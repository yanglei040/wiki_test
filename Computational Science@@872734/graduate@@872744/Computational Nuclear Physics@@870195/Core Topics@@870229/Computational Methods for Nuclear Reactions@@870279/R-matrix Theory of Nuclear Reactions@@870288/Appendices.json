{"hands_on_practices": [{"introduction": "R-matrix theory provides a powerful framework for parameterizing nuclear reactions, but its formal parameters, such as the channel radius $a$, can seem abstract. This exercise bridges the gap between theory and experiment by demonstrating how these parameters connect directly to a measurable physical quantity: the low-energy effective scattering radius $R'$. By working through this derivation [@problem_id:421971], you will gain a deeper appreciation for how the collective influence of distant resonances, captured by the background R-matrix term $R_0^{\\infty}$, shapes observable low-energy scattering phenomena.", "problem": "In the R-matrix theory of nuclear reactions, for a single, non-relativistic, elastic scattering channel of s-wave ($l=0$) neutrons from a spin-zero target nucleus, the scattering phase shift $\\delta_0$ is related to the properties of the compound nucleus system. The relationship can be expressed via the dimensionless R-matrix parameter, $R_0(E)$, as:\n$$\n\\cot(\\delta_0 + ka) = \\frac{1}{ka R_0(E)}\n$$\nHere, $k$ is the neutron wave number, $a$ is the channel radius (the effective radius of the target nucleus), and $E = \\frac{\\hbar^2 k^2}{2m}$ is the center-of-mass energy, with $m$ being the reduced mass.\n\nThe R-matrix parameter $R_0(E)$ contains contributions from all the energy levels (resonances) of the compound nucleus. At very low energies, far from any specific resonance, its value is dominated by the collective effect of many distant levels. This contribution is often denoted as a nearly constant background term, $R_0^\\infty$.\n\nThe low-energy scattering behavior can be characterized by an effective potential scattering radius, $R'$. This parameter is defined by the low-energy limit of the phase shift:\n$$\n\\lim_{k \\to 0} \\frac{\\delta_0}{k} = -R'\n$$\nThis is equivalent to the scattering cross-section at zero energy being $\\sigma(E \\to 0) = 4\\pi (R')^2$.\n\nA theoretical model connects the background R-matrix parameter $R_0^\\infty$ to the dimensionless s-wave neutron strength function, $S_0$. Assume this relationship is given by:\n$$\nR_0^\\infty = -\\zeta S_0\n$$\nwhere $\\zeta$ is a given positive, dimensionless constant of order unity.\n\nUsing this information, derive an expression for the effective potential scattering radius $R'$ in terms of the channel radius $a$, the strength function $S_0$, and the constant $\\zeta$.", "solution": "We start from the R-matrix relation for s-wave scattering,\n$$\n\\cot(\\delta_0 + k a)\\;=\\;\\frac{1}{k\\,a\\,R_0(E)}\\,.\n$$\nAt very low energy, $k \\to 0$, the phase shift defines the effective radius $R'$ by\n$$\n\\delta_0\\;\\approx\\;-\\,k\\,R'\\,,\n\\quad\\Longrightarrow\\quad\n\\delta_0 + k a \\;=\\;k\\bigl(a - R'\\bigr)\\,.\n$$\nMeanwhile the background R-matrix parameter tends to the constant\n$$\nR_0(E)\\;\\to\\;R_0^\\infty\\;=\\;-\\,\\zeta\\,S_0\\,.\n$$\nFor small argument $x=k(a-R')$, use the expansion\n$$\n\\cot x \\approx \\frac{1}{x}\\quad(|x| \\ll 1)\\,,\n$$\nso\n$$\n\\cot(\\delta_0 + ka)\n=\\cot\\bigl(k(a-R')\\bigr)\n\\approx \\frac{1}{k\\,(a-R')}\\,.\n$$\nEquating to the R-matrix form,\n$$\n\\frac{1}{k\\,(a-R')}\n\\;=\\;\\frac{1}{k\\,a\\,R_0^\\infty}\n\\;\\Longrightarrow\\;\n\\frac{1}{a-R'}=\\frac{1}{a\\,R_0^\\infty}\n\\;\\Longrightarrow\\;\na-R'=a\\,R_0^\\infty\\,.\n$$\nHence\n$$\nR'=a - a\\,R_0^\\infty\n=a\\bigl(1 - R_0^\\infty\\bigr)\n=a\\bigl[1 - (-\\zeta S_0)\\bigr]\n=a\\,(1 + \\zeta S_0)\\,.\n$$", "answer": "$$\\boxed{a\\,(1 + \\zeta S_0)}$$", "id": "421971"}, {"introduction": "At the core of any R-matrix calculation lies the inversion of the level matrix, $A(E)$. However, this critical step is fraught with numerical peril, as the matrix can become ill-conditioned or singular, particularly near resonance energies. This hands-on computational exercise [@problem_id:3585517] challenges you to confront this issue by implementing and comparing a naive inversion with a robust, stabilized method using Singular Value Decomposition (SVD), a cornerstone technique for developing reliable scientific software.", "problem": "Consider the multi-level, multi-channel Wigner–Eisenbud $R$-matrix representation of nuclear reactions. The level matrix $A_{\\lambda\\lambda'}(E)$ for $N_\\lambda$ compound-nucleus levels coupled to $N_c$ open channels is defined by the following ingredients:\n\n1. A set of real level energies $E_\\lambda$ in megaelectronvolts (MeV).\n2. Real reduced-width amplitudes $\\gamma_{\\lambda c}$ with units of the square root of energy, specifically $\\sqrt{\\text{MeV}}$, for each level $\\lambda$ and channel $c$.\n3. Real channel boundary-condition constants $B_c$ (dimensionless).\n4. Complex channel functions $L_c(E)$ (dimensionless), with $L_c(E) = S_c(E) + i P_c(E)$, where $S_c(E)$ is the real shift function and $P_c(E)$ is the real penetration factor. In this problem, assume neutral $s$-wave channels with a hard-sphere boundary, so $S_c(E) = 0$ and $P_c(E) = \\rho_c(E)$ with $\\rho_c(E) = k_c(E) a_c$, channel radius $a_c$ in femtometers (fm), reduced mass $\\mu_c$ in megaelectronvolts (MeV) understood as $\\mu_c c^2$, and wave number $k_c(E)$ given by $k_c(E) = \\sqrt{2 \\mu_c E}/(\\hbar c)$. Use $\\hbar c = 197.3269804\\,\\text{MeV}\\cdot\\text{fm}$.\n\nUnder these assumptions, the level matrix is\n$$\nA_{\\lambda\\lambda'}(E) = (E_\\lambda - E)\\,\\delta_{\\lambda\\lambda'} - \\sum_{c=1}^{N_c} \\gamma_{\\lambda c}\\gamma_{\\lambda' c}\\,\\big[L_c(E) - B_c\\big],\n$$\nwhich is generally complex and energy-dependent.\n\nFrom the Wigner–Eisenbud construction, the channel–channel $R$-matrix $R_{cc'}(E)$ is obtained by\n$$\nR_{cc'}(E) = \\sum_{\\lambda=1}^{N_\\lambda}\\sum_{\\lambda'=1}^{N_\\lambda} \\gamma_{\\lambda c}\\,\\big[A^{-1}(E)\\big]_{\\lambda\\lambda'}\\,\\gamma_{\\lambda' c'}.\n$$\nUnder the same hard-sphere simplification with zero hard-sphere phase, the collision (scattering) matrix $U_{cc'}(E)$ is\n$$\nU(E) = I - 2 i\\,P(E)^{1/2}\\,R(E)\\,P(E)^{1/2},\n$$\nwhere $P(E) = \\operatorname{diag}\\big(P_1(E),\\dots,P_{N_c}(E)\\big)$ and $I$ is the $N_c\\times N_c$ identity matrix. The matrix $U(E)$ should be approximately unitary when the model assumptions are satisfied and numerical errors are controlled.\n\nThe inversion of $A(E)$ can be ill-conditioned, especially near resonances where $E \\approx E_\\lambda$ or when reduced-width amplitudes span several orders of magnitude. To improve conditioning, implement a diagonal scaling and a singular value decomposition (SVD) pseudoinverse. Specifically:\n\n1. Construct $A(E)$ from the given inputs.\n2. Compute a naive inverse of $A(E)$ via direct dense inversion when possible.\n3. Compute a scaled-SVD pseudoinverse of $A(E)$:\n   (a) Define a real, positive diagonal scaling matrix $S(E) = \\operatorname{diag}(s_1,\\dots,s_{N_\\lambda})$ with\n   $$\n   s_\\lambda = \\left(|E_\\lambda - E|^2 + \\sum_{c=1}^{N_c} |\\gamma_{\\lambda c}|^2\\,\\big|L_c(E) - B_c\\big|^2\\right)^{-1/2}.\n   $$\n   (b) Form the scaled matrix $A_s(E) = S(E)\\,A(E)\\,S(E)$.\n   (c) Compute the SVD $A_s(E) = U \\Sigma V^\\dagger$ with non-negative singular values $\\sigma_i$ on the diagonal of $\\Sigma$.\n   (d) Form a truncated pseudoinverse $\\Sigma^+$ by replacing each $\\sigma_i$ with $\\sigma_i^{-1}$ if $\\sigma_i \\ge \\tau$, and $0$ otherwise, with a tolerance $\\tau = \\epsilon\\,\\sigma_{\\max}\\,N_\\lambda$, where $\\epsilon$ is machine epsilon for double precision.\n   (e) Set $A_s^+(E) = V\\,\\Sigma^+ U^\\dagger$ and unscale to obtain $A^+(E) \\approx S(E)\\,A_s^+(E)\\,S(E)$ as a stabilized approximation to $A^{-1}(E)$.\n4. Compute $R(E)$ and two versions of $U(E)$: $U_{\\text{naive}}(E)$ from the naive inverse and $U_{\\text{svd}}(E)$ from the scaled-SVD pseudoinverse.\n5. Assess the numerical impact on $U(E)$ using the following diagnostics:\n   (a) The condition number of $A(E)$, defined by $\\kappa\\big(A(E)\\big) = \\sigma_{\\max}/\\sigma_{\\min}$ from the SVD of $A(E)$, with the convention $\\kappa = 10^{18}$ when $\\sigma_{\\min}$ is numerically zero.\n   (b) The condition number of the scaled matrix $A_s(E)$ defined similarly.\n   (c) The deviation from unitarity of $U_{\\text{naive}}(E)$ and $U_{\\text{svd}}(E)$ measured by the Frobenius norm $\\|U^\\dagger U - I\\|_F$.\n   (d) The Frobenius norm $\\|U_{\\text{naive}}(E) - U_{\\text{svd}}(E)\\|_F$.\n\nAll energies must be handled in megaelectronvolts (MeV), masses $\\mu_c$ in MeV (interpreted as $\\mu_c c^2$), and radii $a_c$ in femtometers (fm). Angles do not appear; there is no angle unit to specify. The outputs are dimensionless floats.\n\nImplement a program that computes these quantities for the following fixed data and test suite. Use $N_\\lambda = 3$ levels and $N_c = 2$ channels with the default parameters unless a test case overrides them:\n\n- Levels: $E_\\lambda = [0.30,\\,1.10,\\,2.00]\\,\\text{MeV}$.\n- Reduced masses: $\\mu_1 = 469.0\\,\\text{MeV}$, $\\mu_2 = 931.5\\,\\text{MeV}$.\n- Channel radii: $a_1 = 5.0\\,\\text{fm}$, $a_2 = 5.5\\,\\text{fm}$.\n- Boundary constants: $B_1 = 0.0$, $B_2 = 0.0$.\n- Reduced-width amplitudes in $\\sqrt{\\text{MeV}}$:\n  $$\n  \\gamma = \\begin{bmatrix}\n  0.050 & 0.030\\\\\n  0.020 & 0.040\\\\\n  0.010 & 0.025\n  \\end{bmatrix}.\n  $$\n\nTest suite (each case specifies the energy $E$ in MeV and any overrides):\n\n1. Case 1 (near resonance, default $B_c$ and $\\gamma$): $E = 1.10$.\n2. Case 2 (near threshold, default $B_c$ and $\\gamma$): $E = 0.001$.\n3. Case 3 (higher energy, default $B_c$ and $\\gamma$): $E = 2.00$.\n4. Case 4 (non-zero boundary conditions): $E = 1.10$, $B_1 = 0.30$, $B_2 = -0.20$.\n5. Case 5 (ill-conditioned widths): $E = 1.10$, override\n   $$\n   \\gamma = \\begin{bmatrix}\n   0.0001 & 0.0001\\\\\n   0.2000 & 0.2500\\\\\n   0.0001 & 0.0001\n   \\end{bmatrix}.\n   $$\n\nYour program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets. For each test case, output a list of five floats in the following order:\n$[\\kappa(A),\\,\\kappa(A_s),\\,\\|U_{\\text{naive}}^\\dagger U_{\\text{naive}} - I\\|_F,\\,\\|U_{\\text{svd}}^\\dagger U_{\\text{svd}} - I\\|_F,\\,\\|U_{\\text{naive}} - U_{\\text{svd}}\\|_F]$.\n\nFormat example (with placeholders): \"[[condA1,condAs1,unitNaive1,unitSvd1,diff1],[condA2,condAs2,unitNaive2,unitSvd2,diff2],...]\".", "solution": "The problem statement is critically validated and determined to be valid. It is scientifically grounded in the Wigner-Eisenbud R-matrix theory of nuclear reactions, a well-established formalism in computational nuclear physics. The problem is well-posed, providing a complete and consistent set of definitions, parameters, and equations necessary for a unique numerical solution. The language is objective and precise, and the proposed task—comparing a naive matrix inversion with a stabilized SVD-based pseudoinverse—is a standard and meaningful exercise in numerical analysis applied to physics.\n\nThe solution proceeds by implementing the specified calculations in a step-by-step manner for each test case provided.\n\n**1. R-Matrix Formalism Setup**\nThe calculation begins by defining the energy-dependent quantities for the given $N_c=2$ channels at a specified incident energy $E$. For neutral $s$-wave scattering, the shift function $S_c(E)$ is zero, and the penetration factor $P_c(E)$ is given by $\\rho_c(E) = k_c(E) a_c$. The wave number $k_c(E)$ is calculated using the non-relativistic kinetic energy expression adapted for MeV units:\n$$k_c(E) = \\frac{\\sqrt{2 \\mu_c E}}{\\hbar c}$$\nwhere $\\mu_c$ is the reduced mass in MeV (as $\\mu_c c^2$) and the constant $\\hbar c = 197.3269804\\,\\text{MeV}\\cdot\\text{fm}$. The complex channel function $L_c(E)$ therefore simplifies to $L_c(E) = S_c(E) + i P_c(E) = i P_c(E)$. These quantities are computed for each open channel.\n\n**2. Level Matrix Construction**\nThe $N_\\lambda \\times N_\\lambda$ (in this problem, $3 \\times 3$) complex level matrix $A(E)$ is constructed. Its elements are given by the formula:\n$$A_{\\lambda\\lambda'}(E) = (E_\\lambda - E)\\,\\delta_{\\lambda\\lambda'} - \\sum_{c=1}^{N_c} \\gamma_{\\lambda c}\\,\\gamma_{\\lambda' c}\\,\\big[L_c(E) - B_c\\big]$$\nIn matrix notation, this is expressed as $A(E) = \\operatorname{diag}(E_\\lambda - E) - \\gamma D(E) \\gamma^T$, where $\\gamma$ is the $N_\\lambda \\times N_c$ matrix of reduced-width amplitudes and $D(E)$ is a diagonal $N_c \\times N_c$ matrix with elements $L_c(E) - B_c$. This matrix is complex and symmetric, but not necessarily Hermitian. The term $(E_\\lambda - E)$ on the diagonal can become zero if the energy $E$ matches a level energy $E_\\lambda$, which is a primary source of ill-conditioning.\n\n**3. Naive Inversion and Collision Matrix**\nThe first approach is to compute the inverse of $A(E)$ directly using a standard linear algebra library function.\n$$A^{-1}_{\\text{naive}}(E) = \\operatorname{inv}\\big(A(E)\\big)$$\nThe channel-channel R-matrix $R_{cc'}$ is then computed via matrix multiplication:\n$$R_{\\text{naive}}(E) = \\gamma^T A^{-1}_{\\text{naive}}(E) \\gamma$$\nFinally, the naive collision matrix $U_{\\text{naive}}(E)$ is calculated according to the problem's hard-sphere formula:\n$$U_{\\text{naive}}(E) = I - 2 i\\,P(E)^{1/2}\\,R_{\\text{naive}}(E)\\,P(E)^{1/2}$$\nwhere $I$ is the $N_c \\times N_c$ identity matrix and $P(E)^{1/2}$ is the diagonal matrix with elements $\\sqrt{P_c(E)}$.\n\n**4. Scaled SVD Pseudoinverse Stabilization**\nThe second, more numerically robust method involves several steps to stabilize the inversion of $A(E)$.\n(a) **Scaling**: A diagonal scaling matrix $S(E) = \\operatorname{diag}(s_1, \\dots, s_{N_\\lambda})$ is introduced to precondition the level matrix. The scaling factors are defined to approximately normalize the rows of $A(E)$:\n$$s_\\lambda = \\left(|E_\\lambda - E|^2 + \\sum_{c=1}^{N_c} |\\gamma_{\\lambda c}|^2\\,\\big|L_c(E) - B_c\\big|^2\\right)^{-1/2}$$\nThis results in a real, positive, diagonal matrix $S(E)$.\n(b) **Scaled Matrix**: The original matrix is symmetrically scaled to balance the magnitudes of its elements:\n$$A_s(E) = S(E)\\,A(E)\\,S(E)$$\nThis scaling is designed to improve the condition number of the matrix prior to inversion.\n(c) **SVD**: The singular value decomposition of the scaled matrix $A_s(E)$ is computed:\n$$A_s(E) = U \\Sigma V^\\dagger$$\n(d) **Truncated Pseudoinverse**: A pseudoinverse of the singular value matrix, $\\Sigma^+$, is formed. Singular values $\\sigma_i$ below a certain tolerance $\\tau$ are treated as zero to filter out numerical noise arising from ill-conditioning. The tolerance is defined relative to the largest singular value $\\sigma_{\\max}$ to adapt to the matrix's scale:\n$$\\tau = \\epsilon\\,\\sigma_{\\max}\\,N_\\lambda$$\nwhere $\\epsilon$ is machine epsilon for double-precision floating-point numbers. The diagonal elements of $\\Sigma^+$ are set to $\\sigma_i^{-1}$ if $\\sigma_i \\ge \\tau$, and $0$ otherwise.\n(e) **Unscaling**: The pseudoinverse of the scaled matrix, $A_s^+(E) = V \\Sigma^+ U^\\dagger$, is computed. This is then unscaled to obtain the stabilized pseudoinverse of the original level matrix:\n$$A^+(E) = S(E)\\,A_s^+(E)\\,S(E)$$\n\n**5. SVD-based Collision Matrix**\nUsing this stabilized pseudoinverse $A^+(E)$, the corresponding R-matrix and collision matrix are calculated analogously to the naive case:\n$$R_{\\text{svd}}(E) = \\gamma^T A^+(E) \\gamma$$\n$$U_{\\text{svd}}(E) = I - 2 i\\,P(E)^{1/2}\\,R_{\\text{svd}}(E)\\,P(E)^{1/2}$$\n\n**6. Numerical Diagnostics**\nTo compare the two methods, five diagnostics are computed for each test case:\n- **Condition Numbers**: $\\kappa(A)$ and $\\kappa(A_s)$, calculated as the ratio $\\sigma_{\\max}/\\sigma_{\\min}$ from the SVD of the respective matrices. A value of $10^{18}$ is assigned if $\\sigma_{\\min}$ is numerically indistinguishable from zero, signifying singularity or extreme ill-conditioning.\n- **Unitarity Deviation**: The deviation of $U$ from a unitary matrix is quantified by the Frobenius norm $\\|U^\\dagger U - I\\|_F$ for both $U_{\\text{naive}}$ and $U_{\\text{svd}}$. For a complete model space, $U$ should be unitary; deviation from this property highlights numerical errors.\n- **Method Difference**: The Frobenius norm of the difference, $\\|U_{\\text{naive}} - U_{\\text{svd}}\\|_F$, measures how much the stabilization procedure alters the final physical observable. A large difference suggests that the naive method is producing unreliable results.\n\nThe algorithm is applied to each of the five test cases, and the resulting set of five diagnostic values for each case is collected and formatted into the required output structure.", "answer": "```python\nimport numpy as np\n\n# A meticulous and exacting professor in the STEM fields.\n\ndef solve():\n    \"\"\"\n    Main function to run the R-matrix calculations for all test cases.\n    \"\"\"\n    # Global constants for the calculation\n    HBARC = 197.3269804  # MeV*fm\n    MACHINE_EPSILON = np.finfo(np.float64).eps\n    ILL_COND_THRESHOLD = 1e-18  # Threshold to declare a matrix singular for condition number\n\n    # Default parameters as specified in the problem\n    DEFAULT_E_LAMBDA = np.array([0.30, 1.10, 2.00])\n    DEFAULT_MU_C = np.array([469.0, 931.5])  # in MeV\n    DEFAULT_A_C = np.array([5.0, 5.5])  # in fm\n    DEFAULT_B_C = np.array([0.0, 0.0])\n    DEFAULT_GAMMA = np.array([\n        [0.050, 0.030],\n        [0.020, 0.040],\n        [0.010, 0.025]\n    ])  # in sqrt(MeV)\n\n    def calculate_diagnostics(E, E_lambda, mu_c, a_c, B_c, gamma):\n        \"\"\"\n        Performs the R-matrix calculations for a given set of parameters.\n        \"\"\"\n        N_lambda = len(E_lambda)\n        N_c = len(mu_c)\n\n        if E < 0:\n            raise ValueError(\"Energy E must be non-negative.\")\n        \n        # Step A: Calculate channel-dependent quantities\n        k_c = np.sqrt(2 * mu_c * E) / HBARC\n        P_c = k_c * a_c\n        L_c = 1j * P_c  # S_c(E) = 0 for simplified hard-sphere channels\n\n        # Step B: Construct the level matrix A(E)\n        A = np.diag(E_lambda - E).astype(np.complex128)\n        for c in range(N_c):\n            gamma_c_vec = gamma[:, c:c+1]\n            A -= (gamma_c_vec @ gamma_c_vec.T) * (L_c[c] - B_c[c])\n\n        # Step C: Compute diagnostics for A(E)\n        s_A = np.linalg.svd(A, compute_uv=False)\n        sigma_max_A = np.max(s_A) if s_A.size > 0 else 0\n        sigma_min_A = np.min(s_A) if s_A.size > 0 else 0\n        \n        if sigma_min_A < ILL_COND_THRESHOLD:\n            kappa_A = 1e18\n        else:\n            kappa_A = sigma_max_A / sigma_min_A\n\n        # Step D: Naive inversion and collision matrix\n        try:\n            A_inv_naive = np.linalg.inv(A)\n            R_naive = gamma.T @ A_inv_naive @ gamma\n            P_sqrt_mat = np.diag(np.sqrt(P_c))\n            U_naive = np.eye(N_c, dtype=np.complex128) - 2j * (P_sqrt_mat @ R_naive @ P_sqrt_mat)\n            unitarity_naive = np.linalg.norm(U_naive.conj().T @ U_naive - np.eye(N_c), 'fro')\n        except np.linalg.LinAlgError:\n            U_naive = np.full((N_c, N_c), np.nan, dtype=np.complex128)\n            unitarity_naive = np.inf\n\n        # Step E: Scaled SVD pseudoinverse\n        # (a) Define scaling matrix S\n        s_lambda = np.zeros(N_lambda)\n        for l_idx in range(N_lambda):\n            term1_sq = (E_lambda[l_idx] - E)**2\n            term2 = sum(gamma[l_idx, c_idx]**2 * np.abs(L_c[c_idx] - B_c[c_idx])**2 for c_idx in range(N_c))\n            s_lambda[l_idx] = 1.0 / np.sqrt(term1_sq + term2) if (term1_sq + term2) > 0 else 1.0\n        S_mat = np.diag(s_lambda)\n        \n        # (b) Form scaled matrix A_s\n        A_s = S_mat @ A @ S_mat\n        \n        # (c) Compute SVD of A_s and its condition number\n        U_s, s_s, Vh_s = np.linalg.svd(A_s)\n        sigma_max_As = np.max(s_s) if s_s.size > 0 else 0\n        sigma_min_As = np.min(s_s) if s_s.size > 0 else 0\n        \n        if sigma_min_As < ILL_COND_THRESHOLD:\n            kappa_As = 1e18\n        else:\n            kappa_As = sigma_max_As / sigma_min_As\n\n        # (d) Form truncated pseudoinverse of singular values\n        tau = MACHINE_EPSILON * sigma_max_As * N_lambda\n        s_plus_diag_vals = np.array([1/s if s >= tau else 0 for s in s_s])\n        Sigma_plus = np.zeros((A_s.shape[0], A_s.shape[1]), dtype=np.complex128)\n        np.fill_diagonal(Sigma_plus, s_plus_diag_vals)\n        \n\n        # (e) Compute pseudoinverse A_plus\n        As_plus = Vh_s.conj().T @ Sigma_plus.T @ U_s.conj().T\n        A_plus = S_mat @ As_plus @ S_mat\n\n        # Step F: Calculate R_svd and U_svd\n        R_svd = gamma.T @ A_plus @ gamma\n        P_sqrt_mat = np.diag(np.sqrt(P_c))\n        U_svd = np.eye(N_c, dtype=np.complex128) - 2j * (P_sqrt_mat @ R_svd @ P_sqrt_mat)\n\n        # Step G: Compute final diagnostics\n        unitarity_svd = np.linalg.norm(U_svd.conj().T @ U_svd - np.eye(N_c), 'fro')\n        diff_U = np.linalg.norm(U_naive - U_svd, 'fro') if not np.any(np.isnan(U_naive)) else np.inf\n\n        return [kappa_A, kappa_As, unitarity_naive, unitarity_svd, diff_U]\n\n    test_cases = [\n        # Case 1: E on a resonance, default params\n        {'E': 1.10, 'B_c': DEFAULT_B_C, 'gamma': DEFAULT_GAMMA},\n        # Case 2: Near threshold, default params\n        {'E': 0.001, 'B_c': DEFAULT_B_C, 'gamma': DEFAULT_GAMMA},\n        # Case 3: E on another resonance, default params\n        {'E': 2.00, 'B_c': DEFAULT_B_C, 'gamma': DEFAULT_GAMMA},\n        # Case 4: Non-zero boundary conditions\n        {'E': 1.10, 'B_c': np.array([0.30, -0.20]), 'gamma': DEFAULT_GAMMA},\n        # Case 5: Ill-conditioned widths\n        {'E': 1.10, 'B_c': DEFAULT_B_C, 'gamma': np.array([\n            [0.0001, 0.0001],\n            [0.2000, 0.2500],\n            [0.0001, 0.0001]\n        ])}\n    ]\n\n    results = []\n    for case in test_cases:\n        res = calculate_diagnostics(\n            case['E'],\n            DEFAULT_E_LAMBDA,\n            DEFAULT_MU_C,\n            DEFAULT_A_C,\n            case['B_c'],\n            case['gamma']\n        )\n        results.append(res)\n    \n    # Format the final output string exactly as specified, without spaces\n    print(str(results).replace(\"'\", \"\").replace(' ', ''))\n\nsolve()\n```", "id": "3585517"}, {"introduction": "Beyond numerical stability, computational efficiency is a key concern in practical R-matrix applications, especially when modeling systems with a large number of resonance levels but only a few open reaction channels. This advanced coding practice [@problem_id:3585560] guides you to exploit the low-rank structure of the level matrix's coupling term to dramatically accelerate its inversion. You will derive and implement an elegant solution, related to the Sherman-Morrison-Woodbury identity, showcasing a powerful optimization strategy used in state-of-the-art nuclear data evaluation codes.", "problem": "Consider a many-level, few-channel formulation of the R-matrix theory of nuclear reactions where the level matrix depends on the energy $E$ and the coupling vectors. In the Wigner–Eisenbud formalism with channel boundary conditions chosen so that the boundary constant equals the shift function, the level matrix can be written as\n$$\nA(E) = D(E) + U\\,W(E)\\,U^{\\mathsf T},\n$$\nwhere $D(E)$ is a diagonal matrix of size $N \\times N$ with entries $d_\\lambda(E) = E_\\lambda - E$ for each level index $\\lambda = 1,\\dots,N$, $U$ is the $N \\times C$ matrix whose columns are the level-to-channel reduced width amplitude vectors $\\gamma_c$ for channel indices $c = 1,\\dots,C$, and $W(E)$ is a diagonal $C \\times C$ matrix with entries $w_c(E) = i\\,P_c(E)$, with $i$ the imaginary unit and $P_c(E)$ the penetration factor of channel $c$ at energy $E$. This structure reflects the low-rank property of the coupling term because $U\\,W(E)\\,U^{\\mathsf T}$ has rank at most $C$ even when $N \\gg C$.\n\nFor the single-channel neutral $s$-wave case, the penetration factor can be modeled as $P(E) = k(E)\\,a$, where $k(E) = \\sqrt{2\\,\\mu\\,E}/\\hbar$ is the wave number, $\\mu$ is the reduced mass, $a$ is the channel radius, and $\\hbar$ is the reduced Planck constant. Using the conventional units for computational nuclear physics, take $\\hbar c = 197.3269804$ MeV·fm, so that $k(E)$ can be computed from $E$ in mega-electron-volts (MeV), $\\mu$ in MeV$/c^2$, and $a$ in femtometers (fm), yielding a dimensionless penetration factor $P(E)$. For multi-channel cases, define a distinct $P_c(E) = k_c(E)\\,a_c$ per channel with corresponding $\\mu_c$ and $a_c$.\n\nThe channel-channel R-matrix is defined by\n$$\nR(E) = U^{\\mathsf T}\\,A(E)^{-1}\\,U,\n$$\nwhich is a $C \\times C$ complex symmetric matrix. With the boundary constant equal to the shift function (so the real dispersive shift is absorbed), the collision matrix (also known as the scattering matrix) reduces to\n$$\nU(E) = I_C - 2i\\,P(E)^{1/2}\\,R(E)\\,P(E)^{1/2},\n$$\nwhere $I_C$ is the $C \\times C$ identity matrix and $P(E)^{1/2}$ is the diagonal matrix with entries $\\sqrt{P_c(E)}$. This $U(E)$ is unitary in the ideal mathematical model.\n\nYour task is to design and implement a program that, for a specified set of level energies $E_\\lambda$, reduced width amplitudes in $U$, and channel parameters $(\\mu_c, a_c)$, computes $U(E)$ across several energies using two inversion strategies for $A(E)$:\n- A direct dense inversion of $A(E)$.\n- An inversion update that leverages the low-rank structure of $U\\,W(E)\\,U^{\\mathsf T}$ starting from $D(E)$ and applying a principled matrix identity to avoid inverting the full $N \\times N$ matrix.\n\nYou must:\n1. Start from foundational linear algebra and R-matrix definitions and derive, implement, and use the efficient inverse update mathematically guaranteed for low-rank modifications to a diagonal matrix without relying on any pre-stated shortcut formulas.\n2. Compute the collision matrix $U(E)$ using both inversions for each energy and quantify the numerical error as the maximum absolute entrywise difference between the two $U(E)$ matrices for each energy.\n3. Aggregate the error per test case as the maximum over the specified energy set.\n4. Express all energies in mega-electron-volts (MeV), masses in mega-electron-volts per speed of light squared (MeV$/c^2$), radii in femtometers (fm), and report the final errors as dimensionless floats.\n5. Ensure numerical stability by avoiding energies that make any diagonal entry of $D(E)$ exactly zero.\n\nTest Suite and Parameters:\n- Case 1 (single channel, off- and near-resonance, neutral $s$-wave):\n  - Levels: $N=3$, with $E_\\lambda = [0.2,\\,1.0,\\,3.0]$ MeV.\n  - Reduced mass: $\\mu = 469.5$ MeV$/c^2$.\n  - Channel radius: $a = 5.0$ fm.\n  - Reduced width amplitudes: $\\gamma = [0.06,\\,0.02,\\,0.01]$ in $\\sqrt{\\text{MeV}}$.\n  - Energies: $E = [0.05,\\,0.1999,\\,0.5,\\,1.0]$ MeV.\n- Case 2 (single channel, near threshold):\n  - Levels: $N=5$, with $E_\\lambda = [0.01,\\,0.5,\\,1.5,\\,2.5,\\,4.0]$ MeV.\n  - Reduced mass: $\\mu = 469.5$ MeV$/c^2$.\n  - Channel radius: $a = 5.0$ fm.\n  - Reduced width amplitudes: $\\gamma = [0.03,\\,0.015,\\,0.008,\\,0.004,\\,0.002]$ in $\\sqrt{\\text{MeV}}$.\n  - Energies: $E = [10^{-6},\\,10^{-4},\\,10^{-2}]$ MeV.\n- Case 3 (two channels, multi-level):\n  - Levels: $N=4$, with $E_\\lambda = [0.4,\\,0.8,\\,1.6,\\,2.8]$ MeV.\n  - Channel 1: $\\mu_1 = 469.5$ MeV$/c^2$, $a_1 = 4.5$ fm, reduced width amplitudes $\\gamma_1 = [0.05,\\,0.02,\\,0.03,\\,0.01]$ in $\\sqrt{\\text{MeV}}$.\n  - Channel 2: $\\mu_2 = 300.0$ MeV$/c^2$, $a_2 = 6.0$ fm, reduced width amplitudes $\\gamma_2 = [0.04,\\,0.015,\\,0.02,\\,0.008]$ in $\\sqrt{\\text{MeV}}$.\n  - Energies: $E = [0.3,\\,0.8,\\,1.6,\\,2.5]$ MeV.\n- Case 4 (single channel, ill-conditioned near resonance):\n  - Levels: $N=3$, with $E_\\lambda = [1.0000,\\,1.5000,\\,2.0000]$ MeV.\n  - Reduced mass: $\\mu = 469.5$ MeV$/c^2$.\n  - Channel radius: $a = 5.0$ fm.\n  - Reduced width amplitudes: $\\gamma = [0.10,\\,0.05,\\,0.02]$ in $\\sqrt{\\text{MeV}}$.\n  - Energies: $E = [0.9999,\\,1.0001,\\,1.2]$ MeV.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where each $r_j$ is the maximum absolute entrywise difference between the two computed collision matrices $U(E)$ across the energies for the $j$-th case, reported as a float in a dimensionless unit.", "solution": "The problem requires the computation of the nuclear collision matrix, denoted $U(E)$, using two distinct computational strategies for inverting the level matrix $A(E)$. The results from these two methods, direct inversion and an efficient low-rank update, will be compared to quantify the numerical error. The theoretical foundation is the R-matrix theory of nuclear reactions.\n\n### Theoretical Framework\n\nThe problem is situated within the Wigner–Eisenbud formulation of R-matrix theory. The key quantities are defined as follows:\n\n1.  **Level Matrix, $A(E)$**: An $N \\times N$ complex matrix, where $N$ is the number of included resonance levels.\n    $$A(E) = D(E) + U\\,W(E)\\,U^{\\mathsf T}$$\n    -   $D(E)$ is a diagonal matrix with entries $d_\\lambda(E) = E_\\lambda - E$, where $E_\\lambda$ are the level energies and $E$ is the scattering energy.\n    -   $U$ is an $N \\times C$ real matrix whose columns are the reduced width amplitude vectors $\\gamma_c$ for each of the $C$ reaction channels. An element $U_{\\lambda c}$ corresponds to the amplitude $\\gamma_{\\lambda c}$.\n    -   $W(E)$ is a $C \\times C$ diagonal matrix with entries $w_c(E) = i\\,P_c(E)$, where $i$ is the imaginary unit and $P_c(E)$ is the penetration factor for channel $c$.\n\n2.  **Penetration Factor, $P_c(E)$**: For a neutral particle in an $s$-wave ($l=0$) channel, this is given by $P_c(E) = k_c(E)\\,a_c$.\n    -   $k_c(E)$ is the wave number, $k_c(E) = \\sqrt{2\\mu_c E}/\\hbar$. Using the provided constant $\\hbar c = 197.3269804 \\text{ MeV}\\cdot\\text{fm}$, and expressing the reduced mass $\\mu_c$ in $\\text{MeV}/c^2$ and energy $E$ in MeV, the wave number in units of $\\text{fm}^{-1}$ is:\n        $$k_c(E) = \\frac{\\sqrt{2(\\mu_c c^2)E}}{\\hbar c}$$\n    -   $a_c$ is the channel radius in fm, making $P_c(E)$ a dimensionless quantity.\n\n3.  **R-Matrix, $R(E)$**: A $C \\times C$ complex symmetric matrix that relates the value of the wave function to its derivative on the boundary of the internal region. It is calculated via the level matrix inverse:\n    $$R(E) = U^{\\mathsf T}\\,A(E)^{-1}\\,U$$\n\n4.  **Collision Matrix, $U(E)$**: A $C \\times C$ unitary matrix whose elements $U_{cc'}(E)$ relate incoming and outgoing wave amplitudes. Under the specified boundary conditions, it is given by:\n    $$U(E) = I_C - 2i\\,P(E)^{1/2}\\,R(E)\\,P(E)^{1/2}$$\n    -   $I_C$ is the $C \\times C$ identity matrix.\n    -   $P(E)^{1/2}$ is the diagonal matrix with entries $\\sqrt{P_c(E)}$. Since $E > 0$ and $\\mu_c > 0$, $P_c(E)$ is real and non-negative, so its square root is well-defined and real.\n\n### Computational Methods for $A(E)^{-1}$\n\nThe core task is to compute $R(E)$, which requires the inverse of $A(E)$. We will implement two methods.\n\n**Method 1: Direct Dense Inversion**\n\nThis is the most straightforward approach. For a given energy $E$:\n1.  Construct the $N \\times N$ diagonal matrix $D(E)$.\n2.  Construct the $N \\times C$ matrix $U$ and the $C \\times C$ diagonal matrix $W(E)$.\n3.  Compute the full $N \\times N$ matrix $A(E) = D(E) + U\\,W(E)\\,U^{\\mathsf T}$.\n4.  Invert $A(E)$ using a standard numerical linear algebra routine to obtain $A(E)^{-1}$.\n5.  Compute the R-matrix: $R_{\\text{direct}}(E) = U^{\\mathsf T}\\,A(E)^{-1}\\,U$.\n\nThis method is computationally expensive for large $N$, with the matrix inversion step typically scaling as $\\mathcal{O}(N^3)$. It can also suffer from numerical instability if $A(E)$ is ill-conditioned, which can occur near a resonance energy $E_\\lambda$.\n\n**Method 2: Low-Rank Update Inversion**\n\nThis method exploits the fact that the term $U\\,W(E)\\,U^{\\mathsf T}$ is a low-rank update to the simple diagonal matrix $D(E)$. The rank of the update is at most $C$, the number of channels, which is typically much smaller than $N$. We can derive a more efficient expression for $R(E)$ without explicitly forming or inverting the full $N \\times N$ matrix $A(E)$. The derivation proceeds as follows, starting from the definition of $R(E)$ and the inverse of $A(E)$:\n\nLet $x$ be an $N \\times C$ matrix defined as $x = A(E)^{-1}U$. Then by definition, the R-matrix is $R(E) = U^{\\mathsf T}x$.\nWe can write an equation for $x$ by multiplying by $A(E)$:\n$$A(E)x = U$$\nSubstitute the expression for $A(E)$:\n$$(D(E) + U\\,W(E)\\,U^{\\mathsf T})x = U$$\nExpand the left side:\n$$D(E)x + U\\,W(E)\\,(U^{\\mathsf T}x) = U$$\nRecognize that the term in parentheses, $U^{\\mathsf T}x$, is the R-matrix $R(E)$:\n$$D(E)x + U\\,W(E)\\,R(E) = U$$\nSince $D(E)$ is diagonal, its inverse $D(E)^{-1}$ is also a diagonal matrix with entries $1/(E_\\lambda - E)$, and is trivial to compute provided $E \\neq E_\\lambda$ for all $\\lambda$. We can solve for $x$:\n$$D(E)x = U - U\\,W(E)\\,R(E) = U(I_C - W(E)\\,R(E))$$\n$$x = D(E)^{-1}\\,U\\,(I_C - W(E)\\,R(E))$$\nNow, substitute this expression for $x$ back into the definition of the R-matrix, $R(E) = U^{\\mathsf T}x$:\n$$R(E) = U^{\\mathsf T}\\,[D(E)^{-1}\\,U\\,(I_C - W(E)\\,R(E))]$$\n$$R(E) = (U^{\\mathsf T}D(E)^{-1}U)\\,(I_C - W(E)\\,R(E))$$\nLet us define the $C \\times C$ matrix $Z(E) = U^{\\mathsf T}D(E)^{-1}U$. This matrix is central to the efficient method. Its elements are given by $Z_{cd}(E) = \\sum_{\\lambda=1}^N \\frac{\\gamma_{\\lambda c} \\gamma_{\\lambda d}}{E_\\lambda - E}$. The equation becomes:\n$$R(E) = Z(E)\\,(I_C - W(E)\\,R(E)) = Z(E) - Z(E)\\,W(E)\\,R(E)$$\nWe can now algebraically solve for $R(E)$:\n$$R(E) + Z(E)\\,W(E)\\,R(E) = Z(E)$$\n$$(I_C + Z(E)\\,W(E))\\,R(E) = Z(E)$$\nFinally, provided the matrix $(I_C + Z(E)W(E))$ is invertible, we obtain the expression for the R-matrix:\n$$R_{\\text{update}}(E) = (I_C + Z(E)\\,W(E))^{-1} \\, Z(E)$$\nThis derivation fulfills the requirement of starting from first principles. The computational advantage is substantial: the most expensive step is the inversion of a $C \\times C$ matrix, which scales as $\\mathcal{O}(C^3)$. Since $C \\ll N$ in many practical applications, this is far more efficient than the $\\mathcal{O}(N^3)$ scaling of the direct method.\n\n### Implementation and Error Analysis\n\nThe algorithm for the comparison is as follows. For each test case:\n1.  Initialize a maximum error for the case, $\\epsilon_{\\text{max}} = 0$.\n2.  Iterate through each specified scattering energy $E$.\n3.  At each $E$, compute the collision matrix $U_{\\text{direct}}(E)$ using the direct inversion method for $R(E)$.\n4.  At the same $E$, compute $U_{\\text{update}}(E)$ using the low-rank update method for $R(E)$.\n5.  Calculate the element-wise absolute difference matrix, $\\Delta U(E) = |U_{\\text{direct}}(E) - U_{\\text{update}}(E)|$.\n6.  Find the maximum entry in this difference matrix, $\\epsilon(E) = \\max_{ij} \\Delta U_{ij}(E)$.\n7.  Update the case maximum error: $\\epsilon_{\\text{max}} = \\max(\\epsilon_{\\text{max}}, \\epsilon(E))$.\n8.  After iterating through all energies, the final result for the test case is $\\epsilon_{\\text{max}}$.\n\nThis procedure will be carried out for all four test cases, and the resulting maximum errors will be reported. This comparison serves as a verification of the derived low-rank update formula and also highlights potential numerical precision differences between the two mathematically equivalent paths.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the R-matrix problem for four test cases, comparing direct and \n    low-rank update inversion methods for the collision matrix.\n    \"\"\"\n    HBAR_C = 197.3269804  # MeV·fm\n\n    def get_P_matrices(E, mu_vec, a_vec):\n        \"\"\"Calculates the diagonal P(E) and P(E)^(1/2) matrices.\"\"\"\n        C = len(mu_vec)\n        p_diag = np.zeros(C, dtype=np.float64)\n        for c in range(C):\n            # E can be zero or very close to it, sqrt will be handled correctly.\n            # The calculation is valid for E >= 0.\n            if E >= 0:\n                k_c = np.sqrt(2 * mu_vec[c] * E) / HBAR_C\n                p_diag[c] = k_c * a_vec[c]\n        \n        P_matrix = np.diag(p_diag)\n        P_sqrt_matrix = np.diag(np.sqrt(p_diag))\n        return P_matrix, P_sqrt_matrix\n\n    def calculate_U_direct(E, E_levels, U_mat, mu_vec, a_vec):\n        \"\"\"Computes the collision matrix U(E) using direct inversion.\"\"\"\n        N, C = U_mat.shape\n        I_C = np.identity(C, dtype=np.complex128)\n        \n        # Diagonal matrix D(E)\n        d_diag = E_levels - E\n        D_matrix = np.diag(d_diag)\n\n        # Diagonal matrix W(E)\n        P_matrix, P_sqrt_matrix = get_P_matrices(E, mu_vec, a_vec)\n        W_matrix = 1j * P_matrix\n        \n        # Level matrix A(E)\n        A_matrix = D_matrix.astype(np.complex128) + U_mat @ W_matrix @ U_mat.T\n        \n        # R-matrix R(E)\n        try:\n            A_inv = np.linalg.inv(A_matrix)\n        except np.linalg.LinAlgError:\n            # This should not happen with the given test cases, but is good practice.\n            return np.full((C, C), np.nan, dtype=np.complex128)\n            \n        R_matrix = U_mat.T @ A_inv @ U_mat\n        \n        # Collision matrix U(E)\n        U_collision_matrix = I_C - 2j * P_sqrt_matrix @ R_matrix @ P_sqrt_matrix\n        \n        return U_collision_matrix\n\n    def calculate_U_update(E, E_levels, U_mat, mu_vec, a_vec):\n        \"\"\"Computes the collision matrix U(E) using the low-rank update method.\"\"\"\n        N, C = U_mat.shape\n        I_C = np.identity(C, dtype=np.complex128)\n\n        # Inverse of D(E)\n        d_inv_diag = 1.0 / (E_levels - E)\n        D_inv_matrix = np.diag(d_inv_diag)\n        \n        # Z(E) matrix\n        Z_matrix = U_mat.T @ D_inv_matrix.astype(np.complex128) @ U_mat\n        \n        # W(E) matrix and P_sqrt\n        P_matrix, P_sqrt_matrix = get_P_matrices(E, mu_vec, a_vec)\n        W_matrix = 1j * P_matrix\n        \n        # R-matrix R(E) using the derived formula\n        M_matrix = I_C + Z_matrix @ W_matrix\n        \n        try:\n            M_inv = np.linalg.inv(M_matrix)\n        except np.linalg.LinAlgError:\n            return np.full((C, C), np.nan, dtype=np.complex128)\n            \n        R_matrix = M_inv @ Z_matrix\n        \n        # Collision matrix U(E)\n        U_collision_matrix = I_C - 2j * P_sqrt_matrix @ R_matrix @ P_sqrt_matrix\n        \n        return U_collision_matrix\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        { # Case 1\n            \"E_levels\": np.array([0.2, 1.0, 3.0]),\n            \"U_mat\": np.array([[0.06], [0.02], [0.01]]),\n            \"mu_vec\": np.array([469.5]),\n            \"a_vec\": np.array([5.0]),\n            \"energies\": np.array([0.05, 0.1999, 0.5, 1.0])\n        },\n        { # Case 2\n            \"E_levels\": np.array([0.01, 0.5, 1.5, 2.5, 4.0]),\n            \"U_mat\": np.array([[0.03], [0.015], [0.008], [0.004], [0.002]]),\n            \"mu_vec\": np.array([469.5]),\n            \"a_vec\": np.array([5.0]),\n            \"energies\": np.array([1e-6, 1e-4, 1e-2])\n        },\n        { # Case 3\n            \"E_levels\": np.array([0.4, 0.8, 1.6, 2.8]),\n            \"U_mat\": np.array([\n                [0.05, 0.04], [0.02, 0.015], [0.03, 0.02], [0.01, 0.008]\n            ]),\n            \"mu_vec\": np.array([469.5, 300.0]),\n            \"a_vec\": np.array([4.5, 6.0]),\n            \"energies\": np.array([0.3, 0.8, 1.6, 2.5])\n        },\n        { # Case 4\n            \"E_levels\": np.array([1.0, 1.5, 2.0]),\n            \"U_mat\": np.array([[0.10], [0.05], [0.02]]),\n            \"mu_vec\": np.array([469.5]),\n            \"a_vec\": np.array([5.0]),\n            \"energies\": np.array([0.9999, 1.0001, 1.2])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        max_case_error = 0.0\n        for E in case[\"energies\"]:\n            U_direct = calculate_U_direct(E, case[\"E_levels\"], case[\"U_mat\"], case[\"mu_vec\"], case[\"a_vec\"])\n            U_update = calculate_U_update(E, case[\"E_levels\"], case[\"U_mat\"], case[\"mu_vec\"], case[\"a_vec\"])\n\n            # Quantify numerical error\n            error_E = np.max(np.abs(U_direct - U_update))\n            if error_E > max_case_error:\n                max_case_error = error_E\n        \n        results.append(max_case_error)\n\n    # Format output as specified\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3585560"}]}