{"hands_on_practices": [{"introduction": "The cornerstone of chiral effective field theory ($\\\\chi$EFT) is its systematic power counting, which organizes contributions to physical observables in an expansion in powers of a small parameter $Q/\\Lambda_\\chi$. This principle not only provides a hierarchy of interactions but also allows us to estimate the theoretical uncertainty arising from truncating the EFT expansion at a finite order. This first exercise provides a direct, hands-on calculation of this truncation error, connecting the abstract idea of power counting to a tangible prediction for a key nuclear observable [@problem_id:3549489].", "problem": "In chiral Effective Field Theory (EFT) for nucleon-nucleon (NN) interactions, systematic truncation errors arise from expanding observables in powers of a small, dimensionless ratio of scales. The fundamental basis for this estimate is the separation of scales: low-energy physics governed by a typical soft scale $Q$ and high-energy physics encapsulated by a breakdown scale $\\Lambda_{\\chi}$. The small parameter is $x$ defined by $x=Q/\\Lambda_{\\chi}$, and the EFT power counting states that higher-order contributions are suppressed by increasing powers of $x$. Assuming coefficients of natural size (order unity) and that next-to-next-to-next-to-leading order (N3LO) corrections scale as $x^{4}$ relative to leading order (LO), estimate the fractional size of N3LO corrections for a typical soft scale $Q=200\\ \\mathrm{MeV}$ and breakdown scale $\\Lambda_{\\chi}=1\\ \\mathrm{GeV}$. Then, translate this fractional estimate into an expected truncation error for an NN observable by taking the LO prediction for the deuteron binding energy to be $B_{\\mathrm{LO}}=2.20\\ \\mathrm{MeV}$. Express the final truncation error in $\\mathrm{MeV}$ and round your answer to four significant figures.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- The dimensionless expansion parameter is $x = Q/\\Lambda_{\\chi}$.\n- $Q$ is the typical soft scale.\n- $\\Lambda_{\\chi}$ is the breakdown scale.\n- Next-to-next-to-next-to-leading order (N3LO) corrections scale as $x^{4}$ relative to leading order (LO).\n- The value of the soft scale is $Q = 200 \\ \\mathrm{MeV}$.\n- The value of the breakdown scale is $\\Lambda_{\\chi} = 1 \\ \\mathrm{GeV}$.\n- The LO prediction for the deuteron binding energy is $B_{\\mathrm{LO}} = 2.20 \\ \\mathrm{MeV}$.\n- The final answer for the truncation error must be expressed in $\\mathrm{MeV}$ and rounded to four significant figures.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem is based on the well-established principles of chiral Effective Field Theory (EFT), a cornerstone of modern nuclear physics. The power counting scheme ($x = Q/\\Lambda_{\\chi}$), the scaling of higher-order terms, and the values for the soft scale ($Q$) and breakdown scale ($\\Lambda_{\\chi}$) are standard and physically motivated. The given LO deuteron binding energy is a realistic value. The problem is fundamentally sound.\n- **Well-Posed**: The problem provides all necessary information and a clear objective: to calculate a specific numerical value based on the provided model. A unique solution exists.\n- **Objective**: The language is precise, technical, and free of any subjective or ambiguous terminology.\n- **Completeness and Consistency**: The problem is self-contained. All required data ($Q$, $\\Lambda_{\\chi}$, $B_{\\mathrm{LO}}$, scaling power) are provided. There are no internal contradictions. Units require conversion, but are consistent ($\\mathrm{MeV}$ and $\\mathrm{GeV}$).\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid** as it is scientifically grounded, well-posed, and internally consistent. A solution will be provided.\n\nThe core of the problem is to estimate the size of the N3LO correction to an observable, which serves as a proxy for the truncation error of the EFT expansion at the preceding order.\n\nFirst, we calculate the dimensionless expansion parameter, $x$. We are given the soft scale $Q = 200 \\ \\mathrm{MeV}$ and the breakdown scale $\\Lambda_{\\chi} = 1 \\ \\mathrm{GeV}$. To compute their ratio, we must express them in consistent units. We convert $\\Lambda_{\\chi}$ from gigaelectronvolts ($\\mathrm{GeV}$) to megaelectronvolts ($\\mathrm{MeV}$):\n$$\n\\Lambda_{\\chi} = 1 \\ \\mathrm{GeV} = 1000 \\ \\mathrm{MeV}\n$$\nNow we can compute $x$:\n$$\nx = \\frac{Q}{\\Lambda_{\\chi}} = \\frac{200 \\ \\mathrm{MeV}}{1000 \\ \\mathrm{MeV}} = \\frac{2}{10} = 0.2\n$$\nThe problem states that N3LO corrections scale as $x^{4}$ relative to the LO contribution. This implies that the fractional size of the N3LO correction, which we denote as $\\epsilon_{\\mathrm{N3LO}}$, is of the order of $x^{4}$. Assuming the dimensionless coefficients that multiply this factor are of order unity (a standard assumption in EFT for \"natural\" theories), we can estimate the fractional error as:\n$$\n\\epsilon_{\\mathrm{N3LO}} \\approx x^{4}\n$$\nSubstituting the value of $x$:\n$$\n\\epsilon_{\\mathrm{N3LO}} = (0.2)^{4} = \\left(\\frac{1}{5}\\right)^{4} = \\frac{1}{625} = 0.0016\n$$\nThe truncation error is estimated by the magnitude of the first neglected term in the series. The problem asks us to find the size of the N3LO correction, which we will denote as $\\delta B_{\\mathrm{N3LO}}$. This is found by multiplying the fractional size of the correction by the LO value of the observable, $B_{\\mathrm{LO}} = 2.20 \\ \\mathrm{MeV}$.\n$$\n\\delta B_{\\mathrm{N3LO}} = \\epsilon_{\\mathrm{N3LO}} \\times B_{\\mathrm{LO}}\n$$\nSubstituting the numerical values:\n$$\n\\delta B_{\\mathrm{N3LO}} = 0.0016 \\times 2.20 \\ \\mathrm{MeV} = 0.00352 \\ \\mathrm{MeV}\n$$\nThe problem requires the final answer to be rounded to four significant figures. The calculated value is $0.00352 \\ \\mathrm{MeV}$. The first non-zero digit is $3$, which is the first significant figure. Counting four figures from there gives us $3$, $5$, $2$, and a trailing $0$.\n$$\n\\delta B_{\\mathrm{N3LO}} \\approx 0.003520 \\ \\mathrm{MeV}\n$$\nThis value represents the expected magnitude of the N3LO contribution to the deuteron binding energy and serves as the standard estimate for the truncation error of the N2LO calculation.", "answer": "$$\n\\boxed{0.003520}\n$$", "id": "3549489"}, {"introduction": "While long-range physics in $\\chi$EFT is dictated by pion exchanges, the unresolved short-range dynamics are parameterized by contact interactions with associated low-energy constants (LECs). A key task in computational nuclear physics is to determine these LECs by fitting to experimental data. This process is intimately tied to renormalization, as the loop integrals in the theory must be regularized, making the bare LECs dependent on the chosen regulator and cutoff scale. This computational practice delves into this fundamental procedure, exploring how to fit an LEC and analyze its cutoff dependence—a direct window into the renormalization group flow of the theory [@problem_id:3549517].", "problem": "Consider two-nucleon scattering in the triplet $P$-wave channels $^{3}P_{0}$ and $^{3}P_{2}$ within chiral effective field theory at Leading Order (LO). Leading Order (LO) refers to the lowest order in the power-counting expansion, and Low-Energy Constant (LEC) refers to the coefficient that multiplies the short-range contact interaction. In a computational setup, model the $P$-wave contact interaction in momentum space by a separable form $V(k',k) = C \\, g(k') g(k)$, where $C$ is the LEC for the channel and $g(k)$ is a regulator-dependent form factor that encodes the ultraviolet behavior.\n\nUse the following regulator families, which are representative of nonlocal, local-like, and semilocal regularization strategies frequently employed in nuclear effective field theory:\n- Nonlocal regulator: $g_{\\mathrm{NL}}(k;\\Lambda) = k \\exp\\!\\left(-\\left(\\frac{k}{\\Lambda}\\right)^{4}\\right)$.\n- Local-like regulator: $g_{\\mathrm{L}}(k;\\Lambda) = k \\left(\\frac{\\Lambda^{2}}{\\Lambda^{2}+k^{2}}\\right)^{2}$.\n- Semilocal regulator: $g_{\\mathrm{SL}}(k;\\Lambda) = k \\exp\\!\\left(-\\left(\\frac{k}{\\Lambda}\\right)^{2}\\right) \\left(\\frac{\\Lambda^{2}}{\\Lambda^{2}+k^{2}}\\right)$.\n\nThe reduced mass is $\\mu$, and the on-shell partial-wave amplitude for orbital angular momentum $l$ satisfies the Lippmann–Schwinger equation in partial waves and the standard relation to the scattering amplitude. For the $P$-wave ($l=1$), the low-energy behavior of the phase shift is defined by $$k^{3} \\cot \\delta_{1}(k) = -\\frac{1}{a_{1}} + \\frac{1}{2} r_{1} k^{2} + \\cdots$$, where $a_{1}$ is the scattering volume and $r_{1}$ is the $P$-wave effective range parameter. The partial-wave $T$-matrix $T_{1}(k,k;E)$ is related to the phase shift via the standard nonrelativistic scattering relations and, in the low-energy limit $k \\to 0$, satisfies $T_{1}(k,k;E) \\sim -\\frac{2\\pi}{\\mu} k^{2} a_{1}$.\n\nStarting from the Lippmann–Schwinger equation for separable potentials in the $P$-wave channel and the above low-energy relations, derive from first principles how to determine the LEC $C(\\Lambda)$ that reproduces a given target $P$-wave scattering volume $a_{1}$ at zero energy for each regulator choice. Implement a numerical procedure to compute the loop integral entering the Lippmann–Schwinger equation at zero energy, and fit $C(\\Lambda)$ for variable cutoff $\\Lambda$ by imposing the matching condition to the specified $a_{1}$.\n\nAdopt natural units where $\\hbar = c = 1$, take the reduced mass to be $\\mu = \\frac{1}{2}$ (dimensionless), and treat all momenta and inverse lengths as dimensionless. The scattering volume $a_{1}$ is then expressed in dimensionless units of inverse momentum cubed. The program must implement the integral with respect to $k$ using a numerically stable quadrature over $k \\in [0,\\infty)$ truncated at a sufficiently large upper limit that guarantees convergence for the given regulator. Use a single consistent truncation strategy that is justifiable across all regulator forms.\n\nTo diagnose power-counting consistency, evaluate the cutoff flow of the fitted LECs $C(\\Lambda)$ over sets of $\\Lambda$ values and extract the scaling exponent $s$ from a least-squares fit of $\\log |C(\\Lambda)|$ versus $\\log \\Lambda$. In the renormalization group sense, the expected leading scaling for a pure $P$-wave contact interaction is $|C(\\Lambda)| \\propto \\Lambda^{-3}$ at large $\\Lambda$. Define a boolean diagnostic for consistency by checking whether $|s + 3| \\le \\tau$, where $\\tau$ is a tolerance.\n\nYour program must compute the slope $s$ and the consistency boolean for the following test suite of cases, each specified by a regulator type, a channel with its target scattering volume $a_{1}$, and a list of cutoff values $\\Lambda$:\n- Case $1$: Regulator $g_{\\mathrm{NL}}$, channel $^{3}P_{0}$ with target $a_{1} = -0.35$, and $\\Lambda$ values $[1.5, 2.0, 2.5, 3.0, 3.5]$.\n- Case $2$: Regulator $g_{\\mathrm{L}}$, channel $^{3}P_{2}$ with target $a_{1} = 0.20$, and $\\Lambda$ values $[4.0, 5.0, 7.5, 10.0]$.\n- Case $3$: Regulator $g_{\\mathrm{SL}}$, channel $^{3}P_{0}$ with target $a_{1} = -0.35$, and $\\Lambda$ values $[2.0, 4.0, 8.0, 16.0]$.\n- Case $4$: Regulator $g_{\\mathrm{NL}}$, channel $^{3}P_{2}$ with target $a_{1} = 0.20$, and $\\Lambda$ values $[0.75, 1.0, 1.25, 1.5]$.\n- Case $5$: Regulator $g_{\\mathrm{L}}$, channel $^{3}P_{0}$ with target $a_{1} = -0.35$, and $\\Lambda$ values $[8.0, 12.0, 16.0, 20.0]$.\n\nUse tolerance $\\tau = 0.25$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case’s result is a two-element list $[s, b]$ with $s$ a floating-point number and $b$ the boolean diagnostic. For example, the output format must be of the form $[[s_{1},b_{1}],[s_{2},b_{2}],\\ldots,[s_{5},b_{5}]]$, with no additional text. No physical units should appear in the output.", "solution": "The problem as stated is valid. It is scientifically grounded in the principles of nonrelativistic quantum scattering theory and chiral effective field theory, it is well-posed with sufficient information to derive a unique solution, and it is expressed in objective, precise language. We may therefore proceed with a solution.\n\nThe solution is developed in two stages. First, we derive the analytical relationship between the low-energy constant (LEC) $C$ and the $P$-wave scattering volume $a_1$. Second, we outline the numerical procedure to compute $C(\\Lambda)$ for various cutoffs $\\Lambda$, fit the scaling behavior, and evaluate its consistency with theoretical expectations.\n\n**1. Derivation of the Low-Energy Constant $C(\\Lambda)$**\n\nThe starting point is the partial-wave Lippmann-Schwinger (LS) equation for the off-shell $T$-matrix, $T_l(p', p; E)$, which describes the scattering process. In a common normalization scheme used in nuclear physics, this equation reads:\n$$\nT_l(p', p; E) = V_l(p', p) + \\frac{2}{\\pi} \\int_0^\\infty dq \\, q^2 \\, V_l(p', q) \\, \\frac{1}{k^2 - q^2 + i\\epsilon} \\, T_l(q, p; E)\n$$\nHere, $l$ is the orbital angular momentum, $p$ and $p'$ are the initial and final relative momenta, and $q$ is the loop momentum. The energy is related to the on-shell momentum $k$ by $E = k^2/(2\\mu)$, where $\\mu$ is the reduced mass. The problem specifies natural units ($\\hbar=1$) and $\\mu = 1/2$, so $E=k^2$. The potential $V_l(p', p)$ is the partial-wave projected interaction.\n\nFor the $P$-wave channel ($l=1$), the problem specifies a separable contact interaction of the form:\n$$\nV_1(p', p) = C \\, g(p') \\, g(p)\n$$\nwhere $C$ is the LEC to be determined and $g(p)$ is a regulator function dependent on a cutoff $\\Lambda$. Substituting this separable form into the LS equation yields:\n$$\nT_1(p', p; k^2) = C g(p') g(p) + \\frac{2}{\\pi} \\int_0^\\infty dq \\, q^2 \\, C g(p') g(q) \\, \\frac{1}{k^2 - q^2 + i\\epsilon} \\, T_1(q, p; k^2)\n$$\nThe structure of this equation implies that the $T$-matrix must also be separable, of the form $T_1(p', p; k^2) = \\tau(k) g(p') g(p)$. Inserting this ansatz:\n$$\n\\tau(k) g(p') g(p) = C g(p') g(p) + C g(p') \\left( \\frac{2}{\\pi} \\int_0^\\infty dq \\, q^2 \\, \\frac{g(q) \\tau(k) g(q) g(p)}{k^2-q^2+i\\epsilon} \\right)\n$$\nDividing by the common factor $g(p') g(p)$, we obtain an algebraic equation for $\\tau(k)$:\n$$\n\\tau(k) = C + C \\tau(k) \\, I(k)\n$$\nwhere $I(k)$ is the loop integral:\n$$\nI(k) = \\frac{2}{\\pi} \\int_0^\\infty dq \\, q^2 \\, \\frac{[g(q)]^2}{k^2 - q^2 + i\\epsilon}\n$$\nSolving for $\\tau(k)$ gives:\n$$\n\\tau(k) = \\frac{C}{1 - C I(k)}\n$$\nThe on-shell $T$-matrix is obtained by setting $p' = p = k$:\n$$\nT_1(k, k; k^2) = \\tau(k) [g(k)]^2 = \\frac{C [g(k)]^2}{1 - C I(k)}\n$$\nWe are interested in the zero-energy limit ($k \\to 0$) to relate this to the scattering volume $a_1$. In this limit, the imaginary part of the propagator vanishes, and the principal value integral simplifies. The loop integral becomes:\n$$\nI(k \\to 0) = I(0) = \\frac{2}{\\pi} \\mathcal{P} \\int_0^\\infty dq \\, q^2 \\, \\frac{[g(q)]^2}{-q^2} = -\\frac{2}{\\pi} \\int_0^\\infty dq \\, [g(q;\\Lambda)]^2\n$$\nLet us define the regulator-dependent integral as:\n$$\nI_0(\\Lambda) = \\int_0^\\infty [g(q;\\Lambda)]^2 dq\n$$\nThus, $I(0) = -\\frac{2}{\\pi} I_0(\\Lambda)$. The provided regulator forms $g(k;\\Lambda)$ all have the property $g(k;\\Lambda) \\sim k$ as $k \\to 0$. Therefore, the numerator $[g(k)]^2 \\sim k^2$. The on-shell $T$-matrix in the low-energy limit is:\n$$\nT_1(k, k; k^2 \\to 0) \\approx \\frac{C k^2}{1 - C \\left(-\\frac{2}{\\pi} I_0(\\Lambda)\\right)} = \\frac{C k^2}{1 + \\frac{2C}{\\pi} I_0(\\Lambda)}\n$$\nThe problem provides the low-energy relation $T_{1}(k,k;E) \\sim -\\frac{2\\pi}{\\mu} k^{2} a_{1}$. With $\\mu=1/2$, this becomes $T_{1} \\sim -4\\pi k^{2} a_{1}$. Equating the two expressions for the $T$-matrix and canceling the non-zero factor $k^2$:\n$$\n-4\\pi a_{1} = \\frac{C}{1 + \\frac{2C}{\\pi} I_0(\\Lambda)}\n$$\nThis equation establishes the matching condition between the theoretical parameter $C$ and the observable $a_1$. We now solve for $C$ as a function of $\\Lambda$ and $a_1$:\n$$\n-4\\pi a_{1} \\left(1 + \\frac{2C}{\\pi} I_0(\\Lambda)\\right) = C\n$$\n$$\n-4\\pi a_{1} = C + 8 a_{1} C I_0(\\Lambda) = C(1 + 8 a_{1} I_0(\\Lambda))\n$$\nFinally, we arrive at the expression for the LEC required to reproduce the scattering volume $a_1$:\n$$\nC(\\Lambda) = \\frac{-4\\pi a_{1}}{1 + 8 a_{1} I_0(\\Lambda)}\n$$\n\n**2. Numerical and Analytical Procedure**\n\nThe algorithm to solve the problem proceeds as follows for each test case:\n1.  **Select Regulator**: Choose the specified regulator function $g(k;\\Lambda)$ from the set $\\{g_{\\mathrm{NL}}, g_{\\mathrm{L}}, g_{\\mathrm{SL}}\\}$.\n2.  **Compute LECs**: For each cutoff value $\\Lambda$ in the provided list:\n    a.  **Numerical Integration**: Compute the integral $I_0(\\Lambda) = \\int_0^\\infty [g(q;\\Lambda)]^2 dq$. The integrands are well-behaved, decaying rapidly as $q \\to \\infty$, making them suitable for standard numerical quadrature routines. We will use `scipy.integrate.quad` over the domain $[0, \\infty)$, which is a robust method for such definite integrals.\n    b.  **LEC Calculation**: Substitute the computed value of $I_0(\\Lambda)$ and the given target scattering volume $a_1$ into the derived formula to find the corresponding value of the LEC, $C(\\Lambda)$.\n3.  **Fit Scaling Exponent**: After computing the set of pairs $(\\Lambda_i, C(\\Lambda_i))$, we analyze the scaling of $C(\\Lambda)$ with $\\Lambda$. The expected power-counting behavior is $|C(\\Lambda)| \\propto \\Lambda^{-3}$, which implies a linear relationship in a log-log plot:\n    $$\n    \\log|C(\\Lambda)| = s \\log\\Lambda + \\text{const.}\n    $$\n    The scaling exponent $s$ is the slope of this line. We perform a linear least-squares regression on the set of data points $\\{(\\log\\Lambda_i, \\log|C(\\Lambda_i)|)\\}$ to extract the slope $s$. The `scipy.stats.linregress` function is ideally suited for this task.\n4.  **Power-Counting Consistency Check**: The theoretical expectation is $s=-3$. We define a boolean diagnostic $b$ to check if the numerically determined slope $s$ is consistent with this expectation within a given tolerance $\\tau=0.25$. The condition is:\n    $$\n    b = (|s + 3| \\le \\tau)\n    $$\n5.  **Output Generation**: The final result for each case is the pair $[s, b]$, consisting of the floating-point slope and the boolean diagnostic. These results are aggregated and formatted into the specified string representation.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Computes the scaling exponent for P-wave contact interaction LECs in chiral EFT.\n    \"\"\"\n\n    # Tolerance for the consistency check\n    TOLERANCE_TAU = 0.25\n\n    # --- Regulator function definitions ---\n    def g_nl(k, Lambda):\n        \"\"\"Nonlocal regulator form factor.\"\"\"\n        ratio = k / Lambda\n        return k * np.exp(-ratio**4)\n\n    def g_l(k, Lambda):\n        \"\"\"Local-like regulator form factor.\"\"\"\n        ratio_sq = (k / Lambda)**2\n        return k * (1.0 / (1.0 + ratio_sq))**2\n\n    def g_sl(k, Lambda):\n        \"\"\"Semilocal regulator form factor.\"\"\"\n        ratio_sq = (k / Lambda)**2\n        return k * np.exp(-ratio_sq) * (1.0 / (1.0 + ratio_sq))\n\n    # --- Integrands for the loop integral I_0 ---\n    # The integrand is g(r, Lambda)^2\n    def integrand_nl(r, Lambda):\n        return g_nl(r, Lambda)**2\n\n    def integrand_l(r, Lambda):\n        return g_l(r, Lambda)**2\n\n    def integrand_sl(r, Lambda):\n        return g_sl(r, Lambda)**2\n\n    # Map regulator names to their corresponding integrand functions\n    REGULATORS = {\n        'g_NL': integrand_nl,\n        'g_L': integrand_l,\n        'g_SL': integrand_sl\n    }\n\n    # --- Test suite definition ---\n    test_cases = [\n        {'regulator': 'g_NL', 'channel': '3P0', 'a1': -0.35, 'lambdas': [1.5, 2.0, 2.5, 3.0, 3.5]},\n        {'regulator': 'g_L', 'channel': '3P2', 'a1': 0.20, 'lambdas': [4.0, 5.0, 7.5, 10.0]},\n        {'regulator': 'g_SL', 'channel': '3P0', 'a1': -0.35, 'lambdas': [2.0, 4.0, 8.0, 16.0]},\n        {'regulator': 'g_NL', 'channel': '3P2', 'a1': 0.20, 'lambdas': [0.75, 1.0, 1.25, 1.5]},\n        {'regulator': 'g_L', 'channel': '3P0', 'a1': -0.35, 'lambdas': [8.0, 12.0, 16.0, 20.0]}\n    ]\n\n    def calculate_c(a1, Lambda, integrand_func):\n        \"\"\"\n        Calculates the LEC C(Lambda) for a given a1 and Lambda.\n        \"\"\"\n        # I_0(Lambda) = integral from 0 to inf of [g(r, Lambda)]^2 dr\n        # The quad function returns a tuple (result, error_estimate)\n        i0, _ = quad(integrand_func, 0, np.inf, args=(Lambda,))\n        \n        # C(Lambda) = -4*pi*a1 / (1 + 8*a1*I_0)\n        numerator = -4.0 * np.pi * a1\n        denominator = 1.0 + 8.0 * a1 * i0\n        \n        if np.isclose(denominator, 0):\n            # Pole corresponds to infinite scattering volume, not expected here.\n            return np.nan\n            \n        return numerator / denominator\n\n    results = []\n    for case in test_cases:\n        regulator_key = case['regulator']\n        a1 = case['a1']\n        lambdas = np.array(case['lambdas'])\n        \n        integrand_func = REGULATORS[regulator_key]\n        \n        log_lambdas = []\n        log_abs_cs = []\n        \n        for L in lambdas:\n            C_val = calculate_c(a1, L, integrand_func)\n            if not np.isnan(C_val):\n                log_lambdas.append(np.log(L))\n                log_abs_cs.append(np.log(np.abs(C_val)))\n        \n        # Perform linear regression to find the slope s\n        if len(log_lambdas) > 1:\n            lin_reg_result = linregress(log_lambdas, log_abs_cs)\n            slope_s = lin_reg_result.slope\n        else:\n            # Not enough points to determine a slope\n            slope_s = np.nan\n        \n        # P-wave power-counting consistency check\n        is_consistent = np.abs(slope_s + 3.0) <= TOLERANCE_TAU\n        \n        results.append([slope_s, is_consistent])\n\n    # Format the final output string exactly as specified\n    output_parts = []\n    for s, b in results:\n        # Convert boolean to lowercase 'true'/'false' for consistent output\n        b_str = 'true' if b else 'false'\n        output_parts.append(f\"[{s},{b_str}]\")\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3549517"}, {"introduction": "Building upon the task of fitting parameters, modern analyses in $\\chi$EFT employ sophisticated statistical methods to achieve a comprehensive understanding of parameter and model uncertainties. Instead of finding a single best-fit point, the goal is to determine the full posterior probability distribution for the LECs. This Bayesian approach provides a rigorous framework for combining information from experimental data and theoretical priors, while consistently propagating all sources of uncertainty, including the intrinsic truncation error of the EFT itself. This advanced practice guides you through the implementation of a modern Bayesian analysis, demonstrating how to construct a correlated likelihood and derive the posterior distribution for a set of LECs from scattering data [@problem_id:3549505].", "problem": "You are asked to implement a computational nuclear physics analysis grounded in chiral effective field theory for nuclear interactions. Specifically, you must perform a global fit of nucleon-nucleon contact low-energy constants at next-to-leading order (NLO) to phase-shift data across multiple partial waves using a correlated likelihood, and compute posterior distributions that incorporate truncation uncertainties. The analysis must be performed in a mathematically precise way, starting from established fundamental principles.\n\nThe base of the derivation must be:\n- Bayes’ theorem relating the posterior distribution to the product of the likelihood and the prior.\n- The correlated Gaussian likelihood for data with covariance, where the total covariance is the sum of experimental covariance and theoretical truncation uncertainty covariance.\n- The assumption of a linear model for phase shifts at NLO in terms of the low-energy constants across multiple partial waves.\n\nThe model representation must adhere to the following setup:\n- Consider four partial waves: the spin-singlet s-wave ${}^{1}\\!S_{0}$, the spin-triplet s-wave ${}^{3}\\!S_{1}$, the spin-singlet p-wave ${}^{1}\\!P_{1}$, and the spin-triplet p-wave ${}^{3}\\!P_{0}$.\n- Let the laboratory kinetic energies be $E \\in \\{5,10,25,50\\}\\,\\mathrm{MeV}$, and compute the center-of-mass momentum $p$ in $\\mathrm{fm}^{-1}$ using $p(E) = \\sqrt{m_N E / 2}/(\\hbar c)$, where $m_N = 938.92\\,\\mathrm{MeV}$ and $\\hbar c = 197.327\\,\\mathrm{MeV\\,fm}$.\n- Define the expansion parameter $Q(E) = p(E)/\\Lambda_b$, where $\\Lambda_b$ is the breakdown scale in $\\mathrm{fm}^{-1}$.\n- Use a linear-in-parameters model for the phase shifts in radians:\n  - For ${}^{1}\\!S_{0}$: $$\\delta_{{}^{1}\\!S_{0}}(E) = \\theta_1 + \\theta_2 Q(E)^2$$\n  - For ${}^{3}\\!S_{1}$: $$\\delta_{{}^{3}\\!S_{1}}(E) = \\theta_3 + \\theta_4 Q(E)^2$$\n  - For ${}^{1}\\!P_{1}$: $$\\delta_{{}^{1}\\!P_{1}}(E) = \\theta_5 Q(E)^2$$\n  - For ${}^{3}\\!P_{0}$: $$\\delta_{{}^{3}\\!P_{0}}(E) = \\theta_6 Q(E)^2$$\n- Assume a Gaussian naturalness prior for the parameter vector $\\boldsymbol{\\theta} \\in \\mathbb{R}^6$ with zero mean and diagonal covariance $\\Sigma_{\\mathrm{prior}} = \\mathrm{diag}(s_\\theta^2,\\dots,s_\\theta^2)$.\n\nExperimental data specification:\n- The observed phase-shift data in radians for each partial wave at the energies $E \\in \\{5,10,25,50\\}\\,\\mathrm{MeV}$ are given by:\n  - ${}^{1}\\!S_{0}$: $\\{\\;0.195844,\\;0.190963,\\;0.175844,\\;0.149863\\;\\}$.\n  - ${}^{3}\\!S_{1}$: $\\{\\;0.047859,\\;0.044993,\\;0.035884,\\;0.019973\\;\\}$.\n  - ${}^{1}\\!P_{1}$: $\\{\\;0.003227,\\;0.005729,\\;0.012652,\\;0.023618\\;\\}$.\n  - ${}^{3}\\!P_{0}$: $\\{\\;0.000543,\\;0.000361,\\;-0.000732,\\;-0.003202\\;\\}$.\n- The experimental measurement uncertainties are $\\sigma_{\\mathrm{exp},S} = 0.002\\,\\mathrm{rad}$ for s-waves (both ${}^{1}\\!S_{0}$ and ${}^{3}\\!S_{1}$) and $\\sigma_{\\mathrm{exp},P} = 0.003\\,\\mathrm{rad}$ for p-waves (both ${}^{1}\\!P_{1}$ and ${}^{3}\\!P_{0}$).\n- The experimental covariance is block-correlated within each partial wave according to a correlation coefficient $r_{\\mathrm{exp}}$ for all off-diagonal pairs within that block, and zero correlation across different partial waves; i.e., for each partial wave block with $N_E$ energies, define\n  $$\\Sigma_{\\mathrm{exp,block}} = \\sigma_{\\mathrm{exp}}^2 \\left[(1-r_{\\mathrm{exp}}) I_{N_E} + r_{\\mathrm{exp}} \\mathbf{1}\\mathbf{1}^\\top\\right],$$\n  where $I_{N_E}$ is the identity matrix of size $N_E$ and $\\mathbf{1}$ is the vector of ones of length $N_E$.\n\nTheoretical truncation uncertainty model:\n- Model the standard deviation of the truncation uncertainty at NLO for each datum as $\\sigma_{\\mathrm{th}}(E) = \\bar c \\, Q(E)^2$, where $\\bar c$ is a constant amplitude parameter (in radians).\n- Impose correlations across energies with a kernel $K(E_i,E_j) = \\exp\\left(-\\frac{|p(E_i) - p(E_j)|}{\\lambda_{\\mathrm{th}}}\\right)$, where $\\lambda_{\\mathrm{th}}$ is a correlation length in $\\mathrm{fm}^{-1}$.\n- Impose correlations across partial waves via a factor $\\rho_{\\mathrm{pw}}$: $1$ for the same partial wave and $\\rho_{\\mathrm{pw}}$ for different partial waves.\n- The theoretical covariance is then\n  $$\\left[\\Sigma_{\\mathrm{th}}\\right]_{ij} = \\sigma_{\\mathrm{th}}(E_i)\\,\\sigma_{\\mathrm{th}}(E_j)\\,K(E_i,E_j)\\,\\chi_{\\mathrm{pw}}(i,j),$$\n  where $\\chi_{\\mathrm{pw}}(i,j) = 1$ if $i$ and $j$ belong to the same partial wave and $\\chi_{\\mathrm{pw}}(i,j) = \\rho_{\\mathrm{pw}}$ otherwise.\n\nLikelihood:\n- Let $\\mathbf{y} \\in \\mathbb{R}^{N}$ be the data vector of concatenated phase shifts across waves and energies, and let $A \\in \\mathbb{R}^{N \\times 6}$ be the design matrix formed from the model basis functions described above. The correlated Gaussian likelihood is\n  $$\\mathcal{L}(\\mathbf{y} \\mid \\boldsymbol{\\theta}) \\propto \\exp\\left(-\\tfrac{1}{2}(\\mathbf{y} - A\\boldsymbol{\\theta})^\\top \\Sigma^{-1} (\\mathbf{y} - A\\boldsymbol{\\theta})\\right),$$\n  where $\\Sigma = \\Sigma_{\\mathrm{exp}} + \\Sigma_{\\mathrm{th}}$ is the total covariance.\n\nYour task:\n- Derive and implement the posterior distribution for $\\boldsymbol{\\theta}$ under the linear-Gaussian assumptions stated above, using the specified likelihood and prior.\n- Compute the posterior mean vector and the posterior standard deviations (the square roots of the posterior covariance diagonal).\n- Use the energy values and phase-shift data provided above (radians).\n- Ensure all internal calculations use radians and momenta in $\\mathrm{fm}^{-1}$, and that the expansion parameter $Q$ is dimensionless.\n\nTest suite:\n- Implement the analysis for the following three parameter sets, each defining a test case:\n  1. Case A (baseline): $\\Lambda_b = 3.0\\,\\mathrm{fm}^{-1}$, $\\lambda_{\\mathrm{th}} = 0.3\\,\\mathrm{fm}^{-1}$, $\\rho_{\\mathrm{pw}} = 0.2$, $\\bar c = 0.1\\,\\mathrm{rad}$, $s_\\theta = 1.0$, $r_{\\mathrm{exp},S} = 0.3$, $r_{\\mathrm{exp},P} = 0.2$.\n  2. Case B (small $Q$ and weak theory correlation): $\\Lambda_b = 5.0\\,\\mathrm{fm}^{-1}$, $\\lambda_{\\mathrm{th}} = 0.1\\,\\mathrm{fm}^{-1}$, $\\rho_{\\mathrm{pw}} = 0.1$, $\\bar c = 0.08\\,\\mathrm{rad}$, $s_\\theta = 2.0$, $r_{\\mathrm{exp},S} = 0.2$, $r_{\\mathrm{exp},P} = 0.1$.\n  3. Case C (strong experimental correlation): $\\Lambda_b = 2.5\\,\\mathrm{fm}^{-1}$, $\\lambda_{\\mathrm{th}} = 0.5\\,\\mathrm{fm}^{-1}$, $\\rho_{\\mathrm{pw}} = 0.4$, $\\bar c = 0.12\\,\\mathrm{rad}$, $s_\\theta = 0.5$, $r_{\\mathrm{exp},S} = 0.9$, $r_{\\mathrm{exp},P} = 0.8$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output a list of $12$ floats containing the posterior means followed by the posterior standard deviations for $\\theta_1,\\dots,\\theta_6$. Thus the final output must be a list of three lists:\n  $$\\big[\\,[\\mu_1,\\mu_2,\\mu_3,\\mu_4,\\mu_5,\\mu_6,\\sigma_1,\\sigma_2,\\sigma_3,\\sigma_4,\\sigma_5,\\sigma_6],\\,\\text{case B},\\,\\text{case C}\\,\\big],$$\n  where all numbers are unitless and represent angles (phase shifts) in radians for consistency of the model. The final print statement must match this exact format with no additional text.", "solution": "The problem requires a Bayesian analysis to determine the posterior distribution of six low-energy constants, represented by the vector $\\boldsymbol{\\theta} \\in \\mathbb{R}^6$, using nucleon-nucleon scattering phase-shift data. The analysis is founded on a linear-Gaussian model, which permits an analytical derivation of the posterior distribution.\n\nAccording to Bayes' theorem, the posterior probability distribution of the parameters $\\boldsymbol{\\theta}$ given the observed data $\\mathbf{y}$ is proportional to the product of the likelihood of the data given the parameters, $\\mathcal{L}(\\mathbf{y} \\mid \\boldsymbol{\\theta})$, and the prior distribution of the parameters, $p(\\boldsymbol{\\theta})$:\n$$\np(\\boldsymbol{\\theta} \\mid \\mathbf{y}) \\propto \\mathcal{L}(\\mathbf{y} \\mid \\boldsymbol{\\theta}) \\, p(\\boldsymbol{\\theta})\n$$\n\nThe problem details a linear model for the phase shifts, $\\boldsymbol{\\delta}_{\\mathrm{model}}$, as a function of $\\boldsymbol{\\theta}$, which can be expressed in matrix notation as:\n$$\n\\boldsymbol{\\delta}_{\\mathrm{model}}(\\boldsymbol{\\theta}) = A \\boldsymbol{\\theta}\n$$\nIn this equation, $\\mathbf{y}$ is the vector containing the $N=16$ measured phase shifts, and $A$ is the $N \\times 6$ design matrix that encodes the functional dependence of the phase shifts on the parameters $\\theta_j$.\n\nThe likelihood $\\mathcal{L}(\\mathbf{y} \\mid \\boldsymbol{\\theta})$ is defined as a correlated multivariate Gaussian distribution centered on the model prediction $A\\boldsymbol{\\theta}$:\n$$\n\\mathcal{L}(\\mathbf{y} \\mid \\boldsymbol{\\theta}) \\propto \\exp\\left(-\\frac{1}{2}(\\mathbf{y} - A\\boldsymbol{\\theta})^\\top \\Sigma^{-1} (\\mathbf{y} - A\\boldsymbol{\\theta})\\right)\n$$\nThe total covariance matrix $\\Sigma$ is the sum of the experimental covariance matrix $\\Sigma_{\\mathrm{exp}}$ and the theoretical truncation uncertainty covariance matrix $\\Sigma_{\\mathrm{th}}$, such that $\\Sigma = \\Sigma_{\\mathrm{exp}} + \\Sigma_{\\mathrm{th}}$.\n\nThe prior distribution for $\\boldsymbol{\\theta}$ is also specified as a Gaussian, with a mean of zero and a diagonal covariance matrix $\\Sigma_{\\mathrm{prior}} = s_\\theta^2 I_6$, where $I_6$ is the $6 \\times 6$ identity matrix:\n$$\np(\\boldsymbol{\\theta}) \\propto \\exp\\left(-\\frac{1}{2} \\boldsymbol{\\theta}^\\top \\Sigma_{\\mathrm{prior}}^{-1} \\boldsymbol{\\theta}\\right)\n$$\n\nCombining the likelihood and the prior, the exponent of the posterior distribution (the negative log-posterior, up to a constant) becomes the sum of the exponents from the likelihood and the prior:\n$$\n\\chi^2(\\boldsymbol{\\theta}) = (\\mathbf{y} - A\\boldsymbol{\\theta})^\\top \\Sigma^{-1} (\\mathbf{y} - A\\boldsymbol{\\theta}) + \\boldsymbol{\\theta}^\\top \\Sigma_{\\mathrm{prior}}^{-1} \\boldsymbol{\\theta}\n$$\nExpanding the first term yields:\n$$\n\\chi^2(\\boldsymbol{\\theta}) = \\mathbf{y}^\\top \\Sigma^{-1} \\mathbf{y} - 2\\mathbf{y}^\\top \\Sigma^{-1} A \\boldsymbol{\\theta} + \\boldsymbol{\\theta}^\\top A^\\top \\Sigma^{-1} A \\boldsymbol{\\theta} + \\boldsymbol{\\theta}^\\top \\Sigma_{\\mathrm{prior}}^{-1} \\boldsymbol{\\theta}\n$$\nWe can collect terms that are quadratic and linear in $\\boldsymbol{\\theta}$:\n$$\n\\chi^2(\\boldsymbol{\\theta}) = \\boldsymbol{\\theta}^\\top (A^\\top \\Sigma^{-1} A + \\Sigma_{\\mathrm{prior}}^{-1}) \\boldsymbol{\\theta} - 2(\\mathbf{y}^\\top \\Sigma^{-1} A) \\boldsymbol{\\theta} + \\text{const.}\n$$\nThis quadratic form in $\\boldsymbol{\\theta}$ implies that the posterior distribution $p(\\boldsymbol{\\theta} \\mid \\mathbf{y})$ is also a multivariate Gaussian. By completing the square and comparing this form to the standard exponent of a Gaussian, $- \\frac{1}{2}(\\boldsymbol{\\theta}-\\boldsymbol{\\mu}_{\\mathrm{post}})^\\top \\Sigma_{\\mathrm{post}}^{-1}(\\boldsymbol{\\theta}-\\boldsymbol{\\mu}_{\\mathrm{post}})$, we can identify the posterior mean $\\boldsymbol{\\mu}_{\\mathrm{post}}$ and posterior covariance $\\Sigma_{\\mathrm{post}}$. The inverse of the posterior covariance is:\n$$\n\\Sigma_{\\mathrm{post}}^{-1} = A^\\top \\Sigma^{-1} A + \\Sigma_{\\mathrm{prior}}^{-1}\n$$\nThus, the posterior covariance matrix is:\n$$\n\\Sigma_{\\mathrm{post}} = \\left( A^\\top \\Sigma^{-1} A + \\Sigma_{\\mathrm{prior}}^{-1} \\right)^{-1}\n$$\nThe posterior mean is then found to be:\n$$\n\\boldsymbol{\\mu}_{\\mathrm{post}} = \\Sigma_{\\mathrm{post}} (A^\\top \\Sigma^{-1} \\mathbf{y})\n$$\nThe task is to compute $\\boldsymbol{\\mu}_{\\mathrm{post}}$ and the posterior standard deviations. The latter are the square roots of the diagonal elements of $\\Sigma_{\\mathrm{post}}$: $\\sigma_k = \\sqrt{[\\Sigma_{\\mathrm{post}}]_{kk}}$.\n\nThe implementation requires the careful construction of the matrices $A$, $\\Sigma_{\\mathrm{exp}}$, and $\\Sigma_{\\mathrm{th}}$.\n\nFirst, we establish the kinematic variables. The center-of-mass momentum $p$ (in $\\mathrm{fm}^{-1}$) corresponding to a laboratory kinetic energy $E$ is $p(E) = \\sqrt{m_N E / 2}/(\\hbar c)$, using $m_N = 938.92\\,\\mathrm{MeV}$ and $\\hbar c = 197.327\\,\\mathrm{MeV\\,fm}$. The dimensionless expansion parameter is $Q(E) = p(E)/\\Lambda_b$. Data are provided for energies $E \\in \\{5, 10, 25, 50\\}\\,\\mathrm{MeV}$.\n\nThe data vector $\\mathbf{y} \\in \\mathbb{R}^{16}$ is constructed by concatenating the phase-shift data for the four partial waves: ${}^{1}\\!S_{0}$, ${}^{3}\\!S_{1}$, ${}^{1}\\!P_{1}$, and ${}^{3}\\!P_{0}$, in that sequence.\n\nThe $16 \\times 6$ design matrix $A$ is built from the specified linear models for the phase shifts. Let the four energies be indexed by $k=0,1,2,3$.\n- For the ${}^{1}\\!S_{0}$ channel (rows $0-3$), the model is $\\theta_1 + \\theta_2 Q(E_k)^2$. The corresponding rows in $A$ are $[1, Q(E_k)^2, 0, 0, 0, 0]$.\n- For ${}^{3}\\!S_{1}$ (rows $4-7$), the model is $\\theta_3 + \\theta_4 Q(E_k)^2$. The rows are $[0, 0, 1, Q(E_k)^2, 0, 0]$.\n- For ${}^{1}\\!P_{1}$ (rows $8-11$), the model is $\\theta_5 Q(E_k)^2$. The rows are $[0, 0, 0, 0, Q(E_k)^2, 0]$.\n- For ${}^{3}\\!P_{0}$ (rows $12-15$), the model is $\\theta_6 Q(E_k)^2$. The rows are $[0, 0, 0, 0, 0, Q(E_k)^2]$.\n\nThe experimental covariance matrix $\\Sigma_{\\mathrm{exp}}$ is a $16 \\times 16$ block-diagonal matrix, comprising four $4 \\times 4$ blocks, one for each partial wave.\n- For s-waves (${}^{1}\\!S_{0}$, ${}^{3}\\!S_{1}$), the block is $\\Sigma_{\\mathrm{exp,block}} = \\sigma_{\\mathrm{exp},S}^2 \\left[(1-r_{\\mathrm{exp},S}) I_4 + r_{\\mathrm{exp},S} \\mathbf{1}\\mathbf{1}^\\top\\right]$, with $\\sigma_{\\mathrm{exp},S} = 0.002\\,\\mathrm{rad}$.\n- For p-waves (${}^{1}\\!P_{1}$, ${}^{3}\\!P_{0}$), the block is $\\Sigma_{\\mathrm{exp,block}} = \\sigma_{\\mathrm{exp},P}^2 \\left[(1-r_{\\mathrm{exp},P}) I_4 + r_{\\mathrm{exp},P} \\mathbf{1}\\mathbf{1}^\\top\\right]$, with $\\sigma_{\\mathrm{exp},P} = 0.003\\,\\mathrm{rad}$.\n\nThe theoretical covariance matrix $\\Sigma_{\\mathrm{th}}$ is a dense $16 \\times 16$ matrix, with elements given by:\n$$\n\\left[\\Sigma_{\\mathrm{th}}\\right]_{ij} = \\sigma_{\\mathrm{th}}(E_i)\\,\\sigma_{\\mathrm{th}}(E_j)\\,K(E_i,E_j)\\,\\chi_{\\mathrm{pw}}(i,j)\n$$\nwhere $i, j$ are global indices from $0$ to $15$. The component terms are:\n- The standard deviation of the truncation error: $\\sigma_{\\mathrm{th}}(E_k) = \\bar c \\, Q(E_k)^2$.\n- The energy correlation kernel: $K(E_i,E_j) = \\exp\\left(-\\frac{|p(E_i) - p(E_j)|}{\\lambda_{\\mathrm{th}}}\\right)$.\n- The partial-wave correlation factor $\\chi_{\\mathrm{pw}}(i,j)$, which equals $1$ if data points $i$ and $j$ belong to the same partial wave (i.e., $\\lfloor i/4 \\rfloor = \\lfloor j/4 \\rfloor$) and $\\rho_{\\mathrm{pw}}$ otherwise.\n\nFollowing the construction of all matrices, we calculate the total covariance $\\Sigma = \\Sigma_{\\mathrm{exp}} + \\Sigma_{\\mathrm{th}}$ and find its inverse $\\Sigma^{-1}$. The inverse of the prior covariance is $\\Sigma_{\\mathrm{prior}}^{-1} = (1/s_\\theta^2)I_6$. These components are then used in the derived analytical formulas to compute the posterior mean vector $\\boldsymbol{\\mu}_{\\mathrm{post}}$ and the posterior standard deviations $\\sigma_k$. This entire procedure is executed for each of the three test cases specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the analysis for all test cases.\n    \"\"\"\n    \n    # Global problem constants and data\n    M_N = 938.92  # MeV\n    HBAR_C = 197.327  # MeV fm\n    ENERGIES = np.array([5., 10., 25., 50.])  # MeV\n    DATA_PHASESHIFTS = np.array([\n        # 1S0\n        0.195844, 0.190963, 0.175844, 0.149863,\n        # 3S1\n        0.047859, 0.044993, 0.035884, 0.019973,\n        # 1P1\n        0.003227, 0.005729, 0.012652, 0.023618,\n        # 3P0\n        0.000543, 0.000361, -0.000732, -0.003202,\n    ])\n    SIGMA_EXP_S = 0.002  # rad\n    SIGMA_EXP_P = 0.003  # rad\n    NUM_ENERGIES = len(ENERGIES)\n    NUM_PARAMS = 6\n    NUM_DATA = len(DATA_PHASESHIFTS)\n\n    def solve_case(case_params):\n        \"\"\"\n        Solves for the posterior mean and std dev for one set of hyperparameters.\n        \"\"\"\n        lambda_b, lambda_th, rho_pw, c_bar, s_theta, r_exp_s, r_exp_p = case_params\n\n        # Step 1: Calculate kinematic variables (momentum p and expansion param Q)\n        p_vals = np.sqrt(M_N * ENERGIES / 2.0) / HBAR_C  # units of fm^-1\n        q_vals = p_vals / lambda_b\n        \n        p_vec = np.tile(p_vals, NUM_ENERGIES)\n        q_vec = np.tile(q_vals, NUM_ENERGIES)\n        \n        # Step 2: Construct the design matrix A (16x6)\n        A = np.zeros((NUM_DATA, NUM_PARAMS))\n        q2_vals = q_vals**2\n        \n        A[0:NUM_ENERGIES, 0] = 1.0\n        A[0:NUM_ENERGIES, 1] = q2_vals\n        \n        A[NUM_ENERGIES:2*NUM_ENERGIES, 2] = 1.0\n        A[NUM_ENERGIES:2*NUM_ENERGIES, 3] = q2_vals\n        \n        A[2*NUM_ENERGIES:3*NUM_ENERGIES, 4] = q2_vals\n        \n        A[3*NUM_ENERGIES:4*NUM_ENERGIES, 5] = q2_vals\n        \n        # Step 3: Construct the experimental covariance matrix Sigma_exp (16x16)\n        Sigma_exp = np.zeros((NUM_DATA, NUM_DATA))\n        ones_ne = np.ones((NUM_ENERGIES, NUM_ENERGIES))\n        eye_ne = np.eye(NUM_ENERGIES)\n        \n        block_S = SIGMA_EXP_S**2 * ((1 - r_exp_s) * eye_ne + r_exp_s * ones_ne)\n        block_P = SIGMA_EXP_P**2 * ((1 - r_exp_p) * eye_ne + r_exp_p * ones_ne)\n        \n        Sigma_exp[0:NUM_ENERGIES, 0:NUM_ENERGIES] = block_S\n        Sigma_exp[NUM_ENERGIES:2*NUM_ENERGIES, NUM_ENERGIES:2*NUM_ENERGIES] = block_S\n        Sigma_exp[2*NUM_ENERGIES:3*NUM_ENERGIES, 2*NUM_ENERGIES:3*NUM_ENERGIES] = block_P\n        Sigma_exp[3*NUM_ENERGIES:4*NUM_ENERGIES, 3*NUM_ENERGIES:4*NUM_ENERGIES] = block_P\n\n        # Step 4: Construct the theoretical covariance matrix Sigma_th (16x16)\n        sigma_th_vec = c_bar * q_vec**2\n        \n        p_dist_matrix = np.abs(p_vec[:, np.newaxis] - p_vec)\n        K_matrix = np.exp(-p_dist_matrix / lambda_th)\n        \n        wave_indices = np.repeat(np.arange(NUM_ENERGIES), NUM_ENERGIES)\n        chi_pw_matrix = np.where(wave_indices[:, np.newaxis] == wave_indices, 1.0, rho_pw)\n        \n        sigma_th_outer = np.outer(sigma_th_vec, sigma_th_vec)\n        \n        Sigma_th = sigma_th_outer * K_matrix * chi_pw_matrix\n\n        # Step 5: Compute total covariance, its inverse, and prior inverse\n        Sigma_total = Sigma_exp + Sigma_th\n        Sigma_prior_inv = np.eye(NUM_PARAMS) / s_theta**2\n        \n        # Step 6: Calculate posterior mean and covariance\n        Sigma_total_inv = np.linalg.inv(Sigma_total)\n        \n        At_S_inv_A = A.T @ Sigma_total_inv @ A\n        Sigma_post = np.linalg.inv(At_S_inv_A + Sigma_prior_inv)\n        \n        At_S_inv_y = A.T @ Sigma_total_inv @ DATA_PHASESHIFTS\n        mu_post = Sigma_post @ At_S_inv_y\n        \n        std_post = np.sqrt(np.diag(Sigma_post))\n        \n        return mu_post.tolist() + std_post.tolist()\n\n    # Parameter sets for the three test cases\n    # (Lambda_b, lambda_th, rho_pw, c_bar, s_theta, r_exp_S, r_exp_P)\n    test_cases = [\n        (3.0, 0.3, 0.2, 0.1, 1.0, 0.3, 0.2),  # Case A\n        (5.0, 0.1, 0.1, 0.08, 2.0, 0.2, 0.1),  # Case B\n        (2.5, 0.5, 0.4, 0.12, 0.5, 0.9, 0.8),  # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Print the results in the required single-line format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3549505"}]}