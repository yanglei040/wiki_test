{"hands_on_practices": [{"introduction": "Effective shell-model calculations are necessarily performed in a truncated Hilbert space, known as the model space $P$. This exercise provides a foundational, hands-on derivation of the effective Hamiltonian, $H_{\\text{eff}}$, which is designed to act solely within $P$ while correctly reproducing a subset of the eigenvalues of the full Hamiltonian. By applying a unitary decoupling transformation analogous to the Okubo-Lee-Suzuki method, you will see explicitly how couplings to the excluded space $Q$ lead to a renormalized, or \"effective,\" interaction within the model space [@problem_id:3557309]. This is a cornerstone of many-body effective field theories and a critical concept for understanding how interactions are tailored to a specific model space.", "problem": "Consider a Hamiltonian partitioned into a model space $P$ of dimension $2$ and an excluded space $Q$ of dimension $1$. Let the orthonormal basis of $P$ be $\\{|p_{1}\\rangle, |p_{2}\\rangle\\}$ and the basis of $Q$ be $\\{|q\\rangle\\}$. The unperturbed Hamiltonian is $H_{0}$ with\n$$\nH_{0}|p_{i}\\rangle = \\varepsilon_{i}|p_{i}\\rangle \\quad (i=1,2), \\qquad H_{0}|q\\rangle = \\varepsilon_{q}|q\\rangle,\n$$\nand there is a perturbation $V$ that couples only $P$ to $Q$, such that\n$$\n\\langle q|V|p_{i}\\rangle = v_{i}, \\qquad \\langle p_{i}|V|q\\rangle = v_{i}, \\qquad \\langle p_{i}|V|p_{j}\\rangle = 0, \\qquad \\langle q|V|q\\rangle=0,\n$$\nwith $v_{i}\\in\\mathbb{R}$. The full Hamiltonian is $H=H_{0}+g\\,V$, where $g$ is a small, dimensionless coupling strength. Define the projection operators $P=|p_{1}\\rangle\\langle p_{1}|+|p_{2}\\rangle\\langle p_{2}|$ and $Q=|q\\rangle\\langle q|$, and the wave operator $\\omega$ that maps $P$-space components to $Q$-space components for eigenstates of $H$ via $|\\psi_{Q}\\rangle=\\omega\\,|\\psi_{P}\\rangle$.\n\nStarting from the time-independent Schrödinger equation and the projection operator formalism, and using a unitary decoupling approach consistent with the Okubo-Lee-Suzuki (OLS) method and the Schrieffer-Wolff (SW) transformation, do the following:\n\n1. Derive the first-order-in-$g$ expression for the wave operator $\\omega$ (i.e., compute $\\omega$ to order $O(g)$).\n2. Construct the energy-independent, Hermitian effective Hamiltonian $H_{\\mathrm{eff}}$ acting in the model space $P$ to order $O(g^{2})$ by eliminating the $P$-$Q$ coupling through a block-off-diagonal anti-Hermitian generator.\n\nYour final reported quantity should be the closed-form analytic expression for the trace of the effective Hamiltonian, $\\mathrm{Tr}(H_{\\mathrm{eff}})$, correct to order $O(g^{2})$. No numerical values are provided; your answer must be expressed symbolically in terms of $\\varepsilon_{1}$, $\\varepsilon_{2}$, $\\varepsilon_{q}$, $g$, $v_{1}$, and $v_{2}$. The answer must be a single expression. No rounding is required.", "solution": "The problem is well-posed, scientifically grounded in the principles of quantum mechanics and many-body effective field theory, and all necessary parameters are provided for a symbolic solution. The problem is valid.\n\nThe total Hamiltonian is $H = H_0 + gV$, where $H_0$ is the unperturbed part and $gV$ is the interaction. The Hilbert space is partitioned into a model space $P$ and an excluded space $Q$. In the given basis $\\{|p_1\\rangle, |p_2\\rangle, |q\\rangle\\}$, the operators can be represented as matrices.\nThe unperturbed Hamiltonian $H_0$ is diagonal:\n$$\nH_0 = \\begin{pmatrix} \\varepsilon_1 & 0 & 0 \\\\ 0 & \\varepsilon_2 & 0 \\\\ 0 & 0 & \\varepsilon_q \\end{pmatrix}\n$$\nThe perturbation $V$ is purely off-diagonal between the $P$ and $Q$ spaces:\n$$\nV = \\begin{pmatrix} 0 & 0 & v_1 \\\\ 0 & 0 & v_2 \\\\ v_1 & v_2 & 0 \\end{pmatrix}\n$$\nThe problem requires the use of a unitary transformation $U = e^S$ to block-diagonalize the full Hamiltonian $H = H_0 + gV$. The generator $S$ must be anti-Hermitian ($S^\\dagger = -S$) and block-off-diagonal, coupling only the $P$ and $Q$ spaces. This ensures that the transformed Hamiltonian $H' = U H U^\\dagger$ has no coupling between the $P$ and $Q$ spaces, i.e., $P H' Q = 0$ and $Q H' P = 0$. The effective Hamiltonian is then defined as $H_{\\mathrm{eff}} = P H' P$.\n\nThe decoupling condition $Q(H+[S,H]+...)P = 0$ is imposed order by order in $g$. To first order, $Q(gV + [gS_1, H_0])P = 0$, which gives the equation for the first-order generator $S_1$: $Q[S_1, H_0]P = -QVP$. In matrix form, this is $H_{0Q}S_{1,QP} - S_{1,QP}H_{0P} = V_{QP}$. Let $S_{1,QP} = \\begin{pmatrix} s_1 & s_2 \\end{pmatrix}$. This yields:\n$\\varepsilon_q s_1 - s_1 \\varepsilon_1 = v_1 \\implies s_1 = \\frac{v_1}{\\varepsilon_q - \\varepsilon_1}$\n$\\varepsilon_q s_2 - s_2 \\varepsilon_2 = v_2 \\implies s_2 = \\frac{v_2}{\\varepsilon_q - \\varepsilon_2}$\n\n**1. Derivation of the wave operator $\\omega$**\n\nThe wave operator $\\omega$ relates the $P$-space and $Q$-space components of an exact eigenstate $|\\psi\\rangle$ of $H$ via $|\\psi_Q\\rangle = \\omega|\\psi_P\\rangle$. The unitary transformation maps $|\\psi\\rangle$ to a state $|\\phi_P\\rangle$ purely in the $P$-space: $|\\phi_P\\rangle = U|\\psi\\rangle$. Thus, $|\\psi\\rangle = U^\\dagger |\\phi_P\\rangle = e^{-S}|\\phi_P\\rangle$.\nExpanding to first order in $g$: $|\\psi\\rangle \\approx (I - gS_1)|\\phi_P\\rangle$.\nThe components are:\n$|\\psi_P\\rangle = P|\\psi\\rangle \\approx P(I - gS_1)|\\phi_P\\rangle = |\\phi_P\\rangle$\n$|\\psi_Q\\rangle = Q|\\psi\\rangle \\approx Q(I - gS_1)|\\phi_P\\rangle = -gQS_1P|\\phi_P\\rangle = -gS_{1,QP}|\\phi_P\\rangle$\nSubstituting $|\\phi_P\\rangle \\approx |\\psi_P\\rangle$ gives $|\\psi_Q\\rangle \\approx -gS_{1,QP}|\\psi_P\\rangle$.\nBy definition, $\\omega = Q\\omega P$. To first order, we have $\\omega^{(1)}=-gS_{1,QP}$.\nIn the given basis, $\\omega^{(1)}$ is represented by the $1 \\times 2$ matrix:\n$$\n\\omega^{(1)} = -g \\begin{pmatrix} \\frac{v_1}{\\varepsilon_q - \\varepsilon_1} & \\frac{v_2}{\\varepsilon_q - \\varepsilon_2} \\end{pmatrix} = g \\begin{pmatrix} \\frac{v_1}{\\varepsilon_1 - \\varepsilon_q} & \\frac{v_2}{\\varepsilon_2 - \\varepsilon_q} \\end{pmatrix}\n$$\n\n**2. Construction of the effective Hamiltonian $H_{\\mathrm{eff}}$**\n\nThe effective Hamiltonian is $H_{\\mathrm{eff}} = P H' P$. We expand it to order $O(g^2)$. The general result from the unitary transformation formalism, equivalent to a symmetrized perturbation theory, gives the second-order correction matrix $H_{\\mathrm{eff}}^{(2)}$. Its matrix elements $(H_{\\mathrm{eff}}^{(2)})_{ij}$ for $i,j \\in P$ are given by:\n$$\n(H_{\\mathrm{eff}}^{(2)})_{ij} = \\frac{g^2}{2} \\sum_{k \\in Q} V_{ik}V_{kj} \\left( \\frac{1}{\\varepsilon_i - \\varepsilon_k} + \\frac{1}{\\varepsilon_j - \\varepsilon_k} \\right)\n$$\nIn our problem, the P-space indices are $i,j \\in \\{1,2\\}$ for states $|p_1\\rangle, |p_2\\rangle$, and the Q-space has one state $|q\\rangle$ with index $k=q$.\n\nApplying this to our specific case:\n- The diagonal elements ($i=j$):\n$(H_{\\mathrm{eff}}^{(2)})_{11} = \\frac{g^2}{2} V_{1q}V_{q1} \\left( \\frac{1}{\\varepsilon_1 - \\varepsilon_q} + \\frac{1}{\\varepsilon_1 - \\varepsilon_q} \\right) = g^2 \\frac{v_1^2}{\\varepsilon_1 - \\varepsilon_q}$\n$(H_{\\mathrm{eff}}^{(2)})_{22} = \\frac{g^2}{2} V_{2q}V_{q2} \\left( \\frac{1}{\\varepsilon_2 - \\varepsilon_q} + \\frac{1}{\\varepsilon_2 - \\varepsilon_q} \\right) = g^2 \\frac{v_2^2}{\\varepsilon_2 - \\varepsilon_q}$\n- The off-diagonal element ($i=1, j=2$):\n$(H_{\\mathrm{eff}}^{(2)})_{12} = \\frac{g^2}{2} V_{1q}V_{q2} \\left( \\frac{1}{\\varepsilon_1 - \\varepsilon_q} + \\frac{1}{\\varepsilon_2 - \\varepsilon_q} \\right) = \\frac{g^2 v_1 v_2}{2} \\left( \\frac{1}{\\varepsilon_1 - \\varepsilon_q} + \\frac{1}{\\varepsilon_2 - \\varepsilon_q} \\right)$\n\nCombining these parts, the full second-order correction matrix is:\n$$\nH_{\\mathrm{eff}}^{(2)} = g^2 \\begin{pmatrix} \\frac{v_1^2}{\\varepsilon_1 - \\varepsilon_q} & \\frac{v_1v_2}{2}\\left(\\frac{1}{\\varepsilon_1 - \\varepsilon_q} + \\frac{1}{\\varepsilon_2 - \\varepsilon_q}\\right) \\\\ \\frac{v_1v_2}{2}\\left(\\frac{1}{\\varepsilon_1 - \\varepsilon_q} + \\frac{1}{\\varepsilon_2 - \\varepsilon_q}\\right) & \\frac{v_2^2}{\\varepsilon_2 - \\varepsilon_q} \\end{pmatrix}\n$$\nThe full effective Hamiltonian to order $O(g^2)$ is $H_{\\mathrm{eff}} = H_{0P} + H_{\\mathrm{eff}}^{(2)}$:\n$$\nH_{\\mathrm{eff}} = \\begin{pmatrix} \\varepsilon_1 + \\frac{g^2v_1^2}{\\varepsilon_1 - \\varepsilon_q} & \\frac{g^2v_1v_2}{2}\\left(\\frac{1}{\\varepsilon_1 - \\varepsilon_q} + \\frac{1}{\\varepsilon_2 - \\varepsilon_q}\\right) \\\\ \\frac{g^2v_1v_2}{2}\\left(\\frac{1}{\\varepsilon_1 - \\varepsilon_q} + \\frac{1}{\\varepsilon_2 - \\varepsilon_q}\\right) & \\varepsilon_2 + \\frac{g^2v_2^2}{\\varepsilon_2 - \\varepsilon_q} \\end{pmatrix}\n$$\nThis resulting effective Hamiltonian is Hermitian and energy-independent, as required.\n\nFinally, we compute the trace of the effective Hamiltonian, which is the sum of its diagonal elements:\n$\\mathrm{Tr}(H_{\\mathrm{eff}}) = \\left( \\varepsilon_1 + \\frac{g^2v_1^2}{\\varepsilon_1 - \\varepsilon_q} \\right) + \\left( \\varepsilon_2 + \\frac{g^2v_2^2}{\\varepsilon_2 - \\varepsilon_q} \\right)$\n$\\mathrm{Tr}(H_{\\mathrm{eff}}) = \\varepsilon_1 + \\varepsilon_2 + g^2\\left(\\frac{v_1^2}{\\varepsilon_1 - \\varepsilon_q} + \\frac{v_2^2}{\\varepsilon_2 - \\varepsilon_q}\\right)$", "answer": "$$\n\\boxed{\\varepsilon_{1} + \\varepsilon_{2} + g^{2}\\left(\\frac{v_{1}^{2}}{\\varepsilon_{1} - \\varepsilon_{q}} + \\frac{v_{2}^{2}}{\\varepsilon_{2} - \\varepsilon_{q}}\\right)}\n$$", "id": "3557309"}, {"introduction": "Building on the formal concept of an effective interaction, this practice explores a crucial source of such interactions in modern nuclear physics: three-nucleon forces (3NFs). While the fundamental nuclear interaction is dominated by two-body forces, 3NFs are essential for accurately describing nuclear properties, yet they are computationally challenging to include directly. This exercise demonstrates how, through the powerful technique of normal ordering, 3NFs in a fundamental Hamiltonian give rise to *induced* effective two-body interactions when we restrict ourselves to a valence space above a core like $^{16}\\mathrm{O}$ [@problem_id:3557353]. You will calculate the monopole shift generated by a simplified 3NF, gaining insight into how forces change their character in an effective description.", "problem": "Consider a valence-space shell-model Hamiltonian for two neutrons outside a closed-shell $^{16}\\mathrm{O}$ reference. The three-nucleon interaction is included at the level of normal-ordered two-body (NO2B) contributions with respect to a single Slater determinant reference built from harmonic-oscillator single-particle states. Start from the second-quantized form of a general three-body Hamiltonian,\n$$\n\\hat{V}_{3\\mathrm{N}}=\\frac{1}{36}\\sum_{a b c d e f} W_{a b c d e f}\\, a_{a}^{\\dagger} a_{b}^{\\dagger} a_{c}^{\\dagger} a_{f} a_{e} a_{d},\n$$\nwhere $W_{a b c d e f}$ are fully antisymmetrized three-body matrix elements in a single-particle basis that includes all magnetic substates, and $a_{a}^{\\dagger}$, $a_{a}$ are creation and annihilation operators. Normal ordering is to be performed with respect to a closed-shell $^{16}\\mathrm{O}$ reference characterized by occupation numbers $n_{i}$ for each single-particle state $i$. Assume the following:\n1. The $^{16}\\mathrm{O}$ reference has correlated but uniform effective occupancies for core states: for protons $n_{i}^{(p)} = 0.985$ for each of the eight occupied proton single-particle states, and for neutrons $n_{i}^{(n)} = 0.990$ for each of the eight occupied neutron single-particle states.\n2. The three-nucleon interaction is a simple contact that is spin-isospin independent and, in this discrete basis, has state-independent antisymmetrized diagonal matrix elements on triplets. Specifically, for any two distinct valence neutron orbitals $a \\neq b$ in the $sd$ shell and any occupied core single-particle state $i$ (of either isospin), the only nonvanishing reduced three-body matrix elements needed for the NO2B contraction satisfy\n$$\nW_{a b i\\, a b i} = C_{3},\n$$\nwith all other $W_{a b c d e f}$ not of this diagonal triplet form vanishing. Take $C_{3} = 0.030\\,\\text{MeV}$.\n3. The valence-space monopole two-body matrix element between two distinct valence neutron orbitals $a \\neq b$ is defined as the angular-momentum centroid of the two-body interaction and, for a central, state-independent NO2B reduction as above, coincides with the diagonal matrix element in the $m$-scheme.\n\nUsing only the fundamental definition of normal ordering with respect to a Slater determinant and Wick’s theorem, derive the induced normal-ordered two-body contribution from $\\hat{V}_{3\\mathrm{N}}$ and compute the resulting induced monopole matrix element $\\overline{V}^{(\\mathrm{ind})}_{a b}$ between two distinct valence neutrons $a \\neq b$ in the $sd$ shell. Express your final answer in $\\text{MeV}$ and round to three significant figures.", "solution": "The problem requires the calculation of an induced two-body monopole matrix element in the nuclear shell model. This induced interaction arises from a fundamental three-nucleon (3N) force when normal-ordered with respect to a correlated reference state, in this case, a model of the $^{16}\\mathrm{O}$ core.\n\nFirst, we begin with the provided three-body Hamiltonian, $\\hat{V}_{3\\mathrm{N}}$, given in second-quantized form:\n$$\n\\hat{V}_{3\\mathrm{N}}=\\frac{1}{36}\\sum_{a b c d e f} W_{a b c d e f}\\, a_{a}^{\\dagger} a_{b}^{\\dagger} a_{c}^{\\dagger} a_{f} a_{e} a_{d}\n$$\nHere, $W_{a b c d e f}$ are the fully antisymmetrized three-body matrix elements, $\\langle abc | V_{3N} | def \\rangle_A$, and $a_p^{\\dagger}$ ($a_p$) are fermion creation (annihilation) operators for a single-particle state $p$.\n\nThe process of normal ordering decomposes an operator with respect to a reference state $|\\Phi\\rangle$ into terms with different numbers of uncontracted operators. The normal-ordered two-body (NO2B) part of $\\hat{V}_{3\\mathrm{N}}$ is the term that contains one contraction. A contraction is defined by Wick's theorem, and for the specified reference state with partial occupancies $n_i$, the fundamental contraction is $\\langle\\Phi|a_p^\\dagger a_q|\\Phi\\rangle = \\delta_{pq} n_p$.\n\nThe induced two-body interaction, $\\hat{V}^{(\\mathrm{ind})}_{2\\mathrm{B}}$, is precisely this NO2B component of $\\hat{V}_{3\\mathrm{N}}$. A standard result from many-body theory gives the matrix elements of this induced interaction. For two-particle states in the valence space, $|pq\\rangle$ and $|rs\\rangle$, the induced matrix element $V^{(\\mathrm{ind})}_{pqrs}$ is obtained by summing the contributions from the interaction with each core particle. With effective occupancies $n_i$ for the core states $i$, this is given by:\n$$\nV^{(\\mathrm{ind})}_{pqrs} = \\sum_{i \\in \\text{core}} n_i W_{pqi,rsi}\n$$\nwhere the sum runs over all single-particle states $i$ within the defined core.\n\nThe problem asks for the monopole matrix element, $\\overline{V}^{(\\mathrm{ind})}_{ab}$, between two distinct valence neutron orbitals $a \\neq b$. It is specified that for the simplified interaction considered, this monopole coincides with the diagonal matrix element in the $m$-scheme. Therefore, we need to calculate $V^{(\\mathrm{ind})}_{abab}$:\n$$\n\\overline{V}^{(\\mathrm{ind})}_{ab} = V^{(\\mathrm{ind})}_{abab} = \\sum_{i \\in \\text{core}} n_i W_{abi,abi}\n$$\n\nNext, we must identify the core states and their properties. The core is $^{16}\\mathrm{O}$, which consists of filled $1s_{1/2}$, $1p_{3/2}$, and $1p_{1/2}$ shells for both protons and neutrons. The number of magnetic substates for a shell with angular momentum $j$ is $2j+1$.\n- For protons: $1s_{1/2}$ ($2$ states) + $1p_{3/2}$ ($4$ states) + $1p_{1/2}$ ($2$ states) = $8$ proton core states.\n- For neutrons: $1s_{1/2}$ ($2$ states) + $1p_{3/2}$ ($4$ states) + $1p_{1/2}$ ($2$ states) = $8$ neutron core states.\n\nThe problem provides the effective occupation numbers for these core states:\n- For each of the $8$ proton core states, $n_i^{(p)} = 0.985$.\n- For each of the $8$ neutron core states, $n_i^{(n)} = 0.990$.\n\nThe sum over core states can be split into a sum over proton core states and a sum over neutron core states:\n$$\n\\overline{V}^{(\\mathrm{ind})}_{ab} = \\sum_{i \\in \\{p_{\\text{core}}\\}} n_i^{(p)} W_{abi,abi} + \\sum_{i \\in \\{n_{\\text{core}}\\}} n_i^{(n)} W_{abi,abi}\n$$\n\nThe problem further simplifies the three-body matrix elements. For any two distinct valence neutron orbitals $a \\neq b$ and any core state $i$ (proton or neutron), the matrix element is a constant:\n$$\nW_{abi,abi} = C_3 = 0.030 \\, \\text{MeV}\n$$\n\nSubstituting this into our expression for the monopole:\n$$\n\\overline{V}^{(\\mathrm{ind})}_{ab} = \\sum_{i \\in \\{p_{\\text{core}}\\}} n_i^{(p)} C_3 + \\sum_{i \\in \\{n_{\\text{core}}\\}} n_i^{(n)} C_3\n$$\nSince $C_3$, $n_i^{(p)}$, and $n_i^{(n)}$ are constant within their respective sums, we can factor them out:\n$$\n\\overline{V}^{(\\mathrm{ind})}_{ab} = C_3 \\left( \\sum_{i \\in \\{p_{\\text{core}}\\}} n_i^{(p)} + \\sum_{i \\in \\{n_{\\text{core}}\\}} n_i^{(n)} \\right)\n$$\nThe sums are over the number of states in each core partition:\n$$\n\\sum_{i \\in \\{p_{\\text{core}}\\}} n_i^{(p)} = (\\text{Number of proton core states}) \\times n^{(p)} = 8 \\times 0.985\n$$\n$$\n\\sum_{i \\in \\{n_{\\text{core}}\\}} n_i^{(n)} = (\\text{Number of neutron core states}) \\times n^{(n)} = 8 \\times 0.990\n$$\n\nNow, we perform the numerical calculation:\n$$\n\\sum_{i \\in \\{p_{\\text{core}}\\}} n_i^{(p)} = 8 \\times 0.985 = 7.88\n$$\n$$\n\\sum_{i \\in \\{n_{\\text{core}}\\}} n_i^{(n)} = 8 \\times 0.990 = 7.92\n$$\nThe total sum of occupancies across the entire core is $7.88 + 7.92 = 15.80$.\n\nFinally, we compute the induced monopole matrix element:\n$$\n\\overline{V}^{(\\mathrm{ind})}_{ab} = C_3 \\times (15.80) = (0.030 \\, \\text{MeV}) \\times 15.80\n$$\n$$\n\\overline{V}^{(\\mathrm{ind})}_{ab} = 0.474 \\, \\text{MeV}\n$$\nThe problem requires the answer to be rounded to three significant figures. Our result, $0.474$, already meets this precision.", "answer": "$$\n\\boxed{0.474}\n$$", "id": "3557353"}, {"introduction": "While many effective interactions can be derived from first principles, some of the most successful shell-model Hamiltonians are determined empirically by fitting their parameters to experimental data. This computational exercise provides a hands-on simulation of this calibration process, bridging the gap between theoretical models and experimental observables. You will implement a gradient descent algorithm, a cornerstone of modern numerical optimization, to adjust a set of two-body matrix elements (TBMEs) to reproduce a target energy spectrum [@problem_id:3557305]. This practice develops essential skills in parameter optimization and provides a window into how phenomenological interactions are constructed and refined.", "problem": "You are tasked with implementing a gradient-based calibration of a small set of effective shell-model two-body matrix elements (TBME) using finite-difference sensitivities of selected level energies, and to assess convergence behavior under different numerical settings. The calibration is formulated in a minimal, yet physically meaningful, two-orbital valence-space model where two identical nucleons occupy two single-particle orbits with total angular momenta $j_1=\\tfrac{1}{2}$ and $j_2=\\tfrac{3}{2}$. This setting yields two angular-momentum blocks, $J=0$ and $J=2$, each described by a small Hamiltonian matrix in a coupled basis. The energies and interactions are expressed in mega-electronvolts (MeV), and all final numerical answers must be reported in MeV.\n\nFundamental base and model definition:\n- Start from the nonrelativistic many-body Hamiltonian comprising one-body single-particle energies and two-body interactions. In a fixed valence space, the Hamiltonian reduces to a configuration-interaction problem. For two identical nucleons restricted to the $\\{j_1,j_2\\}$ space, the $J$-coupled Hamiltonian factorizes into blocks for each total angular momentum $J$.\n- Adopt constant single-particle energies $e_1$ and $e_2$ for orbits $j_1$ and $j_2$, respectively. The TBME are taken as $J$-coupled matrix elements that contribute to the diagonal and off-diagonal entries of the block Hamiltonians.\n\nCoupled-basis Hamiltonians:\n- For $J=0$, use the coupled basis $\\{\\lvert (j_1^2) J=0 \\rangle, \\lvert (j_2^2) J=0 \\rangle\\}$. The $2\\times 2$ Hamiltonian is\n$$\nH^{(J=0)} =\n\\begin{pmatrix}\n2 e_1 + V_{11}^{(0)} & V_{12}^{(0)} \\\\\nV_{12}^{(0)} & 2 e_2 + V_{22}^{(0)}\n\\end{pmatrix}.\n$$\n- For $J=2$, use the coupled basis $\\{\\lvert (j_2^2) J=2 \\rangle, \\lvert (j_1 j_2) J=2 \\rangle\\}$. The $2\\times 2$ Hamiltonian is\n$$\nH^{(J=2)} =\n\\begin{pmatrix}\n2 e_2 + V_{22}^{(2)} & V_{x}^{(2)} \\\\\nV_{x}^{(2)} & e_1 + e_2 + V_{12}^{(2)}\n\\end{pmatrix}.\n$$\nHere the parameters to be calibrated are the six TBME\n$$\n\\mathbf{p} = \\big( V_{11}^{(0)}, V_{22}^{(0)}, V_{12}^{(0)}, V_{22}^{(2)}, V_{12}^{(2)}, V_{x}^{(2)} \\big).\n$$\n\nObservables and objective:\n- For each block, compute the eigenvalues (energies) and sort them in ascending order. Denote the two eigenvalues for $J=0$ as $E_{0,1}$ and $E_{0,2}$, and for $J=2$ as $E_{2,1}$ and $E_{2,2}$. The set of observables is the ordered list $\\{E_{0,1}, E_{0,2}, E_{2,1}, E_{2,2}\\}$, each in MeV.\n- Define the objective as the unweighted sum of squares of residuals relative to target energies,\n$$\nS(\\mathbf{p}) = \\sum_{i=1}^{4} \\big( E_i(\\mathbf{p}) - E_i^{\\text{target}} \\big)^2,\n$$\nwhere $E_i^{\\text{target}}$ are fixed target energies in MeV.\n\nTargets and constants:\n- Use $e_1 = 0.0$ MeV and $e_2 = 2.0$ MeV.\n- Define a physically plausible “true” TBME parameter vector (in MeV) used to generate targets:\n$$\n\\mathbf{p}_{\\text{true}} = (-1.2,\\,-0.5,\\,-0.25,\\,0.3,\\,-0.4,\\,-0.15).\n$$\n- Generate $E_i^{\\text{target}}$ by diagonalizing the above $J=0$ and $J=2$ blocks using $\\mathbf{p}_{\\text{true}}$ and sorting within each block in ascending order.\n\nOptimization method:\n- Use central finite differences to compute the gradient of $S(\\mathbf{p})$ with respect to each parameter in $\\mathbf{p}$. For a step size $h>0$,\n$$\n\\left[\\nabla S(\\mathbf{p})\\right]_k \\approx \\frac{S(\\mathbf{p} + h\\,\\mathbf{e}_k) - S(\\mathbf{p} - h\\,\\mathbf{e}_k)}{2h},\n$$\nwhere $\\mathbf{e}_k$ is the $k$-th unit vector.\n- Apply gradient descent updates,\n$$\n\\mathbf{p}^{(n+1)} = \\mathbf{p}^{(n)} - \\alpha \\,\\nabla S(\\mathbf{p}^{(n)}),\n$$\nstarting from the initial guess\n$$\n\\mathbf{p}^{(0)} = (-0.5,\\,0.2,\\,0.0,\\,0.8,\\,0.0,\\,0.0) \\text{ MeV}.\n$$\n- Use early stopping if either the Euclidean norm of the gradient falls below a tolerance $||\\nabla S||_2 \\le \\tau_g$ or the relative change in the objective satisfies $\\frac{|S^{(n+1)} - S^{(n)}|}{\\max(1, S^{(n)})} \\le \\tau_S$, with $\\tau_g = 10^{-6}$ MeV and $\\tau_S = 10^{-12}$.\n\nPhysical units:\n- All energies, TBME, residuals, and objective are computed in MeV. Report the root-mean-square deviation (RMSD) of the four energies relative to targets at the end of optimization,\n$$\n\\text{RMSD} = \\sqrt{\\frac{1}{4} \\sum_{i=1}^{4} \\big( E_i(\\mathbf{p}^{\\text{final}}) - E_i^{\\text{target}} \\big)^2} \\quad \\text{in MeV}.\n$$\n\nTest suite:\nRun the optimizer for the following three test cases, each specified by learning rate $\\alpha$, finite-difference step $h$, and maximum number of iterations $N_{\\max}$:\n- Case A (happy path): $\\alpha = 0.5$, $h = 10^{-4}$, $N_{\\max} = 60$.\n- Case B (boundary, minimal iteration): $\\alpha = 0.3$, $h = 10^{-6}$, $N_{\\max} = 1$.\n- Case C (edge, coarse sensitivity): $\\alpha = 0.5$, $h = 5\\times 10^{-3}$, $N_{\\max} = 60$.\n\nRequired final output format:\nYour program should produce a single line of output containing the root-mean-square deviations for the three cases, in MeV, as a comma-separated list enclosed in square brackets (e.g., \"[rmsA,rmsB,rmsC]\"). Do not print any other text. Each reported value must be a floating-point number representing the RMSD in MeV for that case. The program must be self-contained and must not require any user input or external files. Angle units are not involved in this problem. Percentages are not involved; any fractional quantities must be expressed as decimals or fractions, not as percentages.", "solution": "The problem is assessed to be valid. It constitutes a well-posed, self-contained, and scientifically grounded exercise in computational nuclear physics, specifically in the area of parameter calibration for an effective shell model interaction. All required data, definitions, physical constants, and algorithmic specifications are provided, and they are free from internal contradictions, factual errors, or ambiguities. The task is to implement a standard gradient descent optimization to fit a set of two-body matrix elements (TBME) to synthetically generated target energy levels.\n\nThe solution proceeds as follows: First, we formalize the model, which involves defining the Hamiltonians and the set of observables. Second, we compute the target data using the provided \"true\" parameters. Third, we detail the gradient descent algorithm, including the gradient approximation and stopping criteria. Finally, we describe the implementation of this algorithm to run the specified test cases and compute the required root-mean-square deviation (RMSD) for each.\n\nThe model space consists of two identical nucleons in two single-particle orbitals with total angular momenta $j_1=\\frac{1}{2}$ and $j_2=\\frac{3}{2}$. The corresponding single-particle energies are fixed constants: $e_1 = 0.0$ MeV and $e_2 = 2.0$ MeV. The interaction is described by a set of six TBME, which are the parameters to be calibrated. These parameters are collected in a vector $\\mathbf{p}$:\n$$\n\\mathbf{p} = \\big( V_{11}^{(0)}, V_{22}^{(0)}, V_{12}^{(0)}, V_{22}^{(2)}, V_{12}^{(2)}, V_{x}^{(2)} \\big).\n$$\nThe problem is solved within two uncoupled angular momentum blocks, $J=0$ and $J=2$.\n\nFor the total angular momentum block $J=0$, the Hamiltonian matrix in the basis $\\{\\lvert (j_1^2) J=0 \\rangle, \\lvert (j_2^2) J=0 \\rangle\\}$ is:\n$$\nH^{(J=0)}(\\mathbf{p}) =\n\\begin{pmatrix}\n2 e_1 + V_{11}^{(0)} & V_{12}^{(0)} \\\\\nV_{12}^{(0)} & 2 e_2 + V_{22}^{(0)}\n\\end{pmatrix}.\n$$\n\nFor the total angular momentum block $J=2$, the Hamiltonian matrix in the basis $\\{\\lvert (j_2^2) J=2 \\rangle, \\lvert (j_1 j_2) J=2 \\rangle\\}$ is:\n$$\nH^{(J=2)}(\\mathbf{p}) =\n\\begin{pmatrix}\n2 e_2 + V_{22}^{(2)} & V_{x}^{(2)} \\\\\nV_{x}^{(2)} & e_1 + e_2 + V_{12}^{(2)}\n\\end{pmatrix}.\n$$\n\nThe observables are the four eigenvalues of these matrices, sorted in ascending order within each block, forming the ordered list $\\mathbf{E}(\\mathbf{p}) = \\{E_{0,1}, E_{0,2}, E_{2,1}, E_{2,2}\\}$. These are computed by diagonalizing the $2 \\times 2$ symmetric matrices for a given parameter vector $\\mathbf{p}$.\n\nThe target energies, $\\mathbf{E}^{\\text{target}} = \\{E_{0,1}^{\\text{target}}, E_{0,2}^{\\text{target}}, E_{2,1}^{\\text{target}}, E_{2,2}^{\\text{target}}\\}$, are generated by calculating the eigenvalues using the \"true\" parameter vector $\\mathbf{p}_{\\text{true}} = (-1.2,\\,-0.5,\\,-0.25,\\,0.3,\\,-0.4,\\,-0.15)$ MeV.\nWith $e_1=0.0$ MeV and $e_2=2.0$ MeV, the \"true\" Hamiltonians are:\n$$\nH^{(J=0)}_{\\text{true}} = \\begin{pmatrix} 2(0.0) - 1.2 & -0.25 \\\\ -0.25 & 2(2.0) - 0.5 \\end{pmatrix} = \\begin{pmatrix} -1.2 & -0.25 \\\\ -0.25 & 3.5 \\end{pmatrix} \\text{ MeV}.\n$$\nThe eigenvalues of $H^{(J=0)}_{\\text{true}}$ are $E_{0,1}^{\\text{target}} \\approx -1.21326$ MeV and $E_{0,2}^{\\text{target}} \\approx 3.51326$ MeV.\n$$\nH^{(J=2)}_{\\text{true}} = \\begin{pmatrix} 2(2.0) + 0.3 & -0.15 \\\\ -0.15 & 0.0 + 2.0 - 0.4 \\end{pmatrix} = \\begin{pmatrix} 4.3 & -0.15 \\\\ -0.15 & 1.6 \\end{pmatrix} \\text{ MeV}.\n$$\nThe eigenvalues of $H^{(J=2)}_{\\text{true}}$ are $E_{2,1}^{\\text{target}} \\approx 1.59169$ MeV and $E_{2,2}^{\\text{target}} \\approx 4.30831$ MeV.\nThe complete target energy vector is $\\mathbf{E}^{\\text{target}} \\approx (-1.21326, 3.51326, 1.59169, 4.30831)$ MeV.\n\nThe calibration is performed by minimizing the objective function $S(\\mathbf{p})$, defined as the sum of squared residuals:\n$$\nS(\\mathbf{p}) = \\sum_{i=1}^{4} \\big( E_i(\\mathbf{p}) - E_i^{\\text{target}} \\big)^2.\n$$\nThe minimization employs the gradient descent algorithm. Starting with an initial guess $\\mathbf{p}^{(0)} = (-0.5,\\,0.2,\\,0.0,\\,0.8,\\,0.0,\\,0.0)$ MeV, the parameters are updated iteratively:\n$$\n\\mathbf{p}^{(n+1)} = \\mathbf{p}^{(n)} - \\alpha \\,\\nabla S(\\mathbf{p}^{(n)}),\n$$\nwhere $\\alpha$ is the learning rate and $n$ is the iteration index. The gradient vector $\\nabla S(\\mathbf{p})$ is approximated numerically using the central finite-difference formula for each component $k$:\n$$\n\\left[\\nabla S(\\mathbf{p})\\right]_k = \\frac{\\partial S}{\\partial p_k} \\approx \\frac{S(\\mathbf{p} + h\\,\\mathbf{e}_k) - S(\\mathbf{p} - h\\,\\mathbf{e}_k)}{2h},\n$$\nwhere $h$ is the finite-difference step size and $\\mathbf{e}_k$ is the $k$-th standard basis vector.\n\nThe iterative process terminates if the maximum number of iterations, $N_{\\max}$, is reached, or if one of the following early-stopping conditions is met:\n1. The Euclidean norm of the gradient falls below a tolerance: $||\\nabla S(\\mathbf{p}^{(n)})||_2 \\le \\tau_g$, where $\\tau_g = 10^{-6}$ MeV.\n2. The relative change in the objective function is sufficiently small: $\\frac{|S(\\mathbf{p}^{(n+1)}) - S(\\mathbf{p}^{(n)})|}{\\max(1, S(\\mathbf{p}^{(n)}))} \\le \\tau_S$, where $\\tau_S = 10^{-12}$.\n\nUpon termination at a final parameter vector $\\mathbf{p}^{\\text{final}}$, the quality of the fit is quantified by the root-mean-square deviation (RMSD):\n$$\n\\text{RMSD} = \\sqrt{\\frac{1}{4} S(\\mathbf{p}^{\\text{final}})} = \\sqrt{\\frac{1}{4} \\sum_{i=1}^{4} \\big( E_i(\\mathbf{p}^{\\text{final}}) - E_i^{\\text{target}} \\big)^2}.\n$$\n\nThe algorithm is implemented in Python using the `numpy` library for efficient array operations and matrix diagonalization (`numpy.linalg.eigh`). A function is created to compute the energy eigenvalues for any given parameter vector $\\mathbf{p}$. Another function computes the objective $S(\\mathbf{p})$. The gradient is computed by a function that repeatedly calls the objective function with perturbed parameters. The main optimization loop iterates the gradient descent update while checking the stopping conditions. This procedure is executed for each of the three test cases specified, and the final RMSD for each case is calculated and reported.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the gradient-based calibration of effective shell-model TBME.\n    \"\"\"\n    # Define physical constants and model parameters\n    e1 = 0.0  # MeV\n    e2 = 2.0  # MeV\n    p_true = np.array([-1.2, -0.5, -0.25, 0.3, -0.4, -0.15])  # MeV\n    p0 = np.array([-0.5, 0.2, 0.0, 0.8, 0.0, 0.0])  # MeV\n\n    # Define optimization convergence criteria\n    tau_g = 1e-6  # MeV\n    tau_S = 1e-12\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case A: (alpha, h, N_max)\n        (0.5, 1e-4, 60),\n        # Case B: (alpha, h, N_max)\n        (0.3, 1e-6, 1),\n        # Case C: (alpha, h, N_max)\n        (0.5, 5e-3, 60),\n    ]\n\n    def calculate_energies(p, e1_val, e2_val):\n        \"\"\"\n        Calculates the 4 energy eigenvalues for a given parameter vector p.\n        The eigenvalues are returned as a sorted, concatenated list [E0,1, E0,2, E2,1, E2,2].\n        \"\"\"\n        # Unpack parameter vector p\n        v11_0, v22_0, v12_0, v22_2, v12_2, vx_2 = p\n\n        # Construct H for J=0\n        H0 = np.array([\n            [2 * e1_val + v11_0, v12_0],\n            [v12_0, 2 * e2_val + v22_0]\n        ])\n\n        # Construct H for J=2\n        H2 = np.array([\n            [2 * e2_val + v22_2, vx_2],\n            [vx_2, e1_val + e2_val + v12_2]\n        ])\n\n        # Diagonalize and get sorted eigenvalues (eigh does this by default)\n        eigvals0 = np.linalg.eigh(H0)[0]\n        eigvals2 = np.linalg.eigh(H2)[0]\n\n        return np.concatenate((eigvals0, eigvals2))\n\n    # Generate target energies using p_true\n    E_target = calculate_energies(p_true, e1, e2)\n\n    def calculate_objective(p, E_target_vals, e1_val, e2_val):\n        \"\"\"\n        Calculates the objective function S(p).\n        \"\"\"\n        E_p = calculate_energies(p, e1_val, e2_val)\n        residuals = E_p - E_target_vals\n        return np.sum(residuals**2)\n\n    def calculate_gradient(p, h, E_target_vals, e1_val, e2_val):\n        \"\"\"\n        Calculates the gradient of S(p) using central finite differences.\n        \"\"\"\n        grad = np.zeros_like(p)\n        for k in range(len(p)):\n            p_plus_h = p.copy()\n            p_plus_h[k] += h\n            p_minus_h = p.copy()\n            p_minus_h[k] -= h\n\n            S_plus = calculate_objective(p_plus_h, E_target_vals, e1_val, e2_val)\n            S_minus = calculate_objective(p_minus_h, E_target_vals, e1_val, e2_val)\n            \n            grad[k] = (S_plus - S_minus) / (2 * h)\n        return grad\n    \n    def run_optimization(alpha, h, N_max, p_initial, E_target_vals, e1_val, e2_val, tg, tS):\n        \"\"\"\n        Runs the gradient descent optimization for one test case.\n        \"\"\"\n        p = p_initial.copy()\n        \n        S_current = calculate_objective(p, E_target_vals, e1_val, e2_val)\n\n        for _ in range(N_max):\n            # Calculate gradient\n            grad = calculate_gradient(p, h, E_target_vals, e1_val, e2_val)\n            grad_norm = np.linalg.norm(grad)\n            \n            # Check gradient norm convergence\n            if grad_norm <= tg:\n                break\n                \n            # Update parameters\n            p_next = p - alpha * grad\n            \n            # Calculate new objective value\n            S_next = calculate_objective(p_next, E_target_vals, e1_val, e2_val)\n\n            # Check objective function convergence\n            S_rel_change = abs(S_next - S_current) / max(1.0, S_current)\n            if S_rel_change <= tS:\n                p = p_next\n                break\n\n            # Prepare for next iteration\n            p = p_next\n            S_current = S_next\n            \n        # Calculate final objective value and RMSD\n        S_final = calculate_objective(p, E_target_vals, e1_val, e2_val)\n        rmsd = np.sqrt(S_final / 4.0)\n        return rmsd\n\n    results = []\n    for case in test_cases:\n        alpha, h, N_max = case\n        rmsd = run_optimization(alpha, h, N_max, p0, E_target, e1, e2, tau_g, tau_S)\n        results.append(rmsd)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3557305"}]}