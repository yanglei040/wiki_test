{"hands_on_practices": [{"introduction": "A cornerstone of phenomenological nuclear physics is the description of the nucleus using continuous density distributions. This exercise provides direct experience with the two-parameter Fermi (or Woods-Saxon) model, which accurately captures the saturated density in the nuclear interior and the diffuse surface. You will implement numerical methods to determine the model's parameters for a heavy nucleus by constraining them with key physical observables—the root-mean-square radius and surface thickness—a fundamental skill in nuclear structure modeling [@problem_id:3574012].", "problem": "You are given a spherically symmetric two-parameter Fermi (also called Woods–Saxon) density model for a heavy nucleus, taken here as $^{208}\\mathrm{Pb}$. The mass density is modeled as $\\rho(r) = \\dfrac{\\rho_0}{1 + \\exp\\!\\left( \\dfrac{r - c}{a} \\right)}$, where $r$ is the radial coordinate in femtometers, $c$ is the half-density radius in femtometers, $a$ is the diffuseness in femtometers, and $\\rho_0$ is a central density scale in inverse cubic femtometers. The parameters $c$ and $a$ are to be determined under the following physically motivated constraints: normalization to the nucleon number $A = 208$ and a prescribed root-mean-square radius, and a diffuseness constraint defined by the $10\\%$–$90\\%$ surface thickness of the Fermi function.\n\nStarting from the following fundamental bases and core definitions:\n\n- Spherical symmetry implies that the total number of nucleons $A$ is given by the normalization condition $A = \\displaystyle \\int_{\\mathbb{R}^3} \\rho(\\mathbf{r})\\, d^3\\mathbf{r} = 4\\pi \\displaystyle \\int_{0}^{\\infty} r^2 \\rho(r)\\, dr$.\n\n- The root-mean-square (RMS) radius is defined by $\\sqrt{\\langle r^2 \\rangle} = \\left( \\dfrac{ \\displaystyle \\int_{\\mathbb{R}^3} r^2 \\rho(\\mathbf{r})\\, d^3\\mathbf{r} }{ \\displaystyle \\int_{\\mathbb{R}^3} \\rho(\\mathbf{r})\\, d^3\\mathbf{r} } \\right)^{1/2} = \\left( \\dfrac{ \\displaystyle 4\\pi \\int_{0}^{\\infty} r^4 \\rho(r)\\, dr }{ \\displaystyle 4\\pi \\int_{0}^{\\infty} r^2 \\rho(r)\\, dr } \\right)^{1/2}$.\n\n- The diffuseness constraint is defined as follows: let $r_{0.9}$ and $r_{0.1}$ be the radii at which the density equals $0.9\\,\\rho_0$ and $0.1\\,\\rho_0$, respectively, for the Fermi function $\\rho(r)$. The surface thickness $t$ is defined as $t = r_{0.1} - r_{0.9}$. Enforce the constraint by solving the resulting equations to determine $a$ in terms of $t$.\n\nYour task is to write a complete, runnable program that:\n\n1. Implements numerical quadrature over $r \\in [0,\\infty)$ to evaluate the normalization integral and the second moment integral for the Fermi model. Use these to compute the RMS radius $\\sqrt{\\langle r^2 \\rangle}$ for given $(c,a)$, ensuring all integrals are evaluated with sufficient numerical accuracy.\n\n2. Uses the diffuseness constraint to compute the parameter $a$ from a given surface thickness $t$ by solving the equations implied by the Fermi function definition of $r_{0.9}$ and $r_{0.1}$.\n\n3. Determines the parameter $c$ (for the computed $a$) such that the computed RMS radius equals a specified target. This must be done by solving for $c$ using a robust root-finding method that relies on the monotonic dependence of $\\sqrt{\\langle r^2 \\rangle}$ on $c$ for fixed $a$.\n\n4. Ensures that the density is properly normalized to $A = 208$ by computing $\\rho_0$ numerically so that $4\\pi \\int_{0}^{\\infty} r^2 \\rho(r)\\, dr = 208$. Although the RMS radius for the Fermi model cancels the dependence on $\\rho_0$, you must still compute $\\rho_0$ to demonstrate the correct normalization.\n\n5. Produces the outputs for a test suite of three cases. In each case, return the pair $(c,a)$ in femtometers, rounded to six decimal places. The units for $c$ and $a$ must be femtometers (fm).\n\nUse the following test suite:\n\n- Case 1 (happy path): Target RMS radius $\\sqrt{\\langle r^2 \\rangle} = 5.5$ fm, surface thickness $t = 2.4$ fm.\n- Case 2 (thin surface): Target RMS radius $\\sqrt{\\langle r^2 \\rangle} = 5.5$ fm, surface thickness $t = 1.0$ fm.\n- Case 3 (thick surface, different target): Target RMS radius $\\sqrt{\\langle r^2 \\rangle} = 5.3$ fm, surface thickness $t = 4.0$ fm.\n\nAll three cases use $A = 208$.\n\nFinal output format requirement: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a two-element list $[c,a]$ with both numbers in femtometers rounded to six decimal places. For example, the final line should look like \"[[c1,a1],[c2,a2],[c3,a3]]\" with no additional text.", "solution": "The problem is valid. It is a well-posed, scientifically grounded problem in computational nuclear physics that is free of ambiguity and contains all necessary information for a unique solution. The core task is to determine the parameters of a Woods-Saxon nuclear density distribution for $^{208}\\mathrm{Pb}$ by enforcing physically motivated constraints on its root-mean-square (RMS) radius and surface thickness. This is a standard procedure in the field.\n\nThe solution proceeds in a sequence of analytical and numerical steps. The goal is to find the half-density radius $c$ and the diffuseness parameter $a$ for the Fermi density function,\n$$\n\\rho(r) = \\frac{\\rho_0}{1 + \\exp\\left(\\frac{r - c}{a}\\right)}\n$$\nwhere $r$ is the radial coordinate, and $\\rho_0$ is a normalization constant. The nucleon number is fixed at $A = 208$.\n\n### Step 1: Determine Diffuseness $a$ from Surface Thickness $t$\n\nThe surface thickness $t$ is defined as $t = r_{0.1} - r_{0.9}$, where $r_{0.1}$ and $r_{0.9}$ are the radii at which the density $\\rho(r)$ is $10\\%$ and $90\\%$ of its central value $\\rho_0$, respectively. We can solve for these radii analytically.\n\nFor $r_{0.9}$, we have $\\rho(r_{0.9}) = 0.9\\,\\rho_0$:\n$$\n\\frac{\\rho_0}{1 + \\exp\\left(\\frac{r_{0.9} - c}{a}\\right)} = 0.9\\,\\rho_0\n$$\n$$\n1 + \\exp\\left(\\frac{r_{0.9} - c}{a}\\right) = \\frac{1}{0.9} = \\frac{10}{9}\n$$\n$$\n\\exp\\left(\\frac{r_{0.9} - c}{a}\\right) = \\frac{1}{9}\n$$\nTaking the natural logarithm of both sides gives:\n$$\n\\frac{r_{0.9} - c}{a} = \\ln\\left(\\frac{1}{9}\\right) = -\\ln(9) \\implies r_{0.9} = c - a\\ln(9)\n$$\n\nFor $r_{0.1}$, we have $\\rho(r_{0.1}) = 0.1\\,\\rho_0$:\n$$\n\\frac{\\rho_0}{1 + \\exp\\left(\\frac{r_{0.1} - c}{a}\\right)} = 0.1\\,\\rho_0\n$$\n$$\n1 + \\exp\\left(\\frac{r_{0.1} - c}{a}\\right) = \\frac{1}{0.1} = 10\n$$\n$$\n\\exp\\left(\\frac{r_{0.1} - c}{a}\\right) = 9\n$$\nTaking the natural logarithm gives:\n$$\n\\frac{r_{0.1} - c}{a} = \\ln(9) \\implies r_{0.1} = c + a\\ln(9)\n$$\n\nThe surface thickness $t$ is then:\n$$\nt = r_{0.1} - r_{0.9} = (c + a\\ln(9)) - (c - a\\ln(9)) = 2a\\ln(9)\n$$\nSince $\\ln(9) = \\ln(3^2) = 2\\ln(3)$, this simplifies to $t = 4a\\ln(3)$. Thus, the diffuseness parameter $a$ is directly determined by the surface thickness $t$:\n$$\na = \\frac{t}{4\\ln(3)}\n$$\nThis equation is used to compute $a$ for each test case.\n\n### Step 2: Determine Half-Density Radius $c$ from RMS Radius Constraint\n\nThe root-mean-square (RMS) radius $\\sqrt{\\langle r^2 \\rangle}$ is defined as:\n$$\n\\sqrt{\\langle r^2 \\rangle} = \\left( \\frac{\\int_0^{\\infty} r^4 \\rho(r) 4\\pi r^2 dr}{\\int_0^{\\infty} \\rho(r) 4\\pi r^2 dr} \\right)^{1/2}\n$$\nSubstituting $\\rho(r)$ and canceling the constants $4\\pi\\rho_0$ from the numerator and denominator, we get:\n$$\n\\sqrt{\\langle r^2 \\rangle}(c, a) = \\left( \\frac{\\int_0^{\\infty} \\frac{r^4}{1 + \\exp\\left(\\frac{r-c}{a}\\right)} dr}{\\int_0^{\\infty} \\frac{r^2}{1 + \\exp\\left(\\frac{r-c}{a}\\right)} dr} \\right)^{1/2}\n$$\nFor a fixed value of $a$ (determined from $t$ in Step 1), the RMS radius is a monotonically increasing function of $c$. This allows us to find a unique value of $c$ that satisfies the target RMS radius constraint, $\\sqrt{\\langle r^2 \\rangle}_{\\text{target}}$. We define an objective function $F(c)$ to be zeroed:\n$$\nF(c) = \\sqrt{\\langle r^2 \\rangle}(c, a) - \\sqrt{\\langle r^2 \\rangle}_{\\text{target}} = 0\n$$\nThis is a root-finding problem. The integrals do not have a simple analytical closed-form solution and must be computed numerically. We employ a robust quadrature method, such as `scipy.integrate.quad`, to evaluate the integrals over the semi-infinite domain $r \\in [0, \\infty)$. The exponential decay of the integrand's denominator ensures rapid convergence.\n\nA bracketing root-finding algorithm, such as Brent's method (`scipy.optimize.brentq`), is ideal for solving $F(c) = 0$. We establish a search interval for $c$, for example $[1, 15]$ fm, which is physically certain to bracket the true value for a heavy nucleus like $^{208}\\mathrm{Pb}$. The algorithm iteratively narrows this interval to find the root $c$ to a high degree of precision.\n\n### Step 3: Normalization to Nucleon Number $A$\n\nAlthough the calculation of the RMS radius is independent of the central density $\\rho_0$, a complete physical model requires proper normalization. The total number of nucleons $A$ is given by:\n$$\nA = 4\\pi \\int_0^{\\infty} r^2 \\rho(r) dr = 4\\pi \\rho_0 \\int_0^{\\infty} \\frac{r^2}{1 + \\exp\\left(\\frac{r-c}{a}\\right)} dr\n$$\nOnce the parameters $c$ and $a$ are determined, the integral can be computed numerically. The normalization constant $\\rho_0$ is then found by:\n$$\n\\rho_0 = \\frac{A}{4\\pi \\int_0^{\\infty} \\frac{r^2}{1 + \\exp\\left(\\frac{r-c}{a}\\right)} dr}\n$$\nWith $A=208$, this calculation is performed to verify the completion of the model, though $\\rho_0$ is not part of the required output.\n\n### Algorithmic Summary\n\nFor each test case defined by a pair $(\\sqrt{\\langle r^2 \\rangle}_{\\text{target}}, t)$:\n1.  Calculate a value for the diffuseness $a$ using the formula $a = t / (4\\ln(3))$.\n2.  Define an objective function $F(c)$ that computes the difference between the calculated RMS radius for a given $c$ (and the now-fixed $a$) and the target RMS radius. This function involves numerical evaluation of two integrals.\n3.  Use Brent's method to find the root of $F(c) = 0$ within a safe bracket, yielding the half-density radius $c$.\n4.  The resulting pair $(c, a)$ is the solution for the test case. The values are rounded to six decimal places as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the Fermi density parameters (c, a) for given RMS radius and surface thickness.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is (target_rms_radius_fm, surface_thickness_fm)\n    test_cases = [\n        (5.5, 2.4),\n        (5.5, 1.0),\n        (5.3, 4.0),\n    ]\n    \n    A = 208.0 # Nucleon number for 208Pb\n    \n    results = []\n    \n    for target_rms, t in test_cases:\n        # Step 1: Analytically determine diffuseness 'a' from surface thickness 't'.\n        # The surface thickness t is defined as r_0.1 - r_0.9.\n        # This leads to the relation t = 2*a*ln(9) = 4*a*ln(3).\n        a = t / (4.0 * np.log(3.0))\n\n        # The shape of the Fermi distribution, f(r), without the rho_0 factor.\n        def fermi_shape(r, c_val, a_val):\n            return 1.0 / (1.0 + np.exp((r - c_val) / a_val))\n            \n        def calculate_rms(c_val, a_val):\n            \"\"\"Computes the RMS radius for given c and a.\"\"\"\n            # The integrand for the second moment of the radius, <r^2>.\n            # The 4*pi and rho_0 constants cancel in the RMS radius formula.\n            # Integrand for the numerator of <r^2>: r^4 * f(r)\n            integrand_r4 = lambda r: r**4 * fermi_shape(r, c_val, a_val)\n            \n            # Integrand for the denominator of <r^2> (which is also the normalization integral part): r^2 * f(r)\n            integrand_r2 = lambda r: r**2 * fermi_shape(r, c_val, a_val)\n            \n            # Perform numerical integration from 0 to infinity.\n            # quad returns (integral, error). We only need the integral value.\n            integral_r4, _ = quad(integrand_r4, 0, np.inf)\n            integral_r2, _ = quad(integrand_r2, 0, np.inf)\n            \n            if integral_r2 == 0:\n                # Should not happen with physical parameters\n                return np.inf\n\n            # <r^2> = I(r^4)/I(r^2)\n            mean_square_radius = integral_r4 / integral_r2\n            rms_radius = np.sqrt(mean_square_radius)\n            \n            return rms_radius\n\n        # Step 2: Define the objective function for the root-finder.\n        # We want to find 'c' such that calculate_rms(c, a) equals target_rms.\n        def objective_function(c_val):\n            return calculate_rms(c_val, a) - target_rms\n            \n        # Step 3: Use a robust root-finding algorithm (Brent's method) to find 'c'.\n        # A physically reasonable search interval for c for a heavy nucleus is [1, 15] fm.\n        c_low = 1.0\n        c_high = 15.0\n        \n        # Ensure the root is bracketed. The RMS radius is a monotonically increasing function of c.\n        try:\n            c = brentq(objective_function, c_low, c_high, xtol=1e-12, rtol=1e-12)\n        except ValueError:\n            # This would happen if the root is not bracketed, indicating an issue with the interval or model.\n            # Given the problem physics, this is not expected.\n            c = np.nan\n        \n        # Step 4: (Optional) Calculate rho_0 for completeness. Not required for output.\n        # integral_r2_final, _ = quad(lambda r: r**2 * fermi_shape(r, c, a), 0, np.inf)\n        # rho_0 = A / (4 * np.pi * integral_r2_final)\n\n        results.append((c, a))\n\n    # Final print statement in the exact required format.\n    # The format is [[c1,a1],[c2,a2],[c3,a3]] with numbers rounded to six decimal places.\n    output_str = \",\".join([f\"[{c_val:.6f},{a_val:.6f}]\" for c_val, a_val in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "3574012"}, {"introduction": "Having established a model for the spatial distribution of nucleons, the next step is to connect it to experimental measurements. This practice explores the nuclear charge form factor, $F(q)$, which is the Fourier transform of the charge density and the primary observable in electron scattering experiments. You will not only calculate the form factor from a point-proton distribution but also incorporate the crucial physical effect of the nucleons' intrinsic size by \"folding\" their individual form factors with the distribution of their centers, highlighting the distinction between theoretical constructs and physical reality [@problem_id:3573943].", "problem": "Consider a spherically symmetric medium-mass nucleus in which the spatial distributions of proton centers and neutron centers are modeled by the two-parameter Fermi (2pF) function. Let the radial coordinate be $r$ in femtometers (fm), and define the 2pF shape function as $f(r;c,a) = \\left(1 + \\exp\\left(\\frac{r - c}{a}\\right)\\right)^{-1}$ with half-density radius $c$ (in fm) and surface diffuseness $a$ (in fm). The normalized point-nucleon coordinate densities are constructed as $\\rho_{p}(r) = \\rho_{0,p} f(r;c_p,a_p)$ and $\\rho_{n}(r) = \\rho_{0,n} f(r;c_n,a_n)$, where the normalization constants $\\rho_{0,p}$ and $\\rho_{0,n}$ are chosen so that $4\\pi \\int_{0}^{\\infty} r^{2} \\rho_{p}(r)\\,dr = 1$ and $4\\pi \\int_{0}^{\\infty} r^{2} \\rho_{n}(r)\\,dr = 1$. The nucleus has $Z$ protons and $N$ neutrons.\n\nDefine the point-nucleon proton charge form factor $F_{\\mathrm{point}}(q)$ as the three-dimensional Fourier transform of $\\rho_{p}(r)$, evaluated for a momentum transfer magnitude $q$ in inverse femtometers (fm$^{-1}$), using the spherical symmetry. To incorporate intrinsic nucleon structure, define a folded (physical) charge form factor $F_{\\mathrm{fold}}(q)$ by convolving the coordinate-space densities with intrinsic nucleon charge distributions before the Fourier transform, equivalently multiplying the point-nucleon coordinate-space form factors by intrinsic nucleon electric form factors in momentum space. Use the following physically motivated parameterizations for the intrinsic nucleon electric form factors as functions of $q$:\n- Intrinsic proton electric form factor modeled as a three-dimensional Gaussian with proton root-mean-square radius $r_{p} = 0.84\\,\\mathrm{fm}$, giving a momentum-space factor $G_{E}^{p}(q)$ consistent with the small-$q$ expansion.\n- Intrinsic neutron electric form factor constrained to reproduce the neutron mean-square charge radius $\\langle r_{n}^{2} \\rangle = -0.1161\\,\\mathrm{fm}^{2}$ at small $q$ while decaying with a Gaussian scale comparable to the proton case.\n\nStarting only from the definitions of normalized densities, the three-dimensional Fourier transform for spherically symmetric functions, and the convolution theorem, do the following:\n1. Derive expressions to compute $F_{\\mathrm{point}}(q)$ and $F_{\\mathrm{fold}}(q)$ for a given $q$, $Z$, $N$, and sets of $(c_p,a_p)$ and $(c_n,a_n)$, ensuring that $F_{\\mathrm{point}}(0) = 1$ and $F_{\\mathrm{fold}}(0) = 1$.\n2. Implement a numerical algorithm to accurately evaluate the required radial integrals with the zeroth-order spherical Bessel function $j_{0}(x)$ for the Fourier transforms. Use a radial grid extending to a sufficiently large cutoff radius and a stable quadrature scheme to ensure convergence.\n3. Quantitatively compare the two form factors by computing the absolute difference $\\Delta(q) = F_{\\mathrm{fold}}(q) - F_{\\mathrm{point}}(q)$.\n\nYour program must compute $\\Delta(q)$ for the following test suite of cases, each specified by $(\\text{name}, Z, N, c_p, a_p, c_n, a_n, q)$ with $q$ in fm$^{-1}$ and all radii in fm:\n- Case 1 (edge, zero momentum): $(\"^{40}\\mathrm{Ca}\", 20, 20, 3.5, 0.5, 3.5, 0.5, 0.0)$\n- Case 2 (low $q$, symmetric): $(\"^{40}\\mathrm{Ca}\", 20, 20, 3.5, 0.5, 3.5, 0.5, 0.5)$\n- Case 3 (high $q$, symmetric): $(\"^{40}\\mathrm{Ca}\", 20, 20, 3.5, 0.5, 3.5, 0.5, 3.0)$\n- Case 4 (low $q$, neutron-rich with skin): $(\"^{48}\\mathrm{Ca}\", 20, 28, 3.55, 0.52, 3.60, 0.55, 0.5)$\n- Case 5 (high $q$, neutron-rich with skin): $(\"^{48}\\mathrm{Ca}\", 20, 28, 3.55, 0.52, 3.60, 0.55, 3.0)$\n- Case 6 (moderate $q$, heavier medium-mass): $(\"^{56}\\mathrm{Ni}\", 28, 28, 4.20, 0.52, 4.25, 0.52, 1.0)$\n\nAll physical quantities must be handled in the units specified above. The form factors are dimensionless. Your program should produce a single line of output containing the values of $\\Delta(q)$ for the six cases, in the same order as listed, as a comma-separated list enclosed in square brackets. Each value must be a float rounded to six decimal places. For example, an output line of the correct format looks like $[x_1,x_2,x_3,x_4,x_5,x_6]$, where each $x_i$ is a decimal float.", "solution": "The problem requires the calculation of the difference $\\Delta(q) = F_{\\mathrm{fold}}(q) - F_{\\mathrm{point}}(q)$ between the folded and point-proton charge form factors for a spherically symmetric nucleus. This will be accomplished by first deriving the analytical expressions for all quantities based on the provided definitions, and then implementing a numerical scheme to evaluate the resulting integrals.\n\n**1. Density Normalization**\nThe spatial distributions of proton and neutron centers are given by the two-parameter Fermi (2pF) function, $f(r;c,a) = \\left(1 + \\exp\\left(\\frac{r - c}{a}\\right)\\right)^{-1}$. The normalized point-nucleon densities are $\\rho_{p}(r) = \\rho_{0,p} f(r;c_p,a_p)$ and $\\rho_{n}(r) = \\rho_{0,n} f(r;c_n,a_n)$. The normalization constants $\\rho_{0,p}$ and $\\rho_{0,n}$ are determined by the condition that the integral of the density over all space equals one. For the proton density $\\rho_p(r)$:\n$$4\\pi \\int_{0}^{\\infty} r^{2} \\rho_{p}(r)\\,dr = 1$$\nSubstituting the expression for $\\rho_p(r)$:\n$$4\\pi \\rho_{0,p} \\int_{0}^{\\infty} r^{2} f(r;c_p,a_p)\\,dr = 1$$\nThis gives the normalization constant $\\rho_{0,p}$ as:\n$$\\rho_{0,p} = \\left( 4\\pi \\int_{0}^{\\infty} r^{2} f(r;c_p,a_p)\\,dr \\right)^{-1}$$\nAn identical expression holds for the neutron normalization constant $\\rho_{0,n}$ with parameters $(c_n, a_n)$:\n$$\\rho_{0,n} = \\left( 4\\pi \\int_{0}^{\\infty} r^{2} f(r;c_n,a_n)\\,dr \\right)^{-1}$$\nThe integrals must be computed numerically.\n\n**2. Point-Nucleon Form Factor, $F_{\\mathrm{point}}(q)$**\nThe point-nucleon proton charge form factor, $F_{\\mathrm{point}}(q)$, is the three-dimensional Fourier transform of the normalized point-proton density $\\rho_p(r)$. For a general spherically symmetric density $\\rho(r)$, the Fourier transform $F(q)$, where $q = |\\vec{q}|$, is derived as follows:\n$$F(q) = \\int \\rho(r) e^{-i \\vec{q} \\cdot \\vec{r}} d^3r$$\nUsing spherical coordinates where $\\vec{q}$ is aligned with the z-axis, $\\vec{q} \\cdot \\vec{r} = qr \\cos\\theta$, and $d^3r = r^2 \\sin\\theta dr d\\theta d\\phi$:\n$$F(q) = \\int_0^{2\\pi} d\\phi \\int_0^{\\pi} d\\theta \\sin\\theta \\int_0^{\\infty} dr \\, r^2 \\rho(r) e^{-iqr\\cos\\theta}$$\nThe integral over $\\phi$ yields $2\\pi$. The integral over $\\theta$ is:\n$$\\int_0^{\\pi} \\sin\\theta e^{-iqr\\cos\\theta} d\\theta = \\frac{2\\sin(qr)}{qr} = 2j_0(qr)$$\nwhere $j_0(x)$ is the zeroth-order spherical Bessel function. Combining these results gives:\n$$F(q) = 4\\pi \\int_{0}^{\\infty} r^2 \\rho(r) j_0(qr) dr$$\nApplying this to the normalized proton density $\\rho_p(r)$, we obtain the expression for the point form factor:\n$$F_{\\mathrm{point}}(q) = 4\\pi \\int_{0}^{\\infty} r^2 \\rho_p(r) j_0(qr) dr = 4\\pi \\rho_{0,p} \\int_0^{\\infty} r^2 f(r;c_p, a_p) j_0(qr) dr$$\nAt $q=0$, we have $j_0(0) = 1$. The expression becomes $F_{\\mathrm{point}}(0) = 4\\pi \\rho_{0,p} \\int_0^{\\infty} r^2 f(r;c_p, a_p) dr$. Using the definition of $\\rho_{0,p}$, we confirm that $F_{\\mathrm{point}}(0)=1$, as required. A similar expression defines the point-neutron form factor $F_n(q)$.\n\n**3. Intrinsic Nucleon Form Factors**\nThe folded form factor accounts for the intrinsic charge distribution of the nucleons.\nFor the proton, with RMS charge radius $r_p = 0.84\\,\\mathrm{fm}$, a 3D Gaussian charge distribution leads to a Gaussian form factor. The relationship between a form factor $F(q)$ and the mean-square radius $\\langle r^2 \\rangle$ for small $q$ is $F(q) \\approx 1 - \\frac{1}{6}q^2 \\langle r^2 \\rangle$. The Gaussian form factor that satisfies this is:\n$$G_E^p(q) = \\exp\\left(-\\frac{q^2 r_p^2}{6}\\right)$$\nFor the neutron, the problem specifies that its intrinsic form factor $G_E^n(q)$ must reproduce the mean-square charge radius $\\langle r_n^2 \\rangle = -0.1161\\,\\mathrm{fm}^2$ at small $q$ and decay on a scale similar to the proton. The neutron's total charge is zero, so $G_E^n(0)=0$. The small-$q$ behavior is $G_E^n(q) \\approx - \\frac{1}{6}q^2 \\langle r_n^2 \\rangle$. A simple, physically-motivated parameterization that satisfies all conditions is to multiply this small-$q$ term by a Gaussian decay factor with the same scale as the proton's:\n$$G_E^n(q) = -\\frac{\\langle r_n^2 \\rangle}{6} q^2 \\exp\\left(-\\frac{q^2 r_p^2}{6}\\right)$$\nThis function correctly has $G_E^n(0)=0$ and reproduces the desired mean-square radius, as $\\langle r_n^2 \\rangle = -6 \\frac{dG_E^n}{dq^2}\\Big|_{q^2=0}$.\n\n**4. Folded Charge Form Factor, $F_{\\mathrm{fold}}(q)$**\nThe nuclear charge form factor is the Fourier transform of the total nuclear charge density, which is the convolution of nucleon-center distributions with intrinsic nucleon charge distributions. By the convolution theorem, in momentum space, this corresponds to a product of form factors. The total form factor, normalized by the proton number $Z$, is:\n$$F_{\\mathrm{fold}}(q) = \\frac{1}{Z} \\left[ Z \\cdot F_p(q) G_E^p(q) + N \\cdot F_n(q) G_E^n(q) \\right]$$\nHere, $F_p(q)$ is notation for the point-proton form factor we previously called $F_{\\mathrm{point}}(q)$, and $F_n(q)$ is the point-neutron form factor. The expression simplifies to:\n$$F_{\\mathrm{fold}}(q) = F_{\\mathrm{point}}(q) G_E^p(q) + \\frac{N}{Z} F_n(q) G_E^n(q)$$\nWe can check that $F_{\\mathrm{fold}}(0) = F_{\\mathrm{point}}(0)G_E^p(0) + \\frac{N}{Z}F_n(0)G_E^n(0) = (1)(1) + \\frac{N}{Z}(1)(0) = 1$, satisfying the problem condition.\n\n**5. Final Expression for $\\Delta(q)$**\nThe quantity to compute is $\\Delta(q) = F_{\\mathrm{fold}}(q) - F_{\\mathrm{point}}(q)$. Substituting the derived expressions:\n$$\\Delta(q) = \\left( F_{\\mathrm{point}}(q) G_E^p(q) + \\frac{N}{Z} F_n(q) G_E^n(q) \\right) - F_{\\mathrm{point}}(q)$$\n$$\\Delta(q) = F_{\\mathrm{point}}(q) (G_E^p(q) - 1) + \\frac{N}{Z} F_n(q) G_E^n(q)$$\nThis is the final expression to be implemented numerically. For the specific case of $q=0$, we have $G_E^p(0)=1$ and $G_E^n(0)=0$, which immediately gives $\\Delta(0)=0$.\n\n**6. Numerical Implementation**\nThe algorithm proceeds as follows:\n- For a given set of parameters $(Z, N, c_p, a_p, c_n, a_n, q)$, first check if $q=0$. If so, the result is $0$.\n- If $q \\neq 0$, the necessary integrals for $\\rho_{0,p}$, $\\rho_{0,n}$, $F_{\\mathrm{point}}(q)$, and $F_n(q)$ are computed using a numerical quadrature routine. The `scipy.integrate.quad` function is suitable for this task.\n- The integrals are performed over a finite radial grid from $r=0$ to a cutoff $r_{\\text{max}}$. Since the Fermi function decays exponentially, a cutoff of $r_{\\text{max}} = 25\\,\\mathrm{fm}$ is more than sufficient to ensure convergence for the given parameters.\n- The zeroth-order spherical Bessel function $j_0(qr)$ is evaluated using `scipy.special.spherical_jn`.\n- With all components computed, $\\Delta(q)$ is calculated using the final expression derived above. This process is repeated for all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Computes the difference between folded and point-proton charge form factors\n    for a set of test cases.\n    \"\"\"\n    \n    # Define physical constants from the problem. All units are in fm.\n    # Proton root-mean-square radius squared (fm^2)\n    R_P_SQ = 0.84**2\n    # Neutron mean-square charge radius (fm^2)\n    R_N_SQ = -0.1161\n\n    # Define the test cases from the problem statement.\n    # Format: (name, Z, N, c_p, a_p, c_n, a_n, q)\n    test_cases = [\n        (\"40Ca\", 20, 20, 3.5, 0.5, 3.5, 0.5, 0.0),\n        (\"40Ca\", 20, 20, 3.5, 0.5, 3.5, 0.5, 0.5),\n        (\"40Ca\", 20, 20, 3.5, 0.5, 3.5, 0.5, 3.0),\n        (\"48Ca\", 20, 28, 3.55, 0.52, 3.60, 0.55, 0.5),\n        (\"48Ca\", 20, 28, 3.55, 0.52, 3.60, 0.55, 3.0),\n        (\"56Ni\", 28, 28, 4.20, 0.52, 4.25, 0.52, 1.0)\n    ]\n\n    def fermi_dist(r, c, a):\n        \"\"\"Calculates the two-parameter Fermi (2pF) distribution value.\"\"\"\n        # Safeguard against potential overflow in np.exp for large arguments.\n        # If (r-c)/a is large and positive, the exponential dominates and f -> 0.\n        arg = (r - c) / a\n        if arg > 700:\n            return 0.0\n        return 1.0 / (1.0 + np.exp(arg))\n\n    def calculate_delta(params):\n        \"\"\"\n        Calculates Delta(q) for a single case.\n        Delta(q) = F_fold(q) - F_point(q)\n        \"\"\"\n        _, Z, N, c_p, a_p, c_n, a_n, q = params\n        \n        # Analytic result for q=0 edge case.\n        # G_E^p(0)=1 and G_E^n(0)=0, so Delta(0) = F_point(0)(1-1) + ... = 0.\n        if q == 0.0:\n            return 0.0\n\n        # Set a sufficiently large radial cutoff for integration (in fm).\n        r_max = 25.0\n\n        # 1. Calculate normalization constants rho_0,p and rho_0,n\n        # The integral is I = integral(r^2 * f(r) dr) from 0 to infinity.\n        # rho_0 = 1 / (4 * pi * I)\n        integrand_norm_p = lambda r: r**2 * fermi_dist(r, c_p, a_p)\n        I_p, _ = quad(integrand_norm_p, 0, r_max)\n        rho_0_p = 1.0 / (4.0 * np.pi * I_p)\n\n        integrand_norm_n = lambda r: r**2 * fermi_dist(r, c_n, a_n)\n        I_n, _ = quad(integrand_norm_n, 0, r_max)\n        rho_0_n = 1.0 / (4.0 * np.pi * I_n)\n\n        # 2. Calculate point-proton form factor F_point(q)\n        # F_point(q) = 4*pi*rho_0_p * integral(r^2 * f_p(r) * j0(qr) dr)\n        integrand_Fp = lambda r: r**2 * fermi_dist(r, c_p, a_p) * spherical_jn(0, q * r)\n        I_Fp, _ = quad(integrand_Fp, 0, r_max)\n        F_point_q = 4.0 * np.pi * rho_0_p * I_Fp\n\n        # 3. Calculate point-neutron form factor F_n(q)\n        # F_n(q) = 4*pi*rho_0_n * integral(r^2 * f_n(r) * j0(qr) dr)\n        integrand_Fn = lambda r: r**2 * fermi_dist(r, c_n, a_n) * spherical_jn(0, q * r)\n        I_Fn, _ = quad(integrand_Fn, 0, r_max)\n        F_n_q = 4.0 * np.pi * rho_0_n * I_Fn\n\n        # 4. Calculate intrinsic nucleon form factors G_E^p(q) and G_E^n(q)\n        q_sq = q**2\n        G_E_p_q = np.exp(-q_sq * R_P_SQ / 6.0)\n        G_E_n_q = -(R_N_SQ / 6.0) * q_sq * np.exp(-q_sq * R_P_SQ / 6.0)\n\n        # 5. Calculate Delta(q) = F_point(q)*(G_E^p(q)-1) + (N/Z)*F_n(q)*G_E^n(q)\n        delta_q = F_point_q * (G_E_p_q - 1.0) + (N / Z) * F_n_q * G_E_n_q\n        \n        return delta_q\n\n    results = []\n    for case in test_cases:\n        result = calculate_delta(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3573943"}, {"introduction": "While continuum models are invaluable, many modern *ab initio* nuclear structure calculations are performed on a discrete spatial lattice, which introduces systematic uncertainties. This exercise addresses the critical task of quantifying and correcting for these computational artifacts, namely discretization errors arising from a finite lattice spacing, $a$, and finite-volume effects from a limited box size, $L$. By analyzing a simple Gaussian model, you will learn to identify error scaling laws and perform a simultaneous extrapolation to the physical continuum ($a \\to 0$) and infinite-volume ($L \\to \\infty$) limits, a vital skill for producing reliable predictions from lattice simulations [@problem_id:3574008].", "problem": "Consider a spherically symmetric nuclear charge density modeled by a three-dimensional Gaussian,\n$$\\rho(\\mathbf{r}) = \\frac{1}{\\pi^{3/2} R^3} \\exp\\!\\left(-\\frac{x^2+y^2+z^2}{R^2}\\right),$$\nwith a characteristic length scale $R$. This density is normalized in infinite space so that the total charge is $1$ (dimensionless), and the exact infinite-volume mean-square radius is\n$$\\langle r^2 \\rangle_\\infty = \\int_{\\mathbb{R}^3} r^2 \\rho(\\mathbf{r}) \\, d^3r = \\frac{3 R^2}{2}.$$\n\nSuppose you compute $\\rho(\\mathbf{r})$ and $\\langle r^2 \\rangle$ on a periodic cubic lattice of side length $L$ and spacing $a$ using the midpoint rule on a uniform grid. Let $N = L/a$ (assume $N$ is an integer), and define the one-dimensional midpoints by\n$$x_i = -\\frac{L}{2} + \\left(i + \\frac{1}{2}\\right) a, \\quad i \\in \\{0,1,\\dots,N-1\\}.$$\nDefine the lattice estimators\n$$S_0(a,L) = a^3 \\sum_{i,j,k=0}^{N-1} \\rho(x_i, x_j, x_k), \\qquad S_2(a,L) = a^3 \\sum_{i,j,k=0}^{N-1} \\rho(x_i, x_j, x_k) \\, (x_i^2 + x_j^2 + x_k^2),$$\nand the lattice mean-square radius\n$$\\langle r^2 \\rangle_{\\text{lat}}(a,L) = \\frac{S_2(a,L)}{S_0(a,L)}.$$\nBecause $\\rho(\\mathbf{r})$ factorizes over Cartesian directions, you may exploit this structure algorithmically.\n\nFinite-volume effects can be isolated by comparing to the continuum cube (no discretization, finite $L$) reference, obtained by exact integration over the cube $[-L/2,L/2]^3$. Let\n$$I_0(L) = \\int_{-L/2}^{L/2} \\frac{1}{\\sqrt{\\pi} R} e^{-x^2/R^2} \\, dx = \\operatorname{erf}\\!\\left(\\frac{L}{2R}\\right),$$\n$$I_2(L) = \\int_{-L/2}^{L/2} \\frac{x^2}{\\sqrt{\\pi} R} e^{-x^2/R^2} \\, dx = R^2 \\left[\\frac{1}{2} \\operatorname{erf}\\!\\left(\\frac{L}{2R}\\right) - \\frac{L}{2 R \\sqrt{\\pi}} e^{-(L/2R)^2}\\right],$$\nand\n$$\\langle r^2 \\rangle_{\\text{cube}}(L) = 3 \\, \\frac{I_2(L)}{I_0(L)}.$$\nHere $\\operatorname{erf}$ is the error function and $\\operatorname{erfc}$ is the Complementary Error Function (erfc), defined by $\\operatorname{erfc}(x)=1-\\operatorname{erf}(x)$.\n\nTask. Starting only from fundamental definitions of Riemann sums and well-tested facts about the error function, you must:\n- Derive the leading-order discretization error scaling for the midpoint rule applied to $\\langle r^2 \\rangle_{\\text{lat}}(a,L)$ at fixed $L$, expressing the scaling in powers of $a$.\n- Derive the finite-volume dependence of $\\langle r^2 \\rangle_{\\text{cube}}(L)$ as $L \\to \\infty$ for the Gaussian model, explicitly connecting it to $\\operatorname{erf}$ or $\\operatorname{erfc}$, and identify the asymptotic decay of the finite-volume error.\n- Propose a simultaneous extrapolation ansatz of the form\n$$\\langle r^2 \\rangle_{\\text{lat}}(a,L) = \\langle r^2 \\rangle_\\infty + c_a \\, a^2 + c_L \\, f(L; R),$$\nwhere $f(L;R)$ is a known function capturing the leading finite-volume scaling from your derivation, and $c_a$, $c_L$ are fit coefficients. You must select $f(L;R)$ so that it decays in $L$ consistently with your derivation.\n\nThen implement a program that:\n- Computes $\\langle r^2 \\rangle_{\\text{lat}}(a,L)$ via factorized $1$-dimensional sums, and computes $\\langle r^2 \\rangle_{\\text{cube}}(L)$ via the exact formulas above.\n- Uses the program to quantify the observed scaling laws and perform the extrapolation fit.\n\nUse the following fixed model and test suite. All lengths must be in femtometers (fm) and all mean-square radii in femtometer-squared (fm$^2$). Use $R = 1.0$ fm.\n\nTest suite:\n- Test $1$ (discretization scaling exponent): Use $L = 12.0$ fm, with two spacings $a_1 = 0.6$ fm and $a_2 = 0.3$ fm. Compute the discretization errors\n$$E_{\\text{disc}}(a;L) = \\left| \\langle r^2 \\rangle_{\\text{lat}}(a,L) - \\langle r^2 \\rangle_{\\text{cube}}(L) \\right|,$$\nand estimate the observed scaling exponent\n$$p = \\frac{\\ln\\!\\left(E_{\\text{disc}}(a_1;L)/E_{\\text{disc}}(a_2;L)\\right)}{\\ln\\!\\left(a_1/a_2\\right)}.$$\n- Test $2$ (finite-volume error magnitudes in the continuum cube): Using the exact continuum cube values (no discretization), compute the absolute finite-volume errors\n$$E_{\\text{vol}}(L) = \\left| \\langle r^2 \\rangle_{\\text{cube}}(L) - \\langle r^2 \\rangle_\\infty \\right|,$$\nfor $L \\in \\{6.0 \\text{ fm}, 10.0 \\text{ fm}\\}$.\n- Test $3$ (simultaneous extrapolation): Build a data set of lattice measurements $\\langle r^2 \\rangle_{\\text{lat}}(a,L)$ for\n$$a \\in \\{0.6 \\text{ fm},\\, 0.4 \\text{ fm},\\, 0.3 \\text{ fm}\\}, \\quad L \\in \\{9.6 \\text{ fm},\\, 12.0 \\text{ fm}\\},$$\nwhich ensures $N=L/a$ is an integer for each pair. Fit the linear model\n$$\\langle r^2 \\rangle_{\\text{lat}}(a,L) = \\langle r^2 \\rangle_\\infty + c_a \\, a^2 + c_L \\, \\operatorname{erfc}\\!\\left(\\frac{L}{2R}\\right),$$\nby least squares over all six points, and report the absolute deviation of the fitted $\\langle r^2 \\rangle_\\infty$ from the exact $\\frac{3 R^2}{2}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$[p,\\; E_{\\text{vol}}(6.0\\ \\text{fm}),\\; E_{\\text{vol}}(10.0\\ \\text{fm}),\\; |\\langle r^2 \\rangle_{\\infty,\\text{fit}} - \\tfrac{3 R^2}{2}|],$$\nwith each floating-point number rounded to six decimal places, and the second, third, and fourth entries understood to be in $\\text{fm}^2$ while the first entry $p$ is dimensionless. Angles are not used in this problem. Percentages must not be used; express all ratios as decimals.", "solution": "The problem statement is critically examined and determined to be valid. It presents a well-posed problem in computational nuclear physics that is scientifically grounded and internally consistent, notwithstanding a subtle tension between the derived and prescribed functional forms for the finite-volume error, which will be addressed in the derivation. All necessary parameters and definitions are provided for a unique solution.\n\n**Theoretical Derivations**\n\nA complete theoretical analysis is required to justify the computational method. This involves deriving the scaling of the two primary sources of error: discretization error from the lattice spacing $a$, and finite-volume error from the box size $L$.\n\n**Discretization Error Scaling**\nThe lattice estimators $S_0(a,L)$ and $S_2(a,L)$ are three-dimensional Riemann sums using the midpoint rule for the integrals $\\int_{[-L/2,L/2]^3} \\rho(\\mathbf{r})\\,d^3r$ and $\\int_{[-L/2,L/2]^3} r^2 \\rho(\\mathbf{r})\\,d^3r$, respectively. The Gaussian charge density $\\rho(\\mathbf{r})$ is separable, $\\rho(x,y,z) = \\rho_1(x)\\rho_1(y)\\rho_1(z)$, where $\\rho_1(x) = (\\pi R^2)^{-1/2} e^{-x^2/R^2}$. This allows the three-dimensional sums to be factorized into products of one-dimensional sums.\nLet us define the one-dimensional sums:\n$$J_0(a,L) = a \\sum_{i=0}^{N-1} \\rho_1(x_i), \\qquad J_2(a,L) = a \\sum_{i=0}^{N-1} x_i^2 \\rho_1(x_i)$$\nThe three-dimensional estimators can then be expressed as:\n$$S_0(a,L) = J_0^3(a,L), \\qquad S_2(a,L) = 3 J_2(a,L) J_0^2(a,L)$$\nThe lattice mean-square radius is the ratio:\n$$\\langle r^2 \\rangle_{\\text{lat}}(a,L) = \\frac{S_2(a,L)}{S_0(a,L)} = \\frac{3 J_2(a,L) J_0^2(a,L)}{J_0^3(a,L)} = 3\\frac{J_2(a,L)}{J_0(a,L)}$$\nThe error in this quantity arises from the error in the one-dimensional midpoint sums $J_0$ and $J_2$. The Euler-Maclaurin formula for the midpoint rule states that for a sufficiently smooth function $f(x)$ integrated over $[c,d]$:\n$$a \\sum_{i=0}^{N-1} f(x_i) = \\int_c^d f(x) dx + \\frac{a^2}{24}\\left[f'(d)-f'(c)\\right] + O(a^4)$$\nThe integrands for $J_0$ and $J_2$, which are $\\rho_1(x)$ and $x^2\\rho_1(x)$, are infinitely differentiable. For a finite domain $[-L/2, L/2]$, their derivatives at the boundaries are non-zero. Thus, the leading-order error for both $J_0(a,L)$ and $J_2(a,L)$ is proportional to $a^2$.\n$$J_0(a,L) = I_0(L) + C_0(L) a^2 + O(a^4)$$\n$$J_2(a,L) = I_2(L) + C_2(L) a^2 + O(a^4)$$\nThe error in the ratio is then found by Taylor expansion:\n$$\\langle r^2 \\rangle_{\\text{lat}}(a,L) = 3 \\frac{I_2(L) + C_2 a^2 \\dots}{I_0(L) + C_0 a^2 \\dots} = 3\\frac{I_2}{I_0} \\left(1 + \\left(\\frac{C_2}{I_2}-\\frac{C_0}{I_0}\\right)a^2 + \\dots \\right) = \\langle r^2 \\rangle_{\\text{cube}}(L) + c_a(L) a^2 + O(a^4)$$\nTherefore, the discretization error $E_{\\text{disc}}(a;L) = |\\langle r^2 \\rangle_{\\text{lat}}(a,L) - \\langle r^2 \\rangle_{\\text{cube}}(L)|$ scales as $a^2$, and the exponent $p$ is expected to be $2$.\n\n**Finite-Volume Error Scaling**\nThe finite-volume error in the continuum is $E_{\\text{vol}}(L) = \\langle r^2 \\rangle_{\\text{cube}}(L) - \\langle r^2 \\rangle_\\infty$. We are given:\n$$\\langle r^2 \\rangle_{\\text{cube}}(L) = 3 \\frac{I_2(L)}{I_0(L)}, \\quad \\langle r^2 \\rangle_\\infty = \\frac{3R^2}{2}$$\nSubstituting the provided expressions for $I_0(L)$ and $I_2(L)$:\n$$E_{\\text{vol}}(L) = 3 \\frac{R^2 \\left[\\frac{1}{2} \\operatorname{erf}\\left(\\frac{L}{2R}\\right) - \\frac{L}{2R\\sqrt{\\pi}} e^{-(L/2R)^2}\\right]}{\\operatorname{erf}\\left(\\frac{L}{2R}\\right)} - \\frac{3R^2}{2}$$\n$$E_{\\text{vol}}(L) = \\frac{3R^2}{2} - \\frac{3R^2 \\cdot \\frac{L}{2R\\sqrt{\\pi}} e^{-(L/2R)^2}}{\\operatorname{erf}\\left(\\frac{L}{2R}\\right)} - \\frac{3R^2}{2} = -\\frac{3RL}{2\\sqrt{\\pi}} \\frac{e^{-(L/2R)^2}}{\\operatorname{erf}\\left(\\frac{L}{2R}\\right)}$$\nAs $L \\to \\infty$, $z = L/(2R) \\to \\infty$ and $\\operatorname{erf}(z) \\to 1$. The leading asymptotic behavior of the error is:\n$$E_{\\text{vol}}(L) \\sim -\\frac{3RL}{2\\sqrt{\\pi}} e^{-(L/2R)^2}$$\nThis error scales as $L \\exp(-(L/2R)^2)$.\nThe problem, however, specifies an extrapolation function proportional to $\\operatorname{erfc}(z)$. The asymptotic expansion $\\operatorname{erfc}(z) \\sim \\frac{e^{-z^2}}{z\\sqrt{\\pi}}$ for large $z$ shows that $\\operatorname{erfc}(L/2R)$ scales as $L^{-1}\\exp(-(L/2R)^2)$. This functional form is not strictly consistent with our rigorous derivation from the given integral formulas. However, the total charge omitted from the finite-volume integral, $1 - (\\operatorname{erf}(L/2R))^3$, does asymptotically scale with $\\operatorname{erfc}(L/2R)$. Using $\\operatorname{erfc}(L/2R)$ as the basis function for the finite-volume error is a common, if not strictly derived, practice. Given the explicit instruction in the problem, we will proceed to use $f(L;R) = \\operatorname{erfc}(L/2R)$ for the extrapolation fit.\n\n**Extrapolation Ansatz**\nCombining the two leading error terms, the proposed model for a simultaneous extrapolation to $a \\to 0$ (continuum limit) and $L \\to \\infty$ (infinite-volume limit) is:\n$$\\langle r^2 \\rangle_{\\text{lat}}(a,L) = \\langle r^2 \\rangle_\\infty + c_a a^2 + c_L f(L;R)$$\nwhere $\\langle r^2 \\rangle_\\infty$, $c_a$, and $c_L$ are fit parameters. As per the problem statement, we adopt $f(L;R) = \\operatorname{erfc}(L/2R)$, yielding the linear model to be fitted:\n$$\\langle r^2 \\rangle_{\\text{lat}}(a,L) = \\langle r^2 \\rangle_{\\infty, \\text{fit}} + c_a a^2 + c_L \\operatorname{erfc}\\left(\\frac{L}{2R}\\right)$$\n\n**Computational Strategy**\n\nThe numerical implementation proceeds in three stages as specified by the test suite.\n\n**Test 1: Discretization Scaling Exponent**\nWe compute $\\langle r^2 \\rangle_{\\text{lat}}(a,L)$ for a fixed box size $L=12.0$ fm and two lattice spacings, $a_1=0.6$ fm and $a_2=0.3$ fm. We also compute the exact continuum value $\\langle r^2 \\rangle_{\\text{cube}}(12.0 \\text{ fm})$ using the provided formulas involving the error function. The discretization errors $E_{\\text{disc}}(a_1;L)$ and $E_{\\text{disc}}(a_2;L)$ are calculated, and the scaling exponent $p$ is determined from their ratio, $p = \\ln(E_{\\text{disc}}(a_1)/E_{\\text{disc}}(a_2)) / \\ln(a_1/a_2)$.\n\n**Test 2: Finite-Volume Error Magnitude**\nWe compute the absolute finite-volume error $E_{\\text{vol}}(L) = |\\langle r^2 \\rangle_{\\text{cube}}(L) - \\langle r^2 \\rangle_\\infty|$ for two box sizes, $L=6.0$ fm and $L=10.0$ fm. This requires implementing the formula for $\\langle r^2 \\rangle_{\\text{cube}}(L)$ and using the exact infinite-volume value $\\langle r^2 \\rangle_\\infty = 3R^2/2 = 1.5 \\text{ fm}^2$.\n\n**Test 3: Simultaneous Extrapolation**\nA dataset of six $\\langle r^2 \\rangle_{\\text{lat}}(a,L)$ values is generated for pairs of $a \\in \\{0.6, 0.4, 0.3\\}$ fm and $L \\in \\{9.6, 12.0\\}$ fm. We then perform a linear least-squares fit to the model derived above. This corresponds to solving the overdetermined linear system $\\mathbf{y} = A\\mathbf{c}$ for the coefficient vector $\\mathbf{c} = [\\langle r^2 \\rangle_{\\infty, \\text{fit}}, c_a, c_L]^T$, where:\n- $\\mathbf{y}$ is the vector of the six computed $\\langle r^2 \\rangle_{\\text{lat}}(a_i,L_i)$ values.\n- $A$ is the $6 \\times 3$ design matrix with rows $[1, a_i^2, \\operatorname{erfc}(L_i/2R)]$.\nThe `numpy.linalg.lstsq` function is used to find the best-fit coefficients. The final result is the absolute deviation of the fitted intercept $\\langle r^2 \\rangle_{\\infty, \\text{fit}}$ from the exact value $\\langle r^2 \\rangle_\\infty$. All computations use $R=1.0$ fm. The factorization of the sums is exploited for computational efficiency.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf, erfc\n\ndef solve():\n    \"\"\"\n    Computes discretization and finite-volume errors for the mean-square radius\n    of a Gaussian charge distribution, and performs a simultaneous extrapolation.\n    \"\"\"\n\n    # Fixed model parameter\n    R = 1.0  # fm\n\n    # Exact infinite-volume mean-square radius\n    r2_inf_exact = 1.5 * R**2  # fm^2\n\n    def rho_1d(x: np.ndarray, R_val: float) -> np.ndarray:\n        \"\"\"Computes the 1D Gaussian density.\"\"\"\n        return np.exp(-x**2 / R_val**2) / (np.sqrt(np.pi) * R_val)\n\n    def calc_r2_lat(a: float, L: float, R_val: float) -> float:\n        \"\"\"\n        Computes the lattice estimator for the mean-square radius using\n        factorized 1D sums.\n        \"\"\"\n        N = int(round(L / a))\n        if N == 0:\n            return 0.0\n        \n        # Grid points based on the midpoint rule\n        x_i = -L / 2.0 + (np.arange(N) + 0.5) * a\n        rho_vals = rho_1d(x_i, R_val)\n        \n        # 1D midpoint sums\n        j0 = a * np.sum(rho_vals)\n        j2 = a * np.sum(x_i**2 * rho_vals)\n        \n        if j0 == 0.0:\n            return np.inf  # Avoid division by zero\n        \n        return 3.0 * j2 / j0\n\n    def calc_r2_cube(L: float, R_val: float) -> float:\n        \"\"\"\n        Computes the mean-square radius in the continuum cube using the\n        exact integral formulas.\n        \"\"\"\n        z = L / (2.0 * R_val)\n        erf_z = erf(z)\n        \n        if erf_z == 0.0:\n            return np.inf\n\n        i0 = erf_z\n        i2 = R_val**2 * (0.5 * erf_z - (z / np.sqrt(np.pi)) * np.exp(-z**2))\n        \n        return 3.0 * i2 / i0\n\n    # --- Test 1: Discretization scaling exponent ---\n    L_test1 = 12.0\n    a1, a2 = 0.6, 0.3\n    \n    r2_lat_a1 = calc_r2_lat(a1, L_test1, R)\n    r2_lat_a2 = calc_r2_lat(a2, L_test1, R)\n    r2_cube_val = calc_r2_cube(L_test1, R)\n    \n    E_disc_a1 = abs(r2_lat_a1 - r2_cube_val)\n    E_disc_a2 = abs(r2_lat_a2 - r2_cube_val)\n    \n    # The exponent p = log(E1/E2) / log(a1/a2)\n    p = np.log(E_disc_a1 / E_disc_a2) / np.log(a1 / a2)\n\n    # --- Test 2: Finite-volume error magnitudes ---\n    L_vals_test2 = [6.0, 10.0]\n    E_vol_results = []\n    for L_val in L_vals_test2:\n        r2_cube_L = calc_r2_cube(L_val, R)\n        E_vol = abs(r2_cube_L - r2_inf_exact)\n        E_vol_results.append(E_vol)\n\n    # --- Test 3: Simultaneous extrapolation ---\n    fit_points = [\n        (0.6, 9.6), (0.6, 12.0),\n        (0.4, 9.6), (0.4, 12.0),\n        (0.3, 9.6), (0.3, 12.0),\n    ]\n    \n    # Set up the linear system A*c = y for least-squares fitting\n    num_points = len(fit_points)\n    A = np.zeros((num_points, 3))\n    y = np.zeros(num_points)\n    \n    for i, (a_fit, L_fit) in enumerate(fit_points):\n        # The vector y contains the measured values\n        y[i] = calc_r2_lat(a_fit, L_fit, R)\n        \n        # The design matrix A contains the basis functions\n        A[i, 0] = 1.0  # Intercept term for <r^2>_inf\n        A[i, 1] = a_fit**2  # Discretization error term\n        A[i, 2] = erfc(L_fit / (2.0 * R))  # Finite-volume error term\n\n    # Solve the linear least-squares problem\n    coeffs, _, _, _ = np.linalg.lstsq(A, y, rcond=None)\n    r2_inf_fit = coeffs[0]\n    \n    fit_deviation = abs(r2_inf_fit - r2_inf_exact)\n\n    # Prepare final results list\n    final_results = [p, E_vol_results[0], E_vol_results[1], fit_deviation]\n\n    # Format and print the final output\n    output_str = \",\".join([f\"{val:.6f}\" for val in final_results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "3574008"}]}