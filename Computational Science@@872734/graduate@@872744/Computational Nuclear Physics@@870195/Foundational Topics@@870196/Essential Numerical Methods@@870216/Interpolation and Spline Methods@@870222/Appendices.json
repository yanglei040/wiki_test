{"hands_on_practices": [{"introduction": "In many physics problems involving spherical coordinates, radial functions must be 'regular' at the origin, meaning they have a zero first derivative. This practice demonstrates how to enforce this physical constraint directly within the cubic spline formulation. By deriving a specific 'clamped' boundary condition at $r=0$, you will learn how to adapt standard numerical methods to respect fundamental physical principles, ensuring your interpolant is not only accurate but also physically meaningful [@problem_id:3566068].", "problem": "In spherical mean-field calculations in computational nuclear physics, many radial observables (for example, the $s$-wave component of a nucleon density or a central mean-field potential) are regular at the origin. Physical regularity for a radial function $f(r)$ demands that $f(r)$ be finite and smooth at $r=0$, and the leading-order behavior near the origin is even in $r$. A widely observed and well-tested fact is that such regular radial functions admit a Taylor expansion of the form $f(r)=f_{0}+a_{2}r^{2}+a_{4}r^{4}+\\cdots$ for small $r$, where $f_{0}$ and the coefficients $a_{2},a_{4},\\dots$ are finite.\n\nSuppose $f(r)$ is tabulated on a uniform radial grid $r_{0}=0$, $r_{1}=h$, $r_{2}=2h$, $\\dots$ with $h0$, and let $f_{i}=f(r_{i})$. You wish to construct a twice-continuously differentiable cubic spline interpolant $s(r)$ on $[0,R]$ that passes through the tabulated values and enforces the physical regularity constraint at the origin. Let $M_{i}=s''(r_{i})$ denote the (unknown) second derivatives of the spline at the knots.\n\nOn the first interval $[r_{0},r_{1}]$, define the cubic polynomial segment $s_{0}(r)$ by the standard cubic spline construction:\n$$\ns_{0}(r)=\\frac{M_{0}}{6h}(r_{1}-r)^{3}+\\frac{M_{1}}{6h}(r-r_{0})^{3}+\\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(r_{1}-r)+\\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)(r-r_{0}) .\n$$\n\nStarting from the physical regularity base $f(r)=f_{0}+O(r^{2})$ and the cubic spline definition above, derive the clamped boundary condition at $r=0$ that enforces the regularity in the interpolant, and reduce it to a single analytical expression for $M_{0}$ in terms of $h$, $f_{0}$, $f_{1}$, and $M_{1}$.\n\nAnswer specification:\n- Provide your final answer as a single closed-form analytical expression for $M_{0}$ in terms of $h$, $f_{0}$, $f_{1}$, and $M_{1}$.\n- Do not include units in your final expression.\n- No numerical rounding is required.", "solution": "The problem requires the derivation of a boundary condition for a cubic spline interpolant at the origin, $r=0$, that enforces physical regularity.\n\nFirst, I shall formalize the physical regularity condition. The problem states that a regular radial function $f(r)$ near the origin admits a Taylor expansion of the form $f(r) = f_0 + a_2 r^2 + a_4 r^4 + \\cdots$. This means the function is even in $r$ around the origin. A direct consequence of this evenness is that all odd-order derivatives of $f(r)$ at $r=0$ must be zero. The lowest-order condition is on the first derivative. Differentiating the series term by term gives $f'(r) = 2a_2 r + 4a_4 r^3 + \\cdots$. Evaluating at $r=0$ yields $f'(0) = 0$.\n\nThe task specifies to start from the base condition $f(r) = f_0 + O(r^2)$. This is equivalent to stating that $\\lim_{r\\to 0} \\frac{f(r)-f_0}{r} = 0$, which is precisely the definition of $f'(0)=0$, assuming $f(0)=f_0$.\n\nThe cubic spline interpolant, $s(r)$, is intended to approximate $f(r)$ while respecting its fundamental properties. Therefore, to enforce regularity, the spline must satisfy the same condition on its first derivative at the origin. This gives the clamped boundary condition:\n$$\ns'(0) = 0\n$$\nSince the spline is at least $C^1$, the derivative at the knot $r_0=0$ is given by the derivative of the first spline segment, $s_0(r)$. Thus, we must enforce $s_0'(0)=0$.\n\nThe problem provides the formula for the spline segment $s_0(r)$ on the interval $[r_0, r_1]$, where $r_0=0$ and $r_1=h$:\n$$\ns_{0}(r)=\\frac{M_{0}}{6h}(r_{1}-r)^{3}+\\frac{M_{1}}{6h}(r-r_{0})^{3}+\\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(r_{1}-r)+\\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)(r-r_{0})\n$$\nSubstituting $r_0=0$ and $r_1=h$:\n$$\ns_{0}(r)=\\frac{M_{0}}{6h}(h-r)^{3}+\\frac{M_{1}}{6h}r^{3}+\\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(h-r)+\\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)r\n$$\nTo apply the boundary condition, we first compute the derivative of $s_0(r)$ with respect to $r$:\n$$\ns_{0}'(r) = \\frac{d}{dr} \\left[ \\frac{M_{0}}{6h}(h-r)^{3}+\\frac{M_{1}}{6h}r^{3}+\\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(h-r)+\\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)r \\right]\n$$\nUsing the power rule and chain rule for differentiation:\n$$\ns_{0}'(r) = \\frac{M_{0}}{6h} \\cdot 3(h-r)^{2}(-1) + \\frac{M_{1}}{6h} \\cdot 3r^{2}(1) + \\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(-1) + \\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)(1)\n$$\nSimplifying the expression:\n$$\ns_{0}'(r) = -\\frac{M_{0}}{2h}(h-r)^{2} + \\frac{M_{1}}{2h}r^{2} - \\frac{f_{0}}{h} + \\frac{M_{0}h}{6} + \\frac{f_{1}}{h} - \\frac{M_{1}h}{6}\n$$\nThis can be rearranged as:\n$$\ns_{0}'(r) = -\\frac{M_{0}}{2h}(h-r)^{2} + \\frac{M_{1}}{2h}r^{2} + \\frac{f_{1}-f_{0}}{h} + \\frac{h}{6}(M_{0}-M_{1})\n$$\nNow, we evaluate this derivative at the origin, $r=0$:\n$$\ns_{0}'(0) = -\\frac{M_{0}}{2h}(h-0)^{2} + \\frac{M_{1}}{2h}(0)^{2} + \\frac{f_{1}-f_{0}}{h} + \\frac{h}{6}(M_{0}-M_{1})\n$$\n$$\ns_{0}'(0) = -\\frac{M_{0}h^2}{2h} + 0 + \\frac{f_{1}-f_{0}}{h} + \\frac{M_{0}h}{6} - \\frac{M_{1}h}{6}\n$$\n$$\ns_{0}'(0) = -\\frac{M_{0}h}{2} + \\frac{f_{1}-f_{0}}{h} + \\frac{M_{0}h}{6} - \\frac{M_{1}h}{6}\n$$\nCombine the terms containing $M_0$:\n$$\ns_{0}'(0) = M_{0}\\left(\\frac{h}{6} - \\frac{h}{2}\\right) + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n$$\ns_{0}'(0) = M_{0}\\left(\\frac{h-3h}{6}\\right) + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n$$\ns_{0}'(0) = -M_{0}\\frac{2h}{6} + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n$$\ns_{0}'(0) = -M_{0}\\frac{h}{3} + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\nApplying the regularity condition $s'(0) = s_0'(0) = 0$:\n$$\n0 = -M_{0}\\frac{h}{3} + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\nThe final step is to solve this equation for $M_0$ to obtain the required analytical expression.\n$$\nM_{0}\\frac{h}{3} = \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\nMultiplying both sides by $\\frac{3}{h}$:\n$$\nM_{0} = \\frac{3}{h}\\left(\\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\\right)\n$$\n$$\nM_{0} = \\frac{3(f_{1}-f_{0})}{h^{2}} - \\frac{3M_{1}h}{6h}\n$$\n$$\nM_{0} = \\frac{3(f_{1}-f_{0})}{h^{2}} - \\frac{M_{1}}{2}\n$$\nThis is the analytical expression for the second derivative of the spline at the origin, $M_0$, in terms of the grid spacing $h$, the function values $f_0$ and $f_1$, and the second derivative at the next grid point, $M_1$. This relation serves as the clamped boundary condition at $r=0$ that enforces physical regularity.", "answer": "$$\\boxed{\\frac{3(f_{1}-f_{0})}{h^{2}} - \\frac{M_{1}}{2}}$$", "id": "3566068"}, {"introduction": "Beyond local constraints, the global distribution of sample points is critical for interpolation accuracy, especially for functions with multiple length scales like nuclear potentials. This exercise explores how a physically-motivated coordinate transformation—a logarithmic mapping—can concentrate grid points in regions of high curvature and sparsely sample regions of slow variation. By comparing the interpolation error on a uniform grid versus a logarithmic grid, you will quantify the significant gains in efficiency and accuracy that intelligent grid design can provide [@problem_id:3566085].", "problem": "You will quantify how a logarithmic coordinate mapping affects cubic spline interpolation error for a spherically symmetric potential that models the near-origin curvature typical of Coulomb-modified nuclear potentials. Consider a radially symmetric function $f(r)$, with $r$ measured in femtometers, defined as the sum of a finite-size-charge Coulomb potential and a Woods–Saxon (WS) nuclear potential. The Coulomb component is modeled by a uniformly charged sphere of radius $R_C$, so that $V_C(r)$ is given by\n$$\nV_C(r) = \n\\begin{cases}\n\\displaystyle \\frac{k}{2 R_C}\\left(3 - \\frac{r^2}{R_C^2}\\right),  r \\le R_C, \\\\\n\\displaystyle \\frac{k}{r},  r  R_C,\n\\end{cases}\n$$\nwhere $k = \\left(\\frac{e^2}{4\\pi \\varepsilon_0}\\right) Z$ with $Z$ equal to the product $Z_1 Z_2$ of the projectile and target charges and $\\left(\\frac{e^2}{4\\pi \\varepsilon_0}\\right) \\approx 1.439964$ $\\mathrm{MeV \\cdot fm}$. The Woods–Saxon nuclear potential is defined as\n$$\nV_N(r) = -\\frac{V_0}{1 + \\exp\\left(\\frac{r - R_N}{a}\\right)},\n$$\nwith depth $V_0$ in mega-electron-volts, nuclear radius $R_N$ in femtometers, and diffuseness $a$ in femtometers. The total potential is $f(r) = V_C(r) + V_N(r)$, expressed in mega-electron-volts.\n\nTwo interpolation schemes must be constructed:\n- Scheme $\\mathrm{A}$: cubic spline interpolation using $N$ samples taken on a uniform grid in $r \\in [0, r_{\\max}]$.\n- Scheme $\\mathrm{B}$: cubic spline interpolation using $N$ samples taken uniformly in the logarithmic coordinate $x = \\ln\\left(1 + \\frac{r}{r_0}\\right)$ over $x \\in \\left[0, \\ln\\left(1 + \\frac{r_{\\max}}{r_0}\\right)\\right]$, mapped back to $r$ via $r = r_0\\left(e^x - 1\\right)$.\n\nFor both schemes, the spline is constructed in the physical coordinate $r$, and evaluated on a dense uniform grid of $M$ points in $r \\in [0, r_{\\max}]$ (with $M$ chosen large enough to be representative). The interpolation error for scheme $\\mathrm{A}$ is\n$$\nE_A = \\max_{i=1,\\dots,M} \\left| S_A(r_i) - f(r_i) \\right|,\n$$\nand for scheme $\\mathrm{B}$ is\n$$\nE_B = \\max_{i=1,\\dots,M} \\left| S_B(r_i) - f(r_i) \\right|,\n$$\nwhere $S_A$ and $S_B$ are the respective cubic spline interpolants and $\\{r_i\\}$ are the evaluation points. The effect of the logarithmic mapping is quantified by the error reduction factor\n$$\nR = \\frac{E_A}{E_B}.\n$$\n\nYou must implement a complete, runnable program that computes $E_A$, $E_B$, and $R$ for the following test suite of parameter sets. All energies and errors must be computed and reported in mega-electron-volts (MeV). Radii and lengths are in femtometers (fm). The evaluation grid size is $M = 1000$:\n- Test $1$ (general case): $Z = 20$, $R_C = 4.1$ $\\mathrm{fm}$, $R_N = 4.5$ $\\mathrm{fm}$, $a = 0.6$ $\\mathrm{fm}$, $V_0 = 50$ $\\mathrm{MeV}$, $r_0 = 1.0$ $\\mathrm{fm}$, $N = 50$, $r_{\\max} = 20.0$ $\\mathrm{fm}$.\n- Test $2$ (strong Coulomb, fewer samples): $Z = 82$, $R_C = 7.1$ $\\mathrm{fm}$, $R_N = 7.0$ $\\mathrm{fm}$, $a = 0.5$ $\\mathrm{fm}$, $V_0 = 50$ $\\mathrm{MeV}$, $r_0 = 0.5$ $\\mathrm{fm}$, $N = 30$, $r_{\\max} = 25.0$ $\\mathrm{fm}$.\n- Test $3$ (weak Coulomb, nuclear-dominated): $Z = 1$, $R_C = 1.0$ $\\mathrm{fm}$, $R_N = 1.2$ $\\mathrm{fm}$, $a = 0.5$ $\\mathrm{fm}$, $V_0 = 50$ $\\mathrm{MeV}$, $r_0 = 1.0$ $\\mathrm{fm}$, $N = 60$, $r_{\\max} = 15.0$ $\\mathrm{fm}$.\n- Test $4$ (large mapping scale, near-uniform sampling): $Z = 50$, $R_C = 5.6$ $\\mathrm{fm}$, $R_N = 5.6$ $\\mathrm{fm}$, $a = 0.6$ $\\mathrm{fm}$, $V_0 = 50$ $\\mathrm{MeV}$, $r_0 = 10.0$ $\\mathrm{fm}$, $N = 60$, $r_{\\max} = 20.0$ $\\mathrm{fm}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a triplet $[E_A,E_B,R]$ in mega-electron-volts, and the final output is the list of these triplets in order. For example, the output format must be exactly like $[[E_{A,1},E_{B,1},R_1],[E_{A,2},E_{B,2},R_2],[E_{A,3},E_{B,3},R_3],[E_{A,4},E_{B,4},R_4]]$.", "solution": "The problem requires a quantitative comparison of two cubic spline interpolation schemes for a spherically symmetric nuclear potential. The total potential, $f(r)$, is a sum of a Coulomb potential from a finite-sized charge distribution, $V_C(r)$, and a Woods-Saxon nuclear potential, $V_N(r)$. The goal is to compute the interpolation errors for a uniform radial grid (Scheme A) and a logarithmically spaced radial grid (Scheme B) and to quantify the improvement via their ratio.\n\nFirst, we define the potential function $f(r) = V_C(r) + V_N(r)$. All energies are in mega-electron-volts ($\\mathrm{MeV}$) and distances are in femtometers ($\\mathrm{fm}$). The Coulomb component, $V_C(r)$, models a uniformly charged sphere of radius $R_C$. Its functional form is piecewise:\n$$\nV_C(r) = \n\\begin{cases}\n\\displaystyle \\frac{k}{2 R_C}\\left(3 - \\frac{r^2}{R_C^2}\\right),  r \\le R_C, \\\\\n\\displaystyle \\frac{k}{r},  r  R_C,\n\\end{cases}\n$$\nThe parameter $k$ is given by $k = \\left(\\frac{e^2}{4\\pi \\varepsilon_0}\\right) Z$, with the physical constant $\\left(\\frac{e^2}{4\\pi \\varepsilon_0}\\right) \\approx 1.439964 \\, \\mathrm{MeV \\cdot fm}$. This potential is continuous and has a continuous first derivative with respect to $r$ across the boundary $r=R_C$. However, the second derivative, $\\frac{d^2V_C}{dr^2}$, is discontinuous at $r=R_C$. Specifically, $\\frac{d^2V_C}{dr^2} = -\\frac{k}{R_C^3}$ for $r  R_C$ and $\\frac{d^2V_C}{dr^2} = \\frac{2k}{r^3}$ for $r  R_C$. This discontinuity at $r=R_C$ presents a challenge for high-order polynomial interpolation methods, such as cubic splines, which typically assume a higher degree of smoothness.\n\nThe nuclear potential, $V_N(r)$, is given by the standard Woods-Saxon form:\n$$\nV_N(r) = -\\frac{V_0}{1 + \\exp\\left(\\frac{r - R_N}{a}\\right)}\n$$\nThis function is infinitely differentiable ($C^\\infty$) for all $r>0$. The total potential $f(r)$ thus inherits the $C^1$ continuity and the second-derivative discontinuity from its Coulomb component.\n\nNext, we establish the two interpolation schemes. Both schemes use $N$ sample points to construct a cubic spline interpolant of $f(r)$ over the interval $[0, r_{\\max}]$.\n\nScheme A involves sampling the potential $f(r)$ at $N$ points distributed uniformly on the radial grid $r \\in [0, r_{\\max}]$. The sample points are $r_j = j \\cdot \\frac{r_{\\max}}{N-1}$ for $j=0, 1, \\dots, N-1$. A cubic spline, $S_A(r)$, is constructed using the data pairs $(r_j, f(r_j))$.\n\nScheme B uses a sampling grid that is uniform in a logarithmic coordinate $x$, defined by the transformation $x = \\ln\\left(1 + \\frac{r}{r_0}\\right)$. The $N$ sample points are chosen to be uniform in $x$ over the interval $\\left[0, \\ln\\left(1 + \\frac{r_{\\max}}{r_0}\\right)\\right]$. These points are then mapped back to the radial coordinate using the inverse transformation $r = r_0(e^x - 1)$. This results in a set of radial sample points $\\{r_j'\\}$ that are spaced more densely near the origin ($r=0$) and more sparsely at large $r$. The density of points $dN/dr$ is proportional to $(r_0+r)^{-1}$. A cubic spline, $S_B(r)$, is then constructed using the data pairs $(r_j', f(r_j'))$. This non-uniform distribution is intended to better capture the rapid variation of the potential near the origin.\n\nTo evaluate the accuracy of each scheme, we compute the maximum absolute error over a dense, uniform evaluation grid of $M=1000$ points $\\{r_i\\}$ in the interval $[0, r_{\\max}]$. The errors are defined as:\n$$\nE_A = \\max_{i=1,\\dots,M} \\left| S_A(r_i) - f(r_i) \\right|\n$$\n$$\nE_B = \\max_{i=1,\\dots,M} \\left| S_B(r_i) - f(r_i) \\right|\n$$\nThe effect of the logarithmic mapping is then quantified by the error reduction factor, $R = E_A / E_B$. A value of $R > 1$ indicates that the logarithmic sampling grid provides a more accurate interpolation than the uniform grid for the same number of sample points.\n\nThe implementation will proceed by first defining a Python function for the potential $f(r)$ based on its parameters. For each test case, we will generate the two sets of sample points for Scheme A and Scheme B. Using the `scipy.interpolate.CubicSpline` class, we will construct the interpolants $S_A(r)$ and $S_B(r)$. Finally, we will evaluate these splines and the exact function on the dense grid, compute the maximum errors $E_A$ and $E_B$, and calculate their ratio $R$. This process is repeated for each parameter set provided in the test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Solves the interpolation problem for the given test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (general case)\n        {'Z': 20, 'Rc': 4.1, 'Rn': 4.5, 'a': 0.6, 'V0': 50, 'r0': 1.0, 'N': 50, 'rmax': 20.0},\n        # Test 2 (strong Coulomb, fewer samples)\n        {'Z': 82, 'Rc': 7.1, 'Rn': 7.0, 'a': 0.5, 'V0': 50, 'r0': 0.5, 'N': 30, 'rmax': 25.0},\n        # Test 3 (weak Coulomb, nuclear-dominated)\n        {'Z': 1, 'Rc': 1.0, 'Rn': 1.2, 'a': 0.5, 'V0': 50, 'r0': 1.0, 'N': 60, 'rmax': 15.0},\n        # Test 4 (large mapping scale, near-uniform sampling)\n        {'Z': 50, 'Rc': 5.6, 'Rn': 5.6, 'a': 0.6, 'V0': 50, 'r0': 10.0, 'N': 60, 'rmax': 20.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_one_case(case)\n        results.append(result)\n\n    # Format the final output string as per the problem specification.\n    # [[E_A1,E_B1,R1],[E_A2,E_B2,R2],...]\n    output_str_parts = []\n    for res in results:\n        # Format each number to avoid excessively long floating point representations\n        e_a_str = f\"{res[0]:.10g}\"\n        e_b_str = f\"{res[1]:.10g}\"\n        r_str = f\"{res[2]:.10g}\"\n        output_str_parts.append(f\"[{e_a_str},{e_b_str},{r_str}]\")\n    \n    final_output = f\"[{','.join(output_str_parts)}]\"\n    print(final_output)\n\ndef _potential_function(r, func_params):\n    \"\"\"\n    Calculates the total potential f(r) = V_C(r) + V_N(r).\n    \n    Args:\n        r (np.ndarray or float): Radial coordinate(s) in fm.\n        func_params (dict): Dictionary of potential parameters.\n    \n    Returns:\n        np.ndarray or float: Total potential in MeV.\n    \"\"\"\n    k_const = 1.439964  # MeV * fm\n    Z, Rc, Rn, a, V0 = func_params['Z'], func_params['Rc'], func_params['Rn'], func_params['a'], func_params['V0']\n    \n    k = k_const * Z\n    \n    r_arr = np.atleast_1d(r)\n    \n    # Coulomb potential V_C(r) for a uniformly charged sphere\n    # Using np.where for vectorized piecewise calculation.\n    # This is safe as r  Rc ensures r is not zero for the second part.\n    vc_inside = (k / (2.0 * Rc)) * (3.0 - (r_arr**2 / Rc**2))\n    vc_outside = k / r_arr\n    Vc = np.where(r_arr = Rc, vc_inside, vc_outside)\n    \n    # Woods-Saxon nuclear potential V_N(r)\n    Vn = -V0 / (1.0 + np.exp((r_arr - Rn) / a))\n    \n    f_r = Vc + Vn\n    \n    return f_r[0] if isinstance(r, (int, float)) else f_r\n\ndef _solve_one_case(case_params):\n    \"\"\"\n    Performs the interpolation and error analysis for a single test case.\n    \"\"\"\n    N = case_params['N']\n    rmax = case_params['rmax']\n    r0 = case_params['r0']\n    M = 1000\n\n    func_params = {k: case_params[k] for k in ('Z', 'Rc', 'Rn', 'a', 'V0')}\n\n    # Dense evaluation grid for accurate error measurement\n    r_eval = np.linspace(0, rmax, M)\n    f_exact = _potential_function(r_eval, func_params)\n\n    # Scheme A: Cubic spline with uniform grid in r\n    r_samples_A = np.linspace(0, rmax, N)\n    y_samples_A = _potential_function(r_samples_A, func_params)\n    spline_A = CubicSpline(r_samples_A, y_samples_A)\n    f_spline_A = spline_A(r_eval)\n    E_A = np.max(np.abs(f_spline_A - f_exact))\n\n    # Scheme B: Cubic spline with logarithmic grid\n    x_max = np.log(1 + rmax / r0)\n    x_samples_B = np.linspace(0, x_max, N)\n    r_samples_B = r0 * (np.exp(x_samples_B) - 1)\n    \n    # CubicSpline needs strictly increasing points. Floating point arithmetic can\n    # occasionally create tiny non-monotonicities or duplicates, especially at r=0.\n    # A simple check and fix ensures robustness.\n    if r_samples_B[1] = r_samples_B[0]:\n        r_samples_B[1] = r_samples_B[0] + np.finfo(float).eps\n    \n    y_samples_B = _potential_function(r_samples_B, func_params)\n    spline_B = CubicSpline(r_samples_B, y_samples_B)\n    f_spline_B = spline_B(r_eval)\n    E_B = np.max(np.abs(f_spline_B - f_exact))\n\n    # Error reduction factor\n    R = E_A / E_B if E_B != 0 else np.inf\n\n    return [E_A, E_B, R]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3566085"}, {"introduction": "The ultimate strategy for efficient interpolation involves adapting the grid to the function's specific features, especially when they are not known well in advance. This practice guides you through implementing a greedy algorithm that iteratively places new knots in regions of maximum error, effectively 'learning' the function's structure. Comparing this adaptive method to fixed grids for approximating complex nuclear cross-sections highlights a powerful, general approach to minimizing interpolation error and optimizing computational resources [@problem_id:3566032].", "problem": "In computational nuclear physics, energy-dependent reaction cross sections are approximated by smooth functions built from a limited number of samples to accelerate transport and reactor-physics calculations. Consider a scalar cross section function $\\sigma(E)$ defined for energy $E$ on a closed interval $\\left[E_{\\min}, E_{\\max}\\right]$, and a cubic spline interpolant $s(E)$ with natural boundary conditions defined on a knot set $\\mathcal{K}=\\left\\{E_1,\\dots,E_K\\right\\}$ with $E_1=E_{\\min}$ and $E_K=E_{\\max}$ and strictly increasing $E_i$. The goal is to design a knot placement strategy that directly targets minimizing the Chebyshev norm (maximum norm) of the residual in relative form, that is, to make small the quantity\n$$\n\\left\\| r \\right\\|_{\\infty} \\equiv \\sup_{E\\in[E_{\\min},E_{\\max}]}\\left|\\frac{s(E)-\\sigma(E)}{\\sigma(E)}\\right|.\n$$\nStarting from core definitions, implement an algorithm that uses the Chebyshev norm of the relative residual to guide knot placement. Begin with the endpoints as knots and, at each step, insert a new knot at the energy where the current spline’s relative residual attains its maximum magnitude. Repeat until the prescribed number of knots $K$ is reached. Use a cubic spline with natural boundary conditions. Evaluate the maximum norm on a dense energy grid that resolves both linear and logarithmic energy structure by taking the union of a linearly spaced grid and a logarithmically spaced grid on $\\left[E_{\\min}, E_{\\max}\\right]$.\n\nThe cross section surrogates to be approximated are constructed from well-tested phenomenology: a $1/\\sqrt{E}$ thermal behavior, a $1/E$ epithermal background, and Lorentzian-shaped single-level resonances. Specifically, use the Lorentzian profile\n$$\nL(E; E_r, \\Gamma, S) \\equiv S \\cdot \\frac{\\Gamma^2/4}{(E-E_r)^2 + \\Gamma^2/4},\n$$\nand define the following cases (all energies in electron-volts and $S$ in a consistent arbitrary scale; the final error is dimensionless, so physical unit conversion is not required):\n\n- Case A (thermal band with a resonance):\n  - Interval $\\left[E_{\\min}, E_{\\max}\\right]=\\left[\\,0.01,\\,10\\,\\right]$.\n  - Number of knots $K=12$.\n  - Cross section\n    $$\n    \\sigma_A(E)=\\frac{4.0}{\\sqrt{E}} + L(E; 1.0, 0.08, 30.0).\n    $$\n- Case B (epithermal band with multiple resonances):\n  - Interval $\\left[E_{\\min}, E_{\\max}\\right]=\\left[\\,1.0,\\,1000.0\\,\\right]$.\n  - Number of knots $K=20$.\n  - Cross section\n    $$\n    \\sigma_B(E)=\\frac{10.0}{E} + L(E; 6.67, 0.2, 60.0) + L(E; 20.0, 0.4, 40.0) + L(E; 200.0, 5.0, 25.0).\n    $$\n- Case C (mixed thermal/epithermal behavior with a resonance and few knots; edge case):\n  - Interval $\\left[E_{\\min}, E_{\\max}\\right]=\\left[\\,0.1,\\,100.0\\,\\right]$.\n  - Number of knots $K=5$.\n  - Cross section\n    $$\n    \\sigma_C(E)=\\frac{3.0}{\\sqrt{E}} + \\frac{2.0}{E} + L(E; 5.0, 0.3, 50.0).\n    $$\n\nYour program must:\n\n- Construct three knot placement strategies for each case:\n  1. Chebyshev-guided greedy insertion using the maximum of the relative residual on a dense grid at each iteration from the starting knots $\\left\\{E_{\\min}, E_{\\max}\\right\\}$ until $K$ knots are placed.\n  2. Uniform spacing in energy with $K$ knots on $\\left[E_{\\min}, E_{\\max}\\right]$.\n  3. Uniform spacing in logarithmic energy with $K$ knots on $\\left[E_{\\min}, E_{\\max}\\right]$.\n- For evaluating the supremum (Chebyshev) norm, approximate it using the union of two grids on $\\left[E_{\\min}, E_{\\max}\\right]$: a linearly spaced grid with $20001$ points and a logarithmically spaced grid with $20001$ points (use only logarithms of positive energies).\n- For each strategy and each case, build a cubic spline $s(E)$ with natural boundary conditions and compute the maximum relative error\n  $$\n  \\varepsilon \\equiv \\max_{E\\in\\mathcal{G}} \\left| \\frac{s(E)-\\sigma(E)}{\\sigma(E)} \\right|,\n  $$\n  where $\\mathcal{G}$ is the prescribed dense grid union.\n- Use a numerically safe denominator by replacing $\\sigma(E)$ with $\\max\\left(\\left|\\sigma(E)\\right|, \\epsilon\\right)$ in the denominator, where $\\epsilon$ is a small positive constant such as $\\epsilon=10^{-12}$, to avoid division by zero if it occurs.\n\nDesign for coverage:\n\n- Case A is a typical thermal regime with a localized narrow feature.\n- Case B is a wide epithermal band with multiple resonances and a broad dynamic range.\n- Case C uses very few knots to stress-test behavior near under-resolution.\n\nFinal output format:\n\n- Produce a single line of output containing a flat, comma-separated list of nine decimal floats, rounded to eight significant digits, enclosed in square brackets. The nine floats must be in the following order:\n  - Case A: Chebyshev-guided maximum relative error, uniformly spaced in energy maximum relative error, uniformly spaced in logarithmic energy maximum relative error.\n  - Case B: same ordering.\n  - Case C: same ordering.\n- For example, the output format must be of the form\n  $$\n  [x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9],\n  $$\n  where each $x_i$ is a decimal float rounded to eight significant digits. No other text should be printed.\n\nAngles are not involved. The reported errors are dimensionless. No user input is required; hard-code the test suite as specified above. The program must be a complete, runnable solution that performs all computations and prints the single required line.", "solution": "The problem posed is to develop and evaluate an adaptive knot placement strategy for cubic spline interpolation, with the goal of minimizing the maximum relative error for functions representative of nuclear cross sections. The performance of this adaptive strategy is to be compared against two standard, non-adaptive knot placement schemes: uniform linear and uniform logarithmic spacing.\n\nThe problem centers on the efficient approximation of a scalar function, $\\sigma(E)$, with a simpler, faster-to-evaluate function, a cubic spline interpolant $s(E)$. The objective is to minimize the maximum relative error, or Chebyshev norm of the relative residual, defined as $\\| r \\|_{\\infty} \\equiv \\sup_{E\\in[E_{\\min},E_{\\max}]}\\left|\\frac{s(E)-\\sigma(E)}{\\sigma(E)}\\right|$. The core task is to implement an adaptive knot placement strategy guided by this error metric and compare its performance against standard non-adaptive methods.\n\n**Methodology**\n\n1.  **Target Function and Evaluation Grid**: The target functions, denoted $\\sigma(E)$, are modeled to represent typical features of neutron reaction cross sections, incorporating a $1/\\sqrt{E}$ thermal behavior, a $1/E$ epithermal behavior, and resonances modeled by Lorentzian profiles. These functions exhibit sharp, localized features and globally varying behavior, making them challenging test cases for interpolation. To accurately determine the maximum error, $\\| (s-\\sigma)/\\sigma \\|_{\\infty}$, the supremum is approximated by a maximum over a dense discrete grid, $\\mathcal{G}$. This grid $\\mathcal{G}$ is constructed as the union of a linearly spaced grid and a logarithmically spaced grid, each with $20001$ points on the interval $[E_{\\min}, E_{\\max}]$. This hybrid structure ensures high resolution for both narrow features (like resonances, resolved by the linear grid) and for phenomena varying over orders of magnitude in energy (like $1/E$ behavior, resolved by the log grid).\n\n2.  **Cubic Spline Interpolation**: We employ cubic splines, which are piecewise cubic polynomials joined at the knots such that the resulting function $s(E)$ is twice continuously differentiable (a $C^2$ function). This smoothness is physically desirable for representing cross sections. The interpolant $s(E)$ is uniquely defined by the knot locations $E_i \\in \\mathcal{K}$ and the corresponding function values $\\sigma(E_i)$. The specified \"natural\" boundary conditions, which impose zero second derivatives at the endpoints ($s''(E_{\\min}) = s''(E_{\\max}) = 0$), are a common choice when no information about the function's derivatives at the boundaries is available.\n\n3.  **Knot Placement Strategies**: The effectiveness of $3$ distinct knot placement strategies is compared.\n\n    *   **Chebyshev-Guided Greedy Insertion**: This is an adaptive, iterative algorithm. It begins with a minimal knot set $\\mathcal{K}_0 = \\{E_{\\min}, E_{\\max}\\}$. At each iteration $j$, it constructs a spline $s_{j-1}(E)$ based on the current knot set $\\mathcal{K}_{j-1}$. It then finds the energy $E^*$ that maximizes the relative residual over the dense grid $\\mathcal{G}$:\n        $$E^* = \\arg\\max_{E \\in \\mathcal{G}} \\left| \\frac{s_{j-1}(E) - \\sigma(E)}{\\sigma(E)} \\right|$$\n        The new knot set is formed by $\\mathcal{K}_j = \\mathcal{K}_{j-1} \\cup \\{E^*\\}$. This process repeats until the knot set contains the prescribed number of knots, $K$. This greedy heuristic intuitively refines the approximation where it is most needed by placing new knots in regions of highest error.\n\n    *   **Uniform Linear Spacing**: A non-adaptive baseline where knots are spaced evenly in energy:\n        $$E_i = E_{\\min} + (i-1) \\frac{E_{\\max} - E_{\\min}}{K-1}, \\quad i=1, \\dots, K$$\n\n    *   **Uniform Logarithmic Spacing**: Another non-adaptive strategy where knots are spaced evenly in the logarithm of energy:\n        $$E_i = E_{\\min} \\left( \\frac{E_{\\max}}{E_{\\min}} \\right)^{\\frac{i-1}{K-1}}, \\quad i=1, \\dots, K$$\n        This is often more effective than linear spacing for functions defined over many decades of energy.\n\n4.  **Error Quantification**: For each strategy and test case, a final spline $s(E)$ is built using the generated knot set $\\mathcal{K}$ of size up to $K$. The quality of the approximation is quantified by the maximum relative error, $\\varepsilon$, computed on the dense grid $\\mathcal{G}$:\n    $$\\varepsilon = \\max_{E \\in \\mathcal{G}} \\left| \\frac{s(E) - \\sigma(E)}{\\sigma(E)} \\right|$$\n    To ensure numerical stability, the denominator is regularized to $\\max(|\\sigma(E)|, \\epsilon)$, where $\\epsilon$ is a small positive constant, $10^{-12}$.\n\n**Implementation**: The algorithm is implemented in Python using `NumPy` for numerical operations and `SciPy` for spline interpolation. The `scipy.interpolate.CubicSpline` function is used with the `bc_type='natural'` option. The iterative greedy algorithm robustly handles knot placement by using a set data structure to manage the knot list, ensuring that unique knots are added until the target count $K$ is reached or the algorithm converges. The final errors for the $9$ scenarios ($3$ cases $\\times$ $3$ strategies) are calculated and formatted to $8$ significant digits.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem, including defining test cases,\n    running the analysis, and printing the formatted results.\n    \"\"\"\n    \n    # Define a small constant for numerically safe division.\n    EPSILON = 1e-12\n    # Define the number of points for dense grids.\n    N_GRID_POINTS = 20001\n\n    # Define the Lorentzian profile function.\n    def lorentzian(E, Er, Gamma, S):\n        \"\"\"\n        Calculates the Lorentzian profile.\n        E: Energy (can be a numpy array).\n        Er: Resonance energy.\n        Gamma: Resonance width.\n        S: Resonance strength.\n        \"\"\"\n        return S * (Gamma**2 / 4) / ((E - Er)**2 + Gamma**2 / 4)\n\n    # Define the cross section functions for each case.\n    def sigma_A(E):\n        \"\"\"Cross section for Case A.\"\"\"\n        return 4.0 / np.sqrt(E) + lorentzian(E, 1.0, 0.08, 30.0)\n\n    def sigma_B(E):\n        \"\"\"Cross section for Case B.\"\"\"\n        return (10.0 / E +\n                lorentzian(E, 6.67, 0.2, 60.0) +\n                lorentzian(E, 20.0, 0.4, 40.0) +\n                lorentzian(E, 200.0, 5.0, 25.0))\n\n    def sigma_C(E):\n        \"\"\"Cross section for Case C.\"\"\"\n        return 3.0 / np.sqrt(E) + 2.0 / E + lorentzian(E, 5.0, 0.3, 50.0)\n\n    def calculate_max_relative_error(sigma_func, knots, dense_grid):\n        \"\"\"\n        Calculates the maximum relative error for a given spline.\n        \"\"\"\n        knots = np.unique(knots) # Ensure knots are sorted and unique.\n        if len(knots)  2:\n            return np.inf # Not enough points to build a spline.\n\n        y_knots = sigma_func(knots)\n        spline = CubicSpline(knots, y_knots, bc_type='natural')\n        \n        s_grid = spline(dense_grid)\n        sigma_grid = sigma_func(dense_grid)\n        \n        denominator = np.maximum(np.abs(sigma_grid), EPSILON)\n        relative_error = np.abs((s_grid - sigma_grid) / denominator)\n        \n        return np.max(relative_error)\n\n    def generate_chebyshev_knots(sigma_func, E_min, E_max, K, dense_grid):\n        \"\"\"\n        Generates knots using the Chebyshev-guided greedy insertion algorithm.\n        \"\"\"\n        knots = {E_min, E_max}\n        \n        while len(knots)  K:\n            current_knot_array = np.array(sorted(list(knots)))\n            \n            # This check prevents infinite loops if we can't find new unique knots.\n            last_len = len(knots)\n            \n            y_knots = sigma_func(current_knot_array)\n            spline = CubicSpline(current_knot_array, y_knots, bc_type='natural')\n            \n            s_grid = spline(dense_grid)\n            sigma_grid = sigma_func(dense_grid)\n            \n            denominator = np.maximum(np.abs(sigma_grid), EPSILON)\n            relative_residual = np.abs((s_grid - sigma_grid) / denominator)\n            \n            idx_max = np.argmax(relative_residual)\n            new_knot = dense_grid[idx_max]\n            \n            knots.add(new_knot)\n\n            if len(knots) == last_len:\n                break # Algorithm converged or grid is not dense enough.\n        \n        return np.array(sorted(list(knots)))\n\n    def process_case(case_params):\n        \"\"\"\n        Processes a single case, calculating errors for all three strategies.\n        \"\"\"\n        E_min, E_max, K, sigma_func = case_params\n\n        # 1. Generate the dense evaluation grid.\n        lin_grid = np.linspace(E_min, E_max, N_GRID_POINTS)\n        log_grid = np.logspace(np.log10(E_min), np.log10(E_max), N_GRID_POINTS)\n        dense_grid = np.union1d(lin_grid, log_grid)\n\n        # 2. Generate knots for each strategy.\n        # Strategy 1: Chebyshev-guided.\n        cheby_knots = generate_chebyshev_knots(sigma_func, E_min, E_max, K, dense_grid)\n        \n        # Strategy 2: Uniform in energy (Linear).\n        linear_knots = np.linspace(E_min, E_max, K)\n\n        # Strategy 3: Uniform in log-energy (Logarithmic).\n        log_knots = np.logspace(np.log10(E_min), np.log10(E_max), K)\n        \n        # 3. Calculate max relative error for each knot set.\n        err_cheby = calculate_max_relative_error(sigma_func, cheby_knots, dense_grid)\n        err_linear = calculate_max_relative_error(sigma_func, linear_knots, dense_grid)\n        err_log = calculate_max_relative_error(sigma_func, log_knots, dense_grid)\n        \n        return err_cheby, err_linear, err_log\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.01, 10.0, 12, sigma_A),\n        (1.0, 1000.0, 20, sigma_B),\n        (0.1, 100.0, 5, sigma_C),\n    ]\n\n    # Collect results from all cases.\n    all_results = []\n    for case in test_cases:\n        errors = process_case(case)\n        all_results.extend(errors)\n\n    # Format the final output string.\n    # Each value is formatted to 8 significant digits.\n    formatted_results = [f\"{val:.8g}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3566032"}]}