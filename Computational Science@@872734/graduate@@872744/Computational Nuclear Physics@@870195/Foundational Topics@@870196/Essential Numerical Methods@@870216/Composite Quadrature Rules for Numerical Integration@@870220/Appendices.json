{"hands_on_practices": [{"introduction": "A foundational skill in computational physics is not only implementing a numerical method but also understanding its sources of error. This first practice grounds you in applying a classic composite rule to a physically relevant problem: calculating a neutron reaction rate. You will distinguish between the error introduced by approximating an infinite integral with a finite one (truncation error) and the error inherent in the numerical quadrature method itself (discretization error), a crucial distinction for producing reliable scientific results [@problem_id:3550859].", "problem": "Consider a non-relativistic neutron-induced reaction rate defined as the energy-space expectation of the product of the microscopic cross section, particle speed, and the energy probability density. Let the reaction rate be the scalar quantity $\\lambda$ given by the improper integral\n$$\n\\lambda=\\int_{0}^{\\infty}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE,\n$$\nwhere $E$ is the kinetic energy, $\\sigma(E)$ is the energy-dependent microscopic cross section, $v(E)$ is the speed as a function of energy, and $\\phi_E(E;T)$ is the normalized Maxwell–Boltzmann energy probability density for a gas at absolute temperature $T$. Use the following well-tested physical definitions as the foundational base:\n1. The non-relativistic kinetic energy–speed relation $E=\\tfrac{1}{2}m v^2$ with $m$ the neutron mass, implying $v(E)=\\sqrt{2E/m}$.\n2. The normalized Maxwell–Boltzmann energy distribution in three dimensions (probability density over energy), \n$$\n\\phi_E(E;T)=\\frac{2}{\\sqrt{\\pi}}\\frac{1}{(k_{\\mathrm{B}}T)^{3/2}}\\sqrt{E}\\,e^{-E/(k_{\\mathrm{B}}T)},\n$$\nwhere $k_{\\mathrm{B}}$ is the Boltzmann constant and $T$ is the absolute temperature.\n3. A parametric cross section model that is smooth on $[0,\\infty)$,\n$$\n\\sigma(E)=\\sigma_0+\\sigma_1 E+\\sigma_2 E^2,\n$$\nwith fixed parameters $\\sigma_0$, $\\sigma_1$, and $\\sigma_2$ chosen to be physically plausible and numerically well-conditioned.\n\nIn computational nuclear physics, one often replaces the upper limit $\\infty$ by a finite cutoff $E_{\\max}$ to obtain a truncated integral that can be evaluated numerically by composite quadrature. Your task is to implement the composite Simpson’s rule on $[0,E_{\\max}]$ with an even number of panels $N$ to approximate\n$$\n\\lambda_{\\text{Simpson}}(E_{\\max},N)\\approx\\int_{0}^{E_{\\max}}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE,\n$$\nand to quantify, for each test case, the truncation error and the discretization error separately, defined as\n$$\n\\varepsilon_{\\text{trunc}}=\\left|\\lambda-\\lambda_{\\text{trunc}}(E_{\\max})\\right|,\\quad\n\\varepsilon_{\\text{disc}}=\\left|\\lambda_{\\text{Simpson}}(E_{\\max},N)-\\lambda_{\\text{trunc}}(E_{\\max})\\right|,\n$$\nwhere $\\lambda_{\\text{trunc}}(E_{\\max})=\\int_{0}^{E_{\\max}}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE$ is the truncated integral and $\\lambda=\\int_{0}^{\\infty}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE$ is the true reaction rate. You must compute $\\lambda$ and $\\lambda_{\\text{trunc}}(E_{\\max})$ from first principles, using the given base definitions, without resorting to numerical quadrature for these two quantities. All integrals must be expressed and evaluated in terms of the provided model and physical constants.\n\nUse the following fixed constants in the International System of Units (SI):\n- Neutron mass $m=1.67492749804\\times 10^{-27}\\,\\mathrm{kg}$.\n- Boltzmann constant $k_{\\mathrm{B}}=1.380649\\times 10^{-23}\\,\\mathrm{J/K}$.\n- Cross section parameters $\\sigma_0=1.0\\times 10^{-28}\\,\\mathrm{m^2}$, $\\sigma_1=5.0\\times 10^{-49}\\,\\mathrm{m^2/J}$, $\\sigma_2=2.0\\times 10^{-69}\\,\\mathrm{m^2/J^2}$.\n\nConstruct a test suite covering distinct numerical regimes. For each test case, specify the tuple $(T,\\alpha,N)$, where $T$ is the absolute temperature, $N$ is the even panel count for composite Simpson’s rule, and $E_{\\max}=\\alpha\\,k_{\\mathrm{B}}T$. Use the following test suite:\n- Case $1$: $(T=\\;600\\,\\mathrm{K},\\;\\alpha=\\;5.0,\\;N=\\;100)$.\n- Case $2$: $(T=\\;600\\,\\mathrm{K},\\;\\alpha=\\;1.0,\\;N=\\;100)$.\n- Case $3$: $(T=\\;600\\,\\mathrm{K},\\;\\alpha=\\;5.0,\\;N=\\;2)$.\n- Case $4$: $(T=\\;3000\\,\\mathrm{K},\\;\\alpha=\\;2.0,\\;N=\\;50)$.\n- Case $5$: $(T=\\;300\\,\\mathrm{K},\\;\\alpha=\\;0.1,\\;N=\\;20)$.\n\nYour program must, for each test case, compute and return the quadruple\n$$\n\\left[\\lambda,\\ \\lambda_{\\text{Simpson}}(E_{\\max},N),\\ \\varepsilon_{\\text{trunc}},\\ \\varepsilon_{\\text{disc}}\\right],\n$$\nwith all four quantities expressed in $\\mathrm{m^3/s}$ as real-valued numbers. Angles do not appear in this problem. The final output must aggregate the five test-case results into a single line containing a comma-separated list of these quadruples, enclosed in square brackets, for example\n$$\n\\left[\\,[a_1,b_1,c_1,d_1],\\,[a_2,b_2,c_2,d_2],\\,[a_3,b_3,c_3,d_3],\\,[a_4,b_4,c_4,d_4],\\,[a_5,b_5,c_5,d_5]\\,\\right],\n$$\nand must be printed exactly as a single line. All numerical answers must be in $\\mathrm{m^3/s}$.", "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of non-relativistic statistical mechanics and nuclear reaction theory, mathematically well-posed, objective, and self-contained. All provided physical models, constants, and definitions are standard and consistent. The task is a well-defined exercise in computational physics, requiring both analytical derivation and numerical implementation.\n\nThe primary objective is to compute the neutron-induced reaction rate $\\lambda$, which is defined by the integral:\n$$\n\\lambda=\\int_{0}^{\\infty}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE\n$$\nWe will also compute its truncated and numerical approximations, and the associated errors.\n\nFirst, let's assemble the integrand, $f(E) = \\sigma(E)\\,v(E)\\,\\phi_E(E;T)$, by substituting the given expressions:\n1. Cross section: $\\sigma(E)=\\sigma_0+\\sigma_1 E+\\sigma_2 E^2$\n2. Speed: $v(E)=\\sqrt{2E/m}$\n3. Maxwell-Boltzmann energy density: $\\phi_E(E;T)=\\frac{2}{\\sqrt{\\pi}(k_{\\mathrm{B}}T)^{3/2}}\\sqrt{E}\\,e^{-E/(k_{\\mathrm{B}}T)}$\n\nCombining these terms, the integrand $f(E)$ becomes:\n$$\nf(E) = (\\sigma_0+\\sigma_1 E+\\sigma_2 E^2) \\left(\\sqrt{\\frac{2E}{m}}\\right) \\left(\\frac{2}{\\sqrt{\\pi}(k_{\\mathrm{B}}T)^{3/2}}\\sqrt{E}\\,e^{-E/(k_{\\mathrm{B}}T)}\\right)\n$$\nSimplifying this expression by combining the $\\sqrt{E}$ terms:\n$$\nf(E) = \\frac{2\\sqrt{2}}{\\sqrt{m\\pi}(k_{\\mathrm{B}}T)^{3/2}} (\\sigma_0+\\sigma_1 E+\\sigma_2 E^2) E e^{-E/(k_{\\mathrm{B}}T)}\n$$\nLet's define a constant prefactor $C_T = \\frac{2\\sqrt{2/m}}{\\sqrt{\\pi}(k_{\\mathrm{B}}T)^{3/2}}$. The integrand can then be written as:\n$$\nf(E) = C_T (\\sigma_0 E + \\sigma_1 E^2 + \\sigma_2 E^3) e^{-E/(k_{\\mathrm{B}}T)}\n$$\n\n**1. Analytical Calculation of the True Reaction Rate, $\\lambda$**\n\nTo find the true reaction rate $\\lambda$, we must integrate $f(E)$ from $0$ to $\\infty$.\n$$\n\\lambda = \\int_0^\\infty f(E) dE = C_T \\int_0^\\infty (\\sigma_0 E + \\sigma_1 E^2 + \\sigma_2 E^3) e^{-E/(k_{\\mathrm{B}}T)} dE\n$$\nThis requires solving integrals of the form $\\int_0^\\infty E^n e^{-aE} dE$, where $a=1/(k_{\\mathrm{B}}T)$. This is a standard integral related to the Gamma function, $\\Gamma(z) = \\int_0^\\infty t^{z-1} e^{-t} dt$. Using the substitution $t=aE$, we find:\n$$\n\\int_0^\\infty E^n e^{-aE} dE = \\frac{1}{a^{n+1}} \\int_0^\\infty t^n e^{-t} dt = \\frac{\\Gamma(n+1)}{a^{n+1}} = \\frac{n!}{a^{n+1}}\n$$\nApplying this result to each term of our integral with $a=1/(k_{\\mathrm{B}}T)$:\n- $\\int_0^\\infty E^1 e^{-E/(k_{\\mathrm{B}}T)} dE = \\frac{1!}{(1/k_{\\mathrm{B}}T)^2} = (k_{\\mathrm{B}}T)^2$\n- $\\int_0^\\infty E^2 e^{-E/(k_{\\mathrm{B}}T)} dE = \\frac{2!}{(1/k_{\\mathrm{B}}T)^3} = 2(k_{\\mathrm{B}}T)^3$\n- $\\int_0^\\infty E^3 e^{-E/(k_{\\mathrm{B}}T)} dE = \\frac{3!}{(1/k_{\\mathrm{B}}T)^4} = 6(k_{\\mathrm{B}}T)^4$\n\nSubstituting these back into the expression for $\\lambda$:\n$$\n\\lambda = C_T \\left[ \\sigma_0(k_{\\mathrm{B}}T)^2 + \\sigma_1(2(k_{\\mathrm{B}}T)^3) + \\sigma_2(6(k_{\\mathrm{B}}T)^4) \\right]\n$$\n$$\n\\lambda = \\frac{2\\sqrt{2/m}}{\\sqrt{\\pi}(k_{\\mathrm{B}}T)^{3/2}} (k_{\\mathrm{B}}T)^2 \\left[ \\sigma_0 + 2\\sigma_1(k_{\\mathrm{B}}T) + 6\\sigma_2(k_{\\mathrm{B}}T)^2 \\right]\n$$\n$$\n\\lambda = \\frac{2\\sqrt{2k_{\\mathrm{B}}T/m}}{\\sqrt{\\pi}} \\left[ \\sigma_0 + 2\\sigma_1(k_{\\mathrm{B}}T) + 6\\sigma_2(k_{\\mathrm{B}}T)^2 \\right]\n$$\nThis is the analytical formula for the true reaction rate $\\lambda$.\n\n**2. Analytical Calculation of the Truncated Reaction Rate, $\\lambda_{\\text{trunc}}(E_{\\max})$**\n\nThe truncated rate $\\lambda_{\\text{trunc}}$ is the integral of $f(E)$ from $0$ to a finite cutoff $E_{\\max} = \\alpha k_{\\mathrm{B}}T$. The ratio of the truncated integral $\\int_0^{E_{\\max}} E^n e^{-aE} dE$ to the full integral $\\int_0^{\\infty} E^n e^{-aE} dE$ is given by the regularized lower incomplete gamma function, $P(n+1, \\alpha) = \\gamma(n+1, \\alpha) / \\Gamma(n+1)$, where $a=1/(k_{\\mathrm{B}}T)$ and $\\alpha=aE_{max}$. Since the total reaction rate $\\lambda$ is a linear combination of the full integrals for $n=1, 2, 3$ (corresponding to integrand terms with $E, E^2, E^3$), the truncated rate $\\lambda_{\\text{trunc}}$ is found by multiplying each term in the expression for $\\lambda$ by the corresponding regularization factor:\n$$\n\\lambda_{\\text{trunc}} = \\frac{2\\sqrt{2k_{\\mathrm{B}}T/m}}{\\sqrt{\\pi}} \\left[ \\sigma_0 P(2, \\alpha) + 2\\sigma_1(k_{\\mathrm{B}}T) P(3, \\alpha) + 6\\sigma_2(k_{\\mathrm{B}}T)^2 P(4, \\alpha) \\right]\n$$\nThe functions $P(s,x)$ (often denoted `gammainc` in software libraries) can be used for computation.\n\n**3. Numerical Calculation via Composite Simpson's Rule, $\\lambda_{\\text{Simpson}}(E_{\\max},N)$**\n\nThe composite Simpson's rule approximates the definite integral $\\int_a^b g(x) dx$ over an even number of panels $N$. The interval $[a, b]$ is divided into $N$ subintervals of width $h=(b-a)/N$. The formula is:\n$$\n\\int_a^b g(x) dx \\approx \\frac{h}{3} \\left[ g(x_0) + 4\\sum_{i=1, i\\text{ odd}}^{N-1} g(x_i) + 2\\sum_{i=2, i\\text{ even}}^{N-2} g(x_i) + g(x_N) \\right]\n$$\nwhere $x_i = a+ih$. In our case, the integral is for $\\lambda_{\\text{trunc}}(E_{\\max}, N)$, so $g(E) = f(E)$, $a=0$, and $b=E_{\\max}$. The step size is $h=E_{\\max}/N$.\nThe implementation will evaluate the integrand $f(E)$ at the $N+1$ grid points $E_i = i h$ for $i=0, \\dots, N$, and apply the weighted sum as per the formula above. Note that $f(0)=0$.\n\n**4. Error Quantification**\n\nThe two sources of error are defined as:\n- Truncation error: $\\varepsilon_{\\text{trunc}} = \\left|\\lambda-\\lambda_{\\text{trunc}}(E_{\\max})\\right|$. This error arises from replacing the infinite integration limit with a finite cutoff $E_{\\max}$.\n- Discretization error: $\\varepsilon_{\\text{disc}} = \\left|\\lambda_{\\text{Simpson}}(E_{\\max},N)-\\lambda_{\\text{trunc}}(E_{\\max})\\right|$. This error arises from approximating the definite integral over $[0, E_{\\max}]$ with a numerical quadrature rule.\n\nThese quantities will be computed for each test case using the derived analytical formulas and the numerical implementation of Simpson's rule.", "answer": "```python\nimport numpy as np\nfrom scipy.special import gamma, gammainc\n\ndef solve():\n    \"\"\"\n    Computes neutron-induced reaction rates and associated errors for\n    a set of test cases using analytical and numerical methods.\n    \"\"\"\n    \n    # Fixed constants in SI units\n    M_N = 1.67492749804e-27  # Neutron mass (kg)\n    K_B = 1.380649e-23         # Boltzmann constant (J/K)\n    SIGMA_0 = 1.0e-28          # Cross section parameter (m^2)\n    SIGMA_1 = 5.0e-49          # Cross section parameter (m^2/J)\n    SIGMA_2 = 2.0e-69          # Cross section parameter (m^2/J^2)\n\n    # Test suite: (T in Kelvin, alpha, N panels)\n    test_cases = [\n        (600.0, 5.0, 100),\n        (600.0, 1.0, 100),\n        (600.0, 5.0, 2),\n        (3000.0, 2.0, 50),\n        (300.0, 0.1, 20),\n    ]\n\n    all_results = []\n\n    for T, alpha, N in test_cases:\n        # Characteristic energy\n        kT = K_B * T\n        \n        # --- Analytical Calculation of the True Reaction Rate (lambda) ---\n        # lambda = (2 * sqrt(2*kT/m) / sqrt(pi)) * [s0 + 2*s1*kT + 6*s2*kT^2]\n        \n        common_factor = (2.0 * np.sqrt(2.0 * kT / M_N)) / np.sqrt(np.pi)\n        poly_full = SIGMA_0 + 2.0 * SIGMA_1 * kT + 6.0 * SIGMA_2 * kT**2\n        lambda_true = common_factor * poly_full\n\n        # --- Analytical Calculation of the Truncated Rate (lambda_trunc) ---\n        # The truncated rate is found by multiplying each term of the full rate\n        # by the corresponding regularized lower incomplete gamma function P(n+1, alpha).\n        # P(s, x) is implemented as scipy.special.gammainc(s, x).\n        # Terms correspond to integrals of E^1, E^2, E^3 -> n=1, 2, 3 -> s=2, 3, 4.\n        \n        lambda_trunc = common_factor * (\n            SIGMA_0 * gammainc(2, alpha) +\n            2 * SIGMA_1 * kT * gammainc(3, alpha) +\n            6 * SIGMA_2 * kT**2 * gammainc(4, alpha)\n        )\n        \n        # --- Numerical Calculation using Composite Simpson's Rule (lambda_simpson) ---\n        E_max = alpha * kT\n\n        # Define the integrand f(E) = sigma(E) * v(E) * phi_E(E)\n        # Simplified form: f(E) = C_T * (s0*E + s1*E^2 + s2*E^3) * exp(-E/kT)\n        c_T = (2.0 * np.sqrt(2.0 / M_N)) / (np.sqrt(np.pi) * kT**1.5)\n        \n        def integrand(E_vals):\n            # Vectorized integrand evaluation\n            # Handle E=0 case to avoid 0*inf from 1/sqrt(E) if original form used.\n            # The simplified form with E as factor is 0 at E=0.\n            if isinstance(E_vals, (int, float)):\n                if E_vals == 0: return 0.0\n            \n            poly_E = SIGMA_0 * E_vals + SIGMA_1 * E_vals**2 + SIGMA_2 * E_vals**3\n            return c_T * poly_E * np.exp(-E_vals / kT)\n\n        E_points = np.linspace(0, E_max, N + 1)\n        y_points = integrand(E_points)\n        \n        h = E_max / N\n        lambda_simpson = (h / 3.0) * (\n            y_points[0] + \n            4.0 * np.sum(y_points[1:-1:2]) + \n            2.0 * np.sum(y_points[2:-1:2]) + \n            y_points[-1]\n        )\n\n        # --- Error Calculation ---\n        eps_trunc = np.abs(lambda_true - lambda_trunc)\n        eps_disc = np.abs(lambda_simpson - lambda_trunc)\n\n        all_results.append([lambda_true, lambda_simpson, eps_trunc, eps_disc])\n    \n    # Format the final output string exactly as specified.\n    # e.g., [[a1,b1,c1,d1],[a2,b2,c2,d2],...]\n    formatted_quads = [f\"[{','.join(map(str, quad))}]\" for quad in all_results]\n    final_output_string = f\"[{','.join(formatted_quads)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3550859"}, {"introduction": "Standard composite rules with fixed step sizes are often inefficient when the integrand features sharp, localized structures, such as the Breit-Wigner resonances common in nuclear cross sections. This exercise challenges you to build a more sophisticated tool: an adaptive quadrature algorithm that automatically concentrates computational effort in regions where the function changes rapidly. By implementing an adaptive Gauss-Legendre scheme, you will develop a robust and efficient integrator capable of handling the complex, multi-scale nature of realistic physics problems [@problem_id:3550919].", "problem": "Design and implement an adaptive composite Gaussian–Legendre quadrature to evaluate the energy-weighted reaction rate integral in a one-dimensional energy variable in computational nuclear physics. The integral to be computed is\n$$\nI \\;=\\; \\int_{E_\\min}^{E_\\max} \\sigma(E)\\,\\phi(E)\\,dE,\n$$\nwhere $\\sigma(E)$ is a cross section with multiple resonant structures and $\\phi(E)$ is an energy distribution representing a neutron flux density. The goal is to construct a composite rule that automatically clusters panels around narrow resonances and controls the local truncation error through adaptive subdivision.\n\nUse the following physically motivated and widely accepted forms:\n\n- Cross section with multiple Breit–Wigner (Lorentzian) resonances,\n$$\n\\sigma(E) \\;=\\; \\sum_{i=1}^{N_r} A_i \\,\\frac{\\left(\\frac{\\Gamma_i}{2}\\right)^2}{(E - E_i)^2 + \\left(\\frac{\\Gamma_i}{2}\\right)^2},\n$$\nwhere $E$ is energy, $E_i$ is the resonance centroid, $\\Gamma_i$ is the full width at half maximum, and $A_i$ is the amplitude. $\\sigma(E)$ is expressed in barns.\n\n- Neutron flux density chosen as a normalized Maxwell–Boltzmann-like distribution on the finite interval,\n$$\n\\phi(E) \\;=\\; C \\, E^{1/2} \\, \\exp\\!\\left(-\\frac{E}{kT}\\right),\n$$\nwith $kT$ a thermal energy scale in electron-volts, and $C$ a normalization constant such that\n$$\n\\int_{E_\\min}^{E_\\max} \\phi(E)\\, dE \\;=\\; 1.\n$$\nWith this normalization, $\\phi(E)$ has units of inverse electron-volt, and the integral $I$ is in barns. You must treat $C$ exactly via the known normalization integral\n$$\n\\int_{E_\\min}^{E_\\max} E^{1/2}\\, e^{-E/(kT)}\\, dE \\;=\\; (kT)^{3/2}\\,\\Big[\\gamma\\!\\left(\\tfrac{3}{2},\\tfrac{E_\\max}{kT}\\right) - \\gamma\\!\\left(\\tfrac{3}{2},\\tfrac{E_\\min}{kT}\\right)\\Big],\n$$\nwhere $\\gamma(\\cdot,\\cdot)$ is the lower incomplete gamma function. Thus,\n$$\nC \\;=\\; \\left[(kT)^{3/2}\\,\\Big(\\gamma\\!\\left(\\tfrac{3}{2},\\tfrac{E_\\max}{kT}\\right) - \\gamma\\!\\left(\\tfrac{3}{2},\\tfrac{E_\\min}{kT}\\right)\\Big)\\right]^{-1}.\n$$\n\nFundamental base to use for your derivation and algorithm design:\n\n- The Riemann integral definition and the fact that smooth integrands can be approximated by polynomial interpolation over panels.\n- Orthogonality of Legendre polynomials on $[-1,1]$ and the Gaussian–Legendre quadrature property that integrates polynomials of degree up to $2n-1$ exactly with $n$ nodes.\n- Error reduction by panel halving for sufficiently smooth functions, enabling a local error estimate from the difference between one panel integral and the sum of two child-panel integrals.\n- The incomplete gamma function normalization to ensure physically consistent units.\n\nYour program must implement:\n\n- A composite Gaussian–Legendre quadrature of order $n$, with $n$ fixed to $n=8$ nodes per panel.\n- An adaptive refinement strategy based on comparing a single $n$-node panel estimate over $[a,b]$ with the sum of two $n$-node panel estimates over $[a,m]$ and $[m,b]$, where $m=(a+b)/2$, to obtain a local error estimator. Use a refinement criterion that accepts a panel if the estimated local error $\\varepsilon_\\text{loc}$ satisfies $\\varepsilon_\\text{loc} \\le \\max(\\tau_\\text{abs}, \\tau_\\text{rel}\\,|I_\\text{panel}|)$ with absolute tolerance $\\tau_\\text{abs}$ and relative tolerance $\\tau_\\text{rel}$ both set to $\\tau_\\text{abs}=\\tau_\\text{rel}=10^{-8}$.\n- Automatic panel clustering around narrow resonances by seeding the initial partition with breakpoints at $E_i \\pm m\\,(\\Gamma_i/2)$ for $m \\in \\{-3,-2,-1,0,1,2,3\\}$ that lie within $[E_\\min,E_\\max]$, merged and sorted along with the endpoints. Subsequent adaptive refinement proceeds on these seed panels.\n\nAngles do not appear; no trigonometric functions with angle units are used. All energies are in electron-volts. The final numerical results must be reported in barns.\n\nTest suite. Your program must evaluate the integral $I$ for the following four cases, each specified by $\\{E_\\min,E_\\max,kT; (E_i,\\Gamma_i,A_i)_{i=1}^{N_r}\\}$:\n\n- Case $1$ (single broad resonance):\n  - Interval $[E_\\min,E_\\max] = [\\,0.0,\\,10.0\\,]$ eV, $kT=1.0$ eV.\n  - Resonances: $N_r=1$ with $(E_1,\\Gamma_1,A_1)=(\\,3.0,\\,1.0,\\,10.0\\,)$.\n\n- Case $2$ (multiple peaks, including a very narrow one):\n  - Interval $[E_\\min,E_\\max] = [\\,0.0,\\,20.0\\,]$ eV, $kT=2.0$ eV.\n  - Resonances: $N_r=3$ with $(E_1,\\Gamma_1,A_1)=(\\,5.0,\\,0.2,\\,80.0\\,)$, $(E_2,\\Gamma_2,A_2)=(\\,12.0,\\,1.5,\\,30.0\\,)$, $(E_3,\\Gamma_3,A_3)=(\\,8.0,\\,0.05,\\,150.0\\,)$.\n\n- Case $3$ (narrow resonances near boundaries):\n  - Interval $[E_\\min,E_\\max] = [\\,0.0,\\,5.0\\,]$ eV, $kT=0.5$ eV.\n  - Resonances: $N_r=2$ with $(E_1,\\Gamma_1,A_1)=(\\,0.1,\\,0.01,\\,200.0\\,)$, $(E_2,\\Gamma_2,A_2)=(\\,4.5,\\,0.02,\\,100.0\\,)$.\n\n- Case $4$ (overlapping resonances):\n  - Interval $[E_\\min,E_\\max] = [\\,5.0,\\,15.0\\,]$ eV, $kT=1.5$ eV.\n  - Resonances: $N_r=3$ with $(E_1,\\Gamma_1,A_1)=(\\,9.5,\\,0.4,\\,70.0\\,)$, $(E_2,\\Gamma_2,A_2)=(\\,10.0,\\,0.5,\\,65.0\\,)$, $(E_3,\\Gamma_3,A_3)=(\\,10.3,\\,0.3,\\,80.0\\,)$.\n\nFinal output format. Your program should produce a single line of output containing the four integral estimates as a comma-separated list enclosed in square brackets, in the order of cases $1$ through $4$, for example\n$[\\;I_1,I_2,I_3,I_4\\;]$,\nwith each $I_j$ a floating-point number in barns. Do not print units or any additional text; only the list literal. The numerical answers should be in barns as implied by the units of $\\sigma(E)$ and the normalization of $\\phi(E)$.", "solution": "The problem requires the design and implementation of an adaptive composite Gaussian-Legendre quadrature scheme to compute the energy-weighted reaction rate integral, $I = \\int_{E_\\min}^{E_\\max} \\sigma(E)\\,\\phi(E)\\,dE$. This is a task in computational physics that combines physical modeling with numerical analysis. The solution approach involves defining the integrand precisely, constructing a robust numerical integration algorithm, and implementing it according to the specified test cases.\n\n### 1. The Integrand: Reaction Rate Kernel\n\nThe integrand is the product of two functions, the cross section $\\sigma(E)$ and the neutron flux density $\\phi(E)$.\n\n**Cross Section $\\sigma(E)$:** The cross section is modeled as a sum of $N_r$ Breit-Wigner resonances. Each resonance is a Lorentzian peak centered at energy $E_i$ with a full width at half maximum (FWHM) of $\\Gamma_i$ and an amplitude $A_i$. The formula is given by:\n$$\n\\sigma(E) = \\sum_{i=1}^{N_r} A_i \\,\\frac{\\left(\\frac{\\Gamma_i}{2}\\right)^2}{(E - E_i)^2 + \\left(\\frac{\\Gamma_i}{2}\\right)^2}\n$$\nThis function has units of barns. The presence of narrow resonances (small $\\Gamma_i$) creates sharp peaks where the function varies rapidly, posing a challenge for numerical integration.\n\n**Neutron Flux Density $\\phi(E)$:** The flux is described by a Maxwell-Boltzmann-like distribution truncated to the finite energy interval $[E_\\min, E_\\max]$. Its functional form is:\n$$\n\\phi(E) = C \\, E^{1/2} \\, \\exp\\!\\left(-\\frac{E}{kT}\\right)\n$$\nwhere $k$ is the Boltzmann constant and $T$ is the temperature, with $kT$ representing a thermal energy scale. The constant $C$ is determined by the normalization condition $\\int_{E_\\min}^{E_\\max} \\phi(E)\\, dE = 1$. This ensures that $\\phi(E)$ is a probability density function over the specified energy range, with units of inverse energy (e.g., $\\text{eV}^{-1}$). The integral $I$ thus correctly has units of barns.\n\nTo find $C$, we must evaluate the normalization integral:\n$$\n\\int_{E_\\min}^{E_\\max} E^{1/2}\\, e^{-E/(kT)}\\, dE\n$$\nUsing the substitution $u = E/(kT)$, we have $E = u(kT)$ and $dE = (kT)du$. The integral transforms to:\n$$\n\\int_{E_{\\min}/(kT)}^{E_{\\max}/(kT)} (u kT)^{1/2}\\, e^{-u}\\, (kT)du = (kT)^{3/2} \\int_{E_{\\min}/(kT)}^{E_{\\max}/(kT)} u^{1/2}\\, e^{-u}\\, du\n$$\nThe definite integral can be expressed using the lower incomplete gamma function, $\\gamma(s,x) = \\int_0^x t^{s-1} e^{-t} dt$. With $s = 3/2$, the integral becomes:\n$$\n(kT)^{3/2} \\left[ \\gamma\\!\\left(\\frac{3}{2}, \\frac{E_\\max}{kT}\\right) - \\gamma\\!\\left(\\frac{3}{2}, \\frac{E_\\min}{kT}\\right) \\right]\n$$\nThe normalization constant $C$ is the reciprocal of this value:\n$$\nC = \\left[ (kT)^{3/2} \\left( \\gamma\\!\\left(\\frac{3}{2}, \\frac{E_\\max}{kT}\\right) - \\gamma\\!\\left(\\frac{3}{2}, \\frac{E_\\min}{kT}\\right) \\right) \\right]^{-1}\n$$\n\n### 2. Numerical Integration Method\n\nA standard fixed-panel quadrature rule would be inefficient for an integrand with sharp, localized features. An adaptive quadrature method is required, which automatically refines the integration grid in regions of high functional variation.\n\n**Gaussian-Legendre Quadrature:** The fundamental building block is an $n$-point Gaussian-Legendre quadrature rule. For $n=8$ as specified, this rule approximates the integral of a function $g(x)$ over the canonical interval $[-1, 1]$ as a weighted sum:\n$$\n\\int_{-1}^{1} g(x)\\,dx \\approx \\sum_{i=1}^{n} w_i g(x_i)\n$$\nwhere $x_i$ are the roots of the $n$-th degree Legendre polynomial $P_n(x)$ and $w_i$ are the corresponding weights. This rule is exact for polynomials of degree up to $2n-1 = 15$. To apply this to an arbitrary interval $[a, b]$, we use the linear transformation $E(x) = \\frac{b-a}{2}x + \\frac{a+b}{2}$:\n$$\n\\int_{a}^{b} f(E)\\,dE = \\frac{b-a}{2} \\int_{-1}^{1} f(E(x))\\,dx \\approx \\frac{b-a}{2} \\sum_{i=1}^{n} w_i f\\left(\\frac{b-a}{2}x_i + \\frac{a+b}{2}\\right)\n$$\n\n**Adaptive Subdivision and Error Estimation:** The core of the adaptive algorithm lies in error estimation and panel subdivision. For a given panel $[a, b]$, we compute two approximations for the integral:\n$1$. $I_1$: The integral estimated using a single $n$-point rule over $[a, b]$.\n$2$. $I_2$: A more accurate estimate obtained by bisecting the panel at $m=(a+b)/2$ and summing the results of applying the $n$-point rule to each sub-panel, $[a,m]$ and $[m,b]$.\n\nThe local error of the coarser estimate $I_1$ is estimated as $\\varepsilon_\\text{loc} = |I_2 - I_1|$. If this error satisfies a specified tolerance criterion, the panel is accepted and its contribution (the more accurate value, $I_2$) is added to the total integral. The criterion is:\n$$\n\\varepsilon_\\text{loc} \\le \\max(\\tau_\\text{abs}, \\tau_\\text{rel}\\,|I_2|)\n$$\nwhere $\\tau_\\text{abs} = 10^{-8}$ and $\\tau_\\text{rel} = 10^{-8}$ are the absolute and relative tolerances. If the criterion is not met, the panel $[a,b]$ is rejected and the two sub-panels, $[a,m]$ and $[m,b]$, are added to a list of panels to be processed.\n\n**Initial Panel Seeding:** To improve efficiency, the algorithm is seeded with an initial set of panels that are already concentrated around the challenging parts of the integrand—the narrow resonances. For each resonance $(E_i, \\Gamma_i, A_i)$, we generate a set of breakpoints $E_i \\pm m(\\Gamma_i/2)$ for $m \\in \\{-3, -2, -1, 0, 1, 2, 3\\}$. These points, along with the interval endpoints $E_\\min$ and $E_\\max$, are collected, restricted to be within $(E_\\min, E_\\max)$, made unique, and sorted. This creates an initial partition of $[E_\\min, E_\\max]$ into panels that are fine near resonances and coarse elsewhere. The adaptive algorithm then proceeds on each of these initial panels.\n\n### 3. Algorithmic Implementation\n\nThe overall algorithm is implemented as follows:\n$1$. For each test case, retrieve the parameters $\\{E_\\min, E_\\max, kT\\}$ and the list of resonances.\n$2$. Calculate the normalization constant $C$ for the flux $\\phi(E)$ using the formula involving the lower incomplete gamma function, provided by a scientific library like `SciPy`.\n$3$. Construct the integrand function $f(E) = \\sigma(E)\\,\\phi(E)$.\n$4$. Generate the initial sorted list of breakpoints based on the resonance locations and widths. This defines the initial set of panels.\n$5$. Initialize the total integral to $0$.\n$6$. Use a stack (LIFO data structure) to manage the panels for the adaptive quadrature. Initially, push all panels from the seeded partition onto the stack.\n$7$. While the stack is not empty:\n    a. Pop a panel $[a, b]$ from the stack.\n    b. Compute the one-panel integral $I_1$ and the two-panel integral $I_2$.\n    c. Calculate the error estimate $\\varepsilon_\\text{loc} = |I_2 - I_1|$ and the tolerance $T = \\max(\\tau_\\text{abs}, \\tau_\\text{rel}\\,|I_2|)$.\n    d. If $\\varepsilon_\\text{loc} \\le T$, add $I_2$ to the total integral.\n    e. Otherwise, push the two sub-panels $[a, (a+b)/2]$ and $[(a+b)/2, b]$ onto the stack.\n$8$. The final value of the total integral is the result for the test case. This procedure is repeated for all four cases. The implementation uses `NumPy` for efficient vectorized calculations and `SciPy` for the special function $\\gamma(s,x)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma, gammainc\n\n# Global constants from the problem\nN_NODES = 8\nTOL_ABS = 1e-8\nTOL_REL = 1e-8\nINITIAL_BREAKPOINT_M = [-3, -2, -1, 0, 1, 2, 3]\n\n# Pre-compute Gauss-Legendre nodes and weights for the base rule\nLG_NODES, LG_WEIGHTS = np.polynomial.legendre.leggauss(N_NODES)\n\ndef _sigma(E, resonances):\n    \"\"\"\n    Computes the Breit-Wigner cross section.\n    E can be a scalar or a numpy array for vectorized computation.\n    \"\"\"\n    total_sigma = np.zeros_like(E, dtype=float)\n    for E_i, Gamma_i, A_i in resonances:\n        gamma_half_sq = (Gamma_i / 2.0)**2\n        total_sigma += A_i * gamma_half_sq / ((E - E_i)**2 + gamma_half_sq)\n    return total_sigma\n\ndef _phi(E, C, kT):\n    \"\"\"\n    Computes the normalized Maxwell-Boltzmann-like flux density.\n    E can be a scalar or a numpy array.\n    \"\"\"\n    E = np.asanyarray(E)\n    phi_val = np.zeros_like(E, dtype=float)\n    # The condition E > 0 prevents incorrect values or warnings for sqrt(0) or log(0)\n    # in more complex models, and correctly evaluates phi(0) = 0.\n    mask = E > 0\n    phi_val[mask] = C * np.sqrt(E[mask]) * np.exp(-E[mask] / kT)\n    return phi_val\n\ndef _integrate_panel(f, a, b):\n    \"\"\"\n    Computes the integral of a function f over a single panel [a, b]\n    using the pre-computed n-point Gaussian-Legendre rule.\n    \"\"\"\n    h = (b - a) / 2.0\n    c = (a + b) / 2.0\n    eval_points = c + h * LG_NODES\n    f_values = f(eval_points)\n    integral = h * np.sum(LG_WEIGHTS * f_values)\n    return integral\n\ndef compute_rate_integral(params):\n    \"\"\"\n    Computes the reaction rate integral for a given set of physical parameters.\n    \"\"\"\n    E_min, E_max, kT = params['E_min'], params['E_max'], params['kT']\n    resonances = params['resonances']\n\n    # 1. Calculate normalization constant C for phi(E)\n    s = 1.5\n    # The lower incomplete gamma function is needed: gamma(s,x)\n    # scipy.special.gammainc(s, x) computes the regularized version P(s,x).\n    # gamma(s,x) = P(s,x) * Gamma(s).\n    gamma_s = gamma(s)\n    \n    # an argument to gammainc cannot be 0 if s is not integer; however scipy handles it.\n    if kT <= 0: return 0.0\n    x_max = E_max / kT\n    x_min = E_min / kT\n    \n    if E_min >= E_max: return 0.0\n\n    term_max = gammainc(s, x_max) * gamma_s if x_max > 0 else 0.0\n    term_min = gammainc(s, x_min) * gamma_s if x_min > 0 else 0.0\n    \n    norm_integral_part = term_max - term_min\n    norm_integral = (kT**1.5) * norm_integral_part\n    \n    C = 1.0 / norm_integral if norm_integral > 1e-100 else 0.0\n\n    # 2. Define the full integrand f(E)\n    def integrand(E):\n        return _sigma(E, resonances) * _phi(E, C, kT)\n\n    # 3. Generate initial breakpoints\n    breakpoints = {E_min, E_max}\n    for E_i, Gamma_i, _ in resonances:\n        for m in INITIAL_BREAKPOINT_M:\n            pt = E_i + m * (Gamma_i / 2.0)\n            if E_min < pt < E_max:\n                breakpoints.add(pt)\n    \n    sorted_breakpoints = sorted(list(breakpoints))\n\n    # 4. Perform adaptive quadrature using a stack (LIFO)\n    panel_stack = [(sorted_breakpoints[i], sorted_breakpoints[i+1]) for i in range(len(sorted_breakpoints)-1)]\n    \n    total_integral = 0.0\n    \n    max_panels_processed = 1_000_000 # Safety break\n    panel_count = 0\n\n    while panel_stack:\n        if panel_count > max_panels_processed:\n            raise RuntimeError(\"Exceeded maximum number of panel subdivisions. Tolerance may be too strict.\")\n\n        a, b = panel_stack.pop()\n        m = (a + b) / 2.0\n        \n        # Integral over one coarse panel\n        I1 = _integrate_panel(integrand, a, b)\n        \n        # Integral over two finer sub-panels\n        I_left = _integrate_panel(integrand, a, m)\n        I_right = _integrate_panel(integrand, m, b)\n        I2 = I_left + I_right\n        \n        error_est = abs(I2 - I1)\n        # Use the more accurate integral I2 for the relative tolerance check\n        tolerance = max(TOL_ABS, TOL_REL * abs(I2))\n\n        if error_est <= tolerance:\n            # Panel is accepted. Add its contribution (the more accurate I2).\n            total_integral += I2\n            panel_count += 1\n        else:\n            # Panel is rejected. Push sub-panels onto stack for further refinement.\n            # Push right panel first, then left, so left sub-panel is processed first.\n            panel_stack.append((m, b))\n            panel_stack.append((a, m))\n\n    return total_integral\n\ndef solve():\n    \"\"\"\n    Main orchestrator function that defines test cases and prints results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'E_min': 0.0, 'E_max': 10.0, 'kT': 1.0, \n         'resonances': [(3.0, 1.0, 10.0)]},\n        # Case 2\n        {'E_min': 0.0, 'E_max': 20.0, 'kT': 2.0, \n         'resonances': [(5.0, 0.2, 80.0), (12.0, 1.5, 30.0), (8.0, 0.05, 150.0)]},\n        # Case 3\n        {'E_min': 0.0, 'E_max': 5.0, 'kT': 0.5, \n         'resonances': [(0.1, 0.01, 200.0), (4.5, 0.02, 100.0)]},\n        # Case 4\n        {'E_min': 5.0, 'E_max': 15.0, 'kT': 1.5, \n         'resonances': [(9.5, 0.4, 70.0), (10.0, 0.5, 65.0), (10.3, 0.3, 80.0)]}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_rate_integral(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3550919"}, {"introduction": "Beyond sharp peaks, another common challenge in physical integrals is the presence of integrable singularities, often occurring at reaction thresholds. While adaptive quadrature can handle these, an elegant and powerful alternative is to transform the problem itself. This practice guides you through the analytical technique of using a \"graded mesh,\" a specific change of variables that regularizes the integrand. You will determine the exact transformation required to restore the optimal convergence rate of a simple quadrature rule, demonstrating how analytical insight can dramatically improve numerical performance [@problem_id:3550921].", "problem": "In computational nuclear physics, reaction rate integrals often involve energy-dependent nuclear cross sections that exhibit algebraic endpoint singularities near threshold. Consider a deterministic evaluation of the thermal neutron absorption rate\n$$\nI \\;=\\; \\int_{a}^{b} \\sigma(x)\\,\\phi(x)\\,dx,\n$$\nwhere $x$ denotes kinetic energy, $a$ is a threshold energy ($a \\geq 0$), $b > a$ is a finite upper bound, $\\phi(x)$ is a smooth and bounded neutron flux, and the cross section behaves near the threshold as\n$$\n\\sigma(x) \\;\\sim\\; C\\,(x-a)^{-\\alpha} \\quad \\text{as } x \\to a^{+},\n$$\nfor some constant $C>0$ and $0<\\alpha<1$. This endpoint singularity is integrable but degrades the performance of uniform-step quadrature rules. To address this, adopt a graded mesh defined by the mapping\n$$\nx(t) \\;=\\; a + (b-a)\\,t^{p}, \\qquad t \\in [0,1], \\qquad p>0,\n$$\nand apply the composite trapezoidal rule with $N$ equal subintervals in the variable $t$ over $[0,1]$ to approximate $I$.\n\nStarting from the change-of-variables formula for integrals and the Taylor expansion remainder for the trapezoidal rule on a single panel, justify the use of the graded mesh by analyzing the transformed integrand’s regularity near $t=0$ and the resulting global error accumulation over $N$ panels. Then determine the explicit choice of the grading exponent $p$ (as a function of $\\alpha$) that recovers the nominal second-order global convergence rate of the composite trapezoidal rule, that is, an error behaving like $\\mathcal{O}(N^{-2})$ as $N \\to \\infty$.\n\nExpress your final answer for $p$ as a single closed-form analytic expression. No numerical rounding is required.", "solution": "The integral with an endpoint singularity can be transformed by the graded mapping $x(t) = a + (b-a)\\,t^{p}$, with $t \\in [0,1]$ and $p>0$. By the change-of-variables formula,\n$$\nI \\;=\\; \\int_{0}^{1} f(x(t))\\,x'(t)\\,dt,\n$$\nwhere $f(x) = \\sigma(x)\\,\\phi(x)$ and\n$$\nx'(t) \\;=\\; p\\,(b-a)\\,t^{p-1}.\n$$\nNear $x=a$, we have $f(x) \\sim C\\,(x-a)^{-\\alpha}\\,\\phi(x)$, and since $\\phi(x)$ is smooth and bounded, its behavior near $x=a$ does not introduce additional singularities. Using $x-a = (b-a)\\,t^{p}$, the transformed integrand becomes\n$$\ng(t) \\;=\\; f(x(t))\\,x'(t) \\;\\sim\\; \\big(C\\,(b-a)^{-\\alpha}\\,t^{-\\alpha p}\\big)\\,\\big(p\\,(b-a)\\,t^{p-1}\\big)\n\\;=\\; C\\,p\\,(b-a)^{1-\\alpha}\\,t^{p(1-\\alpha)-1}.\n$$\nDefine $\\beta := p\\,(1-\\alpha)$. Then, near $t=0$,\n$$\ng(t) \\;\\sim\\; K\\,t^{\\beta-1}, \\qquad K := C\\,p\\,(b-a)^{1-\\alpha}.\n$$\n\nWe now analyze the composite trapezoidal rule applied to $g(t)$ on the uniform partition of $[0,1]$ into $N$ equal subintervals of length $h = 1/N$. For a sufficiently smooth function, the local truncation error on a single panel $[t_{i-1},t_{i}]$ with $t_{i}=i\\,h$ is given by Taylor’s theorem with remainder:\n$$\n\\varepsilon_{i} \\;=\\; -\\frac{h^{3}}{12}\\,g''(\\xi_{i}),\n$$\nfor some $\\xi_{i}\\in(t_{i-1},t_{i})$. While $g(t)$ is not globally twice continuously differentiable at $t=0$, we can still estimate the error by analyzing the singular behavior of $g''(t)$ near $t=0$. Differentiating the leading-order behavior $g(t)\\sim K\\,t^{\\beta-1}$ yields\n$$\ng'(t) \\;\\sim\\; K\\,(\\beta-1)\\,t^{\\beta-2}, \\qquad\ng''(t) \\;\\sim\\; K\\,(\\beta-1)\\,(\\beta-2)\\,t^{\\beta-3}.\n$$\nThus, for $i=1,2,\\dots,N$, with $\\xi_{i}\\approx t_{i}\\approx i/N$ in the leading-order sense, the local error obeys\n$$\n|\\varepsilon_{i}| \\;\\approx\\; \\frac{h^{3}}{12}\\,\\big|g''(\\xi_{i})\\big|\n\\;\\lesssim\\; C_{1}\\,N^{-3}\\,\\left(\\frac{i}{N}\\right)^{\\beta-3}\n\\;=\\; C_{1}\\,N^{-\\beta}\\,i^{\\beta-3},\n$$\nfor some constant $C_{1}>0$ absorbing $K$ and the factors $(\\beta-1)(\\beta-2)$.\n\nSumming the local errors, the global error magnitude is bounded (in order) by\n$$\n|E_{N}| \\;\\lesssim\\; C_{1}\\,N^{-\\beta}\\,\\sum_{i=1}^{N} i^{\\beta-3}.\n$$\nWe estimate the sum using the standard asymptotics of power sums. Let $\\gamma := \\beta-3$. Then\n- If $\\gamma>-1$ (i.e., $\\beta>2$), $\\sum_{i=1}^{N} i^{\\gamma} \\sim \\frac{N^{\\gamma+1}}{\\gamma+1}$, hence\n$$\n|E_{N}| \\;\\lesssim\\; C_{2}\\,N^{-\\beta}\\,N^{\\beta-2} \\;=\\; C_{2}\\,N^{-2},\n$$\nfor some constant $C_{2}>0$.\n- If $\\gamma=-1$ (i.e., $\\beta=2$), $\\sum_{i=1}^{N} i^{-1} \\sim \\ln N$, hence\n$$\n|E_{N}| \\;\\lesssim\\; C_{3}\\,N^{-2}\\,\\ln N,\n$$\nfor some constant $C_{3}>0$.\n- If $\\gamma<-1$ (i.e., $\\beta<2$), $\\sum_{i=1}^{N} i^{\\gamma}$ is uniformly bounded in $N$, hence\n$$\n|E_{N}| \\;\\lesssim\\; C_{4}\\,N^{-\\beta},\n$$\nfor some constant $C_{4}>0$.\n\nTherefore, the transformed composite trapezoidal rule on the graded mesh achieves the global error rate\n$$\n|E_{N}| \\;=\\; \\mathcal{O}\\!\\left(N^{-\\min\\{2,\\,\\beta\\}}\\right),\n$$\nwith a logarithmic factor when $\\beta=2$. To recover the nominal second-order global convergence rate $\\mathcal{O}(N^{-2})$ characteristic of the trapezoidal rule on twice continuously differentiable functions, we require $\\beta>2$, i.e.,\n$$\np\\,(1-\\alpha) \\;>\\; 2.\n$$\nThe smallest algebraic choice that enforces this threshold is\n$$\np \\;=\\; \\frac{2}{1-\\alpha}.\n$$\nIn practice, any choice $p>\\frac{2}{1-\\alpha}$ eliminates the borderline logarithmic factor and guarantees the $\\mathcal{O}(N^{-2})$ rate, while the explicit expression $p=\\frac{2}{1-\\alpha}$ identifies the threshold grading that recovers the nominal order in the transformed setting.\n\nThus, the graded mesh $x=a+(b-a)\\,t^{p}$ with the exponent\n$$\np \\;=\\; \\frac{2}{1-\\alpha}\n$$\njustifies the approach and determines the grading needed to recover second-order global convergence for the composite trapezoidal rule in the presence of the algebraic endpoint singularity $f(x)\\sim (x-a)^{-\\alpha}$ with $0<\\alpha<1$.", "answer": "$$\\boxed{\\frac{2}{1-\\alpha}}$$", "id": "3550921"}]}