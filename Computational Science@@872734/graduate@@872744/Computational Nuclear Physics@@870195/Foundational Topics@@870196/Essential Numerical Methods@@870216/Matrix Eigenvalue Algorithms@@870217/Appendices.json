{"hands_on_practices": [{"introduction": "Before deploying computationally intensive iterative methods, it is invaluable to have a rough estimate of where the eigenvalues of a Hamiltonian are located. Gershgorin's Circle Theorem provides a remarkably simple yet powerful tool for establishing these bounds directly from the matrix entries. This practice challenges you to apply the theorem to a model nuclear Hamiltonian, not just as a theoretical exercise, but for the practical purpose of selecting a 'safe' shift $\\sigma$ for a shift-and-invert eigensolver, a critical step for targeting specific energy regions like excited states [@problem_id:3568887].", "problem": "A nuclear shell-model Hamiltonian for a truncated configuration space is represented in a single-particle basis by the real symmetric matrix $H \\in \\mathbb{R}^{6 \\times 6}$ (Hermitian in the underlying complex formulation), whose entries are given in Mega electron Volts (MeV):\n$$\nH \\;=\\; \\begin{pmatrix}\n-8.1 & -0.25 & 0.20 & 0 & 0.05 & 0 \\\\\n-0.25 & -7.4 & -0.15 & 0 & 0 & 0 \\\\\n0.20 & -0.15 & -7.9 & 0.05 & 0.10 & 0 \\\\\n0 & 0 & 0.05 & 4.3 & -0.30 & -0.10 \\\\\n0.05 & 0 & 0.10 & -0.30 & 5.0 & -0.20 \\\\\n0 & 0 & 0 & -0.10 & -0.20 & 6.2\n\\end{pmatrix}.\n$$\nUsing first-principles tools from numerical linear algebra, compute the Gershgorin bounds for the eigenvalues of $H$ and form the union of the resulting one-dimensional Gershgorin intervals (the matrix is Hermitian, so the spectra are real). Then, in order to perform a shift-invert computation that is guaranteed to be safe (invertible factorization) while still targeting the positive-energy sector relevant to excited states, select a positive shift $\\sigma$ as the midpoint of the largest bounded open gap between adjacent positive Gershgorin intervals. Provide this $\\sigma$ in Mega electron Volts (MeV), rounded to four significant figures. The final answer must be a single real number.", "solution": "The problem requires the computation of a suitable shift parameter, $\\sigma$, for a shift-invert eigenvalue algorithm. This involves localizing the eigenvalues of the given Hamiltonian matrix $H$ using Gershgorin's circle theorem, identifying a gap in the positive part of the spectrum, and finding the midpoint of that gap.\n\nThe provided Hamiltonian matrix is:\n$$\nH \\;=\\; \\begin{pmatrix}\n-8.1 & -0.25 & 0.20 & 0 & 0.05 & 0 \\\\\n-0.25 & -7.4 & -0.15 & 0 & 0 & 0 \\\\\n0.20 & -0.15 & -7.9 & 0.05 & 0.10 & 0 \\\\\n0 & 0 & 0.05 & 4.3 & -0.30 & -0.10 \\\\\n0.05 & 0 & 0.10 & -0.30 & 5.0 & -0.20 \\\\\n0 & 0 & 0 & -0.10 & -0.20 & 6.2\n\\end{pmatrix}\n$$\nThe entries are in units of Mega electron Volts (MeV). Since $H$ is a real symmetric matrix, its eigenvalues are real numbers. Gershgorin's circle theorem states that every eigenvalue of a matrix $A \\in \\mathbb{C}^{n \\times n}$ lies within at least one of the Gershgorin disks $D(A_{ii}, R_i)$ in the complex plane, where $A_{ii}$ is the $i$-th diagonal entry and $R_i = \\sum_{j \\neq i} |A_{ij}|$ is the sum of the absolute values of the off-diagonal entries in the $i$-th row. For a real symmetric matrix like $H$, the eigenvalues are real, so the Gershgorin disks become closed intervals on the real line, $G_i = [H_{ii} - R_i, H_{ii} + R_i]$.\n\nFirst, we compute the radii $R_i$ for each row $i = 1, \\dots, 6$:\n$R_1 = |-0.25| + |0.20| + |0| + |0.05| + |0| = 0.25 + 0.20 + 0 + 0.05 + 0 = 0.50$\n$R_2 = |-0.25| + |-0.15| + |0| + |0| + |0| = 0.25 + 0.15 + 0 + 0 + 0 = 0.40$\n$R_3 = |0.20| + |-0.15| + |0.05| + |0.10| + |0| = 0.20 + 0.15 + 0.05 + 0.10 + 0 = 0.50$\n$R_4 = |0| + |0| + |0.05| + |-0.30| + |-0.10| = 0 + 0 + 0.05 + 0.30 + 0.10 = 0.45$\n$R_5 = |0.05| + |0| + |0.10| + |-0.30| + |-0.20| = 0.05 + 0 + 0.10 + 0.30 + 0.20 = 0.65$\n$R_6 = |0| + |0| + |0| + |-0.10| + |-0.20| = 0 + 0 + 0 + 0.10 + 0.20 = 0.30$\n\nNext, we determine the Gershgorin intervals $G_i = [H_{ii} - R_i, H_{ii} + R_i]$:\n$G_1 = [-8.1 - 0.50, -8.1 + 0.50] = [-8.60, -7.60]$\n$G_2 = [-7.4 - 0.40, -7.4 + 0.40] = [-7.80, -7.00]$\n$G_3 = [-7.9 - 0.50, -7.9 + 0.50] = [-8.40, -7.40]$\n$G_4 = [4.3 - 0.45, 4.3 + 0.45] = [3.85, 4.75]$\n$G_5 = [5.0 - 0.65, 5.0 + 0.65] = [4.35, 5.65]$\n$G_6 = [6.2 - 0.30, 6.2 + 0.30] = [5.90, 6.50]$\n\nThe full spectrum of $H$, denoted $\\Lambda(H)$, is contained in the union of these intervals: $\\Lambda(H) \\subseteq \\bigcup_{i=1}^6 G_i$. The problem asks to focus on the positive-energy sector, which corresponds to the intervals $G_4$, $G_5$, and $G_6$. We form the union of these positive intervals.\n\nThe intervals $G_4 = [3.85, 4.75]$ and $G_5 = [4.35, 5.65]$ overlap because the start of $G_5$ ($4.35$) is less than the end of $G_4$ ($4.75$). Their union is:\n$G_4 \\cup G_5 = [\\min(3.85, 4.35), \\max(4.75, 5.65)] = [3.85, 5.65]$.\n\nThe third positive interval is $G_6 = [5.90, 6.50]$. This interval is disjoint from the union $G_4 \\cup G_5$ because the upper bound of $G_4 \\cup G_5$ ($5.65$) is less than the lower bound of $G_6$ ($5.90$).\n\nThus, the region containing the positive eigenvalues, according to Gershgorin's theorem, is the union of two disjoint sets:\n$[3.85, 5.65] \\cup [5.90, 6.50]$.\n\nThe problem requires finding the midpoint of the \"largest bounded open gap between adjacent positive Gershgorin intervals\". In this case, there is only one such gap. This gap is the open interval between the two disjoint sets we found:\nGap $= (5.65, 5.90)$.\n\nThe shift $\\sigma$ is defined as the midpoint of this gap.\n$$\n\\sigma = \\frac{5.65 + 5.90}{2} = \\frac{11.55}{2} = 5.775\n$$\nThis value of $\\sigma$ lies within the gap, ensuring that $\\sigma$ is not an eigenvalue of $H$. Consequently, the matrix $(H - \\sigma I)$ is invertible, making the shift-invert procedure well-defined.\n\nThe problem requires the answer to be rounded to four significant figures. The number $5.775$ already has exactly four significant figures ($5$, $7$, $7$, $5$). Therefore, no further rounding is necessary. The value of the shift is $5.775$ MeV.", "answer": "$$\\boxed{5.775}$$", "id": "3568887"}, {"introduction": "Having explored how to localize eigenvalues, we now turn to the core task of computing them. For the large, sparse symmetric matrices typical of nuclear shell-model calculations, the Lanczos algorithm is a cornerstone iterative method, particularly for finding ground states and low-lying excitations. In this hands-on coding exercise, you will implement the Lanczos algorithm from first principles for a discretized Schrödinger equation, building the tridiagonal projection $T_m$ and computing its Ritz values. Critically, you will also implement the efficient, standard method for calculating the residual norm, which provides an essential *a posteriori* error estimate for your computed eigenvalues [@problem_id:3568855].", "problem": "Consider a real-symmetric matrix representation of a one-dimensional single-nucleon Hamiltonian obtained by finite-difference discretization of the time-independent Schrödinger operator on a bounded domain with Dirichlet boundary conditions. Let the Hamiltonian matrix be defined as follows. For a given number of interior grid points $N \\in \\mathbb{N}$ and a half-domain length $L \\in \\mathbb{R}_{>0}$, define the uniform mesh with spacing $h = \\dfrac{2L}{N+1}$ over the interior points $x_i = -L + i h$ for $i \\in \\{1,2,\\dots,N\\}$. The kinetic energy operator is discretized by the standard second-order central difference, producing a tridiagonal matrix $T \\in \\mathbb{R}^{N \\times N}$ with diagonal entries $T_{ii} = \\dfrac{2}{h^2}$ and first off-diagonal entries $T_{i,i+1} = T_{i+1,i} = -\\dfrac{1}{h^2}$ for all valid indices. A square-well potential of depth $V_0 \\in \\mathbb{R}_{\\ge 0}$ and half-width $a \\in \\mathbb{R}_{\\ge 0}$ is imposed by $V(x) = -V_0$ if $|x| \\le a$ and $V(x) = 0$ otherwise. Let $D \\in \\mathbb{R}^{N \\times N}$ be the diagonal matrix with $D_{ii} = V(x_i)$. The Hamiltonian is $H = T + D \\in \\mathbb{R}^{N \\times N}$.\n\nGiven a starting vector $b \\in \\mathbb{R}^N$ with $\\|b\\|_2 = 1$, the $m$-dimensional Krylov subspace is defined by $\\mathcal{K}_m(H,b) = \\operatorname{span}\\{b, Hb, H^2 b, \\dots, H^{m-1} b\\}$. Use a Lanczos construction starting from $b$ to obtain the tridiagonal Rayleigh-Ritz matrix $T_m \\in \\mathbb{R}^{m \\times m}$ associated with an orthonormal basis of $\\mathcal{K}_m(H,b)$. The Ritz values are the eigenvalues of $T_m$. The lowest Ritz value is taken to approximate the smallest eigenvalue of $H$. Let $\\theta_m \\in \\mathbb{R}$ denote the smallest eigenvalue of $T_m$ and let $y_m \\in \\mathbb{R}^m$ denote a corresponding unit-norm eigenvector. Define the Ritz vector $v_m \\in \\mathbb{R}^N$ as the projection of $y_m$ back to the full space via the Lanczos basis. The residual norm for this Ritz pair is $\\|H v_m - \\theta_m v_m\\|_2$, which serves as an a posteriori accuracy estimate for the lowest eigenvalue approximation. No physical units are required; report all numerical results as dimensionless quantities.\n\nTask: Implement a program that, for each test case specified below, constructs $H$ from $(N,L,V_0,a)$, sets $b$ to the normalized all-ones vector in $\\mathbb{R}^N$, builds the $m$-step Lanczos tridiagonal $T_m$, computes the smallest Ritz value $\\theta_m$, and estimates its accuracy by the residual norm $\\|H v_m - \\theta_m v_m\\|_2$. You must compute the residual norm exactly as defined, or by an equivalent identity that is valid for a Lanczos tridiagonalization initialized with $b$. Use the Euclidean norm for all vector norms.\n\nYour implementation must be general and numerically stable for the given sizes. The following three test cases must be executed in this exact order:\n\n- Case $1$: $N = 40$, $L = 10$, $V_0 = 5$, $a = 2$, $m = 8$.\n- Case $2$: $N = 80$, $L = 8$, $V_0 = 10$, $a = 0.5$, $m = 20$.\n- Case $3$: $N = 12$, $L = 1$, $V_0 = 0$, $a = 0$, $m = 12$.\n\nFor all cases, choose $b$ to be the normalized vector with entries $b_i = 1$ for $i \\in \\{1,2,\\dots,N\\}$.\n\nFinal output format: Your program should produce a single line of output containing a list of pairs, one pair per test case in the order given. Each pair must be $[\\theta_m,\\rho_m]$ where $\\theta_m$ is the smallest Ritz value and $\\rho_m = \\|H v_m - \\theta_m v_m\\|_2$ is the residual norm. All floating-point numbers must be printed in scientific notation with exactly $10$ significant digits, and there must be no spaces anywhere in the output. For example, an output with two cases would look like $[[1.234567890e+00,9.876543210e-05],[\\dots,\\dots]]$ but with the appropriate values for this problem. The program must not read any input and must print exactly one line.\n\nYour answer must be a complete, runnable program.", "solution": "The problem requires the determination of the lowest approximate eigenvalue, a Ritz value, and its associated accuracy for a discretized one-dimensional single-nucleon Hamiltonian. This analysis is performed using the Lanczos algorithm, a prominent Krylov subspace method that is exceptionally well-suited for finding extremal eigenvalues of large, symmetric matrices.\n\nFirst, we formalize the construction of the Hamiltonian matrix $H$. The physical system is modeled by the time-independent Schrödinger equation, $\\hat{H}\\psi = E\\psi$. For a single nucleon of mass $M$ in a potential $V(x)$, the Hamiltonian operator is $\\hat{H} = -\\dfrac{\\hbar^2}{2M} \\dfrac{d^2}{dx^2} + V(x)$. By adopting a system of units where the constant term $\\dfrac{\\hbar^2}{2M}$ is equal to $1$, the operator simplifies to $\\hat{H} = -\\dfrac{d^2}{dx^2} + V(x)$. We discretize this operator on a uniform grid over the bounded domain $[-L, L]$ with $N$ interior points and subject to Dirichlet boundary conditions, $\\psi(-L) = \\psi(L) = 0$.\n\nThe grid spacing is defined as $h = \\dfrac{2L}{N+1}$, and the interior grid points are located at $x_i = -L + i h$ for $i \\in \\{1, 2, \\dots, N\\}$. The second derivative operator is approximated using a second-order central difference stencil: $\\dfrac{d^2\\psi}{dx^2}\\bigg|_{x_i} \\approx \\dfrac{\\psi(x_{i+1}) - 2\\psi(x_i) + \\psi(x_{i-1})}{h^2}$. This discretization leads to a matrix representation of the kinetic energy operator, $T \\in \\mathbb{R}^{N \\times N}$, with entries:\n$$\nT_{ij} = \\begin{cases}\n    \\dfrac{2}{h^2} & \\text{if } i = j \\\\\n    -\\dfrac{1}{h^2} & \\text{if } |i - j| = 1 \\\\\n    0 & \\text{otherwise}\n\\end{cases}\n$$\nThe potential energy operator is represented by a diagonal matrix $D \\in \\mathbb{R}^{N \\times N}$, where the diagonal entries are given by the potential function evaluated at the grid points, $D_{ii} = V(x_i)$. The specified potential is a square well of depth $V_0$ and half-width $a$:\n$$\nV(x_i) = \\begin{cases}\n    -V_0 & \\text{if } |x_i| \\le a \\\\\n    0 & \\text{otherwise}\n\\end{cases}\n$$\nThe total discretized Hamiltonian is the sum of the kinetic and potential energy matrices, yielding the real-symmetric matrix $H = T + D \\in \\mathbb{R}^{N \\times N}$.\n\nNext, we employ the Lanczos algorithm to approximate the eigenvalues of $H$. The algorithm constructs an orthonormal basis for the Krylov subspace $\\mathcal{K}_m(H, b) = \\operatorname{span}\\{b, Hb, \\dots, H^{m-1}b\\}$, where $b$ is a given starting vector. In this process, it generates a sequence of orthonormal vectors $\\{q_j\\}_{j=1}^m$ and a real-symmetric tridiagonal matrix $T_m \\in \\mathbb{R}^{m \\times m}$. The procedure is as follows:\nInitialize: Let $q_0 = 0 \\in \\mathbb{R}^N$, $\\beta_0 = 0$, and normalize the starting vector $b$ to obtain $q_1 = b / \\|b\\|_2$.\nFor $j=1, 2, \\dots, m$:\n1. Compute the matrix-vector product $w_j = H q_j$.\n2. Compute the diagonal element of $T_m$: $\\alpha_j = q_j^T w_j$.\n3. Compute the unnormalized next vector: $\\tilde{w}_j = w_j - \\alpha_j q_j - \\beta_{j-1} q_{j-1}$. This step ensures $\\tilde{w}_j$ is orthogonal to $q_j$ and $q_{j-1}$. The three-term recurrence, a consequence of the symmetry of $H$, guarantees orthogonality to all previous basis vectors $q_k$ for $k<j$.\n4. Compute the off-diagonal element by taking the norm: $\\beta_j = \\|\\tilde{w}_j\\|_2$.\n5. If $\\beta_j$ is numerically zero, the algorithm terminates (a \"lucky breakdown\").\n6. Normalize to get the next basis vector: $q_{j+1} = \\tilde{w}_j / \\beta_j$.\n\nAfter $m$ steps, this iterative process yields the tridiagonal matrix:\n$$\nT_m = \\begin{pmatrix}\n\\alpha_1 & \\beta_1 & & & \\\\\n\\beta_1 & \\alpha_2 & \\beta_2 & & \\\\\n& \\ddots & \\ddots & \\ddots & \\\\\n& & \\beta_{m-2} & \\alpha_{m-1} & \\beta_{m-1} \\\\\n& & & \\beta_{m-1} & \\alpha_m\n\\end{pmatrix}\n$$\nThis matrix $T_m$ is the orthogonal projection of $H$ onto the Krylov subspace spanned by $\\{q_j\\}_{j=1}^m$, that is, $T_m = Q_m^T H Q_m$, where $Q_m = [q_1, q_2, \\dots, q_m]$.\n\nThe eigenvalues of the small matrix $T_m$ are called Ritz values, and they serve as approximations to the eigenvalues of the large matrix $H$. The Lanczos method is particularly effective at approximating the extremal eigenvalues of $H$. We seek the smallest eigenvalue of $H$ (the ground state energy), and thus we compute the smallest eigenvalue of $T_m$, denoted $\\theta_m$. Let $y_m$ be its corresponding unit-norm eigenvector:\n$$\nT_m y_m = \\theta_m y_m, \\quad \\|y_m\\|_2=1\n$$\nThe Ritz vector $v_m = Q_m y_m$ is the corresponding approximation to the eigenvector of $H$ in the original $N$-dimensional space.\n\nA standard a posteriori error estimate for the Ritz pair $(\\theta_m, v_m)$ is the norm of the residual vector, $\\rho_m = \\|H v_m - \\theta_m v_m\\|_2$. A direct calculation is computationally intensive. However, a fundamental property of the Lanczos algorithm provides a highly efficient method for its computation. The relationship between $H$, $Q_m$, and $T_m$ after $m$ steps is given by the identity:\n$$\nH Q_m = Q_m T_m + \\beta_m q_{m+1} e_m^T\n$$\nwhere $\\beta_m$ is the scaling factor generated at step $m$ of the algorithm, $q_{m+1}$ is the next orthonormal vector, and $e_m$ is the $m$-th standard basis vector in $\\mathbb{R}^m$. Using this identity, the residual vector simplifies dramatically:\n$$\n\\begin{aligned}\nH v_m - \\theta_m v_m &= H (Q_m y_m) - \\theta_m (Q_m y_m) \\\\\n&= (H Q_m) y_m - Q_m (\\theta_m y_m) \\\\\n&= (Q_m T_m + \\beta_m q_{m+1} e_m^T) y_m - Q_m (T_m y_m) \\\\\n&= (Q_m T_m y_m) + \\beta_m q_{m+1} (e_m^T y_m) - (Q_m T_m y_m) \\\\\n&= \\beta_m q_{m+1} (e_m^T y_m)\n\\end{aligned}\n$$\nThe term $e_m^T y_m$ is the last component of the eigenvector $y_m$, which we denote $y_{m,m}$. The residual vector is thus $r_m = \\beta_m y_{m,m} q_{m+1}$. Taking the Euclidean norm and using the fact that $\\|q_{m+1}\\|_2 = 1$, we arrive at the elegant and efficient formula for the residual norm:\n$$\n\\rho_m = \\|r_m\\|_2 = \\|\\beta_m y_{m,m} q_{m+1}\\|_2 = |\\beta_m| |y_{m,m}|\n$$\nThis formula obviates the need for explicit formation of the Ritz vector $v_m$ and the costly matrix-vector product with $H$. For the special case where $m=N$, the algorithm must terminate with $\\beta_N=0$ in exact arithmetic, leading to a residual norm of zero, as the Ritz values become the exact eigenvalues of $H$.\n\nThe implementation will execute the following steps for each test case:\n1. Construct the Hamiltonian matrix $H$ from the parameters $(N, L, V_0, a)$.\n2. Initialize and normalize the starting vector $b$.\n3. Perform $m$ iterations of the Lanczos algorithm to compute the tridiagonal matrix $T_m$ (specifically, its diagonal $\\{\\alpha_j\\}_{j=1}^m$ and off-diagonal $\\{\\beta_j\\}_{j=1}^{m-1}$ entries) and the final scalar $\\beta_m$.\n4. Solve the eigenproblem for $T_m$ using `scipy.linalg.eigh_tridiagonal` to find its eigenvalues and eigenvectors.\n5. Identify the smallest eigenvalue, $\\theta_m$, and the final component, $y_{m,m}$, of its corresponding eigenvector $y_m$.\n6. Calculate the residual norm $\\rho_m = |\\beta_m y_{m,m}|$.\n7. Format and store the pair $[\\theta_m, \\rho_m]$ for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef compute_ritz_pair(N, L, V0, a, m):\n    \"\"\"\n    Constructs the Hamiltonian, runs the Lanczos algorithm, and computes the\n    lowest Ritz value and its residual norm.\n    \"\"\"\n    # Step 1: Construct the Hamiltonian matrix H\n    h = (2.0 * L) / (N + 1.0)\n    x = np.array([-L + (i + 1.0) * h for i in range(N)])\n\n    # Kinetic energy matrix T\n    diag_T = np.full(N, 2.0 / h**2)\n    off_diag_T = np.full(N - 1, -1.0 / h**2)\n    T = np.diag(diag_T) + np.diag(off_diag_T, k=1) + np.diag(off_diag_T, k=-1)\n\n    # Potential energy matrix D\n    V_values = -V0 * (np.abs(x) <= a)\n    D = np.diag(V_values)\n\n    H = T + D\n\n    # Step 2: Initialize Lanczos algorithm\n    b = np.ones(N)\n    q = b / np.linalg.norm(b)\n    q_prev = np.zeros(N)\n    beta = 0.0\n\n    alphas = []\n    betas_off_diag = []\n\n    # Step 3: Perform m iterations of Lanczos algorithm\n    for j in range(m):\n        w = H @ q\n        alpha = np.dot(w, q)\n        alphas.append(alpha)\n\n        # The three-term recurrence ensures orthogonality\n        w_hat = w - alpha * q - beta * q_prev\n        beta = np.linalg.norm(w_hat)\n\n        q_prev = q\n        # Handle breakdown (beta is numerically zero)\n        if beta > 1e-15:\n            q = w_hat / beta\n        else:\n            # If breakdown occurs, subsequent beta values would be zero.\n            # beta_m will be this zero value.\n            break\n\n        if j < m - 1:\n            betas_off_diag.append(beta)\n    \n    # This is beta_m needed for the residual norm calculation\n    beta_m = beta\n    \n    # If the loop broke early due to lucky breakdown, right-pad alpha and beta lists\n    # to form a matrix of size j+1. The final m in this case is effectively j+1.\n    current_m = len(alphas)\n    if current_m < m:\n        # The remaining T_m entries are effectively undefined, but we need\n        # a matrix of size 'current_m'\n        pass\n    \n    # Step 4: Solve the tridiagonal eigenproblem for T_m\n    if not betas_off_diag: # handles m=1 case\n        eigvals = np.array(alphas)\n        eigvecs = np.array([[1.0]])\n    else:\n        eigvals, eigvecs = eigh_tridiagonal(np.array(alphas), np.array(betas_off_diag))\n    \n    # Step 5: Identify the smallest Ritz value and its eigenvector\n    min_eig_idx = np.argmin(eigvals)\n    theta_m = eigvals[min_eig_idx]\n    y_m = eigvecs[:, min_eig_idx]\n    \n    # Step 6: Calculate the residual norm\n    # The last component of the eigenvector y_m of the matrix T of size current_m\n    y_m_last = y_m[-1] if current_m > 0 else 0.0\n    rho_m = np.abs(beta_m * y_m_last)\n\n    return theta_m, rho_m\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, V0, a, m)\n        (40, 10.0, 5.0, 2.0, 8),\n        (80, 8.0, 10.0, 0.5, 20),\n        (12, 1.0, 0.0, 0.0, 12),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, V0, a, m = case\n        theta_m, rho_m = compute_ritz_pair(N, L, V0, a, m)\n        results.append([theta_m, rho_m])\n\n    # Final print statement in the exact required format.\n    results_str = [f\"[{val[0]:.10e},{val[1]:.10e}]\" for val in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3568855"}, {"introduction": "An iterative solver is only as good as its stopping criterion. Running for too few iterations yields an inaccurate result, while running for too many wastes valuable computational resources. This practice addresses the crucial question of when to terminate an iteration by connecting the theoretical error bounds of symmetric eigenproblems to a robust, practical stopping condition. You will derive and implement a residual-norm-based threshold for an iterative solver that guarantees a desired level of accuracy for the ground-state energy, using the spectral gap to inform your choice [@problem_id:3568857]. This exercise bridges the gap between the algorithm's mechanics and the guarantees required for scientific precision.", "problem": "You are tasked with designing, justifying, and empirically validating a stopping criterion for an iterative algorithm that targets the ground-state eigenvalue of a symmetric positive-definite Hamiltonian matrix in a one-dimensional, dimensionless setting relevant to computational nuclear physics.\n\nConsider the following dimensionless Hamiltonian discretized on a uniform grid with Dirichlet boundary conditions on the interval $\\left[-L, L\\right]$:\n- The continuous operator is $H = -\\frac{d^2}{dx^2} + \\alpha x^2$, where $\\alpha > 0$.\n- Use a standard second-order central-difference discretization with $N$ interior points and grid spacing $h = \\frac{2L}{N+1}$. The discrete Hamiltonian is the symmetric positive-definite matrix $A \\in \\mathbb{R}^{N \\times N}$ with\n  - main diagonal entries $a_{ii} = \\frac{2}{h^2} + \\alpha x_i^2$,\n  - first off-diagonal entries $a_{i,i\\pm 1} = -\\frac{1}{h^2}$,\n  - where $x_i = -L + i h$ for $i = 1, \\dots, N$.\n\nYou must:\n1. Implement an iterative solver that targets the ground state (the smallest eigenpair) of $A$ using a principled iterative method based on first principles of symmetric eigenproblems. At each iteration with a normalized vector $x$, compute the Rayleigh quotient $\\mu = x^\\top A x$ and the residual $r = A x - \\mu x$. Use only a mathematically principled residual-based stopping condition.\n2. Using a well-justified spectral-gap-dependent bound, derive a stopping threshold (in terms of the residual norm) that guarantees the final energy error $|\\mu - \\lambda_1|$ is strictly below a prescribed target that is proportional to an estimated spectral gap. Specifically, enforce that the final energy error is below $10^{-10}$ times an estimated spectral gap $\\Delta_{\\mathrm{est}}$.\n3. Obtain an independent estimate $\\Delta_{\\mathrm{est}}$ of the spectral gap using an auxiliary symmetric eigenvalue computation that returns the two smallest eigenvalues of $A$ to high accuracy, and define $\\Delta_{\\mathrm{est}}$ as their difference. Use $\\Delta_{\\mathrm{est}}$ only to set the stopping threshold and to define the normalization for verification.\n4. Empirically verify, for each test case, that upon stopping your iteration, the achieved energy error relative to $\\Delta_{\\mathrm{est}}$ satisfies the requirement $|\\mu - \\lambda_1| / \\Delta_{\\mathrm{est}} \\le 10^{-10}$, where $\\lambda_1$ is the true smallest eigenvalue of $A$ computed to high accuracy by a direct symmetric eigensolver.\n\nYour program must implement the above and run the following test suite of parameter triples $(N, L, \\alpha)$:\n- Test $1$: $(N, L, \\alpha) = (140, 8, 1)$.\n- Test $2$: $(N, L, \\alpha) = (140, 15, 0.04)$.\n- Test $3$: $(N, L, \\alpha) = (120, 6, 3)$.\n- Test $4$: $(N, L, \\alpha) = (80, 10, 0.5)$.\n\nFor each test case:\n- Construct $A$ as specified.\n- Compute an independent estimate $\\Delta_{\\mathrm{est}}$ of the spectral gap from the two smallest eigenvalues of $A$ obtained by a reliable symmetric eigenvalue routine accurate to an absolute tolerance of $10^{-12}$.\n- Run your iterative ground-state solver with a stopping threshold justified from first principles that ensures the final energy error is below $10^{-10}$ times $\\Delta_{\\mathrm{est}}$.\n- Compute the true smallest eigenvalue $\\lambda_1$ of $A$ to high accuracy using a direct symmetric eigensolver, then empirically check the inequality $|\\mu - \\lambda_1| / \\Delta_{\\mathrm{est}} \\le 10^{-10}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case output a boolean that is true if and only if the empirical inequality $|\\mu - \\lambda_1| / \\Delta_{\\mathrm{est}} \\le 10^{-10}$ holds at termination of your iteration, and false otherwise.\n- For example, a valid output for the four test cases would be of the form `[True,True,True,True]` if all verifications pass.\n\nNo user input should be read; all parameters are fixed as above. Angles are not involved. There are no physical units in this nondimensionalized formulation. Ensure the numerical implementation is stable and scientifically sound for all four tests.", "solution": "The task is to find the ground-state eigenvalue of a discretized one-dimensional quantum harmonic oscillator Hamiltonian, $H = -\\frac{d^2}{dx^2} + \\alpha x^2$, and to validate a residual-based stopping criterion for an iterative solver.\n\nFirst, we formalize the discrete Hamiltonian matrix $A$. The domain is the interval $[-L, L]$, discretized with $N$ interior points. The grid spacing is $h = \\frac{2L}{N+1}$. The grid points are $x_i = -L + i h$ for $i = 1, \\dots, N$. The second derivative operator $-\\frac{d^2}{dx^2}$ is approximated using a second-order central difference stencil, which results in a tridiagonal matrix with entries $(-\\frac{1}{h^2}, \\frac{2}{h^2}, -\\frac{1}{h^2})$. The potential term $\\alpha x^2$ contributes a diagonal matrix. Combining these, the discrete Hamiltonian $A \\in \\mathbb{R}^{N \\times N}$ is a symmetric tridiagonal matrix with entries:\n$$\na_{ij} =\n\\begin{cases}\n\\frac{2}{h^2} + \\alpha x_i^2 & \\text{if } i = j \\\\\n-\\frac{1}{h^2} & \\text{if } |i - j| = 1 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nSince $\\alpha > 0$, the continuous operator is positive-definite, and its discrete representation $A$ is also a symmetric positive-definite (SPD) matrix.\n\nThe problem requires a principled iterative method to find the smallest eigenvalue, $\\lambda_1$, of $A$. A suitable choice for this task is the Inverse Iteration method with a zero shift. For an SPD matrix, all eigenvalues are positive, $\\lambda_1 > 0$. Inverse iteration finds the eigenvalue closest to a given shift $\\sigma$. By choosing $\\sigma=0$, the algorithm converges to the eigenvector corresponding to the smallest eigenvalue, $\\lambda_1$. The algorithm proceeds as follows:\n1. Start with a random normalized vector $x_0$.\n2. For each iteration $k = 1, 2, \\dots$:\n   a. Solve the linear system $A y_k = x_{k-1}$ for $y_k$.\n   b. Normalize the resulting vector: $x_k = y_k / \\|y_k\\|_2$.\nThe vector $x_k$ converges to the eigenvector $v_1$ associated with $\\lambda_1$.\n\nThe core of the problem is to derive a stopping criterion. At each iteration, we compute the Rayleigh quotient $\\mu_k = x_k^\\top A x_k$ (an estimate of the eigenvalue) and the residual vector $r_k = A x_k - \\mu_k x_k$. The problem requires a stopping criterion based on the residual norm $\\|r_k\\|_2$ that guarantees the final energy error $|\\mu - \\lambda_1|$ is below a target value.\n\nFor a symmetric matrix $A$, the Kaniel-Paige inequality provides a powerful bound relating the error in the Rayleigh quotient to the residual norm:\n$$\n|\\mu_k - \\lambda_1| \\le \\frac{\\|r_k\\|_2^2}{\\text{gap}(\\mu_k)}\n$$\nwhere $\\text{gap}(\\mu_k) = \\min_{j: \\lambda_j \\neq \\lambda_1} |\\lambda_j - \\mu_k|$. As the iteration converges, the iterate $x_k$ approaches the true eigenvector $v_1$, and its Rayleigh quotient $\\mu_k$ approaches the true eigenvalue $\\lambda_1$. Consequently, the gap term $\\text{gap}(\\mu_k)$ approaches the true spectral gap between the first and second eigenvalues, $\\Delta = \\lambda_2 - \\lambda_1$. Thus, for a sufficiently converged iterate, we have the approximation:\n$$\n|\\mu_k - \\lambda_1| \\approx \\frac{\\|r_k\\|_2^2}{\\Delta}\n$$\nThe problem specifies a target for the final energy error: $|\\mu - \\lambda_1| \\le \\epsilon_{\\text{target}}$, where $\\epsilon_{\\text{target}} = 10^{-10} \\Delta_{\\text{est}}$. Here, $\\Delta_{\\text{est}}$ is an independent, high-accuracy estimate of the spectral gap, $\\Delta_{\\text{est}} = \\tilde{\\lambda}_2 - \\tilde{\\lambda}_1$.\n\nTo ensure our error meets this target, we enforce the condition derived from the bound:\n$$\n\\frac{\\|r_k\\|_2^2}{\\Delta_{\\text{est}}} \\le 10^{-10} \\Delta_{\\text{est}}\n$$\nRearranging this inequality gives a condition on the square of the residual norm:\n$$\n\\|r_k\\|_2^2 \\le 10^{-10} \\Delta_{\\text{est}}^2\n$$\nTaking the square root of both sides yields the final stopping criterion for our iterative solver:\n$$\n\\|r_k\\|_2 \\le 10^{-5} \\Delta_{\\text{est}}\n$$\nThis is a mathematically principled, residual-based stopping threshold that is directly dependent on the spectral properties of the matrix, as required.\n\nThe implementation plan is as follows:\n1. For each test case $(N, L, \\alpha)$, construct the symmetric tridiagonal matrix $A$.\n2. Obtain an independent estimate of the spectral gap, $\\Delta_{\\text{est}}$. This is done by computing the two smallest eigenvalues of $A$ to high precision using a specialized routine such as `scipy.sparse.linalg.eigsh(A, k=2, which='SM')`. $\\Delta_{\\text{est}}$ is the difference between these two eigenvalues.\n3. Implement the Inverse Iteration algorithm. To efficiently solve the system $A y_k = x_{k-1}$ in each step, we pre-compute the Cholesky factorization of $A$ ($A = C^\\top C$), which is numerically stable and efficient for SPD matrices. The system is then solved via two triangular substitutions.\n4. The iteration proceeds until the residual norm $\\|r_k\\|_2$ falls below the derived threshold of $10^{-5} \\Delta_{\\text{est}}$. The final Rayleigh quotient $\\mu$ is recorded.\n5. Finally, for verification, the \"true\" smallest eigenvalue $\\lambda_1$ is computed using a direct, high-accuracy solver, `scipy.linalg.eigvalsh`. The empirical validation condition $|\\mu - \\lambda_1| / \\Delta_{\\text{est}} \\le 10^{-10}$ is then checked. The boolean result of this check is the output for the test case.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import cho_factor, cho_solve, eigvalsh\nfrom scipy.sparse.linalg import eigsh\n\ndef solve():\n    \"\"\"\n    Main function to run the validation for the specified test cases.\n    \"\"\"\n    test_cases = [\n        (140, 8, 1),\n        (140, 15, 0.04),\n        (120, 6, 3),\n        (80, 10, 0.5),\n    ]\n\n    results = []\n\n    for N, L, alpha in test_cases:\n        # Step 1: Construct the Hamiltonian matrix A\n        h = 2 * L / (N + 1)\n        x_grid = np.linspace(-L + h, L - h, N)\n        \n        main_diag = 2 / h**2 + alpha * x_grid**2\n        off_diag = -1 / h**2 * np.ones(N - 1)\n        \n        A = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n\n        # Step 2: Obtain an independent estimate of the spectral gap\n        # Use a high-accuracy sparse eigensolver to find the 2 smallest eigenvalues.\n        # We set tol=1e-14 to ensure accuracy well beyond the problem's 1e-12 requirement.\n        try:\n            est_eigvals = eigsh(A, k=2, which='SM', tol=1e-14)[0]\n        except Exception:\n            # eigsh can sometimes fail; fall back to a dense solver\n            est_eigvals = eigvalsh(A, subset_by_index=[0, 1])\n\n        est_eigvals.sort()\n        lambda1_est, lambda2_est = est_eigvals\n        delta_est = lambda2_est - lambda1_est\n\n        # Step 3: Run the iterative solver (Inverse Iteration) with the derived stopping criterion\n        stop_threshold = 1e-5 * delta_est\n\n        # Pre-compute the Cholesky factorization for efficient solves\n        c, low = cho_factor(A, lower=True)\n\n        # Initialize with a random vector\n        rng = np.random.default_rng(seed=(N * L * int(alpha*100)))\n        x_k = rng.random(size=N)\n        x_k /= np.linalg.norm(x_k)\n\n        final_mu = 0.0\n        max_iter = 200 # Sufficient for convergence in all test cases\n        \n        for _ in range(max_iter):\n            # Inverse iteration step: Solve Ay = x_k\n            y_k = cho_solve((c, low), x_k)\n            \n            # Normalize to get the next iterate\n            x_k = y_k / np.linalg.norm(y_k)\n\n            # Compute Rayleigh quotient and residual\n            Ax_k = A @ x_k\n            mu_k = np.dot(x_k.T, Ax_k)\n            r_k = Ax_k - mu_k * x_k\n            norm_r = np.linalg.norm(r_k)\n\n            # Check stopping criterion\n            if norm_r < stop_threshold:\n                final_mu = mu_k\n                break\n        else:\n             # This block executes if the loop completes without breaking\n             # Indicates failure to converge within max_iter\n             final_mu = mu_k # Use the last computed value\n\n        # Step 4: Empirically verify the error bound\n        # Compute the \"true\" ground-state eigenvalue using a direct solver\n        true_lambda1 = eigvalsh(A, subset_by_index=[0, 0])[0]\n\n        # Check if the final energy error satisfies the required inequality\n        achieved_error_ratio = np.abs(final_mu - true_lambda1) / delta_est\n        is_verified = achieved_error_ratio <= 1e-10\n        results.append(is_verified)\n\n    # Final output format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3568857"}]}