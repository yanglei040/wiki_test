{"hands_on_practices": [{"introduction": "The Lippmann-Schwinger equation is a cornerstone of quantum scattering theory, reformulating the differential Schrödinger equation into an integral equation that elegantly incorporates scattering boundary conditions. This exercise provides a foundational, first-principles experience in solving this equation in momentum space for a separable potential. You will learn to manage the characteristic principal-value singularity and employ numerical quadrature with a coordinate mapping, two indispensable techniques for solving integral equations in computational physics.", "problem": "Consider nonrelativistic two-body elastic scattering of spinless particles by a spherically symmetric short-range interaction in momentum space. The nonrelativistic time-independent Schrödinger equation with a central potential is the fundamental starting point. Projecting onto partial waves and using the free resolvent (energy Green's function) leads to the momentum-space Lippmann-Schwinger equation for the partial-wave transition matrix, which in the present normalization is\n$$\nt_l(p',p;E)= v_l(p',p) + \\int_0^\\infty dq\\, q^2\\, \\frac{v_l(p',q)\\, t_l(q,p;E)}{E - \\hbar^2 q^2/(2\\mu) + i0},\n$$\nwhere $l$ is the orbital angular momentum, $p$ and $p'$ are the magnitudes of the incoming and outgoing momenta, $E$ is the center-of-mass energy, $\\mu$ is the reduced mass, and $\\hbar$ is the reduced Planck constant. The term $+i0$ denotes the limiting procedure that selects the outgoing-wave boundary condition.\n\nYour task is to derive, discretize, and implement a solver for the $l=0$ (s-wave) case using a separable Yamaguchi-type potential in dimensionless units, and compute s-wave phase shifts. You must proceed from first principles and definitions (the Schrödinger equation and the Lippmann-Schwinger equation) without shortcut formulas, and design the discretization using Gauss-Legendre quadrature with a rational infrared-ultraviolet mapping. The discretization must be described and implemented precisely.\n\nTo ensure universal applicability and mathematical clarity, adopt the following dimensionless setup:\n- Set $\\hbar^2/(2\\mu)=1$ so that energies and squared momenta share the same units.\n- Use a separable s-wave potential\n$$\nv_0(p',p) = -\\lambda \\frac{1}{(p'^2+1)}\\frac{1}{(p^2+1)},\n$$\nwhere $\\lambda0$ is a dimensionless coupling strength, and the range parameter has been scaled to unity by defining the dimensionless momentum $p\\to p/\\beta$ and choosing $\\beta$ such that the denominator is $p^2+1$.\n\nDefine the on-shell momentum $k$ by $k=\\sqrt{E}$ in these units. To avoid the singularity at $q=k$ introduced by the energy denominator, you must compute the real principal-value $K$-matrix by replacing the resolvent with its Cauchy principal value,\n$$\nK_0(p',p;E)= v_0(p',p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{v_0(p',q)\\, K_0(q,p;E)}{E - q^2}.\n$$\nFor a separable potential, the s-wave $K$-matrix on-shell reduces to a scalar rational function of the principal-value integral. Show this reduction from first principles and implement it.\n\nYou must design the quadrature for the semi-infinite integral using a Gauss-Legendre quadrature (Gaussian quadrature based on Legendre polynomials) over a finite interval with a rational mapping that simultaneously resolves the infrared ($q\\to 0$) and ultraviolet ($q\\to\\infty$) domains. Specifically, map $x\\in[-1,1]$ to $q\\in[0,\\infty)$ via\n$$\nq(x) = \\alpha\\,\\frac{1+x}{1-x},\\quad \\frac{dq}{dx} = \\frac{2\\alpha}{(1-x)^2},\n$$\nwhere $\\alpha0$ is a dimensionless scale that balances resolution between the infrared and ultraviolet. With Gauss-Legendre nodes $x_i$ and weights $w_i$ on $[-1,1]$, approximate\n$$\n\\int_0^\\infty dq\\, F(q) \\approx \\sum_{i=1}^N w_i\\,F(q(x_i))\\,\\frac{dq}{dx}\\Big|_{x=x_i}.\n$$\nTo enforce the principal value at $q=k$, use a subtraction that removes the singularity explicitly:\n$$\n\\operatorname{P}\\!\\int_0^\\infty dq\\, \\frac{f(q)}{k^2 - q^2} = \\int_0^\\infty dq\\, \\frac{f(q)-f(k)}{k^2 - q^2},\n$$\nwhich is finite and numerically well-behaved if $f$ is smooth. In the present problem, let $f(q)=q^2\\,g^2(q)$ with $g(q)=(q^2+1)^{-1}$.\n\nFrom fundamental scattering theory, connect the on-shell real $K$-matrix to the s-wave phase shift $\\delta_0(E)$ by matching asymptotic boundary conditions for real potentials in the chosen normalization. In the dimensionless units specified, the phase shift is derived from\n$$\n\\delta_0(E) = \\arctan\\!\\big(-k\\,K_0(k,k;E)\\big),\n$$\nwith $k=\\sqrt{E}$ and angles measured in radians.\n\nImplement a complete, runnable program that:\n- Constructs the Gauss-Legendre nodes and weights for a chosen $N$.\n- Applies the mapping $q(x)$ with Jacobian to approximate the principal-value integral needed for the separable s-wave $K$-matrix.\n- Computes the s-wave phase shift $\\delta_0(E)$ in radians for each test case.\n\nPhysical and numerical units and outputs:\n- All computations are performed in the dimensionless units defined by $\\hbar^2/(2\\mu)=1$, and the range parameter scaled to unity.\n- Angles must be expressed in radians.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\delta_1,\\delta_2,\\delta_3,\\delta_4]$.\n\nTest suite:\nUse the following set of test cases to assess different facets of the implementation:\n- Case $1$ (near-threshold, typical coupling): $E=0.01$, $\\lambda=1.0$, $\\alpha=1.0$.\n- Case $2$ (intermediate energy, typical coupling): $E=0.5$, $\\lambda=1.0$, $\\alpha=1.0$.\n- Case $3$ (higher energy, typical coupling): $E=2.0$, $\\lambda=1.0$, $\\alpha=1.0$.\n- Case $4$ (weak coupling, intermediate energy): $E=0.5$, $\\lambda=0.1$, $\\alpha=1.0$.\n\nAlgorithmic and scientific requirements:\n- Begin from the Schrödinger equation and the Lippmann-Schwinger integral equation as the fundamental base; derive the separable reduction and the principal-value handling.\n- Use the Gauss-Legendre quadrature with the specified mapping to approximate the semi-infinite integral.\n- Ensure scientific realism by checking numerical stability, smoothness, and convergence behavior through your choice of $N$ (you may choose any reasonable integer $N\\ge 100$).\n- The final output must be a single line in the exact format described, containing the four phase shifts in radians as floating-point numbers.", "solution": "The problem requires the calculation of s-wave phase shifts for nonrelativistic two-body elastic scattering in a dimensionless framework. This is accomplished by solving the momentum-space Lippmann-Schwinger equation for the reaction matrix ($K$-matrix) with a specific separable potential. The solution involves an analytical reduction of the integral equation to an algebraic one, followed by a numerical evaluation of a principal-value integral using Gauss-Legendre quadrature with a coordinate mapping.\n\nThe starting point is the Lippmann-Schwinger equation for the partial-wave $K$-matrix. In the specified dimensionless units where $\\hbar^2/(2\\mu)=1$ and energy $E=k^2$ ($k$ being the on-shell momentum), the equation for orbital angular momentum $l=0$ (s-wave) is:\n$$\nK_0(p',p;E)= v_0(p',p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{v_0(p',q)\\, K_0(q,p;E)}{E - q^2}\n$$\nHere, $\\operatorname{P}$ denotes the Cauchy principal value, which is necessary to handle the singularity at $q=\\sqrt{E}=k$. The potential $v_0(p',p)$ is a separable Yamaguchi-type potential given by:\n$$\nv_0(p',p) = -\\lambda g(p') g(p)\n$$\nwhere $\\lambda  0$ is the coupling strength and the form factor $g(p)$ is given by $g(p) = (p^2+1)^{-1}$.\n\nThe crucial simplification arises from the separable nature of the potential. We substitute the form of $v_0(p',p)$ into the equation for $K_0$:\n$$\nK_0(p',p;E) = -\\lambda g(p')g(p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{[-\\lambda g(p')g(q)]\\, K_0(q,p;E)}{E - q^2}\n$$\nThe term $g(p')$ can be factored out of the integral:\n$$\nK_0(p',p;E) = -\\lambda g(p') \\left[ g(p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{g(q) K_0(q,p;E)}{E - q^2} \\right]\n$$\nThis equation shows that the entire dependence of $K_0(p',p;E)$ on the momentum $p'$ is through the multiplicative factor $g(p')$. This suggests an ansatz for the structure of $K_0$ itself:\n$$\nK_0(p',p;E) = g(p') C(p,E)\n$$\nwhere $C(p,E)$ is an unknown function. Substituting this ansatz into the Lippmann-Schwinger equation yields:\n$$\ng(p') C(p,E) = -\\lambda g(p')g(p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{[-\\lambda g(p')g(q)]\\, [g(q)C(p,E)]}{E - q^2}\n$$\nThe terms $g(p')$ and $C(p,E)$ can be factored out of both sides and the integral, respectively. Assuming $g(p') \\neq 0$, we can divide by it:\n$$\nC(p,E) = -\\lambda g(p) - \\lambda C(p,E) \\left[ \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{g(q)^2}{E - q^2} \\right]\n$$\nThe integral expression depends only on the energy $E$. We define this scalar integral as:\n$$\nI(E) = \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{g(q)^2}{E - q^2}\n$$\nThe equation for $C(p,E)$ is now a simple algebraic equation:\n$$\nC(p,E) = -\\lambda g(p) - \\lambda C(p,E) I(E)\n$$\nSolving for $C(p,E)$:\n$$\nC(p,E) (1 + \\lambda I(E)) = -\\lambda g(p) \\implies C(p,E) = \\frac{-\\lambda g(p)}{1 + \\lambda I(E)}\n$$\nSubstituting this back into our ansatz for $K_0$, we obtain the closed-form solution for the $K$-matrix:\n$$\nK_0(p',p;E) = \\frac{-\\lambda g(p')g(p)}{1 + \\lambda I(E)}\n$$\nThe problem is thus reduced to the numerical evaluation of the principal-value integral $I(E)$.\n\nTo compute $I(E)$, we use the subtraction method specified. Let $k = \\sqrt{E}$ and define $f(q) = q^2 g(q)^2 = q^2 / (q^2+1)^2$. The integral becomes:\n$$\nI(E) = \\operatorname{P}\\!\\int_0^\\infty dq\\, \\frac{f(q)}{k^2 - q^2} = \\int_0^\\infty dq\\, \\frac{f(q) - f(k)}{k^2-q^2}\n$$\nThe new integrand, let's call it $F(q) = \\frac{f(q) - f(k)}{k^2-q^2}$, is now numerically well-behaved at $q=k$. As $q\\to k$, the expression limits to $f'(k)/(2k)$, avoiding any singularity.\n\nNext, we address the semi-infinite integration domain $[0, \\infty)$ by mapping it to the finite interval $[-1,1]$ using the rational map:\n$$\nq(x) = \\alpha\\,\\frac{1+x}{1-x}, \\quad \\text{with Jacobian} \\quad \\frac{dq}{dx} = \\frac{2\\alpha}{(1-x)^2}\n$$\nThe integral $I(E)$ is transformed as:\n$$\nI(E) = \\int_{-1}^{1} F(q(x)) \\frac{dq}{dx} dx = \\int_{-1}^{1} \\frac{f(q(x)) - f(k)}{k^2 - q(x)^2} \\frac{2\\alpha}{(1-x)^2} dx\n$$\nThis definite integral is now suitable for $N$-point Gauss-Legendre quadrature. Using nodes $x_i$ and weights $w_i$ for the interval $[-1,1]$, the integral is approximated by the sum:\n$$\nI(E) \\approx \\sum_{i=1}^N w_i \\left( \\frac{f(q(x_i)) - f(k)}{k^2 - q(x_i)^2} \\right) \\left( \\frac{2\\alpha}{(1-x_i)^2} \\right)\n$$\nwhere $q(x_i) = \\alpha(1+x_i)/(1-x_i)$.\n\nFinally, we relate the on-shell $K$-matrix to the s-wave phase shift $\\delta_0(E)$. The on-shell $K$-matrix is evaluated at $p=p'=k=\\sqrt{E}$:\n$$\nK_0(k,k;E) = \\frac{-\\lambda g(k)^2}{1 + \\lambda I(E)}\n$$\nThe problem provides the relationship between the on-shell $K$-matrix and the phase shift in the given normalization:\n$$\n\\delta_0(E) = \\arctan(-k K_0(k,k;E))\n$$\nSubstituting our expression for $K_0(k,k;E)$:\n$$\n\\delta_0(E) = \\arctan\\left(-k \\left[ \\frac{-\\lambda g(k)^2}{1 + \\lambda I(E)} \\right]\\right) = \\arctan\\left(\\frac{k \\lambda g(k)^2}{1 + \\lambda I(E)}\\right)\n$$\nwhere $g(k) = (k^2+1)^{-1} = (E+1)^{-1}$. This expression is now fully specified and can be implemented numerically.\n\nThe algorithm for each test case $(E, \\lambda, \\alpha)$ is as follows:\n1.  Set $k=\\sqrt{E}$ and choose a sufficiently large number of quadrature points $N$ (e.g., $N=128$).\n2.  Generate the $N$ Gauss-Legendre nodes $x_i$ and weights $w_i$ on $[-1,1]$.\n3.  Compute the value of $f(k) = k^2/(k^2+1)^2$.\n4.  For each node $x_i$, compute the corresponding momentum point $q_i=q(x_i)$, the function value $f(q_i)$, and the Jacobian $dq/dx|_{x_i}$.\n5.  Evaluate the sum to approximate $I(E)$.\n6.  Use the computed value of $I(E)$ to calculate $\\delta_0(E)$ in radians using the final derived formula.\nThis procedure systematically implements the solution based on the principles of scattering theory.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# The following import for Gauss-Legendre quadrature is standard and necessary.\n# numpy.polynomial.legendre.leggauss is the canonical source for this in numpy.\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Solves the Lippmann-Schwinger equation for the s-wave K-matrix with a\n    separable potential and computes the phase shift.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (E, lambda, alpha)\n        (0.01, 1.0, 1.0),  # Case 1\n        (0.5, 1.0, 1.0),   # Case 2\n        (2.0, 1.0, 1.0),   # Case 3\n        (0.5, 0.1, 1.0),   # Case 4\n    ]\n\n    # Set the number of quadrature points as required (N = 100).\n    # A choice of N=128 is a power of 2, often good for numerical algorithms,\n    # and safely above the minimum requirement.\n    N = 128\n\n    results = []\n    \n    # Generate Gauss-Legendre nodes and weights for the interval [-1, 1]\n    x_nodes, w_weights = leggauss(N)\n\n    for E, lam, alpha in test_cases:\n        # On-shell momentum k\n        k = np.sqrt(E)\n\n        # Define the form factor g(p) and the function f(p) = p^2 * g(p)^2\n        def g(p):\n            return 1.0 / (p**2 + 1.0)\n\n        def f(p):\n            return p**2 / (p**2 + 1.0)**2\n\n        # Value of f at the on-shell momentum k for the subtraction method\n        f_k = f(k)\n\n        # --- Numerical Integration for I(E) ---\n        # 1. Map Gauss-Legendre nodes x_i in [-1, 1] to momentum points q_i in [0, inf)\n        # The mapping is q(x) = alpha * (1 + x) / (1 - x)\n        q_nodes = alpha * (1.0 + x_nodes) / (1.0 - x_nodes)\n        \n        # 2. Calculate the Jacobian of the transformation\n        # dq/dx = 2 * alpha / (1 - x)^2\n        jacobian = 2.0 * alpha / (1.0 - x_nodes)**2\n        \n        # 3. Evaluate the integrand for the principal value integral\n        # The integrand is (f(q) - f(k)) / (k^2 - q^2)\n        # which is numerically stable due to the subtraction.\n        f_q_nodes = f(q_nodes)\n        \n        # We must handle the case where a quadrature node q_i might numerically\n        # equal k. While unlikely, it can lead to 0/0 - NaN.\n        # The limit of the integrand as q-k is f'(k)/(2k).\n        # f'(p) = (2p * (1 - p^2)) / (p^2 + 1)^3\n        # limit_val = f'(k) / (2k) = (1 - k^2) / (k^2 + 1)^3\n        # However, numpy's float arithmetic typically handles this subtraction\n        # correctly without explicit NaN, so direct evaluation is robust enough.\n        pv_integrand_values = (f_q_nodes - f_k) / (k**2 - q_nodes**2)\n        \n        # 4. Compute the integral I(E) by summing over the quadrature points\n        I_E = np.sum(w_weights * pv_integrand_values * jacobian)\n        \n        # --- Phase Shift Calculation ---\n        # Calculate the on-shell K-matrix K_0(k,k;E)\n        # K_0(k,k;E) = -lambda * g(k)^2 / (1 + lambda * I(E))\n        g_k_squared = g(k)**2\n        K_on_shell = (-lam * g_k_squared) / (1.0 + lam * I_E)\n        \n        # Calculate the s-wave phase shift delta_0(E) in radians\n        # delta_0(E) = arctan(-k * K_0(k,k;E))\n        delta_0 = np.arctan(-k * K_on_shell)\n        \n        results.append(delta_0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.8f}' for res in results)}]\")\n\nsolve()\n```", "id": "3589031"}, {"introduction": "While direct solutions of the Schrödinger equation are fundamental, at low energies the complex details of the nuclear interaction can be distilled into a few powerful parameters. This is the role of the effective-range expansion (ERE), which provides a model-independent parameterization of the phase shift. This practice [@problem_id:3588976] explores not only the standard ERE for neutral particles but also the crucial modifications required for scattering charged particles, such as proton-proton scattering, revealing the interplay between short-range nuclear forces and the long-range Coulomb interaction.", "problem": "You are to derive, implement, and validate a computational procedure for the Coulomb-modified effective-range expansion in the context of low-energy nucleon-nucleon scattering. The focus is the $S$-wave ($l=0$) scattering with and without Coulomb interaction. Begin from the nonrelativistic Schrödinger equation with a short-range nuclear potential $V_N(r)$ and, for charged particles, a Coulomb potential $V_C(r)=\\alpha Z_1 Z_2 / r$, where $\\alpha$ is the fine-structure constant and $Z_1,Z_2$ are the charges in units of the proton charge. Use partial-wave scattering theory and the analytic behavior of the $S$-matrix near threshold to construct an effective-range function that is linear in $k^2$ at sufficiently low energy. For neutral-particle scattering, this is the usual effective-range expansion. For charged particles, the nuclear phase shift is defined relative to Coulomb-distorted waves, and the effective-range function must be modified by well-defined Coulomb functions.\n\nYour tasks are:\n- Derive, from the fundamental definitions of the scattering phase shift and the analytic structure of the $S$-matrix near threshold, the Coulomb-modified effective-range expansion for the $S$-wave, and identify the specific Coulomb functions that appear in the modification. Carefully define the Sommerfeld parameter $\\eta$ and the Coulomb penetration factor, and state the functional form that must be subtracted from $k\\cot\\delta_0^C$ to isolate the short-range physics.\n- Implement a program that:\n  1. Constructs synthetic $S$-wave phase shifts for proton-proton ($pp$) scattering, $\\delta_0^C(k)$, using the derived Coulomb-modified effective-range expansion at leading order. Use a physically consistent reduced mass and a set of specified center-of-mass energies to produce $\\delta_0^C(k)$ values that are scientifically plausible.\n  2. Fits the Coulomb-modified scattering length $a_C$ and effective range $r_C$ from the synthetic $\\delta_0^C(k)$ by forming the Coulomb-modified effective-range function and performing a linear regression in $k^2$.\n  3. Constructs synthetic $S$-wave phase shifts for neutron-proton ($np$) scattering, $\\delta_0(k)$, using the neutral-particle effective-range expansion at leading order, and fits the scattering length $a$ and effective range $r$ in the same manner.\n  4. Compares the fitted $(a_C,r_C)$ for $pp$ to the fitted $(a,r)$ for $np$ by computing the differences $a_C-a$ and $r_C-r$.\n\nDefinitions and units required for implementation:\n- Let $E_{\\mathrm{cm}}$ be the center-of-mass energy in $\\mathrm{MeV}$. The wave number is $k=\\sqrt{2\\mu E_{\\mathrm{cm}}}/(\\hbar c)$ in $\\mathrm{fm}^{-1}$, where $\\mu$ is the reduced mass in $\\mathrm{MeV}$ and $\\hbar c$ is the product of the reduced Planck constant and the speed of light in $\\mathrm{MeV\\,fm}$. Use $m_p c^2=938.2720813\\,\\mathrm{MeV}$, $m_n c^2=939.5654133\\,\\mathrm{MeV}$, $\\mu_{pp}=m_p/2$, and $\\mu_{np}=m_p m_n/(m_p+m_n)$.\n- The Sommerfeld parameter for $pp$ is $\\eta=\\alpha \\mu /(\\hbar c\\,k)$, with $\\alpha=1/137.035999084$.\n- The angle unit for all phase shifts $\\delta$ is radians.\n- The output scattering lengths and effective ranges must be expressed in femtometers ($\\mathrm{fm}$).\n\nTest suite specification:\n- Case 1 (happy path, $pp$ with Coulomb): $E_{\\mathrm{cm}}$ values $[0.25,0.5,1.0,2.0]$ in $\\mathrm{MeV}$. Use ground-truth Coulomb-modified parameters $a_C^{\\mathrm{true}}=-7.82\\,\\mathrm{fm}$ and $r_C^{\\mathrm{true}}=2.79\\,\\mathrm{fm}$ to generate $\\delta_0^C(k)$.\n- Case 2 (near-threshold stability, $pp$ with Coulomb): $E_{\\mathrm{cm}}$ values $[0.05,0.10,0.20]$ in $\\mathrm{MeV}$ with the same $a_C^{\\mathrm{true}}$ and $r_C^{\\mathrm{true}}$.\n- Case 3 (neutral comparison, $np$ without Coulomb): $E_{\\mathrm{cm}}$ values $[0.25,0.5,1.0,2.0]$ in $\\mathrm{MeV}$. Use ground-truth neutral parameters $a^{\\mathrm{true}}=-23.75\\,\\mathrm{fm}$ and $r^{\\mathrm{true}}=2.70\\,\\mathrm{fm}$ to generate $\\delta_0(k)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n- $a_C$ and $r_C$ fitted for Case 1,\n- $a_C$ and $r_C$ fitted for Case 2,\n- $a$ and $r$ fitted for Case 3,\n- the differences $a_C-a$ and $r_C-r$ comparing Case 1 ($pp$) to Case 3 ($np$).\n\nThus the output format is exactly:\n\"[$a_C^{(1)},r_C^{(1)},a_C^{(2)},r_C^{(2)},a^{(3)},r^{(3)},a_C^{(1)}-a^{(3)},r_C^{(1)}-r^{(3)}]$\"\n\nAll eight numbers must be floats, and $a_C$, $r_C$, $a$, $r$, and their differences must be in $\\mathrm{fm}$.", "solution": "The problem requires the derivation and implementation of the effective-range expansion (ERE) for $S$-wave ($l=0$) nucleon-nucleon scattering, both for neutral particles ($np$) and charged particles ($pp$). The solution logically proceeds in two parts: first, a theoretical derivation of the necessary formulae, and second, a description of the computational procedure to implement the theory.\n\n**Part 1: Theoretical Derivation of the Effective-Range Expansion**\n\nThe effective-range expansion is a model-independent parameterization of the low-energy elastic scattering cross-section. It relates the scattering phase shift to fundamental length scales characterizing the interaction potential: the scattering length and the effective range. Its derivation relies on the analytic properties of the scattering amplitude near the zero-energy threshold ($k \\to 0$).\n\n**1.A. Neutral Particle Scattering (e.g., $np$)**\n\nFor the scattering of two neutral particles interacting via a short-range nuclear potential $V_N(r)$, the $S$-wave ($l=0$) radial Schrödinger equation for the reduced-mass particle is:\n$$\n\\frac{d^2u_0(r)}{dr^2} + \\left(k^2 - U_N(r)\\right)u_0(r) = 0\n$$\nwhere $u_0(r)$ is the radial wave function, $k^2 = 2\\mu E_{\\mathrm{cm}}/\\hbar^2$ is the square of the center-of-mass wave number, $E_{\\mathrm{cm}}$ is the center-of-mass energy, $\\mu$ is the reduced mass, and $U_N(r) = 2\\mu V_N(r)/\\hbar^2$ is the reduced potential. The boundary condition is $u_0(0)=0$.\n\nFor a potential of finite range $R$ (i.e., $V_N(r)=0$ for $r  R$), the wave function outside the potential region has the form:\n$$\nu_0(r) \\propto \\sin(kr + \\delta_0(k)), \\quad r  R\n$$\nwhere $\\delta_0(k)$ is the $S$-wave nuclear phase shift. The information about the scattering process is entirely encapsulated in $\\delta_0(k)$.\n\nThe theory of effective range, developed by Schwinger and Bethe, establishes that for short-range potentials, the function $k \\cot\\delta_0(k)$ is an analytic function of $k^2$ at low energies. It can thus be expanded in a Taylor series about $k^2=0$:\n$$\nk \\cot\\delta_0(k) = -\\frac{1}{a} + \\frac{1}{2} r k^2 + O(k^4)\n$$\nThis is the standard **effective-range expansion**. The parameters $a$ and $r$ are the scattering length and effective range, respectively.\n- The **scattering length $a$** is defined as the zero-energy limit: $a = -\\lim_{k\\to 0} \\frac{\\tan\\delta_0(k)}{k}$. It characterizes the strength of the interaction at vanishing energy.\n- The **effective range $r$** characterizes the energy dependence of the scattering and is related to the spatial extent of the potential.\n\n**1.B. Charged Particle Scattering (e.g., $pp$)**\n\nWhen the scattering particles are charged, such as in proton-proton ($pp$) scattering, the long-range Coulomb potential $V_C(r) = \\alpha \\hbar c Z_1 Z_2 / r$ must be included. For $pp$ scattering, $Z_1=Z_2=1$. The $S$-wave radial Schrödinger equation becomes:\n$$\n\\frac{d^2u_0^C(r)}{dr^2} + \\left(k^2 - \\frac{2\\eta k}{r} - U_N(r)\\right)u_0^C(r) = 0\n$$\nHere, we have introduced the dimensionless **Sommerfeld parameter $\\eta$**, which quantifies the strength of the Coulomb interaction relative to the kinetic energy:\n$$\n\\eta = \\frac{\\alpha \\mu c^2}{\\hbar c k}\n$$\nwhere $\\alpha$ is the fine-structure constant.\n\nThe long-range nature of the Coulomb potential ($1/r$) fundamentally alters the asymptotic behavior of the wave function. The simple form $\\sin(kr + \\delta_0)$ is no longer valid. Instead, the solution outside the range of $V_N(r)$ must be expressed as a linear combination of the regular ($F_0$) and irregular ($G_0$) $S$-wave Coulomb functions:\n$$\nu_0^C(r) \\propto \\cos\\delta_0^C F_0(\\eta, kr) + \\sin\\delta_0^C G_0(\\eta, kr)\n$$\nThe phase shift $\\delta_0^C$ is the nuclear phase shift measured relative to the pure Coulomb scattering waves.\n\nDue to the Coulomb interaction, the function $k \\cot\\delta_0^C$ is not analytic at $k^2=0$. It contains singularities related to the long-range tail. However, a modified function can be constructed that is analytic in $k^2$. This result, from Jackson and Blatt, is the **Coulomb-modified effective-range expansion**:\n$$\nC_0^2(\\eta) k \\cot\\delta_0^C + 2k\\eta h(\\eta) = -\\frac{1}{a_C} + \\frac{1}{2} r_C k^2 + O(k^4)\n$$\nThe new quantities are the Coulomb penetration factor $C_0^2(\\eta)$ and the Coulomb function $h(\\eta)$. $a_C$ and $r_C$ are the Coulomb-modified scattering length and effective range.\n\nThe functions required for this expansion are:\n- The **Coulomb penetration factor for $l=0$**, $C_0^2(\\eta)$, accounts for the suppression of the wave function at the origin by the repulsive Coulomb barrier. It is given by:\n  $$\n  C_0^2(\\eta) = \\frac{2\\pi\\eta}{e^{2\\pi\\eta} - 1}\n  $$\n- The function $h(\\eta)$ is defined to cancel the remaining non-analytic terms arising from the Coulomb interaction. It is given by:\n  $$\n  h(\\eta) = \\mathrm{Re}\\left[\\psi(i\\eta)\\right] - \\ln\\eta\n  $$\n  where $\\psi(z) = \\frac{d}{dz}\\ln\\Gamma(z)$ is the digamma function.\n\nThe problem asks to identify the functional form that must be subtracted from $k\\cot\\delta_0^C$. The formula is not a simple subtraction. The term $k\\cot\\delta_0^C$ is first multiplied by $C_0^2(\\eta)$, and then the function $2k\\eta h(\\eta)$ is added. The combination isolates the short-range physics, yielding a function that is approximately linear in $k^2$ at low energies:\n$$\nf(k^2) = C_0^2(\\eta) k \\cot\\delta_0^C + 2k\\eta h(\\eta)\n$$\n\n**Part 2: Computational Procedure**\n\nThe implementation involves two main steps: ($1$) generating synthetic phase shift data using the ERE formulae and given \"true\" parameters, and ($2$) fitting these parameters back from the synthetic data to validate the procedure.\n\n**2.A. Data Generation**\nFor a given set of center-of-mass energies $E_{\\mathrm{cm},i}$, we first calculate the corresponding wave numbers $k_i = \\sqrt{2\\mu E_{\\mathrm{cm},i}} / (\\hbar c)$. Then, using the provided true parameters ($a^{\\mathrm{true}}, r^{\\mathrm{true}}$), we generate the phase shifts $\\delta_{0,i}$.\n\n- **For neutral scattering ($np$)**:\n  1. Calculate the value of the ERE function: $Y_i = -1/a^{\\mathrm{true}} + \\frac{1}{2}r^{\\mathrm{true}} k_i^2$.\n  2. From the definition $Y_i = k_i \\cot\\delta_{0,i}$, solve for the phase shift: $\\delta_{0,i} = \\mathrm{arccot}(Y_i / k_i)$.\n\n- **For charged scattering ($pp$)**:\n  1. For each $k_i$, calculate the corresponding Sommerfeld parameter $\\eta_i = \\alpha \\mu_{pp} / (\\hbar c k_i)$.\n  2. Calculate the values of the Coulomb functions $C_0^2(\\eta_i)$ and $h(\\eta_i)$.\n  3. Calculate the value of the Coulomb-modified ERE function: $Y_i = -1/a_C^{\\mathrm{true}} + \\frac{1}{2}r_C^{\\mathrm{true}} k_i^2$.\n  4. From the definition $Y_i = C_0^2(\\eta_i) k_i \\cot\\delta_{0,i}^C + 2k_i\\eta_i h(\\eta_i)$, solve for the phase shift:\n     $$\n     \\cot\\delta_{0,i}^C = \\frac{Y_i - 2k_i\\eta_i h(\\eta_i)}{C_0^2(\\eta_i) k_i}\n     $$\n     And thus, $\\delta_{0,i}^C = \\mathrm{arccot}\\left(\\frac{Y_i - 2k_i\\eta_i h(\\eta_i)}{C_0^2(\\eta_i) k_i}\\right)$.\n\nNumerically, $\\mathrm{arccot}(x)$ is robustly computed as $\\arctan(1/x)$ or, even better, using a two-argument arctangent function like `numpy.arctan2` to handle different quadrants and signs correctly.\n\n**2.B. Parameter Fitting**\nWith the synthetic data sets $\\{ (k_i, \\delta_{0,i}) \\}$ and $\\{ (k_i, \\delta_{0,i}^C) \\}$, we can perform a linear regression to extract the scattering parameters. The model is $y = A + Bx$, where $x=k^2$, $A = -1/a$, and $B = r/2$.\n\n- **For neutral scattering ($np$)**:\n  1. Construct the data points for the fit: $(x_i, y_i) = (k_i^2, k_i \\cot\\delta_{0,i})$.\n  2. Perform a linear fit $y = A + Bx$ to these points. The slope $B$ and intercept $A$ are determined.\n  3. The fitted parameters are $a_{\\mathrm{fit}} = -1/A$ and $r_{\\mathrm{fit}} = 2B$.\n\n- **For charged scattering ($pp$)**:\n  1. Construct the data points for the fit: $(x_i, y_i) = (k_i^2, C_0^2(\\eta_i) k_i \\cot\\delta_{0,i}^C + 2k_i\\eta_i h(\\eta_i))$.\n  2. Perform a linear fit $y = A + Bx$.\n  3. The fitted parameters are $a_{C, \\mathrm{fit}} = -1/A$ and $r_{C, \\mathrm{fit}} = 2B$.\n\nThis procedure of generating data and fitting it back with the same model serves as a crucial validation test for the correctness of the numerical implementation of the theoretical formulae. A successful implementation should recover the input true parameters to high precision.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import psi\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates the Coulomb-modified effective-range expansion\n    for low-energy nucleon-nucleon scattering.\n    \"\"\"\n\n    # Physical constants and definitions\n    m_p_c2 = 938.2720813  # MeV\n    m_n_c2 = 939.5654133  # MeV\n    hbar_c = 197.3269804  # MeV fm\n    alpha = 1.0 / 137.035999084\n\n    # Reduced masses in MeV\n    mu_pp = m_p_c2 / 2.0\n    mu_np = (m_p_c2 * m_n_c2) / (m_p_c2 + m_n_c2)\n\n    # Test suite specification\n    test_cases = [\n        {\n            \"name\": \"Case 1 (pp)\",\n            \"type\": \"pp\",\n            \"mu\": mu_pp,\n            \"E_cm_MeV\": np.array([0.25, 0.5, 1.0, 2.0]),\n            \"a_true\": -7.82,  # fm\n            \"r_true\": 2.79,   # fm\n        },\n        {\n            \"name\": \"Case 2 (pp)\",\n            \"type\": \"pp\",\n            \"mu\": mu_pp,\n            \"E_cm_MeV\": np.array([0.05, 0.10, 0.20]),\n            \"a_true\": -7.82,  # fm\n            \"r_true\": 2.79,   # fm\n        },\n        {\n            \"name\": \"Case 3 (np)\",\n            \"type\": \"np\",\n            \"mu\": mu_np,\n            \"E_cm_MeV\": np.array([0.25, 0.5, 1.0, 2.0]),\n            \"a_true\": -23.75,  # fm\n            \"r_true\": 2.70,   # fm\n        },\n    ]\n\n    results = {}\n\n    for case in test_cases:\n        E_cm = case[\"E_cm_MeV\"]\n        mu = case[\"mu\"]\n        a_true = case[\"a_true\"]\n        r_true = case[\"r_true\"]\n        case_type = case[\"type\"]\n        case_name = case[\"name\"]\n\n        # Calculate wave number k in fm^-1\n        k = np.sqrt(2.0 * mu * E_cm) / hbar_c\n\n        # --- 1. Generate synthetic phase shifts ---\n        delta = None\n        if case_type == \"np\":\n            # Neutral particle ERE: k * cot(delta) = -1/a + 0.5 * r * k^2\n            Y_true = -1.0 / a_true + 0.5 * r_true * k**2\n            # delta = arccot(Y_true / k)\n            delta = np.arctan2(k, Y_true)\n        \n        elif case_type == \"pp\":\n            # Coulomb-modified ERE\n            eta = alpha * mu / (hbar_c * k)\n            \n            # C_0^2(eta) = 2*pi*eta / (exp(2*pi*eta) - 1)\n            C0_squared = 2.0 * np.pi * eta / np.expm1(2.0 * np.pi * eta)\n            \n            # h(eta) = Re[psi(i*eta)] - ln(eta)\n            h_eta = np.real(psi(1j * eta)) - np.log(eta)\n            \n            # Y_true = -1/a_C + 0.5 * r_C * k^2\n            Y_true = -1.0 / a_true + 0.5 * r_true * k**2\n            \n            # Y_true = C0_squared * k * cot(delta) + 2*k*eta*h(eta)\n            # -- cot(delta) = (Y_true - 2*k*eta*h(eta)) / (C0_squared * k)\n            cot_delta_numerator = Y_true - 2.0 * k * eta * h_eta\n            cot_delta_denominator = C0_squared * k\n            delta = np.arctan2(cot_delta_denominator, cot_delta_numerator)\n\n        # --- 2. Fit parameters from synthetic data ---\n        \n        # Construct the linear system y = A + B*x for fitting\n        # x = k^2, y = ERE function\n        x_fit = k**2\n        y_fit = None\n        \n        if case_type == \"np\":\n            y_fit = k * (1.0 / np.tan(delta))\n        \n        elif case_type == \"pp\":\n            eta = alpha * mu / (hbar_c * k)\n            C0_squared = 2.0 * np.pi * eta / np.expm1(2.0 * np.pi * eta)\n            h_eta = np.real(psi(1j * eta)) - np.log(eta)\n            y_fit = C0_squared * k * (1.0 / np.tan(delta)) + 2.0 * k * eta * h_eta\n            \n        # Perform linear regression: y_fit = slope * x_fit + intercept\n        # slope = B = r/2, intercept = A = -1/a\n        # np.polyfit returns [slope, intercept]\n        p = np.polyfit(x_fit, y_fit, 1)\n        slope, intercept = p[0], p[1]\n        \n        a_fit = -1.0 / intercept\n        r_fit = 2.0 * slope\n        \n        results[case_name] = (a_fit, r_fit)\n\n    # --- 3. Compile final output list ---\n    aC1, rC1 = results[\"Case 1 (pp)\"]\n    aC2, rC2 = results[\"Case 2 (pp)\"]\n    a3, r3 = results[\"Case 3 (np)\"]\n\n    diff_a = aC1 - a3\n    diff_r = rC1 - r3\n    \n    final_output = [aC1, rC1, aC2, rC2, a3, r3, diff_a, diff_r]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_output))}]\")\n\nsolve()\n```", "id": "3588976"}, {"introduction": "This practice completes our journey from potentials to parameters by addressing the inverse problem: extracting fundamental interaction parameters from scattering data. Using the effective-range expansion as our theoretical model, we will confront synthetic phase-shift data, mimicking a real experimental or large-scale simulation output. This exercise [@problem_id:3589013] will guide you through the implementation of a weighted least-squares fit, a ubiquitous data analysis technique, and emphasizes the critical importance of rigorous uncertainty quantification for the extracted parameters.", "problem": "You are tasked with designing and implementing a complete, runnable program that performs a principled weighted least-squares extraction of the scattering length and effective range from low-energy $s$-wave phase-shift data within the context of computational nuclear physics. The program must be based on well-established scattering theory and must quantify parameter uncertainties and their correlation.\n\nBegin from the following fundamental base in elastic two-body scattering:\n- The radial Schrödinger equation with short-range interaction yields phase shifts, and for low-energy $s$-wave scattering the effective range expansion is a widely used representation connecting observables and parameters.\n- The phase shift $\\delta_0(k)$, where $k$ is the relative wave number, is a physically measurable quantity, and the effective range expansion for $s$-wave scattering relates $k \\cot \\delta_0(k)$ to the scattering length $a$ and effective range $r_e$ through a series whose leading terms are valid at low $k$.\n\nYour tasks are:\n1. Derive, from the effective range expansion base, a linear-in-parameters model suitable for weighted least-squares (Weighted Least Squares (WLS)) regression using measured $\\delta_0(k)$ with known uncertainties. Explicitly justify how the observable and its uncertainty are transformed so that the model becomes linear in the fit parameters and the weights are correctly defined from measurement uncertainties.\n2. Design and implement the WLS estimator for the linear model you obtain, including the construction of the design matrix, weights from measurement uncertainties, and solution of the normal equations.\n3. Obtain parameter point estimates $(a,r_e)$ from the fitted linear parameters, and derive an uncertainty quantification procedure grounded in linear error propagation using the covariance matrix of the WLS estimator. Derive and compute the parameter standard deviations and their correlation coefficient. Also propose a complementary method to assess parameter uncertainties and correlation that is robust to mild nonlinearity and noise heteroscedasticity.\n4. Apply your method to the following test suite of synthetic datasets. For each dataset, construct the measured phase shifts by first computing noiseless $\\delta_0(k)$ from the effective range expansion and then adding Gaussian measurement noise with a specified standard deviation $\\sigma_\\delta$ and fixed random seed to ensure reproducibility. Angles must be in radians, and $k$ must be in $\\mathrm{fm}^{-1}$. The scattering length $a$ and effective range $r_e$ must be reported in $\\mathrm{fm}$.\n\nFundamental base to use for modeling:\n- The effective range expansion at low energies: \n$$\nk \\cot \\delta_0(k) = -\\frac{1}{a} + \\frac{1}{2} r_e k^2 + \\mathcal{O}(k^4).\n$$\n- From this, define a linear-in-parameters observable $y(k)$ to regress against a polynomial in $k^2$, and provide the transformation from $\\delta_0(k)$ to $y(k)$ and its uncertainty.\n\nSynthetic data generation protocol for each test case:\n- For each listed wave number $k_i$, compute the noiseless phase shift $\\delta_0(k_i)$ using \n$$\n\\tan \\delta_0(k_i) = \\frac{k_i}{-\\frac{1}{a_{\\text{true}}} + \\frac{1}{2} r_{e,\\text{true}} k_i^2}.\n$$\n- Then add independent Gaussian noise $\\epsilon_i \\sim \\mathcal{N}(0,\\sigma_\\delta^2)$ to obtain the measured $\\delta_{0,\\text{meas}}(k_i) = \\delta_0(k_i) + \\epsilon_i$ using the specified $\\sigma_\\delta$ and random seed.\n\nTest suite specifications:\n- Case $1$ (general \"happy path\" case):\n  - True parameters: $a_{\\text{true}} = 5.0\\,\\mathrm{fm}$, $r_{e,\\text{true}} = 1.8\\,\\mathrm{fm}$.\n  - Wave numbers $k$ in $\\mathrm{fm}^{-1}$: $[0.05,0.075,0.10,0.125,0.15,0.175,0.20,0.225,0.25,0.275,0.30]$.\n  - Noise standard deviation: $\\sigma_\\delta = 0.01$ radians.\n  - Random seed: $42$.\n- Case $2$ (near-unitarity, large scattering length):\n  - True parameters: $a_{\\text{true}} = 100.0\\,\\mathrm{fm}$, $r_{e,\\text{true}} = 2.0\\,\\mathrm{fm}$.\n  - Wave numbers $k$ in $\\mathrm{fm}^{-1}$: $[0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.10,0.11,0.12]$.\n  - Noise standard deviation: $\\sigma_\\delta = 0.005$ radians.\n  - Random seed: $123$.\n- Case $3$ (edge case: very low $k$ range, challenging parameter separation):\n  - True parameters: $a_{\\text{true}} = 5.0\\,\\mathrm{fm}$, $r_{e,\\text{true}} = 1.8\\,\\mathrm{fm}$.\n  - Wave numbers $k$ in $\\mathrm{fm}^{-1}$: $[0.005,0.008,0.011,0.014,0.017,0.020]$.\n  - Noise standard deviation: $\\sigma_\\delta = 0.005$ radians.\n  - Random seed: $2021$.\n- Case $4$ (negative scattering length, virtual-state-like scenario):\n  - True parameters: $a_{\\text{true}} = -20.0\\,\\mathrm{fm}$, $r_{e,\\text{true}} = 2.7\\,\\mathrm{fm}$.\n  - Wave numbers $k$ in $\\mathrm{fm}^{-1}$: $[0.05,0.075,0.10,0.125,0.15,0.175,0.20,0.225,0.25,0.275,0.30,0.325,0.35,0.375,0.40,0.425,0.45,0.475,0.50]$.\n  - Noise standard deviation: $\\sigma_\\delta = 0.02$ radians.\n  - Random seed: $7$.\n\nProgram requirements:\n- Implement the WLS fit to obtain parameter estimates $(a,r_e)$ in $\\mathrm{fm}$ from the linearized model.\n- Quantify parameter uncertainties (standard deviations) and the correlation coefficient using linear error propagation from the WLS covariance of the linear parameters.\n- Your program must produce a single line of output containing the results as a comma-separated Python list-of-lists, one sublist per test case, where each sublist contains $[a_{\\text{fit}}, r_{e,\\text{fit}}, \\sigma_a, \\sigma_{r_e}, \\rho]$. All angles are in radians, and $k$ is in $\\mathrm{fm}^{-1}$. The units of $a_{\\text{fit}}$, $r_{e,\\text{fit}}$, $\\sigma_a$, and $\\sigma_{r_e}$ are $\\mathrm{fm}$, and $\\rho$ is dimensionless.\n\nThe final printed line must have the exact format: a single line with the results as a bracketed list, for example, $[[x_1,y_1,\\ldots],[x_2,y_2,\\ldots],\\ldots]$, with no additional text.", "solution": "The problem is valid. It is a well-posed, scientifically grounded problem in computational nuclear physics that requests the derivation and implementation of a standard data analysis procedure. All necessary information is provided, and the tasks are clearly defined.\n\nThe objective is to extract the $s$-wave scattering length, $a$, and effective range, $r_e$, from synthetic phase-shift data, $\\delta_0(k)$, using a weighted least-squares (WLS) fit. This involves linearizing the model provided by the effective range expansion (ERE), performing the fit, and propagating uncertainties to the final physical parameters.\n\n**1. Derivation of the Linear Model and Weights**\n\nThe analysis begins with the effective range expansion for $s$-wave ($l=0$) scattering at low energies, which relates the phase shift $\\delta_0$ at a given relative wave number $k$ to the scattering parameters $a$ and $r_e$:\n$$\nk \\cot \\delta_0(k) = -\\frac{1}{a} + \\frac{1}{2} r_e k^2 + \\mathcal{O}(k^4)\n$$\nFor low energies, the $\\mathcal{O}(k^4)$ and higher terms are negligible. Truncating the series yields a model that is linear in its parameters if we define the variables appropriately. Let us define:\n- An independent variable $x_i = k_i^2$.\n- A dependent variable (observable) $y_i = k_i \\cot \\delta_{0,\\text{meas}}(k_i)$, where $\\delta_{0,\\text{meas}}(k_i)$ is the measured phase shift at wave number $k_i$.\n- Fit parameters $c_0 = -1/a$ and $c_1 = r_e/2$.\n\nWith these definitions, the ERE becomes a linear equation:\n$$\ny_i = c_0 + c_1 x_i\n$$\nThis is a simple linear regression model. We can determine the coefficients $c_0$ and $c_1$ by fitting the transformed data points $(x_i, y_i)$.\n\nTo perform a *weighted* least-squares fit, we need to propagate the uncertainty from the measured phase shifts, $\\delta_{0,i}$, to the transformed observable, $y_i$. The problem states that each measured phase shift $\\delta_{0,i}$ has an associated uncertainty $\\sigma_{\\delta,i}$. Using first-order error propagation, the variance $\\sigma_{y,i}^2$ of $y_i = k_i \\cot \\delta_{0,i}$ is:\n$$\n\\sigma_{y,i}^2 = \\left( \\frac{\\partial y_i}{\\partial \\delta_{0,i}} \\right)^2 \\sigma_{\\delta,i}^2\n$$\nThe derivative is:\n$$\n\\frac{\\partial y_i}{\\partial \\delta_{0,i}} = \\frac{\\partial}{\\partial \\delta_{0,i}} (k_i \\cot \\delta_{0,i}) = k_i (-\\csc^2 \\delta_{0,i}) = -k_i (1 + \\cot^2 \\delta_{0,i})\n$$\nTherefore, the variance is:\n$$\n\\sigma_{y,i}^2 = \\left( -k_i (1 + \\cot^2 \\delta_{0,i}) \\right)^2 \\sigma_{\\delta,i}^2 = k_i^2 (1 + \\cot^2 \\delta_{0,i})^2 \\sigma_{\\delta,i}^2\n$$\nIn practice, we use the measured phase shift $\\delta_{0,\\text{meas}}(k_i)$ to estimate the value of $\\cot \\delta_{0,i}$ in this expression. The weight for each data point $(x_i, y_i)$ in the WLS fit is the inverse of this variance:\n$$\nw_i = \\frac{1}{\\sigma_{y,i}^2} = \\frac{1}{k_i^2 (1 + \\cot^2 \\delta_{0,\\text{meas}}(k_i))^2 \\sigma_{\\delta,i}^2}\n$$\n\n**2. Weighted Least-Squares (WLS) Formalism**\n\nThe WLS method finds the parameter vector $\\mathbf{p} = [c_0, c_1]^T$ that minimizes the chi-squared function, $\\chi^2$:\n$$\n\\chi^2(\\mathbf{p}) = \\sum_{i=1}^{N} w_i (y_i - (c_0 + c_1 x_i))^2\n$$\nwhere $N$ is the number of data points. This can be expressed in matrix form. Let $\\mathbf{y}$ be the $N \\times 1$ vector of observations $[y_1, \\dots, y_N]^T$, $\\mathbf{X}$ be the $N \\times 2$ design matrix, and $\\mathbf{W}$ be the $N \\times N$ diagonal weight matrix.\n$$\n\\mathbf{X} = \\begin{pmatrix} 1  x_1 \\\\ 1  x_2 \\\\ \\vdots  \\vdots \\\\ 1  x_N \\end{pmatrix} = \\begin{pmatrix} 1  k_1^2 \\\\ 1  k_2^2 \\\\ \\vdots  \\vdots \\\\ 1  k_N^2 \\end{pmatrix}, \\quad \\mathbf{W} = \\begin{pmatrix} w_1  0  \\dots \\\\ 0  w_2  \\dots \\\\ \\vdots  \\vdots  \\ddots \\end{pmatrix}\n$$\nThe $\\chi^2$ function is then $\\chi^2 = (\\mathbf{y} - \\mathbf{Xp})^T \\mathbf{W} (\\mathbf{y} - \\mathbf{Xp})$. The minimum is found by solving the normal equations:\n$$\n(\\mathbf{X}^T \\mathbf{W} \\mathbf{X}) \\hat{\\mathbf{p}} = \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$\nThe solution for the estimated parameter vector $\\hat{\\mathbf{p}}$ is:\n$$\n\\hat{\\mathbf{p}} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$\nThis provides the best-fit estimates $\\hat{c}_0$ and $\\hat{c}_1$.\n\n**3. Uncertainty Quantification**\n\nThe covariance matrix for the fitted parameters $\\hat{\\mathbf{p}}$ is given by the inverse of the Hessian matrix of the $\\chi^2$ function:\n$$\n\\mathbf{C}_p = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} = \\begin{pmatrix} \\sigma_{c_0}^2  \\operatorname{cov}(c_0, c_1) \\\\ \\operatorname{cov}(c_0, c_1)  \\sigma_{c_1}^2 \\end{pmatrix}\n$$\nFrom the fit parameters $\\hat{c}_0$ and $\\hat{c}_1$, we obtain the physical parameters $\\hat{a}$ and $\\hat{r}_e$:\n$$\n\\hat{a} = -\\frac{1}{\\hat{c}_0}, \\quad \\hat{r}_e = 2 \\hat{c}_1\n$$\nThe uncertainties in $\\hat{a}$ and $\\hat{r}_e$ are found by propagating the uncertainties from $\\hat{\\mathbf{p}}$ using the covariance matrix $\\mathbf{C}_p$. For $\\hat{a}$:\n$$\n\\sigma_a^2 \\approx \\left( \\frac{\\partial a}{\\partial c_0} \\right)^2 \\sigma_{c_0}^2 = \\left( \\frac{1}{c_0^2} \\right)^2 \\sigma_{c_0}^2 = a^4 \\sigma_{c_0}^2 \\implies \\sigma_a = |\\hat{a}^2| \\sigma_{c_0}\n$$\nFor $\\hat{r}_e$:\n$$\n\\sigma_{r_e}^2 \\approx \\left( \\frac{\\partial r_e}{\\partial c_1} \\right)^2 \\sigma_{c_1}^2 = (2)^2 \\sigma_{c_1}^2 \\implies \\sigma_{r_e} = 2 \\sigma_{c_1}\n$$\nThe covariance between $\\hat{a}$ and $\\hat{r}_e$ is primarily driven by the covariance between $\\hat{c}_0$ and $\\hat{c}_1$, as the transformations are independent:\n$$\n\\operatorname{cov}(a, r_e) \\approx \\frac{\\partial a}{\\partial c_0} \\frac{\\partial r_e}{\\partial c_1} \\operatorname{cov}(c_0, c_1) = \\left(\\frac{1}{c_0^2}\\right) (2) \\operatorname{cov}(c_0, c_1) = 2 a^2 \\operatorname{cov}(c_0, c_1)\n$$\nThe correlation coefficient $\\rho$ is defined as $\\rho = \\frac{\\operatorname{cov}(a, r_e)}{\\sigma_a \\sigma_{r_e}}$. Substituting the derived expressions:\n$$\n\\rho = \\frac{2 a^2 \\operatorname{cov}(c_0, c_1)}{( |a^2| \\sigma_{c_0} ) (2 \\sigma_{c_1})} = \\frac{\\operatorname{cov}(c_0, c_1)}{\\sigma_{c_0} \\sigma_{c_1}} = \\rho_{c_0, c_1}\n$$\nThe correlation coefficient of the physical parameters $(a, r_e)$ is the same as that of the linear fit parameters $(c_0, c_1)$, which can be calculated directly from the covariance matrix $\\mathbf{C}_p$.\n\nA complementary method for assessing uncertainties, robust to model non-linearity and other assumption violations, is the non-parametric bootstrap. This procedure involves:\n1. Creating a large number of resampled datasets by drawing $N$ data points with replacement from the original set of measured pairs $(k_i, \\delta_{0,i})$.\n2. For each resampled dataset, performing the entire WLS analysis to obtain a pair of estimates $(\\hat{a}^*, \\hat{r}_e^*)$.\n3. The collection of these estimates forms an empirical distribution for $(\\hat{a}, \\hat{r}_e)$.\n4. The standard deviations of these distributions serve as robust estimates for $\\sigma_a$ and $\\sigma_{r_e}$, and their sample correlation coefficient provides an estimate for $\\rho$.\nThis method is not implemented here as per the primary requirement, but it represents a standard and powerful validation technique.\n\n**4. Implementation Strategy**\n\nThe Python program will follow these steps for each test case:\n1.  Initialize a random number generator with the specified seed for reproducibility.\n2.  For the given true parameters $(a_{\\text{true}}, r_{e,\\text{true}})$ and wave numbers $\\{k_i\\}$, generate the noiseless phase shifts $\\delta_0(k_i) = \\arctan( k_i / (-1/a_{\\text{true}} + 0.5 r_{e,\\text{true}} k_i^2) )$.\n3.  Add Gaussian noise with mean $0$ and standard deviation $\\sigma_\\delta$ to create the \"measured\" phase shifts $\\delta_{0,\\text{meas}}(k_i)$.\n4.  Transform the data: construct the vector $\\mathbf{y}$ with elements $y_i = k_i \\cot(\\delta_{0,\\text{meas}}(k_i))$ and the design matrix $\\mathbf{X}$ with rows $[1, k_i^2]$.\n5.  Calculate the weights $w_i = 1/\\sigma_{y,i}^2$ using the formula derived above and construct the diagonal weight matrix $\\mathbf{W}$.\n6.  Solve the normal equations $\\hat{\\mathbf{p}} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} (\\mathbf{X}^T \\mathbf{W} \\mathbf{y})$ to find $\\hat{\\mathbf{p}} = [\\hat{c}_0, \\hat{c}_1]^T$. This can be done efficiently by first calculating $\\mathbf{A} = \\mathbf{X}^T \\mathbf{W} \\mathbf{X}$ and $\\mathbf{b} = \\mathbf{X}^T \\mathbf{W} \\mathbf{y}$, then solving the system $\\mathbf{A}\\hat{\\mathbf{p}} = \\mathbf{b}$.\n7.  Calculate the parameter covariance matrix $\\mathbf{C}_p = \\mathbf{A}^{-1}$.\n8.  Convert the fitted parameters to physical parameters: $\\hat{a} = -1/\\hat{c}_0$ and $\\hat{r}_e = 2\\hat{c}_1$.\n9.  Propagate uncertainties to find $\\sigma_a$, $\\sigma_{r_e}$, and the correlation coefficient $\\rho$ using the elements of $\\mathbf{C}_p$.\n10. Store the resulting tuple $(\\hat{a}, \\hat{r}_e, \\sigma_a, \\sigma_{r_e}, \\rho)$ for the final output.\nThis procedure will be repeated for all four test cases provided in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for scattering length and effective range from synthetic phase-shift data\n    using a weighted least-squares fit on the linearized effective range expansion.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"a_true\": 5.0,\n            \"r_e_true\": 1.8,\n            \"k_values\": np.array([0.05, 0.075, 0.10, 0.125, 0.15, 0.175, 0.20, 0.225, 0.25, 0.275, 0.30]),\n            \"sigma_delta\": 0.01,\n            \"seed\": 42,\n        },\n        {\n            \"a_true\": 100.0,\n            \"r_e_true\": 2.0,\n            \"k_values\": np.array([0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 0.11, 0.12]),\n            \"sigma_delta\": 0.005,\n            \"seed\": 123,\n        },\n        {\n            \"a_true\": 5.0,\n            \"r_e_true\": 1.8,\n            \"k_values\": np.array([0.005, 0.008, 0.011, 0.014, 0.017, 0.020]),\n            \"sigma_delta\": 0.005,\n            \"seed\": 2021,\n        },\n        {\n            \"a_true\": -20.0,\n            \"r_e_true\": 2.7,\n            \"k_values\": np.array([0.05, 0.075, 0.10, 0.125, 0.15, 0.175, 0.20, 0.225, 0.25, 0.275, 0.30, 0.325, 0.35, 0.375, 0.40, 0.425, 0.45, 0.475, 0.50]),\n            \"sigma_delta\": 0.02,\n            \"seed\": 7,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        a_true = case[\"a_true\"]\n        r_e_true = case[\"r_e_true\"]\n        k_values = case[\"k_values\"]\n        sigma_delta = case[\"sigma_delta\"]\n        seed = case[\"seed\"]\n\n        # Set random seed for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. Generate synthetic data\n        # Theoretical k*cot(delta)\n        k_cot_delta_true = -1.0 / a_true + 0.5 * r_e_true * k_values**2\n        # Noiseless phase shifts\n        delta_true = np.arctan(k_values / k_cot_delta_true)\n        # Add Gaussian noise to create measured phase shifts\n        noise = rng.normal(0.0, sigma_delta, size=k_values.shape)\n        delta_meas = delta_true + noise\n\n        # 2. Linearize the model for WLS\n        # The model is y = c0 + c1*x, where y = k*cot(delta), x = k^2\n        x = k_values**2\n        cot_delta_meas = 1.0 / np.tan(delta_meas)\n        y = k_values * cot_delta_meas\n\n        # 3. Calculate weights for WLS\n        # sigma_y^2 = (d(k*cot(delta))/d(delta))^2 * sigma_delta^2\n        # d(k*cot(delta))/d(delta) = -k * csc^2(delta) = -k * (1 + cot^2(delta))\n        # We use the measured delta to estimate this.\n        sigma_y_sq = (k_values * (1 + cot_delta_meas**2))**2 * sigma_delta**2\n        weights = 1.0 / sigma_y_sq\n\n        # 4. Perform Weighted Least Squares fit\n        # We solve the normal equations: (X^T W X) p = X^T W y\n        # where p = [c0, c1]^T\n        \n        # Construct the design matrix X\n        X = np.vstack([np.ones_like(x), x]).T\n        \n        # Construct the diagonal weight matrix W\n        W = np.diag(weights)\n\n        # Form the matrices for the normal equations\n        XT_W_X = X.T @ W @ X\n        XT_W_y = X.T @ W @ y\n\n        # Solve for the parameter vector p_hat = [c0, c1]\n        try:\n            p_hat = np.linalg.solve(XT_W_X, XT_W_y)\n        except np.linalg.LinAlgError:\n            # Handle singular matrix case if it ever occurs\n            results.append([np.nan, np.nan, np.nan, np.nan, np.nan])\n            continue\n            \n        c0_fit, c1_fit = p_hat\n\n        # 5. Calculate physical parameters\n        a_fit = -1.0 / c0_fit\n        r_e_fit = 2.0 * c1_fit\n\n        # 6. Quantify uncertainties\n        # Covariance matrix of the fitted parameters p_hat is (X^T W X)^-1\n        cov_p = np.linalg.inv(XT_W_X)\n        sigma_c0_sq, sigma_c1_sq = cov_p[0, 0], cov_p[1, 1]\n        cov_c0_c1 = cov_p[0, 1]\n\n        # Propagate uncertainties to a and r_e\n        # sigma_a^2 = (da/dc0)^2 * sigma_c0^2 = (1/c0^2)^2 * sigma_c0^2 = a^4 * sigma_c0^2\n        sigma_a = np.abs(a_fit**2) * np.sqrt(sigma_c0_sq)\n        \n        # sigma_re^2 = (dre/dc1)^2 * sigma_c1^2 = 2^2 * sigma_c1^2\n        sigma_r_e = 2.0 * np.sqrt(sigma_c1_sq)\n\n        # Correlation coefficient rho(a, r_e) = rho(c0, c1)\n        rho = cov_c0_c1 / np.sqrt(sigma_c0_sq * sigma_c1_sq)\n\n        results.append([a_fit, r_e_fit, sigma_a, sigma_r_e, rho])\n\n    # Final print statement in the exact required format.\n    # The format required is a Python list literal string representation.\n    print(results)\n\nsolve()\n```", "id": "3589013"}]}