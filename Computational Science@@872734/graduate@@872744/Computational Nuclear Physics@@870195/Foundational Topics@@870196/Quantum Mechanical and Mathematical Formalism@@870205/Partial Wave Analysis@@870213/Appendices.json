{"hands_on_practices": [{"introduction": "The starting point of many scattering calculations is an interaction potential that depends on the relative momenta of two particles. To analyze scattering in a specific angular momentum channel, this potential must be projected onto a basis of Legendre polynomials. This exercise [@problem_id:3579009] focuses on this partial-wave projection, a fundamental operation in scattering theory. By implementing a high-precision numerical quadrature and comparing it to an exact analytical solution, you will gain hands-on experience with the core mathematical machinery of partial wave analysis and develop essential skills in numerical error assessment.", "problem": "Consider a computational task in the context of partial wave analysis (PWA) for two-body scattering in momentum space. Let $l \\in \\mathbb{N}_0$ be the orbital angular momentum quantum number, $p \\ge 0$ and $p' \\ge 0$ be magnitudes of incoming and outgoing momenta (treated as dimensionless by suitable scaling), and let $\\alpha  0$ be a dimensionless range parameter. Define the partial-wave projection $V_l(p,p')$ of a spherically symmetric model kernel by\n$$\nV_l(p,p') \\equiv \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, V(p,p',x),\n$$\nwhere $x \\equiv \\cos \\theta$ and $P_l(x)$ is the Legendre polynomial of degree $l$. For this problem, use the smooth, rotationally invariant model\n$$\nV(p,p',x) \\equiv \\exp\\!\\big(-\\alpha\\,[p^2 + p'^2 - 2 p p' x]\\big).\n$$\nYour tasks are:\n- Starting from fundamental definitions of Legendre polynomials, orthogonality on the interval $[-1,1]$, and properties of Gaussian quadrature, derive a closed-form expression for $V_l(p,p')$ in terms of a known special function that can serve as a reference (ground truth) for numerical error assessment. Do not introduce any new assumptions beyond analyticity and spherical symmetry as stated.\n- Implement high-precision Gauss–Legendre quadrature with $N$ nodes to approximate the integral for $V_l(p,p')$:\n$$\nV_l^{(N)}(p,p') \\approx \\sum_{i=1}^{N} w_i \\, P_l(x_i)\\, V(p,p',x_i),\n$$\nwhere $\\{x_i,w_i\\}_{i=1}^N$ are nodes and weights for Gauss–Legendre quadrature on $[-1,1]$.\n- For each test case below, compute the absolute truncation error\n$$\n\\varepsilon \\equiv \\big|V_l^{(N)}(p,p') - V_l(p,p')\\big|,\n$$\nwhere $V_l(p,p')$ is the closed-form reference you derived.\n\nAngle is measured in radians via $x=\\cos\\theta$, but the integral variable is $x$ and no angle conversion is required. All quantities are dimensionless by construction, so no physical units are needed in the final answers.\n\nYou must implement a self-contained program that uses only the specified numerical libraries to compute these errors. Your implementation must be general and applicable for arbitrary admissible parameters.\n\nUse the following test suite, which is designed to cover a general case, oscillatory behavior at higher $l$, a boundary condition, a near-collinear configuration with large effective argument, and a challenging case with relatively small $N$ at large $l$:\n- Case $1$: $l=0$, $p=0.8$, $p'=1.1$, $\\alpha=0.6$, $N=16$.\n- Case $2$: $l=12$, $p=1.0$, $p'=1.0$, $\\alpha=0.4$, $N=32$.\n- Case $3$: $l=5$, $p=0.0$, $p'=1.7$, $\\alpha=0.3$, $N=8$.\n- Case $4$: $l=4$, $p=2.0$, $p'=2.0$, $\\alpha=0.75$, $N=24$.\n- Case $5$: $l=20$, $p=1.5$, $p'=1.5$, $\\alpha=0.2$, $N=12$.\n\nFinal output format:\n- Your program should produce a single line of output containing the absolute errors for the $5$ test cases as a comma-separated list enclosed in square brackets, with each error formatted in scientific notation with $10$ significant digits after the decimal point (for example, 1.2345678900e-06), i.e., exactly of the form $\\big[$error$_1$,error$_2$,error$_3$,error$_4$,error$_5\\big]$ with no spaces.", "solution": "The problem is well-posed, scientifically grounded, and self-contained. All necessary definitions and parameters are provided, and there are no contradictions. We may therefore proceed with a solution.\n\nThe task is to compute the partial-wave projection $V_l(p,p')$ of a specific model kernel, both analytically and numerically, and then determine the absolute error of the numerical approximation for a given set of test cases.\n\nThe partial-wave projection is defined by the integral:\n$$\nV_l(p,p') \\equiv \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, V(p,p',x)\n$$\nwhere $P_l(x)$ is the Legendre polynomial of degree $l$, and the model kernel is given by:\n$$\nV(p,p',x) \\equiv \\exp\\!\\big(-\\alpha\\,[p^2 + p'^2 - 2 p p' x]\\big)\n$$\nAll parameters $l$, $p$, $p'$, and $\\alpha$ are dimensionless quantities.\n\n**1. Derivation of the Closed-Form Expression**\n\nTo derive a closed-form expression for $V_l(p,p')$, we substitute the kernel into the integral definition. We can factor out the terms in the exponential that do not depend on the integration variable $x$:\n$$\nV_l(p,p') = \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, \\exp\\!\\big(-\\alpha(p^2 + p'^2)\\big) \\exp\\!\\big(2 \\alpha p p' x\\big)\n$$\n$$\nV_l(p,p') = \\exp\\big(-\\alpha(p^2 + p'^2)\\big) \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, \\exp\\big( (2 \\alpha p p') x\\big)\n$$\nLet us define the argument of the exponential as $z \\equiv 2\\alpha p p'$. The integral becomes:\n$$\nI_l(z) = \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, e^{zx}\n$$\nThis integral is a standard integral representation related to the modified spherical Bessel functions of the first kind, denoted $i_l(z)$. The function $i_l(z)$ can be defined through the expansion of an exponential in a series of Legendre polynomials:\n$$\ne^{zx} = \\sum_{n=0}^{\\infty} (2n+1) i_n(z) P_n(x)\n$$\nThis series converges uniformly for $x \\in [-1,1]$. We can substitute this expansion into the integral $I_l(z)$, multiply by $P_l(x)$, and integrate over $x \\in [-1,1]$. By leveraging the orthogonality property of Legendre polynomials,\n$$\n\\int_{-1}^{1} P_l(x) P_n(x) \\mathrm{d}x = \\frac{2}{2l+1} \\delta_{ln}\n$$\nwhere $\\delta_{ln}$ is the Kronecker delta, we can determine the integral $I_l(z)$:\n$$\nI_l(z) = \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x) \\sum_{n=0}^{\\infty} (2n+1) i_n(z) P_n(x)\n$$\n$$\nI_l(z) = \\sum_{n=0}^{\\infty} (2n+1) i_n(z) \\int_{-1}^{1} P_l(x) P_n(x) \\mathrm{d}x\n$$\n$$\nI_l(z) = \\sum_{n=0}^{\\infty} (2n+1) i_n(z) \\left(\\frac{2}{2l+1} \\delta_{ln}\\right)\n$$\nThe sum collapses to a single term for $n=l$:\n$$\nI_l(z) = (2l+1) i_l(z) \\left(\\frac{2}{2l+1}\\right) = 2 i_l(z)\n$$\nSubstituting this result back into the expression for $V_l(p,p')$, we obtain the closed-form solution:\n$$\nV_l(p,p') = 2 \\exp\\big(-\\alpha(p^2 + p'^2)\\big) \\, i_l(2 \\alpha p p')\n$$\nThis expression serves as the exact reference value for our error analysis. The function $i_l(z)$ is related to the modified Bessel function of the first kind, $I_{\\nu}(z)$, by $i_l(z) = \\sqrt{\\frac{\\pi}{2z}} I_{l+1/2}(z)$. For computational purposes, we will rely on a high-precision library implementation of $i_l(z)$.\n\nA special case arises when $p=0$ or $p'=0$. In this scenario, the argument $z=2\\alpha p p'$ becomes zero. The integral simplifies to:\n$$\nV_l(p, p')|_{p=0} = \\exp(-\\alpha p'^2) \\int_{-1}^{1} P_l(x) \\mathrm{d}x\n$$\nFrom the orthogonality relation with $P_0(x)=1$, we have $\\int_{-1}^{1} P_l(x) \\mathrm{d}x = 2\\delta_{l0}$. Thus, for $p=0$ or $p'=0$:\n$$\nV_l(p, p') =\n\\begin{cases}\n2 \\exp\\big(-\\alpha(p^2+p'^2)\\big)  \\text{if } l=0 \\\\\n0  \\text{if } l>0\n\\end{cases}\n$$\nThis result is consistent with the closed-form formula, as the behavior of the modified spherical Bessel function near the origin is $i_l(z) \\to \\delta_{l0}$ as $z \\to 0$.\n\n**2. Numerical Approximation via Gauss-Legendre Quadrature**\n\nThe problem specifies using Gauss-Legendre quadrature with $N$ nodes to approximate the integral. The approximation, denoted $V_l^{(N)}(p,p')$, is given by:\n$$\nV_l^{(N)}(p,p') = \\sum_{i=1}^{N} w_i \\, P_l(x_i)\\, V(p,p',x_i)\n$$\nHere, $\\{x_i\\}_{i=1}^N$ are the roots of the Legendre polynomial $P_N(x)$, known as the quadrature nodes, and $\\{w_i\\}_{i=1}^N$ are the corresponding quadrature weights. This method is exact for any polynomial integrand of degree up to $2N-1$. Our integrand, $P_l(x)\\exp(2\\alpha p p' x)$, is not a polynomial, but is analytic and generally smooth. The accuracy of the quadrature depends on how well the integrand can be approximated by a polynomial of degree $2N-1$.\n\nThe algorithmic procedure for the numerical calculation is:\n1.  For a given quadrature order $N$, obtain the set of nodes $\\{x_i\\}$ and weights $\\{w_i\\}$ for the interval $[-1,1]$.\n2.  At each node $x_i$, evaluate the integrand components: the Legendre polynomial $P_l(x_i)$ and the kernel $V(p,p',x_i) = \\exp\\big(-\\alpha(p^2 + p'^2 - 2 p p' x_i)\\big)$.\n3.  Compute the sum of the products of these values with the corresponding weights: $\\sum_{i=1}^{N} w_i P_l(x_i) V(p,p',x_i)$.\n\n**3. Error Calculation and Implementation**\n\nThe absolute truncation error $\\varepsilon$ is the magnitude of the difference between the numerical approximation and the exact analytical solution:\n$$\n\\varepsilon \\equiv \\big|V_l^{(N)}(p,p') - V_l(p,p')\\big|\n$$\nThe implementation will be carried out in Python using the `numpy` and `scipy` libraries.\n- The Gauss-Legendre nodes and weights are computed using `scipy.special.roots_legendre(N)`.\n- The Legendre polynomials $P_l(x_i)$ are evaluated using `scipy.special.eval_legendre(l, nodes)`.\n- The modified spherical Bessel function $i_l(z)$ for the exact solution is computed using `scipy.special.spherical_in(l, z)`.\n\nThe final program will define a function that takes the parameters $(l, p, p', \\alpha, N)$ for a test case, computes both $V_l(p,p')$ and $V_l^{(N)}(p,p')$, calculates the absolute error $\\varepsilon$, and returns it. This function will be applied to each of the specified test cases, and the results will be formatted into a single line of output as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre, eval_legendre, spherical_in\n\ndef solve():\n    \"\"\"\n    Computes the absolute truncation error for the partial-wave projection integral\n    for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (l, p, p_prime, alpha, N)\n        (0, 0.8, 1.1, 0.6, 16),\n        (12, 1.0, 1.0, 0.4, 32),\n        (5, 0.0, 1.7, 0.3, 8),\n        (4, 2.0, 2.0, 0.75, 24),\n        (20, 1.5, 1.5, 0.2, 12),\n    ]\n\n    results = []\n    for l, p, p_prime, alpha, N in test_cases:\n        # Step 1: Calculate the exact analytical solution V_l(p, p')\n        # V_l(p,p') = 2 * exp(-alpha*(p^2 + p'^2)) * i_l(2*alpha*p*p')\n        # where i_l is the modified spherical Bessel function of the first kind.\n        \n        prefactor = 2.0 * np.exp(-alpha * (p**2 + p_prime**2))\n        argument_bessel = 2.0 * alpha * p * p_prime\n        \n        # The scipy function spherical_in correctly handles the z=0 case,\n        # where i_l(0) is 1 for l=0 and 0 for l>0.\n        i_l_val = spherical_in(l, argument_bessel)\n        exact_Vl = prefactor * i_l_val\n\n        # Step 2: Calculate the numerical approximation V_l^(N)(p, p')\n        # using N-point Gauss-Legendre quadrature.\n        \n        # Get Gauss-Legendre nodes (x_i) and weights (w_i) on [-1, 1]\n        nodes, weights = roots_legendre(N)\n        \n        # Evaluate the components of the integrand at the nodes\n        # Legendre polynomials P_l(x_i)\n        legendre_vals = eval_legendre(l, nodes)\n        \n        # Kernel V(p, p', x_i) = exp(-alpha * (p^2 + p'^2 - 2*p*p'*x_i))\n        kernel_vals = np.exp(-alpha * (p**2 + p_prime**2 - 2.0 * p * p_prime * nodes))\n\n        # Compute the quadrature sum\n        numerical_Vl = np.sum(weights * legendre_vals * kernel_vals)\n\n        # Step 3: Compute the absolute truncation error\n        error = np.abs(numerical_Vl - exact_Vl)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.10e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3579009"}, {"introduction": "While potentials are theoretical constructs, phase shifts are observables that can be measured in experiments. A crucial task in nuclear physics is to connect theory to these measurements by extracting fundamental parameters that characterize the nuclear force at low energies. This practice [@problem_id:3579075] delves into the effective range expansion (ERE), a cornerstone of low-energy scattering theory which parameterizes the s-wave phase shift in terms of the scattering length, $a_0$, and effective range, $r_0$. By fitting mock experimental data using statistically sound methods, you will learn how to extract these vital physical parameters and critically assess the systematic uncertainties arising from model truncation.", "problem": "You are given low-energy elastic scattering phase shift data for the s-wave partial wave. Your goal is to construct a statistically principled extraction of the s-wave scattering length $a_{0}$ and effective range $r_{0}$ from phase shift measurements with uncertainties, and to quantify the impact of truncating higher-order shape parameters in the low-energy expansion. Work in units where momentum is measured in inverse femtometers, i.e., $k$ in $\\mathrm{fm}^{-1}$, and lengths such as $a_{0}$ and $r_{0}$ are in femtometers $\\mathrm{fm}$. Angles must be treated in radians.\n\nStarting from fundamental principles in nonrelativistic quantum scattering theory and the analyticity of the on-shell scattering amplitude in the complex energy plane, you must first reason that the s-wave phase shift admits a convergent low-energy expansion in the collision momentum magnitude $k$ that can be organized into a hierarchy. Based solely on these principles and definitions, and without assuming any pre-specified final formulas, carry out the following steps:\n\n1. From the definition of the s-wave phase shift $\\delta_{0}(k)$ and the analyticity of the partial-wave scattering amplitude for short-ranged interactions, derive a low-energy expansion for an observable that is linear in two parameters up to order $k^{2}$ and acquires an additional linear term at order $k^{4}$ when the next higher-order shape parameter is included. Identify how to transform the measured phases into this observable so that a weighted linear regression with known Gaussian errors can be applied. Clearly identify the regression parameters and their mapping to $a_{0}$ and $r_{0}$.\n\n2. Construct a statistically sound estimator under the assumption of independent Gaussian errors in the measured phases with known standard deviations. Use the maximum-likelihood estimator equivalent to weighted least squares. Justify your choice of weights from uncertainty propagation that connects the phase shift uncertainty to the chosen linear observable’s uncertainty. Provide a principled method to propagate parameter uncertainties from the linear fit to uncertainties in $a_{0}$ and $r_{0}$.\n\n3. Fit two models to the provided data:\n   - A truncated model up to order $k^{2}$ (two-parameter fit), from which you extract $a_{0}$ and $r_{0}$.\n   - An extended model up to order $k^{4}$ (three-parameter fit), from which you also extract $a_{0}$ and $r_{0}$ while marginalizing over the additional linear shape parameter.\n   Use the two results to quantify the impact of truncating higher-order terms by comparing the two-parameter and three-parameter estimates of $a_{0}$ and $r_{0}$. Your comparison should be expressed both as absolute differences and as a statistical significance in units of combined standard deviations, i.e., a $z$-score constructed from the two fits’ propagated uncertainties.\n\n4. Physical and numerical units:\n   - Use $k$ in $\\mathrm{fm}^{-1}$.\n   - Use $\\delta$ in radians.\n   - Report $a_{0}$ and $r_{0}$ in $\\mathrm{fm}$.\n   - All intermediate angular quantities must be in radians.\n   - Your final reported numerical values must be rounded to six decimal places.\n\n5. Test suite and required output:\n   Use the following three datasets. In each dataset, the momentum values $k_{i}$ are in $\\mathrm{fm}^{-1}$, the measured s-wave phase shifts $\\delta_{i}$ are in radians, and the one-sigma uncertainties $\\sigma_{\\delta,i}$ are in radians.\n\n   - Dataset A (general low-energy case):\n     - $k = [0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40]$\n     - $\\delta = [0.371000, 0.631000, 0.775000, 0.851000, 0.888000, 0.900000, 0.896000, 0.889000]$\n     - $\\sigma_{\\delta} = [0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000]$\n\n   - Dataset B (near-threshold case with tiny momenta):\n     - $k = [0.01, 0.02, 0.03, 0.04, 0.05]$\n     - $\\delta = [0.020000, 0.040000, 0.059800, 0.079400, 0.099100]$\n     - $\\sigma_{\\delta} = [0.002000, 0.002000, 0.002000, 0.002000, 0.002000]$\n\n   - Dataset C (broader low-energy range where higher orders matter more):\n     - $k = [0.05, 0.10, 0.15, 0.20, 0.30, 0.40, 0.50, 0.60]$\n     - $\\delta = [0.243000, 0.444000, 0.597000, 0.703000, 0.811000, 0.849000, 0.844000, 0.818000]$\n     - $\\sigma_{\\delta} = [0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000]$\n\n   For each dataset, perform both fits (up to order $k^{2}$ and up to order $k^{4}$), propagate uncertainties to obtain uncertainties on $a_{0}$ and $r_{0}$, and then compute the absolute $z$-scores for the differences between the two-parameter and three-parameter estimates of $a_{0}$ and $r_{0}$ using the quadrature sum of their one-sigma standard deviations in the denominator.\n\n   Your program must produce a single line of output containing a list of three sublists, one per dataset, with all numbers rounded to six decimal places. The final output format is a single line: [[a0_k2_A,r0_k2_A,a0_k4_A,r0_k4_A,zA0_A,zR0_A],[...dataset B...],[...dataset C...]]", "solution": "The user has provided a problem in computational nuclear physics concerning the extraction of s-wave scattering parameters from phase shift data. The solution requires deriving the relevant physical model from first principles, formulating a statistically sound fitting procedure, and applying it to multiple datasets to assess the impact of model truncation.\n\nThe problem is validated as scientifically sound, well-posed, objective, and self-contained. It is a standard, non-trivial exercise in partial wave analysis rooted in fundamental quantum mechanics and statistical data analysis. We may therefore proceed with a full solution.\n\nThe solution is presented in three parts:\n1.  Derivation of the effective range expansion (ERE) as the theoretical model.\n2.  Formulation of the weighted least-squares fitting procedure and error propagation.\n3.  Specification of the computational protocol for model fitting and comparison.\n\n### 1. Theoretical Foundation: The Effective Range Expansion\n\nThe foundation of low-energy scattering theory for short-ranged interactions is the analyticity of the scattering amplitude. For the s-wave ($l=0$) partial wave, the scattering matrix element $S_0(k)$ is related to the phase shift $\\delta_0(k)$ by $S_0(k) = e^{2i\\delta_0(k)}$, where $k$ is the magnitude of the relative momentum.\n\nThe partial wave scattering amplitude, $f_0(k)$, is defined as:\n$$f_0(k) = \\frac{S_0(k) - 1}{2ik} = \\frac{e^{2i\\delta_0(k)} - 1}{2ik} = \\frac{e^{i\\delta_0(k)}(e^{i\\delta_0(k)} - e^{-i\\delta_0(k)})}{2ik} = \\frac{e^{i\\delta_0(k)}\\sin\\delta_0(k)}{k}$$\nThis expression can be inverted to relate $f_0(k)$ to the phase shift via the function $\\cot\\delta_0(k)$:\n$$f_0(k) = \\frac{1}{k \\cot\\delta_0(k) - ik}$$\nA fundamental result of scattering theory, established by Bethe, is that for short-range potentials, the function $k\\cot\\delta_0(k)$ is an analytic function of energy $E \\propto k^2$. Consequently, it admits a convergent Taylor series expansion in powers of $k^2$ around $k=0$. This is known as the Effective Range Expansion (ERE):\n$$k\\cot\\delta_0(k) = c_0 + c_1 k^2 + c_2 k^4 + O(k^6)$$\nThe coefficients of this expansion define the low-energy scattering parameters. The s-wave scattering length, $a_0$, is defined from the zero-energy limit:\n$$\\lim_{k \\to 0} (-k \\cot\\delta_0(k)) = \\frac{1}{a_0}$$\nThis implies the leading coefficient is $c_0 = -1/a_0$. The next coefficient defines the effective range, $r_0$:\n$$c_1 = \\frac{1}{2}r_0$$\nHigher-order terms define shape parameters. A common convention sets the $k^4$ coefficient as $c_2 = -P_0 r_0^3$, where $P_0$ is the first shape parameter. The ERE can thus be written as:\n$$k\\cot\\delta_0(k) = -\\frac{1}{a_0} + \\frac{1}{2}r_0k^2 - P_0 r_0^3 k^4 + O(k^6)$$\nThis equation provides the basis for a linear regression analysis. Let us define an observable $y(k) = k\\cot\\delta_0(k)$ and an independent variable $x = k^2$. The ERE can then be cast into linear models.\n\n-   **Truncated Model (Order $k^2$):** By truncating the series at order $k^2$, we obtain a two-parameter linear model:\n    $$y(k) \\approx \\beta_0 + \\beta_1 x \\quad \\text{where} \\quad x=k^2$$\n    The regression parameters are directly related to the physical parameters: $\\beta_0 = -1/a_0$ and $\\beta_1 = r_0/2$.\n\n-   **Extended Model (Order $k^4$):** Including the next term gives a three-parameter linear model:\n    $$y(k) \\approx \\beta_0 + \\beta_1 x + \\beta_2 x^2 \\quad \\text{where} \\quad x=k^2$$\n    Here, $\\beta_0 = -1/a_0$, $\\beta_1 = r_0/2$, and $\\beta_2 = -P_0 r_0^3$. The goal is to extract $a_0$ and $r_0$ from $\\beta_0$ and $\\beta_1$, treating $\\beta_2$ as a parameter to be determined by the fit.\n\n### 2. Statistical Methodology and Uncertainty Propagation\n\nWe are given $N$ data points $(k_i, \\delta_i)$ with uncertainties $\\sigma_{\\delta,i}$ on the phase shifts. To perform a linear fit, we first transform these into data points for our linear model: $(x_i, y_i) = (k_i^2, k_i\\cot\\delta_i)$.\n\nThe uncertainties must be propagated from $\\delta_i$ to $y_i$. Using the first-order Taylor expansion for error propagation, the variance of $y_i$, denoted $\\sigma_{y,i}^2$, is:\n$$\\sigma_{y,i}^2 \\approx \\left( \\frac{\\partial y_i}{\\partial \\delta_i} \\right)^2 \\sigma_{\\delta,i}^2$$\nThe derivative is $\\frac{\\partial}{\\partial\\delta}(k\\cot\\delta) = -k\\csc^2\\delta = -k/\\sin^2\\delta$. Therefore, the variance on each $y_i$ is:\n$$\\sigma_{y,i}^2 = \\left( \\frac{-k_i}{\\sin^2\\delta_i} \\right)^2 \\sigma_{\\delta,i}^2 = \\frac{k_i^2}{(\\sin^2\\delta_i)^2} \\sigma_{\\delta,i}^2$$\nAssuming the measurement errors $\\sigma_{\\delta,i}$ are Gaussian and independent, the best linear unbiased estimator for the parameters $\\beta$ is obtained by minimizing the $\\chi^2$ statistic via weighted least squares (WLS). The $\\chi^2$ is defined as:\n$$\\chi^2 = \\sum_{i=1}^{N} \\left( \\frac{y_i - f(x_i; \\beta)}{\\sigma_{y,i}} \\right)^2 = \\sum_{i=1}^{N} w_i \\left(y_i - \\sum_{j=0}^{m-1} \\beta_j X_{ij}\\right)^2$$\nwhere $f(x_i; \\beta)$ is the linear model, $w_i = 1/\\sigma_{y,i}^2$ are the weights, and $X$ is the design matrix whose elements $X_{ij}$ are the basis functions evaluated at data point $i$. For the $k^4$ model, $X_{i0}=1$, $X_{i1}=k_i^2$, $X_{i2}=k_i^4$.\n\nIn matrix form, the solution that minimizes $\\chi^2$ is:\n$$\\hat{\\beta} = (X^T W X)^{-1} X^T W y$$\nHere, $\\hat{\\beta}$ is the vector of estimated parameters, $y$ is the column vector of the observed $y_i$ values, and $W$ is a diagonal matrix with $W_{ii} = w_i$.\n\nThe covariance matrix of the estimated parameters $\\hat{\\beta}$ is given by:\n$$C_{\\beta} = (X^T W X)^{-1}$$\nThe variance of each parameter, $\\sigma_{\\beta_j}^2$, is the $j$-th diagonal element of this matrix, i.e., $\\sigma_{\\beta_j}^2 = (C_{\\beta})_{jj}$.\n\nFinally, the uncertainties on the physical parameters $a_0$ and $r_0$ are obtained by propagating the uncertainties from $\\hat{\\beta}_0$ and $\\hat{\\beta}_1$:\n-   For $a_0 = -1/\\beta_0$:\n    $$\\sigma_{a_0}^2 = \\left( \\frac{\\partial a_0}{\\partial \\beta_0} \\right)^2 \\sigma_{\\beta_0}^2 = \\left( \\frac{1}{\\beta_0^2} \\right)^2 \\sigma_{\\beta_0}^2 = \\frac{\\sigma_{\\beta_0}^2}{\\beta_0^4} = a_0^4 \\sigma_{\\beta_0}^2 \\implies \\sigma_{a_0} = a_0^2 \\sigma_{\\beta_0}$$\n-   For $r_0 = 2\\beta_1$:\n    $$\\sigma_{r_0}^2 = \\left( \\frac{\\partial r_0}{\\partial \\beta_1} \\right)^2 \\sigma_{\\beta_1}^2 = (2)^2 \\sigma_{\\beta_1}^2 = 4\\sigma_{\\beta_1}^2 \\implies \\sigma_{r_0} = 2\\sigma_{\\beta_1}$$\n\n### 3. Computational Protocol and Model Comparison\n\nFor each dataset provided, the following protocol is executed:\n1.  **Data Transformation:** Compute $y_i = k_i\\cot\\delta_i$ and the corresponding weights $w_i = (\\sin^2\\delta_i / (k_i \\sigma_{\\delta,i}))^2$ for all data points.\n2.  **Fit Order-$k^2$ Model:**\n    -   Construct the design matrix $X^{(2)}$ with columns for basis functions $1$ and $k^2$.\n    -   Compute $\\hat{\\beta}^{(k^2)}$ and its covariance matrix $C_{\\beta}^{(k^2)}$ using the WLS formulas.\n    -   Calculate $a_0^{(k^2)} = -1/\\hat{\\beta}_0^{(k^2)}$, $r_0^{(k^2)} = 2\\hat{\\beta}_1^{(k^2)}$, and their uncertainties $\\sigma_{a_0}^{(k^2)}$ and $\\sigma_{r_0}^{(k^2)}$.\n3.  **Fit Order-$k^4$ Model:**\n    -   Construct the design matrix $X^{(4)}$ with columns for basis functions $1$, $k^2$, and $k^4$.\n    -   Compute $\\hat{\\beta}^{(k^4)}$ and its covariance matrix $C_{\\beta}^{(k^4)}$.\n    -   Calculate $a_0^{(k^4)} = -1/\\hat{\\beta}_0^{(k^4)}$, $r_0^{(k^4)} = 2\\hat{\\beta}_1^{(k^4)}$, and their uncertainties $\\sigma_{a_0}^{(k^4)}$ and $\\sigma_{r_0}^{(k^4)}$ using the variances of the first two parameters from $C_{\\beta}^{(k^4)}$.\n4.  **Model Comparison:** To quantify the systematic uncertainty introduced by truncating the ERE, we compute the statistical significance of the difference between the parameters extracted from the two models. This is done via a z-score, defined as the absolute difference between the two estimates divided by their combined uncertainty (added in quadrature):\n    $$z_{a_0} = \\frac{|a_0^{(k^2)} - a_0^{(k^4)}|}{\\sqrt{(\\sigma_{a_0}^{(k^2)})^2 + (\\sigma_{a_0}^{(k^4)})^2}}$$\n    $$z_{r_0} = \\frac{|r_0^{(k^2)} - r_0^{(k^4)}|}{\\sqrt{(\\sigma_{r_0}^{(k^2)})^2 + (\\sigma_{r_0}^{(k^4)})^2}}$$\nA large z-score (e.g., $z > 2$) suggests that the higher-order $k^4$ term is statistically significant and that the truncated model is inadequate for the given data range. A small z-score implies that the simpler model is sufficient and the data do not provide enough information to resolve the higher-order terms. This entire procedure will be implemented numerically for each of the three datasets provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all datasets and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Dataset A (general low-energy case)\n        {\n            \"k\": [0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40],\n            \"delta\": [0.371000, 0.631000, 0.775000, 0.851000, 0.888000, 0.900000, 0.896000, 0.889000],\n            \"sigma_delta\": [0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000]\n        },\n        # Dataset B (near-threshold case with tiny momenta)\n        {\n            \"k\": [0.01, 0.02, 0.03, 0.04, 0.05],\n            \"delta\": [0.020000, 0.040000, 0.059800, 0.079400, 0.099100],\n            \"sigma_delta\": [0.002000, 0.002000, 0.002000, 0.002000, 0.002000]\n        },\n        # Dataset C (broader low-energy range where higher orders matter more)\n        {\n            \"k\": [0.05, 0.10, 0.15, 0.20, 0.30, 0.40, 0.50, 0.60],\n            \"delta\": [0.243000, 0.444000, 0.597000, 0.703000, 0.811000, 0.849000, 0.844000, 0.818000],\n            \"sigma_delta\": [0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = _solve_for_dataset(case[\"k\"], case[\"delta\"], case[\"sigma_delta\"])\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    # [[a0_k2_A,r0_k2_A,a0_k4_A,r0_k4_A,zA0_A,zR0_A],[...B...],[...C...]]\n    formatted_sublists = []\n    for res_list in all_results:\n        # Round each number to six decimal places\n        formatted_numbers = [f\"{x:.6f}\" for x in res_list]\n        formatted_sublists.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_sublists)}]\"\n    print(final_output_string)\n\ndef _solve_for_dataset(k_vals, delta_vals, sigma_delta_vals):\n    \"\"\"\n    Performs the effective range expansion analysis for a single dataset.\n    \n    Args:\n        k_vals (list): Momenta in fm^-1.\n        delta_vals (list): Phase shifts in radians.\n        sigma_delta_vals (list): Uncertainties on phase shifts in radians.\n        \n    Returns:\n        list: A list containing [a0_k2, r0_k2, a0_k4, r0_k4, z_a0, z_r0].\n    \"\"\"\n    k = np.array(k_vals)\n    delta = np.array(delta_vals)\n    sigma_delta = np.array(sigma_delta_vals)\n    \n    # 1. Transform data and propagate uncertainties\n    # y = k * cot(delta)\n    y = k / np.tan(delta)\n    \n    # Uncertainty propagation: sigma_y^2 = (dy/d_delta)^2 * sigma_delta^2\n    # dy/d_delta = -k / sin^2(delta)\n    dyd_delta = -k / (np.sin(delta)**2)\n    sigma_y_sq = (dyd_delta**2) * (sigma_delta**2)\n    \n    # Weights for WLS: w = 1 / sigma_y^2\n    weights = 1.0 / sigma_y_sq\n    W = np.diag(weights)\n    \n    # --- 2. Fit truncated model (order k^2) ---\n    # Model: y = beta_0 + beta_1 * k^2\n    X2 = np.vstack([np.ones_like(k), k**2]).T\n    \n    # WLS solution: beta = (X^T W X)^-1 X^T W y\n    # Covariance matrix: C_beta = (X^T W X)^-1\n    XTWX2 = X2.T @ W @ X2\n    XTWy2 = X2.T @ W @ y\n    \n    C_beta2 = np.linalg.inv(XTWX2)\n    beta_hat2 = C_beta2 @ XTWy2\n    \n    beta0_k2, beta1_k2 = beta_hat2\n    var_beta0_k2, var_beta1_k2 = np.diag(C_beta2)\n    \n    # Extract physical parameters and propagate errors\n    a0_k2 = -1.0 / beta0_k2\n    r0_k2 = 2.0 * beta1_k2\n    \n    sigma_a0_k2 = np.abs(a0_k2**2) * np.sqrt(var_beta0_k2)\n    sigma_r0_k2 = 2.0 * np.sqrt(var_beta1_k2)\n\n    # --- 3. Fit extended model (order k^4) ---\n    # Model: y = beta_0 + beta_1 * k^2 + beta_2 * k^4\n    X4 = np.vstack([np.ones_like(k), k**2, k**4]).T\n    \n    XTWX4 = X4.T @ W @ X4\n    XTWy4 = X4.T @ W @ y\n    \n    C_beta4 = np.linalg.inv(XTWX4)\n    beta_hat4 = C_beta4 @ XTWy4\n    \n    beta0_k4, beta1_k4, _ = beta_hat4\n    var_beta0_k4, var_beta1_k4, _ = np.diag(C_beta4)\n    \n    # Extract physical parameters and propagate errors\n    a0_k4 = -1.0 / beta0_k4\n    r0_k4 = 2.0 * beta1_k4\n    \n    sigma_a0_k4 = np.abs(a0_k4**2) * np.sqrt(var_beta0_k4)\n    sigma_r0_k4 = 2.0 * np.sqrt(var_beta1_k4)\n\n    # --- 4. Calculate z-scores for comparison ---\n    # z = |val1 - val2| / sqrt(sigma1^2 + sigma2^2)\n    z_a0 = np.abs(a0_k2 - a0_k4) / np.sqrt(sigma_a0_k2**2 + sigma_a0_k4**2)\n    z_r0 = np.abs(r0_k2 - r0_k4) / np.sqrt(sigma_r0_k2**2 + sigma_r0_k4**2)\n    \n    return [a0_k2, r0_k2, a0_k4, r0_k4, z_a0, z_r0]\n\nsolve()\n```", "id": "3579075"}, {"introduction": "The mathematical formalism of partial wave analysis does more than just describe scattering data; it reveals deep connections between the low-energy behavior of phase shifts and the analytic structure of the scattering amplitude. This exercise [@problem_id:3578992] uses the effective range expansion as a simple model to explore the physical implications of a pole on the negative imaginary momentum axis, which signifies a \"virtual state.\" Through this, you will numerically verify the modified Levinson's theorem, deepening your understanding of the profound physics encoded within the analytic properties of the S-matrix and its connection to near-threshold phenomena.", "problem": "Consider spinless elastic nucleon-nucleon scattering in the central $S$-wave channel within the framework of partial wave analysis. Work in natural units where the reduced mass does not explicitly appear, and use the low-energy effective range expansion as the computational model for the $S$-wave. The model assumptions and definitions are as follows.\n\n1. The $S$-matrix for the $S$-wave is defined by $S_{0}(k) = \\exp\\!\\left(2 i \\delta_{0}(k)\\right)$, where $\\delta_{0}(k)$ is the $S$-wave phase shift as a function of the on-shell wave number $k$.\n2. The $S$-wave scattering amplitude is related to the phase shift by\n$$\nf_{0}(k) \\;=\\; \\frac{1}{k \\cot \\delta_{0}(k) - i k},\n$$\nwhich is a standard consequence of unitarity and analyticity for short-range potentials.\n3. At sufficiently low energies, the $S$-wave phase shift obeys the effective range expansion\n$$\nk \\cot \\delta_{0}(k) \\;=\\; -\\frac{1}{a} + \\frac{r_{e}}{2}\\,k^{2} + \\mathcal{O}(k^{4}),\n$$\nwhere $a$ is the scattering length and $r_{e}$ is the effective range. Throughout this problem, neglect $\\mathcal{O}(k^{4})$ and higher terms.\n\nUse this model to explore virtual-state effects associated with poles on the negative imaginary $k$ axis and to numerically verify the modified Levinson relation near threshold. A virtual state corresponds to a pole of $f_{0}(k)$ at $k = - i \\kappa$ with $\\kappa  0$, while a bound state corresponds to a pole at $k = + i \\kappa$ with $\\kappa  0$. For short-range interactions, assume the high-energy limit satisfies $\\delta_{0}(\\infty) = 0$.\n\nYour tasks:\n\nA. For given parameters $(a, r_{e})$, compute a numerically stable estimate of the threshold phase shift $\\delta_{0}(0)$ in radians by evaluating $\\delta_{0}(k)$ on a logarithmic grid of $k$ values approaching $k \\to 0^{+}$ and taking the limiting value. Specifically, use the principal-branch representation\n$$\n\\delta_{0}(k) \\;=\\; \\arctan2\\!\\left(k,\\, -\\frac{1}{a} + \\frac{r_{e}}{2}\\,k^{2}\\right),\n$$\nand approximate $\\delta_{0}(0)$ by the value at the smallest $k$ on your grid. Use a logarithmically spaced grid $k \\in [10^{-6},\\,10^{-2}]$ in inverse femtometers (fm$^{-1}$), with angles in radians. For the special case of infinite scattering length (i.e., $a = \\infty$ so that $1/a = 0$), interpret the formula by taking the limit $-1/a \\to 0$ exactly.\n\nB. Using the same parameters $(a, r_{e})$, compute the virtual-state pole position by solving for $\\kappa  0$ in\n$$\n\\frac{r_{e}}{2}\\,\\kappa^{2} + \\kappa + \\frac{1}{a} \\;=\\; 0,\n$$\nwhich follows from the pole condition $k \\cot \\delta_{0}(k) - i k = 0$ evaluated at $k = - i \\kappa$. If $a = \\infty$, take $\\kappa = 0$ for the near-threshold half-bound case. Report $\\kappa$ in fm$^{-1}$.\n\nC. Define\n$$\n\\Delta \\;\\equiv\\; \\delta_{0}(0) - \\delta_{0}(\\infty),\n$$\nand, under the short-range assumption $\\delta_{0}(\\infty) = 0$, compute $m \\equiv \\Delta/\\pi$. According to the modified Levinson relation for short-range interactions, $m$ should approach $0$ for a pure virtual-state scenario without bound states, and $m$ should approach $1/2$ in the presence of a zero-energy half-bound state (infinite scattering length). Numerically verify these behaviors.\n\nPhysical and numerical units:\n- Wave number $k$ and the pole location $\\kappa$ must be expressed in inverse femtometers (fm$^{-1}$).\n- Phase shifts must be expressed in radians.\n- Angles are to be handled in radians throughout.\n\nTest suite:\nEvaluate and report results for the following three parameter sets, chosen to probe different near-threshold behaviors:\n1. $(a, r_{e}) = (-2.0\\,\\text{fm},\\, 2.5\\,\\text{fm})$.\n2. $(a, r_{e}) = (-20.0\\,\\text{fm},\\, 2.5\\,\\text{fm})$.\n3. $(a, r_{e}) = (\\infty,\\, 2.5\\,\\text{fm})$.\n\nFor each test case $i \\in \\{1,2,3\\}$, your program must compute:\n- $m_{i} = \\Delta_{i}/\\pi$ as a floating-point number,\n- $\\kappa_{i}$ in fm$^{-1}$ as a floating-point number.\n\nFinal output format:\nYour program should produce a single line of output containing the six results in the order $[m_{1}, \\kappa_{1}, m_{2}, \\kappa_{2}, m_{3}, \\kappa_{3}]$, as a comma-separated list enclosed in square brackets. Each floating-point number must be rounded to six decimal places. For example: [0.000000,0.123456,0.500000,0.000000,0.000000,0.987654].", "solution": "The problem is well-posed, scientifically sound, and internally consistent. It provides a standard exercise in computational quantum scattering theory, specifically focusing on the low-energy effective range expansion for $S$-wave nucleon-nucleon scattering. The tasks involve calculating the position of a virtual state pole and verifying the modified Levinson's theorem for different scattering parameter regimes. We may proceed with a complete solution.\n\nThe theoretical framework is the low-energy effective range expansion (ERE) for the $S$-wave (orbital angular momentum $l=0$) phase shift, $\\delta_{0}(k)$, where $k$ is the on-shell wave number. The core relation, neglecting terms of order $\\mathcal{O}(k^4)$ and higher, is\n$$\nk \\cot \\delta_{0}(k) = -\\frac{1}{a} + \\frac{r_{e}}{2}\\,k^{2}\n$$\nHere, $a$ is the $S$-wave scattering length and $r_{e}$ is the effective range. The $S$-wave scattering amplitude, $f_{0}(k)$, is given by\n$$\nf_{0}(k) = \\frac{1}{k \\cot \\delta_{0}(k) - i k}\n$$\nPoles of the scattering amplitude in the complex $k$-plane have profound physical significance. A virtual state is characterized by a pole on the negative imaginary axis, $k = -i\\kappa$ with $\\kappa  0$. The pole condition is that the denominator of $f_0(k)$ vanishes. Substituting the ERE and $k = -i\\kappa$ into this condition, $k \\cot \\delta_{0}(k) - ik = 0$, yields:\n$$\n\\left(-\\frac{1}{a} + \\frac{r_{e}}{2}(-i\\kappa)^{2}\\right) - i(-i\\kappa) = 0\n$$\n$$\n-\\frac{1}{a} - \\frac{r_{e}}{2}\\kappa^{2} - \\kappa = 0\n$$\nMultiplying by $-1$ gives the quadratic equation for the virtual state pole position $\\kappa$:\n$$\n\\frac{r_{e}}{2}\\kappa^{2} + \\kappa + \\frac{1}{a} = 0\n$$\nWe must solve this equation for each parameter set $(a, r_e)$ to find $\\kappa_i$.\n\nThe second part of the problem involves the modified Levinson's theorem, which relates the behavior of the phase shift to the number of bound and half-bound states. We are asked to compute $m = \\Delta/\\pi$, where $\\Delta = \\delta_{0}(0) - \\delta_{0}(\\infty)$. Given the short-range interaction assumption $\\delta_{0}(\\infty) = 0$, this simplifies to $m = \\delta_0(0)/\\pi$. The value of $m$ is expected to be $0$ in the absence of bound states (as is the case for a virtual state scenario with $a0$) and $1/2$ in the presence of a zero-energy half-bound state (the case where $a=\\infty$).\n\nTo compute $\\delta_0(0)$, we use the provided principal-branch representation:\n$$\n\\delta_{0}(k) = \\arctan2\\!\\left(y, x\\right) \\quad \\text{with} \\quad y=k, \\quad x = k \\cot \\delta_{0}(k) = -\\frac{1}{a} + \\frac{r_{e}}{2}\\,k^{2}\n$$\nWe numerically approximate $\\delta_0(0)$ by evaluating $\\delta_0(k)$ at a very small wave number, $k_{min} = 10^{-6}\\,\\text{fm}^{-1}$.\n\nThe computational procedure for each test case $(a_i, r_{ei})$ is as follows:\n\n1.  **Compute the virtual-state pole position $\\kappa_i$**:\n    For finite $a  0$, we solve the quadratic equation $A\\kappa^2 + B\\kappa + C = 0$ with $A = r_e/2$, $B=1$, and $C=1/a$. Since $r_e  0$ and $a  0$, the discriminant $B^2 - 4AC = 1 - 2r_e/a$ is greater than $1$, guaranteeing two real roots. The physical solution must have $\\kappa  0$, which corresponds to the root:\n    $$\n    \\kappa = \\frac{-1 + \\sqrt{1 - 2r_{e}/a}}{r_{e}}\n    $$\n    For the special case $a = \\infty$, the problem specifies to take $\\kappa = 0$, which is consistent with the quadratic equation where $1/a \\to 0$.\n\n2.  **Compute the Levinson relation parameter $m_i$**:\n    First, we approximate $\\delta_0(0)$. We evaluate $\\delta_0(k_{min})$ using the `arctan2` function with arguments $y = k_{min}$ and $x = -1/a + (r_e/2)k_{min}^2$.\n    -   For $a  0$, as $k_{min} \\to 0$, $y \\to 0^+$ and $x \\to -1/a  0$. Thus, $\\delta_0(0) = \\arctan2(0^+, \\text{positive}) = 0$. The numerical evaluation at small $k_{min}$ will yield a value very close to $0$.\n    -   For $a = \\infty$, as $k_{min} \\to 0$, $y \\to 0^+$ and $x = (r_e/2)k_{min}^2 \\to 0^+$. The ratio $y/x = 2/(r_e k_{min})$ tends to $+\\infty$. This means the angle approaches $\\pi/2$. Thus, $\\delta_0(0) = \\pi/2$. The numerical evaluation will yield a value very close to $\\pi/2$.\n    Finally, we compute $m_i = \\delta_0(k_{min}) / \\pi$. Based on the analysis above, we expect $m_i \\approx 0$ for the cases with $a  0$ and $m_i \\approx 0.5$ for the case with $a = \\infty$.\n\nThis procedure is applied to the three specified test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational nuclear physics problem for three test cases.\n    For each case (a, r_e), it computes the Levinson parameter m and the\n    virtual-state pole position kappa.\n    \"\"\"\n\n    def calculate_values(a, re):\n        \"\"\"\n        Calculates m and kappa for a given scattering length 'a' and effective range 're'.\n\n        Args:\n            a (float): The scattering length in fm. Can be np.inf.\n            re (float): The effective range in fm.\n\n        Returns:\n            tuple: A tuple containing (m, kappa).\n        \"\"\"\n        # Task A  C: Compute m = delta_0(0) / pi\n        # We approximate delta_0(0) by evaluating at a small k.\n        k_min = 1e-6  # fm^-1\n\n        if np.isinf(a):\n            inv_a = 0.0\n        else:\n            inv_a = 1.0 / a\n        \n        # Arguments for arctan2(y, x) where y = k and x = k*cot(delta_0)\n        x_arg = -inv_a + 0.5 * re * k_min**2\n        y_arg = k_min\n        delta_0_at_0_approx = np.arctan2(y_arg, x_arg)\n        \n        m = delta_0_at_0_approx / np.pi\n\n        # Task B: Compute the virtual-state pole position kappa\n        # This involves solving the quadratic equation: (re/2)*kappa^2 + kappa + 1/a = 0\n        kappa = 0.0\n        if np.isinf(a):\n            # For infinite scattering length, the pole is at zero energy (half-bound state).\n            kappa = 0.0\n        else:\n            # For a finite scattering length, solve the quadratic equation for kappa > 0.\n            # The general solution is kappa = (-1 +/- sqrt(1 - 2*re/a)) / re.\n            # For a virtual state (a  0), the discriminant is > 1.\n            # We select the '+' sign to ensure kappa > 0.\n            discriminant = 1.0 - 2.0 * re / a\n            if discriminant >= 0:\n                kappa = (-1.0 + np.sqrt(discriminant)) / re\n            else:\n                # This case (complex kappa) would not correspond to a simple virtual or bound state\n                # on the imaginary axis, and is not expected for the given problem parameters.\n                kappa = np.nan\n\n        return m, kappa\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (-2.0, 2.5),       # Case 1: (a, r_e) in fm\n        (-20.0, 2.5),      # Case 2\n        (np.inf, 2.5),     # Case 3: Infinite scattering length\n    ]\n\n    results = []\n    for case in test_cases:\n        a_val, re_val = case\n        m_val, kappa_val = calculate_values(a_val, re_val)\n        \n        # Append formatted results to the list\n        results.append(f\"{m_val:.6f}\")\n        results.append(f\"{kappa_val:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3578992"}]}