{"hands_on_practices": [{"introduction": "The evaluation of matrix elements for two-body interactions often involves integrals over products of spherical harmonics. This exercise provides a foundational link between this geometric picture and the algebraic framework of angular momentum coupling [@problem_id:3541865]. By calculating a specific Gaunt coefficient using Clebsch-Gordan coefficients, you will reinforce your understanding of the selection rules and see how symmetry principles reduce complex integrals to algebraic quantities.", "problem": "In computational nuclear physics, two-body operators and mean fields are often expressed in a spherical-tensor basis, which reduces many angular integrations to integrals over products of spherical harmonics. Define the Gaunt coefficient for complex spherical harmonics with the Condon–Shortley phase convention as\n$$\nG(\\ell_{1} m_{1};\\, \\ell_{2} m_{2};\\, \\ell_{3} m_{3}) \\equiv \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{\\pi} Y_{\\ell_{1} m_{1}}(\\theta,\\phi)\\,Y_{\\ell_{2} m_{2}}(\\theta,\\phi)\\,Y_{\\ell_{3} m_{3}}(\\theta,\\phi)\\,\\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi,\n$$\nwith the orthonormality convention\n$$\n\\int Y_{\\ell m}^{*}(\\Omega)\\,Y_{\\ell' m'}(\\Omega)\\,\\mathrm{d}\\Omega \\;=\\; \\delta_{\\ell \\ell'}\\,\\delta_{m m'}.\n$$\nStarting from the definition of spherical harmonics as components of irreducible spherical tensors under rotations and the standard properties of Clebsch–Gordan coefficients (CGC), compute the specific Gaunt coefficient\n$$\nG(1\\,1;\\,1\\,{-}1;\\,2\\,0).\n$$\nAs part of your derivation, explicitly justify the triangular selection rule in $\\ell$ and the $m$-sum selection rule for this case. Express your final answer as an exact closed-form expression. Do not round. No units are required.", "solution": "The problem asks for the computation of a specific Gaunt coefficient, $G(1\\,1;\\,1\\,{-}1;\\,2\\,0)$, using the properties of spherical harmonics as irreducible spherical tensors and the algebra of Clebsch–Gordan coefficients.\n\nThe Gaunt coefficient is defined as the integral of the product of three complex spherical harmonics over the solid angle $\\Omega$:\n$$\nG(\\ell_{1} m_{1};\\, \\ell_{2} m_{2};\\, \\ell_{3} m_{3}) \\equiv \\int Y_{\\ell_{1} m_{1}}(\\Omega)\\,Y_{\\ell_{2} m_{2}}(\\Omega)\\,Y_{\\ell_{3} m_{3}}(\\Omega)\\,\\mathrm{d}\\Omega\n$$\nThis integral represents a scalar quantity, as it is the integral over all space of a product of functions that transform in specific ways under rotation. For the integral to be non-zero, the integrand itself must transform as a scalar, i.e., it must be invariant under rotations. This rotational invariance imposes several selection rules on the quantum numbers $\\ell_i$ and $m_i$.\n\nFirst, we justify the selection rules as requested:\n1.  **The $m$-sum selection rule**: Consider a rotation of the coordinate system by an angle $\\alpha$ about the $z$-axis. Under such a rotation, a spherical harmonic $Y_{\\ell m}(\\theta, \\phi)$ transforms as $Y_{\\ell m} \\rightarrow \\exp(im\\alpha) Y_{\\ell m}$. The product of three spherical harmonics thus transforms as:\n    $$\n    Y_{\\ell_{1} m_{1}} Y_{\\ell_{2} m_{2}} Y_{\\ell_{3} m_{3}} \\rightarrow \\exp(i(m_1+m_2+m_3)\\alpha) Y_{\\ell_{1} m_{1}} Y_{\\ell_{2} m_{2}} Y_{\\ell_{3} m_{3}}\n    $$\n    Since the integral is a scalar, it must be independent of the coordinate system's orientation. Therefore, the integrand must be invariant under this rotation, which requires the phase factor to be unity for any arbitrary angle $\\alpha$. This holds true only if $m_1 + m_2 + m_3 = 0$. For the specific case of $G(1\\,1;\\,1\\,{-}1;\\,2\\,0)$, we have $m_1=1$, $m_2=-1$, and $m_3=0$. The sum is $1 + (-1) + 0 = 0$, so this selection rule is satisfied.\n\n2.  **The triangular selection rule**: From the theory of angular momentum, the product of two irreducible spherical tensors of ranks $\\ell_1$ and $\\ell_2$ (represented by $Y_{\\ell_1 m_1}$ and $Y_{\\ell_2 m_2}$) can be decomposed into a sum of irreducible spherical tensors of ranks $L$, where $L$ is constrained by the vector coupling rule $|\\ell_1 - \\ell_2| \\le L \\le \\ell_1 + \\ell_2$. The Gaunt integral can be viewed as the scalar product of the tensor $Y_{\\ell_3 m_3}$ with this decomposed product. Due to orthogonality, the integral will be non-zero only if the rank $\\ell_3$ is contained within the possible ranks $L$ resulting from the coupling of $\\ell_1$ and $\\ell_2$. This directly leads to the triangular selection rule: $|\\ell_1 - \\ell_2| \\le \\ell_3 \\le \\ell_1 + \\ell_2$. For the given problem, $\\ell_1=1$, $\\ell_2=1$, and $\\ell_3=2$. The condition is $|1-1| \\le 2 \\le 1+1$, which simplifies to $0 \\le 2 \\le 2$. This condition is satisfied.\n\nA third important selection rule relates to parity. The parity of a spherical harmonic $Y_{\\ell m}$ is $(-1)^\\ell$. The integral is non-zero only if the integrand has even parity, meaning $(-1)^{\\ell_1} (-1)^{\\ell_2} (-1)^{\\ell_3} = 1$. This requires the sum $\\ell_1+\\ell_2+\\ell_3$ to be an even integer. For our case, $1+1+2=4$, which is even.\n\nTo compute the Gaunt coefficient, we use the standard formula relating the integral of three spherical harmonics to a product of Clebsch-Gordan coefficients (CGCs). This formula is derived by expanding the product of two spherical harmonics and then using the orthonormality relation. A key step is relating the Gaunt integral to the standard form involving a complex conjugate. Using the Condon-Shortley phase convention, $Y_{\\ell m}^* = (-1)^m Y_{\\ell, -m}$, we can write $Y_{\\ell_3 m_3} = (-1)^{m_3}(Y_{\\ell_3, -m_3})^*$.\nThe Gaunt coefficient becomes:\n$$\nG(\\ell_{1} m_{1}; \\ell_{2} m_{2}; \\ell_{3} m_{3}) = (-1)^{m_3} \\int Y_{\\ell_{1} m_{1}}(\\Omega)\\,Y_{\\ell_{2} m_{2}}(\\Omega)\\, (Y_{\\ell_{3} -m_{3}}(\\Omega))^* \\,\\mathrm{d}\\Omega\n$$\nThe integral on the right is well-known and is given by:\n$$\n\\int Y_{\\ell_{1} m_{1}} Y_{\\ell_{2} m_{2}} Y_{L M}^* \\,\\mathrm{d}\\Omega = \\sqrt{\\frac{(2\\ell_1+1)(2\\ell_2+1)}{4\\pi(2L+1)}} \\langle \\ell_1 0; \\ell_2 0 | L 0 \\rangle \\langle \\ell_1 m_1; \\ell_2 m_2 | L M \\rangle\n$$\nSetting $L=\\ell_3$ and $M=-m_3$ leads to the final expression for the Gaunt coefficient:\n$$\nG(\\ell_{1} m_{1}; \\ell_{2} m_{2}; \\ell_{3} m_{3}) = (-1)^{m_3} \\sqrt{\\frac{(2\\ell_1+1)(2\\ell_2+1)}{4\\pi(2\\ell_3+1)}} \\langle \\ell_1 0; \\ell_2 0 | \\ell_3 0 \\rangle \\langle \\ell_1 m_1; \\ell_2 m_2 | \\ell_3, -m_3 \\rangle\n$$\nWe now apply this formula to the specific case $G(1\\,1;\\,1\\,{-}1;\\,2\\,0)$. The parameters are $\\ell_1=1$, $m_1=1$; $\\ell_2=1$, $m_2=-1$; and $\\ell_3=2$, $m_3=0$.\nSubstituting these values:\n$$\nG(1,1; 1,{-}1; 2,0) = (-1)^0 \\sqrt{\\frac{(2(1)+1)(2(1)+1)}{4\\pi(2(2)+1)}} \\langle 1,0; 1,0 | 2,0 \\rangle \\langle 1,1; 1,{-}1 | 2,0 \\rangle\n$$\n$$\nG(1,1; 1,{-}1; 2,0) = \\sqrt{\\frac{3 \\cdot 3}{4\\pi \\cdot 5}} \\langle 1,0; 1,0 | 2,0 \\rangle \\langle 1,1; 1,{-}1 | 2,0 \\rangle = \\frac{3}{2\\sqrt{5\\pi}} \\langle 1,0; 1,0 | 2,0 \\rangle \\langle 1,1; 1,{-}1 | 2,0 \\rangle\n$$\nThe required Clebsch-Gordan coefficients are for the coupling of two angular momenta with $j_1=1$ and $j_2=1$ to form a total angular momentum $J=2$. These are standard coefficients. The state $|J=2, M=0\\rangle$ is constructed from the product states $|j_1, m_1\\rangle|j_2, m_2\\rangle$ as:\n$$\n|2,0\\rangle = \\frac{1}{\\sqrt{6}} |1,1\\rangle|1,{-}1\\rangle + \\frac{2}{\\sqrt{6}} |1,0\\rangle|1,0\\rangle + \\frac{1}{\\sqrt{6}} |1,{-}1\\rangle|1,1\\rangle\n$$\nFrom this expansion, we read the coefficients:\n$$\n\\langle 1,1; 1,{-}1 | 2,0 \\rangle = \\frac{1}{\\sqrt{6}}\n$$\n$$\n\\langle 1,0; 1,0 | 2,0 \\rangle = \\frac{2}{\\sqrt{6}}\n$$\nSubstituting these values into our expression for the Gaunt coefficient:\n$$\nG(1,1; 1,{-}1; 2,0) = \\frac{3}{2\\sqrt{5\\pi}} \\left(\\frac{2}{\\sqrt{6}}\\right) \\left(\\frac{1}{\\sqrt{6}}\\right)\n$$\n$$\nG(1,1; 1,{-}1; 2,0) = \\frac{3}{2\\sqrt{5\\pi}} \\left(\\frac{2}{6}\\right) = \\frac{3}{2\\sqrt{5\\pi}} \\left(\\frac{1}{3}\\right)\n$$\n$$\nG(1,1; 1,{-}1; 2,0) = \\frac{1}{2\\sqrt{5\\pi}}\n$$\nThis is the exact, closed-form expression for the specified Gaunt coefficient.", "answer": "$$\\boxed{\\frac{1}{2\\sqrt{5\\pi}}}$$", "id": "3541865"}, {"introduction": "Large-scale nuclear shell-model calculations require access to millions of Clebsch-Gordan coefficients. Storing these coefficients naively would be prohibitively expensive in terms of memory. This practice [@problem_id:3541884] challenges you to design and implement a compact indexing scheme that stores only the non-zero coefficients by algorithmically enforcing the fundamental selection rules, a critical skill for developing memory-efficient physics codes.", "problem": "You are asked to formalize and implement a compact, contiguous indexing scheme for storing Clebsch–Gordan coefficients in computational nuclear physics. The coefficients are keyed by the sextuple of quantum numbers $\\left(j_1, j_2, J, m_1, m_2, M\\right)$ for the addition of two angular momenta, where $j_1$ and $j_2$ are single-particle total angular momenta, $m_1$ and $m_2$ are their projections, $J$ is the coupled total angular momentum, and $M$ is the coupled projection. Your scheme must enforce the exact selection rules of angular momentum coupling, and you must estimate the memory footprint for storing all such coefficients in several typical shell-model spaces.\n\nFundamental base and core definitions to be used:\n- The addition of two angular momenta in quantum mechanics builds the coupled basis $\\left| J M \\right\\rangle$ from the uncoupled tensor-product basis $\\left| j_1 m_1 \\right\\rangle \\otimes \\left| j_2 m_2 \\right\\rangle$ using Clebsch–Gordan coefficients $\\left\\langle j_1 m_1, j_2 m_2 \\mid J M \\right\\rangle$ defined by\n$$\n\\left| J M \\right\\rangle = \\sum_{m_1, m_2} \\left| j_1 m_1 \\right\\rangle \\otimes \\left| j_2 m_2 \\right\\rangle \\, \\left\\langle j_1 m_1, j_2 m_2 \\mid J M \\right\\rangle.\n$$\n- The well-tested selection rules are:\n  1. Triangle condition: $\\left| j_1 - j_2 \\right| \\le J \\le j_1 + j_2$.\n  2. Projection conservation: $M = m_1 + m_2$.\n  3. Bounds: $-j_i \\le m_i \\le j_i$ for $i \\in \\{1,2\\}$ and $-J \\le M \\le J$.\n  4. Half-integer consistency: $j_1$, $j_2$, $J$, $m_1$, $m_2$, $M$ are either all integers or half-integers such that $j_1 + j_2 + J$ is an integer and $m_1 + m_2 = M$ holds with consistent steps of unity in all magnetic quantum numbers.\n\nTasks:\n1. Represent all half-integer quantum numbers by doubled integers to obtain an integer-only domain. That is, store $2j_1$, $2j_2$, $2J$, $2m_1$, $2m_2$, $2M$ as integers. Under this representation, valid enumerations use step size $2$ to preserve the half-integer lattice.\n2. Define a canonical lexicographic enumeration over all allowed sextuples $\\left(2j_1, 2j_2, 2J, 2m_1, 2m_2, 2M\\right)$ that enforces the selection rules by construction:\n   - Sort the input set of allowed single-particle $j$ values in ascending order and convert to doubled integers.\n   - Enumerate ordered pairs $\\left(2j_1, 2j_2\\right)$ in ascending lexicographic order. For a symmetry-folded variant, restrict to $\\left(2j_1 \\le 2j_2\\right)$.\n   - For each pair, enumerate $2J$ from $\\left|2j_1 - 2j_2\\right|$ to $\\left(2j_1 + 2j_2\\right)$ in steps of $2$.\n   - For each $2J$, enumerate $2M$ from $-2J$ to $2J$ in steps of $2$.\n   - For each $2M$, enumerate $2m_1$ from $-2j_1$ to $2j_1$ in steps of $2$, set $2m_2 = 2M - 2m_1$, and include the sextuple if $-2j_2 \\le 2m_2 \\le 2j_2$.\n   - The linear index of a sextuple is its rank in this enumeration beginning at $0$.\n3. Compute, for each shell-model space in the test suite below, the total number of stored coefficients and the memory footprint when storing each Clebsch–Gordan coefficient as a $64$-bit floating-point number (that is, $8$ bytes per coefficient). Report both the “ordered-pair” storage (all $\\left(2j_1,2j_2\\right)$ including $2j_1 > 2j_2$) and the “symmetry-folded” storage (only $\\left(2j_1 \\le 2j_2\\right)$).\n4. Your program must implement the above enumeration and indexing scheme, and must compute the counts by explicit enforcement of the selection rules in doubled-integer space. It must not require any user input.\n\nTest suite:\n- Test $\\mathcal{T}_1$: $j$-set $S_1 = \\{ \\tfrac{1}{2} \\}$.\n- Test $\\mathcal{T}_2$: $j$-set $S_2 = \\{ \\tfrac{1}{2}, \\tfrac{3}{2}, \\tfrac{5}{2} \\}$ (an $sd$-shell model space).\n- Test $\\mathcal{T}_3$: $j$-set $S_3 = \\{ \\tfrac{1}{2}, \\tfrac{3}{2}, \\tfrac{5}{2}, \\tfrac{7}{2} \\}$ (a $pf$-shell model space).\n- Test $\\mathcal{T}_4$: $j$-set $S_4 = \\{ \\tfrac{9}{2} \\}$ (a single-orbit $g_{9/2}$ space).\n\nFor each test $\\mathcal{T}_k$, compute:\n- $N_{\\mathrm{ord}}$: the number of stored sextuples under ordered-pair enumeration,\n- $B_{\\mathrm{ord}}$: the total bytes for ordered-pair storage, equal to $N_{\\mathrm{ord}} \\times 8$,\n- $N_{\\mathrm{fold}}$: the number of stored sextuples under symmetry-folded enumeration with $2j_1 \\le 2j_2$,\n- $B_{\\mathrm{fold}}$: the total bytes for folded storage, equal to $N_{\\mathrm{fold}} \\times 8$.\n\nFinal output format:\n- Your program should produce a single line of output containing a JSON-like list with one entry per test, in order $\\left[\\mathcal{T}_1,\\mathcal{T}_2,\\mathcal{T}_3,\\mathcal{T}_4\\right]$.\n- Each entry must itself be the list $\\left[N_{\\mathrm{ord}}, B_{\\mathrm{ord}}, N_{\\mathrm{fold}}, B_{\\mathrm{fold}}\\right]$ using integer values.\n- Example schematic (not actual values): $\\left[\\left[n_1,b_1,n'_1,b'_1\\right],\\left[n_2,b_2,n'_2,b'_2\\right],\\left[n_3,b_3,n'_3,b'_3\\right],\\left[n_4,b_4,n'_4,b'_4\\right]\\right]$.\n\nNo angles are involved, so no angle unit specification is required. All memory must be reported in bytes. The program must be self-contained and must not read input.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of quantum angular momentum theory, well-posed with a clear algorithmic objective, and uses objective, formal language. The provided data and constraints are complete and consistent.\n\nThe task is to implement a counting scheme for the number of non-zero Clebsch-Gordan coefficients, $\\left\\langle j_1 m_1, j_2 m_2 \\mid J M \\right\\rangle$, for several specified sets of single-particle angular momenta $j$. This count determines the memory required to store these coefficients. The solution involves developing an algorithm that systematically enumerates all valid combinations of the six quantum numbers $(j_1, j_2, J, m_1, m_2, M)$ according to the fundamental selection rules of angular momentum coupling.\n\n**1. Integer Representation**\n\nA key requirement is to handle both integer and half-integer quantum numbers using a pure integer representation. This is accomplished by doubling all quantum numbers. A quantum number $j$ becomes $2j$, $m$ becomes $2m$, and so on. In this representation, all quantum numbers are integers. The physical constraint that quantum numbers change in steps of one (e.g., $m, m+1, \\ldots$) translates to the doubled integers changing in steps of $2$ (e.g., $2m, 2m+2, \\ldots$). This preserves the structure of the quantum mechanical state space while avoiding potential floating-point precision issues. For a given angular momentum $j$, the doubled projection $2m$ ranges from $-2j$ to $2j$ in steps of $2$.\n\n**2. Enumeration and Counting Strategy**\n\nThe problem specifies a lexicographical enumeration over the doubled-integer sextuples $(2j_1, 2j_2, 2J, 2m_1, 2m_2, 2M)$. The total number of valid sextuples is the required count. A direct, brute-force implementation would involve a set of nested loops corresponding to this enumeration order. However, a more computationally efficient strategy is employed here.\n\nThe calculation is broken down by pairs of single-particle angular momenta $(j_1, j_2)$. The number of coefficients for a given pair, let's call it $C(j_1, j_2)$, is independent of other pairs. The selection rules for Clebsch-Gordan coefficients are symmetric with respect to the interchange of the two coupled particles, which implies that $C(j_1, j_2) = C(j_2, j_1)$. This symmetry is exploited to optimize the calculation of the counts for the \"ordered-pair\" ($N_{\\mathrm{ord}}$) and \"symmetry-folded\" ($N_{\\mathrm{fold}}$) storage schemes.\n\nThe total counts are given by:\n- $N_{\\mathrm{fold}} = \\sum_{j_1 \\le j_2} C(j_1, j_2) = \\sum_{j_1<j_2} C(j_1, j_2) + \\sum_{j} C(j, j)$\n- $N_{\\mathrm{ord}} = \\sum_{j_1, j_2} C(j_1, j_2) = \\sum_{j_1 \\ne j_2} C(j_1, j_2) + \\sum_{j} C(j, j) = 2 \\sum_{j_1 < j_2} C(j_1, j_2) + \\sum_{j} C(j, j)$\n\nTherefore, we can calculate $N_{\\mathrm{ord}}$ from $N_{\\mathrm{fold}}$ and the diagonal contributions: $N_{\\mathrm{ord}} = 2 N_{\\mathrm{fold}} - \\sum_{j} C(j, j)$. My implementation calculates the diagonal terms ($\\sum_{j} C(j, j)$) and the off-diagonal terms for $j_1 < j_2$ ($\\sum_{j_1 < j_2} C(j_1, j_2)$) separately and combines them to obtain both $N_{\\mathrm{fold}}$ and $N_{\\mathrm{ord}}$ efficiently. This avoids redundant computations.\n\n**3. Analytical Innermost Loop**\n\nFor a fixed pair $(2j_1, 2j_2)$ and a fixed coupled state $(2J, 2M)$, the number of valid basis states is determined by the number of allowed $2m_1$ values. The selection rules impose the following constraints on $2m_1$:\n1. Projection conservation: $2m_1 + 2m_2 = 2M$.\n2. Projection bounds: $-2j_1 \\le 2m_1 \\le 2j_1$ and $-2j_2 \\le 2m_2 \\le 2j_2$.\n\nSubstituting $2m_2 = 2M - 2m_1$ into the second bound gives $-2j_2 \\le 2M - 2m_1 \\le 2j_2$, which rearranges to $2M - 2j_2 \\le 2m_1 \\le 2M + 2j_2$.\nCombining this with the bound on $2m_1$ itself, we find the allowed range for $2m_1$:\n$$\n\\max(-2j_1, 2M - 2j_2) \\le 2m_1 \\le \\min(2j_1, 2M + 2j_2)\n$$\nAdditionally, $2m_1$ must have the same parity as $2j_1$ because it steps from $-2j_1$ in increments of $2$.\n\nInstead of an explicit loop over all possible $2m_1$ values, the algorithm analytically computes the number of integers within this range that satisfy the parity constraint. Let the calculated lower and upper bounds be $L$ and $U$ respectively. We find the first valid $2m_1$ value, $S$, such that $S \\ge L$ and $(S - 2j_1) \\pmod 2 = 0$. If $S > U$, there are no valid values. Otherwise, the number of valid $2m_1$ values is $(U - S) / 2 + 1$. This optimization replaces the innermost loop with a constant-time calculation, significantly improving performance.\n\nThe algorithm proceeds as follows:\n1. For each test case, convert the set of fractional $j$ values into a sorted list of doubled integers, `two_j_list`.\n2. Calculate the \"diagonal\" contributions by summing $C(2j, 2j)$ for each $2j$ in `two_j_list`.\n3. Calculate the \"off-diagonal\" contributions by summing $C(2j_1, 2j_2)$ for all pairs where $2j_1 < 2j_2$.\n4. Combine these sums to find $N_{\\mathrm{fold}}$ and $N_{\\mathrm{ord}}$.\n5. Compute the memory footprints $B_{\\mathrm{fold}}$ and $B_{\\mathrm{ord}}$ by multiplying the counts by $8$ bytes per coefficient.\n6. The results for all test cases are collected and formatted into the specified output string.\n\nThe function `_count_for_j1j2_pair` implements the counting for a single $(2j_1, 2j_2)$ pair by iterating through allowed $(2J, 2M)$ values and applying the analytical formula described above for the number of valid $2m_1$ projections.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _count_for_j1j2_pair(two_j1, two_j2):\n    \"\"\"\n    Counts the number of valid Clebsch-Gordan sextuples for a fixed (j1, j2) pair.\n    The enumeration follows the rules specified in the problem statement, with an\n    analytical optimization for the innermost loop.\n    \"\"\"\n    count = 0\n    # Loop over 2J from |2j1 - 2j2| to 2j1 + 2j2 in steps of 2.\n    for two_J in range(abs(two_j1 - two_j2), two_j1 + two_j2 + 1, 2):\n        # Loop over 2M from -2J to 2J in steps of 2.\n        for two_M in range(-two_J, two_J + 1, 2):\n            # Analytically determine the number of valid m1 values.\n            # Constraint from m1: -2j1 <= 2m1 <= 2j1\n            # Constraint from m2: -2j2 <= 2M - 2m1 <= 2j2\n            # Which is: 2M - 2j2 <= 2m1 <= 2M + 2j2\n            lower_bound_m1 = max(-two_j1, two_M - two_j2)\n            upper_bound_m1 = min(two_j1, two_M + two_j2)\n\n            # If the range is invalid, there are no solutions.\n            if lower_bound_m1 > upper_bound_m1:\n                continue\n            \n            # The start of the valid range for 2m1 must have the same parity as 2j1.\n            start_m1 = lower_bound_m1\n            if (start_m1 - two_j1) % 2 != 0:\n                start_m1 += 1\n            \n            # If the adjusted start is out of bounds, no solutions.\n            if start_m1 > upper_bound_m1:\n                continue\n\n            # Count the number of valid 2m1 values (step size 2)\n            num_valid_m1 = (upper_bound_m1 - start_m1) // 2 + 1\n            count += num_valid_m1\n    return count\n\ndef _calculate_storages(j_set_frac):\n    \"\"\"\n    Calculates the coefficient counts and memory storage for a given j-set.\n    This function leverages the symmetry C(j1, j2) = C(j2, j1) to optimize\n    the calculation of ordered and folded counts.\n    \"\"\"\n    two_j_list = sorted([int(2 * j) for j in j_set_frac])\n    \n    n_diag = 0\n    for two_j in two_j_list:\n        n_diag += _count_for_j1j2_pair(two_j, two_j)\n        \n    n_off_diag_fold = 0\n    num_j = len(two_j_list)\n    for i in range(num_j):\n        for j in range(i + 1, num_j):\n            two_j1 = two_j_list[i]\n            two_j2 = two_j_list[j]\n            n_off_diag_fold += _count_for_j1j2_pair(two_j1, two_j2)\n\n    # N_fold = sum over j1 <= j2\n    n_fold = n_diag + n_off_diag_fold\n    # N_ord = sum over all (j1, j2), which is sum(diag) + 2 * sum(off-diag)\n    n_ord = n_diag + 2 * n_off_diag_fold\n\n    b_ord = n_ord * 8\n    b_fold = n_fold * 8\n\n    return [n_ord, b_ord, n_fold, b_fold]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # T1: S1 = {1/2}\n        [0.5],\n        # T2: S2 = {1/2, 3/2, 5/2} (sd-shell)\n        [0.5, 1.5, 2.5],\n        # T3: S3 = {1/2, 3/2, 5/2, 7/2} (pf-shell)\n        [0.5, 1.5, 2.5, 3.5],\n        # T4: S4 = {9/2} (g_9/2 orbital)\n        [4.5]\n    ]\n\n    results = []\n    for j_set in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        result = _calculate_storages(j_set)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # str(list) produces space after comma, which we remove.\n    print(str(results).replace(' ', ''))\n\nsolve()\n```", "id": "3541884"}, {"introduction": "In high-performance computing, the fastest algorithm in theory is not always the fastest in practice. This exercise [@problem_id:3541900] delves into a classic performance trade-off: is it more efficient to compute Clebsch-Gordan coefficients on-the-fly or to precompute them and look them up from memory? By analyzing a realistic scenario with specific hardware parameters, you will learn to reason about performance in terms of cache hierarchy, memory bandwidth, and computational intensity, key concepts for optimizing modern scientific software.", "problem": "In large-scale nuclear shell-model calculations, construction of many-body Hamiltonian matrix elements and transition operators often requires repeated evaluation of Clebsch-Gordan (CG) coefficients, which couple two angular momenta $j_1$ and $j_2$ to a resultant $J$, with magnetic quantum numbers $m_1$, $m_2$, and $M=m_1+m_2$. The Clebsch-Gordan coefficients are defined by the unitary change of basis between the product basis $\\lvert j_1 m_1 \\rangle \\otimes \\lvert j_2 m_2 \\rangle$ and the coupled basis $\\lvert J M \\rangle$, obeying orthogonality and selection rules such as the triangle condition $\\lvert j_1-j_2 \\rvert \\le J \\le j_1+j_2$ and the projection constraint $m_1+m_2=M$. In computational nuclear physics, many codes either (i) precompute and store needed CG values and perform memory lookups, or (ii) compute them on-the-fly via stable recurrences or relations to Wigner $3j$ symbols, exploiting symmetries (e.g., phase relations, parity of projections) to reduce redundant work.\n\nConsider a shell-model code executing a Lanczos iteration on a node with $N_{\\mathrm{core}}=64$ identical cores. The processor has $S_{L1}=64\\,\\mathrm{KB}$ L1 cache per core, $S_{L2}=1\\,\\mathrm{MB}$ L2 per core, and a shared last-level cache of $S_{L3}=128\\,\\mathrm{MB}$. Assume the following empirically validated, architecture-level parameters: L1 hit latency $t_{L1}\\approx 1\\,\\mathrm{ns}$ per $64\\,\\mathrm{B}$ cache line, L2 hit $t_{L2}\\approx 4\\,\\mathrm{ns}$, and L3 hit $t_{L3}\\approx 12\\,\\mathrm{ns}$; main memory has peak bandwidth $B_{\\mathrm{peak}}=200\\,\\mathrm{GB/s}$ and random-access latency $t_{\\mathrm{DRAM}}\\approx 80\\,\\mathrm{ns}$ for a single $64\\,\\mathrm{B}$ line. Each CG coefficient is stored as an $8\\,\\mathrm{B}$ double-precision floating-point number. The per-core double-precision sustained performance is $\\rho\\approx 50\\,\\mathrm{GFLOP/s}$ on compute-bound kernels, and modern compilers vectorize the stable on-the-fly CG routines so that a single CG evaluation costs $F\\approx 300$ floating-point operations on average.\n\nTwo workload regimes are observed for the inner kernels forming matrix-vector products:\n\n- Regime I (localized coupling): For a given inner kernel, each thread predominantly reuses a small set of $(j_1,j_2,J)$ triples with their allowed $(m_1,m_2)$ combinations, with per-thread working set $S_{\\mathrm{WS}}\\lesssim 512\\,\\mathrm{KB}$ and high temporal locality across iterations. Across all threads, the aggregate distinct CG values touched repeatedly fit within the shared $S_{L3}$ and often within $S_{L2}$ per core.\n\n- Regime II (randomized coupling): Each thread touches a wide variety of $(j_1,j_2,J)$ and $(m_1,m_2)$ combinations with weak locality, so that the aggregate working set of CG values exceeds $S_{L3}$, and per-thread streams exhibit near-random access. Effective memory bandwidth for these random loads is reduced to $B_{\\mathrm{eff}}\\approx 50\\,\\mathrm{GB/s}$ due to limited memory-level parallelism and poor prefetch efficacy.\n\nFor a representative Lanczos step, there are $N_{\\mathrm{CG}}=5\\times 10^{9}$ CG coefficient uses across all threads. In a precompute-and-lookup strategy, a single lookup brings the $8\\,\\mathrm{B}$ value into registers via a cache line load; in an on-the-fly strategy, each CG coefficient is computed anew with cost $F$ floating-point operations, ignoring negligible branching overhead. You may assume that lookups in Regime I predominantly hit $S_{L2}$ or $S_{L3}$ and are bandwidth-sustained near $B_{\\mathrm{peak}}$, whereas lookups in Regime II suffer random-access behavior characterized by $B_{\\mathrm{eff}}$; the on-the-fly computation sustains near-peak floating-point throughput regardless of regime.\n\nUsing only the above foundational definitions and performance facts, derive order-of-magnitude time estimates for the precompute-and-lookup and on-the-fly strategies in each regime, and then select the statement that is best supported by these estimates and by the interplay of cache behavior and parallelization.\n\nOptions:\nA. Precomputing CG coefficients is universally superior in both regimes because their values are fixed; lookups are always faster than arithmetic, and parallelization favors shared read-only tables with negligible bandwidth limits.\nB. On-the-fly computation can outperform precomputed tables in Regime II where the working set exceeds the last-level cache and memory bandwidth/latency dominates, while precompute-and-lookup is superior in Regime I where reuse keeps the working set cache-resident; moreover, the compute-bound on-the-fly method scales better under strong random-access patterns across many cores.\nC. Parallelization inherently favors precomputed tables; threads hitting a shared read-only table will achieve predominantly L1 hits, whereas on-the-fly recurrence requires synchronization across cores that degrades scaling, making precompute superior in both regimes.\nD. Applying triangle and projection selection rules reduces the table size so dramatically that, for realistic shell-model spaces, all needed CG values fit within per-core $S_{L2}$, making precompute-and-lookup superior regardless of locality; on-the-fly computation offers no advantage in practice.", "solution": "The problem statement is critically evaluated for validity before proceeding to a solution.\n\n### Step 1: Extract Givens\nThe following parameters and conditions are extracted verbatim from the problem statement:\n- **System Architecture:**\n    - Number of cores: $N_{\\mathrm{core}} = 64$\n    - L1 cache per core: $S_{L1} = 64\\,\\mathrm{KB}$\n    - L2 cache per core: $S_{L2} = 1\\,\\mathrm{MB}$\n    - Shared last-level cache: $S_{L3} = 128\\,\\mathrm{MB}$\n- **Performance Parameters:**\n    - L1 hit latency: $t_{L1} \\approx 1\\,\\mathrm{ns}$ per $64\\,\\mathrm{B}$ cache line\n    - L2 hit latency: $t_{L2} \\approx 4\\,\\mathrm{ns}$ per $64\\,\\mathrm{B}$ cache line\n    - L3 hit latency: $t_{L3} \\approx 12\\,\\mathrm{ns}$ per $64\\,\\mathrm{B}$ cache line\n    - DRAM random-access latency: $t_{\\mathrm{DRAM}} \\approx 80\\,\\mathrm{ns}$ for a single $64\\,\\mathrm{B}$ line\n    - Main memory peak bandwidth: $B_{\\mathrm{peak}} = 200\\,\\mathrm{GB/s}$\n    - Per-core sustained double-precision performance: $\\rho \\approx 50\\,\\mathrm{GFLOP/s}$\n- **Workload Parameters:**\n    - Clebsch-Gordan (CG) coefficient size: $8\\,\\mathrm{B}$\n    - On-the-fly CG evaluation cost: $F \\approx 300$ floating-point operations (FLOPs)\n    - Total number of CG coefficient uses: $N_{\\mathrm{CG}} = 5 \\times 10^9$\n- **Workload Regimes:**\n    - **Regime I (localized coupling):** Per-thread working set $S_{\\mathrm{WS}} \\lesssim 512\\,\\mathrm{KB}$. High temporal locality. Aggregate distinct CG values fit within $S_{L3}$, often within per-core $S_{L2}$. Lookups are bandwidth-sustained near $B_{\\mathrm{peak}}$.\n    - **Regime II (randomized coupling):** Aggregate working set of CG values exceeds $S_{L3}$. Weak locality, near-random access per thread. Effective memory bandwidth for random loads is reduced to $B_{\\mathrm{eff}} \\approx 50\\,\\mathrm{GB/s}$.\n- **Strategy Assumptions:**\n    - **Precompute-and-lookup:** A lookup brings the $8\\,\\mathrm{B}$ value into registers via a cache line load.\n    - **On-the-fly:** Each CG is computed anew, sustaining near-peak floating-point throughput regardless of regime.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is evaluated based on the criteria of scientific soundness, well-posedness, and objectivity.\n\n- **Scientifically Grounded:** The problem is firmly located within computational nuclear physics and high-performance computing. The scenario described—the trade-off between re-computation and memory lookup for frequently used values like Clebsch-Gordan coefficients—is a canonical problem in scientific software optimization. The hardware parameters ($S_{L1}$, $S_{L2}$, $S_{L3}$, latencies, bandwidths, FLOPS) are realistic for a modern HPC compute node. The physics context (shell model, Lanczos, angular momentum coupling) is accurate. The problem is free of scientific flaws.\n- **Well-Posed:** The problem provides sufficient quantitative data to perform order-of-magnitude estimations for the two strategies in both regimes. The question asks for a conclusion supported by these estimates, which is a well-defined task. The setup is self-contained and internally consistent (e.g., the memory hierarchy latencies and capacities are ordered correctly).\n- **Objective:** The problem is stated in precise, technical language. The parameters are given as objective numerical values, and the regimes are defined by quantitative metrics (working set size, access patterns). There is no subjective or ambiguous language.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. It is scientifically sound, well-posed, objective, and provides a sufficient basis for a rigorous quantitative analysis. The solution process will now proceed.\n\n### Derivation of Time Estimates\n\nThe analysis requires estimating the total wall-clock time for performing $N_{\\mathrm{CG}} = 5 \\times 10^9$ CG coefficient operations on a $N_{\\mathrm{core}} = 64$ core system, for two strategies in two regimes. We assume perfect load balancing, so the work is distributed evenly.\n\n**1. On-the-fly Computation Strategy**\n\nThis strategy is compute-bound, as stated. Its performance depends on the floating-point capability of the processor.\n- Cost per CG evaluation: $F = 300$ FLOPs\n- Total floating-point operations required: $N_{\\mathrm{total\\_FLOPs}} = N_{\\mathrm{CG}} \\times F = (5 \\times 10^9) \\times 300 = 1.5 \\times 10^{12}$ FLOPs.\n- Sustained performance per core: $\\rho = 50\\,\\mathrm{GFLOP/s} = 50 \\times 10^9\\,\\mathrm{FLOP/s}$.\n- Total sustained performance across all cores: $\\rho_{\\mathrm{total}} = N_{\\mathrm{core}} \\times \\rho = 64 \\times 50 \\times 10^9\\,\\mathrm{FLOP/s} = 3200 \\times 10^9\\,\\mathrm{FLOP/s} = 3.2\\,\\mathrm{TFLOP/s}$.\n- Estimated time for on-the-fly computation:\n$$ T_{\\mathrm{compute}} = \\frac{N_{\\mathrm{total\\_FLOPs}}}{\\rho_{\\mathrm{total}}} = \\frac{1.5 \\times 10^{12}\\,\\mathrm{FLOPs}}{3.2 \\times 10^{12}\\,\\mathrm{FLOP/s}} = 0.46875\\,\\mathrm{s} $$\nThe problem states this performance is sustained \"regardless of regime\".\nTherefore, $T_{\\mathrm{compute, I}} \\approx T_{\\mathrm{compute, II}} \\approx 0.47\\,\\mathrm{s}$.\n\n**2. Precompute-and-lookup Strategy**\n\nThis strategy is memory-bound. Its performance depends on the time to load the CG values from the memory hierarchy.\n- Size of each CG value: $8\\,\\mathrm{B}$.\n- Total data transferred to registers over the run: $D_{\\mathrm{total}} = N_{\\mathrm{CG}} \\times 8\\,\\mathrm{B} = (5 \\times 10^9) \\times 8\\,\\mathrm{B} = 40 \\times 10^9\\,\\mathrm{B} = 40\\,\\mathrm{GB}$.\nThe time taken depends on the effective bandwidth, which is determined by the access pattern and data locality described in each regime.\n\n- **Regime I (localized, cache-resident):**\nThe problem states that per-thread working sets ($S_{\\mathrm{WS}} \\lesssim 512\\,\\mathrm{KB}$) fit within the per-core L2 cache ($S_{L2} = 1\\,\\mathrm{MB}$), and that lookups are \"bandwidth-sustained near $B_{\\mathrm{peak}}$\". This implies that the memory subsystem, benefiting from high cache hit rates, can satisfy the cores' data demands at a rate approaching the peak system memory bandwidth.\n- Peak bandwidth: $B_{\\mathrm{peak}} = 200\\,\\mathrm{GB/s}$.\n- Estimated time for lookups in Regime I:\n$$ T_{\\mathrm{lookup, I}} = \\frac{D_{\\mathrm{total}}}{B_{\\mathrm{peak}}} = \\frac{40\\,\\mathrm{GB}}{200\\,\\mathrm{GB/s}} = 0.2\\,\\mathrm{s} $$\n\n- **Regime II (randomized, memory-resident):**\nThe aggregate working set exceeds the shared $S_{L3}$ cache, and accesses are random. This will lead to frequent cache misses at all levels, with most requests ultimately being served by main memory (DRAM). The problem gives a specific effective bandwidth for this scenario, which accounts for high latency and limited memory-level parallelism.\n- Effective bandwidth: $B_{\\mathrm{eff}} = 50\\,\\mathrm{GB/s}$.\n- Estimated time for lookups in Regime II:\n$$ T_{\\mathrm{lookup, II}} = \\frac{D_{\\mathrm{total}}}{B_{\\mathrm{eff}}} = \\frac{40\\,\\mathrm{GB}}{50\\,\\mathrm{GB/s}} = 0.8\\,\\mathrm{s} $$\n\n**Summary of Time Estimates:**\n- Regime I: $T_{\\mathrm{lookup, I}} \\approx 0.20\\,\\mathrm{s}$ vs. $T_{\\mathrm{compute, I}} \\approx 0.47\\,\\mathrm{s}$. The **lookup** strategy is superior.\n- Regime II: $T_{\\mathrm{lookup, II}} \\approx 0.80\\,\\mathrm{s}$ vs. $T_{\\mathrm{compute, II}} \\approx 0.47\\,\\mathrm{s}$. The **on-the-fly** strategy is superior.\n\n### Option-by-Option Analysis\n\n**A. Precomputing CG coefficients is universally superior in both regimes because their values are fixed; lookups are always faster than arithmetic, and parallelization favors shared read-only tables with negligible bandwidth limits.**\nThis statement is factually incorrect. Our estimate shows that in Regime II, on-the-fly computation ($T \\approx 0.47\\,\\mathrm{s}$) is significantly faster than lookup ($T \\approx 0.80\\,\\mathrm{s}$). The premise that \"lookups are always faster than arithmetic\" is false; a computation costing $\\approx 300$ FLOPs takes on the order of $F/\\rho = 300 / (50 \\times 10^9) = 6\\,\\mathrm{ns}$ on a single core, while a random DRAM access costs $t_{\\mathrm{DRAM}} \\approx 80\\,\\mathrm{ns}$. The claim of \"negligible bandwidth limits\" is also false, as the performance in Regime II is explicitly limited by memory bandwidth.\n**Verdict: Incorrect.**\n\n**B. On-the-fly computation can outperform precomputed tables in Regime II where the working set exceeds the last-level cache and memory bandwidth/latency dominates, while precompute-and-lookup is superior in Regime I where reuse keeps the working set cache-resident; moreover, the compute-bound on-the-fly method scales better under strong random-access patterns across many cores.**\nThis statement aligns perfectly with the derived estimates.\n- \"On-the-fly computation can outperform precomputed tables in Regime II...\": Correct ($0.47\\,\\mathrm{s}$ vs. $0.80\\,\\mathrm{s}$). The reason given, memory bandwidth/latency dominance, is the correct physical explanation.\n- \"precompute-and-lookup is superior in Regime I...\": Correct ($0.20\\,\\mathrm{s}$ vs. $0.47\\,\\mathrm{s}$). The reason given, cache-residency due to reuse, is correct.\n- \"the compute-bound on-the-fly method scales better...\": This is also correct. The on-the-fly method is an embarrassingly parallel problem where each core works independently, so performance scales linearly with the number of cores. The lookup method in Regime II is bottlenecked by the shared memory bandwidth resource ($B_{\\mathrm{eff}}$), which does not scale with the number of cores and will saturate, leading to poor scaling.\n**Verdict: Correct.**\n\n**C. Parallelization inherently favors precomputed tables; threads hitting a shared read-only table will achieve predominantly L1 hits, whereas on-the-fly recurrence requires synchronization across cores that degrades scaling, making precompute superior in both regimes.**\nThis statement contains multiple fundamental errors.\n- \"threads ... will achieve predominantly L1 hits\": Incorrect. The per-thread working set in Regime I ($S_{\\mathrm{WS}} \\approx 512\\,\\mathrm{KB}$) is larger than the L1 cache ($S_{L1} = 64\\,\\mathrm{KB}$), so misses will be frequent, and hits will occur mostly in L2. In Regime II, most accesses miss all caches.\n- \"on-the-fly recurrence requires synchronization across cores\": Incorrect. The calculation of a CG coefficient is a self-contained mathematical function that depends only on its input arguments ($j_1, j_2, J, m_1, m_2$). There is no data dependency or required communication between different CG calculations, so cores can compute them independently without any synchronization.\n- \"making precompute superior in both regimes\": This contradicts our finding that on-the-fly is superior in Regime II.\n**Verdict: Incorrect.**\n\n**D. Applying triangle and projection selection rules reduces the table size so dramatically that, for realistic shell-model spaces, all needed CG values fit within per-core $S_{L2}$, making precompute-and-lookup superior regardless of locality; on-the-fly computation offers no advantage in practice.**\nThis statement attempts to invalidate the premise of the problem. The problem explicitly defines Regime II as an observed case where \"the aggregate working set of CG values exceeds $S_{L3}$\". Option D dismisses this regime as unrealistic. However, in the context of solving the given problem, one must accept its premises. Large-scale nuclear shell-model calculations can indeed involve model spaces so large that the set of required CG coefficients exceeds cache capacity. By contradicting a stated premise of the problem, this option fails to correctly address the question asked. Our analysis based on the problem's premises shows that the lookup method is not superior regardless of locality.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{B}$$", "id": "3541900"}]}