{"hands_on_practices": [{"introduction": "This first practice provides a foundational, analytical exploration of the Rayleigh-Ritz method. By applying it to the familiar harmonic oscillator, you will calculate the variational energy within a small, truncated basis and see firsthand how the result serves as an upper bound to the exact ground state energy. This exercise illuminates the core principle that the accuracy of the approximation is directly tied to how well the chosen basis can represent the true physics [@problem_id:3610839].", "problem": "In computational nuclear physics, the variational characterization of the ground-state energy of a self-adjoint Hamiltonian $h$ is given by the Rayleigh quotient $R[\\psi] = \\langle \\psi | h | \\psi \\rangle / \\langle \\psi | \\psi \\rangle$, and the Rayleigh-Ritz (RR) method approximates the ground state by minimizing $R[\\psi]$ over a finite-dimensional subspace. Consider a one-body Hamiltonian in one Cartesian dimension,\n$$\nh = \\frac{p^{2}}{2 m} + \\frac{1}{2} m \\omega^{2} x^{2},\n$$\nwith mass $m$, reference frequency parameter $\\Omega$ used to build a Harmonic Oscillator (HO) basis, and physical frequency $\\omega$ defining $h$. Let $\\{ \\phi_{0}(x;\\Omega), \\phi_{1}(x;\\Omega) \\}$ denote the first two normalized HO eigenfunctions of the reference Hamiltonian\n$$\nh_{\\Omega} = \\frac{p^{2}}{2 m} + \\frac{1}{2} m \\Omega^{2} x^{2}.\n$$\nUsing only the canonical commutation relation $[x,p] = i \\hbar$ and the orthonormality and ladder-operator structure of the HO basis states of $h_{\\Omega}$, construct the $2 \\times 2$ matrix representation of $h$ in the subspace spanned by $\\{ \\phi_{0}, \\phi_{1} \\}$ and determine the minimal Rayleigh quotient over this subspace, i.e., the smallest eigenvalue of the projected Hamiltonian. The exact ground-state energy of $h$ is $E_{0} = \\frac{1}{2} \\hbar \\omega$. Provide your comparison in the form of the fractional error\n$$\n\\frac{E_{\\mathrm{var}} - E_{0}}{E_{0}},\n$$\nwhere $E_{\\mathrm{var}}$ is the minimal Rayleigh quotient in the specified subspace. Express your final answer as a single closed-form analytic expression in terms of $\\Omega$ and $\\omega$. No numerical rounding is required, and since this quantity is dimensionless, no units are to be reported.", "solution": "The task is to find the lowest-energy variational approximation, $E_{\\mathrm{var}}$, for a harmonic oscillator Hamiltonian $h$ within a two-state trial space, and then to compute the fractional error relative to the exact ground-state energy, $E_0$.\n\nThe Hamiltonian of the physical system is given by:\n$$\nh = \\frac{p^{2}}{2 m} + \\frac{1}{2} m \\omega^{2} x^{2}\n$$\nThe variational subspace is spanned by the first two orthonormal eigenfunctions, $\\{ \\phi_{0}, \\phi_{1} \\}$, of a reference harmonic oscillator Hamiltonian, $h_{\\Omega}$:\n$$\nh_{\\Omega} = \\frac{p^{2}}{2 m} + \\frac{1}{2} m \\Omega^{2} x^{2}\n$$\nThe eigenfunctions $\\phi_n \\equiv \\phi_n(x; \\Omega)$ satisfy $h_{\\Omega} \\phi_n = E_n^{(\\Omega)} \\phi_n$, with eigenvalues $E_n^{(\\Omega)} = (n + \\frac{1}{2})\\hbar\\Omega$.\n\nThe Rayleigh-Ritz method requires us to construct the matrix representation of the Hamiltonian $h$ in the basis $\\{ \\phi_{0}, \\phi_{1} \\}$ and find its lowest eigenvalue. This eigenvalue corresponds to the minimal Rayleigh quotient, $E_{\\mathrm{var}}$. The matrix elements are $H_{ij} = \\langle \\phi_i | h | \\phi_j \\rangle$.\n\nTo simplify the calculation of the matrix elements, we can express $h$ in terms of $h_{\\Omega}$:\n$$\nh = h_{\\Omega} - \\frac{1}{2} m \\Omega^{2} x^{2} + \\frac{1}{2} m \\omega^{2} x^{2} = h_{\\Omega} + \\frac{1}{2} m (\\omega^{2} - \\Omega^{2}) x^{2}\n$$\nThe matrix elements are therefore:\n$$\nH_{ij} = \\langle \\phi_i | h_{\\Omega} + \\frac{1}{2} m (\\omega^{2} - \\Omega^{2}) x^{2} | \\phi_j \\rangle\n$$\nUsing the fact that $\\phi_j$ are eigenfunctions of $h_{\\Omega}$ and the basis is orthonormal ($\\langle \\phi_i | \\phi_j \\rangle = \\delta_{ij}$):\n$$\nH_{ij} = \\langle \\phi_i | E_j^{(\\Omega)} | \\phi_j \\rangle + \\frac{1}{2} m (\\omega^{2} - \\Omega^{2}) \\langle \\phi_i | x^{2} | \\phi_j \\rangle\n$$\n$$\nH_{ij} = E_j^{(\\Omega)} \\delta_{ij} + \\frac{1}{2} m (\\omega^{2} - \\Omega^{2}) \\langle \\phi_i | x^{2} | \\phi_j \\rangle\n$$\nThe eigenfunctions of the harmonic oscillator have definite parity: $\\phi_n(-x) = (-1)^n \\phi_n(x)$. Thus, $\\phi_0$ is an even function and $\\phi_1$ is an odd function. The operator $x^2$ is an even operator, as $x^2 = (-x)^2$. The matrix element $\\langle \\phi_i | x^2 | \\phi_j \\rangle$ involves an integral of the form $\\int \\phi_i^*(x) x^2 \\phi_j(x) dx$. For the off-diagonal elements ($i \\neq j$), the integrand is a product of an even function ($\\phi_0$), an even function ($x^2$), and an odd function ($\\phi_1$). The overall integrand is odd, and its integral over symmetric limits $(-\\infty, \\infty)$ is zero.\nTherefore, $\\langle \\phi_0 | x^{2} | \\phi_1 \\rangle = 0$ and $\\langle \\phi_1 | x^{2} | \\phi_0 \\rangle = 0$.\nThis implies that the matrix representation of $h$ in this basis is diagonal:\n$$\nH = \\begin{pmatrix} H_{00} & 0 \\\\ 0 & H_{11} \\end{pmatrix}\n$$\nThe eigenvalues are simply the diagonal elements, $H_{00}$ and $H_{11}$. We must now compute these elements. This requires the expectation values $\\langle \\phi_0 | x^2 | \\phi_0 \\rangle$ and $\\langle \\phi_1 | x^2 | \\phi_1 \\rangle$. We use the ladder operator formalism for the reference Hamiltonian $h_{\\Omega}$. The position operator $x$ is expressed in terms of the annihilation ($a$) and creation ($a^{\\dagger}$) operators:\n$$\nx = \\sqrt{\\frac{\\hbar}{2 m \\Omega}}(a + a^{\\dagger})\n$$\nSquaring this gives:\n$$\nx^{2} = \\frac{\\hbar}{2 m \\Omega} (a + a^{\\dagger})^{2} = \\frac{\\hbar}{2 m \\Omega} (a^2 + (a^{\\dagger})^2 + a a^{\\dagger} + a^{\\dagger} a)\n$$\nUsing the commutation relation $[a, a^{\\dagger}] = 1$, we can write $a a^{\\dagger} = a^{\\dagger} a + 1$. The number operator is $N = a^{\\dagger} a$.\n$$\nx^{2} = \\frac{\\hbar}{2 m \\Omega} (a^2 + (a^{\\dagger})^2 + 2N + 1)\n$$\nWe now compute the expectation values. Note that $\\langle \\phi_n | a^2 | \\phi_n \\rangle = 0$ and $\\langle \\phi_n | (a^{\\dagger})^2 | \\phi_n \\rangle = 0$ due to orthogonality.\nFor the state $\\phi_0$ ($n=0$):\n$$\n\\langle \\phi_0 | x^2 | \\phi_0 \\rangle = \\frac{\\hbar}{2 m \\Omega} \\langle \\phi_0 | 2N + 1 | \\phi_0 \\rangle = \\frac{\\hbar}{2 m \\Omega} (2(0) + 1) = \\frac{\\hbar}{2 m \\Omega}\n$$\nFor the state $\\phi_1$ ($n=1$):\n$$\n\\langle \\phi_1 | x^2 | \\phi_1 \\rangle = \\frac{\\hbar}{2 m \\Omega} \\langle \\phi_1 | 2N + 1 | \\phi_1 \\rangle = \\frac{\\hbar}{2 m \\Omega} (2(1) + 1) = \\frac{3\\hbar}{2 m \\Omega}\n$$\nNow we can construct the diagonal matrix elements of $H$:\n$$\nH_{00} = E_0^{(\\Omega)} + \\frac{1}{2} m (\\omega^{2} - \\Omega^{2}) \\langle \\phi_0 | x^{2} | \\phi_0 \\rangle = \\frac{1}{2}\\hbar\\Omega + \\frac{1}{2} m (\\omega^{2} - \\Omega^{2}) \\frac{\\hbar}{2 m \\Omega}\n$$\n$$\nH_{00} = \\frac{1}{2}\\hbar\\Omega + \\frac{\\hbar(\\omega^{2} - \\Omega^{2})}{4\\Omega} = \\frac{\\hbar}{4\\Omega} [2\\Omega^2 + \\omega^2 - \\Omega^2] = \\frac{\\hbar}{4\\Omega}(\\Omega^2 + \\omega^2)\n$$\nAnd for $H_{11}$:\n$$\nH_{11} = E_1^{(\\Omega)} + \\frac{1}{2} m (\\omega^{2} - \\Omega^{2}) \\langle \\phi_1 | x^{2} | \\phi_1 \\rangle = \\frac{3}{2}\\hbar\\Omega + \\frac{1}{2} m (\\omega^{2} - \\Omega^{2}) \\frac{3\\hbar}{2 m \\Omega}\n$$\n$$\nH_{11} = \\frac{3}{2}\\hbar\\Omega + \\frac{3\\hbar(\\omega^{2} - \\Omega^{2})}{4\\Omega} = \\frac{3\\hbar}{4\\Omega} [2\\Omega^2 + \\omega^2 - \\Omega^2] = \\frac{3\\hbar}{4\\Omega}(\\Omega^2 + \\omega^2)\n$$\nThe eigenvalues of the projected Hamiltonian are $H_{00}$ and $H_{11}$. The minimal Rayleigh quotient, $E_{\\mathrm{var}}$, is the minimum of these two values. Since $\\hbar, \\Omega, \\omega^2, \\Omega^2$ are all positive, $H_{00} < H_{11}$.\nTherefore:\n$$\nE_{\\mathrm{var}} = H_{00} = \\frac{\\hbar}{4\\Omega}(\\Omega^2 + \\omega^2)\n$$\nThe exact ground-state energy of the physical Hamiltonian $h$ is given as $E_0 = \\frac{1}{2} \\hbar \\omega$. We are asked to compute the fractional error:\n$$\n\\frac{E_{\\mathrm{var}} - E_{0}}{E_{0}} = \\frac{E_{\\mathrm{var}}}{E_{0}} - 1\n$$\nSubstituting the expressions for $E_{\\mathrm{var}}$ and $E_0$:\n$$\n\\frac{E_{\\mathrm{var}}}{E_{0}} = \\frac{\\frac{\\hbar}{4\\Omega}(\\Omega^2 + \\omega^2)}{\\frac{1}{2}\\hbar\\omega} = \\frac{\\Omega^2 + \\omega^2}{2\\Omega\\omega}\n$$\nThe fractional error is then:\n$$\n\\frac{E_{\\mathrm{var}} - E_{0}}{E_{0}} = \\frac{\\Omega^2 + \\omega^2}{2\\Omega\\omega} - 1 = \\frac{\\Omega^2 + \\omega^2 - 2\\Omega\\omega}{2\\Omega\\omega} = \\frac{(\\Omega - \\omega)^2}{2\\Omega\\omega}\n$$\nThis result is consistent with the variational theorem, which guarantees $E_{\\mathrm{var}} \\ge E_0$, as the expression is always non-negative. The error vanishes only when $\\Omega = \\omega$, which is the case where the basis state $\\phi_0(x; \\Omega)$ is identical to the true ground state of $h$.", "answer": "$$\n\\boxed{\\frac{(\\Omega - \\omega)^2}{2\\Omega\\omega}}\n$$", "id": "3610839"}, {"introduction": "Moving from a simple analytical model to a realistic computational task, this practice guides you through a complete Configuration Interaction (CI) calculation for a two-nucleon system. A key challenge in such calculations using a fixed laboratory-frame basis is the appearance of unphysical \"spurious\" states of center-of-mass motion. You will implement a diagnostic for this contamination and apply the powerful Lawson method, a variational penalty technique, to filter these spurious states from the spectrum [@problem_id:3610851].", "problem": "You will implement a complete Rayleigh–Ritz variational calculation for a two-nucleon system in one spatial dimension to diagnose and variationally filter center-of-mass contamination in a truncated Configuration Interaction (CI) space. Your implementation must be a single, runnable program that constructs the many-body Hamiltonian, computes its lowest eigenstates, evaluates the expectation value of the center-of-mass Hamiltonian for each eigenstate, and applies a variational filter by augmenting the Hamiltonian with a center-of-mass penalty. All steps must start from first principles without using closed-form matrix elements that shortcut the derivations.\n\nThe physical model is as follows. Consider two distinguishable nucleons of mass $m$ moving in one spatial dimension. Adopt natural units with reduced Planck constant $\\hbar = 1$ and mass $m = 1$. The single-particle confining field is a harmonic oscillator with angular frequency $\\omega > 0$. The two-body interaction is translationally invariant and depends only on the relative coordinate, taken as a finite-range Gaussian potential of strength $V_0$ and range $a > 0$:\n$$\nV(x_1, x_2) = V_0 \\exp\\!\\left(-\\frac{(x_1 - x_2)^2}{2 a^2}\\right).\n$$\nThe full two-body Hamiltonian is\n$$\nH = \\sum_{i=1}^2 \\left(\\frac{p_i^2}{2 m} + \\frac{1}{2} m \\omega^2 x_i^2\\right) + V(x_1, x_2),\n$$\nwith $\\hbar = 1$ and $m = 1$ to be used in all numerical results. The center-of-mass (CM) Hamiltonian in one dimension for $A=2$ particles is\n$$\nH_{\\mathrm{cm}} = \\frac{P_{\\mathrm{cm}}^2}{2 A m} + \\frac{1}{2} A m \\omega^2 R_{\\mathrm{cm}}^2 - \\frac{1}{2}\\,\\omega,\n$$\nwhere $A = 2$, $R_{\\mathrm{cm}} = \\frac{x_1 + x_2}{2}$, and $P_{\\mathrm{cm}} = p_1 + p_2$. The subtraction of $\\frac{1}{2}\\,\\omega$ sets the ground $0S$ center-of-mass mode to zero expectation value. In an exact (untruncated) calculation with a translationally invariant interaction, any eigenstate with a center-of-mass ground component has $\\langle H_{\\mathrm{cm}} \\rangle = 0$, while spurious center-of-mass excitations yield $\\langle H_{\\mathrm{cm}} \\rangle \\approx n_{\\mathrm{cm}} \\,\\omega$ with integer $n_{\\mathrm{cm}} \\ge 1$. In a truncated CI space, spurious mixtures lead to nonzero $\\langle H_{\\mathrm{cm}} \\rangle$ in states that should be free of center-of-mass excitations.\n\nYour computational task is to perform a Rayleigh–Ritz calculation in a truncated CI space and to quantify and filter center-of-mass contamination.\n\n1. Basis and truncation. Use the one-dimensional harmonic oscillator single-particle eigenfunctions $\\{\\varphi_n(x)\\}_{n=0}^{n_{\\max}}$ as your finite basis for each particle, with oscillator length $b = \\sqrt{1/\\omega}$. The two-body CI basis is the direct-product $\\{\\varphi_{n_1}(x_1)\\varphi_{n_2}(x_2)\\}$ with $0 \\le n_1, n_2 \\le n_{\\max}$, which constitutes a truncation by the single-particle maximum quantum number $n_{\\max}$. This truncation does not enforce a fixed total quanta and therefore breaks exact factorization of intrinsic and center-of-mass motion, enabling spurious contamination to appear.\n\n2. Variational principle and Rayleigh–Ritz. Starting from the time-independent Schrödinger equation and the Rayleigh quotient\n$$\n\\mathcal{E}[\\psi] = \\frac{\\langle \\psi| H | \\psi\\rangle}{\\langle \\psi|\\psi\\rangle},\n$$\napply the Rayleigh–Ritz method by expanding trial states $|\\psi\\rangle$ in the truncated CI basis and diagonalizing the Hamiltonian matrix to obtain approximate eigenvalues and eigenvectors.\n\n3. Operator construction. Construct the single-particle position and momentum operators using the canonical commutation relation and ladder operators,\n$$\nx = \\sqrt{\\frac{1}{2 \\omega}}\\,(a + a^\\dagger),\\qquad p = \\mathrm{i}\\sqrt{\\frac{\\omega}{2}}\\,(a^\\dagger - a),\n$$\nthen form $x^2$ and $p^2$ matrices in the truncated single-particle basis by matrix multiplication. Assemble the two-body operators via Kronecker products to form the one-body part of $H$ on the CI basis. For the two-body Gaussian interaction, do not use closed-form matrix elements. Instead, evaluate the matrix elements\n$$\n\\langle n_1 n_2 | V | n_1' n_2' \\rangle = \\int_{-\\infty}^{\\infty}\\!\\!\\int_{-\\infty}^{\\infty} \\varphi_{n_1}(x_1)\\varphi_{n_2}(x_2) V(x_1-x_2) \\varphi_{n_1'}(x_1)\\varphi_{n_2'}(x_2)\\, \\mathrm{d}x_1 \\mathrm{d}x_2\n$$\nnumerically using Gauss–Hermite quadrature with a sufficient number of points to achieve stable results across the provided test cases. You may exploit the polynomial–Gaussian structure of $\\varphi_n$ to use Gauss–Hermite rules that integrate functions of the form $e^{-y^2}$ times a smooth function, taking care to use the correct oscillator length scaling for general $\\omega$.\n\n4. Center-of-mass Hamiltonian. Derive and implement $H_{\\mathrm{cm}}$ in terms of single-particle operators $x_1, x_2, p_1, p_2$ on the CI basis without transforming to relative and center-of-mass coordinates. Then compute $\\langle H_{\\mathrm{cm}} \\rangle$ for each CI eigenstate as a diagnostic of spurious contamination.\n\n5. Variational filtering (Lawson method). Define the penalized Hamiltonian\n$$\nH_\\beta = H + \\beta\\, H_{\\mathrm{cm}},\n$$\nwith penalty parameter $\\beta \\ge 0$. Diagonalize $H_\\beta$ to obtain the lowest eigenstates. Use a threshold $\\tau > 0$ and filter out any states with $\\langle H_{\\mathrm{cm}} \\rangle > \\tau$ among the lowest $k$ eigenstates, where $k$ is specified per test case.\n\nImplementation requirements:\n- Adopt units with $\\hbar = 1$ and $m = 1$, so all energies are in units of $\\omega$ and lengths in units of $b = \\sqrt{1/\\omega}$.\n- Angles do not appear, so no angle units are needed.\n- Your program must produce, for each test case, the integer count of eigenstates among the lowest $k$ eigenstates of $H_\\beta$ whose center-of-mass expectation value satisfies $\\langle H_{\\mathrm{cm}} \\rangle \\le \\tau$. Aggregate these counts for all test cases into a single output line as described below.\n\nTest suite. Run your program on the following parameter sets, each specified as a tuple $\\left(n_{\\max}, \\omega, V_0, a, k, \\tau, \\beta\\right)$:\n- Case $1$: $\\left(4,\\, 1.0,\\, -0.6,\\, 0.8,\\, 6,\\, 0.02,\\, 0.0\\right)$\n- Case $2$: $\\left(4,\\, 1.0,\\, -0.6,\\, 0.8,\\, 6,\\, 0.02,\\, 10.0\\right)$\n- Case $3$: $\\left(3,\\, 1.2,\\, -0.6,\\, 0.5,\\, 6,\\, 0.02,\\, 10.0\\right)$\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For the above three cases, the output must be of the form\n$$\n[\\text{count}_1,\\text{count}_2,\\text{count}_3],\n$$\nwhere each $\\text{count}_i$ is an integer as defined above. No other text should be printed. All numerical calculations must be performed by your code; do not hard-code expected values.", "solution": "The solution proceeds as follows:\nFirst, for each test case, we define the parameters of the model: the single-particle basis truncation $n_{\\max}$, harmonic oscillator frequency $\\omega$, interaction strength $V_0$ and range $a$, and the parameters for the Lawson filtering method $k, \\tau, \\beta$. We work in natural units where $\\hbar=1$ and the nucleon mass $m=1$.\n\nThe single-particle basis consists of the eigenstates of the one-dimensional quantum harmonic oscillator (QHO), $\\{|n\\rangle\\}$, truncated at $n=n_{\\max}$. The dimension of this single-particle space is $N_{sp} = n_{\\max}+1$.\n\nThe single-particle operators for position $x$ and momentum $p$ are constructed in this truncated basis. We start with the matrix representations of the ladder operators, $a$ and $a^\\dagger$, defined by their action on the basis states, $\\langle n' | a | n \\rangle = \\sqrt{n}\\,\\delta_{n',n-1}$ and $\\langle n' | a^\\dagger | n \\rangle = \\sqrt{n+1}\\,\\delta_{n',n+1}$. The $x$ and $p$ matrices are then formed using their standard definitions in terms of $a$ and $a^\\dagger$:\n$$\nx = \\sqrt{\\frac{1}{2 \\omega}}\\,(a + a^\\dagger),\\qquad p = \\mathrm{i}\\sqrt{\\frac{\\omega}{2}}\\,(a^\\dagger - a)\n$$\nThe matrices for $x^2$ and $p^2$ are obtained by matrix multiplication of the $x$ and $p$ matrices, respectively. It is important to note that due to the basis truncation, the canonical commutation relation $[x,p]=i$ is not perfectly satisfied, which is an expected artifact of the method.\n\nThe two-body CI basis is a direct product of the single-particle bases: $\\{|n_1 n_2\\rangle = |n_1\\rangle \\otimes |n_2\\rangle\\}$, where $0 \\le n_1, n_2 \\le n_{\\max}$. The dimension of this two-body space is $N_{basis} = N_{sp}^2$. Two-body operators are constructed as Kronecker products of the single-particle operators. For example, $x_1$ is represented by $x \\otimes I$ and $x_2$ by $I \\otimes x$, where $I$ is the identity matrix in the single-particle space.\n\nThe full Hamiltonian $H = H_{1-body} + V$ is constructed in the two-body basis. The one-body part, representing the kinetic energy and harmonic confinement, is formed from the single-particle Hamiltonian matrices $h = p^2/2 + \\omega^2 x^2/2$ as $H_{1-body} = h \\otimes I + I \\otimes h$.\n\nThe matrix elements of the two-body Gaussian interaction, $\\langle n_1 n_2 | V | n_1' n_2' \\rangle$, are calculated numerically using Gauss-Hermite quadrature as specified. The integral is transformed to dimensionless coordinates $y_i = x_i/b$ where $b=\\sqrt{1/\\omega}$ is the oscillator length. The $e^{-y_1^2-y_2^2}$ factor arising from the QHO wavefunctions is absorbed into the quadrature weights, and the remaining smooth function is evaluated at the quadrature points. A sufficiently large number of quadrature points is used to ensure numerical stability and accuracy.\n\nThe center-of-mass Hamiltonian $H_{cm}$ is also constructed in the two-body basis from the single-particle operators, using its definition:\n$$\nH_{\\mathrm{cm}} = \\frac{P_{\\mathrm{cm}}^2}{4} + \\omega^2 R_{\\mathrm{cm}}^2 - \\frac{\\omega}{2}\n$$\nwhere $R_{cm} = (x_1+x_2)/2$ and $P_{cm} = p_1+p_2$.\n\nThe Lawson method is implemented by forming the penalized Hamiltonian $H_\\beta = H + \\beta H_{cm}$. This matrix is diagonalized to find its eigenvalues and eigenvectors. The eigenvectors represent the approximate eigenstates of the system as per the Rayleigh-Ritz method.\n\nFinally, for each of the $k$ lowest-energy eigenstates obtained from diagonalizing $H_\\beta$, we compute the expectation value of the original center-of-mass Hamiltonian, $\\langle H_{cm} \\rangle$. We then count how many of these $k$ states satisfy the condition $\\langle H_{cm} \\rangle \\le \\tau$. This count is the result for one test case. The process is repeated for all cases provided in the test suite.", "answer": "```python\n# language: Python\n# version: 3.12\n# libraries:\n#   name: numpy\n#   version: 1.23.5\n#   name: scipy\n#   version: 1.11.4\n\nimport numpy as np\nfrom scipy.special import roots_hermite, eval_hermite\nfrom scipy.linalg import eigh\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the calculation for all test cases.\n    It implements the Rayleigh-Ritz method for a two-nucleon system in a \n    truncated harmonic oscillator basis, including diagnostics and filtering \n    of center-of-mass excitations.\n    \"\"\"\n    \n    # Test suite from the problem statement\n    test_cases = [\n        # (n_max, omega, V0, a, k, tau, beta)\n        (4, 1.0, -0.6, 0.8, 6, 0.02, 0.0),\n        (4, 1.0, -0.6, 0.8, 6, 0.02, 10.0),\n        (3, 1.2, -0.6, 0.5, 6, 0.02, 10.0),\n    ]\n\n    results = []\n    \n    # Using a fixed large number of quadrature points for stability\n    # across all test cases.\n    N_quad = 60\n    yq, wq = roots_hermite(N_quad)\n\n    for case in test_cases:\n        n_max, omega, V0, a, k, tau, beta = case\n        \n        # 1. Setup basis and physical constants in natural units (hbar=1, m=1)\n        N_sp = n_max + 1\n        N_basis = N_sp ** 2\n        \n        hbar = 1.0\n        m = 1.0\n        b = np.sqrt(hbar / (m * omega))  # HO length scale\n\n        # 2. Construct single-particle operators in the truncated HO basis { |n> }\n        # Ladder operators (annihilation and creation)\n        a_op = np.zeros((N_sp, N_sp), dtype=float)\n        for n in range(1, N_sp):\n            a_op[n - 1, n] = np.sqrt(n)\n        adag_op = a_op.T\n        \n        # Position and momentum operators from ladder operators\n        x_sp = np.sqrt(hbar / (2 * m * omega)) * (a_op + adag_op)\n        p_sp = 1j * np.sqrt(m * hbar * omega / 2) * (adag_op - a_op)\n        \n        # 3. Construct two-body operators from single-particle ones via Kronecker product\n        I_sp = np.identity(N_sp)\n        I_basis = np.identity(N_basis)\n        \n        X1 = np.kron(x_sp, I_sp)\n        X2 = np.kron(I_sp, x_sp)\n        P1 = np.kron(p_sp, I_sp)\n        P2 = np.kron(I_sp, p_sp)\n        \n        # 4. Construct the many-body Hamiltonian matrix H\n        # One-body part: H_1b = sum_i(p_i^2/2m + 1/2 m omega^2 x_i^2)\n        p2_sp = p_sp @ p_sp\n        x2_sp = x_sp @ x_sp\n        h_sp = (1 / (2 * m)) * p2_sp + (m * omega**2 / 2) * x2_sp\n        H_1body = np.kron(h_sp, I_sp) + np.kron(I_sp, h_sp)\n        \n        # Two-body part: V(x1, x2) matrix from numerical quadrature\n        # Precompute values for efficiency\n        fact = [math.factorial(i) for i in range(2 * n_max + 2)]\n        hermite_vals = np.zeros((N_sp, N_quad))\n        for n in range(N_sp):\n            hermite_vals[n, :] = eval_hermite(n, yq)\n            \n        psi_poly_parts = np.zeros((N_sp, N_quad))\n        for n in range(N_sp):\n            norm = 1.0 / np.sqrt(np.sqrt(np.pi) * (2**n) * fact[n])\n            psi_poly_parts[n, :] = norm * hermite_vals[n, :]\n            \n        V_mat = np.zeros((N_basis, N_basis))\n\n        # Helper to map a flat index to (n1, n2) quantum numbers\n        def get_n_tuple(idx, n_sp_dim):\n            return idx // n_sp_dim, idx % n_sp_dim\n\n        for i in range(N_basis):\n            for j in range(i, N_basis):  # Exploit symmetry V_ij = V_ji\n                n1, n2 = get_n_tuple(i, N_sp)\n                n1p, n2p = get_n_tuple(j, N_sp)\n\n                term_y1 = psi_poly_parts[n1, :] * psi_poly_parts[n1p, :]\n                term_y2 = psi_poly_parts[n2, :] * psi_poly_parts[n2p, :]\n                poly_part = np.outer(term_y1, term_y2)\n                \n                y1_grid, y2_grid = np.meshgrid(yq, yq)\n                exp_arg = -b**2 * (y1_grid - y2_grid)**2 / (2 * a**2)\n                interaction_part = V0 * np.exp(exp_arg)\n                \n                integrand = poly_part * interaction_part\n                integral = np.einsum('i,j,ij->', wq, wq, integrand)\n                \n                V_mat[i, j] = integral\n                if i != j:\n                    V_mat[j, i] = integral\n\n        H_mat = H_1body + V_mat\n        H_mat = np.real(H_mat)\n\n        # 5. Construct the center-of-mass Hamiltonian H_cm\n        A = 2.0  # Number of nucleons\n        R_cm_op = (X1 + X2) / A\n        P_cm_op = P1 + P2\n        \n        H_cm_mat = (1 / (2 * A * m)) * (P_cm_op @ P_cm_op) + \\\n                   (A * m * omega**2 / 2) * (R_cm_op @ R_cm_op) - \\\n                   0.5 * hbar * omega * I_basis\n        H_cm_mat = np.real(H_cm_mat)\n\n        # 6. Apply Lawson's method: create and diagonalize H_beta = H + beta*H_cm\n        H_beta_mat = H_mat + beta * H_cm_mat\n        eigenvalues, eigenvectors = eigh(H_beta_mat)\n        \n        # 7. Analyze results: count states with small <H_cm>\n        count = 0\n        num_states_to_check = min(k, N_basis)\n        \n        for i in range(num_states_to_check):\n            eigenvector = eigenvectors[:, i]\n            # Compute expectation value <psi_i| H_cm |psi_i>\n            h_cm_exp = eigenvector.conj().T @ H_cm_mat @ eigenvector\n            h_cm_exp = np.real(h_cm_exp)\n            \n            if h_cm_exp <= tau:\n                count += 1\n                \n        results.append(count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3610851"}, {"introduction": "The effectiveness of a variational calculation is critically dependent on the choice of basis. This advanced practice delves into how the energy changes with respect to the nonlinear parameters defining the basis functions themselves. You will derive and compute the energy gradient, decomposing it into the physically insightful Hellmann–Feynman and Pulay contributions, and verify your analytical results numerically—a crucial skill for any work involving basis set optimization [@problem_id:3610859].", "problem": "Consider a one-dimensional nonrelativistic particle in natural units where $\\hbar=1$ and $m=1$. The physical Hamiltonian $H_{\\mathrm{phys}}(b)$ is defined as $H_{\\mathrm{phys}}(b)=T+V(b)$, where $T=-\\frac{1}{2}\\frac{d^2}{dx^2}$ and $V(b)=\\frac{1}{2}\\omega(b)^2 x^2$ with $\\omega(b)=b$. Let the trial state $|\\psi(b)\\rangle$ be obtained by the Rayleigh-Ritz method (variational approximation) using a non-orthonormal Gaussian basis $\\{\\phi_i(x;b)\\}_{i=0}^{N-1}$ with $\\phi_i(x;b)=\\exp\\!\\big(-\\alpha_i(b)x^2\\big)$ and $\\alpha_i(b)=\\alpha_0\\,r^{i}/b^2$, where $N$ is the number of basis functions, $\\alpha_0$ is a positive scale, $r>1$ is a geometric ratio, and $b>0$ is the variational length parameter. The Rayleigh-Ritz Generalized Eigenvalue Problem (GEP) for this non-orthonormal basis reads $H(b)\\mathbf{c} = E(b) S(b)\\mathbf{c}$, where $H_{ij}(b)=\\langle \\phi_i(b)|H_{\\mathrm{phys}}(b)|\\phi_j(b)\\rangle$, $S_{ij}(b)=\\langle \\phi_i(b)|\\phi_j(b)\\rangle$, and $\\mathbf{c}$ is the coefficient vector of the approximate ground state $|\\psi(b)\\rangle = \\sum_i c_i |\\phi_i(b)\\rangle$. All energies and $b$ are dimensionless in these units.\n\nYour task is to compute the analytic gradient $dE/db$ at given $(N,\\alpha_0,r,b)$ by decomposing it into the Hellmann–Feynman (HF) and Pulay contributions and to verify numerical consistency by finite differences. Specifically:\n\n- The Rayleigh-Ritz energy is the Rayleigh quotient $E(b) = \\dfrac{\\mathbf{c}^\\top H(b)\\mathbf{c}}{\\mathbf{c}^\\top S(b)\\mathbf{c}}$ at the stationary solution of the GEP $H(b)\\mathbf{c}=E(b)S(b)\\mathbf{c}$.\n- Define the Hellmann–Feynman (HF) contribution as the expectation value of the explicit derivative of the physical Hamiltonian with respect to $b$ at fixed basis functions, $E_{\\mathrm{HF}}(b)=\\mathbf{c}^\\top\\big(\\partial H_{\\mathrm{phys}}(b)/\\partial b\\big)_{\\mathrm{proj}}\\mathbf{c}$, where the subscript “proj” indicates matrix elements taken in the fixed basis $\\{\\phi_i(x;b)\\}$ without differentiating the basis functions themselves.\n- Define the Pulay contribution as $E_{\\mathrm{Pulay}}(b)=\\left.\\dfrac{dE}{db}\\right|_{\\mathrm{analytic}} - E_{\\mathrm{HF}}(b)$, where $\\left.\\dfrac{dE}{db}\\right|_{\\mathrm{analytic}}$ is the analytic derivative obtained from variational principles applied to the non-orthonormal basis and generalized normalization constraint.\n- Verify numerically that $\\left.\\dfrac{dE}{db}\\right|_{\\mathrm{analytic}}$ is consistent with the central finite-difference approximation $\\left.\\dfrac{dE}{db}\\right|_{\\mathrm{FD}} \\approx \\dfrac{E(b+\\varepsilon) - E(b-\\varepsilon)}{2\\varepsilon}$ for a small step $\\varepsilon>0$.\n\nAll matrix elements must be computed exactly by Gaussian integration. For the Gaussian pair characterized by $\\alpha_i(b)$ and $\\alpha_j(b)$, define $\\gamma_{ij}(b)=\\alpha_i(b)+\\alpha_j(b)$ and use the following integral facts (to be derived in the solution):\n\n- $S_{ij}(b) = \\displaystyle \\int_{-\\infty}^{\\infty} e^{-\\gamma_{ij}(b)x^2}\\,dx = \\dfrac{\\sqrt{\\pi}}{\\sqrt{\\gamma_{ij}(b)}}$.\n- $T_{ij}(b) = \\displaystyle \\frac{1}{2}\\int_{-\\infty}^{\\infty}\\frac{d\\phi_i}{dx}\\frac{d\\phi_j}{dx}\\,dx = \\dfrac{\\alpha_i(b)\\alpha_j(b)\\sqrt{\\pi}}{\\gamma_{ij}(b)^{3/2}}$.\n- $V_{ij}(b) = \\displaystyle \\frac{1}{2}\\omega(b)^2 \\int_{-\\infty}^{\\infty} x^2 e^{-\\gamma_{ij}(b)x^2}\\,dx = \\dfrac{\\omega(b)^2 \\sqrt{\\pi}}{4\\,\\gamma_{ij}(b)^{3/2}}$.\n\nIn addition, you must compute the analytic derivatives $dS/db$ and $dH/db$, where $H=T+V$, using the dependence $\\alpha_i(b)=\\alpha_0\\,r^{i}/b^2$ and $\\omega(b)=b$. The Hellmann–Feynman contribution only includes the explicit derivative $\\partial V/\\partial b$ at fixed $\\gamma_{ij}$.\n\nTest Suite:\nProvide results for the following parameter sets $(N,\\alpha_0,r,b,\\varepsilon)$:\n\n1. $(3,0.5,1.7,1.0,10^{-6})$.\n2. $(5,0.4,1.5,0.8,10^{-6})$.\n3. $(2,0.6,2.0,1.2,10^{-6})$.\n4. $(6,0.3,1.7,1.6,10^{-6})$.\n\nYour program should:\n- Solve the generalized eigenvalue problem for each case to obtain the lowest eigenvalue $E(b)$ and corresponding $S$-normalized eigenvector $\\mathbf{c}$ satisfying $\\mathbf{c}^\\top S(b)\\mathbf{c}=1$.\n- Compute $E_{\\mathrm{HF}}(b)$, $E_{\\mathrm{Pulay}}(b)$, the total analytic derivative $\\left.\\dfrac{dE}{db}\\right|_{\\mathrm{analytic}}$, and the finite-difference derivative $\\left.\\dfrac{dE}{db}\\right|_{\\mathrm{FD}}$ using central differences with step $\\varepsilon$.\n- Return, for each test case, the list $[E_{\\mathrm{HF}}(b),E_{\\mathrm{Pulay}}(b),\\left.\\dfrac{dE}{db}\\right|_{\\mathrm{analytic}},\\left.\\dfrac{dE}{db}\\right|_{\\mathrm{FD}},|\\left.\\dfrac{dE}{db}\\right|_{\\mathrm{analytic}}-\\left.\\dfrac{dE}{db}\\right|_{\\mathrm{FD}}|]$.\n\nFinal Output Format:\nYour program should produce a single line of output containing a comma-separated list of these lists, enclosed in square brackets; for example, the output should look like $[[a_1,b_1,c_1,d_1,e_1],[a_2,b_2,c_2,d_2,e_2],\\ldots]$. All quantities are dimensionless and must be reported as floating-point numbers without units.", "solution": "The task is to compute the total analytic derivative of the Rayleigh-Ritz energy, $\\frac{dE}{db}$, and decompose it into its Hellmann-Feynman and Pulay components.\n\n#### 1. Analytic Matrix Elements and their Derivatives\nFirst, we construct the Hamiltonian matrix $H(b)$ and overlap matrix $S(b)$ using the provided integral formulas and basis set definitions. Let $\\gamma_{ij}(b) = \\alpha_i(b) + \\alpha_j(b)$. Since $\\alpha_k(b) = \\alpha_0 r^k b^{-2}$, the derivatives with respect to $b$ are $\\frac{d\\alpha_k}{db} = -2\\frac{\\alpha_k}{b}$ and thus $\\frac{d\\gamma_{ij}}{db} = -2\\frac{\\gamma_{ij}}{b}$.\n\nThe derivatives of the matrix elements are found using the chain rule:\n- **Overlap matrix**: $S_{ij}(b) = \\sqrt{\\pi}\\gamma_{ij}^{-1/2}$.\n  $$ \\frac{dS_{ij}}{db} = \\frac{d S_{ij}}{d\\gamma_{ij}} \\frac{d\\gamma_{ij}}{db} = \\sqrt{\\pi}\\left(-\\frac{1}{2}\\gamma_{ij}^{-3/2}\\right)\\left(-2\\frac{\\gamma_{ij}}{b}\\right) = \\frac{1}{b}\\left(\\sqrt{\\pi}\\gamma_{ij}^{-1/2}\\right) = \\frac{S_{ij}}{b} $$\n- **Kinetic energy matrix**: $T_{ij}(b) = \\alpha_i\\alpha_j\\sqrt{\\pi}\\gamma_{ij}^{-3/2}$. The dependence on $b$ is $T_{ij} \\propto (b^{-2})(b^{-2})(b^{-2})^{-3/2} \\propto b^{-4}b^{3} \\propto b^{-1}$.\n  $$ \\frac{dT_{ij}}{db} = -\\frac{T_{ij}}{b} $$\n- **Potential energy matrix**: $V_{ij}(b) = \\frac{b^2\\sqrt{\\pi}}{4\\gamma_{ij}^{3/2}}$. The dependence on $b$ is $V_{ij} \\propto b^2(b^{-2})^{-3/2} \\propto b^2 b^3 \\propto b^5$.\n  $$ \\frac{dV_{ij}}{db} = \\frac{5V_{ij}}{b} $$\nThe derivative of the Hamiltonian matrix $H = T+V$ is therefore $\\frac{dH_{ij}}{db} = \\frac{1}{b}(-T_{ij} + 5V_{ij})$.\n\n#### 2. Total Analytic Derivative $\\frac{dE}{db}$\nFor a parameter-dependent, non-orthogonal basis, the derivative of the energy eigenvalue is given by the generalized Hellmann-Feynman theorem:\n$$ \\frac{dE}{db} = \\mathbf{c}^\\top\\left(\\frac{dH}{db} - E\\frac{dS}{db}\\right)\\mathbf{c} $$\nwhere $\\mathbf{c}$ is the $S$-normalized eigenvector ($\\mathbf{c}^\\top S \\mathbf{c} = 1$). Substituting the matrix derivatives:\n$$ \\left.\\frac{dE}{db}\\right|_{\\mathrm{analytic}} = \\mathbf{c}^\\top\\left(\\frac{1}{b}(-T + 5V) - E\\frac{S}{b}\\right)\\mathbf{c} = \\frac{1}{b}(-\\langle T \\rangle + 5\\langle V \\rangle - E) $$\nUsing $E = \\langle T \\rangle + \\langle V \\rangle$, this simplifies to:\n$$ \\left.\\frac{dE}{db}\\right|_{\\mathrm{analytic}} = \\frac{1}{b}(-\\langle T \\rangle + 5\\langle V \\rangle - (\\langle T \\rangle + \\langle V \\rangle)) = \\frac{2}{b}(2\\langle V \\rangle - \\langle T \\rangle) $$\n\n#### 3. Hellmann-Feynman and Pulay Contributions\n- The **Hellmann-Feynman (HF) contribution** is the expectation value of the explicit derivative of the Hamiltonian, $\\frac{\\partial H_{\\mathrm{phys}}}{\\partial b} = \\frac{\\partial}{\\partial b}\\left(\\frac{1}{2}b^2 x^2\\right) = b x^2$. The matrix for this operator is $\\langle\\phi_i|bx^2|\\phi_j\\rangle = b\\langle\\phi_i|x^2|\\phi_j\\rangle = b\\left(\\frac{2V_{ij}}{b^2}\\right) = \\frac{2V_{ij}}{b}$.\n  $$ E_{\\mathrm{HF}}(b) = \\mathbf{c}^\\top \\left(\\frac{2V}{b}\\right) \\mathbf{c} = \\frac{2}{b}\\langle V \\rangle $$\n- The **Pulay contribution** is the remainder, which arises from the dependence of the basis functions on $b$:\n  $$ E_{\\mathrm{Pulay}}(b) = \\left.\\frac{dE}{db}\\right|_{\\mathrm{analytic}} - E_{\\mathrm{HF}}(b) = \\frac{2}{b}(2\\langle V \\rangle - \\langle T \\rangle) - \\frac{2}{b}\\langle V \\rangle = \\frac{2}{b}(\\langle V \\rangle - \\langle T \\rangle) $$\n\n#### 4. Numerical Verification\nThe analytic result is verified by computing the central finite-difference approximation:\n$$ \\left.\\frac{dE}{db}\\right|_{\\mathrm{FD}} \\approx \\frac{E(b+\\varepsilon) - E(b-\\varepsilon)}{2\\varepsilon} $$\nThis involves solving the GEP for the energies $E(b+\\varepsilon)$ and $E(b-\\varepsilon)$. The provided Python script implements these calculations for each test case, computes the five required quantities, and confirms that the analytic and numerical derivatives are consistent.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the analytic and finite-difference derivatives of the ground state energy\n    of a quantum harmonic oscillator using a parameter-dependent Gaussian basis set.\n    \"\"\"\n    test_cases = [\n        (3, 0.5, 1.7, 1.0, 10**-6),\n        (5, 0.4, 1.5, 0.8, 10**-6),\n        (2, 0.6, 2.0, 1.2, 10**-6),\n        (6, 0.3, 1.7, 1.6, 10**-6),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, alpha0, r, b, epsilon = case\n        \n        # --- Step 1: Solve GEP at the central point b ---\n        S, T, V = get_matrices(b, N, alpha0, r)\n        H = T + V\n        \n        # Solve the generalized eigenvalue problem H*c = E*S*c\n        # eigh returns eigenvalues in ascending order and corresponding eigenvectors\n        # For scipy.linalg.eigh, eigenvectors are normalized as c.T @ S @ c = 1.\n        eigenvalues, eigenvectors = eigh(H, S)\n        \n        energy = eigenvalues[0]\n        c = eigenvectors[:, 0]\n        \n        # --- Step 2: Compute expectation values ---\n        exp_T = c.T @ T @ c\n        exp_V = c.T @ V @ c\n        \n        # --- Step 3: Compute analytic derivatives ---\n        # Hellmann-Feynman contribution: E_HF = (2/b) * <V>\n        E_hf = (2.0 / b) * exp_V\n        \n        # Pulay contribution: E_Pulay = (2/b) * (<V> - <T>)\n        E_pulay = (2.0 / b) * (exp_V - exp_T)\n        \n        # Total analytic derivative\n        dE_analytic = E_hf + E_pulay\n        \n        # --- Step 4: Compute finite-difference derivative ---\n        # Energy at b + epsilon\n        S_p, T_p, V_p = get_matrices(b + epsilon, N, alpha0, r)\n        H_p = T_p + V_p\n        eigvals_p, _ = eigh(H_p, S_p)\n        E_plus = eigvals_p[0]\n        \n        # Energy at b - epsilon\n        S_m, T_m, V_m = get_matrices(b - epsilon, N, alpha0, r)\n        H_m = T_m + V_m\n        eigvals_m, _ = eigh(H_m, S_m)\n        E_minus = eigvals_m[0]\n        \n        dE_fd = (E_plus - E_minus) / (2.0 * epsilon)\n        \n        # --- Step 5: Compute error and store results ---\n        error = abs(dE_analytic - dE_fd)\n        \n        results.append([E_hf, E_pulay, dE_analytic, dE_fd, error])\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\ndef get_matrices(b_val, N, alpha0, r):\n    \"\"\"\n    Constructs the overlap (S), kinetic (T), and potential (V) energy matrices\n    for a given set of basis set parameters.\n    \n    Args:\n        b_val (float): The variational length parameter b.\n        N (int): The number of basis functions.\n        alpha0 (float): The scale parameter for the Gaussian exponents.\n        r (float): The geometric ratio for the Gaussian exponents.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray, np.ndarray]: The S, T, and V matrices.\n    \"\"\"\n    S = np.zeros((N, N))\n    T = np.zeros((N, N))\n    V = np.zeros((N, N))\n    \n    alphas = [alpha0 * (r**i) / b_val**2 for i in range(N)]\n    sqrt_pi = np.sqrt(np.pi)\n    \n    for i in range(N):\n        for j in range(i, N):\n            alpha_i = alphas[i]\n            alpha_j = alphas[j]\n            gamma_ij = alpha_i + alpha_j\n            \n            # Overlap matrix S\n            S_ij = sqrt_pi / np.sqrt(gamma_ij)\n            \n            # Kinetic energy matrix T\n            T_ij = (alpha_i * alpha_j * sqrt_pi) / (gamma_ij**1.5)\n            \n            # Potential energy matrix V\n            V_ij = (b_val**2 * sqrt_pi) / (4 * gamma_ij**1.5)\n            \n            S[i, j] = S[j, i] = S_ij\n            T[i, j] = T[j, i] = T_ij\n            V[i, j] = V[j, i] = V_ij\n            \n    return S, T, V\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3610859"}]}