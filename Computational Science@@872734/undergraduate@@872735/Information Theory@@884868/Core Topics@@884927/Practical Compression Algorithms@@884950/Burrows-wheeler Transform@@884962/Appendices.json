{"hands_on_practices": [{"introduction": "To truly grasp the Burrows-Wheeler Transform, we must begin by performing the transformation ourselves. This first exercise guides you through the core mechanical steps of the forward BWT: generating all cyclic shifts of a string, sorting them lexicographically, and extracting the final transformed sequence, known as the $L$ column. This hands-on process is fundamental to understanding how the BWT rearranges data to group similar characters together.", "problem": "The Burrows-Wheeler Transform (BWT) is a reversible permutation of a string's characters, widely used in data compression algorithms. The transformation process is as follows:\n\n1.  Given an input string `S` of length `n`, append a special end-of-string marker, denoted by `$`. This marker is not present in the original string and is defined to be lexicographically smaller than any other character in the string. Let the new string be `T`.\n2.  Generate all `n+1` cyclic shifts (or rotations) of the string `T`.\n3.  Sort these cyclic shifts lexicographically (alphabetically).\n4.  The output of the BWT, denoted as `L`, is the string formed by concatenating the last character of each sorted cyclic shift.\n\nGiven the binary input string `S = 101101`, determine its Burrows-Wheeler Transform `L`.\n\nWhich of the following represents the correct BWT output `L`?\n\nA. `11101$0`\n\nB. `$001111`\n\nC. `1101$01`\n\nD. `0$10111`\n\nE. `101101$`", "solution": "We begin with the input string $S=\\text{101101}$ and append the special end-of-string marker, which is defined to be lexicographically smaller than any other character. This produces $T=\\text{101101\\$}$.\n\nGenerate all cyclic shifts of $T$:\n- $\\text{r}_{0}=\\text{101101\\$}$\n- $\\text{r}_{1}=\\text{01101\\$1}$\n- $\\text{r}_{2}=\\text{1101\\$10}$\n- $\\text{r}_{3}=\\text{101\\$101}$\n- $\\text{r}_{4}=\\text{01\\$1011}$\n- $\\text{r}_{5}=\\text{1\\$10110}$\n- $\\text{r}_{6}=\\text{\\$101101}$\n\nSort these cyclic shifts lexicographically using the order $\\$\\lt 0 \\lt 1$:\n- $\\text{r}_{6}=\\text{\\$101101}$\n- $\\text{r}_{4}=\\text{01\\$1011}$\n- $\\text{r}_{1}=\\text{01101\\$1}$\n- $\\text{r}_{5}=\\text{1\\$10110}$\n- $\\text{r}_{3}=\\text{101\\$101}$\n- $\\text{r}_{0}=\\text{101101\\$}$\n- $\\text{r}_{2}=\\text{1101\\$10}$\n\nForm $L$ by taking the last character of each sorted row in order. The last characters are, respectively: $1,1,1,0,1,\\$,0$. Concatenating these gives the BWT output that matches option A.", "answer": "$$\\boxed{A}$$", "id": "1606440"}, {"introduction": "The power of the BWT lies in its reversibility, which is essential for any practical compression scheme. This exercise focuses on the elegant inverse transformation process, which relies on the \"Last-to-First\" (LF) mapping property. By working through the reconstruction of a string from its $L$ column and primary index, you will learn the algorithm that makes BWT-based data recovery possible.", "problem": "The Burrows-Wheeler Transform (BWT) is a reversible text transformation used in data compression algorithms. It rearranges a string of characters into runs of similar characters, which is often more compressible. The transform of an input string is generated by creating a conceptual matrix of all cyclic shifts of the string, sorting these shifts lexicographically, and then extracting the last column of this matrix.\n\nThe output of the BWT consists of two components:\n1.  The transformed string `L`, which is the last column of the sorted matrix of cyclic shifts.\n2.  A primary index `I`, which is the 0-based row index of the original string in the sorted matrix.\n\nTo ensure the original string has a unique representation in the sorted list of shifts and to mark its end, a special end-of-string character, denoted as `$`, is appended to the input string before the transform. This character is defined to be lexicographically smaller than any other character in the alphabet.\n\nGiven the last column `L = 'bb$aa'` and the primary index `I = 2`, determine the original input string. Your final answer should be the reconstructed string *without* the `$` character.", "solution": "We invert the Burrows-Wheeler Transform using the LF-mapping. Let $L$ be the last column, of length $n$. Define the first column $F$ as the characters of $L$ sorted lexicographically, with the end-of-string character $\\$$ ordered before any other character. Define the function $C(c)$ as the number of characters in $L$ that are strictly less than $c$, and for each position $j$ in $L$, define the rank $r(j)$ as the number of occurrences of $L[j]$ in $L[0..j]$. The LF-mapping is then given by\n$$\n\\operatorname{LF}(j)=C(L[j]) + r(j) - 1.\n$$\nStarting from the primary index $I$, which is the row index of the original string in the sorted matrix, the original string with the terminal character, denoted $S\\$, is reconstructed by iterating\n$$\ns[k] = L[j], \\quad j \\leftarrow \\operatorname{LF}(j)\n$$\nfor $k$ from $n-1$ down to $0$, initializing $j=I$.\n\nFor the given data, $L$ has length $n=5$ with positions and characters\n$$\n(0,b),\\ (1,b),\\ (2,\\$),\\ (3,a),\\ (4,a).\n$$\nSorting the characters gives\n$$\nF = [\\$, a, a, b, b].\n$$\nCompute $C(c)$ for the alphabet $\\{\\$,a,b\\}$:\n$$\nC(\\$)=0,\\quad C(a)=1,\\quad C(b)=3.\n$$\nCompute ranks $r(j)$ by scanning $L$ left to right:\n$$\nr(0)=1\\ \\text{for}\\ b,\\quad r(1)=2\\ \\text{for}\\ b,\\quad r(2)=1\\ \\text{for}\\ \\$,\\quad r(3)=1\\ \\text{for}\\ a,\\quad r(4)=2\\ \\text{for}\\ a.\n$$\nApply the LF-mapping:\n$$\n\\operatorname{LF}(0)=3,\\ \\operatorname{LF}(1)=4,\\ \\operatorname{LF}(2)=0,\\ \\operatorname{LF}(3)=1,\\ \\operatorname{LF}(4)=2.\n$$\nReconstruct starting at $j=I=2$:\n$$\nk=4:\\ s[4]=L[2]=\\$, \\ j\\leftarrow \\operatorname{LF}(2)=0;\n$$\n$$\nk=3:\\ s[3]=L[0]=b, \\ j\\leftarrow \\operatorname{LF}(0)=3;\n$$\n$$\nk=2:\\ s[2]=L[3]=a, \\ j\\leftarrow \\operatorname{LF}(3)=1;\n$$\n$$\nk=1:\\ s[1]=L[1]=b, \\ j\\leftarrow \\operatorname{LF}(1)=4;\n$$\n$$\nk=0:\\ s[0]=L[4]=a, \\ j\\leftarrow \\operatorname{LF}(4)=2.\n$$\nThus the reconstructed string with terminator is\n$$\nS\\$ = a\\,b\\,a\\,b\\,\\$,\n$$\nso the original input string (without the $\\$$ character) is\n$$\nabab.\n$$", "answer": "$$\\boxed{abab}$$", "id": "1606417"}, {"introduction": "Moving beyond ideal cases, this practice explores the real-world implications of data corruption on the BWT. You will investigate how a small error—a character swap in the transformed $L$ string—propagates through the inverse BWT algorithm. This analysis provides critical insight into the transform's error characteristics and demonstrates how a local error in the compressed data can affect the reconstructed output.", "problem": "The Burrows-Wheeler Transform (BWT) is a text transformation algorithm used in data compression. For a given input string $S$ of length $n$, the transform is typically computed by first appending a special end-of-string marker, '$', which is not present in the original string. Then, all $n+1$ cyclic shifts (rotations) of this new string are generated. These rotations are sorted lexicographically to form a matrix $M$. The output of the transform consists of two parts: the last column of this matrix, denoted as $L$, and the \"primary index\" $I$, which is the row number of the original string $S\\$$ in the matrix $M$ (using 0-based indexing).\n\nThe inverse BWT can be performed efficiently using a technique called the LF-mapping (Last-to-First mapping). This process reconstructs the original string $S$ character by character, in reverse order. The key steps are:\n1. Construct the first column, $F$, by sorting the characters in the last column, $L$.\n2. For each character `c` in the alphabet, create a C-table entry, $C[c]$, storing the total count of characters in $L$ that are lexicographically smaller than `c`.\n3. The core of the reconstruction is the LF-map function: $LF(i) = C[L[i]] + \\text{rank}(L[i], i)$, where $\\text{rank}(c, i)$ is the number of occurrences of character $c$ in the prefix $L[0 \\dots i-1]$.\n4. The reconstruction proceeds as follows: Start with the row index $j = I$. Initialize an empty string for the result. For each step from $i=0$ to $n$: prepend the character $L[j]$ to the result string, then update the row index by setting $j \\leftarrow LF(j)$.\n\nConsider the original string $S_{orig} = \\text{\"BANANA\"}$. Its Burrows-Wheeler Transform is given by the last column $L_{orig} = \\text{\"ANNB\\$AA\"}$ and the primary index $I = 4$.\n\nNow, suppose that during transmission, the string $L_{orig}$ is corrupted by a swap error. The characters at index 0 and index 2 are exchanged, resulting in a corrupted last column $L_{corr}$. The primary index $I$ remains unchanged.\n\nYour task is to determine the extent of the corruption in the final decoded string. Calculate the number of characters that are incorrect in the string $S_{corr}$ (reconstructed from $L_{corr}$ and $I$) when compared to the original string $S_{orig}$.", "solution": "Let the original string be $S_{\\text{orig}}=\\text{BANANA}$, so $n=6$. The given Burrows-Wheeler Transform has last column $L_{\\text{orig}}=\\text{ANNB\\$AA}$ and primary index $I=4$. The corrupted last column is obtained by swapping indices $0$ and $2$ in $L_{\\text{orig}}$, so\n$$\nL_{\\text{corr}}=\\text{NNAB\\$AA}.\n$$\nWe reconstruct $S_{\\text{corr}}$ using LF-mapping with $j=I=4$ and iterating for $i=n-1,\\dots,0$:\n$$\n\\text{LF}(i)=C[L[i]]+\\operatorname{rank}(L[i],i),\n$$\nwhere $F$ is the sorted version of $L_{\\text{corr}}$, and $C[c]$ is the number of characters in $L_{\\text{corr}}$ strictly smaller than $c$.\n\nFrom $L_{\\text{corr}}=\\text{N N A B \\$ A A}$, the character counts are: one $\\$$, three $A$, one $B$, and two $N$. Thus the first column is\n$$\nF=\\text{\\$ A A A B N N},\n$$\nand the $C$-table is\n$$\nC[\\$]=0,\\quad C[A]=1,\\quad C[B]=4,\\quad C[N]=5.\n$$\nWe apply the reconstruction loop for $i=5,4,3,2,1,0$, updating $j\\leftarrow \\text{LF}(j)$ and setting $S_{\\text{corr}}[i]=L_{\\text{corr}}[j]$ at each step. We compute the necessary ranks on the prefixes of $L_{\\text{corr}}$:\n\n1. $i=5$, $j=4$, $L_{\\text{corr}}[4]=\\$$. Then $\\operatorname{rank}(\\$,4)=0$, so\n$$\nj\\leftarrow C[\\$]+\\operatorname{rank}(\\$,4)=0+0=0,\\quad S_{\\text{corr}}[5]=L_{\\text{corr}}[0]=\\text{N}.\n$$\n\n2. $i=4$, $j=0$, $L_{\\text{corr}}[0]=\\text{N}$. Then $\\operatorname{rank}(\\text{N},0)=0$, so\n$$\nj\\leftarrow C[\\text{N}]+\\operatorname{rank}(\\text{N},0)=5+0=5,\\quad S_{\\text{corr}}[4]=L_{\\text{corr}}[5]=\\text{A}.\n$$\n\n3. $i=3$, $j=5$, $L_{\\text{corr}}[5]=\\text{A}$. On $L_{\\text{corr}}[0..4]=\\text{N N A B \\$}$, $\\operatorname{rank}(\\text{A},5)=1$, so\n$$\nj\\leftarrow C[\\text{A}]+\\operatorname{rank}(\\text{A},5)=1+1=2,\\quad S_{\\text{corr}}[3]=L_{\\text{corr}}[2]=\\text{A}.\n$$\n\n4. $i=2$, $j=2$, $L_{\\text{corr}}[2]=\\text{A}$. On $L_{\\text{corr}}[0..1]=\\text{N N}$, $\\operatorname{rank}(\\text{A},2)=0$, so\n$$\nj\\leftarrow C[\\text{A}]+\\operatorname{rank}(\\text{A},2)=1+0=1,\\quad S_{\\text{corr}}[2]=L_{\\text{corr}}[1]=\\text{N}.\n$$\n\n5. $i=1$, $j=1$, $L_{\\text{corr}}[1]=\\text{N}$. On $L_{\\text{corr}}[0..0]=\\text{N}$, $\\operatorname{rank}(\\text{N},1)=1$, so\n$$\nj\\leftarrow C[\\text{N}]+\\operatorname{rank}(\\text{N},1)=5+1=6,\\quad S_{\\text{corr}}[1]=L_{\\text{corr}}[6]=\\text{A}.\n$$\n\n6. $i=0$, $j=6$, $L_{\\text{corr}}[6]=\\text{A}$. On $L_{\\text{corr}}[0..5]=\\text{N N A B \\$ A}$, $\\operatorname{rank}(\\text{A},6)=2$, so\n$$\nj\\leftarrow C[\\text{A}]+\\operatorname{rank}(\\text{A},6)=1+2=3,\\quad S_{\\text{corr}}[0]=L_{\\text{corr}}[3]=\\text{B}.\n$$\n\nThus the reconstructed string is\n$$\nS_{\\text{corr}}=\\text{BANAAN}.\n$$\nComparing with $S_{\\text{orig}}=\\text{BANANA}$, the mismatches occur at indices $4$ and $5$. Therefore, the number of incorrect characters is $2$.", "answer": "$$\\boxed{2}$$", "id": "1606442"}]}