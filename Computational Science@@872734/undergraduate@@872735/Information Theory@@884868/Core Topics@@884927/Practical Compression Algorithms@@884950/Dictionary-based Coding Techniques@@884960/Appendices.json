{"hands_on_practices": [{"introduction": "To truly understand how LZ77 compresses data, one must master the mechanics of its sliding window. This practice [@problem_id:1617527] provides a concrete scenario to trace the state of the search and lookahead buffers. By manually tracking the algorithm's progress, you will gain a hands-on feel for how matches are found and encoded into $(offset, length, next\\_char)$ triplets.", "problem": "A data compression system uses a simplified version of the Lempel-Ziv 1977 (LZ77) algorithm. The algorithm works by maintaining a sliding window over the input data stream. This window is divided into two parts: a search buffer, which contains recently processed text, and a lookahead buffer, which contains the next portion of the text to be encoded.\n\nThe compressor identifies the longest prefix of the lookahead buffer that also appears in the search buffer. It then outputs a phrase, which is a triplet `(offset, length, next_char)`, where:\n- `offset` is the distance from the current position back to the start of the match in the search buffer. An offset of 0 indicates no match was found.\n- `length` is the length of the longest match. A length of 0 indicates no match was found.\n- `next_char` is the first character in the lookahead buffer that comes immediately after the matched prefix. If no match is found (i.e., length is 0), this is simply the first character of the lookahead buffer.\n\nAfter encoding a phrase, the sliding window is advanced by $length + 1$ characters.\n\nConsider the input string `A_CAT_SAW_A_RAT_EAT_A_CAT` (where `_` represents a space character). The compressor is configured with a search buffer of size 8 and a lookahead buffer of size 7. The process starts with an empty search buffer, and the lookahead buffer is filled from the beginning of the string.\n\nAfter the first five phrases have been encoded, what are the respective contents of the search buffer and the lookahead buffer?\n\nA. Search Buffer: `A_CAT_S`, Lookahead Buffer: `AW_A_RA`\nB. Search Buffer: `A_CAT`, Lookahead Buffer: `_SAW_A_`\nC. Search Buffer: `A_CAT_S`, Lookahead Buffer: `AW_A_RAT`\nD. Search Buffer: `CAT_SAW`, Lookahead Buffer: `_A_RAT_`\nE. Search Buffer: `_CAT_SA`, Lookahead Buffer: `W_A_RAT`", "solution": "The problem asks for the state of the search buffer and the lookahead buffer after five encoding steps of the LZ77 algorithm.\n\nThe parameters are:\n- Input String: `A_CAT_SAW_A_RAT_EAT_A_CAT`\n- Search Buffer Size (S): 8\n- Lookahead Buffer Size (L): 7\n\nLet's trace the state of the buffers step by step. The notation `|` will represent the boundary between the search buffer and the lookahead buffer (i.e., the current cursor position).\n\n**Initial State:**\nThe cursor is at the beginning of the string. The search buffer is empty. The lookahead buffer is filled with the first 7 characters.\n- String View: `|A_CAT_SAW_A_RAT_EAT_A_CAT`\n- Search Buffer (SB): ` ` (empty)\n- Lookahead Buffer (LAB): `A_CAT_S`\n\n**Step 1:**\n- The lookahead buffer starts with `A`. We search for `A` in the empty search buffer. No match is found.\n- The encoded phrase is `(offset=0, length=0, next_char='A')`.\n- The window advances by `length + 1 = 1` character.\n- State after Step 1:\n    - String View: `A|_CAT_SAW_A_RAT_EAT_A_CAT`\n    - SB: `A`\n    - LAB: `_CAT_SA`\n\n**Step 2:**\n- The lookahead buffer starts with `_`. We search for `_` in the search buffer (`A`). No match is found.\n- The encoded phrase is `(0, 0, '_')`.\n- The window advances by `length + 1 = 1` character.\n- State after Step 2:\n    - String View: `A_|_CAT_SAW_A_RAT_EAT_A_CAT`\n    - SB: `A_`\n    - LAB: `CAT_SAW`\n\n**Step 3:**\n- The lookahead buffer starts with `C`. We search for `C` in the search buffer (`A_`). No match is found.\n- The encoded phrase is `(0, 0, 'C')`.\n- The window advances by `length + 1 = 1` character.\n- State after Step 3:\n    - String View: `A_C|AT_SAW_A_RAT_EAT_A_CAT`\n    - SB: `A_C`\n    - LAB: `AT_SAW_`\n\n**Step 4:**\n- The lookahead buffer starts with `A`. We search for `A` in the search buffer (`A_C`). A match is found.\n- The match `A` is at the beginning of the `A_C` buffer. The distance from the cursor back to this `A` is 2 positions. So, `offset = 2`.\n- We check if a longer match exists. The character after `A` in the lookahead buffer is `T`. The character after the matched `A` in the original string (`A_C...`) is `_`. Since `T` is not equal to `_`, the match cannot be extended.\n- The longest match has `length = 1`.\n- The `next_char` is the character after the match in the lookahead buffer, which is `T`.\n- The encoded phrase is `(2, 1, 'T')`.\n- The window advances by `length + 1 = 1 + 1 = 2` characters.\n- State after Step 4:\n    - String View: `A_CAT|_SAW_A_RAT_EAT_A_CAT`\n    - SB: `A_CAT`\n    - LAB: `_SAW_A_`\n\n**Step 5:**\n- The lookahead buffer starts with `_`. We search for `_` in the search buffer (`A_CAT`). A match is found.\n- The match `_` is at the second position of the `A_CAT` buffer. The distance from the cursor back to this `_` is 3 positions. So, `offset = 3`.\n- We check for a longer match. The character after `_` in the lookahead buffer is `S`. The character after the matched `_` in the original string (`A_CAT...`) is `C`. Since `S` is not equal to `C`, the match cannot be extended.\n- The longest match has `length = 1`.\n- The `next_char` is the character after the match in the lookahead buffer, which is `S`.\n- The encoded phrase is `(3, 1, 'S')`.\n- The window advances by `length + 1 = 1 + 1 = 2` characters.\n- State after Step 5:\n    - String View: `A_CAT_S|AW_A_RAT_EAT_A_CAT`\n    - The search buffer contains the 8 characters (or fewer, if at the beginning of the string) to the left of the cursor. The current string to the left is `A_CAT_S` which has length 7. This is within the buffer size. So, SB: `A_CAT_S`.\n    - The lookahead buffer contains the 7 characters to the right of the cursor. So, LAB: `AW_A_RA`.\n\nThe final state after five encoded phrases is:\n- Search Buffer: `A_CAT_S`\n- Lookahead Buffer: `AW_A_RA`\n\nThis corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1617527"}, {"introduction": "The LZ78 algorithm marks a conceptual shift from LZ77's sliding window to an explicitly constructed dictionary. Working through this problem [@problem_id:1617519] will help you visualize how the algorithm parses an input string into new phrases and builds its dictionary from scratch. This exercise illustrates the core logic behind generating $(index, character)$ output pairs and provides a foundation for understanding its widely used successor, LZW.", "problem": "The Lempel-Ziv 1978 (LZ78) algorithm is a dictionary-based lossless data compression method. It compresses a string of characters by parsing it and building a dictionary of phrases encountered.\n\nThe algorithm proceeds as follows:\n1.  The dictionary is initially empty. New phrases are assigned integer indices starting from 1.\n2.  The algorithm iteratively finds the longest prefix of the remaining unread portion of the input string that already exists in the dictionary. Let this prefix correspond to dictionary index `i`.\n3.  A non-empty prefix must match a dictionary entry exactly. If no non-empty prefix is found, the match is considered the empty string, for which we use the index $i=0$.\n4.  The algorithm then reads the next single character, `C`, from the input stream that follows the matched prefix.\n5.  An output pair `(i, C)` is generated, representing the compressed form of the phrase `prefix + C`.\n6.  This new phrase, `prefix + C`, is added to the dictionary with the next available integer index.\n7.  The processed phrase (`prefix + C`) is removed from the beginning of the input string, and the process repeats until the entire string is consumed.\n\nConsider the input string $S = \\text{BOOKKEEPER}$. This string will be parsed into a sequence of phrases, and for each phrase, an output pair `(i, C)` will be generated. Determine the sequence of prefix indices, `i`, that are generated during the LZ78 compression of the string `S`. Present your answer as a sequence of integers.", "solution": "Initialize the dictionary as empty and set the next available index to start at 1. Process the input string $S=\\text{BOOKKEEPER}$ iteratively according to the LZ78 rules.\n\nIteration 1: The remaining input is BOOKKEEPER. No non-empty prefix is in the dictionary, so $i=0$. The next character is $C=B$. Output $(0,B)$, add the phrase $\\text{B}$ to the dictionary at index $1$, and remove $\\text{B}$. Remaining input: OOKKEEPER.\n\nIteration 2: The remaining input is OOKKEEPER. No non-empty prefix in the dictionary matches the start, so $i=0$. The next character is $C=O$. Output $(0,O)$, add the phrase $\\text{O}$ at index $2$, and remove $\\text{O}$. Remaining input: OKKEEPER.\n\nIteration 3: The remaining input is OKKEEPER. The longest matching prefix is $\\text{O}$ with index $2$. The next character is $C=K$. Output $(2,K)$, add the phrase $\\text{OK}$ at index $3$, and remove $\\text{OK}$. Remaining input: KEEPER.\n\nIteration 4: The remaining input is KEEPER. No non-empty prefix in the dictionary matches the start, so $i=0$. The next character is $C=K$. Output $(0,K)$, add the phrase $\\text{K}$ at index $4$, and remove $\\text{K}$. Remaining input: EEPER.\n\nIteration 5: The remaining input is EEPER. No non-empty prefix in the dictionary matches the start, so $i=0$. The next character is $C=E$. Output $(0,E)$, add the phrase $\\text{E}$ at index $5$, and remove $\\text{E}$. Remaining input: EPER.\n\nIteration 6: The remaining input is EPER. The longest matching prefix is $\\text{E}$ with index $5$. The next character is $C=P$. Output $(5,P)$, add the phrase $\\text{EP}$ at index $6$, and remove $\\text{EP}$. Remaining input: ER.\n\nIteration 7: The remaining input is ER. The longest matching prefix is $\\text{E}$ with index $5$. The next character is $C=R$. Output $(5,R)$, add the phrase $\\text{ER}$ at index $7$, and remove $\\text{ER}$. Remaining input: empty, so the process stops.\n\nCollecting the prefix indices $i$ from each output pair in order yields the sequence $0, 0, 2, 0, 0, 5, 5$.", "answer": "$$\\boxed{\\begin{pmatrix} 0 & 0 & 2 & 0 & 0 & 5 & 5 \\end{pmatrix}}$$", "id": "1617519"}, {"introduction": "This advanced practice [@problem_id:1617490] moves beyond simple simulation to a more analytical challenge involving the LZW algorithm, a practical refinement of LZ78. Instead of just tracing the algorithm's execution, you must reverse-engineer an input that produces a specific dictionary entry. This puzzle-like problem solidifies comprehension by testing your understanding of the precise conditions under which the LZW dictionary expands.", "problem": "The Lempel-Ziv-Welch (LZW) algorithm is a universal lossless data compression algorithm. Its operation relies on building a dictionary of strings encountered during encoding.\n\nConsider a standard implementation of the LZW encoder operating on an alphabet consisting of just two characters, 'A' and 'B'. The process is as follows:\n1. The dictionary is initialized to contain all single characters from the alphabet. In this case, the initial dictionary is `{'A', 'B'}`.\n2. The current match string, `w`, is initialized by reading the first character from the input stream.\n3. The algorithm then iterates through the remaining characters of the input stream. For each subsequent character `k`:\n    a. If the new string formed by concatenating the current match with the new character, `w + k`, is already present in the dictionary, the current match is extended, i.e., `w` is updated to `w + k`.\n    b. If `w + k` is not in the dictionary, the algorithm first adds this new string `w + k` to the dictionary, and then the current match `w` is reset to be the single-character string `k`.\n4. This process continues until the entire input stream has been consumed.\n\nYour task is to determine the shortest possible input string that, when fed into this LZW encoder, will cause the specific string 'BABA' to be added to the dictionary.", "solution": "We want the shortest input over the alphabet $\\\\{A,B\\\\}$ that causes the LZW encoder (initialized with only $A$ and $B$) to add the string $BABA$ to the dictionary. In LZW, a new string is added exactly when, for current match $w$ and next input character $k$, the concatenation $w+k$ is not yet in the dictionary; then the encoder inserts $w+k$ and resets $w$ to the single character $k$. Therefore, to add $BABA$, we must reach a step where $w=BAB$ and $k=A$, with $BABA$ not yet in the dictionary. By LZW invariant, $w$ must be an existing dictionary entry at that moment, so $BAB$ must already have been added earlier.\n\nFirst establish the earliest point $BAB$ can be added. Initially $D_{0}=\\\\{A,B\\\\}$. The earliest way to add $BA$ is to begin with $B$ then $A$:\n- Read first symbol $B$, so $w=B$.\n- Next $k=A$: $BA\\notin D_{0}$, so insert $BA$ to get $D_{1}=D_{0}\\cup\\\\{BA\\\\}$, then set $w=A$.\nTo add $BAB$, we need a step with $w=BA$ and next $k=B$ when $BAB$ is not yet in the dictionary. After adding $BA$, the next symbol $B$ paired with $w=A$ yields $AB\\notin D_{1}$, so $AB$ is added and $w=B$. The following $A$ makes $w=BA$, and the next $B$ then causes $BAB$ to be added. Thus, the earliest $BAB$ can be added is when processing the fifth input symbol.\n\nOnce $BAB$ has been added, to add $BABA$ we must have $w=BAB$ and then read $k=A$. Immediately after inserting $BAB$, the encoder resets $w=B$. The shortest way to get $w=BAB$ after that is to read $A$ (making $w=BA$), then $B$ (since $BAB$ is now in the dictionary, this extends to $w=BAB$), and then read $A$ to trigger insertion of $BABA$. Therefore, the earliest step at which $BABA$ can be added is the eighth input symbol.\n\nAn explicit shortest input achieving this is $BABABABA$. Verifying step by step:\n- Initialize $D_{0}=\\\\{A,B\\\\}$ and read first symbol $B$, so $w=B$.\n- Symbol $2$, $k=A$: $BA\\notin D_{0}$, insert $BA$, set $w=A$.\n- Symbol $3$, $k=B$: $AB\\notin D_{1}$, insert $AB$, set $w=B$.\n- Symbol $4$, $k=A$: $BA\\in D$, extend $w=BA$.\n- Symbol $5$, $k=B$: $BAB\\notin D$, insert $BAB$, set $w=B$.\n- Symbol $6$, $k=A$: $BA\\in D$, extend $w=BA$.\n- Symbol $7$, $k=B$: $BAB\\in D$, extend $w=BAB$.\n- Symbol $8$, $k=A$: $BABA\\notin D$, insert $BABA$.\n\nNo shorter input can achieve insertion of $BABA$ earlier than the eighth symbol, as argued above. Hence the shortest possible input string is $BABABABA$.", "answer": "$$\\boxed{BABABABA}$$", "id": "1617490"}]}