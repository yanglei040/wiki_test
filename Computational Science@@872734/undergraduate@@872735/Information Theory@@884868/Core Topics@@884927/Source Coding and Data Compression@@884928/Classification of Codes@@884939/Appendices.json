{"hands_on_practices": [{"introduction": "The first step in appreciating robust code design is to see what happens when things go wrong. A code is not useful if a received message can be interpreted in multiple ways, a property known as ambiguity. This exercise provides a tangible example of a non-uniquely decodable code and challenges you to find the exact point of failure, building your intuition for identifying the source of such decoding errors [@problem_id:1610380].", "problem": "In the design of a simple communication protocol for a network of environmental sensors, a set of four distinct events {Alert, Normal, Low_Battery, Reset} must be encoded into binary strings for transmission. A junior engineer proposes the following variable-length code, $C$:\n- `Alert` $\\rightarrow$ `1`\n- `Normal` $\\rightarrow$ `10`\n- `Low_Battery` $\\rightarrow$ `00`\n- `Reset` $\\rightarrow$ `101`\n\nWhile this code is non-singular (each event maps to a unique binary string), it is suspected that it is not uniquely decodable. A sequence of these binary codewords, when concatenated without separators, might be parsed into a valid sequence of events in more than one way. To prove this flaw to the design team, you must find the shortest possible concatenated binary sequence that demonstrates this ambiguity.\n\nWhat is the shortest binary sequence that can be correctly interpreted as two or more different sequences of events from the set {Alert, Normal, Low_Battery, Reset}?", "solution": "Let the code be the set of binary codewords\n$$C=\\{1,10,00,101\\}.$$\nA concatenated binary sequence is ambiguous if it can be parsed as two different sequences of codewords from $C$ that yield the same overall bit string. To find the shortest such sequence, compare by increasing total length.\n\n- Length $1$: The only decodable string is $1$, which has the unique parse $[1]$. No ambiguity.\n\n- Length $2$: The decodable strings are $00$ and $10$.\n  - $00$ parses only as $[00]$ since $0$ is not a codeword.\n  - $10$ parses only as $[10]$ since $1+0$ is invalid with $0$ not a codeword.\n  The string $11$ is decodable only as $[1][1]$ and is not equal to any single codeword or any other segmentation. No ambiguity at length $2$.\n\n- Length $3$: Consider all decodable concatenations of total length $3$:\n  - $1+00=100$ gives only $[1][00]$.\n  - $1+10=110$ gives only $[1][10]$.\n  - $1+1+1=111$ gives only $[1][1][1]$.\n  - The single codeword $101$ can also be formed by concatenation $10+1=101$, since both $10$ and $1$ are in $C$.\n  Thus\n  $$101=[101] \\quad \\text{and} \\quad 101=[10][1],$$\n  providing two distinct valid parses.\n\nSince no ambiguity exists for lengths $1$ or $2$, and an ambiguity appears at length $3$ with the string $101$, the shortest ambiguous concatenated binary sequence is $101$.", "answer": "$$\\boxed{101}$$", "id": "1610380"}, {"introduction": "To avoid the ambiguity explored previously, we often use prefix codes, where no codeword is the beginning of another, guaranteeing instantaneous decodability. But how do we create such a code once we have a valid set of lengths? This practice walks you through a systematic, algorithmic method for constructing a valid prefix code, turning the abstract guarantee of the Kraft-McMillan theorem into a concrete construction skill [@problem_id:1610365].", "problem": "In digital communication, prefix codes are used for lossless data compression. A code is defined as a prefix code (or an instantaneous code) if no codeword in the assigned set is a prefix of any other codeword. This property allows for unambiguous decoding.\n\nConsider a source alphabet $\\mathcal{S} = \\{A, B, C\\}$. We want to assign a unique binary codeword to each symbol based on a given set of desired codeword lengths: $l_A=2$, $l_B=3$, and $l_C=3$.\n\nThe assignment must follow a specific canonical construction procedure, outlined below:\n1.  The symbols are arranged in a list, sorted first by their required codeword length in non-decreasing order. Any ties in length are broken alphabetically (e.g., A comes before B).\n2.  The first codeword in this sorted list, $c_1$ of length $l_1$, is an all-zero string of length $l_1$.\n3.  Each subsequent codeword, $c_i$ of length $l_i$, is generated from the previous codeword in the list, $c_{i-1}$ of length $l_{i-1}$. Let $v_{i-1}$ be the integer represented by the binary string $c_{i-1}$. The integer value for the current codeword, $v_i$, is given by the formula $v_i = (v_{i-1} + 1) \\times 2^{(l_i - l_{i-1})}$. The codeword $c_i$ is then the binary representation of the integer $v_i$, padded with leading zeros if necessary to ensure it has the required length $l_i$.\n\nWhich of the following options correctly represents the set of codeword assignments $\\{C(A), C(B), C(C)\\}$ generated by this specific procedure?\n\nA. $C(A)=00, C(B)=010, C(C)=011$\n\nB. $C(A)=00, C(B)=001, C(C)=010$\n\nC. $C(A)=11, C(B)=101, C(C)=100$\n\nD. $C(A)=0, C(B)=10, C(C)=11$", "solution": "We are given desired codeword lengths $l_{A}=2$, $l_{B}=3$, and $l_{C}=3$, and the canonical construction procedure.\n\nFirst, sort the symbols by non-decreasing length and alphabetically to break ties. This yields the ordered list $(A, B, C)$ with lengths $(2, 3, 3)$.\n\nFor the first codeword, apply the rule that $c_{1}$ is the all-zero string of length $l_{1}$. Therefore,\n$$\nc_{A} = 00,\\quad v_{A} = 0.\n$$\n\nFor the next symbol $B$ with $l_{B}=3$, use the recurrence\n$$\nv_{B} = (v_{A} + 1)\\times 2^{(l_{B} - l_{A})} = (0 + 1)\\times 2^{(3 - 2)} = 1\\times 2 = 2.\n$$\nThe codeword $c_{B}$ is the binary representation of $v_{B}$ padded to length $3$:\n$$\nc_{B} = 010.\n$$\n\nFor the next symbol $C$ with $l_{C}=3$, apply the recurrence again:\n$$\nv_{C} = (v_{B} + 1)\\times 2^{(l_{C} - l_{B})} = (2 + 1)\\times 2^{(3 - 3)} = 3\\times 1 = 3.\n$$\nThe codeword $c_{C}$ is the binary representation of $v_{C}$ padded to length $3$:\n$$\nc_{C} = 011.\n$$\n\nThus the canonical assignments are $C(A)=00$, $C(B)=010$, and $C(C)=011$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1610365"}, {"introduction": "Before attempting to construct a prefix code, a good designer must first ask: is it even possible with my desired lengths? The Kraft inequality provides the definitive mathematical test for the existence of an instantaneous code for a given set of lengths and alphabet size. This problem puts you in the designer's seat, using the Kraft inequality not just to verify a set of lengths but to optimize them for a communication system, demonstrating how fundamental theory guides practical engineering choices [@problem_id:1610387].", "problem": "A systems engineer is designing a communication protocol for a network of autonomous environmental sensors. The central hub receives status updates from five distinct types of sensors, labeled A, B, C, D, and E. Each status update is encoded into a codeword composed of ternary digits, or \"trits\" (0, 1, or 2). For the hub to process the incoming stream of data without ambiguity and without needing to wait for a special termination symbol, the set of codewords must form an instantaneous code.\n\nBased on the frequency and priority of the sensor types, the codeword lengths for the first three types have been fixed:\n- The codeword for sensor type A has a length of $l_A = 1$ trit.\n- The codewords for sensor types B and C each have a length of $l_B = l_C = 2$ trits.\n\nThe remaining two sensor types, D and E, are for non-critical, periodic check-ins. Their codeword lengths, $l_D$ and $l_E$, are integers that need to be determined. To minimize the computational resources on the simple decoders used in the hub, the design specification requires minimizing the sum of the lengths of these two undetermined codewords, $S = l_D + l_E$.\n\nAssuming $l_D$ and $l_E$ must be positive integers, what is the minimum possible value for the sum $S$?", "solution": "An instantaneous (prefix-free) code over a $D$-ary alphabet must satisfy the Kraft inequality. For ternary trits, $D=3$, so any set of codeword lengths $\\{l_{i}\\}$ must satisfy\n$$\n\\sum_{i} 3^{-l_{i}} \\leq 1.\n$$\nWith the given lengths $l_{A}=1$, $l_{B}=l_{C}=2$ and unknown positive integers $l_{D},l_{E}$, the inequality becomes\n$$\n3^{-1}+3^{-2}+3^{-2}+3^{-l_{D}}+3^{-l_{E}} \\leq 1,\n$$\nwhich simplifies to\n$$\n3^{-l_{D}}+3^{-l_{E}} \\leq 1-\\frac{1}{3}-\\frac{2}{9}=\\frac{4}{9}.\n$$\nWe seek to minimize $S=l_{D}+l_{E}$ subject to $l_{D},l_{E}\\in \\mathbb{Z}_{\\geq 1}$ and the above constraint. Since $3^{-l}$ is strictly decreasing in $l$, making lengths as small as possible increases the left-hand side. The smallest pair is $(1,1)$, which yields\n$$\n3^{-1}+3^{-1}=\\frac{1}{3}+\\frac{1}{3}=\\frac{2}{3}>\\frac{4}{9},\n$$\nso it violates the constraint. The next smallest sum is $S=3$ with pairs $(1,2)$ or $(2,1)$, for which\n$$\n3^{-1}+3^{-2}=\\frac{1}{3}+\\frac{1}{9}=\\frac{4}{9},\n$$\nwhich meets the constraint with equality. By the Kraftâ€“McMillan theorem, this guarantees the existence of a ternary instantaneous code with these lengths, so such a code is feasible. Any larger lengths give $S \\geq 4$, which is not minimal.\n\nTherefore, the minimal possible sum is $S_{\\min}=3$.", "answer": "$$\\boxed{3}$$", "id": "1610387"}]}