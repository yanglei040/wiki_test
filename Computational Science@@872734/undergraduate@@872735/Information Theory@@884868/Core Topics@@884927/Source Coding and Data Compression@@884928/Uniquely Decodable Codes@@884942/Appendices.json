{"hands_on_practices": [{"introduction": "The first step in understanding uniquely decodable codes is learning to identify when a code can lead to confusion. This exercise presents a simple code that is not prefix-free, challenging you to determine if this automatically leads to ambiguity. By analyzing a specific encoded string, you will develop a hands-on feel for what makes a sequence of codewords undecipherable, a crucial skill for designing reliable communication systems. [@problem_id:1666465]", "problem": "A simple communication protocol for a robotic system uses an alphabet consisting of two symbols, $\\{0, 1\\}$. The system transmits information about its a state by encoding three possible states—`IDLE`, `PROCESSING`, and `ALERT`—into the following variable-length codewords:\n- `IDLE`: `0`\n- `PROCESSING`: `01`\n- `ALERT`: `10`\n\nA message is transmitted as a continuous sequence of these codewords without any separators. For example, the state sequence (`IDLE`, `ALERT`) is encoded as the string `010`. A code is considered **uniquely decodable** if any valid encoded string can be partitioned back into its original sequence of codewords in only one way.\n\nWhich of the following statements about this encoding scheme is correct?\n\nA. The code is a prefix code and is therefore uniquely decodable.\n\nB. The code is not uniquely decodable because the string `0101` can be interpreted in two different ways.\n\nC. The code is uniquely decodable.\n\nD. The code is not uniquely decodable because the string `100` can be interpreted in two different ways.\n\nE. The code is not uniquely decodable because the string `010` can be interpreted in two different ways.", "solution": "Let the set of codewords be $C=\\{0,01,10\\}$. The code is not a prefix code because $0$ is a prefix of $01$, so option A is false. However, non-prefix does not automatically imply non-unique decodability; we test unique decodability using the Sardinas–Patterson algorithm.\n\nInitialize $U_{1}$ as the set of nonempty suffixes obtained when one codeword is a prefix of another:\n- Since $0$ is a prefix of $01$, removing $0$ from $01$ yields the suffix $1$.\n- No other prefix relations occur among the remaining pairs.\nHence,\n$$\nU_{1}=\\{1\\}.\n$$\n\nCompute $U_{2}$ from $U_{1}$ and $C$ by solving, for $u\\in U_{i}$ and $c\\in C$, either $u x=c$ or $c x=u$ with nonempty $x$:\n- With $u=1$, the equation $1x=c$ has a solution only when $c=10$, giving $x=0$. The equations $1x=0$ and $1x=01$ have no solutions.\n- The equations $c x=1$ for $c\\in C$ have no solutions.\nThus,\n$$\nU_{2}=\\{0\\}.\n$$\n\nCompute $U_{3}$ from $U_{2}$:\n- With $u=0$, the equation $0x=0$ yields $x=\\epsilon$ (the empty string). The appearance of $\\epsilon$ at this stage implies the code is not uniquely decodable by the Sardinas–Patterson criterion.\n\nAn explicit ambiguity can be exhibited: the string 010 admits two distinct decodings,\n$$\n010=0\\,|\\,10=01\\,|\\,0,\n$$\ncorresponding to the sequences $(\\text{IDLE},\\text{ALERT})$ and $(\\text{PROCESSING},\\text{IDLE})$. Therefore, the code is not uniquely decodable, and the correct justification among the options is that the string 010 can be interpreted in two different ways.\n\nHence, option E is correct, while B and D are false because their cited strings are not ambiguous.", "answer": "$$\\boxed{E}$$", "id": "1666465"}, {"introduction": "While all prefix codes are uniquely decodable, the reverse is not true. There exists a fascinating class of codes that are not prefix-free but can still be decoded without any ambiguity. This problem challenges you to find such a code, forcing you to move beyond simple prefix-checking and apply a more systematic test like the Sardinas–Patterson algorithm. Successfully solving this demonstrates a deeper understanding of the structural properties that guarantee unique decodability. [@problem_id:1666435]", "problem": "An information theorist is tasked with designing a binary, variable-length code for a source that produces four distinct symbols: $S_1, S_2, S_3, S_4$. For reasons related to transmission efficiency and decoder complexity, the set of required codeword lengths is $\\{2, 2, 3, 3\\}$. To ensure perfect message reconstruction, the code must be uniquely decodable. However, due to a specific hardware architecture that processes the bitstream, the code must *not* be a prefix code (i.e., at least one codeword must be a prefix of another).\n\nWhich one of the following code sets, representing the four codewords $\\{c_1, c_2, c_3, c_4\\}$, satisfies all of these design constraints?\n\nA. `{00, 11, 001, 101}`\n\nB. `{00, 01, 100, 101}`\n\nC. `{00, 01, 001, 010}`\n\nD. `{00, 10, 001, 110}`\n\nE. `{00, 01, 001, 000}`", "solution": "The constraints are:\n- Codeword lengths must be $\\{2,2,3,3\\}$.\n- The code must be uniquely decodable (UD).\n- The code must not be prefix-free (at least one codeword is a prefix of another).\n\nPrefix-free codes are always UD, but here the code must not be prefix-free, so we need a non-prefix code that is still UD. To verify unique decodability for non-prefix codes, use the Sardinas–Patterson (SP) algorithm:\n- For code $C$, define\n$$S_{1}=\\{x\\in\\Sigma^{+}:\\exists u,v\\in C\\text{ with }u=vx\\}.$$\n- For $n\\geq 1$, define\n$$S_{n+1}=\\{x\\in\\Sigma^{+}:\\exists y\\in S_{n},\\exists c\\in C\\text{ with }(y=cx)\\text{ or }(c=yx)\\}.$$\n- The code $C$ is UD if and only if $\\epsilon\\notin\\bigcup_{n\\geq 1}S_{n}$; if $\\epsilon$ appears at any stage, the code is not UD.\n\nCheck each option.\n\nA. `{00, 11, 001, 101}`\n- Not prefix-free: `00` is a prefix of `001`.\n- SP sets:\n  - $S_1 = \\{1\\}$ since `00` is a prefix of `001`.\n  - From $y=1$, codewords starting with `1` are `11` and `101`, giving remainders `1` and `01`. Thus $S_2=\\{1, 01\\}$.\n  - From $y=1$ we again get $\\{1, 01\\}$. From $y=01$ there is no codeword $c$ with $c=`01`x$ or `01`$=c x$. Hence the sets stabilize at $S_n=\\{1, 01\\}$ with no $\\epsilon$ appearing.\nTherefore A is UD and not prefix-free, satisfying all constraints.\n\nB. `{00, 01, 100, 101}`\n- Prefix check: no codeword is a prefix of another; it is prefix-free.\n- Violates the “must not be a prefix code” requirement. Reject.\n\nC. `{00, 01, 001, 010}`\n- Not prefix-free: `00` is a prefix of `001`; `01` is a prefix of `010`.\n- SP sets:\n  - $S_1=\\{1, 0\\}$ since `00` is a prefix of `001` and `01` is a prefix of `010`.\n  - From $y=0$, codewords starting with `0` are `00`, `01`, `001`, `010`, giving remainders `0`, `1`, `01`, `10`. Thus $S_2$ contains `01`.\n  - Since the suffix `01` is generated and `01` is also a codeword, the code is not UD (an ambiguity would be found in the next step, yielding $\\epsilon$).\nHence not UD. Reject.\n\nD. `{00, 10, 001, 110}`\n- Not prefix-free: `00` is a prefix of `001`.\n- SP sets:\n  - $S_1=\\{1\\}$ since `00` is a prefix of `001`.\n  - From $y=1$, codewords starting with `1` are `10` and `110`, giving `0` and `10`. Thus $S_2=\\{0, 10\\}$.\n  - Since the suffix `10` is generated and `10` is also a codeword, the code is not UD.\nHence not UD. Reject.\n\nE. `{00, 01, 001, 000}`\n- Not prefix-free: `00` is a prefix of both `001` and `000`.\n- SP sets:\n  - $S_1=\\{1, 0\\}$ since `00` is a prefix of `001` and `000`.\n  - From $y=0$, codewords starting with `0` include `01`, yielding the suffix `1`. `00` yields `0`. `000` yields `00`. `001` yields `01`.\n  - The generated suffixes include `01` and `00`, which are both codewords. The code is not UD.\nHence not UD. Reject.\n\nOnly option A is both uniquely decodable and not prefix-free, with the required lengths.", "answer": "$$\\boxed{A}$$", "id": "1666435"}, {"introduction": "When a code is not uniquely decodable, a simple \"yes\" or \"no\" answer doesn't tell the whole story. A more practical question is: just how ambiguous is a received message? This problem shifts our focus from a qualitative check to a quantitative analysis, introducing an algorithmic approach using dynamic programming to count the exact number of ways a string can be parsed. This practice connects the abstract theory of codes to computational problem-solving, a vital link for real-world applications. [@problem_id:1666456]", "problem": "A digital communication system uses a variable-length binary code to transmit messages composed of a sequence of source symbols. The codebook, which maps source symbols to codewords, is defined by the set of available binary codewords $C = \\{1, 01, 101, 011\\}$. When a message is sent, the corresponding codewords are concatenated directly without any delimiters.\n\nAn engineer at the receiving end observes the binary string $Y = 011011$. The codebook $C$ is not necessarily uniquely decodable, meaning the received string $Y$ could potentially be parsed into a sequence of valid codewords in multiple ways.\n\nDetermine the total number of distinct sequences of codewords from the set $C$ that can be concatenated to form the exact string $Y$.", "solution": "Let the codebook be $C=\\{1, 01, 101, 011\\}$ and the received string be $Y=011011$ of length $6$. Define $F(i)$ as the number of distinct parses of the suffix of $Y$ starting at position $i$, where positions are indexed $1$ through $6$, and let the empty suffix occur at position $7$. The boundary condition is\n$$\nF(7)=1,\n$$\nsince there is exactly one way to parse the empty string.\n\nFor each position $i$, the recurrence is\n$$\nF(i)=\\sum_{w\\in C} \\mathbf{1}[\\text{$w$ matches $Y$ starting at $i$}] \\cdot F(i+|w|),\n$$\nwhere $|w|$ is the length of codeword $w$.\n\nCompute from the end:\n\nAt $i=6$, the suffix is \"1\". The only matching codeword is $1$, hence\n$$\nF(6)=F(7)=1.\n$$\n\nAt $i=5$, the suffix is \"11\". The only matching codeword is $1$, hence\n$$\nF(5)=F(6)=1.\n$$\n\nAt $i=4$, the suffix is \"011\". The matching codewords are $01$ and $011$, giving\n$$\nF(4)=F(6)+F(7)=1+1=2.\n$$\n\nAt $i=3$, the suffix is \"1011\". The matching codewords are $1$ and $101$, giving\n$$\nF(3)=F(4)+F(6)=2+1=3.\n$$\n\nAt $i=2$, the suffix is \"11011\". The only matching codeword is $1$, hence\n$$\nF(2)=F(3)=3.\n$$\n\nAt $i=1$, the suffix is \"011011\". The matching codewords are $01$ and $011$, giving\n$$\nF(1)=F(3)+F(4)=3+2=5.\n$$\n\nTherefore, the total number of distinct sequences of codewords from $C$ that concatenate to $Y$ is $F(1)=5$.", "answer": "$$\\boxed{5}$$", "id": "1666456"}]}