{"hands_on_practices": [{"introduction": "The fundamental operation of any convolutional encoder is the process of generating output bits based on the current input and the encoder's internal state. This first exercise provides a direct, hands-on calculation of a single state transition. By working through this problem [@problem_id:1660255], you will solidify your understanding of how generator sequences define the encoder's logic and how modulo-2 arithmetic is applied to produce the coded output for one time step.", "problem": "Consider a rate $R=1/2$ convolutional encoder. The encoder has a constraint length of $K=3$ and is defined by the two generator sequences $g_1 = [1, 1, 0]$ and $g_2 = [1, 0, 1]$. The state of the encoder at any time $k$ is determined by the two most recent input bits prior to the current one, i.e., the state is $s_k = (u_{k-1}, u_{k-2})$, where $u$ is the input bit sequence. The output from the encoder consists of two bits, $(v_k^{(1)}, v_k^{(2)})$, for each input bit $u_k$. The calculations are performed using modulo-2 arithmetic.\n\nSuppose the encoder is in the state represented by the binary string '10' (meaning $u_{k-1}=1$ and $u_{k-2}=0$). If the next input bit is $u_k = 1$, what is the corresponding two-bit output sequence $(v_k^{(1)}, v_k^{(2)})$ that is generated?\n\nA. 00\n\nB. 01\n\nC. 10\n\nD. 11", "solution": "A rate $R=\\frac{1}{2}$ convolutional encoder with constraint length $K=3$ and generator sequences $g_{1}=[1,1,0]$ and $g_{2}=[1,0,1]$ produces, for each input bit $u_{k}$, two output bits defined by modulo-2 linear combinations of the current and two previous input bits:\n$$\nv_{k}^{(1)}=u_{k}\\cdot g_{1,0}\\oplus u_{k-1}\\cdot g_{1,1}\\oplus u_{k-2}\\cdot g_{1,2},\\qquad\nv_{k}^{(2)}=u_{k}\\cdot g_{2,0}\\oplus u_{k-1}\\cdot g_{2,1}\\oplus u_{k-2}\\cdot g_{2,2},\n$$\nwhere $\\oplus$ denotes addition modulo $2$ and $g_{i,j}$ is the $j$-th element of $g_{i}$ corresponding respectively to taps on $u_{k},u_{k-1},u_{k-2}$.\n\nGiven the state $s_{k}=(u_{k-1},u_{k-2})=(1,0)$ and input $u_{k}=1$, we substitute into the expressions:\n$$\nv_{k}^{(1)}=1\\cdot 1\\oplus 1\\cdot 1\\oplus 0\\cdot 0=1\\oplus 1\\oplus 0=0,\n$$\n$$\nv_{k}^{(2)}=1\\cdot 1\\oplus 1\\cdot 0\\oplus 0\\cdot 1=1\\oplus 0\\oplus 0=1.\n$$\nTherefore, the two-bit output is $(v_{k}^{(1)},v_{k}^{(2)})=(0,1)$, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1660255"}, {"introduction": "Building upon the single-step calculation, we now explore how an encoder behaves over a sequence of inputs. This practice requires you to trace a path through the encoder's states for multiple time steps, calculating the corresponding output sequence along the way [@problem_id:1660233]. This exercise is crucial as it directly simulates the process of encoding a stream of data and forms the basis for visualizing the encoder's operation as a path through its trellis diagram.", "problem": "A rate $R=1/2$ convolutional encoder is constructed using a shift register with two memory elements (D flip-flops). The state of the encoder at any time $k$ can be represented by the ordered pair of bits stored in these registers, $S_k = (M_{1,k}, M_{2,k})$. At each time step, a single input bit $u_k$ enters the encoder. Two output bits, $v_k^{(1)}$ and $v_k^{(2)}$, are generated based on the current input and the current state. The logic for the output generation is defined by the following equations, where all additions are performed modulo-2 (XOR operation):\n\n$$v_k^{(1)} = u_k \\oplus M_{1,k} \\oplus M_{2,k}$$\n$$v_k^{(2)} = u_k \\oplus M_{2,k}$$\n\nAfter the outputs are computed, the state of the registers is updated for the next time step, $k+1$. The new bit $u_k$ is shifted into the first register, and the bit from the first register is shifted into the second. That is, the next state is $S_{k+1} = (u_k, M_{1,k})$.\n\nSuppose the encoder is not in the conventional all-zero starting state. Instead, its initial state at time $k=1$ is $S_1 = (0, 1)$. The encoder is then fed the two-bit input sequence '10' (meaning $u_1 = 1$ and $u_2 = 0$).\n\nWhat is the resulting 4-bit output sequence, formed by concatenating the first output block $(v_1^{(1)}, v_1^{(2)})$ and the second output block $(v_2^{(1)}, v_2^{(2)})$?\n\nSelect the correct sequence from the options below.\n\nA. 0010\n\nB. 1110\n\nC. 0101\n\nD. 0001\n\nE. 1111", "solution": "We are given a rate $R=\\frac{1}{2}$ convolutional encoder with state $S_{k}=(M_{1,k},M_{2,k})$, outputs\n$$v_{k}^{(1)}=u_{k}\\oplus M_{1,k}\\oplus M_{2,k},\\quad v_{k}^{(2)}=u_{k}\\oplus M_{2,k},$$\nwith all additions modulo-2, and state update\n$$S_{k+1}=(u_{k},M_{1,k}).$$\nThe initial state is $S_{1}=(0,1)$ and the inputs are $u_{1}=1$, $u_{2}=0$.\n\nStep at $k=1$:\nGiven $S_{1}=(M_{1,1},M_{2,1})=(0,1)$ and $u_{1}=1$,\n$$v_{1}^{(1)}=u_{1}\\oplus M_{1,1}\\oplus M_{2,1}=1\\oplus 0\\oplus 1=0,$$\n$$v_{1}^{(2)}=u_{1}\\oplus M_{2,1}=1\\oplus 1=0.$$\nUpdate the state:\n$$S_{2}=(u_{1},M_{1,1})=(1,0).$$\n\nStep at $k=2$:\nGiven $S_{2}=(M_{1,2},M_{2,2})=(1,0)$ and $u_{2}=0$,\n$$v_{2}^{(1)}=u_{2}\\oplus M_{1,2}\\oplus M_{2,2}=0\\oplus 1\\oplus 0=1,$$\n$$v_{2}^{(2)}=u_{2}\\oplus M_{2,2}=0\\oplus 0=0.$$\n\nConcatenating $(v_{1}^{(1)},v_{1}^{(2)})=(0,0)$ and $(v_{2}^{(1)},v_{2}^{(2)})=(1,0)$ yields the 4-bit sequence $0010$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1660233"}, {"introduction": "This final practice moves from tracing a single, specified path to analyzing the structural properties of the code's trellis. You will investigate the concept of an \"error event,\" which is a path that diverges from and later re-merges with the all-zero state path [@problem_id:1660294]. Understanding and enumerating these events is fundamental to evaluating a code's performance, as their properties determine the code's ability to correct errors during the decoding process.", "problem": "Consider a binary, rate $R=1/2$ convolutional encoder with memory $m=2$. The encoder transforms an input information sequence $u = (u_0, u_1, u_2, \\dots)$ into two output sequences, $c^{(1)}$ and $c^{(2)}$, which are multiplexed to form the final coded sequence. The connection from the input to the outputs is described by the generator polynomials $g^{(1)}(D) = 1 + D + D^2$ and $g^{(2)}(D) = 1 + D^2$, where $D$ represents a one-bit delay. The arithmetic is performed modulo-2.\n\nThe state of the encoder at time $k$, denoted as $S_k$, is defined by the contents of its memory elements: $S_k = (u_{k-1}, u_{k-2})$. The system starts in the all-zero state, $S_0 = (0,0)$.\n\nAn error event of length $L$ is a path in the encoder's state diagram that diverges from the all-zero state path at some time, and re-merges with the all-zero state path for the first time after exactly $L$ state transitions.\n\nDetermine the total number of unique error events of length exactly $L=5$ that can be generated by this encoder, assuming they all start by diverging from the all-zero state at time $k=0$.", "solution": "For a binary convolutional encoder with memory order $m=2$, the encoder state is $S_{k}=(u_{k-1},u_{k-2})$, with initial state $S_{0}=(0,0)$. The state update is\n$$\nS_{k+1}=(u_{k},u_{k-1}).\n$$\nAn error event of length $L=5$ that starts diverging at $k=0$ must satisfy:\n- Divergence at $k=0$: this requires the input at $k=0$ to be $u_{0}=1$, since $u_{0}=0$ would keep the state on the all-zero path.\n- First re-merge after exactly $5$ transitions: this requires $S_{5}=(0,0)$ and $S_{k}\\neq(0,0)$ for $k=1,2,3,4$.\n\nFrom $S_{5}=(u_{4},u_{3})=(0,0)$ we obtain\n$$\nu_{3}=0,\\quad u_{4}=0.\n$$\nNow enforce the nonzero-state conditions for $k=1,2,3,4$:\n- $S_{1}=(u_{0},u_{-1})=(1,0)\\neq(0,0)$ holds because $u_{0}=1$.\n- $S_{2}=(u_{1},u_{0})\\neq(0,0)$ holds automatically since $u_{0}=1$.\n- $S_{3}=(u_{2},u_{1})\\neq(0,0)$ requires at least one of $u_{2}$ or $u_{1}$ to be $1$.\n- $S_{4}=(u_{3},u_{2})=(0,u_{2})\\neq(0,0)$ forces\n$$\nu_{2}=1.\n$$\nWith $u_{2}=1$, the condition $S_{3}\\neq(0,0)$ is satisfied for either value of $u_{1}$. Therefore the admissible input sequences over $k=0,1,2,3,4$ are exactly those with\n$$\nu_{0}=1,\\quad u_{2}=1,\\quad u_{3}=0,\\quad u_{4}=0,\n$$\nand $u_{1}\\in\\{0,1\\}$ free. This yields exactly $2$ distinct state paths (error events). The specific generator polynomials ensure the code is non-catastrophic since $\\gcd(1+D+D^{2},\\,1+D^{2})=1$, so distinct input sequences correspond to distinct events.", "answer": "$$\\boxed{2}$$", "id": "1660294"}]}