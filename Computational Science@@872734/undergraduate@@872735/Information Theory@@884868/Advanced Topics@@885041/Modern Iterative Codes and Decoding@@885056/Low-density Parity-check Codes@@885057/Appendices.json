{"hands_on_practices": [{"introduction": "Before deploying an error-correcting code, it's essential to understand its fundamental characteristics. A key metric is the code rate, $R$, which quantifies the code's efficiency by measuring the proportion of a codeword that carries actual information. This exercise will guide you through calculating this crucial parameter directly from the dimensions of a given parity-check matrix, providing insight into the trade-off between redundancy and data throughput. [@problem_id:1638281]", "problem": "In digital communications, linear block codes are employed to protect information from errors that may occur during transmission. A popular and powerful class of such codes is the Low-Density Parity-Check (LDPC) code, which is defined by a sparse parity-check matrix, denoted by $H$. The properties of the code, such as its error-correcting capability and its efficiency, are determined by the structure of this matrix.\n\nConsider a binary LDPC code whose parity-check matrix $H$ has 4 rows and 8 columns. The number of columns, $n$, corresponds to the total number of bits in a codeword (the block length), while the number of rows, $m$, corresponds to the number of linear parity-check constraints imposed on the codewords. You are given that this matrix $H$ has full row rank.\n\nCalculate the code rate, $R$, of this LDPC code. Present your answer as a single closed-form analytic expression.", "solution": "For a binary linear block code defined by a parity-check matrix $H$ with $n$ columns and $m$ rows, the code dimension $k$ is given by\n$$\nk = n - \\operatorname{rank}(H).\n$$\nThe code rate is defined as\n$$\nR = \\frac{k}{n}.\n$$\nGiven that $H$ has full row rank, we have $\\operatorname{rank}(H) = m$. Therefore,\n$$\nR = \\frac{n - m}{n}.\n$$\nWith $n = 8$ and $m = 4$, we substitute to obtain\n$$\nR = \\frac{8 - 4}{8} = \\frac{4}{8} = \\frac{1}{2}.\n$$", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "1638281"}, {"introduction": "With an understanding of a code's properties, we can now see how it functions in a practical scenario. The core purpose of a parity-check matrix, $H$, is to detect errors in a received message by calculating a syndrome vector, $s$. This practice demonstrates this fundamental error-detection mechanism, showing how a non-zero syndrome acts as a flag indicating that the received data has been corrupted during transmission. [@problem_id:1638282]", "problem": "In a digital communication system, a linear block code is used for error detection. Specifically, a type of Low-Density Parity-Check (LDPC) code is defined by its parity-check matrix $H$. All calculations involving the vector and matrix elements are performed in the Galois Field $\\mathrm{GF}(2)$, which means all additions and multiplications are performed modulo-2 (e.g., $1+1=0$).\n\nThe parity-check matrix $H$ for a particular $(6,3)$ code is given by:\n$$\nH = \\begin{pmatrix}\n1 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 1 & 0 & 1\n\\end{pmatrix}\n$$\nA vector is transmitted through a noisy channel, and the received vector is $y = (1, 1, 0, 0, 1, 1)$. To check for errors, the receiver calculates the syndrome vector, $s$, using the formula $s = H y^{\\top}$, where $y^{\\top}$ is the transpose of the vector $y$.\n\nCalculate the syndrome vector $s$ for the given received vector $y$. Express your answer as a column vector of binary digits.", "solution": "The problem asks for the calculation of the syndrome vector $s$ for a received vector $y = (1, 1, 0, 0, 1, 1)$ using the parity-check matrix $H$. The formula for the syndrome is given as $s = H y^{\\top}$, with all arithmetic performed modulo-2.\n\nFirst, we identify the given vector and matrix:\nThe received vector is $y = \\begin{pmatrix} 1 & 1 & 0 & 0 & 1 & 1 \\end{pmatrix}$. Its transpose is the column vector $y^{\\top} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 1 \\end{pmatrix}$.\nThe parity-check matrix is $H = \\begin{pmatrix}\n1 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 1 & 0 & 1\n\\end{pmatrix}$.\n\nNow we perform the matrix-vector multiplication $s = H y^{\\top}$. The resulting syndrome vector $s$ will be a $3 \\times 1$ column vector.\n$$\ns = \\begin{pmatrix}\n1 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 1 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 1 \\end{pmatrix}\n$$\n\nWe calculate each component of the syndrome vector $s$ by taking the dot product of each row of $H$ with the vector $y^{\\top}$. Remember that all additions are modulo-2.\n\nFor the first component, $s_1$:\n$s_1 = (1 \\cdot 1) + (0 \\cdot 1) + (0 \\cdot 0) + (1 \\cdot 0) + (1 \\cdot 1) + (0 \\cdot 1)$\n$s_1 = 1 + 0 + 0 + 0 + 1 + 0 = 2$\n$s_1 \\equiv 0 \\pmod{2}$\n\nFor the second component, $s_2$:\n$s_2 = (0 \\cdot 1) + (1 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1) + (1 \\cdot 1)$\n$s_2 = 0 + 1 + 0 + 0 + 1 + 1 = 3$\n$s_2 \\equiv 1 \\pmod{2}$\n\nFor the third component, $s_3$:\n$s_3 = (0 \\cdot 1) + (0 \\cdot 1) + (1 \\cdot 0) + (1 \\cdot 0) + (0 \\cdot 1) + (1 \\cdot 1)$\n$s_3 = 0 + 0 + 0 + 0 + 0 + 1 = 1$\n$s_3 \\equiv 1 \\pmod{2}$\n\nCombining the components, we get the syndrome vector $s = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}$.\nSince the syndrome vector is not the zero vector, this indicates that the received vector $y$ is not a valid codeword of the code defined by $H$.", "answer": "$$\\boxed{\\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}}$$", "id": "1638282"}, {"introduction": "Detecting an error is only the first step; the true strength of LDPC codes is their ability to correct those errors. This exercise provides a hands-on introduction to the logic of a simple yet powerful decoding technique known as the bit-flipping algorithm. By using the syndrome to identify which bit is most likely to be erroneous, you will perform the first corrective step in an iterative process designed to restore the original, error-free message. [@problem_id:1638271]", "problem": "In digital communication, error-correcting codes are used to detect and correct errors that occur during transmission over a noisy channel. Consider a simple binary linear block code, a type of Low-Density Parity-Check (LDPC) code, defined by the following parity-check matrix $H$ over the finite field $\\mathrm{GF}(2)$:\n$$\nH = \\begin{pmatrix}\n1 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 0 & 0 & 1 \\\\\n1 & 1 & 0 & 1 & 0 & 0\n\\end{pmatrix}\n$$\nThe rows of this matrix represent parity-check equations. For a vector to be a valid codeword, the result of multiplying it by $H^{\\top}$ must be the zero vector (all calculations are performed modulo 2).\n\nA 6-bit message is encoded and transmitted, but it gets corrupted by noise. The received vector is:\n$$\ny = \\begin{pmatrix} 0 & 1 & 1 & 0 & 0 & 0 \\end{pmatrix}\n$$\nWe will attempt to correct this vector using the first iteration of a hard-decision bit-flipping algorithm. The rule for this algorithm is as follows: For each of the 6 bit positions in the received vector, we count how many of the parity-check equations that involve that bit are currently unsatisfied (i.e., evaluate to 1 instead of 0). The bit position that is involved in the greatest number of unsatisfied parity-check equations is the one that should be flipped. For this problem, you will find there is a unique bit with the maximum count.\n\nDetermine the 1-based index (an integer from 1 to 6) of the bit in the received vector $y$ that should be flipped according to this rule.", "solution": "For a received vector $y$, the syndrome is $s = H y^{\\top}$ with arithmetic in $\\mathrm{GF}(2)$. A parity-check equation (row) is unsatisfied exactly when its syndrome component equals $1$.\n\nCompute the syndrome components row-wise:\n$$\ns_{1} = y_{1} + y_{3} + y_{5} \\ (\\mathrm{mod}\\ 2) = 0 + 1 + 0 = 1,\n$$\n$$\ns_{2} = y_{2} + y_{3} + y_{6} \\ (\\mathrm{mod}\\ 2) = 1 + 1 + 0 = 0,\n$$\n$$\ns_{3} = y_{1} + y_{2} + y_{4} \\ (\\mathrm{mod}\\ 2) = 0 + 1 + 0 = 1.\n$$\nThus\n$$\ns = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix},\n$$\nso the unsatisfied parity checks are rows $1$ and $3$.\n\nFor each bit position $j \\in \\{1,\\dots,6\\}$, the number of unsatisfied checks that involve bit $j$ is\n$$\nc_{j} = \\sum_{i=1}^{3} H_{i,j}\\, s_{i},\n$$\nwhere the sum is over the integers (since $s_{i} \\in \\{0,1\\}$). Using the columns of $H$ and $s=(1,0,1)^{\\top}$:\n$$\nc_{1} = 1\\cdot 1 + 0\\cdot 0 + 1\\cdot 1 = 2, \\quad\nc_{2} = 0\\cdot 1 + 1\\cdot 0 + 1\\cdot 1 = 1,\n$$\n$$\nc_{3} = 1\\cdot 1 + 1\\cdot 0 + 0\\cdot 1 = 1, \\quad\nc_{4} = 0\\cdot 1 + 0\\cdot 0 + 1\\cdot 1 = 1,\n$$\n$$\nc_{5} = 1\\cdot 1 + 0\\cdot 0 + 0\\cdot 1 = 1, \\quad\nc_{6} = 0\\cdot 1 + 1\\cdot 0 + 0\\cdot 1 = 0.\n$$\nThe unique maximum count is $c_{1}=2$, so the bit to flip is at index $1$.", "answer": "$$\\boxed{1}$$", "id": "1638271"}]}