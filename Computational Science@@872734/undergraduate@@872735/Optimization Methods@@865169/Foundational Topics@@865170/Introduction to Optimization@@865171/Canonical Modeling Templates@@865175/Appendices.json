{"hands_on_practices": [{"introduction": "This first exercise is a classic resource allocation problem, a cornerstone of linear programming. You will step into the role of a planner for a museum, tasked with distributing limited resources—floor space and power—to maximize a desired outcome, visitor engagement. This practice is fundamental for developing the core skill of translating a descriptive problem into a precise mathematical model with an objective function and a system of linear constraints [@problem_id:3106569].", "problem": "A museum wishes to allocate floor space and electrical power to a set of interactive exhibits to maximize visitor engagement. The decision variables are the floor space $x_i$ (in square meters, denoted as $\\text{m}^2$) and electrical power $p_i$ (in kilowatts, denoted as $\\text{kW}$) assigned to exhibit $i$ for $i \\in \\{1,\\dots,n\\}$. Engagement is modeled as a linear function $\\sum_{i=1}^{n} \\alpha_i x_i + \\sum_{i=1}^{n} \\beta_i p_i$, where $\\alpha_i$ and $\\beta_i$ are nonnegative coefficients reflecting marginal engagement per unit space and power, respectively. The allocations must satisfy resource constraints: a total space budget, a total power budget, per-exhibit upper bounds on space and power, and a linear coupling between power and space for each exhibit reflecting maximum power density.\n\nFrom the fundamental base of Linear Programming (LP), which optimizes a linear objective subject to linear constraints over a convex polyhedron, formulate the allocation problem as an LP and implement a solver that, for given parameters, computes the allocation vector that maximizes engagement. The feasible set must reflect the standard physical realism: nonnegative allocations, capacity limits, and linear coupling constraints of the form $p_i \\le r_i x_i$ where $r_i$ is the maximum allowable power density for exhibit $i$ measured in $\\text{kW}/\\text{m}^2$.\n\nYou must use the following canonical LP modeling template: define the decision vector $y = [x_1,\\dots,x_n,p_1,\\dots,p_n]^\\top$, construct a linear objective and linear inequality system that captures all constraints, and compute an optimal $y^\\star$.\n\nThe program must solve the LP for each test case below and output, for each case, a single list containing the optimal allocations and the optimal engagement value in the specific order $[x_1,\\dots,x_n,p_1,\\dots,p_n,z]$, where $z$ is the maximized value of $\\sum_{i=1}^{n} \\alpha_i x_i + \\sum_{i=1}^{n} \\beta_i p_i$. All $x_i$ must be interpreted in $\\text{m}^2$ and all $p_i$ must be interpreted in $\\text{kW}$; report numerical values only, with no unit symbols, rounded to four decimal places.\n\nFundamental definitions to use:\n- Linear Programming (LP): maximize or minimize a linear objective function subject to linear equality and inequality constraints over a set defined by linear bounds. The feasible region is a convex polyhedron, and an optimal solution (if one exists) is attained at an extreme point.\n- Nonnegativity and capacity constraints reflect physical limits of resources and equipment.\n\nYou must not use shortcut formulas beyond these fundamental bases. Derive the linear model from first principles: decision variables, objective, and constraints. Then solve the LP using a general-purpose solver.\n\nTest suite:\n- Case $1$ (happy path, moderately tight budgets, multiple exhibits, all constraints potentially active):\n  - Number of exhibits: $n = 3$.\n  - Engagement coefficients: $\\alpha = (3.0, 2.5, 1.0)$ and $\\beta = (5.0, 2.0, 4.0)$.\n  - Budgets: total space $S = 120.0$ $\\text{m}^2$, total power $P = 30.0$ $\\text{kW}$.\n  - Power density limits: $r = (0.20, 0.10, 0.25)$ $\\text{kW}/\\text{m}^2$.\n  - Per-exhibit upper bounds: $\\bar{x} = (60.0, 50.0, 80.0)$ $\\text{m}^2$, $\\bar{p} = (15.0, 20.0, 12.0)$ $\\text{kW}$.\n- Case $2$ (boundary case where total power is tight and coupling constraints are significant):\n  - Number of exhibits: $n = 3$.\n  - Engagement coefficients: $\\alpha = (2.0, 1.5, 3.0)$ and $\\beta = (1.0, 0.5, 2.0)$.\n  - Budgets: total space $S = 80.0$ $\\text{m}^2$, total power $P = 12.0$ $\\text{kW}$.\n  - Power density limits: $r = (0.15, 0.12, 0.20)$ $\\text{kW}/\\text{m}^2$.\n  - Per-exhibit upper bounds: $\\bar{x} = (40.0, 40.0, 60.0)$ $\\text{m}^2$, $\\bar{p} = (10.0, 10.0, 15.0)$ $\\text{kW}$.\n- Case $3$ (edge case with zero marginal engagement for space on one exhibit and zero marginal engagement for power on another, with tight coupling):\n  - Number of exhibits: $n = 2$.\n  - Engagement coefficients: $\\alpha = (0.0, 0.9)$ and $\\beta = (2.0, 0.0)$.\n  - Budgets: total space $S = 10.0$ $\\text{m}^2$, total power $P = 5.0$ $\\text{kW}$.\n  - Power density limits: $r = (0.50, 0.20)$ $\\text{kW}/\\text{m}^2$.\n  - Per-exhibit upper bounds: $\\bar{x} = (10.0, 10.0)$ $\\text{m}^2$, $\\bar{p} = (5.0, 1.0)$ $\\text{kW}$.\n\nModeling requirements:\n- Decision variables: $x_i \\ge 0$ and $p_i \\ge 0$ for all $i$.\n- Objective: maximize $\\sum_{i=1}^{n} \\alpha_i x_i + \\sum_{i=1}^{n} \\beta_i p_i$.\n- Constraints:\n  - Total space: $\\sum_{i=1}^{n} x_i \\le S$.\n  - Total power: $\\sum_{i=1}^{n} p_i \\le P$.\n  - Coupling: $p_i \\le r_i x_i$ for all $i$.\n  - Bounds: $0 \\le x_i \\le \\bar{x}_i$ and $0 \\le p_i \\le \\bar{p}_i$ for all $i$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list containing $[x_1,\\dots,x_n,p_1,\\dots,p_n,z]$ with all numbers rounded to four decimals. For example, in the correct format: $[[\\dots],[\\dots],[\\dots]]$ where there are no spaces after commas. Do not include unit symbols in the output; interpret $x_i$ values in $\\text{m}^2$ and $p_i$ values in $\\text{kW}$.", "solution": "The problem requires formulating a resource allocation scenario as a Linear Program (LP). The core task is to define the decision variables, objective function, and constraints based on the problem description.\n\n**1. Decision Variables**\nThe decision variables represent the amount of each resource allocated to each exhibit. We define two sets of variables:\n- $x_i$: The floor space (in $\\text{m}^2$) allocated to exhibit $i$, for $i \\in \\{1, \\dots, n\\}$.\n- $p_i$: The electrical power (in $\\text{kW}$) allocated to exhibit $i$, for $i \\in \\{1, \\dots, n\\}$.\nFor a standard LP solver, these $2n$ variables are consolidated into a single decision vector $y = [x_1, \\dots, x_n, p_1, \\dots, p_n]^\\top$.\n\n**2. Objective Function**\nThe goal is to maximize total visitor engagement, which is modeled as a linear function of the allocated resources.\n$$ \\text{maximize } z = \\sum_{i=1}^{n} \\alpha_i x_i + \\sum_{i=1}^{n} \\beta_i p_i $$\nIn vector notation, this is $\\text{maximize } c^\\top y$, where $c = [\\alpha_1, \\dots, \\alpha_n, \\beta_1, \\dots, \\beta_n]^\\top$ is the vector of engagement coefficients. Since standard LP solvers typically minimize, the problem is converted to minimizing $-c^\\top y$.\n\n**3. Constraints**\nThe allocations are subject to several linear constraints:\n- **Total Space Budget**: The sum of space allocated to all exhibits cannot exceed the total available space $S$.\n$$ \\sum_{i=1}^{n} x_i \\le S $$\n- **Total Power Budget**: The sum of power allocated to all exhibits cannot exceed the total available power $P$.\n$$ \\sum_{i=1}^{n} p_i \\le P $$\n- **Power Density Coupling**: For each exhibit $i$, the allocated power is limited by its allocated space, reflecting a maximum power density $r_i$.\n$$ p_i \\le r_i x_i \\quad \\text{or} \\quad -r_i x_i + p_i \\le 0 \\quad \\text{for all } i $$\n- **Variable Bounds**: Each allocation is non-negative and cannot exceed the per-exhibit upper bounds, $\\bar{x}_i$ and $\\bar{p}_i$.\n$$ 0 \\le x_i \\le \\bar{x}_i \\quad \\text{for all } i $$\n$$ 0 \\le p_i \\le \\bar{p}_i \\quad \\text{for all } i $$\n\nThese components define a complete LP model. The constraints can be expressed in the matrix form $A_{ub} y \\le b_{ub}$, and the bounds are handled directly by the solver. The implementation involves constructing these matrices and vectors from the test case parameters and passing them to a standard LP solver like `scipy.optimize.linprog`.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of linear programming problems for museum resource allocation.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"n\": 3,\n            \"alpha\": np.array([3.0, 2.5, 1.0]),\n            \"beta\": np.array([5.0, 2.0, 4.0]),\n            \"S\": 120.0,\n            \"P\": 30.0,\n            \"r\": np.array([0.20, 0.10, 0.25]),\n            \"x_bar\": np.array([60.0, 50.0, 80.0]),\n            \"p_bar\": np.array([15.0, 20.0, 12.0]),\n        },\n        # Case 2\n        {\n            \"n\": 3,\n            \"alpha\": np.array([2.0, 1.5, 3.0]),\n            \"beta\": np.array([1.0, 0.5, 2.0]),\n            \"S\": 80.0,\n            \"P\": 12.0,\n            \"r\": np.array([0.15, 0.12, 0.20]),\n            \"x_bar\": np.array([40.0, 40.0, 60.0]),\n            \"p_bar\": np.array([10.0, 10.0, 15.0]),\n        },\n        # Case 3\n        {\n            \"n\": 2,\n            \"alpha\": np.array([0.0, 0.9]),\n            \"beta\": np.array([2.0, 0.0]),\n            \"S\": 10.0,\n            \"P\": 5.0,\n            \"r\": np.array([0.50, 0.20]),\n            \"x_bar\": np.array([10.0, 10.0]),\n            \"p_bar\": np.array([5.0, 1.0]),\n        },\n    ]\n\n    results_for_all_cases = []\n    \n    for case in test_cases:\n        n = case[\"n\"]\n        alpha = case[\"alpha\"]\n        beta = case[\"beta\"]\n        S = case[\"S\"]\n        P = case[\"P\"]\n        r = case[\"r\"]\n        x_bar = case[\"x_bar\"]\n        p_bar = case[\"p_bar\"]\n\n        # Decision vector y = [x_1, ..., x_n, p_1, ..., p_n]\n        # Number of variables is 2*n\n        n_vars = 2 * n\n\n        # Objective function c_vector^T * y to be maximized.\n        # linprog minimizes, so we minimize -c_vector^T * y.\n        # c_vector = [alpha_1, ..., alpha_n, beta_1, ..., beta_n]\n        c = -np.concatenate([alpha, beta])\n\n        # Inequality constraints A_ub * y = b_ub\n        # There are n+2 such constraints: 1 for space, 1 for power, n for coupling.\n        A_ub = np.zeros((n + 2, n_vars))\n        b_ub = np.zeros(n + 2)\n\n        # 1. Total space constraint: sum(x_i) = S\n        A_ub[0, :n] = 1\n        b_ub[0] = S\n        \n        # 2. Total power constraint: sum(p_i) = P\n        A_ub[1, n:] = 1\n        b_ub[1] = P\n        \n        # 3. Coupling constraints: p_i = r_i * x_i  =  -r_i * x_i + p_i = 0\n        for i in range(n):\n            A_ub[2 + i, i] = -r[i]\n            A_ub[2 + i, n + i] = 1\n            b_ub[2 + i] = 0\n\n        # Bounds for each variable: 0 = y_i = u_i\n        # bounds = [(0, x_bar_1), ..., (0, x_bar_n), (0, p_bar_1), ..., (0, p_bar_n)]\n        bounds_x = [(0, val) for val in x_bar]\n        bounds_p = [(0, val) for val in p_bar]\n        bounds = bounds_x + bounds_p\n\n        # Solve the LP\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n        if res.success:\n            optimal_y = res.x\n            # The maximized objective value is -1 * minimized value\n            optimal_z = -res.fun\n            # Combine allocations and objective value into a single list\n            current_result = list(optimal_y) + [optimal_z]\n            results_for_all_cases.append(current_result)\n        else:\n            # Handle the case where the solver fails\n            # For this well-posed problem, this path should not be taken.\n            # Fill with NaN or handle error as appropriate.\n            # Using NaN of the correct size to avoid crashing the output formatting.\n            results_for_all_cases.append([np.nan] * (n_vars + 1))\n\n    # Format the final output string as per requirements:\n    # [[case1_results],[case2_results],...] with no spaces and 4 decimal places.\n    output_parts = []\n    for res_list in results_for_all_cases:\n        formatted_numbers = [f\"{num:.4f}\" for num in res_list]\n        part_str = \"[\" + \",\".join(formatted_numbers) + \"]\"\n        output_parts.append(part_str)\n        \n    final_output_string = \"[\" + \",\".join(output_parts) + \"]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3106569"}, {"introduction": "Many optimization problems, from logistics to data routing, can be elegantly modeled as finding the most efficient flow through a network. This practice moves beyond simple network models by introducing a common real-world feature: non-linear costs. You will learn a powerful and widely-used technique to handle convex piecewise-linear costs by linearizing the objective function, allowing you to solve a seemingly complex problem using standard linear programming tools [@problem_id:3106543].", "problem": "You are asked to build and solve a single-commodity minimum-cost network flow model with piecewise-linear arc costs using Linear Programming (LP). The fundamental base is the network flow conservation law: for each node, the total outflow minus total inflow equals the node’s net supply (positive for sources) or demand (negative for sinks), and the definition of linear optimization, where a linear objective function is minimized subject to linear equality constraints and variable bounds.\n\nEach directed arc $(i,j)$ has a capacity $u_{ij}$ and a convex piecewise-linear cost of the form $c_{ij}(f_{ij}) = a_{ij} f_{ij} + b_{ij} \\max(0, f_{ij} - \\theta_{ij})$, where $f_{ij}$ is the flow on arc $(i,j)$, $a_{ij} \\ge 0$, $b_{ij} \\ge 0$, and $\\theta_{ij} \\ge 0$. To obtain a linear program, represent $f_{ij}$ using two nonnegative segment variables that split the flow relative to the threshold $\\theta_{ij}$ and enforce appropriate bounds and conservation. Minimize the total cost subject to flow conservation at each node and arc capacity limits.\n\nYour program must:\n- Formulate the LP implied by the above description for each test case by introducing segment variables per arc to linearize the cost, enforce segment bounds derived from $u_{ij}$ and $\\theta_{ij}$, and enforce node-wise flow conservation equalities derived from the node supplies and demands.\n- Solve the LP and return the optimal objective value (total cost) as a decimal number for each test case.\n\nNo physical units are involved. All numbers are dimensionless.\n\nTest Suite:\nProvide a single program that solves the following three test cases. Each test case describes a directed network. Nodes are denoted by labels, and arcs are described by their parameters. All mathematical entities, including numbers, are written in LaTeX.\n\n- Test Case $1$ (happy path, mixed thresholds and capacities):\n  - Nodes: $\\{S,A,B,T\\}$.\n  - Supplies/Demands: $s_S = 6$, $s_A = 0$, $s_B = 0$, $s_T = -6$.\n  - Arcs:\n    - $(S,A)$: $a_{SA}=2$, $b_{SA}=3$, $\\theta_{SA}=3$, $u_{SA}=5$.\n    - $(S,B)$: $a_{SB}=1$, $b_{SB}=0.5$, $\\theta_{SB}=1$, $u_{SB}=4$.\n    - $(A,T)$: $a_{AT}=1.5$, $b_{AT}=2$, $\\theta_{AT}=2$, $u_{AT}=4$.\n    - $(B,T)$: $a_{BT}=2$, $b_{BT}=1$, $\\theta_{BT}=4$, $u_{BT}=5$.\n    - $(S,T)$: $a_{ST}=3$, $b_{ST}=1$, $\\theta_{ST}=1$, $u_{ST}=2$.\n\n- Test Case $2$ (boundary case: capacity equals threshold or capacity below threshold):\n  - Nodes: $\\{S,A,T\\}$.\n  - Supplies/Demands: $s_S = 5$, $s_A = 0$, $s_T = -5$.\n  - Arcs:\n    - $(S,A)$: $a_{SA}=1$, $b_{SA}=5$, $\\theta_{SA}=3$, $u_{SA}=3$.\n    - $(A,T)$: $a_{AT}=2$, $b_{AT}=4$, $\\theta_{AT}=5$, $u_{AT}=3$.\n    - $(S,T)$: $a_{ST}=4$, $b_{ST}=0$, $\\theta_{ST}=2$, $u_{ST}=2$.\n\n- Test Case $3$ (edge case: zero threshold):\n  - Nodes: $\\{S,C,T\\}$.\n  - Supplies/Demands: $s_S = 4$, $s_C = 0$, $s_T = -4$.\n  - Arcs:\n    - $(S,C)$: $a_{SC}=1$, $b_{SC}=2$, $\\theta_{SC}=0$, $u_{SC}=5$.\n    - $(C,T)$: $a_{CT}=1$, $b_{CT}=1$, $\\theta_{CT}=0$, $u_{CT}=5$.\n    - $(S,T)$: $a_{ST}=0$, $b_{ST}=0$, $\\theta_{ST}=0$, $u_{ST}=1$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the optimal objective values for the three test cases as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3]$). Each $result_k$ must be a decimal number (a float). The program must be self-contained, require no input, and directly solve the three provided test cases as specified.", "solution": "The problem asks for the formulation and solution of a single-commodity minimum-cost network flow problem where the cost on each arc is a convex, piecewise-linear function of the flow. The problem is to be modeled as a Linear Program (LP).\n\nThe fundamental principle is the transformation of a convex piecewise-linear objective function into a linear one by introducing new variables that represent the flow on different segments of the cost function. Because the original objective function is convex and the constraints are linear, a minimizer will naturally prioritize using flow on cheaper segments before using more expensive ones, validating this decomposition without needing extra integer variables or special branching rules.\n\nLet the network be represented by a directed graph $G = (V, E)$, where $V$ is the set of nodes and $E$ is the set of arcs. For each node $i \\in V$, there is a net supply $s_i$. If $s_i  0$, node $i$ is a source. If $s_i  0$, it is a sink. If $s_i = 0$, it is a transshipment node. For a valid problem, the total supply must equal the total demand, i.e., $\\sum_{i \\in V} s_i = 0$.\n\nFor each arc $(i,j) \\in E$, we are given:\n- $u_{ij}$: the maximum capacity of the arc.\n- A convex piecewise-linear cost function $c_{ij}(f_{ij})$ for the flow $f_{ij}$ on the arc, defined as:\n$$ c_{ij}(f_{ij}) = a_{ij} f_{ij} + b_{ij} \\max(0, f_{ij} - \\theta_{ij}) $$\nwhere $a_{ij} \\ge 0$, $b_{ij} \\ge 0$, and $\\theta_{ij} \\ge 0$ is the flow threshold where the cost function's slope changes.\n\nThe optimization problem is:\n$$ \\text{minimize} \\quad Z = \\sum_{(i,j) \\in E} c_{ij}(f_{ij}) $$\nsubject to:\n$1$. Flow conservation at each node $k \\in V$:\n$$ \\sum_{j:(k,j) \\in E} f_{kj} - \\sum_{i:(i,k) \\in E} f_{ik} = s_k $$\n$2$. Arc capacity constraints for each arc $(i,j) \\in E$:\n$$ 0 \\le f_{ij} \\le u_{ij} $$\n\nTo linearize the objective function, we decompose the flow variable $f_{ij}$ for each arc into two non-negative variables, $f_{ij}^{(1)}$ and $f_{ij}^{(2)}$:\n$$ f_{ij} = f_{ij}^{(1)} + f_{ij}^{(2)} $$\nThese variables represent the flow in the two linear segments of the cost function:\n- $f_{ij}^{(1)}$ is the flow in the first segment, up to the threshold $\\theta_{ij}$.\n- $f_{ij}^{(2)}$ is the flow in the second segment, beyond the threshold $\\theta_{ij}$.\n\nThis decomposition is governed by the following bounds:\n$$ 0 \\le f_{ij}^{(1)} \\le \\theta_{ij} $$\n$$ f_{ij}^{(2)} \\ge 0 $$\nWith this, the term $\\max(0, f_{ij} - \\theta_{ij})$ in the cost function is equivalent to $f_{ij}^{(2)}$. The cost function for arc $(i,j)$ can now be rewritten as a linear function of these new variables:\n$$ c_{ij}(f_{ij}^{(1)}, f_{ij}^{(2)}) = a_{ij} (f_{ij}^{(1)} + f_{ij}^{(2)}) + b_{ij} f_{ij}^{(2)} = a_{ij} f_{ij}^{(1)} + (a_{ij} + b_{ij}) f_{ij}^{(2)} $$\nThe marginal cost of flow on the first segment is $a_{ij}$, and on the second segment, it is $a_{ij} + b_{ij}$. Since $b_{ij} \\ge 0$, the cost of the second segment is always greater than or equal to the first. An LP solver minimizing the total cost will therefore automatically saturate the first segment (up to its bound $\\theta_{ij}$) before assigning any flow to the second, more expensive segment.\n\nThe complete LP formulation is as follows:\n\n**Decision Variables:**\nFor each arc $(i,j) \\in E$, we have two variables, $f_{ij}^{(1)}$ and $f_{ij}^{(2)}$.\n\n**Objective Function:**\nMinimize the total linear cost:\n$$ \\text{minimize} \\quad Z = \\sum_{(i,j) \\in E} \\left( a_{ij} f_{ij}^{(1)} + (a_{ij} + b_{ij}) f_{ij}^{(2)} \\right) $$\n\n**Constraints:**\n$1$. Flow conservation for each node $k \\in V$:\n$$ \\sum_{j:(k,j) \\in E} \\left( f_{kj}^{(1)} + f_{kj}^{(2)} \\right) - \\sum_{i:(i,k) \\in E} \\left( f_{ik}^{(1)} + f_{ik}^{(2)} \\right) = s_k $$\nThis forms a set of linear equality constraints ($A_{eq}x = b_{eq}$).\n\n$2$. Arc capacity for each arc $(i,j) \\in E$:\n$$ f_{ij}^{(1)} + f_{ij}^{(2)} \\le u_{ij} $$\nThis forms a set of linear inequality constraints ($A_{ub}x \\le b_{ub}$).\n\n$3$. Variable bounds for each arc $(i,j) \\in E$:\n$$ 0 \\le f_{ij}^{(1)} \\le \\theta_{ij} $$\n$$ f_{ij}^{(2)} \\ge 0 $$\nThe upper bound on $f_{ij}^{(2)}$ is implicitly handled by the arc capacity constraint. The standard LP form combines these into a single bounds vector.\n\nThis formulation is implemented for each test case. The node and arc data are used to construct the objective vector $c$, the constraint matrices $A_{eq}$ and $A_{ub}$, the corresponding right-hand-side vectors $b_{eq}$ and $b_{ub}$, and the variable bounds. A standard LP solver, such as `scipy.optimize.linprog`, is then used to find the solution vector $x = [..., f_{ij}^{(1)}, f_{ij}^{(2)}, ...]^T$ that minimizes the objective function $Z$. The optimal value of $Z$ is the minimum total cost for the network flow, which is the required output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves three minimum-cost network flow problems with piecewise-linear costs.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"nodes\": [\"S\", \"A\", \"B\", \"T\"],\n            \"supplies\": {\"S\": 6.0, \"A\": 0.0, \"B\": 0.0, \"T\": -6.0},\n            \"arcs\": [\n                # (from, to, a, b, theta, u)\n                (\"S\", \"A\", 2.0, 3.0, 3.0, 5.0),\n                (\"S\", \"B\", 1.0, 0.5, 1.0, 4.0),\n                (\"A\", \"T\", 1.5, 2.0, 2.0, 4.0),\n                (\"B\", \"T\", 2.0, 1.0, 4.0, 5.0),\n                (\"S\", \"T\", 3.0, 1.0, 1.0, 2.0)\n            ]\n        },\n        # Test Case 2\n        {\n            \"nodes\": [\"S\", \"A\", \"T\"],\n            \"supplies\": {\"S\": 5.0, \"A\": 0.0, \"T\": -5.0},\n            \"arcs\": [\n                (\"S\", \"A\", 1.0, 5.0, 3.0, 3.0),\n                (\"A\", \"T\", 2.0, 4.0, 5.0, 3.0),\n                (\"S\", \"T\", 4.0, 0.0, 2.0, 2.0)\n            ]\n        },\n        # Test Case 3\n        {\n            \"nodes\": [\"S\", \"C\", \"T\"],\n            \"supplies\": {\"S\": 4.0, \"C\": 0.0, \"T\": -4.0},\n            \"arcs\": [\n                (\"S\", \"C\", 1.0, 2.0, 0.0, 5.0),\n                (\"C\", \"T\", 1.0, 1.0, 0.0, 5.0),\n                (\"S\", \"T\", 0.0, 0.0, 0.0, 1.0)\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        supplies = case[\"supplies\"]\n        arcs_data = case[\"arcs\"]\n\n        num_nodes = len(nodes)\n        num_arcs = len(arcs_data)\n        num_vars = 2 * num_arcs\n\n        node_map = {name: i for i, name in enumerate(nodes)}\n\n        # LP formulation: min c'x s.t. A_eq x = b_eq, A_ub x = b_ub, and bounds on x.\n        \n        # 1. Objective function vector c\n        c = np.zeros(num_vars)\n        for i, arc in enumerate(arcs_data):\n            _, _, a, b, _, _ = arc\n            c[2 * i] = a         # Cost for the first segment f_ij^(1)\n            c[2 * i + 1] = a + b # Cost for the second segment f_ij^(2)\n            \n        # 2. Equality constraints A_eq, b_eq (flow conservation)\n        A_eq = np.zeros((num_nodes, num_vars))\n        b_eq = np.array([supplies[name] for name in nodes])\n        \n        for i, arc in enumerate(arcs_data):\n            u_name, v_name, _, _, _, _ = arc\n            u_idx, v_idx = node_map[u_name], node_map[v_name]\n            \n            # For arc i, variables are at 2*i and 2*i+1.\n            # Total flow on arc i is f_i^(1) + f_i^(2).\n            # It is an outflow from node u, so coefficient is +1.\n            A_eq[u_idx, 2 * i] = 1.0\n            A_eq[u_idx, 2 * i + 1] = 1.0\n            \n            # It is an inflow to node v, so coefficient is -1.\n            A_eq[v_idx, 2 * i] = -1.0\n            A_eq[v_idx, 2 * i + 1] = -1.0\n\n        # 3. Inequality constraints A_ub, b_ub (arc capacity)\n        A_ub = np.zeros((num_arcs, num_vars))\n        b_ub = np.zeros(num_arcs)\n        for i, arc in enumerate(arcs_data):\n            _, _, _, _, _, u_cap = arc\n            # f_i^(1) + f_i^(2) = u_i\n            A_ub[i, 2 * i] = 1.0\n            A_ub[i, 2 * i + 1] = 1.0\n            b_ub[i] = u_cap\n\n        # 4. Variable bounds\n        bounds = []\n        for arc in arcs_data:\n            _, _, _, _, theta, _ = arc\n            # 0 = f_i^(1) = theta_i\n            bounds.append((0, theta))\n            # 0 = f_i^(2)\n            bounds.append((0, None))\n\n        # Solve the Linear Program\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        if res.success:\n            results.append(res.fun)\n        else:\n            # This path is not expected for the given valid test cases.\n            results.append(float('nan')) \n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3106543"}, {"introduction": "Our final practice introduces a new level of modeling power by incorporating discrete, \"all-or-nothing\" decisions. Here, an activity yields a benefit only if a minimum resource threshold is met, a common scenario in project investment and activation problems. You will use binary variables to model this logical \"if-then\" condition, transforming the problem into a Mixed-Integer Linear Program (MILP) and discovering its deep connection to the classic $0/1$ knapsack problem [@problem_id:3106648].", "problem": "A finite set of activities indexed by $i \\in \\{0,1,\\dots,n-1\\}$ is available. For each $i$, there is a nonnegative integer benefit $b_i$, a nonnegative integer threshold $T_i$, and a nonnegative integer upper bound $U_i$. A nonnegative integer budget $B$ is available for allocating a scalar resource $x_i$ to each activity. Benefits accrue only if the resource allocation to activity $i$ meets or exceeds its threshold. Introduce binary decision variables $z_i \\in \\{0,1\\}$ indicating whether activity $i$ is activated and integer resource allocations $x_i \\ge 0$. The optimization problem is\n$$\n\\max \\sum_{i=0}^{n-1} b_i z_i\n$$\nsubject to\n$$\n\\sum_{i=0}^{n-1} x_i \\le B, \\quad x_i \\ge T_i z_i, \\quad x_i \\le U_i z_i, \\quad x_i \\in \\mathbb{Z}_{\\ge 0}, \\quad z_i \\in \\{0,1\\} \\quad \\text{for all } i.\n$$\nThis is a canonical resource allocation model with threshold effects and upper bounds, representable as a Mixed-Integer Linear Program (MILP), where the threshold ensures that benefit only accrues if $x_i$ reaches $T_i$ and the upper bound constrains $x_i$.\n\nYour task is to write a complete program that, for each supplied test case, computes the set of indices of activities selected at optimality under the above model. If multiple optimal selections achieve the same maximal objective value, your program must return the lexicographically smallest ascending list of indices among the optimal selections. An activity $i$ for which $U_i  T_i$ cannot be feasibly activated (no $x_i$ satisfies both $x_i \\ge T_i$ and $x_i \\le U_i$ when $z_i=1$), so any feasible optimal solution must set $z_i=0$ for such $i$.\n\nAll parameters in the test suite are integers, so the resource budget and allocations are integer-valued. No physical units are involved.\n\nTest suite:\n- Case A (general case): $b=[9,6,4,7,5,3]$, $T=[5,3,2,6,4,2]$, $U=[8,3,5,6,10,2]$, $B=12$.\n- Case B (boundary budget too small): $b=[5,4,3]$, $T=[2,2,3]$, $U=[5,5,3]$, $B=1$.\n- Case C (invalid activations present): $b=[8,7,6,4]$, $T=[4,3,5,2]$, $U=[3,3,4,4]$, $B=6$.\n- Case D (ties in optimal benefit require lexicographic tie-breaking): $b=[8,8,8,8]$, $T=[5,5,5,5]$, $U=[5,5,5,5]$, $B=10$.\n- Case E (zero-threshold items): $b=[1,2,3]$, $T=[0,0,5]$, $U=[0,4,5]$, $B=4$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the ascending list of selected indices for the corresponding test case, with no spaces anywhere. For example, the output must look like\n$$\n[[i\\_1^{(A)},i\\_2^{(A)},\\dots],[\\dots],\\dots]\n$$\nSpecifically, the output must be a single line of the form \"[[...],[...],[...],[...],[...]]\" with no spaces, and each inner list must contain the selected indices in strictly increasing order.", "solution": "The problem is a resource allocation task with threshold effects, formulated as a Mixed-Integer Linear Program (MILP). A key insight simplifies the problem significantly. The objective function, $\\max \\sum b_i z_i$, depends only on the binary activation variables $z_i$, not on the continuous allocation values $x_i$. Our goal is to activate the most valuable set of activities possible within the given budget $B$.\n\nLet's analyze the constraints on $x_i$ for an activated activity $i$ (where $z_i=1$):\n$$ T_i \\le x_i \\le U_i $$\nThis implies two conditions:\n1.  To activate activity $i$, we must allocate at least $T_i$ resources to it.\n2.  Activation is only feasible if the threshold does not exceed the upper bound, i.e., $T_i \\le U_i$. Any activity with $T_i > U_i$ cannot be activated.\n\nTo maximize the total benefit, we want to activate a set of activities while consuming the minimum necessary resources, thereby leaving the budget available for other high-benefit activities. The minimum resource cost to activate activity $i$ is its threshold, $T_i$. We can therefore set $x_i = T_i$ for every activated activity $i$ without any loss of optimality. If a solution uses $x_i > T_i$, we can reduce it to $x_i = T_i$, which maintains the same benefit but reduces resource consumption, making the solution potentially better or equally good.\n\nThis reduces the original MILP to the classic **0/1 Knapsack Problem**:\n- **Items**: The set of valid activities $i$ for which $T_i \\le U_i$.\n- **Item Value**: The benefit $b_i$.\n- **Item Weight**: The minimum resource cost to activate, $T_i$.\n- **Knapsack Capacity**: The total budget $B$.\n\nThe problem is now to select a subset of items (valid activities) that maximizes the total value (benefit) without the total weight (cost) exceeding the knapsack capacity (budget).\n$$ \\text{maximize} \\quad \\sum_{i \\in I_{\\text{valid}}} b_i z_i $$\n$$ \\text{subject to} \\quad \\sum_{i \\in I_{\\text{valid}}} T_i z_i \\le B $$\n$$ z_i \\in \\{0,1\\} $$\nwhere $I_{\\text{valid}} = \\{i \\mid T_i \\le U_i\\}$.\n\nGiven the small number of activities in the test cases, this problem can be solved optimally using an exhaustive search (brute force). The algorithm iterates through all $2^k$ possible subsets of the $k$ valid activities. For each subset, it calculates the total cost and benefit. It keeps track of the feasible subset that yields the highest benefit. In case of a tie in benefit, the lexicographically smallest list of indices is chosen, as required by the problem's tie-breaking rule.", "answer": "```python\nimport numpy as np\n\ndef _solve_knapsack_variant(b, T, U, B):\n    \"\"\"\n    Solves the resource allocation problem by reducing it to a 0/1 knapsack\n    problem and using brute-force search over all subsets of activities.\n    \n    This approach is feasible given the small number of activities in test cases.\n    \"\"\"\n    n = len(b)\n    \n    # 1. Filter out invalid activities where the threshold is greater than the upper bound.\n    # The list comprehension preserves the ascending order of indices.\n    valid_indices = [i for i in range(n) if T[i] = U[i]]\n    num_valid = len(valid_indices)\n    \n    max_benefit = -1  # A value lower than any possible benefit (e.g., 0 for empty set)\n    best_selection = []\n    \n    # 2. Iterate through all 2^num_valid subsets of valid activities.\n    # Each integer `i` from 0 to 2^num_valid - 1 represents a unique subset.\n    for i in range(1  num_valid):\n        current_selection = []\n        current_cost = 0\n        current_benefit = 0\n        \n        # Construct the subset based on the bits of `i`.\n        for j in range(num_valid):\n            if (i  j)  1:\n                # If the j-th bit is set, include the j-th valid activity.\n                idx = valid_indices[j]\n                current_selection.append(idx)\n                current_cost += T[idx]\n                current_benefit += b[idx]\n\n        # 3. Evaluate the current subset.\n        if current_cost = B:\n            # The selection is feasible.\n            # 4. Check if it's better than the best one found so far.\n            if current_benefit  max_benefit:\n                max_benefit = current_benefit\n                best_selection = current_selection\n            elif current_benefit == max_benefit:\n                # Tie-breaking rule: choose the lexicographically smallest list of indices.\n                # `current_selection` is guaranteed to be sorted because `valid_indices`\n                # and the inner loop order are both ascending.\n                # `best_selection` is also always sorted.\n                if current_selection  best_selection:\n                    best_selection = current_selection\n                    \n    return best_selection\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver for each,\n    and print the results in the required format.\n    \"\"\"\n    # Define the test suite from the problem statement.\n    test_cases = [\n        # Case A (general case)\n        {'b': np.array([9,6,4,7,5,3]), 'T': np.array([5,3,2,6,4,2]), 'U': np.array([8,3,5,6,10,2]), 'B': 12},\n        # Case B (boundary budget too small)\n        {'b': np.array([5,4,3]), 'T': np.array([2,2,3]), 'U': np.array([5,5,3]), 'B': 1},\n        # Case C (invalid activations present)\n        {'b': np.array([8,7,6,4]), 'T': np.array([4,3,5,2]), 'U': np.array([3,3,4,4]), 'B': 6},\n        # Case D (ties in optimal benefit require lexicographic tie-breaking)\n        {'b': np.array([8,8,8,8]), 'T': np.array([5,5,5,5]), 'U': np.array([5,5,5,5]), 'B': 10},\n        # Case E (zero-threshold items)\n        {'b': np.array([1,2,3]), 'T': np.array([0,0,5]), 'U': np.array([0,4,5]), 'B': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Solve each case\n        result = _solve_knapsack_variant(**case)\n        results.append(result)\n\n    # Format the final output string according to the specification:\n    # \"[[...],[...],...]\" with no spaces.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver\nsolve()\n```", "id": "3106648"}]}