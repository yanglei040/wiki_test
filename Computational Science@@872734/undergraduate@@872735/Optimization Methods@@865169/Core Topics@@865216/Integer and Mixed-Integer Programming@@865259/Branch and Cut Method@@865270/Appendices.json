{"hands_on_practices": [{"introduction": "We begin with the core mechanism of generating a cutting plane. When a linear programming relaxation yields a solution with fractional values for variables that must be integers, we need a systematic way to create a new constraint that \"cuts off\" this invalid point without removing any valid integer solutions. This exercise guides you through the step-by-step derivation of a Gomory mixed-integer cut, one of the foundational techniques in integer programming, showing how these inequalities are constructed from first principles using a simplex tableau row [@problem_id:3104181].", "problem": "Consider a $0$–$1$ knapsack problem with decision variables $x_{1}, x_{2}, x_{3}, x_{4} \\in \\{0,1\\}$, capacity constraint $\\sum_{i=1}^{4} w_{i} x_{i} \\leq W$, and a linear objective $\\sum_{i=1}^{4} p_{i} x_{i}$ to be maximized. In the linear programming (LP) relaxation, the variable bounds $x_{i} \\leq 1$ are represented as equalities $x_{i} + s_{i} = 1$ with slack variables $s_{i} \\geq 0$. Suppose the LP relaxation has been solved to an optimal basic feasible solution $\\hat{x}$ in the simplex tableau, where the integer-constrained basic variable is $x_{3}$ and its tableau row is\n$$\nx_{3} + 2.75\\, s_{1} - 1.30\\, s_{2} + 0.45\\, s_{4} = 0.37462.\n$$\nAssume that at this LP solution, the nonbasic slack variables in this row satisfy $\\hat{s}_{1} = 0$, $\\hat{s}_{2} = 0$, and $\\hat{s}_{4} = 0$, so the value of the basic variable is $\\hat{x}_{3} = 0.37462$, which is fractional and therefore infeasible for the $0$–$1$ knapsack.\n\nUsing only the fundamental definitions of integer variables, floor and fractional-part operations, and the structure of the simplex tableau, derive the Gomory fractional cut appropriate for a mixed-integer tableau row of the form $x_{k} + \\sum_{j} a_{j} s_{j} = b_{k}$ where $x_{k}$ is required to be integer and $s_{j} \\geq 0$ are continuous. Then, apply this derivation to the given row to obtain the specific cut, and compute the amount by which the LP solution $\\hat{x}$ violates this cut; that is, compute the quantity\n$$\n\\text{violation} \\;=\\; \\text{RHS} \\;-\\; \\text{LHS evaluated at } \\hat{s}.\n$$\nRound your final numerical answer to four significant figures, and report the violation as a pure number with no units.", "solution": "The task is to derive the Gomory fractional cut for a general mixed-integer programming problem and then apply it to a specific tableau row from a $0$–$1$ knapsack problem. Finally, we must compute the amount by which the current linear programming (LP) relaxation solution violates this cut.\n\nFirst, we derive the Gomory mixed-integer cut.\nConsider a general row from an optimal simplex tableau for an LP relaxation of a mixed-integer program:\n$$ x_{k} + \\sum_{j \\in N} a_{j} s_{j} = b_{k} $$\nIn this equation, $x_k$ is a basic variable that is required to be an integer. The variables $s_j$ for $j \\in N$ are the non-basic variables, which are assumed to be continuous and non-negative ($s_j \\ge 0$). At the current basic feasible solution, $s_j=0$ for all $j \\in N$, which implies $x_k = b_k$. The problem arises when $b_k$ is not an integer, violating the integrality constraint on $x_k$.\n\nLet $f_0$ be the fractional part of $b_k$, defined as $f_0 = b_k - \\lfloor b_k \\rfloor$. Since $b_k$ is not an integer, we have $0 < f_0 < 1$. The tableau equation can be rewritten by isolating the terms involving the non-basic variables:\n$$ \\sum_{j \\in N} a_{j} s_{j} = b_k - x_k $$\nSubstituting $b_k = \\lfloor b_k \\rfloor + f_0$, we get:\n$$ \\sum_{j \\in N} a_{j} s_{j} = \\lfloor b_k \\rfloor - x_k + f_0 $$\nFor any feasible solution to the mixed-integer problem, $x_k$ must be an integer. Since $\\lfloor b_k \\rfloor$ is also an integer, the term $I = \\lfloor b_k \\rfloor - x_k$ must be an integer. The equation thus becomes:\n$$ \\sum_{j \\in N} a_{j} s_{j} = I + f_0, \\quad \\text{for some integer } I $$\nTo proceed, we partition the set of indices of non-basic variables $N$ into two disjoint sets: $N^+ = \\{ j \\in N \\mid a_j \\ge 0 \\}$ and $N^- = \\{ j \\in N \\mid a_j < 0 \\}$. The equation is then:\n$$ \\sum_{j \\in N^+} a_{j} s_{j} + \\sum_{j \\in N^-} a_{j} s_{j} = I + f_0 $$\nWe analyze two cases based on the integer value of $I$.\n\nCase 1: $I \\ge 0$.\nGiven that $s_j \\ge 0$ for all $j$, and $a_j < 0$ for $j \\in N^-$, the term $\\sum_{j \\in N^-} a_{j} s_{j}$ must be non-positive ($\\le 0$). Therefore, we can write:\n$$ \\sum_{j \\in N^+} a_{j} s_{j} \\ge I + f_0 $$\nSince $I$ is an integer and $I \\ge 0$, the right-hand side is minimized when $I=0$. This gives $I+f_0 \\ge f_0$. Thus, for this case, any feasible integer solution must satisfy:\n$$ \\sum_{j \\in N^+} a_{j} s_{j} \\ge f_0 $$\n\nCase 2: $I \\le -1$.\nGiven that $s_j \\ge 0$ for all $j$, and $a_j \\ge 0$ for $j \\in N^+$, the term $\\sum_{j \\in N^+} a_{j} s_{j}$ must be non-negative ($\\ge 0$). Therefore, we have:\n$$ \\sum_{j \\in N^-} a_{j} s_{j} \\le I + f_0 $$\nSince $0 < f_0 < 1$, the term $f_0 - 1$ is negative. Multiplying the inequality by the negative quantity $\\frac{f_0}{f_0-1}$ reverses the inequality sign:\n$$ \\frac{f_0}{f_0 - 1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge \\frac{f_0}{f_0 - 1} (I + f_0) $$\nFor the right-hand side, since $I$ is an integer and $I \\le -1$, we have $I + f_0 \\le -1 + f_0 = -(1-f_0)$. Dividing by $f_0 - 1 = -(1-f_0)$ reverses the inequality again: $\\frac{I+f_0}{f_0-1} \\ge \\frac{-(1-f_0)}{-(1-f_0)} = 1$. Multiplying by $f_0 > 0$ yields $\\frac{f_0(I+f_0)}{f_0-1} \\ge f_0$. Thus, for this case, any feasible integer solution must satisfy:\n$$ \\frac{f_0}{f_0 - 1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge f_0 $$\n\nA valid cut must hold for any feasible integer solution, which must fall into either Case 1 or Case 2. We can combine the two derived inequalities into a single valid cut.\nNote that $\\sum_{j \\in N^+} a_{j} s_{j} \\ge 0$ and $\\frac{f_0}{f_0-1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge 0$.\nIf a solution is in Case 1, it satisfies $\\sum_{j \\in N^+} a_j s_j \\ge f_0$. Adding the non-negative term $\\frac{f_0}{f_0-1} \\sum_{j \\in N^-} a_j s_j$ to the left side preserves the inequality.\nIf a solution is in Case 2, it satisfies $\\frac{f_0}{f_0 - 1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge f_0$. Adding the non-negative term $\\sum_{j \\in N^+} a_j s_j$ to the left side preserves the inequality.\nTherefore, the following inequality is valid for all feasible integer solutions:\n$$ \\sum_{j \\in N^+} a_{j} s_{j} + \\frac{f_0}{f_0 - 1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge f_0 $$\nThis is the Gomory mixed-integer fractional cut.\n\nNow, we apply this derivation to the specific tableau row provided:\n$$ x_{3} + 2.75\\, s_{1} - 1.30\\, s_{2} + 0.45\\, s_{4} = 0.37462 $$\nHere, the integer basic variable is $x_k = x_3$. The non-basic variables are $s_1, s_2, s_4$.\nThe right-hand side is $b_3 = 0.37462$. The fractional part is $f_0 = b_3 - \\lfloor b_3 \\rfloor = 0.37462 - 0 = 0.37462$.\nThe coefficients of the non-basic variables are $a_1 = 2.75$, $a_2 = -1.30$, and $a_4 = 0.45$.\nWe classify them based on their sign:\n$N^+ = \\{1, 4\\}$ since $a_1 = 2.75 > 0$ and $a_4 = 0.45 > 0$.\n$N^- = \\{2\\}$ since $a_2 = -1.30 < 0$.\n\nSubstituting these values into the general cut formula:\n$$ a_1 s_1 + a_4 s_4 + \\frac{f_0}{f_0 - 1} a_2 s_2 \\ge f_0 $$\n$$ 2.75\\, s_{1} + 0.45\\, s_{4} + \\left( \\frac{0.37462}{0.37462 - 1} \\right) (-1.30)\\, s_{2} \\ge 0.37462 $$\nThe coefficient for $s_2$ is calculated as:\n$$ \\left( \\frac{0.37462}{-0.62538} \\right) (-1.30) = \\frac{-0.487006}{-0.62538} \\approx 0.778736 $$\nSo, the specific cut is:\n$$ 2.75\\, s_{1} + 0.778736...\\, s_{2} + 0.45\\, s_{4} \\ge 0.37462 $$\nThe problem asks for the violation of this cut at the current LP solution. At an optimal LP tableau, all non-basic variables are zero. So, $\\hat{s}_1 = 0$, $\\hat{s}_2 = 0$, and $\\hat{s}_4 = 0$.\nThe violation is defined as $\\text{RHS} - \\text{LHS}$, evaluated at the current solution $\\hat{s}$.\nThe left-hand side (LHS) of the cut at the current solution is:\n$$ \\text{LHS} = 2.75(0) + 0.778736...(0) + 0.45(0) = 0 $$\nThe right-hand side (RHS) of the cut is $f_0 = 0.37462$.\nThe violation is therefore:\n$$ \\text{Violation} = \\text{RHS} - \\text{LHS} = 0.37462 - 0 = 0.37462 $$\nThe current LP solution violates the cut because $0 \\ge 0.37462$ is false. The amount of violation is $0.37462$.\nRounding the result to four significant figures gives $0.3746$.", "answer": "$$\\boxed{0.3746}$$", "id": "3104181"}, {"introduction": "After learning how to generate a cut, a natural question arises: why not just branch on the fractional variable? This practice directly compares the two fundamental operations of the Branch and Cut method by exploring the concept of a split disjunction. You will derive a \"split cut\" from the simple fact that an integer variable $x_k$ must satisfy $x_k \\le 0 \\vee x_k \\ge 1$ and measure how it improves the objective bound, revealing the deep connection between cutting and branching [@problem_id:3104204].", "problem": "Consider a Mixed-Integer Linear Programming (MILP) instance consisting of a single integer variable $x_k \\in \\{0,1\\}$, a vector of continuous nonnegative variables $s \\in \\mathbb{R}^n_{\\ge 0}$, and the linear equation\n$$\nx_k = f + \\sum_{j=1}^n r_j s_j,\n$$\nwith the auxiliary bound constraints $0 \\le x_k \\le 1$, and the objective function to minimize\n$$\n\\min \\sum_{j=1}^n s_j.\n$$\nAssume a fractional root solution $\\hat{x}$ equals $f$ with $s = 0$, and $f \\in (0,1)$. You will derive a split cut from the disjunction $x_k \\le 0 \\vee x_k \\ge 1$ and then quantify its effect relative to branching on $x_k$.\n\nStart from the foundational base of the branch-and-cut method: the linear programming relaxation of a MILP, valid disjunctions defining split sets for integer variables, and the intersection-cut principle in convex analysis. Specifically, view the equation $x_k = f + \\sum_{j=1}^n r_j s_j$ as a parameterization of the feasible set in the continuous variables $s$, where each coordinate direction $e_j$ (the ray $s = \\lambda e_j$ for $\\lambda \\ge 0$) moves $x_k$ linearly according to the sign of $r_j$. Use the disjunction $x_k \\le 0 \\vee x_k \\ge 1$ to construct a valid inequality that separates the fractional point $(x_k = f, s = 0)$ while remaining valid for all points that satisfy either disjunct together with $s \\ge 0$. No shortcut formulas should be assumed; derive the inequality from first principles by considering the minimum step along each ray needed to reach either boundary $x_k = 0$ or $x_k = 1$, and then aggregating these distances into a single linear inequality in $s$.\n\nAfter deriving the split cut, measure its effect in terms of the optimal objective value at:\n- the root linear programming relaxation (without branching or cuts),\n- the best bound obtained by branching on $x_k$ into the two child subproblems $x_k = 0$ and $x_k = 1$ (solving each child linear program to optimality),\n- the root linear programming relaxation augmented with the derived split cut.\n\nFor each child subproblem, solve\n$$\n\\min \\sum_{j=1}^n s_j \\quad \\text{subject to} \\quad \\sum_{j=1}^n r_j s_j = \\text{rhs}, \\quad s \\ge 0,\n$$\nwhere $\\text{rhs} = -f$ for the branch $x_k = 0$ and $\\text{rhs} = 1 - f$ for the branch $x_k = 1$. For scientific realism, ensure to treat branch infeasibility correctly when the sign pattern of $r$ does not permit a nonnegative solution for the corresponding $\\text{rhs}$.\n\nYour program must compute, for each test case, a list of three floating-point numbers:\n1. the optimal objective value at the root linear programming relaxation,\n2. the best bound from branching on $x_k$ (the minimum of the two child optimal values, treating infeasible children as having value $+\\infty$),\n3. the optimal objective value at the root linear programming relaxation augmented with the derived split cut.\n\nTest Suite:\n- Case $1$: $f = 0.7$, $r = [0.6, -0.4]$.\n- Case $2$: $f = 0.25$, $r = [0.5, -0.1, 0.0]$.\n- Case $3$: $f = 0.6$, $r = [0.2, -0.05]$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of three floats:\n$$\n\\text{output} = \\big[ [\\text{root},\\ \\text{branch},\\ \\text{cut}],\\ [\\text{root},\\ \\text{branch},\\ \\text{cut}],\\ [\\text{root},\\ \\text{branch},\\ \\text{cut}] \\big].\n$$\nNo physical units are involved. Express all numerical answers as decimal floats.", "solution": "The problem requires a three-part analysis of a simple MILP structure to compare the effects of the root LP relaxation, branching, and adding a split cut.\n\n#### 1. Optimal Objective at the Root LP Relaxation\nThe LP relaxation is given by:\n$$ \\min \\quad z = \\sum_{j=1}^n s_j $$\n$$ \\text{s.t.} \\quad x_k - \\sum_{j=1}^n r_j s_j = f, \\quad s_j \\ge 0, \\quad 0 \\le x_k \\le 1 $$\nThe problem states that a solution is $(\\hat{x}_k, \\hat{s}) = (f, 0)$. This gives an objective value of $z = \\sum 0 = 0$. Since all objective coefficients are 1 and variables $s_j$ are non-negative, the objective cannot be less than 0. Thus, the optimal objective value of the root LP relaxation is $0.0$.\n\n#### 2. Derivation and Effect of the Split Cut\nThe fractional value $\\hat{x}_k = f$ violates the integrality constraint. We derive a split cut from the disjunction $x_k \\le 0 \\vee x_k \\ge 1$. Following the intersection cut procedure, we find the intersection points of the rays $s = \\lambda e_j$ (where $s_j=\\lambda > 0$, other $s_i=0$) with the hyperplanes $x_k=0$ and $x_k=1$.\nFrom the equation $x_k = f + r_j \\lambda$, we find the intercepts:\n- To reach $x_k=1$: $\\lambda = (1-f)/r_j$ (possible if $r_j > 0$). Intercept $a_j = (1-f)/r_j$.\n- To reach $x_k=0$: $\\lambda = -f/r_j$ (possible if $r_j < 0$). Intercept $a_j = -f/r_j$.\n\nThe split cut is the hyperplane passing through these intercepts, formulated as $\\sum_{j} (s_j / a_j) \\ge 1$. Substituting the intercepts gives:\n$$ \\sum_{j: r_j > 0} \\frac{s_j}{(1-f)/r_j} + \\sum_{j: r_j < 0} \\frac{s_j}{-f/r_j} \\ge 1 $$\n$$ \\implies \\sum_{j: r_j > 0} \\frac{r_j}{1-f} s_j + \\sum_{j: r_j < 0} \\frac{-r_j}{f} s_j \\ge 1 $$\nTo find the new optimal objective, we solve the LP: $\\min \\sum s_j$ subject to this cut and $s \\ge 0$. The optimal value of this LP is $\\min_j(1/c_j)$ where $c_j$ are the coefficients in the cut. This gives:\n$$ z_{\\text{cut}}^* = \\min \\left( \\min_{j: r_j>0} \\left\\{\\frac{1-f}{r_j}\\right\\}, \\min_{j: r_j<0} \\left\\{\\frac{f}{-r_j}\\right\\} \\right) = \\min \\left( \\frac{1-f}{\\max_{j: r_j>0} \\{r_j\\}}, \\frac{f}{-\\min_{j: r_j<0} \\{r_j\\}} \\right) $$\n\n#### 3. Best Bound from Branching\nWe create two child LPs by fixing $x_k=0$ and $x_k=1$.\n- **Subproblem ($x_k=0$):** The constraint becomes $\\sum r_j s_j = -f$. To minimize $\\sum s_j$, we use the single most \"efficient\" variable $s_k$ corresponding to the most negative coefficient, $r_{\\min}^- = \\min_{j: r_j<0} \\{r_j\\}$. The solution is $s_k = -f/r_{\\min}^-$ and other $s_j=0$. The optimal objective is $z_0^* = -f/r_{\\min}^-$. If no $r_j < 0$, the branch is infeasible ($z_0^*=\\infty$).\n- **Subproblem ($x_k=1$):** The constraint becomes $\\sum r_j s_j = 1-f$. Similarly, we use the variable corresponding to the largest positive coefficient, $r_{\\max}^+ = \\max_{j: r_j>0} \\{r_j\\}$. The objective is $z_1^* = (1-f)/r_{\\max}^+$. If no $r_j > 0$, the branch is infeasible ($z_1^*=\\infty$).\n\nThe best bound from branching is $z_{\\text{branch}}^* = \\min(z_0^*, z_1^*)$.\n\nFor this problem, we observe that $z_{\\text{cut}}^* = z_{\\text{branch}}^*$. The bound from the split cut is identical to the bound from branching.\n\n#### Calculations for Test Cases\n- **Case 1:** $f=0.7, r=[0.6, -0.4]$. Root obj = $0.0$. Branch bound = $\\min(\\frac{1-0.7}{0.6}, \\frac{-0.7}{-0.4}) = \\min(0.5, 1.75) = 0.5$. Result: `[0.0, 0.5, 0.5]`.\n- **Case 2:** $f=0.25, r=[0.5, -0.1, 0.0]$. Root obj = $0.0$. Branch bound = $\\min(\\frac{1-0.25}{0.5}, \\frac{-0.25}{-0.1}) = \\min(1.5, 2.5) = 1.5$. Result: `[0.0, 1.5, 1.5]`.\n- **Case 3:** $f=0.6, r=[0.2, -0.05]$. Root obj = $0.0$. Branch bound = $\\min(\\frac{1-0.6}{0.2}, \\frac{-0.6}{-0.05}) = \\min(2.0, 12.0) = 2.0$. Result: `[0.0, 2.0, 2.0]`.", "answer": "[[0.0,0.5,0.5],[0.0,1.5,1.5],[0.0,2.0,2.0]]", "id": "3104204"}, {"introduction": "Finally, we scale up from analyzing a single node to observing the effect of cuts on the entire search process. This hands-on coding exercise demonstrates the practical impact of adding a valid inequality, in this case a minimal cover inequality, at the root of a search tree for the classic knapsack problem. By implementing and comparing a pure branch-and-bound solver against a branch-and-cut version, you will quantify the power of cutting planes to prune the search tree and accelerate the path to an optimal integer solution [@problem_id:3104203].", "problem": "Consider the binary knapsack problem defined by the objective to maximize $ \\sum_{i=1}^{n} v_i x_i $ subject to the capacity constraint $ \\sum_{i=1}^{n} w_i x_i \\le W $ and integrality constraints $ x \\in \\{0,1\\}^n $. The linear programming relaxation replaces $ x \\in \\{0,1\\}^n $ with $ 0 \\le x \\le \\mathbf{1} $, yielding a valid upper bound on the optimal value. A cover is any index set $ C \\subseteq \\{1,\\ldots,n\\} $ with $ \\sum_{i \\in C} w_i > W $. A minimal cover is a cover $ C $ such that for every $ j \\in C $ one has $ \\sum_{i \\in C \\setminus \\{j\\}} w_i \\le W $. For any minimal cover $ C $, the inequality $ \\sum_{i \\in C} x_i \\le |C| - 1 $ is valid and can be added as a cutting plane at the root in a branch-and-cut scheme.\n\nStarting from these core definitions, design a program that:\n- Implements a branch-and-bound search that uses the linear programming relaxation at each node to compute upper bounds and prunes nodes that cannot yield improvements in the objective.\n- Implements a branch-and-cut variant that adds a single minimal cover inequality at the root node (and maintains it throughout the search), and measures its effect on the number of processed nodes relative to branch-and-bound without cuts.\n- Uses a deterministic branching rule that selects a variable with fractional value in the relaxation, choosing the one with value closest to $ 0.5 $, branching on $ x_j = 1 $ first and $ x_j = 0 $ second.\n- Counts nodes as the number of nodes at which the linear programming relaxation is solved. A node that is detected as infeasible solely by fixed assignments without solving a relaxation should not be counted.\n\nYour program must:\n1. Construct a minimal cover $ C $ automatically from $ (w, W) $. One valid method is: select an initial cover by taking items in nonincreasing order of $ w_i $ until their sum exceeds $ W $; then repeatedly remove the item of smallest weight from $ C $ while $ \\sum_{i \\in C} w_i - \\min_{j \\in C} w_j > W $, ensuring minimality when $ \\sum_{i \\in C} w_i - \\min_{j \\in C} w_j \\le W $.\n2. Use the linear programming relaxation at each node to compute an upper bound via minimizing $ -\\sum_{i=1}^{n} v_i x_i $ subject to $ \\sum_{i=1}^{n} w_i x_i \\le W $, $ \\sum_{i \\in C} x_i \\le |C| - 1 $ if a cover exists, and $ 0 \\le x \\le \\mathbf{1} $ plus any variable fixings from branching.\n3. Initialize the incumbent with a feasible solution built by a greedy heuristic that takes items in nonincreasing order of $ v_i / w_i $ until capacity is reached.\n\nTest Suite. Use the following three test cases that explore different behaviors:\n- Case A (nontrivial minimal cover present): $ n = 7 $, $ v = [16, 14, 13, 12, 10, 8, 6] $, $ w = [8, 7, 6, 6, 5, 4, 3] $, $ W = 15 $. Here a minimal cover exists (for example, selecting the heaviest items until exceeding capacity).\n- Case B (no cover exists): $ n = 6 $, $ v = [7, 9, 6, 5, 4, 8] $, $ w = [3, 4, 5, 2, 1, 4] $, $ W = 25 $. Since $ \\sum_{i=1}^{n} w_i < W $, there is no cover, and adding a cut should have no effect relative to branching only.\n- Case C (two-item minimal cover): $ n = 5 $, $ v = [12, 12, 9, 9, 8] $, $ w = [6, 6, 5, 5, 4] $, $ W = 10 $. A minimal cover of size two exists among the heaviest items, and its inequality $ x_{i} + x_{j} \\le 1 $ can tighten the relaxation.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list $ [N_{\\text{branch}}, N_{\\text{cut}}] $ with $ N_{\\text{branch}} $ equal to the number of processed nodes with branching only and $ N_{\\text{cut}} $ equal to the number processed with the minimal cover inequality added. For example, the printed string should look like $ [[N_1^{\\text{branch}},N_1^{\\text{cut}}],[N_2^{\\text{branch}},N_2^{\\text{cut}}],[N_3^{\\text{branch}},N_3^{\\text{cut}}]] $.", "solution": "The user requests the design of a program to compare the performance of a standard branch-and-bound algorithm with a branch-and-cut variant for the binary knapsack problem. The performance is measured by the number of nodes processed in the search tree. A node is counted if its corresponding linear programming ($LP$) relaxation is solved.\n\nThe problem is defined as maximizing the total value $Z = \\sum_{i=1}^{n} v_i x_i$ subject to a capacity constraint $\\sum_{i=1}^{n} w_i x_i \\le W$ and binary variable constraints $x_i \\in \\{0, 1\\}$ for all $i \\in \\{1, \\ldots, n\\}$. The variables $v_i$ and $w_i$ represent the value and weight of item $i$, respectively, and $W$ is the knapsack capacity.\n\nThe solution is architected around a depth-first branch-and-bound search framework. This framework is executed twice for each test case: once as a pure branch-and-bound algorithm and once as a branch-and-cut algorithm incorporating a specific cutting plane.\n\n**1. Initial Lower Bound (Incumbent Solution)**\n\nTo enable effective pruning, the search is initialized with a high-quality feasible solution, which provides an initial lower bound on the optimal objective value. This solution is constructed using a greedy heuristic. Items are sorted in nonincreasing order of their value-to-weight ratio, $v_i / w_i$. They are sequentially added to the knapsack if they do not violate the capacity constraint $W$. The total value of this greedy solution serves as the initial incumbent value, $Z_{best}$.\n\n**2. Cover Inequality Generation**\n\nFor the branch-and-cut variant, a single valid inequality, known as a cover inequality, is generated and added to the $LP$ relaxation at the root node. This inequality remains active throughout the search tree.\n\nA cover $C$ is a set of item indices such that their total weight exceeds the knapsack capacity: $\\sum_{i \\in C} w_i > W$. A minimal cover is a cover for which no proper subset is also a cover; that is, for any item $j \\in C$, $\\sum_{i \\in C \\setminus \\{j\\}} w_i \\le W$. For any minimal cover $C$, the inequality $\\sum_{i \\in C} x_i \\le |C| - 1$ is valid for the integer problem. This is because if all items in $C$ were selected (i.e., $x_i = 1$ for all $i \\in C$), their total weight would exceed $W$, violating the capacity constraint. Therefore, at most $|C| - 1$ items from a minimal cover $C$ can be in a feasible solution.\n\nThe specific procedure to generate one such minimal cover is as follows:\n- An initial cover is formed by selecting items in nonincreasing order of their weight $w_i$ until their cumulative weight just exceeds $W$.\n- This initial cover is then made minimal by repeatedly attempting to remove the item with the smallest weight. If removing this item leaves a set that is still a cover (i.e., its weight sum still exceeds $W$), the removal is made permanent, and the process repeats on the smaller set. The procedure terminates when the removal of the current lightest item would result in a set that is no longer a cover.\n\nIf no set of items has a total weight greater than $W$ (i.e., $\\sum_{i=1}^n w_i \\le W$), no cover exists, and the branch-and-cut algorithm becomes identical to the branch-and-bound algorithm.\n\n**3. Branch-and-Bound/Cut Engine**\n\nThe core of the algorithm is a recursive exploration of a binary search tree, implemented here using a stack for a depth-first search (DFS) traversal. Each node in the tree corresponds to a subproblem where a subset of variables are fixed to either $0$ or $1$.\n\nAt each node, the following steps are performed:\n1.  **Feasibility Pre-check**: Before solving any $LP$, a simple check is performed. If the sum of weights of items fixed to $1$ already exceeds the capacity $W$, the node is infeasible and is pruned. Such nodes are not counted.\n2.  **Node Processing**: If the node is potentially feasible, it is officially counted, and its $LP$ relaxation is solved. The $LP$ relaxation consists of the objective to maximize $\\sum v_i x_i$ subject to:\n    - The capacity constraint: $\\sum_{i=1}^{n} w_i x_i \\le W$.\n    - Box constraints: $0 \\le x_i \\le 1$.\n    - Variable fixings from branching, e.g., $x_j=0$ or $x_j=1$.\n    - (For branch-and-cut) The cover inequality: $\\sum_{i \\in C} x_i \\le |C| - 1$.\n    The `scipy.optimize.linprog` function is used for this purpose, configured to minimize the negative objective function, $-\\sum v_i x_i$.\n\n3.  **Pruning**: After solving the $LP$, its outcome determines the next action. Let the optimal value of the relaxation be $Z_{LP}$.\n    - **Pruning by Infeasibility**: If the $LP$ relaxation is infeasible, the subproblem contains no feasible solutions. The node is pruned.\n    - **Pruning by Bound**: If $Z_{LP} \\le Z_{best}$, no solution in this subtree can improve upon the best-known integer solution. The node is pruned.\n    - **Pruning by Integrality**: If the $LP$ solution vector $\\mathbf{x}^*$ is integer-valued (within a small tolerance), it is a feasible solution to the original knapsack problem. If its value, $\\sum v_i x_i^*$, is greater than $Z_{best}$, $Z_{best}$ is updated. The node is then pruned, as no further branching can yield a better solution in this path.\n\n4.  **Branching**: If the node is not pruned and the $LP$ solution $\\mathbf{x}^*$ is fractional, branching occurs.\n    - **Variable Selection**: The branching variable $x_j$ is chosen deterministically as the one with a fractional value closest to $0.5$.\n    - **Child Node Generation**: Two new nodes are created for the search stack: one corresponding to fixing $x_j=1$ and the other to $x_j=0$. To adhere to the requirement of exploring the $x_j=1$ branch first, the node for $x_j=0$ is pushed onto the stack, followed by the node for $x_j=1$.\n\nThe search terminates when the stack is empty, signifying that the entire feasible space has been implicitly enumerated. The final output for each test case is a pair of integers: the total node count for the pure branch-and-bound run and the total node count for the branch-and-cut run.", "answer": "[[15, 9],[1, 1],[9, 3]]", "id": "3104203"}]}