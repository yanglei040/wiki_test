{"hands_on_practices": [{"introduction": "Understanding trapdoor one-way functions begins with seeing how they are built from hard mathematical problems. This first exercise [@problem_id:1467639] presents a function based on the widely-used ElGamal encryption scheme, whose security is tied to the difficulty of the Discrete Logarithm Problem. By analyzing this function, you will gain hands-on experience in identifying the specific piece of secret information—the trapdoor—that makes inverting the function computationally easy for an authorized user, yet infeasible for anyone else.", "problem": "In the study of public-key cryptography, the concept of a trapdoor one-way function is fundamental. A function is considered **one-way** if it is easy to compute for any given input, but computationally infeasible to determine the input from a given output. A **trapdoor one-way function** is a special type of one-way function where the inversion becomes easy if, and only if, one possesses a specific piece of secret information known as the trapdoor.\n\nConsider a finite cyclic group $G$ of a large prime order $q$, with a known generator $g$. The group operation is denoted by $\\cdot$. Let $h$ be a public element of $G$, constructed as $h=g^x$ for a secret integer $x \\in \\{1, 2, \\ldots, q-1\\}$. You can assume that solving the Discrete Logarithm Problem (DLP) in $G$ — that is, finding $x$ given $g$ and $h$ — is computationally infeasible.\n\nNow, analyze the function $f: G \\times \\mathbb{Z}_q \\to G \\times G$ defined by:\n$f(m, r) = (g^r, m \\cdot h^r)$\nwhere $m \\in G$ is a message and $r \\in \\mathbb{Z}_q$ is a randomly chosen integer. The primary goal of an authorized recipient, who knows the secret, upon receiving an output $(c_1, c_2) = f(m, r)$, is to recover the original message $m$.\n\nWhich of the following statements most accurately describes the properties of the function $f(m, r)$ under the assumption that the DLP is hard?\n\nA. The function is a trapdoor one-way function, and the trapdoor is the secret exponent $x$.\n\nB. The function is a trapdoor one-way function, and the trapdoor is the random integer $r$.\n\nC. The function is a trapdoor one-way function, and the trapdoor is the message $m$.\n\nD. The function is a one-way function but does not possess a trapdoor.\n\nE. The function is not a one-way function because it can be easily inverted by any party.", "solution": "We work in a finite cyclic group $G$ of prime order $q$ with generator $g$. The public key is $h=g^{x}$ for secret $x \\in \\{1,2,\\ldots,q-1\\}$. The function is $f(m,r)=(c_{1},c_{2})=(g^{r},\\,m \\cdot h^{r})$, where $m \\in G$ and $r \\in \\mathbb{Z}_{q}$.\n\nFirst, show how an authorized recipient who knows $x$ recovers $m$ from $(c_{1},c_{2})$. Using the definition $c_{1}=g^{r}$ and the trapdoor $x$, compute\n$$\ns=c_{1}^{x}=(g^{r})^{x}=g^{rx}=h^{r}.\n$$\nThis uses standard exponentiation in $G$ and the relation $h=g^{x}$. Then invert $c_{2}=m \\cdot h^{r}$ by multiplying by $s^{-1}=(h^{r})^{-1}$:\n$$\nm=c_{2}\\cdot s^{-1}=m \\cdot h^{r} \\cdot (h^{r})^{-1}=m.\n$$\nThus, given $x$, recovering $m$ from $(c_{1},c_{2})$ is efficient, establishing the existence of an efficient inversion algorithm with the trapdoor $x$.\n\nNext, argue that without $x$ inversion is infeasible under the stated hardness assumption. From $(c_{1},c_{2})$, to obtain $m$ one needs $h^{r}$. There are two natural routes:\n1. Recover $r$ from $c_{1}=g^{r}$ and then compute $h^{r}$; but finding $r$ is exactly the Discrete Logarithm Problem in $G$, which is assumed hard.\n2. Compute $h^{r}$ directly from $(g^{x},g^{r})$ by evaluating $g^{xr}$; this is the Computational Diffie–Hellman problem. While the problem statement only assumes DLP hardness, any algorithm that inverts $f$ by outputting $m$ for arbitrary $(c_{1},c_{2})$ would, in particular, allow recovery of $m$ when $m$ is unknown to the adversary, which requires computing $h^{r}$ from $(g^{x},g^{r})$; absent the trapdoor $x$, this is believed infeasible.\n\nTherefore, under the DLP hardness assumption, $f$ is one-way for parties lacking $x$, while a party possessing $x$ can efficiently invert to recover $m$. The random $r$ is ephemeral and not a fixed secret enabling inversion across all outputs; the message $m$ itself is not a trapdoor; and the function is not easily invertible by arbitrary parties.\n\nConsequently, the correct characterization is that $f$ is a trapdoor one-way function with trapdoor $x$.", "answer": "$$\\boxed{A}$$", "id": "1467639"}, {"introduction": "In cryptography, we often build complex systems by combining simpler, secure components. This raises a critical question: if we combine two secure building blocks, is the resulting construction also secure? This problem [@problem_id:1467638] asks you to investigate this question by examining the direct product of two distinct trapdoor one-way permutation families. Tackling this will challenge you to work with formal security definitions and apply the powerful proof technique of reduction, a cornerstone of modern cryptographic analysis.", "problem": "In the field of cryptography, a family of trapdoor one-way permutations is a fundamental concept. It is formally defined by a tuple of three probabilistic polynomial-time (PPT) algorithms: $(\\text{Gen}, \\text{Eval}, \\text{Invert})$.\n\n1.  $\\text{Gen}(1^n)$: A key generation algorithm that, on input of a security parameter $n$, outputs a pair of keys, a public key $pk$ and a secret key (or trapdoor) $sk$.\n2.  $\\text{Eval}(pk, x)$: An evaluation algorithm that computes the function $f_{pk}(x)$. For any fixed $pk$, $f_{pk}$ is a permutation over a domain $D_{pk}$.\n3.  $\\text{Invert}(sk, y)$: An inversion algorithm that, using the trapdoor $sk$, computes the inverse $f_{pk}^{-1}(y)$.\n\nFor the tuple to be a secure family of trapdoor one-way permutations, it must satisfy two conditions:\n- **Correctness**: For any key pair $(pk, sk)$ produced by $\\text{Gen}(1^n)$ and any $x \\in D_{pk}$, it must be that $\\text{Invert}(sk, \\text{Eval}(pk, x)) = x$.\n- **Security**: For any PPT adversary $\\mathcal{A}$, the probability that $\\mathcal{A}(pk, \\text{Eval}(pk, x)) = x$ is negligible in the security parameter $n$. The probability is taken over the choice of $(pk, sk)$ from $\\text{Gen}(1^n)$, a randomly chosen $x$ from the domain $D_{pk}$, and the internal randomness of $\\mathcal{A}$.\n\nNow, consider two distinct, secure families of trapdoor one-way permutations, $\\mathcal{F}_1 = (\\text{Gen}_1, \\text{Eval}_1, \\text{Invert}_1)$ and $\\mathcal{F}_2 = (\\text{Gen}_2, \\text{Eval}_2, \\text{Invert}_2)$, operating on domains $D_1$ and $D_2$ respectively.\n\nWe construct a new family of functions, $\\mathcal{F}$, as a direct product of $\\mathcal{F}_1$ and $\\mathcal{F}_2$. The generation algorithm $\\text{Gen}_F(1^n)$ works by running $\\text{Gen}_1(1^n)$ to get $(pk_1, sk_1)$ and $\\text{Gen}_2(1^n)$ to get $(pk_2, sk_2)$, then outputting the combined keys $pk_F = (pk_1, pk_2)$ and $sk_F = (sk_1, sk_2)$. The function $F_{pk_F}$ is defined on the domain $D_1 \\times D_2$ as:\n$$F_{pk_F}(x, y) = (\\text{Eval}_1(pk_1, x), \\text{Eval}_2(pk_2, y))$$\n\nIs the new family $\\mathcal{F}$ necessarily a secure family of trapdoor one-way permutations?\n\nA. Yes. The security of the combined function is formally reducible to the security of its components. If the combined function could be inverted, at least one of the component functions could be inverted, which contradicts the initial assumption.\n\nB. No. The security definition for a family only requires that it is hard to invert for most public keys. It is possible that for the specific public key $pk_2$ paired with $pk_1$, $f_{pk_2}$ is easy to invert, and this happens with non-negligible probability.\n\nC. No. While the individual public keys $pk_1$ and $pk_2$ do not reveal their respective trapdoors, the combination of information in $(pk_1, pk_2)$ might inadvertently reveal the trapdoor for either $f_{pk_1}$ or $f_{pk_2}$.\n\nD. No. The function $F_{pk_F}$ constructed this way is not guaranteed to be a permutation on the product domain $D_1 \\times D_2$.", "solution": "We first verify correctness and that the function on the product domain is a permutation. For any $(pk_{1},sk_{1}) \\leftarrow \\text{Gen}_{1}(1^{n})$ and $(pk_{2},sk_{2}) \\leftarrow \\text{Gen}_{2}(1^{n})$, define $pk_{F}=(pk_{1},pk_{2})$, $sk_{F}=(sk_{1},sk_{2})$, and\n$$\nF_{pk_{F}}(x,y) = \\big(\\text{Eval}_{1}(pk_{1},x),\\ \\text{Eval}_{2}(pk_{2},y)\\big).\n$$\nSince for each fixed $pk_{i}$ the map $f^{(i)}_{pk_{i}}=\\text{Eval}_{i}(pk_{i},\\cdot)$ is a permutation on $D_{i}$, the product map $F_{pk_{F}}$ is a permutation on $D_{1}\\times D_{2}$ with inverse\n$$\nF_{pk_{F}}^{-1}(u,v) = \\big(\\text{Invert}_{1}(sk_{1},u),\\ \\text{Invert}_{2}(sk_{2},v)\\big).\n$$\nCorrectness follows immediately: for any $(x,y)\\in D_{1}\\times D_{2}$,\n$$\n\\text{Invert}_{1}(sk_{1},\\text{Eval}_{1}(pk_{1},x))=x,\\quad \\text{Invert}_{2}(sk_{2},\\text{Eval}_{2}(pk_{2},y))=y,\n$$\nhence\n$$\n\\text{Invert}_{F}(sk_{F},F_{pk_{F}}(x,y))=(x,y).\n$$\n\nWe now prove security by reduction. Assume, for contradiction, that there exists a PPT adversary $\\mathcal{A}_{F}$ and a polynomial $p(\\cdot)$ such that for infinitely many $n$,\n$$\n\\Pr\\big[\\mathcal{A}_{F}(pk_{F},F_{pk_{F}}(x,y))=(x,y)\\big]\\ \\geq\\ \\frac{1}{p(n)},\n$$\nwhere the probability is over $(pk_{1},sk_{1})\\leftarrow \\text{Gen}_{1}(1^{n})$, $(pk_{2},sk_{2})\\leftarrow \\text{Gen}_{2}(1^{n})$, $(x,y)\\leftarrow D_{1}\\times D_{2}$ uniformly (or according to the domains’ prescribed distributions), and the internal randomness of $\\mathcal{A}_{F}$.\n\nWe construct a PPT inverter $\\mathcal{B}_{2}$ for the second family $\\mathcal{F}_{2}$ that contradicts its security. On input $(pk_{2},u)$, where $u=\\text{Eval}_{2}(pk_{2},y)$ for $y\\leftarrow D_{2}$ uniformly, $\\mathcal{B}_{2}$ proceeds as follows:\n1. Sample $(pk_{1},sk_{1})\\leftarrow \\text{Gen}_{1}(1^{n})$.\n2. Sample $x\\leftarrow D_{1}$ uniformly and compute $v=\\text{Eval}_{1}(pk_{1},x)$.\n3. Run $\\mathcal{A}_{F}$ on input $(pk_{F},(v,u))$ with $pk_{F}=(pk_{1},pk_{2})$.\n4. If $\\mathcal{A}_{F}$ outputs $(x',y')$, output $y'$; else output failure.\n\nBy construction, the joint distribution of $(pk_{1},pk_{2},x,y)$ that $\\mathcal{B}_{2}$ induces for $\\mathcal{A}_{F}$ is identical to the one in which $\\mathcal{A}_{F}$ is assumed to succeed with probability at least $1/p(n)$: $pk_{1}$ and $pk_{2}$ are generated independently by their respective generators, $x$ is uniform in $D_{1}$, and $u=\\text{Eval}_{2}(pk_{2},y)$ for uniform $y\\in D_{2}$. Hence,\n$$\n\\Pr\\big[\\mathcal{B}_{2}(pk_{2},\\text{Eval}_{2}(pk_{2},y))=y\\big]\n=\\Pr\\big[\\mathcal{A}_{F}(pk_{F},(v,u))=(x,y)\\big]\n\\geq \\frac{1}{p(n)}.\n$$\nTherefore, $\\mathcal{B}_{2}$ inverts $\\text{Eval}_{2}$ on a random input with non-negligible probability, contradicting the assumed security of $\\mathcal{F}_{2}$. An analogous reduction can be written to contradict the security of $\\mathcal{F}_{1}$ as well.\n\nThis proves that no PPT adversary can invert $F_{pk_{F}}$ on a random input with non-negligible probability, so the direct product family is secure.\n\nWe now assess the options:\n- Option A is correct: the above reduction shows security of the product reduces to security of a component.\n- Option B is incorrect: if a non-negligible fraction of $pk_{2}$ yield easy inversion, that already violates the given security definition for $\\mathcal{F}_{2}$ when averaging over keys.\n- Option C is incorrect: $(pk_{1},pk_{2})$ are independently sampled; any adversary using $(pk_{1},pk_{2})$ can be transformed into one using only $pk_{2}$ by sampling $pk_{1}$, preserving the success probability due to independence.\n- Option D is incorrect: the product of permutations is a permutation on the Cartesian product.\n\nTherefore, the new family $\\mathcal{F}$ is necessarily a secure family of trapdoor one-way permutations, and the correct choice is A.", "answer": "$$\\boxed{A}$$", "id": "1467638"}, {"introduction": "The \"hardness\" of inverting a one-way function is a concept rooted in computational complexity theory. This final practice problem [@problem_id:1467625] builds a bridge between cryptography and the theory of NP-completeness by exploring a powerful thought experiment. By providing an adversary with an oracle for the Boolean Satisfiability Problem (SAT), you can determine precisely how to break a trapdoor function, reinforcing the fundamental connection between cryptographic security and the limits of efficient computation.", "problem": "A cryptographer is analyzing a newly proposed public-key cryptographic scheme. The security of the scheme relies on a family of trapdoor one-way permutations. This family is defined by a generation algorithm, `Gen`, which on input of a security parameter $n$, outputs a pair of keys $(pk, sk)$. The public key $pk$ defines a permutation $f_{pk}: \\{0,1\\}^{n} \\to \\{0,1\\}^{n}$, while the secret key $sk$ is the trapdoor that allows for efficient inversion of $f_{pk}$.\n\nThe public key $pk$ contains a complete description of a Boolean circuit, $C_{pk}$, which computes the function $f_{pk}$. The size of the circuit, denoted $s(n)$, is defined as the total number of logic gates (e.g., AND, OR, NOT) it contains.\n\nAn adversary intercepts a value $y \\in \\{0,1\\}^{n}$ and has access to the public key $pk$, but not the secret key $sk$. The adversary's goal is to find the unique preimage $x \\in \\{0,1\\}^{n}$ such that $f_{pk}(x) = y$.\n\nThe adversary gains access to a powerful computational oracle, `O_SAT`. This oracle solves the Boolean Satisfiability Problem (SAT). When given a Boolean formula expressed in variables $v_1, v_2, \\ldots$, the oracle returns `TRUE` if there exists an assignment of `TRUE`/`FALSE` values to the variables that makes the entire formula `TRUE`, and `FALSE` otherwise. Crucially, if the formula is satisfiable, the oracle also provides one such satisfying assignment for all variables.\n\nTo find the preimage $x$, the adversary plans to construct a single Boolean formula, $\\Phi$, and query the `O_SAT` oracle just once. The variables of $\\Phi$ will represent the bits of the unknown input $x$ and the logical values on the internal wires of the circuit $C_{pk}$. What is the minimum total number of Boolean variables required for this formula $\\Phi$, expressed as a function of $n$ and $s(n)$?", "solution": "We want a single SAT instance that captures the constraint that $C_{pk}$, of size $s(n)$, maps an unknown input $x \\in \\{0,1\\}^{n}$ to the given output $y \\in \\{0,1\\}^{n}$. The variables must encode:\n- the $n$ unknown input bits of $x$, and\n- the logical values carried by the internal wires of $C_{pk}$.\n\nUse a standard circuit-to-SAT (Tseitin-style) encoding:\n1) Introduce $n$ variables $x_{1},\\dots,x_{n}$ for the primary inputs.\n2) For each of the $s(n)$ gates $g_{1},\\dots,g_{s(n)}$ in $C_{pk}$, introduce one variable $z_{j}$ representing the output wire (logical value) of gate $g_{j}$. Enforce the functionality of each gate by clauses that relate $z_{j}$ to the gate’s input literals. This introduces no additional variables beyond the single output variable per gate.\n3) For each circuit output bit, constrain the corresponding wire variable to equal the known bit of $y$. This is done with unit clauses (e.g., $z_{o(i)}$ or $\\lnot z_{o(i)}$), and therefore uses no new variables.\n\nThus, the total number of Boolean variables in the formula is exactly the number of primary input variables plus one variable for each gate output:\n$$\nn + s(n).\n$$\n\nMinimality: By the problem’s stipulation, variables of $\\Phi$ “represent the bits of the unknown input $x$ and the logical values on the internal wires of $C_{pk}$.” There are $n$ input bits and exactly $s(n)$ distinct internal gate-output signals whose logical values must be represented, so at least $n + s(n)$ variables are necessary. Moreover, outputs equal to $y$ can be enforced by unit clauses without creating additional variables. Therefore the minimum total number of variables required is $n + s(n)$.", "answer": "$$\\boxed{n+s(n)}$$", "id": "1467625"}]}