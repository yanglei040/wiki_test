{"hands_on_practices": [{"introduction": "Communication complexity often reveals that we don't need to know everything about our partner's input, just enough to solve the task. This first exercise demonstrates this principle beautifully by reducing a problem on long bitstrings to a much simpler one involving only their counts [@problem_id:1421146]. By analyzing this scenario, you'll see how the complexity is determined not by the size of the raw data, but by the size of the domain of the essential properties being compared.", "problem": "Two distributed sensors, let's call them Alice and Bob, are monitoring a certain environmental parameter. Over a one-hour period, each sensor takes $n=1000$ independent binary measurements, resulting in an $n$-bit string for each sensor. Let $x$ be the string held by Alice and $y$ be the string held by Bob. A '1' in a measurement signifies an event of interest, and a '0' signifies no event.\n\nTo ensure their counting mechanisms are synchronized, they need to determine if they have detected the same total number of events. They want to compute the function $f(x, y)$, which is defined to be $1$ if the number of '1's in string $x$ is equal to the number of '1's in string $y$, and $0$ otherwise.\n\nAlice and Bob can communicate by exchanging bits over a channel. A deterministic protocol is a predefined set of rules that they follow to exchange messages. A protocol is considered to have computed the function for a given input pair $(x, y)$ once at least one of the parties knows the correct value of $f(x,y)$. The cost of a protocol for a specific pair of inputs $(x, y)$ is the total number of bits exchanged. The deterministic communication complexity of the function $f$ is the minimum possible cost for the worst-case input pair $(x, y)$, achieved by the most efficient protocol.\n\nWhat is the exact deterministic communication complexity for this synchronization-check function $f$ with $n=1000$? Provide your answer as an integer.", "solution": "Let $n$ be the string length and define the Hamming weights $a=|x|$ and $b=|y|$. Then $a,b \\in \\{0,1,\\dots,n\\}$, so there are $m=n+1$ possible values for each. The function is\n$$\nf(x,y)=1 \\;\\;\\Longleftrightarrow\\;\\; a=b.\n$$\nThus the problem reduces to computing equality on an $m$-element domain.\n\nUpper bound: Alice can compute $a$ locally and send its binary encoding to Bob using\n$$\nL=\\lceil \\log_{2} m \\rceil=\\lceil \\log_{2} (n+1) \\rceil\n$$\nbits, which suffices to uniquely identify one of $m$ possibilities. Bob computes $b$ locally and outputs $1$ if and only if the received value equals $b$. Hence there is a deterministic protocol with worst-case cost $L=\\lceil \\log_{2} (n+1) \\rceil$ bits.\n\nLower bound: Consider the set\n$$\nS=\\{(i,i): i\\in\\{0,1,\\dots,n\\}\\},\n$$\nwhich has size $|S|=m=n+1$. For any distinct $(i,i),(j,j)\\in S$ with $i\\neq j$, we have $f(i,i)=1$ and $f(i,j)=f(j,i)=0$, so $S$ is a $1$-fooling set. By the fooling set lower bound, the deterministic communication complexity $D(f)$ satisfies\n$$\nD(f)\\geq \\log_{2} |S|=\\log_{2} (n+1).\n$$\nSince $D(f)$ is an integer, this implies\n$$\nD(f)\\geq \\lceil \\log_{2} (n+1) \\rceil.\n$$\nCombining the upper and lower bounds yields the exact value\n$$\nD(f)=\\lceil \\log_{2} (n+1) \\rceil.\n$$\nFor $n=1000$, we have $m=1001$ and $2^{9}=512<1001\\leq 1024=2^{10}$, hence\n$$\nD(f)=\\lceil \\log_{2} 1001 \\rceil=10.\n$$", "answer": "$$\\boxed{10}$$", "id": "1421146"}, {"introduction": "Proving that a protocol is optimal requires showing that no better one exists, a central challenge in complexity theory. This is where lower-bound techniques like the \"fooling set\" method become indispensable. This problem provides a hands-on opportunity to construct a fooling set for a graph-based problem, forcing you to reason carefully about the function's structure to prove a tight communication bound [@problem_id:1421116].", "problem": "Two parties, Alice and Bob, are tasked with a computational problem related to a network structure. The network is a cycle graph with 10 vertices, labeled consecutively as 0, 1, 2, ..., 9. In this graph, any vertex $i$ is connected by an edge only to vertex $(i-1) \\pmod{10}$ and vertex $(i+1) \\pmod{10}$.\n\nAlice is privately given a vertex label $x \\in \\{0, 1, ..., 9\\}$, and Bob is privately given a vertex label $y \\in \\{0, 1, ..., 9\\}$. Alice does not know Bob's vertex, and Bob does not know Alice's vertex. Their goal is to determine if their vertices are adjacent in the graph. They can communicate by sending bits to each other over a channel, following a pre-arranged protocol.\n\nWhat is the absolute minimum number of bits that must be exchanged between them in the worst-case input scenario to guarantee that Alice learns whether her vertex is adjacent to Bob's?\n\nA. 3\n\nB. 4\n\nC. 5\n\nD. 10", "solution": "Let the set of vertices be $V = \\{0, 1, \\dots, 9\\}$. Alice's input is $x \\in V$ and Bob's input is $y \\in V$. They want to compute the function $ADJ(x, y)$, where $ADJ(x, y) = 1$ if vertices $x$ and $y$ are adjacent, and $ADJ(x, y) = 0$ otherwise. According to the problem description, adjacency in the 10-vertex cycle graph means $y = (x+1) \\pmod{10}$ or $y = (x-1) \\pmod{10}$. The final result must be known to Alice.\n\nFirst, we establish an upper bound on the number of bits required. An upper bound can be found by constructing a valid communication protocol.\n\nConsider the following protocol:\n1. Bob sends his input vertex, $y$, to Alice.\n2. Alice receives $y$. Since she knows her own input, $x$, she now has both inputs.\n3. Alice computes $ADJ(x, y)$ by checking if $y$ is equal to $(x+1) \\pmod{10}$ or $(x-1) \\pmod{10}$. Since she now knows the result, the protocol is complete.\n\nLet's analyze the number of bits required for this protocol. Bob's input $y$ can be any of the 10 values in $\\{0, 1, \\dots, 9\\}$. To encode one of 10 possibilities, a minimum of $\\lceil \\log_2(10) \\rceil$ bits are required.\n$\\log_2(8) = 3$ and $\\log_2(16) = 4$, so $\\log_2(10)$ is between 3 and 4. Thus, $\\lceil \\log_2(10) \\rceil = 4$.\nBob can send a 4-bit binary representation of his number $y$ to Alice. This protocol requires a total of 4 bits of communication. This establishes an upper bound: the minimum number of bits required is at most 4.\n\nNext, we establish a lower bound on the number of bits. To show that 4 bits is the minimum, we must prove that no protocol with 3 or fewer bits can solve the problem. We will use a \"fooling set\" argument. Any deterministic protocol with $k$ bits of communication can have at most $2^k$ different communication transcripts (the sequence of messages exchanged). If two different input pairs $(x_1, y_1)$ and $(x_2, y_2)$ produce the same communication transcript, the protocol cannot distinguish between them. This implies that the \"crossed\" pairs $(x_1, y_2)$ and $(x_2, y_1)$ must also produce that same transcript. For a correct protocol, all four of these input pairs must result in the same output value (this is known as a monochromatic rectangle). If we can find a set of $M$ input pairs, all of which must have different communication transcripts in any valid protocol, then we need at least $M$ different transcripts. This implies $2^k \\ge M$, or $k \\ge \\lceil \\log_2(M) \\rceil$.\n\nLet's construct such a set of pairs. Consider the set $S$ of 10 input pairs where the vertices are adjacent:\n$S = \\{ (0,1), (1,2), (2,3), (3,4), (4,5), (5,6), (6,7), (7,8), (8,9), (9,0) \\}$.\nFor every pair $(x,y) \\in S$, the function value is $ADJ(x,y) = 1$.\n\nLet's take any two distinct pairs from $S$: $(x_1, y_1) = (i, (i+1)\\pmod{10})$ and $(x_2, y_2) = (j, (j+1)\\pmod{10})$, where $i \\neq j$.\nSuppose, for the sake of contradiction, that these two pairs could produce the same communication transcript. This would imply that the crossed pairs $(x_1, y_2) = (i, (j+1)\\pmod{10})$ and $(x_2, y_1) = (j, (i+1)\\pmod{10})$ must also have the value $ADJ=1$.\nLet's check this condition.\n$ADJ(i, (j+1)\\pmod{10}) = 1$ implies $(j+1) \\equiv i \\pm 1 \\pmod{10}$.\nThis gives two possibilities:\n1a) $j+1 \\equiv i+1 \\pmod{10} \\implies j \\equiv i \\pmod{10}$. This is not possible as we chose distinct pairs, $i \\ne j$.\n1b) $j+1 \\equiv i-1 \\pmod{10} \\implies j \\equiv i-2 \\pmod{10}$.\n\n$ADJ(j, (i+1)\\pmod{10}) = 1$ implies $(i+1) \\equiv j \\pm 1 \\pmod{10}$.\nThis gives two possibilities:\n2a) $i+1 \\equiv j+1 \\pmod{10} \\implies i \\equiv j \\pmod{10}$. Again, not possible.\n2b) $i+1 \\equiv j-1 \\pmod{10} \\implies i \\equiv j-2 \\pmod{10}$.\n\nSo, for both crossed pairs to have an output of 1, we must satisfy both $j \\equiv i-2 \\pmod{10}$ and $i \\equiv j-2 \\pmod{10}$.\nSubstituting the first congruence into the second gives:\n$i \\equiv (i-2) - 2 \\pmod{10}$\n$i \\equiv i-4 \\pmod{10}$\n$0 \\equiv -4 \\pmod{10}$, which implies $4 \\equiv 0 \\pmod{10}$.\nThis is false, since 10 is not a divisor of 4.\n\nThis contradiction shows that for any two distinct pairs from our set $S$, it is impossible for them to be part of the same monochromatic rectangle with value 1. Therefore, any correct protocol must produce a unique communication transcript for each of the 10 pairs in $S$.\nTo have at least 10 different transcripts, the number of bits exchanged, $k$, must satisfy $2^k \\ge 10$.\nThe smallest integer $k$ that satisfies this inequality is $k=4$, since $2^3=8 < 10$ and $2^4=16 \\ge 10$.\nThis establishes a lower bound: the minimum number of bits is at least 4.\n\nSince we have found an upper bound of 4 bits and a lower bound of 4 bits, the minimum number of bits required is exactly 4.\nComparing this with the given options:\nA. 3 - Incorrect, less than the lower bound.\nB. 4 - Correct.\nC. 5 - Incorrect, this is a valid number of bits for a simple protocol, but not the minimum.\nD. 10 - Incorrect.\n\nThe minimum number of bits is 4.", "answer": "$$\\boxed{B}$$", "id": "1421116"}, {"introduction": "Real-world distributed systems often involve more than two communicating parties. This practice extends our thinking to a multi-party setting, a common scenario in network protocols and sensor networks. You will use a fundamental information-theoretic argument to determine the minimum communication required, highlighting how information must physically flow from those who have it to those who need it [@problem_id:1421147].", "problem": "Four distributed seismic sensors, which we will label A, B, C, and D, are part of an earthquake early-warning system. After a potential seismic event, each sensor $i \\in \\{A, B, C, D\\}$ records a single bit, $b_i$, where $b_i=1$ indicates a high risk of soil liquefaction at its location and $b_i=0$ indicates low risk.\n\nA designated master sensor, sensor A, is tasked with computing the overall system risk status, $R$. The system risk status is defined by the parity of the individual risks. Specifically, the value to be computed is $R = b_A \\oplus b_B \\oplus b_C \\oplus b_D$, where $\\oplus$ denotes the exclusive OR (XOR) operation.\n\nThe sensors can exchange messages with each other over a communication network. The goal is for the master sensor, A, to determine the final value of $R$. The other sensors (B, C, and D) do not need to know the final value of $R$.\n\nWhat is the minimum total number of bits that must be exchanged among the sensors, in the worst-case scenario, to guarantee that sensor A can compute the correct overall system risk status $R$?", "solution": "We formalize the goal and the model. Each sensor $i \\in \\{A,B,C,D\\}$ holds one bit $b_{i} \\in \\{0,1\\}$. The master sensor $A$ must determine\n$$\nR \\;=\\; b_{A} \\oplus b_{B} \\oplus b_{C} \\oplus b_{D},\n$$\nwith zero error in the worst case. Communication cost equals the total number of bits exchanged over the network among all sensors. Messages are binary, and each transmitted bit can depend only on the sender’s local input and any messages the sender has previously received.\n\nWe prove a matching lower bound and upper bound.\n\nLower bound (at least three bits are necessary):\n1. Suppose, for contradiction, that the total number of exchanged bits is at most $2$. Then there are at most two transmission events overall.\n2. Consider the three remote sensors $\\{B,C,D\\}$. If any one of them, say $D$, does not transmit any bit during the protocol, then no information about $b_{D}$ can be conveyed to any other sensor, because messages can only carry information from senders to receivers. In particular, sensor $A$’s view at the end of the protocol (its own bit $b_{A}$ plus any messages it received) is independent of $b_{D}$.\n3. However, $R$ depends on $b_{D}$ via $R=b_{A}\\oplus b_{B}\\oplus b_{C}\\oplus b_{D}$. For fixed $(b_{A},b_{B},b_{C})$, flipping $b_{D}$ flips $R$. Therefore, if $A$’s view is independent of $b_{D}$, $A$ cannot always output the correct $R$ with zero error, a contradiction.\n4. Hence, in any correct protocol, each of $B$, $C$, and $D$ must influence the transcript that $A$ uses to decide $R$. Since the only way for a sensor’s private bit to influence others is by transmitting at least one bit, each of $B$, $C$, and $D$ must transmit at least one bit in the worst case.\n5. Therefore, the total number of bits exchanged is at least $3$.\n\nAchievability (three bits suffice):\nA simple protocol that uses exactly $3$ bits and lets $A$ compute $R$ is:\n- Sensor $B$ sends $b_{B}$ to $A$ (one bit).\n- Sensor $C$ sends $b_{C}$ to $A$ (one bit).\n- Sensor $D$ sends $b_{D}$ to $A$ (one bit).\nThen $A$ computes\n$$\nR \\;=\\; b_{A} \\oplus b_{B} \\oplus b_{C} \\oplus b_{D}.\n$$\nThis uses exactly $3$ bits total and achieves zero error in all cases.\n\nBy the lower bound and this explicit protocol, the minimum total number of bits required in the worst-case scenario is $3$.", "answer": "$$\\boxed{3}$$", "id": "1421147"}]}