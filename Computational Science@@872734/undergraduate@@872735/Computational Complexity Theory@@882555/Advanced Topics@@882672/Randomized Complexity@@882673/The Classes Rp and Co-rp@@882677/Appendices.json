{"hands_on_practices": [{"introduction": "A key way to understand the structure of a complexity class is to see if it's \"closed\" under certain operations. For instance, if you combine two problems from a class, does the resulting problem stay within that same class? This exercise [@problem_id:1455470] invites you to explore this idea by examining whether the class RP is closed under the union operation, a fundamental task in combining diagnostic tests or language recognizers.", "problem": "In the field of computational complexity theory, the class RP, which stands for Randomized Polynomial Time, characterizes decision problems solvable by a probabilistic Turing machine with one-sided error. A language $L$ is in RP if there exists a probabilistic, polynomial-time Turing machine $M$ such that for any input string $x$:\n1. If $x$ is in the language $L$, then the probability that $M$ outputs 1 (accepts) is at least $1/2$. ($x \\in L \\implies P(M(x) = 1) \\ge 1/2$)\n2. If $x$ is not in the language $L$, then the probability that $M$ outputs 1 (accepts) is exactly 0. ($x \\notin L \\implies P(M(x) = 1) = 0$)\n\nConsider a company that designs microchips. They have developed two separate probabilistic testing algorithms, $A_1$ and $A_2$, to detect different types of manufacturing flaws. Let $L_1$ be the set of all chips with a \"type-1\" flaw, and $L_2$ be the set of all chips with a \"type-2\" flaw. Both testing algorithms correspond to RP machines, meaning the languages $L_1$ and $L_2$ are both in the complexity class RP.\n\nA chip is considered \"globally defective\" if it has a type-1 flaw, or a type-2 flaw, or both. Let $L_{union}$ be the language of all globally defective chips, so $L_{union} = L_1 \\cup L_2$.\n\nTo create a unified test, an engineer proposes a new algorithm, $A_{union}$. On receiving a chip $x$ for testing, $A_{union}$ operates as follows:\n- First, run the algorithm $A_1$ on $x$.\n- If $A_1$ outputs 1, then $A_{union}$ immediately outputs 1 and halts.\n- If $A_1$ outputs 0, then $A_{union}$ proceeds to run algorithm $A_2$ on $x$ and outputs the result of $A_2$.\n\nBased on this construction, which of the following statements about the language $L_{union}$ is always true?\n\nA. $L_{union}$ is guaranteed to be in RP.\n\nB. $L_{union}$ is not guaranteed to be in RP, but it is guaranteed to be in co-RP.\n\nC. The classification of $L_{union}$ depends on the specific properties of $L_1$ and $L_2$; it is not guaranteed to be in RP.\n\nD. $L_{union}$ is guaranteed to be in P (Polynomial Time).\n\nE. $L_{union}$ is guaranteed to be in BPP (Bounded-error Probabilistic Polynomial Time), but not necessarily in RP.", "solution": "We are given two languages $L_1, L_2$ in RP. By definition, there exist probabilistic polynomial-time algorithms $A_1, A_2$ such that for all inputs $x$:\n- If $x \\in L_i$, then $\\Pr(A_i(x)=1) \\ge \\frac{1}{2}$.\n- If $x \\notin L_i$, then $\\Pr(A_i(x)=1)=0$.\nThe proposed unified algorithm $A_{\\text{union}}$ runs $A_1$ first and accepts immediately if $A_1$ accepts; otherwise it runs $A_2$ and outputs its result. We analyze the running time and correctness relative to the RP definition.\n\nPolynomial time: Let the running times be $T_1(n)$ and $T_2(n)$ for inputs of length $n$, both polynomial. Then the running time $T_{\\text{union}}(n)$ satisfies\n$$\nT_{\\text{union}}(n) \\le T_1(n) + T_2(n),\n$$\nwhich is polynomial; hence $A_{\\text{union}}$ runs in probabilistic polynomial time.\n\nOne-sided error (soundness on negatives): If $x \\notin L_1 \\cup L_2$, then $x \\notin L_1$ and $x \\notin L_2$, so\n$$\n\\Pr(A_1(x)=1)=0 \\quad \\text{and} \\quad \\Pr(A_2(x)=1)=0.\n$$\nTherefore $A_{\\text{union}}$ accepts with probability\n$$\n\\Pr(A_{\\text{union}}(x)=1) = 0 + \\Pr(A_1(x)=0) \\cdot 0 = 0,\n$$\nso there are no false positives.\n\nAcceptance probability on positives: If $x \\in L_1 \\cup L_2$, we consider cases.\n- If $x \\in L_1 \\setminus L_2$, then $\\Pr(A_1(x)=1) \\ge \\frac{1}{2}$, so $A_{\\text{union}}$ accepts with probability at least $\\frac{1}{2}$ without needing $A_2$.\n- If $x \\in L_2 \\setminus L_1$, then $\\Pr(A_1(x)=1)=0$ (since $x \\notin L_1$), hence $A_{\\text{union}}$ runs $A_2$ and accepts with probability\n$$\n\\Pr(A_{\\text{union}}(x)=1)=\\Pr(A_2(x)=1)\\ge \\frac{1}{2}.\n$$\n- If $x \\in L_1 \\cap L_2$, then $\\Pr(A_1(x)=1) \\ge \\frac{1}{2}$, so $A_{\\text{union}}$ accepts with probability at least $\\frac{1}{2}$.\n\nIn all cases with $x \\in L_1 \\cup L_2$, we have $\\Pr(A_{\\text{union}}(x)=1) \\ge \\frac{1}{2}$. Combined with the zero acceptance probability on negatives and polynomial time, this meets the RP definition. Therefore $L_{\\text{union}} \\in \\text{RP}$, and statement A is always true. The other options are unnecessary or false as general guarantees.\n\nThus, the correct choice is A.", "answer": "$$\\boxed{A}$$", "id": "1455470"}, {"introduction": "The definition of RP specifies a success probability of at least $1/2$. This might seem arbitrary, raising the question: what if we had a \"weaker\" algorithm that only succeeded with a much smaller, polynomially-decreasing probability, like $1/p(n)$? This practice [@problem_id:1455479] delves into the powerful technique of probability amplification, showing that even a small chance of success can be boosted to a high, constant probability, demonstrating the remarkable robustness of the class RP.", "problem": "In computational complexity theory, a language is a set of strings over some alphabet. The complexity class RP (Randomized Polynomial time) is defined using a Probabilistic Polynomial-Time Machine (PPTM). A language $L$ is said to be in RP if there exists a PPTM, let's call it $M$, that runs in time polynomial in the input length $|x|$ and satisfies the following two conditions:\n1. For any string $x$ that is in the language $L$ (i.e., $x \\in L$), the machine $M$ accepts with a probability of at least $1/2$. Symbolically, $\\Pr[M(x) \\text{ accepts}] \\ge 1/2$.\n2. For any string $x$ that is not in the language $L$ (i.e., $x \\notin L$), the machine $M$ always rejects. Symbolically, $\\Pr[M(x) \\text{ accepts}] = 0$.\n\nNow, consider a new complexity class, which we will call $\\text{WEAK-RP}$. A language $L$ is in $\\text{WEAK-RP}$ if there exists a PPTM, let's call it $M'$, and a polynomial $p(n)$ such that for any input string $x$ of length $n = |x|$:\n1. If $x \\in L$, then $\\Pr[M'(x) \\text{ accepts}] \\ge 1/p(n)$.\n2. If $x \\notin L$, then $\\Pr[M'(x) \\text{ accepts}] = 0$.\n\nWhat is the relationship between the complexity classes RP and $\\text{WEAK-RP}$?\n\nA. $\\text{WEAK-RP}$ is a proper subset of RP (i.e., $\\text{WEAK-RP} \\subset \\text{RP}$ and $\\text{WEAK-RP} \\neq \\text{RP}$).\n\nB. $\\text{WEAK-RP}$ is a proper superset of RP (i.e., $\\text{RP} \\subset \\text{WEAK-RP}$ and $\\text{RP} \\neq \\text{WEAK-RP}$).\n\nC. $\\text{WEAK-RP}$ is equal to RP (i.e., $\\text{WEAK-RP} = \\text{RP}$).\n\nD. $\\text{WEAK-RP}$ and RP are incomparable (i.e., neither is a subset of the other).\n\nE. Every language in $\\text{WEAK-RP}$ is undecidable, whereas RP contains some decidable languages.", "solution": "We first restate the defining properties. RP consists of languages for which there exists a probabilistic polynomial-time machine that accepts every $x \\in L$ with probability at least $1/2$ and never accepts $x \\notin L$. The class $\\text{WEAK-RP}$ relaxes the acceptance probability on $x \\in L$ to be at least $1/p(n)$ for some polynomial $p(n)$ (depending only on the input length $n = |x|$), while still requiring zero acceptance probability on $x \\notin L$.\n\nStep 1 (RP is contained in WEAK-RP): Let $L \\in \\text{RP}$ with witness machine $M$ satisfying $\\Pr[M(x)\\text{ accepts}] \\ge 1/2$ for $x \\in L$ and $0$ for $x \\notin L$. Choose the constant polynomial $p(n) = 2$. Then $1/2 \\ge 1/p(n)$, so $M$ also witnesses that $L \\in \\text{WEAK-RP}$. Hence $\\text{RP} \\subseteq \\text{WEAK-RP}$.\n\nStep 2 (WEAK-RP is contained in RP via amplification): Let $L \\in \\text{WEAK-RP}$ with witness machine $M'$ and polynomial $p(n)$ such that for all $x$ with $n = |x|$,\n- if $x \\in L$ then $\\Pr[M'(x)\\text{ accepts}] \\ge 1/p(n)$,\n- if $x \\notin L$ then $\\Pr[M'(x)\\text{ accepts}] = 0$.\nWithout loss of generality, define $q(n) = \\max\\{1, \\lceil p(n) \\rceil\\}$ so that $q(n)$ is an integer polynomial and $q(n) \\ge 1$. Then for $x \\in L$ we still have $\\Pr[M'(x)\\text{ accepts}] \\ge 1/q(n)$ since $1/q(n) \\le 1/p(n)$.\n\nConstruct a new probabilistic polynomial-time machine $M$ that, on input $x$ of length $n$, performs $k(n) = \\lceil q(n)\\ln 2 \\rceil$ independent runs of $M'$ on $x$ and accepts if and only if at least one run accepts. This uses independent random bits across runs, so the runs are independent.\n\n- If $x \\notin L$, then each run accepts with probability $0$, so the probability that $M$ accepts is $0$. Thus the one-sided error condition is preserved.\n\n- If $x \\in L$, let $\\alpha(n) = \\Pr[M'(x)\\text{ accepts}]$, so $\\alpha(n) \\ge 1/q(n)$. By independence,\n$$\n\\Pr[M(x)\\text{ accepts}] \\;=\\; 1 - \\Pr[\\text{all }k(n)\\text{ runs reject}]\n\\;=\\; 1 - (1 - \\alpha(n))^{k(n)}.\n$$\nUsing $\\alpha(n) \\ge 1/q(n)$ and the monotonicity of $t \\mapsto (1-t)^{k}$ for $t \\in [0,1]$, we get\n$$\n\\Pr[M(x)\\text{ accepts}] \\;\\ge\\; 1 - \\left(1 - \\frac{1}{q(n)}\\right)^{k(n)} \\;\\ge\\; 1 - \\left(1 - \\frac{1}{q(n)}\\right)^{q(n)\\ln 2}.\n$$\nTo bound the latter term, use the inequality $\\ln(1 - z) \\le -z$ for $z \\in (0,1)$ to obtain\n$$\n\\left(1 - \\frac{1}{q(n)}\\right)^{q(n)\\ln 2}\n= \\exp\\!\\left(q(n)\\ln 2 \\cdot \\ln\\!\\left(1 - \\frac{1}{q(n)}\\right)\\right)\n\\le \\exp\\!\\left(q(n)\\ln 2 \\cdot \\left(-\\frac{1}{q(n)}\\right)\\right)\n= \\exp(-\\ln 2) = \\frac{1}{2}.\n$$\nTherefore,\n$$\n\\Pr[M(x)\\text{ accepts}] \\;\\ge\\; 1 - \\frac{1}{2} \\;=\\; \\frac{1}{2}.\n$$\nMachine $M$ runs in time polynomial in $n$ because it performs $k(n) = \\lceil q(n)\\ln 2 \\rceil$ independent executions of a PPTM with $k(n)$ polynomial in $n$. Thus $M$ witnesses that $L \\in \\text{RP}$.\n\nCombining Step 1 and Step 2 gives $\\text{WEAK-RP} = \\text{RP}$.\n\nHence the correct choice is C.", "answer": "$$\\boxed{C}$$", "id": "1455479"}, {"introduction": "Real-world algorithms are often built by composing smaller modules. This exercise [@problem_id:1455492] simulates a scenario where a deterministic, polynomial-time algorithm relies on an \"oracle\" or subroutine that belongs to RP. Your task is to perform a hands-on calculation to determine how many times you must run the probabilistic subroutine to guarantee that the overall error of the main algorithm remains below a desired threshold, providing insight into the practical management of error in complex randomized computations.", "problem": "An oracle Turing Machine $M$ is designed to decide a language $L_1$. On any input $x$ of length $n$, machine $M$ is guaranteed to halt in polynomial time and makes at most $Q(n) = 2n$ calls to an oracle for a language $L_2$.\n\nThe language $L_2$ belongs to the complexity class Randomized Polynomial Time (RP). This means there is a probabilistic algorithm, $A_2$, that runs in polynomial time and for any input string $y$:\n- If $y \\in L_2$, the probability that $A_2(y)$ accepts is at least $1/2$.\n- If $y \\notin L_2$, the probability that $A_2(y)$ accepts is exactly $0$.\n\nWe construct a new probabilistic algorithm, $A_1$, to decide $L_1$ without an oracle. We do this by running the machine $M$ and simulating its oracle calls. When $M$ queries the oracle about a string $y$, our simulation runs the algorithm $A_2$ on $y$ for $k$ independent trials. If at least one of these $k$ trials results in acceptance, the simulation provides the answer 'yes' to $M$; otherwise, it provides the answer 'no'.\n\nConsider an input $x$ for $L_1$ of length $n=10$. What is the minimum integer value of $k$ that guarantees the overall probability of our algorithm $A_1$ producing an incorrect answer for the input $x$ is at most $1/24$?", "solution": "Machine $M$ makes at most $Q(n)=2n$ oracle calls, so for $n=10$ there are at most $Q(10)=20$ calls.\n\nAlgorithm $A_2$ for $L_2$ has one-sided error: for $y \\in L_2$, a single trial accepts with probability at least $1/2$, and for $y \\notin L_2$ it never accepts. When simulating an oracle call on input $y$, we run $k$ independent trials and answer 'yes' if any trial accepts. Thus, for $y \\in L_2$ the probability that the simulator incorrectly answers 'no' is at most\n$$\n\\left(1-\\frac{1}{2}\\right)^{k} = 2^{-k},\n$$\nwhile for $y \\notin L_2$ the error probability is $0$.\n\nLet $E_i$ be the event that the $i$-th simulated oracle answer is wrong. Then for each possible query, $\\Pr[E_i] \\le 2^{-k}$. By the union bound over at most $Q(10)=20$ queries, the probability that any simulated oracle answer is wrong is at most\n$$\n\\sum_{i=1}^{20} \\Pr[E_i] \\le 20 \\cdot 2^{-k}.\n$$\nSince $M$ decides $L_1$ correctly given correct oracle answers, the overall error probability of $A_1$ is at most $20 \\cdot 2^{-k}$. To ensure this is at most $\\frac{1}{24}$, we require\n$$\n20 \\cdot 2^{-k} \\le \\frac{1}{24} \\quad \\Longleftrightarrow \\quad 2^{-k} \\le \\frac{1}{480} \\quad \\Longleftrightarrow \\quad k \\ge \\log_{2}(480).\n$$\nBecause $2^8=256$ and $2^9=512$, we have $\\log_2(480) \\in (8,9]$, so the minimum integer $k$ satisfying the inequality is $k=9$.", "answer": "$$\\boxed{9}$$", "id": "1455492"}]}