{"hands_on_practices": [{"introduction": "The definition of ZPP hinges on the concept of \"expected polynomial time.\" This practice provides a concrete model for a Las Vegas algorithm and asks you to derive its total expected running time. By working through this calculation, you will see how an algorithm that only succeeds with a polynomially small probability can still solve a problem efficiently on average, which is the cornerstone of the ZPP class [@problem_id:1455251].", "problem": "The complexity class ZPP (Zero-error Probabilistic Polynomial-time) consists of decision problems solvable by a probabilistic algorithm that always returns the correct answer and whose expected running time is polynomial in the input size. Such algorithms are also known as Las Vegas algorithms.\n\nConsider a randomized algorithm, `Searcher`, designed for a certain decision problem on an input of size $n$. The algorithm has the following characteristics:\n1.  The algorithm never produces an incorrect answer. It either returns the correct 'YES' or 'NO' solution, or it reports 'FAILURE'.\n2.  A single run of `Searcher`, whether it succeeds or fails, completes in a time of $T(n) = c n^{\\alpha}$, where $c$ and $\\alpha$ are given positive real constants.\n3.  For a given input of size $n$, the probability that a single run of `Searcher` succeeds (i.e., returns 'YES' or 'NO') is $p(n) = n^{-\\beta}$, where $\\beta$ is a given positive real constant.\n\nTo guarantee a solution, we construct a new master algorithm, `MasterSolver`, which repeatedly executes `Searcher` on the same input until it obtains a 'YES' or 'NO' answer. Determine the expected total running time of `MasterSolver` as a function of the parameters $c$, $\\alpha$, $\\beta$, and the input size $n$. Express your answer as a single closed-form analytic expression.", "solution": "Let $p(n)=n^{-\\beta}$ denote the success probability of a single independent run of Searcher on input size $n$, and let $T(n)=c n^{\\alpha}$ denote the deterministic time per run. Let $K$ be the number of runs until the first success when MasterSolver repeats Searcher.\n\nSince each run succeeds with probability $p(n)$ and failures cause repetition, $K$ follows a geometric distribution with parameter $p(n)$:\n$$\n\\Pr(K=k)=(1-p(n))^{k-1}p(n), \\quad k\\in\\{1,2,\\ldots\\}.\n$$\nThe expectation of a geometric random variable with parameter $p(n)$ is\n$$\n\\mathbb{E}[K]=\\sum_{k=1}^{\\infty}k(1-p(n))^{k-1}p(n)=\\frac{1}{p(n)}.\n$$\nThe total running time is $S=K\\,T(n)$ because each of the $K$ runs consumes time $T(n)$ deterministically. Therefore\n$$\n\\mathbb{E}[S]=\\mathbb{E}[K\\,T(n)]=T(n)\\,\\mathbb{E}[K]=c n^{\\alpha}\\cdot\\frac{1}{p(n)}.\n$$\nSubstituting $p(n)=n^{-\\beta}$ gives\n$$\n\\mathbb{E}[S]=c n^{\\alpha}\\cdot n^{\\beta}=c\\,n^{\\alpha+\\beta}.\n$$\nThus, the expected total running time of MasterSolver is $c\\,n^{\\alpha+\\beta}$.", "answer": "$$\\boxed{c\\,n^{\\alpha+\\beta}}$$", "id": "1455251"}, {"introduction": "The \"Zero-error\" guarantee is what makes ZPP algorithms so reliable, strictly forbidding any incorrect \"yes\" or \"no\" answers. This exercise presents a probabilistic algorithm for network connectivity that sometimes makes a mistake, a characteristic of other complexity classes like RP (Randomized Polynomial-time). Analyzing why this algorithm fails to meet the ZPP standard will clarify the crucial distinction between algorithms that are probably fast (ZPP) and algorithms that are probably correct (RP/BPP) [@problem_id:1455254].", "problem": "A systems engineer develops a new probabilistic algorithm, `NetCheck`, designed to determine if a computer network is fully connected. A network is represented as a graph where computers are vertices and direct links are edges. `NetCheck` runs in polynomial time with respect to the number of vertices in the network. The algorithm is tested extensively with the following consistent results:\n\n1.  If the input network graph is connected, `NetCheck` always outputs \"CONNECTED\".\n2.  If the input network graph is disconnected, `NetCheck` outputs \"CONNECTED\" with a probability of $\\frac{1}{3}$ and \"DISCONNECTED\" with a probability of $\\frac{2}{3}$.\n\nThe complexity class Zero-error Probabilistic Polynomial-time (ZPP) is defined for decision problems. A problem is in ZPP if there exists a probabilistic algorithm that is allowed to return a \"FAIL\" answer (i.e., \"I don't know\") with a probability of at most $\\frac{1}{2}$, but must always be correct whenever it returns a \"YES\" or \"NO\" answer. Furthermore, a ZPP algorithm must have an expected running time that is polynomial in the size of the input.\n\nBased on the behavior of `NetCheck` and the definition of a ZPP algorithm, which of the following statements provides the most accurate reason why the problem of network connectivity, as decided by the `NetCheck` algorithm, is not in the class ZPP?\n\nA. The algorithm's probability of error for disconnected networks ($\\frac{1}{3}$) is not less than or equal to an arbitrarily small constant.\nB. The algorithm only exhibits one-sided error, whereas a ZPP algorithm must be capable of error on both \"YES\" and \"NO\" instances.\nC. The algorithm can produce an incorrect \"YES\" or \"NO\" answer, which is forbidden for a ZPP algorithm.\nD. The algorithm's running time is only polynomial on average, not in the worst case.\nE. The algorithm never returns a \"FAIL\" answer, which is a required possible output for any non-deterministic ZPP algorithm.", "solution": "We formalize the decision problem as language membership: let $L$ be the set of connected graphs, where the correct output is \"YES\" for $x \\in L$ and \"NO\" for $x \\notin L$.\n\nBy specification, the probabilistic algorithm NetCheck satisfies:\n- For all $x \\in L$ (connected graphs), it outputs YES with probability $1$ and NO with probability $0$.\n- For all $x \\notin L$ (disconnected graphs), it outputs YES with probability $\\frac{1}{3}$ and NO with probability $\\frac{2}{3}$.\n\nA ZPP algorithm for a decision problem must satisfy the zero-error property: it may output a special symbol (call it FAIL), but whenever it outputs YES or NO, that answer must be correct. Formally, letting $A$ be a ZPP algorithm, for every input $x$ we have:\n- $\\Pr[A(x) = \\text{FAIL}] \\leq \\frac{1}{2}$,\n- $\\Pr[A(x) = \\text{YES} \\mid A(x) \\neq \\text{FAIL}] = 1$ if and only if $x \\in L$,\n- $\\Pr[A(x) = \\text{NO} \\mid A(x) \\neq \\text{FAIL}] = 1$ if and only if $x \\notin L$,\nand the expected running time is polynomial in the input size.\n\nNetCheck violates the zero-error requirement because there exists $x \\notin L$ such that it outputs YES with positive probability $\\frac{1}{3}$. That is, NetCheck can produce an incorrect YES on NO instances. Therefore, regardless of its runtime, NetCheck is not a ZPP algorithm.\n\nWe now evaluate the options:\n- A is incorrect because ZPP requires zero error on YES/NO outputs, not merely a small error probability; moreover, error reduction by repetition is irrelevant to ZPP’s zero-error criterion.\n- B is incorrect because ZPP does not require two-sided error; it requires zero error on definitive answers.\n- C is correct: NetCheck can output an incorrect YES (and never outputs FAIL), which is forbidden for ZPP algorithms.\n- D is incorrect because ZPP requires expected polynomial time, not worst-case polynomial time; NetCheck’s time bound is not the issue here.\n- E is incorrect because a ZPP algorithm is allowed to return FAIL but is not required to; absence of FAIL does not preclude ZPP as long as there is zero error, which NetCheck does not have.\n\nHence the most accurate reason is that NetCheck can produce an incorrect YES or NO answer, violating the zero-error requirement of ZPP.", "answer": "$$\\boxed{C}$$", "id": "1455254"}, {"introduction": "A fundamental way to understand complexity classes is by examining their closure properties—whether combining problems from a class yields a new problem that is also in that class. This final practice challenges you to design a ZPP algorithm for the concatenation of two languages, using existing ZPP algorithms as subroutines. Successfully constructing this algorithm demonstrates not only a deep understanding of ZPP but also a key skill in computational theory: building complex solutions from simpler, guaranteed components [@problem_id:1455255].", "problem": "In computational complexity theory, the class ZPP, which stands for Zero-error Probabilistic Polynomial time, represents problems solvable by a probabilistic algorithm that is always correct and runs in expected polynomial time. A ZPP algorithm for a decision problem can output 'yes', 'no', or 'unknown' (often denoted as '?'). It is characterized by two key properties:\n1.  It never returns an incorrect answer (i.e., if the true answer is 'yes', it never outputs 'no', and vice-versa).\n2.  For any given input, the probability of it returning 'unknown' is at most $\\frac{1}{2}$.\n\nConsider two languages, $L_1$ and $L_2$, over a common alphabet. You are provided with two ZPP algorithms, $A_1$ and $A_2$, which decide membership in $L_1$ and $L_2$, respectively. For an input of length $k$, the expected running time of $A_1$ is given by $T_1(k) = C_1 k^{a_1}$, and the expected running time of $A_2$ is given by $T_2(k) = C_2 k^{a_2}$. Here, $C_1, C_2, a_1,$ and $a_2$ are given positive real constants.\n\nYour task is to design a new ZPP algorithm, $A_{cat}$, that decides membership in the concatenation language $L_{cat} = L_1 L_2 = \\{uv \\mid u \\in L_1 \\text{ and } v \\in L_2\\}$. Determine the tightest possible polynomial upper bound for the worst-case expected running time of your algorithm $A_{cat}$ on an input string of length $n$. For simplicity in the final derivation, you may approximate any sum of the form $\\sum_{i=0}^{n} g(i)$ with the integral $\\int_0^n g(x) dx$. Express your answer as a symbolic expression in terms of $n, C_1, C_2, a_1$, and $a_2$.", "solution": "We are given ZPP algorithms $A_{1}$ and $A_{2}$ for $L_{1}$ and $L_{2}$ with one-shot behavior: for input length $k$, a single invocation returns a correct definitive answer or the symbol unknown, with probability of unknown at most $\\frac{1}{2}$, and with expected running time $T_{1}(k)=C_{1}k^{a_{1}}$ and $T_{2}(k)=C_{2}k^{a_{2}}$. To obtain a ZPP algorithm in the Las Vegas sense (always correct, expected polynomial time), we repeat each algorithm independently until it returns a definitive answer. If the success probability per independent trial is $p\\geq \\frac{1}{2}$, then the number $N$ of trials until success is dominated by a geometric random variable with parameter $p$, so $\\mathbb{E}[N]=\\frac{1}{p}\\leq 2$. By linearity of expectation, the expected time to obtain a definitive answer from $A_{1}$ on length $k$ is at most $2T_{1}(k)=2C_{1}k^{a_{1}}$, and for $A_{2}$ it is at most $2T_{2}(k)=2C_{2}k^{a_{2}}$.\n\nDesign $A_{cat}$ as follows. On input $x$ of length $n$, for each split index $i\\in\\{0,1,\\dots,n\\}$, let $u=x[1..i]$ and $v=x[i+1..n]$. For each $i$:\n- Repeatedly run $A_{1}$ on $u$ until it returns a definitive answer; if it returns no, continue to the next $i$; if it returns yes, proceed.\n- Repeatedly run $A_{2}$ on $v$ until it returns a definitive answer; if it returns yes, accept and halt; if it returns no, continue to the next $i$.\nIf all splits are processed without acceptance, reject. This algorithm is zero-error because $A_{1}$ and $A_{2}$ never err and we only accept when we have a definitive yes for both parts; it halts with probability $1$ and has finite expected running time due to the geometric bound above.\n\nWe now bound the worst-case expected running time. For a fixed split $i$, in the worst case we must fully resolve both $A_{1}$ on $u$ and $A_{2}$ on $v$, so the expected time cost for that split is at most\n$$\n2C_{1}i^{a_{1}}+2C_{2}(n-i)^{a_{2}}.\n$$\nSumming over all $i\\in\\{0,1,\\dots,n\\}$ and using linearity of expectation gives the worst-case expected running time\n$$\n\\mathbb{E}[T_{cat}(n)]\\leq \\sum_{i=0}^{n}\\left(2C_{1}i^{a_{1}}+2C_{2}(n-i)^{a_{2}}\\right)\n=2C_{1}\\sum_{i=0}^{n}i^{a_{1}}+2C_{2}\\sum_{i=0}^{n}(n-i)^{a_{2}}.\n$$\nFor the tightest polynomial upper bound and per the allowed approximation, we approximate each sum by the corresponding integral:\n$$\n\\sum_{i=0}^{n}i^{a}\\approx \\int_{0}^{n}x^{a}\\,dx=\\frac{n^{a+1}}{a+1}.\n$$\nApplying this to both sums yields\n$$\n\\mathbb{E}[T_{cat}(n)]\\lesssim \\frac{2C_{1}}{a_{1}+1}\\,n^{a_{1}+1}+\\frac{2C_{2}}{a_{2}+1}\\,n^{a_{2}+1}.\n$$\nThus, the tightest possible polynomial upper bound (up to lower-order terms) for the worst-case expected running time of $A_{cat}$ is the sum of these two leading terms.", "answer": "$$\\boxed{\\frac{2C_{1}}{a_{1}+1}\\,n^{a_{1}+1}+\\frac{2C_{2}}{a_{2}+1}\\,n^{a_{2}+1}}$$", "id": "1455255"}]}