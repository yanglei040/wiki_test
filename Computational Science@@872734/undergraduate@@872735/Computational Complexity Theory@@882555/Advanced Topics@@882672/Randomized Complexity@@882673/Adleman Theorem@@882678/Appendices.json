{"hands_on_practices": [{"introduction": "Adleman's theorem hinges on the existence of a \"good\" random string that works for all possible inputs of a given size. This exercise provides a hands-on opportunity to demystify this abstract concept. By manually checking a small, well-defined probabilistic algorithm, you will find the specific advice strings that correctly decide a language for every possible input, making the abstract idea of a \"universally good\" string tangible [@problem_id:1411206].", "problem": "In computational complexity theory, Adleman's theorem demonstrates a powerful connection between randomized and non-uniform computation, stating that any language in BPP (Bounded-error Probabilistic Polynomial time) is also in P/poly (Polynomial time with advice). The core idea is that for a given input length $n$, there exists at least one \"good\" random string that can be used as an \"advice string\" to make a probabilistic algorithm deterministic and correct for all $2^n$ possible inputs of that length.\n\nThis problem asks you to explore this concept in a concrete setting. Consider a probabilistic algorithm, $A$, which takes a 2-bit input string $x \\in \\{0, 1\\}^2$ and uses a 3-bit random string $r \\in \\{0, 1\\}^3$. The algorithm is designed to decide membership in the language $L = \\{x \\in \\{0,1\\}^2 \\mid \\text{the two bits of } x \\text{ are different}\\}$. A return value of 1 signifies that the algorithm accepts the input (i.e., claims $x \\in L$), and 0 signifies rejection.\n\nThe behavior of algorithm $A$ is defined as follows for any input $x$ and random string $r$:\n- If $x = 00$, the algorithm returns 1 if $r \\in \\{011, 110\\}$; otherwise, it returns 0.\n- If $x = 01$, the algorithm returns 0 if $r \\in \\{010, 101\\}$; otherwise, it returns 1.\n- If $x = 10$, the algorithm returns 0 if $r \\in \\{001, 110\\}$; otherwise, it returns 1.\n- If $x = 11$, the algorithm returns 1 if $r \\in \\{001, 100\\}$; otherwise, it returns 0.\n\nAn \"advice string\" for this input length is a specific 3-bit string $r^*$ such that for that fixed string, the algorithm $A(x, r^*)$ produces the correct output for all four possible 2-bit inputs $x \\in \\{00, 01, 10, 11\\}$.\n\nIdentify all 3-bit strings that qualify as a valid advice string for algorithm $A$ at input length $n=2$. If there is more than one such string, provide them all.", "solution": "We require that for each input $x \\in \\{00,01,10,11\\}$, the fixed advice string $r^{\\ast} \\in \\{0,1\\}^{3}$ makes the deterministic computation $A(x,r^{\\ast})$ equal the correct language decision for $L=\\{01,10\\}$, namely output $0$ for $x \\in \\{00,11\\}$ and output $1$ for $x \\in \\{01,10\\}$.\n\nFrom the algorithm’s behavior:\n- For $x=00$, $A$ outputs $1$ if and only if $r \\in \\{011,110\\}$. Correctness requires output $0$, hence $r \\notin \\{011,110\\}$.\n- For $x=01$, $A$ outputs $0$ if and only if $r \\in \\{010,101\\}$. Correctness requires output $1$, hence $r \\notin \\{010,101\\}$.\n- For $x=10$, $A$ outputs $0$ if and only if $r \\in \\{001,110\\}$. Correctness requires output $1$, hence $r \\notin \\{001,110\\}$.\n- For $x=11$, $A$ outputs $1$ if and only if $r \\in \\{001,100\\}$. Correctness requires output $0$, hence $r \\notin \\{001,100\\}$.\n\nTherefore $r^{\\ast}$ must avoid the union of all forbidden sets:\n$$\nr^{\\ast} \\notin \\{011,110\\} \\cup \\{010,101\\} \\cup \\{001,110\\} \\cup \\{001,100\\}\n= \\{001,010,011,100,101,110\\}.\n$$\nSince $\\{0,1\\}^{3}=\\{000,001,010,011,100,101,110,111\\}$, the only candidates left are $000$ and $111$.\n\nVerification:\n- For $r^{\\ast}=000$: for $x=00$ the output is $0$; for $x=01$ the output is $1$; for $x=10$ the output is $1$; for $x=11$ the output is $0$—all correct.\n- For $r^{\\ast}=111$: the same evaluations yield outputs $0,1,1,0$ respectively—also all correct.\n\nHence the complete set of valid advice strings is exactly $\\{000,111\\}$.", "answer": "$$\\boxed{\\begin{pmatrix}000  111\\end{pmatrix}}$$", "id": "1411206"}, {"introduction": "The existence of a \"good\" advice string is not a given; it's proven using a powerful probabilistic method involving a union bound. This method only works if the amplified error probability is made incredibly small. This practice problem challenges you to analyze a hypothetical scenario where amplification is weaker, forcing you to pinpoint the exact step where the proof of $BPP \\subseteq P/poly$ breaks down, thereby deepening your understanding of the argument's quantitative requirements [@problem_id:1411204].", "problem": "In computational complexity theory, Adleman's theorem states that the class of problems solvable by a Bounded-error Probabilistic Polynomial-time (BPP) algorithm is a subset of the class P/poly (problems solvable by a polynomial-time deterministic Turing machine given a polynomial-sized \"advice\" string that depends only on the input length).\n\nThe standard proof for $BPP \\subseteq P/poly$ proceeds in two main stages. First, a BPP algorithm with a constant error probability (e.g., $1/3$) is amplified by running it $k$ times and taking a majority vote. By choosing a sufficiently large polynomial $k(n)$, the error probability for any input $x$ of length $n$ can be reduced to be less than $2^{-n}$. Second, a probabilistic argument using the union bound is applied to show that for any input length $n$, there must exist at least one sequence of random bits that serves as a \"universally good\" advice string, yielding the correct answer for all $2^n$ possible inputs of that length. This is shown by demonstrating that the total probability of a random string failing on *at least one* input is less than 1.\n\nNow, consider a hypothetical complexity class, which we will call WeakBPP. A language is in WeakBPP if there exists a BPP-like algorithm for it, but due to some inherent limitations, the error probability $\\epsilon(n)$ after polynomial-time amplification can only be bounded by $\\epsilon(n)  2^{-n/2}$ for any input of length $n$.\n\nIf we attempt to apply the standard proof of Adleman's theorem to show that WeakBPP $\\subseteq$ P/poly, the argument fails. Identify the specific claim that is no longer valid or cannot be established under this weaker error bound of $2^{-n/2}$.\n\nA. The amplification step is invalid. It is impossible to reduce the error of a probabilistic algorithm to $\\epsilon(n)  2^{-n/2}$ using a number of runs that is polynomial in $n$.\n\nB. The total length of the random bits required for the amplified computation on a single input grows exponentially with the input length $n$, and thus cannot serve as a polynomial-sized advice string.\n\nC. The union bound, which states that the probability of a union of events is less than or equal to the sum of their individual probabilities, is no longer a valid inequality to apply in this scenario.\n\nD. The conclusion that there must exist a \"universally good\" advice string for all inputs of length $n$ cannot be justified, because the upper bound calculated for the total probability of failure is not less than 1.\n\nE. The number of possible inputs of length $n$, which is $2^n$, is an exponential function. The argument fails because an exponential term cannot be part of a valid complexity-theoretic proof involving polynomial resources.", "solution": "Let $L$ be a language in WeakBPP. By definition, there exists a probabilistic polynomial-time algorithm $M$ and a polynomial $k(n)$ such that, after running $M$ independently $k(n)$ times on an input $x \\in \\{0,1\\}^{n}$ and taking the majority vote, the error probability satisfies\n$$\n\\epsilon(n) \\equiv \\Pr[\\text{$M$ errs on $x$ after amplification}]  2^{-n/2}.\n$$\nFix an input length $n$ and let $R$ denote the set of all random strings used by the amplified computation; for concreteness, if one run of $M$ uses $s(n)$ random bits, then a $k(n)$-fold amplification uses $k(n)\\cdot s(n)$ random bits, so $|R| = 2^{k(n)\\cdot s(n)}$. For each $x \\in \\{0,1\\}^{n}$, define the event\n$$\nE_{x} = \\{\\text{the random string $r \\in R$ causes the amplified $M$ to err on input $x$}\\}.\n$$\nBy the amplification guarantee, for every fixed $x$,\n$$\n\\Pr_{r \\in R}[E_{x}] \\leq \\epsilon(n)  2^{-n/2}.\n$$\nLet $E$ be the event that there exists at least one input of length $n$ on which $r$ causes an error:\n$$\nE = \\bigcup_{x \\in \\{0,1\\}^{n}} E_{x}.\n$$\nApplying the union bound,\n$$\n\\Pr_{r \\in R}[E] \\leq \\sum_{x \\in \\{0,1\\}^{n}} \\Pr_{r \\in R}[E_{x}] \\leq 2^{n} \\cdot \\epsilon(n)  2^{n} \\cdot 2^{-n/2} = 2^{n/2}.\n$$\nIn Adleman’s proof for $BPP \\subseteq P/\\text{poly}$, one chooses $\\epsilon(n)$ so that $2^{n} \\cdot \\epsilon(n)  1$, which implies $\\Pr_{r \\in R}[E]  1$ and hence guarantees the existence of at least one random string $r$ that causes no error on any input of length $n$, yielding a valid advice string.\n\nUnder WeakBPP’s limitation $\\epsilon(n)  2^{-n/2}$, the bound becomes\n$$\n\\Pr_{r \\in R}[E]  2^{n/2},\n$$\nwhich is not less than $1$ for all sufficiently large $n$. Therefore, the argument cannot conclude that there exists an $r$ that works for all inputs of length $n$. The amplification step remains valid using polynomially many repetitions, the total random bits remain polynomial, and the union bound is still a valid inequality; however, the key conclusion that a “universally good” advice string must exist cannot be justified, because the computed upper bound for $\\Pr_{r \\in R}[E]$ is not strictly less than $1$.\n\nThus, the specific claim that fails is the existence of a universally good advice string via the union-bound estimate being less than $1$.", "answer": "$$\\boxed{D}$$", "id": "1411204"}, {"introduction": "Adleman's theorem states that $BPP$ is in $P/poly$, which means $BPP$ problems can be solved by polynomial-sized circuits. This exercise connects the dots between the initial probabilistic algorithm and the final circuit. You will analyze how the runtime of the $BPP$ algorithm and the number of amplification runs directly contribute to the size of the final deterministic circuit, illustrating the \"poly\" resource bounds in $P/poly$ [@problem_id:1411175].", "problem": "In computational complexity theory, Adleman's theorem establishes that any language in the class BPP is also in the class P/poly. The class Bounded-error Probabilistic Polynomial time (BPP) includes decision problems solvable by a probabilistic algorithm in polynomial time with an error probability less than 1/3. The class P/poly consists of languages that can be decided by a family of polynomial-size circuits, one for each input length.\n\nThe proof of Adleman's theorem involves a construction. First, a BPP algorithm is \"amplified\" by running it many times to reduce the error probability. Then, for any input size $n$, a single random string is found that allows the amplified algorithm to work correctly for all $2^n$ possible inputs of that size. This fixed random string is then hard-coded into a deterministic circuit.\n\nConsider a specific BPP algorithm, $A$. For an input of size $n$, a single run of algorithm $A$ takes time $p(n) = n^3$. The amplification process for this algorithm involves executing $k(n) = n^2$ independent runs of $A$ and then collecting the results for a majority vote.\n\nAssume the following for the conversion to a circuit:\n1.  The total computational work, $T_{total}(n)$, which includes all $k(n)$ runs of algorithm $A$, can be converted into a computational circuit block of size $S_{comp}(n) = c_1 \\cdot T_{total}(n) \\log(T_{total}(n))$, where $c_1$ is a constant and $\\log$ denotes the natural logarithm. For simplicity, assume the runs are sequential, so the total time is the sum of the individual times.\n2.  An additional circuit block is required to perform the majority vote on the $k(n)$ results. The size of this voting block is given by a separate polynomial function, $S_{vote}(n) = c_2 \\cdot n^4$, where $c_2$ is a constant.\n\nThe total size of the final circuit, $S(n)$, is the sum of the sizes of the computational block and the voting block. Determine the expression for the asymptotically dominant term of the total circuit size $S(n)$. For your final answer, provide this term as a function of $n$, setting all constant factors like $c_1$ and $c_2$ to 1.", "solution": "By assumption, a single run of the BPP algorithm $A$ on inputs of size $n$ takes time $p(n)=n^{3}$. The amplification executes $k(n)=n^{2}$ independent runs sequentially, so the total time is the sum of the individual times:\n$$\nT_{\\text{total}}(n)=k(n)\\,p(n)=n^{2}\\cdot n^{3}=n^{5}.\n$$\nThe computational circuit block size scales as\n$$\nS_{\\text{comp}}(n)=c_{1}\\,T_{\\text{total}}(n)\\,\\ln(T_{\\text{total}}(n)) = c_{1} n^{5} \\ln(n^{5}) = 5c_{1} n^{5}\\ln n.\n$$\nThe voting block has size\n$$\nS_{\\text{vote}}(n)=c_{2}\\,n^{4}.\n$$\nTherefore, the total circuit size is\n$$\nS(n)=S_{\\text{comp}}(n)+S_{\\text{vote}}(n)=5c_{1} n^{5}\\ln n + c_{2} n^{4}.\n$$\nTo identify the asymptotically dominant term, compare the two contributions via their ratio:\n$$\n\\frac{5c_{1} n^5 \\ln n}{c_{2} n^4} = \\frac{5c_1}{c_2} n \\ln n \\to\\infty\\quad\\text{as }n\\to\\infty,\n$$\nso $5c_{1} n^5 \\ln n$ dominates $c_{2} n^{4}$. Setting all constant factors like $c_{1}$ and $c_{2}$ to $1$ and suppressing constant multiplicative factors in the asymptotically dominant term, we obtain\n$$\n\\text{dominant term} \\sim n^{5}\\ln n.\n$$", "answer": "$$\\boxed{n^{5}\\ln n}$$", "id": "1411175"}]}