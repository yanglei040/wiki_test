{"hands_on_practices": [{"introduction": "To truly grasp the power of a computational resource, it is often insightful to consider what happens when that resource is removed. This exercise invites you to explore the foundational structure of an Arthur-Merlin (AM) protocol by stripping Arthur of his randomness. By determining the resulting complexity class, you will gain a clearer understanding of the precise role that public coins play in augmenting the power of a deterministic verifier. [@problem_id:1439656]", "problem": "In computational complexity theory, interactive proof systems are abstract models that describe computations involving a verifier and a prover. The Arthur-Merlin (AM) protocol is a specific type of interactive proof system for a decision problem concerning a language $L$. It involves a probabilistic polynomial-time verifier, named Arthur, and an all-powerful, untrustworthy prover, named Merlin.\n\nFor an input string $x$ of length $n$, the standard AM protocol is defined as follows:\n1.  Arthur, the verifier, receives the input $x$. He generates a random string $r$ of length polynomial in $n$ and sends it to Merlin. This string is considered \"public\" as Merlin can see it.\n2.  Merlin, the prover, upon receiving $x$ and $r$, computes and sends a response string $y$, of length polynomial in $n$, back to Arthur.\n3.  Arthur then runs a deterministic polynomial-time algorithm, let's call its decision function $V(x, y, r)$, to either accept or reject the input $x$ based on the proof $y$ and his random string $r$.\n\nA language $L$ is in the complexity class AM if the following two conditions are met:\n- **Completeness:** For any string $x \\in L$, there exists a response $y$ from Merlin that makes Arthur accept with high probability. Formally: $\\forall x \\in L$, Merlin can choose a proof $y$ such that $\\Pr_{r}[V(x, y, r) = \\text{accept}] \\geq \\frac{2}{3}$.\n- **Soundness:** For any string $x \\notin L$, no matter what response $y$ Merlin provides, Arthur will accept with low probability. Formally: $\\forall x \\notin L$, for any proof $y$, $\\Pr_{r}[V(x, y, r) = \\text{accept}] \\leq \\frac{1}{3}$.\n\nNow, consider a modified version of this protocol where Arthur is stripped of his ability to use randomness. He becomes a purely deterministic polynomial-time verifier, meaning he does not generate or use any random string $r$. Which of the following well-known complexity classes is equivalent to the class of languages decidable by this modified, deterministic Arthur-Merlin protocol?\n\nA. P (Polynomial-Time)\n\nB. BPP (Bounded-error Probabilistic Polynomial-Time)\n\nC. NP (Nondeterministic Polynomial-Time)\n\nD. co-NP\n\nE. AM\n\nF. MA", "solution": "We restate the standard AM definition and then remove randomness to derive the resulting class.\n\nIn AM, the verifier uses a polynomial-length random string $r$ and a deterministic decision procedure $V(x,y,r)$. The completeness and soundness conditions are:\n$$\n\\forall x \\in L,\\ \\exists y \\text{ of length poly}(|x|):\\ \\Pr_{r}\\big[V(x,y,r)=\\text{accept}\\big] \\geq \\frac{2}{3},\n$$\n$$\n\\forall x \\notin L,\\ \\forall y \\text{ of length poly}(|x|):\\ \\Pr_{r}\\big[V(x,y,r)=\\text{accept}\\big] \\leq \\frac{1}{3}.\n$$\n\nNow remove Arthur’s randomness. This yields a deterministic polynomial-time verifier, so there is no $r$. Equivalently, let $r$ be the empty string $\\epsilon$, and define a deterministic decision predicate $V'(x,y) \\coloneqq V(x,y,\\epsilon)$. The probability over $r$ becomes trivial: for any fixed input and proof, the acceptance probability is either $0$ or $1$. Thus the two AM conditions collapse to:\n$$\n\\forall x \\in L,\\ \\exists y \\text{ of length poly}(|x|):\\ V'(x,y)=\\text{accept},\n$$\n$$\n\\forall x \\notin L,\\ \\forall y \\text{ of length poly}(|x|):\\ V'(x,y)=\\text{reject}.\n$$\n\nThese are exactly the verifier-based definition of $\\mathrm{NP}$: a language has a polynomial-length witness $y$ that a deterministic polynomial-time verifier accepts on yes-instances, and no such witness exists on no-instances.\n\nFormally, we show both inclusions.\n\n- Modified-AM $\\subseteq \\mathrm{NP}$: Given a language $L$ decided by the modified protocol with verifier $V'$, define the $\\mathrm{NP}$ verifier $W(x,y)=1$ iff $V'(x,y)=\\text{accept}$. By completeness there exists $y$ for $x \\in L$ making $W$ accept, and by soundness no $y$ makes $W$ accept for $x \\notin L$.\n\n- $\\mathrm{NP} \\subseteq$ Modified-AM: Given $L \\in \\mathrm{NP}$ with verifier $W(x,y)$ running in deterministic polynomial time, construct the modified protocol where Merlin sends $y$ and Arthur computes $V'(x,y) \\coloneqq W(x,y)$. Completeness and soundness follow directly from the definition of $\\mathrm{NP}$.\n\nHence the class obtained by removing verifier randomness from AM equals $\\mathrm{NP}$. Among the options, this is choice C.", "answer": "$$\\boxed{C}$$", "id": "1439656"}, {"introduction": "Abstract definitions come to life when applied to concrete problems. Here, we examine a specific private-coin protocol designed for Graph Non-3-Colorability, a classic problem in the class $\\mathrm{co-NP}$. Your task is to step into the shoes of a cheating prover and analyze the protocol's soundness from an adversarial perspective. This practice is essential for developing the skills to evaluate the security and robustness of interactive proof systems. [@problem_id:1439692]", "problem": "An all-powerful Prover (P) attempts to convince a probabilistic Verifier (V) that a given simple graph $G$ with $n$ vertices is not 3-colorable. They agree to use the following single-round private-coin protocol:\n\n1.  The Verifier (V) secretly chooses a bit $b$. The bit is chosen to be $b=0$ with probability $q$ and $b=1$ with probability $1-q$.\n2.  If $b=0$, V generates a graph $H$ by applying a uniformly random vertex permutation to $G$.\n3.  If $b=1$, V generates a \"chameleon graph\" $H$ on $n$ vertices. To do this, V first defines a 3-coloring $C$ by independently and uniformly assigning each of the $n$ vertices to one of three color sets, $S_1, S_2,$ or $S_3$. Then, for each pair of vertices $\\{u, v\\}$, an edge is added to $H$ with probability $\\frac{1}{2}$ if $u$ and $v$ have different colors under $C$, and no edge is added if they have the same color.\n4.  V sends the graph $H$ to P. The bit $b$ remains V's secret.\n5.  P, having unbounded computational power, must respond with either a valid 3-coloring of $H$ or the symbol $\\bot$ if no such coloring exists.\n6.  V makes a decision: V accepts P's original claim (that $G$ is not 3-colorable) if and only if (P returns $\\bot$ and $b=0$) or (P returns a valid 3-coloring and $b=1$). In all other situations, V rejects.\n\nSuppose the Prover is a cheater: the graph $G$ is, in fact, 3-colorable. The Prover knows this and is committed to playing an optimal strategy to maximize the probability that V accepts the false claim. If the Verifier sets the probability $q = \\frac{1}{3}$, what is this maximum probability of success for the cheating Prover? Express your answer as a fraction in simplest form.", "solution": "We analyze the two possible values of the verifier’s hidden bit $b$.\n\nBy hypothesis, $G$ is 3-colorable. In Step 2, if $b=0$, the verifier sends $H$ obtained by a uniformly random permutation of the vertices of $G$. Graph isomorphism preserves 3-colorability, so $H$ is 3-colorable whenever $b=0$.\n\nIn Step 3, if $b=1$, the verifier constructs a “chameleon graph” $H$ by first assigning each vertex independently and uniformly to one of three color classes $S_{1},S_{2},S_{3}$, and then adding edges only between vertices in different classes, each with probability $\\frac{1}{2}$, and adding no edges between vertices within the same class. By construction, there are no edges within any $S_{i}$, so the 3-coloring $C$ defined by the partition $\\{S_{1},S_{2},S_{3}\\}$ is a proper 3-coloring of $H$. Hence $H$ is 3-colorable whenever $b=1$.\n\nTherefore, in both cases $b=0$ and $b=1$, the prover can always output a valid 3-coloring of $H$. The verifier’s acceptance criterion is: accept if and only if the prover returns $\\bot$ and $b=0$, or returns a valid 3-coloring and $b=1$. Since $H$ is always 3-colorable, the prover can secure acceptance only by matching the hidden bit $b$: returning $\\bot$ when $b=0$, or returning a valid 3-coloring when $b=1$. Any fixed strategy that always returns $\\bot$ succeeds with probability $\\Pr[b=0]=q$, and any fixed strategy that always returns a valid 3-coloring succeeds with probability $\\Pr[b=1]=1-q$.\n\nTo maximize success, the prover should choose the response corresponding to the more likely value of $b$. Given $q=\\frac{1}{3}$, we have $1-q=\\frac{2}{3}$, so the optimal strategy is to always return a valid 3-coloring, yielding success probability $1-q=\\frac{2}{3}$.\n\nThus, the maximum probability of success for the cheating prover under $q=\\frac{1}{3}$ is $\\frac{2}{3}$.", "answer": "$$\\boxed{\\frac{2}{3}}$$", "id": "1439692"}, {"introduction": "A cornerstone result in complexity theory is that public-coin protocols are just as powerful as private-coin ones ($\\mathrm{AM} = \\mathrm{IP}$). However, this equivalence is far from obvious. This problem illustrates why the simulation is non-trivial by exposing a fatal flaw in a simple-minded attempt to convert a private-coin system into a public-coin one. By analyzing the failure of this naive approach, you will appreciate the subtlety and ingenuity required for the actual proof and understand the fundamental difference in how private and public randomness is used. [@problem_id:1439683]", "problem": "In computational complexity theory, an Interactive Proof (IP) system involves a powerful Prover trying to convince a randomized Verifier about the truth of a statement. Consider a \"private-coin\" IP system for a language $L$. For a given input string $x$, the Verifier uses a private random string $r$, drawn uniformly from a set $\\mathcal{R}$ of $2^k$ possible strings, to conduct a dialogue with the Prover. At the end of the interaction, the Verifier decides whether to accept or reject.\n\nThis private-coin system is defined by two properties:\n1.  **Completeness:** If the input string $x$ is in the language $L$, there exists a strategy for an honest Prover that can always convince the Verifier to accept. The probability of acceptance is 1.\n2.  **Soundness:** If the input string $x$ is not in the language $L$, no Prover, regardless of its strategy, can convince the Verifier to accept with a probability greater than $s$, where $0 < s < 1$. The probability is taken over the Verifier's random choice of $r \\in \\mathcal{R}$.\n\nNow, consider a different, simpler proof system, which we will call a \"certificate-based\" system, $\\mathcal{P}_{cert}$. In this system, to prove that $x$ is in $L$, the Prover provides a single certificate to a deterministic Verifier. The proposed certificate is a pair $(r_{guess}, T)$, where $r_{guess}$ is a specific string from the set $\\mathcal{R}$, and $T$ is a full transcript of a conversation. The deterministic Verifier for $\\mathcal{P}_{cert}$ performs a single check: it verifies if the provided transcript $T$ represents an interaction that would cause the original private-coin Verifier to accept the input $x$, had its private random string been $r_{guess}$. If this check passes, the Verifier accepts; otherwise, it rejects.\n\nAssume that for a particular string $x_{false}$ which is not in $L$, the set of private random strings that would allow a malicious Prover to fool the original private-coin Verifier is non-empty. What is the probability that the Verifier in the certificate-based system $\\mathcal{P}_{cert}$ will accept the false statement \"$x_{false}$ is in $L$\" when presented with a certificate from an optimal, malicious Prover?\n\nA. $s$\n\nB. $s^k$\n\nC. $s/2^k$\n\nD. $1$\n\nE. $0$", "solution": "Let $\\mathcal{R}$ be the verifier’s randomness space with $|\\mathcal{R}|=2^{k}$. For $x_{false} \\notin L$, the soundness condition of the private-coin IP states that for any prover strategy, the acceptance probability over a uniformly random $r \\in \\mathcal{R}$ is at most $s$. Equivalently, there exists a set $S \\subseteq \\mathcal{R}$ of “accepting” random strings (those for which some interaction with a prover can lead the original verifier to accept) such that\n$$\n\\frac{|S|}{|\\mathcal{R}|} \\le s \\quad \\Longrightarrow \\quad |S| \\le s \\cdot 2^{k}.\n$$\nThe problem assumes $S \\neq \\emptyset$.\n\nIn the certificate-based system $\\mathcal{P}_{cert}$, the verifier is deterministic and performs a single check on a certificate $(r_{guess}, T)$. A malicious prover aiming to maximize acceptance can choose $r_{guess} \\in S$ (which exists by the assumption $S \\neq \\emptyset$) and provide a corresponding transcript $T$ that is accepting for the original verifier with randomness $r_{guess}$. The deterministic verifier then verifies that $T$ is a valid accepting transcript for $r_{guess}$ and accepts. There is no remaining randomness in this verification, so the acceptance is certain whenever such an $r_{guess}$ is used.\n\nTherefore, when presented with a certificate from an optimal, malicious prover under the assumption that $S \\neq \\emptyset$, the probability that the certificate-based verifier accepts the false statement is\n$$\n1.\n$$\nThis corresponds to option D.", "answer": "$$\\boxed{D}$$", "id": "1439683"}]}