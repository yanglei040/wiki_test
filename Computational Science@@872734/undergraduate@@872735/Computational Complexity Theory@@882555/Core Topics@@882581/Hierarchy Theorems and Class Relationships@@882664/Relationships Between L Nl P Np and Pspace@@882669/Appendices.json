{"hands_on_practices": [{"introduction": "Understanding the landscape of computational complexity begins with mastering the definitions of the core classes. This first exercise is a direct application of these fundamentals. By analyzing a hypothetical algorithm's time and space requirements, you will practice identifying the most specific complexity class a problem belongs to, reinforcing the precise meanings of L, P, and the hierarchy connecting them [@problem_id:1445945].", "problem": "In computational complexity theory, we classify problems based on the computational resources—primarily time and space—required to solve them. Let us consider the following standard complexity classes for decision problems, defined with respect to an input of size $n$:\n\n- **L (Logarithmic Space):** The class of problems solvable by a deterministic algorithm using an amount of memory that is logarithmic in the input size, i.e., $O(\\log n)$.\n- **NL (Nondeterministic Logarithmic Space):** The class of problems solvable by a nondeterministic algorithm using $O(\\log n)$ memory.\n- **P (Polynomial Time):** The class of problems solvable by a deterministic algorithm in a number of steps that is a polynomial function of the input size, i.e., $O(n^k)$ for some constant $k$.\n- **NP (Nondeterministic Polynomial Time):** The class of problems for which a proposed solution can be verified by a deterministic algorithm in polynomial time.\n- **PSPACE (Polynomial Space):** The class of problems solvable by a deterministic algorithm using an amount of memory that is a polynomial function of the input size.\n\nSuppose a computer scientist discovers a new deterministic algorithm that solves a particular decision problem. The algorithm's performance is analyzed and found to have a time complexity of $O(n^2)$ and a space complexity of $O(\\log n)$.\n\nBased strictly on this information, what is the smallest (most specific) complexity class from the list below that we can be certain the problem belongs to?\n\nA. PSPACE\n\nB. NP\n\nC. P\n\nD. NL\n\nE. L", "solution": "We are given a deterministic algorithm for a decision problem with time complexity $T(n)=O(n^{2})$ and space complexity $S(n)=O(\\log n)$.\n\n1) By the definition of the class P, a problem is in P if there exists a deterministic algorithm that solves it in polynomial time. Since $T(n)=O(n^{2})$, which is polynomial, the problem is in P.\n\n2) By the definition of the class L, a problem is in L if there exists a deterministic algorithm that solves it using logarithmic space. Since $S(n)=O(\\log n)$ and the algorithm is deterministic, the problem is in L.\n\n3) Using standard inclusions among the listed classes,\n$$\n\\mathrm{L} \\subseteq \\mathrm{NL} \\subseteq \\mathrm{P} \\subseteq \\mathrm{NP} \\subseteq \\mathrm{PSPACE}.\n$$\nBecause the problem is in L, it is also in each superset, but the smallest (most specific) class from the given options that we can be certain it belongs to is $\\mathrm{L}$.\n\nTherefore, the correct choice is E.", "answer": "$$\\boxed{E}$$", "id": "1445945"}, {"introduction": "One of the most profound results in complexity theory is Savitch's Theorem, which establishes a formal relationship between deterministic and nondeterministic space. This practice moves beyond simple definitions to applying this powerful theorem. You will see how knowing the nondeterministic space complexity of a problem allows us to place a firm upper bound on the deterministic space required to solve it, demonstrating that nondeterminism in space is not as powerful as it might seem [@problem_id:1445880].", "problem": "In computational complexity theory, we classify problems based on the resources required to solve them. Let `DSPACE(s(n))` denote the class of decision problems that can be solved by a deterministic Turing machine using an amount of space on its work tape that is on the order of $s(n)$, where $n$ is the size of the input. Similarly, let `NSPACE(s(n))` denote the class of problems solvable by a non-deterministic Turing machine using $O(s(n))$ space.\n\nA fundamental result connecting these two types of space complexity is Savitch's Theorem, which states that for any function $s(n)$ that is space-constructible and satisfies $s(n) \\ge \\log n$, the following relationship holds: `NSPACE(s(n))` is a subset of `DSPACE(s(n)^2)`.\n\nSuppose a computer scientist develops an algorithm for a specific decision problem. This algorithm is designed for a non-deterministic Turing machine and is proven to use an amount of work-tape space that is proportional to $(\\log n)^2$ for an input of size $n$.\n\nBased on this information and Savitch's Theorem, what is the tightest conclusion one can draw about the space complexity of solving this problem on a *deterministic* Turing machine?\n\nA. The problem is solvable using $O(\\log n)$ deterministic space.\n\nB. The problem is solvable using $O((\\log n)^2)$ deterministic space.\n\nC. The problem is solvable using $O((\\log n)^3)$ deterministic space.\n\nD. The problem is solvable using $O((\\log n)^4)$ deterministic space.\n\nE. The problem requires polynomial space, but a more specific polylogarithmic bound cannot be determined from the given information.", "solution": "The problem statement provides that a new algorithm solves a decision problem on a non-deterministic Turing machine using work-tape space proportional to $(\\log n)^2$. In the language of complexity classes, this means the problem belongs to the class `NSPACE((\\log n)^2)`.\n\nWe are given Savitch's Theorem, which provides a relationship between non-deterministic space complexity and deterministic space complexity. The theorem states that for a space-constructible function $s(n)$ where $s(n) \\ge \\log n$, we have `NSPACE(s(n)) \\subseteq DSPACE(s(n)^2)`.\n\nTo apply this theorem, we must identify our space function $s(n)$ and verify that it meets the theorem's preconditions. In this case, the non-deterministic space usage is $O((\\log n)^2)$, so we set our space function $s(n) = (\\log n)^2$.\n\nFirst, we check the condition $s(n) \\ge \\log n$. For our function, this means we must check if $(\\log n)^2 \\ge \\log n$. Dividing both sides by $\\log n$ (for $n>1$, where $\\log n > 0$), we get $\\log n \\ge 1$. This inequality holds for all $n \\ge e$, where $e$ is Euler's number (approximately 2.718). Thus, for all non-trivially sized inputs, the condition is met. The function $s(n) = (\\log n)^2$ is also a standard space-constructible function. Therefore, Savitch's Theorem is applicable.\n\nNow, we apply the theorem by substituting $s(n) = (\\log n)^2$ into the inclusion `NSPACE(s(n)) \\subseteq DSPACE(s(n)^2)`.\nThis gives us:\n`NSPACE((\\log n)^2) \\subseteq DSPACE( ((\\log n)^2)^2 )`\n\nNext, we simplify the expression on the right-hand side. The space bound for the deterministic class is $(s(n))^2$, which in our case is $((\\log n)^2)^2$. Using the rule of exponents $(x^a)^b = x^{ab}$, we have:\n$((\\log n)^2)^2 = (\\log n)^{2 \\times 2} = (\\log n)^4$.\n\nSo, the inclusion becomes:\n`NSPACE((\\log n)^2) \\subseteq DSPACE((\\log n)^4)`\n\nThis result tells us that any problem in `NSPACE((\\log n)^2)` is also in `DSPACE((\\log n)^4)`. In other words, there must exist a deterministic algorithm that can solve the problem using space on the order of $O((\\log n)^4)$. This is the tightest upper bound that can be concluded directly from Savitch's Theorem.\n\nComparing this result with the given options:\nA. $O(\\log n)$ is incorrect.\nB. $O((\\log n)^2)$ is incorrect; this would imply `NSPACE` is equal to `DSPACE` for this function, which is not guaranteed by the theorem.\nC. $O((\\log n)^3)$ is incorrect; this results from an arithmetic error when squaring the space function.\nD. $O((\\log n)^4)$ matches our derived upper bound.\nE. This is incorrect because we were able to determine a specific polylogarithmic bound.\n\nTherefore, the correct conclusion is that the problem is solvable using $O((\\log n)^4)$ deterministic space.", "answer": "$$\\boxed{D}$$", "id": "1445880"}, {"introduction": "Complexity classes are not just isolated categories; they possess structural properties that govern how they interact. This final exercise explores one such property: closure under the union operation. By considering a problem formed by combining a language from P and another from NP, you will gain deeper insight into the relationship between these two crucial classes and why NP is considered the 'larger' or more general of the two in this context [@problem_id:1445910].", "problem": "In computational complexity theory, we categorize problems based on the resources required to solve them. Let $L_1$ be a language that belongs to the complexity class P, which consists of all decision problems that can be solved by a deterministic Turing machine in polynomial time. Let $L_2$ be a language that belongs to the complexity class NP, which consists of all decision problems for which a 'yes' instance has a proof (a certificate) that can be verified in polynomial time by a deterministic Turing machine.\n\nConsider the union of these two languages, defined as $L = L_1 \\cup L_2 = \\{x \\mid x \\in L_1 \\text{ or } x \\in L_2\\}$.\n\nWhich of the following represents the smallest complexity class that is guaranteed to contain the language $L$ for any valid choice of $L_1$ and $L_2$?\n\nA. P\n\nB. NP\n\nC. co-NP\n\nD. PSPACE\n\nE. EXPTIME", "solution": "We are given $L_1 \\in \\text{P}$ and $L_2 \\in \\text{NP}$, and we consider $L = L_1 \\cup L_2$.\n\nFirst, use the inclusion $\\text{P} \\subseteq \\text{NP}$, which holds because any language decidable in deterministic polynomial time has certificates that can be verified in polynomial time by the trivial verifier that recomputes the decision. Hence $L_1 \\in \\text{NP}$ and $L_2 \\in \\text{NP}$.\n\nNext, use the closure of $\\text{NP}$ under union. To see this constructively, define a nondeterministic polynomial-time machine $M$ for $L$ as follows. On input $x$:\n- Deterministically decide whether $x \\in L_1$ in polynomial time (since $L_1 \\in \\text{P}$). If yes, accept.\n- If not, run the $\\text{NP}$ verifier (or nondeterministic machine) for $L_2$ on $x$ and accept if it accepts.\nThis machine runs in polynomial time and accepts exactly when $x \\in L_1$ or $x \\in L_2$, so $L \\in \\text{NP}$.\n\nNow argue minimality among the given options:\n- $L$ is not guaranteed to be in $\\text{P}$: choose $L_1 = \\emptyset$ (which is in $\\text{P}$) and $L_2$ to be any $\\text{NP}$-complete language (for example, SAT). Then $L = L_2$, which is not known to be in $\\text{P}$; unless $\\text{P} = \\text{NP}$, it is not in $\\text{P}$. Therefore $\\text{P}$ is not guaranteed.\n- $L$ is not guaranteed to be in $\\text{co-NP}$: using the same choice $L = L_2$ where $L_2$ is $\\text{NP}$-complete, unless $\\text{NP} = \\text{co-NP}$, such an $L$ is not in $\\text{co-NP}$, so $\\text{co-NP}$ is not guaranteed.\n- Both $\\text{PSPACE}$ and $\\text{EXPTIME}$ contain $\\text{NP}$, but they are strictly larger candidates than necessary; since $L \\in \\text{NP}$ for all valid choices, these are not the smallest guaranteed classes.\n\nTherefore, the smallest complexity class from the options that is guaranteed to contain $L$ for any valid $L_1 \\in \\text{P}$ and $L_2 \\in \\text{NP}$ is $\\text{NP}$.", "answer": "$$\\boxed{B}$$", "id": "1445910"}]}