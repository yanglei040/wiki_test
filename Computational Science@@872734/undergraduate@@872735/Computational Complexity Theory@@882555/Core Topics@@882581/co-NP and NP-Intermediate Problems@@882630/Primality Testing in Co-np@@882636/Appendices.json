{"hands_on_practices": [{"introduction": "The foundation of the complexity class NP lies in the concept of a \"certificate\"—a piece of evidence that can be quickly checked. This first exercise invites you to think like a complexity theorist by designing a system to prove a number is a perfect power, such as $8 = 2^3$ or $81 = 9^2$. Your task is to evaluate different proposals and identify the most direct and efficient certificate-verifier pair, which is the key to demonstrating that a problem belongs in NP. [@problem_id:1436744]", "problem": "In computational complexity theory, a language $L$ is in the class NP (Non-deterministic Polynomial time) if a proposed solution (called a \"certificate\") for an instance of the problem can be verified in polynomial time.\n\nConsider the language of perfect powers, $L_{\\text{PP}}$, which consists of all positive integers $n$ that can be expressed as $a^k$ for integers $a, k \\ge 2$. An algorithm that determines membership in this language is given an integer $n$ as input. The size of this input is measured by the number of bits required to represent $n$, which we denote as $B = \\lfloor \\log_2 n \\rfloor + 1$. A verifier is considered to run in polynomial time if its runtime is bounded by a polynomial in $B$.\n\nA computer scientist is designing a verifier for $L_{\\text{PP}}$. She has four proposals, each consisting of a certificate to be provided and a verification algorithm. Which of the following proposals correctly and most directly demonstrates that $L_{\\text{PP}}$ is in the class NP?\n\nA. **Certificate:** An integer $k \\ge 2$. **Verifier:** Perform a binary search for an integer $a$ in the range $[2, n]$ to check if $a^k = n$.\n\nB. **Certificate:** An integer $a \\ge 2$. **Verifier:** Iterate through all integers $k$ from $2$ up to $n$ and check if $a^k = n$.\n\nC. **Certificate:** A pair of integers $\\langle a, k \\rangle$ where $a, k \\ge 2$. **Verifier:** Compute $a^k$ and check if it equals $n$.\n\nD. **Certificate:** The complete prime factorization of $n$ in the form $p_1^{e_1} p_2^{e_2} \\cdots p_m^{e_m}$. **Verifier:** Check that all $p_i$ are prime, that their powers multiply to $n$, and that the greatest common divisor of the exponents $\\{e_1, e_2, \\dots, e_m\\}$ is greater than 1.", "solution": "We recall the NP verifier definition: there exists a polynomial $p$ such that for every input $x$ of length $|x|$, there exists a certificate $y$ with $|y| \\leq p(|x|)$ and a deterministic verifier $V$ that runs in time polynomial in $|x|$ and accepts if and only if $x$ is in the language. Here, the input is a positive integer $n$ with bit-length $B=\\lfloor \\log_{2} n \\rfloor + 1$. We denote by $M(B)$ the time to multiply two $B$-bit integers on the standard RAM model; $M(B)$ is polynomial in $B$. Fast exponentiation by repeated squaring uses $O(\\log k)$ multiplications.\n\nWe analyze each proposal for certificate length and verifier runtime in terms of $B$.\n\nA. Certificate: an integer $k \\geq 2$. Since $n=a^{k}$ with $a \\geq 2$ implies $2^{k} \\leq n$, any valid certificate satisfies $k \\leq \\log_{2} n$, hence its bit-length is $O(\\log k) \\leq O(\\log \\log n)=O(\\log B)$, which is polynomial in $B$. The verifier binary searches $a$ in $[2,n]$. The function $f(a)=a^{k}$ is strictly increasing in $a \\geq 1$, so binary search takes $O(\\log n)=O(B)$ iterations. In each iteration, computing $a^{k}$ by repeated squaring takes $O(\\log k)$ multiplications, and we can abort early if an intermediate value exceeds $n$, so all intermediates have at most $B$ bits. Thus a single exponentiation costs $O(M(B)\\log k) \\leq O(M(B)\\log B)$. The total time is $O(B \\cdot M(B) \\cdot \\log B)$, which is polynomial in $B$. Therefore A is a valid NP verification procedure.\n\nB. Certificate: an integer $a \\geq 2$. The certificate length is $O(\\log a) \\leq O(B)$, but the verifier iterates $k$ from $2$ up to $n$, which is $\\Theta(n)$ iterations. Since $n$ has $B$ bits, $n$ can be as large as $2^{B}$, so a loop of length $\\Theta(n)$ is exponential in $B$ and not polynomial. Therefore B does not demonstrate membership in NP.\n\nC. Certificate: a pair $\\langle a,k \\rangle$ with $a,k \\geq 2$. Since $a^{k}=n$ and $a \\geq 2$ imply $a \\leq n$ and $k \\leq \\log_{2} n$, the certificate length is $O(\\log a + \\log k) \\leq O(B + \\log B)=O(B)$. The verifier computes $a^{k}$ by repeated squaring, aborting if an intermediate exceeds $n$, ensuring all intermediates have at most $B$ bits. This takes $O(\\log k)$ multiplications, so $O(M(B)\\log k) \\leq O(M(B) B)$ time, plus an $O(B)$ comparison with $n$. Hence the verification runs in time polynomial in $B$. This is the simplest and most direct NP certificate: it supplies exactly the witness $\\langle a,k \\rangle$ and checks $a^{k}=n$.\n\nD. Certificate: the prime factorization $n=\\prod_{i=1}^{m} p_{i}^{e_{i}}$. The size of this certificate is $O\\!\\left(\\sum_{i=1}^{m} \\log p_{i} + \\sum_{i=1}^{m} \\log e_{i}\\right)$. Since $\\sum \\log p_{i} \\leq \\log n = O(B)$ and each $e_{i} \\leq \\log_{2} n$ with $m \\leq B$, we have $\\sum \\log e_{i} \\leq m \\log \\log n = O(B \\log B)$. Thus the certificate length is polynomial in $B$. The verifier checks primality of each $p_{i}$ deterministically in polynomial time (e.g., via AKS), multiplies $\\prod p_{i}^{e_{i}}$ and compares with $n$ in $O(B \\cdot M(B))$ time, and computes $\\gcd(e_{1},\\dots,e_{m})$ in time polynomial in $\\log \\max e_{i} \\leq O(\\log B)$. Therefore D is also a valid NP verification procedure.\n\nAmong the valid proposals, C is the most direct demonstration that $L_{\\text{PP}} \\in \\text{NP}$ because it uses the natural witness $\\langle a,k \\rangle$ and a straightforward polynomial-time check $a^{k}=n$ without auxiliary heavy subroutines or additional search.", "answer": "$$\\boxed{C}$$", "id": "1436744"}, {"introduction": "Building on our understanding of NP, we now turn to its sibling class, co-NP. A language is in co-NP if its complement is in NP, meaning we can efficiently certify \"no\" instances. This practice [@problem_id:1436748] asks you to do just that: to prove that the language of prime powers (e.g., $8=2^3$, $49=7^2$) is in co-NP, you must design a certificate for numbers that are *not* prime powers—that is, numbers with at least two distinct prime factors.", "problem": "In computational complexity theory, a key concept is that of a \"certificate\" or \"witness.\" For a given language $L$ (a set of strings, or in this case, integers), a certificate for an input $n$ is a piece of information $y$ that allows a verifier algorithm to efficiently confirm that $n$ is indeed in $L$. A verifier $V(n, y)$ must run in time polynomial in the size of $n$ (i.e., polynomial in $\\log_2 n$) and must satisfy two conditions:\n1.  **Completeness**: For every $n \\in L$, there exists a certificate $y$ (of size polynomial in $\\log_2 n$) such that $V(n,y)$ accepts.\n2.  **Soundness**: For any $n \\notin L$, the verifier $V(n,y)$ must reject for all possible certificates $y$.\n\nConsider the language $L$ of positive integers that are composed of at least two distinct prime factors. For example, $12 = 2^2 \\cdot 3$ is in $L$, but $17$ (a prime) and $8 = 2^3$ (a prime power) are not.\n\nWhich of the following proposals for a certificate $y$ are valid for demonstrating that an integer $n$ belongs to the language $L$?\n\nA. Two integers $u,v$ such that $u > 1$, $v > 1$, and $n = uv$.\n\nB. A single integer $d$ such that $1  d  n$ and $d$ divides $n$.\n\nC. Two integers $u,v$ such that $u > 1$, $v > 1$, $n = uv$, and their greatest common divisor $\\gcd(u,v) = 1$.\n\nD. A prime number $p$ that divides $n$, and an integer $m > 1$ such that $m$ also divides $n$ and $\\gcd(p,m) = 1$.\n\nE. Two distinct prime numbers $p_1, p_2$ that both divide $n$.\n\nSelect all valid options.", "solution": "We formalize the language $L$ as the set of positive integers $n$ whose prime factorization contains at least two distinct primes. Equivalently, $n \\in L$ if and only if there exist distinct primes $p_{1}$ and $p_{2}$ such that $p_{1} \\mid n$ and $p_{2} \\mid n$.\n\nA certificate $y$ for $n \\in L$ must allow a deterministic verifier $V(n,y)$ to check in time polynomial in $\\log_{2}(n)$ that $n$ indeed has at least two distinct prime factors. We evaluate each proposal both for soundness (it must never accept $n \\notin L$) and completeness (for every $n \\in L$, some such certificate exists), and we ensure that the verification work is polynomial in the bit-length of $n$.\n\nPreliminaries about efficient checks:\n- Divisibility checks “$a \\mid b$”, equality checks, and computing $\\gcd(a,b)$ via the Euclidean algorithm all run in time polynomial in the bit-lengths of the inputs, hence polynomial in $\\log_{2}(n)$.\n- Primality of a claimed prime can be verified deterministically in polynomial time in the bit-length (e.g., AKS primality test). Thus, checking that an integer is prime is feasible within the verifier’s time bound.\n- The certificate size must be polynomial in $\\log_{2}(n)$; all integers provided as factors or primes are at most $n$, hence their encodings are $O(\\log_{2}(n))$ bits.\n\nOption A: Two integers $u,v$ with $u>1$, $v>1$, and $n=uv$.\n- Verification: Check $u>1$, $v>1$, and $uv=n$. This is polynomial time.\n- Soundness: This fails. Consider $n$ a prime power, e.g., $n=2^{3}$. Taking $u=2$, $v=2^{2}$ satisfies $u>1$, $v>1$, and $uv=n$, yet $n \\notin L$. Hence there exist $n \\notin L$ with a certificate that would be accepted. Therefore A is not sound and is invalid.\n\nOption B: A single integer $d$ with $1dn$ and $d \\mid n$.\n- Verification: Check $1dn$ and $d \\mid n$. This is polynomial time.\n- Soundness: This fails for the same reason as A. If $n$ is a prime power, e.g., $n=2^{3}$, then $d=2$ is a valid divisor with $1dn$, yet $n \\notin L$. Therefore B is not sound and is invalid.\n\nOption C: Two integers $u,v$ with $u>1$, $v>1$, $n=uv$, and $\\gcd(u,v)=1$.\n- Verification: Check $u>1$, $v>1$, $uv=n$, and $\\gcd(u,v)=1$. All are polynomial time.\n- Soundness: Suppose the verifier accepts, i.e., $u>1$, $v>1$, $n=uv$, and $\\gcd(u,v)=1$. Since $u>1$ and $v>1$, each has at least one prime factor, say $p \\mid u$ and $q \\mid v$. The condition $\\gcd(u,v)=1$ implies $p \\neq q$. Because $p \\mid u$ and $u \\mid n$, we have $p \\mid n$, and similarly $q \\mid n$. Thus $n$ has at least two distinct prime divisors and hence $n \\in L$. Therefore soundness holds.\n- Completeness: If $n \\in L$, write $n=\\prod_{i=1}^{k} p_{i}^{\\alpha_{i}}$ with $k \\geq 2$ and distinct primes $p_{i}$. Choose any index $j$ and set $u=p_{j}^{\\alpha_{j}}$ and $v=n/u=\\prod_{i \\neq j} p_{i}^{\\alpha_{i}}$. Then $u>1$, $v>1$, $uv=n$, and $\\gcd(u,v)=1$ because they share no prime factor. Hence such a certificate exists. Therefore completeness holds. Thus C is valid.\n\nOption D: A prime $p$ with $p \\mid n$, and an integer $m1$ with $m \\mid n$ and $\\gcd(p,m)=1$.\n- Verification: Check that $p$ is prime, $p \\mid n$, $m1$, $m \\mid n$, and $\\gcd(p,m)=1$. All checks are polynomial time in $\\log_{2}(n)$ (primality via a polynomial-time primality test).\n- Soundness: If the verifier accepts, then $p \\mid n$ with $p$ prime, and $m \\mid n$ with $m1$ and $\\gcd(p,m)=1$. Since $m1$, $m$ has a prime divisor $q$. The condition $\\gcd(p,m)=1$ implies $q \\neq p$. Also, $q \\mid m$ and $m \\mid n$ imply $q \\mid n$. Thus $n$ has at least two distinct primes $p$ and $q$ dividing it, so $n \\in L$. Hence soundness holds.\n- Completeness: If $n \\in L$ has factorization $n=\\prod_{i=1}^{k} p_{i}^{\\alpha_{i}}$ with $k \\geq 2$, choose $p=p_{1}$ and $m=\\prod_{i=2}^{k} p_{i}^{\\alpha_{i}}$. Then $p \\mid n$, $m1$, $m \\mid n$, and $\\gcd(p,m)=1$. Therefore completeness holds. Thus D is valid.\n\nOption E: Two distinct primes $p_{1},p_{2}$ that both divide $n$.\n- Verification: Check $p_{1}$ is prime, $p_{2}$ is prime, $p_{1} \\neq p_{2}$, and $p_{1} \\mid n$, $p_{2} \\mid n$. All are polynomial time.\n- Soundness: If accepted, then $n$ has two distinct prime divisors $p_{1}$ and $p_{2}$, so $n \\in L$. Thus soundness holds.\n- Completeness: If $n \\in L$, by definition there exist two distinct primes dividing $n$. Providing them yields acceptance. Thus completeness holds. Therefore E is valid.\n\nConclusion: Options C, D, and E are valid certificates; A and B are invalid due to lack of soundness.", "answer": "$$\\boxed{CDE}$$", "id": "1436748"}, {"introduction": "Our final practice challenges you to apply these concepts to a more intricate problem. We will investigate the language `NONSEMIPRIME`, which includes any integer that is not a product of two *distinct* primes. By devising a certificate that confirms a number belongs to this complex set, you'll see how the certificate-verifier model can handle nuanced properties and solidify your understanding of how to construct proofs for membership in NP. [@problem_id:1436741]", "problem": "In computational complexity theory, a language $L$ is in the class NP (Nondeterministic Polynomial time) if there exists a polynomial-time deterministic verifier algorithm $V$ and a polynomial $p$ such that for any input string $x$:\n1.  If $x \\in L$, there exists a certificate string $c$ with a length at most $p(|x|)$, such that $V(x, c)$ accepts.\n2.  If $x \\notin L$, $V(x, c)$ rejects for all possible certificate strings $c$.\n\nLet's define the language `NONSEMIPRIME` over the set of integers greater than 1. An integer $n  1$ is a semiprime if it is the product of two distinct prime numbers. The language `NONSEMIPRIME` consists of all integers $n  1$ that are *not* semiprimes. An integer $n$ belongs to `NONSEMIPRIME` if it is prime, or a power of a single prime ($p^k$ for $k \\geq 2$), or a product of three or more prime factors (counted with multiplicity).\n\nA complete verifier for `NONSEMIPRIME` would need to handle several cases. Which of the following options describes a certificate $c$ and a corresponding verifier logic $V(n, c)$ that could serve as a valid component of such a system? A component is considered valid if its verification process is polynomial in $\\log(n)$ and an 'accept' result from the verifier guarantees that the integer $n$ is in `NONSEMIPRIME`.\n\nA. The certificate $c$ is a pair of integers $(p, q)$. The verifier checks that $p$ and $q$ are distinct prime numbers and that $n = p \\times q$.\n\nB. The certificate $c$ is a single integer $d$. The verifier checks that $d$ is a non-trivial factor of $n$ (i.e., $1  d  n$).\n\nC. The certificate $c$ is a pair of integers $(d, w)$. The verifier checks that $d$ is a non-trivial factor of $n$ (i.e., $1  d  n$), and $w$ is a non-trivial factor of $d$ (i.e., $1  w  d$).\n\nD. The certificate $c$ is an integer $a$ such that $1  a  n$. The verifier checks if $a^{n-1} \\equiv 1 \\pmod{n}$.", "solution": "We analyze each proposed certificate-verifier component to check two properties: (i) verification runs in time polynomial in the input size, which is $O(\\log n)$, and (ii) whenever the verifier accepts, it is guaranteed that $n$ is in NONSEMIPRIME (i.e., $n$ is not the product of two distinct primes).\n\nOption A: $c=(p,q)$, check both $p$ and $q$ are primes and $n=pq$ with $p \\neq q$.\n- Verification complexity: Checking primality of $p$ and $q$ can be done deterministically in polynomial time using a primality test; checking $pq=n$ is polynomial in $\\log n$. Thus verification is polynomial in $\\log n$.\n- Soundness for NONSEMIPRIME: If the verifier accepts, then $n=pq$ with distinct primes $p \\neq q$, so $n$ is a semiprime. Hence $n \\notin \\text{NONSEMIPRIME}$. Therefore acceptance does not guarantee membership in NONSEMIPRIME. Option A is invalid.\n\nOption B: $c=d$, check $1dn$ and $d \\mid n$.\n- Verification complexity: Checking $1dn$ and $d \\mid n$ is polynomial in $\\log n$ via integer division.\n- Soundness for NONSEMIPRIME: If $n$ is semiprime $n=pq$ with distinct primes, then taking $d=p$ yields $1dn$ and $d \\mid n$, so the verifier accepts a semiprime. Therefore acceptance does not guarantee $n \\in \\text{NONSEMIPRIME}$. Option B is invalid.\n\nOption C: $c=(d,w)$, check $1dn$, $d \\mid n$, and $1wd$, $w \\mid d$.\n- Verification complexity: All checks are integer comparisons and divisibility tests, which are polynomial in $\\log n$.\n- Soundness for NONSEMIPRIME: If the verifier accepts, then there exist integers $w,d$ with $1wdn$, $w \\mid d$ and $d \\mid n$. This implies $d$ is a composite proper divisor of $n$. If $n$ were a semiprime $n=pq$ with $p \\neq q$ primes, its only proper divisors larger than $1$ are $p$ and $q$, both prime. Thus a composite proper divisor cannot exist for a semiprime. Therefore acceptance implies $n \\notin \\{pq: p,q \\text{ distinct primes}\\}$, i.e., acceptance implies $n \\in \\text{NONSEMIPRIME}$. Option C is valid as a component.\n\nOption D: $c=a$, check $1an$ and $a^{n-1} \\equiv 1 \\pmod{n}$.\n- Verification complexity: Modular exponentiation can be performed in polynomial time in $\\log n$.\n- Soundness for NONSEMIPRIME: There exist composite numbers $n$ of the form $pq$ with distinct primes (semiprimes) that are pseudoprimes to a base $a$, satisfying $a^{n-1} \\equiv 1 \\pmod{n}$. For example, $n=341=11 \\cdot 31$ and $a=2$ satisfy $2^{340} \\equiv 1 \\pmod{341}$. Hence the verifier may accept a semiprime, so acceptance does not guarantee $n \\in \\text{NONSEMIPRIME}$. Option D is invalid.\n\nTherefore, among the options, only Option C is a valid component: its acceptance guarantees that $n$ is in NONSEMIPRIME, and its verification runs in time polynomial in $\\log n$.", "answer": "$$\\boxed{C}$$", "id": "1436741"}]}