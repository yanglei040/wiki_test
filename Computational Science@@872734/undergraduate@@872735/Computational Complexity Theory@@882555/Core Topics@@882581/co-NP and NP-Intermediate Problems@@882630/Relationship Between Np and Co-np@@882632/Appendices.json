{"hands_on_practices": [{"introduction": "This exercise introduces a powerful thought experiment in computational complexity: the oracle. By imagining we have a machine that can instantly solve the `SAT` problem, we can explore its relationship to other difficult problems. This practice will guide you in using a solver for an $NP$-complete problem to efficiently tackle a $co\\text{-}NP$-complete problem, revealing the elegant symmetry and fundamental connection between these two classes through logical negation.", "problem": "In the field of computational complexity theory, a hypothetical machine called an oracle can solve a specific decision problem in a single computational step. Imagine you have access to an oracle for the `Boolean Satisfiability Problem` (`SAT`). This oracle takes any Boolean formula as input and instantly returns one of two outputs: \"SATISFIABLE\" if there exists at least one assignment of truth values to the variables that makes the formula true, or \"UNSATISFIABLE\" otherwise.\n\nYour task is to use this `SAT` oracle to solve an instance of the `TAUTOLOGY` problem. A Boolean formula is a tautology if it evaluates to true for *all* possible assignments of truth values to its variables.\n\nGiven an arbitrary Boolean formula $\\psi$ over a set of variables $\\{x_1, x_2, \\ldots, x_n\\}$, which of the following procedures correctly determines whether $\\psi$ is a tautology?\n\nA. Construct the formula $\\phi = \\psi$. Feed $\\phi$ to the `SAT` oracle. Conclude that $\\psi$ is a tautology if and only if the oracle reports \"SATISFIABLE\".\n\nB. Construct the formula $\\phi = \\psi$. Feed $\\phi$ to the `SAT` oracle. Conclude that $\\psi$ is a tautology if and only if the oracle reports \"UNSATISFIABLE\".\n\nC. Construct the formula $\\phi = \\neg\\psi$. Feed $\\phi$ to the `SAT` oracle. Conclude that $\\psi$ is a tautology if and only if the oracle reports \"SATISFIABLE\".\n\nD. Construct the formula $\\phi = \\neg\\psi$. Feed $\\phi$ to the `SAT` oracle. Conclude that $\\psi$ is a tautology if and only if the oracle reports \"UNSATISFIABLE\".\n\nE. The `TAUTOLOGY` problem cannot be solved using a `SAT` oracle because `TAUTOLOGY` is a co-NP-complete problem, whereas `SAT` is an NP-complete problem.", "solution": "The goal is to determine if a given Boolean formula $\\psi$ is a tautology by using an oracle for the Boolean Satisfiability Problem (`SAT`).\n\nBy definition, a formula $\\psi$ is a tautology if it is true for *all* possible truth assignments to its variables.\n\nLet's consider the negation of this statement. The formula $\\psi$ is *not* a tautology if there exists *at least one* truth assignment for which $\\psi$ is false.\n\nIf there is a truth assignment that makes $\\psi$ false, then by the definition of logical negation, that same truth assignment must make the formula $\\neg\\psi$ true.\n\nConversely, if there is a truth assignment that makes $\\neg\\psi$ true, then that same assignment must make $\\psi$ false. This would mean that $\\psi$ is not true for all assignments, and therefore is not a tautology.\n\nSo, we have established a crucial logical equivalence:\nThe formula $\\psi$ is *not* a tautology $\\iff$ there exists at least one assignment that makes $\\neg\\psi$ true.\n\nThe statement \"there exists at least one assignment that makes $\\neg\\psi$ true\" is precisely the definition of the formula $\\neg\\psi$ being satisfiable. The `SAT` oracle is designed to answer this exact question. If we provide the formula $\\neg\\psi$ to the `SAT` oracle, it will return \"SATISFIABLE\" if such an assignment exists.\n\nThus, we can update our equivalence:\nThe formula $\\psi$ is *not* a tautology $\\iff$ the formula $\\neg\\psi$ is satisfiable.\n\nThe problem, however, asks for the condition under which $\\psi$ *is* a tautology. We can find this by negating both sides of the equivalence above. The negation of \"$\\psi$ is not a tautology\" is \"$\\psi$ is a tautology\". The negation of \"$\\neg\\psi$ is satisfiable\" is \"$\\neg\\psi$ is not satisfiable\" (or \"$\\neg\\psi$ is unsatisfiable\").\n\nThis gives us the final, decisive equivalence:\nThe formula $\\psi$ *is* a tautology $\\iff$ the formula $\\neg\\psi$ is unsatisfiable.\n\nTherefore, the correct procedure is:\n1.  Take the input formula $\\psi$.\n2.  Construct a new formula $\\phi$ which is the negation of the input formula, i.e., $\\phi = \\neg\\psi$.\n3.  Feed this new formula $\\phi$ into the `SAT` oracle.\n4.  If the oracle returns \"UNSATISFIABLE\", we can conclude that $\\psi$ is a tautology. If it returns \"SATISFIABLE\", we conclude that $\\psi$ is not a tautology.\n\nThis procedure matches option D.\n\nLet's analyze why the other options are incorrect:\n- Option A: Testing if $\\psi$ is satisfiable only tells us that $\\psi$ is not a contradiction. A formula can be satisfiable without being a tautology (e.g., $\\psi = x_1$).\n- Option B: Testing if $\\psi$ is unsatisfiable is a test for whether $\\psi$ is a contradiction (i.e., false for all assignments), which is the opposite of a tautology.\n- Option C: This inverts the conclusion. If $\\neg\\psi$ is satisfiable, it means $\\psi$ is *not* a tautology.\n- Option E: This is a common misconception. The existence of an oracle for an NP-complete problem like `SAT` allows for the efficient solution of all problems in the complexity class NP, as well as all problems in the class co-NP. Since `TAUTOLOGY` is the canonical co-NP-complete problem, it can indeed be solved using a `SAT` oracle. The described procedure is an example of a polynomial-time reduction from a co-NP problem to an NP problem, given an oracle.", "answer": "$$\\boxed{D}$$", "id": "1444878"}, {"introduction": "Building on the relationship between $NP$ and $co\\text{-}NP$, this problem delves into one of the most significant open questions in computer science: does $NP$ equal $co\\text{-}NP$? We'll explore a hypothetical breakthrough where `TAUTOLOGY`, a canonical $co\\text{-}NP$-complete problem, is found to have a polynomial-time verifier for its 'yes' instances. This thought experiment demonstrates how the status of a single, crucial problem can have profound implications, potentially causing entire complexity classes to collapse into one another [@problem_id:1444859].", "problem": "In computational complexity theory, decision problems are categorized into classes based on the resources required to solve them. Two fundamental classes are NP and co-NP.\n\n- The class **NP (Nondeterministic Polynomial time)** consists of all decision problems for which a 'yes' instance can be verified in polynomial time by a deterministic Turing machine, given a suitable certificate or proof.\n- The class **co-NP** consists of all decision problems whose complements are in NP. Equivalently, a problem is in co-NP if a 'no' instance has a certificate that can be verified in polynomial time.\n\nConsider the **TAUTOLOGY** problem: given a Boolean logic formula, is the formula true for every possible assignment of truth values to its variables? For example, the formula $A \\lor \\neg A$ is a tautology.\n\nIt is a well-established result that `TAUTOLOGY` is in co-NP. Now, consider a hypothetical scenario where a computer scientist proves that `TAUTOLOGY` is also in NP. Which of the following would be the most direct and significant consequence for the relationship between these complexity classes?\n\nA. P = NP\n\nB. NP = co-NP\n\nC. `SAT` (the Boolean Satisfiability problem) would be proven to be in P.\n\nD. The complexity class `PSPACE` would collapse to NP.\n\nE. P â‰  NP", "solution": "We recall the standard definitions and reductions. The class co-NP is the set of complements of languages in NP, and the complement operation satisfies $A \\in \\text{NP} \\iff \\bar{A} \\in \\text{co-NP}$ and $A \\in \\text{co-NP} \\iff \\bar{A} \\in \\text{NP}$. The language `TAUTOLOGY` (set of tautological Boolean formulas) is a well-known co-NP-complete problem under polynomial-time many-one reductions. Formally, for every $L \\in \\text{co-NP}$, there exists a polynomial-time computable function $f$ such that\n$$\nx \\in L \\iff f(x) \\in \\text{TAUTOLOGY}.\n$$\nAssume hypothetically that `TAUTOLOGY` is in NP. Then for any $L \\in \\text{co-NP}$ with $L \\leq_{m}^{p} \\text{TAUTOLOGY}$, since NP is closed under polynomial-time many-one reductions, we obtain\n$$\nL \\in \\text{NP}.\n$$\nThus,\n$$\n\\text{co-NP} \\subseteq \\text{NP}.\n$$\nNext, use complements. Since `TAUTOLOGY` is in NP, its complement, $\\overline{\\text{TAUTOLOGY}}$, is in co-NP. Moreover, because `TAUTOLOGY` is co-NP-complete, its complement $\\overline{\\text{TAUTOLOGY}}$ is NP-complete. Indeed, for any $L \\in \\text{NP}$, we have $\\bar{L} \\in \\text{co-NP}$ and hence a polynomial-time reduction $f$ with\n$$\nx \\in \\bar{L} \\iff f(x) \\in \\text{TAUTOLOGY} \\quad \\Longrightarrow \\quad x \\in L \\iff f(x) \\in \\overline{\\text{TAUTOLOGY}},\n$$\nso $L \\leq_{m}^{p} \\overline{\\text{TAUTOLOGY}}$. Since $\\overline{\\text{TAUTOLOGY}}$ is in co-NP and co-NP is closed under polynomial-time many-one reductions, it follows that for any $L \\in \\text{NP}$,\n$$\nL \\in \\text{co-NP}.\n$$\nTherefore,\n$$\n\\text{NP} \\subseteq \\text{co-NP}.\n$$\nCombining the two inclusions yields\n$$\n\\text{NP} = \\text{co-NP}.\n$$\nThis is the most direct and significant consequence. None of the other listed collapses (such as $P=NP$ or `PSPACE` collapsing to NP) is implied by this hypothesis alone. Hence the correct choice is B.", "answer": "$$\\boxed{B}$$", "id": "1444859"}, {"introduction": "Now, let's apply our understanding to a practical classification task. This problem presents a decision problem, `UNAMBIGUOUS-SPEC`, derived from a need in digital system design and asks you to determine its computational complexity. To solve this, you will need to analyze the problem's complement, identify the nature of its certificate, and construct a formal reduction, thereby putting the core concepts of $NP$, $co\\text{-}NP$, and completeness into practice [@problem_id:1444899].", "problem": "In the design of fault-tolerant digital systems, a common practice is to model the system's state using a set of Boolean variables. The system's behavior is constrained by a logical formula, $\\phi$, over these variables. A state is considered 'valid' if the corresponding assignment of truth values to the variables satisfies the formula $\\phi$. For certain critical applications, such as cryptographic key generation or arbitration logic, it is essential to guarantee that the system does not suffer from ambiguity. A system specification is defined as 'unambiguous' if there is at most one valid state (i.e., at most one satisfying assignment for the formula $\\phi$).\n\nConsider the decision problem `UNAMBIGUOUS-SPEC`, which takes a Boolean formula $\\phi$ as input and decides whether the specification it represents is unambiguous. Based on standard assumptions in computational complexity theory (such as $P \\neq NP$), characterize the complexity of the language corresponding to this problem.\n\nWhich of the following statements most accurately describes the complexity class of `UNAMBIGUOUS-SPEC`?\n\nA. `UNAMBIGUOUS-SPEC` is in P.\n\nB. `UNAMBIGUOUS-SPEC` is in NP, but is not believed to be in P or NP-complete.\n\nC. `UNAMBIGUOUS-SPEC` is NP-complete.\n\nD. `UNAMBIGUOUS-SPEC` is co-NP-complete.\n\nE. `UNAMBIGUOUS-SPEC` is in co-NP, but is not believed to be co-NP-complete.\n\nF. `UNAMBIGUOUS-SPEC` is believed to reside outside of the union of NP and co-NP.", "solution": "The problem asks us to determine the complexity class of the language `UNAMBIGUOUS-SPEC`. Let us formally define this language and analyze its properties.\n\nA Boolean formula $\\phi$ is in the language `UNAMBIGUOUS-SPEC` if and only if $\\phi$ has zero or one satisfying assignment. Our goal is to locate this language within the hierarchy of complexity classes. To do this, we will analyze its complement language.\n\nLet's define the complement language, which we will call `AMBIGUOUS-SPEC`. A formula $\\phi$ is in `AMBIGUOUS-SPEC` if and only if it is not in `UNAMBIGUOUS-SPEC`. This means `AMBIGUOUS-SPEC` contains all Boolean formulas that have at least two satisfying assignments.\n\nFirst, we will show that `AMBIGUOUS-SPEC` is in the class NP (Nondeterministic Polynomial Time). A language is in NP if, for any 'yes' instance, there exists a certificate that can be verified in polynomial time by a deterministic Turing machine.\nFor an instance $\\phi$ of `AMBIGUOUS-SPEC`, a 'yes' answer means that $\\phi$ has at least two satisfying assignments. A suitable certificate would be a pair of distinct assignments, say $a_1$ and $a_2$. A polynomial-time verifier can check the validity of this certificate by performing the following steps:\n1. Verify that $a_1$ is a satisfying assignment for $\\phi$. This involves substituting the truth values from $a_1$ into $\\phi$ and evaluating the expression, which can be done in time polynomial in the length of $\\phi$.\n2. Verify that $a_2$ is a satisfying assignment for $\\phi$. This is also a polynomial-time check.\n3. Verify that $a_1 \\neq a_2$. This involves a simple comparison of the two assignments, which can be done in time linear in the number of variables.\nSince all three checks can be performed in polynomial time, and the certificate (two assignments) is polynomial in size relative to the input formula, we can conclude that `AMBIGUOUS-SPEC` is in NP.\n\nNext, we will show that `AMBIGUOUS-SPEC` is NP-hard. To do this, we reduce a known NP-complete problem to `AMBIGUOUS-SPEC`. The canonical NP-complete problem is the Boolean Satisfiability Problem, or `SAT`.\nThe `SAT` problem is: Given a Boolean formula $\\psi$, is it satisfiable? (i.e., does it have at least one satisfying assignment?).\nWe need to construct a polynomial-time mapping (a reduction) $f$ that transforms any instance $\\psi$ of `SAT` into an instance $\\phi = f(\\psi)$ of `AMBIGUOUS-SPEC` such that $\\psi \\in \\text{SAT} \\iff \\phi \\in \\text{AMBIGUOUS-SPEC}$.\n\nLet $\\psi(x_1, x_2, \\dots, x_n)$ be a Boolean formula on $n$ variables. We construct a new formula $\\phi$ by introducing a new variable, $y$, that does not appear in $\\psi$. Let the new formula be:\n$$ \\phi(x_1, \\dots, x_n, y) = \\psi(x_1, \\dots, x_n) \\land (y \\lor \\neg y) $$\nThe construction of $\\phi$ from $\\psi$ is clearly achievable in polynomial time. Now we must prove that the reduction is correct.\n\nCase 1: Assume $\\psi \\in \\text{SAT}$.\nThis means there is at least one satisfying assignment for $\\psi$. Let this assignment for the variables $(x_1, \\dots, x_n)$ be $a$. We now consider assignments for the new formula $\\phi$. The variables of $\\phi$ are $(x_1, \\dots, x_n, y)$.\nConsider the assignment $a_1 = (a, y=\\text{true})$. For this assignment, $\\psi(a)$ evaluates to true, and $(y \\lor \\neg y)$ evaluates to true, so their conjunction $\\phi(a_1)$ is true.\nConsider the assignment $a_2 = (a, y=\\text{false})$. For this assignment, $\\psi(a)$ evaluates to true, and $(y \\lor \\neg y)$ also evaluates to true, so their conjunction $\\phi(a_2)$ is true.\nThe assignments $a_1$ and $a_2$ are distinct because they differ in the value of $y$. Therefore, if $\\psi$ is satisfiable, $\\phi$ has at least two satisfying assignments. This implies $\\phi \\in \\text{AMBIGUOUS-SPEC}$.\n\nCase 2: Assume $\\psi \\notin \\text{SAT}$.\nThis means $\\psi$ is unsatisfiable. For any assignment to the variables $(x_1, \\dots, x_n)$, $\\psi$ evaluates to false. Since $\\phi = \\psi \\land \\text{True}$, $\\phi$ will also evaluate to false for any assignment to its variables. Thus, $\\phi$ is unsatisfiable and has zero satisfying assignments. This implies $\\phi \\notin \\text{AMBIGUOUS-SPEC}$.\n\nFrom both cases, we have shown that $\\psi \\in \\text{SAT}$ if and only if $\\phi \\in \\text{AMBIGUOUS-SPEC}$. This constitutes a valid polynomial-time reduction from `SAT` to `AMBIGUOUS-SPEC`. Since `SAT` is NP-complete, this proves that `AMBIGUOUS-SPEC` is NP-hard.\n\nCombining our two findings: `AMBIGUOUS-SPEC` is in NP and is NP-hard. Therefore, `AMBIGUOUS-SPEC` is NP-complete.\n\nThe original problem asks for the complexity of `UNAMBIGUOUS-SPEC`, which is the complement of `AMBIGUOUS-SPEC`. By definition, the complement of an NP-complete language is co-NP-complete. The class co-NP consists of languages whose complements are in NP. A language is co-NP-complete if it is in co-NP and all other problems in co-NP can be reduced to it in polynomial time. Since `AMBIGUOUS-SPEC` is NP-complete, its complement `UNAMBIGUOUS-SPEC` is co-NP-complete.\n\nThis corresponds to option D.", "answer": "$$\\boxed{D}$$", "id": "1444899"}]}