{"hands_on_practices": [{"introduction": "Before diving into complex algorithms, it is crucial to understand why simpler, more intuitive approaches might fall short. This first exercise challenges you to analyze a common greedy strategy: always picking the item with the highest value. By working through a small, concrete example [@problem_id:1449258], you will discover a scenario where this seemingly logical approach fails to produce the optimal result, highlighting the subtle nature of the 0-1 knapsack problem and motivating the need for more rigorous methods.", "problem": "A data scientist is tasked with selecting a batch of computational jobs to run on a server with a limited amount of available Random Access Memory (RAM). The server has an available capacity of 10 GB of RAM. There are three pending jobs, each with a specific RAM requirement and an associated priority value, which represents its importance. The goal is to choose a subset of these jobs to run simultaneously such that their total RAM requirement does not exceed the server's capacity and the sum of the priority values of the chosen jobs is maximized.\n\nThe three jobs are:\n- Job 1: Priority Value = 10, RAM Requirement = 10 GB\n- Job 2: Priority Value = 6, RAM Requirement = 5 GB\n- Job 3: Priority Value = 6, RAM Requirement = 5 GB\n\nConsider a simple greedy strategy for job selection: always select the available job with the highest priority value first, and continue this process until no more jobs can be added without exceeding the RAM capacity.\n\nLet $V_{greedy}$ be the total priority value obtained by applying this \"highest-priority-first\" greedy strategy.\nLet $V_{optimal}$ be the maximum possible total priority value that can be achieved with any valid combination of jobs.\n\nWhich of the following options represents the correct ordered pair $(V_{greedy}, V_{optimal})$?\n\nA. (10, 10)\n\nB. (10, 12)\n\nC. (12, 10)\n\nD. (12, 12)\n\nE. (6, 12)", "solution": "We model the selection as a 0-1 knapsack problem. Let the capacity be $C=10$ and the jobs be items with values and weights $(v_{1},w_{1})=(10,10)$, $(v_{2},w_{2})=(6,5)$, and $(v_{3},w_{3})=(6,5)$. The goal is to choose a subset $S$ to maximize\n$$\n\\sum_{i \\in S} v_{i}\n$$\nsubject to the constraint\n$$\n\\sum_{i \\in S} w_{i} \\leq C.\n$$\n\n**Greedy Strategy (highest priority value first):**\nThe jobs are sorted by priority value $v_i$ in non-increasing order. The order is Job 1, then Job 2 and Job 3 (in any order).\n- Start with capacity $C=10$.\n- Consider Job 1 ($v_1=10, w_1=10$): Its weight $w_1=10$ is less than or equal to the current capacity $C=10$, so we include it. The remaining capacity becomes $C \\leftarrow C - w_1 = 10 - 10 = 0$.\n- Consider Job 2 and Job 3: Their weights $w_2=w_3=5$ are both greater than the remaining capacity of 0, so neither can be added.\nThe set selected by the greedy strategy is $\\{1\\}$, with a total value of:\n$$\nV_{\\text{greedy}} = 10.\n$$\n\n**Optimal Solution:**\nWe enumerate all feasible subsets of jobs and find the one with the maximum total value.\n- $S=\\varnothing$: Total weight $0 \\leq 10$, Total value $0$.\n- $S=\\{1\\}$: Total weight $10 \\leq 10$, Total value $10$.\n- $S=\\{2\\}$: Total weight $5 \\leq 10$, Total value $6$.\n- $S=\\{3\\}$: Total weight $5 \\leq 10$, Total value $6$.\n- $S=\\{2,3\\}$: Total weight $5+5=10 \\leq 10$, Total value $6+6=12$.\n- $S=\\{1,2\\}$: Total weight $10+5=15 > 10$ (infeasible).\n- $S=\\{1,3\\}$: Total weight $10+5=15 > 10$ (infeasible).\n- $S=\\{1,2,3\\}$: Total weight $10+5+5=20 > 10$ (infeasible).\nThe maximum feasible total value is:\n$$\nV_{\\text{optimal}}=12,\n$$\nachieved by selecting the set of jobs $\\{2,3\\}$.\n\nTherefore, the ordered pair is $(V_{\\text{greedy}}, V_{\\text{optimal}})=(10,12)$, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1449258"}, {"introduction": "Having seen that simple greedy choices can be suboptimal, we now turn to a guaranteed method for finding the true optimal solution: dynamic programming. This practice problem focuses on a memory-efficient implementation that is crucial for resource-constrained environments. You will trace the step-by-step updates to a one-dimensional array [@problem_id:1449277], gaining a concrete understanding of how the algorithm builds up the optimal solution for every possible capacity from a space complexity of $O(nW)$ to $O(W)$.", "problem": "An engineer is developing a resource allocation algorithm for a microcontroller with extremely limited memory. The algorithm must solve a variant of the \"knapsack problem\". Given a set of tasks, each with a specific memory \"weight\" and a \"value\" representing its priority, the goal is to select a subset of tasks that maximizes the total priority value without exceeding the microcontroller's total memory capacity.\n\nTo conserve memory, the engineer's algorithm uses only a single one-dimensional array, let's call it `V_max`, of size `W+1`, where `W` is the total memory capacity. The array is first initialized with all elements set to zero. The algorithm then processes each task one by one. For a given task `i` with weight `w_i` and value `v_i`, the algorithm updates the `V_max` array according to the following rule: for each integer capacity `j` from `W` down to `w_i` (inclusive), the element `V_max[j]` is updated to be the maximum of its current value and the value `V_max[j - w_i] + v_i`.\n\nSuppose the total memory capacity is `W = 7`. The available tasks are given in the following table:\n\n| Task ID | Weight `w` | Value `v` |\n|:-------:|:----------:|:---------:|\n|    1    |     3      |     5     |\n|    2    |     5      |     9     |\n|    3    |     2      |     3     |\n\nThe algorithm will first process Task 1, then Task 2, and finally Task 3. Your goal is to determine the state of the `V_max` array after the algorithm has finished processing **only the first two tasks** (Task 1 and Task 2). The array `V_max` has indices from 0 to 7.\n\nPresent your answer as a row matrix containing the integer values of the elements `V_max[0]` through `V_max[7]`.", "solution": "We solve a 0-1 knapsack using a single array $V_{\\max}[0..W]$ with $W=7$. The update rule for each task with weight $w_{i}$ and value $v_{i}$ is\n$$\nV_{\\max}[j] \\leftarrow \\max\\!\\big(V_{\\max}[j],\\, V_{\\max}[j-w_{i}] + v_{i}\\big)\\quad\\text{for } j=W,W-1,\\ldots,w_{i}.\n$$\n**Initialization:**\nThe array $V_{\\max}$ is initialized to all zeros for indices $j=0,1,\\ldots,7$:\n$$\n\\begin{pmatrix}\n0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\n\\end{pmatrix}\n$$\n\n**Process Task 1 (weight $w_1=3$, value $v_1=5$):**\nWe update the array for $j$ from 7 down to 3.\n- For $j=7$: $V_{\\max}[7]=\\max(V_{\\max}[7], V_{\\max}[4]+5)=\\max(0, 0+5)=5$.\n- For $j=6$: $V_{\\max}[6]=\\max(V_{\\max}[6], V_{\\max}[3]+5)=\\max(0, 0+5)=5$.\n- For $j=5$: $V_{\\max}[5]=\\max(V_{\\max}[5], V_{\\max}[2]+5)=\\max(0, 0+5)=5$.\n- For $j=4$: $V_{\\max}[4]=\\max(V_{\\max}[4], V_{\\max}[1]+5)=\\max(0, 0+5)=5$.\n- For $j=3$: $V_{\\max}[3]=\\max(V_{\\max}[3], V_{\\max}[0]+5)=\\max(0, 0+5)=5$.\nIndices $j=0,1,2$ remain zero. After Task 1, the array is:\n$$\n\\begin{pmatrix}\n0 & 0 & 0 & 5 & 5 & 5 & 5 & 5\n\\end{pmatrix}\n$$\n\n**Process Task 2 (weight $w_2=5$, value $v_2=9$):**\nWe update the array for $j$ from 7 down to 5, using the values from the previous step.\n- For $j=7$: $V_{\\max}[7]=\\max(V_{\\max}[7], V_{\\max}[2]+9)=\\max(5, 0+9)=9$.\n- For $j=6$: $V_{\\max}[6]=\\max(V_{\\max}[6], V_{\\max}[1]+9)=\\max(5, 0+9)=9$.\n- For $j=5$: $V_{\\max}[5]=\\max(V_{\\max}[5], V_{\\max}[0]+9)=\\max(5, 0+9)=9$.\nThe entries for $j=0,1,2,3,4$ are unaffected in this pass, so they remain $0,0,0,5,5$ respectively. Therefore, after processing the first two tasks, the final state of the array is:\n$$\n\\begin{pmatrix}\n0 & 0 & 0 & 5 & 5 & 9 & 9 & 9\n\\end{pmatrix}\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0 & 0 & 0 & 5 & 5 & 9 & 9 & 9\\end{pmatrix}}$$", "id": "1449277"}, {"introduction": "Dynamic programming is not the only exact method for solving the 0-1 knapsack problem; another powerful technique is branch and bound. This approach intelligently explores the tree of all possible solutions, using an 'upper bound' to prune branches that cannot lead to a better result than one already found. In this exercise [@problem_id:1449298], you will simulate the algorithm, using the solution to the fractional knapsack problem as your guide to efficiently search for the best combination of items.", "problem": "A data scientist is selecting features for a machine learning model. The goal is to maximize the model's predictive power, measured by a total \"impact score,\" without exceeding a \"computational budget.\" Each feature has an associated impact score and a computational cost required to process it. This selection problem can be modeled as a 0-1 knapsack problem.\n\nThe available features, pre-sorted in descending order of their impact-to-cost ratio, are:\n- Feature 1: Impact = 40, Cost = 2\n- Feature 2: Impact = 30, Cost = 5\n- Feature 3: Impact = 50, Cost = 10\n- Feature 4: Impact = 10, Cost = 5\n\nThe total computational budget (knapsack capacity) is 16.\n\nYou are to solve this problem using a branch-and-bound algorithm with the following specifications:\n- The algorithm performs a **best-first search**, always expanding the live node with the highest upper bound.\n- The state-space is a binary tree where nodes represent decisions for each feature. The tree is built by considering features in the order they are listed (Feature 1, then Feature 2, etc.).\n- The upper bound for any node is calculated as the sum of the impact scores of features already included on the path to the node, plus the value obtained by solving the **fractional knapsack problem** for the remaining features and the remaining computational budget.\n- A node is pruned if its upper bound is less than or equal to the total impact score of the best complete solution found so far.\n\nWhat is the maximum total impact score that can be achieved under the given computational budget?", "solution": "Let the features be items indexed by $i \\in \\{1,2,3,4\\}$ with impact (value) $v_i$ and cost (weight) $c_i$. The capacity is $W=16$. The items are pre-sorted by decreasing value/cost ratio:\n- Item 1: $v_1=40, c_1=2, r_1=20$\n- Item 2: $v_2=30, c_2=5, r_2=6$\n- Item 3: $v_3=50, c_3=10, r_3=5$\n- Item 4: $v_4=10, c_4=5, r_4=2$\n\nWe use a best-first branch-and-bound search. We maintain a priority queue of live nodes, ordered by their upper bound (UB), and a variable `best_so_far` initialized to 0.\n\n**1. Root Node:**\n- **Path:** Empty. Current value $V=0$, cost $C=0$. Remaining capacity $R=16$.\n- **Upper Bound (UB):** We solve the fractional knapsack on all items with capacity 16.\n  - Take Item 1 (cost 2, value 40). $R=14$.\n  - Take Item 2 (cost 5, value 30). $R=9$.\n  - Take $9/10$ of Item 3 (cost 9, value $50 \\times 0.9 = 45$). $R=0$.\n  - UB = $40 + 30 + 45 = 115$.\n- **Action:** Add Root Node (UB=115) to the priority queue.\n\n**2. Expand Root Node (UB=115):** We branch on Item 1.\n- **Node A (Include Item 1):** $V=40, C=2, R=14$.\n  - UB = $40 +$ fractional value of Items 2,3,4 with capacity 14.\n  - UB = $40 + (30 + 50 \\times 9/10) = 40 + 75 = 115$.\n- **Node B (Exclude Item 1):** $V=0, C=0, R=16$.\n  - UB = $0 +$ fractional value of Items 2,3,4 with capacity 16.\n  - UB = $30 + 50 + (10 \\times 1/5) = 82$.\n- **Action:** Add Node A (UB=115) and Node B (UB=82) to the queue.\n\n**3. Expand Node A (UB=115):** Branch on Item 2.\n- **Node C (Include 1, Include 2):** $V=70, C=7, R=9$.\n  - UB = $70 +$ fractional value of Items 3,4 with capacity 9.\n  - UB = $70 + (50 \\times 9/10) = 70 + 45 = 115$.\n- **Node D (Include 1, Exclude 2):** $V=40, C=2, R=14$.\n  - UB = $40 +$ fractional value of Items 3,4 with capacity 14.\n  - UB = $40 + (50 + 10 \\times 4/5) = 40 + 58 = 98$.\n- **Action:** Add Node C (UB=115) and Node D (UB=98) to the queue. Queue: {C(115), D(98), B(82)}.\n\n**4. Expand Node C (UB=115):** Branch on Item 3.\n- **Path: (Include 1, Include 2, Include 3):** $V=120, C=17$. Cost > 16, so this path is infeasible. Prune.\n- **Node E (Include 1, Include 2, Exclude 3):** $V=70, C=7, R=9$.\n  - UB = $70 +$ fractional value of Item 4 with capacity 9.\n  - UB = $70 + 10 = 80$.\n- **Action:** Add Node E (UB=80) to queue. Queue: {D(98), B(82), E(80)}.\n\n**5. Expand Node D (UB=98):** Branch on Item 3.\n- **Node F (Include 1, Exclude 2, Include 3):** $V=90, C=12, R=4$.\n  - UB = $90 +$ fractional value of Item 4 with capacity 4.\n  - UB = $90 + (10 \\times 4/5) = 98$.\n- **Node G (Include 1, Exclude 2, Exclude 3):** $V=40, C=2, R=14$.\n  - UB = $40 +$ fractional value of Item 4 with capacity 14.\n  - UB = $40 + 10 = 50$.\n- **Action:** Add Node F (UB=98) and G (UB=50) to queue. Queue: {F(98), B(82), E(80), G(50)}.\n\n**6. Expand Node F (UB=98):** Branch on Item 4.\n- **Path: (Include 1, Exclude 2, Include 3, Include 4):** $V=100, C=17$. Infeasible. Prune.\n- **Path: (Include 1, Exclude 2, Include 3, Exclude 4):** This is a complete, feasible solution (a leaf node).\n  - **Value:** 90. **Cost:** 12.\n  - **Action:** Update `best_so_far = 90`.\n- **Action:** Queue is now {B(82), E(80), G(50)}.\n\n**7. Pruning Step:** Now that `best_so_far = 90`, we check the queue. Any node with UB = 90 can be pruned.\n- Node B has UB=82. $82 \\leq 90$. Prune.\n- Node E has UB=80. $80 \\leq 90$. Prune.\n- Node G has UB=50. $50 \\leq 90$. Prune.\n\nThe priority queue is now empty. The algorithm terminates.\n\nThe maximum total impact score found is 90 (from including Features 1 and 3).", "answer": "$$\\boxed{90}$$", "id": "1449298"}]}