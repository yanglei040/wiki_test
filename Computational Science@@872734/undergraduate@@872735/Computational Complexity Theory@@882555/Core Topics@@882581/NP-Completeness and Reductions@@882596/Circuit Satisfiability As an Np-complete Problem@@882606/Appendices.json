{"hands_on_practices": [{"introduction": "Before exploring the abstract power of circuit satisfiability, it is crucial to have a hands-on feel for how a circuit's logic translates to a final output. This first practice problem takes you through a concrete example of a digital circuit built from NAND gates. By tracing the inputs through the layers of logic, you will directly engage with the fundamental task of determining whether a specific condition—in this case, a non-triggering state—is possible, which is the very essence of a satisfiability question.", "problem": "A high-security facility uses a simple alarm system based on a digital logic circuit. The system has three sensor inputs, denoted as $x_1$, $x_2$, and $x_3$. Each input can be in one of two states: inactive (represented by 0) or active (represented by 1). The alarm is designed to trigger if the final output of the circuit, $F$, is 1.\n\nThe circuit is constructed exclusively from two-input NAND gates. A NAND gate outputs 0 if and only if both of its inputs are 1; otherwise, it outputs 1. The connections are as follows:\n- Gate G1 takes inputs $x_1$ and $x_2$.\n- Gate G2 takes inputs $x_2$ and $x_3$.\n- Gate G3 takes inputs $x_1$ and $x_3$.\n- Gate G4 takes the outputs of G1 and G2 as its inputs.\n- Gate G5 takes the outputs of G2 and G3 as its inputs.\n- The final output gate, F, takes the outputs of G4 and G5 as its inputs.\n\nYour task is to determine if there exists any combination of sensor inputs that will *not* trigger the alarm. Which of the following statements is correct?\n\nA. No, the alarm is guaranteed to trigger for any combination of sensor inputs.\n\nB. Yes, a non-triggering combination is $(x_1, x_2, x_3) = (1, 0, 1)$.\n\nC. Yes, a non-triggering combination is $(x_1, x_2, x_3) = (0, 1, 1)$.\n\nD. Yes, a non-triggering combination is $(x_1, x_2, x_3) = (1, 1, 0)$.\n\nE. Yes, a non-triggering combination is $(x_1, x_2, x_3) = (0, 0, 0)$.", "solution": "Let the NAND operation be defined by $a \\uparrow b = \\lnot(a \\land b)$. Denote the outputs of the gates as follows:\n- $y_{1} = \\lnot(x_{1} \\land x_{2})$\n- $y_{2} = \\lnot(x_{2} \\land x_{3})$\n- $y_{3} = \\lnot(x_{1} \\land x_{3})$\n- $y_{4} = \\lnot(y_{1} \\land y_{2})$\n- $y_{5} = \\lnot(y_{2} \\land y_{3})$\n- $F = \\lnot(y_{4} \\land y_{5})$.\n\nUse De Morgan’s laws to simplify step by step.\n\nFirst, compute $y_{4}$ and $y_{5}$:\n$$\ny_{4} = \\lnot(y_{1} \\land y_{2}) = \\lnot y_{1} \\lor \\lnot y_{2}.\n$$\nSince $y_{1} = \\lnot(x_{1} \\land x_{2})$, we have $\\lnot y_{1} = x_{1} \\land x_{2}$. Similarly, $\\lnot y_{2} = x_{2} \\land x_{3}$. Thus\n$$\ny_{4} = (x_{1} \\land x_{2}) \\lor (x_{2} \\land x_{3}) = x_{2} \\land (x_{1} \\lor x_{3}).\n$$\nAnalogously,\n$$\ny_{5} = \\lnot(y_{2} \\land y_{3}) = \\lnot y_{2} \\lor \\lnot y_{3} = (x_{2} \\land x_{3}) \\lor (x_{1} \\land x_{3}) = x_{3} \\land (x_{1} \\lor x_{2}).\n$$\n\nNext, compute $y_{4} \\land y_{5}$:\n$$\ny_{4} \\land y_{5} = \\bigl[x_{2} \\land (x_{1} \\lor x_{3})\\bigr] \\land \\bigl[x_{3} \\land (x_{1} \\lor x_{2})\\bigr] = x_{2} \\land x_{3} \\land \\bigl[(x_{1} \\lor x_{3})(x_{1} \\lor x_{2})\\bigr].\n$$\nUse the distributive identity $(a \\lor b)(a \\lor c) = a \\lor (b \\land c)$ with $a=x_{1}$, $b=x_{3}$, $c=x_{2}$ to get\n$$\n(x_{1} \\lor x_{3})(x_{1} \\lor x_{2}) = x_{1} \\lor (x_{3} \\land x_{2}) = x_{1} \\lor (x_{2} \\land x_{3}).\n$$\nTherefore,\n$$\ny_{4} \\land y_{5} = x_{2} \\land x_{3} \\land \\bigl[x_{1} \\lor (x_{2} \\land x_{3})\\bigr].\n$$\nApply the absorption law $p \\land (q \\lor p) = p$ with $p = x_{2} \\land x_{3}$ and $q = x_{1}$:\n$$\ny_{4} \\land y_{5} = x_{2} \\land x_{3}.\n$$\nHence the final output is\n$$\nF = \\lnot(y_{4} \\land y_{5}) = \\lnot(x_{2} \\land x_{3}).\n$$\n\nThus, $F=0$ (alarm does not trigger) if and only if $x_{2}=1$ and $x_{3}=1$, independent of $x_{1}$. Among the given options, the combination $(x_{1},x_{2},x_{3})=(0,1,1)$ satisfies this condition. Therefore, the correct statement is option C.", "answer": "$$\\boxed{C}$$", "id": "1415026"}, {"introduction": "The true power of an NP-complete problem like CIRCUIT-SAT lies in its ability to model a vast array of other complex problems. This exercise demonstrates this by framing a strategic question from game theory as a satisfiability problem. By learning how to \"hardwire\" known information into a circuit, you will see how we can reduce the question of a player's winning strategy to finding a satisfying assignment for a new, specialized circuit.", "problem": "In computational complexity theory, many problems can be modeled as games. Consider a two-player, perfect-information game defined by a known Boolean circuit $C$. Player 1 provides an $n$-bit input string $x = (x_1, x_2, \\dots, x_n)$, and Player 2 provides an $m$-bit input string $y = (y_1, y_2, \\dots, y_m)$. The circuit $C$ takes these $n+m$ bits as input. The game's outcome is determined by the circuit's single-bit output: if $C(x, y) = 1$, Player 2 wins; if $C(x, y) = 0$, Player 1 wins.\n\nSuppose Player 1 makes a publicly known, fixed opening move $x_0$. We want to determine if Player 2 has a winning response, i.e., if there exists at least one move $y$ for Player 2 such that $C(x_0, y) = 1$. This determination can be made by solving a single instance of the Circuit Satisfiability (CIRCUIT-SAT) problem. The CIRCUIT-SAT problem asks whether there exists an input assignment to a given Boolean circuit that makes the output 1.\n\nYour task is to identify the correct construction of a new circuit, $C'$, from the original circuit $C$ and the fixed move $x_0$, such that $C'$ is satisfiable if and only if Player 2 has a winning response to $x_0$. The inputs of $C'$ should be the variables over which we are searching for a satisfying assignment. Which of the following describes the correct construction for $C'$?\n\nA. Construct $C'$ with $n+m$ inputs, corresponding to $x$ and $y$. Create $n$ new sub-circuits, where the $i$-th sub-circuit computes the logical XOR of an input bit $x_i$ and the constant bit $x_{0,i}$. The outputs of these $n$ sub-circuits are fed into a single large NOR gate. The final output of $C'$ is the logical AND of the original circuit's output, $C(x, y)$, and the output of this NOR gate.\n\nB. Construct $C'$ with $n$ inputs, corresponding to $x$. This circuit is formed by taking the original circuit $C$ and permanently setting the $m$ input lines for $y$ to a fixed, arbitrary string (e.g., all zeros). The satisfiability of $C'$ is then determined over its $n$ inputs.\n\nC. Construct $C'$ with $m$ inputs, corresponding to $y$. This circuit is formed by taking the original circuit $C$, connecting its output to a NOT gate, and using the output of the NOT gate as the output of $C'$. The first $n$ inputs of the original circuit $C$ (for $x$) are hardwired to the constant bit values of $x_0$.\n\nD. Construct $C'$ with $m$ inputs, corresponding to $y$. This circuit is the original circuit $C$ where its first $n$ input lines (for $x$) are not variable inputs but are instead hardwired to the constant bit values of the move $x_0$. Specifically, for each $i \\in \\{1, \\dots, n\\}$, the $i$-th input line is connected to a constant `TRUE` source if $x_{0,i}=1$ and a constant `FALSE` source if $x_{0,i}=0$.\n\nE. Construct $C'$ with $m$ inputs, corresponding to $y$. The circuit is built by taking $n$ copies of $C$. For the $i$-th copy, the input $x_i$ is connected to a `TRUE` source if $x_{0,i}=1$ and a `FALSE` source if $x_{0,i}=0$, while all other $x_j$ (for $j \\neq i$) and all $y_k$ are left as inputs. The outputs of all $n$ copies are then fed into a large OR gate, which produces the final output of $C'$.", "solution": "We formalize the target decision as follows. The game specifies a fixed opening move $x_{0} \\in \\{0,1\\}^{n}$. The question “Does Player 2 have a winning response?” is exactly the predicate\n$$\n\\exists\\, y \\in \\{0,1\\}^{m}:\\; C(x_{0},y)=1.\n$$\nA CIRCUIT-SAT instance consists of a circuit $C'$ over a set of input variables $Z$ and asks whether\n$$\n\\exists\\, z \\in \\{0,1\\}^{|Z|}:\\; C'(z)=1.\n$$\nThe problem additionally requires that the inputs of $C'$ be exactly the variables over which we are searching for a satisfying assignment. Since $x$ is fixed to $x_{0}$, the only variables we must quantify over are the $m$ bits of $y$. Therefore $C'$ must have exactly the $m$ inputs corresponding to $y$, with the $x$-inputs hardwired to constants encoding $x_{0}$.\n\nEvaluate each option:\n\n- Option D: Construct $C'$ with $m$ inputs $y$ and hardwire the first $n$ inputs of $C$ to $x_{0}$. Then for every $y$,\n$$\nC'(y)=C(x_{0},y),\n$$\nso\n$$\n\\exists\\, y:\\; C'(y)=1 \\iff \\exists\\, y:\\; C(x_{0},y)=1,\n$$\nwhich is exactly the required condition, and the inputs of $C'$ are exactly the variables we are searching over. This satisfies the stated requirement.\n\n- Option A: Define\n$$\nC'(x,y)=C(x,y)\\wedge \\bigwedge_{i=1}^{n}\\neg(x_{i}\\oplus x_{0,i}),\n$$\nso $C'(x,y)=1$ iff $x=x_{0}$ and $C(x,y)=1$. Then\n$$\n\\exists\\, x,y:\\; C'(x,y)=1 \\iff \\exists\\, y:\\; C(x_{0},y)=1.\n$$\nWhile logically equivalent to the target predicate, $C'$ exposes $x$ as inputs, thus quantifies over $x$ as well. This violates the requirement that the inputs be exactly the variables we are searching over (only $y$).\n\n- Option B: With $C'$ taking $x$ as inputs and $y$ fixed to an arbitrary constant $s$, satisfiability checks\n$$\n\\exists\\, x:\\; C(x,s)=1,\n$$\nwhich is unrelated to $\\exists\\, y:\\; C(x_{0},y)=1$ in general. Incorrect.\n\n- Option C: With $x$ hardwired to $x_{0}$ but output negated,\n$$\nC'(y)=\\neg C(x_{0},y),\n$$\nso\n$$\n\\exists\\, y:\\; C'(y)=1 \\iff \\exists\\, y:\\; C(x_{0},y)=0,\n$$\nwhich is the opposite of the desired predicate. Incorrect.\n\n- Option E: Builds $n$ copies of $C$ with only one $x_{i}$ fixed per copy and ORs the outputs. This yields\n$$\n\\exists\\, y,\\; \\text{and for some } i,\\; \\exists\\, (x_{j})_{j\\neq i}:\\; C(x,y)=1 \\text{ with } x_{i}=x_{0,i},\n$$\nwhich does not enforce $x=x_{0}$ and is not equivalent to $\\exists\\, y:\\; C(x_{0},y)=1$. Incorrect.\n\nThus, the correct construction that both preserves the target predicate and obeys the requirement on the input variables is Option D.", "answer": "$$\\boxed{D}$$", "id": "1415023"}, {"introduction": "Solving CIRCUIT-SAT tells us if *at least one* solution exists, but often we need more information, such as whether a solution is unique. This thought experiment introduces the concept of an \"oracle\"—a hypothetical black box that can solve any CIRCUIT-SAT instance instantly. Your challenge is to devise a strategy that leverages this powerful tool, using just two queries, to answer a more nuanced question: does the circuit have *exactly one* satisfying assignment? This illustrates a key idea in complexity theory: how to use a solver for one problem to solve other, related problems.", "problem": "An electrical engineer, Alice, is tasked with verifying the behavior of complex digital logic circuits. A given circuit, which we can denote as $C$, has $n$ binary inputs, represented by the vector $\\mathbf{x} = (x_1, x_2, \\dots, x_n)$, and a single binary output. A \"satisfying assignment\" for the circuit $C$ is an input vector $\\mathbf{a}$ for which the circuit's output is 1, i.e., $C(\\mathbf{a}) = 1$.\n\nAlice has access to a powerful piece of testing equipment called an Oracle for Circuit Satisfiability (OCS). The OCS is a black-box device that solves the circuit satisfiability problem: given any Boolean circuit, the OCS instantly returns TRUE if there exists at least one satisfying assignment, and FALSE otherwise.\n\nAlice's specific task is to determine if a circuit $C$ has *exactly one* unique satisfying assignment. She wants to accomplish this using her OCS. She realizes she can construct new circuits based on $C$ and use the OCS to test them. Her plan is to use at most two calls to the OCS. In her design, she uses two distinct sets of $n$ input variables, $\\mathbf{x} = (x_1, \\dots, x_n)$ and $\\mathbf{y} = (y_1, \\dots, y_n)$. Let $C(\\mathbf{x})$ denote the original circuit with inputs $\\mathbf{x}$, and $C(\\mathbf{y})$ denote an identical copy of the circuit with inputs $\\mathbf{y}$. The expression $(\\mathbf{x} \\neq \\mathbf{y})$ denotes a sub-circuit that outputs 1 if and only if the input vectors $\\mathbf{x}$ and $\\mathbf{y}$ are not identical; it is equivalent to the logical expression $\\bigvee_{i=1}^n (x_i \\oplus y_i)$, where $\\oplus$ is the XOR operation.\n\nAlice devises several potential strategies. Which of the following procedures correctly determines if the circuit $C$ has exactly one satisfying assignment using at most two calls to the OCS?\n\nA. First, call the OCS on a circuit $C_1 = C(\\mathbf{x})$. If the result is FALSE, $C$ is not uniquely satisfiable. If the result is TRUE, construct a second circuit $C_2$ on inputs $(\\mathbf{x}, \\mathbf{y})$ that computes $C(\\mathbf{x}) \\lor C(\\mathbf{y})$. Call the OCS on $C_2$. $C$ has a unique satisfying assignment if and only if the OCS returns TRUE for $C_2$.\n\nB. First, call the OCS on a circuit $C_1 = C(\\mathbf{x})$. If the result is FALSE, $C$ is not uniquely satisfiable. If the result is TRUE, construct a second circuit $C_2$ on inputs $(\\mathbf{x}, \\mathbf{y})$ that computes $C(\\mathbf{x}) \\land C(\\mathbf{y}) \\land (\\mathbf{x} \\neq \\mathbf{y})$. Call the OCS on $C_2$. $C$ has a unique satisfying assignment if and only if the OCS returns TRUE for $C_2$.\n\nC. First, call the OCS on a circuit $C_1 = C(\\mathbf{x})$. If the result is FALSE, $C$ is not uniquely satisfiable. If the result is TRUE, construct a second circuit $C_2$ on inputs $(\\mathbf{x}, \\mathbf{y})$ that computes $C(\\mathbf{x}) \\land C(\\mathbf{y}) \\land (\\mathbf{x} \\neq \\mathbf{y})$. Call the OCS on $C_2$. $C$ has a unique satisfying assignment if and only if the OCS returns FALSE for $C_2$.\n\nD. First, call the OCS on a circuit $C_1 = C(\\mathbf{x})$. If the result is FALSE, $C$ is not uniquely satisfiable. If the result is TRUE, construct a second circuit $C_2$ on inputs $(\\mathbf{x}, \\mathbf{y})$ that computes $C(\\mathbf{x}) \\land \\neg C(\\mathbf{y})$. Call the OCS on $C_2$. $C$ has a unique satisfying assignment if and only if the OCS returns TRUE for $C_2$.\n\nE. It is impossible to determine if a circuit has a unique satisfying assignment with only two calls to an OCS. A fundamentally different type of oracle would be required.", "solution": "Define the satisfying set of the circuit $C$ as\n$$S \\equiv \\{\\mathbf{a} \\in \\{0,1\\}^{n} : C(\\mathbf{a}) = 1\\}.$$\nThe circuit $C$ is uniquely satisfiable if and only if $|S| = 1$.\n\nThe Oracle for Circuit Satisfiability (OCS) returns TRUE on an input circuit if and only if that circuit has at least one satisfying assignment. We analyze each proposed procedure in terms of $|S|$.\n\nCommon first call (in all A–D): Call OCS on $C(\\mathbf{x})$. This returns TRUE if and only if $|S| \\geq 1$. If it returns FALSE, then $|S| = 0$ and $C$ is not uniquely satisfiable. Hence, only the branch where the first call returns TRUE (i.e., $|S| \\geq 1$) needs further analysis.\n\nOption A:\n- Second circuit: $C_{2}(\\mathbf{x}, \\mathbf{y}) \\equiv C(\\mathbf{x}) \\lor C(\\mathbf{y})$.\n- This is satisfiable if and only if there exist $\\mathbf{x}, \\mathbf{y}$ with $C(\\mathbf{x}) = 1$ or $C(\\mathbf{y}) = 1$.\n- If $|S| \\geq 1$, choose $\\mathbf{x} \\in S$; then $C_{2}$ is satisfiable regardless of $\\mathbf{y}$. Therefore, OCS on $C_{2}$ returns TRUE for all $|S| \\geq 1$.\n- The procedure claims uniqueness if and only if OCS on $C_{2}$ is TRUE, but that is always TRUE when $|S| \\geq 1$, so it does not distinguish $|S| = 1$ from $|S| \\geq 2$. Hence A is incorrect.\n\nOption B:\n- Second circuit: $C_{2}(\\mathbf{x}, \\mathbf{y}) \\equiv C(\\mathbf{x}) \\land C(\\mathbf{y}) \\land (\\mathbf{x} \\neq \\mathbf{y})$.\n- This is satisfiable if and only if there exist distinct $\\mathbf{x}, \\mathbf{y} \\in S$, i.e., if and only if $|S| \\geq 2$.\n- The procedure claims uniqueness if and only if OCS on $C_{2}$ is TRUE, i.e., it equates $|S| = 1$ with $|S| \\geq 2$, which is inverted. Hence B is incorrect.\n\nOption C:\n- Same second circuit as in B: $C_{2}(\\mathbf{x}, \\mathbf{y}) \\equiv C(\\mathbf{x}) \\land C(\\mathbf{y}) \\land (\\mathbf{x} \\neq \\mathbf{y})$.\n- As above, OCS on $C_{2}$ returns TRUE if and only if $|S| \\geq 2$, and returns FALSE if and only if $|S| \\leq 1$.\n- Combining with the first call (which ensured $|S| \\geq 1$), we have:\n  - First call TRUE and second call FALSE if and only if $|S| = 1$.\n- Therefore, this procedure correctly determines uniqueness with at most two calls. Hence C is correct.\n\nOption D:\n- Second circuit: $C_{2}(\\mathbf{x}, \\mathbf{y}) \\equiv C(\\mathbf{x}) \\land \\neg C(\\mathbf{y})$.\n- This is satisfiable if and only if there exist $\\mathbf{x} \\in S$ and $\\mathbf{y} \\notin S$, i.e., if and only if $1 \\leq |S| \\leq 2^{n} - 1$.\n- For any satisfiable non-tautological $C$ (i.e., $1 \\leq |S| \\leq 2^{n} - 1$), OCS on $C_{2}$ returns TRUE, regardless of whether $|S| = 1$ or $|S| \\geq 2$. If $C$ is a tautology ($|S| = 2^{n}$), OCS on $C_{2}$ returns FALSE, but $C$ is not uniquely satisfiable in that case. Thus this test does not characterize $|S| = 1$. Hence D is incorrect.\n\nOption E:\n- Since option C provides a valid two-call procedure to decide whether $|S| = 1$, it is not impossible. Hence E is incorrect.\n\nTherefore, the only correct procedure is C.", "answer": "$$\\boxed{C}$$", "id": "1415013"}]}