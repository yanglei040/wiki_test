{"hands_on_practices": [{"introduction": "A key feature of a Turing reduction is that the machine performing the reduction must be a decider—it is guaranteed to halt and give a definitive yes or no answer. This exercise [@problem_id:1468144] explores a direct and powerful consequence of this guarantee. You will demonstrate that if a language $A$ can be decided with an oracle for a language $B$, then the complement of $A$, denoted $\\overline{A}$, is also decidable with the same oracle, illustrating a fundamental symmetry of Turing reducibility.", "problem": "In the study of computational complexity, we often analyze the relationship between different decision problems using the concept of reducibility. Let $A$ and $B$ be two languages, which are sets of strings over a common alphabet $\\Sigma$. The complement of a language $A$, denoted $\\overline{A}$, is the set of all strings in $\\Sigma^*$ that are not in $A$.\n\nA language $A$ is said to be Turing-reducible to a language $B$, denoted $A \\le_T B$, if there exists an Oracle Turing Machine (OTM) that decides language $A$ by using an oracle for language $B$. A \"decider\" is a Turing machine that is guaranteed to halt on all inputs, always concluding in either an 'accept' or 'reject' state. The oracle for $B$ can be thought of as a black box that can instantaneously answer whether any given string $q$ is a member of the language $B$.\n\nSuppose you are given an OTM, which we will call $M_A$, that is a decider for language $A$ and uses an oracle for language $B$. This means that for any input string $w$:\n- If $w \\in A$, $M_A$ halts and accepts.\n- If $w \\notin A$, $M_A$ halts and rejects.\n\nYour task is to determine how to construct a new OTM, which we will call $M_{\\overline{A}}$, that decides the complement language $\\overline{A}$ using the same oracle for language $B$. Which of the following statements provides a correct and complete description of the behavior of such a machine $M_{\\overline{A}}$ for any given input string $w$?\n\nA. On input $w$, $M_{\\overline{A}}$ simulates $M_A$ on $w$. If the simulation of $M_A$ halts and accepts, then $M_{\\overline{A}}$ halts and rejects. If the simulation of $M_A$ halts and rejects, then $M_{\\overline{A}}$ halts and accepts.\n\nB. On input $w$, $M_{\\overline{A}}$ simulates $M_A$ on $w$. However, whenever the simulated $M_A$ makes an oracle query for a string $q$ to its oracle for $B$, the new machine $M_{\\overline{A}}$ first uses a separate subroutine to decide if $q \\in \\overline{B}$ and provides the opposite answer to the simulation. This requires an oracle for $\\overline{B}$.\n\nC. On input $w$, $M_{\\overline{A}}$ simulates $M_A$ on $w$. If $M_A$ would enter its accept state, $M_{\\overline{A}}$ enters its reject state. If $M_A$ would enter its reject state, $M_{\\overline{A}}$ enters its accept state. If $M_A$ were to loop infinitely on input $w$, $M_{\\overline{A}}$ would also loop infinitely.\n\nD. It is not possible to construct an oracle Turing machine $M_{\\overline{A}}$ that decides $\\overline{A}$ using only an oracle for $B$. The necessary information is not available.\n\nE. On input $w$, $M_{\\overline{A}}$ runs the simulation of $M_A$ on $w$. $M_{\\overline{A}}$ then accepts if the simulation of $M_A$ accepted, and rejects if the simulation of $M_A$ rejected, effectively copying the behavior of $M_A$.", "solution": "We are given an oracle Turing machine $M_{A}$ that decides $A$ using an oracle for $B$. By definition of a decider, for every input $w \\in \\Sigma^{*}$, the machine $M_{A}$ halts and accepts if $w \\in A$, and halts and rejects if $w \\notin A$.\n\nTo construct an oracle Turing machine $M_{\\overline{A}}$ that decides $\\overline{A}$ using the same oracle for $B$, proceed as follows on input $w$:\n- Simulate $M_{A}$ on input $w$, forwarding each oracle query $q$ exactly to the oracle for $B$ and using the oracle’s answer to continue the simulation. This uses only the oracle for $B$.\n- When the simulated $M_{A}$ halts, invert its decision: if it accepts, then reject; if it rejects, then accept.\n\nProof of correctness:\n- If $w \\in \\overline{A}$, then $w \\notin A$. Since $M_{A}$ decides $A$, it halts and rejects on $w$. Therefore, $M_{\\overline{A}}$ flips this to accept, so $M_{\\overline{A}}$ accepts exactly those $w \\in \\overline{A}$.\n- If $w \\notin \\overline{A}$, then $w \\in A$. Since $M_{A}$ decides $A$, it halts and accepts on $w$. Therefore, $M_{\\overline{A}}$ flips this to reject, so $M_{\\overline{A}}$ rejects exactly those $w \\notin \\overline{A}$.\n- Termination: Because $M_{A}$ halts on all inputs, the simulation halts on all inputs, and the inversion step also halts. Thus $M_{\\overline{A}}$ is a decider.\n\nAmong the options, this behavior is precisely described by option A. Option B incorrectly requires an oracle for $\\overline{B}$. Option C introduces an unnecessary and potentially misleading clause about infinite loops; while vacuously true under the given assumption that $M_{A}$ is a decider, it is not the clean characterization of a decider construction. Option D is false, and option E is incorrect since it does not invert the decision.", "answer": "$$\\boxed{A}$$", "id": "1468144"}, {"introduction": "Computational problems often come in two flavors: decision problems that ask \"Does a solution exist?\" and search problems that ask \"Find one such solution.\" This practice [@problem_id:1468109] introduces a powerful algorithmic pattern where an oracle for a decision problem is used repeatedly to construct an answer to the corresponding search problem. By stepping through a concrete scheduling task, you will see how yes/no answers can be leveraged to build a complete, optimal solution piece by piece.", "problem": "In the field of computational complexity theory, a common technique is to use a subroutine that solves a decision problem (a \"yes/no\" question) to help solve a related search problem (a \"find an example\" question). This problem explores such a scenario.\n\nImagine you are a program manager at a funding agency. You have a list of grant proposals, each with a required start week and end week. Your task is to select the largest possible set of grants to fund, with the constraint that you, as the sole reviewer, cannot review two grants whose time intervals overlap.\n\nYou have access to a powerful, pre-existing computational subroutine called `HAS_SCHEDULE_OF_SIZE_K`. This subroutine takes two arguments: a set of grants `G` and an integer `k`. It returns `True` if there exists a conflict-free subset of `G` with size at least `k`, and `False` otherwise. Two grants conflict if their time intervals overlap. A time interval is defined as `[start_week, end_week)`, meaning it includes the start week but excludes the end week.\n\nYour goal is to use this `HAS_SCHEDULE_OF_SIZE_K` subroutine to find one specific, maximum-sized, conflict-free set of grants. You must use the following deterministic algorithm:\n\n1.  First, determine the maximum possible size, $k_{max}$, of a conflict-free schedule for the entire original set of grants, $T$.\n2.  Initialize an empty schedule, $S = \\emptyset$, and a set of candidate grants, $U = T$.\n3.  Iterate through each grant $g$ in the original set $T$, considered in increasing order of their index.\n    a. Let's call the current grant being considered $g_{current}$. If $g_{current}$ is not in the current candidate set $U$, skip it.\n    b. To decide whether to add $g_{current}$ to your solution, you must determine if it's a \"safe\" choice. A choice is safe if, after choosing $g_{current}$, it's still possible to form a complete schedule of the target size. To test this, form a temporary set $U_{test}$ containing all grants in $U \\setminus \\{g_{current}\\}$ that do not conflict with $g_{current}$.\n    c. Query the oracle: `HAS_SCHEDULE_OF_SIZE_K(U_{test}, |S| + k_{max} - 1)`. Wait, this line seems overly complex. Let's simplify the logic.\n\nLet's restate the core logic for the construction phase (steps 2 and 3) more clearly:\n\n2.  Initialize the final schedule $S = \\emptyset$ and the set of available grants for consideration $U = T$.\n3.  Iterate through the grants $g_1, g_2, \\dots, g_n$ from the original set $T$ in order of their index. For each grant $g_i$:\n    a. Check if choosing $g_i$ is a \"safe move\". A move is safe if, after committing to $g_i$, we can still form a maximum-sized schedule. To test this, we see if a schedule of size ($k_{max} - |S| - 1$) can be formed from the remaining compatible grants. Specifically, define $U_{compatible} = \\{ g' \\in U \\setminus \\{g_i\\} \\mid g' \\text{ does not conflict with } g_i \\}$. Query the oracle: `HAS_SCHEDULE_OF_SIZE_K(`$U_{compatible}$, $k_{max} - |S| - 1$`)`.\n    b. If the oracle returns `True`, then $g_i$ is a safe choice. Add $g_i$ to your schedule $S$ and update the set of available grants $U$ to be only those compatible with your new choice, i.e., $U = U_{compatible}$.\n    c. If the oracle returns `False`, then picking $g_i$ was a dead end. Do not add it to $S$. Simply remove $g_i$ from the set of available grants $U$ and continue to the next grant.\n\nGiven the following set of six grants, $T$, which of the options below represents the final schedule $S$ that your algorithm will construct? The grants are identified by their index.\n\n-   $g_1$: (index=1, start=1, end=5)\n-   $g_2$: (index=2, start=0, end=3)\n-   $g_3$: (index=3, start=4, end=7)\n-   $g_4$: (index=4, start=6, end=9)\n-   $g_5$: (index=5, start=2, end=4)\n-   $g_6$: (index=6, start=8, end=10)\n\nChoose the option that lists the indices of the grants in the final schedule $S$.\n\nA. {1, 4}\nB. {3, 5, 6}\nC. {1, 4, 6}\nD. {2, 3, 6}", "solution": "We are given intervals (half-open) for six grants:\n$g_{1}=[1,5)$, $g_{2}=[0,3)$, $g_{3}=[4,7)$, $g_{4}=[6,9)$, $g_{5}=[2,4)$, $g_{6}=[8,10)$.\nTwo intervals $[a,b)$ and $[c,d)$ conflict if they overlap, i.e., if not ($b \\leq c$ or $d \\leq a)$.\n\nFirst, determine the maximum possible size $k_{\\max}$ of a conflict-free subset of $T=\\{g_{1},\\dots,g_{6}\\}$. The set $\\{g_{2},g_{3},g_{6}\\}$ is conflict-free because $[0,3)$ ends before $[4,7)$ starts, and $[4,7)$ ends before $[8,10)$ starts, so a conflict-free set of size $3$ exists. To upper bound, note that among $\\{g_{1},g_{2},g_{5}\\}$ at most one can be chosen (each pair overlaps), and among $\\{g_{3},g_{4}\\}$ at most one can be chosen (they overlap), while $g_{6}$ overlaps with $g_{4}$ but not with $g_{3}$. Hence the total size is at most $1+1+1=3$. Therefore,\n$$\nk_{\\max}=3.\n$$\n\nNow run the construction with $S=\\emptyset$ and $U=T$, iterating $g_{1}, g_{2}, \\dots, g_{6}$ in index order. At each step, for current $g_{i}\\in U$, define $U_{\\text{compatible}}=\\{g'\\in U\\setminus\\{g_{i}\\}: g'\\text{ does not conflict with }g_{i}\\}$ and query\n$$\n\\text{HAS\\_SCHEDULE\\_OF\\_SIZE\\_K}\\big(U_{\\text{compatible}},\\,k_{\\max}-|S|-1\\big).\n$$\n\nConsider $g_{1}=[1,5)$. Its compatible grants in $U\\setminus\\{g_{1}\\}$ are $g_{4}=[6,9)$ and $g_{6}=[8,10)$, so $U_{\\text{compatible}}=\\{g_{4},g_{6}\\}$. Query with $k_{\\max}-|S|-1=3-0-1=2$ asks if there is a conflict-free subset of size at least $2$ in $\\{g_{4},g_{6}\\}$. Since $g_{4}$ and $g_{6}$ overlap, the largest conflict-free subset has size $1  2$, so the oracle returns False. Therefore $g_{1}$ is not added; remove $g_{1}$ from $U$.\n\nConsider $g_{2}=[0,3)$. With $U$ now $T\\setminus\\{g_{1}\\}$, the grants compatible with $g_{2}$ are $g_{3}$, $g_{4}$, and $g_{6}$, so $U_{\\text{compatible}}=\\{g_{3},g_{4},g_{6}\\}$. Query with $k_{\\max}-|S|-1=3-0-1=2$. In $\\{g_{3},g_{4},g_{6}\\}$, the subset $\\{g_{3},g_{6}\\}$ is conflict-free of size $2$, so the oracle returns True. Hence $g_{2}$ is safe; add it to $S$ and set $U=\\{g_{3},g_{4},g_{6}\\}$.\n\nConsider $g_{3}=[4,7)$. In $U\\setminus\\{g_{3}\\}=\\{g_{4},g_{6}\\}$, only $g_{6}$ is compatible with $g_{3}$, so $U_{\\text{compatible}}=\\{g_{6}\\}$. Query with $k_{\\max}-|S|-1=3-1-1=1$. Since $\\{g_{6}\\}$ has a conflict-free subset of size $1$, the oracle returns True. Add $g_{3}$ to $S$ and set $U=\\{g_{6}\\}$.\n\nConsider $g_{4}$. It is not in $U$, so skip.\n\nConsider $g_{5}$. It is not in $U$, so skip.\n\nConsider $g_{6}=[8,10)$. Now $U\\setminus\\{g_{6}\\}=\\emptyset$, so $U_{\\text{compatible}}=\\emptyset$. Query with $k_{\\max}-|S|-1=3-2-1=0$. A subset of size at least $0$ always exists (the empty set), so the oracle returns True. Add $g_{6}$ to $S$ and set $U=\\emptyset$.\n\nThe algorithm terminates with $S=\\{g_{2},g_{3},g_{6}\\}$, which corresponds to option D.", "answer": "$$\\boxed{D}$$", "id": "1468109"}, {"introduction": "Turing reductions can forge surprising links between seemingly disparate computational tasks. This advanced practice [@problem_id:1468134] challenges you to use an oracle for a decision problem—Graph Isomorphism—to solve a more complex counting problem. You will devise an algorithm to determine the exact number of symmetries (automorphisms) in a given graph, demonstrating how carefully crafted queries to a simple yes/no oracle can be used to extract precise quantitative information.", "problem": "In the field of computational complexity theory, a Turing reduction allows a problem $A$ to be solved using a subroutine, or an \"oracle,\" that can solve a different problem $B$ in a single step. Consider the Graph Isomorphism ($GI$) problem, a famous decision problem in computer science. The $GI$ problem asks whether two given finite graphs are isomorphic.\n\nAn oracle for $GI$ is a hypothetical machine that takes as input two graphs, $G_1 = (V_1, E_1)$ and $G_2 = (V_2, E_2)$, and instantaneously returns TRUE if they are isomorphic, and FALSE otherwise.\n\nYou are a computer scientist tasked with a related, but different, computational problem: counting the number of automorphisms of a given graph. An automorphism of a graph $G = (V, E)$ is an isomorphism from $G$ to itself—that is, a permutation $\\pi$ of the vertex set $V$ such that any pair of vertices $\\{u, v\\}$ forms an edge in $E$ if and only if the pair $\\{\\pi(u), \\pi(v)\\}$ also forms an edge in $E$. The number of such automorphisms is denoted by $|\\text{Aut}(G)|$.\n\nYour goal is to devise an algorithm that uses the $GI$ oracle to compute $|\\text{Aut}(G)|$ for any given graph $G$ with $n$ vertices. What is the minimum number of calls to the $GI$ oracle that your algorithm must make in the worst-case scenario to determine $|\\text{Aut}(G)|$ for a graph with $n$ vertices?\n\nProvide your answer as a closed-form expression in terms of $n$.", "solution": "We want to compute the exact value of $|\\text{Aut}(G)|$ for a graph $G$ with $n$ vertices, using a Turing reduction to the Graph Isomorphism oracle. The key group-theoretic tool is the orbit-stabilizer method applied along a stabilizer chain formed by individualizing vertices.\n\nLet $G=(V,E)$ with $|V|=n$, and let $A_{0}=\\text{Aut}(G)$. Choose an ordered sequence of distinct vertices $v_{1},v_{2},\\dots,v_{t}$, and define the stabilizer chain\n$$\nA_{i}=\\{\\sigma\\in A_{i-1}:\\sigma(v_{i})=v_{i}\\}\\quad\\text{for }i=1,2,\\dots,t.\n$$\nBy the orbit-stabilizer theorem applied iteratively, we have\n$$\n|A_{0}|=\\prod_{i=1}^{t}[A_{i-1}:A_{i}],\n$$\nand each index satisfies\n$$\n[A_{i-1}:A_{i}]=|\\text{Orb}_{A_{i-1}}(v_{i})|,\n$$\nthe size of the orbit of $v_{i}$ under the current stabilizer $A_{i-1}$. If we take $t=n-1$, then $A_{n-1}$ fixes $n-1$ vertices and hence is trivial on the last vertex, so $[A_{n-1}:A_{n}]=1$ and the product over $i=1,\\dots,n-1$ already equals $|\\text{Aut}(G)|$.\n\nIt remains to show how to compute each $|\\text{Orb}_{A_{i-1}}(v_{i})|$ using the $GI$ oracle and to count the number of oracle calls required. For a fixed stage $i$, suppose $v_{1},\\dots,v_{i-1}$ have been individualized (i.e., constrained to be fixed). To test whether there exists $\\sigma\\in A_{i-1}$ that maps $v_{i}$ to a particular vertex $w$ among the remaining $n-i$ candidates, we query the $GI$ oracle on a pair of graphs obtained from $G$ by vertex-coloring: in the first, assign distinct colors to $v_{1},\\dots,v_{i-1}$ and a special color to $v_{i}$; in the second, assign the same distinct colors to $v_{1},\\dots,v_{i-1}$ and the special color to $w$. By standard gadget constructions, colored-graph isomorphism reduces to uncolored $GI$ with a constant overhead, so each such test uses one $GI$ oracle call. The oracle answers TRUE if and only if $w$ lies in the orbit of $v_{i}$ under $A_{i-1}$. Therefore\n$$\n|\\text{Orb}_{A_{i-1}}(v_{i})|=1+\\left|\\{w\\in V\\setminus\\{v_{1},\\dots,v_{i}\\}:\\text{$GI$ on $(G$ colored at $v_{i}), (G$ colored at $w)$ returns TRUE}\\}\\right|.\n$$\nDetermining this exactly by testing each of the $n-i$ candidates $w$ requires at most $n-i$ oracle calls at stage $i$. Summing over $i=1$ to $n-1$, the total number of $GI$ calls made is\n$$\n\\sum_{i=1}^{n-1}(n-i)=\\sum_{k=1}^{n-1}k=\\frac{n(n-1)}{2}.\n$$\nThis yields a correct algorithm with worst-case $GI$-query complexity $\\frac{n(n-1)}{2}$.\n\nTo see that this is optimal in the worst case, consider $G=K_{n}$ (or its complement), where $\\text{Aut}(G)\\cong S_{n}$. At stage $i$, the current stabilizer $A_{i-1}\\cong S_{n-i+1}$ acts transitively on the remaining $n-i+1$ vertices, making them completely indistinguishable under isomorphism constraints that fix $v_{1},\\dots,v_{i-1}$. Any $GI$ query that does not target a specific candidate $w$ among the remaining vertices can only reveal the existence of some image, not how many; thus to determine the exact orbit size $|\\text{Orb}_{A_{i-1}}(v_{i})|=n-i+1$, an algorithm must, in the worst case, test all $n-i$ candidates individually. Consequently, any $GI$-based procedure must make at least $\\sum_{i=1}^{n-1}(n-i)=\\frac{n(n-1)}{2}$ oracle calls in the worst case.\n\nTherefore, the minimum number of $GI$-oracle calls required in the worst-case scenario to determine $|\\text{Aut}(G)|$ for an $n$-vertex graph is exactly $\\frac{n(n-1)}{2}$.", "answer": "$$\\boxed{\\frac{n(n-1)}{2}}$$", "id": "1468134"}]}