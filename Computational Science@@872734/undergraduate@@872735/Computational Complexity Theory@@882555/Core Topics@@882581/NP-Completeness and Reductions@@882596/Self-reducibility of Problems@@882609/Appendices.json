{"hands_on_practices": [{"introduction": "Self-reducibility provides a powerful template for turning a decision oracle into a search algorithm. This practice demonstrates this principle on the classic CLIQUE problem, which is central to network analysis and graph theory. You will devise a two-stage algorithm that first uses an oracle to efficiently determine the size of the maximum clique, and then systematically identifies the vertices belonging to one such clique [@problem_id:1447183].", "problem": "An engineer is tasked with analyzing the structure of a complex communication network, which can be modeled as an undirected graph $G=(V, E)$, where $V$ is the set of $n$ communication nodes and $E$ is the set of $m$ direct links between them. The engineer needs to identify a \"core communication hub,\" which is defined as a maximum clique in the graph. A clique is a subset of vertices where every two distinct vertices are connected by an edge, and a maximum clique is a clique of the largest possible size in the graph.\n\nTo assist in this task, the engineer has access to a specialized hardware oracle. This oracle provides a single function, `HAS_CLIQUE`($G'$, $k'$), which takes a graph $G'$ and an integer $k'$ as input. It returns `true` if $G'$ contains a clique of size at least $k'$, and `false` otherwise. Each call to this oracle is considered a single computational step.\n\nYour task is to devise an algorithm that uses this oracle to find the set of vertices forming one maximum clique in the graph $G$. What is the maximum number of calls to the `HAS_CLIQUE` oracle that your algorithm would require for a graph with $n$ vertices? Express your answer as a closed-form analytic expression in terms of $n$.", "solution": "The problem asks for an algorithm to find a maximum clique in a graph $G$ using a decision oracle, and to determine the maximum number of oracle calls needed. The solution can be broken down into two main stages: first, determining the size of the maximum clique, and second, identifying the vertices that form such a clique.\n\n**Stage 1: Determine the size of the maximum clique ($k_{\\max}$)**\n\nThe core property we can exploit is the monotonic nature of the clique problem. If a graph contains a clique of size $k$, it must also contain cliques of all sizes smaller than $k$. This property makes the problem amenable to binary search. We can search for the largest integer $k$ in the range $[1, n]$ for which the oracle `HAS_CLIQUE`($G, k$) returns `true`.\n\nLet's define the binary search procedure:\n1. Initialize the search range: `low = 1`, `high = n`.\n2. Initialize a variable to store the size of the largest clique found so far: `$k_{\\max} = 0$`.\n3. While `low = high`:\n    a. Calculate the midpoint: `mid = floor((low + high) / 2)`.\n    b. Call the oracle: `result = HAS_CLIQUE(G, mid)`.\n    c. If `result` is `true`, it means a clique of size `mid` exists. This could be our maximum clique, or an even larger one might exist. So, we record this size, `$k_{\\max} = mid$`, and try to find a larger one by adjusting our search space to the upper half: `low = mid + 1`.\n    d. If `result` is `false`, a clique of size `mid` does not exist. Therefore, any clique larger than `mid` also cannot exist. We must search for a smaller clique in the lower half: `high = mid - 1`.\n\nAfter the binary search loop terminates, `$k_{\\max}$` will hold the size of the maximum clique in the graph $G$. A binary search on a range of size $n$ requires a number of queries equal to $\\lceil \\log_2(n) \\rceil$.\n\n**Stage 2: Identify the vertices of a maximum clique**\n\nNow that we know the size of the maximum clique is $k_{\\max}$, we can use a self-reducibility approach to find the specific vertices that form one such clique. The most efficient method is an elimination process.\n\nThe algorithm proceeds as follows:\n1. Initialize a candidate set of vertices, `V_cand`, to be the entire vertex set of the original graph, `V`.\n2. Iterate through each vertex $v$ in the original vertex set $V$, one by one. For each $v$:\n    a. Create a temporary graph, $G'$, which is the subgraph of $G$ induced by the vertices in `V_cand \\setminus \\{v\\}`.\n    b. Call the oracle: `result = HAS_CLIQUE`($G', k_{\\max}$).\n    c. If `result` is `true`, it means that even after removing $v$ from our current set of candidates, a clique of size $k_{\\max}$ still exists. This implies that $v$ is not essential, so we can permanently discard it from our candidate set by updating `V_cand` to `V_cand \\setminus \\{v\\}`.\n    d. If `result` is `false`, it means that $v$ is essential to form any $k_{\\max}$-clique within the current candidate set. Therefore, we must keep $v$, and we do not modify `V_cand`.\n\nThis process is repeated for all $n$ vertices of the original graph $G$. For each of the $n$ vertices, we make exactly one call to the oracle to decide whether to keep or discard it from the candidate pool. After iterating through all $n$ vertices, the final set `V_cand` will contain exactly $k_{\\max}$ vertices. These vertices form a maximum clique because we have systematically eliminated all vertices that are not strictly necessary to form a clique of size $k_{\\max}$. The number of oracle calls in this stage is exactly $n$.\n\n**Total Oracle Calls**\n\nThe total number of oracle calls is the sum of the calls from Stage 1 and Stage 2.\nTotal calls = (Calls for finding $k_{\\max}$) + (Calls for finding vertices)\nTotal calls = $\\lceil \\log_2(n) \\rceil + n$\n\nThus, the maximum number of oracle calls required by this algorithm is $n + \\lceil \\log_2(n) \\rceil$.", "answer": "$$\\boxed{n + \\lceil \\log_2(n) \\rceil}$$", "id": "1447183"}, {"introduction": "While standard self-reducibility for SAT can find *a* satisfying assignment, many applications require a solution with specific properties. This exercise explores how to refine the self-reduction process to find a *minimal* satisfying assignment—one where no variable assigned TRUE can be flipped to FALSE without violating satisfiability. By comparing different strategies, you will gain a deeper insight into how the step-by-step construction of a solution influences its final properties [@problem_id:1447155].", "problem": "In computational complexity theory, the Boolean Satisfiability Problem (SAT) is a foundational problem. Given a Boolean formula $\\phi$ in Conjunctive Normal Form (CNF) over a set of variables $\\{x_1, x_2, \\ldots, x_n\\}$, the problem is to determine if there exists an assignment of True or False values to the variables that makes the entire formula evaluate to True.\n\nImagine you have access to a hypothetical device called a SAT oracle. This oracle, represented by the function `is_sat(ψ)`, takes any Boolean formula `ψ` as input and instantly returns True if `ψ` is satisfiable, and False otherwise. While such an oracle can tell you *if* a satisfying assignment exists, it does not directly provide one.\n\nA well-known procedure called self-reducibility uses this oracle to find a satisfying assignment for a given satisfiable formula $\\phi$. However, a formula can have many satisfying assignments. We are interested in a specific type of assignment known as a *minimal satisfying assignment*. A satisfying assignment $A$ is defined as **minimal** if for any variable $x_i$ that is assigned True in $A$, flipping its value to False (while keeping all other variable assignments the same) results in an assignment that no longer satisfies $\\phi$.\n\nYou are tasked with identifying a correct and guaranteed algorithm that uses a SAT oracle to find one such minimal satisfying assignment for a given satisfiable formula $\\phi$. The algorithms under consideration build the assignment variable by variable, from $x_1$ to $x_n$. In the descriptions below, $\\psi$ represents a formula that is progressively built upon, starting with $\\psi = \\phi$. The final assignment is denoted by $A$.\n\nWhich of the following algorithms correctly and guarantees to find a minimal satisfying assignment for any satisfiable input formula $\\phi$?\n\nA. Initialize $\\psi = \\phi$.\nFor $i = 1, \\ldots, n$:\n    If `is_sat`($\\psi \\land x_i$) is True:\n        Set $A(x_i) = \\text{True}$ and update $\\psi \\leftarrow \\psi \\land x_i$.\n    Else:\n        Set $A(x_i) = \\text{False}$ and update $\\psi \\leftarrow \\psi \\land \\neg x_i$.\nReturn $A$.\n\nB. Initialize $\\psi = \\phi$.\nFor $i = 1, \\ldots, n$:\n    If `is_sat`($\\psi \\land \\neg x_i$) is True:\n        Set $A(x_i) = \\text{False}$ and update $\\psi \\leftarrow \\psi \\land \\neg x_i$.\n    Else:\n        Set $A(x_i) = \\text{True}$ and update $\\psi \\leftarrow \\psi \\land x_i$.\nReturn $A$.\n\nC. First, find an arbitrary satisfying assignment $A_0$ using the standard self-reducibility method (Algorithm A).\nInitialize $A = A_0$.\nFor $i = 1, \\ldots, n$:\n    If $A(x_i)$ is True:\n        Let $A'$ be the assignment identical to $A$ but with $x_i$ set to False.\n        If $A'$ satisfies $\\phi$:\n            Update $A \\leftarrow A'$.\nReturn $A$.\n\nD. For $i = 1, \\ldots, n$:\n    Let $\\phi_T = \\phi \\land x_i$ and $\\phi_F = \\phi \\land \\neg x_i$.\n    If `is_sat`($\\phi_T$) is True and `is_sat`($\\phi_F$) is True:\n        Set $A(x_i) = \\text{False}$.\n    Else if `is_sat`($\\phi_T$) is True:\n        Set $A(x_i) = \\text{True}$.\n    Else:\n        Set $A(x_i) = \\text{False}$.\nReturn $A$.", "solution": "We want an algorithm that always returns a satisfying assignment and guarantees minimality, meaning that for every variable set to True in the output, flipping it to False while keeping all other variables fixed makes the formula unsatisfied.\n\nAlgorithm B:\n- Correctness (returns a satisfying assignment): Maintain the invariant that at the start of iteration $i$ the working formula $\\psi$ equals $\\phi$ conjoined with fixed values for $x_{1},\\ldots,x_{i-1}$ and is satisfiable. At step $i$, the algorithm queries `is_sat`($\\psi \\land \\neg x_{i}$). If True, it sets $x_{i}=\\text{False}$ and updates $\\psi \\leftarrow \\psi \\land \\neg x_{i}$, which remains satisfiable by the oracle’s answer. Otherwise it sets $x_{i}=\\text{True}$ and $\\psi \\leftarrow \\psi \\land x_{i}$. This is safe because $\\psi$ is satisfiable and $\\psi \\equiv (\\psi \\land x_{i}) \\lor (\\psi \\land \\neg x_{i})$; if $\\psi \\land \\neg x_{i}$ is unsatisfiable, then $\\psi \\land x_{i}$ must be satisfiable (otherwise $\\psi$ would be unsatisfiable). By induction, after $n$ steps $\\psi$ includes assignments for all variables and is satisfiable, so the produced $A$ satisfies $\\phi$.\n\n- Minimality: Let $i$ be any index with $A(x_{i})=\\text{True}$. This only occurs when `is_sat`($\\psi \\land \\neg x_{i}$) returned False at step $i$, where $\\psi$ already included the fixed values for $x_{1},\\ldots,x_{i-1}$ as in $A$. The oracle’s False answer means there is no assignment to $x_{i+1},\\ldots,x_{n}$ that can satisfy $\\psi \\land \\neg x_{i}$. In particular, if we take the final values of $x_{i+1},\\ldots,x_{n}$ used in $A$, then\n$$\n\\phi \\land \\bigwedge_{ji}\\ell_{j} \\land \\neg x_{i} \\land \\bigwedge_{ji}\\ell_{j}\n$$\nis unsatisfiable, where each $\\ell_{j}$ is $x_{j}$ or $\\neg x_{j}$ according to $A$. Therefore flipping $x_{i}$ to False while keeping all other variables as in $A$ makes $\\phi$ false. Hence every True in $A$ is necessary and $A$ is minimal. Thus B is correct.\n\nAlgorithm A:\n- Counterexample: Let $\\phi=(x_1 \\lor x_2)$. At $i=1$, `is_sat`($\\phi \\land x_1$) is True, so set $A(x_1) = \\text{True}$. At $i=2$, `is_sat`($\\phi \\land x_1 \\land x_2$) is True, so set $A(x_2) = \\text{True}$. The result $A(x_1)=\\text{True}, A(x_2)=\\text{True}$ is not minimal, since flipping $x_2$ to False still satisfies $\\phi$.\n\nAlgorithm C:\n- Counterexample: Let $\\phi=(\\neg x_2 \\lor x_1)$. Algorithm A yields $A_0(x_1)=\\text{True}, A_0(x_2)=\\text{True}$ because both $\\phi \\land x_1$ and $\\phi \\land x_1 \\land x_2$ are satisfiable. Now Algorithm C: for $i=1$, try flipping $x_1$ to False while keeping $x_2=\\text{True}$; $(\\neg x_2 \\lor x_1)$ evaluates to False, so keep $x_1=\\text{True}$. For $i=2$, flip $x_2$ to False; $(\\neg x_2 \\lor x_1)$ is True, so set $x_2=\\text{False}$ and return $A=(x_1=\\text{True}, x_2=\\text{False})$. This $A$ is not minimal because flipping $x_1$ to False yields $(x_1=\\text{False}, x_2=\\text{False})$, which still satisfies $\\phi$. The flaw is that a single pass may miss further reducible True assignments created by later flips.\n\nAlgorithm D:\n- Counterexample (incompatibility of independent choices): Let\n$$\n\\phi=(x_1 \\lor x_2) \\land (x_1 \\lor x_3) \\land (x_2 \\lor x_3).\n$$\nFor each $i\\in\\{1,2,3\\}$, both $\\phi \\land x_i$ and $\\phi \\land \\neg x_i$ are satisfiable (e.g., $\\phi \\land \\neg x_1$ is satisfied by $x_2=\\text{True}, x_3=\\text{True}$). Algorithm D therefore sets all variables to False, yielding $A=(\\text{False},\\text{False},\\text{False})$, which does not satisfy $\\phi$. Hence D does not even guarantee a satisfying assignment.\n\nConclusion: Only Algorithm B correctly and always returns a minimal satisfying assignment for any satisfiable input $\\phi$.", "answer": "$$\\boxed{B}$$", "id": "1447155"}, {"introduction": "A SAT oracle can tell us if a solution exists, and self-reducibility can help us find one. But what if a problem has multiple solutions? This practice addresses how to find a second, distinct satisfying assignment after one has already been found. You will learn the crucial technique of augmenting a formula to exclude a known solution, effectively guiding the oracle's search into new regions of the solution space [@problem_id:1446970].", "problem": "In computational complexity theory, the concept of an \"oracle\" is a useful abstraction. An oracle for a decision problem, such as the Boolean Satisfiability Problem (SAT), is a black box that can answer in a single step whether any given Boolean formula is satisfiable. The self-reducibility of SAT allows us to use such an oracle not just to decide satisfiability, but also to find a satisfying assignment if one exists.\n\nConsider the following Boolean formula $F$ in Conjunctive Normal Form (CNF) with four variables, $x_1, x_2, x_3, x_4$:\n$$ F = (x_1 \\lor x_3) \\land (\\neg x_2 \\lor x_4) \\land (\\neg x_1 \\lor \\neg x_3 \\lor x_4) $$\nYou are given that the assignment $A = (x_1 \\mapsto \\text{True}, x_2 \\mapsto \\text{True}, x_3 \\mapsto \\text{False}, x_4 \\mapsto \\text{True})$ is a satisfying assignment for $F$.\n\nYour task is to find a second, distinct satisfying assignment for $F$. The standard method to do this is to construct a new formula, let's call it $F'$, which is satisfiable if and only if there exists a satisfying assignment for $F$ that is different from $A$. Once $F'$ is constructed, one can use the SAT oracle in a standard self-reducibility search to find such an assignment.\n\nWhich of the following represents the correct formula $F'$ that must be constructed to begin this process?\n\nA. $ F \\land (\\neg x_1 \\lor \\neg x_2 \\lor x_3 \\lor \\neg x_4) $\nB. $ F \\land (x_1 \\land x_2 \\land \\neg x_3 \\land x_4) $\nC. $ F \\lor (\\neg x_1 \\lor \\neg x_2 \\lor x_3 \\lor \\neg x_4) $\nD. $ (\\neg x_1 \\lor \\neg x_2 \\lor x_3 \\lor \\neg x_4) $\nE. $ F \\land (x_1 \\lor x_2 \\lor \\neg x_3 \\lor x_4) $", "solution": "We are given the CNF formula $F$ and a known satisfying assignment $A$ with $x_{1}=\\text{True}$, $x_{2}=\\text{True}$, $x_{3}=\\text{False}$, $x_{4}=\\text{True}$. To find a second distinct satisfying assignment using a SAT oracle via self-reducibility, we must construct a formula $F'$ that is satisfiable if and only if there exists a satisfying assignment for $F$ different from $A$. The standard construction excludes exactly the assignment $A$ by conjoining $F$ with a clause that is false on $A$ and true on every other assignment.\n\nThe assignment $A$ can be represented as the conjunction that fixes all variables to their values in $A$:\n$$\nC_{A} \\equiv x_{1} \\land x_{2} \\land \\neg x_{3} \\land x_{4}.\n$$\nTo exclude exactly $A$, we add the negation of this conjunction. By De Morgan’s law,\n$$\n\\neg C_{A} \\equiv \\neg(x_{1} \\land x_{2} \\land \\neg x_{3} \\land x_{4}) = (\\neg x_{1} \\lor \\neg x_{2} \\lor x_{3} \\lor \\neg x_{4}).\n$$\nThis disjunction is a single clause that is false precisely on $A$ and true on every assignment that differs from $A$ in at least one variable. Therefore, the desired formula is\n$$\nF' \\equiv F \\land (\\neg x_{1} \\lor \\neg x_{2} \\lor x_{3} \\lor \\neg x_{4}).\n$$\nThis achieves the required equivalence: if $F'$ is satisfiable, then there exists an assignment that satisfies $F$ and differs from $A$; conversely, any satisfying assignment of $F$ that is not $A$ satisfies the added clause and thus satisfies $F'$.\n\nMatching this with the options, this is exactly option A. Options B and E do not exclude $A$ (B forces $A$ itself; E’s clause is true on $A$ but does not exclude it). Option C uses a disjunction with $F$, which does not ensure the result is a satisfying assignment of $F$. Option D drops $F$ entirely, allowing assignments that do not satisfy $F$.", "answer": "$$\\boxed{A}$$", "id": "1446970"}]}