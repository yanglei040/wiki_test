{"hands_on_practices": [{"introduction": "To understand what makes a problem P-complete, it is helpful to first examine a problem that is efficiently parallelizable. This exercise explores the Max-Expression Evaluation Problem (MEEP), which, due to its nested parentheses, might appear to require sequential processing. By analyzing the properties of the `max` operator, you will discover why this problem is actually in the class **NC** and thus considered highly parallelizable, providing a sharp contrast to the nature of P-complete problems [@problem_id:1433477].", "problem": "In computational complexity theory, we study the resources required to solve computational problems. The class **P** consists of all decision problems that can be solved in polynomial time by a deterministic sequential computer. The class **NC** (Nick's Class) is the set of decision problems solvable in polylogarithmic time on a parallel computer with a polynomial number of processors. Problems in NC are considered \"efficiently parallelizable\". It is widely believed that NC is a strict subset of P.\n\nA problem in P is said to be **P-complete** if it is among the \"hardest\" problems in P. More formally, every other problem in P can be reduced to it using a log-space reduction. P-complete problems are considered \"inherently sequential\" and are very unlikely to be in NC. If any P-complete problem were found to be in NC, it would imply that P = NC.\n\nConsider the **Max-Expression Evaluation Problem (MEEP)** defined as follows: Given a fully parenthesized expression involving a set of integer variables $x_1, x_2, \\dots, x_n$ and the binary operator `max(,)`, along with the integer values for each variable, compute the final value of the expression. An example of such an expression is `max(x_1, max(max(x_2, x_3), x_4))`.\n\nBased on the definitions provided, determine the most accurate classification for the Max-Expression Evaluation Problem (MEEP).\n\nA. MEEP is P-complete because the arbitrary nesting of parentheses imposes a sequential evaluation order, similar to other P-complete problems like the general Circuit Value Problem.\n\nB. MEEP is in NC because the `max` operator is associative, which allows the computation to be restructured and performed efficiently in parallel, regardless of the initial parenthesization.\n\nC. MEEP is not in P, and therefore cannot be P-complete, because evaluating a deeply nested expression requires a number of steps proportional to the depth, which can be exponential in the number of variables.\n\nD. MEEP is #P-complete, as the problem is equivalent to counting the number of comparisons needed to find the largest element in a set.\n\nE. MEEP is in NC only if the expression corresponds to a balanced binary tree. For arbitrarily nested (unbalanced) expressions, the problem is P-complete.", "solution": "We are given a fully parenthesized expression over the binary operator $\\max(\\cdot,\\cdot)$ on integer variables $x_{1},\\dots,x_{n}$ and asked to compute the final value. The key algebraic property is that $\\max$ is associative and commutative:\n$$\n\\max(a,\\max(b,c))=\\max(\\max(a,b),c)=\\max(a,b,c),\n$$\nand it is also idempotent:\n$$\n\\max(a,a)=a.\n$$\nTherefore, for any fully parenthesized expression $E$ built solely from $\\max$ applied to variables among $\\{x_{1},\\dots,x_{n}\\}$ (possibly with repetitions), its value depends only on the multiset of variables appearing and equals the global maximum of those values. Equivalently,\n$$\n\\mathrm{MEEP}(E)=\\max\\{x_{i} : x_{i} \\text{ appears in } E\\}.\n$$\n\nTo classify the problem, we observe that computing the maximum of $n$ integers is efficiently parallelizable. A standard parallel reduction computes the maximum in $O(\\log n)$ time using $O(n)$ processors: define $y_{i}^{(0)}=x_{i}$ for $1 \\le i \\le n$, and for each round $t \\ge 1$ set\n$$\ny_{i}^{(t)}=\\max\\bigl(y_{2i-1}^{(t-1)},\\,y_{2i}^{(t-1)}\\bigr)\n\\quad \\text{for} \\quad 1 \\le i \\le \\left\\lfloor \\frac{n}{2^{t}} \\right\\rfloor.\n$$\nAfter $T=\\lceil \\log_{2} n \\rceil$ rounds, we obtain\n$$\ny_{1}^{(T)}=\\max_{1 \\le i \\le n} x_{i}.\n$$\nThis algorithm runs in polylogarithmic time with a polynomial number of processors, so it is in $NC$. The initial parenthesization does not constrain the parallel evaluation because associativity guarantees that rebracketing to a balanced reduction tree does not change the result.\n\nConsequently:\n- Option A is incorrect: associativity defeats any purported inherent sequentiality.\n- Option C is incorrect: the depth of any such expression is at most linear in $n$, and in any case we can evaluate in polylogarithmic parallel time.\n- Option D is incorrect: MEEP asks for the maximum value, not a count; it is not a counting problem and there is no reduction to a $\\#P$ function here.\n- Option E is incorrect: even for unbalanced expressions, associativity allows balanced parallel evaluation, so the problem remains in $NC$.\n\nTherefore, the most accurate classification is that MEEP is in $NC$ due to associativity enabling efficient parallel evaluation regardless of initial parenthesization.", "answer": "$$\\boxed{B}$$", "id": "1433477"}, {"introduction": "In contrast to the previous example where associativity allowed for parallelization, this problem demonstrates the essence of inherent sequentiality. You are asked to evaluate an expression using a non-associative binary operation, where the order of operations is fixed by parentheses. This task illustrates how the underlying algebraic structure can forbid reordering and parallel execution, forcing a step-by-step computation that is characteristic of P-complete problems [@problem_id:1433489].", "problem": "Consider a finite algebraic structure defined on a set of elements $S = \\{a, b, c\\}$. A binary operation $*$ is defined on this set by the following rules:\n$a * a = a, \\quad a * b = c, \\quad a * c = b$\n$b * a = a, \\quad b * b = b, \\quad b * c = c$\n$c * a = b, \\quad c * b = a, \\quad c * c = a$\n\nNote that this operation is not necessarily associative. You are given an unparenthesized expression consisting of a sequence of four elements: $E = a * b * c * a$. A valid parenthesization of this expression fully specifies the order in which the operations are performed. For example, one such parenthesization is $((a*b)*c)*a$.\n\nDetermine the total number of distinct parenthesizations of the expression $E$ that evaluate to the element $c$.\n\nA. 0\n\nB. 1\n\nC. 2\n\nD. 3\n\nE. 5", "solution": "We have the set $S=\\{a,b,c\\}$ with the binary operation $*$ defined by:\n$$a*a=a,\\quad a*b=c,\\quad a*c=b,$$\n$$b*a=a,\\quad b*b=b,\\quad b*c=c,$$\n$$c*a=b,\\quad c*b=a,\\quad c*c=a.$$\nConsider $E=a*b*c*a$. All full parenthesizations of four factors are:\n1. $(((a*b)*c)*a)$\n2. $((a*(b*c))*a)$\n3. $((a*b)*(c*a))$\n4. $(a*((b*c)*a))$\n5. $(a*(b*(c*a)))$\nEvaluate each:\n1. $a*b=c$, then $(a*b)*c=c*c=a$, then $((a*b)*c)*a=a*a=a$.\n2. $b*c=c$, then $a*(b*c)=a*c=b$, then $(a*(b*c))*a=b*a=a$.\n3. $a*b=c$ and $c*a=b$, then $(a*b)*(c*a)=c*b=a$.\n4. $b*c=c$, then $(b*c)*a=c*a=b$, then $a*((b*c)*a)=a*b=c$.\n5. $c*a=b$, then $b*(c*a)=b*b=b$, then $a*(b*(c*a))=a*b=c$.\nExactly two parenthesizations (4 and 5) evaluate to $c$. Therefore, the total number is $2$, corresponding to option C.", "answer": "$$\\boxed{C}$$", "id": "1433489"}, {"introduction": "This practice moves to a classic and more subtle example of a P-complete problem related to the Union-Find data structure. The task of finding a set's representative without the path compression heuristic exemplifies a concept known as pointer chasing, where each step of the computation depends directly on the outcome of the previous one. Solving this problem requires carefully tracing a sequence of operations, revealing the inherently sequential logic that makes this type of problem difficult to parallelize and a canonical member of the P-complete class [@problem_id:1433739].", "problem": "In the study of parallel computation, understanding sequential dependencies is crucial. The Union-Find data structure provides a classic example of such dependencies. Consider a system of $N=16$ elements, indexed from 0 to 15. These elements are organized into disjoint sets using a Union-Find data structure.\n\nInitially, each element $i \\in \\{0, 1, ..., 15\\}$ is in its own set. The state of the system is maintained by a parent array $p$ and a rank array $r$. For each element $i$, $p[i]$ is its parent and $r[i]$ is its rank. Initially, $p[i] = i$ and $r[i] = 0$ for all $i$.\n\nThe `find(i)` operation returns the representative (or root) of the set containing element $i$ by traversing the parent pointers until it reaches an element whose parent is itself. In this problem, the `find` operation does **not** perform path compression.\n\nThe sets are merged using a `union(u, v)` operation. This operation first finds the representatives of $u$ and $v$, let's call them $r_u = \\text{find}(u)$ and $r_v = \\text{find}(v)$. If $r_u$ and $r_v$ are different, the sets are merged according to the **union by rank** heuristic with a specific tie-breaking rule:\n- If $r[r_u] < r[r_v]$, the parent of $r_u$ is set to $r_v$.\n- If $r[r_u] > r[r_v]$, the parent of $r_v$ is set to $r_u$.\n- If $r[r_u] = r[r_v]$, the parent of the root with the smaller index is set to the root with the larger index, and the rank of the larger-indexed root is incremented by one.\n\nA specific sequence of 15 `union` operations is performed on the system in the given order:\n1.  `union(1, 0)`\n2.  `union(3, 2)`\n3.  `union(5, 4)`\n4.  `union(7, 6)`\n5.  `union(9, 8)`\n6.  `union(11, 10)`\n7.  `union(13, 12)`\n8.  `union(15, 14)`\n9.  `union(2, 0)`\n10. `union(6, 4)`\n11. `union(10, 8)`\n12. `union(14, 12)`\n13. `union(4, 0)`\n14. `union(12, 8)`\n15. `union(8, 0)`\n\nAfter this entire sequence of operations has been completed, what is the index of the representative element for the set that contains element 7?", "solution": "We will trace the state of the Union-Find data structure, specifically the parent array `p` and the rank array `r`, through the given sequence of 15 operations. There are $N=16$ elements, indexed 0 to 15.\n\n**Initial State:**\nEach element is its own parent and has a rank of 0.\n$p = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]$\n$r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$\n\nThe `find(i)` operation follows parent pointers from $i$ to its root. Without path compression, it doesn't alter the `p` array. The `union(u, v)` operation merges the sets of $u$ and $v$ based on the ranks of their roots, with the specified tie-breaking rule: if ranks are equal, the smaller-indexed root points to the larger-indexed root.\n\n**Operations 1-8: Pairwise Unions**\n\nThese operations unite adjacent pairs of elements. In each case, both elements are roots with rank 0. The tie-breaking rule applies.\n1. `union(1, 0)`: roots are 1 and 0. Ranks are equal (0). Since $0 < 1$, we set $p[0] = 1$ and $r[1]$ becomes 1.\n2. `union(3, 2)`: roots are 3 and 2. Ranks are equal (0). Since $2 < 3$, we set $p[2] = 3$ and $r[3]$ becomes 1.\n3. `union(5, 4)`: roots are 5 and 4. Ranks are equal (0). Since $4 < 5$, we set $p[4] = 5$ and $r[5]$ becomes 1.\n4. `union(7, 6)`: roots are 7 and 6. Ranks are equal (0). Since $6 < 7$, we set $p[6] = 7$ and $r[7]$ becomes 1.\n5. `union(9, 8)`: roots are 9 and 8. Ranks are equal (0). Since $8 < 9$, we set $p[8] = 9$ and $r[9]$ becomes 1.\n6. `union(11, 10)`: roots are 11 and 10. Ranks are equal (0). Since $10 < 11$, we set $p[10] = 11$ and $r[11]$ becomes 1.\n7. `union(13, 12)`: roots are 13 and 12. Ranks are equal (0). Since $12 < 13$, we set $p[12] = 13$ and $r[13]$ becomes 1.\n8. `union(15, 14)`: roots are 15 and 14. Ranks are equal (0). Since $14 < 15$, we set $p[14] = 15$ and $r[15]$ becomes 1.\n\nAfter these 8 operations, the odd-indexed elements are roots of rank 1, and each is a parent to the preceding even-indexed element.\n- Roots: {1, 3, 5, 7, 9, 11, 13, 15}\n- Ranks: $r[i]=1$ for odd $i$, 0 otherwise.\n- Parents of roots: $p[i]=i$ for odd $i$.\n- Parents of non-roots: $p[0]=1, p[2]=3, p[4]=5, p[6]=7, p[8]=9, p[10]=11, p[12]=13, p[14]=15$.\n\n**Operations 9-12: First Level of Merging**\n\nThese operations merge the sets of size 2 created above.\n9. `union(2, 0)`: `find(2)` is 3. `find(0)` is 1. We are uniting roots 3 and 1. Both have rank 1. Since $1 < 3$, we set $p[1] = 3$ and $r[3]$ becomes 2.\n10. `union(6, 4)`: `find(6)` is 7. `find(4)` is 5. We are uniting roots 7 and 5. Both have rank 1. Since $5 < 7$, we set $p[5] = 7$ and $r[7]$ becomes 2.\n11. `union(10, 8)`: `find(10)` is 11. `find(8)` is 9. We are uniting roots 11 and 9. Both have rank 1. Since $9 < 11$, we set $p[9] = 11$ and $r[11]$ becomes 2.\n12. `union(14, 12)`: `find(14)` is 15. `find(12)` is 13. We are uniting roots 15 and 13. Both have rank 1. Since $13 < 15$, we set $p[13] = 15$ and $r[15]$ becomes 2.\n\nAfter these 4 operations, we have 4 sets, each of size 4.\n- Roots: {3, 7, 11, 15}\n- Ranks: $r[3]=2, r[7]=2, r[11]=2, r[15]=2$. All other ranks are 0 or 1.\n- The parent chains are now longer. For example, `find(0)` follows $0 \\to 1 \\to 3$.\n\n**Operations 13-14: Second Level of Merging**\n\n13. `union(4, 0)`: `find(4)` traverses $4 \\to 5 \\to 7$, so the root is 7. `find(0)` traverses $0 \\to 1 \\to 3$, so the root is 3. We unite roots 7 and 3. Both have rank 2. Since $3 < 7$, we set $p[3] = 7$ and $r[7]$ becomes 3.\n14. `union(12, 8)`: `find(12)` traverses $12 \\to 13 \\to 15$, root 15. `find(8)` traverses $8 \\to 9 \\to 11$, root 11. We unite roots 15 and 11. Both have rank 2. Since $11 < 15$, we set $p[11] = 15$ and $r[15]$ becomes 3.\n\nNow we have two large sets, each of size 8.\n- Roots: {7, 15}\n- Ranks: $r[7]=3, r[15]=3$.\n\n**Operation 15: Final Merge**\n\n15. `union(8, 0)`: `find(8)` traverses $8 \\to 9 \\to 11 \\to 15$, root 15. `find(0)` traverses $0 \\to 1 \\to 3 \\to 7$, root 7. We unite the final two roots, 15 and 7. Both have rank 3. Since $7 < 15$, we set $p[7] = 15$ and $r[15]$ becomes 4.\n\n**Final State and Answer**\n\nAfter all operations, the entire set of 16 elements has been unified under a single root. The last operation set the parent of root 7 to be 15. Therefore, 15 is the single representative for all elements.\n\nThe question asks for the representative element for the set containing element 7. We can find this by tracing the parent pointers from 7 until we reach the root.\n- The element is 7.\n- After all operations, we look at $p[7]$. The final operation set $p[7] = 15$.\n- We then look at $p[15]$. Since 15 is the final root, $p[15]$ is still 15.\nThe path is $7 \\to 15$. The root of the tree containing element 7 is 15.", "answer": "$$\\boxed{15}$$", "id": "1433739"}]}