{"hands_on_practices": [{"introduction": "Understanding Horn-satisfiability begins with mastering the polynomial-time algorithm that solves it. This first practice exercise [@problem_id:1427138] guides you through a step-by-step execution of the marking algorithm. By tracking how truth values propagate through a set of Horn clauses, you will build a foundational, mechanical understanding of how the algorithm reaches a stable 'fixed point,' which corresponds to the problem's minimal satisfying assignment.", "problem": "A system for managing software feature activation is defined by the state of six boolean features, represented by variables $x_1, x_2, x_3, x_4, x_5, x_6$. A value of 1 for a variable indicates the corresponding feature is `ON`, while a value of 0 means it is `OFF`.\n\nThe system's state is determined by an iterative activation algorithm that applies a set of rules. The process is as follows:\n1.  Initially, all features are set to `OFF` (all variables are 0).\n2.  The system then applies a set of activation rules. This is done in rounds. In each round, the algorithm checks every rule. If the prerequisites for a rule are met by the current set of `ON` features, the rule's target feature is turned `ON` (its variable is set to 1).\n3.  This process of applying rules in rounds continues until a full round completes with no new features being turned `ON`.\n\nThe activation rules for the system are:\n- **Rule 1:** Feature 1 is `ON`.\n- **Rule 2:** Feature 2 is `ON`.\n- **Rule 3:** If Feature 1 is `ON`, then Feature 3 is turned `ON`.\n- **Rule 4:** If Feature 3 and Feature 4 are `ON`, then Feature 5 is turned `ON`.\n- **Rule 5:** If Feature 5 is `ON`, then Feature 6 is turned `ON`.\n- **Rule 6:** If Feature 2 and Feature 6 are `ON`, then Feature 4 is turned `ON`.\n\nWhat is the final state of the features upon completion of the algorithm? The state should be represented as a vector $(x_1, x_2, x_3, x_4, x_5, x_6)$.\n\nA. (1, 1, 0, 0, 0, 0)\n\nB. (1, 1, 1, 0, 0, 0)\n\nC. (1, 1, 1, 1, 0, 0)\n\nD. (1, 1, 1, 1, 1, 1)\n\nE. (1, 0, 1, 0, 0, 0)", "solution": "We formalize the rules as implications over boolean variables $x_{1},\\dots,x_{6}$:\n- Rule 1: $x_{1}=1$.\n- Rule 2: $x_{2}=1$.\n- Rule 3: $x_{1}=1 \\Rightarrow x_{3}=1$.\n- Rule 4: $(x_{3}=1) \\land (x_{4}=1) \\Rightarrow x_{5}=1$.\n- Rule 5: $x_{5}=1 \\Rightarrow x_{6}=1$.\n- Rule 6: $(x_{2}=1) \\land (x_{6}=1) \\Rightarrow x_{4}=1$.\n\nThe algorithm starts from the all-zero state and repeatedly applies these implications until no new variables turn to $1$ in a full round. Let the state after round $t$ be denoted by $x^{(t)}=(x_{1}^{(t)},x_{2}^{(t)},x_{3}^{(t)},x_{4}^{(t)},x_{5}^{(t)},x_{6}^{(t)})$.\n\nInitialization gives\n$$\nx^{(0)}=(0,0,0,0,0,0).\n$$\n\nRound 1:\n- By Rule 1 and Rule 2, we set $x_{1}^{(1)}=1$ and $x_{2}^{(1)}=1$.\n- With $x_{1}^{(1)}=1$, Rule 3 applies, so $x_{3}^{(1)}=1$.\n- Rule 4 requires both $x_{3}=1$ and $x_{4}=1$, but $x_{4}^{(1)}=0$, so it does not apply.\n- Rule 5 requires $x_{5}=1$, which is not satisfied, so it does not apply.\n- Rule 6 requires $x_{2}=1$ and $x_{6}=1$, but $x_{6}^{(1)}=0$, so it does not apply.\nTherefore, at the end of Round 1,\n$$\nx^{(1)}=(1,1,1,0,0,0).\n$$\n\nRound 2:\n- Rules 1, 2, and 3 are already satisfied and make no changes beyond $x_{1}=1$, $x_{2}=1$, $x_{3}=1$.\n- Rule 4 still fails because it needs $x_{4}=1$ in addition to $x_{3}=1$, but $x_{4}=0$.\n- Rule 5 still fails because it needs $x_{5}=1$, which is false.\n- Rule 6 still fails because it needs $x_{6}=1$, which is false.\nNo new features are turned on in this round, so the algorithm terminates.\n\nThus the final state is\n$$\n(x_{1},x_{2},x_{3},x_{4},x_{5},x_{6})=(1,1,1,0,0,0),\n$$\nwhich corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1427138"}, {"introduction": "The efficiency of the Horn-SAT algorithm is not magic; it relies fundamentally on the specific structure of Horn clauses. This practice [@problem_id:1427136] is a thought experiment designed to probe the algorithm's limitations by applying it to a formula containing a non-Horn clause. Observing how the algorithm produces an incorrect result will clarify why the 'at most one positive literal' rule is the key to its success and why the general Satisfiability problem remains computationally hard.", "problem": "In computational logic, a Boolean formula is in Conjunctive Normal Form (CNF) if it is a conjunction (AND, $\\land$) of one or more clauses, where a clause is a disjunction (OR, $\\lor$) of literals. A literal is either a variable (a positive literal) or its negation (a negative literal). A Horn clause is a clause with at most one positive literal. For instance, $(\\neg v_1 \\lor \\neg v_2 \\lor v_3)$ and $(\\neg v_1 \\lor \\neg v_2)$ are Horn clauses, but $(v_1 \\lor v_2)$ is not. The Horn-Satisfiability (Horn-SAT) problem, which is solvable in polynomial time, involves determining if a formula consisting entirely of Horn clauses is satisfiable.\n\nA standard algorithm for Horn-SAT is the marking algorithm. Consider the following specific implementation of this algorithm:\n1.  Initialize an empty set, `marked_vars`, which will store variables determined to be TRUE.\n2.  For every \"unit clause\" of the form $(h)$ in the formula, add the variable $h$ to `marked_vars`.\n3.  Repeat the following until no new variables can be added to `marked_vars` in a full pass:\n    For each clause of the form $(\\neg l_1 \\lor \\neg l_2 \\lor \\dots \\lor \\neg l_k \\lor h)$, if the variables corresponding to all negative literals $l_1, l_2, \\dots, l_k$ are already in `marked_vars`, add the variable $h$ to `marked_vars`.\n4.  After the loop terminates, a potential satisfying assignment is proposed: all variables in `marked_vars` are set to TRUE, and all other variables are set to FALSE.\n5.  Finally, a consistency check is performed. For every clause consisting of only negative literals, such as $(\\neg l_1 \\lor \\neg l_2 \\lor \\dots \\lor \\neg l_k)$, if all variables $l_1, l_2, \\dots, l_k$ are in `marked_vars`, the algorithm reports the formula is UNSATISFIABLE. Otherwise, it outputs the proposed assignment from step 4.\n\nNow, consider the following Boolean formula $\\phi$, which contains a mix of Horn and non-Horn clauses:\n$$ \\phi = (v_1 \\lor v_2) \\land (\\neg v_1 \\lor v_3) \\land (\\neg v_2) $$\nWhat is the outcome when the marking algorithm described above is applied to the formula $\\phi$?\n\nA. The algorithm marks variables $v_1$ and $v_3$, proposes the assignment $(v_1, v_2, v_3) = (\\text{TRUE}, \\text{FALSE}, \\text{TRUE})$, and this assignment correctly satisfies $\\phi$.\n\nB. The algorithm fails to mark any variables, proposes the assignment $(v_1, v_2, v_3) = (\\text{FALSE}, \\text{FALSE}, \\text{FALSE})$, and this assignment fails to satisfy the clause $(v_1 \\lor v_2)$.\n\nC. The algorithm uses the clause $(\\neg v_2)$ to infer that $v_2$ must be FALSE, marks $v_1$ and $v_3$, and proposes the correct satisfying assignment.\n\nD. The algorithm fails to mark any variables, and because the clause $(\\neg v_2)$ exists, it reports that the formula is UNSATISFIABLE during the consistency check.\n\nE. The algorithm cannot process the non-Horn clause $(v_1 \\lor v_2)$ and therefore enters an infinite loop.", "solution": "Let the clauses of $\\phi$ be labeled as follows:\n$$C_{1}=(v_{1}\\lor v_{2}),\\quad C_{2}=(\\neg v_{1}\\lor v_{3}),\\quad C_{3}=(\\neg v_{2}).$$\nStep 1 initializes $\\mathrm{marked\\_vars}=\\varnothing$.\n\nIn Step 2, only unit clauses of the form $(h)$ add a variable $h$ to $\\mathrm{marked\\_vars}$. The clause $C_{3}$ is $(\\neg v_{2})$, which is not of the form $(h)$, and there is no positive unit clause in $\\phi$. Therefore, no variable is added and $\\mathrm{marked\\_vars}=\\varnothing$.\n\nIn Step 3, we iterate over clauses of the form $(\\neg l_{1}\\lor\\dots\\lor\\neg l_{k}\\lor h)$ and add $h$ if all $l_{i}$ are already in $\\mathrm{marked\\_vars}$. The clause $C_{2}$ matches this form with $k=1$, $l_{1}=v_{1}$, and $h=v_{3}$, but the condition requires $v_{1}\\in\\mathrm{marked\\_vars}$, which is false. The clause $C_{1}$ does not match the required form (it is not Horn of implication type), and $C_{3}$ has no positive head $h$. Hence, no new variables are added in a full pass, and the loop terminates with $\\mathrm{marked\\_vars}=\\varnothing$.\n\nIn Step 4, the proposed assignment sets all variables in $\\mathrm{marked\\_vars}$ to TRUE and all others to FALSE, yielding $(v_{1},v_{2},v_{3})=(\\text{FALSE},\\text{FALSE},\\text{FALSE})$.\n\nIn Step 5, the consistency check inspects clauses containing only negative literals. The only such clause is $C_{3}=(\\neg v_{2})$. The algorithm reports UNSAT only if all variables in such a clause are in $\\mathrm{marked\\_vars}$. Since $v_{2}\\notin\\mathrm{marked\\_vars}$, no UNSAT is reported, and the algorithm outputs the proposed assignment.\n\nFinally, we verify whether the proposed assignment satisfies $\\phi$. Evaluate $C_{1}$ under $(v_{1},v_{2})=(\\text{FALSE},\\text{FALSE})$:\n$$(v_{1}\\lor v_{2})=\\text{FALSE}\\lor\\text{FALSE}=\\text{FALSE}.$$\nThus the assignment fails to satisfy $\\phi$. This behavior corresponds exactly to option B.", "answer": "$$\\boxed{B}$$", "id": "1427136"}, {"introduction": "Beyond simply determining satisfiability, we often want to ask more nuanced questions about logical systems. This advanced exercise [@problem_id:1427111] explores such a question: can a specific variable ever be true in *any* satisfying assignment? Rather than developing a new algorithm from scratch, this problem guides you to use reduction, a powerful technique in computational theory. By augmenting the original Horn formula in a specific way, you can use the standard Horn-SAT solver to answer this more complex query, highlighting the distinction between a variable that *must* be true and one that *can* be true.", "problem": "In the field of artificial intelligence, knowledge bases are often constructed from a set of logical rules. A particularly efficient and expressive class of rules can be modeled using Horn clauses. Consider a medical diagnostic system that uses such a knowledge base. The system's state is described by a set of propositional variables, where each variable might represent a symptom (e.g., `has_fever`) or a diagnosis (e.g., `has_flu`).\n\nLet's formally define the components:\n- A **literal** is a propositional variable (a positive literal, e.g., $x$) or its negation (a negative literal, e.g., $\\neg x$).\n- A **Horn clause** is a disjunction of literals containing at most one positive literal. Examples of Horn clauses and their common logical equivalences are:\n    1. A definite clause: $\\neg p_1 \\lor \\neg p_2 \\lor \\dots \\lor \\neg p_k \\lor q$, which is equivalent to $(p_1 \\land p_2 \\land \\dots \\land p_k) \\rightarrow q$. This represents a rule, e.g., \"If a patient has a fever and a cough, then they might have the flu.\"\n    2. A negative clause: $\\neg p_1 \\lor \\neg p_2 \\lor \\dots \\lor \\neg p_k$, which is equivalent to $(p_1 \\land p_2 \\land \\dots \\land p_k) \\rightarrow \\text{FALSE}$. This represents a constraint, e.g., \"A patient cannot have both Disease A and Disease B.\"\n    3. A fact: $q$, which is equivalent to $\\text{TRUE} \\rightarrow q$. This represents an observed fact, e.g., \"The patient has a fever.\"\n- A **Horn formula** $\\Phi$ is a conjunction (AND) of Horn clauses.\n- A **satisfying assignment** is a truth value assignment (TRUE/FALSE) to all variables that makes the entire formula $\\Phi$ evaluate to TRUE.\n\nA crucial query for the diagnostic system is to determine if a particular diagnosis is logically possible. Given a Horn formula $\\Phi$ representing the entire knowledge base and a specific variable $x$ representing a potential diagnosis, a developer needs an algorithm to solve the **HORN-EXIST-TRUE** problem: determine if there exists *any* satisfying assignment for $\\Phi$ in which the variable $x$ is assigned the value TRUE.\n\nWhich of the following statements correctly describes a polynomial-time method to solve the HORN-EXIST-TRUE problem for a given Horn formula $\\Phi$ and a variable $x$?\n\nA. The problem is equivalent to checking the satisfiability of $\\Phi$. If $\\Phi$ has any satisfying assignment, then for any variable $v$, there must exist some satisfying assignment where $v$ is TRUE.\n\nB. Find the minimal satisfying assignment for $\\Phi$ using the standard linear-time Horn-SAT algorithm. The variable $x$ can be set to TRUE in a satisfying assignment if and only if $x$ is assigned TRUE in this minimal assignment.\n\nC. Modify the formula $\\Phi$ by adding the clause $(\\neg x)$ and check if the resulting formula is satisfiable. If it is unsatisfiable, then it is possible to set $x$ to TRUE.\n\nD. The problem is NP-complete, a known hard variant of the general Boolean Satisfiability Problem (SAT), and thus no polynomial-time algorithm is believed to exist.\n\nE. Modify the formula $\\Phi$ by adding the clause $(x)$ to form a new formula $\\Phi'$. It is possible to satisfy $\\Phi$ with $x$ as TRUE if and only if this new formula $\\Phi'$ is satisfiable.", "solution": "The problem asks for a polynomial-time algorithm to determine if a variable $x$ can be set to TRUE in any satisfying assignment of a given Horn formula $\\Phi$. This is the HORN-EXIST-TRUE problem. We need to evaluate the proposed methods. The key is to relate this problem to the standard Horn Satisfiability (Horn-SAT) problem, which is known to be solvable in polynomial time (in fact, linear time).\n\nLet's analyze the relationship between HORN-EXIST-TRUE($\\Phi, x$) and Horn-SAT. We are looking for an assignment $A$ such that $A$ satisfies $\\Phi$ (written as $A \\models \\Phi$) and $A(x) = \\text{TRUE}$.\n\nConsider the proposal in option E. We construct a new formula $\\Phi' = \\Phi \\land (x)$.\nFirst, we observe that $\\Phi'$ is also a Horn formula. The original formula $\\Phi$ is a conjunction of Horn clauses. The new clause $(x)$ is a Horn clause itself (it contains exactly one positive literal and zero negative literals, equivalent to $\\text{TRUE} \\rightarrow x$). The conjunction of Horn clauses results in a Horn formula. Since Horn-SAT is solvable in polynomial time, checking the satisfiability of $\\Phi'$ can be done in polynomial time.\n\nNow, we must prove that this approach is correct. That is, we must show that \"there exists a satisfying assignment for $\\Phi$ with $x=\\text{TRUE}$\" if and only if \"$\\Phi'$ is satisfiable\".\n\n**Part 1: (⇒) Assume there exists a satisfying assignment for $\\Phi$ with $x=\\text{TRUE}$.**\nLet this assignment be $A$. By definition, we have:\n1. $A \\models \\Phi$ (A satisfies $\\Phi$)\n2. $A(x) = \\text{TRUE}$\n\nWe want to show that $\\Phi'$ is satisfiable. An assignment satisfies a conjunction if it satisfies every part of the conjunction.\nThe formula is $\\Phi' = \\Phi \\land (x)$.\n- Does $A$ satisfy $\\Phi$? Yes, by assumption (1).\n- Does $A$ satisfy the clause $(x)$? Yes, because an assignment satisfies a single-literal clause if it assigns that literal the value TRUE, and we know from (2) that $A(x) = \\text{TRUE}$.\nSince $A$ satisfies both $\\Phi$ and $(x)$, it is a satisfying assignment for their conjunction, $\\Phi'$. Therefore, $\\Phi'$ is satisfiable.\n\n**Part 2: (⇐) Assume $\\Phi' = \\Phi \\land (x)$ is satisfiable.**\nBy definition, this means there exists an assignment, let's call it $A'$, such that $A' \\models \\Phi'$.\nSince $A'$ satisfies the conjunction $\\Phi \\land (x)$, it must satisfy each part:\n1. $A' \\models \\Phi$\n2. $A' \\models (x)$\n\nFrom (2), for $A'$ to satisfy the clause $(x)$, it must be that $A'(x) = \\text{TRUE}$.\nFrom (1), we know that this same assignment $A'$ is a satisfying assignment for the original formula $\\Phi$.\nSo, we have found an assignment, namely $A'$, which satisfies $\\Phi$ and in which $x$ is assigned TRUE. This is precisely what the HORN-EXIST-TRUE problem asks for.\n\nThis establishes that checking the satisfiability of $\\Phi' = \\Phi \\land (x)$ is a correct, polynomial-time method for solving HORN-EXIST-TRUE($\\Phi, x$). Therefore, option E is correct.\n\nLet's briefly analyze why the other options are incorrect:\n- **A**: This is false. A formula can be satisfiable, yet some variables might be forced to be FALSE in all satisfying assignments. For example, $\\Phi = (x \\rightarrow \\text{FALSE})$ is a Horn formula (equivalent to $\\neg x$). It is satisfied by setting $x=\\text{FALSE}$. There is no satisfying assignment where $x=\\text{TRUE}$.\n- **B**: This is incorrect. The standard Horn-SAT algorithm finds the *minimal satisfying assignment*, where the set of TRUE variables is the smallest possible. This assignment tells us which variables *must* be TRUE in any satisfying assignment. A variable $x$ could be FALSE in the minimal model but could be set to TRUE in other, non-minimal satisfying assignments. For example, consider $\\Phi = (p \\rightarrow q)$. The minimal model is $\\{p=\\text{FALSE}, q=\\text{FALSE}\\}$. Here, $p$ is FALSE. However, the assignment $\\{p=\\text{TRUE}, q=\\text{TRUE}\\}$ also satisfies $\\Phi$. So, it is possible for $p$ to be true, even though it's false in the minimal model.\n- **C**: Modifying $\\Phi$ by adding $(\\neg x)$ tests the wrong property. $(\\neg x)$ is equivalent to $(x \\rightarrow \\text{FALSE})$, which is a Horn clause. The formula $\\Phi \\land (\\neg x)$ is satisfiable if and only if there's a satisfying assignment for $\\Phi$ where $x$ is FALSE. The option suggests that if this new formula is *unsatisfiable*, then it's possible to set $x$ to TRUE. This means that *every* satisfying assignment of $\\Phi$ must have $x=\\text{TRUE}$. This answers the question \"must $x$ be true?\", not \"can $x$ be true?\".\n- **D**: This is incorrect. As shown, the problem reduces in polynomial time to Horn-SAT, which is a classic problem in the complexity class P (solvable in polynomial time). Therefore, HORN-EXIST-TRUE is also in P, not NP-complete.\n\nBased on this analysis, option E provides the correct and computationally efficient method.", "answer": "$$\\boxed{E}$$", "id": "1427111"}]}