{"hands_on_practices": [{"introduction": "Proof by reduction is the cornerstone of undecidability theory. However, the power of this technique hinges on applying its logic correctly. This first exercise [@problem_id:1457073] presents a common but critical error in reasoning: reversing the direction of the reduction. By analyzing the student's flawed argument, you will solidify your understanding of the correct logical structure required to prove a problem is undecidable.", "problem": "A student in a theory of computation course, Alice, is tasked with proving that a particular language, `TOTAL_TM`, is undecidable. The language is defined as $\\text{TOTAL\\_TM} = \\{ \\langle M \\rangle \\mid M \\text{ is a Turing Machine (TM) that halts on all possible input strings} \\}$.\n\nAlice knows that the standard halting problem, $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ is a TM that halts on input } w \\}$, is a famous undecidable language.\n\nTo prove her claim, she correctly constructs a computable function $f$ that transforms any instance $\\langle M \\rangle$ of `TOTAL_TM` into an instance $\\langle M', w' \\rangle = f(\\langle M \\rangle)$ of $A_{TM}$, such that $\\langle M \\rangle \\in \\text{TOTAL\\_TM}$ if and only if $\\langle M', w' \\rangle \\in A_{TM}$. This establishes a mapping reduction from `TOTAL_TM` to $A_{TM}$ (denoted as $\\text{TOTAL\\_TM} \\le_m A_{TM}$).\n\nAlice then concludes her proof: \"Since I have shown that `TOTAL_TM` is reducible to $A_{TM}$, and we know that $A_{TM}$ is undecidable, it logically follows that `TOTAL_TM` must also be undecidable.\"\n\nWhich of the following statements best explains the fundamental flaw in Alice's reasoning?\n\nA. To prove a language $P$ is undecidable via reduction, one must reduce a known undecidable language $U$ *to* $P$ (i.e., show $U \\le_m P$), not the other way around. Alice's reduction direction is incorrect for her stated purpose.\n\nB. The language `TOTAL_TM` is not Turing-recognizable, whereas $A_{TM}$ is. A mapping reduction is only valid between languages that are in the same class of recognizability (i.e., both are recognizable or both are not).\n\nC. Alice's argument is circular. In order to construct the computable function $f$, she must have implicitly assumed a method for deciding `TOTAL_TM`, which contradicts the claim she is trying to prove.\n\nD. The reduction is invalid because `TOTAL_TM` is known to be a \"harder\" problem than $A_{TM}$. It is a foundational theorem of computability theory that one cannot reduce a computationally harder problem to an easier one.\n\nE. Any reduction from a language that takes a single encoding $\\langle M \\rangle$ as input to a language that takes a pair $\\langle M, w \\rangle$ as input is inherently flawed because it requires manufacturing information (the string $w$) that was not present in the original input.", "solution": "We are given the language $\\text{TOTAL\\_TM} = \\{ \\langle M \\rangle \\mid M \\text{ halts on all inputs} \\}$ and the halting problem $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ halts on } w \\}$, where $A_{TM}$ is known to be undecidable. Alice shows a mapping reduction $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$ and concludes that $\\text{TOTAL\\_TM}$ is undecidable.\n\nRecall the definition: For languages $A$ and $B$, $A \\le_{m} B$ means there exists a total computable function $f$ such that for all strings $x$, \n$$x \\in A \\iff f(x) \\in B.$$\n\nKey property of mapping reductions:\n- If $A \\le_{m} B$ and $B$ is decidable, then $A$ is decidable. Proof: Given a decider for $B$, decide $A$ on input $x$ by computing $f(x)$ and running the decider for $B$; accept iff it accepts. \n- The contrapositive of this statement is: If $A$ is undecidable and $A \\le_{m} B$, then $B$ is undecidable.\n\nTherefore, to prove that a target language $P$ is undecidable by reduction, one must reduce a known undecidable language $U$ to $P$, that is, show $U \\le_{m} P$. Then, if $P$ were decidable, $U$ would be decidable, contradicting the known undecidability of $U$.\n\nAlice instead showed $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$. From the fundamental property above, this implication only yields:\n$$\\text{If } A_{TM} \\text{ were decidable, then } \\text{TOTAL\\_TM} \\text{ would be decidable.}$$\nBut since $A_{TM}$ is undecidable, this conditional tells us nothing about the decidability of $\\text{TOTAL\\_TM}$. Hence Alice’s conclusion does not follow.\n\nA concrete illustration that such a reduction direction does not prove undecidability: Let $L$ be any decidable language. Let $D$ be its decider. Define a computable $f$ that, on input $x$, runs $D(x)$ and outputs a fixed pair $\\langle M_{halt}, w_{halt} \\rangle \\in A_{TM}$ if $D$ accepts, and a fixed pair $\\langle M_{loop}, w_{loop} \\rangle \\notin A_{TM}$ if $D$ rejects. Then $x \\in L \\iff f(x) \\in A_{TM}$, so $L \\le_{m} A_{TM}$, yet $L$ is decidable. Thus, showing $P \\le_{m} A_{TM}$ does not establish that $P$ is undecidable.\n\nTherefore, the fundamental flaw is the direction of the reduction. This corresponds to option A. The other options are incorrect because: mapping reductions do not require equal recognizability status (B is false), constructing $f$ does not assume a decider for $\\text{TOTAL\\_TM}$ (C is false), the “harder to easier” phrasing is not the formal criterion at play (D is misleading), and producing pairs from singles is standard via computable padding or hardcoding (E is false).", "answer": "$$\\boxed{A}$$", "id": "1457073"}, {"introduction": "A natural question that arises when studying Turing machines is whether their complexity is the source of undecidability. Could a simpler computational model, like one with only two counters, escape the grasp of the Halting Problem? This practice [@problem_id:1438132] demonstrates the profound universality of undecidability. You will use the logic of reduction to show that any model that is Turing-complete—that is, powerful enough to simulate a Turing machine—inherits its fundamental limitations.", "problem": "In the field of computability theory, the Halting Problem is a classic example of an undecidable problem. For a given computational model, such as a Turing Machine (TM), the Halting Problem asks: given a description of a machine and an initial input, will the machine eventually halt, or will it run forever? It has been proven that no general algorithm exists that can solve the Halting Problem for all possible inputs for Turing Machines.\n\nA computer science student proposes a new, minimalist computational model called a Two-Counter Machine (2-CM). A 2-CM consists of a finite set of states and two counters, which can each store any non-negative integer. The machine operates based on a simple program of instructions. These instructions can increment a counter, decrement a counter, or perform a conditional jump to another instruction based on whether a counter is currently zero.\n\nThe student conjectures that because the 2-CM model is in_significantly simpler than a Turing Machine (which has an infinite tape), its version of the Halting Problem might be decidable. That is, perhaps an algorithm could exist that determines whether any given 2-CM will halt on a given set of initial counter values.\n\nHowever, a fundamental result in computability theory states that **any Turing Machine can be simulated by a Two-Counter Machine**. This means that for any TM and its input, an equivalent 2-CM can be constructed that halts if and only if the original TM halts.\n\nBased on this information, which of the following statements provides the most accurate conclusion about the decidability of the Halting Problem for Two-Counter Machines (the \"2-CM Halting Problem\")?\n\nA. The 2-CM Halting Problem is undecidable. If it were decidable, one could construct a decider for the TM Halting Problem by first converting the TM into its equivalent 2-CM and then using the 2-CM decider. This would contradict the known undecidability of the TM Halting Problem.\n\nB. The 2-CM Halting Problem is decidable. The simulation of a TM by a 2-CM does not imply they have the same decidability properties. The 2-CM's simpler structure, lacking an infinite tape, allows for an analysis of its state and counter-value cycles, which a TM's infinite tape prevents.\n\nC. The 2-CM Halting Problem is undecidable, but only for 2-CMs that are actively simulating TMs. For 2-CMs that are not constructed as TM simulators, the Halting Problem is decidable due to their limited instruction set.\n\nD. The decidability of the 2-CM Halting Problem cannot be determined from the information given. The fact that a 2-CM can simulate a TM does not provide enough information to draw a conclusion about the properties of the 2-CM itself.\n\nE. The 2-CM Halting Problem is decidable. The simulation capability only means the machines are equivalent in computational power (Turing-complete), but decidability is a separate property related to the problem, not the machine's power.", "solution": "We formalize the halting problems and the reduction argument.\n\nDefine the TM Halting Problem language\n$$\nH_{\\mathrm{TM}}=\\{ \\langle M,x \\rangle \\mid \\text{Turing Machine } M \\text{ halts on input } x \\}.\n$$\nDefine the 2-CM Halting Problem language\n$$\nH_{2\\mathrm{CM}}=\\{ \\langle C,\\vec{v} \\rangle \\mid \\text{Two-Counter Machine } C \\text{ halts on initial counters } \\vec{v} \\}.\n$$\n\nGiven the stated fact that any Turing Machine can be simulated by a Two-Counter Machine with halting behavior preserved, there exists an effective (computable) transformation that, on input an encoding $\\langle M,x \\rangle$, outputs an encoding $\\langle C_{M,x},\\vec{v}_{0} \\rangle$ of a 2-CM with initial counters such that\n$$\n\\langle M,x \\rangle \\in H_{\\mathrm{TM}} \\iff \\langle C_{M,x},\\vec{v}_{0} \\rangle \\in H_{2\\mathrm{CM}}.\n$$\nEquivalently, there exists a computable function $f$ with\n$$\nf(\\langle M,x \\rangle)=\\langle C_{M,x},\\vec{v}_{0} \\rangle \\quad \\text{and} \\quad \\langle M,x \\rangle \\in H_{\\mathrm{TM}} \\iff f(\\langle M,x \\rangle) \\in H_{2\\mathrm{CM}}.\n$$\nThis is a many-one reduction $H_{\\mathrm{TM}} \\leq_{m} H_{2\\mathrm{CM}}$.\n\nAssume for contradiction that $H_{2\\mathrm{CM}}$ is decidable. Then there exists a decider $D_{2\\mathrm{CM}}$ such that for every input $y$, $D_{2\\mathrm{CM}}(y)$ correctly decides membership in $H_{2\\mathrm{CM}}$. Construct a decider $D_{\\mathrm{TM}}$ for $H_{\\mathrm{TM}}$ as follows: on input $\\langle M,x \\rangle$, compute $f(\\langle M,x \\rangle)$ and run $D_{2\\mathrm{CM}}$ on that result; output the same answer. By the equivalence preserved by $f$, this $D_{\\mathrm{TM}}$ decides $H_{\\mathrm{TM}}$.\n\nHowever, it is a fundamental result that $H_{\\mathrm{TM}}$ is undecidable. This contradiction shows that the assumption that $H_{2\\mathrm{CM}}$ is decidable is false. Therefore $H_{2\\mathrm{CM}}$ is undecidable.\n\nEvaluating the options:\n- A correctly states the reduction argument and the contradiction with the known undecidability of $H_{\\mathrm{TM}}$.\n- B and E incorrectly claim decidability; the existence of a computable simulation suffices to transfer undecidability via the reduction above.\n- C is incorrect because undecidability is about the language as a whole; the presence of instances that encode TM behavior suffices to make the overall halting problem undecidable.\n- D is incorrect because the given information is sufficient to conclude undecidability via the many-one reduction.\n\nThus, the correct choice is A.", "answer": "$$\\boxed{A}$$", "id": "1438132"}, {"introduction": "We now shift from proving what is impossible to exploring what would become possible if we had a \"magic box,\" or oracle, that could solve an undecidable problem. This thought experiment is a key technique in computability theory. This problem [@problem_id:1438125] challenges you to design an algorithm that uses a hypothetical Halting Oracle to solve a different, non-trivial problem, sharpening your ability to think algorithmically and construct clever machine transformations.", "problem": "In the study of computability theory, we often explore the limits of what can be computed by algorithm. A central unsolvable problem is the Halting Problem: determining whether an arbitrary Turing Machine (TM) will halt on a given input.\n\nImagine you have been granted access to a hypothetical \"oracle,\" a black-box function named `HALT_ORACLE`. This oracle takes the description of any Turing Machine, `M`, and an input string, `s`, and instantly provides a definitive answer. Specifically, `HALT_ORACLE(M, s)` returns `true` if machine `M` halts when run with input `s`, and `false` if `M` runs forever.\n\nYour task is to use this powerful oracle to solve a different, but related, problem, which we will call the `HW_PROBLEM`. The `HW_PROBLEM` asks: for an arbitrary Turing Machine `P` and an input string `w`, will `P` ever write the specific string \"hello world\" to its output tape during its execution on input `w`?\n\nYou must design an algorithm that serves as a **decider** for the `HW_PROBLEM`. A decider is an algorithm that, for any given input ($P$ and $w$ in this case), is guaranteed to halt and provide the correct \"yes\" or \"no\" answer.\n\nWhich of the following algorithms correctly and always decides the `HW_PROBLEM` for any given TM `P` and input `w`?\n\nA. Construct a machine `D` that takes $\\langle P, w \\rangle$ as input. `D` simulates the execution of `P` on input `w`. If at any point `P` writes \"hello world\" to its output tape, `D` halts and outputs \"yes\". If `P` halts without ever writing \"hello world\", `D` halts and outputs \"no\".\n\nB. Construct a machine `D` that takes $\\langle P, w \\rangle$ as input. `D` first queries the oracle `HALT_ORACLE(P, w)`. If the oracle returns `false`, `D` immediately halts and outputs \"no\". If the oracle returns `true`, `D` then proceeds to simulate `P` on `w` (which is now guaranteed to halt) and checks the final output tape. If \"hello world\" is present, `D` outputs \"yes\"; otherwise, it outputs \"no\".\n\nC. Construct a machine `D` that takes $\\langle P, w \\rangle$ as input. `D` first creates the description of a new Turing Machine, `P_prime`. The machine `P_prime` is designed to ignore its own input. Instead, `P_prime` simulates `P` on input `w`. `P_prime` monitors the output tape of the simulated `P`. If `P` ever writes \"hello world\", `P_prime` immediately halts. If the simulation of `P` halts *without* having written \"hello world\", `P_prime` enters a deliberate infinite loop. After constructing `P_prime`, `D` queries the oracle `HALT_ORACLE(P_prime, \"\")`, where `\"\"` is the empty string. If the oracle returns `true`, `D` outputs \"yes\". If it returns `false`, `D` outputs \"no\".\n\nD. Construct a machine `D` that takes $\\langle P, w \\rangle$ as input. `D` first creates the description of a new Turing Machine, `P_double_prime`. This new machine `P_double_prime` simulates `P` on input `w`. If the simulation of `P` halts, `P_double_prime` then inspects the output tape. If \"hello world\" is present, `P_double_prime` halts. If \"hello world\" is not present, `P_double_prime` enters an infinite loop. After constructing `P_double_prime`, `D` queries the oracle `HALT_ORACLE(P_double_prime, \"\")`. If the oracle returns `true`, `D` outputs \"yes\". If it returns `false`, `D` outputs \"no\".", "solution": "We are asked to decide, for any Turing machine $P$ and input $w$, whether $P$ ever writes the string \"hello world\" during its execution on input $w$. We may use an oracle $\\text{HALT\\_ORACLE}(M,s)$ that returns true if and only if $M$ halts on input $s$, and false otherwise. A correct decider must halt on all inputs and return the correct yes/no answer.\n\nAnalyze each proposed algorithm:\n\nOption A: $D$ simulates $P$ on $w$, answers \"yes\" if it ever observes \"hello world\", and answers \"no\" if $P$ halts without having written \"hello world\". This is not a decider. If $P$ runs forever without ever writing \"hello world\", then $D$ simulates forever and never halts. Hence A fails to always halt.\n\nOption B: $D$ queries $\\text{HALT\\_ORACLE}(P,w)$. If it returns false, $D$ outputs \"no\". If true, $D$ simulates $P$ on $w$ (now guaranteed to halt) and checks the final output for \"hello world\". This is incorrect: there exist machines $P$ that, on input $w$, write \"hello world\" at some finite time and then continue running forever. In such a case, $\\text{HALT\\_ORACLE}(P,w)$ returns false, so $D$ outputs \"no\", but the correct answer to the target problem is \"yes\" because \"hello world\" was written during execution. Hence B is incorrect.\n\nOption C: $D$ constructs $P'$ that ignores its own input and simulates $P$ on $w$, monitoring writes. The behavior of $P'$ is:\n- If $P$ ever writes \"hello world\", then $P'$ immediately halts.\n- If $P$ halts without having written \"hello world\", then $P'$ enters an infinite loop.\n- If $P$ runs forever without writing \"hello world\", then $P'$ runs forever (continuing the simulation).\nThen $D$ queries $\\text{HALT\\_ORACLE}(P',\\epsilon)$ where $\\epsilon$ is the empty string. Correctness:\n- If $P$ on $w$ ever writes \"hello world\", then $P'$ halts, so $\\text{HALT\\_ORACLE}(P',\\epsilon)$ returns true and $D$ outputs \"yes\".\n- If $P$ on $w$ never writes \"hello world\", there are two subcases:\n  1. $P$ halts without writing \"hello world\": then $P'$ loops forever, so the oracle returns false and $D$ outputs \"no\".\n  2. $P$ runs forever without writing \"hello world\": then $P'$ also never halts, so the oracle returns false and $D$ outputs \"no\".\nIn all cases, $D$ halts after a single oracle query and gives the correct answer. Thus C is a valid decider.\n\nOption D: $D$ constructs $P''$ that simulates $P$ on $w$, and only upon detecting that $P$ halts does it inspect the final output; it halts if \"hello world\" is present, and loops otherwise. This fails when $P$ on $w$ writes \"hello world\" and then continues running forever (never halts). In that case, $P''$ never halts because it waits for $P$ to halt before checking, so $\\text{HALT\\_ORACLE}(P'',\\epsilon)$ returns false and $D$ outputs \"no\", which is incorrect because \"hello world\" was indeed written during execution. Hence D is incorrect.\n\nTherefore, only Option C correctly and always decides the problem using the oracle.", "answer": "$$\\boxed{C}$$", "id": "1438125"}]}