{"hands_on_practices": [{"introduction": "Let's begin by exploring how the property of recognizability behaves under a simple but fundamental string operation: reversal. This practice ([@problem_id:1444555]) challenges you to think about how a Turing Machine that recognizes a language $L$ can be modified to handle the language $L_R$, which contains all the reversed strings of $L$. It's an excellent exercise in building new machines from existing components, a core skill in computability theory.", "problem": "In the theory of computation, we classify languages based on the computational power required to process them. A language is a set of strings over some alphabet. A **Turing Machine (TM)** is a mathematical model of computation that defines an abstract machine which manipulates symbols on a strip of tape according to a table of rules.\n\nA language $L$ is called **recognizable** (or recursively enumerable) if there exists a Turing Machine $M$ that, for any input string $w$:\n- If $w \\in L$, then $M$ halts and accepts.\n- If $w \\notin L$, then $M$ either halts and rejects, or it loops forever.\n\nA language $L$ is called **decidable** (or recursive) if there exists a Turing Machine $M$ that halts on all inputs, such that for any input string $w$:\n- If $w \\in L$, then $M$ halts and accepts.\n- If $w \\notin L$, then $M$ halts and rejects.\n\nNote that every decidable language is also recognizable, but not all recognizable languages are decidable.\n\nThe **reversal** of a string $w = w_1w_2...w_n$ is the string written backwards, denoted as $w^R = w_nw_{n-1}...w_1$. The reversal of a language $L$, denoted $L_R$, is the set of all reversed strings from $L$: $L_R = \\{w^R \\mid w \\in L\\}$.\n\nConsider the properties of these language classes under the reversal operation. Which one of the following statements is always true?\n\nA. If a language $L$ is recognizable, then its reversal $L_R$ is also recognizable.\n\nB. If a language $L$ is recognizable, then its reversal $L_R$ is always decidable.\n\nC. A language $L$ is recognizable if and only if its reversal $L_R$ is decidable.\n\nD. If a language $L$ is decidable, its reversal $L_R$ is recognizable but not necessarily decidable.\n\nE. The class of recognizable languages is not closed under the reversal operation.", "solution": "We consider the reversal function $r: \\Sigma^* \\to \\Sigma^*$ defined by $r(w)=w^R$. This function is a total computable bijection with computable inverse $r^{-1}=r$. For any language $L \\subseteq \\Sigma^*$, its reversal is $L_R=\\{w^R\\mid w\\in L\\}=\\{x\\mid r(x)\\in L\\}$.\n\nTo analyze closure properties:\n\n1) If $L$ is recognizable, there exists a Turing machine $M$ such that for all $w$:\n- If $w\\in L$, then $M$ halts and accepts $w$.\n- If $w\\notin L$, then $M$ either halts and rejects $w$ or does not halt.\n\nConstruct a Turing machine $N$ to recognize $L_R$:\n- On input $x$, compute $r(x)=x^R$ (this always halts).\n- Run $M$ on input $r(x)$.\n- If $M$ accepts, accept; if $M$ rejects, reject; if $M$ does not halt, do not halt.\n\nCorrectness: If $x\\in L_R$, then $r(x)\\in L$, so $M$ accepts $r(x)$ and $N$ accepts $x$. If $x\\notin L_R$, then $r(x)\\notin L$, so $M$ either rejects or does not halt on $r(x)$, and accordingly $N$ either rejects or does not halt on $x$. Therefore $L_R$ is recognizable. Hence statement A is true.\n\n2) Statement B is false. There exist recognizable languages that are not decidable, for example the halting language $\\text{HALT} = \\{\\langle M,w\\rangle \\mid M \\text{ halts on } w\\}$, which is recognizable and not decidable. If $L=\\text{HALT}$, then $L_R$ cannot be decidable because, since $r$ is a computable bijection with computable inverse, $L$ would be decidable if and only if $L_R$ were decidable. Thus recognizability of $L$ does not imply decidability of $L_R$.\n\n3) Statement C is false. Taking any recognizable but undecidable $L$ (such as $\\text{HALT}$), $L$ is recognizable while $L_R$ is not decidable, contradicting the “if and only if” claim.\n\n4) Statement D is false. If $L$ is decidable by a decider $D$, construct a decider $D_R$ for $L_R$ by computing $r(x)$ and running $D$ on $r(x)$. Since $D$ halts on all inputs and $r$ is total computable, $D_R$ halts on all inputs, so $L_R$ is decidable. Therefore the qualifier “but not necessarily decidable” is incorrect; it is always decidable.\n\n5) Statement E is false because, as shown in item 1, recognizable languages are closed under reversal.\n\nTherefore, the only always true statement among the options is A.", "answer": "$$\\boxed{A}$$", "id": "1444555"}, {"introduction": "Moving to a more complex language operation, this exercise ([@problem_id:1444599]) investigates the closure of decidable languages under the Kleene star. You'll consider whether the ability to definitively decide membership in a language $L$ is powerful enough to also decide membership in $L^*$, the set of all concatenations of strings from $L$. This problem encourages you to think algorithmically and appreciate how the guarantee of termination for a decider enables more sophisticated computational strategies.", "problem": "In the theory of computation, a language is a set of strings over a finite alphabet $\\Sigma$. A language $L$ is called **decidable** if there exists a Turing Machine $M$ that, for any given input string $w$, halts and accepts if $w \\in L$, and halts and rejects if $w \\notin L$. Such a machine is called a decider.\n\nThe **Kleene star** operation on a language $L$, denoted as $L^*$, is defined as the set of all strings that can be formed by concatenating zero or more strings from $L$. For example, if $L = \\{ \\text{\"ab\"}, \\text{\"c\"} \\}$, then $\\epsilon$ (the empty string), \"ab\", \"c\", \"abc\", \"cab\", \"abab\", \"cc\", etc., are all in $L^*$.\n\nConsider a language $L$ over an alphabet $\\Sigma$. You are given that $L$ is decidable. Based on this information, which of the following statements about the language $L^*$ is always true?\n\nA. $L^*$ is always decidable.\n\nB. $L^*$ is always Turing-recognizable, but may not be decidable.\n\nC. $L^*$ is not necessarily Turing-recognizable.\n\nD. The decidability of $L^*$ depends on whether the empty string, $\\epsilon$, is in $L$.\n\nE. The decidability of $L^*$ cannot be determined without knowing the specific alphabet $\\Sigma$.", "solution": "We are given that a language $L \\subseteq \\Sigma^*$ is decidable. By definition, there exists a Turing Machine decider $D_L$ that halts on every input $x \\in \\Sigma^*$ and accepts exactly those $x \\in L$.\n\nWe must determine a property that always holds for $L^*$, the Kleene star of $L$, defined as\n$$ L^* = \\bigcup_{k=0}^{\\infty} L^k, $$\nwhere $L^0 = \\{\\epsilon\\}$ and $L^k = \\{x_1x_2\\cdots x_k : x_i \\in L \\text{ for all } i\\}$ for $k \\geq 1$.\n\nClaim: $L^*$ is decidable.\n\nProof idea: Construct a decider for $L^*$ from the decider $D_L$. On input $w \\in \\Sigma^*$, we need to determine whether there exists a decomposition of $w$ into a concatenation of finitely many strings from $L$. This can be decided by dynamic programming over the finitely many prefixes of $w$, using only calls to $D_L$, which always halt.\n\nTo avoid complications with empty factors, observe that if $\\epsilon \\in L$, then\n$$ L^* = (L \\setminus \\{\\epsilon\\})^{*}. $$\nProof of this equality: Every concatenation that uses $\\epsilon$ factors can be shortened by removing those factors, yielding a concatenation of nonempty strings from $L \\setminus \\{\\epsilon\\}$; conversely, any concatenation from $L \\setminus \\{\\epsilon\\}$ is in $L^*$. Hence, without loss of generality, we can restrict attention to factorizations into nonempty substrings. Therefore, it suffices to check partitions of $w$ into nonempty substrings, of which there are finitely many.\n\nFormal decider for $L^*$ using dynamic programming:\nGiven input $w \\in \\Sigma^*$, let $n = |w|$. Define a boolean array $A[0], A[1], \\dots, A[n]$ with the intended meaning that $A[i]=1$ iff the prefix $w[0..i-1]$ belongs to $L^*$. Initialize\n$$ A[0] = 1. $$\nFor each $i \\in \\{1, 2, \\dots, n\\}$, set\n$$ A[i] = 1 \\iff \\exists j \\in \\{0, 1, \\dots, i-1\\} \\text{ such that } A[j]=1 \\text{ and } D_L \\text{ accepts } w[j..i-1]. $$\nOtherwise, set $A[i]=0$. After filling $A[1], \\dots, A[n]$, accept $w$ iff $A[n]=1$, and reject otherwise.\n\nCorrectness:\n- Soundness: If $A[n]=1$, then by definition there exists a sequence $0=i_0  i_1  \\dots  i_k=n$ such that for each $t \\in \\{1, \\dots, k\\}$, $D_L$ accepts $w[i_{t-1}..i_t-1]$, hence $w$ is a concatenation of $k$ strings from $L$, so $w \\in L^*$.\n- Completeness: If $w \\in L^*$, then $w$ has some factorization $w = x_1\\cdots x_k$ with each $x_t \\in L$, and each $x_t$ is nonempty by removing any $\\epsilon$ factors as justified above. Let $i_t$ be the cumulative lengths of the prefixes. Then $A[i_t]$ will be set to $1$ inductively by the rule, hence $A[n]=1$.\n\nTermination: The algorithm examines only indices $i,j$ with $0 \\leq j  i \\leq n$, a finite set of pairs. For each such pair, it invokes $D_L$ on the finite substring $w[j..i-1]$, and $D_L$ halts on all inputs by decidability of $L$. Therefore, the overall procedure halts on every input $w$.\n\nConclusion: $L^*$ is decidable whenever $L$ is decidable. Therefore, among the options, A is always true, while B, C, D, and E are false:\n- B is false because we have shown decidability, which is stronger than recognizability.\n- C is false because $L^*$ is not merely recognizable; it is decidable.\n- D is false because the argument does not depend on whether $\\epsilon \\in L$ (the case $\\epsilon \\in L$ is handled by removing $\\epsilon$ without affecting $L^*$).\n- E is false because the alphabet $\\Sigma$ is irrelevant to the decidability argument.\n\nHence the correct choice is A.", "answer": "$$\\boxed{A}$$", "id": "1444599"}, {"introduction": "Our final practice ([@problem_id:1444558]) delves into the heart of the relationship between decidable, recognizable, and co-recognizable languages. By constructing a 'join' language from a decidable language and a recognizable-but-undecidable one, you can directly probe the boundaries of these classes. This exercise provides a concrete way to understand why a language that is recognizable but not co-recognizable cannot be decidable, reinforcing a central theorem of computability theory.", "problem": "In the theory of computation, languages are classified based on the capabilities of abstract machines required to recognize them. A language is called **decidable** if a Turing Machine (TM) exists that halts on every input string, accepting those in the language and rejecting those not in it. A language is called **recognizable** (or recursively enumerable) if a TM exists that halts and accepts every string in the language, and for strings not in the language, it either halts and rejects or loops forever. A language is **co-recognizable** if its complement is recognizable.\n\nLet $D$ and $L$ be two languages over the binary alphabet $\\Sigma = \\{0, 1\\}$. Suppose that $D$ is a decidable language, and $L$ is a recognizable but undecidable language.\n\nConsider a new language, $J$, formed by the \"join\" of $D$ and $L$, defined as:\n$$J = \\{0w \\mid w \\in D\\} \\cup \\{1w \\mid w \\in L\\}$$\nwhere $0w$ denotes the string obtained by prepending the symbol '0' to the string $w$, and $1w$ denotes the string obtained by prepending the symbol '1' to the string $w$.\n\nHow would you classify the language $J$?\n\nA. $J$ is decidable.\n\nB. $J$ is recognizable and co-recognizable.\n\nC. $J$ is recognizable, but not co-recognizable.\n\nD. $J$ is co-recognizable, but not recognizable.\n\nE. $J$ is neither recognizable nor co-recognizable.", "solution": "We use the standard definitions from computability theory. A language is decidable if there exists a Turing machine that halts and correctly decides membership for every input. A language is recognizable if there exists a Turing machine that halts and accepts exactly the strings in the language (and may reject or loop otherwise). A language is co-recognizable if its complement is recognizable. It is a standard theorem that a language is decidable if and only if it is both recognizable and co-recognizable.\n\nFirst, we show that $J$ is recognizable. Since $D$ is decidable, there exists a decider $M_D$ for $D$. Since $L$ is recognizable, there exists a recognizer $M_L$ for $L$. Construct a recognizer $M_J$ for $J$ as follows: On input $x$, if $x$ does not begin with $0$ or $1$, reject. If $x = 0w$, run $M_D$ on $w$ and accept iff $M_D$ accepts (otherwise reject). If $x = 1w$, simulate $M_L$ on $w$ and accept iff $M_L$ accepts (and otherwise continue simulating). This machine halts and accepts exactly those strings in $J$, and on nonmembers starting with $1$ it may run forever. Therefore $J$ is recognizable.\n\nNext, we show $J$ is not decidable. Suppose, for contradiction, that $J$ were decidable. Then the decider for $J$ would decide $L$ by mapping any $w$ to $1w$ and deciding whether $1w \\in J$. This would decide $L$, contradicting that $L$ is undecidable. Hence $J$ is not decidable.\n\nFinally, we show that $J$ is not co-recognizable. Observe that\n$$ \\overline{J} = \\{0w \\mid w \\notin D\\} \\cup \\{1w \\mid w \\notin L\\}. $$\nSince $D$ is decidable, $\\{0w \\mid w \\notin D\\}$ is decidable (hence recognizable). Consider the decidable set $S_1 = \\{1w \\mid w \\in \\Sigma^*\\}$. If $\\overline{J}$ were recognizable, then so would be the intersection\n$$ \\overline{J} \\cap S_1 = \\{1w \\mid w \\notin L\\}. $$\nLet $f:\\Sigma^* \\to \\Sigma^*$ be the computable bijection $f(w) = 1w$. Since recognizability is preserved under inverse images of computable bijections, the recognizability of $\\{1w \\mid w \\notin L\\}$ would imply that $\\overline{L}$ is recognizable. But $L$ is recognizable and undecidable, so $\\overline{L}$ is not recognizable. This is a contradiction. Therefore $\\overline{J}$ is not recognizable, and $J$ is not co-recognizable.\n\nCombining the conclusions: $J$ is recognizable, not decidable, and not co-recognizable. Thus the correct classification is that $J$ is recognizable but not co-recognizable.", "answer": "$$\\boxed{C}$$", "id": "1444558"}]}