{"hands_on_practices": [{"introduction": "This first exercise provides a foundational example of a mapping reduction. We will prove that determining if a Turing machine accepts exactly one string is undecidable. The key technique involves constructing a new machine whose language is either a specific singleton set or the empty set, contingent on the outcome of a known undecidable problem, a powerful \"gatekeeper\" mechanism in computability theory.", "problem": "In computability theory, a central method for proving that a language is undecidable is to show a mapping reduction from a known undecidable language. Let $A_{TM}$ be the acceptance problem for Turing Machines (TMs), defined as $A_{TM} = \\{\\langle M, w \\rangle \\mid M \\text{ is a TM and } M \\text{ accepts string } w\\}$. The language $A_{TM}$ is known to be undecidable.\n\nConsider the language $ONE_{TM}$, defined as the set of all TMs that accept a language containing exactly one string:\n$$ONE_{TM} = \\{\\langle M \\rangle \\mid M \\text{ is a TM and } |L(M)| = 1\\}$$\nwhere $L(M)$ is the language of machine $M$ and $|L(M)|$ denotes the number of strings in that language.\n\nTo prove that $ONE_{TM}$ is undecidable, one can construct a computable function $f$ that takes an input $\\langle M, w \\rangle$ and outputs the description of a new TM, $M'$. This function must satisfy the condition for a mapping reduction: $\\langle M, w \\rangle \\in A_{TM}$ if and only if $\\langle M' \\rangle \\in ONE_{TM}$.\n\nLet $s_0$ be a fixed, non-empty string (e.g., $s_0 = \\text{computation}$). The function $f$ constructs $M'$ based on $M$ and $w$. Which of the following descriptions for the behavior of $M'$ on an arbitrary input string $x$ correctly implements this reduction?\n\nA. On input $x$, $M'$ simulates $M$ on $w$. If this simulation accepts, $M'$ accepts $x$. Otherwise, $M'$ rejects $x$.\n\nB. On input $x$, $M'$ simulates $M$ on $x$. If this simulation accepts, $M'$ also accepts $x$. The machine $M'$ is also hard-coded to accept the string $s_0$ regardless of the behavior of $M$.\n\nC. On input $x$, $M'$ first checks if $x = s_0$. If $x \\neq s_0$, $M'$ immediately rejects. If $x = s_0$, $M'$ then proceeds to simulate $M$ on $w$. If this simulation accepts, $M'$ accepts its input $s_0$. Otherwise, $M'$ rejects.\n\nD. On input $x$, $M'$'s behavior is independent of $M$. It checks if $x = w$. If it is, $M'$ accepts. If $x \\neq w$, $M'$ rejects.", "solution": "We are to construct a computable function $f$ mapping inputs $\\langle M,w \\rangle$ to a TM $M'$ such that\n$$\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in ONE_{TM}.$$\nBy definition, $\\langle M' \\rangle \\in ONE_{TM}$ means $|L(M')|=1$. We fix a specific non-empty string $s_0$.\n\nDefine $f$ as follows: on input $\\langle M,w \\rangle$, output the encoding of the TM $M'$ that on input $x$ performs:\n1. If $x \\neq s_0$, reject.\n2. If $x = s_0$, simulate $M$ on $w$; if the simulation accepts, accept $s_0$; if the simulation halts and rejects, reject $s_0$; if the simulation does not halt, then $M'$ does not halt on $s_0$.\n\nThis $f$ is computable because the description of $M'$ is effectively constructed from the code of $M$, the string $w$, and the fixed string $s_0$ by hard-coding a comparison to $s_0$ and a simulation of $M$ on $w$.\n\nCorrectness:\n- If $\\langle M,w \\rangle \\in A_{TM}$, then $M$ accepts $w$. Therefore, on input $x=s_0$, $M'$ accepts, and on all $x \\neq s_0$, $M'$ rejects. Hence $L(M')=\\{s_0\\}$ and $|L(M')|=1$, so $\\langle M' \\rangle \\in ONE_{TM}$.\n- If $\\langle M,w \\rangle \\notin A_{TM}$, then $M$ does not accept $w$ (either rejects or does not halt). Thus, for $x=s_0$, $M'$ does not accept; for $x \\neq s_0$, $M'$ rejects. Therefore $L(M')=\\emptyset$ and $|L(M')|=0$, so $\\langle M' \\rangle \\notin ONE_{TM}$.\n\nHence $\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in ONE_{TM}$, which matches description C.\n\nWhy the other options fail:\n- Option A makes $L(M')=\\Sigma^*$ if $M$ accepts $w$, and $L(M')=\\emptyset$ otherwise; $|L(M')|$ is never $1$.\n- Option B ensures $s_0 \\in L(M')$ regardless of $M$ and may include additional strings depending on $M$, so $|L(M')|$ is rarely $1$ and does not encode whether $M$ accepts $w$.\n- Option D ignores $M$ entirely and always yields a singleton language $\\{w\\}$, breaking the required equivalence with $A_{TM}$.\n\nTherefore, the correct implementation is option C.", "answer": "$$\\boxed{C}$$", "id": "1431361"}, {"introduction": "Building on the basic reduction pattern, this practice demonstrates its versatility by applying it to a different kind of language property. Instead of checking for the existence of an accepted string, we will prove the undecidability of determining whether a machine accepts *all* strings of even length. This shift from an existential to a universal property highlights how mapping reductions can be adapted to tackle a broader class of problems.", "problem": "In computability theory, one of the fundamental techniques to prove that a language is undecidable is through a mapping reduction. Let $\\Sigma = \\{0, 1\\}$ be the alphabet. Consider the well-known undecidable language of the acceptance problem for Turing Machines (TMs):\n$$A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ is a TM that accepts string } w \\}$$\nNow, consider a different language, $L_{EVEN}$, related to the behavior of TMs on strings of even length:\n$$L_{EVEN} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM and } L(M) \\text{ contains all strings of even length over } \\Sigma \\}$$\nTo prove that $L_{EVEN}$ is undecidable, we can construct a mapping reduction from $A_{TM}$ to $L_{EVEN}$. This requires defining a computable function $f$ that transforms an input $\\langle M, w \\rangle$ into an output $\\langle M' \\rangle$ such that $\\langle M, w \\rangle \\in A_{TM}$ if and only if $\\langle M' \\rangle \\in L_{EVEN}$.\n\nWhich of the following correctly describes the behavior of the machine $M'$ that would be constructed by such a reduction function $f$?\n\nA. On input $x$, machine $M'$ simulates $M$ on $w$. If $M$ accepts $w$, $M'$ rejects $x$. If $M$ does not accept $w$ (it rejects or loops), $M'$ accepts $x$.\n\nB. On input $x$, machine $M'$ simulates $M$ on $w$. If $M$ accepts $w$, $M'$ then simulates $M$ on $x$ and its behavior matches that of $M$ on $x$. If $M$ does not accept $w$, $M'$ rejects $x$.\n\nC. On input $x$, machine $M'$ first checks if the length of $x$, denoted $|x|$, is even. If $|x|$ is odd, $M'$ rejects. If $|x|$ is even, $M'$ ignores $x$ and simulates $M$ on $w$. If the simulation shows $M$ accepts $w$, then $M'$ accepts $x$.\n\nD. On input $x$, machine $M'$ first checks if the length of $x$, denoted $|x|$, is even. If $|x|$ is even, $M'$ accepts. If $|x|$ is odd, $M'$ simulates $M$ on $w$ and accepts if $M$ accepts $w$.", "solution": "We aim to construct a computable function $f$ from instances $\\langle M,w \\rangle$ of $A_{TM}$ to instances $\\langle M' \\rangle$ of $L_{EVEN}$ such that\n$$\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in L_{EVEN}.$$\nRecall $L_{EVEN} = \\{\\langle M \\rangle \\mid E \\subseteq L(M)\\}$ where\n$$E = \\{x \\in \\Sigma^* : |x| \\text{ is even}\\}.$$\n\nDefine $f$ by constructing $M'$ from $\\langle M,w \\rangle$ as follows. On input $x$, machine $M'$:\n1. Checks the parity of $|x|$.\n2. If $|x|$ is odd, $M'$ rejects $x$.\n3. If $|x|$ is even, $M'$ simulates $M$ on $w$. If the simulation accepts, $M'$ accepts $x$; if the simulation does not accept (rejects or does not halt), then $M'$ does not accept $x$.\n\nThis construction is computable because parity checking and hardwiring a fixed simulation of $M$ on $w$ into $M'$ are effective.\n\nCorrectness:\n- If $\\langle M,w \\rangle \\in A_{TM}$, then $M$ accepts $w$. Therefore, for every $x$ with $|x|$ even, $M'$ accepts $x$ by step 3. Thus $E \\subseteq L(M')$, so $\\langle M' \\rangle \\in L_{EVEN}$.\n- If $\\langle M,w \\rangle \\notin A_{TM}$, then $M$ does not accept $w$. Then for every $x$ with $|x|$ even, the simulation in step 3 never leads to acceptance, so $M'$ does not accept such $x$. Hence there exists an even-length string not in $L(M')$, so $E \\nsubseteq L(M')$ and $\\langle M' \\rangle \\notin L_{EVEN}$.\n\nTherefore, this $M'$ satisfies the required iff condition, and the described behavior matches option C.\n\nChecking alternatives:\n- A inverts the condition, making $L(M') = \\Sigma^*$ when $M$ does not accept $w$, and empty when $M$ accepts $w$, which does not yield $E \\subseteq L(M')$ iff $M$ accepts $w$.\n- B makes $L(M')$ depend on $L(M)$ on arbitrary $x$ when $M$ accepts $w$, which does not guarantee inclusion of all even strings.\n- D makes all even strings accepted regardless of $M$ and $w$, breaking the reduction.\n\nThus, the correct description is C.", "answer": "$$\\boxed{C}$$", "id": "1431374"}, {"introduction": "This final practice illustrates the full power and generality of mapping reducibility by applying it to a non-standard model of computation. We will prove that determining whether the two heads of a special type of Turing machine will ever collide is an undecidable problem. This exercise requires translating an abstract property like halting into a physical event in a different computational system, demonstrating that reductions are a fundamental tool for comparing the complexity of problems across diverse settings.", "problem": "In computability theory, a standard Turing Machine (TM) is a model of computation with a single infinite tape and a single read/write head. A two-headed, single-tape Turing machine (2-HTM) is a variant that possesses a single infinite tape but features two independent read/write heads, let's call them $H_1$ and $H_2$. The machine's transition function is of the form $\\delta: Q \\times \\Gamma^2 \\to Q \\times \\Gamma^2 \\times \\{L, R, S\\}^2$, where $Q$ is the set of states, $\\Gamma$ is the tape alphabet, and $\\{L, R, S\\}$ represents the head movements Left, Right, and Stay, respectively. This means the machine's next move is determined by its current state and the symbols read by both heads.\n\nA 2-HTM $T$ is said to experience a \"head collision\" if, at any point during its computation, its two heads $H_1$ and $H_2$ come to occupy the same cell on the tape.\n\nLet's define two languages. First, the well-known undecidable halting problem for TMs:\n$HALT_{TM} = \\{\\langle M, w \\rangle \\mid M \\text{ is a TM that halts on input string } w\\}$.\n\nSecond, a language concerning the behavior of 2-HTMs:\n$HEAD_{COLLIDE} = \\{\\langle T \\rangle \\mid T \\text{ is a 2-HTM that, when started on a completely blank tape, eventually has a head collision}\\}$.\n\nTo prove that $HEAD_{COLLIDE}$ is undecidable, we can construct a mapping reduction from $HALT_{TM}$. This requires defining a computable function $f$ that transforms any given input $\\langle M, w \\rangle$ into the description of a specific 2-HTM, denoted as $T = f(\\langle M, w \\rangle)$. This transformation must satisfy the core property of mapping reducibility: $M$ halts on $w$ if and only if $T$ has a head collision when started on a blank tape.\n\nWhich of the following statements provides the most effective and direct strategy for constructing the 2-HTM $T$ in a way that correctly implements the reduction $HALT_{TM} \\le_m HEAD_{COLLIDE}$?\n\nA. The machine $T$ positions its heads $H_1$ and $H_2$ at opposite ends of a tape segment. $H_1$ simulates the run of $M$ on $w$, while $H_2$ moves one step towards $H_1$ for each step of the simulation. A collision is guaranteed to happen if and only if $M$ runs forever.\n\nB. One head of $T$, say $H_1$, is used to carry out a simulation of the TM $M$ on input $w$ on one section of the tape. The other head, $H_2$, is kept stationary at a designated \"target\" cell, away from the simulation area. If and only if the simulation of $M$ reaches a halting state, $T$ enters a special state where it directs $H_1$ to move to the target cell, thus causing a collision.\n\nC. The two heads of $T$, $H_1$ and $H_2$, start at the same cell. $H_1$ remains stationary, while $H_2$ writes the input $w$ and then travels infinitely to the right. The simulation of $M$ on $w$ is encoded entirely within the finite state control of $T$. A collision occurs at the very first step, making membership in $HEAD_{COLLIDE}$ trivial and independent of the behavior of $M$.\n\nD. Both heads $H_1$ and $H_2$ are used to simulate the computation of $M$ on $w$. $H_1$ simulates the left half of the tape of $M$, and $H_2$ simulates the right half. The heads collide at the tape's center point if $M$'s computation requires its head to cross from one half to the other, an event which is engineered to correspond to $M$ halting.\n\nE. The machine $T$ simulates $M$ on $w$ using head $H_1$. Head $H_2$ perfectly mirrors the movements of $H_1$ (e.g., if $H_1$ moves left, $H_2$ moves left) but on a separate, parallel track of symbols on the same tape. If the simulation of $M$ halts, $T$ enters a cleanup phase where $H_2$ is moved onto $H_1$'s track to cause a collision.", "solution": "We seek a computable mapping $f$ from pairs $\\langle M,w \\rangle$ to encodings $\\langle T \\rangle$ of two-headed, single-tape TMs such that\n$$\n\\langle M,w \\rangle \\in HALT_{TM} \\iff \\langle T \\rangle \\in HEAD_{COLLIDE}.\n$$\nThe most direct construction is to let one head simulate $M$ on $w$ and keep the other head fixed at a designated target cell. Only when the simulated computation halts do we send the simulating head to the target cell to force a head collision.\n\nFormalizing this strategy: given $\\langle M,w \\rangle$, define $T=f(\\langle M,w \\rangle)$ as follows.\n\n1. Initialization on a blank tape. Using its two heads $H_1$ and $H_2$, $T$ performs a finite setup:\n- Choose a designated target cell (e.g., physical tape position $0$). Write a unique marker symbol $\\#$ at that cell. Place $H_2$ at this target cell and keep it stationary forever thereafter; this is enforced by the transition function by always outputting the movement $S$ for $H_2$.\n- Choose a simulation region disjoint from the target cell. To ensure disjointness forever, fix a computable bijection $g:\\mathbb{Z}\\to\\mathbb{N}$ and represent the simulated tape cell $i\\in\\mathbb{Z}$ at the physical tape position $p(i)=-g(i)-1$. Thus every simulated cell is stored at a strictly negative physical position. Place $H_1$ in the simulation region (e.g., at $p(0)$) and ensure the target cell at position $0$ is never used by the simulation.\n\n2. Encoding the input. Program $T$ so that the simulated initial tape of $M$ on input $w$ is written by $H_1$ into the simulation region: for each $i$ corresponding to a symbol of $w$, write that symbol at $p(i)$, and write blanks elsewhere. This is a finite, computable initialization.\n\n3. Simulation phase. While the simulated machine $M$ has not reached a halting state, $T$ uses $H_1$ to simulate one step of $M$:\n- Maintain within the finite control the current simulated state of $M$ and the current simulated head index $i\\in\\mathbb{Z}$.\n- To read or write the simulated cell $i$, move $H_1$ to physical position $p(i)$, read or write the symbol stored there, update the simulated state according to $M$’s transition function, and update $i$ to $i-1$, $i$, or $i+1$ accordingly. Because $p(i)$ is always strictly negative, $H_1$ never visits the target cell at position $0$ during this simulation phase. Meanwhile, $H_2$ stays stationary at the target cell.\n\n4. Collision-on-halting phase. If and only if the simulated $M$ enters a halting state, $T$ transitions to a special phase in which it ignores the simulation data and repeatedly moves $H_1$ to the right until it reaches the target cell at position $0$, where $H_2$ is stationary. The first time $H_1$ reaches position $0$, the two heads occupy the same cell, i.e., a head collision occurs.\n\nCorrectness of the reduction:\n- If $M$ halts on $w$, then the simulation phase reaches a halting simulated state in finite time, and $T$ enters the collision-on-halting phase. In that phase, $H_1$ moves right to the target cell and collides with $H_2$. Hence $\\langle T \\rangle \\in HEAD_{COLLIDE}$.\n- If $M$ does not halt on $w$, then the simulation phase never halts. Throughout the simulation, $H_1$ is confined to strictly negative positions and $H_2$ remains stationary at position $0$. Therefore no collision ever occurs, and $\\langle T \\rangle \\notin HEAD_{COLLIDE}$.\n\nComputability of $f$: Given $\\langle M,w \\rangle$, the description of $T$ is produced effectively by hardwiring $M$ and $w$ into $T$’s finite control and using the fixed computable $g$ to locate simulated cells. Thus $f$ is computable and satisfies the required bi-implication.\n\nTherefore the reduction $HALT_{TM} \\le_m HEAD_{COLLIDE}$ is achieved by the strategy described above, which matches option B.\n\nWhy the other options fail or are inferior:\n- A inverts the condition (it suggests collision iff $M$ runs forever), which does not realize the required mapping to $HEAD_{COLLIDE}$.\n- C makes collision immediate and independent of $M$ and $w$, yielding no reduction.\n- D ties collision to a head-crossing event rather than halting, which does not, in general, correspond to $M$ halting.\n- E could be engineered but introduces unnecessary complexity and ambiguities about “separate tracks” on a single tape; B is the direct, standard construction that cleanly enforces collision iff halting.\n\nHence the most effective and direct strategy is B.", "answer": "$$\\boxed{B}$$", "id": "1431410"}]}