{"hands_on_practices": [{"introduction": "A core concept in computability theory is that a Turing Machine can perform any task that follows a clear, mechanical algorithm. This exercise brings that idea to life by asking you to think through the design of a Turing Machine that decides a language representing binary addition. By considering how a TM would handle something as fundamental as arithmetic, you'll gain a concrete understanding of how states, tape symbols, and head movements come together to create a decider for a non-trivial language [@problem_id:1419574].", "problem": "Consider the language $L$ over the alphabet $\\Sigma = \\{0, 1, +, =\\}$. The language consists of all strings that represent a valid binary addition. A string $w$ is in $L$ if and only if it has the form $x+y=z$, where $x, y, z$ are non-empty strings of characters from $\\{0, 1\\}$, and the numerical value of the binary string $x$ added to the numerical value of the binary string $y$ equals the numerical value of the binary string $z$. For example, the string \"101+10=111\" is in $L$ because the binary number 101 (decimal 5) plus the binary number 10 (decimal 2) equals the binary number 111 (decimal 7). The string \"1+1=10\" is also in $L$. However, the string \"11+1=101\" is not in $L$.\n\nA deterministic, single-tape Turing Machine (TM) is to be designed to decide this language $L$. We are interested in the core computational logic of the TM after it has performed an initial scan to verify that the input string contains exactly one '+' symbol and exactly one '=' symbol, with the '+' appearing before the '='.\n\nWhich of the following high-level descriptions outlines a correct procedure for the TM to complete the decision process, starting from the verified format?\n\nA. The TM finds the operand strings $x$ and $y$. It pads the shorter operand with leading zeros until it has the same length as the longer operand. Then, it moves bit-by-bit from right to left, performing a bitwise XOR operation on the corresponding bits of the padded $x$ and $y$. The resulting string is then compared bit-by-bit with the string $z$. The TM accepts if and only if the result of the XOR operation is identical to $z$.\n\nB. The TM replaces the '+' and '=' symbols with a blank symbol. It then repeatedly scans the entire tape. In each scan, it finds the rightmost '1' in the string corresponding to $x$ and the rightmost '1' in the string corresponding to $y$, changes both to '0', and finds the leftmost '0' in the string corresponding to $z$ and changes it to a '1'. The TM accepts if, after this process finishes (no more '1's in $x$ or $y$), the string $z$ consists of all '1's.\n\nC. The TM works from right to left. It marks the rightmost digit of $z$, then the rightmost digit of $y$, then the rightmost digit of $x$. It rejects if the sum of the digits from $x$ and $y$ does not match the digit from $z$ (e.g., if $x$ has a '1', $y$ has a '0', and $z$ has a '0'). It does not use its internal state to handle carries. If the sum is 2 (from '1'+'1'), it simply checks that the corresponding digit in $z$ is '0'. It continues this process, moving left one digit at a time, until all digits are marked. It accepts if all checks pass.\n\nD. The TM uses its finite control (internal state) to remember a carry bit, initially set to 0. It works from right to left across the three numbers. In each step, it reads the rightmost unmarked digits of $x$ and $y$ (treating the ends of shorter numbers as 0) and adds them with the carry. It verifies that the sum modulo 2 matches the corresponding digit of $z$. If it does not match, the TM rejects. It then updates the carry bit to be the integer part of the sum divided by 2. To avoid reprocessing digits, it marks each processed digit (e.g., replaces '0' with $0_m$ and '1' with $1_m$). After processing all digits of $x$ and $y$, it verifies that any remaining digits of $z$ are consistent with the final carry value. If all checks pass, the TM accepts.", "solution": "We assume the input has already been verified to contain exactly one occurrence each of the symbols '+' and '=', with '+' to the left of '=', and that $x$, $y$, $z$ are the three non-empty binary substrings. Correctness of deciding $L$ reduces to checking standard binary addition with carry: for each bit position $i$ from right to left, if $a_{i}$ is the $i$-th bit of $x$ (or $0$ if $i$ exceeds the length), $b_{i}$ the $i$-th bit of $y$ (or $0$), and $k$ the incoming carry at that step, then the expected output bit is\n$$\ns_{i} \\equiv a_{i} + b_{i} + k \\pmod{2},\n$$\nand the outgoing carry is\n$$\nk' = \\left\\lfloor \\frac{a_{i} + b_{i} + k}{2} \\right\\rfloor.\n$$\nA correct TM must implement exactly this logic while moving right-to-left and preventing reprocessing of digits (e.g., by marking processed symbols).\n\nWe now analyze each option:\n\nA. This proposes padding the shorter operand with leading zeros and computing a bitwise XOR of the padded $x$ and $y$, then comparing to $z$. Bitwise XOR corresponds to computing $(a_{i} + b_{i}) \\bmod 2$ at each position but never propagates carries. Therefore it does not implement $k' = \\left\\lfloor (a_{i} + b_{i} + k)/2 \\right\\rfloor$. A simple counterexample is $x=1$, $y=1$, $z=10$. The XOR of $1$ and $1$ is $0$, which does not match $z=10$, so this procedure would reject a valid string. Hence A is incorrect.\n\nB. This repeatedly pairs the rightmost '1' in $x$ with the rightmost '1' in $y$ and flips the leftmost '0' in $z$ to '1', accepting if $z$ becomes all '1's at the end. This procedure ignores positional weights $2^{i}$ and only manipulates counts and extreme positions, so it does not correspond to binary addition with carries. For instance, consider $x=1$, $y=0$, $z=1$, which is valid. Since $y$ has no '1', there is no pair of rightmost '1's to process; the algorithm cannot proceed to eliminate the '1' in $x$ and cannot reach a correct accepting configuration. Thus it fails to accept a valid input and does not decide $L$. Hence B is incorrect.\n\nC. This checks the sum of the two operand bits against the $z$ bit at each position but explicitly does not use any carry. Using the equations above, this wrongly enforces $s_{i} \\equiv a_{i} + b_{i} \\pmod{2}$ with $k \\equiv 0$ at all positions. For $x=1$, $y=1$, $z=10$, at the least significant bit we have $a_{0}+b_{0}=2$, $z_{0}=0$, so it passes that position, but at the next position it effectively checks $0+0$ against $z_{1}=1$ and rejects. Therefore C incorrectly rejects a valid input. Hence C is incorrect.\n\nD. This matches the standard algorithm for binary addition with carry. The TM uses a carry bit $k \\in \\{0,1\\}$ in its finite control, initially $0$. At each step it:\n- Locates the rightmost unmarked digits of $x$ and $y$ (treating positions beyond the left ends as $0$), and the corresponding rightmost unmarked digit of $z$.\n- Computes $t = a_{i} + b_{i} + k$, checks that $z_{i} \\equiv t \\bmod 2$. If not, it rejects.\n- Updates the carry to $k' = \\left\\lfloor t/2 \\right\\rfloor$.\n- Marks the processed digits (e.g., replaces $0$ with $0_{m}$ and $1$ with $1_{m}$) to avoid reprocessing and moves one position left to repeat.\n\nAfter all digits of $x$ and $y$ are marked, it verifies the remaining $z$ digits are consistent with the final carry: if $k=1$, it requires exactly one remaining $z$ digit equal to $1$ followed by only $0$ digits (or no more digits if already matched earlier); if $k=0$, it requires all remaining $z$ digits to be $0$. This is precisely the semantics of\n$$\ns_{i} \\equiv a_{i} + b_{i} + k \\pmod{2}, \\quad k' = \\left\\lfloor \\frac{a_{i} + b_{i} + k}{2} \\right\\rfloor,\n$$\nimplemented right-to-left with marking to ensure termination and correctness. Therefore D outlines a correct decision procedure for $L$.\n\nConclusion: Only D provides a correct high-level description for a TM deciding $L$ after the initial format check.", "answer": "$$\\boxed{D}$$", "id": "1419574"}, {"introduction": "To truly grasp the power of Turing machines, it's essential to understand what they can do that simpler computational models, like pushdown automata, cannot. This practice presents a language defined by a multiplicative relationship between the counts of its symbols. Your task is to classify this language within the Chomsky hierarchy, which will require you to demonstrate why it is beyond the reach of context-free grammars but still decidable by a Turing machine, thereby sharpening your understanding of these crucial class boundaries [@problem_id:1419581].", "problem": "A bio-engineering team is studying synthetic polymers that mimic certain properties of Deoxyribonucleic acid (DNA). These polymers are strings constructed from an alphabet of three distinct monomers: Type-A, Type-B, and Type-C. A polymer is designated \"structurally stable\" if and only if it adheres to a strict formation rule. This rule requires that the polymer must consist of a contiguous block of one or more Type-A monomers, immediately followed by a contiguous block of one or more Type-B monomers, which is in turn immediately followed by a contiguous block of one or more Type-C monomers. Furthermore, a crucial condition for stability is that the number of Type-C monomers must be exactly equal to the product of the number of Type-A monomers and the number of Type-B monomers.\n\nLet $L$ be the language of all strings representing structurally stable polymers over the alphabet $\\Sigma = \\{A, B, C\\}$. This language can be formally expressed as $L = \\{ A^i B^j C^k \\mid i \\ge 1, j \\ge 1, \\text{ and } k = i \\times j \\}$.\n\nBased on the Chomsky hierarchy and the theory of computation, what is the most precise classification for the language $L$?\n\nA. $L$ is a regular language.\nB. $L$ is a context-free language, but not a regular language.\nC. $L$ is a decidable language (also known as a recursive language), but not a context-free language.\nD. $L$ is a Turing-recognizable language (also known as a recursively enumerable language), but not a decidable language.\nE. $L$ is not a Turing-recognizable language.", "solution": "We analyze the formal language $L = \\{ A^{i} B^{j} C^{k} \\mid i \\ge 1, j \\ge 1, k = i \\times j \\}$ over $\\Sigma = \\{A,B,C\\}$.\n\nFirst, $L$ is not regular. Assume for contradiction that $L$ is regular. Consider the regular language $R_{1} = A^{+}BC^{+}$, which enforces exactly one $B$. Then\n$$\nL \\cap R_{1} = \\{ A^{i} B C^{i} \\mid i \\ge 1 \\}.\n$$\nDefine the homomorphism $h$ by $h(A) = a$, $h(B) = \\epsilon$, and $h(C) = c$. By closure of regular languages under intersection with regular languages and under homomorphisms, $h(L \\cap R_{1})$ would be regular if $L$ were regular. But $h(L \\cap R_{1}) = \\{ a^{i} c^{i} \\mid i \\ge 1 \\}$, which is not regular by the pumping lemma for regular languages. This contradiction shows $L$ is not regular.\n\nSecond, $L$ is not context-free. Let $\\Psi(L) \\subseteq \\mathbb{N}^{3}$ denote the Parikh image of $L$, namely\n$$\n\\Psi(L) = \\{ (i,j,k) \\in \\mathbb{N}^{3} \\mid i \\ge 1, j \\ge 1, k = i \\times j \\}.\n$$\nBy Parikhâ€™s theorem, the Parikh image of any context-free language is semilinear. Suppose, for contradiction, that $L$ were context-free. Then $\\Psi(L)$ would be semilinear. Intersect $\\Psi(L)$ with the linear set\n$$\nM = \\{ (n,n,k) \\mid n \\in \\mathbb{N}, k \\in \\mathbb{N} \\},\n$$\nwhich is closed under intersection with semilinear sets. We obtain\n$$\n\\Psi(L) \\cap M = \\{ (n,n,k) \\mid k = n^{2}, n \\ge 1 \\}.\n$$\nProjecting onto the third coordinate (a linear mapping, under which semilinear sets are closed) yields the set of perfect squares\n$$\n\\{ n^{2} \\mid n \\ge 1 \\}.\n$$\nHowever, subsets of $\\mathbb{N}$ that are semilinear are precisely finite unions of arithmetic progressions, and the set of squares is not a finite union of arithmetic progressions (the gaps between consecutive squares grow unbounded). This contradiction shows $L$ is not context-free.\n\nThird, $L$ is decidable (recursive). A deterministic Turing machine can decide $L$ by:\n1) Verifying the input is of the form $A^{+} B^{+} C^{+}$.\n2) Let $i$ be the number of $A$ symbols and $j$ the number of $B$ symbols. For each of the $j$ copies of $B$, cross off exactly $i$ symbols from the block of $C$ (simulating repeated addition to check $k = i \\times j$). Accept if and only if exactly all $C$ symbols are exhausted after processing all $B$ symbols, with no leftovers or deficits. This halts on all inputs, so $L$ is decidable.\n\nCombining these, $L$ is decidable but not context-free and not regular. Among the provided options, the most precise classification is that $L$ is a decidable language (recursive) but not context-free.", "answer": "$$\\boxed{C}$$", "id": "1419581"}, {"introduction": "In computational complexity theory, we often prove a problem is decidable not by building a new Turing machine from scratch, but by showing how to solve it using a decider for another, already-known decidable problem. This powerful technique is called reduction. This exercise challenges you to use this method, leveraging a given decider for the emptiness of context-free grammars ($E_{CFG}$) to construct a decider for the non-emptiness of pushdown automata, highlighting the practical equivalence between these two models and the elegance of reducibility proofs [@problem_id:1419579].", "problem": "Suppose you work for a company that develops compiler construction tools. You are given a specialized Turing machine, let's call it $D_{EMPTY\\_GRAMMAR}$, that functions as a decider for the language $E_{CFG}$. The language $E_{CFG}$ is defined as the set of all string encodings $\\langle G \\rangle$ of Context-Free Grammars (CFGs) for which the language generated by the grammar, $L(G)$, is the empty set ($\\emptyset$). In other words, on input $\\langle G \\rangle$, the decider $D_{EMPTY\\_GRAMMAR}$ accepts if $L(G) = \\emptyset$ and rejects if $L(G) \\neq \\emptyset$.\n\nYour task is to leverage this existing tool to design a new decider, which we will call $D_{NONEMPTY\\_AUTOMATON}$. This new decider must solve the non-emptiness problem for Pushdown Automata (PDAs). Specifically, for any given PDA $P$, the decider $D_{NONEMPTY\\_AUTOMATON}$ should accept the encoding $\\langle P \\rangle$ if the language of the PDA, $L(P)$, contains at least one string (i.e., $L(P) \\neq \\emptyset$), and it should reject $\\langle P \\rangle$ if $L(P)$ is empty.\n\nWhich of the following descriptions accurately outlines a valid high-level algorithm for constructing $D_{NONEMPTY\\_AUTOMATON}$ using the provided decider $D_{EMPTY\\_GRAMMAR}$? Note that $\\langle P \\rangle$ denotes the string encoding of the input PDA $P$.\n\nA. Convert the PDA $P$ into an equivalent regular expression $R$. Run $D_{EMPTY\\_GRAMMAR}$ on the encoding of $R$. If $D_{EMPTY\\_GRAMMAR}$ accepts, then $D_{NONEMPTY\\_AUTOMATON}$ rejects. Otherwise, $D_{NONEMPTY\\_AUTOMATON}$ accepts.\nB. Convert the PDA $P$ into an equivalent Context-Free Grammar $G$. Run $D_{EMPTY\\_GRAMMAR}$ on the encoding $\\langle G \\rangle$. If $D_{EMPTY\\_GRAMMAR}$ accepts, then $D_{NONEMPTY\\_AUTOMATON}$ rejects. Otherwise, $D_{NONEMPTY\\_AUTOMATON}$ accepts.\nC. Convert the PDA $P$ into an equivalent Context-Free Grammar $G$. Run $D_{EMPTY\\_GRAMMAR}$ on the encoding $\\langle G \\rangle$. If $D_{EMPTY\\_GRAMMAR}$ accepts, then $D_{NONEMPTY\\_AUTOMATON}$ accepts. Otherwise, $D_{NONEMPTY\\_AUTOMATON}$ rejects.\nD. This is impossible. The problem of determining if a PDA accepts any string is undecidable, so no such decider as $D_{NONEMPTY\\_AUTOMATON}$ can be constructed.\nE. Construct a new PDA, $P'$, that accepts the complement language of $P$. Convert this new PDA $P'$ into an equivalent Context-Free Grammar, $G'$. Run $D_{EMPTY\\_GRAMMAR}$ on $\\langle G' \\rangle$. If $D_{EMPTY\\_GRAMMAR}$ accepts, then $D_{NONEMPTY\\_AUTOMATON}$ accepts. Otherwise, it rejects.", "solution": "We are given a decider $D_{EMPTY\\_GRAMMAR}$ for the language $E_{\\text{CFG}}=\\{\\langle G\\rangle \\mid \\text{$G$ is a CFG and } L(G)=\\emptyset\\}$. We must build a decider $D_{NONEMPTY\\_AUTOMATON}$ that, on input $\\langle P\\rangle$ for a PDA $P$, accepts iff $L(P)\\neq\\emptyset$ and rejects iff $L(P)=\\emptyset$.\n\nKey principle: For every PDA $P$ there exists an effectively constructible CFG $G$ such that $L(G)=L(P)$, and conversely. The standard PDA-to-CFG construction is total and terminates.\n\nAlgorithm using $D_{EMPTY\\_GRAMMAR}$:\n1. On input $\\langle P\\rangle$, effectively construct a CFG $G$ with $L(G)=L(P)$.\n2. Run $D_{EMPTY\\_GRAMMAR}$ on $\\langle G\\rangle$.\n3. If $D_{EMPTY\\_GRAMMAR}$ accepts (i.e., $L(G)=\\emptyset$), then output reject; otherwise (i.e., $L(G)\\neq\\emptyset$), output accept.\n\nCorrectness:\n- Soundness: If $D_{EMPTY\\_GRAMMAR}$ accepts, then $L(G)=\\emptyset$. Since $L(G)=L(P)$, it follows that $L(P)=\\emptyset$, so $D_{NONEMPTY\\_AUTOMATON}$ must reject. If $D_{EMPTY\\_GRAMMAR}$ rejects, then $L(G)\\neq\\emptyset$, hence $L(P)\\neq\\emptyset$, so $D_{NONEMPTY\\_AUTOMATON}$ accepts.\n- Termination: The PDA-to-CFG conversion terminates, and $D_{EMPTY\\_GRAMMAR}$ is a decider, so the composed procedure halts on all inputs.\n\nEvaluation of options:\n- A is invalid because a general PDA need not be equivalent to a regular expression; PDAs recognize context-free languages, which are in general not regular.\n- B matches the algorithm above and is valid.\n- C reverses the accept/reject mapping from $D_{EMPTY\\_GRAMMAR}$ and is therefore incorrect.\n- D is false; PDA non-emptiness is decidable via the CFG equivalence and emptiness check.\n- E is invalid because context-free languages are not closed under complement in general, so constructing a PDA (or CFG) for the complement of $L(P)$ is not generally possible.\n\nThus, the correct high-level algorithm is described in option B.", "answer": "$$\\boxed{B}$$", "id": "1419579"}]}