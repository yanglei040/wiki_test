{"hands_on_practices": [{"introduction": "Calculating implied volatility is a cornerstone of modern financial engineering, but it presents a classic inverse problem as the Black-Scholes formula cannot be analytically solved for volatility. This first exercise guides you through implementing the Newton-Raphson method, a powerful and widely used numerical technique, to build your own solver. Mastering this practice [@problem_id:2400522] provides the fundamental computational skill for translating observed market prices into the crucial language of implied volatility.", "problem": "You are to implement a program that, for a set of European options on a non-dividend-paying asset under the Black–Scholes model, computes the implied volatility defined as the unique nonnegative value of the annualized standard deviation that, when substituted into the Black–Scholes price, matches a given observed option price. Let $S$ denote the spot price, $K$ the strike price, $r$ the continuously compounded risk-free rate, $T$ the time to maturity (in years), $\\sigma$ the annualized volatility (in decimal form), $\\Phi(\\cdot)$ the cumulative distribution function (CDF) of the standard normal distribution, and $\\phi(\\cdot)$ its probability density function (PDF). For a European call option,\n$$\nC(S,K,r,T,\\sigma) \\;=\\; S\\,\\Phi(d_1) \\;-\\; K\\,e^{-rT}\\,\\Phi(d_2),\n$$\nand for a European put option,\n$$\nP(S,K,r,T,\\sigma) \\;=\\; K\\,e^{-rT}\\,\\Phi(-d_2) \\;-\\; S\\,\\Phi(-d_1),\n$$\nwhere\n$$\nd_1 \\;=\\; \\frac{\\ln(S/K) + \\left(r + \\tfrac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}, \n\\qquad\nd_2 \\;=\\; d_1 - \\sigma\\sqrt{T}.\n$$\nThe implied volatility for a given observed option price $p_{\\text{obs}}$ is the value $\\sigma^\\star \\ge 0$ such that the corresponding Black–Scholes price equals $p_{\\text{obs}}$. If $p_{\\text{obs}}$ is at the no-arbitrage lower bound (i.e., $p_{\\text{obs}} = \\max\\{0, S - K e^{-rT}\\}$ for a call or $p_{\\text{obs}} = \\max\\{0, K e^{-rT} - S\\}$ for a put), then the implied volatility must be $0$. All outputs must be in annualized volatility units (decimal, not a percentage).\n\nYour program must compute the implied volatility for each of the following test cases, treating the option type as either call ($\\text{C}$) or put ($\\text{P}$), and all times $T$ as measured in years:\n\n- Test case $1$: type $\\text{C}$, $S=100.0$, $K=100.0$, $r=0.0$, $T=1.0$, observed price $68.268949213709$.\n- Test case $2$: type $\\text{C}$, $S=60.653065971263$, $K=100.0$, $r=0.0$, $T=1.0$, observed price $14.461007592486$.\n- Test case $3$: type $\\text{P}$, $S=60.653065971263$, $K=100.0$, $r=0.0$, $T=1.0$, observed price $53.807941621223$.\n- Test case $4$: type $\\text{C}$, $S=120.0$, $K=100.0$, $r=0.0$, $T=1.0$, observed price $20.0$.\n- Test case $5$: type $\\text{P}$, $S=80.0$, $K=100.0$, $r=0.0$, $T=1.0$, observed price $20.0$.\n- Test case $6$: type $\\text{C}$, $S=100.0$, $K=100.0$, $r=0.0$, $T=1.0$, observed price $7.965567455406$.\n\nYour program must produce a single line of output containing the implied volatilities for the test cases in order, rounded to exactly six digits after the decimal point. The output format must be a single list on one line as a comma-separated list enclosed in square brackets, with no extra whitespace. For example, the output format must look like \"[v1,v2,v3,v4,v5,v6]\" where each $v_i$ is a float rounded to six decimal places.\n\nThe program must be self-contained and must not read any input. The final answers must be floats in decimal form (not percentages). Ensure numerical stability and correct handling for cases that lie on the no-arbitrage lower bound. The data above are scientifically grounded, and each case admits a unique nonnegative implied volatility consistent with the Black–Scholes model and the no-arbitrage bounds. The set of cases provides coverage of general behavior, deep in-the-money (ITM) and out-of-the-money (OTM) regimes, and boundary conditions. The final output must aggregate the six results as specified on a single line.", "solution": "The problem requires the computation of implied volatility, $\\sigma^\\star$, for a set of European options, given their observed market prices, $p_{\\text{obs}}$. This is a classic inverse problem in quantitative finance. The implied volatility is defined as the value of the volatility parameter, $\\sigma$, that makes the theoretical Black-Scholes price of an option equal to its observed price.\n\nThe core of the task is to solve the equation $f(\\sigma) = 0$ for $\\sigma \\ge 0$, where $f(\\sigma)$ is the difference between the Black-Scholes price and the observed price:\n$$\nf(\\sigma) = \\text{BS}(S, K, r, T, \\sigma) - p_{\\text{obs}} = 0\n$$\nHere, $\\text{BS}(S, K, r, T, \\sigma)$ is the price of the option (either a call $C$ or a put $P$) as given by the Black-Scholes formulas provided in the problem statement.\n\nThe Black-Scholes price function, $\\text{BS}(\\sigma)$, is a strictly increasing and continuous function of volatility $\\sigma$ for any time to maturity $T > 0$. This monotonicity guarantees that if a solution for $\\sigma^\\star$ exists, it is unique. This property makes the problem well-suited for numerical root-finding algorithms. We will employ the Newton-Raphson method, known for its rapid convergence when the derivative of the function is available and well-behaved.\n\nThe Newton-Raphson method is an iterative scheme that finds successively better approximations to the roots of a real-valued function. The iteration is given by:\n$$\n\\sigma_{k+1} = \\sigma_k - \\frac{f(\\sigma_k)}{f'(\\sigma_k)}\n$$\nIn our context, $f(\\sigma) = \\text{BS}(\\sigma) - p_{\\text{obs}}$, and its derivative with respect to $\\sigma$ is:\n$$\nf'(\\sigma) = \\frac{\\partial}{\\partial \\sigma} \\left[ \\text{BS}(\\sigma) - p_{\\text{obs}} \\right] = \\frac{\\partial \\text{BS}(\\sigma)}{\\partial \\sigma}\n$$\nThis derivative is a very important quantity in options pricing known as Vega, denoted by $\\mathcal{V}$. For both call and put options, Vega is given by:\n$$\n\\mathcal{V} = S \\phi(d_1) \\sqrt{T}\n$$\nwhere $\\phi(\\cdot)$ is the probability density function (PDF) of the standard normal distribution and $d_1$ is defined as in the problem statement. Since $\\phi(x) > 0$ for all real $x$, and $S, T > 0$, Vega is strictly positive. This confirms the monotonic nature of the pricing function.\n\nThe iterative formula for the implied volatility thus becomes:\n$$\n\\sigma_{k+1} = \\sigma_k - \\frac{\\text{BS}(\\sigma_k) - p_{\\text{obs}}}{\\mathcal{V}(\\sigma_k)}\n$$\n\nThe overall algorithm is designed as follows:\nFirst, we handle a critical boundary condition. The problem states that if the observed price $p_{\\text{obs}}$ is equal to the option's no-arbitrage lower bound (its intrinsic value), the implied volatility is $0$. The intrinsic value for a call is $\\max\\{0, S - K e^{-rT}\\}$ and for a put is $\\max\\{0, K e^{-rT} - S\\}$. Our implementation will first check if $p_{\\text{obs}}$ matches this value within a small numerical tolerance. If it does, we return $\\sigma^\\star = 0$ immediately, without iteration.\n\nIf the price is above the intrinsic value, we proceed with the Newton-Raphson solver.\n1.  An initial guess, $\\sigma_0$, is chosen. A value of $\\sigma_0 = 0.5$ is a reasonable and robust starting point for a wide range of option parameters.\n2.  The algorithm iterates, calculating $\\sigma_{k+1}$ from $\\sigma_k$ using the formula above.\n3.  The iteration continues until the absolute difference between the calculated Black-Scholes price at $\\sigma_k$ and the observed price $p_{\\text{obs}}$ is smaller than a predefined tolerance, for instance, $10^{-12}$.\n4.  To ensure the algorithm terminates, a maximum number of iterations (e.g., $100$) is enforced. For the well-behaved test cases provided, convergence is expected to be very rapid.\n\nThe implementation consists of three main Python functions:\n-   A function to calculate the Black-Scholes price for a call or put, using `scipy.stats.norm.cdf` to represent the standard normal cumulative distribution function $\\Phi(\\cdot)$.\n-   A function to calculate Vega, $\\mathcal{V}$, using `scipy.stats.norm.pdf` to represent the standard normal probability density function $\\phi(\\cdot)$.\n-   A primary function that orchestrates the process: it checks the boundary condition and, if necessary, executes the Newton-Raphson iteration to find the implied volatility.\n\nFinally, this process is applied to each of the six test cases defined in the problem. The resulting implied volatilities are collected, formatted to six decimal places, and printed to standard output in the specified list format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes implied volatility for a set of European options using the Black-Scholes model\n    and the Newton-Raphson method.\n    \"\"\"\n\n    def black_scholes_price(S, K, r, T, sigma, option_type):\n        \"\"\"\n        Calculates the Black-Scholes price for a European option.\n        \"\"\"\n        # For non-positive sigma, price is intrinsic value.\n        if sigma = 0.0:\n            if option_type == 'C':\n                return np.maximum(0.0, S - K * np.exp(-r * T))\n            else:  # 'P'\n                return np.maximum(0.0, K * np.exp(-r * T) - S)\n\n        # To prevent division by zero for T=0\n        if T == 0:\n            if option_type == 'C':\n                return np.maximum(0.0, S - K)\n            else: # 'P'\n                return np.maximum(0.0, K - S)\n\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n\n        if option_type == 'C':\n            price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        elif option_type == 'P':\n            price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)\n        else:\n            raise ValueError(\"Invalid option type. Must be 'C' or 'P'.\")\n        return price\n\n    def vega(S, K, r, T, sigma):\n        \"\"\"\n        Calculates the Vega of a European option.\n        \"\"\"\n        if sigma = 0.0 or T = 0.0:\n            return 0.0\n        \n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        return S * norm.pdf(d1) * np.sqrt(T)\n\n    def implied_volatility(S, K, r, T, p_obs, option_type):\n        \"\"\"\n        Calculates the implied volatility using the Newton-Raphson method.\n        \"\"\"\n        # Check if price is at the no-arbitrage lower bound (intrinsic value)\n        if option_type == 'C':\n            intrinsic_value = np.maximum(0.0, S - K * np.exp(-r * T))\n        else:  # 'P'\n            intrinsic_value = np.maximum(0.0, K * np.exp(-r * T) - S)\n        \n        # Using a small tolerance for floating point comparison\n        if np.isclose(p_obs, intrinsic_value):\n            return 0.0\n\n        # Newton-Raphson settings\n        sigma = 0.5  # Initial guess\n        max_iter = 100\n        tolerance = 1e-12\n\n        for _ in range(max_iter):\n            price = black_scholes_price(S, K, r, T, sigma, option_type)\n            v = vega(S, K, r, T, sigma)\n            \n            diff = price - p_obs\n\n            if abs(diff)  tolerance:\n                return sigma\n            \n            if v  1e-13:\n                # Vega is too small, Newton-Raphson is unstable.\n                # This should not happen for the given test cases.\n                # A more robust solver would switch to bisection here.\n                break\n\n            sigma = sigma - diff / v\n        \n        # Return the last calculated sigma if max iterations are reached\n        return sigma\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (option_type, S, K, r, T, p_obs)\n        ('C', 100.0, 100.0, 0.0, 1.0, 68.268949213709),\n        ('C', 60.653065971263, 100.0, 0.0, 1.0, 14.461007592486),\n        ('P', 60.653065971263, 100.0, 0.0, 1.0, 53.807941621223),\n        ('C', 120.0, 100.0, 0.0, 1.0, 20.0),\n        ('P', 80.0, 100.0, 0.0, 1.0, 20.0),\n        ('C', 100.0, 100.0, 0.0, 1.0, 7.965567455406),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        option_type, S, K, r, T, p_obs = case\n        result = implied_volatility(S, K, r, T, p_obs, option_type)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2400522"}, {"introduction": "While theoretical models often assume frictionless markets, real-world trading involves costs that create ambiguity around a single observed price. This practice [@problem_id:2400464] challenges you to move beyond calculating a single volatility point and instead determine a consistent *interval* of implied volatilities. By modeling the effects of transaction costs, you will develop a more nuanced understanding of how market structure impacts model calibration and gain insight into the inherent uncertainty in financial data.", "problem": "Consider a European call option written on an underlying asset with current price $S_0$, strike $K$, continuously compounded risk-free rate $r$, continuous dividend yield $q$, and time to maturity $T$ (in years). Under the risk-neutral measure, assume the Black–Scholes (BS) framework: the terminal price is $S_T = S_0 \\exp\\left((r - q - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T} Z\\right)$, where $Z$ is standard normal and $\\sigma \\ge 0$ is the (unknown) volatility. The frictionless theoretical price of the call is the discounted risk-neutral expectation\n$$\nC_{\\text{BS}}(\\sigma) = e^{-rT} \\mathbb{E}\\left[\\max(S_T - K, 0)\\right].\n$$\nDefine the implied volatility as any $\\sigma \\ge 0$ such that $C_{\\text{BS}}(\\sigma)$ equals a given call price.\n\nNow suppose the market has proportional transaction costs on the option itself modeled as a proportional half-spread parameter $\\tau \\in [0,1)$: a single observed transaction at price $P_{\\text{obs}}$ implies that economically consistent frictionless prices lie in the interval $[P_{\\text{obs}}(1 - \\tau),\\, P_{\\text{obs}}(1 + \\tau)]$. Independently, no-arbitrage bounds for a European call imply that any frictionless price must lie in the interval\n$$\n\\left[\\max\\left(0,\\, S_0 e^{-qT} - K e^{-rT}\\right),\\; S_0 e^{-qT}\\right].\n$$\nTherefore, the set of frictionless prices consistent with a single observed price $P_{\\text{obs}}$ and proportional transaction costs $\\tau$ is the intersection of these two intervals. Denote this intersection by $[P_{\\min}, P_{\\max}]$, where $P_{\\min} \\le P_{\\max}$. Because $C_{\\text{BS}}(\\sigma)$ is nondecreasing in $\\sigma$, the set of implied volatilities consistent with $[P_{\\min}, P_{\\max}]$ is an interval $[\\sigma_{\\min}, \\sigma_{\\max}]$, where $C_{\\text{BS}}(\\sigma_{\\min}) = P_{\\min}$ and $C_{\\text{BS}}(\\sigma_{\\max}) = P_{\\max}$, with $\\sigma_{\\min}, \\sigma_{\\max} \\ge 0$.\n\nTask: For each test case below, compute the interval of implied volatilities $[\\sigma_{\\min}, \\sigma_{\\max}]$ consistent with the given parameters. All volatility values must be expressed as decimals (not percentages).\n\nTest suite (each case is $(S_0, K, r, q, T, P_{\\text{obs}}, \\tau)$):\n- Case $1$: $(\\$100.0,\\, \\$100.0,\\, 0.02,\\, 0.01,\\, 1.0,\\, \\$10.0,\\, 0.05)$.\n- Case $2$: $(\\$100.0,\\, \\$100.0,\\, 0.02,\\, 0.01,\\, 1.0,\\, \\$10.0,\\, 0.0)$.\n- Case $3$: $(\\$100.0,\\, \\$80.0,\\, 0.05,\\, 0.0,\\, 2.0,\\, \\$30.0,\\, 0.2)$.\n- Case $4$: $(\\$50.0,\\, \\$45.0,\\, 0.01,\\, 0.0,\\, 0.01,\\, \\$5.3,\\, 0.1)$.\n\nFinal output format: Your program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets, where each result is itself a two-element list $[\\sigma_{\\min}, \\sigma_{\\max}]$. Each volatility must be rounded to exactly six decimal places. For example, an output with two cases would look like $[[0.123456,0.234567],[0.000000,0.345678]]$.", "solution": "The posed problem is valid. It is scientifically grounded in the Black-Scholes option pricing framework, a cornerstone of financial mathematics. The problem is well-posed, providing all necessary parameters and clear, unambiguous definitions for constructing a unique and meaningful solution. It is free of contradictions, subjective claims, and factual inaccuracies. The task is to calculate an interval of implied volatilities, which is a standard and formalizable problem in computational finance.\n\nThe solution is developed in three main stages:\n1.  Determination of the consistent price interval $[P_{\\min}, P_{\\max}]$.\n2.  Implementation of the Black-Scholes call pricing function $C_{\\text{BS}}(\\sigma)$.\n3.  Inversion of the Black-Scholes function using a numerical root-finding algorithm to find volatilities corresponding to $P_{\\min}$ and $P_{\\max}$.\n\n**Step 1: Determine the Price Interval $[P_{\\min}, P_{\\max}]$**\n\nThe problem states that the set of economically consistent frictionless prices is the intersection of two intervals.\n\nThe first interval, $I_1$, arises from the proportional transaction costs on the observed price $P_{\\text{obs}}$ with a half-spread parameter $\\tau$.\n$$\nI_1 = [P_{\\text{obs}}(1 - \\tau),\\, P_{\\text{obs}}(1 + \\tau)]\n$$\nThe second interval, $I_2$, is derived from the fundamental no-arbitrage bounds for a European call option. The price of a call option cannot be negative, nor can it be greater than the discounted current price of the underlying asset, $S_0 e^{-qT}$. A tighter lower bound is the intrinsic value of the option, which is the value if exercised immediately, discounted to the present.\n$$\nI_2 = \\left[\\max\\left(0,\\, S_0 e^{-qT} - K e^{-rT}\\right),\\; S_0 e^{-qT}\\right]\n$$\nThe interval of consistent prices, $[P_{\\min}, P_{\\max}]$, is the intersection of these two intervals, $I_1 \\cap I_2$. The intersection of two closed intervals $[a, b]$ and $[c, d]$ is given by $[\\max(a, c), \\min(b, d)]$. Therefore, we define:\n$$\nP_{\\min} = \\max\\left(P_{\\text{obs}}(1-\\tau),\\, \\max\\left(0,\\, S_0 e^{-qT} - K e^{-rT}\\right)\\right)\n$$\n$$\nP_{\\max} = \\min\\left(P_{\\text{obs}}(1+\\tau),\\, S_0 e^{-qT}\\right)\n$$\nFor a valid problem, we must have $P_{\\min} \\le P_{\\max}$.\n\n**Step 2: Black-Scholes Call Pricing Function**\n\nThe theoretical price of a European call option in the Black-Scholes model, $C_{\\text{BS}}(\\sigma)$, is a function of the volatility $\\sigma$ and other known parameters: the current asset price $S_0$, strike price $K$, risk-free rate $r$, dividend yield $q$, and time to maturity $T$. The closed-form solution is:\n$$\nC_{\\text{BS}}(\\sigma) = S_0 e^{-qT} \\Phi(d_1) - K e^{-rT} \\Phi(d_2)\n$$\nwhere $\\Phi(\\cdot)$ is the cumulative distribution function (CDF) of the standard normal distribution. The terms $d_1$ and $d_2$ are given by:\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r - q + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\n$$\n$$\nd_2 = d_1 - \\sigma\\sqrt{T} = \\frac{\\ln(S_0/K) + (r - q - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\n$$\nThis function is defined for $\\sigma > 0$. In the limit as $\\sigma \\to 0^+$, the call price converges to its intrinsic value, $C_{\\text{BS}}(0) = \\max(0, S_0 e^{-qT} - K e^{-rT})$. The function $C_{\\text{BS}}(\\sigma)$ is a strictly increasing function of $\\sigma$ for $\\sigma > 0$.\n\n**Step 3: Calculating the Implied Volatility Interval $[\\sigma_{\\min}, \\sigma_{\\max}]$**\n\nThe problem requires finding the interval $[\\sigma_{\\min}, \\sigma_{\\max}]$ such that $C_{\\text{BS}}(\\sigma_{\\min}) = P_{\\min}$ and $C_{\\text{BS}}(\\sigma_{\\max}) = P_{\\max}$. This involves inverting the Black-Scholes formula. Since no analytical inverse exists, we must employ a numerical root-finding method.\n\nFor a given price $P$ from the interval $[P_{\\min}, P_{\\max}]$, we need to find the root $\\sigma \\ge 0$ of the equation:\n$$\nf(\\sigma) = C_{\\text{BS}}(\\sigma) - P = 0\n$$\nGiven that $C_{\\text{BS}}(\\sigma)$ is monotonic, this root is unique. The Brent-Dekker method (as implemented in `scipy.optimize.brentq`) is a robust and efficient choice for this task. It requires a bracket $[a, b]$ such that $f(a)$ and $f(b)$ have opposite signs.\n\nThe overall algorithm for each test case is as follows:\n1.  Calculate $P_{\\min}$ and $P_{\\max}$ using the formulas from Step 1.\n2.  Define a function to compute $C_{\\text{BS}}(\\sigma)$ as described in Step 2. Care must be taken for the case $\\sigma \\approx 0$ to avoid division by zero; in this limit, the price is the intrinsic value.\n3.  To find $\\sigma_{\\min}$ corresponding to $P_{\\min}$:\n    a. First, calculate the lower no-arbitrage price bound (intrinsic value), $P_{intrinsic} = \\max(0, S_0 e^{-qT} - K e^{-rT})$.\n    b. If $P_{\\min}$ is computationally indistinguishable from $P_{intrinsic}$ (i.e., $|P_{\\min} - P_{intrinsic}|  \\epsilon$ for a small tolerance $\\epsilon$), then $\\sigma_{\\min} = 0$.\n    c. Otherwise, numerically solve $C_{\\text{BS}}(\\sigma) - P_{\\min} = 0$ for $\\sigma > 0$ using a root-finder like `brentq`. A suitable search interval for volatility, such as $[10^{-5}, 5.0]$, can be used, as it brackets the solution for any realistic financial scenario.\n4.  To find $\\sigma_{\\max}$ corresponding to $P_{\\max}$:\n    a. Solve $C_{\\text{BS}}(\\sigma) - P_{\\max} = 0$ for $\\sigma \\ge 0$ using the same numerical procedure. Given that $P_{\\max} \\ge P_{\\min}$ and $C_{\\text{BS}}$ is increasing, it follows that $\\sigma_{\\max} \\ge \\sigma_{\\min}$.\n5.  Combine the results into the final interval $[\\sigma_{\\min}, \\sigma_{\\max}]$ and format as required.\n\nThis procedure will be applied to each test case to generate the final output.", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the implied volatility interval [sigma_min, sigma_max] for each case.\n    \"\"\"\n\n    test_cases = [\n        # (S0, K, r, q, T, P_obs, tau)\n        (100.0, 100.0, 0.02, 0.01, 1.0, 10.0, 0.05),\n        (100.0, 100.0, 0.02, 0.01, 1.0, 10.0, 0.0),\n        (100.0, 80.0, 0.05, 0.0, 2.0, 30.0, 0.2),\n        (50.0, 45.0, 0.01, 0.0, 0.01, 5.3, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        s0, k, r, q, t, p_obs, tau = case\n        \n        # Step 1: Determine the consistent price interval [P_min, P_max]\n        \n        # Interval from no-arbitrage bounds\n        intrinsic_value = np.max([0.0, s0 * np.exp(-q * t) - k * np.exp(-r * t)])\n        upper_bound = s0 * np.exp(-q * t)\n        \n        # Interval from transaction costs\n        p_obs_lower = p_obs * (1.0 - tau)\n        p_obs_upper = p_obs * (1.0 + tau)\n        \n        # Intersection of the two intervals\n        p_min = np.max([p_obs_lower, intrinsic_value])\n        p_max = np.min([p_obs_upper, upper_bound])\n\n        if p_min  p_max:\n            # This case indicates no consistent price exists.\n            # For this problem, we assume test cases are well-behaved.\n            # In a real application, this would be an error condition.\n            # Setting volatilities to NaN or raising an exception would be appropriate.\n            # Here we follow the problem's assumption of a non-empty interval.\n            sigma_min, sigma_max = np.nan, np.nan\n        else:\n            # Step 2  3: Find implied volatilities for P_min and P_max\n            sigma_min = _calculate_implied_vol(p_min, s0, k, r, q, t, intrinsic_value)\n            sigma_max = _calculate_implied_vol(p_max, s0, k, r, q, t, intrinsic_value)\n        \n        result_str = f\"[{sigma_min:.6f},{sigma_max:.6f}]\"\n        results.append(result_str)\n\n    print(f\"[{','.join(results)}]\")\n\ndef _bs_call_price(sigma, s0, k, r, q, t):\n    \"\"\"\n    Calculates the Black-Scholes price for a European call option.\n    Handles the edge case of sigma being extremely small.\n    \"\"\"\n    if sigma * np.sqrt(t)  1e-12:\n        return np.max([0.0, s0 * np.exp(-q * t) - k * np.exp(-r * t)])\n    \n    d1 = (np.log(s0 / k) + (r - q + 0.5 * sigma**2) * t) / (sigma * np.sqrt(t))\n    d2 = d1 - sigma * np.sqrt(t)\n    \n    price = s0 * np.exp(-q * t) * norm.cdf(d1) - k * np.exp(-r * t) * norm.cdf(d2)\n    return price\n\ndef _calculate_implied_vol(price, s0, k, r, q, t, intrinsic_value):\n    \"\"\"\n    Calculates the implied volatility for a given option price.\n    \"\"\"\n    # If price is at the intrinsic value, volatility is 0.\n    if np.abs(price - intrinsic_value)  1e-9:\n        return 0.0\n\n    # Define the objective function for the root finder.\n    # It is the difference between the BS price and the market price.\n    objective_func = lambda sigma: _bs_call_price(sigma, s0, k, r, q, t) - price\n\n    # Use a robust root-finding algorithm (Brent's method) to find the volatility.\n    # A search bracket of [1e-5, 5.0] is safe for most financial instruments.\n    # 5.0 corresponds to 500% volatility.\n    try:\n        implied_vol = brentq(objective_func, 1e-5, 5.0)\n    except ValueError:\n        # This can happen if the price is outside the range of possible BS prices,\n        # which shouldn't occur with the correct P_min, P_max logic.\n        # It means f(a) and f(b) have the same sign.\n        # If price  s0*exp(-qT), objective is always negative.\n        # If price  intrinsic, objective is always positive.\n        return np.nan\n        \n    return implied_vol\n\nsolve()\n```", "id": "2400464"}, {"introduction": "The Black-Scholes formula is limited to European options, but many actively traded contracts are American, allowing for early exercise. This advanced practice [@problem_id:2400466] requires you to generalize your skills by integrating a binomial tree pricer—a versatile numerical method for American options—into your implied volatility solver. Successfully completing this exercise demonstrates the ability to adapt the root-finding framework to more complex, iterative pricing models that lack a simple closed-form solution.", "problem": "You are asked to write a complete, runnable program that computes implied volatility for American-style options on a dividend-paying stock using a recombining binomial tree model and risk-neutral valuation with early exercise. The program must construct a pricing function for American options that accounts for a continuous dividend yield and then solve for the unique volatility that makes the model price match a given observed price. For testing, each observed price is to be generated synthetically by first pricing the same option with a known volatility on the same binomial tree specification.\n\nAll parameters are annualized and continuous where applicable. The underlying follows a multiplicative binomial process over a fixed number of time steps under the risk-neutral measure. The stock pays a continuous dividend yield. At each node, the American option value equals the greater of its immediate exercise value and the discounted expected continuation value under the risk-neutral probabilities. Implied volatility is defined as the nonnegative real number that, when substituted as the volatility in the same binomial model, makes the computed American option price equal to the observed price.\n\nUnits and conventions:\n- The risk-free rate $r$ and dividend yield $q$ are continuously compounded annual rates given as decimals.\n- Time to maturity $T$ is in years.\n- The underlying price $S_0$ and strike $K$ are in arbitrary currency units; report volatilities as decimals.\n- No angles are involved.\n- All rates and volatilities must be treated as decimals, not percentages.\n\nTest suite:\nFor each test case, first compute the observed option price $V^{obs}$ by pricing the American option using the provided volatility $\\,\\sigma^\\star\\,$ and the specified binomial tree step count $\\,N\\,$. Then, using only $V^{obs}$ (not $\\,\\sigma^\\star\\,$), solve for the implied volatility $\\,\\hat{\\sigma}\\,$ that reproduces $V^{obs}$ in the same model. Your program should return $\\,\\hat{\\sigma}\\,$ for each case, rounded to six decimal places.\n\n- Case A (general, at-the-money American put): $S_0 = 100$, $K = 100$, $r = 0.05$, $q = 0.02$, $T = 1.0$, $N = 300$, option type put, forward-pricing volatility $\\,\\sigma^\\star = 0.20$.\n- Case B (American call with dividend yield, potential early exercise): $S_0 = 120$, $K = 100$, $r = 0.01$, $q = 0.06$, $T = 0.5$, $N = 300$, option type call, forward-pricing volatility $\\,\\sigma^\\star = 0.25$.\n- Case C (short maturity): $S_0 = 100$, $K = 95$, $r = 0.03$, $q = 0.00$, $T = \\tfrac{7}{365}$, $N = 120$, option type call, forward-pricing volatility $\\,\\sigma^\\star = 0.15$.\n- Case D (deep out-of-the-money American put, longer maturity): $S_0 = 150$, $K = 100$, $r = 0.03$, $q = 0.02$, $T = 2.0$, $N = 400$, option type put, forward-pricing volatility $\\,\\sigma^\\star = 0.35$.\n\nFinal output format:\nYour program should produce a single line of output containing the four implied volatilities for Cases A–D in order, rounded to six decimal places, as a comma-separated list enclosed in square brackets. For example, the format must be\n\"[vA,vB,vC,vD]\"\nwith no extra spaces or characters, where each of $vA$, $vB$, $vC$, and $vD$ is a float in decimal form rounded to six decimal places.", "solution": "The problem statement presented is subjected to rigorous validation before any attempt at a solution.\n\nStep 1: Extraction of Givens\n- **Model Type**: Recombining binomial tree model for American-style options.\n- **Underlying Asset**: Stock paying a continuous dividend yield.\n- **Valuation Methodology**: Risk-neutral valuation with early exercise.\n- **Stock Price Process**: Multiplicative binomial process, $S_{t+\\Delta t} = S_t \\cdot u$ or $S_{t+\\Delta t} = S_t \\cdot d$.\n- **Option Value Rule**: At any node, the value is the maximum of its immediate exercise value and its discounted expected continuation value under risk-neutral probabilities.\n- **Implied Volatility ($\\hat{\\sigma}$)**: The unique non-negative real number for volatility $\\sigma$ such that the model price equals the observed market price $V^{obs}$.\n- **Observed Price Generation**: Each $V^{obs}$ is synthetically generated by pricing the option with a known volatility, denoted $\\sigma^\\star$.\n- **Model Parameters**:\n    - $S_0$: Initial stock price.\n    - $K$: Strike price.\n    - $r$: Risk-free interest rate (continuous, annual).\n    - $q$: Dividend yield (continuous, annual).\n    - $T$: Time to maturity (years).\n    - $N$: Number of time steps in the binomial tree.\n    - `option_type`: 'call' or 'put'.\n- **Test Cases**:\n    - **A**: $S_0 = 100$, $K = 100$, $r = 0.05$, $q = 0.02$, $T = 1.0$, $N = 300$, type = put, $\\sigma^\\star = 0.20$.\n    - **B**: $S_0 = 120$, $K = 100$, $r = 0.01$, $q = 0.06$, $T = 0.5$, $N = 300$, type = call, $\\sigma^\\star = 0.25$.\n    - **C**: $S_0 = 100$, $K = 95$, $r = 0.03$, $q = 0.00$, $T = \\frac{7}{365}$, $N = 120$, type = call, $\\sigma^\\star = 0.15$.\n    - **D**: $S_0 = 150$, $K = 100$, $r = 0.03$, $q = 0.02$, $T = 2.0$, $N = 400$, type = put, $\\sigma^\\star = 0.35$.\n- **Output Requirement**: A list of four implied volatilities, $\\hat{\\sigma}$, corresponding to the test cases, rounded to six decimal places.\n\nStep 2: Validation\n- **Scientific Grounding**: The problem is based on the Cox-Ross-Rubinstein (CRR) binomial options pricing model, a cornerstone of computational finance. Risk-neutral valuation, the treatment of American options with early exercise, and the concept of implied volatility are all standard, well-established principles. The model is scientifically sound.\n- **Well-Posedness**: The problem requires finding a root for the equation $V_{model}(\\sigma) - V^{obs} = 0$. The option price, $V_{model}(\\sigma)$, is a monotonically increasing function of volatility $\\sigma$ for standard options (i.e., vega is positive). This ensures that a unique solution for $\\sigma$ exists for any valid observed price $V^{obs}$. The problem's structure, where $V^{obs}$ is generated from a known $\\sigma^\\star$ using the same model, guarantees that a solution $\\hat{\\sigma} = \\sigma^\\star$ exists, making the problem well-posed.\n- **Objectivity**: All parameters and definitions are quantitative and precise. The problem is free of subjective language or speculative claims.\n- **Completeness**: All necessary parameters ($S_0, K, r, q, T, N, \\text{type}$) are provided for each test case, making the problem self-contained.\n- **Consistency**: The problem statement contains no internal contradictions.\n\nStep 3: Verdict\nThe problem is deemed **valid**. It is scientifically grounded, well-posed, objective, complete, and consistent. It represents a standard computational task in quantitative finance. I will now proceed with the derivation and implementation of the solution.\n\nThe solution is a two-stage process. First, an American option pricer is constructed based on the specified binomial model. Second, a numerical root-finding algorithm is used to solve for the implied volatility.\n\n**Part 1: Binomial Model for American Option Pricing**\n\nThe binomial model discretizes time into $N$ steps of duration $\\Delta t = T/N$. At each node, the stock price moves up by a factor $u$ or down by a factor $d$. We use the standard Cox-Ross-Rubinstein (CRR) formulation for these factors, which depends on the volatility $\\sigma$.\n\n1.  **Model Parameters**:\n    The length of a single time step is $\\Delta t = T/N$.\n    The up-move factor is $u = e^{\\sigma \\sqrt{\\Delta t}}$.\n    The down-move factor is $d = e^{-\\sigma \\sqrt{\\Delta t}} = 1/u$.\n\n2.  **Risk-Neutral Probability**:\n    For the discounted stock price process to be a martingale under the risk-neutral measure, taking into account the continuous dividend yield $q$, the expected stock price at time $t+\\Delta t$, discounted at the risk-free rate $r$, must equal the stock price at time $t$ after accounting for the loss in value due to the dividend payment over the interval $\\Delta t$. This gives the relation:\n    $$S_t e^{-q \\Delta t} = e^{-r \\Delta t} [p (S_t u) + (1-p) (S_t d)]$$\n    Solving for the risk-neutral probability $p$ of an up-move yields:\n    $$p = \\frac{e^{(r-q)\\Delta t} - d}{u - d}$$\n    The probability of a down-move is then $1-p$. The condition $0  p  1$ must hold, which requires $d  e^{(r-q)\\Delta t}  u$. This is satisfied for typical parameter values and non-zero volatility.\n\n3.  **Backward Induction Algorithm**:\n    The value of the American option is determined by working backward from maturity.\n    - **At maturity (Time $T$, step $N$)**: The option value is its intrinsic value. A tree of stock prices at maturity is constructed. For $j$ up-moves and $N-j$ down-moves (where $j \\in \\{0, 1, \\dots, N\\}$), the stock price is $S_{N,j} = S_0 u^j d^{N-j}$. The option value is:\n    $$V_{N,j} = \\max(S_{N,j} - K, 0) \\quad \\text{for a call option}$$\n    $$V_{N,j} = \\max(K - S_{N,j}, 0) \\quad \\text{for a put option}$$\n\n    - **At intermediate steps (Time $i \\Delta t$, step $i  N$)**: The option value at any node $(i, j)$ is the maximum of the early exercise value and the discounted expected continuation value.\n    The continuation value is the expected value of the option at step $i+1$, discounted back one period:\n    $$C_{i,j} = e^{-r \\Delta t} [p V_{i+1, j+1} + (1-p) V_{i+1, j}]$$\n    The early exercise value at node $(i,j)$, where the stock price is $S_{i,j} = S_0 u^j d^{i-j}$, is:\n    $$E_{i,j} = \\max(S_{i,j} - K, 0) \\quad \\text{for a call option}$$\n    $$E_{i,j} = \\max(K - S_{i,j}, 0) \\quad \\text{for a put option}$$\n    The value of the American option is therefore:\n    $$V_{i,j} = \\max(E_{i,j}, C_{i,j})$$\n    This backward iteration proceeds until step $i=0$. The price of the option at time $t=0$ is the value at the single node, $V_{0,0}$. This entire procedure constitutes the pricing function, which we denote $V_{\\text{model}}(S_0, K, r, q, T, N, \\sigma, \\text{type})$.\n\n**Part 2: Implied Volatility Calculation**\n\nImplied volatility, $\\hat{\\sigma}$, is the value of $\\sigma$ that equates the model price to an observed market price, $V^{obs}$. We must solve the following equation for $\\sigma$:\n$$f(\\sigma) = V_{\\text{model}}(S_0, K, r, q, T, N, \\sigma, \\text{type}) - V^{obs} = 0$$\n\nSince $V_{\\text{model}}$ does not have a simple closed-form expression, we must use a numerical root-finding method. Brent's method is a robust and efficient choice. It requires an interval $[a, b]$ where $f(a)$ and $f(b)$ have opposite signs.\n\n1.  **Objective Function**: The function to be minimized is `objective_func(sigma) = american_option_pricer(...) - V_obs`.\n2.  **Generate Observed Price**: For each test case, we first compute $V^{obs}$ by calling our pricing function with the given forward-pricing volatility $\\sigma^\\star$.\n3.  **Root Finding**: We then use Brent's method (available in `scipy.optimize.brentq`) to find the root of `objective_func`.\n    - A suitable search interval for volatility is required. A lower bound can be a small positive number, e.g., $10^{-6}$, since volatility cannot be negative. An upper bound of $5.0$ (representing $500\\%$ volatility) is extremely conservative and will suffice for bracketing the solution for any realistic option price.\n    - Since option price is a monotonically increasing function of volatility, and we know a solution exists at $\\sigma = \\sigma^\\star$, finding a bracketing interval is straightforward.\n\nThe final program will encapsulate these two parts. For each test case, it will first compute $V^{obs}$ and then solve for $\\hat{\\sigma}$. The problem formulation guarantees that the result $\\hat{\\sigma}$ will be equal to $\\sigma^\\star$ within the solver's tolerance. The final results are rounded as specified.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef american_option_pricer(S0, K, r, q, T, N, sigma, option_type):\n    \"\"\"\n    Prices an American option using a recombining binomial tree model.\n\n    Args:\n        S0 (float): Initial stock price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate (annual, continuous).\n        q (float): Dividend yield (annual, continuous).\n        T (float): Time to maturity (years).\n        N (int): Number of time steps in the binomial tree.\n        sigma (float): Volatility of the underlying stock.\n        option_type (str): Type of option, 'call' or 'put'.\n\n    Returns:\n        float: The price of the American option.\n    \"\"\"\n    # 1. Parameter setup for the binomial model\n    # Ensure sigma is not too close to zero to avoid division issues.\n    if sigma  1e-9:\n        sigma = 1e-9\n\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1.0 / u\n\n    # Check for arbitrage condition and calculate risk-neutral probability\n    a = np.exp((r - q) * dt)\n    if not (d  a  u):\n        # Fallback or handle arbitrage condition violation\n        # For this problem's context, this is unlikely.\n        # This can be triggered if r-q is very large or sigma very small.\n        # If it happens, we can approximate p to be very close to 1 or 0.\n        if a = u:\n            p = 1.0 \n        else: # a = d\n            p = 0.0\n    else:\n        p = (a - d) / (u - d)\n\n    # 2. Initialize option values at maturity (time T)\n    # The prices are stored in a 1D array representing nodes at a given time step.\n    V = np.zeros(N + 1)\n    \n    # Stock prices at maturity\n    S_T = S0 * (d ** np.arange(N, -1, -1)) * (u ** np.arange(0, N + 1, 1))\n\n    if option_type == 'call':\n        V[:] = np.maximum(S_T - K, 0)\n        payoff_sign = 1\n    else:  # put\n        V[:] = np.maximum(K - S_T, 0)\n        payoff_sign = -1\n\n    # 3. Backward induction through the tree\n    for i in range(N - 1, -1, -1):\n        # Calculate continuation value at step i (vector of size i+1)\n        # V is of size i+2 from the previous step i+1.\n        # We use V's relevant subarray [0:i+2]\n        continuation_value = np.exp(-r * dt) * (p * V[1:i + 2] + (1 - p) * V[0:i + 1])\n\n        # Calculate stock prices at step i\n        S_i = S0 * (d ** np.arange(i, -1, -1)) * (u ** np.arange(0, i + 1, 1))\n\n        # Calculate early exercise value\n        exercise_value = np.maximum((S_i - K) * payoff_sign, 0)\n\n        # Update option values at step i\n        V[0:i + 1] = np.maximum(continuation_value, exercise_value)\n\n    return V[0]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute implied volatilities.\n    \"\"\"\n    test_cases = [\n        # (S0, K, r, q, T, N, option_type, sigma_star)\n        (100.0, 100.0, 0.05, 0.02, 1.0, 300, 'put', 0.20),  # Case A\n        (120.0, 100.0, 0.01, 0.06, 0.5, 300, 'call', 0.25), # Case B\n        (100.0, 95.0, 0.03, 0.00, 7.0/365.0, 120, 'call', 0.15), # Case C\n        (150.0, 100.0, 0.03, 0.02, 2.0, 400, 'put', 0.35), # Case D\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        S0, K, r, q, T, N, option_type, sigma_star = case\n\n        # 1. Generate the \"observed\" option price using the known volatility\n        observed_price = american_option_pricer(S0, K, r, q, T, N, sigma_star, option_type)\n\n        # 2. Define the objective function for the root-finder\n        # The function calculates the difference between model price and observed price.\n        def objective_func(sigma):\n            return american_option_pricer(S0, K, r, q, T, N, sigma, option_type) - observed_price\n\n        # 3. Find the implied volatility using Brent's method\n        # A search bracket from 0.0001 (0.01%) to 5.0 (500%) is very safe.\n        try:\n            implied_vol = brentq(objective_func, a=1e-6, b=5.0, xtol=1e-12, rtol=1e-12)\n        except ValueError:\n            # This would happen if f(a) and f(b) don't have opposite signs.\n            # Given the problem's synthetic nature, this is not expected.\n            implied_vol = np.nan\n\n        results.append(round(implied_vol, 6))\n\n    # Final output format: \"[vA,vB,vC,vD]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2400466"}]}