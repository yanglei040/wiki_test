{"hands_on_practices": [{"introduction": "The efficient frontier offers a spectrum of optimal portfolios, but how does an investor choose just one? This practice bridges theory and application by using an investor's specific risk aversion to pinpoint the single optimal portfolio. You will apply Merton's foundational portfolio rule to see how preferences for risk, represented by a utility function, translate directly into a concrete investment strategy [@problem_id:2383572].", "problem": "An investor with Constant Relative Risk Aversion (CRRA) preferences has utility over terminal wealth given by $U(W) = \\frac{W^{1-\\gamma}}{1-\\gamma}$ with risk aversion parameter $\\gamma = 3$. The investor operates in continuous time over a horizon of length $T = 1$, with initial wealth $W_{0} > 0$, and can invest in two risky assets and a risk-free asset. The risk-free asset grows at a continuously compounded rate $r = 0.02$. The risky assets follow correlated Geometric Brownian Motion (GBM) dynamics:\n$$\n\\frac{dS_{i}(t)}{S_{i}(t)} = \\mu_{i}\\,dt + \\sigma_{i}\\,dB_{i}(t), \\quad i \\in \\{1,2\\},\n$$\nwhere $B_{1}(t)$ and $B_{2}(t)$ are standard Brownian motions with instantaneous correlation $\\rho = 0.25$. The parameters are:\n- Expected returns $\\mu_{1} = 0.06$ and $\\mu_{2} = 0.09$,\n- Volatilities $\\sigma_{1} = 0.2$ and $\\sigma_{2} = 0.3$,\n- Correlation $\\rho = 0.25$,\n- Risk-free rate $r = 0.02$,\n- Risk aversion $\\gamma = 3$.\n\nThe investor chooses constant portfolio weights $w = (w_{1}, w_{2})$ in the risky assets over $[0,1]$, investing the remaining fraction $1 - w_{1} - w_{2}$ in the risk-free asset. Assume there are no constraints on short sales or borrowing.\n\nDetermine the optimal risky-asset weight vector $w^{\\star} = (w_{1}^{\\star}, w_{2}^{\\star})$ that maximizes $\\mathbb{E}[U(W_{1})]$. Express your final answer as exact values. No rounding is required.", "solution": "The problem has been validated and is a well-posed, scientifically grounded problem in quantitative finance. It is a standard application of Merton's portfolio theory. I will proceed with the solution.\n\nThe investor's objective is to maximize the expected utility of terminal wealth, $\\mathbb{E}[U(W_{T})]$, for a power utility function (CRRA) of the form $U(W) = \\frac{W^{1-\\gamma}}{1-\\gamma}$, with a coefficient of relative risk aversion $\\gamma$. The investment opportunity set is assumed to be constant. In this continuous-time framework, the optimal allocation to the risky assets, denoted by the vector $w^{\\star}$, is constant and given by the Merton's portfolio rule:\n$$ w^{\\star} = \\frac{1}{\\gamma} \\Sigma^{-1} (\\mu - r \\mathbf{1}) $$\nHere, $w^{\\star}$ is the column vector of optimal weights for the risky assets, $\\gamma$ is the risk aversion parameter, $\\Sigma$ is the covariance matrix of the risky asset returns, $\\mu$ is the vector of expected returns for the risky assets, $r$ is the risk-free rate, and $\\mathbf{1}$ is a column vector of ones with appropriate dimension.\n\nThe parameters provided in the problem are:\n- Risk aversion parameter: $\\gamma = 3$\n- Risk-free rate: $r = 0.02$\n- Expected returns vector: $\\mu = \\begin{pmatrix} \\mu_{1} \\\\ \\mu_{2} \\end{pmatrix} = \\begin{pmatrix} 0.06 \\\\ 0.09 \\end{pmatrix}$\n- Volatilities: $\\sigma_{1} = 0.2$, $\\sigma_{2} = 0.3$\n- Correlation: $\\rho = 0.25$\n\nFirst, we compute the vector of excess returns (risk premia), $\\mu - r \\mathbf{1}$:\n$$ \\mu - r \\mathbf{1} = \\begin{pmatrix} 0.06 - 0.02 \\\\ 0.09 - 0.02 \\end{pmatrix} = \\begin{pmatrix} 0.04 \\\\ 0.07 \\end{pmatrix} $$\n\nNext, we construct the covariance matrix $\\Sigma$ of the risky asset returns. The elements of $\\Sigma$ are $\\Sigma_{ij} = \\sigma_i \\sigma_j \\rho_{ij}$, where $\\rho_{11} = \\rho_{22} = 1$ and $\\rho_{12} = \\rho_{21} = \\rho = 0.25$.\nThe diagonal elements are the variances:\n$$ \\Sigma_{11} = \\sigma_{1}^{2} = (0.2)^{2} = 0.04 $$\n$$ \\Sigma_{22} = \\sigma_{2}^{2} = (0.3)^{2} = 0.09 $$\nThe off-diagonal elements are the covariances:\n$$ \\Sigma_{12} = \\Sigma_{21} = \\sigma_{1} \\sigma_{2} \\rho = (0.2)(0.3)(0.25) = (0.06)(0.25) = 0.015 $$\nThus, the covariance matrix is:\n$$ \\Sigma = \\begin{pmatrix} 0.04 & 0.015 \\\\ 0.015 & 0.09 \\end{pmatrix} $$\n\nTo apply the formula, we need the inverse of $\\Sigma$. For a $2 \\times 2$ matrix $\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$, its inverse is given by $\\frac{1}{ad-bc} \\begin{pmatrix} d & -b \\\\ -c & a \\end{pmatrix}$.\nFirst, we find the determinant of $\\Sigma$:\n$$ \\det(\\Sigma) = (0.04)(0.09) - (0.015)(0.015) = 0.0036 - 0.000225 = 0.003375 $$\nThe inverse matrix $\\Sigma^{-1}$ is then:\n$$ \\Sigma^{-1} = \\frac{1}{0.003375} \\begin{pmatrix} 0.09 & -0.015 \\\\ -0.015 & 0.04 \\end{pmatrix} $$\n\nNow, we substitute all parts into the Merton's formula for the optimal weight vector $w^{\\star} = \\begin{pmatrix} w_{1}^{\\star} \\\\ w_{2}^{\\star} \\end{pmatrix}$:\n$$ w^{\\star} = \\frac{1}{3} \\left( \\frac{1}{0.003375} \\begin{pmatrix} 0.09 & -0.015 \\\\ -0.015 & 0.04 \\end{pmatrix} \\right) \\begin{pmatrix} 0.04 \\\\ 0.07 \\end{pmatrix} $$\nLet us first compute the product $\\Sigma^{-1} (\\mu - r \\mathbf{1})$:\n$$ \\Sigma^{-1} (\\mu - r \\mathbf{1}) = \\frac{1}{0.003375} \\begin{pmatrix} (0.09)(0.04) - (0.015)(0.07) \\\\ -(0.015)(0.04) + (0.04)(0.07) \\end{pmatrix} $$\n$$ \\Sigma^{-1} (\\mu - r \\mathbf{1}) = \\frac{1}{0.003375} \\begin{pmatrix} 0.0036 - 0.00105 \\\\ -0.0006 + 0.0028 \\end{pmatrix} = \\frac{1}{0.003375} \\begin{pmatrix} 0.00255 \\\\ 0.0022 \\end{pmatrix} $$\nNow we incorporate the risk aversion term $\\frac{1}{\\gamma} = \\frac{1}{3}$:\n$$ w^{\\star} = \\frac{1}{3} \\begin{pmatrix} \\frac{0.00255}{0.003375} \\\\ \\frac{0.0022}{0.003375} \\end{pmatrix} = \\begin{pmatrix} \\frac{0.00255}{0.010125} \\\\ \\frac{0.0022}{0.010125} \\end{pmatrix} $$\nTo obtain exact values, we convert these to fractions:\n$$ w_{1}^{\\star} = \\frac{0.00255}{0.010125} = \\frac{2550}{10125} $$\nTo simplify this fraction, we find the greatest common divisor of the numerator and denominator.\n$$ \\frac{2550}{10125} = \\frac{2 \\times 3 \\times 5^{2} \\times 17}{3^{4} \\times 5^{3}} = \\frac{2 \\times 17}{3^{3} \\times 5} = \\frac{34}{27 \\times 5} = \\frac{34}{135} $$\nFor the second weight:\n$$ w_{2}^{\\star} = \\frac{0.0022}{0.010125} = \\frac{2200}{10125} $$\nSimplifying this fraction:\n$$ \\frac{2200}{10125} = \\frac{2^{3} \\times 5^{2} \\times 11}{3^{4} \\times 5^{3}} = \\frac{2^{3} \\times 11}{3^{4} \\times 5} = \\frac{8 \\times 11}{81 \\times 5} = \\frac{88}{405} $$\nSo, the optimal weight vector is $w^{\\star} = \\begin{pmatrix} \\frac{34}{135} \\\\ \\frac{88}{405} \\end{pmatrix}$. This corresponds to an investment of approximately $25.2\\%$ in asset $1$ and $21.7\\%$ in asset $2$. The remaining fraction, $1 - \\frac{34}{135} - \\frac{88}{405} = 1 - \\frac{102}{405} - \\frac{88}{405} = 1 - \\frac{190}{405} = \\frac{215}{405} = \\frac{43}{81} \\approx 53.1\\%$, is invested in the risk-free asset.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{34}{135} \\\\\n\\frac{88}{405}\n\\end{pmatrix}\n}\n$$", "id": "2383572"}, {"introduction": "Beyond an investor's overall risk tolerance, portfolio construction often involves meeting specific risk targets, such as managing exposure to market movements. This hands-on coding exercise challenges you to find a minimum-variance portfolio that adheres to a fixed beta, a common measure of systematic risk [@problem_id:2383619]. You will translate the mathematical theory of constrained optimization into a practical algorithm, learning to handle both standard and degenerate cases.", "problem": "Write a complete, runnable program that computes, for each specified test case, the minimum-variance portfolio subject to two equality constraints: the portfolio’s beta with respect to the market equals $1$, and the full-investment budget constraint holds (weights sum to $1$). Use the following foundational definitions and facts as the starting point for your reasoning and algorithm design.\n\n- For $N$ risky assets with return vector $R \\in \\mathbb{R}^N$, covariance matrix $\\Sigma \\in \\mathbb{R}^{N \\times N}$ that is symmetric positive definite, and a market return $R_m$, the variance of a portfolio with weight vector $w \\in \\mathbb{R}^N$ is $w^{\\top} \\Sigma w$.\n- For each asset $i$, the beta with respect to the market is $\\beta_i = \\frac{\\operatorname{Cov}(R_i, R_m)}{\\operatorname{Var}(R_m)}$. Given the vector $c \\in \\mathbb{R}^N$ whose entries are $c_i = \\operatorname{Cov}(R_i, R_m)$ and the market variance $\\sigma_m^2 = \\operatorname{Var}(R_m)$, the asset beta vector is $\\beta = c / \\sigma_m^2$ (element-wise division).\n- The portfolio beta is $\\beta_p = \\beta^{\\top} w$.\n\nYour task is to compute, for each test instance:\n- A portfolio weight vector $w \\in \\mathbb{R}^N$ that minimizes $w^{\\top} \\Sigma w$ subject to $1^{\\top} w = 1$ and $\\beta^{\\top} w = 1$, where $1$ denotes the $N$-dimensional vector of ones.\n- The resulting portfolio variance $w^{\\top} \\Sigma w$.\n- The achieved portfolio beta $\\beta^{\\top} w$.\n- The sum of weights $1^{\\top} w$.\n\nFeasibility and degeneracy requirements and edge cases:\n- If the two constraints are linearly independent (that is, the two columns $1$ and $\\beta$ are linearly independent), solve the two-constraint minimum-variance problem.\n- If the two constraints are linearly dependent, there are two sub-cases:\n    - If $\\beta = k \\cdot 1$ for some scalar $k$ and $k = 1$, then the beta constraint is identical to the budget constraint. In this case, compute the minimum-variance portfolio subject to $1^{\\top} w = 1$ only.\n    - If $\\beta = k \\cdot 1$ for some scalar $k$ and $k \\neq 1$, then the system $1^{\\top} w = 1$ and $\\beta^{\\top} w = 1$ is infeasible. In this case, return an empty list for that test case.\n\nNumerical details:\n- For each test case, return a list containing the asset weights $w_1, \\dots, w_N$, followed by the portfolio variance $w^{\\top} \\Sigma w$, the achieved portfolio beta $\\beta^{\\top} w$, and the sum of weights $1^{\\top} w$. Round every reported number to $6$ decimal places.\n- If a test case is infeasible (as defined above), return an empty list for that test case.\n- Angles are not involved. There are no physical units. All numerical quantities should be treated as pure numbers.\n- Use a numerical tolerance of $10^{-10}$ to assess linear dependence and feasibility consistency.\n\nTest suite to implement inside your program (each test case provides $\\Sigma$, $c$, and $\\sigma_m^2$; compute $\\beta = c / \\sigma_m^2$ internally):\n1. Happy path, $N=3$:\n   - $\\Sigma = \\begin{bmatrix} 0.04 & 0.006 & 0.004 \\\\ 0.006 & 0.09 & 0.018 \\\\ 0.004 & 0.018 & 0.16 \\end{bmatrix}$,\n   - $c = \\begin{bmatrix} 0.02 \\\\ 0.03 \\\\ 0.04 \\end{bmatrix}$,\n   - $\\sigma_m^2 = 0.05$.\n2. Degenerate but feasible (constraints linearly dependent with consistency), $N=3$:\n   - $\\Sigma = \\begin{bmatrix} 0.01 & 0.002 & 0.0015 \\\\ 0.002 & 0.02 & 0.003 \\\\ 0.0015 & 0.003 & 0.03 \\end{bmatrix}$,\n   - $c = \\begin{bmatrix} 0.02 \\\\ 0.02 \\\\ 0.02 \\end{bmatrix}$,\n   - $\\sigma_m^2 = 0.02$.\n3. Degenerate and infeasible (constraints linearly dependent without consistency), $N=3$:\n   - $\\Sigma = \\begin{bmatrix} 0.06 & 0.01 & 0.008 \\\\ 0.01 & 0.08 & 0.012 \\\\ 0.008 & 0.012 & 0.1 \\end{bmatrix}$,\n   - $c = \\begin{bmatrix} 0.03 \\\\ 0.03 \\\\ 0.03 \\end{bmatrix}$,\n   - $\\sigma_m^2 = 0.025$.\n4. General $N=4$:\n   - $\\Sigma = \\begin{bmatrix} 0.05 & 0.01 & 0.005 & 0.004 \\\\ 0.01 & 0.07 & 0.011 & 0.006 \\\\ 0.005 & 0.011 & 0.09 & 0.012 \\\\ 0.004 & 0.006 & 0.012 & 0.11 \\end{bmatrix}$,\n   - $c = \\begin{bmatrix} 0.03 \\\\ 0.025 \\\\ 0.02 \\\\ 0.015 \\end{bmatrix}$,\n   - $\\sigma_m^2 = 0.06$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each element is either:\n    - a list of $N+3$ floats: $[w_1,\\dots,w_N,\\, w^{\\top}\\Sigma w,\\, \\beta^{\\top}w,\\, 1^{\\top}w]$ rounded to $6$ decimals, or\n    - an empty list if infeasible.\n- For example, a valid overall output structure with two feasible cases might look like: [[0.2,0.3,0.5,0.012345,1.0,1.0],[...]].", "solution": "The problem presented is a constrained quadratic optimization task, which is a fundamental problem in computational finance. The objective is to find the portfolio weight vector $w \\in \\mathbb{R}^N$ that minimizes the portfolio variance, given by the quadratic form $w^{\\top} \\Sigma w$, subject to two linear equality constraints. The covariance matrix $\\Sigma \\in \\mathbb{R}^{N \\times N}$ is specified as symmetric and positive definite, which ensures that the objective function is strictly convex and thus possesses a unique minimum.\n\nThe optimization problem can be formally stated as:\n$$\n\\begin{aligned}\n& \\underset{w}{\\text{minimize}}\n& & w^{\\top} \\Sigma w \\\\\n& \\text{subject to}\n& & \\mathbf{1}^{\\top} w = 1 \\\\\n& & & \\beta^{\\top} w = 1\n\\end{aligned}\n$$\nwhere $\\mathbf{1}$ is the $N$-dimensional vector of ones, and $\\beta$ is the vector of asset betas.\n\nThe standard and rigorous method for solving such a problem is the method of Lagrange multipliers. We construct the Lagrangian function $L(w, \\lambda_1, \\lambda_2)$:\n$$\nL(w, \\lambda_1, \\lambda_2) = w^{\\top} \\Sigma w - \\lambda_1 (\\mathbf{1}^{\\top} w - 1) - \\lambda_2 (\\beta^{\\top} w - 1)\n$$\nHere, $\\lambda_1$ and $\\lambda_2$ are the Lagrange multipliers associated with the full-investment and a target-beta constraint, respectively. To find the optimal $w$, we derive the first-order necessary conditions by setting the partial derivatives of $L$ with respect to $w$, $\\lambda_1$, and $\\lambda_2$ to zero.\n\nThe partial derivative with respect to the vector $w$ is:\n$$\n\\frac{\\partial L}{\\partial w} = 2 \\Sigma w - \\lambda_1 \\mathbf{1} - \\lambda_2 \\beta = 0\n$$\nSince $\\Sigma$ is positive definite, it is invertible. We can therefore solve for $w$:\n$$\nw = \\frac{1}{2} \\Sigma^{-1} (\\lambda_1 \\mathbf{1} + \\lambda_2 \\beta)\n$$\nThe remaining first-order conditions simply recover the original constraints:\n$$\n\\frac{\\partial L}{\\partial \\lambda_1} = -(\\mathbf{1}^{\\top} w - 1) = 0 \\implies \\mathbf{1}^{\\top} w = 1\n$$\n$$\n\\frac{\\partial L}{\\partial \\lambda_2} = -(\\beta^{\\top} w - 1) = 0 \\implies \\beta^{\\top} w = 1\n$$\nWe substitute the expression for $w$ into these two constraints to form a system of linear equations for $\\lambda_1$ and $\\lambda_2$.\n\nSubstituting into the first constraint:\n$$\n\\mathbf{1}^{\\top} \\left( \\frac{1}{2} \\Sigma^{-1} (\\lambda_1 \\mathbf{1} + \\lambda_2 \\beta) \\right) = 1 \\implies \\lambda_1 (\\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1}) + \\lambda_2 (\\mathbf{1}^{\\top} \\Sigma^{-1} \\beta) = 2\n$$\nSubstituting into the second constraint:\n$$\n\\beta^{\\top} \\left( \\frac{1}{2} \\Sigma^{-1} (\\lambda_1 \\mathbf{1} + \\lambda_2 \\beta) \\right) = 1 \\implies \\lambda_1 (\\beta^{\\top} \\Sigma^{-1} \\mathbf{1}) + \\lambda_2 (\\beta^{\\top} \\Sigma^{-1} \\beta) = 2\n$$\nLet us define the scalars $A$, $B$, and $C$ to simplify the notation:\n$$\nA = \\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1} \\quad ; \\quad B = \\mathbf{1}^{\\top} \\Sigma^{-1} \\beta \\quad ; \\quad C = \\beta^{\\top} \\Sigma^{-1} \\beta\n$$\nNote that since $\\Sigma^{-1}$ is symmetric, we have $B = \\beta^{\\top} \\Sigma^{-1} \\mathbf{1}$. The system for the multipliers becomes:\n$$\n\\begin{pmatrix} A & B \\\\ B & C \\end{pmatrix} \\begin{pmatrix} \\lambda_1 \\\\ \\lambda_2 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}\n$$\nThe determinant of the coefficient matrix is $D = AC - B^2$. This determinant is zero if and only if the constraint vectors $\\mathbf{1}$ and $\\beta$ are linearly dependent, as guaranteed by the Cauchy-Schwarz inequality for the inner product defined by $\\Sigma^{-1}$.\n\nCase 1: Linearly independent constraints ($D \\neq 0$).\nThe system has a unique solution for $(\\lambda_1, \\lambda_2)$, which can be found using Cramer's rule or matrix inversion:\n$$\n\\lambda_1 = \\frac{2(C - B)}{AC - B^2} \\quad ; \\quad \\lambda_2 = \\frac{2(A - B)}{AC - B^2}\n$$\nWith these values, the optimal weight vector $w$ is uniquely determined.\n\nCase 2: Linearly dependent constraints ($D \\approx 0$).\nThis occurs if and only if $\\beta = k \\cdot \\mathbf{1}$ for some scalar $k$. The constraints become:\n$$\n\\mathbf{1}^{\\top} w = 1\n$$\n$$\n(k \\cdot \\mathbf{1})^{\\top} w = 1 \\implies k (\\mathbf{1}^{\\top} w) = 1\n$$\nSubstituting the first constraint into the second yields $k(1) = 1$, which implies $k=1$.\n- Sub-case 2a: Feasible ($k = 1$). If the beta of every asset is $1$, the two constraints are identical. The problem degenerates to minimizing $w^{\\top} \\Sigma w$ subject only to $\\mathbf{1}^{\\top} w = 1$. The Lagrangian is $L(w, \\lambda) = w^{\\top} \\Sigma w - \\lambda(\\mathbf{1}^{\\top} w - 1)$. The first-order condition $\\frac{\\partial L}{\\partial w} = 2 \\Sigma w - \\lambda \\mathbf{1} = 0$ gives $w = \\frac{\\lambda}{2} \\Sigma^{-1} \\mathbf{1}$. Substituting into the constraint gives $\\frac{\\lambda}{2} (\\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1}) = 1$, so $\\frac{\\lambda}{2} = \\frac{1}{\\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1}}$. The optimal weights are:\n  $$\n  w = \\frac{\\Sigma^{-1} \\mathbf{1}}{\\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1}}\n  $$\n- Sub-case 2b: Infeasible ($k \\neq 1$). The constraints are contradictory. No solution exists. The problem is infeasible.\n\nThe computational algorithm directly follows this analytical framework:\n1.  For each test case, compute the beta vector $\\beta = c / \\sigma_m^2$.\n2.  Check for linear dependence of $\\mathbf{1}$ and $\\beta$. This is done by testing if all elements of $\\beta$ are equal to a constant $k$ within a specified numerical tolerance of $10^{-10}$.\n3.  If they are linearly dependent:\n    a. Check if $k$ is consistent with the constraints, i.e., $|k - 1|  10^{-10}$.\n    b. If consistent, solve the single-constraint problem using the derived formula.\n    c. If inconsistent, the problem is infeasible.\n4.  If they are linearly independent, solve the $2 \\times 2$ system for $\\lambda_1, \\lambda_2$ and compute the weights $w$.\n5.  For any feasible solution, compute the portfolio variance $w^{\\top} \\Sigma w$, achieved beta $\\beta^{\\top} w$, and sum of weights $\\mathbf{1}^{\\top} w$. The latter two serve as a verification of constraint satisfaction.\n6.  Format all numerical results to $6$ decimal places as required.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the minimum-variance portfolio under beta and budget constraints.\n    \"\"\"\n    \n    # Numerical tolerance for floating point comparisons.\n    TOL = 1e-10\n\n    test_cases = [\n        {\n            # Happy path, N=3\n            \"Sigma\": np.array([\n                [0.04, 0.006, 0.004],\n                [0.006, 0.09, 0.018],\n                [0.004, 0.018, 0.16]\n            ]),\n            \"c\": np.array([0.02, 0.03, 0.04]),\n            \"sigma_m_sq\": 0.05\n        },\n        {\n            # Degenerate but feasible, N=3\n            \"Sigma\": np.array([\n                [0.01, 0.002, 0.0015],\n                [0.002, 0.02, 0.003],\n                [0.0015, 0.003, 0.03]\n            ]),\n            \"c\": np.array([0.02, 0.02, 0.02]),\n            \"sigma_m_sq\": 0.02\n        },\n        {\n            # Degenerate and infeasible, N=3\n            \"Sigma\": np.array([\n                [0.06, 0.01, 0.008],\n                [0.01, 0.08, 0.012],\n                [0.008, 0.012, 0.1]\n            ]),\n            \"c\": np.array([0.03, 0.03, 0.03]),\n            \"sigma_m_sq\": 0.025\n        },\n        {\n            # General N=4\n            \"Sigma\": np.array([\n                [0.05, 0.01, 0.005, 0.004],\n                [0.01, 0.07, 0.011, 0.006],\n                [0.005, 0.011, 0.09, 0.012],\n                [0.004, 0.006, 0.012, 0.11]\n            ]),\n            \"c\": np.array([0.03, 0.025, 0.02, 0.015]),\n            \"sigma_m_sq\": 0.06\n        }\n    ]\n\n    results_for_print = []\n\n    for case in test_cases:\n        Sigma = case[\"Sigma\"]\n        c = case[\"c\"]\n        sigma_m_sq = case[\"sigma_m_sq\"]\n        N = Sigma.shape[0]\n\n        beta = c / sigma_m_sq\n        ones = np.ones(N)\n\n        # Check for linear dependence: beta = k * 1\n        # This is true if all elements of beta are the same.\n        is_dependent = np.allclose(beta, beta[0], atol=TOL, rtol=TOL)\n\n        w = None\n        if is_dependent:\n            k = beta[0]\n            # Check for feasibility: k must equal 1\n            if np.isclose(k, 1.0, atol=TOL):\n                # Constraints are redundant and feasible. Solve single-constraint problem.\n                # min w'Sw s.t. 1'w = 1\n                Sigma_inv = np.linalg.inv(Sigma)\n                numerator = Sigma_inv @ ones\n                denominator = ones.T @ numerator\n                w = numerator / denominator\n            else:\n                # Constraints are contradictory. Infeasible.\n                results_for_print.append(\"[]\")\n                continue\n        else:\n            # Constraints are linearly independent. Solve two-constraint problem.\n            Sigma_inv = np.linalg.inv(Sigma)\n            \n            # Define scalars for the 2x2 system\n            A = ones.T @ Sigma_inv @ ones\n            B = ones.T @ Sigma_inv @ beta\n            C = beta.T @ Sigma_inv @ beta\n\n            # Solve for Lagrange multipliers lambda1, lambda2\n            matrix_D = A * C - B * B\n            if abs(matrix_D)  TOL:\n                # This should not be reached due to the initial check but is a safeguard.\n                results_for_print.append(\"[]\")\n                continue\n\n            # System is [A, B; B, C][l1; l2] = [2; 2]\n            lambda1 = 2 * (C - B) / matrix_D\n            lambda2 = 2 * (A - B) / matrix_D\n\n            # Compute weights\n            w = 0.5 * (Sigma_inv @ (lambda1 * ones + lambda2 * beta))\n\n        if w is not None:\n            # Calculate final portfolio characteristics\n            portfolio_variance = w.T @ Sigma @ w\n            portfolio_beta = beta.T @ w\n            portfolio_weight_sum = np.sum(w)\n            \n            # Prepare result list and round all numbers\n            final_list = list(w) + [portfolio_variance, portfolio_beta, portfolio_weight_sum]\n            rounded_list = [f\"{x:.6f}\" for x in final_list]\n            results_for_print.append(f\"[{','.join(rounded_list)}]\")\n\n    # Print the final result string in the required format\n    print(f\"[{','.join(results_for_print)}]\")\n\nsolve()\n```", "id": "2383619"}, {"introduction": "Now that we have explored methods for constructing portfolios, we turn to a critical practical question: how computationally expensive are these methods? This exercise moves from financial theory to computational science by analyzing the algorithmic complexity of building the efficient frontier [@problem_id:2383604]. By calculating the operational cost, you will gain insight into how runtime scales with the number of assets, a key factor determining the applicability of these models in real-world scenarios with large investment universes.", "problem": "You are given an unconstrained mean–variance portfolio selection setting with $N$ risky assets, an expected return vector $\\boldsymbol{\\mu} \\in \\mathbb{R}^{N}$, and a symmetric positive definite (SPD) covariance matrix $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{N \\times N}$. The mean–variance efficient frontier is the set of full-investment portfolios whose expected return is parameterized by a finite set of $M$ target expected returns. Constructing this frontier for a fixed pair $(N,M)$ is modeled by the following dense linear algebra cost profile, stated in terms of floating-point operation counts where one addition or one multiplication counts as a single operation:\n\n- One dense factorization of the SPD matrix $\\boldsymbol{\\Sigma}$ with cost $\\frac{1}{3}N^{3}$ operations.\n- Two linear solves using the factorization with different right-hand sides (one equals the all-ones vector and one equals $\\boldsymbol{\\mu}$), with cost $N^{2}$ per right-hand side, for a total of $2N^{2}$ operations.\n- Three scalar quantities formed from dot products or sums of length $N$, with cost $2N$ operations per scalar, for a total of $6N$ operations.\n- For each of the $M$ target expected returns, form the corresponding portfolio weight vector as a linear combination of two precomputed $N$-vectors, with cost $2N$ operations per target, for a total of $2MN$ operations.\n\nUnder this model, the total operation count to construct the efficient frontier for a given $(N,M)$ is\n$$\nF(N,M) \\;=\\; \\tfrac{1}{3}N^{3} \\;+\\; 2N^{2} \\;+\\; 6N \\;+\\; 2MN.\n$$\n\nTask: For each test case in the following test suite, compute $F(N,M)$ and aggregate the results in the specified final output format.\n\nTest suite (each item is $(N,M)$):\n- $(10,21)$\n- $(50,21)$\n- $(100,21)$\n- $(300,21)$\n- $(1000,21)$\n- $(100,1)$\n- $(100,100)$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4,r5,r6,r7]\"), where each $r_i$ is the floating-point value of $F(N,M)$ for the corresponding test case, expressed as a real number without any unit. No additional text should be printed.", "solution": "The mean–variance efficient frontier in an unconstrained setting with full investment can be characterized via the first-order optimality (Lagrangian) conditions, also known as the Karush–Kuhn–Tucker (KKT) conditions, specialized here to equality constraints only. For a given target expected return, the optimal weights $\\boldsymbol{w}^{\\star}$ solve a system that depends on the inverse (or a factorization) of the covariance matrix $\\boldsymbol{\\Sigma}$. Constructing the entire frontier for a finite set of target returns can be organized to reuse a single dense factorization of $\\boldsymbol{\\Sigma}$ and a small number of linear solves, while subsequent target points are obtained by linear combinations of precomputed vectors.\n\nWe formalize a dense linear algebra cost model to quantify the computational complexity in floating-point operation counts. Let $N$ denote the number of assets and $M$ the number of target returns.\n\n1. Factorization cost. Since $\\boldsymbol{\\Sigma}$ is symmetric positive definite, we may use any dense SPD factorization. In the standard cost model, a dense SPD factorization has leading-order cost $\\frac{1}{3}N^{3}$ floating-point operations. Lower-order terms in $N$ are neglected at this step because the factorization dominates asymptotically.\n\n2. Linear solves. Using the factorization, solving with a single right-hand side (for instance, the all-ones vector or the expected return vector) requires a forward and a backward triangular substitution. Counting operations at leading order, each right-hand side costs $N^{2}$ operations, so two right-hand sides cost $2N^{2}$.\n\n3. Scalar coefficients. Three scalar quantities, such as portfolio frontier invariants, are computed by dot products or sums over $N$ entries. Each dot product of length $N$ uses $N$ multiplications and $N-1$ additions, which we count as $2N$ operations to remain consistent with a simple linear model; a sum over $N$ entries is of the same order. Thus, three such scalars cost $3 \\times 2N = 6N$ operations.\n\n4. Per-target portfolio weights. For each of the $M$ target expected returns, the optimal weight vector can be expressed as a linear combination of two precomputed $N$-vectors. Forming this linear combination requires $N$ multiplications and $N$ additions, i.e., $2N$ operations per target, totaling $2MN$ for all targets.\n\nSumming all stages yields the total floating-point operation count\n$$\nF(N,M) \\;=\\; \\tfrac{1}{3}N^{3} \\;+\\; 2N^{2} \\;+\\; 6N \\;+\\; 2MN.\n$$\nThis expression integrates both the dominant cubic term from factorization and the lower-order terms from solves and vector operations. It provides a first-principles quantification of runtime scaling for dense methods in constructing the efficient frontier.\n\nWe now evaluate $F(N,M)$ for the test suite.\n\n- For $(N,M)=(10,21)$:\n$$\nF(10,21) = \\tfrac{1}{3}\\cdot 10^{3} + 2\\cdot 10^{2} + 6\\cdot 10 + 2\\cdot 21\\cdot 10 = \\tfrac{1000}{3} + 200 + 60 + 420 = 1013.\\overline{3}.\n$$\n\n- For $(N,M)=(50,21)$:\n$$\nF(50,21) = \\tfrac{125000}{3} + 5000 + 300 + 2100 = 49066.\\overline{6}.\n$$\n\n- For $(N,M)=(100,21)$:\n$$\nF(100,21) = \\tfrac{1000000}{3} + 20000 + 600 + 4200 = 358133.\\overline{3}.\n$$\n\n- For $(N,M)=(300,21)$:\n$$\nF(300,21) = \\tfrac{27000000}{3} + 180000 + 1800 + 12600 = 9194400.\n$$\n\n- For $(N,M)=(1000,21)$:\n$$\nF(1000,21) = \\tfrac{1000000000}{3} + 2000000 + 6000 + 42000 = 335381333.\\overline{3}.\n$$\n\n- For $(N,M)=(100,1)$:\n$$\nF(100,1) = \\tfrac{1000000}{3} + 20000 + 600 + 200 = 354133.\\overline{3}.\n$$\n\n- For $(N,M)=(100,100)$:\n$$\nF(100,100) = \\tfrac{1000000}{3} + 20000 + 600 + 20000 = 373933.\\overline{3}.\n$$\n\nThese values demonstrate the cubic scaling in $N$ due to the dense factorization term $\\tfrac{1}{3}N^{3}$, while also capturing linear dependence on $M$ through the term $2MN$. The final program computes these values exactly according to the specified formula and prints them in the required single-line list format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\n\ndef flop_count(N: int, M: int) -> float:\n    # F(N,M) = (1/3)N^3 + 2N^2 + 6N + 2MN\n    return (N**3) / 3.0 + 2.0 * (N**2) + 6.0 * N + 2.0 * M * N\n\ndef solve():\n    # Define the test cases from the problem statement as (N, M).\n    test_cases = [\n        (10, 21),\n        (50, 21),\n        (100, 21),\n        (300, 21),\n        (1000, 21),\n        (100, 1),\n        (100, 100),\n    ]\n\n    results = []\n    for N, M in test_cases:\n        result = flop_count(N, M)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2383604"}]}