{"hands_on_practices": [{"introduction": "The defining feature of a small-world network is the combination of high local clustering and a short average path length. This practice provides a concrete, hands-on understanding of this concept by challenging you to transform a set of highly clustered, but globally disconnected, regional economic networks into a single \"small world\" [@problem_id:2431664]. By strategically adding a minimal number of \"shortcut\" trade agreements, you will develop a practical intuition for the powerful impact of long-range links on global integration.", "problem": "You are asked to formalize and solve the following decision problem about when a modular trade network (a stylized regionalized world economy) becomes a small-world network under the addition of international shortcut trade agreements. The network consists of $M$ disjoint regions. Each region contains $n$ economies (nodes) arranged on a ring lattice where each node is connected to its $k$ nearest neighbors on each side within the same region (so each node has degree $2k$ inside its region). Starting from this intra-regional baseline with no connections across regions, you may add undirected international shortcuts, each connecting one node in a region to one node in a different region. You must determine the minimal number of such shortcuts that must be added to meet a small-world criterion defined below, using the specified constructive policy that removes randomness and ensures a unique answer.\n\nFundamental base and definitions:\n- Let $G$ be a simple undirected graph on $N = M \\cdot n$ nodes with adjacency encoded by $A$. The degree of node $i$ is $d_i$.\n- The average local clustering coefficient $C$ is the arithmetic mean over nodes of the fraction of realized links among each node’s neighbors: for node $i$, if $d_i \\lt 2$, let $C_i = 0$; otherwise, $C_i = \\dfrac{2 t_i}{d_i(d_i - 1)}$ where $t_i$ is the number of edges among the neighbors of $i$. Then $C = \\dfrac{1}{N} \\sum_{i=1}^N C_i$.\n- The average shortest path length $L$ is the average of graph distances $d(i,j)$ over all unordered pairs of distinct nodes in the same connected component, i.e., $L = \\dfrac{2}{N(N-1)} \\sum_{1 \\le i \\lt j \\le N} d(i,j)$, defined only if $G$ is connected.\n- The reference random network is the Erdős–Rényi model with the same number of nodes $N$ and the same expected number of edges $E$. Its connection probability is $p = \\dfrac{2E}{N(N-1)}$ and its expected clustering is $C_{\\text{rand}} = p$. For sufficiently large $N$ and average degree $z = \\dfrac{2E}{N}$ with $z \\gt 1$, the expected average shortest path length is well approximated by $L_{\\text{rand}} \\approx \\dfrac{\\ln N}{\\ln z}$. These are widely used, well-tested approximations for benchmarking small-world structure.\n- Define $\\gamma = \\dfrac{C}{C_{\\text{rand}}}$ and $\\lambda = \\dfrac{L}{L_{\\text{rand}}}$.\n\nSmall-world criterion to be achieved:\n- The network is declared small-world if it simultaneously satisfies $\\gamma \\ge g_{\\min}$ and $\\lambda \\le \\ell_{\\max}$ for given thresholds $g_{\\min}$ and $\\ell_{\\max}$, with $g_{\\min} \\gt 1$ and $\\ell_{\\max}$ close to $1$.\n\nShortcut placement policy (deterministic and constructive):\n- Begin from the disjoint union of $M$ regional ring lattices (no international edges).\n- Iteratively add one international shortcut at a time, counting how many have been added. At each iteration:\n  1. If the graph is not connected, add a single shortcut connecting the smallest-index node in the lexicographically smallest connected component to the smallest-index node in the next lexicographically smallest component. This step is repeated across iterations until the graph becomes connected. This guarantees connectivity with exactly $C-1$ added shortcuts where $C$ is the number of connected components at that iteration.\n  2. If the graph is connected, compute all-pairs shortest-path distances. Among all unordered pairs $(i,j)$ that belong to different regions and are not already adjacent, pick the pair with the maximum graph distance. Break ties by the lexicographically smallest pair. Add this single international shortcut and continue.\n- After each shortcut addition, recompute $C$, $L$, $C_{\\text{rand}}$, $L_{\\text{rand}}$, $\\gamma$, and $\\lambda$. Stop immediately when the small-world criterion is first satisfied.\n\nGoal:\n- For each test case, compute the minimal number of added shortcuts (under the above policy) required so that the network first satisfies $\\gamma \\ge g_{\\min}$ and $\\lambda \\le \\ell_{\\max}$.\n- If the criterion cannot be met even after adding all possible international shortcuts (i.e., after every pair of nodes from different regions is connected by an edge), return $-1$ for that test case.\n\nInput model and units:\n- There is no external input; your program must implement the construction and evaluation as specified. There are no physical units. All angles, if any, should be treated in radians, though none appear directly.\n\nTest suite and parameters:\n- Case $1$: $M = 4$, $n = 12$, $k = 2$, $g_{\\min} = 1.5$, $\\ell_{\\max} = 1.3$.\n- Case $2$: $M = 3$, $n = 16$, $k = 2$, $g_{\\min} = 1.5$, $\\ell_{\\max} = 1.25$.\n- Case $3$: $M = 5$, $n = 8$, $k = 2$, $g_{\\min} = 1.5$, $\\ell_{\\max} = 1.3$.\n- Case $4$: $M = 2$, $n = 24$, $k = 3$, $g_{\\min} = 1.5$, $\\ell_{\\max} = 1.25$.\n\nOutput specification:\n- Your program should produce a single line of output containing the results for the test cases as a comma-separated list enclosed in square brackets, e.g., $[r_1,r_2,r_3,r_4]$, where each $r_i$ is an integer representing the minimal number of international shortcuts for test case $i$ (or $-1$ if unattainable).", "solution": "The problem requires us to simulate a deterministic process of network evolution and identify the point at which the network first satisfies a specified small-world criterion. The solution is procedural, following the specified rules meticulously.\n\n**1. Graph Initialization**\nFirst, we construct the initial graph. The total number of nodes is $N = M \\cdot n$. We can represent the graph using an $N \\times N$ adjacency matrix, denoted $A$. The nodes are indexed from $0$ to $N-1$, where a node with index $i$ belongs to region $\\lfloor i/n \\rfloor$ and has a local index of $i \\pmod n$.\nThe initial graph consists of $M$ disjoint ring lattices. For each region $r \\in \\{0, \\dots, M-1\\}$ and each node $i$ within that region, we establish edges to its $k$ nearest neighbors on each side. Specifically, a node with global index $u = r \\cdot n + i$ is connected to nodes $v = r \\cdot n + ((i \\pm s) \\pmod n)$ for each $s \\in \\{1, \\dots, k\\}$.\n\n**2. Iterative Shortcut Addition**\nWe proceed in a loop, adding one shortcut per iteration and checking the small-world criterion. Let `num_shortcuts` be the count of added edges, initialized to $0$.\n\nAt each step, we must first assess the connectivity of the graph. This can be done using a Breadth-First Search (BFS) or Depth-First Search (DFS) to identify the connected components.\n\n- **If the graph is disconnected** (more than one component): The policy dictates adding an edge to bridge two components. The components are sorted lexicographically by their smallest node index. A shortcut is added between the smallest-index node of the first component and the smallest-index node of the second component.\n\n- **If the graph is connected**: The policy dictates adding a \"long-range\" shortcut. This requires computation of all-pairs shortest paths (APSP). The Floyd-Warshall algorithm, with complexity $O(N^3)$, is suitable for the graph sizes in this problem. After computing the distance matrix $D$, we identify the set of all candidate pairs $(i, j)$ such that $i$ and $j$ are in different regions and are not already connected by an edge. Among these candidates, we select the pair with the maximum shortest path distance $d(i, j)$. Any ties in distance are resolved by choosing the lexicographically smallest pair $(i, j)$ where $i  j$. A shortcut is added between this selected pair. If no such candidate pairs exist, it means all inter-regional connections have been made.\n\nAfter identifying the pair $(u, v)$ to connect, we update the adjacency matrix ($A_{uv} = A_{vu} = 1$) and increment `num_shortcuts`.\n\n**3. Criterion Evaluation**\nAfter each shortcut addition, we evaluate the small-world criterion. This is only meaningful if the graph is connected, as the definition of $L$ requires it.\n\n- **Connectivity Check**: We must first verify the graph is connected. If not, the criterion cannot be satisfied, and we proceed to the next iteration.\n\n- **Metric Calculation**: If the graph is connected, we compute the necessary metrics for the current graph state.\n    - **Total Edges $E$**: This is half the sum of all elements in the adjacency matrix.\n    - **Average Clustering Coefficient $C$**: We iterate through each node $i$. We find its set of neighbors and count the number of edges $t_i$ existing between them. The local clustering is $C_i = \\frac{2t_i}{d_i(d_i-1)}$ for degree $d_i \\ge 2$. The average $C$ is the mean of all $C_i$.\n    - **Average Shortest Path Length $L$**: Using the APSP matrix computed for the current graph, we sum the distances for all $\\binom{N}{2}$ distinct pairs of nodes and divide by this total number of pairs.\n    - **Reference Metrics $C_{\\text{rand}}$ and $L_{\\text{rand}}$**: These are calculated using the mandated formulas: $z = 2E/N$, $C_{\\text{rand}} = z/(N-1)$, and $L_{\\text{rand}} = \\ln(N)/\\ln(z)$. It is necessary to ensure $z > 1$ before computing $\\ln(z)$.\n\n- **Condition Check**: Finally, we compute the ratios $\\gamma = C/C_{\\text{rand}}$ and $\\lambda = L/L_{\\text{rand}}$. If $\\gamma \\ge g_{\\min}$ and $\\lambda \\le \\ell_{\\max}$, the process terminates. The current value of `num_shortcuts` is the solution.\n\n**4. Termination**\nThe iterative process terminates in one of two ways:\n1. The small-world criterion is met, and the number of shortcuts is returned.\n2. The loop completes all possible inter-regional shortcut additions without satisfying the criterion. In the connected phase, this is detected when there are no more non-adjacent pairs in different regions. In this case, $-1$ is returned.\n\nThis complete, deterministic algorithm is implemented for each test case to find the required result.", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # M, n, k, g_min, l_max\n        (4, 12, 2, 1.5, 1.3),\n        (3, 16, 2, 1.5, 1.25),\n        (5, 8, 2, 1.5, 1.3),\n        (2, 24, 3, 1.5, 1.25),\n    ]\n\n    results = []\n    for case in test_cases:\n        M, n, k, g_min, l_max = case\n        result = _solve_one_case(M, n, k, g_min, l_max)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_one_case(M, n, k, g_min, l_max):\n    \"\"\"\n    Solves a single instance of the problem.\n    \"\"\"\n    N = M * n\n\n    # 1. Build initial adjacency matrix for M disjoint ring lattices\n    adj = np.zeros((N, N), dtype=int)\n    for r in range(M):\n        base_idx = r * n\n        for i in range(n):\n            u = base_idx + i\n            for s in range(1, k + 1):\n                v1 = base_idx + ((i + s) % n)\n                v2 = base_idx + ((i - s + n) % n)\n                adj[u, v1] = 1\n                adj[u, v2] = 1\n\n    num_shortcuts = 0\n    max_possible_shortcuts = (M * (M - 1) // 2) * (n * n)\n\n    while num_shortcuts = max_possible_shortcuts:\n        # A. Determine which shortcut to add based on the policy\n        components = _find_components(adj, N)\n        u, v = -1, -1\n\n        if len(components)  1:\n            # Policy for disconnected graphs\n            sorted_components = sorted([sorted(list(c)) for c in components])\n            u, v = sorted_components[0][0], sorted_components[1][0]\n        else:\n            # Policy for connected graphs\n            dist = _floyd_warshall(adj, N)\n            \n            candidate_pairs = []\n            for i in range(N):\n                for j in range(i + 1, N):\n                    if (i // n) != (j // n) and adj[i, j] == 0:\n                        candidate_pairs.append((i, j))\n            \n            if not candidate_pairs:\n                return -1 # No more shortcuts can be added\n\n            max_d = -np.inf\n            best_pairs = []\n            for i_p, j_p in candidate_pairs:\n                d = dist[i_p, j_p]\n                if d  max_d:\n                    max_d = d\n                    best_pairs = [(i_p, j_p)]\n                elif d == max_d:\n                    best_pairs.append((i_p, j_p))\n            \n            # Tie-break by lexicographically smallest pair\n            u, v = min(best_pairs)\n\n        # B. Add the shortcut\n        adj[u, v] = 1\n        adj[v, u] = 1\n        num_shortcuts += 1\n\n        # C. Evaluate the small-world criterion\n        # Only check if graph is connected, which is a prerequisite for L\n        post_add_components = _find_components(adj, N)\n        if len(post_add_components)  1:\n            continue\n\n        # --- Graph is connected, proceed with metric calculations ---\n        C = _calculate_C(adj, N)\n        \n        current_dist = _floyd_warshall(adj, N)\n        \n        # Check for disconnected sub-pockets (should not happen with find_components check)\n        if np.isinf(current_dist).any():\n            continue\n            \n        L = current_dist[np.triu_indices(N, k=1)].mean()\n\n        num_edges = np.sum(adj) // 2\n        avg_degree = 2 * num_edges / N\n\n        if avg_degree = 1.0:\n            continue\n\n        C_rand = avg_degree / (N - 1)\n        L_rand = np.log(N) / np.log(avg_degree)\n        \n        if C_rand == 0 or L_rand == 0:\n            continue\n\n        gamma = C / C_rand\n        lambda_val = L / L_rand\n\n        if gamma = g_min and lambda_val = l_max:\n            return num_shortcuts\n            \n    return -1\n\n\ndef _find_components(adj, N):\n    \"\"\"Finds connected components using BFS.\"\"\"\n    visited = set()\n    components = []\n    for i in range(N):\n        if i not in visited:\n            component = set()\n            q = deque([i])\n            visited.add(i)\n            while q:\n                u = q.popleft()\n                component.add(u)\n                neighbors = np.where(adj[u] == 1)[0]\n                for v in neighbors:\n                    if v not in visited:\n                        visited.add(v)\n                        q.append(v)\n            components.append(component)\n    return components\n\ndef _floyd_warshall(adj, N):\n    \"\"\"Computes all-pairs shortest paths using Floyd-Warshall.\"\"\"\n    dist = np.full((N, N), np.inf)\n    np.fill_diagonal(dist, 0)\n    for i in range(N):\n        for j in range(N):\n            if adj[i, j] == 1:\n                dist[i, j] = 1\n    \n    for k_fw in range(N):\n        for i in range(N):\n            for j in range(N):\n                if dist[i, k_fw] + dist[k_fw, j]  dist[i, j]:\n                    dist[i, j] = dist[i, k_fw] + dist[k_fw, j]\n    return dist\n\ndef _calculate_C(adj, N):\n    \"\"\"Calculates the average local clustering coefficient.\"\"\"\n    local_C = []\n    degrees = np.sum(adj, axis=1)\n    for i in range(N):\n        d_i = degrees[i]\n        if d_i  2:\n            local_C.append(0.0)\n            continue\n        \n        neighbors = np.where(adj[i] == 1)[0]\n        t_i = 0\n        subgraph = adj[np.ix_(neighbors, neighbors)]\n        t_i = np.sum(subgraph) // 2\n        \n        C_i = (2 * t_i) / (d_i * (d_i - 1))\n        local_C.append(C_i)\n        \n    return np.mean(local_C)\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2431664"}, {"introduction": "This simulation exercise directly connects network topology to a key economic outcome: the speed of price discovery in a financial market. By implementing the Watts-Strogatz model and simulating belief propagation among traders, you will see firsthand how the rewiring probability $p$, which controls the \"small-worldliness\" of the network, affects how quickly information disseminates and leads to market consensus [@problem_id:2431703]. This illustrates the crucial role of network structure in the efficiency and stability of economic systems.", "problem": "Consider a market of $N$ traders whose information network is modeled by the Watts–Strogatz small-world construction. The network is initialized as a regular ring lattice of even degree $k$ (each node connected to $k/2$ nearest neighbors on each side), and then each right-side edge is independently rewired with probability $p$ to a uniformly chosen non-neighbor, excluding self-loops and duplicate edges, yielding an undirected simple graph. Let $A \\in \\{0,1\\}^{N \\times N}$ denote the adjacency matrix of the resulting graph, and let $D \\in \\mathbb{R}^{N \\times N}$ be the diagonal matrix of node degrees. Define the row-stochastic social influence matrix $W = D^{-1} A$.\n\nEach trader $i \\in \\{1,\\dots,N\\}$ holds a belief $x_i(t)$ about the asset’s fundamental value $F \\in \\mathbb{R}$ at discrete time $t \\in \\{0,1,2,\\dots\\}$. The market price at time $t$ is the simple average $P(t) = \\frac{1}{N} \\sum_{i=1}^N x_i(t)$. Beliefs update via a DeGroot anchoring dynamic:\n$$\n\\mathbf{x}(t+1) = (1-\\alpha) W \\mathbf{x}(t) + \\alpha F \\mathbf{1},\n$$\nwhere $\\alpha \\in [0,1]$ is the public-signal anchoring weight and $\\mathbf{1}$ is the $N$-dimensional vector of ones. Initial beliefs are heterogeneous and drawn as\n$$\nx_i(0) = F + \\Delta + \\xi_i,\\quad \\xi_i \\sim \\mathcal{N}(0,\\sigma^2) \\text{ independently across } i,\n$$\nfor given $\\Delta \\in \\mathbb{R}$ and $\\sigma  0$.\n\nYour task is to write a complete, runnable program that:\n- Constructs the Watts–Strogatz network for given $N$, $k$, and $p$ as described above.\n- Evolves the belief vector $\\mathbf{x}(t)$ according to the update equation for up to $T_{\\max}$ steps.\n- Computes the first hitting time to $\\varepsilon$-convergence of the market price to the fundamental value,\n$$\n\\tau = \\min\\{t \\in \\{1,2,\\dots,T_{\\max}\\} : |P(t) - F| \\le \\varepsilon \\},\n$$\nwith the convention that if no such $t$ exists by $T_{\\max}$, then $\\tau = T_{\\max}$.\n- Uses a fixed pseudorandom number generator seed per test case to ensure reproducibility. The seed must affect both the rewiring randomness and the initial $\\xi_i$.\n\nUse the following fixed configuration for non-network parameters in all test cases: fundamental value $F = 100.0$, initial offset $\\Delta = 5.0$, noise standard deviation $\\sigma = 1.0$. The convergence tolerance is $\\varepsilon$ as specified per case. Angles are not used in this problem. All quantities are dimensionless, so no physical units are required. All time indices are integers.\n\nImplement and evaluate the following test suite of parameter values $(N,k,p,\\alpha,\\varepsilon,T_{\\max},\\text{seed})$:\n- Case $1$: $(150,\\,4,\\,0.0,\\,0.05,\\,10^{-3},\\,5000,\\,1)$\n- Case $2$: $(150,\\,4,\\,0.05,\\,0.05,\\,10^{-3},\\,5000,\\,1)$\n- Case $3$: $(150,\\,4,\\,0.2,\\,0.05,\\,10^{-3},\\,5000,\\,1)$\n- Case $4$: $(150,\\,4,\\,1.0,\\,0.05,\\,10^{-3},\\,5000,\\,1)$\n- Case $5$ (boundary, no anchoring): $(150,\\,4,\\,0.2,\\,0.0,\\,10^{-3},\\,5000,\\,1)$\n- Case $6$ (sparser base lattice): $(150,\\,2,\\,0.5,\\,0.05,\\,10^{-3},\\,5000,\\,2)$\n\nYour program should output a single line containing the list of the six resulting hitting times $\\tau$ as a comma-separated list enclosed in square brackets (for example, $\\,[\\tau_1,\\tau_2,\\dots,\\tau_6]\\,$). The final outputs must be integers. No other text should be printed.", "solution": "The solution is divided into three main components: $1$) construction of the Watts-Strogatz network, $2$) formulation and analysis of the DeGroot belief dynamics, and $3$) implementation of the numerical simulation to compute the hitting time $\\tau$.\n\n**1. Watts–Strogatz Network Construction**\n\nThe network of $N$ traders is constructed according to the specific Watts-Strogatz procedure described.\n\nFirst, an initial regular ring lattice is created. The set of nodes is $V = \\{0, 1, \\dots, N-1\\}$. Each node $i \\in V$ is connected to its $k$ nearest neighbors, where $k$ is an even integer. Specifically, each node $i$ is connected to nodes $(i \\pm j) \\pmod N$ for $j \\in \\{1, \\dots, k/2\\}$. This creates an undirected graph with every node having degree $k$. The adjacency matrix $A^{(0)}$ of this initial lattice has entries $A^{(0)}_{ij} = 1$ if node $j$ is one of the $k$ nearest neighbors of $i$, and $A^{(0)}_{ij} = 0$ otherwise.\n\nSecond, a rewiring process is applied. The problem specifies that \"each right-side edge is independently rewired\". We define the set of \"right-side\" edges as those of the form $(i, (i+j) \\pmod N)$ for $i \\in \\{0, \\dots, N-1\\}$ and $j \\in \\{1, \\dots, k/2\\}$. There are $N \\times (k/2)$ such directed pairs, corresponding to $N \\times (k/2)$ undirected edges in the lattice. For each such edge, say $(u, v)$, a random decision is made. With probability $p$, the edge $(u, v)$ is rewired. Rewiring consists of removing the edge $(u, v)$ and adding a new edge $(u, w)$, where the new target node $w$ is chosen uniformly at random from all nodes that are not $u$ and are not already connected to $u$. This procedure ensures that no self-loops ($u=w$) or multiple edges between $u$ and $w$ are created. The resulting graph remains undirected, so if we add edge $(u,w)$, we must also consider the edge $(w,u)$.\n\nThe final adjacency matrix $A \\in \\{0,1\\}^{N \\times N}$ represents the connectivity of the resulting simple, undirected graph. The pseudorandom number generator with a specified seed ensures reproducibility of the network structure.\n\n**2. DeGroot Belief Dynamics**\n\nThe evolution of traders' beliefs is governed by a DeGroot model with an anchoring term. Let $\\mathbf{x}(t) = [x_1(t), \\dots, x_N(t)]^T$ be the vector of beliefs at discrete time $t$.\n\nThe social influence matrix $W$ is defined as $W = D^{-1} A$, where $A$ is the adjacency matrix from the network construction and $D$ is the diagonal matrix of node degrees, $D_{ii} = \\text{deg}(i) = \\sum_{j=0}^{N-1} A_{ij}$. The entry $W_{ij} = A_{ij} / \\text{deg}(i)$ represents the influence of trader $j$ on trader $i$. If $\\text{deg}(i) = 0$, the $i$-th row of $W$ is all zeros. $W$ is a row-stochastic matrix, meaning its rows sum to $1$ (unless a degree is $0$).\n\nThe belief update equation is given by:\n$$\n\\mathbf{x}(t+1) = (1-\\alpha) W \\mathbf{x}(t) + \\alpha F \\mathbf{1}\n$$\nwhere $\\alpha \\in [0,1]$ is the anchoring weight to the public signal $F \\in \\mathbb{R}$, and $\\mathbf{1}$ is the $N$-dimensional vector of ones. This equation describes two competing forces on a trader's belief: social influence from their neighbors, scaled by $(1-\\alpha)$, and an anchoring pull towards the fundamental value $F$, scaled by $\\alpha$.\n\nThe system has a unique equilibrium point $\\mathbf{x}^*$ when $\\alpha > 0$. At equilibrium, $\\mathbf{x}^* = (1-\\alpha) W \\mathbf{x}^* + \\alpha F \\mathbf{1}$. For a connected graph, the unique eigenvector of $W$ for the eigenvalue $1$ is $\\mathbf{1}$. The system converges to a consensus, so $\\mathbf{x}^* = c \\mathbf{1}$ for some constant $c$. Substituting this into the equilibrium equation yields $c \\mathbf{1} = (1-\\alpha) c W \\mathbf{1} + \\alpha F \\mathbf{1} = (1-\\alpha) c \\mathbf{1} + \\alpha F \\mathbf{1}$. This simplifies to $\\alpha c = \\alpha F$, which for $\\alpha > 0$ implies $c=F$. Therefore, all beliefs, and thus their average (the market price $P(t)$), will converge to the fundamental value $F$.\n\nIn the special case where $\\alpha=0$, the equation becomes $\\mathbf{x}(t+1) = W \\mathbf{x}(t)$. The system still converges to a consensus $c$, but the value of $c$ is determined by the initial conditions and the network structure. Specifically, $c = \\sum_i \\pi_i x_i(0)$, where $\\pi$ is the stationary distribution of the random walk on the graph, given by $\\pi_i = \\text{deg}(i) / \\sum_j \\text{deg}(j)$. Given the initial beliefs $x_i(0) = F + \\Delta + \\xi_i$, the consensus value will be approximately $F+\\Delta$, which is not equal to $F$ for $\\Delta \\neq 0$. Thus, the convergence condition $|P(t) - F| \\le \\varepsilon$ is not expected to be met.\n\n**3. Numerical Simulation and Hitting Time**\n\nThe task is to compute the first hitting time $\\tau$, defined as:\n$$\n\\tau = \\min\\{t \\in \\{1, 2, \\dots, T_{\\max}\\} : |P(t) - F| \\le \\varepsilon \\}\n$$\nIf the condition is not met by $t=T_{\\max}$, then $\\tau = T_{\\max}$.\n\nThe simulation algorithm for each test case proceeds as follows:\n$1$. Set the pseudorandom number generator seed for reproducibility.\n$2$. Construct the Watts-Strogatz networkadjacency matrix $A$ for the given parameters $N$, $k$, and $p$.\n$3$. Compute the degree matrix $D$ and the influence matrix $W = D^{-1} A$. Care is taken to handle division by zero for any isolated nodes (degree $0$).\n$4$. Initialize the belief vector $\\mathbf{x}(0)$. For each $i$, $x_i(0) = F + \\Delta + \\xi_i$, where $\\xi_i$ are independent draws from a normal distribution $\\mathcal{N}(0, \\sigma^2)$. The fixed model parameters are $F=100.0$, $\\Delta=5.0$, and $\\sigma=1.0$.\n$5$. Iterate the simulation for time steps $t$ from $1$ to $T_{\\max}$:\n    a. Update the belief vector: $\\mathbf{x}(t) = (1-\\alpha) W \\mathbf{x}(t-1) + \\alpha F \\mathbf{1}$.\n    b. Compute the market price: $P(t) = \\frac{1}{N} \\sum_{i=0}^{N-1} x_i(t)$.\n    c. Check for convergence: If $|P(t) - F| \\le \\varepsilon$, record the current time step $t$ as $\\tau$ and terminate the simulation for this case.\n$6$. If the loop completes without meeting the convergence criterion, set $\\tau = T_{\\max}$.\n\nThis procedure is executed for each of the specified test cases to generate the required list of hitting times.", "answer": "```python\nimport numpy as np\n\ndef construct_watts_strogatz(N, k, p, rng):\n    \"\"\"\n    Constructs a Watts-Strogatz small-world network.\n\n    Args:\n        N (int): Number of nodes.\n        k (int): Even integer for the degree of each node in the initial lattice.\n        p (float): Rewiring probability.\n        rng (np.random.Generator): Random number generator for reproducibility.\n\n    Returns:\n        np.ndarray: The N x N adjacency matrix of the graph.\n    \"\"\"\n    if k % 2 != 0 or k = N:\n        raise ValueError(\"k must be an even integer and less than N.\")\n\n    A = np.zeros((N, N), dtype=np.int8)\n    \n    # 1. Create the initial regular ring lattice\n    edges_to_rewire = []\n    for i in range(N):\n        for j in range(1, k // 2 + 1):\n            neighbor = (i + j) % N\n            A[i, neighbor] = 1\n            A[neighbor, i] = 1\n            # \"right-side\" edges are defined as (i, i+j)\n            edges_to_rewire.append((i, neighbor))\n\n    # 2. Rewire edges\n    for u, v in edges_to_rewire:\n        if rng.random()  p:\n            # Find a a suitable node 'w' to rewire to\n            # 'w' cannot be 'u' or an existing neighbor of 'u'\n            current_neighbors = np.where(A[u, :] == 1)[0]\n            possible_targets = np.setdiff1d(np.arange(N), np.append(current_neighbors, u))\n\n            if len(possible_targets)  0:\n                w = rng.choice(possible_targets)\n                \n                # Remove old edge (u, v)\n                A[u, v] = 0\n                A[v, u] = 0\n                \n                # Add new edge (u, w)\n                A[u, w] = 1\n                A[w, u] = 1\n    \n    return A\n\ndef simulate_convergence(N, k, p, alpha, epsilon, T_max, seed):\n    \"\"\"\n    Simulates belief dynamics on a Watts-Strogatz network and finds the convergence time.\n\n    Args:\n        N (int): Number of traders.\n        k (int): Lattice degree.\n        p (float): Rewiring probability.\n        alpha (float): Anchoring weight.\n        epsilon (float): Convergence tolerance.\n        T_max (int): Maximum simulation steps.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        int: The hitting time tau.\n    \"\"\"\n    # Fixed parameters from the problem description\n    F = 100.0\n    DELTA = 5.0\n    SIGMA = 1.0\n    \n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # 1. Construct the network\n    A = construct_watts_strogatz(N, k, p, rng)\n\n    # 2. Set up the belief dynamics matrices\n    degrees = A.sum(axis=1)\n    # Handle isolated nodes (degree=0) by keeping their row as all zeros\n    W = np.divide(A, degrees[:, np.newaxis], out=np.zeros_like(A, dtype=float), where=degrees[:, np.newaxis] != 0)\n    \n    one_vector = np.ones(N)\n    \n    # 3. Initialize beliefs\n    xi = rng.normal(0, SIGMA, N)\n    x = F + DELTA + xi\n\n    # 4. Run simulation\n    for t in range(1, T_max + 1):\n        # Update beliefs\n        x = (1 - alpha) * (W @ x) + alpha * F * one_vector\n        \n        # Calculate market price\n        P_t = np.mean(x)\n        \n        # Check for convergence\n        if abs(P_t - F) = epsilon:\n            return t\n            \n    # If convergence is not reached by T_max\n    return T_max\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases: (N, k, p, alpha, epsilon, T_max, seed)\n    test_cases = [\n        (150, 4, 0.0, 0.05, 1e-3, 5000, 1),\n        (150, 4, 0.05, 0.05, 1e-3, 5000, 1),\n        (150, 4, 0.2, 0.05, 1e-3, 5000, 1),\n        (150, 4, 1.0, 0.05, 1e-3, 5000, 1),\n        (150, 4, 0.2, 0.0, 1e-3, 5000, 1),\n        (150, 2, 0.5, 0.05, 1e-3, 5000, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        tau = simulate_convergence(*case)\n        results.append(tau)\n\n    # Print output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2431703"}, {"introduction": "This advanced practice places you at the intersection of network science and game theory, a core area of computational economics. You will explore a model where agents form links based on a trade-off between the benefits of higher network centrality and the costs of maintaining connections [@problem_id:2431635]. By finding the Nash equilibrium networks, you will gain insight into how economic incentives can endogenously shape the very fabric of social and economic networks, and whether these emergent structures exhibit properties like those of small-world or scale-free models.", "problem": "You are given a class of undirected simple networks with a finite set of labeled agents. Each agent is a node, and a link is an undirected edge. For a given network with adjacency matrix $A \\in \\{0,1\\}^{n \\times n}$ (symmetric, with zeros on the diagonal), let $d_i(A)$ denote the degree of node $i$, and let $v(A) \\in \\mathbb{R}^n_{\\ge 0}$ denote the eigenvector centrality vector defined as the dominant eigenvector of $A$ normalized to unit Euclidean norm, that is, $v(A)$ satisfies $A v(A) = \\lambda_{\\max}(A) v(A)$ with $\\|v(A)\\|_2 = 1$ and $v(A) \\ge 0$ elementwise; if $A$ is the zero matrix, define $v(A) = 0$.\n\nFor parameters $\\alpha  0$ and $c  0$, each agent $i$ has payoff\n$$\nu_i(A;\\alpha,c) \\;=\\; \\alpha \\, v_i(A) \\;-\\; c \\, d_i(A).\n$$\n\nLink formation follows bilateral consent and unilateral severance. Consider the following equilibrium notion. A network $A$ is a pairwise Nash equilibrium if and only if both of the following conditions hold:\n1. For every existing link $\\{i,j\\}$ with $A_{ij} = 1$, letting $A^{-ij}$ denote the adjacency matrix with that single link removed, we have $u_i(A^{-ij};\\alpha,c) \\le u_i(A;\\alpha,c)$ and $u_j(A^{-ij};\\alpha,c) \\le u_j(A;\\alpha,c)$.\n2. For every absent link $\\{i,j\\}$ with $A_{ij} = 0$, letting $A^{+ij}$ denote the adjacency matrix with that single link added, it is not the case that $u_i(A^{+ij};\\alpha,c)  u_i(A;\\alpha,c)$ and $u_j(A^{+ij};\\alpha,c)  u_j(A;\\alpha,c)$ simultaneously.\n\nDefine the total welfare of a network as $W(A;\\alpha,c) = \\sum_{i=1}^n u_i(A;\\alpha,c)$.\n\nSmall-world and scale-free diagnostics. For any network $A$, define:\n- The local clustering coefficient of node $i$ as\n$$\nC_i(A) \\;=\\; \n\\begin{cases}\n\\frac{\\text{number of edges among the neighbors of } i}{\\binom{d_i(A)}{2}},  \\text{if } d_i(A) \\ge 2,\\\\\n0,  \\text{if } d_i(A)  2,\n\\end{cases}\n$$\nand the global clustering coefficient as $C(A) = \\frac{1}{n}\\sum_{i=1}^n C_i(A)$.\n- The average shortest-path length $L(A)$ computed on the largest connected component: if the largest connected component has size $s \\ge 2$, let $L(A)$ be the mean of the shortest-path distances over all unordered node pairs within that component; if $s  2$, set $L(A) = 0$.\n- For given $n$ and number of edges $m$, define the Erdős–Rényi baseline averages $C_{\\mathrm{rand}}(n,m)$ and $L_{\\mathrm{rand}}(n,m)$ as the arithmetic means of $C(\\cdot)$ and $L(\\cdot)$ taken over all undirected simple graphs with $n$ nodes and exactly $m$ edges.\n- The small-world coefficient is\n$$\n\\sigma(A) \\;=\\; \\frac{C(A)/C_{\\mathrm{rand}}(n,m)}{L(A)/L_{\\mathrm{rand}}(n,m)},\n$$\nwhere $m$ is the number of edges in $A$. Declare a network to be small-world-like if and only if $C_{\\mathrm{rand}}(n,m)  0$, $L_{\\mathrm{rand}}(n,m)  0$, $L(A)  0$, and $\\sigma(A)  1$; otherwise, it is not small-world-like.\n- To test for scale-free-like behavior, let $k_i = d_i(A)$ be degrees and define the Gini coefficient of the degree sequence as\n$$\nG(A) \\;=\\; \\frac{\\sum_{i=1}^n \\sum_{j=1}^n |k_i - k_j|}{2 n \\sum_{i=1}^n k_i},\n$$\nwith the convention $G(A)=0$ if $\\sum_i k_i = 0$. Using the tail defined by degrees at least $k_{\\min} = 2$, let $S = \\{i : k_i \\ge k_{\\min}\\}$ and $N_{\\mathrm{tail}} = |S|$. If $N_{\\mathrm{tail}} \\ge 2$ and $\\sum_{i \\in S} \\ln\\left(\\frac{k_i}{k_{\\min}}\\right)  0$, define the Hill-type estimator\n$$\n\\hat{\\alpha}(A) \\;=\\; 1 + \\frac{N_{\\mathrm{tail}}}{\\sum_{i \\in S} \\ln\\left(\\frac{k_i}{k_{\\min}}\\right)}.\n$$\nDeclare a network to be scale-free-like if and only if $N_{\\mathrm{tail}} \\ge 2$, $2.0 \\le \\hat{\\alpha}(A) \\le 3.5$, and $G(A) \\ge 0.4$; otherwise, it is not scale-free-like.\n\nTask. For each parameter set in the test suite below, do the following steps:\n- Enumerate all undirected simple networks on $n$ labeled nodes.\n- Compute the set of pairwise Nash equilibrium networks under the payoff specification above.\n- Among all equilibria, select the canonical equilibrium as the one that maximizes total welfare $W(A;\\alpha,c)$; if there is a tie, break ties by choosing the network with the lexicographically smallest edge-incidence bitstring using the edge order $(1,2),(1,3),\\dots,(n-1,n)$.\n- For the canonical equilibrium network, compute whether it is small-world-like and whether it is scale-free-like using the rules above.\n- For each parameter set, output a list containing:\n    1. The number of pairwise Nash equilibria (an integer).\n    2. The canonical equilibrium total welfare rounded to three decimal places (a float).\n    3. The small-world-like indicator for the canonical equilibrium (a boolean).\n    4. The scale-free-like indicator for the canonical equilibrium (a boolean).\n\nTest suite. Use the following parameter sets:\n- Case $1$: $(n,\\alpha,c) = (3, 1.0, 1.0)$.\n- Case $2$: $(n,\\alpha,c) = (3, 1.0, 0.05)$.\n- Case $3$: $(n,\\alpha,c) = (3, 1.0, 0.2)$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, the format must be exactly like `[[x1,y1,z1,w1],[x2,y2,z2,w2],[x3,y3,z3,w3]]`.", "solution": "The solution proceeds algorithmically as follows:\n\n1.  **Network Enumeration**: For a given number of agents $n$, there are $\\binom{n}{2}$ possible undirected links. The total number of simple, undirected networks is $2^{\\binom{n}{2}}$. For the given test cases with $n=3$, there are $\\binom{3}{2}=3$ possible links, leading to a manageable total of $2^3=8$ distinct networks to analyze. Each network can be uniquely represented by its adjacency matrix $A$.\n\n2.  **Payoff Calculation**: For any given network $A$, the payoff $u_i(A)$ for each agent $i$ depends on two quantities: the agent's degree $d_i(A)$ and eigenvector centrality $v_i(A)$.\n    - The degree $d_i(A)$ is the sum of the $i$-th row (or column) of the adjacency matrix $A$.\n    - The eigenvector centrality vector $v(A)$ is defined as the non-negative, unit-norm eigenvector corresponding to the largest eigenvalue $\\lambda_{\\max}(A)$ of the matrix $A$. This is guaranteed to exist by the Perron-Frobenius theorem for non-negative matrices. Numerically, it is found by computing the full eigensystem of the symmetric matrix $A$ and selecting the eigenvector associated with the largest eigenvalue. To adhere to the non-negativity constraint $v(A) \\ge 0$, the absolute value of the computed eigenvector components is taken, which is a standard procedure equivalent to resolving the arbitrary sign of the eigenvector. For the zero matrix, $v(A)$ is defined as the zero vector.\n\n3.  **Equilibrium Identification**: A network $A$ is a pairwise Nash equilibrium (PNE) if it is stable against both the removal and addition of single links. For each of the $8$ networks, we check the following two conditions:\n    - **Condition 1 (Stability to Severance)**: For every existing link $\\{i,j\\}$ (i.e., $A_{ij}=1$), we form a new network $A^{-ij}$ by removing this link. The original network $A$ is stable with respect to this link if neither agent unilaterally benefits from its removal. That is, it must be that $u_i(A^{-ij}) \\le u_i(A)$ and $u_j(A^{-ij}) \\le u_j(A)$. If this condition is violated for any existing link, the network is not a PNE.\n    - **Condition 2 (Stability to Addition)**: For every pair of agents $\\{i,j\\}$ not connected by a link (i.e., $A_{ij}=0$), we form a new network $A^{+ij}$ by adding this link. The original network $A$ is stable with respect to this non-link if the two agents do not have a mutual incentive to form it. That is, it must not be the case that both $u_i(A^{+ij})  u_i(A)$ and $u_j(A^{+ij})  u_j(A)$ hold simultaneously. If this condition is violated for any non-existing link, the network is not a PNE.\n    A network is a PNE if and only if it satisfies both conditions for all possible links.\n\n4.  **Canonical Equilibrium Selection**: After identifying the set of all PNE networks, we select a single canonical equilibrium.\n    - First, we compute the total welfare $W(A) = \\sum_{i=1}^n u_i(A)$ for each PNE.\n    - The canonical equilibrium is the PNE that maximizes this total welfare.\n    - In case of a tie in welfare, the tie is broken by selecting the network with the lexicographically smallest edge-incidence bitstring, following the specified edge ordering $(1,2), (1,3), \\dots, (n-1,n)$. For $n=3$, this corresponds to the order of edges being $((1,2), (1,3), (2,3))$.\n\n5.  **Diagnostic Analysis of the Canonical Equilibrium**: The selected canonical equilibrium network $A_c$ is analyzed for small-world and scale-free properties.\n    - **Small-World-Like Property**: This requires comparing the network's global clustering coefficient $C(A_c)$ and average shortest-path length $L(A_c)$ to those of random graphs, $C_{\\mathrm{rand}}(n,m)$ and $L_{\\mathrm{rand}}(n,m)$, where $m$ is the number of edges in $A_c$.\n        - The global clustering coefficient $C(A)$ is the average of local clustering coefficients $C_i(A)$.\n        - The average path length $L(A)$ is computed over the largest connected component.\n        - For $n=3$, the random baselines can be pre-computed by enumerating all graphs for each possible number of edges $m \\in \\{0, 1, 2, 3\\}$ and averaging their respective $C$ and $L$ values.\n        - The network is small-world-like if $C_{\\mathrm{rand}} > 0$, $L_{\\mathrm{rand}} > 0$, $L(A_c) > 0$, and the small-world coefficient $\\sigma(A_c) = \\frac{C(A_c)/C_{\\mathrm{rand}}}{L(A_c)/L_{\\mathrm{rand}}} > 1$.\n    - **Scale-Free-Like Property**: This property is diagnosed based on the network's degree distribution. It requires the Gini coefficient $G(A_c)$ to be high and the tail exponent $\\hat{\\alpha}(A_c)$ from a Hill-type estimator to be in a specific range.\n        - The definition of the Hill estimator requires at least two nodes in the degree tail ($N_{\\mathrm{tail}} \\ge 2$, where the tail is defined by degrees $k_i \\ge k_{\\min}=2$). It also requires the sum $\\sum_{i \\in S} \\ln(k_i/k_{\\min})$ to be strictly positive.\n        - For $n=3$, the maximum possible degree is $n-1=2$. Thus, any node in the tail (with degree $\\ge 2$) must have degree exactly $2$. If there are $N_{\\mathrm{tail}} \\ge 2$ such nodes, their degrees are all $k_i=2$. This leads to $k_i/k_{\\min} = 2/2 = 1$ for all $i \\in S$, and consequently $\\ln(k_i/k_{\\min}) = \\ln(1) = 0$. The sum $\\sum_{i \\in S} \\ln(k_i/k_{\\min})$ is therefore always zero whenever $N_{\\mathrm{tail}} > 0$.\n        - As the condition for defining $\\hat{\\alpha}(A)$ requires this sum to be strictly positive, the Hill estimator is never defined for any network with $n=3$. Consequently, no network with $n=3$ can be classified as scale-free-like under the given rules. This simplifies the check to always yield `False`.\n\nThis complete procedure is implemented and applied to each of the specified test cases to generate the final results.", "answer": "```python\nimport numpy as np\nfrom scipy.special import comb\nimport math\n\ndef get_payoffs(A, alpha, c):\n    \"\"\"Calculates payoffs for all agents in a network A.\"\"\"\n    n = A.shape[0]\n    # Handle the zero matrix case\n    if not np.any(A):\n        v = np.zeros(n)\n        lambda_max = 0\n    else:\n        # Use eigh for symmetric matrices; it's faster and more stable.\n        # It returns eigenvalues in ascending order.\n        eigenvalues, eigenvectors = np.linalg.eigh(A)\n        lambda_max = eigenvalues[-1]\n        v = eigenvectors[:, -1]\n        # The dominant eigenvector of a non-negative matrix can be chosen to be non-negative.\n        # np.linalg.eigh might return a vector with an overall negative sign.\n        # Taking the absolute value enforces non-negativity.\n        v = np.abs(v)\n\n    degrees = np.sum(A, axis=1)\n    payoffs = alpha * v - c * degrees\n    return payoffs, v, lambda_max, degrees\n\ndef get_all_networks(n):\n    \"\"\"Generates all simple undirected graphs on n nodes.\"\"\"\n    num_edges = n * (n - 1) // 2\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j))\n    \n    for i in range(2**num_edges):\n        A = np.zeros((n, n), dtype=int)\n        bitstring = bin(i)[2:].zfill(num_edges)\n        for k in range(num_edges):\n            if bitstring[k] == '1':\n                u, v = edges[k]\n                A[u, v] = A[v, u] = 1\n        yield A, ''.join(reversed(bitstring)) # Reverse for lexicographical order (1,2), (1,3)...\n\ndef solve():\n    \"\"\"\n    Main solver function for the network formation problem.\n    \"\"\"\n    test_cases = [\n        (3, 1.0, 1.0),\n        (3, 1.0, 0.05),\n        (3, 1.0, 0.2),\n    ]\n\n    # Pre-calculate ER baselines for n=3\n    er_baselines = {\n        # m: (C_rand, L_rand)\n        0: (0.0, 0.0),\n        1: (0.0, 1.0),\n        2: (0.0, 4.0 / 3.0),\n        3: (1.0, 1.0),\n    }\n\n    final_results = []\n    for n, alpha, c in test_cases:\n        pne_list = []\n        \n        edge_indices = []\n        for i_node in range(n):\n            for j_node in range(i_node + 1, n):\n                edge_indices.append((i_node, j_node))\n\n        for A, bitstring in get_all_networks(n):\n            is_pne = True\n            payoffs_A, _, _, _ = get_payoffs(A, alpha, c)\n\n            # Condition 1: Stability against severance\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if A[i, j] == 1:\n                        A_minus = A.copy()\n                        A_minus[i, j] = A_minus[j, i] = 0\n                        payoffs_minus, _, _, _ = get_payoffs(A_minus, alpha, c)\n                        if not (payoffs_minus[i] = payoffs_A[i] and payoffs_minus[j] = payoffs_A[j]):\n                            is_pne = False\n                            break\n                if not is_pne:\n                    break\n            if not is_pne:\n                continue\n\n            # Condition 2: Stability against addition\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if A[i, j] == 0:\n                        A_plus = A.copy()\n                        A_plus[i, j] = A_plus[j, i] = 1\n                        payoffs_plus, _, _, _ = get_payoffs(A_plus, alpha, c)\n                        if payoffs_plus[i]  payoffs_A[i] and payoffs_plus[j]  payoffs_A[j]:\n                            is_pne = False\n                            break\n                if not is_pne:\n                    break\n            \n            if is_pne:\n                welfare = np.sum(payoffs_A)\n                pne_list.append({'A': A, 'welfare': welfare, 'bitstring': bitstring})\n\n        num_pne = len(pne_list)\n        \n        if num_pne == 0:\n             # This case should not occur based on problem structure but is a safeguard.\n            final_results.append([0, 0.0, False, False])\n            continue\n            \n        # Sort to find canonical equilibrium: primary key welfare (desc), secondary key bitstring (asc)\n        pne_list.sort(key=lambda x: (-x['welfare'], x['bitstring']))\n        canonical_equilibrium = pne_list[0]\n        \n        A_c = canonical_equilibrium['A']\n        canonical_welfare = canonical_equilibrium['welfare']\n\n        # Small-world analysis\n        m = int(np.sum(A_c) / 2)\n        degrees = np.sum(A_c, axis=1)\n\n        # Global Clustering Coefficient C(A)\n        local_cs = []\n        for i in range(n):\n            d_i = degrees[i]\n            if d_i  2:\n                local_cs.append(0.0)\n            else:\n                neighbors = np.where(A_c[i] == 1)[0]\n                num_neighbor_edges = 0\n                for u_idx in range(len(neighbors)):\n                    for v_idx in range(u_idx + 1, len(neighbors)):\n                        u, v = neighbors[u_idx], neighbors[v_idx]\n                        if A_c[u, v] == 1:\n                            num_neighbor_edges += 1\n                local_cs.append(num_neighbor_edges / comb(d_i, 2))\n        C_A = np.mean(local_cs)\n\n        # Average Shortest-Path Length L(A)\n        # Find connected components and largest one\n        visited = [False] * n\n        components = []\n        for i in range(n):\n            if not visited[i]:\n                component = []\n                q = [i]\n                visited[i] = True\n                head = 0\n                while head  len(q):\n                    u = q[head]\n                    head += 1\n                    component.append(u)\n                    for v in range(n):\n                        if A_c[u, v] == 1 and not visited[v]:\n                            visited[v] = True\n                            q.append(v)\n                components.append(component)\n        \n        largest_comp = max(components, key=len) if components else []\n        s = len(largest_comp)\n        \n        L_A = 0.0\n        if s = 2:\n            dist_matrix = np.full((n, n), np.inf)\n            for i in range(n):\n                dist_matrix[i, i] = 0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if A_c[i, j] == 1:\n                        dist_matrix[i, j] = dist_matrix[j, i] = 1\n\n            for k in range(n):\n                for i in range(n):\n                    for j in range(n):\n                        dist_matrix[i, j] = min(dist_matrix[i, j], dist_matrix[i, k] + dist_matrix[k, j])\n\n            path_sum = 0\n            num_pairs = 0\n            for i_idx in range(s):\n                for j_idx in range(i_idx + 1, s):\n                    u, v = largest_comp[i_idx], largest_comp[j_idx]\n                    path_sum += dist_matrix[u, v]\n                    num_pairs += 1\n            if num_pairs  0:\n                L_A = path_sum / num_pairs\n\n        C_rand, L_rand = er_baselines[m]\n        is_small_world = False\n        if C_rand  0 and L_rand  0 and L_A  0:\n            sigma = (C_A / C_rand) / (L_A / L_rand)\n            if sigma  1:\n                is_small_world = True\n\n        # Scale-free analysis\n        # For n=3, max degree is 2. The tail starts at k_min=2.\n        # If any nodes have degree = 2, they must have degree exactly 2.\n        # This makes sum(ln(k_i/k_min)) = sum(ln(2/2)) = sum(ln(1)) = 0.\n        # The Hill estimator is undefined. Thus, it can never be scale-free for n=3.\n        is_scale_free = False\n        \n        rounded_welfare = round(canonical_welfare, 3)\n        final_results.append(f\"[{num_pne},{rounded_welfare:.3f},{str(is_small_world).lower()},{str(is_scale_free).lower()}]\")\n\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "2431635"}]}