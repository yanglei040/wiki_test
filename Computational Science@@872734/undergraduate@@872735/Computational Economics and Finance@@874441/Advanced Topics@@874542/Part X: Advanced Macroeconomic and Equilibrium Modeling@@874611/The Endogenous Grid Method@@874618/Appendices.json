{"hands_on_practices": [{"introduction": "A robust understanding of any numerical method begins with its core formula. This debugging exercise challenges you to identify and correct a critical, yet common, logical error in the EGM's application of the Euler equation. By implementing both a flawed and a correct version, you will gain a deeper appreciation for the crucial role of the discount factor, $\\beta$, in linking present and future decisions. [@problem_id:2440065]", "problem": "Consider the infinite-horizon consumption-savings problem with Constant Relative Risk Aversion (CRRA) utility. A representative agent chooses consumption $c_t$ and next-period assets $a_{t+1}$ to maximize\n$$\n\\sum_{t=0}^{\\infty} \\beta^t \\frac{c_t^{1-\\sigma}}{1-\\sigma},\n$$\nsubject to the budget constraint\n$$\na_{t+1} = m_t - c_t,\\quad m_t = R a_t + y,\\quad a_{t+1} \\ge 0,\n$$\nwhere $\\beta \\in (0,1)$ is the discount factor, $\\sigma > 0$ is the coefficient of relative risk aversion, $R > 0$ is the gross interest factor, and $y > 0$ is an exogenous constant income. The marginal utility is $u'(c) = c^{-\\sigma}$. The optimality condition away from the borrowing constraint is the Euler equation\n$$\nu'(c_t) = \\beta R u'(c_{t+1}).\n$$\n\nA common numerical method to solve for the stationary consumption policy $c(m)$ is the Endogenous Grid Method (EGM). In EGM, one fixes a grid for next period assets $a'$, computes next period cash-on-hand $m'$, evaluates next period marginal utility using the current guess of the policy, then uses the Euler equation to recover current consumption and computes the endogenous current cash-on-hand $m$, finally interpolating to obtain $c(m)$.\n\nYou are given the following broken implementation sketch of the EGM update for this one-state, no-uncertainty model. Each step is written in mathematical pseudocode, where the variables $(\\beta, R, \\sigma, y)$ are parameters, $a'$ is the exogenous grid for next period assets, $m'$ is next period cash-on-hand, and $c^{\\text{old}}(m)$ is the current policy guess as a function of $m$:\n\n- Step 1 (grid for next period assets): Choose a grid $\\{a'_i\\}_{i=1}^N$ on $[0,\\bar a]$ for some large $\\bar a > 0$.\n- Step 2 (next period resources): For each $a'_i$, compute $m'_i = R a'_i + y$.\n- Step 3 (next period marginal utility): For each $m'_i$, compute $u'(c^{\\text{old}}(m'_i)) = \\left(c^{\\text{old}}(m'_i)\\right)^{-\\sigma}$.\n- Step 4 (current consumption from Euler, BROKEN): For each $i$, set\n$$\nc^{\\text{endo}}_i = \\left(R \\cdot u'(c^{\\text{old}}(m'_i))\\right)^{-1/\\sigma}.\n$$\n- Step 5 (endogenous current resources): For each $i$, set $m^{\\text{endo}}_i = c^{\\text{endo}}_i + a'_i$.\n- Step 6 (interpolate to fixed $m$-grid): Define a fixed grid $\\{m_j\\}_{j=1}^M$ on $[y, \\bar m]$ for some large $\\bar m > 0$. For $m_j < \\min_i m^{\\text{endo}}_i$, enforce the borrowing constraint by setting $c^{\\text{new}}(m_j) = m_j$. For $m_j \\ge \\min_i m^{\\text{endo}}_i$, obtain $c^{\\text{new}}(m_j)$ by linear interpolation of the pairs $\\left(m^{\\text{endo}}_i, c^{\\text{endo}}_i\\right)$.\n\nThe broken step is Step 4. Your tasks are:\n\n1) Identify the logical error in Step 4 from first principles starting at the Euler equation and the CRRA marginal utility definition. Explain why Step 4 is incorrect and what the correct expression must be.\n\n2) Implement two solvers:\n- A \"broken\" EGM solver that uses the incorrect Step 4 above.\n- A \"corrected\" EGM solver that uses the logically corrected Step 4 you derive in part 1.\n\nBoth solvers should iterate on the consumption policy using the EGM update until convergence to a fixed point of the policy operator, or until a maximum number of iterations is reached. You must handle the borrowing constraint $a' \\ge 0$ by setting $c(m) = m$ wherever it binds. Use linear interpolation between grid points and linear extrapolation beyond the last endogenous grid point. Ensure $c(m) \\le m$ for all $m$.\n\n3) For evaluation, define the Euler residual at a given $m$ as\n$$\n\\mathcal{R}(m) = \n\\begin{cases}\n\\left|u'(c(m)) - \\beta R \\, u'\\left(c\\left(R\\left[m - c(m)\\right] + y\\right)\\right)\\right|, & \\text{if } m - c(m) > 10^{-10},\\\\\n0, & \\text{if } m - c(m) \\le 10^{-10},\n\\end{cases}\n$$\nwhich measures the absolute Euler-equation violation away from the borrowing constraint. Compute the supremum norm of the Euler residual over an evaluation grid of cash-on-hand values.\n\n4) Using your two solvers and the residual definition, run the following test suite. For each parameter set, compute the supremum Euler residual for the broken and corrected solvers on the same evaluation grid. Then output a boolean per test case that is true if and only if all of the following hold simultaneously: the corrected residual is strictly less than $10^{-5}$, the broken residual is at least $10^{-3}$, and the broken residual is at least $10$ times the corrected residual.\n\nTest suite parameter sets:\n- Case A (happy path): $\\beta = 0.96$, $R = 1.04$, $\\sigma = 2.0$, $y = 1.0$, $\\bar a = 50.0$, $N = 300$, $M = 400$.\n- Case B (more impatience and curvature): $\\beta = 0.90$, $R = 1.04$, $\\sigma = 3.0$, $y = 1.0$, $\\bar a = 50.0$, $N = 300$, $M = 400$.\n- Case C (near knife-edge $\\beta R \\approx 1$): $\\beta = 0.995$, $R = 1.004$, $\\sigma = 2.0$, $y = 1.0$, $\\bar a = 60.0$, $N = 300$, $M = 500$.\n\nUse the same stopping rule for both solvers with a maximum of $800$ iterations and a tolerance of $10^{-8}$ in the sup-norm difference between successive policy functions, employing convex damping if necessary to ensure stability.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each entry must be a boolean corresponding to Cases A, B, and C in order, as defined above. No extra whitespace or text is permitted in the output.\n\nAll answers are non-dimensional; no physical units are involved.", "solution": "The problem statement is a valid exercise in computational economics. It concerns the standard infinite-horizon consumption-savings model with Constant Relative Risk Aversion (CRRA) utility. The task is to identify and rectify a logical error in a provided sketch of the Endogenous Grid Method (EGM) algorithm, implement both the flawed and corrected versions, and compare their accuracy using the Euler equation residual. All parameters and model components are well-defined and consistent with established economic theory.\n\n**1. Identification and Correction of the Algorithmic Flaw**\n\nThe core of the dynamic optimization problem is the Euler equation, which dictates the optimal trade-off between consumption today and consumption tomorrow. For the given model, it is:\n$$\nu'(c_t) = \\beta R u'(c_{t+1})\n$$\nwhere $c_t$ is consumption in the current period and $c_{t+1}$ is consumption in the next period. The agent's utility is of the CRRA form, which implies a marginal utility function $u'(c) = c^{-\\sigma}$. Substituting this into the Euler equation yields:\n$$\nc_t^{-\\sigma} = \\beta R c_{t+1}^{-\\sigma}\n$$\nThe Endogenous Grid Method (EGM) solves for the policy function $c(m)$ by working backward from a grid of future states. In this context, $c_t$ corresponds to the endogenous current consumption we wish to find, which we denote $c^{\\text{endo}}$. The future consumption, $c_{t+1}$, is determined by the current guess of the policy function, $c^{\\text{old}}$, evaluated at next period's cash-on-hand, $m'$. Thus, $c_{t+1} = c^{\\text{old}}(m')$. The Euler equation becomes:\n$$\n(c^{\\text{endo}})^{-\\sigma} = \\beta R \\left( c^{\\text{old}}(m') \\right)^{-\\sigma}\n$$\nTo find the correct expression for today's consumption, $c^{\\text{endo}}$, we solve for it by raising both sides to the power of $-1/\\sigma$:\n$$\n\\left( (c^{\\text{endo}})^{-\\sigma} \\right)^{-1/\\sigma} = \\left( \\beta R \\left( c^{\\text{old}}(m') \\right)^{-\\sigma} \\right)^{-1/\\sigma}\n$$\n$$\nc^{\\text{endo}} = \\left( \\beta R \\right)^{-1/\\sigma} \\left( \\left(c^{\\text{old}}(m') \\right)^{-\\sigma} \\right)^{-1/\\sigma}\n$$\n$$\nc^{\\text{endo}} = \\left( \\beta R \\right)^{-1/\\sigma} c^{\\text{old}}(m')\n$$\nAlternatively, and more directly for implementation, we can write this as:\n$$\nc^{\\text{endo}} = \\left[ \\beta R \\cdot u'(c^{\\text{old}}(m')) \\right]^{-1/\\sigma}\n$$\nNow, we compare this correct derivation with the expression provided in the problem statement's Step 4:\n$$\nc^{\\text{endo}}_i = \\left(R \\cdot u'(c^{\\text{old}}(m'_i))\\right)^{-1/\\sigma} \\quad (\\text{Broken Step 4})\n$$\nThe logical error is immediately apparent: the broken step **omits the discount factor $\\beta$**.\n\nThe economic implication of this error is significant. The agent plans consumption as if they are more patient than their preferences dictate. By omitting $\\beta \\in (0,1)$, the agent effectively acts as if $\\beta=1$, failing to discount future marginal utility. This leads to an incorrect intertemporal allocation, where the agent overvalues future consumption relative to present consumption. Consequently, for any given level of future consumption, the agent using the broken rule will save more (and consume less) today compared to the truly optimal agent. This deviation from optimality will manifest as a non-zero Euler equation residual.\n\n**2. Algorithmic Implementation Strategy**\n\nTwo solvers, \"broken\" and \"corrected,\" will be implemented based on the EGM. Both will follow the same iterative procedure, differing only in the equation used in Step 4.\n\nThe algorithm for a single EGM iteration is as follows:\n1.  **Define Grids**: An exogenous grid for next-period assets, $\\{a'_i\\}_{i=1}^N$, is defined on $[0, \\bar a]$. A fixed grid for current cash-on-hand, $\\{m_j\\}_{j=1}^M$, is defined on $[y, \\bar m]$, where $\\bar m = R \\bar a + y$.\n2.  **Initial Policy**: Start with an initial guess for the consumption policy, $c^{\\text{old}}(m)$. A robust choice is $c^{\\text{old}}(m) = m$.\n3.  **Iteration Loop**: Repeat until the policy function converges.\n    a.  **Next-Period States**: For each point $a'_i$ on the asset grid, calculate the corresponding next-period cash-on-hand: $m'_i = R a'_i + y$.\n    b.  **Next-Period Consumption**: Using the current policy guess $c^{\\text{old}}$, find the consumption at each $m'_i$. This requires interpolation of $c^{\\text{old}}$ (defined on the fixed grid $\\{m_j\\}$) at the points $\\{m'_i\\}$.\n    c.  **Invert Euler Equation**: Use the Euler equation to find the current consumption, $c^{\\text{endo}}_i$, that corresponds to each $a'_i$.\n        -   **Corrected Solver**: $c^{\\text{endo}}_i = \\left[ \\beta R \\cdot (c^{\\text{old}}(m'_i))^{-\\sigma} \\right]^{-1/\\sigma}$.\n        -   **Broken Solver**: $c^{\\text{endo}}_i = \\left[ R \\cdot (c^{\\text{old}}(m'_i))^{-\\sigma} \\right]^{-1/\\sigma}$.\n    d.  **Endogenous Grid**: Construct the endogenous grid for current cash-on-hand: $m^{\\text{endo}}_i = c^{\\text{endo}}_i + a'_i$. This creates a set of pairs $(m^{\\text{endo}}_i, c^{\\text{endo}}_i)$ that satisfy the Euler equation.\n    e.  **Update Policy Function**: Construct the new policy, $c^{\\text{new}}$, on the fixed grid $\\{m_j\\}$.\n        i.  Linearly interpolate the pairs $(m^{\\text{endo}}_i, c^{\\text{endo}}_i)$ to find consumption values on the fixed grid $\\{m_j\\}$. Linear extrapolation is used for points outside the range of $\\{m^{\\text{endo}}_i\\}$.\n        ii.  Handle the borrowing constraint: For any $m_j$ below the lowest endogenous grid point ($m_j < m^{\\text{endo}}_1$), the agent is constrained and consumes all resources. Thus, set $c^{\\text{new}}(m_j) = m_j$.\n        iii. Enforce feasibility: Ensure $c^{\\text{new}}(m_j) \\le m_j$ for all $j$.\n    f.  **Convergence Check**: Calculate the supremum norm of the difference between the old and new policies, $\\max_j |c^{\\text{new}}(m_j) - c^{\\text{old}}(m_j)|$. If this difference is below a tolerance (e.g., $10^{-8}$), convergence is achieved. Otherwise, set $c^{\\text{old}} = c^{\\text{new}}$ and begin the next iteration.\n\nFor the given parameterizations, this EGM implementation is stable and does not necessitate damping.\n\n**3. Euler Residual Calculation**\n\nAfter obtaining a converged policy function $c(m)$, its accuracy is assessed by computing the supremum norm of the Euler residual, $\\mathcal{R}(m)$, across the evaluation grid $\\{m_j\\}$. For each $m_j$ on the grid:\n1.  Calculate current consumption $c_j = c(m_j)$ and next-period assets $a'_{j} = m_j - c_j$.\n2.  If the borrowing constraint is not binding ($a'_{j} > 10^{-10}$), compute next-period cash-on-hand $m'_{j} = R a'_{j} + y$ and next-period consumption $c'_{j} = c(m'_{j})$. The residual is then $|\\left(c_j\\right)^{-\\sigma} - \\beta R \\left(c'_{j}\\right)^{-\\sigma}|$.\n3.  If the constraint is binding ($a'_{j} \\le 10^{-10}$), the residual is defined as $0$.\nThe maximum of these values over all $j$ is the final error metric.\n\nThe procedure outlined above is implemented for both the broken and corrected solvers for each test case to determine the final boolean outcome.", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Solves the consumption-savings problem using both broken and corrected EGM,\n    and evaluates the results based on Euler residuals.\n    \"\"\"\n\n    def egm_solver(beta, R, sigma, y, a_bar, N, M, is_broken):\n        \"\"\"\n        Iteratively solves for the consumption policy function using the EGM.\n\n        Args:\n            beta (float): Discount factor.\n            R (float): Gross interest rate.\n            sigma (float): CRRA parameter.\n            y (float): Constant income.\n            a_bar (float): Upper bound for the asset grid.\n            N (int): Number of points in the asset grid.\n            M (int): Number of points in the cash-on-hand grid.\n            is_broken (bool): If True, uses the flawed Euler equation update.\n\n        Returns:\n            tuple: A tuple containing the cash-on-hand grid (np.ndarray) and the\n                   converged consumption policy (np.ndarray).\n        \"\"\"\n        max_iter = 800\n        tol = 1.0e-8\n\n        # Step 1: Set up grids\n        a_prime_grid = np.linspace(0.0, a_bar, N)\n        m_bar = R * a_bar + y\n        m_grid = np.linspace(y, m_bar, M)\n\n        # Initial guess for the policy function: consume everything\n        c_policy = m_grid.copy()\n\n        for _ in range(max_iter):\n            c_old_policy = c_policy.copy()\n            c_old_interp = interp1d(\n                m_grid, c_old_policy, kind='linear',\n                fill_value=\"extrapolate\", bounds_error=False\n            )\n\n            # Step 2: Next period resources\n            m_prime = R * a_prime_grid + y\n            \n            # Step 3: Next period consumption and marginal utility\n            c_at_m_prime = c_old_interp(m_prime)\n            # Ensure consumption is positive for marginal utility calculation\n            c_at_m_prime[c_at_m_prime <= 1.0e-14] = 1.0e-14\n            marg_util_at_m_prime = c_at_m_prime**(-sigma)\n\n            # Step 4: Current consumption from Euler equation (broken or correct)\n            if is_broken:\n                c_endo = (R * marg_util_at_m_prime)**(-1.0 / sigma)\n            else:\n                c_endo = (beta * R * marg_util_at_m_prime)**(-1.0 / sigma)\n\n            # Step 5: Endogenous current resources\n            m_endo = c_endo + a_prime_grid\n            \n            # Step 6: Interpolate to get new policy on the fixed m-grid\n            c_new_interp = interp1d(\n                m_endo, c_endo, kind='linear',\n                fill_value=\"extrapolate\", bounds_error=False\n            )\n            c_policy = c_new_interp(m_grid)\n\n            # Enforce borrowing constraint for m below the first endogenous point\n            borrowing_constrained = m_grid < m_endo[0]\n            c_policy[borrowing_constrained] = m_grid[borrowing_constrained]\n\n            # Enforce physical constraint c(m) <= m\n            c_policy = np.minimum(c_policy, m_grid)\n\n            # Check for convergence\n            diff = np.max(np.abs(c_policy - c_old_policy))\n            if diff < tol:\n                break\n        \n        return m_grid, c_policy\n\n    def calculate_euler_residual(policy_func, m_grid, beta, R, sigma, y):\n        \"\"\"\n        Calculates the supremum norm of the Euler equation residual.\n\n        Args:\n            policy_func (np.ndarray): The converged consumption policy.\n            m_grid (np.ndarray): The cash-on-hand grid.\n            beta, R, sigma, y (float): Model parameters.\n\n        Returns:\n            float: The max absolute Euler residual.\n        \"\"\"\n        c_interp = interp1d(\n            m_grid, policy_func, kind='linear',\n            fill_value=\"extrapolate\", bounds_error=False\n        )\n\n        c_at_m = policy_func\n        a_prime = m_grid - c_at_m\n\n        residuals = np.zeros_like(m_grid)\n        \n        # Evaluate residual only where the borrowing constraint doesn't bind\n        not_binding_mask = a_prime > 1.0e-10\n        m_eval = m_grid[not_binding_mask]\n        c_eval = c_at_m[not_binding_mask]\n        a_prime_eval = a_prime[not_binding_mask]\n\n        if m_eval.size > 0:\n            m_prime_eval = R * a_prime_eval + y\n            c_at_m_prime_eval = c_interp(m_prime_eval)\n            \n            # Ensure consumption values are positive\n            c_eval[c_eval <= 1.0e-14] = 1.0e-14\n            c_at_m_prime_eval[c_at_m_prime_eval <= 1.0e-14] = 1.0e-14\n\n            marg_util_now = c_eval**(-sigma)\n            marg_util_future = c_at_m_prime_eval**(-sigma)\n            \n            residual_values = np.abs(marg_util_now - beta * R * marg_util_future)\n            residuals[not_binding_mask] = residual_values\n\n        return np.max(residuals)\n\n    test_cases = [\n        # Case A\n        {'beta': 0.96, 'R': 1.04, 'sigma': 2.0, 'y': 1.0, 'a_bar': 50.0, 'N': 300, 'M': 400},\n        # Case B\n        {'beta': 0.90, 'R': 1.04, 'sigma': 3.0, 'y': 1.0, 'a_bar': 50.0, 'N': 300, 'M': 400},\n        # Case C\n        {'beta': 0.995, 'R': 1.004, 'sigma': 2.0, 'y': 1.0, 'a_bar': 60.0, 'N': 300, 'M': 500},\n    ]\n\n    results = []\n    for params in test_cases:\n        # Run broken solver and calculate its residual\n        m_grid_b, policy_b = egm_solver(**params, is_broken=True)\n        res_brok = calculate_euler_residual(policy_b, m_grid_b, **{k:v for k,v in params.items() if k in ['beta','R','sigma','y']})\n\n        # Run corrected solver and calculate its residual\n        m_grid_c, policy_c = egm_solver(**params, is_broken=False)\n        res_corr = calculate_euler_residual(policy_c, m_grid_c, **{k:v for k,v in params.items() if k in ['beta','R','sigma','y']})\n\n        # Evaluate the condition\n        condition_met = (res_corr < 1.0e-5) and \\\n                        (res_brok >= 1.0e-3) and \\\n                        (res_brok >= 10.0 * res_corr)\n        results.append(condition_met)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2440065"}, {"introduction": "Building on a correct implementation, we now apply the EGM to a complete, multi-period life-cycle model that incorporates a bequest motive. This practice requires you to perform backward induction from a non-trivial terminal condition, solve for the full set of policy functions, and simulate life-cycle paths. This exercise demonstrates how EGM can be adapted to richer economic settings and used to perform comparative statics, analyzing how savings behavior changes with economic preferences. [@problem_id:2440058]", "problem": "You are asked to implement the Endogenous Grid Method (EGM) for a finite-horizon, deterministic consumption-saving life-cycle model with a bequest motive at the end of life. The agent lives for $T$ consumption periods indexed by $t \\in \\{0,1,\\ldots,T-1\\}$, and faces a budget constraint $c_t + a_{t+1} = R a_t + y_t$, with $a_{t+1} \\ge \\underline{a}$ and given initial assets $a_0$. Preferences are given by\n$$\n\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T),\n$$\nwhere $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$ for $\\gamma \\ne 1$ and $\\phi(a)$ captures bequest motives. You will analyze how the bequest motive affects savings throughout the life-cycle.\n\nFundamental base and core definitions:\n- The period budget constraint is $c_t + a_{t+1} = R a_t + y_t$, where $R$ is the gross interest factor, and $y_t$ is exogenous income.\n- The borrowing constraint is $a_{t+1} \\ge \\underline{a}$ with $\\underline{a} \\in \\mathbb{R}$.\n- The agent’s objective is to choose $\\{c_t,a_{t+1}\\}_{t=0}^{T-1}$ to maximize $\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T)$ subject to the constraints.\n- The first-order conditions (Euler equations) under interior choices and no uncertainty are:\n  - For $t \\in \\{0,1,\\ldots,T-2\\}$: $u'(c_t) = \\beta R u'(c_{t+1})$.\n  - At $t = T-1$ with a terminal bequest $\\phi(a_T)$: $u'(c_{T-1}) = \\beta \\phi'(a_T)$.\n- Define the Endogenous Grid Method mapping for each $t$ by selecting a grid over $a_{t+1}$, computing $c_t$ from the Euler equation using the inverse of the marginal utility $u'(\\cdot)$, and then forming the endogenous grid for cash-on-hand $m_t = a_{t+1} + c_t$. The borrowing constraint is handled by enforcing $a_{t+1} = \\underline{a}$ when the Euler-implied choice would violate the constraint.\n\nModel specification to be implemented:\n- Preferences:\n  - $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$ with $\\gamma > 0$ and $\\gamma \\ne 1$.\n  - $\\phi(a) = \\kappa \\cdot \\frac{(a + b)^{1-\\nu} - b^{1-\\nu}}{1-\\nu}$ with $\\nu > 0$, $\\kappa \\ge 0$, and $b > 0$; hence $\\phi'(a) = \\kappa \\cdot (a+b)^{-\\nu}$.\n- Technology and income:\n  - Gross interest factor $R > 0$ is constant across $t$.\n  - Deterministic income $\\{y_t\\}_{t=0}^{T-1}$ is given.\n- Constraints:\n  - Borrowing limit $\\underline{a}$ is fixed and satisfies $\\underline{a} \\le 0$; in the test suite below it will be set to $\\underline{a} = 0$.\n- Horizon and timing:\n  - There are $T$ consumption periods. The bequest term $\\beta^{T} \\phi(a_T)$ depends on $a_T$ chosen at period $t = T-1$; there is no consumption in the terminal date beyond $t = T-1$.\n\nAlgorithmic task:\n- Use the Endogenous Grid Method to compute the policy functions $\\{c_t(m_t)\\}_{t=0}^{T-1}$ on a grid for $a_{t+1}$ at each $t$, working by backward induction.\n- At $t = T-1$, use the Euler condition $u'(c_{T-1}) = \\beta \\phi'(a_T)$ to compute endogenous $m_{T-1} = a_T + c_{T-1}$ from a grid of $a_T$. If $\\kappa = 0$ so that $\\phi'(a_T) = 0$, the interior Euler equation does not hold and the borrowing constraint binds: $a_T = \\underline{a}$ and $c_{T-1} = m_{T-1} - \\underline{a}$.\n- For $t \\le T-2$, given $c_{t+1}(\\cdot)$, compute for each grid point $a_{t+1}$ the next-period resources $m_{t+1} = R a_{t+1} + y_{t+1}$ and use $u'(c_t) = \\beta R u'(c_{t+1}(m_{t+1}))$ to obtain $c_t$, hence $m_t = a_{t+1} + c_t$. Handle the borrowing constraint by enforcing $a_{t+1} = \\underline{a}$ for low $m_t$ values as required.\n\nSimulation and analysis:\n- After computing policy functions, simulate the life-cycle path of assets and consumption starting from $a_0$ and the given income sequence to obtain $\\{a_{t+1}\\}_{t=0}^{T-1}$ and $\\{c_t\\}_{t=0}^{T-1}$. Define the period-$t$ savings as $a_{t+1}$.\n- For each parameter set in the test suite below, report the average savings across the life-cycle,\n$$\n\\bar{s} = \\frac{1}{T} \\sum_{t=0}^{T-1} a_{t+1},\n$$\nas a real number.\n\nTest suite:\nUse the following common elements across all tests:\n- Horizon $T = 5$.\n- Interest factor $R = 1.03$.\n- Discount factor $\\beta$ will vary by test case as specified below.\n- Relative risk aversion for consumption $\\gamma = 2$.\n- Bequest curvature $\\nu = 2$.\n- Bequest shift $b = 0.01$.\n- Borrowing limit $\\underline{a} = 0$.\n- Initial assets $a_0 = 0$.\n- Deterministic income sequence $\\{y_t\\}_{t=0}^{4} = \\{1.0, 1.0, 0.8, 0.6, 0.5\\}$.\n\nDefine four test cases that vary the bequest strength $\\kappa$ and intertemporal discount factor $\\beta$:\n1. Case A (baseline, no bequest): $\\kappa = 0.0$, $\\beta = 0.96$.\n2. Case B (moderate bequest): $\\kappa = 0.5$, $\\beta = 0.96$.\n3. Case C (strong bequest): $\\kappa = 2.0$, $\\beta = 0.96$.\n4. Case D (moderate bequest, more impatience): $\\kappa = 0.5$, $\\beta = 0.90$.\n\nNumerical requirements:\n- Implement the Endogenous Grid Method with a grid over $a_{t+1}$ of at least $200$ evenly spaced points on $[\\underline{a}, a_{\\max}]$, where $a_{\\max}$ is large enough to avoid truncation of optimal choices. In your program, choose a fixed $a_{\\max}$ that is numerically adequate for all test cases.\n- Use linear interpolation to evaluate $c_{t+1}(m_{t+1})$ off-grid.\n- When $m_{t+1}$ or $m_t$ fall below the smallest endogenous cash-on-hand value implied by the Euler equation, impose the borrowing constraint $a_{t+1} = \\underline{a}$ so that $c_t = m_t - \\underline{a}$.\n\nFinal output specification:\n- For each test case, compute $\\bar{s}$ as defined above and return a list of these four real numbers in order $[\\bar{s}_A, \\bar{s}_B, \\bar{s}_C, \\bar{s}_D]$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,x_3,x_4]$). No additional text should be printed.\n- No physical units arise in this problem. All numerical outputs must be real numbers in decimal representation.", "solution": "The user has provided a scientifically valid and well-posed problem from the field of computational economics. The task is to solve a finite-horizon, deterministic consumption-saving life-cycle model using the Endogenous Grid Method (EGM) and analyze the impact of a bequest motive on savings. I will proceed with a complete solution.\n\nThe agent's objective is to maximize life-cycle utility, given by:\n$$\n\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T)\n$$\nThe utility from consumption is of the Constant Relative Risk Aversion (CRRA) form, $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$, which implies a marginal utility of $u'(c) = c^{-\\gamma}$. The inverse marginal utility function is therefore $(u')^{-1}(x) = x^{-1/\\gamma}$. The bequest motive is captured by the terminal value function $\\phi(a_T)$, with marginal utility $\\phi'(a_T) = \\kappa (a_T+b)^{-\\nu}$.\n\nThe agent faces a budget constraint in each period $t$: $c_t + a_{t+1} = R a_t + y_t$, where $m_t = R a_t + y_t$ is the cash-on-hand. There is a borrowing limit $a_{t+1} \\ge \\underline{a}$.\n\nThe problem is solved by backward induction using the Endogenous Grid Method. The core of the method is to use the first-order conditions (Euler equations) to construct the policy function for consumption, $c_t(m_t)$, from the end of life backwards to the beginning.\n\nThe Euler equations are:\n1.  For periods $t \\in \\{0, 1, \\ldots, T-2\\}$: $u'(c_t) = \\beta R u'(c_{t+1})$.\n2.  For the final consumption period $t = T-1$: $u'(c_{T-1}) = \\beta \\phi'(a_T)$.\n\nThe solution proceeds in three main stages: construction of the policy function in the final period, backward iteration to construct policy functions for all prior periods, and forward simulation to find the life-cycle path and average savings.\n\n**1. Policy Function in the Terminal Period ($t=T-1$)**\n\nThe EGM starts from an exogenous grid of post-decision states. For period $t=T-1$, this is a grid for end-of-life assets, $\\{a_{T,i}\\}_{i=1}^N$, over the interval $[\\underline{a}, a_{\\max}]$.\n\n- **Case with Bequest Motive ($\\kappa > 0$):**\n  The terminal Euler equation $u'(c_{T-1}) = \\beta \\phi'(a_T)$ is used. Substituting the functional forms, we get $c_{T-1}^{-\\gamma} = \\beta \\kappa (a_T+b)^{-\\nu}$. Solving for consumption $c_{T-1}$ for each point $a_{T,i}$ on our grid:\n  $$\n  c_{T-1,i} = \\left( \\beta \\kappa (a_{T,i}+b)^{-\\nu} \\right)^{-1/\\gamma}\n  $$\n  With $c_{T-1,i}$ and $a_{T,i}$ known, we find the corresponding pre-decision state (cash-on-hand) on an endogenous grid: $m_{T-1,i} = a_{T,i} + c_{T-1,i}$. This gives us a set of pairs $(m_{T-1,i}, c_{T-1,i})$ defining the consumption policy for unconstrained agents.\n\n- **Case without Bequest Motive ($\\kappa = 0$):**\n  If $\\kappa=0$, then $\\phi'(a_T)=0$. The Euler equation $c_{T-1}^{-\\gamma} = 0$ would imply infinite consumption, which is infeasible. The agent's optimal choice is to consume all available resources, hitting the borrowing limit. Thus, $a_T = \\underline{a}$ and the policy function is simply $c_{T-1}(m_{T-1}) = m_{T-1} - \\underline{a}$.\n\n**2. Policy Function in Pre-terminal Periods ($t < T-1$)**\n\nWe iterate backward from $t=T-2$ to $t=0$. For each period $t$, we assume the policy function for the next period, $c_{t+1}(m_{t+1})$, is known (represented by the grids computed in the previous step).\n\n1.  Start with an exogenous grid for savings, $\\{a_{t+1,i}\\}_{i=1}^N$, over $[\\underline{a}, a_{\\max}]$.\n2.  For each grid point $a_{t+1,i}$, calculate the cash-on-hand in the next period: $m_{t+1,i} = R a_{t+1,i} + y_{t+1}$.\n3.  Evaluate the known policy function $c_{t+1}(m_{t+1,i})$ to find next-period consumption, $c_{t+1,i}$. This is done via linear interpolation on the stored policy grid for period $t+1$.\n4.  Use the intertemporal Euler equation, $u'(c_t) = \\beta R u'(c_{t+1})$, to work backward to current consumption, $c_{t,i}$. For CRRA utility, this simplifies nicely:\n    $$\n    c_{t,i}^{-\\gamma} = \\beta R c_{t+1,i}^{-\\gamma} \\implies c_{t,i} = (\\beta R)^{-1/\\gamma} c_{t+1,i}\n    $$\n5.  Construct the endogenous grid for cash-on-hand: $m_{t,i} = a_{t+1,i} + c_{t,i}$.\n    This yields the pairs $(m_{t,i}, c_{t,i})$ that define the policy for unconstrained agents in period $t$.\n\n**3. Handling the Borrowing Constraint**\n\nThe EGM procedure naturally generates the policy for unconstrained choices. For agents with low cash-on-hand, the borrowing constraint $a_{t+1} \\ge \\underline{a}$ will bind. Their consumption is $c_t = m_t - \\underline{a}$.\nThe EGM grid begins with $a_{t+1,1} = \\underline{a}$. This corresponds to a point $(m_{t,1}, c_{t,1})$ which forms the \"kink\" between the constrained and unconstrained regions. The policy is continuous at this point. To create a full numerical policy function, we prepend the point $(\\underline{a}, 0)$ to the EGM-generated grids $(m_{t,i}, c_{t,i})$. Linear interpolation between $(\\underline{a}, 0)$ and $(m_{t,1}, c_{t,1})$ correctly reproduces the linear policy $c_t = m_t - \\underline{a}$ in the constrained region, as $m_{t,1} = \\underline{a} + c_{t,1}$.\n\n**4. Simulation and Calculation of Average Savings**\n\nWith all policy functions $\\{c_t(m_t)\\}_{t=0}^{T-1}$ computed, we simulate the agent's life-cycle path forward in time.\n1.  Start with initial assets $a_0$.\n2.  For $t = 0, \\ldots, T-1$:\n    -   Calculate cash-on-hand: $m_t = R a_t + y_t$.\n    -   Determine consumption by interpolating on the stored policy grid: $c_t = c_t(m_t)$.\n    -   Determine savings for the next period from the budget constraint: $a_{t+1} = m_t - c_t$.\n3.  The simulation yields the path of savings $\\{a_1, a_2, \\ldots, a_T\\}$. The final metric is the average of these values:\n    $$\n    \\bar{s} = \\frac{1}{T} \\sum_{t=0}^{T-1} a_{t+1}\n    $$\nThe implementation will perform these steps for each of the four test cases specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the life-cycle model for all test cases and print the results.\n    \"\"\"\n    \n    # Define common parameters across all test cases\n    T = 5\n    R = 1.03\n    gamma = 2.0\n    nu = 2.0\n    b = 0.01\n    underline_a = 0.0\n    a0 = 0.0\n    income = np.array([1.0, 1.0, 0.8, 0.6, 0.5])\n    \n    # Numerical parameters for the Endogenous Grid Method\n    grid_size = 200\n    a_max = 20.0\n    \n    # Define the four test cases by varying bequest strength (kappa) and discount factor (beta)\n    test_cases = [\n        # (kappa, beta)\n        (0.0, 0.96),  # Case A: No bequest motive\n        (0.5, 0.96),  # Case B: Moderate bequest motive\n        (2.0, 0.96),  # Case C: Strong bequest motive\n        (0.5, 0.90),  # Case D: Moderate bequest, more impatient\n    ]\n\n    results = []\n    # Solve the model for each case and store the average savings\n    for kappa, beta in test_cases:\n        avg_savings = solve_one_case(T, R, gamma, nu, b, underline_a, a0, income, \n                                     grid_size, a_max, kappa, beta)\n        results.append(avg_savings)\n\n    # Print the results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_one_case(T, R, gamma, nu, b, underline_a, a0, income, grid_size, a_max, kappa, beta):\n    \"\"\"\n    Solves the life-cycle model for a single set of parameters using EGM.\n\n    Returns:\n        float: The average savings over the agent's life-cycle.\n    \"\"\"\n    # Exogenous grid for post-decision assets (a_{t+1})\n    a_grid = np.linspace(underline_a, a_max, grid_size)\n    \n    # Dictionary to store the computed policy functions (m_grid, c_grid) for each period\n    policy_functions = {}\n    \n    # --- Backward Induction: Solve for policy functions from T-1 to 0 ---\n    \n    # Period t = T-1 (the final consumption period)\n    t = T - 1\n    if kappa == 0.0:\n        # No bequest motive: agent consumes everything, so a_T = underline_a.\n        # The policy is c_{T-1} = m_{T-1} - underline_a.\n        # We represent this linear policy on a grid for consistency with other periods.\n        # A simple two-point grid is sufficient for linear interpolation.\n        m_grid_t = np.array([underline_a, a_max * R + np.max(income)])\n        c_grid_t = m_grid_t - underline_a\n    else:\n        # With bequest motive, use the terminal Euler equation: u'(c_{T-1}) = beta * phi'(a_T)\n        # Here, a_grid represents the grid for a_T.\n        a_T = a_grid\n        phi_p = kappa * (a_T + b)**(-nu)\n        # Avoid division by zero or negative base if phi_p <= 0\n        c_endo_t = np.full_like(a_T, 1e-10) # a small positive value for consumption\n        positive_phi_p_mask = phi_p > 0\n        c_endo_t[positive_phi_p_mask] = (beta * phi_p[positive_phi_p_mask])**(-1.0 / gamma)\n\n        # Compute the endogenous grid for cash-on-hand: m_{T-1} = a_T + c_{T-1}\n        m_endo_t = a_T + c_endo_t\n\n        # Combine with the borrowing-constrained region to form the full policy function.\n        # The constrained policy c = m - underline_a is represented by the point (underline_a, 0).\n        m_grid_t = np.concatenate(([underline_a], m_endo_t))\n        c_grid_t = np.concatenate(([0.0], c_endo_t))\n        \n    policy_functions[t] = (m_grid_t, c_grid_t)\n    \n    # Periods t = T-2 down to 0\n    for t in range(T - 2, -1, -1):\n        m_grid_t_plus_1, c_grid_t_plus_1 = policy_functions[t + 1]\n        \n        # Here, a_grid represents the grid for a_{t+1}\n        a_t_plus_1 = a_grid\n        \n        # 1. Calculate next-period cash-on-hand for each point on the a_{t+1} grid\n        m_t_plus_1 = R * a_t_plus_1 + income[t + 1]\n        \n        # 2. Interpolate on the next-period policy function to find c_{t+1}\n        c_t_plus_1 = np.interp(m_t_plus_1, m_grid_t_plus_1, c_grid_t_plus_1)\n        \n        # 3. Use the intertemporal Euler equation to find current consumption c_t\n        # For CRRA utility, this simplifies to c_t = (beta * R)^(-1/gamma) * c_{t+1}\n        c_endo_t = (beta * R)**(-1.0 / gamma) * c_t_plus_1\n        \n        # 4. Compute the endogenous grid for cash-on-hand m_t\n        m_endo_t = a_t_plus_1 + c_endo_t\n        \n        # Add the borrowing-constrained region\n        m_grid_t = np.concatenate(([underline_a], m_endo_t))\n        c_grid_t = np.concatenate(([0.0], c_endo_t))\n        \n        policy_functions[t] = (m_grid_t, c_grid_t)\n        \n    # --- Forward Simulation: Calculate the life-cycle path of assets ---\n    \n    a_path = np.zeros(T + 1)\n    a_path[0] = a0\n    \n    for t in range(T):\n        # Calculate current period's cash-on-hand\n        m_t = R * a_path[t] + income[t]\n        \n        # Get the policy function for the current period\n        m_grid_t, c_grid_t = policy_functions[t]\n        \n        # Evaluate the policy function to get consumption\n        c_t = np.interp(m_t, m_grid_t, c_grid_t)\n        \n        # Calculate next period's assets from the budget constraint\n        a_path[t + 1] = m_t - c_t\n        \n    # The problem defines savings as {a_1, ..., a_T}.\n    # Calculate the average of these savings.\n    avg_savings = np.mean(a_path[1:])\n    \n    return avg_savings\n\n# Execute the main function when the script is run\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2440058"}, {"introduction": "Beyond simply solving models, it is vital to understand *why* a particular method is effective. This exercise shifts the focus to the properties of the EGM algorithm itself, specifically its ability to generate an \"endogenous\" grid. By analyzing a model with precautionary savings, you will discover that the grid points naturally cluster in regions where the policy function has high curvature, providing a powerful insight into the method's accuracy and efficiency. [@problem_id:2440072]", "problem": "Consider a two-period consumption-savings problem with borrowing constraints in the setting of the Endogenous Grid Method, with idiosyncratic transitory income shocks that are discrete. Preferences are given by constant relative risk aversion utility $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$ for $c > 0$ and $\\gamma > 0$. The gross interest factor is $R = 1 + r$ with $r \\ge 0$, the discount factor is $\\beta \\in (0,1)$, and next-period assets satisfy the borrowing constraint $a' \\ge 0$. Let current-period assets be $a$ and current-period market resources be $m = R a + y \\epsilon$, where $y > 0$ is a constant income scale and $\\epsilon$ is a transitory income shock.\n\nThere are two periods, $t = T-1$ and $t = T$. In the terminal period $t = T$, the agent consumes all available resources, so $c_T(m_T) = m_T$. In period $t = T-1$, the first-order condition for an interior choice equates marginal utility to discounted expected marginal utility next period:\n$$\nu'\\!\\left(c_{T-1}\\right) = \\beta R \\,\\mathbb{E}\\left[u'\\!\\left(c_T(m_T')\\right)\\right] = \\beta R \\,\\mathbb{E}\\left[(m_T')^{-\\gamma}\\right],\n$$\nwhere $m_T' = R a' + y \\epsilon$. For a given nonnegative grid of next-period assets $\\{a'_i\\}_{i=1}^{N}$ that is equally spaced on $[0,\\bar{a}]$, define the corresponding set of endogenous grid points for current-period resources as\n$$\nm_i = c_{T-1}(a'_i) + a'_i, \\quad \\text{where} \\quad c_{T-1}(a'_i) = \\left(\\beta R \\sum_{j=1}^{J} \\pi_j \\left(R a'_i + y \\epsilon_j\\right)^{-\\gamma}\\right)^{-1/\\gamma}.\n$$\nHere $\\{\\epsilon_j\\}_{j=1}^{J}$ and $\\{\\pi_j\\}_{j=1}^{J}$ are the finite shock support and probabilities for $\\epsilon$ (with $\\sum_{j=1}^{J}\\pi_j = 1$ and $\\epsilon_j > 0$), respectively. The set $\\{m_i\\}_{i=1}^{N}$ constitutes the endogenous grid for current resources induced by the first-order condition and the budget constraint, given the exogenous uniform grid for $a'$.\n\nDefine the clustering index $\\kappa$ for a given parameter set as follows. Sort the endogenous grid points $\\{m_i\\}$ in ascending order (they are strictly increasing under the given assumptions), form the nearest-neighbor spacings $\\Delta_i = m_{i+1} - m_i$ for $i = 1,\\dots,N-1$, let $q = 0.10$, set $K = \\max\\{1,\\lfloor q (N-1)\\rfloor\\}$, define the mean spacing in the lower tail $\\overline{\\Delta}_{\\text{low}} = \\frac{1}{K}\\sum_{i=1}^{K}\\Delta_i$ and in the upper tail $\\overline{\\Delta}_{\\text{high}} = \\frac{1}{K}\\sum_{i=N- K}^{N-1}\\Delta_i$, and finally\n$$\n\\kappa = \\frac{\\overline{\\Delta}_{\\text{low}}}{\\overline{\\Delta}_{\\text{high}}}.\n$$\nA value $\\kappa \\in (0,1)$ indicates that endogenous grid points are more tightly clustered near the lower end of the resource space.\n\nYour task is to write a program that, for each parameter set in the test suite below, constructs the endogenous grid $\\{m_i\\}_{i=1}^{N}$ for period $t = T-1$ as described, computes the clustering index $\\kappa$, and reports the value.\n\nUse the following common modeling choices for all cases unless otherwise specified: $y = 1$, $N = 500$, $\\bar{a} = 10$, and a uniform grid on $[0,\\bar{a}]$ for $a'$. For each parameter set, the shock distribution is discrete with support $\\{\\epsilon_j\\}$ and probabilities $\\{\\pi_j\\}$ as explicitly specified.\n\nTest suite (each line is a separate test case, in the order to be used for output):\n1. $\\beta = 0.96$, $r = 0.04$, $\\gamma = 2.0$, shock support $\\{\\epsilon_j\\} = \\{0.8, 1.0, 1.2\\}$ with probabilities $\\{\\pi_j\\} = \\{0.25, 0.50, 0.25\\}$.\n2. $\\beta = 0.96$, $r = 0.04$, $\\gamma = 2.0$, shock support $\\{\\epsilon_j\\} = \\{1.0\\}$ with probabilities $\\{\\pi_j\\} = \\{1.0\\}$.\n3. $\\beta = 0.96$, $r = 0.04$, $\\gamma = 2.0$, shock support $\\{\\epsilon_j\\} = \\{0.2, 1.0, 2.2\\}$ with probabilities $\\{\\pi_j\\} = \\{0.25, 0.50, 0.25\\}$.\n4. $\\beta = 0.96$, $r = 0.04$, $\\gamma = 5.0$, shock support $\\{\\epsilon_j\\} = \\{0.8, 1.0, 1.2\\}$ with probabilities $\\{\\pi_j\\} = \\{0.25, 0.50, 0.25\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite, with each $\\kappa$ rounded to six decimal places (for example, $[0.123456,0.234567,0.345678,0.456789]$). No physical units are involved. Angles are not used. All reported values must be real numbers in decimal form, not percentages.", "solution": "The problem statement submitted for analysis is deemed valid. It is scientifically grounded, well-posed, objective, and internally consistent. It describes a standard problem in computational economics—the solution of a two-period consumption-savings model—using a canonical numerical technique, the Endogenous Grid Method (EGM). The task is to compute a well-defined \"clustering index\" $\\kappa$ for the resulting endogenous grid of market resources. All parameters, functional forms, and procedures are specified with sufficient precision to permit a unique, verifiable solution.\n\nThe solution proceeds as follows. The model consists of an agent with constant relative risk aversion (CRRA) preferences, described by the utility function $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$, who makes decisions over two periods, $t=T-1$ and $t=T$. In the terminal period $t=T$, the agent consumes all available resources, so consumption is $c_T(m_T) = m_T$.\n\nIn period $t=T-1$, the agent chooses consumption $c_{T-1}$ and next-period assets $a'$ to maximize utility, subject to the budget constraint $c_{T-1} + a' = m_{T-1}$, where $m_{T-1}$ are current market resources. The first-order condition, or Euler equation, for an interior solution is:\n$$\nu'(c_{T-1}) = \\beta R \\, \\mathbb{E}[u'(c_T)]\n$$\nwhere $\\beta$ is the discount factor and $R$ is the gross interest factor. Substituting the CRRA marginal utility $u'(c) = c^{-\\gamma}$ and the terminal period consumption rule $c_T = m_T = R a' + y\\epsilon$ gives:\n$$\nc_{T-1}^{-\\gamma} = \\beta R \\, \\mathbb{E}[(R a' + y\\epsilon)^{-\\gamma}]\n$$\nThe expectation is taken over the discrete distribution of the transitory income shock $\\epsilon$, which has support $\\{\\epsilon_j\\}_{j=1}^{J}$ and probabilities $\\{\\pi_j\\}_{j=1}^{J}$. The expectation term is thus a weighted sum:\n$$\n\\mathbb{E}[(R a' + y\\epsilon)^{-\\gamma}] = \\sum_{j=1}^{J} \\pi_j (R a' + y \\epsilon_j)^{-\\gamma}\n$$\nThe Endogenous Grid Method circumvents the need to solve for the root of the Euler equation for each point on a grid of the state variable $m_{T-1}$. Instead, it proceeds by first defining an exogenous, uniformly spaced grid for the choice variable, next-period assets $a'$. Let this grid be $\\mathcal{A}' = \\{a'_i\\}_{i=1}^{N}$ on the interval $[0, \\bar{a}]$.\n\nFor each point $a'_i \\in \\mathcal{A}'$, we can directly compute the right-hand side of the Euler equation. This allows us to solve for the level of current consumption $c_{T-1}(a'_i)$ that would make the choice of $a'_i$ optimal:\n$$\nc_{T-1}(a'_i) = \\left( \\beta R \\sum_{j=1}^{J} \\pi_j (R a'_i + y \\epsilon_j)^{-\\gamma} \\right)^{-1/\\gamma}\n$$\nWith both optimal consumption $c_{T-1}(a'_i)$ and savings $a'_i$ known, the corresponding level of current-period market resources $m_i$ can be recovered from the budget constraint:\n$$\nm_i = c_{T-1}(a'_i) + a'_i\n$$\nThe set of points $\\mathcal{M} = \\{m_i\\}_{i=1}^{N}$ constitutes the endogenous grid. These are the specific resource levels at which an agent would optimally choose one of the savings levels from the exogenous grid $\\mathcal{A}'$. Under the given assumptions, the function mapping $a'_i$ to $m_i$ is strictly increasing, so the resulting grid $\\mathcal{M}$ is ordered.\n\nThe final step is to compute the clustering index $\\kappa$. This index quantifies the spacing of the endogenous grid points. First, the nearest-neighbor spacings are calculated: $\\Delta_i = m_{i+1} - m_i$ for $i=1, \\dots, N-1$. We define a quantile $q=0.10$ and determine the number of grid spacings in the lower and upper tails as $K = \\max\\{1, \\lfloor q (N-1) \\rfloor\\}$. The average spacing in the lower tail is $\\overline{\\Delta}_{\\text{low}} = \\frac{1}{K}\\sum_{i=1}^{K}\\Delta_i$, and the average spacing in the upper tail is $\\overline{\\Delta}_{\\text{high}} = \\frac{1}{K}\\sum_{i=N-K}^{N-1}\\Delta_i$. The clustering index is the ratio of these two averages:\n$$\n\\kappa = \\frac{\\overline{\\Delta}_{\\text{low}}}{\\overline{\\Delta}_{\\text{high}}}\n$$\nA value of $\\kappa < 1$ indicates that the grid points are more densely clustered at lower levels of market resources, which is a typical outcome under precautionary motives.\n\nThe computational implementation will carry out this sequence of operations for each parameter set provided. We utilize vectorized calculations with NumPy for efficiency. The common parameters are $y=1$, $N=500$, and $\\bar{a}=10$. The specified values for $\\beta$, $r$, $\\gamma$, and the shock distribution $\\{\\epsilon_j, \\pi_j\\}$ are used for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_kappa(beta, r, gamma, epsilons, probabilities, y, N, a_bar, q):\n    \"\"\"\n    Calculates the clustering index kappa for a two-period consumption-savings model.\n\n    This function implements the Endogenous Grid Method (EGM) to construct an\n    endogenous grid of market resources and then computes a clustering index\n    based on the spacing of the grid points.\n\n    Args:\n        beta (float): The discount factor.\n        r (float): The net interest rate.\n        gamma (float): The coefficient of relative risk aversion.\n        epsilons (list[float]): The support of the discrete income shock.\n        probabilities (list[float]): The probabilities for the income shocks.\n        y (float): The income scale factor.\n        N (int): The number of points in the asset grid.\n        a_bar (float): The maximum value for the asset grid.\n        q (float): The quantile used for calculating the tail size K.\n\n    Returns:\n        float: The computed clustering index kappa.\n    \"\"\"\n    # 1. Define constants and exogenous grid for next-period assets a'\n    R = 1.0 + r\n    a_prime_grid = np.linspace(0.0, a_bar, N)\n\n    # 2. Vectorized calculation of expected marginal utility\n    # Reshape arrays for broadcasting to create matrices of shape (N, J)\n    # where J is the number of shock points.\n    epsilons_reshaped = np.array(epsilons)[np.newaxis, :]       # Shape (1, J)\n    probabilities_reshaped = np.array(probabilities)[np.newaxis, :]  # Shape (1, J)\n    a_prime_reshaped = a_prime_grid[:, np.newaxis]             # Shape (N, 1)\n\n    # Matrix of next-period market resources: m' = R*a' + y*epsilon\n    # Resulting shape is (N, J) due to broadcasting.\n    m_prime_matrix = R * a_prime_reshaped + y * epsilons_reshaped\n    \n    # Matrix of next-period marginal utilities: u'(m') = (m')^(-gamma)\n    marginal_utility_matrix = m_prime_matrix**(-gamma)\n\n    # Expected next-period marginal utility, weighting by probabilities.\n    # The sum is over the shock dimension (axis=1), resulting in shape (N,).\n    expected_marginal_utility = np.sum(marginal_utility_matrix * probabilities_reshaped, axis=1)\n\n    # 3. Invert the Euler equation to find current-period consumption c\n    # c = (beta * R * E[u'(m')])^(-1/gamma)\n    c_grid = (beta * R * expected_marginal_utility)**(-1.0 / gamma)\n\n    # 4. Construct the endogenous grid for current-period resources m\n    # m = c + a'\n    m_grid = c_grid + a_prime_grid\n\n    # 5. Calculate the clustering index kappa\n    # The problem statement guarantees m_grid is strictly increasing.\n    spacings = np.diff(m_grid)\n    \n    # Number of spacings is N-1\n    num_spacings = N - 1\n    \n    # Determine the number of spacings in the lower and upper tails\n    K = int(max(1.0, np.floor(q * num_spacings)))\n    \n    # Calculate the mean spacing in the lower and upper tails\n    mean_delta_low = np.mean(spacings[:K])\n    mean_delta_high = np.mean(spacings[-K:])\n\n    # The clustering index is the ratio of these means\n    kappa = mean_delta_low / mean_delta_high\n    \n    return kappa\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Common modeling parameters for all test cases\n    y = 1.0\n    N = 500\n    a_bar = 10.0\n    q = 0.10\n\n    # Test suite with parameters for each case\n    test_cases = [\n        {'beta': 0.96, 'r': 0.04, 'gamma': 2.0, 'epsilons': [0.8, 1.0, 1.2], 'probabilities': [0.25, 0.50, 0.25]},\n        {'beta': 0.96, 'r': 0.04, 'gamma': 2.0, 'epsilons': [1.0], 'probabilities': [1.0]},\n        {'beta': 0.96, 'r': 0.04, 'gamma': 2.0, 'epsilons': [0.2, 1.0, 2.2], 'probabilities': [0.25, 0.50, 0.25]},\n        {'beta': 0.96, 'r': 0.04, 'gamma': 5.0, 'epsilons': [0.8, 1.0, 1.2], 'probabilities': [0.25, 0.50, 0.25]},\n    ]\n\n    results = []\n    # Loop through each test case, calculate kappa, and store the result\n    for case in test_cases:\n        kappa = calculate_kappa(\n            beta=case['beta'],\n            r=case['r'],\n            gamma=case['gamma'],\n            epsilons=case['epsilons'],\n            probabilities=case['probabilities'],\n            y=y,\n            N=N,\n            a_bar=a_bar,\n            q=q\n        )\n        results.append(kappa)\n\n    # Format the list of results into the required string format\n    # Each result is rounded to six decimal places.\n    formatted_results = [f'{res:.6f}' for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver\nsolve()\n```", "id": "2440072"}]}