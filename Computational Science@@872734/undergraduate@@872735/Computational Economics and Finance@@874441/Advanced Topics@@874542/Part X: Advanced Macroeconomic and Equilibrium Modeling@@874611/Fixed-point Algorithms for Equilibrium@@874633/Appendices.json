{"hands_on_practices": [{"introduction": "Many dynamic systems, from weather patterns to the evolution of market shares, can be modeled as Markov chains. The long-run behavior of such a system is described by its stationary distribution, which represents a stable equilibrium where the probability of being in any given state remains constant over time. This practice demonstrates that finding this stationary distribution is equivalent to solving a linear fixed-point problem, providing a foundational exercise in applying fixed-point concepts to a stochastic equilibrium [@problem_id:2393467].", "problem": "Consider a finite-state Markov chain with a row-stochastic transition matrix $P \\in \\mathbb{R}^{n \\times n}$, where each entry $P_{ij} \\geq 0$ and each row sums to $1$. A stationary distribution is any probability vector $\\pi \\in \\mathbb{R}^n$ with nonnegative components that satisfy $\\sum_{i=1}^n \\pi_i = 1$ and the fixed-point equation $\\pi = \\pi P$. For each test case below, compute the stationary distribution that solves $\\pi = \\pi P$ and $\\sum_i \\pi_i = 1$ with $\\pi_i \\geq 0$ for all $i$. Express each component of each stationary distribution as a real number rounded to exactly six decimal places using standard rounding to nearest.\n\nTest suite (each $P^{(k)}$ is row-stochastic):\n- Test case $1$ (dimension $2$):\n  $$P^{(1)} = \\begin{bmatrix}\n  0.9  0.1 \\\\\n  0.5  0.5\n  \\end{bmatrix}.$$\n- Test case $2$ (dimension $2$):\n  $$P^{(2)} = \\begin{bmatrix}\n  0.999  0.001 \\\\\n  0.01  0.99\n  \\end{bmatrix}.$$\n- Test case $3$ (dimension $3$):\n  $$P^{(3)} = \\begin{bmatrix}\n  0.7  0.2  0.1 \\\\\n  0.4  0.4  0.2 \\\\\n  0.3  0.3  0.4\n  \\end{bmatrix}.$$\n- Test case $4$ (dimension $4$):\n  $$P^{(4)} = \\begin{bmatrix}\n  0.25  0.25  0.25  0.25 \\\\\n  0.25  0.25  0.25  0.25 \\\\\n  0.25  0.25  0.25  0.25 \\\\\n  0.25  0.25  0.25  0.25\n  \\end{bmatrix}.$$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of real numbers rounded to six decimals, with no additional text. For example, an output with two test cases could look like $[[0.500000,0.500000],[0.333333,0.333333,0.333334]]$.", "solution": "The problem requires finding the stationary distribution $\\pi$ for a given finite-state Markov chain defined by a row-stochastic transition matrix $P \\in \\mathbb{R}^{n \\times n}$.\n\nA stationary distribution is a probability vector $\\pi = [\\pi_1, \\pi_2, \\dots, \\pi_n]$ satisfying three conditions:\n$1$. $\\pi_i \\ge 0$ for all $i \\in \\{1, \\dots, n\\}$.\n$2$. $\\sum_{i=1}^n \\pi_i = 1$.\n$3$. The fixed-point equation: $\\pi = \\pi P$.\n\nThe fixed-point equation $\\pi = \\pi P$ can be rewritten as a homogeneous system of linear equations:\n$$ \\pi P - \\pi = \\mathbf{0} $$\n$$ \\pi (P - I) = \\mathbf{0} $$\nwhere $I$ is the $n \\times n$ identity matrix and $\\mathbf{0}$ is the $n$-dimensional zero row vector.\n\nThis equation signifies that $\\pi$ is a left eigenvector of the matrix $P$ corresponding to the eigenvalue $\\lambda = 1$. Equivalently, by transposing the equation, we get:\n$$ (P^T - I^T) \\pi^T = \\mathbf{0}^T $$\n$$ (P^T - I) \\pi^T = \\mathbf{0} $$\nThis shows that the column vector $\\pi^T$ is a right eigenvector of the transpose matrix $P^T$ corresponding to the eigenvalue $\\lambda = 1$.\n\nFor any row-stochastic matrix $P$, the sum of each row is $1$. This implies that $P \\mathbf{1} = \\mathbf{1}$, where $\\mathbf{1}$ is the column vector of all ones. Thus, $\\lambda=1$ is always an eigenvalue of $P$. Since a matrix and its transpose share the same set of eigenvalues, $\\lambda=1$ is also an eigenvalue of $P^T$.\n\nThe problem of finding $\\pi$ is therefore reduced to finding the eigenspace of $P^T$ for $\\lambda=1$. The given matrices correspond to irreducible Markov chains (every state is accessible from every other state). For such chains, the Perron-Frobenius theorem guarantees that the eigenvalue $\\lambda=1$ has an algebraic multiplicity of $1$. Consequently, its corresponding eigenspace is one-dimensional.\n\nThis means that any non-zero solution to $(P^T - I)\\pi^T = \\mathbf{0}$ is unique up to a scalar multiple. We find one such non-zero eigenvector, let us call it $v$. By the same theorem, for an irreducible non-negative matrix like $P^T$, the eigenvector $v$ corresponding to the dominant eigenvalue (here $\\lambda=1$) can be chosen to have all non-negative components.\n\nThe final step is to enforce the normalization condition $\\sum_{i=1}^n \\pi_i = 1$. We take the found eigenvector $v$ and normalize it by dividing by the sum of its components:\n$$ \\pi^T = \\frac{v}{\\sum_{i=1}^n v_i} $$\nThe resulting vector $\\pi$ is the unique stationary distribution.\n\nThe computational procedure is as follows:\n$1$. For a given matrix $P$, construct the matrix $A = P^T - I$.\n$2$. Find a basis for the null space of $A$. For the given problems, this will be a single vector $v$.\n$3$. Ensure all components of $v$ are non-negative, taking the absolute value if necessary.\n$4$. Normalize $v$ to obtain the probability vector $\\pi^T$.\n$5$. The components of the resulting vector are then rounded to six decimal places as required.\nThis method is applied to each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Computes the stationary distribution for a set of Markov chain transition matrices.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [0.9, 0.1],\n            [0.5, 0.5]\n        ]),\n        np.array([\n            [0.999, 0.001],\n            [0.01, 0.99]\n        ]),\n        np.array([\n            [0.7, 0.2, 0.1],\n            [0.4, 0.4, 0.2],\n            [0.3, 0.3, 0.4]\n        ]),\n        np.array([\n            [0.25, 0.25, 0.25, 0.25],\n            [0.25, 0.25, 0.25, 0.25],\n            [0.25, 0.25, 0.25, 0.25],\n            [0.25, 0.25, 0.25, 0.25]\n        ])\n    ]\n\n    all_results_str = []\n    \n    for P in test_cases:\n        # The stationary distribution pi is the left eigenvector of P for eigenvalue 1.\n        # This is equivalent to the right eigenvector of P.T for eigenvalue 1.\n        # We solve the system (P.T - I) * pi.T = 0.\n        \n        n = P.shape[0]\n        I = np.identity(n)\n        A = P.T - I\n\n        # Find the null space of A. For an irreducible Markov chain, this space\n        # is one-dimensional and spanned by the stationary distribution vector.\n        # The result is a basis for the null space, with basis vectors as columns.\n        v = null_space(A)\n\n        # By Perron-Frobenius theorem, the stationary distribution for an\n        # irreducible chain has all positive components. The eigenvector is\n        # unique up to a scalar, so we take the absolute value to ensure non-negativity.\n        pi_vec = np.abs(v[:, 0])\n        \n        # Normalize the vector to make it a probability distribution.\n        pi = pi_vec / np.sum(pi_vec)\n        \n        # Format results to six decimal places.\n        pi_str_list = [f\"{x:.6f}\" for x in pi]\n        all_results_str.append(f\"[{','.join(pi_str_list)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "2393467"}, {"introduction": "We now move from a simple stochastic equilibrium to the heart of modern dynamic economics: solving for an optimal policy over time. The Bellman equation, which characterizes the value of an optimal plan, is a functional fixed-point equation where the solution is an entire function, not just a single vector. This exercise guides you through implementing value function iteration, a powerful algorithm that finds this fixed point through successive approximations and serves as the computational workhorse for a vast range of problems in macroeconomics and finance [@problem_id:2393445].", "problem": "Consider a discrete-time dynamic programming problem on a finite grid for the state variable $k \\in \\mathcal{K} \\subset \\mathbb{R}_{+}$. The decision variable is the next-period state $k' \\in \\mathcal{K}$. The resource constraint is\n$$\nc + k' = A k^{\\alpha} + (1-\\delta) k + \\bar{y},\n$$\nwith $A  0$, $\\alpha \\in (0,1)$, $\\delta \\in (0,1)$, and an exogenous endowment $\\bar{y} \\ge 0$. Instantaneous utility is constant relative risk aversion (CRRA),\n$$\nu(c) = \\begin{cases}\n\\log(c)  \\text{if } \\sigma = 1,\\\\\n\\dfrac{c^{1-\\sigma}}{1-\\sigma}  \\text{if } \\sigma \\ne 1,\n\\end{cases}\n$$\nwith risk-aversion parameter $\\sigma  0$ and $c \\ge c_{\\min}  0$. The Bellman operator $\\mathcal{T}$ on the space of bounded functions $V:\\mathcal{K} \\to \\mathbb{R}$ is\n$$\n(\\mathcal{T}V)(k) = \\max_{k' \\in \\mathcal{K}} \\left\\{ u\\!\\left(A k^{\\alpha} + (1-\\delta) k + \\bar{y} - k' \\right) + \\beta V(k') \\right\\},\n$$\nwith discount factor $\\beta \\in (0,1)$. The value function $V$ is a fixed point of $\\mathcal{T}$, that is, it satisfies $V = \\mathcal{T}V$. On a finite grid $\\mathcal{K} = \\{k_{1},\\dots,k_{N}\\}$ with $N \\in \\mathbb{N}$, represent $V$ as a vector in $\\mathbb{R}^{N}$. Assume $c \\ge c_{\\min}$ is enforced by restricting feasible choices $k'$ for each $k$.\n\nFundamental base: you may use the following facts. First, the existence of a fixed point of a continuous self-map on a compact convex set is guaranteed by Brouwer’s fixed point theorem. Second, the contraction mapping theorem (Banach fixed point theorem) ensures uniqueness and convergence of successive approximations when $\\mathcal{T}$ is a contraction under the supremum norm. In this finite-grid setting with $\\beta \\in (0,1)$ and bounded returns, $\\mathcal{T}$ is a contraction with modulus $\\beta$ under the supremum norm.\n\nTask: Implement a fixed-point algorithm (value function iteration) to compute the fixed point of $\\mathcal{T}$ on a finite grid by successive approximations starting from an initial guess $V_{0}(k) = 0$ for all $k \\in \\mathcal{K}$. At each iteration $n$, compute $V_{n+1} = \\mathcal{T}V_{n}$ and the supremum norm difference $\\Delta_{n} = \\lVert V_{n+1} - V_{n} \\rVert_{\\infty}$. Stop when $\\Delta_{n} \\le \\text{tol}$ for a specified tolerance $\\text{tol}  0$ or when a specified maximum number of iterations is reached. Additionally, for a designated iteration index $m \\ge 1$, compute whether the contraction inequality $\\Delta_{m} \\le \\beta \\Delta_{m-1}$ holds up to numerical slack.\n\nUse a discrete action set equal to the state grid $\\mathcal{K}$, so that $k' \\in \\mathcal{K}$. Enforce feasibility by excluding any $k'$ that violates $c \\ge c_{\\min}$ for the current state $k$. For numerical stability, you may assign a very large negative utility to infeasible $(k,k')$ pairs. You must implement your program so that it works for the following test suite of parameter values.\n\nTest suite. For each case below, construct an evenly spaced grid $\\mathcal{K} = \\{k_{1},\\dots,k_{N}\\}$ with $k_{1} = k_{\\min}$ and $k_{N} = k_{\\max}$, and report the requested scalar quantity. All numbers are dimensionless and should be treated as pure numbers.\n\n- Case $1$ (baseline, happy path):\n  - $A = 1$, $\\alpha = 0.35$, $\\delta = 0.10$, $\\beta = 0.95$, $\\sigma = 1$, $\\bar{y} = 0$,\n  - $N = 200$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 5$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-6}$, $\\text{max\\_iter} = 10000$.\n  - Output: the integer number of iterations taken to satisfy $\\Delta_{n} \\le \\text{tol}$.\n\n- Case $2$ (high patience and curvature, coarser grid):\n  - $A = 1$, $\\alpha = 0.30$, $\\delta = 0.05$, $\\beta = 0.99$, $\\sigma = 2$, $\\bar{y} = 0.02$,\n  - $N = 150$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 2$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-6}$, $\\text{max\\_iter} = 10000$.\n  - Output: the floating-point value $V(k_{j})$ at index $j = \\left\\lfloor 0.6 \\cdot (N-1) \\right\\rfloor + 1$ (that is, the state whose index is $1$-based and equals the smallest integer greater than or equal to $0.6 (N-1) + 1$).\n\n- Case $3$ (contraction check):\n  - $A = 1$, $\\alpha = 0.40$, $\\delta = 0.08$, $\\beta = 0.90$, $\\sigma = 3$, $\\bar{y} = 0.10$,\n  - $N = 120$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 3$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-8}$, $\\text{max\\_iter} = 10000$.\n  - Let $m = 4$. Output: the boolean truth value of the statement $\\Delta_{m} \\le \\beta \\Delta_{m-1} + \\varepsilon$ with numerical slack $\\varepsilon = 10^{-12}$.\n\n- Case $4$ (residual at fixed point):\n  - $A = 0.80$, $\\alpha = 0.25$, $\\delta = 0.07$, $\\beta = 0.97$, $\\sigma = 1.5$, $\\bar{y} = 0.05$,\n  - $N = 100$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 4$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-6}$, $\\text{max\\_iter} = 10000$.\n  - Output: the floating-point Bellman residual at convergence, defined as $\\lVert V^{*} - \\mathcal{T}V^{*} \\rVert_{\\infty}$, where $V^{*}$ is the converged value function from your algorithm.\n\nFinal output format. Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, in the order of cases $1$ through $4$. For example, the printed line must look like $[r_{1},r_{2},r_{3},r_{4}]$ where $r_{1}$ is an integer, $r_{2}$ is a float, $r_{3}$ is a boolean, and $r_{4}$ is a float. No other text should be printed.", "solution": "The posed problem is to find a numerical solution to a standard discrete-time neoclassical growth model. The model is defined by a Bellman equation, which characterizes the value function $V$ as a fixed point of a Bellman operator $\\mathcal{T}$. The problem is scientifically valid, well-posed, and all necessary parameters for its computational solution are provided. The existence and uniqueness of the solution, as well as the convergence of the proposed algorithm, are guaranteed by the Contraction Mapping Theorem (also known as the Banach fixed-point theorem), as correctly noted in the problem statement. The task is to implement the value function iteration (VFI) algorithm, which is the direct computational counterpart to the successive approximations method used in the proof of the theorem.\n\nThe core of the problem lies in the Bellman operator $\\mathcal{T}$, which maps a function $V$ to a new function $\\mathcal{T}V$:\n$$\n(\\mathcal{T}V)(k) = \\max_{k' \\in \\mathcal{K}} \\left\\{ u\\left(A k^{\\alpha} + (1-\\delta) k + \\bar{y} - k' \\right) + \\beta V(k') \\right\\}\n$$\nA solution, or fixed point, is a function $V^*$ such that $V^* = \\mathcal{T}V^*$. The VFI algorithm constructs a sequence of functions $\\{V_n\\}_{n=0}^{\\infty}$ starting from an initial guess $V_0$ (here, $V_0(k)=0$ for all $k$) and iterating according to the rule $V_{n+1} = \\mathcal{T}V_n$. Because $\\mathcal{T}$ is a contraction mapping with modulus $\\beta \\in (0,1)$ under the supremum norm, this sequence is guaranteed to converge to the unique fixed point $V^*$.\n\nFor numerical implementation, the continuous state space for capital $k$ is discretized onto a finite, evenly spaced grid $\\mathcal{K} = \\{k_1, k_2, \\dots, k_N\\}$. Consequently, the value function $V:\\mathcal{K} \\to \\mathbb{R}$ is represented as a vector $\\mathbf{V} \\in \\mathbb{R}^N$, where the $i$-th component, $\\mathbf{V}_i$, corresponds to the value $V(k_i)$. The action space, which consists of choices for next-period capital $k'$, is also restricted to the same grid $\\mathcal{K}$.\n\nThe iterative update $V_{n+1} = \\mathcal{T}V_n$ is performed for each point $k_i \\in \\mathcal{K}$ on the grid. The $i$-th component of the new value function vector $\\mathbf{V}_{n+1}$ is computed as:\n$$\n(\\mathbf{V}_{n+1})_i = \\max_{j \\in \\{1, \\dots, N\\}} \\left\\{ u(c_{ij}) + \\beta (\\mathbf{V}_n)_j \\right\\}\n$$\nHere, $(\\mathbf{V}_n)_j$ is the value of the function from the previous iteration at state $k_j$, and $c_{ij}$ is the consumption resulting from choosing state $k_j$ when the current state is $k_i$. From the resource constraint:\n$$\nc_{ij} = A k_i^{\\alpha} + (1-\\delta) k_i + \\bar{y} - k_j\n$$\nA crucial step is to enforce the feasibility constraint $c_{ij} \\ge c_{\\min}$. Any choice of $k_j$ that violates this constraint is inadmissible. In the maximization procedure, this is handled by assigning an infinitely negative utility (computationally, a very large negative number) to such choices, ensuring they are never selected. The utility function $u(c)$ is defined as $\\log(c)$ for $\\sigma=1$ and $\\frac{c^{1-\\sigma}}{1-\\sigma}$ for $\\sigma \\ne 1$.\n\nThe algorithm proceeds as follows:\n1.  Initialize $\\mathbf{V}_0$ as a vector of zeros of size $N$.\n2.  For each iteration $n=0, 1, 2, \\dots$:\n    a. For each current state $k_i$, $i=1, \\dots, N$:\n        i.  For each possible next state $k_j$, $j=1, \\dots, N$:\n            -   Calculate consumption $c_{ij} = A k_i^{\\alpha} + (1 - \\delta)k_i + \\bar{y} - k_j$.\n            -   If $c_{ij}  c_{\\min}$, the value for this choice is $-\\infty$.\n            -   Otherwise, the value is $u(c_{ij}) + \\beta (\\mathbf{V}_n)_j$.\n        ii. Set $(\\mathbf{V}_{n+1})_i$ to the maximum value found over all choices of $j$.\n    b. Calculate the supremum norm of the difference: $\\Delta_n = \\lVert \\mathbf{V}_{n+1} - \\mathbf{V}_n \\rVert_{\\infty} = \\max_i |(\\mathbf{V}_{n+1})_i - (\\mathbf{V}_n)_i|$.\n    c. If $\\Delta_n \\le \\text{tol}$ or the maximum number of iterations is reached, terminate. Otherwise, set $\\mathbf{V}_n = \\mathbf{V}_{n+1}$ and continue to the next iteration.\n\nThis process is computationally implemented using vectorized operations for efficiency. A matrix of consumption values $C$ with entries $C_{ij} = c_{ij}$ is constructed. A corresponding utility matrix $U$ is then calculated, with entries $U_{ij} = u(C_{ij})$ for feasible consumption and $U_{ij} = -\\infty$ otherwise. The Bellman operator can then be applied in a single vectorized step:\n$$\n\\mathbf{V}_{n+1} = \\max_{\\text{axis}=1} \\left( U + \\beta \\mathbf{V}_n^T \\right)\n$$\nwhere $\\mathbf{V}_n^T$ is broadcast across the rows of the matrix $U$.\n\nThe specific outputs for each case are determined as follows:\n-   Case 1: The total number of iterations performed until convergence.\n-   Case 2: The value of the converged function $\\mathbf{V}^*$ at a specific index. The 1-based index $j$ is defined by the formula $j = \\lfloor 0.6 \\cdot (N-1) \\rfloor + 1$. For $N=150$, this yields $j = \\lfloor 0.6 \\cdot 149 \\rfloor + 1 = 89+1 = 90$. The required value is the $90$-th element of the value function vector (corresponding to index 89 in a 0-based array).\n-   Case 3: At iteration $m=4$, the inequality $\\Delta_4 \\le \\beta \\Delta_3 + \\varepsilon$ is checked. This verifies the contraction property of the operator.\n-   Case 4: The final Bellman residual $\\lVert V^* - \\mathcal{T}V^* \\rVert_{\\infty}$ is calculated after the algorithm has converged to $V^*$. This is found by applying the operator one final time to the converged solution $V^*$ and computing the supremum norm difference between the result $\\mathcal{T}V^*$ and $V^*$.\n\nThe implementation will systematically execute this procedure for the four provided test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the dynamic programming problem for four distinct test cases\n    using value function iteration and prints the results.\n    \"\"\"\n\n    def run_vfi(params):\n        \"\"\"\n        Performs value function iteration for a given set of parameters.\n        \"\"\"\n        A = params['A']\n        alpha = params['alpha']\n        delta = params['delta']\n        beta = params['beta']\n        sigma = params['sigma']\n        y_bar = params['y_bar']\n        N = params['N']\n        k_min = params['k_min']\n        k_max = params['k_max']\n        c_min = params['c_min']\n        tol = params['tol']\n        max_iter = params['max_iter']\n        case_id = params['case_id']\n\n        # 1. Grid setup\n        k_grid = np.linspace(k_min, k_max, N)\n        \n        # 2. VFI Initialization\n        V = np.zeros(N)\n        \n        # Iteration-specific storage for Case 3\n        delta_m_minus_1 = np.nan\n        delta_m = np.nan\n        \n        # 3. VFI Main Loop\n        for n in range(max_iter):\n            V_old = V.copy()\n            \n            # Vectorized Bellman operator application\n            k_current = k_grid.reshape((N, 1))\n            k_next = k_grid.reshape((1, N))\n            \n            resources = A * k_current**alpha + (1 - delta) * k_current + y_bar\n            consumption = resources - k_next\n            \n            # Utility calculation with feasibility check\n            utility = np.full((N, N), -np.inf)\n            feasible_mask = consumption = c_min\n            \n            c_feasible = consumption[feasible_mask]\n            \n            if sigma == 1.0:\n                utility[feasible_mask] = np.log(c_feasible)\n            else:\n                utility[feasible_mask] = (c_feasible**(1 - sigma)) / (1 - sigma)\n            \n            T_V = utility + beta * V_old\n            V = np.max(T_V, axis=1)\n            \n            # Convergence check\n            diff = np.max(np.abs(V - V_old))\n\n            if case_id == 3:\n                m = params['m']\n                if n == m - 2: # Iteration m-1 (0-indexed)\n                    delta_m_minus_1 = diff\n                if n == m - 1: # Iteration m (0-indexed)\n                    delta_m = diff\n\n            if diff  tol:\n                break\n        \n        num_iterations = n + 1\n\n        # 4. Return the requested result based on the case\n        if case_id == 1:\n            return num_iterations\n        elif case_id == 2:\n            # 1-based index j from formula, convert to 0-based for numpy\n            j_one_based = int(np.floor(0.6 * (N - 1))) + 1\n            j_zero_based = j_one_based - 1\n            return V[j_zero_based]\n        elif case_id == 3:\n            epsilon = params['epsilon']\n            return delta_m = beta * delta_m_minus_1 + epsilon\n        elif case_id == 4:\n            # Calculate the Bellman residual at the converged point V\n            k_current = k_grid.reshape((N, 1))\n            k_next = k_grid.reshape((1, N))\n            resources = A * k_current**alpha + (1 - delta) * k_current + y_bar\n            consumption = resources - k_next\n            utility = np.full((N, N), -np.inf)\n            feasible_mask = consumption = c_min\n            c_feasible = consumption[feasible_mask]\n            \n            if sigma == 1.0:\n                utility[feasible_mask] = np.log(c_feasible)\n            else:\n                utility[feasible_mask] = (c_feasible**(1 - sigma)) / (1 - sigma)\n                \n            TV_star = np.max(utility + beta * V, axis=1)\n            residual = np.max(np.abs(TV_star - V))\n            return residual\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'case_id': 1, 'A': 1, 'alpha': 0.35, 'delta': 0.10, 'beta': 0.95, 'sigma': 1, 'y_bar': 0,\n            'N': 200, 'k_min': 1e-4, 'k_max': 5, 'c_min': 1e-8,\n            'tol': 1e-6, 'max_iter': 10000\n        },\n        {\n            'case_id': 2, 'A': 1, 'alpha': 0.30, 'delta': 0.05, 'beta': 0.99, 'sigma': 2, 'y_bar': 0.02,\n            'N': 150, 'k_min': 1e-4, 'k_max': 2, 'c_min': 1e-8,\n            'tol': 1e-6, 'max_iter': 10000\n        },\n        {\n            'case_id': 3, 'A': 1, 'alpha': 0.40, 'delta': 0.08, 'beta': 0.90, 'sigma': 3, 'y_bar': 0.10,\n            'N': 120, 'k_min': 1e-4, 'k_max': 3, 'c_min': 1e-8,\n            'tol': 1e-8, 'max_iter': 10000, 'm': 4, 'epsilon': 1e-12\n        },\n        {\n            'case_id': 4, 'A': 0.80, 'alpha': 0.25, 'delta': 0.07, 'beta': 0.97, 'sigma': 1.5, 'y_bar': 0.05,\n            'N': 100, 'k_min': 1e-4, 'k_max': 4, 'c_min': 1e-8,\n            'tol': 1e-6, 'max_iter': 10000\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_vfi(case_params)\n        results.append(result)\n\n    # Format the results into the required string format.\n    # Booleans need to be lowercased as 'true'/'false'.\n    formatted_results = []\n    for r in results:\n        if isinstance(r, bool) or isinstance(r, np.bool_):\n            formatted_results.append(str(r).lower())\n        else:\n            formatted_results.append(str(r))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2393445"}, {"introduction": "Fixed-point concepts are not limited to single-agent optimization or simple stochastic systems; they are also central to understanding multi-agent market equilibrium. This practice explores an assignment market, where buyers and items must be matched efficiently. You will implement an iterative auction algorithm that adjusts prices in response to excess demand, effectively searching for a market-clearing price vector which is a fixed point of the market mechanism. This exercise illustrates how fixed-point principles guarantee the existence of stable outcomes, known as the 'core,' in complex strategic environments [@problem_id:2393499].", "problem": "Consider a transferable utility cooperative market with assignment structure, consisting of a finite set of buyers and a finite set of indivisible items. Let there be $n$ buyers indexed by $i \\in \\{1,\\dots,n\\}$ and $m$ items indexed by $j \\in \\{1,\\dots,m\\}$ with $n \\le m$. Each buyer $i$ has a valuation $v_{ij} \\in \\mathbb{R}_{\\ge 0}$ for obtaining item $j$. A feasible allocation is a matching that assigns each buyer to at most one item and each item to at most one buyer, with exactly $n$ buyers matched if possible. In the transferable utility (TU) assignment game, an outcome is specified by a matching together with a transfer (price) vector and buyer utilities, allowing side payments so that buyer $i$ derives utility $u_i$ and seller $j$ (the owner of item $j$) receives a payment $p_j$.\n\nFundamental definitions:\n- The core of the TU assignment game is the set of outcomes $\\{(u,p,\\mu)\\}$, where $\\mu$ is a matching, $u = (u_1,\\dots,u_n)$ are buyer utilities, and $p = (p_1,\\dots,p_m)$ are item prices, such that coalition rationality holds: for every buyer-item pair $(i,j)$, $u_i + p_j \\ge v_{ij}$, and for every matched pair $(i,\\mu(i))$, $u_i + p_{\\mu(i)} = v_{i,\\mu(i)}$. Feasibility requires that exactly $n$ buyers are matched in $\\mu$.\n- A competitive equilibrium (also called Walrasian equilibrium in this quasilinear context) is a price vector $p$ and a matching $\\mu$ such that each matched buyer $i$ chooses $\\mu(i)$ from her demand set $\\arg\\max_{j} \\{v_{ij} - p_j\\}$ given prices $p$, and all buyers are matched. The equivalence between competitive equilibria and core outcomes is well known for assignment markets with transferable utility.\n\nExistence of such equilibria (and hence non-emptiness of the core) can be established by fixed-point theory such as the Kakutani Fixed-Point Theorem, which guarantees the existence of a price vector $p$ that clears the market when buyers choose from their demand correspondences. In particular, the demand correspondence is non-empty, convex-valued, and upper hemicontinuous under standard assumptions, and aggregate excess demand has a fixed point ensuring a competitive equilibrium; in an assignment market, such an equilibrium outcome lies in the core.\n\nYour task is to implement an algorithm that, given a valuation matrix $V = (v_{ij}) \\in \\mathbb{R}_{\\ge 0}^{n \\times m}$ with $n \\le m$, computes a point in the core by constructing a competitive equilibrium via iterative price adjustment:\n- Start from $p_j = 0$ for all $j$, and iteratively adjust prices on over-demanded items until there exists a matching $\\mu$ that matches all buyers to items they demand at $p$.\n- At any price vector $p$, define buyer $i$’s demand set as $D_i(p) = \\arg\\max_{j \\in \\{1,\\dots,m\\}} \\{v_{ij} - p_j\\}$. Construct the bipartite demand graph with edges $(i,j)$ whenever $j \\in D_i(p)$.\n- Compute a maximum matching on the current demand graph. If its size is $n$, stop and output the associated utilities $u_i = v_{i,\\mu(i)} - p_{\\mu(i)}$ along with prices $p$; this is a competitive equilibrium and a core point.\n- If not all buyers can be matched, identify the set $B$ of buyers and the set $S$ of items that are reachable from unmatched buyers by alternating paths in the demand graph (alternating between demand edges and matched edges). Increase the prices $p_j$ for all $j \\in S$ by the minimal increment that causes at least one buyer in $B$ to become indifferent between some item in $S$ and some item not in $S$. Then recompute demands and repeat.\n\nYou must also implement a verification routine that checks whether the resulting $(u,p,\\mu)$ lies in the core by verifying:\n- For all $i \\in \\{1,\\dots,n\\}$ and all $j \\in \\{1,\\dots,m\\}$, $u_i + p_j \\ge v_{ij}$ (within a numerical tolerance).\n- For all $i \\in \\{1,\\dots,n\\}$, if $\\mu(i) = j$, then $u_i + p_j = v_{ij}$ (within a numerical tolerance).\n- Exactly $n$ buyers are matched.\n\nNumerical assumptions: Treat all valuations as real numbers with no physical units. Do not print percentages; any fractional quantities should be represented as decimals.\n\nTest suite:\nImplement your program to run on the following three test cases. Each test case is defined by a valuation matrix $V$.\n- Case $1$: $n = 2$, $m = 3$, with\n$$\nV^{(1)} = \\begin{pmatrix}\n10  8  7 \\\\\n7  9  9\n\\end{pmatrix}.\n$$\n- Case $2$: $n = 3$, $m = 3$, with\n$$\nV^{(2)} = \\begin{pmatrix}\n5  5  1 \\\\\n5  4  4 \\\\\n4  5  4\n\\end{pmatrix}.\n$$\n- Case $3$: $n = 3$, $m = 4$, with\n$$\nV^{(3)} = \\begin{pmatrix}\n1  2  0  2 \\\\\n2  0  2  1 \\\\\n0  2  1  2\n\\end{pmatrix}.\n$$\n\nFor each case, your program must:\n- Compute $(u,p,\\mu)$ via the above iterative price adjustment approach.\n- Verify whether the computed outcome is in the core, returning the boolean truth value.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each result is a boolean indicating whether the computed outcome for the corresponding test case is in the core. For the above three cases, your program must print a single line of the form \"[b1,b2,b3]\" where each $b_k$ is either True or False, with no additional text or lines.", "solution": "The problem requires the implementation of an iterative auction algorithm to find a competitive equilibrium in an assignment market. Such an equilibrium is known to be an allocation in the core of the game. The algorithm, a variant of primal-dual methods for the assignment problem, works by adjusting item prices in response to excess demand.\n\nThe algorithm proceeds as follows:\n1.  **Initialization**: Start with all item prices $p_j$ set to zero.\n\n2.  **Iteration Loop**: Repeat until a market-clearing allocation is found:\n    a. **Demand Calculation**: For the current price vector $p$, determine each buyer's demand set, $D_i(p)$, which consists of all items that maximize their surplus $v_{ij} - p_j$.\n    b. **Matching**: Construct a bipartite \"demand graph\" connecting buyers to the items in their demand sets. Find a maximum matching in this graph.\n    c. **Termination Check**: If the maximum matching has size $n$ (the number of buyers), then all buyers can be assigned an item they demand. The market is cleared. The algorithm terminates, and this price vector and matching form a competitive equilibrium. The buyer utilities are calculated as $u_i = v_{i,\\mu(i)} - p_{\\mu(i)}$.\n    d. **Price Update**: If the matching is not complete (size  $n$), prices must be adjusted.\n        i.  Identify the set of buyers $B$ and items $S$ that are reachable from any unmatched buyer via alternating paths in the demand graph. This set represents the \"over-demanded\" part of the market.\n        ii.  Calculate the minimum price increment $\\delta$ that would make at least one buyer in $B$ indifferent between an item in $S$ and an item outside of $S$.\n        iii.  Increase the price of all items $j \\in S$ by this increment $\\delta$.\n\n3.  **Core Verification**: After termination, the resulting outcome $(u, p, \\mu)$ is checked against the formal definition of the core:\n    - Coalition rationality: $u_i + p_j \\ge v_{ij}$ for all buyer-item pairs.\n    - Individual rationality: $u_i + p_{\\mu(i)} = v_{i,\\mu(i)}$ for all matched pairs.\n    - Feasibility: Exactly $n$ buyers are matched.\n\nThe implementation involves graph algorithms for matching (e.g., using augmenting paths) and traversal (e.g., BFS) to identify the sets for the price update. For the given test cases, this algorithm is executed, and the final outcome is verified against the core conditions.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the assignment market problem for the given test cases.\n    \"\"\"\n    \n    TOL = 1e-9  # Numerical tolerance for float comparisons\n\n    def find_max_matching(demand_graph, n, m):\n        \"\"\"\n        Finds a maximum matching in a bipartite graph using augmenting paths with DFS.\n        The graph is represented by an adjacency list (dict).\n        \"\"\"\n        # item_match[j] = i means item j is matched to buyer i\n        item_match = {}\n        \n        def dfs(buyer, visited_items):\n            \"\"\"DFS to find an augmenting path.\"\"\"\n            for item in demand_graph.get(buyer, []):\n                if item not in visited_items:\n                    visited_items.add(item)\n                    # If item is not matched or its matched buyer can find another match\n                    if item not in item_match or dfs(item_match[item], visited_items):\n                        item_match[item] = buyer\n                        return True\n            return False\n\n        match_size = 0\n        for i in range(n):\n            visited_items = set()\n            if dfs(i, visited_items):\n                match_size += 1\n        \n        # buyer_match[i] = j means buyer i is matched to item j\n        buyer_match = {v: k for k, v in item_match.items()}\n        return buyer_match, item_match, match_size\n\n    def find_alternating_path_sets(unmatched_buyers, demand_graph, item_match, n, m):\n        \"\"\"\n        Finds sets B (buyers) and S (items) reachable from unmatched buyers via alternating paths.\n        Uses BFS for the traversal.\n        \"\"\"\n        B = set(unmatched_buyers)\n        S = set()\n        \n        queue = list(unmatched_buyers)\n        visited_buyers = set(unmatched_buyers)\n        visited_items = set()\n\n        head = 0\n        while head  len(queue):\n            buyer = queue[head]\n            head += 1\n\n            for item in demand_graph.get(buyer, []):\n                if item not in visited_items:\n                    visited_items.add(item)\n                    S.add(item)\n                    if item in item_match:\n                        next_buyer = item_match[item]\n                        if next_buyer not in visited_buyers:\n                            visited_buyers.add(next_buyer)\n                            B.add(next_buyer)\n                            queue.append(next_buyer)\n        return B, S\n\n    def solve_one_case(V):\n        \"\"\"\n        Implements the iterative price adjustment algorithm for one valuation matrix V.\n        \"\"\"\n        n, m = V.shape\n        p = np.zeros(m, dtype=float)\n\n        while True:\n            # 1. Construct demand graph\n            surplus = V - p\n            max_surpluses = np.max(surplus, axis=1)\n            \n            demand_graph = {}\n            for i in range(n):\n                demand_graph[i] = []\n                for j in range(m):\n                    if surplus[i, j] = max_surpluses[i] - TOL:\n                        demand_graph[i].append(j)\n            \n            # 2. Find maximum matching\n            buyer_match, item_match, match_size = find_max_matching(demand_graph, n, m)\n\n            # 3. Check for termination\n            if match_size == n:\n                break\n            \n            # 4. Price update\n            unmatched_buyers = {i for i in range(n) if i not in buyer_match}\n            \n            B, S = find_alternating_path_sets(unmatched_buyers, demand_graph, item_match, n, m)\n            \n            if not S:\n                # This should not happen in a well-defined problem\n                raise RuntimeError(\"Stalled: No items reachable from unmatched buyers.\")\n\n            all_items = set(range(m))\n            items_not_in_S = all_items - S\n            \n            min_delta = float('inf')\n            for i in B:\n                # Surplus from items in S\n                max_surplus_in_S = -float('inf')\n                if S:\n                    max_surplus_in_S = np.max(V[i, list(S)] - p[list(S)])\n                \n                # Surplus from items not in S\n                max_surplus_not_in_S = -float('inf')\n                if items_not_in_S:\n                    max_surplus_not_in_S = np.max(V[i, list(items_not_in_S)] - p[list(items_not_in_S)])\n                \n                delta_i = max_surplus_in_S - max_surplus_not_in_S\n                if delta_i  TOL:\n                    min_delta = min(min_delta, delta_i)\n\n            if min_delta == float('inf'):\n                # This may happen if S contains all items.\n                # A uniform price increase on all goods doesn't change relative preference,\n                # but might be required if valuations are low.\n                # In this specific problem structure, it signals an issue or requires a different rule.\n                # However, for the given test cases, this is not expected.\n                raise RuntimeError(\"Cannot find a positive price increment.\")\n\n            p[list(S)] += min_delta\n\n        # Algorithm terminated, calculate utilities\n        u = np.zeros(n, dtype=float)\n        for i in range(n):\n            j = buyer_match[i]\n            u[i] = V[i, j] - p[j]\n        \n        return u, p, buyer_match\n        \n    def verify_core(V, u, p, mu, n, m):\n        \"\"\"\n        Verifies if the computed outcome (u, p, mu) is in the core.\n        - mu is buyer_match dictionary.\n        \"\"\"\n        # Condition 1: u_i + p_j = v_ij for all i,j\n        for i in range(n):\n            for j in range(m):\n                if u[i] + p[j]  V[i, j] - TOL:\n                    return False\n        \n        # Condition 2: u_i + p_mu(i) = v_i,mu(i) for matched pairs\n        for i in range(n):\n            j = mu[i]\n            if abs((u[i] + p[j]) - V[i, j])  TOL:\n                return False\n\n        # Condition 3: Full matching\n        if len(mu) != n:\n            return False\n            \n        return True\n\n    # Test suite\n    test_cases = [\n        np.array([[10, 8, 7], [7, 9, 9]]),\n        np.array([[5, 5, 1], [5, 4, 4], [4, 5, 4]]),\n        np.array([[1, 2, 0, 2], [2, 0, 2, 1], [0, 2, 1, 2]])\n    ]\n    \n    results = []\n    for V_case in test_cases:\n        n, m = V_case.shape\n        u, p, mu = solve_one_case(V_case)\n        is_in_core = verify_core(V_case, u, p, mu, n, m)\n        results.append(is_in_core)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2393499"}]}