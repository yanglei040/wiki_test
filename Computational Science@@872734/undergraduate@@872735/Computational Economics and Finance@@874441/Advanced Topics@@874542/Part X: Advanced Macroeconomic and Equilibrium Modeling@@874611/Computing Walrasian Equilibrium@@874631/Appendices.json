{"hands_on_practices": [{"introduction": "We begin our hands-on exploration with the foundational case of a single competitive market. This exercise [@problem_id:2382188] bridges the gap between graphical supply-and-demand analysis and its quantitative implementation, challenging you to compute the efficient Walrasian equilibrium. By introducing a price floor, you will then directly calculate the resulting market distortions, including the traded quantity and the deadweight loss, providing a concrete measure of the welfare implications of market interventions.", "problem": "Consider a single-good competitive market embedded in a two-good economy with a numeraire good whose price is normalized to $1$. The market good has an inverse demand function $P_{d}(Q) = a - b\\,Q$ with $a > 0$ and $b > 0$, and an inverse supply function $P_{s}(Q) = c + d\\,Q$ with $c \\ge 0$ and $d > 0$. Quantities must be nonnegative, i.e., $Q \\ge 0$. A Walrasian equilibrium (WE) in this market is a price $p^{\\ast}$ and a quantity $Q^{\\ast} \\ge 0$ such that the market clears: $P_{d}(Q^{\\ast}) = P_{s}(Q^{\\ast}) = p^{\\ast}$. If the unique intersection of demand and supply occurs at a negative quantity, the efficient WE is the no-trade allocation $Q^{\\ast} = 0$.\n\nNow introduce a price floor $\\bar{p} \\ge 0$ for the market good, expressed in units of the numeraire good. The actual traded quantity under the price floor is determined by the following rule: if the floor is not binding relative to the efficient WE price, then the market trades at the efficient WE $(p^{\\ast},Q^{\\ast})$; if the floor is binding, the traded quantity equals the short side of the market at price $\\bar{p}$, that is $Q^{\\text{tr}} = \\min\\{Q_{d}(\\bar{p}), Q_{s}(\\bar{p})\\}$, where $Q_{d}(p) = \\max\\{0, (a - p)/b\\}$ and $Q_{s}(p) = \\max\\{0, (p - c)/d\\}$ are the nonnegative demand and supply quantities induced by price $p$. Define the deadweight loss (DWL) caused by the price floor as the loss in total surplus relative to the efficient WE, i.e., the integral of the net marginal benefit $P_{d}(Q) - P_{s}(Q)$ over the interval from the traded quantity under the floor to the efficient WE quantity:\n$$\n\\text{DWL} = \\int_{Q^{\\text{tr}}}^{Q^{\\ast}} \\big(P_{d}(Q) - P_{s}(Q)\\big)\\,dQ,\n$$\nwith the convention that if $Q^{\\text{tr}} \\ge Q^{\\ast}$ the deadweight loss is $0$.\n\nYour task is to write a program that, for each test case listed below, computes the efficient Walrasian equilibrium quantity $Q^{\\ast}$, the traded quantity under the price floor $Q^{\\text{tr}}$, and the deadweight loss $\\text{DWL}$ as defined above. All computations must assume nonnegative quantities as specified. There are no physical units to report.\n\nTest suite:\n- Test case $1$: $(a,b,c,d,\\bar{p}) = (10,1,2,1,7)$.\n- Test case $2$: $(a,b,c,d,\\bar{p}) = (10,1,2,1,5)$.\n- Test case $3$: $(a,b,c,d,\\bar{p}) = (10,1,2,1,6)$.\n- Test case $4$: $(a,b,c,d,\\bar{p}) = (12,1,0,1,15)$.\n- Test case $5$: $(a,b,c,d,\\bar{p}) = (3,1,5,1,4)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case in the order given above, output the triple $(Q^{\\ast},Q^{\\text{tr}},\\text{DWL})$ in that order. Concatenate these triples for all test cases into one flat list. For example, the output should have the form\n$[Q^{\\ast}_{1},Q^{\\text{tr}}_{1},\\text{DWL}_{1},Q^{\\ast}_{2},Q^{\\text{tr}}_{2},\\text{DWL}_{2},\\dots]$.", "solution": "The problem as stated is valid. It is a well-posed, scientifically grounded exercise in microeconomic theory, specifically the analysis of market equilibrium and welfare effects of a price control. The definitions, parameters, and objective are stated with sufficient mathematical precision, and the problem is free of contradictions or logical flaws. We may proceed with a formal solution.\n\nThe task is to compute the efficient Walrasian equilibrium quantity ($Q^{\\ast}$), the quantity traded under a price floor ($Q^{\\text{tr}}$), and the resulting deadweight loss (DWL) for several parameter sets. The derivation is organized into three stages.\n\n**Stage 1: Determination of the Efficient Walrasian Equilibrium Quantity ($Q^{\\ast}$)**\n\nThe Walrasian equilibrium quantity is found at the point where the market clears, i.e., where quantity demanded equals quantity supplied. This corresponds to the intersection of the inverse demand and supply curves, provided the quantity is non-negative.\nThe inverse demand is given by $P_{d}(Q) = a - b\\,Q$ and the inverse supply by $P_{s}(Q) = c + d\\,Q$. We set $P_{d}(Q) = P_{s}(Q)$:\n$$ a - b\\,Q = c + d\\,Q $$\nSolving for $Q$ yields the intersection quantity, which we shall denote $Q_{\\text{int}}$:\n$$ a - c = (b + d)Q $$\n$$ Q_{\\text{int}} = \\frac{a - c}{b + d} $$\nThe problem specifies that quantity must be non-negative ($Q \\ge 0$). If $a \\le c$, the demand curve lies entirely below the supply curve for $Q > 0$ (or starts at a lower price intercept if $c>a$, or at the same intercept if $c=a$). In this scenario, $Q_{\\text{int}} \\le 0$, and no trade will occur in an efficient market. The problem statement correctly identifies this \"no-trade allocation\" as the efficient outcome. Therefore, the efficient equilibrium quantity $Q^{\\ast}$ is the non-negative part of the intersection quantity:\n$$ Q^{\\ast} = \\max\\left\\{0, \\frac{a - c}{b + d}\\right\\} $$\nIf $Q^{\\ast} > 0$, the corresponding equilibrium price $p^{\\ast}$ is found by substituting $Q^{\\ast}$ into either the inverse demand or supply function:\n$$ p^{\\ast} = P_{d}(Q^{\\ast}) = a - b\\left(\\frac{a - c}{b + d}\\right) = \\frac{a(b+d) - b(a-c)}{b+d} = \\frac{ad + bc}{b + d} $$\n\n**Stage 2: Determination of the Traded Quantity Under the Price Floor ($Q^{\\text{tr}}$)**\n\nA price floor $\\bar{p}$ is a minimum price set by a regulator. Its effect depends on whether it is \"binding\".\n\nCase 1: No trade in the efficient equilibrium ($Q^{\\ast} = 0$).\nThis occurs when $a \\le c$. No voluntary trade can take place because the highest price any consumer is willing to pay ($a$) is less than or equal to the lowest price any supplier is willing to accept ($c$). A price floor $\\bar{p}$ cannot induce a trade that is not mutually beneficial. At any price $\\bar{p}$, either the quantity demanded or the quantity supplied (or both) will be zero. Thus, if $Q^{\\ast} = 0$, the traded quantity $Q^{\\text{tr}}$ must also be zero.\n\nCase 2: Positive trade in the efficient equilibrium ($Q^{\\ast} > 0$).\nIn this case, an equilibrium price $p^{\\ast} = (ad+bc)/(b+d)$ exists.\n- If $\\bar{p} \\le p^{\\ast}$, the price floor is not binding. It is set at or below the price the market would naturally reach. The market trades at the efficient equilibrium, so $Q^{\\text{tr}} = Q^{\\ast}$.\n- If $\\bar{p} > p^{\\ast}$, the price floor is binding. The market price is forced up to $\\bar{p}$. At this higher price, there is a surplus: the quantity suppliers wish to sell, $Q_{s}(\\bar{p})$, exceeds the quantity consumers wish to buy, $Q_{d}(\\bar{p})$. Trade is determined by the \"short side\" of the market, which is demand. The quantity traded is:\n$$ Q^{\\text{tr}} = Q_{d}(\\bar{p}) = \\max\\left\\{0, \\frac{a - \\bar{p}}{b}\\right\\} $$\nSince $\\bar{p} > p^{\\ast}$ and $p^{\\ast} = a - bQ^{\\ast}$, it follows that $\\bar{p} > a - bQ^{\\ast}$, which implies $bQ^{\\ast} > a - \\bar{p}$, and thus $Q^{\\ast} > (a-\\bar{p})/b$. Therefore, a binding price floor always results in a traded quantity $Q^{\\text{tr}}$ that is strictly less than the efficient quantity $Q^{\\ast}$.\n\n**Stage 3: Calculation of Deadweight Loss (DWL)**\n\nDeadweight loss is the loss of total surplus due to the market operating at a quantity different from the efficient level. It is defined by the integral:\n$$ \\text{DWL} = \\int_{Q^{\\text{tr}}}^{Q^{\\ast}} \\big(P_{d}(Q) - P_{s}(Q)\\big)\\,dQ $$\nThe integrand is the difference between the marginal benefit to consumers and the marginal cost to producers:\n$$ P_{d}(Q) - P_{s}(Q) = (a - bQ) - (c + dQ) = (a - c) - (b + d)Q $$\nWhen $Q^{\\ast} > 0$, we have $a - c = (b+d)Q^{\\ast}$. Substituting this into the integrand gives:\n$$ P_{d}(Q) - P_{s}(Q) = (b+d)Q^{\\ast} - (b+d)Q = (b+d)(Q^{\\ast} - Q) $$\nNow we can evaluate the integral:\n$$ \\text{DWL} = \\int_{Q^{\\text{tr}}}^{Q^{\\ast}} (b+d)(Q^{\\ast} - Q)\\,dQ = (b+d)\\left[ Q^{\\ast}Q - \\frac{1}{2}Q^2 \\right]_{Q^{\\text{tr}}}^{Q^{\\ast}} $$\n$$ \\text{DWL} = (b+d)\\left( \\left( (Q^{\\ast})^2 - \\frac{1}{2}(Q^{\\ast})^2 \\right) - \\left( Q^{\\ast}Q^{\\text{tr}} - \\frac{1}{2}(Q^{\\text{tr}})^2 \\right) \\right) $$\n$$ \\text{DWL} = (b+d)\\left( \\frac{1}{2}(Q^{\\ast})^2 - Q^{\\ast}Q^{\\text{tr}} + \\frac{1}{2}(Q^{\\text{tr}})^2 \\right) = \\frac{1}{2}(b+d)(Q^{\\ast} - Q^{\\text{tr}})^2 $$\nThis formula represents the area of a triangle. The height of the triangle is the reduction in quantity, $Q^{\\ast} - Q^{\\text{tr}}$, and the base is the price gap at the restricted quantity, $P_{d}(Q^{\\text{tr}}) - P_{s}(Q^{\\text{tr}})$. The formula holds if $Q^{\\ast} > 0$. If $Q^{\\ast}=0$, then $Q^{\\text{tr}}=0$, and the DWL is correctly calculated as $0$. If the price floor is not binding, $Q^{\\text{tr}}=Q^{\\ast}$, and the DWL is also correctly calculated as $0$. The problem's convention that DWL is $0$ if $Q^{\\text{tr}} \\ge Q^{\\ast}$ is naturally satisfied by this formula, as our logic ensures $Q^{\\text{tr}} \\le Q^{\\ast}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the efficient Walrasian equilibrium quantity (Q*),\n    the traded quantity under a price floor (Q_tr), and the\n    deadweight loss (DWL) for a series of market parameter sets.\n    \"\"\"\n    # Test cases are provided as tuples of (a, b, c, d, p_bar)\n    # P_d(Q) = a - b*Q\n    # P_s(Q) = c + d*Q\n    # p_bar is the price floor\n    test_cases = [\n        (10, 1, 2, 1, 7),\n        (10, 1, 2, 1, 5),\n        (10, 1, 2, 1, 6),\n        (12, 1, 0, 1, 15),\n        (3, 1, 5, 1, 4),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a, b, c, d, p_bar = case\n\n        # Stage 1: Determination of the Efficient Walrasian Equilibrium Quantity (Q*)\n        # The efficient quantity Q* is the non-negative part of the intersection\n        # of the supply and demand curves.\n        q_star = np.maximum(0.0, (a - c) / (b + d))\n\n        # Stage 2: Determination of the Traded Quantity Under the Price Floor (Q_tr)\n        if q_star > 0:\n            # An efficient equilibrium with positive trade exists.\n            # Calculate the equilibrium price p* to check if the floor is binding.\n            p_star = (a * d + b * c) / (b + d)\n            \n            if p_bar <= p_star:\n                # The price floor is not binding. The market trades at the efficient equilibrium.\n                q_tr = q_star\n            else:\n                # The price floor is binding. Trade is determined by the short side of\n                # the market, which is demand at price p_bar.\n                q_tr = np.maximum(0.0, (a - p_bar) / b)\n        else:\n            # The efficient equilibrium is no-trade (Q* = 0). A price floor\n            # cannot induce trade, so the traded quantity remains zero.\n            q_tr = 0.0\n\n        # Stage 3: Calculation of Deadweight Loss (DWL)\n        # DWL arises from the reduction in quantity traded below the efficient level.\n        # The formula is 0.5 * (b+d) * (Q* - Q_tr)^2.\n        # It is non-zero only if q_tr < q_star.\n        if q_tr < q_star:\n            dwl = 0.5 * (b + d) * (q_star - q_tr)**2\n        else:\n            dwl = 0.0\n\n        # Append the calculated triplet to the master list of results.\n        results.extend([q_star, q_tr, dwl])\n\n    # Final print statement in the exact required format.\n    # The list is flattened, and elements are converted to strings.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2382188"}, {"introduction": "Moving beyond a single market, our next practice [@problem_id:2382212] immerses you in a complete general equilibrium model with production. Here, you will construct an economy from first principles, featuring a profit-maximizing firm with access to a finite set of linear technologies and a utility-maximizing consumer. This exercise requires you to develop an algorithm that finds the equilibrium price ratio where the firm's optimal production plan perfectly matches the consumer's optimal consumption bundle, illustrating how prices coordinate complex economic activity.", "problem": "Consider an Arrow–Debreu competitive economy with one consumer who owns one firm that can produce two consumption goods using a finite set of linear technologies and a single capacity constraint, leading to a piecewise linear Production Possibility Frontier (PPF). All markets are for the two consumption goods only; there is no factor market. The consumer has strictly positive Cobb–Douglas preferences. You will compute a Walrasian equilibrium (WE), defined as a price vector and an allocation such that the firm maximizes profit given prices within the feasible production set, the consumer maximizes utility subject to the budget set with income equal to firm profit (distributed entirely to the consumer), and markets for both goods clear.\n\nFundamental base:\n- The consumer’s demand is obtained by maximizing Cobb–Douglas utility subject to the budget constraint.\n- The firm’s supply is obtained by maximizing profit over a convex feasible production set generated by mixing available linear technologies subject to a single resource capacity.\n- A Walrasian equilibrium (WE) is a set of prices and allocations that simultaneously satisfy individual optimality and market clearing.\n\nEconomy specification:\n- There are two goods. The firm has a finite set of available technologies indexed by $k \\in \\{1,\\dots,K\\}$. Each technology $k$ converts one unit of a generic, fixed, non-traded capacity into a net output vector $a_k = (a_{k1}, a_{k2}) \\in \\mathbb{R}_{+}^2$. Let the total capacity be $\\bar{L} > 0$. The firm chooses nonnegative activity levels $x_k \\ge 0$ with $\\sum_{k=1}^K x_k \\le \\bar{L}$ to produce $y = \\sum_{k=1}^K x_k a_k$.\n- The single consumer has utility $u(c_1,c_2) = c_1^{\\alpha} c_2^{1-\\alpha}$ with $\\alpha \\in (0,1)$ over consumption vector $c = (c_1,c_2)$. The consumer owns $100\\%$ of the firm, has no other endowments, and thus has income equal to firm profit.\n\nPrices:\n- Let the price vector be $p = (p_1,p_2) \\in \\mathbb{R}_{++}^2$. Without loss of generality, normalize $p_1 = 1$ and write $p_2 = q$ with $q > 0$.\n\nProgramming challenge:\n- For each parameter set below, compute one Walrasian equilibrium. Your program must determine a price ratio $q$ and a production plan $y = (y_1,y_2)$ on the piecewise linear PPF that clear markets when the consumer optimizes given income equal to firm profit at those prices. You must base your computation on first principles stated above. The economy is single-consumer and single-firm; thus a WE exists for the test instances below, with prices normalized by $p_1 = 1$ and $p_2 = q$.\n\nTest suite (three independent cases):\n- Case A:\n  - Technologies: $a_1 = (2.0, 0.5)$, $a_2 = (1.0, 1.2)$, $a_3 = (0.3, 2.0)$.\n  - Capacity: $\\bar{L} = 10$.\n  - Preference weight: $\\alpha = 0.5$.\n- Case B:\n  - Technologies: $a_1 = (1.2, 0.3)$, $a_2 = (0.9, 0.9)$.\n  - Capacity: $\\bar{L} = 5$.\n  - Preference weight: $\\alpha = 0.9$.\n- Case C:\n  - Technologies: $a_1 = (1.0, 0.4)$, $a_2 = (0.2, 1.3)$.\n  - Capacity: $\\bar{L} = 12$.\n  - Preference weight: $\\alpha = 0.1$.\n\nComputational requirements and acceptance checks:\n- Use the firm’s profit maximization at given $q$ over the convex hull of available technologies with the capacity constraint to produce a profit-maximizing $y$ (allowing mixing of technologies).\n- Use the consumer’s Cobb–Douglas demand at prices $(1,q)$ with income equal to firm profit to obtain $c$.\n- Enforce market clearing by requiring $c = y$ in both coordinates; if the profit-maximizing set includes multiple optimal technologies at prices $(1,q)$, you must select a convex combination that clears markets if feasible.\n- Your algorithm must be general for any finite technology set with two goods satisfying the above structure.\n\nFinal outputs:\n- For each case, output the triple $[q,y_1,y_2]$ where $q$ is the equilibrium price ratio with $p_1 = 1$, and $(y_1,y_2)$ is the equilibrium production/consumption vector. All three numbers must be floating-point values rounded to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list of these triples enclosed in square brackets, in the order Case A, Case B, Case C. For example: $[[q_A,y_{A1},y_{A2}],[q_B,y_{B1},y_{B2}],[q_C,y_{C1},y_{C2}]]$.\n- There are no physical units involved.\n\nYour program must be self-contained and require no input. It must implement the above logic and produce the single specified output line for the given test suite. The answers for each case must be lists of three floats as defined above.", "solution": "The problem presented is a well-posed instance of computing a Walrasian Equilibrium in a single-consumer, single-firm Arrow-Debreu economy. It is scientifically grounded in established microeconomic theory and provides a complete, consistent set of parameters. Therefore, a rigorous solution can be derived from first principles.\n\nThe economy consists of two goods, indexed $1$ and $2$. Normalizing the price of good $1$ to $p_1 = 1$, the price vector is $p = (1, q)$, where $q = p_2 > 0$ is the relative price of good $2$.\n\nThe core of the analysis rests on three pillars: firm behavior, consumer behavior, and market clearing.\n\n**1. Firm's Profit Maximization**\n\nThe firm possesses a set of $K$ linear production technologies. Each technology $k$ is represented by a vector $a_k = (a_{k1}, a_{k2})$, which transforms one unit of a single, non-traded resource (capacity) into a bundle of goods. With a total capacity of $\\bar{L}$, the firm chooses activity levels $x_k \\ge 0$ for each technology, subject to the capacity constraint $\\sum_{k=1}^K x_k \\le \\bar{L}$. The resulting production vector is $y = (y_1, y_2) = \\sum_{k=1}^K x_k a_k$. The set of all feasible production vectors forms the Production Possibility Set (PPS), which is a convex polytope. Its upper-right boundary is the Production Possibility Frontier (PPF).\n\nThe firm's objective is to maximize profit, $\\pi = p \\cdot y = y_1 + q y_2$. Substituting the expression for $y$:\n$$\n\\pi(q) = \\max_{\\{x_k\\}} \\sum_{k=1}^K x_k (a_{k1} + q a_{k2}) \\quad \\text{subject to} \\quad \\sum_{k=1}^K x_k \\le \\bar{L}, \\quad x_k \\ge 0.\n$$\nTo maximize this linear objective, the firm will allocate its entire capacity $\\bar{L}$ to the technology $k^*$ that yields the highest revenue per unit of capacity, $r_k(q) = a_{k1} + q a_{k2}$.\n- If a unique technology $k^*$ maximizes $r_k(q)$, the firm specializes, producing at a vertex of the PPF: $y^S(q) = \\bar{L} a_{k^*}$.\n- If two technologies, say $k_i$ and $k_j$, yield the same maximal revenue, i.e., $a_{i1} + q a_{i2} = a_{j1} + q a_{j2}$, any convex combination of these technologies is optimal. This corresponds to producing on a facet (line segment) of the PPF connecting the points $\\bar{L} a_i$ and $\\bar{L} a_j$. The price ratio $q$ at which this occurs is determined by the technologies themselves:\n$$\nq = - \\frac{a_{j1} - a_{i1}}{a_{j2} - a_{i2}}\n$$\nThis value of $q$ is the negative reciprocal of the slope of the PPF segment connecting $\\bar{L} a_i$ and $\\bar{L} a_j$.\n\n**2. Consumer's Utility Maximization**\n\nThe single consumer has Cobb-Douglas preferences, described by the utility function $u(c_1, c_2) = c_1^{\\alpha} c_2^{1-\\alpha}$, where $\\alpha \\in (0,1)$. The consumer owns the firm and has no other source of income. Thus, the consumer's income $I$ is the firm's profit, $I = \\pi$. The budget constraint is $c_1 + q c_2 = \\pi$.\n\nMaximizing Cobb-Douglas utility subject to a budget constraint yields the well-known demand functions:\n$$\nc_1 = \\frac{\\alpha I}{p_1} = \\alpha \\pi\n$$\n$$\nc_2 = \\frac{(1-\\alpha) I}{p_2} = \\frac{(1-\\alpha) \\pi}{q}\n$$\nA key property of these demands is that the ratio of expenditures on the two goods is constant:\n$$\n\\frac{p_2 c_2}{p_1 c_1} = \\frac{q c_2}{c_1} = \\frac{1-\\alpha}{\\alpha}\n$$\nThis is equivalent to the marginal rate of substitution (MRS) equaling the price ratio: $\\text{MRS} = \\frac{\\partial u / \\partial c_1}{\\partial u / \\partial c_2} = \\frac{\\alpha}{1-\\alpha}\\frac{c_2}{c_1} = \\frac{p_1}{p_2} = \\frac{1}{q}$.\n\n**3. Market Clearing and Walrasian Equilibrium**\n\nIn equilibrium, markets must clear, which in this single-consumer economy means consumption equals production: $c = y$. Let the equilibrium allocation be $y^* = (y_1^*, y_2^*)$. This allocation must lie on the PPF and satisfy the consumer's optimality condition. Substituting $y^*$ into the consumer's optimality condition provides a direct link between the equilibrium allocation and the equilibrium price ratio $q^*$:\n$$\n\\frac{q^* y_2^*}{y_1^*} = \\frac{1-\\alpha}{\\alpha} \\quad \\implies \\quad q^* = \\frac{1-\\alpha}{\\alpha} \\frac{y_1^*}{y_2^*}\n$$\nThe equilibrium is a pair $(q^*, y^*)$ that simultaneously satisfies firm profit maximization and this market clearing condition. This implies that at the equilibrium allocation $y^*$, the slope of the consumer's indifference curve must equal the slope of the PPF, and both must equal the negative of the price ratio, $-1/q^*$.\n\n**Algorithmic Approach**\n\nThe algorithm determines the equilibrium by systematically checking the two possibilities for the location of the equilibrium allocation on the PPF: at a vertex or on a segment.\n\n**Case 1: Equilibrium at a PPF Vertex**\nAn equilibrium occurs at a vertex $y^* = \\bar{L} a_k$ if, at the price ratio $q^*$ implied by consumer optimality at this point, the firm finds it optimal to specialize in technology $k$.\n1.  For a given technology $k$, define the potential equilibrium point $y^* = \\bar{L} a_k$.\n2.  Calculate the price ratio that would make the consumer choose this point: $q^* = \\frac{1-\\alpha}{\\alpha} \\frac{y_1^*}{y_2^*}$.\n3.  Verify if, at this price $q^*$, technology $k$ is indeed the most profitable. This is true if $r_k(q^*) \\ge r_j(q^*)$ for all other technologies $j=1,\\ldots,K$. If this condition holds, an equilibrium is found.\n\n**Case 2: Equilibrium on a PPF Segment**\nAn equilibrium occurs on a segment connecting $\\bar{L} a_i$ and $\\bar{L} a_j$ if the firm is indifferent between these two technologies, and the resulting consumption point lies on this segment.\n1.  For a pair of technologies $(i, j)$, calculate the unique price ratio $q^*$ that makes the firm indifferent: $q^* = -(a_{j1}-a_{i1})/(a_{j2}-a_{i2})$. We only consider pairs where $q^* > 0$.\n2.  Verify that this pair actually forms an edge on the PPF by checking that no other technology $k$ is strictly more profitable at this price $q^*$.\n3.  If the pair forms an edge, determine the consumption point $(y_1^*, y_2^*)$ by finding the intersection of the consumer's demand ray, $y_2 = \\left(\\frac{1-\\alpha}{\\alpha}\\frac{1}{q^*}\\right) y_1$, and the line segment defined by $\\bar{L}a_i$ and $\\bar{L}a_j$.\n4.  If this intersection point falls within the bounds of the segment, an equilibrium is found.\n\nThis systematic search is guaranteed to find the unique equilibrium for the specified economic structure. The implementation will iterate through all technologies and pairs of technologies to identify which of these two cases holds for each test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_equilibrium(technologies: list[tuple[float, float]], L_bar: float, alpha: float) -> list[float]:\n    \"\"\"\n    Computes the Walrasian equilibrium for a single-consumer, single-firm economy.\n\n    Args:\n        technologies: A list of (good1, good2) output tuples per unit of capacity.\n        L_bar: Total capacity.\n        alpha: The consumer's preference parameter for good 1 in the Cobb-Douglas utility.\n\n    Returns:\n        A list containing the equilibrium price ratio [q] and allocation [y1, y2].\n    \"\"\"\n    techs = np.array(technologies, dtype=np.float64)\n    num_techs = len(techs)\n    \n    # Consumer's expenditure ratio from utility maximization\n    if alpha == 0 or alpha == 1:\n        raise ValueError(\"alpha must be in (0,1)\")\n    expenditure_ratio = (1 - alpha) / alpha\n    \n    # Epsilon for robust floating-point comparisons\n    epsilon = 1e-9\n\n    # Case 1: Check for equilibrium at a vertex (specialization in one technology)\n    for i in range(num_techs):\n        y = L_bar * techs[i]\n        y1, y2 = y[0], y[1]\n\n        # Cobb-Douglas implies interior solution, so y1 and y2 must be positive.\n        if y1 < epsilon or y2 < epsilon:\n            continue\n\n        # Price ratio q implied by consumer choosing point y\n        q_consumer = expenditure_ratio * (y1 / y2)\n\n        # Check if firm would choose technology i at this price q\n        revenue_i = techs[i, 0] + q_consumer * techs[i, 1]\n        is_optimal_for_firm = True\n        for j in range(num_techs):\n            if i == j:\n                continue\n            revenue_j = techs[j, 0] + q_consumer * techs[j, 1]\n            if revenue_j > revenue_i + epsilon:\n                is_optimal_for_firm = False\n                break\n        \n        if is_optimal_for_firm:\n            return [q_consumer, y1, y2]\n\n    # Case 2: Check for equilibrium on a segment (diversification between two technologies)\n    for i in range(num_techs):\n        for j in range(i + 1, num_techs):\n            tech_i = techs[i]\n            tech_j = techs[j]\n\n            # Price ratio q implied by firm's indifference between tech i and j\n            # a_i1 + q*a_i2 = a_j1 + q*a_j2  => q*(a_i2 - a_j2) = a_j1 - a_i1\n            delta_a2 = tech_i[1] - tech_j[1]\n            if abs(delta_a2) < epsilon:\n                continue  # Technologies have same good 2 output, can't solve for q this way\n\n            delta_a1 = tech_j[0] - tech_i[0]\n            q_firm = delta_a1 / delta_a2\n\n            if q_firm < epsilon:\n                continue  # Price must be positive\n\n            # Check if this pair (i,j) constitutes an edge of the PPF at this price\n            revenue_ij = tech_i[0] + q_firm * tech_i[1]\n            is_ppf_edge = True\n            for k in range(num_techs):\n                if k == i or k == j:\n                    continue\n                revenue_k = techs[k, 0] + q_firm * techs[k, 1]\n                if revenue_k > revenue_ij + epsilon:\n                    is_ppf_edge = False\n                    break\n            \n            if not is_ppf_edge:\n                continue\n\n            # If it is an edge, find the market-clearing allocation on this segment\n            y_i = L_bar * tech_i\n            y_j = L_bar * tech_j\n            \n            # Slope of the PPF segment\n            if abs(y_j[0] - y_i[0]) < epsilon:\n                continue # Vertical segment\n            m_seg = (y_j[1] - y_i[1]) / (y_j[0] - y_i[0])\n\n            # Slope of the consumer's demand ray\n            m_ray = expenditure_ratio / q_firm\n\n            if abs(m_ray - m_seg) < epsilon:\n                continue # Parallel lines, no unique intersection\n\n            # Find intersection of the two lines\n            # y = m_ray * x\n            # y - y_i[1] = m_seg * (x - y_i[0])\n            # m_ray*x - y_i[1] = m_seg*x - m_seg*y_i[0]\n            # (m_ray - m_seg)*x = y_i[1] - m_seg*y_i[0]\n            y1_eq = (y_i[1] - m_seg * y_i[0]) / (m_ray - m_seg)\n            y2_eq = m_ray * y1_eq\n\n            # Check if the intersection point lies on the segment\n            y1_min = min(y_i[0], y_j[0])\n            y1_max = max(y_i[0], y_j[0])\n            \n            if y1_min - epsilon <= y1_eq <= y1_max + epsilon:\n                return [q_firm, y1_eq, y2_eq]\n                \n    # This part should not be reached given the problem guarantees a solution exists.\n    return []\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'id': 'A', 'techs': [(2.0, 0.5), (1.0, 1.2), (0.3, 2.0)], 'L_bar': 10.0, 'alpha': 0.5},\n        # Case B\n        {'id': 'B', 'techs': [(1.2, 0.3), (0.9, 0.9)], 'L_bar': 5.0, 'alpha': 0.9},\n        # Case C\n        {'id': 'C', 'techs': [(1.0, 0.4), (0.2, 1.3)], 'L_bar': 12.0, 'alpha': 0.1},\n    ]\n\n    results = []\n    for case in test_cases:\n        eq = compute_equilibrium(case['techs'], case['L_bar'], case['alpha'])\n        if eq:\n            results.append(eq)\n\n    # Format the final output string as per requirements\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2382212"}, {"introduction": "Our final practice [@problem_id:2382171] introduces a layer of realism common in modern policy analysis: a non-linear tax system within a general equilibrium model of labor and consumption. The progressive income tax and lump-sum redistribution create a complex feedback loop where individual decisions and government policy are deeply intertwined. This challenge moves beyond analytical solutions, requiring you to implement a numerical fixed-point algorithm to compute the equilibrium, a powerful technique at the heart of applied computational economics.", "problem": "Consider an exchange-production economy with a single consumption good and a time endowment for each agent. There are $2$ agents indexed by $i \\in \\{1,2\\}$. Each agent $i$ chooses consumption $c_i \\ge 0$ and leisure $\\ell_i \\in [0,1]$. Labor supply is $h_i = 1 - \\ell_i \\in [0,1]$. The single consumption good is produced from aggregate labor with linear technology $y = h_1 + h_2$. The price of the consumption good is normalized to $1$ and the pre-tax wage is $w = 1$. The government imposes a progressive income tax on each agent’s labor income according to the function\n$$\nT(I) = \\theta I + \\kappa \\max\\{0, I - I_0\\}^2,\n$$\nwhere $\\theta \\in [0,1)$, $\\kappa \\ge 0$, and $I_0 \\ge 0$ are parameters, and $I$ denotes the agent’s labor income. Tax revenue is rebated as an equal lump-sum transfer to both agents so that the per-capita transfer is\n$$\n\\tau = \\frac{1}{2}\\left(T(w h_1) + T(w h_2)\\right).\n$$\nGiven a transfer $\\tau$, agent $i$ has the budget constraint\n$$\nc_i \\le w h_i - T(w h_i) + \\tau,\n$$\nand preferences represented by the utility function\n$$\nu_i(c_i,\\ell_i) = \\alpha_i \\ln c_i + (1 - \\alpha_i) \\ln \\ell_i,\n$$\nwith $\\alpha_i \\in (0,1)$.\n\nA competitive equilibrium with taxes is a triple $(h_1^\\ast,h_2^\\ast,\\tau^\\ast)$ such that for each $i \\in \\{1,2\\}$, given $\\tau^\\ast$, the choice $h_i^\\ast \\in [0,1]$ solves the agent’s utility maximization problem subject to the budget constraint and non-negativity of consumption and leisure, and the government budget is balanced with $\\tau^\\ast = \\frac{1}{2}\\left(T(h_1^\\ast)+T(h_2^\\ast)\\right)$. Goods market clearing $c_1^\\ast + c_2^\\ast = y^\\ast$ must hold, with $y^\\ast = h_1^\\ast + h_2^\\ast$, and is implied by feasibility and the government budget balance. The price normalization is $1$ and all quantities are dimensionless.\n\nYour task is to write a complete program that, for each parameter set in the test suite below, computes a competitive equilibrium with taxes, and outputs the equilibrium vector $[h_1^\\ast,h_2^\\ast,\\tau^\\ast]$ with each entry rounded to $6$ decimal places. For each test case, the agent’s optimal consumption equals the right-hand side of the budget constraint at the chosen labor supply, i.e., $c_i^\\ast = w h_i^\\ast - T(w h_i^\\ast) + \\tau^\\ast$, and $\\ell_i^\\ast = 1 - h_i^\\ast$.\n\nTest suite (each line is one test case specifying $(\\alpha_1,\\alpha_2,\\theta,\\kappa,I_0)$):\n- Case A (baseline symmetric preferences and progressive tax): $(0.5, 0.5, 0.2, 0.3, 0.5)$.\n- Case B (asymmetric preferences and same tax): $(0.3, 0.7, 0.2, 0.3, 0.5)$.\n- Case C (more progressive tax): $(0.5, 0.5, 0.4, 0.6, 0.3)$.\n- Case D (no tax benchmark): $(0.5, 0.5, 0.0, 0.0, 0.0)$.\n- Case E (flat tax benchmark): $(0.8, 0.2, 0.1, 0.0, 0.0)$.\n\nFor each test case, your program must compute a competitive equilibrium with taxes and produce the vector $[h_1^\\ast,h_2^\\ast,\\tau^\\ast]$ rounded to $6$ decimal places. Your program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, where each element is the $3$-vector for the corresponding case. For example, the final output must have the form\n$[\\,[h_1^\\ast,h_2^\\ast,\\tau^\\ast],\\,[h_1^\\ast,h_2^\\ast,\\tau^\\ast],\\,[h_1^\\ast,h_2^\\ast,\\tau^\\ast],\\,[h_1^\\ast,h_2^\\ast,\\tau^\\ast],\\,[h_1^\\ast,h_2^\\ast,\\tau^\\ast]\\,]$,\nwith all numbers shown as decimal floats rounded to $6$ decimal places. Angles are not involved. Percentages, if any, must be expressed as decimals, not with a percentage sign.", "solution": "The task is to find a competitive equilibrium $(h_1^\\ast, h_2^\\ast, \\tau^\\ast)$ for a specified economic environment. The equilibrium is characterized by a set of conditions that must hold simultaneously: optimization by each agent and government budget balance. We formulate this as a fixed-point problem and solve it numerically.\n\n**1. Agent's Optimization Problem**\n\nEach agent $i \\in \\{1,2\\}$ chooses labor supply $h_i \\in [0,1]$ to maximize their utility. With the wage $w=1$, the agent's problem is to maximize:\n$$ u_i(c_i, \\ell_i) = \\alpha_i \\ln c_i + (1 - \\alpha_i) \\ln \\ell_i $$\nsubject to the constraints:\n$$ c_i = h_i - T(h_i) + \\tau $$\n$$ \\ell_i = 1 - h_i $$\n$$ c_i > 0, \\ell_i > 0 $$\nSubstituting the constraints into the utility function, the problem becomes choosing $h_i \\in (0,1)$ to maximize:\n$$ V(h_i; \\tau) = \\alpha_i \\ln(h_i - T(h_i) + \\tau) + (1 - \\alpha_i) \\ln(1 - h_i) $$\nwhere the tax function is $T(h_i) = \\theta h_i + \\kappa \\max\\{0, h_i - I_0\\}^2$.\n\n**2. First-Order Condition (FOC)**\n\nFor an interior solution $h_i \\in (0,1)$, the first-order condition for utility maximization is $\\frac{dV}{dh_i} = 0$. The derivative of the tax function, representing the marginal tax rate (MTR), is:\n$$ T'(h_i) = \\frac{dT}{dh_i} = \\theta + 2\\kappa \\max\\{0, h_i - I_0\\} $$\nDifferentiating the utility $V(h_i; \\tau)$ with respect to $h_i$ yields the FOC:\n$$ \\frac{\\partial V}{\\partial h_i} = \\frac{\\alpha_i}{c_i} (1 - T'(h_i)) - \\frac{1 - \\alpha_i}{1 - h_i} = 0 $$\nThis condition states that the marginal rate of substitution between consumption and leisure must equal the net-of-tax wage rate, which is $1-T'(h_i)$. Rearranging, we get an implicit equation for the optimal $h_i$ given $\\tau$:\n$$ h_i - T(h_i) + \\tau = \\frac{\\alpha_i}{1-\\alpha_i} (1 - h_i) (1 - T'(h_i)) $$\n\n**3. Equilibrium System and Computational Strategy**\n\nThe competitive equilibrium is a vector $(h_1^\\ast, h_2^\\ast, \\tau^\\ast)$ that simultaneously solves the two agents' FOCs and the government budget constraint:\n1. $h_1^\\ast - T(h_1^\\ast) + \\tau^\\ast - \\frac{\\alpha_1}{1-\\alpha_1} (1 - h_1^\\ast) (1 - T'(h_1^\\ast)) = 0$\n2. $h_2^\\ast - T(h_2^\\ast) + \\tau^\\ast - \\frac{\\alpha_2}{1-\\alpha_2} (1 - h_2^\\ast) (1 - T'(h_2^\\ast)) = 0$\n3. $\\tau^\\ast = \\frac{1}{2}(T(h_1^\\ast) + T(h_2^\\ast))$\n\nThis system is solved numerically as a fixed-point problem. Let $H = (h_1, h_2)$ be a vector of labor supplies. We seek a fixed point $H^\\ast$ such that $H^\\ast = F(H^\\ast)$, where the mapping $F: [0,1]^2 \\to [0,1]^2$ is defined by:\n1. Given a guess $H = (h_1, h_2)$, calculate the corresponding transfer: $\\tau(H) = \\frac{1}{2}(T(h_1) + T(h_2))$.\n2. For each agent $i$, find the optimal labor supply $h_i'$ that solves their utility maximization problem given this transfer $\\tau(H)$. This defines the new vector $H' = F(H) = (h_1', h_2')$.\n\nThe fixed point is found by searching for a root of the function $E(H) = F(H) - H = 0$. This is a two-dimensional root-finding problem, which we solve using `scipy.optimize.root`.\n\n**4. Agent's Best Response Computation**\n\nThe core of the mapping $F$ is computing the agent's best-response labor supply $h_i'(\\tau)$.\n- **Corner Solution**: An agent may choose not to work ($h_i'=0$). This occurs if the marginal utility from the first infinitesimal amount of work is non-positive. At $h_i \\to 0$, this condition is $\\frac{\\partial V}{\\partial h_i}|_{h_i \\to 0^+} \\le 0$. Assuming $I_0 > 0$ or $\\kappa=0$, this simplifies to $\\tau \\ge \\frac{\\alpha_i(1-\\theta)}{1-\\alpha_i}$. If this inequality holds, the optimal labor supply is $h_i' = 0$.\n- **Interior Solution**: If the condition for a corner solution is not met, the optimal $h_i'$ is an interior solution in $(0,1)$ that solves the FOC. Let us define the function $G_i(h; \\tau)$:\n  $$ G_i(h; \\tau) = h - T(h) + \\tau - \\frac{\\alpha_i}{1-\\alpha_i} (1 - h) (1 - T'(h)) $$\n  We need to find the root of $G_i(h; \\tau) = 0$. Since this is a nonlinear equation due to the structure of $T(h)$ and $T'(h)$, we use a numerical 1D root finder, `scipy.optimize.brentq`. This method requires an interval where the function changes sign. Given that an interior solution exists, $G_i(h; \\tau)$ will be negative near $h=0$ and positive near $h=1$ (as long as consumption remains positive), ensuring a root can be found in $(0,1)$.\n\nThe overall algorithm consists of an outer loop that calls a root-finding routine (`root`) on the system $E(H) = 0$. Inside the definition of $E(H)$, for each agent, we first check for a corner solution. If the solution is interior, we call a nested root-finding routine (`brentq`) to solve the agent's FOC for their optimal labor supply. This process is repeated for all test cases.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root, brentq\n\ndef solve():\n    \"\"\"\n    Computes the competitive equilibrium for an exchange-production economy with taxes.\n    The solution is found by solving a fixed-point problem for the agents' labor supplies.\n    \"\"\"\n\n    test_cases = [\n        (0.5, 0.5, 0.2, 0.3, 0.5),  # Case A\n        (0.3, 0.7, 0.2, 0.3, 0.5),  # Case B\n        (0.5, 0.5, 0.4, 0.6, 0.3),  # Case C\n        (0.5, 0.5, 0.0, 0.0, 0.0),  # Case D\n        (0.8, 0.2, 0.1, 0.0, 0.0),  # Case E\n    ]\n    \n    results = []\n\n    def T_func(h, theta, kappa, I0):\n        \"\"\"Computes the tax on labor income.\"\"\"\n        h = np.asanyarray(h)\n        income_above_threshold = np.maximum(0, h - I0)\n        return theta * h + kappa * income_above_threshold**2\n\n    def T_prime_func(h, theta, kappa, I0):\n        \"\"\"Computes the marginal tax rate.\"\"\"\n        h = np.asanyarray(h)\n        return theta + 2 * kappa * np.maximum(0, h - I0)\n\n    def compute_equilibrium(alpha1, alpha2, theta, kappa, I0):\n        \"\"\"\n        Calculates the equilibrium (h1*, h2*, tau*) for a given set of parameters.\n        \"\"\"\n        \n        def solve_agent_h(alpha, tau):\n            \"\"\"\n            Calculates an agent's optimal labor supply h for a given transfer tau.\n            This involves checking for a corner solution (h=0) or finding the root\n            of the first-order condition for an interior solution.\n            \"\"\"\n            # The agent's FOC implies h=0 if the marginal utility of working is non-positive at h->0.\n            # This corresponds to G(h->0) >= 0. For h<=I0, T'(h)=theta.\n            # The check_val is derived from the FOC at h -> 0.\n            # If tau is high enough, agent prefers not to work.\n            if theta < 1:\n                check_val = alpha * (1 - theta) / (1 - alpha)\n                if tau >= check_val:\n                    return 0.0\n            \n            # Define the function G(h) = 0 from the agent's first-order condition.\n            def G(h_val):\n                # Ensure h_val is within the valid domain.\n                if h_val <= 1e-12: return -1.0  # Guide solver towards positive h\n                if h_val >= 1.0 - 1e-12: return 1.0 # Guide solver away from h=1\n\n                th = T_func(h_val, theta, kappa, I0)\n                consumption = h_val - th + tau\n\n                # If consumption is non-positive, this choice is infeasible.\n                # Utility is -inf, so agent would reduce labor.\n                # The FOC function value should be large and positive.\n                if consumption <= 0:\n                    return 1e9\n\n                th_prime = T_prime_func(h_val, theta, kappa, I0)\n                \n                # FOC: c_i = (alpha_i/(1-alpha_i)) * (1-h_i) * (1-T'(h_i))\n                foc_lhs = consumption\n                foc_rhs = (alpha / (1 - alpha)) * (1 - h_val) * (1 - th_prime)\n                \n                return foc_lhs - foc_rhs\n\n            # Use brentq to find the root of G(h) for an interior solution.\n            # The search interval is (0, 1). The logic above ensures a root exists\n            # in this interval if the corner solution check fails.\n            try:\n                h_solution = brentq(G, 1e-9, 1.0 - 1e-9, xtol=1e-12, rtol=1e-12)\n                return h_solution\n            except ValueError:\n                # This case should ideally not be reached given the model's structure\n                # and the corner solution check.\n                return 0.0\n\n        def system_of_equations(h_vec):\n            \"\"\"\n            Defines the system of equations H_new - H = 0 for the fixed-point solver.\n            H = [h1, h2]. H_new is the vector of best-response labor supplies.\n            \"\"\"\n            h1, h2 = h_vec\n            \n            # Penalize out-of-bound values during iteration\n            if not (0 <= h1 <= 1 and 0 <= h2 <= 1):\n                return [1e6, 1e6]\n\n            # 1. Calculate transfer tau from current labor supplies h1, h2.\n            current_tau = 0.5 * (T_func(h1, theta, kappa, I0) + T_func(h2, theta, kappa, I0))\n            \n            # 2. Calculate each agent's optimal labor supply given the transfer.\n            h1_new = solve_agent_h(alpha1, current_tau)\n            h2_new = solve_agent_h(alpha2, current_tau)\n            \n            # 3. Return the error vector for the root finder.\n            return [h1_new - h1, h2_new - h2]\n\n        # Initial guess for the root finder. [0.5, 0.5] is a neutral starting point.\n        initial_guess = np.array([0.5, 0.5])\n        \n        # Use scipy's root finder to solve the system F(H) - H = 0.\n        solution = root(system_of_equations, initial_guess, method='hybr', tol=1e-10)\n\n        if not solution.success:\n            # Fallback to an initial guess based on no-tax solution if first fails\n            solution = root(system_of_equations, np.array([alpha1, alpha2]), method='hybr', tol=1e-10)\n            if not solution.success:\n                 # In case of persistent failure, which shouldn't happen for these parameters.\n                 raise RuntimeError(f\"Equilibrium computation failed for parameters: {alpha1, alpha2, theta, kappa, I0}\")\n\n        h1_star, h2_star = solution.x\n        \n        # Calculate the final equilibrium transfer tau*.\n        tau_star = 0.5 * (T_func(h1_star, theta, kappa, I0) + T_func(h2_star, theta, kappa, I0))\n\n        return [h1_star, h2_star, tau_star]\n\n    for case_params in test_cases:\n        alpha1, alpha2, theta, kappa, I0 = case_params\n        eq = compute_equilibrium(alpha1, alpha2, theta, kappa, I0)\n        results.append(eq)\n\n    # Format the output string exactly as required.\n    formatted_results = []\n    for res in results:\n        # Round each element to 6 decimal places and format into a string \"[v1,v2,v3]\"\n        formatted_res = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\"\n        formatted_results.append(formatted_res)\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2382171"}]}