{"hands_on_practices": [{"introduction": "One of the bisection method's most powerful features is its predictable and guaranteed convergence. This exercise moves beyond simply applying the algorithm to analyzing its performance. By calculating the minimum number of iterations required to find a project's Internal Rate of Return (IRR) to a specific precision, you will develop a core skill in computational analysis: estimating the resources needed to achieve a desired outcome [@problem_id:2438012].", "problem": "A capital budgeting analysis considers a conventional investment project with horizon $50$ years: an initial outlay $c_{0}  0$ at time $t=0$ followed by nonnegative net cash flows $c_{t} \\ge 0$ for $t=1,2,\\dots,50$, not all cash flows equal to zero. The Internal Rate of Return (IRR) $r^{\\ast}$ is defined as the root of the net present value function\n$$\n\\mathrm{NPV}(r) \\equiv \\sum_{t=0}^{50} \\frac{c_{t}}{(1+r)^{t}} = 0,\n$$\nwhere $r \\ge 0$ is the discount rate in decimal form. Under these cash-flow conditions, $\\mathrm{NPV}(r)$ is continuous and strictly decreasing in $r$ for $r \\ge 0$, so any sign change bracket contains a unique IRR.\n\nSuppose it is known that $r^{\\ast} \\in [0,\\,0.30]$, and that $\\mathrm{NPV}(0) \\ge 0$ while $\\mathrm{NPV}(0.30) \\le 0$, so the bisection method can be applied on the initial bracket $[a_{0}, b_{0}] = [0,\\,0.30]$. You use the bisection method and, at iteration $N$, report the midpoint of the current bracketing interval as the estimate of $r^{\\ast}$. You want to guarantee that the absolute estimation error is at most one basis point, where one basis point is $0.0001$ in decimal units of rate.\n\nAssuming worst-case placement of $r^{\\ast}$ within the bracket at each iteration, what is the minimal number of bisection iterations $N$ required to guarantee $|r_{N} - r^{\\ast}| \\le 0.0001$, where $r_{N}$ is the midpoint after $N$ iterations? Provide your answer as a single integer. No rounding is required.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded, well-posed, objective, and internally consistent. It presents a standard application of the bisection method for root finding in the context of computational finance, a problem which is well-defined and solvable.\n\nThe problem asks for the minimum number of iterations $N$ of the bisection method to guarantee a certain precision for the estimate of the Internal Rate of Return, $r^{\\ast}$. The core of the solution lies in the error analysis of the bisection method.\n\nLet the initial interval be $[a_0, b_0]$, where the root $r^{\\ast}$ is known to lie. The length of this interval is $L_0 = b_0 - a_0$. The bisection method iteratively halves the length of the bracketing interval. After $N$ iterations, the new interval containing the root, $[a_N, b_N]$, will have a length of:\n$$\nL_N = b_N - a_N = \\frac{b_0 - a_0}{2^N}\n$$\nThe problem specifies that the estimate of the root after $N$ iterations, denoted $r_N$, is the midpoint of this resulting interval $[a_N, b_N]$.\n$$\nr_N = \\frac{a_N + b_N}{2}\n$$\nSince the true root $r^{\\ast}$ is guaranteed to be within the interval $[a_N, b_N]$, i.e., $a_N \\le r^{\\ast} \\le b_N$, the absolute error of the estimate $r_N$ is given by $|r_N - r^{\\ast}|$. The problem states to assume the worst-case placement of $r^{\\ast}$. The maximum possible error occurs when $r^{\\ast}$ is located at one of the endpoints of the interval.\n$$\n|r_N - r^{\\ast}| \\le \\max(r_N - a_N, b_N - r_N)\n$$\nSince $r_N$ is the midpoint, this maximum error is half the length of the interval $[a_N, b_N]$:\n$$\n|r_N - r^{\\ast}| \\le \\frac{b_N - a_N}{2} = \\frac{L_N}{2}\n$$\nSubstituting the expression for $L_N$, we obtain the error bound after $N$ iterations:\n$$\n|r_N - r^{\\ast}| \\le \\frac{b_0 - a_0}{2^{N+1}}\n$$\nThe problem provides the initial interval $[a_0, b_0] = [0, 0.30]$. Thus, $a_0 = 0$ and $b_0 = 0.30$. The required absolute error tolerance is one basis point, which is $0.0001$. We must find the minimum integer $N$ that satisfies the condition:\n$$\n|r_N - r^{\\ast}| \\le 0.0001\n$$\nUsing the error bound, we establish the inequality:\n$$\n\\frac{b_0 - a_0}{2^{N+1}} \\le 0.0001\n$$\nSubstituting the values for $a_0$ and $b_0$:\n$$\n\\frac{0.30 - 0}{2^{N+1}} \\le 0.0001\n$$\n$$\n\\frac{0.30}{2^{N+1}} \\le 0.0001\n$$\nTo solve for $N$, we rearrange the inequality:\n$$\n0.30 \\le 0.0001 \\times 2^{N+1}\n$$\n$$\n\\frac{0.30}{0.0001} \\le 2^{N+1}\n$$\n$$\n3000 \\le 2^{N+1}\n$$\nTo isolate the exponent, we take the base-$2$ logarithm of both sides:\n$$\n\\log_{2}(3000) \\le N+1\n$$\nWe can compute the value of $\\log_{2}(3000)$ using the change of base formula, $\\log_{b}(x) = \\frac{\\ln(x)}{\\ln(b)}$:\n$$\n\\frac{\\ln(3000)}{\\ln(2)} \\le N+1\n$$\nUsing numerical values for the natural logarithms, $\\ln(3000) \\approx 8.006367$ and $\\ln(2) \\approx 0.693147$:\n$$\n\\frac{8.006367}{0.693147} \\approx 11.5507 \\le N+1\n$$\nSubtracting $1$ from both sides gives the condition for $N$:\n$$\n11.5507 - 1 \\le N\n$$\n$$\n10.5507 \\le N\n$$\nSince the number of iterations $N$ must be an integer, we must select the smallest integer that satisfies this condition. The smallest integer $N$ greater than or equal to $10.5507$ is $11$.\nThus, a minimum of $11$ iterations are required to guarantee that the absolute estimation error is at most $0.0001$.", "answer": "$$\\boxed{11}$$", "id": "2438012"}, {"introduction": "Now, let's move from theoretical analysis to hands-on implementation by applying the bisection method to a cornerstone of macroeconomics. This practice involves writing code to find the steady-state capital per worker in the Solow growth model, a fundamental equilibrium concept [@problem_id:2437951]. This exercise demonstrates how to translate economic theory into a computational problem and use root-finding to locate equilibria that often lack a simple closed-form solution.", "problem": "Consider a deterministic Solow growth model in per-worker form with a strictly increasing, concave production function per worker $f(k)$ satisfying $f(0)=0$. A nonnegative steady state for capital per worker $k^\\ast$ satisfies the fixed point equation\n$$\ns\\, f(k^\\ast) - (\\delta + n)\\, k^\\ast = 0,\n$$\nwhere $s \\in (0,1)$ is the constant savings rate, $\\delta \\in (0,1)$ is the depreciation rate, and $n \\ge 0$ is the exogenous population growth rate. For all test cases in this problem, the production function is Cobbâ€“Douglas of the form\n$$\nf(k) = A\\, k^{\\alpha},\n$$\nwith parameters $A0$ and $\\alpha \\in (0,1)$.\n\nDefine the function\n$$\ng(k) = s\\, f(k) - (\\delta + n)\\, k.\n$$\nFor each parameter set below, there is at least one root $k^\\ast \\ge 0$ of $g(k)$ in a prescribed closed interval $[k_{\\min}, k_{\\max}]$. Your task is to compute a root $k^\\ast$ of $g(k)$ that lies in the given interval and satisfies the following termination criteria: either (i) the absolute interval width is at most $\\varepsilon_x = 10^{-12}$ or (ii) the absolute function value satisfies $|g(k^\\ast)| \\le \\varepsilon_f = 10^{-12}$. All inputs below are unit-free. Savings rates and rates of depreciation and population growth are given as decimals (not percentages).\n\nTest suite (each case is a tuple $(A,\\alpha,s,\\delta,n,k_{\\min},k_{\\max})$):\n- Case 1: $(1.0,\\, 0.33,\\, 0.25,\\, 0.08,\\, 0.02,\\, 10^{-6},\\, 10.0)$.\n- Case 2: $(0.5,\\, 0.5,\\, 0.3,\\, 0.04,\\, 0.01,\\, 10^{-6},\\, 9.0)$.\n- Case 3: $(1.0,\\, 0.4,\\, 0.0,\\, 0.05,\\, 0.01,\\, 0.0,\\, 5.0)$.\n- Case 4: $(1.0,\\, 0.5,\\, 0.005,\\, 0.05,\\, 0.01,\\, 10^{-8},\\, 1.0)$.\n\nFinal output format:\n- Your program must produce a single line of output containing the four computed steady-state capital levels in the same order as the test suite, formatted as a comma-separated list enclosed in square brackets, with no spaces.\n- Each value must be printed as a floating-point number with exactly $8$ digits after the decimal point.\n- For example, the required format is of the form [$x_1,x_2,x_3,x_4$], where each $x_i$ is rounded to $8$ digits after the decimal point.", "solution": "The problem requires the computation of the non-negative steady-state capital per worker, denoted by $k^\\ast$, in a deterministic Solow growth model. The model is defined by a Cobb-Douglas production function per worker, $f(k) = A k^\\alpha$.\n\nFirst, a validation of the problem statement is necessary.\n\n**Step 1: Extracted Givens**\n-   The steady state for capital per worker, $k^\\ast$, is a fixed point satisfying the equation: $s\\, f(k^\\ast) - (\\delta + n)\\, k^\\ast = 0$.\n-   Parameters are the savings rate $s \\in (0,1)$, depreciation rate $\\delta \\in (0,1)$, and population growth rate $n \\ge 0$.\n-   The production function is specifically $f(k) = A\\, k^{\\alpha}$, with productivity parameter $A0$ and output elasticity of capital $\\alpha \\in (0,1)$. The function $f(k)$ is strictly increasing, concave, and satisfies $f(0)=0$.\n-   The task is to find a root of the function $g(k) = s\\, f(k) - (\\delta + n)\\, k$ within a specified interval $[k_{\\min}, k_{\\max}]$.\n-   Termination criteria for the numerical method are an interval width of at most $\\varepsilon_x = 10^{-12}$ or a function value absolute magnitude of at most $\\varepsilon_f = 10^{-12}$.\n-   Test cases are given as tuples $(A,\\alpha,s,\\delta,n,k_{\\min},k_{\\max})$:\n    1.  $(1.0,\\, 0.33,\\, 0.25,\\, 0.08,\\, 0.02,\\, 10^{-6},\\, 10.0)$\n    2.  $(0.5,\\, 0.5,\\, 0.3,\\, 0.04,\\, 0.01,\\, 10^{-6},\\, 9.0)$\n    3.  $(1.0,\\, 0.4,\\, 0.0,\\, 0.05,\\, 0.01,\\, 0.0,\\, 5.0)$\n    4.  $(1.0,\\, 0.5,\\, 0.005,\\, 0.05,\\, 0.01,\\, 10^{-8},\\, 1.0)$\n\n**Step 2: Validation**\nThe problem is scientifically grounded, as it pertains to the standard Solow-Swan neoclassical growth model, a fundamental concept in macroeconomics. The mathematical formulation is correct. The problem is objective and well-posed.\n\nThere exists a minor inconsistency: the general description states $s \\in (0,1)$, while test case 3 specifies $s=0.0$. This is not a critical flaw. The model remains perfectly valid and physically meaningful for the limit case $s=0$. It represents an economy with no savings, where capital stock must depreciate to zero. The specific parameters of a test case must take precedence over the general description. The problem remains solvable.\n\nThe function $g(k) = s A k^\\alpha - (\\delta+n)k$ has two potential non-negative roots.\n1.  The trivial steady state, $k=0$. This is always a root, as $g(0) = s A (0)^\\alpha - (\\delta+n)(0) = 0$, given the convention $0^\\alpha = 0$ for $\\alpha  0$.\n2.  The non-trivial positive steady state. For $k0$, we can solve $s A k^{\\alpha-1} - (\\delta+n) = 0$. This yields $k^{\\alpha-1} = \\frac{\\delta+n}{sA}$. Since $\\alpha \\in (0,1)$, the exponent $1-\\alpha$ is positive. The unique positive root is therefore:\n    $$\n    k^\\ast = \\left( \\frac{sA}{\\delta+n} \\right)^{\\frac{1}{1-\\alpha}}\n    $$\n    This positive steady state exists if and only if $s  0$. If $s=0$, the only non-negative root is $k=0$.\n\nThe second derivative of $g(k)$ is $g''(k) = s A \\alpha (\\alpha-1) k^{\\alpha-2}$. Given $s \\ge 0$, $A0$, $\\alpha \\in (0,1)$, we have $g''(k) \\le 0$ for all $k0$, implying that $g(k)$ is a concave function. A concave function can intersect the horizontal axis at most twice. This confirms the existence of at most one positive root.\n\nThe problem requires finding the root within a given interval. This suggests a numerical root-finding algorithm. The bisection method is a suitable and robust choice, as the problem statement guarantees that for each case, a root exists in the given interval $[k_{\\min}, k_{\\max}]$, and the function $g(k)$ is continuous. For the method to be guaranteed to converge, the function values at the endpoints of the interval must have opposite signs, i.e., $g(k_{\\min}) \\cdot g(k_{\\max})  0$. Let us verify this for the cases with non-boundary roots.\n-   Case 1: $k^\\ast \\approx 4.41 \\in [10^{-6}, 10.0]$. $g(10^{-6})  0$ and $g(10.0)  0$. Condition holds.\n-   Case 4: $k^\\ast \\approx 0.00694 \\in [10^{-8}, 1.0]$. $g(10^{-8})  0$ and $g(1.0)  0$. Condition holds.\n-   Cases 2 and 3 have a root at one of the interval boundaries. A robust implementation of the bisection method must first check if the endpoints themselves are roots before starting the iterative process.\n\n**Step 3: Verdict and Action**\nThe problem is deemed valid. A solution will be provided.\n\n**Solution Methodology**\nWe will implement the bisection method to find the root of $g(k) = sAk^\\alpha - (\\delta+n)k$ on the interval $[a, b] = [k_{\\min}, k_{\\max}]$. The tolerances are given as $\\varepsilon_x = 10^{-12}$ and $\\varepsilon_f = 10^{-12}$.\n\nThe algorithm proceeds as follows:\n1.  Define the function $g(k)$ for a given set of parameters $(A, \\alpha, s, \\delta, n)$.\n2.  Set the initial interval endpoints $a = k_{\\min}$ and $b = k_{\\max}$.\n3.  Evaluate $g(a)$ and $g(b)$. If $|g(a)| \\le \\varepsilon_f$, the root is $a$. If $|g(b)| \\le \\varepsilon_f$, the root is $b$. In these cases, the algorithm terminates.\n4.  Begin the bisection loop. A maximum number of iterations (e.g., $100$) will be used as a safeguard.\n5.  In each iteration, calculate the midpoint $c = a + (b-a)/2$.\n6.  Evaluate $g_c = g(c)$.\n7.  Check termination criteria: if $(b-a) \\le \\varepsilon_x$ or $|g_c| \\le \\varepsilon_f$, the algorithm terminates and returns $c$ as the root.\n8.  Update the interval: Let $g_a = g(a)$. If $g_a \\cdot g_c  0$, the root is in $[a, c]$, so we set $b=c$. Otherwise, the root must be in $[c, b]$, so we set $a=c$.\n9.  Repeat from step 5 until a termination criterion is met.\n\nThis procedure will be applied to each of the four test cases provided. For Case 3, where $s=0$ and $k_{\\min}=0$, we have $g(k_{\\min})=g(0)=0$. The algorithm will correctly identify $k_{\\min}=0$ as the root in the initial check. For Case 2, where the root is at $k_{\\max}=9.0$, the algorithm will also identify this in the initial checks.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the steady-state capital per worker for the Solow growth model\n    using the bisection method for different parameter sets.\n    \"\"\"\n\n    test_cases = [\n        # (A, alpha, s, delta, n, k_min, k_max)\n        (1.0, 0.33, 0.25, 0.08, 0.02, 1e-6, 10.0),\n        (0.5, 0.5, 0.3, 0.04, 0.01, 1e-6, 9.0),\n        (1.0, 0.4, 0.0, 0.05, 0.01, 0.0, 5.0),\n        (1.0, 0.5, 0.005, 0.05, 0.01, 1e-8, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        root = bisection_solver(*case)\n        results.append(root)\n\n    # Format the final output string as required.\n    output_str = f\"[{','.join([f'{r:.8f}' for r in results])}]\"\n    print(output_str)\n\ndef bisection_solver(A, alpha, s, delta, n, k_min, k_max):\n    \"\"\"\n    Finds a root of the Solow steady-state equation using the bisection method.\n\n    The function to find a root for is g(k) = s * A * k**alpha - (delta + n) * k.\n    \"\"\"\n    \n    eps_x = 1e-12\n    eps_f = 1e-12\n    max_iter = 100\n\n    # Define the function g(k) whose root we are seeking.\n    break_even_rate = delta + n\n    g = lambda k: s * A * k**alpha - break_even_rate * k\n\n    a = k_min\n    b = k_max\n\n    g_a = g(a)\n    if abs(g_a) = eps_f:\n        return a\n    \n    g_b = g(b)\n    if abs(g_b) = eps_f:\n        return b\n    \n    # Standard bisection method requires g(a) and g(b) to have opposite signs.\n    # The problem setup ensures this or that one endpoint is the root.\n    if g_a * g_b > 0:\n        # This state should not be reached with the given valid problem cases.\n        # It indicates an issue with the interval.\n        raise ValueError(\"Bisection method precondition failed: g(a) * g(b) > 0.\")\n        \n    c = a # Initialize c\n    for _ in range(max_iter):\n        c = a + (b - a) / 2\n        g_c = g(c)\n\n        # Check termination criteria\n        if (b - a) = eps_x or abs(g_c) = eps_f:\n            return c\n\n        if g_a * g_c  0:\n            b = c\n        else:\n            a = c\n            g_a = g(a) # Update g_a for the new interval [a, b]\n            \n    return c\n\nsolve()\n```", "id": "2437951"}, {"introduction": "A good algorithm works correctly on well-behaved inputs, but a great algorithm is robust enough to handle problematic cases. This exercise is a thought experiment on a critical aspect of building reliable financial software: respecting the mathematical domain of your functions [@problem_id:2437948]. By analyzing why the bisection method fails when its search interval contains a singularity, you will learn to anticipate and prevent common but serious errors in numerical implementations.", "problem": "A fixed-income analyst computes the yield to maturity (YTM) for a conventional coupon bond by solving for the interest rate $r$ that zeros the mispricing function\n$$f(r) \\equiv \\sum_{t=1}^{T} \\frac{C_t}{(1+r)^t} - P_{\\text{mkt}},$$\nwhere $T \\in \\mathbb{N}$ is the maturity in periods, cash flows satisfy $C_t \\ge 0$ with $C_T  0$, and $P_{\\text{mkt}}  0$ is the observed market price. The analyst plans to use the bisection method on an initial interval $[a,b]$. Consider the case where the initial interval is poorly chosen and contains the point $r=-1$, i.e., $a  -1  b$.\n\nWhich statement best describes what will happen and how the algorithm should be made robust in this setting?\n\nA. The bisection method will still converge as long as $f(a)f(b)  0$, because a sign change is sufficient even if $f$ is undefined at $r=-1$. No special handling is needed.\n\nB. The bisection method can fail or return meaningless results because $f(r)$ is undefined at $r=-1$ and not continuous on $[a,b]$; a sign change across $r=-1$ does not imply a root. Robustness requires enforcing the domain $r-1$ (for example, by reparameterizing with $x=\\log(1+r)$ so $r=e^x-1$ and bracketing in $x$), and verifying a valid bracket with $f(a)f(b)0$ entirely within the feasible domain.\n\nC. The bisection method will only be affected by numerical overflow; using a smaller tolerance for the midpoint and ignoring any non-numeric evaluations is sufficient to preserve convergence even if $[a,b]$ contains $-1$.\n\nD. Because bond prices are monotone in $r$, any initial $[a,b]$ will eventually lead bisection to the YTM; floating-point arithmetic will automatically skip over $r=-1$ if encountered, so no change is necessary.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n\nThe problem defines a mispricing function for a bond's yield to maturity (YTM), $r$:\n$$f(r) \\equiv \\sum_{t=1}^{T} \\frac{C_t}{(1+r)^t} - P_{\\text{mkt}}$$\nThe parameters and conditions are:\n- Maturity: $T \\in \\mathbb{N}$\n- Cash flows: $C_t \\ge 0$ for $t=1, \\dots, T-1$, and $C_T  0$\n- Market price: $P_{\\text{mkt}}  0$\n- Numerical method: Bisection method\n- Initial interval for the search: $[a,b]$\n- Specific scenario under consideration: The interval contains $r=-1$, such that $a  -1  b$.\n\nThe question asks to describe the outcome for the bisection algorithm and how to make the implementation robust.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically grounded in the fields of fixed-income analysis and numerical methods. The formula for the present value of a bond is standard. The use of a root-finding algorithm like the bisection method to find the YTM is a common application in computational finance.\n\nThe critical aspect of the problem is the analysis of the function $f(r)$ and the bisection method's requirements. The bisection method guarantees convergence to a root under two conditions:\n1. The function $f$ must be continuous on the closed interval $[a,b]$.\n2. The function values at the endpoints must have opposite signs, i.e., $f(a)f(b)  0$.\n\nThe problem statement directs us to examine the case where the interval is $[a,b]$ with $a  -1  b$. Let us inspect the function $f(r)$ at the point $r=-1$. The denominator of each term in the summation is $(1+r)^t$. When $r=-1$, this denominator becomes $(1-1)^t = 0^t = 0$ for any $t \\ge 1$. Since it is given that $C_T  0$ (and other $C_t \\ge 0$), at least one term in the summation attempts a division by zero. Therefore, the function $f(r)$ has a vertical asymptote at $r=-1$ and is discontinuous on any interval containing this point.\n\nThe problem is thus well-posed, complete, and devoid of contradictions. It sets up a valid, albeit problematic, scenario to test the understanding of the theoretical underpinnings of a numerical algorithm. The problem is not ill-posed, ambiguous, or trivial.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. It presents a clear and analyzable scenario concerning the limitations of the bisection method. I will proceed to derive the solution and evaluate the options.\n\n**Derivation of Solution**\n\nThe fundamental principle governing the bisection method is the Intermediate Value Theorem (IVT). The IVT states that for a function $f$ that is continuous on a closed interval $[a,b]$, if $f(a)$ and $f(b)$ have opposite signs, there must exist at least one point $c \\in (a,b)$ such that $f(c)=0$.\n\nIn the given scenario, the interval is $[a,b]$ where $a  -1  b$. The function $f(r)$ is discontinuous at $r=-1$. Consequently, the primary hypothesis of the IVT is violated. Therefore, even if $f(a)f(b)  0$, we cannot conclude that a root exists in $(a,b)$. The sign change can occur across the singularity at $r=-1$. For example, as $r \\to -1^+$, the sum $\\sum_{t=1}^{T} \\frac{C_t}{(1+r)^t}$ tends to $+\\infty$ (since $C_t \\ge 0$ with at least one $C_t  0$), so $f(r) \\to +\\infty$. As $r \\to -1^-$, the signs of the terms $(1+r)^t$ will alternate depending on whether $t$ is even or odd, but the magnitude will still diverge. This discontinuity means a sign change is not indicative of a root.\n\nThe bisection algorithm proceeds by calculating the midpoint $c_k = (a_k+b_k)/2$ and evaluating $f(c_k)$. If the initial interval $[a,b]$ contains $-1$, the sequence of midpoints may eventually attempt to evaluate $f(r)$ at or very close to $r=-1$. This will result in a fatal error (division by zero) or a numerical overflow (a very large floating-point number), causing the algorithm to fail. The logic of narrowing the bracket based on the sign of $f(c_k)$ collapses because the evaluation itself is compromised.\n\nTo create a robust algorithm, one must respect the domain of the function $f(r)$. From a financial perspective, the discount factor $1+r$ must be positive, which implies $r  -1$. A yield of $-100\\%$ or lower is economically meaningless, as it implies an infinite or negative present value for positive future cash flows. The search for YTM must be restricted to the domain $r \\in (-1, \\infty)$.\n\nA robust procedure must therefore:\n1.  Ensure the initial search interval $[a,b]$ is chosen such that $a > -1$.\n2.  Verify that a valid bracket is found within this domain, i.e., $f(a)f(b)  0$ for $-1  a  b$.\n\nA more sophisticated technique to enforce the domain constraint is to reparameterize the problem. Let $x = \\log(1+r)$. This maps the domain $r \\in (-1, \\infty)$ to the entire real line $x \\in (-\\infty, \\infty)$. The inverse transformation is $r = e^x - 1$. The function becomes:\n$$g(x) = f(e^x-1) = \\sum_{t=1}^{T} \\frac{C_t}{(1+(e^x-1))^t} - P_{\\text{mkt}} = \\sum_{t=1}^{T} C_t e^{-xt} - P_{\\text{mkt}}$$\nThis function $g(x)$ is continuous and well-behaved for all $x \\in \\mathbb{R}$. The bisection method can be applied to $g(x)$ on any real interval $[x_a, x_b]$ without risk of singularities. Once a root $x^*$ is found for $g(x)$, the corresponding yield is recovered as $r^* = e^{x^*} - 1$.\n\n**Option-by-Option Analysis**\n\nA. The bisection method will still converge as long as $f(a)f(b)  0$, because a sign change is sufficient even if $f$ is undefined at $r=-1$. No special handling is needed.\nThis statement is fundamentally incorrect. The convergence guarantee of the bisection method depends critically on the continuity of the function, which is violated here. A sign change across a singularity does not imply a root, and the algorithm is susceptible to failure when evaluating the function near the singularity.\n**Verdict: Incorrect**\n\nB. The bisection method can fail or return meaningless results because $f(r)$ is undefined at $r=-1$ and not continuous on $[a,b]$; a sign change across $r=-1$ does not imply a root. Robustness requires enforcing the domain $r-1$ (for example, by reparameterizing with $x=\\log(1+r)$ so $r=e^x-1$ and bracketing in $x$), and verifying a valid bracket with $f(a)f(b)0$ entirely within the feasible domain.\nThis statement correctly identifies the mathematical failure: lack of continuity invalidates the premise of the bisection method. It correctly diagnoses that a sign change is not sufficient. It correctly identifies the valid domain for the yield, $r  -1$. It proposes a valid and standard method for ensuring robustness through reparameterization, and correctly states the need to find a proper bracket within the valid domain. This analysis is complete and accurate.\n**Verdict: Correct**\n\nC. The bisection method will only be affected by numerical overflow; using a smaller tolerance for the midpoint and ignoring any non-numeric evaluations is sufficient to preserve convergence even if $[a,b]$ contains $-1$.\nThis is incorrect. The issue is a fundamental mathematical discontinuity, not just a numerical precision problem. \"Ignoring a non-numeric evaluation\" is not a coherent strategy; if the function cannot be evaluated at the midpoint, the algorithm cannot decide how to proceed. Changing the tolerance does not fix the singularity.\n**Verdict: Incorrect**\n\nD. Because bond prices are monotone in $r$, any initial $[a,b]$ will eventually lead bisection to the YTM; floating-point arithmetic will automatically skip over $r=-1$ if encountered, so no change is necessary.\nThis is incorrect. While the bond price function is monotone for $r  -1$, this property does not allow the bisection method to overcome a singularity within its search interval. The assertion that floating-point arithmetic will \"skip over\" a point of failure is nonsensical. An operation like division by zero will cause an exception or return an IEEE $754$ special value like `Inf` or `NaN`, which will break the algorithm's control flow.\n**Verdict: Incorrect**", "answer": "$$\\boxed{B}$$", "id": "2437948"}]}