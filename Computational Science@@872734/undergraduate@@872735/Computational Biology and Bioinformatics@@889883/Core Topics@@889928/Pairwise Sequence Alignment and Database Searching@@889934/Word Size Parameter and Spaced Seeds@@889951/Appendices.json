{"hands_on_practices": [{"introduction": "To truly understand how spaced seeds work, it's essential to start with the fundamental operation: hashing. This first practice challenges you to translate the formal definition of a spaced seed hash into a working program. By implementing this function, you will gain a concrete understanding of how specific nucleotide positions, dictated by a seed pattern, are converted into a unique integer value for efficient indexing and lookup. [@problem_id:2441094]", "problem": "You are given the formal definition of a spaced seed hashing over the Deoxyribonucleic Acid (DNA) alphabet $\\{A,C,G,T\\}$. A spaced seed pattern is a binary string $s$ of length $L$ with at least one $1$; the number of $1$ symbols in $s$ is the word size parameter $w$. For a DNA string $x$ of length $n \\geq L$, consider each contiguous substring (window) $x[i\\,..\\,i+L-1]$ of length $L$ for $i \\in \\{0,1,\\dots,n-L\\}$. Define the set of indices of care positions as $P = \\{j \\in \\{0,1,\\dots,L-1\\} \\mid s[j] = 1\\}$, listed in strictly increasing order as $P = (p_0,p_1,\\dots,p_{w-1})$. Define a symbol-to-digit mapping $\\phi:\\{A,C,G,T\\} \\to \\{0,1,2,3\\}$ by $\\phi(A)=0$, $\\phi(C)=1$, $\\phi(G)=2$, $\\phi(T)=3$. The spaced-seed hash of a window $x[i\\,..\\,i+L-1]$ with respect to $s$ is the base-$4$ integer\n$$\nH_s\\big(x[i\\,..\\,i+L-1]\\big) \\;=\\; \\sum_{t=0}^{w-1} \\phi\\big(x[i+p_t]\\big)\\cdot 4^{\\,w-1-t}.\n$$\nAll strings will contain only the letters $A$, $C$, $G$, and $T$. All indices are $0$-based. All arithmetic is over the integers.\n\nTask: Implement a program that, for each test case below, computes the list of spaced-seed hash values $H_s$ for every window $x[i\\,..\\,i+L-1]$ in order of increasing $i$, using the definition above.\n\nTest suite:\n- Case $1$ (general case): $s=\\text{\"10101\"}$ (so $L=5$), $x=\\text{\"ACGTACGTAC\"}$ (so $n=10$).\n- Case $2$ (large number of do-not-care positions): $s=\\text{\"100000010000001\"}$ (so $L=15$), $x=\\text{\"ACGTACGTACGTACGTACGT\"}$ (so $n=20$).\n- Case $3$ (single care position, boundary case): $s=\\text{\"0001000\"}$ (so $L=7$), $x=\\text{\"TTACGGAAC\"}$ (so $n=9$).\n- Case $4$ (all care positions, dense seed): $s=\\text{\"1111\"}$ (so $L=4$), $x=\\text{\"AGCTAG\"}$ (so $n=6$).\n\nFor each case, the required result is the list of integers $[H_s(x[0\\,..\\,L-1]), H_s(x[1\\,..\\,L]), \\dots, H_s(x[n-L\\,..\\,n-1])]$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Each result must be a bracketed, comma-separated list of integers with no spaces. For example, a valid output structure is \"[[a,b],[c,d],[e,f,g],[h]]\" where $a,b,c,d,e,f,g,h$ are integers computed as specified. No additional text or whitespace is allowed in the output line.", "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded, well-posed, and objective. It provides a formal, complete, and consistent definition of a spaced-seed hashing function, a standard concept in computational biology. The task is to implement this function and apply it to a given set of test cases. A step-by-step solution can be systematically constructed.\n\nThe objective is to compute the spaced-seed hash value $H_s$ for every possible contiguous substring (window) of length $L$ within a longer DNA sequence $x$ of length $n$. The process is deterministic and can be broken down into the following steps.\n\nFirst, the spaced seed pattern $s$ must be processed. The length of the pattern is denoted by $L$. From $s$, we must identify the set of *care positions* $P$, which are the $0$-based indices where the pattern string $s$ contains the character '1'. These indices are collected into an ordered list $P = (p_0, p_1, \\dots, p_{w-1})$, where the indices are sorted in strictly increasing order. The number of care positions, $w = |P|$, is the word size of the seed.\n\nSecond, the provided symbol-to-digit mapping, $\\phi:\\{A,C,G,T\\} \\to \\{0,1,2,3\\}$, is defined as $\\phi(A)=0$, $\\phi(C)=1$, $\\phi(G)=2$, and $\\phi(T)=3$. This mapping converts the relevant DNA characters into their numerical representations.\n\nThird, we iterate through the DNA sequence $x$. The sequence $x$ has length $n$. Windows are substrings of length $L$. The first window is $x[0\\,..\\,L-1]$, the second is $x[1\\,..\\,L]$, and so on, up to the last possible window, $x[n-L\\,..\\,n-1]$. The iteration proceeds over the starting index $i$ of the window, for $i \\in \\{0, 1, \\dots, n-L\\}$.\n\nFor each window starting at index $i$, we compute the hash value $H_s\\big(x[i\\,..\\,i+L-1]\\big)$. The definition provided is:\n$$\nH_s\\big(x[i\\,..\\,i+L-1]\\big) \\;=\\; \\sum_{t=0}^{w-1} \\phi\\big(x[i+p_t]\\big)\\cdot 4^{\\,w-1-t}\n$$\nThis formula represents the construction of a base-$4$ integer. The \"digits\" of this number are the values $\\phi\\big(x[i+p_t]\\big)$ corresponding to the characters at the care positions within the current window. The character at absolute index $i+p_t$ in the string $x$ corresponds to the $t$-th care position of the seed pattern, where $t$ ranges from $0$ to $w-1$. The term $4^{w-1-t}$ provides the correct positional weight for each digit in the base-$4$ system.\n\nA computationally efficient method to calculate this sum is to use Horner's method. We can initialize a hash value $H$ to $0$. Then, for each $t$ from $0$ to $w-1$, we update the hash using the rule:\n$$\nH_{\\text{new}} = H_{\\text{old}} \\cdot 4 + \\phi\\big(x[i+p_t]\\big)\n$$\nThis iterative process avoids explicit computation of powers of $4$ in each step. Let us unroll this for clarity.\nFor $t=0$: $H = \\phi\\big(x[i+p_0]\\big)$.\nFor $t=1$: $H = \\big(\\phi\\big(x[i+p_0]\\big)\\big) \\cdot 4 + \\phi\\big(x[i+p_1]\\big)$.\nFor $t=2$: $H = \\big(\\phi\\big(x[i+p_0]\\big) \\cdot 4 + \\phi\\big(x[i+p_1]\\big)\\big) \\cdot 4 + \\phi\\big(x[i+p_2]\\big) = \\phi\\big(x[i+p_0]\\big) \\cdot 4^2 + \\phi\\big(x[i+p_1]\\big) \\cdot 4^1 + \\phi\\big(x[i+p_2]\\big) \\cdot 4^0$.\nThis demonstrates that the iterative update correctly computes the specified summation.\n\nThis entire procedure is performed for each window from $i=0$ to $i=n-L$. The resulting integer hash values are collected into a list, in the order of their corresponding window index $i$. This process is then repeated for each test case provided in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to drive the solution. It defines the test cases and computes\n    the spaced-seed hashes for each, then prints the results in the specified format.\n    \"\"\"\n    \n    # Define the symbol-to-digit mapping phi\n    phi = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general case)\n        (\"10101\", \"ACGTACGTAC\"),\n        # Case 2 (large number of do-not-care positions)\n        (\"100000010000001\", \"ACGTACGTACGTACGTACGT\"),\n        # Case 3 (single care position, boundary case)\n        (\"0001000\", \"TTACGGAAC\"),\n        # Case 4 (all care positions, dense seed)\n        (\"1111\", \"AGCTAG\"),\n    ]\n\n    all_results = []\n    for s, x in test_cases:\n        hashes = calculate_spaced_seed_hashes(s, x, phi)\n        all_results.append(hashes)\n    \n    # Format the final output according to the problem specification.\n    # e.g., \"[[r1_1,r1_2],[r2_1,r2_2,r2_3]]\"\n    formatted_results = []\n    for result_list in all_results:\n        # Convert each integer list to a comma-separated string without spaces.\n        formatted_list = f\"[{','.join(map(str, result_list))}]\"\n        formatted_results.append(formatted_list)\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\ndef calculate_spaced_seed_hashes(s, x, phi):\n    \"\"\"\n    Computes the list of spaced-seed hash values for a given seed pattern and DNA string.\n\n    Args:\n        s (str): The spaced seed pattern (binary string).\n        x (str): The DNA sequence.\n        phi (dict): The symbol-to-digit mapping.\n\n    Returns:\n        list[int]: A list of calculated hash values for each window.\n    \"\"\"\n    L = len(s)\n    n = len(x)\n    \n    # Determine the care positions and the word size w\n    care_positions = [j for j, char in enumerate(s) if char == '1']\n    w = len(care_positions)\n    \n    # Check for the edge case where the seed has no care positions, although\n    # the problem statement guarantees at least one '1'.\n    if w == 0:\n        return [0] * (n - L + 1) if n >= L else []\n\n    hash_results = []\n    \n    # Iterate through all possible windows in the DNA sequence x\n    for i in range(n - L + 1):\n        # For each window, compute the spaced-seed hash\n        current_hash = 0\n        \n        # Iteratively build the base-4 hash value\n        # This is equivalent to Horner's method for polynomial evaluation\n        # and avoids costly exponentiation inside the loop.\n        for p_t in care_positions:\n            # Get the character at the care position within the current window\n            char_at_pos = x[i + p_t]\n            # Map character to its digit value\n            digit = phi[char_at_pos]\n            # Update hash: H = H * 4 + digit\n            current_hash = current_hash * 4 + digit\n            \n        hash_results.append(current_hash)\n        \n    return hash_results\n\nsolve()\n```", "id": "2441094"}, {"introduction": "Beyond the mechanics of hashing, a crucial aspect of bioinformatics tool design is choosing the right parameters. This exercise guides you through a theoretical derivation to find the optimal seed weight, or word size $k$, that balances the trade-off between sensitivity and specificity. Mastering this concept will allow you to make principled design choices that maximize performance for a given biological problem, such as distinguishing between two species. [@problem_id:2441114]", "problem": "Two orthologous deoxyribonucleic acid (DNA) segments of length $N$ are compared using a seed-and-extend strategy. The alphabet size is $|\\Sigma|=4$, and sites evolve independently under a time-homogeneous, symmetric substitution process so that the average per-site divergence between the two species is $d$, meaning the per-site match probability is $p=1-d$. A seed is defined by a binary pattern of span $s$ and weight $k$, where $k$ positions (the ones) must match and the remaining $s-k$ positions (the zeros) are ignored; such a seed is called a spaced seed of weight $k$. You place the seed at $t$ non-overlapping positions along the alignment, with $t$ treated as an external design parameter (for example, $t \\approx \\lfloor N/s \\rfloor$ when using stride $s$ so that placements are independent).\n\nAssume the following well-tested modeling facts:\n- Under the independence model, for a single placement in homologous sequence, the probability that a seed of weight $k$ matches exactly is $p^{k}$, because $k$ specified sites must match independently.\n- Against an unrelated background generated by an independent, uniform four-letter source, the probability that a seed of weight $k$ matches at a given placement is $4^{-k}$.\n- Over $t$ independent placements, the probability of at least one hit is $1-(1-q)^{t}$ when the per-placement success probability is $q$.\n\nYou adopt the decision rule “declare related if and only if there is at least one seed hit among the $t$ placements.” Your design objective is to distinguish the species by maximizing specificity (minimizing the false-positive probability) subject to a required sensitivity constraint: the probability of at least one hit under homology must be at least a prescribed target $\\tau \\in (0,1)$.\n\nStarting only from the modeling assumptions above, derive a closed-form expression for the optimal seed weight $k^{\\star}$ that minimizes the false-positive probability subject to the sensitivity constraint. Express $k^{\\star}$ in terms of $d$, $t$, and $\\tau$. Give your final answer as a single analytic expression. Do not round.", "solution": "The problem as stated is subjected to validation.\n\n**Step 1: Extracted Givens**\n- Two orthologous DNA segments of length $N$.\n- Alphabet size is $|\\Sigma|=4$.\n- Per-site divergence is $d$.\n- Per-site match probability is $p=1-d$.\n- A spaced seed has span $s$ and weight $k$.\n- The seed is placed at $t$ non-overlapping positions.\n- The probability that a seed of weight $k$ matches in homologous sequence is $p^{k}$.\n- The probability that a seed of weight $k$ matches in an unrelated background is $4^{-k}$.\n- The probability of at least one hit over $t$ independent placements is $1-(1-q)^{t}$, where $q$ is the per-placement success probability.\n- The decision rule is to declare sequences related if at least one seed hit occurs among the $t$ placements.\n- The objective is to minimize the false-positive probability.\n- There is a sensitivity constraint: the probability of at least one hit under homology must be at least $\\tau \\in (0,1)$.\n- The goal is to find a closed-form expression for the optimal seed weight $k^{\\star}$ in terms of $d$, $t$, and $\\tau$.\n\n**Step 2: Validation**\nThe problem is scientifically grounded, well-posed, and objective. It formalizes a standard trade-off in sequence alignment heuristic design, specifically balancing sensitivity and specificity. The modeling assumptions, such as independent sites and independent seed placements, are common and necessary simplifications in bioinformatics to make the analysis tractable. All necessary parameters and relationships ($p$, $d$, $t$, $\\tau$, and the probability formulas) are provided. The problem is not contradictory, incomplete, or ambiguous. It represents a valid optimization problem within computational biology.\n\n**Verdict**\nThe problem is deemed valid. A solution will be derived.\n\n**Derivation of the Solution**\nThe problem is to find the optimal seed weight $k^{\\star}$ that minimizes the false-positive probability while satisfying a minimum sensitivity requirement. We shall formalize these quantities based on the provided model.\n\nLet $S(k)$ be the sensitivity, which is the probability of at least one seed hit between the two homologous DNA segments. The per-placement probability of a hit is given as $q_{true} = p^k$. With $t$ independent placements, the total probability of at least one hit is:\n$$S(k) = 1 - (1 - p^k)^t$$\nThe sensitivity constraint requires that $S(k) \\ge \\tau$.\n\nLet $FP(k)$ be the false-positive probability, which is the probability of at least one seed hit when comparing unrelated sequences. The per-placement probability of a hit against a random background is given as $q_{false} = 4^{-k}$. With $t$ independent placements, the false-positive probability is:\n$$FP(k) = 1 - (1 - 4^{-k})^t$$\nThe objective is to minimize $FP(k)$.\n\nTo minimize $FP(k) = 1 - (1 - 4^{-k})^t$, we must maximize the term $(1 - 4^{-k})^t$. Since $t$ is a positive parameter, this is equivalent to maximizing the base, $1 - 4^{-k}$. Maximizing $1 - 4^{-k}$ is equivalent to minimizing $4^{-k}$. The function $f(x) = 4^{-x}$ is a decreasing function of $x$. Therefore, minimizing $4^{-k}$ is equivalent to maximizing the seed weight $k$.\n\nThe problem is thus transformed into finding the maximum possible value of $k$ that satisfies the sensitivity constraint:\n$$S(k) \\ge \\tau$$\n$$1 - (1 - p^k)^t \\ge \\tau$$\nWe proceed to solve this inequality for $k$.\n$$(1 - p^k)^t \\le 1 - \\tau$$\nSince $\\tau \\in (0,1)$ and $t$ is positive, we can take the $t$-th root of both sides without changing the inequality's direction:\n$$1 - p^k \\le (1 - \\tau)^{1/t}$$\nRearranging the terms to isolate $p^k$:\n$$p^k \\ge 1 - (1 - \\tau)^{1/t}$$\nTo solve for $k$, we take the natural logarithm of both sides. The per-site divergence $d$ is typically non-zero, so $d  0$, which implies $p = 1-d  1$. Consequently, $\\ln(p)$ is a negative number. When we apply the logarithm, we must be prepared to reverse the inequality upon division by $\\ln(p)$.\n$$\\ln(p^k) \\ge \\ln\\left(1 - (1 - \\tau)^{1/t}\\right)$$\n$$k \\ln(p) \\ge \\ln\\left(1 - (1 - \\tau)^{1/t}\\right)$$\nDividing by $\\ln(p)$ and reversing the inequality sign yields:\n$$k \\le \\frac{\\ln\\left(1 - (1 - \\tau)^{1/t}\\right)}{\\ln(p)}$$\nThis inequality provides an upper bound on the seed weight $k$. Since our objective is to maximize $k$, the optimal value $k^{\\star}$ is the maximum value allowed by the constraint, which is the upper bound itself.\n$$k^{\\star} = \\frac{\\ln\\left(1 - (1 - \\tau)^{1/t}\\right)}{\\ln(p)}$$\nFinally, we substitute the definition $p = 1-d$ into the expression for $k^{\\star}$:\n$$k^{\\star} = \\frac{\\ln\\left(1 - (1 - \\tau)^{1/t}\\right)}{\\ln(1-d)}$$\nThis is the closed-form expression for the optimal seed weight, treated as a continuous variable, which minimizes the false-positive probability under the specified sensitivity constraint. The numerator is negative because $1 - (1-\\tau)^{1/t}  1$, and the denominator is negative because $1-d  1$, so $k^{\\star}$ is positive, as expected for a weight.", "answer": "$$\\boxed{\\frac{\\ln\\left(1 - (1 - \\tau)^{1/t}\\right)}{\\ln(1-d)}}$$", "id": "2441114"}, {"introduction": "An algorithm's theoretical elegance is only useful if it is practically feasible. This final practice brings the concepts of word size and seed indexing into the real world by asking you to estimate the memory required to index the entire human genome. This exercise emphasizes the importance of resource management in bioinformatics and demonstrates how design choices, such as the seed weight, have direct and significant consequences on the computational resources needed. [@problem_id:2441116]", "problem": "You are building an index for spaced seeds over the haploid human reference genome to support seed-and-extend alignment. A spaced seed is defined by a binary mask of span $S$ and weight $W$, where the mask selects $W$ informative positions within a window of $S$ nucleotides. For this problem, the mask has weight $W=12$ and span $S=18$. The index to be built is a direct-address hash index with the following specification:\n\n- The haploid human genome length is $L=3.2\\times 10^{9}$ bases. Assume there are no ambiguous nucleotides ($N$) anywhere in the genome.\n- For each genomic offset $t$ from $1$ to $L-S+1$, extract the spaced seed defined by the mask at the window $[t, t+S-1]$. Consider only the forward strand.\n- Each spaced seed is encoded by $2W$ bits (two bits per nucleotide), yielding $4^{W}$ possible keys in total.\n- The index consists of two arrays:\n  1. A primary direct-address array of length $4^{W}$, keyed by the $2W$-bit code of the seed. For each key, store two unsigned $32$-bit integers: the starting offset and the count of positions for that key in the positions array. No other metadata is stored.\n  2. A positions array containing one unsigned $32$-bit integer per valid window, storing the genomic start coordinate $t$ of each spaced-seed occurrence. Entries are laid out by grouping all positions for the same key contiguously (in arbitrary key order).\n- Ignore any memory overhead from the operating system or memory allocator; compute only the raw byte sizes of these arrays.\n- Use the decimal definition of Gigabyte (Gigabyte (GB) $=10^{9}$ bytes).\n\nUnder these assumptions, what is the total memory required to store the complete index, expressed in Gigabytes? Round your answer to three significant figures.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- Spaced seed mask span: $S=18$\n- Spaced seed mask weight: $W=12$\n- Haploid human genome length: $L=3.2 \\times 10^{9}$ bases\n- Nucleotide encoding: $2$ bits per nucleotide\n- Seed key encoding: $2W$ bits\n- Total possible keys: $4^{W}$\n- Index structure:\n    1. Primary direct-address array:\n        - Length: $4^{W}$\n        - Entry content: two unsigned $32$-bit integers\n    2. Positions array:\n        - Content: one unsigned $32$-bit integer per valid window\n        - Valid windows: for genomic offsets $t$ from $1$ to $L-S+1$\n- Data types: unsigned $32$-bit integers\n- Memory overhead (OS, allocator): ignore\n- Unit definition: $1$ Gigabyte (GB) $= 10^9$ bytes\n- Output requirement: Total memory in GB, rounded to three significant figures.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is evaluated against the specified criteria.\n- **Scientifically Grounded**: The problem describes the construction of a spaced seed index, a fundamental and widely used data structure in bioinformatics for sequence alignment. The parameters given ($L, S, W$) are realistic for indexing a human genome. The concept is sound.\n- **Well-Posed**: The problem is clearly specified. All necessary parameters and definitions are provided to calculate the sizes of the two arrays comprising the index. A unique numerical solution exists.\n- **Objective**: The language is precise and quantitative. There are no subjective or ambiguous statements.\n- **Completeness and Consistency**: The problem is self-contained. The data types (unsigned $32$-bit integer) are sufficient to store the required information; a $32$-bit integer can hold values up to $2^{32}-1 \\approx 4.29 \\times 10^9$, which is greater than the maximum genomic offset $L-S+1 \\approx 3.2 \\times 10^9$. The constraints are consistent.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is scientifically sound, well-posed, and complete. A solution will be derived.\n\nThe total memory requirement, denoted by $M_{\\text{total}}$, is the sum of the memory required for the primary direct-address array, $M_{\\text{primary}}$, and the memory required for the positions array, $M_{\\text{pos}}$.\n$$M_{\\text{total}} = M_{\\text{primary}} + M_{\\text{pos}}$$\n\nFirst, we calculate the size of the primary direct-address array, $M_{\\text{primary}}$.\nThis array is indexed by all possible spaced seed keys. The number of possible keys, $N_{\\text{keys}}$, is determined by the seed weight $W$. With an alphabet of $4$ nucleotides and a weight of $W$, the number of distinct keys is:\n$$N_{\\text{keys}} = 4^{W}$$\nGiven $W=12$:\n$$N_{\\text{keys}} = 4^{12} = (2^2)^{12} = 2^{24} = 16,777,216$$\nEach entry in this array consists of two unsigned $32$-bit integers. An unsigned $32$-bit integer occupies $32$ bits, which is $\\frac{32}{8} = 4$ bytes. Therefore, the size of each entry is $2 \\times 4 = 8$ bytes.\nThe total size of the primary array is the number of entries multiplied by the size of each entry:\n$$M_{\\text{primary}} = N_{\\text{keys}} \\times (\\text{size of one entry})$$\n$$M_{\\text{primary}} = 16,777,216 \\times 8 \\text{ bytes} = 134,217,728 \\text{ bytes}$$\n\nNext, we calculate the size of the positions array, $M_{\\text{pos}}$.\nThis array stores one entry for each valid window in the genome. The number of valid windows, $N_{\\text{windows}}$, corresponds to the number of possible starting positions $t$ for a seed of span $S$ within a genome of length $L$. The starting positions range from $t=1$ to $t=L-S+1$.\n$$N_{\\text{windows}} = (L-S+1) - 1 + 1 = L-S+1$$\nSubstituting the given values $L=3.2 \\times 10^9$ and $S=18$:\n$$N_{\\text{windows}} = 3.2 \\times 10^9 - 18 + 1 = 3.2 \\times 10^9 - 17$$\n$$N_{\\text{windows}} = 3,200,000,000 - 17 = 3,199,999,983$$\nEach entry in the positions array is a single unsigned $32$-bit integer, which is $4$ bytes.\nThe total size of the positions array is the number of windows multiplied by the size of each entry:\n$$M_{\\text{pos}} = N_{\\text{windows}} \\times (\\text{size of one entry})$$\n$$M_{\\text{pos}} = (3.2 \\times 10^9 - 17) \\times 4 \\text{ bytes}$$\n$$M_{\\text{pos}} = 3,199,999,983 \\times 4 \\text{ bytes} = 12,799,999,932 \\text{ bytes}$$\n\nNow, we compute the total memory requirement by summing the sizes of the two arrays:\n$$M_{\\text{total}} = M_{\\text{primary}} + M_{\\text{pos}}$$\n$$M_{\\text{total}} = 134,217,728 \\text{ bytes} + 12,799,999,932 \\text{ bytes}$$\n$$M_{\\text{total}} = 12,934,217,660 \\text{ bytes}$$\n\nThe problem requires the answer in Gigabytes (GB), using the definition $1 \\text{ GB} = 10^9 \\text{ bytes}$.\n$$M_{\\text{total}} (\\text{in GB}) = \\frac{12,934,217,660}{10^9} = 12.934217660 \\text{ GB}$$\n\nFinally, we round the result to three significant figures. The number is $12.9342...$. The first three significant digits are $1$, $2$, and $9$. The fourth significant digit is $3$, which is less than $5$, so we round down.\n$$M_{\\text{total}} (\\text{in GB}) \\approx 12.9$$", "answer": "$$\\boxed{12.9}$$", "id": "2441116"}]}