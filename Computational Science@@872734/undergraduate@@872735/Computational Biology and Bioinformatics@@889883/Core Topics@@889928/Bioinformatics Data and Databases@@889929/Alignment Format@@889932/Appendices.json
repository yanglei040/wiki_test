{"hands_on_practices": [{"introduction": "The CIGAR string is the grammar of a genomic alignment, encoding the story of how a read maps to a reference. Before you can interpret complex alignment scenarios, you must be fluent in this language. This foundational exercise tests your understanding of the core CIGAR operations by asking you to translate an alignment's CIGAR string back into a property of the original sequencing read—its length [@problem_id:2370597].", "problem": "In the Sequence Alignment/Map (SAM) format and its binary equivalent, Binary Alignment/Map (BAM), each alignment includes a Compact Idiosyncratic Gapped Alignment Report (CIGAR) string that encodes the lengths and types of alignment operations. Consider the CIGAR string $15\\mathrm{M}5\\mathrm{I}10\\mathrm{M}5\\mathrm{D}15\\mathrm{M}$. An $\\mathrm{M}$ operation denotes an alignment match-or-mismatch and consumes nucleotides from both the read and the reference; an $\\mathrm{I}$ operation denotes an insertion with respect to the reference and consumes nucleotides from the read only; a $\\mathrm{D}$ operation denotes a deletion relative to the reference (i.e., a base is missing from the read that is present in the reference) and consumes nucleotides from the reference only. The integer preceding each operation gives the count of nucleotides to which the operation applies. Assume no soft clipping ($\\mathrm{S}$) or hard clipping ($\\mathrm{H}$) operations are present.\n\nWhat is the minimal possible length, in nucleotides, of a DNA read (query) sequence that could produce this CIGAR string when aligned to some reference? Express your answer as an integer.", "solution": "The problem requires the determination of the length of a DNA read, or query sequence, from its given CIGAR string. The CIGAR string, an acronym for Compact Idiosyncratic Gapped Alignment Report, provides a concise representation of an alignment. The total length of the query sequence is found by summing the lengths of all CIGAR operations that consume bases from the query itself.\n\nThe problem provides definitions for three types of operations:\n- Operation $\\mathrm{M}$ (alignment match-or-mismatch) consumes bases from both the query and the reference sequence.\n- Operation $\\mathrm{I}$ (insertion with respect to the reference) consumes bases from the query sequence only.\n- Operation $\\mathrm{D}$ (deletion relative to the reference) consumes bases from the reference sequence only.\n\nThe problem statement explicitly rules out the presence of clipping operations ($\\mathrm{S}$ and $\\mathrm{H}$). This is a critical simplification, as it means the length of the sequence described by the CIGAR string is unambiguous. The phrase \"minimal possible length\" is therefore equivalent to the single, determined length of the sequence segment participating in the alignment.\n\nThe CIGAR string provided is $15\\mathrm{M}5\\mathrm{I}10\\mathrm{M}5\\mathrm{D}15\\mathrm{M}$. Let $L_{\\text{read}}$ be the length of the read sequence in nucleotides. We must calculate $L_{\\text{read}}$ by dissecting the CIGAR string and summing the contributions of each component that consumes the read.\n\nThe contributions are as follows:\n- The component $15\\mathrm{M}$ corresponds to $15$ bases consumed from the read.\n- The component $5\\mathrm{I}$ corresponds to $5$ bases consumed from the read.\n- The component $10\\mathrm{M}$ corresponds to $10$ bases consumed from the read.\n- The component $5\\mathrm{D}$ corresponds to a deletion relative to the reference. It consumes bases from the reference, thus it contributes $0$ bases to the read's length.\n- The component $15\\mathrm{M}$ corresponds to $15$ bases consumed from the read.\n\nTo find the total length $L_{\\text{read}}$, we sum these values:\n$$L_{\\text{read}} = 15 + 5 + 10 + 0 + 15$$\nPerforming the summation:\n$$L_{\\text{read}} = 20 + 10 + 15$$\n$$L_{\\text{read}} = 30 + 15$$\n$$L_{\\text{read}} = 45$$\nThus, the length of the DNA read that produces the given CIGAR string is $45$ nucleotides.", "answer": "$$\\boxed{45}$$", "id": "2370597"}, {"introduction": "The SAM FLAG is more than just a technical field; it's a dense summary of an alignment's context and geometry. This practice moves beyond simple decoding to explore the profound biological consequences encoded in these bits. By analyzing how a hypothetical single-bit error can fabricate evidence for a major structural variant, you will develop a critical intuition for how data artifacts can lead to significant biological misinterpretations [@problem_id:2370643].", "problem": "A paired-end whole-genome sequencing dataset was aligned with a standard inward-facing library configuration, where a properly paired fragment has read $1$ mapping to the forward strand and read $2$ mapping to the reverse strand on the reference genome (often described as an \"FR\" library). The aligner outputs Sequence Alignment/Map (SAM) flags, and the Binary Alignment/Map (BAM) format encodes the same flags. The SAM flag is a bitwise-encoded integer: each property is represented by a bit with a fixed value, and the total flag is the sum of the values of all bits that apply. Consider the following core definitions used by most aligners and downstream tools:\n- Bit value $1$: template is paired.\n- Bit value $2$: each segment in the template is properly aligned according to the aligner.\n- Bit value $4$: this segment (read) is unmapped.\n- Bit value $8$: the mate is unmapped.\n- Bit value $16$: this segment is mapped to the reverse complement strand.\n- Bit value $32$: the mate is mapped to the reverse complement strand.\n- Bit value $64$: this is the first segment (read $1$) in the template.\n- Bit value $128$: this is the second segment (read $2$) in the template.\n\nYou examine a read pair whose SAM flags are $99$ for read $1$ and $147$ for read $2$. The mapping coordinates and insert size are typical of a proper pair. Now suppose a single-bit error flips the state of the bit indicating \"this segment is reverse complemented\" for read $1$ while leaving all other bits and the alignment coordinates unchanged.\n\nWhich of the following best captures the most consequential change in biological interpretation that could result from this one-bit flip in read $1$'s flag?\n\nA. The pair would likely be reinterpreted as a discordant \"inversion-like\" orientation (both reads on the reverse strand) and could produce a false positive structural variant signal near this locus.\n\nB. The pair would still be considered a proper pair for all downstream tools because mapping positions and insert size are unchanged; orientation bits are ignored in practice.\n\nC. The change would only affect duplicate marking without influencing biological interpretation, since duplicate marking relies solely on mapping start positions and the CIGAR string.\n\nD. The read would be treated as unmapped and removed from analysis, eliminating any possibility of biological misinterpretation from this pair.", "solution": "**Analysis of the Initial State**\n\nFirst, we must decompose the initial SAM flags to understand the state of the read pair as described by the aligner. The flag is the sum of the bit values for all true properties.\n\nFor read $1$, the flag is $99$:\n$99 = 64 + 32 + 2 + 1$.\nThis decodes as:\n- $64$: This is the first segment (read $1$).\n- $32$: The mate (read $2$) is mapped to the reverse complement strand.\n- $2$: The pair is properly aligned.\n- $1$: The template is paired.\nThe bit $16$ (this segment is reverse complemented) is not set, so read $1$ is on the forward strand. This describes a read $1$ on the forward strand whose mate is on the reverse strand.\n\nFor read $2$, the flag is $147$:\n$147 = 128 + 16 + 2 + 1$.\nThis decodes as:\n- $128$: This is the second segment (read $2$).\n- $16$: This segment is mapped to the reverse complement strand.\n- $2$: The pair is properly aligned.\n- $1$: The template is paired.\nThe bit $32$ (the mate is reverse complemented) is not set, so the mate (read $1$) is on the forward strand. This describes a read $2$ on the reverse strand whose mate is on the forward strand.\n\nThe combination of these flags ($99$ and $147$) consistently describes a \"proper pair\" from a standard $\\text{FR}$ library: read $1$ is forward, read $2$ is reverse, and they are oriented towards each other. The presence of the \"properly aligned\" bit ($2$) in both flags confirms this interpretation by the aligner.\n\n**Analysis of the Perturbation**\n\nThe problem states that the bit for \"this segment is reverse complemented\" (value $16$) is flipped for read $1$.\nThe initial flag for read $1$ is $99$. The bit with value $16$ is not set. A \"flip\" in this case means setting the bit to true. Therefore, the new flag for read $1$ is the original flag plus the value of the flipped bit:\nNew flag for read $1 = 99 + 16 = 115$.\n\n**Analysis of the New State**\n\nThe read pair is now described by the flags $115$ for read $1$ and $147$ for read $2$. Let us analyze the meaning of this new state for downstream tools, particularly for structural variant (SV) calling.\n\nNew flag for read $1$ is $115$:\n$115 = 64 + 32 + 16 + 2 + 1$.\nThe critical changes are due to the new presence of bit $16$:\n- $64$: This is read $1$.\n- $16$: This segment (read $1$) is mapped to the reverse complement strand.\n- $32$: The mate (read $2$) is mapped to the reverse complement strand.\n- (Other bits `1`, `2` are unchanged).\n\nThe flag for read $2$ remains $147$, which indicates it is on the reverse strand.\nSo, the new interpretation based on the individual orientation flags is:\n- Read $1$ is on the reverse strand (due to bit $16$ in flag $115$).\n- Read $2$ is on the reverse strand (due to bit $16$ in flag $147$).\n\nThe pair's orientation has changed from $\\text{FR}$ (forward-reverse, `-> ... <-`) to $\\text{RR}$ (reverse-reverse, `<- ... <-`). This is a discordant read pair orientation. In the context of a standard library, an $\\text{RR}$ orientation, where both reads map to the same strand and point in the same direction, is a classic signature for a genomic inversion. The reads flank one of the inversion's breakpoints.\n\nBecause the problem states that this change arose from a technical error (a bit flip) and not a true biological rearrangement, any tool that identifies this $\\text{RR}$ pattern will report a structural variant that does not exist. This is a false positive call, a serious form of biological misinterpretation.\n\nThe bit `2` (\"properly paired\") remains set in the flag, as per the problem statement. A naive tool might filter out this read pair from a discordant analysis if it only selects pairs where bit `2` is *not* set. However, robust SV callers do not rely solely on the \"proper pair\" flag. They re-evaluate the pairing geometry (orientation, insert size) based on the fundamental flags (like $16$ and $32$) and mapping positions. Such a tool would identify this pair as discordant despite the presence of bit `2`, and flag it as evidence for an inversion.\n\n**Evaluation of Options**\n\n**A. The pair would likely be reinterpreted as a discordant \"inversion-like\" orientation (both reads on the reverse strand) and could produce a false positive structural variant signal near this locus.**\nThis statement is consistent with our derivation. The bit flip changes the orientation of read $1$ to reverse, resulting in an $\\text{RR}$ pair. This orientation is a canonical signature for an inversion. As the pair was originally normal, this leads to a false positive SV signal. This is a highly consequential change in biological interpretation. **Correct**.\n\n**B. The pair would still be considered a proper pair for all downstream tools because mapping positions and insert size are unchanged; orientation bits are ignored in practice.**\nThis statement is fundamentally incorrect. The orientation bits ($16$ and $32$) are critical for interpreting paired-end data and are absolutely not ignored by downstream tools. They are the primary indicators of read pair geometry, which is essential for SV detection, RNA-seq analysis, and other applications. An $\\text{RR}$ orientation is, by definition, not a proper pair for an $\\text{FR}$ library. **Incorrect**.\n\n**C. The change would only affect duplicate marking without influencing biological interpretation, since duplicate marking relies solely on mapping start positions and the CIGAR string.**\nThis statement is incorrect on two counts. First, duplicate marking algorithms (like Picard's) do use strand information to determine the correct 5' mapping coordinate for comparison, so the bit flip would affect it. More importantly, the claim that this *only* affects duplicate marking and has no influence on biological interpretation is patently false. As shown, the change creates a strong but spurious signal for a structural variant, which is a major influence on biological interpretation. **Incorrect**.\n\n**D. The read would be treated as unmapped and removed from analysis, eliminating any possibility of biological misinterpretation from this pair.**\nThis statement is incorrect. The bit flag for \"unmapped\" is bit $4$. The problem explicitly states that only bit $16$ was flipped. The bit $4$ was not set in the original flag ($99$) and is not set in the new flag ($115$). The read remains mapped. Therefore, it will be included in downstream analyses and is subject to misinterpretation. **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "2370643"}, {"introduction": "In real-world bioinformatics, data often needs to be transformed from one format to another to build an analysis pipeline. This advanced practice simulates just such a task, challenging you to convert raw alignment information into a valid SAM record. This exercise synthesizes your knowledge of bitwise FLAGs, CIGAR string generation, and coordinate systems, providing a practical, hands-on understanding of how aligners construct the records that are foundational to genomics [@problem_id:2370602].", "problem": "You are given a set of alignments originating from the Basic Local Alignment Search Tool (BLAST) in a tabular form that includes explicit, gapped pairwise alignment strings for the query and the reference, along with reference coordinates and strand. Your task is to convert each alignment into the fields of a Sequence Alignment/Map (SAM) record that are necessary to validate the alignment geometry: the bitwise FLAG, the leftmost reference position POS, and a compact CIGAR string. Because sequences and base qualities are not provided, they are not required in the output. The Binary Alignment/Map (BAM) uses a canonical integer coding for CIGAR operators; you must encode the generated CIGAR as a list of length–operator-code pairs using these codes.\n\nFormally, for each alignment record, you are given:\n- A query name string $qname$ and a reference name string $rname$.\n- A strand indicator $strand \\in \\{\"+\",\"-\"\\}$ for the query-to-reference orientation.\n- Reference start and end coordinates $r_{start}$ and $r_{end}$ that are $1$-based inclusive coordinates spanning exactly the number of reference symbols in the gapped alignment (that is, the number of non-gap characters in the reference alignment string), with $r_{start} \\le r_{end}$ when $strand = \"+\"$ and $r_{start} \\ge r_{end}$ when $strand = \"-\"$.\n- Two equal-length strings $aln\\_q$ and $aln\\_r$, composed only of the characters $\\{\"A\",\"C\",\"G\",\"T\",\"-\"\\}$, that describe the aligned query and reference with gap characters $\"-\"$ for insertions or deletions.\n\nYou must generate, for each alignment, the following SAM components:\n- The bitwise FLAG as an integer: use $0$ if $strand = \"+$\", and $16$ if $strand = \"-\"$. All other bits are unset because the alignments are single-end and mapped.\n- The POS field as the $1$-based leftmost reference coordinate of the alignment of the read to the reference. Define $L = \\min(r_{start}, r_{end})$. Construct the raw CIGAR by scanning $aln\\_q$ and $aln\\_r$ left-to-right and coalescing consecutive operations using only the operators $M$, $I$, and $D$ under the following rules:\n  - If $aln\\_q[i] \\neq \"-\"$ and $aln\\_r[i] \\neq \"-\"$, emit an $M$ of length $1$ (alignment match or mismatch; do not distinguish between match and mismatch).\n  - If $aln\\_q[i] = \"-\"$ and $aln\\_r[i] \\neq \"-\"$, emit a $D$ of length $1$ (deletion with respect to the query, consuming reference).\n  - If $aln\\_q[i] \\neq \"-\"$ and $aln\\_r[i] = \"-\"$, emit an $I$ of length $1$ (insertion with respect to the reference, consuming query).\n  - The case $aln\\_q[i] = \"-\"$ and $aln\\_r[i] = \"-\"$ does not occur.\n  - Coalesce adjacent identical operations into single runs with summed lengths.\n  After constructing this raw CIGAR run list, remove all leading and trailing $D$ runs, because valid SAM alignments must not start or end with a deletion. Let $d\\_{low}$ be the number of reference bases consumed by deletions adjacent to the leftmost genomic coordinate of the alignment before the first aligned query base. Compute $d\\_{low}$ as follows:\n  - If $strand = \"+\"$, then $d\\_{low}$ is the length of the leading $D$ run removed from the start (or $0$ if there was none).\n  - If $strand = \"-\"$, then $d\\_{low}$ is the length of the trailing $D$ run removed from the end (or $0$ if there was none).\n  Finally, set $POS = L + d\\_{low}$.\n- The CIGAR in run-length form, using only $M$, $I$, and $D$ after the above trimming. For output, encode this CIGAR using BAM operator codes: $M \\mapsto 0$, $I \\mapsto 1$, $D \\mapsto 2$. Represent the CIGAR as a list of pairs $[len,op]$ where $len$ is a positive integer and $op \\in \\{0,1,2\\}$.\n\nAssume the mapping quality is unavailable and would be reported in SAM as $MAPQ = 255$ if it were required. Because sequences and base qualities are not provided, $SEQ$ and $QUAL$ are not part of the required output. For mate fields, assume single-end data so that $RNEXT = \"*\"$, $PNEXT = 0$, $TLEN = 0$ in a full SAM line; these do not appear in the required output.\n\nYou must implement a program that, given the fixed test suite below embedded in the program, produces for each test case a list containing three elements: the integer FLAG, the integer POS, and the encoded CIGAR as a list of $[len,op]$ pairs using the above operator codes. Aggregate the results for all test cases into a single list and print it on one line as a comma-separated list enclosed in square brackets, with nested lists using the same bracketed format. No other text should be printed.\n\nTest suite (each test case is a tuple of fields in the order $(qname, rname, strand, r_{start}, r_{end}, aln\\_q, aln\\_r)$):\n- Case $1$ (forward strand with an insertion relative to the reference):\n  - $qname = \\text{\"read1\"}$, $rname = \\text{\"chr1\"}$, $strand = \\text{\"+\"}$, $r_{start} = 7$, $r_{end} = 11$, $aln\\_q = \\text{\"ACTGAC\"}$, $aln\\_r = \\text{\"ACT-AC\"}$.\n- Case $2$ (reverse strand with a deletion relative to the query):\n  - $qname = \\text{\"read2\"}$, $rname = \\text{\"chr2\"}$, $strand = \\text{\"-\"}$, $r_{start} = 100$, $r_{end} = 96$, $aln\\_q = \\text{\"A-CCT\"}$, $aln\\_r = \\text{\"AGCCT\"}$.\n- Case $3$ (forward strand with leading deletions and a trailing insertion):\n  - $qname = \\text{\"read3\"}$, $rname = \\text{\"chr3\"}$, $strand = \\text{\"+\"}$, $r_{start} = 1000$, $r_{end} = 1004$, $aln\\_q = \\text{\"--ACGT\"}$, $aln\\_r = \\text{\"TTACG-\"}$.\n- Case $4$ (reverse strand with trailing deletions at the low-coordinate end):\n  - $qname = \\text{\"read4\"}$, $rname = \\text{\"chr4\"}$, $strand = \\text{\"-\"}$, $r_{start} = 500$, $r_{end} = 495$, $aln\\_q = \\text{\"AC-T--\"}$, $aln\\_r = \\text{\"ACCTGG\"}$.\n- Case $5$ (forward strand with mismatches only, no gaps):\n  - $qname = \\text{\"read5\"}$, $rname = \\text{\"chr5\"}$, $strand = \\text{\"+\"}$, $r_{start} = 1$, $r_{end} = 3$, $aln\\_q = \\text{\"AGT\"}$, $aln\\_r = \\text{\"ACT\"}$.\n\nAngle units do not apply. No physical units are involved. All outputs are integers or lists of integers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[\\,[flag\\_1,POS\\_1,CIGAR\\_1],\\,[flag\\_2,POS\\_2,CIGAR\\_2],\\,\\dots\\,]$, where each $CIGAR\\_i$ is itself a list of $[len,op]$ pairs using the BAM operator codes $M \\mapsto 0$, $I \\mapsto 1$, $D \\mapsto 2$.", "solution": "The procedure to convert each given alignment record into the required SAM fields—the bitwise $FLAG$, the position $POS$, and the encoded $CIGAR$ string—is executed in three sequential stages.\n\nFirst, the bitwise $FLAG$ is determined. The SAM format specification uses bit flags to encode properties of an alignment. The bit representing strand is $0x10$, or $16$ in decimal. As per the problem description, if the alignment is to the forward strand ($strand = \\text{\"+\"}$), the $FLAG$ is set to $0$. If the alignment is to the reverse-complement strand ($strand = \\text{\"-\"}$), the $FLAG$ is set to $16$. Other flags related to pairing, quality, or supplementary status are not considered, consistent with the provided information.\n\nSecond, the $CIGAR$ string is constructed and encoded. The $CIGAR$ string provides a compact representation of the alignment structure. The process is as follows:\n$1$. The alignment strings $aln\\_q$ (query) and $aln\\_r$ (reference) are scanned character by character from left to right.\n$2$. For each position $i$, an operation is determined: an alignment match/mismatch ($M$) if $aln\\_q[i]$ and $aln\\_r[i]$ are both bases; a deletion from the reference ($D$) if $aln\\_q[i]$ is a gap ($\"-\"$); or an insertion into the reference ($I$) if $aln\\_r[i]$ is a gap ($\"-\"$). The case where both are gaps is proscribed.\n$3$. This sequence of single-character operations is then coalesced. Consecutive identical operations are merged into a single operation with a summed length. For example, a sequence of $M, M, M$ becomes $3M$. This results in a raw run-length encoded $CIGAR$.\n$4$. According to the problem specification, valid SAM alignments must not begin or end with a deletion ($D$). Therefore, any leading or trailing runs of $D$ operations are removed from the raw $CIGAR$. The lengths of these removed runs are recorded for the subsequent calculation of the $POS$ field.\n$5$. Finally, the trimmed $CIGAR$ string is converted into its binary representation as used in the BAM format. The operators $M$, $I$, and $D$ are mapped to the integer codes $0$, $1$, and $2$, respectively. The final $CIGAR$ is a list of pairs, each containing a length and an operator code, e.g., $[len, op]$.\n\nThird, the $POS$ field is calculated. The $POS$ field in SAM format specifies the $1$-based leftmost mapping position of the primary alignment. The calculation is critically dependent on the strand and any trimmed deletions.\n$1$. The leftmost genomic coordinate of the alignment span, $L$, is identified as $L = \\min(r_{start}, r_{end})$. Note that for a forward strand alignment, $L = r_{start}$, and for a reverse strand alignment, $L = r_{end}$.\n$2$. A crucial adjustment factor, $d_{low}$, must be computed. This factor accounts for reference bases that are part of the original alignment block but are trimmed from the final $CIGAR$ because they correspond to deletions at the start or end of the query sequence. The definition of $d_{low}$ depends on the strand:\n   - For a forward strand ($strand = \\text{\"+\"}$) alignment, the alignment's \"left\" side corresponds to the start of the CIGAR string and the low genomic coordinates. Thus, $d_{low}$ is the length of the leading $D$ run that was removed.\n   - For a reverse strand ($strand = \\text{\"-\"}$) alignment, the alignment's \"left\" side (in genomic coordinates) corresponds to the end of the query and thus the end of the CIGAR string. Therefore, $d_{low}$ is the length of the trailing $D$ run that was removed.\n$3$. The final $POS$ value is calculated as $POS = L + d_{low}$. This adjusts the starting position to account for the reference bases that were consumed by the trimmed deletions adjacent to the first aligned base of the query.\n\nAs a demonstrative example, let us apply this procedure to Test Case $3$:\n- Inputs: $strand = \\text{\"+\"}$, $r_{start} = 1000$, $r_{end} = 1004$, $aln\\_q = \\text{\"--ACGT\"}$, $aln\\_r = \\text{\"TTACG-\"}$.\n- $FLAG$: Since $strand = \\text{\"+\"}$, $FLAG = 0$.\n- CIGAR Generation:\n  - Scanning $aln\\_q$ and $aln\\_r$ yields the operation sequence $[D, D, M, M, M, I]$.\n  - Coalescing results in the raw $CIGAR$: $2D3M1I$.\n  - Trimming leading/trailing $D$ operations: The leading $2D$ is removed. The resulting $CIGAR$ is $3M1I$.\n  - The length of the removed leading $D$ run is $2$.\n  - Encoding $3M1I$ with codes $M \\mapsto 0, I \\mapsto 1$ gives $[[3, 0], [1, 1]]$.\n- POS Calculation:\n  - $L = \\min(1000, 1004) = 1000$.\n  - $strand$ is $\\text{\"+\"}$, so $d_{low}$ is the length of the leading $D$ run removed, which is $2$.\n  - $POS = L + d_{low} = 1000 + 2 = 1002$.\n- Final result for Case $3$: $[0, 1002, [[3, 0], [1, 1]]]$.\n\nThis rigorous, step-by-step process is applied to each test case to generate the final required output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are imported.\n\ndef solve():\n    \"\"\"\n    Solves the problem of converting BLAST-like alignments to SAM fields.\n    \"\"\"\n    \n    # Test suite provided in the problem statement.\n    test_cases = [\n        # Case 1 (forward strand with an insertion relative to the reference):\n        (\"read1\", \"chr1\", \"+\", 7, 11, \"ACTGAC\", \"ACT-AC\"),\n        # Case 2 (reverse strand with a deletion relative to the query):\n        (\"read2\", \"chr2\", \"-\", 100, 96, \"A-CCT\", \"AGCCT\"),\n        # Case 3 (forward strand with leading deletions and a trailing insertion):\n        (\"read3\", \"chr3\", \"+\", 1000, 1004, \"--ACGT\", \"TTACG-\"),\n        # Case 4 (reverse strand with trailing deletions at the low-coordinate end):\n        (\"read4\", \"chr4\", \"-\", 500, 495, \"AC-T--\", \"ACCTGG\"),\n        # Case 5 (forward strand with mismatches only, no gaps):\n        (\"read5\", \"chr5\", \"+\", 1, 3, \"AGT\", \"ACT\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the test case tuple for clarity.\n        qname, rname, strand, r_start, r_end, aln_q, aln_r = case\n\n        # 1. Determine the bitwise FLAG\n        flag = 16 if strand == \"-\" else 0\n\n        # 2. Generate the raw CIGAR string\n        op_map = {'M': 0, 'I': 1, 'D': 2}\n        raw_ops = []\n        for q_char, r_char in zip(aln_q, aln_r):\n            if q_char != '-' and r_char != '-':\n                raw_ops.append('M')  # Match or Mismatch\n            elif q_char != '-' and r_char == '-':\n                raw_ops.append('I')  # Insertion to reference\n            elif q_char == '-' and r_char != '-':\n                raw_ops.append('D')  # Deletion from reference\n        \n        # Coalesce adjacent identical operations\n        if not raw_ops:\n            raw_cigar_list = []\n        else:\n            raw_cigar_list = []\n            current_op = raw_ops[0]\n            current_len = 1\n            for op in raw_ops[1:]:\n                if op == current_op:\n                    current_len += 1\n                else:\n                    raw_cigar_list.append([current_len, current_op])\n                    current_op = op\n                    current_len = 1\n            raw_cigar_list.append([current_len, current_op])\n        \n        # 3. Trim CIGAR and calculate POS\n        \n        # Record lengths of leading/trailing deletions before trimming\n        d_leading = 0\n        if raw_cigar_list and raw_cigar_list[0][1] == 'D':\n            d_leading = raw_cigar_list[0][0]\n        \n        d_trailing = 0\n        if raw_cigar_list and len(raw_cigar_list) > 1 and raw_cigar_list[-1][1] == 'D':\n            d_trailing = raw_cigar_list[-1][0]\n        elif len(raw_cigar_list) == 1 and raw_cigar_list[0][1] == 'D':\n            d_trailing = raw_cigar_list[0][0]\n\n        # Trim leading 'D'\n        trimmed_cigar = list(raw_cigar_list) # Make a copy\n        if trimmed_cigar and trimmed_cigar[0][1] == 'D':\n            trimmed_cigar.pop(0)\n            \n        # Trim trailing 'D'\n        if trimmed_cigar and trimmed_cigar[-1][1] == 'D':\n            trimmed_cigar.pop(-1)\n\n        # Calculate d_low based on strand\n        d_low = 0\n        if strand == '+':\n            d_low = d_leading\n        elif strand == '-':\n            # For reverse strand, trailing deletions in the alignment string\n            # correspond to the low-coordinate end of the reference alignment.\n            d_low = d_trailing\n            \n        # Calculate the leftmost genomic coordinate L\n        L = min(r_start, r_end)\n        \n        # Final POS calculation\n        pos = L + d_low\n        \n        # 4. Encode the final CIGAR using BAM operator codes\n        encoded_cigar = [[length, op_map[op]] for length, op in trimmed_cigar]\n        \n        results.append([flag, pos, encoded_cigar])\n\n    # Final print statement in the exact required format.\n    # The default str() representation of lists includes spaces. Removing them\n    # to match the required output format exactly.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2370602"}]}