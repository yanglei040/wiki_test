{"hands_on_practices": [{"introduction": "Understanding a phylogenetic tree begins with mastering its fundamental components and the relationships between them. This exercise challenges you to apply the core definitions of ancestry and clades to a clearly defined tree structure. By tracing paths from the leaves to the root, you will practice identifying the Most Recent Common Ancestor (MRCA) of a group and use this to determine a clade's depth, strengthening your foundational understanding of tree navigation. [@problem_id:2414815]", "problem": "In computational biology and bioinformatics, consider a rooted phylogenetic tree with root node $r$ and the following parent-child relationships (each edge points from a parent to its children):\n- $r$ has children $u$ and $v$.\n- $u$ has children $w$ and $x$.\n- $w$ has children $A$ and $B$.\n- $x$ has child $C$.\n- $v$ has children $y$ and $z$.\n- $y$ has children $D$ and $E$.\n- $z$ has children $F$ and $G$.\n\nAll leaves $A$ through $G$ represent extant taxa. A clade is defined as a set consisting of a single ancestor and all of its descendants. The Most Recent Common Ancestor (MRCA) is the unique lowest (i.e., farthest from the root) node that is an ancestor of every taxon in a given set.\n\nFor a rooted tree, define the depth of a clade as the number of nodes on the simple path from the root to the clade’s Most Recent Common Ancestor (MRCA), counting both the root and the MRCA.\n\nCompute the depth of the clade consisting of the taxa $\\{A, B\\}$. Provide your answer as a single integer. No rounding is necessary.", "solution": "The problem statement is accepted as valid. It is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution.\n\nThe problem requires the computation of the depth of a specific clade within a given rooted phylogenetic tree. We shall proceed by first reconstructing the tree structure, then identifying the Most Recent Common Ancestor (MRCA) of the specified taxa, and finally calculating the depth as defined.\n\nFirst, we construct the tree based on the provided parent-child relationships. The root is node $r$.\n- $r$ is the parent of $u$ and $v$.\n- $u$ is the parent of $w$ and $x$.\n- $v$ is the parent of $y$ and $z$.\n- $w$ is the parent of the leaves $A$ and $B$.\n- $x$ is the parent of the leaf $C$.\n- $y$ is the parent of the leaves $D$ and $E$.\n- $z$ is the parent of the leaves $F$ and $G$.\n\nThe resulting tree structure can be systematically outlined with nodes arranged by their level (distance from the root, starting at level $0$):\n- Level $0$: $r$\n- Level $1$: $u, v$\n- Level $2$: $w, x, y, z$\n- Level $3$: $A, B, C, D, E, F, G$\n\nThe question asks for the depth of the clade consisting of the taxa $\\{A, B\\}$. The problem defines the depth of a clade as \"the number of nodes on the simple path from the root to the clade’s Most Recent Common Ancestor (MRCA), counting both the root and the MRCA.\" Therefore, our first step is to identify the MRCA of the taxa $A$ and $B$.\n\nThe set of ancestors for taxon $A$ is the set of all nodes on the path from $A$ to the root $r$. This path is $A \\leftarrow w \\leftarrow u \\leftarrow r$. The ancestors of $A$ are $\\{w, u, r\\}$.\nThe set of ancestors for taxon $B$ is the set of all nodes on the path from $B$ to the root $r$. This path is $B \\leftarrow w \\leftarrow u \\leftarrow r$. The ancestors of $B$ are $\\{w, u, r\\}$.\n\nThe set of common ancestors of $A$ and $B$ is the intersection of their respective ancestor sets: $\\{w, u, r\\} \\cap \\{w, u, r\\} = \\{w, u, r\\}$.\n\nThe MRCA is defined as the unique lowest (i.e., farthest from the root) node among the common ancestors. The path from the root to the leaves $A$ and $B$ originates at $r$ and diverges from other paths at subsequent nodes. Specifically, the path is $r \\rightarrow u \\rightarrow w$. Among the common ancestors $\\{w, u, r\\}$, the node $w$ is the farthest from the root $r$. Thus, the MRCA of taxa $\\{A, B\\}$ is the node $w$.\n\nThe problem now reduces to calculating the depth to this MRCA, $w$. According to the given definition, the depth is the number of nodes on the simple path from the root $r$ to the MRCA $w$.\n\nThe simple path from the root $r$ to the MRCA $w$ is the sequence of nodes $(r, u, w)$.\nWe must count the number of nodes in this path. The nodes are $r$, $u$, and $w$.\nThe total number of nodes is $3$.\n\nTherefore, the depth of the clade consisting of taxa $\\{A, B\\}$ is $3$.", "answer": "$$\\boxed{3}$$", "id": "2414815"}, {"introduction": "Moving from conceptual understanding to practical application is a key step in bioinformatics. This problem asks you to translate the definition of a clade into a working algorithm. You will design a procedure to first find the Most Recent Common Ancestor (MRCA) of a specified set of leaves and then identify the complete clade that descends from it, a common and essential task in comparative genomic analyses. [@problem_id:2414840]", "problem": "You are given the foundational definitions for rooted phylogenetic trees. A rooted tree is a connected, directed acyclic graph with a distinguished root node such that there is exactly one directed path from the root to any node. A node is an element of the graph; a branch is a directed edge from a parent node to a child node. A leaf is a node with no children. A clade is the set of all leaves that descend from a single internal node. For three specified leaves $L_1$, $L_2$, and $L_3$ in a rooted tree, the smallest clade containing them is the smallest (by set inclusion) clade that contains all three leaves.\n\nStarting from the fundamental definitions above (rooted trees, ancestor relations, leaves, and clades), derive an algorithm that, given a rooted tree and three distinct leaves $L_1$, $L_2$, and $L_3$, computes the smallest clade that contains all three leaves. Express the smallest clade as the set of all leaf labels that descend from the most recent common ancestor of $L_1$, $L_2$, and $L_3$.\n\nYour program must implement this logic for a fixed test suite. Each test case specifies:\n- A finite set of directed edges $(u, v)$ indicating that $u$ is the parent of $v$.\n- A distinguished root node $r$.\n- A tuple of three distinct leaf labels $(L_1, L_2, L_3)$.\n\nAssume all inputs form a valid rooted tree: there are no cycles, every node except the root has exactly one parent, and there is exactly one path from the root to each node. Leaves are exactly those nodes with out-degree $0$. The smallest clade for the given three leaves is defined as the set of all leaves in the subtree rooted at the most recent common ancestor of $L_1$, $L_2$, and $L_3$.\n\nTest suite:\n- Case $1$:\n  - Edges: [('A','B'),('A','C'),('B','D'),('B','E'),('C','F'),('C','G')]\n  - Root: 'A'\n  - $(L_1,L_2,L_3)$: ('D','E','F')\n- Case $2$:\n  - Edges: [('R','X'),('R','Y'),('X','L1'),('X','Z'),('Z','L2'),('Z','L3'),('Y','W'),('W','L4')]\n  - Root: 'R'\n  - $(L_1,L_2,L_3)$: ('L1','L2','L3')\n- Case $3$:\n  - Edges: [('R','A'),('R','B'),('R','C'),('A','D'),('A','E'),('B','F'),('C','G'),('C','H')]\n  - Root: 'R'\n  - $(L_1,L_2,L_3)$: ('D','F','G')\n- Case $4$:\n  - Edges: [('R','A'),('R','B'),('A','C'),('A','D'),('A','E')]\n  - Root: 'R'\n  - $(L_1,L_2,L_3)$: ('C','D','E')\n\nRequirements:\n- For each case, compute the smallest clade that contains $L_1$, $L_2$, and $L_3$, and output the list of leaf labels in that clade, sorted lexicographically.\n- The final output format must be a single line containing a comma-separated list of the results for all cases, enclosed in a single pair of square brackets. Each case’s result must itself be a list of strings of leaf labels enclosed in square brackets, with each label enclosed in single quotes, with no whitespace after commas. For example, a valid overall output for two cases would be: [['a','b'],['c']].\n- Each test case’s result must be a list of strings. No physical units, angles, or percentages are involved in this problem.\n\nYour program should produce exactly one line of output containing the results for the four cases in the order $1$, $2$, $3$, $4$, as described above. The output must be a single line of the form [['...','...'],['...'],['...'],['...',...]] with no extra spaces after commas.", "solution": "The problem statement has been subjected to rigorous validation and is found to be valid. It is scientifically grounded, well-posed, and objective. It provides a formal system of definitions for a rooted phylogenetic tree and requests the derivation of an algorithm to compute the smallest clade containing three specified leaves. The problem is self-contained and free of contradictions or ambiguities. I shall now provide a complete, reasoned solution.\n\nThe problem requires us to find the \"smallest clade\" containing three distinct leaves, $L_1$, $L_2$, and $L_3$. This concept is precisely defined as the set of all leaves in the subtree rooted at the Most Recent Common Ancestor (MRCA) of these three leaves. The solution, therefore, consists of two primary algorithmic steps: first, identifying the MRCA of $L_1$, $L_2$, and $L_3$; second, enumerating all leaves that are descendants of this MRCA.\n\nLet the rooted tree be represented as a directed graph $G = (V, E)$, where $V$ is the set of nodes and $E$ is the set of directed edges (branches). An edge $(u, v) \\in E$ signifies that node $u$ is the parent of node $v$. The structure is a valid rooted tree with a specified root $r \\in V$. Each node $n \\in V$, except for the root $r$, has exactly one parent.\n\nThe set of ancestors of a node $n$, denoted $Ancestors(n)$, is the set of all nodes on the unique directed path from $n$ to the root $r$, inclusive of $n$ and $r$. The Most Recent Common Ancestor of two nodes, $n_1$ and $n_2$, is the unique node $a \\in V$ such that $a \\in Ancestors(n_1) \\cap Ancestors(n_2)$ and $a$ has the greatest depth in the tree (i.e., it is the 'lowest' common ancestor). Formally, for any other common ancestor $a'$, $a'$ must also be an ancestor of $a$. This is denoted as $a = MRCA(n_1, n_2)$.\n\nThe MRCA operation is associative. Therefore, the MRCA of three leaves $L_1$, $L_2$, and $L_3$ can be computed iteratively:\n$$A_{MRCA} = MRCA(L_1, L_2, L_3) = MRCA(MRCA(L_1, L_2), L_3)$$\nThe order of operations is irrelevant. Once we identify this node $A_{MRCA}$, the problem is reduced to finding all leaves in the subtree rooted at $A_{MRCA}$. A leaf is defined as a node with an out-degree of $0$.\n\nThe algorithm proceeds as follows for each test case:\n\nStep $1$: Tree Representation. The input edge list is processed to build two data structures for efficient traversal. First, a parent map, which is a dictionary mapping each child node to its unique parent. This allows for efficient upward traversal from any node towards the root. Second, an adjacency list, which is a dictionary mapping each parent node to a list of its children. This enables efficient downward traversal into subtrees.\n\nStep $2$: MRCA Computation. We implement a function to find the MRCA of two nodes, say $n_1$ and $n_2$. This function first traces the path from $n_1$ to the root $r$ using the parent map, storing all visited ancestors in a set for constant-time lookup. Then, it traces the path from $n_2$ towards the root. The first node encountered on this second path that is also present in the set of $n_1$'s ancestors is, by definition, the $MRCA(n_1, n_2)$. To find the MRCA for the three given leaves, we apply this function twice. First, we compute $A_{12} = MRCA(L_1, L_2)$, and then we compute the final MRCA as $A_{123} = MRCA(A_{12}, L_3)$.\n\nStep $3$: Leaf Enumeration. With the final MRCA, $A_{123}$, identified, we must find all leaves within its descendant subtree. A traversal algorithm, such as Breadth-First Search (BFS) or Depth-First Search (DFS), is initiated from $A_{123}$. We use the adjacency list to explore the subtree. During the traversal, we inspect each visited node. If a node has no children (i.e., it is not a key in the adjacency list), it satisfies the definition of a leaf. All such leaf nodes encountered during the traversal are collected into a set.\n\nStep $4$: Output Formatting. The collected set of leaf labels is converted to a list and sorted lexicographically, as required by the problem specification. This process is repeated for all test cases, and the final results are aggregated and formatted into the precise single-line string format.\n\nThis structured, principle-based approach guarantees a correct and verifiable solution by directly implementing the formal definitions of phylogenetic tree concepts provided in the problem statement. The use of appropriate data structures ensures algorithmic efficiency.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the phylogenetic tree problem for a fixed test suite.\n    The main logic to derive the smallest clade containing three leaves is encapsulated here.\n    \"\"\"\n    test_cases = [\n        {\n            \"edges\": [('A','B'),('A','C'),('B','D'),('B','E'),('C','F'),('C','G')],\n            \"root\": 'A',\n            \"leaves\": ('D','E','F')\n        },\n        {\n            \"edges\": [('R','X'),('R','Y'),('X','L1'),('X','Z'),('Z','L2'),('Z','L3'),('Y','W'),('W','L4')],\n            \"root\": 'R',\n            \"leaves\": ('L1','L2','L3')\n        },\n        {\n            \"edges\": [('R','A'),('R','B'),('R','C'),('A','D'),('A','E'),('B','F'),('C','G'),('C','H')],\n            \"root\": 'R',\n            \"leaves\": ('D','F','G')\n        },\n        {\n            \"edges\": [('R','A'),('R','B'),('A','C'),('A','D'),('A','E')],\n            \"root\": 'R',\n            \"leaves\": ('C','D','E')\n        }\n    ]\n\n    def process_case(edges, root, target_leaves):\n        \"\"\"\n        Processes a single test case to find the smallest clade for three leaves.\n\n        Args:\n            edges (list): A list of tuples (parent, child).\n            root (str): The label of the root node.\n            target_leaves (tuple): A tuple of three leaf labels.\n\n        Returns:\n            list: A lexicographically sorted list of leaf labels in the smallest clade.\n        \"\"\"\n        parent_map = {child: parent for parent, child in edges}\n        adj_list = {}\n        for parent, child in edges:\n            if parent not in adj_list:\n                adj_list[parent] = []\n            adj_list[parent].append(child)\n\n        def get_mrca(node1, node2):\n            \"\"\"Finds the Most Recent Common Ancestor of two nodes.\"\"\"\n            ancestors_n1 = set()\n            curr = node1\n            while curr in parent_map:\n                ancestors_n1.add(curr)\n                curr = parent_map[curr]\n            ancestors_n1.add(root)\n\n            curr = node2\n            while curr not in ancestors_n1:\n                curr = parent_map[curr]\n            return curr\n\n        # Find the MRCA for the three target leaves\n        l1, l2, l3 = target_leaves\n        mrca_12 = get_mrca(l1, l2)\n        mrca_123 = get_mrca(mrca_12, l3)\n        \n        def get_leaves_in_subtree(start_node):\n            \"\"\"Finds all leaves in the subtree of a given node using BFS.\"\"\"\n            leaves_in_clade = []\n            queue = [start_node]\n            visited = {start_node}\n            \n            while queue:\n                node = queue.pop(0)\n                \n                # Check if it is a leaf (has no children in this tree)\n                if node not in adj_list:\n                    leaves_in_clade.append(node)\n                else:\n                    for child in adj_list[node]:\n                        if child not in visited:\n                            visited.add(child)\n                            queue.append(child)\n            return leaves_in_clade\n\n        clade_leaves = get_leaves_in_subtree(mrca_123)\n        clade_leaves.sort()\n        return clade_leaves\n\n    results = []\n    for case in test_cases:\n        result = process_case(case[\"edges\"], case[\"root\"], case[\"leaves\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is converted to a string\n    # and all spaces are removed to meet the strict output format requirement.\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\nsolve()\n```", "id": "2414840"}, {"introduction": "Phylogenetic trees are powerful tools for testing hypotheses about character evolution. This advanced exercise requires you to synthesize your understanding of tree topology with the principle of maximum parsimony to interpret the evolutionary history of a trait. By mapping character state changes onto the tree, you will determine whether a group of taxa is monophyletic, paraphyletic, or polyphyletic, confronting the real-world complexities and potential ambiguities of evolutionary reconstruction. [@problem_id:2591308]", "problem": "A rooted phylogenetic tree on five terminal taxa is given by the fully parenthesized representation $(((A,B),(C,D)),E)$, with $E$ as the outgroup. Consider a single, unordered, binary morphological character with observed tip states: $A=1$, $B=1$, $C=1$, $D=0$, $E=0$. Using outgroup polarization, the principle of Maximum Parsimony (MP), and the definitions of monophyly, paraphyly, and polyphyly grounded in the Most Recent Common Ancestor (MRCA), determine which classificatory statement about the set of taxa with state $1$ is best supported by the tree and character mapping.\n\nBase concepts to use:\n- A monophyletic group (clade) is a set of taxa that includes a common ancestor and all of its descendants.\n- A paraphyletic group includes a common ancestor and some, but not all, of its descendants.\n- A polyphyletic group is assembled from taxa whose most recent common ancestor is not itself included in the group defined by the character state, typically requiring multiple independent origins of the defining state.\n- Under Maximum Parsimony, the preferred character mapping minimizes the total number of state changes on the tree, with gains and losses of equal cost unless otherwise specified, and outgroup rooting polarizes the ancestral state at the root.\n\nWhich option is best supported?\n\nA. The set $\\{A,B,C\\}$ is monophyletic on the given rooted tree.\n\nB. The set $\\{A,B,C\\}$ is paraphyletic under all equally parsimonious reconstructions.\n\nC. The set $\\{A,B,C\\}$ is polyphyletic under all equally parsimonious reconstructions.\n\nD. The set $\\{A,B,C\\}$ is non-monophyletic; both paraphyly and polyphyly are possible under equally parsimonious mappings with a minimum of $2$ changes.", "solution": "The problem statement will be validated before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Tree Topology**: A rooted phylogenetic tree on five terminal taxa given by the Newick format $(((A,B),(C,D)),E)$.\n- **Outgroup**: Taxon $E$ is the designated outgroup.\n- **Character Data**: A single, unordered, binary morphological character with the following observed states at the tips: $S(A)=1$, $S(B)=1$, $S(C)=1$, $S(D)=0$, $S(E)=0$.\n- **Group of Interest**: The set of taxa with state $1$, which is $\\{A,B,C\\}$.\n- **Methodology**: Maximum Parsimony (MP), with outgroup polarization used to infer the root state.\n- **Definitions**:\n    - **Monophyletic**: Includes a common ancestor and all of its descendants.\n    - **Paraphyletic**: Includes a common ancestor and some, but not all, of its descendants.\n    - **Polyphyletic**: The Most Recent Common Ancestor (MRCA) of the group's members does not possess the defining character state, implying multiple independent origins.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is well-grounded in the principles of phylogenetic systematics, a core discipline in comparative biology. The concepts of phylogenetic trees, character mapping, maximum parsimony, and the classification of groups (monophyly, paraphyly, polyphyly) are standard and accurately represented.\n- **Well-Posedness**: The problem is well-posed. The tree topology is unambiguous, character states are explicitly provided, the analytical method (MP with outgroup polarization) is specified, and the question is precise. This setup ensures that a unique and logical solution can be derived.\n- **Objectivity**: The problem statement is objective and devoid of subjective or ambiguous language.\n\n### Step 3: Verdict and Action\nThe problem is scientifically sound, self-contained, and well-posed. It is valid. A solution will now be derived.\n\n### Derivation of Solution\nThe task is to determine the phylogenetic status (monophyletic, paraphyletic, or polyphyletic) of the set of taxa possessing character state $1$, which is the set $\\{A,B,C\\}$. This requires mapping the character evolution onto the provided tree topology under the principle of Maximum Parsimony.\n\nThe tree topology $(((A,B),(C,D)),E)$ can be visualized. Let us denote the internal nodes (ancestors) as follows:\n- $v_{AB} = \\text{MRCA}(A, B)$\n- $v_{CD} = \\text{MRCA}(C, D)$\n- $v_{ABCD} = \\text{MRCA}(A, B, C, D)$\n- $v_{Root} = \\text{MRCA}(A, B, C, D, E)$\n\nThe character states are $S(A)=1$, $S(B)=1$, $S(C)=1$, $S(D)=0$, $S(E)=0$.\n\n**1. Determine the Parsimony Score**\nWe use the Fitch algorithm (or equivalent logic) to find the minimum number of state changes (the parsimony score, $L$).\nThe bottom-up pass assigns a set of possible states to each internal node:\n- For $v_{AB}$, children have states $\\{1\\}$ and $\\{1\\}$. Intersection is $\\{1\\}$. State set is $\\{1\\}$.\n- For $v_{CD}$, children have states $\\{1\\}$ and $\\{0\\}$. Intersection is empty. Union is $\\{0,1\\}$. State set is $\\{0,1\\}$. This step adds $1$ to the score.\n- For $v_{ABCD}$, children are $v_{AB}$ with state set $\\{1\\}$ and $v_{CD}$ with state set $\\{0,1\\}$. Intersection is $\\{1\\}$. State set is $\\{1\\}$.\n- For $v_{Root}$, children are $v_{ABCD}$ with state set $\\{1\\}$ and $E$ with state set $\\{0\\}$. Intersection is empty. Union is $\\{0,1\\}$. State set is $\\{0,1\\}$. This step adds $1$ to the score.\n\nThe total minimum number of changes (parsimony score) is $L = 1 + 1 = 2$.\n\n**2. Reconstruct Ancestral States for all Most Parsimonious Reconstructions (MPRs)**\nWe need to find all assignments of states to internal nodes that result in exactly $2$ changes. The problem mandates \"outgroup polarization,\" which means the state of the outgroup, $S(E)=0$, determines the state at the root. Thus, we must set $S(v_{Root})=0$.\n\nWe now analyze the possible state assignments for the other internal nodes that are consistent with $S(v_{Root})=0$ and $L=2$.\n\n**Scenario 1: The \"Paraphyly\" Reconstruction (DELTRAN-like optimization)**\nThis scenario posits a single origin of state $1$ followed by a reversal.\n- $S(v_{Root}) = 0$.\n- For state $1$ to appear in the ingroup $\\{A,B,C,D\\}$, it must originate on the branch leading to $v_{ABCD}$. So, $S(v_{ABCD})=1$. This is change #1: $0 \\to 1$.\n- For the clade $(A,B)$, with $S(A)=1$ and $S(B)=1$, the most parsimonious assignment for their ancestor is $S(v_{AB})=1$. This involves no additional changes from its parent $v_{ABCD}$.\n- For the clade $(C,D)$, with parent $v_{ABCD}$ having state $1$, we consider $v_{CD}$. To satisfy the states of its children $S(C)=1$ and $S(D)=0$, we can set $S(v_{CD})=1$. This involves no change from its parent $v_{ABCD}$. The state $0$ in taxon $D$ must then be explained by a reversal on the terminal branch leading to $D$. This is change #2: $1 \\to 0$.\n- **Summary of MPR 1**: A single gain of state $1$ on the branch leading to $v_{ABCD}$, and a single loss (reversal) of state $1$ on the branch leading to $D$. The total number of changes is $2$.\n- **Interpretation**: The MRCA of the group $\\{A,B,C\\}$ is $v_{ABCD}$. In this reconstruction, $S(v_{ABCD})=1$. The group $\\{A,B,C\\}$ is formed from an ancestor with state $1$ ($v_{ABCD}$), but excludes one of that ancestor's descendants ($D$), which lost the character. This is the definition of a **paraphyletic** group.\n\n**Scenario 2: The \"Polyphyly\" Reconstruction (ACCTRAN-like optimization)**\nThis scenario posits multiple independent origins of state $1$.\n- $S(v_{Root}) = 0$.\n- Let us assume state $1$ does not arise on the branch leading to $v_{ABCD}$. We set $S(v_{ABCD})=0$. This involves no change from the root.\n- To explain $S(A)=1$ and $S(B)=1$, state $1$ must originate on the branch leading to their ancestor, $v_{AB}$. So, $S(v_{AB})=1$. This is change #1: $0 \\to 1$ on the branch $v_{ABCD} \\to v_{AB}$.\n- For clade $(C,D)$, its parent $v_{ABCD}$ has state $0$. We can set $S(v_{CD})=0$ to match its child $D$ and its parent. This involves no change.\n- To explain $S(C)=1$, state $1$ must originate independently on the terminal branch leading to $C$. This is change #2: $0 \\to 1$ on the branch $v_{CD} \\to C$.\n- **Summary of MPR 2**: Two independent gains (parallelisms) of state $1$: one on the branch to $v_{AB}$ and one on the branch to $C$. The total number of changes is $2$.\n- **Interpretation**: The MRCA of the group $\\{A,B,C\\}$ is $v_{ABCD}$. In this reconstruction, $S(v_{ABCD})=0$. The defining character state ($1$) is absent in the group's most recent common ancestor. The group is defined by a trait that evolved convergently. This is the definition of a **polyphyletic** group.\n\n**Conclusion of Analysis**\nThere are two equally parsimonious reconstructions, each requiring a minimum of $2$ changes. One reconstruction implies the group $\\{A,B,C\\}$ is paraphyletic. The other implies the group $\\{A,B,C\\}$ is polyphyletic. In neither case is the group monophyletic, as the full clade descended from $v_{ABCD}$ is $\\{A,B,C,D\\}$. Therefore, the phylogenetic status of the group $\\{A,B,C\\}$ is ambiguous under maximum parsimony.\n\n### Evaluation of Options\n\n**A. The set $\\{A,B,C\\}$ is monophyletic on the given rooted tree.**\nThis is incorrect. The Most Recent Common Ancestor of $\\{A,B,C\\}$ is $v_{ABCD}$, whose complete set of descendants is $\\{A,B,C,D\\}$. The group $\\{A,B,C\\}$ excludes taxon $D$, thus it is not monophyletic.\n\n**B. The set $\\{A,B,C\\}$ is paraphyletic under all equally parsimonious reconstructions.**\nThis is incorrect. While one MPR supports paraphyly, there exists another equally parsimonious reconstruction (MPR 2) that supports polyphyly. The statement \"under all\" is false.\n\n**C. The set $\\{A,B,C\\}$ is polyphyletic under all equally parsimonious reconstructions.**\nThis is incorrect. While one MPR supports polyphyly, there exists another equally parsimonious reconstruction (MPR 1) that supports paraphyly. The statement \"under all\" is false.\n\n**D. The set $\\{A,B,C\\}$ is non-monophyletic; both paraphyly and polyphyly are possible under equally parsimonious mappings with a minimum of $2$ changes.**\nThis statement is fully consistent with our analysis.\n- The set is indeed non-monophyletic.\n- There are two equally parsimonious scenarios (MPRs), one implying paraphyly and the other polyphyly.\n- The minimum number of changes is correctly stated as $2$.\nThis option is the most accurate and complete description of the situation.", "answer": "$$\\boxed{D}$$", "id": "2591308"}]}