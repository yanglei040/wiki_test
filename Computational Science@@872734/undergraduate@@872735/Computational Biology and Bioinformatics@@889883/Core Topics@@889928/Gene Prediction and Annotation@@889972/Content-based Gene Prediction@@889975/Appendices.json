{"hands_on_practices": [{"introduction": "The Codon Adaptation Index (CAI) is a widely used measure that quantifies the extent to which a gene's codon usage resembles that of highly expressed genes in a reference organism. This hands-on problem [@problem_id:2381997] asks you to calculate the possible range of CAI values for a short DNA sequence containing ambiguous nucleotides. By determining the minimum and maximum possible scores, you will develop a practical intuition for how individual codon choices contribute to the overall CAI and how sequence uncertainty can affect gene-level analysis.", "problem": "A genomic fragment in a fixed reading frame is analyzed for codon usage bias using the Codon Adaptation Index (CAI). By definition, for a coding sequence of length $L$ codons in a fixed reading frame, the CAI is the geometric mean of the relative adaptiveness weights $w_{c}$ of its codons:\n$$\\mathrm{CAI}=\\left(\\prod_{i=1}^{L} w_{c_i}\\right)^{1/L}.$$\nEach $w_{c}$ is a dimensionless relative adaptiveness weight in the interval $(0,1]$ defined with respect to a fixed reference set. Consider the DNA sequence (frame starting at the first base):\n`ATGGCNCGNTTNCCN`\nwhere the ambiguous character $\\mathrm{N}$ denotes any nucleotide in $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$, independently at each position. The reading frame partitions this sequence into $L=5$ codons: $\\mathrm{ATG}$, $\\mathrm{GCN}$, $\\mathrm{CGN}$, $\\mathrm{TTN}$, $\\mathrm{CCN}$. By construction, none of the possible codons generated by these ambiguous positions is a stop codon in this frame.\n\nThe relative adaptiveness weights $w_{c}$ for all codons that can appear in this frame are given by:\n- $w(\\mathrm{ATG})=1$.\n- For $\\mathrm{GCN}$: $w(\\mathrm{GCA})=0.2$, $w(\\mathrm{GCC})=1$, $w(\\mathrm{GCG})=0.7$, $w(\\mathrm{GCT})=0.4$.\n- For $\\mathrm{CGN}$: $w(\\mathrm{CGA})=0.1$, $w(\\mathrm{CGC})=1$, $w(\\mathrm{CGG})=0.8$, $w(\\mathrm{CGT})=0.6$.\n- For $\\mathrm{TTN}$: $w(\\mathrm{TTA})=0.05$, $w(\\mathrm{TTC})=1$, $w(\\mathrm{TTG})=0.1$, $w(\\mathrm{TTT})=0.5$.\n- For $\\mathrm{CCN}$: $w(\\mathrm{CCA})=0.3$, $w(\\mathrm{CCC})=1$, $w(\\mathrm{CCG})=0.9$, $w(\\mathrm{CCT})=0.6$.\n\nOver all possible assignments of $\\mathrm{N}$ to nucleotides that respect the fixed reading frame, determine the minimum and maximum possible CAI values for this sequence. Report your answers as the ordered pair (minimum, maximum). Round your answers to four significant figures. The CAI is dimensionless; do not include units.", "solution": "The Codon Adaptation Index (CAI) for a coding sequence of length $L$ codons is defined as the geometric mean of the relative adaptiveness weights $w_{c_i}$ of its constituent codons:\n$$ \\mathrm{CAI} = \\left(\\prod_{i=1}^{L} w_{c_i}\\right)^{1/L} $$\nThe given DNA sequence is `ATGGCNCGNTTNCCN`. With the reading frame starting at the first base, the sequence is partitioned into $L=5$ codons:\n$c_1 = \\mathrm{ATG}$, $c_2 = \\mathrm{GCN}$, $c_3 = \\mathrm{CGN}$, $c_4 = \\mathrm{TTN}$, $c_5 = \\mathrm{CCN}$.\n\nThe weight of the first codon is given as $w(\\mathrm{ATG})=1$. This is a constant factor. The subsequent codons contain the ambiguous nucleotide $\\mathrm{N}$, which can be any of $\\mathrm{A}$, $\\mathrm{C}$, $\\mathrm{G}$, or $\\mathrm{T}$. The choices for $\\mathrm{N}$ at each ambiguous position are independent.\nThe expression for the CAI is therefore:\n$$ \\mathrm{CAI} = \\left( w(\\mathrm{ATG}) \\cdot w(\\mathrm{GCN}) \\cdot w(\\mathrm{CGN}) \\cdot w(\\mathrm{TTN}) \\cdot w(\\mathrm{CCN}) \\right)^{1/5} $$\n$$ \\mathrm{CAI} = \\left( 1 \\cdot w(\\mathrm{GCN}) \\cdot w(\\mathrm{CGN}) \\cdot w(\\mathrm{TTN}) \\cdot w(\\mathrm{CCN}) \\right)^{1/5} $$\nThe function $f(x) = x^{1/5}$ is a strictly increasing function for positive arguments $x$. Since all given weights $w_c$ are in the interval $(0, 1]$, their product will also be a positive number. Consequently, to find the minimum and maximum possible values of the CAI, we must find the minimum and maximum of the product of the weights $\\prod_{i=1}^{5} w_{c_i}$.\nDue to the independence of the nucleotide choice for each `N`, the total product is maximized by choosing the sequence of codons that maximizes each individual weight, and minimized by choosing the sequence that minimizes each individual weight.\n\nFirst, let us determine the maximum possible CAI. This requires us to select the nucleotide for each `N` such that the corresponding codon weight is maximal. We examine the weights provided for each ambiguous codon family:\n- For $c_2 = \\mathrm{GCN}$: The available weights are $w(\\mathrm{GCA})=0.2$, $w(\\mathrm{GCC})=1$, $w(\\mathrm{GCG})=0.7$, and $w(\\mathrm{GCT})=0.4$. The maximum weight is $w_{\\max}(\\mathrm{GCN}) = 1$.\n- For $c_3 = \\mathrm{CGN}$: The available weights are $w(\\mathrm{CGA})=0.1$, $w(\\mathrm{CGC})=1$, $w(\\mathrm{CGG})=0.8$, and $w(\\mathrm{CGT})=0.6$. The maximum weight is $w_{\\max}(\\mathrm{CGN}) = 1$.\n- For $c_4 = \\mathrm{TTN}$: The available weights are $w(\\mathrm{TTA})=0.05$, $w(\\mathrm{TTC})=1$, $w(\\mathrm{TTG})=0.1$, and $w(\\mathrm{TTT})=0.5$. The maximum weight is $w_{\\max}(\\mathrm{TTN}) = 1$.\n- For $c_5 = \\mathrm{CCN}$: The available weights are $w(\\mathrm{CCA})=0.3$, $w(\\mathrm{CCC})=1$, $w(\\mathrm{CCG})=0.9$, and $w(\\mathrm{CCT})=0.6$. The maximum weight is $w_{\\max}(\\mathrm{CCN}) = 1$.\n\nThe product of the maximum possible weights is:\n$$ P_{\\max} = w(\\mathrm{ATG}) \\cdot w_{\\max}(\\mathrm{GCN}) \\cdot w_{\\max}(\\mathrm{CGN}) \\cdot w_{\\max}(\\mathrm{TTN}) \\cdot w_{\\max}(\\mathrm{CCN}) $$\n$$ P_{\\max} = 1 \\cdot 1 \\cdot 1 \\cdot 1 \\cdot 1 = 1 $$\nThe maximum CAI is the fifth root of this product:\n$$ \\mathrm{CAI}_{\\max} = (1)^{1/5} = 1 $$\nAs the problem requires rounding to four significant figures, the maximum value is $1.000$.\n\nNext, we determine the minimum possible CAI. This requires selecting the nucleotide for each `N` that results in the minimum codon weight.\n- For $c_2 = \\mathrm{GCN}$: The minimum weight is $w_{\\min}(\\mathrm{GCN}) = \\min\\{0.2, 1, 0.7, 0.4\\} = 0.2$.\n- For $c_3 = \\mathrm{CGN}$: The minimum weight is $w_{\\min}(\\mathrm{CGN}) = \\min\\{0.1, 1, 0.8, 0.6\\} = 0.1$.\n- For $c_4 = \\mathrm{TTN}$: The minimum weight is $w_{\\min}(\\mathrm{TTN}) = \\min\\{0.05, 1, 0.1, 0.5\\} = 0.05$.\n- For $c_5 = \\mathrm{CCN}$: The minimum weight is $w_{\\min}(\\mathrm{CCN}) = \\min\\{0.3, 1, 0.9, 0.6\\} = 0.3$.\n\nThe product of the minimum possible weights is:\n$$ P_{\\min} = w(\\mathrm{ATG}) \\cdot w_{\\min}(\\mathrm{GCN}) \\cdot w_{\\min}(\\mathrm{CGN}) \\cdot w_{\\min}(\\mathrm{TTN}) \\cdot w_{\\min}(\\mathrm{CCN}) $$\n$$ P_{\\min} = 1 \\cdot 0.2 \\cdot 0.1 \\cdot 0.05 \\cdot 0.3 $$\n$$ P_{\\min} = 0.02 \\cdot 0.05 \\cdot 0.3 = 0.001 \\cdot 0.3 = 0.0003 $$\nThe minimum CAI is the fifth root of this product:\n$$ \\mathrm{CAI}_{\\min} = (0.0003)^{1/5} $$\nTo find the numerical value, we compute:\n$$ \\mathrm{CAI}_{\\min} = (3 \\times 10^{-4})^{1/5} \\approx 0.19743286 $$\nRounding to four significant figures, the minimum value is $0.1974$.\n\nThe problem asks for the ordered pair of (minimum, maximum) CAI values. This pair is $(0.1974, 1.000)$.", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.1974 & 1.000 \\end{pmatrix}}\n$$", "id": "2381997"}, {"introduction": "Beyond just analyzing existing genes, the CAI is a powerful tool for designing new ones, a common task in synthetic biology. This exercise [@problem_id:2381987] flips the script: instead of calculating the CAI from a given sequence, you will design a DNA sequence that encodes a specific protein fragment while aiming for a target CAI value. This optimization challenge will test your ability to strategically select synonymous codons to fine-tune the predicted expression level of a synthetic gene.", "problem": "You are given a fixed target Codon Adaptation Index (CAI) value $v=0.7$. For a protein fragment represented by an amino acid sequence of length $L$, a DNA coding sequence is a concatenation of codons, one per amino acid, taken from the standard genetic code but restricted to the codons and weights enumerated below. Each codon $c$ has an associated relative adaptiveness weight $w(c)$ in the interval $(0,1]$. For a coding sequence $S=c_1c_2\\ldots c_L$, the Codon Adaptation Index is defined as the geometric mean\n$$\n\\mathrm{CAI}(S)=\\left(\\prod_{i=1}^{L} w(c_i)\\right)^{1/L}.\n$$\nYour task, for each provided amino acid sequence, is to determine a DNA coding sequence $S$ that encodes the amino acid sequence and minimizes the absolute difference $|\\mathrm{CAI}(S)-v|$. If multiple sequences attain the same minimal absolute difference, prefer a sequence with $\\mathrm{CAI}(S)\\le v$ over one with $\\mathrm{CAI}(S)>v$. If a tie remains, choose the lexicographically smallest DNA sequence under the usual alphabetical order on characters $A  C  G  T$. All weights provided below are strictly positive, and you must only use the listed codons for each amino acid.\n\nRelative adaptiveness weights $w(c)$ for codons (DNA alphabet) are specified for the amino acids that appear in the test suite:\n- Alanine ($\\mathrm{A}$): GCT ($0.35$), GCC ($1.0$), GCA ($0.25$), GCG ($0.5$).\n- Glycine ($\\mathrm{G}$): GGT ($0.3$), GGC ($1.0$), GGA ($0.2$), GGG ($0.5$).\n- Leucine ($\\mathrm{L}$): TTA ($0.2$), TTG ($0.3$), CTT ($0.25$), CTC ($0.5$), CTA ($0.1$), CTG ($1.0$).\n- Serine ($\\mathrm{S}$): TCT ($0.4$), TCC ($0.6$), TCA ($0.3$), TCG ($1.0$), AGT ($0.2$), AGC ($0.8$).\n- Threonine ($\\mathrm{T}$): ACT ($0.4$), ACC ($1.0$), ACA ($0.3$), ACG ($0.7$).\n- Lysine ($\\mathrm{K}$): AAA ($0.6$), AAG ($1.0$).\n- Isoleucine ($\\mathrm{I}$): ATT ($0.85$), ATC ($1.0$), ATA ($0.1$).\n- Arginine ($\\mathrm{R}$): CGT ($0.7$), CGC ($1.0$), CGA ($0.1$), CGG ($0.2$), AGA ($0.05$), AGG ($0.05$).\n- Methionine ($\\mathrm{M}$): ATG ($1.0$).\n- Tryptophan ($\\mathrm{W}$): TGG ($1.0$).\n\nTest suite:\n- Case $1$: amino acid sequence \"MKT\".\n- Case $2$: amino acid sequence \"GAS\".\n- Case $3$: amino acid sequence \"ILRW\".\n- Case $4$: amino acid sequence \"MWM\".\n\nFor each case, report only the CAI value of your selected optimal coding sequence, rounded to exactly $6$ digits after the decimal point as a decimal number. Use the fixed target $v=0.7$ for all cases. Your program should produce a single line of output containing the results in order for Cases $1$ through $4$, as a comma-separated list enclosed in square brackets. For example: \"[r1,r2,r3,r4]\".", "solution": "The problem asks us to find a DNA coding sequence $S$ for a given amino acid sequence of length $L$, such that the Codon Adaptation Index, $\\mathrm{CAI}(S)$, is as close as possible to a target value $v=0.7$. The $\\mathrm{CAI}$ is defined as the geometric mean of the relative adaptiveness weights $w(c_i)$ of the constituent codons $c_i$:\n$$\n\\mathrm{CAI}(S) = \\left( \\prod_{i=1}^{L} w(c_i) \\right)^{1/L}\n$$\nThe primary objective is to minimize the absolute difference $|\\mathrm{CAI}(S) - v|$. A set of tie-breaking rules is specified for cases where multiple sequences yield the same minimal difference.\n\nThis is a combinatorial optimization problem. For an amino acid sequence $a_1 a_2 \\ldots a_L$, let the number of synonymous codons for each amino acid $a_i$ be $n_i$. The total number of possible DNA sequences that encode the given protein fragment is the product $\\prod_{i=1}^L n_i$. We must search this discrete space for an optimal solution.\n\nLet us evaluate the size of the search space for each test case to determine the feasibility of a brute-force approach.\n- Case $1$ (\"MKT\", $L=3$): The number of choices are $1$ for Methionine (M), $2$ for Lysine (K), and $4$ for Threonine (T). The total number of sequences is $1 \\times 2 \\times 4 = 8$.\n- Case $2$ (\"GAS\", $L=3$): The number of choices are $4$ for Glycine (G), $4$ for Alanine (A), and $6$ for Serine (S). The total is $4 \\times 4 \\times 6 = 96$.\n- Case $3$ (\"ILRW\", $L=4$): The choices are $3$ for Isoleucine (I), $6$ for Leucine (L), $6$ for Arginine (R), and $1$ for Tryptophan (W). The total is $3 \\times 6 \\times 6 \\times 1 = 108$.\n- Case $4$ (\"MWM\", $L=3$): The choices are $1$ for M, $1$ for W, and $1$ for M. There is only $1 \\times 1 \\times 1 = 1$ possible sequence.\n\nThe number of candidate sequences is small in all cases, making a brute-force enumeration computationally trivial and algorithmically sound. The method is as follows:\n1.  Generate all possible DNA coding sequences for the given amino acid sequence. This is done by taking the Cartesian product of the sets of available codons for each position in the amino acid sequence.\n2.  For each generated sequence $S = c_1 c_2 \\ldots c_L$, calculate its $\\mathrm{CAI}(S)$. This involves computing the product of weights $P = \\prod_{i=1}^L w(c_i)$ and then taking the $L$-th root, $\\mathrm{CAI}(S) = P^{1/L}$.\n3.  Identify the optimal sequence by applying the specified criteria in hierarchical order.\n\nThe selection criteria are:\n1.  Minimize $|\\mathrm{CAI}(S) - v|$, where $v=0.7$.\n2.  If a tie exists in criterion $1$, prefer sequences where $\\mathrm{CAI}(S) \\le v$.\n3.  If a tie still persists, choose the lexicographically smallest DNA sequence $S$.\n\nA robust method to implement this multi-level optimization is to sort all candidate solutions. For each candidate solution, represented by its DNA sequence $S$ and its calculated $\\mathrm{CAI}$ value, we can construct a composite sort key. A suitable key is the tuple:\n$$\n\\left( |\\mathrm{CAI}(S) - v|, (\\mathrm{CAI}(S)  v), S \\right)\n$$\nSorting a list of these tuples in ascending order will place the optimal solution at the very beginning. The logic is as follows:\n- The primary sorting is on $|\\mathrm{CAI}(S) - v|$, which addresses the main objective.\n- For ties in the first element, the second element, a Boolean $(\\mathrm{CAI}(S)  v)$, is used. In computation, `False` is treated as $0$ and `True` as $1$. Therefore, a solution with $\\mathrm{CAI}(S) \\le v$ (evaluating to `False`) will be ranked before a solution with $\\mathrm{CAI}(S)  v$ (evaluating to `True`), satisfying the second criterion.\n- If both of the first two elements are identical for two solutions, the third element, the sequence string $S$ itself, is used for comparison. Standard lexicographical string comparison will identify the alphabetically smallest sequence, satisfying the third criterion.\n\nThe algorithm to be implemented is therefore:\nFor each amino acid sequence:\n1.  Construct a list of all possible coding sequences and their corresponding $\\mathrm{CAI}$ values.\n2.  Sort this list using the composite key defined above.\n3.  The first element of the sorted list is the optimal solution.\n4.  Extract the $\\mathrm{CAI}$ value of this optimal solution, round it to the required precision ($6$ decimal places), and report it.\n\nThis procedure guarantees finding the unique optimal solution according to the problem's rules. For the specific case of Arginine (R) which has two codons (AGA, AGG) with the same weight $w=0.05$, the lexicographical tie-breaker on $S$ ensures a unique choice is made if they are part of otherwise identical optimal candidates.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Validates and solves the codon adaptation index optimization problem.\n    \"\"\"\n    # The target Codon Adaptation Index (CAI) value.\n    v = 0.7\n\n    # Relative adaptiveness weights w(c) for codons, sorted lexicographically by codon.\n    codon_data = {\n        'A': sorted([('GCT', 0.35), ('GCC', 1.0), ('GCA', 0.25), ('GCG', 0.5)]),\n        'G': sorted([('GGT', 0.3), ('GGC', 1.0), ('GGA', 0.2), ('GGG', 0.5)]),\n        'L': sorted([('TTA', 0.2), ('TTG', 0.3), ('CTT', 0.25), ('CTC', 0.5), ('CTA', 0.1), ('CTG', 1.0)]),\n        'S': sorted([('TCT', 0.4), ('TCC', 0.6), ('TCA', 0.3), ('TCG', 1.0), ('AGT', 0.2), ('AGC', 0.8)]),\n        'T': sorted([('ACT', 0.4), ('ACC', 1.0), ('ACA', 0.3), ('ACG', 0.7)]),\n        'K': sorted([('AAA', 0.6), ('AAG', 1.0)]),\n        'I': sorted([('ATT', 0.85), ('ATC', 1.0), ('ATA', 0.1)]),\n        'R': sorted([('CGT', 0.7), ('CGC', 1.0), ('CGA', 0.1), ('CGG', 0.2), ('AGA', 0.05), ('AGG', 0.05)]),\n        'M': sorted([('ATG', 1.0)]),\n        'W': sorted([('TGG', 1.0)]),\n    }\n\n    # Test suite of amino acid sequences.\n    test_cases = [\n        \"MKT\",\n        \"GAS\",\n        \"ILRW\",\n        \"MWM\",\n    ]\n\n    results = []\n    for aa_seq in test_cases:\n        L = len(aa_seq)\n        \n        # Get codon options for each position in the amino acid sequence.\n        # Each option is a tuple of (codon_string, weight).\n        codon_options_per_position = [codon_data[aa] for aa in aa_seq]\n\n        # Generate all possible combinations of codon choices.\n        # itertools.product generates the Cartesian product of input iterables.\n        all_codon_combinations = itertools.product(*codon_options_per_position)\n        \n        candidate_solutions = []\n        for combo in all_codon_combinations:\n            # combo is a tuple of (codon, weight) pairs, e.g., (('ATG', 1.0), ('AAG', 1.0), ...)\n            \n            # Construct the full DNA sequence string.\n            sequence_str = \"\".join([c[0] for c in combo])\n            \n            # Extract weights for CAI calculation.\n            weights = [c[1] for c in combo]\n            \n            # Calculate the product of weights.\n            prod_weights = np.prod(weights)\n            \n            # Calculate the Codon Adaptation Index (CAI).\n            cai = prod_weights**(1.0 / L)\n            \n            candidate_solutions.append({'seq': sequence_str, 'cai': cai})\n        \n        # Sort candidates to find the optimal one based on the hierarchical criteria.\n        # The sort key is a tuple: (abs_difference, preference_for_cai=v, lexicographical_order).\n        # Python's tuple sorting handles the priorities correctly.\n        # (cai  v) is a boolean; False  True, so cai=v is preferred in ties.\n        optimal_solution = sorted(\n            candidate_solutions, \n            key=lambda s: (abs(s['cai'] - v), s['cai']  v, s['seq'])\n        )[0]\n        \n        # Format the result to 6 decimal places.\n        results.append(f\"{optimal_solution['cai']:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2381987"}, {"introduction": "A powerful way to understand a model is to find where it breaks. This advanced practice [@problem_id:2382027] challenges you to think adversarially and probe the limits of a simplified, content-only gene prediction algorithm. Your task is to construct a DNA sequence that is, by a simple biological rule, non-coding, yet is misclassified as a gene because its statistical properties mimic a true coding region. Successfully fooling the classifier demonstrates a deep understanding of the signals it relies on and highlights why modern gene finders must incorporate more sophisticated evidence.", "problem": "You are given a simplified setting for content-based gene prediction based on codon usage bias. In this setting, a gene-finding classifier uses only a $64$-element codon probability vector for a \"gene\" model and a second $64$-element codon probability vector for a \"background\" model. For a fixed reading frame and window length, the classifier treats the sequence as a bag of non-overlapping codons and compares how likely the observed codon counts are under the two models, using the natural logarithm. Deoxyribonucleic Acid (DNA) is read in triplets called codons, so a window of length $L$ contributes $\\lfloor L/3 \\rfloor$ codons in a fixed frame. A start codon in this setting is $\\text{ATG}$. An Open Reading Frame (ORF) is a contiguous run of in-frame codons with no stop codon; however, in this problem we will use a minimal non-coding proxy constraint defined below.\n\nFundamental base and data:\n- The classifier is a multinomial model over $64$ codons. It evaluates windows in reading frame $0$ (starting at index $0$) and compares the two models using a log-likelihood difference. The Log-Likelihood Ratio (LLR) is computed with the natural logarithm and is dimensionless.\n- The gene model probabilities $\\mathbf{P}$ over $64$ codons are generated as follows. Let the single-nucleotide weights be $w(\\text{A}) = 0.15$, $w(\\text{C}) = 0.35$, $w(\\text{G}) = 0.35$, $w(\\text{T}) = 0.15$. For any codon $\\text{X}_1\\text{X}_2\\text{X}_3$, assign an unnormalized weight $W(\\text{X}_1\\text{X}_2\\text{X}_3) = w(\\text{X}_1)\\, w(\\text{X}_2)\\, w(\\text{X}_3)$. For the three stop codons $\\{\\text{TAA}, \\text{TAG}, \\text{TGA}\\}$, multiply their unnormalized weights by a stop-scale factor $s_{\\text{gene}} = 10^{-3}$ to reflect that coding regions strongly avoid internal stops. Then normalize all $64$ weights to sum to $1$ to obtain $\\mathbf{P}$.\n- Each background model $\\mathbf{Q}$ is generated analogously from its own single-nucleotide weights $v(\\cdot)$, but with stop-scale factor $s_{\\text{bg}} = 1$ (no special suppression of stops), and then normalized to a probability distribution over $64$ codons.\n\nNon-coding constraint for this problem:\n- A constructed DNA sequence is considered non-coding if, in reading frame $0$, it contains no in-frame start codon $\\text{ATG}$. This proxy is used only for this exercise and is not a comprehensive biological definition of non-coding.\n\nClassification rule:\n- For a length $L$ window, the classifier counts codons in frame $0$ and computes a log-likelihood difference between the gene model $\\mathbf{P}$ and a background model $\\mathbf{Q}$ using the multinomial likelihood with natural logarithms. The classifier declares \"gene\" if the computed LLR exceeds a given threshold $\\tau$.\n\nYour task:\n- Construct a DNA sequence of length $L = 1000$ nucleotides that satisfies the non-coding constraint above and yet would be misclassified as a gene (i.e., its LLR exceeds the threshold) by the classifier for each background model specified in the test suite below. The classifier only uses reading frame $0$ and ignores any trailing nucleotides that do not complete a full codon; you must count only the $\\lfloor L/3 \\rfloor = 333$ full codons starting at position $0$.\n- You may construct the sequence in any manner that obeys the non-coding constraint and is self-consistent with the definitions above. Use the natural logarithm in all computations. No angles or physical units are involved. Any proportions must be expressed as decimals.\n\nTest suite:\n- Use the gene model $\\mathbf{P}$ as specified above with $w(\\text{A}) = 0.15$, $w(\\text{C}) = 0.35$, $w(\\text{G}) = 0.35$, $w(\\text{T}) = 0.15$, and $s_{\\text{gene}} = 10^{-3}$.\n- Provide three background cases, each with its own single-nucleotide weights $v(\\cdot)$ and threshold $\\tau$:\n  1. Case $1$: $v_1(\\text{A}) = 0.25$, $v_1(\\text{C}) = 0.25$, $v_1(\\text{G}) = 0.25$, $v_1(\\text{T}) = 0.25$, threshold $\\tau_1 = 60.0$.\n  2. Case $2$: $v_2(\\text{A}) = 0.18$, $v_2(\\text{C}) = 0.32$, $v_2(\\text{G}) = 0.32$, $v_2(\\text{T}) = 0.18$, threshold $\\tau_2 = 7.0$.\n  3. Case $3$: $v_3(\\text{A}) = 0.40$, $v_3(\\text{C}) = 0.10$, $v_3(\\text{G}) = 0.10$, $v_3(\\text{T}) = 0.40$, threshold $\\tau_3 = 400.0$.\n\nImplementation details to respect:\n- Reading frame: always use frame $0$.\n- Window length: $L = 1000$, so count exactly $333$ codons from the start and ignore any leftover trailing nucleotides.\n- Codon ordering for any internal data structures may be taken as lexicographic with $\\text{A} \\lt \\text{C} \\lt \\text{G} \\lt \\text{T}$ at each position.\n- Natural logarithm must be used for all likelihood computations.\n- Your construction must ensure that the in-frame codon $\\text{ATG}$ never appears among those $333$ codons (non-coding proxy).\n- The stop codons are $\\{\\text{TAA}, \\text{TAG}, \\text{TGA}\\}$.\n\nRequired program output:\n- For the three background cases listed above, evaluate whether your single constructed sequence would be misclassified as a gene while satisfying the non-coding constraint. For each case $k \\in \\{1,2,3\\}$, output a boolean that is true if and only if both conditions hold simultaneously: (i) the LLR computed against background $\\mathbf{Q}_k$ exceeds $\\tau_k$ and (ii) the frame $0$ codon list contains no $\\text{ATG}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[True,False,True]\").\n\nYour solution must be a complete, runnable program that performs the construction and the three evaluations as specified and prints exactly one line in the required format.", "solution": "The objective is to construct a single DNA sequence of length $L=1000$ that is simultaneously misclassified as a gene by three different classifiers. This requires the sequence to satisfy the non-coding constraint (no in-frame $\\text{ATG}$ codon) while its Log-Likelihood Ratio (LLR) exceeds the specified threshold for each of the three background models.\n\nThe LLR for a sequence containing $N=333$ codons with counts $\\{n_i\\}$ for each of the $64$ codon types is given by:\n$$LLR_k = \\sum_{i=1}^{64} n_i \\log\\left(\\frac{P_i}{Q_{i,k}}\\right)$$\nwhere $\\mathbf{P}$ is the gene model probability vector and $\\mathbf{Q}_k$ is the $k$-th background model probability vector.\n\nWe must find a set of codon counts $\\{n_i\\}$ such that $\\sum n_i = 333$, $n_{\\text{ATG}} = 0$, and the following three inequalities hold:\n$1$. $LLR_1  \\tau_1 = 60.0$\n$2$. $LLR_2  \\tau_2 = 7.0$\n$3$. $LLR_3  \\tau_3 = 400.0$\n\nTo maximize the LLR, we should preferentially use codons for which the log-ratio term $\\log(P_i/Q_{i,k})$ is large and positive. Since this must hold for all three cases, an effective and simple strategy is to construct the sequence from a single type of codon, $c^*$, repeated $N=333$ times. This choice simplifies the LLR calculation to:\n$$LLR_k = N \\times \\log\\left(\\frac{P(c^*)}{Q_k(c^*)}\\right)$$\nThe non-coding constraint is satisfied by choosing a codon $c^* \\neq \\text{ATG}$.\n\nThe task thus reduces to finding a codon $c^* \\neq \\text{ATG}$ that satisfies the three conditions:\n$1$. $333 \\times \\log(P(c^*)/Q_1(c^*))  60.0$\n$2$. $333 \\times \\log(P(c^*)/Q_2(c^*))  7.0$\n$3$. $333 \\times \\log(P(c^*)/Q_3(c^*))  400.0$\n\nThe algorithm is as follows:\n1.  **Generate Probability Models:** For each of the four models (gene $\\mathbf{P}$, and backgrounds $\\mathbf{Q}_1, \\mathbf{Q}_2, \\mathbf{Q}_3$), generate the corresponding $64$-element probability vector. This is done by first calculating the unnormalized weight for each codon based on the product of its constituent nucleotide weights, applying the appropriate stop-codon scaling factor ($s_{\\text{gene}}=10^{-3}$ for $\\mathbf{P}$, $s_{\\text{bg}}=1$ for all $\\mathbf{Q}_k$), and then normalizing the $64$ weights to sum to $1$.\n2.  **Search for an Optimal Codon:** Iterate through all $63$ codons, excluding $\\text{ATG}$. For each candidate codon, calculate the LLR it would produce for all three test cases if the sequence were composed solely of that codon. If a codon is found that satisfies all three threshold conditions, it is selected as our construction codon, $c^*$.\n3.  **Analysis of Codon Choice:** The gene model exhibits a strong bias towards Guanine (G) and Cytosine (C), with $w(\\text{C})=w(\\text{G})=0.35$. In contrast, the background models are either uniform (Case 1: $v_1=0.25$), less biased towards G/C (Case 2: $v_2(\\text{C,G})=0.32$), or strongly biased against G/C (Case 3: $v_3(\\text{C,G})=0.10$). Consequently, GC-rich codons such as $\\text{CGC}$ are excellent candidates for $c^*$, as they have a high probability under the gene model $\\mathbf{P}$ but a relatively lower probability under all three background models $\\mathbf{Q}_k$, maximizing the ratio $P/Q_k$.\n4.  **Verification and Evaluation:** A detailed calculation confirms that the codon $\\text{CGC}$ satisfies all conditions.\n    - $P(\\text{CGC}) \\approx 0.0437$\n    - $Q_1(\\text{CGC}) = 0.015625$, $Q_2(\\text{CGC}) = 0.032768$, $Q_3(\\text{CGC}) = 0.001$\n    - $LLR_1 = 333 \\times \\log(0.0437/0.015625) \\approx 342.5  60.0$\n    - $LLR_2 = 333 \\times \\log(0.0437/0.032768) \\approx 95.9  7.0$\n    - $LLR_3 = 333 \\times \\log(0.0437/0.001) \\approx 1257.9  400.0$\nSince a valid construction codon $c^*$ (e.g., $\\text{CGC}$) exists, a sequence can be formed (e.g., by repeating $\\text{CGC}$ $333$ times and appending a nucleotide to reach length $1000$). This single sequence fulfills the non-coding constraint and is misclassified as a gene in all three cases. Therefore, the boolean evaluation for each case must be true.\n\nThe provided code implements this logic by first identifying a suitable codon and then formally evaluating the conditions for a sequence constructed from it.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a DNA sequence that is misclassified as a gene under three different\n    background models, while adhering to a non-coding constraint, and evaluates the\n    outcomes.\n    \"\"\"\n\n    # Define problem parameters and test cases.\n    L = 1000\n    N_codons = L // 3\n    s_gene = 1e-3\n    s_bg = 1.0\n\n    gene_model_weights = {'A': 0.15, 'C': 0.35, 'G': 0.35, 'T': 0.15}\n\n    test_cases = [\n        {'v': {'A': 0.25, 'C': 0.25, 'G': 0.25, 'T': 0.25}, 'tau': 60.0},\n        {'v': {'A': 0.18, 'C': 0.32, 'G': 0.32, 'T': 0.18}, 'tau': 7.0},\n        {'v': {'A': 0.40, 'C': 0.10, 'G': 0.10, 'T': 0.40}, 'tau': 400.0}\n    ]\n\n    bases = ['A', 'C', 'G', 'T']\n    codons = [b1 + b2 + b3 for b1 in bases for b2 in bases for b3 in bases]\n    stop_codons = {'TAA', 'TAG', 'TGA'}\n    atg_codon = 'ATG'\n    atg_index = codons.index(atg_codon)\n\n    def get_codon_probs(nuc_weights, stop_scale):\n        \"\"\"\n        Generates a 64-element codon probability vector from nucleotide weights.\n        \"\"\"\n        unnorm_w = np.zeros(64)\n        for i, codon in enumerate(codons):\n            w = nuc_weights[codon[0]] * nuc_weights[codon[1]] * nuc_weights[codon[2]]\n            if codon in stop_codons:\n                w *= stop_scale\n            unnorm_w[i] = w\n        # Handle case where sum is zero to avoid division by zero, though not expected here.\n        norm_sum = np.sum(unnorm_w)\n        if norm_sum == 0:\n            return np.full(64, 1/64)\n        return unnorm_w / norm_sum\n\n    # Generate gene and background models.\n    P = get_codon_probs(gene_model_weights, s_gene)\n    background_models = []\n    for case in test_cases:\n        Q = get_codon_probs(case['v'], s_bg)\n        background_models.append({'Q': Q, 'tau': case['tau']})\n\n    # Strategy: Find a single codon to construct the sequence that satisfies all constraints.\n    construction_codon_idx = -1\n    for i in range(len(codons)):\n        if i == atg_index:\n            continue\n\n        # Check if P[i] or any Q[i] is zero to avoid log(0) errors.\n        if P[i] == 0 or any(model['Q'][i] == 0 for model in background_models):\n            continue\n\n        # Check if this codon satisfies all three threshold conditions simultaneously.\n        all_conditions_met = True\n        for model in background_models:\n            llr = N_codons * (np.log(P[i]) - np.log(model['Q'][i]))\n            if llr = model['tau']:\n                all_conditions_met = False\n                break\n        \n        if all_conditions_met:\n            construction_codon_idx = i\n            break\n\n    # Evaluate the constructed sequence against the test cases.\n    # The constructed sequence consists of N_codons repetitions of `construction_codon_idx`.\n    # This sequence by definition satisfies the non-coding constraint.\n    results = []\n    if construction_codon_idx != -1:\n        # A sequence could be constructed, so we evaluate it.\n        for model in background_models:\n            llr = N_codons * (np.log(P[construction_codon_idx]) - np.log(model['Q'][construction_codon_idx]))\n            \n            # Condition 1: LLR exceeds threshold.\n            is_misclassified = llr  model['tau']\n            # Condition 2: No in-frame ATG. This is true by construction.\n            has_no_atg = True\n            \n            results.append(is_misclassified and has_no_atg)\n    else:\n        # No such sequence could be constructed using the single-codon strategy.\n        # This implies failure to satisfy the \"misclassified\" condition for all cases.\n        results = [False, False, False]\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b), results))}]\")\n\nsolve()\n```", "id": "2382027"}]}