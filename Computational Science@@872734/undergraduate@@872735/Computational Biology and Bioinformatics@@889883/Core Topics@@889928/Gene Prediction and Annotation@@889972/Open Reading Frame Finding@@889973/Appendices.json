{"hands_on_practices": [{"introduction": "Before we can analyze or predict genes, we must first learn how to find all potential candidates. This practice challenges you to implement a six-frame Open Reading Frame (ORF) finder from first principles, a cornerstone algorithm in computational genomics. By translating the raw DNA sequence according to the rules of the genetic code, you will develop a program to systematically identify every possible protein-coding region defined by a start and stop codon [@problem_id:2435536].", "problem": "You are given the task of writing a complete program that, for a set of deoxyribonucleic acid (DNA) contigs, identifies all Open Reading Frames (ORFs) longer than a given threshold measured in codons. An ORF is defined here using the Standard Genetic Code as a maximal in-frame interval that begins with a canonical start codon and ends at the first in-frame stop codon downstream on the same strand. The program must search all six reading frames ($+1$, $+2$, $+3$, $-1$, $-2$, $-3$) for each contig.\n\nFundamental bases and definitions to use:\n- The Central Dogma of molecular biology: DNA is transcribed to ribonucleic acid (RNA) and translated to protein; translation operates on codons, which are contiguous triplets of nucleotides.\n- Under the Standard Genetic Code, there are three stop codons: TAA, TAG, and TGA. The canonical start codon is ATG.\n- A reading frame is defined by a phase offset modulo $3$ on a strand. There are three frames per strand, hence six total when considering both forward and reverse-complement strands.\n- The reverse complement of a DNA string is obtained by reversing the string and complementing each nucleotide (A↔T, C↔G), reflecting antiparallel, complementary base pairing.\n\nYou must derive the algorithm from these principles:\n- On each strand, scan each frame in steps of $3$ nucleotides. Whenever you encounter a start codon ATG, find the first in-frame stop codon (TAA, TAG, or TGA) downstream in the same frame. If no in-frame stop codon exists before the end of the contig, this start does not produce a reportable ORF.\n- Let the contig length be $L$. For an ORF found on the forward strand at nucleotide start index $s$ (index of the A in ATG) and stop codon start index $t$ (index of the first base of the stop codon), the nucleotide interval for the ORF is $[s, t+3)$ (a half-open interval). The ORF length in codons, excluding the terminal stop codon, is $(t - s)/3$.\n- For an ORF found on the reverse-complement strand at reverse-complement coordinates $[s_{\\mathrm{rc}}, t_{\\mathrm{rc}}+3)$, map it to the original contig coordinates using $s_{\\mathrm{orig}} = L - (t_{\\mathrm{rc}}+3)$ and $t_{\\mathrm{orig}} = L - s_{\\mathrm{rc}}$. Report coordinates on the original contig in all cases.\n- An ORF is included in the output if and only if its length in codons strictly exceeds a given threshold $N$ (that is, length $> N$). The reported length excludes the terminal stop codon.\n\nRepresent each ORF as a list of four integers $[f, s, e, \\ell]$ where:\n- $f$ is the frame identifier: $+1$, $+2$, $+3$ for forward frames with offsets $0$, $1$, $2$ respectively; and $-1$, $-2$, $-3$ for reverse-complement frames with offsets $0$, $1$, $2$ respectively on the reverse-complement string.\n- $s$ is the $0$-based start index on the original contig (inclusive).\n- $e$ is the $0$-based end index on the original contig (exclusive), i.e., the index immediately after the stop codon.\n- $\\ell$ is the ORF length in codons excluding the terminal stop codon.\n\nSorting rule: For each contig, sort the ORFs by ascending $s$, then ascending $e$, then ascending $f$.\n\nAssumptions and constraints:\n- All contigs are uppercase strings over the alphabet {A, C, G, T}. No ambiguous symbols occur.\n- Use only the Standard Genetic Code with ATG as the sole start codon and TAA, TAG, TGA as stop codons.\n- Coordinates must be reported in $0$-based half-open intervals $[s,e)$ on the original contig.\n\nTest suite:\nYour program must compute results for the following four test cases. Each test case is a pair $(\\text{contig}, N)$.\n\n- Test case $1$ (happy path with forward and reverse frames):\n  - Contig: \"AAAATGAAACCCGGGTTTTAAAATGGCCGAACCTTAGTCAGGGTTTTTTCAT\"\n  - Threshold $N = 2$\n- Test case $2$ (boundary condition where an ORF has length exactly $N$ and must be excluded, alongside a longer ORF):\n  - Contig: \"GGGATGAAATAGGGATGCCACCCTAA\"\n  - Threshold $N = 1$\n- Test case $3$ (edge case with no start codon anywhere):\n  - Contig: \"CCCTTTGGGCCCTAGTAA\"\n  - Threshold $N = 0$\n- Test case $4$ (edge case with a start codon but no in-frame stop before the end; do not report incomplete ORFs):\n  - Contig: \"GGGATGCCCCCCCCGGG\"\n  - Threshold $N = 0$\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets.\n- Each test case’s result must be a list of ORF records $[f,s,e,\\ell]$, sorted as specified. The top-level output is a list of these per-test-case lists.\n- The output must contain no whitespace characters at all. For example, a valid shape is \"[[...],[...],[],[]]\".\n\nYour program must be self-contained and must not read any input. It must compute the results for the four test cases above and print the single required line.", "solution": "The problem presented is a standard exercise in bioinformatics, specifically in the domain of sequence analysis. It requires the identification of Open Reading Frames (ORFs) within given deoxyribonucleic acid (DNA) contigs. The problem is scientifically grounded, well-posed, and provides a complete set of unambiguous definitions and constraints. Therefore, it is deemed valid and a solution can be constructed.\n\nThe fundamental principle is the translation of a nucleotide sequence into an amino acid sequence, which is governed by the genetic code. Translation occurs in a specific reading frame, which is a division of the sequence into contiguous, non-overlapping triplets of nucleotides called codons. An ORF represents a potential protein-coding gene, defined as a sequence starting with a start codon and ending with a stop codon in the same reading frame. As DNA is a double-stranded molecule with antiparallel strands, we must analyze six reading frames in total: three on the forward strand and three on the reverse-complement strand.\n\nThe algorithm is designed to systematically inspect each of the six reading frames for every given contig.\n\n**Step 1: Strand and Frame Iteration**\nThe procedure must be applied to both the forward strand and its reverse complement. The reverse complement is generated by first reversing the DNA sequence and then replacing each nucleotide with its complementary base ($A \\leftrightarrow T$, $C \\leftrightarrow G$). For each strand, there are three reading frames, determined by the starting position of the first codon. These frames begin at indices $0$, $1$, and $2$ of the sequence, respectively. We shall denote these by frame identifiers $+1, +2, +3$ for the forward strand and $-1, -2, -3$ for the reverse-complement strand.\n\n**Step 2: ORF Identification on a Single Strand**\nFor a given strand (either forward or reverse-complement) and a specific frame (offset $i \\in \\{0, 1, 2\\}$), the algorithm scans the sequence for ORFs. The scan proceeds codon by codon, i.e., in steps of $3$ nucleotides, starting from the frame's offset.\n\nThe process for a single frame is as follows:\n1.  Iterate through the sequence with a starting index $s$ such that $s \\equiv i \\pmod 3$.\n2.  At each position $s$, check if the codon `dna[s:s+3]` is the canonical start codon, `ATG`.\n3.  If a start codon is found at index $s$, a subsequent search is initiated from position $s+3$ to find the first in-frame stop codon (`TAA`, `TAG`, or `TGA`). This search also proceeds in steps of $3$.\n4.  If a stop codon is found at index $t$, this defines an ORF. The problem statement defines the length of this ORF in codons, excluding the stop codon, as $\\ell = (t-s)/3$. An integer division can be used as $(t-s)$ is guaranteed to be a multiple of $3$ for an in-frame stop.\n5.  This ORF is considered valid for reporting only if its length $\\ell$ is strictly greater than the given threshold $N$.\n6.  If no in-frame stop codon is found before the end of the sequence, the start codon at $s$ does not initiate a complete ORF, and nothing is reported for it.\n7.  The scan for the next start codon resumes from the position immediately following the current start codon, i.e., $s+3$, to ensure all potential ORFs are found. The problem defines an ORF as a \"maximal in-frame interval\", which we interpret as the interval from a given start codon to the very first stop codon encountered in that frame.\n\n**Step 3: Coordinate Transformation for Reverse-Complement Strand**\nORFs found on the reverse-complement strand must have their coordinates mapped back to the coordinate system of the original forward strand. Let the original contig have length $L$. If an ORF is found on the reverse-complement strand with a start index $s_{rc}$ and a stop codon beginning at index $t_{rc}$, its nucleotide interval is $[s_{rc}, t_{rc}+3)$. The corresponding interval on the original contig is derived from the antiparallel nature of the strands. The start coordinate on the original contig is $s_{orig} = L - (t_{rc}+3)$, and the exclusive end coordinate is $e_{orig} = L - s_{rc}$.\n\n**Step 4: Record Formulation and Sorting**\nEach valid ORF is recorded as a list of four integers: $[f, s, e, \\ell]$. Here, $f$ is the frame identifier ($+1, +2, +3, -1, -2, -3$), $s$ is the $0$-based start index on the original contig, $e$ is the $0$-based exclusive end index, and $\\ell$ is the calculated length in codons. After all ORFs for a contig are identified, the resulting list is sorted. The specified sorting criteria are: primarily by ascending start position $s$, secondarily by ascending end position $e$, and tertiarily by ascending frame identifier $f$.\n\nThis structured approach ensures that all six reading frames are exhaustively searched, and any identified ORFs are correctly filtered, formatted, and sorted according to the problem's strict requirements, thereby yielding a determinate and correct solution.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the ORF finding problem for the predefined test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"AAAATGAAACCCGGGTTTTAAAATGGCCGAACCTTAGTCAGGGTTTTTTCAT\", 2),\n        (\"GGGATGAAATAGGGATGCCACCCTAA\", 1),\n        (\"CCCTTTGGGCCCTAGTAA\", 0),\n        (\"GGGATGCCCCCCCCGGG\", 0),\n    ]\n\n    results = []\n    for contig, n_threshold in test_cases:\n        results.append(find_all_orfs(contig, n_threshold))\n\n    # Final print statement in the exact required format.\n    # The string representation of a list includes spaces, which must be removed.\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\ndef find_all_orfs(contig, n_threshold):\n    \"\"\"\n    Finds all ORFs in a given contig that are longer than a specified threshold.\n    Searches all six reading frames.\n\n    Args:\n        contig (str): The DNA sequence.\n        n_threshold (int): The minimum number of codons (exclusive of stop)\n                           for an ORF to be reported. Length must be > threshold.\n    \n    Returns:\n        list: A sorted list of ORF records. Each record is [frame, start, end, length].\n    \"\"\"\n    stop_codons = {\"TAA\", \"TAG\", \"TGA\"}\n    start_codon = \"ATG\"\n    all_orfs = []\n    L = len(contig)\n\n    # Process forward strand (+1, +2, +3 frames)\n    for offset in range(3):\n        frame_id = offset + 1\n        # Iterate through the sequence in steps of 3 for the current frame\n        for s in range(offset, L - 5, 3):\n            if contig[s:s+3] == start_codon:\n                # Found a start codon, now search for the first in-frame stop codon\n                for t in range(s + 3, L - 2, 3):\n                    if contig[t:t+3] in stop_codons:\n                        # ORF found, calculate length and check against threshold\n                        length = (t - s) // 3\n                        if length > n_threshold:\n                            e = t + 3\n                            all_orfs.append([frame_id, s, e, length])\n                        # Break inner loop as we only care about the first stop\n                        break\n\n    # Process reverse-complement strand (-1, -2, -3 frames)\n    # The translation map for complementing DNA\n    complement_map = str.maketrans(\"ATCG\", \"TAGC\")\n    rc_contig = contig.translate(complement_map)[::-1]\n    \n    for offset in range(3):\n        frame_id = -(offset + 1)\n        for s_rc in range(offset, L - 5, 3):\n            if rc_contig[s_rc:s_rc+3] == start_codon:\n                for t_rc in range(s_rc + 3, L - 2, 3):\n                    if rc_contig[t_rc:t_rc+3] in stop_codons:\n                        length = (t_rc - s_rc) // 3\n                        if length > n_threshold:\n                            # Map coordinates from reverse-complement to original\n                            s_orig = L - (t_rc + 3)\n                            e_orig = L - s_rc\n                            all_orfs.append([frame_id, s_orig, e_orig, length])\n                        break\n\n    # Sort the collected ORFs according to the specified rule: s, then e, then f\n    # In the list [f, s, e, l], these correspond to indices 0, 1, 2\n    all_orfs.sort(key=lambda orf: (orf[1], orf[2], orf[0]))\n\n    return all_orfs\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2435536"}, {"introduction": "A long DNA sequence will inevitably contain short Open Reading Frames purely by chance, creating a challenge of distinguishing signal from noise. This exercise moves from simply finding ORFs to evaluating their significance, asking you to derive a minimum length threshold to control the rate of false positives across a genome [@problem_id:2410641]. By applying basic probability theory to the hypothetical scenario provided, you will learn a fundamental technique for setting statistical cutoffs in bioinformatics.", "problem": "A bacterial genome has length $N = 5 \\times 10^{6}$ nucleotides and background nucleotide frequencies $p_{A} = 0.3$, $p_{T} = 0.3$, $p_{G} = 0.2$, and $p_{C} = 0.2$. Assume an independent and identically distributed (i.i.d.) nucleotide model and independence between successive codons. An open reading frame (ORF) is defined as a sequence that begins with the canonical start codon ATG and continues in-frame without encountering any in-frame stop codon for at least $L$ codons downstream of the start codon. Consider the three standard stop codons TAA, TAG, and TGA. The genome is scanned on both strands and in all three reading frames per strand.\n\nYou want a statistical decision rule that robustly distinguishes true, but very short, ORFs from stochastically generated ones by controlling the expected number of false-positive ORFs genome-wide to be at most $\\alpha = 0.05$ under the null random-sequence model described above. Here, a false-positive ORF is any ORF that meets the definition above purely by chance in random sequence.\n\nDetermine the minimal integer $L$ (in codons) such that the expected number of false-positive ORFs across the entire genome, over both strands and all reading frames, is at most $\\alpha$. Report your answer as the minimal integer number of codons. No rounding is required beyond choosing the minimal integer that satisfies the criterion.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- Genome length: $N = 5 \\times 10^{6}$ nucleotides\n- Nucleotide frequencies: $p_{A} = 0.3$, $p_{T} = 0.3$, $p_{G} = 0.2$, $p_{C} = 0.2$\n- Sequence model: independent and identically distributed (i.i.d.) nucleotides\n- Codon model: independence between successive codons\n- ORF definition: starts with ATG, followed by at least $L$ in-frame non-stop codons\n- Start codon: ATG\n- Stop codons: TAA, TAG, TGA\n- Scanning parameters: both strands, three reading frames per strand\n- Statistical threshold: expected number of false-positive ORFs genome-wide is at most $\\alpha = 0.05$\n- Objective: Find the minimal integer $L$ (in codons) satisfying the criterion.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is assessed against the required criteria.\n- **Scientifically Grounded**: The problem is based on fundamental principles of computational biology and statistics. The use of an i.i.d. random sequence model to estimate the number of chance occurrences of a feature (an ORF) is a standard technique in bioinformatics for setting significance thresholds.\n- **Well-Posed**: The problem is clearly defined. It provides all necessary parameters ($N$, nucleotide frequencies, $\\alpha$) to construct a mathematical inequality and solve for the single unknown variable, $L$. A unique integer solution is expected.\n- **Objective**: The problem is stated in precise, quantitative terms, free from any subjective or ambiguous language.\n\n**Step 3: Verdict and Action**\nThe problem is scientifically sound, well-posed, and objective. It contains no contradictions, missing information, or logical flaws. Therefore, it is deemed **valid**. A solution will be derived.\n\nThe objective is to find the minimal integer $L$ such that the expected number of false-positive Open Reading Frames, denoted $E[N_{FP}]$, is no greater than $\\alpha$. This is expressed by the inequality:\n$$\nE[N_{FP}] \\leq \\alpha\n$$\nThe expected number of false positives is the product of the number of locations at which an ORF can potentially start and the probability that a random ORF of the required length occurs at any such location.\n\nFirst, we calculate the necessary probabilities based on the provided i.i.d. nucleotide model. The probability of any codon is the product of the probabilities of its constituent nucleotides.\n\nThe probability of the start codon, ATG, is:\n$$\nP_{\\text{start}} = P(\\text{ATG}) = p_{A} \\times p_{T} \\times p_{G} = 0.3 \\times 0.3 \\times 0.2 = 0.018\n$$\n\nNext, we calculate the probability of encountering one of the three stop codons: TAA, TAG, TGA.\n$$\nP(\\text{TAA}) = p_{T} \\times p_{A} \\times p_{A} = 0.3 \\times 0.3 \\times 0.3 = 0.027\n$$\n$$\nP(\\text{TAG}) = p_{T} \\times p_{A} \\times p_{G} = 0.3 \\times 0.3 \\times 0.2 = 0.018\n$$\n$$\nP(\\text{TGA}) = p_{T} \\times p_{G} \\times p_{A} = 0.3 \\times 0.2 \\times 0.3 = 0.018\n$$\nSince these are mutually exclusive events, the total probability of a randomly chosen codon being a stop codon is their sum:\n$$\nP_{\\text{stop}} = P(\\text{TAA}) + P(\\text{TAG}) + P(\\text{TGA}) = 0.027 + 0.018 + 0.018 = 0.063\n$$\nThe probability of a codon *not* being a stop codon is therefore:\n$$\nP_{\\text{non-stop}} = 1 - P_{\\text{stop}} = 1 - 0.063 = 0.937\n$$\n\nA false-positive ORF is defined as a sequence that begins with a start codon (ATG) and is followed by at least $L$ in-frame non-stop codons. Assuming independence between successive codons, the probability of such an event, $p_{FP}$, starting at a specific codon position is:\n$$\np_{FP} = P_{\\text{start}} \\times (P_{\\text{non-stop}})^{L}\n$$\n\nNext, we must determine the total number of positions, $N_{\\text{trials}}$, where we test for the start of an ORF. The genome is scanned on both strands, and in all three reading frames on each strand. For a long genome of length $N$, we can approximate the number of possible starting positions for a codon in one reading frame as $N/3$. Since there are three reading frames on the forward strand and three on the reverse strand, the total number of distinct, non-overlapping codon positions is $6 \\times (N/3) = 2N$. A more direct view is that every nucleotide position on both strands (total $2N$ positions) can be considered the start of a triplet in one specific reading frame. Therefore, the total number of trials is effectively $2N$.\n$$\nN_{\\text{trials}} = 2N = 2 \\times (5 \\times 10^{6}) = 10^{7}\n$$\nThe expected number of false-positive ORFs is the product of the number of trials and the probability of a false positive at each trial:\n$$\nE[N_{FP}] = N_{\\text{trials}} \\times p_{FP} = 2N \\times P_{\\text{start}} \\times (P_{\\text{non-stop}})^{L}\n$$\nWe must find the minimal integer $L$ that satisfies $E[N_{FP}] \\leq \\alpha$. We substitute the known values into the inequality:\n$$\n2 \\times (5 \\times 10^{6}) \\times (0.018) \\times (0.937)^{L} \\leq 0.05\n$$\n$$\n10^{7} \\times 0.018 \\times (0.937)^{L} \\leq 0.05\n$$\n$$\n180000 \\times (0.937)^{L} \\leq 0.05\n$$\nWe isolate the term containing $L$:\n$$\n(0.937)^{L} \\leq \\frac{0.05}{180000} = \\frac{1}{3600000}\n$$\nTo solve for $L$, we take the natural logarithm of both sides:\n$$\n\\ln((0.937)^{L}) \\leq \\ln\\left(\\frac{1}{3600000}\\right)\n$$\n$$\nL \\ln(0.937) \\leq -\\ln(3600000)\n$$\nSince $\\ln(0.937)$ is a negative number, dividing by it reverses the direction of the inequality:\n$$\nL \\geq \\frac{-\\ln(3600000)}{\\ln(0.937)} = \\frac{\\ln(3600000)}{-\\ln(0.937)}\n$$\nNow, we compute the value:\n$$\n\\ln(3600000) \\approx 15.09659\n$$\n$$\n\\ln(0.937) \\approx -0.065056\n$$\n$$\nL \\geq \\frac{15.09659}{-(-0.065056)} \\approx \\frac{15.09659}{0.065056} \\approx 232.054\n$$\nSince $L$ must be an integer and satisfy $L \\geq 232.054$, the minimal integer value for $L$ is $233$. This is the minimal number of codons required downstream of the start codon to ensure the expected number of false positives genome-wide is at most $0.05$.", "answer": "$$\n\\boxed{233}\n$$", "id": "2410641"}, {"introduction": "Beyond statistical significance, the biological properties of an ORF provide powerful clues to its function. This exercise introduces the Codon Adaptation Index (CAI), a measure of how well an ORF's codon usage matches that of highly expressed genes [@problem_id:2410622]. You will implement a program to calculate the CAI for candidate ORFs and use it as a sophisticated scoring metric to identify the most promising gene candidate, moving beyond simple length cutoffs.", "problem": "You are given a deoxyribonucleic acid (DNA) string over the alphabet $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ and a set of parameters. A candidate Open Reading Frame (ORF) is defined on a strand and frame as any maximal substring that starts at a canonical start codon $\\text{ATG}$ and ends at the first in-frame stop codon among $\\{\\text{TAA},\\text{TAG},\\text{TGA}\\}$ encountered after it along the same strand and frame. The ORF’s sense codon sequence is the list of codons from the start codon inclusive up to but not including the stop codon (that is, the stop codon is excluded from the list of sense codons). For a DNA of length $N$, you must consider all six reading frames: the three frames on the forward strand (offsets $0$, $1$, $2$ corresponding to frames $+1$, $+2$, $+3$) and the three frames on the reverse-complement strand (offsets $0$, $1$, $2$ on the reverse complement corresponding to frames $-1$, $-2$, $-3$). For any ORF on the reverse-complement strand defined by a half-open interval $[s',e')$ in reverse-complement coordinates, its half-open interval in the forward-strand coordinate system is $[N-e',\\,N-s')$.\n\nFor any sense codon sequence $(c_1,c_2,\\ldots,c_n)$ of length $n \\ge 1$, the Codon Adaptation Index (CAI) is defined by\n$$\n\\mathrm{CAI}(c_1,\\ldots,c_n)\\;=\\;\\left(\\prod_{i=1}^{n} w(c_i)\\right)^{1/n},\n$$\nwhere $w(c)$ is a nonnegative weight associated with codon $c$ derived from a fixed reference set of synonymous codon preferences. For this problem, you must use the following fixed codon weight function $w(\\cdot)$ (only for sense codons; stop codons are never used in the product):\n- Alanine: $w(\\text{GCT})=1.0$, $w(\\text{GCC})=0.9$, $w(\\text{GCA})=0.8$, $w(\\text{GCG})=0.7$.\n- Valine: $w(\\text{GTT})=1.0$, $w(\\text{GTC})=0.9$, $w(\\text{GTA})=0.7$, $w(\\text{GTG})=0.6$.\n- Glycine: $w(\\text{GGT})=1.0$, $w(\\text{GGC})=0.8$, $w(\\text{GGA})=0.7$, $w(\\text{GGG})=0.6$.\n- Proline: $w(\\text{CCT})=1.0$, $w(\\text{CCC})=0.9$, $w(\\text{CCA})=0.8$, $w(\\text{CCG})=0.7$.\n- Threonine: $w(\\text{ACT})=1.0$, $w(\\text{ACC})=0.9$, $w(\\text{ACA})=0.8$, $w(\\text{ACG})=0.7$.\n- Lysine: $w(\\text{AAA})=1.0$, $w(\\text{AAG})=0.6$.\n- Glutamate: $w(\\text{GAA})=1.0$, $w(\\text{GAG})=0.5$.\n- Arginine: $w(\\text{CGT})=1.0$, $w(\\text{CGC})=0.9$, $w(\\text{CGA})=0.6$, $w(\\text{CGG})=0.6$, $w(\\text{AGA})=0.5$, $w(\\text{AGG})=0.5$.\n- Phenylalanine: $w(\\text{TTC})=1.0$, $w(\\text{TTT})=0.8$.\n- Isoleucine: $w(\\text{ATT})=1.0$, $w(\\text{ATC})=0.9$, $w(\\text{ATA})=0.5$.\n- Leucine: $w(\\text{CTG})=1.0$, $w(\\text{CTT})=0.8$, $w(\\text{CTC})=0.7$, $w(\\text{CTA})=0.5$, $w(\\text{TTG})=0.6$, $w(\\text{TTA})=0.4$.\n- Serine: $w(\\text{TCT})=1.0$, $w(\\text{TCC})=0.9$, $w(\\text{TCA})=0.8$, $w(\\text{TCG})=0.7$, $w(\\text{AGT})=0.6$, $w(\\text{AGC})=0.6$.\n- Asparagine: $w(\\text{AAT})=1.0$, $w(\\text{AAC})=0.9$.\n- Aspartate: $w(\\text{GAT})=1.0$, $w(\\text{GAC})=0.9$.\n- Glutamine: $w(\\text{CAA})=1.0$, $w(\\text{CAG})=0.8$.\n- Histidine: $w(\\text{CAT})=1.0$, $w(\\text{CAC})=0.9$.\n- Tyrosine: $w(\\text{TAC})=1.0$, $w(\\text{TAT})=0.9$.\n- Cysteine: $w(\\text{TGC})=1.0$, $w(\\text{TGT})=0.9$.\n- Methionine: $w(\\text{ATG})=1.0$.\n- Tryptophan: $w(\\text{TGG})=1.0$.\n\nIf any sense codon in an ORF has no defined weight in the above list, that ORF is considered ineligible and must be discarded. Define the sense-codon length of an ORF to be $n$, the number of sense codons excluding the terminating stop codon. An ORF is admissible if and only if $n \\ge L_{\\min}$, where $L_{\\min}$ is the provided minimum length threshold in codons.\n\nYour program must, for each test case, enumerate all admissible ORFs over all six frames, compute their $\\mathrm{CAI}$, and select a single “best” ORF using the following deterministic tie-breaking rule applied in order:\n- Highest $\\mathrm{CAI}$ value.\n- If tied, largest sense-codon length $n$.\n- If still tied, smallest forward-strand start coordinate $s$ (zero-based).\n- If still tied, smallest frame rank according to the order $+1 \\prec +2 \\prec +3 \\prec -1 \\prec -2 \\prec -3$.\n\nFor the selected ORF, report:\n- The frame as an integer in $\\{+1,+2,+3,-1,-2,-3\\}$,\n- The forward-strand start coordinate $s$ (zero-based) of the ORF’s half-open interval $[s,e)$ in nucleotides,\n- The forward-strand end coordinate $e$ (end-exclusive) of the same interval,\n- The $\\mathrm{CAI}$ rounded to exactly $4$ digits after the decimal point.\n\nIf no admissible ORF exists in a test case, output the integer $-1$ for that case.\n\nTest Suite:\nProvide your program with the following test cases, each as a pair $(\\text{DNA}, L_{\\min})$ with $L_{\\min}$ in codons:\n- Case $1$: $\\left(\\text{ATGGCTGTTGGTCCTACTAAAGAACGTTTCATTTAA}\\,\\|\\text{GCCGCCGCC}\\,\\|\\text{ATGGCGGTGGGGCCGACGAAGGAGCGGTTTATCTAG},\\; L_{\\min}=8\\right)$, where $\\|$ denotes string concatenation.\n- Case $2$: $\\left(\\text{TTAAGGACCAACAGCCATATGAAATGA},\\; L_{\\min}=5\\right)$.\n- Case $3$: $\\left(\\text{GGGGCCCCAAAATTTT},\\; L_{\\min}=3\\right)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for the three cases as a comma-separated list enclosed in square brackets. Each result is either the integer $-1$ or a list of four elements $[\\text{frame}, s, e, \\mathrm{CAI}]$ with the $\\mathrm{CAI}$ displayed with exactly $4$ digits after the decimal point. For example, a syntactically valid output would look like $[[1,0,90,0.7123],[-2,5,41,0.6431],-1]$. No additional whitespace or text should be printed.", "solution": "The user has provided a problem in computational biology that requires finding the optimal Open Reading Frame (ORF) in a given DNA sequence based on a set of criteria. The steps to solve this problem are as follows: validation of the problem statement, development of an algorithm, and implementation.\n\n### Problem Validation\n\nThe problem statement has been evaluated according to the specified criteria:\n1.  **Givens Extraction**: All data and definitions have been extracted. This includes the DNA alphabet $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$, the start codon $\\text{ATG}$, stop codons $\\{\\text{TAA},\\text{TAG},\\text{TGA}\\}$, the six reading frames (three forward, three reverse-complement), the coordinate mapping for the reverse strand, the formula for the Codon Adaptation Index (CAI), a complete table of $61$ codon weights, the definition of an admissible ORF ($n \\ge L_{\\min}$), and a deterministic tie-breaking rule for selecting the best ORF.\n2.  **Scientific Grounding**: The problem is well-grounded in established principles of molecular and computational biology. ORF finding, six-frame translation, start/stop codons, and the CAI are standard concepts. The problem is scientifically sound.\n3.  **Well-Posedness and Objectivity**: The problem is well-posed. All terms are defined with mathematical precision. The objective function (CAI) and the tie-breaking rules are unambiguous, ensuring a unique solution exists. The language is objective and free of subjective claims.\n4.  **Completeness and Consistency**: The problem is self-contained and provides all necessary information. The provided list of codon weights covers all $61$ sense codons, making the system complete. There are no contradictions in the definitions or constraints.\n\n**Verdict**: The problem is valid. A reasoned solution can be constructed.\n\n### Algorithmic Solution\n\nThe core of the task is to systematically enumerate all admissible ORFs across all six reading frames, calculate their properties, and then select the best one according to a multi-level sorting criterion.\n\n**1. Six-Frame Translation and ORF Identification**\n\nA DNA sequence of length $N$ has six reading frames. Three on the forward strand and three on the reverse-complement strand.\n-   **Forward Frames (+1, +2, +3)**: These correspond to reading the DNA sequence starting from offsets $0$, $1$, and $2$, respectively.\n-   **Reverse Frames (-1, -2, -3)**: These correspond to reading the reverse-complement of the DNA sequence, also with offsets $0$, $1$, and $2$. These frames are denoted $-1, -2, -3$.\n\nFor each of the six frames, we must identify all candidate ORFs. A candidate ORF is a maximal sequence that starts with the codon $\\text{ATG}$ and ends with the first in-frame stop codon ($\\text{TAA}$, $\\text{TAG}$, or $\\text{TGA}$). This implies that for every occurrence of an $\\text{ATG}$ codon in a given frame, we must scan downstream in the same frame to find the first stop codon. This process must be repeated for every $\\text{ATG}$ found, as ORFs can be nested.\n\n**2. ORF Admissibility and Property Calculation**\n\nFor each candidate ORF found, we determine its properties:\n-   **Sense-Codon Sequence and Length ($n$)**: This is the sequence of codons starting from the $\\text{ATG}$ up to, but not including, the stop codon. Its length, $n$, is the number of these codons. An ORF is deemed **admissible** if its sense-codon length $n$ is greater than or equal to the given minimum threshold, $L_{\\min}$.\n-   **Codon Adaptation Index (CAI)**: For an admissible ORF with sense codons $(c_1, c_2, \\ldots, c_n)$, the CAI is the geometric mean of their weights $w(c_i)$:\n    $$\n    \\mathrm{CAI} = \\left(\\prod_{i=1}^{n} w(c_i)\\right)^{1/n}\n    $$\n    To ensure numerical stability, especially for long ORFs where the product of weights could lead to floating-point underflow, it is computationally preferable to work with logarithms:\n    $$\n    \\ln(\\mathrm{CAI}) = \\frac{1}{n} \\sum_{i=1}^{n} \\ln(w(c_i)) \\implies \\mathrm{CAI} = \\exp\\left(\\frac{1}{n} \\sum_{i=1}^{n} \\ln(w(c_i))\\right)\n    $$\n-   **Coordinates and Frame**: The ORF's start ($s$) and end ($e$) coordinates must be reported in the forward-strand, zero-based coordinate system. For an ORF on the forward strand starting at index $s_{fwd}$ and terminating with a stop codon at index $j_{fwd}$, the interval is $[s, e) = [s_{fwd}, j_{fwd}+3)$. For an ORF found on the reverse-complement sequence with an interval $[s', e')$, its coordinates on the forward strand are given by the transformation $[s, e) = [N-e', N-s')$. The frame is one of $\\{+1, +2, +3, -1, -2, -3\\}$.\n\n**3. Selection of the Best ORF**\n\nAll admissible ORFs from all six frames are collected. If no admissible ORFs are found, the process terminates for that test case with a result of $-1$. Otherwise, the collected ORFs are sorted to find the single best one using the specified tie-breaking hierarchy:\n1.  **Highest CAI value**: Sort in descending order of CAI.\n2.  **Largest sense-codon length $n$**: For ties in CAI, sort in descending order of $n$.\n3.  **Smallest forward-strand start coordinate $s$**: For further ties, sort in ascending order of $s$.\n4.  **Smallest frame rank**: As a final tie-breaker, sort by frame in the specified order: $+1 \\prec +2 \\prec +3 \\prec -1 \\prec -2 \\prec -3$. This can be implemented by mapping frames to integer ranks $\\{+1:0, +2:1, \\ldots, -3:5\\}$ and sorting in ascending order of rank.\n\nThe ORF that appears first after this multi-level sort is the \"best\" ORF. Its properties (frame, $s$, $e$, and CAI rounded to four decimal places) are then reported. This systematic procedure guarantees the identification of a unique, optimal ORF as defined by the problem statement.", "answer": "```python\nimport numpy as np\nimport math\n\n# Fixed parameters and definitions from the problem statement\nCODON_WEIGHTS = {\n    'GCT': 1.0, 'GCC': 0.9, 'GCA': 0.8, 'GCG': 0.7,  # Alanine\n    'GTT': 1.0, 'GTC': 0.9, 'GTA': 0.7, 'GTG': 0.6,  # Valine\n    'GGT': 1.0, 'GGC': 0.8, 'GGA': 0.7, 'GGG': 0.6,  # Glycine\n    'CCT': 1.0, 'CCC': 0.9, 'CCA': 0.8, 'CCG': 0.7,  # Proline\n    'ACT': 1.0, 'ACC': 0.9, 'ACA': 0.8, 'ACG': 0.7,  # Threonine\n    'AAA': 1.0, 'AAG': 0.6,                           # Lysine\n    'GAA': 1.0, 'GAG': 0.5,                           # Glutamate\n    'CGT': 1.0, 'CGC': 0.9, 'CGA': 0.6, 'CGG': 0.6, 'AGA': 0.5, 'AGG': 0.5,  # Arginine\n    'TTC': 1.0, 'TTT': 0.8,                           # Phenylalanine\n    'ATT': 1.0, 'ATC': 0.9, 'ATA': 0.5,               # Isoleucine\n    'CTG': 1.0, 'CTT': 0.8, 'CTC': 0.7, 'CTA': 0.5, 'TTG': 0.6, 'TTA': 0.4,  # Leucine\n    'TCT': 1.0, 'TCC': 0.9, 'TCA': 0.8, 'TCG': 0.7, 'AGT': 0.6, 'AGC': 0.6,  # Serine\n    'AAT': 1.0, 'AAC': 0.9,                           # Asparagine\n    'GAT': 1.0, 'GAC': 0.9,                           # Aspartate\n    'CAA': 1.0, 'CAG': 0.8,                           # Glutamine\n    'CAT': 1.0, 'CAC': 0.9,                           # Histidine\n    'TAC': 1.0, 'TAT': 0.9,                           # Tyrosine\n    'TGC': 1.0, 'TGT': 0.9,                           # Cysteine\n    'ATG': 1.0,                                       # Methionine\n    'TGG': 1.0,                                       # Tryptophan\n}\nSTART_CODON = 'ATG'\nSTOP_CODONS = {'TAA', 'TAG', 'TGA'}\nFRAME_RANKS = {1: 0, 2: 1, 3: 2, -1: 3, -2: 4, -3: 5}\nCOMPLEMENT_DNA = str.maketrans('ATCG', 'TAGC')\n\ndef get_reverse_complement(dna_seq):\n    \"\"\"Computes the reverse complement of a DNA sequence.\"\"\"\n    return dna_seq.translate(COMPLEMENT_DNA)[::-1]\n\ndef process_case(dna_seq, L_min):\n    \"\"\"Finds the best ORF for a given DNA sequence and minimum length.\"\"\"\n    admissible_orfs = []\n    N = len(dna_seq)\n\n    # Process both forward and reverse-complement strands\n    for strand_type in ['forward', 'reverse']:\n        seq = dna_seq if strand_type == 'forward' else get_reverse_complement(dna_seq)\n        \n        # Iterate through the three reading frames for the current strand\n        for frame_offset in range(3):\n            # Scan for all potential start codons within the current frame\n            for i in range(frame_offset, len(seq) - 2, 3):\n                if seq[i:i+3] == START_CODON:\n                    start_pos_in_strand = i\n                    sense_codons = []\n                    \n                    # Find the first in-frame stop codon after the start\n                    for j in range(start_pos_in_strand, len(seq) - 2, 3):\n                        codon = seq[j:j+3]\n                        if codon in STOP_CODONS:\n                            # ORF is defined, check for admissibility\n                            n = len(sense_codons)\n                            if n >= L_min:\n                                # Calculate CAI using logarithms for numerical stability\n                                weights = [CODON_WEIGHTS[c] for c in sense_codons]\n                                if 0 in weights:\n                                    cai = 0.0\n                                else:\n                                    cai = np.exp(np.mean(np.log(weights)))\n                                \n                                # Determine frame number and forward-strand coordinates\n                                if strand_type == 'forward':\n                                    frame = frame_offset + 1\n                                    s = start_pos_in_strand\n                                    e = j + 3\n                                else:  # reverse strand\n                                    frame = -(frame_offset + 1)\n                                    s_prime = start_pos_in_strand\n                                    e_prime = j + 3\n                                    s = N - e_prime\n                                    e = N - s_prime\n                                \n                                frame_rank = FRAME_RANKS[frame]\n                                \n                                admissible_orfs.append({\n                                    'cai': cai, 'n': n, 's': s,\n                                    'frame_rank': frame_rank, 'frame': frame, 'e': e\n                                })\n                            \n                            # Break inner loop since we found the first stop codon\n                            break\n                        \n                        sense_codons.append(codon)\n\n    if not admissible_orfs:\n        return -1\n\n    # Sort ORFs based on the specified tie-breaking rules\n    admissible_orfs.sort(key=lambda o: (-o['cai'], -o['n'], o['s'], o['frame_rank']))\n    \n    best_orf = admissible_orfs[0]\n    return [best_orf['frame'], best_orf['s'], best_orf['e'], best_orf['cai']]\n\ndef to_string_repr(item):\n    \"\"\"Formats an ORF result list or integer into the required string format.\"\"\"\n    if isinstance(item, int):\n        return str(item)\n    frame, s, e, cai = item\n    return f\"[{frame},{s},{e},{cai:.4f}]\"\n\ndef solve():\n    \"\"\"Main function to run the test suite and print results.\"\"\"\n    test_cases = [\n        (\n            \"ATGGCTGTTGGTCCTACTAAAGAACGTTTCATTTAA\" + \n            \"GCCGCCGCC\" +\n            \"ATGGCGGTGGGGCCGACGAAGGAGCGGTTTATCTAG\",\n            8\n        ),\n        (\n            \"TTAAGGACCAACAGCCATATGAAATGA\",\n            5\n        ),\n        (\n            \"GGGGCCCCAAAATTTT\",\n            3\n        ),\n    ]\n\n    results = [process_case(dna, l_min) for dna, l_min in test_cases]\n    output_strings = [to_string_repr(res) for res in results]\n    \n    print(f\"[{','.join(output_strings)}]\")\n\nsolve()\n```", "id": "2410622"}]}