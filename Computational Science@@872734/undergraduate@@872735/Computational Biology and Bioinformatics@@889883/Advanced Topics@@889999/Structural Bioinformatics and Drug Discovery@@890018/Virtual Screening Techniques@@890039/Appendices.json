{"hands_on_practices": [{"introduction": "Virtual screening in practice is rarely a single step, but rather a cascade of filters designed to efficiently reduce a vast chemical library to a manageable number of promising hits. This exercise guides you through implementing such a pipeline, starting with a rapid 2D similarity search, followed by a more specific 3D pharmacophore filter, and culminating in a simplified but conceptually complete flexible docking stage [@problem_id:2440164]. Mastering this process provides a foundational understanding of the entire virtual screening workflow.", "problem": "Implement a complete screening cascade that operates in three sequential stages consistent with virtual screening practice: a 2D similarity search, then a 3D pharmacophore filter, and finally a flexible docking stage. Your program must be a deterministic implementation based on the following definitions and rules, and it must process a fixed test suite of parameter sets. All distances must be expressed in angstroms, denoted $\\mathrm{\\mathring{A}}$, and all angles must be expressed in radians.\n\nBegin from the following fundamental bases and core definitions.\n\n1. 2D similarity as set similarity. Represent each molecule and the query as a fixed-length binary fingerprint vector that encodes molecular substructures. Let $A$ and $B$ be two binary fingerprints interpreted as sets of indices where the bits are $1$. The Tanimoto coefficient (also known as the Jaccard index for binary fingerprints) is defined by\n$$\nT(A,B) \\;=\\; \\frac{|A \\cap B|}{|A \\cup B|} \\;=\\; \\frac{c}{a + b - c},\n$$\nwhere $a = |A|$, $b = |B|$, and $c = |A \\cap B|$. A molecule passes the 2D filter if $T(A,B) \\ge \\tau_{\\mathrm{sim}}$, where $\\tau_{\\mathrm{sim}}$ is a given similarity threshold.\n\n2. 3D pharmacophore as geometric distance constraints. A pharmacophore template is specified by an ordered triple of feature types and their target pairwise distances. In this problem, each molecule provides three feature points labeled $\\mathrm{DON}$ (hydrogen bond donor), $\\mathrm{ACC}$ (hydrogen bond acceptor), and $\\mathrm{HYD}$ (hydrophobe), each with a 3D coordinate in $\\mathrm{\\mathring{A}}$. Let $d_{XY}$ denote the Euclidean distance between features $X$ and $Y$. Given target distances $\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)$ and a nonnegative tolerance $\\delta$ in $\\mathrm{\\mathring{A}}$, a molecule passes the 3D pharmacophore filter if and only if\n$$\n|d_{\\mathrm{DA}} - d^{\\star}_{\\mathrm{DA}}| \\le \\delta,\\quad\n|d_{\\mathrm{DH}} - d^{\\star}_{\\mathrm{DH}}| \\le \\delta,\\quad\n|d_{\\mathrm{AH}} - d^{\\star}_{\\mathrm{AH}}| \\le \\delta.\n$$\n\n3. Flexible docking as discrete internal rotation minimizing an energy-like score. For each molecule that passes the first two stages, consider a simplified docking setup with the following components:\n- Rigid receptor interaction sites at fixed coordinates $S_{\\mathrm{DON}}$, $S_{\\mathrm{ACC}}$, and $S_{\\mathrm{HYD}}$ in $\\mathrm{\\mathring{A}}$. The ligand’s feature $\\mathrm{DON}$ is the anchor that is translated to $S_{\\mathrm{DON}}$ for all candidate conformations.\n- A single internal flexibility modeled by rotation around the $z$-axis through the anchor point $S_{\\mathrm{DON}}$. Let $\\theta \\in \\Theta$ be a discrete set of rotation angles. For each $\\theta$, rotate the ligand’s $\\mathrm{ACC}$ and $\\mathrm{HYD}$ feature coordinates about the anchor by $\\theta$ using a standard rotation in the $xy$-plane.\n- An attraction energy defined by a sum of isotropic Gaussian terms:\n$$\nE_{\\mathrm{attr}}(\\theta) \\;=\\; -\\,w_{\\mathrm{ACC}} \\exp\\!\\Big(\\!-\\frac{\\|R_{\\theta}(P_{\\mathrm{ACC}}-P_{\\mathrm{DON}}) + S_{\\mathrm{DON}} - S_{\\mathrm{ACC}}\\|^2}{2\\sigma^2}\\Big) \\;-\\; w_{\\mathrm{HYD}} \\exp\\!\\Big(\\!-\\frac{\\|R_{\\theta}(P_{\\mathrm{HYD}}-P_{\\mathrm{DON}}) + S_{\\mathrm{DON}} - S_{\\mathrm{HYD}}\\|^2}{2\\sigma^2}\\Big),\n$$\nwhere $P_{\\mathrm{DON}}$, $P_{\\mathrm{ACC}}$, and $P_{\\mathrm{HYD}}$ are the molecule’s original feature coordinates, $R_{\\theta}$ is the rotation by angle $\\theta$ about the $z$-axis, $\\sigma > 0$ is a length scale in $\\mathrm{\\mathring{A}}$, and $w_{\\mathrm{ACC}}, w_{\\mathrm{HYD}} > 0$ are weights.\n- A steric clash penalty. Given an excluded sphere with center $C$ and radius $R_{\\mathrm{clash}}$ in $\\mathrm{\\mathring{A}}$, if any transformed feature point lies strictly within the sphere, add a penalty $+\\lambda_{\\mathrm{clash}}$ to the energy for that $\\theta$:\n$$\nE_{\\mathrm{clash}}(\\theta) \\;=\\; \n\\begin{cases}\n\\lambda_{\\mathrm{clash}}, & \\text{if any } \\|Q(\\theta) - C\\| \\lt R_{\\mathrm{clash}},\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nwhere $Q(\\theta)$ ranges over the transformed positions of $\\mathrm{DON}$, $\\mathrm{ACC}$, and $\\mathrm{HYD}$ at angle $\\theta$. The total energy is\n$$\nE(\\theta) \\;=\\; E_{\\mathrm{attr}}(\\theta) \\;+\\; E_{\\mathrm{clash}}(\\theta).\n$$\nDefine the docking score of a molecule to be the minimum of $E(\\theta)$ over $\\theta \\in \\Theta$. Lower (more negative) values indicate better docking.\n\nThe screening cascade proceeds in order: apply the 2D filter, then the 3D pharmacophore filter, then compute the docking score for each remaining molecule and select the molecule with the lowest docking score. If there is a tie, select the molecule with the smallest index.\n\nYou must implement the cascade over a fixed library and a fixed query, and evaluate it under a test suite of three parameter sets described below. For each parameter set, your program must output the index of the selected molecule as a single integer according to the rules above, or output $-1$ if no molecule survives through docking. The final program output must be a single line containing all three results as a comma-separated list enclosed in square brackets.\n\nUse the following fixed library and query data.\n\n- Query fingerprint $F_q$ of length $8$: $[1,1,0,1,0,1,0,0]$.\n\n- Library of $4$ molecules indexed $0$ through $3$:\n    - Molecule $0$:\n        - Fingerprint $F_0 = [1,1,0,1,0,1,0,0]$.\n        - Features in $\\mathrm{\\mathring{A}}$: $P_{\\mathrm{DON}}=(0,0,0)$, $P_{\\mathrm{ACC}}=(3,0,0)$, $P_{\\mathrm{HYD}}=(0,4,0)$.\n    - Molecule $1$:\n        - Fingerprint $F_1 = [1,0,1,1,0,0,1,0]$.\n        - Features in $\\mathrm{\\mathring{A}}$: $P_{\\mathrm{DON}}=(0,0,0)$, $P_{\\mathrm{ACC}}=(2.0,1.0,0)$, $P_{\\mathrm{HYD}}=(-1.0,3.5,0)$.\n    - Molecule $2$:\n        - Fingerprint $F_2 = [0,1,0,1,1,0,0,1]$.\n        - Features in $\\mathrm{\\mathring{A}}$: $P_{\\mathrm{DON}}=(0,0,0)$, $P_{\\mathrm{ACC}}=(2.5,0.2,0)$, $P_{\\mathrm{HYD}}=(-0.5,4.2,0)$.\n    - Molecule $3$:\n        - Fingerprint $F_3 = [0,0,0,1,0,1,0,1]$.\n        - Features in $\\mathrm{\\mathring{A}}$: $P_{\\mathrm{DON}}=(0,0,0)$, $P_{\\mathrm{ACC}}=(2.7,0,0)$, $P_{\\mathrm{HYD}}=(0,4.1,0)$.\n\n- Receptor interaction sites in $\\mathrm{\\mathring{A}}$: $S_{\\mathrm{DON}}=(0,0,0)$, $S_{\\mathrm{ACC}}=(5,0,0)$, $S_{\\mathrm{HYD}}=(0,5,0)$.\n\n- Docking parameters common to all test cases unless otherwise specified: Gaussian length scale $\\sigma=1.5\\,\\mathrm{\\mathring{A}}$, weights $w_{\\mathrm{ACC}}=1.0$, $w_{\\mathrm{HYD}}=0.8$, excluded sphere center $C=(1.0,1.0,0.0)$, excluded radius $R_{\\mathrm{clash}}=1.0\\,\\mathrm{\\mathring{A}}$, penalty $\\lambda_{\\mathrm{clash}}=50.0$, and rotation angle set $\\Theta$ consisting of $24$ uniformly spaced values in $[0,2\\pi)$.\n\nImplement the test suite as three parameter sets, each specifying the 2D similarity threshold $\\tau_{\\mathrm{sim}}$, the pharmacophore target distances $\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)$ in $\\mathrm{\\mathring{A}}$, and the pharmacophore tolerance $\\delta$ in $\\mathrm{\\mathring{A}}$:\n- Test case $1$ (happy path): $\\tau_{\\mathrm{sim}}=0.5$, $\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)=(3.0,4.0,5.0)$, $\\delta=0.3$.\n- Test case $2$ (boundary inclusion for 2D similarity): $\\tau_{\\mathrm{sim}}=0.4$, $\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)=(3.0,4.0,5.0)$, $\\delta=0.3$.\n- Test case $3$ (edge case, no survivors due to stringent 3D template): $\\tau_{\\mathrm{sim}}=0.3$, $\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)=(2.4,2.4,2.4)$, $\\delta=0.05$.\n\nProgram requirements and output format:\n- Your program must implement the three-stage cascade exactly as defined.\n- For each test case, compute the index (zero-based) of the single best-scoring molecule after docking among those that pass the filters. If no molecule survives, output $-1$ for that test case.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3]$, where each $r_i$ is an integer result for test case $i$.", "solution": "The problem statement is a valid, well-posed computational exercise grounded in the principles of virtual screening in bioinformatics and computational chemistry. It is self-contained, with all necessary data, parameters, and mathematical definitions provided. The staged pipeline mimics a realistic (albeit simplified) screening cascade, progressing from less computationally intensive methods (2D similarity) to more intensive ones (3D docking). The objective is to implement this deterministic cascade and report the index of the optimal molecule for a given set of test parameters, or $-1$ if no molecule passes the filters. The problem is scientifically consistent and mathematically unambiguous.\n\nThe solution is implemented by following the prescribed three-stage cascade.\n\nStage 1: 2D Similarity Search\n\nThis stage filters molecules based on their structural similarity to a query molecule, quantified using a binary fingerprint. A fingerprint is a vector of $0$s and $1$s representing the presence or absence of specific substructures. The similarity between two molecules, represented by their fingerprint sets $A$ and $B$, is calculated using the Tanimoto coefficient, $T(A,B)$. This coefficient is defined as the size of the intersection of the sets divided by the size of their union:\n$$\nT(A,B) = \\frac{|A \\cap B|}{|A \\cup B|}\n$$\nThe problem provides an equivalent formula for computation: $T(A,B) = \\frac{c}{a + b - c}$, where $a = |A|$, $b = |B|$, and $c = |A \\cap B|$. A molecule with fingerprint $F_{mol}$ passes this filter if its Tanimoto coefficient with the query fingerprint $F_q$ meets or exceeds a given threshold $\\tau_{\\mathrm{sim}}$:\n$$\nT(F_{mol}, F_q) \\ge \\tau_{\\mathrm{sim}}\n$$\n\nStage 2: 3D Pharmacophore Filtering\n\nMolecules that pass the first stage are then subjected to a geometric filter based on a 3D pharmacophore model. A pharmacophore represents the spatial arrangement of essential features for molecular recognition. In this problem, the model consists of three features—a hydrogen bond donor ($\\mathrm{DON}$), an acceptor ($\\mathrm{ACC}$), and a hydrophobe ($\\mathrm{HYD}$)—and a set of target distances between them, $\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)$. A molecule, with its own internal feature distances $\\big(d_{\\mathrm{DA}}, d_{\\mathrm{DH}}, d_{\\mathrm{AH}}\\big)$, is considered a match if each of its internal distances is within a specified tolerance $\\delta$ of the corresponding target distance. That is, all three of the following conditions must be met:\n$$\n|d_{\\mathrm{DA}} - d^{\\star}_{\\mathrm{DA}}| \\le \\delta \\\\\n|d_{\\mathrm{DH}} - d^{\\star}_{\\mathrm{DH}}| \\le \\delta \\\\\n|d_{\\mathrm{AH}} - d^{\\star}_{\\mathrm{AH}}| \\le \\delta\n$$\nThe distance $d_{XY}$ is the standard Euclidean distance between the coordinates of features $X$ and $Y$ within the molecule.\n\nStage 3: Flexible Docking and Scoring\n\nThe final stage evaluates the binding of the remaining molecules to a rigid receptor model. This simplified docking protocol involves a single degree of internal flexibility and an energy-like scoring function.\n\n- **Conformation Generation**: For each molecule, a set of conformations is generated. The molecule's $\\mathrm{DON}$ feature is designated as the anchor and is translated to the receptor's corresponding site, $S_{\\mathrm{DON}}$. The rest of the molecule is then rotated around the $z$-axis passing through this anchor point. The rotation is sampled at a discrete set of angles $\\Theta$, which consists of $24$ uniformly spaced values in $[0, 2\\pi)$. For each angle $\\theta \\in \\Theta$, the coordinates of the $\\mathrm{ACC}$ and $\\mathrm{HYD}$ features are transformed. If a point $P_X$ is a feature coordinate in the molecule's original frame, its transformed coordinate $Q_X(\\theta)$ after moving the anchor $P_{DON}$ to $S_{DON}$ and rotating is:\n  $$\n  Q_X(\\theta) = R_{\\theta}(P_X - P_{\\mathrm{DON}}) + S_{\\mathrm{DON}}\n  $$\n  where $R_{\\theta}$ is the standard 3D rotation matrix for an angle $\\theta$ about the $z$-axis.\n\n- **Scoring Function**: The goodness-of-fit for each conformation is evaluated by a total energy score $E(\\theta)$, which is the sum of an attraction term $E_{\\mathrm{attr}}(\\theta)$ and a steric clash penalty $E_{\\mathrm{clash}}(\\theta)$.\n\n  The attraction energy is modeled as a sum of negative Gaussian functions, rewarding proximity between the ligand's features ($\\mathrm{ACC}$, $\\mathrm{HYD}$) and their respective receptor sites ($S_{\\mathrm{ACC}}$, $S_{\\mathrm{HYD}}$):\n  $$\n  E_{\\mathrm{attr}}(\\theta) = -w_{\\mathrm{ACC}} \\exp\\left(-\\frac{\\|Q_{\\mathrm{ACC}}(\\theta) - S_{\\mathrm{ACC}}\\|^2}{2\\sigma^2}\\right) - w_{\\mathrm{HYD}} \\exp\\left(-\\frac{\\|Q_{\\mathrm{HYD}}(\\theta) - S_{\\mathrm{HYD}}\\|^2}{2\\sigma^2}\\right)\n  $$\n  Here, $w_X$ are positive weights and $\\sigma$ is a length scale defining the width of the potential wells.\n\n  The steric clash penalty is applied if any of the transformed feature points $Q_X(\\theta)$ penetrates an excluded volume, modeled as a sphere with center $C$ and radius $R_{\\mathrm{clash}}$. If $\\|Q_X(\\theta) - C\\| < R_{\\mathrm{clash}}$ for any feature $X \\in \\{\\mathrm{DON, ACC, HYD}\\}$, a large positive penalty $\\lambda_{\\mathrm{clash}}$ is added to the energy for that angle $\\theta$. Otherwise, the penalty is $0$.\n  $$\n  E(\\theta) = E_{\\mathrm{attr}}(\\theta) + E_{\\mathrm{clash}}(\\theta)\n  $$\n\n- **Docking Score**: The final docking score for a molecule is the minimum energy conformation found among all sampled rotations:\n  $$\n  \\text{Score} = \\min_{\\theta \\in \\Theta} E(\\theta)\n  $$\n\nFinal Selection\n\nThe cascade is executed sequentially for each test case. From the set of molecules that pass all three stages, the one with the lowest (most negative) docking score is selected as the winner. If two or more molecules have the same minimum score, the one with the lower original index (from $0$ to $3$) is chosen. If no molecules survive the entire cascade, the result is reported as $-1$. The procedure is repeated for all three test cases provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs the three-stage virtual screening cascade for the given test cases.\n    \"\"\"\n    \n    # --- Fixed Data and Parameters ---\n    \n    # Query fingerprint\n    F_Q = np.array([1, 1, 0, 1, 0, 1, 0, 0], dtype=int)\n\n    # Library of molecules\n    MOLECULES = [\n        {\n            \"id\": 0,\n            \"fp\": np.array([1, 1, 0, 1, 0, 1, 0, 0], dtype=int),\n            \"coords\": {\n                \"DON\": np.array([0.0, 0.0, 0.0]),\n                \"ACC\": np.array([3.0, 0.0, 0.0]),\n                \"HYD\": np.array([0.0, 4.0, 0.0]),\n            },\n        },\n        {\n            \"id\": 1,\n            \"fp\": np.array([1, 0, 1, 1, 0, 0, 1, 0], dtype=int),\n            \"coords\": {\n                \"DON\": np.array([0.0, 0.0, 0.0]),\n                \"ACC\": np.array([2.0, 1.0, 0.0]),\n                \"HYD\": np.array([-1.0, 3.5, 0.0]),\n            },\n        },\n        {\n            \"id\": 2,\n            \"fp\": np.array([0, 1, 0, 1, 1, 0, 0, 1], dtype=int),\n            \"coords\": {\n                \"DON\": np.array([0.0, 0.0, 0.0]),\n                \"ACC\": np.array([2.5, 0.2, 0.0]),\n                \"HYD\": np.array([-0.5, 4.2, 0.0]),\n            },\n        },\n        {\n            \"id\": 3,\n            \"fp\": np.array([0, 0, 0, 1, 0, 1, 0, 1], dtype=int),\n            \"coords\": {\n                \"DON\": np.array([0.0, 0.0, 0.0]),\n                \"ACC\": np.array([2.7, 0.0, 0.0]),\n                \"HYD\": np.array([0.0, 4.1, 0.0]),\n            },\n        },\n    ]\n\n    # Receptor and common docking parameters\n    RECEPTOR_SITES = {\n        \"DON\": np.array([0.0, 0.0, 0.0]),\n        \"ACC\": np.array([5.0, 0.0, 0.0]),\n        \"HYD\": np.array([0.0, 5.0, 0.0]),\n    }\n    DOCKING_PARAMS = {\n        \"sigma\": 1.5,\n        \"w_acc\": 1.0,\n        \"w_hyd\": 0.8,\n        \"clash_C\": np.array([1.0, 1.0, 0.0]),\n        \"clash_R\": 1.0,\n        \"clash_lambda\": 50.0,\n        \"angles\": np.linspace(0, 2 * np.pi, 24, endpoint=False),\n    }\n\n    # Test suite parameter sets\n    test_cases = [\n        # (tau_sim, (d_DA_star, d_DH_star, d_AH_star), delta)\n        (0.5, (3.0, 4.0, 5.0), 0.3),  # Test case 1\n        (0.4, (3.0, 4.0, 5.0), 0.3),  # Test case 2\n        (0.3, (2.4, 2.4, 2.4), 0.05), # Test case 3\n    ]\n\n    # --- Helper Functions ---\n    def tanimoto_coeff(fp_a, fp_b):\n        a = np.sum(fp_a)\n        b = np.sum(fp_b)\n        c = np.sum(np.logical_and(fp_a, fp_b))\n        if a + b - c == 0:\n            return 1.0\n        return c / (a + b - c)\n\n    def internal_distances(coords):\n        d_da = np.linalg.norm(coords[\"ACC\"] - coords[\"DON\"])\n        d_dh = np.linalg.norm(coords[\"HYD\"] - coords[\"DON\"])\n        d_ah = np.linalg.norm(coords[\"ACC\"] - coords[\"HYD\"])\n        return (d_da, d_dh, d_ah)\n\n    def docking_score(molecule, receptor_sites, params):\n        p_don = molecule[\"coords\"][\"DON\"]\n        p_acc = molecule[\"coords\"][\"ACC\"]\n        p_hyd = molecule[\"coords\"][\"HYD\"]\n\n        s_don = receptor_sites[\"DON\"]\n        s_acc = receptor_sites[\"ACC\"]\n        s_hyd = receptor_sites[\"HYD\"]\n\n        v_acc = p_acc - p_don\n        v_hyd = p_hyd - p_don\n\n        min_energy = float('inf')\n\n        for theta in params[\"angles\"]:\n            # 2D rotation matrix for rotation about z-axis\n            cos_t, sin_t = np.cos(theta), np.sin(theta)\n            \n            # Rotated relative vectors\n            rot_v_acc = np.array([v_acc[0] * cos_t - v_acc[1] * sin_t, v_acc[0] * sin_t + v_acc[1] * cos_t, v_acc[2]])\n            rot_v_hyd = np.array([v_hyd[0] * cos_t - v_hyd[1] * sin_t, v_hyd[0] * sin_t + v_hyd[1] * cos_t, v_hyd[2]])\n\n            # Transformed absolute coordinates\n            q_don = s_don\n            q_acc = rot_v_acc + s_don\n            q_hyd = rot_v_hyd + s_don\n            \n            # Attraction energy\n            dist_sq_acc = np.sum((q_acc - s_acc)**2)\n            dist_sq_hyd = np.sum((q_hyd - s_hyd)**2)\n            energy_attr = -params[\"w_acc\"] * np.exp(-dist_sq_acc / (2 * params[\"sigma\"]**2)) \\\n                          -params[\"w_hyd\"] * np.exp(-dist_sq_hyd / (2 * params[\"sigma\"]**2))\n\n            # Clash penalty\n            energy_clash = 0.0\n            clash_R_sq = params[\"clash_R\"]**2\n            clash_points = [q_don, q_acc, q_hyd]\n            for point in clash_points:\n                if np.sum((point - params[\"clash_C\"])**2) < clash_R_sq:\n                    energy_clash = params[\"clash_lambda\"]\n                    break\n            \n            total_energy = energy_attr + energy_clash\n            if total_energy < min_energy:\n                min_energy = total_energy\n        \n        return min_energy\n\n    # --- Main Cascade Logic ---\n    results = []\n    \n    # Pre-calculate molecule properties that don't depend on test case parameters\n    for mol in MOLECULES:\n        mol['tanimoto'] = tanimoto_coeff(mol['fp'], F_Q)\n        mol['distances'] = internal_distances(mol['coords'])\n\n    for case in test_cases:\n        tau_sim, d_star, delta = case\n        d_star_da, d_star_dh, d_star_ah = d_star\n\n        # Stage 1: 2D Similarity Filter\n        survivors_1 = []\n        for mol in MOLECULES:\n            if mol['tanimoto'] >= tau_sim:\n                survivors_1.append(mol)\n\n        # Stage 2: 3D Pharmacophore Filter\n        survivors_2 = []\n        for mol in survivors_1:\n            d_da, d_dh, d_ah = mol['distances']\n            if (abs(d_da - d_star_da) <= delta and\n                abs(d_dh - d_star_dh) <= delta and\n                abs(d_ah - d_star_ah) <= delta):\n                survivors_2.append(mol)\n        \n        # Stage 3: Docking and Selection\n        if not survivors_2:\n            results.append(-1)\n            continue\n            \n        best_score = float('inf')\n        best_mol_idx = -1\n\n        for mol in survivors_2:\n            score = docking_score(mol, RECEPTOR_SITES, DOCKING_PARAMS)\n            if score < best_score:\n                best_score = score\n                best_mol_idx = mol[\"id\"]\n        \n        results.append(best_mol_idx)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2440164"}, {"introduction": "Building a screening model is just the first step; a crucial part of computational science is knowing how to rigorously evaluate its output. This practice introduces standard metrics for quantifying the success of a virtual screen, including the Area Under the Curve (AUC) and the Enrichment Factor (EF), in the realistic context of comparing results from an experimental crystal structure versus a predicted homology model [@problem_id:2440123]. By completing this exercise, you will gain the essential skill of assessing and validating the performance of your computational predictions.", "problem": "You are given the outcomes of two virtual screens of the same ligand set against the same target protein: one using an X-ray crystal structure and one using a high-quality homology model. For each screen, a real-valued docking score is provided for every ligand, where lower scores indicate stronger predicted binding. A binary activity label is also provided for each ligand, where $1$ denotes an experimentally confirmed active and $0$ denotes an inactive. You must quantify and compare the ranking quality of the two screens using the following definitions.\n\nLet the ligand index set be $\\{0,1,\\dots,N-1\\}$. Let $y(j) \\in \\{0,1\\}$ be the ground-truth activity label for ligand $j$, with the active index set $A = \\{ j \\mid y(j) = 1 \\}$ and inactive index set $I = \\{ j \\mid y(j) = 0 \\}$. Let $s_{C}(j)$ be the docking score from the X-ray crystal structure screen and $s_{H}(j)$ be the docking score from the homology model screen. Lower scores are better.\n\nDefine, for a given model $M \\in \\{C,H\\}$ with scores $s_{M}(j)$:\n1. Receiver Operating Characteristic (ROC) area under the curve (AUC): \n   $$\\mathrm{AUC}(M) = \\frac{1}{|A|\\cdot|I|} \\sum_{a \\in A} \\sum_{i \\in I} \\phi\\big(s_{M}(a), s_{M}(i)\\big),$$\n   where \n   $$\\phi(x,y) = \\begin{cases}\n   1 & \\text{if } x < y,\\\\\n   \\tfrac{1}{2} & \\text{if } x = y,\\\\\n   0 & \\text{if } x > y,\n   \\end{cases}$$\n   reflecting the probability that a randomly chosen active has a strictly better (lower) score than a randomly chosen inactive, with ties contributing $\\tfrac{1}{2}$.\n\n2. Early enrichment factor at fraction $f \\in (0,1]$:\n   - Let $T = f \\cdot N$ (assumed to be an integer in the test suite below). Rank ligands by ascending $s_{M}(j)$. If a tie occurs at the selection boundary, break ties by choosing smaller indices first so that exactly $T$ ligands are selected.\n   - Let $\\mathrm{TP}_{f}(M)$ be the number of actives among these top $T$ ligands. Let $|A|$ be the total number of actives.\n   - Define \n     $$\\mathrm{EF}_{f}(M) = \\frac{\\mathrm{TP}_{f}(M)}{f \\cdot |A|}.$$\n\n3. Jaccard index of the top-$K$ ligand sets between the two models:\n   - For each model, form the top-$K$ set by taking the $K$ ligands with the smallest scores (ties broken by smaller indices first to obtain exactly $K$ ligands).\n   - Let $S_{C}^{(K)}$ and $S_{H}^{(K)}$ be these two sets. Define\n     $$J^{(K)} = \\frac{\\left| S_{C}^{(K)} \\cap S_{H}^{(K)} \\right|}{\\left| S_{C}^{(K)} \\cup S_{H}^{(K)} \\right|}.$$\n\nFor each test case below, compute the $5$-tuple \n$$\\left[ \\mathrm{AUC}(C),\\ \\mathrm{AUC}(H),\\ \\mathrm{EF}_{f}(C),\\ \\mathrm{EF}_{f}(H),\\ J^{(K)} \\right],$$\nwith all values rounded to $6$ decimal places.\n\nTest suite (each case specifies $N$, the two score lists, the activity labels, the fraction $f$, and the integer $K$):\n\n- Case $1$:\n  - $N = 12$\n  - $s_{C} = [-9.8,\\ -7.3,\\ -10.5,\\ -6.8,\\ -8.1,\\ -9.1,\\ -7.0,\\ -8.7,\\ -6.5,\\ -10.2,\\ -7.9,\\ -8.3]$\n  - $s_{H} = [-9.0,\\ -7.5,\\ -9.8,\\ -7.2,\\ -8.4,\\ -8.9,\\ -7.1,\\ -8.5,\\ -6.8,\\ -9.7,\\ -7.6,\\ -8.0]$\n  - $y = [1,\\ 0,\\ 1,\\ 0,\\ 0,\\ 1,\\ 0,\\ 0,\\ 0,\\ 1,\\ 0,\\ 0]$\n  - $f = 0.25$\n  - $K = 5$\n\n- Case $2$:\n  - $N = 10$\n  - $s_{C} = [-11.0,\\ -10.5,\\ -10.2,\\ -9.8,\\ -8.0,\\ -7.9,\\ -7.5,\\ -7.2,\\ -7.0,\\ -6.8]$\n  - $s_{H} = [-7.5,\\ -7.4,\\ -7.3,\\ -7.2,\\ -10.0,\\ -9.8,\\ -9.5,\\ -9.2,\\ -9.0,\\ -8.8]$\n  - $y = [1,\\ 1,\\ 1,\\ 1,\\ 0,\\ 0,\\ 0,\\ 0,\\ 0,\\ 0]$\n  - $f = 0.2$\n  - $K = 3$\n\n- Case $3$:\n  - $N = 8$\n  - $s_{C} = [-8.0,\\ -9.0,\\ -8.0,\\ -9.0,\\ -8.0,\\ -8.0,\\ -9.0,\\ -8.0]$\n  - $s_{H} = [-8.5,\\ -8.5,\\ -8.5,\\ -8.5,\\ -8.5,\\ -8.5,\\ -8.5,\\ -8.5]$\n  - $y = [0,\\ 1,\\ 0,\\ 1,\\ 0,\\ 0,\\ 1,\\ 0]$\n  - $f = 0.5$\n  - $K = 4$\n\nFinal output format: Your program should produce a single line of output containing a list of per-case results, where each per-case result is the $5$-tuple described above, rounded to $6$ decimal places. The single line must be a valid list-of-lists without any spaces. For example: $[[x_{11},x_{12},x_{13},x_{14},x_{15}],[x_{21},x_{22},x_{23},x_{24},x_{25}],\\dots]$ where each $x_{ij}$ is a decimal number with exactly $6$ digits after the decimal point.", "solution": "The problem statement has been rigorously evaluated and is deemed valid. It is scientifically grounded in the field of computational drug discovery, well-posed with precise mathematical definitions and explicit test cases, and objective in its formulation. All necessary data, conditions, and constraints are provided, and there are no logical contradictions or ambiguities. I will therefore proceed with the derivation of the solution.\n\nThe task is to evaluate and compare the performance of two virtual screening models—one based on an X-ray crystal structure ($C$) and another on a homology model ($H$)—using three distinct metrics: the Area Under the Receiver Operating Characteristic Curve ($\\mathrm{AUC}$), the Early Enrichment Factor ($\\mathrm{EF}_f$), and the Jaccard index ($J^{(K)}$). The solution requires a systematic implementation of the algorithms for these metrics, paying strict attention to the specified tie-breaking rules.\n\nLet the set of all $N$ ligands be indexed by $j \\in \\{0, 1, \\dots, N-1\\}$. For each ligand $j$, we are given a binary activity label $y(j)$ and two docking scores, $s_C(j)$ and $s_H(j)$.\n\nFirst, we define helper sets based on the activity labels: the set of active ligands $A = \\{j \\mid y(j) = 1\\}$ and the set of inactive ligands $I = \\{j \\mid y(j) = 0\\}$, with cardinalities $|A|$ and $|I|$ respectively.\n\nThe algorithmic approach for computing each required quantity is as follows:\n\n1.  **Area Under the ROC Curve ($\\mathrm{AUC}(M)$)**\n\nThe $\\mathrm{AUC}$ for a model $M \\in \\{C, H\\}$ is a measure of its ability to rank active ligands higher than inactive ones. The provided formula is a direct implementation of the Mann-Whitney U test statistic, which is equivalent to the $\\mathrm{AUC}$:\n$$\n\\mathrm{AUC}(M) = \\frac{1}{|A|\\cdot|I|} \\sum_{a \\in A} \\sum_{i \\in I} \\phi\\big(s_{M}(a), s_{M}(i)\\big)\n$$\nwhere the function $\\phi(x, y)$ evaluates to $1$ if $x < y$, $\\frac{1}{2}$ if $x = y$, and $0$ if $x > y$. This corresponds to the probability that a randomly selected active ligand has a better (lower) score than a randomly selected inactive ligand.\n\nThe algorithm is a direct implementation of this formula:\n- Separate the scores $s_M$ into two groups: active scores $\\{s_M(a) \\mid a \\in A\\}$ and inactive scores $\\{s_M(i) \\mid i \\in I\\}$.\n- Initialize a sum, $\\Sigma_\\phi = 0$.\n- For each active score $s_M(a)$, iterate through all inactive scores $s_M(i)$ and add $\\phi(s_M(a), s_M(i))$ to the sum $\\Sigma_\\phi$.\n- The final $\\mathrm{AUC}(M)$ is computed as $\\frac{\\Sigma_\\phi}{|A| \\cdot |I|}$. This computation must be performed for both models, $C$ and $H$.\n\n2.  **Early Enrichment Factor ($\\mathrm{EF}_{f}(M)$)**\n\nThe $\\mathrm{EF}_f$ metric quantifies how many active ligands are found within the top-scoring fraction $f$ of the ranked list, compared to a random selection.\n$$\n\\mathrm{EF}_{f}(M) = \\frac{\\mathrm{TP}_{f}(M)}{f \\cdot |A|}\n$$\nThe key to this calculation is the correct ranking of ligands. The problem specifies that ligands are to be ranked by ascending score $s_M(j)$, with ties broken by choosing the smaller ligand index $j$ first.\n\nThe algorithm proceeds as follows:\n- For a given model $M$, create a list of tuples $(s_M(j), j)$ for all ligands $j \\in \\{0, \\dots, N-1\\}$.\n- Perform a stable sort on this list, first by score (ascending) and then by index (ascending). This correctly implements the specified tie-breaking rule.\n- Determine the number of ligands to select, $T = f \\cdot N$. This is given to be an integer.\n- Select the first $T$ ligands from the sorted list.\n- Count the number of true positives, $\\mathrm{TP}_f(M)$, which is the number of active ligands (where $y(j)=1$) within this top-$T$ set.\n- Calculate the enrichment factor using the formula above. The denominator $f \\cdot |A|$ represents the expected number of actives in a random selection of $T$ ligands.\n\n3.  **Jaccard Index ($J^{(K)}$)**\n\nThe Jaccard index measures the similarity between the top-$K$ ligand sets as predicted by the two models, $C$ and $H$.\n$$\nJ^{(K)} = \\frac{\\left| S_{C}^{(K)} \\cap S_{H}^{(K)} \\right|}{\\left| S_{C}^{(K)} \\cup S_{H}^{(K)} \\right|}\n$$\nThe top-$K$ sets, $S_C^{(K)}$ and $S_H^{(K)}$, are constructed using the same ranking and tie-breaking procedure as for the enrichment factor.\n\nThe algorithm is:\n- For model $C$, generate the ranked list of ligands and select the indices of the top $K$ ligands to form the set $S_C^{(K)}$.\n- Repeat the process for model $H$ to form the set $S_H^{(K)}$.\n- Compute the cardinality of the intersection of these two sets, $|S_C^{(K)} \\cap S_H^{(K)}|$.\n- Compute the cardinality of the union of these two sets, $|S_C^{(K)} \\cup S_H^{(K)}|$. Note that $|S_C^{(K)} \\cup S_H^{(K)}| = |S_C^{(K)}| + |S_H^{(K)}| - |S_C^{(K)} \\cap S_H^{(K)}| = 2K - |S_C^{(K)} \\cap S_H^{(K)}|$.\n- The Jaccard index is the ratio of these two cardinalities.\n\nFor each test case, these three algorithms are applied to the provided data to compute the five required values: $\\mathrm{AUC}(C)$, $\\mathrm{AUC}(H)$, $\\mathrm{EF}_f(C)$, $\\mathrm{EF}_f(H)$, and $J^{(K)}$. The results are then rounded to $6$ decimal places and formatted as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_top_n_indices(scores: np.ndarray, n: int) -> list[int]:\n    \"\"\"\n    Ranks ligands by score (ascending) and index (ascending for ties)\n    and returns the indices of the top n ligands.\n    \"\"\"\n    N = len(scores)\n    # Create pairs of (score, index) for sorting.\n    indexed_scores = sorted([(scores[j], j) for j in range(N)])\n    # Extract indices from the top n sorted pairs.\n    top_indices = [index for score, index in indexed_scores[:n]]\n    return top_indices\n\ndef calculate_auc(scores: np.ndarray, y: np.ndarray) -> float:\n    \"\"\"\n    Calculates the Area Under the ROC Curve (AUC).\n    \"\"\"\n    active_indices = np.where(y == 1)[0]\n    inactive_indices = np.where(y == 0)[0]\n\n    num_actives = len(active_indices)\n    num_inactives = len(inactive_indices)\n\n    if num_actives == 0 or num_inactives == 0:\n        return 0.5  # Per convention, AUC is 0.5 if one class is missing.\n\n    active_scores = scores[active_indices]\n    inactive_scores = scores[inactive_indices]\n\n    # Vectorized comparison\n    # Reshape for broadcasting: active_scores (num_actives, 1), inactive_scores (1, num_inactives)\n    # Resulting comparison matrices have shape (num_actives, num_inactives)\n    less_than_count = np.sum(active_scores[:, np.newaxis] < inactive_scores)\n    equal_to_count = np.sum(active_scores[:, np.newaxis] == inactive_scores)\n\n    phi_sum = less_than_count + 0.5 * equal_to_count\n    \n    auc = phi_sum / (num_actives * num_inactives)\n    return auc\n\ndef calculate_ef(scores: np.ndarray, y: np.ndarray, f: float) -> float:\n    \"\"\"\n    Calculates the Early Enrichment Factor at fraction f.\n    \"\"\"\n    N = len(y)\n    num_actives_total = np.sum(y)\n    \n    if num_actives_total == 0:\n        return 0.0 # No actives to enrich.\n\n    T = int(f * N)\n    if T == 0:\n        return 0.0\n\n    top_indices = get_top_n_indices(scores, T)\n    \n    # Count true positives in the top T ligands\n    tp_f = np.sum(y[top_indices])\n    \n    # Denominator is the expected number of actives in a random selection of size T\n    ef = tp_f / (f * num_actives_total)\n    return ef\n\ndef calculate_jaccard(scores_c: np.ndarray, scores_h: np.ndarray, k: int) -> float:\n    \"\"\"\n    Calculates the Jaccard index between the top-K sets of two models.\n    \"\"\"\n    if k == 0:\n        return 1.0 if len(scores_c) == 0 else 0.0\n\n    top_k_indices_c = get_top_n_indices(scores_c, k)\n    top_k_indices_h = get_top_n_indices(scores_h, k)\n\n    set_c = set(top_k_indices_c)\n    set_h = set(top_k_indices_h)\n    \n    intersection_size = len(set_c.intersection(set_h))\n    union_size = len(set_c.union(set_h))\n\n    if union_size == 0:\n        return 1.0 # By convention, Jaccard of two empty sets is 1.\n\n    jaccard = intersection_size / union_size\n    return jaccard\n\ndef process_case(s_c: list, s_h: list, y_labels: list, f: float, k: int) -> list[float]:\n    \"\"\"\n    Processes a single test case and computes all required metrics.\n    \"\"\"\n    s_c_np = np.array(s_c)\n    s_h_np = np.array(s_h)\n    y_np = np.array(y_labels)\n\n    auc_c = calculate_auc(s_c_np, y_np)\n    auc_h = calculate_auc(s_h_np, y_np)\n\n    ef_c = calculate_ef(s_c_np, y_np, f)\n    ef_h = calculate_ef(s_h_np, y_np, f)\n    \n    jaccard_k = calculate_jaccard(s_c_np, s_h_np, k)\n\n    return [auc_c, auc_h, ef_c, ef_h, jaccard_k]\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the calculations, and prints the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 12,\n            \"s_C\": [-9.8, -7.3, -10.5, -6.8, -8.1, -9.1, -7.0, -8.7, -6.5, -10.2, -7.9, -8.3],\n            \"s_H\": [-9.0, -7.5, -9.8, -7.2, -8.4, -8.9, -7.1, -8.5, -6.8, -9.7, -7.6, -8.0],\n            \"y\": [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0],\n            \"f\": 0.25,\n            \"K\": 5\n        },\n        {\n            \"N\": 10,\n            \"s_C\": [-11.0, -10.5, -10.2, -9.8, -8.0, -7.9, -7.5, -7.2, -7.0, -6.8],\n            \"s_H\": [-7.5, -7.4, -7.3, -7.2, -10.0, -9.8, -9.5, -9.2, -9.0, -8.8],\n            \"y\": [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],\n            \"f\": 0.2,\n            \"K\": 3\n        },\n        {\n            \"N\": 8,\n            \"s_C\": [-8.0, -9.0, -8.0, -9.0, -8.0, -8.0, -9.0, -8.0],\n            \"s_H\": [-8.5, -8.5, -8.5, -8.5, -8.5, -8.5, -8.5, -8.5],\n            \"y\": [0, 1, 0, 1, 0, 0, 1, 0],\n            \"f\": 0.5,\n            \"K\": 4\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result_tuple = process_case(case[\"s_C\"], case[\"s_H\"], case[\"y\"], case[\"f\"], case[\"K\"])\n        all_results.append(result_tuple)\n    \n    # Manually construct the output string to match the required format without spaces.\n    formatted_results = []\n    for res_tuple in all_results:\n        # Format each float to 6 decimal places and join into a string like \"[x.xxxxxx,y.yyyyyy,...]\"\n        formatted_tuple_str = f\"[{','.join([f'{v:.6f}' for v in res_tuple])}]\"\n        formatted_results.append(formatted_tuple_str)\n    \n    # Join the individual case strings into the final list-of-lists format \"[[...],[...]]\"\n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "2440123"}, {"introduction": "Different docking programs often produce conflicting rankings for the same set of ligands due to their distinct scoring functions and search algorithms. A powerful strategy to overcome this variability and improve predictive accuracy is consensus scoring, which intelligently combines the results from multiple methods. This exercise challenges you to implement a robust consensus scoring protocol that normalizes and aggregates ranks from different programs, a technique widely used to increase confidence in hit selection [@problem_id:2440194].", "problem": "You are given three independent docking score lists for the same set of ligands produced by three different programs. Each program’s raw score has a known directionality indicating whether a higher or lower value is better. Define a consensus method that transforms scores into a common, order-preserving, unitless scale and then aggregates them into a single consensus score to re-rank the ligands. Implement a program that applies this method to multiple test cases and returns, for each case, the integer identifiers of the top-$k$ ligands in descending consensus order.\n\nMathematical specification of the consensus method:\n\n- Let there be $n$ ligands indexed by $i \\in \\{1,\\dots,n\\}$ and three programs indexed by $j \\in \\{1,2,3\\}$. For program $j$, you are given raw scores $s_{ij} \\in \\mathbb{R}$ and a direction indicator $d_j \\in \\{-1,+1\\}$, where $d_j = +1$ means “higher is better” and $d_j = -1$ means “lower is better.”\n- Define orientation-corrected scores $t_{ij} = d_j \\cdot s_{ij}$ so that, for all programs, larger $t_{ij}$ indicates better performance.\n- Define the rank $r_{ij}$ for ligand $i$ in program $j$ as the “midrank” under sorting by decreasing $t_{\\cdot j}$. Concretely, if all $t_{\\cdot j}$ are sorted in decreasing order, ties share the average of the positions they occupy. Thus the best value(s) receive rank $1$, the worst rank $n$, and ties receive the average of consecutive integer ranks they span.\n- Map each rank to a unit interval score via\n$$\nq_{ij} =\n\\begin{cases}\n1 - \\dfrac{r_{ij} - 1}{n - 1}, & \\text{if } n \\ge 2,\\\\\n1, & \\text{if } n = 1.\n\\end{cases}\n$$\nThis makes $q_{ij} \\in [0,1]$ with $1$ for the best and $0$ for the worst within each program.\n- Let nonnegative weights $w_j \\ge 0$ be provided. Let $S = \\sum_{j=1}^{3} w_j$. Define normalized weights\n$$\n\\tilde{w}_j =\n\\begin{cases}\n\\dfrac{w_j}{S}, & \\text{if } S > 0,\\\\\n\\dfrac{1}{3}, & \\text{if } S = 0.\n\\end{cases}\n$$\n- Define the consensus score for ligand $i$ as\n$$\nc_i = \\sum_{j=1}^{3} \\tilde{w}_j \\, q_{ij}.\n$$\n- Define a strict total order on ligands as follows. Fix a tie tolerance $\\varepsilon = 10^{-12}$. For two ligands $i$ and $k$:\n  1. If $c_i > c_k + \\varepsilon$, then $i$ precedes $k$; if $c_k > c_i + \\varepsilon$, then $k$ precedes $i$.\n  2. Otherwise, compare the rank triples lexicographically: $(r_{i1}, r_{i2}, r_{i3})$ versus $(r_{k1}, r_{k2}, r_{k3})$, preferring the smaller at the first index $j$ where $|r_{ij} - r_{kj}| > \\varepsilon$.\n  3. If still tied, prefer the smaller ligand identifier $i$.\n\nYour program must implement the above definitions exactly and, for each test case, return the top-$k$ ligand identifiers as a list of integers.\n\nTest suite:\n\n- Test case A (general case, mixed directions, normalized weights, $k = 3$):\n  - $n = 5$, ligand identifiers $1$ to $5$.\n  - Program $1$ scores (lower is better): $[-8.5, -10.2, -7.1, -9.0, -6.6]$.\n  - Program $2$ scores (higher is better): $[62.0, 55.0, 78.0, 70.0, 65.0]$.\n  - Program $3$ scores (lower is better): $[-7.8, -8.0, -6.5, -9.5, -7.0]$.\n  - Directions $(d_1, d_2, d_3) = (-1, +1, -1)$.\n  - Weights $(w_1, w_2, w_3) = (0.5, 0.3, 0.2)$.\n  - $k = 3$.\n\n- Test case B (weight normalization and tie handling via ranks, $k = 4$):\n  - $n = 4$, ligand identifiers $1$ to $4$.\n  - Program $1$ scores (lower is better): $[-9.0, -8.0, -7.0, -6.0]$.\n  - Program $2$ scores (higher is better): $[50.0, 80.0, 60.0, 40.0]$.\n  - Program $3$ scores (lower is better, with ties): $[-8.5, -8.5, -6.0, -6.0]$.\n  - Directions $(d_1, d_2, d_3) = (-1, +1, -1)$.\n  - Weights $(w_1, w_2, w_3) = (2.0, 1.0, 1.0)$.\n  - $k = 4$.\n\n- Test case C (all-equal scores in one program, ties in another, $k = 3$):\n  - $n = 3$, ligand identifiers $1$ to $3$.\n  - Program $1$ scores (lower is better, all equal): $[-7.0, -7.0, -7.0]$.\n  - Program $2$ scores (higher is better): $[50.0, 60.0, 70.0]$.\n  - Program $3$ scores (lower is better, with ties): $[-9.0, -8.0, -8.0]$.\n  - Directions $(d_1, d_2, d_3) = (-1, +1, -1)$.\n  - Weights $(w_1, w_2, w_3) = (1.0, 1.0, 1.0)$.\n  - $k = 3$.\n\n- Test case D (single-ligand boundary, zero-sum weights defaulting to equal, $k = 1$):\n  - $n = 1$, ligand identifier $1$.\n  - Program $1$ scores (lower is better): $[-8.0]$.\n  - Program $2$ scores (higher is better): $[65.0]$.\n  - Program $3$ scores (lower is better): $[-6.5]$.\n  - Directions $(d_1, d_2, d_3) = (-1, +1, -1)$.\n  - Weights $(w_1, w_2, w_3) = (0.0, 0.0, 0.0)$.\n  - $k = 1$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results for all test cases as a single bracketed list, where each element is itself a bracketed, comma-separated list of the top-$k$ ligand identifiers for that test case, with no additional whitespace. For example, a valid format with two hypothetical results is $[[1,2],[3,4,5]]$.", "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded in the domain of computational drug discovery, specifically concerning consensus scoring methods for virtual screening. The problem is well-posed, providing a complete and unambiguous mathematical specification for an algorithm. All terms are precisely defined, and the provided test cases are self-contained and consistent with the definitions. The task is to implement the specified algorithm and apply it to the test cases.\n\nThe objective is to construct a consensus ranking of ligands from multiple, heterogeneous scoring lists. The procedure is a multi-step data fusion process, which will be implemented as follows.\n\nLet there be $n$ ligands, indexed by $i \\in \\{1, \\dots, n\\}$, and $J=3$ scoring programs, indexed by $j \\in \\{1, \\dots, J\\}$. For each ligand $i$ and program $j$, we are given a raw score $s_{ij}$.\n\nStep 1: Orientation-Corrected Scores\nThe raw scores $s_{ij}$ from different programs may have different meanings; for some, higher values are better, while for others, lower values are better. A direction indicator $d_j \\in \\{-1, +1\\}$ is provided for each program. We unify the scores by defining an orientation-corrected score $t_{ij}$ such that a higher value is always better:\n$$t_{ij} = d_j \\cdot s_{ij}$$\nThis ensures that for all programs, the ranking will be based on descending order of $t_{ij}$.\n\nStep 2: Ranking\nTo make scores from different programs comparable, we transform them onto a common scale. The first part of this transformation involves converting the scores into ranks. For each program $j$, we rank the ligands based on their $t_{ij}$ values in descending order. When scores are tied, we use the \"midrank\" method, where tied items receive the average of the ranks they would occupy. Let $r_{ij}$ be the rank of ligand $i$ according to program $j$. The best-scoring ligand(s) receive a rank of $1$ (or an average rank starting from $1$), and the worst-scoring receive a rank of $n$ (or an average rank ending at $n$).\n\nStep 3: Rank-to-Score Normalization\nThe ranks $r_{ij}$ are on a scale from $1$ to $n$, but they still depend on the number of ligands $n$. To create a truly unitless score, we map each rank to the interval $[0, 1]$. The normalized score $q_{ij}$ for ligand $i$ in program $j$ is defined as:\n$$\nq_{ij} =\n\\begin{cases}\n1 - \\dfrac{r_{ij} - 1}{n - 1}, & \\text{if } n \\ge 2,\\\\\n1, & \\text{if } n = 1.\n\\end{cases}\n$$\nThis transformation preserves the order established by the ranks. The best rank ($r_{ij}=1$) maps to $q_{ij}=1$, and the worst rank ($r_{ij}=n$) maps to $q_{ij}=0$.\n\nStep 4: Weight Normalization\nEach program $j$ is assigned a non-negative weight $w_j \\ge 0$, reflecting its perceived reliability or importance. These weights are normalized to sum to $1$ to ensure the final consensus score remains on a consistent scale. Let $S = \\sum_{j=1}^{J} w_j$. The normalized weights $\\tilde{w}_j$ are:\n$$\n\\tilde{w}_j =\n\\begin{cases}\n\\dfrac{w_j}{S}, & \\text{if } S > 0,\\\\\n\\dfrac{1}{J}, & \\text{if } S = 0.\n\\end{cases}\n$$\nThe special case for $S=0$ provides a default of equal weighting when no explicit weights are given.\n\nStep 5: Consensus Score Calculation\nThe final consensus score $c_i$ for each ligand $i$ is the weighted average of its normalized scores $q_{ij}$ across all programs:\n$$c_i = \\sum_{j=1}^{J} \\tilde{w}_j \\, q_{ij}$$\nThis score aggregates the performance of a ligand across all evaluation methods into a single metric.\n\nStep 6: Final Ranking and Tie-Breaking\nA strict total order for ranking the ligands is established using a hierarchical set of rules. For any two ligands $i$ and $k$:\n1. The primary sorting criterion is the consensus score $c_i$. A ligand $i$ is ranked higher than ligand $k$ if $c_i > c_k + \\varepsilon$, where $\\varepsilon = 10^{-12}$ is a numerical tolerance to handle floating-point comparisons.\n2. If the consensus scores are considered equal (i.e., $|c_i - c_k| \\le \\varepsilon$), a secondary tie-breaking rule is applied. The rank vectors $(r_{i1}, r_{i2}, \\dots, r_{iJ})$ and $(r_{k1}, r_{k2}, \\dots, r_{kJ})$ are compared lexicographically. The ligand with the smaller rank at the first differing position is ranked higher. The comparison $|r_{ij} - r_{kj}| > \\varepsilon$ is used.\n3. If the rank vectors are also identical, a final tie is broken by the ligand identifier. The ligand with the smaller integer identifier is ranked higher.\n\nThis methodology provides a robust and deterministic procedure for producing a final, unified ranking of ligands from multiple sources. The implementation will follow these steps precisely for each provided test case to determine the top-$k$ ligands.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import rankdata\nfrom functools import cmp_to_key\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and print results for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Test Case A\",\n            \"ligand_ids\": list(range(1, 6)),\n            \"scores\": [\n                [-8.5, -10.2, -7.1, -9.0, -6.6],\n                [62.0, 55.0, 78.0, 70.0, 65.0],\n                [-7.8, -8.0, -6.5, -9.5, -7.0],\n            ],\n            \"directions\": [-1, 1, -1],\n            \"weights\": [0.5, 0.3, 0.2],\n            \"k\": 3,\n        },\n        {\n            \"name\": \"Test Case B\",\n            \"ligand_ids\": list(range(1, 5)),\n            \"scores\": [\n                [-9.0, -8.0, -7.0, -6.0],\n                [50.0, 80.0, 60.0, 40.0],\n                [-8.5, -8.5, -6.0, -6.0],\n            ],\n            \"directions\": [-1, 1, -1],\n            \"weights\": [2.0, 1.0, 1.0],\n            \"k\": 4,\n        },\n        {\n            \"name\": \"Test Case C\",\n            \"ligand_ids\": list(range(1, 4)),\n            \"scores\": [\n                [-7.0, -7.0, -7.0],\n                [50.0, 60.0, 70.0],\n                [-9.0, -8.0, -8.0],\n            ],\n            \"directions\": [-1, 1, -1],\n            \"weights\": [1.0, 1.0, 1.0],\n            \"k\": 3,\n        },\n        {\n            \"name\": \"Test Case D\",\n            \"ligand_ids\": [1],\n            \"scores\": [\n                [-8.0],\n                [65.0],\n                [-6.5],\n            ],\n            \"directions\": [-1, 1, -1],\n            \"weights\": [0.0, 0.0, 0.0],\n            \"k\": 1,\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_case(\n            case[\"ligand_ids\"],\n            case[\"scores\"],\n            case[\"directions\"],\n            case[\"weights\"],\n            case[\"k\"],\n        )\n        all_results.append(result)\n\n    # Format output as a single string per problem specification\n    # e.g., [[1,2],[3,4,5]]\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_case(ligand_ids, scores, directions, weights, k):\n    \"\"\"\n    Implements the consensus scoring and ranking method for a single test case.\n    \"\"\"\n    scores_np = np.array(scores, dtype=float).T\n    n_ligands, n_programs = scores_np.shape\n    \n    # Step 1: Orientation-corrected scores\n    directions_np = np.array(directions, dtype=float)\n    t_scores = scores_np * directions_np\n\n    # Step 2: Ranking\n    ranks = np.zeros_like(t_scores)\n    for j in range(n_programs):\n        # rankdata ranks ascending, so we rank the negative of the scores\n        # for descending rank.\n        ranks[:, j] = rankdata(-t_scores[:, j], method='average')\n\n    # Step 3: Rank-to-Score Normalization\n    if n_ligands >= 2:\n        q_scores = 1 - (ranks - 1) / (n_ligands - 1)\n    else: # n_ligands == 1\n        q_scores = np.ones_like(ranks)\n\n    # Step 4: Weight Normalization\n    weights_np = np.array(weights, dtype=float)\n    sum_weights = np.sum(weights_np)\n    if sum_weights > 0:\n        norm_weights = weights_np / sum_weights\n    else:\n        norm_weights = np.full(n_programs, 1.0 / n_programs)\n\n    # Step 5: Consensus Score Calculation\n    consensus_scores = np.dot(q_scores, norm_weights)\n\n    # Step 6: Final Ranking and Tie-Breaking\n    # Create a list of tuples (ligand_id, consensus_score, rank_tuple) for sorting\n    ligand_data = []\n    for i in range(n_ligands):\n        ligand_data.append((ligand_ids[i], consensus_scores[i], tuple(ranks[i, :])))\n    \n    # Define the custom comparison function for sorting\n    def compare_ligands(item1, item2):\n        id1, c1, r1_tuple = item1\n        id2, c2, r2_tuple = item2\n        epsilon = 1e-12\n\n        # Primary sort: consensus score (descending)\n        if c1 > c2 + epsilon:\n            return -1\n        if c2 > c1 + epsilon:\n            return 1\n\n        # Secondary sort: rank vectors (lexicographical, ascending)\n        for r1_j, r2_j in zip(r1_tuple, r2_tuple):\n            if r1_j < r2_j - epsilon:\n                return -1\n            if r2_j < r1_j - epsilon:\n                return 1\n\n        # Tertiary sort: ligand ID (ascending)\n        if id1 < id2:\n            return -1\n        if id2 < id1:\n            return 1\n        \n        return 0\n\n    # Sort using the custom comparison function\n    sorted_ligands = sorted(ligand_data, key=cmp_to_key(compare_ligands))\n    \n    # Extract the top-k ligand identifiers\n    top_k_ids = [item[0] for item in sorted_ligands[:k]]\n    \n    return top_k_ids\n\n# Execute the solver\nsolve()\n```", "id": "2440194"}]}