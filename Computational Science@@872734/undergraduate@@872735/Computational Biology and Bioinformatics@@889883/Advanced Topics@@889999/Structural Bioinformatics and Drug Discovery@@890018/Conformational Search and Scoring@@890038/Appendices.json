{"hands_on_practices": [{"introduction": "A robust scoring function must encapsulate the fundamental physical principles that drive protein folding. Among the most crucial of these is solvation, which describes the energetic consequences of moving a part of the protein away from water. This exercise challenges you to apply your thermodynamic intuition to the `fa_sol` term in the Rosetta energy function, exploring how it models both the favorable burial of hydrophobic residues and the prohibitive penalty of burying polar ones [@problem_id:2381452].", "problem": "You are using the Rosetta all-atom energy function, which includes a physically motivated implicit solvation free energy term named \"fa_sol\" based on the Lazaridis–Karplus (LK) Gaussian solvent exclusion model. Consider two amino acid side chains: leucine (a nonpolar, hydrophobic side chain) and aspartate (a negatively charged, polar side chain). For each side chain, consider two environments within a folded protein: a highly surface-exposed environment with large solvent-accessible surface area (SASA) and an interior, tightly packed environment with minimal SASA and no internal hydrogen bonds or salt bridges. Assume that only the \"fa_sol\" term is being considered, and that all other energy terms (electrostatics, hydrogen bonding, torsional entropy, etc.) are ignored for the purpose of this question.\n\nStarting from the fundamental thermodynamic facts that (i) polar and charged groups are stabilized by favorable interactions with water, (ii) nonpolar groups experience the hydrophobic effect whereby removing water from their vicinity reduces the system free energy, and (iii) an implicit solvation term like LK quantifies the free energy change of solvation upon occlusion of water by nearby solute atoms with bulk solvent taken as a reference state, analyze how moving a side chain from surface exposure to burial changes its contribution to the \"fa_sol\" term.\n\nWhich option best describes the sign and relative magnitude of the \"fa_sol\" contributions for leucine and aspartate in these two environments?\n\nA. For leucine, \"fa_sol\" is strongly favorable (large negative) when surface-exposed and near $0$ when buried; for aspartate, \"fa_sol\" is strongly favorable (large negative) when buried and near $0$ when surface-exposed.\n\nB. For both leucine and aspartate, the \"fa_sol\" contribution is approximately $0$ regardless of burial because solvation is dominated by other terms in Rosetta.\n\nC. For leucine, \"fa_sol\" is near $0$ when surface-exposed and becomes strongly negative (favorable) upon burial; for aspartate lacking internal hydrogen bonds or salt bridges, \"fa_sol\" is near $0$ when surface-exposed and becomes strongly positive (unfavorable) upon burial.\n\nD. For leucine, \"fa_sol\" becomes positive (unfavorable) upon burial only if it makes tight van der Waals contacts; for aspartate, \"fa_sol\" becomes negative (favorable) upon burial if it loses rotamer entropy.", "solution": "We begin from thermodynamic first principles and the construction of an implicit solvation term. The free energy of solvation reflects interactions between solute groups and water. A polar or charged group forms favorable electrostatic and hydrogen-bonding interactions with water, lowering the free energy of the solvated state; conversely, a nonpolar group experiences the hydrophobic effect, whereby water organization around it is unfavorable, and removing water from its vicinity (e.g., by burying it against other nonpolar groups) reduces the system free energy. In a Gaussian solvent exclusion model such as Lazaridis–Karplus (LK), the solvation free energy change upon moving from bulk solvent into a protein environment is estimated by how neighboring atoms occlude solvent around each atom; the reference state is taken as bulk solvent, so a fully exposed atom contributes approximately $0$ to the solvation energy, and burial changes the free energy according to that atom’s solvation character (hydrophobic versus polar/charged).\n\nApplying these principles:\n\n- Leucine is nonpolar. In bulk solvent (surface-exposed), it is surrounded by water; in an LK-like model with bulk solvent reference, this corresponds to a contribution near $0$ to \"fa_sol\". When leucine is buried by neighboring protein atoms, water is excluded from its vicinity; removing unfavorable water contact leads to a decrease in free energy, so the solvation term becomes more favorable (more negative). Therefore, burial drives \"fa_sol\" to values $<0$ (negative), with magnitude depending on the extent of occlusion.\n\n- Aspartate is negatively charged and polar. In bulk solvent (surface-exposed), it forms favorable interactions with water; in the LK framework with bulk solvent as reference, the exposed state again corresponds to near $0$ contribution because there is minimal occlusion by protein. When aspartate is buried without forming compensating internal hydrogen bonds or salt bridges, water is excluded and the residue loses favorable solvation, producing a desolvation penalty. Hence, the solvation term becomes positive (unfavorable), with magnitude increasing with the extent of burial. Other Rosetta terms (e.g., hydrogen bonding, electrostatics) may compensate in realistic scenarios, but by assumption these are neglected here.\n\nWith this analysis, we examine the options:\n\nA. Claims leucine is strongly favorable when surface-exposed and near $0$ when buried, and aspartate is favorable when buried. This reverses the hydrophobic effect for leucine and the desolvation penalty for aspartate. Incorrect.\n\nB. Claims \"fa_sol\" is approximately $0$ regardless of burial for both residue types. This contradicts the core role of \"fa_sol,\" which penalizes burial of polar/charged atoms and rewards burial of nonpolar atoms by modeling solvent occlusion. Incorrect.\n\nC. States leucine is near $0$ when surface-exposed and strongly negative upon burial, and aspartate (without internal hydrogen bonds or salt bridges) is near $0$ when surface-exposed and strongly positive upon burial. This matches the thermodynamic reasoning and the LK reference choice. Correct.\n\nD. Attributes sign changes of \"fa_sol\" to van der Waals contacts for leucine and rotamer entropy loss for aspartate. Van der Waals and entropy are separate terms in Rosetta and do not determine the sign of \"fa_sol\"; furthermore, the asserted directions contradict the hydrophobic and desolvation expectations. Incorrect.\n\nTherefore, the correct choice is C.", "answer": "$$\\boxed{C}$$", "id": "2381452"}, {"introduction": "Identifying the native structure of a protein is not just about having an accurate energy function; it is also about having an effective search strategy to navigate the vast conformational space. Fragment-based assembly is a powerful search technique that accelerates exploration by using pieces of known protein structures. This thought experiment [@problem_id:2381444] reveals the critical dependence of the search outcome on the sampling library, demonstrating why a good scoring function is powerless if the search algorithm cannot access the right conformations.", "problem": "In fragment-based protein structure prediction within the Rosetta framework, short backbone fragments (typically $3$-mers and $9$-mers) drawn from known structures are inserted into an evolving model during a Monte Carlo (MC) search guided by a scoring function. Consider a hypothetical ab initio folding run for a target protein whose native structure is all-$\\beta$. By mistake, the fragment library was constructed exclusively from a nonredundant set of all-$\\alpha$ proteins, so that the fragment $\\phi$ and $\\psi$ torsion angle distributions predominantly occupy the $\\alpha$-helical basin. All other parameters (temperature schedule, move frequencies, and scoring functions in low-resolution and all-atom stages) are standard. Which of the following outcomes is most likely?\n\nA. The search will be strongly biased toward $\\alpha$-helical conformations; it will rarely sample extended $\\beta$-strand geometries necessary for $\\beta$-sheets; as a result, decoys will concentrate in helical topologies with relatively poor all-atom and low-resolution scores compared to the native-like $\\beta$ fold, and the run will show poor convergence to low root-mean-square deviation (RMSD) models.\n\nB. The Rosetta all-atom scoring function contains explicit $\\beta$-sheet hydrogen-bonding terms that will force fragment-inserted helices to unwind and rearrange into $\\beta$-sheets, so the search will still efficiently find the correct fold with similar convergence as with a matched library.\n\nC. Because fragments are short ($3$-mers and $9$-mers), their secondary structure content is irrelevant; given enough Monte Carlo steps, the sampling remains effectively unbiased and the correct $\\beta$ topology will be reached with unaffected efficiency.\n\nD. The move set becomes invalid because $\\phi$ and $\\psi$ torsion angle limits differ between $\\alpha$ and $\\beta$ regions, causing frequent violations that are rejected deterministically; therefore, the Markov chain cannot proceed and the simulation terminates early.", "solution": "The problem statement is critically evaluated and found to be valid. It describes a scientifically plausible scenario in computational protein structure prediction that is well-posed, objective, and self-contained. The question concerns the predictable outcome of using a conformationally biased move set in a Monte Carlo search, which is a standard topic in the field.\n\nThe problem describes an *ab initio* protein folding simulation using the Rosetta framework. In this method, the conformational space is explored using a Monte Carlo (MC) search. A key move type is the insertion of backbone torsion angle fragments, typically of length $3$ and $9$ residues ($3$-mers and $9$-mers), extracted from a library of known protein structures. The acceptance of a move is governed by a scoring function and the Metropolis criterion.\n\nThe core of the problem lies in the conflict between two components of the simulation:\n1.  **The Sampling Bias:** The fragment library is constructed exclusively from all-$\\alpha$ proteins. This means that the torsion angles ($\\phi$, $\\psi$) of the available fragments will be predominantly in the $\\alpha$-helical region of the Ramachandran plot (approximately $\\phi \\approx -60^\\circ$, $\\psi \\approx -40^\\circ$). The primary method for making significant changes to the backbone conformation is therefore heavily biased to produce and maintain $\\alpha$-helical secondary structures.\n2.  **The Target Structure:** The native structure of the target protein is all-$\\beta$. This means its constituent residues should adopt torsion angles in the $\\beta$-strand region of the Ramachandran plot (approximately $\\phi \\approx -120^\\circ$, $\\psi \\approx +135^\\circ$). The global minimum of the energy landscape, as defined by the Rosetta scoring function for this protein, corresponds to this all-$\\beta$ fold.\n\nThe simulation's outcome is determined by the interplay of this biased sampling and the energy landscape. The MC search will proceed as follows:\n- The fragment insertion moves will consistently propose local conformations with $\\alpha$-helical character. This will very effectively sample helical topologies.\n- The search will be unable to efficiently sample extended $\\beta$-strand conformations because the required $(\\phi, \\psi)$ angles are systematically absent from the move set provided by the fragment library. While other small-perturbation moves (`small` and `shear`) exist, they are insufficient to transition from a compact helical globule to an extended $\\beta$-sheet topology on a realistic simulation timescale.\n- The generated conformations (\"decoys\") will therefore be predominantly helical.\n- The Rosetta scoring function (both low-resolution and all-atom) is designed to recognize the energetic favorability of a native fold. For an all-$\\beta$ protein, the scoring function will correctly assign a much lower (better) energy to the native $\\beta$-sheet topology than to any non-native helical arrangement. The sampled helical decoys will lack the specific long-range hydrogen bonding network and tertiary packing that stabilize the native $\\beta$-sheet, resulting in high (poor) scores.\n- The simulation will fail to converge. An energy-versus-RMSD plot would not show the characteristic funnel shape where the lowest-energy structures have low root-mean-square deviation (RMSD) from the native state. Instead, the lowest-energy structures found by the search will be non-native helical compact states with high RMSD.\n\nWith this understanding, we evaluate the given options:\n\n**A. The search will be strongly biased toward $\\alpha$-helical conformations; it will rarely sample extended $\\beta$-strand geometries necessary for $\\beta$-sheets; as a result, decoys will concentrate in helical topologies with relatively poor all-atom and low-resolution scores compared to the native-like $\\beta$ fold, and the run will show poor convergence to low root-mean-square deviation (RMSD) models.**\nThis statement is a precise and accurate description of the expected outcome. The sampling is biased by the fragment library, preventing access to the correct region of conformational space. The resulting decoys are non-native and thus have poor scores. The overall prediction fails, as indicated by the lack of convergence to low-RMSD structures.\n**Verdict: Correct.**\n\n**B. The Rosetta all-atom scoring function contains explicit $\\beta$-sheet hydrogen-bonding terms that will force fragment-inserted helices to unwind and rearrange into $\\beta$-sheets, so the search will still efficiently find the correct fold with similar convergence as with a matched library.**\nThis statement is incorrect. The scoring function evaluates conformations; it does not \"force\" rearrangements across large kinetic barriers. The simulation explores conformational space via a path defined by the available moves. If the moves do not lead toward the correct fold, the scoring function alone cannot compensate. The low-resolution search will produce poor starting models for the all-atom stage, and all-atom refinement uses local perturbations, which are incapable of converting an entire protein's topology from all-$\\alpha$ to all-$\\beta$. The claim of \"efficiently\" finding the correct fold with \"similar convergence\" is false.\n**Verdict: Incorrect.**\n\n**C. Because fragments are short ($3$-mers and $9$-mers), their secondary structure content is irrelevant; given enough Monte Carlo steps, the sampling remains effectively unbiased and the correct $\\beta$ topology will be reached with unaffected efficiency.**\nThis statement is fundamentally flawed. The local secondary structure information encoded in fragments is the very reason for their use. It dramatically accelerates the search for nativelike local conformations. Claiming their content is \"irrelevant\" is contrary to the entire principle of fragment-based assembly. While theoretically an infinitely long MC run could sample any state, in practice, the strong bias makes the probability of sampling the correct fold vanishingly small within any feasible simulation time. The sampling is not \"effectively unbiased\"; it is severely biased, and the efficiency will be drastically reduced to the point of complete failure.\n**Verdict: Incorrect.**\n\n**D. The move set becomes invalid because $\\phi$ and $\\psi$ torsion angle limits differ between $\\alpha$ and $\\beta$ regions, causing frequent violations that are rejected deterministically; therefore, the Markov chain cannot proceed and the simulation terminates early.**\nThis statement misunderstands the Rosetta algorithm. There are no hard \"invalid\" limits on torsion angles that would cause deterministic rejection and simulation termination. A proposed move resulting in unfavorable torsion angles (e.g., in a disallowed region of the Ramachandran plot) receives a high energy penalty from the corresponding score term (e.g., `rama`). This makes the move's acceptance highly improbable under the Metropolis criterion, but it is a probabilistic, not deterministic, process. The Markov chain proceeds, but it is trapped in an unproductive region of the conformational space. The simulation does not terminate.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "2381444"}, {"introduction": "Theory becomes tangible when you build a model yourself. This final practice is a capstone exercise where you will synthesize the concepts of scoring and search by implementing a simplified predictive model from scratch. You will define a multi-term energy function and perform a grid search to predict the structural shift caused by a post-translational modification [@problem_id:2381408]. This hands-on coding challenge will solidify your understanding of how computational tools connect a change in sequence to a change in structure and energy.", "problem": "You are asked to formalize a simplified conformational search and scoring problem inspired by the Rosetta modeling framework. Your program must simulate how a residue parameter file and a phosphorylation Patch would alter a residue’s backbone conformational preference and predicted minimum-energy conformation.\n\nScientific foundation. You must start from the principle that, in knowledge-based modeling frameworks such as Rosetta, the predicted conformation is the one that minimizes a total potential energy. Specifically, if $E(\\boldsymbol{\\theta}; \\boldsymbol{\\lambda})$ is a scalar energy over conformation variables $\\boldsymbol{\\theta}$ with parameters $\\boldsymbol{\\lambda}$, then the predicted conformation is any $\\boldsymbol{\\theta}^{\\star}$ minimizing $E$. A change in chemical identity or post-translational state can be represented as a change in $\\boldsymbol{\\lambda}$ via a residue parameter file (the base identity) and a Patch (a modification overlay). Thus, phosphorylation by adding a phosphate group to serine can be modeled as a change in statistical torsion preferences and additional physicochemical terms that reflect steric bulk and electrostatic interactions.\n\nYou will implement a coarse-grained, self-consistent scoring function over the backbone dihedral angles at a single residue, $\\phi$ and $\\psi$, measured in degrees. The total energy is the sum of interpretable components that are abstractions of common Rosetta terms: backbone statistical preferences, steric effects from added bulk, and an environmental directional electrostatic or hydrogen-bond like interaction. Your program must construct a base “Serine params” and a “phospho-Serine Patch” in-code as data structures and apply them to compute energies.\n\nDefinitions to implement:\n- Angles are in degrees. Energies are in kilocalories per mole.\n- The backbone statistical preference is modeled as a mixture of two anisotropic Gaussian wells representing the $\\alpha$-helical and $\\beta$-strand basins. For residue type $r \\in \\{\\mathrm{Ser}, \\mathrm{pSer}\\}$,\n  $$\n  E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;=\\; -d_{\\alpha}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\alpha}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\alpha}}{\\sigma_{\\psi}}\\right)^{2}\\right)\n  \\;-\\; d_{\\beta}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\beta}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\beta}}{\\sigma_{\\psi}}\\right)^{2}\\right).\n  $$\n  Use centers $\\left(\\mu_{\\phi,\\alpha},\\mu_{\\psi,\\alpha}\\right)=(-60,-45)$ and $\\left(\\mu_{\\phi,\\beta},\\mu_{\\psi,\\beta}\\right)=(-120,130)$ (angles in degrees), and widths $\\sigma_{\\phi}=\\sigma_{\\psi}=25$ (degrees). The base Serine (“params”) well depths are $d_{\\alpha}^{(\\mathrm{Ser})}=3.0$ and $d_{\\beta}^{(\\mathrm{Ser})}=2.0$. The phospho-Serine (“Patch”-modified) well depths are $d_{\\alpha}^{(\\mathrm{pSer})}=1.2$ and $d_{\\beta}^{(\\mathrm{pSer})}=3.2$.\n- The phosphorylation Patch also adds a steric penalty term that penalizes adopting $\\alpha$-helical $\\phi$ due to phosphate bulk:\n  $$\n  E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) \\;=\\; + s_{0} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi - \\mu_{\\phi,\\mathrm{steric}}}{\\sigma_{\\phi,\\mathrm{steric}}}\\right)^{2}\\right),\n  $$\n  with $\\mu_{\\phi,\\mathrm{steric}}=-60$, $\\sigma_{\\phi,\\mathrm{steric}}=15$, and $s_{0}=0.8$. For unmodified Serine this term is $0$.\n- The environment may provide a favorable directional interaction for the phosphate with a nearby positive charge that is approximately captured by a Gaussian in $\\psi$ around an environment-specified target $\\psi_{0}$:\n  $$\n  E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\;=\\; - k_{\\mathrm{el}} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\psi - \\psi_{0}}{\\sigma_{\\psi,\\mathrm{el}}}\\right)^{2}\\right),\n  $$\n  with $\\sigma_{\\psi,\\mathrm{el}}=25$. This term models an electrostatic or hydrogen-bond like directional preference in a coarse way. If no nearby positive charge exists, set $k_{\\mathrm{el}}=0$. For unmodified Serine this term is $0$.\n- The total energy is\n  $$\n  E_{\\mathrm{total}}^{(r)}(\\phi,\\psi) \\;=\\; E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;+\\; \\mathbb{1}[r=\\mathrm{pSer}] \\left( E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) + E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\right).\n  $$\n  Here $\\mathbb{1}[\\cdot]$ is $1$ if the condition is true and $0$ otherwise.\n\nComputational task:\n- Construct in-code a “params” data structure for Serine holding $d_{\\alpha}^{(\\mathrm{Ser})}$ and $d_{\\beta}^{(\\mathrm{Ser})}$ and the shared Gaussian centers and widths. Construct in-code a phosphorylation “Patch” that, when applied to the Serine params, yields pSer parameters $d_{\\alpha}^{(\\mathrm{pSer})}$ and $d_{\\beta}^{(\\mathrm{pSer})}$ and adds the two terms $E_{\\mathrm{steric}}^{(\\mathrm{pSer})}$ and $E_{\\mathrm{env}}^{(\\mathrm{pSer})}$ with the constants above. Applying the Patch must not change any other aspect of the scoring.\n- Implement a grid search over $\\phi \\in \\{-180,-175,\\ldots,180\\}$ and $\\psi \\in \\{-180,-175,\\ldots,180\\}$, both in degrees, to find the minimum-energy conformation for Ser and for pSer under the same environment parameters.\n- For each test case below, compute:\n  1. The energy-minimizing backbone dihedrals $(\\phi^{\\star}_{\\mathrm{Ser}},\\psi^{\\star}_{\\mathrm{Ser}})$ and $(\\phi^{\\star}_{\\mathrm{pSer}},\\psi^{\\star}_{\\mathrm{pSer}})$, in degrees.\n  2. The signed, wrapped angular differences $\\Delta \\phi$ and $\\Delta \\psi$, each wrapped into $(-180,180]$ by the map $\\Delta \\theta \\mapsto \\left((\\Delta \\theta + 180) \\bmod 360\\right) - 180$, where $\\Delta \\theta = \\theta^{\\star}_{\\mathrm{pSer}} - \\theta^{\\star}_{\\mathrm{Ser}}$.\n  3. The energy change $\\Delta E = E_{\\min}^{(\\mathrm{pSer})} - E_{\\min}^{(\\mathrm{Ser})}$, in kilocalories per mole.\n\nTest suite (three environments):\n- Case $1$ (happy path): nearby positive charge aligned with $\\alpha$-like geometry. Use $k_{\\mathrm{el}}=1.5$ and $\\psi_{0}=-60$.\n- Case $2$ (no directional stabilization): no nearby positive charge. Use $k_{\\mathrm{el}}=0.0$ and $\\psi_{0}=0.0$.\n- Case $3$ (competing stabilization near $\\beta$): weaker positive charge aligned with $\\beta$-like geometry. Use $k_{\\mathrm{el}}=0.9$ and $\\psi_{0}=130.0$.\n\nRequired output format:\n- Your program must produce a single line containing a flat list with $9$ numbers: $\\left[\\Delta \\phi_{1},\\Delta \\psi_{1},\\Delta E_{1},\\Delta \\phi_{2},\\Delta \\psi_{2},\\Delta E_{2},\\Delta \\phi_{3},\\Delta \\psi_{3},\\Delta E_{3}\\right]$.\n- Angles must be rounded to one decimal place (degrees). Energies must be rounded to three decimal places (kilocalories per mole).\n\nYour final answer must be a complete, runnable Python program that constructs the Ser “params,” applies the phosphorylation “Patch,” performs the conformational grid search for each test case, and prints the results in the exact format specified above.", "solution": "The problem presented requires the formalization and implementation of a simplified, knowledge-based energy function to predict the preferred backbone conformation of a single amino acid residue, both in its standard state (Serine, Ser) and with a post-translational modification (phospho-Serine, pSer). This task is rooted in the fundamental principle of computational structural biology: that the thermodynamically favored conformation of a molecule corresponds to a minimum in its potential energy landscape. The energy function, or scoring function, $E(\\boldsymbol{\\theta}; \\boldsymbol{\\lambda})$, is a mathematical model that approximates this potential energy, where $\\boldsymbol{\\theta}$ represents the system's conformational degrees of freedom and $\\boldsymbol{\\lambda}$ are the parameters of the model.\n\nIn this problem, the conformational variables are the backbone dihedral angles $\\phi$ and $\\psi$. A change in the residue's chemical state, from Ser to pSer, is modeled by altering the parameters $\\boldsymbol{\\lambda}$. This is analogous to the \"parameter file\" and \"Patch\" system used in molecular modeling software like Rosetta, where a base set of parameters defines a standard residue, and a Patch applies a specific modification.\n\nOur task is to construct the energy functions for Ser and pSer, find the minimum-energy conformation $(\\phi^{\\star}, \\psi^{\\star})$ for each by performing a grid search, and then quantify the change in conformation and energy due to phosphorylation under three different environmental conditions. All angles are in degrees and energies are in kilocalories per mole.\n\nThe total energy for a residue of type $r \\in \\{\\mathrm{Ser}, \\mathrm{pSer}\\}$ is given by:\n$$\nE_{\\mathrm{total}}^{(r)}(\\phi,\\psi) \\;=\\; E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;+\\; \\mathbb{1}[r=\\mathrm{pSer}] \\left( E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) + E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\right)\n$$\nwhere $\\mathbb{1}[\\cdot]$ is the indicator function, being $1$ if its argument is true and $0$ otherwise. This means for Serine, only the $E_{\\mathrm{bb}}$ term contributes, while for phospho-Serine, two additional \"Patch\" terms are applied.\n\nThe energy components are defined as follows:\n$1$. **Backbone Statistical Preference, $E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi)$**: This term models the intrinsic conformational propensities of the peptide backbone, which are known to cluster in specific regions of the Ramachandran plot, namely the $\\alpha$-helical and $\\beta$-strand basins. It is formulated as a sum of two Gaussian wells, where the depths of the wells, $d_{\\alpha}^{(r)}$ and $d_{\\beta}^{(r)}$, depend on the residue type $r$.\n$$\nE_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;=\\; -d_{\\alpha}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\alpha}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\alpha}}{\\sigma_{\\psi}}\\right)^{2}\\right)\n\\;-\\; d_{\\beta}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\beta}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\beta}}{\\sigma_{\\psi}}\\right)^{2}\\right)\n$$\nThe common parameters are the centers for the $\\alpha$-basin, $(\\mu_{\\phi,\\alpha},\\mu_{\\psi,\\alpha})=(-60,-45)$, the $\\beta$-basin, $(\\mu_{\\phi,\\beta},\\mu_{\\psi,\\beta})=(-120,130)$, and the widths $\\sigma_{\\phi}=\\sigma_{\\psi}=25$.\nFor Serine, the parameters are $d_{\\alpha}^{(\\mathrm{Ser})}=3.0$ and $d_{\\beta}^{(\\mathrm{Ser})}=2.0$, favoring the $\\alpha$-helical conformation.\nThe phosphorylation \"Patch\" changes these to $d_{\\alpha}^{(\\mathrm{pSer})}=1.2$ and $d_{\\beta}^{(\\mathrm{pSer})}=3.2$, shifting the preference toward the $\\beta$-strand conformation.\n\n$2$. **Steric Penalty, $E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi)$**: This term is added only for pSer and models the steric hindrance introduced by the bulky phosphate group, which particularly penalizes the tight turns associated with the $\\alpha$-helical region. It is a positive Gaussian function centered on the $\\alpha$-helical $\\phi$ value.\n$$\nE_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) \\;=\\; + s_{0} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi - \\mu_{\\phi,\\mathrm{steric}}}{\\sigma_{\\phi,\\mathrm{steric}}}\\right)^{2}\\right)\n$$\nThe parameters are amplitude $s_{0}=0.8$, center $\\mu_{\\phi,\\mathrm{steric}}=-60$, and width $\\sigma_{\\phi,\\mathrm{steric}}=15$. For Serine, this term is $0$.\n\n$3$. **Environmental Interaction, $E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi)$**: This term is also added only for pSer and models a directional electrostatic or hydrogen-bonding interaction between the negatively charged phosphate group and a nearby positive charge in the protein's environment. The strength of this interaction is $k_{\\mathrm{el}}$ and it favors a particular $\\psi$ angle, $\\psi_{0}$.\n$$\nE_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\;=\\; - k_{\\mathrm{el}} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\psi - \\psi_{0}}{\\sigma_{\\psi,\\mathrm{el}}}\\right)^{2}\\right)\n$$\nThe width is $\\sigma_{\\psi,\\mathrm{el}}=25$. The parameters $k_{\\mathrm{el}}$ and $\\psi_{0}$ are specified by the test cases. For Serine, or if $k_{\\mathrm{el}}=0$, this term is $0$.\n\nTo find the minimum-energy conformation, we will perform a grid search. The search space is a discrete grid defined by $\\phi, \\psi \\in \\{-180, -175, \\ldots, 180\\}$. For each of the three test cases, we will perform two separate grid searches: one for Serine to find $(\\phi^{\\star}_{\\mathrm{Ser}},\\psi^{\\star}_{\\mathrm{Ser}})$ and $E_{\\min}^{(\\mathrm{Ser})}$, and one for phospho-Serine with the specified environmental parameters $(k_{\\mathrm{el}}, \\psi_{0})$ to find $(\\phi^{\\star}_{\\mathrm{pSer}},\\psi^{\\star}_{\\mathrm{pSer}})$ and $E_{\\min}^{(\\mathrm{pSer})}$.\n\nFrom these results, we compute the required outputs for each case:\n- The change in dihedral angles, $\\Delta \\phi = \\phi^{\\star}_{\\mathrm{pSer}} - \\phi^{\\star}_{\\mathrm{Ser}}$ and $\\Delta \\psi = \\psi^{\\star}_{\\mathrm{pSer}} - \\psi^{\\star}_{\\mathrm{Ser}}$. These differences are wrapped to the interval $(-180, 180]$ using the mapping $\\Delta \\theta \\mapsto ((\\Delta \\theta + 180) \\pmod{360}) - 180$. This ensures the shortest angular distance is reported.\n- The change in minimum energy, $\\Delta E = E_{\\min}^{(\\mathrm{pSer})} - E_{\\min}^{(\\mathrm{Ser})}$.\n\nThis procedure is repeated for all three test cases, and the resulting $9$ values ($\\Delta\\phi, \\Delta\\psi, \\Delta E$ for each case) are collected, rounded to the specified precision (angles to $1$ decimal place, energies to $3$ decimal places), and presented in a single flat list. The implementation will use data structures to represent the base \"params\" for Serine and the \"Patch\" for phosphorylation, mimicking the logic of modular modeling frameworks.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the conformational search and scoring problem for Serine and phospho-Serine.\n    \"\"\"\n\n    # --- Data Structures for Parameters (\"Params\" and \"Patch\") ---\n    \n    # Shared parameters for backbone statistical potential\n    bb_shared_params = {\n        'mu_phi_alpha': -60.0, 'mu_psi_alpha': -45.0,\n        'mu_phi_beta': -120.0, 'mu_psi_beta': 130.0,\n        'sigma_phi': 25.0, 'sigma_psi': 25.0,\n    }\n\n    # Base \"params\" file for Serine\n    serine_params = {\n        'type': 'Ser',\n        **bb_shared_params,\n        'd_alpha': 3.0,\n        'd_beta': 2.0,\n        # Patch-related flags are off by default\n        'has_steric_penalty': False,\n        'has_env_interaction': False,\n    }\n\n    # \"Patch\" for phosphorylation\n    pser_patch = {\n        'd_alpha': 1.2,\n        'd_beta': 3.2,\n        'has_steric_penalty': True,\n        's0_steric': 0.8,\n        'mu_phi_steric': -60.0,\n        'sigma_phi_steric': 15.0,\n        'has_env_interaction': True,\n        'sigma_psi_el': 25.0,\n    }\n\n    def apply_patch(base_params, patch):\n        \"\"\"Applies a patch to base parameters to create modified parameters.\"\"\"\n        patched_params = base_params.copy()\n        patched_params['type'] = 'pSer'\n        patched_params.update(patch)\n        return patched_params\n\n    # Create phospho-Serine parameters by applying the patch\n    pser_base_params = apply_patch(serine_params, pser_patch)\n\n    # --- Energy Functions ---\n\n    def E_bb(phi, psi, params):\n        \"\"\"Calculates backbone statistical energy.\"\"\"\n        term_alpha = -params['d_alpha'] * np.exp(\n            -0.5 * ((phi - params['mu_phi_alpha']) / params['sigma_phi'])**2\n            -0.5 * ((psi - params['mu_psi_alpha']) / params['sigma_psi'])**2\n        )\n        term_beta = -params['d_beta'] * np.exp(\n            -0.5 * ((phi - params['mu_phi_beta']) / params['sigma_phi'])**2\n            -0.5 * ((psi - params['mu_psi_beta']) / params['sigma_psi'])**2\n        )\n        return term_alpha + term_beta\n\n    def E_steric(phi, params):\n        \"\"\"Calculates steric penalty for pSer.\"\"\"\n        if not params['has_steric_penalty']:\n            return 0.0\n        return params['s0_steric'] * np.exp(\n            -0.5 * ((phi - params['mu_phi_steric']) / params['sigma_phi_steric'])**2\n        )\n\n    def E_env(psi, params, k_el, psi_0):\n        \"\"\"Calculates environmental interaction for pSer.\"\"\"\n        if not params['has_env_interaction'] or k_el == 0.0:\n            return 0.0\n        return -k_el * np.exp(-0.5 * ((psi - psi_0) / params['sigma_psi_el'])**2)\n\n    def total_energy(phi, psi, params, env_params):\n        \"\"\"Calculates the total energy for a given conformation.\"\"\"\n        k_el, psi_0 = env_params\n        energy = E_bb(phi, psi, params) + \\\n                 E_steric(phi, params) + \\\n                 E_env(psi, params, k_el, psi_0)\n        return energy\n        \n    # --- Grid Search and Calculation ---\n\n    def find_minimum_energy_conformation(params, env_params):\n        \"\"\"Performs a grid search to find the minimum energy conformation.\"\"\"\n        phi_grid = np.arange(-180.0, 180.1, 5.0)\n        psi_grid = np.arange(-180.0, 180.1, 5.0)\n        \n        min_energy = float('inf')\n        min_angles = (None, None)\n\n        for phi in phi_grid:\n            for psi in psi_grid:\n                E = total_energy(phi, psi, params, env_params)\n                if E  min_energy:\n                    min_energy = E\n                    min_angles = (phi, psi)\n        \n        return min_angles, min_energy\n\n    def wrap_angle(delta_theta):\n        \"\"\"Wraps an angular difference to the range (-180, 180].\"\"\"\n        return (delta_theta + 180.0) % 360.0 - 180.0\n\n    # --- Test Suite ---\n    test_cases = [\n        # (k_el, psi_0)\n        (1.5, -60.0),  # Case 1\n        (0.0, 0.0),    # Case 2\n        (0.9, 130.0),  # Case 3\n    ]\n\n    all_results = []\n    \n    # Find Serine minimum once (it's environment-independent)\n    ser_env_params = (0.0, 0.0) # k_el=0 for Serine\n    ser_min_angles, ser_min_energy = find_minimum_energy_conformation(serine_params, ser_env_params)\n    phi_star_ser, psi_star_ser = ser_min_angles\n\n    for case_env_params in test_cases:\n        # Find pSerine minimum for current environment\n        pser_min_angles, pser_min_energy = find_minimum_energy_conformation(pser_base_params, case_env_params)\n        phi_star_pser, psi_star_pser = pser_min_angles\n        \n        # Calculate differences\n        delta_phi = wrap_angle(phi_star_pser - phi_star_ser)\n        delta_psi = wrap_angle(psi_star_pser - psi_star_ser)\n        delta_E = pser_min_energy - ser_min_energy\n\n        # Round and append results\n        all_results.append(np.round(delta_phi, 1))\n        all_results.append(np.round(delta_psi, 1))\n        all_results.append(np.round(delta_E, 3))\n\n    # --- Final Output ---\n    # Convert all numbers to strings for joining, handling -0.0\n    # The format 'g' prevents scientific notation for small numbers.\n    results_str = [f\"{x:.1f}\" if i % 3 != 2 else f\"{x:.3f}\" for i, x in enumerate(all_results)]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2381408"}]}