{"hands_on_practices": [{"introduction": "Before analyzing experimental data, it is critical to understand the inherent limitations of the method itself. The sonication step in ChIP-seq, for instance, shears chromatin into fragments whose size directly impacts the resolution of the final signal, determining our ability to distinguish closely spaced protein binding events. This practice [@problem_id:2397900] models this relationship using Gaussian kernels, guiding you to derive the fundamental connection between the sonication fragment length $L$ and the minimal resolvable distance $D_{\\text{crit}}$ between two binding sites. This exercise provides a first-principles understanding of how experimental parameters shape the data we ultimately interpret.", "problem": "You are given an idealized, first-principles model of the expected signal produced by Chromatin Immunoprecipitation followed by sequencing (ChIP-seq) around two point-like binding sites on a linear genome. The two binding sites are located at genomic coordinates $0$ and $D$ (in base pairs). In this in silico setting, the expected pileup signal $S(x; L, D)$ at genomic coordinate $x$ is defined as the sum of two identical, centered Gaussian kernels,\n$$\nS(x; L, D) \\;=\\; G(x; 0, \\sigma(L)) \\;+\\; G(x; D, \\sigma(L)),\n$$\nwhere $G(x; \\mu, \\sigma)$ is a Gaussian function with mean $\\mu$ and standard deviation $\\sigma$, and where the effective standard deviation $\\sigma(L)$ depends on the sonication fragment size $L$ via\n$$\n\\sigma(L) \\;=\\; \\sqrt{\\sigma_0^2 + (\\alpha L)^2}.\n$$\nHere, $\\sigma_0 \\ge 0$ (in base pairs) represents an intrinsic width due to factors independent of sonication, and $\\alpha \\ge 0$ (dimensionless) captures the scaling of positional uncertainty with the fragment length $L$ (in base pairs). All variables $x$, $D$, $L$, and $\\sigma_0$ are measured in base pairs.\n\nDefine that the two binding sites are distinguishable if and only if the function $S(x; L, D)$ has exactly two distinct local maxima on $\\mathbb{R}$, with one maximum located closer to $0$ and the other located closer to $D$.\n\nFor each test case below, compute:\n- The minimal separation $D_{\\text{crit}}(L, \\alpha, \\sigma_0)$ (in base pairs) such that for all $D > D_{\\text{crit}}(L, \\alpha, \\sigma_0)$ the two sites are distinguishable according to the definition above.\n- A boolean value indicating whether the provided $D$ in the test case yields distinguishable sites (true if $D > D_{\\text{crit}}(L, \\alpha, \\sigma_0)$, false otherwise).\n\nExpress $D_{\\text{crit}}$ in base pairs as a real number.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must itself be a two-element list of the form $[D_{\\text{crit}}, \\text{resolvable}]$, where $D_{\\text{crit}}$ is a real number (in base pairs) and $\\text{resolvable}$ is a boolean. For example, an output with three results should look like\n$[[d_1,\\text{True}],[d_2,\\text{False}],[d_3,\\text{True}]]$\non a single line (without additional spaces).\n\nUse the following test suite, where each tuple is $(D, L, \\alpha, \\sigma_0)$ with all applicable quantities in base pairs:\n- $(300, 150, 0.25, 20)$\n- $(121, 200, 0.30, 10)$\n- $(0, 150, 0.20, 15)$\n- $(60, 50, 0.20, 5)$\n- $(200, 600, 0.30, 15)$\n- $(40, 100, 0.10, 0)$", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- The signal model is $S(x; L, D) = G(x; 0, \\sigma(L)) + G(x; D, \\sigma(L))$, where $G(x; \\mu, \\sigma)$ denotes a Gaussian function with mean $\\mu$ and standard deviation $\\sigma$. The two binding sites are at coordinates $x=0$ and $x=D$.\n- The effective standard deviation $\\sigma(L)$ is given by $\\sigma(L) = \\sqrt{\\sigma_0^2 + (\\alpha L)^2}$.\n- The parameters are the genomic coordinate $x$, the separation $D$, the fragment length $L$, the intrinsic width $\\sigma_0$, and the dimensionless scaling factor $\\alpha$.\n- The condition for the two binding sites to be \"distinguishable\" is that the function $S(x; L, D)$ has exactly two distinct local maxima on the real line $\\mathbb{R}$.\n- The task is to compute the critical separation $D_{\\text{crit}}(L, \\alpha, \\sigma_0)$ such that sites are distinguishable for all $D > D_{\\text{crit}}$, and to determine for each given $D$ if this condition is met.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The model is an idealized, but physically and biologically plausible, representation of a ChIP-seq signal. Using a sum of Gaussian kernels to model overlapping peaks is a standard method in signal processing and bioinformatics. The relationship between fragment length $L$ and positional uncertainty (encoded in $\\sigma(L)$) is a reasonable first-principles assumption. The problem is scientifically sound.\n- **Well-Posed:** The problem is well-posed. It asks for the critical value of a parameter $D$ that governs a qualitative change in the shape of a function $S(x)$—specifically, the number of its local maxima. This is a standard problem in calculus and bifurcation theory, which is expected to have a unique, stable, and meaningful solution.\n- **Objective:** The problem is stated in precise, objective mathematical language. The criterion for \"distinguishable\" is defined unambiguously.\n\n**Step 3: Verdict and Action**\n- The problem is valid. It is scientifically grounded, well-posed, and objective. There are no contradictions, missing information, or other flaws enumerated in the validation checklist. The solution process may proceed.\n\n**Solution Derivation**\n\nThe problem is to determine the condition under which the function $S(x; L, D)$ transitions from having one local maximum to two distinct local maxima. This transition is governed by the behavior of the derivatives of $S(x)$.\n\nThe signal function is the sum of two identical Gaussian functions:\n$$ S(x) = A e^{-\\frac{x^2}{2\\sigma^2}} + A e^{-\\frac{(x-D)^2}{2\\sigma^2}} $$\nHere, $A$ is the amplitude of the Gaussian, which acts as a scaling constant and does not affect the location of local extrema, and $\\sigma$ is a shorthand for $\\sigma(L, \\alpha, \\sigma_0)$. The extrema are found by setting the first derivative, $S'(x)$, to zero.\n$$ S'(x) = A \\left( -\\frac{x}{\\sigma^2} e^{-\\frac{x^2}{2\\sigma^2}} - \\frac{x-D}{\\sigma^2} e^{-\\frac{(x-D)^2}{2\\sigma^2}} \\right) = 0 $$\nDisregarding the constant prefactor $-A/\\sigma^2$, we must solve:\n$$ x e^{-\\frac{x^2}{2\\sigma^2}} + (x-D) e^{-\\frac{(x-D)^2}{2\\sigma^2}} = 0 $$\nDue to the symmetry of the function $S(x)$ about the point $x=D/2$, it is evident that $x=D/2$ is always a critical point:\n$$ \\frac{D}{2} e^{-\\frac{(D/2)^2}{2\\sigma^2}} + \\left(\\frac{D}{2}-D\\right) e^{-\\frac{(D/2-D)^2}{2\\sigma^2}} = \\frac{D}{2} e^{-\\frac{D^2}{8\\sigma^2}} - \\frac{D}{2} e^{-\\frac{D^2}{8\\sigma^2}} = 0 $$\nTo determine if this critical point at $x=D/2$ is a local maximum or minimum, we must analyze the sign of the second derivative, $S''(x)$, at this point.\nThe second derivative is:\n$$ S''(x) = \\frac{d}{dx} \\left[ -\\frac{A}{\\sigma^2} \\left( x e^{-\\frac{x^2}{2\\sigma^2}} + (x-D) e^{-\\frac{(x-D)^2}{2\\sigma^2}} \\right) \\right] $$\n$$ S''(x) = -\\frac{A}{\\sigma^2} \\left[ \\left(e^{-\\frac{x^2}{2\\sigma^2}} - \\frac{x^2}{\\sigma^2}e^{-\\frac{x^2}{2\\sigma^2}}\\right) + \\left(e^{-\\frac{(x-D)^2}{2\\sigma^2}} - \\frac{(x-D)^2}{\\sigma^2}e^{-\\frac{(x-D)^2}{2\\sigma^2}}\\right) \\right] $$\n$$ S''(x) = -\\frac{A}{\\sigma^2} \\left[ \\left(1 - \\frac{x^2}{\\sigma^2}\\right)e^{-\\frac{x^2}{2\\sigma^2}} + \\left(1 - \\frac{(x-D)^2}{\\sigma^2}\\right)e^{-\\frac{(x-D)^2}{2\\sigma^2}} \\right] $$\nEvaluating at the critical point $x=D/2$:\n$$ S''\\left(\\frac{D}{2}\\right) = -\\frac{A}{\\sigma^2} \\left[ \\left(1 - \\frac{(D/2)^2}{\\sigma^2}\\right)e^{-\\frac{(D/2)^2}{2\\sigma^2}} + \\left(1 - \\frac{(-D/2)^2}{\\sigma^2}\\right)e^{-\\frac{(-D/2)^2}{2\\sigma^2}} \\right] $$\n$$ S''\\left(\\frac{D}{2}\\right) = -\\frac{2A}{\\sigma^2} e^{-\\frac{D^2}{8\\sigma^2}} \\left(1 - \\frac{D^2}{4\\sigma^2}\\right) $$\nThe term $-\\frac{2A}{\\sigma^2} e^{-\\frac{D^2}{8\\sigma^2}}$ is always negative. Therefore, the sign of $S''(D/2)$ is determined by the sign of the term $\\left(1 - \\frac{D^2}{4\\sigma^2}\\right)$.\n\n1.  If $1 - \\frac{D^2}{4\\sigma^2} > 0$, which implies $D^2 < 4\\sigma^2$ or $D < 2\\sigma$, then $S''(D/2) < 0$. The critical point at $x=D/2$ is a local maximum. In this regime, the two Gaussians are sufficiently close that they merge into a single peak. Thus, there is only one local maximum, and the sites are not distinguishable.\n\n2.  If $1 - \\frac{D^2}{4\\sigma^2} < 0$, which implies $D^2 > 4\\sigma^2$ or $D > 2\\sigma$, then $S''(D/2) > 0$. The critical point at $x=D/2$ is a local minimum. Since $S(x) \\to 0$ as $x \\to \\pm\\infty$, the existence of a local minimum between the two centers implies that there must be two local maxima, one located in $(-\\infty, D/2)$ and the other in $(D/2, \\infty)$. By the problem's definition, the sites are distinguishable.\n\n3.  The transition between these two regimes occurs when $1 - \\frac{D^2}{4\\sigma^2} = 0$, which means $D = 2\\sigma$. At this point, $S''(D/2) = 0$, and this corresponds to an inflection point with zero slope, representing the moment the single peak begins to bifurcate into two.\n\nThe condition for the two sites to be distinguishable (i.e., for two local maxima to exist) is $D > 2\\sigma$. Therefore, the minimal separation for distinguishability is:\n$$ D_{\\text{crit}} = 2\\sigma $$\nSubstituting the given expression for $\\sigma = \\sigma(L, \\alpha, \\sigma_0)$:\n$$ D_{\\text{crit}}(L, \\alpha, \\sigma_0) = 2\\sqrt{\\sigma_0^2 + (\\alpha L)^2} $$\nFor each test case with parameters $(D, L, \\alpha, \\sigma_0)$, we will calculate $D_{\\text{crit}}$ using this formula and then compare the given $D$ to this critical value to determine if the sites are resolvable. The boolean value `resolvable` is true if and only if $D > D_{\\text{crit}}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ChIP-seq peak resolution problem for a suite of test cases.\n    \"\"\"\n    # Test suite: each tuple is (D, L, alpha, sigma_0)\n    # D: separation in bp\n    # L: fragment size in bp\n    # alpha: dimensionless scaling factor\n    # sigma_0: intrinsic width in bp\n    test_cases = [\n        (300, 150, 0.25, 20),\n        (121, 200, 0.30, 10),\n        (0, 150, 0.20, 15),\n        (60, 50, 0.20, 5),\n        (200, 600, 0.30, 15),\n        (40, 100, 0.10, 0)\n    ]\n\n    results = []\n    for case in test_cases:\n        D_given, L, alpha, sigma_0 = case\n\n        # Calculate the effective standard deviation sigma(L)\n        # sigma(L) = sqrt(sigma_0^2 + (alpha * L)^2)\n        sigma = np.sqrt(sigma_0**2 + (alpha * L)**2)\n\n        # The critical separation D_crit is 2 * sigma, based on the second\n        # derivative test at the midpoint between the two Gaussians.\n        # Two peaks are resolvable if D > D_crit.\n        D_crit = 2.0 * sigma\n\n        # Determine if the given separation D_given allows for resolution\n        is_resolvable = D_given > D_crit\n\n        # Store the result pair [D_crit, resolvable]\n        results.append([D_crit, is_resolvable])\n\n    # Format the output string exactly as specified: [[d1,bool1],[d2,bool2],...]\n    # without any extra spaces. Python's str() for booleans is \"True\"/\"False\",\n    # which matches the example's capitalization.\n    result_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2397900"}, {"introduction": "With a grasp of the ChIP-seq signal's physical nature, the central computational task is to distinguish regions of true enrichment from background noise—a process known as peak calling. This exercise has you model background reads as events from a homogeneous Poisson point process, a powerful and standard assumption in genomics. You will then test for statistically \"surprising\" accumulations of reads in genomic windows and apply the Benjamini-Hochberg procedure to manage the false discovery rate across thousands of tests. By building a simplified peak caller from the ground up [@problem_id:2397925], you will gain a deep appreciation for the statistical engines that drive modern bioinformatics software.", "problem": "You are asked to design and implement a simple peak caller for Chromatin Immunoprecipitation followed by sequencing (ChIP-seq) read pileups by modeling read arrivals along a genomic interval as a homogeneous Poisson point process. The scientifically grounded base is the definition of a homogeneous Poisson point process: counts of events in disjoint intervals are independent, and the count in any interval of length $w$ follows a Poisson distribution with mean $\\lambda w$, where $\\lambda$ is the constant event rate per unit length. In this context, under a null model of no enrichment, ChIP-seq reads are idealized as events of a homogeneous Poisson point process along a genome segment of length $L$ with background rate $\\lambda_0$ reads per base pair. A scanning window of width $w$ base pairs produces a read count whose null distribution is Poisson with mean $\\mu = \\lambda_0 w$. To detect enrichment, compare the observed count in each window against this null distribution using a one-sided tail probability for observing at least the measured count, and then control the False Discovery Rate (FDR) across all tested windows using the Benjamini–Hochberg step-up procedure.\n\nYour task is to write a complete program that:\n- Accepts, as internal constants in code, the following for each test case: a list of read positions (as integers in base pairs measured from $0$ to $L-1$), the genomic interval length $L$ (in base pairs), the window width $w$ (in base pairs), the scanning stride $s$ (in base pairs), the background rate $\\lambda_0$ (in reads per base pair), and the target FDR level $q$ (as a decimal, not a percentage).\n- Scans windows $[t, t+w)$ with starts $t \\in \\{0, s, 2s, \\ldots\\}$ constrained so that $t + w \\le L$.\n- Counts reads in each window, computes the one-sided tail probability under the Poisson null with mean $\\mu = \\lambda_0 w$ for the event “observed count is at least the measured count,” and applies the Benjamini–Hochberg step-up procedure at target level $q$ across all scanned windows within the test case.\n- Returns, for each test case, the list of window start coordinates (in base pairs) that are called significant after multiple-testing correction. The list must be sorted in ascending order by genomic coordinate.\n\nScientific and algorithmic constraints:\n- Use the homogeneous Poisson point process as the null model for background read arrivals with constant rate $\\lambda_0$; in a window of width $w$, the null count distribution is Poisson with mean $\\mu = \\lambda_0 w$.\n- Use a one-sided enrichment test per window that evaluates the tail probability of observing at least the measured count under the Poisson null.\n- Control the False Discovery Rate using the Benjamini–Hochberg step-up procedure at level $q$ applied to all windows in a test case.\n- Positions are measured in base pairs; report window start coordinates in base pairs as integers.\n\nTest suite to implement within your program (each is an independent test case):\n- Case A (background only; no peaks expected): $L = 1000$, $w = 100$, $s = 100$, $\\lambda_0 = 0.01$ reads per base pair, $q = 0.1$, read positions $[50, 250, 750]$. Expected behavior: no significant windows.\n- Case B (one clear internal peak): $L = 1000$, $w = 100$, $s = 100$, $\\lambda_0 = 0.01$ reads per base pair, $q = 0.1$, read positions $[20, 120, 405, 410, 420, 431, 440, 455, 460, 495, 800]$. Expected behavior: the window starting at $400$ base pairs is significant.\n- Case C (boundary peak at the end): $L = 500$, $w = 100$, $s = 100$, $\\lambda_0 = 0.01$ reads per base pair, $q = 0.05$, read positions $[401, 402, 415, 420, 430, 440, 450, 460, 480]$. Expected behavior: the window starting at $400$ base pairs is significant.\n- Case D (multiple moderate peaks; multiple-testing interaction): $L = 800$, $w = 100$, $s = 100$, $\\lambda_0 = 0.01$ reads per base pair, $q = 0.1$, read positions $[110, 115, 120, 130, 180, 505, 510, 530, 540, 590]$. Expected behavior: the windows starting at $100$ and $500$ base pairs are significant.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all four cases as a comma-separated list enclosed in square brackets, where each element is itself a list of integers representing significant window start coordinates for the corresponding case. For example, a valid format is $[[\\dots],[\\dots],[\\dots],[\\dots]]$ with no extra text. All coordinates must be in base pairs (bp) as integers.", "solution": "We are tasked with designing a computational procedure to identify regions of signal enrichment in Chromatin Immunoprecipitation sequencing (ChIP-seq) data. This is a canonical problem in computational genomics known as \"peak calling.\" The provided problem statement is scientifically sound and algorithmically well-defined, resting on established biostatistical principles. It is therefore valid, and we proceed to construct the solution.\n\nThe fundamental premise is to model the background distribution of sequencing reads using a stochastic process. Under the null hypothesis of no specific protein-DNA binding, reads are assumed to be distributed randomly across the genome. A homogeneous Poisson point process provides a simple yet powerful null model for this random background.\n\nThe core of our method consists of three stages: first, partitioning the genome and quantifying read counts; second, evaluating the statistical significance of observed counts against the null model; and third, correcting for the multiplicity of tests performed across the genome.\n\nFirst, we address the task of genomic tiling and read counting. The genomic interval of length $L$ is scanned using a sliding window of width $w$ and stride $s$. The start coordinates of these windows are given by the set $\\{t_i = i \\cdot s \\mid i \\in \\mathbb{Z}_{\\ge 0}, i \\cdot s + w \\le L\\}$. The total number of windows, and thus the total number of statistical tests, is $M = \\lfloor \\frac{L-w}{s} \\rfloor + 1$. For each window $i$, which spans the genomic interval $[t_i, t_i+w)$, we count the number of observed reads, denoted $k_i$, whose positions fall within this interval.\n\nSecond, we formulate the statistical test for enrichment. The null hypothesis, $H_0$, states that read arrivals follow a homogeneous Poisson process with a constant rate of $\\lambda_0$ reads per base pair. Consequently, the number of reads $X$ in any window of width $w$ follows a Poisson distribution with mean parameter $\\mu = \\lambda_0 w$. The probability mass function is $P(X=k | H_0) = \\frac{e^{-\\mu}\\mu^k}{k!}$. To test for enrichment, we compute a one-sided p-value for each window $i$. This p-value is the probability of observing a read count of at least $k_i$ under the null distribution. This corresponds to the survival function (or complementary cumulative distribution function) of the Poisson distribution:\n$$p_i = P(X \\ge k_i) = \\sum_{j=k_i}^{\\infty} \\frac{e^{-\\mu}\\mu^j}{j!} = 1 - \\sum_{j=0}^{k_i-1} \\frac{e^{-\\mu}\\mu^j}{j!}$$\nA small p-value suggests that the observed count $k_i$ is improbably high under the assumption of a random background, providing evidence against the null hypothesis for that specific window.\n\nThird, we must address the multiple hypothesis testing problem. Since we perform $M$ independent or correlated tests, one for each window, using a naive p-value threshold (e.g., $p \\le 0.05$) would inflate the rate of false positive discoveries. To control this, we employ the Benjamini–Hochberg (BH) procedure to control the False Discovery Rate (FDR) at a specified level $q$. The FDR is the expected proportion of rejected null hypotheses that are falsely rejected. The BH procedure is as follows:\n1.  Collect the set of all $M$ p-values, $\\{p_1, p_2, \\ldots, p_M\\}$.\n2.  Sort these p-values in ascending order: $p_{(1)} \\le p_{(2)} \\le \\ldots \\le p_{(M)}$.\n3.  Find the largest integer rank $k$ such that the $k$-th ordered p-value satisfies the condition:\n    $$p_{(k)} \\le \\frac{k}{M}q$$\n4.  If such a $k$ exists, we reject the null hypotheses for all windows corresponding to the p-values $p_{(1)}, p_{(2)}, \\ldots, p_{(k)}$. These windows are declared \"significant.\"\n5.  If no such $k$ exists (i.e., $p_{(1)} > \\frac{1}{M}q$), no null hypotheses are rejected, and no windows are declared significant.\n\nThis procedure guarantees that for independent tests, the expected FDR is less than or equal to $q$. The final output is the sorted list of start coordinates $t_i$ for all windows identified as significant by this procedure.\n\nThe algorithmic implementation will therefore systematically execute these steps:\n1.  Generate all window start coordinates based on $L$, $w$, and $s$.\n2.  For each window, efficiently count the reads falling within its boundaries. Sorting the read positions initially allows for rapid counting using binary search.\n3.  Calculate the Poisson parameter $\\mu = \\lambda_0 w$.\n4.  For each window count $k_i$, compute the corresponding p-value using the survival function of the Poisson($\\mu$) distribution.\n5.  Apply the Benjamini-Hochberg procedure to the set of all p-values to identify the subset of significant findings.\n6.  Return the start coordinates of the significant windows, sorted in ascending order.\nThis provides a rigorous and complete framework for the problem posed.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import poisson\n\ndef solve():\n    \"\"\"\n    Main function to run the ChIP-seq peak calling analysis for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (background only; no peaks expected)\n        {\n            \"L\": 1000, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.1,\n            \"read_positions\": [50, 250, 750]\n        },\n        # Case B (one clear internal peak)\n        {\n            \"L\": 1000, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.1,\n            \"read_positions\": [20, 120, 405, 410, 420, 431, 440, 455, 460, 495, 800]\n        },\n        # Case C (boundary peak at the end)\n        {\n            \"L\": 500, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.05,\n            \"read_positions\": [401, 402, 415, 420, 430, 440, 450, 460, 480]\n        },\n        # Case D (multiple moderate peaks; multiple-testing interaction)\n        {\n            \"L\": 800, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.1,\n            \"read_positions\": [110, 115, 120, 130, 180, 505, 510, 530, 540, 590]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        w = case[\"w\"]\n        s = case[\"s\"]\n        lambda_0 = case[\"lambda_0\"]\n        q = case[\"q\"]\n        read_positions = np.array(sorted(case[\"read_positions\"]))\n\n        # Step 1: Generate window starts and count reads\n        window_starts = np.arange(0, L - w + 1, s, dtype=int)\n        \n        # Efficiently count reads in each window using pre-sorted positions\n        window_counts = np.zeros_like(window_starts, dtype=int)\n        for i, start in enumerate(window_starts):\n            end = start + w\n            left_idx = np.searchsorted(read_positions, start, side='left')\n            right_idx = np.searchsorted(read_positions, end, side='left')\n            window_counts[i] = right_idx - left_idx\n        \n        # Step 2: Calculate p-values based on Poisson null model\n        mu = lambda_0 * w\n        \n        # Calculate p-value: P(X >= k) = 1 - P(X <= k-1). \n        # This is the survival function (sf).\n        # We use k-1 because sf(k, mu) calculates P(X > k). So sf(k-1, mu) is P(X >= k).\n        # For k=0, k-1=-1. scipy.stats.poisson.sf handle this correctly and return 1.0.\n        p_values = poisson.sf(window_counts - 1, mu)\n        \n        # Step 3: Apply Benjamini-Hochberg procedure\n        num_tests = len(p_values)\n        significant_windows = []\n\n        if num_tests > 0:\n            # Get original indices sorted by p-value\n            sorted_indices = np.argsort(p_values)\n            sorted_p_values = p_values[sorted_indices]\n            \n            # Calculate BH thresholds\n            ranks = np.arange(1, num_tests + 1)\n            bh_thresholds = (ranks / num_tests) * q\n            \n            # Find p-values that are below the BH threshold\n            significant_mask = sorted_p_values <= bh_thresholds\n            \n            if np.any(significant_mask):\n                # Find the largest rank k for which p_(k) <= (k/m)*q\n                max_significant_rank_idx = np.where(significant_mask)[0][-1]\n                \n                # All hypotheses up to this rank are rejected\n                significant_original_indices = sorted_indices[:max_significant_rank_idx + 1]\n                \n                # Get the window start coordinates for the significant windows\n                significant_starts = window_starts[significant_original_indices]\n                significant_windows = sorted(significant_starts.tolist())\n\n        results.append(significant_windows)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list is what's needed for the inner elements.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2397925"}, {"introduction": "Once peaks for a given histone modification are reliably identified, the biological investigation can begin. A fascinating area of epigenetics is understanding how combinations of different histone modifications orchestrate complex cellular states. For example, \"bivalent\" promoters, which are simultaneously marked by the activating modification H3K4me3 and the repressive modification H3K27me3, are thought to poise key developmental genes for rapid changes in expression. This final practice [@problem_id:2397930] challenges you to implement a computational strategy to find these bivalent regions, demonstrating how integrating multiple ChIP-seq datasets can reveal sophisticated regulatory logic.", "problem": "You are given abstracted representations of Chromatin Immunoprecipitation followed by sequencing (ChIP-seq) peak calls for two histone modifications, histone H3 lysine 4 tri-methylation (H3K4me3) and histone H3 lysine 27 tri-methylation (H3K27me3), and a list of promoter intervals on a single chromosome. Each interval is represented as a half-open interval $[s,e)$ on the integer coordinate axis in base pairs, where $s$ and $e$ are integers with $s &lt; e$. The length of an interval $[s,e)$ is $e - s$ in base pairs. The overlap length between two intervals is defined as the number of integer positions they share; due to the half-open convention, if two intervals only touch at a boundary point (for example, $[100,200)$ and $[200,300)$), their overlap length is $0$.\n\nDefine a promoter to be bivalent if and only if there exists at least one H3K4me3 peak whose overlap length with the promoter is greater than or equal to a given threshold $t_{4}$ (in base pairs) and there exists at least one H3K27me3 peak whose overlap length with the promoter is greater than or equal to a given threshold $t_{27}$ (in base pairs). The overlap criterion is applied per-peak independently; do not combine or sum overlap lengths across multiple peaks for a given modification. If a peak list for a modification is empty, then no promoter can satisfy the existence condition for that modification.\n\nFor each test case below, you must compute the number of bivalent promoters. All coordinates are integers in base pairs, and all thresholds $t_{4}$ and $t_{27}$ are nonnegative integers in base pairs. Express all results as integer counts. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[a,b,c]$), where each entry corresponds to the number of bivalent promoters for the corresponding test case in the same order as listed.\n\nTest Suite:\n\n- Test case $1$ (general case):\n  - Promoters (ID, $[s,e)$): $(1,[1000,1500))$, $(2,[2000,2300))$, $(3,[3000,3300))$.\n  - H3K4me3 peaks $[s,e)$: $[1100,1400)$, $[1950,2100)$, $[3100,3120)$, $[5000,5100)$.\n  - H3K27me3 peaks $[s,e)$: $[1200,1600)$, $[2250,2350)$, $[3150,3290)$.\n  - Thresholds: $t_{4} = 100$, $t_{27} = 100$.\n- Test case $2$ (boundary-touching and minimal positive overlaps):\n  - Promoters (ID, $[s,e)$): $(1,[100,200))$, $(2,[400,500))$, $(3,[700,800))$.\n  - H3K4me3 peaks $[s,e)$: $[200,300)$, $[350,400)$, $[700,701)$.\n  - H3K27me3 peaks $[s,e)$: $[50,100)$, $[500,600)$, $[799,900)$.\n  - Thresholds: $t_{4} = 1$, $t_{27} = 1$.\n- Test case $3$ (multiple peaks per modification, per-peak thresholds not summed):\n  - Promoters (ID, $[s,e)$): $(1,[1000,1100))$, $(2,[2000,2100))$, $(3,[3000,3100))$.\n  - H3K4me3 peaks $[s,e)$: $[950,980)$, $[1070,1120)$, $[1990,2060)$, $[2900,3000)$, $[3000,3050)$.\n  - H3K27me3 peaks $[s,e)$: $[1005,1050)$, $[2090,2150)$, $[2050,2105)$, $[3050,3100)$.\n  - Thresholds: $t_{4} = 50$, $t_{27} = 50$.\n- Test case $4$ (empty peak list edge case):\n  - Promoters (ID, $[s,e)$): $(1,[100,200))$, $(2,[300,400))$.\n  - H3K4me3 peaks $[s,e)$: empty list.\n  - H3K27me3 peaks $[s,e)$: $[500,600)$.\n  - Thresholds: $t_{4} = 0$, $t_{27} = 0$.\n- Test case $5$ (zero thresholds admit non-overlaps when peaks exist):\n  - Promoters (ID, $[s,e)$): $(1,[100,200))$.\n  - H3K4me3 peaks $[s,e)$: $[0,50)$.\n  - H3K27me3 peaks $[s,e)$: $[500,600)$.\n  - Thresholds: $t_{4} = 0$, $t_{27} = 0$.\n\nYour program must deterministically compute, for each test case, the integer count of promoter IDs that satisfy the bivalency definition under the stated rules and thresholds, and then output a single line in the exact format $[a,b,c,d,e]$ corresponding to the five test cases in order.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded in the principles of computational genomics, is mathematically well-posed, and is expressed with objective, unambiguous language. All necessary data and definitions for a deterministic solution are provided.\n\nThe core of the problem is to identify and count \"bivalent promoters\" based on a set of precise criteria involving the overlap of genomic intervals. A promoter is defined as bivalent if it meets two separate conditions simultaneously: one concerning the histone modification H3K4me3 and another concerning H3K27me3.\n\nLet a promoter interval be denoted by $P = [s_p, e_p)$ and a peak interval (for either modification) be denoted by $K = [s_k, e_k)$. The overlap length, $L_{overlap}$, between these two half-open intervals is the length of their intersection, which is calculated as:\n$$L_{overlap}(P, K) = \\max(0, \\min(e_p, e_k) - \\max(s_p, s_k))$$\nThis formula correctly computes the number of integer positions shared by the two intervals. The use of $\\max(0, \\dots)$ ensures that non-overlapping intervals have an overlap length of $0$.\n\nAccording to the provided definition, a promoter $P$ is bivalent if and only if both of the following logical conditions are satisfied:\n$1.$ There exists at least one H3K4me3 peak, $K_4$, from the provided list of H3K4me3 peaks, such that its overlap with the promoter $P$ is greater than or equal to a specified threshold $t_4$. Formally:\n$$\\exists K_4 \\in \\{\\text{H3K4me3 peaks}\\} \\text{ such that } L_{overlap}(P, K_4) \\ge t_4$$\n$2.$ There exists at least one H3K27me3 peak, $K_{27}$, from the provided list of H3K27me3 peaks, such that its overlap with the promoter $P$ is greater than or equal to a specified threshold $t_{27}$. Formally:\n$$\\exists K_{27} \\in \\{\\text{H3K27me3 peaks}\\} \\text{ such that } L_{overlap}(P, K_{27}) \\ge t_{27}$$\n\nThe problem explicitly states that these conditions are evaluated independently for each peak. The overlap lengths from multiple peaks of the same modification are not to be aggregated.\n\nThe algorithm to solve this problem is a direct implementation of this definition:\nFirst, we initialize a counter for bivalent promoters to $0$. We then iterate through each promoter in the given list. For each promoter, we must verify the two existence conditions.\n\nTo verify the H3K4me3 condition for a given promoter, we first check if the list of H3K4me3 peaks is empty. If it is empty, the existence condition cannot be satisfied, and the promoter cannot be bivalent. If the list is not empty, we iterate through each H3K4me3 peak, calculate its overlap length with the promoter, and compare it to the threshold $t_4$. If we find any peak that satisfies the condition $L_{overlap} \\ge t_4$, the H3K4me3 condition for the promoter is met, and we can immediately stop checking other H3K4me3 peaks for this promoter.\n\nIf the H3K4me3 condition is met, we proceed to verify the H3K27me3 condition in an analogous manner. We check if the H3K27me3 peak list is empty. If not, we iterate through the peaks, calculating their overlap with the promoter, until we find one that satisfies $L_{overlap} \\ge t_{27}$. If such a peak is found, the H3K27me3 condition is also met.\n\nA promoter is counted as bivalent if and only if both the H3K4me3 and H3K27me3 conditions are successfully verified. This process is repeated for all promoters, and the final value of the counter is the result for the test case.\n\nA special case arises when a threshold is zero, for instance $t_4 = 0$. Since the overlap length $L_{overlap}$ is, by definition, always non-negative ($L_{overlap} \\ge 0$), the condition $L_{overlap} \\ge 0$ is always true for any pair of intervals. Therefore, for a threshold of $0$, the existence condition for a modification is met if and only if its corresponding peak list is not empty.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bivalent promoter counting problem for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (general case)\n        {\n            \"promoters\": [(1000, 1500), (2000, 2300), (3000, 3300)],\n            \"h3k4me3_peaks\": [(1100, 1400), (1950, 2100), (3100, 3120), (5000, 5100)],\n            \"h3k27me3_peaks\": [(1200, 1600), (2250, 2350), (3150, 3290)],\n            \"t4\": 100,\n            \"t27\": 100,\n        },\n        # Test case 2 (boundary-touching and minimal positive overlaps)\n        {\n            \"promoters\": [(100, 200), (400, 500), (700, 800)],\n            \"h3k4me3_peaks\": [(200, 300), (350, 400), (700, 701)],\n            \"h3k27me3_peaks\": [(50, 100), (500, 600), (799, 900)],\n            \"t4\": 1,\n            \"t27\": 1,\n        },\n        # Test case 3 (multiple peaks per modification, per-peak thresholds not summed)\n        {\n            \"promoters\": [(1000, 1100), (2000, 2100), (3000, 3100)],\n            \"h3k4me3_peaks\": [(950, 980), (1070, 1120), (1990, 2060), (2900, 3000), (3000, 3050)],\n            \"h3k27me3_peaks\": [(1005, 1050), (2090, 2150), (2050, 2105), (3050, 3100)],\n            \"t4\": 50,\n            \"t27\": 50,\n        },\n        # Test case 4 (empty peak list edge case)\n        {\n            \"promoters\": [(100, 200), (300, 400)],\n            \"h3k4me3_peaks\": [],\n            \"h3k27me3_peaks\": [(500, 600)],\n            \"t4\": 0,\n            \"t27\": 0,\n        },\n        # Test case 5 (zero thresholds admit non-overlaps when peaks exist)\n        {\n            \"promoters\": [(100, 200)],\n            \"h3k4me3_peaks\": [(0, 50)],\n            \"h3k27me3_peaks\": [(500, 600)],\n            \"t4\": 0,\n            \"t27\": 0,\n        },\n    ]\n\n    def calculate_overlap(interval1, interval2):\n        \"\"\"\n        Calculates the overlap length between two half-open intervals [s, e).\n        \n        Args:\n            interval1 (tuple): A tuple (start, end) for the first interval.\n            interval2 (tuple): A tuple (start, end) for the second interval.\n            \n        Returns:\n            int: The non-negative integer overlap length.\n        \"\"\"\n        s1, e1 = interval1\n        s2, e2 = interval2\n        \n        overlap_start = max(s1, s2)\n        overlap_end = min(e1, e2)\n        \n        return max(0, overlap_end - overlap_start)\n\n    def analyze_case(promoters, h3k4me3_peaks, h3k27me3_peaks, t4, t27):\n        \"\"\"\n        Counts the number of bivalent promoters for a single test case.\n        \"\"\"\n        bivalent_promoter_count = 0\n\n        for p_interval in promoters:\n            # Check for H3K4me3 mark\n            has_h3k4me3_mark = False\n            if h3k4me3_peaks:\n                for k4_peak in h3k4me3_peaks:\n                    if calculate_overlap(p_interval, k4_peak) >= t4:\n                        has_h3k4me3_mark = True\n                        break  # Found a qualifying peak, no need to check others\n            \n            # If K4 condition fails, the promoter cannot be bivalent. Continue to next promoter.\n            if not has_h3k4me3_mark:\n                continue\n\n            # Check for H3K27me3 mark\n            has_h3k27me3_mark = False\n            if h3k27me3_peaks:\n                for k27_peak in h3k27me3_peaks:\n                    if calculate_overlap(p_interval, k27_peak) >= t27:\n                        has_h3k27me3_mark = True\n                        break  # Found a qualifying peak, no need to check others\n\n            # If both conditions are met, increment the counter\n            if has_h3k4me3_mark and has_h3k27me3_mark:\n                bivalent_promoter_count += 1\n                \n        return bivalent_promoter_count\n\n    results = []\n    for case in test_cases:\n        result = analyze_case(\n            case[\"promoters\"],\n            case[\"h3k4me3_peaks\"],\n            case[\"h3k27me3_peaks\"],\n            case[\"t4\"],\n            case[\"t27\"]\n        )\n        results.append(result)\n\n    # Final output must be a single line in the specified format [a,b,c,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2397930"}]}