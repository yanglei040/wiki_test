{"hands_on_practices": [{"introduction": "Theoretical Mendelian genetics provides precise predictions for genotype ratios, but real experimental data always exhibits some degree of random variation. A crucial skill for any biologist is to distinguish this expected statistical noise from a true biological deviation from the model. This first practice challenges you to implement the Pearson's chi-squared ($\\chi^2$) goodness-of-fit test, a cornerstone of genetic analysis, to quantitatively assess whether observed offspring counts from genetic crosses are consistent with Mendelian expectations [@problem_id:2403843].", "problem": "You are given a set of independent genetic loci from offspring of controlled crosses. For each locus, the offspring have been genotyped using high-throughput sequencing, and the observed counts across genotype classes have been tallied. Assume biallelic loci and codominant genotype calls (so that the genotype categories are unambiguously distinguishable). Under classical Mendelian inheritance, for specific cross designs, the expected genotype proportions are determined by the law of segregation and random union of gametes.\n\nFor each test case, you must decide whether the observed counts at a locus are consistent with Mendelian segregation for the declared cross design at a specified significance level. Formally, for a locus with $k$ genotype categories, let the observed counts be the vector $\\mathbf{O}=(O_1,\\dots,O_k)$ with total $N=\\sum_{i=1}^k O_i$, and let the expected Mendelian proportions under the cross design be $\\mathbf{p}=(p_1,\\dots,p_k)$ with $\\sum_{i=1}^k p_i=1$ and $p_i>0$ for all $i$. The null hypothesis is that the data arise from the categorical distribution with probabilities $\\mathbf{p}$. Your program must determine whether to reject the null hypothesis at significance level $\\alpha$ for each test case.\n\nSupported cross designs and their expected genotype proportions:\n- Cross design string \"F2\" denotes an $F_2$ intercross from two inbred parents with a single biallelic locus and codominant genotyping. The expected genotype proportion vector (in the order $AA$, $Aa$, $aa$) is $\\left(\\tfrac{1}{4},\\tfrac{1}{2},\\tfrac{1}{4}\\right)$.\n- Cross design string \"BACKCROSS\" denotes a backcross of a heterozygote to a homozygous recessive at a single biallelic locus with codominant genotyping. The expected genotype proportion vector (in the order $Aa$, $aa$) is $\\left(\\tfrac{1}{2},\\tfrac{1}{2}\\right)$.\n\nInterpretation and output encoding:\n- For each test case, return the integer decision code $d$ defined as follows: $d=1$ if the null hypothesis of Mendelian segregation is rejected at level $\\alpha$, $d=0$ if the null hypothesis is not rejected at level $\\alpha$, and $d=-1$ if the test is invalid because the observed category count vector length does not match that of the expected proportion vector for the declared cross design or because $N=0$.\n\nYour program must hard-code and use the following test suite. Each test case is a tuple of three elements: the cross design string, the list of observed nonnegative integer counts per genotype category in the specified order for that cross, and the significance level $\\alpha$ (expressed as a decimal fraction):\n- Test case $1$: cross \"F2\", observed counts $[20,40,20]$, $\\alpha=0.05$.\n- Test case $2$: cross \"F2\", observed counts $[10,60,10]$, $\\alpha=0.05$.\n- Test case $3$: cross \"BACKCROSS\", observed counts $[35,45]$, $\\alpha=0.05$.\n- Test case $4$: cross \"BACKCROSS\", observed counts $[0,40]$, $\\alpha=0.01$.\n- Test case $5$: cross \"F2\", observed counts $[0,4,0]$, $\\alpha=0.05$.\n- Test case $6$: cross \"F2\", observed counts $[50,50]$, $\\alpha=0.05$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[1,0,1]\"), in the order of the test cases above. The elements must be the decision codes $d$ as defined above.\n\nAll numerical answers are unitless. The angle unit is not applicable. The significance level must be provided and interpreted as a decimal fraction, not as a percentage sign. The final output must be exactly one line in the specified format. Do not read any input; use only the test suite provided here.", "solution": "The problem as stated has been subjected to rigorous validation and is found to be valid. It is scientifically grounded in the principles of Mendelian genetics and statistical hypothesis testing, it is well-posed, and its formulation is objective and unambiguous. We will therefore proceed with a complete solution.\n\nThe task is to assess whether observed genotype counts from genetic crosses conform to the expected ratios predicted by Mendelian laws. This is a classic problem of goodness-of-fit, for which the standard statistical instrument is Pearson's chi-squared ($\\chi^2$) test.\n\nThe core principle is to quantify the discrepancy between observed data and the data expected under a specific null hypothesis. The null hypothesis, denoted $H_0$, is that the observed counts are drawn from a categorical distribution with probabilities specified by the Mendelian model for the given cross design.\n\nFor each test case, we are given a set of observed counts, $\\mathbf{O} = (O_1, O_2, \\dots, O_k)$, where $k$ is the number of genotype categories. The total number of observations is $N = \\sum_{i=1}^k O_i$. The null hypothesis $H_0$ provides a vector of expected proportions, $\\mathbf{p} = (p_1, p_2, \\dots, p_k)$, where $\\sum_{i=1}^k p_i = 1$ and each $p_i > 0$.\n\nFirst, we perform the preliminary validation as required for each test case. A test case is deemed invalid, assigned a code $d = -1$, if either of two conditions is met:\n$1$. The number of observed categories, which is the length of vector $\\mathbf{O}$, does not match the number of expected categories, the length of vector $\\mathbf{p}$, for the specified cross design. For an `$F_2$` cross, we expect $k=3$ categories ($AA, Aa, aa$). For a `BACKCROSS`, we expect $k=2$ categories ($Aa, aa$).\n$2$. The total number of observed offspring is zero, i.e., $N=0$. A statistical test is meaningless without data.\n\nIf a test case is valid, we proceed. We compute the expected counts, $\\mathbf{E}$, for each category under the null hypothesis:\n$$ E_i = N \\times p_i $$\nThe Pearson's $\\chi^2$ test statistic measures the normalized squared deviation between observed and expected counts:\n$$ \\chi^2 = \\sum_{i=1}^{k} \\frac{(O_i - E_i)^2}{E_i} $$\nA larger value of $\\chi^2$ indicates a greater deviation from the Mendelian model and thus provides stronger evidence against $H_0$.\n\nUnder the null hypothesis, this $\\chi^2$ statistic follows, approximately, a chi-squared distribution with $\\nu = k-1$ degrees of freedom. The number of degrees of freedom is the number of categories minus one, as the total count $N$ is fixed.\n\nTo make a decision, we compare the calculated $\\chi^2$ value to the distribution. This is done by calculating the p-value, which is the probability of observing a test statistic at least as extreme as the one computed, given that $H_0$ is true.\n$$ \\text{p-value} = P(\\chi^2_{\\nu} \\ge \\chi^2_{\\text{calculated}}) $$\nThe final decision is made by comparing the p-value to the pre-specified significance level, $\\alpha$:\n- If p-value $< \\alpha$, we reject the null hypothesis $H_0$. The observed data are statistically inconsistent with the Mendelian model at the $\\alpha$ level of significance. The decision code is $d=1$.\n- If p-value $\\ge \\alpha$, we do not reject the null hypothesis $H_0$. There is insufficient statistical evidence to conclude that the data deviate from the Mendelian model. The decision code is $d=0$.\n\nIt must be noted that the chi-squared distribution is an approximation that is most accurate when expected counts $E_i$ are sufficiently large (e.g., $E_i \\ge 5$). The problem statement does not require us to invalidate tests based on this condition, so we will perform the calculation regardless of the magnitude of the expected counts, as is formally defined.\n\nThe algorithm is as follows:\n$1$. For each test case defined by a cross design, observed counts $\\mathbf{O}$, and significance level $\\alpha$, retrieve the corresponding expected proportions $\\mathbf{p}$.\n$2$. Validate the test case. If `len(O)` $\\neq$ `len(p)` or if $\\sum O_i = 0$, the result is $d=-1$.\n$3$. If the case is valid, calculate the total count $N = \\sum O_i$.\n$4$. Calculate the vector of expected counts $\\mathbf{E} = N \\times \\mathbf{p}$.\n$5$. Compute the $\\chi^2$ statistic and its corresponding p-value using the chi-squared distribution with $\\nu = k-1$ degrees of freedom.\n$6$. Compare the p-value to $\\alpha$ to determine the decision code, either $d=1$ or $d=0$.\n$7$. Collect the decision codes for all test cases and format them as required. This procedure will be implemented using numerical libraries for precision and efficiency.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Validates and solves a suite of genetic cross problems using the chi-squared test.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (cross_design, observed_counts, alpha)\n        (\"F2\", [20, 40, 20], 0.05),\n        (\"F2\", [10, 60, 10], 0.05),\n        (\"BACKCROSS\", [35, 45], 0.05),\n        (\"BACKCROSS\", [0, 40], 0.01),\n        (\"F2\", [0, 4, 0], 0.05),\n        (\"F2\", [50, 50], 0.05),\n    ]\n\n    # Define the expected genotype proportions for the supported cross designs.\n    mendelian_proportions = {\n        \"F2\": np.array([0.25, 0.5, 0.25]),\n        \"BACKCROSS\": np.array([0.5, 0.5])\n    }\n\n    results = []\n    for cross_design, observed_counts, alpha in test_cases:\n        # Step 1: Retrieve expected proportions for the cross design.\n        expected_proportions = mendelian_proportions[cross_design]\n\n        # Step 2: Validate the test case.\n        # Check for mismatch in the number of genotype categories.\n        if len(observed_counts) != len(expected_proportions):\n            results.append(-1)\n            continue\n        \n        # Calculate the total number of offspring.\n        N = sum(observed_counts)\n        \n        # Check if the total count is zero.\n        if N == 0:\n            results.append(-1)\n            continue\n\n        # Step 3: Calculate expected counts.\n        # The observed counts are converted to a NumPy array for vectorized operations.\n        observed_counts_np = np.array(observed_counts)\n        expected_counts = N * expected_proportions\n        \n        # Step 4: Perform Pearson's chi-squared goodness-of-fit test.\n        # The scipy.stats.chisquare function computes the statistic and the p-value.\n        # The degrees of freedom are calculated by the function as k-1.\n        chi2_statistic, p_value = stats.chisquare(f_obs=observed_counts_np, f_exp=expected_counts)\n        \n        # Step 5: Make a decision based on the p-value and significance level alpha.\n        if p_value < alpha:\n            # Reject the null hypothesis.\n            decision_code = 1\n        else:\n            # Do not reject the null hypothesis.\n            decision_code = 0\n            \n        results.append(decision_code)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2403843"}, {"introduction": "Having learned to statistically detect deviations from Mendelian ratios, we now turn to modeling their underlying mechanisms. This exercise shifts our focus from data analysis to mechanistic simulation by exploring meiotic non-disjunction, the failure of chromosomes to segregate properly. You will build a deterministic model from first principles to calculate the expected frequency of aneuploid zygotes, directly linking errors at the cellular level of meiosis to their consequences on offspring genetics [@problem_id:2403845].", "problem": "You are asked to write a deterministic program that models deviations from Mendelian segregation due to meiotic non-disjunction and computes the expected fraction of zygotes that are aneuploid at a single focal chromosome. The modeling assumptions, grounded in standard meiosis mechanics and basic probability, are as follows.\n\n1. Each parent undergoes gametogenesis via meiosis for the focal chromosome. There are two stages in meiosis: Meiosis I (MI) and Meiosis II (MII). Non-disjunction is the failure of proper chromosomal segregation in either stage. For each parent, you are given two probabilities: the probability of MI non-disjunction, denoted $p_I$, and the probability of MII non-disjunction, denoted $p_{II}$, for the focal chromosome in a given meiosis. Assume that $p_I \\ge 0$, $p_{II} \\ge 0$, and $p_I + p_{II} \\le 1$, and that exactly one of the three mutually exclusive outcomes occurs in any meiosis of the focal chromosome: normal segregation, MI non-disjunction, or MII non-disjunction.\n\n2. Mechanistic outcomes per meiosis for the focal chromosome are as follows, ignoring crossing-over at the focal locus and treating all four post-meiotic products (gametes) as equally likely to be used in fertilization.\n   - Normal segregation: all four gametes are haploid with exactly one copy of the focal chromosome.\n   - MI non-disjunction: homologous chromosomes fail to separate in MI, leading after MII to two gametes with zero copies (nullisomic for the focal chromosome) and two gametes with two copies (disomic for the focal chromosome).\n   - MII non-disjunction: sister chromatids fail to separate in MII, yielding one gamete with zero copies, two gametes with one copy, and one gamete with two copies of the focal chromosome.\n\n3. A zygote is formed by random union of one gamete from each parent, independently. Define the zygote’s copy number for the focal chromosome as the sum of the numbers of copies carried by the two parental gametes. By definition in this problem, aneuploid zygotes are those whose total copy number is not equal to $2$. That is, total copy numbers of $0$, $1$, $3$, or $4$ are considered aneuploid, while a total of $2$ copies is considered euploid, even if both copies derive from a single parent.\n\n4. You must compute, for each specified parameter set, the expected fraction (probability) of aneuploid zygotes under the above assumptions. Your computations must be exact with respect to the specified probabilities, without stochastic simulation.\n\n5. Your program must hard-code and evaluate the following test suite of five cases. In each case, the tuple provides $(p_I^{(1)}, p_{II}^{(1)}, p_I^{(2)}, p_{II}^{(2)})$, where superscripts $(1)$ and $(2)$ denote the first and second parent, respectively.\n   - Case 1 (baseline Mendelian): $p_I^{(1)} = 0.0$, $p_{II}^{(1)} = 0.0$, $p_I^{(2)} = 0.0$, $p_{II}^{(2)} = 0.0$.\n   - Case 2 (one parent always MII non-disjunction): $p_I^{(1)} = 0.0$, $p_{II}^{(1)} = 1.0$, $p_I^{(2)} = 0.0$, $p_{II}^{(2)} = 0.0$.\n   - Case 3 (both parents always MI non-disjunction): $p_I^{(1)} = 1.0$, $p_{II}^{(1)} = 0.0$, $p_I^{(2)} = 1.0$, $p_{II}^{(2)} = 0.0$.\n   - Case 4 (moderate, asymmetric rates): $p_I^{(1)} = 0.01$, $p_{II}^{(1)} = 0.02$, $p_I^{(2)} = 0.03$, $p_{II}^{(2)} = 0.04$.\n   - Case 5 (one parent always abnormal with mixed-stage non-disjunction): $p_I^{(1)} = 0.0$, $p_{II}^{(1)} = 0.0$, $p_I^{(2)} = 0.5$, $p_{II}^{(2)} = 0.5$.\n\n6. Output specification:\n   - For each case, compute the expected probability of aneuploid zygotes for the focal chromosome as a real number in $[0,1]$, rounded to six decimal places.\n   - Your program should produce a single line of output containing the results for the five cases, in order, as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5]$, where each $r_i$ is a float rounded to six decimal places. No other text should be printed.\n\nYour solution must begin from the above mechanistic facts about meiosis and basic probability (independence and the law of total probability) and must not assume any pre-derived shortcut formulas. No physical units are involved. Angles and percentages are not used. The task is purely probabilistic-combinatorial and must be solved exactly in terms of the given parameters.", "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded, well-posed, and objective. The provided assumptions are a standard, simplified model of meiotic non-disjunction, and the parameters are consistent and complete. The task is a direct application of probability theory to a biological process, which is a solvable and meaningful problem in computational biology.\n\nThe objective is to compute the probability of a zygote being aneuploid, $P(\\text{aneuploid})$, for a single focal chromosome. Aneuploidy is defined as the zygote having a total chromosome copy number not equal to $2$. A more direct approach is to first calculate the probability of the complementary event, euploidy (copy number equal to $2$), denoted $P(\\text{euploid})$, and then use the relation $P(\\text{aneuploid}) = 1 - P(\\text{euploid})$.\n\nA zygote is formed by the union of a gamete from parent $1$ and a gamete from parent $2$. Let $C_1$ and $C_2$ be the random variables representing the number of copies of the focal chromosome in the gametes from parent $1$ and parent $2$, respectively. The zygote is euploid if the total copy number is $2$, i.e., $C_1 + C_2 = 2$. The possible copy numbers for a gamete are $0$, $1$, or $2$. The combinations of $(C_1, C_2)$ that result in a euploid zygote are $(0, 2)$, $(1, 1)$, and $(2, 0)$.\n\nSince the gametes from each parent are chosen independently, the probability of a euploid zygote is the sum of the probabilities of these mutually exclusive combinations:\n$$P(\\text{euploid}) = P(C_1=0, C_2=2) + P(C_1=1, C_2=1) + P(C_1=2, C_2=0)$$\n$$P(\\text{euploid}) = P(C_1=0)P(C_2=2) + P(C_1=1)P(C_2=1) + P(C_1=2)P(C_2=0)$$\n\nThis reduces the problem to determining the probability distribution of gamete copy number for each parent. Let $g_k^{(j)} = P(C_j=k)$ be the probability that a gamete from parent $j$ has $k$ copies of the chromosome, where $j \\in \\{1, 2\\}$ and $k \\in \\{0, 1, 2\\}$. The euploidy probability is then:\n$$P(\\text{euploid}) = g_0^{(1)}g_2^{(2)} + g_1^{(1)}g_1^{(2)} + g_2^{(1)}g_0^{(2)}$$\n\nWe derive the gamete distribution $g_k^{(j)}$ for a generic parent $j$ with given probabilities of meiotic errors: $p_I^{(j)}$ for Meiosis I (MI) non-disjunction and $p_{II}^{(j)}$ for Meiosis II (MII) non-disjunction. The problem states three mutually exclusive outcomes for any meiosis:\n$1$. Normal segregation, with probability $p_N^{(j)} = 1 - p_I^{(j)} - p_{II}^{(j)}$.\n$2$. MI non-disjunction, with probability $p_I^{(j)}$.\n$3$. MII non-disjunction, with probability $p_{II}^{(j)}$.\n\nWe use the law of total probability, conditioning on the type of meiotic event.\n$$g_k^{(j)} = P(C_j=k) = \\sum_{\\text{event}} P(C_j=k | \\text{event}) P(\\text{event})$$\n\nThe conditional probabilities for gamete copy number, given a meiotic event, are derived from the problem's mechanistic description. It is assumed all four meiotic products are equally likely to form a gamete.\n- **Normal Segregation**: All $4$ resulting gametes are haploid ($1$ copy).\n  The conditional probabilities are: $P(C_j=1 | \\text{Normal}) = 1$, $P(C_j=0 | \\text{Normal}) = 0$, $P(C_j=2 | \\text{Normal}) = 0$.\n- **MI Non-disjunction**: Results in $2$ nullisomic ($0$ copies) and $2$ disomic ($2$ copies) gametes.\n  The conditional probabilities are: $P(C_j=0 | \\text{MI-NDJ}) = 2/4 = 0.5$, $P(C_j=1 | \\text{MI-NDJ}) = 0$, $P(C_j=2 | \\text{MI-NDJ}) = 2/4 = 0.5$.\n- **MII Non-disjunction**: Results in $1$ nullisomic ($0$ copies), $2$ haploid ($1$ copy), and $1$ disomic ($2$ copies) gamete.\n  The conditional probabilities are: $P(C_j=0 | \\text{MII-NDJ}) = 1/4 = 0.25$, $P(C_j=1 | \\text{MII-NDJ}) = 2/4 = 0.5$, $P(C_j=2 | \\text{MII-NDJ}) = 1/4 = 0.25$.\n\nNow, we combine these using the law of total probability for each gamete copy number $k$:\n\n$g_0^{(j)} = P(C_j=0) = P(C_j=0|\\text{Normal})p_N^{(j)} + P(C_j=0|\\text{MI-NDJ})p_I^{(j)} + P(C_j=0|\\text{MII-NDJ})p_{II}^{(j)}$\n$g_0^{(j)} = (0) \\cdot (1 - p_I^{(j)} - p_{II}^{(j)}) + (0.5) \\cdot p_I^{(j)} + (0.25) \\cdot p_{II}^{(j)} = 0.5 p_I^{(j)} + 0.25 p_{II}^{(j)}$\n\n$g_1^{(j)} = P(C_j=1) = P(C_j=1|\\text{Normal})p_N^{(j)} + P(C_j=1|\\text{MI-NDJ})p_I^{(j)} + P(C_j=1|\\text{MII-NDJ})p_{II}^{(j)}$\n$g_1^{(j)} = (1) \\cdot (1 - p_I^{(j)} - p_{II}^{(j)}) + (0) \\cdot p_I^{(j)} + (0.5) \\cdot p_{II}^{(j)} = 1 - p_I^{(j)} - 0.5 p_{II}^{(j)}$\n\n$g_2^{(j)} = P(C_j=2) = P(C_j=2|\\text{Normal})p_N^{(j)} + P(C_j=2|\\text{MI-NDJ})p_I^{(j)} + P(C_j=2|\\text{MII-NDJ})p_{II}^{(j)}$\n$g_2^{(j)} = (0) \\cdot (1 - p_I^{(j)} - p_{II}^{(j)}) + (0.5) \\cdot p_I^{(j)} + (0.25) \\cdot p_{II}^{(j)} = 0.5 p_I^{(j)} + 0.25 p_{II}^{(j)}$\n\nThe overall algorithm is as follows:\n$1$. For each of the five test cases, take the input parameters $(p_I^{(1)}, p_{II}^{(1)}, p_I^{(2)}, p_{II}^{(2)})$.\n$2$. For each parent $j \\in \\{1, 2\\}$, use the formulas above to calculate the gamete copy number probabilities $g_0^{(j)}$, $g_1^{(j)}$, and $g_2^{(j)}$.\n$3$. Calculate the probability of a euploid zygote: $P(\\text{euploid}) = g_0^{(1)}g_2^{(2)} + g_1^{(1)}g_1^{(2)} + g_2^{(1)}g_0^{(2)}$.\n$4$. Calculate the final probability of an aneuploid zygote: $P(\\text{aneuploid}) = 1 - P(\\text{euploid})$.\n$5$. Round the result to six decimal places as required.\n\nThis procedure is implemented to calculate the required probabilities for the given test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are necessary for this problem.\n\ndef solve():\n    \"\"\"\n    Solves the meiotic non-disjunction problem by calculating the probability of\n    aneuploidy for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (p_I_parent1, p_II_parent1, p_I_parent2, p_II_parent2)\n    test_cases = [\n        (0.0, 0.0, 0.0, 0.0),  # Case 1: Baseline Mendelian\n        (0.0, 1.0, 0.0, 0.0),  # Case 2: One parent always MII non-disjunction\n        (1.0, 0.0, 1.0, 0.0),  # Case 3: Both parents always MI non-disjunction\n        (0.01, 0.02, 0.03, 0.04),  # Case 4: Moderate, asymmetric rates\n        (0.0, 0.0, 0.5, 0.5)   # Case 5: One parent always abnormal (mixed)\n    ]\n\n    results = []\n    for case in test_cases:\n        p_I1, p_II1, p_I2, p_II2 = case\n        \n        # This function encapsulates the core logic derived from first principles.\n        prob_aneuploidy = calculate_aneuploidy_prob(p_I1, p_II1, p_I2, p_II2)\n        results.append(prob_aneuploidy)\n\n    # Format the final output string as specified.\n    # Each result is formatted to six decimal places.\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    print(output_str)\n\ndef get_gamete_distribution(p_I, p_II):\n    \"\"\"\n    Calculates the probability distribution of gamete copy numbers (0, 1, or 2)\n    for a single parent based on non-disjunction probabilities.\n\n    Args:\n        p_I (float): Probability of Meiosis I non-disjunction.\n        p_II (float): Probability of Meiosis II non-disjunction.\n\n    Returns:\n        tuple: A tuple (g0, g1, g2) where gi is the probability of a gamete\n               having i copies of the chromosome.\n    \"\"\"\n    \n    # Probability of a gamete with 0 copies (nullisomic)\n    # This arises from MI-NDJ (yields 2/4 nullisomic) or MII-NDJ (yields 1/4 nullisomic).\n    g0 = 0.5 * p_I + 0.25 * p_II\n    \n    # Probability of a gamete with 2 copies (disomic)\n    # This also arises from MI-NDJ (yields 2/4 disomic) or MII-NDJ (yields 1/4 disomic).\n    g2 = 0.5 * p_I + 0.25 * p_II\n\n    # Probability of a gamete with 1 copy (haploid)\n    # This arises from normal meiosis (yields 4/4 haploid) or MII-NDJ (yields 2/4 haploid).\n    # It is most easily calculated as 1 minus the other probabilities.\n    # The direct derivation is: (1 - p_I - p_II) * 1.0 + p_II * 0.5 = 1 - p_I - 0.5 * p_II.\n    g1 = 1.0 - g0 - g2\n\n    return (g0, g1, g2)\n\ndef calculate_aneuploidy_prob(p_I1, p_II1, p_I2, p_II2):\n    \"\"\"\n    Computes the total probability of an aneuploid zygote.\n\n    Args:\n        p_I1, p_II1 (float): Non-disjunction rates for parent 1.\n        p_I2, p_II2 (float): Non-disjunction rates for parent 2.\n\n    Returns:\n        float: The probability of aneuploidy.\n    \"\"\"\n    # Get the gamete copy number distributions for each parent.\n    dist1 = get_gamete_distribution(p_I1, p_II1)\n    dist2 = get_gamete_distribution(p_I2, p_II2)\n    \n    g0_1, g1_1, g2_1 = dist1\n    g0_2, g1_2, g2_2 = dist2\n\n    # A zygote is euploid if the sum of chromosome copies is 2.\n    # The independent events leading to a euploid zygote are:\n    # - Parent 1 contributes 0, Parent 2 contributes 2\n    # - Parent 1 contributes 1, Parent 2 contributes 1\n    # - Parent 1 contributes 2, Parent 2 contributes 0\n    prob_euploid = (g0_1 * g2_2) + (g1_1 * g1_2) + (g2_1 * g0_2)\n    \n    # The probability of aneuploidy is the complement of euploidy.\n    prob_aneuploid = 1.0 - prob_euploid\n    \n    return prob_aneuploid\n\nsolve()\n```", "id": "2403845"}, {"introduction": "Our final practice elevates the principles of inheritance to the level of developmental pattern formation. Here, you will simulate the iconic coat pattern of a calico cat, a classic example of genetic mosaicism. This model integrates Mendelian X-linked inheritance with the stochastic process of X-chromosome inactivation across a grid of cells. This advanced simulation exercise demonstrates how simple, random rules at the cellular level can give rise to complex, emergent macroscopic phenotypes, a central theme in computational and systems biology [@problem_id:2403838].", "problem": "You are to formalize and simulate X-linked mosaicism consistent with Mendelian inheritance for a heterozygous female at the orange locus in domestic cats by constructing a mathematically specified model of random X-chromosome inactivation across a discrete tissue. Consider a square lattice of size $N \\times N$ indexed by integer coordinates $(i,j)$ with $i \\in \\{0,1,\\dots,N-1\\}$ and $j \\in \\{0,1,\\dots,N-1\\}$. Each lattice site represents a somatic cell at the time of observation. A set of $M$ distinct founder sites $\\{s_k\\}_{k=1}^M$ is selected uniformly at random without replacement from the $N^2$ lattice sites using a Pseudo-Random Number Generator (PRNG) initialized with a given nonnegative integer seed $r$. Each founder $s_k$ independently inactivates one of the two X-chromosomes so that the active X encodes either orange or non-orange pigment at a single X-linked locus. Write the founder’s expression state as $S_k \\in \\{0,1\\}$, where $S_k=1$ denotes orange expression and $S_k=0$ denotes non-orange expression. The random variable $S_k$ is distributed as $\\mathrm{Bernoulli}(p)$ with parameter $p \\in [0,1]$, independently across $k$.\n\nModel clonal expansion geometrically as follows. For any lattice site $u=(i,j)$ and any founder site $s_k=(x_k,y_k)$, define the Manhattan distance\n$$\nd_1(u,s_k) = |i-x_k| + |j-y_k|.\n$$\nAssign each lattice site $u$ to the index of a founder in the set of minimizers of $d_1(u,s_k)$ over $k \\in \\{1,\\dots,M\\}$. If there is a unique minimizer, choose it. If there are multiple minimizers, select one uniformly at random among the minimizers using the same PRNG initialized with seed $r$ (and continuing its state from all earlier uses). Let $f(u) \\in \\{1,\\dots,M\\}$ denote the selected founder index for $u$. The expression state of site $u$ is then $G(u) = S_{f(u)} \\in \\{0,1\\}$. Collect these into an $N \\times N$ grid $G$, where $G_{ij} = G((i,j))$.\n\nFor each parameter set $(N,M,p,r)$ given in the test suite below, compute the following four quantitative outputs:\n\n1) Orange fraction $F$, defined by\n$$\nF = \\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} G_{ij}.\n$$\nReport $F$ rounded to $6$ decimal places.\n\n2) Number of orange patches $C$, defined as the number of connected components in the induced subgraph on the vertex set $\\{(i,j) \\mid G_{ij}=1\\}$ with $4$-neighbor adjacency (two sites are adjacent if and only if their coordinates differ by exactly $1$ in exactly one dimension and are equal in the other). Report $C$ as an integer.\n\n3) Average orange patch area $A$, defined as\n$$\nA = \n\\begin{cases}\n\\frac{1}{C}\\sum_{c=1}^{C} |P_c|, & \\text{if } C \\ge 1,\\\\\n0, & \\text{if } C=0,\n\\end{cases}\n$$\nwhere $P_c$ is the set of lattice sites belonging to the $c$-th orange connected component and $|P_c|$ is its cardinality. Report $A$ rounded to $6$ decimal places.\n\n4) Interface length $L$, defined as the count of edges between adjacent lattice sites with differing states under $4$-neighbor adjacency:\n$$\nL = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-2} \\mathbf{1}[G_{i,j} \\ne G_{i,j+1}] \\;+\\; \\sum_{i=0}^{N-2}\\sum_{j=0}^{N-1} \\mathbf{1}[G_{i,j} \\ne G_{i+1,j}],\n$$\nreported as an integer.\n\nAll randomness must be generated using the specified PRNG with the given seed $r$, applied first to sample founder locations, then to sample founder states, and then to resolve any distance ties during assignment of lattice sites to founders.\n\nTest suite. Use exactly the following parameter sets, in this order:\n- Case $1$: $(N,M,p,r) = (8,5,0.5,42)$.\n- Case $2$: $(N,M,p,r) = (1,1,0.5,7)$.\n- Case $3$: $(N,M,p,r) = (10,1,0.5,123)$.\n- Case $4$: $(N,M,p,r) = (12,30,0.8,314159)$.\n- Case $5$: $(N,M,p,r) = (6,36,0.3,271828)$.\n\nFinal output format. Your program should produce a single line of output containing a list of per-case result records, in order, with no spaces. Each record is the list $[F,C,A,L]$ for that case. Thus the entire output must be a single line of the form\n$[[F_1,C_1,A_1,L_1],[F_2,C_2,A_2,L_2],\\dots,[F_5,C_5,A_5,L_5]]$\nwhere $F_k$ and $A_k$ are rounded to $6$ decimal places and $C_k$ and $L_k$ are integers.", "solution": "The biological foundation is Mendelian segregation at an X-linked locus combined with random X-chromosome inactivation in female mammals. A heterozygous female with genotype $X^O X^B$ carries two alleles at an X-linked pigmentation locus: an orange allele and a non-orange allele. During early embryogenesis, random X-chromosome inactivation leads each somatic lineage to inactivate one X, fixing the active allele in that lineage. The observable mosaic is a spatial mixture of clones expressing either orange or non-orange pigment. This process can be abstracted as independent founder lineages that occupy space, with an assignment of an expression state to each lineage.\n\nWe formalize this as follows. Consider an $N \\times N$ discrete lattice representing sites occupied by cells. Let $\\{s_k\\}_{k=1}^M$ be $M$ founder sites placed uniformly at random without replacement among the $N^2$ lattice sites, using a fixed-seed Pseudo-Random Number Generator (PRNG) with seed $r$. Each founder $k$ is assigned an independent expression state $S_k \\in \\{0,1\\}$ with distribution $\\mathrm{Bernoulli}(p)$, where $S_k=1$ denotes that the orange allele is active (orange expression) and $S_k=0$ denotes that the non-orange allele is active (non-orange expression). This models the Mendelian heterozygous state combined with random X inactivation, with $p$ admitting possible skew.\n\nTo map founders to all lattice sites, we define for any site $u=(i,j)$ and founder $s_k=(x_k,y_k)$ the Manhattan distance\n$$\nd_1(u,s_k) = |i-x_k| + |j-y_k|.\n$$\nThis induces a Voronoi-type partition under the $L_1$ metric: each site $u$ is assigned to a founder index in the set of minimizers of $d_1(u,s_k)$ over $k \\in \\{1,\\dots,M\\}$. If the minimizer is unique, it is selected; if there are multiple minimizers, one is selected uniformly at random using the same PRNG (continuing from its current state so that all randomness is globally coupled by the single seed $r$). Denote by $f(u)$ the selected founder index. The expression at $u$ is then $G(u) = S_{f(u)}$, yielding a grid $G \\in \\{0,1\\}^{N \\times N}$ with $G_{ij} = G((i,j))$.\n\nFrom $G$, compute the four required outputs:\n\n1) The orange fraction is\n$$\nF = \\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} G_{ij}.\n$$\nThis is the empirical proportion of orange-expressing sites. In expectation conditioned on the random founders and states, $\\mathbb{E}[F]=p$, though finite-size geometry and tie-breaking introduce sampling variability around $p$. The reported value must be rounded to $6$ decimal places.\n\n2) The number of orange patches $C$ is the count of connected components in the subgraph induced by $\\{(i,j) : G_{ij}=1\\}$ using $4$-neighbor adjacency. This is computed by scanning the grid and performing breadth-first or depth-first search restricted to sites with $G_{ij}=1$, marking visited sites to avoid recounting. Each time an unvisited orange site is found, a new component is started and all orange sites reachable via $4$-neighbor moves are visited; the total number of such starts equals $C$.\n\n3) The average orange patch area $A$ is\n$$\nA = \n\\begin{cases}\n\\frac{1}{C}\\sum_{c=1}^{C} |P_c|, & C \\ge 1,\\\\\n0, & C=0,\n\\end{cases}\n$$\nwhere $P_c$ is the set of lattice sites in the $c$-th orange connected component. Because the components form a partition of the orange sites, $\\sum_{c=1}^{C} |P_c| = \\sum_{i,j} G_{ij}$, so $A$ equals the total number of orange sites divided by $C$ when $C \\ge 1$, and equals $0$ when there are no orange sites. The reported value must be rounded to $6$ decimal places.\n\n4) The interface length $L$ is the number of adjacent pairs of sites with different states under $4$-neighbor adjacency. To avoid double counting, sum horizontal differences and vertical differences separately:\n$$\nL = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-2} \\mathbf{1}[G_{i,j} \\ne G_{i,j+1}] \\;+\\; \\sum_{i=0}^{N-2}\\sum_{j=0}^{N-1} \\mathbf{1}[G_{i,j} \\ne G_{i+1,j}],\n$$\nwhere $\\mathbf{1}[\\cdot]$ is the indicator function. This yields an integer.\n\nThe PRNG with seed $r$ is used consistently in three places, in order: to sample the $M$ founder sites without replacement, to sample the $M$ independent founder states $S_k \\sim \\mathrm{Bernoulli}(p)$, and to resolve any distance ties when assigning sites to founders. This fully determines $G$ and the outputs for each case. The final program must emit a single line containing $5$ records, one per test case, each record being $[F,C,A,L]$ with $F$ and $A$ rounded to $6$ decimal places and $C$ and $L$ integers, with no spaces, in the order specified in the test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sample_founders(N, M, rng):\n    # Sample M distinct lattice indices from N*N sites\n    total = N * N\n    flat_indices = rng.choice(total, size=M, replace=False)\n    rows = flat_indices // N\n    cols = flat_indices % N\n    founders = np.stack([rows, cols], axis=1)  # shape (M, 2)\n    return founders\n\ndef sample_founder_states(M, p, rng):\n    # Bernoulli(p) for each founder: True for orange (1), False for non-orange (0)\n    return rng.random(M) < p\n\ndef assign_sites_to_founders(N, founders, rng):\n    # For each site, compute Manhattan distances to all founders and choose minimizer\n    M = founders.shape[0]\n    assigned = np.empty((N, N), dtype=np.int32)\n    # Pre-extract founder coords for vectorized distance computation per cell\n    f_rows = founders[:, 0]\n    f_cols = founders[:, 1]\n    for i in range(N):\n        for j in range(N):\n            # Manhattan distances to all founders\n            dists = np.abs(f_rows - i) + np.abs(f_cols - j)\n            min_dist = dists.min()\n            candidates = np.flatnonzero(dists == min_dist)\n            if candidates.size == 1:\n                assigned[i, j] = candidates[0]\n            else:\n                # Randomly choose among ties\n                assigned[i, j] = rng.choice(candidates)\n    return assigned\n\ndef count_orange_components_and_sizes(grid):\n    # grid: boolean or 0/1 array of shape (N, N)\n    N = grid.shape[0]\n    visited = np.zeros_like(grid, dtype=bool)\n    comp_sizes = []\n    # 4-neighbor directions\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i, j] and not visited[i, j]:\n                # Start BFS\n                stack = [(i, j)]\n                visited[i, j] = True\n                size = 0\n                while stack:\n                    r, c = stack.pop()\n                    size += 1\n                    for dr, dc in dirs:\n                        rr, cc = r + dr, c + dc\n                        if 0 <= rr < N and 0 <= cc < N:\n                            if grid[rr, cc] and not visited[rr, cc]:\n                                visited[rr, cc] = True\n                                stack.append((rr, cc))\n                comp_sizes.append(size)\n    return len(comp_sizes), comp_sizes\n\ndef interface_length(grid):\n    # Count horizontal and vertical interfaces where neighbors differ\n    horiz = np.sum(grid[:, :-1] != grid[:, 1:])\n    vert = np.sum(grid[:-1, :] != grid[1:, :])\n    return int(horiz + vert)\n\ndef run_case(N, M, p, r):\n    rng = np.random.default_rng(r)\n    founders = sample_founders(N, M, rng)\n    founder_states = sample_founder_states(M, p, rng)\n    assigned = assign_sites_to_founders(N, founders, rng)\n    grid = founder_states[assigned].astype(np.int8)  # 1 for orange, 0 for non-orange\n\n    total_cells = N * N\n    orange_count = int(grid.sum())\n    F = orange_count / total_cells\n\n    C, sizes = count_orange_components_and_sizes(grid.astype(bool))\n    if C > 0:\n        A = orange_count / C\n    else:\n        A = 0.0\n\n    L = interface_length(grid)\n\n    # Round floats to 6 decimal places for output formatting\n    F = round(F + 0.0, 6)\n    A = round(A + 0.0, 6)\n\n    return (F, C, A, L)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (N, M, p, r)\n    test_cases = [\n        (8, 5, 0.5, 42),\n        (1, 1, 0.5, 7),\n        (10, 1, 0.5, 123),\n        (12, 30, 0.8, 314159),\n        (6, 36, 0.3, 271828),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, p, r = case\n        F, C, A, L = run_case(N, M, p, r)\n        results.append((F, C, A, L))\n\n    # Build exact output string with no spaces, floats with 6 decimals\n    record_strs = []\n    for F, C, A, L in results:\n        # Ensure fixed 6 decimal places for floats\n        record_strs.append(f\"[{F:.6f},{C},{A:.6f},{L}]\")\n    output = \"[\" + \",\".join(record_strs) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2403838"}]}