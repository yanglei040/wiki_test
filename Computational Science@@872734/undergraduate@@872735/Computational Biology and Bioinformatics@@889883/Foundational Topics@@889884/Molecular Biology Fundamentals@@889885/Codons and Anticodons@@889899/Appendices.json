{"hands_on_practices": [{"introduction": "We begin by exploring a fundamental property of the genetic code: its degeneracy. This exercise [@problem_id:2380340] uses information theory, a cornerstone of bioinformatics, to quantify the \"uncertainty\" or information lost when a specific amino acid is observed, as multiple codons could have encoded it. This practice builds a deep, quantitative intuition for why synonymous codons are a key feature of molecular biology.", "problem": "A messenger ribonucleic acid (mRNA) coding sequence is translated by the ribosome, which maps each codon (a triplet of nucleotides) to an amino acid according to the standard genetic code. Consider the following model: at each coding position, the codon is chosen independently and uniformly at random from the $61$ sense codons (stop codons are excluded), and translation is error-free. The mapping from codons to amino acids is many-to-one due to synonymous codons. Let $C$ be the random variable denoting the codon at a position, and let $A$ be the random variable denoting the translated amino acid at that position. Use Shannon entropy in bits, where for a discrete random variable $X$ with distribution $\\{p_x\\}$, $H(X) = - \\sum_{x} p_x \\log_{2} p_x$.\n\nIn the standard genetic code, the number of synonymous codons per amino acid is as follows: two amino acids have $1$ codon each (methionine and tryptophan), nine amino acids have $2$ codons each (phenylalanine, tyrosine, histidine, glutamine, asparagine, lysine, aspartate, glutamate, cysteine), one amino acid has $3$ codons (isoleucine), five amino acids have $4$ codons each (valine, proline, threonine, alanine, glycine), and three amino acids have $6$ codons each (serine, leucine, arginine). These counts sum to $61$ sense codons.\n\nDefine the information lost by translation at a position as the conditional entropy $H(C \\mid A)$, which quantifies the expected uncertainty about the original codon after observing the amino acid. Under the model above, compute the expected information loss per translated amino acid, in bits. Round your answer to four significant figures, and express it in bits per amino acid.", "solution": "The problem statement is first subjected to critical validation.\n\nStep 1: Extract Givens.\n-   The system is an mRNA coding sequence being translated.\n-   Model: At each position, a codon is chosen independently and uniformly at random from the $61$ sense codons. Stop codons are excluded.\n-   Translation is error-free.\n-   $C$ is the random variable for the codon at a position.\n-   $A$ is the random variable for the translated amino acid at that position.\n-   The entropy formula is Shannon entropy in bits: $H(X) = - \\sum_{x} p_x \\log_{2}(p_x)$.\n-   The quantity to be computed is the information lost by translation, defined as the conditional entropy $H(C \\mid A)$.\n-   The structure of the standard genetic code is provided by the number of synonymous codons for each amino acid:\n    -   $2$ amino acids have $1$ codon each.\n    -   $9$ amino acids have $2$ codons each.\n    -   $1$ amino acid has $3$ codons.\n    -   $5$ amino acids have $4$ codons each.\n    -   $3$ amino acids have $6$ codons each.\n-   The total number of sense codons is $2 \\times 1 + 9 \\times 2 + 1 \\times 3 + 5 \\times 4 + 3 \\times 6 = 2 + 18 + 3 + 20 + 18 = 61$. This is consistent.\n-   The final answer must be a numerical value in bits, rounded to four significant figures.\n\nStep 2: Validate Using Extracted Givens.\n-   **Scientifically Grounded**: The problem is grounded in information theory and molecular biology. It uses standard definitions of Shannon entropy and the accepted structure of the genetic code. The model of uniform codon probability is a standard simplification used in theoretical exercises, not a claim about biological reality. It is scientifically valid as a model-based problem.\n-   **Well-Posed**: The problem is well-posed. It provides all necessary data and a clear objective. The quantity $H(C \\mid A)$ is a well-defined mathematical object, and its calculation is feasible given the provided information. A unique numerical solution exists.\n-   **Objective**: The problem is stated in objective, mathematical language. It is free from ambiguity and subjective claims.\n-   **Conclusion**: The problem does not violate any of the specified criteria for invalidity. It is a valid, solvable problem in computational biology.\n\nStep 3: Verdict and Action.\n-   The problem is valid. A full solution will be provided.\n\nThe task is to compute the conditional entropy $H(C \\mid A)$, which represents the expected uncertainty remaining about the codon $C$ once the amino acid $A$ is known. The definition of conditional entropy is:\n$$\nH(C \\mid A) = \\sum_{a \\in \\mathcal{A}} p(A=a) H(C \\mid A=a)\n$$\nwhere $\\mathcal{A}$ is the set of all $20$ standard amino acids, and $p(A=a)$ is the probability of observing amino acid $a$.\n\nFirst, we must determine the probability distribution of the amino acids, $p(A=a)$. The problem states that each of the $61$ sense codons is chosen with uniform probability. Therefore, for any specific sense codon $c$, its probability is $p(C=c) = \\frac{1}{61}$.\nLet $N_a$ be the number of synonymous codons that code for a specific amino acid $a$. The probability of observing amino acid $a$ is the sum of the probabilities of all codons that map to it:\n$$\np(A=a) = \\sum_{c \\to a} p(C=c) = \\sum_{c \\to a} \\frac{1}{61} = \\frac{N_a}{61}\n$$\n\nNext, we must determine the conditional entropy for a given amino acid, $H(C \\mid A=a)$. This is the entropy of the distribution of codons, given that they all code for the amino acid $a$.\n$$\nH(C \\mid A=a) = - \\sum_{c} p(C=c \\mid A=a) \\log_{2}(p(C=c \\mid A=a))\n$$\nThe conditional probability $p(C=c \\mid A=a)$ is the probability of codon $c$ given that the amino acid is $a$. By the definition of conditional probability:\n$$\np(C=c \\mid A=a) = \\frac{p(C=c, A=a)}{p(A=a)}\n$$\nIf codon $c$ does not code for amino acid $a$, this probability is $0$. If codon $c$ does code for amino acid $a$, the event $\\{C=c\\}$ is a subset of the event $\\{A=a\\}$, so $p(C=c, A=a) = p(C=c) = \\frac{1}{61}$.\nTherefore, for a codon $c$ that codes for $a$:\n$$\np(C=c \\mid A=a) = \\frac{1/61}{N_a/61} = \\frac{1}{N_a}\n$$\nThis result is intuitive: if we know the amino acid is $a$, and there are $N_a$ possible codons for it, and each was originally equally likely, then they remain equally likely within that subset. The conditional probability for each of these $N_a$ codons is $\\frac{1}{N_a}$.\n\nNow we can compute $H(C \\mid A=a)$. The sum is over the $N_a$ codons that map to $a$:\n$$\nH(C \\mid A=a) = - \\sum_{c \\to a} \\frac{1}{N_a} \\log_{2}\\left(\\frac{1}{N_a}\\right) = - N_a \\left(\\frac{1}{N_a} \\log_{2}\\left(\\frac{1}{N_a}\\right)\\right) = - \\log_{2}\\left(\\frac{1}{N_a}\\right) = \\log_{2}(N_a)\n$$\nThis entropy is $0$ if $N_a=1$, which is correct as there is no uncertainty.\n\nNow we combine these results to compute the total conditional entropy $H(C \\mid A)$:\n$$\nH(C \\mid A) = \\sum_{a \\in \\mathcal{A}} p(A=a) H(C \\mid A=a) = \\sum_{a \\in \\mathcal{A}} \\frac{N_a}{61} \\log_{2}(N_a)\n$$\nWe can group the amino acids by their number of codons ($N_a$). Let $k_N$ be the number of amino acids with $N$ codons. The sum can be rewritten as:\n$$\nH(C \\mid A) = \\frac{1}{61} \\sum_{N} k_N \\cdot N \\cdot \\log_{2}(N)\n$$\nUsing the data provided:\n-   $N=1$: $k_1 = 2$\n-   $N=2$: $k_2 = 9$\n-   $N=3$: $k_3 = 1$\n-   $N=4$: $k_4 = 5$\n-   $N=6$: $k_6 = 3$\n\nThe sum becomes:\n$$\nH(C \\mid A) = \\frac{1}{61} \\left[ (2 \\cdot 1 \\cdot \\log_{2}(1)) + (9 \\cdot 2 \\cdot \\log_{2}(2)) + (1 \\cdot 3 \\cdot \\log_{2}(3)) + (5 \\cdot 4 \\cdot \\log_{2}(4)) + (3 \\cdot 6 \\cdot \\log_{2}(6)) \\right]\n$$\nWe evaluate each term:\n-   $2 \\cdot 1 \\cdot \\log_{2}(1) = 2 \\cdot 0 = 0$\n-   $9 \\cdot 2 \\cdot \\log_{2}(2) = 18 \\cdot 1 = 18$\n-   $1 \\cdot 3 \\cdot \\log_{2}(3) = 3 \\log_{2}(3)$\n-   $5 \\cdot 4 \\cdot \\log_{2}(4) = 20 \\cdot \\log_{2}(2^2) = 20 \\cdot 2 = 40$\n-   $3 \\cdot 6 \\cdot \\log_{2}(6) = 18 \\cdot \\log_{2}(2 \\cdot 3) = 18 (\\log_{2}(2) + \\log_{2}(3)) = 18 + 18 \\log_{2}(3)$\n\nSumming these terms:\n$$\n\\sum = 0 + 18 + 3 \\log_{2}(3) + 40 + 18 + 18 \\log_{2}(3) = (18 + 40 + 18) + (3 + 18) \\log_{2}(3) = 76 + 21 \\log_{2}(3)\n$$\nTherefore, the exact expression for the conditional entropy is:\n$$\nH(C \\mid A) = \\frac{76 + 21 \\log_{2}(3)}{61}\n$$\nTo obtain the numerical value, we use $\\log_{2}(3) = \\frac{\\ln(3)}{\\ln(2)} \\approx \\frac{1.098612}{0.693147} \\approx 1.5849625$.\n$$\nH(C \\mid A) \\approx \\frac{76 + 21 \\cdot (1.5849625)}{61} = \\frac{76 + 33.2842125}{61} = \\frac{109.2842125}{61} \\approx 1.791544467\n$$\nThe problem requires the result to be rounded to four significant figures.\n$$\n1.791544467 \\approx 1.792\n$$\nThe information lost by translation is thus approximately $1.792$ bits per amino acid.", "answer": "$$\n\\boxed{1.792}\n$$", "id": "2380340"}, {"introduction": "Moving from the static code to the dynamic process of translation, this practice [@problem_id:2380386] challenges you to determine the minimum number of tRNA molecules needed to read a genome. You will learn to account for the \"wobble\" rules that permit flexible base pairing between codons and anticodons. This exercise hones crucial algorithmic modeling skills by guiding you to translate a biological puzzle into a classic computational task known as the set cover problem.", "problem": "You are given the task of computing the minimal number of transfer ribonucleic acid (tRNA) species, denoted by $N_{\\min}$, required to translate a given ribonucleic acid (RNA) genome under specified non-standard wobble-pairing rules. The Central Dogma of molecular biology states that deoxyribonucleic acid (DNA) is transcribed to RNA, which is translated into protein. Translation decodes RNA codons (triplets over the alphabet $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$) into amino acids via base pairing with tRNA anticodons. Standard Watson–Crick base pairing applies at codon positions $1$ and $2$ (anticodon positions $3$ and $2$), while the wobble position (codon position $3$ and anticodon position $1$) allows expanded pairing governed by modification-dependent rules. Each tRNA species is assumed to be specific to a single amino acid, and is characterized here by its anticodon wobble base at position $1$ only; anticodon positions $2$ and $3$ are assumed to be strict Watson–Crick complements of the codon’s first two positions. Stop codons are not translated and must be ignored.\n\nFundamental base and constraints:\n- Codons are length-$3$ words on $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$. The canonical nuclear genetic code (standard genetic code) maps $64$ codons to $20$ amino acids and $3$ stops (the three stop codons are $\\mathrm{UAA}$, $\\mathrm{UAG}$, and $\\mathrm{UGA}$). Only sense codons (non-stop) require tRNAs.\n- For any fixed amino acid and fixed first-two bases $XY \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}^2$, the set of its synonymous codons in that “family box” is $XY\\{b \\mid b \\in \\mathcal{B}_{aa,XY}\\}$, where $\\mathcal{B}_{aa,XY} \\subseteq \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ depends on the standard genetic code assignment. A tRNA species for that box has anticodon positions $2$ and $3$ complementary to $X$ and $Y$, and its anticodon wobble base determines which third-base letters it can decode in that box. A tRNA cannot serve codons that translate to a different amino acid, even if its anticodon would base-pair, because aminoacylation is amino-acid specific.\n- The wobble pairing rules are provided as a mapping from the anticodon wobble base symbol to the set of codon-third-base letters it decodes. For a given amino acid and $XY$ family box, if the set of third bases observed in the genome for that box is $S \\subseteq \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$, then the minimal number of tRNAs required for that box equals the minimal number of wobble-base types whose decoded-letter sets cover $S$. This is a minimal set cover on a ground set of size at most $4$.\n\nNon-standard wobble rule sets to be used:\n- Rule set $\\mathcal{R}_{\\mathrm{NS1}}$ (mitochondria-like superwobble permitted): \n  $\\mathrm{A}\\to\\{\\mathrm{U}\\}$, $\\mathrm{C}\\to\\{\\mathrm{G}\\}$, $\\mathrm{G}\\to\\{\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{U}\\to\\{\\mathrm{A},\\mathrm{G}\\}$, $\\mathrm{I}\\to\\{\\mathrm{A},\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{W}\\to\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$, $\\mathrm{K}\\to\\{\\mathrm{A}\\}$, $\\mathrm{Q}\\to\\{\\mathrm{U},\\mathrm{C}\\}$.\n- Rule set $\\mathcal{R}_{\\mathrm{NS2}}$ (no inosine; expanded but not superwobble): \n  $\\mathrm{A}\\to\\{\\mathrm{U}\\}$, $\\mathrm{C}\\to\\{\\mathrm{G}\\}$, $\\mathrm{G}\\to\\{\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{U}\\to\\{\\mathrm{A},\\mathrm{G}\\}$, $\\mathrm{Q}\\to\\{\\mathrm{U},\\mathrm{C}\\}$, $\\mathrm{M}\\to\\{\\mathrm{A},\\mathrm{G}\\}$, $\\mathrm{K}\\to\\{\\mathrm{A}\\}$.\n- Rule set $\\mathcal{R}_{\\mathrm{NS3}}$ (restrictive wobble; suppressed $\\mathrm{G}\\text{-}\\mathrm{U}$ pairing): \n  $\\mathrm{A}\\to\\{\\mathrm{U}\\}$, $\\mathrm{C}\\to\\{\\mathrm{G}\\}$, $\\mathrm{G}\\to\\{\\mathrm{C}\\}$, $\\mathrm{U}\\to\\{\\mathrm{A}\\}$, $\\mathrm{I}\\to\\{\\mathrm{A},\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{K}\\to\\{\\mathrm{A}\\}$, $\\mathrm{Q}\\to\\{\\mathrm{U},\\mathrm{C}\\}$.\n\nTask:\n- Implement a program that, for each test case, computes $N_{\\min}$ as follows. For each amino acid, partition the codons present in the genome that encode that amino acid by their first two bases $XY$. For each partition, let $S$ be the set of third-base letters actually observed in the genome for that amino acid and $XY$. Using the specified wobble rule set, find the minimal number of anticodon wobble base types whose decoded-letter sets cover $S$. Sum this minimal count over all amino acids and all $XY$ partitions to obtain $N_{\\min}$ for the genome under that rule set. Ignore stop codons entirely. All counts are integers and should be reported as such.\n\nTest suite:\n- Case $1$: Genome $\\mathcal{G}_1$ with codons \n  $\\{\\mathrm{AUG},\\mathrm{GCU},\\mathrm{GCC},\\mathrm{GCA},\\mathrm{GCG},\\mathrm{GGU},\\mathrm{GGC},\\mathrm{GGA},\\mathrm{AUU},\\mathrm{AUC},\\mathrm{AUA},\\mathrm{UUU},\\mathrm{UUC},\\mathrm{CCU},\\mathrm{CCA},\\mathrm{UCU},\\mathrm{UCC},\\mathrm{UCA},\\mathrm{UCG},\\mathrm{AGU},\\mathrm{CUA},\\mathrm{CUG},\\mathrm{UUA},\\mathrm{GUU},\\mathrm{UAU},\\mathrm{UAC},\\mathrm{UAA},\\mathrm{UGA},\\mathrm{UAG}\\}$ evaluated under $\\mathcal{R}_{\\mathrm{NS1}}$.\n- Case $2$: Same genome $\\mathcal{G}_1$ under $\\mathcal{R}_{\\mathrm{NS2}}$.\n- Case $3$: Same genome $\\mathcal{G}_1$ under $\\mathcal{R}_{\\mathrm{NS3}}$.\n- Case $4$: Genome $\\mathcal{G}_2$ with codons consisting of $\\mathrm{UUU}$ repeated $10$ times plus one stop $\\mathrm{UAA}$, evaluated under $\\mathcal{R}_{\\mathrm{NS3}}$.\n- Case $5$: Genome $\\mathcal{G}_{\\mathrm{all}}$ containing each of the $61$ sense codons exactly once (all standard genetic code sense codons), evaluated under $\\mathcal{R}_{\\mathrm{NS3}}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$), where each $\\text{result}_i$ is the integer $N_{\\min}$ for the corresponding case in the order listed above. No user input should be read; all data must be embedded in the program. No physical units or angles are involved. All outputs are integers. The implementation language and environment are specified in the final answer instructions.", "solution": "The problem statement is valid. It is scientifically grounded, well-posed, and objective. It presents a clear computational task based on established principles of molecular biology, specifically the translation of messenger RNA into protein. The problem asks for the calculation of the minimal number of transfer RNA (tRNA) species, $N_{\\min}$, required to translate a given set of RNA codons under specified non-standard wobble pairing rules. This is a well-defined optimization problem that can be decomposed into a series of minimum set cover problems.\n\nThe fundamental principle is that protein synthesis relies on the recognition of three-base codons on an mRNA molecule by the corresponding three-base anticodons of tRNA molecules. Each tRNA is charged with a specific amino acid. While base pairing at the first two codon positions with the third and second anticodon positions, respectively, follows standard Watson-Crick rules ($\\mathrm{A}$-$\\mathrm{U}$, $\\mathrm{G}$-$\\mathrm{C}$), the pairing at the \"wobble\" position (codon position $3$, anticodon position $1$) is more flexible. This flexibility is often governed by chemical modifications to the anticodon's first base. The problem provides three hypothetical sets of such wobble pairing rules, $\\mathcal{R}_{\\mathrm{NS1}}$, $\\mathcal{R}_{\\mathrm{NS2}}$, and $\\mathcal{R}_{\\mathrm{NS3}}$, mapping anticodon wobble bases to the set of codon third bases they can recognize.\n\nThe core constraint is that a single tRNA species, defined by its anticodon and amino acid specificity, cannot service codons that translate to different amino acids. This leads to the central algorithmic step: partitioning the problem. The total tRNA count, $N_{\\min}$, is the sum of the minimum tRNAs required for distinct groups of codons. These groups are defined by a unique pair of (amino acid, codon prefix $XY$), where $XY$ are the first two bases of the codons in that group.\n\nThe solution proceeds as follows:\n\nStep $1$: Data Structuring.\nFirst, we encode the necessary biological and problem-specific data.\n- The standard nuclear genetic code is represented as a mapping from each of the $64$ codons to its corresponding amino acid or a stop signal. For example, $\\mathrm{UUU} \\to \\mathrm{Phenylalanine}$ and $\\mathrm{UAA} \\to \\mathrm{Stop}$.\n- The non-standard wobble pairing rules ($\\mathcal{R}_{\\mathrm{NS1}}$, $\\mathcal{R}_{\\mathrm{NS2}}$, $\\mathcal{R}_{\\mathrm{NS3}}$) are stored as mappings. Each mapping associates an anticodon wobble base (e.g., `I` for inosine) with the set of codon third bases it can pair with (e.g., $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{U}\\}$).\n- The input genomes for each test case are provided as sets of unique codons. Stop codons ($\\mathrm{UAA}$, $\\mathrm{UAG}$, $\\mathrm{UGA}$) are excluded from any analysis.\n\nStep $2$: Codon Partitioning.\nFor a given genome and rule set, we iterate through all unique, non-stop codons present. Each codon is categorized based on the amino acid it codes for and its first two nucleotides ($XY$). This creates a set of disjoint partitions. For each partition, identified by a key (amino acid, $XY$), we collect the set of all observed third-position bases. For a partition corresponding to (amino acid$_{i}$, $XY_{j}$), let this set of observed third bases be $S_{i,j}$.\n\nFor example, if the genome contains codons $\\mathrm{GCU}$, $\\mathrm{GCC}$, and $\\mathrm{GCA}$, all of which code for Alanine, they all share the prefix $\\mathrm{GC}$. This forms a single partition with key $(\\mathrm{Alanine}, \\mathrm{GC})$ and the set of required third bases is $S = \\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}\\}$.\n\nStep $3$: Solving the Minimum Set Cover Problem.\nFor each partition $(i, j)$ with its corresponding required third-base set $S_{i,j}$, we must find the minimum number of tRNA wobble bases (from the specified rule set) whose recognized-base sets collectively \"cover\" $S_{i,j}$. This is a classic minimum set cover problem. The universe of elements to be covered is $S_{i,j}$, which is a subset of $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$. The collection of available sets to form the cover is given by the values in the chosen wobble rule map (e.g., for $\\mathcal{R}_{\\mathrm{NS1}}$, the available sets are $\\{\\mathrm{U}\\}, \\{\\mathrm{G}\\}, \\{\\mathrm{C}, \\mathrm{U}\\}, \\dots$).\n\nSince the universe size is at most $4$, this problem can be solved efficiently by exhaustive search. We check if a cover of size $k=1$ exists. If not, we check for a cover of size $k=2$, and so on. The first $k$ for which a cover is found is the minimum size.\nLet $c_{i,j}$ be the minimum number of tRNAs for partition $(i, j)$.\n\nFor instance, to cover the set $S = \\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}\\}$ for $(\\mathrm{Alanine}, \\mathrm{GC})$ under rule set $\\mathcal{R}_{\\mathrm{NS1}}$, we inspect the available wobble pairings. The anticodon wobble base `I` recognizes $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{U}\\}$. Since $S \\subseteq \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{U}\\}$, a single tRNA with anticodon `I` is sufficient. Thus, the cost for this partition is $c = 1$. If no single tRNA could cover $S$, we would check all pairs of tRNAs, and so on.\n\nStep $4$: Final Calculation.\nThe total minimum number of tRNA species, $N_{\\min}$, is the sum of the minimums calculated for each partition:\n$$ N_{\\min} = \\sum_{i,j} c_{i,j} $$\nThis process is repeated for each of the five test cases specified in the problem, using the appropriate genome and wobble rule set for each. The final output is an ordered list of the integer values of $N_{\\min}$ for each case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the tRNA minimization problem for all test cases.\n    \"\"\"\n\n    # --- Data Definitions ---\n\n    # Standard Nuclear Genetic Code\n    genetic_code = {\n        'UUU': 'F', 'UUC': 'F', 'UUA': 'L', 'UUG': 'L',\n        'UCU': 'S', 'UCC': 'S', 'UCA': 'S', 'UCG': 'S',\n        'UAU': 'Y', 'UAC': 'Y', 'UAA': 'Stop', 'UAG': 'Stop',\n        'UGU': 'C', 'UGC': 'C', 'UGA': 'Stop', 'UGG': 'W',\n\n        'CUU': 'L', 'CUC': 'L', 'CUA': 'L', 'CUG': 'L',\n        'CCU': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'CAU': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGU': 'R', 'CUC': 'R', 'CGA': 'R', 'CGG': 'R',\n\n        'AUU': 'I', 'AUC': 'I', 'AUA': 'I', 'AUG': 'M',\n        'ACU': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'AAU': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGU': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n\n        'GUU': 'V', 'GUC': 'V', 'GUA': 'V', 'GUG': 'V',\n        'GCU': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'GAU': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGU': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'\n    }\n    # Corrected an error in a common table: CUC is L, not R. CGC is R.\n    genetic_code['CUC'] = 'L'\n    genetic_code['CGC'] = 'R'\n\n\n    # Non-standard Wobble Rule Sets\n    wobble_rules = {\n        'R_NS1': {\n            'A': frozenset({'U'}), 'C': frozenset({'G'}),\n            'G': frozenset({'C', 'U'}), 'U': frozenset({'A', 'G'}),\n            'I': frozenset({'A', 'C', 'U'}), 'W': frozenset({'A', 'C', 'G', 'U'}),\n            'K': frozenset({'A'}), 'Q': frozenset({'U', 'C'})\n        },\n        'R_NS2': {\n            'A': frozenset({'U'}), 'C': frozenset({'G'}),\n            'G': frozenset({'C', 'U'}), 'U': frozenset({'A', 'G'}),\n            'Q': frozenset({'U', 'C'}), 'M': frozenset({'A', 'G'}),\n            'K': frozenset({'A'})\n        },\n        'R_NS3': {\n            'A': frozenset({'U'}), 'C': frozenset({'G'}),\n            'G': frozenset({'C'}), 'U': frozenset({'A'}),\n            'I': frozenset({'A', 'C', 'U'}), 'K': frozenset({'A'}),\n            'Q': frozenset({'U', 'C'})\n        }\n    }\n\n    # Test Suite\n    genome_g1 = {\n        \"AUG\", \"GCU\", \"GCC\", \"GCA\", \"GCG\", \"GGU\", \"GGC\", \"GGA\", \"AUU\", \"AUC\", \"AUA\",\n        \"UUU\", \"UUC\", \"CCU\", \"CCA\", \"UCU\", \"UCC\", \"UCA\", \"UCG\", \"AGU\", \"CUA\",\n        \"CUG\", \"UUA\", \"GUU\", \"UAU\", \"UAC\", \"UAA\", \"UGA\", \"UAG\"\n    }\n\n    genome_g2 = {\"UUU\"} # 10 times does not change the set, stop codon UAA is ignored\n\n    all_sense_codons = {codon for codon, aa in genetic_code.items() if aa != 'Stop'}\n\n    test_cases = [\n        (genome_g1, wobble_rules['R_NS1']),\n        (genome_g1, wobble_rules['R_NS2']),\n        (genome_g1, wobble_rules['R_NS3']),\n        (genome_g2, wobble_rules['R_NS3']),\n        (all_sense_codons, wobble_rules['R_NS3']),\n    ]\n\n    # --- Helper Functions ---\n    def solve_min_set_cover(target_set, covering_sets):\n        \"\"\"\n        Solves the minimum set cover problem for a small universe.\n        The target_set must be covered by the union of sets from covering_sets.\n        \"\"\"\n        if not target_set:\n            return 0\n        \n        # Check covers of increasing size\n        for k in range(1, len(covering_sets) + 1):\n            for combo in combinations(covering_sets, k):\n                # An arbitrary iterable of a collection of sets can be passed to union()\n                union_of_combo = frozenset.union(*combo)\n                if target_set.issubset(union_of_combo):\n                    return k\n        # This part should be unreachable if all bases can be covered.\n        # Fallback in case of an un-coverable base, though problem setup prevents this.\n        return len(target_set)\n\n    def compute_n_min(genome_codons, rules):\n        \"\"\"\n        Computes N_min for a given genome and rule set.\n        \"\"\"\n        codons_by_group = {}\n        for codon in genome_codons:\n            aa = genetic_code.get(codon)\n            if aa and aa != 'Stop':\n                prefix = codon[:2]\n                third_base = codon[2]\n                key = (aa, prefix)\n                if key not in codons_by_group:\n                    codons_by_group[key] = set()\n                codons_by_group[key].add(third_base)\n\n        total_trna_count = 0\n        available_covers = list(rules.values())\n        \n        for group_key, third_bases_needed in codons_by_group.items():\n            min_cover_size = solve_min_set_cover(frozenset(third_bases_needed), available_covers)\n            total_trna_count += min_cover_size\n            \n        return total_trna_count\n\n    # --- Main Logic ---\n    results = []\n    for genome, rules in test_cases:\n        result = compute_n_min(genome, rules)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2380386"}, {"introduction": "Finally, we apply our knowledge to a question in molecular evolution. This exercise [@problem_id:2380355] guides you through testing the hypothesis that essential genes might be under selective pressure to avoid codons that are just one mutation away from a premature stop signal. You will perform a complete bioinformatics analysis, from parsing sequence data to applying statistical tests, to investigate patterns potentially shaped by natural selection.", "problem": "You are given the task of programmatically quantifying whether messenger ribonucleic acid (mRNA) codons that are exactly one point mutation away from a stop codon are underrepresented in a set of essential genes compared to a matched set of nonessential genes. The analysis must be founded on the Central Dogma of molecular biology (deoxyribonucleic acid to ribonucleic acid to protein), the definition of codons as length-$3$ triplets over the alphabet $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$, the existence of three stop codons $\\{\\mathrm{UAA}, \\mathrm{UAG}, \\mathrm{UGA}\\}$, and the base-pairing rules that define anticodons for transfer ribonucleic acid (tRNA). A codon is “near-stop” if its Hamming distance (the number of positions at which two strings of equal length differ) to any stop codon is exactly $1$, and the codon itself is not a stop codon. Only sense codons (non-stop codons) contribute to usage totals. Assume coding sequences are already spliced and provided in-frame in the $5'$ to $3'$ direction as strings over $\\Sigma$, with lengths that are multiples of $3$.\n\nStarting from these fundamentals:\n- The set of stop codons is $S = \\{\\mathrm{UAA}, \\mathrm{UAG}, \\mathrm{UGA}\\}$.\n- The set of all codons is $\\Sigma^3$, size $|\\Sigma^3| = 4^3 = 64$.\n- The set of sense codons is $\\Sigma^3 \\setminus S$.\n- A “near-stop” codon $c$ satisfies $\\min_{s \\in S} \\mathrm{Hamming}(c, s) = 1$ and $c \\notin S$.\n- Anticodons are the reverse-complements of codons under Watson–Crick pairing ($\\mathrm{A}\\leftrightarrow \\mathrm{U}$, $\\mathrm{C}\\leftrightarrow \\mathrm{G}$), but anticodons are used here only to justify the codon framework; the computation operates entirely at the codon level.\n\nYou must design an algorithm that:\n- Parses each gene sequence into non-overlapping codons in the given reading frame.\n- Excludes any stop codon encountered from usage counting.\n- Counts, for each gene set (essential versus nonessential), the total number of near-stop sense codons and the total number of non-near-stop sense codons.\n- Forms a $2\\times 2$ contingency table with entries:\n  - $a$: near-stop counts in essential genes,\n  - $b$: non-near-stop counts in essential genes,\n  - $c$: near-stop counts in nonessential genes,\n  - $d$: non-near-stop counts in nonessential genes.\n- Computes a smoothed log-odds ratio with Laplace smoothing parameter $\\alpha > 0$:\n  $$\\mathrm{LOR}_\\alpha = \\log\\left(\\frac{a+\\alpha}{b+\\alpha}\\right) - \\log\\left(\\frac{c+\\alpha}{d+\\alpha}\\right).$$\n- Computes a two-sided Fisher’s exact test $p$-value for the table\n  $$\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}.$$\n  If any row or any column sum equals $0$ (that is, $a+b=0$ or $c+d=0$ or $a+c=0$ or $b+d=0$), define the two-sided $p$-value to be $1.0$ for the purpose of this program.\n- Declares “underrepresentation” in essential genes if and only if $\\mathrm{LOR}_\\alpha &lt; 0$ and the two-sided $p$-value is less than a specified significance threshold $\\tau$.\n\nImplementation requirements:\n- Work purely from the given sequences and definitions.\n- Treat all inputs as mRNA codons over $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$.\n- Ignore any trailing nucleotides that cannot form a full codon triplet (the provided sequences will be multiples of $3$).\n\nTest suite:\nImplement your program to run the following three independent test cases. Each test case specifies a set of essential gene sequences, a set of nonessential gene sequences, a smoothing parameter $\\alpha$, and a significance threshold $\\tau$. All sequences are valid mRNA coding sequences, each string’s length is a multiple of $3$, and no internal stop codons are included.\n\n- Test case $1$ (balanced usage; expect no underrepresentation):\n  - Essential genes:\n    - $\\mathrm{E1} = \\text{\"AAGGCUAAAGCUUUU\"}$ which parses as $(\\mathrm{AAG}, \\mathrm{GCU}, \\mathrm{AAA}, \\mathrm{GCU}, \\mathrm{UUU})$,\n    - $\\mathrm{E2} = \\text{\"GCCUGGUGGUUCGCA\"}$ which parses as $(\\mathrm{GCC}, \\mathrm{UGG}, \\mathrm{UGG}, \\mathrm{UUC}, \\mathrm{GCA})$.\n  - Nonessential genes:\n    - $\\mathrm{N1} = \\text{\"CAAGCUUAUGCGUUC\"}$ which parses as $(\\mathrm{CAA}, \\mathrm{GCU}, \\mathrm{UAU}, \\mathrm{GCG}, \\mathrm{UUC})$,\n    - $\\mathrm{N2} = \\text{\"AAAGCCUUGGCAUUU\"}$ which parses as $(\\mathrm{AAA}, \\mathrm{GCC}, \\mathrm{UUG}, \\mathrm{GCA}, \\mathrm{UUU})$.\n  - Parameters: $\\alpha = 1.0$, $\\tau = 0.05$.\n\n- Test case $2$ (strong underrepresentation in essential genes):\n  - Essential genes:\n    - $\\mathrm{E1} = \\text{\"GCUGCCGCAGCGUUC\"}$ which parses as $(\\mathrm{GCU}, \\mathrm{GCC}, \\mathrm{GCA}, \\mathrm{GCG}, \\mathrm{UUC})$,\n    - $\\mathrm{E2} = \\text{\"GCUGCGUUUUUCGCC\"}$ which parses as $(\\mathrm{GCU}, \\mathrm{GCG}, \\mathrm{UUU}, \\mathrm{UUC}, \\mathrm{GCC})$.\n  - Nonessential genes:\n    - $\\mathrm{N1} = \\text{\"AAAAAGCAAGAAUUA\"}$ which parses as $(\\mathrm{AAA}, \\mathrm{AAG}, \\mathrm{CAA}, \\mathrm{GAA}, \\mathrm{UUA})$,\n    - $\\mathrm{N2} = \\text{\"UGGUCGUAUUACAGA\"}$ which parses as $(\\mathrm{UGG}, \\mathrm{UCG}, \\mathrm{UAU}, \\mathrm{UAC}, \\mathrm{AGA})$.\n  - Parameters: $\\alpha = 0.5$, $\\tau = 0.01$.\n\n- Test case $3$ (edge case with zero near-stop counts in both groups):\n  - Essential genes:\n    - $\\mathrm{E1} = \\text{\"GCUGCCGCAGCGUUU\"}$ which parses as $(\\mathrm{GCU}, \\mathrm{GCC}, \\mathrm{GCA}, \\mathrm{GCG}, \\mathrm{UUU})$,\n    - $\\mathrm{E2} = \\text{\"UUCGCUGCCGCAGCG\"}$ which parses as $(\\mathrm{UUC}, \\mathrm{GCU}, \\mathrm{GCC}, \\mathrm{GCA}, \\mathrm{GCG})$.\n  - Nonessential genes:\n    - $\\mathrm{N1} = \\text{\"GCUGCGUUUUUCGCC\"}$ which parses as $(\\mathrm{GCU}, \\mathrm{GCG}, \\mathrm{UUU}, \\mathrm{UUC}, \\mathrm{GCC})$,\n    - $\\mathrm{N2} = \\text{\"GCAGCUUUCUUUGCG\"}$ which parses as $(\\mathrm{GCA}, \\mathrm{GCU}, \\mathrm{UUC}, \\mathrm{UUU}, \\mathrm{GCG})$.\n  - Parameters: $\\alpha = 1.0$, $\\tau = 0.05$.\n\nFinal output specification:\n- For each test case, your program must produce a triplet $[\\mathrm{LOR}_\\alpha, p, \\mathrm{underrep}]$, where $\\mathrm{LOR}_\\alpha$ is the smoothed log-odds ratio as defined above, $p$ is the two-sided Fisher exact $p$-value, and $\\mathrm{underrep}$ is a boolean indicating whether essential genes show statistically significant underrepresentation. Round all floating-point outputs to $6$ decimal places.\n- Your program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, with each test case result itself rendered as a bracketed, comma-separated list. For example: \"[[x1,y1,True],[x2,y2,False],[x3,y3,True]]\".\n- There are no physical units, angles, or percentages required in this problem; all reported quantities are dimensionless real numbers or booleans.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded in molecular biology, mathematically well-posed, and provides a complete, unambiguous specification for the required algorithm and its parameters. We will therefore proceed with a complete solution.\n\nThe core of the problem is to quantify and test for the underrepresentation of a specific class of codons, termed \"near-stop\" codons, in essential genes compared to nonessential genes. The solution is executed in four logical stages.\n\n**Step 1: Formalization and Identification of Near-Stop Codons**\n\nThe problem defines a codon $c$ as \"near-stop\" if two conditions are met:\n1.  $c$ must be a sense codon, meaning it is not a member of the stop codon set $S = \\{\\mathrm{UAA}, \\mathrm{UAG}, \\mathrm{UGA}\\}$.\n2.  The Hamming distance from $c$ to its closest stop codon must be exactly $1$. This is expressed formally as $\\min_{s \\in S} \\mathrm{Hamming}(c, s) = 1$. The Hamming distance between two strings of equal length is the number of positions at which the corresponding symbols are different.\n\nTo implement this, we systematically generate all $4^3 = 64$ possible codons from the alphabet $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$. For each codon $c$, we first check if $c \\in S$. If it is, it is discarded. If $c \\notin S$, we then compute its Hamming distance to each of the three stop codons in $S$. If the minimum of these three distances is $1$, the codon $c$ is classified as near-stop.\n\nThis procedure yields the following set of $18$ near-stop codons, which will be pre-computed and used for all subsequent analysis:\n$\\{\\mathrm{AAA}, \\mathrm{AAG}, \\mathrm{AGA}, \\mathrm{CAA}, \\mathrm{CAG}, \\mathrm{CGA}, \\mathrm{GAA}, \\mathrm{GAG}, \\mathrm{GGA}, \\mathrm{UAC}, \\mathrm{UAU}, \\mathrm{UCA}, \\mathrm{UCG}, \\mathrm{UGC}, \\mathrm{UGU}, \\mathrm{UGG}, \\mathrm{UUA}, \\mathrm{UUG}\\}$.\n\n**Step 2: Sequence Processing and Contingency Table Construction**\n\nThe provided gene sequences are strings of mRNA bases. The algorithm processes each set of genes (essential and nonessential) as follows:\n1.  For each gene sequence, which is guaranteed to have a length that is a multiple of $3$, we parse it into a list of non-overlapping, in-frame codons of length $3$.\n2.  For each codon, we determine if it belongs to the pre-computed set of near-stop codons.\n3.  The problem states that input sequences do not contain stop codons, so every codon is a sense codon. A codon is either \"near-stop\" or \"non-near-stop\".\n4.  We accumulate counts across all genes within a set (essential or nonessential) to populate a $2 \\times 2$ contingency table of the form $\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$, where:\n    - $a$: Total count of near-stop codons in essential genes.\n    - $b$: Total count of non-near-stop sense codons in essential genes.\n    - $c$: Total count of near-stop codons in nonessential genes.\n    - $d$: Total count of non-near-stop sense codons in nonessential genes.\n\n**Step 3: Statistical Analysis**\n\nWith the contingency table constructed, two statistical measures are computed.\n\nFirst, the smoothed log-odds ratio ($\\mathrm{LOR}_\\alpha$) is calculated to estimate the magnitude and direction of the effect. The formula uses Laplace smoothing with a parameter $\\alpha > 0$ to handle potential zero counts:\n$$\n\\mathrm{LOR}_\\alpha = \\log\\left(\\frac{a+\\alpha}{b+\\alpha}\\right) - \\log\\left(\\frac{c+\\alpha}{d+\\alpha}\\right)\n$$\nA negative $\\mathrm{LOR}_\\alpha$ indicates that the odds of a codon being near-stop are lower in the essential gene set than in the nonessential gene set, suggesting underrepresentation. The natural logarithm is used.\n\nSecond, a two-sided Fisher's Exact Test is performed on the contingency table to assess the statistical significance of the association between gene type (essential vs. nonessential) and codon type (near-stop vs. non-near-stop). The test calculates a $p$-value, which represents the probability of observing a table at least as extreme as the one constructed, assuming the null hypothesis of no association. A small $p$-value provides evidence against the null hypothesis.\n\nA special condition is mandated for the $p$-value calculation: if any row sum ($a+b$ or $c+d$) or column sum ($a+c$ or $b+d$) of the contingency table is zero, the $p$-value is defined to be $1.0$. This handles cases where one category is entirely absent from the data, making the test trivial.\n\n**Step 4: Declaration of Underrepresentation**\n\nThe final verdict of \"underrepresentation\" is based on two criteria, which must both be met:\n1.  The direction of the effect must indicate underrepresentation in essential genes: $\\mathrm{LOR}_\\alpha < 0$.\n2.  The result must be statistically significant: the $p$-value must be less than a specified significance threshold $\\tau$.\n\nIf both $\\mathrm{LOR}_\\alpha < 0$ and $p < \\tau$ are true, the result is `True`; otherwise, it is `False`. The algorithm computes these values for each test case and formats the output as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import fisher_exact\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"essential_genes\": [\"AAGGCUAAAGCUUUU\", \"GCCUGGUGGUUCGCA\"],\n            \"nonessential_genes\": [\"CAAGCUUAUGCGUUC\", \"AAAGCCUUGGCAUUU\"],\n            \"alpha\": 1.0,\n            \"tau\": 0.05\n        },\n        {\n            \"essential_genes\": [\"GCUGCCGCAGCGUUC\", \"GCUGCGUUUUUCGCC\"],\n            \"nonessential_genes\": [\"AAAAAGCAAGAAUUA\", \"UGGUCGUAUUACAGA\"],\n            \"alpha\": 0.5,\n            \"tau\": 0.01\n        },\n        {\n            \"essential_genes\": [\"GCUGCCGCAGCGUUU\", \"UUCGCUGCCGCAGCG\"],\n            \"nonessential_genes\": [\"GCUGCGUUUUUCGCC\", \"GCAGCUUUCUUUGCG\"],\n            \"alpha\": 1.0,\n            \"tau\": 0.05\n        }\n    ]\n\n    results = []\n    \n    # Pre-compute the set of near-stop codons once.\n    near_stop_codons = _get_near_stop_codons()\n\n    for case in test_cases:\n        # Extract parameters for the current test case.\n        essential_genes = case[\"essential_genes\"]\n        nonessential_genes = case[\"nonessential_genes\"]\n        alpha = case[\"alpha\"]\n        tau = case[\"tau\"]\n\n        # Step 1: Count codon types in essential genes.\n        a, b = _count_codon_types(essential_genes, near_stop_codons)\n        \n        # Step 2: Count codon types in nonessential genes.\n        c, d = _count_codon_types(nonessential_genes, near_stop_codons)\n        \n        # Step 3: Compute the smoothed log-odds ratio.\n        # LOR = log((a+alpha)/(b+alpha)) - log((c+alpha)/(d+alpha))\n        term_essential = (a + alpha) / (b + alpha)\n        term_nonessential = (c + alpha) / (d + alpha)\n        lor = np.log(term_essential) - np.log(term_nonessential)\n        \n        # Step 4: Compute the two-sided Fisher's exact test p-value.\n        table = np.array([[a, b], [c, d]])\n        \n        # Check for zero row or column sums as per the problem specification.\n        if (a + b == 0) or (c + d == 0) or (a + c == 0) or (b + d == 0):\n            p_value = 1.0\n        else:\n            _, p_value = fisher_exact(table, alternative='two-sided')\n            \n        # Step 5: Determine if there is underrepresentation.\n        # Condition: LOR  0 and p-value  significance threshold tau.\n        is_underrepresented = lor  0 and p_value  tau\n        \n        # Append the formatted result triplet to the list.\n        results.append([lor, p_value, is_underrepresented])\n\n    # Format the final output string as specified.\n    formatted_results = [\n        f\"[{lor:.6f},{p_val:.6f},{str(underrep).lower()}]\" \n        for lor, p_val, underrep in results\n    ]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _get_near_stop_codons():\n    \"\"\"\n    Generates the set of \"near-stop\" codons based on the problem definition.\n    A codon is near-stop if its Hamming distance to any stop codon is 1\n    and it is not itself a stop codon.\n    \"\"\"\n    bases = ['A', 'C', 'G', 'U']\n    stop_codons = {'UAA', 'UAG', 'UGA'}\n    \n    all_codons = {b1 + b2 + b3 for b1 in bases for b2 in bases for b3 in bases}\n    sense_codons = all_codons - stop_codons\n    \n    near_stop_set = set()\n    for codon in sense_codons:\n        min_dist = 3  # The maximum possible Hamming distance for length 3 strings.\n        for stop_codon in stop_codons:\n            dist = sum(1 for i in range(3) if codon[i] != stop_codon[i])\n            if dist  min_dist:\n                min_dist = dist\n        \n        if min_dist == 1:\n            near_stop_set.add(codon)\n            \n    return near_stop_set\n\ndef _count_codon_types(gene_sequences, near_stop_set):\n    \"\"\"\n    Parses gene sequences into codons and counts near-stop vs. non-near-stop codons.\n    \n    Args:\n        gene_sequences (list[str]): A list of mRNA sequences.\n        near_stop_set (set[str]): The pre-computed set of near-stop codons.\n\n    Returns:\n        tuple[int, int]: A tuple containing (near_stop_count, non_near_stop_count).\n    \"\"\"\n    near_stop_count = 0\n    non_near_stop_count = 0\n    \n    for seq in gene_sequences:\n        # Parse sequence into non-overlapping codons of length 3.\n        for i in range(0, len(seq), 3):\n            codon = seq[i:i+3]\n            \n            # According to problem, input sequences do not contain stop codons.\n            if codon in near_stop_set:\n                near_stop_count += 1\n            else:\n                non_near_stop_count += 1\n                \n    return near_stop_count, non_near_stop_count\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2380355"}]}