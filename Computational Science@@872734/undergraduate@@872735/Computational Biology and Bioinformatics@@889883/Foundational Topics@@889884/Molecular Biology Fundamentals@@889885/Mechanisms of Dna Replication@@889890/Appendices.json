{"hands_on_practices": [{"introduction": "To truly understand the mechanism of semiconservative replication, we must move beyond qualitative diagrams and engage in quantitative prediction. This practice challenges you to apply the foundational principles demonstrated by Meselson and Stahl to a new scenario, modeling an unsynchronized, exponentially growing bacterial population. By calculating the distribution of DNA molecules after a specific number of generations [@problem_id:2792765], you will sharpen your ability to translate core biological concepts into precise mathematical models.", "problem": "Escherichia coli are grown for many generations in medium containing heavy nitrogen ${}^{15}\\text{N}$, such that every genomic deoxyribonucleic acid (DNA) duplex initially consists of two ${}^{15}\\text{N}$-labeled strands. At time $t=0$, the population is abruptly shifted to medium containing only light nitrogen ${}^{14}\\text{N}$. Assume the following foundations: (i) semiconservative DNA replication, meaning each daughter duplex inherits exactly one parental strand, (ii) no incorporation of ${}^{15}\\text{N}$ after the shift (all newly synthesized strands are ${}^{14}\\text{N}$), (iii) binary fission with exponential growth so that the total number of complete DNA duplexes scales as $2^{g}$ after $g$ generations, (iv) no cell death, and (v) all replication forks that are active at the sampling time are allowed to complete before density-gradient analysis so that every DNA molecule at measurement is a complete duplex. DNA is then analyzed by Cesium Chloride (CsCl) density-gradient centrifugation, which resolves species by buoyant density into hybrid ${}^{15}\\text{N}/{}^{14}\\text{N}$ and light ${}^{14}\\text{N}/{}^{14}\\text{N}$ bands. The photographic band intensity is proportional to the total DNA mass that bands at that density; since all genomes have equal length, intensity is proportional to the number of duplex molecules of that density.\n\nUsing only the stated foundations, derive from first principles the normalized relative intensities (dimensionless fractions that sum to $1$) of the hybrid and light DNA bands when the culture has undergone $2.5$ generations of growth in ${}^{14}\\text{N}$ medium. Express your final answer as a row matrix $\\big[I_{\\mathrm{hybrid}}\\; I_{\\mathrm{light}}\\big]$ with exact values (no rounding and no units inside the matrix).", "solution": "The problem presented is a classic exercise in molecular genetics, famously modeled on the Meselson-Stahl experiment, and its validity must first be rigorously established.\n\n**Problem Validation**\n\nGivens are extracted verbatim:\n1.  Initial state: *Escherichia coli* culture grown in ${}^{15}\\text{N}$ medium; all genomic DNA is ${}^{15}\\text{N}/${}^{15}\\text{N}$.\n2.  Experimental shift: At $t=0$, culture is moved to ${}^{14}\\text{N}$ medium.\n3.  Foundation (i): DNA replication is semiconservative.\n4.  Foundation (ii): All newly synthesized strands are ${}^{14}\\text{N}$.\n5.  Foundation (iii): Total number of complete DNA duplexes scales as $2^g$ after $g$ generations.\n6.  Foundation (iv): No cell death.\n7.  Foundation (v): All active replication forks are completed before analysis, ensuring measurements are on complete duplexes.\n8.  Analysis: Cesium Chloride (CsCl) density-gradient centrifugation resolves DNA into hybrid (${}^{15}\\text{N}/{}^{14}\\text{N}$) and light (${}^{14}\\text{N}/${}^{14}\\text{N}$) bands.\n9.  Intensity rule: Band intensity is proportional to the number of DNA duplex molecules at that density.\n10. Objective: Derive the normalized relative intensities of the hybrid and light bands for $g=2.5$ generations.\n\nValidation results:\nThe problem is scientifically grounded, based on the canonical Meselson-Stahl experiment which confirmed the semiconservative model of DNA replication. All foundations are standard principles in molecular biology and population kinetics. The problem is well-posed; the initial conditions and rules of evolution are explicitly stated. The inclusion of a non-integer number of generations, $g=2.5$, combined with the axiom that the total number of duplexes is $N_0 2^g$, correctly models an unsynchronized, exponentially growing population at a macroscopic level. Crucially, foundation (v) provides a necessary idealization, allowing us to reason about discrete, complete molecules without the complexities of analyzing a population containing partially replicated DNA. The problem avoids ambiguity, is mathematically formalizable, and tests fundamental understanding rather than being trivial. Therefore, the problem is deemed valid.\n\n**Solution Derivation**\n\nLet $N_0$ be the initial number of *E. coli* cells, and therefore the initial number of DNA duplexes, at generation $g=0$. According to the initial conditions, all these duplexes are of the heavy/heavy type, which we denote as ${}^{15}\\text{N}/${}^{15}\\text{N}$. The total number of individual DNA strands is $2N_0$, and all are labeled with ${}^{15}\\text{N}$. These original strands are conserved throughout the experiment as per the semiconservative replication mechanism.\n\nAt $g=0$, the medium is switched to one containing only ${}^{14}\\text{N}$. According to foundation (ii), any new strand synthesized will be a light (${}^{14}\\text{N}$) strand.\n\nThe cornerstone of this analysis is the fate of the original $2N_0$ heavy strands. Foundation (i) states that replication is semiconservative, meaning these strands serve as templates and are never degraded (foundation (iv), no cell death, reinforces this). Foundation (v) guarantees that at the point of measurement, every molecule is a complete duplex. It follows logically that each of the original $2N_0$ heavy (${}^{15}\\text{N}$) strands must be present within a complete DNA duplex. After the first round of replication, any original ${}^{15}\\text{N}$ strand must pair with a newly synthesized ${}^{14}\\text{N}$ strand, forming a hybrid (${}^{15}\\text{N}/${}^{14}\\text{N}$) duplex. Since no new ${}^{15}\\text{N}$ is available, it is impossible to form new ${}^{15}\\text{N}/${}^{15}\\text{N}$ duplexes, and it is impossible for a ${}^{15}\\text{N}$ strand to be lost. Therefore, for any generation $g \\ge 1$, the number of hybrid duplexes, $N_{\\mathrm{hybrid}}(g)$, must be exactly equal to the number of original template strands.\n$$N_{\\mathrm{hybrid}}(g) = 2N_0 \\quad (\\text{for } g \\ge 1)$$\n\nNext, we consider the total number of DNA duplexes in the population. Foundation (iii) explicitly provides the governing equation for an exponentially growing culture:\n$$N_{\\mathrm{total}}(g) = N_0 2^g$$\nThis equation is valid for any non-negative real number $g$.\n\nFor any generation $g \\ge 1$, the population of duplexes consists of two species: hybrid (${}^{15}\\text{N}/${}^{14}\\text{N}$) and light (${}^{14}\\text{N}/${}^{14}\\text{N}$). The total number of duplexes is the sum of the numbers of these two species:\n$$N_{\\mathrm{total}}(g) = N_{\\mathrm{hybrid}}(g) + N_{\\mathrm{light}}(g)$$\nWe can now derive an expression for the number of light duplexes, $N_{\\mathrm{light}}(g)$, by substitution:\n$$N_{\\mathrm{light}}(g) = N_{\\mathrm{total}}(g) - N_{\\mathrm{hybrid}}(g) = N_0 2^g - 2N_0 = N_0 (2^g - 2) \\quad (\\text{for } g \\ge 1)$$\n\nThe problem requires the state of the system at $g=2.5$. We apply the formulae derived above.\nThe number of hybrid duplexes at $g=2.5$ is:\n$$N_{\\mathrm{hybrid}}(2.5) = 2N_0$$\nThe total number of duplexes at $g=2.5$ is:\n$$N_{\\mathrm{total}}(2.5) = N_0 2^{2.5} = N_0 2^{5/2} = N_0 \\sqrt{2^5} = N_0 \\sqrt{32} = N_0 \\sqrt{16 \\times 2} = 4\\sqrt{2} N_0$$\nThe number of light duplexes at $g=2.5$ is:\n$$N_{\\mathrm{light}}(2.5) = N_0 (2^{2.5} - 2) = N_0 (4\\sqrt{2} - 2)$$\n\nThe normalized relative intensity of each band is proportional to the number of molecules in that band divided by the total number of molecules. Let $I_{\\mathrm{hybrid}}$ and $I_{\\mathrm{light}}$ be the normalized intensities.\n\nFor the hybrid band:\n$$I_{\\mathrm{hybrid}} = \\frac{N_{\\mathrm{hybrid}}(2.5)}{N_{\\mathrm{total}}(2.5)} = \\frac{2N_0}{4\\sqrt{2} N_0} = \\frac{2}{4\\sqrt{2}} = \\frac{1}{2\\sqrt{2}}$$\nTo rationalize the denominator, we multiply the numerator and denominator by $\\sqrt{2}$:\n$$I_{\\mathrm{hybrid}} = \\frac{1 \\times \\sqrt{2}}{2\\sqrt{2} \\times \\sqrt{2}} = \\frac{\\sqrt{2}}{2 \\times 2} = \\frac{\\sqrt{2}}{4}$$\n\nFor the light band:\n$$I_{\\mathrm{light}} = \\frac{N_{\\mathrm{light}}(2.5)}{N_{\\mathrm{total}}(2.5)} = \\frac{N_0(4\\sqrt{2} - 2)}{4\\sqrt{2} N_0} = \\frac{4\\sqrt{2} - 2}{4\\sqrt{2}} = 1 - \\frac{2}{4\\sqrt{2}} = 1 - \\frac{1}{2\\sqrt{2}}$$\nUsing the rationalized form from the hybrid calculation:\n$$I_{\\mathrm{light}} = 1 - \\frac{\\sqrt{2}}{4} = \\frac{4 - \\sqrt{2}}{4}$$\n\nAs a verification, the sum of the normalized intensities must be $1$:\n$$I_{\\mathrm{hybrid}} + I_{\\mathrm{light}} = \\frac{\\sqrt{2}}{4} + \\frac{4 - \\sqrt{2}}{4} = \\frac{\\sqrt{2} + 4 - \\sqrt{2}}{4} = \\frac{4}{4} = 1$$\nThe derivation is consistent. The final intensities are expressed as exact fractions as required.\n\nThe result is to be expressed as a row matrix $\\begin{pmatrix} I_{\\mathrm{hybrid}} & I_{\\mathrm{light}} \\end{pmatrix}$.\nSubstituting the derived values provides the final answer.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\sqrt{2}}{4} & \\frac{4-\\sqrt{2}}{4}\n\\end{pmatrix}\n}\n$$", "id": "2792765"}, {"introduction": "The process of DNA replication is not always smooth, as specific DNA sequences can form secondary structures that physically impede the polymerase. This exercise puts you in the role of a bioinformatician tasked with identifying such potential roadblocks by developing an algorithm to scan a genome for hairpin-forming palindromic sequences [@problem_id:2403464]. You will learn to translate a set of simplified biophysical rules into a concrete computational tool, a fundamental skill in sequence analysis.", "problem": "You are given a formal definition of reverse-complement palindromic substrings in a Deoxyribonucleic Acid (DNA) string and a simplified biophysical criterion for hairpin formation that may stall DNA-dependent DNA polymerases. Let the alphabet be $\\{A,C,G,T\\}$. For a genome string $G$ of length $N$, a hairpin candidate is any substring $H$ of $G$ that can be partitioned as $H = L \\cdot \\ell \\cdot R$, where $L$ is the left arm of length $s$, $\\ell$ is the loop of length $l$, and $R$ is the right arm of length $s$, with $s \\in \\mathbb{Z}_{\\ge 1}$ and $l \\in \\mathbb{Z}_{\\ge 1}$. Define the complement map $c$ by $c(A)=T$, $c(T)=A$, $c(C)=G$, and $c(G)=C$. For each position $j \\in \\{0,1,\\dots,s-1\\}$, define a base-pair between $L[j]$ and $R[s-1-j]$. A base-pair is a match if $R[s-1-j] = c(L[j])$ and a mismatch otherwise. Let $b$ be the total number of matches, $m$ be the total number of mismatches so that $m = s - b$, and let $g$ be the count of matches that are guanine-cytosine (GC) pairs, namely those matches where $\\{L[j],R[s-1-j]\\} = \\{G,C\\}$. Define the GC fraction $f_{\\mathrm{GC}}$ by $f_{\\mathrm{GC}}=g/b$ if $b \\neq 0$, and $f_{\\mathrm{GC}} = 0$ if $b=0$.\n\nA hairpin candidate $H$ is considered predicted to form a stable hairpin that can stall the polymerase if and only if all of the following hold simultaneously:\n- Stem length constraint: $s_{\\min} \\le s \\le s_{\\max}$.\n- Loop length constraint: $l_{\\min} \\le l \\le l_{\\max}$.\n- Mismatch tolerance: $m \\le k_{\\max}$.\n- Minimum pairing: $b \\ge b_{\\min}$.\n- Minimum GC fraction: $f_{\\mathrm{GC}} \\ge f_{\\mathrm{GC}}^{\\min}$.\n\nFor a given genome $G$ and parameters $(s_{\\min}, s_{\\max}, l_{\\min}, l_{\\max}, k_{\\max}, b_{\\min}, f_{\\mathrm{GC}}^{\\min})$, define the task output as the total number of distinct hairpin instances in $G$ that satisfy the above criteria, where distinct instances are defined by triples $(i,s,l)$ with $i \\in \\{0,1,\\dots,N-(2s+l)\\}$ being the start index of $H$ in $G$, and $s$ and $l$ as above.\n\nYour program must implement this definition exactly and produce the required outputs for the following test suite. Each test case is a tuple consisting of a genome string $G$ and a parameter septuple $(s_{\\min}, s_{\\max}, l_{\\min}, l_{\\max}, k_{\\max}, b_{\\min}, f_{\\mathrm{GC}}^{\\min})$:\n\n- Test case $1$ (general GC-rich palindrome):\n  - $G =$ \"AAAGCGCTTGCGCAAATTT\"\n  - Parameters: $(s_{\\min}, s_{\\max}, l_{\\min}, l_{\\max}, k_{\\max}, b_{\\min}, f_{\\mathrm{GC}}^{\\min}) = (\\,4,\\,4,\\,2,\\,2,\\,0,\\,4,\\,0.75\\,)$\n- Test case $2$ (boundary with exactly one mismatch and GC fraction at threshold):\n  - $G =$ \"TTTATCAAAGTTCCC\"\n  - Parameters: $(\\,3,\\,3,\\,3,\\,3,\\,1,\\,2,\\,0.5\\,)$\n- Test case $3$ (no valid hairpin under strict constraints):\n  - $G =$ \"ATCAAAGTT\"\n  - Parameters: $(\\,3,\\,3,\\,3,\\,3,\\,0,\\,3,\\,1.0\\,)$\n- Test case $4$ (two separated strong hairpins, both GC-rich):\n  - $G =$ \"AAAGCGCTTGCGCTTTCCGGAACCGGAAA\"\n  - Parameters: $(\\,4,\\,4,\\,2,\\,2,\\,0,\\,4,\\,1.0\\,)$\n- Test case $5$ (inclusivity at thresholds with $\\frac{2}{3}$ GC fraction and mismatches at limit):\n  - $G =$ \"AAAGTATCAAAGGTCCAAA\"\n  - Parameters: $(\\,5,\\,5,\\,3,\\,3,\\,2,\\,3,\\,\\frac{2}{3}\\,)$\n\nAngle units are not applicable and no physical units are involved.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases listed above (from test case $1$ to test case $5$). For example, the required format is \"[rA,rB,rC,rD,rE]\" where each item is the integer count for the corresponding test case.", "solution": "The problem statement has been subjected to rigorous validation and is found to be scientifically grounded, well-posed, and objective. It presents a simplified but coherent biophysical model for the formation of DNA hairpin structures, which are known to be implicated in the stalling of DNA polymerases during replication. All terms, parameters, and criteria are defined with mathematical precision, rendering the problem unambiguous and algorithmically solvable. No contradictions, missing information, or pseudoscientific claims have been identified. Therefore, a solution is not only possible but required.\n\nThe task is to enumerate all distinct hairpin instances within a given genome string $G$ that satisfy a set of simultaneous biophysical and structural constraints. A distinct instance is uniquely identified by a triple $(i, s, l)$, where $i$ is the $0$-indexed starting position of the hairpin candidate $H$ in $G$, $s$ is the length of the stem arms, and $l$ is the length of the loop.\n\nThe methodological approach is a direct and exhaustive search over the entire space of possible hairpin candidates. The algorithm proceeds systematically as follows:\n\n1.  **Candidate Generation**: We iterate through all permissible integer values for the stem length $s$ and loop length $l$, as constrained by the input parameters $(s_{\\min}, s_{\\max})$ and $(l_{\\min}, l_{\\max})$, respectively.\n    $$ s \\in [s_{\\min}, s_{\\max}] $$\n    $$ l \\in [l_{\\min}, l_{\\max}] $$\n    For each valid pair $(s, l)$, the total length of a hairpin candidate $H$ is $2s+l$. We then iterate through all possible starting positions $i$ for such a candidate within the genome $G$ of length $N$.\n    $$ i \\in [0, N - (2s+l)] $$\n    This triple loop structure ensures that every potential hairpin candidate, defined by $(i, s, l)$, is considered exactly once.\n\n2.  **Substructure Partitioning**: For each candidate triple $(i,s,l)$, we extract the corresponding substring $H = G[i:i+2s+l]$. This substring is partitioned into its constituent parts: the left arm $L$, the loop $\\ell$, and the right arm $R$.\n    -   $L = G[i:i+s]$\n    -   $\\ell = G[i+s:i+s+l]$\n    -   $R = G[i+s+l:i+2s+l]$\n\n3.  **Biophysical Analysis**: We then analyze the pairing potential between the left arm $L$ and the right arm $R$. According to the problem definition, a base pair is formed between $L[j]$ and $R[s-1-j]$ for each position $j \\in \\{0, 1, \\dots, s-1\\}$. We must quantify the following properties:\n    -   The total number of matches, $b$, where $R[s-1-j] = c(L[j])$, with $c$ being the complement map $\\{A \\leftrightarrow T, C \\leftrightarrow G\\}$.\n    -   The total number of mismatches, $m$, which is simply $m = s-b$.\n    -   The count of Guanine-Cytosine (GC) matches, $g$, where a match involves the pair $\\{G,C\\}$.\n\n4.  **Constraint Validation**: The computed properties $(b, m, g)$ for the candidate defined by $(i,s,l)$ are validated against the given stability criteria:\n    -   Mismatch tolerance: $m \\le k_{\\max}$\n    -   Minimum pairing: $b \\ge b_{\\min}$\n    -   Minimum GC fraction: A crucial check involves the GC fraction, $f_{\\mathrm{GC}}$. It is defined as $f_{\\mathrm{GC}} = g/b$ if $b \\neq 0$, and $f_{\\mathrm{GC}} = 0$ if $b=0$. This calculated value must satisfy $f_{\\mathrm{GC}} \\ge f_{\\mathrm{GC}}^{\\min}$.\n\n5.  **Enumeration**: If a candidate $(i,s,l)$ satisfies all the specified constraints simultaneously, it is counted as a valid hairpin instance. The total count is accumulated across all evaluated candidates.\n\nThis exhaustive enumeration provides the exact, unique, and correct solution as demanded by the problem statement. The final result for each test case is the total count of such valid $(i,s,l)$ triples.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DNA hairpin counting problem for a suite of test cases.\n    \"\"\"\n    \n    # The complement map for DNA bases.\n    complement_map = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            \"AAAGCGCTTGCGCAAATTT\",\n            (4, 4, 2, 2, 0, 4, 0.75)\n        ),\n        (\n            \"TTTATCAAAGTTCCC\",\n            (3, 3, 3, 3, 1, 2, 0.5)\n        ),\n        (\n            \"ATCAAAGTT\",\n            (3, 3, 3, 3, 0, 3, 1.0)\n        ),\n        (\n            \"AAAGCGCTTGCGCTTTCCGGAACCGGAAA\",\n            (4, 4, 2, 2, 0, 4, 1.0)\n        ),\n        (\n            \"AAAGTATCAAAGGTCCAAA\",\n            (5, 5, 3, 3, 2, 3, 2/3)\n        ),\n    ]\n\n    def count_hairpins(G, params):\n        \"\"\"\n        Calculates the number of valid hairpin instances in a genome string.\n        \"\"\"\n        s_min, s_max, l_min, l_max, k_max, b_min, f_gc_min = params\n        N = len(G)\n        valid_hairpin_count = 0\n\n        # Iterate over all possible stem lengths s\n        for s in range(s_min, s_max + 1):\n            if s  1: continue\n\n            # Iterate over all possible loop lengths l\n            for l in range(l_min, l_max + 1):\n                if l  1: continue\n\n                hairpin_len = 2 * s + l\n                if hairpin_len > N:\n                    continue\n\n                # Iterate over all possible start positions i\n                for i in range(N - hairpin_len + 1):\n                    # Extract hairpin candidate substructures\n                    L = G[i : i + s]\n                    # Loop ell is G[i + s : i + s + l]\n                    R = G[i + s + l : i + hairpin_len]\n                    \n                    # Calculate biophysical properties\n                    b = 0  # matches\n                    g = 0  # GC matches\n                    \n                    for j in range(s):\n                        base_L = L[j]\n                        base_R = R[s - 1 - j]\n                        \n                        if complement_map.get(base_L) == base_R:\n                            b += 1\n                            if base_L in ('G', 'C'):\n                                g += 1\n                    \n                    m = s - b # mismatches\n\n                    # Check stability criteria\n                    # 1. Stem length (implicit in loop bounds)\n                    # 2. Loop length (implicit in loop bounds)\n                    # 3. Mismatch tolerance\n                    if m > k_max:\n                        continue\n                    \n                    # 4. Minimum pairing\n                    if b  b_min:\n                        continue\n                        \n                    # 5. Minimum GC fraction\n                    if b == 0:\n                        f_gc = 0.0\n                    else:\n                        f_gc = g / b\n                    \n                    if f_gc  f_gc_min:\n                        continue\n                        \n                    # If all criteria are met, this is a valid hairpin instance\n                    valid_hairpin_count += 1\n                        \n        return valid_hairpin_count\n\n    results = []\n    for genome, parameters in test_cases:\n        result = count_hairpins(genome, parameters)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2403464"}, {"introduction": "Replication is a globally orchestrated process, with distinct initiation and termination zones distributed across the genome. High-throughput experiments generate replication timing profiles where these zones appear as characteristic 'U-shaped' and 'N-shaped' patterns, respectively. This practice introduces you to the analysis of such genomic data, requiring you to build a classifier that can distinguish between initiation and termination sites based on the shape of their noisy profiles [@problem_id:2403516].", "problem": "You are given the task of building a deterministic classifier that distinguishes between genomic windows corresponding to initiation zones and termination zones of deoxyribonucleic acid (DNA) replication, using simplified synthetic replication timing profiles. In replication timing data, initiation zones tend to manifest as U-shaped valleys, whereas termination zones tend to manifest as inverted U-shaped profiles (N-shaped). For this task, each replication timing profile is represented as a discrete set of samples from a scalar function of a one-dimensional genomic coordinate.\n\nEach test case defines a synthetic replication timing profile over a window by sampling at $n$ equally spaced coordinates $x_i$ on the closed interval $\\left[-1,1\\right]$, where $i \\in \\{1,2,\\dots,n\\}$. The observed replication timing value at coordinate $x_i$ is given by\n$$\ny_i \\;=\\; a\\,(x_i - c)^2 + b + d\\,x_i + \\varepsilon_i,\n$$\nwhere $a, b, c, d$ are real-valued parameters, and $\\varepsilon_i$ are independent and identically distributed samples from a normal distribution with mean $0$ and standard deviation $\\sigma$. The coordinate grid is defined by $x_i = -1 + \\dfrac{2(i-1)}{n-1}$ for $i = 1,\\dots,n$. The label is defined by the sign of the intrinsic curvature parameter $a$: initiation (U-shaped) if $a  0$, and termination (N-shaped) if $a  0$. However, when deciding labels, you must treat only the observable pairs $(x_i, y_i)$ as available; you are not allowed to rely on the hidden generating parameter $a$.\n\nYour program must construct the profiles for the following test suite and output a binary prediction for each test case in order, using the rule: output $1$ for predicted initiation (U-shaped) and $0$ for predicted termination (N-shaped). No user input is provided; all quantities needed are specified here. There are no physical units to report. Angles are not used. All outputs must be integers.\n\nTest suite (each bullet describes one test case in the exact order they must be evaluated):\n\n- Case $1$: $n = 101$, $a = 0.8$, $b = 0.05$, $c = 0.0$, $d = 0.0$, $\\sigma = 0.05$, random seed $= 41$.\n- Case $2$: $n = 101$, $a = -0.7$, $b = -0.02$, $c = 0.2$, $d = 0.0$, $\\sigma = 0.05$, random seed $= 7$.\n- Case $3$: $n = 121$, $a = 0.4$, $b = 0.0$, $c = -0.2$, $d = 0.3$, $\\sigma = 0.07$, random seed $= 99$.\n- Case $4$: $n = 121$, $a = -0.5$, $b = 0.1$, $c = 0.1$, $d = -0.2$, $\\sigma = 0.08$, random seed $= 123$.\n- Case $5$: $n = 81$, $a = 0.25$, $b = 0.0$, $c = 0.0$, $d = -0.1$, $\\sigma = 0.15$, random seed $= 2025$.\n- Case $6$: $n = 81$, $a = -0.2$, $b = 0.05$, $c = -0.1$, $d = 0.0$, $\\sigma = 0.05$, random seed $= 555$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[1,0,1,1,0,0]\"), in the same order as the test cases above, with no additional text. The required outputs are integers and must be reported as a list of length $6$.", "solution": "The problem presented is a standard exercise in statistical estimation and classification, and as such, it is valid. It requires the construction of a deterministic classifier to distinguish between two classes of synthetic genomic profiles based on their shape. The classification is to be performed on data generated from a known model with stochastic components.\n\nThe underlying physical process is modeled by the equation:\n$$ y_i \\;=\\; a(x_i - c)^2 + b + d x_i + \\varepsilon_i $$\nwhere $(x_i, y_i)$ for $i \\in \\{1, \\dots, n\\}$ represent the observable data, $\\varepsilon_i$ are independent and identically distributed random variables from a normal distribution $\\mathcal{N}(0, \\sigma^2)$, and $a, b, c, d$ are the hidden parameters defining the signal.\n\nThe classification rule is based on the sign of the parameter $a$. A positive value of $a$ corresponds to an 'initiation' profile (U-shaped, concave up), while a negative value of $a$ corresponds to a 'termination' profile (N-shaped, concave down). The task is to infer this sign from the observed data $(x_i, y_i)$ alone.\n\nTo accomplish this, we must first recognize the structure of the model equation. By expanding the quadratic term, the equation can be rewritten as:\n$$ y_i = a x_i^2 - 2ac x_i + ac^2 + b + d x_i + \\varepsilon_i $$\nGrouping terms by powers of $x_i$ reveals a simple polynomial structure:\n$$ y_i = (a) x_i^2 + (d - 2ac) x_i + (ac^2 + b) + \\varepsilon_i $$\nThis is a quadratic model of the form $y_i = \\beta_2 x_i^2 + \\beta_1 x_i + \\beta_0 + \\varepsilon_i$, where the coefficients are defined as:\n$$ \\beta_2 = a $$\n$$ \\beta_1 = d - 2ac $$\n$$ \\beta_0 = ac^2 + b $$\nThe critical parameter for classification, $a$, is identical to the coefficient of the quadratic term, $\\beta_2$. Therefore, the problem reduces to estimating $\\beta_2$ from the noisy data and determining its sign.\n\nThe standard and optimal method for estimating the coefficients of such a linear model is the method of least squares. We seek to find a set of estimated coefficients $\\hat{\\boldsymbol{\\beta}} = [\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2]^T$ that minimizes the sum of squared residuals, $SSR$:\n$$ SSR = \\sum_{i=1}^{n} (y_i - (\\hat{\\beta}_0 + \\hat{\\beta}_1 x_i + \\hat{\\beta}_2 x_i^2))^2 $$\nThis problem can be expressed in matrix algebra. Let $\\mathbf{y}$ be the $n \\times 1$ column vector of observations $[y_1, \\dots, y_n]^T$. Let $\\mathbf{X}$ be the $n \\times 3$ design matrix, where each row corresponds to an observation and each column to a predictor term:\n$$\n\\mathbf{X} = \\begin{pmatrix}\n1  x_1  x_1^2 \\\\\n1  x_2  x_2^2 \\\\\n\\vdots  \\vdots  \\vdots \\\\\n1  x_n  x_n^2\n\\end{pmatrix}\n$$\nThe linear model is then $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}$. The least-squares solution $\\hat{\\boldsymbol{\\beta}}$ that minimizes $\\|\\mathbf{y} - \\mathbf{X}\\hat{\\boldsymbol{\\beta}}\\|^2$ is given by the solution to the normal equations:\n$$ \\mathbf{X}^T \\mathbf{X} \\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T \\mathbf{y} $$\nAssuming $\\mathbf{X}^T \\mathbf{X}$ is invertible, the solution is:\n$$ \\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y} $$\nNumerically, this solution is computed efficiently using methods such as QR decomposition, as implemented in standard scientific computing libraries.\n\nOur estimate for the parameter $a$ is the estimated coefficient of the quadratic term, $\\hat{a} = \\hat{\\beta}_2$. The classification rule is then definitively established:\n- If $\\hat{\\beta}_2  0$, the profile is classified as initiation (label $1$).\n- If $\\hat{\\beta}_2 \\le 0$, the profile is classified as termination (label $0$).\n\nFor each test case, the procedure is as follows:\n1.  Set the random number generator seed to ensure reproducibility.\n2.  Generate the $n$ coordinates $x_i$ over the interval $[-1, 1]$.\n3.  Generate $n$ noise samples $\\varepsilon_i$ from $\\mathcal{N}(0, \\sigma^2)$.\n4.  Compute the observed data $y_i$ using the given parameters $a, b, c, d, \\sigma$.\n5.  Construct the design matrix $\\mathbf{X}$ and the observation vector $\\mathbf{y}$.\n6.  Solve the least-squares problem for $\\hat{\\boldsymbol{\\beta}} = [\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2]^T$.\n7.  Apply the decision rule based on the sign of $\\hat{\\beta}_2$ to obtain the classification label.\n\nThis procedure is applied to all specified test cases to generate the final list of predictions.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the classification problem for a suite of synthetic DNA replication timing profiles.\n    The method involves fitting a quadratic model to the data using least squares\n    and classifying based on the sign of the estimated quadratic coefficient.\n    \"\"\"\n    test_cases = [\n        # n, a, b, c, d, sigma, seed\n        (101, 0.8, 0.05, 0.0, 0.0, 0.05, 41),\n        (101, -0.7, -0.02, 0.2, 0.0, 0.05, 7),\n        (121, 0.4, 0.0, -0.2, 0.3, 0.07, 99),\n        (121, -0.5, 0.1, 0.1, -0.2, 0.08, 123),\n        (81, 0.25, 0.0, 0.0, -0.1, 0.15, 2025),\n        (81, -0.2, 0.05, -0.1, 0.0, 0.05, 555),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        n, a, b, c, d, sigma, seed = case\n        \n        # 1. Set the random seed for reproducibility.\n        np.random.seed(seed)\n        \n        # 2. Generate the coordinate grid over [-1, 1].\n        x = np.linspace(-1, 1, int(n))\n        \n        # 3. Generate Gaussian noise.\n        epsilon = np.random.normal(loc=0.0, scale=sigma, size=int(n))\n        \n        # 4. Compute the observed data y using the generative model.\n        y = a * (x - c)**2 + b + d * x + epsilon\n        \n        # 5. Construct the design matrix for quadratic regression.\n        # The model is y = beta_0 + beta_1*x + beta_2*x^2.\n        # The columns represent powers of x: x^0, x^1, x^2.\n        X = np.vstack([np.ones_like(x), x, x**2]).T\n        \n        # 6. Solve the linear least-squares problem to find the coefficients.\n        # The solution vector beta_hat corresponds to [beta_0, beta_1, beta_2].\n        beta_hat, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        \n        # 7. The estimated quadratic coefficient, a_hat, is the third element.\n        a_hat = beta_hat[2]\n        \n        # 8. Apply the decision rule:\n        # 1 for initiation (U-shaped, a > 0), 0 for termination (N-shaped, a  0).\n        prediction = 1 if a_hat > 0 else 0\n        results.append(prediction)\n\n    # 9. Format the output as a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2403516"}]}