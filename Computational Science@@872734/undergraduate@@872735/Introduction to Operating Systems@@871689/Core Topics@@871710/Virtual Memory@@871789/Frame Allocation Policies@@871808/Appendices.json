{"hands_on_practices": [{"introduction": "A central challenge in operating systems is to distribute a finite number of memory frames among competing processes to maximize overall performance. This practice explores a hybrid \"global-over-reserves\" policy, which provides each process with a guaranteed minimum set of frames while allowing a global pool to be allocated dynamically. By modeling the diminishing returns of adding extra frames, this exercise [@problem_id:3645310] will guide you through formalizing this scenario as an optimization problem and solving it with a greedy algorithm, a foundational technique for efficient resource allocation.", "problem": "Consider an Operating System (OS) managing $N$ concurrent processes under a hybrid frame allocation policy called \"global-over-reserves.\" Each process $i$ must be guaranteed a minimum reserve of $k_i$ page frames, and all frames above these reserves are allocated globally to optimize system performance.\n\nStart from the following foundational definitions and widely accepted facts:\n- A \"local\" frame allocation policy fixes each process's frames independently, while a \"global\" policy allows processes to compete for a shared pool of frames.\n- For a given process $i$, the steady-state page fault rate $f_i(m)$ is a decreasing function of the number of frames $m$ allocated to it. Additional frames beyond the process's working set typically yield diminishing returns.\n\nYou are given $N = 3$ processes and a total of $M = 15$ physical frames. The per-process reserves are $k_1 = 3$, $k_2 = 2$, and $k_3 = 4$. Define the allocated frames to process $i$ as $m_i$, with the constraint $m_i \\geq k_i$ and $\\sum_{i=1}^{N} m_i = M$. Let the extras $e_i$ be defined by $e_i = m_i - k_i \\geq 0$, so that $\\sum_{i=1}^{N} e_i = M - \\sum_{i=1}^{N} k_i$.\n\nUnder the global-over-reserves policy, the system first allocates the reserves and then distributes the extras to minimize the total steady-state page fault rate $\\sum_{i=1}^{N} f_i(m_i)$. For each process $i$, the page fault rate at the reserve allocation is $f_i(k_i) = f_{i,0}$, and each extra frame $j$ allocated to process $i$ yields a marginal reduction $r_{i,j}$ in its page fault rate. Assume that for each process $i$, the sequence $\\{r_{i,j}\\}$ is non-increasing in $j$ (diminishing returns), and that beyond the listed $r_{i,j}$ values, additional frames produce zero marginal reduction.\n\nThe parameters are:\n- $f_{1,0} = 0.30$, $r_{1,1} = 0.08$, $r_{1,2} = 0.06$, $r_{1,3} = 0.05$, $r_{1,4} = 0.02$.\n- $f_{2,0} = 0.40$, $r_{2,1} = 0.12$, $r_{2,2} = 0.07$, $r_{2,3} = 0.03$.\n- $f_{3,0} = 0.25$, $r_{3,1} = 0.09$, $r_{3,2} = 0.04$.\n\nTasks:\n1. Formalize the hybrid global-over-reserves allocation as an optimization problem over the extras $e_i$ that minimizes $\\sum_{i=1}^{N} f_i(m_i)$ subject to the reserve constraints.\n2. Compute the minimized value of $\\sum_{i=1}^{N} f_i(m_i)$ under this policy using the provided $f_{i,0}$ and $r_{i,j}$ values.\n\nExpress your final numeric answer as a decimal rounded to four significant figures. Do not use a percentage sign; treat all page fault rates as dimensionless fractions.", "solution": "The problem is validated as scientifically grounded, well-posed, objective, and complete. It represents a standard resource allocation problem within the domain of operating systems.\n\n### Step 1: Formalization of the Optimization Problem\n\nThe objective is to minimize the total steady-state page fault rate, denoted by $F$, which is the sum of the individual page fault rates of each process:\n$$\nF = \\sum_{i=1}^{N} f_i(m_i)\n$$\nwhere $N=3$ is the number of processes and $m_i$ is the number of frames allocated to process $i$.\n\nThe total number of frames is $M=15$. The allocation must satisfy the constraint that all frames are used:\n$$\n\\sum_{i=1}^{N} m_i = M\n$$\n\nEach process $i$ has a guaranteed minimum reserve of $k_i$ frames, so the allocation must also respect the constraint:\n$$\nm_i \\geq k_i \\quad \\text{for } i=1, 2, \\dots, N\n$$\n\nWe define the number of \"extra\" frames allocated to process $i$ beyond its reserve as $e_i = m_i - k_i$. By definition, $e_i \\geq 0$. Substituting $m_i = k_i + e_i$ into the total frame constraint gives:\n$$\n\\sum_{i=1}^{N} (k_i + e_i) = M \\implies \\sum_{i=1}^{N} e_i = M - \\sum_{i=1}^{N} k_i\n$$\nThis sum represents the total pool of extra frames, $E$, to be distributed globally.\n\nThe page fault rate for process $i$ with $m_i = k_i + e_i$ frames is given by its rate at the reserve level, $f_{i,0} = f_i(k_i)$, minus the cumulative reduction from the $e_i$ extra frames:\n$$\nf_i(m_i) = f_i(k_i + e_i) = f_{i,0} - \\sum_{j=1}^{e_i} r_{i,j}\n$$\nwhere $r_{i,j}$ is the marginal reduction from the $j$-th extra frame for process $i$.\n\nThe total page fault rate can now be expressed as a function of the extra frame allocations $e_i$:\n$$\nF(e_1, \\dots, e_N) = \\sum_{i=1}^{N} \\left( f_{i,0} - \\sum_{j=1}^{e_i} r_{i,j} \\right) = \\left(\\sum_{i=1}^{N} f_{i,0}\\right) - \\left(\\sum_{i=1}^{N} \\sum_{j=1}^{e_i} r_{i,j}\\right)\n$$\nThe first term, $\\sum_{i=1}^{N} f_{i,0}$, is a constant based on the initial reserve allocation. Therefore, minimizing the total page fault rate $F$ is equivalent to maximizing the total reduction in page fault rate, $R$:\n$$\n\\text{Maximize } R(e_1, \\dots, e_N) = \\sum_{i=1}^{N} \\sum_{j=1}^{e_i} r_{i,j}\n$$\nThe formal optimization problem is to find the non-negative integers $e_1, e_2, \\dots, e_N$ that maximize $R$ subject to the constraint $\\sum_{i=1}^{N} e_i = M - \\sum_{i=1}^{N} k_i$.\n\n### Step 2: Computation of the Minimized Page Fault Rate\n\nFirst, we calculate the total number of extra frames available for global allocation.\nThe reserves are $k_1 = 3$, $k_2 = 2$, and $k_3 = 4$. The total number of reserved frames is:\n$$\n\\sum_{i=1}^{3} k_i = 3 + 2 + 4 = 9\n$$\nWith a total of $M = 15$ physical frames, the number of extra frames to distribute is:\n$$\nE = M - \\sum_{i=1}^{3} k_i = 15 - 9 = 6\n$$\nThe problem now reduces to allocating these $6$ extra frames. Since the marginal returns $\\{r_{i,j}\\}$ are non-increasing for each process, a greedy algorithm that always allocates the next frame to the process offering the highest marginal reduction will yield an optimal solution.\n\nWe list all available marginal reductions $r_{i,j}$:\n- Process 1: $r_{1,1} = 0.08$, $r_{1,2} = 0.06$, $r_{1,3} = 0.05$, $r_{1,4} = 0.02$\n- Process 2: $r_{2,1} = 0.12$, $r_{2,2} = 0.07$, $r_{2,3} = 0.03$\n- Process 3: $r_{3,1} = 0.09$, $r_{3,2} = 0.04$\n\nWe proceed to allocate the $6$ frames greedily:\n\n1.  **Allocation 1:** The largest available reduction is $r_{2,1} = 0.12$. Allocate the 1st extra frame to Process 2.\n    - Total reduction so far: $0.12$. Frames remaining: $5$.\n\n2.  **Allocation 2:** The next largest available reduction is $r_{3,1} = 0.09$. Allocate the 2nd extra frame to Process 3.\n    - Total reduction so far: $0.12 + 0.09 = 0.21$. Frames remaining: $4$.\n\n3.  **Allocation 3:** The next largest is $r_{1,1} = 0.08$. Allocate the 3rd extra frame to Process 1.\n    - Total reduction so far: $0.21 + 0.08 = 0.29$. Frames remaining: $3$.\n\n4.  **Allocation 4:** The next largest is $r_{2,2} = 0.07$ (from Process 2). Allocate the 4th extra frame to Process 2.\n    - Total reduction so far: $0.29 + 0.07 = 0.36$. Frames remaining: $2$.\n\n5.  **Allocation 5:** The next largest is $r_{1,2} = 0.06$ (from Process 1). Allocate the 5th extra frame to Process 1.\n    - Total reduction so far: $0.36 + 0.06 = 0.42$. Frames remaining: $1$.\n\n6.  **Allocation 6:** The next largest is $r_{1,3} = 0.05$ (from Process 1). Allocate the 6th extra frame to Process 1.\n    - Total reduction so far: $0.42 + 0.05 = 0.47$. Frames remaining: $0$.\n\nThe allocation of the $6$ extra frames is complete. The total maximized reduction is $R_{max} = 0.47$.\n\nThe final allocation of extra frames is:\n- Process 1: $e_1 = 3$ frames\n- Process 2: $e_2 = 2$ frames\n- Process 3: $e_3 = 1$ frame\n\nThe total number of frames for each process is:\n- $m_1 = k_1 + e_1 = 3 + 3 = 6$\n- $m_2 = k_2 + e_2 = 2 + 2 = 4$\n- $m_3 = k_3 + e_3 = 4 + 1 = 5$\n\nThe initial total page fault rate, with only reserve frames allocated, is:\n$$\n\\sum_{i=1}^{3} f_{i,0} = f_{1,0} + f_{2,0} + f_{3,0} = 0.30 + 0.40 + 0.25 = 0.95\n$$\nThe minimized total page fault rate is the initial rate minus the maximum total reduction:\n$$\nF_{min} = \\left(\\sum_{i=1}^{3} f_{i,0}\\right) - R_{max} = 0.95 - 0.47 = 0.48\n$$\nTo verify, we can calculate the final fault rate for each process:\n- $f_1(6) = f_{1,0} - (r_{1,1} + r_{1,2} + r_{1,3}) = 0.30 - (0.08 + 0.06 + 0.05) = 0.30 - 0.19 = 0.11$\n- $f_2(4) = f_{2,0} - (r_{2,1} + r_{2,2}) = 0.40 - (0.12 + 0.07) = 0.40 - 0.19 = 0.21$\n- $f_3(5) = f_{3,0} - r_{3,1} = 0.25 - 0.09 = 0.16$\n\nThe minimized total page fault rate is the sum of these individual rates:\n$$\nF_{min} = f_1(6) + f_2(4) + f_3(5) = 0.11 + 0.21 + 0.16 = 0.48\n$$\nThe problem requires the answer to be rounded to four significant figures, which is $0.4800$.", "answer": "$$\\boxed{0.4800}$$", "id": "3645310"}, {"introduction": "Theoretical models are powerful, but the true test of a policy lies in its behavior under dynamic, real-world workloads. This hands-on simulation [@problem_id:3645321] pits two classic process types against each other: a \"streaming\" process that sequentially scans large amounts of data, and a \"looping\" process that reuses a small, fixed set of pages. By implementing and observing both local and global allocation policies, you will gain tangible insight into how a global policy's flexibility can sometimes harm processes with stable memory needs, a critical trade-off in system design.", "problem": "Consider a two-process virtual memory system in which virtual memory pages are mapped into a finite set of physical frames. The fundamental starting point is the definition of a page fault: whenever a process references a virtual page that is not currently resident in any physical frame, the system incurs a page fault and must load that page into a frame, possibly evicting an existing page according to a page replacement policy. We will use the Least Recently Used (LRU) policy, which evicts the page whose last access time is furthest in the past. We define two frame allocation policies: local allocation, in which each process evicts only from its own assigned frames, and global allocation, in which all frames are pooled and evictions can remove pages belonging to any process.\n\nYou are to simulate two specific processes under both policies:\n- A streaming process that scans a set of unique pages sequentially and may repeat this scan for multiple passes.\n- A looping process that repeatedly cycles over a fixed working set of pages.\n\nCore definitions:\n- Let the streaming process have a working set size of $U_s$ distinct pages. It performs $P_s$ sequential passes over these $U_s$ pages, for a total of $T_s = U_s \\cdot P_s$ references. On each pass, it references pages in the exact order $0, 1, 2, \\dots, (U_s - 1)$.\n- Let the looping process have a working set size of $U_l$ distinct pages. It performs $P_l$ complete loops over these $U_l$ pages, for a total of $T_l = U_l \\cdot P_l$ references. On each loop, it references pages in the exact order $0, 1, 2, \\dots, (U_l - 1)$.\n- Interleaving schedule: in each cycle, the system issues $q_s$ references from the streaming process (if any remain), followed by $q_l$ references from the looping process (if any remain), and repeats this cycle until both processes complete their total references $T_s$ and $T_l$. When one process completes early, the other continues alone.\n- Under local allocation, the streaming process has $f_s$ frames and the looping process has $f_l$ frames; replacement occurs only within the owning process's frames. Under global allocation, there are $F$ total frames shared by both processes; replacement can evict any page regardless of process.\n- We assume a single global clock for LRU: every reference increments a global time counter, and the LRU victim is the page with the smallest last-access time. Ties are broken by choosing the page with the smallest last-access time value (this is equivalent under LRU). A page is considered the same only if both its process identity and its page number match; pages from different processes are distinct even if they share the same page number.\n\nYour task is to implement a complete, runnable program in the C programming language that:\n1. Simulates both local and global allocation policies as defined above.\n2. Counts page faults separately for the streaming process and the looping process under each policy.\n3. Determines, for each test case, whether global allocation helps the stream and whether it ruins the loop, according to the following predicates:\n   - Global helps the stream if and only if $PF^{G}_s < PF^{L}_s$, where $PF^{G}_s$ and $PF^{L}_s$ denote the streaming process page faults under global and local allocation, respectively.\n   - Global ruins the loop if and only if $PF^{G}_l > PF^{L}_l$, where $PF^{G}_l$ and $PF^{L}_l$ denote the looping process page faults under global and local allocation, respectively.\n\nProvide results for the following test suite. Each test case is specified by $(U_s, P_s, U_l, P_l, f_s, f_l, F, q_s, q_l)$, and all quantities are nonnegative integers, with $F \\ge f_s + f_l$ to maintain physical consistency:\n- Test case $1$: $(U_s, P_s, U_l, P_l, f_s, f_l, F, q_s, q_l) = (50, 2, 5, 20, 3, 5, 60, 5, 1)$.\n- Test case $2$: $(U_s, P_s, U_l, P_l, f_s, f_l, F, q_s, q_l) = (40, 2, 6, 30, 3, 6, 20, 8, 1)$.\n- Test case $3$: $(U_s, P_s, U_l, P_l, f_s, f_l, F, q_s, q_l) = (20, 2, 10, 30, 10, 10, 20, 1, 1)$.\n- Test case $4$: $(U_s, P_s, U_l, P_l, f_s, f_l, F, q_s, q_l) = (30, 1, 10, 40, 3, 10, 13, 20, 1)$.\n\nOutput specification:\n- For each test case, compute two booleans: $b_1$ indicating whether global helps the stream ($1$ if true, $0$ otherwise) and $b_2$ indicating whether global ruins the loop ($1$ if true, $0$ otherwise).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list of integers $[b_1, b_2]$. For example, the overall output must have the exact form $$[[b_{1,1}, b_{1,2}], [b_{2,1}, b_{2,2}], [b_{3,1}, b_{3,2}], [b_{4,1}, b_{4,2}]]$$ with no spaces added or any extra text.\nNo physical units or angles are involved in this problem; all outputs are unitless integers. The final program must be self-contained and must not read input.", "solution": "The problem has been validated and is deemed well-posed, scientifically grounded, and internally consistent. It presents a standard simulation task from the field of operating systems, with all parameters and behaviors clearly and formally defined. No logical contradictions, ambiguities, or factual unsoundness were found.\n\nThe problem requires the simulation of a two-process system under two distinct memory frame allocation policies: local and global. The objective is to quantify the number of page faults for each process under each policy and compare the outcomes. The simulation will be driven by deterministic reference strings generated by a streaming process, $S$, and a looping process, $L$.\n\nThe core of the solution is a discrete-time event simulation. A global clock, represented by a variable `time`, is incremented upon every memory reference. The state of the physical memory is represented by an array of data structures, each corresponding to a physical frame. A `Frame` structure must contain:\n1.  `process_id`: An identifier for the owning process ($0$ for the streaming process, $1$ for the looping process). A sentinel value of $-1$ can indicate an empty frame.\n2.  `page_num`: The virtual page number stored in the frame.\n3.  `last_used_time`: The value of the global clock at the time this page was last referenced. This is critical for implementing the Least Recently Used (LRU) replacement policy.\n\nThe simulation proceeds by generating memory references according to the specified interleaving schedule. For each reference to a virtual page $(p_{id}, p_{num})$ at time $t$, where $p_{id}$ is the process ID and $p_{num}$ is the page number, the system must check if this page is resident in a physical frame.\n\n-   **Page Hit**: If the page $(p_{id}, p_{num})$ is found in a frame, it is a page hit. The only action required is to update the `last_used_time` of that frame to the current time $t$.\n\n-   **Page Fault**: If the page is not found, a page fault occurs. The page fault counter for process $p_{id}$ is incremented. The system must then load the page into a frame.\n    1.  **Find Target Frame**: The system first searches for an empty frame (where `process_id` is $-1$). If one is available, it is chosen as the target.\n    2.  **LRU Replacement**: If all frames in the relevant pool are occupied, the LRU policy is invoked. The frame with the minimum `last_used_time` value is identified as the victim. This is the frame that has been unused for the longest duration.\n    3.  **Load Page**: The new page $(p_{id}, p_{num})$ and its reference time $t$ are loaded into the target frame (either the newly found empty frame or the victim frame), overwriting its previous contents.\n\nThe simulation must be executed for two distinct policy configurations:\n\n1.  **Local Allocation**: Two separate pools of frames are maintained. One pool of size $f_s$ for the streaming process ($S$) and another of size $f_l$ for the looping process ($L$). When a fault occurs for process $S$, the search for a free frame or an LRU victim is confined entirely to its dedicated pool of $f_s$ frames. Similarly, process $L$ only uses its $f_l$ frames. This isolates the processes from each other's memory access behavior.\n\n2.  **Global Allocation**: A single, shared pool of $F$ frames is available to both processes. When a fault occurs for either process, the search for a free frame or an LRU victim is performed across the entire pool of $F$ frames. This means a page from process $S$ can be evicted to make room for a page from process $L$, and vice versa. The LRU victim is the least recently used page in the entire system, regardless of which process it belongs to.\n\nThe main simulation driver generates the reference sequence based on the parameters $(U_s, P_s, q_s)$ for the streaming process and $(U_l, P_l, q_l)$ for the looping process. It iterates in cycles, issuing $q_s$ references for process $S$ followed by $q_l$ references for process $L$, until both processes have completed their total number of references, $T_s = U_s \\cdot P_s$ and $T_l = U_l \\cdot P_l$. The $k^{th}$ reference (0-indexed) for the streaming process is to page $k \\pmod{U_s}$, and for the looping process is to page $k \\pmod{U_l}$.\n\nFor each test case, we first run the simulation with local allocation to obtain the page fault counts $PF^{L}_s$ and $PF^{L}_l$. We then reset the system and run the simulation again with global allocation to obtain $PF^{G}_s$ and $PF^{G}_l$. Finally, we compute the two boolean indicators:\n-   `Global helps the stream`, $b_1$, is $1$ if $PF^{G}_s < PF^{L}_s$, and $0$ otherwise.\n-   `Global ruins the loop`, $b_2$, is $1$ if $PF^{G}_l > PF^{L}_l$, and $0$ otherwise.\n\nThe program will execute this procedure for all specified test cases and format the results as a single-line list of boolean pairs.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// A struct to hold a page's information within a physical frame.\ntypedef struct {\n    int process_id;       // 0 for stream, 1 for loop, -1 for empty\n    int page_num;         // Virtual page number\n    long long last_used_time; // Global clock time of last access\n} Frame;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int Us, Ps, Ul, Pl, fs, fl, F, qs, ql;\n} TestCase;\n\n// A struct to return page fault counts for both processes.\ntypedef struct {\n    int s; // Page faults for streaming process\n    int l; // Page faults for looping process\n} PFCounts;\n\n// Processes a single memory reference.\n// Handles page hits and faults, including LRU replacement.\nvoid handle_reference(int proc_id, int page_num, long long time, Frame* frame_pool, int pool_size, int* pf_counter) {\n    int hit_idx = -1;\n    // Search for the page in the frame pool\n    for (int i = 0; i < pool_size; ++i) {\n        if (frame_pool[i].process_id == proc_id && frame_pool[i].page_num == page_num) {\n            hit_idx = i;\n            break;\n        }\n    }\n\n    if (hit_idx != -1) { // Page Hit\n        frame_pool[hit_idx].last_used_time = time;\n    } else { // Page Fault\n        (*pf_counter)++;\n        \n        int target_idx = -1;\n        // Find an empty frame first\n        for (int i = 0; i < pool_size; ++i) {\n            if (frame_pool[i].process_id == -1) {\n                target_idx = i;\n                break;\n            }\n        }\n\n        // If no empty frame, find the LRU victim\n        if (target_idx == -1) {\n            int lru_idx = 0;\n            for (int i = 1; i < pool_size; ++i) {\n                if (frame_pool[i].last_used_time < frame_pool[lru_idx].last_used_time) {\n                    lru_idx = i;\n                }\n            }\n            target_idx = lru_idx;\n        }\n\n        // Place the new page in the target frame\n        frame_pool[target_idx].process_id = proc_id;\n        frame_pool[target_idx].page_num = page_num;\n        frame_pool[target_idx].last_used_time = time;\n    }\n}\n\n\n// Runs the full simulation for a given policy (local or global).\nPFCounts run_simulation(const TestCase* tc, int is_global) {\n    long long time = 0;\n    int pf_s = 0, pf_l = 0;\n    long refs_done_s = 0, refs_done_l = 0;\n    long total_refs_s = (long)tc->Us * tc->Ps;\n    long total_refs_l = (long)tc->Ul * tc->Pl;\n\n    Frame *frames_s = NULL, *frames_l = NULL;\n    int num_frames_s = 0, num_frames_l = 0;\n\n    // Initialize frame pools based on allocation policy\n    if (is_global) {\n        num_frames_s = num_frames_l = tc->F;\n        frames_s = malloc(sizeof(Frame) * tc->F);\n        for(int i=0; i<tc->F; ++i) frames_s[i].process_id = -1;\n        frames_l = frames_s; // Both point to the same shared pool\n    } else {\n        num_frames_s = tc->fs;\n        num_frames_l = tc->fl;\n        frames_s = malloc(sizeof(Frame) * tc->fs);\n        frames_l = malloc(sizeof(Frame) * tc->fl);\n        for(int i=0; i<tc->fs; ++i) frames_s[i].process_id = -1;\n        for(int i=0; i<tc->fl; ++i) frames_l[i].process_id = -1;\n    }\n\n    // Main simulation loop\n    while (refs_done_s < total_refs_s || refs_done_l < total_refs_l) {\n        // Stream process's turn\n        for (int i = 0; i < tc->qs && refs_done_s < total_refs_s; ++i) {\n            int page = refs_done_s % tc->Us;\n            handle_reference(0, page, ++time, frames_s, num_frames_s, &pf_s);\n            refs_done_s++;\n        }\n\n        // Loop process's turn\n        for (int i = 0; i < tc->ql && refs_done_l < total_refs_l; ++i) {\n            int page = refs_done_l % tc->Ul;\n            handle_reference(1, page, ++time, frames_l, num_frames_l, &pf_l);\n            refs_done_l++;\n        }\n    }\n    \n    // Clean up allocated memory\n    if (is_global) {\n        free(frames_s);\n    } else {\n        free(frames_s);\n        free(frames_l);\n    }\n    \n    return (PFCounts){pf_s, pf_l};\n}\n\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {50, 2, 5, 20, 3, 5, 60, 5, 1},\n        {40, 2, 6, 30, 3, 6, 20, 8, 1},\n        {20, 2, 10, 30, 10, 10, 20, 1, 1},\n        {30, 1, 10, 40, 3, 10, 13, 20, 1},\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases][2];\n\n    for (int i = 0; i < num_cases; ++i) {\n        // Run simulation for local policy\n        PFCounts local_pfs = run_simulation(&test_cases[i], 0);\n\n        // Run simulation for global policy\n        PFCounts global_pfs = run_simulation(&test_cases[i], 1);\n        \n        // Determine the boolean outcomes\n        results[i][0] = (global_pfs.s < local_pfs.s) ? 1 : 0; // Global helps stream\n        results[i][1] = (global_pfs.l > local_pfs.l) ? 1 : 0; // Global ruins loop\n    }\n\n    // Print the results in the EXACT required format before the final return statement\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%d,%d]\", results[i][0], results[i][1]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3645321"}, {"introduction": "Beyond steady-state behavior, an operating system must gracefully handle transient events like the arrival of a new process. This exercise [@problem_id:3645334] focuses on the \"cold-start\" phase, where a new process must load its initial working set into memory. You will use first principles to calculate the new process's startup latency and the \"disruption\" caused to existing processes under both local and global allocation, quantitatively analyzing the core trade-off between providing rapid service to new tasks and maintaining stability for running ones.", "problem": "Consider a simplified memory management model for an Operating System (OS) with physical memory partitioned into identical frames. There are $m$ existing processes with stable resident working sets prior to the arrival of a new process. Each existing process $i$ has a current allocation $A_i$ frames and a working set size $W_i$ pages fully resident, with the invariant $A_i \\geq W_i$. The total number of frames in the system is $F$, and the number of free frames is $F_{\\text{free}} = F - \\sum_{i=1}^{m} A_i$. A new process arrives with a working set size $W_{\\text{new}}$ pages that are all initially absent from memory.\n\nUse the following fundamental base to reason about the start-up behavior:\n- The working set model: a working set is the set of pages actively used within a window, and each such page requires one resident frame.\n- A page fault occurs when a referenced page is not resident; bringing it into memory consumes one frame.\n- Under local allocation, existing processes never lose frames to a newcomer; the new process can only use $F_{\\text{free}}$.\n- Under global allocation, the new process may borrow frames from existing processes. Frames borrowed from the unused portions of existing allocations (beyond their working sets) do not disrupt them. Borrowing beyond those unused portions evicts pages from the existing processesâ€™ working sets, which causes additional page faults when those evicted pages are next referenced.\n\nDefine cold-start latency for the new process as the number of distinct pages that must be faulted to make its working set resident during start-up, evaluated under a given allocation policy. Define disruption as the total number of additional page faults induced in other processes due to eviction from their working sets during the pre-warming interval.\n\nTask: Implement a program that, for each test case, calculates three integers:\n- $L_{\\text{local}}$: the cold-start latency under local allocation. If the new process cannot make its entire working set resident using only $F_{\\text{free}}$ frames, set $L_{\\text{local}} = -1$.\n- $L_{\\text{global}}$: the cold-start latency under global allocation, assuming the system can borrow frames as needed from currently allocated frames during start-up, up to the physical memory limit.\n- $D_{\\text{global}}$: the total disruption under global allocation, quantified as the number of additional page faults in other processes caused by evicting pages from their working sets during the pre-warming interval.\n\nYour program must compute these values from first principles, using only the definitions above. For each test case, you are given $F$, $m$, the vectors $A = [A_1, A_2, \\dots, A_m]$, $W = [W_1, W_2, \\dots, W_m]$, and $W_{\\text{new}}$.\n\nTest suite (each line is a separate test case):\n- Case $1$: $F = 32$, $m = 2$, $A = [12, 10]$, $W = [10, 8]$, $W_{\\text{new}} = 14$.\n- Case $2$: $F = 32$, $m = 2$, $A = [14, 14]$, $W = [12, 12]$, $W_{\\text{new}} = 16$.\n- Case $3$: $F = 40$, $m = 3$, $A = [10, 10, 10]$, $W = [8, 9, 7]$, $W_{\\text{new}} = 9$.\n- Case $4$: $F = 20$, $m = 2$, $A = [9, 9]$, $W = [9, 9]$, $W_{\\text{new}} = 18$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of lists, with each inner list corresponding to one test case and ordered as $[L_{\\text{local}}, L_{\\text{global}}, D_{\\text{global}}]$. For example, the output must look like $[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots]$ with no spaces.", "solution": "The problem statement has been rigorously validated and found to be self-contained, scientifically grounded in the principles of operating system memory management, and well-posed. All provided data and definitions are consistent and sufficient for deriving a unique, meaningful solution.\n\nThe task is to compute three quantities for a new process arriving in a system with $m$ existing processes: the cold-start latency under local allocation ($L_{\\text{local}}$), the cold-start latency under global allocation ($L_{\\text{global}}$), and the system-wide disruption under global allocation ($D_{\\text{global}}$). The analysis proceeds from the first principles given in the problem statement.\n\nLet the given parameters for a test case be:\n- $F$: the total number of physical memory frames.\n- $m$: the number of existing processes.\n- $A_i$: the number of frames allocated to existing process $i$, for $i \\in \\{1, \\dots, m\\}$.\n- $W_i$: the working set size (in pages) of existing process $i$, for $i \\in \\{1, \\dots, m\\}$.\n- $W_{\\text{new}}$: the working set size (in pages) of the new process.\n\nFrom these givens, we can derive several key quantities describing the state of the system prior to the new process's arrival.\n1.  The total number of frames allocated to existing processes is the sum of their individual allocations:\n    $$A_{\\text{total}} = \\sum_{i=1}^{m} A_i$$\n2.  The number of free frames available in the system is the total number of frames minus those already allocated:\n    $$F_{\\text{free}} = F - A_{\\text{total}}$$\n3.  The total number of frames occupied by the working sets of existing processes is:\n    $$W_{\\text{total}} = \\sum_{i=1}^{m} W_i$$\n\nWith these quantities established, we can derive the required values.\n\n**1. Cold-Start Latency under Local Allocation ($L_{\\text{local}}$)**\n\nUnder a local allocation policy, the new process is restricted to using only the frames in the free pool, $F_{\\text{free}}$. The existing processes' frame allocations are not affected. The new process requires $W_{\\text{new}}$ frames to make its working set resident.\n\n- If the number of free frames is sufficient to accommodate the new process's entire working set ($F_{\\text{free}} \\geq W_{\\text{new}}$), the process will incur one page fault for each of its $W_{\\text{new}}$ pages. Thus, its cold-start latency is equal to its working set size.\n  $$L_{\\text{local}} = W_{\\text{new}} \\quad \\text{if } F_{\\text{free}} \\geq W_{\\text{new}}$$\n- If the number of free frames is insufficient ($F_{\\text{free}} < W_{\\text{new}}$), the new process cannot make its working set resident. According to the problem's explicit instruction for this scenario, the latency is set to a sentinel value.\n  $$L_{\\text{local}} = -1 \\quad \\text{if } F_{\\text{free}} < W_{\\text{new}}$$\n\nCombining these two conditions, the formula for $L_{\\text{local}}$ is:\n$$L_{\\text{local}} = \\begin{cases} W_{\\text{new}} & \\text{if } F - \\sum_{i=1}^{m} A_i \\geq W_{\\text{new}} \\\\ -1 & \\text{otherwise} \\end{cases}$$\n\n**2. Cold-Start Latency under Global Allocation ($L_{\\text{global}}$)**\n\nCold-start latency is defined as \"the number of distinct pages that must be faulted to make its working set resident\". The new process arrives with all $W_{\\text{new}}$ of its working set pages absent from memory. To bring each of these unique pages into a frame, it must incur one page fault per page. Under a global policy, the system can provide frames by reallocating them from any process. Therefore, regardless of the subsequent system stability or potential for thrashing, the initial number of faults incurred by the new process to load its working set is simply its size.\n$$L_{\\text{global}} = W_{\\text{new}}$$\n\n**3. Disruption under Global Allocation ($D_{\\text{global}}$)**\n\nDisruption is the total number of additional page faults induced in other processes due to the new process evicting pages from their working sets. To calculate this, we must determine how many frames the new process needs and from where the OS will source them. The OS reclaims frames in an order that minimizes disruption.\n\nThe new process requires $W_{\\text{new}}$ frames. The available sources are, in order of preference:\n1.  **Free Frames**: $F_{\\text{free}}$ frames are available at no cost to other processes.\n2.  **Surplus Frames**: These are frames allocated to existing processes but not part of their working sets. The total number of surplus frames is $S_{\\text{total}} = \\sum_{i=1}^{m} (A_i - W_i)$. Reclaiming these frames does not cause disruption.\n\nThe total number of frames that can be reclaimed without causing disruption is the sum of free and surplus frames:\n$$N_{\\text{no-disrupt}} = F_{\\text{free}} + S_{\\text{total}} = \\left(F - \\sum_{i=1}^{m} A_i\\right) + \\left(\\sum_{i=1}^{m} A_i - \\sum_{i=1}^{m} W_i\\right) = F - W_{\\text{total}}$$\nThis lucidly shows that all frames not actively part of an existing working set are available without causing disruption.\n\nIf the new process's requirement $W_{\\text{new}}$ exceeds this pool ($W_{\\text{new}} > N_{\\text{no-disrupt}}$), the system must reclaim the remaining frames from the working sets of existing processes. The number of frames that must be stolen this way corresponds directly to the disruption, $D_{\\text{global}}$.\n\nThe deficit of frames is:\n$$N_{\\text{deficit}} = W_{\\text{new}} - N_{\\text{no-disrupt}} = W_{\\text{new}} - (F - W_{\\text{total}}) = W_{\\text{new}} + W_{\\text{total}} - F$$\nDisruption only occurs if this deficit is positive. Therefore,\n$$D_{\\text{global}} = \\max(0, N_{\\text{deficit}}) = \\max(0, W_{\\text{new}} + W_{\\text{total}} - F)$$\nThis represents the number of pages evicted from the working sets of processes $1$ through $m$ to satisfy the memory demands of the new process.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int F;\n    int m;\n    int W_new;\n    const int* A;\n    const int* W;\n} TestCase;\n\nint main(void) {\n    // Define array data for the test cases.\n    const int A1[] = {12, 10};\n    const int W1[] = {10, 8};\n    const int A2[] = {14, 14};\n    const int W2[] = {12, 12};\n    const int A3[] = {10, 10, 10};\n    const int W3[] = {8, 9, 7};\n    const int A4[] = {9, 9};\n    const int W4[] = {9, 9};\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {32, 2, 14, A1, W1},\n        {32, 2, 16, A2, W2},\n        {40, 3, 9, A3, W3},\n        {20, 2, 18, A4, W4}\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases][3];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase current_case = test_cases[i];\n\n        // --- Intermediate Value Calculation ---\n        long sum_A = 0;\n        long sum_W = 0;\n        for (int j = 0; j < current_case.m; ++j) {\n            sum_A += current_case.A[j];\n            sum_W += current_case.W[j];\n        }\n\n        long F_free = current_case.F - sum_A;\n\n        // --- L_local Calculation ---\n        int L_local;\n        if (F_free >= current_case.W_new) {\n            L_local = current_case.W_new;\n        } else {\n            L_local = -1;\n        }\n\n        // --- L_global Calculation ---\n        int L_global = current_case.W_new;\n\n        // --- D_global Calculation ---\n        long disruption_long = (long)current_case.W_new + sum_W - current_case.F;\n        int D_global = (disruption_long > 0) ? (int)disruption_long : 0;\n        \n        // Store results\n        results[i][0] = L_local;\n        results[i][1] = L_global;\n        results[i][2] = D_global;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%d,%d,%d]\", results[i][0], results[i][1], results[i][2]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3645334"}]}