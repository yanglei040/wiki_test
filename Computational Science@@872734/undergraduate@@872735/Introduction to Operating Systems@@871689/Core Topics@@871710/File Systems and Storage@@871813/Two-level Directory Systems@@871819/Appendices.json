{"hands_on_practices": [{"introduction": "A two-level directory system's performance is critical, especially as the number of users grows. This exercise models the expected lookup latency by combining concepts of linear search with the probabilistic nature of caching. By deriving a formula for the maximum number of users a system can support under a given latency budget, you'll gain hands-on insight into how caching strategies directly impact system scalability [@problem_id:3689336].", "problem": "Consider a two-level directory system consisting of a single root directory that contains one entry per user and a per-user directory beneath it. To open a user file, the operating system first resolves the user’s directory by searching the root directory, then continues within the user directory (ignore the cost after the root lookup for this problem). Assume that the root directory contains $U$ user entries and that requests target users uniformly at random over these $U$ entries.\n\nThe system employs a cache for root directory entries with an independent cache-hit probability $p$ on each lookup. On a cache hit, the time to locate the user’s directory can be taken as negligible compared to disk access and modeled as $0$. On a cache miss, the system performs a linear scan of the root directory, examining entries sequentially until the target user’s entry is found. Assume that each entry examined on a miss incurs an amortized disk latency of $t_d$ seconds and that there is no overlapping of disk operations. Let $T$ denote the operator’s latency budget for the expected root-lookup time per request.\n\nUsing only first principles about linear search and basic probability, derive an analytic expression for the maximum number of users $U$ such that the expected latency of the root lookup does not exceed $T$. Express your final answer as a closed-form expression in terms of $T$, $p$, and $t_d$. Your final answer must be a single analytic expression with no inequalities.", "solution": "Let $T_{exp}$ be the expected latency of the root lookup. The lookup can result in a cache hit or a cache miss.\n- The probability of a cache hit is given as $p$. The time taken on a hit is negligible, i.e., $0$.\n- The probability of a cache miss is $(1-p)$.\n\nOn a cache miss, the system performs a linear scan of the root directory, which contains $U$ entries. The problem states that requests target users uniformly at random. For a linear search in a list of size $U$, the number of entries examined can be any integer from $1$ to $U$, each with probability $1/U$. The expected number of entries to be examined, $E[\\text{scan}]$, is the average of this sequence:\n$$ E[\\text{scan}] = \\frac{1+2+3+...+U}{U} = \\frac{U(U+1)/2}{U} = \\frac{U+1}{2} $$\n\nThe time taken for each examined entry on a miss is $t_d$. Therefore, the expected time on a cache miss is:\n$$ T_{\\text{miss}} = E[\\text{scan}] \\times t_d = \\frac{U+1}{2} t_d $$\n\nThe total expected latency $T_{exp}$ is the sum of the latencies for each case, weighted by their probabilities:\n$$ T_{exp} = (p \\times 0) + ((1-p) \\times T_{\\text{miss}}) $$\n$$ T_{exp} = (1-p) \\frac{U+1}{2} t_d $$\n\nThe operator's latency budget is $T$. We need to find the maximum number of users $U$ such that the expected latency does not exceed this budget.\n$$ T_{exp} \\le T $$\n$$ (1-p) \\frac{U+1}{2} t_d \\le T $$\n\nNow, we solve for $U$:\n$$ \\frac{U+1}{2} \\le \\frac{T}{(1-p)t_d} $$\n$$ U+1 \\le \\frac{2T}{(1-p)t_d} $$\n$$ U \\le \\frac{2T}{(1-p)t_d} - 1 $$\n\nThe question asks for the maximum number of users $U$, which is the upper bound of this inequality.\n$$ U_{\\text{max}} = \\frac{2T}{(1-p)t_d} - 1 $$\nThis is the closed-form expression for the maximum number of users.", "answer": "$$\n\\boxed{\\frac{2T}{(1-p)t_d} - 1}\n$$", "id": "3689336"}, {"introduction": "Beyond performance, efficient use of disk space is a major concern in file system design. This practice explores the concept of internal fragmentation, which is the space wasted within the last allocated block of a directory. By analyzing how fragmentation changes with the number of entries, you can better understand the trade-offs in file system layout and the factors contributing to storage overhead [@problem_id:3689414].", "problem": "Consider a $2$-level directory system in an Operating System (OS) in which the root directory contains exactly $U$ user entries, and each user directory contains exactly $F$ file entries. Directory contents are stored on disk in fixed-size blocks of size $B$ bytes, and directory entries consist of a variable-length name plus fixed metadata. The variable-length names have an average length of $L$ bytes, and the fixed metadata per entry consumes $s$ bytes, so for estimation purposes the average entry size can be modeled as $L+s$ bytes. All directory entries are packed contiguously with no gaps other than the unused trailing bytes in the last allocated block of each directory. Each directory occupies an integer number of whole blocks.\n\nUsing the fundamental definition that internal fragmentation in a block-based storage object equals the difference between the total allocated capacity and the actual occupied content size, and that the number of blocks allocated to store $S$ bytes of content is $\\lceil S/B \\rceil$, derive from first principles a closed-form analytic expression for the difference between the internal fragmentation of the root directory and the internal fragmentation of a single user directory, expressed purely in terms of $B$, $L$, $s$, $U$, and $F$. Provide the final expression in simplest closed form. No numerical substitution is required, and no rounding is necessary.", "solution": "The problem statement will first be validated against the required criteria.\n\n### Step 1: Extract Givens\n- System type: A $2$-level directory system.\n- Root directory contents: Exactly $U$ user entries.\n- User directory contents: Exactly $F$ file entries per user directory.\n- Storage block size: $B$ bytes.\n- Average directory entry name length: $L$ bytes.\n- Fixed metadata size per entry: $s$ bytes.\n- Average total size of a directory entry (model): $L+s$ bytes.\n- Allocation rule: Each directory occupies an integer number of whole blocks.\n- Definition of internal fragmentation: Total allocated capacity minus the actual occupied content size.\n- Formula for number of blocks to store $S$ bytes: $\\lceil S/B \\rceil$.\n- Objective: Derive a closed-form analytic expression for the difference between the internal fragmentation of the root directory and the internal fragmentation of a single user directory.\n- Expression variables: $B$, $L$, $s$, $U$, and $F$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated for validity.\n- **Scientifically Grounded**: The problem is well-grounded in the fundamental principles of operating system design, specifically file system implementation. The concepts of multi-level directories, block-based storage, and internal fragmentation are standard topics in computer science. The model, while a simplification using average entry size, is a common and valid approach for such an analysis.\n- **Well-Posed**: The problem is well-posed. It provides all necessary variables ($U$, $F$, $B$, $L$, $s$) and explicit definitions for calculating space requirements (contiguous packing) and fragmentation. The goal is clearly stated, and a unique analytical solution can be derived from the given information.\n- **Objective**: The problem is stated in objective, technical language, free from ambiguity or subjective claims.\n\nThe problem does not exhibit any of the flaws listed in the validation checklist. It is scientifically sound, formalizable, complete, and well-structured.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be derived from first principles.\n\n### Derivation of the Solution\n\nLet $\\text{Frag}(S, B)$ denote the internal fragmentation for a data object of size $S$ stored in blocks of size $B$. The problem defines the number of allocated blocks as $N = \\lceil S/B \\rceil$. The total allocated capacity is therefore $N \\times B$. The internal fragmentation is the difference between the allocated capacity and the actual content size.\n\n$$ \\text{Frag}(S, B) = \\left( \\lceil \\frac{S}{B} \\rceil \\times B \\right) - S $$\n\nWe will apply this fundamental formula to both the root directory and a single user directory.\n\n**1. Internal Fragmentation of the Root Directory**\n\nThe root directory contains $U$ user entries. The average size of each entry is given as $L+s$ bytes. As entries are packed contiguously, the total size of the content in the root directory, $S_{\\text{root}}$, is the product of the number of entries and the average size per entry.\n\n$$ S_{\\text{root}} = U (L+s) $$\n\nUsing the general formula for fragmentation, the internal fragmentation of the root directory, $\\text{Frag}_{\\text{root}}$, is:\n\n$$ \\text{Frag}_{\\text{root}} = \\left( \\lceil \\frac{S_{\\text{root}}}{B} \\rceil \\times B \\right) - S_{\\text{root}} $$\n$$ \\text{Frag}_{\\text{root}} = \\left( \\lceil \\frac{U(L+s)}{B} \\rceil \\times B \\right) - U(L+s) $$\n\n**2. Internal Fragmentation of a Single User Directory**\n\nSimilarly, each user directory contains $F$ file entries. The average size of each entry is the same, $L+s$ bytes. The total size of the content in a single user directory, $S_{\\text{user}}$, is:\n\n$$ S_{\\text{user}} = F (L+s) $$\n\nThe internal fragmentation of a single user directory, $\\text{Frag}_{\\text{user}}$, is:\n\n$$ \\text{Frag}_{\\text{user}} = \\left( \\lceil \\frac{S_{\\text{user}}}{B} \\rceil \\times B \\right) - S_{\\text{user}} $$\n$$ \\text{Frag}_{\\text{user}} = \\left( \\lceil \\frac{F(L+s)}{B} \\rceil \\times B \\right) - F(L+s) $$\n\n**3. Difference in Internal Fragmentation**\n\nThe problem requires the derivation of the difference between the internal fragmentation of the root directory and that of a single user directory, which we denote as $\\Delta \\text{Frag}$.\n\n$$ \\Delta \\text{Frag} = \\text{Frag}_{\\text{root}} - \\text{Frag}_{\\text{user}} $$\n\nSubstitute the expressions derived above:\n\n$$ \\Delta \\text{Frag} = \\left[ \\left( \\lceil \\frac{U(L+s)}{B} \\rceil B \\right) - U(L+s) \\right] - \\left[ \\left( \\lceil \\frac{F(L+s)}{B} \\rceil B \\right) - F(L+s) \\right] $$\n\nTo simplify, we group terms with a common factor of $B$ and terms with a common factor of $(L+s)$:\n\n$$ \\Delta \\text{Frag} = \\left( \\lceil \\frac{U(L+s)}{B} \\rceil B - \\lceil \\frac{F(L+s)}{B} \\rceil B \\right) - \\left( U(L+s) - F(L+s) \\right) $$\n\nFactor out the common terms $B$ and $(L+s)$:\n\n$$ \\Delta \\text{Frag} = B \\left( \\lceil \\frac{U(L+s)}{B} \\rceil - \\lceil \\frac{F(L+s)}{B} \\rceil \\right) - (U - F)(L+s) $$\n\nThis expression is the closed-form analytic solution for the difference in internal fragmentation, expressed purely in terms of the given variables $B$, $L$, $s$, $U$, and $F$. No further simplification is possible without imposing additional constraints on the variables. This is the simplest closed form.", "answer": "$$\n\\boxed{B \\left( \\lceil \\frac{U(L+s)}{B} \\rceil - \\lceil \\frac{F(L+s)}{B} \\rceil \\right) - (U-F)(L+s)}\n$$", "id": "3689414"}, {"introduction": "In a multi-user, concurrent operating system, ensuring operations are secure is paramount. A common but dangerous pattern involves checking for a condition and then acting on it, creating a window for security exploits. This thought experiment addresses the \"Time Of Check to Time Of Use\" (TOCTOU) race condition, a classic vulnerability, and challenges you to identify the correct use of atomic operations to guarantee system integrity [@problem_id:3689375].", "problem": "Consider a two-level directory system in which the root directory contains one directory per user. For a user with identifier $U$, denote the user’s directory by $D_U$, and let a file to be created be named $N$. A program $P$ running with the effective user identifier $U$ intends to create $N$ inside $D_U$. In the current implementation, $P$ performs two separate system calls: first it checks whether $N$ exists inside $D_U$ at time $t_1$ (using an existence predicate $E(D_U,N,t_1)$), and then, if the check indicates non-existence, it issues a create call at time $t_2$. Another process $Q$ controlled by an adversary can concurrently modify directory entries in $D_U$ during the interval $(t_1,t_2)$, potentially introducing symbolic links and changing the target of $N$. This raises a Time Of Check to Time Of Use (TOCTOU) vulnerability: $P$’s decision based on $E(D_U,N,t_1)$ may be invalid by the time of use at $t_2$.\n\nAssume the following foundational definitions and facts from operating systems:\n- An operation is atomic if it is executed as a single indivisible action in the kernel, so no other process can observe intermediate states or interleave conflicting updates during the operation.\n- Directory operations are mediated by the kernel’s path resolution and access control. Let $\\mathrm{owner}(D)$ be the owner identifier for directory $D$. Let $\\mathrm{perm}(U, D, \\mathrm{op})$ be a predicate indicating that user $U$ has permission for operation $\\mathrm{op}$ on directory $D$.\n- The existence predicate $E(D,N,t)$ is true if, at time $t$, a directory entry named $N$ exists within directory $D$; it does not by itself distinguish file types (regular files versus symbolic links).\n- Symbolic link traversal can redirect path resolution to a target outside $D_U$, unless explicitly prevented by semantics that do not follow symbolic links for the final path component.\n- The two-level directory invariant requires that every user file path be of the form $/users/U/N$, and that $\\mathrm{owner}(D_U)=U$.\n\nYou are tasked with eliminating the TOCTOU vulnerability by replacing the two-call check-then-create with atomic create semantics and by specifying the necessary kernel-side checks to enforce the two-level directory invariant, avoid symbolic link redirection, and ensure that the existence test and the create action occur as one indivisible operation.\n\nWhich option most completely and correctly specifies atomic create semantics and outlines kernel-side checks that are sufficient to prevent the TOCTOU vulnerability in this two-level directory system?\n\nA. Obtain a directory file descriptor $d$ to $D_U$ by opening $D_U$ with the directory-only flag, then invoke a single atomic create on name $N$ relative to $d$ using flags that create the file only if it does not already exist and prohibit following a symbolic link as the final component. In the kernel, resolve $N$ relative to $d$, verify $\\mathrm{owner}(D_U)=U$ and $\\mathrm{perm}(U,D_U,\\mathrm{create})$, reject if $E(D_U,N,t)$ is true for the instant $t$ of the operation, prevent following a symbolic link for the final component, and perform the insertion of $N$ into $D_U$ under a lock that spans the existence check and insertion, returning an error if the name already exists.\n\nB. Loop in user space: check $E(D_U,N,t)$ via a status call at time $t$, then issue a create if no entry is found; on failure due to concurrent change, retry. In the kernel, rely only on standard Access Control List (ACL) checks and allow symbolic link traversal as usual. This ensures eventual success without needing special atomic semantics.\n\nC. Create a temporary file $T$ in $D_U$ at time $t_1$ and then atomically rename $T$ to $N$ at time $t_2$. In the kernel, allow the rename to overwrite $N$ if it appears concurrently, since the rename is atomic. This avoids an explicit existence check and therefore removes TOCTOU concerns.\n\nD. Use a single create call on the absolute path $/users/U/N$ without exclusive creation flags. After the call returns, check the returned file descriptor’s metadata to ensure it belongs to $D_U$. In the kernel, permit following symbolic links in the final component and depend on the post hoc verification to catch misdirection.\n\nSelect the best option.", "solution": "The user has requested a rigorous analysis of a problem concerning a Time Of Check to Time Of Use (TOCTOU) vulnerability in a two-level directory system. The task involves validating the problem statement and, if valid, deriving the correct solution and evaluating the given options.\n\n### Problem Validation\n\nFirst, a critical validation of the problem statement is performed.\n\n#### Step 1: Extract Givens\n\nThe problem statement provides the following information:\n- **System**: A two-level directory system. The root directory contains one directory per user.\n- **Entities**:\n    - User identifier: $U$\n    - User's directory: $D_U$ (located under the root, e.g., `/users/U`)\n    - File to be created: $N$\n    - A program $P$ running with effective user identifier $U$.\n    - An adversarial process $Q$.\n- **Vulnerable Procedure**:\n    - At time $t_1$, program $P$ checks for the existence of $N$ in $D_U$ using a predicate $E(D_U,N,t_1)$.\n    - If the check indicates non-existence, $P$ issues a create call for $N$ at time $t_2 > t_1$.\n- **Adversary Action**: Process $Q$ can modify directory entries in $D_U$ during the time interval $(t_1, t_2)$.\n- **Vulnerability**: Time Of Check to Time Of Use (TOCTOU).\n- **Foundational Definitions and Facts**:\n    - **Atomic Operation**: An operation executed as a single indivisible action in the kernel.\n    - **Access Control**: Directory operations are mediated by the kernel.\n    - $\\mathrm{owner}(D)$: A function returning the owner identifier for directory $D$.\n    - $\\mathrm{perm}(U, D, \\mathrm{op})$: A predicate, true if user $U$ has permission for operation $\\mathrm{op}$ on directory $D$.\n    - $E(D,N,t)$: A predicate, true if an entry named $N$ exists in directory $D$ at time $t$. It does not distinguish file types.\n    - **Symbolic Links**: Symbolic link traversal can redirect path resolution, unless prevented.\n    - **System Invariant**: All user file paths are of the form `/users/U/N`, and $\\mathrm{owner}(D_U)=U$.\n- **Task**: To eliminate the TOCTOU vulnerability by replacing the two-step procedure with an atomic one, specifying necessary kernel-side checks to enforce the invariant, prevent symbolic link redirection, and combine the existence test and creation into one indivisible operation.\n\n#### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded (Critical)**: The problem describes the TOCTOU race condition, a classic and fundamental vulnerability in computer security, specifically within the context of operating system file management. The concepts of atomic operations, permissions, symbolic links, and directory structures are all standard and well-established in the field of operating systems. The scenario is a canonical example used to teach secure programming practices. The problem is scientifically sound.\n- **Well-Posed**: The problem is well-posed. It clearly defines the initial insecure state and the desired secure state. The goal is to identify the set of mechanisms that correctly and completely achieves this secure state. A definite solution, based on established OS design principles, exists.\n- **Objective (Critical)**: The problem is stated using formal and objective language (e.g., $U, D_U, N, t_1, t_2, E(D,N,t)$). The descriptions of system behavior are technical and free of subjectivity or opinion.\n- **Other Flaws**: The problem statement is self-contained, consistent, and provides sufficient information to reason about the solution. It does not suffer from any of the listed invalidity criteria.\n\n#### Step 3: Verdict and Action\nThe problem statement is **valid**. The analysis can proceed.\n\n### Solution Derivation\n\nThe core of the TOCTOU vulnerability is the time gap between the check (at $t_1$) and the use (at $t_2$). During this interval $(t_1,t_2)$, an adversary can alter the state of the filesystem, invalidating the premise upon which the \"use\" operation is based.\n\nIn this specific scenario, the \"check\" is $E(D_U,N,t_1)$ being false, and the \"use\" is the creation of file $N$ at $t_2$. An adversary could, for instance:\n1.  Create a regular file named $N$. The subsequent create call by $P$ might fail or overwrite it, depending on the flags used.\n2.  Create a symbolic link named $N$ pointing to a sensitive file, for example, a system configuration file or another file owned by user $U$ that $P$ has permission to write to. If the `create` operation at $t_2$ follows symbolic links and has overwrite semantics (e.g., `open(path, O_WRONLY | O_TRUNC)`), program $P$ could inadvertently destroy the target of the link.\n\nTo eliminate this vulnerability, the check and the use must be combined into a single, **atomic** operation performed by the kernel. The properties of this atomic operation must be:\n1.  **Atomicity**: The check for the existence of $N$ and its creation if it does not exist must be indivisible. This is typically implemented within the kernel using locks on the parent directory ($D_U$) data structures.\n2.  **Exclusivity**: The operation must fail if the entry $N$ already exists. This directly implements the \"if non-existent, then create\" logic and thwarts the race where the adversary creates a file with the same name. In POSIX systems, this semantic is provided by the `O_EXCL` flag in conjunction with `O_CREAT` for the `open()` system call.\n3.  **Symbolic Link Protection**: The operation must not follow a symbolic link if one exists at the final component of the path (i.e., at $N$). This prevents the attack where the operation is redirected to an unintended location. In POSIX, this is achieved with the `O_NOFOLLOW` flag.\n4.  **Stable Directory Reference**: To prevent race conditions on the path to the directory $D_U$ itself (e.g., the adversary replaces `/users/U` with a symbolic link), it is best practice to first obtain a stable handle to the directory $D_U$ (a file descriptor) and then perform the file creation relative to that handle. POSIX provides `openat()` for this purpose. Opening the directory should verify that it is indeed a directory (e.g., using the `O_DIRECTORY` flag).\n5.  **Invariant and Permission Enforcement**: Within the single atomic kernel operation, all necessary checks must still be performed. This includes verifying that the user $U$ has creation permissions on the directory $D_U$ (i.e., $\\mathrm{perm}(U,D_U,\\mathrm{create})$) and that any system-specific invariants, such as $\\mathrm{owner}(D_U)=U$, hold.\n\nA complete and correct solution must embody all these principles.\n\n### Option-by-Option Analysis\n\nNow, we evaluate each option against this derived set of requirements.\n\n**A. Obtain a directory file descriptor $d$ to $D_U$ by opening $D_U$ with the directory-only flag, then invoke a single atomic create on name $N$ relative to $d$ using flags that create the file only if it does not already exist and prohibit following a symbolic link as the final component. In the kernel, resolve $N$ relative to $d$, verify $\\mathrm{owner}(D_U)=U$ and $\\mathrm{perm}(U,D_U,\\mathrm{create})$, reject if $E(D_U,N,t)$ is true for the instant $t$ of the operation, prevent following a symbolic link for the final component, and perform the insertion of $N$ into $D_U$ under a lock that spans the existence check and insertion, returning an error if the name already exists.**\n\nThis option comprehensively addresses all requirements.\n- It uses a stable directory file descriptor $d$, preventing races on the path to $D_U$.\n- It uses a single atomic create call relative to $d$.\n- It specifies exclusive creation (\"create the file only if it does not already exist\").\n- It specifies protection against symbolic link attacks (\"prohibit following a symbolic link as the final component\").\n- It correctly outlines the kernel-side implementation: verifying ownership ($\\mathrm{owner}(D_U)=U$) and permissions ($\\mathrm{perm}(U,D_U,\\mathrm{create})$), executing the existence check and creation under a lock (ensuring atomicity), and returning an error on pre-existence.\nThis option perfectly matches the derived solution.\n**Verdict: Correct**\n\n**B. Loop in user space: check $E(D_U,N,t)$ via a status call at time $t$, then issue a create if no entry is found; on failure due to concurrent change, retry. In the kernel, rely only on standard Access Control List (ACL) checks and allow symbolic link traversal as usual. This ensures eventual success without needing special atomic semantics.**\n\nThis option fails to solve the problem.\n- It explicitly preserves the non-atomic check-then-act sequence in a loop. The window of vulnerability exists in every single iteration.\n- It does not \"eliminate\" the vulnerability, but rather suggests a recovery strategy that may lead to livelock if the adversary is persistent.\n- Critically, it states to \"allow symbolic link traversal as usual,\" which leaves the most dangerous attack vector wide open. An `open()` call with write/truncate flags would still follow a malicious link and damage the target file.\n**Verdict: Incorrect**\n\n**C. Create a temporary file $T$ in $D_U$ at time $t_1$ and then atomically rename $T$ to $N$ at time $t_2$. In the kernel, allow the rename to overwrite $N$ if it appears concurrently, since the rename is atomic. This avoids an explicit existence check and therefore removes TOCTOU concerns.**\n\nThis option uses an atomic operation (`rename`), which is a valid pattern for some atomic updates. However, it is flawed in this context.\n- The original logic is \"if non-existent, then create\". This option changes the semantics to \"atomically replace whatever is at $N$\". Standard `rename` semantics dictate that if the destination ($N$) exists, it is unlinked (overwritten). This is a different behavior from exclusive creation. If the adversary creates a legitimate file $N$, this process would destroy it, which was not the original intent.\n- While `rename` typically does not follow a symbolic link at its destination (it replaces the link itself), the proposed logic (\"allow the rename to overwrite $N$\") does not match the problem's requirement of creating a file *only if one does not already exist*. It trades one problem (TOCTOU) for another (unconditional overwrite).\n**Verdict: Incorrect**\n\n**D. Use a single create call on the absolute path $/users/U/N$ without exclusive creation flags. After the call returns, check the returned file descriptor’s metadata to ensure it belongs to $D_U$. In the kernel, permit following symbolic links in the final component and depend on the post hoc verification to catch misdirection.**\n\nThis option is fundamentally insecure and demonstrates a misunderstanding of the TOCTOU problem.\n- Performing a check *after* the operation (\"post hoc verification\") is known as a Time Of Use to Time Of Check (TOUTOC) vulnerability. The damaging operation may have already completed. For example, if the `create` call was an `open()` with a flag to truncate the file (`O_TRUNC`), the target of a malicious symbolic link would be emptied *before* the check could ever be performed.\n- It explicitly allows the vulnerability by \"permit[ting] following symbolic links in the final component\".\n- It does not use exclusive creation flags, meaning it would happily open a file or link planted by the adversary.\n**Verdict: Incorrect**", "answer": "$$\\boxed{A}$$", "id": "3689375"}]}