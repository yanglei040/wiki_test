{"hands_on_practices": [{"introduction": "One of the most robust ways to handle deadlocks is to prevent them from ever occurring by breaking one of the four necessary Coffman conditions. This practice [@problem_id:3658940] challenges you to apply the deadlock prevention technique of imposing a strict total order on resources. You will frame this as a constraint satisfaction problem to find an optimal resource hierarchy that minimizes deviation from the processes' original intended behavior, providing insight into the practical trade-offs of deadlock prevention.", "problem": "An operating system schedules three concurrent processes $\\{P_1, P_2, P_3\\}$ that each acquire a subset of non-preemptible resources $\\{A, B, C, D\\}$. A deadlock can occur if and only if the waits-for graph contains a cycle, and one well-tested method to prevent deadlock is to impose a strict total order on resources and require that every process request resources in an order that is monotonically nondecreasing with respect to that total order. This eliminates circular wait by ensuring there is no directed cycle.\n\nEach process has an original preferred acquisition sequence (a linear order of the resources it will acquire, with no repeats):\n- $P_1$: $A \\rightarrow B \\rightarrow C$\n- $P_2$: $B \\rightarrow D \\rightarrow A$\n- $P_3$: $C \\rightarrow A \\rightarrow D$\n\nYou must formulate this as a constraint satisfaction problem where the decision variables are the per-process acquisition orders that the operating system will enforce. The constraints must ensure that the enforced orders are monotonically nondecreasing with respect to a single strict total order on $\\{A, B, C, D\\}$ so that the waits-for graph is acyclic. The deviation of an enforced order from a process’s original sequence is measured by the number of adjacent swaps required to transform the original sequence into the enforced sequence (this is the Kendall tau distance restricted to the resources in that process’s sequence). The total deviation is the sum of these distances over $P_1, P_2, P_3$.\n\nAmong all satisfying assignments of acquisition orders that obey a single strict total resource order (thereby preventing deadlock), determine the minimal possible total deviation. Report your answer as a single integer. No rounding is necessary. Your final answer must be a single integer.", "solution": "The problem asks for the minimum possible total deviation between the original preferred resource acquisition sequences for three processes and their enforced sequences, subject to the constraint that all enforced sequences must conform to a single strict total order on the set of resources $\\{A, B, C, D\\}$. This constraint is a standard method for deadlock prevention.\n\nLet the set of resources be $R = \\{A, B, C, D\\}$. A strict total order on $R$ is a permutation $\\pi$ of these four resources. There are $4! = 24$ such possible orders. For any given total order $\\pi$, each process $P_i$ must acquire its required resources in an order that is a subsequence of $\\pi$. This determines a unique enforced acquisition sequence for each process.\n\nLet $S_1, S_2, S_3$ be the original preferred acquisition sequences:\n- $S_1: A \\rightarrow B \\rightarrow C$\n- $S_2: B \\rightarrow D \\rightarrow A$\n- $S_3: C \\rightarrow A \\rightarrow D$\n\nLet $\\pi$ be a chosen strict total order on $R$. For each process $P_i$, let $R_i \\subseteq R$ be the set of resources it uses. The enforced sequence for $P_i$, denoted $S_i'(\\pi)$, is the permutation of resources in $R_i$ obtained by sorting them according to $\\pi$.\n\nThe deviation for a single process $P_i$ is defined as the number of adjacent swaps needed to transform the original sequence $S_i$ into the enforced sequence $S_i'(\\pi)$. This is equivalent to the number of inversions, or the Kendall tau distance, between the two permutations of the resource set $R_i$. The distance is the number of pairs of resources whose relative order is different in $S_i$ and $S_i'(\\pi)$.\n\nThe total deviation for a given total order $\\pi$ is the sum of the deviations for each process:\n$$ D(\\pi) = \\sum_{i=1}^{3} d_K(S_i, S_i'(\\pi)) $$\nwhere $d_K$ denotes the Kendall tau distance.\n\nThe objective is to find $\\min_{\\pi} D(\\pi)$.\n\nThe total deviation can be decomposed by considering each pair of resources $\\{X, Y\\} \\subseteq R$. The total deviation is the sum of disagreements over all pairs of resources across all three processes.\n$$ D(\\pi) = \\sum_{\\{X, Y\\} \\subseteq R, X \\neq Y} \\text{cost}(\\{X, Y\\}|\\pi) $$\nThe cost for a single pair $\\{X, Y\\}$ given a total order $\\pi$ is the number of processes whose original request order for this pair is inverted by $\\pi$.\nLet $N(X \\prec Y)$ be the number of processes $P_i$ such that $X$ is requested before $Y$ in the original sequence $S_i$. If the total order specifies $X \\prec_{\\pi} Y$, then the cost contributed by this pair is $N(Y \\prec X)$. Conversely, if $Y \\prec_{\\pi} X$, the cost is $N(X \\prec Y)$.\nThe minimum possible cost for the pair $\\{X, Y\\}$ is therefore $\\min(N(X \\prec Y), N(Y \\prec X))$.\n\nThe minimum total deviation is the sum of these minimum pair costs, provided that the set of pairwise orderings that achieve these minima is consistent (i.e., transitive and contains no cycles). If the preferences are consistent, a total order $\\pi$ exists that respects all of them.\n\nLet's compute the counts $N(X \\prec Y)$ for all $\\binom{4}{2} = 6$ pairs of resources based on the original sequences:\n- $S_1 = (A, B, C)$: gives preferences $A \\prec B$, $A \\prec C$, $B \\prec C$.\n- $S_2 = (B, D, A)$: gives preferences $B \\prec D$, $B \\prec A$, $D \\prec A$.\n- $S_3 = (C, A, D)$: gives preferences $C \\prec A$, $C \\prec D$, $A \\prec D$.\n\nNow, we tabulate the counts and determine the minimum cost for each pair:\n\n1.  **Pair $\\{A, B\\}$**:\n    - $P_1$ prefers $A \\prec B$.\n    - $P_2$ prefers $B \\prec A$.\n    - $P_3$ does not use $B$.\n    - So, $N(A \\prec B) = 1$ and $N(B \\prec A) = 1$.\n    - Minimum cost for $\\{A, B\\}$ is $\\min(1, 1) = 1$. This cost is incurred regardless of whether we choose $A \\prec_{\\pi} B$ or $B \\prec_{\\pi} A$.\n\n2.  **Pair $\\{A, C\\}$**:\n    - $P_1$ prefers $A \\prec C$.\n    - $P_3$ prefers $C \\prec A$.\n    - $P_2$ does not use $C$.\n    - So, $N(A \\prec C) = 1$ and $N(C \\prec A) = 1$.\n    - Minimum cost for $\\{A, C\\}$ is $\\min(1, 1) = 1$. This cost is unavoidable.\n\n3.  **Pair $\\{A, D\\}$**:\n    - $P_3$ prefers $A \\prec D$.\n    - $P_2$ prefers $D \\prec A$.\n    - $P_1$ does not use $D$.\n    - So, $N(A \\prec D) = 1$ and $N(D \\prec A) = 1$.\n    - Minimum cost for $\\{A, D\\}$ is $\\min(1, 1) = 1$. This cost is unavoidable.\n\n4.  **Pair $\\{B, C\\}$**:\n    - $P_1$ prefers $B \\prec C$.\n    - $P_2$ does not use $C$. $P_3$ does not use $B$.\n    - So, $N(B \\prec C) = 1$ and $N(C \\prec B) = 0$.\n    - Minimum cost for $\\{B, C\\}$ is $\\min(1, 0) = 0$. This minimum is achieved by choosing the ordering $B \\prec_{\\pi} C$.\n\n5.  **Pair $\\{B, D\\}$**:\n    - $P_2$ prefers $B \\prec D$.\n    - $P_1$ does not use $D$. $P_3$ does not use $B$.\n    - So, $N(B \\prec D) = 1$ and $N(D \\prec B) = 0$.\n    - Minimum cost for $\\{B, D\\}$ is $\\min(1, 0) = 0$. This minimum is achieved by choosing the ordering $B \\prec_{\\pi} D$.\n\n6.  **Pair $\\{C, D\\}$**:\n    - $P_3$ prefers $C \\prec D$.\n    - $P_1$ does not use $D$. $P_2$ does not use $C$.\n    - So, $N(C \\prec D) = 1$ and $N(D \\prec C) = 0$.\n    - Minimum cost for $\\{C, D\\}$ is $\\min(1, 0) = 0$. This minimum is achieved by choosing the ordering $C \\prec_{\\pi} D$.\n\nTo achieve the overall minimum total deviation, we must select the pairwise orderings that yield the minimum costs. This requires our total order $\\pi$ to satisfy:\n- $B \\prec_{\\pi} C$\n- $B \\prec_{\\pi} D$\n- $C \\prec_{\\pi} D$\n\nLet's check if these constraints are consistent. The constraints $B \\prec_{\\pi} C$ and $C \\prec_{\\pi} D$ imply $B \\prec_{\\pi} D$ by transitivity. This is consistent with the third constraint. So, there is no cycle in these preferred orderings. We can construct a total order $\\pi$ that satisfies all three, for instance, any ordering where the relative order of $B, C, D$ is $B \\rightarrow C \\rightarrow D$. An example is $\\pi = (A, B, C, D)$.\n\nThe minimal total deviation is the sum of the minimum costs for each pair:\n$$ D_{min} = \\underbrace{1}_{\\{A,B\\}} + \\underbrace{1}_{\\{A,C\\}} + \\underbrace{1}_{\\{A,D\\}} + \\underbrace{0}_{\\{B,C\\}} + \\underbrace{0}_{\\{B,D\\}} + \\underbrace{0}_{\\{C,D\\}} = 3 $$\n\nLet's verify this with a specific total order satisfying the conditions, for example $\\pi = (B, A, C, D)$. This order satisfies $B \\prec C$ and $B \\prec D$ and $C \\prec D$.\n- $P_1$ (uses $\\{A,B,C\\}$), original $A \\rightarrow B \\rightarrow C$. Enforced $S_1'(\\pi): B \\rightarrow A \\rightarrow C$.\n  - Pairs $(A,B)$, $(A,C)$, $(B,C)$: Original has $A \\prec B$. Enforced has $B \\prec A$. $1$ inversion. Deviation = $1$.\n- $P_2$ (uses $\\{A,B,D\\}$), original $B \\rightarrow D \\rightarrow A$. Enforced $S_2'(\\pi): B \\rightarrow A \\rightarrow D$.\n  - Pairs $(B,D)$, $(B,A)$, $(D,A)$: Original has $D \\prec A$. Enforced has $A \\prec D$. $1$ inversion. Deviation = $1$.\n- $P_3$ (uses $\\{A,C,D\\}$), original $C \\rightarrow A \\rightarrow D$. Enforced $S_3'(\\pi): A \\rightarrow C \\rightarrow D$.\n  - Pairs $(C,A)$, $(C,D)$, $(A,D)$: Original has $C \\prec A$. Enforced has $A \\prec C$. $1$ inversion. Deviation = $1$.\nThe total deviation is $1 + 1 + 1 = 3$.\n\nThe analysis confirms that the minimal possible total deviation is $3$. Any total order $\\pi$ where the resources $B,C,D$ appear in the sequence $B \\rightarrow C \\rightarrow D$ will yield this minimal deviation.", "answer": "$$\\boxed{3}$$", "id": "3658940"}, {"introduction": "Moving from prevention to the more dynamic strategy of avoidance, we encounter algorithms that check the safety of each resource allocation before granting it. In this exercise [@problem_id:3658926], you will step into the role of the operating system and apply the classic Banker's Algorithm to a resource allocation scenario. This hands-on calculation will solidify your understanding of how an OS can make intelligent decisions to stay in a \"safe state,\" thereby avoiding potential deadlocks.", "problem": "In a conservative resource-allocation variant of the dining philosophers problem, all forks are treated as a single pool of identical resources. There are $n=4$ philosophers $\\{P_1,P_2,P_3,P_4\\}$ and a pool of $F=9$ identical forks. Each philosopher $P_i$ declares a maximum outstanding claim of $M_i$ forks, but to complete a meal a philosopher requires at most $2$ forks at once. However, the operating system enforces safety by the Banker's algorithm, which must conservatively assume that each $P_i$ may request up to its declared maximum $M_i$ before releasing any forks. Thus the safety check is performed against the declared maxima.\n\nThe current allocation vector (forks currently held) is $A=(2,2,2,1)$, and the declared maximum vector is $M=(5,6,5,x)$, where $x$ is a positive integer and must satisfy $1 \\le x \\le F$ to be a valid declaration. The system state is represented by $(F,M,A)$ and is considered safe if there exists an ordering of the philosophers in which, starting from the currently available forks, each philosopher can be allocated up to its remaining declared need and then complete (releasing all its allocated forks), never exceeding the available forks at any step.\n\nStarting only from the core definitions of deadlock and the safety test underlying the Banker's algorithm (without assuming any specialized shortcuts), determine the largest integer value of $x$ for which the current state $(F,M,A)$ is safe under the Banker's algorithm. Provide your final answer as a single integer.", "solution": "The problem requires determining the largest integer value of a variable $x$ that keeps a resource-allocation system in a safe state, according to the Banker's algorithm. A state is defined as safe if there exists a sequence of processes (philosophers, in this case) that can all complete their execution.\n\nFirst, we formalize the state of the system based on the provided data.\nThe number of processes (philosophers) is $n=4$.\nThe total number of identical resources (forks) is $F=9$.\n\nThe state of the system is defined by three vectors:\n1.  The maximum resource claim for each philosopher, $M$.\n2.  The current allocation of resources to each philosopher, $A$.\n3.  The number of available resources in the system, $V$.\n\nThe givens are:\nThe maximum claim vector is $M = (M_1, M_2, M_3, M_4) = (5, 6, 5, x)$.\nThe current allocation vector is $A = (A_1, A_2, A_3, A_4) = (2, 2, 2, 1)$.\n\nFrom these, we can calculate the total number of allocated resources:\n$$ \\sum_{i=1}^{n} A_i = 2 + 2 + 2 + 1 = 7 $$\nThe number of currently available resources, $V$, is the total number of resources minus the total allocated resources:\n$$ V = F - \\sum_{i=1}^{n} A_i = 9 - 7 = 2 $$\n\nNext, we calculate the `Need` vector, $N$. The `Need` for each philosopher $P_i$ is the maximum number of additional resources it might request to complete its task. It is calculated as the difference between its maximum claim and its current allocation: $N_i = M_i - A_i$.\n$$ N = M - A = (5-2, 6-2, 5-2, x-1) = (3, 4, 3, x-1) $$\n\nThe safety algorithm determines if the current state is safe. The algorithm works as follows:\n1.  Initialize a `Work` vector (in this case, a scalar since there is only one resource type) to the value of `Available` resources. Let $W = V = 2$.\n2.  Initialize a boolean vector `Finish` of length $n$, with all elements set to `false`. $Finish = (\\text{false}, \\text{false}, \\text{false}, \\text{false})$.\n3.  Search for a philosopher $P_i$ such that both of the following conditions are met:\n    a. $Finish_i$ is `false`.\n    b. $N_i \\le W$.\n4.  If such a philosopher $P_i$ exists, we assume it can complete. We update the state by virtually releasing its resources:\n    a. $W \\leftarrow W + A_i$.\n    b. $Finish_i \\leftarrow \\text{true}$.\n    c. Go back to step 3.\n5.  If no such philosopher can be found in step 3, the algorithm terminates.\n6.  The initial state is considered safe if and only if the algorithm terminates with all elements of the `Finish` vector being `true`.\n\nWe will now apply this algorithm to the given system state to find the constraint on $x$.\nInitial state of the safety check:\n$W = 2$\n$N = (3, 4, 3, x-1)$\n$A = (2, 2, 2, 1)$\n$Finish = (\\text{false}, \\text{false}, \\text{false}, \\text{false})$\n\nIn the first pass of step 3, we look for a philosopher $P_i$ where $N_i \\le W = 2$ and $Finish_i$ is `false`.\n- For $P_1$: $N_1 = 3$. Is $3 \\le 2$? No.\n- For $P_2$: $N_2 = 4$. Is $4 \\le 2$? No.\n- For $P_3$: $N_3 = 3$. Is $3 \\le 2$? No.\n- For $P_4$: $N_4 = x-1$. We need to check if $x-1 \\le 2$.\n\nFor the safety algorithm to proceed beyond the first step, there must be at least one philosopher that can be satisfied with the currently available resources. From the analysis above, philosophers $P_1$, $P_2$, and $P_3$ cannot be chosen. Therefore, the algorithm can only start if philosopher $P_4$ can be chosen. This imposes a necessary condition on $x$:\n$$ N_4 \\le W \\implies x-1 \\le 2 \\implies x \\le 3 $$\nThe problem states that $x$ is a positive integer, so $x \\ge 1$. This implies that any value of $x  3$ will result in an unsafe state, because the safety algorithm would halt at the very first step with no process being able to proceed.\n\nTo find the largest integer value of $x$ for which the state is safe, we must test the maximum possible value, $x=3$. If $x=3$ yields a safe state, it will be our answer.\n\nLet's test for $x=3$:\nThe `Need` vector becomes $N = (3, 4, 3, 3-1) = (3, 4, 3, 2)$.\nInitial state: $W=2$, $Finish=(\\text{false}, \\text{false}, \\text{false}, \\text{false})$.\n\n- **Pass 1:** We search for $P_i$ with $N_i \\le W=2$. As determined before, only $P_4$ satisfies this, with $N_4=2$. We select $P_4$.\n  - Update $W \\leftarrow W + A_4 = 2 + 1 = 3$.\n  - Update $Finish \\leftarrow (\\text{false}, \\text{false}, \\text{false}, \\text{true})$.\n  - A possible safe sequence starts with $\\langle P_4 \\rangle$.\n\n- **Pass 2:** We search for $P_i$ with $Finish_i=\\text{false}$ and $N_i \\le W=3$.\n  - For $P_1$: $N_1 = 3$. Is $3 \\le 3$? Yes.\n  - For $P_2$: $N_2 = 4$. Is $4 \\le 3$? No.\n  - For $P_3$: $N_3 = 3$. Is $3 \\le 3$? Yes.\n  - We can choose either $P_1$ or $P_3$. Let's select $P_1$.\n  - Update $W \\leftarrow W + A_1 = 3 + 2 = 5$.\n  - Update $Finish \\leftarrow (\\text{true}, \\text{false}, \\text{false}, \\text{true})$.\n  - The sequence is now $\\langle P_4, P_1 \\rangle$.\n\n- **Pass 3:** We search for $P_i$ with $Finish_i=\\text{false}$ and $N_i \\le W=5$.\n  - For $P_2$: $N_2 = 4$. Is $4 \\le 5$? Yes.\n  - For $P_3$: $N_3 = 3$. Is $3 \\le 5$? Yes.\n  - We can choose either $P_2$ or $P_3$. Let's select $P_3$.\n  - Update $W \\leftarrow W + A_3 = 5 + 2 = 7$.\n  - Update $Finish \\leftarrow (\\text{true}, \\text{false}, \\text{true}, \\text{true})$.\n  - The sequence is now $\\langle P_4, P_1, P_3 \\rangle$.\n\n- **Pass 4:** We search for $P_i$ with $Finish_i=\\text{false}$ and $N_i \\le W=7$.\n  - Only $P_2$ remains. $N_2=4$. Is $4 \\le 7$? Yes.\n  - We select $P_2$.\n  - Update $W \\leftarrow W + A_2 = 7 + 2 = 9$.\n  - Update $Finish \\leftarrow (\\text{true}, \\text{true}, \\text{true}, \\text{true})$.\n  - The sequence is now $\\langle P_4, P_1, P_3, P_2 \\rangle$.\n\n- **Pass 5:** All elements of the `Finish` vector are now `true`. The algorithm terminates successfully.\n\nSince a safe sequence $\\langle P_4, P_1, P_3, P_2 \\rangle$ exists for $x=3$, the state is safe for this value. We have already established that for any integer $x3$, the state is unsafe. Therefore, the largest integer value of $x$ for which the state is safe is $3$.", "answer": "$$\\boxed{3}$$", "id": "3658926"}, {"introduction": "When deadlocks are allowed to occur, the operating system must be able to detect and resolve them. This problem [@problem_id:3658954] delves into the practical consequences of a deadlock, contrasting the high CPU waste of spinlocks with the efficiency of sleeping locks in such a state. You will also analyze different detection strategies, learning to distinguish between naive heuristics and the robust, graph-based methods used in real systems.", "problem": "Consider an Operating System (OS) running on a Symmetric Multiprocessing system with $m=2$ cores. The OS provides two kinds of locks: spinlocks and sleeping locks. A spinlock causes a thread to busy-wait in a loop, repeatedly testing a shared variable using atomic operations until the lock becomes available; a sleeping lock causes a thread to block and yield the Central Processing Unit (CPU), letting the scheduler run other threads. Two threads $T_1$ and $T_2$ contend for two spinlocks $L_1$ and $L_2$ as follows: thread $T_1$ acquires $L_1$ and then attempts to acquire $L_2$, while thread $T_2$ acquires $L_2$ and then attempts to acquire $L_1$. Neither thread releases its first lock while waiting for the second. The system supports tracking of lock ownership and waiters. The target is to reason from fundamental definitions of deadlock and resource waiting to analyze CPU waste due to spinning under deadlock and to propose a principled deadlock detection method that can be invoked from within spin loops.\n\nBase definitions: a deadlock exists when a nonempty set of threads are each waiting for an event that only another thread in the set can cause, which in the context of locks corresponds to cycles in a Wait-For Graph (WFG). The Coffman conditions for deadlock are mutual exclusion, hold-and-wait, no preemption, and circular wait. Throughput is the rate of completed critical sections per unit time; while a thread spins, it consumes CPU cycles even if it does not make progress on its critical section.\n\nWhich of the following statements are correct in this scenario?\n\nA. With $m=2$ cores, if $T_1$ and $T_2$ deadlock while spinning on $L_1$ and $L_2$, the system’s aggregate CPU utilization can reach approximately $100\\%$ while throughput remains $0$, because both cores execute busy-wait loops that do not complete any work.\n\nB. If $L_1$ and $L_2$ were implemented as sleeping locks instead of spinlocks, a deadlock could still occur between $T_1$ and $T_2$, but the scheduler would deschedule the blocked threads, reducing CPU waste without increasing throughput.\n\nC. A correct deadlock detection policy inside a spin loop can be based solely on a fixed timeout $t$; if a thread spins longer than $t$, the OS may safely conclude a deadlock and forcibly preempt the lock holder to break the cycle.\n\nD. A principled deadlock detection method for spinning threads is to periodically build a Wait-For Graph (WFG) of threads and locks from kernel-maintained ownership and waiter metadata and check for cycles; upon detecting a cycle, the OS can invoke a resolution policy such as aborting one acquisition attempt or rolling back one thread, thereby breaking circular wait.\n\nE. Spinlocks are always preferable to sleeping locks on single-processor systems because they eliminate context switch overhead and therefore cannot deadlock.", "solution": "The problem statement is analyzed and found to be valid. It is scientifically grounded in the principles of operating systems, specifically concurrency and deadlock. The scenario is well-posed, unambiguous, and free of contradictions. It presents a classic deadlock case that is suitable for rigorous analysis.\n\nThe core of the problem describes a deadlock situation involving two threads, $T_1$ and $T_2$, and two spinlocks, $L_1$ and $L_2$, on a symmetric multiprocessing system with $m=2$ cores. The sequence of lock acquisitions creates a circular dependency:\n1. Thread $T_1$ acquires lock $L_1$.\n2. Thread $T_2$ acquires lock $L_2$.\n3. Thread $T_1$ attempts to acquire $L_2$, which is held by $T_2$. $T_1$ begins to spin-wait.\n4. Thread $T_2$ attempts to acquire $L_1$, which is held by $T_1$. $T_2$ begins to spin-wait.\n\nThis situation satisfies the four necessary Coffman conditions for deadlock:\n1.  **Mutual Exclusion**: The locks $L_1$ and $L_2$ are exclusive resources.\n2.  **Hold-and-Wait**: $T_1$ holds $L_1$ while waiting for $L_2$, and $T_2$ holds $L_2$ while waiting for $L_1$.\n3.  **No Preemption**: The problem states that neither thread releases its first lock while waiting, meaning the locks cannot be preempted.\n4.  **Circular Wait**: A circular chain of waiting exists: $T_1 \\to L_2 \\to T_2 \\to L_1 \\to T_1$.\n\nGiven this deadlock, $T_1$ and $T_2$ are scheduled on the two available cores. $T_1$ executes a busy-wait loop on one core, and $T_2$ executes a busy-wait loop on the other. Neither thread can make progress.\n\n**Analysis of Option A:**\nThe statement suggests that with $m=2$ cores, the deadlocked threads $T_1$ and $T_2$ will lead to approximately $100\\%$ CPU utilization and $0$ throughput.\nIn the described deadlock, $T_1$ is executing a spin-wait loop on one core, and $T_2$ is executing a spin-wait loop on the second core. A thread in a spin-wait loop is actively executing instructions, thus keeping the CPU core it is running on fully occupied. Since both cores of the $m=2$ system are occupied by spinning threads, the aggregate CPU utilization will be $((100\\% + 100\\%) / 2) = 100\\%$. Throughput is defined as the rate of completed critical sections. Since both threads are stuck in a deadlock, neither can complete its sequence of operations. Therefore, the throughput of useful work is $0$. The reasoning provided in the statement is also sound: the cores are busy, but with non-productive work.\nVerdict: **Correct**.\n\n**Analysis of Option B:**\nThis statement considers a hypothetical scenario where the spinlocks $L_1$ and $L_2$ are replaced with sleeping locks.\nThe underlying logic for deadlock remains unchanged; the four Coffman conditions are still met. Thus, a deadlock would still occur. The difference lies in the waiting mechanism. A sleeping lock causes a thread to block and be moved by the scheduler from a `RUNNING` state to a `WAITING` or `BLOCKED` state. A blocked thread does not consume CPU cycles. Therefore, when $T_1$ and $T_2$ attempt to acquire the second lock, they will both be descheduled. This frees up the CPU cores to execute other ready threads or to enter an idle state if no other threads are ready. This directly reduces CPU waste compared to the spinlock scenario. However, the deadlock condition persists, so neither thread makes progress, and the throughput remains $0$.\nVerdict: **Correct**.\n\n**Analysis of Option C:**\nThis statement proposes a deadlock detection policy based on a fixed timeout, $t$, and a recovery action of forcibly preempting the lock holder.\nUsing a timeout to infer a deadlock is a heuristic, not a definitive method. A thread might spin for a long time not because of a deadlock, but because of high contention or because the lock holder is executing a legitimate, long-running critical section. Therefore, one cannot \"safely conclude a deadlock\" based solely on a timeout; this can lead to false positives. Furthermore, \"forcibly preempting the lock holder\" is an extremely unsafe operation. The lock holder may be at an intermediate stage of modifying a shared data structure. Preempting its lock would likely leave this structure in an inconsistent and corrupted state, which could crash the system or lead to subtle data errors. Safe preemption requires complex transaction-like rollback/recovery mechanisms, which are not implied by this simplistic policy.\nVerdict: **Incorrect**.\n\n**Analysis of Option D:**\nThis statement describes a principled method for deadlock detection and resolution. It involves constructing a Wait-For Graph (WFG), where nodes represent threads and a directed edge from $T_i$ to $T_j$ signifies that $T_i$ is waiting for a resource held by $T_j$. The problem states that the OS maintains the necessary ownership and waiter information. A cycle in the WFG is a necessary and sufficient condition for a deadlock. This is a formal and correct method for detection. Upon detecting a cycle (and thus confirming a deadlock), the OS must apply a resolution policy. The suggested policies—aborting an acquisition attempt or rolling back a thread—are standard strategies for breaking the deadlock, typically by breaking the circular wait condition. This approach is sound, robust, and represents a standard algorithm taught in operating systems courses.\nVerdict: **Correct**.\n\n**Analysis of Option E:**\nThis statement claims that spinlocks are \"always preferable\" to sleeping locks on single-processor systems because they \"cannot deadlock\".\nThis statement is fundamentally flawed. On a single-processor system, if a thread $T_A$ holding a lock is preempted and a thread $T_B$ is scheduled, and $T_B$ attempts to acquire the same lock using a spinlock, $T_B$ will spin indefinitely. Since there is only one processor, the lock-holding thread $T_A$ cannot run to release the lock because $T_B$ is consuming all available CPU time. This leads to a complete system freeze, a form of deadlock. In contrast, if $T_B$ used a sleeping lock, it would block, and the scheduler could reschedule $T_A$, which could then release the lock and allow the system to make progress. Thus, spinlocks are generally a very poor choice on uniprocessor systems, and they can most certainly cause deadlocks. The premise is false and the conclusion is also false.\nVerdict: **Incorrect**.", "answer": "$$\\boxed{ABD}$$", "id": "3658954"}]}