{"hands_on_practices": [{"introduction": "Establishing a global lock ordering, where resources must be acquired in a predefined sequence, is a powerful technique for preventing deadlocks. But what happens when a process doesn't follow the rules? This exercise challenges you to construct a Resource-Allocation Graph to determine the absolute minimum number of defiant processes needed to break the system and create a deadlock cycle, highlighting the critical importance of protocol compliance. [@problem_id:3677426]", "problem": "Consider a system with two resource types, denoted by $R_a$ and $R_b$, each having exactly one instance. There are $n$ processes, denoted by $P_1, P_2, \\dots, P_n$, that may need to acquire both resources in a nested manner. A global lock ordering is prescribed: any process that requires both resources must acquire $R_a$ before $R_b$, which we denote by the lock order $R_a \\rightarrow R_b$. The resource-allocation graph (RAG) is defined as follows: for each process $P_i$ and resource $R_x$, a directed edge $P_i \\rightarrow R_x$ represents that $P_i$ is requesting $R_x$, and a directed edge $R_x \\rightarrow P_i$ represents that $R_x$ is allocated to $P_i$. Assume the usual four necessary conditions for deadlock are in effect: mutual exclusion, hold-and-wait, no preemption, and circular wait.\n\nAt time $t$, the system is in the following snapshot:\n- Process $P_1$ holds $R_a$ (has an allocation edge $R_a \\rightarrow P_1$) and, consistent with the global lock order, is requesting $R_b$ (has a request edge $P_1 \\rightarrow R_b$) without releasing $R_a$.\n- Exactly one process $P_k$ violates the global lock ordering. Specifically, $P_k$ holds $R_b$ (has an allocation edge $R_b \\rightarrow P_k$) and is requesting $R_a$ (has a request edge $P_k \\rightarrow R_a$) without releasing $R_b$.\n- All other processes, if they need both resources, respect the lock order $R_a \\rightarrow R_b$.\n\nStarting from the core definitions of a resource-allocation graph and the well-known characterization that, in the single-instance case, a cycle in the RAG is both necessary and sufficient for deadlock, construct the logical RAG for the snapshot at time $t$ and determine the minimal number of lock-order violations, denoted $v_{\\min}$, required among the $n$ processes for the RAG to contain a directed cycle that implies a deadlock in this two-resource system. Express your answer as a single integer for $v_{\\min}$. No rounding is necessary, and no units are required.", "solution": "The problem asks for the minimal number of lock-order violations, $v_{\\min}$, required to create a deadlock in a system with two single-instance resources, $R_a$ and $R_b$.\n\nFirst, we establish the theoretical foundation. The system consists of a set of processes $\\mathcal{P} = \\{P_1, P_2, \\dots, P_n\\}$ and a set of resource types $\\mathcal{R} = \\{R_a, R_b\\}$. Each resource type has a single instance. The state of the system can be modeled by a resource-allocation graph (RAG), which is a directed graph $G = (V, E)$. The set of vertices is $V = \\mathcal{P} \\cup \\mathcal{R}$. The set of edges $E$ consists of two types:\n1.  A request edge $P_i \\rightarrow R_x$ exists if process $P_i$ is waiting for an instance of resource type $R_x$.\n2.  An assignment edge $R_x \\rightarrow P_i$ exists if an instance of resource type $R_x$ has been allocated to process $P_i$.\n\nThe problem states that the four necessary conditions for deadlock (mutual exclusion, hold-and-wait, no preemption, and circular wait) are in effect. For a system with single-instance resources, a cycle in the RAG is a necessary and sufficient condition for the existence of a deadlock. Our task is to find the minimum number of processes that must violate the prescribed lock order, $R_a \\rightarrow R_b$, to create such a cycle.\n\nLet's analyze the condition for a cycle to form. A cycle in the RAG must involve both processes and resources. Since there are only two resource types, a cycle must alternate between processes and resources. The simplest possible cycle would involve two processes, say $P_i$ and $P_j$, and both resources, $R_a$ and $R_b$. Such a cycle would have the structure $P_i \\rightarrow R_x \\rightarrow P_j \\rightarrow R_y \\rightarrow P_i$, where $R_x, R_y \\in \\{R_a, R_b\\}$ and $R_x \\neq R_y$.\n\nLet's assume, without loss of generality, that $R_x = R_a$ and $R_y = R_b$. The cycle is then $P_i \\rightarrow R_a \\rightarrow P_j \\rightarrow R_b \\rightarrow P_i$.\nLet's interpret the edges in this cycle:\n-   $P_i \\rightarrow R_a$: Process $P_i$ is requesting resource $R_a$.\n-   $R_a \\rightarrow P_j$: Resource $R_a$ is held by process $P_j$.\n-   $P_j \\rightarrow R_b$: Process $P_j$ is requesting resource $R_b$.\n-   $R_b \\rightarrow P_i$: Resource $R_b$ is held by process $P_i$.\n\nSummarizing the state of the two processes involved in the cycle:\n-   Process $P_i$ holds $R_b$ and is requesting $R_a$.\n-   Process $P_j$ holds $R_a$ and is requesting $R_b$.\n\nNow, we evaluate this state against the global lock ordering rule, which mandates that any process requiring both resources must acquire $R_a$ before $R_b$.\n-   Process $P_j$ is behaving consistently with this rule. It acquired $R_a$ and is now requesting $R_b$. This is a valid sequence of operations.\n-   Process $P_i$, however, is holding $R_b$ and requesting $R_a$. To be in this state, it must have acquired $R_b$ first. By subsequently requesting $R_a$, it violates the $R_a \\rightarrow R_b$ lock order.\n\nThis analysis demonstrates that the formation of a two-process, two-resource cycle *requires* that one of the processes violates the global lock order. If both processes were to follow the lock order, a process holding $R_b$ would never request $R_a$, breaking the potential for a circular wait condition. Therefore, the number of violations must be at least $1$. We have established that $v_{\\min} \\geq 1$.\n\nNext, we must determine if a deadlock is possible with exactly one violation. The problem statement provides a specific snapshot at time $t$ that allows us to test this.\n-   Process $P_1$ holds $R_a$ and requests $R_b$. This corresponds to the edges $R_a \\rightarrow P_1$ and $P_1 \\rightarrow R_b$. As noted before, $P_1$ is adhering to the lock ordering protocol.\n-   Process $P_k$ holds $R_b$ and requests $R_a$. This corresponds to the edges $R_b \\rightarrow P_k$ and $P_k \\rightarrow R_a$. This is explicitly stated as the single violation of the lock order.\n\nLet's construct the RAG for this specific configuration. The graph contains the following sequence of directed edges:\n$P_1 \\rightarrow R_b \\rightarrow P_k \\rightarrow R_a \\rightarrow P_1$.\n\nThis sequence constitutes a closed directed path, or a cycle, in the RAG. The vertices and edges are:\n-   $P_1$ requests $R_b$ (edge $P_1 \\rightarrow R_b$).\n-   $R_b$ is held by $P_k$ (edge $R_b \\rightarrow P_k$).\n-   $P_k$ requests $R_a$ (edge $P_k \\rightarrow R_a$).\n-   $R_a$ is held by $P_1$ (edge $R_a \\rightarrow P_1$).\n\nSince a cycle exists in the RAG and the resources are single-instance, a deadlock involving processes $P_1$ and $P_k$ is present. This deadlock state was achieved with exactly one process, $P_k$, violating the global lock order.\n\nThus, we have shown:\n1.  At least one lock-order violation is necessary to form a deadlock cycle ($v_{\\min} \\geq 1$).\n2.  Exactly one lock-order violation is sufficient to form a deadlock cycle ($v_{\\min} \\leq 1$).\n\nCombining these two points, the minimal number of lock-order violations required for the RAG to contain a directed cycle is precisely $1$.", "answer": "$$\\boxed{1}$$", "id": "3677426"}, {"introduction": "The Dining Philosophers problem is a classic metaphor for the challenges of concurrency and resource sharing in operating systems. By modeling the philosophers and forks using a Resource-Allocation Graph, you will explore why their intuitive approach leads to deadlock. This practice then guides you to apply a strict resource ordering policy, demonstrating a practical and elegant way to prevent circular waits and ensure the system remains deadlock-free. [@problem_id:3677360]", "problem": "Consider a dining philosophers variant modeled as follows. There are $n$ philosophers $P_1, P_2, \\dots, P_n$ seated around a circular table, and $n$ forks $R_1, R_2, \\dots, R_n$, with fork $R_j$ placed between $P_j$ and $P_{j+1}$ (with indices modulo $n$, so $R_n$ is between $P_n$ and $P_1$). Each philosopher $P_i$ requires both forks $R_i$ and $R_{i+1}$ to eat. Assume each resource type (each fork) has a single instance. A resource-allocation graph (RAG) is constructed with process vertices $P_i$ and resource vertices $R_j$, with request edges $P_i \\rightarrow R_j$ and assignment edges $R_j \\rightarrow P_i$ per the standard definition of RAG.\n\nA system policy imposes a strict total order on resource types: $R_1 \\prec R_2 \\prec \\cdots \\prec R_n$. Every philosopher must request forks in strictly increasing order with respect to $\\prec$: for philosopher $P_i$ this means requesting $\\min_{\\prec}\\{R_i, R_{i+1}\\}$ first, then $\\max_{\\prec}\\{R_i, R_{i+1}\\}$. Compare this policy to the intuition underlying cycle formation in the RAG for single-instance resource types, and evaluate the following statements. Additionally, consider a hypothetical variant policy where the resource-type precedence is cyclic $R_1 \\rightarrow R_2 \\rightarrow \\cdots \\rightarrow R_n \\rightarrow R_1$ and philosophers request in the direction of this cycle.\n\nWhich of the following statements are correct?\n\nA. Under the strict total order $R_1 \\prec R_2 \\prec \\cdots \\prec R_n$, and the constraint that philosophers request in increasing order, the resource-allocation graph cannot contain a directed cycle; therefore deadlock is impossible for single-instance forks.\n\nB. Even with the strict total order and increasing-order requests, a directed cycle among processes can still arise in the induced wait-for graph, so deadlock remains possible for single-instance forks.\n\nC. The strict total ordering eliminates the hold-and-wait condition because a philosopher is forbidden from holding a lower-ordered fork while waiting on a higher-ordered fork.\n\nD. If the resource-type precedence were cyclic $R_1 \\rightarrow R_2 \\rightarrow \\cdots \\rightarrow R_n \\rightarrow R_1$, then requesting along this cycle would fail to prevent directed cycles in the resource-allocation graph.\n\nE. The strict total ordering guarantees starvation freedom regardless of the scheduling policy, so every philosopher eventually acquires both forks and eats.", "solution": "First, let us formalize the system components and policies based on the provided statement.\n- **Processes**: There are $n$ philosophers, denoted as a set of processes $\\mathcal{P} = \\{P_1, P_2, \\dots, P_n\\}$.\n- **Resources**: There are $n$ forks, denoted as a set of resource types $\\mathcal{R} = \\{R_1, R_2, \\dots, R_n\\}$. Each resource type has a single instance.\n- **Resource Requirements**: Philosopher $P_i$ requires two forks, $R_i$ and $R_{i+1}$, where indices are interpreted modulo $n$ (so $P_n$ requires $R_n$ and $R_1$).\n- **Deadlock Condition**: For single-instance resource types, a deadlock exists if and only if the resource-allocation graph (RAG) contains a directed cycle. A cycle in the RAG is a sequence of alternating processes and resources, e.g., $P_a \\rightarrow R_x \\rightarrow P_b \\rightarrow R_y \\rightarrow \\dots \\rightarrow P_a$, indicating a circular chain of waiting processes.\n\nWe will analyze two policies.\n\n**Policy 1: Strict Total Ordering**\n\nThe first policy imposes a strict total order on the resource types: $R_1 \\prec R_2 \\prec \\cdots \\prec R_n$. A philosopher must request their required forks in strictly increasing order according to this precedence relation.\n\nLet's analyze the request order for each philosopher $P_i$:\n- For any philosopher $P_i$ where $i \\in \\{1, 2, \\dots, n-1\\}$, the required forks are $R_i$ and $R_{i+1}$. According to the total order, $R_i \\prec R_{i+1}$. Therefore, $P_i$ must request $R_i$ first, and only after acquiring $R_i$ can they request $R_{i+1}$.\n- For philosopher $P_n$, the required forks are $R_n$ and $R_1$. According to the total order, $R_1 \\prec R_n$. Therefore, $P_n$ must request $R_1$ first, and only after acquiring $R_1$ can they request $R_n$.\n\nThis policy is a standard technique for deadlock prevention, known as hierarchical resource allocation. It prevents deadlock by breaking the possibility of a circular wait condition. To prove this, assume for contradiction that a cycle exists in the RAG. A cycle must be of the form $P_{i_1} \\rightarrow R_{j_1} \\rightarrow P_{i_2} \\rightarrow R_{j_2} \\rightarrow \\dots \\rightarrow P_{i_k} \\rightarrow R_{j_k} \\rightarrow P_{i_1}$.\n\n- An edge $P_{i_m} \\rightarrow R_{j_m}$ means process $P_{i_m}$ is requesting resource $R_{j_m}$.\n- An edge $R_{j_{m-1}} \\rightarrow P_{i_m}$ means process $P_{i_m}$ holds resource $R_{j_{m-1}}$ (with index $m-1$ taken modulo $k$).\n\nSo, for any process $P_{i_m}$ in the cycle, it holds a resource $R_{j_{m-1}}$ and is requesting another resource $R_{j_m}$. The policy dictates that a process can only request a resource of a higher order than any resource it currently holds. Thus, for each step in the cycle, it must be that the held resource has a lower order than the requested resource.\n- $P_{i_1}$ holds $R_{j_k}$ and requests $R_{j_1} \\implies R_{j_k} \\prec R_{j_1}$.\n- $P_{i_2}$ holds $R_{j_1}$ and requests $R_{j_2} \\implies R_{j_1} \\prec R_{j_2}$.\n- ...\n- $P_{i_k}$ holds $R_{j_{k-1}}$ and requests $R_{j_k} \\implies R_{j_{k-1}} \\prec R_{j_k}$.\n\nChaining these inequalities gives $R_{j_k} \\prec R_{j_1} \\prec R_{j_2} \\prec \\cdots \\prec R_{j_{k-1}} \\prec R_{j_k}$. This results in the statement $R_{j_k} \\prec R_{j_k}$, which contradicts the irreflexive property of a strict order. Therefore, no cycle can exist in the RAG.\n\n**Policy 2: Cyclic Precedence**\n\nThe second, hypothetical policy imposes a cyclic precedence: $R_1 \\rightarrow R_2 \\rightarrow \\cdots \\rightarrow R_n \\rightarrow R_1$. Philosophers request forks in the direction of this cycle.\n\nLet's analyze the request order for each philosopher $P_i$:\n- For any philosopher $P_i$ where $i \\in \\{1, 2, \\dots, n-1\\}$, the required forks are $R_i$ and $R_{i+1}$. The cyclic precedence is $R_i \\rightarrow R_{i+1}$, so $P_i$ requests $R_i$ first, then $R_{i+1}$.\n- For philosopher $P_n$, the required forks are $R_n$ and $R_1$. The cyclic precedence is $R_n \\rightarrow R_1$, so $P_n$ requests $R_n$ first, then $R_1$.\n\nThis setup leads to the classic dining philosophers deadlock scenario. Consider the case where every philosopher executes the first step of their protocol simultaneously:\n1.  $P_1$ requests and acquires $R_1$.\n2.  $P_2$ requests and acquires $R_2$.\n3.  ...\n4.  $P_n$ requests and acquires $R_n$.\n\nAt this point, every philosopher holds one fork and is about to request their second fork.\n- $P_1$ holds $R_1$ and requests $R_2$, which is held by $P_2$. So $P_1$ waits.\n- $P_2$ holds $R_2$ and requests $R_3$, which is held by $P_3$. So $P_2$ waits.\n- ...\n- $P_{n-1}$ holds $R_{n-1}$ and requests $R_n$, which is held by $P_n$. So $P_{n-1}$ waits.\n- $P_n$ holds $R_n$ and requests $R_1$, which is held by $P_1$. So $P_n$ waits.\n\nThis creates a circular wait condition. The RAG will contain the cycle:\n$P_1 \\rightarrow R_2 \\rightarrow P_2 \\rightarrow R_3 \\rightarrow \\cdots \\rightarrow P_n \\rightarrow R_1 \\rightarrow P_1$.\nThus, this policy fails to prevent deadlock.\n\nNow, we evaluate each statement.\n\n**A. Under the strict total order $R_1 \\prec R_2 \\prec \\cdots \\prec R_n$, and the constraint that philosophers request in increasing order, the resource-allocation graph cannot contain a directed cycle; therefore deadlock is impossible for single-instance forks.**\nOur analysis of Policy 1 proved that the strict total ordering of resources prevents the formation of a cycle in the RAG. For single-instance resources, the absence of a cycle in the RAG is a sufficient condition for being deadlock-free.\nVerdict: **Correct**.\n\n**B. Even with the strict total order and increasing-order requests, a directed cycle among processes can still arise in the induced wait-for graph, so deadlock remains possible for single-instance forks.**\nA wait-for graph (WFG) contains an edge from $P_i$ to $P_j$ if process $P_i$ is waiting for a resource held by process $P_j$. For single-instance resource types, a cycle in the WFG is equivalent to a cycle in the RAG. As established in the analysis for statement A, the strict total order policy prevents cycles in the RAG. Consequently, it also prevents cycles in the WFG. The statement's claim that a cycle can arise is false.\nVerdict: **Incorrect**.\n\n**C. The strict total ordering eliminates the hold-and-wait condition because a philosopher is forbidden from holding a lower-ordered fork while waiting on a higher-ordered fork.**\nThe hold-and-wait condition is one of the four necessary conditions for deadlock, stating that a process must be holding at least one resource while waiting to acquire additional resources. The strict total ordering policy does not eliminate this condition. For example, philosopher $P_1$ requests $R_1$, and if granted, *holds* $R_1$ while it *waits* for $R_2$. The policy structures the hold-and-wait condition, but does not eliminate it. The reasoning provided is also flawed; the policy requires a philosopher to hold a lower-ordered fork while waiting for a higher-ordered one, it does not forbid it.\nVerdict: **Incorrect**.\n\n**D. If the resource-type precedence were cyclic $R_1 \\rightarrow R_2 \\rightarrow \\cdots \\rightarrow R_n \\rightarrow R_1$, then requesting along this cycle would fail to prevent directed cycles in the resource-allocation graph.**\nOur analysis of Policy 2 demonstrated that a cyclic precedence allows for a scenario where every philosopher acquires one fork and waits for the next one in the cycle, leading to a circular wait among all $n$ philosophers. This circular dependency manifests as a cycle in the RAG, causing a deadlock. Thus, this policy fails to prevent directed cycles.\nVerdict: **Correct**.\n\n**E. The strict total ordering guarantees starvation freedom regardless of the scheduling policy, so every philosopher eventually acquires both forks and eats.**\nDeadlock freedom does not imply starvation freedom. Starvation, or indefinite postponement, occurs when a process is repeatedly denied access to a resource even though the resource becomes available. While the total ordering policy prevents deadlock, it is possible for a philosopher to be starved. For example, consider $P_{n-1}$ (needs $R_{n-1}$, then $R_n$) and its neighbors $P_{n-2}$ (needs $R_{n-2}$, then $R_{n-1}$) and $P_n$ (needs $R_1$, then $R_n$). It is possible for an unlucky scheduling sequence to allow $P_{n-2}$ and $P_n$ to repeatedly acquire their respective needed forks ($R_{n-1}$ for $P_{n-2}$ and $R_n$ for $P_n$) in an alternating fashion, such that $P_{n-1}$ can never acquire both $R_{n-1}$ and $R_n$ at the same time. The policy itself provides no mechanism to ensure fairness.\nVerdict: **Incorrect**.", "answer": "$$\\boxed{AD}$$", "id": "3677360"}, {"introduction": "A cycle in a Resource-Allocation Graph is often taught as the definitive sign of a deadlock, but this rule comes with a critical asterisk. This thought experiment presents a scenario with a clear cycle, yet one of the resources involved—the CPU—is preemptible. Your task is to analyze how the ability to forcibly reclaim a resource breaks one of the fundamental conditions for deadlock, proving that a cycle isn't always a point of no return. [@problem_id:3677400]", "problem": "Consider the following scenario in an Introduction to Operating Systems course. A Resource-Allocation Graph (RAG) is a directed bipartite graph with processes and resources as nodes, and two types of edges: a request edge from a process to a resource (denoted $P_i \\to R_j$) representing that process $P_i$ is waiting for resource $R_j$, and an assignment edge from a resource to a process (denoted $R_j \\to P_i$) representing that resource $R_j$ is currently held by process $P_i$. A system is said to be in deadlock when a set of processes are blocked each waiting for a resource held by another process in the set; for single-instance resource types, the existence of a directed cycle in the RAG is both necessary and sufficient for deadlock.\n\nSuppose there are $2$ processes, $P_1$ and $P_2$, and $2$ resource types: a Central Processing Unit (CPU), modeled as a single-instance resource $R_{cpu}$, and a printer, modeled as a single-instance resource $R_{printer}$. The CPU $R_{cpu}$ is preemptible, meaning the operating system can forcibly deallocate it from a process and reassign it, whereas the printer $R_{printer}$ is non-preemptible, meaning it cannot be forcibly taken away once assigned.\n\nInitially, the RAG has the following edges:\n- $R_{printer} \\to P_1$ (the printer is assigned to $P_1$),\n- $P_1 \\to R_{cpu}$ (process $P_1$ requests the CPU),\n- $R_{cpu} \\to P_2$ (the CPU is assigned to $P_2$),\n- $P_2 \\to R_{printer}$ (process $P_2$ requests the printer).\n\nThis yields the cycle\n$$\nP_1 \\to R_{cpu} \\to P_2 \\to R_{printer} \\to P_1.\n$$\n\nBased on the fundamental definitions of RAGs and deadlock, evaluate the effect of allowing preemption of $R_{cpu}$ on the above cycle. Which statement best describes whether preempting $R_{cpu}$ can break the cycle that otherwise leads to deadlock, and why?\n\nA. Allowing preemption of $R_{cpu}$ can break the cycle by preempting $R_{cpu}$ from $P_2$ and assigning it to $P_1$, enabling $P_1$ to run and eventually release $R_{printer}$, thereby preventing deadlock.\n\nB. Cycles in a RAG always imply deadlock regardless of preemption policy, so allowing preemption of $R_{cpu}$ cannot break the cycle or prevent deadlock.\n\nC. Preemption of $R_{cpu}$ can only break the cycle if $R_{printer}$ is also preemptible; otherwise, the cycle necessarily persists and deadlock remains.\n\nD. Preempting $R_{cpu}$ cannot break the hold-and-wait condition when both resources have single instances; therefore, the cycle remains and deadlock is unavoidable.", "solution": "A Resource-Allocation Graph (RAG) represents processes and resources with directed edges: a request edge $P_i \\to R_j$ means process $P_i$ is waiting for resource $R_j$, and an assignment edge $R_j \\to P_i$ means resource $R_j$ is held by process $P_i$. For single-instance resource types, a directed cycle in the RAG is both necessary and sufficient for deadlock: if there is a cycle, then there is a set of processes each waiting for a resource held by another in the set, making progress impossible.\n\nIn the given scenario, there are $2$ processes ($P_1$, $P_2$) and $2$ single-instance resource types ($R_{cpu}$ and $R_{printer}$). The edges are:\n- $R_{printer} \\to P_1$,\n- $P_1 \\to R_{cpu}$,\n- $R_{cpu} \\to P_2$,\n- $P_2 \\to R_{printer}$.\n\nThis creates the cycle\n$$\nP_1 \\to R_{cpu} \\to P_2 \\to R_{printer} \\to P_1,\n$$\nwhich, under the assumption that both resources are non-preemptible, would imply deadlock because each process holds one resource and waits for the other, and neither can proceed.\n\nHowever, the CPU $R_{cpu}$ is explicitly preemptible. Preemption means the operating system can forcibly deallocate $R_{cpu}$ from $P_2$ and reassign it to another process, such as $P_1$. In terms of the RAG, preempting $R_{cpu}$ from $P_2$ removes the assignment edge $R_{cpu} \\to P_2$. If the operating system then assigns $R_{cpu}$ to $P_1$, the graph gains the assignment edge $R_{cpu} \\to P_1$ and the request edge $P_1 \\to R_{cpu}$ is satisfied and removed. After this, the remaining edges are:\n- $R_{printer} \\to P_1$,\n- $R_{cpu} \\to P_1$,\n- $P_2 \\to R_{printer}$.\n\nThere is no cycle among these edges: $P_2$ requests $R_{printer}$, which is held by $P_1$, but $P_1$ holds both $R_{cpu}$ and $R_{printer}$ and can proceed to run (using $R_{cpu}$) and complete the critical section that uses $R_{printer}$, eventually releasing $R_{printer}$. Once $R_{printer}$ is released, $P_2$ can be granted $R_{printer}$, and the system progresses without deadlock.\n\nFrom the general deadlock characterization via the four necessary conditions—mutual exclusion, hold-and-wait, no preemption, and circular wait—note that enabling preemption for $R_{cpu}$ invalidates the \"no preemption\" condition for that resource type. By removing the assignment $R_{cpu} \\to P_2$, the circular wait condition is broken: the previously existing cycle $P_1 \\to R_{cpu} \\to P_2 \\to R_{printer} \\to P_1$ no longer exists because $R_{cpu}$ is not held by $P_2$ during the critical transition. Consequently, the deadlock can be avoided.\n\nWe now evaluate each option:\n\nA. Allowing preemption of $R_{cpu}$ can break the cycle by preempting $R_{cpu}$ from $P_2$ and assigning it to $P_1$, enabling $P_1$ to run and eventually release $R_{printer}$, thereby preventing deadlock. This aligns with the reasoning above. Preempting $R_{cpu}$ removes the assignment edge $R_{cpu} \\to P_2$, eliminating the cycle, and granting $R_{cpu}$ to $P_1$ allows $P_1$ to make progress and release $R_{printer}$. Verdict — Correct.\n\nB. Cycles in a RAG always imply deadlock regardless of preemption policy, so allowing preemption of $R_{cpu}$ cannot break the cycle or prevent deadlock. This is incorrect. The statement \"cycles always imply deadlock\" is only true for single-instance resources under a static allocation model without preemption. When a resource is preemptible, the operating system can change allocation state, eliminating cycles and preventing deadlock. Verdict — Incorrect.\n\nC. Preemption of $R_{cpu}$ can only break the cycle if $R_{printer}$ is also preemptible; otherwise, the cycle necessarily persists and deadlock remains. This is incorrect. The cycle can be broken solely by preempting $R_{cpu}$, as shown: removing $R_{cpu} \\to P_2$ destroys the cycle even though $R_{printer}$ remains non-preemptible. The printer’s non-preemptibility does not prevent the cycle from being broken via the CPU. Verdict — Incorrect.\n\nD. Preempting $R_{cpu}$ cannot break the hold-and-wait condition when both resources have single instances; therefore, the cycle remains and deadlock is unavoidable. This is incorrect. Preemption of $R_{cpu}$ explicitly breaks hold-and-wait for $P_2$ by forcing it to release $R_{cpu}$. The cycle is eliminated, and deadlock is avoided. Single-instance status does not negate the effect of preemption on breaking circular wait. Verdict — Incorrect.\n\nTherefore, the best description is given by option A.", "answer": "$$\\boxed{A}$$", "id": "3677400"}]}