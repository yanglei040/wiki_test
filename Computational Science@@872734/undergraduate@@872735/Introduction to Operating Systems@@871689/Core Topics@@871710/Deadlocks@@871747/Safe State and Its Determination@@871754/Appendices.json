{"hands_on_practices": [{"introduction": "This first exercise grounds you in the fundamentals of the safety algorithm. You will analyze a simple system with just one resource type to determine if the current state is safe by identifying all possible safe sequences. This practice [@problem_id:3678785] clarifies the core logic of checking needs against available resources and understanding how resource releases enable other processes to complete.", "problem": "Consider a system with $n=3$ processes, labeled $P_0$, $P_1$, and $P_2$, and $m=1$ reusable resource type. The current snapshot has $Available=1$ instance free, the current $Allocation$ vector $[1,0,0]$ corresponding respectively to $P_0$, $P_1$, $P_2$, and the $Max$ vector $[2,1,1]$ indicating each process’s declared maximum demand. Assume the standard setting that when a process completes, it immediately releases all instances it holds, and that a state is safe if and only if there exists an ordering of all processes such that each process can obtain its remaining needed instances from what is currently available plus what will be released by previously finished processes.\nDefine $S$ to be the number of distinct safe sequences (full orderings of all $3$ processes) that are feasible from the given snapshot under the standard safety check. Next, for each $i \\in \\{0,1,2\\}$, consider a hypothetical immediate single-instance request of size $1$ from process $P_i$ (each such request is within the process’s remaining need in this snapshot). Let $U$ be the number of indices $i$ for which granting that request immediately (and updating the snapshot accordingly) would place the system in an unsafe state.\nCompute the single integer $S - U$. Express your final answer as an integer with no units. No rounding is required.", "solution": "To solve this problem, we will first calculate the initial `Need` of each process. Then, we will use the safety algorithm to find all possible safe sequences to determine the value of $S$. Finally, we will simulate granting a single-instance request from each process to determine how many of these grants lead to an unsafe state, which gives us the value of $U$.\n\n### 1. Initial State Calculation\nFirst, we determine the resources each process still needs to complete its execution. The `Need` for a process is its `Max` demand minus its current `Allocation`.\n- Given: $n=3$ processes, $m=1$ resource type, $Available = 1$, $Allocation = [1, 0, 0]$, and $Max = [2, 1, 1]$.\n- The `Need` vector is calculated as `Max - Allocation`:\n  - $Need_0 = 2 - 1 = 1$\n  - $Need_1 = 1 - 0 = 1$\n  - $Need_2 = 1 - 0 = 1$\nSo, the `Need` vector is $[1, 1, 1]$.\n\n### 2. Calculating $S$ (Number of Safe Sequences)\nWe apply the safety algorithm to find all complete execution sequences that are safe.\n- **Initial State:** `Work` = `Available` = 1. `Finish` = [false, false, false].\n- **Finding the first process:** A process $P_i$ can be chosen if $Need_i \\le Work$. Since $Need_0=1$, $Need_1=1$, and $Need_2=1$, and $Work=1$, any of the three processes can start a safe sequence.\n\nLet's enumerate the paths:\n- **If $P_0$ starts:** It finishes, releasing its allocation. New `Work` = $1 (Work) + 1 (Allocation_0) = 2$. The remaining processes are $P_1$ and $P_2$, both needing 1 instance. With `Work`=2, both can finish in any order ($P_1$ then $P_2$, or $P_2$ then $P_1$). This gives 2 sequences: $\\langle P_0, P_1, P_2 \\rangle$ and $\\langle P_0, P_2, P_1 \\rangle$.\n- **If $P_1$ starts:** It finishes, releasing its allocation. New `Work` = $1 (Work) + 0 (Allocation_1) = 1$. The remaining processes are $P_0$ and $P_2$, both needing 1 instance. With `Work`=1, both can finish in any order. This gives 2 sequences: $\\langle P_1, P_0, P_2 \\rangle$ and $\\langle P_1, P_2, P_0 \\rangle$.\n- **If $P_2$ starts:** It finishes, releasing its allocation. New `Work` = $1 (Work) + 0 (Allocation_2) = 1$. This case is symmetric to starting with $P_1$. This gives 2 sequences: $\\langle P_2, P_0, P_1 \\rangle$ and $\\langle P_2, P_1, P_0 \\rangle$.\n\nTotal number of distinct safe sequences is $2 + 2 + 2 = 6$. Therefore, $S=6$.\n\n### 3. Calculating $U$ (Unsafe Granting Scenarios)\nWe check each process's request for 1 instance. A request from $P_i$ is valid as $Need_i=1$. Granting it is possible as $Available=1$. After any grant, $Available'$ will become 0.\n\n- **Grant 1 to $P_0$:**\n  - New state: $Available' = 0$, $Allocation' = [2, 0, 0]$, $Need' = [0, 1, 1]$.\n  - Safety check: `Work` starts at 0. Only $P_0$ can run ($Need'_0 = 0$). After $P_0$ finishes, it releases 2 instances. New `Work` = 2. Both $P_1$ (needs 1) and $P_2$ (needs 1) can finish. The state is **SAFE**.\n\n- **Grant 1 to $P_1$:**\n  - New state: $Available' = 0$, $Allocation' = [1, 1, 0]$, $Need' = [1, 0, 1]$.\n  - Safety check: `Work` starts at 0. Only $P_1$ can run ($Need'_1 = 0$). After $P_1$ finishes, it releases 1 instance. New `Work` = 1. Both $P_0$ (needs 1) and $P_2$ (needs 1) can finish. The state is **SAFE**.\n\n- **Grant 1 to $P_2$:**\n  - New state: $Available' = 0$, $Allocation' = [1, 0, 1]$, $Need' = [1, 1, 0]$.\n  - Safety check: `Work` starts at 0. Only $P_2$ can run ($Need'_2 = 0$). After $P_2$ finishes, it releases 1 instance. New `Work` = 1. Both $P_0$ (needs 1) and $P_1$ (needs 1) can finish. The state is **SAFE**.\n\nIn all three scenarios, granting the request leads to a safe state. Thus, the number of processes whose request leads to an unsafe state is $U = 0$.\n\n### 4. Final Calculation\nThe required value is $S - U$.\n$S - U = 6 - 0 = 6$.", "answer": "$$\\boxed{6}$$", "id": "3678785"}, {"introduction": "Building on the basics, this problem scales up the scenario to multiple resource types and a larger number of processes. The key insight here lies in recognizing that processes which have already acquired their maximum declared resources can finish at any time, releasing their holdings. This exercise [@problem_id:3678795] challenges you to apply the safety algorithm in a more complex but structured environment to determine if the single remaining process can be satisfied.", "problem": "Consider a system managed by the Banker's algorithm with $n$ processes $\\{P_0,\\dots,P_4\\}$ and $m$ resource types $\\{R_0,R_1,R_2\\}$. You are given the current state in terms of the $Allocation$ and $Max$ vectors for each process and the system-wide $Available$ vector. For all processes except one, the declared maximum equals the current allocation, so their remaining need is zero. The data are:\n- $Available = (1,0,0)$.\n- $Allocation(P_0) = (1,0,2)$ and $Max(P_0) = (1,0,2)$.\n- $Allocation(P_1) = (0,2,1)$ and $Max(P_1) = (0,2,1)$.\n- $Allocation(P_2) = (2,1,0)$ and $Max(P_2) = (2,1,0)$.\n- $Allocation(P_3) = (1,1,1)$ and $Max(P_3) = (1,1,1)$.\n- $Allocation(P_4) = (0,1,0)$ and $Max(P_4) = (4,3,3)$.\n\nUse only the core definitions that underlie the Banker's safety test: a state is safe if there exists some order in which processes can finish, where at each step the currently $Available$ resources are at least the remaining claim of some unfinished process, and upon a process finishing its allocated resources are returned to $Available$. Determine whether the single remaining process with nonzero need (namely $P_4$) can be safely satisfied given $Available$ and the fact that all other processes have zero remaining need. Define the indicator $s$ to be $1$ if the state is safe (i.e., such an order exists) and $0$ otherwise. Provide the value of $s$ as a single integer. No rounding is required, and no units are involved.", "solution": "The problem asks to determine if a given system state is safe according to the Banker's algorithm. The state is defined by the number of processes $n=5$, denoted $\\{P_0, P_1, P_2, P_3, P_4\\}$, and the number of resource types $m=3$, denoted $\\{R_0, R_1, R_2\\}$. We are provided with the current allocation of resources to each process, the maximum resources each process may request, and the currently available resources in the system.\n\nFirst, we formalize the given data.\nThe vector of available resources is $Available = (1, 0, 0)$.\nThe allocation matrix, $Allocation$, where row $i$ corresponds to process $P_i$, is:\n$$\nAllocation = \\begin{pmatrix}\n1 & 0 & 2 \\\\\n0 & 2 & 1 \\\\\n2 & 1 & 0 \\\\\n1 & 1 & 1 \\\\\n0 & 1 & 0\n\\end{pmatrix}\n$$\nThe maximum need matrix, $Max$, is:\n$$\nMax = \\begin{pmatrix}\n1 & 0 & 2 \\\\\n0 & 2 & 1 \\\\\n2 & 1 & 0 \\\\\n1 & 1 & 1 \\\\\n4 & 3 & 3\n\\end{pmatrix}\n$$\n\nThe core of the Banker's algorithm is the safety check, which determines if there is at least one sequence of process executions that allows every process to complete without causing a deadlock. A state is safe if such a sequence exists. The algorithm relies on the concept of the remaining need of each process, which is calculated as the difference between its maximum required resources and its current allocation.\n\nLet the $Need$ matrix be defined by the relation $Need_i = Max_i - Allocation_i$, where $i$ is the process index. We can compute the $Need$ vector for each process:\n$Need(P_0) = Max(P_0) - Allocation(P_0) = (1,0,2) - (1,0,2) = (0,0,0)$.\n$Need(P_1) = Max(P_1) - Allocation(P_1) = (0,2,1) - (0,2,1) = (0,0,0)$.\n$Need(P_2) = Max(P_2) - Allocation(P_2) = (2,1,0) - (2,1,0) = (0,0,0)$.\n$Need(P_3) = Max(P_3) - Allocation(P_3) = (1,1,1) - (1,1,1) = (0,0,0)$.\n$Need(P_4) = Max(P_4) - Allocation(P_4) = (4,3,3) - (0,1,0) = (4,2,3)$.\n\nAs stated in the problem, processes $P_0, P_1, P_2, P_3$ have a remaining need of zero, meaning they have acquired all the resources they declared they would ever need and can finish their execution at any time, releasing their currently allocated resources. Process $P_4$ is the only one with a non-zero remaining need.\n\nThe safety algorithm works as follows:\n1.  Initialize a vector $Work = Available$ and a boolean vector $Finish$ of length $n$ to $false$.\n2.  Find a process $P_i$ such that $Finish[i]$ is $false$ and $Need_i \\le Work$. If no such process exists, go to step 4.\n3.  If such a process is found, assume it completes execution. Update $Work = Work + Allocation_i$ and set $Finish[i]$ to $true$. Go back to step 2.\n4.  If all elements of $Finish$ are $true$, the system state is safe. Otherwise, it is unsafe.\n\nLet's apply this algorithm to the given state.\nInitial state:\n$Work = Available = (1,0,0)$.\n$Finish = (false, false, false, false, false)$.\n\nWe search for a process $P_i$ such that $Finish[i] = false$ and $Need_i \\le Work$.\n- For $P_0$: $Need_0 = (0,0,0) \\le Work = (1,0,0)$. This is true. So, $P_0$ can finish.\nLet's select $P_0$ to run to completion.\n$Work = Work + Allocation_0 = (1,0,0) + (1,0,2) = (2,0,2)$.\n$Finish = (true, false, false, false, false)$.\nThe partial safe sequence is $<P_0>$.\n\nNow we repeat the search with the updated $Work$ vector.\n- For $P_1$: $Finish[1] = false$ and $Need_1 = (0,0,0) \\le Work = (2,0,2)$. This is true.\nLet's select $P_1$ to run to completion.\n$Work = Work + Allocation_1 = (2,0,2) + (0,2,1) = (2,2,3)$.\n$Finish = (true, true, false, false, false)$.\nThe partial safe sequence is $<P_0, P_1>$.\n\nRepeat the search:\n- For $P_2$: $Finish[2] = false$ and $Need_2 = (0,0,0) \\le Work = (2,2,3)$. This is true.\nLet's select $P_2$ to run to completion.\n$Work = Work + Allocation_2 = (2,2,3) + (2,1,0) = (4,3,3)$.\n$Finish = (true, true, true, false, false)$.\nThe partial safe sequence is $<P_0, P_1, P_2>$.\n\nRepeat the search:\n- For $P_3$: $Finish[3] = false$ and $Need_3 = (0,0,0) \\le Work = (4,3,3)$. This is true.\nLet's select $P_3$ to run to completion.\n$Work = Work + Allocation_3 = (4,3,3) + (1,1,1) = (5,4,4)$.\n$Finish = (true, true, true, true, false)$.\nThe partial safe sequence is $<P_0, P_1, P_2, P_3>$.\n\nFinally, we repeat the search for the last unfinished process, $P_4$.\n- For $P_4$: $Finish[4] = false$. We must check if $Need_4 \\le Work$.\n$Need_4 = (4,2,3)$.\n$Work = (5,4,4)$.\nThe condition $(4,2,3) \\le (5,4,4)$ is true because $4 \\le 5$, $2 \\le 4$, and $3 \\le 4$.\nSo, $P_4$ can also run to completion.\n$Work = Work + Allocation_4 = (5,4,4) + (0,1,0) = (5,5,4)$.\n$Finish = (true, true, true, true, true)$.\nThe full safe sequence is $<P_0, P_1, P_2, P_3, P_4>$.\n\nSince the algorithm terminated with $Finish[i]$ being true for all processes $i = 0, \\dots, 4$, a safe sequence exists. Therefore, the system is in a safe state.\n\nThe problem asks for the value of the indicator $s$, which is $1$ if the state is safe and $0$ otherwise. Since the state is safe, $s=1$. Any permutation of $\\{P_0, P_1, P_2, P_3\\}$ followed by $P_4$ would constitute a valid safe sequence.", "answer": "$$\\boxed{1}$$", "id": "3678795"}, {"introduction": "This final practice moves beyond simple analysis to a question of system design and resource provisioning. Presented with an unsafe state, your task is to determine the minimum number of additional resources required to make it safe. This problem [@problem_id:3678749] beautifully illustrates the concept of a resource threshold and demonstrates how the Banker's algorithm can be used not just to check states, but to inform decisions about system capacity.", "problem": "A uniprogrammed operating system is managing $m=2$ distinct resource types, denoted $R_1$ and $R_2$. There are $n=3$ independent processes $P_0$, $P_1$, and $P_2$. The system-wide resource totals are $R_1^{\\text{tot}}=100$ and $R_2^{\\text{tot}}=3$. The current state of the system is specified by each process’s current Allocation vector and its declared Maximum vector, given as ordered pairs $(R_1,R_2)$:\n- $P_0$: Allocation $(10,1)$, Maximum $(20,3)$.\n- $P_1$: Allocation $(15,1)$, Maximum $(25,3)$.\n- $P_2$: Allocation $(5,1)$, Maximum $(15,3)$.\n\nNo other processes exist. Assume that the only change you are allowed to make is to increase the total amount of $R_2$ by an integer $\\Delta \\ge 0$ (so that $R_2^{\\text{tot}}$ becomes $3+\\Delta$), with no changes to Allocations or Maximums. The goal is to leverage the standard notion of a safe state in resource-allocation systems: a state is safe if there exists some order of completion of the processes such that each process can acquire its remaining needed resources from what is available at its turn and, upon completion, releases its Allocation to possibly enable the next process, until all processes complete.\n\nDetermine the minimal integer $\\Delta$ such that, after increasing only $R_2^{\\text{tot}}$ by $\\Delta$, the resulting state is safe. Report the value of $\\Delta$ as a single integer. No rounding is required.", "solution": "The problem asks for the minimum integer value of $\\Delta \\ge 0$ that makes the given system state safe. The initial total resources are $R_1^{\\text{tot}}=100$ and $R_2^{\\text{tot}}=3$. The amount of $R_2$ is increased to a new total of $R_{2, \\text{new}}^{\\text{tot}} = 3 + \\Delta$. This problem can be solved by applying the Banker's Algorithm for deadlock avoidance.\n\nFirst, let's formalize the state of the system. The number of processes is $n=3$ and the number of resource types is $m=2$.\n\nThe resource vectors are defined as follows:\nThe `Total` vector (E) of available resources in the system is $E = (R_1^{\\text{tot}}, R_{2, \\text{new}}^{\\text{tot}}) = (100, 3+\\Delta)$.\n\nThe `Allocation` matrix (A) specifies the resources currently allocated to each process.\nFor $P_0$: $A_0 = (10, 1)$\nFor $P_1$: $A_1 = (15, 1)$\nFor $P_2$: $A_2 = (5, 1)$\n$$ A = \\begin{pmatrix} 10 & 1 \\\\ 15 & 1 \\\\ 5 & 1 \\end{pmatrix} $$\n\nThe `Maximum` matrix (M) specifies the maximum resources each process may request.\nFor $P_0$: $M_0 = (20, 3)$\nFor $P_1$: $M_1 = (25, 3)$\nFor $P_2$: $M_2 = (15, 3)$\n$$ M = \\begin{pmatrix} 20 & 3 \\\\ 25 & 3 \\\\ 15 & 3 \\end{pmatrix} $$\n\nNext, we calculate the `Need` matrix (N), which represents the remaining resources each process needs to complete its task. The `Need` for a process $i$ is calculated as $N_i = M_i - A_i$.\nFor $P_0$: $N_0 = (20, 3) - (10, 1) = (10, 2)$\nFor $P_1$: $N_1 = (25, 3) - (15, 1) = (10, 2)$\nFor $P_2$: $N_2 = (15, 3) - (5, 1) = (10, 2)$\n$$ N = \\begin{pmatrix} 10 & 2 \\\\ 10 & 2 \\\\ 10 & 2 \\end{pmatrix} $$\n\nNow, we calculate the `Available` vector (V), which represents the resources not currently allocated. This is found by subtracting the sum of all allocated resources from the total resources.\nFirst, find the total allocated resources by summing the columns of the `Allocation` matrix:\nTotal allocated $R_1 = 10 + 15 + 5 = 30$.\nTotal allocated $R_2 = 1 + 1 + 1 = 3$.\nSo, the total allocation vector is $(30, 3)$.\n\nThe `Available` vector $V$ is:\n$V = E - (30, 3) = (100, 3+\\Delta) - (30, 3) = (70, \\Delta)$.\n\nThe safety algorithm is used to determine if the current state is safe. A state is safe if there exists a sequence of processes $<P_{i_1}, P_{i_2}, \\dots, P_{i_n}>$ such that for each process $P_k$ in the sequence, its `Need` can be satisfied by the currently available resources. If this condition is met, the process is assumed to execute, complete, and release its allocated resources, which are then added back to the pool of available resources.\n\nThe algorithm works as follows:\nLet `Work` be a vector of length $m$, initialized to `Available`. So, $Work = V = (70, \\Delta)$.\nLet `Finish` be a boolean vector of length $n$, initialized to `false` for all processes.\n\n1. Find a process $P_i$ such that `Finish[i]` is `false` and $N_i \\le Work$. The vector inequality $A \\le B$ holds if $A_j \\le B_j$ for all components $j$.\n2. If no such process exists, go to step 4.\n3. If such a process $P_i$ is found, update `Work` = `Work` + $A_i$, set `Finish[i]` = `true`, and go back to step 1.\n4. If `Finish[i]` is `true` for all $i$, the system is in a safe state. Otherwise, it is unsafe.\n\nFor the system to be safe, there must be at least one process $P_i$ that can be executed first. This requires its `Need` vector $N_i$ to be less than or equal to the initial `Available` vector, $V$.\nLet's check this condition for each process:\nFor $P_0$: $N_0 \\le V \\implies (10, 2) \\le (70, \\Delta)$. This requires $10 \\le 70$ (which is true) and $2 \\le \\Delta$.\nFor $P_1$: $N_1 \\le V \\implies (10, 2) \\le (70, \\Delta)$. This requires $10 \\le 70$ (true) and $2 \\le \\Delta$.\nFor $P_2$: $N_2 \\le V \\implies (10, 2) \\le (70, \\Delta)$. This requires $10 \\le 70$ (true) and $2 \\le \\Delta$.\n\nIn all cases, for the safety algorithm to even begin, we must satisfy the condition $2 \\le \\Delta$. Since $\\Delta$ is an integer, the smallest possible value it could take to satisfy this condition is $\\Delta = 2$.\n\nLet's verify if the state is indeed safe for $\\Delta = 2$.\nIf $\\Delta=2$, the initial `Available` (Work) vector is $Work = (70, 2)$.\nThe `Finish` vector is $($false, false, false$)$.\n\n1. We can choose any of the three processes to start. Let's pick $P_0$.\n   Is $N_0 = (10, 2) \\le Work = (70, 2)$? Yes.\n   $P_0$ can run. It finishes and releases its resources.\n   New $Work = Work + A_0 = (70, 2) + (10, 1) = (80, 3)$.\n   `Finish` becomes $($true, false, false$)$.\n\n2. Now we look for the next process. Current $Work = (80, 3)$.\n   Let's pick $P_1$. Is $N_1 = (10, 2) \\le Work = (80, 3)$? Yes.\n   $P_1$ can run. It finishes and releases its resources.\n   New $Work = Work + A_1 = (80, 3) + (15, 1) = (95, 4)$.\n   `Finish` becomes $($true, true, false$)$.\n\n3. Finally, we check the last process, $P_2$. Current $Work = (95, 4)$.\n   Is $N_2 = (10, 2) \\le Work = (95, 4)$? Yes.\n   $P_2$ can run. It finishes and releases its resources.\n   New $Work = Work + A_2 = (95, 4) + (5, 1) = (100, 5)$.\n   `Finish` becomes $($true, true, true$)$.\n\nSince `Finish` is true for all processes, a safe sequence $<P_0, P_1, P_2>$ exists (other permutations like $<P_1, P_0, P_2>$ etc. are also possible). Therefore, the state is safe for $\\Delta=2$.\n\nIf we choose any integer $\\Delta < 2$ (i.e., $\\Delta_0 = 0$ or $\\Delta_1=1$), the initial condition $N_i \\le V$ would not be met for any process $P_i$, as it would require $2 \\le 0$ or $2 \\le 1$, both of which are false. In those cases, no process could be selected to run, and the algorithm would terminate with `Finish` not all true, indicating an unsafe state.\n\nThus, the minimal integer value of $\\Delta$ that makes the system state safe is $2$.", "answer": "$$\n\\boxed{2}\n$$", "id": "3678749"}]}