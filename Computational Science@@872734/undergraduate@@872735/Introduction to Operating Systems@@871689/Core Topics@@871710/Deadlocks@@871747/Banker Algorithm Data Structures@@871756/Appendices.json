{"hands_on_practices": [{"introduction": "The correctness of the Banker's algorithm depends on the integrity of its core data structures. The relationship $Need = Max - Allocation$ is not just a definition, but a fundamental invariant that must hold true at all times. This exercise [@problem_id:3622586] serves as a practical diagnostic task, challenging you to act like a system debugger and pinpoint an inconsistency within a given state snapshot, thereby reinforcing your understanding of these essential data relationships.", "problem": "A system uses the Banker's algorithm (BA) to manage $m$ resource types across $n$ processes. The BA maintains the following data structures per process $P_i$ and resource type $R_j$: an Allocation matrix $A$ where $A[i,j]$ is the number of instances of $R_j$ currently allocated to $P_i$, a Maximum demand matrix $M$ where $M[i,j]$ is the declared maximum number of instances of $R_j$ that $P_i$ may ever request, and a Need matrix $N$ defined from first principles by $N[i,j] = M[i,j] - A[i,j]$. The system also tracks a Total resource vector $\\mathbf{T}$ and an Available vector $\\mathbf{V}$ that must satisfy $\\mathbf{V} = \\mathbf{T} - \\sum_{i} A[i,*]$ componentwise, with all entries nonnegative integers. A fundamental invariant of the BA data model is that, for every $i$ and $j$, $0 \\le A[i,j] \\le M[i,j]$ and $0 \\le N[i,j] \\le M[i,j]$, with $N[i,j]$ computed exactly as $M[i,j] - A[i,j]$.\n\nConsider the following snapshot with $n = 4$ processes and $m = 3$ resource types $\\{A,B,C\\}$. The vectors and matrices are:\n\n$$\\mathbf{T} = (12, 9, 8), \\quad \\mathbf{V} = (4, 4, 2).$$\n\n$$A = \\begin{bmatrix}\n3 & 0 & 1 \\\\\n2 & 1 & 3 \\\\\n2 & 3 & 1 \\\\\n1 & 1 & 1\n\\end{bmatrix}, \\quad\nM = \\begin{bmatrix}\n7 & 5 & 3 \\\\\n3 & 2 & 7 \\\\\n4 & 3 & 3 \\\\\n3 & 4 & 4\n\\end{bmatrix}, \\quad\nN = \\begin{bmatrix}\n4 & 5 & 2 \\\\\n1 & 1 & 4 \\\\\n2 & 0 & 2 \\\\\n2 & 5 & 3\n\\end{bmatrix}.$$\n\nAssume that the Allocation $A$, the Need $N$, and the vectors $\\mathbf{T}, \\mathbf{V}$ are accurate measurements. Exactly one entry in the Maximum demand matrix $M$ is a data-entry error, and the true value must be the one that makes the BA invariants hold for all processes and resource types simultaneously, without changing any other entry. Which of the following statements correctly identifies the erroneous entry and its corrected value?\n\nA. The incorrect entry is $M[P_3,B]$; its correct value is $6$.\n\nB. The incorrect entry is $N[P_3,B]$; its correct value is $3$.\n\nC. The incorrect entry is $A[P_2,B]$; its correct value is $2$.\n\nD. The Available vector $\\mathbf{V}$ is incorrect; its correct value is $(3, 4, 2)$.\n\nE. The incorrect entry is $M[P_0,B]$; its correct value is $6$.", "solution": "The user wants me to validate and solve a problem concerning the data structures of the Banker's algorithm.\n\n### Step 1: Extract Givens\n- Number of processes $n=4$, denoted $P_0, P_1, P_2, P_3$.\n- Number of resource types $m=3$, denoted $A, B, C$.\n- Total resource vector: $\\mathbf{T} = (12, 9, 8)$.\n- Available resource vector: $\\mathbf{V} = (4, 4, 2)$.\n- Allocation matrix $A$:\n$$A = \\begin{bmatrix}\n3 & 0 & 1 \\\\\n2 & 1 & 3 \\\\\n2 & 3 & 1 \\\\\n1 & 1 & 1\n\\end{bmatrix}$$\n- Maximum demand matrix $M$:\n$$M = \\begin{bmatrix}\n7 & 5 & 3 \\\\\n3 & 2 & 7 \\\\\n4 & 3 & 3 \\\\\n3 & 4 & 4\n\\end{bmatrix}$$\n- Need matrix $N$:\n$$N = \\begin{bmatrix}\n4 & 5 & 2 \\\\\n1 & 1 & 4 \\\\\n2 & 0 & 2 \\\\\n2 & 5 & 3\n\\end{bmatrix}$$\n- Core invariants:\n  1. $N[i,j] = M[i,j] - A[i,j]$ for all $i,j$.\n  2. $\\mathbf{V} = \\mathbf{T} - \\sum_{i=0}^{n-1} A[i,*]$ (component-wise sum over all processes).\n- Problem premise: The matrices $A$ and $N$, and the vectors $\\mathbf{T}$ and $\\mathbf{V}$ are accurate. There is exactly one incorrect entry in the matrix $M$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement provides a set of data and a clear set of rules (invariants of the Banker's algorithm) to be checked. The task is to find a single inconsistency based on these rules.\n\nFirst, I will verify the consistency of the data declared as \"accurate\": $A, N, \\mathbf{T}, \\mathbf{V}$. The relationship connecting $\\mathbf{T}, \\mathbf{V},$ and $A$ must hold.\nThe total allocated resources for each type are the sum of the columns of the Allocation matrix $A$.\nLet $\\mathbf{A}_{\\text{total}}$ be the vector of total allocated resources.\n- Total allocated for resource type A (column $0$): $3 + 2 + 2 + 1 = 8$.\n- Total allocated for resource type B (column $1$): $0 + 1 + 3 + 1 = 5$.\n- Total allocated for resource type C (column $2$): $1 + 3 + 1 + 1 = 6$.\nSo, $\\mathbf{A}_{\\text{total}} = (8, 5, 6)$.\n\nAccording to the invariant, the available vector $\\mathbf{V}$ should be $\\mathbf{T} - \\mathbf{A}_{\\text{total}}$.\nLet's compute this:\n$\\mathbf{T} - \\mathbf{A}_{\\text{total}} = (12, 9, 8) - (8, 5, 6) = (12-8, 9-5, 8-6) = (4, 4, 2)$.\nThis calculated available vector $(4, 4, 2)$ matches the given available vector $\\mathbf{V} = (4, 4, 2)$.\nThus, the relationship between $\\mathbf{T}$, $\\mathbf{V}$, and $A$ is consistent.\n\nNext, the problem states the error is in $M$, and that $A$ and $N$ are accurate. This implies that the fundamental relationship $N[i,j] = M[i,j] - A[i,j]$ must have been violated for one entry due to the error in $M$. To find the error, we can check the equivalent formulation $M[i,j] = A[i,j] + N[i,j]$ for all $i, j$. The location where the given $M$ differs from the sum $A+N$ is the location of the error.\n\n### Step 3: Verdict and Action\nThe problem is scientifically grounded in the principles of operating systems, specifically resource allocation and deadlock avoidance. It is well-posed, objective, and self-contained, providing sufficient information to arrive at a unique solution. The premises are internally consistent. Therefore, the problem is valid. I will proceed with the solution.\n\n### Derivation of the Solution\nThe central task is to identify the single incorrect entry in the matrix $M$. Based on the problem's premise that $A$ and $N$ are correct, the correct Maximum demand matrix, let's call it $M'$, can be computed directly from the invariant $M'[i,j] = A[i,j] + N[i,j]$. We will then compare $M'$ with the given $M$ to find the discrepancy.\n\nThe rows of the matrices correspond to processes $P_0, P_1, P_2, P_3$ (indices $0, 1, 2, 3$) and the columns correspond to resource types $A, B, C$ (indices $0, 1, 2$).\n\nLet's compute $M' = A + N$ element by element:\n$M' = \\begin{bmatrix}\n3+4 & 0+5 & 1+2 \\\\\n2+1 & 1+1 & 3+4 \\\\\n2+2 & 3+0 & 1+2 \\\\\n1+2 & 1+5 & 1+3\n\\end{bmatrix} = \\begin{bmatrix}\n7 & 5 & 3 \\\\\n3 & 2 & 7 \\\\\n4 & 3 & 3 \\\\\n3 & 6 & 4\n\\end{bmatrix}$\n\nNow, we compare this computed correct matrix $M'$ with the given matrix $M$:\n$M = \\begin{bmatrix}\n7 & 5 & 3 \\\\\n3 & 2 & 7 \\\\\n4 & 3 & 3 \\\\\n3 & 4 & 4\n\\end{bmatrix}$\n\nBy inspection, the matrices are identical except for one entry:\n- The entry at row index $3$, column index $1$ (Process $P_3$, Resource type B).\n- The given value is $M[3,1] = 4$.\n- The correctly computed value is $M'[3,1] = 6$.\n\nTherefore, the incorrect entry is $M[P_3,B]$ (which can be written as $M[3,1]$), its given value is $4$, and its correct value is $6$.\n\n### Option-by-Option Analysis\n\n**A. The incorrect entry is $M[P_3,B]$; its correct value is $6$.**\nThis statement aligns perfectly with our derivation. The entry corresponds to the element at row index $3$ and column index $1$ of the matrix $M$. We found that $M[3,1]$ should be $A[3,1] + N[3,1] = 1 + 5 = 6$, but it was given as $4$.\n**Verdict: Correct.**\n\n**B. The incorrect entry is $N[P_3,B]$; its correct value is $3$.**\nThis statement contradicts the problem's premise that the Need matrix $N$ is accurate and the error is in $M$. If we were to assume $A$ and $M$ were correct, then $N[P_3,B]$ would be $M[P_3,B] - A[P_3,B] = 4-1=3$. However, this violates the explicit conditions of the problem.\n**Verdict: Incorrect.**\n\n**C. The incorrect entry is $A[P_2,B]$; its correct value is $2$.**\nThis statement contradicts the problem's premise that the Allocation matrix $A$ is accurate. Changing $A$ would also violate the consistency of the $\\mathbf{T}, \\mathbf{V}, A$ relationship that we verified earlier.\n**Verdict: Incorrect.**\n\n**D. The Available vector $\\mathbf{V}$ is incorrect; its correct value is $(3, 4, 2)$.**\nThis statement contradicts the problem's premise that the Available vector $\\mathbf{V}$ is accurate. Furthermore, our validation step confirmed that the given $\\mathbf{V}$ is consistent with the given $\\mathbf{T}$ and $A$.\n**Verdict: Incorrect.**\n\n**E. The incorrect entry is $M[P_0,B]$; its correct value is $6$.**\nOur analysis showed the error is at $M[P_3,B]$, not $M[P_0,B]$. For $M[P_0,B]$, or $M[0,1]$, the correct value is $A[0,1] + N[0,1] = 0 + 5 = 5$. The given value is also $5$. There is no error at this position.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "3622586"}, {"introduction": "Moving from theory to practice often involves optimizing critical code paths. The safety check in the Banker's algorithm, which may run frequently, involves repeatedly scanning for processes that can complete. This practice [@problem_id:3622562] invites you to analyze a common performance optimization: replacing a simple array of flags with a packed bitset. By quantifying the expected speedup, you will gain insight into how low-level data representation and CPU-native operations can significantly enhance algorithmic efficiency.", "problem": "Consider the data structure choice for the array $Finish$ used in the safety check loop of the Banker's algorithm in an operating system that manages $N$ processes. The array $Finish$ records which processes have completed the safety check, with $Finish[i] = 1$ meaning finished and $Finish[i] = 0$ meaning unfinished. You are to compare two representations and scanning strategies for identifying unfinished processes during one full scan over all $N$ processes.\n\nAssume the following base facts and definitions:\n- Work is proportional to a count of primitive operations; the expected total work is the sum of expected counts of these operations.\n- A packed bitset stores one Boolean per bit and can be processed a machine word at a time.\n- The Find First Set (FFS) operation returns the index of the least significant set bit of a word in constant time.\n\nYou will compare:\n1. An array of Booleans stored as bytes (one byte per flag), scanned sequentially.\n2. A packed bitset stored in $64$-bit words; scanning uses word-wise operations and the Find First Set (FFS) primitive to enumerate indices of unfinished processes by operating on the bitwise complement of each word.\n\nAssume:\n- There are $N = 4096$ processes.\n- Each process is independently finished with probability $0.9$ and unfinished with probability $0.1$.\n- In the byte-array representation, scanning each entry incurs a fixed cost of $c_b = 1$ operation per entry inspected. Additionally, each time an unfinished process is detected, there is a fixed overhead $c_u = 2$ operations to handle it (for example, enqueueing the index for subsequent admissibility checks). This same overhead $c_u$ applies in both representations.\n- In the bitset representation:\n  - The bitset is partitioned into contiguous $64$-bit words; denote the number of words by $W$.\n  - For each $64$-bit word, you perform one $64$-bit load, one bitwise NOT, and one zero-test, with per-operation costs $c_L = 1$, $c_I = 1$, and $c_Z = 1$, respectively.\n  - For each unfinished process within a word (a $1$ bit in the complemented mask), you perform one FFS with cost $c_F = 3$ and one clear-lowest-set-bit operation with cost $c_C = 1$, in addition to the shared overhead $c_u = 2$.\n- Treat expectations using independence and linearity of expectation; do not assume any additional branch or cache penalties beyond the costs stated.\n\nDerive from first principles the expected total operation count for each representation over one complete scan, and then compute the expected speedup\n$$S = \\frac{\\text{expected total operations for the byte-array scan}}{\\text{expected total operations for the bitset scan}}.$$\nReport $S$ as a pure number. Round your answer to four significant figures. Do not include any units in your final answer.", "solution": "The problem asks for the expected speedup $S$ achieved by using a packed bitset representation over a byte-array representation for the $Finish$ array in the Banker's algorithm's safety check. The speedup $S$ is defined as the ratio of the expected total operation counts for a single scan.\n\nLet $E_B$ be the expected total operations for the byte-array scan and $E_{BS}$ be the expected total operations for the bitset scan. The speedup is then:\n$$S = \\frac{E_B}{E_{BS}}$$\n\nWe are given the following parameters:\n- Number of processes, $N = 4096$.\n- Probability of a process being finished, $p_{fin} = 0.9$.\n- Probability of a process being unfinished, $p_{unfin} = 1 - p_{fin} = 0.1$.\n- Cost to inspect one entry in the byte-array, $c_b = 1$.\n- Overhead cost for handling an unfinished process, $c_u = 2$.\n- Machine word size, $k = 64$ bits.\n- Number of words in the bitset, $W = \\frac{N}{k} = \\frac{4096}{64} = 64$.\n- Cost for a $64$-bit load, $c_L = 1$.\n- Cost for a bitwise NOT operation, $c_I = 1$.\n- Cost for a zero-test, $c_Z = 1$.\n- Cost for a Find First Set (FFS) operation, $c_F = 3$.\n- Cost for a clear-lowest-set-bit operation, $c_C = 1$.\n\nFirst, we derive the expected operation count for the byte-array representation, $E_B$.\nThe total cost $C_B$ for one scan is the sum of scanning all entries and the additional overhead for each unfinished process found.\nLet $N_{unfin}$ be the random variable representing the total number of unfinished processes.\nThe total cost is given by the expression:\n$$C_B = N \\cdot c_b + N_{unfin} \\cdot c_u$$\nTo find the expected cost $E_B = E[C_B]$, we use the linearity of expectation:\n$$E_B = E[N \\cdot c_b + N_{unfin} \\cdot c_u] = N \\cdot c_b + E[N_{unfin}] \\cdot c_u$$\nThe expected number of unfinished processes, $E[N_{unfin}]$, can be found by considering that each of the $N$ processes is unfinished independently with probability $p_{unfin}$. Let $X_i$ be an indicator variable such that $X_i=1$ if process $i$ is unfinished and $X_i=0$ otherwise. Then $E[X_i] = 1 \\cdot P(X_i=1) + 0 \\cdot P(X_i=0) = p_{unfin}$.\nThe total number of unfinished processes is $N_{unfin} = \\sum_{i=1}^{N} X_i$.\nBy linearity of expectation:\n$$E[N_{unfin}] = E\\left[\\sum_{i=1}^{N} X_i\\right] = \\sum_{i=1}^{N} E[X_i] = N \\cdot p_{unfin}$$\nSubstituting this back into the expression for $E_B$:\n$$E_B = N \\cdot c_b + (N \\cdot p_{unfin}) \\cdot c_u$$\nPlugging in the given values:\n$$E_B = 4096 \\cdot 1 + (4096 \\cdot 0.1) \\cdot 2 = 4096 + 409.6 \\cdot 2 = 4096 + 819.2 = 4915.2$$\n\nNext, we derive the expected operation count for the packed bitset representation, $E_{BS}$.\nThe total cost $C_{BS}$ is the sum of costs for processing each of the $W$ words and the costs for handling each unfinished process.\nFor each of the $W$ words, a load, a NOT, and a zero-test are performed. The total cost for this is $W \\cdot (c_L + c_I + c_Z)$.\nFor each unfinished process found across the entire bitset, an FFS, a clear-lowest-set-bit, and the shared overhead are incurred. The cost per unfinished process is $(c_F + c_C + c_u)$.\nThe total cost $C_{BS}$ is:\n$$C_{BS} = W \\cdot (c_L + c_I + c_Z) + N_{unfin} \\cdot (c_F + c_C + c_u)$$\nAgain, using linearity of expectation to find $E_{BS} = E[C_{BS}]$:\n$$E_{BS} = W \\cdot (c_L + c_I + c_Z) + E[N_{unfin}] \\cdot (c_F + c_C + c_u)$$\nWe have already established that $E[N_{unfin}] = N \\cdot p_{unfin}$. Substituting this gives:\n$$E_{BS} = W \\cdot (c_L + c_I + c_Z) + (N \\cdot p_{unfin}) \\cdot (c_F + c_C + c_u)$$\nPlugging in the given values:\n$$W = \\frac{4096}{64} = 64$$\n$$E_{BS} = 64 \\cdot (1 + 1 + 1) + (4096 \\cdot 0.1) \\cdot (3 + 1 + 2)$$\n$$E_{BS} = 64 \\cdot 3 + 409.6 \\cdot 6$$\n$$E_{BS} = 192 + 2457.6 = 2649.6$$\n\nFinally, we compute the speedup $S$:\n$$S = \\frac{E_B}{E_{BS}} = \\frac{4915.2}{2649.6}$$\n$$S \\approx 1.85507246...$$\nRounding the result to four significant figures, we get $S = 1.855$.", "answer": "$$\\boxed{1.855}$$", "id": "3622562"}, {"introduction": "In resource management, not all \"safe\" states are equally robust; some are fragile and teeter on the edge of becoming unsafe. This exercise [@problem_id:3678108] explores this concept of algorithmic robustness by analyzing a \"borderline\" safe state. You will determine the system's tolerance for small variations in a resource request, calculating a \"safety robustness margin\" that defines how much a request can change before it endangers the system's stability, providing a deeper appreciation for the nuances of system safety.", "problem": "A uniprocessor operating system uses the Banker's algorithm to avoid deadlock for three resource types, labeled $\\mathrm{A}$, $\\mathrm{B}$, and $\\mathrm{C}$. There are four processes $P_{0}, P_{1}, P_{2}, P_{3}$. The system is characterized by the standard Banker's algorithm data structures:\n\n- The current Allocation matrix $\\mathrm{Allocation}$, where $\\mathrm{Allocation}[i,j]$ is the number of instances of resource type $j$ currently allocated to process $i$.\n- The Maximum Claim matrix $\\mathrm{Max}$, where $\\mathrm{Max}[i,j]$ is the maximum number of instances of resource type $j$ that process $i$ may ever request.\n- The Available vector $\\mathrm{Available}$, where $\\mathrm{Available}[j]$ is the number of currently available instances of resource type $j$.\n\nThe Need matrix is defined by the fundamental relation of the Banker's algorithm:\n$$\n\\mathrm{Need} = \\mathrm{Max} - \\mathrm{Allocation},\n$$\nwhere subtraction is componentwise.\n\nA state is defined to be safe if there exists a sequence of all processes $\\langle i_{1}, i_{2}, \\dots, i_{n} \\rangle$ such that, letting $\\mathrm{Work}$ be initialized to $\\mathrm{Available}$, one can iteratively find a process $i_{k}$ whose remaining need satisfies $\\mathrm{Need}[i_{k}] \\le \\mathrm{Work}$ (componentwise), hypothetically allow it to finish, and then update $\\mathrm{Work} \\leftarrow \\mathrm{Work} + \\mathrm{Allocation}[i_{k}]$; iterating this for all processes succeeds. The resource-request algorithm first checks two necessary conditions for a request vector $\\mathrm{Request}_{i}$ by process $P_{i}$: (i) $\\mathrm{Request}_{i} \\le \\mathrm{Need}[i]$ and (ii) $\\mathrm{Request}_{i} \\le \\mathrm{Available}$; if both hold, it tentatively allocates $\\mathrm{Request}_{i}$ and then invokes the safety check described above.\n\nConsider the following concrete system instance (resources ordered as $(\\mathrm{A},\\mathrm{B},\\mathrm{C})$):\n\n- Total resources:\n$$\n\\mathrm{Total} = \\begin{pmatrix} 3 & 2 & 1 \\end{pmatrix}.\n$$\n\n- Current Allocation:\n$$\n\\mathrm{Allocation} = \\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix},\n$$\ncorresponding to processes $P_{0}, P_{1}, P_{2}, P_{3}$ in order.\n\n- Maximum Claim:\n$$\n\\mathrm{Max} = \\begin{pmatrix}\n2 & 0 & 0 \\\\\n1 & 2 & 0 \\\\\n3 & 1 & 1 \\\\\n3 & 2 & 1\n\\end{pmatrix}.\n$$\n\n- From these, the Need matrix is\n$$\n\\mathrm{Need} = \\mathrm{Max} - \\mathrm{Allocation} = \\begin{pmatrix}\n1 & 0 & 0 \\\\\n1 & 1 & 0 \\\\\n3 & 1 & 1 \\\\\n3 & 2 & 1\n\\end{pmatrix}.\n$$\n\n- The Available vector, consistent with conservation $\\mathrm{Total} = \\sum_{i}\\mathrm{Allocation}[i,\\cdot] + \\mathrm{Available}$, is\n$$\n\\mathrm{Available} = \\begin{pmatrix} 2 & 1 & 1 \\end{pmatrix}.\n$$\n\nProcess $P_{2}$ issues the request\n$$\n\\mathrm{Request}_{2} = \\begin{pmatrix} 1 & 1 & 1 \\end{pmatrix}.\n$$\n\nBy design, if $\\mathrm{Request}_{2}$ is granted, the resulting state is safe but with a unique safe sequence at the start. Now define the following robustness study under integer perturbations to the request: for an integer $t \\ge 0$, let\n$$\n\\mathcal{D}(t) = \\left\\{ \\delta \\in \\mathbb{Z}^{3} : \\|\\delta\\|_{\\infty} \\le t,\\ 0 \\le \\mathrm{Request}_{2} + \\delta \\le \\mathrm{Need}[2],\\ \\mathrm{Request}_{2} + \\delta \\le \\mathrm{Available} \\right\\},\n$$\nwhere inequalities are componentwise and $\\|\\delta\\|_{\\infty} = \\max\\{|\\delta_{A}|, |\\delta_{B}|, |\\delta_{C}|\\}$. Define the safety robustness margin $t^{\\ast}$ to be the largest integer $t$ such that for all $\\delta \\in \\mathcal{D}(t)$, granting $\\mathrm{Request}_{2} + \\delta$ yields a safe state (according to the safety definition above).\n\nCompute $t^{\\ast}$. The final answer must be a single integer. No rounding is required.", "solution": "The problem asks for the safety robustness margin, $t^{\\ast}$, which is the largest integer $t \\ge 0$ such that for any valid integer perturbation $\\delta \\in \\mathbb{Z}^3$ with $\\|\\delta\\|_{\\infty} \\le t$, granting the modified request $\\mathrm{Request}_2' = \\mathrm{Request}_2 + \\delta$ to process $P_2$ results in a safe state.\n\nFirst, let's determine the set of all possible valid perturbations $\\delta = \\begin{pmatrix} \\delta_A & \\delta_B & \\delta_C \\end{pmatrix}$ by applying the constraints from the problem definition. The modified request $\\mathrm{Request}_2' = \\mathrm{Request}_2 + \\delta$ must satisfy:\n$1$. $0 \\le \\mathrm{Request}_2' \\implies \\begin{pmatrix} 0 & 0 & 0 \\end{pmatrix} \\le \\begin{pmatrix} 1 & 1 & 1 \\end{pmatrix} + \\delta$. This gives componentwise inequalities:\n$0 \\le 1 + \\delta_A \\Rightarrow \\delta_A \\ge -1$.\n$0 \\le 1 + \\delta_B \\Rightarrow \\delta_B \\ge -1$.\n$0 \\le 1 + \\delta_C \\Rightarrow \\delta_C \\ge -1$.\n\n$2$. $\\mathrm{Request}_2' \\le \\mathrm{Need}[2] \\implies \\begin{pmatrix} 1 & 1 & 1 \\end{pmatrix} + \\delta \\le \\begin{pmatrix} 3 & 1 & 1 \\end{pmatrix}$. This gives:\n$1 + \\delta_A \\le 3 \\Rightarrow \\delta_A \\le 2$.\n$1 + \\delta_B \\le 1 \\Rightarrow \\delta_B \\le 0$.\n$1 + \\delta_C \\le 1 \\Rightarrow \\delta_C \\le 0$.\n\n$3$. $\\mathrm{Request}_2' \\le \\mathrm{Available} \\implies \\begin{pmatrix} 1 & 1 & 1 \\end{pmatrix} + \\delta \\le \\begin{pmatrix} 2 & 1 & 1 \\end{pmatrix}$. This gives:\n$1 + \\delta_A \\le 2 \\Rightarrow \\delta_A \\le 1$.\n$1 + \\delta_B \\le 1 \\Rightarrow \\delta_B \\le 0$.\n$1 + \\delta_C \\le 1 \\Rightarrow \\delta_C \\le 0$.\n\nCombining all constraints on the integer components of $\\delta$:\n$\\delta_A \\in [-1, 1]$, so $\\delta_A \\in \\{-1, 0, 1\\}$.\n$\\delta_B \\in [-1, 0]$, so $\\delta_B \\in \\{-1, 0\\}$.\n$\\delta_C \\in [-1, 0]$, so $\\delta_C \\in \\{-1, 0\\}$.\nThe set $\\mathcal{D}(t)$ consists of all such $\\delta$ that also satisfy $\\|\\delta\\|_{\\infty} \\le t$.\n\nOur goal is to find the largest integer $t$ for which the system state is safe for *all* $\\delta \\in \\mathcal{D}(t)$. Let's analyze the system state after hypothetically granting $\\mathrm{Request}_2' = \\mathrm{Request}_2 + \\delta$.\nThe system state updates as follows:\n$\\mathrm{Available}' = \\mathrm{Available} - \\mathrm{Request}_2' = \\begin{pmatrix} 2 & 1 & 1 \\end{pmatrix} - \\begin{pmatrix} 1+\\delta_A & 1+\\delta_B & 1+\\delta_C \\end{pmatrix} = \\begin{pmatrix} 1-\\delta_A & -\\delta_B & -\\delta_C \\end{pmatrix}$.\n$\\mathrm{Allocation}'[2] = \\mathrm{Allocation}[2] + \\mathrm{Request}_2' = \\begin{pmatrix} 0 & 0 & 0 \\end{pmatrix} + \\begin{pmatrix} 1+\\delta_A & 1+\\delta_B & 1+\\delta_C \\end{pmatrix} = \\begin{pmatrix} 1+\\delta_A & 1+\\delta_B & 1+\\delta_C \\end{pmatrix}$.\n$\\mathrm{Need}'[2] = \\mathrm{Need}[2] - \\mathrm{Request}_2' = \\begin{pmatrix} 3 & 1 & 1 \\end{pmatrix} - \\begin{pmatrix} 1+\\delta_A & 1+\\delta_B & 1+\\delta_C \\end{pmatrix} = \\begin{pmatrix} 2-\\delta_A & -\\delta_B & -\\delta_C \\end{pmatrix}$.\nThe `Allocation` and `Need` for processes $P_0$, $P_1$, and $P_3$ are unchanged.\n\nThe safety algorithm is then invoked on this new state, starting with $\\mathrm{Work} = \\mathrm{Available}'$.\n\nCase $t=0$:\nFor $t=0$, the constraint is $\\|\\delta\\|_{\\infty} \\le 0$, which implies $\\max(|\\delta_A|, |\\delta_B|, |\\delta_C|) \\le 0$. Since absolute values are non-negative, this forces $\\delta_A=0$, $\\delta_B=0$, $\\delta_C=0$. So, $\\mathcal{D}(0) = \\{\\begin{pmatrix} 0 & 0 & 0 \\end{pmatrix}\\}$. We only need to check the safety for this single perturbation, which corresponds to the original unperturbed request $\\mathrm{Request}_2 = \\begin{pmatrix} 1 & 1 & 1 \\end{pmatrix}$.\n\nFor $\\delta=\\begin{pmatrix} 0 & 0 & 0 \\end{pmatrix}$:\n$\\mathrm{Available}' = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}$.\n$\\mathrm{Allocation}' = \\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n1 & 1 & 1 \\\\\n0 & 0 & 0\n\\end{pmatrix}$.\n$\\mathrm{Need}' = \\begin{pmatrix}\n1 & 0 & 0 \\\\\n1 & 1 & 0 \\\\\n2 & 0 & 0 \\\\\n3 & 2 & 1\n\\end{pmatrix}$.\n\nSafety Check for $t=0$:\nLet $\\mathrm{Work} = \\mathrm{Available}' = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}$.\n1. Check process needs:\n   - For $P_0$: $\\mathrm{Need}'[0] = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix} \\le \\mathrm{Work}$. Yes. Let $P_0$ finish.\n   - Update $\\mathrm{Work} = \\mathrm{Work} + \\mathrm{Allocation}'[0] = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix} + \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 2 & 0 & 0 \\end{pmatrix}$.\n2. Remaining processes: $\\{P_1, P_2, P_3\\}$.\n   - For $P_2$: $\\mathrm{Need}'[2] = \\begin{pmatrix} 2 & 0 & 0 \\end{pmatrix} \\le \\mathrm{Work}$. Yes. Let $P_2$ finish.\n   - Update $\\mathrm{Work} = \\mathrm{Work} + \\mathrm{Allocation}'[2] = \\begin{pmatrix} 2 & 0 & 0 \\end{pmatrix} + \\begin{pmatrix} 1 & 1 & 1 \\end{pmatrix} = \\begin{pmatrix} 3 & 1 & 1 \\end{pmatrix}$.\n3. Remaining processes: $\\{P_1, P_3\\}$.\n   - For $P_1$: $\\mathrm{Need}'[1] = \\begin{pmatrix} 1 & 1 & 0 \\end{pmatrix} \\le \\mathrm{Work}$. Yes. Let $P_1$ finish.\n   - Update $\\mathrm{Work} = \\mathrm{Work} + \\mathrm{Allocation}'[1] = \\begin{pmatrix} 3 & 1 & 1 \\end{pmatrix} + \\begin{pmatrix} 0 & 1 & 0 \\end{pmatrix} = \\begin{pmatrix} 3 & 2 & 1 \\end{pmatrix}$.\n4. Remaining process: $\\{P_3\\}$.\n   - For $P_3$: $\\mathrm{Need}'[3] = \\begin{pmatrix} 3 & 2 & 1 \\end{pmatrix} \\le \\mathrm{Work}$. Yes. Let $P_3$ finish.\nAll processes can finish. The state is safe. Thus, for all $\\delta \\in \\mathcal{D}(0)$, the state is safe. This means $t^{\\ast} \\ge 0$.\n\nCase $t=1$:\nFor $t=1$, the constraint is $\\|\\delta\\|_{\\infty} \\le 1$. The set $\\mathcal{D}(1)$ includes all integer $\\delta$ vectors with components satisfying $\\delta_A \\in \\{-1, 0, 1\\}$, $\\delta_B \\in \\{-1, 0\\}$, and $\\delta_C \\in \\{-1, 0\\}$. For the system to be robust for $t=1$, the resulting state must be safe for all such perturbations. If we can find just one $\\delta \\in \\mathcal{D}(1)$ that leads to an unsafe state, then $t=1$ is not the answer.\n\nAn unsafe state is more likely if the initial $\\mathrm{Work}$ vector (i.e., $\\mathrm{Available}'$) is smaller.\n$\\mathrm{Available}' = \\begin{pmatrix} 1-\\delta_A & -\\delta_B & -\\delta_C \\end{pmatrix}$.\nTo minimize the components of this vector, we should maximize the components of $\\delta$.\nLet's choose the \"worst-case\" perturbation from $\\mathcal{D}(1)$ by picking the largest allowed values for each component: $\\delta = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}$.\nThis $\\delta$ is in $\\mathcal{D}(1)$ since $\\|\\delta\\|_{\\infty} = \\max(|1|, |0|, |0|) = 1 \\le 1$.\n\nSafety Check for $\\delta = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}$:\nThe modified request is $\\mathrm{Request}_2' = \\begin{pmatrix} 1 & 1 & 1 \\end{pmatrix} + \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 2 & 1 & 1 \\end{pmatrix}$.\nAfter granting this request:\n$\\mathrm{Available}' = \\mathrm{Available} - \\mathrm{Request}_2' = \\begin{pmatrix} 2 & 1 & 1 \\end{pmatrix} - \\begin{pmatrix} 2 & 1 & 1 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 0 \\end{pmatrix}$.\nThe safety algorithm starts with $\\mathrm{Work} = \\begin{pmatrix} 0 & 0 & 0 \\end{pmatrix}$.\nThe updated need for $P_2$ is $\\mathrm{Need}'[2] = \\mathrm{Need}[2] - \\mathrm{Request}_2' = \\begin{pmatrix} 3 & 1 & 1 \\end{pmatrix} - \\begin{pmatrix} 2 & 1 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}$.\nThe needs of other processes are unchanged:\n$\\mathrm{Need}'[0] = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}$\n$\\mathrm{Need}'[1] = \\begin{pmatrix} 1 & 1 & 0 \\end{pmatrix}$\n$\\mathrm{Need}'[3] = \\begin{pmatrix} 3 & 2 & 1 \\end{pmatrix}$\n\nWe check if any process $P_i$ can run, i.e., if $\\mathrm{Need}'[i] \\le \\mathrm{Work}$.\n- $P_0$: $\\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix} \\le \\begin{pmatrix} 0 & 0 & 0 \\end{pmatrix}$. False.\n- $P_1$: $\\begin{pmatrix} 1 & 1 & 0 \\end{pmatrix} \\le \\begin{pmatrix} 0 & 0 & 0 \\end{pmatrix}$. False.\n- $P_2$: $\\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix} \\le \\begin{pmatrix} 0 & 0 & 0 \\end{pmatrix}$. False.\n- $P_3$: $\\begin{pmatrix} 3 & 2 & 1 \\end{pmatrix} \\le \\begin{pmatrix} 0 & 0 & 0 \\end{pmatrix}$. False.\n\nNo process can secure its needed resources. The system is in an unsafe state, which can lead to deadlock.\nSince we have found a perturbation $\\delta \\in \\mathcal{D}(1)$ for which granting the request is not safe, the condition for $t=1$ is not met.\n\nTherefore, $t^{\\ast}$ must be less than $1$. As $t^{\\ast}$ must be a non-negative integer and we have shown that $t=0$ works, the largest possible integer value for $t^{\\ast}$ is $0$.", "answer": "$$\n\\boxed{0}\n$$", "id": "3678108"}]}