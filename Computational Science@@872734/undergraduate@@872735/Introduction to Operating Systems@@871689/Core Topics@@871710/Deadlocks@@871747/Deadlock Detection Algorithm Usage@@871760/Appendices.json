{"hands_on_practices": [{"introduction": "This exercise provides a foundational, step-by-step simulation of how deadlocks form and are detected in systems with single-instance resources. By manually tracing lock requests and building the corresponding Wait-For Graph (WFG), you will gain a concrete, visual understanding of the circular wait condition. This practice is essential for visualizing how a sequence of seemingly harmless events can lead to a complete system halt, a core concept in concurrent programming [@problem_id:3632429].", "problem": "An operating system (OS) manages $n=6$ concurrent threads $\\{T_1,T_2,T_3,T_4,T_5,T_6\\}$ contending for six distinct non-reentrant mutual-exclusion locks $\\{\\ell_A,\\ell_B,\\ell_C,\\ell_D,\\ell_E,\\ell_F\\}$, all initially free. The OS uses a deadlock detection algorithm based on the Wait-For Graph (WFG), which has a directed edge $T_i \\to T_j$ if and only if thread $T_i$ is waiting for some lock currently held by thread $T_j$. A deadlock is present if and only if the WFG contains at least one directed cycle. When a thread is blocked, it continues to hold all locks it previously acquired. Upon termination of a thread, the OS immediately releases all locks held by that thread.\n\nProcess the following event sequence in order. If a lock requested is free, the requesting thread acquires it; otherwise, the thread blocks and waits for its availability.\n\n- Event $1$: $T_1$ requests $\\ell_A$ and acquires $\\ell_A$.\n- Event $2$: $T_2$ requests $\\ell_B$ and acquires $\\ell_B$.\n- Event $3$: $T_3$ requests $\\ell_C$ and acquires $\\ell_C$.\n- Event $4$: $T_1$ requests $\\ell_B$; since $\\ell_B$ is held by $T_2$, $T_1$ blocks waiting for $\\ell_B$.\n- Event $5$: $T_2$ requests $\\ell_C$; since $\\ell_C$ is held by $T_3$, $T_2$ blocks waiting for $\\ell_C$.\n- Event $6$: $T_3$ requests $\\ell_A$; since $\\ell_A$ is held by $T_1$, $T_3$ blocks waiting for $\\ell_A$.\n- Event $7$: $T_4$ requests $\\ell_D$ and acquires $\\ell_D$.\n- Event $8$: $T_5$ requests $\\ell_E$ and acquires $\\ell_E$.\n- Event $9$: $T_6$ requests $\\ell_F$ and acquires $\\ell_F$.\n- Event $10$: $T_4$ requests $\\ell_E$; since $\\ell_E$ is held by $T_5$, $T_4$ blocks waiting for $\\ell_E$.\n- Event $11$: $T_5$ requests $\\ell_F$; since $\\ell_F$ is held by $T_6$, $T_5$ blocks waiting for $\\ell_F$.\n- Event $12$: $T_6$ requests $\\ell_D$; since $\\ell_D$ is held by $T_4$, $T_6$ blocks waiting for $\\ell_D$.\n\nAfter processing through Event $12$, construct the Wait-For Graph (WFG) implied by the resulting state. Confirm whether the specific cycle $C: T_1 \\to T_2 \\to T_3 \\to T_1$ exists in the WFG at this time. Then, assuming that terminating any thread immediately releases all locks it holds and that no further events occur, compute the minimal number $k$ of threads that must be terminated to ensure that the system is free of deadlock and can make progress. Provide only the value of $k$ as your final answer. Give your answer exactly as an integer with no rounding.", "solution": "The problem requires us to analyze a sequence of events in a multithreaded environment to determine the state of deadlock and the minimum number of threads to terminate to resolve it. The analysis will proceed by first tracking the state of locks and threads, then constructing the Wait-For Graph (WFG), identifying cycles within it, and finally determining the minimum number of vertices to remove to make the graph acyclic.\n\nFirst, we trace the state of the system through the given sequence of $12$ events. The state of the system is defined by which threads hold which locks and which threads are waiting for other threads.\n\n- **Initial State**: All six locks $\\{\\ell_A, \\ell_B, \\ell_C, \\ell_D, \\ell_E, \\ell_F\\}$ are free. All six threads $\\{T_1, T_2, T_3, T_4, T_5, T_6\\}$ are ready.\n\n- **Events $1-3$**: Threads $T_1$, $T_2$, and $T_3$ acquire locks $\\ell_A$, $\\ell_B$, and $\\ell_C$ respectively.\n  - After Event $1$: $T_1$ holds $\\ell_A$.\n  - After Event $2$: $T_2$ holds $\\ell_B$.\n  - After Event $3$: $T_3$ holds $\\ell_C$.\n\n- **Events $4-6$**: A set of circular dependencies is established among $T_1, T_2, T_3$.\n  - Event $4$: $T_1$ requests $\\ell_B$, which is held by $T_2$. $T_1$ blocks. This establishes a wait-for dependency: $T_1 \\to T_2$.\n  - Event $5$: $T_2$ requests $\\ell_C$, which is held by $T_3$. $T_2$ blocks. This establishes a wait-for dependency: $T_2 \\to T_3$.\n  - Event $6$: $T_3$ requests $\\ell_A$, which is held by $T_1$. $T_3$ blocks. This establishes a wait-for dependency: $T_3 \\to T_1$.\n\n- **Events $7-9$**: Threads $T_4$, $T_5$, and $T_6$ acquire locks $\\ell_D$, $\\ell_E$, and $\\ell_F$ respectively.\n  - After Event $7$: $T_4$ holds $\\ell_D$.\n  - After Event $8$: $T_5$ holds $\\ell_E$.\n  - After Event $9$: $T_6$ holds $\\ell_F$.\n\n- **Events $10-12$**: A second set of circular dependencies is established among $T_4, T_5, T_6$.\n  - Event $10$: $T_4$ requests $\\ell_E$, which is held by $T_5$. $T_4$ blocks. This establishes a wait-for dependency: $T_4 \\to T_5$.\n  - Event $11$: $T_5$ requests $\\ell_F$, which is held by $T_6$. $T_5$ blocks. This establishes a wait-for dependency: $T_5 \\to T_6$.\n  - Event $12$: $T_6$ requests $\\ell_D$, which is held by $T_4$. $T_6$ blocks. This establishes a wait-for dependency: $T_6 \\to T_4$.\n\nAfter processing all $12$ events, the state of the system is as follows:\n- **Lock Holders**:\n  - $T_1$ holds $\\ell_A$.\n  - $T_2$ holds $\\ell_B$.\n  - $T_3$ holds $\\ell_C$.\n  - $T_4$ holds $\\ell_D$.\n  - $T_5$ holds $\\ell_E$.\n  - $T_6$ holds $\\ell_F$.\n- **Waiting Threads**:\n  - $T_1$ is waiting for $\\ell_B$ (held by $T_2$).\n  - $T_2$ is waiting for $\\ell_C$ (held by $T_3$).\n  - $T_3$ is waiting for $\\ell_A$ (held by $T_1$).\n  - $T_4$ is waiting for $\\ell_E$ (held by $T_5$).\n  - $T_5$ is waiting for $\\ell_F$ (held by $T_6$).\n  - $T_6$ is waiting for $\\ell_D$ (held by $T_4$).\n\nNext, we construct the Wait-For Graph, $G=(V, E)$, where the set of vertices $V$ is the set of threads, and a directed edge $(T_i, T_j) \\in E$ exists if thread $T_i$ is waiting for a lock held by thread $T_j$.\n- Vertex set: $V = \\{T_1, T_2, T_3, T_4, T_5, T_6\\}$.\n- Edge set: $E = \\{(T_1, T_2), (T_2, T_3), (T_3, T_1), (T_4, T_5), (T_5, T_6), (T_6, T_4)\\}$.\n\nA deadlock exists if and only if the WFG contains at least one directed cycle. We examine the graph for cycles.\nThe edge set clearly defines two distinct cycles:\n1.  Cycle $C_1$: $T_1 \\to T_2 \\to T_3 \\to T_1$. This cycle is formed by the edges $(T_1, T_2)$, $(T_2, T_3)$, and $(T_3, T_1)$.\n2.  Cycle $C_2$: $T_4 \\to T_5 \\to T_6 \\to T_4$. This cycle is formed by the edges $(T_4, T_5)$, $(T_5, T_6)$, and $(T_6, T_4)$.\n\nThe problem explicitly asks to confirm the existence of the cycle $C: T_1 \\to T_2 \\to T_3 \\to T_1$. Based on our construction of the WFG, this cycle is present and is one of the two deadlocks in the system.\n\nThe final task is to compute the minimal number $k$ of threads that must be terminated to eliminate all deadlocks. Terminating a thread corresponds to removing its corresponding vertex from the WFG. To break all cycles in a directed graph, we must find a minimum feedback vertex set, which is a smallest set of vertices whose removal leaves the graph acyclic.\n\nThe WFG in this problem consists of two vertex-disjoint components, each being a simple cycle.\n- The first component involves vertices $\\{T_1, T_2, T_3\\}$ and forms cycle $C_1$.\n- The second component involves vertices $\\{T_4, T_5, T_6\\}$ and forms cycle $C_2$.\n\nSince the two cycles are vertex-disjoint, removing a vertex from one cycle does not affect the other. Therefore, to break all cycles, we must break each cycle independently.\n- To break cycle $C_1$, we must terminate at least one thread from the set $\\{T_1, T_2, T_3\\}$. The minimum number required is $1$.\n- To break cycle $C_2$, we must terminate at least one thread from the set $\\{T_4, T_5, T_6\\}$. The minimum number required is $1$.\n\nThe total minimum number of threads to terminate, $k$, is the sum of the minimums required for each disjoint cycle.\n$$k = (\\text{min threads for } C_1) + (\\text{min threads for } C_2) = 1 + 1 = 2$$\nFor example, terminating threads $T_1$ and $T_4$ would be one possible minimal set of terminations. Terminating $T_1$ releases $\\ell_A$, breaking cycle $C_1$. Terminating $T_4$ releases $\\ell_D$, breaking cycle $C_2$. The resulting system would be free of deadlocks.\n\nThus, the minimal number of threads that must be terminated is $2$.", "answer": "$$\\boxed{2}$$", "id": "3632429"}, {"introduction": "While the Wait-For Graph is intuitive, many systems manage resources with multiple identical instances. This requires a more general detection method, which you will practice here. Using the standard matrix-based algorithm, you will analyze a system's state to determine which processes are part of a deadlock, giving you hands-on experience with the same logic used in many commercial operating systems [@problem_id:3632410].", "problem": "Consider an Operating System (OS) with $n=6$ processes $\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$ competing for $m=4$ resource types $\\{R_1,R_2,R_3,R_4\\}$, each with multiple instances. The system state is characterized by the resource allocation matrix $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$, the outstanding request matrix $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$, and the currently available instances vector $\\mathbf{Available} \\in \\mathbb{Z}^{4}$, all given below. Each row corresponds to a process $P_i$, and each column corresponds to a resource type $R_j$.\n\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 2 & 0 & 0 \\\\\n1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 1 \\\\\n0 & 1 & 0 & 0\n\\end{pmatrix},\n\\quad\n\\mathbf{Request} =\n\\begin{pmatrix}\n0 & 0 & 1 & 0 \\\\\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 1 & 0 & 0\n\\end{pmatrix},\n\\quad\n\\mathbf{Available} =\n\\begin{pmatrix}\n1 & 0 & 1 & 0\n\\end{pmatrix}.\n$$\n\nUse the classical deadlock detection algorithm for multiple-instance resources that iteratively searches for an unfinished process $P_i$ whose request vector $Request_i$ satisfies $Request_i \\leq Work$ (with $Work$ initialized to $\\mathbf{Available}$), and when found, treats $P_i$ as able to complete and release its allocation, updating $Work \\leftarrow Work + Allocation_i$. Continue until no such $P_i$ exists; the processes that remain unfinished at that point are deemed unfinishable.\n\nDefine the quantity $S$ to be the sum of the indices of all unfinishable processes, i.e., if the unfinishable set is $\\{P_{i_1}, P_{i_2}, \\dots\\}$ then $S = i_1 + i_2 + \\dots$. Compute $S$. Provide your final answer as an exact integer. No rounding is required.", "solution": "The task is to determine the set of unfinishable processes in a system with $n=6$ processes and $m=4$ resource types. The state of the system is given by the $\\mathbf{Allocation}$ matrix, the $\\mathbf{Request}$ matrix, and the $\\mathbf{Available}$ vector.\n\nThe givens are:\n- Number of processes: $n=6$, $\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$.\n- Number of resource types: $m=4$, $\\{R_1,R_2,R_3,R_4\\}$.\n- Allocation matrix $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$:\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 2 & 0 & 0 \\\\\n1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 1 \\\\\n0 & 1 & 0 & 0\n\\end{pmatrix}\n$$\n- Request matrix $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$:\n$$\n\\mathbf{Request} =\n\\begin{pmatrix}\n0 & 0 & 1 & 0 \\\\\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 1 & 0 & 0\n\\end{pmatrix}\n$$\n- Available vector $\\mathbf{Available} \\in \\mathbb{Z}^{4}$:\n$$\n\\mathbf{Available} = \\begin{pmatrix} 1 & 0 & 1 & 0 \\end{pmatrix}\n$$\n\nWe apply the deadlock detection algorithm. Let $\\mathbf{Work}$ be a vector of length $m$ and $\\mathbf{Finish}$ be a boolean vector of length $n$. The vector inequality $\\mathbf{A} \\leq \\mathbf{B}$ holds if and only if $A_k \\leq B_k$ for all components $k$.\n\n**Step 1: Initialization**\nInitialize $\\mathbf{Work}$ to $\\mathbf{Available}$ and $\\mathbf{Finish}_i$ to false for all processes $i = 0, \\dots, 5$.\n$$ \\mathbf{Work} = \\mathbf{Available} = \\begin{pmatrix} 1 & 0 & 1 & 0 \\end{pmatrix} $$\n$$ \\mathbf{Finish} = \\begin{pmatrix} \\text{false} & \\text{false} & \\text{false} & \\text{false} & \\text{false} & \\text{false} \\end{pmatrix} $$\n\n**Step 2: Iterative Search and Update**\nThe algorithm proceeds by finding an index $i$ such that $\\mathbf{Finish}_i$ is false and its request vector $\\mathbf{Request}_i \\leq \\mathbf{Work}$. If found, the process can theoretically finish, so we release its resources by updating $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_i$ and setting $\\mathbf{Finish}_i \\leftarrow \\text{true}$. This process is repeated until no such process can be found.\n\n**Iteration 1:**\nWe search for a process $P_i$ with $\\mathbf{Finish}_i = \\text{false}$ and $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 1 & 0 & 1 & 0 \\end{pmatrix}$.\n- $P_0$: $\\mathbf{Request}_0 = \\begin{pmatrix} 0 & 0 & 1 & 0 \\end{pmatrix} \\leq \\begin{pmatrix} 1 & 0 & 1 & 0 \\end{pmatrix}$. This condition is met.\nLet's select $P_0$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_0 = \\begin{pmatrix} 1 & 0 & 1 & 0 \\end{pmatrix} + \\begin{pmatrix} 1 & 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 2 & 0 & 1 & 1 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_0 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 2 & 0 & 1 & 1 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true} & \\text{false} & \\text{false} & \\text{false} & \\text{false} & \\text{false} \\end{pmatrix}$.\n\n**Iteration 2:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2 & 0 & 1 & 1 \\end{pmatrix}$.\n- $P_1$: $\\mathbf{Request}_1 = \\begin{pmatrix} 1 & 0 & 0 & 0 \\end{pmatrix} \\leq \\begin{pmatrix} 2 & 0 & 1 & 1 \\end{pmatrix}$. This condition is met.\nLet's select $P_1$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_1 = \\begin{pmatrix} 2 & 0 & 1 & 1 \\end{pmatrix} + \\begin{pmatrix} 0 & 0 & 1 & 0 \\end{pmatrix} = \\begin{pmatrix} 2 & 0 & 2 & 1 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_1 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 2 & 0 & 2 & 1 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true} & \\text{true} & \\text{false} & \\text{false} & \\text{false} & \\text{false} \\end{pmatrix}$.\n\n**Iteration 3:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2 & 0 & 2 & 1 \\end{pmatrix}$.\n- $P_2$: $\\mathbf{Request}_2 = \\begin{pmatrix} 0 & 1 & 0 & 0 \\end{pmatrix}$. This is not $\\leq \\mathbf{Work}$ because for the second resource, $1 > 0$.\n- $P_3$: $\\mathbf{Request}_3 = \\begin{pmatrix} 0 & 0 & 0 & 0 \\end{pmatrix} \\leq \\begin{pmatrix} 2 & 0 & 2 & 1 \\end{pmatrix}$. This condition is met.\nLet's select $P_3$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_3 = \\begin{pmatrix} 2 & 0 & 2 & 1 \\end{pmatrix} + \\begin{pmatrix} 1 & 0 & 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 3 & 0 & 2 & 1 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_3 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 3 & 0 & 2 & 1 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true} & \\text{true} & \\text{false} & \\text{true} & \\text{false} & \\text{false} \\end{pmatrix}$.\n\n**Iteration 4:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3 & 0 & 2 & 1 \\end{pmatrix}$.\n- $P_2$: $\\mathbf{Request}_2$ is still not satisfiable.\n- $P_4$: $\\mathbf{Request}_4 = \\begin{pmatrix} 0 & 0 & 0 & 1 \\end{pmatrix} \\leq \\begin{pmatrix} 3 & 0 & 2 & 1 \\end{pmatrix}$. This condition is met.\nLet's select $P_4$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_4 = \\begin{pmatrix} 3 & 0 & 2 & 1 \\end{pmatrix} + \\begin{pmatrix} 0 & 0 & 1 & 1 \\end{pmatrix} = \\begin{pmatrix} 3 & 0 & 3 & 2 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_4 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 3 & 0 & 3 & 2 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true} & \\text{true} & \\text{false} & \\text{true} & \\text{true} & \\text{false} \\end{pmatrix}$.\n\n**Iteration 5:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3 & 0 & 3 & 2 \\end{pmatrix}$. The remaining unfinished processes are $P_2$ and $P_5$.\n- $P_2$: $\\mathbf{Request}_2 = \\begin{pmatrix} 0 & 1 & 0 & 0 \\end{pmatrix}$. This is not $\\leq \\mathbf{Work}$ because for $R_2$, $1 > 0$.\n- $P_5$: $\\mathbf{Request}_5 = \\begin{pmatrix} 0 & 1 & 0 & 0 \\end{pmatrix}$. This is not $\\leq \\mathbf{Work}$ because for $R_2$, $1 > 0$.\n\n**Step 3: Termination**\nNo remaining unfinished process can have its request satisfied with the current $\\mathbf{Work}$ vector. The algorithm terminates.\n\n**Step 4: Identify Unfinishable Processes and Calculate S**\nThe processes for which $\\mathbf{Finish}_i$ remains false are considered unfinishable. From the final $\\mathbf{Finish}$ vector $\\begin{pmatrix} \\text{true} & \\text{true} & \\text{false} & \\text{true} & \\text{true} & \\text{false} \\end{pmatrix}$, the unfinishable processes are $\\{P_2, P_5\\}$.\n\nThe problem defines $S$ as the sum of the indices of all unfinishable processes.\n$$ S = 2 + 5 = 7 $$\nThe physical reason for the deadlock is that both $P_2$ and $P_5$ are requesting an instance of resource $R_2$. There are $0$ instances of $R_2$ available, and no other process that can finish holds any instances of $R_2$ to release. Thus, $P_2$ and $P_5$ will wait indefinitely.", "answer": "$$\\boxed{7}$$", "id": "3632410"}, {"introduction": "Simply detecting a deadlock is only half the battle; the system must also recover. This problem bridges the gap between detection and recovery by tasking you with not only identifying a deadlock using the matrix-based algorithm but also determining the most efficient way to break it. By calculating the minimal number of processes to terminate, you will explore the trade-offs involved in restoring system progress, a critical aspect of robust OS design [@problem_id:3632450].", "problem": "An Operating System (OS) manages $n=5$ processes $P_1,P_2,P_3,P_4,P_5$ and $m=3$ resource types $R_1,R_2,R_3$, each with multiple instances. The system uses the standard deadlock detection algorithm for multiple instances of resources: initialize the work vector $\\mathbf{Work}$ to the available vector $\\mathbf{Available}$ and, iteratively, if there exists a process $P_i$ whose outstanding request vector $\\mathbf{Q}_i$ satisfies $\\mathbf{Q}_i \\leq \\mathbf{Work}$ (componentwise), then treat $P_i$ as able to complete, release its allocated resources back to $\\mathbf{Work}$, and continue; if no such $P_i$ exists, the remaining processes are in deadlock (equivalently, the wait-for graph contains a cycle).\n\nConsider the following configuration, given as the total instances vector, the allocation matrix, and the outstanding request matrix:\n$$\n\\mathbf{T}=(6,5,5),\n$$\n$$\nA=\\begin{pmatrix}\n2 & 0 & 1 \\\\\n1 & 2 & 0 \\\\\n1 & 1 & 2 \\\\\n1 & 1 & 1 \\\\\n1 & 1 & 1\n\\end{pmatrix}\n\\quad\\text{for }(P_1,\\dots,P_5),\n$$\n$$\nQ=\\begin{pmatrix}\n1 & 1 & 0 \\\\\n0 & 1 & 1 \\\\\n1 & 0 & 1 \\\\\n0 & 0 & 1 \\\\\n1 & 0 & 0\n\\end{pmatrix}\n\\quad\\text{for }(P_1,\\dots,P_5).\n$$\nAssume that terminating any process $P_i$ immediately returns its allocated resources $\\mathbf{A}_i$ to $\\mathbf{Available}$.\n\nUsing only the fundamental definitions of deadlock, resource allocation with multiple instances, and the described detection algorithmâ€™s $\\mathbf{Available}$-vector step, determine the minimal number $k$ of processes that must be terminated so that, starting from the updated $\\mathbf{Available}$ vector after these terminations, the detection algorithm can find an order in which all remaining processes can complete without deadlock. Your final answer must be a single integer; no rounding is required.", "solution": "The problem asks for the minimum number of processes $k$ that must be terminated to resolve a deadlock in a system with $n=5$ processes and $m=3$ resource types. The state of the system is given by the total resource instances, the allocation matrix, and the request matrix.\n\nFirst, we define the given vectors and matrices.\nThe number of processes is $n=5$, labeled $P_1, P_2, P_3, P_4, P_5$.\nThe number of resource types is $m=3$, labeled $R_1, R_2, R_3$.\nThe total instances vector for resources $(R_1, R_2, R_3)$ is $\\mathbf{T} = (6, 5, 5)$.\nThe allocation matrix $A$ specifies the resources held by each process. The $i$-th row, $\\mathbf{A}_i$, corresponds to process $P_i$.\n$$\nA=\\begin{pmatrix}\n2 & 0 & 1 \\\\\n1 & 2 & 0 \\\\\n1 & 1 & 2 \\\\\n1 & 1 & 1 \\\\\n1 & 1 & 1\n\\end{pmatrix}\n\\implies\n\\begin{cases}\n\\mathbf{A}_1 = (2, 0, 1) \\\\\n\\mathbf{A}_2 = (1, 2, 0) \\\\\n\\mathbf{A}_3 = (1, 1, 2) \\\\\n\\mathbf{A}_4 = (1, 1, 1) \\\\\n\\mathbf{A}_5 = (1, 1, 1)\n\\end{cases}\n$$\nThe request matrix $Q$ specifies the outstanding resource requests for each process. The $i$-th row, $\\mathbf{Q}_i$, corresponds to process $P_i$.\n$$\nQ=\\begin{pmatrix}\n1 & 1 & 0 \\\\\n0 & 1 & 1 \\\\\n1 & 0 & 1 \\\\\n0 & 0 & 1 \\\\\n1 & 0 & 0\n\\end{pmatrix}\n\\implies\n\\begin{cases}\n\\mathbf{Q}_1 = (1, 1, 0) \\\\\n\\mathbf{Q}_2 = (0, 1, 1) \\\\\n\\mathbf{Q}_3 = (1, 0, 1) \\\\\n\\mathbf{Q}_4 = (0, 0, 1) \\\\\n\\mathbf{Q}_5 = (1, 0, 0)\n\\end{cases}\n$$\n\nNext, we determine the initial number of available resources. The total allocated resources for each type is the sum of the corresponding column in the allocation matrix $A$.\nTotal allocated vector $\\mathbf{Alloc} = \\sum_{i=1}^{5} \\mathbf{A}_i$.\n$$\n\\mathbf{Alloc} = (2+1+1+1+1, \\quad 0+2+1+1+1, \\quad 1+0+2+1+1) = (6, 5, 5)\n$$\nThe available resources vector $\\mathbf{Available}$ is the total instances minus the total allocated.\n$$\n\\mathbf{Available} = \\mathbf{T} - \\mathbf{Alloc} = (6, 5, 5) - (6, 5, 5) = (0, 0, 0)\n$$\n\nNow, we apply the deadlock detection algorithm to the initial state. The algorithm initializes a work vector $\\mathbf{Work} = \\mathbf{Available}$ and searches for a process $P_i$ whose request $\\mathbf{Q}_i$ can be satisfied, i.e., $\\mathbf{Q}_i \\leq \\mathbf{Work}$.\nInitially, $\\mathbf{Work} = (0, 0, 0)$. We check each process:\n- $P_1$: $\\mathbf{Q}_1 = (1, 1, 0)$. Is $(1, 1, 0) \\leq (0, 0, 0)$? False.\n- $P_2$: $\\mathbf{Q}_2 = (0, 1, 1)$. Is $(0, 1, 1) \\leq (0, 0, 0)$? False.\n- $P_3$: $\\mathbf{Q}_3 = (1, 0, 1)$. Is $(1, 0, 1) \\leq (0, 0, 0)$? False.\n- $P_4$: $\\mathbf{Q}_4 = (0, 0, 1)$. Is $(0, 0, 1) \\leq (0, 0, 0)$? False.\n- $P_5$: $\\mathbf{Q}_5 = (1, 0, 0)$. Is $(1, 0, 0) \\leq (0, 0, 0)$? False.\nNo process can have its request satisfied. Therefore, the algorithm terminates, and all five processes are in a deadlock state. This confirms that the number of processes to terminate, $k$, must be at least $1$.\n\nWe now investigate if terminating $k=1$ process is sufficient to break the deadlock. We will select one process to terminate, return its resources to the available pool, and re-run the detection algorithm on the remaining processes. Let's choose to terminate process $P_1$.\n\nIf $P_1$ is terminated, its allocated resources $\\mathbf{A}_1 = (2, 0, 1)$ are released. The new available vector, $\\mathbf{Available}'$, becomes:\n$$\n\\mathbf{Available}' = \\mathbf{Available} + \\mathbf{A}_1 = (0, 0, 0) + (2, 0, 1) = (2, 0, 1)\n$$\nThe remaining processes are $\\{P_2, P_3, P_4, P_5\\}$. We apply the detection algorithm with this new state.\nInitialize $\\mathbf{Work} = \\mathbf{Available}' = (2, 0, 1)$.\nLet's find a process $P_i$ (from the remaining set) such that $\\mathbf{Q}_i \\leq \\mathbf{Work}$:\n- $P_2$: $\\mathbf{Q}_2 = (0, 1, 1)$. Is $(0, 1, 1) \\leq (2, 0, 1)$? False (since $1 > 0$ for the second resource type).\n- $P_3$: $\\mathbf{Q}_3 = (1, 0, 1)$. Is $(1, 0, 1) \\leq (2, 0, 1)$? True.\nSo, process $P_3$ can execute. After it completes, it releases its resources $\\mathbf{A}_3 = (1, 1, 2)$.\nThe work vector is updated:\n$$\n\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{A}_3 = (2, 0, 1) + (1, 1, 2) = (3, 1, 3)\n$$\nThe remaining processes are $\\{P_2, P_4, P_5\\}$. We continue the algorithm with the updated $\\mathbf{Work}$ vector.\n- $P_2$: $\\mathbf{Q}_2 = (0, 1, 1)$. Is $(0, 1, 1) \\leq (3, 1, 3)$? True.\nProcess $P_2$ can now execute. Upon completion, it releases $\\mathbf{A}_2 = (1, 2, 0)$.\nThe work vector is updated:\n$$\n\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{A}_2 = (3, 1, 3) + (1, 2, 0) = (4, 3, 3)\n$$\nThe remaining processes are $\\{P_4, P_5\\}$. We continue.\n- $P_4$: $\\mathbf{Q}_4 = (0, 0, 1)$. Is $(0, 0, 1) \\leq (4, 3, 3)$? True.\nProcess $P_4$ executes and releases $\\mathbf{A}_4 = (1, 1, 1)$.\nThe work vector is updated:\n$$\n\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{A}_4 = (4, 3, 3) + (1, 1, 1) = (5, 4, 4)\n$$\nThe only remaining process is $P_5$.\n- $P_5$: $\\mathbf{Q}_5 = (1, 0, 0)$. Is $(1, 0, 0) \\leq (5, 4, 4)$? True.\nProcess $P_5$ executes.\n\nAll remaining processes, $\\{P_2, P_3, P_4, P_5\\}$, can complete in the sequence $\\langle P_3, P_2, P_4, P_5 \\rangle$. Thus, terminating a single process ($P_1$) is sufficient to resolve the deadlock.\n\nSince the system is initially in a deadlock ($k \\geq 1$), and we have shown that terminating one process is sufficient ($k \\leq 1$), the minimal number of processes that must be terminated is $k=1$.", "answer": "$$\\boxed{1}$$", "id": "3632450"}]}