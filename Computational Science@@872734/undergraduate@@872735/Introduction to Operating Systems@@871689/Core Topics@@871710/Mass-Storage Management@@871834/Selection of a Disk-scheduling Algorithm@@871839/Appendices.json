{"hands_on_practices": [{"introduction": "The choice between disk scheduling algorithms like CSCAN and CLOOK is not absolute, but rather a trade-off dependent on the specific system and workload. To make an informed decision, we can formalize this trade-off by constructing a quantitative cost model. This exercise challenges you to build a comprehensive cost function that incorporates seek time, rotational latency, and queuing delays, allowing you to derive the precise conditions under which one algorithm outperforms the other. This analytical practice moves beyond simple seek distance comparisons, equipping you with the skills to make principled, data-driven decisions about algorithm selection. [@problem_id:3681159]", "problem": "A mechanical hard disk using Zoned-Bit Recording (ZBR) maintains constant angular velocity while varying the number of sectors per track across concentric zones. Consider two elevator-style disk-scheduling algorithms: Circular SCAN (CSCAN) and Circular LOOK (CLOOK). Requests within an active service epoch are assumed to be uniformly and independently distributed across a contiguous span of $D$ cylinders in a single zone, and the scheduler sees $N \\geq 2$ pending requests per cycle. Define a cycle as the period in which all $N$ requests are serviced exactly once before the next wrap or jump.\n\nModel the expected per-request cost for an algorithm $A \\in \\{\\text{CSCAN}, \\text{CLOOK}\\}$ as\n$$\nC_A \\;=\\; \\alpha \\cdot s_A \\;+\\; \\beta \\cdot r_A \\;+\\; \\gamma \\cdot w_A,\n$$\nwhere $s_A$ is the expected seek distance per request (in cylinders), $r_A$ is the expected rotational-latency contribution per request (in units of time), and $w_A$ is the expected queue waiting-time contribution per request (in units of time). Assume the following widely observed behaviors for elevator scans on uniformly random requests:\n\n- Linearity of movement costs across a cycle: the total per-cycle movement distance is proportional to the sum of inter-request scan gaps plus the wrap or jump between the last and first serviced cylinder.\n- For CSCAN, the head traverses the entire span forward and then wraps the full span, so the total distance per cycle is $2D$ cylinders.\n- For CLOOK, the head traverses only the span between the minimum and maximum requested cylinders and then jumps back across that span, so the total distance per cycle is $2L$ cylinders, where $L$ is the random span between the minimum and maximum of $N$ independent uniform draws on $[0,D]$.\n- The expected span satisfies $\\mathbb{E}[L] \\;=\\; D \\cdot \\frac{N-1}{N+1}$, by properties of order statistics of independent uniform samples.\n- ZBR induces an effective per-cylinder rotational skew penalty that is approximately linear in seek distance over the range of interest. Let $\\theta_{\\text{C}}$ and $\\theta_{\\text{L}}$ denote the effective rotational-latency penalty per cylinder (in time per cylinder) for CSCAN and CLOOK, respectively.\n- Similarly, let $\\omega_{\\text{C}}$ and $\\omega_{\\text{L}}$ denote the effective queue waiting-time penalty per cylinder (in time per cylinder) for CSCAN and CLOOK, respectively, reflecting how cycle length translates into waiting time.\n\nUnder these assumptions, the expected per-request seek distance is the per-cycle distance divided by $N$, and the rotational and waiting components scale linearly with the per-cycle distance, with coefficients $\\theta_A$ and $\\omega_A$, respectively, again divided by $N$ to obtain per-request quantities.\n\nDerive a closed-form analytic expression for the critical value $\\alpha_{\\text{crit}}$ such that the expected costs of CSCAN and CLOOK are equal when $\\alpha = \\alpha_{\\text{crit}}$, expressed in terms of $D$, $N$, $\\beta$, $\\gamma$, $\\theta_{\\text{C}}$, $\\theta_{\\text{L}}$, $\\omega_{\\text{C}}$, and $\\omega_{\\text{L}}$. Use the expected span $\\mathbb{E}[L]$ in place of $L$. Your final answer must be a single closed-form expression for $\\alpha_{\\text{crit}}$ with no inequality statements. No rounding is required.", "solution": "The problem requires the derivation of a critical value $\\alpha_{\\text{crit}}$ for the seek cost weight $\\alpha$ at which the expected per-request costs of the CSCAN and CLOOK disk-scheduling algorithms are equal. The analysis will proceed by first formulating the cost function for each algorithm based on the provided model and then solving for $\\alpha_{\\text{crit}}$ by equating these two cost functions.\n\nThe expected per-request cost for an algorithm $A \\in \\{\\text{CSCAN}, \\text{CLOOK}\\}$ is given by the model:\n$$\nC_A = \\alpha \\cdot s_A + \\beta \\cdot r_A + \\gamma \\cdot w_A\n$$\nwhere $s_A$ is the expected seek distance, $r_A$ is the expected rotational-latency contribution, and $w_A$ is the expected queue waiting-time contribution, all on a per-request basis.\n\nFirst, let us derive the cost for the CSCAN algorithm, which we denote by the subscript 'C'.\nThe problem states that for CSCAN, the disk head traverses the entire span of $D$ cylinders and then performs a full wrap-around, covering a total distance of $2D$ cylinders per service cycle. With $N$ requests serviced per cycle, the expected per-request seek distance $s_{\\text{C}}$ is:\n$$\ns_{\\text{C}} = \\frac{2D}{N}\n$$\nThe rotational-latency contribution $r_{\\text{C}}$ and queue waiting-time contribution $w_{\\text{C}}$ are defined to be proportional to the total cycle distance, with respective proportionality constants $\\theta_{\\text{C}}$ and $\\omega_{\\text{C}}$. On a per-request basis, these are:\n$$\nr_{\\text{C}} = \\theta_{\\text{C}} \\cdot \\frac{2D}{N}\n$$\n$$\nw_{\\text{C}} = \\omega_{\\text{C}} \\cdot \\frac{2D}{N}\n$$\nSubstituting these into the cost model, the total expected cost per request for CSCAN, $C_{\\text{CSCAN}}$, is:\n$$\nC_{\\text{CSCAN}} = \\alpha \\left( \\frac{2D}{N} \\right) + \\beta \\left( \\theta_{\\text{C}} \\frac{2D}{N} \\right) + \\gamma \\left( \\omega_{\\text{C}} \\frac{2D}{N} \\right)\n$$\nFactoring out the common term $\\frac{2D}{N}$:\n$$\nC_{\\text{CSCAN}} = \\frac{2D}{N} (\\alpha + \\beta\\theta_{\\text{C}} + \\gamma\\omega_{\\text{C}})\n$$\n\nNext, we derive the cost for the CLOOK algorithm, denoted by the subscript 'L'.\nFor CLOOK, the head traverses only the span $L$ between the minimum and maximum requested cylinders and then jumps back. The total distance per cycle is $2L$. The problem instructs us to use the expected value of this span, $\\mathbb{E}[L]$, where:\n$$\n\\mathbb{E}[L] = D \\cdot \\frac{N-1}{N+1}\n$$\nThe expected total distance per cycle for CLOOK is therefore $2\\mathbb{E}[L] = 2D \\frac{N-1}{N+1}$.\nFollowing the same logic as for CSCAN, the per-request components for CLOOK are:\n$$\ns_{\\text{L}} = \\frac{2\\mathbb{E}[L]}{N} = \\frac{2D}{N} \\frac{N-1}{N+1}\n$$\n$$\nr_{\\text{L}} = \\theta_{\\text{L}} \\cdot \\frac{2\\mathbb{E}[L]}{N} = \\theta_{\\text{L}} \\frac{2D}{N} \\frac{N-1}{N+1}\n$$\n$$\nw_{\\text{L}} = \\omega_{\\text{L}} \\cdot \\frac{2\\mathbb{E}[L]}{N} = \\omega_{\\text{L}} \\frac{2D}{N} \\frac{N-1}{N+1}\n$$\nThe total expected cost per request for CLOOK, $C_{\\text{CLOOK}}$, is:\n$$\nC_{\\text{CLOOK}} = \\alpha \\left( \\frac{2D}{N} \\frac{N-1}{N+1} \\right) + \\beta \\left( \\theta_{\\text{L}} \\frac{2D}{N} \\frac{N-1}{N+1} \\right) + \\gamma \\left( \\omega_{\\text{L}} \\frac{2D}{N} \\frac{N-1}{N+1} \\right)\n$$\nFactoring out the common term $\\frac{2D}{N} \\frac{N-1}{N+1}$:\n$$\nC_{\\text{CLOOK}} = \\frac{2D}{N} \\frac{N-1}{N+1} (\\alpha + \\beta\\theta_{\\text{L}} + \\gamma\\omega_{\\text{L}})\n$$\n\nThe critical value $\\alpha_{\\text{crit}}$ is found by setting $C_{\\text{CSCAN}} = C_{\\text{CLOOK}}$ and solving for $\\alpha = \\alpha_{\\text{crit}}$:\n$$\n\\frac{2D}{N} (\\alpha_{\\text{crit}} + \\beta\\theta_{\\text{C}} + \\gamma\\omega_{\\text{C}}) = \\frac{2D}{N} \\frac{N-1}{N+1} (\\alpha_{\\text{crit}} + \\beta\\theta_{\\text{L}} + \\gamma\\omega_{\\text{L}})\n$$\nSince $D > 0$ and $N \\geq 2$, the term $\\frac{2D}{N}$ is non-zero and can be cancelled from both sides:\n$$\n\\alpha_{\\text{crit}} + \\beta\\theta_{\\text{C}} + \\gamma\\omega_{\\text{C}} = \\frac{N-1}{N+1} (\\alpha_{\\text{crit}} + \\beta\\theta_{\\text{L}} + \\gamma\\omega_{\\text{L}})\n$$\nNow, we rearrange the equation to isolate $\\alpha_{\\text{crit}}$.\n$$\n\\alpha_{\\text{crit}} + \\beta\\theta_{\\text{C}} + \\gamma\\omega_{\\text{C}} = \\alpha_{\\text{crit}}\\left(\\frac{N-1}{N+1}\\right) + \\left(\\frac{N-1}{N+1}\\right)(\\beta\\theta_{\\text{L}} + \\gamma\\omega_{\\text{L}})\n$$\nGroup terms involving $\\alpha_{\\text{crit}}$ on the left side:\n$$\n\\alpha_{\\text{crit}} - \\alpha_{\\text{crit}}\\left(\\frac{N-1}{N+1}\\right) = \\left(\\frac{N-1}{N+1}\\right)(\\beta\\theta_{\\text{L}} + \\gamma\\omega_{\\text{L}}) - (\\beta\\theta_{\\text{C}} + \\gamma\\omega_{\\text{C}})\n$$\nFactor out $\\alpha_{\\text{crit}}$:\n$$\n\\alpha_{\\text{crit}}\\left(1 - \\frac{N-1}{N+1}\\right) = \\left(\\frac{N-1}{N+1}\\right)(\\beta\\theta_{\\text{L}} + \\gamma\\omega_{\\text{L}}) - (\\beta\\theta_{\\text{C}} + \\gamma\\omega_{\\text{C}})\n$$\nSimplify the term multiplying $\\alpha_{\\text{crit}}$:\n$$\n1 - \\frac{N-1}{N+1} = \\frac{N+1 - (N-1)}{N+1} = \\frac{2}{N+1}\n$$\nThe equation becomes:\n$$\n\\alpha_{\\text{crit}}\\left(\\frac{2}{N+1}\\right) = \\left(\\frac{N-1}{N+1}\\right)(\\beta\\theta_{\\text{L}} + \\gamma\\omega_{\\text{L}}) - (\\beta\\theta_{\\text{C}} + \\gamma\\omega_{\\text{C}})\n$$\nTo solve for $\\alpha_{\\text{crit}}$, we multiply both sides by $\\frac{N+1}{2}$:\n$$\n\\alpha_{\\text{crit}} = \\frac{N+1}{2} \\left[ \\left(\\frac{N-1}{N+1}\\right)(\\beta\\theta_{\\text{L}} + \\gamma\\omega_{\\text{L}}) - (\\beta\\theta_{\\text{C}} + \\gamma\\omega_{\\text{C}}) \\right]\n$$\nDistributing $\\frac{N+1}{2}$ into the brackets simplifies the expression:\n$$\n\\alpha_{\\text{crit}} = \\frac{N-1}{2}(\\beta\\theta_{\\text{L}} + \\gamma\\omega_{\\text{L}}) - \\frac{N+1}{2}(\\beta\\theta_{\\text{C}} + \\gamma\\omega_{\\text{C}})\n$$\nThis can be rewritten in a more structured form by grouping terms with $\\beta$ and $\\gamma$:\n$$\n\\alpha_{\\text{crit}} = \\frac{1}{2} \\left[ (N-1)(\\beta\\theta_{\\text{L}} + \\gamma\\omega_{\\text{L}}) - (N+1)(\\beta\\theta_{\\text{C}} + \\gamma\\omega_{\\text{C}}) \\right]\n$$\n$$\n\\alpha_{\\text{crit}} = \\frac{1}{2} \\left[ \\beta((N-1)\\theta_{\\text{L}} - (N+1)\\theta_{\\text{C}}) + \\gamma((N-1)\\omega_{\\text{L}} - (N+1)\\omega_{\\text{C}}) \\right]\n$$\nThis is the final closed-form expression for $\\alpha_{\\text{crit}}$.", "answer": "$$\n\\boxed{\\frac{1}{2} \\left[ \\beta\\left((N-1)\\theta_{\\text{L}} - (N+1)\\theta_{\\text{C}}\\right) + \\gamma\\left((N-1)\\omega_{\\text{L}} - (N+1)\\omega_{\\text{C}}\\right) \\right]}\n$$", "id": "3681159"}, {"introduction": "Standard scheduling algorithms operate on an idealized model of the disk, but real-world hardware presents imperfections that an operating system must handle gracefully. This practice explores how to adapt scheduling logic to physical constraints by modeling defective disk regions as impenetrable \"walls.\" You will trace the behavior of modified SCAN and LOOK algorithms that are aware of these walls, calculating their total movement cost which now includes both standard seek time and fixed penalties for crossing defective zones. This hands-on trace analysis sharpens your ability to reason about algorithm performance under novel constraints, a crucial skill for designing and debugging robust systems. [@problem_id:3681088]", "problem": "A storage system exposes a disk with contiguous cylinders indexed from $0$ to $199$. The arm seek time is modeled as proportional to cylinder distance: if the head moves from cylinder $c_a$ to $c_b$, the seek cost is proportional to $\\lvert c_b - c_a \\rvert$. In addition, two ranges of cylinders are marked as media defect clusters: $[60,79]$ and $[140,149]$. A reliability policy treats each defect cluster as a wall that cannot be swept through seamlessly; crossing a wall requires a recalibration jump whose cost is modeled as an additional fixed penalty equivalent to $W$ cylinders of movement, with $W = 20$. Requests inside defective ranges are never queued, and requests outside may be served in any order consistent with the scheduling algorithm.\n\nYou must select a wall-aware scheduling policy and analyze its behavior. Consider two policies adapted to the presence of walls:\n\n- Wall-aware SCAN without backtracking (WB-SCAN): starting from the current head position and direction, the head sweeps monotonically, serving requests in order of increasing or decreasing cylinder. It continues the sweep to the nearest physical boundary in that direction (end of disk or the near side of a wall). When it reaches a wall, it pays the crossing penalty $W$ to jump to the far side boundary and continues the sweep in the same direction. It reverses only at physical boundaries (end of disk), not at the last request before a wall, even if no requests remain before the boundary in that direction.\n\n- Wall-aware LOOK (WB-LOOK): starting from the current head position and direction, the head sweeps monotonically but reverses immediately at the last outstanding request in the current direction before any boundary (wall or end of disk), avoiding travel to the boundary if it is not needed. It crosses a wall only when there is at least one outstanding request beyond that wall in the current sweep direction; crossing a wall incurs the penalty $W$ and requires moving to the near-side boundary before crossing.\n\nAssume the head is initially at cylinder $c_0 = 50$, moving in the increasing-cylinder direction. The pending request set is $R = \\{20, 30, 58, 85, 132, 155, 170, 190\\}$, all of which are outside the defective ranges. Rotational latency and transfer time are negligible compared to seek costs and wall-crossing penalties. The system’s objective is to minimize the total movement (seek distance plus wall-crossing penalties) required to service all pending requests exactly once.\n\nWhich option best specifies a principled selection criterion for treating defect clusters as walls and correctly analyzes how WB-LOOK navigates these walls compared to WB-SCAN without backtracking on the given instance, including the resulting total movement?\n\nA. Prefer WB-LOOK when request density is sparse near walls or when $W$ is large relative to typical inter-request distances, because reversing at the last request before a wall avoids unnecessary boundary travel and redundant wall crossings. For the given $c_0$, $R$, and walls, WB-LOOK reverses at cylinder $58$, serves $30$ and $20$, then crosses the first wall once going upward and the second wall once, never going to disk ends without demand. Its total movement is $224$, while WB-SCAN pays to sweep to boundaries and crosses both walls twice, also traveling to both disk ends, for a total movement of $364$.\n\nB. Prefer WB-SCAN without backtracking because it eliminates reversals that cause extra repositioning; with walls present, WB-SCAN reverses at the last request before a wall just like WB-LOOK, so both policies incur identical movement of $224$ on the given instance.\n\nC. Prefer WB-SCAN without backtracking when defect clusters exist, because continuous sweeping minimizes jump penalties and end effects; on the given instance, WB-SCAN has total movement $159$, which is strictly less than WB-LOOK’s $224$.\n\nD. Prefer WB-LOOK only when all requests lie on a single side of each wall; otherwise WB-LOOK must traverse to physical ends to reverse and will cross each wall twice like WB-SCAN, yielding the same total movement of $364$ on the given instance.", "solution": "We will analyze the total movement for both algorithms based on the provided definitions. For analysis, the disk is partitioned by the walls into three service regions: $S_1 = [0, 59]$, $S_2 = [80, 139]$, and $S_3 = [150, 199]$. The request set is partitioned accordingly: $R_1 = \\{20, 30, 58\\}$, $R_2 = \\{85, 132\\}$, and $R_3 = \\{155, 170, 190\\}$.\n\n#### Analysis of WB-SCAN\n\nThe WB-SCAN algorithm sweeps across the entire disk from one end to the other, reversing only at the physical boundaries.\n\n1.  **Initial State**: Head at $c_0 = 50$, moving towards $199$.\n2.  **Upward Sweep ($50 \\to 199$)**:\n    - Move from $50$ to serve request at $58$. Movement: $|58 - 50| = 8$.\n    - The algorithm must proceed to the boundary of Wall 1 ($[60, 79]$), which is cylinder $59$. Movement: $|59 - 58| = 1$.\n    - At $59$, cross the wall. Cost: $W = 20$. The head jumps to the far side, cylinder $80$.\n    - Continue sweep, serving requests at $85$ and $132$. Movement: $|132 - 80| = 52$.\n    - Proceed to the boundary of Wall 2 ($[140, 149]$), at cylinder $139$. Movement: $|139 - 132| = 7$.\n    - At $139$, cross the wall. Cost: $W = 20$. Head jumps to the far side, cylinder $150$.\n    - Continue sweep, serving requests at $155, 170, 190$. Movement: $|190 - 150| = 40$.\n    - Proceed to the physical disk end. Movement: $|199 - 190| = 9$.\n    - Total cost for upward sweep: $8 + 1 + 20 + 52 + 7 + 20 + 40 + 9 = 157$.\n3.  **Downward Sweep ($199 \\to 0$)**:\n    - The head reverses at $199$ and moves towards $0$.\n    - Proceed to the boundary of Wall 2 (near side is $150$). Movement: $|150 - 199| = 49$.\n    - Cross the wall. Cost: $W = 20$. Head jumps to $139$.\n    - Proceed to the boundary of Wall 1 (near side is $80$). Movement: $|80 - 139| = 59$.\n    - Cross the wall. Cost: $W = 20$. Head jumps to $59$.\n    - Continue sweep, serving requests at $30$ and $20$. Movement: $|20 - 59| = 39$.\n    - Proceed to the physical disk end. Movement: $|0 - 20| = 20$.\n    - Total cost for downward sweep: $49 + 20 + 59 + 20 + 39 + 20 = 207$.\n4.  **Total WB-SCAN Movement**:\n    $$ \\text{Total Cost} = 157 + 207 = 364 $$\n\n#### Analysis of WB-LOOK\n\nThe WB-LOOK algorithm reverses at the last request in a given direction, avoiding trips to boundaries where no requests are pending.\n\n1.  **Initial State**: Head at $c_0 = 50$, moving towards $199$.\n2.  **Initial Upward Move**:\n    - The first request is at $58$. This is the last outstanding request before the boundary of Wall 1. There are outstanding requests in the \"down\" direction ($\\{20, 30\\}$).\n    - The algorithm moves from $50$ to $58$. Movement: $|58 - 50| = 8$.\n    - At $58$, it serves the request and, per its definition, reverses direction.\n3.  **First Downward Sweep**:\n    - The head is at $58$, moving towards $0$.\n    - It serves requests at $30$ and $20$. Movement: $|30 - 58| + |20 - 30| = 28 + 10 = 38$.\n    - The request at $20$ is the last one in this direction. All other pending requests are in the \"up\" direction. The head reverses at $20$.\n4.  **Final Upward Sweep**:\n    - The head is at $20$, moving towards $199$.\n    - To service requests at $85, 132, \\dots$, it must cross Wall 1. It moves to the near-side boundary, $59$. Movement: $|59 - 20| = 39$.\n    - Cross the wall. Cost: $W = 20$. Head jumps to $80$.\n    - Sweep up, serving $85$ and $132$. Movement: $|132 - 80| = 52$.\n    - At $132$, it's the last request before Wall 2. However, there are no pending requests in the \"down\" direction, so there is no reason to reverse. It must continue its sweep.\n    - To cross Wall 2, it moves to the near-side boundary, $139$. Movement: $|139 - 132| = 7$.\n    - Cross the wall. Cost: $W = 20$. Head jumps to $150$.\n    - Continue sweep, serving $155, 170, 190$. Movement: $|190 - 150| = 40$.\n    - The request at $190$ is the last overall. The algorithm terminates.\n5.  **Total WB-LOOK Movement**:\n    $$ \\text{Total Cost} = \\underbrace{8}_{\\text{_50→58_}} + \\underbrace{38}_{\\text{_58→20_}} + \\underbrace{39}_{\\text{_20→59_}} + \\underbrace{20}_{\\text{_W_}} + \\underbrace{52}_{\\text{_80→132_}} + \\underbrace{7}_{\\text{_132→139_}} + \\underbrace{20}_{\\text{_W_}} + \\underbrace{40}_{\\text{_150→190_}} = 224 $$\n\n### Option-by-Option Analysis\n\n**A. Prefer WB-LOOK when request density is sparse near walls or when $W$ is large relative to typical inter-request distances, because reversing at the last request before a wall avoids unnecessary boundary travel and redundant wall crossings. For the given $c_0$, $R$, and walls, WB-LOOK reverses at cylinder $58$, serves $30$ and $20$, then crosses the first wall once going upward and the second wall once, never going to disk ends without demand. Its total movement is $224$, while WB-SCAN pays to sweep to boundaries and crosses both walls twice, also traveling to both disk ends, for a total movement of $364$.**\n- The selection criterion is sound. LOOK-based algorithms excel by avoiding unnecessary travel to boundaries, a benefit amplified by the high cost ($W$) of crossing walls.\n- The description of WB-LOOK's path ($50 \\to 58 \\to \\text{reverse} \\to \\dots$) matches our derived path based on the most plausible interpretation of the algorithm's definition.\n- The calculated movement for WB-LOOK ($224$) is correct.\n- The calculated movement for WB-SCAN ($364$) is correct, and the description of its behavior (sweeping to ends, crossing walls twice) is accurate. It crosses both walls on the way up and on the way down.\n- **Verdict: Correct.**\n\n**B. Prefer WB-SCAN without backtracking because it eliminates reversals that cause extra repositioning; with walls present, WB-SCAN reverses at the last request before a wall just like WB-LOOK, so both policies incur identical movement of $224$ on the given instance.**\n- The claim that WB-SCAN reverses at the last request before a wall is in direct contradiction to its definition, which states it reverses \"only at physical boundaries (end of disk)\".\n- Consequently, the claim that both policies incur identical movement is false. Our calculation shows WB-SCAN's movement is $364$, not $224$.\n- **Verdict: Incorrect.**\n\n**C. Prefer WB-SCAN without backtracking when defect clusters exist, because continuous sweeping minimizes jump penalties and end effects; on the given instance, WB-SCAN has total movement $159$, which is strictly less than WB-LOOK’s $224$.**\n- The reasoning is flawed. Continuous sweeping to the ends (the \"end effect\") is a known disadvantage of SCAN, not a benefit. In this instance, WB-SCAN incurs four wall crossings with penalty $W$ each, while WB-LOOK incurs only two. Thus, WB-SCAN does not minimize jump penalties here.\n- The stated total movement for WB-SCAN ($159$) is incorrect. Our derived value is $364$. The value $159$ is close to the cost of only the first upward sweep of WB-SCAN ($157$), but this ignores the entire return sweep needed to service all requests.\n- **Verdict: Incorrect.**\n\n**D. Prefer WB-LOOK only when all requests lie on a single side of each wall; otherwise WB-LOOK must traverse to physical ends to reverse and will cross each wall twice like WB-SCAN, yielding the same total movement of $364$ on the given instance.**\n- The premise for preferring WB-LOOK is overly restrictive and generally untrue.\n- The claim that WB-LOOK must traverse to physical ends is a fundamental misunderstanding of LOOK algorithms, which are defined by their avoidance of physical ends.\n- The claim that it crosses each wall twice is false for this instance; our analysis shows it crosses each wall only once.\n- The claim that its total movement is $364$ is false; this is the movement for WB-SCAN, not WB-LOOK ($224$).\n- **Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "3681088"}, {"introduction": "In many modern applications, such as multimedia streaming or industrial control, meeting deadlines for I/O operations is more critical than maximizing raw throughput. This shifts the scheduling objective from simply minimizing average seek time to ensuring timeliness. This problem delves into real-time disk scheduling by asking you to simulate hybrid algorithms that use Earliest Deadline First (EDF) as the primary policy, with SSTF or SCAN as tie-breakers. By implementing a simulator, you will gain a dynamic understanding of how different head-movement heuristics impact the system's ability to meet firm deadlines under various workloads. [@problem_id:3681126]", "problem": "Consider a single mechanical hard disk with concentric cylinders indexed by integers, a single read/write head, and non-preemptive service of input/output (I/O) requests. Each request is characterized by an arrival time $a_i$ in milliseconds, a target cylinder $c_i$ in integer cylinder units, and a firm deadline $d_i$ in milliseconds by which completion must occur. The head position is an integer cylinder index $p(t)$ at time $t$, and moving the head by a distance $\\Delta = \\lvert c_i - p(t) \\rvert$ incurs a seek time that can be modeled by a linear approximation, together with a fixed service time term that subsumes rotational latency and data transfer. This model is given by the well-tested empirical formula\n$$\nT_{\\text{service}}(\\Delta) = T_0 + \\alpha \\cdot \\Delta + T_{\\text{fixed}},\n$$\nwhere $T_0$ is a seek start overhead in milliseconds, $\\alpha$ is a constant in milliseconds per cylinder, and $T_{\\text{fixed}}$ is a rotational and transfer term in milliseconds. Once the head begins servicing a request, it cannot be preempted until completion.\n\nAt each decision epoch when at least one request is available (arrived and not yet completed), a scheduler chooses the next request to start. The primary selection discipline is Earliest Deadline First (EDF): among all available requests, the scheduler chooses those with the smallest deadline $d_i = \\min\\{ d_j \\mid a_j \\le t \\}$. If there is a single request with the minimal deadline, it is chosen. If there are multiple requests sharing the same smallest deadline, a tie-breaker based on a disk head movement heuristic is used:\n\n- For EDF with Shortest Seek Time First (EDF+SSTF), among those with the minimal deadline, choose the request minimizing $\\lvert c_i - p(t) \\rvert$. On ties, choose the smaller $c_i$.\n\n- For EDF with SCAN (EDF+SCAN), maintain a scan direction $\\delta \\in \\{+1,-1\\}$, initialized to $+1$ (increasing cylinder indices). Among those with the minimal deadline, if $\\delta = +1$, choose the request with the smallest $c_i$ satisfying $c_i \\ge p(t)$; if none exists, flip $\\delta \\leftarrow -1$ and choose the request with the largest $c_i$ satisfying $c_i \\le p(t)$. If $\\delta = -1$, choose the request with the largest $c_i$ satisfying $c_i \\le p(t)$; if none exists, flip $\\delta \\leftarrow +1$ and choose the request with the smallest $c_i$ satisfying $c_i \\ge p(t)$. The scan direction only changes when forced by the absence of candidates on the current side.\n\nA request $i$ is said to miss its deadline if its completion time $t_{\\text{complete},i}$ strictly exceeds its deadline $d_i$, that is, if $t_{\\text{complete},i} > d_i$. The deadline miss rate $m$ for a given scheduler and trace is defined as the number of requests that miss their deadlines divided by the total number of requests. Express $m$ as a decimal (not a percentage).\n\nStarting from these fundamental definitions, write a complete program that, given synthetic traces emphasizing deadlines near $t=0$ milliseconds, simulates both EDF+SCAN and EDF+SSTF under the stated non-preemptive model to compute the deadline miss rate $m$ for each. All time quantities are to be in milliseconds. Use the following disk service model parameters uniformly for all test cases: $T_0 = 0.2$ milliseconds, $\\alpha = 0.1$ milliseconds per cylinder, and $T_{\\text{fixed}} = 0.1$ milliseconds. The head scan direction initialization is $\\delta = +1$. The disk cylinders are indexed by integers without explicit bounds, but all given cylinder indices are within a realistic range.\n\nYour program should implement a discrete-event simulation that:\n\n- Maintains the current time $t$ in milliseconds and head position $p(t)$ as an integer cylinder.\n\n- When no requests have arrived yet or none are available at the current time $t$, advances time to the next request arrival time.\n\n- When one or more requests are available, selects the next request according to EDF; if multiple share the minimal deadline, applies the appropriate tie-breaker (EDF+SCAN or EDF+SSTF) as specified; begins service immediately; computes the service time using $T_{\\text{service}}(\\Delta)$; updates $t$ to the completion time; and updates the head position.\n\n- Counts deadline misses for each request and computes $m$ for each scheduler.\n\nTest suite and parameters to simulate:\n\n- Test case $1$ (balanced earliest deadlines on both sides of the head, with additional later-deadline local requests):\n\n    - Initial head position $p(0) = 100$.\n\n    - Requests:\n        - $(a_1, c_1, d_1) = (0.0, 40, 12.0)$,\n        - $(a_2, c_2, d_2) = (0.0, 60, 12.0)$,\n        - $(a_3, c_3, d_3) = (0.0, 140, 12.0)$,\n        - $(a_4, c_4, d_4) = (0.0, 160, 12.0)$,\n        - $(a_5, c_5, d_5) = (0.5, 95, 25.0)$,\n        - $(a_6, c_6, d_6) = (0.5, 105, 25.0)$.\n\n- Test case $2$ (all deadlines equal, widely separated cylinders):\n\n    - Initial head position $p(0) = 50$.\n\n    - Requests:\n        - $(a_1, c_1, d_1) = (0.0, 10, 10.0)$,\n        - $(a_2, c_2, d_2) = (0.0, 20, 10.0)$,\n        - $(a_3, c_3, d_3) = (0.0, 30, 10.0)$,\n        - $(a_4, c_4, d_4) = (0.0, 160, 10.0)$,\n        - $(a_5, c_5, d_5) = (0.0, 170, 10.0)$.\n\n- Test case $3$ (edge case with zero seek and very tight deadlines, including arrivals after service begins):\n\n    - Initial head position $p(0) = 100$.\n\n    - Requests:\n        - $(a_1, c_1, d_1) = (0.0, 100, 2.0)$,\n        - $(a_2, c_2, d_2) = (0.0, 90, 1.0)$,\n        - $(a_3, c_3, d_3) = (0.5, 110, 2.0)$,\n        - $(a_4, c_4, d_4) = (0.0, 160, 3.5)$,\n        - $(a_5, c_5, d_5) = (0.0, 40, 3.5)$.\n\nYour program should produce a single line of output containing the miss rates as a comma-separated list enclosed in square brackets in the order\n$[m_{\\text{EDF+SCAN}}^{(1)}, m_{\\text{EDF+SSTF}}^{(1)}, m_{\\text{EDF+SCAN}}^{(2)}, m_{\\text{EDF+SSTF}}^{(2)}, m_{\\text{EDF+SCAN}}^{(3)}, m_{\\text{EDF+SSTF}}^{(3)}]$,\nwith each miss rate rounded to four decimal places. For example, the output should look like $[0.1234,0.5678,0.0000,0.2500,0.3333,0.5000]$ where each entry is a decimal in the specified format.", "solution": "The problem requires the simulation of two real-time disk scheduling algorithms, Earliest Deadline First with Shortest Seek Time First tie-breaking (EDF+SSTF) and Earliest Deadline First with SCAN tie-breaking (EDF+SCAN), to determine their respective deadline miss rates for a given set of I/O request traces. This can be modeled and solved using a discrete-event simulation approach.\n\nThe state of the disk system at any time can be described by a tuple $(t, p, \\delta, S)$, where $t$ is the current simulation time in milliseconds, $p$ is the integer index of the cylinder where the read/write head is located, $\\delta \\in \\{+1, -1\\}$ is the current scan direction for the EDF+SCAN algorithm (initialized to $+1$), and $S$ is the set of states of all I/O requests. Each request $i$ is defined by its arrival time $a_i$, target cylinder $c_i$, and deadline $d_i$, and its state includes whether it has been completed.\n\nThe simulation proceeds by advancing time from one event to the next. An event is either a new request arriving or a service completion. However, since the service is non-preemptive, a decision on which request to service next is only made when the disk becomes free. The simulation loop therefore proceeds as follows:\n\n1.  At the current time $t$, identify the set of available requests, which are those that have arrived ($a_i \\le t$) and have not yet been completed.\n\n2.  If the set of available requests is empty, the disk is idle. The simulation time $t$ is advanced to the earliest arrival time $a_j$ of any pending (not yet arrived) request. The process then repeats from Step 1 at this new time $t$.\n\n3.  If there is at least one available request, a decision epoch has been reached. The scheduler must select the next request to service.\n    a.  **EDF Filtering**: The primary scheduling discipline is Earliest Deadline First (EDF). We first identify the minimum deadline $d_{\\min}$ among all available requests. The set of candidate requests is then formed by all available requests whose deadline $d_i$ is equal to $d_{\\min}$.\n    b.  **Tie-Breaking**: If this candidate set contains more than one request, a tie-breaking rule is applied:\n        i.  For **EDF+SSTF**, the scheduler selects the candidate request $i$ that minimizes the seek distance, $\\Delta_i = \\lvert c_i - p \\rvert$, where $p$ is the current head position. If a further tie exists (multiple requests have the same minimal seek distance), the one with the smaller cylinder index $c_i$ is chosen.\n        ii. For **EDF+SCAN**, the scheduler considers the current scan direction $\\delta$. If $\\delta = +1$, it searches for candidates with $c_i \\ge p$. If such requests exist, it chooses the one with the minimum cylinder index $c_i$. If no such requests exist, the direction is reversed ($\\delta \\leftarrow -1$), and it then chooses the candidate with the maximum cylinder index $c_i$ (from the full set of candidates with deadline $d_{\\min}$). A symmetric logic applies if the initial direction was $\\delta = -1$. The direction $\\delta$ is only reversed when no candidates lie in the current direction of motion.\n\n4.  Once a request $i$ is selected, its service begins immediately. The service time is calculated using the provided empirical formula:\n    $$T_{\\text{service}}(\\Delta_i) = T_0 + \\alpha \\cdot \\Delta_i + T_{\\text{fixed}}$$\n    where $\\Delta_i = \\lvert c_i - p \\rvert$ is the seek distance, $T_0 = 0.2$ ms, $\\alpha = 0.1$ ms/cylinder, and $T_{\\text{fixed}} = 0.1$ ms.\n\n5.  The system state is then updated. The request's completion time is $t_{\\text{complete},i} = t + T_{\\text{service}}(\\Delta_i)$. If $t_{\\text{complete},i} > d_i$, the request has missed its deadline, and a counter for missed deadlines is incremented. The simulation time is advanced to the completion time, $t \\leftarrow t_{\\text{complete},i}$, and the head position is updated to the cylinder of the just-completed request, $p \\leftarrow c_i$. The request is marked as completed.\n\n6.  The loop (Steps 1-5) repeats until all requests in the trace have been completed.\n\n7.  Finally, the deadline miss rate $m$ is computed as the total number of missed deadlines divided by the total number of requests in the trace.\n\nThis entire simulation process is deterministic and is executed for each combination of the test cases and scheduling algorithms to produce the required six miss rate values.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// Constants from the problem statement\n#define T0 0.2\n#define ALPHA 0.1\n#define T_FIXED 0.1\n#define MAX_REQUESTS 10\n\n// Scheduler type enumeration\ntypedef enum {\n    EDF_SCAN,\n    EDF_SSTF\n} SchedulerType;\n\n// Request structure\ntypedef struct {\n    int id;\n    double arrival_time;\n    int cylinder;\n    double deadline;\n    int completed; // Using int as a boolean (0 or 1)\n} Request;\n\n// Test case structure\ntypedef struct {\n    int initial_head_pos;\n    int num_requests;\n    Request requests[MAX_REQUESTS];\n} TestCase;\n\n// Function to run a single simulation instance\ndouble run_simulation(TestCase tc, SchedulerType scheduler) {\n    // State variables\n    double current_time = 0.0;\n    int head_position = tc.initial_head_pos;\n    int scan_direction = 1; // Initialized to +1 for SCAN\n    int completed_count = 0;\n    int missed_deadlines = 0;\n\n    // Create a mutable copy of the requests for the simulation\n    Request sim_requests[MAX_REQUESTS];\n    for (int i = 0; i < tc.num_requests; ++i) {\n        sim_requests[i] = tc.requests[i];\n        sim_requests[i].completed = 0;\n    }\n\n    while (completed_count < tc.num_requests) {\n        // Find available requests at current_time\n        Request* available_reqs[MAX_REQUESTS];\n        int available_count = 0;\n        double next_arrival_time = -1.0;\n\n        for (int i = 0; i < tc.num_requests; i++) {\n            if (!sim_requests[i].completed) {\n                if (sim_requests[i].arrival_time <= current_time) {\n                    available_reqs[available_count++] = &sim_requests[i];\n                } else {\n                    if (next_arrival_time < 0 || sim_requests[i].arrival_time < next_arrival_time) {\n                        next_arrival_time = sim_requests[i].arrival_time;\n                    }\n                }\n            }\n        }\n\n        // If idle, advance time to the next event\n        if (available_count == 0) {\n            if (next_arrival_time >= 0) {\n                current_time = next_arrival_time;\n                continue; // Re-evaluate available requests at the new time\n            } else {\n                break; // All requests are completed\n            }\n        }\n\n        // Select next request to service\n        // 1. Find minimum deadline among available requests\n        double min_deadline = -1.0;\n        for (int i = 0; i < available_count; i++) {\n            if (min_deadline < 0 || available_reqs[i]->deadline < min_deadline) {\n                min_deadline = available_reqs[i]->deadline;\n            }\n        }\n\n        // 2. Collect all candidates with the minimum deadline\n        Request* candidates[MAX_REQUESTS];\n        int candidate_count = 0;\n        for (int i = 0; i < available_count; i++) {\n            if (available_reqs[i]->deadline == min_deadline) {\n                candidates[candidate_count++] = available_reqs[i];\n            }\n        }\n\n        Request* chosen_req = NULL;\n        if (candidate_count == 1) {\n            chosen_req = candidates[0];\n        } else {\n            // 3. Apply tie-breaking rule\n            if (scheduler == EDF_SSTF) {\n                int min_seek = -1;\n                for (int i = 0; i < candidate_count; i++) {\n                    int seek = abs(candidates[i]->cylinder - head_position);\n                    if (min_seek == -1 || seek < min_seek) {\n                        min_seek = seek;\n                        chosen_req = candidates[i];\n                    } else if (seek == min_seek) {\n                        if (candidates[i]->cylinder < chosen_req->cylinder) {\n                            chosen_req = candidates[i];\n                        }\n                    }\n                }\n            } else { // EDF_SCAN\n                Request* preferred_dir_candidates[MAX_REQUESTS];\n                int preferred_dir_count = 0;\n                Request* other_dir_candidates[MAX_REQUESTS];\n                int other_dir_count = 0;\n\n                if (scan_direction == 1) {\n                    for(int i = 0; i < candidate_count; ++i) if(candidates[i]->cylinder >= head_position) preferred_dir_candidates[preferred_dir_count++] = candidates[i];\n                    for(int i = 0; i < candidate_count; ++i) if(candidates[i]->cylinder <= head_position) other_dir_candidates[other_dir_count++] = candidates[i];\n                } else { // scan_direction == -1\n                    for(int i = 0; i < candidate_count; ++i) if(candidates[i]->cylinder <= head_position) preferred_dir_candidates[preferred_dir_count++] = candidates[i];\n                    for(int i = 0; i < candidate_count; ++i) if(candidates[i]->cylinder >= head_position) other_dir_candidates[other_dir_count++] = candidates[i];\n                }\n\n                if (preferred_dir_count > 0) {\n                    chosen_req = preferred_dir_candidates[0];\n                    if (scan_direction == 1) { // Find smallest cylinder\n                        for(int i=1; i<preferred_dir_count; ++i) if (preferred_dir_candidates[i]->cylinder < chosen_req->cylinder) chosen_req = preferred_dir_candidates[i];\n                    } else { // Find largest cylinder\n                        for(int i=1; i<preferred_dir_count; ++i) if (preferred_dir_candidates[i]->cylinder > chosen_req->cylinder) chosen_req = preferred_dir_candidates[i];\n                    }\n                } else {\n                    scan_direction *= -1; // Reverse direction\n                    chosen_req = other_dir_candidates[0];\n                    if (scan_direction == 1) { // Find smallest cylinder\n                        for(int i=1; i<other_dir_count; ++i) if (other_dir_candidates[i]->cylinder < chosen_req->cylinder) chosen_req = other_dir_candidates[i];\n                    } else { // Find largest cylinder\n                        for(int i=1; i<other_dir_count; ++i) if (other_dir_candidates[i]->cylinder > chosen_req->cylinder) chosen_req = other_dir_candidates[i];\n                    }\n                }\n            }\n        }\n\n        // Process the chosen request\n        int delta = abs(chosen_req->cylinder - head_position);\n        double service_time = T0 + ALPHA * delta + T_FIXED;\n        double completion_time = current_time + service_time;\n\n        if (completion_time > chosen_req->deadline) {\n            missed_deadlines++;\n        }\n\n        current_time = completion_time;\n        head_position = chosen_req->cylinder;\n        chosen_req->completed = 1;\n        completed_count++;\n    }\n\n    return (double)missed_deadlines / tc.num_requests;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        { // Test Case 1\n            .initial_head_pos = 100,\n            .num_requests = 6,\n            .requests = {\n                {1, 0.0, 40, 12.0}, {2, 0.0, 60, 12.0}, {3, 0.0, 140, 12.0},\n                {4, 0.0, 160, 12.0}, {5, 0.5, 95, 25.0}, {6, 0.5, 105, 25.0}\n            }\n        },\n        { // Test Case 2\n            .initial_head_pos = 50,\n            .num_requests = 5,\n            .requests = {\n                {1, 0.0, 10, 10.0}, {2, 0.0, 20, 10.0}, {3, 0.0, 30, 10.0},\n                {4, 0.0, 160, 10.0}, {5, 0.0, 170, 10.0}\n            }\n        },\n        { // Test Case 3\n            .initial_head_pos = 100,\n            .num_requests = 5,\n            .requests = {\n                {1, 0.0, 100, 2.0}, {2, 0.0, 90, 1.0}, {3, 0.5, 110, 2.0},\n                {4, 0.0, 160, 3.5}, {5, 0.0, 40, 3.5}\n            }\n        }\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    double results[num_cases * 2];\n\n    // Calculate the result for each test case and scheduler\n    for (int i = 0; i < num_cases; ++i) {\n        results[i * 2 + 0] = run_simulation(test_cases[i], EDF_SCAN);\n        results[i * 2 + 1] = run_simulation(test_cases[i], EDF_SSTF);\n    }\n\n    // Print the results in the EXACT REQUIRED format.\n    printf(\"[%.4f,%.4f,%.4f,%.4f,%.4f,%.4f]\\n\",\n           results[0], results[1], results[2], results[3], results[4], results[5]);\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3681126"}]}