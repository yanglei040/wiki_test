{"hands_on_practices": [{"introduction": "Understanding the theoretical trade-offs between disk scheduling algorithms is one thing; seeing them in action is another. This comprehensive exercise provides a hands-on opportunity to calculate and compare the performance of six fundamental algorithms—from the simple First-Come, First-Served (FCFS) to the more sophisticated Circular LOOK (C-LOOK)—on a static set of requests. By meticulously tracing the head movement and calculating the average response time for each policy, you will develop a concrete, quantitative intuition for why certain algorithms are more efficient than others. [@problem_id:3635884]", "problem": "A magnetic hard disk has cylinders indexed from $0$ to $199$. The disk head starts at cylinder $75$ at time $t=0$ with initial sweep direction toward increasing cylinder numbers. Eight read requests arrive simultaneously at $t=0$ with the following cylinder numbers, listed in the order they are presented to the operating system: $40$, $150$, $10$, $90$, $15$, $180$, $60$, $20$. Consider six disk scheduling algorithms: First-Come, First-Served (FCFS), Shortest Seek Time First (SSTF), SCAN, LOOK, Circular SCAN (C-SCAN), and Circular LOOK (C-LOOK). Assume that:\n- All requests arrive at $t=0$ (so response time equals completion time).\n- Seek time is modeled linearly as $t_{\\text{seek}}(d)=\\alpha+\\beta d$, where $d$ is the absolute cylinder distance moved, with $\\alpha=0.2\\,\\mathrm{ms}$ and $\\beta=0.01\\,\\mathrm{ms}/\\text{cylinder}$.\n- The average rotational latency is half a rotation. The disk rotates at $7200$ revolutions per minute, so the mean rotational latency is $T_{\\text{rot}}=\\frac{1}{2}\\times\\frac{60\\times 1000}{7200}\\,\\mathrm{ms}=\\frac{25}{6}\\,\\mathrm{ms}$.\n- Each request transfers a single sector with constant transfer time $T_{\\text{xfer}}=0.5\\,\\mathrm{ms}$.\n- Therefore, the service time for a request that follows a head movement of distance $d$ is $t(d)=\\alpha+\\beta d+T_{\\text{rot}}+T_{\\text{xfer}}=\\frac{73}{15}+\\frac{d}{100}\\,\\mathrm{ms}$.\n- For SCAN and C-SCAN, the head continues to the physical end ($0$ or $199$) before reversing (SCAN) or wrapping (C-SCAN) if no request lies further in the current sweep direction; any such repositioning movement that does not immediately serve a request consumes time modeled purely as $\\beta d$ with no $\\alpha$, no rotation, and no transfer.\n- For LOOK and C-LOOK, the head reverses or wraps only at the last request in the current direction (no travel to the physical end), so there is no repositioning movement beyond the last requested cylinder.\n- Ties in SSTF are broken by choosing the lower-numbered cylinder; for SCAN and C-SCAN, the initial direction is toward increasing cylinder numbers; for LOOK and C-LOOK, the initial sweep is also toward increasing cylinder numbers.\n\nTasks:\n1. For each algorithm (FCFS, SSTF, SCAN, LOOK, C-SCAN, C-LOOK), determine the exact service order given the starting position and rules above.\n2. For each algorithm, compute the total head movement in cylinders (include all movement, including any SCAN or C-SCAN repositioning).\n3. For each algorithm, compute the average response time (mean of the completion times of the eight requests) using the service time model $t(d)=\\frac{73}{15}+\\frac{d}{100}$ and including any repositioning time where applicable.\n4. Interpret the differences in total head movement and average response time among the algorithms in terms of locality and fairness.\n\nFinally, define the summary metric $R$ to be the ratio of the maximum total head movement to the minimum total head movement across these six algorithms. Compute $R$. Round your final value of $R$ to four significant figures. Report the final value of $R$ with no units.", "solution": "The problem is a well-posed and self-contained exercise in analyzing disk scheduling algorithms, a standard topic in computer organization and operating systems. All necessary data, models, and constraints are provided and are scientifically and mathematically sound. Therefore, a complete solution can be derived.\n\nThe givens are:\n- Cylinder range: $[0, 199]$.\n- Initial head position: $C_{\\text{start}}=75$.\n- Initial time: $t=0$.\n- Initial direction of sweep: toward increasing cylinder numbers.\n- Request queue (simultaneous arrival at $t=0$): a set of $N=8$ requests for cylinders $\\{10, 15, 20, 40, 60, 90, 150, 180\\}$.\n- The order of arrival for FCFS is: $40, 150, 10, 90, 15, 180, 60, 20$.\n- The service time for a request following a head movement of distance $d$ is $t(d) = T_{\\text{const}} + \\beta d$, where the constant time component is $T_{\\text{const}} = \\alpha + T_{\\text{rot}} + T_{\\text{xfer}} = \\frac{73}{15}\\,\\mathrm{ms}$ and the seek time coefficient is $\\beta = 0.01\\,\\mathrm{ms}/\\text{cylinder} = \\frac{1}{100}\\,\\mathrm{ms}/\\text{cylinder}$.\n- The repositioning time for SCAN and C-SCAN is modeled as $t_{\\text{repo}}(d) = \\beta d = \\frac{d}{100}\\,\\mathrm{ms}$.\n\nSince all requests arrive at $t=0$, the response time for a request is equal to its completion time. The average response time is the mean of the completion times for all $N=8$ requests. Let $S = (c_1, c_2, \\dots, c_8)$ be the service order of cylinders for a given algorithm. The head starts at $c_0=75$. The distance moved for the $i$-th request is $d_i = |c_i - c_{i-1}|$. The service time for the $i$-th request is $T_i$. The completion time for the $i$-th request is $C_i = \\sum_{j=1}^{i} T_j$.\n\nWe analyze each of the six algorithms.\n\n**1. First-Come, First-Served (FCFS)**\nThe requests are serviced in the order they arrived.\n- Service Order: $40, 150, 10, 90, 15, 180, 60, 20$.\n- Movement Path: $75 \\to 40 \\to 150 \\to 10 \\to 90 \\to 15 \\to 180 \\to 60 \\to 20$.\n- Head Movements ($d_i$): $d_1=|40-75|=35$, $d_2=|150-40|=110$, $d_3=|10-150|=140$, $d_4=|90-10|=80$, $d_5=|15-90|=75$, $d_6=|180-15|=165$, $d_7=|60-180|=120$, $d_8=|20-60|=40$.\n- Total Head Movement: $\\sum d_i = 35+110+140+80+75+165+120+40 = 765$ cylinders.\n- Average Response Time: The sum of completion times is $\\sum_{i=1}^{8} C_i = \\sum_{i=1}^{8} (8-i+1) T_i$.\n  $T_i = \\frac{73}{15} + \\frac{d_i}{100}$.\n  $\\sum C_i = \\frac{73}{15}\\sum_{i=1}^{8}(8-i+1) + \\frac{1}{100}\\sum_{i=1}^{8}(8-i+1)d_i$. The first sum is $\\frac{8 \\times 9}{2} = 36$.\n  $\\sum(8-i+1)d_i = 8(35)+7(110)+6(140)+5(80)+4(75)+3(165)+2(120)+1(40) = 3365$.\n  $\\sum C_i = \\frac{73}{15}(36) + \\frac{3365}{100} = 175.2 + 33.65 = 208.85\\,\\mathrm{ms}$.\n  Average Response Time = $\\frac{208.85}{8} = 26.10625\\,\\mathrm{ms}$.\n\n**2. Shortest Seek Time First (SSTF)**\nThe request with the minimum seek distance from the current head position is selected next.\n- Head at $75$. Distances to $60$ and $90$ are both $15$. Tie-breaking rule selects the lower cylinder, $60$.\n- Path: $75 \\to 60 \\to 40 \\to 20 \\to 15 \\to 10 \\to 90 \\to 150 \\to 180$.\n- Service Order: $60, 40, 20, 15, 10, 90, 150, 180$.\n- Head Movements ($d_i$): $15, 20, 20, 5, 5, 80, 60, 30$.\n- Total Head Movement: $\\sum d_i = 15+20+20+5+5+80+60+30 = 235$ cylinders.\n- Average Response Time:\n  $\\sum(8-i+1)d_i = 8(15)+7(20)+6(20)+5(5)+4(5)+3(80)+2(60)+1(30) = 815$.\n  $\\sum C_i = \\frac{73}{15}(36) + \\frac{815}{100} = 175.2 + 8.15 = 183.35\\,\\mathrm{ms}$.\n  Average Response Time = $\\frac{183.35}{8} = 22.91875\\,\\mathrm{ms}$.\n\n**3. SCAN (Elevator Algorithm)**\nThe head sweeps back and forth across the disk.\n- Start at $75$, direction is increasing.\n- Service Order: $90, 150, 180$. Then moves to end $199$, reverses, and services $60, 40, 20, 15, 10$.\n- Total Movement Path: $75 \\to 199 \\to 10$.\n- Total Head Movement: $(199-75) + (199-10) = 124 + 189 = 313$ cylinders.\n- Average Response Time:\n  - $C_{90}: t(15)$.\n  - $C_{150}: C_{90} + t(60)$.\n  - $C_{180}: C_{150} + t(30)$.\n  - After servicing $180$, head moves to $199$. $d_{\\text{repo1}}=19$. Time taken is $t_{\\text{repo1}} = \\frac{19}{100} = 0.19\\,\\mathrm{ms}$.\n  - Time upon arrival at $199$ is $C_{180} + t_{\\text{repo1}}$.\n  - The next service is for cylinder $60$. The head moves from $199$ to $60$, a distance of $d_4=139$.\n  - $C_{60}: (C_{180} + t_{\\text{repo1}}) + t(139)$.\n  - Subsequent services: $C_{40} = C_{60}+t(20)$, $C_{20}=C_{40}+t(20)$, $C_{15}=C_{20}+t(5)$, $C_{10}=C_{15}+t(5)$.\n  - Summing the individual completion times:\n  Let $T_0 = \\frac{73}{15}$. $\\sum C_i = (T_0+0.15) + (2T_0+0.75) + (3T_0+1.05) + (4T_0+2.63+0.19) + (5T_0+2.83+0.19) + (6T_0+3.03+0.19) + (7T_0+3.08+0.19) + (8T_0+3.13+0.19) = 36T_0 + 19.55$.\n  $\\sum C_i = 175.2 + 19.55 = 194.75\\,\\mathrm{ms}$.\n  Average Response Time = $\\frac{194.75}{8} = 24.34375\\,\\mathrm{ms}$.\n\n**4. LOOK**\nSimilar to SCAN, but the head reverses direction at the last request in the current direction.\n- Service Order: $90, 150, 180$. Reverses at $180$, then services $60, 40, 20, 15, 10$.\n- Total Movement Path: $75 \\to 180 \\to 10$.\n- Total Head Movement: $(180-75) + (180-10) = 105 + 170 = 275$ cylinders.\n- Average Response Time: No repositioning time. After servicing $180$, the next service is for $60$. The travel distance is $|60-180|=120$.\n  - $C_{90}: t(15)$, $C_{150}: C_{90}+t(60)$, $C_{180}: C_{150}+t(30)$.\n  - $C_{60}: C_{180}+t(120)$.\n  - Summing completion times:\n  $\\sum(8-i+1)d_i$ for this order: $8(15)+7(60)+6(30)+5(120)+4(20)+3(20)+2(5)+1(5) = 1475$.\n  $\\sum C_i = 36 \\times \\frac{73}{15} + \\frac{1475}{100} = 175.2 + 14.75 = 189.95\\,\\mathrm{ms}$.\n  Average Response Time = $\\frac{189.95}{8} = 23.74375\\,\\mathrm{ms}$.\n\n**5. Circular SCAN (C-SCAN)**\nThe head sweeps in one direction only. After reaching the end, it returns to the start and sweeps again.\n- Service Order: $90, 150, 180$. Move to end $199$, wrap to $0$, then service $10, 15, 20, 40, 60$.\n- Total Movement Path: $75 \\to 199$ (services), $199 \\to 0$ (reposition), $0 \\to 60$ (services).\n- Total Head Movement: $(199-75) + (199-0) + (60-0) = 124 + 199 + 60 = 383$ cylinders.\n- Average Response Time:\n  - Repositioning moves are from $180 \\to 199$ ($d=19$) and $199 \\to 0$ ($d=199$). Total reposition distance is $218$.\n  - Total repositioning time is $t_{\\text{repo}} = \\frac{218}{100} = 2.18\\,\\mathrm{ms}$. This time is incurred after $C_{180}$ and before the service of $C_{10}$.\n  - Summing completion times:\n  Let $T_0 = \\frac{73}{15}$. $\\sum C_i = (T_0+0.15) + (2T_0+0.75) + (3T_0+1.05) + (4T_0+1.15+2.18) + (5T_0+1.20+2.18) + (6T_0+1.25+2.18) + (7T_0+1.45+2.18) + (8T_0+1.65+2.18) = 36T_0 + 26.15$.\n  $\\sum C_i = 175.2 + 26.15 = 201.35\\,\\mathrm{ms}$.\n  Average Response Time = $\\frac{201.35}{8} = 25.16875\\,\\mathrm{ms}$.\n\n**6. Circular LOOK (C-LOOK)**\nSimilar to C-SCAN, but the head wraps from the last request to the first request of the next cycle.\n- Service Order: $90, 150, 180$. Then wraps to $10$ and services $10, 15, 20, 40, 60$.\n- Head movements are all part of service seeks. Path: $75 \\to 90 \\to \\dots \\to 180 \\to 10 \\to \\dots \\to 60$.\n- Head Movements ($d_i$): $15, 60, 30, |10-180|=170, 5, 5, 20, 20$.\n- Total Head Movement: $15+60+30+170+5+5+20+20 = 325$ cylinders.\n- Average Response Time:\n  $\\sum(8-i+1)d_i = 8(15)+7(60)+6(30)+5(170)+4(5)+3(5)+2(20)+1(20) = 1665$.\n  $\\sum C_i = \\frac{73}{15}(36) + \\frac{1665}{100} = 175.2 + 16.65 = 191.85\\,\\mathrm{ms}$.\n  Average Response Time = $\\frac{191.85}{8} = 23.98125\\,\\mathrm{ms}$.\n\n**Summary of Results**\n\n| Algorithm | Total Head Movement | Avg. Response Time (ms) |\n|-----------|--------------------:|------------------------:|\n| FCFS      | $765$               | $26.10625$              |\n| SSTF      | $235$               | $22.91875$              |\n| SCAN      | $313$               | $24.34375$              |\n| LOOK      | $275$               | $23.74375$              |\n| C-SCAN    | $383$               | $25.16875$              |\n| C-LOOK    | $325$               | $23.98125$              |\n\n**Interpretation**\n- **Locality and Head Movement**: SSTF minimizes total head movement ($235$ cylinders) by exploiting spatial locality, always choosing the nearest request. FCFS performs the worst ($765$ cylinders) as it ignores locality entirely. The SCAN/LOOK variants fall in between. LOOK ($275$) and C-LOOK ($325$) outperform their SCAN ($313$) and C-SCAN ($383$) counterparts by avoiding unnecessary travel to the physical ends of the disk.\n- **Fairness and Response Time**: FCFS is definitionally fair in terms of preventing starvation but has the highest average response time due to its inefficiency. SSTF provides the lowest average response time, maximizing throughput, but can lead to starvation for distant requests (a fairness issue not apparent in this static batch). The SCAN/LOOK family offers a compromise. C-SCAN and C-LOOK generally provide more uniform wait times than SCAN and LOOK, as requests only ever wait for one sweep direction. In this specific case, LOOK provides the best response time among the sweep-based algorithms.\n\n**Final Metric Calculation**\nThe summary metric $R$ is the ratio of the maximum to the minimum total head movement.\n- Maximum total head movement, $H_{\\text{max}} = 765$ (from FCFS).\n- Minimum total head movement, $H_{\\text{min}} = 235$ (from SSTF).\n\nThe ratio is:\n$$R = \\frac{H_{\\text{max}}}{H_{\\text{min}}} = \\frac{765}{235} = \\frac{153}{47}$$\nNumerically, this is:\n$$R \\approx 3.25531914...$$\nRounding to four significant figures, we get $R = 3.255$.", "answer": "$$ \\boxed{3.255} $$", "id": "3635884"}, {"introduction": "In a static environment, LOOK almost always outperforms SCAN by avoiding unnecessary travel to the disk's physical endpoints. But what happens when the environment is dynamic, with new requests arriving over time? This practice explores that very question, revealing a scenario where SCAN's seemingly wasteful journey to the end of the disk becomes a clever, anticipatory move. [@problem_id:3635730] This exercise will challenge you to think about scheduling as a bet on future events and to appreciate the subtle design choices that distinguish these two 'elevator' algorithms.", "problem": "A hard disk with cylinders indexed from $0$ through $199$ is accessed by a single-threaded scheduler. The disk head starts at cylinder $100$ at time $t=0$ moving toward increasing cylinder numbers. The head moves at constant speed $v=1$ cylinder per unit time. Ignore rotational latency and controller overhead; the cost to complete a sequence of I/O requests is measured as the total head movement, defined as the sum of absolute cylinder differences between consecutive serviced positions. The scheduler is non-preemptive and operates under a chosen policy without knowledge of future arrivals. The disk scheduling policies considered are: First-Come, First-Served (FCFS), Shortest Seek Time First (SSTF), Elevator SCAN algorithm (SCAN), and LOOK algorithm (LOOK). In SCAN, the head continues in its current direction to the physical end of the disk ($0$ or $199$) before reversing; in LOOK, the head reverses when it reaches the last pending request in the current direction, without going to the physical end unless needed. The system stops the head when all pending requests have been serviced.\n\nAt time $t=0$, the initial pending requests are at cylinders $\\{120, 130, 150, 30, 10\\}$. Additional requests may arrive over time as specified in the options below. In every option, assume requests are serviced immediately upon arrival if the head reaches their cylinder while following the policy’s path in its current direction; otherwise, they remain pending until later. Choose the option in which SCAN results in a strictly smaller total head movement than LOOK because the empty extreme tracks in the current direction later receive arrivals that SCAN picks up in the same outward sweep while LOOK has already reversed, thereby forcing a subsequent long traversal.\n\nA. Future arrivals: at time $t=70$, cylinders $\\{195, 198\\}$ arrive.\n\nB. Future arrivals: at time $t=20$, cylinders $\\{160, 165\\}$ arrive.\n\nC. Future arrivals: at time $t=110$, cylinders $\\{195, 198\\}$ arrive.\n\nD. Future arrivals: at time $t=70$, cylinders $\\{3, 5\\}$ arrive.\n\nAnswer the multiple-choice question by selecting the correct option(s). Your reasoning must start from the above operational definitions and the physical model (constant-speed head, seek cost equals absolute cylinder travel). In your solution, explain why the selected option(s) satisfy the stated condition and why the others do not, and discuss the notion of anticipatory scheduling in this context along with its associated risks under uncertain future arrivals.", "solution": "This problem requires a step-by-step simulation of the SCAN and LOOK algorithms under dynamic request arrivals for each option. The total head movement is calculated as the sum of the lengths of the head's sweeps required to service all requests.\n\n**Initial State Analysis (Common to all options):**\n- At $t=0$, the head is at cylinder $100$, moving toward increasing cylinder numbers (towards $199$).\n- The initial request queue is $\\{10, 30, 120, 130, 150\\}$.\n- Both SCAN and LOOK will first service the requests in the current direction of travel: $120$, $130$, and $150$.\n- The head moves $100 \\to 120 \\to 130 \\to 150$. This takes $(150 - 100) = 50$ units of time.\n- At $t=50$, the head is at cylinder $150$, having serviced all initial requests in its path. The pending requests are now $\\{10, 30\\}$.\n\nThis is the critical decision point where the behaviors of SCAN and LOOK diverge.\n- **LOOK:** Having serviced the last request in its current direction ($150$), it will reverse and begin moving towards cylinder $0$ to service $\\{10, 30\\}$.\n- **SCAN:** According to its definition, it will continue moving to the physical end of the disk, cylinder $199$, before reversing.\n\nWe now analyze each option.\n\n**A. Future arrivals: at time $t=70$, cylinders $\\{195, 198\\}$ arrive.**\n- **SCAN:**\n  - At $t=50$, the head is at $150$ and moves towards $199$.\n  - At $t=70$, the head has moved for $20$ time units, reaching cylinder $150 + 20 = 170$.\n  - At this moment, new requests $\\{195, 198\\}$ arrive. These are ahead of the head in its current direction.\n  - SCAN continues its sweep, servicing $195$ and $198$ on its way to $199$.\n  - After reaching $199$, it reverses and services the remaining requests $\\{10, 30\\}$.\n  - The total path consists of an outward sweep from $100 \\to 199$ and an inward sweep from $199 \\to 10$.\n  - Total Movement (SCAN): $(199 - 100) + (199 - 10) = 99 + 189 = 288$.\n- **LOOK:**\n  - At $t=50$, the head is at $150$ and reverses, moving towards $0$.\n  - At $t=70$, the head is at cylinder $150 - 20 = 130$.\n  - The new requests $\\{195, 198\\}$ arrive. The pending queue is $\\{10, 30, 195, 198\\}$.\n  - LOOK continues its current inward sweep, servicing $30$ and then $10$.\n  - After servicing $10$, it must reverse to service the distant requests at $195$ and $198$.\n  - The total path consists of three sweeps: $100 \\to 150$, then $150 \\to 10$, and finally $10 \\to 198$.\n  - Total Movement (LOOK): $(150 - 100) + (150 - 10) + (198 - 10) = 50 + 140 + 188 = 378$.\n- **Comparison:** SCAN movement ($288$) is strictly smaller than LOOK movement ($378$). This option satisfies the condition.\n\n**B. Future arrivals: at time $t=20$, cylinders $\\{160, 165\\}$ arrive.**\n- At $t=20$, the head is at cylinder $120$, servicing the first request. The new requests are added to the queue.\n- Both SCAN and LOOK will continue their outward sweep, now including $160$ and $165$. The last request in this direction is $165$.\n- **SCAN:** Sweeps $100 \\to 199 \\to 10$. Total Movement: $(199 - 100) + (199 - 10) = 288$.\n- **LOOK:** Sweeps $100 \\to 165 \\to 10$. Total Movement: $(165 - 100) + (165 - 10) = 65 + 155 = 220$.\n- **Comparison:** LOOK performs better. This option is incorrect.\n\n**C. Future arrivals: at time $t=110$, cylinders $\\{195, 198\\}$ arrive.**\n- **SCAN:**\n  - At $t=50$, head at $150$. It proceeds to $199$, arriving at $t=50+(199-150)=99$. It immediately reverses.\n  - At $t=110$, the head is on its return sweep, at position $199 - (110 - 99) = 188$.\n  - The new requests $\\{195, 198\\}$ arrive \"behind\" the head.\n  - SCAN must complete its sweep to $0$ (servicing $30, 10$), then reverse again for a third sweep to service $195, 198$.\n  - Path: $100 \\to 199 \\to 0 \\to 198$.\n  - Total Movement (SCAN): $(199 - 100) + (199 - 0) + (198 - 0) = 99 + 199 + 198 = 496$.\n- **LOOK:**\n  - At $t=50$, head at $150$, reverses.\n  - At $t=110$, it's at position $150 - (110-50) = 90$. The new requests are behind it.\n  - It completes its sweep to $10$, then reverses for a final sweep to $198$.\n  - Path: $100 \\to 150 \\to 10 \\to 198$.\n  - Total Movement (LOOK): $(150 - 100) + (150 - 10) + (198 - 10) = 50 + 140 + 188 = 378$.\n- **Comparison:** LOOK performs better. This option is incorrect.\n\n**D. Future arrivals: at time $t=70$, cylinders $\\{3, 5\\}$ arrive.**\n- These new requests are in the opposite direction of the initial sweep.\n- **SCAN:** Sweeps $100 \\to 199$, then reverses to service all requests on the way to $0$. Path: $100 \\to 199 \\to 3$ (since 3 is the new minimum). Total Movement: $(199-100)+(199-3) = 99 + 196 = 295$.\n- **LOOK:** Reverses at $150$. Its inward sweep now extends to cylinder $3$. Path: $100 \\to 150 \\to 3$. Total Movement: $(150-100)+(150-3) = 50 + 147 = 197$.\n- **Comparison:** LOOK performs better. This option is incorrect.\n\n**Conclusion and Discussion:**\nOnly Option A creates the specific scenario where SCAN outperforms LOOK. This happens because SCAN's \"wasteful\" journey to the end of the disk (cylinder $199$) can be viewed as a form of **anticipatory scheduling**. It makes a bet that new requests may arrive in the unserviced area beyond the current last request. In option A, this bet pays off. The new requests at $195$ and $198$ are picked up \"for free\" during SCAN's initial outward sweep.\n\nLOOK, conversely, is more conservative. It optimizes for the current state by reversing at the last known request ($150$), minimizing the immediate travel distance. However, this leaves it poorly positioned when the late arrivals appear at the far end of the disk, forcing it to make a long, costly third sweep from $10$ to $198$. This illustrates the fundamental trade-off: SCAN risks wasting movement on the chance of future locality at the disk's extremes, while LOOK minimizes current movement at the risk of being wrong-footed by future arrivals. Without a predictive model for future requests, neither strategy is universally superior.", "answer": "$$\n\\boxed{A}\n$$", "id": "3635730"}, {"introduction": "Shortest Seek Time First (SSTF) is often the most efficient algorithm in terms of minimizing total head movement, but it hides a dangerous potential flaw: starvation. This advanced thought experiment puts you in the role of an adversary, tasking you with constructing a request pattern that indefinitely postpones service to a specific request. By proving that SSTF can be fundamentally unfair, you will gain a deeper appreciation for the fairness guarantees provided by sweep-based algorithms like SCAN. [@problem_id:3635804]", "problem": "Consider a disk with tracks indexed continuously on the closed interval $\\left[0,L\\right]$, where $L>0$ denotes the outermost track index. The disk head moves at constant speed $v>0$ measured in tracks per second, so a pure movement back-and-forth sweep from $0$ to $L$ and back to $0$ takes base time $T=\\frac{2L}{v}$ seconds when no service is performed en route. Each I/O request requires a fixed service time of $1$ second when the head is positioned at its track; the seek time is purely the head movement time determined by $v$ and track distance. A request stream is controlled by an adversary subject to a long-run average arrival rate constraint $\\lambda$ measured in requests per second; the adversary may place each arrival at any track index and time as long as the average rate is $\\lambda$.\n\nThe scheduling policy Shortest Seek Time First (SSTF) always selects the pending request whose track is at minimum seek distance from the current head position. The SCAN policy sweeps monotonically from $0$ to $L$ and then from $L$ back to $0$, servicing all requests encountered along the path in track order without deviating from the current sweep direction.\n\nAt time $t=0$, the head is located at track $y\\in\\left[0,L\\right]$ and there is a pending request at a distinct track $x\\in\\left[0,L\\right]$ with $\\left|x-y\\right|>0$. You are to:\n\n- Construct an adversarial arrival pattern $Q(t)$ that, under SSTF, causes the request at track $x$ to be starved (not serviced) for at least a target duration $\\Delta t>0$. Your construction must respect the arrival rate constraint $\\lambda$ and may optionally include an initial backlog of $b$ requests placed at track $y$ at $t=0$.\n- Using only the core definitions of SSTF and SCAN and the model described above, argue from first principles why SCAN guarantees a bounded waiting time for any single request regardless of adversarial placement, provided that the system is stable in the sense $0\\le\\lambda<1$.\n- Derive the tightest upper bound on the waiting time of an arbitrary request under SCAN in steady state as a symbolic expression in terms of the base sweep time $T$ and the arrival rate $\\lambda$. Express the final bound in seconds.\n\nNo rounding is required; provide your final bound as a closed-form analytic expression.", "solution": "The problem statement is analyzed according to the specified validation protocol.\n\n### Step 1: Extract Givens\n- Disk tracks are indexed continuously on the closed interval $[0, L]$, with $L > 0$.\n- The disk head moves at a constant speed $v > 0$ (tracks/second).\n- A pure back-and-forth sweep ($0 \\to L \\to 0$) takes base time $T = \\frac{2L}{v}$ seconds.\n- Each I/O request requires a fixed service time of $1$ second.\n- Seek time is the head movement time, determined by distance and speed $v$.\n- A request stream arrives with a long-run average rate of $\\lambda$ requests per second.\n- An adversary controls the time and track of each arrival, subject to the rate constraint $\\lambda$.\n- SSTF (Shortest Seek Time First) policy selects the pending request with the minimum seek distance.\n- SCAN policy sweeps monotonically between track $0$ and track $L$, servicing requests encountered on its path.\n- Initial conditions (at $t=0$): head is at track $y \\in [0,L]$; a pending request exists at track $x \\in [0,L]$ with $|x-y| > 0$.\n- Task 1: Construct an adversarial arrival pattern for SSTF to cause starvation of the request at $x$ for a duration $\\Delta t > 0$.\n- Task 2: Argue from first principles why SCAN guarantees bounded waiting time for any request, assuming the system is stable ($0 \\le \\lambda < 1$).\n- Task 3: Derive the tightest upper bound on the waiting time for an arbitrary request under SCAN in steady state, in terms of $T$ and $\\lambda$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is a well-defined theoretical exercise in the analysis of disk scheduling algorithms, a standard topic in operating systems.\n\n- **Scientifically Grounded**: The problem is based on established, albeit simplified, models of disk I/O systems and standard scheduling algorithms (SSTF, SCAN). The concepts of seek time, service time, and arrival rates are fundamental to performance analysis in this domain. All principles are sound within the context of theoretical computer science and algorithm analysis.\n- **Well-Posed**: Each of the three tasks is clearly defined. Task 1 asks for a constructive proof of starvation. Task 2 asks for a qualitative argument based on the algorithm's definition. Task 3 asks for a quantitative derivation of a tight upper bound, a standard objective in algorithm analysis. The condition $0 \\le \\lambda < 1$ provides the necessary stability assumption for the steady-state analysis.\n- **Objective**: The problem is stated using precise, formal language without subjective or ambiguous terminology.\n\nThe problem does not exhibit any of the invalidity flaws. The model, while an abstraction (e.g., continuous tracks), is internally consistent and serves as a valid basis for the required analysis. The concept of an adversary constrained by a long-run average rate is common in competitive analysis of online algorithms. The notion of \"steady state\" combined with an adversary is interpreted to mean the adversary enforces a worst-case pattern that is sustainable under the average rate $\\lambda$, which is a consistent framework for worst-case analysis.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n***\n\n### Part 1: Adversarial Starvation under SSTF\n\nThe goal is to construct an arrival pattern that causes a request at track $x$ to be starved (i.e., its waiting time is made arbitrarily long) by the SSTF scheduler. Let the initial head position be $y$ and the target request be at track $x$. Let the distance be $d = |x-y| > 0$. For definiteness, let's assume $y < x$.\n\nThe adversary's strategy is to generate a stream of new requests that are always closer to the current head position than the target request at $x$. This will trap the head in a small local region, preventing it from ever moving towards $x$.\n\nLet's define a simple oscillating pattern. The adversary chooses a small distance $\\epsilon > 0$ such that $2\\epsilon < d$.\n\n1.  At time $t=0$, the head is at $y$ and a request is pending at $x$. The distance to this request is $d=x-y$.\n2.  The adversary places a new request at track $y_1 = y+\\epsilon$. Since $\\epsilon < d$, the SSTF scheduler will choose to service the request at $y_1$ over the one at $x$.\n    - The time taken for this operation is the seek time $\\frac{|y_1-y|}{v} = \\frac{\\epsilon}{v}$ plus the service time of $1$ second. Total time: $1 + \\frac{\\epsilon}{v}$.\n3.  After this service, the head is at position $y_1 = y+\\epsilon$. The distance to the original request at $x$ is now $x - y_1 = x - (y+\\epsilon) = d-\\epsilon$.\n4.  The adversary now places another request back at the original position $y$. The distance from the head (at $y_1$) to this new request is $|y-y_1| = \\epsilon$.\n5.  SSTF must choose between the request at $x$ (distance $d-\\epsilon$) and the new request at $y$ (distance $\\epsilon$). Since we chose $\\epsilon$ such that $2\\epsilon < d$, it follows that $\\epsilon < d-\\epsilon$. Thus, SSTF will select the request at $y$.\n    - The time taken is again a seek time of $\\frac{\\epsilon}{v}$ plus a service time of $1$. Total time: $1 + \\frac{\\epsilon}{v}$.\n6.  After this service, the head is back at $y$. The situation is identical to the beginning of step 2.\n\nThe adversary can repeat this cycle indefinitely, causing the head to oscillate between tracks $y$ and $y+\\epsilon$. Each cycle services two adversarial requests and takes $2(1 + \\frac{\\epsilon}{v})$ seconds. The request at $x$ is never serviced. This constitutes starvation.\n\nTo starve the request for a specific duration $\\Delta t$, the adversary must sustain this pattern. The number of adversarial requests required is approximately $\\frac{\\Delta t}{1+\\epsilon/v}$. The problem states a \"long-run average arrival rate constraint $\\lambda$\". An adversary can generate a burst of requests with a higher instantaneous rate, as long as it is compensated for by periods of no arrivals, such that the average rate over a sufficiently long period is $\\lambda$. Thus, for any finite $\\Delta t$, such a burst can be constructed without violating the constraint. This construction successfully demonstrates that SSTF is susceptible to starvation.\n\n### Part 2: Bounded Waiting Time under SCAN\n\nThe SCAN algorithm guarantees a bounded waiting time for any request because of the fundamental nature of its operation: the head sweeps monotonically across the disk in one direction, and then reverses and sweeps monotonically in the other.\n\n1.  Consider a request for track $z$ that arrives at time $t_{arrival}$. At this time, the disk head is at some position $h(t_{arrival})$ and moving in a specific direction (e.g., towards $L$).\n2.  There are two cases for the waiting time of this request:\n    a. The head is moving towards the request's track $z$. For example, $h(t_{arrival}) < z$ and the head is moving towards $L$. In this case, the head will continue its sweep and will eventually reach track $z$, at which point the request is serviced. The waiting time is bounded by the time it takes to sweep from its current position to $z$, including servicing any intervening requests.\n    b. The head is moving away from the request's track $z$. For example, the request is at track $z$, and the head has just passed it (e.g., $h(t_{arrival}) = z+\\delta$ for some small $\\delta>0$) and is moving towards $L$. This represents the worst-case scenario for the request at $z$.\n3.  In this worst-case scenario, the head will continue its sweep to the end of the disk (track $L$). Upon reaching $L$, it reverses direction and begins a monotonic sweep back towards track $0$. During this return sweep, it is guaranteed to encounter track $z$. When it does, the request will be serviced.\n4.  Therefore, any request is guaranteed to be serviced within, at most, the time it takes for the head to travel from its current position to one extremity of the disk and then sweep almost all the way back across the disk. The maximum path length for this journey is slightly less than a full round trip ($2L$). The time for this travel is bounded by the base sweep time $T = \\frac{2L}{v}$.\n5.  The total waiting time also includes the time spent servicing other requests. The stability condition $0 \\le \\lambda < 1$ ensures that the request queue does not grow infinitely. This implies that the number of requests serviced during one sweep cycle is finite.\n6.  In summary, because the SCAN algorithm's head movement is non-reversing within a sweep and covers all tracks in a round trip, no request can be indefinitely postponed. Its waiting time is bounded by the duration of (at most) one full round-trip sweep cycle. SSTF lacks this property, as its greedy, non-monotonic movement can be exploited by an adversary to confine the head to a small region of the disk, thereby starving requests outside that region.\n\n### Part 3: Tightest Upper Bound on Waiting Time for SCAN\n\nTo derive the tightest upper bound on the waiting time, we analyze the system in a steady state. The worst-case waiting time for a request occurs when it arrives at a track just as the disk head has passed it. Let's consider a request arriving at track $0$ at the exact moment the head finishes servicing a prior request at track $0$ and begins its sweep towards track $L$. This new request must wait for the head to complete a full cycle: sweep from $0 \\to L$ and then sweep back from $L \\to 0$. The duration of this cycle will be the waiting time for our target request.\n\nLet $W_{max}$ be the maximum waiting time, which corresponds to the duration of this worst-case cycle, $T_{cycle}$. The duration of a cycle is the sum of the total seek time and the total service time for all requests serviced within that cycle.\n\n- The total seek time for a full round trip ($0 \\to L \\to 0$) is constant and given as $T$.\n- Let $N_{cycle}$ be the number of requests serviced during one full cycle. Since each request requires a service time of $1$ second, the total service time is $N_{cycle} \\times 1 = N_{cycle}$.\n\nThe duration of the cycle is therefore:\n$$T_{cycle} = T + N_{cycle}$$\n\nIn a steady state, the system is stable, meaning the rate of requests being serviced must equal the average rate of requests arriving. The number of requests arriving during a cycle of duration $T_{cycle}$ is, on average, $\\lambda T_{cycle}$. For a deterministic worst-case analysis under the steady-state assumption, we equate the number of serviced requests to the number of arrivals:\n$$N_{cycle} = \\lambda T_{cycle}$$\n\nNow we can substitute this expression for $N_{cycle}$ back into the equation for the cycle time:\n$$T_{cycle} = T + (\\lambda T_{cycle})$$\n\nWe can solve this equation for $T_{cycle}$:\n$$T_{cycle} - \\lambda T_{cycle} = T$$\n$$T_{cycle}(1 - \\lambda) = T$$\n$$T_{cycle} = \\frac{T}{1 - \\lambda}$$\n\nThe maximum waiting time $W_{max}$ is the duration of this worst-case cycle. This bound is tight because this scenario is constructible: an adversary can place a request at an extremity (e.g., track $0$) just as the head moves away and then ensure that requests arrive at an average rate of $\\lambda$ during the subsequent sweep to create this exact cycle time. The stability condition $0 \\le \\lambda < 1$ ensures that the denominator is positive and the waiting time is finite. As $\\lambda \\to 1$, $W_{max} \\to \\infty$, reflecting the system becoming unstable. As $\\lambda \\to 0$, $W_{max} \\to T$, reflecting an empty system where the wait is only the travel time.\n\nThus, the tightest upper bound on the waiting time is $\\frac{T}{1-\\lambda}$ seconds.", "answer": "$$\\boxed{\\frac{T}{1 - \\lambda}}$$", "id": "3635804"}]}