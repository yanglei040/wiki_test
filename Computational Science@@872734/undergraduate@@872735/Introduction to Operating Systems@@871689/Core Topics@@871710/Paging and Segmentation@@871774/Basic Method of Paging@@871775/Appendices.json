{"hands_on_practices": [{"introduction": "To build a solid understanding of paging, we begin with the fundamental process of address translation in a single-level system. This practice strips away complexities to focus on the core mechanism: converting a virtual address into a physical address using a page table. By working through concrete examples, you will apply the essential arithmetic of splitting a virtual address into a page number and an offset, use a page table to find the corresponding physical frame, and identify when a requested page is not in memory, triggering a page fault [@problem_id:3623012].", "problem": "Consider a single-level paging system for a process with a virtual address space of size $2^{24}$ bytes. The page size is $4\\,\\text{KiB}$, which equals $2^{12}$ bytes. Physical memory is organized into frames of the same size as pages, and frame indices range from $0$ up to $2047$. A page fault occurs when a referenced virtual page has no valid mapping to a physical frame.\n\nThe process has the following partial page-to-frame mappings (a mapping absent from the list means the page is not currently resident and would cause a page fault):\n- Virtual page $7$ maps to physical frame $33$.\n- Virtual page $15$ maps to physical frame $81$.\n- Virtual page $205$ maps to physical frame $512$.\n- Virtual page $3000$ maps to physical frame $1020$.\n- Virtual page $4095$ maps to physical frame $2047$.\n\nYou are given the following virtual addresses (all in bytes):\n- $VA_1 = 28{,}795$.\n- $VA_2 = 33{,}024$.\n- $VA_3 = 842{,}752$.\n- $VA_4 = 12{,}293{,}120$.\n- $VA_5 = 16{,}777{,}215$.\n- $VA_6 = 61{,}440$.\n\nStarting from core definitions, determine for each $VA_i$ whether it refers to a resident page or incurs a page fault, and if resident, determine the corresponding physical address by translating the virtual address through the given mappings. Let $S$ be defined as the sum of the physical addresses for all resident references plus $1000$ times the number of page faults over the list. Compute $S$.\n\nExpress your final answer for $S$ in bytes as a single exact integer with no rounding and no units. While you should identify page faults in your working, only report the value of $S$.", "solution": "The problem requires us to perform virtual-to-physical address translation for a series of virtual addresses within a single-level paging system, determine which references result in page faults, and compute a final score $S$ based on the results.\n\nFirst, we establish the fundamental principles of address translation in a paging system. A virtual address, denoted as $VA$, is partitioned into two components: a virtual page number ($p$) and a page offset ($d$). The physical address, $PA$, is similarly composed of a physical frame number ($f$) and the same offset $d$. The mapping from $p$ to $f$ is managed by a page table.\n\nThe translation process is as follows:\nGiven a $VA$ and a page size $PS$:\n1.  The virtual page number is calculated by integer division: $p = \\lfloor \\frac{VA}{PS} \\rfloor$.\n2.  The offset is the remainder: $d = VA \\pmod{PS}$.\n3.  The page table is consulted to find the frame number $f$ corresponding to the page number $p$.\n    - If a valid mapping exists, the page is resident in physical memory.\n    - If no valid mapping exists, a page fault occurs.\n4.  If the page is resident, the physical address is constructed: $PA = f \\times PS + d$.\n\nFrom the problem statement, we have the following parameters:\n- The page size is $PS = 4\\,\\text{KiB} = 2^{12}\\,\\text{bytes} = 4096\\,\\text{bytes}$.\n- The partial page table mappings are:\n    - Virtual page $7 \\to$ physical frame $33$.\n    - Virtual page $15 \\to$ physical frame $81$.\n    - Virtual page $205 \\to$ physical frame $512$.\n    - Virtual page $3000 \\to$ physical frame $1020$.\n    - Virtual page $4095 \\to$ physical frame $2047$.\n\nWe will now process each given virtual address. Let $N_{faults}$ be a counter for page faults, initialized to $0$, and $\\sum PA$ be the sum of physical addresses for resident pages, initialized to $0$.\n\n1.  For $VA_1 = 28{,}795$:\n    - Virtual page number $p_1 = \\lfloor \\frac{28795}{4096} \\rfloor = \\lfloor 7.0300... \\rfloor = 7$.\n    - Offset $d_1 = 28795 \\pmod{4096} = 123$.\n    - The page table contains a mapping for virtual page $p_1 = 7$. The corresponding physical frame is $f_1 = 33$. This is a memory hit.\n    - The physical address is $PA_1 = f_1 \\times PS + d_1 = 33 \\times 4096 + 123 = 135168 + 123 = 135291$.\n    - We add this to our sum: $\\sum PA = 135291$.\n\n2.  For $VA_2 = 33{,}024$:\n    - Virtual page number $p_2 = \\lfloor \\frac{33024}{4096} \\rfloor = \\lfloor 8.0625 \\rfloor = 8$.\n    - Offset $d_2 = 33024 \\pmod{4096} = 256$.\n    - The page table does not contain a mapping for virtual page $p_2 = 8$. This is a page fault.\n    - We increment the fault counter: $N_{faults} = 1$.\n\n3.  For $VA_3 = 842{,}752$:\n    - Virtual page number $p_3 = \\lfloor \\frac{842752}{4096} \\rfloor = \\lfloor 205.75 \\rfloor = 205$.\n    - Offset $d_3 = 842752 \\pmod{4096} = 3072$.\n    - The page table contains a mapping for virtual page $p_3 = 205$. The corresponding physical frame is $f_3 = 512$. This is a memory hit.\n    - The physical address is $PA_3 = f_3 \\times PS + d_3 = 512 \\times 4096 + 3072 = 2097152 + 3072 = 2100224$.\n    - We add this to our sum: $\\sum PA = 135291 + 2100224 = 2235515$.\n\n4.  For $VA_4 = 12{,}293{,}120$:\n    - Virtual page number $p_4 = \\lfloor \\frac{12293120}{4096} \\rfloor = \\lfloor 3001.25 \\rfloor = 3001$.\n    - Offset $d_4 = 12293120 \\pmod{4096} = 1024$.\n    - The page table does not contain a mapping for virtual page $p_4 = 3001$. This is a page fault.\n    - We increment the fault counter: $N_{faults} = 2$.\n\n5.  For $VA_5 = 16{,}777{,}215$:\n    - Virtual page number $p_5 = \\lfloor \\frac{16777215}{4096} \\rfloor = \\lfloor 4095.999... \\rfloor = 4095$. Note that $16777215 = 2^{24}-1$. Thus, $p_5=\\lfloor \\frac{2^{24}-1}{2^{12}} \\rfloor = \\lfloor 2^{12} - 2^{-12} \\rfloor = 2^{12}-1=4095$.\n    - Offset $d_5 = 16777215 \\pmod{4096} = 4095$.\n    - The page table contains a mapping for virtual page $p_5 = 4095$. The corresponding physical frame is $f_5 = 2047$. This is a memory hit.\n    - The physical address is $PA_5 = f_5 \\times PS + d_5 = 2047 \\times 4096 + 4095 = 8384512 + 4095 = 8388607$.\n    - We add this to our sum: $\\sum PA = 2235515 + 8388607 = 10624122$.\n\n6.  For $VA_6 = 61{,}440$:\n    - Virtual page number $p_6 = \\lfloor \\frac{61440}{4096} \\rfloor = \\lfloor 15 \\rfloor = 15$.\n    - Offset $d_6 = 61440 \\pmod{4096} = 0$.\n    - The page table contains a mapping for virtual page $p_6 = 15$. The corresponding physical frame is $f_6 = 81$. This is a memory hit.\n    - The physical address is $PA_6 = f_6 \\times PS + d_6 = 81 \\times 4096 + 0 = 331776$.\n    - We add this to our sum: $\\sum PA = 10624122 + 331776 = 10955898$.\n\nAfter processing all virtual addresses, we have the following summary:\n- Total sum of physical addresses for resident pages: $\\sum PA = 10955898$.\n- Total number of page faults: $N_{faults} = 2$.\n\nFinally, we compute the value of $S$ using the given formula:\n$S = (\\sum PA) + 1000 \\times N_{faults}$\n$S = 10955898 + 1000 \\times 2$\n$S = 10955898 + 2000$\n$S = 10957898$.", "answer": "$$\\boxed{10957898}$$", "id": "3623012"}, {"introduction": "While single-level paging illustrates the basic concept, it is impractical for the vast virtual address spaces of modern 64-bit systems, as it would require enormous page tables. The solution is hierarchical (or multi-level) paging, which creates a tree-like structure of page tables. This exercise focuses on the first critical step in navigating this hierarchy: correctly parsing a virtual address into multiple index parts and an offset, based on a specific hardware-defined layout [@problem_id:3623008]. Mastering this bit-level manipulation is key to understanding how operating systems manage memory on a large scale.", "problem": "A computer system implements two-level paging in its virtual memory subsystem. A Virtual Address (VA) is a $32$-bit unsigned integer. Pages have size $4$ kibibytes (KiB), and the two-level page table layout uses $p_{1} = 10$ bits to index the outer page table and $p_{2} = 10$ bits to index the inner page table. The offset within a page uses the remaining low-order bits. The bit layout of the $32$-bit VA, from most significant to least significant bit, is therefore $[p_{1}][p_{2}][\\text{offset}]$. Assume the conventional interpretation that the most significant bit is bit $31$ and the least significant bit is bit $0$, and the layout applies to the logical bit fields of the integer value of the VA (independent of byte endianness).\n\nUsing the concrete Virtual Address (VA) value $VA = \\texttt{0xCAFEBABE}$, compute:\n- the numerical value of the outer page table index (the $p_{1}$-bit field),\n- the numerical value of the inner page table index (the $p_{2}$-bit field),\n- the numerical value of the offset within the page.\n\nExpress your final answer as a single row matrix containing the three integers in the order outer index, inner index, offset. No rounding is required, and no physical units are involved.", "solution": "The problem is first assessed for validity.\n\n### Step 1: Extract Givens\n- Virtual Address ($VA$) size: $32$-bit unsigned integer.\n- Paging scheme: two-level.\n- Page size: $4$ kibibytes (KiB).\n- Outer page table index field size: $p_1 = 10$ bits.\n- Inner page table index field size: $p_2 = 10$ bits.\n- Offset field size: remaining low-order bits.\n- $VA$ bit layout (MSB to LSB): $[p_1][p_2][\\text{offset}]$.\n- Specific $VA$ to analyze: $VA = \\texttt{0xCAFEBABE}$.\n- Required output: numerical values for the outer index, inner index, and offset.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, as two-level paging is a standard memory management technique in operating systems. The given parameters are checked for internal consistency.\n\nThe page size is $4$ KiB. One kibibyte is $2^{10}$ bytes, so the page size is $4 \\times 2^{10} = 2^2 \\times 2^{10} = 2^{12}$ bytes. The number of bits required for the byte offset within a page, let's call it $d$, is determined by the page size:\n$$d = \\log_2(\\text{Page Size in bytes}) = \\log_2(2^{12}) = 12 \\text{ bits}$$\nThe total number of bits in the virtual address is the sum of the bits for the indices and the offset:\n$$\\text{Total bits} = p_1 + p_2 + d = 10 + 10 + 12 = 32 \\text{ bits}$$\nThis matches the specified $32$-bit virtual address size. The problem is self-contained, consistent, and well-posed.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be derived.\n\n### Solution Derivation\n\nThe virtual address is a $32$-bit value. The structure is defined from the most significant bit (MSB), bit $31$, to the least significant bit (LSB), bit $0$.\n- The outer page table index, $p_1$, consists of the $10$ most significant bits (bits $31$ down to $22$).\n- The inner page table index, $p_2$, consists of the next $10$ bits (bits $21$ down to $12$).\n- The offset, $d$, consists of the $12$ least significant bits (bits $11$ down to $0$).\n\nThe specific virtual address to analyze is given in hexadecimal as $VA = \\texttt{0xCAFEBABE}$. To extract the fields, we first convert this hexadecimal value to its $32$-bit binary representation. Each hexadecimal digit corresponds to $4$ binary bits:\n- $\\texttt{C}_{16} = 12_{10} = 1100_2$\n- $\\texttt{A}_{16} = 10_{10} = 1010_2$\n- $\\texttt{F}_{16} = 15_{10} = 1111_2$\n- $\\texttt{E}_{16} = 14_{10} = 1110_2$\n- $\\texttt{B}_{16} = 11_{10} = 1011_2$\n\nAssembling the full binary string for $VA = \\texttt{0xCAFEBABE}$:\n$$VA_{\\text{bin}} = 11001010111111101011101010111110_2$$\n\nNow, we partition this $32$-bit string into the three fields according to their specified sizes ($10$, $10$, and $12$ bits):\n$$VA_{\\text{bin}} = \\underbrace{1100101011}_{p_1 \\text{ (10 bits)}} \\underbrace{1111101011}_{p_2 \\text{ (10 bits)}} \\underbrace{101010111110}_{d \\text{ (12 bits)}}$$\n\nWe proceed to compute the decimal value for each field.\n\n1.  **Outer Page Table Index ($p_1$)**:\n    The binary value is $1100101011_2$. Its decimal equivalent is:\n    $$p_1 = 1 \\cdot 2^9 + 1 \\cdot 2^8 + 0 \\cdot 2^7 + 0 \\cdot 2^6 + 1 \\cdot 2^5 + 0 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0$$\n    $$p_1 = 512 + 256 + 0 + 0 + 32 + 0 + 8 + 0 + 2 + 1 = 811$$\n\n2.  **Inner Page Table Index ($p_2$)**:\n    The binary value is $1111101011_2$. Its decimal equivalent is:\n    $$p_2 = 1 \\cdot 2^9 + 1 \\cdot 2^8 + 1 \\cdot 2^7 + 1 \\cdot 2^6 + 1 \\cdot 2^5 + 0 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0$$\n    $$p_2 = 512 + 256 + 128 + 64 + 32 + 0 + 8 + 0 + 2 + 1 = 1003$$\n\n3.  **Offset ($d$)**:\n    The binary value is $101010111110_2$. This corresponds to the last three hexadecimal digits, $\\texttt{ABE}_{16}$. Its decimal equivalent is:\n    $$d = 10 \\cdot 16^2 + 11 \\cdot 16^1 + 14 \\cdot 16^0$$\n    $$d = 10 \\cdot 256 + 11 \\cdot 16 + 14 \\cdot 1$$\n    $$d = 2560 + 176 + 14 = 2750$$\n    Alternatively, from its binary representation:\n    $$d = 1 \\cdot 2^{11} + 0 \\cdot 2^{10} + 1 \\cdot 2^9 + 0 \\cdot 2^8 + 1 \\cdot 2^7 + 0 \\cdot 2^6 + 1 \\cdot 2^5 + 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 0 \\cdot 2^0$$\n    $$d = 2048 + 512 + 128 + 32 + 16 + 8 + 4 + 2 = 2750$$\n\nThe computed integer values are $811$ for the outer page table index, $1003$ for the inner page table index, and $2750$ for the offset.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n811  1003  2750\n\\end{pmatrix}\n}\n$$", "id": "3623008"}, {"introduction": "The process of walking a page table for every memory reference would be prohibitively slow. To solve this, CPUs use a fast caching mechanism called the Translation Lookaside Buffer (TLB). However, the TLB's effectiveness hinges on the principle of localityâ€”the tendency of programs to reuse addresses. This practice explores a worst-case scenario where a program's access pattern completely defeats the TLB, leading to a \"thrashing\" condition where every access is a miss. By analyzing this pointer-chasing workload, you will calculate the resulting effective access time and gain a deeper appreciation for how software behavior and hardware design interact to determine real-world performance [@problem_id:3622966].", "problem": "A process running on a system with demand paging constructs a singly linked list whose nodes are deliberately placed so that successive pointer dereferences visit a different virtual page each time. The list spans $W$ distinct virtual pages and is traversed cyclically. The memory management unit uses a Translation Lookaside Buffer (TLB) with $E$ fully associative entries and Least Recently Used (LRU) replacement. Assume the following hardware timing characteristics: each TLB lookup takes $t_{\\mathrm{TLB}} = 1.5\\,\\mathrm{ns}$ and each main memory access takes $t_{\\mathrm{mem}} = 65\\,\\mathrm{ns}$. The system employs a single-level page table stored in main memory with no additional caching; on a TLB miss, the page table is consulted by reading the relevant page-table entry from memory before reading the requested data from memory. There are no page faults in this workload (all pages are resident), and the TLB lookup is not overlapped with memory access.\n\nGiven $E = 64$ and $W = 8192$ with the described pointer-chasing pattern, determine the worst-case TLB hit rate $h$ and the Effective Access Time (EAT) per pointer dereference. Express the EAT in nanoseconds and round your EAT to four significant figures. Provide your final answer as a row matrix $\\begin{pmatrix} h  \\text{EAT} \\end{pmatrix}$, where $h$ is a decimal between $0$ and $1$, and EAT is the rounded numeric value in nanoseconds.", "solution": "The user wants me to solve the problem by first validating it, then providing a detailed solution if valid.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Data structure and access pattern: A singly linked list is traversed cyclically. Successive pointer dereferences access a sequence of $W$ distinct virtual pages.\n- Number of distinct virtual pages in the working set: $W = 8192$.\n- TLB entries: $E = 64$.\n- TLB organization: Fully associative.\n- TLB replacement policy: Least Recently Used (LRU).\n- TLB lookup time: $t_{\\mathrm{TLB}} = 1.5\\,\\mathrm{ns}$.\n- Main memory access time: $t_{\\mathrm{mem}} = 65\\,\\mathrm{ns}$.\n- Page table structure: Single-level, stored in main memory.\n- System conditions: No page faults (all pages are resident). TLB lookup is not overlapped with memory access.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective. It describes a standard scenario in computer architecture and operating systems for analyzing the performance of a memory management unit. The parameters given are realistic and sufficient to determine a unique solution. The access pattern described is a \"pointer-chasing\" workload, which represents a worst-case scenario for spatial and temporal locality, making it a valid and interesting case for analysis. The problem is free from any scientific, logical, or factual flaws. It is self-contained and unambiguous.\n\n**Step 3: Verdict and Action**\nThe problem is valid. I will proceed with a full solution.\n\n### Solution\n\nThe problem requires the calculation of the worst-case Translation Lookaside Buffer (TLB) hit rate, $h$, and the Effective Access Time (EAT) for a specific pointer-chasing workload.\n\n**1. Analysis of the TLB Hit Rate ($h$)**\n\nThe workload involves cyclically traversing a linked list that spans $W = 8192$ distinct virtual pages. Each node access corresponds to an access to a new virtual page. The sequence of virtual page accesses is $P_1, P_2, \\dots, P_{8192}, P_1, P_2, \\dots$.\n\nThe TLB is fully associative with $E = 64$ entries and uses the Least Recently Used (LRU) replacement policy. This means the TLB can hold translations for $64$ different virtual pages at any time. When a new translation must be loaded into a full TLB, the one that has not been used for the longest time is evicted.\n\nThe number of distinct pages in the access cycle, $W = 8192$, is significantly larger than the number of entries in the TLB, $E = 64$. Let's trace the state of the TLB during the first traversal cycle:\n- The first $64$ memory accesses are to pages $P_1, P_2, \\dots, P_{64}$. Since the TLB starts empty, each of these accesses will result in a TLB miss. After the access to $P_{64}$, the TLB is full and contains the page-to-frame translations for pages $P_1$ through $P_{64}$. The least recently used entry is for $P_1$, and the most recently used is for $P_{64}$.\n\n- The $65$-th access is to page $P_{65}$. This is a guaranteed TLB miss, as its translation is not in the TLB. Because the TLB is full, the LRU entry, which is the translation for page $P_1$, is evicted to make space for the translation of $P_{65}$.\n\n- The $66$-th access is to page $P_{66}$. This is also a miss. The LRU entry, now for page $P_2$, is evicted.\n\n- This pattern continues. For any access to a page $P_i$ (where $i  E$), the TLB will not contain its translation. The access will be a miss, and the translation for page $P_{i-E}$ will be evicted.\n\nBy the time the traversal reaches the end of the list at page $P_{8192}$, the TLB will contain the translations for the last $64$ pages accessed: {$P_{8129}, P_{8130}, \\dots, P_{8192}$}.\n\nWhen the traversal wraps around and accesses page $P_1$ again, its translation is required. However, the translation for $P_1$ was evicted from the TLB at the time of the access to page $P_{65}$. Since the access sequence consists of $8192$ unique pages before repeating, and $8192  64$, the translation for any given page $P_i$ will have been evicted long before $P_i$ is accessed again.\n\nTherefore, in the steady state of this cyclic traversal, every single memory access results in a TLB miss. The number of TLB hits is $0$. The TLB hit rate, $h$, is the ratio of hits to total accesses:\n$$h = \\frac{\\text{Number of Hits}}{\\text{Total Accesses}} = \\frac{0}{\\text{Total Accesses}} = 0$$\n\n**2. Calculation of the Effective Access Time (EAT)**\n\nThe EAT is the weighted average of the time taken for a TLB hit and a TLB miss. The general formula is:\n$$ \\text{EAT} = h \\times T_{\\text{hit}} + (1-h) \\times T_{\\text{miss}} $$\nwhere $T_{\\text{hit}}$ is the time for a TLB hit and $T_{\\text{miss}}$ is the time for a TLB miss.\n\nFirst, let's determine $T_{\\text{hit}}$ and $T_{\\text{miss}}$.\n- **Time for a TLB hit ($T_{\\text{hit}}$):** On a hit, the address translation is found in the TLB. The total time is the TLB lookup time plus the time to access data from main memory. Since the lookup and memory access are not overlapped:\n$$ T_{\\text{hit}} = t_{\\mathrm{TLB}} + t_{\\mathrm{mem}} = 1.5\\,\\mathrm{ns} + 65\\,\\mathrm{ns} = 66.5\\,\\mathrm{ns} $$\n\n- **Time for a TLB miss ($T_{\\text{miss}}$):** On a miss, a more complex sequence of events occurs. Given no page faults and a single-level page table:\n    1. A TLB lookup is performed, which fails: $t_{\\mathrm{TLB}}$.\n    2. The hardware must then access the page table in main memory to retrieve the Page Table Entry (PTE): $t_{\\mathrm{mem}}$.\n    3. Using the physical frame address from the PTE, the hardware accesses the requested data from main memory: $t_{\\mathrm{mem}}$.\nThe total time for a miss is the sum of these sequential operations:\n$$ T_{\\text{miss}} = t_{\\mathrm{TLB}} + t_{\\mathrm{mem}} + t_{\\mathrm{mem}} = t_{\\mathrm{TLB}} + 2 \\times t_{\\mathrm{mem}} $$\n$$ T_{\\text{miss}} = 1.5\\,\\mathrm{ns} + 2 \\times 65\\,\\mathrm{ns} = 1.5\\,\\mathrm{ns} + 130\\,\\mathrm{ns} = 131.5\\,\\mathrm{ns} $$\n\nNow, we can calculate the EAT using the hit rate $h=0$. The miss rate is $1-h = 1$.\n$$ \\text{EAT} = (0) \\times T_{\\text{hit}} + (1) \\times T_{\\text{miss}} $$\n$$ \\text{EAT} = T_{\\text{miss}} = 131.5\\,\\mathrm{ns} $$\n\nThe problem asks for the EAT to be rounded to four significant figures. The value $131.5$ already has four significant figures (1, 3, 1, 5), so no further rounding is needed.\n\nThe final answer is the TLB hit rate $h=0$ and the EAT of $131.5\\,\\mathrm{ns}$.", "answer": "$$ \\boxed{\\begin{pmatrix} 0  131.5 \\end{pmatrix}} $$", "id": "3622966"}]}