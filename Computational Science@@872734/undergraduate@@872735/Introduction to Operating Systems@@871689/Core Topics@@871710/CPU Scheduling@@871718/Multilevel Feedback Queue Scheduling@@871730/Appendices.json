{"hands_on_practices": [{"introduction": "The primary goal of a Multilevel Feedback Queue (MLFQ) is to prioritize interactive tasks over CPU-bound ones without prior knowledge of a task's behavior. However, a naive implementation can be \"gamed\" by a clever process that yields the CPU just before its time quantum expires, thus remaining in the highest-priority queue indefinitely. This exercise [@problem_id:3660276] challenges you to think like an operating system designer, evaluating different strategies to counter this behavior and selecting a solution that is both effective and adheres to the strict performance constraints of a real-world kernel.", "problem": "An operating system uses a Multilevel Feedback Queue (MLFQ) scheduler with multiple priority queues. The highest-priority queue has a time quantum of $q$ milliseconds. By design, a process that uses its full $q$ is demoted to a lower-priority queue, while a process that yields the processor before using the full $q$ remains in the highest-priority queue. The goal of MLFQ is to preferentially serve interactive tasks while allowing long-running Central Processing Unit (CPU) bound tasks to drift downward in priority over time. Consider a process $P$ that deliberately yields at time $q - \\varepsilon$ (for some small $\\varepsilon \\in (0, q)$) in each dispatch to avoid demotion, but repeats this very frequently, consuming a large fraction of CPU time over wall-clock time. To counter this gaming behavior while preserving MLFQ responsiveness for genuinely interactive tasks, the scheduler designer proposes tracking a per-process CPU “credit” $C$ that reflects recent CPU consumption and demoting a process if $C$ exceeds a threshold $\\kappa$, even if the process frequently yields before consuming a full quantum.\n\nYou are told the following foundational facts and definitions:\n- MLFQ emulates Shortest Job First bias by adapting priorities based on observed recent behavior, not lifetime behavior, to achieve low response time for interactive tasks.\n- Any mechanism that bases demotion solely on “did the process consume a full quantum” can be gamed by voluntary yields; therefore, the demotion decision must correlate with recent CPU usage over wall-clock time and must not be reset by yields.\n- The operating system must implement the rule with per-process state and update cost bounded by $O(1)$ per clock tick and $O(1)$ per scheduling event, independent of any tunable window length parameter.\n- Interactive tasks are characterized by short, infrequent CPU bursts separated by Input/Output (I/O) waits; CPU-bound tasks exhibit sustained CPU usage with few or no I/O waits over recent time.\n\nAssume $q = 10$ milliseconds and that $P$ yields at $q - 1$ milliseconds on each dispatch, repeating often. Suppose the designer wants a policy that, for a tunable “recentness scale” of about $W = 200$ milliseconds and a threshold $\\kappa = 60$ milliseconds, would demote $P$ despite its frequent yields, while not demoting a truly interactive task that uses about $5$ milliseconds of CPU time every $200$ milliseconds.\n\nWhich of the following candidate rules for defining and acting on $C$ best achieves the stated goals and constraints?\n\nA. Define $C$ as the cumulative CPU time a process has used since creation. Demote immediately once $C > \\kappa$; $C$ never decreases and is never reset.\n\nB. Define $C$ as the total CPU time used in the most recent sliding window of the last $W$ milliseconds of wall-clock time, updated precisely at each millisecond with a moving window. Demote whenever $C > \\kappa$; allow re-promotion only via the system’s periodic global priority boost.\n\nC. Define $C$ as the CPU time used since the last dispatch. Reset $C$ to $0$ on every voluntary yield. Demote if and only if $C \\ge \\kappa$ at a preemption or yield.\n\nD. Define $C$ as the count of voluntary yields in the last $W$ milliseconds. Demote when the count exceeds a fixed threshold, on the rationale that frequent yielding is indicative of gaming.\n\nE. Define $C$ as an Exponentially Weighted Moving Average (EWMA) of recent CPU use over wall-clock time: at each scheduler tick of length $\\tau$, update $C \\leftarrow \\lambda C + (1 - \\lambda) U$, where $U \\in \\{0, 1\\}$ indicates whether the process used the CPU during the last tick and $\\lambda \\approx e^{-\\tau / W}$. Demote when $C \\cdot W > \\kappa$, and allow promotion once $C \\cdot W$ decays below $\\kappa$, regardless of yields or sleeps; sleeping causes $U = 0$, so $C$ decays during I/O waits.\n\nSelect the best option under the given goals and constraints. Provide a brief justification rooted in fundamental MLFQ principles and the stated implementation constraints. There may be more than one plausible rule, but select the one that satisfies all constraints and achieves the intended behavior in the numerical scenario described.", "solution": "The problem statement is analyzed for validity before proceeding to a solution.\n\n### Step 1: Extract Givens\n- **Scheduler Type**: Multilevel Feedback Queue (MLFQ).\n- **Highest Priority Queue Quantum**: $q$ milliseconds.\n- **Standard Demotion Rule**: A process is demoted if it uses its full time quantum $q$.\n- **Standard Retention Rule**: A process remains at its priority level if it yields before using the full quantum $q$.\n- **Goal**: Preferentially serve interactive tasks; let CPU-bound tasks drift to lower priorities.\n- **Problem to Solve**: A process $P$ \"games\" the scheduler by repeatedly using nearly the full quantum ($q - \\varepsilon$) and then yielding to avoid demotion, thereby monopolizing the CPU. Here $\\varepsilon$ is a small positive time, $\\varepsilon \\in (0, q)$.\n- **Proposed Solution Framework**: Introduce a CPU \"credit\" metric, $C$. A process is demoted if $C$ exceeds a threshold $\\kappa$, regardless of whether it completed a full quantum.\n- **Foundational Principles  Constraints**:\n    1.  The scheduler must adapt based on *recent* behavior, not lifetime behavior.\n    2.  The demotion rule must be based on recent CPU usage over wall-clock time and must *not* be reset by voluntary yields.\n    3.  The implementation must have a computational cost of $O(1)$ per clock tick and $O(1)$ per scheduling event, with storage and computation costs being independent of any tunable window length parameter.\n    4.  Interactive tasks are defined by short, infrequent CPU bursts. CPU-bound tasks have sustained CPU usage.\n- **Numerical Scenario**:\n    - Time quantum $q = 10$ ms.\n    - Gaming process $P$ yields at $t = q - 1 = 9$ ms.\n    - Tunable \"recentness scale\": $W = 200$ ms.\n    - CPU usage threshold: $\\kappa = 60$ ms.\n    - A truly interactive task uses about $5$ ms of CPU every $200$ ms and should not be demoted.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is scientifically grounded in the well-established domain of operating system scheduling algorithms, specifically MLFQ. The \"gaming\" scenario described is a known weakness of naive MLFQ implementations. The constraints provided, such as the $O(1)$ update cost, are realistic and critical considerations in OS kernel design. The problem is well-posed, providing clear objectives (demote the gamer, protect the interactive task), explicit numerical parameters for a test case, and a set of distinct algorithmic options to evaluate. The language is objective and technical. The problem does not violate any of the invalidity criteria.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be derived by evaluating each option against the stated goals and constraints.\n\n### Solution Derivation and Option Analysis\n\nThe core requirements for a successful rule are:\n1.  **Effectiveness against Gaming**: It must demote process $P$, which uses $9$ ms of CPU frequently enough to accumulate over $60$ ms of usage within a $200$ ms wall-clock period.\n2.  **Protection of Interactivity**: It must **not** demote a task that uses only $5$ ms of CPU in a $200$ ms period.\n3.  **Adherence to Principles**: The metric must reflect *recent* CPU usage and not be reset by voluntary yields.\n4.  **Performance Constraint**: The update mechanism must have $O(1)$ time and space complexity, independent of the window size $W$.\n\n**Analysis of Option A:**\n- **Rule**: $C$ is the cumulative CPU time since process creation. Demote when $C > \\kappa$.\n- **Evaluation**: This rule would eventually demote the gaming process $P$ once its total CPU usage exceeds $\\kappa = 60$ ms. However, it would also demote any long-running interactive task. An interactive process that uses $5$ ms of CPU every $200$ ms would be demoted after $13$ such bursts (totaling $65$ ms of CPU usage over $2.6$ seconds), even though its recent behavior is perfectly interactive. This violates the foundational principle that MLFQ should adapt to *recent* behavior, not lifetime history.\n- **Verdict**: **Incorrect**.\n\n**Analysis of Option B:**\n- **Rule**: $C$ is the sum of CPU time used in a precise sliding window of the last $W = 200$ ms of wall-clock time. Demote when $C > \\kappa$.\n- **Evaluation**: This rule is conceptually ideal. For the gaming process $P$, if it consumes more than $60$ ms of CPU within any $200$ ms interval, it will be demoted. For the interactive process, its usage in any $200$ ms window is $\\approx 5$ ms, which is less than $\\kappa = 60$ ms, so it would not be demoted. This meets the behavioral goals. However, the implementation constraint is \"updated precisely at each millisecond with a moving window.\" This would require storing the usage for each of the last $200$ ms, for instance, in a circular buffer of size $200$. The memory requirement for this data structure is $O(W)$. This violates the strict constraint that the implementation cost must be independent of the tunable parameter $W$.\n- **Verdict**: **Incorrect**.\n\n**Analysis of Option C:**\n- **Rule**: $C$ is the CPU time used since the last dispatch, reset to $0$ on every voluntary yield. Demote if $C \\ge \\kappa$.\n- **Evaluation**: This rule is fundamentally flawed. The gaming process $P$ runs for $9$ ms and then voluntarily yields. At the point of yielding, its current CPU usage is $C = 9$ ms. Since $9  \\kappa = 60$, it is not demoted. The rule then resets $C$ to $0$. This mechanism is exactly what the process is exploiting. The rule explicitly allows the gaming to succeed and directly contradicts the requirement that the demotion decision \"must not be reset by yields\".\n- **Verdict**: **Incorrect**.\n\n**Analysis of Option D:**\n- **Rule**: $C$ is the count of voluntary yields in the last $W$ ms. Demote if the count exceeds a threshold.\n- **Evaluation**: This rule attempts to address the problem by punishing a symptom (frequent yields) rather than the underlying cause (high CPU consumption). While it might demote process $P$, it is a brittle heuristic. First, it conflates voluntary yielding (e.g., `sched_yield`) with blocking for I/O, which is what true interactive processes do. If an I/O block is counted as a yield, interactive processes would be unfairly punished. If it is not, a gaming process could easily adapt by performing a trivial, fast I/O operation instead of yielding, thus appearing interactive to this rule. Most importantly, this rule fails to meet the specified requirement that the \"demotion decision must correlate with recent CPU usage over wall-clock time\".\n- **Verdict**: **Incorrect**.\n\n**Analysis of Option E:**\n- **Rule**: $C$ is an Exponentially Weighted Moving Average (EWMA) of CPU use. Update at each tick $\\tau$: $C \\leftarrow \\lambda C + (1 - \\lambda) U$, where $U \\in \\{0, 1\\}$ indicates CPU use by the process in that tick, and $\\lambda \\approx e^{-\\tau / W}$. Demote when $C \\cdot W > \\kappa$.\n- **Evaluation**:\n    - **Performance Constraint**: The update requires one multiplication and one addition per tick, which is $O(1)$ computation. The state required per process is a single floating-point number $C$, which is $O(1)$ space. Both are independent of $W$. This meets the performance constraint.\n    - **Adherence to Principles**: A yield does not reset $C$; it merely ends the period where $U=1$ for the process. $C$ tracks recent CPU usage by its very definition as a moving average. When a process sleeps for I/O, $U=0$, causing $C$ to decay exponentially. This correctly models the behavior of an interactive task and allows a demoted process to be promoted again if its behavior changes.\n    - **Effectiveness**: The term $C$ approximates the fraction of recent time the process has been running. The condition for demotion, $C \\cdot W > \\kappa$, compares the estimated recent CPU usage (fraction $C$ of time window $W$) to the threshold $\\kappa$.\n        - **Gaming Process $P$**: This process has a high duty cycle. If it uses CPU for $9$ out of every, say, $15$ ms, its duty cycle is $9/15 = 0.6$. The EWMA $C$ will converge to $\\approx 0.6$. The check becomes $C \\cdot W \\approx 0.6 \\cdot 200 = 120$ ms. Since $120 > \\kappa = 60$, the process is correctly demoted.\n        - **Interactive Process**: This process uses CPU for $5$ ms every $200$ ms. Its duty cycle is $5/200 = 0.025$. Its EWMA $C$ will converge to $\\approx 0.025$. The check becomes $C \\cdot W \\approx 0.025 \\cdot 200 = 5$ ms. Since $5  \\kappa = 60$, the process is correctly protected from demotion.\n    - The EWMA is a standard, computationally efficient technique for approximating a sliding window average (as in Option B) while satisfying the strict $O(1)$ complexity constraints. It fulfills all the requirements.\n- **Verdict**: **Correct**.", "answer": "$$\\boxed{E}$$", "id": "3660276"}, {"introduction": "Every time-sharing scheduler faces a fundamental trade-off between throughput and response time, a conflict directly controlled by the choice of time quantum, $Q_0$. A large quantum reduces the overhead from context switches, boosting throughput, but a small quantum ensures that interactive tasks get to run frequently, improving responsiveness. This practice [@problem_id:3660269] moves beyond this qualitative understanding, guiding you to build a quantitative model that captures this trade-off, enabling you to calculate the optimal time quantum that maximizes performance while satisfying a given latency requirement.", "problem": "A single Central Processing Unit (CPU) runs a Multilevel Feedback Queue (MLFQ) scheduler whose top-priority queue uses strict priority over all lower queues and time-slices tasks using round-robin. The top queue’s time quantum is $Q_0$ ticks. The scheduler’s tick frequency is $f$ ticks per second, so one tick lasts $1/f$ seconds. Each time a timeslice ends and the scheduler selects the next task, the system incurs a context-switch cost of $c$ seconds. Assume that the top queue is continuously non-empty due to $n$ always-ready interactive tasks, and that strict priority ensures lower queues do not interfere with the timing of the top queue.\n\nAdopt the following definitions and assumptions:\n- Throughput is the long-run fraction of time spent on useful task execution (not context switching) while the top queue remains continuously busy.\n- Worst-case response time for a top-queue interactive task is the largest possible time from the moment the task becomes ready to run until the start of its next CPU service in the top queue, under round-robin rotation among the $n$ top-queue tasks.\n\nYou are given $f = 1000$ ticks per second, $c = 3.0 \\times 10^{-4}$ seconds, $n = 6$, and an interactive latency requirement $T_{\\text{resp}} \\le X$ with $X = 2.0 \\times 10^{-2}$ seconds. Choose $Q_0$ to maximize throughput subject to the latency constraint for the top queue. Report the optimal $Q_0$ as an integer number of ticks. The final answer must be a single number with no units.", "solution": "The problem asks for the optimal time quantum $Q_0$ for the top-priority queue of a Multilevel Feedback Queue (MLFQ) scheduler. The optimization objective is to maximize throughput, subject to a constraint on the worst-case response time for tasks in that queue. $Q_0$ must be an integer number of ticks.\n\nFirst, we formalize the scheduler's performance metrics based on the given parameters. The givens are:\n- Tick frequency, $f = 1000$ ticks/second.\n- Context-switch cost, $c = 3.0 \\times 10^{-4}$ seconds.\n- Number of always-ready tasks in the top queue, $n = 6$.\n- Maximum allowed worst-case response time, $X = 2.0 \\times 10^{-2}$ seconds.\n\nThe time quantum for the top queue is $Q_0$ ticks. The duration of this time quantum in seconds, denoted $T_Q$, is given by the number of ticks divided by the tick frequency:\n$$\nT_Q = \\frac{Q_0}{f}\n$$\n\nNext, we formulate the expression for throughput. Throughput, denoted $\\eta$, is defined as the fraction of time the CPU spends on useful task execution, as opposed to context-switching overhead. In a round-robin system with a non-empty queue, the CPU repeatedly performs a task execution for a duration of $T_Q$ followed by a context switch of duration $c$. The total time for one such task \"slice\" and its subsequent context switch is $T_Q + c$. The fraction of this time that is useful work is:\n$$\n\\eta = \\frac{T_Q}{T_Q + c}\n$$\nSubstituting the expression for $T_Q$ in terms of $Q_0$:\n$$\n\\eta(Q_0) = \\frac{Q_0/f}{Q_0/f + c} = \\frac{Q_0}{Q_0 + fc}\n$$\nTo maximize throughput, we analyze how $\\eta$ changes with $Q_0$. We can examine the derivative of $\\eta$ with respect to $Q_0$:\n$$\n\\frac{d\\eta}{dQ_0} = \\frac{(1)(Q_0 + fc) - Q_0(1)}{(Q_0 + fc)^2} = \\frac{fc}{(Q_0 + fc)^2}\n$$\nSince $f  0$ and $c  0$, the derivative $\\frac{d\\eta}{dQ_0}$ is always positive for any non-negative $Q_0$. This indicates that throughput $\\eta(Q_0)$ is a monotonically increasing function of $Q_0$. Therefore, to maximize throughput, we must choose the largest possible value of $Q_0$ that satisfies the given constraints.\n\nNow, we formulate the expression for the worst-case response time, $T_{\\text{resp}}$. The problem defines this as the largest possible time from the moment a task becomes ready until the start of its next CPU service. For the $n=6$ always-ready tasks in the top queue, a task becomes ready again at the instant its previous time quantum expires. To determine the waiting time until its next service begins, we must account for the execution of all other tasks and the associated context switches.\n\nConsider a task, Task A, that has just finished its time quantum. It waits in the ready queue while the other $n-1$ tasks are serviced. The sequence of events before Task A can run again is as follows:\n1. A context switch from Task A to the next task in the queue.\n2. The next task runs for its quantum, $T_Q$.\n3. This pattern of (context switch, task execution) repeats for all $n-1$ other tasks.\n4. Finally, a context switch occurs to bring Task A back onto the CPU. The service for Task A begins only after this final context switch is complete.\n\nThe total duration of this waiting period comprises the execution time of the $n-1$ other tasks and the time for all context switches that occur. There is one context switch for each of the $n$ tasks in a full rotation. Thus, the total waiting time is the sum of $(n-1)$ time quanta and $n$ context switches:\n$$\nT_{\\text{resp}} = (n-1)T_Q + nc\n$$\nSubstituting $T_Q = Q_0/f$:\n$$\nT_{\\text{resp}}(Q_0) = (n-1)\\frac{Q_0}{f} + nc\n$$\nThe problem imposes a latency constraint: $T_{\\text{resp}} \\le X$. We can now establish an upper bound for $Q_0$:\n$$\n(n-1)\\frac{Q_0}{f} + nc \\le X\n$$\nSolving for $Q_0$:\n$$\n(n-1)\\frac{Q_0}{f} \\le X - nc\n$$\n$$\nQ_0 \\le \\frac{f(X - nc)}{n-1}\n$$\nSince our goal is to maximize $Q_0$, we should choose the largest value allowed by this inequality. As $Q_0$ must be an integer number of ticks, the optimal value is the floor of the expression on the right-hand side.\n$$\nQ_{0, \\text{optimal}} = \\left\\lfloor \\frac{f(X - nc)}{n-1} \\right\\rfloor\n$$\nNow, we substitute the given numerical values:\n- $f = 1000$\n- $c = 3.0 \\times 10^{-4}$\n- $n = 6$\n- $X = 2.0 \\times 10^{-2}$\n\nFirst, calculate the term $nc$:\n$$\nnc = 6 \\times (3.0 \\times 10^{-4}) = 18.0 \\times 10^{-4} = 0.0018 \\text{ seconds}\n$$\nNext, calculate the numerator $f(X-nc)$:\n$$\nf(X - nc) = 1000 \\times (2.0 \\times 10^{-2} - 0.0018) = 1000 \\times (0.02 - 0.0018) = 1000 \\times 0.0182 = 18.2\n$$\nThe denominator is $n-1 = 6-1=5$.\nNow we can find the maximum value for $Q_0$:\n$$\nQ_0 \\le \\frac{18.2}{5} = 3.64\n$$\nSince $Q_0$ must be an integer number of ticks, the maximum integer value that satisfies this constraint is $\\lfloor 3.64 \\rfloor$.\n$$\nQ_{0, \\text{optimal}} = 3\n$$\nThus, the optimal time quantum for the top queue is $3$ ticks. This value maximizes throughput while ensuring the worst-case response time does not exceed the specified limit.", "answer": "$$\\boxed{3}$$", "id": "3660269"}, {"introduction": "An operating system is more than a collection of independent components; its mechanisms interact in complex and sometimes unexpected ways. This exercise [@problem_id:3660203] explores the critical intersection of scheduling and synchronization, focusing on the hazardous problem of priority inversion, where a high-priority task is forced to wait for a low-priority one. You will analyze a bounded priority donation policy designed to solve this issue, tracing task execution step-by-step to determine if the solution is robust or if it creates new failure modes and vulnerabilities.", "problem": "A system uses a Multilevel Feedback Queue (MLFQ) scheduler with the following properties grounded in standard definitions of preemptive priority scheduling and time-slicing. There are $3$ queues, $Q_0$ (highest priority), $Q_1$, and $Q_2$ (lowest priority). The policy is preemptive strictly by queue level: any ready task in a higher-priority queue preempts tasks in lower-priority queues. Within a queue, tasks are scheduled using Round-Robin (RR) with a fixed time quantum. The time quanta are $q_0 = 5\\,\\mathrm{ms}$ for $Q_0$, $q_1 = 10\\,\\mathrm{ms}$ for $Q_1$, and $q_2 = 20\\,\\mathrm{ms}$ for $Q_2$. Assume a single Central Processing Unit (CPU) and negligible context-switch overhead (assume $0$ for analysis).\n\nThe system employs Fast Userspace Mutex (futex)-based locks with priority donation across MLFQ levels: if a task $H$ in $Q_0$ attempts to lock a mutex held by task $L$ in a lower-priority queue, then $L$ inherits a temporary boost to $Q_0$. The donation is bounded: the lock holder $L$ is granted a cumulative CPU-time budget of at most $W$ while running at $Q_0$ due to this donation. The donation begins immediately at the next scheduling decision when $H$ blocks and places $L$ at the head of $Q_0$. The budget $W$ is decremented only while $L$ runs (i.e., wall-clock time where other tasks run does not decrease $W$). When $L$ releases the mutex or when $L$ exhausts its donated CPU budget $W$, the donation ends. For each continuous lock hold, at most one donation window is granted to $L$ (no re-donation until the lock is released and reacquired).\n\nConsider the following scenario grounded in these definitions:\n- At time $t = 0$, a task $L$ resides in $Q_2$ and already holds the mutex; the remaining critical section length is $C$ units of CPU time (assume $C$ is known).\n- At time $t = 0$, a task $H$ in $Q_0$ attempts to acquire the mutex and blocks on the futex held by $L$, triggering the bounded donation described above.\n- At time $t = 0$, there also exists a distinct task $R$ in $Q_0$ that is always ready (CPU-bound), unrelated to the mutex. Task $R$ remains ready at all times and never blocks.\n- There are no other tasks in the system.\n\nAnalyze two parameter sets:\n- Parameter set $\\mathcal{A}$: $q_0 = 5\\,\\mathrm{ms}$, $W = 9\\,\\mathrm{ms}$, $C = 11\\,\\mathrm{ms}$.\n- Parameter set $\\mathcal{B}$: $q_0 = 5\\,\\mathrm{ms}$, $W = 11\\,\\mathrm{ms}$, $C = 11\\,\\mathrm{ms}$.\n\nBased only on the fundamental scheduler definitions above, select all statements that are correct.\n\nA. Under parameter set $\\mathcal{A}$, the waiting time of $H$ to enter its critical section can be unbounded (i.e., there is no finite upper bound on wall-clock delay) because, after $L$ exhausts its donated budget while still holding the lock, $R$ in $Q_0$ can indefinitely preempt $L$ in $Q_2$.\n\nB. Under parameter set $\\mathcal{B}$, $H$ will enter its critical section within at most $11\\,\\mathrm{ms}$ of wall-clock time after $t = 0$.\n\nC. Under parameter set $\\mathcal{B}$, with exactly one always-ready competitor $R$ in $Q_0$, the wall-clock time until $L$ releases the lock is upper-bounded by $2C$.\n\nD. Even with a bounded window $W$ per lock hold, a malicious task in $Q_2$ can obtain an arbitrarily large fraction of CPU time over a long interval by repeatedly reacquiring the lock and inducing a sequence of $Q_0$ waiters, unless the scheduler also enforces a cap on the cumulative donated CPU per unit time.\n\nE. Setting $W = q_0$ always suffices to avoid unbounded priority inversion, regardless of the values of $C$ and the presence of always-ready tasks in $Q_0$.\n\nSelect all that apply.", "solution": "The problem statement will first be validated for scientific soundness, completeness, and objectivity.\n\n### Step 1: Extract Givens\nThe problem describes a computer system with a single Central Processing Unit (CPU) and a Multilevel Feedback Queue (MLFQ) scheduler. The explicit givens are:\n-   **Queues**: A system of $3$ queues is defined: $Q_0$ (highest priority), $Q_1$, and $Q_2$ (lowest priority).\n-   **Inter-Queue Scheduling**: Preemptive priority scheduling, where a ready task in a higher-priority queue preempts any task running in a lower-priority queue.\n-   **Intra-Queue Scheduling**: Round-Robin (RR) with a fixed time quantum per queue.\n-   **Time Quanta**: $q_0 = 5\\,\\mathrm{ms}$ for $Q_0$, $q_1 = 10\\,\\mathrm{ms}$ for $Q_1$, and $q_2 = 20\\,\\mathrm{ms}$ for $Q_2$.\n-   **System Model**: A single CPU is assumed, and context-switch overhead is to be considered $0$ for analysis.\n-   **Priority Donation Mechanism**:\n    -   A task $H$ in a higher-priority queue blocking on a mutex held by a task $L$ in a lower-priority queue causes $L$ to be temporarily promoted to the priority level of $H$ (i.e., to queue $Q_0$ in this scenario).\n    -   The promotion is bounded by a CPU-time budget of $W$. This budget, $W$, is decremented only when $L$ is actively running on the CPU.\n    -   The donation starts at the next scheduling decision after $H$ blocks, with $L$ being placed at the head of the ready queue for $Q_0$.\n    -   The donation ends if either $L$ releases the mutex or its donated budget $W$ is exhausted.\n    -   A single donation window is granted per continuous lock hold.\n-   **Initial Scenario ($t=0$)**:\n    -   Task $L$ is in $Q_2$, holding a mutex, with a remaining critical section requiring $C$ units of CPU time.\n    -   Task $H$ is in $Q_0$ and attempts to acquire the same mutex, causing it to block and trigger the donation to $L$.\n    -   Task $R$ is in $Q_0$ and is always ready to run (CPU-bound); it is unrelated to the mutex.\n    -   There are no other tasks in the system.\n-   **Parameter Sets**:\n    -   Set $\\mathcal{A}$: $q_0 = 5\\,\\mathrm{ms}$, $W = 9\\,\\mathrm{ms}$, $C = 11\\,\\mathrm{ms}$.\n    -   Set $\\mathcal{B}$: $q_0 = 5\\,\\mathrm{ms}$, $W = 11\\,\\mathrm{ms}$, $C = 11\\,\\mathrm{ms}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is evaluated against standard criteria for validity.\n-   **Scientific Grounding**: The concepts presented—MLFQ, preemptive priority scheduling, Round-Robin, priority inversion, and priority inheritance (here specified as a bounded \"priority donation\" via a futex mechanism)—are fundamental and standard topics in the study of operating systems. The model, though simplified (e.g., $0$ context-switch cost), is scientifically and logically consistent with the principles it describes.\n-   **Well-Posedness**: The problem is well-posed. The initial state of the system is clearly defined, the rules governing state transitions (scheduling, preemption, donation) are explicit, and the questions posed are specific and deterministic. A unique sequence of events can be derived from the premises.\n-   **Objectivity**: The language is technical, precise, and free from subjective or ambiguous terminology.\n-   **Review for Flaws**:\n    1.  **Scientific Unsoundness**: None. The model is a standard representation of a scheduling problem.\n    2.  **Irrelevance**: None. The topic is centrally focused on operating system scheduling.\n    3.  **Incompleteness/Contradiction**: None. The rules are sufficient to simulate the system's behavior. For instance, the tie-breaking rule within $Q_0$ (placing the donated task $L$ at the head) is explicitly stated.\n    4.  **Unrealistic Conditions**: The assumption of zero context-switch overhead is a common and acceptable simplification for theoretical analysis. The parameter values are reasonable for this type of problem.\n    5.  **Ill-Posed Structure**: None. The problem structure is logical and leads to a unique solution.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. A detailed analysis can proceed.\n\n### Derivations and Analysis\n\nThe core of the problem involves tracing the execution of tasks $L$ and $R$ in queue $Q_0$ under the Round-Robin policy, while tracking the remaining critical section time $C$ and the donated time budget $W$ for task $L$.\n\n**Analysis of Parameter Set $\\mathcal{A}$ ($q_0 = 5\\,\\mathrm{ms}$, $W = 9\\,\\mathrm{ms}$, $C = 11\\,\\mathrm{ms}$)**\n\nAt $t=0$, task $H$ (in $Q_0$) blocks on the mutex held by task $L$ (in $Q_2$). This triggers priority donation. $L$ is promoted to $Q_0$ and placed at the head of the ready queue. The $Q_0$ ready queue is $(L, R)$. The states are: $C_{rem} = 11\\,\\mathrm{ms}$, $W_{rem} = 9\\,\\mathrm{ms}$.\n\n1.  **$t = [0, 5)\\,\\mathrm{ms}$**: Task $L$ runs, as it is at the head of the $Q_0$ queue. It runs for its full quantum, $q_0 = 5\\,\\mathrm{ms}$.\n    -   $C_{rem}$ becomes $11 - 5 = 6\\,\\mathrm{ms}$.\n    -   $W_{rem}$ becomes $9 - 5 = 4\\,\\mathrm{ms}$.\n    -   At $t=5\\,\\mathrm{ms}$, $L$ is preempted and moved to the tail of the $Q_0$ queue. The queue is now $(R, L)$.\n\n2.  **$t = [5, 10)\\,\\mathrm{ms}$**: Task $R$ runs for its quantum, $q_0 = 5\\,\\mathrm{ms}$.\n    -   At $t=10\\,\\mathrm{ms}$, $R$ is preempted and moved to the tail. The queue is now $(L, R)$.\n\n3.  **$t = [10, 14)\\,\\mathrm{ms}$**: Task $L$ runs again. It requires $C_{rem} = 6\\,\\mathrm{ms}$ to finish its critical section, but its remaining donation budget is only $W_{rem} = 4\\,\\mathrm{ms}$. It is also limited by the quantum $q_0 = 5\\,\\mathrm{ms}$. It will run for $\\min(q_0, C_{rem}, W_{rem}) = \\min(5, 6, 4) = 4\\,\\mathrm{ms}$.\n    -   $L$ runs for $4\\,\\mathrm{ms}$.\n    -   $C_{rem}$ becomes $6 - 4 = 2\\,\\mathrm{ms}$.\n    -   $W_{rem}$ becomes $4 - 4 = 0\\,\\mathrm{ms}$.\n\n4.  **At $t=14\\,\\mathrm{ms}$**: Task $L$ exhausts its donated budget $W$. The donation ends. $L$ is immediately demoted to its original queue, $Q_2$. Crucially, $L$ has not finished its critical section ($C_{rem} = 2\\,\\mathrm{ms}$) and still holds the mutex.\n\n5.  **For $t \\geq 14\\,\\mathrm{ms}$**: The ready queues are $Q_0: (R)$, $Q_1: (\\text{empty})$, $Q_2: (L)$. Task $H$ remains blocked. Since task $R$ is in $Q_0$ and is defined as \"always ready,\" it will be continuously scheduled. The scheduler will never select a task from a lower-priority queue like $Q_2$. Consequently, $L$ is starved and can never run to complete its remaining $2\\,\\mathrm{ms}$ of critical section work. It will never release the mutex. This results in an unbounded waiting time for task $H$.\n\n**Analysis of Parameter Set $\\mathcal{B}$ ($q_0 = 5\\,\\mathrm{ms}$, $W = 11\\,\\mathrm{ms}$, $C = 11\\,\\mathrm{ms}$)**\n\nAt $t=0$, the setup is the same. The $Q_0$ ready queue is $(L, R)$. The states are: $C_{rem} = 11\\,\\mathrm{ms}$, $W_{rem} = 11\\,\\mathrm{ms}$. The key difference is that $W=C$.\n\n1.  **$t = [0, 5)\\,\\mathrm{ms}$**: Task $L$ runs for $q_0 = 5\\,\\mathrm{ms}$.\n    -   $C_{rem} = 11 - 5 = 6\\,\\mathrm{ms}$.\n    -   $W_{rem} = 11 - 5 = 6\\,\\mathrm{ms}$.\n    -   At $t=5\\,\\mathrm{ms}$, queue becomes $(R, L)$.\n\n2.  **$t = [5, 10)\\,\\mathrm{ms}$**: Task $R$ runs for $q_0 = 5\\,\\mathrm{ms}$.\n    -   At $t=10\\,\\mathrm{ms}$, queue becomes $(L, R)$.\n\n3.  **$t = [10, 15)\\,\\mathrm{ms}$**: Task $L$ runs for $q_0 = 5\\,\\mathrm{ms}$.\n    -   $C_{rem} = 6 - 5 = 1\\,\\mathrm{ms}$.\n    -   $W_{rem} = 6 - 5 = 1\\,\\mathrm{ms}$.\n    -   At $t=15\\,\\mathrm{ms}$, queue becomes $(R, L)$.\n\n4.  **$t = [15, 20)\\,\\mathrm{ms}$**: Task $R$ runs for $q_0 = 5\\,\\mathrm{ms}$.\n    -   At $t=20\\,\\mathrm{ms}$, queue becomes $(L, R)$.\n\n5.  **$t = [20, 21)\\,\\mathrm{ms}$**: Task $L$ runs. It needs only $C_{rem} = 1\\,\\mathrm{ms}$ to finish. It has $W_{rem} = 1\\,\\mathrm{ms}$ of budget remaining.\n    -   $L$ runs for $1\\,\\mathrm{ms}$.\n    -   $C_{rem} = 1 - 1 = 0\\,\\mathrm{ms}$.\n    -   $W_{rem}$ becomes $1 - 1 = 0\\,\\mathrm{ms}$.\n\n6.  **At $t=21\\,\\mathrm{ms}$**: Task $L$ completes its critical section and releases the mutex. Task $H$ unblocks, becomes ready in $Q_0$, and can now be scheduled. The waiting time for $H$ to enter its critical section is $21\\,\\mathrm{ms}$.\n\n### Option-by-Option Analysis\n\n**A. Under parameter set $\\mathcal{A}$, the waiting time of $H$ to enter its critical section can be unbounded (i.e., there is no finite upper bound on wall-clock delay) because, after $L$ exhausts its donated budget while still holding the lock, $R$ in $Q_0$ can indefinitely preempt $L$ in $Q_2$.**\nThis statement perfectly matches the outcome of the analysis for parameter set $\\mathcal{A}$. The donated budget $W=9\\,\\mathrm{ms}$ is insufficient for $L$ to complete its $C=11\\,\\mathrm{ms}$ critical section while competing with $R$. $L$ is demoted mid-critical-section and subsequently starved by the high-priority task $R$, leading to a deadlock-like situation where $H$ waits indefinitely. This is a classic example of ill-managed priority inversion.\n**Verdict: Correct.**\n\n**B. Under parameter set $\\mathcal{B}$, $H$ will enter its critical section within at most $11\\,\\mathrm{ms}$ of wall-clock time after $t = 0$.**\nThe detailed analysis for parameter set $\\mathcal{B}$ shows that task $L$ requires $21\\,\\mathrm{ms}$ of wall-clock time to complete its critical section, due to the interleaved execution with task $R$. Therefore, the waiting time for $H$ is $21\\,\\mathrm{ms}$. Since $21\\,\\mathrm{ms}$ is not at most $11\\,\\mathrm{ms}$, the statement is false.\n**Verdict: Incorrect.**\n\n**C. Under parameter set $\\mathcal{B}$, with exactly one always-ready competitor $R$ in $Q_0$, the wall-clock time until $L$ releases the lock is upper-bounded by $2C$.**\nThis statement generalizes the observation from set $\\mathcal{B}$. To complete its critical section of length $C$, task $L$ needs to run for a total of $C$ CPU time. With a quantum of $q_0$, this requires $N_L = \\lceil C/q_0 \\rceil$ separate runs in the $Q_0$ Round-Robin schedule. Between each of the first $N_L - 1$ runs of $L$, task $R$ will run for a full quantum $q_0$.\nThe total wall-clock time, $T_{wall}$, is the sum of the time $L$ runs ($C$) and the time $R$ runs.\n$T_{wall} = C + (N_L - 1)q_0 = C + (\\lceil C/q_0 \\rceil - 1)q_0$.\nTo verify the bound $T_{wall} \\leq 2C$, we must check if $C + (\\lceil C/q_0 \\rceil - 1)q_0 \\leq 2C$, which simplifies to $(\\lceil C/q_0 \\rceil - 1)q_0 \\leq C$.\nBy the definition of the ceiling function, we know $\\lceil x \\rceil  x + 1$. Let $x = C/q_0$.\nThen $(\\lceil C/q_0 \\rceil - 1)  (C/q_0 + 1 - 1) = C/q_0$.\nMultiplying by $q_0$ gives $(\\lceil C/q_0 \\rceil - 1)q_0  C$.\nThus, the strict inequality holds. If $C$ is an exact multiple of $q_0$, $C = k \\cdot q_0$, then $\\lceil C/q_0 \\rceil = k$ and the expression becomes $(k-1)q_0$, which is less than $C = k \\cdot q_0$ (for $k1$). The inequality $(\\lceil C/q_0 \\rceil - 1)q_0 \\leq C$ is always true. This implies $T_{wall} \\leq 2C$.\nFor parameter set $\\mathcal{B}$, $C=11\\,\\mathrm{ms}$ and $q_0=5\\,\\mathrm{ms}$. $T_{wall} = 11 + (\\lceil 11/5 \\rceil - 1) \\times 5 = 11 + (3 - 1) \\times 5 = 11 + 10 = 21\\,\\mathrm{ms}$. The bound $2C$ is $2 \\times 11 = 22\\,\\mathrm{ms}$. $21\\,\\mathrm{ms} \\leq 22\\,\\mathrm{ms}$, so the bound holds. The analysis is valid as long as unbounded inversion is prevented, which is true for set $\\mathcal{B}$ since $W \\geq C$.\n**Verdict: Correct.**\n\n**D. Even with a bounded window $W$ per lock hold, a malicious task in $Q_2$ can obtain an arbitrarily large fraction of CPU time over a long interval by repeatedly reacquiring the lock and inducing a sequence of $Q_0$ waiters, unless the scheduler also enforces a cap on the cumulative donated CPU per unit time.**\nThe described donation policy bounds the CPU time granted *per lock acquisition*. It does not impose any limit on the total donated time a task can receive over a longer period. A malicious task could repeatedly execute a cycle of: (1) acquire a lock, (2) have a high-priority task block on it, (3) receive and use the $W$ budget at high priority, (4) release the lock, and (5) repeat. If this cycle can be performed rapidly, the malicious task can effectively run at high priority for a significant fraction of the time, bypassing the MLFQ's intent. The statement correctly identifies this vulnerability and the need for a further mechanism, such as a rate limit on donations, to prevent such abuse.\n**Verdict: Correct.**\n\n**E. Setting $W = q_0$ always suffices to avoid unbounded priority inversion, regardless of the values of $C$ and the presence of always-ready tasks in $Q_0$.**\nThis statement makes a strong general claim. To disprove it, a single counterexample is sufficient. Let us use the scenario from the problem with an always-ready competitor $R$ in $Q_0$.\nSet $W = q_0 = 5\\,\\mathrm{ms}$. Let the critical section be longer than the quantum, for example, $C = 6\\,\\mathrm{ms}$.\n-   $t=0$: $L$ is promoted to $Q_0$. $W_{rem}=5, C_{rem}=6$.\n-   $t = [0, 5)\\,\\mathrm{ms}$: $L$ runs for $5\\,\\mathrm{ms}$. It exhausts its entire budget $W$.\n-   At $t=5\\,\\mathrm{ms}$: $W_{rem}=0$, donation ends. $L$ is demoted to $Q_2$. However, its critical section is not finished, as $C_{rem}=1\\,\\mathrm{ms}$.\n-   For $t \\geq 5\\,\\mathrm{ms}$: $L$ is in $Q_2$ while holding the lock, and the always-ready task $R$ is in $Q_0$. $R$ will continuously preempt $L$, causing unbounded priority inversion.\nTherefore, setting $W=q_0$ is insufficient if $C  W$. The statement's claim to work \"regardless of the values of $C$\" is false.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{ACD}$$", "id": "3660203"}]}