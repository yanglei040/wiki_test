{"hands_on_practices": [{"introduction": "To understand the impact of scheduling decisions, it's essential to compare different policies using concrete performance metrics. This exercise guides you through a manual simulation of two foundational algorithms, First-Come First-Served (FCFS) and non-preemptive Shortest Job First (SJF), for a given workload. By calculating the mean slowdown for each, you will gain a quantitative appreciation for how a scheduler's logic directly influences system efficiency and job fairness [@problem_id:3630106].", "problem": "A uniprocessor Central Processing Unit (CPU) executes a mixed workload of six independent jobs with arbitrary arrivals. Dispatch and context-switch overheads are negligible (assume zero). The ready queue is managed either by First-Come First-Served (FCFS) or by non-preemptive Shortest Job First (SJF). For FCFS, ties among jobs that arrive at the same time are broken by increasing job index. For SJF, when the CPU becomes idle, the scheduler selects the available job with the smallest service time; ties are broken first by earliest arrival time and then by increasing job index. If the ready queue is empty, the CPU remains idle until the next arrival. All times are measured in milliseconds. For each job $J_i$, let arrival time be $a_i$, service time (CPU burst) be $s_i$, start time be $b_i$, finish time be $f_i$, completion time (turnaround time) be $c_i = f_i - a_i$, and slowdown be $S_i = \\frac{c_i}{s_i}$.\n\nThe workload is:\n- Job $J_1$: $a_1 = 0$, $s_1 = 8$.\n- Job $J_2$: $a_2 = 0$, $s_2 = 3$.\n- Job $J_3$: $a_3 = 0$, $s_3 = 1$.\n- Job $J_4$: $a_4 = 2$, $s_4 = 9$.\n- Job $J_5$: $a_5 = 3$, $s_5 = 2$.\n- Job $J_6$: $a_6 = 6$, $s_6 = 5$.\n\nUsing only the definitions above and the scheduling rules, determine the arithmetic mean slowdown under FCFS, denoted $\\overline{S}_{\\mathrm{FCFS}}$, and the arithmetic mean slowdown under SJF, denoted $\\overline{S}_{\\mathrm{SJF}}$. Then compute the ratio\n$$R \\equiv \\frac{\\overline{S}_{\\mathrm{FCFS}}}{\\overline{S}_{\\mathrm{SJF}}}.$$\nReport only $R$ as a pure number, rounded to four significant figures.", "solution": "The problem statement is scrutinized and found to be valid. It is a well-posed problem from the field of operating systems, specifically CPU scheduling. It provides a complete set of data for six jobs, defines two scheduling algorithms (First-Come First-Served and non-preemptive Shortest Job First) with explicit tie-breaking rules, and specifies all necessary performance metrics. There are no scientific inconsistencies, contradictions, or ambiguities. We may therefore proceed with the solution.\n\nThe problem requires the calculation of the arithmetic mean slowdown for two different scheduling policies and their ratio. The definitions given are:\n- Arrival time: $a_i$\n- Service time: $s_i$\n- Finish time: $f_i$\n- Completion (turnaround) time: $c_i = f_i - a_i$\n- Slowdown: $S_i = \\frac{c_i}{s_i}$\n- Mean slowdown: $\\overline{S} = \\frac{1}{N} \\sum_{i=1}^{N} S_i$, where $N=6$.\n\nThe workload consists of $6$ jobs, $J_1$ through $J_6$:\n- $J_1: a_1=0, s_1=8$\n- $J_2: a_2=0, s_2=3$\n- $J_3: a_3=0, s_3=1$\n- $J_4: a_4=2, s_4=9$\n- $J_5: a_5=3, s_5=2$\n- $J_6: a_6=6, s_6=5$\n\n**Part 1: Analysis under First-Come First-Served (FCFS) Scheduling**\n\nUnder FCFS, jobs are processed in the order of their arrival. For jobs arriving simultaneously, the tie is broken by increasing job index.\n- At time $t=0$, jobs $J_1$, $J_2$, and $J_3$ arrive. The ready queue, ordered by job index, is ($J_1, J_2, J_3$).\n- The CPU starts processing $J_1$ at $t=0$. It runs for $s_1 = 8$ units.\n- Finish time for $J_1$ is $f_1 = 0 + 8 = 8$.\n- At $t=8$, the CPU becomes free. The ready queue contains all other jobs, as they have all arrived by this time. The FCFS order (based on original arrival times and job indices) is ($J_2, J_3, J_4, J_5, J_6$).\n- The CPU starts processing $J_2$ at $t=8$. It runs for $s_2 = 3$ units.\n- Finish time for $J_2$ is $f_2 = 8 + 3 = 11$.\n- The CPU starts processing $J_3$ at $t=11$. It runs for $s_3 = 1$ unit.\n- Finish time for $J_3$ is $f_3 = 11 + 1 = 12$.\n- The CPU starts processing $J_4$ at $t=12$. It runs for $s_4 = 9$ units.\n- Finish time for $J_4$ is $f_4 = 12 + 9 = 21$.\n- The CPU starts processing $J_5$ at $t=21$. It runs for $s_5 = 2$ units.\n- Finish time for $J_5$ is $f_5 = 21 + 2 = 23$.\n- The CPU starts processing $J_6$ at $t=23$. It runs for $s_6 = 5$ units.\n- Finish time for $J_6$ is $f_6 = 23 + 5 = 28$.\n\nNow, we calculate the completion time $c_i$ and slowdown $S_i$ for each job.\n- $J_1$: $c_1 = f_1 - a_1 = 8 - 0 = 8$. $S_1 = c_1/s_1 = 8/8 = 1$.\n- $J_2$: $c_2 = f_2 - a_2 = 11 - 0 = 11$. $S_2 = c_2/s_2 = 11/3$.\n- $J_3$: $c_3 = f_3 - a_3 = 12 - 0 = 12$. $S_3 = c_3/s_3 = 12/1 = 12$.\n- $J_4$: $c_4 = f_4 - a_4 = 21 - 2 = 19$. $S_4 = c_4/s_4 = 19/9$.\n- $J_5$: $c_5 = f_5 - a_5 = 23 - 3 = 20$. $S_5 = c_5/s_5 = 20/2 = 10$.\n- $J_6$: $c_6 = f_6 - a_6 = 28 - 6 = 22$. $S_6 = c_6/s_6 = 22/5$.\n\nThe arithmetic mean slowdown for FCFS is:\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\sum_{i=1}^{6} S_i = \\frac{1}{6} \\left(1 + \\frac{11}{3} + 12 + \\frac{19}{9} + 10 + \\frac{22}{5}\\right) $$\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\left(23 + \\frac{11}{3} + \\frac{19}{9} + \\frac{22}{5}\\right) $$\nTo sum the fractions, we find a common denominator of $45$:\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\left(\\frac{23 \\cdot 45}{45} + \\frac{11 \\cdot 15}{45} + \\frac{19 \\cdot 5}{45} + \\frac{22 \\cdot 9}{45}\\right) $$\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\left(\\frac{1035 + 165 + 95 + 198}{45}\\right) = \\frac{1}{6} \\left(\\frac{1493}{45}\\right) = \\frac{1493}{270} $$\n\n**Part 2: Analysis under Non-preemptive Shortest Job First (SJF) Scheduling**\n\nUnder non-preemptive SJF, when the CPU becomes idle, it selects the available job with the smallest service time. Ties are broken first by earliest arrival time, and then by increasing job index.\n\n- At $t=0$, the CPU is idle. The ready queue contains $J_1(s_1=8, a_1=0)$, $J_2(s_2=3, a_2=0)$, and $J_3(s_3=1, a_3=0)$. Based on the shortest service time, $J_3$ is selected.\n- $J_3$ starts at $t=0$ and runs for $s_3=1$. Finish time $f_3 = 1$.\n- At $t=1$, the CPU is idle. The ready queue contains $J_1(s_1=8, a_1=0)$ and $J_2(s_2=3, a_2=0)$. Shortest is $J_2$.\n- $J_2$ starts at $t=1$ and runs for $s_2=3$. Finish time $f_2 = 1+3=4$. During its execution, $J_4(a_4=2, s_4=9)$ and $J_5(a_5=3, s_5=2)$ arrive.\n- At $t=4$, the CPU is idle. The ready queue contains $J_1(s_1=8, a_1=0)$, $J_4(s_4=9, a_4=2)$, and $J_5(s_5=2, a_5=3)$. Shortest is $J_5$.\n- $J_5$ starts at $t=4$ and runs for $s_5=2$. Finish time $f_5 = 4+2=6$. During its execution, $J_6(a_6=6, s_6=5)$ arrives at the moment of completion.\n- At $t=6$, the CPU is idle. The ready queue contains $J_1(s_1=8, a_1=0)$, $J_4(s_4=9, a_4=2)$, and $J_6(s_6=5, a_6=6)$. Shortest is $J_6$.\n- $J_6$ starts at $t=6$ and runs for $s_6=5$. Finish time $f_6 = 6+5=11$.\n- At $t=11$, the CPU is idle. The ready queue contains $J_1(s_1=8, a_1=0)$ and $J_4(s_4=9, a_4=2)$. Shortest is $J_1$.\n- $J_1$ starts at $t=11$ and runs for $s_1=8$. Finish time $f_1 = 11+8=19$.\n- At $t=19$, the CPU is idle. The only job left is $J_4$.\n- $J_4$ starts at $t=19$ and runs for $s_4=9$. Finish time $f_4 = 19+9=28$.\n\nNow, we calculate the completion time $c_i$ and slowdown $S_i$ for each job under SJF.\n- $J_1$: $c_1 = f_1 - a_1 = 19 - 0 = 19$. $S_1 = c_1/s_1 = 19/8$.\n- $J_2$: $c_2 = f_2 - a_2 = 4 - 0 = 4$. $S_2 = c_2/s_2 = 4/3$.\n- $J_3$: $c_3 = f_3 - a_3 = 1 - 0 = 1$. $S_3 = c_3/s_3 = 1/1 = 1$.\n- $J_4$: $c_4 = f_4 - a_4 = 28 - 2 = 26$. $S_4 = c_4/s_4 = 26/9$.\n- $J_5$: $c_5 = f_5 - a_5 = 6 - 3 = 3$. $S_5 = c_5/s_5 = 3/2$.\n- $J_6$: $c_6 = f_6 - a_6 = 11 - 6 = 5$. $S_6 = c_6/s_6 = 5/5 = 1$.\n\nThe arithmetic mean slowdown for SJF is:\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\sum_{i=1}^{6} S_i = \\frac{1}{6} \\left(\\frac{19}{8} + \\frac{4}{3} + 1 + \\frac{26}{9} + \\frac{3}{2} + 1\\right) $$\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\left(2 + \\frac{19}{8} + \\frac{4}{3} + \\frac{26}{9} + \\frac{3}{2}\\right) $$\nTo sum the fractions, we find a common denominator of $72$:\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\left(\\frac{2 \\cdot 72}{72} + \\frac{19 \\cdot 9}{72} + \\frac{4 \\cdot 24}{72} + \\frac{26 \\cdot 8}{72} + \\frac{3 \\cdot 36}{72}\\right) $$\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\left(\\frac{144 + 171 + 96 + 208 + 108}{72}\\right) = \\frac{1}{6} \\left(\\frac{727}{72}\\right) = \\frac{727}{432} $$\n\n**Part 3: Calculation of the Ratio R**\n\nThe final step is to compute the ratio $R \\equiv \\frac{\\overline{S}_{\\mathrm{FCFS}}}{\\overline{S}_{\\mathrm{SJF}}}$.\n$$ R = \\frac{1493/270}{727/432} = \\frac{1493}{270} \\times \\frac{432}{727} $$\nWe can simplify the fraction $\\frac{432}{270}$:\n$$ \\frac{432}{270} = \\frac{432 \\div 54}{270 \\div 54} = \\frac{8}{5} $$\nSo the ratio becomes:\n$$ R = \\frac{1493}{727} \\times \\frac{8}{5} = \\frac{11944}{3635} $$\nNow, we compute the numerical value and round to four significant figures:\n$$ R \\approx 3.285832187... $$\nRounding to four significant figures yields $3.286$.", "answer": "$$\\boxed{3.286}$$", "id": "3630106"}, {"introduction": "While preemptive algorithms like Round Robin (RR) can improve responsiveness, they introduce overhead from context switching. This practice moves beyond simple simulation to an analytical model that quantifies this cost. By deriving the throughput degradation as a function of the time quantum $q$ and context-switch cost $d$, you will explore the fundamental trade-off between responsiveness and CPU efficiency [@problem_id:3630101].", "problem": "Consider a single-core Central Processing Unit (CPU) executing a large stream of identical, purely CPU-bound jobs under Round Robin (RR) scheduling. Each job requires a total of $C$ units of CPU service to complete, with $C \\gg q$, where $q$ is the RR time slice (quantum). The dispatcher incurs an average context switch overhead of $d$ units of CPU time at each preemption and dispatch, during which no useful job computation occurs. Assume there are always at least $2$ ready jobs so that a context switch occurs at every quantum expiration, the CPU is never idle, and boundary effects at job start and completion are negligible in the long-run average.\n\nLet $X(q,d)$ denote the long-run throughput, defined as the limit of completed jobs per unit time, and let $X_{\\text{ideal}}$ denote the ideal throughput on the same CPU if there were no context-switching overhead and no preemption overhead. Define the multiplicative throughput degradation factor as $D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$.\n\nStarting only from the definitions of throughput and time accounting for useful work versus overhead under RR scheduling and dispatching, derive $D(q,d)$ and then evaluate it when $q=d$. Provide your final answer as a single exact value for $D(q,d)$ when $q=d$. No rounding is required, and no units should be included in the final answer. Express the final value as a simplified exact fraction.", "solution": "The problem statement is first validated for scientific soundness, self-consistency, and clarity.\n\n**Step 1: Extract Givens**\n- Scheduling algorithm: Round Robin (RR).\n- CPU: Single-core.\n- Job characteristics: Identical, purely CPU-bound.\n- Total CPU service time required per job: $C$.\n- Time slice (quantum): $q$.\n- Condition on service time and quantum: $C \\gg q$.\n- Context switch overhead per preemption: $d$.\n- System state: Always at least $2$ ready jobs, ensuring the CPU is never idle and a context switch occurs at the end of every time slice.\n- Simplifying assumption: Boundary effects at job start and completion are negligible in the long-run average.\n- Definition of long-run throughput: $X(q,d)$ is the limit of completed jobs per unit time.\n- Definition of ideal throughput: $X_{\\text{ideal}}$ is the throughput on the same CPU if $d=0$ (no context-switching overhead).\n- Definition of throughput degradation factor: $D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$.\n- Task: Derive $D(q,d)$ and evaluate it for the case $q=d$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, rooted in the fundamental principles of operating system CPU scheduling. It presents a standard, simplified model used to analyze the performance of the Round Robin algorithm. The terms used ($C$, $q$, $d$, throughput) are well-defined within computer science. The assumptions provided (e.g., $C \\gg q$, always ready jobs) are necessary to create a tractable analytical model for steady-state behavior, removing complexities of transient states and idle time. The problem is well-posed, objective, and self-contained, with no internal contradictions or missing information. It is a valid problem for analysis.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n**Derivation of the Solution**\n\nThe objective is to find the throughput degradation factor $D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$. We begin by deriving expressions for the ideal throughput $X_{\\text{ideal}}$ and the actual throughput $X(q,d)$. Throughput is defined as the number of jobs completed per unit of time.\n\n**1. Ideal Throughput ($X_{\\text{ideal}}$)**\n\nIn the ideal case, there is no overhead from context switching, so $d=0$. The CPU spends $100\\%$ of its time performing useful computations for the jobs. Each job requires a total of $C$ units of CPU service time. Therefore, the time taken to complete one job is simply $C$.\n\nThe ideal throughput, $X_{\\text{ideal}}$, is the reciprocal of the time required to complete one job:\n$$X_{\\text{ideal}} = \\frac{1 \\text{ job}}{C \\text{ time units}} = \\frac{1}{C}$$\n\n**2. Actual Throughput ($X(q,d)$)**\n\nUnder Round Robin scheduling with context-switch overhead, the CPU's time is divided between useful work and overhead. The problem states that a context switch occurs after every time slice.\n\nA single cycle of operation consists of:\n- One time slice of useful computation, of duration $q$.\n- One context switch, of duration $d$.\n\nThe total duration of one such cycle is $T_{\\text{cycle}} = q + d$.\n\nDuring this cycle of total time $q+d$, only a duration of $q$ is spent performing useful work. The fraction of total time that the CPU spends on useful computation is its efficiency, $\\eta$:\n$$\\eta = \\frac{\\text{Useful time}}{\\text{Total time}} = \\frac{q}{q+d}$$\n\nTo complete a single job, a total of $C$ units of useful CPU service must be provided. Since the CPU is only effectively available for useful work for a fraction $\\eta$ of the time, the total (wall-clock) time required to provide $C$ units of service is:\n$$T_{\\text{job}} = \\frac{C}{\\eta} = \\frac{C}{\\frac{q}{q+d}} = C \\frac{q+d}{q}$$\n\nThe actual long-run throughput, $X(q,d)$, is the reciprocal of this total time per job:\n$$X(q,d) = \\frac{1}{T_{\\text{job}}} = \\frac{1}{C \\frac{q+d}{q}} = \\frac{q}{C(q+d)}$$\n\n**3. Throughput Degradation Factor ($D(q,d)$)**\n\nNow we can compute the degradation factor using its definition:\n$$D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$$\nSubstituting the expressions for $X(q,d)$ and $X_{\\text{ideal}}$:\n$$D(q,d) = \\frac{\\frac{q}{C(q+d)}}{\\frac{1}{C}}$$\n$$D(q,d) = \\frac{q}{C(q+d)} \\cdot \\frac{C}{1} = \\frac{q}{q+d}$$\nThis result is intuitive: the throughput is degraded by a factor equal to the fraction of time the CPU is doing useful work.\n\n**4. Evaluation for $q=d$**\n\nThe problem asks for the value of $D(q,d)$ when the quantum $q$ is equal to the context-switch overhead $d$. We substitute $d=q$ into our expression for $D(q,d)$:\n$$D(q,q) = \\frac{q}{q+q} = \\frac{q}{2q}$$\nSince $q$ is a time quantum, it must be a positive duration ($q > 0$). We can therefore cancel $q$ from the numerator and denominator:\n$$D(q,q) = \\frac{1}{2}$$\n\nThus, when the context switch overhead is equal to the time slice duration, the CPU spends half its time on useful work and half on overhead, resulting in a throughput that is exactly half of the ideal throughput.", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "3630101"}, {"introduction": "Schedulers can also use probability to allocate CPU time, offering a flexible way to manage diverse workloads. Lottery scheduling is a prime example where processes are given \"tickets\" to contend for the CPU, ensuring proportional-share allocation over time. This problem asks you to apply principles of probability to derive the expected CPU share and its variance, providing insight into the fairness and predictability of this randomized approach [@problem_id:3630144].", "problem": "An Operating System (OS) uses lottery scheduling to allocate the Central Processing Unit (CPU) among $4$ ready processes $P_{1}$, $P_{2}$, $P_{3}$, and $P_{4}$. Each scheduling decision awards a fixed-length time quantum to exactly one process by drawing uniformly at random from a pool of tickets; process $P_{i}$ owns $t_{i}$ tickets. Draws are independent across time quanta. Over a measurement horizon of $N$ consecutive time quanta, define the random variable $X_{i}$ to be the fraction of these $N$ quanta awarded to process $P_{i}$.\n\nStarting from the fundamental definition that each time quantum selects one ticket uniformly at random from the total pool, and from the standard properties of independent Bernoulli trials, derive expressions for the expected value $\\mathbb{E}[X_{i}]$ and the variance $\\mathrm{Var}(X_{i})$ in terms of $t_{i}$, the total number of tickets $T$, and the horizon length $N$. Then evaluate these expressions for the concrete configuration\n$$t_{1} = 12,\\quad t_{2} = 20,\\quad t_{3} = 8,\\quad t_{4} = 10,\\quad N = 1200.$$\nReturn your final numerical answer as a single row matrix in the order\n$$(\\mathbb{E}[X_{1}],\\,\\mathbb{E}[X_{2}],\\,\\mathbb{E}[X_{3}],\\,\\mathbb{E}[X_{4}],\\,\\mathrm{Var}(X_{1}),\\,\\mathrm{Var}(X_{2}),\\,\\mathrm{Var}(X_{3}),\\,\\mathrm{Var}(X_{4})).$$\nRound each entry to four significant figures. Express the shares and variances as unitless decimals.", "solution": "The problem statement is first validated for scientific soundness, self-consistency, and completeness.\n\n**Step 1: Extract Givens**\n- An Operating System uses lottery scheduling.\n- There are $4$ ready processes: $P_{1}, P_{2}, P_{3}, P_{4}$.\n- Process $P_{i}$ owns $t_{i}$ tickets.\n- The total number of tickets is $T = \\sum_{i} t_{i}$.\n- A scheduling decision selects one process for a fixed-length time quantum by drawing a ticket uniformly at random from the pool of $T$ tickets.\n- Draws are independent across time quanta.\n- The measurement horizon is $N$ consecutive time quanta.\n- $X_{i}$ is the random variable for the fraction of the $N$ quanta awarded to process $P_{i}$.\n- The specific configuration is given by: $t_{1} = 12$, $t_{2} = 20$, $t_{3} = 8$, $t_{4} = 10$, and $N = 1200$.\n- The task is to derive expressions for the expected value $\\mathbb{E}[X_{i}]$ and variance $\\mathrm{Var}(X_{i})$, and then evaluate them for the given configuration, rounding the final numerical results to four significant figures.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem describes lottery scheduling, a well-established algorithm in operating systems. The modeling of this algorithm using probability theory, specifically with independent Bernoulli trials, is standard and correct. The problem is firmly rooted in computer science and probability theory.\n- **Well-Posed**: The problem is clearly specified. The mechanism of random selection is defined (uniform and independent draws). The variables to be calculated ($\\mathbb{E}[X_{i}]$ and $\\mathrm{Var}(X_{i})$) are standard statistical measures. All necessary parameters ($t_i$, $N$) are provided to find a unique, stable solution.\n- **Objective**: The problem is stated in precise, objective language, free of ambiguity or subjective claims.\n\n**Step 3: Verdict and Action**\nThe problem is valid as it is scientifically sound, well-posed, and objective. There are no identifiable flaws. We proceed to the solution.\n\n**Derivation of $\\mathbb{E}[X_{i}]$ and $\\mathrm{Var}(X_{i})$**\n\nFirst, we calculate the total number of tickets, $T$.\n$$T = \\sum_{i=1}^{4} t_{i}$$\nThe selection of a process for a single time quantum is a random trial. Since the draw is uniform from the pool of all tickets, the probability $p_{i}$ that process $P_i$ is selected in any given trial is the ratio of its tickets to the total number of tickets:\n$$p_{i} = P(\\text{process } P_{i} \\text{ is selected}}) = \\frac{t_{i}}{T}$$\nThe process of scheduling over $N$ quanta consists of $N$ independent trials. Let us define an indicator random variable $Y_{i,k}$ for the $k$-th time quantum, where $k \\in \\{1, 2, \\dots, N\\}$:\n$$Y_{i,k} = \\begin{cases} 1 & \\text{if process } P_{i} \\text{ is selected at quantum } k \\\\ 0 & \\text{otherwise} \\end{cases}$$\nEach $Y_{i,k}$ is a Bernoulli random variable with parameter $p_{i}$. The expected value and variance of a single Bernoulli trial are:\n$$\\mathbb{E}[Y_{i,k}] = p_{i}$$\n$$\\mathrm{Var}(Y_{i,k}) = p_{i}(1 - p_{i})$$\nLet $C_{i}$ be the total number of quanta awarded to process $P_i$ over the horizon of $N$ quanta. $C_{i}$ is the sum of the outcomes of the $N$ independent trials:\n$$C_{i} = \\sum_{k=1}^{N} Y_{i,k}$$\nThus, $C_{i}$ follows a binomial distribution, $C_{i} \\sim \\mathrm{Binomial}(N, p_{i})$.\nThe expected value of $C_{i}$ is given by the linearity of expectation:\n$$\\mathbb{E}[C_{i}] = \\mathbb{E}\\left[\\sum_{k=1}^{N} Y_{i,k}\\right] = \\sum_{k=1}^{N} \\mathbb{E}[Y_{i,k}] = \\sum_{k=1}^{N} p_{i} = N p_{i}$$\nSince the trials are independent, the variance of the sum is the sum of the variances:\n$$\\mathrm{Var}(C_{i}) = \\mathrm{Var}\\left(\\sum_{k=1}^{N} Y_{i,k}\\right) = \\sum_{k=1}^{N} \\mathrm{Var}(Y_{i,k}) = \\sum_{k=1}^{N} p_{i}(1 - p_{i}) = N p_{i}(1 - p_{i})$$\nThe problem defines $X_{i}$ as the fraction of quanta awarded to $P_{i}$, so $X_{i} = \\frac{C_{i}}{N}$. We can now find its expectation and variance.\n\nFor the expected value $\\mathbb{E}[X_{i}]$:\n$$\\mathbb{E}[X_{i}] = \\mathbb{E}\\left[\\frac{C_{i}}{N}\\right] = \\frac{1}{N} \\mathbb{E}[C_{i}] = \\frac{1}{N}(N p_{i}) = p_{i}$$\nSubstituting the expression for $p_{i}$:\n$$\\mathbb{E}[X_{i}] = \\frac{t_{i}}{T}$$\nFor the variance $\\mathrm{Var}(X_{i})$:\nUsing the property $\\mathrm{Var}(aZ) = a^{2}\\mathrm{Var}(Z)$ with $a = \\frac{1}{N}$ and $Z = C_{i}$:\n$$\\mathrm{Var}(X_{i}) = \\mathrm{Var}\\left(\\frac{C_{i}}{N}\\right) = \\frac{1}{N^{2}}\\mathrm{Var}(C_{i}) = \\frac{1}{N^{2}}(N p_{i}(1 - p_{i})) = \\frac{p_{i}(1 - p_{i})}{N}$$\nSubstituting the expression for $p_{i}$:\n$$\\mathrm{Var}(X_{i}) = \\frac{\\frac{t_{i}}{T}\\left(1 - \\frac{t_{i}}{T}\\right)}{N} = \\frac{t_{i}(T - t_{i})}{N T^{2}}$$\n\n**Numerical Evaluation**\nWe are given the concrete configuration:\n$t_{1} = 12$, $t_{2} = 20$, $t_{3} = 8$, $t_{4} = 10$, and $N = 1200$.\n\nFirst, we compute the total number of tickets $T$:\n$$T = t_{1} + t_{2} + t_{3} + t_{4} = 12 + 20 + 8 + 10 = 50$$\nNext, we compute the probabilities $p_{i} = t_{i}/T$ for each process:\n$$p_{1} = \\frac{12}{50} = 0.24$$\n$$p_{2} = \\frac{20}{50} = 0.40$$\n$$p_{3} = \\frac{8}{50} = 0.16$$\n$$p_{4} = \\frac{10}{50} = 0.20$$\n\nNow we can compute the expected values $\\mathbb{E}[X_{i}] = p_{i}$:\n$$\\mathbb{E}[X_{1}] = 0.24$$\n$$\\mathbb{E}[X_{2}] = 0.40$$\n$$\\mathbb{E}[X_{3}] = 0.16$$\n$$\\mathbb{E}[X_{4}] = 0.20$$\nRounding to four significant figures, these are $0.2400$, $0.4000$, $0.1600$, and $0.2000$.\n\nNext, we compute the variances $\\mathrm{Var}(X_{i}) = \\frac{p_{i}(1 - p_{i})}{N}$ with $N = 1200$:\n$$\\mathrm{Var}(X_{1}) = \\frac{0.24(1 - 0.24)}{1200} = \\frac{0.24 \\times 0.76}{1200} = \\frac{0.1824}{1200} = 0.000152$$\n$$\\mathrm{Var}(X_{2}) = \\frac{0.40(1 - 0.40)}{1200} = \\frac{0.40 \\times 0.60}{1200} = \\frac{0.24}{1200} = 0.0002$$\n$$\\mathrm{Var}(X_{3}) = \\frac{0.16(1 - 0.16)}{1200} = \\frac{0.16 \\times 0.84}{1200} = \\frac{0.1344}{1200} = 0.000112$$\n$$\\mathrm{Var}(X_{4}) = \\frac{0.20(1 - 0.20)}{1200} = \\frac{0.20 \\times 0.80}{1200} = \\frac{0.16}{1200} \\approx 0.00013333\\dots$$\nRounding these values to four significant figures:\n$$\\mathrm{Var}(X_{1}) \\approx 0.0001520$$\n$$\\mathrm{Var}(X_{2}) \\approx 0.0002000$$\n$$\\mathrm{Var}(X_{3}) \\approx 0.0001120$$\n$$\\mathrm{Var}(X_{4}) \\approx 0.0001333$$\n\nThe final numerical answer is presented as a single row matrix in the specified order.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.2400 & 0.4000 & 0.1600 & 0.2000 & 0.0001520 & 0.0002000 & 0.0001120 & 0.0001333\n\\end{pmatrix}\n}\n$$", "id": "3630144"}]}