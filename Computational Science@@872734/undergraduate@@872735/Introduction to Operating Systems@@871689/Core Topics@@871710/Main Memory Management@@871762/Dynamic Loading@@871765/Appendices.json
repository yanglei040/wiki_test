{"hands_on_practices": [{"introduction": "Before your program's `main` function is ever called, the dynamic loader performs a series of crucial steps to prepare your application for execution. This first practice invites you to model this process from first principles, focusing on how the contents of an executable file, such as its symbol tables, influence the loader's behavior. By simulating the effects of different binary configurations—such as the presence of symbol tables or the choice between immediate and lazy binding—you will gain a concrete understanding of the trade-offs between load time, file size, and debuggability [@problem_id:3637126].", "problem": "You are to model, from first principles, how removing the non-dynamic symbol table of an Executable and Linkable Format (ELF)-like binary affects dynamic loader behavior and debugging capability, and implement the model as a complete, runnable program. The fundamental base you should start from is: (i) the dynamic loader resolves external references using the dynamic symbol table, (ii) the general notion of relocation processing with either lazy binding or immediate binding, and (iii) that sections not mapped into loadable segments are not read by the loader when bringing a program into memory.\n\nBegin from the following core definitions and facts. A binary contains a general symbol table (commonly named .symtab) and a dynamic symbol table (commonly named .dynsym). The dynamic loader resolves external references using only the dynamic symbol table. The general symbol table is used by static linkers and debuggers, not by the dynamic loader. For relocation processing, if lazy binding is enabled, function-call relocations are deferred until first call via the Procedure Linkage Table and Global Offset Table, whereas immediate binding resolves all relocations at load time. Only segments marked for loading are read into memory by the loader; non-loadable sections such as the general symbol table are not part of the loader’s disk input. Debugging capability is affected by the presence of symbol names and unwind metadata: without the general symbol table, only exported dynamic symbols are typically name-visible; without unwind information, reliable stack backtraces are limited.\n\nYour program must accept no input and must compute results for a fixed test suite described below by implementing the following concepts purely from these fundamentals:\n\n- Presence flags: Let $S \\in \\{0,1\\}$ indicate whether the general symbol table is present, $D \\in \\{0,1\\}$ indicate whether the dynamic symbol table is present, $L \\in \\{0,1\\}$ indicate lazy binding ($L=1$) or immediate binding ($L=0$), and $U \\in \\{0,1\\}$ indicate whether unwind information is present.\n- Work to be done by the loader: Let $T \\in \\mathbb{Z}_{\\ge 0}$ be the total count of relocations requiring symbol resolution, and let $F \\in \\mathbb{Z}_{\\ge 0}$ be the subset of those relocations corresponding to function-call relocations that would be deferred under lazy binding. Assume $F \\le T$ in valid configurations.\n- I/O at load: Let $B \\in \\mathbb{Z}_{\\ge 0}$ be the total bytes in loadable segments read by the loader from disk on program start, measured in bytes. Let $Y \\in \\mathbb{Z}_{\\ge 0}$ be the size in bytes of the general symbol table.\n- Loader success criterion: Consider that if there are relocations to resolve ($T>0$) but the dynamic symbol table is absent ($D=0$), dynamic loading cannot proceed successfully.\n\nFrom these, implement a model that, for each test case, computes the following outputs:\n\n1) $\\text{load\\_success} \\in \\{0,1\\}$ indicating whether the loader succeeds at program start.\n2) $\\text{relocations\\_at\\_load} \\in \\mathbb{Z}_{\\ge 0}$, the number of relocations the loader resolves at load time as a function of $T$, $F$, and $L$ in successful cases.\n3) $\\text{io\\_bytes} \\in \\mathbb{Z}_{\\ge 0}$, the bytes read from disk at load time, equal to the loadable segment size in bytes.\n4) $\\text{debug\\_score} \\in \\{0,1,2,3\\}$, a composite score where symbol name coverage and unwind capability contribute additively: name coverage contributes $2$ if $S=1$, $1$ if $S=0$ and $D=1$, and $0$ if $S=0$ and $D=0$; unwind capability contributes $1$ if $U=1$ and $0$ if $U=0$; the score is the sum of these two parts.\n5) $\\text{loader\\_uses\\_dynsym} \\in \\{0,1\\}$ indicating whether the loader uses the dynamic symbol table during program start, which occurs if and only if dynamic loading proceeds and there is at least one relocation to resolve at load time or later.\n6) $\\text{error\\_code} \\in \\{0,1,2\\}$ with the following interpretation: $0$ indicates no error; $1$ indicates that $T>0$ and $D=0$ so dynamic resolution is impossible; $2$ indicates invalid inputs such as $F>T$, any negative quantity among $T$, $F$, $B$, $Y$, or any flag not in $\\{0,1\\}$.\n\nBoundary behavior requirements:\n\n- If $\\text{error\\_code} = 2$, report $\\text{load\\_success} = 0$, $\\text{relocations\\_at\\_load} = 0$, and $\\text{loader\\_uses\\_dynsym} = 0$, but still report $\\text{io\\_bytes} = B$ and compute $\\text{debug\\_score}$ from $S$, $D$, and $U$.\n- If $T=0$, then dynamic resolution is not required at load time; in this case, $\\text{load\\_success} = 1$ regardless of $D$, and $\\text{relocations\\_at\\_load} = 0$.\n- If lazy binding is enabled ($L=1$) and inputs are valid and $\\text{load\\_success} = 1$, relocations resolved at load time exclude the $F$ function-call relocations, so only non-function relocations are resolved at load time. If immediate binding is enabled ($L=0$), all $T$ relocations are resolved at load time on success.\n\nNote that strippings that remove the general symbol table while keeping the dynamic one correspond to $S=0$ and $D=1$; these should not change loader success nor $io\\_bytes$ nor the count of relocations at load compared to $S=1$, but should reduce the $debug\\_score$.\n\nTest suite parameters to evaluate:\n\n- Case A (stripped, lazy binding, with unwind): $S=0$, $D=1$, $L=1$, $U=1$, $T=120$, $F=40$, $B=1000000$, $Y=200000$.\n- Case B (unstripped baseline, lazy binding, with unwind): $S=1$, $D=1$, $L=1$, $U=1$, $T=120$, $F=40$, $B=1000000$, $Y=200000$.\n- Case C (stripped, immediate binding, no unwind): $S=0$, $D=1$, $L=0$, $U=0$, $T=50$, $F=50$, $B=409600$, $Y=150000$.\n- Case D (invalid: function-call relocations exceed total): $S=0$, $D=1$, $L=1$, $U=1$, $T=10$, $F=15$, $B=123456$, $Y=654321$.\n- Case E (missing dynamic symbol table but relocations exist): $S=1$, $D=0$, $L=1$, $U=1$, $T=80$, $F=20$, $B=777000$, $Y=300000$.\n- Case F (no relocations at all): $S=0$, $D=0$, $L=1$, $U=0$, $T=0$, $F=0$, $B=2048$, $Y=32000$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results for all cases as a comma-separated list of per-case results, enclosed in square brackets. Each per-case result must itself be a bracketed, comma-separated list in the exact order $[\\text{load\\_success},\\text{relocations\\_at\\_load},\\text{io\\_bytes},\\text{debug\\_score},\\text{loader\\_uses\\_dynsym},\\text{error\\_code}]$. For example: $[[a\\_1,b\\_1,c\\_1,d\\_1,e\\_1,f\\_1],[a\\_2,b\\_2,c\\_2,d\\_2,e\\_2,f\\_2],\\dots]$. All values must be integers, with $io\\_bytes$ expressed in bytes.", "solution": "The problem statement has been meticulously validated and is determined to be valid. It is scientifically grounded in the principles of operating system loaders and linkers, well-posed with clear definitions and objectives, and free from any subjective or contradictory statements. I will now proceed with a formal solution.\n\nThe problem asks us to construct a computational model of a dynamic loader's behavior based on a set of fundamental principles and input parameters. We must calculate six output metrics for a given test suite. The model's logic is derived from first principles as follows.\n\nLet the input parameters for a given binary be a tuple $(S, D, L, U, T, F, B, Y)$, where:\n- $S \\in \\{0,1\\}$: Presence of the general symbol table (`.symtab`).\n- $D \\in \\{0,1\\}$: Presence of the dynamic symbol table (`.dynsym`).\n- $L \\in \\{0,1\\}$: Use of lazy binding ($L=1$) versus immediate binding ($L=0$).\n- $U \\in \\{0,1\\}$: Presence of unwind information.\n- $T \\in \\mathbb{Z}_{\\ge 0}$: Total number of relocations.\n- $F \\in \\mathbb{Z}_{\\ge 0}$: Number of function-call relocations eligible for lazy binding.\n- $B \\in \\mathbb{Z}_{\\ge 0}$: Size of loadable segments in bytes.\n- $Y \\in \\mathbb{Z}_{\\ge 0}$: Size of the general symbol table in bytes.\n\nWe are to compute the following six outputs: $\\text{load\\_success}$, $\\text{relocations\\_at\\_load}$, $\\text{io\\_bytes}$, $\\text{debug\\_score}$, $\\text{loader\\_uses\\_dynsym}$, and $\\text{error\\_code}$. The derivation for each is as follows.\n\n**1. Error Code ($\\text{error\\_code} \\in \\{0,1,2\\}$)**\n\nThe $\\text{error\\_code}$ identifies the validity and executability of the scenario.\n- An $\\text{error\\_code}$ of $2$ signifies invalid input parameters. This occurs if any flag is not in $\\{0,1\\}$, if any count/size is negative, or if the number of function relocations $F$ exceeds the total relocations $T$.\n$$ \\text{error\\_code} = 2 \\iff (S, D, L, U \\notin \\{0,1\\}) \\lor (T, F, B, Y  0) \\lor (F > T) $$\n- An $\\text{error\\_code}$ of $1$ signifies a failure at load time due to missing prerequisites. The dynamic loader requires the dynamic symbol table (`.dynsym`, indicated by $D=1$) to resolve any relocations ($T > 0$). If relocations are needed but the table is missing, loading fails.\n$$ \\text{error\\_code} = 1 \\iff (T > 0 \\land D = 0) \\land (\\text{inputs are valid}) $$\n- An $\\text{error\\_code}$ of $0$ indicates that the configuration is valid and loader execution can proceed.\n$$ \\text{error\\_code} = 0 \\iff (\\text{not error code 1 or 2}) $$\n\n**2. I/O at Load Time ($\\text{io\\_bytes} \\in \\mathbb{Z}_{\\ge 0}$)**\n\nThe dynamic loader reads only the loadable segments of the binary from disk into memory. The total size of these segments is given by $B$. The general symbol table, of size $Y$, is typically not in a loadable segment and thus is not read by the loader. Therefore, the I/O at load time is independent of other factors and is always equal to $B$.\n$$ \\text{io\\_bytes} = B $$\n\n**3. Debuggability Score ($\\text{debug\\_score} \\in \\{0,1,2,3\\}$)**\n\nThe debug score is a composite metric based on symbol availability and unwind information.\n- Symbol Name Coverage: Full debugging symbols are in the general symbol table (`.symtab`, $S=1$), contributing a score of $2$. If `.symtab` is stripped ($S=0$) but the dynamic symbol table (`.dynsym`, $D=1$) remains, limited symbol information (for exported symbols) is available, contributing a score of $1$. If both are absent ($S=0, D=0$), there is no symbol information, contributing $0$.\n$$ \\text{score}_{\\text{name}} = \\begin{cases} 2  \\text{if } S=1 \\\\ 1  \\text{if } S=0 \\land D=1 \\\\ 0  \\text{if } S=0 \\land D=0 \\end{cases} $$\n- Unwind Capability: The presence of unwind information ($U=1$) is essential for reliable stack backtraces and contributes a score of $1$. Its absence ($U=0$) contributes $0$.\n$$ \\text{score}_{\\text{unwind}} = U $$\nThe total score is the sum:\n$$ \\text{debug\\_score} = \\text{score}_{\\text{name}} + \\text{score}_{\\text{unwind}} $$\nThis score is calculated regardless of $\\text{error\\_code}$.\n\n**4. Loader Success ($\\text{load\\_success} \\in \\{0,1\\}$)**\n\nThe loader succeeds if and only if the scenario is valid and executable, which corresponds to an $\\text{error\\_code}$ of $0$. Any other error code signifies a failure condition.\n$$ \\text{load\\_success} = \\begin{cases} 1  \\text{if } \\text{error\\_code} = 0 \\\\ 0  \\text{if } \\text{error\\_code} \\in \\{1, 2\\} \\end{cases} $$\n\n**5. Relocations Resolved at Load Time ($\\text{relocations\\_at\\_load} \\in \\mathbb{Z}_{\\ge 0}$)**\n\nThis metric is meaningful only upon successful loading. If loading fails, no relocations are ultimately resolved by the loader.\n- If $\\text{load\\_success} = 0$, then $\\text{relocations\\_at\\_load} = 0$.\n- If $\\text{load\\_success} = 1$:\n    - With immediate binding ($L=0$), the loader resolves all $T$ relocations at program start.\n    - With lazy binding ($L=1$), the loader resolves all non-function data relocations ($T-F$) at program start, deferring the $F$ function relocations.\n$$ \\text{relocations\\_at\\_load} = \\begin{cases} 0  \\text{if } \\text{load\\_success} = 0 \\\\ T-F  \\text{if } \\text{load\\_success} = 1 \\land L=1 \\\\ T  \\text{if } \\text{load\\_success} = 1 \\land L=0 \\end{cases} $$\nNote this is consistent with the boundary condition for $T=0$, where $F$ must also be $0$, yielding $\\text{relocations\\_at\\_load}=0$.\n\n**6. Loader Usage of Dynamic Symbol Table ($\\text{loader\\_uses\\_dynsym} \\in \\{0,1\\}$)**\n\nThe loader consults the dynamic symbol table (`.dynsym`) if and only if loading proceeds successfully and there are any relocations to resolve, either at load time or later. The total number of relocations is $T$.\n$$ \\text{loader\\_uses\\_dynsym} = \\begin{cases} 1  \\text{if } \\text{load\\_success} = 1 \\land T > 0 \\\\ 0  \\text{otherwise} \\end{cases} $$\n\nThese derived rules form the complete model to be implemented.", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n#include string.h\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    const char* case_id;\n    int S;\n    int D;\n    int L;\n    int U;\n    long T;\n    long F;\n    long B;\n    long Y;\n} TestCase;\n\n// A struct to hold the computed results for a single test case.\ntypedef struct {\n    int load_success;\n    long relocations_at_load;\n    long io_bytes;\n    int debug_score;\n    int loader_uses_dynsym;\n    int error_code;\n} Results;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {\"A\", 0, 1, 1, 1, 120, 40, 1000000, 200000},\n        {\"B\", 1, 1, 1, 1, 120, 40, 1000000, 200000},\n        {\"C\", 0, 1, 0, 0, 50, 50, 409600, 150000},\n        {\"D\", 0, 1, 1, 1, 10, 15, 123456, 654321},\n        {\"E\", 1, 0, 1, 1, 80, 20, 777000, 300000},\n        {\"F\", 0, 0, 1, 0, 0, 0, 2048, 32000}\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    Results results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        Results res = {0};\n\n        // Step 1: Calculate error_code\n        if (tc.S  0 || tc.S  1 || tc.D  0 || tc.D  1 || tc.L  0 || tc.L  1 || tc.U  0 || tc.U  1 || \n            tc.T  0 || tc.F  0 || tc.B  0 || tc.Y  0 || tc.F  tc.T) {\n            res.error_code = 2; // Invalid inputs\n        } else if (tc.T  0  tc.D == 0) {\n            res.error_code = 1; // Dynamic resolution impossible\n        } else {\n            res.error_code = 0; // No error\n        }\n\n        // Step 2: Calculate io_bytes (unconditional)\n        res.io_bytes = tc.B;\n\n        // Step 3: Calculate debug_score (unconditional)\n        int name_coverage_score = 0;\n        if (tc.S == 1) {\n            name_coverage_score = 2;\n        } else if (tc.D == 1) {\n            name_coverage_score = 1;\n        }\n        int unwind_score = tc.U;\n        res.debug_score = name_coverage_score + unwind_score;\n\n        // Step 4: Calculate load_success\n        res.load_success = (res.error_code == 0) ? 1 : 0;\n\n        // Step 5: Calculate relocations_at_load\n        if (res.load_success == 1) {\n            if (tc.L == 1) { // Lazy binding\n                res.relocations_at_load = tc.T - tc.F;\n            } else { // Immediate binding\n                res.relocations_at_load = tc.T;\n            }\n        } else {\n            res.relocations_at_load = 0;\n        }\n\n        // Step 6: Calculate loader_uses_dynsym\n        if (res.load_success == 1  tc.T  0) {\n            res.loader_uses_dynsym = 1;\n        } else {\n            res.loader_uses_dynsym = 0;\n        }\n\n        // Final overrides for error_code = 2 as per problem statement\n        if (res.error_code == 2) {\n            res.load_success = 0;\n            res.relocations_at_load = 0;\n            res.loader_uses_dynsym = 0;\n        }\n\n        results[i] = res;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"[%d,%ld,%ld,%d,%d,%d]\",\n            results[i].load_success,\n            results[i].relocations_at_load,\n            results[i].io_bytes,\n            results[i].debug_score,\n            results[i].loader_uses_dynsym,\n            results[i].error_code\n        );\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3637126"}, {"introduction": "Dynamic loading often employs an optimization known as lazy binding, which defers the resolution of function symbols until they are first called, thereby speeding up application startup. However, this efficiency comes with a trade-off: it introduces a window of fragility where the program can fail long after it has started. This simulation challenges you to model the precise conditions under which lazy binding can lead to a runtime crash, specifically when a required library is removed after the program launches but before a function within it is invoked [@problem_id:3637179]. This exercise provides a clear, formal model to explore the temporal dependencies and potential pitfalls inherent in lazy binding.", "problem": "You are asked to model and simulate the behavior of a dynamic linker under lazy binding in a simplified, formally specified setting. The goal is to evaluate whether a program call to an imported symbol crashes when the providing shared library file is removed between program start and symbol resolution time. You will write a program that simulates this behavior under clearly defined policies and event order, using only the provided formal model.\n\nDefinitions and model:\n- Time is discrete with steps $t \\in \\mathbb{Z}_{\\ge 0}$.\n- A single main executable imports exactly one symbol from a single shared library.\n- The presence of the library file is modeled by a predicate $P(t) \\in \\{0,1\\}$, where $P(t) = 1$ if and only if the library file exists at time $t$.\n- A removal time $t_r \\in \\mathbb{Z} \\cup \\{-1\\}$ is specified per scenario as follows: if $t_r = -1$, then $P(t) = 1$ for all $t \\ge 0$; if $t_r \\ge 0$, then $P(t) = 1$ for all $t  t_r$ and $P(t) = 0$ for all $t \\ge t_r$. Removal, when it occurs, is processed at the beginning of a time step.\n- The dynamic linker behavior is parameterized by a policy $\\pi \\in \\{\\text{LAZY}, \\text{EAGER}\\}$.\n- There are two internal state bits:\n  1. $M(t) \\in \\{0,1\\}$ indicating whether the providing library has been mapped into the process address space by time $t$.\n  2. $C(t) \\in \\{0,1\\}$ indicating whether the call site has cached the resolved symbol address by time $t$.\n- Policy semantics:\n  - Under $\\text{LAZY}$: $M(0) = 0$ and $C(0) = 0$.\n  - Under $\\text{EAGER}$: the loader maps the library at program start, before any removals, so $M(0) = 1$ and $C(0) = 0$.\n- Event order at each time step $t$:\n  1. If $t = t_r \\ge 0$, process removal first to set $P(t) = 0$.\n  2. Then process any scheduled call at time $t$.\n- Call processing rule at time $t$:\n  - If $M(t) = 0$:\n    - If $P(t) = 0$, the call crashes immediately (no changes to $M$ or $C$ occur).\n    - If $P(t) = 1$, the loader maps the library and resolves the symbol, setting $M(t^{+}) = 1$ and $C(t^{+}) = 1$, and the call succeeds.\n  - If $M(t) = 1$, the call succeeds, and we set $C(t^{+}) = 1$.\n- Persistence: once $M(t)$ becomes $1$, it remains $1$ thereafter; once $C(t)$ becomes $1$, it remains $1$ thereafter.\n\nInput to your simulation:\n- A finite sequence of test scenarios, each defined by:\n  - A policy $\\pi \\in \\{\\text{LAZY}, \\text{EAGER}\\}$.\n  - A removal time $t_r \\in \\mathbb{Z} \\cup \\{-1\\}$.\n  - A non-decreasing finite list of call times $\\langle t_1, t_2, \\dots, t_k \\rangle$, where each $t_i \\in \\mathbb{Z}_{\\ge 0}$ is the time of a call to the imported symbol that must be simulated using the rules above.\n\nOutput required:\n- For each call event in the order they occur within each scenario, output an integer $x \\in \\{0,1\\}$ where $x = 1$ if that call crashes under the model, and $x = 0$ if it succeeds.\n- Aggregate the outputs for all scenarios into a single line formatted as a comma-separated list enclosed in square brackets, for example, $[x_1,x_2,\\dots,x_N]$.\n\nTest suite to implement and evaluate:\n- Test $1$ (failure on first call under lazy binding when the library is removed before the first call):\n  - Policy $\\pi = \\text{LAZY}$, removal time $t_r = 1$, calls $\\langle 2 \\rangle$.\n- Test $2$ (boundary condition when removal and first call occur at the same time step: removal is processed first):\n  - Policy $\\pi = \\text{LAZY}$, removal time $t_r = 3$, calls $\\langle 3 \\rangle$.\n- Test $3$ (robustness under eager mapping: removal before first call does not cause a crash):\n  - Policy $\\pi = \\text{EAGER}$, removal time $t_r = 1$, calls $\\langle 2 \\rangle$.\n- Test $4$ (caching robustness: first call before removal resolves and maps, subsequent calls after removal still succeed):\n  - Policy $\\pi = \\text{LAZY}$, removal time $t_r = 2$, calls $\\langle 0, 3 \\rangle$.\n- Test $5$ (happy path: no removal, lazy binding resolves on first call):\n  - Policy $\\pi = \\text{LAZY}$, removal time $t_r = -1$, calls $\\langle 0 \\rangle$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,\\dots,x_N]$). The unit of each result is a pure number in $\\{0,1\\}$.", "solution": "The problem has been validated and found to be well-posed, scientifically grounded, and objective. It presents a formal, deterministic model of dynamic linker behavior that can be simulated to yield a unique result for each specified scenario. We shall now proceed with the solution by analyzing each test case according to the provided rules.\n\nThe state of the system for each test scenario is described by the tuple $(M(t), C(t), P(t))$, where $M(t) \\in \\{0,1\\}$ is the memory-mapped status of the library, $C(t) \\in \\{0,1\\}$ is the cached status of the symbol address, and $P(t) \\in \\{0,1\\}$ is the presence of the library file on disk. The evolution of this state is determined by the policy $\\pi \\in \\{\\text{LAZY}, \\text{EAGER}\\}$, the removal time $t_r \\in \\mathbb{Z} \\cup \\{-1\\}$, and the sequence of call times $\\langle t_i \\rangle$.\n\n**Test 1 Analysis**\n*   **Parameters**: Policy $\\pi = \\text{LAZY}$, removal time $t_r = 1$, calls at $\\langle 2 \\rangle$.\n*   **Initial State ($t=0$):** Under the $\\text{LAZY}$ policy, the library is not mapped at program start. Thus, $M(0) = 0$ and $C(0) = 0$.\n*   **Environment**: The removal time is $t_r = 1$. The library presence predicate is $P(t) = 1$ for $t  1$ and $P(t) = 0$ for $t \\ge 1$.\n*   **Call at $t=2$**:\n    1.  We evaluate the state at the beginning of the call processing at $t=2$. Since no events occurred between $t=0$ and $t=2$ that would change the state, $M(2) = M(0) = 0$.\n    2.  The library presence at this time is $P(2) = 0$, as $2 \\ge t_r$.\n    3.  We apply the call processing rule for the case $M(t)=0$. The rule states that if $P(t)=0$, the call crashes.\n*   **Result**: The call at $t=2$ crashes. The output is $1$.\n\n**Test 2 Analysis**\n*   **Parameters**: Policy $\\pi = \\text{LAZY}$, removal time $t_r = 3$, calls at $\\langle 3 \\rangle$.\n*   **Initial State ($t=0$):** $\\pi = \\text{LAZY}$, so $M(0) = 0$ and $C(0) = 0$.\n*   **Environment**: $t_r = 3$, so $P(t) = 1$ for $t  3$ and $P(t) = 0$ for $t \\ge 3$.\n*   **Call at $t=3$**:\n    1.  The event order at a given time step $t$ is well-defined: removal is processed before calls. At $t=3$, since $t=t_r$, the removal is processed first, setting $P(3)=0$.\n    2.  After the removal, the call at $t=3$ is processed. The state $M(3)$ is still $0$, as no prior successful resolution occurred.\n    3.  We apply the call processing rule for $M(3)=0$. Because $P(3)=0$, the call crashes.\n*   **Result**: The call at $t=3$ crashes. The output is $1$.\n\n**Test 3 Analysis**\n*   **Parameters**: Policy $\\pi = \\text{EAGER}$, removal time $t_r = 1$, calls at $\\langle 2 \\rangle$.\n*   **Initial State ($t=0$):** Under the $\\text{EAGER}$ policy, the library is mapped at program start. Thus, $M(0) = 1$ and $C(0) = 0$.\n*   **Environment**: $t_r = 1$, so $P(t) = 1$ for $t  1$ and $P(t) = 0$ for $t \\ge 1$.\n*   **Call at $t=2$**:\n    1.  We evaluate the state at $t=2$. The state bit $M$ is persistent; once $M=1$, it remains $1$. So, $M(2) = M(0) = 1$.\n    2.  We apply the call processing rule for the case $M(t)=1$. The rule states that the call succeeds. The presence of the file, $P(2)=0$, is irrelevant because the library is already in the process's address space. The call also ensures the cache is populated, so $C(2^{+})=1$.\n*   **Result**: The call at $t=2$ succeeds. The output is $0$.\n\n**Test 4 Analysis**\n*   **Parameters**: Policy $\\pi = \\text{LAZY}$, removal time $t_r = 2$, calls at $\\langle 0, 3 \\rangle$.\n*   **Initial State ($t=0$):** $\\pi = \\text{LAZY}$, so $M(0) = 0$ and $C(0) = 0$.\n*   **Environment**: $t_r = 2$, so $P(t) = 1$ for $t  2$ and $P(t) = 0$ for $t \\ge 2$.\n*   **First Call at $t=0$**:\n    1.  The state at the beginning of the call is $M(0)=0$.\n    2.  The library presence is $P(0)=1$, as $0  t_r$.\n    3.  We apply the rule for $M(t)=0$ with $P(t)=1$. The call succeeds, and the state is updated to $M(0^{+})=1$ and $C(0^{+})=1$.\n*   **Result of first call**: The call at $t=0$ succeeds. The output is $0$.\n*   **Second Call at $t=3$**:\n    1.  We evaluate the state at $t=3$. Due to the persistence rule and the successful call at $t=0$, the state is $M(3)=1$. The removal event at $t=2$ sets $P(t)=0$ for $t \\ge 2$, so $P(3)=0$.\n    2.  We apply the call processing rule for the case $M(3)=1$. The call succeeds. The value of $P(3)$ is inconsequential.\n*   **Result of second call**: The call at $t=3$ succeeds. The output is $0$.\n*   **Combined Result**: The sequence of outputs for this test case is $(0, 0)$.\n\n**Test 5 Analysis**\n*   **Parameters**: Policy $\\pi = \\text{LAZY}$, removal time $t_r = -1$, calls at $\\langle 0 \\rangle$.\n*   **Initial State ($t=0$):** $\\pi = \\text{LAZY}$, so $M(0) = 0$ and $C(0) = 0$.\n*   **Environment**: $t_r = -1$, meaning the library is never removed. $P(t)=1$ for all $t \\ge 0$.\n*   **Call at $t=0$**:\n    1.  The state at the beginning of the call is $M(0)=0$.\n    2.  The library presence is $P(0)=1$.\n    3.  We apply the rule for $M(t)=0$ with $P(t)=1$. The call succeeds, and the state updates to $M(0^{+})=1$ and $C(0^{+})=1$.\n*   **Result**: The call at $t=0$ succeeds. The output is $0$.\n\n**Final Aggregated Results**\nCollating the results from each test in the specified order:\n- Test 1: $1$\n- Test 2: $1$\n- Test 3: $0$\n- Test 4: $0, 0$\n- Test 5: $0$\nThe final sequence of outputs is $\\langle 1, 1, 0, 0, 0, 0 \\rangle$.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n\n// Define the linker policies as an enumeration for clarity.\ntypedef enum {\n    POLICY_LAZY,\n    POLICY_EAGER\n} Policy;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    Policy policy;\n    int removal_time; // Corresponds to t_r\n    const int* call_times;\n    int num_calls;\n    const char* description;\n} TestCase;\n\nint main(void) {\n    // Define the call time sequences for each test case.\n    const int calls1[] = {2};\n    const int calls2[] = {3};\n    const int calls3[] = {2};\n    const int calls4[] = {0, 3};\n    const int calls5[] = {0};\n\n    // Define the test suite from the problem statement.\n    TestCase test_cases[] = {\n        {POLICY_LAZY, 1, calls1, sizeof(calls1)/sizeof(calls1[0]), \"Test 1\"},\n        {POLICY_LAZY, 3, calls2, sizeof(calls2)/sizeof(calls2[0]), \"Test 2\"},\n        {POLICY_EAGER, 1, calls3, sizeof(calls3)/sizeof(calls3[0]), \"Test 3\"},\n        {POLICY_LAZY, 2, calls4, sizeof(calls4)/sizeof(calls4[0]), \"Test 4\"},\n        {POLICY_LAZY, -1, calls5, sizeof(calls5)/sizeof(calls5[0]), \"Test 5\"}\n    };\n\n    int num_test_suites = sizeof(test_cases) / sizeof(test_cases[0]);\n    \n    // Calculate the total number of call events to store results.\n    int total_calls = 0;\n    for (int i = 0; i  num_test_suites; ++i) {\n        total_calls += test_cases[i].num_calls;\n    }\n    \n    int* results = (int*)malloc(total_calls * sizeof(int));\n    if (results == NULL) {\n        return EXIT_FAILURE;\n    }\n    int result_index = 0;\n\n    // Simulate each test case.\n    for (int i = 0; i  num_test_suites; ++i) {\n        TestCase current_test = test_cases[i];\n\n        // Initialize state variables M(t) and C(t) for the scenario.\n        // M: library mapped, C: call site cached\n        int M = 0;\n        int C = 0; // C is not strictly needed for this logic, but part of the model.\n\n        // Apply EAGER policy if specified.\n        if (current_test.policy == POLICY_EAGER) {\n            M = 1; // Library is mapped at t=0.\n        }\n\n        // Process each call event in the current test case.\n        for (int j = 0; j  current_test.num_calls; ++j) {\n            int t_call = current_test.call_times[j];\n            int t_r = current_test.removal_time;\n\n            // Determine the library presence predicate P(t) at the time of the call.\n            // P = 1 if library exists, P = 0 if removed.\n            // Removal at t_r means for all t = t_r, the library is absent.\n            int P = 1;\n            if (t_r != -1  t_call = t_r) {\n                P = 0;\n            }\n\n            int call_crashes = 0;\n\n            // Apply the formal call processing rules from the problem statement.\n            if (M == 0) { // Library is not yet mapped into memory.\n                if (P == 0) { // Attempt to map, but file is gone.\n                    call_crashes = 1;\n                    // State M and C do not change on crash.\n                } else { // P == 1, file exists.\n                    call_crashes = 0; // Call succeeds.\n                    // Loader maps library and resolves symbol.\n                    M = 1; // State M becomes 1 and persists.\n                    C = 1; // State C becomes 1 and persists.\n                }\n            } else { // M == 1, library is already in memory.\n                call_crashes = 0; // Call succeeds.\n                C = 1; // Symbol is (re)cached. State C remains 1.\n            }\n            \n            results[result_index++] = call_crashes;\n        }\n    }\n\n    // Print the aggregated results in the exact required format.\n    printf(\"[\");\n    for (int i = 0; i  total_calls; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  total_calls - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    free(results);\n    return EXIT_SUCCESS;\n}\n```", "id": "3637179"}, {"introduction": "The lifecycle of a dynamically loaded module concludes when it is no longer needed and its resources can be reclaimed by the operating system. However, unloading a module is not always straightforward; the system must ensure that no part of the program is still using it. This practice delves into the mechanics of safe module unloading by modeling the reference counting mechanisms that prevent memory from being freed prematurely. You will simulate how the system distinguishes between persistent handles (from calls like `dlopen`) and transient execution references to implement deferred unmapping, a core principle ensuring program stability [@problem_id:3637167].", "problem": "Consider a simplified, purely logical model of dynamic loading and unloading in an Operating System (OS). The goal is to capture the principle that a request to unload a dynamically loaded module (for example, via a function analogous to the Portable Operating System Interface (POSIX) function $dlclose$) does not reclaim its code pages if the module remains referenced, and to demonstrate deferred unmap behavior. You must build a program that simulates a set of modules, their handle reference counts, ephemeral execution references, and the mapping and reclamation of their code pages.\n\nFundamental base and definitions to use:\n1. A module is considered resident (mapped) if it has at least one handle reference or at least one ephemeral execution reference. Handles represent explicit dynamic loader references (e.g., from $dlopen$), and ephemeral references represent transient ties such as active function pointers or threads executing within the module’s code.\n2. Let the set of modules be indexed by $i \\in \\{0,\\dots,N-1\\}$. For each module $i$, define:\n   - $P_i$: the number of code pages the module occupies.\n   - $h_i$: the handle reference count.\n   - $e_i$: the count of ephemeral execution references.\n   - $m_i \\in \\{0,1\\}$: the mapping state, where $m_i=1$ means the module is currently mapped (resident), and $m_i=0$ means it is unmapped.\n   - $d_i \\in \\{0,1\\}$: a deferred unmap flag set when an unload request occurs while ephemeral references remain ($e_i0$).\n3. The simulation processes a sequence of events for each module:\n   - $L_i$: acquire a handle on module $i$; $h_i \\leftarrow h_i + 1$, and if $m_i=0$ then $m_i \\leftarrow 1$ (mapping occurs).\n   - $C_i$: release a handle (an unload request) on module $i$ if $h_i0$; $h_i \\leftarrow h_i - 1$. If after decrement $h_i=0$ and $e_i0$, then set $d_i \\leftarrow 1$ (deferred unmap). If $h_i=0$ and $e_i=0$, then unmap immediately.\n   - $A_i$: acquire an ephemeral reference on module $i$; $e_i \\leftarrow e_i + 1$, and if $m_i=0$ then $m_i \\leftarrow 1$ (mapping occurs).\n   - $R_i$: release an ephemeral reference on module $i$ if $e_i0$; $e_i \\leftarrow e_i - 1$. If now $h_i=0$ and $e_i=0$ and $m_i=1$, then unmap immediately, consuming any deferred unmap request.\n4. Unmap rule and reclamation: whenever $m_i=1$, $h_i=0$, and $e_i=0$, the module’s code pages are reclaimed and $m_i \\leftarrow 0$, $d_i \\leftarrow 0$. The total number of reclaimed pages for a test is the sum of $P_i$ reclaimed across all unmap events. The final resident pages are $\\sum_i m_i \\cdot P_i$.\n\nYour program must implement this model deterministically for the provided test suite and produce a single line of output that aggregates the results for all test cases. Each test case’s result must be a list of two integers $[R,F]$ where $R$ is the total reclaimed pages over the entire event sequence, and $F$ is the final resident pages after all events.\n\nTest suite:\n- Test case $1$ (happy path demonstrating deferred unmap):\n  - Modules: $N=1$.\n  - Initial state: $P_0=5$, $h_0=1$, $e_0=1$, $m_0=1$ (by definition since either $h_00$ or $e_00$).\n  - Events: $C_0$, $R_0$.\n  - Interpretation: the unload attempt $C_0$ cannot reclaim pages because $e_00$; reclamation occurs after $R_0$ when both references are $0$.\n- Test case $2$ (multiple handles, immediate unmap when both counts reach zero):\n  - Modules: $N=1$.\n  - Initial state: $P_0=3$, $h_0=2$, $e_0=0$, $m_0=1$.\n  - Events: $C_0$, $C_0$.\n  - Interpretation: only after the second close does $h_0$ reach $0$ and $e_0=0$, so pages are reclaimed immediately.\n- Test case $3$ (two modules, mixed immediate and deferred unmap):\n  - Modules: $N=2$.\n  - Initial state: module $0$ has $P_0=4$, $h_0=1$, $e_0=0$, $m_0=1$; module $1$ has $P_1=2$, $h_1=1$, $e_1=1$, $m_1=1$.\n  - Events: $C_0$, $C_1$, $R_1$.\n  - Interpretation: module $0$ reclaims immediately on $C_0$. Module $1$ defers on $C_1$ and only reclaims on $R_1$.\n- Test case $4$ (boundary: unload request with zero handles, then map via handle and defer due to ephemeral reference):\n  - Modules: $N=1$.\n  - Initial state: $P_0=7$, $h_0=0$, $e_0=0$, $m_0=0$.\n  - Events: $C_0$, $L_0$, $A_0$, $C_0$, $R_0$.\n  - Interpretation: initial $C_0$ is a no-op since $h_0=0$. $L_0$ maps the module. $A_0$ adds an ephemeral reference. $C_0$ defers unmap, and $R_0$ triggers reclamation.\n- Test case $5$ (resident at end: extra handle prevents unmap):\n  - Modules: $N=1$.\n  - Initial state: $P_0=9$, $h_0=1$, $e_0=0$, $m_0=1$.\n  - Events: $L_0$, $C_0$.\n  - Interpretation: net handle count remains $h_0=1$, so the module stays mapped and no pages are reclaimed.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case yields its $[R,F]$ list in order. For example, the output format must be exactly like $[[r_1,f_1],[r_2,f_2],\\dots]$ with integers. There are no physical units or angle units involved, and no percentages are required. There is no input; all parameters are embedded in the program as constants matching the test suite above.", "solution": "We start from the fundamental definitions of dynamic loading, reference counting, and memory mapping behavior. In a dynamic loading environment, a module’s residency (whether its code pages are mapped) is governed by whether there are outstanding references. Explicit dynamic loader handles (for instance from $dlopen$ in the Portable Operating System Interface (POSIX)) are counted in a handle reference count, and transient execution ties such as active frames or function pointers are captured as ephemeral execution references. From the operating system perspective, reclaiming memory pages is only safe when no code paths or handles refer to the module. This leads to a principle of reference counting and safe reclamation.\n\nWe model each module $i$ with:\n- $P_i$: pages occupied by its code.\n- $h_i$: handle count.\n- $e_i$: ephemeral reference count.\n- $m_i \\in \\{0,1\\}$: mapping state, deduced initially as $m_i=1$ if either $h_i0$ or $e_i0$, else $m_i=0$.\n- $d_i \\in \\{0,1\\}$: deferred unmap flag, recording that an unload attempt happened when $e_i0$.\n\nWe formalize the events and state transitions:\n1. On $L_i$, we set $h_i \\leftarrow h_i+1$ and, if $m_i=0$, then $m_i \\leftarrow 1$ because acquiring a handle implies mapping the module.\n2. On $C_i$, if $h_i0$, we set $h_i \\leftarrow h_i-1$. If after decrement $h_i=0$ and $e_i0$ and $m_i=1$, we set $d_i \\leftarrow 1$ to record a deferred unmap condition. If after decrement $h_i=0$ and $e_i=0$ and $m_i=1$, we immediately unmap:\n   - Reclaim $\\Delta R = P_i$ pages,\n   - Set $m_i \\leftarrow 0$ and $d_i \\leftarrow 0$.\n3. On $A_i$, we set $e_i \\leftarrow e_i+1$ and, if $m_i=0$, set $m_i \\leftarrow 1$ because an ephemeral execution reference implies the module must be resident.\n4. On $R_i$, if $e_i0$, we set $e_i \\leftarrow e_i-1$. If after decrement $h_i=0$ and $e_i=0$ and $m_i=1$, we unmap immediately:\n   - Reclaim $\\Delta R = P_i$ pages,\n   - Set $m_i \\leftarrow 0$ and $d_i \\leftarrow 0$.\n\nWe implement a unified unmap check after each event:\n- If $m_i=1$ and $h_i=0$ and $e_i=0$, then reclaim $P_i$, set $m_i \\leftarrow 0$ and $d_i \\leftarrow 0$. This embodies both immediate unmap and the realization of deferred unmap conditions, and ensures that reclamation occurs exactly once per module when both categories of references reach zero simultaneously.\n\nCorrectness and invariants:\n- Safety invariant: A module can only be unmapped when $h_i=0$ and $e_i=0$. This reflects the operating system constraint that no code pages are reclaimed while references remain.\n- Liveness invariant: If an unload request sets $h_i=0$ but ephemeral references remain ($e_i0$), then unmap is deferred; later, when $e_i$ reaches $0$, the deferred condition is resolved and pages are reclaimed. The $d_i$ flag is helpful diagnostically but is not strictly required for correctness if we always check the unmap condition after each event.\n- Accounting invariant: The total reclaimed pages $R$ for a test case equal the sum of $P_i$ across all unmap events that occur within the sequence. The final resident pages $F$ are $\\sum_i m_i \\cdot P_i$ computed after processing all events.\n\nWe now apply the event sequences from the test suite:\n- Test case $1$: Start with $P_0=5$, $h_0=1$, $e_0=1$, $m_0=1$. Event $C_0$ sets $h_0=0$ while $e_0=1$, deferring unmap ($d_0=1$). Event $R_0$ sets $e_0=0$, and since $h_0=0$, $e_0=0$, $m_0=1$, we unmap and reclaim $5$ pages; final resident pages are $0$.\n- Test case $2$: Start with $P_0=3$, $h_0=2$, $e_0=0$, $m_0=1$. Event $C_0$ sets $h_0=1$, no unmap. Event $C_0$ sets $h_0=0$ and $e_0=0$ while $m_0=1$, so we unmap and reclaim $3$ pages; final resident pages are $0$.\n- Test case $3$: Module $0$ has $P_0=4$, $h_0=1$, $e_0=0$, $m_0=1$; module $1$ has $P_1=2$, $h_1=1$, $e_1=1$, $m_1=1$. Event $C_0$ sets $h_0=0$ and $e_0=0$ while $m_0=1$, so we reclaim $4$ pages immediately. Event $C_1$ sets $h_1=0$ while $e_1=1$, deferring unmap. Event $R_1$ sets $e_1=0$ and triggers unmap, reclaiming $2$ pages; final resident pages are $0$.\n- Test case $4$: Start with $P_0=7$, $h_0=0$, $e_0=0$, $m_0=0$. Event $C_0$ is a no-op since $h_0=0$. Event $L_0$ sets $h_0=1$ and maps ($m_0=1$). Event $A_0$ sets $e_0=1$. Event $C_0$ sets $h_0=0$ while $e_0=1$, deferring unmap. Event $R_0$ sets $e_0=0$ and triggers unmap, reclaiming $7$ pages; final resident pages are $0$.\n- Test case $5$: Start with $P_0=9$, $h_0=1$, $e_0=0$, $m_0=1$. Event $L_0$ sets $h_0=2$, Event $C_0$ sets $h_0=1$. Since $h_00$, the module remains mapped and no pages are reclaimed; final resident pages are $9$.\n\nThus the expected output is the single line $[[5,0],[3,0],[6,0],[7,0],[0,9]]$. The implementation is entirely self-contained, performs no input/output other than printing this final line, and adheres to the specified format.", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n#include string.h\n\ntypedef struct {\n    char op; // 'L' (acquire handle), 'C' (close handle), 'A' (acquire ephemeral), 'R' (release ephemeral)\n    int m;   // module index\n} Event;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int num_modules;\n    int pages[3]; // code pages per module (up to 3 modules for generality)\n    int h[3];     // handle counts\n    int e[3];     // ephemeral counts\n    int num_events;\n    Event events[16]; // sequence of events\n} TestCase;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        // Test case 1: deferred unmap (C then R)\n        {\n            .num_modules = 1,\n            .pages = {5, 0, 0},\n            .h = {1, 0, 0},\n            .e = {1, 0, 0},\n            .num_events = 2,\n            .events = {\n                {'C', 0},\n                {'R', 0}\n            }\n        },\n        // Test case 2: multiple handles, immediate unmap when both reach zero\n        {\n            .num_modules = 1,\n            .pages = {3, 0, 0},\n            .h = {2, 0, 0},\n            .e = {0, 0, 0},\n            .num_events = 2,\n            .events = {\n                {'C', 0},\n                {'C', 0}\n            }\n        },\n        // Test case 3: two modules, mixed immediate and deferred unmap\n        {\n            .num_modules = 2,\n            .pages = {4, 2, 0},\n            .h = {1, 1, 0},\n            .e = {0, 1, 0},\n            .num_events = 3,\n            .events = {\n                {'C', 0},\n                {'C', 1},\n                {'R', 1}\n            }\n        },\n        // Test case 4: boundary: close with zero handles, then map via L and defer due to A\n        {\n            .num_modules = 1,\n            .pages = {7, 0, 0},\n            .h = {0, 0, 0},\n            .e = {0, 0, 0},\n            .num_events = 5,\n            .events = {\n                {'C', 0},\n                {'L', 0},\n                {'A', 0},\n                {'C', 0},\n                {'R', 0}\n            }\n        },\n        // Test case 5: resident at end due to remaining handle\n        {\n            .num_modules = 1,\n            .pages = {9, 0, 0},\n            .h = {1, 0, 0},\n            .e = {0, 0, 0},\n            .num_events = 2,\n            .events = {\n                {'L', 0},\n                {'C', 0}\n            }\n        }\n    };\n\n    int num_cases = (int)(sizeof(test_cases) / sizeof(test_cases[0]));\n    // Each result is a pair: [reclaimed_total, final_resident]\n    int reclaimed[num_cases];\n    int final_resident[num_cases];\n\n    for (int t = 0; t  num_cases; ++t) {\n        TestCase *tc = test_cases[t];\n\n        // Derived state per module\n        int mapped[3] = {0, 0, 0};\n        int deferred[3] = {0, 0, 0}; // deferred unmap flag (diagnostic)\n\n        // Initialize mapping state: mapped if any references exist\n        for (int i = 0; i  tc-num_modules; ++i) {\n            mapped[i] = (tc-h[i]  0 || tc-e[i]  0) ? 1 : 0;\n            deferred[i] = 0;\n        }\n\n        int total_reclaimed = 0;\n\n        for (int k = 0; k  tc-num_events; ++k) {\n            Event ev = tc-events[k];\n            int m = ev.m;\n\n            switch (ev.op) {\n                case 'L': {\n                    // Acquire handle; map if needed.\n                    tc-h[m] += 1;\n                    if (!mapped[m]) {\n                        mapped[m] = 1;\n                    }\n                    break;\n                }\n                case 'C': {\n                    // Close handle if present.\n                    if (tc-h[m]  0) {\n                        tc-h[m] -= 1;\n                    }\n                    // If handles are now zero but ephemeral remains, mark deferred.\n                    if (mapped[m]  tc-h[m] == 0  tc-e[m]  0) {\n                        deferred[m] = 1;\n                    }\n                    break;\n                }\n                case 'A': {\n                    // Acquire ephemeral; map if needed.\n                    tc-e[m] += 1;\n                    if (!mapped[m]) {\n                        mapped[m] = 1;\n                    }\n                    break;\n                }\n                case 'R': {\n                    // Release ephemeral if present.\n                    if (tc-e[m]  0) {\n                        tc-e[m] -= 1;\n                    }\n                    break;\n                }\n                default: {\n                    // Unknown event: no-op.\n                    break;\n                }\n            }\n\n            // Unified unmap check after each event for the affected module.\n            if (mapped[m]  tc-h[m] == 0  tc-e[m] == 0) {\n                total_reclaimed += tc-pages[m];\n                mapped[m] = 0;\n                deferred[m] = 0; // resolve any deferred state\n            }\n        }\n\n        // Compute final resident pages\n        int resident_pages = 0;\n        for (int i = 0; i  tc-num_modules; ++i) {\n            if (mapped[i]) {\n                resident_pages += tc-pages[i];\n            }\n        }\n\n        reclaimed[t] = total_reclaimed;\n        final_resident[t] = resident_pages;\n    }\n\n    // Print the results in the EXACT REQUIRED format: a single line\n    // [[r1,f1],[r2,f2],...]\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"[%d,%d]\", reclaimed[i], final_resident[i]);\n        if (i + 1  num_cases) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3637167"}]}