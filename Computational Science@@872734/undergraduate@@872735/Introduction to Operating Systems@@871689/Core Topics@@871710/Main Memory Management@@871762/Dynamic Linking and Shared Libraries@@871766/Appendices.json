{"hands_on_practices": [{"introduction": "When building complex software, the same function name may be defined in multiple places, such as a default implementation in a shared library and a specialized version in your main program. The dynamic linker resolves these potential conflicts using a deterministic set of rules based on symbol \"strength\" (weak vs. strong) and a predefined search order. This practice [@problem_id:3636892] allows you to model this decision logic, helping you understand how choices are made at both link-time and load-time, which is essential for predicting program behavior and debugging complex linking issues.", "problem": "You will design and implement a complete, runnable program that models the interplay between weak and strong symbols across an executable and shared libraries, and that distinguishes decisions made at link-time versus load-time. The context is a simplified and idealized model of Executable and Linkable Format (ELF) dynamic linking in an operating system, focusing on how the loader and linker choose symbol definitions.\n\nThe fundamental base you must use consists of the following well-tested facts and core definitions:\n- A symbol has a binding strength that is either weak or strong. In this model, encode absence as $0$, weak as $1$, and strong as $2$ for each object.\n- At static link-time, when multiple object files are combined into a single link unit, a strong definition overrides any number of weak definitions of the same symbol, and multiple strong definitions of the same symbol in the same link unit constitute a link-time error.\n- At dynamic load-time, a loader resolves undefined references by searching a well-defined order of objects. For this problem, use the following precedence order, which reflects common interposition behavior: preloaded libraries first, then the executable, then other shared libraries. In this model, if no definition is found at load-time and the reference is weak, the relocation may resolve to a null address; if the reference is strong and unresolved, it is a runtime error.\n\nYour task is to:\n- Define a deterministic decision procedure that, given parameters describing three objects and the type of reference, predicts which definition is chosen at static link-time (if objects are bundled into a single link unit) and which definition is chosen at dynamic load-time (if linking is deferred).\n- Implement this decision procedure as a C program adhering to the exact output specification below.\n\nParameters per test case are:\n- $s_X \\in \\{0,1,2\\}$: symbol strength in the executable $X$ ($0$ absent, $1$ weak, $2$ strong).\n- $s_L \\in \\{0,1,2\\}$: symbol strength in a shared library $L$ ($0$ absent, $1$ weak, $2$ strong).\n- $s_P \\in \\{0,1,2\\}$: symbol strength in a preloaded library $P$ ($0$ absent, $1$ weak, $2$ strong).\n- $p \\in \\{0,1\\}$: whether preloading is active ($1$ means $P$ is present and has highest precedence, $0$ otherwise).\n- $b \\in \\{0,1\\}$: bundling indicator; $1$ means $L$ is statically bundled into the same link unit as $X$ (static linking across object files), $0$ means dynamic linking (no bundling).\n- $w \\in \\{0,1\\}$: whether the reference to the symbol is weak ($1$ means the reference is weak and can legally resolve to a null address if no definition exists, $0$ means the reference is strong and must resolve to a definition).\n\nThe program must produce, for each test case, two decision codes:\n- Link-time decision code $\\ell$:\n  - $\\ell = 0$ if the executable $X$'s definition is chosen at link-time,\n  - $\\ell = 1$ if the library $L$'s definition is chosen at link-time,\n  - $\\ell = -1$ if there is a link-time error due to multiple strong definitions in a single bundled link unit,\n  - $\\ell = -3$ if linking is dynamic and the decision is deferred to load-time.\n- Load-time decision code $r$:\n  - $r = 2$ if the preloaded library $P$'s definition is chosen at load-time,\n  - $r = 0$ if the executable $X$'s definition is chosen at load-time,\n  - $r = 1$ if the library $L$'s definition is chosen at load-time,\n  - $r = 3$ if no definition is found and the reference is weak, resolving to a null address,\n  - $r = -2$ if no definition is found and the reference is strong, causing a runtime error,\n  - $r = -1$ if there was a prior link-time error that prevents execution.\n\nYou must derive $\\ell$ and $r$ from the fundamental base described above, without relying on any shortcut formulas provided to you.\n\nThe test suite is the following set of parameter combinations, designed to cover typical and edge cases:\n- Case A: $(s_X,s_L,s_P,p,b,w) = (2,1,0,0,0,0)$.\n- Case B: $(s_X,s_L,s_P,p,b,w) = (0,1,0,0,0,0)$.\n- Case C: $(s_X,s_L,s_P,p,b,w) = (2,1,2,1,0,0)$.\n- Case D: $(s_X,s_L,s_P,p,b,w) = (2,2,0,0,1,0)$.\n- Case E: $(s_X,s_L,s_P,p,b,w) = (0,0,0,0,0,1)$.\n- Case F: $(s_X,s_L,s_P,p,b,w) = (0,0,0,0,0,0)$.\n- Case G: $(s_X,s_L,s_P,p,b,w) = (1,1,0,0,1,0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of pairs, where each pair is the link-time decision code and the load-time decision code for the corresponding test case, in the order A through G, enclosed in square brackets. For example, your output must look exactly like $[\\,[\\ell_A,r_A],[\\ell_B,r_B],\\dots,[\\ell_G,r_G]\\,]$, with numeric codes as defined above and no additional text.\n\nAll answers are integers; no physical units, angles, or percentages are involved. The output must be computed by the program without any user input or external files.", "solution": "We begin from core definitions that govern symbol resolution and the behavior of weak and strong bindings. Let the executable be denoted by $X$, a shared library by $L$, and a preloaded library by $P$, each possibly containing a definition of the same symbol. The strength values are encoded as $s_X,s_L,s_P \\in \\{0,1,2\\}$, corresponding to absence, weak, and strong, respectively.\n\nFirst, we derive the link-time decision $\\ell$. The fundamental fact is that when multiple object files are combined into a single link unit (static linking across object files), a strong definition overrides any number of weak definitions of the same symbol, and multiple strong definitions of the same symbol in that single link unit constitute a link-time error. This property can be captured by the following reasoning:\n- If $b=0$, then $L$ is not bundled into the same link unit as $X$, which means dynamic linking is used, and selection of any external symbol cannot be finalized at link-time. Therefore the link-time decision is deferred, and we set $\\ell=-3$.\n- If $b=1$, then $L$ and $X$ are merged in the same link unit. Consider the number of strong definitions of the symbol across $X$ and $L$:\n  - If $s_X=2$ and $s_L=2$, then there are two strong definitions in the same link unit, which creates a multiple strong definition conflict; hence $\\ell=-1$ (link-time error).\n  - If exactly one of $s_X$ or $s_L$ equals $2$, that strong definition overrides any weak definitions, selecting the corresponding object; set $\\ell=0$ if $s_X=2$ and $\\ell=1$ if $s_L=2$.\n  - If both are weak (i.e., $s_X=1$ and $s_L=1$), then there is no strong definition, and the linker must choose a single definition from among weak ones in the link unit. A common and consistent deterministic approach is that the first definition encountered in the link unit is selected. Without loss of generality and to maintain determinism, we select the executable’s definition when both are weak, giving $\\ell=0$. If exactly one is weak and the other is absent, the weak definition is selected accordingly, again with $\\ell=0$ when $s_X=1$ and $\\ell=1$ when $s_L=1$.\n  - If both are absent ($s_X=0$ and $s_L=0$), there is no definition to bind at link-time. In a static bundle $b=1$, this situation would yield an undefined symbol at link-time. To remain consistent with the requirement that the program compute both link-time and load-time decisions, we constrain practical test cases such that when $b=1$ at least one definition exists. In the provided suite, this constraint holds.\n\nSecond, we derive the load-time decision $r$. At dynamic load-time, the loader uses a search order reflecting interposition precedence. The essential, well-tested behavior we use is that preloaded libraries are searched first, then the executable, then other shared libraries. Therefore:\n- If a link-time error occurred (i.e., $\\ell=-1$), the program cannot execute, and we assign $r=-1$ to encode that load-time is unreachable due to prior failure.\n- Otherwise, check for a definition according to precedence that incorporates preloading control $p$:\n  - If $p=1$ and $s_P > 0$, choose $P$, giving $r=2$.\n  - Else if $s_X > 0$, choose $X$, giving $r=0$.\n  - Else if $s_L > 0$, choose $L$, giving $r=1$.\n  - Else if no definition is found among $P$, $X$, and $L$, then the outcome depends on the reference strength $w$:\n    - If $w=1$, this is a weak undefined reference and may legally resolve to a null address; encode this as $r=3$.\n    - If $w=0$, this is a strong reference and must resolve to an actual definition; the absence of a definition produces a runtime error, encoded as $r=-2$.\n\nNote that the call origin inside the process does not alter the global interposition outcome in this simplified model; the first matching definition in the precedence order is used system-wide for references that participate in the global scope resolution.\n\nWe now apply the decision procedure to the test suite:\n\n- Case A: $(s_X,s_L,s_P,p,b,w)=(2,1,0,0,0,0)$. Since $b=0$, $\\ell=-3$. At load-time, $p=0$, $s_P=0$, $s_X=2>0$, so choose $X$, giving $r=0$.\n- Case B: $(s_X,s_L,s_P,p,b,w)=(0,1,0,0,0,0)$. $b=0$ implies $\\ell=-3$. At load-time, no $P$, $s_X=0$, $s_L=1>0$, so choose $L$, yielding $r=1$.\n- Case C: $(s_X,s_L,s_P,p,b,w)=(2,1,2,1,0,0)$. $b=0$ implies $\\ell=-3$. At load-time, $p=1$ and $s_P=2>0$, so choose $P$, yielding $r=2$.\n- Case D: $(s_X,s_L,s_P,p,b,w)=(2,2,0,0,1,0)$. $b=1$ and both $s_X=2$ and $s_L=2$ are strong in the same link unit, so $\\ell=-1$. Load-time cannot proceed, so $r=-1$.\n- Case E: $(s_X,s_L,s_P,p,b,w)=(0,0,0,0,0,1)$. $b=0$ implies $\\ell=-3$. At load-time, there is no definition in $P$, $X$, or $L$; since $w=1$, it resolves to null, giving $r=3$.\n- Case F: $(s_X,s_L,s_P,p,b,w)=(0,0,0,0,0,0)$. $b=0$ implies $\\ell=-3$. At load-time, there is no definition, and $w=0$ requires a definition; hence runtime error $r=-2$.\n- Case G: $(s_X,s_L,s_P,p,b,w)=(1,1,0,0,1,0)$. $b=1$ bundles $X$ and $L$; both are weak, so choose the executable deterministically, $\\ell=0$. At load-time, the chosen definition in the executable exists, and with no $P$ ahead, interposition yields $X$, so $r=0$.\n\nThe final output must be a single line containing the seven pairs $[\\ell,r]$ in order A through G, enclosed in brackets. The list is computed without any external input.\n\nThis derivation follows directly from the foundational rules about weak and strong symbol behavior at link-time and from the load-time search order with interposition and preloading, and yields a clear and testable algorithm that maps directly to the required integer codes.", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// Code mapping:\n// Link-time codes:\n//  0 -> choose executable (X)\n//  1 -> choose library (L)\n// -1 -> link-time error (multiple strong in bundled link unit)\n// -3 -> decision deferred to load-time (dynamic linking)\n//\n// Load-time codes:\n//  2 -> choose preloaded library (P)\n//  0 -> choose executable (X)\n//  1 -> choose library (L)\n//  3 -> weak undefined resolves to null\n// -2 -> strong undefined causes runtime error\n// -1 -> cannot run because of link-time error\n\ntypedef struct {\n    int sX;      // symbol strength in executable X: 0 absent, 1 weak, 2 strong\n    int sL;      // symbol strength in shared library L: 0 absent, 1 weak, 2 strong\n    int sP;      // symbol strength in preloaded library P: 0 absent, 1 weak, 2 strong\n    int preload; // p: 0 no preloading, 1 preloading active\n    int bundle;  // b: 0 dynamic (no bundling), 1 static bundling into same link unit\n    int refWeak; // w: 0 strong reference, 1 weak reference\n} TestCase;\n\n// Determine link-time decision code.\nstatic int link_decision(const TestCase *tc) {\n    if (tc->bundle == 0) {\n        // Dynamic linking: decision deferred to load-time.\n        return -3;\n    }\n    // Static bundling: X and L are in the same link unit.\n    int xStrong = (tc->sX == 2);\n    int lStrong = (tc->sL == 2);\n    int xWeak   = (tc->sX == 1);\n    int lWeak   = (tc->sL == 1);\n\n    // Multiple strong definitions in same link unit -> link-time error.\n    if (xStrong && lStrong) {\n        return -1;\n    }\n    // Exactly one strong -> choose that.\n    if (xStrong) return 0;\n    if (lStrong) return 1;\n\n    // No strong: consider weak and absence.\n    if (xWeak && lWeak) {\n        // Deterministic tie-break: prefer executable (first) when both are weak.\n        return 0;\n    }\n    if (xWeak) return 0;\n    if (lWeak) return 1;\n\n    // Both absent in a bundled scenario would be an undefined at link-time,\n    // but our provided test suite avoids this case when bundle==1.\n    // If encountered, treat as link-time error (undefined).\n    return -1;\n}\n\n// Determine load-time decision code.\nstatic int runtime_decision(const TestCase *tc, int link_code) {\n    if (link_code == -1) {\n        // Prior link-time error prevents execution.\n        return -1;\n    }\n\n    // Preload has highest precedence if active and P defines the symbol.\n    if (tc->preload == 1 && tc->sP > 0) {\n        return 2; // choose P\n    }\n    // Next precedence: executable X.\n    if (tc->sX > 0) {\n        return 0;\n    }\n    // Then shared library L.\n    if (tc->sL > 0) {\n        return 1;\n    }\n    // No definition found: resolve based on reference strength.\n    if (tc->refWeak == 1) {\n        return 3; // weak undefined resolves to null\n    }\n    return -2; // strong undefined -> runtime error\n}\n\nint main(void) {\n    // Define the test cases from the problem statement (A through G).\n    TestCase test_cases[] = {\n        // Case A: (sX,sL,sP,p,b,w) = (2,1,0,0,0,0)\n        {2, 1, 0, 0, 0, 0},\n        // Case B: (sX,sL,sP,p,b,w) = (0,1,0,0,0,0)\n        {0, 1, 0, 0, 0, 0},\n        // Case C: (sX,sL,sP,p,b,w) = (2,1,2,1,0,0)\n        {2, 1, 2, 1, 0, 0},\n        // Case D: (sX,sL,sP,p,b,w) = (2,2,0,0,1,0)\n        {2, 2, 0, 0, 1, 0},\n        // Case E: (sX,sL,sP,p,b,w) = (0,0,0,0,0,1)\n        {0, 0, 0, 0, 0, 1},\n        // Case F: (sX,sL,sP,p,b,w) = (0,0,0,0,0,0)\n        {0, 0, 0, 0, 0, 0},\n        // Case G: (sX,sL,sP,p,b,w) = (1,1,0,0,1,0)\n        {1, 1, 0, 0, 1, 0}\n    };\n\n    int num_cases = (int)(sizeof(test_cases) / sizeof(test_cases[0]));\n    int link_codes[num_cases];\n    int runtime_codes[num_cases];\n\n    for (int i = 0; i < num_cases; ++i) {\n        link_codes[i] = link_decision(&test_cases[i]);\n        runtime_codes[i] = runtime_decision(&test_cases[i], link_codes[i]);\n    }\n\n    // Print the results in the EXACT REQUIRED format:\n    // [[lA,rA],[lB,rB],...,[lG,rG]]\n    putchar('[');\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%d,%d]\", link_codes[i], runtime_codes[i]);\n        if (i + 1 < num_cases) {\n            putchar(',');\n        }\n    }\n    putchar(']');\n    return EXIT_SUCCESS;\n}\n```", "id": "3636892"}, {"introduction": "The primary advantage of shared libraries is their efficiency; a single copy of a library's code in physical memory can be used by multiple processes simultaneously. This sharing is made possible by a compilation technique known as Position-Independent Code (PIC), which ensures the executable code segment does not need modification when loaded. This exercise [@problem_id:3636956] challenges you to quantify the memory savings of this approach by modeling the costs of an older, non-PIC strategy versus a modern PIC-based one, providing a concrete understanding of why PIC is a cornerstone of modern operating systems.", "problem": "You are to model and quantify the impact of dynamic relocation on memory sharing when loading shared libraries in an operating system that uses virtual memory with pages and copy-on-write. You will compare a non-position-independent code (non-PIC) shared object against a position-independent code (PIC) shared object. The goal is to derive, then compute, the additional private memory induced by relocations under each model across multiple processes, explain why non-PIC text relocations can fail under a strict write-xor-execute policy, and how the Global Offset Table (GOT) and Procedure Linkage Table (PLT) design move relocation writes out of the read-only text segment.\n\nFundamental base to use:\n- Definition of virtual memory pages of size $P$ bytes, with copy-on-write semantics: if $k$ processes map the same file-backed read-only page, they share one physical copy. If any process writes to that page, the operating system creates a private copy for that process. Writing to a page with copy-on-write therefore increases private memory usage by $P$ bytes per process beyond the single shared copy.\n- Dynamic relocation by the runtime linker writes resolved addresses into relocation targets.\n- In the non-position-independent model, absolute addresses in the text segment require text relocations; writing into the text segment causes either copy-on-write of those pages per process, or failure under a strict write-xor-execute policy that forbids making the text segment writable.\n- In the position-independent model, the Global Offset Table (GOT) holds addresses to be resolved, and the Procedure Linkage Table (PLT) uses indirect jumps through the GOT. Relocation writes are redirected into writable data pages (GOT), keeping the text segment read-only and fully shareable.\n\nMathematical model and required computation:\n- Let there be $N$ processes concurrently mapping the same shared object.\n- Let page size be $P$ bytes.\n- Let text segment size be $T$ bytes. Let the set of non-PIC text relocation offsets be $\\mathcal{O} = \\{o_1, o_2, \\dots, o_a\\}$, where each $o_i$ is a byte offset within $[0, T-1]$ from the start of the text segment that the dynamic linker writes to.\n- Let the GOT have total size $G$ bytes, divided into entries of size $E$ bytes. Let the set of GOT indices requiring relocation be $\\mathcal{I} = \\{i_1, i_2, \\dots, i_b\\}$, where each $i_j$ is an integer index such that $0 \\le i_j \\cdot E < G$. These GOT relocations occur under both non-PIC and PIC.\n- Define the set of text pages dirtied by relocations as $\\mathcal{P}_{\\text{text}} = \\left\\{ \\left\\lfloor \\dfrac{o}{P} \\right\\rfloor \\,\\middle|\\, o \\in \\mathcal{O} \\right\\}$ with cardinality $U_{\\text{text}} = \\left|\\mathcal{P}_{\\text{text}}\\right|$.\n- Define the set of GOT pages dirtied by relocations as $\\mathcal{P}_{\\text{got}} = \\left\\{ \\left\\lfloor \\dfrac{i \\cdot E}{P} \\right\\rfloor \\,\\middle|\\, i \\in \\mathcal{I} \\right\\}$ with cardinality $U_{\\text{got}} = \\left|\\mathcal{P}_{\\text{got}}\\right|$.\n- Additional private memory solely due to relocations is computed using copy-on-write semantics as follows:\n  - For non-PIC, both the text and GOT pages are dirtied: \n    $$M_{\\text{nonpic}} = (N - 1) \\cdot (U_{\\text{text}} + U_{\\text{got}}) \\cdot P.$$\n  - For PIC, only the GOT pages are dirtied (text remains read-only and fully shared):\n    $$M_{\\text{pic}} = (N - 1) \\cdot U_{\\text{got}} \\cdot P.$$\n- A strict write-xor-execute policy indicator $\\sigma \\in \\{0,1\\}$ is given, where $\\sigma = 1$ forbids text relocations. The failure indicator is \n  $$F = \\begin{cases}\n  1, & \\text{if } \\sigma = 1 \\text{ and } U_{\\text{text}} > 0,\\\\\n  0, & \\text{otherwise.}\n  \\end{cases}$$\n\nYour program must compute, for each test case, the $4$-tuple \n$$\\left[F,\\; M_{\\text{nonpic}},\\; M_{\\text{pic}},\\; M_{\\text{nonpic}} - M_{\\text{pic}}\\right],$$ \nwhere all quantities are integers measured in bytes. The difference $M_{\\text{nonpic}} - M_{\\text{pic}}$ represents the bytes of additional private memory saved by using position-independent code; it will be non-negative under this model.\n\nUnits: All memory sizes must be expressed in bytes.\n\nAngle units: Not applicable.\n\nPercentages: Not applicable.\n\nTest suite to implement inside your program:\n- Case A (general case):\n  - $P = 4096$, $N = 10$, $T = 16384$, $G = 4096$, $E = 8$, $\\sigma = 0$,\n  - $\\mathcal{O} = \\{100, 4095, 4096, 8191\\}$,\n  - $\\mathcal{I} = \\{0, 1\\}$.\n- Case B (no text relocations, GOT relocations only, strict policy enabled):\n  - $P = 4096$, $N = 5$, $T = 4096$, $G = 4096$, $E = 8$, $\\sigma = 1$,\n  - $\\mathcal{O} = \\emptyset$,\n  - $\\mathcal{I} = \\{0, 400\\}$.\n- Case C (all text relocations within a single page, repeated offsets, boundary condition on deduplication):\n  - $P = 1024$, $N = 3$, $T = 2048$, $G = 1024$, $E = 16$, $\\sigma = 1$,\n  - $\\mathcal{O} = \\{0, 1, 1023\\}$,\n  - $\\mathcal{I} = \\{0\\}$.\n- Case D (GOT entries span two pages due to entry size, multiple text pages touched, smallest $N$ above $1$):\n  - $P = 4096$, $N = 2$, $T = 32768$, $G = 9000$, $E = 500$, $\\sigma = 0$,\n  - $\\mathcal{O} = \\{0, 5000, 9000, 16000, 32000\\}$,\n  - $\\mathcal{I} = \\{0, 9\\}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing a comma-separated list of the per-test results, enclosed in a single pair of square brackets. Each per-test result must itself be a list of four integers in square brackets. No spaces are allowed anywhere in the output.\n- Example overall shape: \n  - For $k$ test cases, output should look like \n  $$\\text{\"[[r_{1,1},r_{1,2},r_{1,3},r_{1,4}],[r_{2,1},r_{2,2},r_{2,3},r_{2,4}],\\dots,[r_{k,1},r_{k,2},r_{k,3},r_{k,4}]]\"}.$$", "solution": "The problem requires an analysis of the memory overhead incurred by dynamic relocations for shared libraries, comparing position-independent code (PIC) with non-position-independent code (non-PIC). The analysis is situated within the context of a modern operating system employing virtual memory with paged memory management and a copy-on-write (COW) mechanism.\n\n### Fundamental Principles\n\n1.  **Virtual Memory and Paging**: The operating system provides each process with its own private virtual address space, which is mapped to physical memory in discrete units called pages. A page is a contiguous block of virtual memory of size $P$ bytes.\n\n2.  **Shared Libraries and Copy-on-Write (COW)**: To conserve physical memory, when multiple processes load the same shared library, the OS maps their corresponding virtual pages to the same physical pages of memory. Initially, these pages are marked as read-only. If any process attempts to write to such a shared page, the COW mechanism is triggered. The OS intercepts the write, allocates a new physical page, copies the content of the original shared page to it, and maps the writing process's virtual page to this new, private, writable copy. This ensures process isolation while maximizing memory sharing for read-only data. The cost of a COW fault on a single page for $N$ processes that all eventually write to it is the creation of $N-1$ new physical pages, one for each process after the first write triggers the initial split. The total private memory becomes $N \\cdot P$ bytes, an increase of $(N-1) \\cdot P$ bytes over the single shared page.\n\n3.  **Dynamic Relocation**: When a program uses a shared library, the addresses of functions and global variables in that library are not known at compile time. The dynamic linker resolves these symbolic references at load time or run time by writing the actual virtual addresses into designated locations. These write operations are called relocations.\n\n4.  **Non-Position-Independent Code (non-PIC)**: In this older model, the compiler generates code that uses absolute addresses. Consequently, the machine code itself (the `.text` segment) contains locations that must be patched by the dynamic linker with the correct addresses. These are known as text relocations. When a process loads a non-PIC shared library, the dynamic linker must write into its `.text` segment. This act of writing triggers COW for every page containing a relocation target.\n\n5.  **Position-Independent Code (PIC) and the GOT/PLT**: To avoid text relocations, modern systems use PIC. All memory accesses are made relative to the current instruction pointer. For external symbols, this is mediated by two structures:\n    *   **Global Offset Table (GOT)**: A table located in the writable data segment that stores the absolute addresses of external functions and variables.\n    *   **Procedure Linkage Table (PLT)**: A read-only table in the text segment containing small code stubs. When a function in the shared library is called for the first time, its PLT entry calls a resolver routine in the dynamic linker. The resolver finds the function's true address and writes it into the corresponding GOT entry. Subsequent calls to the same function are redirected via the PLT to the GOT, which now contains the correct address, and jump to it directly.\n\n    This design ensures that all relocation writes occur in the writable data segment (specifically, the GOT), leaving the text segment pristine (read-only). The text segment can thus be shared among all processes without ever triggering COW faults due to relocations.\n\n6.  **Write-XOR-Execute (W^X)**: A security policy that prevents a memory page from being both writable and executable simultaneously. This mitigates certain classes of exploits, such as buffer overflows that inject and execute malicious code. Under a strict W^X policy, attempting to make an executable page (like one in the `.text` segment) writable will fail. Consequently, loading a non-PIC shared library that requires text relocations is impossible under such a policy.\n\n### Mathematical Model Derivation\n\nThe problem provides a formal model to quantify the memory impact.\n\n-   **Unique Dirtied Pages**: A relocation at offset $o$ dirties the page with index $\\left\\lfloor o/P \\right\\rfloor$. Since multiple relocations can fall within the same page, we must count the number of *unique* pages affected. The set of unique text pages dirtied is $\\mathcal{P}_{\\text{text}} = \\left\\{ \\left\\lfloor o/P \\right\\rfloor \\mid o \\in \\mathcal{O} \\right\\}$, and its cardinality is $U_{\\text{text}} = |\\mathcal{P}_{\\text{text}}|$. Similarly, for the GOT, a relocation for entry $i$ occurs at offset $i \\cdot E$. The set of unique GOT pages dirtied is $\\mathcal{P}_{\\text{got}} = \\left\\{ \\left\\lfloor (i \\cdot E)/P \\right\\rfloor \\mid i \\in \\mathcal{I} \\right\\}$, with cardinality $U_{\\text{got}} = |\\mathcal{P}_{\\text{got}}|$.\n\n-   **Additional Private Memory Calculation**: For each unique page that is written to, $N-1$ private copies are created across the $N$ processes, each of size $P$.\n    -   For a **non-PIC** library, both text and GOT relocations occur. The total number of unique dirtied pages is $U_{\\text{text}} + U_{\\text{got}}$. The total additional private memory is therefore:\n        $$M_{\\text{nonpic}} = (N - 1) \\cdot (U_{\\text{text}} + U_{\\text{got}}) \\cdot P$$\n    -   For a **PIC** library, only GOT relocations occur. The text segment is not written to, so $U_{\\text{text}}$ does not contribute to the COW overhead. The additional private memory is:\n        $$M_{\\text{pic}} = (N - 1) \\cdot U_{\\text{got}} \\cdot P$$\n\n-   **Failure Indicator ($F$)**: The indicator models the effect of a W^X policy. If the policy is strict ($\\sigma=1$) and there are any text relocations ($U_{\\text{text}} > 0$), the loading process fails.\n    $$F = \\begin{cases} 1, & \\text{if } \\sigma = 1 \\text{ and } U_{\\text{text}} > 0 \\\\ 0, & \\text{otherwise} \\end{cases}$$\n\n-   **Memory Savings**: The difference $M_{\\text{nonpic}} - M_{\\text{pic}}$ quantifies the memory savings achieved by using PIC, which is attributable entirely to avoiding text relocations:\n    $$M_{\\text{nonpic}} - M_{\\text{pic}} = (N - 1) \\cdot U_{\\text{text}} \\cdot P$$\n\n### Computation for Test Cases\n\nThe solution requires calculating the 4-tuple $\\left[F, M_{\\text{nonpic}}, M_{\\text{pic}}, M_{\\text{nonpic}} - M_{\\text{pic}}\\right]$ for each provided test case. This involves determining $U_{\\text{text}}$ and $U_{\\text{got}}$ by finding the number of unique page indices for the given relocation offsets and then applying the formulas above.\n\n**Case A:** $P=4096, N=10, \\sigma=0, \\mathcal{O}=\\{100, 4095, 4096, 8191\\}, \\mathcal{I}=\\{0, 1\\}, E=8$.\n-   $U_{\\text{text}}$: Offsets $100, 4095$ map to page $\\lfloor 100/4096 \\rfloor = \\lfloor 4095/4096 \\rfloor = 0$. Offsets $4096, 8191$ map to page $\\lfloor 4096/4096 \\rfloor = \\lfloor 8191/4096 \\rfloor = 1$. The set of unique pages is $\\{0, 1\\}$, so $U_{\\text{text}}=2$.\n-   $U_{\\text{got}}$: Indices $0, 1$ give offsets $0 \\cdot 8=0$ and $1 \\cdot 8=8$. Both map to page $\\lfloor 0/4096 \\rfloor = \\lfloor 8/4096 \\rfloor = 0$. The set is $\\{0\\}$, so $U_{\\text{got}}=1$.\n-   $F=0$ since $\\sigma=0$.\n-   $M_{\\text{nonpic}} = (10-1) \\cdot (2+1) \\cdot 4096 = 9 \\cdot 3 \\cdot 4096 = 110592$ bytes.\n-   $M_{\\text{pic}} = (10-1) \\cdot 1 \\cdot 4096 = 9 \\cdot 4096 = 36864$ bytes.\n-   Difference = $110592 - 36864 = 73728$ bytes.\n-   Result: $[0, 110592, 36864, 73728]$\n\n**Case B:** $P=4096, N=5, \\sigma=1, \\mathcal{O}=\\emptyset, \\mathcal{I}=\\{0, 400\\}, E=8$.\n-   $U_{\\text{text}}=0$ since $\\mathcal{O}$ is empty.\n-   $U_{\\text{got}}$: Indices $0, 400$ give offsets $0, 3200$. Both map to page $\\lfloor 0/4096 \\rfloor = \\lfloor 3200/4096 \\rfloor = 0$. The set is $\\{0\\}$, so $U_{\\text{got}}=1$.\n-   $F=0$ since $U_{\\text{text}}=0$.\n-   $M_{\\text{nonpic}} = (5-1) \\cdot (0+1) \\cdot 4096 = 4 \\cdot 4096 = 16384$ bytes.\n-   $M_{\\text{pic}} = (5-1) \\cdot 1 \\cdot 4096 = 4 \\cdot 4096 = 16384$ bytes.\n-   Difference = $0$ bytes.\n-   Result: $[0, 16384, 16384, 0]$\n\n**Case C:** $P=1024, N=3, \\sigma=1, \\mathcal{O}=\\{0, 1, 1023\\}, \\mathcal{I}=\\{0\\}, E=16$.\n-   $U_{\\text{text}}$: Offsets $0, 1, 1023$ all map to page $\\lfloor 0/1024 \\rfloor = \\dots = \\lfloor 1023/1024 \\rfloor = 0$. The set is $\\{0\\}$, so $U_{\\text{text}}=1$.\n-   $U_{\\text{got}}$: Index $0$ gives offset $0$, which maps to page $\\lfloor 0/1024 \\rfloor = 0$. The set is $\\{0\\}$, so $U_{\\text{got}}=1$.\n-   $F=1$ since $\\sigma=1$ and $U_{\\text{text}}=1 > 0$.\n-   $M_{\\text{nonpic}} = (3-1) \\cdot (1+1) \\cdot 1024 = 2 \\cdot 2 \\cdot 1024 = 4096$ bytes.\n-   $M_{\\text{pic}} = (3-1) \\cdot 1 \\cdot 1024 = 2 \\cdot 1024 = 2048$ bytes.\n-   Difference = $2048$ bytes.\n-   Result: $[1, 4096, 2048, 2048]$\n\n**Case D:** $P=4096, N=2, \\sigma=0, \\mathcal{O}=\\{0, 5000, 9000, 16000, 32000\\}, \\mathcal{I}=\\{0, 9\\}, E=500$.\n-   $U_{\\text{text}}$: Page indices are $\\lfloor 0/4096 \\rfloor=0$, $\\lfloor 5000/4096 \\rfloor=1$, $\\lfloor 9000/4096 \\rfloor=2$, $\\lfloor 16000/4096 \\rfloor=3$, $\\lfloor 32000/4096 \\rfloor=7$. The set is $\\{0, 1, 2, 3, 7\\}$, so $U_{\\text{text}}=5$.\n-   $U_{\\text{got}}$: Indices $0, 9$ give offsets $0, 4500$. Page indices are $\\lfloor 0/4096 \\rfloor=0$, $\\lfloor 4500/4096 \\rfloor=1$. The set is $\\{0, 1\\}$, so $U_{\\text{got}}=2$.\n-   $F=0$ since $\\sigma=0$.\n-   $M_{\\text{nonpic}} = (2-1) \\cdot (5+2) \\cdot 4096 = 1 \\cdot 7 \\cdot 4096 = 28672$ bytes.\n-   $M_{\\text{pic}} = (2-1) \\cdot 2 \\cdot 4096 = 1 \\cdot 2 \\cdot 4096 = 8192$ bytes.\n-   Difference = $28672 - 8192 = 20480$ bytes.\n-   Result: $[0, 28672, 8192, 20480]$", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    long long P, N, T, G, E;\n    int sigma;\n    const int* O; // Pointer to array of text relocation offsets\n    int O_size;   // Size of O array\n    const int* I; // Pointer to array of GOT indices\n    int I_size;   // Size of I array\n} TestCase;\n\n// Comparison function for qsort\nstatic int compare_ints(const void *a, const void *b) {\n    int int_a = *((const int*)a);\n    int int_b = *((const int*)b);\n    if (int_a < int_b) return -1;\n    if (int_a > int_b) return 1;\n    return 0;\n}\n\n// Helper function to count unique pages dirtied by relocations.\n// For text relocations, pass entry_size = 1.\n// For GOT relocations, pass entry_size = E, and items = indices.\nstatic int count_unique_pages(const int* items, int count, long long page_size, long long entry_size) {\n    if (count == 0) {\n        return 0;\n    }\n\n    int* page_indices = malloc(count * sizeof(int));\n    if (page_indices == NULL) {\n        // This should not happen in this controlled environment.\n        fprintf(stderr, \"Fatal: Memory allocation failed.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Calculate page indices for each relocation target\n    for (int i = 0; i < count; ++i) {\n        long long offset = (long long)items[i] * entry_size;\n        page_indices[i] = (int)(offset / page_size);\n    }\n\n    // Sort to bring duplicates together\n    qsort(page_indices, count, sizeof(int), compare_ints);\n\n    // Count unique elements in the sorted array\n    int unique_count = 1;\n    for (int i = 1; i < count; ++i) {\n        if (page_indices[i] != page_indices[i - 1]) {\n            unique_count++;\n        }\n    }\n\n    free(page_indices);\n    return unique_count;\n}\n\nint main(void) {\n    // Define the relocation data for the test cases.\n    const int O_A[] = {100, 4095, 4096, 8191};\n    const int I_A[] = {0, 1};\n\n    const int* O_B = NULL; // Empty set\n    const int I_B[] = {0, 400};\n\n    const int O_C[] = {0, 1, 1023};\n    const int I_C[] = {0};\n\n    const int O_D[] = {0, 5000, 9000, 16000, 32000};\n    const int I_D[] = {0, 9};\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {4096, 10, 16384, 4096, 8, 0, O_A, sizeof(O_A)/sizeof(O_A[0]), I_A, sizeof(I_A)/sizeof(I_A[0])}, // Case A\n        {4096, 5, 4096, 4096, 8, 1, O_B, 0, I_B, sizeof(I_B)/sizeof(I_B[0])}, // Case B\n        {1024, 3, 2048, 1024, 16, 1, O_C, sizeof(O_C)/sizeof(O_C[0]), I_C, sizeof(I_C)/sizeof(I_C[0])}, // Case C\n        {4096, 2, 32768, 9000, 500, 0, O_D, sizeof(O_D)/sizeof(O_D[0]), I_D, sizeof(I_D)/sizeof(I_D[0])} // Case D\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    long long results[num_cases][4];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n\n        // U_text: number of unique text pages dirtied\n        long long U_text = count_unique_pages(tc.O, tc.O_size, tc.P, 1);\n        \n        // U_got: number of unique GOT pages dirtied\n        long long U_got = count_unique_pages(tc.I, tc.I_size, tc.P, tc.E);\n        \n        // F: Failure indicator\n        long long F = (tc.sigma == 1 && U_text > 0) ? 1 : 0;\n        \n        // M_nonpic: Additional private memory for non-PIC\n        long long M_nonpic = (tc.N - 1) * (U_text + U_got) * tc.P;\n        \n        // M_pic: Additional private memory for PIC\n        long long M_pic = (tc.N - 1) * U_got * tc.P;\n        \n        // M_diff: Memory savings from using PIC\n        long long M_diff = M_nonpic - M_pic;\n\n        results[i][0] = F;\n        results[i][1] = M_nonpic;\n        results[i][2] = M_pic;\n        results[i][3] = M_diff;\n    }\n\n    // Print the results in the EXACT REQUIRED format.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%lld,%lld,%lld,%lld]\", results[i][0], results[i][1], results[i][2], results[i][3]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3636956"}, {"introduction": "The dynamic linker's predictable resolution order can be intentionally manipulated for powerful techniques like profiling, debugging, or extending application functionality without modifying the original source code. This is achieved through symbol interposition, where a custom library is loaded first to intercept function calls meant for another library. In this practice [@problem_id:3636919], you will model the detailed resolution logic, including factors like secure execution contexts and symbol visibility, to determine when interposition will succeed, clarifying how this powerful mechanism works and where its boundaries lie.", "problem": "You will implement a complete, runnable program that models dynamic linker symbol interposition for a single symbol named \"open\" under a simplified, but scientifically sound abstraction of Executable and Linkable Format (ELF) runtime resolution. The program must determine, for a fixed test suite, which object’s definition of \"open\" is chosen by the runtime linker, and whether this choice constitutes symbol interposition via the Load Preload (LD_PRELOAD) mechanism. The program must produce a single line of output encoding these results.\n\nThe fundamental base for this task is the following well-tested facts and core definitions from operating systems and dynamic linking. The dynamic linker constructs a global resolution scope with an ordered search list; earlier entries in the list provide interposition over later ones. When LD_PRELOAD is applied, its libraries are placed at the front of the search order. In secure execution contexts (for example, set-user-ID binaries inducing secure mode in the dynamic loader), environment-based preloading is ignored. A symbol definition must be globally exported with default visibility and match the required symbol version to be eligible for resolution. Hidden visibility prevents external interposition by making the symbol non-preemptable, and version mismatches are rejected.\n\nModel the runtime resolution using the following definitions. Let there be $n$ dynamically loaded objects (including the main executable). Each object is described by a tuple of attributes $(\\text{id}, \\text{is\\_main}, \\text{load\\_source}, \\text{preload\\_order}, \\text{dep\\_order}, \\text{defines}, \\text{visibility}, \\text{version})$, where:\n- $\\text{id} \\in \\mathbb{Z}$ is the identifier to report in the result (for example, $0$ for the main executable).\n- $\\text{is\\_main} \\in \\{0,1\\}$ indicates whether the object is the main executable ($1$) or not ($0$).\n- $\\text{load\\_source} \\in \\{0,1\\}$ indicates normal dependency ($0$) or LD\\_PRELOAD ($1$).\n- $\\text{preload\\_order} \\in \\mathbb{Z}$ is the position among LD\\_PRELOAD libraries (lower numbers indicate earlier in the search list); it is set to $-1$ for non-LD\\_PRELOAD objects.\n- $\\text{dep\\_order} \\in \\mathbb{Z}$ is the dependency load order among normal dependencies (lower numbers indicate earlier in the search list); it is set to $-1$ for non-dependency objects such as the main executable.\n- $\\text{defines} \\in \\{0,1\\}$ indicates whether the object defines the symbol \"open\".\n- $\\text{visibility} \\in \\{0,1\\}$ indicates default ($0$) or hidden ($1$) visibility for the symbol \"open\".\n- $\\text{version} \\in \\mathbb{Z}$ is the symbol version provided by the object for \"open\".\n\nLet the global required version be $V_{\\text{req}} \\in \\mathbb{Z}$, and let $\\text{secure} \\in \\{0,1\\}$ indicate whether secure execution is active ($1$) or not ($0$). The dynamic linker's search order is modeled as follows:\n- If $\\text{secure} = 0$, the search list begins with LD\\_PRELOAD libraries sorted by ascending $\\text{preload\\_order}$, then the main executable (the unique object with $\\text{is\\_main} = 1$), then normal dependencies sorted by ascending $\\text{dep\\_order}$.\n- If $\\text{secure} = 1$, LD\\_PRELOAD libraries are ignored, and the search list begins with the main executable, then normal dependencies sorted by ascending $\\text{dep\\_order}$.\n\nDefine the eligibility predicate $P(o)$ for an object $o$ as $P(o) = (\\text{defines} = 1) \\land (\\text{visibility} = 0) \\land (\\text{version} = V_{\\text{req}})$. The resolution function $R$ returns the $\\text{id}$ of the first object in the search list for which $P(o)$ is true, or $-1$ if no such object exists. Define the interposition indicator $I$ to be $1$ if the chosen object has $\\text{load\\_source} = 1$, and $0$ otherwise; if $R = -1$, then $I = 0$.\n\nImplement a program in the C language that hardcodes the test suite below and prints the results for all cases on a single line in the specified format. The program must not perform any file input or output, and must not rely on any operating system facilities beyond basic computation and printing. The program must compute $R$ and $I$ for each test case by constructing the search order according to the rules above and applying the predicate $P$.\n\nTest suite:\n- Case $1$ (happy path with LD\\_PRELOAD interposition):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$.\n  - Objects:\n    - Main executable $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n    - Preload library $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n    - Normal dependency $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n- Case $2$ (secure execution ignores LD\\_PRELOAD):\n  - $\\text{secure} = 1$, $V_{\\text{req}} = 10$, $n = 3$.\n  - Objects:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$.\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n- Case $3$ (hidden visibility prevents interposition):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$.\n  - Objects:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$.\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=1, \\text{version}=10)$.\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n- Case $4$ (version mismatch in LD\\_PRELOAD causes fallback):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$.\n  - Objects:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$.\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=20)$.\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n- Case $5$ (multiple LD\\_PRELOAD libraries, order determines interposition):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 4$.\n  - Objects:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n    - $L3$: $(\\text{id}=3, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=1, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n- Case $6$ (no eligible provider: boundary case):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$.\n  - Objects:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$.\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=20)$.\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=30)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain $12$ integers: for each test case $i$ from $1$ to $6$, output the chosen provider $\\text{id}$, followed by the interposition indicator. The format is $[\\text{id}_1,I_1,\\text{id}_2,I_2,\\dots,\\text{id}_6,I_6]$ with no extra whitespace or text.", "solution": "The user has provided a problem statement that requires the implementation of a computational model for dynamic linker symbol resolution. The first step is to validate the problem statement according to the specified criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe problem provides a detailed model for dynamic linking symbol resolution, defined by the following components:\n\n- **Objects**: A set of $n$ dynamically loaded objects, each described by a tuple of attributes: $(\\text{id}, \\text{is\\_main}, \\text{load\\_source}, \\text{preload\\_order}, \\text{dep\\_order}, \\text{defines}, \\text{visibility}, \\text{version})$.\n  - $\\text{id} \\in \\mathbb{Z}$: A unique identifier.\n  - $\\text{is\\_main} \\in \\{0,1\\}$: $1$ if the object is the main executable.\n  - $\\text{load\\_source} \\in \\{0,1\\}$: $1$ if loaded via `LD_PRELOAD`, $0$ otherwise.\n  - $\\text{preload\\_order} \\in \\mathbb{Z}$: Sort key for `LD_PRELOAD` libraries (lower is first), or $-1$.\n  - $\\text{dep\\_order} \\in \\mathbb{Z}$: Sort key for normal dependencies (lower is first), or $-1$.\n  - $\\text{defines} \\in \\{0,1\\}$: $1$ if the object provides the symbol \"open\".\n  - $\\text{visibility} \\in \\{0,1\\}$: $0$ for default (globally visible), $1$ for hidden.\n  - $\\text{version} \\in \\mathbb{Z}$: The version of the provided symbol.\n- **Global State**:\n  - $V_{\\text{req}} \\in \\mathbb{Z}$: The required version of the symbol.\n  - $\\text{secure} \\in \\{0,1\\}$: $1$ if secure execution mode is active.\n- **Search Order Rules**:\n  1. If $\\text{secure} = 0$: The search order is (1) `LD_PRELOAD` libraries, sorted by ascending `preload_order`; (2) the main executable; (3) normal dependencies, sorted by ascending `dep_order`.\n  2. If $\\text{secure} = 1$: `LD_PRELOAD` libraries are ignored. The search order is (1) the main executable; (2) normal dependencies, sorted by ascending `dep_order`.\n- **Eligibility Predicate**: An object $o$ is an eligible provider if the predicate $P(o)$ is true, where $P(o) = (\\text{defines} = 1) \\land (\\text{visibility} = 0) \\land (\\text{version} = V_{\\text{req}})$.\n- **Resolution Function ($R$)**: Returns the $\\text{id}$ of the *first* object in the constructed search list for which $P(o)$ is true. If no such object exists, $R$ returns $-1$.\n- **Interposition Indicator ($I$)**: $I=1$ if the resolved object has $\\text{load\\_source} = 1$. Otherwise, $I=0$. If no object is resolved ($R=-1$), $I=0$.\n- **Test Suite**: Six specific test cases are provided, enumerating all object attributes and global state variables for each case.\n- **Output Format**: A single line of text: $[\\text{id}_1,I_1,\\text{id}_2,I_2,\\dots,\\text{id}_6,I_6]$.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded**: The problem is grounded in the established principles of dynamic linking in modern operating systems like Linux (which uses ELF). The concepts of search order, `LD_PRELOAD` interposition, the effect of secure execution on preloading (e.g., for `setuid` executables), symbol visibility (`default` vs. `hidden`), and symbol versioning are all accurate, albeit simplified, representations of real-world mechanisms. The model is a sound abstraction of a complex computer science topic.\n- **Well-Posed**: The problem is well-posed. The rules for constructing the search list are explicit and cover all cases defined by the `secure` flag. The sorting criteria are unambiguous. The resolution function is precisely defined to find the *first* match, ensuring a unique solution for each test case.\n- **Objective**: The problem is stated in objective, formal language. All parameters are numerical or binary flags. The logic is based on conditional rules and a precisely defined predicate, leaving no room for subjective interpretation.\n- **Completeness and Consistency**: The problem is self-contained. All necessary data for each of the six test cases are fully specified. The rules are internally consistent and sufficient to compute the required results.\n- **Feasibility and Realism**: The model is a computational abstraction and is perfectly feasible to implement. The data provided are simple integers that present no physical or dimensional inconsistencies.\n- **Structure and Clarity**: The problem is well-structured. The terms are clearly defined (e.g., $P(o)$, $R$, $I$). The logic flows from data definition to search order construction, and finally to resolution, which is a clear and logical sequence.\n- **Substance**: The problem is not trivial. It requires careful implementation of sorting and conditional logic to correctly model the linker's behavior across different scenarios. It is a legitimate test of understanding and implementing a specified algorithm.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is a well-defined, scientifically grounded, and computationally solvable problem. I will proceed with providing a solution.\n\n### Solution\n\nThe task is to implement an algorithm that simulates the symbol resolution process of a dynamic linker based on a set of formal rules. The solution will be structured as a C program that processes a hardcoded suite of six test cases. For each case, the program must determine the resolved object's identifier, $R$, and an interposition flag, $I$.\n\n**1. Data Representation**\nWe will define C structures to represent the objects and test cases described in the problem. An `Object` structure will store the tuple of attributes for a single library or executable. A `TestCase` structure will contain the global parameters for a scenario ($V_{\\text{req}}$, $\\text{secure}$), the number of objects $n$, and an array of `Object` structures.\n\n**2. Search List Construction**\nFor each test case, the ordered search list must be constructed. This process is governed by the $\\text{secure}$ flag and involves sorting.\n- First, we partition the array of objects into three categories: `LD_PRELOAD` libraries ($\\text{load\\_source} = 1$), the main executable ($\\text{is\\_main} = 1$), and normal dependencies.\n- Next, we sort the `LD_PRELOAD` libraries based on their $\\text{preload\\_order}$ in ascending order.\n- We then sort the normal dependencies based on their $\\text{dep\\_order}$ in ascending order.\n- Finally, we assemble the final search list, which is an array of pointers to `Object`s.\n  - If $\\text{secure} = 0$, the final list is formed by concatenating the sorted `LD_PRELOAD` list, the main executable, and the sorted dependency list.\n  - If $\\text{secure} = 1$, the `LD_PRELOAD` list is omitted, and the final list is formed by concatenating the main executable and the sorted dependency list.\n\nThe C standard library function `qsort` is ideally suited for performing the required sorting operations. We will implement two comparison functions: one for `preload_order` and one for `dep_order`.\n\n**3. Symbol Resolution**\nOnce the search list is constructed, we iterate through it from the beginning to the end. For each object $o$ in the list, we evaluate the eligibility predicate $P(o) = (\\text{defines} = 1) \\land (\\text{visibility} = 0) \\land (\\text{version} = V_{\\text{req}})$.\n- The first object for which $P(o)$ evaluates to true is the winner of the resolution process. Its $\\text{id}$ is the result $R$.\n- We then determine the interposition indicator $I$. If the winning object has $\\text{load\\_source} = 1$, then $I=1$; otherwise, $I=0$.\n- If the loop completes without finding any object that satisfies $P(o)$, the resolution fails. In this case, $R$ is set to $-1$ and $I$ is set to $0$, as per the problem definition.\n\n**4. Final Output**\nAfter processing all six test cases, the program will have computed twelve integer results ($R_1, I_1, \\dots, R_6, I_6$). These results are then printed to standard output in the exact format specified: $[\\text{id}_1,I_1,\\text{id}_2,I_2,\\dots,\\text{id}_6,I_6]$, with no additional characters or whitespace.\n\nThe final program encapsulates this logic, hardcodes the test suite data, performs the calculations for each case, and prints the consolidated result.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// A struct to hold the attributes of a single dynamically loaded object.\ntypedef struct {\n    int id;\n    int is_main;\n    int load_source;\n    int preload_order;\n    int dep_order;\n    int defines;\n    int visibility;\n    int version;\n} Object;\n\n// The maximum number of objects in any single test case.\n#define MAX_OBJECTS_PER_CASE 4\n#define MAX_TEST_CASES 6\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int secure;\n    int v_req;\n    int n;\n    Object objects[MAX_OBJECTS_PER_CASE];\n} TestCase;\n\n// Comparison function for qsort to sort LD_PRELOAD libraries.\nint compare_preload_order(const void *a, const void *b) {\n    const Object *objA = *(const Object **)a;\n    const Object *objB = *(const Object **)b;\n    return objA->preload_order - objB->preload_order;\n}\n\n// Comparison function for qsort to sort normal dependencies.\nint compare_dep_order(const void *a, const void *b) {\n    const Object *objA = *(const Object **)a;\n    const Object *objB = *(const Object **)b;\n    return objA->dep_order - objB->dep_order;\n}\n\nint main(void) {\n    // Hardcode the test suite as specified in the problem statement.\n    TestCase test_cases[MAX_TEST_CASES] = {\n        // Case 1: happy path with LD_PRELOAD interposition\n        {\n            .secure = 0, .v_req = 10, .n = 3,\n            .objects = {\n                {0, 1, 0, -1, -1, 1, 0, 10}, // Main executable E\n                {1, 0, 1,  0, -1, 1, 0, 10}, // Preload library L1\n                {2, 0, 0, -1,  0, 1, 0, 10}  // Normal dependency L2\n            }\n        },\n        // Case 2: secure execution ignores LD_PRELOAD\n        {\n            .secure = 1, .v_req = 10, .n = 3,\n            .objects = {\n                {0, 1, 0, -1, -1, 0, 0,  0}, // Main executable E\n                {1, 0, 1,  0, -1, 1, 0, 10}, // Preload library L1\n                {2, 0, 0, -1,  0, 1, 0, 10}  // Normal dependency L2\n            }\n        },\n        // Case 3: hidden visibility prevents interposition\n        {\n            .secure = 0, .v_req = 10, .n = 3,\n            .objects = {\n                {0, 1, 0, -1, -1, 0, 0,  0}, // Main executable E\n                {1, 0, 1,  0, -1, 1, 1, 10}, // Preload library L1\n                {2, 0, 0, -1,  0, 1, 0, 10}  // Normal dependency L2\n            }\n        },\n        // Case 4: version mismatch in LD_PRELOAD causes fallback\n        {\n            .secure = 0, .v_req = 10, .n = 3,\n            .objects = {\n                {0, 1, 0, -1, -1, 0, 0,  0}, // Main executable E\n                {1, 0, 1,  0, -1, 1, 0, 20}, // Preload library L1\n                {2, 0, 0, -1,  0, 1, 0, 10}  // Normal dependency L2\n            }\n        },\n        // Case 5: multiple LD_PRELOAD libraries, order determines interposition\n        {\n            .secure = 0, .v_req = 10, .n = 4,\n            .objects = {\n                {0, 1, 0, -1, -1, 1, 0, 10}, // Main executable E\n                {3, 0, 1,  0, -1, 1, 0, 10}, // Preload library L3\n                {1, 0, 1,  1, -1, 1, 0, 10}, // Preload library L1\n                {2, 0, 0, -1,  0, 1, 0, 10}  // Normal dependency L2\n            }\n        },\n        // Case 6: no eligible provider\n        {\n            .secure = 0, .v_req = 10, .n = 3,\n            .objects = {\n                {0, 1, 0, -1, -1, 0, 0,  0}, // Main executable E\n                {1, 0, 1,  0, -1, 1, 0, 20}, // Preload library L1\n                {2, 0, 0, -1,  0, 1, 0, 30}  // Normal dependency L2\n            }\n        }\n    };\n\n    int results[MAX_TEST_CASES * 2];\n\n    for (int i = 0; i < MAX_TEST_CASES; ++i) {\n        TestCase *tc = &test_cases[i];\n\n        // Storage for search list and categorized object pointers\n        const Object *search_list[MAX_OBJECTS_PER_CASE];\n        int search_list_size = 0;\n\n        const Object *preload_libs[MAX_OBJECTS_PER_CASE];\n        int preload_count = 0;\n        const Object *main_exec = NULL;\n        const Object *deps[MAX_OBJECTS_PER_CASE];\n        int dep_count = 0;\n\n        // Partition objects into categories\n        for (int j = 0; j < tc->n; ++j) {\n            const Object *obj = &(tc->objects[j]);\n            if (obj->load_source == 1) {\n                preload_libs[preload_count++] = obj;\n            } else if (obj->is_main == 1) {\n                main_exec = obj;\n            } else {\n                deps[dep_count++] = obj;\n            }\n        }\n\n        // Sort preload libraries and dependencies\n        if (preload_count > 1) {\n            qsort(preload_libs, preload_count, sizeof(Object *), compare_preload_order);\n        }\n        if (dep_count > 1) {\n            qsort(deps, dep_count, sizeof(Object *), compare_dep_order);\n        }\n\n        // Assemble the final search list based on the secure flag\n        if (tc->secure == 0) {\n            for (int k = 0; k < preload_count; ++k) search_list[search_list_size++] = preload_libs[k];\n        }\n        if (main_exec != NULL) search_list[search_list_size++] = main_exec;\n        for (int k = 0; k < dep_count; ++k) search_list[search_list_size++] = deps[k];\n\n        // Perform resolution\n        int resolved_id = -1;\n        int interposed = 0;\n        for (int k = 0; k < search_list_size; ++k) {\n            const Object* current_obj = search_list[k];\n            // Eligibility Predicate: P(o)\n            if (current_obj->defines == 1 && current_obj->visibility == 0 && current_obj->version == tc->v_req) {\n                resolved_id = current_obj->id;\n                if (current_obj->load_source == 1) {\n                    interposed = 1;\n                }\n                break; // First match wins\n            }\n        }\n\n        results[i * 2] = resolved_id;\n        results[i * 2 + 1] = interposed;\n    }\n\n    // Print the results in the EXACT required format.\n    printf(\"[\");\n    for (int i = 0; i < MAX_TEST_CASES; ++i) {\n        printf(\"%d,%d\", results[i * 2], results[i * 2 + 1]);\n        if (i < MAX_TEST_CASES - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3636919"}]}