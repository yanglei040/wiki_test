{"hands_on_practices": [{"introduction": "Before we can understand how memory becomes fragmented on a large scale, we must first examine the anatomy of a single allocated block. This exercise [@problem_id:3637495] delves into the concept of internal fragmentation, the memory wasted within a block due to metadata and alignment rules. By meticulously accounting for headers, footers, and padding, you will quantify the hidden costs of memory management and appreciate the trade-offs involved in allocator design.", "problem": "A dynamic memory allocator used in an operating systems course implements blocks with explicit metadata and strict alignment. Each allocated block contains a header of size $h$ immediately preceding the payload and a footer of size $f$ immediately following the payload. The allocator must ensure that the start address of each payload is aligned to an alignment quantum $a$. The allocator operates on an initially empty heap whose base address is aligned to $a$, and it places blocks sequentially with no gaps between consecutive blocks. To maintain payload alignment for all subsequent allocations, the allocator may insert the minimal nonnegative number of bytes of padding immediately after the header and may add the minimal nonnegative number of bytes of padding at the end of the block so that the total block size is a multiple of $a$.\n\nUse the following parameters: header size $h = 12$ bytes, footer size $f = 4$ bytes, alignment quantum $a = 16$ bytes. Consider a sequence of $5$ allocation requests with payload sizes $\\{s_1, s_2, s_3, s_4, s_5\\} = \\{13, 64, 7, 33, 2\\}$ bytes.\n\nStarting from the fundamental definitions that (i) internal fragmentation for a block is the number of bytes within the block that are not part of the requested payload and (ii) alignment means the payload start address is congruent to $0$ modulo $a$, determine the total number of bytes across all $5$ blocks that do not belong to any payload and are due solely to the metadata and the alignment padding interactions described (i.e., count all header and footer bytes, any padding inserted before the payload to achieve alignment, and any padding at the end of the block to round the block size up to a multiple of $a$).\n\nExpress your final answer as an integer number of bytes. No rounding is required. Units in the final numeric answer should be bytes.", "solution": "The problem statement has been validated and is deemed to be scientifically grounded, well-posed, and objective. It provides a complete and consistent set of parameters and constraints to solve a standard problem in the study of dynamic memory allocation for operating systems.\n\nThe problem requires the calculation of the total non-payload bytes for a sequence of $5$ memory allocations. These non-payload bytes comprise the block's metadata (header and footer) and any padding required to satisfy alignment constraints.\n\nThe given parameters are:\n- Header size: $h = 12$ bytes\n- Footer size: $f = 4$ bytes\n- Alignment quantum: $a = 16$ bytes\n- Sequence of $5$ requested payload sizes: $\\{s_1, s_2, s_3, s_4, s_5\\} = \\{13, 64, 7, 33, 2\\}$ bytes.\n\nLet's analyze the structure of a single allocated block. A block consists of a header, optional pre-payload padding, the payload itself, a footer, and optional post-payload padding. The total size of each block, including all components, must be a multiple of the alignment quantum $a$.\n\nThe allocator places blocks sequentially, starting from a heap base address that is aligned to $a$. Let the start address of block $i$ be $B_i$.\nFor the first block, $B_1$ is the heap base address, so $B_1 \\equiv 0 \\pmod a$.\nThe total size of any block $i$, which we denote $S_i$, is required to be a multiple of $a$. The next block, block $i+1$, will start at address $B_{i+1} = B_i + S_i$. Since $B_i$ is a multiple of $a$ and $S_i$ is a multiple of $a$, $B_{i+1}$ will also be a multiple of $a$. By induction, the start address $B_i$ of every block is aligned to the quantum $a$.\n\nNow, let's determine the components of a block for a given payload size $s_i$.\n1.  **Header**: The block starts at address $B_i$ with a header of size $h$. The header ends at address $B_i + h - 1$.\n2.  **Pre-payload Padding**: The payload must start at an address $P_i$ that is a multiple of $a$. This address must be greater than or equal to the address immediately following the header, which is $B_i + h$. Since $B_i \\equiv 0 \\pmod a$, we need to find the smallest multiple of $a$ that is greater than or equal to $B_i + h$. This is equivalent to finding the smallest amount of non-negative padding, $p_{\\text{pre},i}$, to add to $h$ such that $h + p_{\\text{pre},i}$ is a multiple of $a$. This padding is constant for all blocks as it only depends on $h$ and $a$.\n    The amount of pre-payload padding is given by the formula $(a - (h \\pmod a)) \\pmod a$.\n    Substituting the given values:\n    $$p_{\\text{pre}} = (16 - (12 \\pmod{16})) \\pmod{16} = (16 - 12) \\pmod{16} = 4 \\text{ bytes}$$\n    So, for every block, $4$ bytes of padding are inserted between the header and the payload. The payload for block $i$ starts at address $P_i = B_i + h + p_{\\text{pre}} = B_i + 12 + 4 = B_i + 16$, which is aligned to $a$.\n\n3.  **Payload and Footer**: The payload of size $s_i$ is placed, followed by a footer of size $f$.\n\n4.  **Total Block Size and Post-payload Padding**: The size of the block up to this point, before final rounding, is the sum of the sizes of the header, pre-payload padding, payload, and footer. Let's call this unrounded size $U_i$.\n    $$U_i = h + p_{\\text{pre}} + s_i + f = 12 + 4 + s_i + 4 = 20 + s_i$$\n    The total size of the block, $S_i$, must be the smallest multiple of $a$ that is greater than or equal to $U_i$. This is calculated by rounding $U_i$ up to the nearest multiple of $a$.\n    $$S_i = a \\cdot \\left\\lceil \\frac{U_i}{a} \\right\\rceil = 16 \\cdot \\left\\lceil \\frac{20 + s_i}{16} \\right\\rceil$$\n    The post-payload padding is $p_{\\text{post},i} = S_i - U_i$.\n\nThe quantity of interest for each block is the number of non-payload bytes, $N_i$. This is the total size of the block minus the payload size.\n$$N_i = S_i - s_i$$\nThis is equivalent to the sum of the sizes of the header, footer, and both padding sections: $N_i = h + f + p_{\\text{pre}} + p_{\\text{post},i}$.\n\nWe now compute $N_i$ for each of the $5$ allocation requests.\n\n**Block 1:** $s_1 = 13$ bytes\n- Unrounded size: $U_1 = 20 + 13 = 33$ bytes.\n- Total block size: $S_1 = 16 \\cdot \\lceil \\frac{33}{16} \\rceil = 16 \\cdot 3 = 48$ bytes.\n- Non-payload bytes: $N_1 = S_1 - s_1 = 48 - 13 = 35$ bytes.\n\n**Block 2:** $s_2 = 64$ bytes\n- Unrounded size: $U_2 = 20 + 64 = 84$ bytes.\n- Total block size: $S_2 = 16 \\cdot \\lceil \\frac{84}{16} \\rceil = 16 \\cdot 6 = 96$ bytes.\n- Non-payload bytes: $N_2 = S_2 - s_2 = 96 - 64 = 32$ bytes.\n\n**Block 3:** $s_3 = 7$ bytes\n- Unrounded size: $U_3 = 20 + 7 = 27$ bytes.\n- Total block size: $S_3 = 16 \\cdot \\lceil \\frac{27}{16} \\rceil = 16 \\cdot 2 = 32$ bytes.\n- Non-payload bytes: $N_3 = S_3 - s_3 = 32 - 7 = 25$ bytes.\n\n**Block 4:** $s_4 = 33$ bytes\n- Unrounded size: $U_4 = 20 + 33 = 53$ bytes.\n- Total block size: $S_4 = 16 \\cdot \\lceil \\frac{53}{16} \\rceil = 16 \\cdot 4 = 64$ bytes.\n- Non-payload bytes: $N_4 = S_4 - s_4 = 64 - 33 = 31$ bytes.\n\n**Block 5:** $s_5 = 2$ bytes\n- Unrounded size: $U_5 = 20 + 2 = 22$ bytes.\n- Total block size: $S_5 = 16 \\cdot \\lceil \\frac{22}{16} \\rceil = 16 \\cdot 2 = 32$ bytes.\n- Non-payload bytes: $N_5 = S_5 - s_5 = 32 - 2 = 30$ bytes.\n\nThe total number of non-payload bytes across all $5$ blocks is the sum of the individual non-payload amounts:\n$$N_{\\text{total}} = N_1 + N_2 + N_3 + N_4 + N_5$$\n$$N_{\\text{total}} = 35 + 32 + 25 + 31 + 30$$\n$$N_{\\text{total}} = 153 \\text{ bytes}$$", "answer": "$$\\boxed{153}$$", "id": "3637495"}, {"introduction": "While internal fragmentation wastes space within blocks, external fragmentation wastes space *between* them. This hands-on coding practice [@problem_id:3239139] challenges you to build a first-fit memory manager and then craft a workload that deliberately triggers worst-case fragmentation. By programming the logic of allocation, splitting, and coalescing, you will gain a powerful, practical insight into how a heap can fail even when total free space seems plentiful.", "problem": "Design and implement a simulated heap memory manager that uses the first-fit strategy to satisfy allocation requests. The heap is modeled as a contiguous array of addresses partitioned into blocks. Each block has a size measured in abstract units and a state indicating whether it is allocated or free. The allocator must implement block splitting on allocation and coalescing of adjacent free blocks on deallocation. The first-fit strategy searches blocks from the beginning of the heap and selects the first free block whose size is at least the requested size. If the selected free block is larger than the requested size, it is split into one allocated block of the requested size and one residual free block representing the remaining capacity. If a block is exactly the requested size, it is simply marked as allocated without splitting.\n\nFoundational base:\n- Heap memory is a contiguous address space; contiguous allocation requests require a single uninterrupted range of addresses.\n- First-fit is a widely used heap allocation strategy: a request of size $s$ scans the free list from the beginning until it finds the first free block with size at least $s$ and places the allocation there.\n- External fragmentation is the phenomenon where the total free memory is sufficient to satisfy a request but cannot be used because the free memory is split across multiple non-contiguous blocks. A quantitative external fragmentation measure in this problem is the count of maximal contiguous free regions (free blocks) and the size of the largest such region.\n\nYou must:\n- Implement a first-fit allocator with the following operations:\n  - Allocate a block of size $s$ if a suitable free block exists. Return a handle (an identifier) that uniquely refers to the allocated block. If no suitable free block exists, the allocation fails.\n  - Free a previously allocated block by its handle, and coalesce it with adjacent free blocks, if any, to restore maximal contiguous free regions.\n- Use exact integer sizes for all blocks. There are no physical units in this problem.\n- Provide functions that compute the following metrics at any point:\n  - The number of free blocks (each block is a maximal contiguous free region).\n  - The size of the largest free block.\n  - The total free memory, computed as the sum of sizes of all free blocks.\n- Implement a test that tries a final allocation of size $s^\\ast$ (after a specific sequence of allocations and deallocations), reports whether it would succeed under first-fit, and then immediately reverses that attempt such that the heap returns to its prior state.\n\nCore requirement regarding worst-case external fragmentation:\n- Construct a sequence of $N$ requests that yields worst-case external fragmentation of order $O(N)$ under first-fit. Specifically, for a heap of capacity at least $3N$ units, perform $2N$ allocations each of size $1$, then free every other allocated block among these $2N$ blocks (for example, free the blocks at positions $0,2,4,\\ldots,2N-2$ in the allocation order). This produces $N$ free blocks of size $1$ interleaved with $N$ allocated blocks of size $1$, with no adjacency between free blocks, so coalescing cannot reduce their count. After this pattern, attempt to allocate a single block of size $N$ and report whether the allocation would succeed.\n\nTest suite:\n- Case $1$: Heap size $30$, $N=10$. Execute the $O(N)$ fragmentation construction described above. Attempt a final allocation of size $10$.\n- Case $2$: Heap size $3$, $N=1$. Execute the same construction, then attempt a final allocation of size $1$.\n- Case $3$: Heap size $12$. Allocate $12$ blocks each of size $1$, free all of them, and then attempt a final allocation of size $12$.\n- Case $4$: Heap size $20$. Sequentially allocate blocks with sizes $[3,2,5,2,3,2,1,2]$, then free the $2$-nd, $4$-th, $6$-th, and $8$-th allocated blocks (these have sizes $2,2,2,2$), and attempt a final allocation of size $5$.\n\nFor each test case, produce the following result list in the exact order:\n- The number of free blocks (an integer).\n- The size of the largest free block (an integer).\n- The total free memory (an integer).\n- Whether the final attempted allocation would succeed (a boolean value).\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each test case result is itself a comma-separated list enclosed in square brackets. For instance, the output should look like $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$, with no spaces.\n\nYour implementation must be self-contained and deterministic, requiring no input and producing exactly one line that conforms to the specified format.", "solution": "The problem statement is formally valid. It is scientifically grounded in the principles of computer science, specifically dynamic memory management algorithms. The problem is well-posed, with all necessary data, constraints, and definitions provided for a deterministic simulation. The language is objective and unambiguous. We may, therefore, proceed with a solution.\n\nThe design of a simulated heap memory manager based on the first-fit strategy requires a data structure that can efficiently represent the partitioning of memory into free and allocated blocks, and support the operations of allocation (with block splitting) and deallocation (with block coalescing).\n\nA doubly linked list is an exemplary data structure for this purpose. Each node in the list represents a contiguous block of memory. The use of pointers to the previous and next blocks in memory order allows for efficient traversal and, critically, for constant-time access to adjacent blocks, which is essential for the coalescing operation during deallocation.\n\nEach block in our model will be an object with the following attributes:\n- `s`: An integer representing the size of the block.\n- `is_free`: A boolean flag, `True` if the block is available for allocation and `False` otherwise.\n- `start_addr`: The starting address (offset) of the block within the heap, providing a unique spatial reference.\n- `prev_block`: A reference to the logically preceding block in the heap's memory space.\n- `next_block`: A reference to the logically succeeding block in the heap's memory space.\n\nThe heap manager itself is initialized with a single free block spanning the entire heap capacity. Allocations are tracked using a dictionary that maps a unique integer handle, returned upon successful allocation, to the corresponding block object.\n\nThe core operations are implemented as follows:\n\n**1. Allocation (`allocate(s)`)**\nThe first-fit algorithm mandates a linear scan of the heap from the beginning. We traverse the doubly linked list of blocks, starting from the head, searching for the first block `b` that satisfies two conditions: `b.is_free` is `True`, and its size `b.s` is greater than or equal to the requested size `s`.\n\n- If no such block is found, the available memory is too fragmented or insufficient, and the allocation request fails.\n- If a suitable block `b` is found:\n    - **Exact Fit**: If `b.s = s`, the block is simply marked as allocated (`b.is_free = False`). No structural change to the list is needed.\n    - **Splitting**: If `b.s > s`, the block must be split. The original block `b` is resized to size `s` and marked as allocated. A new free block is created immediately following it in the list, with size `b.s - s`. This operation involves updating the pointers of `b` and its original successor to insert the new residual free block, maintaining the integrity of the doubly linked list.\n\nA unique handle is generated and associated with the allocated block, which is then returned to the caller.\n\n**2. Deallocation (`free(handle)`)**\nDeallocation begins by using the provided `handle` to retrieve the block to be freed. The block's state is changed to `is_free = True`. The crucial step is coalescing, which counters external fragmentation by merging adjacent free blocks into a single, larger free block.\n\nUpon freeing a block `B`, we inspect its neighbors—the previous block `A` and the next block `C`.\n- If `C` exists and is free, `B` and `C` are merged. This is achieved by adding `C`'s size to `B`'s size and updating `B`'s `next_block` pointer to bypass `C`, effectively removing `C` from the list.\n- Subsequently, if `A` exists and is free, the now potentially larger block `B` is merged into `A`. This is done by adding `B`'s size to `A`'s size and updating `A`'s `next_block` pointer to bypass `B`.\n\nThis two-way check ensures that a newly freed block is merged with any and all adjacent free neighbors, restoring the maximal possible contiguous free space at that location.\n\n**3. Metrics and Testing**\nThe required metrics—number of free blocks, size of the largest free block, and total free memory—are computed by straightforward traversals of the linked list, accumulating counts, maximums, and sums for blocks where `is_free` is `True`.\n\nThe function to test a potential allocation of size $s^\\ast$ is implemented transactionally. It first attempts the allocation using the standard `allocate` method. If the allocation fails, it returns `False`. If it succeeds, it obtains a handle, returns `True`, and immediately calls the `free` method with that handle. As established in our design, the `free` operation, with its included coalescing logic, correctly reverses the state changes made by a splitting or exact-fit allocation, thereby restoring the heap to its precise state before the test.\n\nThe provided test cases are designed to validate specific aspects of the allocator's behavior. Case 3 demonstrates perfect coalescing. Case 4 exemplifies external fragmentation, where total free memory exceeds the request size, yet the allocation fails. Cases 1 and 2 construct a specific worst-case fragmentation pattern for the first-fit algorithm, where numerous small, non-contiguous free blocks render the allocator unable to satisfy a large request despite ample total free space. Our implementation correctly simulates these phenomena.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the heap memory manager simulation problem.\n    \"\"\"\n\n    class Block:\n        \"\"\"Represents a block of memory in the heap.\"\"\"\n        def __init__(self, size, start_addr):\n            self.size = size\n            self.is_free = True\n            self.start_addr = start_addr\n            self.prev_block = None\n            self.next_block = None\n\n        def __repr__(self):\n            state = \"F\" if self.is_free else \"A\"\n            return f\"[{state}({self.size})@{self.start_addr}]\"\n\n    class HeapManager:\n        \"\"\"Implements a first-fit heap memory manager.\"\"\"\n        def __init__(self, total_size):\n            self.total_size = total_size\n            self.head = Block(total_size, 0)\n            self.allocations = {}\n            self.next_handle = 1\n\n        def allocate(self, req_size):\n            \"\"\"Allocates a block of memory using first-fit strategy.\"\"\"\n            if req_size = 0:\n                return None\n            \n            current_block = self.head\n            while current_block:\n                if current_block.is_free and current_block.size >= req_size:\n                    # Found a suitable block\n                    if current_block.size > req_size:\n                        # Split the block\n                        new_free_block = Block(\n                            size=current_block.size - req_size,\n                            start_addr=current_block.start_addr + req_size\n                        )\n                        new_free_block.prev_block = current_block\n                        new_free_block.next_block = current_block.next_block\n                        \n                        if current_block.next_block:\n                            current_block.next_block.prev_block = new_free_block\n                        \n                        current_block.size = req_size\n                        current_block.next_block = new_free_block\n\n                    # Mark the block as allocated\n                    current_block.is_free = False\n                    handle = self.next_handle\n                    self.allocations[handle] = current_block\n                    self.next_handle += 1\n                    return handle\n\n                current_block = current_block.next_block\n            \n            return None # Allocation failed\n\n        def free(self, handle):\n            \"\"\"Frees a previously allocated block and coalesces neighbors.\"\"\"\n            if handle not in self.allocations:\n                return\n\n            block_to_free = self.allocations.pop(handle)\n            block_to_free.is_free = True\n\n            # Coalesce with next block\n            if block_to_free.next_block and block_to_free.next_block.is_free:\n                next_b = block_to_free.next_block\n                block_to_free.size += next_b.size\n                block_to_free.next_block = next_b.next_block\n                if next_b.next_block:\n                    next_b.next_block.prev_block = block_to_free\n\n            # Coalesce with previous block\n            if block_to_free.prev_block and block_to_free.prev_block.is_free:\n                prev_b = block_to_free.prev_block\n                prev_b.size += block_to_free.size\n                prev_b.next_block = block_to_free.next_block\n                if block_to_free.next_block:\n                    block_to_free.next_block.prev_block = prev_b\n        \n        def get_metrics(self):\n            \"\"\"Computes the required heap metrics.\"\"\"\n            num_free_blocks = 0\n            max_free_block_size = 0\n            total_free_memory = 0\n            \n            current_block = self.head\n            while current_block:\n                if current_block.is_free:\n                    num_free_blocks += 1\n                    total_free_memory += current_block.size\n                    if current_block.size > max_free_block_size:\n                        max_free_block_size = current_block.size\n                current_block = current_block.next_block\n            \n            return num_free_blocks, max_free_block_size, total_free_memory\n\n        def test_allocate(self, req_size):\n            \"\"\"Tests if an allocation would succeed and reverts the heap state.\"\"\"\n            handle = self.allocate(req_size)\n            if handle is None:\n                return False\n            else:\n                self.free(handle)\n                return True\n\n    all_results = []\n\n    # Case 1\n    heap1 = HeapManager(30)\n    n1 = 10\n    handles1 = [heap1.allocate(1) for _ in range(2 * n1)]\n    for i in range(0, 2 * n1, 2):\n        heap1.free(handles1[i])\n    metrics1 = heap1.get_metrics()\n    success1 = heap1.test_allocate(10)\n    all_results.append([*metrics1, success1])\n\n    # Case 2\n    heap2 = HeapManager(3)\n    n2 = 1\n    handles2 = [heap2.allocate(1) for _ in range(2 * n2)]\n    for i in range(0, 2 * n2, 2):\n        heap2.free(handles2[i])\n    metrics2 = heap2.get_metrics()\n    success2 = heap2.test_allocate(1)\n    all_results.append([*metrics2, success2])\n    \n    # Case 3\n    heap3 = HeapManager(12)\n    handles3 = [heap3.allocate(1) for _ in range(12)]\n    for handle in handles3:\n        heap3.free(handle)\n    metrics3 = heap3.get_metrics()\n    success3 = heap3.test_allocate(12)\n    all_results.append([*metrics3, success3])\n\n    # Case 4\n    heap4 = HeapManager(20)\n    alloc_sizes = [3, 2, 5, 2, 3, 2, 1, 2]\n    handles4 = [heap4.allocate(size) for size in alloc_sizes]\n    handles_to_free_indices = [1, 3, 5, 7] # 2nd, 4th, 6th, 8th (0-indexed)\n    for index in handles_to_free_indices:\n        heap4.free(handles4[index])\n    metrics4 = heap4.get_metrics()\n    success4 = heap4.test_allocate(5)\n    all_results.append([*metrics4, success4])\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3239139"}, {"introduction": "When external fragmentation becomes severe, an operating system can resort to a more drastic measure: memory compaction. This practice [@problem_id:3637454] puts you in the role of an OS designer tasked with evaluating this strategy. You will calculate the tangible benefit of compaction by quantifying the reduction in fragmentation, and weigh it against the performance cost of relocating all live data in memory.", "problem": "An Operating System (OS) manages a contiguous Random Access Memory (RAM) region of total size $64$ MiB, with byte addresses measured from a base address $0$. The memory currently contains the following live allocations, specified by their starting offsets (in MiB from the base) and sizes (in MiB):\nAllocation $A_{1}$: start $4$, size $6$; allocation $A_{2}$: start $12$, size $8$; allocation $A_{3}$: start $22$, size $2$; allocation $A_{4}$: start $28$, size $10$; allocation $A_{5}$: start $40$, size $5$; allocation $A_{6}$: start $48$, size $4$; allocation $A_{7}$: start $56$, size $3$.\n\nAll other memory is free. The free intervals (in MiB) are $[0,4)$, $[10,12)$, $[20,22)$, $[24,28)$, $[38,40)$, $[45,48)$, $[52,56)$, and $[59,64)$.\n\nStarting from the fundamental definitions of external fragmentation in dynamic storage allocation and the definition of data-transfer bandwidth, design a compaction strategy that relocates all live allocations to form a single contiguous free region, preserving allocation order by non-decreasing original starting offsets and ensuring no overlap during relocation. Under this strategy, determine:\n\n1. The relocation cost $R$, defined as the total time in seconds required to complete compaction, assuming a uniform relocation bandwidth $B = 64 \\times 2^{20}$ bytes per second. Express $R$ in seconds.\n\n2. The reduction in external fragmentation $\\Delta F$, where the fragmentation metric $F$ is defined as the fraction of the total free memory that is not part of the largest contiguous free block, i.e., $F = 1 - \\frac{\\text{size of largest free block}}{\\text{total free memory}}$. Compute $\\Delta F = F_{\\text{before}} - F_{\\text{after}}$ as a pure number (dimensionless).\n\nProvide exact values for $R$ and $\\Delta F$; do not round. The final answer must be given as a row matrix containing $R$ and $\\Delta F$.", "solution": "The problem statement has been validated and is deemed to be self-contained, scientifically grounded, and well-posed. All provided data are consistent and sufficient for deriving a unique solution. The concepts of memory compaction, external fragmentation, and data transfer bandwidth are standard topics in operating systems, and their definitions within the problem are formal and unambiguous. We may therefore proceed with the solution.\n\nThe problem asks for two quantities: the relocation cost $R$ and the reduction in external fragmentation $\\Delta F$. We will address each in turn.\n\nFirst, we verify the memory layout. The total RAM size is $S_{RAM} = 64$ MiB.\nThe live allocations are:\n$A_{1}$: start $4$ MiB, size $6$ MiB $\\rightarrow$ interval $[4, 10)$\n$A_{2}$: start $12$ MiB, size $8$ MiB $\\rightarrow$ interval $[12, 20)$\n$A_{3}$: start $22$ MiB, size $2$ MiB $\\rightarrow$ interval $[22, 24)$\n$A_{4}$: start $28$ MiB, size $10$ MiB $\\rightarrow$ interval $[28, 38)$\n$A_{5}$: start $40$ MiB, size $5$ MiB $\\rightarrow$ interval $[40, 45)$\n$A_{6}$: start $48$ MiB, size $4$ MiB $\\rightarrow$ interval $[48, 52)$\n$A_{7}$: start $56$ MiB, size $3$ MiB $\\rightarrow$ interval $[56, 59)$\n\nThe total size of allocated memory is the sum of the sizes of all allocations:\n$$S_{alloc} = 6 + 8 + 2 + 10 + 5 + 4 + 3 = 38 \\text{ MiB}$$\n\nThe free intervals are given as $[0,4)$, $[10,12)$, $[20,22)$, $[24,28)$, $[38,40)$, $[45,48)$, $[52,56)$, and $[59,64)$.\nThe total size of free memory is the sum of the sizes of these free blocks:\n$$S_{free} = (4-0) + (12-10) + (22-20) + (28-24) + (40-38) + (48-45) + (56-52) + (64-59)$$\n$$S_{free} = 4 + 2 + 2 + 4 + 2 + 3 + 4 + 5 = 26 \\text{ MiB}$$\n\nThe sum of allocated and free memory is $S_{alloc} + S_{free} = 38 + 26 = 64$ MiB, which matches the total RAM size, confirming the consistency of the provided data.\n\n**1. Calculation of Relocation Cost $R$**\n\nThe compaction strategy is to relocate all live allocations to form a single contiguous block at the beginning of the memory region (starting at address $0$), preserving their relative order. The cost of relocation, $R$, is the total time required to move the data. This time is determined by the total amount of data moved and the memory bandwidth.\n\nThe strategy dictates that after compaction, the allocations will be packed contiguously starting from address $0$. The new layout will be:\n$A_{1}$ at $[0, 6)$\n$A_{2}$ at $[6, 14)$\n$A_{3}$ at $[14, 16)$\n$A_{4}$ at $[16, 26)$\n$A_{5}$ at $[26, 31)$\n$A_{6}$ at $[31, 35)$\n$A_{7}$ at $[35, 38)$\n\nThe original starting address of the first allocation, $A_{1}$, is $4$ MiB, not $0$ MiB. Therefore, $A_{1}$ must be moved to its new position at address $0$. To maintain contiguity and the relative ordering, all subsequent allocations must also be moved to their new positions. The total amount of data to be relocated is thus the sum of the sizes of all live allocations.\n\nTotal data to move = $S_{alloc} = 38$ MiB.\nTo calculate the time, we must express the data size and bandwidth in consistent units.\n$1$ MiB = $2^{20}$ bytes.\nTotal data to move = $38 \\times 2^{20}$ bytes.\n\nThe given relocation bandwidth is $B = 64 \\times 2^{20}$ bytes per second.\n\nThe relocation cost $R$ is the ratio of the total data moved to the bandwidth:\n$$R = \\frac{\\text{Total data to move}}{B} = \\frac{38 \\times 2^{20} \\text{ bytes}}{64 \\times 2^{20} \\text{ bytes/s}}$$\nThe term $2^{20}$ cancels out:\n$$R = \\frac{38}{64} = \\frac{19}{32} \\text{ seconds}$$\n\n**2. Calculation of the Reduction in External Fragmentation $\\Delta F$**\n\nThe fragmentation metric is defined as $F = 1 - \\frac{\\text{size of largest free block}}{\\text{total free memory}}$. The reduction in fragmentation is $\\Delta F = F_{\\text{before}} - F_{\\text{after}}$.\n\nFirst, we calculate $F_{\\text{before}}$.\nThe sizes of the free blocks before compaction are $4$, $2$, $2$, $4$, $2$, $3$, $4$, and $5$ MiB.\nThe size of the largest free block is the maximum of these values:\n$$\\text{size of largest free block}_{\\text{before}} = \\max(\\{4, 2, 2, 4, 2, 3, 4, 5\\}) = 5 \\text{ MiB}$$\nThe total free memory is $S_{free} = 26$ MiB.\n$$F_{\\text{before}} = 1 - \\frac{5 \\text{ MiB}}{26 \\text{ MiB}} = 1 - \\frac{5}{26} = \\frac{21}{26}$$\n\nNext, we calculate $F_{\\text{after}}$.\nAfter compaction, all allocated blocks form a single contiguous segment of size $S_{alloc} = 38$ MiB at the beginning of memory. This leaves all the free space consolidated into a single contiguous block at the end of memory.\nThe size of this single free block is equal to the total free memory, $S_{free} = 26$ MiB.\nTherefore, the size of the largest free block after compaction is $26$ MiB.\n$$F_{\\text{after}} = 1 - \\frac{26 \\text{ MiB}}{26 \\text{ MiB}} = 1 - 1 = 0$$\n\nFinally, we compute the reduction in fragmentation, $\\Delta F$:\n$$\\Delta F = F_{\\text{before}} - F_{\\text{after}} = \\frac{21}{26} - 0 = \\frac{21}{26}$$\n\nThe two required values are $R = \\frac{19}{32}$ and $\\Delta F = \\frac{21}{26}$.", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{19}{32}  \\frac{21}{26} \\end{pmatrix}}$$", "id": "3637454"}]}