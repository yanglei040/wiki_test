{"hands_on_practices": [{"introduction": "Linked allocation trades contiguous space for flexibility, but this comes at the cost of sacrificing some capacity in every block for a pointer. This exercise guides you through quantifying this overhead, which is a form of internal fragmentation. By deriving a threshold for acceptable overhead, you will develop a concrete understanding of the interplay between block size and pointer size—a critical consideration in file system design [@problem_id:3653104].", "problem": "A file system uses linked allocation, where each disk block has a total size of $B$ bytes. In each block, a single pointer of size $p$ bytes is stored to locate the next block in the file, and the remainder of the block is used for file data. Assume that this pointer field is present in every block. The pointer bytes are considered metadata, and the ratio of metadata to useful payload is defined as the pointer overhead fraction. A system design constraint requires that, for each block, the pointer overhead must not exceed a specified fraction $\\theta$ of the useful data stored in that block.\n\nStarting from the definitions that:\n- useful data per block equals total bytes minus metadata bytes, and\n- the pointer overhead fraction is defined as the ratio of metadata bytes to useful data bytes,\n\nderive, from first principles, a closed-form expression for the threshold block size $B_{\\text{threshold}}$ (in terms of $p$ and $\\theta$) at which the pointer overhead equals the allowable fraction $\\theta$. Interpret this threshold as the boundary such that for any block size $B$ smaller than $B_{\\text{threshold}}$, the overhead per block exceeds $\\theta$ times the useful data, and for any $B$ greater than or equal to $B_{\\text{threshold}}$, the overhead per block is at most $\\theta$ times the useful data. Assume $B>p$ and $\\theta>0$.\n\nExpress your final answer as a closed-form analytic expression in bytes, in terms of $p$ and $\\theta$ only. Do not substitute numerical values and do not include units inside the final boxed answer.", "solution": "The problem requires the derivation of a closed-form expression for a threshold block size, $B_{\\text{threshold}}$, in a linked-allocation file system. The derivation must start from first principles as defined in the problem statement.\n\nLet the total size of a disk block be $B$ bytes.\nLet the size of the pointer stored in each block be $p$ bytes. This pointer constitutes the metadata.\nLet the maximum allowable pointer overhead fraction be $\\theta$. We are given the assumptions that $B > p$ and $\\theta > 0$.\n\nFirst, we formalize the definitions provided in the problem statement.\n\nLet $M$ be the size of the metadata in a single block. According to the problem, this consists solely of the pointer.\n$$M = p$$\n\nLet $D$ be the amount of useful data stored in a single block. The problem defines this as the total block size minus the metadata bytes.\n$$D = B - M$$\nSubstituting the expression for $M$, we get the useful data as a function of $B$ and $p$:\n$$D(B) = B - p$$\n\nNext, we define the pointer overhead fraction, which we will denote as $O_f$. The problem defines this as the ratio of metadata bytes to useful data bytes.\n$$O_f = \\frac{M}{D}$$\nSubstituting the expressions for $M$ and $D(B)$, we can express the overhead fraction as a function of the block size $B$:\n$$O_f(B) = \\frac{p}{B - p}$$\n\nThe system design imposes a constraint that the pointer overhead must not exceed a fraction $\\theta$ of the useful data. This translates to the inequality $M \\le \\theta D$. Dividing by $D$ (which is positive, since $B > p$ implies $D > 0$), this constraint is equivalent to:\n$$\\frac{M}{D} \\le \\theta$$\nSubstituting our expression for the overhead fraction, the constraint is:\n$$O_f(B) = \\frac{p}{B - p} \\le \\theta$$\n\nThe problem asks for the threshold block size, $B_{\\text{threshold}}$, which is defined as the specific block size at which the pointer overhead fraction *equals* the allowable fraction $\\theta$. This represents the boundary case of the constraint. Therefore, we set $O_f(B_{\\text{threshold}}) = \\theta$.\n$$\\frac{p}{B_{\\text{threshold}} - p} = \\theta$$\n\nWe now solve this equation for $B_{\\text{threshold}}$. Given that $\\theta > 0$ and we require $B_{\\text{threshold}} > p$, we can safely multiply both sides by $(B_{\\text{threshold}} - p)$:\n$$p = \\theta (B_{\\text{threshold}} - p)$$\nDistributing $\\theta$ on the right-hand side gives:\n$$p = \\theta B_{\\text{threshold}} - \\theta p$$\nTo solve for $B_{\\text{threshold}}$, we first isolate the term containing it:\n$$\\theta B_{\\text{threshold}} = p + \\theta p$$\nFactoring out $p$ from the terms on the right-hand side yields:\n$$\\theta B_{\\text{threshold}} = p(1 + \\theta)$$\nFinally, since $\\theta > 0$, we can divide by $\\theta$ to obtain the closed-form expression for the threshold block size:\n$$B_{\\text{threshold}} = \\frac{p(1 + \\theta)}{\\theta}$$\n\nThis expression can also be written as $B_{\\text{threshold}} = p\\left(1 + \\frac{1}{\\theta}\\right)$.\n\nTo confirm the interpretation provided in the problem, we examine the behavior of the overhead fraction function, $O_f(B) = \\frac{p}{B - p}$. The derivative with respect to $B$ is $\\frac{d(O_f)}{dB} = -\\frac{p}{(B - p)^2}$. Since $p > 0$ and $(B-p)^2 > 0$, the derivative is always negative for $B > p$. This means that $O_f(B)$ is a monotonically decreasing function of $B$.\nConsequently:\n- For any block size $B < B_{\\text{threshold}}$, it follows that $O_f(B) > O_f(B_{\\text{threshold}})$, which means $\\frac{p}{B-p} > \\theta$. This matches the condition that the overhead per block exceeds $\\theta$ times the useful data.\n- For any block size $B \\ge B_{\\text{threshold}}$, it follows that $O_f(B) \\le O_f(B_{\\text{threshold}})$, which means $\\frac{p}{B-p} \\le \\theta$. This matches the condition that the overhead per block is at most $\\theta$ times the useful data.\nThe derived expression for $B_{\\text{threshold}}$ is therefore consistent with all conditions and interpretations given in the problem statement.", "answer": "$$\\boxed{\\frac{p(1 + \\theta)}{\\theta}}$$", "id": "3653104"}, {"introduction": "The structural choices of a file system have profound implications for its performance, and the sequential nature of linked allocation presents a significant bottleneck for certain operations. This practice contrasts the algorithmic complexity of file truncation in a linked allocation system with that of an indexed allocation system. By calculating the time costs based on a detailed model, you will see a dramatic illustration of why traversing a linked list on disk is expensive and appreciate how different data structures are suited for different operational demands [@problem_id:3653085].", "problem": "Consider a file system that supports two block-allocation methods for files: linked allocation via a File Allocation Table (FAT) and indexed allocation via an index node (inode). In linked allocation, the directory entry of a file stores only the pointer to the first block; each block stores a pointer to the next block. In indexed allocation, the inode stores pointers to all data blocks in a single-level index block, which is kept in main memory.\n\nAssume a file currently occupies $N=50{,}000$ blocks. An application issues $B=10{,}000$ successive truncation operations, each removing exactly the last block of the file. All metadata structures are resident in main memory. The following operation costs apply:\n- Reading a single pointer (from the FAT or an index block) costs $t_{r} = 80$ nanoseconds.\n- Writing a single pointer (to the FAT or an index block) costs $t_{w} = 120$ nanoseconds.\n- Writing one bit in the free-space bitmap costs $t_{f} = 150$ nanoseconds.\n- Updating file metadata (for example, file size in the directory entry or inode) per truncation call costs $t_{i} = 200$ nanoseconds.\n\nUnder linked allocation without a tail pointer, truncating the last block of a file of current length $m$ requires traversing the chain from the head to the predecessor of the tail to update the predecessor’s next pointer to the null terminator. Under indexed allocation, truncating the last block requires clearing the last pointer in the index and does not require traversal.\n\nYou must:\n1. From core definitions of linked and indexed allocation, derive the number of pointer updates performed per truncation step for each method, and aggregate them across $B$ successive truncations for linked allocation.\n2. Using the given costs, compute the total time to remove the last $B$ blocks when performed as $B$ successive single-block truncations using linked allocation and using indexed allocation.\n3. Suppose the operating system applies a batch optimization for linked allocation: it traverses the chain once to the new tail (the $(N-B)$-th block), performs a single pointer write to terminate the list there, writes $B$ bits in the bitmap, and performs a single metadata update. Derive the total time of this batch approach.\n4. Finally, report the ratio of the total time of linked allocation with $B$ successive single-block truncations to the total time of indexed allocation with $B$ successive single-block truncations, as a single dimensionless number. Round your final ratio to four significant figures. Express all intermediate times in seconds for clarity, but the requested final ratio is dimensionless.", "solution": "The solution proceeds by addressing the four required components of the problem.\n\n### 1 & 2. Total Time for Successive Single-Block Truncations\n\nWe will derive the costs for both allocation methods for $B$ successive truncations.\n\n**Linked Allocation (Successive)**\n\nFirst, we analyze the cost of a single truncation step. Let the $k$-th truncation operation occur when the file has $m_k$ blocks, for $k \\in \\{1, 2, \\dots, B\\}$. Initially, $m_1=N$. After the first truncation, $m_2 = N-1$, and so on. The number of blocks before the $k$-th truncation is $m_k = N - (k-1)$.\n\nTo truncate the last block ($m_k$), the system must traverse the linked list of blocks to find its predecessor, block $m_k - 1$. This requires reading the pointers in blocks $1, 2, \\dots, m_k-2$.\n- Number of pointer reads for the $k$-th truncation: $N_{\\text{reads},k} = m_k - 2 = (N - k + 1) - 2 = N - k - 1$.\n- Upon reaching block $m_k - 1$, its pointer is overwritten to be the null terminator. This constitutes one pointer write.\n- Number of pointer writes for the $k$-th truncation: $N_{\\text{writes},k} = 1$.\n\nThe total cost for the $k$-th truncation, $C_{\\text{linked}, k}$, is the sum of costs for pointer reads, one pointer write, one bitmap update, and one metadata update:\n$$C_{\\text{linked},k} = (N - k - 1)t_r + t_w + t_f + t_i$$\nTo find the total time, $T_{\\text{linked, succ}}$, we sum this cost over all $B$ truncations (from $k=1$ to $k=B$):\n$$T_{\\text{linked, succ}} = \\sum_{k=1}^{B} C_{\\text{linked},k} = \\sum_{k=1}^{B} \\left[ (N-k-1)t_r + t_w + t_f + t_i \\right]$$\n$$T_{\\text{linked, succ}} = t_r \\sum_{k=1}^{B} (N-k-1) + B(t_w+t_f+t_i)$$\nThe summation term is the sum of an arithmetic series:\n$$\\sum_{k=1}^{B} (N-k-1) = (N-2) + (N-3) + \\dots + (N-B-1)$$\nThe sum can be calculated as $\\frac{\\text{number of terms}}{2} \\times (\\text{first term} + \\text{last term})$:\n$$\\sum_{k=1}^{B} (N-k-1) = \\frac{B}{2}((N-2) + (N-B-1)) = \\frac{B(2N-B-3)}{2}$$\nSo, the total time is:\n$$T_{\\text{linked, succ}} = \\left[\\frac{B(2N-B-3)}{2}\\right]t_r + B(t_w+t_f+t_i)$$\nSubstituting the given values:\n$N = 50000$, $B = 10000$, $t_r = 80 \\times 10^{-9} \\text{ s}$, $t_w = 120 \\times 10^{-9} \\text{ s}$, $t_f = 150 \\times 10^{-9} \\text{ s}$, $t_i = 200 \\times 10^{-9} \\text{ s}$.\n$$T_{\\text{linked, succ}} = \\left[\\frac{10000(2 \\cdot 50000 - 10000 - 3)}{2}\\right](80 \\times 10^{-9}) + 10000(120+150+200) \\times 10^{-9}$$\n$$T_{\\text{linked, succ}} = \\left[\\frac{10000(89997)}{2}\\right](80 \\times 10^{-9}) + 10000(470) \\times 10^{-9}$$\n$$T_{\\text{linked, succ}} = (449,985,000)(80 \\times 10^{-9}) + 4,700,000 \\times 10^{-9}$$\n$$T_{\\text{linked, succ}} = 35.9988 \\text{ s} + 0.0047 \\text{ s} = 36.0035 \\text{ s}$$\n\n**Indexed Allocation (Successive)**\n\nFor indexed allocation, the inode points to an index block in memory containing an array of pointers to the data blocks. To truncate the last block, the system only needs to modify this index block.\n- For each truncation, the pointer to the last block is cleared (set to null). This is one pointer write. No pointer reads are required for traversal.\n- Number of pointer reads per truncation: $N_{\\text{reads}} = 0$.\n- Number of pointer writes per truncation: $N_{\\text{writes}} = 1$.\n\nThe cost for a single truncation, $C_{\\text{indexed}}$, is constant:\n$$C_{\\text{indexed}} = t_w + t_f + t_i$$\nThe total time for $B$ successive truncations, $T_{\\text{indexed, succ}}$, is:\n$$T_{\\text{indexed, succ}} = B \\times C_{\\text{indexed}} = B(t_w+t_f+t_i)$$\nSubstituting values:\n$$T_{\\text{indexed, succ}} = 10000(120 + 150 + 200) \\times 10^{-9} = 10000(470) \\times 10^{-9} = 4,700,000 \\times 10^{-9} = 0.0047 \\text{ s}$$\n\n### 3. Total Time for Batch-Optimized Linked Allocation\n\nIn this scenario, the total operation to remove $B$ blocks is performed with a single pass.\n1.  **Traversal**: The system traverses to the new tail block, which is block $N-B$. This requires reading the pointers in blocks $1, 2, \\dots, N-B-1$.\n    Number of pointer reads: $N - B - 1$.\n2.  **Pointer Write**: The pointer in block $N-B$ is updated to the null terminator.\n    Number of pointer writes: $1$.\n3.  **Bitmap Update**: All $B$ freed blocks are marked in the free-space bitmap.\n    Number of bitmap writes: $B$.\n4.  **Metadata Update**: The file size is updated once for the entire batch operation.\n    Number of metadata updates: $1$.\n\nThe total time, $T_{\\text{linked, batch}}$, is:\n$$T_{\\text{linked, batch}} = (N-B-1)t_r + t_w + B t_f + t_i$$\nSubstituting values:\n$$T_{\\text{linked, batch}} = (50000 - 10000 - 1)(80 \\times 10^{-9}) + 120 \\times 10^{-9} + 10000(150 \\times 10^{-9}) + 200 \\times 10^{-9}$$\n$$T_{\\text{linked, batch}} = (39999)(80 \\times 10^{-9}) + 120 \\times 10^{-9} + 1,500,000 \\times 10^{-9} + 200 \\times 10^{-9}$$\n$$T_{\\text{linked, batch}} = (3,199,920 + 120 + 1,500,000 + 200) \\times 10^{-9}$$\n$$T_{\\text{linked, batch}} = 4,700,240 \\times 10^{-9} = 0.00470024 \\text{ s}$$\n\n### 4. Ratio of Successive Truncation Times\n\nFinally, we compute the ratio of the total time for successive linked allocation to that of successive indexed allocation.\n$$R = \\frac{T_{\\text{linked, succ}}}{T_{\\text{indexed, succ}}} = \\frac{\\left[\\frac{B(2N-B-3)}{2}\\right]t_r + B(t_w+t_f+t_i)}{B(t_w+t_f+t_i)}$$\n$$R = \\frac{\\left[\\frac{B(2N-B-3)}{2}\\right]t_r}{B(t_w+t_f+t_i)} + 1 = \\frac{(2N-B-3)t_r}{2(t_w+t_f+t_i)} + 1$$\nUsing the numerical values:\n$$R = \\frac{(2 \\cdot 50000 - 10000 - 3)(80)}{2(120+150+200)} + 1$$\n$$R = \\frac{(89997)(80)}{2(470)} + 1$$\n$$R = \\frac{7199760}{940} + 1$$\n$$R \\approx 7659.31914... + 1 = 7660.31914...$$\nRounding to four significant figures, the ratio is $7660$.\nAlternatively, using the calculated times:\n$$R = \\frac{36.0035 \\text{ s}}{0.0047 \\text{ s}} \\approx 7660.31914...$$\nThe result is consistent. The final rounded value is $7660$.", "answer": "$$\\boxed{7660}$$", "id": "3653085"}, {"introduction": "While linked allocation elegantly solves the problem of external fragmentation, it can cause a file's blocks to become scattered across the disk, severely degrading sequential read performance. This hands-on coding challenge puts you in the role of a systems programmer tasked with fixing this issue by implementing an online compaction algorithm. By translating a detailed specification into a working program, you will tackle the real-world problem of data layout optimization and gain experience simulating disk operations under practical constraints [@problem_id:3653129].", "problem": "You are given a simplified model of a disk and a single file stored using linked allocation. The disk is modeled as an array of block indices from $0$ to $N-1$. A file under linked allocation consists of a logical sequence of disk blocks, where each block stores a pointer to the next block. We model the file’s logical order by a sequence of distinct block indices $\\langle s_0, s_1, \\dots, s_{L-1}\\rangle$, where $L \\ge 1$ is the number of blocks in the file. Each $s_k$ is a disk block index in $\\{0,1,\\dots,N-1\\}$, all $s_k$ are pairwise distinct, and these indices are currently occupied by this file. Other files may occupy additional disk blocks, given as a set $U \\subseteq \\{0,1,\\dots.N-1\\}$ disjoint from $\\{s_0,\\dots,s_{L-1}\\}$. A disk block $i$ is free if and only if $i \\notin U$ and $i \\notin \\{s_0,\\dots,s_{L-1}\\}$.\n\nGoal: Design and implement an online compaction algorithm that rewrites the file’s blocks into a near-contiguous region in nondecreasing physical order, while preserving the file’s logical order. The algorithm must obey the following concrete rules, which formalize the constraints of linked allocation and online operation:\n\n- Disk operation model:\n  - Reading a block into an in-memory buffer costs $1$ time unit.\n  - Writing a block from the buffer to disk costs $1$ time unit.\n  - Updates to the intra-file pointers are assumed to be included in the rewritten block’s write and incur no extra I/O.\n  - Seeking costs are ignored.\n- Space model:\n  - You may use at most $1$ in-memory buffer block at any time (online constraint). The peak number of such buffers used simultaneously is the space cost to be reported.\n- Allowed move:\n  - To relocate a file block currently at physical index $s$ to a free target index $t$, you must read $s$ into the buffer and write it to $t$ (time cost $2$). Upon completion, $s$ becomes free.\n- Placement policy (Stable Greedy Forward Compaction, SGFC):\n  - Maintain a write cursor $w$, initialized to $0$.\n  - Process the file’s logical blocks in order $s_0, s_1, \\dots, s_{L-1}$.\n  - For the current source index $s$, choose the target index $t$ as the minimum $i$ such that $i \\ge w$ and either $i$ is currently free or $i = s$. This ensures that if the source is already at the earliest permissible position, it can remain in place; otherwise it moves to the earliest currently free index.\n  - If $t \\ne s$, perform a move (read $s$, write $t$), mark $s$ free, and mark $t$ occupied by the file. If $t = s$, do nothing.\n  - Set $w \\leftarrow t + 1$ and continue to the next logical block.\n- Required measures to compute and report:\n  - Total I/O time $T$, equal to $2$ times the number of moved blocks (each move is one read and one write).\n  - Number of moved blocks $M$.\n  - Peak extra in-memory buffer blocks $B$ used simultaneously.\n  - Length $R$ of the longest contiguous run in the final physical placement $\\langle t_0,t_1,\\dots,t_{L-1}\\rangle$, where a run increments when $t_{k} = t_{k-1} + 1$.\n  - The final placement itself as the list $\\langle t_0,t_1,\\dots,t_{L-1}\\rangle$.\n\nYour task is to implement SGFC exactly as specified and compute the measures above.\n\nTest suite definition (embed these in your program; no input should be read):\n\n- Test case $1$:\n  - $N = 20$\n  - File logical order (current physical indices): $\\langle 17, 3, 12, 5, 9, 15 \\rangle$\n  - Other files occupy $U = \\{0, 10, 11, 14, 18\\}$\n- Test case $2$ (boundary: single-block file):\n  - $N = 8$\n  - File logical order: $\\langle 2 \\rangle$\n  - Other files occupy $U = \\{0, 1, 3, 5, 6, 7\\}$\n- Test case $3$ (already contiguous, no moves needed):\n  - $N = 12$\n  - File logical order: $\\langle 1, 2, 3, 4 \\rangle$\n  - Other files occupy $U = \\{0, 7, 9, 10, 11\\}$\n- Test case $4$ (overlap hazard with later block occupying an early slot):\n  - $N = 15$\n  - File logical order: $\\langle 5, 6, 12, 4 \\rangle$\n  - Other files occupy $U = \\{0, 1, 9, 14\\}$\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. Each test case’s result must itself be a list of the form $[T, M, B, R, [t_0,t_1,\\dots,t_{L-1}]]$ with no spaces. For example: $[[T_1,M_1,B_1,R_1,[\\dots]],[T_2,M_2,B_2,R_2,[\\dots]],\\dots]$.\n\nAll numbers in the output are integers. No angles or physical units are involved beyond the abstract I/O time units defined above.", "solution": "The provided problem is a well-posed algorithmic challenge rooted in the principles of operating systems, specifically file system management. It asks for the implementation and analysis of a specific online file compaction algorithm, termed Stable Greedy Forward Compaction (SGFC). The problem statement is scientifically grounded, objective, and provides a complete and consistent set of rules and data for its resolution. The premise is a simplified but standard model of disk allocation, and the task is to simulate the behavior of the SGFC algorithm on several test cases and report specific performance metrics. The problem is valid.\n\nThe solution involves a direct simulation of the SGFC algorithm. The core of this simulation is managing the state of the disk blocks, which can be in one of three states at any given time: free, occupied by another file, or occupied by the file being compacted.\n\nFirst, we establish the initial state of the disk. A one-dimensional array, let's call it `disk_status`, of size $N$ is used to represent the $N$ blocks of the disk. Each element of this array can hold a value representing its state. We initialize all blocks to a `FREE` state. Then, we update the status of blocks listed in the set $U$ to `OCCUPIED_BY_U`. Finally, we mark the initial physical blocks $\\langle s_0, s_1, \\dots, s_{L-1} \\rangle$ of our file as `OCCUPIED_BY_FILE`.\n\nThe SGFC algorithm proceeds as follows:\n$1.$ A write cursor, $w$, is initialized to $0$. A counter for moved blocks, $M$, is initialized to $0$. An array to store the final placement, say `final_placement`, is prepared.\n\n$2.$ The algorithm iterates through the logical blocks of the file in their specified order, from $k=0$ to $L-1$. In each iteration $k$, we process the source block at physical address $s_k$.\n\n$3.$ For the current source block $s_k$, we must find its new target physical address, $t_k$. According to the SGFC policy, $t_k$ is the minimum block index $i$ such that $i \\ge w$ and the block at index $i$ is a valid destination. A block $i$ is a valid destination if it is currently free or if it is the source block itself ($i=s_k$). In terms of our `disk_status` array, this means we search for the smallest $i \\ge w$ where `disk_status[i]` is not `OCCUPIED_BY_U`, and either `disk_status[i]` is not `OCCUPIED_BY_FILE` or $i = s_k$. The second part of this condition, `(disk_status[i] != OCCUPIED_BY_FILE || i == s_k)`, correctly handles the case where a block can stay in its original position if it is the earliest available slot. It also correctly prevents moving a block to a location that is currently occupied by another block of the *same* file that has not yet been processed.\n\n$4.$ Once the target $t_k$ is found, we record it: `final_placement[k] = t_k`.\n\n$5.$ We then check if the block needs to be moved. A move is necessary if $t_k \\ne s_k$. If so, we increment the move counter $M$. The move operation consists of reading from $s_k$ and writing to $t_k$. This has consequences for the disk state: the block at the source address $s_k$ becomes free, and the block at the target address $t_k$ becomes occupied by our file. We update our `disk_status` array accordingly: `disk_status[s_k]` becomes `FREE` and `disk_status[t_k]` becomes `OCCUPIED_BY_FILE`. If $t_k = s_k$, no I/O operations occur, $M$ is not incremented, and the disk state for this block remains unchanged.\n\n$6.$ Finally, we update the write cursor for the next iteration: $w \\leftarrow t_k + 1$. This ensures the next block will be placed at or after the position following the current block, promoting contiguity.\n\nAfter iterating through all $L$ blocks, the simulation is complete. We then compute the required metrics:\n-   **Total I/O time $T$**: Each move involves one read and one write, costing $2$ time units. Thus, $T = 2 \\times M$.\n-   **Number of moved blocks $M$**: This is the value accumulated during the simulation.\n-   **Peak extra buffer blocks $B$**: The problem specifies an online algorithm using at most one buffer. A buffer is used only when a block is moved ($M > 0$). If any moves occur, the peak usage is $1$. If no moves occur ($M=0$), the peak usage is $0$. Therefore, $B = (M > 0) ? 1 : 0$.\n-   **Longest contiguous run $R$**: We iterate through the `final_placement` array, $\\langle t_0, t_1, \\dots, t_{L-1} \\rangle$. A run is a sequence of blocks where $t_k = t_{k-1} + 1$. We track the length of the current run and the maximum run length found so far. For a file of length $L \\ge 1$, the minimum possible run length is $1$.\n-   **Final placement**: This is the `final_placement` array itself.\n\nThis entire procedure is deterministic and is implemented for each test case to generate the final results.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// Represents the state of a single disk block.\ntypedef enum {\n    FREE,\n    OCCUPIED_BY_U,\n    OCCUPIED_BY_FILE\n} DiskStatus;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int N;\n    int file_len;\n    const int* file_seq;\n    int u_len;\n    const int* u_set;\n} TestCase;\n\n// A struct to hold the results of a single test case.\ntypedef struct {\n    int T;\n    int M;\n    int B;\n    int R;\n    int file_len;\n    int* placement;\n} Result;\n\nint main(void) {\n    // Define the test case data.\n    const int file1[] = {17, 3, 12, 5, 9, 15};\n    const int u1[] = {0, 10, 11, 14, 18};\n    const int file2[] = {2};\n    const int u2[] = {0, 1, 3, 5, 6, 7};\n    const int file3[] = {1, 2, 3, 4};\n    const int u3[] = {0, 7, 9, 10, 11};\n    const int file4[] = {5, 6, 12, 4};\n    const int u4[] = {0, 1, 9, 14};\n\n    // Initialize the test cases array.\n    TestCase test_cases[] = {\n        {20, 6, file1, 5, u1},\n        {8, 1, file2, 6, u2},\n        {12, 4, file3, 5, u3},\n        {15, 4, file4, 4, u4},\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    Result results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n\n        // 1. Initialization\n        DiskStatus* disk_status = (DiskStatus*)malloc(tc.N * sizeof(DiskStatus));\n        for (int j = 0; j < tc.N; j++) {\n            disk_status[j] = FREE;\n        }\n        for (int j = 0; j < tc.u_len; j++) {\n            disk_status[tc.u_set[j]] = OCCUPIED_BY_U;\n        }\n        for (int j = 0; j < tc.file_len; j++) {\n            disk_status[tc.file_seq[j]] = OCCUPIED_BY_FILE;\n        }\n\n        int M = 0;\n        int w = 0;\n        int* final_placement = (int*)malloc(tc.file_len * sizeof(int));\n\n        // 2. Main Loop: Implement the SGFC algorithm\n        for (int k = 0; k < tc.file_len; ++k) {\n            int s = tc.file_seq[k];\n            int t = -1;\n\n            // Find target t: minimum i >= w such that (i is free or i=s)\n            for (int j = w; j < tc.N; ++j) {\n                if (disk_status[j] != OCCUPIED_BY_U && (disk_status[j] != OCCUPIED_BY_FILE || j == s)) {\n                    t = j;\n                    break;\n                }\n            }\n\n            final_placement[k] = t;\n\n            // If a move is performed, update state and metrics\n            if (t != s) {\n                M++;\n                disk_status[s] = FREE;\n                disk_status[t] = OCCUPIED_BY_FILE;\n            }\n\n            w = t + 1;\n        }\n\n        // 3. Post-Processing: Calculate final metrics\n        int T = 2 * M;\n        int B = (M > 0) ? 1 : 0;\n        int R = (tc.file_len > 0) ? 1 : 0;\n        if (tc.file_len > 1) {\n            int current_run = 1;\n            for (int j = 1; j < tc.file_len; j++) {\n                if (final_placement[j] == final_placement[j - 1] + 1) {\n                    current_run++;\n                } else {\n                    current_run = 1;\n                }\n                if (current_run > R) {\n                    R = current_run;\n                }\n            }\n        }\n        \n        results[i] = (Result){T, M, B, R, tc.file_len, final_placement};\n        free(disk_status);\n    }\n\n    // Print the results in the EXACT required format before the final return statement\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%d,%d,%d,%d,[\", results[i].T, results[i].M, results[i].B, results[i].R);\n        for (int j = 0; j < results[i].file_len; ++j) {\n            printf(\"%d\", results[i].placement[j]);\n            if (j < results[i].file_len - 1) {\n                printf(\",\");\n            }\n        }\n        printf(\"]]\");\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n        free(results[i].placement);\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3653129"}]}