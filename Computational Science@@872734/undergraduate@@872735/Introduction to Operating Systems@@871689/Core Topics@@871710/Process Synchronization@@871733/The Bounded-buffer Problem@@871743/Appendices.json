{"hands_on_practices": [{"introduction": "Before diving into complex synchronization code, a fundamental question for any buffer is: how large does it need to be? This exercise moves beyond guesswork, asking you to model a producer-consumer system with real-world performance constraints [@problem_id:3687090]. By deriving the minimum buffer size needed to handle a burst of data without violating per-item deadlines, you will develop a first-principles understanding of the relationship between buffer capacity, service rate, and latency guarantees.", "problem": "A single-producer, single-consumer bounded-buffer system must guarantee that every admitted item completes service no later than a fixed per-item deadline. The buffer holds only waiting items; the consumer removes an item from the buffer to begin service and holds it during service. Assume the following foundational model.\n\n- At time $t = 0$, a worst-case burst of $X$ items becomes available simultaneously. Items are identical and are enqueued in first-come, first-served order.\n- The consumer processes items at a constant rate $\\mu$ items per second, so the deterministic service time per item is $1/\\mu$ seconds. There are no context-switch or dequeue overheads.\n- Each item must complete service within $D$ seconds of its arrival. The system employs admission control at arrival: items that cannot meet their deadlines given the current queue state are not admitted to the buffer and are immediately rejected, so as not to waste buffer space on inevitably tardy items.\n- The consumer begins processing immediately at $t = 0^{+}$ if at least one item is admitted. There are no arrivals after the burst at $t = 0$.\n\nStarting from first principles of this model, derive a closed-form expression for the minimum buffer capacity $B$ (in buffer slots) required to ensure that, under the worst-case burst described, no admitted item is lost to buffer overflow and every admitted item completes by its deadline.\n\nExpress your final answer as a single analytic expression in terms of $X$, $\\mu$, and $D$. No numerical approximation or rounding is required.", "solution": "The problem asks for the minimum buffer capacity, $B$, required for a single-producer, single-consumer system under specific conditions. The derivation proceeds from first principles by analyzing the timing of events for items processed in a first-come, first-served (FCFS) manner.\n\nLet us denote the time of arrival of the burst of $X$ items as $t_{arrival} = 0$. According to the problem statement, every admitted item must have its service completed by a deadline $D$ seconds after its arrival. Therefore, for any admitted item, its completion time, $t_{completion}$, must satisfy the condition $t_{completion} \\le D$.\n\nThe consumer processes items at a constant rate of $\\mu$ items per second. This implies that the service time for a single item is deterministic and equal to $s = 1/\\mu$ seconds. The system employs an FCFS queueing discipline. Let's analyze the completion time for the $k^{th}$ item in the sequence to be processed, where $k$ is a positive integer ($k=1, 2, 3, \\dots$).\n\nThe first item ($k = 1$) is enqueued at $t = 0$ and, since the consumer is immediately available, its service begins at $t=0^{+}$. Its service completes at time $t_{completion,1} = 1/\\mu$.\nThe second item ($k = 2$) must wait for the first item to finish. It enters service at time $1/\\mu$ and completes service at time $t_{completion,2} = 1/\\mu + 1/\\mu = 2/\\mu$.\nGeneralizing this pattern, the $k^{th}$ item to be processed will complete its service at time:\n$$t_{completion,k} = k \\times \\frac{1}{\\mu} = \\frac{k}{\\mu}$$\n\nThe system employs an admission control policy: an item is admitted only if it can meet its deadline. For the $k^{th}$ item in the processing sequence, this means its completion time must not exceed the deadline $D$.\n$$\\frac{k}{\\mu} \\le D$$\nThis inequality can be rearranged to find the maximum possible value of $k$:\n$$k \\le \\mu D$$\n\nSince $k$ must represent an integer number of items, the maximum number of items that can be processed while satisfying all deadlines, let us call this $A_{max\\_servable}$, is the greatest integer less than or equal to $\\mu D$. This is represented by the floor function:\n$$A_{max\\_servable} = \\lfloor \\mu D \\rfloor$$\n\nAt time $t=0$, a burst of $X$ items arrives. The system cannot admit more items than are available. Therefore, the actual number of admitted items, which we will denote as $A$, is the minimum of the number of available items, $X$, and the maximum number of items the system can servably process, $A_{max\\_servable}$.\n$$A = \\min(X, A_{max\\_servable}) = \\min(X, \\lfloor \\mu D \\rfloor)$$\n\nWe now need to determine the required buffer capacity, $B$. The problem states that the buffer holds only *waiting* items. The item currently being served is held by the consumer, not in the buffer. At time $t=0$, $A$ items are admitted. At time $t=0^{+}$, if $A  0$, the first item is immediately dequeued and enters service. The remaining $A-1$ items must reside in the buffer. This moment represents the peak occupancy of the buffer, because from this point forward, no new items arrive, and the number of items in the buffer will only decrease as the consumer processes them one by one.\n\nTherefore, the minimum buffer capacity $B$ must be large enough to hold these waiting items.\n$$B = A - 1$$\n\nThis is valid for $A \\ge 1$. If $A=0$ or $A=1$, the number of waiting items is $0$. A negative buffer capacity is not physically meaningful. The buffer capacity must be a non-negative integer. Thus, the required capacity is the number of waiting items, floored at $0$.\n$$B = \\max(0, A - 1)$$\n\nSubstituting the expression for $A$ into this equation gives the final closed-form expression for the minimum required buffer capacity:\n$$B = \\max(0, \\min(X, \\lfloor \\mu D \\rfloor) - 1)$$\n\nThis expression correctly captures all cases. For instance, if the service time $1/\\mu$ exceeds the deadline $D$, then $\\mu D  1$, which means $\\lfloor \\mu D \\rfloor = 0$. This leads to $A=0$ and $B=\\max(0, 0-1) = 0$, which is correct as no items can be admitted. If only one item is admitted ($A=1$), it goes directly to the consumer, and the buffer requirement is $B = \\max(0, 1-1) = 0$, which is also correct. For any $A  1$ admitted items, one is in service and $A-1$ are in the buffer, matching the formula.", "answer": "$$\\boxed{\\max(0, \\min(X, \\lfloor \\mu D \\rfloor) - 1)}$$", "id": "3687090"}, {"introduction": "Implementing a bounded buffer correctly requires more than just managing capacity; it demands flawless synchronization between concurrent threads. This practice problem presents a scenario with a subtle but critical bug in a semaphore-based solution, where a consumer signals prematurely [@problem_id:3687132]. By constructing a specific interleaving of threads that leads to a system failure, you will learn to think like a concurrency detective, identifying race conditions that can violate fundamental system invariants.", "problem": "Consider the classical bounded-buffer producer-consumer problem implemented with counting semaphores and a binary mutex. Let there be two producers $P_1$ and $P_2$ and one consumer $C$. The buffer has capacity $B$, and the shared integer $count$ tracks the number of occupied slots. The system uses counting semaphores $empty$ and $full$ with initial values $empty = B - count$ and $full = count$, and a binary mutex $m$ protecting the buffer and $count$. The semantics of the primitives are: $\\text{wait}(s)$ atomically decrements semaphore $s$ or blocks if its value is $0$, and $\\text{signal}(s)$ atomically increments $s$ and wakes one blocked thread if any. The critical correctness invariant is $0 \\le count \\le B$ at all times, and modifications to the buffer and $count$ occur only while holding $m$.\n\nAssume the following intended producer sequence:\n- $\\text{wait}(empty)$, then $\\text{wait}(m)$, then $\\text{put}$ into the buffer, then $count := count + 1$, then $\\text{signal}(m)$, then $\\text{signal}(full)$.\n\nHowever, the consumer is incorrectly implemented to signal $empty$ prematurely:\n- $\\text{wait}(full)$, then $\\text{signal}(empty)$, then $\\text{wait}(m)$, then $\\text{take}$ from the buffer, then $count := count - 1$, then $\\text{signal}(m)$.\n\nStarting from the scientifically consistent initial state $B = 2$, $count = 2$, $empty = 0$, $full = 2$, and with both $P_1$ and $P_2$ initially blocked on $\\text{wait}(empty)$, construct an interleaving that shows how the premature $\\text{signal}(empty)$ by $C$ can lead to a violation of the invariant $count \\le B$. Then, identify a corrected consumer sequence that ensures the invariant $0 \\le count \\le B$ is preserved under all interleavings, by respecting mutual exclusion and capacity semantics.\n\nWhich option below both\n- provides a concrete interleaving (given the faulty consumer above) that makes $count$ exceed $B$, and\n- proposes a corrected consumer ordering that prevents such violations for any interleaving?\n\nA. Interleaving demonstrating violation, then corrected consumer:\n- Interleaving:\n  - $C$: $\\text{wait}(full)$, then $\\text{signal}(empty)$.\n  - $P_1$: $\\text{wait}(empty)$, then $\\text{wait}(m)$, then $\\text{put}$, then $count := count + 1$ so $count = 3$ while $B = 2$, then $\\text{signal}(m)$, then $\\text{signal}(full)$.\n- Corrected consumer sequence:\n  - $\\text{wait}(full)$, then $\\text{wait}(m)$, then $\\text{take}$, then $count := count - 1$, then $\\text{signal}(m)$, then $\\text{signal}(empty)$.\n\nB. Interleaving with no violation, then incorrect consumer fix:\n- Interleaving:\n  - $C$: $\\text{wait}(full)$, then $\\text{wait}(m)$, then $\\text{signal}(empty)$, then $\\text{take}$, then $count := count - 1$, then $\\text{signal}(m)$.\n  - $P_1$: $\\text{wait}(empty)$, then $\\text{wait}(m)$, then $\\text{put}$, then $count := count + 1$.\n- Proposed consumer fix (still premature):\n  - $\\text{wait}(full)$, then $\\text{signal}(empty)$, then $\\text{wait}(m)$, then $\\text{take}$, then $count := count - 1$, then $\\text{signal}(m)$.\n\nC. Interleaving demonstrating violation, then incorrect consumer fix:\n- Interleaving:\n  - $C$: $\\text{wait}(full)$, then $\\text{signal}(empty)$.\n  - $P_1$: $\\text{wait}(empty)$, then $\\text{wait}(m)$.\n  - $C$: $\\text{wait}(m)$ blocks while $P_1$ holds $m$.\n  - $P_1$: $\\text{put}$, then $count := count + 1$ so $count = 3$ while $B = 2$, then $\\text{signal}(m)$.\n- Proposed consumer fix (moves $\\text{take}$ outside mutual exclusion):\n  - $\\text{wait}(full)$, then $\\text{take}$, then $\\text{wait}(m)$, then $count := count - 1$, then $\\text{signal}(empty)$, then $\\text{signal}(m)$.\n\nD. Interleaving demonstrating violation using $\\text{signal}(full)$ prematurely, then incorrect consumer fix:\n- Interleaving:\n  - $C$: $\\text{wait}(full)$, then $\\text{signal}(full)$, then $\\text{wait}(m)$.\n  - $P_1$: $\\text{wait}(full)$ succeeds, then $\\text{wait}(m)$, then $\\text{put}$, then $count := count + 1$ so $count = 3$ while $B = 2$.\n- Proposed consumer fix (misordered and missing $\\text{signal}(empty)$):\n  - $\\text{wait}(full)$, then $\\text{wait}(m)$, then $count := count - 1$, then $\\text{signal}(m)$.\n\nSelect the single best option.", "solution": "The problem statement is subjected to validation before proceeding.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Processes: Two producers, $P_1$ and $P_2$, and one consumer, $C$.\n- Buffer Capacity: $B$.\n- Shared State: An integer $count$ tracking the number of occupied slots.\n- Synchronization Primitives:\n    - Counting semaphore $empty$, initialized to $B - count$.\n    - Counting semaphore $full$, initialized to $count$.\n    - Binary mutex $m$.\n- Primitive Semantics:\n    - $\\text{wait}(s)$: Atomically decrements semaphore $s$ or blocks if its value is $0$.\n    - $\\text{signal}(s)$: Atomically increments $s$ and wakes one blocked thread if any.\n- Correctness Invariant: $0 \\le count \\le B$ must hold at all times.\n- Producer Logic: $\\text{wait}(empty)$, then $\\text{wait}(m)$, then $\\text{put}$ into buffer, then $count := count + 1$, then $\\text{signal}(m)$, then $\\text{signal}(full)$.\n- Faulty Consumer Logic: $\\text{wait}(full)$, then $\\text{signal}(empty)$, then $\\text{wait}(m)$, then $\\text{take}$ from buffer, then $count := count - 1$, then $\\text{signal}(m)$.\n- Specific Initial State: $B = 2$, $count = 2$, $empty = 0$, $full = 2$. Both $P_1$ and $P_2$ are initially blocked on $\\text{wait}(empty)$. The mutex $m$ is assumed to be available (value $1$).\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded in the principles of concurrent programming and operating systems. It describes a classic synchronization problem (bounded-buffer) with standard primitives (semaphores, mutex). The terminology is precise and objective. The provided initial state ($B=2, count=2, empty=0, full=2$) is consistent with the definitions ($empty=B-count=2-2=0$; $full=count=2$). The problem is well-posed, asking for a specific execution trace that demonstrates a flaw and a corrected code sequence. The setup is not incomplete, contradictory, or unrealistic for a software context. It represents a common type of programming error.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. A solution will be derived.\n\n### Derivation of Solution\n\nThe core of the problem lies in the interaction between the faulty consumer $C$ and a producer, say $P_1$. The invariant to be violated is $count \\le B$. We need to show how an interleaving can lead to $count  2$.\n\n**1. Analysis of the Flaw**\n\nThe standard producer-consumer solution uses the $empty$ and $full$ semaphores to enforce the buffer capacity constraints. A producer must wait for an empty slot (by calling $\\text{wait}(empty)$) before producing, and a consumer must wait for a full slot (by calling $\\text{wait}(full)$) before consuming.\n\n- The **Producer** logic is correct: It waits for an empty slot ($\\text{wait}(empty)$), acquires a lock ($\\text{wait}(m)$) to update the shared state, adds an item and increments $count$, releases the lock ($\\text{signal}(m)$), and finally signals that a slot is now full ($\\text{signal}(full)$).\n- The **Consumer** logic is faulty. The operations $\\text{wait}(full)$ and $\\text{signal}(empty)$ should conceptually bracket the consumption of an item. However, the sequence is given as $\\text{wait}(full)$, then $\\text{signal}(empty)$, then $\\text{wait}(m)$, etc. The consumer signals that a slot is empty *before* it has actually acquired the lock $m$ and removed the item from the buffer. This creates a race condition. The consumer advertises a resource (an empty slot) that does not yet exist.\n\n**2. Constructing a Violating Interleaving**\n\nLet's trace an execution starting from the initial state: $B=2$, $count=2$, $empty=0$, $full=2$, $m=1$. $P_1$ and $P_2$ are blocked on $\\text{wait}(empty)$.\n\n1.  $C$ starts execution. The producers are blocked, so they cannot run.\n2.  $C$ executes $\\text{wait}(full)$. The value of $full$ is $2$, so the call succeeds, and $full$ is decremented to $1$.\n3.  $C$ executes its faulty instruction: $\\text{signal}(empty)$. The value of $empty$ was $0$. This call increments $empty$ to $1$. Since $P_1$ (or $P_2$) was blocked on this semaphore, the operating system unblocks $P_1$. $P_1$ is now in the ready state, having completed its $\\text{wait}(empty)$ call.\n4.  At this point, a context switch occurs, and the scheduler chooses to run $P_1$. The consumer $C$ is preempted before it can execute $\\text{wait}(m)$.\n5.  $P_1$ executes its next instruction, $\\text{wait}(m)$. The mutex $m$ is available (value $1$), so $P_1$ acquires it, and the value of $m$ becomes $0$. $P_1$ is now in its critical section.\n6.  Inside its critical section, $P_1$ performs a $\\text{put}$ operation. The buffer, which was full, now overflows.\n7.  $P_1$ executes $count := count + 1$. The value of $count$ was $2$. It is now incremented to $3$.\n8.  At this moment, the invariant $count \\le B$ is violated, since $count = 3$ and $B = 2$. The violation has occurred. The rest of the execution sequence for $P_1$ ($\\text{signal}(m)$, $\\text{signal}(full)$) and the eventual execution of $C$ (which will block on $\\text{wait}(m)$ until $P_1$ releases it) do not alter this fact.\n\nThis interleaving demonstrates the violation successfully.\n\n**3. Proposing a Corrected Consumer Sequence**\n\nTo fix the bug, the consumer must only signal that a slot is empty *after* it has completed the removal of an item and the corresponding update of the shared variable $count$. The modification of shared state (the buffer and $count$) must be protected by the mutex $m$. Therefore, the $\\text{signal}(empty)$ call must be moved to after the critical section.\n\nThe correct, standard sequence for the consumer is:\n1.  $\\text{wait}(full)$: Wait until there is at least one item in the buffer.\n2.  $\\text{wait}(m)$: Acquire the lock to access shared state.\n3.  $\\text{take}$: Remove an item from the buffer.\n4.  $count := count - 1$: Decrement the count of items.\n5.  $\\text{signal}(m)$: Release the lock.\n6.  $\\text{signal}(empty)$: Signal to producers that a slot has been freed.\n\nThis ordering ensures that the semaphore $empty$ correctly represents the number of available slots, preventing the race condition that led to the violation.\n\n### Option-by-Option Analysis\n\n**A. Interleaving demonstrating violation, then corrected consumer:**\n- **Interleaving:** The described interleaving ($C$ runs $\\text{wait}(full)$, then $\\text{signal}(empty)$; then $P_1$ wakes up, acquires $m$, and increments $count$ to $3$) directly matches the violation trace derived above. This part is correct.\n- **Corrected consumer sequence:** The proposed sequence is $\\text{wait}(full)$, $\\text{wait}(m)$, $\\text{take}$, $count := count - 1$, $\\text{signal}(m)$, $\\text{signal}(empty)$. This is the canonical correct implementation, as derived above. This part is correct.\n- **Verdict:** **Correct**.\n\n**B. Interleaving with no violation, then incorrect consumer fix:**\n- **Interleaving:** This describes an interleaving where $C$ acquires the mutex before a context switch. As analyzed, this specific interleaving does not produce the violation. The task was to show an interleaving that *does* produce a violation. This part fails the task.\n- **Proposed consumer fix:** The proposed \"fix\" is identical to the original faulty sequence. This part is incorrect.\n- **Verdict:** **Incorrect**.\n\n**C. Interleaving demonstrating violation, then incorrect consumer fix:**\n- **Interleaving:** The interleaving is described in slightly more detail than in option A (explicitly showing $C$ blocking on $m$), but it is conceptually the same correct demonstration of the violation. This part is correct.\n- **Proposed consumer fix:** The proposed sequence is $\\text{wait}(full)$, then $\\text{take}$, then $\\text{wait}(m)$, ... This is critically flawed. The $\\text{take}$ operation modifies the shared buffer but is placed outside the critical section protected by the mutex $m$. This introduces a different a race condition. This part is incorrect.\n- **Verdict:** **Incorrect**.\n\n**D. Interleaving demonstrating violation using $\\text{signal}(full)$ prematurely, then incorrect consumer fix:**\n- **Interleaving:** The interleaving describes a different fault, a premature $\\text{signal}(full)$. The problem explicitly states the fault is a premature $\\text{signal}(empty)$. Furthermore, it incorrectly claims that producers wait on `full`, when they wait on `empty`. This part is inconsistent with the problem statement.\n- **Proposed consumer fix:** The proposed fix is missing the $\\text{take}$ operation and the $\\text{signal}(empty)$ call, which would cause the system to deadlock eventually as producers would never be signaled. This part is incorrect.\n- **Verdict:** **Incorrect**.\n\nBased on the analysis, option A is the only one that both correctly demonstrates the violation with a valid interleaving and provides the standard, correct fix for the consumer's logic.", "answer": "$$\\boxed{A}$$", "id": "3687132"}, {"introduction": "Even with correct high-level synchronization logic, the devil is in the details of the implementation, particularly with off-by-one errors in circular array indexing. This hands-on coding challenge asks you to build a model checker to systematically hunt for such bugs in a buggy buffer implementation and verify their absence in a corrected version [@problem_id:3687126]. This exercise will not only sharpen your coding skills but also introduce you to the power of formal verification for building robust and reliable concurrent data structures.", "problem": "Design and implement a complete, runnable program that systematically model-checks a bounded-buffer ring implementation for off-by-one errors in circular indexing and capacity guards. The bounded-buffer, also called the producer-consumer queue, has capacity $B$ and two indices: a producer index $p$ and a consumer index $c$. The occupancy (number of items currently in the buffer) is $n$. Items produced are labeled with strictly increasing identifiers $0, 1, 2, \\ldots$, and correct consumption must preserve order without duplication or loss.\n\nStart from the following fundamental base:\n- Modular arithmetic on indices respects $x' = (x + 1) \\bmod m$ for wrap-around when an index with modulus $m$ advances by one.\n- Safety properties of the bounded buffer require $\\;0 \\le n \\le B\\;$ and that both indices satisfy $\\;0 \\le p  B\\;$ and $\\;0 \\le c  B\\;$ at all times.\n- The conservation relation between total produced and total consumed is $\\;n = N_p - N_c\\;$, where $N_p$ is the count of produced items and $N_c$ is the count of consumed items.\n- Correctness of consumption requires that the value read at index $c$ equals the next expected identifier $\\;N_c\\;$.\n\nYou must implement two models of the ring buffer as labeled transition systems and verify them via finite-state exploration:\n- Pre-fix (buggy) model, intended to exhibit off-by-one errors:\n  1. Production is enabled when $\\;n \\le B\\;$.\n  2. The producer writes the current item $\\;N_p\\;$ to slot $\\;p\\;$, then updates $p$ with $p' = (p + 1) \\bmod B$ and $n' = n + 1$, and increments $N_p$ by $1$.\n  3. Consumption is enabled when $\\;n  0\\;$.\n  4. The consumer checks that the buffer at index $c$ equals $\\;N_c\\;$, consumes it, then updates $c$ with $c' = (c + 1) \\bmod (B + 1)$ and $n' = n - 1$, and increments $N_c$ by $1$.\n- Post-fix (corrected) model:\n  1. Production is enabled when $\\;n  B\\;$.\n  2. The producer writes the current item $\\;N_p\\;$ to slot $\\;p\\;$, then updates $p$ with $p' = (p + 1) \\bmod B$ and $n' = n + 1$, and increments $N_p$ by $1$.\n  3. Consumption is enabled when $\\;n  0\\;$.\n  4. The consumer checks that the buffer at index $c$ equals $\\;N_c\\;$, consumes it, then updates $c$ with $c' = (c + 1) \\bmod B$ and $n' = n - 1$, and increments $N_c$ by $1$.\n\nModel checking requirement:\n- Starting from the initial state with $\\;p = 0\\;$, $\\;c = 0\\;$, $\\;n = 0\\;$, $\\;N_p = 0\\;$, and $\\;N_c = 0\\;$, perform exhaustive exploration of all execution traces of length at most $S$ steps using Depth-First Search (DFS). At each step, if both production and consumption are enabled, branch to explore both transitions. If only one is enabled, take that transition. If neither is enabled or the step bound is reached, terminate that branch.\n- At every reached state, check the invariants $\\;0 \\le p  B\\;$, $\\;0 \\le c  B\\;$, $\\;0 \\le n \\le B\\;$, and $\\;n = N_p - N_c\\;$.\n- On each consumption transition, additionally check that the value read equals $\\;N_c\\;$ before updating indices and counters.\n\nA violation occurs as soon as any invariant fails or the read-value check fails on any explored trace (this represents a counterexample). The model passes if and only if no violations occur in any explored trace up to depth $S$.\n\nTest suite:\n- Case $1$: $B = 3$, $S = 6$.\n- Case $2$: $B = 1$, $S = 4$.\n- Case $3$: $B = 2$, $S = 5$.\n- Case $4$: $B = 4$, $S = 7$.\n\nFor each case, run both the pre-fix model and the post-fix model. The required final output format is a single line containing two lists: the first list holds the pre-fix results and the second list holds the post-fix results. Each entry is a boolean encoded as $1$ if the model passes (no violations found in any trace up to $S$), or $0$ if it fails (a violation is found in at least one trace). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, specifically:\n$$\\text{[[}b_1,b_2,b_3,b_4\\text{],[}f_1,f_2,f_3,f_4\\text{]]}$$\nwhere $b_i$ and $f_i$ are the booleans for the pre-fix and post-fix models on case $i$ respectively.", "solution": "The problem requires the design and implementation of a model checker to verify two implementations of a bounded-buffer algorithm against a set of safety and correctness properties. This task falls under the domain of formal methods in computer science, specifically algorithmic verification of finite-state systems.\n\nThe solution is architected as a systematic, exhaustive state-space exploration using a Depth-First Search (DFS) algorithm. The bounded-buffer system is modeled as a labeled transition system, where states are defined by the system's variables and transitions represent producer or consumer actions.\n\n### State Representation\nA state $\\Sigma$ of the system is a tuple comprising the producer index $p$, consumer index $c$, current occupancy $n$, total items produced $N_p$, total items consumed $N_c$, and the contents of the buffer array itself.\n$$ \\Sigma = (p, c, n, N_p, N_c, \\text{buffer}) $$\nThe buffer is an array of size $B$. Initially, the system is in state $\\Sigma_0 = (0, 0, 0, 0, 0, \\text{empty\\_buffer})$, where the buffer is considered empty.\n\n### Transition System\nThe behavior of the system is defined by two possible transitions from any given state: a produce transition ($T_p$) and a consume transition ($T_c$). Each transition is defined by a guard (a condition that must be true for the transition to be enabled) and an action (a rule for updating the state).\n\n#### 1. Pre-fix (Buggy) Model\n- **Produce Transition ($T_p$)**:\n  - Guard: $n \\le B$. This guard is flawed, as it allows production even when the buffer is full (i.e., when $n=B$).\n  - Action: An item with identifier $N_p$ is written to $\\text{buffer}[p]$. The state is updated as follows:\n    $$ p' = (p + 1) \\bmod B $$\n    $$ n' = n + 1 $$\n    $$ N_p' = N_p + 1 $$\n- **Consume Transition ($T_c$)**:\n  - Guard: $n  0$. This guard is correct.\n  - Action: The item at $\\text{buffer}[c]$ is consumed. The state is updated as follows:\n    $$ c' = (c + 1) \\bmod (B + 1) $$\n    $$ n' = n - 1 $$\n    $$ N_c' = N_c + 1 $$\n    The modulus $B+1$ for the consumer index $c$ is a flaw. Since the valid buffer indices are $0, 1, \\ldots, B-1$, this rule will eventually cause $c$ to take the value $B$, resulting in an out-of-bounds access attempt.\n\n#### 2. Post-fix (Corrected) Model\n- **Produce Transition ($T_p$)**:\n  - Guard: $n  B$. This is the correct guard, preventing production when the buffer is full.\n  - Action: Same as the pre-fix model.\n    $$ p' = (p + 1) \\bmod B $$\n    $$ n' = n + 1 $$\n    $$ N_p' = N_p + 1 $$\n- **Consume Transition ($T_c$)**:\n  - Guard: $n  0$.\n  - Action: The state is updated using the correct modulus for the consumer index:\n    $$ c' = (c + 1) \\bmod B $$\n    $$ n' = n - 1 $$\n    $$ N_c' = N_c + 1 $$\n\n### Verification via Depth-First Search\nThe model-checking process is implemented as a recursive function, `model_check_dfs`, which performs a DFS on the state-space graph starting from the initial state $\\Sigma_0$. The search is bounded by a maximum exploration depth $S$.\n\nThe algorithm at each recursive step is as follows:\n1.  **Invariant Check**: Upon entering a new state at a given depth, the function first validates a set of safety invariants:\n    - Index bounds: $0 \\le p  B$ and $0 \\le c  B$.\n    - Occupancy bound: $0 \\le n \\le B$.\n    - Conservation law: $n = N_p - N_c$.\n    If any invariant is violated, the model has failed. The function returns a failure status, pruning the current search path.\n\n2.  **Depth Check**: If the current search depth reaches the limit $S$, the exploration of that path terminates successfully, and the function returns a success status.\n\n3.  **Transition Exploration**: The function determines which transitions ($T_p$ and/or $T_c$) are enabled from the current state based on the model's guards.\n    - If a production is possible, a new state is computed according to the producer action, and the `model_check_dfs` function is called recursively on this new state with an incremented depth.\n    - If a consumption is possible, the algorithm first performs a crucial data correctness check: it verifies that the item at `buffer[c]` is indeed the next expected item, i.e., `buffer[c] == N_c`. If this check fails, it indicates data corruption or loss, and the model has failed. If the check passes, a new state is computed according to the consumer action, and a recursive call is made.\n\n4.  **Result Propagation**: If any recursive call returns a failure status, that status is immediately propagated up the call stack. The entire model is considered to have failed as soon as the first counterexample (a trace leading to a state that violates an invariant or correctness property) is found. If all possible execution traces up to depth $S$ are explored without finding any violation, the model is considered to have passed the check.\n\nThis systematic approach guarantees that if a flaw exists that can be triggered by a sequence of $S$ or fewer operations, the model checker will find it. The flaws in the pre-fix model—specifically, the potential for buffer overflow ($n  B$) and the out-of-bounds consumer index ($c \\ge B$)—are readily detected by the invariant checks. The post-fix model, employing the correct guards and update rules, adheres to all specified properties and thus passes verification.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n\n// Note: Per problem constraints, only headers from the specified list are used.\n// math.h, complex.h, threads.h, stdatomic.h are allowed but not needed for this implementation.\n// As stdbool.h is not on the list, we use int (1 for true, 0 for false) for boolean logic.\n\n// The maximum buffer capacity from the test cases.\n#define MAX_B 4\n\n// Represents the state of the bounded-buffer system.\ntypedef struct {\n    int p;  // Producer index\n    int c;  // Consumer index\n    int n;  // Occupancy (number of items in buffer)\n    int Np; // Total items produced\n    int Nc; // Total items consumed\n    int buffer[MAX_B];\n} State;\n\n// Represents a single test case with buffer size B and search depth S.\ntypedef struct {\n    int B;\n    int S;\n} TestCase;\n\n// Forward declaration of the model checking function.\nint model_check_dfs(State s, int depth, int B, int S, int is_postfix);\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {3, 6}, // Case 1\n        {1, 4}, // Case 2\n        {2, 5}, // Case 3\n        {4, 7}  // Case 4\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int pre_fix_results[num_cases];\n    int post_fix_results[num_cases];\n\n    // Calculate the result for each test case for both models.\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        \n        // Initial state for the system.\n        State initial_state = { .p = 0, .c = 0, .n = 0, .Np = 0, .Nc = 0 };\n        // Initialize buffer with a sentinel value (-1) to distinguish empty slots.\n        memset(initial_state.buffer, -1, sizeof(initial_state.buffer));\n\n        // Run the pre-fix (buggy) model.\n        pre_fix_results[i] = model_check_dfs(initial_state, 0, tc.B, tc.S, 0); // 0 for pre-fix\n\n        // Run the post-fix (corrected) model.\n        post_fix_results[i] = model_check_dfs(initial_state, 0, tc.B, tc.S, 1); // 1 for post-fix\n    }\n\n    // Print the results in the EXACT required format without a trailing newline.\n    printf(\"[[%d,%d,%d,%d],[%d,%d,%d,%d]]\", \n           pre_fix_results[0], pre_fix_results[1], pre_fix_results[2], pre_fix_results[3],\n           post_fix_results[0], post_fix_results[1], post_fix_results[2], post_fix_results[3]);\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Recursively explores the state space using DFS to find violations.\n * @param s The current state of the system.\n * @param depth The current depth in the search tree.\n * @param B The buffer capacity.\n * @param S The maximum search depth.\n * @param is_postfix A flag to select the model (1 for post-fix, 0 for pre-fix).\n * @return 1 (true) if no violation is found in this branch, 0 (false) otherwise.\n */\nint model_check_dfs(State s, int depth, int B, int S, int is_postfix) {\n    // --- Invariant Checks on the current state ---\n    // Index invariants: 0 = p  B and 0 = c  B\n    if (s.p  0 || s.p = B) { return 0; }\n    if (s.c  0 || s.c = B) { return 0; }\n    // Occupancy invariant: 0 = n = B\n    if (s.n  0 || s.n  B) { return 0; }\n    // Conservation invariant: n = Np - Nc\n    if (s.n != s.Np - s.Nc) { return 0; }\n    \n    // --- Termination Condition (depth limit) ---\n    if (depth = S) {\n        return 1; // Reached search depth limit without finding a violation.\n    }\n\n    // --- Determine Enabled Transitions ---\n    int can_produce;\n    if (is_postfix) {\n        can_produce = (s.n  B); // Correct guard for post-fix model\n    } else {\n        can_produce = (s.n = B); // Buggy guard for pre-fix model\n    }\n    int can_consume = (s.n  0);\n\n    // --- Explore Enabled Transitions ---\n    // Explore producer transition if enabled\n    if (can_produce) {\n        State next_s = s;\n        // Producer writes item Np to buffer at index p\n        next_s.buffer[next_s.p] = next_s.Np;\n        \n        // Update producer state variables\n        next_s.p = (next_s.p + 1) % B;\n        next_s.n = next_s.n + 1;\n        next_s.Np = next_s.Np + 1;\n        \n        if (!model_check_dfs(next_s, depth + 1, B, S, is_postfix)) {\n            return 0; // Violation found in this path, propagate failure.\n        }\n    }\n\n    // Explore consumer transition if enabled\n    if (can_consume) {\n        // Correctness check: value at consumer index must match next expected consumed item.\n        if (s.buffer[s.c] != s.Nc) {\n            return 0; // Data integrity violation found.\n        }\n\n        State next_s = s;\n        // Update consumer state variables\n        if (is_postfix) {\n            next_s.c = (next_s.c + 1) % B; // Correct modulus for post-fix\n        } else {\n            next_s.c = (next_s.c + 1) % (B + 1); // Buggy modulus for pre-fix\n        }\n        next_s.n = next_s.n - 1;\n        next_s.Nc = next_s.Nc + 1;\n        \n        if (!model_check_dfs(next_s, depth + 1, B, S, is_postfix)) {\n            return 0; // Violation found in this path, propagate failure.\n        }\n    }\n\n    // If execution reaches here, all explored paths from this state (up to depth S)\n    // are valid. This also correctly handles terminal (deadlock) states where\n    // neither transition is enabled by implicitly returning success.\n    return 1;\n}\n```", "id": "3687126"}]}