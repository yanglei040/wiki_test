{"hands_on_practices": [{"introduction": "Before diving into the complexities of threads and locks, it is invaluable to first understand the pure logic of a scheduling policy. This exercise challenges you to implement a deterministic scheduler for the readers-writers problem from a formal set of rules, focusing on writer preference [@problem_id:2422634]. By simulating the system over discrete time steps, you will build a concrete intuition for the state transitions and fairness constraints that govern how readers and writers are granted access to a shared resource.", "problem": "You are given a shared-memory parallel system with a single logical shared object accessed by two types of operations: readers and writers. Each operation is a request characterized by an arrival time and a service duration, both measured in discrete unitless time steps. An operation, once started, occupies the shared object over a half-open interval from its start time to its start time plus its duration, that is, over the interval $\\left[ s_i, s_i + d_i \\right)$ where $s_i$ is the start time and $d_i$ is the duration.\n\nThe system must satisfy the following semantics and constraints.\n\n1) Safety constraints. Let $R(t)$ denote the number of active readers at time $t$ and let $W(t) \\in \\{0,1\\}$ denote the number of active writers at time $t$. The system must ensure that for every time $t$, if $W(t) = 1$ then $R(t) = 0$, and additionally there is never more than one writer active simultaneously. Multiple readers may be active concurrently when no writer is active.\n\n2) Fairness constraint for writers (writer starvation freedom). Once a writer has arrived and is waiting to start, no new reader may start until there are no waiting writers. Formally, if at time $t$ there exists a writer $j$ with arrival time $a_j \\le t$ whose start time $s_j$ satisfies $s_j > t$, then no reader may start at time $t$.\n\n3) Deterministic scheduling semantics. Time progresses over a discrete set of decision times. At each decision time $t$, the following ordering within the instant $t$ is assumed: first, all operations that have end time exactly $t$ complete and release the resource; second, all operations whose arrival time equals $t$ are considered to have arrived and joined the waiting set; third, new starts are determined according to the following rule:\n   a) If there is at least one waiting writer and there are no active readers and no active writer, then the unique earliest-arrived waiting writer must start at time $t$.\n   b) Otherwise, if there are no waiting writers and no active writer, then all waiting readers must start at time $t$.\n   c) Otherwise, no new operation starts at time $t$.\nIn case multiple requests share the same arrival time, their relative order is the order given in the input for that test case. An operation’s start time must be no earlier than its arrival time.\n\nYour task is to implement a program that, given a finite list of requests for each test case, constructs start times for all requests that obey the semantics above and then computes the following three quantities for each test case:\n- A boolean indicating whether the produced schedule satisfies both the safety constraints and the writer fairness constraint defined above.\n- The maximum number of concurrent readers, that is, $\\max_{t} R(t)$ over the schedule.\n- The makespan, defined as the difference between the latest completion time $\\max_i \\left( s_i + d_i \\right)$ and the earliest arrival time $\\min_i a_i$.\n\nTest suite. Use the following $5$ test cases. Each test case is a list of requests. Each request is a triple $(\\text{type}, a, d)$ where $\\text{type} \\in \\{\\text{R}, \\text{W}\\}$, $a$ is the arrival time, and $d$ is the duration. For equal arrival times within a test case, the order in which the requests are listed below is the required tie-breaking order.\n\n- Test case $1$:\n  $[(\\text{R},\\, 0,\\, 5),\\, (\\text{R},\\, 1,\\, 3),\\, (\\text{W},\\, 2,\\, 4),\\, (\\text{R},\\, 6,\\, 2),\\, (\\text{W},\\, 6,\\, 1)]$.\n\n- Test case $2$:\n  $[(\\text{R},\\, 0,\\, 2),\\, (\\text{R},\\, 0,\\, 2),\\, (\\text{R},\\, 1,\\, 1)]$.\n\n- Test case $3$:\n  $[(\\text{W},\\, 0,\\, 2),\\, (\\text{W},\\, 1,\\, 2),\\, (\\text{W},\\, 3,\\, 1)]$.\n\n- Test case $4$:\n  $[(\\text{R},\\, 0,\\, 5),\\, (\\text{R},\\, 1,\\, 5),\\, (\\text{W},\\, 2,\\, 2),\\, (\\text{R},\\, 2,\\, 1),\\, (\\text{R},\\, 3,\\, 1)]$.\n\n- Test case $5$:\n  $[(\\text{R},\\, 0,\\, 1),\\, (\\text{W},\\, 0,\\, 1)]$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and must itself be a three-element list $[\\text{valid}, \\text{max\\_readers}, \\text{makespan}]$ in that order, with no spaces. For example, a valid output shape is\n$[[\\text{True},2,7],[\\text{False},1,3],[\\text{True},3,5],[\\text{True},2,4],[\\text{True},1,1]]$\nbut with the actual values determined by your implementation for the specified test suite.", "solution": "The problem requires the simulation of a deterministic scheduling policy for a readers-writers problem on a shared resource. The solution involves two main stages: first, simulating the system over discrete time steps to generate a schedule, and second, analyzing this schedule to compute the required metrics.\n\n**1. Simulation of the Scheduling Policy**\n\nThe core of the task is to implement a discrete-time simulator that strictly adheres to the given scheduling semantics. The state of the system at any time $t$ can be described by the set of active operations and the set of waiting operations.\n\nLet's formalize the state variables:\n- A list of unprocessed requests, sorted by their arrival times $a_i$ and, for ties, by their order in the input. Each request `i` is a tuple of (type, $a_i$, $d_i$). We will augment this with a unique ID and a field for the start time $s_i$.\n- A queue of waiting readers, `waiting_readers`.\n- A queue of waiting writers, `waiting_writers`, maintained in first-in-first-out (FIFO) order based on arrival.\n- A list of active readers, `active_readers`.\n- A variable for the single active writer, `active_writer`.\n\nThe simulation proceeds by incrementing a time variable $t$ starting from $t=0$. The simulation terminates when all requests have arrived, started, and completed.\n\nAt each time step $t$, the following sequence of actions must be performed, as specified in the problem statement:\n\n**Step 1: Process Completions**\nAny active operation `i` whose completion time $s_i + d_i$ is equal to $t$ finishes its execution.\n- If an active writer `j` has $s_j + d_j = t$, the resource is released by setting `active_writer` to null.\n- Any active readers `k` with $s_k + d_k = t$ are removed from the `active_readers` list.\n\n**Step 2: Process Arrivals**\nAll requests `i` with an arrival time $a_i = t$ are moved from the unprocessed list to the appropriate waiting queue (`waiting_readers` or `waiting_writers`). The tie-breaking rule (input order for requests with the same arrival time) must be respected when adding to the queues.\n\n**Step 3: Make Scheduling Decisions**\nNew operations are started based on the current state of active and waiting queues, following a strict set of rules:\n- **Rule (a):** If `waiting_writers` is not empty AND `active_readers` is empty AND `active_writer` is null, the earliest-arrived writer from `waiting_writers` is dequeued and started. Its start time $s_i$ is set to $t$, and it becomes the `active_writer`.\n- **Rule (b):** Otherwise, if `waiting_writers` is empty AND `active_writer` is null, all readers in `waiting_readers` are started. For each of these readers, its start time $s_i$ is set to $t$, and it is moved to the `active_readers` list. The `waiting_readers` queue is then cleared.\n- **Rule (c):** In all other cases (e.g., the resource is held by a writer, or held by readers while a writer is waiting), no new operation can start at time $t$.\n\nThis `t++` simulation loop continues until all requests are completed.\n\n**2. Analysis of the Generated Schedule**\n\nOnce the simulation is complete, all requests will have an assigned start time $s_i$. We then analyze this complete schedule to compute three quantities for each test case.\n\n**A. Schedule Validity**\nThe problem requires a boolean indicating if the generated schedule satisfies the safety and writer-fairness constraints. The provided scheduling rules are designed to produce a valid schedule by construction. Therefore, this check serves as a verification of the simulator's implementation.\n- **Safety Check:** A schedule is safe if at no time $t$ a writer is active concurrently with any other operation (reader or writer), and there is never more than one active writer. This can be verified by iterating through time and checking the sets of active operations.\n- **Fairness Check:** The writer-starvation-freedom rule states that no new reader may start at time $t$ if a writer is waiting. This is checked by examining each reader's start time $s_k$. At $t = s_k$, we verify that there was no writer `j` for which $a_j \\le s_k$ and $s_j > s_k$.\n\nIf both checks pass, the schedule is valid. Given the deterministic rules, this should always be `True` for a correct implementation.\n\n**B. Maximum Concurrent Readers**\nThis is the maximum value of $R(t)$ over the entire duration of the schedule, where $R(t)$ is the number of active readers at time $t$. This can be computed by analyzing the schedule. An efficient method is to create a list of `START_READER` and `END_READER` events at times $s_i$ and $s_i+d_i$ respectively. By sorting these events and sweeping through time, we can track the current number of active readers and find its maximum.\n\n**C. Makespan**\nThe makespan is defined as the total time elapsed from the first arrival to the last completion. It is calculated as:\n$$\n\\text{Makespan} = \\left( \\max_{i} (s_i + d_i) \\right) - \\left( \\min_{i} a_i \\right)\n$$\nThe minimum arrival time $\\min(a_i)$ is found from the input data. The maximum completion time $\\max(s_i + d_i)$ is determined from the generated schedule.\n\nBy following this procedure for each test case, we can systematically derive the required results. The use of a simple time-stepping simulation ensures a direct and faithful implementation of the problem's formal specification.", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the readers-writers scheduling problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        [('R', 0, 5), ('R', 1, 3), ('W', 2, 4), ('R', 6, 2), ('W', 6, 1)],\n        # Test case 2\n        [('R', 0, 2), ('R', 0, 2), ('R', 1, 1)],\n        # Test case 3\n        [('W', 0, 2), ('W', 1, 2), ('W', 3, 1)],\n        # Test case 4\n        [('R', 0, 5), ('R', 1, 5), ('W', 2, 2), ('R', 2, 1), ('R', 3, 1)],\n        # Test case 5\n        [('R', 0, 1), ('W', 0, 1)],\n    ]\n\n    all_results = []\n    for case_idx, case_data in enumerate(test_cases):\n        # 1. Initialize requests with unique IDs and start times\n        requests = []\n        for i, (req_type, arrival, duration) in enumerate(case_data):\n            requests.append({\n                'id': i,\n                'type': req_type,\n                'a': arrival,\n                'd': duration,\n                's': -1,  # Start time, -1 indicates not started\n            })\n\n        # 2. Simulation\n        time = 0\n        num_completed = 0\n        total_requests = len(requests)\n        \n        arrived_but_not_waiting_requests = sorted(requests, key=lambda r: (r['a'], r['id']))\n        arrived_idx = 0\n\n        waiting_readers = deque()\n        waiting_writers = deque()\n        active_readers = []\n        active_writer = None\n\n        while num_completed < total_requests:\n            # Step 1: Process completions at the beginning of time t\n            completed_this_step = []\n            if active_writer and (active_writer['s'] + active_writer['d'] == time):\n                completed_this_step.append(active_writer)\n                active_writer = None\n\n            remaining_active_readers = []\n            for r in active_readers:\n                if r['s'] + r['d'] == time:\n                    completed_this_step.append(r)\n                else:\n                    remaining_active_readers.append(r)\n            active_readers = remaining_active_readers\n            \n            num_completed += len(completed_this_step)\n\n            # Step 2: Process arrivals at time t\n            while arrived_idx < total_requests and arrived_but_not_waiting_requests[arrived_idx]['a'] == time:\n                req = arrived_but_not_waiting_requests[arrived_idx]\n                if req['type'] == 'R':\n                    waiting_readers.append(req)\n                else: # 'W'\n                    waiting_writers.append(req)\n                arrived_idx += 1\n\n            # Step 3: Make scheduling decisions\n            # Rule a: Start a writer if possible\n            if waiting_writers and not active_readers and not active_writer:\n                writer_to_start = waiting_writers.popleft()\n                writer_to_start['s'] = time\n                active_writer = writer_to_start\n            # Rule b: Otherwise, start readers if possible\n            elif not waiting_writers and not active_writer:\n                while waiting_readers:\n                    reader_to_start = waiting_readers.popleft()\n                    reader_to_start['s'] = time\n                    active_readers.append(reader_to_start)\n            # Rule c: Otherwise, wait\n            \n            time += 1\n        \n        # 3. Analysis of the schedule\n        schedule = requests\n        is_valid = True\n        \n        # Safety and Max Readers calculation\n        max_time = 0\n        if schedule:\n            max_time = max(r['s'] + r['d'] for r in schedule)\n\n        max_readers_count = 0\n        for t in range(max_time):\n            current_readers = [r for r in schedule if r['type'] == 'R' and r['s'] <= t < r['s'] + r['d']]\n            current_writers = [r for r in schedule if r['type'] == 'W' and r['s'] <= t < r['s'] + r['d']]\n            \n            num_r = len(current_readers)\n            num_w = len(current_writers)\n            \n            max_readers_count = max(max_readers_count, num_r)\n\n            if num_w > 1 or (num_w > 0 and num_r > 0):\n                is_valid = False\n                break\n        \n        # Fairness check\n        if is_valid:\n            for reader in schedule:\n                if reader['type'] == 'R':\n                    start_time = reader['s']\n                    for writer in schedule:\n                        if writer['type'] == 'W':\n                            # Writer was waiting if it arrived at or before reader start, and started after\n                            if writer['a'] <= start_time and writer['s'] > start_time:\n                                is_valid = False\n                                break\n                    if not is_valid:\n                        break\n        \n        # Makespan calculation\n        min_arrival_time = min(r['a'] for r in schedule) if schedule else 0\n        max_completion_time = max(r['s'] + r['d'] for r in schedule) if schedule else 0\n        makespan = max_completion_time - min_arrival_time\n\n        all_results.append([is_valid, max_readers_count, makespan])\n\n    # Final formatting\n    result_str = \",\".join([f\"[{v},{r},{m}]\" for v, r, m in all_results])\n    print(f\"[{result_str}]\")\n\n\nsolve()\n```", "id": "2422634"}, {"introduction": "Implementing concurrency control with primitives like semaphores requires careful attention to detail, as subtle bugs can arise from the interleaving of threads. This exercise presents a flawed semaphore-based solution and asks you to pinpoint the specific execution sequence that leads to a safety violation [@problem_id:3687766]. This practice will sharpen your ability to reason like a preemptive scheduler, helping you identify and prevent critical race conditions in your own concurrent code.", "problem": "Consider the classic Readers-Writers coordination problem. Mutual exclusion requires that no Reader executes its read critical section concurrently with a Writer executing its write critical section. Assume the following foundational model and definitions as the base of reasoning:\n- A semaphore operation $P(x)$ (also called wait) is atomic; if the semaphore counter is $0$, the caller blocks; otherwise it decrements the counter by $1$ and returns.\n- A semaphore operation $V(x)$ (also called signal) is atomic; it increments the counter by $1$ and, if there is at least one blocked thread on that semaphore, exactly one blocked thread becomes ready to run.\n- A binary semaphore initialized to $1$ provides mutual exclusion for the protected region bounded by $P(\\cdot)$ and $V(\\cdot)$.\n- A scheduler may preempt a running thread and switch to a ready thread between any two sequential instructions that are not part of the same atomic $P(\\cdot)$ or $V(\\cdot)$ operation. There is no preemption inside a single atomic $P(\\cdot)$ or $V(\\cdot)$.\n- Memory is sequentially consistent with respect to program order and atomic semaphore operations.\n\nYou are given the following flawed implementation that attempts to provide Writer-preference using semaphores. Shared state and initial values:\n- Binary semaphore $wr\\_lock = 1$ guarding the Writer’s critical section.\n- Binary semaphore $m = 1$ guarding shared variables.\n- Counting semaphore $read\\_ok = 0$ used to release blocked Readers.\n- Integer $waiting = 0$.\n- Boolean $writer\\_active = \\text{false}$.\n\nReader code (executed by each Reader thread):\n1. $P(m)$\n2. If $(writer\\_active)$ then $waiting \\leftarrow waiting + 1$; $V(m)$; $P(read\\_ok)$; else $V(m)$\n3. Execute read critical section (denoted $read()$)\n\nWriter code (executed by each Writer thread):\n1. $P(wr\\_lock)$\n2. $P(m)$; $writer\\_active \\leftarrow \\text{true}$; $V(m)$\n3. Execute write critical section (denoted $write()$)\n4. $P(m)$\n5. While $(waiting > 0)$ do $V(read\\_ok)$; $waiting \\leftarrow waiting - 1$ end while\n6. $writer\\_active \\leftarrow \\text{false}$; $V(m)$\n7. $V(wr\\_lock)$\n\nThe bug is that the Writer signals Readers in step $5$ before releasing the Writer lock in step $7$. Under which of the following interleavings does this bug lead to a mutual exclusion violation that only occurs under preemption, i.e., a Reader runs its $read()$ while a Writer is still inside the region demarcated by $P(wr\\_lock)$ and $V(wr\\_lock)$?\n\nAssume a single Writer $W$ and a single Reader $R_1$, both starting from the initial state $wr\\_lock = 1$, $m = 1$, $read\\_ok = 0$, $waiting = 0$, and $writer\\_active = \\text{false}$. All $P(\\cdot)$ and $V(\\cdot)$ operations are atomic as defined above.\n\nA. Interleaving with preemption immediately after the Writer performs the first $V(read\\_ok)$ in step $5$:\n- Step $1$: $W$ executes $P(wr\\_lock)$ and enters its write critical section.\n- Step $2$: $W$ executes $P(m)$; sets $writer\\_active \\leftarrow \\text{true}$; executes $V(m)$.\n- Step $3$: $R_1$ executes $P(m)$; observes $writer\\_active = \\text{true}$; sets $waiting \\leftarrow waiting + 1$; executes $V(m)$; executes $P(read\\_ok)$ and blocks because $read\\_ok = 0$.\n- Step $4$: $W$ completes $write()$; executes $P(m)$; in step $5$ executes $V(read\\_ok)$ once (so $read\\_ok$ transitions from $0$ to $1$ and unblocks one Reader); decrements $waiting \\leftarrow waiting - 1$.\n- Step $5$: The scheduler preempts $W$ before $W$ executes $V(wr\\_lock)$ in step $7$; the just-unblocked $R_1$ is scheduled and returns from $P(read\\_ok)$.\n- Step $6$: $R_1$ proceeds to execute $read()$ while $W$ still holds $wr\\_lock$ (i.e., $W$ has not yet executed $V(wr\\_lock)$).\n\nB. Interleaving where the Writer completes step $7$ before any Reader runs:\n- Step $1$: $W$ executes through steps $1$–$7$, including completing $write()$, step $5$ signaling all Readers, and then executes $V(wr\\_lock)$ in step $7$.\n- Step $2$: Only after $V(wr\\_lock)$ does $R_1$ get scheduled, returns from $P(read\\_ok)$, and executes $read()$.\n\nC. Interleaving where the Reader arrives after the Writer has signaled but before the Writer releases $wr\\_lock$, but the Reader still blocks:\n- Step $1$: $W$ executes steps $1$–$4$.\n- Step $2$: $W$ executes step $5$ but $waiting = 0$ so no $V(read\\_ok)$ occurs.\n- Step $3$: $R_1$ executes $P(m)$; observes $writer\\_active = \\text{true}$; increments $waiting$; executes $V(m)$; executes $P(read\\_ok)$ and blocks.\n- Step $4$: $W$ executes step $6$, then step $7$; only afterwards is $R_1$ released by a later $V(read\\_ok)$.\n\nD. Interleaving with preemption at a point where no Reader is yet blocked on $read\\_ok$:\n- Step $1$: $W$ executes $P(wr\\_lock)$ and then is preempted before setting $writer\\_active$.\n- Step $2$: $R_1$ executes $P(m)$; observes $writer\\_active = \\text{false}$; executes $V(m)$; proceeds directly to $read()$.\n- Step $3$: $W$ resumes, sets $writer\\_active \\leftarrow \\text{true}$, and executes $write()$ while $R_1$ is still in $read()$.\n\nWhich option best demonstrates the mutual exclusion violation caused by the bug under preemption, consistent with the specified atomicity and scheduling model?", "solution": "### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe problem provides the following definitions, shared state, initial values, and code for a Readers-Writers coordination problem.\n\n- **Semaphore Operations**:\n  - $P(x)$ (wait): Atomic operation. If semaphore counter is $0$, the caller blocks. Otherwise, it decrements the counter by $1$ and returns.\n  - $V(x)$ (signal): Atomic operation. It increments the counter by $1$. If any threads are blocked on the semaphore, exactly one becomes ready.\n- **Mutual Exclusion**: A binary semaphore initialized to $1$ provides mutual exclusion for a region bounded by $P(\\cdot)$ and $V(\\cdot)$.\n- **Scheduler**: The scheduler can preempt a thread between any two non-atomic instructions. Preemption does not occur within an atomic $P(\\cdot)$ or $V(\\cdot)$ operation.\n- **Memory Model**: Sequentially consistent.\n\n- **Shared State and Initial Values**:\n  - Binary semaphore $wr\\_lock = 1$.\n  - Binary semaphore $m = 1$.\n  - Counting semaphore $read\\_ok = 0$.\n  - Integer $waiting = 0$.\n  - Boolean $writer\\_active = \\text{false}$.\n\n- **Reader Code**:\n  1. $P(m)$\n  2. If $(writer\\_active)$ then $waiting \\leftarrow waiting + 1$; $V(m)$; $P(read\\_ok)$; else $V(m)$\n  3. Execute read critical section ($read()$)\n\n- **Writer Code**:\n  1. $P(wr\\_lock)$\n  2. $P(m)$; $writer\\_active \\leftarrow \\text{true}$; $V(m)$\n  3. Execute write critical section ($write()$)\n  4. $P(m)$\n  5. While $(waiting > 0)$ do $V(read\\_ok)$; $waiting \\leftarrow waiting - 1$ end while\n  6. $writer\\_active \\leftarrow \\text{false}$; $V(m)$\n  7. $V(wr\\_lock)$\n\n- **Question Context**:\n  - The implementation is flawed. The bug is identified as the Writer signaling Readers (step $5$) before releasing the writer lock (step $7$).\n  - The task is to identify which of the provided interleavings demonstrates a mutual exclusion violation (a Reader in $read()$ while a Writer is in the region $P(wr\\_lock)...V(wr\\_lock)$) caused by this specific bug.\n  - The scenario involves a single Writer ($W$) and a single Reader ($R_1$).\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement is evaluated against the validation criteria:\n\n- **Scientifically Grounded**: The problem is based on fundamental and standard concepts in computer science, specifically operating systems and concurrency (Readers-Writers problem, semaphores, preemption, race conditions). The presented code is a plausible, albeit flawed, algorithm. This criterion is met.\n- **Well-Posed**: The problem is well-posed. It provides a complete and self-contained description of the system, including initial states, code logic, and operational semantics of primitives ($P$ and $V$). It asks for the analysis of specific, explicitly described execution traces (interleavings) to identify a well-defined failure condition (mutual exclusion violation). A unique, verifiable answer can be derived. This criterion is met.\n- **Objective**: The problem is stated using precise, formal, and objective language common in computer science. Terms like \"atomic\", \"preemption\", \"mutual exclusion\", and the code itself are unambiguous. This criterion is met.\n- **No Flaws**:\n  1. **Scientific/Factual Unsoundness**: None. The model of concurrency is standard.\n  2. **Non-Formalizable/Irrelevant**: None. The problem is a formal analysis of a concurrent algorithm.\n  3. **Incomplete/Contradictory Setup**: None. All necessary information for a trace analysis is provided.\n  4. **Unrealistic/Infeasible**: None. The described interleavings are possible in a preemptive multitasking environment.\n  5. **Ill-Posed/Poorly Structured**: None. The question is direct and answerable through rigorous analysis.\n  6. **Pseudo-Profound/Trivial**: None. The problem requires careful step-by-step state tracking and understanding of the interaction between concurrency primitives, which is a non-trivial reasoning task.\n  7. **Outside Scientific Verifiability**: None. The behavior for each interleaving is deterministic and verifiable by tracing the algorithm's state.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. Proceeding to the solution.\n\n### Solution Derivation\n\nThe problem requires identifying the interleaving that demonstrates a mutual exclusion violation caused by a specific bug: the Writer executes $V(read\\_ok)$ in its step $5$ *before* executing $V(wr\\_lock)$ in step $7$. A mutual exclusion violation occurs if a Reader enters its critical section, $read()$, while a Writer is inside its critical section, defined as the code section between $P(wr\\_lock)$ and $V(wr\\_lock)$. We will analyze each option by tracing the state of the system.\n\nThe initial state is: $wr\\_lock = 1$, $m = 1$, $read\\_ok = 0$, $waiting = 0$, $writer\\_active = \\text{false}$.\n\n### Option-by-Option Analysis\n\n**Option A: Interleaving with preemption immediately after the Writer performs the first $V(read\\_ok)$ in step $5$**\n\n1.  **$W$ executes $P(wr\\_lock)$**: $wr\\_lock$ becomes $0$. $W$ is now in its critical section.\n2.  **$W$ executes $P(m)$, sets $writer\\_active \\leftarrow \\text{true}$, then $V(m)$**: The state becomes $m=1$, $writer\\_active=\\text{true}$.\n3.  **$R_1$ executes**: $R_1$ performs $P(m)$ ($m$ becomes $0$). It evaluates 'if $(writer\\_active)$', which is true. It increments $waiting$ to $1$, performs $V(m)$ ($m$ becomes $1$), and then executes $P(read\\_ok)$. Since $read\\_ok$ is $0$, $R_1$ blocks.\n4.  **$W$ executes**: $W$ completes its $write()$. It then executes $P(m)$ ($m$ becomes $0$). The condition $(waiting > 0)$ in step $5$ is true. $W$ executes $V(read\\_ok)$. This operation increments $read\\_ok$ and, since $R_1$ is blocked on this semaphore, $R_1$ is unblocked and moved to the ready queue. $W$ then decrements $waiting$ to $0$.\n5.  **Preemption**: The scheduler preempts $W$ at this point. Crucially, $W$ has not yet executed step $6$ ($V(m)$) or step $7$ ($V(wr\\_lock)$). Thus, $W$ still holds the lock $wr\\_lock$ and is inside its critical section.\n6.  **$R_1$ executes**: The scheduler runs the now-ready $R_1$. $R_1$'s $P(read\\_ok)$ call completes successfully. The next statement for $R_1$ is to execute its critical section, $read()$.\n\nAt this moment, $R_1$ is executing $read()$ while $W$ is still inside its critical section (it has not yet executed $V(wr\\_lock)$). This is a clear mutual exclusion violation. This violation is a direct result of $W$ signaling $R_1$ (step $5$) before leaving its own critical section (step $7$), combined with the preemption that allows $R_1$ to run.\n\n**Verdict on A: Correct.** This option perfectly demonstrates the failure mode caused by the specified bug.\n\n**Option B: Interleaving where the Writer completes step $7$ before any Reader runs**\n\n1.  **$W$ executes through steps $1$–$7$**: This scenario assumes $W$ runs without preemption in favor of $R_1$. After step $5$, any waiting Readers are signaled and become ready. In step $7$, $W$ executes $V(wr\\_lock)$, which sets $wr\\_lock$ to $1$ and formally exits the critical section.\n2.  **$R_1$ executes**: Only after $W$ has left its critical section does $R_1$ get scheduled. It returns from $P(read\\_ok)$ and executes $read()$.\n\nAt the time $R_1$ executes $read()$, $W$ is no longer in its critical section. There is no concurrent access and no mutual exclusion violation.\n\n**Verdict on B: Incorrect.** This scenario shows correct, sequential execution, not a violation.\n\n**Option C: Interleaving where the Reader arrives after the Writer has signaled but before the Writer releases $wr\\_lock$, but the Reader still blocks**\n\n1.  **$W$ executes steps $1–4$**: After step $4$, $W$ has executed $P(m)$ and holds the mutex $m$.\n2.  **$W$ executes step $5$**: In this hypothetical scenario, $waiting = 0$, so the loop is skipped.\n3.  **$R_1$ executes $P(m)$...**: This is stated to happen now. However, $W$ currently holds the mutex $m$ (from its step $4$). Therefore, $R_1$ *must* block on its call to $P(m)$ in its step $1$. It cannot proceed to check $writer\\_active$. The described sequence of events is impossible under the rules of semaphores.\n\nThe interleaving described in this option is logically inconsistent with the provided code and semaphore semantics.\n\n**Verdict on C: Incorrect.** The scenario is not possible.\n\n**Option D: Interleaving with preemption at a point where no Reader is yet blocked on $read\\_ok$**\n\n1.  **$W$ executes $P(wr\\_lock)$ and is preempted**: $wr\\_lock$ becomes $0$. $W$ is in its critical section, but has not yet set $writer\\_active$ to true.\n2.  **$R_1$ executes**: $R_1$ executes $P(m)$ ($m$ becomes $0$). It evaluates 'if $(writer\\_active)$', which is currently `false`. $R_1$ takes the `else` branch, executes $V(m)$ ($m$ becomes $1$), and proceeds immediately to its critical section, $read()$.\n3.  **$W$ resumes**: $W$ now executes its step $2$, setting $writer\\_active \\leftarrow \\text{true}$, and then proceeds to its critical section, $write()$.\n\nAt this point, $R_1$ is in $read()$ and $W$ is in $write()$. This is a mutual exclusion violation. However, the question asks for the violation caused by **\"this bug\"**, which is explicitly defined as the premature signaling in step $5$. The violation in Option D is caused by a *different* bug: a race condition where a Writer acquires the $wr\\_lock$ before setting the $writer\\_active$ flag that Readers check. This violation occurs completely independently of the logic in the Writer's step $5$. Therefore, this option does not demonstrate the bug the question is focused on.\n\n**Verdict on D: Incorrect.** While it shows a valid mutual exclusion violation, it is not caused by the specific bug the problem statement asks to be demonstrated.\n\n### Conclusion\n\nOption A is the only interleaving that demonstrates a mutual exclusion violation as a direct consequence of the specified bug—the writer signaling waiting readers before it has released its own lock on the resource. The combination of this premature signal and a subsequent preemption allows a reader to enter its critical section while the writer is still in its own.", "answer": "$$\\boxed{A}$$", "id": "3687766"}, {"introduction": "Condition variables (CVs) provide a powerful mechanism for thread coordination, but their correct use depends on understanding their specific semantics, including Mesa-style signaling and the possibility of spurious wake-ups. This exercise explores why a simple conditional check is insufficient and demonstrates the necessity of the canonical `while` loop pattern for correctness [@problem_id:3687757]. Mastering this pattern is a crucial step toward writing robust and reliable concurrent programs that use condition variables.", "problem": "You are designing the synchronization for the classical readers-writers problem in an Operating System (OS), with writer preference and Condition Variables (CV). The shared state includes a mutex $m$, CVs $canRead$ and $canWrite$, an integer $activeReaders$, an integer $waitingWriters$, and a boolean $writerActive$. The semantics are as follows: (i) $wait(cv, m)$ atomically releases $m$ and blocks the calling thread; when the wait returns, $m$ has been re-acquired, (ii) $signal(cv)$ or $broadcast(cv)$ may wake one or more waiters, but spurious wake-ups are permitted (a waiting thread may wake without any $signal$ or $broadcast$), and (iii) Mesa-style CV semantics apply: a signaled thread only runs after the signaling thread releases $m$, so the condition may have changed before the waiter runs.\n\nThe required safety property is that at most one writer is active and no reader can read while a writer is active. Formally, when $writerActive = \\text{true}$, then $activeReaders = 0$. The writer-preference policy requires that new readers do not enter if any writer is active or waiting. Formally, a reader may proceed into the critical section only if $\\lnot writerActive \\land waitingWriters = 0$.\n\nConsider two shapes of reader-entry code, written informally using the shared state variables above. Both execute under $m$ held and increment $activeReaders$ just before returning to the caller.\n\n- Single-check version: if the admission predicate is false, execute $wait(canRead, m)$ once, then proceed to increment $activeReaders$.\n- Loop version: while the admission predicate is false, execute $wait(canRead, m)$, then when the loop exits, proceed to increment $activeReaders$.\n\nYour task is to reason from the definitions above to choose the correct statements about how to guard reader entry in the presence of spurious wake-ups and writer preference.\n\nWhich of the following options are correct?\n\nA. The loop guard that preserves safety and writer preference is: while $\\big(writerActive \\lor waitingWriters > 0\\big)$, call $wait(canRead, m)$. Only when the loop exits should $activeReaders \\leftarrow activeReaders + 1$.\n\nB. The loop guard can be weakened to: while $\\big(writerActive \\land waitingWriters > 0\\big)$, call $wait(canRead, m)$, because if only one of the two is true, no violation can occur.\n\nC. The single-check version with a single if-test is safe if it checks $\\big(writerActive \\lor waitingWriters > 0\\big)$ once before a single $wait(canRead, m)$, because $wait$ re-acquires $m$ before returning and thus the condition cannot change unexpectedly.\n\nD. There exists a schedule showing that the single-check version fails under spurious wake-ups: at time $t_1$, a writer sets $writerActive \\leftarrow \\text{true}$ and holds $m$; at time $t_2$, a reader $R$ executes the single if-test, finds $\\big(writerActive \\lor waitingWriters > 0\\big)$ true, and calls $wait(canRead, m)$; at time $t_3$, a spurious wake-up occurs, $R$ returns from $wait$ with $m$ held while $writerActive$ is still $\\text{true}$; at time $t_4$, because there is no re-check, $R$ increments $activeReaders$ and proceeds concurrently with the writer, violating safety.\n\nE. Using $signal(canRead)$ instead of $broadcast(canRead)$ when a writer releases the resource eliminates the need for a loop in the reader code, because at most one reader will wake and the state will be stable when it runs.\n\nSelect all that apply.", "solution": "The user wants a critical analysis of synchronization strategies for the readers-writers problem with writer preference, using Mesa-style condition variables. I will first validate the problem statement and then, finding it valid, proceed to a detailed analysis of each option.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n\n-   **Problem Domain**: Classical readers-writers problem in an Operating System.\n-   **Synchronization Policy**: Writer preference.\n-   **Primitives**: Mutex $m$ and Condition Variables (CVs) $canRead$ and $canWrite$.\n-   **Shared State**: Integer $activeReaders$, integer $waitingWriters$, boolean $writerActive$.\n-   **CV Semantics**:\n    -   (i) $wait(cv, m)$ atomically releases $m$, blocks, and re-acquires $m$ upon return.\n    -   (ii) Spurious wake-ups are permitted.\n    -   (iii) Mesa-style semantics apply: a signaled thread resumes execution only after the signaling thread releases the mutex $m$.\n-   **Safety Property**: If $writerActive = \\text{true}$, then $activeReaders = 0$.\n-   **Writer-Preference Policy**: A reader may enter its critical section only if $\\lnot writerActive \\land waitingWriters = 0$.\n-   **Code Constructs to Compare**:\n    1.  **Single-check**: An `if` statement tests the admission predicate once before a potential $wait$.\n    2.  **Loop**: A `while` loop repeatedly tests the admission predicate before proceeding.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement is **valid**.\n-   It is **Scientifically Grounded** and **Objective**: The problem is a canonical computer science problem concerning concurrency control. The terminology (Mesa semantics, spurious wake-ups, mutex, condition variable) and the formal properties are standard and precisely defined within the field of operating systems.\n-   It is **Well-Posed**: The problem provides a complete set of rules (primitive semantics, safety properties, policies) and asks for an evaluation of specific implementation choices against these rules. This allows for a unique and logical analysis.\n-   There are no contradictions, ambiguities, or factual errors in the setup.\n\n### **Derivation and Solution**\n\nThe core of the problem lies in the interaction between the reader's admission condition and the semantics of Mesa-style condition variables.\n\n**Fundamental Principle of Mesa-style CVs:**\nThe problem states that (ii) spurious wake-ups are possible, and (iii) due to Mesa-style semantics, the condition that prompted a `signal` may no longer be true when the waiting thread finally re-acquires the mutex and runs. Both of these facts imply a crucial design principle: **upon waking from a $wait$ call, a thread cannot assume the desired condition is met.** It must re-evaluate the condition.\n\nThe standard and correct pattern to wait for a condition $P$ to become true using Mesa-style CVs is to place the $wait$ call inside a `while` loop:\n\n`lock(m);`\n`while (!P)`\n`    wait(cv, m);`\n`// ... proceed, P is guaranteed to be true here`\n`unlock(m);`\n\nAny implementation that uses a single `if` check before the $wait$ is inherently flawed, as it fails to re-check the condition after waking up.\n\n**Applying the Principle to the Problem:**\nThe writer-preference policy dictates that a reader can proceed only when the condition $P \\equiv (\\lnot writerActive \\land waitingWriters = 0)$ is true. The condition to wait, therefore, is $\\lnot P$. Using De Morgan's laws:\n$$ \\lnot(\\lnot writerActive \\land waitingWriters = 0) \\equiv (\\lnot(\\lnot writerActive) \\lor \\lnot(waitingWriters = 0)) $$\n$$ \\equiv (writerActive \\lor waitingWriters \\neq 0) $$\nAssuming $waitingWriters$ cannot be negative, this is equivalent to $(writerActive \\lor waitingWriters > 0)$.\n\nTherefore, the correct reader entry code must lock the mutex $m$, loop while $(writerActive \\lor waitingWriters > 0)$, and only after the loop terminates (when the condition to proceed is met) increment $activeReaders$.\n\n### **Option-by-Option Analysis**\n\n**A. The loop guard that preserves safety and writer preference is: while $\\big(writerActive \\lor waitingWriters > 0\\big)$, call $wait(canRead, m)$. Only when the loop exits should $activeReaders \\leftarrow activeReaders + 1$.**\n\n-   **Analysis**: This option describes the exact implementation derived from first principles. The `while` loop correctly handles both spurious wake-ups and the condition changes inherent in Mesa-style semantics by re-checking the predicate. The predicate itself, $writerActive \\lor waitingWriters > 0$, is the correct condition for a reader to wait, as it is the negation of the admission predicate $\\lnot writerActive \\land waitingWriters = 0$. Incrementing $activeReaders$ after the loop ensures a reader is only counted once it has been granted access, preserving the integrity of the shared state.\n-   **Verdict**: Correct.\n\n**B. The loop guard can be weakened to: while $\\big(writerActive \\land waitingWriters > 0\\big)$, call $wait(canRead, m)$, because if only one of the two is true, no violation can occur.**\n\n-   **Analysis**: This proposes an incorrect waiting condition. The loop would terminate if $\\lnot(writerActive \\land waitingWriters > 0)$ is true, which is equivalent to $\\lnot writerActive \\lor waitingWriters = 0$. This is not the required admission condition.\n    -   Case 1: If $writerActive$ is true and $waitingWriters = 0$, the loop condition is false. The reader would exit the loop and increment $activeReaders$, resulting in a state where $writerActive = \\text{true}$ and $activeReaders > 0$. This is a direct violation of the specified safety property.\n    -   Case 2: If $writerActive$ is false and $waitingWriters > 0$, the loop condition is false. The reader would exit the loop and proceed, violating the writer-preference policy which requires readers to wait for waiting writers.\n-   **Verdict**: Incorrect.\n\n**C. The single-check version with a single if-test is safe if it checks $\\big(writerActive \\lor waitingWriters > 0\\big)$ once before a single $wait(canRead, m)$, because $wait$ re-acquires $m$ before returning and thus the condition cannot change unexpectedly.**\n\n-   **Analysis**: This option defends the single-check version. Its reasoning is fundamentally flawed. While $wait(canRead, m)$ does re-acquire $m$, the period between the thread being signaled (or spuriously woken up) and it re-acquiring the lock is an interval where other threads can run. Another thread could have acquired $m$, changed the state (e.g., a new writer arrived and set $waitingWriters > 0$), and released $m$. Furthermore, a spurious wake-up provides no information about the state at all. A `while` loop is required to handle these cases; an `if` statement is insufficient and unsafe. The claim that \"the condition cannot change unexpectedly\" is false.\n-   **Verdict**: Incorrect.\n\n**D. There exists a schedule showing that the single-check version fails under spurious wake-ups: at time $t_1$, a writer sets $writerActive \\leftarrow \\text{true}$ and holds $m$; at time $t_2$, a reader $R$ executes the single if-test, finds $\\big(writerActive \\lor waitingWriters > 0\\big)$ true, and calls $wait(canRead, m)$; at time $t_3$, a spurious wake-up occurs, $R$ returns from $wait$ with $m$ held while $writerActive$ is still $\\text{true}$; at time $t_4$, because there is no re-check, $R$ increments $activeReaders$ and proceeds concurrently with the writer, violating safety.**\n\n-   **Analysis**: This option provides a concrete failure scenario for the single-check version. While the wording \"at time $t_1$, a writer... holds $m$\" and \"at time $t_2$, a reader $R$ executes\" is slightly imprecise (two threads cannot hold the same mutex simultaneously), the logical sequence of states it describes is valid and demonstrates a critical flaw. A more precise timeline would be: A writer acquires $m$, sets $writerActive \\leftarrow \\text{true}$, and releases $m$ to do work. Reader $R$ then acquires $m$, sees $writerActive$ is true, and calls $wait(canRead, m)$, releasing $m$. Then, a spurious wake-up occurs. $R$ re-acquires $m$. At this point, the writer is still active ($writerActive = \\text{true}$). The single-check code does not re-test the condition, so $R$ incorrectly proceeds to increment $activeReaders$ and enters the critical section. This leads to a state where $writerActive = \\text{true}$ and $activeReaders > 0$, a clear violation of the safety property. The scenario described is a classic example of why a `while` loop is necessary.\n-   **Verdict**: Correct.\n\n**E. Using $signal(canRead)$ instead of $broadcast(canRead)$ when a writer releases the resource eliminates the need for a loop in the reader code, because at most one reader will wake and the state will be stable when it runs.**\n\n-   **Analysis**: This option is incorrect for two primary reasons. First, the claim that \"the state will be stable when it runs\" is false under Mesa-style semantics. As established, another thread can change the state between the `signal` and the waiter's resumption. Second, it completely ignores the possibility of spurious wake-ups, which are independent of whether `signal` or `broadcast` is used. A spurious wake-up would still cause the single-check code to fail. Therefore, switching to $signal(canRead)$ does not remove the need for the `while` loop.\n-   **Verdict**: Incorrect.", "answer": "$$\\boxed{AD}$$", "id": "3687757"}]}