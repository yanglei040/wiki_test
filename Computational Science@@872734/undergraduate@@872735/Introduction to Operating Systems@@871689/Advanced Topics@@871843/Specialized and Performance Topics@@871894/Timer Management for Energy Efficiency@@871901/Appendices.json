{"hands_on_practices": [{"introduction": "At the heart of energy-efficient timer management lies a fundamental trade-off: the energy saved by skipping a processor wakeup versus the performance cost of delaying a task. This practice invites you to model this exact decision for a single low-priority timer, calculating the \"indifference point\" where the cost of waking up equals the cost of waiting. By working through this scenario [@problem_id:3689036], you will develop a quantitative framework for the energy-latency trade-offs that operating systems constantly navigate.", "problem": "A modern Operating System (OS) employs a tickless kernel with high-resolution timers to maximize idle residency and reduce energy use. Consider a single Central Processing Unit (CPU) that is currently in a deep idle state. The CPU has an idle power draw $P_{\\mathrm{idle}}$ and incurs energy $E_{\\mathrm{exit}}$ to exit deep idle and $E_{\\mathrm{entry}}$ to re-enter deep idle, for a total transition energy $E_{\\mathrm{trans}} = E_{\\mathrm{exit}} + E_{\\mathrm{entry}}$. A low-priority timer is scheduled at time $t$, and an independent mandatory event will occur at time $t + \\Delta$ where $\\Delta > 0$. The low-priority timer’s handler takes a fixed service time $\\tau$, and the mandatory event’s handler takes a fixed service time $\\sigma$. Assume both handlers consume active power $P_{\\mathrm{active}}$ while running and that their work and energy are independent of when they are executed.\n\nThe kernel must choose between two actions:\n- Wake at time $t$ to run the low-priority timer, then return to deep idle, and later wake again at time $t + \\Delta$ for the mandatory event.\n- Extend idle residency and defer the low-priority timer to $t + \\Delta$, so there is a single wake at $t + \\Delta$ that handles both the deferred timer and the mandatory event.\n\nThe kernel uses an energy-aware policy that minimizes a scalarized cost consisting of physical energy plus a weighted utility-loss for delaying the low-priority timer. Let $U(\\Delta)$ denote the utility loss incurred by deferring the low-priority timer by $\\Delta$, and suppose $U(\\Delta)$ is linear with slope $u'$ (in abstract utility units per second), so that $U(\\Delta) = u' \\Delta$. Let $\\lambda$ be the policy’s conversion factor (in Joules per utility unit) that maps utility loss into energy-equivalent cost. The scalarized cost is the sum of physical energy and $\\lambda U(\\Delta)$.\n\nStarting from the fundamental definition that energy equals power integrated over time, namely $E = \\int P(t)\\,dt$, derive a decision rule that compares the two actions and yields an indifference threshold $\\Delta^{*}$ at which the kernel is exactly indifferent between waking at $t$ or deferring to $t + \\Delta$. Then, using the following parameter values:\n- $E_{\\mathrm{exit}} = 2.5$ mJ,\n- $E_{\\mathrm{entry}} = 1.1$ mJ,\n- $\\lambda = 0.02$ J per utility unit,\n- $u' = 2$ utility units per second,\n\ncompute the numerical value of $\\Delta^{*}$. Express your final answer in milliseconds and round your answer to four significant figures. You may assume $P_{\\mathrm{idle}}$, $P_{\\mathrm{active}}$, $\\tau$, and $\\sigma$ are positive constants, and that deferring the low-priority timer affects only its timing (not its work content or energy when executed).", "solution": "The goal is to find the indifference threshold $\\Delta^{*}$ where the total scalarized cost of the two actions is equal. The scalarized cost is the sum of the physical energy consumed and the energy-equivalent cost of utility loss.\n\nLet's analyze the *difference* in cost between the two actions. The problem states that deferring the timer affects only its timing, not its work content or energy when executed. This implies that the energy consumed by the handlers themselves is the same for both actions and can be excluded from the comparison. We only need to compare the costs that differ: the transition energy and the utility loss.\n\n**Action 1: Wake at time $t$ (and again at $t+\\Delta$)**\n*   This action involves two separate wakeup events. Each wakeup requires a full transition cycle (exit from idle and re-entry to idle), costing $E_{\\text{trans}}$.\n*   The total transition energy cost is $2 \\times E_{\\text{trans}}$.\n*   The low-priority timer is serviced on time, so the delay is zero. The associated utility loss is $U(0) = 0$.\n*   The total scalarized cost attributable to this decision is $C_1 = 2 E_{\\text{trans}}$.\n\n**Action 2: Defer and wake at time $t+\\Delta$**\n*   This action involves only one wakeup event to service both timers.\n*   The total transition energy cost is $1 \\times E_{\\text{trans}}$.\n*   The low-priority timer is deferred by a duration of $\\Delta$. The utility loss is $U(\\Delta) = u' \\Delta$.\n*   The energy-equivalent cost of this utility loss is $\\lambda U(\\Delta) = \\lambda u' \\Delta$.\n*   The total scalarized cost attributable to this decision is $C_2 = E_{\\text{trans}} + \\lambda u' \\Delta$.\n\n**Indifference Point**\nThe indifference point $\\Delta^*$ is the value of $\\Delta$ for which the costs are equal, i.e., $C_1 = C_2$.\n$$\n2 E_{\\text{trans}} = E_{\\text{trans}} + \\lambda u' \\Delta^*\n$$\nSolving for $\\Delta^*$:\n$$\nE_{\\text{trans}} = \\lambda u' \\Delta^*\n$$\n$$\n\\Delta^* = \\frac{E_{\\text{trans}}}{\\lambda u'}\n$$\nThe total transition energy is given by $E_{\\text{trans}} = E_{\\text{exit}} + E_{\\text{entry}}$.\n\n**Numerical Calculation**\nWe substitute the given parameter values:\n*   $E_{\\text{exit}} = 2.5\\,\\text{mJ}$\n*   $E_{\\text{entry}} = 1.1\\,\\text{mJ}$\n*   $\\lambda = 0.02\\,\\text{J per utility unit}$\n*   $u' = 2\\,\\text{utility units per second}$\n\nFirst, we calculate $E_{\\text{trans}}$ and the product $\\lambda u'$:\n$$\nE_{\\text{trans}} = 2.5\\,\\text{mJ} + 1.1\\,\\text{mJ} = 3.6\\,\\text{mJ} = 3.6 \\times 10^{-3}\\,\\text{J}\n$$\n$$\n\\lambda u' = (0.02\\,\\text{J/unit}) \\times (2\\,\\text{units/s}) = 0.04\\,\\text{J/s}\n$$\nNow, we can compute $\\Delta^*$:\n$$\n\\Delta^* = \\frac{3.6 \\times 10^{-3}\\,\\text{J}}{0.04\\,\\text{J/s}} = \\frac{0.0036}{0.04}\\,\\text{s} = 0.09\\,\\text{s}\n$$\nThe problem asks for the answer in milliseconds, rounded to four significant figures.\n$$\n\\Delta^* = 0.09\\,\\text{s} \\times 1000\\,\\text{ms/s} = 90.00\\,\\text{ms}\n$$", "answer": "$$\n\\boxed{90.00}\n$$", "id": "3689036"}, {"introduction": "Effective timer coalescing relies on having a global view of all pending events, but where in the system should this intelligence reside? This exercise compares the energy efficiency of two strategies: user-space coalescing, where each application manages its own timers, and kernel-level coalescing, where the OS has a global view. By analyzing a concrete scenario [@problem_id:3689068], you'll quantify the significant advantage of centralized, kernel-level decisions and consider the essential Application Programming Interface (API) needed to pass scheduling flexibility from applications to the kernel.", "problem": "An operating system with a tickless kernel and high-resolution timers is deployed on a device whose Central Processing Unit (CPU) idle power is $P_i = 0.5\\ \\mathrm{W}$ and active power is $P_a = 1.5\\ \\mathrm{W}$. Each wakeup from an idle state incurs a fixed transition energy cost $E_w = 50\\ \\mathrm{\\mu J}$ to reprogram the hardware timer and exit low-power states, independent of the amount of work performed after the interrupt. Servicing each timer event consumes $\\tau = 200\\ \\mathrm{\\mu s}$ of CPU time at power $P_a$, and any number of timer events that are delivered together in a single wakeup incur the same single fixed cost $E_w$ but require a proportional multiple of $\\tau$ of active time. You may neglect all overheads not explicitly stated. Consider the interval $[0, 1\\ \\mathrm{s}]$. Two user processes schedule one-shot timers with allowed deferral (slack), meaning a timer requested for time $t$ may legally be delivered at any time in $[t, t+\\Delta]$ for that timer’s slack $\\Delta$, but not earlier than $t$.\n\nProcess A requests timers at times $t_A \\in \\{100, 200, 300, 400, 500, 600, 700, 800, 900\\}\\ \\mathrm{ms}$, each with slack $\\Delta_A = 10\\ \\mathrm{ms}$.\n\nProcess B requests timers at times $t_B \\in \\{95, 205, 305, 395, 605, 795\\}\\ \\mathrm{ms}$, each with slack $\\Delta_B = 15\\ \\mathrm{ms}$.\n\nAssume the kernel is tickless and uses one-shot hardware programming, so that only actual timer expirations cause interrupts. Consider two coalescing strategies:\n\nUser-space coalescing: each process independently attempts to align only its own timers within its per-timer slack windows to reduce its own wakeups, but has no knowledge of other processes’ timers, and the kernel does not merge timers across processes.\n\nKernel-level coalescing: the kernel has global visibility of all timers and may coalesce any timers from any processes whose legal delivery windows overlap, delivering them in a single interrupt at a time it selects within the intersection of the corresponding windows.\n\nUsing only the definition that energy is the time integral of power, i.e., $E = \\int P(t)\\, dt$, and the given device model, determine which coalescing level yields lower total energy in this scenario and by how much over the $1\\ \\mathrm{s}$ interval. Then select the option that both correctly identifies the better level with the correct energy comparison for the given parameters and proposes a minimal Application Programming Interface (API) by which user space can provide coalescing hints to the kernel that are sufficient to enable the kernel-level behavior without violating per-timer constraints.\n\nChoices:\nA. Kernel-level coalescing yields lower energy by reducing wakeups from $15$ to $9$, saving $6 E_w = 300\\ \\mathrm{\\mu J}$ over $1\\ \\mathrm{s}$ while keeping the same total active service time $15 \\tau$. A suitable Application Programming Interface (API) is a per-timer call that specifies a mandatory earliest expiry $t$ and a maximum deferral (slack) $\\Delta$, allowing the kernel to deliver at any time in $[t, t+\\Delta]$, plus an optional per-thread default slack parameter to apply when a per-timer slack is not provided.\n\nB. User-space coalescing yields lower energy because it avoids extra system calls; in this scenario both approaches achieve $9$ wakeups, so the energy is identical. The best Application Programming Interface (API) is a simple sleep-until-$t$ function with no slack parameter, leaving alignment to libraries.\n\nC. Both levels are energy-equivalent because the total active time $15 \\tau$ is the same; the fixed per-wakeup energy $E_w$ is negligible. The Application Programming Interface (API) should expose a single global system-wide slack value that the kernel applies uniformly to all timers, without per-timer constraints.\n\nD. Kernel-level coalescing yields lower energy by forcing all timers onto a fixed $10\\ \\mathrm{ms}$ tick grid, which in this scenario reduces wakeups from $15$ to $12$. The recommended Application Programming Interface (API) is to require applications to busy-wait until the next grid boundary and then call a nanosleep without specifying slack.", "solution": "The user has provided a problem concerning energy consumption in an operating system with a tickless kernel, comparing user-space and kernel-level timer coalescing strategies. I will first validate the problem statement and then proceed to a full solution and evaluation of the options.\n\n### Step 1: Extract Givens\nThe problem provides the following parameters and definitions:\n-   CPU idle power: $P_i = 0.5\\ \\mathrm{W}$\n-   CPU active power: $P_a = 1.5\\ \\mathrm{W}$\n-   Wakeup transition energy cost: $E_w = 50\\ \\mathrm{\\mu J}$\n-   CPU time to service one timer event: $\\tau = 200\\ \\mathrm{\\mu s}$\n-   Evaluation interval: $[0, 1\\ \\mathrm{s}]$\n-   Process A timer requests: $t_A \\in \\{100, 200, 300, 400, 500, 600, 700, 800, 900\\}\\ \\mathrm{ms}$. This constitutes $9$ timers.\n-   Process A timer slack: $\\Delta_A = 10\\ \\mathrm{ms}$\n-   Process B timer requests: $t_B \\in \\{95, 205, 305, 395, 605, 795\\}\\ \\mathrm{ms}$. This constitutes $6$ timers.\n-   Process B timer slack: $\\Delta_B = 15\\ \\mathrm{ms}$\n-   A timer requested for time $t$ with slack $\\Delta$ must be delivered in the interval $[t, t+\\Delta]$.\n-   **User-space coalescing**: Each process coalesces only its own timers. The kernel does not merge timers between processes.\n-   **Kernel-level coalescing**: The kernel has a global view and coalesces timers from any processes if their legal delivery windows $[t, t+\\Delta]$ overlap.\n-   The total number of timers to be serviced is $N_t = 9 + 6 = 15$.\n-   Energy definition: $E = \\int P(t)\\, dt$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is evaluated against standard validation criteria.\n-   **Scientifically Grounded:** The problem is based on established concepts in operating systems and energy management, such as CPU power states (active/idle), state transition energy costs, and timer coalescing with slack. The physical model $E = \\int P(t) dt$ is fundamental. The given values are plausible for a modern device. The problem is scientifically sound.\n-   **Well-Posed:** The problem is clearly specified. All necessary data to calculate the energy consumption for both strategies are provided. The objectives are unambiguous, and a unique solution for the energy difference can be determined from the givens.\n-   **Objective:** The problem is phrased in objective, quantitative terms. The request for a \"suitable\" API is constrained by the requirement to enable the specified kernel behavior, making its evaluation objective.\n-   **Completeness and Consistency:** The setup is self-contained and free from internal contradictions.\n-   **Feasibility:** The scenario is a simplified but realistic model of timer management in a real-world operating system.\nThe problem statement is deemed **valid**.\n\n### Step 3: Derivation of the Solution\n\nThe total energy $E_{total}$ consumed over the interval $T_{total} = 1\\ \\mathrm{s}$ can be modeled as the sum of idle energy, active energy, and transition energy.\nLet $N_w$ be the number of wakeups from the idle state.\nThe total number of timers is fixed at $N_t = 15$.\nThe total time spent in the active state to service all timers is constant regardless of coalescing strategy:\n$$T_{active} = N_t \\times \\tau = 15 \\times 200\\ \\mathrm{\\mu s} = 3000\\ \\mathrm{\\mu s} = 3 \\times 10^{-3}\\ \\mathrm{s}$$\nThe total time spent in the idle state is $T_{idle} = T_{total} - T_{active}$.\nThe total energy is given by:\n$$E_{total} = E_{idle} + E_{active} + E_{transitions}$$\n$$E_{total} = (P_i \\times T_{idle}) + (P_a \\times T_{active}) + (N_w \\times E_w)$$\n$$E_{total} = P_i (T_{total} - T_{active}) + P_a T_{active} + N_w E_w$$\n$$E_{total} = P_i T_{total} + (P_a - P_i) T_{active} + N_w E_w$$\nTo compare the two coalescing strategies, we calculate the difference in total energy, $\\Delta E_{total}$. The terms $P_i T_{total}$ and $(P_a - P_i) T_{active}$ are identical for both strategies because $T_{total}$ and $T_{active}$ are fixed. Therefore, the energy difference depends solely on the difference in the number of wakeups, $N_w$.\n$$\\Delta E_{total} = E_{total,1} - E_{total,2} = (N_{w,1} - N_{w,2}) \\times E_w$$\nThe strategy that results in fewer wakeups will be more energy-efficient. We now calculate $N_w$ for each strategy.\n\n**Case 1: User-Space Coalescing**\nIn this model, each process coalesces its own timers, but the kernel does not coalesce across processes.\n\n-   **Process A:** Timers are requested at $t_A \\in \\{100, 200, ..., 900\\}\\ \\mathrm{ms}$ with $\\Delta_A = 10\\ \\mathrm{ms}$. The legal delivery windows are $[100, 110]\\ \\mathrm{ms}$, $[200, 210]\\ \\mathrm{ms}$, ..., $[900, 910]\\ \\mathrm{ms}$. Since the end of any window ($t+10$) is before the start of the next window ($t+100$), the windows are disjoint. No coalescing is possible within Process A. This results in $N_{w,A} = 9$ wakeups.\n-   **Process B:** Timers are requested at $t_B \\in \\{95, 205, 305, 395, 605, 795\\}\\ \\mathrm{ms}$ with $\\Delta_B = 15\\ \\mathrm{ms}$. The legal delivery windows are $[95, 110]\\ \\mathrm{ms}$, $[205, 220]\\ \\mathrm{ms}$, etc. These windows are also disjoint. No coalescing is possible within Process B. This results in $N_{w,B} = 6$ wakeups.\n\nThe total number of wakeups for user-space coalescing is the sum of wakeups caused by each process:\n$$N_{w,user} = N_{w,A} + N_{w,B} = 9 + 6 = 15$$\n\n**Case 2: Kernel-Level Coalescing**\nThe kernel has a global view of all timers and can merge any timers whose legal delivery intervals overlap. Let's list the intervals for all timers from both processes:\n-   A1: $[100, 110]\\ \\mathrm{ms}$; B1: $[95, 110]\\ \\mathrm{ms}$. Intersection: $[100, 110]\\ \\mathrm{ms}$. These can be coalesced. (Group 1)\n-   A2: $[200, 210]\\ \\mathrm{ms}$; B2: $[205, 220]\\ \\mathrm{ms}$. Intersection: $[205, 210]\\ \\mathrm{ms}$. These can be coalesced. (Group 2)\n-   A3: $[300, 310]\\ \\mathrm{ms}$; B3: $[305, 320]\\ \\mathrm{ms}$. Intersection: $[305, 310]\\ \\mathrm{ms}$. These can be coalesced. (Group 3)\n-   A4: $[400, 410]\\ \\mathrm{ms}$; B4: $[395, 410]\\ \\mathrm{ms}$. Intersection: $[400, 410]\\ \\mathrm{ms}$. These can be coalesced. (Group 4)\n-   A5: $[500, 510]\\ \\mathrm{ms}$. No other timer overlaps. This is a standalone group. (Group 5)\n-   A6: $[600, 610]\\ \\mathrm{ms}$; B5: $[605, 620]\\ \\mathrm{ms}$. Intersection: $[605, 610]\\ \\mathrm{ms}$. These can be coalesced. (Group 6)\n-   A7: $[700, 710]\\ \\mathrm{ms}$. No other timer overlaps. This is a standalone group. (Group 7)\n-   A8: $[800, 810]\\ \\mathrm{ms}$; B6: $[795, 810]\\ \\mathrm{ms}$. Intersection: $[800, 810]\\ \\mathrm{ms}$. These can be coalesced. (Group 8)\n-   A9: $[900, 910]\\ \\mathrm{ms}$. No other timer overlaps. This is a standalone group. (Group 9)\n\nEach group of coalesced timers requires a single wakeup. Counting the groups gives the total number of wakeups:\n$$N_{w,kernel} = 9$$\n\n**Energy Comparison**\nKernel-level coalescing is more efficient. The number of saved wakeups is:\n$$\\Delta N_w = N_{w,user} - N_{w,kernel} = 15 - 9 = 6$$\nThe total energy saved is:\n$$\\Delta E = \\Delta N_w \\times E_w = 6 \\times 50\\ \\mathrm{\\mu J} = 300\\ \\mathrm{\\mu J}$$\n\n**Application Programming Interface (API) Analysis**\nTo perform kernel-level coalescing, the kernel requires knowledge of the valid delivery interval for each timer. This interval is defined by the earliest expiry time, $t$, and the latest expiry time, $t+\\Delta$. Therefore, an application must provide the kernel with both the nominal requested time $t$ and the allowed slack $\\Delta$. An API call of the form `set_timer(earliest_time, slack)` would be sufficient.\n\n### Option-by-Option Analysis\n\n**A. Kernel-level coalescing yields lower energy by reducing wakeups from $15$ to $9$, saving $6 E_w = 300\\ \\mathrm{\\mu J}$ over $1\\ \\mathrm{s}$ while keeping the same total active service time $15 \\tau$. A suitable Application Programming Interface (API) is a per-timer call that specifies a mandatory earliest expiry $t$ and a maximum deferral (slack) $\\Delta$, allowing the kernel to deliver at any time in $[t, t+\\Delta]$, plus an optional per-thread default slack parameter to apply when a per-timer slack is not provided.**\n-   **Energy Analysis**: The calculation of wakeups ($15$ reduced to $9$), the number of saved wakeups ($6$), the energy saving ($300\\ \\mathrm{\\mu J}$), and the observation about constant active time ($15\\tau$) are all identical to my derivation. This part is correct.\n-   **API Analysis**: The proposed API, which allows specifying the interval $[t, t+\\Delta]$ for each timer, provides exactly the information required by the kernel to perform the optimal coalescing demonstrated. The optional default parameter is a sensible design enhancement. This part is correct.\n-   **Verdict**: **Correct**.\n\n**B. User-space coalescing yields lower energy because it avoids extra system calls; in this scenario both approaches achieve $9$ wakeups, so the energy is identical. The best Application Programming Interface (API) is a simple sleep-until-$t$ function with no slack parameter, leaving alignment to libraries.**\n-   **Energy Analysis**: The claim that user-space coalescing is better is incorrect. The claim that both approaches achieve $9$ wakeups is demonstrably false; user-space requires $15$ wakeups. The premise about avoiding system calls is not supported by the problem statement, which neglects such overheads. This part is incorrect.\n-   **API Analysis**: A simple `sleep-until-t` API provides no slack information to the kernel, making kernel-level coalescing impossible. This API is insufficient. This part is incorrect.\n-   **Verdict**: **Incorrect**.\n\n**C. Both levels are energy-equivalent because the total active time $15 \\tau$ is the same; the fixed per-wakeup energy $E_w$ is negligible. The Application Programming Interface (API) should expose a single global system-wide slack value that the kernel applies uniformly to all timers, without per-timer constraints.**\n-   **Energy Analysis**: The claim that the levels are energy-equivalent is false; kernel-level coalescing saves $300\\ \\mathrm{\\mu J}$. The assertion that $E_w$ is negligible contradicts the premise of the problem, which is to calculate the energy difference based on this non-zero cost. This part is incorrect.\n-   **API Analysis**: A single global slack value would violate the specific per-timer constraints given in the problem (e.g., $\\Delta_A = 10\\ \\mathrm{ms}$ and $\\Delta_B=15\\ \\mathrm{ms}$). The kernel must respect individual timer requirements. This part is incorrect.\n-   **Verdict**: **Incorrect**.\n\n**D. Kernel-level coalescing yields lower energy by forcing all timers onto a fixed $10\\ \\mathrm{ms}$ tick grid, which in this scenario reduces wakeups from $15$ to $12$. The recommended Application Programming Interface (API) is to require applications to busy-wait until the next grid boundary and then call a nanosleep without specifying slack.**\n-   **Energy Analysis**: While a grid-based approach is a form of coalescing, it is not necessarily optimal. Optimal coalescing, by checking for any interval overlap, reduces wakeups to $9$, not $12$. The figure of $12$ wakeups is incorrect for an optimal strategy. This part is incorrect.\n-   **API Analysis**: Recommending busy-waiting is antithetical to energy efficiency, as it keeps the CPU in a high-power active state ($P_a = 1.5\\ \\mathrm{W}$) instead of a low-power idle state ($P_i = 0.5\\ \\mathrm{W}$). This is a fundamentally flawed approach to power management. This part is incorrect.\n-   **Verdict**: **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "3689068"}, {"introduction": "Real-world systems don't deal with fixed, predictable timer schedules; they face a constant, random stream of events with varying importance. This practice introduces a more advanced and realistic scenario, using Poisson processes to model the arrival of both high-priority and low-priority timers. You will analyze a mixed-criticality policy [@problem_id:3689085] to calculate the expected energy savings over a long period, gaining experience with the stochastic modeling techniques essential for modern system performance analysis.", "problem": "A mobile system-on-chip runs a tickless kernel with High-Resolution Timers (HRT) and manages two classes of timers under a mixed-criticality policy. High-criticality timers must meet strict deadlines and bypass coalescing; low-criticality timers are deferrable and may be coalesced. The kernel implements the following policy: for low-criticality timers, it partitions time into fixed, disjoint coalescing windows of length $W$ and, within each window, if at least one low-criticality timer is pending, it schedules exactly one wake at the window boundary to service all of them; otherwise, it schedules no wake for that window. High-criticality timers are serviced immediately at their arrival times without coalescing. The system uses a tickless idle so that, in the absence of scheduled wakeups, the processor remains in deep sleep.\n\nAssume the following foundational modeling assumptions, all standard in operating systems energy analysis and queueing theory:\n- Low-criticality timer arrivals form a homogeneous Poisson process of rate $\\lambda_{\\ell}$ (arrivals per second), independent of high-criticality arrivals.\n- High-criticality timer arrivals form a homogeneous Poisson process of rate $\\lambda_{h}$ (arrivals per second).\n- The probability of exact temporal coincidence between independent continuous-time events is zero, so expected counts of wakeups from independent sources add linearly.\n- Each wake transition (from deep sleep to active state and back) incurs a fixed energy cost $E_{w}$ that is independent of how many timers are serviced during that wake.\n- Servicing each timer consumes a fixed processing energy $E_{\\ell}$ for a low-criticality timer and $E_{h}$ for a high-criticality timer, independent of coalescing. You may assume that processing energies and transition energies add linearly and that differences in steady-state power between active and sleep during brief handling intervals are negligible for comparing the two strategies below.\n- Baseline deep-sleep power $P_{s}$ applies whenever the processor is not handling a wake; for the energy difference you are asked to compute, $P_{s}$ cancels because the total sleep time is effectively the same under both strategies given the assumptions above.\n\nCompare two strategies over a time horizon of $T$:\n- Strategy A (no coalescing): every timer (high or low) creates an immediate wake on its expiration.\n- Strategy B (mixed-criticality coalescing): high-criticality timers bypass coalescing (immediate wakes); low-criticality timers are coalesced as described above.\n\nGiven the parameter values\n- $\\lambda_{h} = 2\\,\\text{s}^{-1}$,\n- $\\lambda_{\\ell} = 100\\,\\text{s}^{-1}$,\n- $W = 0.01\\,\\text{s}$,\n- $E_{w} = 80 \\times 10^{-6}\\,\\text{J}$,\n- $E_{h} = 2 \\times 10^{-6}\\,\\text{J}$,\n- $E_{\\ell} = 1 \\times 10^{-6}\\,\\text{J}$,\n- $T = 3600\\,\\text{s}$,\nand assuming the stochastic processes and policy behavior above are stationary over $T$, derive from first principles the expected energy saved by Strategy B relative to Strategy A over time $T$.\n\nRound your final numerical result to four significant figures. Express the final energy in Joules.", "solution": "The objective is to compute the expected energy saved by Strategy B (mixed-criticality coalescing) relative to Strategy A (no coalescing) over a time horizon $T$. This energy saving, denoted by $\\Delta E$, is the difference between the expected total energy consumption of Strategy A, $\\langle E_A \\rangle$, and that of Strategy B, $\\langle E_B \\rangle$.\n$$ \\Delta E = \\langle E_A \\rangle - \\langle E_B \\rangle $$\nThe total energy consumed under any strategy is the sum of the energy for wake transitions and the energy for processing timers. The total expected energy $\\langle E \\rangle$ can be expressed as:\n$$ \\langle E \\rangle = \\langle N_{\\text{wakes}} \\rangle E_w + \\langle N_h \\rangle E_h + \\langle N_{\\ell} \\rangle E_{\\ell} $$\nwhere $\\langle N_{\\text{wakes}} \\rangle$ is the expected number of wakeups, $\\langle N_h \\rangle$ is the expected number of high-criticality timers, and $\\langle N_{\\ell} \\rangle$ is the expected number of low-criticality timers.\n\nThe arrival of timers is governed by Poisson processes, which are independent of the servicing strategy. Therefore, the expected number of high-criticality and low-criticality timers over the interval $T$ is the same for both strategies:\n$$ \\langle N_h \\rangle = \\lambda_h T $$\n$$ \\langle N_{\\ell} \\rangle = \\lambda_{\\ell} T $$\nConsequently, the total expected processing energy, $\\langle E_{\\text{proc}} \\rangle = \\langle N_h \\rangle E_h + \\langle N_{\\ell} \\rangle E_{\\ell}$, is identical for both Strategy A and Strategy B. When we compute the difference $\\Delta E$, this component will cancel out.\n$$ \\Delta E = (\\langle N_{\\text{wakes, A}} \\rangle E_w + \\langle E_{\\text{proc}} \\rangle) - (\\langle N_{\\text{wakes, B}} \\rangle E_w + \\langle E_{\\text{proc}} \\rangle) $$\n$$ \\Delta E = (\\langle N_{\\text{wakes, A}} \\rangle - \\langle N_{\\text{wakes, B}} \\rangle) E_w $$\nThe problem is thus reduced to finding the difference in the expected number of wakeups between the two strategies.\n\nFirst, we analyze Strategy A (no coalescing).\nIn this strategy, every timer arrival, whether high-criticality or low-criticality, triggers an immediate wake. The total stream of timer arrivals is a superposition of two independent Poisson processes with rates $\\lambda_h$ and $\\lambda_{\\ell}$. The resulting superposed process is also a Poisson process with a combined rate of $\\lambda_{A} = \\lambda_h + \\lambda_{\\ell}$. The expected number of wakeups over the time horizon $T$ is therefore:\n$$ \\langle N_{\\text{wakes, A}} \\rangle = (\\lambda_h + \\lambda_{\\ell}) T $$\n\nNext, we analyze Strategy B (mixed-criticality coalescing).\nIn this strategy, wakeups are generated by two independent sources: high-criticality timers and coalesced low-criticality timers. The total expected number of wakeups is the sum of the expectations from each source.\n1.  High-criticality timers: Each high-criticality timer causes an immediate wake. The expected number of wakes from this source is equal to the expected number of high-criticality arrivals.\n    $$ \\langle N_{\\text{wakes, h}} \\rangle = \\lambda_h T $$\n2.  Low-criticality timers: These are coalesced. The time horizon $T$ is partitioned into $N_{\\text{win}} = \\frac{T}{W}$ disjoint windows of length $W$. A single wake is generated at the end of a window if and only if at least one low-criticality timer arrived within that window.\n    The number of low-criticality arrivals in any given window of length $W$ is a random variable $K$ that follows a Poisson distribution with parameter $\\mu = \\lambda_{\\ell} W$. The probability mass function is $P(K=k) = \\frac{\\mu^k \\exp(-\\mu)}{k!}$.\n    A wake is triggered if $K \\ge 1$. The probability of this event is:\n    $$ P(\\text{wake in window}) = P(K \\ge 1) = 1 - P(K=0) $$\n    The probability of zero arrivals is:\n    $$ P(K=0) = \\frac{(\\lambda_{\\ell} W)^0 \\exp(-\\lambda_{\\ell} W)}{0!} = \\exp(-\\lambda_{\\ell} W) $$\n    Therefore, the probability of a wake in a given window is:\n    $$ P(\\text{wake in window}) = 1 - \\exp(-\\lambda_{\\ell} W) $$\n    The expected number of low-criticality wakes over the horizon $T$ is the number of windows multiplied by the probability of a wake per window:\n    $$ \\langle N_{\\text{wakes, }\\ell} \\rangle = N_{\\text{win}} \\times P(\\text{wake in window}) = \\frac{T}{W} \\left(1 - \\exp(-\\lambda_{\\ell} W)\\right) $$\nThe total expected number of wakes for Strategy B is the sum of the expected wakes from both sources:\n$$ \\langle N_{\\text{wakes, B}} \\rangle = \\langle N_{\\text{wakes, h}} \\rangle + \\langle N_{\\text{wakes, }\\ell} \\rangle = \\lambda_h T + \\frac{T}{W} \\left(1 - \\exp(-\\lambda_{\\ell} W)\\right) $$\n\nNow we can compute the difference in the expected number of wakes:\n$$ \\langle N_{\\text{wakes, A}} \\rangle - \\langle N_{\\text{wakes, B}} \\rangle = (\\lambda_h + \\lambda_{\\ell}) T - \\left[\\lambda_h T + \\frac{T}{W} \\left(1 - \\exp(-\\lambda_{\\ell} W)\\right)\\right] $$\n$$ \\langle N_{\\text{wakes, A}} \\rangle - \\langle N_{\\text{wakes, B}} \\rangle = \\lambda_{\\ell} T - \\frac{T}{W} \\left(1 - \\exp(-\\lambda_{\\ell} W)\\right) $$\nThe expected energy saving is then:\n$$ \\Delta E = \\left[\\lambda_{\\ell} T - \\frac{T}{W} \\left(1 - \\exp(-\\lambda_{\\ell} W)\\right)\\right] E_w $$\n$$ \\Delta E = T \\left[\\lambda_{\\ell} - \\frac{1}{W} \\left(1 - \\exp(-\\lambda_{\\ell} W)\\right)\\right] E_w $$\n\nWe now substitute the given numerical values:\n$\\lambda_{h} = 2\\,\\text{s}^{-1}$\n$\\lambda_{\\ell} = 100\\,\\text{s}^{-1}$\n$W = 0.01\\,\\text{s}$\n$E_{w} = 80 \\times 10^{-6}\\,\\text{J}$\n$T = 3600\\,\\text{s}$\n\nFirst, we compute the dimensionless argument of the exponential function:\n$$ \\lambda_{\\ell} W = (100\\,\\text{s}^{-1}) \\times (0.01\\,\\text{s}) = 1 $$\nSubstituting this into the expression for $\\Delta E$:\n$$ \\Delta E = (3600\\,\\text{s}) \\left[100\\,\\text{s}^{-1} - \\frac{1}{0.01\\,\\text{s}} \\left(1 - \\exp(-1)\\right)\\right] (80 \\times 10^{-6}\\,\\text{J}) $$\n$$ \\Delta E = 3600 \\left[100 - 100 \\left(1 - \\exp(-1)\\right)\\right] \\times (80 \\times 10^{-6})\\,\\text{J} $$\n$$ \\Delta E = 3600 \\left[100 - 100 + 100 \\exp(-1)\\right] \\times (80 \\times 10^{-6})\\,\\text{J} $$\n$$ \\Delta E = 3600 \\left[100 \\exp(-1)\\right] \\times (80 \\times 10^{-6})\\,\\text{J} $$\n$$ \\Delta E = 360000 \\exp(-1) \\times (80 \\times 10^{-6})\\,\\text{J} $$\nUsing the value $e \\approx 2.7182818...$:\n$$ \\Delta E \\approx (360000 \\times 0.367879) \\times (80 \\times 10^{-6})\\,\\text{J} $$\n$$ \\Delta E \\approx 132436.44 \\times 80 \\times 10^{-6}\\,\\text{J} \\approx 10.5949...\\,\\text{J} $$\nRounding the result to four significant figures, we get:\n$$ \\Delta E \\approx 10.59\\,\\text{J} $$\nThis value represents the expected total energy saved over one hour by implementing the mixed-criticality coalescing policy.", "answer": "$$\n\\boxed{10.59}\n$$", "id": "3689085"}]}