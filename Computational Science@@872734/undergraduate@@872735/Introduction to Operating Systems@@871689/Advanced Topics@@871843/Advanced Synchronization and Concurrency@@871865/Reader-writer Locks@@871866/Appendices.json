{"hands_on_practices": [{"introduction": "To build efficient locks, systems programmers often pack state information, like flags and counters, into a single atomic integer. This practice explores a critical pitfall of this design: integer overflow in the reader count, which can silently corrupt the lock's state and violate its safety guarantees. Working through this problem will sharpen your understanding of low-level data representation and its direct impact on concurrent program correctness [@problem_id:3675673].", "problem": "A reader-writer lock stores its state in a fixed-width unsigned integer with standard two’s-complement modulo arithmetic semantics for unsigned types: all additions and subtractions on a $w$-bit unsigned integer are performed modulo $2^{w}$. The design uses the high-order $f$ bits for flags and the remaining low-order $w-f$ bits for the reader count. The reader count is incremented atomically by each acquiring reader and decremented atomically by each releasing reader. A writer acquires exclusivity only when the reader count field is equal to $0$.\n\nAssume the following implementation choices and constraints:\n- The integer width is $w=16$ bits (that is, a `uint16`).\n- The number of flag bits is $f=2$ (the two most significant bits hold a write-locked and a writer-waiting indicator).\n- All arithmetic on the reader count field follows the induced modulo $2^{w-f}$ semantics, because it is a subfield of a $w$-bit unsigned integer.\n\nTasks:\n1. Starting from the definition of modulo arithmetic on fixed-width unsigned integers and the invariants of a reader-writer lock, explain why a reader-count “saturation” at the maximum representable value followed by one more reader acquire will wrap the reader count field to $0$, and why this can violate writer safety if a writer is waiting.\n2. Under the above $w$ and $f$, derive the exact maximum number of concurrent readers $N_{\\max}$ that can be represented without ambiguity in the reader count field, and identify the next increment that would trigger the wrap-around.\n3. Suppose the system architect can guarantee an absolute concurrency bound of $B=1\\times 10^{6}$ simultaneous readers in the worst case, while retaining the same $f=2$ flag bits. Determine the minimal integer width $w_{\\min}$ (in bits) such that the reader count field can represent all values from $0$ through $B$ without wrap-around. Express your final answer as the single integer $w_{\\min}$ in bits.\n\nIn addition, propose one robust type choice and one concrete run-time guard that would prevent the overflow in practice under these constraints. These proposals will be graded qualitatively and do not affect the required numeric answer.\n\nReport only the value of $w_{\\min}$ for grading. No rounding is required; provide an exact integer in bits.", "solution": "The problem statement is analyzed to be valid. It is scientifically grounded in the principles of computer architecture and operating systems, specifically concerning integer representation and concurrency control mechanisms. The problem is well-posed, with all necessary parameters and constraints defined to derive a unique, logical solution. The language is objective and precise.\n\nLet the state of the reader-writer lock be stored in a $w$-bit unsigned integer, denoted by a variable $S$. The range of values for $S$ is $[0, 2^w - 1]$. All arithmetic on $S$ is performed modulo $2^w$.\nThe integer $S$ is partitioned into two fields:\n1. The most significant $f$ bits are used for flags.\n2. The least significant $c = w-f$ bits are used for the reader count, denoted by $R$.\n\nThe numerical value of the reader count $R$ can be extracted from $S$ using a bitmask or modulo arithmetic: $R = S \\pmod{2^c}$. A reader acquiring the lock corresponds to an atomic increment of $S$, i.e., $S \\leftarrow S+1$. A writer can acquire the lock only when the reader count $R$ is $0$.\n\n**1. Analysis of Reader-Count Overflow and Writer Safety Violation**\n\nThe reader count field has $c = w-f$ bits. As a $c$-bit unsigned integer field, it can represent values from $0$ to $2^c - 1$. The state of having $N$ readers is represented by the reader count field having the value $N$.\n\nLet us consider the case where the reader count is at its maximum representable value, which is $R_{\\max} = 2^c - 1$. This corresponds to $2^c - 1$ readers concurrently holding the lock. Assume for simplicity that no flags are set, so the state variable $S$ has the value $S = 2^c - 1$.\n\nWhen one more reader attempts to acquire the lock, the state variable $S$ is atomically incremented:\n$$S_{new} = S_{old} + 1 = (2^c - 1) + 1 = 2^c$$\nThe new reader count $R_{new}$ is found by taking this new state value modulo $2^c$:\n$$R_{new} = S_{new} \\pmod{2^c} = 2^c \\pmod{2^c} = 0$$\nThis is a wrap-around, or an integer overflow, within the reader count field. The state of the lock now indicates a reader count of $0$. However, in reality, there are $2^c$ readers holding the lock.\n\nIf a writer thread is waiting to acquire the lock, it continuously checks the reader count. Upon observing that the reader count is $R_{new} = 0$, the writer's acquisition condition is met. The writer proceeds to acquire the lock and modify the shared resource. This is a critical violation of writer safety, which is a core invariant of the reader-writer lock protocol. The protocol requires that a writer has exclusive access. In this overflow scenario, a writer is granted access while $2^c$ readers are simultaneously accessing the resource, leading to a race condition and potential data corruption.\n\n**2. Maximum Concurrent Readers for $w=16$ and $f=2$**\n\nGiven the integer width $w=16$ bits and the number of flag bits $f=2$, the number of bits available for the reader count is:\n$$c = w - f = 16 - 2 = 14 \\text{ bits}$$\nA $14$-bit field can represent unsigned integer values in the range $[0, 2^{14}-1]$. The value $0$ represents zero readers. Each integer value $N$ in this range represents $N$ concurrent readers. Therefore, the maximum number of concurrent readers $N_{\\max}$ that can be represented without ambiguity is the maximum value the field can hold.\n$$N_{\\max} = 2^{14} - 1 = 16384 - 1 = 16383$$\nThe next increment, corresponding to the $(N_{\\max}+1)$-th reader acquisition, would attempt to set the reader count to $16383+1=16384$. Since $16384 = 2^{14}$, this value represented in a $14$-bit field is $0$, triggering the wrap-around described in the first part.\n\n**3. Minimal Integer Width for a Concurrency Bound of $B=1 \\times 10^6$**\n\nThe system must support an absolute concurrency bound of $B=1 \\times 10^6$ readers. This means the reader count field must be able to represent all integer values from $0$ to $B$ inclusive. Let the minimal required integer width be $w_{\\min}$ and the number of bits for the reader count be $c_{\\min}$. We are given that the number of flag bits remains $f=2$. Thus, $c_{\\min} = w_{\\min} - f = w_{\\min} - 2$.\n\nA $c_{\\min}$-bit field can represent $2^{c_{\\min}}$ distinct values, from $0$ to $2^{c_{\\min}}-1$. To accommodate up to $B$ readers, the maximum value representable by the field must be at least $B$.\n$$2^{c_{\\min}} - 1 \\ge B$$\nSubstituting $B = 1 \\times 10^6$:\n$$2^{c_{\\min}} - 1 \\ge 10^6$$\n$$2^{c_{\\min}} \\ge 10^6 + 1$$\nTo find the minimum integer $c_{\\min}$ that satisfies this inequality, we use the base-$2$ logarithm:\n$$c_{\\min} \\ge \\log_2(10^6 + 1)$$\nSince $c_{\\min}$ must be an integer, we take the ceiling of the result:\n$$c_{\\min} = \\lceil \\log_2(1000001) \\rceil$$\nWe can compute the logarithm:\n$$\\log_2(1000001) = \\frac{\\ln(1000001)}{\\ln(2)} \\approx \\frac{13.8155105}{0.6931472} \\approx 19.931568$$\nThe ceiling of this value is:\n$$c_{\\min} = \\lceil 19.931568 \\rceil = 20 \\text{ bits}$$\nSo, a minimum of $20$ bits are required for the reader count field.\nLet's verify this: a $20$-bit field can store values up to $2^{20}-1 = 1048576 - 1 = 1048575$. This value is indeed greater than or equal to $10^6$. A $19$-bit field could only store up to $2^{19}-1 = 524287$, which is insufficient.\nThe minimal total integer width $w_{\\min}$ is the sum of the bits for the reader count and the flags:\n$$w_{\\min} = c_{\\min} + f = 20 + 2 = 22 \\text{ bits}$$\n\n**Proposals to Prevent Overflow**\n\nAs requested, here are two proposals to prevent reader count overflow in practice.\n\n1.  **Robust Type Choice**: The fundamental problem is the entanglement of the reader count and flags within a single integer of fixed, and potentially insufficient, width. A more robust design would be to separate these concerns using a `struct` or `class`.\n    ```c++\n    struct SafeRWLockState {\n        std::atomic<uint_fast16_t> flags;      // e.g., for 2 flags, a 16-bit type is ample.\n        std::atomic<size_t>        reader_count; // size_t is large enough for any practical count.\n    };\n    ```\n    By using `std::atomic<size_t>`, the reader count is stored in an integer type that is guaranteed by the C++ standard to be large enough to hold the size of any object, which on a $64$-bit system is a $64$-bit integer. This provides a capacity of $2^{64}-1$ readers, effectively eliminating overflow as a practical concern. Operations on flags and the reader count would be performed on distinct atomic variables, preventing overflow in one from corrupting the other.\n\n2.  **Concrete Run-Time Guard**: If the packed-integer design must be retained, a run-time guard is essential. Before incrementing the reader count, the operation must check if the count is already at a saturation point. This is correctly implemented using a compare-and-swap (CAS) loop. A safe saturation limit should be chosen, for instance, `MAX_READERS = (1U << c) - 2`, to leave a buffer.\n    ```c++\n    // Pseudocode for a safe reader acquire on a w-bit state variable `lock_state`\n    const unsigned int READER_INC = 1;\n    const unsigned int READER_MASK = (1U << (w-f)) - 1;\n    const unsigned int SATURATION_LIMIT = READER_MASK - 1; // A safe upper bound\n\n    unsigned int old_state = lock_state.load(std::memory_order_relaxed);\n    while (true) {\n        if ((old_state & WRITER_BITS_MASK) != 0) {\n            // Writer is active or waiting, spin or wait.\n            old_state = lock_state.load(std::memory_order_relaxed);\n            continue;\n        }\n        if ((old_state & READER_MASK) >= SATURATION_LIMIT) {\n            return ACQUIRE_FAILED_TOO_MANY_READERS; // Fail the acquisition\n        }\n        // Attempt to atomically increment the reader count\n        if (lock_state.compare_exchange_weak(old_state, old_state + READER_INC)) {\n            return ACQUIRE_SUCCESS; // Success\n        }\n        // CAS failed, old_state was updated, loop will retry\n    }\n    ```\n    This guard actively prevents the count from reaching the value that would wrap around to zero, thereby preserving writer safety.\n\nThe question requires reporting only the value of $w_{\\min}$ for grading.\n$$w_{\\min} = 22$$", "answer": "$$\\boxed{22}$$", "id": "3675673"}, {"introduction": "Beyond low-level implementation, the logical correctness of a reader-writer lock depends on its disciplined use by threads. This exercise examines the system-wide consequences of a seemingly simple bug: a reader thread that fails to release its lock. You will analyze how this single error can trigger complex failure modes like deadlock or starvation depending on the lock's fairness policy, developing crucial skills in debugging concurrent logic [@problem_id:3675714].", "problem": "A reader-writer lock (RW lock) enforces shared access for readers and exclusive access for writers. Consider a common implementation that maintains three state variables protected by a mutex and coordinated by condition variables: $C$ (the number of active readers), $W$ (the number of waiting writers), and $X$ (a Boolean flag indicating whether a writer is active). The lock admits a reader when $X$ is $\\text{false}$ and $W=0$, and admits a writer when $X$ is $\\text{false}$ and $C=0$. A reader’s lock acquisition increments $C$ by $1$, and its unlock decrements $C$ by $1$. A writer’s lock acquisition sets $X$ to $\\text{true}$ and its unlock sets $X$ to $\\text{false}$. In the writer-preference variant, readers wait when $W>0$ even if $X$ is $\\text{false}$.\n\nStart from the fundamental definitions: mutual exclusion requires that no two writers execute concurrently; shared access for readers requires that readers may execute concurrently only when no writer is active; deadlock is a state in which a set of threads are each waiting for events that only threads in the set can cause, given the lock semantics and state transitions defined above.\n\nSuppose the system begins in a quiescent state with $C=0$, $W=0$, and $X=\\text{false}$. Then $n$ readers sequentially acquire and release the lock. Exactly one reader fails to decrement $C$ on unlock, leaving $C=1$ despite there being no active readers in reality. Subsequently, a writer arrives and attempts to acquire the lock, executing its wait condition while $C>0$ or $X$ is $\\text{true}$ and incrementing $W$ to $1$. Additional readers arrive thereafter.\n\nUnder these assumptions, consider the following statements:\n\nA. In a writer-preference RW lock, after the single reader forgets to decrement $C$ and a writer arrives, the system will enter a deadlock: $C$ remains at $1$, the writer cannot proceed because $C>0$, and all new readers are blocked because $W>0$, so no thread can make progress to change $C$ to $0$.\n\nB. In a reader-preference RW lock (where readers do not wait when $W>0$), the same bug inevitably produces deadlock rather than starvation, because the writer can never acquire the lock when $C>0$.\n\nC. A wait-for graph based deadlock detector that records edges from waiting threads to the locks they await, and edges from locks to their current owning thread(s), will report this deadlock, because the leaked reader count corresponds to an owner and completes a cycle in the graph.\n\nD. A detection strategy that maintains per-thread reader-hold counters $c_i$ and periodically checks the invariant $\\sum_i c_i = C$ can identify the bug even before any writer waits, by discovering a mismatch between $C$ and the true set of reader holders.\n\nE. Adding timeouts to the writer’s wait condition guarantees the absence of deadlock and preserves correctness, because the writer will eventually bypass the $C>0$ condition and proceed.\n\nSelect all statements that are correct.", "solution": "The problem statement describes a reader-writer lock implementation and a scenario involving a software bug where a reader fails to decrement the active reader count, $C$, upon releasing the lock. We must analyze the consequences of this bug under different lock policies and with different detection mechanisms.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n-   **System**: A reader-writer lock (RW lock).\n-   **State Variables**:\n    -   $C$: integer, number of active readers.\n    -   $W$: integer, number of waiting writers.\n    -   $X$: Boolean, `true` if a writer is active.\n-   **Locking Logic (Reader)**:\n    -   Acquisition Condition (general): $X = \\text{false}$ and $W = 0$.\n    -   Acquisition Action: $C \\leftarrow C + 1$.\n    -   Unlock Action: $C \\leftarrow C - 1$.\n-   **Locking Logic (Writer)**:\n    -   Acquisition Condition: $X = \\text{false}$ and $C = 0$.\n    -   Acquisition Action: $X \\leftarrow \\text{true}$.\n    -   Unlock Action: $X \\leftarrow \\text{false}$.\n-   **Writer-Preference Variant**: Readers must also wait if $W > 0$.\n-   **Scenario**:\n    1.  Initial state: $C = 0$, $W = 0$, $X = \\text{false}$.\n    2.  $n$ readers sequentially acquire and release the lock.\n    3.  A bug: Exactly one reader fails to execute $C \\leftarrow C - 1$ upon unlock.\n    4.  Resulting state: $C = 1$, but no reader thread is actually in its critical section.\n    5.  A writer arrives. It executes its wait condition loop (while $C>0$ or $X$ is true) and increments $W$ to $1$.\n    6.  Additional readers arrive after the writer.\n-   **Definitions**:\n    -   **Mutual Exclusion**: No two writers can be concurrent.\n    -   **Shared Access**: Readers can be concurrent only if no writer is active.\n    -   **Deadlock**: A set of threads are each waiting for an event that can only be caused by another thread within the same set.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The problem is grounded in the well-established computer science topic of concurrency control, specifically reader-writer locks. The implementation described (using counters, a flag, a mutex, and condition variables) is a standard textbook model. The bug presented is a realistic programming error.\n-   **Well-Posed**: The initial conditions, state transition rules, and sequence of events are specified unambiguously. The questions posed in the options are evaluable based on these rules.\n-   **Objectivity**: The language is technical and free of subjective claims.\n-   **Completeness and Consistency**: The problem provides sufficient information to analyze the system's behavior. The rules for standard and writer-preference locks are clearly delineated. No contradictions exist in the setup.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. It describes a realistic and analyzable scenario in concurrent programming. I will proceed with the solution.\n\n### Solution Derivation\n\nThe initial state for our analysis, following the bug and the arrival of the first writer ($W_1$), is as follows:\n-   The buggy reader has terminated, leaving $C=1$.\n-   No thread actually holds the read lock.\n-   A writer, $W_1$, has arrived. It checks its wait condition, `while ($C>0$ or $X$ is true)`. Since $C=1$, the condition is met.\n-   $W_1$ increments the waiting writer count, so $W=1$.\n-   $W_1$ blocks on a condition variable.\n-   The system state is now: $C=1$, $W=1$, $X=\\text{false}$.\n-   Subsequently, new readers arrive.\n\nWe will now evaluate each statement based on this system state and the rules provided.\n\n### Option-by-Option Analysis\n\n**A. In a writer-preference RW lock, after the single reader forgets to decrement $C$ and a writer arrives, the system will enter a deadlock: $C$ remains at $1$, the writer cannot proceed because $C>0$, and all new readers are blocked because $W>0$, so no thread can make progress to change $C$ to $0$.**\n\n-   **Analysis**:\n    1.  The writer $W_1$ is blocked, waiting for the condition $C=0$.\n    2.  New readers arrive. For a writer-preference lock, a reader can acquire the lock only if $X$ is $\\text{false}$ and $W=0$.\n    3.  In the current state, $W=1$. Therefore, any new reader that arrives will be blocked; it cannot acquire the lock.\n    4.  We have a set of blocked threads: the writer $W_1$ and all subsequent readers.\n    5.  $W_1$ is waiting for $C$ to become $0$. The only operation that decrements $C$ is a reader's unlock. However, no reader is currently holding the lock. The thread that should have decremented $C$ has already terminated. The new readers are blocked *before* they can acquire the lock and increment $C$, so they will never reach a state where they can perform an unlock to decrement $C$. Thus, the event $W_1$ is waiting for will never occur.\n    6.  The new readers are waiting for $W$ to become $0$. This would happen after $W_1$ acquires and releases the lock. But $W_1$ is blocked.\n    7.  This creates a permanent standstill. The set of threads {$W_1$, all new readers} are waiting for events that cannot be triggered. The writer waits for a \"ghost\" reader to release the lock, and the new readers wait for the writer. This fits the definition of deadlock.\n-   **Verdict**: Correct.\n\n**B. In a reader-preference RW lock (where readers do not wait when $W>0$), the same bug inevitably produces deadlock rather than starvation, because the writer can never acquire the lock when $C>0$.**\n\n-   **Analysis**:\n    1.  We consider a reader-preference lock. The initial state is the same: $C=1$, $W=1$, $X=\\text{false}$, with writer $W_1$ blocked waiting for $C=0$.\n    2.  New readers arrive. In a reader-preference implementation, the condition for a reader to acquire the lock is typically just $X=\\text{false}$. The presence of waiting writers ($W>0$) does not block readers.\n    3.  Since $X=\\text{false}$, these new readers can successfully acquire the lock, incrementing $C$ to $2, 3, \\ldots$. They can perform their work and then correctly release the lock, decrementing $C$.\n    4.  While these new readers are making progress, the writer $W_1$ remains blocked because $C>0$. As long as there is a stream of incoming readers, the condition $C=0$ might never be met during the moments the writer is scheduled to run.\n    5.  This scenario, where one thread ($W_1$) is indefinitely postponed while other threads (the new readers) make progress, is the definition of **starvation**.\n    6.  It is not a deadlock, because the system is not in a global standstill; the reader threads are able to proceed. The statement incorrectly identifies the outcome as deadlock.\n-   **Verdict**: Incorrect.\n\n**C. A wait-for graph based deadlock detector that records edges from waiting threads to the locks they await, and edges from locks to their current owning thread(s), will report this deadlock, because the leaked reader count corresponds to an owner and completes a cycle in the graph.**\n\n-   **Analysis**:\n    1.  A wait-for graph for resource allocation typically has nodes for threads and resources (here, the RW lock). An edge from a thread $T_i$ to a resource $R$ signifies that $T_i$ is waiting for $R$. An edge from $R$ to a thread $T_j$ signifies that $R$ is held by $T_j$. A cycle indicates deadlock.\n    2.  In our deadlock scenario (from option A), the writer $W_1$ is waiting for the RW lock. This creates an edge: $W_1 \\rightarrow \\text{RWLock}$.\n    3.  The lock's state is $C=1$, so it is \"held\" in read mode. To form a cycle, the detector must draw an edge from the lock to its owner: $\\text{RWLock} \\rightarrow T_{owner}$.\n    4.  The problem is that the lock implementation described only maintains a *count* ($C$) of readers, not their identities. More importantly, the thread that caused $C$ to be $1$ has terminated. It is a \"ghost\" owner.\n    5.  A deadlock detector operates on the set of *active* threads in the system. It cannot create an edge to a non-existent thread. The lock state shows it is held, but the detector cannot find an active owner to assign the holding edge to.\n    6.  Without an edge from the lock to an active thread, no cycle can be formed. The graph would simply show one or more threads waiting for a lock that appears to be held, but with no identifiable owner to complete a wait-for chain. Therefore, this type of detector would not report a deadlock.\n-   **Verdict**: Incorrect.\n\n**D. A detection strategy that maintains per-thread reader-hold counters $c_i$ and periodically checks the invariant $\\sum_i c_i = C$ can identify the bug even before any writer waits, by discovering a mismatch between $C$ and the true set of reader holders.**\n\n-   **Analysis**:\n    1.  This statement proposes a debugging or monitoring mechanism. Let $c_i$ be $1$ if thread $i$ holds a read lock, and $0$ otherwise. The invariant is that the sum of these per-thread flags over all active threads must equal the lock's internal reader count, $C$.\n    2.  When the buggy reader (let's call it $R_{bug}$) acquires the lock, it would set its internal flag, $c_{bug}=1$, and the lock would increment its counter, $C \\leftarrow 1$. At this point, $\\sum_i c_i = 1$ and $C=1$, so the invariant holds.\n    3.  The reader $R_{bug}$ then terminates without decrementing $C$. Upon thread termination, all its associated resources and state, including the hypothetical $c_{bug}$ flag, are reclaimed. The contribution of this thread to the sum $\\sum_i c_i$ becomes $0$.\n    4.  Immediately after $R_{bug}$ terminates, the state is: $C=1$ (since it was not decremented) and $\\sum_i c_i = 0$ (summing over all remaining *active* threads).\n    5.  A periodic check of the invariant $\\sum_i c_i = C$ would find a mismatch: $0 \\neq 1$.\n    6.  This mismatch is detected as soon as the buggy thread terminates, which is before the writer arrives. The proposed strategy is therefore effective at identifying this precise bug.\n-   **Verdict**: Correct.\n\n**E. Adding timeouts to the writer’s wait condition guarantees the absence of deadlock and preserves correctness, because the writer will eventually bypass the $C>0$ condition and proceed.**\n\n-   **Analysis**:\n    1.  Consider the deadlock from option A. The writer $W_1$ is blocked indefinitely. If its wait on the condition variable has a timeout, it will eventually stop waiting and regain control.\n    2.  This does break the deadlock, as the writer is no longer permanently stuck. So, the first part of the claim (\"guarantees the absence of deadlock\") is plausible.\n    3.  However, the statement also claims it \"preserves correctness\". When the writer's timed wait expires, the condition $C>0$ is still true. To maintain correctness, the writer must re-check the condition in its `while` loop and, finding it still true, re-enter the wait. This would not solve the problem.\n    4.  If, as the statement implies, the writer \"bypasses the $C>0$ condition and proceed[s]\", it would acquire the lock (e.g., set $X=\\text{true}$) despite $C=1$.\n    5.  This action fundamentally violates the reader-writer lock's core invariant: a writer cannot be active when readers are active. The lock state ($C=1$) indicates a reader is active. Allowing the writer to proceed breaks this guarantee. Correctness is not preserved. The lock's state is now inconsistent ($C=1$ and $X=\\text{true}$) and permanently corrupted, as the ghost count of $1$ will never be cleared.\n-   **Verdict**: Incorrect.", "answer": "$$\\boxed{AD}$$", "id": "3675714"}, {"introduction": "A lock does not operate in a vacuum; its behavior is deeply intertwined with the underlying operating system scheduler. This final practice investigates the classic problem of priority inversion, where a high-priority writer can be indefinitely blocked by a low-priority reader, not due to a bug in the lock, but due to scheduling dynamics. By dissecting this scenario, you will learn to analyze the holistic behavior of concurrent systems and evaluate advanced mitigation strategies like priority inheritance [@problem_id:3675645].", "problem": "A uniprocessor operating system uses a preemptive, fixed-priority scheduler: at any instant, the runnable thread with the highest numerical priority value runs, and a higher-priority arrival preempts a lower-priority thread immediately. A reader-writer lock allows any number of concurrent readers but requires exclusive access for writers. A thread holding a lock is blocked only by the lock semantics; otherwise, if it is runnable and has the highest priority among runnable threads, it runs. Assume negligible context-switch overhead and that critical sections of interest are CPU-bound.\n\nConsider the following scenario. There are three classes of threads: a low-priority reader $R_L$ with priority $p_L$, a high-priority writer $W_H$ with priority $p_H$, and a stream of medium-priority threads $\\{M_i\\}$, each with priority $p_M$ such that $p_H > p_M > p_L$. At time $t=0$, $R_L$ acquires the read lock and begins a critical section of remaining CPU time $C_r > 0$. At time $t=\\varepsilon$ (for some arbitrarily small $\\varepsilon > 0$), $W_H$ becomes runnable and attempts to acquire the write lock, blocking because $R_L$ holds a read lock. From time $t \\geq \\varepsilon$ onward, an arbitrary number of medium-priority threads $\\{M_i\\}$ may become runnable over time. The lock implementation admits multiple concurrent readers by default and does not have any built-in priority handling unless specified by a variant.\n\nUsing only the core definitions above (reader-writer mutual exclusion, preemptive fixed-priority scheduling, and the notion that a blocked thread cannot run), reason about priority inversion and mitigation. Which of the following statements are correct? Select all that apply.\n\nA. In the baseline implementation described (no priority-aware features), $W_H$ can suffer unbounded delay even though only $R_L$ holds the read lock at $t=\\varepsilon$, because arbitrarily many medium-priority arrivals can continuously preempt $R_L$ and prevent it from finishing its critical section.\n\nB. A variant that, upon the arrival of any blocked writer, immediately boosts the priority of every current reader-holding thread to $p_H$ and prevents admission of new readers until the writer acquires and releases the lock eliminates unbounded priority inversion. On a single core with exactly $1$ current reader at $t=\\varepsilon$ and remaining critical-section time $C_r$, the additional waiting time experienced by $W_H$ starting at $t=\\varepsilon$ is at most $C_r$.\n\nC. A variant that, upon the arrival of a blocked writer, boosts the priority of exactly one arbitrarily chosen current reader-holding thread to $p_H$ but allows new readers to continue acquiring the lock is sufficient to prevent unbounded priority inversion in general.\n\nD. A variant that, upon the arrival of a blocked writer, assigns the lock object itself a temporary priority of $p_H$ (without modifying the priorities of lock-holding threads) suffices to prevent unbounded priority inversion, because the scheduler will prefer the lock’s priority.\n\nE. A variant that implements a priority-ceiling style policy for the reader-writer lock—define a ceiling $p_C = \\max\\{p \\mid \\text{some thread may write with priority } p\\}$; when any reader acquires the lock, it temporarily executes at priority $p_C$; if any writer is pending, no new readers are admitted—eliminates unbounded priority inversion without starving the writer under the given scheduler.", "solution": "The user has provided a problem concerning priority inversion in the context of a preemptive, fixed-priority uniprocessor operating system using a reader-writer lock. The task is to validate the problem statement and, if valid, evaluate several statements about the system's behavior and potential mitigation strategies.\n\n### Problem Validation\n\nFirst, I will validate the problem statement.\n\n#### Step 1: Extract Givens\n\n*   **System Model**: Uniprocessor with a preemptive, fixed-priority scheduler.\n*   **Scheduling Policy**: The runnable thread with the highest numerical priority value runs. A higher-priority arrival immediately preempts a lower-priority thread.\n*   **Synchronization Primitive**: A reader-writer lock.\n    *   Allows any number of concurrent readers.\n    *   Requires exclusive access for writers.\n    *   Baseline implementation has no built-in priority-aware features.\n*   **Thread States**: A thread holding a lock is considered blocked only by lock semantics. If it is not blocked by a lock it is trying to acquire, it is runnable.\n*   **Assumptions**: Negligible context-switch overhead; critical sections are CPU-bound.\n*   **Scenario Participants**:\n    *   One low-priority reader, $R_L$, with priority $p_L$.\n    *   One high-priority writer, $W_H$, with priority $p_H$.\n    *   A stream of medium-priority threads, $\\{M_i\\}$, each with priority $p_M$.\n*   **Priority Ordering**: $p_H > p_M > p_L$.\n*   **Timeline**:\n    *   At time $t=0$, $R_L$ acquires the read lock and enters a critical section with remaining CPU time $C_r > 0$.\n    *   At time $t=\\varepsilon$ (for an arbitrarily small $\\varepsilon > 0$), $W_H$ becomes runnable and attempts to acquire the write lock, subsequently blocking because $R_L$ holds a read lock.\n    *   For $t \\geq \\varepsilon$, an arbitrary number of medium-priority threads $\\{M_i\\}$ may become runnable.\n\n#### Step 2: Validate Using Extracted Givens\n\n*   **Scientifically Grounded**: The problem is based on fundamental and well-established concepts in operating systems theory, including preemptive priority scheduling, reader-writer locks, and priority inversion. The scenario described is a canonical example used to illustrate these concepts. It is scientifically sound.\n*   **Well-Posed**: The problem is clearly defined. The system rules (scheduler, lock), initial conditions, and subsequent events are specified, allowing for a logical analysis of the system's behavior. The question asks to evaluate the correctness of given statements based on this model.\n*   **Objective**: The language is technical and precise. Terms like \"uniprocessor,\" \"preemptive,\" \"CPU-bound,\" and the priority definitions are objective and unambiguous.\n*   **Completeness and Consistency**: The problem statement is self-contained and provides all necessary information to reason about the outcomes. The condition \"an arbitrary number of medium-priority threads\" is a necessary part of the setup to test for *unbounded* delay. There are no contradictions.\n*   **Realism**: This scenario is a classic problem in real-time systems and is entirely realistic from a computer science perspective.\n\n#### Step 3: Verdict and Action\n\nThe problem statement is **valid**. It is a well-formed problem in operating systems theory. I will proceed to derive the solution and evaluate each option.\n\n### Solution Derivation and Option Analysis\n\nThe core issue to analyze is priority inversion. This occurs when a high-priority thread is forced to wait for a low-priority thread, and critically, the duration of this wait is prolonged by the execution of unrelated medium-priority threads.\n\n**Baseline Scenario Analysis**\n\nAt time $t=0$, $R_L$ (priority $p_L$) holds the read lock and is running.\nAt time $t=\\varepsilon$, $W_H$ (priority $p_H$) arrives and tries to acquire the write lock. Since $R_L$ holds a read lock, $W_H$ becomes blocked on the lock. According to the scheduler rules, blocked threads do not run.\nNow, consider any time $t' > \\varepsilon$ when a medium-priority thread $M_i$ (priority $p_M$) becomes runnable. The set of runnable threads now contains at least {$R_L, M_i$}. Since the scheduler is preemptive and $p_M > p_L$, the scheduler will preempt $R_L$ and run $M_i$.\nThe problem states that an arbitrary number of such threads, $\\{M_i\\}$, can become runnable. This implies that the CPU could be continuously occupied by a stream of medium-priority tasks. As long as there is at least one runnable thread $M_i$, the low-priority reader $R_L$ will never be scheduled to run.\nBecause $R_L$ cannot run, it cannot complete its critical section and release the read lock. Because $R_L$ never releases the lock, the high-priority writer $W_H$ remains blocked indefinitely. This is a classic case of unbounded priority inversion, where the blocking time of $W_H$ is not determined by the critical section of $R_L$ but by the execution of an arbitrary number of $M_i$ threads.\n\n**Option-by-Option Analysis**\n\n**A. In the baseline implementation described (no priority-aware features), $W_H$ can suffer unbounded delay even though only $R_L$ holds the read lock at $t=\\varepsilon$, because arbitrarily many medium-priority arrivals can continuously preempt $R_L$ and prevent it from finishing its critical section.**\n\n*   **Analysis**: This statement accurately describes the baseline scenario analyzed above. The high-priority thread $W_H$ is blocked by the low-priority thread $R_L$. However, $R_L$ is prevented from running by the continuous preemption from medium-priority threads $\\{M_i\\}$. This leads to an unbounded waiting time for $W_H$.\n*   **Verdict**: **Correct**.\n\n**B. A variant that, upon the arrival of any blocked writer, immediately boosts the priority of every current reader-holding thread to $p_H$ and prevents admission of new readers until the writer acquires and releases the lock eliminates unbounded priority inversion. On a single core with exactly $1$ current reader at $t=\\varepsilon$ and remaining critical-section time $C_r$, the additional waiting time experienced by $W_H$ starting at $t=\\varepsilon$ is at most $C_r$.**\n\n*   **Analysis**: This describes a priority inheritance-like mechanism. At $t=\\varepsilon$, $W_H$ blocks. The variant's rules trigger:\n    1.  The priority of the sole reader, $R_L$, is boosted from $p_L$ to $p_H$.\n    2.  New readers are prevented from acquiring the lock.\n    With its priority now at $p_H$, $R_L$ cannot be preempted by any arriving medium-priority thread $M_i$ (since $p_H > p_M$). $R_L$ will run to completion. The time taken for this depends on how much of its critical section it completed before $t=\\varepsilon$. Let's say it had executed for time $\\delta \\le \\varepsilon$. Its remaining CPU time is $C_r' = C_r - \\delta$. From $t=\\varepsilon$, $R_L$ will run for $C_r'$ time, then release the lock. The waiting time for $W_H$ starting from its arrival at $t=\\varepsilon$ is therefore $C_r'$. Since $\\delta \\ge 0$, we have $C_r' \\le C_r$. The statement claims the waiting time is at most $C_r$, which is a correct upper bound. The mechanism successfully bounds the priority inversion.\n*   **Verdict**: **Correct**.\n\n**C. A variant that, upon the arrival of a blocked writer, boosts the priority of exactly one arbitrarily chosen current reader-holding thread to $p_H$ but allows new readers to continue acquiring the lock is sufficient to prevent unbounded priority inversion in general.**\n\n*   **Analysis**: This variant has two significant flaws.\n    1.  **Boosting only one reader**: Suppose at the time $W_H$ blocks, there are multiple low-priority readers, say $R_{L1}$ and $R_{L2}$. The variant boosts $R_{L1}$'s priority to $p_H$. $R_{L1}$ runs and finishes, releasing its hold on the lock. However, $R_{L2}$ still holds a read lock and remains at its low priority $p_L$. $R_{L2}$ will be preempted by any medium-priority threads $\\{M_i\\}$, and the priority inversion problem persists. $W_H$ remains blocked by $R_{L2}$.\n    2.  **Allowing new readers**: Even if there is only one reader $R_L$ initially, its priority is boosted and it finishes. However, the policy allows new readers to acquire the lock while $W_H$ is waiting. A new medium-priority reader $R_M$ could acquire the lock just before $R_L$ releases it. Now, $W_H$ is blocked by $R_M$. This can repeat, leading to writer starvation, which is a form of unbounded delay.\n    Therefore, this proposed solution is not sufficient in the general case.\n*   **Verdict**: **Incorrect**.\n\n**D. A variant that, upon the arrival of a blocked writer, assigns the lock object itself a temporary priority of $p_H$ (without modifying the priorities of lock-holding threads) suffices to prevent unbounded priority inversion, because the scheduler will prefer the lock’s priority.**\n\n*   **Analysis**: This statement is ill-defined. The problem's core scheduling rule is: \"at any instant, the runnable thread with the highest numerical priority value runs.\" Schedulers operate on threads, not on synchronization objects like locks. The statement provides no mechanism for how a \"lock's priority\" would influence the scheduling of threads. The claim \"because the scheduler will prefer the lock’s priority\" is an unsubstantiated assertion. For this variant to work, it would need to be re-specified as a rule that modifies thread priorities, e.g., \"any thread holding a lock inherits the lock's priority.\" Without this crucial detail, the statement describes a mechanism that does not integrate with the defined scheduling policy. It is fatally vague.\n*   **Verdict**: **Incorrect**.\n\n**E. A variant that implements a priority-ceiling style policy for the reader-writer lock—define a ceiling $p_C = \\max\\{p \\mid \\text{some thread may write with priority } p\\}$; when any reader acquires the lock, it temporarily executes at priority $p_C$; if any writer is pending, no new readers are admitted—eliminates unbounded priority inversion without starving the writer under the given scheduler.**\n\n*   **Analysis**: This describes a Priority Ceiling Protocol adapted for reader-writer locks. Let's trace it:\n    1.  The priority ceiling $p_C$ is set to the highest priority of any potential writer, which is $p_H$.\n    2.  At $t=0$, when $R_L$ acquires the read lock, its priority is immediately raised to $p_C = p_H$. It begins executing at this high priority.\n    3.  Because $R_L$ is running at $p_H$, it cannot be preempted by any arriving medium-priority threads $\\{M_i\\}$ (since $p_H > p_M$). Thus, priority inversion is prevented from the start.\n    4.  At $t=\\varepsilon$, $W_H$ arrives and blocks, becoming a \"pending writer\".\n    5.  The \"no new readers\" rule is now active, preventing any other readers from acquiring the lock and prolonging the wait for $W_H$. This prevents writer starvation.\n    $R_L$ continues to run at priority $p_H$, finishes its critical section, and releases the lock. Once the lock is free, $W_H$ can acquire it. The blocking time for $W_H$ is bounded by the remaining critical section time of the lock-holding reader(s), which run at the ceiling priority. This protocol correctly eliminates unbounded priority inversion and prevents writer starvation.\n*   **Verdict**: **Correct**.", "answer": "$$\\boxed{ABE}$$", "id": "3675645"}]}