{"hands_on_practices": [{"introduction": "The Priority Inheritance Protocol was created to solve a critical flaw in real-time systems known as priority inversion, where a high-priority task is forced to wait for a low-priority one. This exercise [@problem_id:3670912] provides a classic scenario to demonstrate this problem and lets you calculate the system's performance both with and without priority inheritance. By comparing the response times, you will gain a concrete understanding of how this protocol prevents intermediate-priority tasks from interfering and ensures more predictable system behavior.", "problem": "Consider a single-processor system scheduled under the Linux First-In, First-Out (FIFO) real-time policy, denoted as $SCHED\\_FIFO$. Under $SCHED\\_FIFO$, tasks have fixed priorities; the scheduler always dispatches the highest-priority ready task, and a running task can be preempted only by a task of strictly higher priority. Suppose three tasks share a single mutual-exclusion resource protected by a lock that enforces atomic critical sections. The highest-priority task $H$ requires the lock at the beginning of its job; the medium-priority task $M$ does not use the lock; the low-priority task $L$ uses the lock for part of its job. The Priority Inheritance Protocol (PIP) raises the priority of a resource holder to that of the highest-priority task blocked on the resource; without PIP, a low-priority lock holder can be preempted by unrelated medium-priority tasks while a high-priority task is blocked on the lock, causing priority inversion.\n\nAssume the following parameters and worst-case arrival alignment. The low-priority task $L$ has a worst-case execution time $C_{L}=10\\,\\mathrm{ms}$, of which a contiguous critical section of duration $b=5\\,\\mathrm{ms}$ requires the lock. The highest-priority task $H$ has a worst-case execution time $C_{H}=2\\,\\mathrm{ms}$ and requires the lock immediately upon release. A single job of the medium-priority task $M$ with worst-case execution time $C_{M}=C_{L}-b$ is released exactly when $H$ is released. At time $t=0$, task $H$ is released and attempts to lock the resource; simultaneously, $M$ is released; task $L$ is already executing and has just entered its critical section, so it holds the lock for the next $b$ units unless preempted. The resource lock is non-preemptive with respect to critical section atomicity but does not prevent the processor from being preempted by higher-priority tasks when the lock is held; thus, preemption while holding the lock delays the time to unlock.\n\nUsing only the definitions of response time as completion time minus release time, the semantics of fixed-priority preemptive scheduling under $SCHED\\_FIFO$, and the mechanism of priority inheritance donation under the Priority Inheritance Protocol, derive the worst-case response time $R_{H}$ of task $H$ in two scenarios: (i) without priority donation and (ii) with priority donation. Then compute the numerical values for $R_{H}$ in milliseconds for both scenarios and the improvement defined as $\\Delta = R_{H}^{\\mathrm{without}} - R_{H}^{\\mathrm{with}}$. Express the final numerical answers in $\\mathrm{ms}$ and round your answers to four significant figures.", "solution": "The problem is validated as follows.\n\nFirst, all givens are extracted verbatim.\nSystem: Single-processor.\nScheduling Policy: `SCHED_FIFO` (fixed-priority, preemptive).\nTasks: $H$ (high-priority), $M$ (medium-priority), $L$ (low-priority). The priority relationship is $P_H > P_M > P_L$.\nResource: Single mutual-exclusion resource protected by a lock.\nProtocol: Priority Inheritance Protocol (PIP) is considered in the second scenario.\nTask Parameters:\n- Low-priority task $L$: worst-case execution time $C_{L}=10\\,\\mathrm{ms}$; critical section duration $b=5\\,\\mathrm{ms}$.\n- High-priority task $H$: worst-case execution time $C_{H}=2\\,\\mathrm{ms}$; requires lock immediately upon release.\n- Medium-priority task $M$: worst-case execution time $C_{M}=C_{L}-b$.\nInitial Conditions (Worst-case arrival alignment):\n- At time $t=0$, task $H$ is released and attempts to lock the resource.\n- At time $t=0$, task $M$ is released.\n- At time $t=0$, task $L$ is already executing and has just entered its critical section, holding the lock for the next $b$ units.\nDefinitions:\n- Response time $R$ = completion time - release time.\nObjective:\n- Derive the worst-case response time of task $H$, $R_{H}$, in two scenarios: (i) without priority donation and (ii) with priority donation.\n- Compute the numerical values for $R_{H}^{\\mathrm{without}}$ and $R_{H}^{\\mathrm{with}}$ in milliseconds.\n- Compute the improvement $\\Delta = R_{H}^{\\mathrm{without}} - R_{H}^{\\mathrm{with}}$.\n- Round the final numerical answers to four significant figures.\n\nSecond, the problem is validated against the specified criteria.\n- **Scientifically Grounded:** The problem is a classic, standard scenario in the study of real-time operating systems, specifically used to demonstrate the problem of priority inversion and the solution provided by the Priority Inheritance Protocol. All concepts are fundamental to computer science.\n- **Well-Posed:** The problem is fully specified with all necessary parameters, initial conditions, and clear definitions of the scheduling and resource locking mechanisms. The parameter $C_M$ is unambiguously defined as $C_{L}-b = 10\\,\\mathrm{ms} - 5\\,\\mathrm{ms} = 5\\,\\mathrm{ms}$. A unique, stable solution can be derived by simulating the system's behavior over time.\n- **Objective:** The problem is stated in precise, technical language, free of ambiguity or subjective claims.\n\nThe problem is found to be scientifically sound, well-posed, objective, and does not violate any of the specified invalidity criteria. Therefore, it is deemed **valid**. A solution is now derived.\n\nThe problem requires the calculation of the worst-case response time for the high-priority task $H$, denoted $R_H$, under two different resource management policies. The response time of a task is defined as the sum of its own execution time, any time it spends blocked waiting for resources, and any time it is preempted by higher-priority tasks. For task $H$, there are no higher-priority tasks, so its response time is $R_H = C_H + B_H$, where $C_H$ is its execution time and $B_H$ is its total blocking time.\n\nFirst, we calculate the execution time of task $M$:\n$C_M = C_L - b = 10\\,\\mathrm{ms} - 5\\,\\mathrm{ms} = 5\\,\\mathrm{ms}$.\n\n**Scenario (i): Without Priority Inheritance**\n\nIn this scenario, task priorities are static.\n- At $t=0$: Task $L$ is executing in its critical section, holding the lock. Task $H$ and task $M$ are released. Since $P_H > P_L$, task $H$ preempts task $L$.\n- Immediately after preemption, task $H$ attempts to acquire the lock. The lock is held by $L$, so task $H$ enters a blocked state.\n- The scheduler must now dispatch the highest-priority ready task. Task $H$ is blocked. The ready queue contains $M$ and $L$. Since $P_M > P_L$, task $M$ is dispatched and begins to execute. This is the moment of priority inversion: the medium-priority task $M$ runs while the high-priority task $H$ is blocked by the low-priority task $L$.\n- From $t=0$ to $t=C_M = 5\\,\\mathrm{ms}$: Task $M$ executes to completion. During this interval, $H$ remains blocked, and $L$ remains preempted.\n- At $t=5\\,\\mathrm{ms}$: Task $M$ completes. The scheduler again dispatches the highest-priority ready task. $H$ is still blocked. The only task in the ready queue is $L$. Task $L$ resumes execution.\n- From $t=5\\,\\mathrm{ms}$ to $t=5\\,\\mathrm{ms} + b = 10\\,\\mathrm{ms}$: Task $L$ executes for the duration of its critical section, $b=5\\,\\mathrm{ms}$.\n- At $t=10\\,\\mathrm{ms}$: Task $L$ completes its critical section and releases the lock. The release of the lock unblocks task $H$, which becomes ready. Since $P_H$ is the highest priority, $H$ immediately preempts $L$ and begins execution.\n- From $t=10\\,\\mathrm{ms}$ to $t=10\\,\\mathrm{ms} + C_H = 12\\,\\mathrm{ms}$: Task $H$ executes to completion.\n- At $t=12\\,\\mathrm{ms}$: Task $H$ completes its job.\n\nThe response time of $H$ is the completion time minus the release time:\n$R_{H}^{\\mathrm{without}} = 12\\,\\mathrm{ms} - 0\\,\\mathrm{ms} = 12\\,\\mathrm{ms}$.\n\nAnalytically, the blocking time $B_H$ for task $H$ is the sum of the time $L$ holds the lock (direct blocking) and the time $M$ executes while $H$ is waiting for $L$ (push-through blocking).\n$B_H = b + C_M = 5\\,\\mathrm{ms} + 5\\,\\mathrm{ms} = 10\\,\\mathrm{ms}$.\n$R_{H}^{\\mathrm{without}} = C_H + B_H = 2\\,\\mathrm{ms} + 10\\,\\mathrm{ms} = 12\\,\\mathrm{ms}$.\n\n**Scenario (ii): With Priority Inheritance Protocol (PIP)**\n\nIn this scenario, a task holding a lock can have its priority temporarily elevated.\n- At $t=0$: Task $L$ is executing in its critical section, holding the lock. Tasks $H$ and $M$ are released. $H$ preempts $L$ and immediately attempts to acquire the lock, causing it to block.\n- **Priority Inheritance Mechanism**: Since the high-priority task $H$ is now blocked by the low-priority task $L$, task $L$'s priority is \"donated\" by $H$. $L$'s effective priority is elevated to $P_H$.\n- The scheduler must dispatch the highest-priority ready task. The task set consists of blocked $H$, ready $M$ with priority $P_M$, and ready $L$ with an effective priority of $P_H$. Since $P_H > P_M$, task $L$ has the highest priority among ready tasks and is dispatched to run.\n- From $t=0$ to $t=b = 5\\,\\mathrm{ms}$: Task $L$ executes with inherited priority $P_H$ and completes its critical section. Task $M$ remains in the ready state, unable to run.\n- At $t=5\\,\\mathrm{ms}$: Task $L$ releases the lock. Upon releasing the lock, its priority immediately reverts to its base priority, $P_L$. The release of the lock unblocks task $H$, which becomes ready.\n- The scheduler dispatches the highest-priority ready task. The ready tasks are now $H$ (priority $P_H$), $M$ (priority $P_M$), and $L$ (priority $P_L$). Task $H$ is dispatched.\n- From $t=5\\,\\mathrm{ms}$ to $t=5\\,\\mathrm{ms} + C_H = 7\\,\\mathrm{ms}$: Task $H$ executes to completion.\n- At $t=7\\,\\mathrm{ms}$: Task $H$ completes its job.\n\nThe response time of $H$ is the completion time minus the release time:\n$R_{H}^{\\mathrm{with}} = 7\\,\\mathrm{ms} - 0\\,\\mathrm{ms} = 7\\,\\mathrm{ms}$.\n\nAnalytically, with PIP, the medium-priority task $M$ cannot preempt the lock-holding task $L$ because $L$'s priority is elevated. The push-through blocking is eliminated. The only blocking experienced by $H$ is the direct blocking from $L$ completing its critical section.\n$B_H = b = 5\\,\\mathrm{ms}$.\n$R_{H}^{\\mathrm{with}} = C_H + B_H = 2\\,\\mathrm{ms} + 5\\,\\mathrm{ms} = 7\\,\\mathrm{ms}$.\n\n**Improvement Calculation**\n\nThe improvement is the difference in response times:\n$\\Delta = R_{H}^{\\mathrm{without}} - R_{H}^{\\mathrm{with}} = 12\\,\\mathrm{ms} - 7\\,\\mathrm{ms} = 5\\,\\mathrm{ms}$.\nThis improvement corresponds exactly to the execution time $C_M$ of the intermediate-priority task, which was prevented from running by the PIP mechanism.\n\nThe numerical answers required are $R_{H}^{\\mathrm{without}}$, $R_{H}^{\\mathrm{with}}$, and $\\Delta$. Rounded to four significant figures, these are $12.00\\,\\mathrm{ms}$, $7.000\\,\\mathrm{ms}$, and $5.000\\,\\mathrm{ms}$, respectively.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n12.00 & 7.000 & 5.000\n\\end{pmatrix}\n}\n$$", "id": "3670912"}, {"introduction": "In real-world systems, blocking dependencies can form long, intricate chains that are difficult to analyze informally. This practice [@problem_id:3670926] introduces the concept of a \"wait-for\" graph, a formal tool for visualizing how threads and locks interact. By constructing this graph and tracing the propagation of priority donations, you will learn to systematically identify the longest blocking chain, which is crucial for determining worst-case performance bounds.", "problem": "Consider an Operating System (OS) with preemptive fixed-priority scheduling and mutually exclusive locks implemented as binary semaphores. A thread that attempts to acquire a held lock is blocked, creating a wait-for dependency on the lock and, by extension, on the lock holder. The Priority Inheritance Protocol (PIP) states that when a higher-priority thread is blocked on a lock, the lock holder temporarily inherits the blocked thread’s priority, and if this holder is itself blocked on another lock, the donation is transitive until the chain terminates at a thread that is not blocked. A wait-for graph is represented as a directed graph $G=(V,E)$ where $V$ contains both threads and locks, and $E$ contains edges of the form $T \\to L$ when a thread $T$ is waiting to acquire lock $L$, and $L \\to T$ when lock $L$ is held by thread $T$.\n\nThere are threads $T_0,T_1,T_2,T_3,T_4,T_5,T_6,T_7$ with base priorities $p(T_0)=90$, $p(T_1)=40$, $p(T_2)=35$, $p(T_3)=20$, $p(T_4)=15$, $p(T_5)=10$, $p(T_6)=50$, $p(T_7)=25$, and locks $L_1,L_2,L_3,L_4,L_5,L_A,L_B$. Assume the following instantaneous state, consistent with mutual exclusion and preemptive scheduling:\n- $T_0$ is blocked, waiting to acquire $L_1$, and $L_1$ is held by $T_1$.\n- $T_1$ is blocked, waiting to acquire $L_2$, and $L_2$ is held by $T_2$.\n- $T_2$ is blocked, waiting to acquire $L_3$, and $L_3$ is held by $T_3$.\n- $T_3$ is blocked, waiting to acquire $L_4$, and $L_4$ is held by $T_4$.\n- $T_4$ is blocked, waiting to acquire $L_5$, and $L_5$ is held by $T_5$.\n- $T_6$ is blocked, waiting to acquire $L_A$, and $L_A$ is held by $T_2$.\n- $T_7$ is blocked, waiting to acquire $L_B$, and $L_B$ is held by $T_4$.\n- $T_5$ is not waiting for any lock and continues executing until it releases $L_5$.\n\nTasks:\n- Using the definitions above, construct the directed wait-for graph $G=(V,E)$ for this state by listing all vertices and edges implied by the relationships. Treat each lock and thread as distinct vertices in $V$.\n- Using only the stated definitions of preemptive fixed-priority scheduling, mutual exclusion, and the Priority Inheritance Protocol (PIP), argue why priority donation must propagate along any simple directed wait-for path in $G$ until it reaches a thread that is not waiting.\n- Let $\\ell$ be the length (number of edges) of the longest simple directed wait-for path in $G$. Compute $\\ell$. Express your final answer as an integer; no rounding is required.", "solution": "The problem statement has been validated and found to be self-contained, consistent, and scientifically sound. It presents a well-defined scenario in the context of operating systems scheduling, specifically concerning the Priority Inheritance Protocol (PIP). All data and definitions are clear and sufficient to proceed with a formal solution.\n\nThe problem asks for three tasks: constructing the wait-for graph, arguing for the transitivity of priority donation, and computing the length of the longest simple directed wait-for path. We will address each in turn.\n\n**Task 1: Construction of the wait-for graph $G=(V,E)$**\n\nThe graph $G=(V,E)$ consists of a set of vertices $V$ and a set of directed edges $E$. The vertices represent both threads and locks. The edges represent \"waits-for\" ($T \\to L$) and \"held-by\" ($L \\to T$) relationships.\n\nBased on the problem description, the set of vertices $V$ is:\n$$V = \\{T_0, T_1, T_2, T_3, T_4, T_5, T_6, T_7, L_1, L_2, L_3, L_4, L_5, L_A, L_B\\}$$\n\nThe set of directed edges $E$ is constructed from the given state:\n1.  $T_0$ is waiting for $L_1$: $T_0 \\to L_1$\n2.  $L_1$ is held by $T_1$: $L_1 \\to T_1$\n3.  $T_1$ is waiting for $L_2$: $T_1 \\to L_2$\n4.  $L_2$ is held by $T_2$: $L_2 \\to T_2$\n5.  $T_2$ is waiting for $L_3$: $T_2 \\to L_3$\n6.  $L_3$ is held by $T_3$: $L_3 \\to T_3$\n7.  $T_3$ is waiting for $L_4$: $T_3 \\to L_4$\n8.  $L_4$ is held by $T_4$: $L_4 \\to T_4$\n9.  $T_4$ is waiting for $L_5$: $T_4 \\to L_5$\n10. $L_5$ is held by $T_5$: $L_5 \\to T_5$\n11. $T_6$ is waiting for $L_A$: $T_6 \\to L_A$\n12. $L_A$ is held by $T_2$: $L_A \\to T_2$\n13. $T_7$ is waiting for $L_B$: $T_7 \\to L_B$\n14. $L_B$ is held by $T_4$: $L_B \\to T_4$\n\nThus, the set of edges $E$ is:\n$$E = \\{ (T_0,L_1), (L_1,T_1), (T_1,L_2), (L_2,T_2), (T_2,L_3), (L_3,T_3), (T_3,L_4), (L_4,T_4), (T_4,L_5), (L_5,T_5), (T_6,L_A), (L_A,T_2), (T_7,L_B), (L_B,T_4) \\}$$\n\n**Task 2: Argument for Transitive Priority Donation**\n\nThe argument for the propagation of priority donation along a simple directed wait-for path is derived directly from the definitions provided for preemptive scheduling and the Priority Inheritance Protocol (PIP).\n\nA simple directed wait-for path in $G$ has the form $T_a \\to L_1 \\to T_b \\to L_2 \\to T_c \\to \\dots \\to T_z$, where $T_z$ is a thread that is not waiting. Each subpath of the form $T_i \\to L \\to T_j$ signifies that thread $T_i$ is blocked, waiting to acquire lock $L$, which is currently held by thread $T_j$.\n\nLet us consider a segment of such a path: $T_i \\to L_k \\to T_j$. Per the problem statement, this means $T_i$ is blocked on $L_k$ held by $T_j$. This situation is an instance of priority inversion if the base priority of the waiting thread, $p(T_i)$, is greater than the base priority of the lock-holding thread, $p(T_j)$. In a preemptive system, $T_j$ could be preempted by another thread $T_m$ with $p(T_j) < p(T_m) < p(T_i)$, thus delaying the release of $L_k$ and prolonging the blocking of the high-priority thread $T_i$.\n\nThe PIP is designed to resolve this. The definition states: \"when a higher-priority thread is blocked on a lock, the lock holder temporarily inherits the blocked thread’s priority\". Let $p_{eff}(T)$ denote the effective priority of a thread $T$. Initially, $p_{eff}(T) = p(T)$. If $p(T_i) > p(T_j)$, PIP dictates that $T_j$ inherits $T_i$'s priority. The effective priority of $T_j$ becomes:\n$$p_{eff}(T_j) = \\max(p_{eff}(T_j), p_{eff}(T_i))$$\nIf multiple threads are waiting for the lock held by $T_j$, $T_j$ inherits the maximum of their priorities.\n\nNow, consider the transitivity clause: \"...and if this holder is itself blocked on another lock, the donation is transitive until the chain terminates at a thread that is not blocked.\"\nSuppose our path continues: $T_i \\to L_k \\to T_j \\to L_m \\to T_n$. Here, $T_j$, the initial lock holder, is itself blocked waiting for lock $L_m$ held by $T_n$.\n1.  $T_j$ has inherited priority from $T_i$, so its effective priority is now $p_{eff}(T_j) = \\max(p(T_j), p_{eff}(T_i))$.\n2.  From the perspective of the scheduler and the resource $L_m$, thread $T_j$ is a waiting thread with an effective priority of $p_{eff}(T_j)$.\n3.  $T_j$ is blocked by $T_n$. If $p_{eff}(T_j) > p(T_n)$, this is another instance of priority inversion.\n4.  Applying PIP again, the lock holder $T_n$ must inherit the priority of the thread it is blocking. Therefore, $T_n$ inherits $p_{eff}(T_j)$. The new effective priority of $T_n$ is:\n$$p_{eff}(T_n) = \\max(p_{eff}(T_n), p_{eff}(T_j)) = \\max(p_{eff}(T_n), \\max(p(T_j), p_{eff}(T_i)))$$\nThis demonstrates that the priority of $T_i$ is propagated to $T_n$. This logic applies recursively along the entire length of any simple directed wait-for path. The priority of the highest-priority \"head\" of a dependency chain is passed down from one lock holder to the next until it reaches the final thread in the chain, which is not blocked and can therefore execute. This ensures the final thread runs with a sufficiently high priority to prevent preemption by intermediate-priority threads, allowing it to complete its critical section and release the lock, thereby unblocking the entire chain.\n\n**Task 3: Computation of the longest simple directed wait-for path length $\\ell$**\n\nA simple directed path is one that does not repeat vertices. The length of a path is the number of edges it contains. We must find the longest such path in the graph $G$ constructed in Task 1. The graph is a Directed Acyclic Graph (DAG) as there are no deadlock cycles described.\n\nThe graph contains three distinct dependency chains which eventually merge. The chains originate from threads that are waiting but do not hold any locks themselves. In the graph $G$, these are vertices with an in-degree of $0$ that are threads. These are $T_0$, $T_6$, and $T_7$. All dependency chains terminate at $T_5$, the only thread holding a lock that is not waiting for another.\n\nWe trace the paths from each origin to the single termination point, $T_5$:\n\n1.  **Path starting from $T_0$**:\n    $T_0 \\to L_1 \\to T_1 \\to L_2 \\to T_2 \\to L_3 \\to T_3 \\to L_4 \\to T_4 \\to L_5 \\to T_5$\n    The sequence of vertices is $(T_0, L_1, T_1, L_2, T_2, L_3, T_3, L_4, T_4, L_5, T_5)$. All vertices are unique, so the path is simple.\n    The number of edges is the number of vertices minus $1$. There are $11$ vertices in this path.\n    Length = $11 - 1 = 10$.\n\n2.  **Path starting from $T_6$**:\n    This path merges with the first path at vertex $T_2$.\n    $T_6 \\to L_A \\to T_2 \\to L_3 \\to T_3 \\to L_4 \\to T_4 \\to L_5 \\to T_5$\n    The sequence of vertices is $(T_6, L_A, T_2, L_3, T_3, L_4, T_4, L_5, T_5)$. All vertices are unique.\n    There are $9$ vertices in this path.\n    Length = $9 - 1 = 8$.\n\n3.  **Path starting from $T_7$**:\n    This path merges with the first path at vertex $T_4$.\n    $T_7 \\to L_B \\to T_4 \\to L_5 \\to T_5$\n    The sequence of vertices is $(T_7, L_B, T_4, L_5, T_5)$. All vertices are unique.\n    There are $5$ vertices in this path.\n    Length = $5 - 1 = 4$.\n\nComparing the lengths of the maximal simple directed paths originating from a waiting thread, we have lengths of $10$, $8$, and $4$. The longest simple directed wait-for path in $G$ is the path starting from $T_0$.\n\nTherefore, the length $\\ell$ of the longest simple directed wait-for path is $10$.", "answer": "$$\\boxed{10}$$", "id": "3670926"}, {"introduction": "The principles of priority inheritance are not limited to simple mutexes but can be extended to more complex synchronization mechanisms like Reader-Writer locks. This problem [@problem_id:3670917] challenges you to reason about how priority donation works when a high-priority writer is blocked by multiple low-priority readers. You will derive a bound for this \"chained blocking,\" developing a deeper appreciation for how locking policies and priority management interact to affect system predictability.", "problem": "A uniprocessor system uses fixed-priority preemptive scheduling and a Reader–Writer (RW) lock for shared data. The Priority Inheritance Protocol (PIP) is implemented for binary semaphores and extended to the Reader–Writer lock as follows: any task that currently holds the RW lock in shared (read) mode and thereby prevents a writer from acquiring the lock is eligible to inherit the blocked writer’s priority while it continues to hold the RW lock. The RW lock is write-preferring: once a writer is queued, no new readers are admitted until the writer acquires and releases the lock.\n\nConsider a highest-priority writer task $T_{H}$ that attempts to acquire the RW lock in write mode and is blocked because there are $r$ lower-priority reader tasks $T_{L}^{1},\\dots,T_{L}^{r}$ that already hold the RW lock in shared mode. Each reader $T_{L}^{i}$ executes a single critical section under the RW lock of duration at most $L_{i}$ (time units), with no nested locking, no self-suspensions, and purely processor-bound execution while in the critical section. Assume that at the instant $T_{H}$ requests the lock, these $r$ readers are the only current holders of the lock and that all new reader arrivals are blocked by the lock’s write-preferring policy.\n\nStarting only from the core definitions of fixed-priority preemptive scheduling, the semantics of the Priority Inheritance Protocol (PIP), and the semantics of a Reader–Writer lock, reason about whether priority donation must apply to all $r$ readers or only a subset, and derive a tight upper bound $B_{H}$ on the worst-case blocking time of $T_{H}$ caused by these $r$ concurrent readers. Your bound must be expressed as a closed-form analytic expression in terms of $r$ and $L_{1},\\dots,L_{r}$. Assume all $L_{i}$ are measured in milliseconds, and express the final bound in milliseconds. No rounding is required.", "solution": "The problem is first validated against the specified criteria.\n\n### Step 1: Extract Givens\n- **System**: Uniprocessor.\n- **Scheduling**: Fixed-priority preemptive scheduling.\n- **Synchronization**: Reader–Writer (RW) lock.\n- **Lock Policy**: Write-preferring. Once a writer is queued, no new readers are admitted.\n- **Protocol**: Priority Inheritance Protocol (PIP) is implemented.\n- **PIP Extension Rule**: A task holding an RW lock in shared (read) mode inherits a blocked writer's priority if it is preventing the writer from acquiring the lock.\n- **Tasks**:\n  - $T_{H}$: A highest-priority writer task.\n  - $T_{L}^{1}, \\dots, T_{L}^{r}$: A set of $r$ lower-priority reader tasks.\n- **Scenario**:\n  - At an initial time, $T_{H}$ attempts to acquire the RW lock in write mode.\n  - $T_{H}$ is blocked because the $r$ tasks $T_{L}^{1}, \\dots, T_{L}^{r}$ already hold the lock in shared mode.\n- **Task Properties**:\n  - Each reader $T_{L}^{i}$ executes a single critical section protected by the RW lock.\n  - The duration of the critical section for task $T_{L}^{i}$ is at most $L_{i}$ time units.\n  - Readers' critical sections are purely processor-bound, with no nested locking or self-suspensions.\n- **Assumptions**:\n  - The $r$ readers are the only holders of the lock when $T_{H}$ makes its request.\n  - All new readers are blocked by the write-preferring policy.\n- **Goal**:\n  1. Determine if priority inheritance applies to all $r$ readers or a subset.\n  2. Derive a tight upper bound $B_{H}$ on the worst-case blocking time of $T_{H}$ due to these $r$ readers, expressed as a closed-form analytic expression in terms of $r$ and $L_{1}, \\dots, L_{r}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It uses standard concepts from the field of real-time operating systems, including fixed-priority scheduling, reader-writer locks, and the priority inheritance protocol. The scenario described is a classic case study for analyzing blocking time and priority inversion. The problem statement is self-contained, providing all necessary definitions and constraints to derive a solution. The terms are precise, and there are no contradictions or factual errors. The problem is formalizable and requires non-trivial reasoning about the interaction of the system components.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A reasoned solution will be provided.\n\n### Solution Derivation\n\nThe solution is derived by analyzing the interactions between the tasks, the scheduler, and the locking mechanism based on the provided rules.\n\nFirst, we address whether priority donation applies to all $r$ readers. The high-priority writer task, $T_{H}$, attempts to acquire the RW lock in exclusive (write) mode. The lock cannot be granted to a writer if it is held by any other task, either in read or write mode. In this scenario, the lock is simultaneously held by $r$ reader tasks, $\\{T_{L}^{1}, T_{L}^{2}, \\dots, T_{L}^{r}\\}$, in shared (read) mode. The condition for $T_{H}$ to be unblocked is the release of the lock by *all* $r$ readers.\n\nAccording to the specified PIP rule, \"any task that currently holds the RW lock in shared (read) mode and thereby prevents a writer from acquiring the lock is eligible to inherit the blocked writer’s priority.\" Since the continued holding of the lock by any one of the tasks $T_{L}^{i}$ is sufficient to prevent $T_{H}$ from proceeding, every one of the $r$ readers is directly contributing to the blocking of $T_{H}$. Therefore, to resolve this priority inversion, priority donation must be applied to all $r$ reader tasks. Each task $T_{L}^{i}$ for $i \\in \\{1, \\dots, r\\}$ inherits the priority of $T_{H}$.\n\nNext, we derive the tight upper bound on the blocking time, $B_{H}$. After the application of PIP, all $r$ reader tasks are now ready to execute at the same high priority level as $T_{H}$. The system is a uniprocessor, which is a critical constraint. On a uniprocessor, only one task can execute at any given instant.\n\nWhen multiple tasks are ready to run at the same priority level, a secondary scheduling policy (e.g., FIFO or round-robin) would determine the order. However, regardless of the tie-breaking rule, since all $r$ readers now have the highest active priority in the system and are processor-bound, they cannot be preempted by any other task. Consequently, their critical sections will be executed serially on the single CPU. One reader will gain access to the processor, run its critical section to completion, and release the lock; then another will do the same, and so on, until all $r$ readers have finished.\n\nThe total blocking time for $T_{H}$ is the total duration from the moment it requests the lock until the lock is finally granted. This period ends only when the last of the $r$ readers completes its critical section and releases the lock. The worst-case execution time for the critical section of reader $T_{L}^{i}$ is given as $L_{i}$. Since their executions on the CPU are serialized, the total worst-case time required for all $r$ readers to complete their critical sections is the sum of their individual worst-case durations.\n\nThis phenomenon is known as chained blocking, where a high-priority task is blocked for a duration dependent on the cumulative execution of multiple lower-priority tasks. The write-preferring policy is essential here, as it prevents any new readers that might arrive from acquiring the lock after $T_{H}$ has queued its request, thereby bounding the number of blocking tasks to the initial set of $r$ readers.\n\nThus, the tight upper bound on the blocking time, $B_{H}$, is the sum of the maximum critical section lengths of all $r$ readers that were holding the lock when $T_{H}$ made its request. This bound is considered tight because a worst-case scenario is trivially constructible: at the instant $T_{H}$ requests the lock, all $r$ readers have just entered their critical sections and are ready to execute, and each subsequently consumes its maximum processing time $L_{i}$. The uniprocessor scheduler would then execute them one by one, leading to a total blocking time equal to the sum of their durations.\n\nThe final expression for the tight upper bound on the blocking time of $T_H$ is:\n$$B_{H} = L_{1} + L_{2} + \\dots + L_{r} = \\sum_{i=1}^{r} L_{i}$$\nThe units of $B_H$ are milliseconds, as the constituent $L_i$ terms are given in milliseconds.", "answer": "$$\\boxed{\\sum_{i=1}^{r} L_{i}}$$", "id": "3670917"}]}