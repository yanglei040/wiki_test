{"hands_on_practices": [{"introduction": "Modern operating systems are tasked with managing sensitive, short-lived data such as session keys or tokens on behalf of applications. This practice explores the challenge of creating a secure in-memory \"vault\" by cryptographically sealing secrets to a specific process context. You will implement a model to investigate how core OS process lifecycle events, such as `fork()` and `exec()`, interact with these cryptographic controls and how proper cleanup mechanisms are essential to prevent secrets from persisting beyond their intended lifetime. This exercise provides critical insight into the subtle but vital interplay between OS process management and cryptographic access control [@problem_id:3631353].", "problem": "You are tasked with designing and analyzing a model of a secure shared secrets vault for an operating system using temporary file system (tmpfs) and cryptographic sealed keys. The model must be implemented as a complete, runnable program. The goal is to explore how process creation and replacement, as well as thread lifecycle events, affect access control and cleanup of in-memory secrets. Your program must compute and output results for a specified test suite.\n\nThe secure vault stores entries in volatile memory on a temporary file system. This memory is intended to be ephemeral and is cleared under certain conditions. A vault entry is considered sealed to a process by deriving an unsealing key from invariant process attributes. The model must adhere to the following base facts and definitions and steer clear of unverified shortcuts:\n\n- Sealed keys are derived from a pseudorandom function (PRF) and a Key Derivation Function (KDF), which are widely used cryptographic primitives. A PRF maps an input ($\\text{key}, \\text{data}$) deterministically to an output indistinguishable from random for attackers without the key. A KDF computes a derived key from an input key and context to bind secrets to particular attributes. The details of the PRF/KDF construction are left to the solution, but they must be deterministic and collision-resistant for distinct contexts within the model.\n- In the operating system process model, fundamental semantics include:\n  - Process creation via `fork()`: a child process is created as a near-exact copy of the parent, inheriting memory mappings and contents, user identifier ($u$), group identifier ($g$), and the current program epoch ($e$) until further changes.\n  - Program replacement via `exec()`: the process image is replaced; process identifiers ($u, g$) persist, while the program epoch ($e$) is considered to change to a new value. User-space cleanup handlers may run before or during replacement, depending on policy. Memory mappings are generally replaced, but shared tmpfs regions can persist at the filesystem level unless explicitly cleaned.\n  - Thread cancellation: when a thread receives a cancellation request, registered cleanup handlers run, which must securely erase secrets in memory to prevent lingering sensitive data.\n- Temporary file system (tmpfs) content depends on the mount epoch ($m$), and secrets residing in tmpfs are considered cleared when the mount epoch changes. Remounting or unmounting increments $m$ and invalidates previous content.\n\nModel Requirements to Implement:\n- Represent each vault entry with a sealed binder derived from attributes ($K, u, g, e, m$), where $K$ is the operating system master secret for sealing, $u$ is the user identifier, $g$ is the group identifier, $e$ is the program epoch, and $m$ is the mount epoch. The vault entry should include a presence flag indicating whether the secret exists in memory.\n- Implement a deterministic PRF-based KDF to compute the binder. The PRF must act as a deterministic mixing function consistent with a pseudorandom function's core properties at the model level.\n- Define access semantics: a process may unseal a secret if and only if the derived key computed from the current ($K, u, g, e, m$) equals the stored binder and the vault entry is present.\n- Define cleanup semantics:\n  - On thread cancellation, the vault entry is cleared immediately by erasing its memory, setting the presence flag to false.\n  - On `exec()`, the program epoch ($e$) changes to a new value; optional policy may trigger cleanup, clearing the vault entry.\n  - On mount epoch change ($m \\rightarrow m'$), tmpfs content is cleared, making the vault entry absent and invalid for unsealing.\n\nState-Transition Model to Simulate:\n- A parent process creates a sealed vault entry under ($K, u, g, e, m$) and then a child is created via `fork()`.\n- The child may perform `exec()` to transition ($e \\rightarrow e'$).\n- A thread cancellation may occur either before or after the child attempts access.\n- The mount epoch may change ($m \\rightarrow m'$) at a specific point in the scenario.\n\nParameter Definitions:\n- $K$ is a $64$-bit unsigned integer representing the master secret.\n- $u$ and $g$ are unsigned integers representing the user and group identifiers.\n- $e$ and $m$ are nonnegative integers representing program epoch and mount epoch.\n- Policies include boolean flags for cleanup on `exec()`.\n\nTest Suite:\nYour program must evaluate the following six test cases, each parameterized as specified. For each case, simulate the sequence of events and determine if the child process can access the secret and whether the vault is empty after the sequence concludes. Booleans must be output as integers: $1$ for true and $0$ for false.\n\n- Test Case $1$ (happy path with post-access cleanup):\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, $g = 1001$, $e = 1$, $m = 1$.\n  - Child does not perform `exec()`; cleanup on `exec()` policy is $0$.\n  - Cancellation occurs after the child attempts access.\n- Test Case $2$ (exec with cleanup policy):\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, $g = 1001$, $e = 1$, $m = 1$.\n  - Child performs `exec()` and changes epoch to $e' = 2$; cleanup on `exec()` policy is $1$.\n  - No cancellation outside of `exec()`.\n- Test Case $3$ (cancellation before access):\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1002$, $g = 1002$, $e = 1$, $m = 1$.\n  - No `exec()`; cleanup on `exec()` policy is $0$.\n  - Cancellation occurs before the child attempts access.\n- Test Case $4$ (mount epoch change clears tmpfs):\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, $g = 1002$, $e = 1$, $m$ changes from $1$ to $2$ before child access.\n  - No `exec()`; cleanup on `exec()` policy is $0$.\n  - No cancellation.\n- Test Case $5$ (group identifier change in child, with post-access cleanup):\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, $g$ changes from $1005$ to $1006$ in the child after `fork()` and before access, $e = 1$, $m = 1$.\n  - No `exec()`; cleanup on `exec()` policy is $0$.\n  - Cancellation occurs after the child attempts access.\n- Test Case $6$ (exec without cleanup policy, showing residual secret risk):\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, $g = 1001$, $e = 1$, $m = 1$.\n  - Child performs `exec()` and changes epoch to $e' = 2$; cleanup on `exec()` policy is $0$.\n  - No cancellation.\n\nFor each test case, your program must compute two outputs:\n- Access result: whether the child can unseal the secret after the sequence, as an integer $0$ or $1$.\n- Vault emptiness: whether the vault is empty after the sequence ends, as an integer $0$ or $1$.\n\nFinal Output Format:\nYour program should produce a single line of output containing a list of six pairs, one per test case, where each pair is the two integers described above in the order $(\\text{access}, \\text{empty})$. The list must be printed as a comma-separated list enclosed in square brackets, where each pair is itself a bracketed comma-separated list. For example: $[[1,0],[0,1],\\dots]$.", "solution": "The problem requires the design and implementation of a computational model for a secure secrets vault in an operating system. The model must simulate how access control to secrets is affected by process lifecycle events such as `fork()` and `exec()`, thread cancellation, and system state changes like the remounting of a temporary file system (tmpfs). The solution is predicated on established principles of operating systems and cryptography.\n\n**1. Foundational Principles**\n\nThe model is grounded in three core areas: the operating system process model, temporary file system semantics, and cryptographic key derivation.\n\n- **Process and Thread Model**: In UNIX-like systems, a new process is created by `fork()`, which produces a child process that is nearly an identical copy of the parent. The child inherits the parent's memory, credentials (user identifier $u$, group identifier $g$), and program code. The `exec()` system call replaces the current process's memory and code with a new program, but critically, credentials like $u$ and $g$ are retained. We model the program identity with a \"program epoch\" $e$, which is inherited on `fork()` but changes on `exec()`. Thread cancellation is a mechanism to terminate a thread, which should trigger cleanup handlers to securely erase sensitive data from memory.\n\n- **Temporary File System (tmpfs)**: A tmpfs is a volatile, in-memory file system. Its contents are ephemeral and exist for the lifetime of the mount. We model this by associating the tmpfs with a \"mount epoch\" $m$. Any event that invalidates the mount (e.g., unmount or remount) is modeled as an increment of $m$, which is defined to clear all contents of the tmpfs.\n\n- **Cryptographic Binding**: A secret can be cryptographically \"sealed\" or \"bound\" to a specific context. This is achieved using a Key Derivation Function (KDF), often built from a Pseudorandom Function (PRF). The KDF takes a master key and a set of context attributes (e.g., process credentials, program identity) and deterministically produces a derived key. A secret can only be \"unsealed\" if the current context can reproduce the exact same derived key. This ensures that the secret is only accessible under the intended conditions.\n\n**2. Algorithmic Design and State Modeling**\n\nBased on these principles, we construct a deterministic simulation model.\n\n- **State Representation**:\n  - **Vault Entry**: A vault entry is represented by two components: a `binder` and a `presence flag`.\n    - The `binder` is an `unsigned long long` value, representing the derived key computed by the KDF. It is calculated from the context ($K, u, g, e, m$), where $K$ is the system's master secret, ($u, g$) are the process credentials, $e$ is the program epoch, and $m$ is the tmpfs mount epoch.\n    - The `presence flag` is a boolean (represented as an integer $1$ for true, $0$ for false) indicating if the secret physically exists in memory (i.e., on the tmpfs).\n  - **Process Context**: A process is defined by its current attributes ($u, g, e$).\n  - **System Context**: The relevant system-wide state is the mount epoch $m$ and the master secret $K$.\n\n- **Key Derivation Function (KDF)**:\nTo model the cryptographic binding, we implement a deterministic function `compute_binder(K, u, g, e, m)`. This function must be a strong mixing function that produces a unique output for each unique set of inputs, satisfying the conceptual requirements of a PRF-based KDF. For this model, a function similar in principle to the FNV-1a hash algorithm is employed. It combines the inputs ($K, u, g, e, m$) through a series of XOR and multiplication operations with large prime numbers to produce a $64$-bit `binder` value.\n$$ \\text{binder} = \\text{KDF}(K, u, g, e, m) $$\n\n- **Access Semantics**:\nA process can successfully access (unseal) the secret if and only if two conditions are met simultaneously:\n$1$. The vault entry's `presence flag` must be true.\n$2$. The `binder` computed from the process's current context ($K, u_{\\text{current}}, g_{\\text{current}}, e_{\\text{current}}, m_{\\text{current}}$) must exactly match the `binder` stored in the vault entry.\n$$ \\text{Access} = (\\text{is\\_present} = \\text{true}) \\land (\\text{KDF}(K, u_{\\text{current}}, g_{\\text{current}}, e_{\\text{current}}, m_{\\text{current}}) = \\text{binder}_{\\text{stored}}) $$\n\n- **State Transition Logic**:\nThe simulation for each test case follows a strict sequence of events, updating the state variables accordingly:\n$1$. **Initialization**: A parent process with context ($u, g, e$) exists in a system with master key $K$ and mount epoch $m$.\n$2$. **Vault Creation**: The parent process creates a vault entry. The `binder` is computed using the initial context ($K, u, g, e, m$), and its `presence flag` is set to true ($1$).\n$3$. **Fork**: A child process is created. It inherits the parent's context, so its initial state is also ($u, g, e$). The vault entry persists in the shared tmpfs.\n$4$. **Pre-Access Events**: The test case scenario dictates events that occur before the child attempts to access the vault. These events modify the child's context or the vault's state:\n    - **Group ID change**: The child's $g$ value is updated.\n    - **Mount epoch change**: The system's $m$ is updated to $m'$, and the vault's `presence flag` is set to false ($0$), simulating tmpfs clearance.\n    - **`exec()`**: The child's program epoch $e$ changes to $e'$. If the `cleanup_on_exec` policy is active, the `presence flag` is set to false ($0$).\n    - **Pre-access cancellation**: The `presence flag` is set to false ($0$) due to cleanup handlers.\n$5$. **Access Attempt**: The child computes a key based on its *current* context and attempts to access the vault according to the access semantics defined above. The result (access success or failure) is recorded.\n$6$. **Post-Access Events**: Events like thread cancellation can occur after the access attempt, which would set the `presence flag` to false ($0$).\n$7$. **Final State**: The final state of the `presence flag` determines if the vault is empty.\n\n**3. Test Case Analysis**\n\nThe logic is applied to each test case. As an example, let's analyze two contrasting cases:\n\n- **Test Case 1 (Successful Access and Cleanup)**:\n  - Parent creates the vault with context ($K, u=1001, g=1001, e=1, m=1$). The vault is present.\n  - The child forks, inheriting the identical context. No pre-access events occur.\n  - The child attempts access. Its context ($1001, 1001, 1$) matches the context used to create the `binder`, and the vault is present. Thus, access is granted. Result: **access = 1**.\n  - A cancellation occurs *after* access. This triggers cleanup, setting the `presence flag` to false.\n  - The final vault state is empty. Result: **empty = 1**.\n\n- **Test Case 6 (Access Failure due to `exec()` without cleanup)**:\n  - Parent creates the vault with context ($K, u=1001, g=1001, e=1, m=1$). The vault is present.\n  - The child forks, inheriting the context.\n  - The child performs an `exec()`, changing its program epoch to $e'=2$. The `cleanup_on_exec` policy is false, so the vault entry's `presence flag` remains true.\n  - The child attempts access. Its context is now ($1001, 1001, 2$). The `binder` it computes with $e=2$ does not match the stored `binder` created with $e=1$. Access is denied. Result: **access = 0**.\n  - No further cleanup events occur. The `presence flag` remains true.\n  - The final vault state is not empty, representing a residual secret risk. Result: **empty = 0**.\n\nThis systematic simulation, implemented in the C program, allows for the precise evaluation of each scenario's security implications as defined by the model.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n// The following headers are allowed but not used in this specific implementation.\n// #include <string.h>\n// #include <math.h>\n// #include <complex.h>\n// #include <threads.h>\n// #include <stdatomic.h>\n\n/**\n * @struct TestCase\n * @brief Holds all parameters for a single test case simulation.\n */\ntypedef struct {\n    unsigned long long K; // Master secret\n    unsigned int u;       // User ID\n    unsigned int g;       // Group ID\n    int e;                // Initial program epoch\n    int m;                // Initial mount epoch\n\n    // Scenario flags\n    int child_execs;       // 1 if child performs exec, 0 otherwise\n    int new_e_on_exec;     // The new epoch value after exec\n    int cleanup_on_exec;   // 1 if cleanup runs on exec, 0 otherwise\n\n    // 0: none, 1: before access, 2: after access\n    int cancellation_timing;\n\n    int mount_epoch_changes; // 1 if mount epoch changes, 0 otherwise\n    int new_m;               // The new mount epoch value\n\n    int group_id_changes;    // 1 if child's group ID changes, 0 otherwise\n    int new_g;               // The new group ID value\n} TestCase;\n\n/**\n * @brief Deterministic PRF-based KDF to compute the binder.\n * This function acts as a deterministic mixing function to derive a key from the\n * given context attributes. It uses a method inspired by the FNV-1a hash algorithm.\n * \n * @param K The 64-bit OS master secret.\n * @param u The user identifier.\n * @param g The group identifier.\n * @param e The program epoch.\n * @param m The mount epoch.\n * @return A 64-bit binder value.\n */\nunsigned long long compute_binder(\n    unsigned long long K,\n    unsigned int u,\n    unsigned int g,\n    int e,\n    int m)\n{\n    // FNV-1a 64-bit constants\n    const unsigned long long prime = 0x100000001B3ULL;\n    unsigned long long hash = 0xcbf29ce484222325ULL;\n\n    // Cast all inputs to 64-bit for consistent arithmetic\n    unsigned long long val_u = u;\n    unsigned long long val_g = g;\n    unsigned long long val_e = e; \n    unsigned long long val_m = m;\n\n    // Mix each attribute into the hash value\n    hash = (hash ^ K) * prime;\n    hash = (hash ^ val_u) * prime;\n    hash = (hash ^ val_g) * prime;\n    hash = (hash ^ val_e) * prime;\n    hash = (hash ^ val_m) * prime;\n\n    return hash;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        // Case 1: Happy path, post-access cleanup via cancellation\n        {0xA3B1C2D3E4F56789ULL, 1001, 1001, 1, 1, 0, 0, 0, 2, 0, 0, 0, 0},\n        // Case 2: exec with cleanup policy, access fails\n        {0xA3B1C2D3E4F56789ULL, 1001, 1001, 1, 1, 1, 2, 1, 0, 0, 0, 0, 0},\n        // Case 3: Cancellation before access, access fails\n        {0xA3B1C2D3E4F56789ULL, 1002, 1002, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0},\n        // Case 4: Mount epoch change clears tmpfs, access fails\n        {0xA3B1C2D3E4F56789ULL, 1001, 1002, 1, 1, 0, 0, 0, 0, 1, 2, 0, 0},\n        // Case 5: Group ID change in child, access fails\n        {0xA3B1C2D3E4F56789ULL, 1001, 1005, 1, 1, 0, 0, 0, 2, 0, 0, 1, 1006},\n        // Case 6: exec without cleanup, access fails, secret remains\n        {0xA3B1C2D3E4F56789ULL, 1001, 1001, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases][2];\n\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n\n        // ---Simulation State---\n        // Parent process context at time of vault creation\n        unsigned int parent_u = tc.u;\n        unsigned int parent_g = tc.g;\n        int parent_e = tc.e;\n\n        // System-wide state\n        unsigned long long K = tc.K;\n        int m = tc.m;\n\n        // The secure vault entry\n        struct {\n            unsigned long long binder;\n            int is_present; // Boolean: 1 for true, 0 for false\n        } vault_entry;\n\n        // ---Simulation Sequence---\n\n        // 1. Parent process creates the sealed vault entry.\n        vault_entry.binder = compute_binder(K, parent_u, parent_g, parent_e, m);\n        vault_entry.is_present = 1;\n\n        // 2. Child process is created via fork, inheriting context.\n        unsigned int child_u = parent_u;\n        unsigned int child_g = parent_g;\n        int child_e = parent_e;\n\n        // 3. Pre-access events occur, modifying child context or vault state.\n        if (tc.group_id_changes) {\n            child_g = tc.new_g;\n        }\n        if (tc.mount_epoch_changes) {\n            m = tc.new_m;\n            vault_entry.is_present = 0; // tmpfs content is cleared.\n        }\n        if (tc.cancellation_timing == 1) { // BEFORE_ACCESS\n            vault_entry.is_present = 0;\n        }\n        if (tc.child_execs) {\n            child_e = tc.new_e_on_exec;\n            if (tc.cleanup_on_exec) {\n                vault_entry.is_present = 0;\n            }\n        }\n        \n        // 4. Child attempts to access the secret.\n        int access_result = 0;\n        unsigned long long child_key = compute_binder(K, child_u, child_g, child_e, m);\n\n        // Access is granted iff the vault entry is present and the derived key matches.\n        if (vault_entry.is_present && child_key == vault_entry.binder) {\n            access_result = 1;\n        }\n        results[i][0] = access_result;\n        \n        // 5. Post-access events occur.\n        if (tc.cancellation_timing == 2) { // AFTER_ACCESS\n            vault_entry.is_present = 0;\n        }\n        \n        // 6. Evaluate final state of the vault.\n        int vault_emptiness = !vault_entry.is_present;\n        results[i][1] = vault_emptiness;\n    }\n\n    // Print the results in the EXACT required format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%d,%d]\", results[i][0], results[i][1]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3631353"}, {"introduction": "Encrypting data in transit is a fundamental security requirement, but encryption alone is not sufficient to protect against active network attackers. Secure protocols like TLS and IPsec must also defend against replay attacks, where an adversary captures and re-transmits valid data packets to disrupt or compromise a connection. This hands-on exercise challenges you to implement a per-socket anti-replay window, a core mechanism that provides freshness and replay resistance by tracking record sequence numbers. By building and analyzing this component, you will gain a practical understanding of how stateful defense mechanisms are built into the OS networking stack and appreciate the memory overhead trade-offs required to secure communications at scale [@problem_id:3631435].", "problem": "You are asked to design and analyze a per-socket anti-replay window mechanism suitable for Transport Layer Security (TLS)–like protocols inside an Operating System (OS) kernel networking stack. The cryptographic objective is to prevent replay attacks by enforcing the freshness of records using monotonically increasing record sequence numbers. From the base definitions of freshness and replay resistance in cryptographic protocols, sequence numbers must be non-decreasing and each unique sequence number must be processed at most once. Your implementation must realize a sliding window that tracks the acceptance or rejection of incoming records based on their integer sequence numbers.\n\nFundamental base for this task:\n- An anti-replay window for a cryptographic protocol maintains acceptance state over a window of recent sequence numbers.\n- Each TLS-like record carries a monotonically increasing sequence number $s \\in \\mathbb{N}$.\n- The window is parameterized by a size $W \\in \\mathbb{N}$ in bits. The state must track the highest sequence number seen $H \\in \\mathbb{N}$ and a bitmask of length $W$ indicating whether a sequence number within the last $W$ positions has already been received.\n- A record with sequence number $s$ is accepted if either $s > H$ (advancing the window) or $H - s  W$ and the corresponding bit in the window is not yet set. Otherwise it is rejected as a replay or as too old.\n\nProgram requirements:\n1. Implement a per-socket anti-replay window that maintains:\n   - The highest sequence number $H$ observed so far.\n   - A $W$-bit bitmap where bit index $i$ corresponds to whether sequence number $H - i$ has been seen (index $i = 0$ corresponds to $H$ itself).\n   - The window must slide forward by a distance $\\Delta = s - H$ when a new record with $s > H$ is received, dropping bits that fall out of the window and zeroing the newly introduced leading positions. If $\\Delta \\ge W$, the entire bitmap is zeroed.\n2. For each test case below, simulate processing the given sequence of integers and output for each sequence number an integer decision: $1$ for accept and $0$ for reject.\n3. Analyze memory overhead for per-socket state. Assume a socket maintains exactly the $W$-bit bitmap plus fixed per-socket metadata overhead $M$ bytes (for bookkeeping such as counters and locking state). Compute:\n   - Per-socket memory in bytes: $m_{\\text{socket}} = \\lceil W/8 \\rceil + M$.\n   - Total memory in bytes for $n$ sockets: $m_{\\text{total}} = n \\cdot m_{\\text{socket}}$.\n   Report both $m_{\\text{socket}}$ and $m_{\\text{total}}$ as integers in bytes.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The results must be flattened across all test cases in the following order: for each test case in the order listed, first output all acceptance decisions for the sequence numbers in that test case, then output $m_{\\text{socket}}$, then output $m_{\\text{total}}$.\n\nAngle units are not involved. All memory quantities must be expressed in bytes as integers.\n\nTest suite:\n- Test case $1$: $W = 64$, $M = 24$, $n = 10^6$, sequence $\\{1, 2, 3, 2, 70, 69\\}$.\n- Test case $2$: $W = 8$, $M = 16$, $n = 10^6$, sequence $\\{5, 5, 12, 4, 12, 20, 13\\}$.\n- Test case $3$: $W = 128$, $M = 32$, $n = 10^6$, sequence $\\{1000, 900, 1000, 1128, 1127, 1128\\}$.\n- Test case $4$: $W = 4096$, $M = 40$, $n = 10^6$, sequence $\\{1, 4097, 1\\}$.\n\nScientific realism and consistency notes:\n- The anti-replay window is a widely used mechanism in Internet Protocol Security (IPsec) and TLS-like constructions for replay resistance and is necessary for kernel-level network stacks handling encrypted transport.\n- The scale $n = 10^6$ models large-scale server deployments with approximately one million sockets, which is realistic for memory planning at high concurrency.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,\\dots]$).", "solution": "The problem statement is evaluated to be **valid**. It is scientifically grounded, well-posed, objective, and provides a complete and consistent set of requirements for designing and analyzing an anti-replay window mechanism. The specified mechanism is a standard technique in cryptographic protocols like IPsec and DTLS for preventing replay attacks. The parameters and scale are realistic for modern server environments.\n\nThe core of the solution is the implementation of a stateful anti-replay window for each socket. This window's state is defined by two components:\n1.  $H$: The highest sequence number received so far, an unsigned integer initialized to $0$.\n2.  A bitmap of size $W$ bits, which we can denote as $B$. Bit $i$ of this map (from right to left, i.e., index $0$ is the least significant bit) corresponds to the sequence number $H-i$. A bit value of $1$ indicates that the corresponding sequence number has been received; $0$ indicates it has not. The bitmap is initialized to all zeros.\n\nWhen a record with sequence number $s$ arrives, the following logic is applied:\n\n1.  **Case 1: $s > H$ (Newest Record)**\n    *   The record is unconditionally accepted (decision: $1$).\n    *   The window must slide forward to accommodate the new highest sequence number. The slide distance is $\\Delta = s - H$.\n    *   If $\\Delta \\ge W$, the new window does not overlap with the old one, so the entire bitmap $B$ is reset to all zeros.\n    *   If $\\Delta  W$, the bitmap $B$ is logically left-shifted by $\\Delta$ bits. This discards the state of the oldest $\\Delta$ sequence numbers and makes room for $\\Delta$ new ones.\n    *   The highest sequence number is updated: $H \\leftarrow s$.\n    *   The bit corresponding to the new $H$ (index $0$) is set to $1$ in the bitmap $B$ to mark it as received.\n\n2.  **Case 2: $s \\le H$ (Potentially Old or Replayed Record)**\n    *   Calculate the position of $s$ relative to $H$: $d = H - s$.\n    *   If $d \\ge W$, the sequence number $s$ is older than the oldest record the window can track. It is rejected as too old (decision: $0$).\n    *   If $d  W$, the sequence number falls within the current window. We check bit $d$ of the bitmap $B$.\n        *   If bit $d$ is $1$, the record is a duplicate (a replay). It is rejected (decision: $0$).\n        *   If bit $d$ is $0$, the record is new and within the window. It is accepted (decision: $1$). The state is then updated by setting bit $d$ of bitmap $B$ to $1$.\n\nThe memory overhead for one socket is the size of the bitmap plus any fixed metadata. The bitmap requires $\\lceil W/8 \\rceil$ bytes. Therefore, $m_{\\text{socket}} = \\lceil W/8 \\rceil + M$ bytes. The total memory for $n$ sockets is $m_{\\text{total}} = n \\cdot m_{\\text{socket}}$.\n\nWe now apply this logic to each test case.\n\n**Test Case 1:** $W = 64$, $M = 24$, $n = 10^6$, sequence $\\{1, 2, 3, 2, 70, 69\\}$.\nInitial state: ($H=0, B=0x0$).\n- $s=1$: $s>H$. Accept ($1$). $\\Delta = 1$. $B \\leftarrow (B \\ll 1) | 1 = 0x1$. $H \\leftarrow 1$. State: ($H=1, B=0x1$).\n- $s=2$: $s>H$. Accept ($1$). $\\Delta = 1$. $B \\leftarrow (B \\ll 1) | 1 = 0x3$. $H \\leftarrow 2$. State: ($H=2, B=0x3$).\n- $s=3$: $s>H$. Accept ($1$). $\\Delta = 1$. $B \\leftarrow (B \\ll 1) | 1 = 0x7$. $H \\leftarrow 3$. State: ($H=3, B=0x7$).\n- $s=2$: $s \\le H$. $d = H-s = 1$. Since $d  W=64$, we check bit $1$ of $B$. Bit $1$ is set in $0x7$. Reject ($0$). State unchanged.\n- $s=70$: $s>H$. Accept ($1$). $\\Delta = 70-3 = 67$. Since $\\Delta \\ge W=64$, reset $B \\leftarrow 0$. Then set bit $0$, so $B \\leftarrow 0x1$. $H \\leftarrow 70$. State: ($H=70, B=0x1$).\n- $s=69$: $s \\le H$. $d = H-s = 1$. Since $d  W=64$, we check bit $1$ of $B$. Bit $1$ is not set in $0x1$. Accept ($1$). Set bit $1$: $B \\leftarrow B | (1 \\ll 1) = 0x3$. State: ($H=70, B=0x3$).\nDecisions: $1, 1, 1, 0, 1, 1$.\nMemory: $m_{\\text{socket}} = \\lceil 64/8 \\rceil + 24 = 8 + 24 = 32$ bytes. $m_{\\text{total}} = 10^6 \\cdot 32 = 32000000$ bytes.\n\n**Test Case 2:** $W = 8$, $M = 16$, $n = 10^6$, sequence $\\{5, 5, 12, 4, 12, 20, 13\\}$.\nInitial state: ($H=0, B=0x0$).\n- $s=5$: $s>H$. Accept ($1$). $\\Delta = 5$. $B \\leftarrow (B \\ll 5) | 1 = 0x1$. $H \\leftarrow 5$. State: ($H=5, B=0b00000001$).\n- $s=5$: $s \\le H$. $d = H-s = 0$. Since $d  W=8$, we check bit $0$. Bit $0$ is set. Reject ($0$).\n- $s=12$: $s>H$. Accept ($1$). $\\Delta = 7$. $B \\leftarrow (B \\ll 7) | 1 = 0b10000001$. $H \\leftarrow 12$. State: ($H=12, B=0b10000001$).\n- $s=4$: $s \\le H$. $d = H-s = 8$. Since $d \\ge W=8$, it is too old. Reject ($0$).\n- $s=12$: $s \\le H$. $d = H-s = 0$. Since $d  W=8$, we check bit $0$. Bit $0$ is set. Reject ($0$).\n- $s=20$: $s>H$. Accept ($1$). $\\Delta = 8$. Since $\\Delta \\ge W=8$, reset $B \\leftarrow 0$. Then set bit $0$, $B \\leftarrow 0x1$. $H \\leftarrow 20$. State: ($H=20, B=0b00000001$).\n- $s=13$: $s \\le H$. $d = H-s = 7$. Since $d  W=8$, we check bit $7$. Bit $7$ is not set. Accept ($1$). Set bit $7$: $B \\leftarrow B | (1 \\ll 7) = 0b10000001$. State: ($H=20, B=0b10000001$).\nDecisions: $1, 0, 1, 0, 0, 1, 1$.\nMemory: $m_{\\text{socket}} = \\lceil 8/8 \\rceil + 16 = 1 + 16 = 17$ bytes. $m_{\\text{total}} = 10^6 \\cdot 17 = 17000000$ bytes.\n\n**Test Case 3:** $W = 128$, $M = 32$, $n = 10^6$, sequence $\\{1000, 900, 1000, 1128, 1127, 1128\\}$.\nInitial state: ($H=0, B=\\{0x0, 0x0\\}$). We use two $64$-bit integers for the $128$-bit bitmap.\n- $s=1000$: $s>H$. Accept ($1$). $\\Delta = 1000 \\ge W=128$. Reset $B$. $H \\leftarrow 1000$. Set bit $0$. State: ($H=1000, \\text{bit } 0 \\text{ set}$).\n- $s=900$: $s \\le H$. $d = H-s = 100$. Since $d  W=128$, check bit $100$. Not set. Accept ($1$). Set bit $100$. State: ($H=1000, \\text{bits } 0, 100 \\text{ set}$).\n- $s=1000$: $s \\le H$. $d = H-s = 0$. Since $d  W=128$, check bit $0$. Bit $0$ is set. Reject ($0$).\n- $s=1128$: $s>H$. Accept ($1$). $\\Delta = 128$. Since $\\Delta \\ge W=128$, reset $B$. $H \\leftarrow 1128$. Set bit $0$. State: ($H=1128, \\text{bit } 0 \\text{ set}$).\n- $s=1127$: $s \\le H$. $d = H-s = 1$. Since $d  W=128$, check bit $1$. Not set. Accept ($1$). Set bit $1$. State: ($H=1128, \\text{bits } 0, 1 \\text{ set}$).\n- $s=1128$: $s \\le H$. $d = H-s = 0$. Since $d  W=128$, check bit $0$. Bit $0$ is set. Reject ($0$).\nDecisions: $1, 1, 0, 1, 1, 0$.\nMemory: $m_{\\text{socket}} = \\lceil 128/8 \\rceil + 32 = 16 + 32 = 48$ bytes. $m_{\\text{total}} = 10^6 \\cdot 48 = 48000000$ bytes.\n\n**Test Case 4:** $W = 4096$, $M = 40$, $n = 10^6$, sequence $\\{1, 4097, 1\\}$.\nInitial state: ($H=0, B=\\text{all zeros}$).\n- $s=1$: $s>H$. Accept ($1$). $\\Delta = 1  W=4096$. Shift $B$ left by $1$. $H \\leftarrow 1$. Set bit $0$. State: ($H=1, \\text{bit } 0 \\text{ set}$).\n- $s=4097$: $s>H$. Accept ($1$). $\\Delta = 4096$. Since $\\Delta \\ge W=4096$, reset $B$. $H \\leftarrow 4097$. Set bit $0$. State: ($H=4097, \\text{bit } 0 \\text{ set}$).\n- $s=1$: $s \\le H$. $d = H-s = 4096$. Since $d \\ge W=4096$, it is too old. Reject ($0$).\nDecisions: $1, 1, 0$.\nMemory: $m_{\\text{socket}} = \\lceil 4096/8 \\rceil + 40 = 512 + 40 = 552$ bytes. $m_{\\text{total}} = 10^6 \\cdot 552 = 552000000$ bytes.\n\nThe final flattened list of results is formed by concatenating the decision sequences and memory calculations for each case in order.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// A struct to hold the state of the anti-replay window.\n// H is the highest sequence number, W is window size in bits.\n// The bitmap is represented as an array of 64-bit unsigned integers.\ntypedef struct {\n    unsigned long long H;\n    size_t W;\n    size_t num_words;\n    unsigned long long* bitmap;\n} ReplayState;\n\n// Utility function to get the value of a bit in the bitmap.\n// index 0 corresponds to sequence number H.\nint get_bit(const ReplayState* state, size_t index) {\n    if (index = state-W) {\n        return 0; // Index is outside the window.\n    }\n    size_t word_index = index / 64;\n    size_t bit_index = index % 64;\n    return (state-bitmap[word_index]  bit_index)  1ULL;\n}\n\n// Utility function to set a bit in the bitmap.\nvoid set_bit(ReplayState* state, size_t index) {\n    if (index = state-W) {\n        return; // Index is outside the window.\n    }\n    size_t word_index = index / 64;\n    size_t bit_index = index % 64;\n    state-bitmap[word_index] |= (1ULL  bit_index);\n}\n\n// Utility function to shift the entire bitmap left by 'delta' bits.\nvoid shift_bitmap_left(ReplayState* state, unsigned long long delta) {\n    if (delta == 0) {\n        return;\n    }\n    // If shift is larger than the window, just clear the bitmap.\n    if (delta = state-W) {\n        memset(state-bitmap, 0, state-num_words * sizeof(unsigned long long));\n        return;\n    }\n\n    size_t word_shift = delta / 64;\n    size_t bit_shift = delta % 64;\n\n    // Shift by whole 64-bit words first.\n    if (word_shift  0) {\n        memmove(state-bitmap, state-bitmap + word_shift, (state-num_words - word_shift) * sizeof(unsigned long long));\n        memset(state-bitmap + (state-num_words - word_shift), 0, word_shift * sizeof(unsigned long long));\n    }\n\n    // Then, shift by the remaining bits, carrying over between words.\n    if (bit_shift  0) {\n        for (size_t i = state-num_words - 1; i  0; --i) {\n            state-bitmap[i] = bit_shift;\n            state-bitmap[i] |= (state-bitmap[i - 1]  (64 - bit_shift));\n        }\n        state-bitmap[0] = bit_shift;\n    }\n}\n\n// Processes a single sequence number 's' and returns the decision (1=accept, 0=reject).\n// The state of the window is updated upon acceptance.\nint process_packet(ReplayState* state, unsigned long long s) {\n    if (s  state-H) {\n        unsigned long long delta = s - state-H;\n        shift_bitmap_left(state, delta);\n        state-H = s;\n        set_bit(state, 0); // Mark the newest packet 's' (at index 0) as seen.\n        return 1;\n    } else { // s = state-H\n        unsigned long long diff = state-H - s;\n        if (diff = state-W) {\n            return 0; // Too old, outside the window.\n        }\n        if (get_bit(state, diff)) {\n            return 0; // Replay, already seen.\n        }\n        // Accept: packet is within the window and not a replay.\n        set_bit(state, diff);\n        return 1;\n    }\n}\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    size_t W;\n    int M;\n    long long n;\n    const unsigned long long* sequence;\n    int seq_len;\n} TestCase;\n\nint main(void) {\n    // Define the test case sequences.\n    const unsigned long long seq1[] = {1, 2, 3, 2, 70, 69};\n    const unsigned long long seq2[] = {5, 5, 12, 4, 12, 20, 13};\n    const unsigned long long seq3[] = {1000, 900, 1000, 1128, 1127, 1128};\n    const unsigned long long seq4[] = {1, 4097, 1};\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {64, 24, 1000000, seq1, sizeof(seq1) / sizeof(seq1[0])},\n        {8, 16, 1000000, seq2, sizeof(seq2) / sizeof(seq2[0])},\n        {128, 32, 1000000, seq3, sizeof(seq3) / sizeof(seq3[0])},\n        {4096, 40, 1000000, seq4, sizeof(seq4) / sizeof(seq4[0])},\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    \n    // Store all results in a single array for final printing.\n    long long results[100]; // Sized to be large enough for all test case results.\n    int result_count = 0;\n\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase tc = test_cases[i];\n\n        // Initialize the anti-replay state for the current test case.\n        ReplayState state;\n        state.H = 0;\n        state.W = tc.W;\n        state.num_words = (tc.W + 63) / 64; // ceiling division\n        state.bitmap = (unsigned long long*)calloc(state.num_words, sizeof(unsigned long long));\n        if (state.bitmap == NULL) {\n            // In a real OS, this would trigger an error, but for this problem, we assume success.\n            return EXIT_FAILURE;\n        }\n\n        // Process the sequence for the current test case.\n        for (int j = 0; j  tc.seq_len; ++j) {\n            results[result_count++] = process_packet(state, tc.sequence[j]);\n        }\n\n        // Calculate memory overhead.\n        long long m_socket = (tc.W + 7) / 8 + tc.M; // ceiling division for bytes\n        unsigned long long m_total = (unsigned long long)tc.n * m_socket;\n        \n        results[result_count++] = m_socket;\n        results[result_count++] = (long long)m_total;\n\n        // Free the allocated bitmap.\n        free(state.bitmap);\n    }\n\n    // Print the results in the EXACT REQUIRED format.\n    printf(\"[\");\n    for (int i = 0; i  result_count; ++i) {\n        printf(\"%lld\", results[i]);\n        if (i  result_count - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3631435"}, {"introduction": "In zero-trust security models, it's not enough to secure communication channels; you must first establish trust in the endpoint itself. Remote attestation is a powerful protocol that allows a system to prove its integrity to a remote verifier, anchored by a hardware root of trust like a Trusted Platform Module (TPM). This practice demystifies this advanced concept by guiding you through the implementation of an attestation protocol, from measuring software components to generating a cryptographically signed quote. You will simulate the roles of the OS, the TPM, and the verifier, learning how cryptographic hashing, message authentication, and nonces work together to provide an authentic and fresh report of a system's state [@problem_id:3631438].", "problem": "You are given the task of designing and validating a remote attestation protocol from the perspective of an operating system, using cryptography as a security tool. The goal is to allow a process to prove to a remote client the integrity of its currently executing binary and loaded modules, using a Trusted Platform Module (TPM) acting as a trust anchor. You must implement a complete, runnable program that simulates the attestation procedure and validates it under several test conditions. The protocol must enforce freshness using a nonce challenge and authenticity using a keyed-hash message authentication code.\n\nFundamental base definitions and facts to use are:\n- A cryptographic hash function $H$ maps arbitrary-length input to fixed-length output and must satisfy pre-image resistance, second pre-image resistance, and collision resistance. For this problem, use an instantiation equivalent to Secure Hash Algorithm 256-bit (SHA-256), producing $256$-bit outputs and operating on a block size of $64$ bytes.\n- A Keyed-Hash Message Authentication Code (HMAC) with an underlying hash function $H$ is defined as $$\\operatorname{HMAC}_K(m) = H\\left((K \\oplus \\text{opad}) \\parallel H\\left((K \\oplus \\text{ipad}) \\parallel m\\right)\\right),$$ where $K$ is a key, $m$ is the message, $\\oplus$ is bitwise exclusive-or, $\\parallel$ denotes concatenation, and $\\text{opad}$ and $\\text{ipad}$ are the outer and inner pads defined by standards for the chosen $H$ with block size $b = 64$ bytes.\n- A nonce is a number used once; it provides freshness when a responder includes the nonce from the challenger in its authenticated response.\n\nProtocol description to implement:\n- Define a measurement procedure where a process has a binary image $B$ and a list of loaded modules $\\{(N_i, M_i)\\}_{i=1}^k$, with $N_i$ the module name and $M_i$ its content. Compute the binary hash $h_{\\text{bin}} = H(B)$ and each module hash $h_i = H(M_i)$.\n- Serialize a quote message $\\mathcal{S}$ that includes $h_{\\text{bin}}$, the count $k$, each pair $(N_i, h_i)$, and a freshness nonce $n$ provided by the challenger. The TPM produces an attestation tag $t = \\operatorname{HMAC}_K(\\mathcal{S})$, where $K$ is a TPM-resident attestation key. In a realistic setting, $K$ would be asymmetric (for a digital signature); for this exercise, model the TPM as holding a symmetric key for $\\operatorname{HMAC}$ to focus on the integrity and freshness properties.\n- The verifier checks: (i) that the provided tag $t$ equals $\\operatorname{HMAC}_{K_{\\text{ver}}}(\\mathcal{S})$ where $K_{\\text{ver}}$ is its copy of the attestation key (or otherwise a shared secret established securely), (ii) that the nonce in the quote matches its challenge $n_{\\text{challenge}}$, and (iii) that $h_{\\text{bin}}$ and $\\{h_i\\}$ match an allowed whitelist of known-good measurements. The verdict is true if and only if all three conditions hold.\n\nOperating system role to analyze and encode in your implementation logic:\n- The operating system must mediate measurement so user-space cannot forge $\\mathcal{S}$ arbitrarily. In practice, measurement originates from the kernel or a trusted loader, and the TPM key $K$ must be protected so user-space cannot compute $\\operatorname{HMAC}_K$ except via a trusted path. The operating system also governs module loading via its dynamic loader and can enumerate loaded modules to ensure the measurement log reflects actual state.\n- Your program should simulate this separation by structurally distinguishing between a \"TPM quote\" function with access to $K$ and a verifier function, and by checking a whitelist maintained by the verifier. You must also include test cases that demonstrate spoofing attempts and the operating system's role in detecting them (e.g., tampered modules, incorrect keys, or wrong nonce challenges).\n\nTest suite specification:\nUse the following five test cases to exercise correctness, coverage, and edge conditions. Strings represent byte arrays and should be used as-is.\n- Case $1$ (Happy path): Binary $B = \\text{\"APP\\_A v1.0\"}$, modules $\\{(\\text{\"libalpha\"}, \\text{\"libalpha v1.0\"}), (\\text{\"libbeta\"}, \\text{\"libbeta v1.0\"})\\}$, TPM signing key $K = \\text{\"K\\_AIK\"}$, quote nonce $n = \\text{\"N1\"}$, verifier challenge $n_{\\text{challenge}} = \\text{\"N1\"}$. Whitelist contains $B$ and both module contents exactly.\n- Case $2$ (Tampered module content, authentic tag): Binary $B = \\text{\"APP\\_A v1.0\"}$, modules $\\{(\\text{\"libalpha\"}, \\text{\"libalpha v1.1\"}), (\\text{\"libbeta\"}, \\text{\"libbeta v1.0\"})\\}$, TPM signing key $K = \\text{\"K\\_AIK\"}$, quote nonce $n = \\text{\"N1\"}$, verifier challenge $n_{\\text{challenge}} = \\text{\"N1\"}$. Whitelist expects $\\text{\"libalpha v1.0\"}$ and $\\text{\"libbeta v1.0\"}$; the attestation tag is valid, but measurement mismatches whitelist.\n- Case $3$ (Wrong HMAC key): Binary $B = \\text{\"APP\\_A v1.0\"}$, modules $\\{(\\text{\"libalpha\"}, \\text{\"libalpha v1.0\"})\\}$, TPM signing key $K = \\text{\"K\\_AIK\\_BAD\"}$, quote nonce $n = \\text{\"N2\"}$, verifier challenge $n_{\\text{challenge}} = \\text{\"N2\"}$. Verifier uses $K_{\\text{ver}} = \\text{\"K\\_AIK\"}$; thus the tag verification fails.\n- Case $4$ (Wrong nonce): Binary $B = \\text{\"APP\\_A v1.0\"}$, modules $\\{(\\text{\"libalpha\"}, \\text{\"libalpha v1.0\"})\\}$, TPM signing key $K = \\text{\"K\\_AIK\"}$, quote nonce $n = \\text{\"N3\"}$, verifier challenge $n_{\\text{challenge}} = \\text{\"N4\"}$. Tag is valid under $K$, but freshness fails because the nonce mismatches.\n- Case $5$ (Edge case, zero modules): Binary $B = \\text{\"APP\\_MIN\"}$, modules $\\{\\}$ (empty set with $k = 0$), TPM signing key $K = \\text{\"K\\_AIK\"}$, quote nonce $n = \\text{\"N5\"}$, verifier challenge $n_{\\text{challenge}} = \\text{\"N5\"}$. Whitelist contains only $B$ and expects zero modules.\n\nYour program must:\n- Implement $H$ equivalent to SHA-256 and $\\operatorname{HMAC}$ as defined above with block size $b = 64$ bytes.\n- Compute the attestation quote message $\\mathcal{S}$ as a string that includes the hexadecimal representation of $h_{\\text{bin}}$, the module count $k$, each pair $(N_i, h_i)$ with $h_i$ in hexadecimal, and the nonce $n$. The tag $t$ is computed over this exact serialization.\n- For each test case, compute the tag $t$ using the TPM signing key $K$, then perform verification using the verifier’s key $K_{\\text{ver}}$, the challenge nonce $n_{\\text{challenge}}$, and the expected whitelist contents. The boolean result is true if and only if tag verification, nonce equality, and whitelist equality all hold.\n\nFinal output format:\nYour program should produce a single line of output containing the five boolean results for the test suite as a comma-separated list enclosed in square brackets, for example: $[\\text{true},\\text{false},\\text{true},\\text{false},\\text{true}]$. The booleans must be lowercase English words.\n\nNo physical units or angle units are involved in this problem; percentages are not used. All numeric quantities must be expressed as numbers enclosed in LaTeX dollar signs as given above.", "solution": "The user-provided problem has been analyzed and is determined to be valid. It is scientifically grounded in established principles of cryptography and operating system security, is well-posed with a clear objective and deterministic test cases, and is relevant to the specified domain. While the exact serialization format for the quote message $\\mathcal{S}$ is not rigidly defined, this minor ambiguity does not impede the creation of a unique and correct solution, as a reasonable and consistent format can be established and implemented for both the attestation generation and verification phases. I will proceed with a full solution.\n\nThe problem requires the simulation of a remote attestation protocol, a fundamental security mechanism that allows a remote verifier to obtain trustworthy information about the software state of a target system, known as the prover. The protocol's security relies on three core cryptographic principles:\n\n1.  **Integrity**: A cryptographic hash function, specified as $H$ (SHA-256), is used to create a concise and unique fingerprint (a digest) of the binary ($B$) and each loaded module ($M_i$). Any modification to the binary or a module, no matter how small, will result in a drastically different hash. This allows the verifier to detect tampering by comparing the received hashes against a whitelist of known-good values.\n\n2.  **Authenticity**: A Keyed-Hash Message Authentication Code, $\\operatorname{HMAC}_K(\\cdot)$, is used to prove that the attestation measurement was generated by a party in possession of a secret key $K$. In this model, the key resides within a Trusted Platform Module (TPM), a hardware security anchor. The verifier, holding a copy of the same key ($K_{\\text{ver}}$), can re-compute the HMAC on the received message and check if it matches the provided tag. A match authenticates the origin of the message, ensuring it came from the trusted TPM and not an imposter. The HMAC formula is given as:\n    $$\n    \\operatorname{HMAC}_K(m) = H\\left((K \\oplus \\text{opad}) \\parallel H\\left((K \\oplus \\text{ipad}) \\parallel m\\right)\\right)\n    $$\n    where $K$ is the secret key, $m$ is the message, $\\oplus$ is the bitwise XOR operation, $\\parallel$ denotes concatenation, and $\\text{ipad}$ and $\\text{opad}$ are standardized padding constants derived from the hash function's block size ($b=64$ bytes for SHA-256).\n\n3.  **Freshness**: A nonce ($n$), a \"number used once,\" is employed to prevent replay attacks. The verifier (challenger) generates a random nonce, $n_{\\text{challenge}}$, and sends it to the prover. The prover must include this exact nonce in its signed attestation quote. When the verifier receives the quote, it checks that the embedded nonce $n$ matches its original challenge $n_{\\text{challenge}}$. This confirms that the attestation is recent and not a recording of a past, potentially compromised state.\n\nThe implementation will be structured to simulate the roles and constraints described.\n\n**Cryptographic Primitive Implementation**:\nThe C program will include a self-contained implementation of the SHA-256 hash algorithm, compliant with FIPS PUB 180-4. This involves functions for initialization of the hash state, processing input data in $64$-byte blocks, and finalizing the computation to produce a $256$-bit ($32$-byte) digest. Subsequently, an `hmac_sha256` function will be implemented based on the provided formula, using the SHA-256 implementation as the underlying hash function $H$.\n\n**Protocol and Data Structure Implementation**:\n- **Measurement and Quoting**: A set of functions will simulate the prover's side. The process begins by computing the SHA-256 hash of the main application binary ($h_{\\text{bin}} = H(B)$) and each loaded module ($h_i = H(M_i)$).\n- **Quote Serialization ($\\mathcal{S}$)**: The resulting measurements are serialized into a single string, $\\mathcal{S}$, for the HMAC calculation. The chosen format for this serialization is a space-separated string: `[h_bin_hex] [k] [N1]:[h1_hex] [N2]:[h2_hex] ... [Nk]:[hk_hex] [nonce]`. The hexadecimal representation of each $32$-byte hash digest will be a $64$-character string. This format is unambiguous and contains all required information.\n- **TPM Simulation**: A function will model the trusted operation of the TPM by computing the attestation tag $t = \\operatorname{HMAC}_K(\\mathcal{S})$, taking the prover's secret key $K$ as an input.\n- **Verification**: A separate verification function simulates the remote client. This function will perform the three critical checks:\n    1.  **Tag Verification**: It re-computes the HMAC on the received quote string $\\mathcal{S}$ using the verifier's key, $K_{\\text{ver}}$, and compares it to the received tag $t$.\n    2.  **Nonce Verification**: It parses the nonce $n$ from the string $\\mathcal{S}$ and compares it to its internally held challenge nonce, $n_{\\text{challenge}}$.\n    3.  **Whitelist Verification**: It parses the binary hash $h_{\\text{bin}}$ and all module hashes $\\{h_i\\}$ from $\\mathcal{S}$ and compares them against a predefined whitelist of known-good hashes.\n\nA test case passes if and only if all three verification steps succeed. The program will execute the five specified test cases, each designed to probe a different aspect of the protocol's security: a successful attestation (Case 1), detection of tampered content (Case 2), detection of an invalid signing key (Case 3), detection of a replayed or incorrect nonce (Case 4), and correct handling of an edge case with no modules (Case 5). The final output will be a boolean array reflecting the outcome of each test.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// Note: This implementation uses basic C types like `unsigned char` (1 byte)\n// and `unsigned int` (assumed 32-bit) to adhere to the header restrictions.\n// A static assert would normally be used to verify sizeof(unsigned int) == 4.\n\n#define SHA256_BLOCK_SIZE 64\n#define SHA256_DIGEST_SIZE 32\n#define MAX_MODULES 5\n#define MAX_WHITELIST_HASHES (1 + MAX_MODULES)\n\n// ============================================================================\n// SHA-256 Implementation (based on public domain sources)\n// ============================================================================\n\ntypedef struct {\n    unsigned char data[SHA256_BLOCK_SIZE];\n    unsigned int datalen;\n    unsigned long long bitlen;\n    unsigned int state[8];\n} SHA256_CTX;\n\nstatic const unsigned int k[64] = {\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n};\n\n// Bitwise rotation right\nstatic unsigned int rotr(unsigned int x, unsigned int n) {\n    return (x  n) | (x  (32 - n));\n}\n\n// SHA-256 functions\n#define CH(x, y, z) (((x)  (y)) ^ (~(x)  (z)))\n#define MAJ(x, y, z) (((x)  (y)) ^ ((x)  (z)) ^ ((y)  (z)))\n#define EP0(x) (rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22))\n#define EP1(x) (rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25))\n#define SIG0(x) (rotr(x, 7) ^ rotr(x, 18) ^ ((x)  3))\n#define SIG1(x) (rotr(x, 17) ^ rotr(x, 19) ^ ((x)  10))\n\nvoid sha256_transform(SHA256_CTX *ctx, const unsigned char data[]) {\n    unsigned int a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];\n\n    for (i = 0, j = 0; i  16; ++i, j += 4)\n        m[i] = (data[j]  24) | (data[j + 1]  16) | (data[j + 2]  8) | (data[j + 3]);\n    for (; i  64; ++i)\n        m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];\n\n    a = ctx-state[0]; b = ctx-state[1]; c = ctx-state[2]; d = ctx-state[3];\n    e = ctx-state[4]; f = ctx-state[5]; g = ctx-state[6]; h = ctx-state[7];\n\n    for (i = 0; i  64; ++i) {\n        t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i];\n        t2 = EP0(a) + MAJ(a, b, c);\n        h = g; g = f; f = e; e = d + t1;\n        d = c; c = b; b = a; a = t1 + t2;\n    }\n\n    ctx-state[0] += a; ctx-state[1] += b; ctx-state[2] += c; ctx-state[3] += d;\n    ctx-state[4] += e; ctx-state[5] += f; ctx-state[6] += g; ctx-state[7] += h;\n}\n\nvoid sha256_init(SHA256_CTX *ctx) {\n    ctx-datalen = 0;\n    ctx-bitlen = 0;\n    ctx-state[0] = 0x6a09e667; ctx-state[1] = 0xbb67ae85;\n    ctx-state[2] = 0x3c6ef372; ctx-state[3] = 0xa54ff53a;\n    ctx-state[4] = 0x510e527f; ctx-state[5] = 0x9b05688c;\n    ctx-state[6] = 0x1f83d9ab; ctx-state[7] = 0x5be0cd19;\n}\n\nvoid sha256_update(SHA256_CTX *ctx, const unsigned char *data, size_t len) {\n    unsigned int i;\n    for (i = 0; i  len; ++i) {\n        ctx-data[ctx-datalen] = data[i];\n        ctx-datalen++;\n        if (ctx-datalen == SHA256_BLOCK_SIZE) {\n            sha256_transform(ctx, ctx-data);\n            ctx-bitlen += 512;\n            ctx-datalen = 0;\n        }\n    }\n}\n\nvoid sha256_final(SHA256_CTX *ctx, unsigned char hash[]) {\n    unsigned int i = ctx-datalen;\n    ctx-data[i++] = 0x80;\n\n    if (ctx-datalen = 56) {\n        memset(ctx-data + i, 0, SHA256_BLOCK_SIZE - i);\n        sha256_transform(ctx, ctx-data);\n        memset(ctx-data, 0, SHA256_BLOCK_SIZE - 8);\n    } else {\n        memset(ctx-data + i, 0, SHA256_BLOCK_SIZE - i - 8);\n    }\n\n    ctx-bitlen += ctx-datalen * 8;\n    ctx-data[63] = ctx-bitlen;\n    ctx-data[62] = ctx-bitlen  8;\n    ctx-data[61] = ctx-bitlen  16;\n    ctx-data[60] = ctx-bitlen  24;\n    ctx-data[59] = ctx-bitlen  32;\n    ctx-data[58] = ctx-bitlen  40;\n    ctx-data[57] = ctx-bitlen  48;\n    ctx-data[56] = ctx-bitlen  56;\n    sha256_transform(ctx, ctx-data);\n\n    for (i = 0; i  8; ++i) {\n        hash[i*4 + 0] = (ctx-state[i]  24)  0xff;\n        hash[i*4 + 1] = (ctx-state[i]  16)  0xff;\n        hash[i*4 + 2] = (ctx-state[i]  8)  0xff;\n        hash[i*4 + 3] = (ctx-state[i])  0xff;\n    }\n}\n\n// ============================================================================\n// HMAC-SHA256 Implementation\n// ============================================================================\n\nvoid hmac_sha256(const char *key_str, const char *msg, unsigned char *digest) {\n    unsigned char key[SHA256_BLOCK_SIZE];\n    unsigned char k_ipad[SHA256_BLOCK_SIZE];\n    unsigned char k_opad[SHA256_BLOCK_SIZE];\n    size_t key_len = strlen(key_str);\n    SHA256_CTX ctx;\n\n    memset(key, 0, SHA256_BLOCK_SIZE);\n    if (key_len  SHA256_BLOCK_SIZE) {\n        sha256_init(ctx);\n        sha256_update(ctx, (unsigned char*)key_str, key_len);\n        sha256_final(ctx, key);\n    } else {\n        memcpy(key, key_str, key_len);\n    }\n\n    for (size_t i = 0; i  SHA256_BLOCK_SIZE; ++i) {\n        k_ipad[i] = key[i] ^ 0x36;\n        k_opad[i] = key[i] ^ 0x5c;\n    }\n\n    unsigned char inner_hash[SHA256_DIGEST_SIZE];\n    sha256_init(ctx);\n    sha256_update(ctx, k_ipad, SHA256_BLOCK_SIZE);\n    sha256_update(ctx, (unsigned char*)msg, strlen(msg));\n    sha256_final(ctx, inner_hash);\n\n    sha256_init(ctx);\n    sha256_update(ctx, k_opad, SHA256_BLOCK_SIZE);\n    sha256_update(ctx, inner_hash, SHA256_DIGEST_SIZE);\n    sha256_final(ctx, digest);\n}\n\n// ============================================================================\n// Helper and Protocol Structures\n// ============================================================================\n\nvoid bytes_to_hex(const unsigned char* bytes, size_t len, char* hex_str) {\n    for (size_t i = 0; i  len; ++i) {\n        sprintf(hex_str + i * 2, \"%02x\", bytes[i]);\n    }\n    hex_str[len * 2] = '\\0';\n}\n\ntypedef struct {\n    const char* name;\n    const char* content;\n} Module;\n\ntypedef struct {\n    unsigned char binary_hash[SHA256_DIGEST_SIZE];\n    int module_count;\n    unsigned char module_hashes[MAX_MODULES][SHA256_DIGEST_SIZE];\n} Whitelist;\n\ntypedef struct {\n    const char* binary_content;\n    int module_count;\n    Module modules[MAX_MODULES];\n\n    const char* tpm_key;\n    const char* nonce;\n    \n    const char* verifier_key;\n    const char* challenge_nonce;\n    const Whitelist* whitelist;\n} TestCase;\n\n// ============================================================================\n// Main Logic\n// ============================================================================\n\nint main(void) {\n    // === Define Whitelists ===\n    unsigned char hash_app_a_v1[SHA256_DIGEST_SIZE], hash_app_min[SHA256_DIGEST_SIZE];\n    unsigned char hash_libalpha_v1[SHA256_DIGEST_SIZE], hash_libbeta_v1[SHA256_DIGEST_SIZE];\n    SHA256_CTX ctx;\n\n    sha256_init(ctx); sha256_update(ctx, (unsigned char*)\"APP_A v1.0\", 10); sha256_final(ctx, hash_app_a_v1);\n    sha256_init(ctx); sha256_update(ctx, (unsigned char*)\"APP_MIN\", 7); sha256_final(ctx, hash_app_min);\n    sha256_init(ctx); sha256_update(ctx, (unsigned char*)\"libalpha v1.0\", 13); sha256_final(ctx, hash_libalpha_v1);\n    sha256_init(ctx); sha256_update(ctx, (unsigned char*)\"libbeta v1.0\", 12); sha256_final(ctx, hash_libbeta_v1);\n\n    Whitelist whitelist1;\n    memcpy(whitelist1.binary_hash, hash_app_a_v1, SHA256_DIGEST_SIZE);\n    whitelist1.module_count = 2;\n    memcpy(whitelist1.module_hashes[0], hash_libalpha_v1, SHA256_DIGEST_SIZE);\n    memcpy(whitelist1.module_hashes[1], hash_libbeta_v1, SHA256_DIGEST_SIZE);\n\n    Whitelist whitelist5;\n    memcpy(whitelist5.binary_hash, hash_app_min, SHA256_DIGEST_SIZE);\n    whitelist5.module_count = 0;\n\n    // === Define Test Cases ===\n    TestCase test_cases[] = {\n        // Case 1: Happy path\n        {\n            \"APP_A v1.0\", 2, {{\"libalpha\", \"libalpha v1.0\"}, {\"libbeta\", \"libbeta v1.0\"}},\n            \"K_AIK\", \"N1\",\n            \"K_AIK\", \"N1\", whitelist1\n        },\n        // Case 2: Tampered module\n        {\n            \"APP_A v1.0\", 2, {{\"libalpha\", \"libalpha v1.1\"}, {\"libbeta\", \"libbeta v1.0\"}},\n            \"K_AIK\", \"N1\",\n            \"K_AIK\", \"N1\", whitelist1\n        },\n        // Case 3: Wrong HMAC key\n        {\n            \"APP_A v1.0\", 1, {{\"libalpha\", \"libalpha v1.0\"}},\n            \"K_AIK_BAD\", \"N2\",\n            \"K_AIK\", \"N2\", whitelist1 // verifier expects a 2-module whitelist, but this fails at tag check first\n        },\n        // Case 4: Wrong nonce\n        {\n            \"APP_A v1.0\", 1, {{\"libalpha\", \"libalpha v1.0\"}},\n            \"K_AIK\", \"N3\",\n            \"K_AIK\", \"N4\", whitelist1\n        },\n        // Case 5: Edge case, zero modules\n        {\n            \"APP_MIN\", 0, {},\n            \"K_AIK\", \"N5\",\n            \"K_AIK\", \"N5\", whitelist5\n        }\n    };\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase* tc = test_cases[i];\n        \n        // --- PROVER/TPM SIDE ---\n        \n        // 1. Measure binary and modules\n        unsigned char h_bin[SHA256_DIGEST_SIZE];\n        unsigned char h_mods[MAX_MODULES][SHA256_DIGEST_SIZE];\n        sha256_init(ctx); sha256_update(ctx, (unsigned char*)tc-binary_content, strlen(tc-binary_content)); sha256_final(ctx, h_bin);\n\n        for (int j = 0; j  tc-module_count; ++j) {\n            sha256_init(ctx); sha256_update(ctx, (unsigned char*)tc-modules[j].content, strlen(tc-modules[j].content)); sha256_final(ctx, h_mods[j]);\n        }\n\n        // 2. Serialize the quote message S\n        char quote_S[4096];\n        char h_bin_hex[SHA256_DIGEST_SIZE * 2 + 1];\n        bytes_to_hex(h_bin, SHA256_DIGEST_SIZE, h_bin_hex);\n        sprintf(quote_S, \"%s %d\", h_bin_hex, tc-module_count);\n        \n        for (int j = 0; j  tc-module_count; ++j) {\n            char h_mod_hex[SHA256_DIGEST_SIZE * 2 + 1];\n            bytes_to_hex(h_mods[j], SHA256_DIGEST_SIZE, h_mod_hex);\n            sprintf(quote_S + strlen(quote_S), \" %s:%s\", tc-modules[j].name, h_mod_hex);\n        }\n        sprintf(quote_S + strlen(quote_S), \" %s\", tc-nonce);\n\n        // 3. TPM computes attestation tag t\n        unsigned char tag_t[SHA256_DIGEST_SIZE];\n        hmac_sha256(tc-tpm_key, quote_S, tag_t);\n\n        // --- VERIFIER SIDE ---\n\n        int is_valid = 1; // Assume valid until a check fails\n\n        // Check 1: HMAC Tag verification\n        unsigned char verifier_tag[SHA256_DIGEST_SIZE];\n        hmac_sha256(tc-verifier_key, quote_S, verifier_tag);\n        if (memcmp(tag_t, verifier_tag, SHA256_DIGEST_SIZE) != 0) {\n            is_valid = 0;\n        }\n\n        if (is_valid) {\n            // Check 2: Nonce verification\n            // The nonce is the last word in the quote string\n            char* last_space = strrchr(quote_S, ' ');\n            if (!last_space || strcmp(last_space + 1, tc-challenge_nonce) != 0) {\n                is_valid = 0;\n            }\n        }\n        \n        if (is_valid) {\n            // Check 3: Whitelist verification\n            if (memcmp(h_bin, tc-whitelist-binary_hash, SHA256_DIGEST_SIZE) != 0) {\n                is_valid = 0;\n            } else if (tc-module_count != tc-whitelist-module_count) {\n                // This check is implicitly handled by iterating over module hashes\n                // but explicit check is clearer.\n                is_valid = 0;\n            } else {\n                // For simplicity, we assume order matters. A real implementation\n                // would treat hashes as a set.\n                for (int j = 0; j  tc-module_count; ++j) {\n                    if (memcmp(h_mods[j], tc-whitelist-module_hashes[j], SHA256_DIGEST_SIZE) != 0) {\n                        is_valid = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        results[i] = is_valid;\n    }\n\n    // Print the results in the EXACT REQUIRED format\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"%s%s\", (i  0 ? \",\" : \"\"), (results[i] ? \"true\" : \"false\"));\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3631438"}]}