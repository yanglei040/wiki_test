{"hands_on_practices": [{"introduction": "We begin our hands-on exploration with Discretionary Access Control (DAC), the permission model familiar to users of systems like Linux or Windows. This first exercise [@problem_id:3619218] simulates a common administrative task: revoking a user's group membership. By analyzing the outcomes of file operations before and after this change, you will solidify your understanding of a fundamental principle: access rights are evaluated dynamically at the time of the request, making revocation effective immediately after a subject's credentials are updated.", "problem": "An operating system implements Discretionary Access Control (DAC), Mandatory Access Control (MAC), and Role-Based Access Control (RBAC). Discretionary Access Control (DAC) on a typical Unix-like system uses owner, group, and others permission bits, and the Set Group ID (SGID) bit on directories causes new files created within the directory to inherit the directory’s group. Under DAC, effective access for a process to a filesystem object is determined by comparing the process’s credentials (user identifier and set of group identifiers) to the object’s ownership fields and then applying the appropriate permission class: owner bits if the process’s user identifier equals the owner, group bits if any of the process’s group identifiers equals the file’s group, and otherwise others bits. Additionally, the system uses a process creation mask (umask) to clear permission bits at file creation. Mandatory Access Control (MAC) can further constrain access based on labels and policy, while Role-Based Access Control (RBAC) assigns permissions by roles rather than identities or groups; however, for this experiment, assume MAC is not enforcing any additional constraints and that RBAC is not configured to override DAC.\n\nDesign and evaluate the following controlled experiment intended to demonstrate how revocation of group membership affects effective rights when SGID directories cause new files to inherit groups.\n\nSetup:\n- There are two users, $u_{alice}$ and $u_{bob}$, and one group $G_{dev}$.\n- The directory $D = \\text{/proj/dev}$ is owned by $u_{alice}$, has group $G_{dev}$, and its mode is $2775$ (the leading $2$ sets the SGID bit on the directory, so the mode is $rwxrwxr-x$). No Access Control List (ACL) entries are present beyond mode bits. The umask for processes of both users is $002$.\n- At time $t_1$, $u_{bob}$ is a member of $G_{dev}$ and authenticates to obtain fresh credentials reflecting current group membership.\n- At time $t_1$, $u_{alice}$ creates file $f_1$ inside $D$ by calling $\\text{open}(\\text{\"}f_1\\text{\"}, O\\_CREAT)$ with the requested mode $0666$. Due to the umask $002$, the actual mode becomes $0664$; because $D$ has SGID set, the group of $f_1$ becomes $G_{dev}$, and the owner of $f_1$ is $u_{alice}$.\n- Immediately after $t_1$, $u_{bob}$ has no open file descriptors to $f_1$ and has not cached any capabilities beyond standard credentials.\n- At time $t_2$, the administrator revokes $u_{bob}$’s membership in $G_{dev}$ and forces $u_{bob}$ to reauthenticate, ensuring his process credentials reflect the revocation.\n- At time $t_3 > t_2$, $u_{alice}$ creates file $f_2$ inside $D$ with requested mode $0666$; due to umask $002$, the actual mode is $0664$ and, due to SGID on $D$, the group of $f_2$ is $G_{dev}$, with owner $u_{alice}$.\n- At time $t_4 > t_3$, $u_{bob}$ attempts the following operations: write to $f_1$, write to $f_2$, and create a new file $f_3$ in $D$ with requested mode $0666$.\n\nAssumptions:\n- No Mandatory Access Control (MAC) labels or policies are active that would deny or permit access beyond DAC.\n- No Role-Based Access Control (RBAC) roles are in force for $u_{bob}$ that would override DAC outcomes.\n- No POSIX ACLs are set on $D$, $f_1$, or $f_2$ beyond the standard mode bits.\n- All access checks occur at the time of each operation; in particular, $u_{bob}$ did not open $f_1$ for writing before $t_2$.\n\nWhich of the following outcome sets, observed at time $t_4$, correctly demonstrates the effect of revoking $u_{bob}$’s membership in $G_{dev}$ under these conditions?\n\nA. Before revocation at $t_1$, $u_{bob}$ can write $f_1$ via group $G_{dev}$; after revocation at $t_2$ and reauthentication, $u_{bob}$ cannot write to $f_1$, cannot write to $f_2$, and cannot create $f_3$ in $D$.\n\nB. $u_{bob}$ can still write to $f_1$ after revocation because the SGID bit “pins” group write permission to files in $D$; $u_{bob}$ cannot write to $f_2$, but can create $f_3$ because SGID grants create regardless of group membership.\n\nC. Revocation only affects future files: $u_{bob}$ retains write access to $f_1$ but loses write access to $f_2$; creation of $f_3$ remains permitted because $u_{bob}$ previously had membership in $G_{dev}$ at $t_1$.\n\nD. Even with no Role-Based Access Control (RBAC) configured to override DAC, revoking $u_{bob}$’s membership in $G_{dev}$ at $t_2$ does not affect DAC outcomes on $f_1$ or $f_2$ due to SGID; $u_{bob}$ can write both $f_1$ and $f_2$ and can create $f_3$ in $D$.", "solution": "The problem statement describes a controlled experiment on a Unix-like operating system to test the effects of group membership revocation on file access permissions under a Discretionary Access Control (DAC) policy. The analysis requires a precise application of the rules for DAC, the Set Group ID (SGID) bit on directories, and the process creation mask (umask).\n\n### Problem Validation\nThe provided problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- **Users**: $u_{alice}$, $u_{bob}$\n- **Group**: $G_{dev}$\n- **Directory**: $D = \\text{/proj/dev}$\n    - Owner: $u_{alice}$\n    - Group: $G_{dev}$\n    - Mode: $2775$ (octal), which is $rwxrwxr-x$ with the SGID bit set.\n- **Umask**: $002$ (octal) for both users.\n- **Timeline and Events**:\n    - **$t_1$**: $u_{bob}$ is a member of $G_{dev}$ and has credentials reflecting this. $u_{alice}$ creates file $f_1$ in $D$ with requested mode $0666$. The resulting file has owner $u_{alice}$, group $G_{dev}$ (due to SGID on $D$), and mode $0664$ (due to umask $002$). $u_{bob}$ holds no open file descriptors to $f_1$.\n    - **$t_2$**: $u_{bob}$'s membership in $G_{dev}$ is revoked. $u_{bob}$ reauthenticates to update his credentials.\n    - **$t_3$**: $u_{alice}$ creates file $f_2$ in $D$ with requested mode $0666$. The resulting file has owner $u_{alice}$, group $G_{dev}$, and mode $0664$.\n    - **$t_4$**: $u_{bob}$ attempts three operations: write to $f_1$, write to $f_2$, create $f_3$ in $D$.\n- **Assumptions**: No overriding MAC or RBAC policies, no POSIX ACLs, access checks are performed at the time of the operation.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective. It describes a standard, verifiable scenario in operating systems security based on POSIX-compliant file system semantics.\n- The description of DAC, SGID on directories, and umask functionality is accurate and aligns with established principles of operating systems like Linux.\n- The setup is self-contained and provides all necessary information (users, groups, permissions, actions) to deduce a unique outcome.\n- The problem is free of contradictions. For example, the calculation of the final file mode from the requested mode and the umask is correct: the effective permissions are `(requested_mode) & (~umask)`. For a requested mode of $0666_8$ and a umask of $0002_8$, the calculation is $0666_8 \\text{ AND } (\\text{NOT } 0002_8) = 0666_8 \\text{ AND } 0775_8 = 0664_8$.\n- The language is precise and technical.\n\n**Step 3: Verdict and Action**\nThe problem statement is **valid**. A solution can be derived.\n\n### Derivation of Solution\nThe solution is derived by analyzing the permissions of each filesystem object and the credentials of user $u_{bob}$ at the time of the access attempts.\n\n**1. Object Permissions Analysis**\n- **Directory $D = \\text{/proj/dev}$**:\n    - Permissions: mode $2775_8$. This gives $rwx$ to the owner ($u_{alice}$), $rwx$ to the group ($G_{dev}$), and $r-x$ to others. The leading $2$ sets the SGID bit. To create a file within a directory, a process needs both write ($w$) and execute ($x$) permissions on the directory.\n- **File $f_1$ (created at $t_1$)**:\n    - Owner: $u_{alice}$\n    - Group: $G_{dev}$ (inherited from $D$ due to SGID)\n    - Mode: $0664_8$ ($rw-rw-r--$). This gives read/write ($rw-$) to the owner, read/write ($rw-$) to the group, and read-only ($r--$) to others.\n- **File $f_2$ (created at $t_3$)**:\n    - Owner: $u_{alice}$\n    - Group: $G_{dev}$\n    - Mode: $0664_8$ ($rw-rw-r--$). Permissions are identical to $f_1$.\n\n**2. Access Analysis at Time $t_1$ (Before Revocation)**\nAt time $t_1$, $u_{bob}$'s process credentials include membership in $G_{dev}$. When accessing $f_1$:\n- The process UID ($u_{bob}$) does not match the file's owner UID ($u_{alice}$).\n- A process GID ($G_{dev}$) matches the file's group GID ($G_{dev}$).\n- Therefore, the group permissions are used. For $f_1$, these are $rw-$.\n- Conclusion: At $t_1$, $u_{bob}$ can read and write to $f_1$.\n\n**3. Access Analysis at Time $t_4$ (After Revocation)**\nAt time $t_2$, $u_{bob}$'s membership in $G_{dev}$ is revoked, and he reauthenticates. At time $t_4$, any new process run by $u_{bob}$ will have credentials that do not include $G_{dev}$. Access checks occur at the time of the operation ($t_4$) using these new credentials.\n\n- **Attempt 1: Write to file $f_1$**\n    - Target: $f_1$ (owner: $u_{alice}$, group: $G_{dev}$, mode: $rw-rw-r--$)\n    - $u_{bob}$'s credentials: UID is $u_{bob}$, GIDs do **not** include $G_{dev}$.\n    - Access Check:\n        1. UID match? No ($u_{bob} \\neq u_{alice}$).\n        2. GID match? No ($G_{dev}$ is not in $u_{bob}$'s GID set).\n        3. Default to \"others\" permissions.\n    - The \"others\" permissions on $f_1$ are $r--$. This does not grant write permission.\n    - **Outcome**: The write operation is denied.\n\n- **Attempt 2: Write to file $f_2$**\n    - Target: $f_2$ (owner: $u_{alice}$, group: $G_{dev}$, mode: $rw-rw-r--$)\n    - The access check is identical to that for $f_1$. $u_{bob}$ is not the owner and is not in the file's group, so \"others\" permissions apply.\n    - The \"others\" permissions are $r--$.\n    - **Outcome**: The write operation is denied.\n\n- **Attempt 3: Create file $f_3$ in directory $D$**\n    - Target: $D$ (owner: $u_{alice}$, group: $G_{dev}$, mode: $rwxrwxr-x$)\n    - Operation: Creating a file requires write ($w$) and execute ($x$) permissions on the containing directory.\n    - $u_{bob}$'s credentials: Not owner, not in group.\n    - Access Check: \"others\" permissions apply.\n    - The \"others\" permissions on $D$ are $r-x$. This grants read and execute/search permissions, but **not** write permission.\n    - **Outcome**: The file creation is denied.\n\n**Summary of Outcomes:** At $t_4$, $u_{bob}$ cannot write to $f_1$, cannot write to $f_2$, and cannot create $f_3$ in $D$. The revocation of group membership, combined with reauthentication, effectively and immediately removes all access rights that were dependent on that group membership.\n\n### Option-by-Option Analysis\n\n- **A. Before revocation at $t_1$, $u_{bob}$ can write $f_1$ via group $G_{dev}$; after revocation at $t_2$ and reauthentication, $u_{bob}$ cannot write to $f_1$, cannot write to $f_2$, and cannot create $f_3$ in $D$.**\n    - The first clause is correct, as analyzed for time $t_1$.\n    - The second clause, listing the outcomes at $t_4$, matches our derivation perfectly: all three attempted operations fail.\n    - **Verdict: Correct.**\n\n- **B. $u_{bob}$ can still write to $f_1$ after revocation because the SGID bit “pins” group write permission to files in $D$; $u_{bob}$ cannot write to $f_2$, but can create $f_3$ because SGID grants create regardless of group membership.**\n    - This option is based on a misunderstanding of SGID. SGID on a directory affects group ownership of new files, it does not \"pin\" permissions or override the standard DAC evaluation based on current credentials. As derived, $u_{bob}$ cannot write to $f_1$ or create $f_3$.\n    - **Verdict: Incorrect.**\n\n- **C. Revocation only affects future files: $u_{bob}$ retains write access to $f_1$ but loses write access to $f_2$; creation of $f_3$ remains permitted because $u_{bob}$ previously had membership in $G_{dev}$ at $t_1$.**\n    - This is incorrect. Access control in DAC is dynamic; it does not depend on when the file was created or on historical group memberships. Rights are checked at the time of access. $u_{bob}$ loses access to all files for which his permission depended on $G_{dev}$, including $f_1$. He also cannot create $f_3$.\n    - **Verdict: Incorrect.**\n\n- **D. Even with no Role-Based Access Control (RBAC) configured to override DAC, revoking $u_{bob}$’s membership in $G_{dev}$ at $t_2$ does not affect DAC outcomes on $f_1$ or $f_2$ due to SGID; $u_{bob}$ can write both $f_1$ and $f_2$ and can create $f_3$ in $D$.**\n    - This option claims revocation is ineffective, which is the opposite of the truth. The problem explicitly states $u_{bob}$ reauthenticates, meaning his credentials are updated. DAC uses these updated credentials. The SGID bit is irrelevant to this access check. All three predicted outcomes in this option are wrong.\n    - **Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "3619218"}, {"introduction": "Having seen how revocation works in a discretionary model, we now turn to the more structured world of Mandatory Access Control (MAC). In this practice [@problem_id:3619220], you will move beyond simple file permissions to model system-wide security policy as an information flow graph. By implementing a check for noninterference, you will gain a practical understanding of how MAC enforces confidentiality and how revoking permissions is equivalent to severing pathways for potential information leaks between different security levels.", "problem": "You are to model Mandatory Access Control (MAC) information flows and revocation of write privileges using a directed graph and demonstrate noninterference with respect to a two-level confidentiality partition. Use the following fundamental base:\n\n- Let a system have a finite set of security labels organized in a lattice with partial order $\\preceq$. Every subject or object $v$ has a label $\\ell(v)$. In classical confidentiality MAC, write operations must respect the property \"no write down,\" i.e., writing from $u$ to $w$ is permitted only if $\\ell(u) \\preceq \\ell(w)$.\n- Noninterference, in the two-level confidentiality sense, requires that actions at a high-security level do not alter what is observable at a low-security level, which can be operationally reasoned about as the absence of any information flow from high to low through allowed operations.\n\nYour program must:\n\n- Represent a small information-flow graph as a directed graph $G = (V, E)$, where vertices $V$ represent subjects or objects, and directed edges $(u, v) \\in E$ represent currently allowed write flows from $u$ to $v$.\n- Apply revocation to write edges: a revocation is the removal of designated edges from $E$, producing a new edge set $E' \\subseteq E$.\n- After revocation, determine whether noninterference holds by checking that there is no path in $G' = (V, E')$ that starts at any vertex $s$ with $\\ell(s) = H$ and reaches any vertex $t$ with $\\ell(t) = L$. For this problem, use a two-level partition with low set $L$ at numeric label $0$ and high set $H$ at numeric label $2$. Vertices with any other label (e.g., $1$) are intermediates that should be considered only as potential waypoints; they are not directly part of the low or high sets for the noninterference check.\n- Return, for each test case, a boolean expressed as an integer: output $1$ if noninterference holds (no high-to-low reachability) after revocation, and output $0$ otherwise.\n\nImplement the solution purely in terms of graph reachability using the remaining write edges after revocation. You must define the revocation semantics as the elimination of specified write edges from the graph. You may assume that all edges in these test cases are write edges.\n\nTest Suite:\nUse exactly the following five test cases. In all cases, the label function $\\ell$ maps vertices to integers, with $0$ meaning low $L$, $1$ meaning intermediate, and $2$ meaning high $H$. All edges listed are write edges prior to revocation. Vertices are indexed starting from $0$.\n\n- Test case $1$ (happy path: revocation blocks a high-to-low flow):\n  - $|V| = 3$, labels $\\ell = [2, 1, 0]$ for vertices $[0, 1, 2]$ respectively.\n  - Initial edges $E = \\{(0,1), (1,2), (0,2)\\}$.\n  - Revoked edges: indices $0$ and $2$, i.e., remove $(0,1)$ and $(0,2)$, keep $(1,2)$.\n\n- Test case $2$ (boundary: no edges):\n  - $|V| = 3$, labels $\\ell = [2, 1, 0]$ for vertices $[0, 1, 2]$ respectively.\n  - Initial edges $E = \\emptyset$.\n  - Revoked edges: none.\n\n- Test case $3$ (edge case: cycle among high nodes, no path to low):\n  - $|V| = 3$, labels $\\ell = [2, 2, 0]$ for vertices $[0, 1, 2]$ respectively.\n  - Initial edges $E = \\{(0,1), (1,0)\\}$.\n  - Revoked edges: none.\n\n- Test case $4$ (negative case: indirect path from high to low remains):\n  - $|V| = 3$, labels $\\ell = [2, 1, 0]$ for vertices $[0, 1, 2]$ respectively.\n  - Initial edges $E = \\{(0,1), (1,2)\\}$.\n  - Revoked edges: none.\n\n- Test case $5$ (revocation removes a direct high-to-low edge):\n  - $|V| = 2$, labels $\\ell = [2, 0]$ for vertices $[0, 1]$ respectively.\n  - Initial edges $E = \\{(0,1)\\}$.\n  - Revoked edges: index $0$, i.e., remove $(0,1)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for the five test cases, as a comma-separated list enclosed in square brackets, in the order the test cases are given. For example, the output must be of the form $[r_1,r_2,r_3,r_4,r_5]$, where each $r_i$ is an integer $0$ or $1$ as defined above. There are no physical quantities, so no units are required. Angles and percentages do not apply.", "solution": "The problem is assessed to be **valid**. It presents a well-defined task grounded in the formal principles of computer security, specifically information flow control and noninterference. The problem is self-contained, with all necessary data and definitions provided. The use of a directed graph to model information flow and reachability analysis to check for policy violations is a standard and sound methodology in this domain.\n\nThe central principle is **noninterference**, a security policy that aims to prevent actions performed by subjects at a high-security level from having any effect on the observations of subjects at a low-security level. In the context of this problem, noninterference is formalized as the absence of information flow from high-security entities to low-security entities.\n\nWe model the system as a directed graph $G' = (V, E')$, where:\n- $V$ is the set of all subjects and objects in the system, represented as vertices.\n- Each vertex $v \\in V$ is assigned a security label $\\ell(v)$. The problem specifies a lattice of labels, but here we use a discrete set $\\{0, 1, 2\\}$, where $\\ell(v)=0$ corresponds to a low-security level ($L$), and $\\ell(v)=2$ corresponds to a high-security level ($H$). Vertices with $\\ell(v)=1$ are considered intermediate and are neither sources nor sinks for the noninterference check, but can be part of a flow path.\n- $E'$ is the set of directed edges representing permitted information flows (write operations) *after* a revocation operation has occurred. An edge $(u, v) \\in E'$ signifies that information can flow from $u$ to $v$.\n\nA violation of noninterference occurs if there is a path from any high-security vertex to any low-security vertex. Let $V_H = \\{s \\in V \\mid \\ell(s) = 2\\}$ be the set of high-security vertices and $V_L = \\{t \\in V \\mid \\ell(t) = 0\\}$ be the set of low-security vertices. Noninterference is violated if there exists at least one pair $(s, t)$ with $s \\in V_H$ and $t \\in V_L$ such that $t$ is reachable from $s$ in the graph $G'$. Mathematically, a violation exists if:\n$$ \\exists s \\in V_H, \\exists t \\in V_L \\text{ such that a path } s \\to \\dots \\to t \\text{ exists in } G' $$\nIf no such path exists for any pair $(s, t)$, noninterference is said to hold.\n\nThe algorithmic solution proceeds as follows for each test case:\n\n1.  **Graph Construction:** The graph $G'=(V, E')$ is constructed. We can use an adjacency matrix $A$ of size $|V| \\times |V|$, initialized with all entries as $0$. The initial set of edges $E$ is given. We iterate through these edges. For each edge $(u,v) \\in E$ that is *not* in the set of revoked edges, we set the corresponding matrix entry $A_{uv} = 1$. This matrix represents the final set of allowed flows $E'$.\n\n2.  **Identify High and Low Vertices:** From the given label mapping $\\ell$, we identify the sets $V_H$ and $V_L$.\n\n3.  **Reachability Analysis:** To check for a violation, we must determine if any vertex in $V_L$ is reachable from any vertex in $V_H$. A systematic way to do this is to perform a graph traversal, such as a Depth-First Search (DFS), starting from each high-security vertex.\n    - For each vertex $s \\in V_H$:\n        - Initiate a DFS starting from $s$.\n        - A `visited` array, reset for each new starting vertex $s$, is used to track visited vertices during the traversal to avoid infinite loops in case of cycles.\n        - The DFS explores vertices reachable from $s$. If at any point the traversal reaches a vertex $t$ such that $t \\in V_L$ (i.e., $\\ell(t)=0$), an information flow from high to low has been discovered.\n        - Upon finding such a path, the noninterference property is violated. We can immediately conclude the result for the test case is $0$ and terminate the search.\n\n4.  **Final Verdict:** If the traversal from every vertex $s \\in V_H$ completes without ever reaching any vertex in $V_L$, it proves that no such high-to-low path exists in the graph. In this case, the noninterference property holds, and the result for the test case is $1$.\n\nThis algorithm correctly and completely solves the problem by translating the abstract security property of noninterference into a concrete graph reachability problem.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n// #include <complex.h> // Not needed\n// #include <threads.h> // Not needed\n// #include <stdatomic.h> // Not needed\n\n// Define problem-specific constants for clarity and safety.\n#define MAX_VERTICES 4 // Max vertices across all test cases is 3, using 4 for safety.\n#define MAX_EDGES 3    // Max edges across all test cases is 3.\n\n// Security level definitions from the problem.\n#define HIGH_LEVEL 2\n#define LOW_LEVEL 0\n\n// A struct to represent a directed edge in the graph.\ntypedef struct {\n    int u; // source vertex\n    int v; // destination vertex\n} Edge;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int num_vertices;\n    int labels[MAX_VERTICES];\n    int num_edges;\n    Edge edges[MAX_EDGES];\n    int num_revoked;\n    int revoked_indices[MAX_EDGES];\n} TestCase;\n\n/**\n * @brief Performs a Depth-First Search (DFS) to find a path to a low-security vertex.\n *\n * @param u The current vertex in the traversal.\n * @param num_vertices The total number of vertices in the graph.\n * @param adj The adjacency matrix representing the graph.\n * @param labels The array of security labels for each vertex.\n * @param visited An array to keep track of visited vertices in the current DFS traversal.\n * @return Returns 1 if a path to a low-security vertex is found, 0 otherwise.\n */\nint has_path_to_low_recursive(int u, int num_vertices, const int adj[][MAX_VERTICES], const int labels[], int visited[]) {\n    visited[u] = 1;\n\n    for (int v = 0; v < num_vertices; ++v) {\n        if (adj[u][v]) { // If there is an edge from u to v\n            if (labels[v] == LOW_LEVEL) {\n                return 1; // Path to a low-level vertex found\n            }\n            if (!visited[v]) {\n                if (has_path_to_low_recursive(v, num_vertices, adj, labels, visited)) {\n                    return 1; // Propagate the \"found\" signal up the recursion stack\n                }\n            }\n        }\n    }\n    return 0; // No path found from this branch\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        // Test case 1 (happy path: revocation blocks flow)\n        {   .num_vertices = 3, \n            .labels = {2, 1, 0}, \n            .num_edges = 3, \n            .edges = {{0, 1}, {1, 2}, {0, 2}}, \n            .num_revoked = 2, \n            .revoked_indices = {0, 2}\n        },\n        // Test case 2 (boundary: no edges)\n        {   .num_vertices = 3, \n            .labels = {2, 1, 0}, \n            .num_edges = 0, \n            .edges = {}, \n            .num_revoked = 0, \n            .revoked_indices = {}\n        },\n        // Test case 3 (edge case: cycle among high nodes)\n        {   .num_vertices = 3, \n            .labels = {2, 2, 0}, \n            .num_edges = 2, \n            .edges = {{0, 1}, {1, 0}}, \n            .num_revoked = 0, \n            .revoked_indices = {}\n        },\n        // Test case 4 (negative case: indirect path remains)\n        {   .num_vertices = 3, \n            .labels = {2, 1, 0}, \n            .num_edges = 2, \n            .edges = {{0, 1}, {1, 2}}, \n            .num_revoked = 0, \n            .revoked_indices = {}\n        },\n        // Test case 5 (revocation removes direct high-to-low edge)\n        {   .num_vertices = 2, \n            .labels = {2, 0}, \n            .num_edges = 1, \n            .edges = {{0, 1}},\n            .num_revoked = 1, \n            .revoked_indices = {0}\n        }\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        int adj[MAX_VERTICES][MAX_VERTICES];\n        memset(adj, 0, sizeof(adj));\n\n        // Build the post-revocation adjacency matrix.\n        int is_revoked_flags[MAX_EDGES] = {0};\n        for (int j = 0; j < tc.num_revoked; ++j) {\n            is_revoked_flags[tc.revoked_indices[j]] = 1;\n        }\n\n        for (int j = 0; j < tc.num_edges; ++j) {\n            if (!is_revoked_flags[j]) {\n                Edge e = tc.edges[j];\n                adj[e.u][e.v] = 1;\n            }\n        }\n\n        // Check for noninterference.\n        int interference_found = 0;\n        for (int start_node = 0; start_node < tc.num_vertices; ++start_node) {\n            if (tc.labels[start_node] == HIGH_LEVEL) {\n                int visited[MAX_VERTICES] = {0};\n                if (has_path_to_low_recursive(start_node, tc.num_vertices, (const int (*)[MAX_VERTICES])adj, tc.labels, visited)) {\n                    interference_found = 1;\n                    break; // A high-to-low path was found, no need to check other high nodes.\n                }\n            }\n        }\n        \n        // Result is 1 if noninterference holds (no path found), 0 otherwise.\n        results[i] = !interference_found;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3619220"}, {"introduction": "Our final practice looks beneath the policy layer to a critical implementation challenge that affects all access control models: the race against time. A security policy is only as strong as its enforcement mechanism, which can be undermined by concurrency bugs. This exercise [@problem_id:3619192] explores the infamous Time-Of-Check-To-Time-Of-Use (TOCTOU) vulnerability, challenging you to think like an operating system designer and construct a sequence of operations that guarantees revocation is atomic and secure, preventing attackers from exploiting the tiny window between when a permission is checked and when it is used.", "problem": "A multi-user operating system kernel must enforce access decisions for file opens under Discretionary Access Control (DAC), Mandatory Access Control (MAC), and Role-Based Access Control (RBAC). Let the authorization function be $Auth(s,o,p)$, which returns true if and only if the subject $s$ is permitted to perform privilege $p$ on object $o$ by all active policies, that is $Auth(s,o,p) = Auth_{DAC}(s,o,p) \\land Auth_{MAC}(s,o,p) \\land Auth_{RBAC}(s,o,p)$. A revocation event updates the relevant policy state so that $Auth$ may transition from true to false for a given $(s,o,p)$. The kernel implements path-based opens that may traverse symbolic links.\n\nConsider a process with credentials $S$ calling open on a path that resolves through one or more symbolic links to a final file object with inode identity $I_f$. Let the time of access check be $t_c$, the time of capability acquisition (e.g., creation of a file descriptor) be $t_u$, and the time of a concurrent revocation event be $t_r$. A Time Of Check To Time Of Use (TOCTOU) vulnerability exists if an attacker can cause $t_c < t_r < t_u$ so that the decision made at $t_c$ is no longer valid at $t_u$ but the kernel still grants access.\n\nThe kernel designers want a deterministic order of operations and synchronization rule for open that ensures the following property: if $t_r < t_u$ for privilege $p$ on $I_f$, and the call has not yet acquired a capability for $I_f$, then the open must be denied; in particular, revocation must take effect before use, even when the path contains symbolic links and intermediate directories may be concurrently modified.\n\nAssume the kernel supports the following primitives that can be composed in different orders:\n- Component-wise path resolution that follows symbolic links to a final inode $I_f$, while acquiring per-directory read locks sufficient to prevent a resolved component from being removed during the walk.\n- An exclusive metadata lock on a final inode $I_f$ that is also taken by any policy revocation that affects $I_f$ or by any credential-role update that impacts access to $I_f$.\n- A per-object generation counter $g(o)$ that is incremented on every revocation that would change $Auth(\\cdot,o,\\cdot)$ for any subject and privilege, and is readable under the inode metadata lock.\n- Creation of a file descriptor for $I_f$ as the capability to use $I_f$, which occurs only when the kernel returns to user space; creation is considered the use at time $t_u$.\n\nWhich of the following orders of operations and synchronization rules correctly eliminate the TOCTOU window for revocation with respect to open, while still allowing symbolic link traversal?\n\nA. Compute $Auth(S,\\text{path string},p)$ once at the beginning based on the user-supplied string without resolving symbolic links, cache the result for the duration of the system call, then resolve the path to $I_f$ and immediately create a file descriptor without further checks. Revocation updates invalidate the cache only for exact path string matches.\n\nB. Resolve the path through all components and symbolic links to obtain $I_f$ without taking any locks. Immediately create a file descriptor for $I_f$ to ensure the handle is stable, then check $Auth(S,I_f,p)$; if the check fails, close the file descriptor and return an error. Revocations proceed without synchronizing with open.\n\nC. For each path component, take and release the directory lock around resolution and check $Auth(S,\\text{component},\\text{lookup})$ to ensure lookup permission. After finishing resolution and following symbolic links, open $I_f$ without any additional policy check, because all components have already been checked. Revocations that occur after intermediate checks do not affect the final open.\n\nD. Resolve the path component-by-component while following symbolic links to an $I_f$, holding only directory read locks sufficient to keep the walk stable. Upon reaching $I_f$, take the exclusive metadata lock on $I_f$, read $g(I_f)$, and evaluate $Auth(S,I_f,p)$ under that lock using the subject’s current credentials at time $t_c$. If and only if $Auth$ is true, atomically create the file descriptor for $I_f$ and return it, then release the lock; otherwise, return an error. Any revocation that would change $Auth(\\cdot,I_f,\\cdot)$ must first acquire the same metadata lock on $I_f$, increment $g(I_f)$, update policy state, and only then release the lock. The open operation must re-evaluate $Auth$ if $g(I_f)$ changed before capability creation, ensuring that if $t_r < t_u$ then the open fails.", "solution": "We begin from first principles in operating systems access control and race freedom. The operating system enforces a policy decision function $Auth(s,o,p)$ for Discretionary Access Control (DAC), Mandatory Access Control (MAC), and Role-Based Access Control (RBAC). A revocation is a policy state change that can flip $Auth$ from true to false. The fundamental safety property we want is that capability acquisition (e.g., creation of a file descriptor) must not be based on a stale authorization decision. Formally, if the authorization is checked at $t_c$, the capability is acquired at $t_u$, and a revocation occurs at $t_r$ such that $t_c < t_r < t_u$, then a naive design has a Time Of Check To Time Of Use (TOCTOU) window. Eliminating this window requires that either $t_c$ and $t_u$ are made to coincide within a critical section that excludes revocation, or that the check is performed strictly after revocation effects are visible to the check, i.e., ensure $t_c > t_r$ whenever $t_r < t_u$.\n\nSymbolic link traversal introduces an additional name indirection: the path resolves to a final inode identity $I_f$ only after following links. The core correctness requirement is to authorize on the final object $I_f$ with the subject’s current credentials and to ensure that there is no interleaving where a revocation that affects $I_f$ can slip between check and use. From the concurrency perspective, the needed mechanism is a critical section on $I_f$ that is shared between open and revocation, so that either revocation happens first and is seen by open, causing denial, or open happens first and proceeds consistently.\n\nWe analyze each option relative to these principles.\n\nOption A: This option attempts to authorize on the path string before resolving symbolic links and then uses the cached decision after resolution. This violates the core definition that $Auth$ applies to the object $o$, here the final inode $I_f$, not the unexpanded path string. Authorizing on the string is unsound because a symbolic link can redirect to any target; the mapping from string to $I_f$ is not injective nor stable across concurrent modifications. Moreover, caching by path string cannot capture revocations that target $I_f$ unless the cache is invalidated for all strings that may resolve to $I_f$, which is generally untrackable. In TOCTOU terms, $t_c$ here occurs before resolution, and an attacker can change a link so that $I_f$ differs, or a revocation can occur after $t_c$; since no recheck occurs at $t_u$, $t_c < t_r < t_u$ remains possible. Verdict: Incorrect.\n\nOption B: This option creates the file descriptor first, then checks authorization, and closes the descriptor if the check fails. The design implies that capability creation (the use at $t_u$) precedes authorization at $t_c$, i.e., $t_u < t_c$, which inverts the required order and necessarily violates the safety property: a file descriptor is a capability to use the file, and creating it is the very action whose safety must be guarded by $Auth$. Even if the kernel never exposes the descriptor to user space until after the check, the stated order “immediately create a file descriptor, then check” creates an internal capability before synchronization with revocation, and revocations “proceed without synchronizing with open,” leaving a TOCTOU window where $t_r$ can occur between internal use and check. The lack of synchronization with revocation also means that $t_c$ and $t_u$ are not in a critical section that excludes revocation, so $t_c < t_r < t_u$ remains possible. Verdict: Incorrect.\n\nOption C: This option performs per-component lookup checks and then omits a final authorization on $I_f$. The fundamental base in DAC/MAC/RBAC is that authorization to look up names in directories (often modeled as a distinct privilege such as “search” or “execute” on directories) is not equivalent to authorization to read or write the target file. Revocation that targets the final object $I_f$ can occur after intermediate component checks, and because there is no final check under synchronization, $t_c$ for $I_f$ effectively does not exist and $t_u$ can proceed even if $t_r$ precedes it. Moreover, symbolic link traversal can redirect to a different $I_f$ even if intermediate components were authorized, so omitting a final object check is unsound. Verdict: Incorrect.\n\nOption D: This option resolves the path to the final inode identity $I_f$ while maintaining a stable walk using per-directory read locks but defers authorization until $I_f$ is reached. Crucially, it then takes an exclusive metadata lock on $I_f$ and evaluates $Auth(S,I_f,p)$ under that lock, using current credentials. Revocation acquires the same lock, updates policy state, and increments a generation counter $g(I_f)$, thereby serializing any change that would affect $Auth$. Because the open holds the lock across both check and capability creation, we have $t_c \\leq t_u$ within one critical section that excludes revocation. If a revocation occurs with $t_r < t_u$, it must either have acquired the lock before the open, in which case the open’s $t_c$ observes the updated state and denies, or it must occur after the open releases the lock, in which case $t_r > t_u$ and the specific open is allowed as a consistent action prior to revocation. The per-object generation counter $g(I_f)$ ensures that if any state relevant to $Auth$ changes while the open is pending but before capability creation, the open re-evaluates or fails, preventing $t_c < t_r < t_u$. This ordering authorizes on the correct object $I_f$ after symbolic link traversal and ensures deterministic serialization with revocation. Verdict: Correct.\n\nTherefore, the only option that provides a deterministic, revocation-safe order of operations for path-based opens with symbolic links is Option D. It aligns with the principle that to eliminate TOCTOU, the check and the use must be in the same critical section that also serializes with revocation, and it authorizes on the final object identity after resolution, as required by DAC, MAC, and RBAC semantics.", "answer": "$$\\boxed{D}$$", "id": "3619192"}]}