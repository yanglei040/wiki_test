{"hands_on_practices": [{"introduction": "Byzantine fault tolerance often involves designing algorithms that are resilient to faulty data inputs. This practice challenges you to analyze a common technique for achieving this resilience: the trimmed mean. By exploring a hypothetical OS fan controller that relies on multiple temperature sensors, some of which may be malicious, you will derive the worst-case error bound and understand how simple statistical filtering can provide strong guarantees against arbitrary faults. [@problem_id:3625176]", "problem": "An Operating System (OS) fan controller uses multiple on-board thermal sensors to estimate the Central Processing Unit (CPU) temperature and set the fan speed. The system must tolerate Byzantine Fault Tolerance (BFT), where up to $f$ sensors may act arbitrarily (maliciously), and the remaining $n-f$ sensors are honest. Let the true CPU temperature be $T \\in \\mathbb{R}$. Honest sensor $i$ reports $x_{i} = T + \\varepsilon_{i}$ with $|\\varepsilon_{i}| \\leq \\delta$ for a known bound $\\delta > 0$. Malicious sensors may report any real numbers without constraint.\n\nTo aggregate the $n$ readings, the OS uses the $f$-trimmed mean estimator: sort the $n$ reported values to obtain the order statistics $x_{(1)} \\leq x_{(2)} \\leq \\cdots \\leq x_{(n)}$, discard the lowest $f$ and highest $f$ values, and compute\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} x_{(i)} \\, ,\n$$\nassuming $n \\geq 2f + 1$ so that the estimator is well-defined.\n\nAdversaries seek to maximize the estimation error subject to the above constraints. Derive the tight worst-case upper bound on the absolute error\n$$\nE = \\sup \\, \\big| \\hat{T} - T \\big| \\, ,\n$$\nover all possible assignments of malicious values and all honest noise realizations satisfying $|\\varepsilon_{i}| \\leq \\delta$. Express your final bound as a closed-form function of $n$, $f$, and $\\delta$. You must express the bound in degrees Celsius. No numerical rounding is required.", "solution": "The problem asks for the tight worst-case upper bound on the absolute estimation error, $E = \\sup \\, \\big| \\hat{T} - T \\big|$, where $\\hat{T}$ is the $f$-trimmed mean estimator for the true temperature $T$. The estimator is given by\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} x_{(i)}\n$$\nThe system consists of $n$ sensors, of which up to $f$ can be malicious (Byzantine) and report arbitrary values. The remaining $n-f$ sensors are honest, reporting values $x_i = T + \\varepsilon_i$ where the noise $\\varepsilon_i$ is bounded by $|\\varepsilon_i| \\leq \\delta$. The analysis is subject to the condition $n \\geq 2f + 1$.\n\nThe absolute error is $|\\hat{T} - T|$. To find its supremum, we can analyze the maximum and minimum possible values of the deviation $\\hat{T} - T$. Due to the symmetric nature of the problem (malicious sensors can report arbitrarily high or low values, and the honest error bound $|\\varepsilon_i| \\le \\delta$ is symmetric around $0$), the maximum positive error $\\sup(\\hat{T}-T)$ will have the same magnitude as the maximum negative error $\\sup(T-\\hat{T})$. We will focus on finding the maximum possible value of $\\hat{T}$.\n\nLet us analyze the range of values that can appear in the sum of the estimator. The sum is over the order statistics $x_{(i)}$ for $i$ from $f+1$ to $n-f$. We will demonstrate that any such value $x_{(i)}$ must lie within the range $[T-\\delta, T+\\delta]$, regardless of the values reported by the malicious sensors.\n\nFirst, let's establish an upper bound for any value $x_{(i)}$ in the averaging window. The largest value included in the average is $x_{(n-f)}$. Consider the set of the largest $f+1$ reported values: $\\{x_{(n-f)}, x_{(n-f+1)}, \\dots, x_{(n)}\\}$. All values in this set are, by definition of order statistics, greater than or equal to $x_{(n-f)}$. This set contains $f+1$ sensor readings. Since there are only $f$ malicious sensors, at least one of these $f+1$ readings must come from an honest sensor. Let this honest reading be $x_{h}$. For this honest reading, we know $x_{h} = T + \\varepsilon_{h}$ and $\\varepsilon_{h} \\leq \\delta$, so $x_{h} \\leq T + \\delta$.\nSince $x_{h}$ is in the set $\\{x_{(n-f)}, \\dots, x_{(n)}\\}$, we have $x_{h} \\geq x_{(n-f)}$.\nCombining these inequalities yields $x_{(n-f)} \\leq x_{h} \\leq T + \\delta$.\nSince $x_{(n-f)}$ is the largest value in the averaging window, it follows that for any $i \\in \\{f+1, \\dots, n-f\\}$, we have $x_{(i)} \\leq x_{(n-f)} \\leq T + \\delta$.\n\nSecond, let's establish a lower bound using a symmetric argument. The smallest value included in the average is $x_{(f+1)}$. Consider the set of the smallest $f+1$ reported values: $\\{x_{(1)}, x_{(2)}, \\dots, x_{(f+1)}\\}$. All values in this set are less than or equal to $x_{(f+1)}$. This set also contains $f+1$ sensor readings. By the pigeonhole principle, at least one of these readings must originate from an honest sensor. Let this honest reading be $x_{h'}$. For this reading, $x_{h'} = T + \\varepsilon_{h'}$ and $\\varepsilon_{h'} \\geq -\\delta$, so $x_{h'} \\geq T - \\delta$.\nSince $x_{h'}$ is in the set $\\{x_{(1)}, \\dots, x_{(f+1)}\\}$, we have $x_{h'} \\leq x_{(f+1)}$.\nCombining these gives $x_{(f+1)} \\geq x_{h'} \\geq T - \\delta$.\nSince $x_{(f+1)}$ is the smallest value in the averaging window, it follows that for any $i \\in \\{f+1, \\dots, n-f\\}$, we have $x_{(i)} \\geq x_{(f+1)} \\geq T - \\delta$.\n\nWe have proven that for any index $i$ in the summation range, $f+1 \\leq i \\leq n-f$, the corresponding order statistic $x_{(i)}$ is bounded by\n$$\nT - \\delta \\leq x_{(i)} \\leq T + \\delta\n$$\nThis holds for any possible set of malicious values and any valid realization of honest sensor noise.\n\nNow, we can bound the estimator $\\hat{T}$. Using the upper bound for each term in the sum:\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} x_{(i)} \\leq \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} (T + \\delta)\n$$\nThe number of terms in the sum is $(n-f) - (f+1) + 1 = n-2f$.\n$$\n\\hat{T} \\leq \\frac{1}{n - 2f} (n - 2f)(T + \\delta) = T + \\delta\n$$\nSimilarly, using the lower bound for each term:\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} x_{(i)} \\geq \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} (T - \\delta) = T - \\delta\n$$\nCombining these results, we find that the estimate $\\hat{T}$ is always contained in the interval $[T - \\delta, T + \\delta]$. This implies that the absolute error is bounded by:\n$$\n|\\hat{T} - T| \\leq \\delta\n$$\nThis shows that $\\sup \\, |\\hat{T}-T| \\le \\delta$.\n\nTo prove that this bound is tight, we must construct a worst-case scenario where the error is exactly $\\delta$. The adversary's goal is to maximize the error, which involves choosing the $f$ malicious values and is maximized over all possible honest noise realizations $|\\varepsilon_i| \\le \\delta$. To maximize $\\hat{T}-T$, the adversary can employ the following strategy:\n1.  Set the noise for all $n-f$ honest sensors to their maximum possible value, $\\varepsilon_i = +\\delta$. This makes all honest sensors report the value $T+\\delta$.\n2.  Set the values for all $f$ malicious sensors to be some value smaller than any honest reading, for instance, by reporting a very large negative number (or any value less than $T+\\delta$). A simple choice is to have them report $T-\\delta$.\n\nThe collection of $n$ sensor readings is then $\\{T-\\delta, \\dots, T-\\delta\\}$ ($f$ times) and $\\{T+\\delta, \\dots, T+\\delta\\}$ ($n-f$ times). The sorted list of readings, $x_{(1)} \\leq x_{(2)} \\leq \\cdots \\leq x_{(n)}$, will be:\n$$\nx_{(1)} = \\cdots = x_{(f)} = T - \\delta\n$$\n$$\nx_{(f+1)} = \\cdots = x_{(n)} = T + \\delta\n$$\nThe estimator $\\hat{T}$ averages the values from $x_{(f+1)}$ to $x_{(n-f)}$. In this scenario, all of these values are equal to $T+\\delta$.\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} (T + \\delta) = \\frac{1}{n - 2f} (n-2f)(T+\\delta) = T + \\delta\n$$\nFor this case, the estimation error is $\\hat{T} - T = (T+\\delta) - T = \\delta$.\nBy a symmetric argument (setting honest noise to $-\\delta$ and malicious values to a very large positive number), an error of $-\\delta$ can be achieved.\n\nSince the absolute error $|\\hat{T} - T|$ is always less than or equal to $\\delta$, and we have demonstrated a scenario where it is exactly equal to $\\delta$, the tight worst-case upper bound (supremum) on the absolute error is $\\delta$. The problem states the bound should be expressed in degrees Celsius, which is the unit of $\\delta$.", "answer": "$$\\boxed{\\delta}$$", "id": "3625176"}, {"introduction": "A fundamental challenge in distributed systems is achieving agreement among multiple nodes, especially when some may be Byzantine. This exercise takes you to the heart of BFT by tasking you with deriving the minimal quorum size required for safe agreement from first principles. You will then translate this mathematical foundation into a simulation that decides whether a distributed checkpoint service can safely agree on a single memory digest. [@problem_id:3625121]", "problem": "You are given a scenario motivated by operating system hibernation: before entering a low-power state, a distributed checkpoint service must agree on a single memory image digest to persist. The system is replicated across multiple nodes and must tolerate Byzantine faults. The agreement is performed on signed memory image digests, denoted by $h$, one per proposed image. Your task is to write a program that simulates whether safe agreement is achievable and, if so, which digest is selected, based on a set-theoretic derivation of a quorum rule under Byzantine faults.\n\nUse the following fundamental base, stated in purely logical and mathematical terms:\n\n- Byzantine Fault Tolerance (BFT) means up to $f$ nodes can behave arbitrarily. The system has $n$ total nodes. Correct nodes follow protocol rules, including signing at most one digest for a given decision round.\n- The acceptance rule requires a quorum of signatures on a single digest. A signature is considered valid if it is syntactically correct and attached to the target digest $h$; otherwise it is invalid. For the purpose of this simulation, validity is a boolean predicate provided in the test cases for each signature.\n- A quorum size, denoted by $t$, must be chosen to guarantee safety and liveness under the following constraints:\n  1. Safety: No two distinct digests $h_a \\neq h_b$ can both be simultaneously accepted by correct nodes. Equivalently, any two quorums for different digests must intersect in at least one correct node, since correct nodes sign at most one digest per round.\n  2. Liveness: If at most $f$ nodes are Byzantine, correct nodes can form a quorum that accepts a digest whenever sufficiently many correct signatures exist.\n- Set-theoretic foundation: For a universe of $n$ nodes, any two subsets of size $t$ have an intersection of size at least $2t - n$. Since at most $f$ nodes can be Byzantine, guaranteeing that the intersection includes at least one correct node requires the intersection’s size to exceed $f$.\n\nYour program must:\n1. Derive the minimal integer quorum size $t$ from $n$ and $f$ using the above constraints and set-theoretic facts, without relying on any pre-given shortcut formulas.\n2. Validate signatures, count only valid and distinct signers per digest, and enforce that each correct node signs at most one digest in the round.\n3. Determine if a unique digest is safely acceptable. A digest $h$ is acceptable if it gathers at least $t$ valid signatures, and no other digest simultaneously does so; if more than one digest meets or exceeds $t$, or if a correct node signs more than one digest, or if the configuration is not viable for Byzantine Fault Tolerance, then no safe agreement can be made.\n4. Produce the final answer as a single line containing a comma-separated list of integers in square brackets, one per test case, where each integer is the accepted digest identifier $h$ if agreement is safely achievable, or $-1$ if no safe agreement can be made.\n\nViability check: A classical sufficient viability condition for Byzantine Fault Tolerance is $n \\geq 3f + 1$. If this condition does not hold for a test case, the program must return $-1$ for that case.\n\nTest suite specification (all identifiers and counts are integers, and all sets are finite; for every mathematical entity, numbers are wrapped in LaTeX):\n- Test Case $1$ (happy path):\n  - $n = 7$, $f = 2$, correct nodes $\\{0,1,2,3,4\\}$.\n  - Digests:\n    - $h = 101$ with valid signers $\\{0,1,2,3,4,5\\}$, all valid.\n    - $h = 202$ with signers $\\{5,6\\}$ where node $5$ is valid and node $6$ is invalid.\n  - Expected behavior: only $h = 101$ reaches the quorum; accept $101$.\n- Test Case $2$ (boundary viability):\n  - $n = 4$, $f = 1$, correct nodes $\\{0,1,2\\}$.\n  - Digests:\n    - $h = 303$ with valid signers $\\{0,1,2\\}$, all valid.\n  - Expected behavior: accept $303$.\n- Test Case $3$ (correct-node double-signing invalidates safety):\n  - $n = 7$, $f = 2$, correct nodes $\\{0,1,2,3,4\\}$.\n  - Digests:\n    - $h = 404$ with valid signers $\\{0,1,2,3,5\\}$, all valid.\n    - $h = 505$ with valid signers $\\{0,1,2,4,6\\}$, all valid.\n  - Expected behavior: correct nodes $0,1,2$ sign two digests; reject agreement and return $-1$.\n- Test Case $4$ (non-viable configuration):\n  - $n = 6$, $f = 2$, correct nodes $\\{0,1,2,3\\}$.\n  - Digests:\n    - $h = 606$ with valid signers $\\{0,1,2,3,4\\}$, all valid.\n  - Expected behavior: since $n  3f + 1$ (i.e., $6  7$), return $-1$.\n- Test Case $5$ (insufficient signatures):\n  - $n = 7$, $f = 2$, correct nodes $\\{0,1,2,3,4\\}$.\n  - Digests:\n    - $h = 707$ with signers $\\{0,1,2,3\\}$, where nodes $0,1,2$ are valid and node $3$ is invalid, leaving only $3$ valid signatures.\n  - Expected behavior: no digest reaches the quorum; return $-1$.\n- Test Case $6$ (Byzantine equivocation but unique quorum):\n  - $n = 10$, $f = 3$, correct nodes $\\{0,1,2,3,4,5,6\\}$.\n  - Digests:\n    - $h = 808$ with valid signers $\\{0,1,2,3,4,5,7\\}$, all valid.\n    - $h = 909$ with valid signers $\\{7,8,9,6\\}$, all valid.\n    - $h = 1000$ with valid signers $\\{8,9\\}$, all valid.\n  - Expected behavior: only $h = 808$ meets the quorum; accept $808$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$). For the above test suite, the program must output the accepted digest identifiers or $-1$ per case, in order.", "solution": "The problem requires the design of a simulation to determine if a safe agreement on a memory digest can be reached in a distributed system subject to Byzantine faults. The solution is derived from first principles of Byzantine Fault Tolerance (BFT), specifically focusing on the set-theoretic properties of quorums.\n\nThe process of determining the outcome for each test case is predicated on a sequence of validation steps and calculations, grounded in established BFT theory.\n\n**Step 1: System Viability Condition**\n\nThe system is described by a total of $n$ nodes, of which up to $f$ may be Byzantine. A widely established sufficient condition for a system to be able to solve consensus in the presence of $f$ Byzantine faults is that the total number of nodes $n$ must be at least $3f + 1$. This is expressed by the inequality:\n$$ n \\ge 3f + 1 $$\nThis condition ensures that after $f$ nodes are revealed to be faulty, the remaining $n-f$ correct nodes are numerous enough ($n-f \\ge 2f+1$) to outvote the faulty nodes, which could lie and create two opposing factions of size $f$. The problem states that if this viability condition is not met for a given test case, no safe agreement can be made, and the outcome must be $-1$.\n\n**Step 2: Derivation of the Minimal Quorum Size ($t$)**\n\nThe core of BFT safety revolves around ensuring that two conflicting proposals (e.g., for different digests $h_a$ and $h_b$) can never be simultaneously accepted by the system. Acceptance of a digest $h$ is defined as gathering a quorum of at least $t$ valid signatures from distinct nodes.\n\nLet $Q_a$ be the set of nodes that signed for digest $h_a$, and $Q_b$ be the set of nodes that signed for digest $h_b$. For both digests to be accepted, the size of these sets must meet the quorum threshold: $|Q_a| \\ge t$ and $|Q_b| \\ge t$. For our derivation, we consider the minimal case where $|Q_a| = t$ and $|Q_b| = t$.\n\nThe safety property mandates that it's impossible for two quorums on conflicting digests to be formed. A correct node, by definition, signs at most one digest per decision round. Therefore, if the intersection of any two potential quorums, $Q_a \\cap Q_b$, is guaranteed to contain at least one correct node, safety is upheld. If a correct node is in the intersection, it would be asked to sign for both $h_a$ and $h_b$. It would sign one but refuse the other, preventing one of the quorums from forming.\n\nThe worst-case scenario for safety is that the intersection $Q_a \\cap Q_b$ consists entirely of Byzantine nodes. There are at most $f$ Byzantine nodes in the system. To guarantee that the intersection contains at least one correct node, its size must be strictly greater than $f$.\n$$|Q_a \\cap Q_b| > f$$\nFrom set theory, the size of the intersection of two sets is bounded by the inclusion-exclusion principle. For a universe of $n$ nodes:\n$$|Q_a \\cap Q_b| \\ge |Q_a| + |Q_b| - n$$\nSubstituting $|Q_a| = t$ and $|Q_b| = t$, we get:\n$$|Q_a \\cap Q_b| \\ge 2t - n$$\nCombining the two inequalities to enforce the safety requirement yields:\n$$2t - n > f$$\nSolving for $t$, the quorum size:\n$$2t > n + f$$\n$$t > \\frac{n+f}{2}$$\nSince $t$ must be an integer (representing a count of nodes), the minimal integer value for $t$ that satisfies this strict inequality is obtained by taking the floor of the right-hand side and adding $1$.\n$$t = \\left\\lfloor \\frac{n+f}{2} \\right\\rfloor + 1$$\nThis formula provides the minimum number of signatures required to safely accept a digest.\n\n**Step 3: Algorithmic Procedure for Agreement**\n\nBased on the principles above, a deterministic algorithm can be formulated to evaluate each test case.\n\n1.  **Viability Check**: For the given parameters $n$ and $f$, first verify if $n \\ge 3f + 1$. If this condition is false, the system is not viable. The procedure terminates for this case, and the result is $-1$.\n\n2.  **Quorum Calculation**: If the system is viable, calculate the minimal integer quorum size $t$ using the derived formula: $t = \\lfloor \\frac{n+f}{2} \\rfloor + 1$.\n\n3.  **Signature Validation and Correctness Check**:\n    a. Initialize data structures to track the number of valid signatures for each proposed digest and to monitor the signing activity of correct nodes.\n    b. For each digest, iterate through its list of signers. A signature is counted only if it is marked as valid.\n    c. Simultaneously, check for protocol violations by correct nodes. A correct node must sign at most one digest. If a node identified as correct is found to have provided valid signatures for two or more distinct digests, this constitutes a critical safety failure. The procedure terminates for this case, and the result is $-1$. Byzantine nodes are, by definition, allowed to equivocate (sign multiple digests).\n\n4.  **Determine Final Outcome**:\n    a. After processing all signatures and confirming no correct node has double-signed, determine which digests, if any, have met the quorum threshold $t$.\n    b. Let $S$ be the set of digests that have accumulated at least $t$ valid signatures.\n    c. If the size of this set is exactly one, $|S| = 1$, then a unique, safe agreement has been reached. The result is the identifier $h$ of the single digest in $S$.\n    d. If the size of the set is zero, $|S| = 0$, no digest gathered sufficient support.\n    e. If the size of the set is greater than one, $|S| > 1$, two or more digests have met the quorum threshold, resulting in an ambiguity that violates safety.\n    f. In both cases where $|S| \\neq 1$, no safe agreement is possible, and the result is $-1$.\n\nThis structured procedure ensures that all conditions for Byzantine fault-tolerant agreement, as specified in the problem, are rigorously checked, leading to a definitive conclusion for each scenario.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n// The maximum number of nodes across all test cases, used for array sizing.\n#define MAX_NODES 16\n\n// A struct to hold information about a single digest proposal.\ntypedef struct {\n    int id;\n    const int* signers;\n    const int* valid_flags;\n    int num_signers;\n} Digest;\n\n// A struct to hold all parameters for a single test case.\ntypedef struct {\n    int n;\n    int f;\n    const int* correct_nodes;\n    int num_correct;\n    const Digest* digests;\n    int num_digests;\n} TestCase;\n\n// Function to solve a single test case.\nint solve_case(const TestCase* tc) {\n    // Step 1: Viability Check\n    if (tc-n  3 * tc-f + 1) {\n        return -1;\n    }\n\n    // Step 2: Calculate Quorum Size\n    int t = (tc-n + tc-f) / 2 + 1;\n\n    // Data structures for validation\n    int is_correct[MAX_NODES] = {0};\n    for (int i = 0; i  tc-num_correct; ++i) {\n        is_correct[tc-correct_nodes[i]] = 1;\n    }\n\n    int digest_counts[tc-num_digests];\n    for(int i = 0; i  tc-num_digests; ++i) {\n        digest_counts[i] = 0;\n    }\n\n    int node_signed_digest[MAX_NODES] = {0}; // Stores which digest_id a node signed (0 if none)\n    int double_sign_error = 0;\n\n    // Step 3: Signature Validation and Correctness Check\n    for (int i = 0; i  tc-num_digests; ++i) {\n        const Digest* d = tc-digests[i];\n        for (int j = 0; j  d-num_signers; ++j) {\n            if (d-valid_flags[j]) {\n                digest_counts[i]++;\n                int signer_id = d-signers[j];\n                if (signer_id  MAX_NODES  is_correct[signer_id]) {\n                    if (node_signed_digest[signer_id] != 0  node_signed_digest[signer_id] != d-id) {\n                        double_sign_error = 1;\n                    }\n                    node_signed_digest[signer_id] = d-id;\n                }\n            }\n        }\n    }\n\n    if (double_sign_error) {\n        return -1;\n    }\n\n    // Step 4: Determine Final Outcome\n    int accepted_digest_id = -1;\n    int num_accepted = 0;\n    for (int i = 0; i  tc-num_digests; ++i) {\n        if (digest_counts[i] = t) {\n            num_accepted++;\n            accepted_digest_id = tc-digests[i].id;\n        }\n    }\n\n    if (num_accepted == 1) {\n        return accepted_digest_id;\n    }\n\n    return -1;\n}\n\nint main(void) {\n    // --- Test Case 1 Data ---\n    int tc1_correct_nodes[] = {0, 1, 2, 3, 4};\n    int tc1_d1_signers[] = {0, 1, 2, 3, 4, 5};\n    int tc1_d1_valid[] = {1, 1, 1, 1, 1, 1};\n    int tc1_d2_signers[] = {5, 6};\n    int tc1_d2_valid[] = {1, 0};\n    Digest tc1_digests[] = {\n        {101, tc1_d1_signers, tc1_d1_valid, 6},\n        {202, tc1_d2_signers, tc1_d2_valid, 2}\n    };\n\n    // --- Test Case 2 Data ---\n    int tc2_correct_nodes[] = {0, 1, 2};\n    int tc2_d1_signers[] = {0, 1, 2};\n    int tc2_d1_valid[] = {1, 1, 1};\n    Digest tc2_digests[] = {\n        {303, tc2_d1_signers, tc2_d1_valid, 3}\n    };\n\n    // --- Test Case 3 Data ---\n    int tc3_correct_nodes[] = {0, 1, 2, 3, 4};\n    int tc3_d1_signers[] = {0, 1, 2, 3, 5};\n    int tc3_d1_valid[] = {1, 1, 1, 1, 1};\n    int tc3_d2_signers[] = {0, 1, 2, 4, 6};\n    int tc3_d2_valid[] = {1, 1, 1, 1, 1};\n    Digest tc3_digests[] = {\n        {404, tc3_d1_signers, tc3_d1_valid, 5},\n        {505, tc3_d2_signers, tc3_d2_valid, 5}\n    };\n\n    // --- Test Case 4 Data ---\n    int tc4_correct_nodes[] = {0, 1, 2, 3};\n    int tc4_d1_signers[] = {0, 1, 2, 3, 4};\n    int tc4_d1_valid[] = {1, 1, 1, 1, 1};\n    Digest tc4_digests[] = {\n        {606, tc4_d1_signers, tc4_d1_valid, 5}\n    };\n\n    // --- Test Case 5 Data ---\n    int tc5_correct_nodes[] = {0, 1, 2, 3, 4};\n    int tc5_d1_signers[] = {0, 1, 2, 3};\n    int tc5_d1_valid[] = {1, 1, 1, 0};\n    Digest tc5_digests[] = {\n        {707, tc5_d1_signers, tc5_d1_valid, 4}\n    };\n\n    // --- Test Case 6 Data ---\n    int tc6_correct_nodes[] = {0, 1, 2, 3, 4, 5, 6};\n    int tc6_d1_signers[] = {0, 1, 2, 3, 4, 5, 7};\n    int tc6_d1_valid[] = {1, 1, 1, 1, 1, 1, 1};\n    int tc6_d2_signers[] = {7, 8, 9, 6};\n    int tc6_d2_valid[] = {1, 1, 1, 1};\n    int tc6_d3_signers[] = {8, 9};\n    int tc6_d3_valid[] = {1, 1};\n    Digest tc6_digests[] = {\n        {808, tc6_d1_signers, tc6_d1_valid, 7},\n        {909, tc6_d2_signers, tc6_d2_valid, 4},\n        {1000, tc6_d3_signers, tc6_d3_valid, 2},\n    };\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {7, 2, tc1_correct_nodes, 5, tc1_digests, 2},\n        {4, 1, tc2_correct_nodes, 3, tc2_digests, 1},\n        {7, 2, tc3_correct_nodes, 5, tc3_digests, 2},\n        {6, 2, tc4_correct_nodes, 4, tc4_digests, 1},\n        {7, 2, tc5_correct_nodes, 5, tc5_digests, 1},\n        {10, 3, tc6_correct_nodes, 7, tc6_digests, 3},\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        results[i] = solve_case(test_cases[i]);\n    }\n\n    // Print the results in the EXACT REQUIRED format.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3625121"}, {"introduction": "Building on the principles of quorum-based agreement, this final practice applies BFT to a dynamic, real-world scenario: a distributed Process Identifier (PID) allocator. You will simulate how time-based leases, combined with BFT quorums, prevent the catastrophic failure of assigning the same PID to multiple processes, even when some replicas are malicious. This exercise demonstrates how BFT secures not just a single decision, but the ongoing integrity of a replicated state machine. [@problem_id:3625198]", "problem": "Consider a distributed operating system service that allocates Process Identifiers (PIDs) using a replicated state machine with nodes that may exhibit arbitrary failures (Byzantine faults). There are $n$ replicas, of which up to $f$ may be Byzantine. Each allocation decision must be accompanied by a lease that expires at absolute time $t_{\\mathrm{exp}}$, and every allocation is represented by a message $M = (\\mathrm{rid}, \\mathrm{pid}, t_{\\mathrm{exp}})$ where $\\mathrm{rid}$ is a unique request identifier and $\\mathrm{pid}$ is the requested Process Identifier. Each replica has a signing key and issues a digital signature over $M$ when it grants a lease. A client commits an allocation only when it holds a certificate consisting of $q$ distinct, verifiable signatures over the same $M$. Honest replicas never sign two different live leases for the same $\\mathrm{pid}$; leases signed by honest replicas become invalid at times $t \\ge t_{\\mathrm{exp}}$ and honest replicas refuse to sign a lease whose expiry is not in the future. Byzantine replicas, in contrast, may sign conflicting leases for different $\\mathrm{pid}$ values, withhold signatures, or sign malformed messages.\n\nFundamental base assumptions and definitions:\n- A Byzantine fault is an arbitrary deviation from specified behavior, including sending inconsistent or maliciously crafted messages.\n- A quorum certificate is a set of signatures over the same message $M$ from distinct replicas; a certificate is considered valid when it contains $q$ verifiable signatures.\n- The system parameters satisfy $n \\ge 3f + 1$ and $q$ is chosen to ensure that any two quorums of size $q$ intersect in at least $f+1$ honest replicas, so that two conflicting certificates cannot both be valid concurrently during any lease period.\n\nTask:\nImplement a self-contained program that simulates this replicated PID allocator and demonstrates how duplicate PID assignments are avoided under Byzantine behavior using quorum-based leases expiring at time $t$ and signed allocations. Your simulation must:\n1. Represent replicas with per-node keys and model signature generation and verification over messages $M = (\\mathrm{rid}, \\mathrm{pid}, t_{\\mathrm{exp}})$.\n2. Model honest replicas’ local state as a mapping from $\\mathrm{pid}$ to current lease expiry; an honest replica grants a lease for $(\\mathrm{pid}, t_{\\mathrm{exp}})$ if and only if $t_{\\mathrm{exp}}  t_{\\mathrm{now}}$ and either there is no existing lease for $\\mathrm{pid}$ or the existing lease has expired (i.e., its expiry time is $\\le t_{\\mathrm{now}}$).\n3. Model Byzantine behavior by allowing replicas to equivocate (e.g., signing a different $\\mathrm{pid}$ than requested) or withhold signatures.\n4. Determine the minimum quorum size $q$ that enforces the intersection property under the constraint $n \\ge 3f + 1$, and use that $q$ to decide commitment. A client commits $(\\mathrm{pid}, t_{\\mathrm{exp}})$ only if it collects a certificate of $q$ valid signatures over that $M$.\n5. Simulate requests at discrete time steps $t = 0, 1, 2, \\dots$; for each attempt, choose a candidate $\\mathrm{pid}$ and seek a quorum certificate. If an attempt cannot obtain a valid certificate for any candidate within a reasonable bounded search, count it as a failure. When a certificate is obtained, record $(\\mathrm{pid}, t_{\\mathrm{start}}, t_{\\mathrm{exp}})$ and treat it as an allocation decision.\n6. After all attempts in a test case, detect whether any duplicate PID assignments exist by checking if two committed allocations share the same $\\mathrm{pid}$ with overlapping lease intervals, i.e., if there exist two allocations $(\\mathrm{pid}, t^{(1)}_{\\mathrm{start}}, t^{(1)}_{\\mathrm{exp}})$ and $(\\mathrm{pid}, t^{(2)}_{\\mathrm{start}}, t^{(2)}_{\\mathrm{exp}})$ such that $t^{(2)}_{\\mathrm{start}}  t^{(1)}_{\\mathrm{exp}}$.\n\nAngle units do not apply; time is discrete and unitless integers.\n\nTest Suite:\nUse the following three test cases to exercise correctness, boundary conditions, and edge cases. In each, choose a minimal $\\mathrm{pid}$ that can be committed; if a chosen $\\mathrm{pid}$ cannot be committed due to insufficient valid signatures, search for the next candidate $\\mathrm{pid}$ until success or bounded exhaustion.\n\n- Test Case A (happy path with equivocation):\n  - $n = 7$, $f = 2$, attempts $= 5$, lease duration (span) $= 3$ time units, byzantine mode: half of Byzantine replicas equivocate by signing a different $\\mathrm{pid}$ than requested, the rest sign the correct message. No forced reuse of a previously allocated $\\mathrm{pid}$.\n\n- Test Case B (boundary at lease expiry):\n  - $n = 4$, $f = 1$, attempts $= 3$, lease duration $= 2$ time units, byzantine mode: replicas sign the correct message when they choose to sign. Force reuse of the first allocated $\\mathrm{pid}$ exactly when its lease expires, i.e., on the third attempt ($t = 2$).\n\n- Test Case C (edge case with invalid leases):\n  - $n = 7$, $f = 2$, attempts $= 2$, lease duration $= 0$ time units, byzantine mode: replicas sign the correct message when they choose to sign. Honest replicas must refuse leases with $t_{\\mathrm{exp}} \\le t_{\\mathrm{now}}$, so commitments cannot reach quorum.\n\nAnswer specification:\nFor each test case, produce a triple $[\\text{successes}, \\text{failures}, \\text{duplicate\\_flag}]$ where $\\text{successes}$ is the integer count of committed allocations, $\\text{failures}$ is the integer count of attempts that did not commit, and $\\text{duplicate\\_flag}$ is $0$ if no overlapping duplicate PID assignments exist and $1$ otherwise.\n\nFinal output format:\nYour program should produce a single line of output containing the three test case results as a comma-separated list enclosed in square brackets, where each element is itself a comma-separated list of three integers. For example: $[[s_1,f_1,d_1],[s_2,f_2,d_2],[s_3,f_3,d_3]]$. No additional text should be printed.", "solution": "The user wants me to act as a meticulous STEM professor and solve a problem related to Byzantine Fault Tolerance in a distributed operating system.\n\nMy process will be:\n1.  **Validate the problem statement.**\n    *   Extract all given information verbatim.\n    *   Check for scientific soundness, well-posedness, objectivity, and other criteria.\n2.  **If valid, solve the problem.**\n    *   The problem asks me to implement a simulation of a replicated PID allocator.\n    *   I need to determine the minimum quorum size `q`.\n    *   I need to model replicas, signing keys, messages, and state.\n    *   I need to model honest and Byzantine behavior.\n    *   I need to simulate discrete time steps and allocation attempts.\n    *   I need to check for duplicate allocations after the simulation.\n    *   The final output should be a specific string format reporting the results for three test cases.\n3.  **If invalid, explain why and terminate.**\n\n### Step 1: Extract Givens\n\n*   **System Model**: Replicated state machine for PID allocation in a distributed OS.\n*   **Nodes**: $n$ replicas.\n*   **Faults**: Up to $f$ replicas may be Byzantine (exhibit arbitrary failures).\n*   **Allocation Message**: $M = (\\mathrm{rid}, \\mathrm{pid}, t_{\\mathrm{exp}})$.\n    *   `rid`: unique request identifier.\n    *   `pid`: requested Process Identifier.\n    *   $t_{\\mathrm{exp}}$: absolute time of lease expiry.\n*   **Signatures**: Each replica has a signing key and issues a digital signature over $M$ when granting a lease.\n*   **Certificate**: A set of $q$ distinct, verifiable signatures over the same $M$. A client commits an allocation upon holding such a certificate.\n*   **Honest Replica Behavior**:\n    *   Never sign two different live leases for the same `pid`.\n    *   A lease is live if current time $t  t_{\\mathrm{exp}}$.\n    *   Leases become invalid at times $t \\ge t_{\\mathrm{exp}}$.\n    *   Refuse to sign a lease whose expiry $t_{\\mathrm{exp}}$ is not in the future (i.e., $t_{\\mathrm{exp}}  t_{\\mathrm{now}}$).\n    *   An honest replica grants a lease for $(\\mathrm{pid}, t_{\\mathrm{exp}})$ if and only if $t_{\\mathrm{exp}}  t_{\\mathrm{now}}$ **and** ( (no existing lease for `pid`) **or** (existing lease has expired, i.e., its expiry time is $\\le t_{\\mathrm{now}}$) ).\n    *   Local state: a mapping from `pid` to current lease expiry time.\n*   **Byzantine Replica Behavior**:\n    *   May sign conflicting leases for different `pid` values.\n    *   May withhold signatures.\n    *   May sign malformed messages.\n    *   May equivocate (e.g., signing a different `pid` than requested).\n*   **System Constraints**:\n    *   $n \\ge 3f + 1$.\n    *   $q$ is chosen to ensure that any two quorums of size $q$ intersect in at least $f+1$ honest replicas.\n*   **Simulation Task**:\n    *   Represent replicas, keys, signatures.\n    *   Model honest and Byzantine behavior as described.\n    *   Determine the minimum quorum size $q$.\n    *   Simulate requests at discrete time steps $t = 0, 1, 2, \\dots$.\n    *   An attempt involves choosing a `pid` and seeking a quorum certificate.\n    *   If an attempt fails, it is counted as a failure.\n    *   If a certificate is obtained, record $(\\mathrm{pid}, t_{\\mathrm{start}}, t_{\\mathrm{exp}})$ as a committed allocation.\n    *   After simulation, check for duplicate PID assignments with overlapping lease intervals: two allocations $(\\mathrm{pid}, t^{(1)}_{\\mathrm{start}}, t^{(1)}_{\\mathrm{exp}})$ and $(\\mathrm{pid}, t^{(2)}_{\\mathrm{start}}, t^{(2)}_{\\mathrm{exp}})$ overlap if $t^{(2)}_{\\mathrm{start}}  t^{(1)}_{\\mathrm{exp}}$.\n*   **Test Cases**:\n    *   **Case A**: $n = 7, f = 2$, attempts $= 5$, lease duration $= 3$, Byzantine mode: half (1) equivocates, half (1) signs correctly.\n    *   **Case B**: $n = 4, f = 1$, attempts $= 3$, lease duration $= 2$, Byzantine mode: signs correctly. Force reuse of first allocated `pid` at $t=2$.\n    *   **Case C**: $n = 7, f = 2$, attempts $= 2$, lease duration $= 0$, Byzantine mode: signs correctly.\n*   **Answer Specification**: For each test case, output $[\\text{successes}, \\text{failures}, \\text{duplicate\\_flag}]$.\n*   **Final Output Format**: `[[s1,f1,d1],[s2,f2,d2],[s3,f3,d3]]`\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is evaluated against the validation criteria.\n\n1.  **Scientific or Factual Soundness**: The problem is well-grounded in the principles of distributed computing, specifically Byzantine Fault Tolerance (BFT) and state machine replication. The use of quorums to ensure safety (uniqueness of PID allocation) is a standard technique. The constraint $n \\ge 3f + 1$ is the well-known requirement for asynchronous BFT consensus protocols. The model, though simplified, is scientifically and logically coherent.\n2.  **Non-Formalizable or Irrelevant**: The problem is formal and directly relevant to the specified topic. The rules for replica behavior, message structure, and commitment are precise and can be translated into an algorithm.\n3.  **Incomplete or Contradictory Setup**: The problem is largely self-contained. Minor ambiguities, such as the exact method for choosing which Byzantine nodes equivocate or the definition of \"bounded exhaustion\" in the PID search, are reasonable degrees of freedom in a simulation context and can be resolved with standard assumptions (e.g., designating specific nodes as malicious, using a fixed search bound). The phrase \"intersect in at least $f+1$ honest replicas\" is a slightly imprecise but understandable statement of the standard BFT quorum intersection property, which requires the intersection size to be at least $f+1$ to guarantee at least one honest member. This interpretation renders the problem well-defined.\n4.  **Unrealistic or Infeasible**: The problem describes a simulation with abstract \"signatures\" and discrete time, which are standard and valid simplifications for analyzing the logic of distributed algorithms. The numerical parameters are feasible.\n5.  **Ill-Posed or Poorly Structured**: With the standard interpretation of the quorum intersection property, the problem is well-posed and a unique, meaningful result can be determined for each test case.\n6.  **Pseudo-Profound, Trivial, or Tautological**: The problem is non-trivial, requiring the implementation of core BFT logic, state management, and specific simulation scenarios.\n7.  **Outside Scientific Verifiability**: The results of the simulation are verifiable by implementing the described logic and checking against theoretical predictions.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. The solution process will proceed.\n\n### Solution\n\nThe problem requires simulating a Byzantine fault-tolerant (BFT) system for allocating Process Identifiers (PIDs). The core of the solution lies in correctly implementing the quorum-based consensus mechanism that prevents duplicate allocations despite the presence of malicious (Byzantine) replicas.\n\n#### 1. Quorum Size Determination\n\nThe system has $n$ replicas, with up to $f$ being Byzantine. A client requires a certificate of $q$ signatures to commit an allocation. To guarantee safety (i.e., prevent two conflicting certificates from being formed for the same resource, such as a PID during a live lease), any two quorums must intersect. Furthermore, this intersection must contain at least one honest replica.\n\nLet $Q_1$ and $Q_2$ be two distinct quorums, each of size $q$. The minimum size of their intersection is given by the quorum intersection formula:\n$$ |Q_1 \\cap Q_2| \\ge |Q_1| + |Q_2| - n = 2q - n $$\nIn the worst-case scenario, all $f$ Byzantine replicas could be part of this intersection and vote for both conflicting operations. To ensure at least one honest replica is present in the intersection to break the tie, the intersection size must be strictly greater than $f$. The minimum integer size is thus $f+1$.\n$$ 2q - n \\ge f + 1 $$\nSolving for the minimum integer quorum size $q$:\n$$ 2q \\ge n + f + 1 $$\n$$ q \\ge \\frac{n + f + 1}{2} $$\nSince $q$ must be an integer, the minimum quorum size is:\n$$ q = \\left\\lfloor \\frac{n + f}{2} \\right\\rfloor + 1 $$\nThis is a standard result for BFT systems. For example, with the typical $n = 3f + 1$, we get $q = \\left\\lfloor \\frac{3f+1+f}{2} \\right\\rfloor + 1 = \\left\\lfloor \\frac{4f+1}{2} \\right\\rfloor + 1 = 2f + 1$. The intersection size is $2(2f+1) - (3f+1) = 4f+2 - 3f-1 = f+1$, as required.\n\nThis formula will be used to calculate $q$ for each test case.\n\n#### 2. Simulation Model\n\nThe simulation proceeds in discrete time steps, $t=0, 1, 2, \\dots$. Each step corresponds to one allocation attempt.\n\n*   **Replicas**: Each of the $n$ replicas is modeled with an ID, a flag indicating if it's Byzantine, and a local state. The state is a map from a `pid` to its lease expiry time, $t_{\\mathrm{exp}}$. We can use an array `pid_leases[]` for this, where the index is the `pid`.\n*   **Message and Signature**: A message $M$ is $(\\mathrm{rid}, \\mathrm{pid}, t_{\\mathrm{exp}})$. A cryptographic signature is simulated by a replica returning the exact message it \"signed\". A client verifies a \"signature\" by comparing the returned message with the one it requested.\n*   **Honest Replica Logic**: At time $t_{\\mathrm{now}}$, when requested to sign a lease for $(\\mathrm{pid}, t_{\\mathrm{exp}})$, an honest replica agrees if and only if both conditions are met:\n    1.  The lease is for the future: $t_{\\mathrm{exp}}  t_{\\mathrm{now}}$.\n    2.  The PID is available: There is no current lease for the `pid`, or the existing lease has expired (`pid_leases[pid] = t_now`).\n*   **Byzantine Replica Logic**: These replicas are not bound by the protocol. In this simulation, their behavior is determined by the test case: they may sign the correct message (cooperate) or sign a modified message (equivocate), but they do not check for lease validity.\n*   **Client Logic**: At each time step $t$, the client attempts to allocate a PID. It sequentially tries candidate PIDs (e.g., starting from $1$) until one is successfully committed or a search bound is hit.\n    1.  For a candidate `pid`, the client forms a message $M = (\\mathrm{rid}=t, \\mathrm{pid}, t_{\\mathrm{exp}}=t+\\text{duration})$.\n    2.  It broadcasts $M$ and collects signed messages from all $n$ replicas.\n    3.  It counts the number of valid signatures for $M$.\n    4.  If the count is at least $q$, the allocation is a **success**. The client records the allocation $(\\mathrm{pid}, t_{\\mathrm{start}}=t, t_{\\mathrm{exp}})$ and all honest replicas update their state to reflect the new lease.\n    5.  If no candidate `pid` achieves a quorum, the attempt is a **failure**.\n\n#### 3. Duplicate Detection\n\nAfter all simulation attempts are complete, the list of committed allocations is checked for duplicates. A duplicate exists if there are two allocations, $(\\mathrm{pid}_1, t^{(1)}_{\\mathrm{start}}, t^{(1)}_{\\mathrm{exp}})$ and $(\\mathrm{pid}_2, t^{(2)}_{\\mathrm{start}}, t^{(2)}_{\\mathrm{exp}})$, such that:\n$$ \\mathrm{pid}_1 = \\mathrm{pid}_2 \\quad \\text{and} \\quad (t^{(1)}_{\\mathrm{start}}  t^{(2)}_{\\mathrm{exp}}) \\quad \\text{and} \\quad (t^{(2)}_{\\mathrm{start}}  t^{(1)}_{\\mathrm{exp}}) $$\nThis corresponds to an overlap of the lease intervals $[\\,t_{\\mathrm{start}}, t_{\\mathrm{exp}})$.\n\n#### 4. Test Case Analysis\n\n*   **Test Case A**: $n=7, f=2$. This gives $q = \\lfloor (7+2)/2 \\rfloor + 1 = 5$. There are $5$ honest replicas and $2$ Byzantine replicas. One Byzantine replica equivocates (signs for `pid+1`), the other signs correctly. A client requesting a new `pid` will receive $5$ (honest) + $1$ (cooperative Byzantine) $= 6$ correct signatures. Since $6 \\ge q$, all attempts should succeed with new PIDs. Thus, we expect $[5, 0, 0]$.\n*   **Test Case B**: $n=4, f=1$. This gives $q = \\lfloor (4+1)/2 \\rfloor + 1 = 3$. There are $3$ honest replicas and $1$ cooperative Byzantine replica. At $t=0$, `pid=1` is allocated with a lease duration of $2$, so its lease is `[0, 2)`. At $t=1$, a new `pid=2` is allocated. At $t=2$, the forced reuse of `pid=1` is attempted. The old lease expires at $t=2$, so the condition `expiry_time = t_now` ($2 \\le 2$) is met. Honest replicas will grant a new lease for `pid=1`. All $3$ attempts succeed. The lease intervals for `pid=1` are $[0, 2)$ and $[2, 4)$, which do not overlap. Thus, we expect $[3, 0, 0]$.\n*   **Test Case C**: $n=7, f=2, q=5$. The lease duration is $0$. At any time $t$, the requested expiry is $t_{\\mathrm{exp}} = t+0 = t$. The condition for an honest replica to sign, $t_{\\mathrm{exp}}  t_{\\mathrm{now}}$, becomes $t  t$, which is always false. Honest replicas will never sign. The client can only collect signatures from the $2$ Byzantine replicas. Since $2  q$, no allocation can be committed. Both attempts will fail. Thus, we expect $[0, 2, 0]$.\n\nThe implementation will follow this logic to produce the final results.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// --- Configuration Constants ---\n#define MAX_REPLICAS 10\n#define MAX_PIDS 20\n#define PID_SEARCH_BOUND 10\n#define MAX_ALLOCATIONS 10\n\n// --- Data Structures ---\n\n// Represents a message M = (rid, pid, t_exp)\ntypedef struct {\n    int rid;\n    int pid;\n    int t_exp;\n} Message;\n\n// Enumeration for test-case-specific Byzantine behavior\ntypedef enum {\n    MODE_A_EQUIVOCATE,\n    MODE_B_C_COOPERATE\n} ByzantineMode;\n\n// Holds parameters for a single test case\ntypedef struct {\n    int n;\n    int f;\n    int attempts;\n    int lease_duration;\n    ByzantineMode byzantine_mode;\n} TestCase;\n\n// State of a single replica\ntypedef struct {\n    int id;\n    int is_byzantine;\n    int pid_leases[MAX_PIDS]; // index is pid, value is t_exp\n} Replica;\n\n// Represents a committed allocation\ntypedef struct {\n    int pid;\n    int t_start;\n    int t_exp;\n} Allocation;\n\n// --- Helper Functions ---\n\n// Compares two messages. Returns 1 if identical, 0 otherwise.\nint compare_messages(const Message* m1, const Message* m2) {\n    return (m1-rid == m2-rid  m1-pid == m2-pid  m1-t_exp == m2-t_exp);\n}\n\n// Checks if an honest replica can sign a message at a given time. Does not modify state.\nint honest_can_sign(const Replica* replica, const Message* msg, int t_now) {\n    if (msg-pid = 0 || msg-pid = MAX_PIDS) {\n        return 0; // Invalid PID\n    }\n    // Condition 1: Lease expiry must be in the future.\n    if (msg-t_exp = t_now) {\n        return 0;\n    }\n    // Condition 2: No conflicting live lease exists.\n    if (replica-pid_leases[msg-pid]  t_now) {\n        return 0;\n    }\n    return 1;\n}\n\n// Checks for duplicate allocations with overlapping lease intervals.\nint check_for_duplicates(const Allocation* allocations, int count) {\n    for (int i = 0; i  count; ++i) {\n        for (int j = i + 1; j  count; ++j) {\n            if (allocations[i].pid == allocations[j].pid) {\n                const Allocation* a1 = allocations[i];\n                const Allocation* a2 = allocations[j];\n                // Check for interval overlap for [start1, exp1) and [start2, exp2)\n                if (a1-t_start  a2-t_exp  a2-t_start  a1-t_exp) {\n                    return 1; // Duplicate with overlap found\n                }\n            }\n        }\n    }\n    return 0; // No duplicates\n}\n\n// --- Main Program ---\n\nint main(void) {\n    TestCase test_cases[] = {\n        {7, 2, 5, 3, MODE_A_EQUIVOCATE},\n        {4, 1, 3, 2, MODE_B_C_COOPERATE},\n        {7, 2, 2, 0, MODE_B_C_COOPERATE}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases][3];\n\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        int n = tc.n;\n        int f = tc.f;\n        int q = (n + f) / 2 + 1;\n\n        Replica replicas[MAX_REPLICAS];\n        for (int j = 0; j  n; ++j) {\n            replicas[j].id = j;\n            replicas[j].is_byzantine = (j = n - f);\n            memset(replicas[j].pid_leases, 0, sizeof(replicas[j].pid_leases));\n        }\n\n        Allocation committed_allocations[MAX_ALLOCATIONS];\n        int allocation_count = 0;\n        int successes = 0;\n        int failures = 0;\n\n        for (int t = 0; t  tc.attempts; ++t) {\n            int attempt_succeeded = 0;\n            int start_pid = 1;\n            \n            // For Test Case B, third attempt must reuse pid 1.\n            if (i == 1  t == 2) {\n                start_pid = 1;\n            }\n\n            for (int pid_candidate = start_pid; pid_candidate  start_pid + PID_SEARCH_BOUND; ++pid_candidate) {\n                Message request_msg = {t, pid_candidate, t + tc.lease_duration};\n\n                Message received_signatures[MAX_REPLICAS];\n                int signature_count = 0;\n                \n                // Collect \"signatures\" from all replicas.\n                for (int j = 0; j  n; ++j) {\n                    if (replicas[j].is_byzantine) {\n                        if (tc.byzantine_mode == MODE_A_EQUIVOCATE) {\n                            // As per test case, for f=2, one equivocates, one cooperates.\n                            // We model this by having the highest ID replica equivocate.\n                            if (replicas[j].id == n - 1) {\n                                Message byzantine_msg = request_msg;\n                                byzantine_msg.pid++;\n                                received_signatures[signature_count++] = byzantine_msg;\n                            } else {\n                                received_signatures[signature_count++] = request_msg;\n                            }\n                        } else { // MODE_B_C_COOPERATE\n                            received_signatures[signature_count++] = request_msg;\n                        }\n                    } else { // Honest Replica\n                        if (honest_can_sign(replicas[j], request_msg, t)) {\n                            received_signatures[signature_count++] = request_msg;\n                        }\n                    }\n                }\n\n                // Verify signatures and check for quorum.\n                int valid_signatures_for_request = 0;\n                for (int j = 0; j  signature_count; ++j) {\n                    if (compare_messages(received_signatures[j], request_msg)) {\n                        valid_signatures_for_request++;\n                    }\n                }\n\n                if (valid_signatures_for_request = q) {\n                    attempt_succeeded = 1;\n                    successes++;\n                    \n                    committed_allocations[allocation_count].pid = request_msg.pid;\n                    committed_allocations[allocation_count].t_start = t;\n                    committed_allocations[allocation_count].t_exp = request_msg.t_exp;\n                    allocation_count++;\n\n                    // Update states of all honest replicas.\n                    for (int j = 0; j  n; ++j) {\n                        if (!replicas[j].is_byzantine) {\n                            replicas[j].pid_leases[request_msg.pid] = request_msg.t_exp;\n                        }\n                    }\n                    break; // PID committed, end search for this time step.\n                }\n\n                // For Test Case B, only try pid=1 at t=2.\n                if (i == 1  t == 2) {\n                    break;\n                }\n            }\n\n            if (!attempt_succeeded) {\n                failures++;\n            }\n        }\n\n        results[i][0] = successes;\n        results[i][1] = failures;\n        results[i][2] = check_for_duplicates(committed_allocations, allocation_count);\n    }\n    \n    // Print the results in the exact required format.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"[%d,%d,%d]\", results[i][0], results[i][1], results[i][2]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3625198"}]}