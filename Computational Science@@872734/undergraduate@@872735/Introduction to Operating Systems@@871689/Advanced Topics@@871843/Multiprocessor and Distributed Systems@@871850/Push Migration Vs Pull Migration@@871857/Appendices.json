{"hands_on_practices": [{"introduction": "To truly understand system behavior, it's not enough to read definitions; you must learn to interpret real-world data. This first practice places you in the role of a performance analyst. By examining a time-series trace of CPU queue lengths, you will use correlation analysis to deduce whether the underlying scheduler is using push or pull migration, connecting abstract policy definitions to their observable signatures in system metrics [@problem_id:3674334].", "problem": "A symmetric two-core scheduler maintains per-core runnable queue lengths $q_1(t)$ and $q_2(t)$ sampled at discrete times $t \\in \\{0,1,2,3,4,5,6,7,8\\}$ with sampling interval $\\Delta t = 1$. Assume that exogenous arrivals are balanced across cores on average and that service quanta per core are approximately constant across samples. Two canonical migration policies are considered: push migration (an overloaded core proactively transfers tasks to other cores) and pull migration (an underloaded core proactively fetches tasks from other cores).\n\nYou are given a trace of queue lengths:\n- $q_1(t)$ for $t=0,1,\\dots,8$: $[\\,3,4,5,5,4,3,2,2,2\\,]$,\n- $q_2(t)$ for $t=0,1,\\dots,8$: $[\\,1,1,1,2,3,3,3,2,2\\,]$.\n\nLet the discrete-time derivative be defined by the forward difference $\\dot q_j(t) \\approx q_j(t)-q_j(t-1)$ for $t \\ge 1$. Consider the sample cross-correlation at lag $\\tau$, defined for two zero-mean sequences $x(t)$ and $y(t)$ over their common support as\n$$\n\\rho_{xy}(\\tau) \\;=\\; \\frac{\\sum_t \\big(x(t-\\tau)-\\bar x\\big)\\big(y(t)-\\bar y\\big)}{\\sqrt{\\sum_t \\big(x(t-\\tau)-\\bar x\\big)^2}\\,\\sqrt{\\sum_t \\big(y(t)-\\bar y\\big)^2}},\n$$\nwhere $\\bar x$ and $\\bar y$ are sample means. Interpret $\\tau>0$ as $x$ leading $y$.\n\nUsing the provided trace, form $\\dot q_2(t)$ for $t=1,\\dots,8$, and reason from the definitions of push migration and pull migration, together with the definition of cross-correlation, to decide which migration policy is more consistent with the data by analyzing the sign and lag of the prominent peak of $\\mathrm{corr}\\big(q_1,\\dot q_2\\big)$. Choose the single best option:\n\nA. The system uses push migration: $q_1$ leads $\\dot q_2$; $\\mathrm{corr}\\big(q_1,\\dot q_2\\big)$ has a strong positive peak at a small positive lag $\\tau>0$.\n\nB. The system uses pull migration: $q_2$ initiates transfers when underloaded; $\\mathrm{corr}\\big(q_1,\\dot q_2\\big)$ peaks at a negative lag $\\tau<0$ or is weak for $\\tau>0$.\n\nC. The system uses pull migration, yet $q_1$ still leads $\\dot q_2$ with a strong positive peak at $\\tau>0$.\n\nD. Neither policy can be inferred: $\\mathrm{corr}\\big(q_1,\\dot q_2\\big)$ is approximately zero for small $|\\tau|$.", "solution": "The user wants me to validate the problem statement and, if valid, provide a detailed solution.\n\n### Step 1: Problem Validation\n\nI will first extract the givens and then validate the problem statement based on scientific principles and well-posedness.\n\n**Extracted Givens:**\n*   **System:** A symmetric two-core scheduler.\n*   **Observables:** Per-core runnable queue lengths, $q_1(t)$ and $q_2(t)$.\n*   **Time Discretization:** The data is sampled at discrete times $t \\in \\{0, 1, 2, 3, 4, 5, 6, 7, 8\\}$ with a sampling interval of $\\Delta t = 1$.\n*   **Data Traces:**\n    *   $q_1(t): [\\,3, 4, 5, 5, 4, 3, 2, 2, 2\\,]$\n    *   $q_2(t): [\\,1, 1, 1, 2, 3, 3, 3, 2, 2\\,]$\n*   **System Assumptions:** Exogenous arrivals are balanced on average, and service quanta are approximately constant.\n*   **Migration Policies:**\n    *   **Push migration:** An overloaded core proactively transfers tasks to other cores.\n    *   **Pull migration:** An underloaded core proactively fetches tasks from other cores.\n*   **Mathematical Definitions:**\n    *   Discrete-time derivative: $\\dot q_j(t) \\approx q_j(t)-q_j(t-1)$ for $t \\ge 1$.\n    *   Sample cross-correlation at lag $\\tau$: $\\rho_{xy}(\\tau) \\;=\\; \\frac{\\sum_t \\big(x(t-\\tau)-\\bar x\\big)\\big(y(t)-\\bar y\\big)}{\\sqrt{\\sum_t \\big(x(t-\\tau)-\\bar x\\big)^2}\\,\\sqrt{\\sum_t \\big(y(t)-\\bar y\\big)^2}}$. The sequences $x(t)$ and $y(t)$ are zero-mean over their common support, with sample means $\\bar x$ and $\\bar y$.\n    *   Lag interpretation: $\\tau > 0$ implies $x$ leads $y$.\n*   **Task:** Analyze $\\mathrm{corr}\\big(q_1, \\dot q_2\\big)$ to determine which migration policy is more consistent with the provided trace.\n\n**Validation Verdict:**\nThe problem is **valid**.\n1.  **Scientifically Grounded:** The concepts of push and pull migration, CPU scheduler queue lengths, and their analysis via time-series correlation are standard topics in operating systems and performance engineering. The setup is a simplified but physically meaningful model.\n2.  **Well-Posed:** All necessary data ($q_1(t)$, $q_2(t)$) and mathematical definitions ($\\dot q_j(t)$, $\\rho_{xy}(\\tau)$) are provided. The question is specific and answerable through the application of the given tools to the given data.\n3.  **Objective and Complete:** The problem statement is objective and quantitative. It contains all information required to perform the analysis. There are no contradictions.\n\n### Step 2: Solution Derivation\n\nThe problem requires us to determine the migration policy by analyzing the cross-correlation between the queue length of core 1, $q_1(t)$, and the rate of change of the queue length of core 2, $\\dot q_2(t)$.\n\n**Theoretical Expectation for Each Policy:**\n\n1.  **Push Migration:**\n    *   The trigger for this policy is a core becoming overloaded. In our two-core system, if core 1 is overloaded, its queue length $q_1(t)$ will be high.\n    *   As a proactive measure, core 1 will 'push' a task to core 2 to balance the load.\n    *   The arrival of this pushed task at core 2 will cause its queue length, $q_2$, to increment. This corresponds to a positive value for the change in queue length, $\\dot q_2 > 0$.\n    *   There is a causal relationship: a high $q_1$ at time $t$ leads to a positive $\\dot q_2$ at a slightly later time $t+\\tau$, where $\\tau > 0$ is the lag incorporating decision and transfer time.\n    *   This implies a positive correlation between the time series $q_1(t)$ and $\\dot q_2(t)$. Since the cause ($q_1$) precedes the effect ($\\dot q_2$), we expect the cross-correlation function $\\rho_{q_1 \\dot q_2}(\\tau)$ to exhibit a prominent positive peak at a small positive lag, $\\tau > 0$.\n\n2.  **Pull Migration:**\n    *   The trigger for this policy is a core becoming underloaded. If core 2 is underloaded, its queue length $q_2(t)$ will be low.\n    *   Core 2 will 'pull' a task from another core, which in this case must be core 1. This can only happen if core 1 has tasks to give, so $q_1(t)$ must be sufficiently large.\n    *   The result of a successful pull is an increment in $q_2$, meaning $\\dot q_2 > 0$.\n    *   The direct trigger is the state of core 2 (low $q_2$), not core 1. The state of $q_1$ is a necessary precondition, not the direct cause of the migration event.\n    *   Therefore, the causal link between $q_1$ alone and the change $\\dot q_2$ is less direct than in push migration. We might expect the correlation $\\rho_{q_1 \\dot q_2}(\\tau)$ to be weaker for $\\tau > 0$ or for the relationship to be more complex, possibly involving the state of $q_2$ as well. The signature of a strong positive peak at $\\tau > 0$ is not the primary expectation for pull migration.\n\n**Data Analysis:**\n\nLet's compute the relevant quantities from the given traces.\n\n*   $q_1(t) = [\\,3, 4, 5, 5, 4, 3, 2, 2, 2\\,]$ for $t=0, \\dots, 8$.\n*   $q_2(t) = [\\,1, 1, 1, 2, 3, 3, 3, 2, 2\\,]$ for $t=0, \\dots, 8$.\n\nFirst, we compute the sequence for $\\dot q_2(t) = q_2(t) - q_2(t-1)$ for $t=1, \\dots, 8$:\n*   $\\dot q_2(1) = 1-1=0$\n*   $\\dot q_2(2) = 1-1=0$\n*   $\\dot q_2(3) = 2-1=1$\n*   $\\dot q_2(4) = 3-2=1$\n*   $\\dot q_2(5) = 3-3=0$\n*   $\\dot q_2(6) = 3-3=0$\n*   $\\dot q_2(7) = 2-3=-1$\n*   $\\dot q_2(8) = 2-2=0$\n\nSo, the sequence to be correlated is $x(t) = q_1(t)$ and $y(t) = \\dot q_2(t) = [\\,0, 0, 1, 1, 0, 0, -1, 0\\,]$ for $t=1, \\dots, 8$. We need to find the lag $\\tau$ of the prominent peak of $\\rho_{xy}(\\tau) = \\mathrm{corr}\\big(q_1, \\dot q_2\\big)(\\tau)$.\n\nWe will calculate the numerator of the cross-correlation, the sample covariance, for small integer lags $|\\tau|$. A peak in the covariance corresponds to a peak in the correlation. The formula for covariance is $C_{xy}(\\tau) = \\sum_t (x(t-\\tau) - \\bar{x})(y(t) - \\bar{y})$, where the sum is over the common time support and the means are calculated over the sequences in that support.\n\n**Case $\\tau = 1$ ($q_1$ leads $\\dot q_2$):**\nThe sum is over $t \\in [1, 8]$.\n*   The sequence $x(t-1)$ is $q_1(0...7) = [\\,3, 4, 5, 5, 4, 3, 2, 2\\,]$. Its mean is $\\bar x = (3+4+5+5+4+3+2+2)/8 = 28/8 = 3.5$.\n*   The sequence $y(t)$ is $\\dot q_2(1...8) = [\\,0, 0, 1, 1, 0, 0, -1, 0\\,]$. Its mean is $\\bar y = (0+0+1+1+0+0-1+0)/8 = 1/8 = 0.125$.\n*   The uncentered cross-product sum is $\\sum_{t=1}^8 q_1(t-1) \\dot q_2(t) = 5\\cdot1 + 5\\cdot1 + 2\\cdot(-1) = 8$.\n*   The covariance is $C_{xy}(1) = \\sum x y - N \\bar x \\bar y = 8 - 8 \\cdot (3.5) \\cdot (0.125) = 8 - 3.5 = 4.5$.\n\n**Case $\\tau = 0$ (zero lag):**\nThe sum is over $t \\in [1, 8]$.\n*   The sequence $x(t)$ is $q_1(1...8) = [\\,4, 5, 5, 4, 3, 2, 2, 2\\,]$. Its mean is $\\bar x = (4+5+5+4+3+2+2+2)/8 = 27/8 = 3.375$.\n*   The sequence $y(t)$ is $\\dot q_2(1...8)$, same as before, with $\\bar y = 0.125$.\n*   The uncentered cross-product sum is $\\sum_{t=1}^8 q_1(t) \\dot q_2(t) = 5\\cdot1 + 4\\cdot1 + 2\\cdot(-1) = 7$.\n*   The covariance is $C_{xy}(0) = \\sum x y - N \\bar x \\bar y = 7 - 8 \\cdot (3.375) \\cdot (0.125) = 7 - 3.375 = 3.625$.\n\n**Case $\\tau = 2$ ($q_1$ leads $\\dot q_2$):**\nThe sum is over $t \\in [2, 8]$.\n*   The sequence $x(t-2)$ is $q_1(0...6) = [\\,3, 4, 5, 5, 4, 3, 2\\,]$. Its mean is $\\bar x = (3+4+5+5+4+3+2)/7 = 26/7 \\approx 3.714$.\n*   The sequence $y(t)$ is $\\dot q_2(2...8) = [\\,0, 1, 1, 0, 0, -1, 0\\,]$. Its mean is $\\bar y = (0+1+1+0+0-1+0)/7 = 1/7 \\approx 0.143$.\n*   The uncentered cross-product sum is $\\sum_{t=2}^8 q_1(t-2) \\dot q_2(t) = 4\\cdot1 + 5\\cdot1 + 3\\cdot(-1) = 6$.\n*   The covariance is $C_{xy}(2) = \\sum x y - N \\bar x \\bar y = 6 - 7 \\cdot (26/7) \\cdot (1/7) = 6 - 26/7 = (42-26)/7 = 16/7 \\approx 2.286$.\n\nThe covariance values are $C(1)=4.5$, $C(0)=3.625$, $C(2)\\approx 2.286$. The covariance is clearly positive and has a prominent peak at lag $\\tau=1$. To confirm the strength of the correlation, we can calculate $\\rho(1)$.\n*   Denominator for $\\rho(1)$: $\\sqrt{\\sum (x-\\bar x)^2} \\sqrt{\\sum (y-\\bar y)^2}$.\n*   For $x(t-1)$, centered sequence is $[ -0.5, 0.5, 1.5, 1.5, 0.5, -0.5, -1.5, -1.5 ]$. Sum of squares is $10$.\n*   For $y(t)$, centered sequence is $[ -0.125, -0.125, 0.875, 0.875, -0.125, -0.125, -1.125, -0.125 ]$. Sum of squares is $184/64 = 2.875$.\n*   $\\rho(1) = \\frac{4.5}{\\sqrt{10} \\sqrt{2.875}} \\approx \\frac{4.5}{3.162 \\times 1.696} \\approx \\frac{4.5}{5.362} \\approx 0.839$.\n\nThis is a very strong positive correlation. The data shows that a high queue length on core 1 is a strong predictor of an increase in queue length on core 2 one time step later. This observation is a classic signature of push migration.\n\n### Step 3: Option-by-Option Analysis\n\n**A. The system uses push migration: $q_1$ leads $\\dot q_2$; $\\mathrm{corr}\\big(q_1,\\dot q_2\\big)$ has a strong positive peak at a small positive lag $\\tau>0$.**\nThis statement aligns perfectly with both our theoretical reasoning for push migration and our analysis of the provided data. We found a strong positive correlation coefficient ($\\rho \\approx 0.839$) at a positive lag of $\\tau = 1$. The peak at $\\tau=1$ means $q_1$ leads $\\dot q_2$.\n**Verdict: Correct.**\n\n**B. The system uses pull migration: $q_2$ initiates transfers when underloaded; $\\mathrm{corr}\\big(q_1,\\dot q_2\\big)$ peaks at a negative lag $\\tau<0$ or is weak for $\\tau>0$.**\nThis statement claims that for pull migration, the correlation is either weak for $\\tau > 0$ or peaks at $\\tau < 0$. Our data analysis found a *strong* correlation at $\\tau=1 > 0$, which contradicts both of these possibilities. Therefore, the data is inconsistent with the signature described for pull migration.\n**Verdict: Incorrect.**\n\n**C. The system uses pull migration, yet $q_1$ still leads $\\dot q_2$ with a strong positive peak at $\\tau>0$.**\nThis option suggests that the system is using pull migration but coincidentally exhibits the signature of push migration. While complex system dynamics can sometimes produce misleading correlations, Occam's razor suggests we should prefer the simplest explanation. The observed signature is the canonical expectation for push migration. Asserting the policy is pull migration in the face of this evidence would require a separate, compelling reason, which is not provided. The most direct conclusion from the data is that the policy is push migration.\n**Verdict: Incorrect.**\n\n**D. Neither policy can be inferred: $\\mathrm{corr}\\big(q_1,\\dot q_2\\big)$ is approximately zero for small $|\\tau|$.**\nThis statement claims the correlation is negligible. Our calculation shows the correlation is strong and positive at $\\tau=1$, with $\\rho(1) \\approx 0.839$, which is very far from zero. Thus, this statement is factually incorrect.\n**Verdict: Incorrect.**\n\nThe analysis of the data provides strong evidence for a push migration policy, as its characteristic signature is clearly present in the correlation between $q_1$ and $\\dot q_2$.", "answer": "$$\\boxed{A}$$", "id": "3674334"}, {"introduction": "While task migration is a powerful tool for load balancing, it is not a \"free\" operation. Every time a thread moves between cores, it incurs overhead, particularly within the memory subsystem. This exercise delves into the concrete costs of migration by modeling the time spent on invalidating old memory address translations (TLB shootdown) and handling misses on the new core, allowing you to quantify the penalty and determine when a migration might be counterproductive [@problem_id:3674362].", "problem": "A multicore operating system employs two load-balancing policies: push migration, where a busy core proactively moves a runnable thread to another core, and pull migration, where an idle core pulls a thread when it detects imbalance. Consider the memory translation overhead caused by a migration of a thread between cores. The underlying architecture provides a Translation Lookaside Buffer (TLB) that caches page translations. A migrating thread’s address space is identified by an Address Space Identifier (ASID), but assume that on this platform the operating system performs a per-page TLB shootdown via Inter-Processor Interrupt (IPI) to the source core to invalidate potentially stale translations for the migrating address space, and the destination core must incur TLB refills for the first touch of each distinct page of the thread’s working set.\n\nUse the following context-appropriate base and assumptions:\n- The Translation Lookaside Buffer (TLB) has capacity $E$ entries and each entry caches the translation of one page.\n- The thread’s working set spans $n$ distinct pages.\n- A per-page TLB invalidation (such as an instruction analogous to invalidate page) on the source core costs $t_{\\text{invlpg}}$ seconds per invalidated entry, and dispatching and handling the Inter-Processor Interrupt (IPI) costs $t_{\\text{ipi}}$ seconds as a fixed overhead per shootdown event.\n- On the destination core, each first access to a distinct page in the working set that is not yet in the TLB causes one TLB miss, costing $t_{\\text{miss}}$ seconds per distinct page accessed until the TLB is warmed for that address space.\n- Pages beyond TLB capacity do not incur additional invalidations or misses beyond $E$ on a single migration, because only up to $E$ distinct translations can reside in the TLB at once.\n\nTask:\n1. Starting from the definitions above, derive a closed-form expression $S(n)$ for the total migration-induced overhead time due to TLB shootdown and TLB refill on the two cores, in terms of $n$, $E$, $t_{\\text{ipi}}$, $t_{\\text{invlpg}}$, and $t_{\\text{miss}}$. Your expression must be valid for both small and large address spaces and should justify the use of any saturation behavior based on TLB capacity.\n2. Evaluate $S(n)$ for a “small” address space with $n_{s} = 32$ pages and a “large” address space with $n_{\\ell} = 4096$ pages, given $E = 512$, $t_{\\text{ipi}} = 3.0 \\times 10^{-6}$ seconds, $t_{\\text{invlpg}} = 8.0 \\times 10^{-8}$ seconds, and $t_{\\text{miss}} = 4.0 \\times 10^{-8}$ seconds. Express both results in microseconds and round to four significant figures.\n3. Let the proactive benefit of push migration (for example, reduced run queue waiting) be $G$ seconds per migration. Derive, in a single closed-form analytic expression, the threshold page count $n^{\\star}$ (as a function of $E$, $t_{\\text{ipi}}$, $t_{\\text{invlpg}}$, $t_{\\text{miss}}$, and $G$) above which push migration is counterproductive, meaning $S(n) > G$.\n\nProvide your final results as a row vector $\\big[ S(n_{s})\\text{ in }\\mu\\text{s},\\ S(n_{\\ell})\\text{ in }\\mu\\text{s},\\ n^{\\star} \\big]$ and note that the numerical entries must be rounded to four significant figures. Do not include units in the boxed final answer, but state microseconds explicitly in your intermediate work.", "solution": "The problem statement is first subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\n- **TLB Capacity:** $E$ entries.\n- **Thread Working Set:** $n$ distinct pages.\n- **IPI Overhead:** $t_{\\text{ipi}}$ seconds, a fixed cost per shootdown event.\n- **Per-Page Invalidation Cost:** $t_{\\text{invlpg}}$ seconds per invalidated entry on the source core.\n- **TLB Miss Cost:** $t_{\\text{miss}}$ seconds per distinct page on the destination core.\n- **Saturation Constraint:** \"Pages beyond TLB capacity do not incur additional invalidations or misses beyond $E$ on a single migration, because only up to $E$ distinct translations can reside in the TLB at once.\"\n- **Task 1:** Derive $S(n)$ for total migration-induced overhead time.\n- **Task 2:** Evaluate $S(n)$ for $n_{s} = 32$ and $n_{\\ell} = 4096$, given:\n  - $E = 512$\n  - $t_{\\text{ipi}} = 3.0 \\times 10^{-6}$ seconds\n  - $t_{\\text{invlpg}} = 8.0 \\times 10^{-8}$ seconds\n  - $t_{\\text{miss}} = 4.0 \\times 10^{-8}$ seconds\n- **Task 3:** Derive the threshold page count $n^{\\star}$ such that $S(n) > G$, where $G$ is the proactive benefit of push migration.\n- **Final Answer Format:** A row vector $\\big[ S(n_{s})\\text{ in }\\mu\\text{s},\\ S(n_{\\ell})\\text{ in }\\mu\\text{s},\\ n^{\\star} \\big]$, with numerical values rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem is based on established concepts in operating systems and computer architecture, including thread migration, Translation Lookaside Buffers (TLBs), TLB shootdowns, and Inter-Processor Interrupts (IPIs). The cost model is a valid simplification of real-world overheads. The problem is scientifically sound.\n- **Well-Posed:** All necessary variables and constraints are defined. The tasks are specific and allow for the derivation of unique, meaningful solutions. The explicit saturation constraint based on TLB capacity $E$ removes ambiguity.\n- **Objective:** The problem is stated in precise, technical language, free of subjectivity or opinion.\n- **Flaw Check:** The problem does not violate any fundamental principles, is not incomplete or contradictory, uses plausible physical parameters, and is not ill-posed or trivial. The saturation condition adds a non-trivial modeling challenge.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A full solution will be provided.\n\n### Solution Derivation\n\nThe total migration-induced overhead, $S(n)$, is the sum of the overhead on the source core (TLB shootdown) and the overhead on the destination core (TLB refill).\n\n$S(n) = T_{\\text{shootdown}} + T_{\\text{refill}}$\n\n**1. Derivation of the overhead expression $S(n)$**\n\nThe TLB shootdown process on the source core involves a single Inter-Processor Interrupt (IPI) to initiate the invalidation, plus the cost of invalidating each relevant TLB entry. A thread with a working set of $n$ pages can have at most $n$ entries in the TLB. However, the TLB's capacity is limited to $E$ entries. Therefore, the number of entries that could possibly be in the source core's TLB for this thread is the minimum of $n$ and $E$. The problem statement confirms this saturation behavior. The shootdown overhead is thus:\n$$T_{\\text{shootdown}} = t_{\\text{ipi}} + \\min(n, E) \\cdot t_{\\text{invlpg}}$$\nHere, $t_{\\text{ipi}}$ is the one-time cost for the shootdown event, and $\\min(n, E) \\cdot t_{\\text{invlpg}}$ is the variable cost dependent on the number of pages to invalidate.\n\nThe TLB refill process occurs on the destination core. When the thread begins execution, its working set of $n$ pages is not in the new core's TLB. Each first access to one of these $n$ distinct pages will cause a TLB miss, incurring a cost of $t_{\\text{miss}}$. Similar to the shootdown cost, the problem explicitly states that the number of misses is capped by the TLB capacity, $E$. Thus, the number of misses to be accounted for is $\\min(n, E)$. The refill overhead is:\n$$T_{\\text{refill}} = \\min(n, E) \\cdot t_{\\text{miss}}$$\n\nCombining these two components gives the total migration overhead $S(n)$:\n$$S(n) = \\left( t_{\\text{ipi}} + \\min(n, E) \\cdot t_{\\text{invlpg}} \\right) + \\left( \\min(n, E) \\cdot t_{\\text{miss}} \\right)$$\nFactoring out the common term $\\min(n, E)$, we obtain the final closed-form expression for the total overhead:\n$$S(n) = t_{\\text{ipi}} + \\min(n, E) \\cdot (t_{\\text{invlpg}} + t_{\\text{miss}})$$\nThis expression correctly models the linear increase in overhead for working sets smaller than the TLB capacity ($n \\le E$, where $\\min(n, E) = n$) and the saturation of overhead for working sets larger than the TLB capacity ($n > E$, where $\\min(n, E) = E$).\n\n**2. Evaluation of $S(n_{s})$ and $S(n_{\\ell})$**\n\nWe are given the following values:\n- $E = 512$\n- $t_{\\text{ipi}} = 3.0 \\times 10^{-6}$ s\n- $t_{\\text{invlpg}} = 8.0 \\times 10^{-8}$ s\n- $t_{\\text{miss}} = 4.0 \\times 10^{-8}$ s\n\nFirst, we pre-calculate the combined per-page cost:\n$$t_{\\text{invlpg}} + t_{\\text{miss}} = 8.0 \\times 10^{-8} \\, \\text{s} + 4.0 \\times 10^{-8} \\, \\text{s} = 12.0 \\times 10^{-8} \\, \\text{s} = 1.2 \\times 10^{-7} \\, \\text{s}$$\n\nFor the \"small\" address space, $n_{s} = 32$. Since $n_{s} < E$ ($32 < 512$), we have $\\min(n_{s}, E) = 32$.\n$$S(32) = t_{\\text{ipi}} + 32 \\cdot (t_{\\text{invlpg}} + t_{\\text{miss}})$$\n$$S(32) = 3.0 \\times 10^{-6} + 32 \\cdot (1.2 \\times 10^{-7})$$\n$$S(32) = 3.0 \\times 10^{-6} + 3.84 \\times 10^{-6} = 6.84 \\times 10^{-6} \\, \\text{s}$$\nIn microseconds, this is $6.84 \\, \\mu\\text{s}$. To four significant figures, this is $6.840 \\, \\mu\\text{s}$.\n\nFor the \"large\" address space, $n_{\\ell} = 4096$. Since $n_{\\ell} > E$ ($4096 > 512$), we have $\\min(n_{\\ell}, E) = E = 512$.\n$$S(4096) = t_{\\text{ipi}} + E \\cdot (t_{\\text{invlpg}} + t_{\\text{miss}})$$\n$$S(4096) = 3.0 \\times 10^{-6} + 512 \\cdot (1.2 \\times 10^{-7})$$\n$$S(4096) = 3.0 \\times 10^{-6} + 61.44 \\times 10^{-6} = 64.44 \\times 10^{-6} \\, \\text{s}$$\nIn microseconds, this is $64.44 \\, \\mu\\text{s}$. This value already has four significant figures.\n\n**3. Derivation of the threshold page count $n^{\\star}$**\n\nPush migration is counterproductive when the migration overhead $S(n)$ exceeds the benefit $G$. The threshold $n^{\\star}$ is the page count at which the overhead equals the benefit, $S(n^{\\star}) = G$.\n$$t_{\\text{ipi}} + \\min(n^{\\star}, E) \\cdot (t_{\\text{invlpg}} + t_{\\text{miss}}) = G$$\nThis equation can only be solved for $n^{\\star}$ if the overhead is not saturated. The crossover from beneficial to counterproductive must occur in the linear region of the cost function, where $n^{\\star} \\le E$. If the benefit $G$ is larger than the maximum possible overhead, $S(E) = t_{\\text{ipi}} + E (t_{\\text{invlpg}} + t_{\\text{miss}})$, then migration is never counterproductive, and no finite threshold $n^{\\star}$ exists. Assuming such a threshold does exist (i.e., $G$ is not excessively large), we can solve for $n^{\\star}$ in the linear regime where $\\min(n^{\\star}, E) = n^{\\star}$:\n$$t_{\\text{ipi}} + n^{\\star} \\cdot (t_{\\text{invlpg}} + t_{\\text{miss}}) = G$$\nSolving for $n^{\\star}$:\n$$n^{\\star} \\cdot (t_{\\text{invlpg}} + t_{\\text{miss}}) = G - t_{\\text{ipi}}$$\n$$n^{\\star} = \\frac{G - t_{\\text{ipi}}}{t_{\\text{invlpg}} + t_{\\text{miss}}}$$\nThis expression is physically meaningful for a page count threshold if $G > t_{\\text{ipi}}$, yielding $n^{\\star} > 0$. If $G \\le t_{\\text{ipi}}$, any migration is counterproductive for any working set size ($n > 0$), making the effective threshold $0$. The derived expression is the general analytical solution for the threshold $n^{\\star}$, under the condition that it exists within the linear cost domain ($0 \\le n^{\\star} \\le E$).", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6.840 & 64.44 & \\frac{G - t_{\\text{ipi}}}{t_{\\text{invlpg}} + t_{\\text{miss}}}\n\\end{pmatrix}\n}\n$$", "id": "3674362"}, {"introduction": "Effective system design is an art of managing trade-offs. While frequent load balancing can improve responsiveness, the mechanism itself can introduce new bottlenecks. This final practice explores such a trade-off, where frequent push migrations increase contention for a shared runqueue lock. Using principles from queueing theory, you will model this system-level effect and calculate the optimal balancing interval $\\Delta$ to keep resource contention within an acceptable tolerance [@problem_id:3674381].", "problem": "A multiprocessor scheduler on a system with $N$ Central Processing Unit (CPU) cores uses a single shared runqueue protected by a mutex. The scheduler performs periodic load balancing using push migration: each CPU, at interval $\\Delta$, initiates a balancing action that acquires the runqueue lock to inspect and potentially move tasks. You are asked to design a microbenchmark that stresses push migrations and then derive the smallest $\\Delta$ that keeps the probability of lock contention below a target.\n\nTest design assumptions grounded in well-tested modeling facts:\n1. Each CPU triggers a push-migration lock acquisition driven by an independent exponential timer with mean $\\Delta$ (so push attempts are a Poisson process per core with rate $1/\\Delta$, producing an aggregate push rate $\\lambda_{p} = N/\\Delta$).\n2. Background enqueue operations to the shared runqueue occur as a Poisson process of rate $\\lambda_{e}$ due to task wakeups, and each enqueue acquires the same lock.\n3. Lock hold times for push attempts and for enqueue operations are independent and exponentially distributed with means $\\tau_{p}$ and $\\tau_{e}$, respectively.\n4. The lock is modeled as a single-server First-Come First-Served (FCFS) system. By the Poisson Arrivals See Time Averages (PASTA) property, a Poisson arrival sees the lock busy with probability equal to the long-run busy fraction.\n\nUnder these assumptions, construct a microbenchmark by setting $N = 32$ and configuring the scheduler and workload such that push migrations dominate lock usage while still occurring concurrently with background enqueues: per-core push-migration lock holds have mean $\\tau_{p} = 35 \\times 10^{-6}$ s, background enqueue lock holds have mean $\\tau_{e} = 18 \\times 10^{-6}$ s, and the measured background enqueue arrival rate is $\\lambda_{e} = 3500$ s$^{-1}$. The balancing interval $\\Delta$ is the single tunable parameter.\n\nUsing only the assumptions listed above and first principles of queueing under FCFS with Poisson arrivals, derive the smallest $\\Delta$ (in seconds) that guarantees $P(\\text{contention}) < 0.1$, where $P(\\text{contention})$ denotes the probability that an arbitrary lock acquisition attempt finds the runqueue lock already held. Then express your final result for $\\Delta$ in milliseconds and round your answer to four significant figures.", "solution": "The problem statement is first validated against the required criteria.\n\n### Step 1: Extract Givens\n- Number of CPU cores: $N = 32$.\n- Each CPU initiates a push-migration lock acquisition at an interval $\\Delta$.\n- Push attempts are a Poisson process per core with rate $1/\\Delta$.\n- Aggregate push-migration attempt rate: $\\lambda_{p} = N/\\Delta$.\n- Background enqueue operations are a Poisson process with rate $\\lambda_{e} = 3500$ s$^{-1}$.\n- The lock is a single-server First-Come First-Served (FCFS) system.\n- Lock hold times for push attempts are independent and exponentially distributed with mean $\\tau_{p} = 35 \\times 10^{-6}$ s.\n- Lock hold times for enqueue operations are independent and exponentially distributed with mean $\\tau_{e} = 18 \\times 10^{-6}$ s.\n- The Poisson Arrivals See Time Averages (PASTA) property is assumed.\n- The probability of contention, $P(\\text{contention})$, is the probability an arbitrary lock acquisition attempt finds the lock already held.\n- The objective is to find the smallest $\\Delta$ (in seconds) that guarantees $P(\\text{contention}) < 0.1$.\n- The final result for $\\Delta$ is to be expressed in milliseconds, rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on queueing theory, a standard and rigorous mathematical framework for analyzing system performance. The use of Poisson processes, exponential distributions, and the PASTA property are fundamental concepts in this field. The model (an M/G/1 queue, more specifically a superposition of processes leading to an M/H$_2$/1 queue) is a well-established method for modeling contention on shared resources in computer systems.\n- **Well-Posed**: The problem is clearly defined with a specific objective: to find a parameter $\\Delta$ that satisfies a given inequality. All necessary data and relationships are provided to establish a solvable mathematical model. A unique boundary value for $\\Delta$ exists.\n- **Objective**: The problem is stated in precise, quantitative, and unbiased technical language.\n- **Completeness and Consistency**: The problem is self-contained. All variables and constants required for the derivation are defined and have consistent units. There are no contradictions in the setup.\n- **Unrealistic or Infeasible**: The numerical values provided for core counts, lock hold times (microseconds), and event rates (thousands per second) are realistic for modern high-performance multiprocessor operating systems.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid** as it is scientifically sound, well-posed, and complete. A solution will be derived.\n\n### Solution Derivation\nThe runqueue lock is modeled as a single-server queue. Lock acquisition requests arrive from two independent sources, both of which are Poisson processes:\n1.  Push-migration attempts from $N$ cores, with a total aggregate arrival rate of $\\lambda_{p} = \\frac{N}{\\Delta}$.\n2.  Background enqueue operations, with an arrival rate of $\\lambda_{e}$.\n\nSince the superposition of independent Poisson processes is itself a Poisson process, the total arrival rate of lock requests, $\\lambda_{total}$, is the sum of the individual rates:\n$$\n\\lambda_{total} = \\lambda_{p} + \\lambda_{e} = \\frac{N}{\\Delta} + \\lambda_{e}\n$$\nThe service time (the duration the lock is held) depends on the type of request. For push-migration attempts, the mean service time is $\\tau_{p}$. For enqueue operations, the mean service time is $\\tau_{e}$.\n\nThe utilization of the server, $\\rho$, is the fraction of time the lock is held. It is the sum of the workloads contributed by each process. The workload from a process is the product of its arrival rate and its mean service time.\n$$\n\\rho = (\\text{workload from push migrations}) + (\\text{workload from enqueues})\n$$\n$$\n\\rho = \\lambda_{p} \\tau_{p} + \\lambda_{e} \\tau_{e}\n$$\nSubstituting the expression for $\\lambda_p$:\n$$\n\\rho = \\frac{N \\tau_{p}}{\\Delta} + \\lambda_{e} \\tau_{e}\n$$\nThe problem states that due to the PASTA property, the probability that an arriving request finds the lock busy, $P(\\text{contention})$, is equal to the long-run server utilization $\\rho$. This is a standard result for any queueing system with Poisson arrivals (an M/G/1 queue, in this case, where 'G' stands for a general service time distribution).\n$$\nP(\\text{contention}) = \\rho\n$$\nThe problem requires that this probability be less than $0.1$:\n$$\nP(\\text contention) < 0.1\n$$\n$$\n\\frac{N \\tau_{p}}{\\Delta} + \\lambda_{e} \\tau_{e} < 0.1\n$$\nWe are asked to find the smallest value of $\\Delta$ that guarantees this condition. This means we are looking for the threshold value of $\\Delta$ that defines the boundary of the acceptable region. We can find this by rearranging the inequality to solve for $\\Delta$.\n$$\n\\frac{N \\tau_{p}}{\\Delta} < 0.1 - \\lambda_{e} \\tau_{e}\n$$\nFor a stable system, the utilization $\\rho$ must be less than $1$. The condition $\\rho < 0.1$ ensures this. The term $0.1 - \\lambda_{e} \\tau_{e}$ must be positive. Let's compute the value of $\\lambda_{e} \\tau_{e}$ using the given data:\n$$\n\\lambda_{e} \\tau_{e} = (3500 \\text{ s}^{-1}) \\times (18 \\times 10^{-6} \\text{ s}) = 63000 \\times 10^{-6} = 0.063\n$$\nSince $0.063 < 0.1$, the term on the right-hand side is positive, and we can proceed.\n$$\n\\frac{N \\tau_{p}}{\\Delta} < 0.1 - 0.063\n$$\n$$\n\\frac{N \\tau_{p}}{\\Delta} < 0.037\n$$\nSince $\\Delta$ is a time interval, it must be positive. We can multiply by $\\Delta$ and divide by $0.037$ without changing the direction of the inequality:\n$$\n\\Delta > \\frac{N \\tau_{p}}{0.037}\n$$\nThis inequality specifies the condition that $\\Delta$ must satisfy. The \"smallest $\\Delta$\" refers to the infimum of the set of valid $\\Delta$ values, which is the boundary value itself. We will calculate this boundary.\n$$\n\\Delta_{min} = \\frac{N \\tau_{p}}{0.1 - \\lambda_{e} \\tau_{e}}\n$$\nLet's substitute the remaining numerical values: $N=32$ and $\\tau_{p} = 35 \\times 10^{-6}$ s.\nThe numerator is:\n$$\nN \\tau_{p} = 32 \\times (35 \\times 10^{-6} \\text{ s}) = 1120 \\times 10^{-6} \\text{ s} = 1.12 \\times 10^{-3} \\text{ s}\n$$\nNow, substitute this into the expression for $\\Delta_{min}$:\n$$\n\\Delta_{min} = \\frac{1.12 \\times 10^{-3} \\text{ s}}{0.037} \\approx 30.27027... \\times 10^{-3} \\text{ s}\n$$\nThe problem requires the answer in milliseconds (ms), where $1$ ms $= 10^{-3}$ s.\n$$\n\\Delta_{min} \\approx 30.27027... \\text{ ms}\n$$\nFinally, rounding the result to four significant figures:\n$$\n\\Delta_{min} \\approx 30.27 \\text{ ms}\n$$\nThus, the smallest balancing interval that keeps the probability of lock contention below $0.1$ is (approaching from above) $30.27$ ms.", "answer": "$$\n\\boxed{30.27}\n$$", "id": "3674381"}]}