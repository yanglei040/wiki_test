{"hands_on_practices": [{"introduction": "Before we can trust the results of a numerical simulation, we must first ensure it is stable—that is, errors do not grow uncontrollably and cause the solution to \"blow up.\" This first exercise dives into the fundamental concept of numerical stability for the Lax-Wendroff scheme, governed by the Courant-Friedrichs-Lewy (CFL) condition. By combining theoretical analysis with a simple numerical experiment, you will directly investigate the boundary between a stable simulation and a chaotic, unstable one, providing a crucial first-hand understanding of the scheme's operational limits [@problem_id:2407699].", "problem": "Consider the one-dimensional linear advection equation $u_t + a\\,u_x = 0$ with constant advection speed $a \\in \\mathbb{R}$ on a periodic domain $x \\in [0,1)$. Discretize space with a uniform grid of $N$ points, where $N = 256$, grid index $j \\in \\{0,1,\\dots,N-1\\}$, and spacing $\\Delta x = 1/N$. Let time be discretized with step $\\Delta t$ and define the Courant number $C = a\\,\\Delta t/\\Delta x$. All quantities are nondimensional.\n\nUse the second-order Lax–Wendroff scheme\n$$\nu_j^{n+1}\n=\nu_j^n\n-\n\\frac{C}{2}\\left(u_{j+1}^n - u_{j-1}^n\\right)\n+\n\\frac{C^2}{2}\\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right),\n$$\nwith periodic indexing $u_{j\\pm N}^n \\equiv u_j^n$.\n\nLet the initial condition be a combination of a smooth Fourier mode and a seeded highest-wavenumber mode,\n$$\nu_j^0 = \\sin\\!\\left(2\\pi m \\frac{j}{N}\\right) + \\varepsilon\\,(-1)^j,\n$$\nwith $m = 4$ and $\\varepsilon = 10^{-6}$.\n\nFor each parameter set below, choose $\\Delta t$ so that the Courant number equals the specified $C$ via $C = a\\,\\Delta t/\\Delta x$. For each set, compute and report the following four quantities:\n- A boolean indicating instability in the von Neumann sense, equal to $\\mathrm{True}$ if $|C|  1$ and $\\mathrm{False}$ otherwise.\n- The theoretical maximum per-step amplification factor over all Fourier modes, i.e., $\\max_{\\theta \\in [0,2\\pi)} |G(\\theta)|$, where $G(\\theta)$ is the Lax–Wendroff amplification factor for wavenumber angle $\\theta$.\n- The theoretical per-step amplification factor for the specific smooth mode with wavenumber index $m$, i.e., $|G(\\theta_m)|$ with $\\theta_m = 2\\pi m/N$.\n- The numerically measured per-step amplification factor for the same smooth mode after exactly one time step, obtained by comparing the magnitude of that mode before and after one application of the scheme.\n\nTest suite (each case is $(a,C)$):\n- Case $1$: $(a,C) = (1,\\,0.5)$.\n- Case $2$: $(a,C) = (1,\\,1.0)$.\n- Case $3$: $(a,C) = (1,\\,1.1)$.\n- Case $4$: $(a,C) = (1,\\,1.5)$.\n- Case $5$: $(a,C) = (-1,\\,-1.1)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the entry for each case is itself a list of the form $[b,g_{\\max},g_m^{\\mathrm{theory}},g_m^{\\mathrm{meas}}]$ in the same order as above. The element $b$ must be either $\\mathrm{True}$ or $\\mathrm{False}$; the three real numbers must be rounded to exactly six digits after the decimal point. No spaces are permitted anywhere in the output line. For example, a line with two cases would look like $[[\\mathrm{False},1.000000,0.999000,0.999001],[\\mathrm{True},1.420000,1.000010,1.000012]]$.", "solution": "The problem as stated is a well-posed, scientifically-grounded exercise in the numerical analysis of partial differential equations. It concerns the application of the Lax–Wendroff scheme to the one-dimensional linear advection equation. All provided parameters and conditions are consistent and sufficient for a unique solution. Therefore, I will proceed with a full derivation and computational solution.\n\nThe problem asks for an analysis of the second-order Lax–Wendroff scheme for the linear advection equation $u_t + a\\,u_x = 0$. The scheme is given by\n$$\nu_j^{n+1} = u_j^n - \\frac{C}{2}\\left(u_{j+1}^n - u_{j-1}^n\\right) + \\frac{C^2}{2}\\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right)\n$$\nwhere $u_j^n$ is the numerical solution at grid point $j$ and time step $n$, and $C = a\\,\\Delta t/\\Delta x$ is the Courant number.\n\nTo determine the theoretical properties of this scheme, we perform a von Neumann stability analysis. We consider the evolution of a single Fourier mode, $u_j^n = \\hat{u}^n(k) e^{i k x_j}$, where $x_j = j\\Delta x$ and $k$ is the wavenumber. We define the non-dimensional wavenumber angle $\\theta = k \\Delta x$. The solution ansatz becomes $u_j^n = \\hat{u}^n(\\theta) e^{ij\\theta}$. The amplification factor $G(\\theta)$ is defined by the relation $\\hat{u}^{n+1}(\\theta) = G(\\theta) \\hat{u}^n(\\theta)$. Substituting the ansatz into the scheme yields:\n$$\nG(\\theta)e^{ij\\theta} = e^{ij\\theta} - \\frac{C}{2}\\left(e^{i(j+1)\\theta} - e^{i(j-1)\\theta}\\right) + \\frac{C^2}{2}\\left(e^{i(j+1)\\theta} - 2e^{ij\\theta} + e^{i(j-1)\\theta}\\right)\n$$\nDividing by $e^{ij\\theta}$, we obtain the amplification factor:\n$$\nG(\\theta) = 1 - \\frac{C}{2}\\left(e^{i\\theta} - e^{-i\\theta}\\right) + \\frac{C^2}{2}\\left(e^{i\\theta} - 2 + e^{-i\\theta}\\right)\n$$\nUsing the identities $e^{i\\theta} - e^{-i\\theta} = 2i\\sin\\theta$ and $e^{i\\theta} + e^{-i\\theta} = 2\\cos\\theta$, this simplifies to:\n$$\nG(\\theta) = 1 - iC\\sin\\theta + C^2(\\cos\\theta - 1)\n$$\nThe magnitude of the amplification factor, $|G(\\theta)|$, determines the stability of the scheme. $|G(\\theta)| \\le 1$ for all $\\theta$ is required for stability. The squared magnitude is:\n$$\n|G(\\theta)|^2 = \\text{Re}(G(\\theta))^2 + \\text{Im}(G(\\theta))^2 = (1 + C^2(\\cos\\theta - 1))^2 + (-C\\sin\\theta)^2\n$$\n$$\n|G(\\theta)|^2 = 1 + 2C^2(\\cos\\theta - 1) + C^4(\\cos\\theta - 1)^2 + C^2\\sin^2\\theta\n$$\n$$\n|G(\\theta)|^2 = 1 - 2C^2(1 - \\cos\\theta) + C^4(1 - 2\\cos\\theta + \\cos^2\\theta) + C^2(1 - \\cos^2\\theta)\n$$\n$$\n|G(\\theta)|^2 = 1 - 2C^2 + 2C^2\\cos\\theta + C^4 - 2C^4\\cos\\theta + C^4\\cos^2\\theta + C^2 - C^2\\cos^2\\theta\n$$\n$$\n|G(\\theta)|^2 = 1 - C^2 + (2C^2 - 2C^4)\\cos\\theta + (C^4 - C^2)\\cos^2\\theta\n$$\nA more elegant derivation uses the half-angle identity $1 - \\cos\\theta = 2\\sin^2(\\theta/2)$:\n$$\nG(\\theta) = 1 - 2C^2\\sin^2(\\theta/2) - iC(2\\sin(\\theta/2)\\cos(\\theta/2))\n$$\n$$\n|G(\\theta)|^2 = (1 - 2C^2\\sin^2(\\theta/2))^2 + 4C^2\\sin^2(\\theta/2)\\cos^2(\\theta/2)\n$$\n$$\n|G(\\theta)|^2 = 1 - 4C^2\\sin^2(\\theta/2) + 4C^4\\sin^4(\\theta/2) + 4C^2\\sin^2(\\theta/2)(1-\\sin^2(\\theta/2))\n$$\n$$\n|G(\\theta)|^2 = 1 - 4C^2\\sin^2(\\theta/2) + 4C^4\\sin^4(\\theta/2) + 4C^2\\sin^2(\\theta/2) - 4C^2\\sin^4(\\theta/2)\n$$\nThis simplifies to a remarkably compact form:\n$$\n|G(\\theta)|^2 = 1 - 4C^2(1-C^2)\\sin^4(\\theta/2)\n$$\nWe now compute the four required quantities.\n\n1.  **Instability Condition**: The scheme is stable if $|G(\\theta)|^2 \\le 1$ for all $\\theta \\in [0, 2\\pi)$. The term $\\sin^4(\\theta/2)$ is non-negative. If $C^2 \\le 1$, then $(1-C^2) \\ge 0$, which makes the second term $-4C^2(1-C^2)\\sin^4(\\theta/2) \\le 0$. Thus, $|G(\\theta)|^2 \\le 1$, and the scheme is stable. If $C^2  1$, then $(1-C^2)  0$, making the second term positive. In this case, $|G(\\theta)|^2$ can exceed $1$. The condition for instability is therefore $|C|  1$.\n\n2.  **Theoretical Maximum Amplification Factor, $\\max_{\\theta} |G(\\theta)|$**:\n    -   If $|C| \\le 1$: Since the second term in the expression for $|G(\\theta)|^2$ is non-positive, the maximum is $1$ (at $\\theta=0$).\n    -   If $|C|  1$: The second term is positive, so $|G(\\theta)|^2$ is maximized when $\\sin^4(\\theta/2)$ is maximized. The maximum value of $\\sin^4(\\theta/2)$ is $1$ (at $\\theta=\\pi$).\n        $$\n        \\max |G(\\theta)|^2 = |G(\\pi)|^2 = 1 - 4C^2(1-C^2) = 1 - 4C^2 + 4C^4 = (2C^2 - 1)^2\n        $$\n        Therefore, $\\max_{\\theta} |G(\\theta)| = \\sqrt{(2C^2-1)^2} = |2C^2-1|$. Since $C^2  1$, $2C^2-1  1$, so the maximum factor is $2C^2-1$.\n\n3.  **Theoretical Amplification Factor for Mode $m$**:\n    The problem specifies a grid of $N=256$ points and a smooth mode with wavenumber index $m=4$. The corresponding wavenumber angle is $\\theta_m = 2\\pi m/N = 2\\pi(4)/256 = \\pi/32$. The theoretical amplification for this mode is $|G(\\theta_m)|$, which is calculated directly from the derived formula:\n    $$\n    |G(\\theta_m)| = \\sqrt{1 - 4C^2(1-C^2)\\sin^4(\\theta_m/2)} = \\sqrt{1 - 4C^2(1-C^2)\\sin^4(\\pi/64)}\n    $$\n\n4.  **Numerically Measured Amplification Factor for Mode $m$**:\n    This requires a one-step numerical experiment.\n    -   First, we construct the initial condition vector $u^0$ of size $N=256$ according to $u_j^0 = \\sin(2\\pi m j/N) + \\varepsilon (-1)^j$, with $m=4$ and $\\varepsilon=10^{-6}$.\n    -   We compute the Discrete Fourier Transform (DFT) of the initial state, $\\hat{u}^0 = \\text{FFT}(u^0)$. The initial complex amplitude of mode $m$ is $\\hat{u}^0_m$. Its magnitude is $|\\hat{u}^0_m|$.\n    -   Next, we apply a single step of the Lax–Wendroff scheme to $u^0$ to obtain the state at the next time step, $u^1$. This calculation must respect the periodic boundary conditions, which can be implemented efficiently using cyclic shifts of the array (e.g., `numpy.roll`).\n    -   We then compute the DFT of the new state, $\\hat{u}^1 = \\text{FFT}(u^1)$, and find the magnitude of the complex amplitude of mode $m$, $|\\hat{u}^1_m|$.\n    -   The numerically measured amplification factor is the ratio of these magnitudes: $g_m^{\\mathrm{meas}} = |\\hat{u}^1_m| / |\\hat{u}^0_m|$. This value is expected to be extremely close to the theoretical value $|G(\\theta_m)|$, with any deviation attributable to floating-point precision limitations.\n\nFor each test case $(a,C)$, these four quantities are calculated and formatted as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by analyzing the Lax-Wendroff scheme for five test cases.\n\n    For each case, it calculates:\n    1. A boolean for von Neumann instability.\n    2. The theoretical maximum amplification factor over all modes.\n    3. The theoretical amplification factor for a specific mode m.\n    4. The numerically measured amplification factor for mode m after one time step.\n    \"\"\"\n    # Define constants from the problem statement\n    N = 256\n    m = 4\n    eps = 1e-6\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (a, C), where 'a' is advection speed and 'C' is Courant number.\n    test_cases = [\n        (1.0, 0.5),\n        (1.0, 1.0),\n        (1.0, 1.1),\n        (1.0, 1.5),\n        (-1.0, -1.1),\n    ]\n\n    results = []\n    \n    # Grid for initial condition\n    j = np.arange(N)\n    \n    # Wavenumber angle for the smooth mode m\n    theta_m = 2.0 * np.pi * m / N\n\n    for a, C in test_cases:\n        # 1. Instability (von Neumann sense)\n        # The scheme is unstable if and only if |C|  1.0.\n        is_unstable = np.abs(C)  1.0\n\n        # 2. Theoretical maximum per-step amplification factor\n        if np.abs(C) = 1.0:\n            g_max = 1.0\n        else:\n            g_max = 2.0 * C**2 - 1.0\n\n        # 3. Theoretical per-step amplification factor for mode m\n        # |G|^2 = 1 - 4*C^2*(1-C^2)*sin^4(theta/2)\n        # We need to compute the square root of this for a complex result when C  1\n        # The term under the square root can be negative if C^2 outside of [0,1]\n        # and sin^4 is not zero. Let's use complex arithmetic to be safe.\n        term_inside_sqrt = 1.0 - 4.0 * C**2 * (1.0 - C**2) * np.sin(theta_m / 2.0)**4\n        g_m_theory = np.sqrt(np.abs(term_inside_sqrt))\n        \n        # 4. Numerically measured per-step amplification factor for mode m\n        # Initial condition\n        u0 = np.sin(2.0 * np.pi * m * j / N) + eps * (-1)**j\n\n        # Compute initial amplitude of mode m via FFT\n        u0_fft = np.fft.fft(u0)\n        A0_m = np.abs(u0_fft[m])\n\n        # Apply one step of the Lax-Wendroff scheme\n        u_jp1 = np.roll(u0, -1)\n        u_jm1 = np.roll(u0, 1)\n        u1 = u0 - (C / 2.0) * (u_jp1 - u_jm1) + (C**2 / 2.0) * (u_jp1 - 2.0 * u0 + u_jm1)\n\n        # Compute final amplitude of mode m via FFT\n        u1_fft = np.fft.fft(u1)\n        A1_m = np.abs(u1_fft[m])\n\n        # Calculate the measured amplification factor\n        g_m_measured = A1_m / A0_m if A0_m != 0 else 0.0\n        \n        # Store results for this case\n        results.append([\n            is_unstable,\n            g_max,\n            g_m_theory,\n            g_m_measured\n        ])\n    \n    # Format the output string precisely as required, with no spaces and\n    # with floating-point numbers rounded to exactly six decimal places.\n    case_strings = []\n    for res in results:\n        b_val, gmax_val, gm_th_val, gm_ms_val = res\n        s_bool = str(b_val)\n        s_gmax = f\"{gmax_val:.6f}\"\n        s_gm_th = f\"{gm_th_val:.6f}\"\n        s_gm_ms = f\"{gm_ms_val:.6f}\"\n        case_strings.append(f\"[{s_bool},{s_gmax},{s_gm_th},{s_gm_ms}]\")\n        \n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2407699"}, {"introduction": "A stable scheme is a necessary, but not sufficient, condition for an accurate one. For wave propagation problems, a common source of error is numerical dispersion, where the numerical wave travels at a speed slightly different from the true physical speed, leading to a phase error that accumulates over time. This practice moves beyond simple stability to quantify this specific type of error, challenging you to not only implement the Lax-Wendroff scheme but also to analyze its output by fitting it to a model to precisely measure the phase lag [@problem_id:2407698]. This provides a deeper insight into the scheme's accuracy and its dispersive nature.", "problem": "Consider the linear advection equation $u_t + u_x = 0$ on the periodic spatial domain $x \\in [0,1]$ with dimensionless wave speed $a=1$ and periodic boundary conditions. The initial condition is $u(x,0) = \\sin(10 \\pi x)$. The exact solution is given by the characteristic shift $u(x,t) = \\sin(10 \\pi (x - t))$. One full period in time corresponds to $T=1$, since a shift by one domain length returns the solution to itself on a periodic domain.\n\nYou are to compute a fully discrete numerical solution at time $t=T$ on a uniform grid of $N$ points with spacing $\\Delta x = 1/N$, using a time step $\\Delta t$ such that the Courant number $C = \\Delta t / \\Delta x$ equals a prescribed value and the final time $T$ is reached after an integer number of steps. Assume $N/C$ is an integer in all test cases, so that the number of steps $n_{\\text{steps}} = N/C$ and the time step $\\Delta t = T / n_{\\text{steps}}$. Advance the solution from $t=0$ to $t=T$ with periodic boundary conditions using a second-order accurate explicit method that is consistent with the Taylor expansion in time to second order for the conservation law $u_t + u_x = 0$.\n\nAfter obtaining the numerical solution $u_j^{\\text{num}}$ at the grid points $x_j = j \\Delta x$ for $j=0,1,\\dots,N-1$ at $t=T$, quantify the phase error by fitting a phase shift $\\varphi \\in (-\\pi,\\pi]$ so that $u_j^{\\text{num}}$ is best approximated in the least-squares sense by a shifted sinusoid of the form $A \\sin(10 \\pi x_j - \\varphi)$ with a freely varying amplitude $A \\in \\mathbb{R}$. Formally, define the phase error $\\varphi^\\star$ as any minimizer of\n$$\n\\min_{\\varphi \\in (-\\pi,\\pi],\\, A \\in \\mathbb{R}} \\sum_{j=0}^{N-1} \\left[u_j^{\\text{num}} - A \\sin(10 \\pi x_j - \\varphi)\\right]^2.\n$$\nReport the phase error $\\varphi^\\star$ in radians. Each reported phase error must be rounded to eight decimal places.\n\nUse the following test suite of parameter pairs $(N,C)$:\n- $(N,C) = (200, 0.5)$,\n- $(N,C) = (100, 1.0)$,\n- $(N,C) = (20, 0.8)$,\n- $(N,C) = (90, 0.9)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite, for example $[\\varphi_1,\\varphi_2,\\varphi_3,\\varphi_4]$, where each $\\varphi_i$ is the rounded phase error in radians as specified above.", "solution": "The problem presented is a standard exercise in computational physics: to quantify the numerical error of a finite difference scheme for the linear advection equation. The problem is well-posed, scientifically grounded, and contains all necessary information for its unique resolution. I will proceed with the solution.\n\nThe governing partial differential equation (PDE) is the linear advection equation with a constant wave speed $a$:\n$$ \\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0 $$\nThe problem specifies a dimensionless wave speed $a=1$, a periodic spatial domain $x \\in [0,1]$, and an initial condition $u(x,0) = \\sin(10 \\pi x)$. The final time for integration is $T=1$, which corresponds to one full period for a wave to traverse the domain length of $1$. At this time, the exact solution $u(x,t) = \\sin(10 \\pi (x-at))$ returns to its initial state:\n$$ u(x,T) = u(x,1) = \\sin(10 \\pi (x-1)) = \\sin(10 \\pi x - 10 \\pi) = \\sin(10 \\pi x) $$\nThus, the exact solution at $t=T$ has a phase shift of $0$ relative to the initial condition. Any phase shift observed in the numerical solution represents the accumulated phase error of the scheme.\n\nThe problem requires a second-order accurate explicit method derived from a Taylor expansion. The canonical choice is the Lax-Wendroff scheme. We begin with the Taylor series for $u(x, t+\\Delta t)$:\n$$ u(x, t+\\Delta t) = u(x,t) + \\Delta t \\frac{\\partial u}{\\partial t} + \\frac{(\\Delta t)^2}{2} \\frac{\\partial^2 u}{\\partial t^2} + \\mathcal{O}((\\Delta t)^3) $$\nFrom the PDE, we have $\\frac{\\partial u}{\\partial t} = -a \\frac{\\partial u}{\\partial x}$. Differentiating with respect to time gives the second time derivative, assuming sufficient smoothness:\n$$ \\frac{\\partial^2 u}{\\partial t^2} = \\frac{\\partial}{\\partial t}\\left(-a \\frac{\\partial u}{\\partial x}\\right) = -a \\frac{\\partial}{\\partial x}\\left(\\frac{\\partial u}{\\partial t}\\right) = -a \\frac{\\partial}{\\partial x}\\left(-a \\frac{\\partial u}{\\partial x}\\right) = a^2 \\frac{\\partial^2 u}{\\partial x^2} $$\nSubstituting these into the Taylor expansion yields a semi-discrete scheme:\n$$ u(x, t+\\Delta t) = u(x,t) - a \\Delta t \\frac{\\partial u}{\\partial x} + \\frac{a^2 (\\Delta t)^2}{2} \\frac{\\partial^2 u}{\\partial x^2} + \\mathcal{O}((\\Delta t)^3) $$\nTo obtain a fully discrete scheme, we introduce a uniform grid $x_j = j \\Delta x$ and time levels $t_n = n \\Delta t$. Let $u_j^n \\approx u(x_j, t_n)$. We approximate the spatial derivatives using second-order central finite differences:\n$$ \\frac{\\partial u}{\\partial x}\\bigg|_{x_j, t_n} \\approx \\frac{u_{j+1}^n - u_{j-1}^n}{2 \\Delta x} $$\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j, t_n} \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} $$\nSubstituting these approximations yields the explicit update rule for $u_j^{n+1}$:\n$$ u_j^{n+1} = u_j^n - a \\Delta t \\left( \\frac{u_{j+1}^n - u_{j-1}^n}{2 \\Delta x} \\right) + \\frac{a^2 (\\Delta t)^2}{2} \\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} \\right) $$\nIntroducing the Courant number $C = a \\Delta t / \\Delta x$ (with $a=1$ for this problem, so $C = \\Delta t / \\Delta x$), we can rearrange the scheme by collecting terms for $u_{j-1}^n$, $u_j^n$, and $u_{j+1}^n$:\n$$ u_j^{n+1} = u_j^n - \\frac{C}{2} (u_{j+1}^n - u_{j-1}^n) + \\frac{C^2}{2} (u_{j+1}^n - 2u_j^n + u_{j-1}^n) $$\n$$ u_j^{n+1} = \\left(\\frac{C^2}{2} + \\frac{C}{2}\\right) u_{j-1}^n + (1 - C^2) u_j^n + \\left(\\frac{C^2}{2} - \\frac{C}{2}\\right) u_{j+1}^n $$\nThis is the Lax-Wendroff scheme. It is an explicit, three-point stencil, second-order accurate in both space and time, and is von Neumann stable for $|C| \\le 1$. The periodic boundary conditions are enforced by setting $u_{-1}^n = u_{N-1}^n$ and $u_N^n = u_0^n$ at each time step.\n\nAfter advancing the solution from $t=0$ to $t=T$ using $n_{\\text{steps}}=T/\\Delta t = N/C$ steps, we obtain the numerical solution $u_j^{\\text{num}}$ at grid points $x_j$. The final step is to quantify the phase error by fitting this numerical data to a model of the form $f(x_j; A, \\varphi) = A \\sin(k x_j - \\varphi)$, where $k=10\\pi$. We must find the parameters $A$ and $\\varphi$ that minimize the sum of squared residuals:\n$$ \\min_{\\varphi \\in (-\\pi,\\pi],\\, A \\in \\mathbb{R}} \\sum_{j=0}^{N-1} \\left[u_j^{\\text{num}} - A \\sin(k x_j - \\varphi)\\right]^2 $$\nThis non-linear-in-$\\varphi$ least-squares problem can be linearized. Using the trigonometric identity $\\sin(\\alpha - \\beta) = \\sin\\alpha \\cos\\beta - \\cos\\alpha \\sin\\beta$, the model function can be rewritten as:\n$$ A \\sin(k x_j - \\varphi) = (A \\cos\\varphi) \\sin(k x_j) - (A \\sin\\varphi) \\cos(k x_j) $$\nWe define new linear coefficients $c_1 = A \\cos\\varphi$ and $c_2 = -A \\sin\\varphi$. The model becomes linear in these coefficients: $f(x_j) = c_1 \\sin(k x_j) + c_2 \\cos(k x_j)$. The task is now a standard linear least-squares problem:\n$$ \\min_{c_1, c_2} \\sum_{j=0}^{N-1} \\left[u_j^{\\text{num}} - \\left(c_1 \\sin(k x_j) + c_2 \\cos(k x_j)\\right)\\right]^2 $$\nLet the basis vectors be $S_j = \\sin(k x_j)$ and $C_j = \\cos(k x_j)$. The solution for the coefficients $(c_1, c_2)$ is given by the normal equations:\n$$ \\begin{pmatrix} \\sum S_j^2  \\sum S_j C_j \\\\ \\sum S_j C_j  \\sum C_j^2 \\end{pmatrix} \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix} = \\begin{pmatrix} \\sum u_j^{\\text{num}} S_j \\\\ \\sum u_j^{\\text{num}} C_j \\end{pmatrix} $$\nThis $2 \\times 2$ system is solved for $c_1$ and $c_2$. The phase $\\varphi$ is then recovered from the definitions of $c_1$ and $c_2$:\n$$ \\tan\\varphi = \\frac{\\sin\\varphi}{\\cos\\varphi} = \\frac{-c_2/A}{c_1/A} = \\frac{-c_2}{c_1} $$\nThe phase error $\\varphi^\\star$ is uniquely determined in the interval $(-\\pi, \\pi]$ using the two-argument arctangent function:\n$$ \\varphi^\\star = \\operatorname{atan2}(-c_2, c_1) $$\nThis value $\\varphi^\\star$ represents the phase lag or lead of the numerical solution relative to the exact solution at $t=T$, and is the quantity to be reported. A positive value indicates a phase lag (numerical wave is slower). For the specific case $C=1$, the Lax-Wendroff scheme is exact on the grid, yielding $u_j^{n+1} = u_{j-1}^n$, which after $n_{\\text{steps}} = N$ steps results in $u_j^{\\text{final}} = u_{j-N}^0 = u_j^0$. In this case, the phase error must be exactly zero.\nThe entire procedure is implemented computationally for each given pair of parameters $(N, C)$.", "answer": "```python\nimport numpy as np\n\ndef run_lax_wendroff(N, C):\n    \"\"\"\n    Solves the linear advection equation u_t + u_x = 0 on a periodic\n    domain [0,1] using the Lax-Wendroff scheme.\n\n    Args:\n        N (int): Number of grid points.\n        C (float): Courant number.\n\n    Returns:\n        numpy.ndarray: The numerical solution at the final time T=1.\n    \"\"\"\n    # Parameters definition\n    T_final = 1.0\n    wave_number = 10.0 * np.pi\n    \n    # Spatial grid setup\n    dx = 1.0 / N\n    x_grid = np.arange(N) * dx\n    \n    # Initial condition\n    u0 = np.sin(wave_number * x_grid)\n    \n    # Time stepping setup\n    # The problem statement guarantees N/C is an integer.\n    num_steps = int(round(N / C))\n    \n    # Pre-calculate Lax-Wendroff coefficients\n    # u_j^{n+1} = coeff_jm1 * u_{j-1} + coeff_j * u_j + coeff_jp1 * u_{j+1}\n    courant_sq = C * C\n    coeff_jm1 = 0.5 * (courant_sq + C)  # Coefficient for u_{j-1}\n    coeff_j = 1.0 - courant_sq           # Coefficient for u_j\n    coeff_jp1 = 0.5 * (courant_sq - C)  # Coefficient for u_{j+1}\n    \n    u = u0.copy()\n    \n    # Time-marching loop\n    for _ in range(num_steps):\n        # Periodic boundary conditions are handled by np.roll\n        u_jm1 = np.roll(u, 1)\n        u_jp1 = np.roll(u, -1)\n        \n        u = coeff_jm1 * u_jm1 + coeff_j * u + coeff_jp1 * u_jp1\n        \n    return u\n\ndef calculate_phase_error(u_final, N):\n    \"\"\"\n    Calculates the phase error by fitting the numerical solution to the model\n    A * sin(k*x - phi) using linear least-squares.\n\n    Args:\n        u_final (numpy.ndarray): The numerical solution at the final time.\n        N (int): Number of grid points.\n\n    Returns:\n        float: The calculated phase error phi in radians.\n    \"\"\"\n    # Define basis functions for the least-squares fit\n    wave_number = 10.0 * np.pi\n    dx = 1.0 / N\n    x_grid = np.arange(N) * dx\n    \n    # Model: c1*sin(k*x) + c2*cos(k*x)\n    S_basis = np.sin(wave_number * x_grid)\n    C_basis = np.cos(wave_number * x_grid)\n\n    # Set up and solve the normal equations: (M^T * M) * c = M^T * u\n    # where M = [S_basis, C_basis], c = [c1, c2]^T, u = u_final\n    \n    # M^T * M matrix components\n    S2 = np.dot(S_basis, S_basis)\n    C2 = np.dot(C_basis, C_basis)\n    SC = np.dot(S_basis, C_basis)\n    \n    M_T_M = np.array([[S2, SC], \n                      [SC, C2]])\n                      \n    # M^T * u vector components\n    uS = np.dot(u_final, S_basis)\n    uC = np.dot(u_final, C_basis)\n    \n    M_T_u = np.array([uS, uC])\n    \n    # Solve for coefficients c1, c2\n    # c1 = A*cos(phi), c2 = -A*sin(phi)\n    try:\n        c1, c2 = np.linalg.solve(M_T_M, M_T_u)\n    except np.linalg.LinAlgError:\n        # This is unlikely to happen with sine and cosine bases\n        return np.nan\n\n    # Recover the phase phi from the coefficients\n    # phi = atan2(-c2, c1)\n    phase_error = np.arctan2(-c2, c1)\n    \n    return phase_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (200, 0.5),\n        (100, 1.0),\n        (20, 0.8),\n        (90, 0.9),\n    ]\n\n    results = []\n    for N, C in test_cases:\n        # Run the numerical simulation\n        u_final = run_lax_wendroff(N, C)\n        \n        # Calculate the phase error from the final state\n        phase_err = calculate_phase_error(u_final, N)\n        \n        results.append(phase_err)\n\n    # Format and print the final results as specified.\n    formatted_results = \",\".join([f\"{r:.8f}\" for r in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "2407698"}, {"introduction": "Beyond quantitative errors like dispersion, a numerical scheme's qualitative behavior is also critical, especially when modeling physical quantities like density or concentration that cannot be negative. The Lax-Wendroff scheme, as a higher-order linear method, is known to produce spurious oscillations near sharp gradients or discontinuities, a phenomenon related to Godunov's theorem. This final practice confronts this issue head-on, investigating whether these oscillations can lead to unphysical, negative values for a quantity that must remain positive, highlighting a key limitation of the scheme and introducing the important concept of positivity-preservation [@problem_id:2407736].", "problem": "Consider the one-dimensional linear advection of a nonnegative scalar number density $n(x,t)$ with constant speed $a0$ on a periodic domain of length $L$, governed by the conservation law\n$$\n\\partial_t n(x,t) + a\\,\\partial_x n(x,t) = 0,\\quad x\\in[0,L],\\ t\\ge 0,\n$$\nwith periodic boundary conditions and a uniform spatial discretization. The exact solution preserves nonnegativity: if $n(x,0)\\ge 0$ for all $x$, then $n(x,t)\\ge 0$ for all $t\\ge 0$. You are to compute a fully discrete numerical solution on a uniform grid using an explicit, second-order accurate method in both space and time on a periodic mesh. The mesh consists of $N$ grid points with spacing $\\Delta x = L/N$ and nodes $x_j = j\\,\\Delta x$ for $j=0,1,\\dots,N-1$. Use a uniform time step $\\Delta t$ defined by the Courant–Friedrichs–Lewy (CFL) number $c = a\\,\\Delta t/\\Delta x$, with $c\\in(0,1]$, and advance the solution for as many whole time steps $K=\\lfloor T/\\Delta t\\rfloor$ as do not exceed the target time $T$.\n\nYour program must, for each specified test case, evolve the discrete solution starting from the given nonnegative initial data and detect whether the numerical solution ever attains a value less than a small negative threshold at any grid point during the evolution up to time $T$. To avoid false positives due to floating-point roundoff, declare that an unphysical negative value has occurred if and only if $\\min_j n_j^m  -\\varepsilon$ for some time step $m\\in\\{0,1,\\dots,K\\}$, with tolerance $\\varepsilon = 10^{-12}$, where $n_j^m$ denotes the discrete solution at grid node $x_j$ and time level $t^m=m\\,\\Delta t$.\n\nUse nondimensional units (no physical units are required). Angles are not involved. All parameter values below are nondimensional. The domain is periodic on $[0,L]$ in every test.\n\nTest suite (each item lists $(L,a,N,c,T,\\text{initial profile})$):\n- Case A (smooth profile, “happy path”): $(L,a,N,c,T) = (1.0,\\,1.0,\\,400,\\,0.5,\\,1.0)$. Initial condition: $n(x,0) = \\exp\\!\\left(-\\left(\\dfrac{x-0.3}{0.05}\\right)^2\\right)$ for $x\\in[0,L)$.\n- Case B (single discontinuity pair, near-Courant-boundary): $(L,a,N,c,T) = (1.0,\\,1.0,\\,400,\\,0.9,\\,0.2)$. Initial condition: $n(x,0) = 1$ for $x\\in[0.25,0.55]$ and $n(x,0)=0$ otherwise on $[0,L)$.\n- Case C (multiple discontinuities, coarser grid): $(L,a,N,c,T) = (1.0,\\,1.0,\\,200,\\,0.5,\\,0.2)$. Initial condition: $n(x,0) = 1$ on the union $[0.10,0.20]\\cup[0.60,0.80]$ and $n(x,0)=0$ otherwise on $[0,L)$.\n\nYour program must compute, for each case, a boolean indicator of whether any unphysical negative value (as defined by the threshold $\\varepsilon$) is observed at any grid point during the time stepping from $t=0$ to $t=K\\,\\Delta t$. The final output must be a single line containing the three results in order for Cases A, B, and C, formatted as a comma-separated list of integers enclosed in square brackets, where each entry equals $1$ if an unphysical negative value was detected for that case, and equals $0$ otherwise. For example, the required output format is $[x_1,x_2,x_3]$ with $x_i\\in\\{0,1\\}$.", "solution": "The problem presented is a well-posed exercise in computational physics. It asks for the implementation of a specific class of numerical methods to solve the one-dimensional linear advection equation and to test a fundamental property of the numerical solution: the preservation of non-negativity.\n\nThe governing equation is the linear advection equation for a scalar density $n(x,t)$ with a constant, positive wave speed $a$:\n$$\n\\partial_t n + a\\,\\partial_x n = 0\n$$\nThe problem requires a numerical scheme that is explicit and second-order accurate in both time and space. The canonical method satisfying these properties for this equation is the Lax-Wendroff scheme. We will derive this scheme and use it to solve the problem.\n\nWe begin with a Taylor series expansion of the solution $n(x, t+\\Delta t)$ in time around $t$:\n$$\nn(x, t+\\Delta t) = n(x,t) + \\Delta t \\frac{\\partial n}{\\partial t} + \\frac{(\\Delta t)^2}{2} \\frac{\\partial^2 n}{\\partial t^2} + O((\\Delta t)^3)\n$$\nTo achieve second-order accuracy in time, we must approximate the time derivatives using the governing PDE. The first time derivative is given directly by the PDE:\n$$\n\\frac{\\partial n}{\\partial t} = -a \\frac{\\partial n}{\\partial x}\n$$\nThe second time derivative is found by differentiating the PDE with respect to time and substituting back:\n$$\n\\frac{\\partial^2 n}{\\partial t^2} = \\frac{\\partial}{\\partial t}\\left(-a \\frac{\\partial n}{\\partial x}\\right) = -a \\frac{\\partial}{\\partial x}\\left(\\frac{\\partial n}{\\partial t}\\right) = -a \\frac{\\partial}{\\partial x}\\left(-a \\frac{\\partial n}{\\partial x}\\right) = a^2 \\frac{\\partial^2 n}{\\partial x^2}\n$$\nSubstituting these expressions back into the Taylor expansion yields a semi-discretized equation, accurate to second order in $\\Delta t$:\n$$\nn(x, t+\\Delta t) = n(x,t) - a \\Delta t \\frac{\\partial n}{\\partial x} + \\frac{(a \\Delta t)^2}{2} \\frac{\\partial^2 n}{\\partial x^2} + O((\\Delta t)^3)\n$$\nTo create a fully discrete scheme, we discretize the spatial domain with grid points $x_j = j\\Delta x$ and approximate the solution at these points at time $t^m=m\\Delta t$ by $n_j^m \\approx n(x_j, t^m)$. We replace the spatial derivatives with second-order accurate central finite differences:\n$$\n\\left.\\frac{\\partial n}{\\partial x}\\right|_{x_j} \\approx \\frac{n_{j+1}^m - n_{j-1}^m}{2\\Delta x}\n$$\n$$\n\\left.\\frac{\\partial^2 n}{\\partial x^2}\\right|_{x_j} \\approx \\frac{n_{j+1}^m - 2n_j^m + n_{j-1}^m}{(\\Delta x)^2}\n$$\nSubstituting these finite differences into the semi-discretized equation gives the explicit update rule for $n_j^{m+1}$:\n$$\nn_j^{m+1} = n_j^m - a \\Delta t \\left( \\frac{n_{j+1}^m - n_{j-1}^m}{2\\Delta x} \\right) + \\frac{(a \\Delta t)^2}{2} \\left( \\frac{n_{j+1}^m - 2n_j^m + n_{j-1}^m}{(\\Delta x)^2} \\right)\n$$\nIntroducing the non-dimensional Courant–Friedrichs–Lewy (CFL) number, $c = a\\Delta t/\\Delta x$, we can simplify the expression:\n$$\nn_j^{m+1} = n_j^m - \\frac{c}{2} (n_{j+1}^m - n_{j-1}^m) + \\frac{c^2}{2} (n_{j+1}^m - 2n_j^m + n_{j-1}^m)\n$$\nGrouping terms by their spatial index at the current time level $m$:\n$$\nn_j^{m+1} = \\left( \\frac{c^2}{2} + \\frac{c}{2} \\right) n_{j-1}^m + (1 - c^2) n_j^m + \\left( \\frac{c^2}{2} - \\frac{c}{2} \\right) n_{j+1}^m\n$$\nThis is the Lax-Wendroff scheme. For the scheme to be positivity-preserving (i.e., guarantee $n_j^{m+1} \\ge 0$ if all $n_k^m \\ge 0$), all coefficients in the stencil must be non-negative. We analyze the coefficients for the stability range $c \\in (0,1]$:\n- Coefficient of $n_{j-1}^m$: $\\frac{c(c+1)}{2}$. This is non-negative for $c \\ge 0$.\n- Coefficient of $n_j^m$: $1 - c^2$. This is non-negative for $c \\le 1$.\n- Coefficient of $n_{j+1}^m$: $\\frac{c(c-1)}{2}$. This is non-positive for $c \\in [0,1]$.\n\nThe coefficient of $n_{j+1}^m$ is negative for any $c \\in (0,1)$. This means the Lax-Wendroff scheme is not positivity-preserving in general. It is a non-monotone scheme that can introduce spurious oscillations (undershoots and overshoots) around sharp gradients or discontinuities in the solution. This is a manifestation of Godunov's theorem, which states that no linear numerical scheme for conservation laws with order of accuracy greater than one can be monotonicity-preserving. We therefore expect to observe negative values when the initial condition contains discontinuities, as in Cases B and C. For a smooth initial condition like the Gaussian in Case A, any oscillations should be much smaller, and may not fall below the specified negative threshold $\\varepsilon = 10^{-12}$.\n\nThe algorithm to solve the problem is as follows:\n1. For each test case, define parameters $L, a, N, c, T$.\n2. Compute the grid spacing $\\Delta x = L/N$, the time step $\\Delta t = c \\Delta x / a$, and the total number of time steps $K = \\lfloor T/\\Delta t \\rfloor$.\n3. Create a uniform spatial grid $x_j = j\\Delta x$ for $j=0, \\dots, N-1$.\n4. Initialize the discrete solution array $n^0$ according to the specified initial condition for the case.\n5. Set a flag `negative_detected = 0`.\n6. Iterate from time step $m=0$ to $K-1$:\n   a. Compute the solution at the next time step, $n^{m+1}$, using the Lax-Wendroff formula. Periodic boundary conditions are enforced by treating the grid indices cyclically (e.g., $n_{-1}^m \\equiv n_{N-1}^m$ and $n_N^m \\equiv n_0^m$).\n   b. After computing the new array $n^{m+1}$, find its minimum value, $\\min_j n_j^{m+1}$.\n   c. If this minimum is less than $-\\varepsilon = -10^{-12}$, set `negative_detected = 1` and terminate the time-stepping for this case.\n   d. Update the solution array for the next iteration.\n7. Record the final value of `negative_detected` for the case.\n8. After processing all cases, report the results as a list of these flags.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using the Lax-Wendroff scheme\n    and detects the occurrence of unphysical negative values.\n    \"\"\"\n\n    # Define the tolerance for detecting negative values.\n    epsilon = 1.0e-12\n\n    def run_simulation(L, a, N, c, T, initial_profile_func):\n        \"\"\"\n        Runs a single simulation case.\n\n        Returns:\n            int: 1 if a negative value below the threshold is detected, 0 otherwise.\n        \"\"\"\n        # Grid and time step parameters\n        dx = L / N\n        dt = c * dx / a\n        num_steps = int(T // dt)\n\n        # Spatial grid (uniform and periodic)\n        # x corresponds to nodes x_j = j*dx for j=0, ..., N-1\n        x = np.linspace(0, L, N, endpoint=False)\n\n        # Initialize the solution array n from the initial condition\n        n = initial_profile_func(x)\n\n        # Lax-Wendroff coefficients\n        # n_j^{m+1} = c_j-1 * n_{j-1}^m + c_j * n_j^m + c_j+1 * n_{j+1}^m\n        # Note: np.roll(n, 1) corresponds to n_{j-1}\n        #       np.roll(n, -1) corresponds to n_{j+1}\n        c_j_minus_1 = c * (c + 1.0) / 2.0\n        c_j = 1.0 - c**2\n        c_j_plus_1 = c * (c - 1.0) / 2.0\n        \n        # Check initial state (t=0)\n        if np.min(n)  -epsilon:\n            return 1\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            # Apply the Lax-Wendroff update rule\n            # np.roll handles periodic boundary conditions efficiently\n            n_new = (c_j_minus_1 * np.roll(n, 1) +\n                     c_j * n +\n                     c_j_plus_1 * np.roll(n, -1))\n            \n            n = n_new\n            \n            # Check for unphysical negative values\n            if np.min(n)  -epsilon:\n                return 1\n\n        return 0\n\n    # Define test cases based on the problem statement\n    test_cases = [\n        # Case A: Smooth Gaussian profile\n        {\n            \"L\": 1.0, \"a\": 1.0, \"N\": 400, \"c\": 0.5, \"T\": 1.0,\n            \"initial_profile_func\": lambda x: np.exp(-((x - 0.3) / 0.05)**2)\n        },\n        # Case B: Single discontinuity pair (square pulse)\n        {\n            \"L\": 1.0, \"a\": 1.0, \"N\": 400, \"c\": 0.9, \"T\": 0.2,\n            \"initial_profile_func\": lambda x: np.where((x = 0.25)  (x  0.55), 1.0, 0.0)\n        },\n        # Case C: Multiple discontinuities, coarser grid\n        {\n            \"L\": 1.0, \"a\": 1.0, \"N\": 200, \"c\": 0.5, \"T\": 0.2,\n            \"initial_profile_func\": lambda x: np.where(\n                ((x = 0.10)  (x  0.20)) | ((x = 0.60)  (x  0.80)), 1.0, 0.0\n            )\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(\n            case[\"L\"], case[\"a\"], case[\"N\"], case[\"c\"], case[\"T\"], case[\"initial_profile_func\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2407736"}]}