{"hands_on_practices": [{"introduction": "The Poisson equation is a cornerstone of computational physics, modeling phenomena from electrostatics to gravitation. This first practice focuses on a fundamental skill: verifying the accuracy of numerical methods. By implementing and comparing the standard 5-point stencil with a higher-order 9-point stencil [@problem_id:2393516], you will gain direct experience with how the choice of discretization impacts convergence speed and learn the formal procedure for calculating the observed order of accuracy from numerical experiments.", "problem": "Consider the two-dimensional Poisson equation on the unit square domain with homogeneous Dirichlet boundary condition. Let the open domain be $\\Omega = (0,1)\\times(0,1)$ and the boundary be $\\partial\\Omega$. Define the exact solution by $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$ for $(x,y)\\in \\overline{\\Omega}$, which is analytic and non-polynomial. The source term is determined from the governing equation $-\\Delta u = f$ in $\\Omega$, with $u = 0$ on $\\partial\\Omega$. \n\na) Derive $f(x,y)$ in closed form from the definition of $u(x,y)$ and the equality $-\\Delta u = f$.\n\nb) For a uniform Cartesian grid with $m$ equal subdivisions per coordinate direction, define the grid spacing $h = 1/m$ and grid nodes $(x_i,y_j) = (i h, j h)$ for $i,j\\in\\{0,1,\\dots,m\\}$. Impose the boundary values by the Dirichlet condition $u(x,y)=0$ on $\\partial\\Omega$, which holds for the exact $u$. For interior nodes, form the discrete linear system corresponding to $-\\Delta u = f$ using both of the following discrete operators for $-\\Delta$ at an interior node $(i,j)$:\n- The standard second-order $5$-point stencil,\n$$\\left(-\\Delta_h^{(5)} u\\right)_{i,j} \\equiv \\frac{1}{h^2}\\left(4\\,u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\\right).$$\n- The classical fourth-order $9$-point stencil,\n$$\\left(-\\Delta_h^{(9)} u\\right)_{i,j} \\equiv \\frac{1}{6h^2}\\Big(20\\,u_{i,j} - 4\\left(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\right) - \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right)\\Big).$$\n\nc) For each chosen $m$, let $u_h^{(5)}$ and $u_h^{(9)}$ denote the numerical solutions on the grid obtained by solving the respective discrete systems with the right-hand side set to $f(x_i,y_j)$ at interior nodes. Construct the full grid function by setting boundary values to the exact $u(x_i,y_j)$ and interior values to the corresponding numerical solution. Define the discrete root-mean-square error (a discrete $L^2$ approximation) for a grid function $w$ relative to the exact $u$ by\n$$E(h; w) = \\left(h^2 \\sum_{i=0}^{m}\\sum_{j=0}^{m} \\left(w_{i,j} - u(x_i,y_j)\\right)^2\\right)^{1/2}.$$\nLet $E^{(5)}(h)$ and $E^{(9)}(h)$ denote these errors for the $5$-point and $9$-point solutions, respectively.\n\nd) For each consecutive pair of grid spacings $(h, h/2)$, define the observed base-$2$ convergence rates by\n$$p^{(5)}(h\\to h/2) = \\log_2\\left(\\frac{E^{(5)}(h)}{E^{(5)}(h/2)}\\right),\\qquad p^{(9)}(h\\to h/2) = \\log_2\\left(\\frac{E^{(9)}(h)}{E^{(9)}(h/2)}\\right).$$\n\nUse the following test suite of subdivision counts: $m\\in\\{2,4,8,16\\}$. For each $m$, use the definition of $u$ to compute $f$ and enforce the boundary condition $u=0$ on $\\partial\\Omega$. For the pairwise refinements $(m,m') = (2,4)$, $(4,8)$, and $(8,16)$, compute the corresponding observed convergence rates.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order:\n$[E^{(5)}(1/2), E^{(9)}(1/2), p^{(5)}(1/2\\to 1/4), p^{(9)}(1/2\\to 1/4), p^{(5)}(1/4\\to 1/8), p^{(9)}(1/4\\to 1/8), p^{(5)}(1/8\\to 1/16), p^{(9)}(1/8\\to 1/16)]$.\n\nAll numerical values must be reported as floating-point numbers. No physical units are involved. Angles, if any appear, must be in radians. The final output format must match the specification exactly: a single line with the list in square brackets and values separated by commas.", "solution": "The problem statement is subjected to rigorous validation.\n\nStep 1: Extracted Givens\n-   **Governing Equation**: The two-dimensional Poisson equation $-\\Delta u = f$ on the open unit square domain $\\Omega = (0,1)\\times(0,1)$.\n-   **Boundary Condition (BC)**: Homogeneous Dirichlet boundary condition, $u = 0$ on the boundary $\\partial\\Omega$.\n-   **Exact Solution**: $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$ for $(x,y)\\in \\overline{\\Omega} = [0,1]\\times[0,1]$.\n-   **Source Term**: Defined by the equality $f = -\\Delta u$.\n-   **Discretization**: A uniform Cartesian grid with $m$ subdivisions in each direction, resulting in grid spacing $h = 1/m$ and nodes $(x_i,y_j) = (ih, jh)$ for $i,j\\in\\{0,1,\\dots,m\\}$.\n-   **Discrete Operators**:\n    -   Standard second-order $5$-point stencil for the negative Laplacian: $\\left(-\\Delta_h^{(5)} u\\right)_{i,j} \\equiv \\frac{1}{h^2}\\left(4\\,u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\\right)$.\n    -   Classical fourth-order $9$-point stencil for the negative Laplacian: $\\left(-\\Delta_h^{(9)} u\\right)_{i,j} \\equiv \\frac{1}{6h^2}\\Big(20\\,u_{i,j} - 4\\left(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\right) - \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right)\\Big)$.\n-   **Numerical Solution**: $u_h^{(5)}$ and $u_h^{(9)}$ are solutions to the discrete linear systems arising from the stencils. The right-hand side is $f(x_i,y_j)$ at interior nodes. Boundary values are set to $u(x_i,y_j)=0$.\n-   **Error Metric**: Discrete root-mean-square error $E(h; w) = \\left(h^2 \\sum_{i=0}^{m}\\sum_{j=0}^{m} \\left(w_{i,j} - u(x_i,y_j)\\right)^2\\right)^{1/2}$.\n-   **Convergence Rate**: Observed base-$2$ rate $p(h\\to h/2) = \\log_2\\left(\\frac{E(h)}{E(h/2)}\\right)$.\n-   **Test Parameters**: Subdivision counts $m\\in\\{2,4,8,16\\}$.\n-   **Required Output**: A list of numerical values: $[E^{(5)}(1/2), E^{(9)}(1/2), p^{(5)}(1/2\\to 1/4), p^{(9)}(1/2\\to 1/4), p^{(5)}(1/4\\to 1/8), p^{(9)}(1/4\\to 1/8), p^{(5)}(1/8\\to 1/16), p^{(9)}(1/8\\to 1/16)]$.\n\nStep 2: Validation Using Extracted Givens\nThe problem is a standard exercise in the numerical analysis of partial differential equations, specifically the application of finite difference methods to the Poisson equation.\n-   **Scientifically Grounded**: The problem is based on established mathematical principles of numerical analysis and PDEs. The Poisson equation, finite difference stencils, and convergence analysis are all fundamental, well-understood concepts.\n-   **Well-Posed**: The Poisson equation with Dirichlet boundary conditions is a classic example of a well-posed elliptic problem. The resulting discrete linear systems for both stencils correspond to symmetric positive-definite matrices, guaranteeing unique solutions.\n-   **Objective**: The problem is stated in precise, objective mathematical language.\n-   **Consistency Check**: The prescribed exact solution $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$ correctly satisfies the homogeneous Dirichlet boundary condition $u=0$ on $\\partial\\Omega$, since $\\sin(\\pi x) = 0$ for $x=0,1$ and $\\sin(\\pi y)=0$ for $y=0,1$.\n-   **Completeness**: All necessary information to formulate and solve the problem is provided.\n\nStep 3: Verdict and Action\nThe problem is valid. It is scientifically sound, well-posed, and self-contained. A complete solution will be provided.\n\n**Part a) Derivation of the Source Term $f(x,y)$**\n\nThe source term $f(x,y)$ is determined by the relation $f = -\\Delta u = -(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2})$. We compute the second partial derivatives of the exact solution $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$.\n\nFirst, the partial derivative with respect to $x$:\n$$ \\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y) \\right) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y) + \\pi \\mathrm{e}^{x+y}\\cos(\\pi x)\\sin(\\pi y) $$\nThe second partial derivative with respect to $x$:\n$$ \\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial}{\\partial x} \\left( \\mathrm{e}^{x+y}(\\sin(\\pi x) + \\pi\\cos(\\pi x))\\sin(\\pi y) \\right) \\\\ = \\mathrm{e}^{x+y}(\\sin(\\pi x) + \\pi\\cos(\\pi x))\\sin(\\pi y) + \\mathrm{e}^{x+y}(\\pi\\cos(\\pi x) - \\pi^2\\sin(\\pi x))\\sin(\\pi y) \\\\ = \\mathrm{e}^{x+y}\\sin(\\pi y) \\left[ (1-\\pi^2)\\sin(\\pi x) + 2\\pi\\cos(\\pi x) \\right] $$\nDue to the symmetry of $u(x,y)$ with respect to interchange of $x$ and $y$, the second partial derivative with respect to $y$ is analogous:\n$$ \\frac{\\partial^2 u}{\\partial y^2} = \\mathrm{e}^{x+y}\\sin(\\pi x) \\left[ (1-\\pi^2)\\sin(\\pi y) + 2\\pi\\cos(\\pi y) \\right] $$\nThe Laplacian $\\Delta u$ is the sum of these second derivatives:\n$$ \\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = \\mathrm{e}^{x+y} \\left[ 2(1-\\pi^2)\\sin(\\pi x)\\sin(\\pi y) + 2\\pi(\\cos(\\pi x)\\sin(\\pi y) + \\sin(\\pi x)\\cos(\\pi y)) \\right] $$\nFinally, the source term is $f(x,y) = -\\Delta u$:\n$$ f(x,y) = \\mathrm{e}^{x+y} \\left[ 2(\\pi^2-1)\\sin(\\pi x)\\sin(\\pi y) - 2\\pi(\\cos(\\pi x)\\sin(\\pi y) + \\sin(\\pi x)\\cos(\\pi y)) \\right] $$\nThis is the closed-form expression required.\n\n**Part b, c, d) Numerical Solution and Analysis**\n\nThe problem requires solving the linear system $A \\mathbf{u}_h = \\mathbf{b}$ for the unknown values of the numerical solution at the $(m-1)^2$ interior grid points. The vector $\\mathbf{u}_h$ contains the values $u_{i,j}$ for $i,j \\in \\{1, \\dots, m-1\\}$, arranged in lexicographical (column-major) order. The matrix $A$ represents the discrete negative Laplacian operator, and the vector $\\mathbf{b}$ contains the values of the source term $f(x_i, y_j)$ at the interior points.\n\nFor the $5$-point stencil, the matrix $A_5$ corresponding to $(-\\Delta_h^{(5)})$ can be constructed using Kronecker products. Let $T_{1D}$ be the $(m-1) \\times (m-1)$ matrix for the one-dimensional second derivative operator $-\\frac{d^2}{dx^2}$, given by $T_{1D} = \\frac{1}{h^2} \\text{tridiag}(-1, 2, -1)$. Let $I$ be the $(m-1) \\times (m-1)$ identity matrix. Then, the matrix for the two-dimensional operator is:\n$$ A_5 = I \\otimes T_{1D} + T_{1D} \\otimes I $$\n\nFor the $9$-point stencil, the matrix $A_9$ corresponding to $(-\\Delta_h^{(9)})$ has a block-tridiagonal structure $A_9 = \\text{block_tridiag}(B, D, B)$, where the blocks $D$ and $B$ are $(m-1) \\times (m-1)$ matrices:\n$$ D = \\frac{1}{6h^2} \\text{tridiag}(-4, 20, -4) $$\n$$ B = \\frac{1}{6h^2} \\text{tridiag}(-1, -4, -1) $$\nThis structure arises from the coefficients of the stencil coupling nodes within the same grid row (matrix $D$) and between adjacent grid rows (matrix $B$).\n\nThe numerical procedure for each $m \\in \\{2, 4, 8, 16\\}$ is as follows:\n1.  Set the grid spacing $h=1/m$ and define the grid coordinates.\n2.  Construct the sparse matrices $A_5$ and $A_9$ of size $(m-1)^2 \\times (m-1)^2$.\n3.  Construct the right-hand side vector $\\mathbf{b}$ by evaluating $f(x_i, y_j)$ at the $(m-1)^2$ interior grid points.\n4.  Solve the two linear systems $A_5 \\mathbf{u}_h^{(5)} = \\mathbf{b}$ and $A_9 \\mathbf{u}_h^{(9)} = \\mathbf{b}$ to obtain the numerical solutions at the interior points.\n5.  Form the full $(m+1) \\times (m+1)$ grid solutions $u_h^{(5)}$ and $u_h^{(9)}$ by embedding the interior solutions into a grid of zeros, which correctly represents the homogeneous boundary conditions.\n6.  Evaluate the exact solution $u(x,y)$ on the full grid.\n7.  Compute the discrete RMS errors $E^{(5)}(h)$ and $E^{(9)}(h)$ using the specified formula. These errors are stored for each value of $m$.\n8.  After computing errors for all $m$, the observed convergence rates $p^{(5)}$ and $p^{(9)}$ are calculated for each refinement level using the given logarithmic formula.\n\nThe expected convergence rates are $p \\approx 2$ for the second-order $5$-point stencil and $p \\approx 4$ for the fourth-order $9$-point stencil, as these are the theoretical orders of accuracy for the respective discretizations. The numerical experiment serves to verify this theoretical behavior.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the 2D Poisson equation on a unit square using 5-point and 9-point\n    finite difference stencils and computes errors and convergence rates.\n    \"\"\"\n    m_values = [2, 4, 8, 16]\n    errors = {'5': {}, '9': {}}\n\n    def u_exact_func(x, y):\n        \"\"\"Computes the exact solution u(x,y).\"\"\"\n        return np.exp(x + y) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def f_func(x, y):\n        \"\"\"Computes the source term f(x,y) = -Delta u.\"\"\"\n        term1 = 2 * (np.pi**2 - 1) * np.sin(np.pi * x) * np.sin(np.pi * y)\n        term2 = -2 * np.pi * (np.cos(np.pi * x) * np.sin(np.pi * y) + np.sin(np.pi * x) * np.cos(np.pi * y))\n        return np.exp(x + y) * (term1 + term2)\n\n    for m in m_values:\n        h = 1.0 / m\n        N = m - 1  # Number of interior grid points in one dimension\n\n        # Create the full grid\n        grid_pts = np.linspace(0, 1, m + 1)\n        X, Y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n\n        # Evaluate exact solution on the full grid\n        u_exact_grid = u_exact_func(X, Y)\n\n        if N == 0: # Trivial case with no interior points\n            u_sol_5 = np.zeros_like(u_exact_grid)\n            u_sol_9 = np.zeros_like(u_exact_grid)\n        else:\n            N2 = N * N # Total number of unknowns\n\n            # Interior grid points and RHS vector b\n            interior_grid_pts = np.linspace(h, 1 - h, N)\n            XI, YI = np.meshgrid(interior_grid_pts, interior_grid_pts, indexing='ij')\n            # Use Fortran ordering for flattening to match lexicographical (column-major) order\n            b = f_func(XI, YI).flatten(order='F')\n\n            # --- 5-point stencil system ---\n            # A_5 = I kron T + T kron I for -Delta\n            T_1d = sparse.diags([-1, 2, -1], [-1, 0, 1], shape=(N, N))\n            I_n = sparse.eye(N)\n            A5 = (1 / h**2) * (sparse.kron(I_n, T_1d) + sparse.kron(T_1d, I_n))\n            \n            u_sol_5_flat = spsolve(A5.tocsc(), b)\n            u_sol_5 = np.zeros_like(u_exact_grid)\n            u_sol_5[1:-1, 1:-1] = u_sol_5_flat.reshape((N, N), order='F')\n\n            # --- 9-point stencil system ---\n            # Block-tridiagonal construction A_9 = block_tridiag(B, D, B)\n            D_diag_vals = [np.full(N - 1, -4), np.full(N, 20), np.full(N - 1, -4)]\n            D = (1 / (6 * h**2)) * sparse.diags(D_diag_vals, [-1, 0, 1])\n\n            B_diag_vals = [np.full(N - 1, -1), np.full(N, -4), np.full(N - 1, -1)]\n            B = (1 / (6 * h**2)) * sparse.diags(B_diag_vals, [-1, 0, 1])\n            \n            # Off-diagonal blocks for Kronecker sum\n            off_diag_block_matrix = sparse.diags([1, 1], [-1, 1], shape=(N, N))\n            A9 = sparse.kron(I_n, D) + sparse.kron(off_diag_block_matrix, B)\n            \n            u_sol_9_flat = spsolve(A9.tocsc(), b)\n            u_sol_9 = np.zeros_like(u_exact_grid)\n            u_sol_9[1:-1, 1:-1] = u_sol_9_flat.reshape((N, N), order='F')\n\n        # Compute discrete RMS error: E = sqrt(h^2 * sum((w-u)^2))\n        # This is equivalent to h * Frobenius_norm(w-u)\n        diff_5 = u_sol_5 - u_exact_grid\n        errors['5'][m] = h * np.sqrt(np.sum(diff_5**2))\n\n        diff_9 = u_sol_9 - u_exact_grid\n        errors['9'][m] = h * np.sqrt(np.sum(diff_9**2))\n\n    # Calculate convergence rates and assemble final results\n    results = []\n    \n    # E(h=1/2) for m=2\n    results.append(errors['5'][2])\n    results.append(errors['9'][2])\n\n    # p(1/2 - 1/4) for m=2,4\n    results.append(np.log2(errors['5'][2] / errors['5'][4]))\n    results.append(np.log2(errors['9'][2] / errors['9'][4]))\n\n    # p(1/4 - 1/8) for m=4,8\n    results.append(np.log2(errors['5'][4] / errors['5'][8]))\n    results.append(np.log2(errors['9'][4] / errors['9'][8]))\n\n    # p(1/8 - 1/16) for m=8,16\n    results.append(np.log2(errors['5'][8] / errors['5'][16]))\n    results.append(np.log2(errors['9'][8] / errors['9'][16]))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2393516"}, {"introduction": "Moving from steady-state to time-dependent problems, we now tackle the parabolic heat equation. This exercise highlights a crucial, often-overlooked detail: the implementation of boundary conditions can dictate the global accuracy of your simulation. You will compare a first-order and a second-order implementation for Neumann (flux) boundary conditions [@problem_id:2393512] to see how a seemingly small local error at the boundary can degrade the performance of an otherwise accurate interior scheme.", "problem": "Consider the one-dimensional heat equation (a parabolic partial differential equation) on the spatial interval $[0,1]$,\n$$\nu_t(x,t) = \\alpha \\, u_{xx}(x,t), \\quad x \\in [0,1], \\; t \\in [0,T],\n$$\nwith thermal diffusivity $\\alpha  0$, subject to Neumann boundary conditions\n$$\nu_x(0,t) = g_0(t), \\quad u_x(1,t) = g_1(t),\n$$\nand an initial condition\n$$\nu(x,0) = u_0(x).\n$$\nInvestigate how different boundary condition closures affect the overall accuracy by comparing two mathematically specified implementations of the Neumann boundary condition that differ in their consistency order in space. The interior spatial discretization must be the standard second-order centered finite difference for $u_{xx}$ at all interior grid points, and time advancement must be the forward Euler method. The two boundary closures to be compared are:\n\n1. A first-order-consistent one-sided closure (denoted $\\mathrm{FO}$): enforce the Neumann boundary condition at $x=0$ and $x=1$ using one-sided first-order finite differences to eliminate ghost values,\n$$\n\\frac{u(x_0,t) - u(x_{-1},t)}{h} = g_0(t) \\;\\;\\Rightarrow\\;\\; u(x_{-1},t) = u(x_0,t) - h\\, g_0(t),\n$$\n$$\n\\frac{u(x_{N+1},t) - u(x_N,t)}{h} = g_1(t) \\;\\;\\Rightarrow\\;\\; u(x_{N+1},t) = u(x_N,t) + h\\, g_1(t),\n$$\nwhere $h$ is the spatial step, $x_i = i h$, $i=0,1,\\dots,N$, with $N h = 1$, and $x_{-1}$ and $x_{N+1}$ are ghost points.\n\n2. A second-order-consistent centered closure (denoted $\\mathrm{SO}$): enforce the Neumann boundary condition at $x=0$ and $x=1$ using centered finite differences to eliminate ghost values,\n$\n\\frac{u(x_1,t) - u(x_{-1},t)}{2h} = g_0(t) \\;\\Rightarrow\\; u(x_{-1},t) = u(x_1,t) - 2 h\\, g_0(t),\n$\n$\n\\frac{u(x_{N+1},t) - u(x_{N-1},t)}{2h} = g_1(t) \\;\\Rightarrow\\; u(x_{N+1},t) = u(x_{N-1},t) + 2 h\\, g_1(t).\n$\n\nAt each explicit time step, the ghost values are used to evaluate the discrete Laplacian at the boundary nodes with the same second-order centered formula for $u_{xx}$ as used in the interior. The forward Euler time step must be chosen as\n$$\n\\Delta t = c \\, \\frac{h^2}{2 \\alpha},\n$$\nwith a fixed constant $c = 0.45$, so that for $T  0$ the number of time steps is the nearest integer to $T / \\Delta t$, and the final step size is adjusted so that the final time is exactly $T$.\n\nUse the following two exact manufactured solutions (no physical units are involved in this problem):\n- Case A (nonzero Neumann flux): take\n$$\nu(x,t) = \\sin(\\pi x)\\, e^{-\\alpha \\pi^2 t}, \\quad u_0(x) = \\sin(\\pi x), \\quad g_0(t) = \\pi \\, e^{-\\alpha \\pi^2 t}, \\quad g_1(t) = -\\pi \\, e^{-\\alpha \\pi^2 t}.\n$$\n- Case B (homogeneous Neumann flux): take\n$$\nu(x,t) = \\cos(\\pi x)\\, e^{-\\alpha \\pi^2 t}, \\quad u_0(x) = \\cos(\\pi x), \\quad g_0(t) = 0, \\quad g_1(t) = 0.\n$$\n\nFix parameters $\\alpha = 1$, $T = 0.1$. For each of the two boundary closures $\\mathrm{FO}$ and $\\mathrm{SO}$, and for each of the two cases A and B, compute the discrete $L^2$-error at time $T$ for the uniform grids with $N \\in \\{20, 40, 80, 160\\}$ (so that $h = 1/N$ and the grid points are $x_i = i h$, $i = 0, 1, \\dots, N$). For an error sequence $E(h)$ gathered over these $4$ refinements, define the observed spatial order $p$ as the slope of the least-squares fit of $\\log E$ versus $\\log h$.\n\nYour program must:\n- Implement the forward Euler time integration with the stated $\\Delta t$ formula and second-order centered interior spatial discretization.\n- Implement the two boundary closures $\\mathrm{FO}$ and $\\mathrm{SO}$ exactly as stated.\n- For each of the two cases (A and B) and each boundary closure, compute the observed order $p$ from the four-grid error sequences using least squares on $\\{(\\log h, \\log E(h))\\}$.\n- Additionally, report whether, on the finest grid $N=160$, the $\\mathrm{SO}$ closure attains a smaller $L^2$-error than the $\\mathrm{FO}$ closure.\n\nTest suite and required outputs:\n- Use $\\alpha = 1$, $T = 0.1$, $c = 0.45$, and $N \\in \\{20, 40, 80, 160\\}$.\n- Produce six outputs in the following order:\n  1. The observed order $p$ for Case A with $\\mathrm{FO}$.\n  2. The observed order $p$ for Case A with $\\mathrm{SO}$.\n  3. The observed order $p$ for Case B with $\\mathrm{FO}$.\n  4. The observed order $p$ for Case B with $\\mathrm{SO}$.\n  5. A boolean indicating whether, on $N=160$ for Case A, the $L^2$-error with $\\mathrm{SO}$ is strictly smaller than with $\\mathrm{FO}$.\n  6. A boolean indicating whether, on $N=160$ for Case B, the $L^2$-error with $\\mathrm{SO}$ is strictly smaller than with $\\mathrm{FO}$.\n\nFinal output format:\nYour program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, in the exact order listed above. For example, an output like\n$$\n[\\;p\\_A^{\\mathrm{FO}},\\;p\\_A^{\\mathrm{SO}},\\;p\\_B^{\\mathrm{FO}},\\;p\\_B^{\\mathrm{SO}},\\;b\\_A,\\;b\\_B\\;]\n$$\nwhere the first four entries are real numbers (floats) and the last two entries are booleans. No other text should be printed.", "solution": "The problem statement has been rigorously validated and is determined to be scientifically grounded, well-posed, and self-contained. It presents a standard numerical analysis task involving the finite difference method for a parabolic partial differential equation. All parameters, equations, and conditions are explicitly defined, forming a consistent and solvable problem. We proceed with the derivation and implementation of the solution.\n\nThe problem requires simulating the one-dimensional heat equation $u_t(x,t) = \\alpha \\, u_{xx}(x,t)$ on the domain $x \\in [0,1]$ and $t \\in [0,T]$. We employ a finite difference method on a uniform grid with spatial points $x_i = i h$ for $i=0, 1, \\dots, N$ where $h=1/N$ is the spatial step size. The time domain is discretized into steps of size $\\Delta t$, with $t_n = n \\Delta t$. Let $u_i^n$ be the numerical approximation of the exact solution $u(x_i, t_n)$.\n\nThe time derivative $u_t$ is approximated using the first-order accurate forward Euler method. The spatial second derivative $u_{xx}$ is approximated using the second-order accurate centered difference stencil. Combining these discretizations yields the update rule for all grid points $i=0, \\dots, N$:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}\n$$\nRearranging for $u_i^{n+1}$ and introducing the mesh Fourier number $\\lambda = \\frac{\\alpha \\Delta t}{h^2}$, we obtain the explicit update formula:\n$$\nu_i^{n+1} = u_i^n + \\lambda (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\nThis formula is applied at all interior points, $i = 1, \\dots, N-1$. For the boundary points $i=0$ and $i=N$, the formula requires values at the \"ghost points\" $x_{-1} = -h$ and $x_{N+1} = 1+h$. These values, $u_{-1}^n$ and $u_{N+1}^n$, are determined by enforcing the Neumann boundary conditions, $u_x(0,t) = g_0(t)$ and $u_x(1,t) = g_1(t)$, using two different finite difference closures.\n\nThe problem specifies a fixed relationship between the time and space steps: $\\Delta t = c \\frac{h^2}{2 \\alpha}$ with $c = 0.45$. This gives $\\lambda = c/2 = 0.225$, which satisfies the stability condition $\\lambda \\le 1/2$ for the forward Euler method. The number of time steps is chosen as the nearest integer to $T/\\Delta t$, and $\\Delta t$ is then adjusted to ensure the final time is exactly $T$.\n\nThe two boundary closures are as follows:\n\n1.  **First-Order (FO) Closure**: The ghost points are determined by a first-order accurate one-sided difference approximation of the Neumann condition as specified:\n    $$\n    u_{-1}^n = u_0^n - h g_0(t_n)\n    $$\n    $$\n    u_{N+1}^n = u_N^n + h g_1(t_n)\n    $$\n    Substituting these into the general update formula for $i=0$ and $i=N$ gives the specific boundary update rules:\n    -   At $i=0$: $u_0^{n+1} = u_0^n + \\lambda (u_1^n - 2u_0^n + (u_0^n - h g_0(t_n))) = (1-\\lambda) u_0^n + \\lambda u_1^n - \\lambda h g_0(t_n)$.\n    -   At $i=N$: $u_N^{n+1} = u_N^n + \\lambda ((u_N^n + h g_1(t_n)) - 2u_N^n + u_{N-1}^n) = \\lambda u_{N-1}^n + (1-\\lambda) u_N^n + \\lambda h g_1(t_n)$.\n    The local truncation error of this boundary condition implementation is $\\mathcal{O}(h)$. This is expected to limit the overall spatial accuracy of the entire scheme to first order, so the observed convergence rate $p$ should be approximately $1$.\n\n2.  **Second-Order (SO) Closure**: The ghost points are determined by a second-order accurate centered difference approximation of the Neumann condition:\n    $$\n    u_{-1}^n = u_1^n - 2h g_0(t_n)\n    $$\n    $$\n    u_{N+1}^n = u_{N-1}^n + 2h g_1(t_n)\n    $$\n    Substituting these yields the boundary update rules:\n    -   At $i=0$: $u_0^{n+1} = u_0^n + \\lambda (u_1^n - 2u_0^n + (u_1^n - 2h g_0(t_n))) = (1-2\\lambda) u_0^n + 2\\lambda u_1^n - 2\\lambda h g_0(t_n)$.\n    -   At $i=N$: $u_N^{n+1} = u_N^n + \\lambda ((u_{N-1}^n + 2h g_1(t_n)) - 2u_N^n + u_{N-1}^n) = 2\\lambda u_{N-1}^n + (1-2\\lambda) u_N^n + 2\\lambda h g_1(t_n)$.\n    The local truncation error of this boundary implementation is $\\mathcal{O}(h^2)$, which is consistent with the $\\mathcal{O}(h^2)$ accuracy of the interior spatial discretization. The temporal error is $\\mathcal{O}(\\Delta t) = \\mathcal{O}(h^2)$. Therefore, the entire scheme is expected to be second-order accurate, and the observed convergence rate $p$ should be approximately $2$.\n\nThe numerical experiment proceeds as follows: for each case (A, B) and each closure (FO, SO), we solve the problem for a sequence of grid resolutions $N \\in \\{20, 40, 80, 160\\}$. For each resolution, we compute the final numerical solution $u_i$ at time $T$. The error is measured using the discrete $L^2$-norm, defined as $E(h) = \\sqrt{h \\sum_{i=0}^N (u_i - u_{exact}(x_i, T))^2}$. The observed order of convergence, $p$, is calculated as the slope of the linear least-squares fit to the points $(\\log h, \\log E(h))$. Finally, the errors on the finest grid ($N=160$) are compared for the two closures.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified. It computes convergence orders\n    for two different Neumann boundary condition closures for the 1D heat equation.\n    \"\"\"\n    # Define problem parameters\n    alpha = 1.0\n    T = 0.1\n    c = 0.45\n    N_values = [20, 40, 80, 160]\n\n    # Define the two manufactured solution cases\n    case_A = {\n        'name': 'A',\n        'u_exact': lambda x, t, a: np.sin(np.pi * x) * np.exp(-a * np.pi**2 * t),\n        'u_0': lambda x: np.sin(np.pi * x),\n        'g_0': lambda t, a: np.pi * np.exp(-a * np.pi**2 * t),\n        'g_1': lambda t, a: -np.pi * np.exp(-a * np.pi**2 * t)\n    }\n\n    case_B = {\n        'name': 'B',\n        'u_exact': lambda x, t, a: np.cos(np.pi * x) * np.exp(-a * np.pi**2 * t),\n        'u_0': lambda x: np.cos(np.pi * x),\n        'g_0': lambda t, a: 0.0,\n        'g_1': lambda t, a: 0.0\n    }\n\n    # Define the configurations to test\n    test_configs = [\n        {'case': case_A, 'closure': 'FO'},\n        {'case': case_A, 'closure': 'SO'},\n        {'case': case_B, 'closure': 'FO'},\n        {'case': case_B, 'closure': 'SO'},\n    ]\n\n    observed_orders = []\n    errors_N160 = {}\n\n    for config in test_configs:\n        case = config['case']\n        closure_type = config['closure']\n        \n        log_h_list = []\n        log_E_list = []\n\n        for N in N_values:\n            h = 1.0 / N\n            x = np.linspace(0.0, 1.0, N + 1)\n            \n            # Time stepping setup\n            dt_base = c * h**2 / (2.0 * alpha)\n            num_steps = int(round(T / dt_base))\n            dt = T / num_steps\n            \n            lam = alpha * dt / h**2\n            \n            # Initial condition\n            u = case['u_0'](x)\n            \n            # Time integration loop\n            for n in range(num_steps):\n                t_n = n * dt\n                u_new = np.zeros_like(u)\n                \n                # Interior points update\n                u_new[1:-1] = u[1:-1] + lam * (u[:-2] - 2 * u[1:-1] + u[2:])\n                \n                # Boundary functions g0(t), g1(t)\n                g0_tn = case['g_0'](t_n, alpha)\n                g1_tn = case['g_1'](t_n, alpha)\n\n                # Boundary points update\n                if closure_type == 'FO':\n                    u_new[0] = (1.0 - lam) * u[0] + lam * u[1] - lam * h * g0_tn\n                    u_new[-1] = lam * u[-2] + (1.0 - lam) * u[-1] + lam * h * g1_tn\n                elif closure_type == 'SO':\n                    u_new[0] = (1.0 - 2.0 * lam) * u[0] + 2.0 * lam * u[1] - 2.0 * lam * h * g0_tn\n                    u_new[-1] = 2.0 * lam * u[-2] + (1.0 - 2.0 * lam) * u[-1] + 2.0 * lam * h * g1_tn\n\n                u = u_new\n\n            # Compute error at final time T\n            u_exact_T = case['u_exact'](x, T, alpha)\n            error = np.sqrt(h) * np.linalg.norm(u - u_exact_T)\n            \n            log_h_list.append(np.log(h))\n            log_E_list.append(np.log(error))\n            \n            if N == 160:\n                errors_N160[(case['name'], closure_type)] = error\n\n        # Compute observed order of convergence using least-squares fit\n        p, _ = np.polyfit(log_h_list, log_E_list, 1)\n        observed_orders.append(p)\n    \n    # Final comparisons for N=160\n    b_A = errors_N160[('A', 'SO')]  errors_N160[('A', 'FO')]\n    b_B = errors_N160[('B', 'SO')]  errors_N160[('B', 'FO')]\n    \n    # Prepare results for printing\n    results_list = observed_orders + [b_A, b_B]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results_list))}]\")\n\nsolve()\n```", "id": "2393512"}, {"introduction": "Our final practice takes on the Kuramoto-Sivashinsky equation, a model that showcases the emergence of spatio-temporal chaos from a relatively simple nonlinear PDE. This problem introduces the challenge of handling both stiff, high-order linear derivatives and a nonlinear convective term. You will implement an Implicit-Explicit (IMEX) time-stepping scheme [@problem_id:2393592], a powerful technique used to efficiently simulate systems where different physical processes operate on vastly different time scales.", "problem": "Consider the Kuramoto–Sivashinsky partial differential equation (PDE)\n$$u_t + u\\,u_x + u_{xx} + u_{xxxx} = 0,$$\nposed on a one-dimensional periodic domain of length $L$, that is, $x \\in [0,L)$ with periodic boundary conditions. Your task is to derive from first principles, implement, and test a finite difference method that advances the solution in time. You must follow these requirements:\n\n- Start from the method-of-lines viewpoint and the core definitions of finite differences. Use standard centered finite differences in space on a uniform grid with $N$ nodes, grid spacing $\\Delta x = L/N$, and periodic wrap-around indexing. Treat the linear terms $u_{xx}$ and $u_{xxxx}$ implicitly in a single linear solve each time step, and treat the nonlinear convective term $u\\,u_x$ explicitly in conservative (skew-symmetric) form. Use a one-step time discretization that is unconditionally stable for the linear part and consistent for the full PDE. Use periodic boundary conditions in all spatial operators.\n- Ensure that your discrete spatial differentiation is conservative in the sense that the discrete sum over all nodes of a discrete derivative is exactly zero for periodic grids.\n- The program must be fully deterministic (no randomness). Use smooth, zero-mean trigonometric initial data as specified below. No external inputs are allowed.\n\nInitial condition family: For parameters $A$ and integer $m$, use\n$$u(x,0) = A\\left[\\sin\\!\\left(\\tfrac{2\\pi m}{L}\\,x\\right) + \\tfrac{1}{4}\\cos\\!\\left(\\tfrac{4\\pi m}{L}\\,x\\right)\\right].$$\n\nNumerical outputs to report for each test case:\n- The absolute drift of the discrete spatial mean between the initial and final time,\n$$\\left|\\overline{u}(T)-\\overline{u}(0)\\right|,$$\nwhere $\\overline{u}(t)$ is the discrete average over all grid points at time $t$.\n- The final-time discrete essential supremum (infinity norm),\n$$\\|u(\\cdot,T)\\|_{\\infty} = \\max_i |u_i(T)|.$$\n\nBoth reported values must be rounded to $6$ decimal places.\n\nTest suite: Run your solver for the following four parameter sets. For each, the final time is $T$, the time step is $\\Delta t$, and the number of steps $T/\\Delta t$ is an integer.\n\n- Test $1$: $L=32.0$, $N=64$, $\\Delta t=0.01$, $T=0.5$, $A=0.5$, $m=1$.\n- Test $2$: $L=32.0$, $N=128$, $\\Delta t=0.005$, $T=0.5$, $A=0.5$, $m=1$.\n- Test $3$: $L=8.0$, $N=64$, $\\Delta t=0.01$, $T=0.2$, $A=0.5$, $m=1$.\n- Test $4$: $L=32.0$, $N=64$, $\\Delta t=0.01$, $T=0.5$, $A=0.0$, $m=1$.\n\nFinal output format:\n- Your program should produce a single line of output containing a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a two-element list. Each two-element list must be of the form $[\\text{mean\\_drift},\\text{final\\_linf}]$, both rounded to $6$ decimal places. For example,\n$$[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]],$$\nwith no spaces added beyond those shown by the default string conversion of the list.\n\nYour final answer must be a complete, runnable program that produces exactly this single-line output and nothing else. The answer must be unitless; do not use any physical units. Angles, where they appear in trigonometric functions, are in radians by construction.", "solution": "The problem presented is a well-posed computational task in the field of numerical partial differential equations. It is scientifically grounded, internally consistent, and contains all necessary information for its resolution. We shall proceed with a complete solution derived from first principles.\n\nThe governing equation is the Kuramoto–Sivashinsky (KS) partial differential equation (PDE):\n$$u_t + u\\,u_x + u_{xx} + u_{xxxx} = 0$$\nThis equation is posed on a one-dimensional periodic domain $x \\in [0,L)$. We are tasked to solve this equation numerically using a finite difference method.\n\nFirst, we adopt the method-of-lines approach. We discretize the spatial domain into a uniform grid of $N$ points, $x_i = i \\Delta x$ for $i = 0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/N$. Let $u_i(t)$ be the approximation of the solution $u(x_i, t)$. The system of partial differential equations is transformed into a system of ordinary differential equations (ODEs) for the vector $\\mathbf{u}(t) = [u_0(t), u_1(t), \\dots, u_{N-1}(t)]^T$.\n\nThe KS equation can be written as $u_t = \\mathcal{N}(u) + \\mathcal{L}(u)$, where $\\mathcal{N}(u) = -u u_x$ is the nonlinear part and $\\mathcal{L}(u) = -u_{xx} - u_{xxxx}$ is the linear part.\n\nWe discretize the spatial operators using centered finite differences with periodic boundary conditions. The stencils for the second and fourth derivatives are:\n$$ (D_{xx} \\mathbf{u})_i = \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} $$\n$$ (D_{xxxx} \\mathbf{u})_i = \\frac{u_{i+2} - 4u_{i+1} + 6u_i - 4u_{i-1} + u_{i-2}}{\\Delta x^4} $$\nThese operators satisfy the problem's requirement that the discrete sum of a derivative over the periodic grid is zero, which is evident from the fact that the sum of stencil coefficients is $1-2+1=0$ and $1-4+6-4+1=0$. Let $\\mathbf{D}_{xx}$ and $\\mathbf{D}_{xxxx}$ be the circulant matrices representing these discrete operators. The semi-discretized linear part is then $\\mathbf{L}\\mathbf{u} = -(\\mathbf{D}_{xx} + \\mathbf{D}_{xxxx})\\mathbf{u}$.\n\nFor the nonlinear term $u u_x$, the problem requires a conservative (skew-symmetric) form. We interpret \"conservative\" as preserving the spatial mean of the solution, $\\overline{u} = \\frac{1}{N}\\sum_i u_i$. The continuous mean is conserved because the KS equation can be written in conservation form: $u_t + \\left(\\frac{1}{2}u^2 + u_x + u_{xxx}\\right)_x = 0$. A discrete scheme preserves the mean if the sum of the right-hand side over all grid points is zero. For the linear part, this is already satisfied. For the nonlinear part, we write $u u_x = (\\frac{1}{2}u^2)_x$ and discretize it with a centered difference, which is a standard conservative scheme:\n$$ (\\mathbf{N}(\\mathbf{u}))_i = -\\frac{u_{i+1}^2/2 - u_{i-1}^2/2}{2\\Delta x} = -\\frac{u_{i+1}^2 - u_{i-1}^2}{4\\Delta x} $$\nThe sum $\\sum_i (\\mathbf{N}(\\mathbf{u}))_i$ is a telescoping sum on a periodic grid and is therefore exactly zero, ensuring discrete conservation of the mean.\n\nThe semi-discretized system of ODEs is:\n$$ \\frac{d\\mathbf{u}}{dt} = \\mathbf{N}(\\mathbf{u}) + \\mathbf{L}\\mathbf{u} $$\n\nNext, we discretize in time. The problem specifies a one-step method that treats the linear part implicitly for stability and the nonlinear part explicitly. This leads to a first-order Implicit-Explicit (IMEX) Euler scheme, which is consistent and unconditionally stable for the linear part. Given the solution $\\mathbf{u}^n$ at time $t_n$, the solution at $t_{n+1} = t_n + \\Delta t$ is found by solving:\n$$ \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\mathbf{N}(\\mathbf{u}^n) + \\mathbf{L}\\mathbf{u}^{n+1} $$\nRearranging gives the linear system to be solved at each time step:\n$$ (\\mathbf{I} - \\Delta t \\mathbf{L})\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\mathbf{N}(\\mathbf{u}^n) $$\nSubstituting the expressions for $\\mathbf{L}$ and $\\mathbf{N}(\\mathbf{u})$:\n$$ (\\mathbf{I} + \\Delta t \\mathbf{D}_{xx} + \\Delta t \\mathbf{D}_{xxxx})\\mathbf{u}^{n+1} = \\mathbf{u}^n - \\Delta t \\left(-\\frac{(\\mathbf{u}^n_{\\text{shifted}+1})^2 - (\\mathbf{u}^n_{\\text{shifted}-1})^2}{4\\Delta x}\\right) $$\nThe matrix on the left, $\\mathbf{A} = \\mathbf{I} + \\Delta t \\mathbf{D}_{xx} + \\Delta t \\mathbf{D}_{xxxx}$, is a circulant matrix. Direct inversion would be computationally expensive ($O(N^3)$). Instead, we exploit the property that circulant matrices are diagonalized by the Discrete Fourier Transform (DFT). Let $\\mathcal{F}$ denote the DFT operator. The equation $\\mathbf{A}\\mathbf{u}^{n+1} = \\mathbf{b}^n$, where $\\mathbf{b}^n$ is the right-hand side, can be solved efficiently:\n1.  Compute the right-hand side $\\mathbf{b}^n$ in physical space.\n2.  Transform $\\mathbf{b}^n$ to Fourier space: $\\hat{\\mathbf{b}}^n = \\mathcal{F}(\\mathbf{b}^n)$.\n3.  The Fourier transform diagonalizes $\\mathbf{A}$ into $\\hat{\\mathbf{A}}$, a diagonal matrix whose entries are the eigenvalues of $\\mathbf{A}$. The equation in Fourier space is $\\hat{\\mathbf{A}} \\hat{\\mathbf{u}}^{n+1} = \\hat{\\mathbf{b}}^n$.\n4.  Solve for $\\hat{\\mathbf{u}}^{n+1}$ by element-wise division: $\\hat{u}^{n+1}_k = \\hat{b}^n_k / \\hat{A}_k$.\n5.  Transform back to physical space: $\\mathbf{u}^{n+1} = \\mathcal{F}^{-1}(\\hat{\\mathbf{u}}^{n+1})$.\n\nThe eigenvalues $\\hat{A}_k$ are derived from the eigenvalues of the discrete derivative operators. For a discrete wavenumber $k = 2\\pi m / L$ corresponding to the $m$-th Fourier mode, the eigenvalues of $\\mathbf{D}_{xx}$ and $\\mathbf{D}_{xxxx}$ are:\n$$ \\hat{D}_{xx}(k) = \\frac{2(\\cos(k\\Delta x) - 1)}{\\Delta x^2} $$\n$$ \\hat{D}_{xxxx}(k) = \\left( \\hat{D}_{xx}(k) \\right)^2 = \\frac{4(\\cos(k\\Delta x) - 1)^2}{\\Delta x^4} = \\frac{2\\cos(2k\\Delta x) - 8\\cos(k\\Delta x) + 6}{\\Delta x^4} $$\nThus, the eigenvalues of the implicit operator matrix $\\mathbf{A}$ are:\n$$ \\hat{A}_k = 1 + \\Delta t \\hat{D}_{xx}(k) + \\Delta t \\hat{D}_{xxxx}(k) $$\nThese are pre-computed. The overall algorithm has a cost of $O(N \\log N)$ per time step, dominated by the Fast Fourier Transforms (FFTs).\n\nThe implementation will follow this procedure. For each test case, we initialize the solution using the given formula, calculate the initial discrete mean $\\overline{u}(0) = \\frac{1}{N}\\sum_i u_i(0)$, and then iterate the time-stepping loop for $T/\\Delta t$ steps. Finally, we compute the final mean $\\overline{u}(T)$, the absolute mean drift $|\\overline{u}(T)-\\overline{u}(0)|$, and the final infinity norm $\\|u(\\cdot,T)\\|_{\\infty} = \\max_i |u_i(T)|$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(L, N, dt, T, A, m):\n    \"\"\"\n    Solves the Kuramoto-Sivashinsky equation using a finite difference method\n    with an IMEX-1 (Implicit-Explicit Euler) time-stepping scheme.\n\n    The equation is u_t + u*u_x + u_xx + u_xxxx = 0.\n\n    Time stepping scheme:\n    (u^{n+1} - u^n)/dt = -N(u^n) - L_op(u^{n+1})\n    where N(u) = u*u_x is the nonlinear term, treated explicitly,\n    and L_op(u) = u_xx + u_xxxx is the linear part, treated implicitly.\n\n    Rearranging yields the linear system to solve at each step:\n    (I + dt*L_op) u^{n+1} = u^n - dt*N(u^n)\n    This system is solved efficiently in Fourier space.\n    \"\"\"\n    # 1. Spatial and temporal grid setup\n    dx = L / N\n    x = np.arange(N) * dx\n    num_steps = int(round(T / dt))\n\n    # 2. Initial condition\n    # u(x,0) = A * [sin(2*pi*m/L * x) + 1/4 * cos(4*pi*m/L * x)]\n    u = A * (np.sin(2 * np.pi * m / L * x) + 0.25 * np.cos(4 * np.pi * m / L * x))\n    initial_mean = np.mean(u)\n\n    # 3. Pre-computation for the linear operator (solved in Fourier space)\n    # Wavenumbers k for the discrete Fourier transform\n    # The physical wavenumbers are k_phys = 2 * pi * freqs\n    freqs = np.fft.fftfreq(N, d=dx)\n    k = 2 * np.pi * freqs\n\n    # Eigenvalues of the finite difference operators for u_xx and u_xxxx.\n    # Stencil for D_xx: (1, -2, 1)/dx^2.\n    # Symbol (eigenvalue for basis func e^{ikx}): (e^{ik*dx} - 2 + e^{-ik*dx}) / dx^2\n    # which simplifies to 2*(cos(k*dx)-1)/dx^2\n    D2_hat = 2 * (np.cos(k * dx) - 1) / dx**2\n    # Symbol for D_xxxx is (D2_hat)^2\n    D4_hat = D2_hat**2\n\n    # The PDE has u_t + L_op*u + ... = 0, so du/dt = -L_op*u - ...\n    # The implicit operator matrix for (I - dt * (-D2_hat - D4_hat)) is\n    # I + dt*(D2_hat + D4_hat). This is the divisor in Fourier space.\n    implicit_op_hat = 1.0 + dt * (D2_hat + D4_hat)\n    \n    # 4. Main time-stepping loop\n    u_hat = np.fft.fft(u)\n\n    for _ in range(num_steps):\n        # Go to physical space to compute nonlinear term\n        u_phys = np.fft.ifft(u_hat).real\n\n        # Nonlinear term N(u) = u*u_x discretized in conservative form.\n        # This corresponds to discretizing (u^2/2)_x with a centered difference.\n        # (f(i+1) - f(i-1))/(2dx), where f_i = u_i^2/2.\n        # - (u_{i+1}^2/2 - u_{i-1}^2/2)/(2dx) = (u_{i+1}^2 - u_{i-1}^2)/(4dx)\n        # We use np.roll for periodic boundary conditions.\n        Nu = (np.roll(u_phys, -1)**2 - np.roll(u_phys, 1)**2) / (4.0 * dx)\n\n        # Form the right-hand-side: u^n - dt * N(u^n)\n        # PDE is u_t = -N(u) - L(u).\n        RHS_phys = u_phys - dt * Nu\n        RHS_hat = np.fft.fft(RHS_phys)\n\n        # Solve for next time step in Fourier space\n        u_hat_next = RHS_hat / implicit_op_hat\n        u_hat = u_hat_next\n\n    # 5. Compute final outputs and round as specified\n    u_final = np.fft.ifft(u_hat).real\n    \n    final_mean = np.mean(u_final)\n    mean_drift = np.abs(final_mean - initial_mean)\n    final_linf = np.max(np.abs(u_final))\n    \n    return [round(mean_drift, 6), round(final_linf, 6)]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite: (L, N, dt, T, A, m)\n    test_cases = [\n        (32.0, 64, 0.01, 0.5, 0.5, 1),\n        (32.0, 128, 0.005, 0.5, 0.5, 1),\n        (8.0, 64, 0.01, 0.2, 0.5, 1),\n        (32.0, 64, 0.01, 0.5, 0.0, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Print the final result in the exact required format.\n    # The string representation of a list includes spaces, which must be removed.\n    print(f\"{results}\".replace(\" \", \"\"))\n\nsolve()\n```", "id": "2393592"}]}