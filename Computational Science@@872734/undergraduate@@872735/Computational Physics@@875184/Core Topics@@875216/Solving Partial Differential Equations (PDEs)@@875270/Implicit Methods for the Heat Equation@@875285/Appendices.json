{"hands_on_practices": [{"introduction": "This first practice provides a foundational exercise in implementing an implicit method for the one-dimensional heat equation. You will encounter a scenario where an explicit method would fail due to stability constraints, highlighting the practical necessity of implicit schemes like Crank-Nicolson. This exercise reinforces core skills by requiring you to compare your numerical results against a known analytical solution, a crucial step in code verification and validation [@problem_id:2402549].", "problem": "Consider one-dimensional heat conduction into a semi-infinite homogeneous solid. The temperature field $T(x,t)$ satisfies the heat equation (a Partial Differential Equation (PDE))\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\,\\frac{\\partial^2 T}{\\partial x^2}, \\quad x > 0, \\; t > 0,\n$$\nwhere $\\alpha$ is the thermal diffusivity. The solid is initially at a uniform temperature and the surface at $x=0$ is suddenly brought to and maintained at a higher temperature. To compute a numerical approximation, approximate the semi-infinite domain by a finite interval $[0,L]$ and use the following well-posed initial and boundary conditions:\n- Initial condition: $T(x,0) = T_0$ for all $x \\in (0,L]$.\n- Boundary condition at the surface: $T(0,t) = T_s$ for all $t > 0$.\n- Boundary condition at the far end: $\\frac{\\partial T}{\\partial x}(L,t) = 0$ for all $t > 0$.\n\nThe exact analytical solution for the semi-infinite domain (with no finite-$L$ truncation) under these conditions is known and given by\n$$\nT_{\\text{exact}}(x,t) = T_0 + \\bigl(T_s - T_0\\bigr)\\,\\mathrm{erfc}\\!\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right), \\quad x \\ge 0, \\; t > 0,\n$$\nwhere $\\mathrm{erfc}$ denotes the complementary error function.\n\nYour task is to compute, for each specified parameter set, a numerical approximation to $T(x,t)$ on the truncated domain $[0,L]$ at a final time $t = t_f$, using a uniform spatial grid with $N_x$ equal-sized subintervals (so the grid points are $x_i = i\\,\\Delta x$ with $\\Delta x = L/N_x$ for $i=0,1,\\dots,N_x$) and a uniform time step $\\Delta t$ (so that the number of time steps up to $t_f$ is $t_f/\\Delta t$, which is guaranteed to be an integer in the test suite). Then, on the grid $\\{x_i\\}_{i=0}^{N_x}$, compute the maximum absolute error (in Kelvin) between the numerical solution $T_{\\text{num}}(x_i,t_f)$ and $T_{\\text{exact}}(x_i,t_f)$:\n$$\nE_{\\max} = \\max_{0 \\le i \\le N_x} \\left| T_{\\text{num}}(x_i,t_f) - T_{\\text{exact}}(x_i,t_f) \\right|.\n$$\n\nAll physical units must be used consistently: lengths in meters ($\\mathrm{m}$), time in seconds ($\\mathrm{s}$), temperature in Kelvin ($\\mathrm{K}$), and diffusivity in square meters per second ($\\mathrm{m^2/s}$). Report each $E_{\\max}$ in Kelvin, rounded to six decimal places.\n\nTest suite. For each of the following parameter sets $(\\alpha, L, T_0, T_s, t_f, N_x, \\Delta t)$, compute $E_{\\max}$:\n\n- Case $1$: $\\alpha = 1.0\\times 10^{-5}\\ \\mathrm{m^2/s}$, $L = 0.1\\ \\mathrm{m}$, $T_0 = 300\\ \\mathrm{K}$, $T_s = 400\\ \\mathrm{K}$, $t_f = 100\\ \\mathrm{s}$, $N_x = 400$, $\\Delta t = 0.1\\ \\mathrm{s}$.\n- Case $2$: $\\alpha = 1.4\\times 10^{-7}\\ \\mathrm{m^2/s}$, $L = 0.02\\ \\mathrm{m}$, $T_0 = 293\\ \\mathrm{K}$, $T_s = 350\\ \\mathrm{K}$, $t_f = 10\\ \\mathrm{s}$, $N_x = 200$, $\\Delta t = 0.5\\ \\mathrm{s}$.\n- Case $3$: $\\alpha = 1.0\\times 10^{-5}\\ \\mathrm{m^2/s}$, $L = 0.02\\ \\mathrm{m}$, $T_0 = 300\\ \\mathrm{K}$, $T_s = 310\\ \\mathrm{K}$, $t_f = 200\\ \\mathrm{s}$, $N_x = 200$, $\\Delta t = 0.2\\ \\mathrm{s}$.\n- Case $4$: $\\alpha = 5.0\\times 10^{-6}\\ \\mathrm{m^2/s}$, $L = 0.05\\ \\mathrm{m}$, $T_0 = 300\\ \\mathrm{K}$, $T_s = 360\\ \\mathrm{K}$, $t_f = 200\\ \\mathrm{s}$, $N_x = 40$, $\\Delta t = 2.0\\ \\mathrm{s}$.\n\nFinal output format. Your program should produce a single line of output containing the list of the four rounded errors, in the order of the test suite, as a comma-separated list enclosed in square brackets, for example\n$[e_1,e_2,e_3,e_4]$,\nwhere each $e_k$ is the error for Case $k$ in Kelvin rounded to six decimal places (no units or extra spaces in the output line).", "solution": "The problem presented is a well-posed initial-boundary value problem for the one-dimensional heat equation on a truncated spatial domain. A numerical solution is to be computed and compared against a given analytical solution corresponding to a semi-infinite domain.\n\nThe problem is validated as follows. The governing partial differential equation, $\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}$, is a fundamental principle of heat transfer. The initial and boundary conditions are standard and physically meaningful. All parameters are provided with consistent units. Critically, an analysis of the stability parameter for an explicit forward-time, centered-space (FTCS) scheme, $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$, reveals values of $s \\approx 16$, $s=7$, $s=200$, and $s \\approx 6.4$ for the four respective test cases. Since for stability the FTCS scheme requires $s \\le \\frac{1}{2}$, an explicit method would be violently unstable. This necessitates the use of an unconditionally stable implicit method. The problem is therefore scientifically sound and rigorously structured to test the implementation of such a method.\n\nThe Crank-Nicolson method is selected for its unconditional stability and second-order accuracy in both time $\\mathcal{O}((\\Delta t)^2)$ and space $\\mathcal{O}((\\Delta x)^2)$. The method approximates the time derivative at the midpoint of a time interval $[t_n, t_{n+1}]$ and averages the spatial derivative over the two time levels. Let $T_i^n$ denote the numerical approximation of the temperature $T(x_i, t_n)$ at grid point $x_i = i\\Delta x$ and time $t_n = n\\Delta t$. The Crank-Nicolson discretization of the heat equation is:\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left[ \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2} + \\frac{T_{i+1}^{n+1} - 2T_i^{n+1} + T_{i-1}^{n+1}}{(\\Delta x)^2} \\right] $$\nThis equation applies to the interior spatial grid points $i = 1, 2, \\dots, N_x - 1$. Let $r = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$. Rearranging the equation to separate the unknown temperatures at time step $n+1$ from the known temperatures at time step $n$ yields:\n$$ -r T_{i-1}^{n+1} + (1+2r) T_i^{n+1} - r T_{i+1}^{n+1} = r T_{i-1}^n + (1-2r) T_i^n + r T_{i+1}^n $$\nThis system of equations must be supplemented with boundary conditions. The spatial grid has $N_x+1$ points indexed from $i=0$ to $i=N_x$. The temperatures $T_1^{n+1}, \\dots, T_{N_x}^{n+1}$ are the $N_x$ unknowns to be found at each time step.\n\nAt the boundary $x=0$ (corresponding to $i=0$), the Dirichlet condition $T(0,t) = T_s$ is applied, so $T_0^n = T_s$ for all $n \\ge 0$. For the first unknown $T_1^{n+1}$ (i.e., at $i=1$), the known value $T_0^{n+1} = T_s$ is moved to the right-hand side of the equation:\n$$ (1+2r) T_1^{n+1} - r T_2^{n+1} = (1-2r) T_1^n + r T_2^n + 2r T_s $$\n\nAt the boundary $x=L$ (corresponding to $i=N_x$), the Neumann condition $\\frac{\\partial T}{\\partial x}(L,t)=0$ is imposed. This is approximated using a second-order accurate central difference involving a \"ghost point\" at $x_{N_x+1} = L+\\Delta x$. The condition $\\frac{T_{N_x+1} - T_{N_x-1}}{2\\Delta x} = 0$ implies $T_{N_x+1} = T_{N_x-1}$. Substituting this into the general Crank-Nicolson equation for $i=N_x$ provides the equation for the final unknown $T_{N_x}^{n+1}$:\n$$ -2r T_{N_x-1}^{n+1} + (1+2r) T_{N_x}^{n+1} = 2r T_{N_x-1}^n + (1-2r) T_{N_x}^n $$\nThese equations for $i = 1, \\dots, N_x$ form a linear system of the form $\\mathbf{A} \\mathbf{U}^{n+1} = \\mathbf{b}^n$, where $\\mathbf{U}^{n+1}$ is the vector of unknown temperatures $[T_1^{n+1}, \\dots, T_{N_x}^{n+1}]^T$. The matrix $\\mathbf{A}$ is a constant, $N_x \\times N_x$ tridiagonal matrix:\n$$ \\mathbf{A} = \\begin{pmatrix}\n1+2r & -r & 0 & \\dots & \\dots & 0 \\\\\n-r & 1+2r & -r & \\ddots & & \\vdots \\\\\n0 & \\ddots & \\ddots & \\ddots & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & -r & 1+2r & -r & 0 \\\\\n\\vdots & & \\ddots & 0 & -2r & 1+2r\n\\end{pmatrix} $$\nThe right-hand side vector $\\mathbf{b}^n$ is computed from the known temperatures at time $n$:\n$$ b_1^n = (1-2r) T_1^n + r T_2^n + 2r T_s $$\n$$ b_i^n = r T_{i-1}^n + (1-2r) T_i^n + r T_{i+1}^n \\quad \\text{for } i=2, \\dots, N_x-1 $$\n$$ b_{N_x}^n = 2r T_{N_x-1}^n + (1-2r) T_{N_x}^n $$\nThe numerical solution proceeds by first setting the initial temperature profile $T(x,0) = T_0$ for $x>0$ and $T(0,0)=T_s$. Then, for each time step from $n=0$ to $N_t-1$, where $N_t=t_f/\\Delta t$, the right-hand side vector $\\mathbf{b}^n$ is constructed and the tridiagonal system $\\mathbf{A} \\mathbf{U}^{n+1} = \\mathbf{b}^n$ is solved to find the temperatures at the next time step. This process is repeated until the final time $t_f$ is reached. This tridiagonal system is efficiently solved using an algorithm such as the Thomas algorithm, available in scientific computing libraries.\n\nFinally, at $t=t_f$, the computed numerical solution $T_{\\text{num}}(x_i, t_f)$ is compared to the analytical solution for the semi-infinite domain, $T_{\\text{exact}}(x_i, t_f)$, and the maximum absolute error $E_{\\max}$ over all grid points is determined. It is noted that this error metric conflates the numerical discretization error with the modeling error arising from the domain truncation and the approximate far-field boundary condition.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D heat equation for given test cases using the Crank-Nicolson method\n    and computes the maximum error against the analytical solution.\n    \"\"\"\n    # (alpha, L, T0, Ts, tf, Nx, dt)\n    test_cases = [\n        (1.0e-5, 0.1, 300.0, 400.0, 100.0, 400, 0.1),\n        (1.4e-7, 0.02, 293.0, 350.0, 10.0, 200, 0.5),\n        (1.0e-5, 0.02, 300.0, 310.0, 200.0, 200, 0.2),\n        (5.0e-6, 0.05, 300.0, 360.0, 200.0, 40, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, L, T0, Ts, tf, Nx, dt = case\n\n        # Discretization parameters\n        dx = L / Nx\n        # Note: The stability parameter for FTCS is alpha*dt/dx**2.\n        # The Crank-Nicolson parameter 'r' is defined with a factor of 2.\n        r = (alpha * dt) / (2 * dx**2)\n        Nt = int(round(tf / dt))\n\n        # --- Initial Condition ---\n        # T_current is the temperature vector at the current time step.\n        # It has Nx+1 points, from x=0 to x=L.\n        T_current = np.full(Nx + 1, T0)\n        T_current[0] = Ts # Boundary condition at x=0\n\n        # --- Set up the Crank-Nicolson matrix system A*U_next = b ---\n        # Matrix A is tridiagonal and constant through time.\n        # We use scipy.linalg.solve_banded which is efficient.\n        # The matrix A acts on the interior points plus the far boundary, so it is Nx x Nx.\n        \n        # 'ab' stores the bands of matrix A in a format required by solve_banded.\n        # For a (1,1) banded matrix A, ab is (3, Nx).\n        # ab[0, 1:] = upper diagonal\n        # ab[1, :]   = main diagonal\n        # ab[2, :-1] = lower diagonal\n        ab = np.zeros((3, Nx))\n\n        # Main diagonal\n        ab[1, :] = 1 + 2 * r\n\n        # Upper diagonal\n        ab[0, 1:] = -r\n\n        # Lower diagonal\n        ab[2, :-1] = -r\n        # Modification for Neumann boundary condition at x=L (i=Nx)\n        # This affects the last row of matrix A: A[Nx-1, Nx-2] = -2*r\n        # which corresponds to the last element of the lower diagonal band.\n        if Nx > 1:\n            ab[2, Nx - 2] = -2 * r\n\n        # --- Time-stepping loop ---\n        for _ in range(Nt):\n            # Construct the right-hand side vector b\n            b = np.zeros(Nx)\n\n            # Equation for the first interior point i=1 (vector index 0)\n            b[0] = (1 - 2 * r) * T_current[1] + r * T_current[2] + 2 * r * Ts\n\n            # Equations for interior points i=2 to Nx-1 (vector indices 1 to Nx-2)\n            # This loop is slow but clear. Vectorization is possible but complex to write.\n            for i in range(2, Nx):\n                b[i-1] = r * T_current[i-1] + (1 - 2 * r) * T_current[i] + r * T_current[i+1]\n\n            # Equation for the last point i=Nx (vector index Nx-1)\n            # This is only relevant if there's more than one unknown point\n            if Nx > 1:\n                b[Nx - 1] = 2 * r * T_current[Nx - 1] + (1 - 2 * r) * T_current[Nx]\n\n            # Solve the linear system for the unknown interior temperatures at the next time step\n            T_next_interior = solve_banded((1, 1), ab, b)\n            \n            # Update the temperature vector\n            T_current[1:] = T_next_interior\n            # T_current[0] is always Ts\n\n        # --- Error Calculation ---\n        # The numerical solution at t=tf is in T_current\n        T_numerical = T_current\n\n        # Calculate the exact solution at t=tf\n        x = np.linspace(0, L, Nx + 1)\n        # The argument of erfc can become infinite if t=0, but tf > 0 here.\n        argument = x / (2 * np.sqrt(alpha * tf))\n        T_exact = T0 + (Ts - T0) * erfc(argument)\n        \n        # Compute the maximum absolute error\n        max_error = np.max(np.abs(T_numerical - T_exact))\n        results.append(round(max_error, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2402549"}, {"introduction": "Building upon the one-dimensional case, this problem extends our study to heat diffusion in two spatial dimensions. A naive implicit discretization in 2D would lead to a large, computationally expensive linear system. This practice introduces the Alternating-Direction Implicit (ADI) method, a powerful and efficient technique that circumvents this issue by splitting the problem into a sequence of simpler, one-dimensional solves, while preserving the unconditional stability of an implicit approach [@problem_id:2402582].", "problem": "Consider the two-dimensional heat diffusion on a square domain governed by the partial differential equation (PDE)\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\left(\\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2}\\right),\n$$\non the square plate $\\Omega = [0,L]\\times[0,L]$, with constant Dirichlet boundary conditions\n$$\nT(x,y,t) = T_b \\quad \\text{for all } (x,y)\\in \\partial \\Omega, \\; t \\ge 0,\n$$\nand an initial condition of the form\n$$\nT(x,y,0) = T_b + A \\exp\\left(-\\frac{(x - L/2)^2 + (y - L/2)^2}{2\\sigma^2}\\right).\n$$\nUse a uniform Cartesian grid with $N\\times N$ points, spatial step $\\Delta x = \\Delta y = L/(N-1)$, and a uniform time step $\\Delta t$. Evolve the temperature up to a final time $t_{\\text{final}}$ starting from $t=0$. All temperatures must be reported in Kelvin (K), all lengths in meters (m), and all times in seconds (s).\n\nYour task is to compute, for each test case listed below, the following two quantities:\n- The temperature at the plate center grid point $(x=L/2,y=L/2)$ at time $t=t_{\\text{final}}$ (Kelvin).\n- The maximum temperature over all grid points at time $t=t_{\\text{final}}$ (Kelvin).\n\nAssume $N$ is odd so that the grid contains the exact center $(L/2,L/2)$. Treat the boundary values as fixed at $T_b$ for all $t \\ge 0$.\n\nTest Suite (each case specifies $(L,\\alpha,T_b,A,\\sigma,\\Delta t,t_{\\text{final}},N)$):\n- Case $1$: $L=0.1$ m, $\\alpha=1.0\\times 10^{-4}$ m$^2$/s, $T_b=300.0$ K, $A=100.0$ K, $\\sigma=0.01$ m, $\\Delta t=2.5\\times 10^{-4}$ s, $t_{\\text{final}}=0.01$ s, $N=41$.\n- Case $2$: $L=0.1$ m, $\\alpha=1.0\\times 10^{-4}$ m$^2$/s, $T_b=300.0$ K, $A=50.0$ K, $\\sigma=0.02$ m, $\\Delta t=1.0\\times 10^{-3}$ s, $t_{\\text{final}}=0.01$ s, $N=5$.\n- Case $3$: $L=0.1$ m, $\\alpha=1.0\\times 10^{-4}$ m$^2$/s, $T_b=300.0$ K, $A=0.0$ K, $\\sigma=0.01$ m, $\\Delta t=1.0\\times 10^{-3}$ s, $t_{\\text{final}}=0.02$ s, $N=31$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list $[T_{\\text{center}},T_{\\max}]$ in Kelvin. For the three cases above, the required format is\n[ [T_center_case1,T_max_case1], [T_center_case2,T_max_case2], [T_center_case3,T_max_case3] ]\nwith no spaces in the printed output (for example: [[300.123456,350.654321],[...],[...]]). The values are real numbers in Kelvin.", "solution": "The problem statement has been validated and is deemed valid. It presents a well-posed initial-boundary value problem for the two-dimensional heat equation, a fundamental model in physics. All parameters and conditions are specified, allowing for a unique, stable, and meaningful numerical solution.\n\nThe problem requires the numerical solution of the two-dimensional heat equation:\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\left(\\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2}\\right)\n$$\non a square domain $\\Omega = [0,L]\\times[0,L]$ with a spatial grid of $N \\times N$ points. The boundary temperature is fixed at $T(x,y,t) = T_b$ for $(x,y) \\in \\partial\\Omega$, and the initial temperature distribution is given by a Gaussian function superimposed on the boundary temperature.\n\nFor the numerical solution of this parabolic partial differential equation, an implicit finite difference method is appropriate due to its property of unconditional stability. The Alternating-Direction Implicit (ADI) method, specifically the Peaceman-Rachford scheme, is an efficient choice for two-dimensional problems. This method decouples the dimensions by splitting each time step $\\Delta t$ into two half-steps of size $\\Delta t / 2$, transforming the large two-dimensional problem into a series of smaller, independent one-dimensional problems that can be solved very efficiently.\n\nLet $T_{i,j}^n$ represent the temperature at grid point $(x_i, y_j)$ at time $t_n = n\\Delta t$. The spatial grid steps are $\\Delta x = \\Delta y = L/(N-1)$.\n\nThe ADI scheme proceeds in two half-steps to advance the solution from time $t_n$ to $t_{n+1} = t_n + \\Delta t$:\n\nStep 1: Advance from $t_n$ to an intermediate time $t_{n+1/2} = t_n + \\Delta t/2$.\nIn this step, the scheme is implicit in the $x$-direction and explicit in the $y$-direction. The finite difference equation is:\n$$\n\\frac{T_{i,j}^{n+1/2} - T_{i,j}^n}{\\Delta t/2} = \\alpha \\left( \\frac{T_{i-1,j}^{n+1/2} - 2T_{i,j}^{n+1/2} + T_{i+1,j}^{n+1/2}}{\\Delta x^2} + \\frac{T_{i,j-1}^n - 2T_{i,j}^n + T_{i,j+1}^n}{\\Delta y^2} \\right)\n$$\nLet $r = \\frac{\\alpha \\Delta t}{2\\Delta x^2}$ (since $\\Delta x = \\Delta y$). After rearranging the terms to group unknowns at time level $n+1/2$ on the left-hand side, we get:\n$$\n-r T_{i-1,j}^{n+1/2} + (1+2r) T_{i,j}^{n+1/2} - r T_{i+1,j}^{n+1/2} = T_{i,j}^n + r (T_{i,j-1}^n - 2T_{i,j}^n + T_{i,j+1}^n)\n$$\nThis equation is formulated for each interior row $j \\in \\{1, 2, \\dots, N-2\\}$. For a fixed $j$, this is a tridiagonal system of linear equations for the unknown temperatures $T_{i,j}^{n+1/2}$ for $i \\in \\{1, 2, \\dots, N-2\\}$. The boundary values $T_{0,j}^{n+1/2}$ and $T_{N-1,j}^{n+1/2}$ are known and equal to $T_b$. These systems are solved efficiently using the Thomas algorithm (Tridiagonal Matrix Algorithm).\n\nStep 2: Advance from $t_{n+1/2}$ to $t_{n+1}$.\nIn this step, the scheme is explicit in the $x$-direction and implicit in the $y$-direction:\n$$\n\\frac{T_{i,j}^{n+1} - T_{i,j}^{n+1/2}}{\\Delta t/2} = \\alpha \\left( \\frac{T_{i-1,j}^{n+1/2} - 2T_{i,j}^{n+1/2} + T_{i+1,j}^{n+1/2}}{\\Delta x^2} + \\frac{T_{i,j-1}^{n+1} - 2T_{i,j}^{n+1} + T_{i,j+1}^{n+1}}{\\Delta y^2} \\right)\n$$\nRearranging gives a tridiagonal system for the $y$-direction:\n$$\n-r T_{i,j-1}^{n+1} + (1+2r) T_{i,j}^{n+1} - r T_{i,j+1}^{n+1} = T_{i,j}^{n+1/2} + r(T_{i-1,j}^{n+1/2} - 2T_{i,j}^{n+1/2} + T_{i+1,j}^{n+1/2})\n$$\nThis equation is formulated for each interior column $i \\in \\{1, 2, \\dots, N-2\\}$. For a fixed $i$, this forms a tridiagonal system for the unknowns $T_{i,j}^{n+1}$ for $j \\in \\{1, 2, \\dots, N-2\\}$. The boundary values $T_{i,0}^{n+1}$ and $T_{i,N-1}^{n+1}$ are known and equal to $T_b$. These systems are also solved using the Thomas algorithm.\n\nThe overall algorithm is as follows:\n1.  **Initialization**: Define the simulation parameters $(L, \\alpha, T_b, A, \\sigma, \\Delta t, t_{\\text{final}}, N)$. Construct the spatial grid $x_i, y_j$. Calculate the total number of time steps, $N_t = \\lceil t_{\\text{final}} / \\Delta t \\rceil$. Initialize the temperature field $T$ at $t=0$ using the provided Gaussian function. The boundary points are kept fixed at $T_b$. Pre-calculate the parameter $r$. Construct the constant tridiagonal matrix for the linear solves.\n\n2.  **Time Evolution**: Loop for $n$ from $0$ to $N_t-1$:\n    a. Create an intermediate temperature array, $T_{\\text{intermediate}}$.\n    b. For each interior row $j$, assemble the right-hand side vector from the known values in $T^n$ and solve the tridiagonal system for the corresponding row in $T_{\\text{intermediate}}$. The boundary values are enforced by adjusting the right-hand side vector.\n    c. For each interior column $i$, assemble the right-hand side vector from the known values in $T_{\\text{intermediate}}$ and solve the tridiagonal system for the corresponding column in the new temperature array $T^{n+1}$.\n    d. Update the temperature array: $T \\leftarrow T^{n+1}$.\n\n3.  **Result Extraction**: After the final time step, the temperature field $T$ at $t=t_{\\text{final}}$ is obtained. The temperature at the center grid point, $T_{\\text{center}}$, is found at the index $((N-1)/2, (N-1)/2)$. The maximum temperature, $T_{\\max}$, is found by taking the maximum value over the entire grid.\n\nDue to the symmetry of the domain, boundary conditions, and initial condition, the maximum temperature is expected to remain at the geometric center of the plate throughout the simulation. Therefore, it is expected that $T_{\\text{center}} = T_{\\text{max}}$ at $t_{\\text{final}}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve_case(params):\n    \"\"\"\n    Solves the 2D heat equation for a single test case using the ADI method.\n    \"\"\"\n    L, alpha, T_b, A, sigma, dt, t_final, N = params\n    \n    # 1. Initialization\n    dx = L / (N - 1)\n    # The problem asks to treat N as odd, so center index is integer\n    center_idx = (N - 1) // 2\n\n    # Create spatial grid\n    x = np.linspace(0, L, N)\n    y = np.linspace(0, L, N)\n    X, Y = np.meshgrid(x, y)\n\n    # Initialize temperature field from IC\n    T = T_b + A * np.exp(-((X - L/2)**2 + (Y - L/2)**2) / (2 * sigma**2))\n    \n    # Enforce boundary conditions (though IC should be consistent)\n    T[0, :] = T_b\n    T[-1, :] = T_b\n    T[:, 0] = T_b\n    T[:, -1] = T_b\n\n    # ADI parameters\n    r = (alpha * dt) / (2 * dx**2)\n    num_steps = int(np.ceil(t_final / dt))\n\n    # Construct the tridiagonal matrix for the linear solver.\n    # The matrix is for an (N-2) x (N-2) system (interior points).\n    M = N - 2\n    # For solve_banded, the matrix is specified in banded format (3, M)\n    # ab[0,:] = upper diagonal (length M, first element unused)\n    # ab[1,:] = main diagonal (length M)\n    # ab[2,:] = lower diagonal (length M, last element unused)\n    ab = np.zeros((3, M))\n    ab[0, 1:] = -r\n    ab[1, :] = 1 + 2 * r\n    ab[2, :-1] = -r\n    \n    # 2. Time Evolution\n    T_intermediate = np.copy(T)\n\n    for _ in range(num_steps):\n        # --- Step 1: Implicit in x, explicit in y ---\n        for j in range(1, N - 1): # Iterate over interior rows\n            # Construct RHS vector d\n            d = T[j, 1:-1] + r * (T[j-1, 1:-1] - 2*T[j, 1:-1] + T[j+1, 1:-1])\n            # Add boundary contributions\n            d[0] += r * T_b  # Boundary at x=0\n            d[-1] += r * T_b # Boundary at x=L\n\n            # Solve the tridiagonal system for the current row\n            T_intermediate[j, 1:-1] = solve_banded((1, 1), ab, d)\n        \n        # Enforce BC on intermediate solution\n        T_intermediate[0, :] = T_b\n        T_intermediate[-1, :] = T_b\n        T_intermediate[:, 0] = T_b\n        T_intermediate[:, -1] = T_b\n\n        # --- Step 2: Implicit in y, explicit in x ---\n        for i in range(1, N - 1): # Iterate over interior columns\n            # Construct RHS vector d\n            d = T_intermediate[1:-1, i] + r * (T_intermediate[1:-1, i-1] - 2*T_intermediate[1:-1, i] + T_intermediate[1:-1, i+1])\n            # Add boundary contributions\n            d[0] += r * T_b # Boundary at y=0\n            d[-1] += r * T_b # Boundary at y=L\n\n            # Solve the tridiagonal system for the current column\n            T[1:-1, i] = solve_banded((1, 1), ab, d)\n        \n        # Enforce BC on final solution for the step\n        T[0, :] = T_b\n        T[-1, :] = T_b\n        T[:, 0] = T_b\n        T[:, -1] = T_b\n        \n    # 3. Result Extraction\n    T_center = T[center_idx, center_idx]\n    T_max = np.max(T)\n    \n    return [T_center, T_max]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, alpha, T_b, A, sigma, dt, t_final, N)\n        (0.1, 1.0e-4, 300.0, 100.0, 0.01, 2.5e-4, 0.01, 41),\n        (0.1, 1.0e-4, 300.0, 50.0, 0.02, 1.0e-3, 0.01, 5),\n        (0.1, 1.0e-4, 300.0, 0.0, 0.01, 1.0e-3, 0.02, 31),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Format the output string as required\n    results_str = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(results_str)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2402582"}, {"introduction": "Our final practice moves from a single equation to coupled systems, which are essential for modeling many real-world phenomena involving multiple interacting physical quantities. Discretizing a system of partial differential equations, such as a reaction-diffusion model, naturally leads to linear systems with a block-tridiagonal structure. This exercise will guide you through constructing and solving such a system, generalizing the scalar tridiagonal solver and equipping you with the tools to tackle more complex multiphysics problems [@problem_id:2402636].", "problem": "Consider the coupled one-dimensional heat equation for a two-component state vector $w(x,t) = \\begin{bmatrix} u(x,t) \\\\ v(x,t) \\end{bmatrix}$ on the spatial interval $x \\in [0,1]$ and for times $t \\ge 0$, governed by the system\n$$\n\\frac{\\partial w}{\\partial t} = D \\frac{\\partial^2 w}{\\partial x^2} + C\\, w,\n$$\nwhere $D \\in \\mathbb{R}^{2 \\times 2}$ is a constant diffusion matrix and $C \\in \\mathbb{R}^{2 \\times 2}$ is a constant linear coupling (reaction) matrix. All quantities in this problem are non-dimensional and all angles must be interpreted in radians.\n\nLet the spatial grid consist of $N$ interior nodes at positions $x_i = i h$ for $i \\in \\{1,2,\\dots,N\\}$ with uniform spacing $h = \\frac{1}{N+1}$. Use the fully implicit Backward Euler time discretization from time $t^0$ to $t^1 = \\Delta t$, with a second-order centered finite difference for the second spatial derivative at interior nodes. The discrete equation at an interior node $i$ is\n$$\nw_i^{1} - \\Delta t \\, D \\, \\frac{w_{i-1}^{1} - 2 w_i^{1} + w_{i+1}^{1}}{h^2} - \\Delta t \\, C \\, w_i^{1} = w_i^{0},\n$$\nwhere $w_i^{n} \\in \\mathbb{R}^2$ denotes the approximation to $w(x_i, t^n)$ at time level $n \\in \\{0,1\\}$. This leads to a block-tridiagonal linear system for the unknowns $\\{w_i^{1}\\}_{i=1}^N$ with $2 \\times 2$ blocks.\n\nBoundary conditions:\n- A homogeneous Dirichlet boundary condition at an endpoint enforces $w = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$ at that endpoint. Its effect is incorporated by moving boundary contributions to the right-hand side where they appear in the finite difference stencil.\n- A homogeneous Neumann boundary condition at the right endpoint $x=1$ enforces $\\frac{\\partial w}{\\partial x}(1,t)=\\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$. Implement this by the standard ghost-point elimination, which at the last interior node $i=N$ replaces $w_{N+1}^{1}$ by $w_{N-1}^{1}$ in the second-difference operator, so that\n$$\n\\frac{w_{N-1}^{1} - 2 w_N^{1} + w_{N+1}^{1}}{h^2} \\;\\; \\text{becomes} \\;\\; \\frac{2 w_{N-1}^{1} - 2 w_N^{1}}{h^2}.\n$$\n\nInitial condition at time $t^0$ is prescribed pointwise at interior nodes by $w_i^{0} = \\begin{bmatrix} u_i^0 \\\\ v_i^0 \\end{bmatrix}$ according to each test case below.\n\nYour task is to write a complete program that:\n- Constructs the block-tridiagonal linear system arising from the above discretization for each test case.\n- Solves for $w^{1}$ without requiring any user input.\n- For each test case, returns a single scalar equal to the Euclidean norm of the stacked vector of all components of $w^{1}$ at the $N$ interior nodes, that is,\n$$\n\\left\\| \\begin{bmatrix} u_1^{1} \\\\ v_1^{1} \\\\ \\vdots \\\\ u_N^{1} \\\\ v_N^{1} \\end{bmatrix} \\right\\|_2.\n$$\n\nTest suite:\n- Case $1$ (general symmetric diffusion, no reaction, homogeneous Dirichlet boundaries):\n  - $N = 5$, $\\Delta t = 0.01$.\n  - $D = \\begin{bmatrix} 0.1 & 0.02 \\\\ 0.02 & 0.08 \\end{bmatrix}$, $C = \\begin{bmatrix} 0 & 0 \\\\ 0 & 0 \\end{bmatrix}$.\n  - Boundary conditions: Dirichlet at $x=0$ and $x=1$ with $w=\\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n  - Initial condition for $i \\in \\{1,\\dots,N\\}$ at $x_i = i h$: $u_i^0 = \\sin(\\pi x_i)$, $v_i^0 = \\cos(\\pi x_i)$.\n- Case $2$ (decoupled diffusion and decay, mixed boundary conditions with homogeneous Neumann at right):\n  - $N = 4$, $\\Delta t = 0.02$.\n  - $D = \\begin{bmatrix} 0.05 & 0 \\\\ 0 & 0.2 \\end{bmatrix}$, $C = \\begin{bmatrix} -1.0 & 0 \\\\ 0 & -0.5 \\end{bmatrix}$.\n  - Boundary conditions: Dirichlet at $x=0$ with $w=\\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$; homogeneous Neumann at $x=1$.\n  - Initial condition: $u_i^0 = x_i$, $v_i^0 = 1 - x_i$.\n- Case $3$ (strongly coupled diffusion and reaction, homogeneous Dirichlet boundaries):\n  - $N = 3$, $\\Delta t = 0.05$.\n  - $D = \\begin{bmatrix} 0.15 & 0.10 \\\\ 0.12 & 0.18 \\end{bmatrix}$, $C = \\begin{bmatrix} -0.3 & 0.05 \\\\ -0.07 & -0.25 \\end{bmatrix}$.\n  - Boundary conditions: Dirichlet at $x=0$ and $x=1$ with $w=\\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n  - Initial condition: $u_i^0 = \\sin(2\\pi x_i)$, $v_i^0 = \\sin(3\\pi x_i)$.\n\nAll computations are to be carried out in exact arithmetic of the implementation language with no stochastic elements. Angles appearing in the sine and cosine functions are in radians.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of cases $1$, $2$, $3$, with each floating-point number rounded to $10$ decimal places. For example, the printed line must look like\n[r_1,r_2,r_3],\nwhere each r_k is the requested Euclidean norm for case $k$ rounded to $10$ decimal places.", "solution": "The problem presented is a well-posed problem in computational physics. It is scientifically grounded, self-contained, and possesses a clear, objective formulation. It describes the numerical solution of a system of coupled linear reaction-diffusion partial differential equations using a standard, stable implicit finite difference method. All necessary parameters, initial conditions, and boundary conditions are provided. Therefore, we proceed with a complete solution.\n\nThe governing system of equations is given by:\n$$\n\\frac{\\partial w}{\\partial t} = D \\frac{\\partial^2 w}{\\partial x^2} + C w\n$$\nwhere $w(x,t) = \\begin{bmatrix} u(x,t) \\\\ v(x,t) \\end{bmatrix}$ is the state vector, $D \\in \\mathbb{R}^{2 \\times 2}$ is the diffusion matrix, and $C \\in \\mathbb{R}^{2 \\times 2}$ is the reaction matrix. The spatial domain is $x \\in [0, 1]$ and time $t \\ge 0$.\n\nWe discretize this system in space and time. The spatial domain is divided into $N+1$ segments of uniform width $h = \\frac{1}{N+1}$, yielding $N$ interior grid points $x_i = i h$ for $i \\in \\{1, 2, \\dots, N\\}$. We use a second-order centered finite difference approximation for the spatial derivative:\n$$\n\\frac{\\partial^2 w}{\\partial x^2} \\bigg|_{x_i} \\approx \\frac{w(x_{i-1}, t) - 2 w(x_i, t) + w(x_{i+1}, t)}{h^2}\n$$\nFor time stepping from $t^0$ to $t^1 = t^0 + \\Delta t$, we employ the fully implicit Backward Euler method. Let $w_i^n$ denote the numerical approximation of $w(x_i, t^n)$. The discretized equation at an interior node $i$ is:\n$$\n\\frac{w_i^1 - w_i^0}{\\Delta t} = D \\left( \\frac{w_{i-1}^1 - 2 w_i^1 + w_{i+1}^1}{h^2} \\right) + C w_i^1\n$$\nThis equation is rearranged to group all unknown terms (at time level $n=1$) on the left-hand side (LHS) and known terms (at time level $n=0$) on the right-hand side (RHS):\n$$\n- \\left(\\frac{\\Delta t}{h^2} D\\right) w_{i-1}^1 + \\left(I + \\frac{2 \\Delta t}{h^2} D - \\Delta t C\\right) w_i^1 - \\left(\\frac{\\Delta t}{h^2} D\\right) w_{i+1}^1 = w_i^0\n$$\nwhere $I$ is the $2 \\times 2$ identity matrix.\n\nThis structure gives rise to a block-tridiagonal linear system for the unknown vectors $\\{w_i^1\\}_{i=1}^N$. Let us define the $2 \\times 2$ block matrices:\n- Lower diagonal blocks: $L = - \\frac{\\Delta t}{h^2} D$\n- Upper diagonal blocks: $U = - \\frac{\\Delta t}{h^2} D$\n- Main diagonal blocks: $M = I + \\frac{2 \\Delta t}{h^2} D - \\Delta t C$\n\nThe system for the interior nodes takes the form $L w_{i-1}^1 + M w_i^1 + U w_{i+1}^1 = w_i^0$. If we stack the unknown vectors into a single column vector $W^1 = [w_1^1, w_2^1, \\dots, w_N^1]^T \\in \\mathbb{R}^{2N}$ and the initial condition vectors similarly into $W^0$, the system is $\\mathcal{A} W^1 = W^0$. The structure of the $2N \\times 2N$ matrix $\\mathcal{A}$ depends on the boundary conditions.\n\n**Boundary Conditions**\n\n1.  **Homogeneous Dirichlet Conditions at $x=0$ and $x=1$ (Cases $1$ and $3$)**:\n    The conditions are $w(0,t)=0$ and $w(1,t)=0$, which in discrete form are $w_0^1=0$ and $w_{N+1}^1=0$.\n    For the first interior node ($i=1$), the equation is $L w_0^1 + M w_1^1 + U w_2^1 = w_1^0$. Since $w_0^1=0$, this simplifies to $M w_1^1 + U w_2^1 = w_1^0$.\n    For the last interior node ($i=N$), the equation is $L w_{N-1}^1 + M w_N^1 + U w_{N+1}^1 = w_N^0$. Since $w_{N+1}^1=0$, this simplifies to $L w_{N-1}^1 + M w_N^1 = w_N^0$.\n    The resulting block-tridiagonal matrix, $\\mathcal{A}_{\\text{DD}}$, is:\n    $$\n    \\mathcal{A}_{\\text{DD}} = \\begin{bmatrix}\n    M & U & 0 & \\dots \\\\\n    L & M & U & \\\\\n    0 & \\ddots & \\ddots & \\ddots \\\\\n      & & L & M & U \\\\\n      & \\dots & 0 & L & M\n    \\end{bmatrix}\n    $$\n\n2.  **Mixed: Dirichlet at $x=0$, Neumann at $x=1$ (Case $2$)**:\n    The condition at $x=0$ is $w_0^1=0$, handled as above.\n    The homogeneous Neumann condition at $x=1$ is $\\frac{\\partial w}{\\partial x}(1, t) = 0$. This is approximated using a ghost point $x_{N+1}$ such that $\\frac{w_{N+1}^1-w_{N-1}^1}{2h} = 0$, implying $w_{N+1}^1 = w_{N-1}^1$.\n    Substituting this into the finite difference stencil at $i=N$, $\\frac{w_{N-1}^1-2w_N^1+w_{N+1}^1}{h^2}$, yields $\\frac{2w_{N-1}^1 - 2w_N^1}{h^2}$.\n    The PDE discretization at $i=N$ becomes:\n    $$\n    w_N^1 - \\Delta t D \\left( \\frac{2w_{N-1}^1 - 2w_N^1}{h^2} \\right) - \\Delta t C w_N^1 = w_N^0\n    $$\n    Rearranging gives:\n    $$\n    \\left(- \\frac{2 \\Delta t}{h^2} D\\right) w_{N-1}^1 + \\left(I + \\frac{2 \\Delta t}{h^2} D - \\Delta t C\\right) w_N^1 = w_N^0\n    $$\n    In terms of our block matrices, this is $(2L) w_{N-1}^1 + M w_N^1 = w_N^0$.\n    The resulting block matrix, $\\mathcal{A}_{\\text{DN}}$, is:\n    $$\n    \\mathcal{A}_{\\text{DN}} = \\begin{bmatrix}\n    M & U & 0 & \\dots \\\\\n    L & M & U & \\\\\n    \\ddots & \\ddots & \\ddots & \\\\\n      & L & M & U \\\\\n      \\dots & 0 & 2L & M\n    \\end{bmatrix}\n    $$\n\n**Solution Procedure**\n\nFor each test case, the following steps are executed:\n1.  Define the parameters $N, \\Delta t, D, C$, the boundary condition type, and the initial condition function.\n2.  Calculate the grid spacing $h = 1/(N+1)$.\n3.  Compute the $2 \\times 2$ block matrices $L$, $U$, and $M$.\n4.  Construct the $2N \\times 2N$ system matrix $\\mathcal{A}$ according to the specified boundary conditions.\n5.  Construct the $2N \\times 1$ right-hand side vector $W^0$ by evaluating the initial condition at each interior grid point $x_i = i h$ for $i \\in \\{1, \\dots, N\\}$.\n6.  Solve the linear system $\\mathcal{A} W^1 = W^0$ for the solution vector $W^1$.\n7.  Compute the Euclidean norm of the resulting vector $W^1$, which is $\\left\\| [u_1^1, v_1^1, \\dots, u_N^1, v_N^1]^T \\right\\|_2$.\nThis procedure is deterministic and will be implemented computationally.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(N, dt, D, C, bc_type, ic_func):\n    \"\"\"\n    Solves one case of the coupled heat equation problem.\n\n    Args:\n        N (int): Number of interior spatial nodes.\n        dt (float): Time step size.\n        D (np.ndarray): 2x2 diffusion matrix.\n        C (np.ndarray): 2x2 reaction matrix.\n        bc_type (str): Boundary condition type, 'DD' for Dirichlet-Dirichlet,\n                       'DN' for Dirichlet-Neumann.\n        ic_func (callable): Function taking x and returning the initial \n                          condition vector [u0, v0].\n\n    Returns:\n        float: The Euclidean norm of the solution vector at time dt.\n    \"\"\"\n    dim = 2  # Dimension of the state vector w\n    h = 1.0 / (N + 1)\n    \n    I_block = np.eye(dim)\n    \n    # Define block matrices\n    factor = dt / (h**2)\n    L_block = -factor * D\n    U_block = -factor * D\n    M_block = I_block + 2 * factor * D - dt * C\n\n    # Construct the full system matrix A of size (dim*N) x (dim*N)\n    A = np.zeros((dim * N, dim * N))\n    \n    for i in range(N):\n        # Main diagonal block\n        A[dim*i : dim*(i+1), dim*i : dim*(i+1)] = M_block\n        \n        # Upper diagonal block\n        if i < N - 1:\n            A[dim*i : dim*(i+1), dim*(i+1) : dim*(i+2)] = U_block\n            \n        # Lower diagonal block\n        if i > 0:\n            A[dim*i : dim*(i+1), dim*(i-1) : dim*i] = L_block\n\n    # Apply boundary condition modifications\n    if bc_type == 'DN':\n        # Modify the last block row for Neumann condition at x=1\n        A[dim*(N-1) : dim*N, dim*(N-2) : dim*(N-1)] = 2 * L_block\n        \n    # Construct the right-hand side vector W0\n    W0 = np.zeros(dim * N)\n    for i in range(1, N + 1):\n        x_i = i * h\n        w_i_0 = ic_func(x_i)\n        W0[dim*(i-1) : dim*i] = w_i_0\n\n    # Solve the linear system A * W1 = W0\n    try:\n        W1 = np.linalg.solve(A, W0)\n    except np.linalg.LinAlgError:\n        # This should not happen for a well-posed problem with stable discretization\n        return np.nan\n\n    # Calculate and return the Euclidean norm of the solution vector\n    return np.linalg.norm(W1)\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run them, and print results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 5, \n            \"dt\": 0.01,\n            \"D\": np.array([[0.1, 0.02], [0.02, 0.08]]),\n            \"C\": np.array([[0.0, 0.0], [0.0, 0.0]]),\n            \"bc_type\": \"DD\",\n            \"ic_func\": lambda x: np.array([np.sin(np.pi * x), np.cos(np.pi * x)])\n        },\n        {\n            \"N\": 4, \n            \"dt\": 0.02,\n            \"D\": np.array([[0.05, 0.0], [0.0, 0.2]]),\n            \"C\": np.array([[-1.0, 0.0], [0.0, -0.5]]),\n            \"bc_type\": \"DN\",\n            \"ic_func\": lambda x: np.array([x, 1.0 - x])\n        },\n        {\n            \"N\": 3, \n            \"dt\": 0.05,\n            \"D\": np.array([[0.15, 0.10], [0.12, 0.18]]),\n            \"C\": np.array([[-0.3, 0.05], [-0.07, -0.25]]),\n            \"bc_type\": \"DD\",\n            \"ic_func\": lambda x: np.array([np.sin(2 * np.pi * x), np.sin(3 * np.pi * x)])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(\n            N=case[\"N\"],\n            dt=case[\"dt\"],\n            D=case[\"D\"],\n            C=case[\"C\"],\n            bc_type=case[\"bc_type\"],\n            ic_func=case[\"ic_func\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "2402636"}]}