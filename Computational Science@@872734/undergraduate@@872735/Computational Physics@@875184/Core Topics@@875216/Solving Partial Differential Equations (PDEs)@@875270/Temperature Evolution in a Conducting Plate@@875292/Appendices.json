{"hands_on_practices": [{"introduction": "This first practice grounds your understanding in the direct simulation of the time-dependent heat equation. You will model the temperature evolution on a plate with mixed boundary conditions—periodic in one direction to simulate a thin cylinder, and insulated in the other. This exercise [@problem_id:2445101] is essential for mastering the implementation of finite difference schemes and handling boundary conditions that reflect realistic physical geometries.", "problem": "Consider a thin conducting plate of uniform thickness modeled as a two-dimensional domain with coordinates $x \\in [0,L_x)$ and $y \\in [0,L_y]$. The temperature field $T(x,y,t)$ evolves according to the Heat Equation, a Partial Differential Equation (PDE), given by\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\left( \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} \\right) + s(x,y,t),\n$$\nwhere $\\alpha$ is the constant thermal diffusivity and $s(x,y,t)$ is a volumetric heating term expressed in units of temperature rate. The boundary condition in the $x$-direction is periodic, meaning $T(0,y,t) = T(L_x,y,t)$ for all $y$ and $t$, which models a thin cylindrical shell obtained by identifying the edges $x=0$ and $x=L_x$. The $y$-direction boundary is thermally insulated (zero normal heat flux), meaning $\\frac{\\partial T}{\\partial y}(x,0,t)=0$ and $\\frac{\\partial T}{\\partial y}(x,L_y,t)=0$ for all $x$ and $t$. The initial condition is uniform: $T(x,y,0) = T_0$ everywhere.\n\nThe source term $s(x,y,t)$ represents a linear heating strip that is uniform along $x$ and confined to a band in $y$. It is defined by\n$$\ns(x,y,t) =\n\\begin{cases}\nH, & \\text{if } y \\in [y_1,y_2] \\text{ and } t \\in [0,\\tau],\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nwith $H$ a constant heating rate. All temperatures must be expressed in Kelvin, all lengths in meters, and all times in seconds. Angles do not appear in this problem. The material and geometry are spatially uniform, and the plate properties do not vary in time.\n\nYour program must numerically evolve $T(x,y,t)$ to a specified final time $t=t_f$ for several parameter sets and then report, for each set:\n- The temperature at the point $(x^\\ast,y^\\ast) = (L_x/4, L_y/2)$ at time $t_f$ (in Kelvin).\n- The temperature at the point $(x^\\ast,y^\\ast) = (3L_x/4, L_y/2)$ at time $t_f$ (in Kelvin).\n- The spatial area average of $T(\\cdot,\\cdot,t_f)$ over the plate (in Kelvin).\n\nTo ensure unambiguous evaluation of the required pointwise quantities, use a uniform grid in $x$ and $y$ defined by the node coordinates $x_i = i\\,L_x/N_x$ for $i \\in \\{0,1,\\dots,N_x-1\\}$ and $y_j = j\\,L_y/(N_y-1)$ for $j \\in \\{0,1,\\dots,N_y-1\\}$. For all test cases below, $(L_x/4, L_y/2)$ and $(3L_x/4, L_y/2)$ coincide with grid nodes under this convention. The area average is the continuous spatial average over the rectangular domain and must be reported in Kelvin.\n\nUse the following material parameter for all tests:\n- Thermal diffusivity $\\alpha = 1.11\\times 10^{-4}\\ \\text{m}^2/\\text{s}$.\n\nUse the following test suite of parameter sets. In each case, the plate is initially at $T_0 = 300\\ \\text{K}$, and $s(x,y,t)$ is specified by a strip of width $w$ and duration $\\tau$ as described above. All outputs must be expressed in Kelvin and rounded to three decimal places.\n\nTest Case A (central strip, heating turns off before $t_f$):\n- $L_x = 0.2\\ \\text{m}$, $L_y = 0.1\\ \\text{m}$.\n- $N_x = 64$, $N_y = 33$, $\\Delta t = 0.002\\ \\text{s}$, $t_f=1.0\\ \\text{s}$.\n- $H = 50\\ \\text{K/s}$, $w = 0.01\\ \\text{m}$, $\\tau = 0.5\\ \\text{s}$.\n- The strip occupies $y \\in [y_1,y_2]$ with $y_1 = (L_y - w)/2$ and $y_2 = (L_y + w)/2$.\n\nTest Case B (strip at the lower insulated edge):\n- $L_x = 0.2\\ \\text{m}$, $L_y = 0.1\\ \\text{m}$.\n- $N_x = 48$, $N_y = 25$, $\\Delta t = 0.002\\ \\text{s}$, $t_f=0.4\\ \\text{s}$.\n- $H = 100\\ \\text{K/s}$, $w = 0.01\\ \\text{m}$, $\\tau = 0.2\\ \\text{s}$.\n- The strip occupies $y \\in [y_1,y_2]$ with $y_1 = 0$ and $y_2 = w$.\n\nTest Case C (no heating):\n- $L_x = 0.2\\ \\text{m}$, $L_y = 0.1\\ \\text{m}$.\n- $N_x = 32$, $N_y = 17$, $\\Delta t = 0.002\\ \\text{s}$, $t_f=0.3\\ \\text{s}$.\n- $H = 0\\ \\text{K/s}$, $w = 0.01\\ \\text{m}$, $\\tau = 0.0\\ \\text{s}$.\n- The strip location is irrelevant.\n\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. The list must be ordered as\n$$\n[\\ T^{(A)}(L_x/4,L_y/2,t_f),\\ T^{(A)}(3L_x/4,L_y/2,t_f),\\ \\overline{T}^{(A)}(t_f),\\ T^{(B)}(L_x/4,L_y/2,t_f),\\ T^{(B)}(3L_x/4,L_y/2,t_f),\\ \\overline{T}^{(B)}(t_f),\\ T^{(C)}(L_x/4,L_y/2,t_f),\\ T^{(C)}(3L_x/4,L_y/2,t_f),\\ \\overline{T}^{(C)}(t_f)\\ ],\n$$\nwith each entry in Kelvin rounded to three decimal places, where $T^{(\\cdot)}$ denotes the temperature field in the indicated test case and $\\overline{T}^{(\\cdot)}(t_f)$ denotes the spatial area average at time $t_f$.", "solution": "The problem presented is a well-posed initial-boundary value problem for the two-dimensional linear heat equation. It is scientifically grounded, requires a numerical solution, and provides all necessary parameters and conditions. The problem is therefore valid. I will proceed with the solution.\n\nThe governing partial differential equation (PDE) is the heat equation with a source term $s(x,y,t)$:\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\left( \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} \\right) + s(x,y,t)\n$$\nThis equation describes the evolution of the temperature field $T(x,y,t)$ in a domain $x \\in [0,L_x)$, $y \\in [0,L_y]$ with thermal diffusivity $\\alpha$.\n\nThe numerical solution will be obtained using the Finite Difference Method (FDM). I will employ the explicit Forward-Time, Central-Space (FTCS) scheme due to its direct implementation. The continuous domain is discretized into a grid of points $(x_i, y_j, t_n)$ where $x_i = i \\Delta x$, $y_j = j \\Delta y$, and $t_n = n \\Delta t$. The grid parameters are given as $N_x$ and $N_y$, so the spatial steps are $\\Delta x = L_x / N_x$ and $\\Delta y = L_y / (N_y - 1)$. The temperature at a grid point is denoted $T_{i,j}^n \\approx T(x_i, y_j, t_n)$.\n\nThe partial derivatives are approximated as follows:\n- Time derivative (first-order forward difference):\n$$\n\\frac{\\partial T}{\\partial t} \\approx \\frac{T_{i,j}^{n+1} - T_{i,j}^n}{\\Delta t}\n$$\n- Spatial derivatives (second-order central differences):\n$$\n\\frac{\\partial^2 T}{\\partial x^2} \\approx \\frac{T_{i+1,j}^n - 2T_{i,j}^n + T_{i-1,j}^n}{\\Delta x^2}\n$$\n$$\n\\frac{\\partial^2 T}{\\partial y^2} \\approx \\frac{T_{i,j+1}^n - 2T_{i,j}^n + T_{i,j-1}^n}{\\Delta y^2}\n$$\nSubstituting these into the heat equation yields the explicit update rule for the temperature at the next time step, $T_{i,j}^{n+1}$:\n$$\nT_{i,j}^{n+1} = T_{i,j}^n + \\Delta t \\left[ \\alpha \\left( \\frac{T_{i+1,j}^n - 2T_{i,j}^n + T_{i-1,j}^n}{\\Delta x^2} + \\frac{T_{i,j+1}^n - 2T_{i,j}^n + T_{i,j-1}^n}{\\Delta y^2} \\right) + s_{i,j}^n \\right]\n$$\nThis scheme is stable under the Courant-Friedrichs-Lewy (CFL) condition, which for the 2D heat equation is $\\alpha \\Delta t \\left( \\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta y^2} \\right) \\le \\frac{1}{2}$. The parameters given for all test cases satisfy this condition, guaranteeing a stable numerical solution.\n\nThe boundary conditions must be correctly implemented in the finite difference scheme:\n1.  **Periodic boundary in $x$:** $T(0,y,t) = T(L_x,y,t)$. On the discrete grid, this implies $T_{0,j}^n = T_{N_x,j}^n$. The neighbors of a point at $i=0$ are $i=1$ and $i=N_x-1$. For a point at $i=N_x-1$, the neighbors are $i=N_x-2$ and $i=0$. This is efficiently implemented using a circular shift operation on the data array corresponding to the $x$-axis.\n\n2.  **Insulated (Neumann) boundary in $y$:** $\\frac{\\partial T}{\\partial y} = 0$ at $y=0$ ($j=0$) and $y=L_y$ ($j=N_y-1$). A second-order accurate central difference for the derivative using a \"ghost point\" outside the domain is employed. For $j=0$, the condition $\\frac{T_{i,1}^n - T_{i,-1}^n}{2\\Delta y} = 0$ implies the ghost point value $T_{i,-1}^n = T_{i,1}^n$. The Laplacian term at $j=0$ becomes:\n    $$\n    \\left. \\frac{\\partial^2 T}{\\partial y^2} \\right|_{j=0} \\approx \\frac{T_{i,1}^n - 2T_{i,0}^n + T_{i,-1}^n}{\\Delta y^2} = \\frac{2(T_{i,1}^n - T_{i,0}^n)}{\\Delta y^2}\n    $$\n    Similarly, for $j=N_y-1$, the ghost point $T_{i,N_y}^n = T_{i,N_y-2}^n$, and the Laplacian term is:\n    $$\n    \\left. \\frac{\\partial^2 T}{\\partial y^2} \\right|_{j=N_y-1} \\approx \\frac{2(T_{i,N_y-2}^n - T_{i,N_y-1}^n)}{\\Delta y^2}\n    $$\n\nThe simulation starts from the uniform initial condition $T(x,y,0) = T_0$. The FTCS update rule is applied iteratively for a total number of steps equal to $t_f/ \\Delta t$. The source term $s_{i,j}^n$ is applied at each step, taking the value $H$ if the grid point $(x_i, y_j)$ is within the heating strip and the current time $t_n$ is less than $\\tau$, and $0$ otherwise.\n\nAfter the final time $t_f$ is reached, the required quantities are extracted from the final temperature field $T_{i,j}^{final}$:\n-   **Pointwise temperatures:** The values are read directly from the grid nodes corresponding to $(L_x/4, L_y/2)$ and $(3L_x/4, L_y/2)$. The grid is constructed such that these are exact grid points with indices $i = N_x/4$ (or $i=3N_x/4$) and $j = (N_y-1)/2$.\n-   **Spatial area average:** The continuous average $\\overline{T}(t_f) = \\frac{1}{L_x L_y} \\iint T(x,y,t_f) \\,dx\\,dy$ is computed numerically. The integral is evaluated using a composite quadrature rule. Due to periodicity in $x$, the integral $\\int_0^{L_x} f(x) dx$ is best approximated by a rectangular rule: $\\Delta x \\sum_{i=0}^{N_x-1} f(x_i)$. For the non-periodic $y$ direction, the trapezoidal rule is appropriate: $\\int_0^{L_y} g(y) dy \\approx \\text{np.trapz}(g, \\text{dx=}\\Delta y)$. Combining these, the double integral is computed by first integrating along the $y$-axis for each $x_i$ using the trapezoidal rule, and then summing the results along the $x$-axis, scaled by $\\Delta x$. The final value is this integral divided by the total area $L_x L_y$.\n\nAs a verification, the evolution of the area-averaged temperature can be determined analytically. Integrating the PDE over the domain and applying the divergence theorem with the given zero-flux boundary conditions yields $\\frac{d\\overline{T}}{dt} = \\frac{1}{L_y} H w$ for $t \\le \\tau$, and $0$ for $t > \\tau$. The solution is $\\overline{T}(t_f) = T_0 + \\frac{Hw}{L_y} \\min(t_f, \\tau)$. For Case C where $H=0$, the temperature field must remain constant at $T_0=300\\,\\text{K}$ for all time. These analytical results serve as a rigorous check on the numerical implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D heat equation for the specified test cases and prints the results.\n    \"\"\"\n    \n    # Material parameter\n    ALPHA = 1.11e-4  # m^2/s\n    T0 = 300.0  # K\n\n    test_cases = [\n        # Test Case A\n        {\n            \"Lx\": 0.2, \"Ly\": 0.1, \"Nx\": 64, \"Ny\": 33, \n            \"dt\": 0.002, \"tf\": 1.0, \n            \"H\": 50.0, \"w\": 0.01, \"tau\": 0.5,\n            \"strip_type\": \"central\"\n        },\n        # Test Case B\n        {\n            \"Lx\": 0.2, \"Ly\": 0.1, \"Nx\": 48, \"Ny\": 25, \n            \"dt\": 0.002, \"tf\": 0.4, \n            \"H\": 100.0, \"w\": 0.01, \"tau\": 0.2,\n            \"strip_type\": \"lower_edge\"\n        },\n        # Test Case C\n        {\n            \"Lx\": 0.2, \"Ly\": 0.1, \"Nx\": 32, \"Ny\": 17, \n            \"dt\": 0.002, \"tf\": 0.3,\n            \"H\": 0.0, \"w\": 0.01, \"tau\": 0.0,\n            \"strip_type\": \"irrelevant\"\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Extract parameters\n        Lx, Ly, Nx, Ny = case[\"Lx\"], case[\"Ly\"], case[\"Nx\"], case[\"Ny\"]\n        dt, tf = case[\"dt\"], case[\"tf\"]\n        H, w, tau = case[\"H\"], case[\"w\"], case[\"tau\"]\n        strip_type = case[\"strip_type\"]\n\n        # Grid setup\n        dx = Lx / Nx\n        dy = Ly / (Ny - 1)\n        \n        # Grid coordinates\n        y_coords = np.linspace(0, Ly, Ny)\n        x_coords = np.linspace(0, Lx, Nx, endpoint=False)\n\n        # Initialize temperature field\n        T = np.full((Ny, Nx), T0, dtype=np.float64)\n\n        # Define heating strip location\n        if strip_type == \"central\":\n            y1 = (Ly - w) / 2\n            y2 = (Ly + w) / 2\n        elif strip_type == \"lower_edge\":\n            y1 = 0.0\n            y2 = w\n        else: # \"irrelevant\" or other\n            y1, y2 = -1.0, -1.0 # No heating should occur\n\n        # Pre-calculate source term mask\n        source_mask = np.zeros_like(T)\n        if H > 0:\n            # Add a small epsilon for robust float comparison at boundaries\n            y_indices = np.where((y_coords >= y1 - 1e-9)  (y_coords = y2 + 1e-9))[0]\n            source_mask[y_indices, :] = H\n\n        # Time-stepping loop\n        num_steps = int(round(tf / dt))\n        for n in range(num_steps):\n            # Calculate laplacian\n            # x-direction (periodic)\n            T_xx = (np.roll(T, -1, axis=1) - 2 * T + np.roll(T, 1, axis=1)) / (dx * dx)\n            \n            # y-direction (Neumann)\n            T_yy = np.zeros_like(T)\n            # Interior points\n            T_yy[1:-1, :] = (T[2:, :] - 2 * T[1:-1, :] + T[:-2, :]) / (dy * dy)\n            # Boundary y=0\n            T_yy[0, :] = 2 * (T[1, :] - T[0, :]) / (dy * dy)\n            # Boundary y=Ly\n            T_yy[-1, :] = 2 * (T[-2, :] - T[-1, :]) / (dy * dy)\n            \n            laplacian = T_xx + T_yy\n            \n            # Current source term\n            current_time = (n + 1) * dt # time at end of step\n            s_current = source_mask if current_time = tau else 0.0\n            \n            # Update temperature using FTCS scheme\n            T += dt * (ALPHA * laplacian + s_current)\n        \n        # --- Post-processing ---\n        \n        # 1. Pointwise temperatures\n        # Indices for (Lx/4, Ly/2) and (3Lx/4, Ly/2)\n        ix1 = Nx // 4\n        ix2 = 3 * Nx // 4\n        iy = (Ny - 1) // 2\n        \n        T_pt1 = T[iy, ix1]\n        T_pt2 = T[iy, ix2]\n        \n        # 2. Spatial area average\n        # Integrate along y (non-periodic) using trapezoidal rule\n        integral_y = np.trapz(T, dx=dy, axis=0) # Result is a 1D array of size Nx\n        # Integrate along x (periodic) using rectangular rule (summation)\n        total_integral = np.sum(integral_y) * dx\n        avg_T = total_integral / (Lx * Ly)\n\n        # Store results for this case\n        all_results.extend([T_pt1, T_pt2, avg_T])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.3f}' for val in all_results)}]\")\n\nsolve()\n```", "id": "2445101"}, {"introduction": "Moving from transient behavior to equilibrium, this practice challenges you to solve a steady-state thermal design problem. Instead of simply predicting temperature, you will determine the optimal placement of cooling channels to minimize heat in a critical area, governed by the Poisson equation. This task [@problem_id:2445124] shifts the focus from simulation to optimization, a crucial skill in engineering and applied physics where computational models are used to design better systems.", "problem": "You are asked to formulate, discretize, and solve an optimization problem for the steady-state temperature field in a thin, homogeneous, isotropic, square conducting plate with internal heat generation over a designated hot area and a set of discrete candidate locations for internal cooling channels idealized as line sinks per unit thickness. Your task is to compute, for several specified test cases, the minimal achievable average temperature over the hot area when placing a fixed number of cooling channels at distinct candidate nodes, subject to fixed ambient temperature at the plate boundary. You must implement a complete program that performs the following: (i) construct a mathematically consistent model based on first principles, (ii) discretize the steady-state governing equation on a uniform grid using the Finite Difference Method (FDM), (iii) solve the resulting linear systems for all combinations of cooling channel placements of a given cardinality, and (iv) report the minimal average temperature over the hot area, expressed in kelvin and rounded to three decimal places, for each test case.\n\nFundamental modeling base. Start from conservation of energy and Fourier’s law of heat conduction. For a thin plate whose thermal conductivity is constant and equal to $k$ (in $\\mathrm{W\\,m^{-1}\\,K^{-1}}$), neglecting convection and radiation within the interior, the steady-state temperature field $T(x,y)$ satisfies\n$$\n\\nabla \\cdot \\left( k \\nabla T \\right) + q_{\\text{hot}}(x,y) - q_{\\text{sink}}(x,y) = 0,\n$$\nwhere $q_{\\text{hot}}(x,y)$ is the volumetric heat generation (in $\\mathrm{W\\,m^{-3}}$) localized to the designated hot area, and $q_{\\text{sink}}(x,y)$ is a sum of localized volumetric sink terms representing cooling channels per unit thickness. With constant $k$, this becomes\n$$\n\\nabla^2 T(x,y) = \\frac{q_{\\text{sink}}(x,y) - q_{\\text{hot}}(x,y)}{k}.\n$$\nImpose Dirichlet Boundary Conditions (BCs) $T = T_{\\text{amb}}$ (in $\\mathrm{K}$) on the entire plate boundary.\n\nDiscretization. Consider a square domain of side length $L$ (in $\\mathrm{m}$), discretized on a uniform grid of $N \\times N$ nodes with spacing $h = L/(N-1)$. Use the standard $5$-point stencil finite difference discretization of the Laplacian. For an interior grid node with index $(i,j)$, let $T_{i,j}$ denote the discrete temperature. The discrete equation is\n$$\n\\frac{T_{i+1,j} + T_{i-1,j} + T_{i,j+1} + T_{i,j-1} - 4 T_{i,j}}{h^2} = \\frac{q_{\\text{sink},i,j} - q_{\\text{hot},i,j}}{k}.\n$$\nFor boundary nodes, enforce the Dirichlet condition $T_{i,j} = T_{\\text{amb}}$. Represent $q_{\\text{hot},i,j}$ as a constant $q_{\\text{hot}}$ (in $\\mathrm{W\\,m^{-3}}$) on the specified hot-area indices and zero elsewhere. Model each cooling channel as contributing a constant volumetric sink $s$ (in $\\mathrm{W\\,m^{-3}}$) at its node; if channels are placed at node indices in a set $\\mathcal{S}$, then $q_{\\text{sink},i,j} = s$ for $(i,j) \\in \\mathcal{S}$ and zero otherwise.\n\nOptimization task. For each test case below, you are given:\n- Plate side length $L$ (in $\\mathrm{m}$),\n- Grid size $N$ (dimensionless),\n- Thermal conductivity $k$ (in $\\mathrm{W\\,m^{-1}\\,K^{-1}}$),\n- Ambient boundary temperature $T_{\\text{amb}}$ (in $\\mathrm{K}$),\n- Hot area index ranges $\\{i_{\\min}..i_{\\max}\\}$ and $\\{j_{\\min}..j_{\\max}\\}$ (inclusive),\n- Uniform internal volumetric heat generation $q_{\\text{hot}}$ over the hot area (in $\\mathrm{W\\,m^{-3}}$),\n- A list of candidate nodes $\\mathcal{C} = \\{(i,j)\\}$ at which you are allowed to place cooling channels,\n- The number of channels $m$ to place (an integer with $0 \\le m \\le |\\mathcal{C}|$), and\n- The sink strength $s$ (in $\\mathrm{W\\,m^{-3}}$) per channel node.\n\nFor each test case, evaluate all combinations of $m$ distinct nodes chosen from $\\mathcal{C}$, solve the linear system for each combination, compute the average of $T_{i,j}$ over the hot area node set $\\mathcal{H}$, and report the minimal average temperature over $\\mathcal{H}$ achieved among all combinations.\n\nNumerical units and output. All temperatures must be expressed in kelvin and the final answer for each test case must be rounded to three decimal places. Angles are not used. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[300.123,299.876,305.000]$.\n\nTest suite. Use exactly the following three test cases; indices are zero-based and inclusive:\n- Test case $1$ (happy path):\n  - $L = 0.20$ $\\mathrm{m}$, $N = 20$, $k = 200$ $\\mathrm{W\\,m^{-1}\\,K^{-1}}$, $T_{\\text{amb}} = 300$ $\\mathrm{K}$,\n  - Hot area rows $i \\in \\{7,8,9,10,11,12\\}$ and columns $j \\in \\{7,8,9,10,11,12\\}$,\n  - $q_{\\text{hot}} = 1.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$,\n  - Candidate set $\\mathcal{C}_1 = \\{(6,7),(6,9),(6,12),(13,7),(13,9),(13,12),(7,6),(9,6),(12,13),(9,13)\\}$,\n  - Number of channels $m = 2$,\n  - Sink strength $s = 5.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$.\n- Test case $2$ (boundary case with no channels):\n  - $L = 0.20$ $\\mathrm{m}$, $N = 20$, $k = 200$ $\\mathrm{W\\,m^{-1}\\,K^{-1}}$, $T_{\\text{amb}} = 300$ $\\mathrm{K}$,\n  - Hot area rows $i \\in \\{7,8,9,10,11,12\\}$ and columns $j \\in \\{7,8,9,10,11,12\\}$,\n  - $q_{\\text{hot}} = 1.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$,\n  - Candidate set $\\mathcal{C}_2 = \\mathcal{C}_1$ (same as in test case $1$),\n  - Number of channels $m = 0$,\n  - Sink strength $s = 5.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$ (irrelevant since $m=0$).\n- Test case $3$ (different material and geometry):\n  - $L = 0.16$ $\\mathrm{m}$, $N = 16$, $k = 60$ $\\mathrm{W\\,m^{-1}\\,K^{-1}}$, $T_{\\text{amb}} = 300$ $\\mathrm{K}$,\n  - Hot area rows $i \\in \\{6,7,8,9\\}$ and columns $j \\in \\{6,7,8,9\\}$,\n  - $q_{\\text{hot}} = 1.2 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$,\n  - Candidate set $\\mathcal{C}_3 = \\{(5,5),(5,7),(5,8),(5,10),(10,5),(10,7),(10,8),(10,10),(7,5),(8,5),(7,10),(8,10)\\}$,\n  - Number of channels $m = 3$,\n  - Sink strength $s = 8.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$.\n\nFinal output format. Your program should produce a single line of output containing the minimal average hot-area temperatures for the three test cases as a comma-separated list enclosed in square brackets, with each entry rounded to three decimal places in kelvin, for example $[T_1,T_2,T_3]$ where each $T_i$ is a float in kelvin rounded to three decimal places.", "solution": "The problem presented is a well-posed optimization task rooted in the fundamental principles of heat transfer. It requires finding the optimal placement of a discrete number of cooling channels to minimize the average temperature over a specified region of a conducting plate. The solution proceeds by first formulating the physical problem as a system of linear equations and then solving this system for every possible configuration of cooling channels to identify the global minimum of the objective function.\n\nThe governing physical law is the steady-state heat equation, which for a homogeneous and isotropic medium with constant thermal conductivity $k$ simplifies to the Poisson equation:\n$$\n\\nabla^2 T(x,y) = -\\frac{q(x,y)}{k}\n$$\nwhere $T(x,y)$ is the temperature field and $q(x,y) = q_{\\text{hot}}(x,y) - q_{\\text{sink}}(x,y)$ is the net volumetric heat source density in $\\mathrm{W\\,m^{-3}}$. The plate is a square domain of side length $L$, and the temperature on its boundary is fixed by a Dirichlet condition, $T = T_{\\text{amb}}$.\n\nTo solve this partial differential equation numerically, the domain is discretized into a uniform grid of $N \\times N$ nodes with spacing $h = L/(N-1)$. The Laplacian operator $\\nabla^2$ is approximated using a standard $5$-point finite difference stencil. For an interior node $(i,j)$, where $i,j \\in \\{1, \\dots, N-2\\}$, the discrete form of the Poisson equation is:\n$$\n\\frac{T_{i+1,j} + T_{i-1,j} + T_{i,j+1} + T_{i,j-1} - 4T_{i,j}}{h^2} = -\\frac{q_{i,j}}{k}\n$$\nRearranging this equation for all $(N-2)^2$ interior nodes results in a system of linear algebraic equations, $\\mathbf{A}\\mathbf{T}_{\\text{int}} = \\mathbf{b}$.\n- $\\mathbf{T}_{\\text{int}}$ is a vector of dimension $(N-2)^2$ containing the unknown temperatures at the interior nodes.\n- $\\mathbf{A}$ is a sparse, block-tridiagonal matrix of size $(N-2)^2 \\times (N-2)^2$ that represents the discretized negative Laplacian operator. For an interior node with a flattened index $p$, the corresponding row of the matrix equation is derived from $4T_p - \\sum_{n \\in \\text{neighbors}} T_n = \\frac{h^2}{k}q_p$. Thus, the diagonal elements of $\\mathbf{A}$ are $4$, and off-diagonal elements corresponding to adjacent interior nodes are $-1$.\n- $\\mathbf{b}$ is the right-hand side vector of dimension $(N-2)^2$. Each element $b_p$ is composed of two parts: the contribution from the heat source/sink term, $\\frac{h^2}{k}q_{i,j}$, and the contribution from any adjacent boundary nodes, whose temperatures are known ($T_{\\text{amb}}$). If an interior node $(i,j)$ is adjacent to a boundary, the known temperature $T_{\\text{amb}}$ is moved to the right-hand side of the equation.\n\nThe optimization is performed via a combinatorial search. For each test case, we are given a set of candidate locations $\\mathcal{C}$ and a number of channels $m$ to place. The algorithm computes all $\\binom{|\\mathcal{C}|}{m}$ combinations of placing $m$ cooling channels. For each combination:\n1.  The total source term grid, $q_{i,j} = q_{\\text{hot},i,j} - q_{\\text{sink},i,j}$, is constructed. $q_{\\text{hot},i,j}$ is non-zero only in the specified hot area $\\mathcal{H}$, and $q_{\\text{sink},i,j}$ is non-zero only at the nodes selected for the current combination.\n2.  The vector $\\mathbf{b}$ is assembled using the current $q_{i,j}$ distribution and the fixed boundary temperature $T_{\\text{amb}}$. The matrix $\\mathbf{A}$ is independent of the source/sink configuration and is constructed only once per test case.\n3.  The sparse linear system $\\mathbf{A}\\mathbf{T}_{\\text{int}} = \\mathbf{b}$ is solved for the vector of interior temperatures $\\mathbf{T}_{\\text{int}}$. `scipy.sparse.linalg.spsolve` is an appropriate and efficient solver for this task.\n4.  The full temperature grid is reconstructed by placing the solution $\\mathbf{T}_{\\text{int}}$ into the interior of a grid whose boundaries are set to $T_{\\text{amb}}$.\n5.  The average temperature over the hot area $\\mathcal{H}$ is calculated by summing the temperatures at the nodes in $\\mathcal{H}$ and dividing by the number of nodes $|\\mathcal{H}|$.\n6.  This average temperature is compared against the minimum value found in previous combinations, and the minimum is updated if necessary.\n\nAfter iterating through all combinations, the resulting minimal average temperature for the hot area is reported. This procedure is repeated for each test case provided in the problem statement. The case where $m=0$ is handled naturally, as there is only one combination (no channels), for which the system is solved once.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the optimization problem for three test cases.\n    For each case, it finds the optimal placement of cooling channels\n    to minimize the average temperature of a hot area on a conducting plate.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (happy path)\n        {\n            \"L\": 0.20, \"N\": 20, \"k\": 200, \"T_amb\": 300,\n            \"hot_area_rows\": (7, 12), \"hot_area_cols\": (7, 12),\n            \"q_hot\": 1.0e6,\n            \"C\": [(6, 7), (6, 9), (6, 12), (13, 7), (13, 9), (13, 12), (7, 6), (9, 6), (12, 13), (9, 13)],\n            \"m\": 2, \"s\": 5.0e6\n        },\n        # Test case 2 (boundary case with no channels)\n        {\n            \"L\": 0.20, \"N\": 20, \"k\": 200, \"T_amb\": 300,\n            \"hot_area_rows\": (7, 12), \"hot_area_cols\": (7, 12),\n            \"q_hot\": 1.0e6,\n            \"C\": [(6, 7), (6, 9), (6, 12), (13, 7), (13, 9), (13, 12), (7, 6), (9, 6), (12, 13), (9, 13)],\n            \"m\": 0, \"s\": 5.0e6\n        },\n        # Test case 3 (different material and geometry)\n        {\n            \"L\": 0.16, \"N\": 16, \"k\": 60, \"T_amb\": 300,\n            \"hot_area_rows\": (6, 9), \"hot_area_cols\": (6, 9),\n            \"q_hot\": 1.2e6,\n            \"C\": [(5, 5), (5, 7), (5, 8), (5, 10), (10, 5), (10, 7), (10, 8), (10, 10), (7, 5), (8, 5), (7, 10), (8, 10)],\n            \"m\": 3, \"s\": 8.0e6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, k, T_amb = case[\"L\"], case[\"N\"], case[\"k\"], case[\"T_amb\"]\n        hot_area_rows, hot_area_cols = case[\"hot_area_rows\"], case[\"hot_area_cols\"]\n        q_hot, C, m, s = case[\"q_hot\"], case[\"C\"], case[\"m\"], case[\"s\"]\n        \n        h = L / (N - 1)\n        N_int = N - 2\n        num_unknowns = N_int * N_int\n\n        # Define hot area grid and node list\n        q_hot_grid = np.zeros((N, N))\n        hot_area_nodes = []\n        for i in range(hot_area_rows[0], hot_area_rows[1] + 1):\n            for j in range(hot_area_cols[0], hot_area_cols[1] + 1):\n                q_hot_grid[i, j] = q_hot\n                hot_area_nodes.append((i, j))\n\n        # Construct the A matrix (sparse). This is constant for each case.\n        A = lil_matrix((num_unknowns, num_unknowns))\n        for i in range(1, N - 1):\n            for j in range(1, N - 1):\n                p = (i - 1) * N_int + (j - 1)\n                A[p, p] = 4\n                if i > 1: A[p, p - N_int] = -1\n                if i  N - 2: A[p, p + N_int] = -1\n                if j > 1: A[p, p - 1] = -1\n                if j  N - 2: A[p, p + 1] = -1\n        A_csc = A.tocsc()\n\n        min_avg_temp = float('inf')\n        \n        # Handle m=0 case without iterating\n        if m == 0:\n            sink_combinations = [[]]\n        else:\n            sink_combinations = combinations(C, m)\n\n        for sink_placement in sink_combinations:\n            q_sink_grid = np.zeros((N, N))\n            for r, c in sink_placement:\n                q_sink_grid[r, c] = s\n\n            q_total_grid = q_hot_grid - q_sink_grid\n\n            # Construct the b vector\n            b = np.zeros(num_unknowns)\n            for i in range(1, N - 1):\n                for j in range(1, N - 1):\n                    p = (i - 1) * N_int + (j - 1)\n                    \n                    source_term = (h**2 / k) * q_total_grid[i, j]\n                    \n                    boundary_term = 0\n                    if i == 1: boundary_term += T_amb\n                    if i == N - 2: boundary_term += T_amb\n                    if j == 1: boundary_term += T_amb\n                    if j == N - 2: boundary_term += T_amb\n                    \n                    b[p] = source_term + boundary_term\n            \n            # Solve the sparse linear system\n            T_int_vec = spsolve(A_csc, b)\n            \n            # Reconstruct the full temperature grid\n            T_full = np.full((N, N), T_amb, dtype=float)\n            T_full[1:N-1, 1:N-1] = T_int_vec.reshape((N_int, N_int))\n\n            # Calculate average temperature over the hot area\n            current_hot_area_temp_sum = 0\n            for r, c in hot_area_nodes:\n                current_hot_area_temp_sum += T_full[r, c]\n            \n            avg_temp = current_hot_area_temp_sum / len(hot_area_nodes)\n            min_avg_temp = min(min_avg_temp, avg_temp)\n        \n        results.append(round(min_avg_temp, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.3f}' for val in results)}]\")\n\nsolve()\n```", "id": "2445124"}, {"introduction": "This final practice introduces you to the fascinating world of inverse problems, a cornerstone of scientific discovery. Given a final temperature distribution, your goal is to deduce the location of the hidden heat source that created it. This exercise [@problem_id:2445154] requires you to leverage your knowledge of the forward simulation as a tool within a larger logical framework to infer cause from effect, a powerful technique used in fields from medical imaging to geophysics.", "problem": "You will solve an inverse problem for temperature evolution in a thin, homogeneous, isotropic conducting plate. Begin from the conservation of energy and Fourier’s law of heat conduction as the fundamental base. Consider a square plate of side length $L$ with constant thermal diffusivity $\\alpha$, held at zero temperature on its boundary for all times, and initially at zero temperature. A constant point heat source of unknown location injects heat at a constant rate from time $t=0$ until a final time $t=T$. The plate is modeled in two spatial dimensions and is sufficiently thin that out-of-plane conduction can be neglected. The goal is to determine the grid location of the source, given only the final temperature field at time $t=T$.\n\nYour program must implement the following pipeline in purely mathematical terms:\n- Derive a consistent discrete evolution from the two-dimensional heat equation starting from the energy balance and Fourier’s law, and use an unconditionally stable time-marching scheme on a uniform grid of $N_x \\times N_x$ nodes covering the square $[0,L]\\times[0,L]$ with zero-Dirichlet boundary conditions at $x=0$, $x=L$, $y=0$, and $y=L$.\n- Represent the constant point source as a single nodal forcing at one unknown interior grid node. The amplitude of the nodal forcing is constant in time but otherwise unknown.\n- Use the linear structure of the discrete evolution to formulate an inverse estimator that, for each candidate interior node, computes the least-squares residual between the measured final field and the prediction due to a source at that node with its optimal constant amplitude. Select the node that minimizes this residual.\n\nThe test suite below specifies parameter sets and the true source locations. For each test case, you must:\n- Construct the discrete operator on a uniform grid.\n- Generate the “measured” final temperature field internally by solving the forward problem using the same discrete model, a zero initial condition, and a constant source applied at the true source location with the specified constant amplitude throughout the integration interval.\n- Recover the source location by solving the inverse selection problem described above.\n\nDo not use any external input. Use zero-based indexing with the origin at the lower-left corner. Report the source location as integer grid indices $(i_x,i_y)$ on the full grid of size $N_x \\times N_x$, where $i_x \\in \\{0,1,\\dots,N_x-1\\}$ increases with $x$ from left to right and $i_y \\in \\{0,1,\\dots,N_x-1\\}$ increases with $y$ from bottom to top. The source will always be located strictly in the interior, i.e., $1 \\le i_x \\le N_x-2$ and $1 \\le i_y \\le N_x-2$. No physical units are required in your output.\n\nTest suite (five cases):\n- Case $1$: $L=1$, $N_x=25$, $\\alpha=10^{-3}$, time step $\\Delta t=2\\times 10^{-2}$, number of steps $N_t=200$, source amplitude $q=1$, true source location $(i_x,i_y)=(12,9)$.\n- Case $2$: $L=1$, $N_x=25$, $\\alpha=2\\times 10^{-3}$, time step $\\Delta t=1.5\\times 10^{-2}$, number of steps $N_t=160$, source amplitude $q=0.8$, true source location $(i_x,i_y)=(1,7)$.\n- Case $3$: $L=1$, $N_x=21$, $\\alpha=5\\times 10^{-4}$, time step $\\Delta t=10^{-2}$, number of steps $N_t=80$, source amplitude $q=1.2$, true source location $(i_x,i_y)=(10,10)$.\n- Case $4$: $L=1$, $N_x=27$, $\\alpha=1.5\\times 10^{-3}$, time step $\\Delta t=10^{-2}$, number of steps $N_t=150$, source amplitude $q=0.5$, true source location $(i_x,i_y)=(2,2)$.\n- Case $5$: $L=1$, $N_x=17$, $\\alpha=10^{-3}$, time step $\\Delta t=2.5\\times 10^{-2}$, number of steps $N_t=60$, source amplitude $q=1$, true source location $(i_x,i_y)=(8,1)$.\n\nFinal output format:\n- Your program should produce a single line containing a list of the estimated source locations for the five cases, in order, as a comma-separated list of $5$ items, each item being a two-element list of integers $[i_x,i_y]$. For example, the output format must be exactly like $[[i_{x,1},i_{y,1}],[i_{x,2},i_{y,2}],[i_{x,3},i_{y,3}],[i_{x,4},i_{y,4}],[i_{x,5},i_{y,5}]]$.", "solution": "The problem is evaluated to be scientifically sound, well-posed, and self-contained. It is a standard inverse problem in computational physics, based on the fundamental principles of heat transfer. All necessary parameters and conditions are provided. I will now proceed with the solution.\n\nThe temperature evolution in a homogeneous, isotropic conducting plate is governed by the two-dimensional heat equation. We begin by deriving its discrete form.\n\n**1. Governing Equation and Discretization**\n\nThe derivation starts from the principle of conservation of energy applied to a small control volume $d A=dx\\,dy$ within the plate. The time rate of change of thermal energy must equal the net heat flow into the volume plus any heat generated internally. This is expressed as:\n$$\n\\rho c_p \\frac{\\partial u}{\\partial t} = -\\nabla \\cdot \\mathbf{q} + Q\n$$\nwhere $u(x,y,t)$ is the temperature field, $\\rho$ is the density, $c_p$ is the specific heat capacity, $\\mathbf{q}$ is the heat flux vector, and $Q$ is the volumetric heat source density. Fourier's law of heat conduction relates the heat flux to the temperature gradient: $\\mathbf{q} = -k \\nabla u$, where $k$ is the thermal conductivity. For a homogeneous material with constant properties, substitution yields:\n$$\n\\rho c_p \\frac{\\partial u}{\\partial t} = \\nabla \\cdot (k \\nabla u) + Q = k \\nabla^2 u + Q\n$$\nDividing by $\\rho c_p$ and defining the thermal diffusivity $\\alpha = k/(\\rho c_p)$ and the source term $S = Q/(\\rho c_p)$ (with units of temperature per time), we obtain the standard heat equation:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2 u + S(x,y,t)\n$$\nWe discretize the spatial domain $[0,L]\\times[0,L]$ using a uniform grid with $N_x \\times N_x$ nodes. The grid spacing is $\\Delta x = \\Delta y = h = L/(N_x-1)$. Let $u_{i,j}^n$ denote the temperature at grid point $(x_i, y_j) = (ih, jh)$ at time $t_n = n\\Delta t$. The Laplacian operator $\\nabla^2$ is approximated using a five-point central difference stencil:\n$$\n\\nabla^2 u \\Big|_{(i,j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\n$$\n\n**2. Temporal Discretization and Matrix Formulation**\n\nTo ensure unconditional stability as required, we use an implicit time-marching scheme. The Backward Euler method is chosen for its simplicity and stability. It evaluates the spatial derivatives at the future time step $n+1$:\n$$\n\\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} = \\alpha \\left( \\frac{u_{i+1,j}^{n+1} + u_{i-1,j}^{n+1} + u_{i,j+1}^{n+1} + u_{i,j-1}^{n+1} - 4u_{i,j}^{n+1}}{h^2} \\right) + S_{i,j}^{n+1}\n$$\nRearranging the terms to place unknowns at time $n+1$ on the left side, we have a linear equation for each interior grid point $(i,j)$, where $i,j \\in \\{1, \\dots, N_x-2\\}$:\n$$\n(1 + 4c)u_{i,j}^{n+1} - c(u_{i+1,j}^{n+1} + u_{i-1,j}^{n+1} + u_{i,j+1}^{n+1} + u_{i,j-1}^{n+1}) = u_{i,j}^n + \\Delta t S_{i,j}^{n+1}\n$$\nwhere $c = \\alpha \\Delta t / h^2$ is the diffusion number. The zero-Dirichlet boundary conditions ($u=0$ on all boundaries) are implicitly handled as any term $u^{n+1}$ with an index on the boundary is zero and drops from the equation.\n\nThis system of $(N_x-2)^2$ linear equations must be solved at each time step. We can express this in matrix form. Let $\\mathbf{u}^n$ be a vector of size $N_{int} = (N_x-2)^2$ representing the temperatures at all interior nodes, flattened into a single column. The system becomes:\n$$\n\\mathbf{A} \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\mathbf{S}^{n+1}\n$$\nThe matrix $\\mathbf{A}$ is a sparse, block-tridiagonal matrix representing the discrete implicit operator. It is constant in time. The vector $\\mathbf{S}^{n+1}$ represents the nodal source forcing. Since the source is constant in time and space (at a single node), we can write $\\mathbf{S}^{n+1} = q \\, \\mathbf{e}_{k_s}$, where $k_s$ is the flattened index of the source node, $\\mathbf{e}_{k_s}$ is the corresponding standard basis vector, and $q$ is the source amplitude.\n\n**3. Forward Problem Solution**\n\nThe forward problem consists of finding the final temperature field $\\mathbf{u}_{final} = \\mathbf{u}^{N_t}$, given the initial condition $\\mathbf{u}^0 = \\mathbf{0}$ and a source with known location $k_s$ and amplitude $q$. The time evolution is computed by iteratively solving the linear system:\n$$\n\\mathbf{u}^{n+1} = \\mathbf{A}^{-1}(\\mathbf{u}^n + q \\Delta t \\, \\mathbf{e}_{k_s})\n$$\nfor $n=0, \\dots, N_t-1$. To perform this efficiently, the matrix $\\mathbf{A}$ is factorized once (e.g., using LU decomposition), and the factorization is reused to solve for $\\mathbf{u}^{n+1}$ via forward and backward substitution at each time step. This procedure is used to generate the \"measured\" final temperature field, $\\mathbf{u}_{meas}$, using the true source parameters provided in each test case.\n\n**4. Inverse Problem Formulation**\n\nThe inverse problem aims to find the source location $k_s$, given $\\mathbf{u}_{meas}$. The source amplitude $q$ is also unknown. The problem is structured as a search over all possible interior nodes. For each candidate source location, $k_c$, we find the optimal source amplitude that best explains the measured data in a least-squares sense.\n\nLet $\\mathbf{U}_{k_c}$ be the final temperature field generated by a unit source ($q=1$) located at $k_c$, computed using the same forward model. Due to linearity, the predicted field for a source of amplitude $q_c$ at location $k_c$ is $\\mathbf{u}_{pred} = q_c \\mathbf{U}_{k_c}$. We must find $k_c$ and $q_c$ that minimize the residual:\n$$\nR(k_c, q_c) = \\| \\mathbf{u}_{meas} - q_c \\mathbf{U}_{k_c} \\|_2^2\n$$\nFor a fixed candidate location $k_c$, the optimal amplitude $q_c^*$ is found by setting the derivative of $R$ with respect to $q_c$ to zero:\n$$\n\\frac{\\partial R}{\\partial q_c} = 0 \\implies q_c^* = \\frac{\\mathbf{U}_{k_c}^T \\mathbf{u}_{meas}}{\\mathbf{U}_{k_c}^T \\mathbf{U}_{k_c}} = \\frac{\\langle \\mathbf{U}_{k_c}, \\mathbf{u}_{meas} \\rangle}{\\| \\mathbf{U}_{k_c} \\|_2^2}\n$$\nThis optimal amplitude is the scalar projection of $\\mathbf{u}_{meas}$ onto the basis vector $\\mathbf{U}_{k_c}$.\n\n**5. Algorithmic Procedure**\n\nThe final estimated source location is the candidate node that minimizes the residual after substituting its optimal amplitude:\n$$\nk_{est} = \\arg\\min_{k_c} \\| \\mathbf{u}_{meas} - q_c^*(k_c) \\, \\mathbf{U}_{k_c} \\|_2^2\n$$\nThe complete algorithm is as follows:\n1.  **Generate Data**: For each test case, construct the matrix $\\mathbf{A}$. Simulate the temperature evolution over $N_t$ time steps with the true source parameters to generate the measurement vector $\\mathbf{u}_{meas}$.\n2.  **Iterate and Test Candidates**: Loop through every interior grid node $(i_c, j_c)$ as a candidate source location.\n    a.  For each candidate $(i_c, j_c)$, simulate the forward problem with a unit source ($q=1$) at that location to compute the corresponding final temperature profile $\\mathbf{U}_{k_c}$.\n    b.  Calculate the optimal source amplitude $q_c^*$ using the derived projection formula.\n    c.  Compute the squared L2-norm of the residual between $\\mathbf{u}_{meas}$ and the prediction $q_c^* \\mathbf{U}_{k_c}$.\n3.  **Select Best Fit**: The estimated source location is the candidate $(i_c, j_c)$ that yields the minimum residual. The program implements this procedure for each specified test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import splu\n\ndef solve():\n    \"\"\"\n    Main function to solve the inverse heat source problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {'L': 1, 'Nx': 25, 'alpha': 1e-3, 'dt': 2e-2, 'Nt': 200, 'q': 1, 'true_loc': (12, 9)},\n        {'L': 1, 'Nx': 25, 'alpha': 2e-3, 'dt': 1.5e-2, 'Nt': 160, 'q': 0.8, 'true_loc': (1, 7)},\n        {'L': 1, 'Nx': 21, 'alpha': 5e-4, 'dt': 1e-2, 'Nt': 80, 'q': 1.2, 'true_loc': (10, 10)},\n        {'L': 1, 'Nx': 27, 'alpha': 1.5e-3, 'dt': 1e-2, 'Nt': 150, 'q': 0.5, 'true_loc': (2, 2)},\n        {'L': 1, 'Nx': 17, 'alpha': 1e-3, 'dt': 2.5e-2, 'Nt': 60, 'q': 1, 'true_loc': (8, 1)},\n    ]\n\n    results = []\n    for case in test_cases:\n        estimated_loc = find_source_location(**case)\n        results.append(list(estimated_loc))\n\n    formatted_results = [f'[{r[0]},{r[1]}]' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_forward_simulation(solver, Nt, dt, source_amplitude, source_k, N_int):\n    \"\"\"\n    Simulates the heat equation forward in time.\n    \n    Args:\n        solver: Pre-factorized sparse matrix solver (from splu).\n        Nt: Number of time steps.\n        dt: Time step size.\n        source_amplitude: The 'q' value for the source.\n        source_k: The flattened index of the source node.\n        N_int: Total number of interior nodes.\n\n    Returns:\n        The final temperature field as a 1D numpy array.\n    \"\"\"\n    f_vec = np.zeros(N_int)\n    if source_k is not None:\n        f_vec[source_k] = source_amplitude * dt\n\n    u_n = np.zeros(N_int)\n    for _ in range(Nt):\n        b = u_n + f_vec\n        u_n = solver.solve(b)\n    \n    return u_n\n\ndef find_source_location(L, Nx, alpha, dt, Nt, q, true_loc):\n    \"\"\"\n    Finds the heat source location for a single test case.\n    \"\"\"\n    # 1. Setup grid and parameters\n    h = L / (Nx - 1)\n    c = alpha * dt / h**2\n    N_int_dim = Nx - 2\n    N_int = N_int_dim**2\n\n    # 2. Build the sparse matrix A for the implicit scheme (I - c*L)\n    M = N_int_dim\n    N = M * M\n    main_diag = np.full(N, 1 + 4 * c)\n    sub_diag = np.full(N - 1, -c)\n    sup_diag = np.full(N - 1, -c)\n    # Remove fictitious connections between grid rows\n    sub_diag[M-1::M] = 0\n    sup_diag[M-1::M] = 0\n    lower_M_diag = np.full(N - M, -c)\n    upper_M_diag = np.full(N - M, -c)\n    \n    diagonals_data = [upper_M_diag, sup_diag, main_diag, sub_diag, lower_M_diag]\n    offsets = [M, 1, 0, -1, -M]\n    A = diags(diagonals_data, offsets, shape=(N, N), format='csc')\n    \n    # Pre-factorize the matrix for efficient solves\n    solver = splu(A)\n\n    # 3. Generate \"measured\" data by solving the forward problem with true parameters\n    k_true = (true_loc[0] - 1) + (true_loc[1] - 1) * N_int_dim\n    u_meas = run_forward_simulation(solver, Nt, dt, q, k_true, N_int)\n\n    # 4. Inverse search for the source location\n    min_residual = float('inf')\n    best_location = None\n    \n    # Iterate through all possible interior nodes as candidates\n    for j_c in range(1, Nx - 1):\n        for i_c in range(1, Nx - 1):\n            k_c = (i_c - 1) + (j_c - 1) * N_int_dim\n            \n            # a. Simulate the final field for a unit source at the candidate location\n            U_kc = run_forward_simulation(solver, Nt, dt, 1.0, k_c, N_int)\n            \n            dot_Ukc_Ukc = np.dot(U_kc, U_kc)\n            # If the response is negligible, this is not a viable candidate\n            if dot_Ukc_Ukc  1e-30:\n                continue\n\n            # b. Calculate the optimal source amplitude and the corresponding residual\n            q_star = np.dot(U_kc, u_meas) / dot_Ukc_Ukc\n            residual = np.sum((u_meas - q_star * U_kc)**2)\n\n            # c. Update the best-fit location if the current candidate is better\n            if residual  min_residual:\n                min_residual = residual\n                best_location = (i_c, j_c)\n                \n    return best_location\n\nsolve()\n```", "id": "2445154"}]}