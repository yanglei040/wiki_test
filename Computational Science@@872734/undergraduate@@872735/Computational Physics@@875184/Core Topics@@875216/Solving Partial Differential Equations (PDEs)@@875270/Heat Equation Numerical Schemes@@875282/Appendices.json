{"hands_on_practices": [{"introduction": "Our first practice focuses on the most critical property of explicit schemes: numerical stability. Using the Forward-Time Centered-Space (FTCS) method, we will not solve for a physical temperature profile, but instead inject a tiny, single-point error and observe its evolution. This exercise [@problem_id:2400867] provides a direct, visceral understanding of how a scheme can either damp out errors or catastrophically amplify them, depending on the choice of discretization parameters.", "problem": "You are to write a complete, runnable program that studies how a single-point numerical round-off error propagates under the Forward-Time Centered-Space (FTCS) scheme for the one-dimensional heat equation in nondimensional form. Start from the fundamental model of heat diffusion described by the partial differential equation $u_t = u_{xx}$ on a periodic domain. Discretize space into $N$ uniform points with spacing $\\Delta x$, discretize time with step $\\Delta t$, and apply the FTCS update at each time step. Work in nondimensional units, so no physical units are required in your answer.\n\nYour program must implement the following mathematical definitions and tasks without using any pre-derived stability or amplification formulas in the implementation:\n- Define the nondimensional ratio $r = \\Delta t / \\Delta x^2$.\n- Use the periodic FTCS update for each time step for indices $i = 0, 1, \\dots, N - 1$,\n  $$u_i^{n+1} = u_i^n + r \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n\\right),$$\n  with periodic indexing $u_{-1} = u_{N-1}$ and $u_N = u_0$.\n- Initialize a perturbation field that is identically zero except at a single index $i_0 = \\lfloor N/2 \\rfloor$, where the value is set to the IEEE $754$ double-precision machine epsilon $\\varepsilon = 2^{-52}$. This emulates a single-point numerical round-off error.\n- Evolve the perturbation for $T$ time steps using the FTCS update. Compute the two-norm amplification factor per time step\n  $$g = \\left(\\frac{\\lVert e^T \\rVert_2}{\\lVert e^0 \\rVert_2}\\right)^{1/T},$$\n  where $e^n$ is the perturbation vector after $n$ steps, and $\\lVert \\cdot \\rVert_2$ denotes the Euclidean norm.\n\nThe goal is to quantify how the single-point round-off error is amplified or damped in both stable ($r < 0.5$) and unstable ($r > 0.5$) FTCS regimes by reporting the measured geometric growth factor $g$.\n\nImplement your program to handle the following test suite of parameter sets $(N, r, T)$, all with periodic boundaries and index $i_0 = \\lfloor N/2 \\rfloor$:\n- Test $1$ (stable, happy path): $N = 64$, $r = 0.25$, $T = 200$.\n- Test $2$ (unstable, mild): $N = 64$, $r = 0.51$, $T = 80$.\n- Test $3$ (borderline): $N = 33$, $r = 0.5$, $T = 200$.\n- Test $4$ (unstable, severe): $N = 128$, $r = 0.9$, $T = 30$.\n\nYour program should compute $g$ for each test and produce a single line of output containing the results as a comma-separated list of floats rounded to six decimal places, enclosed in square brackets, in the same order as above (for example, \"[$g_1, g_2, g_3, g_4$]\"). The outputs are nondimensional numbers, so no physical units are required. Each $g$ must be printed as a float rounded to six decimal places. The final output type is a list of floats.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to proceed with a unique and meaningful solution. The problem constitutes a standard numerical experiment in the field of computational physics to investigate the stability of a finite difference scheme. We will now proceed with the solution.\n\nThe fundamental physical process under consideration is one-dimensional heat diffusion, described by the partial differential equation (PDE):\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial^2 u}{\\partial x^2}\n$$\nwhere $u(x, t)$ is the temperature at position $x$ and time $t$. The problem specifies a periodic domain, which implies $u(x, t) = u(x+L, t)$ for some period $L$. For our numerical simulation, the domain is a discrete set of $N$ points, and periodicity is enforced by connecting the boundaries, such that the neighbor of point $i=0$ to the left is $i=N-1$, and the neighbor of point $i=N-1$ to the right is $i=0$.\n\nTo solve this equation numerically, we discretize both space and time. Let the spatial domain be discretized into $N$ points with a uniform spacing $\\Delta x$, and time be discretized into steps of size $\\Delta t$. We denote the numerical approximation of $u(i\\Delta x, n\\Delta t)$ as $u_i^n$. The Forward-Time Centered-Space (FTCS) scheme approximates the derivatives as follows:\n- The time derivative $\\frac{\\partial u}{\\partial t}$ is approximated using a forward difference:\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{(i,n)} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\n- The spatial second derivative $\\frac{\\partial^2 u}{\\partial x^2}$ is approximated using a centered difference:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(i,n)} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\n$$\nSubstituting these approximations into the heat equation yields the FTCS update rule:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\n$$\nRearranging this equation to solve for the future state $u_i^{n+1}$ gives the explicit formula provided in the problem statement:\n$$\nu_i^{n+1} = u_i^n + r \\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right)\n$$\nwhere $r = \\frac{\\Delta t}{(\\Delta x)^2}$ is the non-dimensional diffusion number for this parabolic problem.\n\nThis update rule is a linear transformation. If we represent the state of the system at time step $n$ as a vector $\\mathbf{u}^n = [u_0^n, u_1^n, \\dots, u_{N-1}^n]^T$, the evolution from one time step to the next can be expressed in matrix form:\n$$\n\\mathbf{u}^{n+1} = \\mathbf{A} \\mathbf{u}^n\n$$\nwhere $\\mathbf{A}$ is the $N \\times N$ amplification matrix. Based on the update rule and the periodic boundary conditions ($u_{-1} = u_{N-1}$ and $u_N = u_0$), the matrix $\\mathbf{A}$ is a circulant matrix with the following structure:\n$$\n\\mathbf{A} = \\begin{pmatrix}\n1-2r & r & 0 & \\dots & 0 & r \\\\\nr & 1-2r & r & \\dots & 0 & 0 \\\\\n0 & r & 1-2r & \\dots & 0 & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\\n0 & 0 & 0 & \\dots & 1-2r & r \\\\\nr & 0 & 0 & \\dots & r & 1-2r\n\\end{pmatrix}\n$$\nThe problem is to study the propagation of a numerical round-off error. Since the evolution equation is linear, any error $\\mathbf{e}^n$ will evolve according to the same rule: $\\mathbf{e}^{n+1} = \\mathbf{A} \\mathbf{e}^n$. By induction, the error after $T$ time steps is given by $\\mathbf{e}^T = \\mathbf{A}^T \\mathbf{e}^0$.\n\nThe simulation procedure is as follows:\n1.  For each test case $(N, r, T)$, an initial error vector $\\mathbf{e}^0$ of size $N$ is created. This vector is initialized to zeros everywhere except at the central index $i_0 = \\lfloor N/2 \\rfloor$.\n2.  The value at this single point is set to the double-precision machine epsilon, $\\varepsilon = 2^{-52}$. Thus, $\\mathbf{e}^0_{i_0} = \\varepsilon$.\n3.  The Euclidean norm (or $L_2$-norm) of this initial vector is calculated: $\\lVert \\mathbf{e}^0 \\rVert_2 = \\sqrt{\\sum_{i=0}^{N-1} (e_i^0)^2} = \\sqrt{\\varepsilon^2} = \\varepsilon$.\n4.  A loop iterates for $T$ time steps. In each step $n$, the error vector $\\mathbf{e}^{n+1}$ is computed from $\\mathbf{e}^n$ using the FTCS update rule with periodic boundary conditions.\n5.  After $T$ steps, the final error vector is $\\mathbf{e}^T$. Its Euclidean norm, $\\lVert \\mathbf{e}^T \\rVert_2$, is computed.\n6.  The geometric growth factor per time step, $g$, is then calculated from its definition:\n$$\ng = \\left(\\frac{\\lVert \\mathbf{e}^T \\rVert_2}{\\lVert \\mathbf{e}^0 \\rVert_2}\\right)^{1/T}\n$$\nA value of $g > 1$ indicates that the error is amplified, and the scheme is unstable for the given parameters. A value of $g < 1$ indicates that the error is damped, and the scheme is stable. A value of $g \\approx 1$ suggests a neutrally stable or borderline case. This procedure is executed for each of the four test cases provided. The implementation will use `numpy` for efficient array operations, particularly `numpy.roll` to handle the periodic boundary conditions elegantly.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical amplification factor for the FTCS scheme\n    for the 1D heat equation under different stability regimes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, r, T)\n    # N: number of spatial points\n    # r: nondimensional ratio delta_t / (delta_x)^2\n    # T: number of time steps\n    test_cases = [\n        (64, 0.25, 200),  # Test 1: stable\n        (64, 0.51, 80),   # Test 2: unstable (mild)\n        (33, 0.5, 200),   # Test 3: borderline\n        (128, 0.9, 30),   # Test 4: unstable (severe)\n    ]\n\n    results = []\n    \n    # The IEEE 754 double-precision machine epsilon\n    epsilon = np.finfo(float).eps\n\n    for N, r, T in test_cases:\n        # Initialize the perturbation field 'e'.\n        # It is zero everywhere except for a single point.\n        e = np.zeros(N, dtype=float)\n        \n        # Set the perturbation at the central grid point.\n        # i_0 = floor(N/2) is implemented via integer division.\n        i0 = N // 2\n        e[i0] = epsilon\n        \n        # The initial L2 norm of the error vector.\n        # Since only one element is non-zero, the norm is its absolute value.\n        norm_e0 = np.linalg.norm(e)\n\n        # Evolve the perturbation for T time steps using the FTCS scheme.\n        for _ in range(T):\n            # Applying periodic boundary conditions efficiently using np.roll.\n            # np.roll(e, 1) shifts elements to the right (e_{i-1})\n            # np.roll(e, -1) shifts elements to the left (e_{i+1})\n            e_im1 = np.roll(e, 1)\n            e_ip1 = np.roll(e, -1)\n            \n            # Apply the FTCS update rule.\n            e = e + r * (e_ip1 - 2 * e + e_im1)\n\n        # Calculate the L2 norm of the final error vector.\n        norm_eT = np.linalg.norm(e)\n        \n        # Calculate the geometric amplification factor per time step, g.\n        # Handle the case where the error is damped to zero to avoid division errors.\n        if norm_eT == 0.0 or norm_e0 == 0.0:\n            g = 0.0\n        else:\n            g = (norm_eT / norm_e0)**(1.0 / T)\n\n        results.append(g)\n\n    # Format the results as a list of strings, each rounded to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2400867"}, {"introduction": "While the FTCS scheme is simple, its first-order accuracy in time can be a significant limitation for precision simulations. This next exercise [@problem_id:2400909] guides you through deriving and implementing a predictor-corrector method, a technique that improves the temporal accuracy to second order. You will perform a full analysis, from derivation and stability analysis to numerical verification, gaining insight into the design principles of higher-order schemes.", "problem": "Consider the one-dimensional heat equation with periodic boundary conditions on the domain $[0,1]$,\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in [0,1], \\quad t \\ge 0,\n$$\nwhere $\\alpha > 0$ is a given thermal diffusivity constant, and $u(x,t)$ is smooth in both $x$ and $t$. Work from the following fundamental base:\n- The heat equation as stated above.\n- The centered second-difference operator as an approximation of the second spatial derivative, that is, for a spatial grid $x_i = i \\Delta x$ with $i = 0,1,\\dots,N-1$ and periodic boundary conditions, the discrete Laplacian acts as\n$$\n(\\Delta_h u)_i = \\frac{u_{i+1} - 2 u_i + u_{i-1}}{(\\Delta x)^2},\n$$\nwhere indices are taken modulo $N$.\n- The concept of a predictor-corrector method that builds a time-advanced approximation by using an explicit prediction and then a correction based on predicted fluxes or derivatives, followed by averaging, in the spirit of MacCormack's method.\n\nTask A (derivation): Starting from the semi-discrete method-of-lines form obtained by applying the centered second-difference operator in space, derive a two-stage explicit predictor-corrector time-stepping method adapted to the heat equation that uses a predictor based on the current-time discrete Laplacian and a corrector based on the predicted state, followed by averaging. Express the scheme in terms of the non-dimensional parameter\n$$\n\\mu = \\alpha \\frac{\\Delta t}{(\\Delta x)^2}.\n$$\nDo not assume any particular form beyond the above principles; derive the full update rule.\n\nTask B (stability analysis): Perform a von Neumann Fourier analysis of your scheme on a periodic grid. For a grid Fourier mode, determine the scalar amplification factor $G(\\theta,\\mu)$ as a function of the nondimensional wavenumber $\\theta \\in [0,\\pi]$ and $\\mu$. From this, deduce a necessary and sufficient bound on $\\mu$ for stability in the maximum norm, expressed as an inequality of the form $\\mu \\le \\mu_{\\max}$, and give the value of $\\mu_{\\max}$.\n\nTask C (order-of-accuracy study): Consider the initial condition\n$$\nu(x,0) = \\sin(2 \\pi x)\n$$\non $x \\in [0,1]$ with periodic boundary conditions and $\\alpha = 1$. The exact solution is\n$$\nu_{\\text{exact}}(x,t) = \\exp\\!\\big(- (2\\pi)^2 t\\big) \\sin(2 \\pi x).\n$$\nImplement your derived predictor-corrector method on uniform grids with $N \\in \\{50, 100, 200\\}$ points, using the same nondimensional time step $\\mu = 0.4$ in all cases, and evolve to a final time $T = 0.05$. Use a number of uniform steps $n$ so that the actual final time equals $n \\Delta t$; evaluate the exact solution at that same time. Compute the discrete $L^2$-error\n$$\n\\|e\\|_{2,h} = \\left( \\Delta x \\sum_{i=0}^{N-1} \\left[u_i^{\\text{num}} - u_{\\text{exact}}(x_i, n\\Delta t)\\right]^2 \\right)^{1/2}.\n$$\nFrom the errors at $N=50$, $N=100$, and $N=200$, compute the observed orders of accuracy\n$$\np_{50\\to 100} = \\frac{\\log\\left(\\|e\\|_{2,h=1/50} / \\|e\\|_{2,h=1/100}\\right)}{\\log(2)}, \\quad\np_{100\\to 200} = \\frac{\\log\\left(\\|e\\|_{2,h=1/100} / \\|e\\|_{2,h=1/200}\\right)}{\\log(2)}.\n$$\n\nTask D (edge-case stability probe): Using the same periodic domain and the same scheme, test stability for the highest-frequency grid mode by taking the initial condition\n$$\nu_i^0 = (-1)^i, \\quad i=0,1,\\dots,N-1,\n$$\nwith $N=128$, and evolve exactly $n=50$ time steps for each of the values $\\mu \\in \\{0.49,\\,0.50,\\,0.51\\}$ (take $\\alpha=1$). Classify the run as stable if the ratio of the discrete $L^2$-norm at step $n$ to that at step $0$ is less than or equal to $1.01$, and unstable otherwise. Report three booleans in the same order of $\\mu$.\n\nTest suite and final output specification:\n- Use the following parameter sets and compute the corresponding outputs:\n  - For Task C: $N \\in \\{50, 100, 200\\}$, $\\alpha = 1$, $\\mu = 0.4$, $T = 0.05$, $u(x,0) = \\sin(2\\pi x)$, periodic boundary conditions. Compute $p_{50\\to 100}$ and $p_{100\\to 200}$ as real numbers.\n  - For Task D: $N=128$, $\\alpha=1$, initial data $u_i^0 = (-1)^i$, $n=50$ steps, and $\\mu \\in \\{0.49,\\,0.50,\\,0.51\\}$. Compute the three stability booleans.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order\n$$\n\\big[p_{50\\to 100},\\, p_{100\\to 200},\\, \\text{stable}_{0.49},\\, \\text{stable}_{0.50},\\, \\text{stable}_{0.51}\\big].\n$$\nNo units are required anywhere, and all angles are in radians by default. All numerical quantities appearing in the output must be represented as primitive types (real numbers and booleans).", "solution": "The problem is well-posed and scientifically sound, consisting of a standard set of tasks in the analysis of numerical methods for partial differential equations. The problem is validated and a full solution is provided below.\n\nTask A: Derivation of the Predictor-Corrector Scheme\n\nThe one-dimensional heat equation is given by $\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}$. We spatially discretize this equation on a uniform grid $x_i = i \\Delta x$ for $i=0, 1, \\dots, N-1$ using the centered second-difference operator for the spatial derivative. This yields the semi-discrete method-of-lines system:\n$$\n\\frac{d u_i}{dt} = \\alpha \\frac{u_{i+1} - 2u_i + u_{i-1}}{(\\Delta x)^2}\n$$\nwhere $u_i(t) \\approx u(x_i, t)$ and indices are taken modulo $N$ due to periodic boundary conditions.\n\nThe task requires the derivation of a two-stage explicit predictor-corrector scheme. This structure corresponds to a second-order Runge-Kutta method, specifically Heun's method. Let $u_i^n$ be the approximation of $u(x_i, n\\Delta t)$.\n\nStep 1: Predictor. We compute a predicted state $u_i^*$ at time $t_{n+1} = t_n + \\Delta t$ using an explicit forward Euler step.\n$$\nu_i^* = u_i^n + \\Delta t \\left( \\alpha \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2} \\right)\n$$\nUsing the non-dimensional parameter $\\mu = \\alpha \\frac{\\Delta t}{(\\Delta x)^2}$, the predictor step is:\n$$\nu_i^* = u_i^n + \\mu (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\n\nStep 2: Corrector. We evaluate the spatial derivative at the predicted state $u_i^*$ and use the average of the time derivatives at the current state $u_i^n$ and the predicted state $u_i^*$ to compute the final update.\n$$\nu_i^{n+1} = u_i^n + \\frac{\\Delta t}{2} \\left[ \\left( \\alpha \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2} \\right) + \\left( \\alpha \\frac{u_{i+1}^* - 2u_i^* + u_{i-1}^*}{(\\Delta x)^2} \\right) \\right]\n$$\nIn terms of $\\mu$, this becomes:\n$$\nu_i^{n+1} = u_i^n + \\frac{\\mu}{2} \\left[ (u_{i+1}^n - 2u_i^n + u_{i-1}^n) + (u_{i+1}^* - 2u_i^* + u_{i-1}^*) \\right]\n$$\nThis two-step process defines the required scheme. For analysis, it is useful to combine these into a single expression for $u_i^{n+1}$ in terms of values at time level $n$. Let the discrete spatial operator be $L_h u_i = u_{i+1} - 2u_i + u_{i-1}$. The scheme is:\n$$\n\\mathbf{u}^* = \\mathbf{u}^n + \\mu L_h \\mathbf{u}^n\n$$\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\frac{\\mu}{2} (L_h \\mathbf{u}^n + L_h \\mathbf{u}^*)\n$$\nSubstituting the predictor into the corrector and using the linearity of $L_h$:\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\frac{\\mu}{2} (L_h \\mathbf{u}^n + L_h (\\mathbf{u}^n + \\mu L_h \\mathbf{u}^n)) = \\mathbf{u}^n + \\frac{\\mu}{2} (2 L_h \\mathbf{u}^n + \\mu L_h^2 \\mathbf{u}^n)\n$$\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\mu L_h \\mathbf{u}^n + \\frac{\\mu^2}{2} L_h^2 \\mathbf{u}^n\n$$\nwhere $L_h^2 u_i = L_h(L_h u_i) = u_{i+2} - 4u_{i+1} + 6u_i - 4u_{i-1} + u_{i-2}$.\n\nTask B: Stability Analysis\n\nWe perform a von Neumann stability analysis by substituting a single Fourier mode $u_j^n = G^n e^{i j \\theta}$ into the single-step scheme derived above, where $\\theta = k \\Delta x$ is the non-dimensional wavenumber and $G$ is the amplification factor.\nThe symbol of the operator $L_h$ is $\\hat{L}_h(\\theta) = e^{i\\theta} - 2 + e^{-i\\theta} = 2\\cos(\\theta) - 2$.\nThe symbol of $L_h^2$ is $(\\hat{L}_h(\\theta))^2 = (2\\cos(\\theta) - 2)^2$.\nSubstituting into the scheme gives the amplification factor $G(\\theta, \\mu)$:\n$$\nG(\\theta, \\mu) = 1 + \\mu \\hat{L}_h(\\theta) + \\frac{\\mu^2}{2} (\\hat{L}_h(\\theta))^2 = 1 + \\mu (2\\cos(\\theta) - 2) + \\frac{\\mu^2}{2} (2\\cos(\\theta) - 2)^2\n$$\nFor stability, we require $|G(\\theta, \\mu)| \\le 1$ for all $\\theta \\in [-\\pi, \\pi]$. Let $X = 2\\cos(\\theta) - 2$. As $\\theta$ covers its range, $X$ spans the interval $[-4, 0]$. The stability condition becomes $|1 + \\mu X + \\frac{\\mu^2}{2} X^2| \\le 1$ for all $X \\in [-4, 0]$.\n\n1.  Upper Stability Bound: $1 + \\mu X + \\frac{\\mu^2}{2} X^2 \\le 1$.\n    $\\mu X + \\frac{\\mu^2}{2} X^2 \\le 0 \\implies X(\\mu + \\frac{\\mu^2}{2} X) \\le 0$.\n    Since $\\mu > 0$ and $X \\le 0$, we must have $\\mu + \\frac{\\mu^2}{2} X \\ge 0$, which is equivalent to $1 + \\frac{\\mu}{2} X \\ge 0$. This must hold for all $X \\in [-4, 0]$. The most restrictive case is at $X = -4$:\n    $1 + \\frac{\\mu}{2}(-4) \\ge 0 \\implies 1 - 2\\mu \\ge 0 \\implies \\mu \\le \\frac{1}{2}$.\n\n2.  Lower Stability Bound: $1 + \\mu X + \\frac{\\mu^2}{2} X^2 \\ge -1$.\n    $P(X) = \\frac{\\mu^2}{2} X^2 + \\mu X + 2 \\ge 0$.\n    This is a convex parabola in $X$. Its minimum occurs at $X_v = -\\frac{\\mu}{\\mu^2} = -1/\\mu$.\n    If the vertex is in the interval, $\\mu \\ge 1/4$, the minimum value is $P(-1/\\mu) = \\frac{\\mu^2}{2}(-1/\\mu)^2 + \\mu(-1/\\mu) + 2 = 1/2 - 1 + 2 = 3/2 > 0$, so the condition holds.\n    If the vertex is outside the interval, $\\mu < 1/4$, the minimum value on $[-4, 0]$ is at $X=-4$. $P(-4) = 8\\mu^2 - 4\\mu + 2$. The discriminant of this quadratic in $\\mu$ is $(-4)^2 - 4(8)(2) = 16 - 64 = -48 < 0$, so $P(-4)$ is always positive. The lower bound is always satisfied.\n\nThe only constraint is $\\mu \\le 1/2$. Thus, the necessary and sufficient condition for stability is $\\mu \\le 0.5$, and $\\mu_{\\max} = 0.5$.\n\nTask C: Order-of-Accuracy Study\n\nThe derived scheme is implemented with parameters $\\alpha=1$, $\\mu = 0.4$ on grids of size $N \\in \\{50, 100, 200\\}$ to solve the heat equation with initial condition $u(x,0)=\\sin(2\\pi x)$ up to a target time of $T=0.05$. For each $N$, $\\Delta x=1/N$ and $\\Delta t = \\mu (\\Delta x)^2 / \\alpha$ are defined. The number of time steps $n$ is chosen as $n = \\text{round}(T/\\Delta t)$ to get as close as possible to the target time. The numerical solution is compared to the exact solution $u_{\\text{exact}}(x,t) = \\exp(-(2\\pi)^2 t) \\sin(2\\pi x)$ evaluated at the actual final time $T_{final} = n \\Delta t$. The discrete $L^2$-error $\\|e\\|_{2,h}$ is computed for each grid. The observed order of accuracy $p$ is calculated by comparing errors between successively refined grids. As both the spatial and temporal discretizations are second-order, and $\\Delta t$ is proportional to $(\\Delta x)^2$, the global error is expected to be dominated by the spatial error, leading to an observed order of accuracy $p \\approx 2$. The numerical computation is performed in the final answer code.\n\nTask D: Edge-Case Stability Probe\n\nThe stability of the scheme is tested numerically at the stability boundary $\\mu_{\\max}=0.5$. The initial condition is $u_i^0 = (-1)^i$, which corresponds to the highest-frequency mode on the grid ($\\theta = \\pi$), for which the stability constraint is most severe. The simulation is run for $N=128$, $\\alpha=1$, and $n=50$ steps with $\\mu$ values of $\\{0.49, 0.50, 0.51\\}$. The theoretical amplification factor for this mode is $G(\\pi, \\mu) = 1 - 4\\mu + 8\\mu^2$.\n- For $\\mu=0.49$, $|G| = |1 - 1.96 + 1.9208| = |0.9608| < 1$, predicting stability.\n- For $\\mu=0.50$, $|G| = |1 - 2.00 + 2.0000| = |1| = 1$, predicting neutral stability.\n- For $\\mu=0.51$, $|G| = |1 - 2.04 + 2.0808| = |1.0408| > 1$, predicting instability.\nThe ratio of the final to initial discrete $L^2$-norm is computed. A run is classified as stable if this ratio is less than or equal to $1.01$. The code in the final answer will report the resulting booleans.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    # This function combines the logic for all tasks as specified.\n    # The structure with a list of test cases is not directly applicable\n    # as the problem contains distinct, sequential tasks.\n\n    # --- Task C: Order-of-accuracy study ---\n    c_alpha = 1.0\n    c_mu = 0.4\n    c_T_target = 0.05\n    c_N_values = [50, 100, 200]\n    \n    errors = []\n    \n    for N in c_N_values:\n        dx = 1.0 / N\n        dt = c_mu * dx**2 / c_alpha\n        # Per problem statement, use integer number of steps and evaluate at actual final time\n        n_steps = int(round(c_T_target / dt))\n        T_final = n_steps * dt\n        \n        x = np.arange(N) * dx\n        u = np.sin(2 * np.pi * x)\n        \n        for _ in range(n_steps):\n            # Predictor-corrector (Heun's method)\n            Lh_u = np.roll(u, -1) - 2 * u + np.roll(u, 1)\n            u_star = u + c_mu * Lh_u\n            \n            Lh_u_star = np.roll(u_star, -1) - 2 * u_star + np.roll(u_star, 1)\n            u = u + (c_mu / 2.0) * (Lh_u + Lh_u_star)\n\n        u_exact = np.exp(-(2 * np.pi)**2 * T_final) * np.sin(2 * np.pi * x)\n        error_norm = np.sqrt(dx * np.sum((u - u_exact)**2))\n        errors.append(error_norm)\n        \n    p_50_100 = np.log(errors[0] / errors[1]) / np.log(2.0)\n    p_100_200 = np.log(errors[1] / errors[2]) / np.log(2.0)\n\n    # --- Task D: Edge-case stability probe ---\n    d_N = 128\n    d_alpha = 1.0\n    d_n_steps = 50\n    d_mu_values = [0.49, 0.50, 0.51]\n    \n    stability_results = []\n    \n    dx_d = 1.0 / d_N\n    i_indices = np.arange(d_N)\n    u0 = (-1.0)**i_indices\n    # Initial norm calculation\n    norm0 = np.sqrt(dx_d * np.sum(u0**2))\n    \n    for mu in d_mu_values:\n        u = np.copy(u0) # Reset to initial condition for each run\n        \n        for _ in range(d_n_steps):\n            Lh_u = np.roll(u, -1) - 2 * u + np.roll(u, 1)\n            u_star = u + mu * Lh_u\n            \n            Lh_u_star = np.roll(u_star, -1) - 2 * u_star + np.roll(u_star, 1)\n            u = u + (mu / 2.0) * (Lh_u + Lh_u_star)\n\n        # Final norm and stability check\n        norm_n = np.sqrt(dx_d * np.sum(u**2))\n        is_stable = (norm_n / norm0) <= 1.01\n        stability_results.append(is_stable)\n\n    # Combine results from all tasks\n    results = [p_50_100, p_100_200] + stability_results\n\n    # Final print statement in the exact required format.\n    # str(True) -> 'True', str(False) -> 'False' as per standard Python conversion.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2400909"}, {"introduction": "Armed with an understanding of stability and accuracy, we now tackle a more realistic problem: heat diffusion on a two-dimensional circular disk. This practice [@problem_id:2400870] introduces the challenges of non-Cartesian coordinate systems, requiring a careful discretization of the Laplacian operator at the origin to handle the coordinate singularity. You will implement the powerful, unconditionally stable Crank-Nicolson method, a cornerstone of computational physics that requires solving a linear system at each time step.", "problem": "Consider the radially symmetric heat conduction in a two-dimensional circular disk of radius $R$, where the temperature depends only on the radial coordinate $r$ and time $t$. The governing equation, derived from local energy conservation and Fourier’s law of heat conduction, is the heat equation in polar coordinates without angular dependence:\n$$\n\\frac{\\partial u}{\\partial t}(r,t) = \\alpha \\left( \\frac{\\partial^2 u}{\\partial r^2}(r,t) + \\frac{1}{r}\\frac{\\partial u}{\\partial r}(r,t) \\right), \\quad 0 \\le r \\le R, \\; t \\ge 0,\n$$\nwith boundary condition $u(R,t) = 0$ for all $t \\ge 0$, and regularity at the origin consistent with physical symmetry. Assume all quantities are dimensionless.\n\nYour task is to write a complete, runnable program that computes the temperature evolution using an unconditionally stable, second-order accurate in time scheme for this initial-boundary value problem. The spatial discretization must be second-order accurate and must be constructed so that the discretization at the origin $r=0$ is consistent with the polar form of the Laplace operator and the symmetry condition implied by finite energy and Fourier’s law. You must start from the conservation-law form and obtain a discretization that respects the correct limiting behavior as $r \\to 0$.\n\nUse the following specifications:\n\n- The computational domain is the interval $[0,R]$ in the radial coordinate.\n- Use a uniform grid $r_i = i \\,\\Delta r$ for $i = 0,1,\\dots,N$, where $\\Delta r = R/N$.\n- Impose the boundary condition $u_N^n = 0$ for all time levels $n$.\n- The initial condition is $u(r,0) = \\exp\\!\\left( -\\left(\\frac{r}{\\sigma}\\right)^2 \\right)$.\n- The time-stepping scheme must be the Crank–Nicolson method (also known as the trapezoidal rule in time), which is unconditionally stable and second-order accurate in time when paired with a second-order accurate spatial discretization. Assemble the method in matrix form and solve the resulting linear system at each time step.\n- The discrete spatial operator must correctly handle $r=0$ without singularities and must be derived from first principles by taking the appropriate limit of the polar Laplacian at the origin. You must not introduce ad hoc lower-order fixes at $r=0$.\n\nTest suite and output:\n\n- Run your program for the following four test cases. In each case, set the parameters $(\\alpha, R, \\sigma, N, M, T)$ as listed below, where $M$ is the number of uniform time steps and $\\Delta t = T/M$:\n  - Case $1$: $(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.2, 200, 50, 0.05)$.\n  - Case $2$: $(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.2, 50, 50, 0.05)$.\n  - Case $3$: $(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.05, 200, 100, 0.02)$.\n  - Case $4$: $(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.5, 200, 50, 0.05)$.\n- For each case, compute the numerical solution up to final time $T$ and report the temperature at the origin, i.e., $u(0,T)$.\n- Your program must produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $4$. Each number must be rounded to eight decimal places. For example, the output format must be exactly\n$[x_1,x_2,x_3,x_4]$\nwhere each $x_i$ is $u(0,T)$ for Case $i$, rounded to eight decimal places.\n\nYour implementation must be self-contained, must not read any user input, and must not require any external files or network access. The final answer of the question must be code. Ensure scientific realism by deriving and using a spatial discretization at the origin that is consistent with the limiting behavior of the polar Laplacian. The numerical quantities in this problem are dimensionless; no physical units are required. The final output format requirement is strict and must be followed exactly.", "solution": "The problem presented is a well-posed initial-boundary value problem for the linear heat equation in a two-dimensional disk with radial symmetry. It is scientifically sound and contains all necessary information for a numerical solution. We shall therefore proceed with its resolution.\n\nOur objective is to compute the temperature evolution $u(r,t)$ governed by the radially symmetric heat equation in polar coordinates:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\left( \\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial u}{\\partial r} \\right)\n$$\nfor $r \\in [0, R]$ and $t \\ge 0$. The problem is subject to the boundary condition $u(R,t) = 0$ and the initial condition $u(r,0) = \\exp(-(r/\\sigma)^2)$. Physical consistency requires the temperature gradient to vanish at the origin due to symmetry, i.e., $\\frac{\\partial u}{\\partial r}\\big|_{r=0} = 0$.\n\nWe will employ the Crank-Nicolson method for time integration, which is a second-order accurate and unconditionally stable scheme. The equation is discretized in time as:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} \\left( \\mathcal{L}_h \\mathbf{u}^{n+1} + \\mathcal{L}_h \\mathbf{u}^n \\right)\n$$\nwhere $\\mathbf{u}^n$ is the vector of numerical solutions at time $t_n = n\\Delta t$, and $\\mathcal{L}_h$ is the discrete spatial operator approximating the continuous operator $\\mathcal{L} \\equiv \\alpha \\left( \\frac{\\partial^2}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial}{\\partial r} \\right)$. The scheme is implicit and can be arranged into a linear system to be solved at each time step:\n$$\n\\left(I - \\frac{\\Delta t}{2} L\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\Delta t}{2} L\\right) \\mathbf{u}^n\n$$\nwhere $L$ is the matrix representation of $\\mathcal{L}_h$. The vector of unknowns consists of the temperature at the discrete radial points $\\mathbf{u} = [u_0, u_1, \\ldots, u_{N-1}]^T$, corresponding to radii $r_i = i\\Delta r$ for $i=0, \\ldots, N-1$, with $\\Delta r = R/N$. The boundary condition fixes $u_N^n = 0$ for all $n$.\n\nThe crucial step is to construct a second-order accurate spatial discretization $\\mathcal{L}_h$.\n\nFor interior points $r_i$ where $i \\in \\{1, 2, \\ldots, N-1\\}$, we use standard second-order central difference formulas for the derivatives:\n$$\n\\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r_i} \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{(\\Delta r)^2}, \\quad \\frac{\\partial u}{\\partial r}\\bigg|_{r_i} \\approx \\frac{u_{i+1} - u_{i-1}}{2\\Delta r}\n$$\nSubstituting these into the expression for $\\mathcal{L}u$ yields the discrete operator at node $i$:\n$$\n(\\mathcal{L}_h \\mathbf{u})_i = \\alpha \\left( \\frac{u_{i+1} - 2u_i + u_{i-1}}{(\\Delta r)^2} + \\frac{1}{i\\Delta r} \\frac{u_{i+1} - u_{i-1}}{2\\Delta r} \\right) = \\frac{\\alpha}{(\\Delta r)^2} \\left[ \\left(1 - \\frac{1}{2i}\\right)u_{i-1} - 2u_i + \\left(1 + \\frac{1}{2i}\\right)u_{i+1} \\right]\n$$\n\nAt the origin, $r=0$ ($i=0$), the term $\\frac{1}{r}\\frac{\\partial u}{\\partial r}$ is singular. A correct discretization must be derived by considering the limiting behavior of the Laplacian operator. By symmetry, the temperature profile must be an even function of $r$, which implies $\\frac{\\partial u}{\\partial r}\\big|_{r=0} = 0$. Applying L'Hôpital's rule to the singular term, we find:\n$$\n\\lim_{r\\to 0} \\frac{1}{r}\\frac{\\partial u}{\\partial r} = \\lim_{r\\to 0} \\frac{\\frac{\\partial^2 u}{\\partial r^2}}{1} = \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0}\n$$\nThus, the heat equation at the origin becomes:\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{r=0} = \\alpha \\left( \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0} + \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0} \\right) = 2\\alpha \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0}\n$$\nWe discretize the second derivative at $r=0$ using a central difference. The symmetry condition $u_r(0)=0$ implies that for a Taylor expansion around $r=0$, $u(r) = u(0) + \\frac{1}{2}u_{rr}(0)r^2 + O(r^4)$. This implies $u(\\Delta r) = u(-\\Delta r)$, which in our discrete notation is $u_1 = u_{-1}$. The central difference for $u_{rr}(0)$ is:\n$$\n\\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r_0} \\approx \\frac{u_1 - 2u_0 + u_{-1}}{(\\Delta r)^2} = \\frac{u_1 - 2u_0 + u_1}{(\\Delta r)^2} = \\frac{2(u_1 - u_0)}{(\\Delta r)^2}\n$$\nSubstituting this into the specialized heat equation at the origin gives the discretization for $i=0$:\n$$\n(\\mathcal{L}_h \\mathbf{u})_0 = 2\\alpha \\left( \\frac{2(u_1 - u_0)}{(\\Delta r)^2} \\right) = \\frac{4\\alpha}{(\\Delta r)^2} (u_1 - u_0)\n$$\nThis discretization is second-order accurate and consistent with the geometry.\n\nWith these expressions, we construct the $N \\times N$ matrix $L$. Let $c = \\alpha/(\\Delta r)^2$.\n- The first row ($i=0$) is: $L_{0,0} = -4c$, $L_{0,1} = 4c$, and $L_{0,j}=0$ for $j>1$.\n- For rows $i=1, \\ldots, N-2$, the non-zero elements are:\n  $L_{i,i-1} = c(1 - 1/(2i))$, $L_{i,i} = -2c$, and $L_{i,i+1} = c(1+1/(2i))$.\n- The last row ($i=N-1$) must account for the boundary condition $u_N=0$:\n  $L_{N-1,N-2} = c(1 - 1/(2(N-1)))$ and $L_{N-1,N-1} = -2c$.\n\nThe algorithm proceeds as follows:\n1.  For each test case, define parameters $(\\alpha, R, \\sigma, N, M, T)$ and calculate $\\Delta r=R/N$ and $\\Delta t=T/M$.\n2.  Construct the matrices $A = I - \\frac{\\Delta t}{2} L$ and $B = I + \\frac{\\Delta t}{2} L$. For efficiency, we compute the LU factorization of matrix $A$ once before the time-stepping loop.\n3.  Initialize the solution vector $\\mathbf{u}^0$ using the initial condition: $u_i^0 = \\exp(-(i\\Delta r/\\sigma)^2)$ for $i=0, \\ldots, N-1$.\n4.  Iterate for $n=0, \\ldots, M-1$:\n    a. Compute the right-hand-side vector $\\mathbf{b} = B \\mathbf{u}^n$.\n    b. Solve the linear system $A \\mathbf{u}^{n+1} = \\mathbf{b}$ for $\\mathbf{u}^{n+1}$ using the pre-computed LU factorization of $A$.\n5.  After $M$ steps, the final temperature at the origin is $u_0^M$, which is the first element of the final solution vector. This value is reported.\nThe implementation will use `numpy` for matrix operations and `scipy.linalg` for the efficient solution of the linear system.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to solve the radially symmetric heat equation for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, R, sigma, N, M, T)\n        (1.0, 1.0, 0.2, 200, 50, 0.05),\n        (1.0, 1.0, 0.2, 50, 50, 0.05),\n        (1.0, 1.0, 0.05, 200, 100, 0.02),\n        (1.0, 1.0, 0.5, 200, 50, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, R, sigma, N, M, T = case\n        result = run_simulation(alpha, R, sigma, N, M, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_simulation(alpha, R, sigma, N, M, T):\n    \"\"\"\n    Computes the temperature evolution for a single test case.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        R (float): Radius of the disk.\n        sigma (float): Width of the initial Gaussian profile.\n        N (int): Number of spatial grid points in the radius (excluding the boundary).\n        M (int): Number of time steps.\n        T (float): Final time.\n\n    Returns:\n        float: Temperature at the origin u(0, T).\n    \"\"\"\n    # Grid parameters\n    dr = R / N\n    dt = T / M\n    \n    # Grid points for r (interior points from r=0 to r=R-dr)\n    r = np.linspace(0, R - dr, N)\n\n    # Construct the spatial discretization matrix L\n    # The size of the system is N x N for points u_0, u_1, ..., u_{N-1}\n    L = np.zeros((N, N))\n    c = alpha / dr**2\n\n    # Equation at the origin (i=0)\n    L[0, 0] = -4.0 * c\n    L[0, 1] = 4.0 * c\n\n    # Equations for interior points (i=1 to N-2)\n    for i in range(1, N - 1):\n        # r_i = i * dr, so the coefficients simplify\n        L[i, i - 1] = c * (1.0 - 1.0 / (2.0 * i))\n        L[i, i]     = -2.0 * c\n        L[i, i + 1] = c * (1.0 + 1.0 / (2.0 * i))\n\n    # Equation at the point next to the boundary (i=N-1)\n    # The u_N term is zero due to boundary condition and moves to the other side.\n    if N > 1:\n        i = N - 1\n        L[i, i - 1] = c * (1.0 - 1.0 / (2.0 * i))\n        L[i, i]     = -2.0 * c\n        # The u_{N} term is u_N = 0, so L[i, i+1] which would reference u_N is zero.\n\n    # Construct Crank-Nicolson matrices A and B\n    # A u^{n+1} = B u^{n}\n    # where A = I - dt/2 * L, B = I + dt/2 * L\n    I = np.identity(N)\n    A = I - (dt / 2.0) * L\n    B = I + (dt / 2.0) * L\n\n    # Initial condition u(r, 0)\n    u = np.exp(-(r / sigma)**2)\n\n    # Pre-compute LU factorization of A for efficiency\n    try:\n        lu_and_piv = linalg.lu_factor(A)\n    except linalg.LinAlgError:\n        # This case should not be reached for a well-posed problem.\n        return np.nan\n\n    # Time-stepping loop\n    for _ in range(M):\n        # Calculate the right-hand side vector\n        b = B @ u\n        # Solve the linear system A u_next = b\n        u = linalg.lu_solve(lu_and_piv, b)\n\n    # Return the temperature at the origin at the final time\n    return u[0]\n\n# Execute the solver\nsolve()\n```", "id": "2400870"}]}