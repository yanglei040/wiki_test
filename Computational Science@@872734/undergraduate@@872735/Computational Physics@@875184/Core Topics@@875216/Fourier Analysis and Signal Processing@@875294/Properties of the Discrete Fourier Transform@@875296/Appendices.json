{"hands_on_practices": [{"introduction": "The relationship between operations in the time domain and their counterparts in the frequency domain is a cornerstone of Fourier analysis. This exercise focuses on time-scaling operations like compression (downsampling) and expansion (upsampling) of a discrete signal and their effect on the Discrete Fourier Transform (DFT). By numerically verifying these properties [@problem_id:2431109], you will build a strong intuition for the time-frequency duality and see firsthand how operations like downsampling can lead to aliasing.", "problem": "You are given the task of verifying precise relationships between the Discrete Fourier Transform (DFT) of a sequence and the DFTs of versions of the sequence that are compressed or stretched in the discrete-time sense. Work only with finite-length sequences and the DFT as defined below. All indices are integer, and all transforms are computed exactly as finite sums.\n\nDefinition of the Discrete Fourier Transform (DFT): For a sequence $x[n]$ of length $N$, its DFT $X[k]$ is defined by\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-j \\, 2\\pi \\, k \\, n / N}, \\quad k=0,1,\\dots,N-1,\n$$\nand the inverse DFT is\n$$\nx[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{j \\, 2\\pi \\, k \\, n / N}, \\quad n=0,1,\\dots,N-1.\n$$\n\nDefine the following three operations on sequences:\n\n1. Discrete-time expansion (upsampling by factor $L$): Given a sequence $x[n]$ of length $N$ and an integer $L \\ge 1$, define a sequence $y_{\\text{exp}}[n]$ of length $N' = L N$ by\n$$\ny_{\\text{exp}}[n] = \n\\begin{cases}\nx\\!\\left[\\dfrac{n}{L}\\right],  \\text{if } n \\text{ is a multiple of } L, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n\\quad n=0,1,\\dots,N'-1.\n$$\n\n2. Discrete-time compression (downsampling by factor $M$): Given a sequence $x[n]$ of length $N$ and an integer $M \\ge 1$ that divides $N$, define a sequence $y_{\\text{comp}}[n]$ of length $Q = N/M$ by\n$$\ny_{\\text{comp}}[n] = x[M n], \\quad n=0,1,\\dots,Q-1.\n$$\n\n3. Circular index scaling modulo $N$ (with $a$ coprime to $N$): Given a sequence $x[n]$ of length $N$ and an integer $a$ such that $\\gcd(a,N)=1$, define a sequence $y_{\\text{circ}}[n]$ of length $N$ by\n$$\ny_{\\text{circ}}[n] = x[(a n) \\bmod N], \\quad n=0,1,\\dots,N-1.\n$$\n\nYour program must verify the following properties directly from the definitions above, with a numerical absolute tolerance of $\\varepsilon = 10^{-9}$ on complex-valued equality:\n\n- Expansion property: If $Y_{\\text{exp}}[k]$ is the DFT of $y_{\\text{exp}}[n]$ of length $N' = L N$ and $X[k]$ is the DFT of $x[n]$ of length $N$, then\n$$\nY_{\\text{exp}}[k] = X[k \\bmod N], \\quad k=0,1,\\dots,N'-1.\n$$\n\n- Compression property: If $Y_{\\text{comp}}[k]$ is the DFT of $y_{\\text{comp}}[n]$ of length $Q = N/M$ and $X[k]$ is the DFT of $x[n]$ of length $N$, then\n$$\nY_{\\text{comp}}[k] = \\frac{1}{M} \\sum_{r=0}^{M-1} X[k + r Q], \\quad k=0,1,\\dots,Q-1,\n$$\nwhere all indices of $X[\\cdot]$ are taken in the range $0$ to $N-1$ and $Q = N/M$ is an integer.\n\n- Circular index scaling property: If $Y_{\\text{circ}}[k]$ is the DFT of $y_{\\text{circ}}[n]$ of length $N$ and $X[k]$ is the DFT of $x[n]$ of length $N$, then\n$$\nY_{\\text{circ}}[k] = X[(k \\, a^{-1}) \\bmod N], \\quad k=0,1,\\dots,N-1,\n$$\nwhere $a^{-1}$ is the multiplicative inverse of $a$ modulo $N$ (that is, $a \\, a^{-1} \\equiv 1 \\pmod{N}$).\n\nTest Suite. For each test, compute the necessary DFTs and verify the corresponding property by checking that the maximum absolute difference between the two sides is at most $\\varepsilon = 10^{-9}$. Produce one boolean result per test case.\n\n- Test $1$ (Expansion, general): $N=8$, $L=3$, $x[n] = \\cos\\!\\left(2\\pi \\cdot 1 \\cdot n / 8\\right) + \\tfrac{1}{2}\\sin\\!\\left(2\\pi \\cdot 2 \\cdot n / 8\\right)$ for $n=0,1,\\dots,7$.\n\n- Test $2$ (Compression, general): $N=12$, $M=3$, $x[n] = (-1)^n + \\tfrac{1}{4} n$ for $n=0,1,\\dots,11$.\n\n- Test $3$ (Boundary, identity scaling): $N=10$, $a=1$. Define $x[n] = \\cos\\!\\left(2\\pi \\cdot 4 \\cdot n / 10\\right) + \\sin\\!\\left(2\\pi \\cdot 3 \\cdot n / 10\\right)$ for $n=0,1,\\dots,9$. Verify both the expansion property with $L=1$ and the compression property with $M=1$ simultaneously; the test result is true if and only if both verifications succeed at tolerance $\\varepsilon$.\n\n- Test $4$ (Circular scaling, coprime factor): $N=10$, $a=3$ with $\\gcd(3,10)=1$. Define $x[n] = \\cos\\!\\left(2\\pi \\cdot 4 \\cdot n / 10\\right) + \\sin\\!\\left(2\\pi \\cdot 3 \\cdot n / 10\\right)$ for $n=0,1,\\dots,9$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Each result must be a boolean corresponding to the tests in the order listed above. No additional text or whitespace is permitted in the output line. No physical units are involved in this problem; all quantities are dimensionless real or complex numbers. Angles in trigonometric functions are in radians.", "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded, well-posed, objective, and self-contained. The problem concerns the verification of standard, well-established properties of the Discrete Fourier Transform (DFT) in the context of digital signal processing and computational physics. The definitions, operations, and claimed properties are stated with mathematical precision and are theoretically sound. We shall now proceed with the solution.\n\nThe core of the problem is to verify three properties of the DFT related to time-domain scaling operations: expansion (upsampling), compression (downsampling), and circular index scaling. We will first provide a brief analytical proof for each property, as rigor dictates, and then outline the numerical procedure for verification.\n\nLet $x[n]$ be a sequence of length $N$, and its DFT be $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi k n / N}$, where $j$ is the imaginary unit.\n\n**1. Expansion Property**\n\nGiven a sequence $x[n]$ of length $N$, the expanded sequence $y_{\\text{exp}}[n]$ of length $N' = LN$ is defined as:\n$$\ny_{\\text{exp}}[n] = \n\\begin{cases}\nx[n/L],  \\text{if } n \\text{ is a multiple of } L, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\nThe property to verify is $Y_{\\text{exp}}[k] = X[k \\bmod N]$ for $k=0, 1, \\dots, N'-1$.\n\n**Derivation:**\nThe DFT of $y_{\\text{exp}}[n]$ is given by:\n$$\nY_{\\text{exp}}[k] = \\sum_{n=0}^{N'-1} y_{\\text{exp}}[n] e^{-j 2\\pi k n / N'}\n$$\nSince $y_{\\text{exp}}[n]$ is non-zero only for $n$ that are multiples of $L$, we can substitute $n = mL$ where $m$ ranges from $0$ to $N-1$:\n$$\nY_{\\text{exp}}[k] = \\sum_{m=0}^{N-1} y_{\\text{exp}}[mL] e^{-j 2\\pi k (mL) / (LN)}\n$$\nBy definition of $y_{\\text{exp}}$, $y_{\\text{exp}}[mL] = x[m]$. Substituting this into the equation:\n$$\nY_{\\text{exp}}[k] = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi k m / N}\n$$\nThe right-hand side is the definition of the DFT of $x[n]$, which we denote as $X[\\cdot]$ evaluated at frequency index $k$. The DFT $X[k]$ is inherently periodic with period $N$, meaning $X[k] = X[k+aN]$ for any integer $a$. Therefore, for any $k$, the expression is equivalent to $X[k \\bmod N]$. Thus, the property $Y_{\\text{exp}}[k] = X[k \\bmod N]$ is correct.\n\n**2. Compression Property**\n\nGiven a sequence $x[n]$ of length $N$ and an integer $M$ that divides $N$, the compressed sequence $y_{\\text{comp}}[n]$ of length $Q = N/M$ is defined as $y_{\\text{comp}}[n] = x[Mn]$ for $n=0, 1, \\dots, Q-1$.\nThe property to verify is $Y_{\\text{comp}}[k] = \\frac{1}{M} \\sum_{r=0}^{M-1} X[k + rQ]$ for $k=0, 1, \\dots, Q-1$.\n\n**Derivation:**\nWe start with the inverse DFT expression for $x[n]$ and substitute it into the definition of $y_{\\text{comp}}[n]$:\n$$\ny_{\\text{comp}}[n] = x[Mn] = \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] e^{j 2\\pi p (Mn) / N}\n$$\nSince $N = MQ$, this simplifies to:\n$$\ny_{\\text{comp}}[n] = \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] e^{j 2\\pi p n / Q}\n$$\nNow, we compute the DFT of $y_{\\text{comp}}[n]$:\n$$\nY_{\\text{comp}}[k] = \\sum_{n=0}^{Q-1} y_{\\text{comp}}[n] e^{-j 2\\pi k n / Q} = \\sum_{n=0}^{Q-1} \\left( \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] e^{j 2\\pi p n / Q} \\right) e^{-j 2\\pi k n / Q}\n$$\nReordering the sums:\n$$\nY_{\\text{comp}}[k] = \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] \\left( \\sum_{n=0}^{Q-1} e^{j 2\\pi (p-k) n / Q} \\right)\n$$\nThe inner sum is a geometric series sum, which equals $Q$ if $p-k$ is a multiple of $Q$ (i.e., $p-k = rQ$ for some integer $r$), and $0$ otherwise. Therefore, we only need to sum over values of $p$ such that $p = k + rQ$. Since $0 \\le p  N$, the possible values of $r$ are $0, 1, \\dots, M-1$.\n$$\nY_{\\text{comp}}[k] = \\frac{1}{N} \\sum_{r=0}^{M-1} X[k+rQ] \\cdot Q\n$$\nSince $Q/N = 1/M$, we arrive at the desired property:\n$$\nY_{\\text{comp}}[k] = \\frac{1}{M} \\sum_{r=0}^{M-1} X[k+rQ]\n$$\nThis confirms the correctness of the compression property.\n\n**3. Circular Index Scaling Property**\n\nGiven a sequence $x[n]$ of length $N$ and an integer $a$ coprime to $N$, the scaled sequence is $y_{\\text{circ}}[n] = x[(an) \\bmod N]$.\nThe property to verify is $Y_{\\text{circ}}[k] = X[(k a^{-1}) \\bmod N]$, where $a a^{-1} \\equiv 1 \\pmod{N}$.\n\n**Derivation:**\nThe DFT of $y_{\\text{circ}}[n]$ is:\n$$\nY_{\\text{circ}}[k] = \\sum_{n=0}^{N-1} y_{\\text{circ}}[n] e^{-j 2\\pi k n / N} = \\sum_{n=0}^{N-1} x[(an) \\bmod N] e^{-j 2\\pi k n / N}\n$$\nSince $\\gcd(a,N)=1$, the mapping $m = (an) \\bmod N$ is a permutation of the set $\\{0, 1, \\dots, N-1\\}$. We can perform a change of summation variable from $n$ to $m$. The inverse mapping is $n = (a^{-1}m) \\bmod N$, where $a^{-1}$ is the multiplicative inverse of $a$ modulo $N$.\n$$\nY_{\\text{circ}}[k] = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi k ((a^{-1}m) \\bmod N) / N}\n$$\nDue to the periodicity of the complex exponential, $e^{-j 2\\pi \\theta} = e^{-j 2\\pi (\\theta \\bmod 1)}$, we can remove the modulo operation in the exponent's numerator if we let $a^{-1}_{int}$ be the integer representative of the inverse in $\\{1, \\dots, N-1\\}$:\n$$\nY_{\\text{circ}}[k] = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi k (a^{-1}_{int} m) / N} = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi (k a^{-1}_{int}) m / N}\n$$\nThis expression is precisely the DFT of $x[m]$ evaluated at the frequency index $k' = (k a^{-1}_{int}) \\bmod N$.\n$$\nY_{\\text{circ}}[k] = X[(k a^{-1}) \\bmod N]\n$$\nThe property is thus analytically correct.\n\n**Numerical Verification Procedure:**\nFor each test case, the verification follows a consistent procedure:\n1.  Generate the base signal $x[n]$ of length $N$ according to the given formula.\n2.  Compute its DFT, $X[k]$, using a standard Fast Fourier Transform (FFT) algorithm, as provided by `numpy.fft.fft`.\n3.  Construct the transformed signal ($y_{\\text{exp}}$, $y_{\\text{comp}}$, or $y_{\\text{circ}}$) according to its definition.\n4.  Compute the DFT of the transformed signal ($Y_{\\text{exp}}$, $Y_{\\text{comp}}$, or $Y_{\\text{circ}}$). This forms the left-hand side (LHS) of the identity.\n5.  Construct the right-hand side (RHS) of the identity using the pre-computed $X[k]$ and the specified formula.\n6.  Calculate the maximum absolute difference between the complex-valued LHS and RHS arrays: $\\max_k | \\text{LHS}[k] - \\text{RHS}[k] |$.\n7.  The property is considered verified if this difference is less than or equal to the specified tolerance $\\varepsilon = 10^{-9}$.\n\nThis procedure is applied to each of the four test cases described in the problem statement. For Test $3$, verification of both the expansion and compression properties for the trivial cases ($L=1$, $M=1$) must succeed for the overall test to be true. The modular multiplicative inverse required for Test $4$ is computed using `pow(a, -1, N)`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT properties verification problem.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: Expansion property\n    def test_1():\n        N = 8\n        L = 3\n        n = np.arange(N)\n        x = np.cos(2 * np.pi * 1 * n / N) + 0.5 * np.sin(2 * np.pi * 2 * n / N)\n        X = np.fft.fft(x)\n\n        N_prime = L * N\n        y_exp = np.zeros(N_prime, dtype=np.float64)\n        for n_prime in range(N_prime):\n            if n_prime % L == 0:\n                y_exp[n_prime] = x[n_prime // L]\n        \n        # LHS: DFT of the expanded sequence\n        Y_exp_lhs = np.fft.fft(y_exp)\n\n        # RHS: Periodically repeated original DFT\n        Y_exp_rhs = np.zeros(N_prime, dtype=np.complex128)\n        k_prime = np.arange(N_prime)\n        Y_exp_rhs = X[k_prime % N]\n        \n        max_diff = np.max(np.abs(Y_exp_lhs - Y_exp_rhs))\n        return max_diff = epsilon\n\n    results.append(test_1())\n\n    # Test 2: Compression property\n    def test_2():\n        N = 12\n        M = 3\n        n = np.arange(N)\n        x = (-1)**n + 0.25 * n\n        X = np.fft.fft(x)\n\n        Q = N // M\n        y_comp = x[::M]\n        \n        # LHS: DFT of the compressed sequence\n        Y_comp_lhs = np.fft.fft(y_comp)\n        \n        # RHS: Sum of aliased components\n        Y_comp_rhs = np.zeros(Q, dtype=np.complex128)\n        for k in range(Q):\n            for r in range(M):\n                Y_comp_rhs[k] += X[k + r * Q]\n        Y_comp_rhs /= M\n        \n        max_diff = np.max(np.abs(Y_comp_lhs - Y_comp_rhs))\n        return max_diff = epsilon\n\n    results.append(test_2())\n\n    # Test 3: Boundary cases (L=1, M=1)\n    def test_3():\n        N = 10\n        n = np.arange(N)\n        x = np.cos(2 * np.pi * 4 * n / N) + np.sin(2 * np.pi * 3 * n / N)\n        X = np.fft.fft(x)\n\n        # Part A: Expansion with L=1\n        L = 1\n        N_prime = L * N\n        y_exp = x # y_exp is just x\n        Y_exp_lhs = np.fft.fft(y_exp)\n        k_prime = np.arange(N_prime)\n        Y_exp_rhs = X[k_prime % N]\n        check_L1 = np.max(np.abs(Y_exp_lhs - Y_exp_rhs)) = epsilon\n\n        # Part B: Compression with M=1\n        M = 1\n        Q = N // M\n        y_comp = x # y_comp is just x\n        Y_comp_lhs = np.fft.fft(y_comp)\n        Y_comp_rhs = np.zeros(Q, dtype=np.complex128)\n        for k in range(Q):\n            for r in range(M):\n                Y_comp_rhs[k] += X[k + r * Q]\n        Y_comp_rhs /= M\n        check_M1 = np.max(np.abs(Y_comp_lhs - Y_comp_rhs)) = epsilon\n        \n        return check_L1 and check_M1\n\n    results.append(test_3())\n\n    # Test 4: Circular index scaling property\n    def test_4():\n        N = 10\n        a = 3\n        n = np.arange(N)\n        x = np.cos(2 * np.pi * 4 * n / N) + np.sin(2 * np.pi * 3 * n / N)\n        X = np.fft.fft(x)\n        \n        # In Python 3.8+, pow(a, -1, m) computes modular inverse\n        a_inv = pow(a, -1, N)\n\n        y_circ = np.zeros(N, dtype=np.float64)\n        for n_val in range(N):\n            y_circ[n_val] = x[(a * n_val) % N]\n\n        # LHS: DFT of the circularly scaled sequence\n        Y_circ_lhs = np.fft.fft(y_circ)\n\n        # RHS: Permuted original DFT\n        Y_circ_rhs = np.zeros(N, dtype=np.complex128)\n        for k in range(N):\n            Y_circ_rhs[k] = X[(k * a_inv) % N]\n        \n        max_diff = np.max(np.abs(Y_circ_lhs - Y_circ_rhs))\n        return max_diff = epsilon\n\n    results.append(test_4())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2431109"}, {"introduction": "A common practice in signal analysis is to zero-pad a signal before computing its DFT to achieve a higher frequency resolution in the resulting plot. This exercise reveals what is truly happening: zero-padding in the time domain corresponds to an exact interpolation of the frequency spectrum with a periodic sinc function (the Dirichlet kernel). This practice [@problem_id:2431114] is vital for correctly interpreting high-density DFT plots, as it teaches you to distinguish between true spectral content and interpolated points.", "problem": "You are given a finite-length discrete-time signal $x_n$ of length $N$, where $n \\in \\{0,1,\\dots,N-1\\}$. Define its length-$N$ Discrete Fourier Transform (DFT) $X^{(N)}_k$ by\n$$\nX^{(N)}_k = \\sum_{n=0}^{N-1} x_n \\, e^{-j 2\\pi k n / N}, \\quad k \\in \\{0,1,\\dots,N-1\\}.\n$$\nDefine the zero-padded sequence $\\tilde{x}_n$ of length $M$ by\n$$\n\\tilde{x}_n = \\begin{cases}\nx_n,  0 \\le n \\le N-1,\\\\\n0,  N \\le n \\le M-1,\n\\end{cases}\n$$\nand its length-$M$ Discrete Fourier Transform $X^{(M)}_r$ by\n$$\nX^{(M)}_r = \\sum_{n=0}^{M-1} \\tilde{x}_n \\, e^{-j 2\\pi r n / M}, \\quad r \\in \\{0,1,\\dots,M-1\\}.\n$$\nUsing only first principles (the definitions of the Discrete Fourier Transform and its inverse), your program must demonstrate the exact relationship between $X^{(M)}_r$ and the $N$-point spectrum $X^{(N)}_k$ that arises from zero-padding in the time domain. For each test case below, compute two quantities for the same pair $(N,M)$ and sequence $x_n$: \n(1) the length-$M$ spectrum obtained directly from the zero-padded sequence by the definition of the Discrete Fourier Transform, and \n(2) the length-$M$ spectrum expressed entirely in terms of $X^{(N)}_k$ and elementary finite sums implied by the Discrete Fourier Transform and its inverse. \nThen return, for each test case, the maximal absolute difference between these two spectra across all indices $r \\in \\{0,1,\\dots,M-1\\}$, as a floating-point decimal.\n\nTest suite:\n- Case A (general composite real sinusoid): $N=16$, $M=128$, and $x_n = \\cos\\!\\left(2\\pi \\cdot 3.5 \\, n / 16\\right) + 0.6 \\, \\sin\\!\\left(2\\pi \\cdot 5 \\, n / 16\\right)$ for all integer $n$ with $0 \\le n \\le 15$.\n- Case B (Kronecker delta): $N=9$, $M=27$, and $x_n = 1$ if $n=0$ and $x_n=0$ otherwise, for $0 \\le n \\le 8$.\n- Case C (bin-centered complex exponential): $N=10$, $M=100$, and $x_n = e^{j 2\\pi \\cdot 3 \\, n / 10}$ for $0 \\le n \\le 9$.\n- Case D (non-sinusoidal, alternating component): $N=12$, $M=50$, and $x_n = (n+1)/12 + 0.1\\,(-1)^n$ for $0 \\le n \\le 11$.\n\nNo physical units are involved. Angles are in radians. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC,resultD]\"). Each entry must be the maximal absolute difference for the corresponding case, represented as a floating-point number.", "solution": "Let $x_n$ be given for $n \\in \\{0,1,\\dots,N-1\\}$. The length-$N$ Discrete Fourier Transform (DFT) is\n$$\nX^{(N)}_k = \\sum_{n=0}^{N-1} x_n \\, e^{-j 2\\pi k n / N}, \\quad k=0,1,\\dots,N-1.\n$$\nThe inverse Discrete Fourier Transform (IDFT) on this convention is\n$$\nx_n = \\frac{1}{N}\\sum_{k=0}^{N-1} X^{(N)}_k \\, e^{j 2\\pi k n / N}, \\quad n=0,1,\\dots,N-1.\n$$\nDefine the zero-padded sequence $\\tilde{x}_n$ of length $M \\ge N$ by $\\tilde{x}_n=x_n$ for $0 \\le n \\le N-1$ and $\\tilde{x}_n=0$ for $N \\le n \\le M-1$. Its length-$M$ DFT is\n$$\nX^{(M)}_r = \\sum_{n=0}^{M-1} \\tilde{x}_n \\, e^{-j 2\\pi r n / M} = \\sum_{n=0}^{N-1} x_n \\, e^{-j 2\\pi r n / M}, \\quad r=0,1,\\dots,M-1,\n$$\nsince $\\tilde{x}_n=0$ for $n \\ge N$. Substitute the inverse DFT for $x_n$:\n$$\nX^{(M)}_r = \\sum_{n=0}^{N-1} \\left(\\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\, e^{j 2\\pi k n / N}\\right) e^{-j 2\\pi r n / M}\n= \\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\sum_{n=0}^{N-1} e^{j 2\\pi n \\left(\\frac{k}{N} - \\frac{r}{M}\\right)}.\n$$\nThe inner finite geometric sum is the Dirichlet kernel in complex-exponential form:\n$$\nD_N(\\alpha) \\equiv \\sum_{n=0}^{N-1} e^{j 2\\pi n \\alpha}\n= e^{j \\pi \\alpha (N-1)} \\, \\frac{\\sin(\\pi N \\alpha)}{\\sin(\\pi \\alpha)},\n$$\nwith the continuous extension $D_N(0)=N$ obtained by the limit $\\alpha \\to 0$. Therefore,\n$$\nX^{(M)}_r = \\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\, D_N\\!\\left(\\frac{k}{N}-\\frac{r}{M}\\right).\n$$\nThis shows that $X^{(M)}_r$ is obtained from the length-$N$ DFT samples $X^{(N)}_k$ by interpolation with the Dirichlet kernel, which is a periodic sinc. In other words, zero-padding the time-domain sequence produces a finer sampling in frequency that equals the Dirichlet (periodic sinc) interpolation of the coarse DFT samples. The identity is exact for all integers $N \\ge 1$ and $M \\ge N$ and all sequences $x_n$.\n\nAlgorithmic plan grounded in the above principles:\n- Compute $X^{(M)}_r$ directly from the zero-padded time-domain sequence via the Discrete Fourier Transform definition (implemented by a standard Fast Fourier Transform, which is computationally equivalent to the definition).\n- Separately compute $X^{(N)}_k$ for the original length-$N$ sequence, and then construct\n$$\n\\widehat{X}^{(M)}_r = \\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\, D_N\\!\\left(\\frac{k}{N}-\\frac{r}{M}\\right),\n$$\nwhere $D_N(\\alpha)$ is evaluated either by the finite sum definition or by the closed form above with the continuous extension at $\\alpha=0$.\n- For each test case, report\n$$\n\\max_{0 \\le r \\le M-1} \\left| X^{(M)}_r - \\widehat{X}^{(M)}_r \\right|\n$$\nas a floating-point decimal.\n\nBecause the identity is exact, the reported maximal absolute differences are expected to be at the level of floating-point rounding error (on the order of the machine precision, typically around $10^{-15}$ to $10^{-13}$ for double-precision computations), including at indices where $\\frac{k}{N}-\\frac{r}{M}=0$, for which the limit $D_N(0)=N$ must be used. The test suite covers:\n- A general composite real sinusoid (Case A),\n- A Kronecker delta (Case B),\n- A bin-centered complex exponential (Case C),\n- A non-sinusoidal sequence with an alternating component (Case D).\nIn all cases, the maximal discrepancy should be numerically negligible, validating that zero-padding in the time domain corresponds to Dirichlet (periodic sinc) interpolation in the frequency domain.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dirichlet_kernel(N: int, alpha: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute D_N(alpha) = sum_{n=0}^{N-1} exp(j 2π n alpha)\n    using the closed-form expression with robust handling at alpha=0.\n\n    Parameters:\n        N: int, sequence length\n        alpha: ndarray of floats, same shape as output\n\n    Returns:\n        ndarray of complex128 with same shape as alpha\n    \"\"\"\n    alpha = np.asarray(alpha, dtype=np.float64)\n    # Compute using closed-form: e^{jπ alpha (N-1)} * sin(π N alpha) / sin(π alpha)\n    numer = np.sin(np.pi * N * alpha)\n    denom = np.sin(np.pi * alpha)\n\n    # General case\n    with np.errstate(divide='ignore', invalid='ignore'):\n        kernel = np.exp(1j * np.pi * alpha * (N - 1)) * (numer / denom)\n\n    # Handle alpha near integer multiples (here only near 0 under our alpha range) where denom ~ 0\n    # Limit as alpha - 0 is N.\n    mask = np.isclose(denom, 0.0, atol=1e-12)\n    if np.any(mask):\n        kernel = kernel.astype(np.complex128, copy=False)\n        kernel[mask] = N + 0j\n    return kernel\n\ndef zero_padded_spectrum_direct(x: np.ndarray, M: int) - np.ndarray:\n    \"\"\"\n    Compute the M-point DFT of x zero-padded to length M.\n    \"\"\"\n    N = x.shape[0]\n    padded = np.zeros(M, dtype=np.complex128)\n    padded[:N] = x.astype(np.complex128)\n    return np.fft.fft(padded, n=M)\n\ndef spectrum_interpolated_from_XN(x: np.ndarray, M: int) - np.ndarray:\n    \"\"\"\n    Compute the M-point spectrum from the N-point spectrum X^{(N)}_k\n    using the Dirichlet-kernel interpolation identity:\n        X^{(M)}_r = (1/N) sum_k X^{(N)}_k D_N(k/N - r/M)\n    \"\"\"\n    N = x.shape[0]\n    XN = np.fft.fft(x, n=N)  # X^{(N)}_k\n    # Build alpha grid: shape (M, N) for r in [0..M-1], k in [0..N-1]\n    r = np.arange(M, dtype=np.float64).reshape(-1, 1)  # (M,1)\n    k = np.arange(N, dtype=np.float64).reshape(1, -1)  # (1,N)\n    alpha = k / N - r / M                              # (M,N)\n    D = dirichlet_kernel(N, alpha)                     # (M,N)\n    X_interp = (D @ XN) / N                            # (M,)\n    return X_interp\n\ndef max_abs_diff_between_methods(x: np.ndarray, M: int) - float:\n    \"\"\"\n    Compute max_r |X_zp(r) - X_interp(r)| as a float.\n    \"\"\"\n    X_direct = zero_padded_spectrum_direct(x, M)\n    X_interp = spectrum_interpolated_from_XN(x, M)\n    diff = np.abs(X_direct - X_interp)\n    return float(np.max(diff))\n\ndef make_test_cases():\n    \"\"\"\n    Construct the test cases as specified in the problem statement.\n    Returns a list of tuples (x, M) with x as np.ndarray (complex128) of length N.\n    \"\"\"\n    cases = []\n\n    # Case A: N=16, M=128, x_n = cos(2π*3.5*n/16) + 0.6*sin(2π*5*n/16)\n    N_A, M_A = 16, 128\n    nA = np.arange(N_A, dtype=np.float64)\n    xA = np.cos(2.0 * np.pi * 3.5 * nA / N_A) + 0.6 * np.sin(2.0 * np.pi * 5.0 * nA / N_A)\n    cases.append((xA.astype(np.complex128), M_A))\n\n    # Case B: N=9, M=27, Kronecker delta at n=0\n    N_B, M_B = 9, 27\n    xB = np.zeros(N_B, dtype=np.complex128)\n    xB[0] = 1.0 + 0.0j\n    cases.append((xB, M_B))\n\n    # Case C: N=10, M=100, x_n = exp(j 2π*3*n/10)\n    N_C, M_C = 10, 100\n    nC = np.arange(N_C, dtype=np.float64)\n    xC = np.exp(1j * 2.0 * np.pi * 3.0 * nC / N_C)\n    cases.append((xC.astype(np.complex128), M_C))\n\n    # Case D: N=12, M=50, x_n = (n+1)/12 + 0.1*(-1)^n\n    N_D, M_D = 12, 50\n    nD = np.arange(N_D, dtype=np.float64)\n    xD = (nD + 1.0) / 12.0 + 0.1 * ((-1.0) ** nD)\n    cases.append((xD.astype(np.complex128), M_D))\n\n    return cases\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = make_test_cases()\n\n    results = []\n    for x, M in test_cases:\n        result = max_abs_diff_between_methods(x, M)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2431114"}, {"introduction": "In many physical applications, the input signals are purely real-valued, yet standard Fast Fourier Transform (FFT) algorithms are designed for complex inputs. This problem introduces a powerful optimization based on the DFT's Hermitian symmetry property for real signals, which states that $X[k] = \\overline{X[N-k]}$. By implementing this technique [@problem_id:2431155], you will learn how to compute an $N$-point DFT of a real signal using a single, more efficient complex FFT of length $N/2$, a valuable skill in high-performance scientific computing.", "problem": "You are given a real-valued discrete-time signal of even length $N$. The discrete Fourier transform (DFT) of $x[n]$ is defined by\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-2\\pi j\\, kn/N},\\quad k=0,1,\\dots,N-1,\n$$\nwhere $j$ denotes the imaginary unit and all angles are in radians. For real $x[n]$, the DFT satisfies Hermitian symmetry, so the information content is fully captured by the unique half-spectrum\n$$\nH[k] = X[k],\\quad k=0,1,\\dots,N/2,\n$$\nwith $N$ even.\n\nWrite a complete program that, for each test case listed below, computes the half-spectrum $H[k]$ for the given real input sequence $x[n]$ of length $N$ in two independent ways:\n- By any correct algorithm of your choice that computes the unique half-spectrum for real input.\n- By directly applying the defining sum of the discrete Fourier transform to compute $X[k]$ for $k=0,1,\\dots,N/2$.\n\nFor each test case, your program must output a single floating-point number equal to the maximum absolute difference between the two half-spectra across all $k$ in $\\{0,1,\\dots,N/2\\}$.\n\nAngles must be interpreted in radians. Each result must be rounded to $10^{-12}$ before printing.\n\nTest suite (each case specifies an even length $N$ and a real sequence $x[n]$):\n- Case $1$: $N=8$, $x[n] = \\cos\\!\\big(2\\pi\\cdot 2\\, n/N\\big)$ for $n=0,1,\\dots,N-1$.\n- Case $2$: $N=10$, $x[n] = \\sin\\!\\big(2\\pi\\cdot 3\\, n/N\\big) + 0.5\\,\\cos\\!\\big(2\\pi\\cdot 1\\, n/N\\big)$ for $n=0,1,\\dots,N-1$.\n- Case $3$: $N=16$, $x[n] = \\delta_{n,0}$ (the Kronecker delta), that is, $x[0]=1$ and $x[n]=0$ for $n=1,2,\\dots,N-1$.\n- Case $4$: $N=16$, $x[n] = 1$ for all $n=0,1,\\dots,N-1$.\n- Case $5$: $N=2$, $x[0]=1$, $x[1]=-1$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each number rounded to $10^{-12}$ and printed in scientific notation with $12$ digits after the decimal point, for example, \"[a,b,c]\" where each of $a,b,c$ follows this numerical format.", "solution": "The discrete Fourier transform (DFT) for an input sequence $x[n]$ of even length $N$ is defined by\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-2\\pi j\\, kn/N},\\quad k=0,1,\\dots,N-1.\n$$\nWhen $x[n]$ is real-valued, the DFT exhibits Hermitian symmetry, namely $X[N-k] = \\overline{X[k]}$ for all $k$, where the overline denotes complex conjugation. Therefore, the unique spectral information is contained in the half-spectrum\n$$\nH[k] = X[k],\\quad k=0,1,\\dots,N/2.\n$$\nThe problem requires, for each test case, two independent computations of $H[k]$:\n- One derived directly from the definition above by evaluating the sum for each $k$ in $\\{0,1,\\dots,N/2\\}$.\n- One obtained by a correct algorithm that produces the same $H[k]$ for real input.\n\nA principled and efficient construction can be derived from first principles by decomposing the DFT into even and odd indexed parts. Let $N$ be even and define $M=N/2$. Partition $x[n]$ into even and odd subsequences $x_e[n]=x[2n]$ and $x_o[n]=x[2n+1]$ for $n=0,1,\\dots,M-1$. Define the $M$-point DFTs\n$$\nE[k] = \\sum_{n=0}^{M-1} x_e[n]\\, e^{-2\\pi j\\, kn/M},\\quad\nO[k] = \\sum_{n=0}^{M-1} x_o[n]\\, e^{-2\\pi j\\, kn/M},\\quad k=0,1,\\dots,M-1.\n$$\nBy substitution into the DFT definition, the $N$-point DFT of $x[n]$ can be expressed in terms of the DFTs of its even and odd parts (the Cooley-Tukey radix-2 decomposition). For $k=0,1,\\dots,M-1$, the relations are:\n$$\nX[k] = E[k] + W_N^k\\, O[k],\\qquad\nX[k+M] = E[k] - W_N^k\\, O[k],\n$$\nwhere $W_N = e^{-2\\pi j / N}$ is the primitive $N$-th root of unity. The half-spectrum requires values up to $k=M$. The endpoint $X[M]$ is given by the second formula with $k=0$:\n$$\nX[M] = E[0] - W_N^0 O[0] = E[0] - O[0],\n$$\nsince $E[M]=E[0]$ and $O[M]=O[0]$ by the $M$-periodicity of the DFTs. For real-valued input $x[n]$, the spectrum also exhibits Hermitian symmetry, $X[N-k]=\\overline{X[k]}$, which is implicitly handled by this efficient algorithm.\n\nTo reduce the number of transforms to one $M$-point transform, combine the even and odd parts into a single complex sequence\n$$\ny[n] = x_e[n] + j\\, x_o[n],\\quad n=0,1,\\dots,M-1,\n$$\nand compute its $M$-point DFT\n$$\nY[k] = \\sum_{n=0}^{M-1} y[n]\\, e^{-2\\pi j\\, kn/M} = E[k] + j\\, O[k].\n$$\nUsing properties of the discrete Fourier transform and conjugate symmetry for real inputs, one also has\n$$\n\\overline{Y[(M-k)\\bmod M]} = E[k] - j\\, O[k],\\quad k=0,1,\\dots,M-1.\n$$\nSolving for $E[k]$ and $O[k]$ yields\n$$\nE[k] = \\tfrac{1}{2}\\big(Y[k] + \\overline{Y[(M-k)\\bmod M]}\\big),\\qquad\nO[k] = -\\tfrac{j}{2}\\big(Y[k] - \\overline{Y[(M-k)\\bmod M]}\\big).\n$$\nTherefore, for $k=1,2,\\dots,M-1$,\n$$\nX[k] = E[k] + W_N^k\\, O[k] = \\tfrac{1}{2}\\big(Y[k] + \\overline{Y[M-k]}\\big) - \\tfrac{j}{2} W_N^k \\big(Y[k] - \\overline{Y[M-k]}\\big).\n$$\nThe endpoints follow from $Y[0] = E[0] + j\\, O[0]$:\n$$\nX[0] = E[0] + O[0] = \\operatorname{Re}\\{Y[0]\\} + \\operatorname{Im}\\{Y[0]\\},\\qquad\nX[M] = E[0] - O[0] = \\operatorname{Re}\\{Y[0]\\} - \\operatorname{Im}\\{Y[0]\\}.\n$$\nThis construction computes the exact half-spectrum from a single $M$-point complex DFT and algebraic post-processing, fully derived from the DFT definition and symmetry for real data.\n\nFor verification, compute the reference half-spectrum directly from the definition:\n$$\nH_{\\text{ref}}[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-2\\pi j\\, kn/N},\\quad k=0,1,\\dots,M.\n$$\nFor each test case, compute\n$$\n\\varepsilon = \\max_{0\\le k\\le M} \\left| H[k] - H_{\\text{ref}}[k] \\right|,\n$$\nround $\\varepsilon$ to $10^{-12}$, and report it.\n\nThe test suite covers several important behaviors: a single-bin cosine ($N=8$), a sum of in-bin sinusoidal components ($N=10$), an impulse ($N=16$), a constant signal ($N=16$), and the smallest even length case ($N=2$). These exercise Hermitian symmetry endpoints, interior bins, and boundary conditions. The final program constructs each $x[n]$, computes both half-spectra as described, evaluates the maximum absolute deviation, rounds to $10^{-12}$, and prints the results as a single bracketed list in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef r2c_half_spectrum_via_half_fft(x: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute the unique half-spectrum H[k] = X[k], k=0..N/2, for real x of even length N,\n    using a single complex FFT of length N/2 and post-processing.\n    The packed sequence is y[n] = x[2n] + j x[2n+1].\n    The twiddle factor is W_N^k = exp(-2π j k / N).\n    \"\"\"\n    x = np.asarray(x, dtype=np.float64)\n    N = x.size\n    if N % 2 != 0 or N == 0:\n        raise ValueError(\"Input length must be a positive even integer.\")\n    M = N // 2\n\n    # Pack even and odd samples into a complex sequence y[n] = x[2n] + j x[2n+1]\n    y = x[0::2] + 1j * x[1::2]  # length M\n\n    # Compute M-point complex FFT\n    Y = np.fft.fft(y)\n\n    # Allocate half-spectrum H[0..M] (complex-valued)\n    H = np.empty(M + 1, dtype=np.complex128)\n\n    # Endpoints from Y[0] = E0 + j O0\n    E0 = Y[0].real\n    O0 = Y[0].imag\n    H[0] = (E0 + O0) + 0j\n    H[M] = (E0 - O0) + 0j\n\n    # Interior bins 1..M-1\n    # Twiddle factor W_N^k = exp(-2π j k / N)\n    for k in range(1, M):\n        a = Y[k]\n        b = np.conj(Y[M - k])\n        E = 0.5 * (a + b)\n        O = (-0.5j) * (a - b)\n        W = np.exp(-2j * np.pi * k / N)\n        H[k] = E + W * O\n\n    return H\n\ndef dft_half_spectrum_direct(x: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute the unique half-spectrum directly from the DFT definition:\n    H[k] = sum_{n=0}^{N-1} x[n] * exp(-2π j k n / N), for k = 0..N/2.\n    \"\"\"\n    x = np.asarray(x, dtype=np.float64)\n    N = x.size\n    if N % 2 != 0 or N == 0:\n        raise ValueError(\"Input length must be a positive even integer.\")\n    M = N // 2\n    n = np.arange(N, dtype=np.float64)\n    H = np.empty(M + 1, dtype=np.complex128)\n    for k in range(M + 1):\n        H[k] = np.sum(x * np.exp(-2j * np.pi * k * n / N))\n    return H\n\ndef max_abs_diff_half(x: np.ndarray) - float:\n    \"\"\"\n    Compute the maximum absolute difference between the half-spectrum computed via\n    the half-length complex FFT method and the direct DFT definition.\n    \"\"\"\n    H_fft = r2c_half_spectrum_via_half_fft(x)\n    H_dir = dft_half_spectrum_direct(x)\n    diff = np.max(np.abs(H_fft - H_dir))\n    # Round to 1e-12 as required\n    return float(np.round(diff, 12))\n\ndef build_test_cases():\n    cases = []\n\n    # Case 1: N=8, x[n] = cos(2π * 2 n / N)\n    N1 = 8\n    n1 = np.arange(N1, dtype=np.float64)\n    x1 = np.cos(2.0 * np.pi * 2.0 * n1 / N1)\n    cases.append(x1)\n\n    # Case 2: N=10, x[n] = sin(2π * 3 n / N) + 0.5*cos(2π * 1 n / N)\n    N2 = 10\n    n2 = np.arange(N2, dtype=np.float64)\n    x2 = np.sin(2.0 * np.pi * 3.0 * n2 / N2) + 0.5 * np.cos(2.0 * np.pi * 1.0 * n2 / N2)\n    cases.append(x2)\n\n    # Case 3: N=16, impulse at n=0\n    N3 = 16\n    x3 = np.zeros(N3, dtype=np.float64)\n    x3[0] = 1.0\n    cases.append(x3)\n\n    # Case 4: N=16, constant ones\n    N4 = 16\n    x4 = np.ones(N4, dtype=np.float64)\n    cases.append(x4)\n\n    # Case 5: N=2, [1, -1]\n    x5 = np.array([1.0, -1.0], dtype=np.float64)\n    cases.append(x5)\n\n    return cases\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = build_test_cases()\n\n    results = []\n    for x in test_cases:\n        result = max_abs_diff_half(x)\n        results.append(result)\n\n    # Final print statement in the exact required format:\n    # comma-separated floats in scientific notation with 12 digits after the decimal.\n    formatted = \",\".join(f\"{v:.12e}\" for v in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2431155"}]}