{"hands_on_practices": [{"introduction": "To truly master the Fast Fourier Transform, it's invaluable to build it from the ground up. This practice guides you through implementing the radix-2 Cooley-Tukey algorithm, the very engine that powers countless scientific applications. By constructing the algorithm and verifying its correctness against both a direct $\\mathcal{O}(N^2)$ implementation and fundamental theorems like circular convolution and Parseval's identity, you will develop a deep and practical understanding of its remarkable efficiency and mathematical structure [@problem_id:2387187].", "problem": "Let $N$ be a positive integer of the form $N = 2^m$ for some nonnegative integer $m$. For a length-$N$ complex-valued sequence $x = \\{x_n\\}_{n=0}^{N-1}$, the discrete Fourier transform (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ is defined by\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1,\n$$\nand the inverse discrete Fourier transform (IDFT) is defined by\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N} \\quad \\text{for } n = 0,1,\\dots,N-1,\n$$\nwhere all angles are in radians.\n\nWrite a complete program that, without calling any library Fourier transform routines, computes the DFT and IDFT for sequences of length $N = 2^m$. Your program must also verify the following fundamental properties against explicit test cases using only these definitions:\n\n- Circular convolution theorem: For sequences $a$ and $b$ of length $N$, their length-$N$ circular convolution $c$ defined by $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$ satisfies $C_k = A_k B_k$, where $A$, $B$, and $C$ are the DFTs of $a$, $b$, and $c$, respectively.\n- Parseval identity (with the above normalization): $\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$.\n\nYour program must implement its own fast algorithm to compute the DFT and IDFT for $N = 2^m$, and must include a direct $\\mathcal{O}(N^2)$ DFT for verification. Use a numerical tolerance $\\varepsilon = 10^{-9}$ where boolean validations are required. All angles must be interpreted in radians.\n\nUse the following test suite, and produce the outputs in the order given below:\n\n- Test $1$ (DFT correctness versus direct DFT, happy path): Let $N = 8$ and $x = [0,1,2,3,4,3,2,1]$. Compute $X$ using your fast implementation and $\\tilde{X}$ using the direct DFT. Output a boolean equal to $\\text{True}$ if $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $2$ (Inverse transform recovery): Using the same $N$ and $x$ as in Test $1$, compute $x'$ by applying your IDFT to $X$ from your fast implementation. Output a boolean equal to $\\text{True}$ if $\\max_n |x'_n - x_n| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $3$ (Circular convolution via frequency domain): Let $N = 8$, $a = [1,2,3,0,0,0,0,0]$, and $b = [0,1,0,0,0,0,0,0]$. Compute the length-$N$ circular convolution $c$ directly from its definition. Separately, compute $\\hat{c}$ by taking the DFTs of $a$ and $b$, multiplying pointwise, and applying the IDFT. Output the scalar $\\max_n |c_n - \\hat{c}_n|$ as a floating-point number.\n- Test $4$ (Parseval identity): Let $N = 16$ and $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$ for $n = 0,1,\\dots,15$. Compute $X$ by your fast implementation. Output the scalar $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$ as a floating-point number.\n- Test $5$ (Edge case $N=1$): Let $N = 1$ and $x = [3 + 4i]$. Compute $X$ and then $x'$ via IDFT. Output a boolean equal to $\\text{True}$ if $|x'_0 - x_0| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $6$ (Smallest nontrivial size $N=2$): Let $N = 2$ and $x = [1,-1]$. Compute $X$ by your fast implementation. The exact DFT under the given convention is $[0,2]$. Output the scalar $\\max_k |X_k - [0,2]_k|$ as a floating-point number.\n\nFinal output format: Your program should produce a single line of output containing the six results, in order, as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5,r_6]$. All boolean entries must be either $\\text{True}$ or $\\text{False}$, and all real-valued entries must be printed in standard decimal or scientific notation. No other text should be printed.", "solution": "The problem presented is a well-posed and scientifically sound exercise in computational physics, specifically in the area of signal processing. It requires the implementation and verification of the Discrete Fourier Transform (DFT), its inverse (IDFT), and fundamental associated theorems. The problem is complete, objective, and its resolution is verifiable. We will proceed with the solution.\n\nThe core of the problem is the computation of the DFT, $X$, for a given discrete, complex-valued sequence, $x = \\{x_n\\}_{n=0}^{N-1}$, of length $N$. The definition is given as:\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\nA direct implementation of this formula involves two nested loops, one for each index $k$ from $0$ to $N-1$ and one for each index $n$ from $0$ to $N-1$. This leads to a computational complexity of $\\mathcal{O}(N^2)$, which is inefficient for large $N$. For verification purposes, such a direct method will be implemented.\n\nThe problem specifies that $N$ is a power of two, i.e., $N = 2^m$ for some non-negative integer $m$. This structure is key for employing a Fast Fourier Transform (FFT) algorithm, specifically the Cooley-Tukey decimation-in-time algorithm. This algorithm reduces the complexity from $\\mathcal{O}(N^2)$ to $\\mathcal{O}(N \\log N)$. The principle is one of divide and conquer. The length-$N$ DFT is recursively broken down into two length-$(N/2)$ DFTs.\n\nLet the sequence $x_n$ be split into its even-indexed elements, forming a sequence $x'_m = x_{2m}$, and its odd-indexed elements, forming a sequence $x''_m = x_{2m+1}$, each of length $N/2$. The DFT sum can be rewritten as:\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi i k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi i k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi i k m / (N/2)} + e^{-2\\pi i k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi i k m / (N/2)}\n$$\nLet $X'_k$ and $X''_k$ be the length-$(N/2)$ DFTs of $x'_m$ and $x''_m$, respectively. The expressions above become:\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\nwhere $W_N^k = e^{-2\\pi i k/N}$ is the \"twiddle factor\". For $k$ in the first half of the indices, $0 \\le k < N/2$, we have:\n$$\nX_k = X'_k + W_N^k X''_k\n$$\nFor the second half, where the index is $k+N/2$ for $0 \\le k < N/2$, we use the properties $X'_{k+N/2} = X'_k$, $X''_{k+N/2} = X''_k$, and $W_N^{k+N/2} = -W_N^k$. This yields:\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\nThis recursive definition allows the construction of the full DFT. The recursion terminates at the base case $N=1$, where the DFT of a sequence $\\{x_0\\}$ is simply $\\{X_0\\} = \\{x_0\\}$. Our implementation will follow this recursive structure.\n\nThe Inverse Discrete Fourier Transform (IDFT) is defined as:\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N}\n$$\nA separate implementation is not necessary. We can relate the IDFT to the forward DFT. Observe the following derivation:\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi i k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi i k n / N}\n$$\nThe right-hand side is the DFT of the complex-conjugated sequence $\\{\\overline{X_k}\\}_{k=0}^{N-1}$. Therefore, we can find $x_n$ by computing the DFT of $\\overline{X}$, taking the complex conjugate of the result, and scaling by $1/N$. That is, $x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$. This allows us to use our efficient FFT implementation to compute the inverse transform (IFFT) as well.\n\nThe problem further requires verification of two fundamental theorems.\n\nFirst, the circular convolution theorem. The circular convolution $c$ of two length-$N$ sequences, $a$ and $b$, is given by $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$. The theorem states that the DFT of the convolution is the pointwise product of the individual DFTs: $C_k = A_k B_k$. Thus, one can compute $c$ via the frequency domain: $c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$, where $\\odot$ denotes element-wise multiplication. We will test this by computing $c$ both directly and via the frequency domain route and comparing the results.\n\nSecond, Parseval's identity. For the given DFT normalization, the identity is:\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\nThis theorem relates the total energy of a signal in the time domain to its energy in the frequency domain. We will verify this for a specific test signal.\n\nThe program will proceed by first defining the necessary functions: a direct $\\mathcal{O}(N^2)$ DFT, a recursive $\\mathcal{O}(N \\log N)$ FFT, an IFFT based on the FFT, and a direct circular convolution function. Then, it will execute the $6$ specified test cases using these functions and a numerical tolerance of $\\varepsilon = 10^{-9}$ for comparisons. The results will be collected and printed in the required format.", "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N <= 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 <= epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 <= epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 <= epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2387187"}, {"introduction": "Beyond signal analysis, the FFT is a powerful tool for signal synthesis. This exercise demonstrates how to engineer a signal with specific spectral characteristics by applying a filter directly in the frequency domain. You will start with a simple white noise signal, which has a flat power spectrum, and transform it into pink noise, where the power is inversely proportional to frequency ($P(f) \\propto 1/f$), a signal type ubiquitous in physics and nature [@problem_id:2383316].", "problem": "Write a complete, runnable program that constructs a discrete-time signal that approximates pink noise by filtering a white noise sequence in the frequency domain so that its power spectrum satisfies $P(f) \\propto 1/f$. Let the sequence length be $N \\in \\mathbb{N}$, and let the discrete-time white noise sequence be $\\{x[n]\\}_{n=0}^{N-1}$, where each $x[n]$ is independently drawn from a Gaussian distribution with mean $0$ and variance $1$. For reproducibility, the pseudo-random number generator must be initialized with a given integer seed $s$. Use the following definitions and requirements.\n\n1. Define the Discrete Fourier Transform (DFT) and its inverse for $N$ samples by\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n]\\,e^{-i\\,2\\pi nk/N}, \\quad k=0,1,\\dots,N-1,\n$$\n$$\nx[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\,e^{i\\,2\\pi nk/N}, \\quad n=0,1,\\dots,N-1.\n$$\nAll angles in the complex exponentials are in radians.\n\n2. Define a real, nonnegative, conjugate-symmetric frequency-domain filter $H[k]$ for $k=0,1,\\dots,N-1$ by\n$$\nH[0] = 0,\\quad H[k] = \\frac{1}{\\sqrt{\\min(k,\\,N-k)}} \\text{ for } k=1,2,\\dots,N-1.\n$$\nForm the filtered spectrum $Y[k] = H[k]\\,X[k]$, and then obtain the filtered time-domain sequence $y[n]$ by the inverse transform applied to $Y[k]$ as above.\n\n3. Define the empirical power spectrum of $y[n]$ as\n$$\nS[k] = \\left|\\sum_{n=0}^{N-1} y[n]\\,e^{-i\\,2\\pi nk/N}\\right|^2, \\quad k=0,1,\\dots,N-1.\n$$\nTo quantify how well the result approximates pink noise, estimate the slope $a$ in the linear model\n$$\n\\log S[k] \\approx a\\,\\log k + b\n$$\nover the index range $k=1,2,\\dots,\\left\\lfloor N/2 \\right\\rfloor - 1$ using ordinary least squares, where $b$ is an intercept. The expected slope for ideal pink noise is $a=-1$.\n\n4. Your program must compute the estimated slope $a$ for each test case below. Each white-noise sequence must be generated by a pseudo-random number generator initialized with the specified integer seed $s$, and each sequence must have length $N$. Assume $N$ is a power of $2$. The test suite is:\n- Case $1$: $(N,s) = (8,\\,1)$.\n- Case $2$: $(N,s) = (64,\\,7)$.\n- Case $3$: $(N,s) = (256,\\,42)$.\n- Case $4$: $(N,s) = (512,\\,99)$.\n\n5. Final output format: Your program should produce a single line of output containing the four estimated slopes as a comma-separated list enclosed in square brackets, with each slope rounded to $3$ decimal places, in the order of the test cases above. For example, an output line has the form\n$$\n[\\text{a}_1,\\text{a}_2,\\text{a}_3,\\text{a}_4].\n$$\n\nNo external input is provided. All computations must be performed within the program. The final answers are pure numbers (unitless).", "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically grounded, mathematically well-posed, objective, and provides a complete and consistent set of definitions and requirements for constructing a unique, verifiable solution. We shall therefore proceed with the derivation and implementation.\n\nThe objective is to synthesize a discrete-time signal $y[n]$ that approximates pink noise, characterized by a power spectrum $S[f]$ proportional to $1/f$. The method specified is to filter a discrete white noise sequence $x[n]$ in the frequency domain.\n\nFirst, we establish the theoretical foundation. A discrete-time white noise sequence, $\\{x[n]\\}_{n=0}^{N-1}$, where each sample is drawn independently from a Gaussian distribution with mean $\\mu=0$ and variance $\\sigma^2=1$, has an expected power spectrum that is flat. That is, the expectation of the squared magnitude of its Discrete Fourier Transform (DFT), $E[|X[k]|^2]$, is constant for all frequency indices $k > 0$.\n\nThe filtering operation is performed in the frequency domain. Let $X[k]$ be the DFT of the input white noise $x[n]$:\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n]\\,e^{-i\\,2\\pi nk/N}\n$$\nThe problem defines a frequency-domain filter $H[k]$. The filtered spectrum $Y[k]$ is obtained by element-wise multiplication:\n$$\nY[k] = H[k] \\cdot X[k]\n$$\nThe resulting time-domain signal, our pink noise approximation $y[n]$, is the Inverse Discrete Fourier Transform (IDFT) of $Y[k]$:\n$$\ny[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} Y[k]\\,e^{i\\,2\\pi nk/N}\n$$\nThe DFT and IDFT definitions provided conform to the standard implementation in scientific computing libraries such as NumPy, specifically with a normalization factor of $1/N$ on the inverse transform.\n\nThe empirical power spectrum of the output signal $y[n]$ is given by $S[k] = |Y[k]|^2$. Substituting the expression for $Y[k]$, we have:\n$$\nS[k] = |H[k] \\cdot X[k]|^2 = |H[k]|^2 \\cdot |X[k]|^2\n$$\nSince $|X[k]|^2$ is approximately constant for a realization of white noise, the shape of the output power spectrum $S[k]$ is determined by $|H[k]|^2$. To achieve a pink noise spectrum where power is proportional to $1/f$, which corresponds to $1/k$ in the discrete frequency domain, we must design a filter such that $|H[k]|^2 \\propto 1/k$. This implies that the magnitude of the filter transfer function should be $|H[k]| \\propto 1/\\sqrt{k}$.\n\nThe problem provides a specific filter definition:\n$$\nH[0] = 0,\\quad H[k] = \\frac{1}{\\sqrt{\\min(k,\\,N-k)}} \\text{ for } k=1,2,\\dots,N-1.\n$$\nThe condition $H[0]=0$ forces the DC component ($k=0$) of the signal to be zero, resulting in a signal with zero mean. For $k > 0$, the term $\\min(k, N-k)$ correctly corresponds to the integer frequency magnitude, accounting for the conjugate symmetry of the DFT of a real signal ($X[k] = X[N-k]^*$). This filter is real-valued and symmetric ($H[k] = H[N-k]$), which ensures that the filtered spectrum $Y[k] = H[k]X[k]$ is also conjugate symmetric, guaranteeing that the output signal $y[n]$ is purely real. The filter magnitude $|H[k]|$ is precisely $1/\\sqrt{k_{eff}}$, where $k_{eff}$ is the effective frequency index, thus shaping the white noise spectrum into the desired $1/k$ form.\n\nTo verify the \"pinkness\" of the generated signal, we analyze its power spectrum $S[k]$. If $S[k] \\propto 1/k$, then in a log-log plot, the relationship becomes linear:\n$$\n\\log S[k] \\approx \\log(C/k) = -\\log k + \\log C\n$$\nThis is a linear model of the form $\\log S[k] \\approx a\\,\\log k + b$, with an expected slope of $a = -1$. The algorithm must estimate the slope $a$ using ordinary least squares (OLS) linear regression on the generated data points $(\\log k, \\log S[k])$. The regression is performed over the range of frequency indices $k=1, 2, \\dots, \\lfloor N/2 \\rfloor - 1$, which avoids the DC component ($k=0$) where $\\log k$ is undefined, and also excludes the Nyquist frequency and higher reflective frequencies where aliasing and boundary effects can distort the power-law relationship.\n\nThe computational procedure for each test case $(N, s)$ is as follows:\n1.  Initialize a pseudo-random number generator with the given integer seed $s$ for reproducibility.\n2.  Generate a sequence $x[n]$ of length $N$ by drawing from a standard normal distribution (mean $0$, variance $1$).\n3.  Compute the DFT, $X[k]$, of the sequence $x[n]$ using a Fast Fourier Transform (FFT) algorithm.\n4.  Construct the filter array $H[k]$ of length $N$ according to its definition. This is most efficiently implemented by using the discrete frequency values corresponding to each index $k$.\n5.  Compute the filtered spectrum $Y[k] = H[k] \\cdot X[k]$.\n6.  Calculate the empirical power spectrum $S[k] = |Y[k]|^2$.\n7.  Define the fitting range for the regression: $k_{fit} = \\{1, 2, \\dots, \\lfloor N/2 \\rfloor - 1\\}$.\n8.  Extract the corresponding values from the power spectrum, $S_{fit} = \\{S[1], S[2], \\dots, S[\\lfloor N/2 \\rfloor - 1]\\}$.\n9.  Perform OLS regression on $\\log(S_{fit})$ versus $\\log(k_{fit})$ to find the slope $a$. A function such as `numpy.polyfit` is suitable for this purpose.\n10. The computed slope $a$ is the result for the given test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Generates pink noise by filtering white noise in the frequency domain\n    and calculates the slope of its log-log power spectrum.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, 1),\n        (64, 7),\n        (256, 42),\n        (512, 99),\n    ]\n\n    results = []\n    for N, s in test_cases:\n        # Step 1: Initialize the pseudo-random number generator with the specified seed.\n        rng = np.random.default_rng(s)\n\n        # Step 2: Generate a discrete-time white noise sequence.\n        # x[n] are independently drawn from a Gaussian distribution with mean 0 and variance 1.\n        x = rng.standard_normal(N)\n\n        # Step 3: Compute the Discrete Fourier Transform (DFT) of the white noise.\n        # The numpy.fft.fft function implements the specified DFT definition.\n        X = np.fft.fft(x)\n\n        # Step 4: Define the real, nonnegative, conjugate-symmetric frequency-domain filter H[k].\n        # The frequency values corresponding to DFT indices k=0,1,...,N-1 can be found\n        # using numpy.fft.fftfreq. Multiplying by N gives integer frequencies.\n        # The absolute value corresponds to min(k, N-k).\n        k_freq = np.abs(np.fft.fftfreq(N) * N)\n        \n        # Initialize filter with zeros.\n        H = np.zeros_like(k_freq, dtype=float)\n        \n        # For k > 0, H[k] = 1/sqrt(k). This avoids division by zero at k=0.\n        # This correctly sets H[0] = 0 as required.\n        non_zero_indices = k_freq > 0\n        H[non_zero_indices] = 1.0 / np.sqrt(k_freq[non_zero_indices])\n        \n        # Step 5: Form the filtered spectrum Y[k] = H[k]*X[k].\n        Y = H * X\n\n        # Step 6: Define the empirical power spectrum S[k] = |Y[k]|^2.\n        # This is equivalent to |DFT(y[n])|^2, as Y is the DFT of the output signal y[n].\n        S = np.abs(Y)**2\n        \n        # Step 7: Estimate the slope 'a' of the log-log power spectrum.\n        # The linear model is log S[k] ≈ a*log k + b.\n        # The regression is performed over the index range k = 1, 2, ..., floor(N/2) - 1.\n        \n        # Define the range of k for the linear regression.\n        fit_range_k = np.arange(1, N // 2)\n        \n        # Extract the corresponding power spectrum values.\n        fit_range_S = S[1 : N // 2]\n        \n        # Take the logarithm of k and S for the linear fit.\n        log_k = np.log(fit_range_k)\n        log_S = np.log(fit_range_S)\n        \n        # Perform ordinary least squares using numpy.polyfit to find the slope 'a'.\n        # polyfit with degree 1 returns [slope, intercept].\n        slope, _ = np.polyfit(log_k, log_S, 1)\n\n        results.append(slope)\n\n    # Final print statement in the exact required format.\n    # The slopes are rounded to 3 decimal places.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2383316"}, {"introduction": "Perhaps one of the most powerful applications of the FFT in computational physics is in solving partial differential equations. This practice applies the Cooley-Tukey algorithm to the core of the split-step Fourier method, a premier technique for simulating quantum dynamics. By evolving the time-dependent Schrödinger equation, you will model the tunneling of a Gaussian wavepacket through a potential barrier, providing a direct, hands-on visualization of a fundamental quantum mechanical phenomenon [@problem_id:2383392].", "problem": "You are to derive, implement, and validate a numerical solver for one-dimensional quantum tunneling of a Gaussian wavepacket through a rectangular potential barrier using the split-step Fourier method. Your implementation must rely on the Cooley–Tukey Fast Fourier Transform (FFT) algorithm via a standard numerical library call. Start from the time-dependent Schrödinger equation and build the method from first principles.\n\nUse the following fundamental base and modeling assumptions:\n- The time-dependent Schrödinger equation in one dimension is \n$$\ni\\,\\hbar\\,\\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\frac{\\hbar^2}{2m}\\,\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} \\;+\\; V(x)\\,\\psi(x,t).\n$$\n- Work in atomic units with reduced Planck constant and mass set to $ \\hbar = 1 $ and $ m = 1 $, so that the equation reduces to\n$$\ni\\,\\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\frac{1}{2}\\,\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} \\;+\\; V(x)\\,\\psi(x,t).\n$$\n- Angles in all complex exponentials must be in radians.\n\nDiscretization and numerical design requirements:\n- Spatial domain: a periodic interval of length $ L = 100 $, represented by $ N = 1024 $ uniformly spaced grid points $ x_j \\in [-L/2,\\,L/2) $ with spacing $ \\Delta x = L/N $. The periodic boundary condition is required for the Fourier-based method to be mathematically consistent.\n- The Fourier wavenumbers must be consistent with the discrete Fourier transform pair on the periodic grid, so that the kinetic energy operator is diagonal in Fourier space with dispersion $ \\omega(k) = k^2/2 $. Use a wavenumber grid $ k_n $ that is mathematically consistent with the discrete transform on a domain of length $ L $.\n- Initial condition: a normalized Gaussian wavepacket with mean position $ x_0 = -L/4 $, spatial width $ \\sigma = 1 $, and central wavenumber $ k_0 = 1.5 $,\n$$\n\\psi(x,0) \\;=\\; C\\,\\exp\\!\\Big(-\\frac{(x-x_0)^2}{4\\sigma^2}\\Big)\\,\\exp(i\\,k_0\\,x),\n$$\nwhere $ C $ is chosen so that $ \\int_{-L/2}^{L/2} |\\psi(x,0)|^2\\,dx = 1 $. The normalization must be performed numerically on the discrete grid.\n- Potential barrier: a rectangular barrier centered at $ x=0 $ with height $ V_0 \\ge 0 $ and width $ a \\ge 0 $,\n$$\nV(x) \\;=\\; \\begin{cases}\nV_0, & |x| \\le a/2,\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\n- Time stepping: choose a time step $ \\Delta t = 0.01 $ and a total simulation time $ T = 30 $, giving an integer number of steps $ M = T/\\Delta t $. Use a second-order, time-reversible operator-splitting (split-step) method that alternately applies the potential evolution in position space and the kinetic evolution in Fourier space. The kinetic evolution must be performed using a Cooley–Tukey FFT implementation. Ensure that the discretization is consistent so that norm is preserved to within expected numerical accuracy.\n\nQuantity to compute:\n- Define the transmission probability at the final time $ T $ as the discrete integral of the probability density to the right of the barrier, i.e., for $ x > a/2 $,\n$$\n\\mathcal{T} \\;=\\; \\int_{x > a/2} |\\psi(x,T)|^2\\,dx,\n$$\nimplemented as a Riemann sum over the grid with spacing $ \\Delta x $. Report $ \\mathcal{T} $ rounded to six decimal places.\n\nTest suite:\n- Use the fixed settings above for $ L $, $ N $, $ \\Delta t $, $ T $, $ x_0 $, $ \\sigma $, and $ k_0 $.\n- Evaluate the solver for the following three parameter sets $ (V_0, a) $:\n  1. $ (0.5,\\,5.0) $: barrier height lower than the nominal central kinetic energy of the packet, a \"happy path\" transmission-dominated case.\n  2. $ (1.3,\\,5.0) $: barrier height slightly above the central kinetic energy, a tunneling-dominated case.\n  3. $ (0.0,\\,5.0) $: zero-height barrier, an edge case that should yield near-unity transmission.\n- For each case, compute the corresponding transmission probability $ \\mathcal{T} $ as defined above.\n\nFinal program output format:\n- Your program should produce a single line of output containing the three transmission probabilities, ordered as listed above, each rounded to six decimal places, as a comma-separated list enclosed in square brackets, e.g., \n\"[0.952341,0.007812,0.999998]\".\nNo other output is permitted.\n\nAll physical quantities are dimensionless under the chosen atomic units. All angles are in radians. The final numerical answers must be floats rounded to six decimal places.", "solution": "The problem statement is subjected to rigorous validation.\n\nStep 1: Extract Givens\n- **Governing Equation**: The one-dimensional time-dependent Schrödinger equation in atomic units ($\\hbar=1$, $m=1$):\n$$\ni\\,\\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\frac{1}{2}\\,\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} \\;+\\; V(x)\\,\\psi(x,t)\n$$\n- **Discretization Parameters**:\n  - Spatial domain length: $L = 100$.\n  - Number of grid points: $N = 1024$.\n  - Grid spacing: $\\Delta x = L/N$.\n  - Spatial grid: $x_j \\in [-L/2, L/2)$.\n  - Boundary conditions: Periodic.\n  - Time step: $\\Delta t = 0.01$.\n  - Total simulation time: $T = 30$.\n- **Initial Condition ($t=0$)**:\n  - Wavefunction form: $\\psi(x,0) = C\\,\\exp\\left(-\\frac{(x-x_0)^2}{4\\sigma^2}\\right)\\,\\exp(i\\,k_0\\,x)$.\n  - Mean position: $x_0 = -L/4$.\n  - Spatial width: $\\sigma = 1$.\n  - Central wavenumber: $k_0 = 1.5$.\n  - Normalization: $\\int_{-L/2}^{L/2} |\\psi(x,0)|^2\\,dx = 1$, to be performed numerically on the discrete grid.\n- **Potential Barrier**:\n  - Functional form: A rectangular barrier,\n  $$\n  V(x) \\;=\\; \\begin{cases}\n  V_0, & |x| \\le a/2,\\\\\n  0, & \\text{otherwise}.\n  \\end{cases}\n  $$\n  - Parameters: Height $V_0 \\ge 0$, width $a \\ge 0$.\n- **Numerical Method**:\n  - Second-order, time-reversible split-step Fourier method.\n  - Kinetic evolution performed in Fourier space using the Cooley–Tukey FFT algorithm.\n- **Quantity to Compute**:\n  - Transmission probability at $t=T$: $\\mathcal{T} = \\int_{x>a/2} |\\psi(x,T)|^2\\,dx$, implemented as a discrete sum.\n- **Test Suite**:\n  - Case 1: $(V_0, a) = (0.5, 5.0)$.\n  - Case 2: $(V_0, a) = (1.3, 5.0)$.\n  - Case 3: $(V_0, a) = (0.0, 5.0)$.\n\nStep 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is founded on the Schrödinger equation, a fundamental principle of quantum mechanics. The physical scenario of wavepacket tunneling is a canonical problem. The proposed numerical technique, the split-step Fourier method, is a standard and robust algorithm for solving this class of partial differential equations. The use of atomic units is a common and valid simplification in computational physics. The problem is scientifically sound.\n- **Well-Posed**: All necessary parameters for the simulation ($L$, $N$, $\\Delta t$, $T$) and for defining the initial state and potential are provided. The initial value problem is well-defined. The quantity to be computed ($\\mathcal{T}$) is specified unambiguously.\n- **Objective**: The problem is stated using precise mathematical and physical terminology. There are no subjective or ambiguous statements.\n- **Overall Assessment**: The problem does not violate any of the invalidity criteria. It is a complete, consistent, and well-posed problem in computational physics.\n\nStep 3: Verdict and Action\nThe problem is **valid**. A solution will be derived and implemented.\n\nThe time-dependent Schrödinger equation is given by\n$$\ni\\,\\frac{\\partial \\psi(x,t)}{\\partial t} = \\hat{H}\\psi(x,t)\n$$\nwhere the Hamiltonian operator $\\hat{H}$ is the sum of the kinetic energy operator $\\hat{T}$ and the potential energy operator $\\hat{V}$. In the units provided ($\\hbar=1$, $m=1$), these are:\n$$\n\\hat{T} = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2}, \\quad \\hat{V} = V(x)\n$$\nThe formal solution for the evolution of the wavefunction over a small time step $\\Delta t$ is\n$$\n\\psi(x, t + \\Delta t) = e^{-i\\hat{H}\\Delta t} \\psi(x,t) = e^{-i(\\hat{T} + \\hat{V})\\Delta t} \\psi(x,t)\n$$\nSince the kinetic and potential operators do not commute, $[\\hat{T}, \\hat{V}] \\neq 0$, the exponential of the sum cannot be simply factored. The split-step method provides an approximation for the time-evolution operator. A second-order accurate, symmetric scheme (Strang splitting) is specified:\n$$\ne^{-i(\\hat{T} + \\hat{V})\\Delta t} \\approx e^{-i\\hat{V}\\frac{\\Delta t}{2}} e^{-i\\hat{T}\\Delta t} e^{-i\\hat{V}\\frac{\\Delta t}{2}}\n$$\nThis approximation is accurate to order $\\mathcal{O}(\\Delta t^3)$ for a single step and is unitary, thus preserving the norm of the wavefunction, which is critical for physical consistency. The full time evolution from $t=0$ to $t=T$ is achieved by applying this operation $M = T/\\Delta t$ times.\n\nThe algorithm proceeds by implementing each component of the split operator:\n1.  **Potential Evolution**: The operator $e^{-i\\hat{V}\\frac{\\Delta t}{2}}$ involves the potential $V(x)$, which is a function of position $x$. In the position representation, this operator is diagonal. Its action is a simple multiplication:\n    $$\n    \\psi(x,t) \\rightarrow e^{-iV(x)\\frac{\\Delta t}{2}} \\psi(x,t)\n    $$\n2.  **Kinetic Evolution**: The operator $e^{-i\\hat{T}\\Delta t}$ contains a second derivative, making it non-local and difficult to apply in the position representation. However, the Fourier transform diagonalizes the momentum (and thus kinetic energy) operator. Let $\\tilde{\\psi}(k,t)$ be the Fourier transform of $\\psi(x,t)$:\n    $$\n    \\tilde{\\psi}(k,t) = \\mathcal{F}\\{\\psi(x,t)\\} = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} \\psi(x,t) e^{-ikx} dx\n    $$\n    In Fourier space, the kinetic energy operator becomes a simple multiplication by $\\frac{k^2}{2}$. The kinetic evolution step is therefore:\n    $$\n    \\tilde{\\psi}(k,t) \\rightarrow e^{-i\\frac{k^2}{2}\\Delta t} \\tilde{\\psi}(k,t)\n    $$\n    To implement this, one must:\n    a.  Transform the wavefunction to Fourier space: $\\psi(x) \\rightarrow \\tilde{\\psi}(k) = \\text{FFT}(\\psi(x))$.\n    b.  Apply the kinetic evolution phase factor in Fourier space.\n    c.  Transform back to position space: $\\tilde{\\psi}(k) \\rightarrow \\psi(x) = \\text{IFFT}(\\tilde{\\psi}(k))$.\nThe problem mandates use of the Cooley-Tukey algorithm, which is the standard implementation of the Fast Fourier Transform (FFT) in numerical libraries such as NumPy.\n\nThe numerical implementation requires discretization of all continuous variables.\n- **Spatial Grid**: The domain $[-L/2, L/2)$ is discretized into $N$ points $x_j = -L/2 + j\\Delta x$ for $j=0, \\dots, N-1$, with grid spacing $\\Delta x = L/N$. The wavefunction is represented by a vector of its values at these points, $\\psi_j = \\psi(x_j)$.\n- **Wavenumber Grid**: For consistency with the discrete Fourier transform on a domain of length $L$ with $N$ points, the corresponding wavenumber grid $k_n$ is given by $k_n = 2\\pi f_n$, where $f_n$ are the frequencies provided by standard FFT routines. For a sample spacing of $\\Delta x$, these frequencies are $f_n = n/(N\\Delta x)$ for $n = 0, \\dots, N/2-1$ and $f_n = (n-N)/(N\\Delta x)$ for $n=N/2, \\dots, N-1$. This ordering is handled by the `numpy.fft.fftfreq` function.\n- **Initial Condition**: The initial wavepacket is constructed on the spatial grid $x_j$:\n$$\n\\psi_j(0) = C \\exp\\left(-\\frac{(x_j - x_0)^2}{4\\sigma^2}\\right) \\exp(i k_0 x_j)\n$$\nThe normalization constant $C$ is found by numerically enforcing the condition $\\sum_{j=0}^{N-1} |\\psi_j(0)|^2 \\Delta x = 1$. This gives $C = 1 / \\sqrt{\\sum_{j=0}^{N-1} \\left|\\exp\\left(-\\frac{(x_j - x_0)^2}{4\\sigma^2}\\right) \\exp(i k_0 x_j)\\right|^2 \\Delta x}$.\n- **Potential Barrier**: The rectangular potential $V(x)$ is defined on the spatial grid $x_j$. For a given $V_0$ and $a$, $V_j = V_0$ if $|x_j| \\le a/2$, and $V_j = 0$ otherwise.\n\nThe propagation algorithm is as follows:\n1.  Initialize parameters: $L=100$, $N=1024$, $\\Delta t=0.01$, $T=30$. Calculate $\\Delta x = L/N$ and the number of steps $M = \\text{int}(T/\\Delta t)$.\n2.  Construct the spatial grid $x_j$ and the wavenumber grid $k_n$.\n3.  For each test case $(V_0, a)$:\n    a. Construct the potential array $V_j$.\n    b. Construct the initial wavefunction array $\\psi_j(0)$ and normalize it numerically.\n    c. Pre-compute the evolution operators: $U_V = \\exp(-i V_j \\Delta t/2)$ and $U_T = \\exp(-i k_n^2 \\Delta t/2)$.\n    d. Evolve in a loop for $m$ from $0$ to $M-1$:\n        i.   Apply first half potential step: $\\psi \\leftarrow \\psi \\cdot U_V$.\n        ii.  Transform to k-space: $\\tilde{\\psi} \\leftarrow \\text{FFT}(\\psi)$.\n        iii. Apply kinetic step: $\\tilde{\\psi} \\leftarrow \\tilde{\\psi} \\cdot U_T$.\n        iv.  Transform to x-space: $\\psi \\leftarrow \\text{IFFT}(\\tilde{\\psi})$.\n        v.   Apply second half potential step: $\\psi \\leftarrow \\psi \\cdot U_V$.\n4.  At the final time $T$, the wavefunction is $\\psi_j(T)$.\n5.  Compute the transmission probability $\\mathcal{T}$ by summing the probability density over the grid points to the right of the barrier:\n    $$\n    \\mathcal{T} = \\sum_{j \\text{ where } x_j > a/2} |\\psi_j(T)|^2 \\Delta x\n    $$\nThis procedure is repeated for each of the three given sets of parameters $(V_0, a)$. The central kinetic energy of the packet is $E_k = k_0^2/2 = (1.5)^2/2 = 1.125$. The barrier heights are chosen to be below ($V_0=0.5$), above ($V_0=1.3$), and zero relative to this energy, correctly probing the regimes of classical transmission, quantum tunneling, and free propagation, respectively.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates a numerical solver for 1D quantum tunneling\n    of a Gaussian wavepacket through a rectangular potential barrier using the\n    split-step Fourier method.\n    \"\"\"\n\n    # Discretization and numerical design parameters\n    L = 100.0         # Spatial domain length\n    N = 1024          # Number of grid points\n    dx = L / N        # Spatial grid spacing\n    x = np.arange(-L/2, L/2, dx) # Spatial grid\n\n    # Wavenumber grid consistent with numpy's FFT\n    # k = 2 * pi * f, where f are the frequencies from fftfreq\n    k = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # Initial condition parameters\n    x0 = -L / 4.0     # Mean position\n    sigma = 1.0       # Spatial width\n    k0 = 1.5          # Central wavenumber\n\n    # Time stepping parameters\n    dt = 0.01         # Time step\n    T = 30.0          # Total simulation time\n    num_steps = int(T / dt)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.5, 5.0),  # V0, a: Barrier height < central energy\n        (1.3, 5.0),  # V0, a: Barrier height > central energy (tunneling)\n        (0.0, 5.0),  # V0, a: Zero-height barrier (free propagation)\n    ]\n\n    results = []\n    \n    # Pre-compute the kinetic energy evolution operator (independent of V0, a)\n    # This is U_T = exp(-i * T_op * dt) where T_op = k^2 / 2\n    kinetic_evolution_op = np.exp(-1j * k**2 * dt / 2.0)\n\n    for V0, a in test_cases:\n        # 1. Set up the potential barrier\n        V = np.zeros_like(x)\n        V[np.abs(x) <= a / 2.0] = V0\n        \n        # Pre-compute the potential energy evolution operator for this case\n        # This is U_V = exp(-i * V_op * dt/2)\n        potential_evolution_op = np.exp(-1j * V * dt / 2.0)\n\n        # 2. Set up the initial wavefunction\n        # Un-normalized Gaussian wavepacket\n        psi_0_unnormalized = np.exp(-(x - x0)**2 / (4 * sigma**2)) * np.exp(1j * k0 * x)\n        \n        # Numerically normalize the wavefunction\n        norm_squared = np.sum(np.abs(psi_0_unnormalized)**2) * dx\n        C = 1.0 / np.sqrt(norm_squared)\n        psi = C * psi_0_unnormalized\n        psi = psi.astype(np.complex128)\n\n        # 3. Time evolution using the split-step Fourier method\n        for _ in range(num_steps):\n            # First half potential step\n            psi = psi * potential_evolution_op\n\n            # Full kinetic step in Fourier space\n            psi_k = np.fft.fft(psi)\n            psi_k = psi_k * kinetic_evolution_op\n            psi = np.fft.ifft(psi_k)\n\n            # Second half potential step\n            psi = psi * potential_evolution_op\n        \n        # 4. Compute the transmission probability\n        # Find indices for x > a/2\n        transmission_indices = np.where(x > a / 2.0)\n        \n        # Calculate probability density in the transmission region\n        prob_density_transmitted = np.abs(psi[transmission_indices])**2\n        \n        # Integrate (sum) over the transmission region\n        transmission_probability = np.sum(prob_density_transmitted) * dx\n        \n        results.append(round(transmission_probability, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2383392"}]}