{"hands_on_practices": [{"introduction": "Our journey into the practical side of aliasing begins with a familiar illusion: the wagon-wheel effect. This phenomenon, where a rapidly spinning wheel appears to slow down, stop, or even rotate backward, is a classic example of temporal aliasing. By modeling the wheel's rotation as a continuous phase and the camera's capture as discrete sampling, this exercise [@problem_id:2373299] allows us to predict the perceived motion and understand how our eyes or cameras can be tricked by undersampling.", "problem": "You are asked to model temporal aliasing (the \"wagon-wheel effect\") as a sampling problem of a rotating phase. Consider a rigid wheel with a single distinguishable marker on its rim, rotating at constant rotation frequency $f_{rot}$ in hertz (cycles per second). An ideal camera samples the wheel’s state at uniform intervals with frame rate $f_{fps}$ in hertz, with instantaneous exposures (no motion blur). The angular phase of the marker is $\\phi(t) = 2\\pi f_{rot} t + \\phi_0$, with $\\phi_0 = 0$ without loss of generality. Let the sampling times be $t_n = n/f_{fps}$ for integer $n$. The frame-to-frame phase increment is $\\Delta \\phi = \\phi(t_{n+1}) - \\phi(t_n)$, which is the same for all $n$.\n\nAssume the human perceptual system selects the smallest-magnitude frame-to-frame change that is consistent with the sampled images, i.e., the unique representative $\\Delta \\phi^{*}$ that is congruent to $\\Delta \\phi$ modulo $2\\pi$ and lies in the interval $(-\\pi, \\pi]$. Define the perceived continuous-time rotation frequency (in hertz) as $f_{perc} = \\dfrac{f_{fps}}{2\\pi}\\,|\\Delta \\phi^{*}|$, and the perceived direction as the integer $s \\in \\{-1, 0, +1\\}$ given by $s = \\operatorname{sgn}(\\Delta \\phi^{*})$, with the convention that $s = 0$ when $f_{perc} = 0$ exactly. This convention deterministically resolves the boundary case $\\Delta \\phi \\equiv \\pi \\pmod{2\\pi}$ by taking $\\Delta \\phi^{*} = +\\pi$.\n\nYour task is to write a complete, runnable program that:\n- For each test case below, takes $f_{rot}$ and $f_{fps}$ as inputs (both in hertz).\n- Computes the perceived frequency $f_{perc}$ in hertz and the perceived direction $s$ using only the principles and definitions stated above.\n- Expresses $f_{perc}$ in hertz rounded to $6$ decimal places.\n- Returns, for each test case, a list of the form $[f_{perc}, s]$.\n\nPhysical units: All frequencies must be expressed in hertz (Hz). Angles are handled internally in radians. Directions must be the integers $-1$, $0$, or $+1$. Round $f_{perc}$ to $6$ decimal places.\n\nTest suite of parameter values (happy path, edge, and boundary cases), each given as $(f_{rot}, f_{fps})$ in hertz:\n- Case $1$: $(2.3,\\, 24.0)$\n- Case $2$: $(23.0,\\, 24.0)$\n- Case $3$: $(12.0,\\, 24.0)$\n- Case $4$: $(48.0,\\, 24.0)$\n- Case $5$: $(-1.2,\\, 24.0)$\n- Case $6$: $(103.0,\\, 24.0)$\n- Case $7$: $(0.49,\\, 24.0)$\n- Case $8$: $(31.0,\\, 30.0)$\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element is itself a list $[f_{perc}, s]$ for one test case, where $f_{perc}$ is a float written with exactly $6$ decimal places and $s$ is an integer. For example, the overall structure must look like $[[f_1, s_1],[f_2, s_2],\\ldots]$ with the specified numeric formatting, such as $[[2.300000,1],[1.000000,-1],\\ldots]$. No additional text should be printed.", "solution": "The problem statement has been subjected to a rigorous validation process.\n\nThe givens are:\n- Angular phase of a marker on a rotating wheel: $\\phi(t) = 2\\pi f_{rot} t$, where $f_{rot}$ is the rotation frequency in hertz.\n- Sampling times by a camera with frame rate $f_{fps}$: $t_n = n/f_{fps}$ for integer $n \\ge 0$.\n- Frame-to-frame phase increment: $\\Delta \\phi = \\phi(t_{n+1}) - \\phi(t_n)$.\n- Perceived phase increment, $\\Delta \\phi^{*}$, is the unique representative of $\\Delta \\phi$ congruent modulo $2\\pi$ such that $\\Delta \\phi^{*} \\in (-\\pi, \\pi]$.\n- Perceived frequency: $f_{perc} = \\dfrac{f_{fps}}{2\\pi}\\,|\\Delta \\phi^{*}|$.\n- Perceived direction: $s = \\operatorname{sgn}(\\Delta \\phi^{*})$, with $s=0$ if $\\Delta \\phi^{*} = 0$.\n\nThe validation confirms that the problem is scientifically grounded, well-posed, and objective. It provides a clear, formal model of the temporal aliasing phenomenon, based on fundamental principles of signal sampling theory. All terms are unambiguously defined, and the required computations are mathematically sound and lead to a unique solution. The problem is therefore deemed valid, and a solution is derived as follows.\n\nThe analysis begins by deriving the frame-to-frame phase increment, $\\Delta \\phi$. Substituting the expressions for the phase $\\phi(t)$ and the sampling times $t_n$ into the definition of $\\Delta \\phi$:\n$$\n\\Delta \\phi = \\phi(t_{n+1}) - \\phi(t_n) = 2\\pi f_{rot} \\left(\\frac{n+1}{f_{fps}}\\right) - 2\\pi f_{rot} \\left(\\frac{n}{f_{fps}}\\right)\n$$\nSimplifying the expression yields a constant phase increment:\n$$\n\\Delta \\phi = 2\\pi f_{rot} \\left(\\frac{n+1-n}{f_{fps}}\\right) = 2\\pi \\frac{f_{rot}}{f_{fps}}\n$$\nThe core of the problem lies in the perceptual model, which maps the true phase increment $\\Delta \\phi$ to its perceived counterpart $\\Delta \\phi^{*}$. This is a mathematical wrapping operation. We must find an integer $k$ representing the number of full $2\\pi$ rotations that are perceptually discarded, such that:\n$$\n\\Delta \\phi^{*} = \\Delta \\phi - 2\\pi k\n$$\nand $\\Delta \\phi^{*}$ falls within the specified principal interval $(-\\pi, \\pi]$.\n\nTo systematically find $k$, we can work with normalized frequencies and phases. Let $x$ be the ratio of the rotation frequency to the sampling frequency:\n$$\nx = \\frac{f_{rot}}{f_{fps}}\n$$\nThe normalized phase increment is $\\frac{\\Delta \\phi}{2\\pi} = x$. We seek a normalized perceived phase increment $p = \\frac{\\Delta \\phi^{*}}{2\\pi}$ such that $p = x - k$ for some integer $k$ and $p \\in (-0.5, 0.5]$.\nThis inequality for $p$ can be rewritten in terms of $x$ and $k$:\n$$\n-0.5  x - k \\le 0.5\n$$\nRearranging for $k$ gives the condition:\n$$\nx - 0.5 \\le k  x + 0.5\n$$\nThe unique integer $k$ satisfying this condition for any real number $x$ is given by the ceiling function:\n$$\nk = \\lceil x - 0.5 \\rceil\n$$\nWith $k$ determined, the normalized perceived phase increment $p$ is calculated as $p = x - k$.\n\nThe perceived frequency $f_{perc}$ is defined as $f_{perc} = \\frac{f_{fps}}{2\\pi} |\\Delta \\phi^{*}|$. Substituting $\\Delta \\phi^{*} = 2\\pi p$:\n$$\nf_{perc} = \\frac{f_{fps}}{2\\pi} |2\\pi p| = f_{fps} |p| = f_{fps} \\left| \\frac{f_{rot}}{f_{fps}} - k \\right|\n$$\nThe perceived direction $s$ is the sign of the perceived phase increment:\n$$\ns = \\operatorname{sgn}(\\Delta \\phi^{*}) = \\operatorname{sgn}(2\\pi p) = \\operatorname{sgn}(p)\n$$\nBy convention, $\\operatorname{sgn}(0) = 0$, which correctly handles the case of a stationary perceived image ($f_{perc} = 0$).\n\nThe complete computational algorithm for a given pair $(f_{rot}, f_{fps})$ is as follows:\n$1$. Calculate the frequency ratio $x = f_{rot} / f_{fps}$.\n$2$. Determine the integer number of full rotations to subtract, $k = \\lceil x - 0.5 \\rceil$.\n$3$. Compute the normalized perceived phase increment $p = x - k$.\n$4$. Calculate the perceived frequency $f_{perc} = f_{fps} |p|$.\n$5$. Determine the perceived direction $s = \\operatorname{sgn}(p)$.\n$6$. Round $f_{perc}$ to $6$ decimal places and return the pair $[f_{perc}, s]$.\nThis algorithm is now implemented to solve for the provided test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the perceived frequency and direction of a rotating object\n    subject to temporal aliasing, based on the wagon-wheel effect model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (f_rot, f_fps) in hertz.\n    test_cases = [\n        (2.3, 24.0),     # Case 1\n        (23.0, 24.0),    # Case 2\n        (12.0, 24.0),    # Case 3\n        (48.0, 24.0),    # Case 4\n        (-1.2, 24.0),    # Case 5\n        (103.0, 24.0),   # Case 6\n        (0.49, 24.0),    # Case 7\n        (31.0, 30.0),    # Case 8\n    ]\n\n    # A list to store the string-formatted results for each case.\n    results_str_list = []\n\n    for case in test_cases:\n        f_rot, f_fps = case\n\n        # Step 1: Calculate the frequency ratio x.\n        # This represents the number of rotations per sample period.\n        x = f_rot / f_fps\n\n        # Step 2: Determine the integer number of full rotations k to subtract.\n        # The logic k = ceil(x - 0.5) ensures that the remainder p = x - k\n        # falls into the interval (-0.5, 0.5], which corresponds to a\n        # phase increment in (-pi, pi].\n        k = np.ceil(x - 0.5)\n\n        # Step 3: Compute the normalized perceived phase increment p.\n        p = x - k\n\n        # Step 4: Calculate the perceived frequency f_perc.\n        # This is the magnitude of the perceived rotation rate.\n        f_perc = f_fps * np.abs(p)\n\n        # Step 5: Determine the perceived direction s.\n        # This is the sign of the perceived phase increment.\n        # np.sign(0) correctly returns 0.\n        s = int(np.sign(p))\n\n        # Step 6: Format the result for the current case as a string '[f_perc,s]'\n        # f_perc is formatted to exactly 6 decimal places.\n        case_result_str = f\"[{f_perc:.6f},{s}]\"\n        results_str_list.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    # The final output is a single line: a list of lists.\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```", "id": "2373299"}, {"introduction": "Aliasing isn't just about visual illusions; it has profound implications for data analysis across all scientific disciplines. This problem [@problem_id:2373235] presents a hypothetical public health scenario where a disease with a known cyclical nature is monitored with insufficient frequency. By calculating the apparent cycle time from the undersampled data, we can directly see how the Nyquist criterion is not merely a theoretical boundary, but a critical rule for ensuring the integrity of scientific conclusions drawn from time-series measurements.", "problem": "A public-health monitoring program records the incidence of a seasonal infectious disease whose continuous-time fluctuations are known to be well-approximated by a single sinusoid of the form $x(t)=A\\cos\\!\\big(2\\pi t/T_{0}+\\varphi\\big)$, where $A$ and $\\varphi$ are constants and the true cycle time is $T_0=5$ days. Due to resource constraints, data are collected only at equally spaced times $t_{n}=nT_{s}$ with $T_s=7$ days (i.e., weekly), yielding the discrete sequence $y[n]=x(nT_{s})$.\n\nAssuming ideal, noise-free measurements for $n\\in\\mathbb{Z}$ and no prior knowledge of aliasing, a downstream analyst attempts to infer a single cycle time by fitting a sinusoid to $y[n]$ against the actual observation times $t_{n}$. Under these conditions, what incorrect cycle time (i.e., the apparent period implied by the aliased data) will be inferred from the sampled sequence?\n\nExpress your final answer in days as an exact value; do not round.", "solution": "The continuous-time signal is $x(t)=A\\cos\\!\\big(2\\pi f_{0}t+\\varphi\\big)$, where the true frequency is $f_{0}=1/T_{0}$. With $T_0=5$ days, the true frequency is\n$$\nf_{0}=\\frac{1}{5}\\ \\text{day}^{-1}.\n$$\nSampling at interval $T_s=7$ days corresponds to a sampling frequency\n$$\nf_{s}=\\frac{1}{T_{s}}=\\frac{1}{7}\\ \\text{day}^{-1}.\n$$\nThe sampled sequence is\n$$\ny[n]=x(nT_{s})=A\\cos\\!\\big(2\\pi f_{0}nT_{s}+\\varphi\\big)=A\\cos\\!\\Big(2\\pi \\frac{f_{0}}{f_{s}}\\,n+\\varphi\\Big).\n$$\nBecause the cosine function is $2\\pi$-periodic in its argument, the discrete-time sinusoid with normalized frequency $2\\pi(f_{0}/f_{s})$ is indistinguishable from one with normalized frequency $2\\pi\\big(f_{0}/f_{s}-k\\big)$ for any integer $k$. Consequently, in continuous-time units, the set of frequencies that produce the same samples is $\\{\\,|f_{0}-k f_{s}|:k\\in\\mathbb{Z}\\,\\}$. The apparent (aliased) frequency $f_{a}$ inferred by an analyst who interprets the samples as coming from a low-frequency sinusoid is obtained by choosing the integer $k$ that brings $|f_{0}-k f_{s}|$ into the baseband interval $[0,\\,f_{s}/2]$:\n$$\nf_{a}=\\min_{k\\in\\mathbb{Z}}|f_{0}-k f_{s}|.\n$$\nWith $f_{0}=\\frac{1}{5}$ and $f_{s}=\\frac{1}{7}$ (both in day$^{-1}$), consider $k=1$:\n$$\n|f_{0}-f_{s}|=\\left|\\frac{1}{5}-\\frac{1}{7}\\right|=\\left|\\frac{7-5}{35}\\right|=\\frac{2}{35}\\ \\text{day}^{-1}.\n$$\nThis value lies within $[0,\\,f_{s}/2]=\\left[0,\\,\\frac{1}{14}\\right]$, since $\\frac{2}{35}\\frac{1}{14}$. Therefore the apparent frequency is\n$$\nf_{a}=\\frac{2}{35}\\ \\text{day}^{-1}.\n$$\nThe corresponding apparent cycle time (period) is\n$$\nT_{a}=\\frac{1}{f_{a}}=\\frac{1}{\\frac{2}{35}}=\\frac{35}{2}\\ \\text{days}.\n$$\nThus, the aliased data will suggest an incorrect cycle time of $\\frac{35}{2}$ days.", "answer": "$$\\boxed{\\frac{35}{2}}$$", "id": "2373235"}, {"introduction": "Having explored temporal aliasing, we now extend our understanding to the spatial domain, where aliasing manifests as Moiré patterns. These interference patterns are common when viewing a fine pattern through another, or when a digital image of a detailed texture is resized or displayed at a different resolution. This practice [@problem_id:2373273] guides you through simulating this effect by downsampling a synthetic 'fabric' image and using the two-dimensional Fast Fourier Transform (FFT) to verify the theoretical predictions of spatial aliasing, a crucial concept in image processing and scientific visualization.", "problem": "You will write a complete and runnable program that demonstrates and quantifies aliasing and the Nyquist criterion in two spatial dimensions using synthetic images. You must start from core definitions: sampling of a continuous field by a spatial lattice, the Discrete Fourier Transform (DFT) as a projection onto complex exponentials on that lattice, and the well-established observation that sampling replicates spectra in frequency space. You must not assume any pre-derived aliasing shortcuts in the problem statement; instead, infer how the aliased spatial frequency observed after decimation arises from these bases.\n\nConstruct a synthetic two-dimensional cosine “fabric” pattern of the form\n$$\nI(x,y) = \\cos\\!\\big( 2\\pi \\big( f_x x + f_y y \\big) \\big),\n$$\nwhere $x$ and $y$ are integers indexing the high-resolution pixel grid, and $(f_x,f_y)$ is the spatial frequency vector expressed in cycles per pixel with respect to this high-resolution grid. Use a square image of side length $M$ pixels, with $M = 1024$. Assume the continuous underlying field is already band-limited so that its sampling on this high-resolution grid is valid for the given $(f_x,f_y)$.\n\nYou will then downsample (decimate) the image by an integer factor $N$ by keeping every $N$-th sample along both axes. This corresponds to a new sampling lattice with spacing enlarged by a factor $N$ in both directions. Let the downsampled image dimensions be those implied by Python slicing with step $N$.\n\nFrom first principles, use the definitions above to reason how a sinusoid at spatial frequency $(f_x,f_y)$ on the high-resolution grid will appear after decimation by $N$ when expressed in the units of the downsampled grid (cycles per downsampled pixel). In particular, show how the observed frequency must be folded into the baseband supported by the lower sampling rate, consistent with the Nyquist criterion that demands each component lie within the interval of width one cycle per sample centered at zero. Your implementation must:\n- Construct the high-resolution image $I(x,y)$ for each test case.\n- Downsample it by keeping every $N$-th pixel in both $x$ and $y$.\n- Estimate the dominant spatial frequency magnitude (in cycles per downsampled pixel) of the downsampled image by:\n  - Computing the two-dimensional DFT (via a Fast Fourier Transform).\n  - Locating the nonzero spectral peak of largest magnitude.\n  - Converting its indices to physical frequencies using the standard DFT frequency grid.\n- Independently compute the theoretically predicted aliased spatial frequency magnitude in cycles per downsampled pixel by folding the scaled frequency vector implied by decimation into the Nyquist interval supported by the downsampled grid.\n- For each test case, compute the absolute difference between the estimated and the theoretically predicted magnitudes as a single floating-point number.\n\nExpress all spatial frequencies in cycles per pixel, and do not use any physical units. Angles, if any, must be interpreted in radians, but you are not required to use or report any angles in this problem. All numeric answers must be reported as Python floats without any percentage sign.\n\nTest Suite:\nUse $M = 1024$ and the following set of $7$ test cases, each specified as $(N,f_x,f_y)$ with all frequencies in cycles per high-resolution pixel:\n- Case $1$: $(N,f_x,f_y) = (\\,3,\\,0.12,\\,0.00\\,)$\n- Case $2$: $(N,f_x,f_y) = (\\,4,\\,0.125,\\,0.00\\,)$\n- Case $3$: $(N,f_x,f_y) = (\\,5,\\,0.11,\\,0.00\\,)$\n- Case $4$: $(N,f_x,f_y) = (\\,3,\\,0.14,\\,0.10\\,)$\n- Case $5$: $(N,f_x,f_y) = (\\,4,\\,0.249,\\,0.001\\,)$\n- Case $6$: $(N,f_x,f_y) = (\\,7,\\,0.09,\\,0.085\\,)$\n- Case $7$: $(N,f_x,f_y) = (\\,6,\\,0.00,\\,0.09\\,)$\n\nRequired final output format:\n- Your program must produce a single line of output containing a Python-style list of $7$ floats, each being the absolute error (estimated magnitude minus theoretical magnitude, absolute value) for the corresponding test case, in the same order as above. For example: \n$[e_1,e_2,\\dots,e_7]$ \nwhere each $e_i$ is a float.\n\nThe program must run as is with no inputs and no external files or network access, and it must use only standard libraries plus the specified numerical libraries. All computations must be carried out in the units specified above (cycles per pixel). The final line printed by the program must be exactly the result list and nothing else.", "solution": "The problem statement is valid. It is scientifically grounded, well-posed, objective, and contains all necessary information for a unique and meaningful solution. It describes a standard, verifiable procedure in computational physics for demonstrating the phenomenon of aliasing. I will proceed with a solution derived from first principles.\n\nThe analysis begins with the provided high-resolution synthetic image, defined on a discrete grid of integer coordinates $(x,y)$ where $x, y \\in \\{0, 1, \\dots, M-1\\}$ and $M=1024$. The intensity function is given by\n$$\nI(x,y) = \\cos\\!\\big( 2\\pi \\big( f_x x + f_y y \\big) \\big)\n$$\nHere, $(f_x, f_y)$ represents the spatial frequency vector in units of cycles per high-resolution pixel. This formulation implies that the underlying continuous field has been sampled at a rate corresponding to a unit pixel spacing in both dimensions. The Nyquist frequency for this high-resolution grid is $0.5$ cycles per pixel. The problem stipulates that the given frequencies $(f_x, f_y)$ are within the non-aliased range for this initial grid.\n\nThe core of the problem lies in the decimation process, where the high-resolution image $I(x,y)$ is downsampled by an integer factor $N$. A new, coarser grid is constructed with integer coordinates $(x',y')$. The relationship between the coordinate systems is $x = N x'$ and $y = N y'$. The downsampled image, $I_D(x',y')$, is formed by taking samples from $I(x,y)$ at these new grid points:\n$$\nI_D(x', y') = I(N x', N y') = \\cos\\!\\big( 2\\pi \\big( f_x (N x') + f_y (N y') \\big) \\big)\n$$\nThis expression can be regrouped to reveal the new effective spatial frequency on the downsampled grid:\n$$\nI_D(x', y') = \\cos\\!\\big( 2\\pi \\big( (N f_x) x' + (N f_y) y' \\big) \\big)\n$$\nLet the new frequency vector, expressed in cycles per downsampled pixel, be $(f'_x, f'_y)$. From the equation above, we have:\n$$\nf'_x = N f_x \\quad \\text{and} \\quad f'_y = N f_y\n$$\nThis vector $(f'_x, f'_y)$ represents the true frequency of the sinusoidal pattern on the new grid. However, this is not necessarily the frequency that will be observed. The discrete nature of the grid imposes fundamental limits on the range of frequencies that can be uniquely represented.\n\nAccording to the theory of discrete sampling, the spectrum of a sampled signal is periodic. The sampling process creates infinite replicas of the continuous signal's spectrum, shifted by integer multiples of the sampling frequency. In our normalized units, the sampling frequency is $1$ cycle per pixel in each dimension. Consequently, a frequency component $f'$ is indistinguishable from $f' + k$ for any integer $k$. An observer of the discrete signal can only perceive the frequency component that falls within a defined principal range, typically the baseband of width $1$ centered at zero. This phenomenon is aliasing. The Nyquist criterion specifies that for a signal to be sampled without aliasing, its frequency components must lie strictly within this baseband.\n\nThe principal alias, or the observed frequency component, is found by \"folding\" the true frequency into the Nyquist interval $[-0.5, 0.5)$. For any given frequency $f'$, the observed aliased frequency $f'_a$ is the unique value in this interval such that $f' - f'_a$ is an integer. This can be computed by subtracting the nearest integer to $f'$. A robust formula to perform this mapping is:\n$$\nf'_a = (f' + 0.5) \\pmod 1 - 0.5\n$$\nwhere the modulo operation is understood to produce a result in $[0, 1)$. Applying this to our two-dimensional frequency vector $(f'_x, f'_y)$, we obtain the theoretically predicted aliased frequency vector $(f'_{x,a}, f'_{y,a})$:\n$$\nf'_{x,a} = ((N f_x) + 0.5) \\pmod 1 - 0.5\n$$\n$$\nf'_{y,a} = ((N f_y) + 0.5) \\pmod 1 - 0.5\n$$\nThe magnitude of this theoretically predicted aliased frequency is therefore:\n$$\n|f'_a|_{theory} = \\sqrt{(f'_{x,a})^2 + (f'_{y,a})^2}\n$$\n\nTo verify this theoretical prediction, we must estimate the frequency from the downsampled image $I_D$ numerically. This is achieved using the two-dimensional Discrete Fourier Transform (DFT), implemented via the Fast Fourier Transform (FFT) algorithm. The DFT projects the image onto a basis of complex exponential functions, revealing its spectral content. For an image of size $M_{Dy} \\times M_{Dx}$, the DFT yields a complex-valued matrix where each element $(k_y, k_x)$ corresponds to a discrete frequency $(k_y/M_{Dy}, k_x/M_{Dx})$.\n\nSince the input image $I_D(x',y')$ is a pure cosine wave, its DFT will ideally consist of two impulses (delta functions) at the positive and negative aliased frequencies, $(\\pm f'_{x,a}, \\pm f'_{y,a})$. On a finite grid, these impulses are broadened into narrow peaks due to spectral leakage, but their maximum magnitude will be centered at or near the true frequency.\n\nThe numerical estimation procedure is as follows:\n1.  Compute the 2D FFT of the downsampled image $I_D$: $F_D = \\text{FFT2}(I_D)$.\n2.  Shift the zero-frequency component to the center of the spectrum for easier interpretation: $F_{D, \\text{shifted}} = \\text{fftshift}(F_D)$.\n3.  Calculate the magnitude of the complex spectrum: $|F_{D, \\text{shifted}}|$.\n4.  The problem asks for the dominant non-zero frequency. Therefore, we disregard the peak at zero frequency (the DC component) by setting its magnitude to zero.\n5.  Locate the indices $(k_{y, \\text{peak}}, k_{x, \\text{peak}})$ corresponding to the maximum remaining magnitude in the shifted spectrum.\n6.  Convert these integer indices into physical frequencies using the standard DFT frequency grid, which is also shifted to be centered at zero. The estimated frequencies are $(f_{x, \\text{est}}, f_{y, \\text{est}})$.\n7.  The estimated frequency magnitude is then $|f'|_{est} = \\sqrt{(f_{x, \\text{est}})^2 + (f_{y, \\text{est}})^2}$.\n\nFinally, for each test case, we compute the absolute error $\\epsilon = \\big| |f'|_{est} - |f'_a|_{theory} \\big|$. This error quantifies the difference between the experimental measurement from the FFT and the theoretical prediction, which should be close to zero, limited only by the finite precision of floating-point arithmetic and the discrete nature of the DFT frequency grid.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the aliasing problem by comparing theoretical predictions with\n    numerical estimates from FFT analysis.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, f_x, f_y)\n    test_cases = [\n        (3, 0.12, 0.00),\n        (4, 0.125, 0.00),\n        (5, 0.11, 0.00),\n        (3, 0.14, 0.10),\n        (4, 0.249, 0.001),\n        (7, 0.09, 0.085),\n        (6, 0.00, 0.09),\n    ]\n\n    results = []\n    M = 1024  # High-resolution image side length\n\n    for N, fx, fy in test_cases:\n        # --- Theoretical Calculation ---\n        # 1. Scale original frequencies by the decimation factor N.\n        # These are the frequencies in units of cycles/downsampled_pixel.\n        f_prime_x = N * fx\n        f_prime_y = N * fy\n\n        # 2. Fold the frequencies into the Nyquist interval [-0.5, 0.5).\n        # This gives the expected aliased frequencies.\n        # The formula (f + 0.5) % 1.0 - 0.5 correctly maps f to [-0.5, 0.5).\n        f_alias_x = (f_prime_x + 0.5) % 1.0 - 0.5\n        f_alias_y = (f_prime_y + 0.5) % 1.0 - 0.5\n        \n        # 3. Calculate the magnitude of the theoretical aliased frequency vector.\n        mag_theory = np.sqrt(f_alias_x**2 + f_alias_y**2)\n\n        # --- Numerical Estimation ---\n        # 1. Create the high-resolution image.\n        x = np.arange(M)\n        y = np.arange(M)\n        xx, yy = np.meshgrid(x, y)\n        I_high_res = np.cos(2 * np.pi * (fx * xx + fy * yy))\n\n        # 2. Downsample the image by decimation factor N.\n        I_downsampled = I_high_res[::N, ::N]\n        M_dy, M_dx = I_downsampled.shape\n\n        # 3. Compute the 2D FFT of the downsampled image.\n        F_downsampled = np.fft.fft2(I_downsampled)\n\n        # 4. Shift the zero-frequency component to the center and get magnitudes.\n        F_shifted = np.fft.fftshift(F_downsampled)\n        abs_F_shifted = np.abs(F_shifted)\n\n        # 5. Locate the peak frequency, ignoring the DC component at the center.\n        # Find center indices for the shifted spectrum.\n        center_y, center_x = M_dy // 2, M_dx // 2\n        \n        # Set the DC component magnitude to zero to exclude it from the search.\n        abs_F_shifted[center_y, center_x] = 0.0\n\n        # Find the indices of the largest non-zero magnitude peak.\n        ky_idx, kx_idx = np.unravel_index(np.argmax(abs_F_shifted), abs_F_shifted.shape)\n\n        # 6. Convert peak indices to physical frequencies (cycles/downsampled_pixel).\n        # Generate the frequency grids corresponding to the shifted FFT output.\n        freq_x_axis = np.fft.fftshift(np.fft.fftfreq(M_dx))\n        freq_y_axis = np.fft.fftshift(np.fft.fftfreq(M_dy))\n\n        f_est_x = freq_x_axis[kx_idx]\n        f_est_y = freq_y_axis[ky_idx]\n\n        # 7. Calculate the magnitude of the estimated frequency vector.\n        mag_est = np.sqrt(f_est_x**2 + f_est_y**2)\n\n        # --- Final Calculation ---\n        # Compute the absolute error between theoretical and estimated magnitudes.\n        error = np.abs(mag_est - mag_theory)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2373273"}]}