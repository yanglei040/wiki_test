{"hands_on_practices": [{"introduction": "The convolution theorem is a cornerstone of computational signal processing, offering a dramatic speed-up for convolution operations. This practice provides a foundational verification of the theorem by contrasting a direct, time-domain convolution with the far more efficient frequency-domain approach powered by the Fast Fourier Transform (FFT). By implementing both methods and comparing their outputs, you will gain a concrete understanding of why the FFT-based method is not just an approximation but a numerically precise equivalent, and appreciate the practical difference between an $\\mathcal{O}(N^2)$ and an $\\mathcal{O}(N \\log N)$ algorithm [@problem_id:2383312].", "problem": "You are asked to verify the convolution theorem numerically by comparing a direct time-domain linear convolution with a frequency-domain method that uses a radix-$2$ Cooley–Tukey Fast Fourier Transform (FFT). Work entirely in discrete time with sequences indexed by nonnegative integers. All quantities are dimensionless. Angles inside complex exponentials must be measured in radians.\n\nBegin from the following fundamental base:\n- The discrete-time linear convolution of two finite-length sequences $\\{x[n]\\}_{n=0}^{n_x-1}$ and $\\{h[n]\\}_{n=0}^{n_h-1}$ is defined by $y[n] = \\sum_{m=-\\infty}^{\\infty} x[m] h[n-m]$, where $x[m] = 0$ for $m \\notin \\{0,\\dots,n_x-1\\}$ and $h[m] = 0$ for $m \\notin \\{0,\\dots,n_h-1\\}$. The linear convolution length is $n_y = n_x + n_h - 1$.\n- The length-$L$ Discrete Fourier Transform (DFT) of $\\{x[n]\\}_{n=0}^{L-1}$ is $X[k] = \\sum_{n=0}^{L-1} x[n] \\exp\\!\\left(-2\\pi i \\frac{kn}{L}\\right)$ for $k \\in \\{0,\\dots,L-1\\}$, and its inverse is $x[n] = \\frac{1}{L}\\sum_{k=0}^{L-1} X[k] \\exp\\!\\left(2\\pi i \\frac{kn}{L}\\right)$ for $n \\in \\{0,\\dots,L-1\\}$. Angles are in radians.\n\nTask:\n- Implement a radix-$2$ Cooley–Tukey Fast Fourier Transform (FFT) and its inverse to compute the DFT and inverse DFT. Your implementation must require input lengths to be powers of $2$ and must use the divide-and-conquer decomposition into even and odd indices with the twiddle factors $\\exp\\!\\left(-2\\pi i \\frac{k}{N}\\right)$.\n- Implement the direct linear convolution using its definition, with explicit summation that runs in $\\mathcal{O}(n_x n_h)$ time.\n- Implement the FFT-based linear convolution as follows: given $\\{x[n]\\}$ and $\\{h[n]\\}$, choose $L$ to be the smallest power of $2$ that is at least $n_x + n_h - 1$, zero-pad both sequences to length $L$, compute their DFTs via your radix-$2$ Cooley–Tukey FFT, multiply pointwise in the frequency domain, and apply your inverse FFT. Return the first $n_x + n_h - 1$ samples to obtain the linear convolution result.\n- For the numerical comparison, generate signals using a fixed random seed so that results are reproducible. For each test below, compute the maximum absolute difference between the direct linear convolution and the FFT-based linear convolution:\n  $$\\varepsilon = \\max_{0 \\le n \\le n_x+n_h-2} \\left|y_{\\text{direct}}[n] - y_{\\text{FFT}}[n]\\right|.$$\n  Report $\\varepsilon$ rounded to $10$ decimal places.\n\nAngle unit requirement:\n- All complex exponentials must use radians.\n\nTest suite:\n- Use a single random number generator with seed $2025$. For each case, draw each independent real component from the standard normal distribution with mean $0$ and variance $1$.\n  1. General real case: $n_x = 64$, $n_h = 47$, $x[n]$ and $h[n]$ real-valued.\n  2. General complex case: $n_x = 32$, $n_h = 16$, $x[n]$ and $h[n]$ complex-valued with independent real and imaginary parts drawn as above.\n  3. Tiny case: $n_x = 1$, $n_h = 1$, $x[n]$ and $h[n]$ real-valued.\n  4. Prime-length edge case: $n_x = 7$, $n_h = 11$, $x[n]$ and $h[n]$ real-valued.\n\nAnswer specification:\n- For each test case, compute $\\varepsilon$ as defined above. The expected outcome is that each $\\varepsilon$ is a small nonnegative real number due to numerical round-off, typically on the order of $10^{-12}$ or smaller. There is no physical unit.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $1$ through $4$, where each entry is the float $\\varepsilon$ rounded to $10$ decimal places. For example, a valid output format is like [e1,e2,e3,e4] with each e printed as a decimal number with exactly $10$ digits after the decimal point (no percentage signs).\n\nYour final deliverable must be a complete, runnable program that performs all computations and prints only the required single-line output in the specified format.", "solution": "The problem statement is scrutinized and found to be valid. It is scientifically grounded in the principles of Fourier analysis, specifically the convolution theorem. The problem is well-posed, with all necessary definitions, parameters, and constraints for performing a numerical verification. The instructions are objective and explicit, allowing for a unique and reproducible solution. We may therefore proceed with the derivation and implementation.\n\nThe objective is to verify the discrete convolution theorem by implementing and comparing two methods for computing the linear convolution of two finite discrete-time sequences, $\\{x[n]\\}_{n=0}^{n_x-1}$ and $\\{h[n]\\}_{n=0}^{n_h-1}$.\n\nThe first method is direct computation. The linear convolution, denoted by $\\{y[n]\\} = \\{x[n]\\} * \\{h[n]\\}$, is defined as:\n$$\ny[n] = \\sum_{m=-\\infty}^{\\infty} x[m] h[n-m]\n$$\nGiven that $x[m]$ is non-zero only for $m \\in \\{0, \\dots, n_x-1\\}$ and $h[k]$ is non-zero only for $k \\in \\{0, \\dots, n_h-1\\}$, the sum is non-zero only over a finite range of $m$. The resulting sequence $y[n]$ has a length of $n_y = n_x + n_h - 1$. A direct implementation involves nested loops iterating through indices $n$ and $m$, leading to a computational complexity of $\\mathcal{O}(n_x n_h)$.\n\nThe second method leverages the convolution theorem, which states that convolution in the time domain is equivalent to pointwise multiplication in the frequency domain. For discrete sequences, this theorem applies to circular convolution:\n$$\n\\text{DFT}\\{x \\circledast_L y\\} = \\text{DFT}\\{x\\} \\cdot \\text{DFT}\\{y\\}\n$$\nwhere $\\circledast_L$ denotes circular convolution of length $L$, and the DFTs are also of length $L$. To compute linear convolution using this property, we must prevent the wrap-around effect (time-domain aliasing) inherent in circular convolution. This is achieved by zero-padding both sequences, $x[n]$ and $h[n]$, to a length $L$ such that $L \\ge n_x + n_h - 1$. The product of their $L$-point DFTs is then computed, and an $L$-point inverse DFT is applied to return to the time domain. The resulting $L$-point sequence's first $n_x + n_h - 1$ samples are identical to the linear convolution result.\n\nThe Discrete Fourier Transform (DFT) of a length-$N$ sequence $\\{x[n]\\}$ is:\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-2\\pi i \\frac{kn}{N}\\right), \\quad k \\in \\{0, \\dots, N-1\\}\n$$\nA direct computation of the DFT has a complexity of $\\mathcal{O}(N^2)$. The problem mandates the use of the more efficient radix-2 Cooley–Tukey Fast Fourier Transform (FFT) algorithm, which has a complexity of $\\mathcal{O}(N \\log N)$, but requires the sequence length $N$ to be a power of $2$.\n\nThe Cooley-Tukey algorithm is a divide-and-conquer algorithm. For a sequence $x[n]$ of length $N = 2^p$, we split the DFT sum into even and odd-indexed terms:\n$$\nX[k] = \\sum_{m=0}^{N/2-1} x[2m] e^{-2\\pi i \\frac{k(2m)}{N}} + \\sum_{m=0}^{N/2-1} x[2m+1] e^{-2\\pi i \\frac{k(2m+1)}{N}}\n$$\nLet $x_e[m] = x[2m]$ and $x_o[m] = x[2m+1]$ be the even and odd sub-sequences, each of length $N/2$. The expression becomes:\n$$\nX[k] = \\sum_{m=0}^{N/2-1} x_e[m] e^{-2\\pi i \\frac{km}{N/2}} + e^{-2\\pi i \\frac{k}{N}} \\sum_{m=0}^{N/2-1} x_o[m] e^{-2\\pi i \\frac{km}{N/2}}\n$$\nThis reveals that the $N$-point DFT can be constructed from two $(N/2)$-point DFTs. Let $X_e[k]$ and $X_o[k]$ be the $(N/2)$-point DFTs of $x_e$ and $x_o$, respectively. Let $W_N^k = \\exp(-2\\pi i \\frac{k}{N})$ be the \"twiddle factor\". Then for $k \\in \\{0, \\dots, N/2 - 1\\}$:\n$$\nX[k] = X_e[k] + W_N^k X_o[k]\n$$\nUsing the periodicity of the DFT ($X_e[k] = X_e[k+N/2]$) and properties of the twiddle factor ($W_N^{k+N/2} = -W_N^k$), we find for the upper half of the transform:\n$$\nX[k + N/2] = X_e[k] - W_N^k X_o[k]\n$$\nThis decomposition is applied recursively until we reach a base case of length $N=1$, where the DFT is the identity operation: $\\text{DFT}\\{x[0]\\} = x[0]$.\n\nFor the FFT-based convolution, we must choose the transform length $L$ to be the smallest power of $2$ such that $L \\ge n_x + n_h - 1$. After padding $x[n]$ and $h[n]$ to this length $L$, we compute their FFTs, multiply the results, and then perform an inverse FFT (IFFT). The IFFT can be computed using the FFT algorithm via the identity:\n$$\n\\text{IFFT}\\{X[k]\\} = \\frac{1}{N} \\overline{\\text{FFT}\\{\\overline{X[k]}\\}}\n$$\nwhere $\\overline{z}$ denotes the complex conjugate of $z$.\n\nThe final step is to compare the result of the direct convolution, $y_{\\text{direct}}[n]$, with the result from the FFT-based method, $y_{\\text{FFT}}[n]$, by calculating the maximum absolute difference:\n$$\n\\varepsilon = \\max_{0 \\le n < n_x+n_h-1} \\left|y_{\\text{direct}}[n] - y_{\\text{FFT}}[n]\\right|\n$$\nThis error $\\varepsilon$ should be a small number, close to machine precision, confirming the numerical equivalence of the two methods, thereby verifying the convolution theorem in a practical computational setting.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef cooley_tukey_fft(x: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the radix-2 Cooley-Tukey FFT algorithm recursively.\n    Input length must be a power of 2.\n    \"\"\"\n    N = len(x)\n    if N == 0:\n        return np.array([], dtype=np.complex128)\n    \n    # Validate that N is a power of 2\n    if (N & (N - 1)) != 0:\n        raise ValueError(\"FFT input length must be a power of 2.\")\n\n    # Base case for recursion\n    if N == 1:\n        return x.astype(np.complex128)\n\n    # Recursive step: divide\n    x_even = cooley_tukey_fft(x[0::2])\n    x_odd = cooley_tukey_fft(x[1::2])\n\n    # Combine step: conquer\n    k = np.arange(N // 2)\n    \n    # Twiddle factors. Angles must be in radians.\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    # Butterfly operations\n    X_k = x_even + twiddle_factors * x_odd\n    X_k_plus_N2 = x_even - twiddle_factors * x_odd\n    \n    return np.concatenate([X_k, X_k_plus_N2])\n\ndef inverse_fft(X: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the inverse FFT using the Cooley-Tukey FFT implementation.\n    \"\"\"\n    N = len(X)\n    if N == 0:\n        return np.array([], dtype=np.complex128)\n        \n    # The IFFT can be computed by conjugating the input and output\n    # of a forward FFT and scaling by 1/N.\n    result = np.conj(cooley_tukey_fft(np.conj(X))) / N\n    return result\n\ndef direct_convolution(x: np.ndarray, h: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes linear convolution using the direct summation definition.\n    Complexity is O(nx * nh).\n    \"\"\"\n    nx = len(x)\n    nh = len(h)\n    ny = nx + nh - 1\n\n    if ny <= 0:\n        return np.array([])\n    \n    # The output type should accommodate complex results if inputs are complex\n    y_dtype = np.result_type(x.dtype, h.dtype, np.float64)\n    y = np.zeros(ny, dtype=y_dtype)\n\n    for n in range(ny):\n        for m in range(nx):\n            if 0 <= n - m < nh:\n                y[n] += x[m] * h[n - m]\n    return y\n\ndef fft_convolution(x: np.ndarray, h: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes linear convolution using the FFT-based method.\n    \"\"\"\n    nx = len(x)\n    nh = len(h)\n    ny = nx + nh - 1\n    \n    if ny <= 0:\n        return np.array([])\n\n    # Find the smallest power of 2 that is >= ny\n    # (ny-1).bit_length() gives ceil(log2(ny)). 1 << ... gives 2^ceil(log2(ny)).\n    if ny == 1:\n        L = 1\n    else:\n        L = 1 << (ny - 1).bit_length()\n\n    # Zero-pad signals to length L\n    x_padded = np.zeros(L, dtype=x.dtype)\n    x_padded[:nx] = x\n    \n    h_padded = np.zeros(L, dtype=h.dtype)\n    h_padded[:nh] = h\n\n    # Compute FFTs, pointwise product, and inverse FFT\n    X = cooley_tukey_fft(x_padded)\n    H = cooley_tukey_fft(h_padded)\n    Y = X * H\n    y_padded = inverse_fft(Y)\n\n    # Truncate to the linear convolution length\n    return y_padded[:ny]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    # Use a single random number generator with a fixed seed for reproducibility.\n    # The seed is 2025 as per the problem.\n    rng = np.random.default_rng(2025)\n\n    test_cases = [\n        # (nx, nh, value_type)\n        (64, 47, 'real'),\n        (32, 16, 'complex'),\n        (1, 1, 'real'),\n        (7, 11, 'real'),\n    ]\n\n    results = []\n    for nx, nh, value_type in test_cases:\n        # Generate signals based on test case parameters\n        if value_type == 'real':\n            x = rng.standard_normal(size=nx)\n            h = rng.standard_normal(size=nh)\n        elif value_type == 'complex':\n            x_real = rng.standard_normal(size=nx)\n            x_imag = rng.standard_normal(size=nx)\n            x = x_real + 1j * x_imag\n            h_real = rng.standard_normal(size=nh)\n            h_imag = rng.standard_normal(size=nh)\n            h = h_real + 1j * h_imag\n        \n        # Compute convolution using both methods\n        y_direct = direct_convolution(x, h)\n        y_fft = fft_convolution(x, h)\n\n        # Calculate the maximum absolute difference\n        # The absolute value handles complex numbers correctly.\n        max_abs_diff = np.max(np.abs(y_direct - y_fft))\n        \n        # Append the formatted result\n        results.append(f\"{max_abs_diff:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2383312"}, {"introduction": "With the convolution theorem verified, we can now apply it to one of its most common uses: signal filtering. This exercise explores the consequences of applying a theoretically 'perfect' sharp-cutoff low-pass filter in the frequency domain, which is equivalent to convolving the signal with a sinc-like kernel in the time domain. You will numerically investigate the famous Gibbs phenomenon, a persistent overshoot and ringing artifact that appears near signal discontinuities, and quantify its magnitude as a function of the filter's properties [@problem_id:2383027].", "problem": "You are to investigate the Gibbs phenomenon caused by imposing an ideal sharp-cutoff low-pass filter in the frequency domain on a periodic discrete-time signal. Consider a real-valued, periodic signal sampled with $N$ equally spaced points over one period. Define the signal $x[n]$ on indices $n \\in \\{0,1,\\dots,N-1\\}$ by a unit-amplitude rectangular pulse of width $N/2$, specifically\n$$\nx[n] =\n\\begin{cases}\n1, & N/4 \\le n < 3N/4,\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nwith indices interpreted modulo $N$ so that periodicity over one period is enforced. Define the ideal low-pass projection in the discrete-frequency domain as follows. Let the Discrete Fourier Transform (DFT) frequencies be $f_k$ in cycles per sample, for $k \\in \\{0,1,\\dots,N-1\\}$, as given by the standard DFT frequency grid. Let the Nyquist frequency be $f_{\\text{Nyq}} = 1/2$ cycles per sample. For a specified cutoff fraction $f_c \\in (0,1)$, define the ideal low-pass filter by multiplying each DFT coefficient at frequency $f_k$ by\n$$\nH(f_k) =\n\\begin{cases}\n1, & |f_k| \\le f_c \\, f_{\\text{Nyq}},\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nApplying this frequency-domain multiplication to $x[n]$ and transforming back to the time domain yields the filtered signal $y[n]$. According to the convolution theorem, this operation is equivalent to convolving $x[n]$ with the corresponding time-domain kernel, and the resulting $y[n]$ exhibits oscillatory behavior near the discontinuities of $x[n]$ (Gibbs phenomenon).\n\nFor each parameter pair $(N,f_c)$ in the test suite, define the following two quantitative measures:\n- The overshoot ratio $G = \\max_{n} y[n] - 1$, which measures how much the filtered signal exceeds the target plateau value of $1$ at or near the step.\n- The undershoot magnitude $U = \\max(0, -\\min_{n} y[n])$, which measures how far the filtered signal dips below the baseline value of $0$ at or near the step.\n\nCompute $(G,U)$ for each test case. All values are dimensionless. Report all floating-point results rounded to $6$ decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list $[G,U]$. For example, the output format must be\n[[G_1,U_1],[G_2,U_2],...],\nwith all numbers rounded to $6$ decimal places and no spaces.\n\nTest suite (each pair is $(N,f_c)$):\n- $(4096, 0.2)$\n- $(4096, 0.05)$\n- $(2048, 0.45)$\n- $(128, 0.2)$", "solution": "The problem requires a numerical investigation of the Gibbs phenomenon, which manifests as oscillatory artifacts when a signal with discontinuities is reconstructed from a truncated set of its Fourier components. This is equivalent to applying an ideal sharp-cutoff low-pass filter in the frequency domain. Our task is to perform this filtering operation for a specified discrete rectangular pulse and quantify the resulting overshoot and undershoot for several parameter sets.\n\nThe theoretical foundation for this analysis is the convolution theorem for the Discrete Fourier Transform (DFT). The theorem establishes that circular convolution in the time domain is equivalent to element-wise multiplication in the frequency domain. Given two periodic signals, $x[n]$ and $h[n]$ of period $N$, with DFTs $X[k]$ and $H[k]$ respectively, their circular convolution is $y[n] = (x * h)[n]$. The DFT of the resulting signal $y[n]$ is given by $Y[k] = X[k] H[k]$. The operator $\\mathcal{F}$ denotes the DFT, so we have $Y = \\mathcal{F}\\{y\\}$, $X = \\mathcal{F}\\{x\\}$, and $H = \\mathcal{F}\\{h\\}$. The inverse relationship, $\\mathcal{F}^{-1}\\{X[k] H[k]\\} = (x*h)[n]$, forms the basis of frequency-domain filtering.\n\nThe problem defines a direct filtering procedure which we shall follow:\n$1$. Define the discrete-time signal $x[n]$ for $n \\in \\{0, 1, \\dots, N-1\\}$.\n$2$. Compute its DFT, $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2\\pi kn/N}$.\n$3$. Define the frequency response of the ideal low-pass filter, $H[k]$.\n$4$. Multiply in the frequency domain to obtain the filtered spectrum: $Y[k] = X[k] H[k]$.\n$5$. Compute the inverse DFT to find the filtered time-domain signal: $y[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] e^{i 2\\pi kn/N}$.\n\nWe now specify these components according to the problem statement.\nThe input signal $x[n]$ is a periodic, discrete rectangular pulse of unit amplitude and $50\\%$ duty cycle over a period of $N$ samples. It is defined as:\n$$\nx[n] =\n\\begin{cases}\n1, & N/4 \\le n < 3N/4 \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\nThe indices $n$ are to be interpreted modulo $N$. The given test cases use values of $N$ that are integer multiples of $4$, ensuring the interval boundaries $N/4$ and $3N/4$ are integers.\n\nThe filter is an ideal low-pass filter. Its frequency response $H(f_k)$ is defined on the standard DFT frequency grid. For a signal of length $N$ and a sampling period of $T=1$ (implying frequencies are in cycles per sample), the discrete frequencies $f_k$ range from $-f_s/2$ to $f_s/2$, where the sampling frequency $f_s=1$. The Nyquist frequency is therefore $f_{\\text{Nyq}} = 1/2$ cycles/sample. The filter passes frequencies below a certain cutoff and blocks those above it:\n$$\nH(f_k) =\n\\begin{cases}\n1, & |f_k| \\le f_c f_{\\text{Nyq}} \\\\\n0, & |f_k| > f_c f_{\\text{Nyq}}\n\\end{cases}\n$$\nHere, $f_c$ is the given cutoff fraction. This filter function creates a \"brick-wall\" cutoff at the frequency $f_{\\text{cutoff}} = f_c / 2$.\n\nThe input signal $x[n]$ is real-valued. Consequently, its DFT $X[k]$ must exhibit conjugate symmetry: $X[k] = X^{*}[N-k]$. The filter response $H(f_k)$ is defined based on $|f_k|$, making it a real and even function. The product $Y[k] = X[k] H[k]$ thus retains conjugate symmetry. A signal with a conjugate-symmetric DFT must be real-valued in the time domain. Therefore, the resulting filtered signal $y[n]$ must be real. Any small imaginary part appearing in a numerical computation is an artifact of finite floating-point precision and should be discarded.\n\nFinally, we must quantify the Gibbs phenomenon using two specified metrics. The overshoot ratio $G$ measures the maximum peak of the filtered signal relative to the pulse's intended maximum value of $1$:\n$$\nG = \\max_{n} y[n] - 1\n$$\nThe undershoot magnitude $U$ measures the maximum deviation of the filtered signal below the intended baseline of $0$:\n$$\nU = \\max(0, -\\min_{n} y[n])\n$$\nThe computational algorithm for each parameter pair $(N, f_c)$ is as follows:\n$1$. Generate an array of length $N$ representing the signal $x[n]$.\n$2$. Compute the DFT of this array using a Fast Fourier Transform (FFT) algorithm.\n$3$. Generate the corresponding array of discrete frequencies $f_k$.\n$4$. Construct the filter array $H$ according to the definition using the specified $f_c$.\n$5$. Perform an element-wise multiplication of the signal's DFT and the filter array.\n$6$. Compute the inverse FFT of the resulting product array to obtain $y[n]$. Ensure the result is real by taking the real part.\n$7$. From the array $y[n]$, calculate the maximum and minimum values to compute $G$ and $U$.\n$8$. Round the final values of $G$ and $U$ to $6$ decimal places as required for the output.\n\nThis procedure is deterministic and will be executed for all test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Gibbs phenomenon problem by simulating the application of an\n    ideal low-pass filter on a discrete rectangular pulse.\n    \"\"\"\n    # Test suite: each pair is (N, f_c), where N is the number of samples\n    # and f_c is the cutoff fraction.\n    test_cases = [\n        (4096, 0.2),\n        (4096, 0.05),\n        (2048, 0.45),\n        (128, 0.2)\n    ]\n\n    all_results = []\n    for N, f_c in test_cases:\n        # Step 1: Generate the discrete-time signal x[n].\n        # The signal is a unit-amplitude rectangular pulse of width N/2.\n        # x[n] = 1 for N/4 <= n < 3N/4, and 0 otherwise.\n        x = np.zeros(N, dtype=float)\n        start_index = N // 4\n        end_index = 3 * N // 4\n        x[start_index:end_index] = 1.0\n\n        # Step 2: Compute the Discrete Fourier Transform (DFT) of x[n].\n        X = np.fft.fft(x)\n\n        # Step 3: Define the ideal low-pass filter H(f_k) in the frequency domain.\n        # Frequencies f_k are in cycles per sample (d=1.0).\n        # The Nyquist frequency is f_Nyq = 0.5 cycles/sample.\n        frequencies = np.fft.fftfreq(N, d=1.0)\n        f_nyquist = 0.5\n        cutoff_freq = f_c * f_nyquist\n\n        # The filter H is 1 if |f_k| <= cutoff_freq, and 0 otherwise.\n        # The condition uses <= as specified in the problem statement.\n        H = (np.abs(frequencies) <= cutoff_freq).astype(float)\n\n        # Step 4: Apply the filter by multiplying in the frequency domain.\n        Y = X * H\n\n        # Step 5: Compute the Inverse DFT to get the filtered signal y[n].\n        # The signal y[n] must be real. We take the real part to handle\n        # minor imaginary components arising from numerical inaccuracies.\n        y = np.real(np.fft.ifft(Y))\n\n        # Step 6: Calculate the overshoot ratio G and undershoot magnitude U.\n        # G = max(y[n]) - 1\n        # U = max(0, -min(y[n]))\n        G = np.max(y) - 1.0\n        U = max(0.0, -np.min(y))\n\n        # Append the formatted results for the final output string.\n        # All floating-point results must be rounded to 6 decimal places.\n        all_results.append(f\"[{round(G, 6):.6f},{round(U, 6):.6f}]\")\n\n    # Final print statement must produce a single line in the exact format:\n    # [[G1,U1],[G2,U2],...]\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2383027"}, {"introduction": "Beyond signal processing, the convolution theorem is a powerful tool in data analysis for tasks like matched filtering. This practice demonstrates how to efficiently search for a known signal template within a data stream by calculating the chi-squared ($\\chi^2$) goodness-of-fit for all possible time shifts. You will use the convolution theorem to reformulate this seemingly complex optimization problem into a fast cross-correlation calculation, a technique essential for detecting faint signals in disciplines ranging from astrophysics to particle physics [@problem_id:2383038].", "problem": "You are given two real-valued, finite, discrete time series of equal length $N$, a data sequence $d = \\{d_n\\}_{n=0}^{N-1}$ and a template sequence $h = \\{h_n\\}_{n=0}^{N-1}$. Consider the circularly shifted model $m_n(\\tau, A) = A \\, h_{(n-\\tau) \\bmod N}$ with shift $\\tau \\in \\{0,1,\\dots,N-1\\}$ and real amplitude $A \\in \\mathbb{R}$. For each shift $\\tau$, define the chi-squared\n$$\n\\chi^2(\\tau) = \\sum_{n=0}^{N-1} \\frac{\\left(d_n - A_{\\star}(\\tau) \\, h_{(n-\\tau) \\bmod N}\\right)^2}{\\sigma^2},\n$$\nwhere $\\sigma^2$ is a known, uniform variance and $A_{\\star}(\\tau)$ is the amplitude that minimizes $\\chi^2(\\tau)$ for that fixed $\\tau$. If $\\sum_{n=0}^{N-1} h_n^2 = 0$, interpret $A_{\\star}(\\tau)$ as $0$ for all $\\tau$ and $\\chi^2(\\tau) = \\sum_{n=0}^{N-1} d_n^2 / \\sigma^2$. If multiple shifts $\\tau$ attain the same minimal value of $\\chi^2(\\tau)$, select the smallest such $\\tau$.\n\nYour task is to compute, for each of the following test cases, the shift $\\tau_{\\min}$ that minimizes $\\chi^2(\\tau)$, the corresponding minimal value $\\chi^2_{\\min}$, and the corresponding best-fit amplitude $A_{\\star}(\\tau_{\\min})$. Use $N=8$ and $\\sigma^2 = 1$ for all cases. All sequences are to be interpreted with circular indexing modulo $N$.\n\nTest Suite:\n1) Happy-path (nontrivial template and shift):\n$$\nN = 8, \\quad \\sigma^2 = 1, \\quad h = [0,1,2,3,2,1,0,0], \\quad d = [2,0,0,0,2,4,6,4].\n$$\n\n2) Boundary (alternating sequence, exact negative match):\n$$\nN = 8, \\quad \\sigma^2 = 1, \\quad h = [1,-1,1,-1,1,-1,1,-1], \\quad d = [-1,1,-1,1,-1,1,-1,1].\n$$\n\n3) Edge case (zero template):\n$$\nN = 8, \\quad \\sigma^2 = 1, \\quad h = [0,0,0,0,0,0,0,0], \\quad d = [3,-1,4,1,5,-9,2,6].\n$$\n\n4) General case (periodic template, fractional amplitude):\n$$\nN = 8, \\quad \\sigma^2 = 1, \\quad h = [0,1,0,-1,0,1,0,-1], \\quad d = [0,-0.5,0,0.5,0,-0.5,0,0.5].\n$$\n\nFor each test case, your program must output a list of three values $[\\tau_{\\min}, \\chi^2_{\\min}, A_{\\star}(\\tau_{\\min})]$, where $\\tau_{\\min}$ is an integer, and the two floating-point values are rounded to six decimal places. Your program should produce a single line of output containing the results for all four test cases as a comma-separated list of these per-case lists, enclosed in square brackets, with no spaces. For example, an output with two hypothetical cases would look like\n[[\\tau_1,\\chi^2_1,A_1],[\\tau_2,\\chi^2_2,A_2]].", "solution": "We start from the least-squares definition. For a fixed shift $\\tau$, define\n$$\n\\chi^2(\\tau;A) = \\sum_{n=0}^{N-1} \\frac{\\left(d_n - A \\, h_{(n-\\tau) \\bmod N}\\right)^2}{\\sigma^2}.\n$$\nWith uniform variance $\\sigma^2 = 1$, the minimizing amplitude $A_{\\star}(\\tau)$ is obtained by setting the derivative with respect to $A$ to zero:\n$$\n\\frac{\\partial}{\\partial A} \\chi^2(\\tau;A) = -2 \\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N} + 2 A \\sum_{n=0}^{N-1} h_{(n-\\tau) \\bmod N}^2 = 0.\n$$\nBecause circular shifts preserve the squared norm, $\\sum_{n=0}^{N-1} h_{(n-\\tau) \\bmod N}^2 = \\sum_{n=0}^{N-1} h_n^2 \\equiv \\|h\\|^2$. Thus, if $\\|h\\|^2 > 0$,\n$$\nA_{\\star}(\\tau) = \\frac{\\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N}}{\\|h\\|^2}.\n$$\nSubstituting $A_{\\star}(\\tau)$ back into $\\chi^2$ and expanding yields\n$$\n\\chi^2(\\tau) = \\sum_{n=0}^{N-1} d_n^2 - \\frac{\\left(\\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N}\\right)^2}{\\|h\\|^2}.\n$$\nIf $\\|h\\|^2 = 0$, we follow the stated convention $A_{\\star}(\\tau)=0$ for all $\\tau$ and $\\chi^2(\\tau)=\\sum_{n=0}^{N-1} d_n^2$.\n\nThe quantity $\\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N}$ is the circular cross-correlation of $d$ with $h$ at lag $\\tau$. Denote\n$$\nc(\\tau) \\equiv \\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N}.\n$$\nBy the convolution theorem, $c(\\tau)$ can be computed for all $\\tau$ using the Discrete Fourier Transform (DFT) efficiently via the Fast Fourier Transform (FFT). With the DFT convention\n$$\nD_k = \\sum_{n=0}^{N-1} d_n \\, e^{-2\\pi i k n / N}, \\quad H_k = \\sum_{n=0}^{N-1} h_n \\, e^{-2\\pi i k n / N},\n$$\nthe inverse DFT gives\n$$\nc(\\tau) = \\operatorname{IDFT}\\left(D_k \\, \\overline{H_k}\\right)_\\tau = \\frac{1}{N} \\sum_{k=0}^{N-1} D_k \\, \\overline{H_k} \\, e^{2\\pi i k \\tau / N}.\n$$\nA direct derivation shows\n$$\n\\operatorname{IDFT}\\left(D_k \\, \\overline{H_k}\\right)_\\tau = \\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N},\n$$\nwhich is exactly the desired circular cross-correlation. Therefore, we can compute the entire correlation sequence $c(\\tau)$ in $\\mathcal{O}(N \\log N)$ time via one forward FFT of $d$, one forward FFT of $h$, pointwise multiplication by the complex conjugate, and one inverse FFT.\n\nAlgorithmic steps:\n1) Compute $\\|h\\|^2 = \\sum_{n=0}^{N-1} h_n^2$ and $\\|d\\|^2 = \\sum_{n=0}^{N-1} d_n^2$.\n2) If $\\|h\\|^2 = 0$, set $A_{\\star}(\\tau)=0$ and $\\chi^2(\\tau)=\\|d\\|^2$ for all $\\tau$.\n3) Otherwise, compute $c(\\tau)$ via the convolution theorem using the FFT. Then for each $\\tau$,\n$$\nA_{\\star}(\\tau) = \\frac{c(\\tau)}{\\|h\\|^2}, \\quad \\chi^2(\\tau) = \\|d\\|^2 - \\frac{c(\\tau)^2}{\\|h\\|^2}.\n$$\n4) Find $\\tau_{\\min}$ that minimizes $\\chi^2(\\tau)$; break ties by choosing the smallest $\\tau$.\n5) Report $[\\tau_{\\min}, \\chi^2_{\\min}, A_{\\star}(\\tau_{\\min})]$ with the floating-point entries rounded to six decimal places.\n\nApplying to the provided test suite:\n\nCase $1$: $h = [0,1,2,3,2,1,0,0]$, $d = [2,0,0,0,2,4,6,4]$.\nWe have $\\|h\\|^2 = 19$ and $\\|d\\|^2 = 76$. The cross-correlation attains its maximum at $\\tau=3$ with $c(3) = 38$, giving $A_{\\star}(3) = 38/19 = 2$ and $\\chi^2_{\\min} = 76 - 38^2/19 = 0$.\n\nCase $2$: $h = [1,-1,1,-1,1,-1,1,-1]$, $d = [-1,1,-1,1,-1,1,-1,1]$.\nHere $\\|h\\|^2 = 8$, $\\|d\\|^2 = 8$. For all $\\tau$, $c(\\tau) \\in \\{\\pm 8\\}$ so $\\chi^2(\\tau) = 8 - 64/8 = 0$ for every $\\tau$. We select the smallest index $\\tau_{\\min} = 0$, with $A_{\\star}(0) = -1$.\n\nCase $3$: $h = [0,0,0,0,0,0,0,0]$, $d = [3,-1,4,1,5,-9,2,6]$.\nThen $\\|h\\|^2 = 0$, so by convention $A_{\\star}(\\tau) = 0$ and $\\chi^2(\\tau) = \\|d\\|^2 = 173$ for all $\\tau$. We choose $\\tau_{\\min} = 0$ and $A_{\\star}(0) = 0$.\n\nCase $4$: $h = [0,1,0,-1,0,1,0,-1]$, $d = [0,-0.5,0,0.5,0,-0.5,0,0.5]$.\nWe have $\\|h\\|^2 = 4$, $\\|d\\|^2 = 1$. The cross-correlation peaks at $\\tau=2$ with $c(2)=2$, yielding $A_{\\star}(2) = 2/4 = 0.5$ and $\\chi^2_{\\min} = 1 - 4/4 = 0$.\n\nRounded to six decimals, the expected per-case outputs are\n$$\n[3, 0.000000, 2.000000], \\quad [0, 0.000000, -1.000000], \\quad [0, 173.000000, 0.000000], \\quad [2, 0.000000, 0.500000].\n$$\nAggregated into a single line as required:\n$$\n[[3,0.000000,2.000000],[0,0.000000,-1.000000],[0,173.000000,0.000000],[2,0.000000,0.500000]].\n$$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_min_chi2_shift(d, h):\n    \"\"\"\n    Given data d and template h (both length N), compute for circular shifts tau:\n    - A_hat(tau) = argmin_A sum (d_n - A h_{n - tau})^2\n    - chi2(tau) = min value at A_hat(tau) with sigma^2 = 1\n    Return (tau_min, chi2_min, A_hat_at_tau_min), breaking ties by smallest tau.\n    \"\"\"\n    d = np.asarray(d, dtype=np.float64)\n    h = np.asarray(h, dtype=np.float64)\n    N = d.size\n    assert h.size == N, \"d and h must have the same length\"\n\n    norm_h2 = float(np.dot(h, h))\n    norm_d2 = float(np.dot(d, d))\n\n    if norm_h2 == 0.0:\n        # Degenerate case: A_hat(tau)=0 and chi2(tau)=norm_d2 for all tau\n        tau_min = 0\n        chi2_min = norm_d2\n        A_hat_min = 0.0\n        return tau_min, chi2_min, A_hat_min\n\n    # Compute circular cross-correlation c[tau] = sum_n d_n h_{n - tau}\n    D = np.fft.fft(d)\n    H = np.fft.fft(h)\n    c = np.fft.ifft(D * np.conj(H))\n    # Numerical errors may leave tiny imaginary parts\n    c = np.real(c)\n\n    # Compute chi2(tau) = ||d||^2 - c[tau]^2 / ||h||^2\n    chi2 = norm_d2 - (c * c) / norm_h2\n    # Guard against tiny negative due to numerical precision\n    chi2 = np.maximum(chi2, 0.0)\n\n    tau_min = int(np.argmin(chi2))\n    chi2_min = float(chi2[tau_min])\n    A_hat_min = float(c[tau_min] / norm_h2)\n\n    return tau_min, chi2_min, A_hat_min\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (\n            [2, 0, 0, 0, 2, 4, 6, 4],\n            [0, 1, 2, 3, 2, 1, 0, 0]\n        ),\n        # Case 2\n        (\n            [-1, 1, -1, 1, -1, 1, -1, 1],\n            [1, -1, 1, -1, 1, -1, 1, -1]\n        ),\n        # Case 3\n        (\n            [3, -1, 4, 1, 5, -9, 2, 6],\n            [0, 0, 0, 0, 0, 0, 0, 0]\n        ),\n        # Case 4\n        (\n            [0.0, -0.5, 0.0, 0.5, 0.0, -0.5, 0.0, 0.5],\n            [0, 1, 0, -1, 0, 1, 0, -1]\n        ),\n    ]\n\n    results = []\n    for d, h in test_cases:\n        tau_min, chi2_min, A_hat_min = compute_min_chi2_shift(d, h)\n        # Format with required rounding for floats\n        results.append([tau_min, f\"{chi2_min:.6f}\", f\"{A_hat_min:.6f}\"])\n\n    # Build the exact required single-line output without spaces\n    inner = \",\".join(\"[\" + \",\".join([str(r[0]), r[1], r[2]]) + \"]\" for r in results)\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2383038"}]}