{"hands_on_practices": [{"introduction": "Before diving into the complexities of fast algorithms, it is crucial to build a solid foundation. This first practice grounds your understanding of the Discrete Fourier Transform (DFT) by having you implement it directly from its mathematical definition as a matrix-vector product. By verifying a standard library's FFT against this \"slow\" but transparent reference implementation, you will not only confirm its correctness but also internalize fundamental properties like energy conservation and symmetry. [@problem_id:2391694]", "problem": "You are to implement and use a reference discrete Fourier transform based on the linear algebraic definition to verify the correctness of a canned Fast Fourier Transform (FFT) implementation on small problem sizes. Start from the following foundational base:\n\n- The complex exponentials $e^{\\mathrm{i} 2 \\pi k n / N}$ form an orthogonal basis on the discrete grid $n \\in \\{0,1,\\dots,N-1\\}$ with respect to the discrete inner product, and they are $N$-periodic in $n$ and $k$.\n- The discrete Fourier transform is a linear change of basis between the standard basis in the time domain and the complex-exponential basis in the frequency domain.\n- The discrete-time signals are modeled as finite sequences of length $N$ with complex values, and angles are measured in radians.\n\nTasks:\n\n1) Implement a function that computes the discrete Fourier transform as a pure matrix-vector multiplication using an explicitly formed $N \\times N$ complex matrix. This must be the direct, quadratic-time method without any divide-and-conquer optimization. Denote the input vector by $x \\in \\mathbb{C}^N$ and the output by $X \\in \\mathbb{C}^N$. Choose the forward transform convention consistent with the default normalization of a standard library FFT: the forward transform has no scaling, and the inverse has a factor $1/N$.\n\n2) Implement the corresponding inverse transform as a pure matrix-vector multiplication using the inverse of the forward transform matrix, in a manner consistent with the chosen forward convention.\n\n3) Using your matrix-based transforms, verify the correctness of a canned FFT implementation (use the standard library FFT available in your language; in Python this is the default behavior of numpy.fft.fft) by checking the following properties for each test case listed below:\n- Forward agreement: your direct-transform $X$ matches the canned FFT result within a numerical tolerance.\n- Inverse agreement: applying your direct inverse transform to the canned FFT result reconstructs the original signal within the same tolerance.\n- Energy conservation (Parseval relation for the adopted normalization): $\\sum_{n=0}^{N-1} |x_n|^2$ equals $\\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$ within the tolerance.\n- Hermitian symmetry for real inputs: if $x$ is real-valued, then $X_k = \\overline{X_{(-k) \\bmod N}}$ for all $k$, within the tolerance.\n\nNumerical details:\n\n- Use absolute tolerance $10^{-10}$ and relative tolerance $10^{-10}$.\n- Angles are in radians.\n\nTest suite:\n\nFor each case, let $n \\in \\{0,1,\\dots,N-1\\}$.\n\n- Case A (happy path, complex scalar): $N = 1$, $x_0 = 3 - 2\\,\\mathrm{i}$.\n- Case B (boundary size, real alternating): $N = 2$, $x_0 = 1$, $x_1 = -1$.\n- Case C (prime length, complex mix): $N = 3$, $x_0 = 1 + 2\\,\\mathrm{i}$, $x_1 = -3 + 0.5\\,\\mathrm{i}$, $x_2 = -\\mathrm{i}$.\n- Case D (power of two, single-bin cosine): $N = 4$, $x_n = \\cos\\!\\left(2 \\pi \\cdot 1 \\cdot n / 4\\right)$.\n- Case E (sparse impulse): $N = 5$, $x_n = 2$ if $n = 2$, and $x_n = 0$ otherwise.\n- Case F (complex chirp): $N = 8$, $x_n = \\exp\\!\\left(\\mathrm{i} \\pi\\, n (n-1) / 8\\right)$.\n- Case G (random complex, reproducible): $N = 16$, $x_n = a_n + \\mathrm{i}\\, b_n$, where $\\{a_n\\}$ and $\\{b_n\\}$ are independent standard normal deviates generated with a fixed seed $12345$.\n\nFor each case, produce a single boolean indicating whether all applicable checks pass. The tolerance comparisons must use the specified absolute and relative tolerances.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with boolean literals written as $\\text{True}$ or $\\text{False}$, in the order of Cases A through G. For example: \"[True,False,True]\".", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extracted Givens**\n- **Principle**: The discrete Fourier transform (DFT) is a linear transformation from the standard basis to an orthogonal basis of complex exponentials $e^{\\mathrm{i} 2 \\pi k n / N}$ on the grid $n \\in \\{0, 1, \\dots, N-1\\}$.\n- **Task 1**: Implement a forward DFT, $X = Wx$, by explicitly constructing the $N \\times N$ DFT matrix $W$. This is a direct, $O(N^2)$ algorithm.\n- **Task 2**: Implement the corresponding inverse DFT, $x = W_{\\text{inv}}X$, by constructing the inverse matrix $W_{\\text{inv}}$.\n- **Normalization Convention**: The forward transform is unscaled. The inverse transform is scaled by a factor of $1/N$.\n- **Task 3**: Verify a canned Fast Fourier Transform (FFT) implementation by checking four properties for a suite of test cases:\n    1.  **Forward Agreement**: The direct DFT result must match the canned FFT result.\n    2.  **Inverse Agreement**: Applying the direct IDFT to the canned FFT result must reconstruct the original signal.\n    3.  **Energy Conservation (Parseval's Relation)**: $\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$.\n    4.  **Hermitian Symmetry**: For real-valued inputs $x$, the transform must satisfy $X_k = \\overline{X_{(-k) \\bmod N}}$.\n- **Numerical Tolerance**: Absolute tolerance $10^{-10}$, relative tolerance $10^{-10}$.\n- **Test Cases**:\n    - **A**: $N=1$, $x_0 = 3 - 2\\,\\mathrm{i}$.\n    - **B**: $N=2$, $x = [1, -1]$.\n    - **C**: $N=3$, $x = [1 + 2\\,\\mathrm{i}, -3 + 0.5\\,\\mathrm{i}, -\\mathrm{i}]$.\n    - **D**: $N=4$, $x_n = \\cos(2 \\pi n / 4)$.\n    - **E**: $N=5$, $x = [0, 0, 2, 0, 0]$.\n    - **F**: $N=8$, $x_n = \\exp(\\mathrm{i} \\pi n(n-1) / 8)$.\n    - **G**: $N=16$, $x_n = a_n + \\mathrm{i}\\,b_n$ from standard normal deviates with seed $12345$.\n- **Final Output**: A single boolean result for each test case, indicating if all applicable checks pass.\n\n**Step 2: Validation**\nThe problem is assessed for scientific validity, well-posedness, and objectivity.\n- **Scientific Grounding**: The problem is fundamentally sound. It is based on the standard mathematical definition of the Discrete Fourier Transform, its matrix representation, and its core properties like Parseval's theorem and Hermitian symmetry. The specified normalization is a common convention.\n- **Well-Posedness**: The problem is unambiguous and self-contained. It provides all necessary data (signals, sizes $N$), algorithms to implement, properties to verify, and strict numerical tolerances. A unique, verifiable outcome (a list of booleans) is expected.\n- **Objectivity**: The language is precise and devoid of subjective claims. The tasks are purely computational and verifiable.\n\n**Step 3: Verdict**\nThe problem is deemed **valid**. It is a well-defined exercise in numerical verification, rooted in the fundamental principles of Fourier analysis. I will now provide the solution.\n\n---\n\nThe solution requires the implementation of the Discrete Fourier Transform (DFT) and its inverse as direct matrix-vector multiplications to serve as a reference for verifying a Fast Fourier Transform (FFT) implementation.\n\n**1. Forward Discrete Fourier Transform (DFT)**\nThe DFT maps a discrete signal vector $x \\in \\mathbb{C}^N$ of length $N$ to its frequency-domain representation $X \\in \\mathbb{C}^N$. For each frequency component $k \\in \\{0, 1, \\dots, N-1\\}$, the value $X_k$ is computed as the projection of the signal $x$ onto the complex exponential basis vector corresponding to frequency $k$. Adhering to the standard definition, this is:\n$$\nX_k = \\sum_{n=0}^{N-1} x_n e^{-\\mathrm{i} 2 \\pi k n / N}\n$$\nThis set of $N$ linear equations can be expressed in matrix form as $X = Wx$, where $W$ is the $N \\times N$ DFT matrix. The elements of this matrix, indexed by row $k$ and column $n$, are given by:\n$$\nW_{kn} = e^{-\\mathrm{i} 2 \\pi k n / N}\n$$\nThe implementation will construct this matrix explicitly and perform the matrix-vector multiplication, which has a computational complexity of $O(N^2)$. This is in contrast to FFT algorithms, which compute the same transform in $O(N \\log N)$ time.\n\n**2. Inverse Discrete Fourier Transform (IDFT)**\nThe inverse transform reconstructs the original signal $x$ from its spectrum $X$. Based on the specified normalization convention (no scaling on the forward transform), the inverse transform must include a scaling factor of $1/N$ to ensure that the composition of the forward and inverse transforms yields the identity operation. The formula is:\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k e^{\\mathrm{i} 2 \\pi k n / N}\n$$\nIn matrix form, this is $x = W_{\\text{inv}}X$. The inverse matrix $W_{\\text{inv}}$ has elements:\n$$\n(W_{\\text{inv}})_{nk} = \\frac{1}{N} e^{\\mathrm{i} 2 \\pi n k / N}\n$$\nIt is a fundamental property of the DFT matrix that $W^{-1} = \\frac{1}{N}W^*$, where $W^*$ is the conjugate transpose of $W$. This follows from the orthogonality of the columns of $W$. Our implementation will construct the matrix for the inverse transform and apply it.\n\n**3. Verification Procedure**\nThe correctness of a canned FFT routine is verified against our direct matrix implementation by performing four checks for each test case. All numerical comparisons use a relative tolerance of $r_{tol} = 10^{-10}$ and an absolute tolerance of $a_{tol} = 10^{-10}$.\n\n- **Forward Agreement:** We compute $X_{\\text{direct}} = Wx$ and obtain $X_{\\text{FFT}}$ from the standard library function. We then verify that $X_{\\text{direct}}$ and $X_{\\text{FFT}}$ are element-wise equal within the specified tolerance.\n\n- **Inverse Agreement:** We verify that the original signal $x$ is recovered when our direct inverse transform is applied to the result of the canned FFT, $X_{\\text{FFT}}$. We compute $x_{\\text{rec}} = W_{\\text{inv}} X_{\\text{FFT}}$ and check that $x$ and $x_{\\text{rec}}$ are element-wise equal within tolerance.\n\n- **Energy Conservation (Parseval's Relation):** For the specified normalization, the sum of squared magnitudes of the signal elements is related to the sum of squared magnitudes of its transform coefficients by the identity:\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\nWe compute both the left-hand side and the right-hand side of this equation and verify they are equal within the given tolerance.\n\n- **Hermitian Symmetry:** This property applies only to signals $x$ that are purely real-valued ($x_n \\in \\mathbb{R}$ for all $n$). For such signals, the DFT spectrum exhibits conjugate symmetry:\n$$\nX_k = \\overline{X_{(-k) \\pmod{N}}}\n$$\nThis is checked for all $k \\in \\{0, 1, \\dots, N-1\\}$. This implies that $X_0$ is real, and if $N$ is even, $X_{N/2}$ is also real. This check is performed only for the test cases with real-valued inputs.\n\nFor each test case, the final result is a single boolean value, which is true if and only if all applicable checks pass.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the DFT verification process.\n    \"\"\"\n    \n    # Define test cases as a list of dictionaries.\n    # Each dictionary specifies the signal size N and a function to generate the signal x.\n    test_cases = [\n        {\n            \"id\": \"A\",\n            \"N\": 1,\n            \"x_func\": lambda N: np.array([3.0 - 2.0j]),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"B\",\n            \"N\": 2,\n            \"x_func\": lambda N: np.array([1.0, -1.0]),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"C\",\n            \"N\": 3,\n            \"x_func\": lambda N: np.array([1.0 + 2.0j, -3.0 + 0.5j, -1.0j]),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"D\",\n            \"N\": 4,\n            \"x_func\": lambda N: np.cos(2 * np.pi * 1 * np.arange(N) / N),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"E\",\n            \"N\": 5,\n            \"x_func\": lambda N: np.array([0.0, 0.0, 2.0, 0.0, 0.0]),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"F\",\n            \"N\": 8,\n            \"x_func\": lambda N: np.exp(1j * np.pi * np.arange(N) * (np.arange(N) - 1) / N),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"G\",\n            \"N\": 16,\n            \"x_func\": lambda N: (\n                (rng := np.random.default_rng(12345)).standard_normal(N) +\n                1j * rng.standard_normal(N)\n            ),\n            \"is_real\": False,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        x = case[\"x_func\"](N)\n        is_real_input = case[\"is_real\"]\n        \n        # Run all verification checks for the current case.\n        passed = run_verification(x, N, is_real_input)\n        results.append(passed)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_verification(x, N, is_real_input):\n    \"\"\"\n    Performs all DFT verification checks for a given signal x of size N.\n    \"\"\"\n    rtol = 1e-10\n    atol = 1e-10\n    \n    checks_passed = []\n\n    # --- 1. Forward Agreement Check ---\n    # Construct the direct DFT matrix W\n    k = np.arange(N).reshape((N, 1))\n    n = np.arange(N)\n    W = np.exp(-2j * np.pi * k * n / N)\n\n    # Compute direct DFT and canned FFT\n    X_direct = W @ x\n    X_fft = np.fft.fft(x)\n    \n    forward_agreement = np.allclose(X_direct, X_fft, rtol=rtol, atol=atol)\n    checks_passed.append(forward_agreement)\n\n    # --- 2. Inverse Agreement Check ---\n    # Construct the direct IDFT matrix W_inv\n    # The unscaled matrix is the conjugate transpose of W, or simply change the sign of the exponent.\n    W_inv_unscaled = np.exp(2j * np.pi * k * n / N)\n    W_inv = (1 / N) * W_inv_unscaled\n    \n    # Reconstruct the signal from the canned FFT result\n    x_reconstructed = W_inv @ X_fft\n    \n    inverse_agreement = np.allclose(x, x_reconstructed, rtol=rtol, atol=atol)\n    checks_passed.append(inverse_agreement)\n\n    # --- 3. Energy Conservation (Parseval's Relation) Check ---\n    energy_x = np.sum(np.abs(x)**2)\n    energy_X = (1 / N) * np.sum(np.abs(X_direct)**2)\n\n    parseval_check = np.isclose(energy_x, energy_X, rtol=rtol, atol=atol)\n    checks_passed.append(parseval_check)\n\n    # --- 4. Hermitian Symmetry Check (for real inputs only) ---\n    if is_real_input:\n        # Check that the input signal is indeed real, as a sanity check.\n        assert np.all(np.abs(x.imag)  atol)\n        \n        # Check X_k = conj(X_{(-k) mod N})\n        indices = np.arange(N)\n        neg_indices_mod_N = (-indices) % N\n        X_conj_symmetric = np.conj(X_direct[neg_indices_mod_N])\n        \n        hermitian_check = np.allclose(X_direct, X_conj_symmetric, rtol=rtol, atol=atol)\n        checks_passed.append(hermitian_check)\n\n    # Return True only if all executed checks passed.\n    return all(checks_passed)\n\nsolve()\n```", "id": "2391694"}, {"introduction": "With a solid grasp of what the FFT computes, the next step is to uncover *how* it achieves its remarkable speed. This exercise guides you through the implementation of the quintessential Cooley-Tukey algorithm, the \"divide and conquer\" strategy that lies at the heart of modern FFTs. Building this recursive algorithm from scratch will demystify the process and provide a deep, practical appreciation for its computational elegance and efficiency. [@problem_id:2387187]", "problem": "Let $N$ be a positive integer of the form $N = 2^m$ for some nonnegative integer $m$. For a length-$N$ complex-valued sequence $x = \\{x_n\\}_{n=0}^{N-1}$, the discrete Fourier transform (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ is defined by\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1,\n$$\nand the inverse discrete Fourier transform (IDFT) is defined by\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N} \\quad \\text{for } n = 0,1,\\dots,N-1,\n$$\nwhere all angles are in radians.\n\nWrite a complete program that, without calling any library Fourier transform routines, computes the DFT and IDFT for sequences of length $N = 2^m$. Your program must also verify the following fundamental properties against explicit test cases using only these definitions:\n\n- Circular convolution theorem: For sequences $a$ and $b$ of length $N$, their length-$N$ circular convolution $c$ defined by $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$ satisfies $C_k = A_k B_k$, where $A$, $B$, and $C$ are the DFTs of $a$, $b$, and $c$, respectively.\n- Parseval identity (with the above normalization): $\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$.\n\nYour program must implement its own fast algorithm to compute the DFT and IDFT for $N = 2^m$, and must include a direct $O(N^2)$ DFT for verification. Use a numerical tolerance $\\varepsilon = 10^{-9}$ where boolean validations are required. All angles must be interpreted in radians.\n\nUse the following test suite, and produce the outputs in the order given below:\n\n- Test $1$ (DFT correctness versus direct DFT, happy path): Let $N = 8$ and $x = [0,1,2,3,4,3,2,1]$. Compute $X$ using your fast implementation and $\\tilde{X}$ using the direct DFT. Output a boolean equal to $\\text{True}$ if $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $2$ (Inverse transform recovery): Using the same $N$ and $x$ as in Test $1$, compute $x'$ by applying your IDFT to $X$ from your fast implementation. Output a boolean equal to $\\text{True}$ if $\\max_n |x'_n - x_n| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $3$ (Circular convolution via frequency domain): Let $N = 8$, $a = [1,2,3,0,0,0,0,0]$, and $b = [0,1,0,0,0,0,0,0]$. Compute the length-$N$ circular convolution $c$ directly from its definition. Separately, compute $\\hat{c}$ by taking the DFTs of $a$ and $b$, multiplying pointwise, and applying the IDFT. Output the scalar $\\max_n |c_n - \\hat{c}_n|$ as a floating-point number.\n- Test $4$ (Parseval identity): Let $N = 16$ and $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$ for $n = 0,1,\\dots,15$. Compute $X$ by your fast implementation. Output the scalar $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$ as a floating-point number.\n- Test $5$ (Edge case $N=1$): Let $N = 1$ and $x = [3 + 4i]$. Compute $X$ and then $x'$ via IDFT. Output a boolean equal to $\\text{True}$ if $|x'_0 - x_0| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $6$ (Smallest nontrivial size $N=2$): Let $N = 2$ and $x = [1,-1]$. Compute $X$ by your fast implementation. The exact DFT under the given convention is $[0,2]$. Output the scalar $\\max_k |X_k - [0,2]_k|$ as a floating-point number.\n\nFinal output format: Your program should produce a single line of output containing the six results, in order, as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5,r_6]$. All boolean entries must be either $\\text{True}$ or $\\text{False}$, and all real-valued entries must be printed in standard decimal or scientific notation. No other text should be printed.", "solution": "The problem presented is a well-posed and scientifically sound exercise in computational physics, specifically in the area of signal processing. It requires the implementation and verification of the Discrete Fourier Transform (DFT), its inverse (IDFT), and fundamental associated theorems. The problem is complete, objective, and its resolution is verifiable. We will proceed with the solution.\n\nThe core of the problem is the computation of the DFT, $X$, for a given discrete, complex-valued sequence, $x = \\{x_n\\}_{n=0}^{N-1}$, of length $N$. The definition is given as:\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\nA direct implementation of this formula involves two nested loops, one for each index $k$ from $0$ to $N-1$ and one for each index $n$ from $0$ to $N-1$. This leads to a computational complexity of $O(N^2)$, which is inefficient for large $N$. For verification purposes, such a direct method will be implemented.\n\nThe problem specifies that $N$ is a power of two, i.e., $N = 2^m$ for some non-negative integer $m$. This structure is key for employing a Fast Fourier Transform (FFT) algorithm, specifically the Cooley-Tukey decimation-in-time algorithm. This algorithm reduces the complexity from $O(N^2)$ to $O(N \\log N)$. The principle is one of divide and conquer. The length-$N$ DFT is recursively broken down into two length-$(N/2)$ DFTs.\n\nLet the sequence $x_n$ be split into its even-indexed elements, forming a sequence $x'_m = x_{2m}$, and its odd-indexed elements, forming a sequence $x''_m = x_{2m+1}$, each of length $N/2$. The DFT sum can be rewritten as:\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi i k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi i k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi i k m / (N/2)} + e^{-2\\pi i k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi i k m / (N/2)}\n$$\nLet $X'_k$ and $X''_k$ be the length-$(N/2)$ DFTs of $x'_m$ and $x''_m$, respectively. The expressions above become:\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\nwhere $W_N^k = e^{-2\\pi i k/N}$ is the \"twiddle factor\". For $k$ in the first half of the indices, $0 \\le k  N/2$, we have:\n$$\nX_k = X'_k + W_N^k X''_k\n$$\nFor the second half, where the index is $k+N/2$ for $0 \\le k  N/2$, we use the properties $X'_{k+N/2} = X'_k$, $X''_{k+N/2} = X''_k$, and $W_N^{k+N/2} = -W_N^k$. This yields:\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\nThis recursive definition allows the construction of the full DFT. The recursion terminates at the base case $N=1$, where the DFT of a sequence $\\{x_0\\}$ is simply $\\{X_0\\} = \\{x_0\\}$. Our implementation will follow this recursive structure.\n\nThe Inverse Discrete Fourier Transform (IDFT) is defined as:\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N}\n$$\nA separate implementation is not necessary. We can relate the IDFT to the forward DFT. Observe the following derivation:\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi i k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi i k n / N}\n$$\nThe right-hand side is the DFT of the complex-conjugated sequence $\\{\\overline{X_k}\\}_{k=0}^{N-1}$. Therefore, we can find $x_n$ by computing the DFT of $\\overline{X}$, taking the complex conjugate of the result, and scaling by $1/N$. That is, $x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$. This allows us to use our efficient FFT implementation to compute the inverse transform (IFFT) as well.\n\nThe problem further requires verification of two fundamental theorems.\n\nFirst, the circular convolution theorem. The circular convolution $c$ of two length-$N$ sequences, $a$ and $b$, is given by $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$. The theorem states that the DFT of the convolution is the pointwise product of the individual DFTs: $C_k = A_k B_k$. Thus, one can compute $c$ via the frequency domain: $c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$, where $\\odot$ denotes element-wise multiplication. We will test this by computing $c$ both directly and via the frequency domain route and comparing the results.\n\nSecond, Parseval's identity. For the given DFT normalization, the identity is:\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\nThis theorem relates the total energy of a signal in the time domain to its energy in the frequency domain. We will verify this for a specific test signal.\n\nThe program will proceed by first defining the necessary functions: a direct $O(N^2)$ DFT, a recursive $O(N \\log N)$ FFT, an IFFT based on the FFT, and a direct circular convolution function. Then, it will execute the $6$ specified test cases using these functions and a numerical tolerance of $\\varepsilon = 10^{-9}$ for comparisons. The results will be collected and printed in the required format.", "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N = 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 = epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 = epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 = epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2387187"}, {"introduction": "The true power of an algorithm is revealed in its application. This final practice explores one of the FFT's most significant uses: accelerating convolution operations, a task central to filtering, signal processing, and modeling physical systems. You will confront a crucial distinction between the linear convolution often desired in physics and the circular convolution naturally computed by the FFT, learning the vital technique of zero-padding to bridge this gap and correctly leverage the FFT for practical problem-solving. [@problem_id:2391693]", "problem": "In computational physics, discrete convolutions are often carried out by using the Fast Fourier Transform (FFT) to accelerate the Discrete Fourier Transform (DFT). Let the length-$L$ DFT of a length-$L$ sequence $x[n]$ (with indices $n \\in \\{0,1,\\dots,L-1\\}$) be defined by\n$$\nX[k] \\equiv \\sum_{n=0}^{L-1} x[n] \\, e^{-2\\pi \\mathrm{i} kn/L}, \\quad k \\in \\{0,1,\\dots,L-1\\},\n$$\nand let the inverse DFT be\n$$\nx[n] \\equiv \\frac{1}{L} \\sum_{k=0}^{L-1} X[k] \\, e^{2\\pi \\mathrm{i} kn/L}.\n$$\nGiven two real, finite-length sequences\n$$\nx[n] = \\begin{cases}\n1,  n=0,\\\\\n2,  n=1,\\\\\n1,  n=2,\\\\\n0,  \\text{otherwise},\n\\end{cases}\n\\qquad\nh[n] = \\begin{cases}\n1,  n=0,\\\\\n0,  n=1,\\\\\n-1,  n=2,\\\\\n1,  n=3,\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\nconsider computing their convolution via the FFT-based procedure: zero-pad $x[n]$ and $h[n]$ to a common length $L$, compute their length-$L$ DFTs, multiply pointwise in the frequency domain, and apply the length-$L$ inverse DFT to obtain a length-$L$ sequence in the time domain. By definition, this procedure yields the length-$L$ circular convolution.\n\nLet $N$ and $M$ denote the nonzero lengths of $x[n]$ and $h[n]$, respectively. For the sequences above, $N=3$ and $M=4$.\n\nWhich of the following statements are correct?\n\nA. If both $x[n]$ and $h[n]$ are zero-padded to any common length $L$ satisfying $L \\ge N+M-1$, then the inverse DFT of the pointwise product equals the linear convolution $x[n] * h[n]$ in its first $N+M-1$ samples and is identically zero in the remaining $L-(N+M-1)$ samples.\n\nB. If both sequences are zero-padded to length $L=N+M-2$, then only the last sample is affected by circular wrap-around; the first $N+M-2$ samples of the inverse DFT equal the linear convolution $x[n]*h[n]$.\n\nC. For the specific $x[n]$ and $h[n]$ given, if both are zero-padded to length $L=4$, the inverse DFT of the pointwise product equals the length-$4$ circular convolution\n$$\n[\\,2,\\,3,\\,0,\\,-1\\,].\n$$\n\nD. For the specific $x[n]$ and $h[n]$ given, if both are zero-padded to length $L=6$, the inverse DFT of the pointwise product equals exactly the linear convolution $x[n]*h[n]$ of length $6$.\n\nE. Padding only one of the sequences to any $L \\ge N+M-1$ while leaving the other at its native length is sufficient to obtain the linear convolution via the FFT-based procedure without circular aliasing.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- Length-$L$ Discrete Fourier Transform (DFT) definition: $X[k] \\equiv \\sum_{n=0}^{L-1} x[n] \\, e^{-2\\pi \\mathrm{i} kn/L}$, for $k \\in \\{0,1,\\dots,L-1\\}$.\n- Length-$L$ Inverse DFT (IDFT) definition: $x[n] \\equiv \\frac{1}{L} \\sum_{k=0}^{L-1} X[k] \\, e^{2\\pi \\mathrm{i} kn/L}$.\n- Sequence $x[n]$: $x[0]=1$, $x[1]=2$, $x[2]=1$, and $x[n]=0$ otherwise. Its nonzero length is $N=3$.\n- Sequence $h[n]$: $h[0]=1$, $h[1]=0$, $h[2]=-1$, $h[3]=1$, and $h[n]=0$ otherwise. Its nonzero length is $M=4$.\n- The FFT-based convolution procedure: zero-pad $x[n]$ and $h[n]$ to a common length $L$, compute their length-$L$ DFTs, multiply pointwise, and apply the length-$L$ IDFT.\n- The procedure yields the length-$L$ circular convolution.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem is based on the Discrete Convolution Theorem, a cornerstone of digital signal processing and computational science. The provided definitions for the DFT and IDFT are standard. The relationship between linear and circular convolution via zero-padding is a well-established technique. The problem is scientifically sound.\n- **Well-Posed**: The problem provides all necessary definitions and data to evaluate the correctness of each statement. A unique and verifiable conclusion can be reached for each option.\n- **Objective**: The statements are formulated in precise mathematical language, free from ambiguity or subjective interpretation.\n\n**Step 3: Verdict and Action**\nThe problem statement is internally consistent, scientifically grounded, and well-posed. It is therefore deemed **valid**. We proceed to a full solution.\n\nThe fundamental principle is the Discrete Convolution Theorem, which states that for two length-$L$ sequences $x_p[n]$ and $h_p[n]$, their circular convolution, denoted $(x_p \\circledast_L h_p)[n]$, is given by the IDFT of the pointwise product of their DFTs:\n$$\n(x_p \\circledast_L h_p)[n] = \\text{IDFT}\\{ X_p[k] \\cdot H_p[k] \\}\n$$\nwhere $X_p[k] = \\text{DFT}\\{x_p[n]\\}$ and $H_p[k] = \\text{DFT}\\{h_p[n]\\}$.\n\nThe linear convolution of the original sequences $x[n]$ (length $N$) and $h[n]$ (length $M$), denoted $(x * h)[n]$, is a sequence of length $N+M-1$. The relationship between the length-$L$ circular convolution of the zero-padded sequences and the linear convolution of the original sequences is given by\n$$\n(x_p \\circledast_L h_p)[n] = \\sum_{r=-\\infty}^{\\infty} (x * h)[n + rL] \\quad \\text{for } n \\in \\{0, 1, \\dots, L-1\\}\n$$\nThis formula shows that the circular convolution is a periodized (aliased) version of the linear convolution. To ensure that the circular convolution result is identical to the linear convolution result, we must prevent aliasing. Since the linear convolution $(x * h)[n]$ has a finite length of $N+M-1$ (i.e., it is non-zero only for $n \\in \\{0, 1, \\dots, N+M-2\\}$), aliasing is avoided if the padding length $L$ is at least this great: $L \\ge N+M-1$.\n\nFor the given sequences, $N=3$ and $M=4$. The linear convolution $(x*h)[n]$ has length $N+M-1 = 3+4-1=6$. The condition to obtain the linear convolution from the circular convolution is to use a padding length of at least $L \\ge 6$.\n\nWe will now evaluate each statement individually.\n\n**A. If both $x[n]$ and $h[n]$ are zero-padded to any common length $L$ satisfying $L \\ge N+M-1$, then the inverse DFT of the pointwise product equals the linear convolution $x[n] * h[n]$ in its first $N+M-1$ samples and is identically zero in the remaining $L-(N+M-1)$ samples.**\n\nThis statement describes the standard method for computing linear convolution using FFTs. The condition $L \\ge N+M-1$ ensures there is no time-domain aliasing. The output of the FFT-based procedure is a sequence of length $L$. The linear convolution $(x*h)[n]$ has length $N+M-1$.\n- For $n \\in \\{0, 1, \\dots, N+M-2\\}$, the sum $\\sum_{r=-\\infty}^{\\infty} (x * h)[n + rL]$ contains only the $r=0$ term, since all other terms $(x * h)[n+rL]$ with $r \\ne 0$ are zero. Thus, the result matches the linear convolution for these first $N+M-1$ samples.\n- For $n \\in \\{N+M-1, \\dots, L-1\\}$, the sum $\\sum_{r=-\\infty}^{\\infty} (x * h)[n + rL]$ is zero, because for $r=0$, $(x*h)[n]$ is zero, and for all other $r$, the index is out of the support of $(x*h)$.\nThe resulting length-$L$ sequence is therefore the linear convolution result, padded with $L-(N+M-1)$ zeros. This statement is a precise and correct description of this fact.\nVerdict: **Correct**.\n\n**B. If both sequences are zero-padded to length $L=N+M-2$, then only the last sample is affected by circular wrap-around; the first $N+M-2$ samples of the inverse DFT equal the linear convolution $x[n]*h[n]$.**\n\nFor the given sequences, $L = N+M-2 = 3+4-2=5$. The linear convolution has length $N+M-1=6$. The output of the procedure is a length-$5$ circular convolution $y_c[n]$. The linear convolution is $y_l[n] = (x*h)[n]$.\nThe relation is $y_c[n] = y_l[n] + y_l[n+5] + y_l[n-5] + \\dots$ for $n \\in \\{0,1,2,3,4\\}$.\nSince $y_l[n]$ is non-zero only for $n \\in \\{0,1,2,3,4,5\\}$, this simplifies to:\n- $y_c[0] = y_l[0] + y_l[5]$. This sample is aliased.\n- $y_c[1] = y_l[1]$.\n- $y_c[2] = y_l[2]$.\n- $y_c[3] = y_l[3]$.\n- $y_c[4] = y_l[4]$.\nThe statement claims \"only the last sample is affected\". The last sample is $y_c[4]$, which is not affected. The first sample, $y_c[0]$, is affected. The statement is factually incorrect.\nVerdict: **Incorrect**.\n\n**C. For the specific $x[n]$ and $h[n]$ given, if both are zero-padded to length $L=4$, the inverse DFT of the pointwise product equals the length-$4$ circular convolution $[\\,2,\\,3,\\,0,\\,-1\\,]$.**\n\nWe must compute the length-$4$ circular convolution of the zero-padded sequences.\n$x_p[n] = \\{1, 2, 1, 0\\}$\n$h_p[n] = h[n] = \\{1, 0, -1, 1\\}$\nLet $y_c[n] = (x_p \\circledast_4 h_p)[n] = \\sum_{m=0}^{3} x_p[m] h_p[(n-m) \\pmod 4]$.\n- $y_c[0] = x_p[0]h_p[0] + x_p[1]h_p[3] + x_p[2]h_p[2] + x_p[3]h_p[1] = (1)(1) + (2)(1) + (1)(-1) + (0)(0) = 1+2-1 = 2$.\n- $y_c[1] = x_p[0]h_p[1] + x_p[1]h_p[0] + x_p[2]h_p[3] + x_p[3]h_p[2] = (1)(0) + (2)(1) + (1)(1) + (0)(-1) = 0+2+1 = 3$.\n- $y_c[2] = x_p[0]h_p[2] + x_p[1]h_p[1] + x_p[2]h_p[0] + x_p[3]h_p[3] = (1)(-1) + (2)(0) + (1)(1) + (0)(1) = -1+0+1 = 0$.\n- $y_c[3] = x_p[0]h_p[3] + x_p[1]h_p[2] + x_p[2]h_p[1] + x_p[3]h_p[0] = (1)(1) + (2)(-1) + (1)(0) + (0)(1) = 1-2+0 = -1$.\nThe resulting sequence is $\\{2, 3, 0, -1\\}$. The statement provides the sequence $[\\,2,\\,3,\\,0,\\,-1\\,]$, which matches our calculation.\nVerdict: **Correct**.\n\n**D. For the specific $x[n]$ and $h[n]$ given, if both are zero-padded to length $L=6$, the inverse DFT of the pointwise product equals exactly the linear convolution $x[n]*h[n]$ of length $6$.**\n\nHere, the padding length is $L=6$. The required minimal length to avoid aliasing is $N+M-1=3+4-1=6$. Since $L = N+M-1$, the condition is met. The procedure computes the length-$6$ circular convolution, which in this case will be identical to the length-$6$ linear convolution. The statement claims the result is \"exactly the linear convolution ... of length $6$\". This is a correct consequence of the theory. The length of the output sequence from the IDFT ($L=6$) matches the length of the linear convolution ($N+M-1=6$), and since aliasing is avoided, the sequences themselves are identical.\nVerdict: **Correct**.\n\n**E. Padding only one of the sequences to any $L \\ge N+M-1$ while leaving the other at its native length is sufficient to obtain the linear convolution via the FFT-based procedure without circular aliasing.**\n\nThe described FFT-based procedure involves a pointwise product of the DFTs: $X_p[k] \\cdot H_p[k]$. This operation is only defined if the two DFTs, $X_p[k]$ and $H_p[k]$, have the same length. DFTs of sequences of different lengths will have different numbers of frequency bins, making a pointwise product meaningless. The procedure mandates padding both sequences to a *common* length $L$. Therefore, the proposed modification is not compatible with the procedure.\nVerdict: **Incorrect**.\n\nIn summary, statements A, C, and D are correct.", "answer": "$$\\boxed{ACD}$$", "id": "2391693"}]}