{"hands_on_practices": [{"introduction": "The coefficients in the Adams-Bashforth formulas are not arbitrary; they arise from the fundamental principle of approximating a function's integral by integrating a simpler, polynomial approximation. This exercise guides you through this foundational process, tasking you with deriving the weights for the fifth-order method by constructing and integrating the appropriate interpolating polynomial. Completing this practice [@problem_id:2371218] will demystify the method's origins and solidify your understanding of its mathematical underpinnings.", "problem": "In computational physics, multistep integrators are constructed by approximating the time integral of the right-hand side of an ordinary differential equation (ODE). Consider the initial value problem for a scalar state variable governed by the ODE $y^{\\prime}(t)=f(t,y(t))$ on a uniform grid $t_{n}=t_{0}+n h$ with constant step size $h0$. The explicit Adams–Bashforth family advances $y_{n}$ to $y_{n+1}$ by approximating the integral\n$$\ny_{n+1} = y_{n} + \\int_{t_{n}}^{t_{n+1}} f(t, y(t)) \\, dt\n$$\nusing an interpolating polynomial for $f$ built from previously computed values. Construct a $5$th-order explicit Adams–Bashforth method by the following first-principles procedure:\n\n1. On the interval $[t_{n}, t_{n+1}]$, replace $f(t, y(t))$ by the unique degree-$4$ polynomial $p_{4}(t)$ that interpolates the data $\\{(t_{n-k}, f_{n-k})\\}_{k=0}^{4}$, where $f_{n-k} \\equiv f(t_{n-k}, y_{n-k})$.\n\n2. Use the integral representation $y_{n+1}=y_{n}+\\int_{t_{n}}^{t_{n+1}} p_{4}(t)\\,dt$ to obtain an explicit linear combination of the known values $f_{n}, f_{n-1}, f_{n-2}, f_{n-3}, f_{n-4}$ with coefficients that depend only on the interpolation geometry (not on $f$ itself).\n\nYour task is to derive the $5$ coefficients multiplying $f_{n}, f_{n-1}, f_{n-2}, f_{n-3}, f_{n-4}$, respectively, in this $5$th-order Adams–Bashforth update. Express your final answer as exact rational numbers in a single row matrix ordered as $\\bigl(w_{0}, w_{1}, w_{2}, w_{3}, w_{4}\\bigr)$, where\n$$\ny_{n+1} \\;=\\; y_{n} \\;+\\; h \\sum_{k=0}^{4} w_{k}\\, f_{n-k}.\n$$\nNo rounding is required, and no units are involved.", "solution": "The problem statement is scientifically grounded, well-posed, and objective. It describes a standard procedure for deriving coefficients of an Adams-Bashforth method, a fundamental topic in numerical analysis. The problem is valid, and we shall proceed with its solution.\n\nThe task is to derive the coefficients of the $5$th-order explicit Adams-Bashforth method for the ordinary differential equation $y'(t) = f(t, y(t))$. The method is given by the update rule:\n$$\ny_{n+1} = y_{n} + \\int_{t_{n}}^{t_{n+1}} f(t, y(t)) \\, dt\n$$\nwhere the integrand $f(t, y(t))$ is approximated by a unique interpolating polynomial $p_4(t)$ of degree $4$ passing through the five most recent data points $\\{(t_{n-k}, f_{n-k})\\}_{k=0}^{4}$, where $f_{n-k} \\equiv f(t_{n-k}, y_{n-k})$. The step size $h=t_{n+1}-t_n$ is constant.\n\nTo simplify the integration, we introduce a dimensionless variable $s$ through the transformation $t = t_n + sh$. The integration interval $[t_n, t_{n+1}]$ corresponds to $s \\in [0, 1]$. The interpolation nodes $t_{n-k}$ become $s = -k$ for $k=0, 1, 2, 3, 4$. The integral becomes:\n$$\n\\int_{t_{n}}^{t_{n+1}} p_4(t) \\, dt = \\int_{0}^{1} p_4(t_n+sh) \\, h \\, ds = h \\int_{0}^{1} P(s) \\, ds\n$$\nwhere $P(s)$ is the interpolating polynomial in the $s$ coordinate system.\n\nWe construct $P(s)$ using Newton's backward difference formula, which is particularly suited for this equally spaced data. The polynomial that interpolates the points $(-k, f_{n-k})$ for $k=0, \\dots, 4$ is given by:\n$$\nP(s) = \\sum_{j=0}^{4} (-1)^j \\binom{-s}{j} \\nabla^j f_n\n$$\nwhere $\\binom{-s}{j} = \\frac{(-s)(-s-1)\\cdots(-s-j+1)}{j!}$ is the generalized binomial coefficient, and $\\nabla^j f_n$ is the $j$-th backward difference of $f$ centered at $t_n$.\n\nThe integral term is then $h \\sum_{j=0}^{4} \\gamma_j \\nabla^j f_n$, where the coefficients $\\gamma_j$ are defined as:\n$$\n\\gamma_j = \\int_{0}^{1} (-1)^j \\binom{-s}{j} \\, ds\n$$\nWe compute these coefficients for $j=0, 1, 2, 3, 4$:\n\n$\\gamma_0 = \\int_0^1 (-1)^0 \\binom{-s}{0} ds = \\int_0^1 1 \\, ds = 1$.\n$\\gamma_1 = \\int_0^1 (-1)^1 \\binom{-s}{1} ds = \\int_0^1 s \\, ds = \\left[\\frac{s^2}{2}\\right]_0^1 = \\frac{1}{2}$.\n$\\gamma_2 = \\int_0^1 (-1)^2 \\binom{-s}{2} ds = \\int_0^1 \\frac{s(s+1)}{2} \\, ds = \\frac{1}{2} \\left[\\frac{s^3}{3} + \\frac{s^2}{2}\\right]_0^1 = \\frac{1}{2}\\left(\\frac{1}{3} + \\frac{1}{2}\\right) = \\frac{5}{12}$.\n$\\gamma_3 = \\int_0^1 (-1)^3 \\binom{-s}{3} ds = \\int_0^1 \\frac{s(s+1)(s+2)}{6} \\, ds = \\frac{1}{6}\\int_0^1 (s^3+3s^2+2s) \\, ds = \\frac{1}{6}\\left[\\frac{s^4}{4}+s^3+s^2\\right]_0^1 = \\frac{1}{6}\\left(\\frac{1}{4}+1+1\\right) = \\frac{1}{6}\\left(\\frac{9}{4}\\right) = \\frac{3}{8}$.\n$\\gamma_4 = \\int_0^1 (-1)^4 \\binom{-s}{4} ds = \\int_0^1 \\frac{s(s+1)(s+2)(s+3)}{24} \\, ds = \\frac{1}{24}\\int_0^1(s^4+6s^3+11s^2+6s) \\, ds = \\frac{1}{24}\\left[\\frac{s^5}{5}+\\frac{6s^4}{4}+\\frac{11s^3}{3}+3s^2\\right]_0^1 = \\frac{1}{24}\\left(\\frac{1}{5}+\\frac{3}{2}+\\frac{11}{3}+3\\right) = \\frac{1}{24}\\left(\\frac{6+45+110+90}{30}\\right) = \\frac{251}{720}$.\n\nThe update rule is $y_{n+1} = y_n + h\\sum_{j=0}^4 \\gamma_j \\nabla^j f_n$. To obtain the desired form $y_{n+1} = y_n + h \\sum_{k=0}^4 w_k f_{n-k}$, we must express the backward differences $\\nabla^j f_n$ in terms of the function values $f_{n-k}$:\n$\\nabla^0 f_n = f_n$\n$\\nabla^1 f_n = f_n - f_{n-1}$\n$\\nabla^2 f_n = \\nabla(f_n - f_{n-1}) = (f_n - f_{n-1}) - (f_{n-1} - f_{n-2}) = f_n - 2f_{n-1} + f_{n-2}$\n$\\nabla^3 f_n = f_n - 3f_{n-1} + 3f_{n-2} - f_{n-3}$\n$\\nabla^4 f_n = f_n - 4f_{n-1} + 6f_{n-2} - 4f_{n-3} + f_{n-4}$\n\nThe total increment is $h (\\gamma_0 f_n + \\gamma_1(f_n - f_{n-1}) + \\gamma_2(f_n - 2f_{n-1} + f_{n-2}) + \\gamma_3(f_n - 3f_{n-1} + 3f_{n-2} - f_{n-3}) + \\gamma_4(f_n - 4f_{n-1} + 6f_{n-2} - 4f_{n-3} + f_{n-4}))$. We collect the coefficients $w_k$ for each $f_{n-k}$:\n\n$w_0$ (coefficient of $f_n$):\n$w_0 = \\gamma_0 + \\gamma_1 + \\gamma_2 + \\gamma_3 + \\gamma_4 = 1 + \\frac{1}{2} + \\frac{5}{12} + \\frac{3}{8} + \\frac{251}{720} = \\frac{720+360+300+270+251}{720} = \\frac{1901}{720}$.\n\n$w_1$ (coefficient of $f_{n-1}$):\n$w_1 = -\\gamma_1 - 2\\gamma_2 - 3\\gamma_3 - 4\\gamma_4 = -\\frac{1}{2} - 2\\left(\\frac{5}{12}\\right) - 3\\left(\\frac{3}{8}\\right) - 4\\left(\\frac{251}{720}\\right) = -\\frac{1}{2} - \\frac{5}{6} - \\frac{9}{8} - \\frac{251}{180} = \\frac{-180-300-405-502}{360} = -\\frac{1387}{360}$.\n\n$w_2$ (coefficient of $f_{n-2}$):\n$w_2 = \\gamma_2 + 3\\gamma_3 + 6\\gamma_4 = \\frac{5}{12} + 3\\left(\\frac{3}{8}\\right) + 6\\left(\\frac{251}{720}\\right) = \\frac{5}{12} + \\frac{9}{8} + \\frac{251}{120} = \\frac{50+135+251}{120} = \\frac{436}{120} = \\frac{109}{30}$.\n\n$w_3$ (coefficient of $f_{n-3}$):\n$w_3 = -\\gamma_3 - 4\\gamma_4 = -\\frac{3}{8} - 4\\left(\\frac{251}{720}\\right) = -\\frac{3}{8} - \\frac{251}{180} = \\frac{-135-502}{360} = -\\frac{637}{360}$.\n\n$w_4$ (coefficient of $f_{n-4}$):\n$w_4 = \\gamma_4 = \\frac{251}{720}$.\n\nThe coefficients for the $5$th-order Adams-Bashforth method are thus:\n$w_0 = \\frac{1901}{720}$, $w_1 = -\\frac{1387}{360}$, $w_2 = \\frac{109}{30}$, $w_3 = -\\frac{637}{360}$, $w_4 = \\frac{251}{720}$.\nWe can verify that the method is consistent by checking if $\\sum w_k = 1$:\n$\\frac{1901}{720} - \\frac{2774}{720} + \\frac{2616}{720} - \\frac{1274}{720} + \\frac{251}{720} = \\frac{1901-2774+2616-1274+251}{720} = \\frac{4768 - 4048}{720} = \\frac{720}{720} = 1$.\nThe consistency check is passed. The derivation is complete and correct.", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1901}{720}  -\\frac{1387}{360}  \\frac{109}{30}  -\\frac{637}{360}  \\frac{251}{720} \\end{pmatrix}}$$", "id": "2371218"}, {"introduction": "Moving from theory to practice, a robust numerical integrator is best constructed as a reusable, object-oriented tool. This exercise challenges you to implement a versatile Adams-Bashforth solver in Python, encapsulating the logic for handling different orders, managing the history of past states, and employing a proper startup procedure. By building and testing this solver [@problem_id:2371225] on a variety of ODEs, you will develop the practical software engineering skills essential for a computational physicist.", "problem": "Construct a complete, runnable program that defines a class-based solver for explicit Adams–Bashforth multistep methods and uses it to integrate several initial value problems. The solver must maintain the internal state consisting of the most recent right-hand-side evaluations in the order $\\left[f_n,f_{n-1},\\dots\\right]$, where $f_n=f(t_n,y_n)$. The solver must support constant step size and orders $k \\in \\{1,2,3,4\\}$. All variables are to be treated as dimensionless. Angles, where they appear, must be interpreted in radians.\n\nThe program must, for each test case described below, numerically integrate the given initial value problem from $t=t_0$ to $t=t_{\\mathrm{final}}$ using a fixed step size $h$ and the specified Adams–Bashforth order $k$. For each test case, compute a scalar error as follows: for scalar problems, the absolute value $|y\\left(t_{\\mathrm{final}}\\right)-y_{\\mathrm{exact}}\\left(t_{\\mathrm{final}}\\right)|$; for vector problems, the Euclidean norm $\\left\\|y\\left(t_{\\mathrm{final}}\\right)-y_{\\mathrm{exact}}\\left(t_{\\mathrm{final}}\\right)\\right\\|_2$. Your program must then output a single line that is a comma-separated Python-style list of the four error values in the order of the test cases below.\n\nTest suite specification:\n\n- Test case $1$ (scalar, linear, order $k=1$):\n  - Differential equation: $\\dfrac{dy}{dt}=-y$.\n  - Initial condition: $y(0)=1$ at $t_0=0$.\n  - Final time: $t_{\\mathrm{final}}=1$.\n  - Step size: $h=0.1$.\n  - Exact solution: $y_{\\mathrm{exact}}(t)=e^{-t}$.\n  - Required error to compute: $|y(1)-e^{-1}|$.\n\n- Test case $2$ (scalar, linear, order $k=2$):\n  - Differential equation: $\\dfrac{dy}{dt}=-y$.\n  - Initial condition: $y(0)=1$ at $t_0=0$.\n  - Final time: $t_{\\mathrm{final}}=1$.\n  - Step size: $h=0.1$.\n  - Exact solution: $y_{\\mathrm{exact}}(t)=e^{-t}$.\n  - Required error to compute: $|y(1)-e^{-1}|$.\n\n- Test case $3$ (scalar, nonlinear, order $k=3$):\n  - Differential equation: $\\dfrac{dy}{dt}=-y^3$.\n  - Initial condition: $y(0)=1$ at $t_0=0$.\n  - Final time: $t_{\\mathrm{final}}=1$.\n  - Step size: $h=0.05$.\n  - Exact solution: $y_{\\mathrm{exact}}(t)=\\dfrac{1}{\\sqrt{1+2t}}$.\n  - Required error to compute: $|y(1)-1/\\sqrt{3}|$.\n\n- Test case $4$ (vector, linear rotation, order $k=4$):\n  - Differential equation: $$\\dfrac{d}{dt}\\begin{bmatrix}u\\\\v\\end{bmatrix}=\\begin{bmatrix}0  -\\omega\\\\ \\omega  0\\end{bmatrix}\\begin{bmatrix}u\\\\v\\end{bmatrix}$$ with $\\omega=1$.\n  - Initial condition: $$\\begin{bmatrix}u(0)\\\\v(0)\\end{bmatrix}=\\begin{bmatrix}1\\\\0\\end{bmatrix}$$ at $t_0=0$.\n  - Final time: $t_{\\mathrm{final}}=\\dfrac{\\pi}{2}$.\n  - Step size: $h=\\dfrac{\\pi}{400}$.\n  - Exact solution: $$\\begin{bmatrix}u_{\\mathrm{exact}}(t)\\\\v_{\\mathrm{exact}}(t)\\end{bmatrix}=\\begin{bmatrix}\\cos(t)\\\\\\sin(t)\\end{bmatrix}$$.\n  - Required error to compute: $\\left\\|\\begin{bmatrix}u\\left(\\frac{\\pi}{2}\\right)\\\\v\\left(\\frac{\\pi}{2}\\right)\\end{bmatrix}-\\begin{bmatrix}0\\\\1\\end{bmatrix}\\right\\|_2$.\n\nFinal output format specification:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the fixed order of test cases $\\left[1,2,3,4\\right]$. For example, a syntactically valid line would be of the form $[r_1,r_2,r_3,r_4]$ where each $r_i$ is a floating-point number. Do not print any additional text before or after this line.", "solution": "The problem statement has been subjected to rigorous validation. All givens, including the differential equations, initial conditions, integration parameters, and exact solutions for four distinct test cases, have been extracted and verified. The mathematical and physical premises are sound. The specified ordinary differential equations are standard, and their provided exact solutions are correct. The task is to implement an explicit Adams–Bashforth multistep solver for orders $k \\in \\{1,2,3,4\\}$, which is a well-defined problem in numerical analysis.\n\nA minor ambiguity exists in the problem statement regarding the startup procedure for the multistep methods (where $k  1$). A $k$-step method requires $k$ historical values of the derivative, $f_{n}, f_{n-1}, \\dots, f_{n-k+1}$, to compute the next step, $y_{n+1}$. To begin the integration, the first $k-1$ points, $(t_1, y_1), \\dots, (t_{k-1}, y_{k-1})$, must be generated by a different, self-starting method. The problem does not specify this method. This omission is a common characteristic of such problems, where the implementer is expected to select a standard, scientifically justifiable approach. For this solution, the classical fourth-order Runge-Kutta (RK4) method is chosen for the startup phase. Its single-step nature and $O(h^4)$ accuracy make it a robust and appropriate choice for generating the initial history for Adams–Bashforth methods up to order $4$. With this clarification, the problem is deemed complete, consistent, and well-posed. We proceed with the solution.\n\nThe explicit $k$-step Adams–Bashforth method for solving the initial value problem $\\frac{dy}{dt} = f(t,y)$ with $y(t_0) = y_0$ is defined by the iterative formula:\n$$\ny_{n+1} = y_n + h \\sum_{i=0}^{k-1} b_{k,i} f(t_{n-i}, y_{n-i})\n$$\nwhere $h$ is the constant step size, $y_n$ is the numerical approximation of $y(t_n)$ at time $t_n = t_0 + nh$, and $f_{n-i} = f(t_{n-i}, y_{n-i})$. The coefficients $b_{k,i}$ for the required orders $k=1, 2, 3, 4$ are as follows:\n\nFor $k=1$ (Forward Euler method):\n$$\ny_{n+1} = y_n + h f_n\n$$\nThe single coefficient is $b_{1,0} = 1$.\n\nFor $k=2$:\n$$\ny_{n+1} = y_n + h \\left( \\frac{3}{2} f_n - \\frac{1}{2} f_{n-1} \\right)\n$$\nThe coefficients are $b_{2,0} = \\frac{3}{2}$ and $b_{2,1} = -\\frac{1}{2}$.\n\nFor $k=3$:\n$$\ny_{n+1} = y_n + \\frac{h}{12} \\left( 23 f_n - 16 f_{n-1} + 5 f_{n-2} \\right)\n$$\nThe coefficients are $b_{3,0} = \\frac{23}{12}$, $b_{3,1} = -\\frac{16}{12}$, and $b_{3,2} = \\frac{5}{12}$.\n\nFor $k=4$:\n$$\ny_{n+1} = y_n + \\frac{h}{24} \\left( 55 f_n - 59 f_{n-1} + 37 f_{n-2} - 9 f_{n-3} \\right)\n$$\nThe coefficients are $b_{4,0} = \\frac{55}{24}$, $b_{4,1} = -\\frac{59}{24}$, $b_{4,2} = \\frac{37}{24}$, and $b_{4,3} = -\\frac{9}{24}$.\n\nThe implementation will be encapsulated within a class, `AdamsBashforthSolver`. The solver's constructor, `__init__`, will initialize the state ($t$, $y$) and handle the startup procedure. For a given order $k1$, it will execute $k-1$ steps of the RK4 method to compute the points $(y_1, y_2, \\ldots, y_{k-1})$ and populate the required history of function evaluations, $[f_{k-1}, f_{k-2}, \\ldots, f_0]$. The RK4 formula for a single step from $(t_n, y_n)$ is:\n$$\n\\begin{align*}\nk_1 = f(t_n, y_n) \\\\\nk_2 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_1) \\\\\nk_3 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_2) \\\\\nk_4 = f(t_n + h, y_n + h k_3) \\\\\ny_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n$$\nAfter the startup phase, the solver's state will consist of the current time $t_{k-1}$, the current solution $y_{k-1}$, and the history of derivative evaluations $[f_{k-1}, f_{k-2}, \\ldots, f_0]$. A `step` method will advance the solution by one time step using the appropriate Adams–Bashforth formula. This involves calculating a weighted sum of the historical $f$ values. An `integrate` method will orchestrate the process, repeatedly calling the `step` method until the final integration time $t_{\\mathrm{final}}$ is reached.\n\nThe program will define the four right-hand side functions, set up the parameters for each test case, and instantiate the solver for each case. The `integrate` method will be called to obtain the final numerical solution $y(t_{\\mathrm{final}})$. The error will then be computed as specified: for scalar problems, the absolute difference $|y(t_{\\mathrm{final}}) - y_{\\mathrm{exact}}(t_{\\mathrm{final}})|$, and for the vector problem, the Euclidean norm $\\|y(t_{\\mathrm{final}}) - y_{\\mathrm{exact}}(t_{\\mathrm{final}})\\|_2$. The computed errors for the four cases will be collected and printed in the required format.", "answer": "```python\nimport numpy as np\n\nclass AdamsBashforthSolver:\n    \"\"\"\n    A class-based solver for explicit Adams–Bashforth multistep methods.\n    \"\"\"\n    AB_COEFFS = {\n        1: np.array([1.0]),\n        2: np.array([3.0/2.0, -1.0/2.0]),\n        3: np.array([23.0/12.0, -16.0/12.0, 5.0/12.0]),\n        4: np.array([55.0/24.0, -59.0/24.0, 37.0/24.0, -9.0/24.0])\n    }\n\n    def __init__(self, f, y0, t0, h, k):\n        \"\"\"\n        Initializes the Adams-Bashforth solver.\n\n        Args:\n            f (callable): The right-hand side function f(t, y) of the ODE.\n            y0 (float or np.ndarray): The initial condition y(t0).\n            t0 (float): The initial time.\n            h (float): The step size.\n            k (int): The order of the Adams-Bashforth method (1, 2, 3, or 4).\n        \"\"\"\n        if k not in self.AB_COEFFS:\n            raise ValueError(\"Order k must be in {1, 2, 3, 4}\")\n\n        self.f = f\n        self.y0 = np.array(y0, dtype=float)\n        self.t0 = float(t0)\n        self.h = float(h)\n        self.k = int(k)\n        \n        self.coeffs = self.AB_COEFFS[self.k]\n        \n        # Initialize state\n        self.t = self.t0\n        self.y = self.y0\n        \n        # f_history stores [f_n, f_{n-1}, ..., f_{n-k+1}]\n        self.f_history = []\n        \n        # Startup procedure to generate initial history for k1\n        self._startup()\n\n    def _rk4_step(self, t, y):\n        \"\"\"Performs a single RK4 step.\"\"\"\n        k1 = self.f(t, y)\n        k2 = self.f(t + 0.5 * self.h, y + 0.5 * self.h * k1)\n        k3 = self.f(t + 0.5 * self.h, y + 0.5 * self.h * k2)\n        k4 = self.f(t + self.h, y + self.h * k3)\n        y_next = y + (self.h / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n        t_next = t + self.h\n        return t_next, y_next\n\n    def _startup(self):\n        \"\"\"\n        Generates the first k-1 points using RK4 to populate f_history.\n        \"\"\"\n        # First evaluation at (t0, y0)\n        f0 = self.f(self.t0, self.y0)\n        self.f_history.insert(0, f0)\n        \n        # If k  1, perform k-1 RK4 steps\n        if self.k  1:\n            for _ in range(self.k - 1):\n                t_next, y_next = self._rk4_step(self.t, self.y)\n                self.t = t_next\n                self.y = y_next\n                f_next = self.f(self.t, self.y)\n                self.f_history.insert(0, f_next)\n\n    def step(self):\n        \"\"\"\n        Advances the solution by one step using the Adams-Bashforth formula.\n        \"\"\"\n        # Ensure f_history has the correct size\n        f_hist_array = np.array(self.f_history)\n        \n        # Calculate the weighted sum for the AB step\n        # For scalar y, f_hist_array is (k,), for vector y it is (k, dim)\n        # We need to dot coeffs with f_hist_array.\n        # np.dot handles this if f_hist_array is (dim, k)\n        if self.y.ndim  0: # Vector case\n            ab_sum = np.dot(f_hist_array.T, self.coeffs)\n        else: # Scalar case\n            ab_sum = np.dot(self.coeffs, f_hist_array)\n\n        y_next = self.y + self.h * ab_sum\n        t_next = self.t + self.h\n        \n        # Update state\n        self.y = y_next\n        self.t = t_next\n        \n        # Update history\n        f_next = self.f(self.t, self.y)\n        self.f_history.insert(0, f_next)\n        if len(self.f_history)  self.k:\n            self.f_history.pop()\n\n    def integrate(self, t_final):\n        \"\"\"\n        Integrates the ODE from the current time to t_final.\n        \"\"\"\n        num_total_steps = int(round((t_final - self.t0) / self.h))\n        # Startup phase performed k-1 steps.\n        num_ab_steps = num_total_steps - (self.k - 1)\n        \n        for _ in range(num_ab_steps):\n            self.step()\n            \n        return self.y\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    # --- Define RHS functions for the test cases ---\n    def f_case12(t, y):\n        # dy/dt = -y\n        return -y\n\n    def f_case3(t, y):\n        # dy/dt = -y^3\n        return -y**3\n\n    def f_case4(t, y):\n        # d/dt [u,v] = [0,-1; 1,0] * [u,v]\n        omega = 1.0\n        A = np.array([[0, -omega], [omega, 0]])\n        return A @ y\n\n    # --- Test suite specification ---\n    test_cases = [\n        # Case 1\n        {\n            'f': f_case12, 'y0': 1.0, 't0': 0.0, 't_final': 1.0, 'h': 0.1, 'k': 1,\n            'y_exact_final': np.exp(-1.0)\n        },\n        # Case 2\n        {\n            'f': f_case12, 'y0': 1.0, 't0': 0.0, 't_final': 1.0, 'h': 0.1, 'k': 2,\n            'y_exact_final': np.exp(-1.0)\n        },\n        # Case 3\n        {\n            'f': f_case3, 'y0': 1.0, 't0': 0.0, 't_final': 1.0, 'h': 0.05, 'k': 3,\n            'y_exact_final': 1.0 / np.sqrt(3.0)\n        },\n        # Case 4\n        {\n            'f': f_case4, 'y0': np.array([1.0, 0.0]), 't0': 0.0, 't_final': np.pi / 2.0, \n            'h': np.pi / 400.0, 'k': 4,\n            'y_exact_final': np.array([0.0, 1.0])\n        }\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        solver = AdamsBashforthSolver(\n            f=case['f'],\n            y0=case['y0'],\n            t0=case['t0'],\n            h=case['h'],\n            k=case['k']\n        )\n        \n        y_final = solver.integrate(case['t_final'])\n        \n        y_exact = case['y_exact_final']\n        \n        if i == 3: # Vector case\n            error = np.linalg.norm(y_final - y_exact)\n        else: # Scalar cases\n            error = np.abs(y_final - y_exact)\n            \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2371225"}, {"introduction": "A powerful solver allows us to probe the deeper properties and limitations of a numerical method. This exercise applies your understanding of Adams-Bashforth methods to a Hamiltonian system, where a key physical quantity—phase-space area—is exactly conserved. By tracking the area of a patch of phase space under the numerical flow [@problem_id:2371247], you will discover that the method introduces a spurious drift in this conserved quantity, a phenomenon we term 'numerical entropy'. This reveals that Adams-Bashforth methods are not 'symplectic' and highlights the critical importance of choosing an integrator that respects the geometric structure of the physical problem.", "problem": "Consider the Hamiltonian system in two dimensions defined by the ordinary differential equation (ODE) $$\\frac{d}{dt}\\begin{bmatrix} q(t) \\\\ p(t) \\end{bmatrix} = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix} \\begin{bmatrix} q(t) \\\\ p(t) \\end{bmatrix}.$$ The exact flow for this system is a rotation in the phase plane by angle $t$ (in radians), which preserves phase-space area by Liouville's theorem. Let the initial basis vectors be $\\mathbf{e}_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$ and $\\mathbf{e}_2 = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$. Define the numerical method as the explicit four-step Adams–Bashforth method of order four (AB4), which advances a state $\\mathbf{y}_n \\in \\mathbb{R}^2$ to $\\mathbf{y}_{n+1}$ at time step $n$ using $$\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\left( \\frac{55}{24}\\,\\mathbf{f}_n - \\frac{59}{24}\\,\\mathbf{f}_{n-1} + \\frac{37}{24}\\,\\mathbf{f}_{n-2} - \\frac{9}{24}\\,\\mathbf{f}_{n-3} \\right),$$ where $h  0$ is the step size, $\\mathbf{f}_k = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix} \\mathbf{y}_k$, and $n \\ge 3$. To start the multistep method, use the exact analytical solution at times $t=0$, $t=h$, $t=2h$, and $t=3h$ for each initial condition. The exact solution at time $t$ is given by the rotation $$\\mathbf{y}(t) = \\begin{bmatrix} \\cos t  \\sin t \\\\ -\\sin t  \\cos t \\end{bmatrix} \\mathbf{y}(0),$$ where $t$ is in radians.\n\nFor a given total evolution time $T$, define the numerical phase-space area at time $T$ as the area of the parallelogram spanned by the images of $\\mathbf{e}_1$ and $\\mathbf{e}_2$ under the numerical flow, that is, $$A(T) = \\left| \\det \\left( \\begin{bmatrix} \\mathbf{y}^{(1)}(T)  \\mathbf{y}^{(2)}(T) \\end{bmatrix} \\right) \\right|,$$ where $\\mathbf{y}^{(1)}(T)$ and $\\mathbf{y}^{(2)}(T)$ are the numerical solutions at time $T$ starting from $\\mathbf{y}(0)=\\mathbf{e}_1$ and $\\mathbf{y}(0)=\\mathbf{e}_2$, respectively. The numerical entropy is defined as $$S(T) = \\ln\\!\\left(\\frac{A(T)}{A(0)}\\right),$$ where $A(0)=1$.\n\nAdopt the following conventions for all computations:\n- Use radians for all angles.\n- For a given step size $h$ and a specified number of periods $P$, define the number of steps as $$N = \\operatorname{round}\\!\\left(\\frac{2\\pi P}{h}\\right),$$ so that the total integration time is $T = N h$.\n- If $N \\le 3$, use the exact solution at time $T$ for each initial condition to evaluate $A(T)$.\n- The desired outputs are the values of $S(T)$ as real numbers.\n\nTest suite:\n- Case $1$: $h = 0.10$, $P = 10$.\n- Case $2$: $h = 0.05$, $P = 10$.\n- Case $3$: $h = 0.20$, $P = 5$.\n- Case $4$: $h = 0.10$, $P = 0$.\n- Case $5$: $h = 0.10$, $P = 100$.\n\nFinal output format:\n- Your program should produce a single line of output containing the numerical entropies for the test cases as a comma-separated list enclosed in square brackets, with each number formatted as a fixed-point decimal with $12$ digits after the decimal point, and with no spaces. For example, $[\\text{S}_1,\\text{S}_2,\\text{S}_3,\\text{S}_4,\\text{S}_5]$.", "solution": "The problem presented is valid. It is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. We will proceed with a formal derivation and computational strategy.\n\nThe problem requires us to analyze the numerical evolution of phase-space area for a simple harmonic oscillator using the four-step Adams–Bashforth method (AB4). The system is described by the linear ordinary differential equation (ODE):\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{J} \\mathbf{y}(t), \\quad \\text{where} \\quad \\mathbf{y}(t) = \\begin{bmatrix} q(t) \\\\ p(t) \\end{bmatrix} \\quad \\text{and} \\quad \\mathbf{J} = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix}.\n$$\nThe evolution of the initial basis vectors $\\mathbf{e}_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$ and $\\mathbf{e}_2 = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$ is considered. Let the solutions starting from these initial conditions be $\\mathbf{y}^{(1)}(t)$ and $\\mathbf{y}^{(2)}(t)$, respectively. Due to the linearity of the ODE, we can represent the evolution of both vectors simultaneously by considering a $2 \\times 2$ matrix $\\mathbf{Y}(t) = [ \\mathbf{y}^{(1)}(t) \\, \\mathbf{y}^{(2)}(t) ]$. The matrix $\\mathbf{Y}(t)$ satisfies the same ODE:\n$$\n\\frac{d\\mathbf{Y}}{dt} = \\mathbf{J} \\mathbf{Y}(t),\n$$\nwith the initial condition $\\mathbf{Y}(0) = [ \\mathbf{e}_1 \\, \\mathbf{e}_2 ] = \\mathbf{I}$, where $\\mathbf{I}$ is the $2 \\times 2$ identity matrix.\n\nThe phase-space area at time $T$ is given by $A(T) = \\left| \\det(\\mathbf{Y}(T)) \\right|$. The exact analytical solution is $\\mathbf{Y}(t) = \\mathbf{R}(t)\\mathbf{Y}(0)$, where $\\mathbf{R}(t) = \\begin{bmatrix} \\cos t  \\sin t \\\\ -\\sin t  \\cos t \\end{bmatrix}$ is the rotation matrix. Since $\\det(\\mathbf{R}(t)) = 1$ for all $t$, the exact flow preserves area: $A(t) = |\\det(\\mathbf{R}(t)\\mathbf{I})| = 1$. The numerical entropy is defined as $S(T) = \\ln(A(T)/A(0))$. Since $A(0) = |\\det(\\mathbf{Y}(0))| = |\\det(\\mathbf{I})| = 1$, this simplifies to $S(T) = \\ln(A(T))$. For the exact solution, $S(t) = \\ln(1) = 0$, consistent with Liouville's theorem for Hamiltonian systems.\n\nWe are to use the AB4 numerical method to approximate $\\mathbf{Y}(T)$. Let $\\mathbf{Y}_n$ be the numerical approximation of $\\mathbf{Y}(t_n)$ at time $t_n = n h$, where $h$ is the step size. The AB4 update rule for our matrix equation is:\n$$\n\\mathbf{Y}_{n+1} = \\mathbf{Y}_n + h \\left( \\frac{55}{24}\\,\\mathbf{F}_n - \\frac{59}{24}\\,\\mathbf{F}_{n-1} + \\frac{37}{24}\\,\\mathbf{F}_{n-2} - \\frac{9}{24}\\,\\mathbf{F}_{n-3} \\right),\n$$\nwhere $\\mathbf{F}_k = \\mathbf{J} \\mathbf{Y}_k$. This formula is valid for $n \\ge 3$. To start the integration, we require the state matrices for the first four steps, i.e., $\\mathbf{Y}_0, \\mathbf{Y}_1, \\mathbf{Y}_2, \\mathbf{Y}_3$. The problem specifies that these must be initialized using the exact analytical solution:\n$$\n\\mathbf{Y}_k = \\mathbf{R}(kh) = \\begin{bmatrix} \\cos(kh)  \\sin(kh) \\\\ -\\sin(kh)  \\cos(kh) \\end{bmatrix} \\quad \\text{for} \\quad k \\in \\{0, 1, 2, 3\\}.\n$$\nFrom these, the corresponding derivative matrices $\\mathbf{F}_k = \\mathbf{J} \\mathbf{Y}_k$ can be computed to seed the AB4 iteration.\n\nThe total number of steps $N$ is determined by the number of periods $P$ and step size $h$ as $N = \\operatorname{round}(2\\pi P / h)$, giving a total integration time of $T = N h$.\n\nA special condition applies if $N \\le 3$. In this case, the numerical solution is defined to be the exact solution at time $T$. Thus, the state matrix is $\\mathbf{Y}(T) = \\mathbf{R}(T)$. The area is $A(T) = |\\det(\\mathbf{R}(T))| = 1$, and the numerical entropy is $S(T) = \\ln(1) = 0$.\n\nFor the general case where $N  3$, the computational algorithm is as follows:\n1.  Initialize the first four state matrices $\\mathbf{Y}_0, \\mathbf{Y}_1, \\mathbf{Y}_2, \\mathbf{Y}_3$ using the exact rotation matrix $\\mathbf{R}(t)$.\n2.  Compute the corresponding derivative matrices $\\mathbf{F}_0, \\mathbf{F}_1, \\mathbf{F}_2, \\mathbf{F}_3$.\n3.  Iterate from $n = 3$ to $N-1$. In each step, compute $\\mathbf{Y}_{n+1}$ using the AB4 formula with the four most recent derivative matrices.\n4.  After computing $\\mathbf{Y}_{n+1}$, calculate the new derivative matrix $\\mathbf{F}_{n+1} = \\mathbf{J} \\mathbf{Y}_{n+1}$ and update the history of derivatives for the next step.\n5.  After the loop completes, the final matrix is $\\mathbf{Y}_N$.\n6.  The numerical area is $A(T) = |\\det(\\mathbf{Y}_N)|$.\n7.  The final numerical entropy is $S(T) = \\ln(A(T))$.\n\nThis procedure will be implemented for each test case to compute the required values of $S(T)$. All calculations are performed using double-precision floating-point arithmetic to ensure sufficient accuracy for the specified output format.", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (h, P)\n        (0.10, 10),\n        (0.05, 10),\n        (0.20, 5),\n        (0.10, 0),\n        (0.10, 100),\n    ]\n\n    results = []\n    for h, P in test_cases:\n        result = calculate_numerical_entropy(h, P)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.12f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_numerical_entropy(h, P):\n    \"\"\"\n    Calculates the numerical entropy S(T) for a given step size h and number of periods P.\n    \"\"\"\n    # Define the constant matrix J for the ODE dy/dt = J*y\n    J = np.array([[0., 1.], [-1., 0.]])\n    \n    # Calculate the total number of steps N and total time T\n    N = int(np.round((2. * np.pi * P) / h))\n    T = N * h\n    \n    # Handle the special case where N = 3\n    if N = 3:\n        # Per the problem statement, the numerical solution is the exact solution.\n        # The exact solution is area-preserving, so the determinant of the evolution\n        # matrix is 1. The logarithm of 1 is 0.\n        return 0.0\n        \n    # --- General case for N  3 ---\n    \n    # Function to compute the exact rotation matrix R(t)\n    def get_rotation_matrix(t):\n        c, s = np.cos(t), np.sin(t)\n        return np.array([[c, s], [-s, c]])\n        \n    # 1. Initialization\n    # The first four state matrices (Y_0, Y_1, Y_2, Y_3) are from the exact solution.\n    # We also need the corresponding derivative matrices (F_0, F_1, F_2, F_3).\n    # F_hist will store F_{n-3}, F_{n-2}, F_{n-1}, F_n in a deque.\n    \n    Y_3 = get_rotation_matrix(3. * h)\n    \n    F_0 = J @ get_rotation_matrix(0. * h)\n    F_1 = J @ get_rotation_matrix(1. * h)\n    F_2 = J @ get_rotation_matrix(2. * h)\n    F_3 = J @ get_rotation_matrix(3. * h)\n    \n    F_hist = deque([F_0, F_1, F_2, F_3])\n    Y_curr = Y_3 # This is Y_n at the start of each iteration\n    \n    # AB4 coefficients for f_n, f_{n-1}, f_{n-2}, f_{n-3}\n    b = [55./24., -59./24., 37./24., -9./24.]\n    \n    # 2. Iteration loop\n    # The loop runs from n = 3 to N-1 to compute Y_4 through Y_N.\n    for n in range(3, N):\n        # Retrieve the historical derivatives for the AB4 step\n        F_n, F_nm1, F_nm2, F_nm3 = F_hist[3], F_hist[2], F_hist[1], F_hist[0]\n        \n        # Calculate the update term using the AB4 formula\n        F_update = b[0] * F_n + b[1] * F_nm1 + b[2] * F_nm2 + b[3] * F_nm3\n        \n        # Compute the next state matrix Y_{n+1}\n        Y_next = Y_curr + h * F_update\n        \n        # Compute the derivative at the new state for the next iteration\n        F_next = J @ Y_next\n        \n        # Update the state and history for the next step\n        Y_curr = Y_next\n        F_hist.popleft()\n        F_hist.append(F_next)\n        \n    # After the loop, Y_curr is the final state matrix Y_N\n    Y_N = Y_curr\n    \n    # 3. Final calculation\n    # Compute the area A(T) from the determinant of the final state matrix\n    area_T = np.abs(np.linalg.det(Y_N))\n    \n    # Compute the numerical entropy S(T) = ln(A(T)) since A(0)=1\n    entropy_T = np.log(area_T)\n    \n    return entropy_T\n\n# Run the simulation\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2371247"}]}