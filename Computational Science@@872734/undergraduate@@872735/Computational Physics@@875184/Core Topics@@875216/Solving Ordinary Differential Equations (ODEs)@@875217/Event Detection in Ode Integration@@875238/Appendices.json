{"hands_on_practices": [{"introduction": "We begin with a familiar scenario: a projectile in flight. While the object's path is governed by simple physical laws, determining the exact moment it strikes a complex, non-flat surface requires a more sophisticated approach than simple algebraic substitution. This exercise [@problem_id:2390630] demonstrates how to define a state-dependent event function to precisely locate the time and position of impact on a parabolic hill, providing a foundational skill for any simulation involving collisions or boundary interactions.", "problem": "Consider the ballistic motion of a point-mass projectile in a uniform gravitational field without aerodynamic drag. Let the state of the projectile be given by position $(x(t), y(t))$ in meters and velocity $(v_x(t), v_y(t))$ in meters per second. The dynamics follow Newton’s second law with constant gravitational acceleration $g$ pointing downward. The ground is a deterministic, perfectly rigid, parabolic surface described by the height function $h(x) = a x^2 + b$, where $a$ has units of inverse meters and $b$ has units of meters. An impact event occurs at the earliest time $t_{\\text{hit}} > 0$ such that $y(t_{\\text{hit}}) = h(x(t_{\\text{hit}}))$, with the event detected only when the trajectory crosses the surface from above to below. There is no rebound. Assume the projectile’s initial state is specified by $(x(0), y(0)) = (x_0, y_0)$ in meters and an initial speed $v_0$ in meters per second at a launch angle $\\theta$ measured from the positive $x$-axis (angles expressed in degrees).\n\nFrom first principles, the motion is governed by the ordinary differential equations (ODEs):\n- $\\frac{dx}{dt} = v_x$,\n- $\\frac{dy}{dt} = v_y$,\n- $\\frac{dv_x}{dt} = 0$,\n- $\\frac{dv_y}{dt} = -g$.\n\nDefine the event function $\\phi(t) = y(t) - h(x(t))$. The impact time $t_{\\text{hit}}$ is the smallest positive root of $\\phi(t)$ such that the directional crossing is negative (i.e., $\\phi$ crosses zero from positive to negative).\n\nYour task is to write a complete program that, for each test case below, integrates the ODE forward in time from $t = 0$ until the first impact event or until a finite cutoff time $t_{\\max}$ is reached if no event occurs. Use the following rules:\n- Use $g = 9.81$ in meters per second squared.\n- Convert the launch angle $\\theta$ from degrees to radians before using trigonometric functions.\n- The event is defined by $\\phi(t) = y(t) - (a x(t)^2 + b)$ with detection restricted to downward crossing only.\n- If the event is detected, return the quadruple $[t_{\\text{hit}}, x_{\\text{hit}}, y_{\\text{hit}}, v_{\\text{hit}}]$, where $v_{\\text{hit}} = \\sqrt{v_x(t_{\\text{hit}})^2 + v_y(t_{\\text{hit}})^2}$ is the speed at impact.\n- If no event occurs on $[0, t_{\\max}]$, return $[\\mathrm{nan}, \\mathrm{nan}, \\mathrm{nan}, \\mathrm{nan}]$.\n\nAll answers must be expressed in International System of Units (SI): time in seconds, position in meters, speed in meters per second. Angles are provided in degrees and must be converted to radians internally. Your program must round each reported floating-point value to six decimal places.\n\nTest suite (each case is $(a, b, x_0, y_0, v_0, \\theta, t_{\\max})$):\n- Case A (general “happy path”): $(0.02, 0.0, 0.0, 2.0, 20.0, 30.0, 10.0)$.\n- Case B (near-horizontal launch above a raised hill): $(0.05, 1.0, 0.0, 1.5, 10.0, 0.0, 10.0)$.\n- Case C (steep launch; impact occurs later as the hill rises): $(0.001, 0.0, 0.0, 1.0, 50.0, 60.0, 30.0)$.\n- Case D (vertical drop at fixed horizontal position): $(0.01, 2.0, 5.0, 5.0, 0.0, 90.0, 10.0)$.\n\nFinal output format: Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, where each element is itself a list in the form $[t_{\\text{hit}}, x_{\\text{hit}}, y_{\\text{hit}}, v_{\\text{hit}}]$. For example: $[[t_1,x_1,y_1,v_1],[t_2,x_2,y_2,v_2],[t_3,x_3,y_3,v_3],[t_4,x_4,y_4,v_4]]$. Each number must be rounded to six decimal places as specified.", "solution": "The problem presented is valid. It is a well-posed problem in classical mechanics and computational physics, grounded in the established principles of kinematics and ordinary differential equations. All necessary conditions and parameters are provided, and there are no scientific or logical inconsistencies. We shall proceed with a solution.\n\nThe problem requires a numerical solution to a system of ordinary differential equations (ODEs) describing projectile motion, with the integration terminating upon a specific event: the impact of the projectile with a parabolic surface. The core of the task is the correct formulation of the dynamical system and the implementation of an event detection algorithm.\n\nFirst, we define the state of the system at any time $t \\ge 0$. The state vector $S(t)$ is given by the projectile's position and velocity components:\n$$\nS(t) = \\begin{bmatrix} x(t) \\\\ y(t) \\\\ v_x(t) \\\\ v_y(t) \\end{bmatrix}\n$$\nThe dynamics of the system are governed by Newton's second law for a point mass in a uniform gravitational field with acceleration $g$. This yields a system of four first-order ODEs:\n$$\n\\frac{dS}{dt} = \\frac{d}{dt} \\begin{bmatrix} x \\\\ y \\\\ v_x \\\\ v_y \\end{bmatrix} = \\begin{bmatrix} v_x \\\\ v_y \\\\ 0 \\\\ -g \\end{bmatrix} = F(S)\n$$\nThe initial state $S(0)$ is determined from the given initial conditions: position $(x_0, y_0)$, speed $v_0$, and launch angle $\\theta$. The angle $\\theta$ must first be converted from degrees to radians, let's call it $\\theta_{\\text{rad}}$. The initial velocity components are then:\n$$\nv_x(0) = v_0 \\cos(\\theta_{\\text{rad}})\n$$\n$$\nv_y(0) = v_0 \\sin(\\theta_{\\text{rad}})\n$$\nThus, the initial state vector is fully specified as $S(0) = [x_0, y_0, v_x(0), v_y(0)]^T$.\n\nThe impact event is defined by the condition that the projectile's vertical position $y(t)$ is equal to the height of the parabolic ground surface $h(x(t)) = ax(t)^2 + b$. We define an event function $\\phi(t)$ whose roots correspond to intersections of the trajectory with the surface:\n$$\n\\phi(t) = y(t) - h(x(t)) = y(t) - (a \\cdot x(t)^2 + b)\n$$\nAn impact occurs at time $t_{\\text{hit}}$ if $\\phi(t_{\\text{hit}}) = 0$. The problem specifies two additional constraints:\n$1$. The impact must be the earliest such event for $t > 0$.\n$2$. The event is detected only for a downward crossing, which means the projectile is moving from above the surface to below it. This translates to the condition that the event function is decreasing at the root, i.e., $\\frac{d\\phi}{dt} \\bigg|_{t=t_{\\text{hit}}}  0$.\n\nThe standard and most robust method for solving such a problem is to use a numerical ODE integrator that includes a root-finding capability for event detection. The `scipy.integrate.solve_ivp` function from the SciPy library is precisely designed for this purpose.\n\nThe algorithm proceeds as follows for each test case:\n$1$. **Initialization**: The parameters $(a, b, x_0, y_0, v_0, \\theta, t_{\\max})$ are used to define the specific problem instance. The gravitational constant is $g = 9.81 \\, \\text{m/s}^2$. The initial state vector $S(0)$ is computed as described above. The integration time interval is $[0, t_{\\max}]$.\n\n$2$. **ODE System Definition**: A function, say `ode_system(t, S)`, is defined to compute the derivative vector $\\frac{dS}{dt}$. This function implements the equations of motion, returning $[S_2, S_3, 0, -g]$, where $S_i$ is the $i$-th component of the state vector (using 1-based indexing for clarity).\n\n$3$. **Event Function Definition**: A function, say `event_func(t, S)`, is defined to compute the value of the event function $\\phi(t, S(t)) = S_1 - (a \\cdot S_0^2 + b)$. To satisfy the problem's constraints, we configure this event function for the solver:\n    - We set its `terminal` attribute to `True`. This instructs the solver to terminate the integration when the event is found.\n    - We set its `direction` attribute to $-1$. This instructs the solver to only report roots where the event function is decreasing (crossing zero from positive to negative), which matches the physical requirement.\n\n$4$. **Numerical Integration**: The `solve_ivp` function is called with the ODE system, the time interval, the initial state vector, and the configured event function. We must also request `dense_output=True` to ensure the solver can accurately locate the root between integration steps.\n\n$5$. **Result Extraction**: After the solver returns, we inspect its output.\n    - If the `sol.t_events` list is not empty, an event was successfully detected. The first element, `sol.t_events[0][0]`, gives the impact time $t_{\\text{hit}}$. The corresponding state at impact, $S(t_{\\text{hit}})$, is found in `sol.y_events[0][0]`.\n    - From the state at impact, we extract the position $(x_{\\text{hit}}, y_{\\text{hit}})$ and velocity $(v_{x,\\text{hit}}, v_{y,\\text{hit}})$. The final impact speed is calculated as $v_{\\text{hit}} = \\sqrt{v_{x,\\text{hit}}^2 + v_{y,\\text{hit}}^2}$.\n    - If the `sol.t_events` list is empty, no event satisfying the conditions occurred within the interval $[0, t_{\\max}]$. In this case, the result is reported as not a number (`nan`) for all four output values.\n\n$6$. **Formatting**: The final numerical results, $[t_{\\text{hit}}, x_{\\text{hit}}, y_{\\text{hit}}, v_{\\text{hit}}]$, are rounded to six decimal places as required.\n\nThis procedure provides a complete, correct, and robust solution to the problem, directly implementing the physical principles using standard, validated computational tools.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the impact time and state of a projectile on a parabolic surface.\n    \"\"\"\n    # Gravitational constant in m/s^2\n    G = 9.81\n\n    # Test suite: (a, b, x0, y0, v0, theta, t_max)\n    test_cases = [\n        # Case A (general “happy path”)\n        (0.02, 0.0, 0.0, 2.0, 20.0, 30.0, 10.0),\n        # Case B (near-horizontal launch above a raised hill)\n        (0.05, 1.0, 0.0, 1.5, 10.0, 0.0, 10.0),\n        # Case C (steep launch; impact occurs later as the hill rises)\n        (0.001, 0.0, 0.0, 1.0, 50.0, 60.0, 30.0),\n        # Case D (vertical drop at fixed horizontal position)\n        (0.01, 2.0, 5.0, 5.0, 0.0, 90.0, 10.0),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        a, b, x0, y0, v0, theta_deg, t_max = case\n\n        # Convert angle to radians for trigonometric functions\n        theta_rad = np.deg2rad(theta_deg)\n\n        # Calculate initial velocity components\n        vx0 = v0 * np.cos(theta_rad)\n        vy0 = v0 * np.sin(theta_rad)\n\n        # Initial state vector: [x, y, vx, vy]\n        s0 = [x0, y0, vx0, vy0]\n\n        def ode_system(t, s):\n            \"\"\"\n            Defines the system of ordinary differential equations for projectile motion.\n            s = [x, y, vx, vy]\n            \"\"\"\n            # dx/dt = vx\n            # dy/dt = vy\n            # dvx/dt = 0\n            # dvy/dt = -g\n            return [s[2], s[3], 0, -G]\n\n        def event_func(t, s):\n            \"\"\"\n            Event function for impact detection.\n            The event occurs when y(t) - h(x(t)) = 0.\n            h(x) = a*x^2 + b\n            \"\"\"\n            return s[1] - (a * s[0]**2 + b)\n\n        # Set event properties: terminate on event, detect downward crossing\n        event_func.terminal = True\n        event_func.direction = -1\n\n        # Integrate the ODE system\n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=[0, t_max],\n            y0=s0,\n            events=event_func,\n            dense_output=True,\n        )\n\n        # Process the results\n        if sol.t_events and len(sol.t_events[0]) > 0:\n            # Event was detected\n            t_hit = sol.t_events[0][0]\n            s_hit = sol.y_events[0][0]\n            x_hit, y_hit, vx_hit, vy_hit = s_hit\n\n            # The problem asks for the height of the impact to be y_hit,\n            # which is guaranteed by the event function to be a*x_hit**2 + b\n            # at the located root.\n            \n            # Calculate final speed at impact\n            v_hit = np.sqrt(vx_hit**2 + vy_hit**2)\n\n            case_result = [t_hit, x_hit, y_hit, v_hit]\n        else:\n            # No event detected within t_max\n            case_result = [np.nan, np.nan, np.nan, np.nan]\n\n        all_results.append(case_result)\n\n    # Format the final output string\n    formatted_results = []\n    for case_res in all_results:\n        str_vals = []\n        for val in case_res:\n            if np.isnan(val):\n                str_vals.append(\"nan\")\n            else:\n                str_vals.append(f\"{val:.6f}\")\n        formatted_results.append(f\"[{','.join(str_vals)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2390630"}, {"introduction": "Moving beyond simple kinematics, we now explore how event detection is crucial for modeling real-world engineering systems with physical constraints. In this practice [@problem_id:2390610], we will model a micro-electro-mechanical (MEMS) accelerometer and use event detection to determine if and when its internal proof mass hits the boundary of its housing. This critical failure or operational mode, known as \"bottoming out,\" illustrates how event detection serves as a vital tool for monitoring state variables as they cross important thresholds.", "problem": "A single-degree-of-freedom Micro-Electro-Mechanical Systems (MEMS) accelerometer can be modeled as a proof mass connected to a housing by a linear spring and damper. Let the absolute displacement of the proof mass be $X(t)$ and the absolute displacement of the housing (base) be $Y(t)$. Define the relative displacement as $x(t) = X(t) - Y(t)$. The housing is subject to a prescribed base acceleration $a_b(t) = \\ddot{Y}(t)$. The proof mass is confined within the housing such that the relative displacement is constrained to the interval $[-d_{\\max}, d_{\\max}]$. When $|x(t)| = d_{\\max}$, the proof mass physically contacts the housing (this condition is called \"bottoming out\"). Your task is to derive the governing ordinary differential equation (ODE) for $x(t)$ from first principles and then implement a numerical integrator with robust event detection to identify the first time $t_e$ at which bottoming out occurs, if it does within a specified time horizon.\n\nStart from Newton's Second Law applied to the proof mass and a linear viscous damping model between the proof mass and housing. Use the definitions of velocity and acceleration as time derivatives. Do not assume any pre-derived formula for the relative motion; derive it from the absolute motion using $x(t) = X(t) - Y(t)$ and the linear spring and damper forces.\n\nOnce the governing ODE for $x(t)$ has been derived, implement a numerical integration algorithm that:\n- Integrates the system forward in time from an initial condition $(x(0), \\dot{x}(0))$.\n- Detects an event when either $x(t) = d_{\\max}$ or $x(t) = -d_{\\max}$ is satisfied for the first time.\n- Treats the case $|x(0)| = d_{\\max}$ as an immediate event at $t = 0$ without integrating.\n- Stops integration at the first event if it occurs before the end of the simulation horizon $T_{\\text{end}}$.\n\nUse physically consistent units throughout. Mass must be in kilograms, stiffness in newtons per meter, damping in newton-seconds per meter, displacement in meters, time in seconds, and acceleration in meters per second squared. The sine function arguments must be in radians.\n\nYour program must implement the following four test cases, which collectively serve as the test suite. In all cases, express the final time outputs in seconds and velocity outputs in meters per second.\n\n- Test case 1 (positive boundary hit under negative step base acceleration):\n  - Mass: $m = 1.0 \\times 10^{-6}\\,\\mathrm{kg}$\n  - Damping: $c = 3.162 \\times 10^{-4}\\,\\mathrm{N\\cdot s/m}$\n  - Stiffness: $k = 10\\,\\mathrm{N/m}$\n  - Maximum displacement: $d_{\\max} = 1.0 \\times 10^{-5}\\,\\mathrm{m}$\n  - Initial conditions: $x(0) = 0\\,\\mathrm{m}$, $\\dot{x}(0) = 0\\,\\mathrm{m/s}$\n  - Base acceleration: constant step $a_b(t) = a_0$ with $a_0 = -150\\,\\mathrm{m/s^2}$\n  - Time horizon: $T_{\\text{end}} = 0.05\\,\\mathrm{s}$\n\n- Test case 2 (no contact under bounded sinusoidal base acceleration, off resonance):\n  - Mass: $m = 1.0 \\times 10^{-6}\\,\\mathrm{kg}$\n  - Damping: $c = 3.162 \\times 10^{-4}\\,\\mathrm{N\\cdot s/m}$\n  - Stiffness: $k = 10\\,\\mathrm{N/m}$\n  - Maximum displacement: $d_{\\max} = 1.0 \\times 10^{-5}\\,\\mathrm{m}$\n  - Initial conditions: $x(0) = 0\\,\\mathrm{m}$, $\\dot{x}(0) = 0\\,\\mathrm{m/s}$\n  - Base acceleration: sinusoid $a_b(t) = A \\sin(2\\pi f t)$ with $A = 8\\,\\mathrm{m/s^2}$ and $f = 100\\,\\mathrm{Hz}$\n  - Time horizon: $T_{\\text{end}} = 0.5\\,\\mathrm{s}$\n\n- Test case 3 (negative boundary hit under positive step base acceleration):\n  - Mass: $m = 1.0 \\times 10^{-6}\\,\\mathrm{kg}$\n  - Damping: $c = 3.162 \\times 10^{-4}\\,\\mathrm{N\\cdot s/m}$\n  - Stiffness: $k = 10\\,\\mathrm{N/m}$\n  - Maximum displacement: $d_{\\max} = 1.0 \\times 10^{-5}\\,\\mathrm{m}$\n  - Initial conditions: $x(0) = 0\\,\\mathrm{m}$, $\\dot{x}(0) = 0\\,\\mathrm{m/s}$\n  - Base acceleration: constant step $a_b(t) = a_0$ with $a_0 = +150\\,\\mathrm{m/s^2}$\n  - Time horizon: $T_{\\text{end}} = 0.05\\,\\mathrm{s}$\n\n- Test case 4 (immediate contact at initialization):\n  - Mass: $m = 1.0 \\times 10^{-6}\\,\\mathrm{kg}$\n  - Damping: $c = 3.162 \\times 10^{-4}\\,\\mathrm{N\\cdot s/m}$\n  - Stiffness: $k = 10\\,\\mathrm{N/m}$\n  - Maximum displacement: $d_{\\max} = 1.0 \\times 10^{-5}\\,\\mathrm{m}$\n  - Initial conditions: $x(0) = d_{\\max}\\,\\mathrm{m}$, $\\dot{x}(0) = 0\\,\\mathrm{m/s}$\n  - Base acceleration: $a_b(t) = 0\\,\\mathrm{m/s^2}$\n  - Time horizon: $T_{\\text{end}} = 0.01\\,\\mathrm{s}$\n\nFor each test case, your program must output a list with four entries:\n- A boolean indicating whether bottoming out occurs before $T_{\\text{end}}$.\n- The event time $t_e$ in seconds (use $-1.0$ if no event occurs).\n- The relative velocity $\\dot{x}(t_e)$ in meters per second at the event time (use $0.0$ if no event occurs).\n- An integer identifying which boundary is hit: $+1$ if $x(t_e) = d_{\\max}$, $-1$ if $x(t_e) = -d_{\\max}$, or $0$ if no event occurs.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list should consist of one such four-entry list per test case, in the same order as specified above. For example: \"[[True,0.012345,0.456789,1],[False,-1.0,0.0,0],[...],[...]]\".", "solution": "The problem statement has been subjected to rigorous validation and is deemed scientifically grounded, well-posed, and objective. It presents a standard problem in mechanical vibrations and computational physics, with all necessary data and conditions provided. There are no logical contradictions, factual errors, or ambiguities. Therefore, I will proceed with the derivation and solution.\n\nThe task is to determine the first time of \"bottoming out\" for a MEMS accelerometer, which is modeled as a damped, single-degree-of-freedom mechanical system subjected to base excitation. This involves two primary steps: first, deriving the governing equation of motion for the relative displacement from fundamental principles, and second, implementing a numerical solution with event detection to find the precise moment of impact.\n\n**1. Derivation of the Governing Ordinary Differential Equation (ODE)**\n\nThe system consists of a proof mass, denoted by $m$, connected to a housing by a linear spring of stiffness $k$ and a viscous damper with coefficient $c$. The absolute displacement of the proof mass is $X(t)$, and the absolute displacement of the housing is $Y(t)$. The relative displacement is defined as $x(t) = X(t) - Y(t)$.\n\nWe begin with Newton's Second Law applied to the proof mass $m$. The sum of all external forces acting on the mass equals the mass times its absolute acceleration, $\\ddot{X}(t)$.\n$$ \\sum F = m \\ddot{X}(t) $$\nThe forces acting on the mass are from the spring and the damper. These forces are generated by the relative motion between the mass and the housing.\nThe spring force, $F_s$, is proportional to the relative displacement $x(t)$:\n$$ F_s = -k x(t) $$\nThe damping force, $F_d$, is proportional to the relative velocity $\\dot{x}(t) = \\dot{X}(t) - \\dot{Y}(t)$:\n$$ F_d = -c \\dot{x}(t) $$\nSubstituting these forces into Newton's law gives the equation of motion in terms of the absolute acceleration $\\ddot{X}(t)$:\n$$ -k x(t) - c \\dot{x}(t) = m \\ddot{X}(t) $$\nTo obtain an equation solely in terms of the relative displacement $x(t)$, we express $\\ddot{X}(t)$ using the definition $x(t) = X(t) - Y(t)$. Differentiating this definition twice with respect to time $t$ yields:\n$$ X(t) = x(t) + Y(t) $$\n$$ \\dot{X}(t) = \\dot{x}(t) + \\dot{Y}(t) $$\n$$ \\ddot{X}(t) = \\ddot{x}(t) + \\ddot{Y}(t) $$\nThe problem specifies the base motion via its acceleration, $a_b(t) = \\ddot{Y}(t)$. Substituting this and the expression for $\\ddot{X}(t)$ into the equation of motion:\n$$ -k x(t) - c \\dot{x}(t) = m (\\ddot{x}(t) + a_b(t)) $$\nRearranging the terms to the standard form for a second-order linear ordinary differential equation, we arrive at the governing equation for the relative displacement $x(t)$:\n$$ m \\ddot{x}(t) + c \\dot{x}(t) + k x(t) = -m a_b(t) $$\nThis equation describes the dynamics of the relative motion of the proof mass with respect to the housing, driven by the base acceleration $a_b(t)$.\n\n**2. State-Space Formulation**\n\nNumerical integrators for ODEs typically operate on systems of first-order equations. We must convert our second-order ODE into this form. We define a state vector $\\mathbf{z}(t)$ consisting of the relative displacement and relative velocity:\n$$ \\mathbf{z}(t) = \\begin{bmatrix} z_0(t) \\\\ z_1(t) \\end{bmatrix} = \\begin{bmatrix} x(t) \\\\ \\dot{x}(t) \\end{bmatrix} $$\nThe time derivative of the state vector, $\\dot{\\mathbf{z}}(t)$, is:\n$$ \\dot{\\mathbf{z}}(t) = \\begin{bmatrix} \\dot{z}_0(t) \\\\ \\dot{z}_1(t) \\end{bmatrix} = \\begin{bmatrix} \\dot{x}(t) \\\\ \\ddot{x}(t) \\end{bmatrix} $$\nFrom our state definition, the first component is $\\dot{z}_0 = z_1$. The second component, $\\dot{z}_1 = \\ddot{x}$, is obtained by rearranging the governing ODE:\n$$ \\ddot{x}(t) = \\frac{1}{m} \\left( -c \\dot{x}(t) - k x(t) - m a_b(t) \\right) $$\nSubstituting the state variables $z_0$ and $z_1$:\n$$ \\dot{z}_1(t) = -\\frac{c}{m} z_1(t) - \\frac{k}{m} z_0(t) - a_b(t) $$\nThus, the system of first-order ODEs is:\n$$ \\dot{\\mathbf{z}}(t) = \\mathbf{f}(t, \\mathbf{z}(t)) = \\begin{bmatrix} z_1(t) \\\\ -\\frac{k}{m} z_0(t) - \\frac{c}{m} z_1(t) - a_b(t) \\end{bmatrix} $$\nThis system can now be solved numerically given an initial state $\\mathbf{z}(0) = [x(0), \\dot{x}(0)]^T$.\n\n**3. Event Detection**\n\nThe problem requires finding the first time $t_e$ at which the proof mass makes contact with the housing. This event, termed \"bottoming out,\" occurs when the magnitude of the relative displacement equals the maximum allowed gap, $|x(t)| = d_{\\max}$. This is equivalent to two conditions:\n1.  $x(t) - d_{\\max} = 0$ (contact at the positive boundary)\n2.  $x(t) + d_{\\max} = 0$ (contact at the negative boundary)\n\nThis is a root-finding problem concurrent with the time integration of the ODE. We will use the `scipy.integrate.solve_ivp` function from the SciPy library, which has built-in support for such event detection.\n\nWe define two event functions whose roots correspond to the bottoming-out conditions:\n$$ g_p(t, \\mathbf{z}) = z_0(t) - d_{\\max} $$\n$$ g_n(t, \\mathbf{z}) = z_0(t) + d_{\\max} $$\nThe integrator will monitor the values of $g_p$ and $g_n$ during the integration process and locate the times $t$ where they cross zero. By setting the `terminal` attribute of these event functions to `True`, we instruct the integrator to stop at the first time $t_e > 0$ that a root is found.\n\nThe solution object returned by `solve_ivp` provides the time of the event, $t_e$, and the state of the system at that instant, $\\mathbf{z}(t_e)$. From this, we can extract the event time and the relative velocity $\\dot{x}(t_e) = z_1(t_e)$. The sign of the boundary hit ($+1$ or $-1$) is determined by which event function, $g_p$ or $g_n$, triggered the termination. If the integration completes up to the final time $T_{\\text{end}}$ without any event being triggered, it signifies that no contact occurred.\n\nA special case is when the system starts at the boundary, i.e., $|x(0)| = d_{\\max}$. In this scenario, integration is unnecessary, and the event is registered to have occurred at $t_e=0$.\n\n**4. Implementation Strategy**\n\nThe final program will be structured as follows:\n- A list of test cases will be defined, with each case containing the physical parameters ($m, c, k, d_{\\max}$), initial conditions ($x(0), \\dot{x}(0)$), a function for the base acceleration $a_b(t)$, and the simulation time horizon $T_{\\text{end}}$.\n- The program will iterate through each test case.\n- For each case, it will first check for an immediate event at $t=0$.\n- If no immediate event exists, it will define the ODE system function and the two terminal event functions described above.\n- `scipy.integrate.solve_ivp` will be called to integrate the system from $t=0$ to $t=T_{\\text{end}}$.\n- The output from `solve_ivp` will be analyzed. If it terminated due to an event, the event time, final velocity, and boundary identifier ($+1$ or $-1$) are extracted.\n- If the integration completes without an event, the result is recorded as specified (no event, $t_e = -1.0$, $\\dot{x}(t_e) = 0.0$, side=$0$).\n- All results are compiled into a final list of lists and formatted into a single string for output, strictly adhering to the specified format. This ensures a complete and correct response to the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Derives the ODE for a MEMS accelerometer, solves it numerically for four\n    test cases, and detects the first \"bottoming out\" event.\n    \"\"\"\n    test_cases = [\n        {\n            \"m\": 1.0e-6, \"c\": 3.162e-4, \"k\": 10.0, \"d_max\": 1.0e-5,\n            \"x0\": 0.0, \"xdot0\": 0.0,\n            \"ab_func\": lambda t: -150.0, \"T_end\": 0.05,\n        },\n        {\n            \"m\": 1.0e-6, \"c\": 3.162e-4, \"k\": 10.0, \"d_max\": 1.0e-5,\n            \"x0\": 0.0, \"xdot0\": 0.0,\n            \"ab_func\": lambda t: 8.0 * np.sin(2 * np.pi * 100 * t), \"T_end\": 0.5,\n        },\n        {\n            \"m\": 1.0e-6, \"c\": 3.162e-4, \"k\": 10.0, \"d_max\": 1.0e-5,\n            \"x0\": 0.0, \"xdot0\": 0.0,\n            \"ab_func\": lambda t: 150.0, \"T_end\": 0.05,\n        },\n        {\n            \"m\": 1.0e-6, \"c\": 3.162e-4, \"k\": 10.0, \"d_max\": 1.0e-5,\n            \"x0\": 1.0e-5, \"xdot0\": 0.0,\n            \"ab_func\": lambda t: 0.0, \"T_end\": 0.01,\n        }\n    ]\n\n    # ODE system function\n    # z = [x, x_dot]\n    # dz/dt = [x_dot, x_ddot]\n    # m*x_ddot + c*x_dot + k*x = -m*a_b\n    def ode_system(t, z, m, c, k, ab_func):\n        x, x_dot = z\n        x_ddot = (-c * x_dot - k * x - m * ab_func(t)) / m\n        return [x_dot, x_ddot]\n\n    results = []\n    for params in test_cases:\n        m, c, k = params[\"m\"], params[\"c\"], params[\"k\"]\n        d_max = params[\"d_max\"]\n        x0, xdot0 = params[\"x0\"], params[\"xdot0\"]\n        ab_func = params[\"ab_func\"]\n        T_end = params[\"T_end\"]\n        \n        # Check for immediate event at t=0\n        if np.isclose(x0, d_max):\n            results.append([True, 0.0, xdot0, 1])\n            continue\n        if np.isclose(x0, -d_max):\n            results.append([True, 0.0, xdot0, -1])\n            continue\n\n        # Event function for positive boundary contact\n        def event_pos(t, z, m, c, k, ab_func):\n            return z[0] - d_max\n        event_pos.terminal = True\n        event_pos.direction = 0\n\n        # Event function for negative boundary contact\n        def event_neg(t, z, m, c, k, ab_func):\n            return z[0] + d_max\n        event_neg.terminal = True\n        event_neg.direction = 0\n        \n        y0 = [x0, xdot0]\n        t_span = [0, T_end]\n        \n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=t_span,\n            y0=y0,\n            method='RK45',\n            args=(m, c, k, ab_func),\n            events=[event_pos, event_neg],\n            dense_output=True,\n            rtol=1e-8,\n            atol=1e-10\n        )\n\n        if sol.status == 1:  # An event was triggered\n            event_occurred = True\n            hit_side = 0\n            \n            # Check which event occurred first\n            t_e_pos = sol.t_events[0][0] if len(sol.t_events[0]) > 0 else np.inf\n            t_e_neg = sol.t_events[1][0] if len(sol.t_events[1]) > 0 else np.inf\n            \n            if t_e_pos = t_e_neg:\n                event_time = t_e_pos\n                event_state = sol.y_events[0][0]\n                hit_side = 1\n            else:\n                event_time = t_e_neg\n                event_state = sol.y_events[1][0]\n                hit_side = -1\n\n            event_velocity = event_state[1]\n            results.append([event_occurred, event_time, event_velocity, hit_side])\n            \n        else:  # Integration finished without event\n            results.append([False, -1.0, 0.0, 0])\n\n    # Format the final output string exactly as specified in the problem description,\n    # without extraneous spaces.\n    output_parts = []\n    for res_list in results:\n        # Convert boolean to lowercase 'true'/'false' if needed by a stricter parser,\n        # but standard str() is 'True'/'False' which is fine for Python eval.\n        # Problem example uses 'True'/'False', so str() is correct.\n        part = '[' + ','.join(map(str, res_list)) + ']'\n        output_parts.append(part)\n\n    final_output_string = '[' + ','.join(output_parts) + ']'\n    print(final_output_string)\n\nsolve()\n```", "id": "2390610"}, {"introduction": "Many physical phenomena are not purely continuous; they involve discrete events that instantaneously alter the system's state. This final practice [@problem_id:2390644] introduces a powerful technique for modeling these \"hybrid systems\" by simulating a bouncing ball on a moving platform. Here, detecting the impact event allows us not only to stop the integration but also to apply a physical law—the coefficient of restitution—to reset the ball's velocity before seamlessly continuing the simulation, enabling the study of complex, multi-stage dynamics.", "problem": "You are asked to implement event detection in ordinary differential equation integration for a one-dimensional bouncing ball over an oscillating platform. The vertical position of the ball is modeled by the second-order ordinary differential equation derived from Newton’s Second Law for motion under gravity. The platform moves vertically according to a prescribed kinematic function. An impact event occurs at the instant when the height of the ball equals the height of the platform while the ball approaches the platform from above. Upon impact, the ball’s velocity changes according to the definition of the coefficient of restitution. Your task is to detect all such events within a finite time interval and update the ball’s velocity at each impact consistently with the collision law. The final outputs must be computed for a small set of specified test cases.\n\nUse the following fundamental base:\n- Newton’s Second Law for vertical motion under uniform gravity: the vertical position $y(t)$ and vertical velocity $v(t)$ of the ball obey $\\dot{y}(t) = v(t)$ and $\\dot{v}(t) = -g$, where $g$ is the gravitational acceleration.\n- The platform height is $y_{p}(t)$, a known function of time. The platform velocity is $v_{p}(t) = \\dot{y}_{p}(t)$.\n- The coefficient of restitution $e \\in [0,1]$ is defined as the ratio of the magnitude of the post-impact relative normal speed to the pre-impact relative normal speed.\n\nMathematical setup:\n- State vector: $\\mathbf{x}(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$ governed by\n$$\n\\dot{\\mathbf{x}}(t) = \\begin{bmatrix} v(t) \\\\ -g \\end{bmatrix}.\n$$\n- Platform motion: $y_{p}(t) = A \\sin(\\omega t)$ with $\\omega = 2\\pi f$, where $A$ is the oscillation amplitude and $f$ is the frequency. The platform velocity is $v_{p}(t) = A \\omega \\cos(\\omega t)$.\n- Event definition: an event occurs at times $t$ such that $y(t) = y_{p}(t)$ while the ball is approaching the platform from above. An event must be detected through a zero of a scalar function, and your detection must enforce the approach direction to avoid spurious contacts.\n- Impact update: if an event occurs at time $t_{\\mathrm{imp}}$, let $v^{-}$ be the ball velocity just before impact and $v^{+}$ the velocity just after. Let $v_{p}$ be the platform velocity at the same instant. Use the coefficient of restitution definition to update $v^{+}$ from $v^{-}$ and $v_{p}$.\n- Sticking criterion: to avoid numerical chattering when the post-impact relative speed is negligible, treat the ball as “sticking” to the platform if $|v^{+} - v_{p}|$ falls below a small tolerance $\\varepsilon_{v}$. In this case, for the remainder of the simulation, the ball moves with the platform, i.e., $y(t) = y_{p}(t)$.\n\nNumerical instructions:\n- Use an event-capable adaptive ordinary differential equation integrator to advance the state from $t=0$ to $t=T$, repeatedly handling impacts when they occur. Ensure that event bracketing and directionality are configured to detect $y(t) - y_{p}(t)$ crossings only when decreasing through zero.\n- Use a small positive time offset after each handled impact to reinitialize the integrator away from the event surface.\n- Use relative and absolute tolerances small enough to reliably localize event times.\n\nOutputs:\nFor each test case, compute the following quantities:\n1. The total number of impact events $N$ detected in $t \\in [0,T]$ (integer).\n2. The time of the first impact $t_{\\mathrm{first}}$ in seconds if at least one impact occurs; otherwise report $-1.0$.\n3. The time of the last impact $t_{\\mathrm{last}}$ in seconds if at least one impact occurs; otherwise report $-1.0$.\n4. The final ball height $y(T)$ in meters at the end of the simulation.\n\nPhysical and numerical units and formatting:\n- All times must be reported in seconds, and all lengths in meters.\n- Report $t_{\\mathrm{first}}$, $t_{\\mathrm{last}}$, and $y(T)$ rounded to six decimal places.\n- The coefficient of restitution $e$ is dimensionless. The gravitational acceleration $g$ is in $\\mathrm{m}/\\mathrm{s}^2$. The oscillation amplitude $A$ is in meters, frequency $f$ in hertz, and angular frequency $\\omega$ in radians per second.\n\nTest suite:\nSimulate the following four cases, each specified as $(g, A, f, e, y_{0}, v_{0}, T)$ where $y_{0}$ and $v_{0}$ are the initial height (in meters) and vertical velocity (in meters per second) at $t=0$:\n\n- Case 1 (general oscillating platform): $(9.81, 0.10, 1.5, 0.8, 1.0, 0.0, 3.0)$.\n- Case 2 (boundary: initial contact with downward approach): $(9.81, 0.05, 2.0, 0.9, 0.0, -1.0, 1.0)$.\n- Case 3 (edge: no collision within the horizon): $(9.81, 0.05, 1.0, 0.8, -0.5, 2.0, 0.5)$.\n- Case 4 (edge: completely inelastic on a static floor): $(9.81, 0.0, 0.0, 0.0, 1.0, 0.0, 2.0)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list of four sublists, each sublist in the order $[N, t_{\\mathrm{first}}, t_{\\mathrm{last}}, y(T)]$ and with floating-point values rounded to six decimals. For example, the output must look like:\n\"[ [N1,tfirst1,tlast1,yT1], [N2,tfirst2,tlast2,yT2], [N3,tfirst3,tlast3,yT3], [N4,tfirst4,tlast4,yT4] ]\" but without extra spaces except those required by list delimiters.", "solution": "The problem statement has been analyzed and is determined to be valid. It constitutes a well-posed problem in computational physics, based on fundamental principles of classical mechanics. The objectives are clearly defined, and the provided data are sufficient and consistent for constructing a numerical solution. The task is to simulate the one-dimensional motion of a ball under gravity, subject to collisions with an oscillating platform, and to report specific metrics of this motion.\n\nThe approach involves the numerical integration of the governing ordinary differential equations (ODEs), coupled with an event detection mechanism to handle the discrete impacts. The solution is constructed methodologically, beginning with the physical model and proceeding to the numerical algorithm.\n\nThe state of the ball at any time $t$ is described by its vertical position $y(t)$ and velocity $v(t)$. The state vector is $\\mathbf{x}(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$. According to Newton's Second Law for a body in a uniform gravitational field, the equations of motion are:\n$$\n\\dot{\\mathbf{x}}(t) = \\frac{d\\mathbf{x}}{dt} = \\begin{bmatrix} v(t) \\\\ -g \\end{bmatrix}\n$$\nwhere $g$ is the acceleration due to gravity. This is a system of first-order ODEs.\n\nThe platform's motion is prescribed as a sinusoidal function of time:\n$$\ny_{p}(t) = A \\sin(\\omega t)\n$$\nwhere $A$ is the amplitude and $\\omega = 2\\pi f$ is the angular frequency. The platform's velocity is the time derivative of its position:\n$$\nv_{p}(t) = \\dot{y}_{p}(t) = A \\omega \\cos(\\omega t)\n$$\n\nAn impact event occurs when the ball makes contact with the platform. The problem specifies two conditions for a valid impact:\n$1$. The position of the ball equals the position of the platform: $y(t) = y_{p}(t)$.\n$2$. The ball is approaching the platform from above. This implies that the relative velocity, $v(t) - v_{p}(t)$, is negative just before impact.\n\nThese conditions are captured by a scalar event function, $E(t, \\mathbf{x}(t)) = y(t) - y_{p}(t)$. An impact corresponds to a root of this function, $E(t, \\mathbf{x}(t))=0$. The approach direction condition means that the event must be detected only when the function $E(t, \\mathbf{x}(t))$ is decreasing through zero.\n\nThe numerical integration of the ODE system is performed using an adaptive step-size integrator, specifically the `solve_ivp` function from the SciPy library, which is well-suited for this class of problem due to its built-in event detection capabilities. The simulation proceeds in a loop. In each step of the loop, the integrator advances the solution from the current time $t_{current}$ until either the final time $T$ is reached or an event is detected.\n\nIf an event is detected at time $t_{\\mathrm{imp}}$, the integration is stopped. The state of the ball just before impact, $\\mathbf{x}^{-}(t_{\\mathrm{imp}}) = \\begin{bmatrix} y(t_{\\mathrm{imp}}) \\\\ v^{-}(t_{\\mathrm{imp}}) \\end{bmatrix}$, is obtained. The ball's velocity is then instantaneously updated according to the law of restitution. The coefficient of restitution $e$ is defined by:\n$$\nv_{\\mathrm{rel, post}} = -e \\cdot v_{\\mathrm{rel, pre}}\n$$\nwhere $v_{\\mathrm{rel, pre}} = v^{-} - v_{p}$ and $v_{\\mathrm{rel, post}} = v^{+} - v_{p}$ are the relative velocities before and after impact, respectively. Here, $v_{p}$ is the platform velocity at $t_{\\mathrm{imp}}$, and $v^{+}$ is the ball's velocity just after impact. This yields the update rule for the ball's velocity:\n$$\nv^{+} = v_{p}(t_{\\mathrm{imp}}) - e \\left( v^{-} - v_{p}(t_{\\mathrm{imp}}) \\right)\n$$\nThe position of the ball remains continuous through the impact, $y^{+}(t_{\\mathrm{imp}}) = y^{-}(t_{\\mathrm{imp}})$.\n\nAfter the velocity update, a check for \"sticking\" is performed. If the post-impact relative speed $|v^{+} - v_{p}(t_{\\mathrm{imp}})|$ is below a small numerical tolerance $\\varepsilon_{v}$, the ball is considered to have stuck to the platform. In this case, the simulation of ballistic motion is terminated. For all subsequent times $t > t_{\\mathrm{imp}}$, the ball's trajectory is kinematically determined by the platform's motion, $y(t) = y_{p}(t)$. The final height at time $T$ is then simply $y(T) = y_p(T)$.\n\nIf the ball does not stick, the integrator is reinitialized with the new state $\\mathbf{x}^{+}(t_{\\mathrm{imp}}) = \\begin{bmatrix} y(t_{\\mathrm{imp}}) \\\\ v^{+} \\end{bmatrix}$, and the time is advanced by a small offset from $t_{\\mathrm{imp}}$ to prevent the event from being detected again immediately. The integration loop then continues.\n\nThis process is repeated until the simulation time $t$ reaches the final time $T$. Special care is taken for the boundary case where an impact occurs at the initial time $t=0$, by performing an impact-update calculation before starting the main integration loop.\n\nThe required outputs—the total number of impacts $N$, the times of the first and last impacts ($t_{\\mathrm{first}}$, $t_{\\mathrm{last}}$), and the final ball height $y(T)$—are collected during this process. If no impacts occur, $N$ is $0$, and $t_{\\mathrm{first}}$ and $t_{\\mathrm{last}}$ are reported as $-1.0$. The numerical tolerances for the ODE solver (`rtol`, `atol`) are set to a small value, $10^{-12}$, to ensure high accuracy in both the trajectory and the event time localization. The sticking tolerance $\\varepsilon_v$ is set to $10^{-8}$.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    def run_simulation(g, A, f, e, y0, v0, T):\n        \"\"\"\n        Solves the bouncing ball problem for a single set of parameters.\n        \"\"\"\n        omega = 2.0 * np.pi * f\n        sticking_tolerance = 1e-8\n        time_offset = 1e-12\n\n        # Define platform kinematics\n        def platform_pos(t):\n            if A == 0.0:\n                return 0.0\n            return A * np.sin(omega * t)\n\n        def platform_vel(t):\n            if A == 0.0:\n                return 0.0\n            return A * omega * np.cos(omega * t)\n\n        # Define ODE system for the ball\n        def dynamics(t, state):\n            # state = [y, v]\n            return [state[1], -g]\n\n        # Define event function for impact detection\n        def impact_event(t, state):\n            # Event function is zero when ball height equals platform height\n            return state[0] - platform_pos(t)\n        \n        impact_event.terminal = True  # Stop integration at event\n        impact_event.direction = -1   # Trigger only when function is decreasing\n\n        # Initialize simulation variables\n        t_current = 0.0\n        state_current = np.array([y0, v0], dtype=float)\n        impact_times = []\n        is_sticking = False\n\n        # Handle potential impact at t=0, which solve_ivp might ignore.\n        # Check if positions match and relative velocity is negative.\n        if np.isclose(state_current[0], platform_pos(0.0)):\n            v_rel_initial = state_current[1] - platform_vel(0.0)\n            if v_rel_initial  0:\n                impact_times.append(0.0)\n                v_minus = state_current[1]\n                v_p = platform_vel(0.0)\n                v_plus = v_p - e * (v_minus - v_p)\n                \n                if abs(v_plus - v_p)  sticking_tolerance:\n                    is_sticking = True\n                    t_current = 0.0\n                else:\n                    state_current[1] = v_plus\n                    t_current += time_offset\n\n        # Main simulation loop\n        while t_current  T and not is_sticking:\n            sol = solve_ivp(\n                dynamics,\n                (t_current, T),\n                state_current,\n                events=impact_event,\n                dense_output=True,\n                rtol=1e-12,\n                atol=1e-12\n            )\n            \n            t_current = sol.t[-1]\n            state_current = sol.y[:, -1]\n\n            # Check if an event was found\n            if sol.status == 1 and sol.t_events[0].size > 0:\n                t_event = sol.t_events[0][0]\n                impact_times.append(t_event)\n                \n                # State right before impact\n                state_at_event = sol.sol(t_event)\n                v_minus = state_at_event[1]\n                v_p = platform_vel(t_event)\n                \n                # Apply restitution law\n                v_plus = v_p - e * (v_minus - v_p)\n                \n                # Check for sticking\n                if abs(v_plus - v_p)  sticking_tolerance:\n                    is_sticking = True\n                    t_current = t_event # Set time for final height calculation\n                    break\n                \n                # Re-initialize state for next integration segment\n                t_current = t_event + time_offset\n                state_current[0] = state_at_event[0]\n                state_current[1] = v_plus\n                \n                if t_current >= T:\n                    break\n        \n        # Calculate final reported values\n        N = len(impact_times)\n        t_first = -1.0 if N == 0 else impact_times[0]\n        t_last = -1.0 if N == 0 else impact_times[-1]\n        \n        if is_sticking:\n            y_final = platform_pos(T)\n        else:\n            y_final = state_current[0]\n\n        return [\n            N,\n            round(t_first, 6),\n            round(t_last, 6),\n            round(y_final, 6)\n        ]\n\n    test_cases = [\n        (9.81, 0.10, 1.5, 0.8, 1.0, 0.0, 3.0),\n        (9.81, 0.05, 2.0, 0.9, 0.0, -1.0, 1.0),\n        (9.81, 0.05, 1.0, 0.8, -0.5, 2.0, 0.5),\n        (9.81, 0.0, 0.0, 0.0, 1.0, 0.0, 2.0)\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n    \n    # Format the final output string exactly as required, with no extra spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2390644"}]}