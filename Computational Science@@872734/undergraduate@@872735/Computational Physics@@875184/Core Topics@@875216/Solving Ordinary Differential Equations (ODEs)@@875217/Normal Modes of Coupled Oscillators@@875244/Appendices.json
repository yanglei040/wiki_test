{"hands_on_practices": [{"introduction": "Our journey into the hands-on practice of normal modes begins with the quintessential model: the one-dimensional chain of masses and springs. This first exercise [@problem_id:2418616] challenges you to move beyond the textbook case of fixed- or free-ends and consider a 'soft' boundary condition. By translating the physical laws of this system into a matrix eigenvalue problem, you will develop the foundational skill of constructing the dynamical matrix, which is the heart of any normal mode analysis.", "problem": "Consider a one-dimensional chain of $N$ identical point masses of mass $m$ connected by linear springs of stiffness $k$. The left end of the chain is attached to a fixed wall by a spring of stiffness $k$, and the right end is attached to a fixed wall by a spring of stiffness $k_{\\text{end}}$. All springs obey Hooke’s law and there is no damping. Let $x_i(t)$ denote the displacement of the $i$-th mass from its equilibrium position along the line, where $i \\in \\{1,2,\\dots,N\\}$ and $t$ is time.\n\nUsing only the fundamental laws of mechanics, determine the smallest positive normal-mode angular frequency $\\omega_1$ (in radians per second) of small oscillations for the chain described above, for each parameter set in the test suite below. Express each $\\omega_1$ in radians per second, rounded to six decimal places.\n\nTest suite (each item is $(N, m, k, k_{\\text{end}})$ with $m$ in kilograms, $k$ and $k_{\\text{end}}$ in newtons per meter):\n- $(5,\\, 0.20,\\, 50.0,\\, 50.0)$\n- $(5,\\, 0.20,\\, 50.0,\\, 10^{-3})$\n- $(5,\\, 0.20,\\, 50.0,\\, 10^{6})$\n- $(1,\\, 1.0,\\, 100.0,\\, 100.0)$\n- $(2,\\, 1.0,\\, 10.0,\\, 0.0)$\n\nFinal output format requirement:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite, for example, \"[r1,r2,r3,r4,r5]\". Each $r_j$ must be the float representation of $\\omega_1$ for the $j$-th test case, rounded to six decimal places, in radians per second.", "solution": "The problem requires the determination of the lowest normal-mode angular frequency for a one-dimensional chain of coupled oscillators. The analysis proceeds from first principles of classical mechanics.\n\nThe system consists of $N$ point masses, each of mass $m$. Let $x_i(t)$ be the displacement of the $i$-th mass from its equilibrium position, where $i \\in \\{1, 2, \\dots, N\\}$. The masses are connected and attached to fixed walls by massless springs obeying Hooke's Law.\n\nThe cornerstone of the derivation is Newton's Second Law, $F_i = m \\ddot{x}_i$, applied to each mass. The force $F_i$ is the net force exerted by the springs attached to the $i$-th mass.\n\nWe must consider three distinct cases for the equations of motion: the first mass ($i=1$), an interior mass ($1 < i < N$), and the last mass ($i=N$).\n\nFor an interior mass $i$, where $1 < i < N$, it is connected to mass $i-1$ and mass $i+1$ by springs of stiffness $k$. The force from the left spring is $k(x_{i-1} - x_i)$ and the force from the right spring is $k(x_{i+1} - x_i)$. The total force is:\n$$F_i = k(x_{i-1} - x_i) + k(x_{i+1} - x_i) = k(x_{i-1} - 2x_i + x_{i+1})$$\nThe equation of motion is therefore:\n$$m \\ddot{x}_i = k(x_{i-1} - 2x_i + x_{i+1})$$\n\nFor the first mass, $i=1$, it is connected to a fixed wall ($x_0 = 0$) by a spring of stiffness $k$ and to mass $2$ by another spring of stiffness $k$. The force from the left spring is $k(x_0 - x_1) = -kx_1$. The force from the right spring is $k(x_2 - x_1)$. The total force is:\n$$F_1 = -kx_1 + k(x_2 - x_1) = kx_2 - 2kx_1$$\nThe equation of motion for the first mass is:\n$$m \\ddot{x}_1 = k(x_2 - 2x_1)$$\n\nFor the last mass, $i=N$, it is connected to mass $N-1$ by a spring of stiffness $k$ and to a fixed wall ($x_{N+1} = 0$) by a spring of stiffness $k_{\\text{end}}$. The force from the left spring is $k(x_{N-1} - x_N)$. The force from the right spring is $k_{\\text{end}}(x_{N+1} - x_N) = -k_{\\text{end}}x_N$. The total force is:\n$$F_N = k(x_{N-1} - x_N) - k_{\\text{end}}x_N = kx_{N-1} - (k + k_{\\text{end}})x_N$$\nThe equation of motion for the last mass is:\n$$m \\ddot{x}_N = kx_{N-1} - (k + k_{\\text{end}})x_N$$\n\nTo find the normal modes, we assume a solution where all masses oscillate with the same angular frequency $\\omega$. We express the displacements in complex form as $x_i(t) = A_i e^{i\\omega t}$, where $A_i$ is the complex amplitude of the $i$-th mass. The second time derivative is $\\ddot{x}_i(t) = -\\omega^2 A_i e^{i\\omega t} = -\\omega^2 x_i(t)$. Substituting this into the equations of motion and cancelling the common factor $e^{i\\omega t}$ yields a system of linear algebraic equations for the amplitudes $A_i$:\n$$-m\\omega^2 A_1 = kA_2 - 2kA_1$$\n$$-m\\omega^2 A_i = k(A_{i-1} - 2A_i + A_{i+1}) \\quad \\text{for } 1 < i < N$$\n$$-m\\omega^2 A_N = kA_{N-1} - (k + k_{\\text{end}})A_N$$\n\nThese equations can be rearranged and expressed in matrix form. Let $\\mathbf{A}$ be the column vector of amplitudes, $[A_1, A_2, \\dots, A_N]^T$. The system of equations is equivalent to the eigenvalue problem $\\mathbf{K}\\mathbf{A} = m\\omega^2\\mathbf{A}$, where $\\mathbf{K}$ is the $N \\times N$ stiffness matrix. This is a generalized eigenvalue problem, which simplifies to a standard one:\n$$\\frac{1}{m}\\mathbf{K}\\mathbf{A} = \\omega^2\\mathbf{A}$$\nThe matrix $\\mathbf{C} = \\frac{1}{m}\\mathbf{K}$ is the dynamical matrix. Its eigenvalues $\\lambda_j = \\omega_j^2$ are the squares of the normal-mode angular frequencies.\n\nThe stiffness matrix $\\mathbf{K}$ is a real, symmetric, tridiagonal matrix constructed from the coefficients of the amplitudes $A_i$ in the force equations:\n$$\n\\mathbf{K} =\n\\begin{pmatrix}\n2k & -k & 0 & \\dots & 0 \\\\\n-k & 2k & -k & \\dots & 0 \\\\\n0 & -k & 2k & \\ddots & \\vdots \\\\\n\\vdots & \\vdots & \\ddots & 2k & -k \\\\\n0 & 0 & \\dots & -k & k+k_{\\text{end}}\n\\end{pmatrix}\n$$\nThe potential energy of the system, $U = \\frac{1}{2}\\mathbf{x}^T\\mathbf{K}\\mathbf{x} = \\frac{1}{2} k x_1^2 + \\frac{1}{2} k \\sum_{i=1}^{N-1} (x_{i+1}-x_i)^2 + \\frac{1}{2} k_{\\text{end}} x_N^2$, is positive for any non-zero displacement vector provided $k > 0$. Therefore, the matrix $\\mathbf{K}$ is positive definite, and all its eigenvalues $\\omega_j^2$ are strictly positive.\n\nThe problem is thus reduced to a computational task: for each set of parameters $(N, m, k, k_{\\text{end}})$, construct the matrix $\\mathbf{C} = \\frac{1}{m}\\mathbf{K}$ and compute its eigenvalues. The smallest positive normal-mode angular frequency $\\omega_1$ is the square root of the smallest eigenvalue, $\\lambda_{\\text{min}}$.\n$$\\omega_1 = \\sqrt{\\lambda_{\\text{min}}}$$\n\nThe solution is found by implementing this procedure. For a given $N$, we construct the $N \\times N$ matrix $\\mathbf{K}$ with diagonal elements $K_{ii} = 2k$ for $i < N$ and $K_{NN} = k + k_{\\text{end}}$, and off-diagonal elements $K_{i, i+1} = K_{i+1, i} = -k$. Then, we find the eigenvalues of $\\mathbf{C} = \\frac{1}{m}\\mathbf{K}$. Since $\\mathbf{C}$ is real and symmetric, its eigenvalues are real and can be computed efficiently. The smallest of these eigenvalues gives the required frequency $\\omega_1$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the smallest positive normal-mode angular frequency for a 1D chain of\n    masses and springs with specified boundary conditions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, m, k, k_end)\n    test_cases = [\n        (5, 0.20, 50.0, 50.0),\n        (5, 0.20, 50.0, 1e-3),\n        (5, 0.20, 50.0, 1e6),\n        (1, 1.0, 100.0, 100.0),\n        (2, 1.0, 10.0, 0.0),\n    ]\n\n    results = []\n    for N, m, k, k_end in test_cases:\n        # The problem reduces to solving the eigenvalue problem (1/m)K * A = omega^2 * A,\n        # where K is the stiffness matrix. The eigenvalues are the squared angular frequencies.\n        # We construct the dynamical matrix C = (1/m)K and find its eigenvalues.\n\n        # The stiffness matrix K is a real, symmetric, tridiagonal NxN matrix.\n        if N == 1:\n            # For N=1, the matrix K is a 1x1 matrix with element k + k_end.\n            main_diag = np.array([k + k_end])\n            K = np.diag(main_diag)\n        else:\n            # For N > 1, construct the tridiagonal matrix K.\n            # Main diagonal elements: 2k for the first N-1 masses.\n            main_diag = np.full(N, 2 * k)\n            # The last mass has a different diagonal term.\n            main_diag[N - 1] = k + k_end\n            \n            # Off-diagonal elements: -k for connections between masses.\n            off_diag = np.full(N - 1, -k)\n            \n            # Construct K using numpy.diag.\n            K = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n\n        # The dynamical matrix C.\n        C = (1 / m) * K\n\n        # Find the eigenvalues of the real symmetric matrix C.\n        # numpy.linalg.eigvalsh is efficient for this and returns eigenvalues\n        # sorted in ascending order.\n        eigenvalues = np.linalg.eigvalsh(C)\n        \n        # The smallest eigenvalue is the first element of the sorted array.\n        # For a stable system with k > 0, all eigenvalues are positive.\n        lambda_min = eigenvalues[0]\n        \n        # The smallest normal mode angular frequency is the square root of the smallest eigenvalue.\n        omega_1 = np.sqrt(lambda_min)\n        \n        results.append(round(omega_1, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2418616"}, {"introduction": "Having mastered the one-dimensional chain, we now extend our analysis to a more complex, three-dimensional structure. This practice [@problem_id:2418576] involves a pyramidal arrangement of masses, requiring a careful application of vector mechanics to construct the stiffness matrix. This exercise will solidify your understanding of how to build the governing equations for any arbitrary geometry, a crucial step toward modeling real-world molecular or mechanical systems.", "problem": "You are to model the small-amplitude vibrational normal modes of a three-dimensional square pyramid formed by point masses connected by linear springs. There are five ($5$) point masses placed at the vertices of a square base and a single apex above the center of the square. Let the base be a square of side length $\\ell$ lying in the plane $z=0$ and centered at the origin. The base vertices are at positions $\\left(-\\frac{\\ell}{2},-\\frac{\\ell}{2},0\\right)$, $\\left(\\frac{\\ell}{2},-\\frac{\\ell}{2},0\\right)$, $\\left(\\frac{\\ell}{2},\\frac{\\ell}{2},0\\right)$, and $\\left(-\\frac{\\ell}{2},\\frac{\\ell}{2},0\\right)$. The apex is located at $\\left(0,0,h\\right)$, where $h$ is the height in meters.\n\nEach of the four ($4$) base vertices has mass $m_{\\mathrm{base}}$ (in kilograms), and the apex has mass $m_{\\mathrm{apex}}$ (in kilograms). Springs connect the masses as follows: each pair of adjacent base vertices is connected (four base edges), the two opposite base vertices are connected by the two base diagonals, and each base vertex is connected to the apex (four side edges). The spring stiffnesses (in newtons per meter) may be distinct for the base edges ($k_{\\mathrm{base}}$), side edges ($k_{\\mathrm{side}}$), and base diagonals ($k_{\\mathrm{diag}}$). Assume all springs are at their rest lengths in the reference geometry defined above, and neglect gravity.\n\nUnder the small oscillation approximation, treat each mass as a point mass moving in three spatial dimensions with small displacements. Construct the mass matrix and the stiffness matrix implied by this network and compute the angular frequencies of the vibrational normal modes by solving the generalized eigenvalue problem. Discard the rigid-body modes with zero angular frequency and report the smallest nine ($9$) strictly positive angular frequencies $\\omega$ (in radians per second) in ascending order for each parameter set below.\n\nAll outputs must be expressed in radians per second and rounded to six ($6$) decimal places.\n\nUse the following test suite of parameter sets. Each set is given in the order $\\left[\\ell\\ \\mathrm{(m)},\\ h\\ \\mathrm{(m)},\\ m_{\\mathrm{base}}\\ \\mathrm{(kg)},\\ m_{\\mathrm{apex}}\\ \\mathrm{(kg)},\\ k_{\\mathrm{base}}\\ \\mathrm{(N/m)},\\ k_{\\mathrm{side}}\\ \\mathrm{(N/m)},\\ k_{\\mathrm{diag}}\\ \\mathrm{(N/m)}\\right]$:\n- Test $1$: $\\left[1.0,\\ 1.0,\\ 1.0,\\ 1.0,\\ 100.0,\\ 100.0,\\ 100.0\\right]$.\n- Test $2$: $\\left[1.0,\\ 1.0,\\ 1.0,\\ 3.0,\\ 100.0,\\ 100.0,\\ 100.0\\right]$.\n- Test $3$: $\\left[1.0,\\ 0.7,\\ 1.5,\\ 1.0,\\ 300.0,\\ 100.0,\\ 300.0\\right]$.\n- Test $4$: $\\left[1.0,\\ 2.0,\\ 2.0,\\ 0.5,\\ 200.0,\\ 200.0,\\ 200.0\\right]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of the nine ($9$) ascending positive angular frequencies rounded to six ($6$) decimal places. For example, the output format must be:\n\"[ [w1_1,w1_2,...,w1_9],[w2_1,...,w2_9],[w3_1,...,w3_9],[w4_1,...,w4_9] ]\" with no additional text.", "solution": "The problem statement is subjected to validation and is found to be valid. It presents a well-posed problem in classical mechanics, specifically the study of small oscillations in a system of coupled masses. All parameters are provided, the physical model is standard, and the objective is clear and scientifically grounded. We may proceed with the solution.\n\nThe system consists of $N=5$ point masses, whose small displacements from their equilibrium positions are described. Each mass has three translational degrees of freedom, so the configuration of the system is described by a generalized coordinate vector $\\mathbf{q}$ of dimension $3N = 15$. We can write $\\mathbf{q}$ as the concatenation of the displacement vectors $\\mathbf{u}_i = (u_{ix}, u_{iy}, u_{iz})$ for each mass $i=1, \\dots, 5$:\n$$\n\\mathbf{q} = [u_{1x}, u_{1y}, u_{1z}, u_{2x}, u_{2y}, u_{2z}, \\dots, u_{5x}, u_{5y}, u_{5z}]^T\n$$\n\nIn the small oscillations approximation, the kinetic energy $T$ and potential energy $V$ of the system can be expressed as quadratic forms of the generalized velocities $\\dot{\\mathbf{q}}$ and displacements $\\mathbf{q}$, respectively.\nThe kinetic energy is given by:\n$$\nT = \\frac{1}{2} \\sum_{i=1}^{5} m_i ||\\dot{\\mathbf{u}}_i||^2 = \\frac{1}{2} \\dot{\\mathbf{q}}^T M \\dot{\\mathbf{q}}\n$$\nHere, $M$ is the mass matrix. For this system of point masses, $M$ is a $15 \\times 15$ diagonal matrix. The diagonal entries corresponding to the degrees of freedom of the four base masses are $m_{\\mathrm{base}}$, and those for the apex mass are $m_{\\mathrm{apex}}$.\n$$\nM = \\mathrm{diag}( m_{\\mathrm{base}}, m_{\\mathrm{base}}, m_{\\mathrm{base}}, \\dots, m_{\\mathrm{base}}, m_{\\mathrm{apex}}, m_{\\mathrm{apex}}, m_{\\mathrm{apex}} )\n$$\n\nThe potential energy $V$ is stored in the springs. Since the springs are at their rest lengths in the equilibrium configuration, the potential energy is zero at equilibrium. For small displacements, the change in potential energy is approximately:\n$$\nV \\approx \\frac{1}{2} \\mathbf{q}^T K \\mathbf{q}\n$$\nwhere $K$ is the $15 \\times 15$ stiffness matrix. The matrix $K$ is constructed by summing the contributions from each spring in the system. Consider a single spring with stiffness $k_{ij}$ connecting masses $i$ and $j$ at equilibrium positions $\\mathbf{r}_i^0$ and $\\mathbf{r}_j^0$. The initial length of the spring is $L_{ij}^0 = ||\\mathbf{r}_j^0 - \\mathbf{r}_i^0||$, and the unit vector along it is $\\hat{\\mathbf{n}}_{ij} = (\\mathbf{r}_j^0 - \\mathbf{r}_i^0) / L_{ij}^0$. For small displacements $\\mathbf{u}_i$ and $\\mathbf{u}_j$, the change in spring length $\\Delta L_{ij}$ is the projection of the relative displacement vector onto the spring's direction:\n$$\n\\Delta L_{ij} \\approx (\\mathbf{u}_j - \\mathbf{u}_i) \\cdot \\hat{\\mathbf{n}}_{ij}\n$$\nThe potential energy stored in this spring is $V_{ij} = \\frac{1}{2} k_{ij} (\\Delta L_{ij})^2$. Summing over all springs gives the total potential energy $V = \\sum_{\\text{springs}} V_{ij}$. This quadratic form defines the stiffness matrix $K$.\n\nA practical method to construct $K$ is to consider the contribution of each spring individually. For a spring between masses $i$ and $j$, its contribution to the global stiffness matrix can be expressed in terms of a $3 \\times 3$ matrix $K_{ij}^{\\text{block}} = k_{ij} (\\hat{\\mathbf{n}}_{ij} \\otimes \\hat{\\mathbf{n}}_{ij}) = k_{ij} \\hat{\\mathbf{n}}_{ij} \\hat{\\mathbf{n}}_{ij}^T$. The global stiffness matrix $K$ is populated by adding and subtracting this block as follows, where $K_{ab}$ denotes the $3 \\times 3$ submatrix of $K$ that couples mass $a$ with mass $b$:\n$$\n\\begin{cases}\nK_{ii} \\mathrel{+}= K_{ij}^{\\text{block}} \\\\\nK_{jj} \\mathrel{+}= K_{ij}^{\\text{block}} \\\\\nK_{ij} \\mathrel{-}= K_{ij}^{\\text{block}} \\\\\nK_{ji} \\mathrel{-}= K_{ij}^{\\text{block}}\n\\end{cases}\n$$\nThis procedure is repeated and summed for all springs in the network, yielding the complete symmetric, positive semi-definite matrix $K$.\n\nThe Lagrangian of the system is $L = T - V$. The Euler-Lagrange equations, $\\frac{d}{dt} \\frac{\\partial L}{\\partial \\dot{q}_k} - \\frac{\\partial L}{\\partial q_k} = 0$, lead to the system of second-order linear differential equations:\n$$\nM \\ddot{\\mathbf{q}} + K \\mathbf{q} = \\mathbf{0}\n$$\nTo find the normal modes, we seek solutions of the form $\\mathbf{q}(t) = \\mathbf{a} e^{i\\omega t}$, where $\\mathbf{a}$ is a constant amplitude vector and $\\omega$ is the angular frequency. Substituting this into the equation of motion gives:\n$$\n(-\\omega^2 M \\mathbf{a} + K \\mathbf{a}) e^{i\\omega t} = \\mathbf{0}\n$$\nThis must hold for all $t$, which leads to the generalized eigenvalue problem:\n$$\nK \\mathbf{a} = \\omega^2 M \\mathbf{a}\n$$\nThe eigenvalues of this problem are $\\lambda_k = \\omega_k^2$, and the eigenvectors $\\mathbf{a}_k$ are the normal mode vectors. For a $3D$ system of $N$ free masses, there are $3N$ modes in total. Six of these are rigid-body modes (3 translations and 3 rotations) with $\\omega = 0$. The remaining $3N-6$ modes are vibrational modes with strictly positive frequencies. For this problem with $N=5$, we expect $15 - 6 = 9$ vibrational modes.\n\nThe computational strategy is as follows:\n1.  Define the equilibrium positions of the $5$ masses based on the parameters $\\ell$ and $h$.\n2.  Construct the diagonal $15 \\times 15$ mass matrix $M$.\n3.  Initialize a $15 \\times 15$ zero matrix for $K$.\n4.  Iterate through all $10$ springs. For each spring, calculate its unit direction vector $\\hat{\\mathbf{n}}_{ij}$ and stiffness $k_{ij}$. Compute the $3 \\times 3$ block matrix $K_{ij}^{\\text{block}}$ and update the corresponding submatrices of $K$.\n5.  Solve the generalized eigenvalue problem $K \\mathbf{a} = \\lambda M \\mathbf{a}$ to find the eigenvalues $\\lambda_k$.\n6.  Calculate the angular frequencies $\\omega_k = \\sqrt{\\lambda_k}$. Due to numerical precision, eigenvalues for rigid-body modes may be small non-zero numbers, so a tolerance is used to identify them.\n7.  Collect the $9$ strictly positive frequencies, sort them in ascending order, and round to the required precision. This procedure is repeated for each parameter set provided.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves for the vibrational normal modes of a square pyramid system\n    for a given set of test cases.\n    \"\"\"\n    test_cases = [\n        (1.0, 1.0, 1.0, 1.0, 100.0, 100.0, 100.0), # Test 1\n        (1.0, 1.0, 1.0, 3.0, 100.0, 100.0, 100.0), # Test 2\n        (1.0, 0.7, 1.5, 1.0, 300.0, 100.0, 300.0), # Test 3\n        (1.0, 2.0, 2.0, 0.5, 200.0, 200.0, 200.0), # Test 4\n    ]\n\n    results = []\n    for params in test_cases:\n        freqs = calculate_frequencies(*params)\n        results.append(freqs)\n\n    # Format the final output string precisely as specified.\n    case_strings = []\n    for case_res in results:\n        # Round final results to 6 decimal places and format as a string\n        num_strings = [f\"{val:.6f}\" for val in case_res]\n        case_strings.append(f\"[{','.join(num_strings)}]\")\n    \n    final_print_string = f\"[{','.join(case_strings)}]\"\n    print(final_print_string)\n\ndef calculate_frequencies(ell, h, m_base, m_apex, k_base, k_side, k_diag):\n    \"\"\"\n    Calculates the 9 smallest positive angular frequencies for the pyramid system.\n\n    Args:\n        ell (float): Side length of the square base.\n        h (float): Height of the apex.\n        m_base (float): Mass of each base vertex.\n        m_apex (float): Mass of the apex vertex.\n        k_base (float): Stiffness of base edge springs.\n        k_side (float): Stiffness of side edge springs.\n        k_diag (float): Stiffness of base diagonal springs.\n\n    Returns:\n        list: A list of the 9 smallest positive angular frequencies, sorted ascending.\n    \"\"\"\n    num_masses = 5\n    dim = 3\n    dof = num_masses * dim\n\n    # Define equilibrium positions of the 5 masses\n    # Masses 0-3 are base, Mass 4 is apex\n    l2 = ell / 2.0\n    positions = np.array([\n        [-l2, -l2, 0.0],\n        [ l2, -l2, 0.0],\n        [ l2,  l2, 0.0],\n        [-l2,  l2, 0.0],\n        [0.0, 0.0,   h]\n    ])\n\n    # Construct the Mass Matrix M (15x15)\n    mass_array = np.array([m_base] * 4 + [m_apex] * 1)\n    M = np.diag(np.repeat(mass_array, dim))\n\n    # Define spring connections: (mass_idx_1, mass_idx_2, stiffness)\n    connections = [\n        # Base edges\n        (0, 1, k_base), (1, 2, k_base), (2, 3, k_base), (3, 0, k_base),\n        # Base diagonals\n        (0, 2, k_diag), (1, 3, k_diag),\n        # Side edges\n        (0, 4, k_side), (1, 4, k_side), (2, 4, k_side), (3, 4, k_side)\n    ]\n\n    # Construct the Stiffness Matrix K (15x15)\n    K = np.zeros((dof, dof))\n    for i, j, k_spring in connections:\n        r_i = positions[i]\n        r_j = positions[j]\n        \n        vec = r_j - r_i\n        dist = np.linalg.norm(vec)\n        if dist  1e-9:\n            continue\n        \n        unit_vec = vec / dist\n        \n        # Calculate the 3x3 stiffness block for this spring\n        k_block = k_spring * np.outer(unit_vec, unit_vec)\n        \n        # Add contributions to the global stiffness matrix K\n        s_i = i * dim\n        s_j = j * dim\n        e_i = s_i + dim\n        e_j = s_j + dim\n        \n        K[s_i:e_i, s_i:e_i] += k_block\n        K[s_j:e_j, s_j:e_j] += k_block\n        K[s_i:e_i, s_j:e_j] -= k_block\n        K[s_j:e_j, s_i:e_i] -= k_block\n\n    # Solve the generalized eigenvalue problem: K*v = w^2*M*v\n    # eigh returns eigenvalues in ascending order.\n    eigenvalues, _ = eigh(K, M)\n\n    # Frequencies are sqrt of eigenvalues. Filter out small/negative values\n    # from numerical noise, which correspond to rigid-body modes.\n    # Take the smallest 9 positive frequencies.\n    tolerance = 1e-9\n    positive_eigenvalues = eigenvalues[eigenvalues > tolerance]\n    angular_frequencies = np.sqrt(positive_eigenvalues)\n    \n    # We expect 9 vibrational modes.\n    # Sort and take the first 9, just in case of numerical issues.\n    sorted_freqs = np.sort(angular_frequencies)\n    num_modes = dof - 6\n    \n    return [round(w, 6) for w in sorted_freqs[:num_modes]]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2418576"}, {"introduction": "The true power of computational physics lies in its ability to explore systems that defy simple analytical solutions. In this final practice [@problem_id:2418657], we introduce disorder into our one-dimensional chain, a feature ubiquitous in nature. You will investigate the profound phenomenon of Anderson localization, where waves can become trapped, and learn to quantify this effect using the inverse participation ratio (IPR), a standard tool in condensed matter physics.", "problem": "You are tasked with investigating mode localization in a one-dimensional disordered chain of coupled oscillators using computational methods. Consider a chain of $N$ identical point masses, each of mass $m$, connected in series by springs and attached at both ends to fixed walls. The spring connecting the left wall to mass $1$ has spring constant $k_0$, the spring connecting mass $i$ to mass $i+1$ has spring constant $k_i$ for $i=1,\\dots,N-1$, and the spring connecting mass $N$ to the right wall has spring constant $k_N$. All springs obey Hooke’s law. The spring constants are independently drawn from a uniform random distribution on the closed interval $\\left[k_{\\mathrm{avg}} - \\frac{w}{2},\\, k_{\\mathrm{avg}} + \\frac{w}{2}\\right]$, with the constraint that every realized spring constant must be positive. The chain endpoints are fixed (no displacement at the walls). No external forces act on the masses.\n\nStarting from Newton’s second law and Hooke’s law, derive the linearized equations governing small oscillations, reduce them to a matrix eigenvalue problem for the normal modes, and implement a program that constructs the dynamical matrix for given parameters, computes all normal modes numerically, and quantifies localization using the inverse participation ratio (IPR). For a normalized eigenvector $\\mathbf{v}=\\left(v_1,\\dots,v_N\\right)$ of the dynamical matrix, define the inverse participation ratio (IPR) as $I=\\sum_{i=1}^{N} v_i^4$. The IPR is dimensionless. Extended modes have $I$ on the order of $1/N$, while strongly localized modes have $I$ significantly larger.\n\nYour program must:\n1. For each specified parameter set, generate the disordered spring constants by independent sampling from the specified uniform distribution, using a fixed pseudorandom seed for reproducibility, and construct the corresponding dynamical matrix implied by Newton’s second law and Hooke’s law with fixed-wall boundary conditions.\n2. Compute all eigenvalues and normalized eigenvectors of the dynamical matrix. Interpret eigenvalues as squared angular frequencies in $\\text{rad}^2/\\text{s}^2$ if needed, but note that the requested outputs are dimensionless.\n3. For each realization, compute the IPR for every mode and then average the IPR over all modes and all realizations. Report this average IPR as a single floating-point number for the parameter set.\n4. Repeat steps for the entire test suite below and output all results aggregated as specified.\n\nUse the following test suite of parameter sets to ensure coverage of different regimes:\n- Test case A (ordered chain, edge case): $N=64$, $m=1\\,\\text{kg}$, $k_{\\mathrm{avg}}=1\\,\\text{N}\\,\\text{m}^{-1}$, $w=0$, number of realizations $R=1$, random seed $s=1234$. This case has no disorder and should produce a small average IPR on the order of $1/N$.\n- Test case B (moderate disorder): $N=64$, $m=1\\,\\text{kg}$, $k_{\\mathrm{avg}}=1\\,\\text{N}\\,\\text{m}^{-1}$, $w=0.6\\,\\text{N}\\,\\text{m}^{-1}$, $R=200$, $s=2024$.\n- Test case C (strong disorder): $N=64$, $m=1\\,\\text{kg}$, $k_{\\mathrm{avg}}=1\\,\\text{N}\\,\\text{m}^{-1}$, $w=1.8\\,\\text{N}\\,\\text{m}^{-1}$, $R=200$, $s=2024$.\n\nEnsure the uniform distribution bounds $\\left[k_{\\mathrm{avg}} - \\frac{w}{2},\\, k_{\\mathrm{avg}} + \\frac{w}{2}\\right]$ are strictly positive for all test cases. The IPR is dimensionless, and no unit conversion is required for the final outputs.\n\nFinal output format:\n- Your program should produce a single line of output containing the three average IPR values for test cases A, B, and C, respectively, as a comma-separated list enclosed in square brackets. Each value must be rounded to exactly six digits after the decimal point. For example: $\\left[\\text{value}_A,\\text{value}_B,\\text{value}_C\\right]$ printed as in the following format: \"[0.012345,0.067890,0.123456]\".", "solution": "The problem is subjected to validation and is determined to be valid. It is a well-posed, scientifically grounded problem in computational physics that is free from ambiguity and contradiction. We may thus proceed with the solution.\n\nThe core of the problem is to analyze the normal modes of a one-dimensional chain of coupled oscillators. We begin by deriving the equations of motion from first principles.\n\nLet the system consist of $N$ point masses, each of mass $m$. The masses are indexed from $i=1$ to $N$. Let $x_i(t)$ be the displacement of the $i$-th mass from its equilibrium position. The chain is connected to fixed walls at both ends, which implies boundary conditions $x_0(t) = 0$ and $x_{N+1}(t) = 0$ for all times $t$. The spring connecting the left wall to mass $1$ has spring constant $k_0$. The spring connecting mass $i$ to mass $i+1$ has spring constant $k_i$ for $i=1, \\dots, N-1$. The spring connecting mass $N$ to the right wall has spring constant $k_N$. There are a total of $N+1$ springs.\n\nAccording to Hooke's law, the force exerted by a spring is proportional to its extension. The net force on mass $i$ is the sum of forces from the spring on its left (with constant $k_{i-1}$) and the spring on its right (with constant $k_i$):\n$$F_i = F_{\\text{left}, i} + F_{\\text{right}, i} = k_{i-1}(x_{i-1} - x_i) + k_i(x_{i+1} - x_i)$$\nApplying Newton's second law, $F_i = m\\ddot{x}_i$, we obtain the system of coupled differential equations for small oscillations:\n$$m\\ddot{x}_i = k_{i-1}x_{i-1} - (k_{i-1} + k_i)x_i + k_i x_{i+1}$$\nThis equation holds for $i=1, \\dots, N$, with the fixed boundary conditions $x_0 = 0$ and $x_{N+1} = 0$.\n\nTo find the normal modes, we seek solutions of the form $x_i(t) = v_i e^{i\\omega t}$, where $\\omega$ is the angular frequency and $v_i$ is the time-independent amplitude for mass $i$. The second time derivative is $\\ddot{x}_i(t) = -\\omega^2 v_i e^{i\\omega t}$. Substituting this into the equations of motion and cancelling the common factor $e^{i\\omega t}$ yields:\n$$-m\\omega^2 v_i = k_{i-1}v_{i-1} - (k_{i-1} + k_i)v_i + k_i v_{i+1}$$\nRearranging the terms, we get a system of linear algebraic equations:\n$$(k_{i-1} + k_i)v_i - k_{i-1}v_{i-1} - k_i v_{i+1} = m\\omega^2 v_i$$\nThis system of $N$ equations can be expressed as a matrix eigenvalue problem:\n$$\\mathbf{K}\\mathbf{v} = m\\omega^2\\mathbf{v}$$\nwhere $\\mathbf{v} = (v_1, \\dots, v_N)^T$ is the eigenvector of amplitudes and $\\mathbf{K}$ is the $N \\times N$ stiffness matrix. The elements of $\\mathbf{K}$ are given by (using $1$-based indexing):\n$$K_{ij} = \\begin{cases} k_{i-1} + k_i  \\text{if } j=i \\\\ -k_i  \\text{if } j=i+1 \\\\ -k_{i-1}  \\text{if } j=i-1 \\\\ 0  \\text{otherwise} \\end{cases}$$\nThe matrix $\\mathbf{K}$ is real, symmetric, and tridiagonal. To cast this into a standard eigenvalue problem, we define the dynamical matrix $\\mathbf{D} = \\frac{1}{m}\\mathbf{K}$ and the eigenvalue $\\lambda = \\omega^2$. The problem becomes:\n$$\\mathbf{D}\\mathbf{v} = \\lambda\\mathbf{v}$$\nThe eigenvalues $\\lambda_j$ of $\\mathbf{D}$ are the squared angular frequencies of the normal modes, and the corresponding eigenvectors $\\mathbf{v}_j$ describe the spatial profile of these modes.\n\nThe computational task is to implement this model. For each parameter set, the procedure is as follows:\n$1$. A total of $R$ realizations are simulated. For each realization, a set of $N+1$ spring constants $\\{k_0, k_1, \\dots, k_N\\}$ is generated by independent random sampling from the uniform distribution on the interval $\\left[k_{\\mathrm{avg}} - \\frac{w}{2}, k_{\\mathrm{avg}} + \\frac{w}{2}\\right]$. A fixed pseudorandom seed ensures reproducibility.\n\n$2$. The $N \\times N$ dynamical matrix $\\mathbf{D}$ is constructed. For implementation with $0$-based indexing, where masses are indexed $0, \\dots, N-1$ and the spring constants are in an array `k_const` of length $N+1$, the elements of $\\mathbf{D}$ are:\n- Main diagonal: $D_{i,i} = \\frac{\\texttt{k\\_const}[i] + \\texttt{k\\_const}[i+1]}{m}$ for $i=0, \\dots, N-1$.\n- Off-diagonals: $D_{i,i+1} = D_{i+1,i} = -\\frac{\\texttt{k\\_const}[i+1]}{m}$ for $i=0, \\dots, N-2$.\n\n$3$. The eigenvalue problem for the symmetric matrix $\\mathbf{D}$ is solved numerically. This yields $N$ real eigenvalues $\\lambda_j$ and a set of $N$ mutually orthogonal eigenvectors $\\mathbf{v}_j$. We use a numerical library function (e.g., `numpy.linalg.eigh`) that returns eigenvectors normalized to unit L$2$-norm, i.e., $\\sum_{i=1}^{N} v_{ij}^2 = 1$.\n\n$4$. For each normalized eigenvector $\\mathbf{v}_j$, the Inverse Participation Ratio (IPR) is calculated using the formula $I_j = \\sum_{i=1}^{N} v_{ij}^4$. This dimensionless quantity measures the degree of localization of the mode. An extended mode (like a sine wave) has an IPR of order $1/N$, while a mode localized on a few sites has a much larger IPR.\n\n$5$. The final result for a given parameter set is the average IPR, computed over all $N$ modes and all $R$ realizations. This provides a statistical measure of localization for the given level of disorder.\n\nThis entire process is repeated for each of the specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_average_ipr(N, m, k_avg, w, R, seed):\n    \"\"\"\n    Computes the average Inverse Participation Ratio (IPR) for a disordered chain.\n\n    Args:\n        N (int): Number of masses.\n        m (float): Mass of each oscillator.\n        k_avg (float): Average spring constant.\n        w (float): Width of the uniform distribution for spring constants.\n        R (int): Number of realizations for averaging.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        float: The average IPR over all modes and all realizations.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # This list will store IPR values for each mode of each realization.\n    all_iprs = []\n\n    for _ in range(R):\n        # 1. Generate N+1 spring constants for one realization.\n        k_low = k_avg - w / 2.0\n        k_high = k_avg + w / 2.0\n        \n        # Spring constants k_0, k_1, ..., k_N\n        k_constants = rng.uniform(k_low, k_high, size=N + 1)\n        \n        # 2. Construct the dynamical matrix D (size N x N).\n        # We use 0-based indexing for the masses (0 to N-1).\n        # The main diagonal elements D_ii are (k_i + k_{i+1}) / m.\n        # This translates to (k_constants[0...N-1] + k_constants[1...N]) / m.\n        diag_elements = (k_constants[:-1] + k_constants[1:]) / m\n        \n        # The off-diagonal elements D_{i,i+1} are -k_{i+1} / m.\n        # This translates to -k_constants[1...N-1] / m.\n        off_diag_elements = -k_constants[1:-1] / m\n        \n        # Efficiently construct the tridiagonal matrix.\n        D = np.diag(diag_elements) + np.diag(off_diag_elements, k=1) + np.diag(off_diag_elements, k=-1)\n        \n        # 3. Compute eigenvalues and eigenvectors.\n        # np.linalg.eigh is used for symmetric matrices. It is efficient and\n        # returns real eigenvalues and normalized eigenvectors (L2 norm = 1).\n        _, eigvecs = np.linalg.eigh(D)\n        \n        # 4. Compute IPR for each mode.\n        # The columns of eigvecs are the eigenvectors.\n        # IPR is defined as sum(v_i^4) for each eigenvector v.\n        # The operation is vectorized for efficiency.\n        iprs_for_realization = np.sum(eigvecs**4, axis=0)\n        \n        all_iprs.extend(iprs_for_realization)\n        \n    # 5. Average IPR over all modes and all realizations.\n    return np.mean(all_iprs)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, m, k_avg, w, R, seed)\n        (64, 1.0, 1.0, 0.0, 1, 1234),    # Test case A\n        (64, 1.0, 1.0, 0.6, 200, 2024),  # Test case B\n        (64, 1.0, 1.0, 1.8, 200, 2024),  # Test case C\n    ]\n\n    results = []\n    for case in test_cases:\n        N, m, k_avg, w, R, seed = case\n        avg_ipr = compute_average_ipr(N, m, k_avg, w, R, seed)\n        results.append(f\"{avg_ipr:.6f}\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2418657"}]}