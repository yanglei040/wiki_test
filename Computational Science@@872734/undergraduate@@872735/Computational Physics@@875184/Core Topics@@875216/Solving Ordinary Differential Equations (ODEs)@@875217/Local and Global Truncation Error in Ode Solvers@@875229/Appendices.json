{"hands_on_practices": [{"introduction": "The simple harmonic oscillator is a fundamental model for periodic motion in physics and engineering. This exercise explores how two different numerical methods, the explicit Euler and the Leapfrog integrator, handle this system's conserved energy. You will discover that the global truncation error manifests in qualitatively different ways for each method, leading to distinct physical artifacts like artificial energy gain versus a manageable phase shift, illustrating that the *character* of the error is as important as its magnitude. [@problem_id:2409167]", "problem": "Consider the undamped simple harmonic oscillator (SHO) governed by the ordinary differential equation (ODE) $m\\,\\ddot{x}(t)+k\\,x(t)=0$, with $m$ the mass and $k$ the stiffness. Let $m=k=1$ so that the angular frequency is $\\omega=\\sqrt{k/m}=1$ (in radians per second). Use the initial conditions $x(0)=A$ and $v(0)=\\dot{x}(0)=0$, with amplitude $A=1$ (in meters). The exact displacement is $x_{\\text{exact}}(t)=A\\cos(\\omega t)$ and the exact velocity is $v_{\\text{exact}}(t)=-A\\,\\omega\\sin(\\omega t)$. Investigate how the global truncation error (GTE) and the local truncation error (LTE) of two one-step time integrators manifest for this system: the explicit Euler method and the Leapfrog method. The explicit Euler method is defined by the updates\n$$\nx_{n+1}=x_n+h\\,v_n,\\quad v_{n+1}=v_n-h\\,\\omega^2\\,x_n,\n$$\nwhere $h$ is the fixed time step and $n\\in\\{0,1,2,\\dots,N-1\\}$ with $t_n=n\\,h$ and $t_N=T=N\\,h$. The Leapfrog method (velocity Verlet form) is defined by\n$$\na_n=-\\omega^2 x_n,\\quad v_{n+\\frac{1}{2}}=v_n+\\frac{h}{2}a_n,\\quad x_{n+1}=x_n+h\\,v_{n+\\frac{1}{2}},\n$$\n$$\na_{n+1}=-\\omega^2 x_{n+1},\\quad v_{n+1}=v_{n+\\frac{1}{2}}+\\frac{h}{2}a_{n+1}.\n$$\nFor each method, integrate from $t=0$ to $t=T$ with a uniform time step $h$ so that $T=N\\,h$ for some integer $N$.\n\nDefine the amplitude error of the explicit Euler method at $t=T$ by\n$$\nE_A=\\sqrt{x_N^2+\\left(\\frac{v_N}{\\omega}\\right)^2}-A,\n$$\nexpressed in meters. Define the signed phase error of the Leapfrog method at $t=T$ by\n$$\nE_\\phi=\\operatorname{wrap}_{(-\\pi,\\pi]}\\!\\left(\\theta_{\\text{num}}-\\theta_{\\text{exact}}\\right),\n$$\nwhere the numerical phase is\n$$\n\\theta_{\\text{num}}=\\operatorname{atan2}\\!\\left(-\\frac{v_N}{\\omega},\\,x_N\\right),\n$$\nthe exact phase is $\\theta_{\\text{exact}}=\\omega T$, and $\\operatorname{wrap}_{(-\\pi,\\pi]}(\\alpha)$ maps any real $\\alpha$ to its representative in $(-\\pi,\\pi]$ by adding or subtracting integer multiples of $2\\pi$. The angle unit must be radians.\n\nYour program must compute, for each test case below, the pair $[E_A,E_\\phi]$ using the definitions above, with $E_A$ in meters and $E_\\phi$ in radians. Use $A=1$ (in meters) and $\\omega=1$ (in radians per second) for all cases. The test suite consists of the following parameter sets, each specified by $(h,T)$ in seconds, with $T=N\\,h$:\n- Case $1$: $h=0.1$, $T=50$.\n- Case $2$: $h=0.01$, $T=50$.\n- Case $3$: $h=0.5$, $T=50$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the two-entry list $[E_A,E_\\phi]$ for one case, in the same order as above. For example, a valid shape is $[[\\dots,\\dots],[\\dots,\\dots],[\\dots,\\dots]]$. Angles must be in radians and distances in meters. No additional text should be printed.", "solution": "The problem presented is valid. It is a well-posed, scientifically grounded problem in computational physics that investigates the fundamental error characteristics of two standard numerical integrators for ordinary differential equations. All parameters, conditions, and definitions are provided, and there are no internal contradictions or logical flaws. We shall proceed with the solution.\n\nThe problem requires the analysis of two numerical integration schemes, the explicit Euler method and the Leapfrog method, applied to the simple harmonic oscillator (SHO). The governing equation of motion is\n$$\nm\\,\\ddot{x}(t) + k\\,x(t) = 0\n$$\nWith the given parameters, mass $m=1$ and stiffness $k=1$, the angular frequency is $\\omega = \\sqrt{k/m} = 1\\,\\text{rad/s}$. The system is described by the state vector $(x(t), v(t))$, where $v(t) = \\dot{x}(t)$. The initial conditions are $x(0) = A = 1$ and $v(0) = 0$. The exact solution is given by\n$$\nx_{\\text{exact}}(t) = A\\cos(\\omega t) \\quad \\text{and} \\quad v_{\\text{exact}}(t) = -A\\omega\\sin(\\omega t)\n$$\nThe total energy of the system, $E = \\frac{1}{2}mv^2 + \\frac{1}{2}kx^2$, is a conserved quantity. For the given parameters, this is $E(t) = \\frac{1}{2}(v(t)^2 + x(t)^2)$. The initial energy is $E(0) = \\frac{1}{2}(0^2 + 1^2) = 1/2$. The amplitude of the oscillation is related to the energy by $A = \\sqrt{x^2 + (v/\\omega)^2}$. Thus, conservation of energy is equivalent to conservation of amplitude.\n\nWe will now analyze the behavior of each specified numerical method.\n\n**Explicit Euler Method**\n\nThe explicit Euler method is a first-order integrator. For the SHO, with acceleration $a(t) = \\ddot{x}(t) = -\\omega^2 x(t)$, the update rules are:\n$$\nx_{n+1} = x_n + h\\,v_n\n$$\n$$\nv_{n+1} = v_n + h\\,a_n = v_n - h\\,\\omega^2\\,x_n\n$$\nwhere $h$ is the time step. This method is not symplectic, and for oscillatory systems, it is known to be numerically unstable as it artificially increases the system's energy over time. Let us analyze the numerical energy at step $n+1$:\n$$\nE_{n+1} = \\frac{1}{2}(v_{n+1}^2 + \\omega^2 x_{n+1}^2) = \\frac{1}{2}((v_n - h\\omega^2 x_n)^2 + \\omega^2(x_n + h v_n)^2)\n$$\nExpanding the terms, we find:\n$$\nE_{n+1} = \\frac{1}{2}(v_n^2 - 2h\\omega^2 x_n v_n + h^2\\omega^4 x_n^2 + \\omega^2(x_n^2 + 2h x_n v_n + h^2 v_n^2))\n$$\n$$\nE_{n+1} = \\frac{1}{2}(v_n^2 + h^2\\omega^4 x_n^2 + \\omega^2 x_n^2 + \\omega^2 h^2 v_n^2) = \\frac{1}{2}((1+\\omega^2h^2)v_n^2 + \\omega^2(1+\\omega^2h^2)x_n^2)\n$$\n$$\nE_{n+1} = (1+\\omega^2h^2) \\left(\\frac{1}{2}(v_n^2 + \\omega^2 x_n^2)\\right) = (1+\\omega^2h^2)E_n\n$$\nAfter $N$ steps to time $T=N\\,h$, the energy becomes $E_N = (1+\\omega^2h^2)^N E_0$. Since the amplitude is $A = \\sqrt{2E/\\omega^2}$, the numerical amplitude $A_N$ at step $N$ is related to the initial amplitude $A_0$ by:\n$$\nA_N = A_0 (1+\\omega^2h^2)^{N/2}\n$$\nThe amplitude error, $E_A = A_N - A_0$, is therefore given by $E_A = A_0 \\left[(1+\\omega^2h^2)^{N/2} - 1\\right]$. This demonstrates an exponential growth in amplitude, a hallmark of this method's instability for conservative systems. The amplitude error $E_A$ is calculated using the final state $(x_N, v_N)$ as specified: $E_A = \\sqrt{x_N^2 + (v_N/\\omega)^2} - A$.\n\n**Leapfrog Method (Velocity Verlet Form)**\n\nThe Leapfrog method is a second-order, symplectic integrator. Its velocity Verlet form is given by:\n$$\nv_{n+\\frac{1}{2}} = v_n + \\frac{h}{2}a_n \\quad \\text{where} \\quad a_n=-\\omega^2 x_n\n$$\n$$\nx_{n+1} = x_n + h\\,v_{n+\\frac{1}{2}}\n$$\n$$\nv_{n+1} = v_{n+\\frac{1}{2}} + \\frac{h}{2}a_{n+1} \\quad \\text{where} \\quad a_{n+1}=-\\omega^2 x_{n+1}\n$$\nBeing symplectic, this method does not exhibit secular drift in energy. The numerical energy will oscillate around the true energy, leading to excellent long-term stability and bounded amplitude error. However, the method introduces a systematic error in the phase of the oscillation. The numerical frequency, $\\tilde{\\omega}$, is slightly different from the true frequency $\\omega$. This leads to a phase error that accumulates over time. For small step sizes $h$, the global phase error at time $T$ is on the order of $O(T\\omega^3h^2)$.\nThe problem defines the phase error $E_\\phi$ based on a state-space representation $(x, -v/\\omega)$. For the exact solution, the state vector $(x_{\\text{exact}}(t), -v_{\\text{exact}}(t)/\\omega) = (A\\cos(\\omega t), A\\sin(\\omega t))$ rotates counter-clockwise with an angle $\\theta_{\\text{exact}}(t) = \\omega t$. The numerical phase $\\theta_{\\text{num}}$ is computed from the final numerical state $(x_N, v_N)$ as $\\theta_{\\text{num}} = \\operatorname{atan2}(-v_N/\\omega, x_N)$. The phase error is the difference between the numerical and exact phase, wrapped to the interval $(-\\pi, \\pi]$:\n$$\nE_\\phi = \\operatorname{wrap}_{(-\\pi,\\pi]}(\\theta_{\\text{num}} - \\theta_{\\text{exact}})\n$$\nThis calculation correctly captures the phase lag or lead of the numerical solution. The wrapping is required because phase is a periodic quantity.\n\n**Computational Procedure**\n\nFor each given test case $(h, T)$:\n1.  Set initial conditions $x_0 = 1$, $v_0 = 0$ and parameters $A=1$, $\\omega=1$.\n2.  Calculate the number of integration steps $N = T/h$.\n3.  Simulate the system using the explicit Euler method for $N$ steps to find the final state $(x_N, v_N)_{\\text{Euler}}$.\n4.  Compute the amplitude error $E_A = \\sqrt{x_{N,\\text{Euler}}^2 + (v_{N,\\text{Euler}}/\\omega)^2} - A$.\n5.  Simulate the system using the Leapfrog method for $N$ steps to find the final state $(x_N, v_N)_{\\text{Leapfrog}}$.\n6.  Compute the numerical phase $\\theta_{\\text{num}} = \\operatorname{atan2}(-v_{N,\\text{Leapfrog}}/\\omega, x_{N,\\text{Leapfrog}})$, the exact phase $\\theta_{\\text{exact}} = \\omega T$, and the wrapped phase error $E_\\phi$. The wrapping function maps a real number $\\alpha$ to the interval $(-\\pi, \\pi]$ using the formula $\\beta = \\alpha - 2\\pi \\lceil(\\alpha - \\pi)/(2\\pi)\\rceil$.\n7.  Combine the results into a single pair $[E_A, E_\\phi]$.\n\nThis procedure will be implemented to generate the required output for all test cases. The calculated values will serve as a concrete demonstration of the theoretical error behaviors discussed above.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes amplitude and phase errors for Euler and Leapfrog methods\n    for a simple harmonic oscillator.\n    \"\"\"\n    \n    # Test cases defined by (h, T) in seconds.\n    test_cases = [\n        (0.1, 50.0),\n        (0.01, 50.0),\n        (0.5, 50.0),\n    ]\n\n    # Constants from the problem statement\n    A = 1.0  # meters\n    omega = 1.0  # radians per second\n\n    results = []\n    \n    # Custom wrap function to map angle to (-pi, pi]\n    def wrap_to_pi(alpha):\n        \"\"\"Maps an angle alpha in radians to the interval (-pi, pi].\"\"\"\n        return alpha - 2 * np.pi * np.ceil((alpha - np.pi) / (2 * np.pi))\n\n    for h, T in test_cases:\n        N = int(T / h)\n        if not np.isclose(N * h, T):\n            # This should not happen with the given test cases\n            raise ValueError(\"T must be an integer multiple of h.\")\n\n        # --- Explicit Euler Simulation ---\n        x_euler, v_euler = A, 0.0\n        for _ in range(N):\n            x_next = x_euler + h * v_euler\n            v_next = v_euler - h * (omega**2) * x_euler\n            x_euler, v_euler = x_next, v_next\n        \n        # Calculate amplitude error for Euler method\n        amplitude_numerical_euler = np.sqrt(x_euler**2 + (v_euler / omega)**2)\n        E_A = amplitude_numerical_euler - A\n\n        # --- Leapfrog (Velocity Verlet) Simulation ---\n        x_leap, v_leap = A, 0.0\n        # Initial acceleration\n        a_n = -(omega**2) * x_leap\n        for _ in range(N):\n            v_half = v_leap + 0.5 * h * a_n\n            x_next = x_leap + h * v_half\n            a_next = -(omega**2) * x_next\n            v_next = v_half + 0.5 * h * a_next\n            \n            x_leap, v_leap = x_next, v_next\n            a_n = a_next\n\n        # Calculate signed phase error for Leapfrog method\n        theta_num = np.arctan2(-v_leap / omega, x_leap)\n        theta_exact = omega * T\n        phase_diff = theta_num - theta_exact\n        E_phi = wrap_to_pi(phase_diff)\n        \n        results.append([E_A, E_phi])\n\n    # Format the output string exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2409167"}, {"introduction": "Many physical systems involve processes that evolve on vastly different time scales, leading to \"stiff\" ordinary differential equations. This practice uses a simple linear ODE to demonstrate a crucial principle: for stiff problems solved with explicit methods, the step size $h$ is often constrained by numerical stability, not local accuracy. You will see firsthand how violating the stability condition, even when the local truncation error per step is small, causes the global truncation error to explode. [@problem_id:2409172]", "problem": "Consider the scalar linear stiff Ordinary Differential Equation (ODE): $y'(t)=-\\lambda y(t)$ with $\\lambda>0$ and initial condition $y(0)=1$. The exact solution is $y(t)=e^{-\\lambda t}$. Let a numerical approximation $y_n$ be generated on a uniform grid $t_n = n h$ with a constant time step $h>0$ using the explicit forward Euler one-step scheme $y_{n+1}=y_n+h f(t_n,y_n)$, where $f(t,y)=-\\lambda y$, so that after $N$ steps the final time is $T=N h$. Define the one-step Local Truncation Error (LTE) at the initial point as $\\mathrm{LTE}_1=\\left|y(h)-\\left(y(0)+h f(0,y(0))\\right)\\right|$, and define the Global Truncation Error (GTE) at time $T$ as $\\mathrm{GTE}(T)=\\left|y_N-y(T)\\right|$. Also define the ratio $R=\\mathrm{GTE}(T)/\\mathrm{LTE}_1$, and the linear stability indicator $S$ for the explicit method on this problem as the boolean value of the condition $\\left|1-\\lambda h\\right|<1$.\n\nYour task is to write a complete program that, for each parameter triplet $(\\lambda,T,h)$ in the test suite below, computes the tuple of quantities $\\left(\\mathrm{GTE}(T),\\mathrm{LTE}_1,R,S\\right)$ using $y(0)=1$ and the definitions above. All calculations are dimensionless. Angles are not involved. Do not round the outputs; produce them as raw floating-point and boolean values.\n\nTest suite (provide results in this exact order):\n- Case $1$: $(\\lambda,T,h)=\\left(200,1.0,0.002\\right)$.\n- Case $2$: $(\\lambda,T,h)=\\left(200,1.0,0.01\\right)$.\n- Case $3$: $(\\lambda,T,h)=\\left(200,0.96,0.012\\right)$.\n- Case $4$: $(\\lambda,T,h)=\\left(500,0.468,0.0039\\right)$.\n- Case $5$: $(\\lambda,T,h)=\\left(20,1.0,0.2\\right)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each caseâ€™s result is itself a list in the form $[\\mathrm{GTE}(T),\\mathrm{LTE}_{1,1},R_1,S_1],[\\mathrm{GTE}_2,\\mathrm{LTE}_{1,2},R_2,S_2],\\dots]$.", "solution": "The problem presented is a standard, well-posed exercise in the elementary analysis of numerical methods for Ordinary Differential Equations (ODEs). It is scientifically sound, resting on foundational principles of computational physics and numerical analysis, and it provides all necessary definitions and data for a unique, unambiguous solution. We find no flaws; therefore, we proceed with the derivation.\n\nThe problem centers on the scalar linear ODE:\n$$\ny'(t) = -\\lambda y(t)\n$$\nwith initial condition $y(0)=1$ and parameter $\\lambda > 0$. The exact solution is given as:\n$$\ny(t) = e^{-\\lambda t}\n$$\nWe are to analyze the explicit forward Euler scheme applied to this equation. The scheme is defined as:\n$$\ny_{n+1} = y_n + h f(t_n, y_n)\n$$\nwhere $h$ is the constant time step and $f(t,y) = -\\lambda y$. Substituting the function $f$ into the scheme provides the iterative relation for the numerical solution $y_n$ at time $t_n = n h$:\n$$\ny_{n+1} = y_n + h(-\\lambda y_n) = (1 - \\lambda h) y_n\n$$\nThis is a first-order linear recurrence relation. Given the initial condition $y_0 = y(0) = 1$, we can derive a closed-form expression for the numerical solution $y_N$ at time $T=Nh$:\n$$\ny_N = (1 - \\lambda h)^N y_0 = (1 - \\lambda h)^N\n$$\nSince $N=T/h$, we have the numerical approximation at the final time $T$:\n$$\ny_N = \\left(1 - \\lambda h\\right)^{T/h}\n$$\nWith this foundation, we can now derive the expressions for the four quantities required by the problem for each parameter set $(\\lambda, T, h)$.\n\n1.  Global Truncation Error, $\\mathrm{GTE}(T)$:\n    The GTE is defined as the absolute difference between the numerical solution and the exact solution at the final time $T$.\n    $$\n    \\mathrm{GTE}(T) = \\left|y_N - y(T)\\right|\n    $$\n    Substituting the expressions for $y_N$ and $y(T)$:\n    $$\n    \\mathrm{GTE}(T) = \\left| \\left(1 - \\lambda h\\right)^{T/h} - e^{-\\lambda T} \\right|\n    $$\n\n2.  Local Truncation Error, $\\mathrm{LTE}_1$:\n    The one-step LTE at the initial point is defined as the error incurred in the first step, assuming the step starts from the exact solution $y(0)$.\n    $$\n    \\mathrm{LTE}_1 = \\left|y(h) - \\left(y(0)+h f(0,y(0))\\right)\\right|\n    $$\n    We substitute the known quantities: $y(h) = e^{-\\lambda h}$, $y(0)=1$, and $f(0, y(0)) = f(0,1) = -\\lambda$.\n    $$\n    \\mathrm{LTE}_1 = \\left|e^{-\\lambda h} - \\left(1 + h(-\\lambda)\\right)\\right| = \\left|e^{-\\lambda h} - (1 - \\lambda h)\\right|\n    $$\n    From the Taylor series expansion of $e^{-\\lambda h} = 1 - \\lambda h + \\frac{(\\lambda h)^2}{2!} - O((\\lambda h)^3)$, it is evident that $\\mathrm{LTE}_1$ is of order $O(h^2)$. Since the local error of a method of order $p$ is $O(h^{p+1})$, this confirms the forward Euler method is first-order ($p=1$).\n\n3.  Ratio, $R$:\n    The ratio $R$ is defined as $R = \\mathrm{GTE}(T)/\\mathrm{LTE}_1$.\n    $$\n    R = \\frac{\\left| \\left(1 - \\lambda h\\right)^{T/h} - e^{-\\lambda T} \\right|}{\\left|e^{-\\lambda h} - (1 - \\lambda h)\\right|}\n    $$\n    This ratio compares the magnitude of the final global error to the magnitude of the initial local error.\n\n4.  Linear Stability Indicator, $S$:\n    The stability of the forward Euler method for this test problem depends on the amplification factor $g(\\lambda h) = 1 - \\lambda h$. For the numerical solution to remain bounded, we require $|g(\\lambda h)| \\leq 1$. The problem specifies a strict inequality for the indicator $S$.\n    $$\n    S = \\text{boolean value of } \\left|1 - \\lambda h\\right| < 1\n    $$\n    This inequality is equivalent to $-1 < 1 - \\lambda h < 1$.\n    The right side, $1 - \\lambda h < 1$, implies $-\\lambda h < 0$, which is always true since $\\lambda > 0$ and $h > 0$.\n    The left side, $-1 < 1 - \\lambda h$, implies $\\lambda h < 2$.\n    Thus, the stability condition simplifies to $0 < \\lambda h < 2$. The indicator $S$ is `True` if $\\lambda h < 2$ and `False` otherwise.\n\nThese four formulas will be implemented directly to compute the required tuples for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes GTE, LTE, their ratio, and a stability indicator for the\n    forward Euler method on a stiff ODE for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (200.0, 1.0, 0.002),   # Case 1\n        (200.0, 1.0, 0.01),    # Case 2\n        (200.0, 0.96, 0.012),   # Case 3\n        (500.0, 0.468, 0.0039), # Case 4\n        (20.0, 1.0, 0.2),      # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_, T, h = case\n\n        # Number of steps N = T/h. Ensure it is an integer value.\n        # Problem statement guarantees this, but round for robustness.\n        N = int(round(T / h))\n\n        # Calculate lambda * h, a key dimensionless parameter\n        lambda_h = lambda_ * h\n\n        # 1. Global Truncation Error (GTE) at time T\n        # GTE(T) = |y_N - y(T)|\n        # y_N = (1 - lambda*h)^N\n        # y(T) = exp(-lambda*T)\n        y_num_N = (1.0 - lambda_h)**N\n        y_exact_T = np.exp(-lambda_ * T)\n        GTE = np.abs(y_num_N - y_exact_T)\n\n        # 2. Local Truncation Error (LTE) at the first step\n        # LTE_1 = |y(h) - (y(0) + h*f(0,y(0)))|\n        # y(h) = exp(-lambda*h)\n        # y(0) + h*f(0,y(0)) = 1 - lambda*h\n        y_exact_h = np.exp(-lambda_h)\n        y_num_h = 1.0 - lambda_h\n        LTE1 = np.abs(y_exact_h - y_num_h)\n        \n        # 3. Ratio R = GTE(T) / LTE_1\n        # The problem setup ensures LTE1 is never zero.\n        if LTE1 == 0.0:\n            # Handle potential division by zero, though not expected here.\n            R = np.inf if GTE != 0.0 else 0.0\n        else:\n            R = GTE / LTE1\n\n        # 4. Linear Stability Indicator S\n        # S is True if |1 - lambda*h| < 1, which simplifies to lambda*h < 2.\n        S = lambda_h < 2.0\n        \n        # Store the computed tuple\n        result_tuple_str = f\"[{GTE},{LTE1},{R},{S}]\"\n        results.append(result_tuple_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2409172"}, {"introduction": "The N-body problem is a classic challenge in celestial mechanics, renowned for its potential for chaotic behavior where small errors can lead to vastly different outcomes. This final practice demonstrates the high-stakes consequences of global truncation error in a complex, multi-particle simulation. By simulating a three-body system, you will investigate how different choices of numerical integrator and step size can yield qualitatively divergent futures, such as a planet maintaining a stable orbit versus being ejected into interstellar space. [@problem_id:2409137]", "problem": "Consider a Newtonian three-body system in two spatial dimensions under pairwise gravitational interaction. Let the gravitational constant be $G=1$ and let the bodies have masses $m_1=1$, $m_2=10^{-3}$, and $m_3=10^{-6}$. Let the initial positions and velocities be given by\n$$\n\\mathbf{r}_1(0)=\\begin{bmatrix}0\\\\0\\end{bmatrix},\\quad\n\\mathbf{r}_2(0)=\\begin{bmatrix}1\\\\0\\end{bmatrix},\\quad\n\\mathbf{r}_3(0)=\\begin{bmatrix}1.5\\\\0\\end{bmatrix},\n$$\n$$\n\\mathbf{v}_2(0)=\\begin{bmatrix}0\\\\1\\end{bmatrix},\\quad\n\\mathbf{v}_3(0)=\\begin{bmatrix}0\\\\\\sqrt{\\dfrac{1}{1.5}}\\end{bmatrix},\\quad\n\\mathbf{v}_1(0)=-\\dfrac{m_2 \\mathbf{v}_2(0)+m_3 \\mathbf{v}_3(0)}{m_1}.\n$$\nThe equations of motion are\n$$\n\\frac{d\\mathbf{r}_i}{dt}=\\mathbf{v}_i,\\qquad\n\\frac{d\\mathbf{v}_i}{dt}=\\sum_{\\substack{j=1 \\\\ j\\neq i}}^{3} G m_j \\frac{\\mathbf{r}_j-\\mathbf{r}_i}{\\|\\mathbf{r}_j-\\mathbf{r}_i\\|^3},\\quad i\\in\\{1,2,3\\}.\n$$\nAll quantities are nondimensionalized (dimensionless units), so no physical unit conversion is required.\n\nDefine the total energy of the system at time $t$ by\n$$\nE(t)=\\sum_{i=1}^{3}\\frac{1}{2}m_i\\|\\mathbf{v}_i(t)\\|^2 - \\sum_{1\\le i<j\\le 3}\\frac{G m_i m_j}{\\|\\mathbf{r}_i(t)-\\mathbf{r}_j(t)\\|}.\n$$\nDefine the energy of body $3$ relative to the others by\n$$\nE_3(t)=\\frac{1}{2}m_3\\|\\mathbf{v}_3(t)\\|^2 - \\frac{G m_1 m_3}{\\|\\mathbf{r}_3(t)-\\mathbf{r}_1(t)\\|} - \\frac{G m_2 m_3}{\\|\\mathbf{r}_3(t)-\\mathbf{r}_2(t)\\|}.\n$$\nA qualitative ejection of body $3$ by the final time $T$ is defined to have occurred if $E_3(T)>0$.\n\nA numerical one-step method is characterized by a stepsize $h>0$, a finite final time $T>0$, and a local truncation error that is proportional to $h^{p+1}$ for some positive integer $p$ (called the order). For a fixed initial value problem, the global truncation error scales with $h^p$ over a fixed interval when $h\\to 0$.\n\nYour task is to compute approximations to the solution for the following three parameter sets $(p,h,T)$ and to report, for each set, two quantities: the boolean ejection flag $b$ defined by $b=(E_3(T)>0)$, and the relative total energy error at the final time $\\varepsilon=\\dfrac{|E(T)-E(0)|}{|E(0)|}$.\n\nThe test suite of parameter sets is:\n- Set A (happy path for illustrating severe global error): $(p,h,T)=(1,0.3,300)$.\n- Set B (same stepsize, higher order): $(p,h,T)=(4,0.3,300)$.\n- Set C (smaller stepsize, same order as A): $(p,h,T)=(1,0.05,300)$.\n\nYour program must produce a single line of output containing a flat list with entries in this exact order:\n$$\n[\\;b_A,\\;\\varepsilon_A,\\;b_B,\\;\\varepsilon_B,\\;b_C,\\;\\varepsilon_C\\;],\n$$\nwhere $b_A$ and $b_B$ and $b_C$ are booleans and $\\varepsilon_A$, $\\varepsilon_B$, $\\varepsilon_C$ are real numbers. The output must be printed as a single comma-separated list enclosed in square brackets, with no additional text. All computations are to be performed in the nondimensionalized system specified above. No angles are involved, and no unit conversion is required. The numerical values should be reported in their natural decimal form. The design of the parameter sets ensures coverage of a general illustrative case, a comparison at fixed stepsize with different order, and an edge case with reduced stepsize at fixed order.", "solution": "The problem presented is to find a numerical solution to a Newtonian three-body problem in two dimensions and to analyze the effects of the numerical integrator's order and step size on the solution's accuracy. The problem is scientifically grounded, well-posed, and contains all necessary information for a unique solution under the standard interpretation of using canonical numerical methods. Therefore, the problem is valid.\n\nThe system's state at any time $t$ can be described by a state vector $Y(t) \\in \\mathbb{R}^{12}$, which concatenates the positions and velocities of the three bodies:\n$$\nY(t) = \\begin{bmatrix} \\mathbf{r}_1(t) \\\\ \\mathbf{r}_2(t) \\\\ \\mathbf{r}_3(t) \\\\ \\mathbf{v}_1(t) \\\\ \\mathbf{v}_2(t) \\\\ \\mathbf{v}_3(t) \\end{bmatrix}\n$$\nwhere $\\mathbf{r}_i(t) = [x_i(t), y_i(t)]^T$ and $\\mathbf{v}_i(t) = [v_{ix}(t), v_{iy}(t)]^T$ are the $2$-dimensional position and velocity vectors of the $i$-th body, for $i \\in \\{1, 2, 3\\}$. The evolution of the system is governed by a system of first-order ordinary differential equations (ODEs) of the form $\\frac{dY}{dt} = F(Y)$, where the function $F: \\mathbb{R}^{12} \\to \\mathbb{R}^{12}$ is defined by the equations of motion:\n$$\nF(Y) = \\begin{bmatrix} \\mathbf{v}_1 \\\\ \\mathbf{v}_2 \\\\ \\mathbf{v}_3 \\\\ \\mathbf{a}_1 \\\\ \\mathbf{a}_2 \\\\ \\mathbf{a}_3 \\end{bmatrix}\n$$\nThe acceleration $\\mathbf{a}_i$ of body $i$ is given by Newton's law of universal gravitation:\n$$\n\\mathbf{a}_i = \\frac{d\\mathbf{v}_i}{dt} = \\sum_{\\substack{j=1 \\\\ j\\neq i}}^{3} G m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\|\\mathbf{r}_j - \\mathbf{r}_i\\|^3}\n$$\nThe problem specifies the masses $m_1=1$, $m_2=10^{-3}$, $m_3=10^{-6}$ and the gravitational constant $G=1$. The initial conditions at $t=0$ are:\n$$\n\\mathbf{r}_1(0)=\\begin{bmatrix}0\\\\0\\end{bmatrix},\\quad\n\\mathbf{r}_2(0)=\\begin{bmatrix}1\\\\0\\end{bmatrix},\\quad\n\\mathbf{r}_3(0)=\\begin{bmatrix}1.5\\\\0\\end{bmatrix}\n$$\n$$\n\\mathbf{v}_2(0)=\\begin{bmatrix}0\\\\1\\end{bmatrix},\\quad\n\\mathbf{v}_3(0)=\\begin{bmatrix}0\\\\\\sqrt{1/1.5}\\end{bmatrix}\n$$\nThe initial velocity of the first body, $\\mathbf{v}_1(0)$, is set to ensure the total momentum of the system is zero: $\\sum_{i=1}^3 m_i \\mathbf{v}_i(0) = \\mathbf{0}$. This yields:\n$$\n\\mathbf{v}_1(0) = -\\frac{m_2 \\mathbf{v}_2(0) + m_3 \\mathbf{v}_3(0)}{m_1} = -\\frac{10^{-3} \\begin{bmatrix}0\\\\1\\end{bmatrix} + 10^{-6} \\begin{bmatrix}0\\\\\\sqrt{2/3}\\end{bmatrix}}{1} = \\begin{bmatrix}0 \\\\ -10^{-3} - 10^{-6}\\sqrt{2/3}\\end{bmatrix}\n$$\nFrom these initial conditions, we compute the initial total energy $E(0)$ which is a conserved quantity for the exact solution and serves as a benchmark for numerical accuracy. Using the given formula, we find $E(0) \\approx -4.9983 \\times 10^{-4}$.\n\nSince an analytical solution to the three-body problem is generally not available, we must use numerical integration. The problem asks to investigate methods of order $p=1$ and $p=4$.\nFor a method of order $p=1$, the canonical choice is the Forward Euler method. It is an explicit one-step method with a global truncation error of $\\mathcal{O}(h)$. The update rule is:\n$$\nY_{n+1} = Y_n + h F(Y_n)\n$$\nwhere $Y_n$ is the numerical approximation of $Y(t_n)$ at time $t_n=nh$, and $h$ is the step size.\n\nFor a method of order $p=4$, the standard choice is the classical fourth-order Runge-Kutta (RK4) method. It provides a much more accurate solution for a given step size, with a global truncation error of $\\mathcal{O}(h^4)$. Its update rule is:\n\\begin{align*}\nk_1 &= F(Y_n) \\\\\nk_2 &= F(Y_n + \\frac{h}{2} k_1) \\\\\nk_3 &= F(Y_n + \\frac{h}{2} k_2) \\\\\nk_4 &= F(Y_n + h k_3) \\\\\nY_{n+1} &= Y_n + \\frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n\nThe procedure to solve the problem is as follows. For each of the three parameter sets $(p, h, T)$:\n$1.$ Select the numerical method corresponding to the order $p$: Forward Euler for $p=1$ and RK4 for $p=4$.\n$2.$ Starting with the initial state $Y_0 = Y(0)$, iterate the chosen method for $N = T/h$ steps to find the approximate final state $Y_N \\approx Y(T)$.\n$3.$ Using the final state $Y_N$, calculate the final total energy $E(T)$ and the final energy of body $3$, $E_3(T)$, using the provided formulae.\n$4.$ Determine the boolean ejection flag $b = (E_3(T) > 0)$.\n$5.$ Compute the relative total energy error $\\varepsilon = \\frac{|E(T)-E(0)|}{|E(0)|}$, which measures the violation of energy conservation by the numerical method.\n\nThis computational experiment is designed to illustrate a fundamental concept in numerical analysis: the trade-off between computational cost (related to $h$) and accuracy (related to both $h$ and $p$). Comparing Set A ($p=1, h=0.3$) with Set B ($p=4, h=0.3$) demonstrates the significant accuracy gain from increasing the method's order. Comparing Set A with Set C ($p=1, h=0.05$) shows the more modest accuracy improvement achieved by simply reducing the step size for a low-order method. The results will highlight how numerical error propagation can lead not only to quantitative inaccuracies but also to qualitatively different physical outcomes, such as the incorrect prediction of particle ejection.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Newtonian three-body problem for three different parameter sets\n    and reports the ejection status of body 3 and the relative energy error.\n    \"\"\"\n    # System parameters\n    G = 1.0\n    masses = np.array([1.0, 1e-3, 1e-6])\n\n    # Initial conditions\n    r0 = np.array([\n        [0.0, 0.0],\n        [1.0, 0.0],\n        [1.5, 0.0]\n    ])\n    v2_0 = np.array([0.0, 1.0])\n    v3_0 = np.array([0.0, np.sqrt(1.0 / 1.5)])\n    v1_0 = -(masses[1] * v2_0 + masses[2] * v3_0) / masses[0]\n    v0 = np.array([v1_0, v2_0, v3_0])\n    Y0 = np.concatenate((r0.flatten(), v0.flatten()))\n\n    def acceleration(r, m):\n        \"\"\"Computes the acceleration of each body.\"\"\"\n        acc = np.zeros((3, 2))\n        for i in range(3):\n            for j in range(3):\n                if i == j:\n                    continue\n                r_ji = r[j] - r[i]\n                # Add a small softening factor to prevent division by zero in case of close encounters,\n                # though not strictly specified, it's a standard practice for stability.\n                # Here, we will follow the problem statement strictly and risk it.\n                dist_cubed = np.linalg.norm(r_ji)**3\n                if dist_cubed == 0:\n                    # In a real scenario, this would terminate. For this problem,\n                    # this signifies a method failure.\n                    return np.full_like(acc, np.inf)\n                acc[i] += G * m[j] * r_ji / dist_cubed\n        return acc\n\n    def rhs(Y, m):\n        \"\"\"Computes the right-hand side of the ODE system dY/dt = F(Y).\"\"\"\n        r = Y[:6].reshape(3, 2)\n        v = Y[6:].reshape(3, 2)\n        drdt = v\n        dvdt = acceleration(r, m)\n        return np.concatenate((drdt.flatten(), dvdt.flatten()))\n\n    def euler_step(Y, h, m):\n        \"\"\"Performs a single Forward Euler step.\"\"\"\n        return Y + h * rhs(Y, m)\n\n    def rk4_step(Y, h, m):\n        \"\"\"Performs a single RK4 step.\"\"\"\n        k1 = rhs(Y, m)\n        k2 = rhs(Y + 0.5 * h * k1, m)\n        k3 = rhs(Y + 0.5 * h * k2, m)\n        k4 = rhs(Y + h * k3, m)\n        return Y + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def total_energy(Y, m):\n        \"\"\"Calculates the total energy of the system.\"\"\"\n        r = Y[:6].reshape(3, 2)\n        v = Y[6:].reshape(3, 2)\n        kinetic = 0.5 * np.sum(m * np.sum(v**2, axis=1))\n        potential = 0.0\n        for i in range(3):\n            for j in range(i + 1, 3):\n                dist = np.linalg.norm(r[i] - r[j])\n                potential -= G * m[i] * m[j] / dist\n        return kinetic + potential\n\n    def energy_of_body3(Y, m):\n        \"\"\"Calculates the energy of body 3 relative to the others.\"\"\"\n        r = Y[:6].reshape(3, 2)\n        v = Y[6:].reshape(3, 2)\n        kinetic3 = 0.5 * m[2] * np.linalg.norm(v[2])**2\n        potential3 = - (G * m[0] * m[2] / np.linalg.norm(r[2] - r[0])) \\\n                     - (G * m[1] * m[2] / np.linalg.norm(r[2] - r[1]))\n        return kinetic3 + potential3\n\n    def run_simulation(p, h, T):\n        \"\"\"Runs the simulation for a given parameter set.\"\"\"\n        Y = np.copy(Y0)\n        num_steps = int(round(T / h))\n\n        if p == 1:\n            step_func = euler_step\n        elif p == 4:\n            step_func = rk4_step\n        else:\n            raise ValueError(\"Unsupported order p\")\n\n        for _ in range(num_steps):\n            Y = step_func(Y, h, masses)\n\n        E_T = total_energy(Y, masses)\n        E3_T = energy_of_body3(Y, masses)\n        \n        b = E3_T > 0\n        \n        E_0 = total_energy(Y0, masses)\n        epsilon = np.abs(E_T - E_0) / np.abs(E_0)\n        \n        return b, epsilon\n\n    test_cases = [\n        (1, 0.3, 300),   # Set A\n        (4, 0.3, 300),   # Set B\n        (1, 0.05, 300),  # Set C\n    ]\n\n    results = []\n    for p, h, T in test_cases:\n        b, epsilon = run_simulation(p, h, T)\n        results.extend([b, epsilon])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2409137"}]}