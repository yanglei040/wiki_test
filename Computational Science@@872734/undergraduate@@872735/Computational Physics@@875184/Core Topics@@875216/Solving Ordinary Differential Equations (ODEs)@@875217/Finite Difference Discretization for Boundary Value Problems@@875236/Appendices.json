{"hands_on_practices": [{"introduction": "The first step in mastering numerical methods is building a robust and flexible solver. This practice challenges you to construct a general-purpose tool for a wide class of one-dimensional boundary value problems [@problem_id:2392775]. You will learn to discretize a general self-adjoint differential operator and, most importantly, translate diverse physical boundary conditions—Dirichlet, Neumann, and Robin—into the language of linear algebra, correctly formulating the rows of the system matrix. This exercise provides the fundamental machinery for applying the finite difference method to real-world physical models.", "problem": "You are asked to design and implement a general-purpose finite difference solver for a linear, second-order, self-adjoint boundary value problem on a closed interval. The governing equation is the steady one-dimensional linear differential equation in conservation form:\n$$\n- \\frac{d}{dx}\\!\\left(p(x)\\,\\frac{du}{dx}\\right) + q(x)\\,u(x) = r(x), \\quad x \\in [a,b].\n$$\nThe function $u(x)$ is unknown, while $p(x)$, $q(x)$, and $r(x)$ are given functions with $p(x) \\gt 0$ on $[a,b]$. You must support boundary conditions at both $x=a$ and $x=b$ of the following types:\n- Dirichlet: $u = \\text{value}$,\n- Neumann: $u' = \\text{value}$,\n- Robin: $\\alpha\\,u + \\beta\\,u' = \\gamma$, where $\\alpha$, $\\beta$, and $\\gamma$ are given constants.\n\nYour task is to:\n- Derive a stable second-order accurate finite difference discretization of the interior operator based on flux differences, using midpoint evaluations of $p(x)$, and central differences for gradients.\n- Derive second-order accurate one-sided boundary stencils for $u'(a)$ and $u'(b)$ suitable for Neumann and Robin boundary conditions.\n- Implement a solver that accepts arbitrary Python callables for $p(x)$, $q(x)$, and $r(x)$; real numbers $a$, $b$; an integer $N \\ge 2$ specifying the number of subintervals of a uniform grid; and boundary condition specifications at both ends, returning the grid points and the numerical solution vector.\n\nFundamental base you may use for derivations:\n- The definition of the derivative as a limit of difference quotients and standard Taylor expansions.\n- The interpretation of the conservative operator $-\\frac{d}{dx}(p\\,u')$ as the negative divergence of a flux.\n- Widely used central and one-sided finite difference formulas derived from Taylor series.\n\nYour program must validate the solver on the following four test cases, each on a uniform grid of $N$ subintervals with step $h = (b-a)/N$, and must compute the maximum absolute error over the grid compared to the provided analytic solution for each case.\n\nTest Suite:\n- Case $1$ (Dirichlet–Dirichlet, constant $p$, no reaction):\n  - Domain: $[a,b] = [0,1]$, choose $N = 200$.\n  - Coefficients: $p(x) = 1$, $q(x) = 0$, $r(x) = \\sin(\\pi x)$.\n  - Boundary conditions: $u(0) = 0$, $u(1) = 0$.\n  - Analytic solution: $u_\\text{exact}(x) = \\dfrac{\\sin(\\pi x)}{\\pi^2}$.\n- Case $2$ (Dirichlet–Neumann, constant $p$, positive reaction):\n  - Domain: $[a,b] = [0,1]$, choose $N = 200$.\n  - Coefficients: $p(x) = 1$, $q(x) = 1$, $r(x) = 0$.\n  - Boundary conditions: $u(0) = e^0 = 1$, $u'(1) = e^1$.\n  - Analytic solution: $u_\\text{exact}(x) = e^x$.\n- Case $3$ (Robin–Robin, variable $p$ and $q$):\n  - Domain: $[a,b] = [0,1]$, choose $N = 200$.\n  - Coefficients: $p(x) = 1 + x$, $q(x) = x^2$, $r(x) = 1 + 4x + x^3 - x^4$.\n  - Boundary conditions at $x=0$: $\\alpha_L = 2$, $\\beta_L = 1$, $\\gamma_L = 1$; at $x=1$: $\\alpha_R = 3$, $\\beta_R = -1$, $\\gamma_R = 1$.\n  - Analytic solution: $u_\\text{exact}(x) = x(1-x)$.\n- Case $4$ (Neumann–Neumann, constant coefficients with strictly positive reaction to ensure uniqueness):\n  - Domain: $[a,b] = [0,1]$, choose $N = 80$.\n  - Coefficients: $p(x) = 2$, $q(x) = 5$, $r(x) = 7 \\cos(x)$.\n  - Boundary conditions: $u'(0) = 0$, $u'(1) = -\\sin(1)$.\n  - Analytic solution: $u_\\text{exact}(x) = \\cos(x)$.\n\nNumerical requirements and output:\n- Use a uniform grid with $N$ subintervals and $N+1$ nodes, and approximate $p$ at half-nodes using midpoint evaluation $p(x_i \\pm h/2)$.\n- For interior nodes $x_i$, $i \\in \\{1,2,\\dots,N-1\\}$, discretize the conservative form using flux differences to obtain a tri-diagonal contribution.\n- For Neumann and Robin boundary conditions, use the second-order one-sided approximations:\n  - Left derivative: $u'(a) \\approx \\dfrac{-3u_0 + 4u_1 - u_2}{2h}$,\n  - Right derivative: $u'(b) \\approx \\dfrac{3u_N - 4u_{N-1} + u_{N-2}}{2h}$.\n- Your program must compute, for each case, the maximum absolute error over all grid nodes, and then produce a single line of output containing the four errors as a comma-separated list enclosed in square brackets, in the order of cases $1$ through $4$. Express each error as a floating-point number. For consistency, round each error to eight decimal places before printing.", "solution": "The problem presented is a linear, second-order, self-adjoint ordinary differential equation, a form of the Sturm-Liouville problem, defined on a closed interval $[a, b]$ with specified boundary conditions. The governing equation is:\n$$\n- \\frac{d}{dx}\\!\\left(p(x)\\,\\frac{du}{dx}\\right) + q(x)\\,u(x) = r(x)\n$$\nwhere $p(x) > 0$. We are tasked with developing a second-order accurate finite difference solver for this boundary value problem (BVP). The derivation proceeds as follows.\n\nFirst, we establish a uniform computational grid. The domain $[a, b]$ is discretized into $N$ subintervals of equal width $h = (b-a)/N$. This creates $N+1$ grid points, or nodes, indexed from $i=0$ to $i=N$, located at positions $x_i = a + i h$. Our objective is to determine the approximate values of the unknown function $u(x)$ at these nodes, denoted by $u_i \\approx u(x_i)$.\n\nThe core of the method is the discretization of the differential operator at the interior nodes of the grid, i.e., for $i \\in \\{1, 2, \\dots, N-1\\}$. The operator is given in conservative form, which suggests a discretization based on the flux, $F(x) = -p(x) \\frac{du}{dx}$. The differential equation can be written as $-\\frac{dF}{dx} + q(x)u(x) = r(x)$.\n\nAt an interior node $x_i$, we approximate the term $-\\frac{dF}{dx}$ using a central difference on the fluxes evaluated at the midpoints of the grid cells, $x_{i \\pm 1/2} = x_i \\pm h/2$:\n$$\n\\left. -\\frac{dF}{dx} \\right|_{x_i} \\approx -\\frac{F(x_{i+1/2}) - F(x_{i-1/2})}{h}\n$$\nThis is a second-order accurate approximation. The flux $F$ itself must be approximated at these midpoints. We use a central difference for the derivative $\\frac{du}{dx}$ centered at the midpoints:\n$$\n\\left. \\frac{du}{dx} \\right|_{x_{i+1/2}} \\approx \\frac{u(x_{i+1}) - u(x_i)}{h} = \\frac{u_{i+1} - u_i}{h}\n$$\n$$\n\\left. \\frac{du}{dx} \\right|_{x_{i-1/2}} \\approx \\frac{u(x_i) - u(x_{i-1})}{h} = \\frac{u_i - u_{i-1}}{h}\n$$\nThe problem specifies that the coefficient $p(x)$ is evaluated at the midpoints, $p_{i \\pm 1/2} = p(x_{i \\pm 1/2})$. The fluxes are therefore approximated as:\n$$\nF_{i+1/2} \\approx -p_{i+1/2} \\frac{u_{i+1} - u_i}{h}\n$$\n$$\nF_{i-1/2} \\approx -p_{i-1/2} \\frac{u_i - u_{i-1}}{h}\n$$\nSubstituting these flux approximations into the equation for $-\\frac{dF}{dx}$ yields:\n$$\n\\left. -\\frac{dF}{dx} \\right|_{x_i} \\approx -\\frac{1}{h} \\left( -p_{i+1/2} \\frac{u_{i+1} - u_i}{h} - \\left(-p_{i-1/2} \\frac{u_i - u_{i-1}}{h}\\right) \\right) = \\frac{1}{h^2} \\left( p_{i+1/2}(u_{i+1} - u_i) - p_{i-1/2}(u_i - u_{i-1}) \\right)\n$$\nRecombining this with the other terms in the governing equation, evaluated at $x_i$, we get the full discretized equation for an interior node:\n$$\n\\frac{1}{h^2} \\left[ -p_{i-1/2} u_{i-1} + (p_{i-1/2} + p_{i+1/2}) u_i - p_{i+1/2} u_{i+1} \\right] + q(x_i) u_i = r(x_i)\n$$\nBy collecting terms associated with $u_{i-1}$, $u_i$, and $u_{i+1}$, we obtain the linear algebraic equation for row $i$:\n$$\n\\left( -\\frac{p_{i-1/2}}{h^2} \\right) u_{i-1} + \\left( \\frac{p_{i-1/2} + p_{i+1/2}}{h^2} + q_i \\right) u_i + \\left( -\\frac{p_{i+1/2}}{h^2} \\right) u_{i+1} = r_i\n$$\nwhere $q_i = q(x_i)$ and $r_i = r(x_i)$. This provides $N-1$ equations for the $N+1$ unknowns $\\{u_0, u_1, \\dots, u_N\\}$. The remaining two equations are derived from the boundary conditions at $x_0=a$ and $x_N=b$.\n\nWe now form the equations for the boundary nodes, $i=0$ and $i=N$.\n\n**Left Boundary at $x_0 = a$ (Row $0$):**\n- **Dirichlet Condition:** $u(a) = \\gamma_L$.\n  This condition is implemented directly as $u_0 = \\gamma_L$. The first equation is $1 \\cdot u_0 = \\gamma_L$.\n- **Neumann Condition:** $u'(a) = \\gamma_L$.\n  We use the provided second-order accurate one-sided forward difference formula:\n  $$u'(a) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h} = \\gamma_L$$\n  This yields the linear equation: $-3u_0 + 4u_1 - u_2 = 2h\\gamma_L$.\n- **Robin Condition:** $\\alpha_L u(a) + \\beta_L u'(a) = \\gamma_L$.\n  Substituting the same one-sided formula for $u'(a)$:\n  $$\\alpha_L u_0 + \\beta_L \\left(\\frac{-3u_0 + 4u_1 - u_2}{2h}\\right) = \\gamma_L$$\n  Multiplying by $2h$ and grouping terms gives the equation:\n  $$(2h\\alpha_L - 3\\beta_L)u_0 + (4\\beta_L)u_1 - \\beta_L u_2 = 2h\\gamma_L$$\n\n**Right Boundary at $x_N = b$ (Row $N$):**\n- **Dirichlet Condition:** $u(b) = \\gamma_R$.\n  This is simply $u_N = \\gamma_R$. The last equation is $1 \\cdot u_N = \\gamma_R$.\n- **Neumann Condition:** $u'(b) = \\gamma_R$.\n  We use the provided second-order accurate one-sided backward difference formula:\n  $$u'(b) \\approx \\frac{3u_N - 4u_{N-1} + u_{N-2}}{2h} = \\gamma_R$$\n  This yields the linear equation: $u_{N-2} - 4u_{N-1} + 3u_N = 2h\\gamma_R$.\n- **Robin Condition:** $\\alpha_R u(b) + \\beta_R u'(b) = \\gamma_R$.\n  Substituting the one-sided formula for $u'(b)$:\n  $$\\alpha_R u_N + \\beta_R \\left(\\frac{3u_N - 4u_{N-1} + u_{N-2}}{2h}\\right) = \\gamma_R$$\n  Multiplying by $2h$ and grouping terms gives the equation:\n  $$\\beta_R u_{N-2} - (4\\beta_R)u_{N-1} + (2h\\alpha_R + 3\\beta_R)u_N = 2h\\gamma_R$$\n\nThese equations collectively form a system of $N+1$ linear equations in $N+1$ unknowns, which can be written in matrix form as $A\\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u} = [u_0, u_1, \\dots, u_N]^T$. The matrix $A$ and vector $\\mathbf{b}$ are constructed row by row.\n\n- **Rows $i=1, \\dots, N-1$ (Interior):**\n  $A_{i, i-1} = -p_{i-1/2}/h^2$\n  $A_{i, i} = (p_{i-1/2} + p_{i+1/2})/h^2 + q_i$\n  $A_{i, i+1} = -p_{i+1/2}/h^2$\n  $b_i = r_i$\n\n- **Row $0$ (Left Boundary):**\n  - Dirichlet ($\\gamma_L$): $A_{0,0}=1$, $b_0=\\gamma_L$.\n  - Neumann ($\\gamma_L$): $A_{0,0}=-3$, $A_{0,1}=4$, $A_{0,2}=-1$, $b_0=2h\\gamma_L$.\n  - Robin ($\\alpha_L, \\beta_L, \\gamma_L$): $A_{0,0}=2h\\alpha_L-3\\beta_L$, $A_{0,1}=4\\beta_L$, $A_{0,2}=-\\beta_L$, $b_0=2h\\gamma_L$.\n\n- **Row $N$ (Right Boundary):**\n  - Dirichlet ($\\gamma_R$): $A_{N,N}=1$, $b_N=\\gamma_R$.\n  - Neumann ($\\gamma_R$): $A_{N,N-2}=1$, $A_{N,N-1}=-4$, $A_{N,N}=3$, $b_N=2h\\gamma_R$.\n  - Robin ($\\alpha_R, \\beta_R, \\gamma_R$): $A_{N,N-2}=\\beta_R$, $A_{N,N-1}=-4\\beta_R$, $A_{N,N}=2h\\alpha_R+3\\beta_R$, $b_N=2h\\gamma_R$.\n\nAll other elements of $A$ are zero. The resulting matrix $A$ is sparse and banded. For the specified problem parameters, this system is non-singular and has a unique solution $\\mathbf{u} = A^{-1}\\mathbf{b}$, which can be found using a standard linear algebra solver.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_bvp(p, q, r, a, b, N, bc_left, bc_right):\n    \"\"\"\n    Solves a linear, second-order, self-adjoint BVP using finite differences.\n\n    Equation: -(p(x)u')' + q(x)u(x) = r(x) on [a, b]\n\n    Args:\n        p (callable): Coefficient function p(x).\n        q (callable): Coefficient function q(x).\n        r (callable): Source function r(x).\n        a (float): Left boundary of the domain.\n        b (float): Right boundary of the domain.\n        N (int): Number of subintervals in the uniform grid.\n        bc_left (tuple): Left boundary condition.\n            - ('dirichlet', gamma): u(a) = gamma\n            - ('neumann', gamma): u'(a) = gamma\n            - ('robin', alpha, beta, gamma): alpha*u(a) + beta*u'(a) = gamma\n        bc_right (tuple): Right boundary condition (similar format).\n\n    Returns:\n        tuple: (x, u) where x is the grid and u is the numerical solution.\n    \"\"\"\n    if N < 2:\n        raise ValueError(\"N must be at least 2.\")\n\n    h = (b - a) / N\n    x = np.linspace(a, b, N + 1)\n    \n    A = np.zeros((N + 1, N + 1))\n    rhs = np.zeros(N + 1)\n\n    # Interior points (i = 1, ..., N-1)\n    for i in range(1, N):\n        x_i = x[i]\n        p_minus_half = p(x_i - h / 2)\n        p_plus_half = p(x_i + h / 2)\n        \n        A[i, i-1] = -p_minus_half / h**2\n        A[i, i] = (p_minus_half + p_plus_half) / h**2 + q(x_i)\n        A[i, i+1] = -p_plus_half / h**2\n        rhs[i] = r(x_i)\n\n    # Left boundary condition (i = 0)\n    bc_type_left = bc_left[0]\n    if bc_type_left == 'dirichlet':\n        gamma_L = bc_left[1]\n        A[0, 0] = 1\n        rhs[0] = gamma_L\n    elif bc_type_left == 'neumann':\n        gamma_L = bc_left[1]\n        A[0, 0] = -3\n        A[0, 1] = 4\n        A[0, 2] = -1\n        rhs[0] = 2 * h * gamma_L\n    elif bc_type_left == 'robin':\n        alpha_L, beta_L, gamma_L = bc_left[1:]\n        A[0, 0] = 2 * h * alpha_L - 3 * beta_L\n        A[0, 1] = 4 * beta_L\n        A[0, 2] = -beta_L\n        rhs[0] = 2 * h * gamma_L\n    else:\n        raise ValueError(f\"Unknown left boundary condition type: {bc_type_left}\")\n\n    # Right boundary condition (i = N)\n    bc_type_right = bc_right[0]\n    if bc_type_right == 'dirichlet':\n        gamma_R = bc_right[1]\n        A[N, N] = 1\n        rhs[N] = gamma_R\n    elif bc_type_right == 'neumann':\n        gamma_R = bc_right[1]\n        A[N, N-2] = 1\n        A[N, N-1] = -4\n        A[N, N] = 3\n        rhs[N] = 2 * h * gamma_R\n    elif bc_type_right == 'robin':\n        alpha_R, beta_R, gamma_R = bc_right[1:]\n        A[N, N-2] = beta_R\n        A[N, N-1] = -4 * beta_R\n        A[N, N] = 2 * h * alpha_R + 3 * beta_R\n        rhs[N] = 2 * h * gamma_R\n    else:\n        raise ValueError(f\"Unknown right boundary condition type: {bc_type_right}\")\n\n    u = np.linalg.solve(A, rhs)\n    return x, u\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (Dirichlet–Dirichlet)\n        {\n            'a': 0.0, 'b': 1.0, 'N': 200,\n            'p': lambda x: 1.0,\n            'q': lambda x: 0.0,\n            'r': lambda x: np.sin(np.pi * x),\n            'bc_left': ('dirichlet', 0.0),\n            'bc_right': ('dirichlet', 0.0),\n            'u_exact': lambda x: np.sin(np.pi * x) / (np.pi**2)\n        },\n        # Case 2 (Dirichlet–Neumann)\n        {\n            'a': 0.0, 'b': 1.0, 'N': 200,\n            'p': lambda x: 1.0,\n            'q': lambda x: 1.0,\n            'r': lambda x: 0.0,\n            'bc_left': ('dirichlet', 1.0),\n            'bc_right': ('neumann', np.e),\n            'u_exact': lambda x: np.exp(x)\n        },\n        # Case 3 (Robin–Robin)\n        {\n            'a': 0.0, 'b': 1.0, 'N': 200,\n            'p': lambda x: 1.0 + x,\n            'q': lambda x: x**2,\n            'r': lambda x: 1.0 + 4.0*x + x**3 - x**4,\n            'bc_left': ('robin', 2.0, 1.0, 1.0),\n            'bc_right': ('robin', 3.0, -1.0, 1.0),\n            'u_exact': lambda x: x * (1.0 - x)\n        },\n        # Case 4 (Neumann–Neumann)\n        {\n            'a': 0.0, 'b': 1.0, 'N': 80,\n            'p': lambda x: 2.0,\n            'q': lambda x: 5.0,\n            'r': lambda x: 7.0 * np.cos(x),\n            'bc_left': ('neumann', 0.0),\n            'bc_right': ('neumann', -np.sin(1.0)),\n            'u_exact': lambda x: np.cos(x)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        x_grid, u_numerical = solve_bvp(\n            p=case['p'],\n            q=case['q'],\n            r=case['r'],\n            a=case['a'],\n            b=case['b'],\n            N=case['N'],\n            bc_left=case['bc_left'],\n            bc_right=case['bc_right']\n        )\n        \n        u_analytic = case['u_exact'](x_grid)\n        \n        # Compute maximum absolute error\n        max_abs_error = np.max(np.abs(u_numerical - u_analytic))\n        \n        # Round to 8 decimal places as required\n        results.append(round(max_abs_error, 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2392775"}, {"introduction": "With a solid foundation in one dimension, we can now extend our methods to higher-dimensional space. This practice tackles the classic two-dimensional Laplace equation, a cornerstone of fields like electrostatics, heat transfer, and fluid dynamics [@problem_id:2392730]. The key takeaway is understanding how the one-dimensional three-point stencil generalizes to the two-dimensional five-point stencil and mastering the crucial skill of mapping a 2D grid of unknowns into a 1D vector to construct the matrix equation.", "problem": "Consider the electrostatic potential field inside a square region governed by electrostatics in the absence of free charge. The fundamental base is that, in electrostatics, the electric field satisfies $ \\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0 $ and $ \\mathbf{E} = -\\nabla \\phi $. For a region with $ \\rho = 0 $ (no free charge), the potential $ \\phi(x,y) $ satisfies the two-dimensional Laplace equation $ \\nabla^2 \\phi = 0 $ with Dirichlet boundary conditions (fixed values of the potential on the boundary). You are to discretize this boundary value problem using the Finite Difference Method (FDM) with second-order central differences to obtain a linear system for the interior grid values and solve it numerically.\n\nA square box of side length $ L $ (in meters) has its right wall at $ x = L $ held at a fixed potential $ V_0 $ (in volts), while the other three walls at $ x = 0 $, $ y = 0 $, and $ y = L $ are grounded at $ 0 $ volts. Use a uniform grid of $ N $ grid points per direction, including the boundaries, so the grid spacing is $ h = L / (N-1) $. Let $ \\phi_{i,j} $ denote the discrete potential at the grid point $ (x_i, y_j) = (i h, j h) $, where $ i, j \\in \\{0, 1, \\dots, N-1\\} $. The interior unknowns are those with $ i, j \\in \\{1, 2, \\dots, N-2\\} $. Using second-order central differences to approximate $ \\nabla^2 \\phi $, formulate the resulting linear system for the interior values $ \\phi_{i,j} $, enforce the Dirichlet boundary conditions on the four walls, and solve for the potential.\n\nYour program must:\n- Construct the five-point stencil discrete Laplace operator corresponding to the second-order central difference approximation on a uniform grid.\n- Incorporate the boundary values into the right-hand side consistently with Dirichlet boundary conditions, where the right wall at $ x=L $ has $ \\phi = V_0 $ and the other three walls have $ \\phi = 0 $.\n- Solve the linear system for the interior unknowns.\n- Extract and report the potential at the geometric center $ (x,y) = (L/2, L/2) $. Assume $ N $ is odd so that the geometric center coincides with a grid point. Report the center value in volts.\n\nPhysical units: potentials must be reported in volts, expressed as decimal floats rounded to six decimals.\n\nAngle units: no angles are involved.\n\nYour program should use the following test suite, each specified as a tuple $ (L, N, V_0) $ with $ L $ in meters and $ V_0 $ in volts:\n- Test $ 1 $: $ (L, N, V_0) = (1.0, 3, 1.0) $\n- Test $ 2 $: $ (L, N, V_0) = (1.0, 5, 1.0) $\n- Test $ 3 $: $ (L, N, V_0) = (1.0, 21, 2.0) $\n\nFor each test, compute a single float: the value of $ \\phi $ at the geometric center in volts, rounded to six decimals. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the tests above. For example, the format must be exactly like $ [r_1,r_2,r_3] $ where each $ r_k $ is a decimal float with six digits after the decimal point.", "solution": "The problem presented is a classic boundary value problem in electrostatics, specifically the solution of the two-dimensional Laplace equation in a square domain with specified Dirichlet boundary conditions. The problem is scientifically grounded, well-posed, and contains all necessary information for a numerical solution. It is therefore deemed valid.\n\nThe governing partial differential equation for the electrostatic potential $\\phi(x,y)$ in a charge-free region ($\\rho=0$) is the Laplace equation:\n$$\n\\nabla^2 \\phi(x,y) = \\frac{\\partial^2 \\phi}{\\partial x^2} + \\frac{\\partial^2 \\phi}{\\partial y^2} = 0\n$$\nThe domain is a square of side length $L$, defined by $x \\in [0, L]$ and $y \\in [0, L]$. The boundary conditions are of the Dirichlet type, meaning the potential is fixed on the boundaries:\n- $\\phi(x,0) = 0$ (bottom wall)\n- $\\phi(x,L) = 0$ (top wall)\n- $\\phi(0,y) = 0$ (left wall)\n- $\\phi(L,y) = V_0$ (right wall)\n\nTo solve this problem numerically, we employ the Finite Difference Method (FDM). First, the continuous domain is discretized into a uniform grid of points $(x_i, y_j)$, where $x_i = i h$ and $y_j = j h$. The grid spacing $h$ is given by $h = L / (N-1)$, where $N$ is the number of grid points in each direction. The grid indices $i$ and $j$ range from $0$ to $N-1$. The potential at a grid point $(x_i, y_j)$ is denoted by $\\phi_{i,j}$.\n\nThe second-order partial derivatives are approximated using second-order central difference formulas:\n$$\n\\frac{\\partial^2 \\phi}{\\partial x^2}\\bigg|_{(x_i,y_j)} \\approx \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{h^2}\n$$\n$$\n\\frac{\\partial^2 \\phi}{\\partial y^2}\\bigg|_{(x_i,y_j)} \\approx \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{h^2}\n$$\nSubstituting these approximations into the Laplace equation for each interior grid point, where $i, j \\in \\{1, 2, \\dots, N-2\\}$, yields:\n$$\n\\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{h^2} + \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{h^2} = 0\n$$\nMultiplying by $h^2$ and rearranging terms gives the five-point stencil equation, which states that the potential at an interior point is the average of the potentials at its four nearest neighbors:\n$$\n4\\phi_{i,j} - \\phi_{i+1,j} - \\phi_{i-1,j} - \\phi_{i,j+1} - \\phi_{i,j-1} = 0\n$$\nThis equation must hold for all $M = (N-2)^2$ interior points. This set of equations forms a system of linear equations of the form $A\\vec{\\Phi} = \\vec{b}$, where $\\vec{\\Phi}$ is a vector containing the unknown potentials $\\phi_{i,j}$ for the interior points.\n\nTo construct the system, we must flatten the two-dimensional grid of unknowns into a one-dimensional vector $\\vec{\\Phi}$. A consistent mapping is required. We use a column-major ordering where the index $k$ for the unknown $\\phi_{i,j}$ (where $i, j \\in \\{1, \\dots, N-2\\}$) is given by $k = (i-1)(N-2) + (j-1)$.\n\nThe matrix $A$ is an $M \\times M$ matrix representing the coefficients of the unknown potentials. The vector $\\vec{b}$ of size $M$ contains terms resulting from the known boundary values. The equation for an interior point $(i,j)$ is rearranged as:\n$$\n4\\phi_{i,j} - \\phi_{i-1,j} - \\phi_{i+1,j} - \\phi_{i,j-1} - \\phi_{i,j+1} = b_{i,j}\n$$\nWhen a neighboring point $(i', j')$ lies on a boundary, its potential $\\phi_{i',j'}$ is known. This term is moved to the right-hand side of the equation.\n- For points adjacent to the left wall ($i=1$), the term $\\phi_{0,j}=0$ is known.\n- For points adjacent to the bottom wall ($j=1$), the term $\\phi_{i,0}=0$ is known.\n- For points adjacent to the top wall ($j=N-2$), the term $\\phi_{i,N-1}=0$ is known.\nThese zero-potential boundaries contribute nothing to the right-hand side vector $\\vec{b}$.\n- For points adjacent to the right wall ($i=N-2$), the term $\\phi_{N-1,j}=V_0$ is known. The equation for such a point becomes $4\\phi_{N-2,j} - \\phi_{N-3,j} - \\phi_{N-2,j-1} - \\phi_{N-2,j+1} = V_0$.\n\nThus, the components of the vector $\\vec{b}$ are zero for all points except those adjacent to the right wall (where $i = N-2$), for which the value is $V_0$. The matrix $A$ has a sparse, block-tridiagonal structure with $4$ on the main diagonal and $-1$ on certain off-diagonals corresponding to the neighboring points in the grid.\n\nOnce the matrix $A$ and vector $\\vec{b}$ are constructed, the linear system $A\\vec{\\Phi} = \\vec{b}$ is solved for the vector of unknown potentials $\\vec{\\Phi}$.\n\nThe final step is to extract the potential at the geometric center of the square, $(L/2, L/2)$. Since $N$ is specified to be odd, the center coincides with a grid point $(x_{i_c}, y_{j_c})$, where the indices are $i_c = j_c = (N-1)/2$. These indices fall within the range of interior points, $\\{1, \\dots, N-2\\}$, for $N \\ge 3$. The potential at this point is one of the elements of the solution vector $\\vec{\\Phi}$, which can be located using the same index mapping.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_laplace(L, N, V0):\n    \"\"\"\n    Solves the 2D Laplace equation on a square grid using the Finite Difference Method.\n\n    Args:\n        L (float): Side length of the square domain in meters.\n        N (int): Number of grid points in each direction.\n        V0 (float): Potential on the right wall in volts.\n\n    Returns:\n        float: The potential at the geometric center of the grid.\n    \"\"\"\n    # Number of interior grid points in one dimension.\n    N_int = N - 2\n\n    # If N <= 2, there are no interior points to solve for.\n    if N_int <= 0:\n        # A grid with N=1 or N=2 has no interior. The problem statement implies N>=3.\n        # For N=3, the center is the only interior point. Its value can be calculated\n        # as V0/4. A general solution is implemented anyway.\n        if N == 1: # A single point can't have these conflicting BCs.\n           return 0.0\n        return 0.0\n\n    # Total number of unknown interior potentials.\n    M = N_int * N_int\n\n    # Initialize the matrix A and vector b for the linear system A*phi = b.\n    A = np.zeros((M, M))\n    b = np.zeros(M)\n\n    # Function to map 2D interior grid indices (ii, jj) to a 1D vector index k.\n    # We use 0-indexed interior indices: ii, jj in [0, N_int-1].\n    # These correspond to original grid indices i=ii+1, j=jj+1.\n    # The mapping is column-major for consistency with (x,y) -> (i,j).\n    map_k = lambda ii, jj: ii * N_int + jj\n\n    for ii in range(N_int):  # Corresponds to x-direction grid index i = ii + 1\n        for jj in range(N_int):  # Corresponds to y-direction grid index j = jj + 1\n            k = map_k(ii, jj)\n\n            # The discrete Laplace equation is:\n            # 4*phi_i,j - phi_i-1,j - phi_i+1,j - phi_i,j-1 - phi_i,j+1 = 0\n            # We move known boundary values to the right-hand side (vector b).\n\n            # Main diagonal from the term 4*phi_i,j\n            A[k, k] = 4\n\n            # Neighbor in negative x-direction (i-1, j)\n            if ii > 0:  # Neighbor is an interior point\n                A[k, map_k(ii - 1, jj)] = -1\n            else:  # Neighbor is on the boundary x=0 (i=0), where phi=0\n                b[k] += 0.0\n\n            # Neighbor in positive x-direction (i+1, j)\n            if ii < N_int - 1:  # Neighbor is an interior point\n                A[k, map_k(ii + 1, jj)] = -1\n            else:  # Neighbor is on the boundary x=L (i=N-1), where phi=V0\n                b[k] += V0\n\n            # Neighbor in negative y-direction (i, j-1)\n            if jj > 0:  # Neighbor is an interior point\n                A[k, map_k(ii, jj - 1)] = -1\n            else:  # Neighbor is on the boundary y=0 (j=0), where phi=0\n                b[k] += 0.0\n\n            # Neighbor in positive y-direction (i, j+1)\n            if jj < N_int - 1:  # Neighbor is an interior point\n                A[k, map_k(ii, jj + 1)] = -1\n            else:  # Neighbor is on the boundary y=L (j=N-1), where phi=0\n                b[k] += 0.0\n    \n    # Solve the linear system for the unknown interior potentials.\n    phi_sol = np.linalg.solve(A, b)\n\n    # Find the potential at the geometric center.\n    # Since N is odd, the center (L/2, L/2) is a grid point.\n    center_grid_idx = (N - 1) // 2\n    \n    # Convert grid index to 0-indexed interior index.\n    ii_center = center_grid_idx - 1\n    jj_center = center_grid_idx - 1\n    \n    # Get the 1D vector index for the center point.\n    k_center = map_k(ii_center, jj_center)\n\n    return phi_sol[k_center]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 3, 1.0),\n        (1.0, 5, 1.0),\n        (1.0, 21, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, V0 = case\n        center_potential = solve_laplace(L, N, V0)\n        # Round the result to six decimal places as required.\n        results.append(f\"{center_potential:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2392730"}, {"introduction": "Obtaining a numerical solution is only half the battle; understanding and improving its accuracy is just as critical. This exercise introduces Richardson extrapolation, a powerful and elegant technique for enhancing the precision of your results [@problem_id:2392773]. By combining solutions computed on two different grid resolutions, you can systematically cancel out the leading-order error term, achieving a higher order of convergence. This practice moves beyond simply finding an answer to developing a more refined and accurate numerical solution.", "problem": "Consider the two-point boundary value problem on the unit interval: find a function $u(x)$ such that\n$$\nu''(x) = -\\sin(\\pi x), \\quad x \\in (0,1), \\qquad u(0)=0,\\quad u(1)=0,\n$$\nwhere $\\sin(\\cdot)$ uses angles in radians. Let $n$ denote the number of interior grid points on a uniform mesh of $[0,1]$ with grid spacing $h = \\frac{1}{n+1}$ and nodes $x_i = i h$ for $i=0,1,\\ldots,n+1$. Approximate $u''(x)$ by the standard second-order centered finite difference on this mesh, enforce the Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$ exactly, and solve the resulting linear system for the interior unknowns.\n\nNext, refine the mesh by halving the grid spacing (i.e., use a mesh with $m = 2n+1$ interior points so that the refined spacing is $h/2$ and refined interior nodes coincide with the coarse ones). Solve the same discrete problem on the refined mesh. Use Richardson extrapolation, assuming a leading truncation error proportional to $h^2$, to combine the two numerical solutions and obtain a higher-accuracy approximation on the coarse mesh interior nodes.\n\nUse the exact analytical solution $u_{\\text{exact}}(x) = \\dfrac{\\sin(\\pi x)}{\\pi^2}$ to quantify accuracy. For each test case specified below, compute the maximum absolute error of the Richardson-extrapolated solution evaluated at the coarse mesh interior nodes, i.e.,\n$$\nE_\\infty = \\max_{1 \\le i \\le n} \\left| u_{\\text{RE}}(x_i) - \\frac{\\sin(\\pi x_i)}{\\pi^2} \\right|.\n$$\n\nTest suite:\n- Case $1$: $n=1$.\n- Case $2$: $n=4$.\n- Case $3$: $n=10$.\n\nFinal output format:\nYour program should produce a single line of output containing the three results $E_\\infty$ for the cases listed above, in order, as a comma-separated list enclosed in square brackets (for example, $[e_1,e_2,e_3]$). Each $e_k$ must be a real number (a floating-point value). No additional text should be printed.", "solution": "The problem presented is a well-posed, two-point boundary value problem (BVP) from the field of differential equations. It is scientifically grounded and contains all necessary information for obtaining a unique numerical solution. The proposed method, employing finite differences and Richardson extrapolation, is a standard and valid technique in computational physics. Therefore, the problem is valid, and a solution will be presented.\n\nThe problem is to find a function $u(x)$ satisfying the following second-order ordinary differential equation and boundary conditions:\n$$\nu''(x) = -\\sin(\\pi x), \\quad x \\in (0,1)\n$$\n$$\nu(0)=0, \\quad u(1)=0\n$$\nThe analytical solution is given as $u_{\\text{exact}}(x) = \\dfrac{\\sin(\\pi x)}{\\pi^2}$, which can be verified by direct differentiation and substitution.\n\nThe first step is to discretize the domain $[0,1]$ using a uniform mesh. For a given integer $n$, we define $n$ interior grid points. The grid spacing is $h = \\frac{1}{n+1}$, and the grid nodes are $x_i = ih$ for $i=0, 1, \\ldots, n+1$. The values of the solution at these nodes are denoted by $u_i = u(x_i)$. The boundary conditions dictate that $u_0 = 0$ and $u_{n+1} = 0$. We seek to find the unknown values $u_i$ for $i=1, 2, \\ldots, n$.\n\nThe second derivative $u''(x)$ at an interior node $x_i$ is approximated using a second-order accurate centered finite difference formula:\n$$\nu''(x_i) \\approx \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} = \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\nSubstituting this approximation into the original differential equation yields a system of algebraic equations for the unknowns $u_i$:\n$$\n\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = -\\sin(\\pi x_i), \\quad \\text{for } i = 1, 2, \\ldots, n\n$$\nRearranging this equation, we obtain:\n$$\nu_{i-1} - 2u_i + u_{i+1} = -h^2 \\sin(\\pi x_i)\n$$\nIncorporating the boundary conditions ($u_0=0$ and $u_{n+1}=0$), we can write out the equations for the first and last interior nodes:\nFor $i=1$: $u_0 - 2u_1 + u_2 = -h^2 \\sin(\\pi x_1) \\implies -2u_1 + u_2 = -h^2 \\sin(\\pi x_1)$.\nFor $i=n$: $u_{n-1} - 2u_n + u_{n+1} = -h^2 \\sin(\\pi x_n) \\implies u_{n-1} - 2u_n = -h^2 \\sin(\\pi x_n)$.\n\nThese $n$ equations form a system of linear equations of the form $A \\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u} = [u_1, u_2, \\ldots, u_n]^T$ is the vector of unknown solution values at the interior nodes. The matrix $A$ is an $n \\times n$ symmetric, tridiagonal matrix, and the vector $\\mathbf{b}$ is the right-hand side.\n$$\nA = \\begin{pmatrix}\n-2 & 1 & 0 & \\cdots & 0 \\\\\n1 & -2 & 1 & \\cdots & 0 \\\\\n0 & 1 & -2 & \\ddots & \\vdots \\\\\n\\vdots & \\vdots & \\ddots & -2 & 1 \\\\\n0 & 0 & \\cdots & 1 & -2\n\\end{pmatrix}, \\quad \\mathbf{b} = -h^2 \\begin{pmatrix}\n\\sin(\\pi x_1) \\\\\n\\sin(\\pi x_2) \\\\\n\\vdots \\\\\n\\sin(\\pi x_n)\n\\end{pmatrix}\n$$\nThis linear system is diagonally dominant and therefore has a unique solution which can be found using standard numerical linear algebra methods.\n\nThe problem requires using Richardson extrapolation to improve the accuracy of the solution. The centered difference scheme has a global error that has an asymptotic expansion in even powers of $h$:\n$$\nu_h(x) = u_{\\text{exact}}(x) + C_1(x)h^2 + C_2(x)h^4 + \\dots\n$$\nwhere $u_h(x)$ is the numerical solution at point $x$ computed with grid spacing $h$.\n\nWe compute two numerical solutions:\n1. A coarse solution, $\\mathbf{u}_h$, on a grid with $n$ interior points and spacing $h = \\frac{1}{n+1}$.\n2. A fine solution, $\\mathbf{u}_{h/2}$, on a grid with $m = 2n+1$ interior points and spacing $h/2 = \\frac{1}{m+1}$.\n\nAt a coarse grid node $x_i$, we have the following approximations for the exact solution $u_{\\text{exact}}(x_i)$:\n$$\nu_h(x_i) \\approx u_{\\text{exact}}(x_i) + C_1(x_i)h^2\n$$\n$$\nu_{h/2}(x_i) \\approx u_{\\text{exact}}(x_i) + C_1(x_i)(h/2)^2 = u_{\\text{exact}}(x_i) + \\frac{1}{4}C_1(x_i)h^2\n$$\nWe can eliminate the leading error term $C_1(x_i)h^2$ by algebraically combining these two expressions. Multiplying the second equation by $4$ and subtracting the first gives:\n$$\n4u_{h/2}(x_i) - u_h(x_i) \\approx 3u_{\\text{exact}}(x_i)\n$$\nThis leads to the Richardson-extrapolated solution $u_{\\text{RE}}(x_i)$, which has an error of order $O(h^4)$:\n$$\nu_{\\text{RE}}(x_i) = \\frac{4u_{h/2}(x_i) - u_h(x_i)}{3}\n$$\nThis extrapolation is performed for each node $x_i$ on the coarse grid, $i = 1, \\ldots, n$. Note that the coarse grid nodes $\\{x_i\\}$ are a subset of the fine grid nodes. Specifically, the coarse node $x_i = i h$ corresponds to the fine grid node at the same position, which is the $(2i)$-th interior node on the fine mesh.\n\nThe final step is to quantify the accuracy of the extrapolated solution. For each test case, we compute the maximum absolute error $E_\\infty$ over the coarse interior grid points:\n$$\nE_\\infty = \\max_{1 \\le i \\le n} \\left| u_{\\text{RE}}(x_i) - u_{\\text{exact}}(x_i) \\right| = \\max_{1 \\le i \\le n} \\left| u_{\\text{RE}}(x_i) - \\frac{\\sin(\\pi x_i)}{\\pi^2} \\right|\n$$\nThe computational procedure for each test value of $n$ is as follows:\n1.  Solve the BVP for the coarse grid with $n$ interior points to get $\\mathbf{u}_h$.\n2.  Solve the BVP for the fine grid with $m=2n+1$ interior points to get $\\mathbf{u}_{h/2}$.\n3.  Extract the values from $\\mathbf{u}_{h/2}$ that correspond to the coarse grid locations.\n4.  Compute the Richardson-extrapolated solution vector $\\mathbf{u}_{\\text{RE}}$.\n5.  Compute the exact solution at the coarse grid points.\n6.  Calculate the maximum absolute error $E_\\infty$.\n\nThis procedure will be implemented for the specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_bvp(n):\n    \"\"\"\n    Solves the BVP u''(x) = -sin(pi*x) on [0,1] with u(0)=u(1)=0\n    using a centered finite difference scheme with n interior points.\n\n    Args:\n        n (int): The number of interior grid points.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The solution vector u at the interior points.\n            - np.ndarray: The x-coordinates of the interior points.\n    \"\"\"\n    if n == 0:\n        return np.array([]), np.array([])\n    \n    # Grid spacing\n    h = 1.0 / (n + 1)\n    \n    # Interior grid points\n    x_interior = np.linspace(h, 1.0 - h, n)\n    \n    # Construct the right-hand side vector b\n    b = -h**2 * np.sin(np.pi * x_interior)\n    \n    # Construct the tridiagonal matrix A\n    A = np.diag(-2 * np.ones(n)) + np.diag(np.ones(n - 1), k=1) + np.diag(np.ones(n - 1), k=-1)\n    \n    # Solve the linear system Au = b\n    u = np.linalg.solve(A, b)\n    \n    return u, x_interior\n\ndef solve():\n    \"\"\"\n    Main driver function to solve the problem for all test cases and print the result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 4, 10]\n\n    results = []\n    for n in test_cases:\n        # 1. Solve on coarse mesh\n        u_coarse, x_coarse = solve_bvp(n)\n        \n        # 2. Solve on fine mesh\n        m = 2 * n + 1\n        u_fine, _ = solve_bvp(m)\n        \n        # 3. Extract fine solution at coarse grid points\n        # The coarse grid points correspond to every second point of the fine grid's interior.\n        # Python indices are 0-based. The i-th coarse point (i=0 to n-1) is at the same\n        # spatial location as the (2i+1)-th fine point (index 2i+1).\n        # This corresponds to slicing u_fine with [1::2].\n        u_fine_at_coarse_points = u_fine[1::2]\n\n        # 4. Apply Richardson extrapolation\n        # u_RE = (4 * u_h/2 - u_h) / 3\n        u_re = (4.0 * u_fine_at_coarse_points - u_coarse) / 3.0\n        \n        # 5. Compute exact solution at coarse grid points\n        u_exact = np.sin(np.pi * x_coarse) / (np.pi**2)\n        \n        # 6. Calculate the maximum absolute error\n        max_error = np.max(np.abs(u_re - u_exact))\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2392773"}]}