{"hands_on_practices": [{"introduction": "Before diving into the complexities of a full Monte Carlo simulation, a skilled physicist first develops an intuition for the model's behavior in limiting cases. This practice focuses on sharpening that physical intuition by analyzing special, analytically solvable scenarios of the Ising model. By considering conditions such as zero interaction ($J=0$), zero temperature ($T=0$), or zero external field ($h=0$), you can predict the system's equilibrium state using fundamental principles of statistical mechanics, providing essential benchmarks for any computational approach [@problem_id:2413215].", "problem": "Consider a two-dimensional Ising model on a square lattice of side length $L$ with periodic boundary conditions. Each site $i$ carries a binary spin $s_i \\in \\{-1,+1\\}$, interpreted as a Susceptible-Infected-Susceptible (SIS) model, where $s_i=+1$ denotes \"infected\" and $s_i=-1$ denotes \"susceptible.\" The energy of a configuration $\\{s_i\\}$ is given by the Hamiltonian\n$$\nH(\\{s_i\\})=-J\\sum_{\\langle i,j\\rangle} s_i s_j - h \\sum_i s_i,\n$$\nwhere $J$ is the nearest-neighbor interaction strength, $\\langle i,j\\rangle$ denotes unordered nearest-neighbor pairs on the lattice, and $h$ is a uniform external field. Assume Boltzmann statistics at temperature $T$ with Boltzmann constant set to $k_{\\mathrm{B}}=1$ (so $T$ is dimensionless). The thermodynamic equilibrium average of any observable $\\mathcal{O}(\\{s_i\\})$ is taken with respect to the Boltzmann weight $\\exp(-H/T)$.\n\nInterpretation in terms of disease dynamics: a positive coupling $J>0$ biases neighboring sites to align, so an infected neighbor ($s_j=+1$) lowers the energy cost of $s_i=+1$, modeling higher transmission likelihood; a negative field $h<0$ biases spins toward $s_i=-1$, modeling a recovery pressure toward susceptibility. Define the infected fraction to be\n$$\nf=\\frac{1}{N}\\sum_{i=1}^{N}\\frac{s_i+1}{2}=\\frac{1}{2}\\left(1+\\frac{1}{N}\\sum_{i=1}^{N}s_i\\right),\n$$\nwhere $N=L^2$ is the number of lattice sites. The goal is to compute the equilibrium value of $f$ for specified parameters.\n\nTest Suite:\nFor each of the following parameter quadruples $(L,J,h,T)$, compute the equilibrium infected fraction $f$ as a real number and round the result to exactly $6$ decimal places using standard rounding rules.\n- Case $1$: $(L,J,h,T)=(\\,10,\\,0.0,\\,0.7,\\,2.5\\,)$.\n- Case $2$: $(L,J,h,T)=(\\,10,\\,1.0,\\,-0.3,\\,0.0\\,)$.\n- Case $3$: $(L,J,h,T)=(\\,10,\\,1.0,\\,0.3,\\,0.0\\,)$.\n- Case $4$: $(L,J,h,T)=(\\,9,\\,0.9,\\,0.0,\\,1.7\\,)$.\n\nYour program must produce a single line of output containing the results for the four cases in the order listed, formatted as a comma-separated list enclosed in square brackets, for example, $[x_1,x_2,x_3,x_4]$, where each $x_k$ is a float rounded to exactly $6$ decimal places. No additional text should be printed.\n\nAll quantities are dimensionless (no physical units). Angles are not used. Percentages must be expressed as decimal fractions (for instance, $0.5$ for $50$ percent).", "solution": "The problem will first be validated for scientific and logical integrity.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n-   **Model**: Two-dimensional Ising model on an $L \\times L$ square lattice with periodic boundary conditions.\n-   **Spins**: $s_i \\in \\{-1,+1\\}$, where $s_i=+1$ represents an \"infected\" state and $s_i=-1$ represents a \"susceptible\" state.\n-   **Hamiltonian**: $H(\\{s_i\\})=-J\\sum_{\\langle i,j\\rangle} s_i s_j - h \\sum_i s_i$.\n-   **Parameters**: $J$ is the interaction strength, $h$ is the external field, $T$ is the temperature. The Boltzmann constant is $k_{\\mathrm{B}}=1$.\n-   **Observable**: The infected fraction is $f=\\frac{1}{N}\\sum_{i=1}^{N}\\frac{s_i+1}{2}$, where $N=L^2$. This is equivalent to $f=\\frac{1}{2}(1+m)$, with $m = \\frac{1}{N}\\sum_i s_i$ being the average magnetization per spin.\n-   **Objective**: Compute the equilibrium value of $f$, denoted $\\langle f \\rangle$, for four specific parameter sets.\n-   **Test Suite**:\n    1.  $(L,J,h,T) = (10, 0.0, 0.7, 2.5)$\n    2.  $(L,J,h,T) = (10, 1.0, -0.3, 0.0)$\n    3.  $(L,J,h,T) = (10, 1.0, 0.3, 0.0)$\n    4.  $(L,J,h,T) = (9, 0.9, 0.0, 1.7)$\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientifically Grounded**: The problem is based on the 2D Ising model, a fundamental and rigorously studied model in statistical mechanics. The Hamiltonian and definitions are standard. The interpretation as an SIS model is a valid, albeit simplified, analogy used in modeling complex systems. The problem is scientifically sound.\n-   **Well-Posed**: The objective is to compute the equilibrium expectation value of an observable. For a finite system at a given temperature, this value is uniquely defined by the Boltzmann distribution. The special cases of $T=0$ are also well-posed, as they correspond to finding the ground state configuration(s), which for the given parameters are unique.\n-   **Objective**: The problem statement is precise, quantitative, and free from subjective language.\n-   **Completeness and Consistency**: All necessary parameters ($L, J, h, T$) are provided for each case. The model and observable are unambiguously defined. There are no contradictions.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is a well-defined problem in statistical physics. A solution will be formulated.\n\n### Solution\n\nThe objective is to compute the equilibrium infected fraction $\\langle f \\rangle$. The infected fraction $f$ is related to the average magnetization per spin $m$ by the athermal transformation $f = \\frac{1}{2}(1+m)$. By linearity of the expectation value operator, the equilibrium infected fraction is $\\langle f \\rangle = \\frac{1}{2}(1 + \\langle m \\rangle)$. The task therefore reduces to computing the equilibrium average magnetization $\\langle m \\rangle$ for each parameter set.\n\nWhile the general 2D Ising model with an external field requires numerical methods like Monte Carlo simulation, the specific parameters provided in the test suite permit exact analytical solutions. A competent analysis must precede any brute-force computation.\n\n**Case 1: $(L,J,h,T) = (10, 0.0, 0.7, 2.5)$**\n\nThe interaction strength is $J=0$. The Hamiltonian simplifies to that of a paramagnet:\n$$H = -h \\sum_{i=1}^{N} s_i$$\nIn this system, the spins are non-interacting. The partition function $Z$ of the $N$-spin system is the product of the single-spin partition functions $Z_1$: $Z = Z_1^N$. The single-spin partition function is:\n$$Z_1 = \\sum_{s \\in \\{-1, +1\\}} e^{-(-hs)/T} = e^{h/T} + e^{-h/T} = 2 \\cosh(h/T)$$\nThe expectation value of a single spin $\\langle s_i \\rangle$ is given by:\n$$\\langle s_i \\rangle = \\frac{1}{Z_1} \\sum_{s \\in \\{-1, +1\\}} s e^{hs/T} = \\frac{(+1)e^{h/T} + (-1)e^{-h/T}}{e^{h/T} + e^{-h/T}} = \\tanh(h/T)$$\nSince all spins are identical and independent, the average magnetization is $\\langle m \\rangle = \\langle s_i \\rangle$.\nWith $h=0.7$ and $T=2.5$, the ratio is $h/T = 0.7/2.5 = 0.28$.\n$$\\langle m \\rangle = \\tanh(0.28)$$\nThe equilibrium infected fraction is:\n$$\\langle f \\rangle = \\frac{1}{2}(1 + \\tanh(0.28)) \\approx \\frac{1}{2}(1 + 0.2729010) \\approx 0.6364505$$\nRounding to $6$ decimal places gives $0.636451$.\n\n**Case 2: $(L,J,h,T) = (10, 1.0, -0.3, 0.0)$**\n\nThe temperature is $T=0$. The system must be in its ground state, i.e., the configuration $\\{s_i\\}$ that minimizes the Hamiltonian $H$.\n$$H = -J\\sum_{\\langle i,j\\rangle} s_i s_j - h \\sum_i s_i$$\nWith $J=1.0 > 0$, the interaction term $-J\\sum s_i s_j$ is minimized when all spins are aligned (ferromagnetic state), i.e., all $s_i=+1$ or all $s_i=-1$.\nWith $h=-0.3 < 0$, the field term $-h \\sum_i s_i = 0.3 \\sum_i s_i$ is minimized when $\\sum_i s_i$ is minimized, which occurs when all $s_i=-1$.\nBoth the interaction and field terms are minimized by the configuration where all spins are $s_i=-1$. This is the unique ground state.\nFor this state, the average magnetization is $\\langle m \\rangle = \\frac{1}{N}\\sum_i(-1) = -1$.\nThe equilibrium infected fraction is:\n$$\\langle f \\rangle = \\frac{1}{2}(1 + \\langle m \\rangle) = \\frac{1}{2}(1 - 1) = 0$$\nThe result is exactly $0.000000$.\n\n**Case 3: $(L,J,h,T) = (10, 1.0, 0.3, 0.0)$**\n\nThe temperature is again $T=0$. We perform a similar ground state analysis.\nThe parameters are $J=1.0 > 0$ and $h=0.3 > 0$.\nThe ferromagnetic interaction term favors alignment (all $s_i=+1$ or all $s_i=-1$).\nThe field term $-h \\sum_i s_i = -0.3 \\sum_i s_i$ is minimized when $\\sum_i s_i$ is maximized, which occurs when all $s_i=+1$.\nBoth terms favor the configuration where all spins are $s_i=+1$. This is the unique ground state.\nFor this state, the average magnetization is $\\langle m \\rangle = \\frac{1}{N}\\sum_i(+1) = +1$.\nThe equilibrium infected fraction is:\n$$\\langle f \\rangle = \\frac{1}{2}(1 + \\langle m \\rangle) = \\frac{1}{2}(1 + 1) = 1$$\nThe result is exactly $1.000000$.\n\n**Case 4: $(L,J,h,T) = (9, 0.9, 0.0, 1.7)$**\n\nThe external field is $h=0$. The Hamiltonian is:\n$$H = -J\\sum_{\\langle i,j\\rangle} s_i s_j$$\nThis Hamiltonian is invariant under a global spin flip transformation, where all $s_i$ are replaced by $-s_i$. Let this transformation be denoted by $\\mathcal{F}$. If $\\{s\\}$ is a configuration, then $H(\\mathcal{F}(\\{s\\})) = H(\\{s\\})$.\nThe average magnetization is the expectation value over the Boltzmann distribution:\n$$\\langle m \\rangle = \\frac{1}{Z} \\sum_{\\{s\\}} m(\\{s\\}) e^{-H(\\{s\\})/T}$$\nwhere $m(\\{s\\}) = \\frac{1}{N} \\sum_i s_i$. The magnetization of a globally flipped state is $m(\\mathcal{F}(\\{s\\})) = -m(\\{s\\})$.\nSince the sum is over all possible configurations, for every configuration $\\{s\\}$ with magnetization $m$, there exists a corresponding configuration $\\mathcal{F}(\\{s\\})$ with magnetization $-m$ and the same energy, and thus the same Boltzmann weight $e^{-H/T}$. These two states contribute $m \\cdot e^{-H/T}$ and $-m \\cdot e^{-H/T}$ to the numerator of $\\langle m \\rangle$, which sum to zero. The entire sum is therefore zero due to this pairing symmetry. This holds for any finite system with $h=0$ at any non-zero temperature.\nThus, $\\langle m \\rangle = 0$.\nThe equilibrium infected fraction is:\n$$\\langle f \\rangle = \\frac{1}{2}(1 + \\langle m \\rangle) = \\frac{1}{2}(1 + 0) = 0.5$$\nThis result is independent of $L$, $J$, and $T>0$, provided $h=0$. The result is exactly $0.500000$. Spontaneous magnetization only occurs in the thermodynamic limit an infinite system ($L \\to \\infty$) where symmetry breaking can occur. For a finite system, the true equilibrium average magnetization is strictly zero.\n\n**Summary of Results:**\n-   Case 1: $\\langle f \\rangle \\approx 0.636451$\n-   Case 2: $\\langle f \\rangle = 0.000000$\n-   Case 3: $\\langle f \\rangle = 1.000000$\n-   Case 4: $\\langle f \\rangle = 0.500000$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# language: Python\n# version: 3.12\n# libraries:\n#   - name: numpy\n#     version: 1.23.5\n#   - name: scipy\n#     version: 1.11.4\n\ndef solve():\n    \"\"\"\n    Computes the equilibrium infected fraction for an Ising model\n    under different parameter sets.\n    The provided test cases admit analytical solutions, bypassing the need for\n    Monte Carlo simulation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, J, h, T)\n        (10, 0.0, 0.7, 2.5),  # Case 1\n        (10, 1.0, -0.3, 0.0), # Case 2\n        (10, 1.0, 0.3, 0.0),  # Case 3\n        (9, 0.9, 0.0, 1.7),   # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        _L, J, h, T = case\n        \n        # The infected fraction f is related to magnetization m by f = (1 + m) / 2.\n        # We calculate the equilibrium average magnetization <m> for each case.\n\n        # Cases 2 & 3: T = 0.0\n        # At zero temperature, the system occupies its ground state, which minimizes\n        # the Hamiltonian H = -J * sum(s_i s_j) - h * sum(s_i).\n        if T == 0.0:\n            # The J > 0 term favors spin alignment.\n            # The field term (-h * sum(s_i)) determines the direction.\n            # If h > 0, the field term favors s_i = +1. Ground state is all spins up, <m>=1.\n            # If h < 0, the field term favors s_i = -1. Ground state is all spins down, <m>=-1.\n            m_avg = 1.0 if h > 0 else -1.0\n            f_eq = 0.5 * (1.0 + m_avg)\n            results.append(f\"{f_eq:.6f}\") # Result is exactly 0.0 or 1.0\n\n        # Case 1: J = 0.0\n        # The spins are non-interacting (paramagnet). The average magnetization\n        # for a spin in an external field h at temperature T is tanh(h/T).\n        elif J == 0.0:\n            # Check for T=0 is already done, T must be > 0 here.\n            m_avg = np.tanh(h / T)\n            f_eq = 0.5 * (1.0 + m_avg)\n            results.append(f\"{f_eq:.6f}\")\n\n        # Case 4: h = 0.0\n        # For a finite system with zero external field, the Hamiltonian is symmetric\n        # under a global spin flip (all s_i -> -s_i). By symmetry, the\n        # expectation value of magnetization <m> must be exactly 0.\n        elif h == 0.0:\n            m_avg = 0.0\n            f_eq = 0.5 * (1.0 + m_avg)\n            results.append(f\"{f_eq:.6f}\") # Result is exactly 0.5\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2413215"}, {"introduction": "The Metropolis algorithm is a powerful tool for studying systems too large for direct calculation, but what exactly is it approximating? This exercise bridges the gap between analytical theory and numerical simulation by asking you to compute thermodynamic observables for a small system through exact enumeration. By summing over all $2^N$ possible configurations, you will calculate the partition function and thermal averages directly from their statistical definitions, providing a \"ground truth\" that reinforces the core concepts of the canonical ensemble and serves as an invaluable reference for validating a Monte Carlo code [@problem_id:2413243].", "problem": "Consider a system of binary opinions represented by spins on a finite undirected graph. Each individual is a node indexed by $i \\in \\{0,1,\\dots,N-1\\}$ with spin $s_i \\in \\{-1,+1\\}$. Let the \"friendship strength\" between two distinct individuals $i$ and $j$ be a nonnegative, symmetric weight $w_{ij} = w_{ji} \\ge 0$, with $w_{ii} = 0$, and assume there is an edge between $i$ and $j$ if and only if $w_{ij} > 0$. The interaction energy of a configuration $s = (s_0,\\dots,s_{N-1})$ at temperature $T > 0$ in an external uniform field $h$ is given by the Ising Hamiltonian\n$$\nH(s) \\;=\\; -\\sum_{0 \\le i < j \\le N-1} J_{ij} \\, s_i s_j \\;-\\; h \\sum_{i=0}^{N-1} s_i,\n$$\nwith couplings $J_{ij} = J_0 \\, w_{ij}$, where $J_0 > 0$ is a uniform coupling scale. Work in units where the Boltzmann constant $k_B$ equals $1$ so that the canonical probability of configuration $s$ is\n$$\n\\mathbb{P}(s) \\;=\\; \\frac{1}{Z} \\exp\\!\\left(-\\frac{H(s)}{T}\\right), \\qquad Z \\;=\\; \\sum_{s \\in \\{-1,+1\\}^N} \\exp\\!\\left(-\\frac{H(s)}{T}\\right).\n$$\n\nFor each specified test case below, compute the following equilibrium observables:\n- The absolute magnetization per spin,\n$$\nm \\;=\\; \\frac{1}{N} \\, \\Big\\langle \\big| \\sum_{i=0}^{N-1} s_i \\big| \\Big\\rangle,\n$$\n- The energy per spin,\n$$\ne \\;=\\; \\frac{1}{N} \\, \\langle H(s) \\rangle,\n$$\nwhere $\\langle \\cdot \\rangle$ denotes the canonical expectation with respect to $\\mathbb{P}(s)$ at the given temperature $T$. All quantities are dimensionless in these units. Energies are to be expressed in units of $J_0$ and temperatures in units where $k_B = 1$.\n\nTest suite (each case is fully specified by $(N,\\{(i,j,w_{ij})\\},J_0,h,T)$):\n- Case $1$: $N = 4$; weighted edges $\\{(0,1,1.0),(1,2,1.0),(2,3,1.0)\\}$; $J_0 = 1.0$; $h = 0.0$; $T = 0.1$.\n- Case $2$: $N = 4$; weighted edges $\\{(0,1,1.0),(1,2,1.0),(2,3,1.0)\\}$; $J_0 = 1.0$; $h = 0.0$; $T = 5.0$.\n- Case $3$: $N = 3$; weighted edges $\\{(0,1,2.0),(1,2,0.5),(0,2,1.0)\\}$; $J_0 = 1.0$; $h = 0.0$; $T = 1.5$.\n- Case $4$: $N = 4$; weighted edges $\\{(0,1,1.5),(2,3,1.5),(1,2,0.1)\\}$; $J_0 = 1.0$; $h = 0.2$; $T = 1.0$.\n\nRequired final output format:\n- Your program must produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets. Each case’s result must itself be a two-element list $[m,e]$, with both $m$ and $e$ rounded to exactly $6$ decimal places using standard rounding to nearest. There must be no spaces anywhere in the output.\n- Concretely, the output must have the form\n$$\n[[m_1,e_1],[m_2,e_2],[m_3,e_3],[m_4,e_4]],\n$$\nwhere each $m_k$ and $e_k$ are decimal numbers with exactly $6$ digits after the decimal point.\n\nNo angles or percentages are involved; do not use angle units or percentage signs. All temperatures and energies are dimensionless in the specified units. The problem is fully determined by the definitions above; use only the provided parameters. Your code must use exactly the test suite above and produce the final output in the required single-line format.", "solution": "The problem statement is critically examined and found to be valid. It is scientifically grounded in the principles of statistical mechanics, well-posed for its small system sizes, and expressed with objective, mathematical precision. It does not violate any of the criteria for invalidity. The problem describes the standard Ising model on a finite, weighted, undirected graph and asks for the computation of fundamental equilibrium observables: the absolute magnetization per spin and the energy per spin.\n\nThe crucial observation is that for the small number of spins $N$ given in the test cases ($N=3$ and $N=4$), the total number of system configurations, $2^N$, is very small ($2^3 = 8$ and $2^4 = 16$, respectively). This allows for a direct, exact calculation of the partition function and thermal expectation values by enumerating all possible states. This approach is computationally feasible and yields exact results, obviating the need for stochastic methods such as Metropolis Monte Carlo simulations, which would only provide statistical estimates.\n\nThe solution is based on the principles of the canonical ensemble in statistical mechanics. The probability of a system being in a specific configuration $s$ with energy $H(s)$ at a given temperature $T$ is given by the Boltzmann distribution:\n$$\n\\mathbb{P}(s) = \\frac{1}{Z} \\exp\\left(-\\frac{H(s)}{T}\\right)\n$$\nwhere $Z$ is the partition function, which normalizes the probability distribution. It is the sum of the Boltzmann factors over all possible configurations:\n$$\nZ = \\sum_{s \\in \\{-1,+1\\}^N} \\exp\\left(-\\frac{H(s)}{T}\\right)\n$$\nThe Hamiltonian $H(s)$ for a given configuration $s = (s_0, \\dots, s_{N-1})$ is defined as:\n$$\nH(s) = -\\sum_{0 \\le i < j \\le N-1} J_{ij} s_i s_j - h \\sum_{i=0}^{N-1} s_i\n$$\nThe couplings $J_{ij}$ are derived from the problem-specified friendship weights $w_{ij}$ and the uniform coupling scale $J_0$ as $J_{ij} = J_0 w_{ij}$.\n\nThe thermal expectation value of any observable quantity $A(s)$ is then calculated by averaging $A(s)$ over all possible configurations, weighted by their respective probabilities:\n$$\n\\langle A \\rangle = \\sum_s A(s) \\mathbb{P}(s) = \\frac{1}{Z} \\sum_s A(s) \\exp\\left(-\\frac{H(s)}{T}\\right)\n$$\nThe two observables required are:\n1.  The energy per spin, $e = \\frac{1}{N} \\langle H \\rangle$.\n2.  The absolute magnetization per spin, $m = \\frac{1}{N} \\langle \\left| M \\right| \\rangle$, where the total magnetization of a state $s$ is $M(s) = \\sum_{i=0}^{N-1} s_i$.\n\nThe computational procedure is as follows:\nFirst, for each test case, we construct the symmetric $N \\times N$ coupling matrix $J$ where $J_{ij} = J_0 w_{ij}$.\nSecond, we systematically generate all $2^N$ spin configurations $s$. This is achieved by iterating through integers from $0$ to $2^N - 1$ and using their binary representations to define the spin states (e.g., bit $0 \\mapsto +1$, bit $1 \\mapsto -1$).\nFor each configuration $s$, we compute its energy $H(s)$ and its absolute total magnetization $|M(s)|$.\n\nA key numerical consideration is the evaluation of the Boltzmann factor $\\exp(-H(s)/T)$. When $T$ is small, the argument $-H(s)/T$ can become very large and positive, leading to numerical overflow. To ensure stability, we subtract the minimum energy of the system, $H_{\\text{min}} = \\min_s H(s)$, from all energies before exponentiating. The expectation value calculation is invariant under this shift:\n$$\n\\langle A \\rangle = \\frac{\\sum_s A(s) \\exp\\left(-\\frac{H(s) - H_{\\text{min}}}{T}\\right)}{\\sum_s \\exp\\left(-\\frac{H(s) - H_{\\text{min}}}{T}\\right)}\n$$\nThis reformulation guarantees that all arguments to the exponential function are less than or equal to zero, thus preventing overflow and maintaining numerical precision.\n\nThe algorithm for each test case is implemented by:\n1.  Initializing sums for the numerator of $\\langle H \\rangle$, the numerator of $\\langle |M| \\rangle$, and the (shifted) partition function to zero.\n2.  Iterating through all $2^N$ states. For each state $s$:\n    a.  Calculate $H(s)$ and $|M(s)|$.\n    b.  Calculate the shifted Boltzmann factor $W'(s) = \\exp(-(H(s) - H_{\\text{min}})/T)$.\n    c.  Update the sums: add $W'(s)$ to the partition function sum, add $H(s) \\cdot W'(s)$ to the energy sum, and add $|M(s)| \\cdot W'(s)$ to the magnetization sum.\n3.  After iterating through all states, compute the final expectation values $\\langle H \\rangle$ and $\\langle |M| \\rangle$ by dividing the accumulated sums by the total sum of shifted Boltzmann factors.\n4.  Finally, divide these expectation values by $N$ to obtain the per-spin quantities $e$ and $m$. These are then formatted as required by the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_observables(N, edges, J0, h, T):\n    \"\"\"\n    Calculates equilibrium observables for an Ising model on a graph by exact enumeration.\n    \n    Args:\n        N (int): Number of spins.\n        edges (list): List of tuples (i, j, w_ij) representing weighted edges.\n        J0 (float): Uniform coupling scale.\n        h (float): External uniform field.\n        T (float): Temperature (with k_B = 1).\n        \n    Returns:\n        tuple: A tuple (m, e) containing the absolute magnetization per spin\n               and the energy per spin.\n    \"\"\"\n    # 1. Construct the coupling matrix J\n    J_mat = np.zeros((N, N))\n    for i, j, w_ij in edges:\n        J_mat[i, j] = J0 * w_ij\n        J_mat[j, i] = J0 * w_ij\n\n    num_states = 1 << N\n    all_energies = np.zeros(num_states)\n    all_abs_mags = np.zeros(num_states)\n\n    # 2. Enumerate all 2^N states and calculate H and |M| for each\n    for i in range(num_states):\n        # Generate spin configuration s from the bits of integer i.\n        # bit 0 -> spin +1, bit 1 -> spin -1\n        s = np.array([1 if not ((i >> j) & 1) else -1 for j in range(N)])\n        \n        # Calculate Hamiltonian H(s) = -0.5 * s.T @ J_mat @ s - h * sum(s)\n        interaction_energy = -0.5 * np.dot(s, np.dot(J_mat, s))\n        field_energy = -h * np.sum(s)\n        H_s = interaction_energy + field_energy\n        \n        M_s = np.sum(s)\n        \n        all_energies[i] = H_s\n        all_abs_mags[i] = np.abs(M_s)\n        \n    # 3. Calculate expectation values using numerically stable method\n    if T <= 0:\n        # In the zero-temperature limit, the system occupies the ground state(s).\n        min_energy = np.min(all_energies)\n        ground_state_indices = np.where(all_energies == min_energy)[0]\n        \n        avg_H = min_energy\n        avg_abs_M = np.mean(all_abs_mags[ground_state_indices])\n    else:\n        # For T > 0, use Boltzmann statistics with a shift to avoid overflow.\n        min_energy = np.min(all_energies)\n        shifted_boltzmann_factors = np.exp(-(all_energies - min_energy) / T)\n        \n        Z_prime = np.sum(shifted_boltzmann_factors)\n        \n        avg_H = np.sum(all_energies * shifted_boltzmann_factors) / Z_prime\n        avg_abs_M = np.sum(all_abs_mags * shifted_boltzmann_factors) / Z_prime\n\n    # 4. Compute per-spin observables\n    e = avg_H / N\n    m = avg_abs_M / N\n\n    return m, e\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (N, edges, J0, h, T)\n        (4, [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0)], 1.0, 0.0, 0.1),\n        # Case 2\n        (4, [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0)], 1.0, 0.0, 5.0),\n        # Case 3\n        (3, [(0, 1, 2.0), (1, 2, 0.5), (0, 2, 1.0)], 1.0, 0.0, 1.5),\n        # Case 4\n        (4, [(0, 1, 1.5), (2, 3, 1.5), (1, 2, 0.1)], 1.0, 0.2, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, edges, J0, h, T = case\n        m, e = calculate_observables(N, edges, J0, h, T)\n        \n        # Format each [m, e] pair as a string with 6 decimal places and no spaces.\n        result_str = f\"[{m:.6f},{e:.6f}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2413243"}, {"introduction": "With a solid conceptual and computational foundation, you are now ready to implement the workhorse of computational statistical mechanics: the Metropolis algorithm. This practice guides you through building a complete simulation of the 2D Ising model for a system large enough that exact methods are no longer feasible. You will tackle practical implementation details such as different boundary conditions (periodic, open, and helical) and employ an efficient checkerboard update scheme, culminating in the measurement of the finite-size correction to the magnetization—a key physical effect where simulation directly confronts theory [@problem_id:2413296].", "problem": "You are tasked with designing and executing a Metropolis single-spin-flip simulation of the two-dimensional Ising model to quantify how different boundary conditions modify finite-size corrections to the magnetization. Your implementation must be a complete, runnable program. The model consists of spins $s_i \\in \\{-1,+1\\}$ on a square lattice of linear size $L$, with Hamiltonian\n$$\nH(\\{s\\}) = - J \\sum_{\\langle i,j \\rangle} s_i s_j,\n$$\nwhere $J>0$ and $\\langle i,j \\rangle$ denotes nearest-neighbor pairs defined by a boundary condition. Use $J=1$ and Boltzmann constant $k_{\\mathrm{B}}=1$, so temperature $T$ is dimensionless. The Metropolis algorithm with a single-spin-flip proposal must be employed, using the acceptance probability\n$$\nP_{\\mathrm{acc}} = \\min\\left(1, e^{-\\beta \\Delta E}\\right),\n$$\nwhere $\\Delta E$ is the energy change due to a proposed flip and $\\beta = 1/T$.\n\nBoundary conditions to implement:\n- Periodic boundary condition (PBC): neighbors of a site at coordinates $(x,y)$ are $((x+1)\\!\\!\\mod L, y)$, $((x-1)\\!\\!\\mod L, y)$, $(x, (y+1)\\!\\!\\mod L)$, $(x, (y-1)\\!\\!\\mod L)$.\n- Open boundary condition (OBC): neighbors outside the lattice are absent and do not contribute to $H$.\n- Helical boundary condition (HBC): flatten the lattice to one-dimensional index $i = x + L y \\in \\{0,\\dots,L^2-1\\}$, and use neighbors $\\{(i+1)\\!\\!\\mod N, (i-1)\\!\\!\\mod N, (i+L)\\!\\!\\mod N, (i-L)\\!\\!\\mod N\\}$ with $N=L^2$. For algorithmic efficiency, you must use a checkerboard (red-black) parallel Metropolis update; to strictly preserve independence of sublattice updates under HBC, choose odd $L$.\n\nMagnetization per spin is\n$$\nm(\\{s\\}) = \\frac{1}{N}\\left|\\sum_{i=1}^N s_i\\right|, \\quad N=L^2.\n$$\nDefine the finite-size correction at temperature $T$ for a lattice of size $L$ under a boundary condition $\\mathcal{B}$ as\n$$\n\\Delta m(L,\\mathcal{B},T) = m_{\\infty}(T) - \\langle m \\rangle_{L,\\mathcal{B},T},\n$$\nwhere $\\langle m \\rangle_{L,\\mathcal{B},T}$ is the Monte Carlo average of $m(\\{s\\})$ in equilibrium, and $m_{\\infty}(T)$ is the exact infinite-lattice spontaneous magnetization for the two-dimensional Ising model at $T<T_{\\mathrm{c}}$, given by the well-tested expression\n$$\nm_{\\infty}(T) = \\left[1 - \\sinh^{-4}\\!\\left(\\frac{2}{T}\\right)\\right]^{1/8}, \\quad T<T_{\\mathrm{c}},\n$$\nand $m_{\\infty}(T)=0$ for $T \\ge T_{\\mathrm{c}}$. The critical temperature is\n$$\nT_{\\mathrm{c}} = \\frac{2}{\\ln\\!\\left(1+\\sqrt{2}\\right)}.\n$$\n\nStart from the Boltzmann distribution and the Metropolis transition rule. Implement a checkerboard (two-sublattice) update that flips all spins on one sublattice in parallel, then the other. Use a hot start with random initial spins $s_i \\in \\{-1,+1\\}$ with equal probability. Thermalize for a specified number of full sweeps, then perform measurements of $m$ after each sweep and average them to estimate $\\langle m \\rangle_{L,\\mathcal{B},T}$. Use fixed random seeds for reproducibility.\n\nTest Suite. Run your program for the following parameter sets, all at $T=2.2$ (which satisfies $T<T_{\\mathrm{c}}$), using the listed number of thermalization sweeps and measurement sweeps. All lattice sizes are odd to ensure helical boundary condition compatibility with checkerboard updates. Each test case is independent with its own fixed seed.\n- Case $1$: $(\\mathcal{B}=\\mathrm{PBC},\\, L=9,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231101)$.\n- Case $2$: $(\\mathcal{B}=\\mathrm{OBC},\\, L=9,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231102)$.\n- Case $3$: $(\\mathcal{B}=\\mathrm{HBC},\\, L=9,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231103)$.\n- Case $4$: $(\\mathcal{B}=\\mathrm{PBC},\\, L=13,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231104)$.\n- Case $5$: $(\\mathcal{B}=\\mathrm{OBC},\\, L=13,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231105)$.\n- Case $6$: $(\\mathcal{B}=\\mathrm{HBC},\\, L=13,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231106)$.\n\nYour output must be the list\n$$\n[\\Delta m_1,\\Delta m_2,\\Delta m_3,\\Delta m_4,\\Delta m_5,\\Delta m_6],\n$$\nwhere $\\Delta m_k$ is the finite-size correction computed for Case $k$, rounded to $6$ decimal places. The program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[0.123456,0.234567,0.345678,0.456789,0.567890,0.678901]$). No physical units are required since all quantities are dimensionless. Angles are not used.\n\nYour solution must be derived from the Boltzmann weight, the definition of the Ising Hamiltonian, and the Metropolis acceptance rule. Do not use any pre-computed simulation outputs. Your program must be fully self-contained and require no user input. All mathematical symbols and numbers in this problem statement are written in LaTeX. Ensure scientific realism and internal consistency in your assumptions and numerical choices.", "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically grounded, well-posed, objective, and internally consistent. It presents a standard problem in computational statistical mechanics with all necessary parameters, definitions, and constraints clearly specified.\n\nThe task is to perform a Metropolis Monte Carlo simulation of the two-dimensional Ising model to compute the finite-size correction to the spontaneous magnetization, $\\Delta m$, for various lattice sizes and boundary conditions. The solution is derived from the fundamental principles of statistical mechanics and the Monte Carlo method.\n\nThe foundational principle is that in thermal equilibrium, the probability of a physical system being in a microscopic state $\\{s\\}$ with energy $H(\\{s\\})$ is given by the Boltzmann distribution:\n$$\nP(\\{s\\}) = \\frac{1}{Z} e^{-\\beta H(\\{s\\})}\n$$\nwhere $Z$ is the partition function and $\\beta = 1/(k_{\\mathrm{B}}T)$. For the Ising model on a square lattice, the Hamiltonian is given by:\n$$\nH(\\{s\\}) = -J \\sum_{\\langle i,j \\rangle} s_i s_j\n$$\nwith $J=1$ and $k_{\\mathrm{B}}=1$.\n\nDirectly sampling from the Boltzmann distribution is intractable for any non-trivial system size. Instead, we employ a Markov Chain Monte Carlo (MCMC) method, specifically the Metropolis algorithm, to generate a sequence of states that are distributed according to $P(\\{s\\})$. This algorithm ensures that the system evolves towards equilibrium by satisfying the detailed balance condition. The Metropolis transition rule for a proposed single-spin flip $s_k \\to -s_k$ is governed by the acceptance probability:\n$$\nP_{\\mathrm{acc}} = \\min\\left(1, e^{-\\beta \\Delta E}\\right)\n$$\nwhere $\\Delta E$ is the change in energy resulting from the flip. For a flip of spin $s_k$, the energy change is:\n$$\n\\Delta E = E_{\\text{final}} - E_{\\text{initial}} = -J \\sum_{\\langle k,j \\rangle} (-s_k)s_j - \\left(-J \\sum_{\\langle k,j \\rangle} s_k s_j\\right) = 2J s_k \\sum_{\\langle k,j \\rangle} s_j\n$$\nHere, $\\sum_{\\langle k,j \\rangle} s_j$ is the sum of the spins neighboring site $k$.\n\nFor computational efficiency, a checkerboard update scheme is implemented. The lattice sites are partitioned into two independent sublattices, \"red\" and \"black,\" akin to a chessboard. A site $(x,y)$ is red if $(x+y)$ is even, and black if $(x+y)$ is odd. Crucially, all nearest neighbors of a red site are black, and vice versa. This independence allows for the simultaneous (vectorized) update of all spins on one sublattice, followed by the simultaneous update of all spins on the other. A full Monte Carlo sweep consists of updating the red sublattice and then the black sublattice.\n\nThe simulation protocol for each test case proceeds as follows:\n1.  **Initialization**: The system is initialized in a \"hot\" state, where each spin $s_i$ is randomly assigned a value of $+1$ or $-1$ with equal probability. An appropriate random number generator is seeded for reproducibility.\n2.  **Thermalization**: The system is evolved for a specified number of thermalization sweeps, $N_{\\mathrm{therm}}$. During this phase, the system relaxes from its random initial state towards thermal equilibrium. No measurements are taken.\n3.  **Measurement**: Following thermalization, the simulation continues for $N_{\\mathrm{meas}}$ measurement sweeps. After each full sweep, the instantaneous absolute magnetization per spin, $m(\\{s\\}) = \\frac{1}{N}|\\sum_i s_i|$, is calculated and recorded.\n4.  **Averaging**: The equilibrium expectation value of the magnetization, $\\langle m \\rangle_{L,\\mathcal{B},T}$, is estimated by averaging the instantaneous values of $m(\\{s\\})$ collected during the measurement phase.\n\nThe neighbor sum calculation depends critically on the boundary condition ($\\mathcal{B}$):\n-   **Periodic Boundary Condition (PBC)**: The lattice is treated as a torus. The neighbors of a site are found by applying modulo $L$ arithmetic to their coordinates. This is efficiently implemented using `numpy.roll` on a two-dimensional array.\n-   **Open Boundary Condition (OBC)**: Spins at the edges and corners have fewer than four neighbors as any connection extending beyond the lattice boundary is absent. This is implemented by constructing the neighbor-sum array and adding contributions from each direction using appropriate array slices that exclude the boundaries.\n-   **Helical Boundary Condition (HBC)**: The $L \\times L$ lattice is flattened into a one-dimensional array of size $N=L^2$. The neighbors of a site with index $i$ are at indices $(i\\pm 1) \\pmod N$ and $(i\\pm L) \\pmod N$. This configuration is compatible with the checkerboard update scheme for odd $L$, as specified. This is efficiently implemented using `numpy.roll` on the one-dimensional array.\n\nFinally, the finite-size correction is computed using the provided exact result for the infinite-lattice spontaneous magnetization, $m_{\\infty}(T)$, for $T<T_{\\mathrm{c}}$:\n$$\n\\Delta m(L,\\mathcal{B},T) = m_{\\infty}(T) - \\langle m \\rangle_{L,\\mathcal{B},T}\n$$\nwhere $T=2.2$ is below the critical temperature $T_{\\mathrm{c}} = 2/\\ln(1+\\sqrt{2}) \\approx 2.269$. The formula for $m_{\\infty}(T)$ is:\n$$\nm_{\\infty}(T) = \\left[1 - \\sinh^{-4}\\left(\\frac{2}{T}\\right)\\right]^{1/8}\n$$\nThe entire procedure is repeated for each of the six specified test cases, and the results are aggregated.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Ising model simulations and compute finite-size corrections.\n    \"\"\"\n\n    def calculate_avg_m(L, T, bc_type, n_therm, n_meas, seed):\n        \"\"\"\n        Performs a Metropolis simulation of the 2D Ising model.\n\n        Args:\n            L (int): Linear size of the lattice.\n            T (float): Temperature.\n            bc_type (str): Boundary condition type ('PBC', 'OBC', 'HBC').\n            n_therm (int): Number of thermalization sweeps.\n            n_meas (int): Number of measurement sweeps.\n            seed (int): Seed for the random number generator.\n\n        Returns:\n            float: The time-averaged absolute magnetization per spin.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        beta = 1.0 / T\n        N = L * L\n        J = 1.0\n\n        # Initialize spins and checkerboard masks\n        if bc_type == 'HBC':\n            spins = rng.choice([-1, 1], size=N)\n            # Create 2D indices to define masks, then flatten\n            x, y = np.meshgrid(np.arange(L), np.arange(L))\n            mask_red = ((x + y) % 2 == 0).flatten()\n            mask_black = ((x + y) % 2 == 1).flatten()\n        else: # PBC, OBC\n            spins = rng.choice([-1, 1], size=(L, L))\n            x, y = np.meshgrid(np.arange(L), np.arange(L))\n            mask_red = (x + y) % 2 == 0\n            mask_black = (x + y) % 2 == 1\n        \n        num_red = np.sum(mask_red)\n        num_black = np.sum(mask_black)\n\n        def update_sublattice(spins, mask, num_sites_in_mask):\n            \"\"\"Applies one parallel update to a sublattice.\"\"\"\n            # Calculate sum of neighbors for all sites\n            if bc_type == 'PBC':\n                neighbors_sum = (np.roll(spins, 1, axis=0) + np.roll(spins, -1, axis=0) +\n                                 np.roll(spins, 1, axis=1) + np.roll(spins, -1, axis=1))\n            elif bc_type == 'OBC':\n                neighbors_sum = np.zeros_like(spins, dtype=np.int8)\n                neighbors_sum[1:, :] += spins[:-1, :]  # Neighbors from top\n                neighbors_sum[:-1, :] += spins[1:, :]  # Neighbors from bottom\n                neighbors_sum[:, 1:] += spins[:, :-1]  # Neighbors from left\n                neighbors_sum[:, :-1] += spins[:, 1:]  # Neighbors from right\n            elif bc_type == 'HBC':\n                neighbors_sum = (np.roll(spins, 1) + np.roll(spins, -1) +\n                                 np.roll(spins, L) + np.roll(spins, -L))\n\n            sublattice_spins = spins[mask]\n            sublattice_neighbors_sum = neighbors_sum[mask]\n\n            # Calculate energy change for a flip for all spins on the sublattice\n            delta_E = 2.0 * J * sublattice_spins * sublattice_neighbors_sum\n            \n            # Metropolis acceptance condition\n            accept = (delta_E <= 0) | (rng.random(size=num_sites_in_mask) < np.exp(-beta * delta_E))\n            \n            # Apply flips. Must assign back to the masked array to modify in place.\n            new_sublattice_spins = sublattice_spins.copy()\n            new_sublattice_spins[accept] *= -1\n            spins[mask] = new_sublattice_spins\n            \n            return spins\n\n        # Thermalization sweeps\n        for _ in range(n_therm):\n            spins = update_sublattice(spins, mask_red, num_red)\n            spins = update_sublattice(spins, mask_black, num_black)\n\n        # Measurement sweeps\n        magnetization_values = []\n        for _ in range(n_meas):\n            spins = update_sublattice(spins, mask_red, num_red)\n            spins = update_sublattice(spins, mask_black, num_black)\n            m = np.abs(np.sum(spins)) / N\n            magnetization_values.append(m)\n        \n        return np.mean(magnetization_values)\n\n    # Define test cases from the problem statement.\n    test_cases = [\n        ('PBC', 9, 2.2, 1000, 2000, 20231101),\n        ('OBC', 9, 2.2, 1000, 2000, 20231102),\n        ('HBC', 9, 2.2, 1000, 2000, 20231103),\n        ('PBC', 13, 2.2, 1000, 2000, 20231104),\n        ('OBC', 13, 2.2, 1000, 2000, 20231105),\n        ('HBC', 13, 2.2, 1000, 2000, 20231106),\n    ]\n\n    # Calculate exact infinite-lattice magnetization for T=2.2\n    T_val = 2.2\n    Tc = 2.0 / np.log(1.0 + np.sqrt(2.0))\n    if T_val < Tc:\n        m_infinity = (1.0 - np.sinh(2.0 / T_val)**(-4))**(1.0/8.0)\n    else:\n        m_infinity = 0.0\n\n    results = []\n    for case in test_cases:\n        bc_type, L, T_case, n_therm, n_meas, seed = case\n        avg_m = calculate_avg_m(L, T_case, bc_type, n_therm, n_meas, seed)\n        delta_m = m_infinity - avg_m\n        results.append(round(delta_m, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2413296"}]}