{"hands_on_practices": [{"introduction": "The Vicsek model is a cornerstone for understanding collective motion, from bird flocks to bacterial swarms. It captures the essence of a phase transition from disordered movement to collective order, driven by simple local alignment rules and noise. This practice provides direct, hands-on experience in implementing an agent-based model from first principles, allowing you to observe how a macroscopic property like flocking emerges from microscopic interactions and changes with a control parameter, a hallmark of a continuous phase transition [@problem_id:2422305].", "problem": "You must write a complete, runnable program that simulates the Vicsek model of self-propelled particles on a finite, two-dimensional periodic square domain and computes the flocking order parameter for a specified set of cases. All angles must be expressed and implemented in radians. The model must be defined from first principles as follows.\n\nConsider a square domain of side length $L$ with periodic boundary conditions. There are $N$ particles with positions $\\mathbf{r}_i(t) \\in [0,L) \\times [0,L)$ and orientations $\\theta_i(t) \\in \\mathbb{R}$ for $i \\in \\{1,\\dots,N\\}$. Each particle moves with constant speed $v_0$ and its position and orientation are updated synchronously at discrete times $t = 0, \\Delta t, 2 \\Delta t, \\dots$ according to the following rules.\n\n- Initialization at $t=0$: The positions $\\mathbf{r}_i(0)$ are independent and identically distributed uniformly on $[0,L) \\times [0,L)$, and the orientations $\\theta_i(0)$ are independent and identically distributed uniformly on $[-\\pi,\\pi)$.\n\n- Neighborhood under periodic boundary conditions: Let $\\mathbf{r}_i = (x_i,y_i)$ and $\\mathbf{r}_j = (x_j,y_j)$. Define the periodic displacement\n$$\n\\Delta \\mathbf{r}_{ij} = \\left(\\Delta x_{ij}, \\Delta y_{ij}\\right) = \\left(x_i - x_j - L \\,\\mathrm{round}\\!\\left(\\frac{x_i - x_j}{L}\\right),\\; y_i - y_j - L \\,\\mathrm{round}\\!\\left(\\frac{y_i - y_j}{L}\\right)\\right),\n$$\nand the periodic distance\n$$\nd_{ij} = \\sqrt{(\\Delta x_{ij})^2 + (\\Delta y_{ij})^2}.\n$$\nParticle $j$ is a neighbor of particle $i$ if and only if $d_{ij} \\le R$, where $R$ is the interaction radius. By construction, $d_{ii} = 0 \\le R$, so the particle counts itself as its own neighbor.\n\n- Orientation update: Let $\\mathcal{N}_i(t) = \\{ j \\in \\{1,\\dots,N\\} \\mid d_{ij}(t) \\le R \\}$ be the neighbor set of particle $i$ at time $t$. Define the complex unit vectors $u_j(t) = e^{\\mathrm{i}\\theta_j(t)}$. The noiseless mean heading of neighbors is $\\mathrm{Arg}\\!\\left(\\sum_{j \\in \\mathcal{N}_i(t)} u_j(t)\\right)$, where $\\mathrm{Arg}$ denotes the complex argument. The orientation is updated synchronously by\n$$\n\\theta_i(t+\\Delta t) = \\mathrm{Arg}\\!\\left(\\sum_{j \\in \\mathcal{N}_i(t)} e^{\\mathrm{i}\\theta_j(t)}\\right) + \\xi_i(t),\n$$\nwhere $\\xi_i(t)$ are independent random angles sampled uniformly from the interval $[-\\eta/2,\\;\\eta/2]$, and $\\eta \\ge 0$ is the noise amplitude.\n\n- Position update with periodic wrapping:\n$$\n\\mathbf{r}_i(t+\\Delta t) = \\mathbf{r}_i(t) + v_0 \\Delta t \\, \\big(\\cos \\theta_i(t+\\Delta t), \\; \\sin \\theta_i(t+\\Delta t)\\big),\n$$\nwith periodic boundary conditions applied componentwise so that positions remain in $[0,L)$ by wrapping modulo $L$.\n\n- Instantaneous polarization (order parameter) at time $t$:\n$$\n\\Phi(t) = \\frac{1}{N}\\left\\| \\sum_{i=1}^{N} \\big(\\cos \\theta_i(t), \\; \\sin \\theta_i(t)\\big) \\right\\|,\n$$\nwhich takes values in $[0,1]$.\n\n- Time-averaged order parameter after relaxation:\nGiven a total number of steps $T$ and a nonnegative number of discarded transient steps $T_{\\mathrm{disc}} < T$, define the sample set $\\mathcal{S} = \\{ t_k \\mid t_k = k\\Delta t,\\; k \\in \\{T_{\\mathrm{disc}}, T_{\\mathrm{disc}}+1,\\dots, T-1\\} \\}$ consisting of $T - T_{\\mathrm{disc}}$ equally spaced samples. The reported order parameter is the time average\n$$\n\\overline{\\Phi} = \\frac{1}{T - T_{\\mathrm{disc}}} \\sum_{k=T_{\\mathrm{disc}}}^{T-1} \\Phi(k\\Delta t).\n$$\n\nRandomness and reproducibility requirements:\n- For each case in the test suite below, use the provided integer random seed to initialize the pseudorandom number generator that is used for all random draws in that case. The initial positions, initial orientations, and all noise angles must be generated using this seeded generator to ensure deterministic outputs.\n\nAngle unit requirement:\n- All angles must be in radians. The uniform distributions over angles are in radians, and the noise interval is $[-\\eta/2,\\;\\eta/2]$ in radians.\n\nOutput requirement:\n- For each test case, compute a single floating-point number $\\overline{\\Phi}$ as defined above. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite, with each value rounded to exactly $6$ decimal places (for example, $\\texttt{[0.912345,0.053210,...]}$). No other text must be printed.\n\nTest suite:\nFor each case, the tuple lists $(N, L, R, v_0, \\Delta t, \\eta, T, T_{\\mathrm{disc}}, \\text{seed})$.\n\n- Case $1$ (ordered, low noise, moderate density):\n  - $(N, L, R, v_0, \\Delta t, \\eta, T, T_{\\mathrm{disc}}, \\text{seed}) = (150, 10.0, 1.0, 0.03, 1.0, 0.10, 600, 200, 1)$.\n- Case $2$ (disordered, high noise, same density):\n  - $(N, L, R, v_0, \\Delta t, \\eta, T, T_{\\mathrm{disc}}, \\text{seed}) = (150, 10.0, 1.0, 0.03, 1.0, 3.00, 600, 200, 2)$.\n- Case $3$ (intermediate noise, near transition regime):\n  - $(N, L, R, v_0, \\Delta t, \\eta, T, T_{\\mathrm{disc}}, \\text{seed}) = (150, 10.0, 1.0, 0.03, 1.0, 2.00, 600, 200, 3)$.\n- Case $4$ (edge case, self-only interaction radius):\n  - $(N, L, R, v_0, \\Delta t, \\eta, T, T_{\\mathrm{disc}}, \\text{seed}) = (150, 10.0, 0.0, 0.03, 1.0, 0.50, 600, 200, 4)$.\n- Case $5$ (finite-size effect, small system):\n  - $(N, L, R, v_0, \\Delta t, \\eta, T, T_{\\mathrm{disc}}, \\text{seed}) = (16, 5.0, 1.5, 0.05, 1.0, 0.30, 800, 300, 5)$.\n\nYour program must implement exactly the rules specified above, adhere to the angle unit requirement, use the provided seeds, and produce the final output in the exact required format. The output list must be ordered as $[\\overline{\\Phi}_1,\\overline{\\Phi}_2,\\overline{\\Phi}_3,\\overline{\\Phi}_4,\\overline{\\Phi}_5]$ corresponding to Cases $1$ through $5$, rounded to $6$ decimal places.", "solution": "The problem presented is a well-posed and standard exercise in computational statistical physics. It requires the implementation of the Vicsek model of self-propelled particles, a canonical model for studying collective motion and flocking phenomena. All definitions, parameters, and computational requirements are specified with sufficient precision to permit a unique and reproducible solution. The problem is scientifically sound and algorithmically implementable. We shall proceed with the derivation of the computational algorithm.\n\nThe objective is to compute the time-averaged order parameter, $\\overline{\\Phi}$, for several parameter sets. This requires a direct simulation of the system's dynamics over a specified number of time steps.\n\nThe algorithm is structured as a time-stepping simulation.\n\n1.  **Initialization ($t=0$):**\n    For each test case, a specific integer seed is provided. This seed must be used to initialize a pseudorandom number generator (RNG). This ensures that the simulation is deterministic and the results are reproducible.\n    -   The positions of the $N$ particles, $\\mathbf{r}_i = (x_i, y_i)$, are stored in a numerical array of size $N \\times 2$. Each component $x_i(0)$ and $y_i(0)$ is drawn independently from a uniform distribution over the interval $[0, L)$.\n    -   The orientations of the $N$ particles, $\\theta_i$, are stored in a numerical array of size $N$. Each $\\theta_i(0)$ is drawn independently from a uniform distribution over the interval $[-\\pi, \\pi)$. All angles are treated in radians.\n\n2.  **Simulation Loop:**\n    The system evolves in discrete time steps of size $\\Delta t$. A loop iterates from step $k=0$ to $k=T-1$. At each step, the state of all $N$ particles is updated synchronously. This means we must first compute all new orientations $\\{\\theta_i(t+\\Delta t)\\}$ and only then use these new orientations to update all particle positions $\\{\\mathbf{r}_i(t+\\Delta t)\\}$.\n\n3.  **State Update (from time $t$ to $t+\\Delta t$):**\n    This is the core of the simulation, comprising three sequential operations within each time step.\n\n    a. **Neighborhood Identification:**\n    For each particle $i$, its neighbors $\\mathcal{N}_i(t)$ are all particles $j$ (including itself) such that the periodic distance $d_{ij}(t)$ is less than or equal to the interaction radius $R$. The periodic distance calculation must implement the minimum image convention on the square domain of side length $L$. The displacement vector $\\Delta \\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$ is calculated, and each component is wrapped into the interval $[-L/2, L/2]$. The specified formula, $\\Delta x' = \\Delta x - L \\cdot \\mathrm{round}(\\Delta x / L)$, achieves this. The distance is then $d_{ij} = \\sqrt{(\\Delta x'_{ij})^2 + (\\Delta y'_{ij})^2}$.\n    Computationally, this is accomplished efficiently by first computing the matrix of all pairwise position differences, $\\mathbf{r}_i - \\mathbf{r}_j$. This yields an $N \\times N \\times 2$ tensor. The periodic boundary condition is applied element-wise. Then, the squared Euclidean norm of each displacement vector is computed, resulting in an $N \\times N$ matrix of squared distances, $D^2_{ij}$. A boolean mask where $D^2_{ij} \\le R^2$ then identifies all neighbor pairs.\n\n    b. **Orientation Update:**\n    The new orientation $\\theta_i(t+\\Delta t)$ is the sum of the local average heading and a random noise term. The average heading is the argument of the sum of complex unit vectors corresponding to the orientations of the neighbors:\n    $$ \\langle \\theta(t) \\rangle_{\\mathcal{N}_i(t)} = \\mathrm{Arg}\\left(\\sum_{j \\in \\mathcal{N}_i(t)} e^{\\mathrm{i}\\theta_j(t)}\\right) = \\mathrm{atan2}\\left(\\sum_{j \\in \\mathcal{N}_i(t)} \\sin\\theta_j(t), \\sum_{j \\in \\mathcal{N}_i(t)} \\cos\\theta_j(t)\\right) $$\n    The noise term $\\xi_i(t)$ is a random variable drawn from the uniform distribution on $[-\\eta/2, \\eta/2]$.\n    The update rule is:\n    $$ \\theta_i(t+\\Delta t) = \\langle \\theta(t) \\rangle_{\\mathcal{N}_i(t)} + \\xi_i(t) $$\n    This operation is performed for all $N$ particles. To maintain synchronicity, the new angles $\\{\\theta_i(t+\\Delta t)\\}$ must be stored in a temporary array and should not overwrite the current angles $\\{\\theta_i(t)\\}$ until all new angles have been computed.\n\n    c. **Position Update:**\n    Each particle moves with constant speed $v_0$ in its new direction $\\theta_i(t+\\Delta t)$. The velocity vector for particle $i$ is $\\mathbf{v}_i(t+\\Delta t) = v_0 (\\cos\\theta_i(t+\\Delta t), \\sin\\theta_i(t+\\Delta t))$. The position is updated as:\n    $$ \\mathbf{r}_i(t+\\Delta t) = \\mathbf{r}_i(t) + \\mathbf{v}_i(t+\\Delta t) \\Delta t $$\n    Periodic boundary conditions are then applied to the components of $\\mathbf{r}_i(t+\\Delta t)$ to ensure they remain within the domain $[0, L)$. This is achieved by taking the result modulo $L$.\n\n4.  **Order Parameter Calculation:**\n    After the state update, if the current step $k$ is $T_{\\mathrm{disc}}$ or greater, the instantaneous polarization (order parameter) $\\Phi(t)$ is calculated. It is the magnitude of the average velocity vector of the whole swarm:\n    $$ \\Phi(t) = \\left\\| \\frac{1}{N} \\sum_{i=1}^N \\mathbf{\\hat{v}}_i(t) \\right\\| = \\frac{1}{N} \\sqrt{\\left(\\sum_{i=1}^N \\cos\\theta_i(t)\\right)^2 + \\left(\\sum_{i=1}^N \\sin\\theta_i(t)\\right)^2} $$\n    where $\\mathbf{\\hat{v}}_i(t) = (\\cos\\theta_i(t), \\sin\\theta_i(t))$. These values of $\\Phi(k\\Delta t)$ for $k \\in \\{T_{\\mathrm{disc}}, \\dots, T-1\\}$ are stored.\n\n5.  **Final Averaging:**\n    After the simulation loop completes, the final result $\\overline{\\Phi}$ is the arithmetic mean of the stored instantaneous order parameter values:\n    $$ \\overline{\\Phi} = \\frac{1}{T - T_{\\mathrm{disc}}} \\sum_{k=T_{\\mathrm{disc}}}^{T-1} \\Phi(k\\Delta t) $$\n    This procedure is repeated for each test case, and the resulting values are formatted as specified. The case with interaction radius $R=0$ is a valid physical limit where each particle only interacts with itself, and its orientation dynamics simplify to a random walk, $\\theta_i(t+\\Delta t) = \\theta_i(t) + \\xi_i(t)$. A correct implementation must handle this case without error.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, L, R, v0, dt, eta, T, T_disc, seed):\n    \"\"\"\n    Simulates the Vicsek model for a given set of parameters.\n\n    Args:\n        N (int): Number of particles.\n        L (float): Side length of the square domain.\n        R (float): Interaction radius.\n        v0 (float): Constant speed of particles.\n        dt (float): Time step size.\n        eta (float): Noise amplitude.\n        T (int): Total number of simulation steps.\n        T_disc (int): Number of transient steps to discard.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        float: The time-averaged order parameter over the steady state.\n    \"\"\"\n    # Initialize the pseudo-random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # 1. Initialization at t=0\n    # Positions: r is an (N, 2) array, distributed uniformly in [0, L) x [0, L).\n    r = rng.uniform(0, L, size=(N, 2))\n    # Orientations: theta is an (N,) array, distributed uniformly in [-pi, pi).\n    theta = rng.uniform(-np.pi, np.pi, size=N)\n\n    order_params = []\n    R_sq = R**2  # Use squared radius for distance comparison to avoid sqrt.\n\n    # 2. Simulation Loop\n    for t_step in range(T):\n        # 3a. Neighborhood Identification (Vectorized)\n        # Calculate pairwise displacement tensor (N, N, 2).\n        # r[:, np.newaxis, :] -> (N, 1, 2)\n        # r[np.newaxis, :, :] -> (1, N, 2)\n        # Broadcasting gives all (r_i - r_j) pairs.\n        delta_r = r[:, np.newaxis, :] - r[np.newaxis, :, :]\n\n        # Apply periodic boundary conditions using the minimum image convention.\n        # This wraps displacements into the [-L/2, L/2] interval.\n        delta_r -= L * np.round(delta_r / L)\n\n        # Calculate squared distances (N, N) matrix.\n        dist_sq = np.sum(delta_r**2, axis=-1)\n\n        # Get neighbor mask: True if distance <= R.\n        neighbor_mask = (dist_sq <= R_sq).astype(float)\n        \n        # 3b. Orientation Update\n        # Convert angles to complex vectors (cos, sin components).\n        vel_vectors = np.stack([np.cos(theta), np.sin(theta)], axis=1)\n\n        # Sum neighbor velocity components using matrix multiplication.\n        # neighbor_mask (N, N) @ vel_vectors (N, 2) -> (N, 2)\n        sum_vel = neighbor_mask @ vel_vectors\n        \n        # Calculate mean angles from the sum of vectors.\n        mean_angles = np.arctan2(sum_vel[:, 1], sum_vel[:, 0])\n\n        # Generate noise for each particle.\n        noise = rng.uniform(-eta / 2, eta / 2, size=N)\n        \n        # New orientations are mean angle + noise.\n        # The update is synchronous as we use old 'theta' for all calculations.\n        new_theta = mean_angles + noise\n\n        # 3c. Position Update\n        # Update positions using the *new* orientations.\n        r[:, 0] += v0 * dt * np.cos(new_theta)\n        r[:, 1] += v0 * dt * np.sin(new_theta)\n        \n        # Apply periodic boundary conditions to positions (wrap around).\n        r %= L\n\n        # Update the orientations for the next step.\n        theta = new_theta\n\n        # 4. Order Parameter Calculation\n        if t_step >= T_disc:\n            # Calculate the average velocity vector of the swarm.\n            # Using current orientations `theta` (which are `theta(t+dt)`).\n            mean_vel_x = np.mean(np.cos(theta))\n            mean_vel_y = np.mean(np.sin(theta))\n            \n            # Magnitude of the average velocity vector is the order parameter.\n            phi = np.sqrt(mean_vel_x**2 + mean_vel_y**2)\n            order_params.append(phi)\n    \n    # 5. Final Averaging\n    # Compute the arithmetic mean of the collected order parameters.\n    if order_params:\n        avg_phi = np.mean(order_params)\n    else:\n        avg_phi = 0.0\n\n    return avg_phi\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite from the problem statement:\n    # (N, L, R, v0, dt, eta, T, T_disc, seed)\n    test_cases = [\n        (150, 10.0, 1.0, 0.03, 1.0, 0.10, 600, 200, 1),\n        (150, 10.0, 1.0, 0.03, 1.0, 3.00, 600, 200, 2),\n        (150, 10.0, 1.0, 0.03, 1.0, 2.00, 600, 200, 3),\n        (150, 10.0, 0.0, 0.03, 1.0, 0.50, 600, 200, 4),\n        (16, 5.0, 1.5, 0.05, 1.0, 0.30, 800, 300, 5),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, R, v0, dt, eta, T, T_disc, seed = case\n        result = run_simulation(N, L, R, v0, dt, eta, T, T_disc, seed)\n        results.append(result)\n\n    # Format the final output as a comma-separated list of floats\n    # rounded to 6 decimal places, enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2422305"}, {"introduction": "The Ising model is the archetypal system for studying equilibrium phase transitions, but its behavior can be profoundly affected by the underlying topology of spin connections. This exercise moves beyond simulation to the fundamental method of exact enumeration, where you will calculate thermal properties directly from the partition function. By comparing the magnetic susceptibility $\\chi$ on a cylinder versus a Möbius strip, you will gain a deeper appreciation for how boundary conditions and global topology can alter the physical properties of a finite system [@problem_id:2422307].", "problem": "Consider the two-dimensional Ising model with spins $s_{x,y} \\in \\{+1,-1\\}$ on a rectangular $L_x \\times L_y$ lattice with Hamiltonian\n$$\nH(\\{s\\}) \\;=\\; -J \\sum_{\\langle i,j\\rangle} s_i s_j,\n$$\nwhere $J>0$ and the sum is over nearest-neighbor pairs defined by the lattice topology. Work at zero external field and in units where the Boltzmann constant $k_{\\mathrm{B}}=1$. The equilibrium (canonical) probability of a configuration $\\{s\\}$ at temperature $T$ is proportional to $\\exp(-\\beta H)$ with $\\beta = 1/T$. The total magnetization is $M(\\{s\\})=\\sum_{x=0}^{L_x-1}\\sum_{y=0}^{L_y-1} s_{x,y}$ and the magnetic susceptibility per spin is defined by\n$$\n\\chi(T) \\;=\\; \\frac{\\beta}{N} \\left( \\langle M^2 \\rangle - \\langle M \\rangle^2 \\right),\n$$\nwhere $N=L_x L_y$ and $\\langle \\cdot \\rangle$ denotes the canonical ensemble average.\n\nDefine two topologies on the same $L_x \\times L_y$ grid:\n\n- Cylinder: open boundaries in the $x$-direction and periodic boundaries in the $y$-direction. The set of nearest-neighbor bonds consists of pairs $\\big((x,y),(x+1,y)\\big)$ for all $x$ with $0 \\le x < L_x-1$, $0 \\le y < L_y$, and pairs $\\big((x,y),(x, y')\\big)$ with $y'=(y+1)\\bmod L_y$ for all $x$ and $y$.\n\n- Möbius strip: open boundaries in the $x$-direction and twisted periodic boundaries in the $y$-direction. The set of nearest-neighbor bonds consists of pairs $\\big((x,y),(x+1,y)\\big)$ for all $x$ with $0 \\le x < L_x-1$, $0 \\le y < L_y$, and pairs $\\big((x,y),(x', y')\\big)$ where if $y+1<L_y$ then $(x',y')=(x,y+1)$, and if $y+1=L_y$ then $(x',y')=(L_x-1-x,0)$, for all $x$ and $y$.\n\nUsing only the definitions above (no approximations), compute the susceptibility $\\chi$ for both topologies by evaluating the canonical ensemble exactly through sums over all spin configurations. Set $J=1$ and express temperatures $T$ in dimensionless units (since $k_{\\mathrm{B}}=1$ and $J=1$), with $\\beta=1/T$.\n\nTest Suite:\nFor each of the following parameter sets $(L_x,L_y,T)$, compute two numbers: $\\chi_{\\mathrm{Mobius}}(T)$ and $\\chi_{\\mathrm{Cylinder}}(T)$.\n\n- Case A: $L_x=4$, $L_y=3$, $T=2.30$.\n- Case B: $L_x=5$, $L_y=3$, $T=1.80$.\n- Case C: $L_x=4$, $L_y=4$, $T=4.00$.\n\nFinal Output Format:\nYour program should produce a single line of output containing a comma-separated flat list with the six susceptibility values in the order\n$$\n\\big[\\chi_{\\mathrm{Mobius}}^{\\mathrm{A}},\\;\\chi_{\\mathrm{Cylinder}}^{\\mathrm{A}},\\;\\chi_{\\mathrm{Mobius}}^{\\mathrm{B}},\\;\\chi_{\\mathrm{Cylinder}}^{\\mathrm{B}},\\;\\chi_{\\mathrm{Mobius}}^{\\mathrm{C}},\\;\\chi_{\\mathrm{Cylinder}}^{\\mathrm{C}}\\big],\n$$\nrounded to exactly $6$ decimal places, and enclosed in square brackets. For example: $[\\chi_1,\\chi_2,\\chi_3,\\chi_4,\\chi_5,\\chi_6]$.", "solution": "The problem statement is assessed to be valid. It is a well-posed problem in computational statistical mechanics, free of scientific or logical flaws, and provides all necessary information for a unique solution. The specified method of exact enumeration is computationally feasible for the given lattice sizes.\n\nThe magnetic susceptibility per spin, $\\chi(T)$, is defined as\n$$\n\\chi(T) = \\frac{\\beta}{N} \\left( \\langle M^2 \\rangle - \\langle M \\rangle^2 \\right),\n$$\nwhere $N=L_x L_y$ is the total number of spins, $\\beta = 1/T$ (with $k_{\\mathrm{B}}=1$), $M$ is the total magnetization, and $\\langle \\cdot \\rangle$ denotes the canonical ensemble average. An observable $O$ has a canonical average given by\n$$\n\\langle O \\rangle = \\frac{\\sum_{\\{s\\}} O(\\{s\\}) e^{-\\beta H(\\{s\\})}}{Z},\n$$\nwhere the sum runs over all $2^N$ spin configurations $\\{s\\}$, and $Z = \\sum_{\\{s\\}} e^{-\\beta H(\\{s\\})}$ is the partition function.\n\nThe Hamiltonian $H(\\{s\\}) = -J \\sum_{\\langle i,j\\rangle} s_i s_j$ is invariant under a global spin-flip transformation, where all spins $\\{s_k\\}$ become $\\{-s_k\\}$. This holds for both the cylinder and Möbius strip topologies as the set of neighbor pairs is fixed. Under this transformation, the energy $H$ is unchanged, while the magnetization reverses sign, $M \\to -M$. Consequently, for every configuration with magnetization $M$, there exists a degenerate configuration with magnetization $-M$. The sum for $\\langle M \\rangle$ can be written as a sum over pairs of such configurations:\n$$\n\\sum_{\\{s\\} \\text{ pairs}} \\left( M e^{-\\beta H} + (-M) e^{-\\beta H} \\right) = 0.\n$$\nTherefore, the average magnetization $\\langle M \\rangle$ is strictly zero for any temperature. The expression for susceptibility simplifies to\n$$\n\\chi(T) = \\frac{\\beta}{N} \\langle M^2 \\rangle.\n$$\nTo compute $\\chi(T)$, we must evaluate $\\langle M^2 \\rangle$ by summing over all $2^N$ spin configurations. This is an exact enumeration approach. The algorithm is as follows:\n\n1.  For a given lattice of size $N=L_x \\times L_y$, there are $2^N$ unique spin configurations. We can systematically generate each configuration by mapping it to an integer $i$ in the range $[0, 2^N-1]$. The state of the $k$-th spin, $s_k \\in \\{+1, -1\\}$, is determined by the $k$-th bit of the binary representation of $i$. For example, a map can be $s_k = 2 \\cdot (\\text{bit}_k \\text{ of } i) - 1$. A 1D spin index $k \\in [0, N-1]$ is mapped to a 2D lattice coordinate $(x,y)$ via $k = y \\cdot L_x + x$.\n\n2.  The crucial element defining the model is the lattice topology, which determines the set of nearest-neighbor pairs $\\langle i,j \\rangle$ used in the Hamiltonian sum. We generate a definitive list of unique bonds for each specified topology.\n    *   For the **Cylinder** topology ($L_x \\times L_y$), the bonds are defined by:\n        *   Horizontal connections: Pairs of sites $((x,y), (x+1,y))$ for $0 \\le x < L_x-1$ and $0 \\le y < L_y$.\n        *   Vertical connections with periodic boundaries: Pairs $((x,y), (x, (y+1) \\pmod{L_y}))$ for $0 \\le x < L_x$ and $0 \\le y < L_y$.\n    *   For the **Möbius strip** topology, the bonds are:\n        *   Horizontal connections: Same as the cylinder.\n        *   Vertical connections with a twist: Pairs $((x,y), (x,y+1))$ for $0 \\le y < L_y-1$, and a specific twisted connection for the boundary columns of spins, linking site $(x, L_y-1)$ to site $(L_x-1-x, 0)$ for all $x \\in [0, L_x-1]$.\n\n3.  With the bond list established, we iterate through all $2^N$ configurations. For each configuration $\\{s\\}$, we compute:\n    *   The total magnetization: $M(\\{s\\}) = \\sum_{k=0}^{N-1} s_k$.\n    *   The total energy: $H(\\{s\\}) = -J \\sum_{\\langle i,j \\rangle} s_i s_j$. We are given $J=1$.\n\n4.  We then compute the required sums over all configurations:\n    *   The partition function sum $Z_{\\text{sum}} = \\sum_{\\{s\\}} \\exp(-\\beta H(\\{s\\}))$.\n    *   The sum for the second moment of magnetization $S_{M^2} = \\sum_{\\{s\\}} M(\\{s\\})^2 \\exp(-\\beta H(\\{s\\}))$.\n\n5.  The calculation of Boltzmann factors $\\exp(-\\beta H)$ can lead to numerical overflow if $-\\beta H$ is large and positive. To ensure stability, we first find the minimum energy over all configurations, $H_{\\min} = \\min_{\\{s\\}} H(\\{s\\})$. We then compute numerically stable weights $w_s = \\exp(-\\beta(H(\\{s\\}) - H_{\\min}))$. The factor $\\exp(\\beta H_{\\min})$ is common to all terms in both the numerator and denominator of $\\langle M^2 \\rangle$ and thus cancels:\n    $$\n    \\langle M^2 \\rangle = \\frac{\\sum_{\\{s\\}} M^2(\\{s\\}) w_s}{\\sum_{\\{s\\}} w_s} = \\frac{S_{M^2}}{Z_{\\text{sum}}}.\n    $$\n\n6.  Finally, the susceptibility is calculated using the simplified formula: $\\chi(T) = \\frac{\\beta}{N} \\langle M^2 \\rangle$.\n\nThe provided code implements this exact algorithm. It generates all spin configurations and their corresponding magnetizations and energies for a given topology. It then uses these to compute the partition function sum and the thermal average of the squared magnetization, leading to the final susceptibility value. This process is repeated for each set of parameters and each topology in the test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_bonds(Lx, Ly, topology):\n    \"\"\"\n    Generates the list of unique nearest-neighbor bonds for a given topology.\n\n    Args:\n        Lx (int): Lattice size in the x-direction.\n        Ly (int): Lattice size in the y-direction.\n        topology (str): 'cylinder' or 'mobius'.\n\n    Returns:\n        list: A list of tuples, where each tuple represents a bond (pair of site indices).\n    \"\"\"\n    bonds = set()\n\n    def add_bond(i, j):\n        bonds.add(tuple(sorted((i, j))))\n\n    def get_idx(x, y):\n        return y * Lx + x\n\n    # Horizontal bonds (common to both topologies)\n    for y in range(Ly):\n        for x in range(Lx - 1):\n            add_bond(get_idx(x, y), get_idx(x + 1, y))\n\n    # Vertical bonds (topology-dependent)\n    if topology == 'cylinder':\n        for x in range(Lx):\n            for y in range(Ly):\n                add_bond(get_idx(x, y), get_idx(x, (y + 1) % Ly))\n    elif topology == 'mobius':\n        for x in range(Lx):\n            # Normal vertical bonds for y < Ly-1\n            for y in range(Ly - 1):\n                add_bond(get_idx(x, y), get_idx(x, y + 1))\n            # Twisted bonds connecting y=Ly-1 to y=0\n            add_bond(get_idx(x, Ly - 1), get_idx(Lx - 1 - x, 0))\n    \n    return list(bonds)\n\ndef calculate_chi(Lx, Ly, T, topology):\n    \"\"\"\n    Computes the magnetic susceptibility per spin for the 2D Ising model\n    by exact enumeration of all spin configurations.\n\n    Args:\n        Lx (int): Lattice size in the x-direction.\n        Ly (int): Lattice size in the y-direction.\n        T (float): Temperature.\n        topology (str): The lattice topology, 'cylinder' or 'mobius'.\n\n    Returns:\n        float: The calculated magnetic susceptibility per spin.\n    \"\"\"\n    N = Lx * Ly\n    beta = 1.0 / T\n    J = 1.0\n    \n    bonds = get_bonds(Lx, Ly, topology)\n    \n    num_configs = 1 << N\n    \n    # 1. Generate all 2^N spin configurations using numpy broadcasting.\n    # Each row is a configuration, each column is a spin site.\n    # The value is +1 or -1.\n    i_vals = np.arange(num_configs, dtype=np.uint32)\n    k_vals = np.arange(N, dtype=np.uint8)\n    spins = (((i_vals[:, None] >> k_vals[None, :]) & 1) * 2 - 1).astype(np.int8)\n\n    # 2. Calculate magnetization M for each configuration.\n    magnetizations = np.sum(spins, axis=1, dtype=np.int32)\n\n    # 3. Calculate energy H for each configuration.\n    energies = np.zeros(num_configs, dtype=np.float64)\n    for idx1, idx2 in bonds:\n        energies -= spins[:, idx1] * spins[:, idx2]\n    energies *= J\n\n    # 4. Compute sums for <M^2> using numerically stable weights.\n    # Find minimum energy to prevent overflow in exp.\n    H_min = np.min(energies)\n    shifted_energies = energies - H_min\n    weights = np.exp(-beta * shifted_energies)\n    \n    # Partition function sum\n    Z_sum = np.sum(weights)\n    \n    # Thermal sum for M^2\n    M2_sum = np.sum(magnetizations**2 * weights)\n    \n    # 5. Calculate susceptibility.\n    # <M> = 0 due to spin-flip symmetry.\n    mean_M2 = M2_sum / Z_sum\n    chi = (beta / N) * mean_M2\n    \n    return chi\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4, 3, 2.30),  # Case A\n        (5, 3, 1.80),  # Case B\n        (4, 4, 4.00),  # Case C\n    ]\n\n    results = []\n    for Lx, Ly, T in test_cases:\n        chi_mobius = calculate_chi(Lx, Ly, T, 'mobius')\n        chi_cylinder = calculate_chi(Lx, Ly, T, 'cylinder')\n        results.append(chi_mobius)\n        results.append(chi_cylinder)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2422307"}, {"introduction": "The Lee-Yang theorem reveals a deep connection between phase transitions and the mathematical structure of the partition function in the complex plane. This advanced practice challenges you to apply a sophisticated theoretical tool to a concrete computational problem. By constructing the partition function as a polynomial in the complex fugacity $z=e^{-2\\beta h}$ and finding its roots, you will learn a powerful method for precisely locating the critical temperature in a finite system, bridging the gap between abstract theory and practical analysis [@problem_id:2422394].", "problem": "You are asked to implement a complete, runnable program that estimates the critical temperature $T_c$ of the two-dimensional (2D) ferromagnetic Ising model on small finite lattices using the Lee-Yang zeros of the partition function in the complex fugacity plane. The program must enumerate spin configurations to construct the partition function as a polynomial in the complex fugacity $z$ and then estimate $T_c$ by locating the temperature at which the Lee-Yang zero with the smallest angular distance to the positive real axis is closest to $z=1$. All angles must be treated in radians.\n\nStart from the following fundamental definitions:\n\n- The Ising model has spins $s_i \\in \\{+1,-1\\}$ on a square lattice of linear size $L$ with periodic boundary conditions (PBC). The Hamiltonian is\n$$\nH(s;J,h) \\;=\\; -J \\sum_{\\langle i,j\\rangle} s_i s_j \\;-\\; h \\sum_{i=1}^{N} s_i,\n$$\nwhere $N=L^2$, $J>0$ is the ferromagnetic coupling, $\\langle i,j\\rangle$ denotes nearest neighbors with PBC, and $h$ is a uniform external magnetic field.\n\n- The canonical partition function is\n$$\nZ(\\beta,h) \\;=\\; \\sum_{s} e^{-\\beta H(s;J,h)} \\;=\\; \\sum_{s} \\exp\\!\\Big(\\beta J\\sum_{\\langle i,j\\rangle} s_i s_j + \\beta h \\sum_{i=1}^{N} s_i\\Big),\n$$\nwhere $\\beta = 1/T$ with Boltzmann constant set to $k_B=1$.\n\nDefine the complex fugacity\n$$\nz \\;=\\; e^{-2\\beta h}.\n$$\nBy grouping configurations according to the number $k$ of down spins (i.e., the number of sites with $s_i=-1$), note that $\\sum_{i=1}^{N} s_i = N-2k$. Then\n$$\ne^{\\beta h \\sum_i s_i} = e^{\\beta h (N-2k)} = e^{\\beta h N}\\, z^{k}.\n$$\nTherefore\n$$\nZ(\\beta,h) \\;=\\; e^{\\beta h N} \\sum_{k=0}^{N} a_k(\\beta)\\, z^k \\;\\equiv\\; e^{\\beta h N}\\, P_L(z;\\beta),\n$$\nwith coefficients\n$$\na_k(\\beta) \\;=\\; \\sum_{\\substack{s:\\;\\text{$k$ spins equal } -1}} \\exp\\!\\Big(\\beta J \\sum_{\\langle i,j\\rangle} s_i s_j\\Big).\n$$\nThe Lee-Yang zeros are the roots of $P_L(z;\\beta)$ in the complex $z$-plane. For a finite lattice, these are isolated complex numbers. For ferromagnetic $J>0$, the Lee-Yang circle theorem implies that all zeros lie on the unit circle $|z|=1$ for real $\\beta>0$.\n\nEstimator for $T_c$: For fixed $L$ and temperature $T$, compute all roots $\\{z_i(T,L)\\}_{i=1}^{N}$ of $P_L(z;\\beta)$ and define\n$$\n\\theta_{\\min}(T,L) \\;=\\; \\min_{i} \\big|\\arg(z_i(T,L))\\big|,\n$$\nwhere $\\arg(\\cdot)$ denotes the complex argument in radians. Define the finite-size estimator\n$$\nT_{\\mathrm{est}}(L) \\;=\\; \\operatorname*{arg\\,min}_{T \\in \\mathcal{G}} \\theta_{\\min}(T,L)\n$$\nover a supplied finite temperature grid $\\mathcal{G}$ (ties broken by choosing the smaller $T$). This estimator identifies the temperature in the grid where the nearest Lee-Yang zero approaches the positive real axis most closely.\n\nImplementation requirements:\n\n- Set $J=1$ and $k_B=1$. All temperatures $T$ are dimensionless. All angles must be handled and, where relevant, interpreted in radians.\n- Use periodic boundary conditions on an $L\\times L$ lattice. Enumerate all $2^N$ spin configurations to compute the coefficients $a_k(\\beta)$. For each configuration, compute the nearest-neighbor interaction sum $\\sum_{\\langle i,j\\rangle} s_i s_j$, the number $k$ of down spins, and accumulate the corresponding weight into $a_k(\\beta)$.\n- Construct the polynomial $P_L(z;\\beta)=\\sum_{k=0}^{N} a_k(\\beta)\\, z^k$ and compute all its complex roots. Compute $\\theta_{\\min}(T,L)$ as defined above.\n- For each test case, scan the provided temperature grid $\\mathcal{G}$ and output $T_{\\mathrm{est}}(L)$.\n\nTest suite:\n\nCompute $T_{\\mathrm{est}}(L)$ for the following test cases. Each case is a pair $(L,\\mathcal{G})$:\n\n- Case $1$ (happy path): $L=2$, $\\mathcal{G} = [\\,1.5,\\,2.0,\\,2.2,\\,2.3,\\,2.5,\\,3.0\\,]$.\n- Case $2$ (larger lattice): $L=3$, $\\mathcal{G} = [\\,1.8,\\,2.0,\\,2.1,\\,2.2,\\,2.25,\\,2.3,\\,2.4,\\,2.6\\,]$.\n- Case $3$ (coarse grid boundary): $L=2$, $\\mathcal{G} = [\\,1.0,\\,4.0\\,]$.\n- Case $4$ (grid including the exact infinite-lattice critical temperature as a reference point): $L=3$, $\\mathcal{G} = [\\,2.1,\\,2.2,\\,2.269185,\\,2.3\\,]$. The exact infinite-lattice value is $T_c = 2/\\ln(1+\\sqrt{2}) \\approx 2.269185$, which is included here only as a grid point; the finite-size estimator need not select it.\n\nFinal output format:\n\nYour program must produce a single line containing the four estimated temperatures $[\\,T_{\\mathrm{est}}^{(1)},T_{\\mathrm{est}}^{(2)},T_{\\mathrm{est}}^{(3)},T_{\\mathrm{est}}^{(4)}\\,]$ in the same order as the cases above, as a comma-separated list enclosed in square brackets. Each entry must be the grid value (a float) that minimizes $\\theta_{\\min}(T,L)$ for that case. For example, an output of the form $[2.2,2.25,4.0,2.269185]$ is acceptable if those are the minimizing grid values found by your program. No additional text should be printed.", "solution": "The problem statement is scientifically sound, well-posed, and provides all necessary information for a complete computational solution. It describes a standard method in statistical physics for estimating critical phenomena using Lee-Yang zeros, applied to the two-dimensional Ising model on a finite lattice. The approach is computationally intensive, requiring full enumeration of states, but feasible for the small lattice sizes specified. Therefore, the problem is valid, and a solution can be constructed.\n\nThe task is to estimate the critical temperature $T_c$ of the 2D ferromagnetic Ising model by finding the temperature at which the Lee-Yang zeros of the partition function are closest to the positive real axis. The problem provides the Hamiltonian, the partition function $Z(\\beta, h)$, and its polynomial form in terms of complex fugacity $z=e^{-2\\beta h}$, $P_L(z;\\beta)$. The roots of this polynomial are the Lee-Yang zeros.\n\nThe core of the methodology is based upon the following steps:\n$1$. For a given lattice of size $L \\times L$ and at a specific temperature $T$, we first need to compute the coefficients $a_k(\\beta)$ of the partition function polynomial $P_L(z;\\beta) = \\sum_{k=0}^{N} a_k(\\beta) z^k$. Here, $N=L^2$ is the total number of spins, $\\beta = 1/T$ (with $k_B=1$), and $a_k(\\beta)$ is defined as:\n$$\na_k(\\beta) = \\sum_{\\substack{s:\\;\\text{$k$ spins equal } -1}} \\exp\\left(\\beta J \\sum_{\\langle i,j\\rangle} s_i s_j\\right)\n$$\nwhere $J=1$ is the ferromagnetic coupling constant. The sum is over all spin configurations $s$ that have exactly $k$ spins in the state $s_i = -1$.\n\n$2$. To compute these coefficients, we must perform a complete enumeration of all $2^N$ possible spin configurations on the lattice. For each configuration:\n    a. We identify the spin state $s = \\{s_1, s_2, \\ldots, s_N\\}$, where each $s_i \\in \\{+1, -1\\}$.\n    b. We count the number of \"down\" spins, $k = \\sum_{i=1}^N \\frac{1-s_i}{2}$.\n    c. We calculate the total interaction energy of the configuration, $E_{\\text{int}} = \\sum_{\\langle i,j\\rangle} s_i s_j$. The sum is over all unique nearest-neighbor pairs on the $L \\times L$ lattice with periodic boundary conditions. The total number of such bonds on a 2D toroidal lattice is $2N$. A standard and correct method to compute this sum is to iterate over each site $i$ and sum the interactions with its \"forward\" neighbors (e.g., right and down neighbors). For a site at coordinates $(r,c)$, this corresponds to calculating $s_{r,c} s_{r, c+1} + s_{r,c} s_{r+1,c}$, where all indices are taken modulo $L$. Summing this over all $N$ sites gives the total interaction energy sum.\n    d. The Boltzmann-like weight, $\\exp(\\beta J E_{\\text{int}})$, for the current configuration is then added to the corresponding coefficient $a_k(\\beta)$.\n\n$3$. Once all $2^N$ configurations have been processed, the array of coefficients $\\{a_k(\\beta)\\}_{k=0}^N$ is complete for the chosen temperature $T$. These coefficients define the polynomial $P_L(z;\\beta)$.\n\n$4$. We then compute the complex roots $\\{z_i(T,L)\\}$ of this polynomial. This is a standard numerical task that can be accomplished using established library functions, such as `numpy.roots` in Python. According to the Lee-Yang circle theorem, for a ferromagnetic system ($J>0$), all these roots must lie on the unit circle in the complex fugacity plane, i.e., $|z_i| = 1$.\n\n$5$. From the set of roots, we calculate the finite-size estimator quantity $\\theta_{\\min}(T,L)$, defined as the minimum absolute value of the argument of the roots:\n$$\n\\theta_{\\min}(T,L) = \\min_{i} \\big|\\arg(z_i(T,L))\\big|\n$$\nwhere the argument is computed in radians. This value represents the angular distance of the closest Lee-Yang zero to the positive real axis ($z=1$), which corresponds to the location of a phase transition in the thermodynamic limit.\n\n$6$. Finally, to estimate the critical temperature for a given lattice size $L$, we repeat steps $1$ through $5$ for every temperature $T$ in the provided grid $\\mathcal{G}$. The estimated critical temperature, $T_{\\mathrm{est}}(L)$, is the temperature from the grid that yields the minimum value of $\\theta_{\\min}(T,L)$:\n$$\nT_{\\mathrm{est}}(L) = \\operatorname*{arg\\,min}_{T \\in \\mathcal{G}} \\theta_{\\min}(T,L)\n$$\nIf a tie occurs, the smaller temperature is selected. This computational procedure is applied to each of the four test cases specified in the problem.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _calculate_interaction_energy(spins_flat, L):\n    \"\"\"\n    Calculates the total interaction energy sum for a given spin configuration.\n    The sum is over all nearest-neighbor pairs with periodic boundary conditions.\n    This is E_int = sum_{<i,j>} s_i s_j.\n    \"\"\"\n    N = L * L\n    spins = spins_flat.reshape((L, L))\n    energy_sum = 0\n    for r in range(L):\n        for c in range(L):\n            s_i = spins[r, c]\n            \n            # Interaction with right neighbor\n            s_j_right = spins[r, (c + 1) % L]\n            energy_sum += s_i * s_j_right\n            \n            # Interaction with down neighbor\n            s_j_down = spins[(r + 1) % L, c]\n            energy_sum += s_i * s_j_down\n    return energy_sum\n\ndef _get_polynomial_coeffs(L, T):\n    \"\"\"\n    Computes the coefficients a_k(beta) of the partition function polynomial.\n    \"\"\"\n    J = 1.0\n    beta = 1.0 / T\n    N = L * L\n    \n    # a_k are the coefficients for powers k=0, 1, ..., N\n    coeffs = np.zeros(N + 1, dtype=np.float64)\n\n    # Enumerate all 2^N spin configurations\n    for i in range(2**N):\n        # Generate spin configuration from integer representation\n        # Bit 0 -> spin +1, Bit 1 -> spin -1\n        spins_flat = np.ones(N, dtype=np.int8)\n        k_down_spins = 0\n        \n        temp_i = i\n        for j in range(N):\n            if (temp_i & 1) == 1:\n                spins_flat[j] = -1\n                k_down_spins += 1\n            temp_i >>= 1\n            \n        # Calculate interaction energy\n        energy_sum = _calculate_interaction_energy(spins_flat, L)\n        \n        # Accumulate weight into the corresponding coefficient\n        weight = np.exp(beta * J * energy_sum)\n        coeffs[k_down_spins] += weight\n        \n    return coeffs\n\ndef _estimate_tc_for_case(L, T_grid):\n    \"\"\"\n    Estimates the critical temperature for a single test case (L, T_grid).\n    \"\"\"\n    min_theta = float('inf')\n    T_est = -1.0\n    \n    for T in T_grid:\n        # 1. Compute polynomial coefficients a_k at temperature T\n        coeffs = _get_polynomial_coeffs(L, T)\n        \n        # 2. Find the roots of the polynomial P(z) = sum(a_k * z^k).\n        # np.roots expects coefficients from highest power to lowest.\n        roots = np.roots(coeffs[::-1])\n        \n        # 3. Calculate theta_min for this temperature\n        # Ensure roots are treated as complex numbers for angle calculation.\n        angles = np.angle(roots.astype(np.complex128))\n        theta_m = np.min(np.abs(angles))\n        \n        # 4. Update the estimated Tc if a new minimum theta is found\n        if theta_m < min_theta:\n            min_theta = theta_m\n            T_est = T\n            \n    return T_est\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, [1.5, 2.0, 2.2, 2.3, 2.5, 3.0]),\n        (3, [1.8, 2.0, 2.1, 2.2, 2.25, 2.3, 2.4, 2.6]),\n        (2, [1.0, 4.0]),\n        (3, [2.1, 2.2, 2.269185, 2.3]),\n    ]\n\n    results = []\n    for L, T_grid in test_cases:\n        estimated_tc = _estimate_tc_for_case(L, T_grid)\n        results.append(estimated_tc)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2422394"}]}