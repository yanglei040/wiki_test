{"hands_on_practices": [{"introduction": "Tridiagonal systems are not just abstract mathematical objects; they are the backbone of numerical solutions to many differential equations. In this exercise [@problem_id:2222858], you will see this connection firsthand by taking the one-dimensional steady-state heat equation, which describes temperature distribution in a rod, and discretizing it using the finite difference method. This fundamental process transforms a continuous physics problem into a solvable system of linear equations, illustrating why efficient tridiagonal solvers are indispensable in computational physics.", "problem": "Consider a thin, uniform metal rod of length $L = 0.500 \\text{ m}$. The rod's thermal conductivity is constant at $k = 200. \\text{ W/(m}\\cdot\\text{K)}$. The two ends of the rod are maintained at fixed temperatures: the temperature at $x=0$ is $T_A = 100. \\text{ °C}$, and the temperature at $x=L$ is $T_B = 50.0 \\text{ °C}$. The rod is subjected to an internal heat source that varies linearly along its length, described by the function $Q(x) = \\beta x$, where $\\beta = 8.00 \\times 10^4 \\text{ W/m}^4$. The steady-state temperature distribution $T(x)$ along the rod is governed by the one-dimensional heat equation:\n$$ k \\frac{d^2T}{dx^2} + Q(x) = 0 $$\nTo find an approximate numerical solution, the domain from $x=0$ to $x=L$ is discretized by defining 4 equally spaced internal points, $x_1, x_2, x_3, x_4$. These points, along with the endpoints $x_0=0$ and $x_5=L$, divide the rod into 5 equal segments. The second derivative in the heat equation is to be approximated using the centered finite difference formula:\n$$ \\frac{d^2T}{dx^2}\\bigg|_{x_i} \\approx \\frac{T_{i-1} - 2T_i + T_{i+1}}{(\\Delta x)^2} $$\nwhere $T_i$ represents the temperature $T(x_i)$ and $\\Delta x$ is the spacing between adjacent points.\n\nBy discretizing the governing differential equation, a system of linear algebraic equations for the unknown internal temperatures ($T_1, T_2, T_3, T_4$) is obtained. Calculate the temperature at the point $x_3$, which is located at three-fifths of the rod's length from the end at $x=0$.\n\nExpress your answer in degrees Celsius, rounded to three significant figures.", "solution": "The steady-state one-dimensional heat equation with a spatially varying internal heat source is\n$$\nk\\,\\frac{d^{2}T}{dx^{2}}+Q(x)=0,\n$$\nwith $Q(x)=\\beta x$. Discretizing the interval $[0,L]$ into 5 equal segments defines nodes $x_{i}=i\\,\\Delta x$ for $i=0,1,2,3,4,5$, where $\\Delta x=L/5$. Approximating the second derivative at internal nodes by the centered finite difference gives, for $i=1,2,3,4$,\n$$\nk\\,\\frac{T_{i-1}-2T_{i}+T_{i+1}}{(\\Delta x)^{2}}+Q(x_{i})=0.\n$$\nDefine $a=\\dfrac{k}{(\\Delta x)^{2}}$ and use $Q(x_{i})=\\beta x_{i}=\\beta i\\,\\Delta x$. With boundary conditions $T_{0}=T_{A}$ and $T_{5}=T_{B}$, the linear equations for the internal temperatures are\n$$\na\\,T_{i-1}-2a\\,T_{i}+a\\,T_{i+1}=-Q(x_{i}),\\quad i=1,2,3,4,\n$$\nwith $T_{0}$ and $T_{5}$ known.\n\nInsert the given data: $L=0.500$, $k=200$, $\\beta=8.00\\times 10^{4}$, $T_{A}=100$, $T_{B}=50.0$. Then\n$$\n\\Delta x=\\frac{L}{5}=0.100,\\qquad a=\\frac{k}{(\\Delta x)^{2}}=\\frac{200}{(0.100)^{2}}=20000,\n$$\nand\n$$\nQ(x_{i})=\\beta i\\,\\Delta x=(8.00\\times 10^{4})\\,i\\,(0.100)=8000\\,i.\n$$\nDivide each equation by $a$ to simplify:\n- For $i=1$: $T_{0}-2T_{1}+T_{2}=-\\dfrac{Q(x_{1})}{a}=-\\dfrac{8000}{20000}=-0.4$, hence $-2T_{1}+T_{2}=-0.4-T_{0}=-100.4$.\n- For $i=2$: $T_{1}-2T_{2}+T_{3}=-\\dfrac{16000}{20000}=-0.8$.\n- For $i=3$: $T_{2}-2T_{3}+T_{4}=-\\dfrac{24000}{20000}=-1.2$.\n- For $i=4$: $T_{3}-2T_{4}+T_{5}=-\\dfrac{32000}{20000}=-1.6$, hence $T_{3}-2T_{4}=-1.6-T_{5}=-51.6$.\n\nThus the system is\n$$\n\\begin{aligned}\n-2T_{1}+T_{2}&=-100.4,\\\\\nT_{1}-2T_{2}+T_{3}&=-0.8,\\\\\nT_{2}-2T_{3}+T_{4}&=-1.2,\\\\\nT_{3}-2T_{4}&=-51.6.\n\\end{aligned}\n$$\nSolve sequentially from the last equation:\n$$\nT_{3}=-51.6+2T_{4}.\n$$\nSubstitute into the third equation to express $T_{2}$ in terms of $T_{4}$:\n$$\nT_{2}-2(-51.6+2T_{4})+T_{4}=-1.2\\;\\Rightarrow\\;T_{2}=-104.4+3T_{4}.\n$$\nSubstitute $T_{2}$ and $T_{3}$ into the second equation to express $T_{1}$:\n$$\nT_{1}-2(-104.4+3T_{4})+(-51.6+2T_{4})=-0.8\\;\\Rightarrow\\;T_{1}=-158.0+4T_{4}.\n$$\nInsert $T_{1}$ and $T_{2}$ into the first equation to solve for $T_{4}$:\n$\n-2(-158.0+4T_{4})+(-104.4+3T_{4})=-100.4\n$\nwhich simplifies to\n$\n211.6-5T_{4}=-100.4\n$\nso\n$\n-5T_{4}=-312.0\\;\\Rightarrow\\;T_{4}=62.4.\n$\nThen\n$$\nT_{3}=-51.6+2(62.4)=73.2.\n$$\nTherefore, the temperature at $x_{3}$ (three-fifths of the rod length from $x=0$) is $73.2$ degrees Celsius, already at three significant figures as required.", "answer": "$$\\boxed{73.2}$$", "id": "2222858"}, {"introduction": "A key skill in computational science is recognizing how to decompose a complex problem into a series of simpler ones. This practice [@problem_id:2447589] presents the challenge of solving the system $A^2 x = b$, where $A$ is a tridiagonal matrix. A naive approach would be to compute the pentadiagonal matrix $A^2$ explicitly, but a far more elegant and efficient solution involves applying the Thomas algorithm twice. This exercise will help you develop the mindset of using solvers as modular tools, a cornerstone of effective algorithm design.", "problem": "Consider the linear system $A^2 x = b$ where $A \\in \\mathbb{R}^{n \\times n}$ is tridiagonal with strictly subdiagonal entries $a_i$ for $i = 2,\\dots,n$, diagonal entries $d_i$ for $i = 1,\\dots,n$, and strictly superdiagonal entries $c_i$ for $i = 1,\\dots,n-1$. Assume that $A$ is nonsingular and that all computations are performed in double precision floating point arithmetic. Your task is to derive, from the associativity of matrix multiplication and the uniqueness of solutions for nonsingular linear systems, a method to solve $A^2 x = b$ using only operations involving $A$ without ever forming the pentadiagonal matrix $A^2$. Then, implement this method in a program that uses a tridiagonal solver based on Gaussian elimination specialized to tridiagonal matrices. You must not form $A^2$ explicitly at any point.\n\nAs a measure of correctness, for each test case specified below, compute the infinity norm of the residual constructed without $A^2$ as $r = b - A(Ax)$ using only applications of the tridiagonal matrix $A$. Specifically, compute $y = A x$, then $z = A y$, and the residual $r = b - z$, and finally report $\\lVert r \\rVert_{\\infty} = \\max_i |r_i|$.\n\nImplement a function that solves tridiagonal systems robustly for nonsingular inputs, and apply it as needed by your method. Your implementation must be general and work for any valid tridiagonal input data of the sizes given.\n\nTest suite:\n- Test case $1$ (symmetric positive definite, uniform coefficients): $n = 6$, $a = (-1,-1,-1,-1,-1)$, $d = (2,2,2,2,2,2)$, $c = (-1,-1,-1,-1,-1)$, $b = (1,2,3,4,5,6)$.\n- Test case $2$ (nonsymmetric, strictly diagonally dominant): $n = 7$, $a = (-1,-1,-1,-1,-1,-1)$, $d = (3,3,3,3,3,3,3)$, $c = (2,2,2,2,2,2)$, $b = (1,-1,1,-1,1,-1,1)$.\n- Test case $3$ (scalar edge case): $n = 1$, $a = ()$, $d = (5)$, $c = ()$, $b = (3)$.\n- Test case $4$ (weak diagonal dominance, symmetric positive definite): $n = 10$, $a = (-1,-1,-1,-1,-1,-1,-1,-1,-1)$, $d = (2.001,2.001,2.001,2.001,2.001,2.001,2.001,2.001,2.001,2.001)$, $c = (-1,-1,-1,-1,-1,-1,-1,-1,-1)$, $b = (1,1,1,1,1,1,1,1,1,1)$.\n\nAll numbers in the vectors above are unitless scalars. Angles are not used. Percentages are not used.\n\nFinal output format: Your program should produce a single line of output containing the results for the four test cases, in order, as a comma-separated list of floating-point numbers enclosed in square brackets, for example $[r_1,r_2,r_3,r_4]$, where each $r_i$ is the infinity norm of the residual defined above for test case $i$.", "solution": "The problem requires solving the linear system $A^2 x = b$, where $A \\in \\mathbb{R}^{n \\times n}$ is a given nonsingular tridiagonal matrix, without explicitly computing the matrix $A^2$. The solution must be derived from fundamental principles of linear algebra and implemented using a specialized solver for tridiagonal systems.\n\nThe validation of the problem statement confirms its scientific and mathematical soundness. It is a well-posed problem in numerical linear algebra with complete and consistent data, requiring a standard, verifiable computational method. All provided test cases involve matrices for which the proposed algorithm is numerically stable.\n\n**Derivation of the Method**\n\nThe core of the method lies in the associativity of matrix multiplication. The equation to be solved is:\n$$A^2 x = b$$\nBy the associative property, we can group the multiplication as:\n$$A(Ax) = b$$\nThis structure suggests a decomposition of the problem into a sequence of two simpler problems. We introduce an intermediate vector $y \\in \\mathbb{R}^n$ defined as:\n$$y = Ax$$\nSubstituting this definition into the previous equation yields the first linear system:\n$$Ay = b$$\nSince the matrix $A$ is given to be nonsingular, a unique solution $y$ for this system exists. Once $y$ is determined, we can find the final solution $x$ by solving the second linear system, which is our initial definition of $y$:\n$$Ax = y$$\nAgain, the nonsingularity of $A$ guarantees a unique solution for $x$.\n\nThis two-step procedure correctly solves the original problem while adhering to the critical constraint of not forming the matrix $A^2$. The method consists of two sequential solves of linear systems involving the same tridiagonal matrix $A$:\n$1$. Solve $Ay = b$ to find the intermediate vector $y$.\n$2$. Solve $Ax = y$ to find the final solution vector $x$.\n\n**Algorithmic Implementation: The Thomas Algorithm**\n\nTo solve the tridiagonal systems $Ay=b$ and $Ax=y$, we employ the Thomas algorithm, also known as the Tridiagonal Matrix Algorithm (TDMA). This algorithm is a highly efficient form of Gaussian elimination specialized for tridiagonal matrices, with a computational complexity of $O(n)$, which is vastly superior to the $O(n^3)$ complexity of general Gaussian elimination.\n\nA tridiagonal system is defined by the matrix $A$ with a lower diagonal (subdiagonal) vector $a = (a_2, \\dots, a_n)$, a main diagonal vector $d = (d_1, \\dots, d_n)$, and an upper diagonal (superdiagonal) vector $c = (c_1, \\dots, c_{n-1})$. The $i$-th equation of the system $Af = g$ is:\n$$a_i f_{i-1} + d_i f_i + c_i f_{i+1} = g_i$$\nwhere, by convention, $a_1 = 0$ and $c_n = 0$.\n\nThe Thomas algorithm consists of two stages:\n\n$1$. **Forward Elimination**: The algorithm transforms the system into an equivalent upper bidiagonal system by eliminating the subdiagonal elements. This is achieved by modifying the coefficients of the main diagonal $d_i$ and the right-hand side vector $g_i$. The procedure involves computing a new set of coefficients, let us say $c'_i$ and $g'_i$:\nFor $i=1$:\n$$c'_1 = \\frac{c_1}{d_1}$$\n$$g'_1 = \\frac{g_1}{d_1}$$\nFor $i = 2, 3, \\dots, n-1$:\n$$m_i = d_i - a_i c'_{i-1}$$\n$$c'_i = \\frac{c_i}{m_i}$$\n$$g'_i = \\frac{g_i - a_i g'_{i-1}}{m_i}$$\nAnd for the last row, $i=n$:\n$$m_n = d_n - a_n c'_{n-1}$$\n$$g'_n = \\frac{g_n - a_n g'_{n-1}}{m_n}$$\nThis process is numerically stable without pivoting for matrices that are strictly or irreducibly diagonally dominant, or symmetric and positive definite, which is true for all test cases provided.\n\n$2$. **Backward Substitution**: After the forward elimination, the system has an upper bidiagonal form, which can be solved easily for the unknown vector $f$ by starting from the last equation and moving backward:\n$$f_n = g'_n$$\nFor $i = n-1, n-2, \\dots, 1$:\n$$f_i = g'_i - c'_i f_{i+1}$$\n\n**Verification of the Solution**\n\nTo assess the correctness of the computed solution $x$, we calculate the infinity norm of the residual vector, $r = b - A^2x$. As stipulated, $A^2$ is not formed. The term $A^2x$ is computed as $A(Ax)$.\nThe procedure is as follows:\n$1$. Compute the vector $y_{check} = Ax$. This is a matrix-vector multiplication involving the tridiagonal matrix $A$ and the computed solution $x$.\n$2$. Compute the vector $z_{check} = Ay_{check}$. This is a second application of the matrix $A$ to the result of the first multiplication.\n$3$. Compute the residual vector $r = b - z_{check}$.\n$4$. Compute the infinity norm of the residual, $\\lVert r \\rVert_{\\infty} = \\max_{i} |r_i|$. A small residual norm indicates that the computed solution $x$ is accurate.\n\nThis comprehensive approach solves the problem efficiently and robustly, satisfying all specified constraints. The total computational cost is dominated by the two applications of the Thomas algorithm, leading to an overall complexity of $O(n)$.", "answer": "```python\nimport numpy as np\n\ndef thomas_solver(a_sub, d_diag, c_super, b_rhs):\n    \"\"\"\n    Solves a tridiagonal system of linear equations Ax=b using the Thomas algorithm.\n\n    Args:\n        a_sub (np.ndarray): The sub-diagonal (length n-1).\n        d_diag (np.ndarray): The main diagonal (length n).\n        c_super (np.ndarray): The super-diagonal (length n-1).\n        b_rhs (np.ndarray): The right-hand side vector (length n).\n\n    Returns:\n        np.ndarray: The solution vector x (length n).\n    \"\"\"\n    n = len(d_diag)\n    if n == 0:\n        return np.array([])\n    if n == 1:\n        return np.array([b_rhs[0] / d_diag[0]])\n\n    # Create copies to avoid modifying input arrays\n    c_prime = np.zeros(n - 1)\n    b_prime = np.zeros(n)\n\n    # Forward elimination phase\n    c_prime[0] = c_super[0] / d_diag[0]\n    b_prime[0] = b_rhs[0] / d_diag[0]\n\n    for i in range(1, n - 1):\n        m = d_diag[i] - a_sub[i-1] * c_prime[i-1]\n        c_prime[i] = c_super[i] / m\n        b_prime[i] = (b_rhs[i] - a_sub[i-1] * b_prime[i-1]) / m\n        \n    m_last = d_diag[n-1] - a_sub[n-2] * c_prime[n-2]\n    b_prime[n-1] = (b_rhs[n-1] - a_sub[n-2] * b_prime[n-2]) / m_last\n\n    # Backward substitution phase\n    x = np.zeros(n)\n    x[n-1] = b_prime[n-1]\n    for i in range(n - 2, -1, -1):\n        x[i] = b_prime[i] - c_prime[i] * x[i+1]\n\n    return x\n\ndef matvec_tridiagonal(a_sub, d_diag, c_super, v):\n    \"\"\"\n    Computes the matrix-vector product Ax for a tridiagonal matrix A.\n\n    Args:\n        a_sub (np.ndarray): The sub-diagonal (length n-1).\n        d_diag (np.ndarray): The main diagonal (length n).\n        c_super (np.ndarray): The super-diagonal (length n-1).\n        v (np.ndarray): The vector to multiply with (length n).\n\n    Returns:\n        np.ndarray: The resulting vector Ax (length n).\n    \"\"\"\n    n = len(d_diag)\n    if n == 0:\n        return np.array([])\n    if n == 1:\n        return np.array([d_diag[0] * v[0]])\n\n    res = np.zeros(n)\n    \n    # First row\n    res[0] = d_diag[0] * v[0] + c_super[0] * v[1]\n    \n    # Middle rows\n    for i in range(1, n - 1):\n        res[i] = a_sub[i-1] * v[i-1] + d_diag[i] * v[i] + c_super[i] * v[i+1]\n        \n    # Last row\n    res[n-1] = a_sub[n-2] * v[n-2] + d_diag[n-1] * v[n-1]\n    \n    return res\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, solve them, and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 6,\n            \"a\": np.array([-1, -1, -1, -1, -1], dtype=np.float64),\n            \"d\": np.array([2, 2, 2, 2, 2, 2], dtype=np.float64),\n            \"c\": np.array([-1, -1, -1, -1, -1], dtype=np.float64),\n            \"b\": np.array([1, 2, 3, 4, 5, 6], dtype=np.float64)\n        },\n        {\n            \"n\": 7,\n            \"a\": np.array([-1, -1, -1, -1, -1, -1], dtype=np.float64),\n            \"d\": np.array([3, 3, 3, 3, 3, 3, 3], dtype=np.float64),\n            \"c\": np.array([2, 2, 2, 2, 2, 2], dtype=np.float64),\n            \"b\": np.array([1, -1, 1, -1, 1, -1, 1], dtype=np.float64)\n        },\n        {\n            \"n\": 1,\n            \"a\": np.array([], dtype=np.float64),\n            \"d\": np.array([5], dtype=np.float64),\n            \"c\": np.array([], dtype=np.float64),\n            \"b\": np.array([3], dtype=np.float64)\n        },\n        {\n            \"n\": 10,\n            \"a\": np.array([-1, -1, -1, -1, -1, -1, -1, -1, -1], dtype=np.float64),\n            \"d\": np.array([2.001] * 10, dtype=np.float64),\n            \"c\": np.array([-1, -1, -1, -1, -1, -1, -1, -1, -1], dtype=np.float64),\n            \"b\": np.array([1] * 10, dtype=np.float64)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        a, d, c, b = case[\"a\"], case[\"d\"], case[\"c\"], case[\"b\"]\n        \n        # Step 1: Solve Ay = b for y\n        y = thomas_solver(a, d, c, b)\n        \n        # Step 2: Solve Ax = y for x\n        x = thomas_solver(a, d, c, y)\n        \n        # Verification: compute norm of residual r = b - A(Ax)\n        y_check = matvec_tridiagonal(a, d, c, x)\n        z_check = matvec_tridiagonal(a, d, c, y_check)\n        residual = b - z_check\n        residual_norm = np.linalg.norm(residual, ord=np.inf)\n        \n        results.append(residual_norm)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2447589"}, {"introduction": "Physical models are often defined by their boundary conditions, and periodic systems are a common and important case in physics, appearing in models of crystals, rings, and periodic domains. When discretized, these problems yield cyclically tridiagonal matrices, which feature non-zero elements in the corners of the matrix, breaking the standard tridiagonal structure. This advanced exercise [@problem_id:2447642] guides you through using the Sherman-Morrison-Woodbury formula to extend the Thomas algorithm, enabling it to solve these cyclic systems efficiently and demonstrating how to adapt specialized solvers to new challenges.", "problem": "You are asked to build a robust, linear-time solver for cyclically tridiagonal linear systems that arise from finite-difference models with periodic boundary conditions. Starting from the foundational facts that central finite differences approximate second derivatives and that Gaussian elimination on tridiagonal matrices yields the Thomas algorithm, derive a method that uses a tridiagonal solver as a subroutine and corrects for the two corner couplings by applying a rank-update identity from linear algebra. The method must remain strictly linear in the system size and stable for strictly diagonally dominant inputs.\n\nConsider the one-dimensional operator with periodic boundary conditions that maps a grid function $u$ on $[0,1)$ to the discrete vector $f$ by the central difference approximation of $-u'' + \\mu u = f$, where $u$ is periodic and $\\mu > 0$ is a constant. Let $n \\in \\mathbb{N}$ be the number of grid points, $h = 1/n$ the grid spacing, and $x_i = i h$ for $i = 0,1,\\dots,n-1$. The discrete linear system has coefficient matrix $A \\in \\mathbb{R}^{n \\times n}$ with main diagonal entries $a_i = 2/h^2 + \\mu$, strict subdiagonal entries $b_i = -1/h^2$ for $i = 1,\\dots,n-1$, strict superdiagonal entries $c_i = -1/h^2$ for $i = 0,\\dots,n-2$, and the two corner entries $A_{0,n-1} = -1/h^2$ and $A_{n-1,0} = -1/h^2$ induced by periodicity. This is a cyclically tridiagonal matrix.\n\nYour task is to implement a program that:\n- Implements a reusable tridiagonal $LU$ factorization (Thomas algorithm) to solve $T y = r$ for a strictly tridiagonal matrix $T$ (with zero corner entries), for arbitrary right-hand sides $r$.\n- Adapts this tridiagonal solver to the cyclically tridiagonal system $A x = b$ by representing $A$ as a strictly tridiagonal matrix plus a low-rank update and then applying a rank-update identity from linear algebra (for example, the Sherman–Morrison–Woodbury identity) in a way that only requires solving a small number of tridiagonal systems and a constant-size dense system.\n- Verifies the correctness on a set of Fourier-mode right-hand sides for which the exact discrete solution is known, and also on one general non-symmetric cyclic case by reporting a residual norm.\n\nAngles used in trigonometric functions must be in radians.\n\nFor the verification, note the following well-tested fact: on the uniform periodic grid, the discrete Laplacian with periodic boundary conditions has discrete Fourier modes $v^{(k)}$ with entries $v^{(k)}_i = \\sin(2\\pi k x_i)$ and $v^{(k)}_i = \\cos(2\\pi k x_i)$ as eigenvectors. For $v^{(k)}_i = \\sin(2\\pi k x_i)$, the corresponding eigenvalue of the positive operator $(-\\Delta_h)$ is\n$$\n\\lambda_k = \\frac{4}{h^2} \\sin^2\\!\\left(\\frac{\\pi k}{n}\\right).\n$$\nTherefore, for the discrete system $(-\\Delta_h + \\mu I) u = f$ with $f_i = \\sin(2\\pi k x_i)$, the exact discrete solution is\n$$\nu_i = \\frac{1}{\\lambda_k + \\mu} \\sin(2\\pi k x_i).\n$$\n\nYour program must implement the cyclically tridiagonal solver and evaluate it on the following test suite. For each test, compute a scalar result as specified:\n\n- Test $1$ (general periodic case, happy path): $n = 10$, $\\mu = 1$, $k = 1$. Construct $A$ from the periodic stencil described above with $h = 1/n$, right-hand side $b_i = \\sin(2\\pi k x_i)$, and compute the exact discrete solution using the formula above. Output the maximum absolute error $\\max_i |x_i - u_i|$ as a floating-point number.\n- Test $2$ (smallest nontrivial size): $n = 3$, $\\mu = 1$, $k = 1$. Same construction and output as Test $1$.\n- Test $3$ (ill-conditioned but invertible): $n = 64$, $\\mu = 10^{-6}$, $k = 3$. Same construction and output as Test $1$.\n- Test $4$ (asymmetric cyclic system, residual check): $n = 5$ with strictly tridiagonal part defined by lower diagonal $b = [-1.0, -2.0, -1.0, -0.5]$, main diagonal $a = [4.0, 3.5, 3.0, 3.0, 2.5]$, upper diagonal $c = [-0.5, -1.5, -1.0, -2.0]$, and corner entries $A_{0,4} = \\alpha = 1.2$, $A_{4,0} = \\beta = -0.7$. Use the right-hand side $b = [1.0, 0.0, -1.0, 2.0, 0.5]^T$. Solve the cyclic system and output the infinity norm of the residual $\\|A x - b\\|_{\\infty}$ as a floating-point number.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"). Each result must be printed as a decimal floating-point number in scientific notation with exactly $10$ significant digits. No other text should be printed.\n\nYour implementation must be self-contained, require no user input, and be runnable in any modern programming language. For this assignment, you must submit a complete, runnable program.", "solution": "The user requires a solver for a cyclically tridiagonal linear system, $Ax=b$, of size $n \\times n$. Such systems frequently arise from numerical discretizations of differential equations with periodic boundary conditions, as described in the problem statement. A direct dense solver would require $O(n^3)$ operations, which is inefficient. The specified method involves leveraging the highly efficient Thomas algorithm for strictly tridiagonal systems, which has a linear time complexity of $O(n)$. This is achieved by representing the cyclic matrix $A$ as a sum of a strictly tridiagonal matrix $T$ and a low-rank correction matrix, and then applying the Sherman-Morrison-Woodbury (SMW) formula.\n\nFirst, we define the structure of the cyclically tridiagonal matrix $A \\in \\mathbb{R}^{n \\times n}$:\n$$\nA = \\begin{pmatrix}\nd_0 & c_0 & 0 & \\dots & \\beta \\\\\nb_1 & d_1 & c_1 & & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & \\vdots \\\\\n\\vdots & & b_{n-2} & d_{n-2} & c_{n-2} \\\\\n\\alpha & 0 & \\dots & b_{n-1} & d_{n-1}\n\\end{pmatrix}\n$$\nHere, $\\{d_i\\}$ is the main diagonal, $\\{b_i\\}$ is the subdiagonal, $\\{c_i\\}$ is the superdiagonal, and $\\alpha=A_{n-1,0}$ and $\\beta=A_{0,n-1}$ are the \"corner\" elements that violate the strict tridiagonal structure.\n\nThe core of the method is to decompose $A$ into a strictly tridiagonal part $T$ and a correction part. Let $T$ be the matrix $A$ with $\\alpha$ and $\\beta$ set to zero. The difference $A-T$ is a matrix with only two nonzero elements. This correction can be written as a rank-two update:\n$$\nA = T + \\alpha e_{n-1}e_{0}^T + \\beta e_{0}e_{n-1}^T\n$$\nwhere $e_i$ is the $i$-th standard basis vector (with index $0$ for the first element). This can be expressed in the form $A = T + UV^T$, which is suitable for the SMW formula. A convenient choice for $U, V \\in \\mathbb{R}^{n \\times 2}$ is:\n$$\nU = \\begin{bmatrix} e_0 & e_{n-1} \\end{bmatrix}, \\quad V^T = \\begin{bmatrix} \\beta e_{n-1}^T \\\\ \\alpha e_0^T \\end{bmatrix}\n$$\nThen, $UV^T = e_0(\\beta e_{n-1}^T) + e_{n-1}(\\alpha e_0^T) = \\beta e_0 e_{n-1}^T + \\alpha e_{n-1} e_0^T$, which is precisely the correction matrix.\n\nThe Sherman-Morrison-Woodbury formula gives the inverse of $A$ as:\n$$\nA^{-1} = (T + UV^T)^{-1} = T^{-1} - T^{-1}U(I_2 + V^T T^{-1} U)^{-1} V^T T^{-1}\n$$\nwhere $I_2$ is the $2 \\times 2$ identity matrix. To solve $Ax=b$, we compute $x = A^{-1}b$:\n$$\nx = T^{-1}b - T^{-1}U(I_2 + V^T T^{-1} U)^{-1} V^T (T^{-1}b)\n$$\nA direct computation using this formula would be inefficient. Instead, we devise a step-by-step algorithm that avoids explicit matrix inversions.\n\nLet's define auxiliary vectors and matrices:\n1.  Let $y = T^{-1}b$. This is the solution to the tridiagonal system $Ty = b$.\n2.  Let $Z = T^{-1}U$. This matrix $Z \\in \\mathbb{R}^{n \\times 2}$ can be found by solving two tridiagonal systems, one for each column of $U$. Let the columns of $Z$ be $z_1$ and $z_2$. Then $Tz_1 = e_0$ and $Tz_2 = e_{n-1}$.\n\nSubstituting these into the expression for $x$:\n$$\nx = y - Z(I_2 + V^T Z)^{-1} V^T y\n$$\nThis structure suggests the following numerical algorithm:\n\n**Algorithm for Cyclically Tridiagonal Systems**\n\n1.  Given $A$ and $b$, extract the tridiagonal part $T$ (diagonals $\\{d_i\\}$, $\\{b_i\\}$, $\\{c_i\\}$) and the corner elements $\\alpha=A_{n-1,0}$, $\\beta=A_{0,n-1}$.\n2.  Using an efficient tridiagonal solver (the Thomas algorithm), solve the following three linear systems:\n    a. $Ty = b$\n    b. $Tz_1 = e_0$\n    c. $Tz_2 = e_{n-1}$\n3.  Construct the $2 \\times 2$ matrix $M = I_2 + V^T Z$. The elements of $V^T Z$ are:\n    $$\n    V^T Z = \\begin{pmatrix} \\beta e_{n-1}^T \\\\ \\alpha e_0^T \\end{pmatrix} \\begin{bmatrix} z_1 & z_2 \\end{bmatrix} = \\begin{pmatrix} \\beta z_{1,n-1} & \\beta z_{2,n-1} \\\\ \\alpha z_{1,0} & \\alpha z_{2,0} \\end{pmatrix}\n    $$\n    where $z_{j,i}$ is the $i$-th component of vector $z_j$. So,\n    $$\n    M = \\begin{pmatrix} 1 + \\beta z_{1,n-1} & \\beta z_{2,n-1} \\\\ \\alpha z_{1,0} & 1 + \\alpha z_{2,0} \\end{pmatrix}\n    $$\n4.  Construct the $2 \\times 1$ vector $w = V^T y$:\n    $$\n    w = \\begin{pmatrix} \\beta y_{n-1} \\\\ \\alpha y_0 \\end{pmatrix}\n    $$\n5.  Solve the small $2 \\times 2$ system $Mq = w$ for the vector $q = [q_1, q_2]^T$.\n6.  The final solution is given by the correction formula: $x = y - Zq$, which expands to:\n    $$\n    x = y - q_1 z_1 - q_2 z_2\n    $$\n\nThis algorithm's total cost is dominated by the three calls to the Thomas algorithm, resulting in an overall complexity of $O(n)$, as required. The method is numerically stable for strictly diagonally dominant matrices, as the Thomas algorithm is stable in this case, and the $2 \\times 2$ matrix $M$ is typically well-conditioned.\n\nThe problem requires verification using specific test cases. For tests involving the discretized Helmholtz operator $-u'' + \\mu u = f$ with $\\mu > 0$, the resulting matrix $A$ is strictly diagonally dominant, guaranteeing stability. The provided analytical solution for Fourier mode inputs serves as an exact benchmark. For the general non-symmetric case, the residual norm $\\|Ax-b\\|_{\\infty}$ provides a reliable measure of the solution's accuracy.", "answer": "```python\nimport numpy as np\n\ndef thomas_solver(a_sub, d_main, c_super, r):\n    \"\"\"\n    Solves a strictly tridiagonal system Tx = r using the Thomas algorithm.\n    T is defined by its diagonals.\n    \n    Args:\n        a_sub (np.ndarray): The sub-diagonal (length n-1). a_sub[i] is T[i+1, i].\n        d_main (np.ndarray): The main diagonal (length n).\n        c_super (np.ndarray): The super-diagonal (length n-1). c_super[i] is T[i, i+1].\n        r (np.ndarray): The right-hand side vector (length n).\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(d_main)\n    if n == 0:\n        return np.array([])\n    if n == 1:\n        return np.array([r[0] / d_main[0]])\n\n    c_prime = np.zeros(n - 1)\n    r_prime = np.zeros(n)\n    \n    # Forward elimination\n    c_prime[0] = c_super[0] / d_main[0]\n    r_prime[0] = r[0] / d_main[0]\n\n    for i in range(1, n - 1):\n        den = d_main[i] - a_sub[i-1] * c_prime[i-1]\n        c_prime[i] = c_super[i] / den\n    \n    for i in range(1, n):\n        den = d_main[i] - a_sub[i-1] * c_prime[i-1]\n        r_prime[i] = (r[i] - a_sub[i-1] * r_prime[i-1]) / den\n\n    # Backward substitution\n    x = np.zeros(n)\n    x[n-1] = r_prime[n-1]\n    for i in range(n - 2, -1, -1):\n        x[i] = r_prime[i] - c_prime[i] * x[i+1]\n        \n    return x\n\ndef cyclic_solver(d_main, a_sub, c_super, alpha, beta, b_rhs):\n    \"\"\"\n    Solves a cyclically tridiagonal system Ax = b using the Sherman-Morrison-Woodbury formula.\n\n    Args:\n        d_main (np.ndarray): Main diagonal of A.\n        a_sub (np.ndarray): Sub-diagonal of A.\n        c_super (np.ndarray): Super-diagonal of A.\n        alpha (float): Corner element A[n-1, 0].\n        beta (float): Corner element A[0, n-1].\n        b_rhs (np.ndarray): Right-hand side vector.\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(d_main)\n    \n    # 1. Solve Ty = b for the tridiagonal part T\n    y = thomas_solver(a_sub, d_main, c_super, b_rhs)\n    \n    # 2. Solve for correction vectors z1 and z2\n    # T z1 = e_0 and T z2 = e_{n-1}\n    u1 = np.zeros(n)\n    u1[0] = 1.0\n    z1 = thomas_solver(a_sub, d_main, c_super, u1)\n    \n    u2 = np.zeros(n)\n    u2[n-1] = 1.0\n    z2 = thomas_solver(a_sub, d_main, c_super, u2)\n    \n    # 3. Form and solve the 2x2 system Mq = w\n    # U = [e_0, e_{n-1}], V^T = [[beta*e_{n-1}^T], [alpha*e_0^T]]\n    M = np.array([\n        [1.0 + beta * z1[n-1], beta * z2[n-1]],\n        [alpha * z1[0],       1.0 + alpha * z2[0]]\n    ])\n    \n    # w = V^T y\n    w = np.array([beta * y[n-1], alpha * y[0]])\n    \n    q = np.linalg.solve(M, w)\n    \n    # 4. Compute final solution x = y - Zq\n    x = y - q[0] * z1 - q[1] * z2\n    \n    return x\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'id': 1, 'n': 10, 'mu': 1.0, 'k': 1},\n        {'id': 2, 'n': 3, 'mu': 1.0, 'k': 1},\n        {'id': 3, 'n': 64, 'mu': 1e-6, 'k': 3},\n        {'id': 4}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        if case['id'] <= 3:\n            n, mu, k = case['n'], case['mu'], case['k']\n            h = 1.0 / n\n            x_grid = np.arange(n) * h\n            \n            d_val = 2.0 / h**2 + mu\n            s_val = -1.0 / h**2\n            \n            d_main = np.full(n, d_val)\n            a_sub = np.full(n - 1, s_val)\n            c_super = np.full(n - 1, s_val)\n            alpha = beta = s_val\n            \n            b_rhs = np.sin(2 * np.pi * k * x_grid)\n            \n            x_sol = cyclic_solver(d_main, a_sub, c_super, alpha, beta, b_rhs)\n            \n            lambda_k = (4.0 / h**2) * np.sin(np.pi * k / n)**2\n            u_exact = (1.0 / (lambda_k + mu)) * b_rhs\n            \n            error = np.max(np.abs(x_sol - u_exact))\n            results.append(f\"{error:.9e}\")\n        \n        else: # Test 4\n            n = 5\n            d_main = np.array([4.0, 3.5, 3.0, 3.0, 2.5])\n            a_sub = np.array([-1.0, -2.0, -1.0, -0.5])\n            c_super = np.array([-0.5, -1.5, -1.0, -2.0])\n            alpha = -0.7\n            beta = 1.2\n            b_rhs = np.array([1.0, 0.0, -1.0, 2.0, 0.5])\n            \n            x_sol = cyclic_solver(d_main, a_sub, c_super, alpha, beta, b_rhs)\n            \n            # Reconstruct matrix A to compute residual\n            A = np.diag(d_main) + np.diag(a_sub, k=-1) + np.diag(c_super, k=1)\n            A[0, n-1] = beta\n            A[n-1, 0] = alpha\n            \n            residual = np.linalg.norm(A @ x_sol - b_rhs, ord=np.inf)\n            results.append(f\"{residual:.9e}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2447642"}]}