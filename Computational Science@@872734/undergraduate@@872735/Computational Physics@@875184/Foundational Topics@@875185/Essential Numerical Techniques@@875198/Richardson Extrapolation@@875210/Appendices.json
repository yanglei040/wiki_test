{"hands_on_practices": [{"introduction": "To begin, we will apply Richardson extrapolation in its most straightforward form. This first practice [@problem_id:2197893] presents a common scenario in computational science: we have two numerical estimates from a method with a known first-order error, $\\mathcal{O}(h)$. By combining these estimates, you can systematically cancel this leading error term to produce a more accurate result, demonstrating the power of the technique with minimal complexity.", "problem": "A team of aerospace engineers is developing a computer simulation to predict the final landing velocity of a probe on a newly discovered exoplanet. The simulation employs a numerical integration algorithm to solve the equations of motion. It is known that the primary numerical method used has a global truncation error of the first order, commonly denoted as $\\mathcal{O}(h)$, where $h$ is the time step of the simulation.\n\nThe team conducts two simulation runs with different time steps to assess the convergence of their results.\n1.  With a time step of $h_1 = 0.20$ seconds, the simulation predicts a final landing velocity of $V(h_1) = 15.60$ m/s.\n2.  With a reduced time step of $h_2 = 0.10$ seconds, the simulation yields a more refined landing velocity of $V(h_2) = 15.85$ m/s.\n\nTo obtain a more accurate prediction without the computational expense of running another simulation with an even smaller time step, the team decides to use Richardson extrapolation. Apply Richardson extrapolation to the two available velocity estimates to compute an improved estimate of the true landing velocity.\n\nExpress your final answer for the improved velocity in m/s, rounded to four significant figures.", "solution": "Let the true landing velocity be $V$ and the numerical estimate with time step $h$ be $V(h)$. For a first-order method, the global truncation error model is\n$$\nV(h) = V + C h + \\mathcal{O}(h^{2}),\n$$\nwhere $C$ is an $h$-independent constant. For two step sizes $h_{1}$ and $h_{2}$, we have\n$$\nV(h_{1}) = V + C h_{1} + \\mathcal{O}(h_{1}^{2}), \\quad V(h_{2}) = V + C h_{2} + \\mathcal{O}(h_{2}^{2}).\n$$\nNeglecting $\\mathcal{O}(h^{2})$ terms and eliminating $C$ gives\n$$\nC \\approx \\frac{V(h_{2}) - V(h_{1})}{h_{2} - h_{1}}, \\quad V \\approx V(h_{2}) - C h_{2}.\n$$\nSubstituting $C$ yields the Richardson extrapolation formula for a first-order method:\n$$\nV \\approx V(h_{2}) - h_{2}\\,\\frac{V(h_{2}) - V(h_{1})}{h_{2} - h_{1}} = V(h_{2}) + \\frac{V(h_{2}) - V(h_{1})}{\\frac{h_{1}}{h_{2}} - 1}.\n$$\nWith $h_{1} = 0.20$, $h_{2} = 0.10$, $V(h_{1}) = 15.60$, and $V(h_{2}) = 15.85$, the step ratio is $r = \\frac{h_{1}}{h_{2}} = 2$, so\n$$\nV \\approx 15.85 + \\frac{15.85 - 15.60}{2 - 1} = 15.85 + 0.25 = 16.10.\n$$\nRounded to four significant figures, the improved estimate of the true landing velocity is $16.10$.", "answer": "$$\\boxed{16.10}$$", "id": "2197893"}, {"introduction": "Having practiced the basic application, we now explore the 'why' behind the formula itself. This exercise [@problem_id:2197927] reverses the problem: given a specific extrapolation formula, your task is to deduce the order of the error, $p$, from the underlying numerical method's error expansion, $L = A(h) + C h^{p} + \\mathcal{O}(h^q)$. This practice is crucial for understanding that an extrapolation formula is uniquely tailored to the error characteristics of the method it aims to improve.", "problem": "In a numerical analysis task, a function $A(h)$ provides an approximation to an unknown exact value $L$. The approximation depends on a small positive step size $h$. The error of this approximation is known to follow the asymptotic relationship:\n$$L = A(h) + C h^{p} + \\mathcal{O}(h^{q})$$\nwhere $C$ is a non-zero constant, $p$ is a positive integer representing the order of the leading error term, and $q$ is another integer such that $q > p$.\n\nTo obtain a more accurate estimate for $L$, a single step of Richardson extrapolation is performed using the approximations at step sizes $h$ and $h/2$. The resulting extrapolated value, denoted $R(h)$, is calculated using the following specific formula:\n$$R(h) = \\frac{4A(h/2) - A(h)}{3}$$\nThe new approximation $R(h)$ converges to $L$ faster than $A(h)$ as $h \\to 0$. By analyzing the structure of this extrapolation formula, determine the integer value of $p$.", "solution": "We start from the given asymptotic expansion\n$$L = A(h) + C h^{p} + \\mathcal{O}(h^{q}),$$\nwith $C \\neq 0$, $p \\in \\mathbb{Z}_{>0}$, and $q > p$. Rearranging, this gives\n$$A(h) = L - C h^{p} + \\mathcal{O}(h^{q}).$$\nReplacing $h$ by $h/2$ yields\n$$A(h/2) = L - C \\left(\\frac{h}{2}\\right)^{p} + \\mathcal{O}\\left(\\left(\\frac{h}{2}\\right)^{q}\\right) = L - C 2^{-p} h^{p} + \\mathcal{O}(h^{q}),$$\nsince $\\mathcal{O}\\left((h/2)^{q}\\right) = \\mathcal{O}(h^{q})$.\n\nThe Richardson extrapolation provided is\n$$R(h) = \\frac{4 A(h/2) - A(h)}{3}.$$\nSubstitute the expansions of $A(h/2)$ and $A(h)$:\n$$R(h) = \\frac{4\\left(L - C 2^{-p} h^{p} + \\mathcal{O}(h^{q})\\right) - \\left(L - C h^{p} + \\mathcal{O}(h^{q})\\right)}{3}.$$\nSimplify the numerator:\n$$4L - 4 C 2^{-p} h^{p} + \\mathcal{O}(h^{q}) - L + C h^{p} - \\mathcal{O}(h^{q}) = 3L + h^{p}\\left(C - 4 C 2^{-p}\\right) + \\mathcal{O}(h^{q}).$$\nTherefore,\n$$R(h) = L + \\frac{h^{p}}{3} C \\left(1 - 4 \\cdot 2^{-p}\\right) + \\mathcal{O}(h^{q}).$$\n\nFor $R(h)$ to converge faster than $A(h)$, the coefficient of the leading error term $h^{p}$ must vanish, which requires\n$$1 - 4 \\cdot 2^{-p} = 0 \\quad \\Longrightarrow \\quad 4 = 2^{p} \\quad \\Longrightarrow \\quad p = 2.$$\nThus, the structure of the given extrapolation formula implies that the leading error order is $p=2$.", "answer": "$$\\boxed{2}$$", "id": "2197927"}, {"introduction": "Our final practice [@problem_id:2435010] transitions from theory to a complete, hands-on implementation. You will simulate the motion of a nonlinear pendulum using the second-order Verlet algorithm and then apply Richardson extrapolation to obtain a high-precision estimate of its oscillation period. This problem illustrates how the technique is used to refine results from complex simulations, bridging the gap between numerical theory and computational physics research.", "problem": "You are asked to design and implement a program that uses Richardson extrapolation to improve the numerical estimate of the oscillation period of a nonlinear pendulum, when the pendulumâ€™s motion is simulated with the Verlet algorithm. Work entirely in the International System of Units (SI units). Angles must be in radians, time in seconds, length in meters, and acceleration in meters per second squared. Your program must produce a single line of output as described at the end.\n\nThe physical model is the planar, undamped, nonlinear pendulum of length $L$ and gravitational acceleration $g$, with angular displacement $\\theta(t)$ evolving by the ordinary differential equation (ODE)\n$$\n\\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\,\\sin\\!\\big(\\theta(t)\\big) = 0.\n$$\nAssume initial conditions $\\theta(0) = \\theta_0$ and $\\frac{d\\theta}{dt}(0) = 0$.\n\nSimulate the motion using the velocity Verlet algorithm (a second-order symplectic method), treating the state variables $\\theta$ and $\\omega = d\\theta/dt$ and the acceleration $a(\\theta) = -\\frac{g}{L}\\sin(\\theta)$. Evolve the system with a fixed time step $\\Delta t$ over a long enough time window to determine the oscillation period $T(\\Delta t)$. Estimate the period by detecting two successive zero-crossings of $\\theta$ with the same direction of crossing (e.g., both crossings from positive to negative), and compute the time difference between those two crossings. Use linear interpolation between discrete time samples to estimate each zero-crossing time. Repeat the simulation with the refined time step $\\Delta t/2$ to obtain $T(\\Delta t/2)$.\n\nAssume that the leading-order global discretization error of any smooth scalar quantity extracted from a velocity Verlet trajectory scales as $\\mathcal{O}(\\Delta t^2)$. Using this assumption, apply Richardson extrapolation to combine $T(\\Delta t)$ and $T(\\Delta t/2)$ into an improved estimate $\\widehat{T}$ of the true period $T$, by eliminating the leading error term.\n\nImplement the above for the following test suite of parameter sets, which are chosen to probe multiple regimes:\n- Case $1$ (happy path, moderate amplitude): $L = 1.0\\,\\text{m}$, $g = 9.81\\,\\text{m}/\\text{s}^2$, $\\theta_0 = 0.5\\,\\text{rad}$, $\\Delta t = 0.05\\,\\text{s}$.\n- Case $2$ (larger amplitude, more nonlinearity): $L = 1.0\\,\\text{m}$, $g = 9.81\\,\\text{m}/\\text{s}^2$, $\\theta_0 = 1.2\\,\\text{rad}$, $\\Delta t = 0.05\\,\\text{s}$.\n- Case $3$ (near-separatrix edge case, very large amplitude): $L = 1.0\\,\\text{m}$, $g = 9.81\\,\\text{m}/\\text{s}^2$, $\\theta_0 = 2.9\\,\\text{rad}$, $\\Delta t = 0.02\\,\\text{s}$.\n\nYour program must:\n- For each case, simulate with $\\Delta t$ and $\\Delta t/2$, estimate $T(\\Delta t)$ and $T(\\Delta t/2)$ from same-direction zero-crossings of $\\theta(t)$, and then compute the Richardson-extrapolated period estimate $\\widehat{T}$.\n- Express each final period estimate $\\widehat{T}$ in seconds, rounded to $6$ decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the three extrapolated period estimates as a comma-separated list enclosed in square brackets, in the order of the cases above, for example, $[\\widehat{T}_1,\\widehat{T}_2,\\widehat{T}_3]$. Ensure each $\\widehat{T}_k$ is rounded to $6$ decimal places.", "solution": "The problem statement is subjected to rigorous validation before any attempt at a solution.\n\n**Step 1: Extract Givens**\n\n-   **Governing Equation**: $\\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\,\\sin(\\theta(t)) = 0$.\n-   **Initial Conditions**: $\\theta(0) = \\theta_0$, $\\frac{d\\theta}{dt}(0) = 0$.\n-   **Numerical Integrator**: Velocity Verlet algorithm.\n-   **State Variables**: $\\theta$ (angular displacement) and $\\omega = d\\theta/dt$ (angular velocity).\n-   **Acceleration Function**: $a(\\theta) = -\\frac{g}{L}\\sin(\\theta)$.\n-   **Period Estimation Method**: Time interval between two successive zero-crossings of $\\theta(t)$ in the same direction, located using linear interpolation.\n-   **Error Assumption**: The global discretization error for quantities derived from the simulation scales as $\\mathcal{O}(\\Delta t^2)$.\n-   **Improvement Method**: Richardson extrapolation using results from time steps $\\Delta t$ and $\\Delta t/2$.\n-   **Test Case 1**: $L = 1.0\\,\\text{m}$, $g = 9.81\\,\\text{m}/\\text{s}^2$, $\\theta_0 = 0.5\\,\\text{rad}$, $\\Delta t = 0.05\\,\\text{s}$.\n-   **Test Case 2**: $L = 1.0\\,\\text{m}$, $g = 9.81\\,\\text{m}/\\text{s}^2$, $\\theta_0 = 1.2\\,\\text{rad}$, $\\Delta t = 0.05\\,\\text{s}$.\n-   **Test Case 3**: $L = 1.0\\,\\text{m}$, $g = 9.81\\,\\text{m}/\\text{s}^2$, $\\theta_0 = 2.9\\,\\text{rad}$, $\\Delta t = 0.02\\,\\text{s}$.\n-   **Output Format**: A comma-separated list of three extrapolated period estimates $[\\widehat{T}_1, \\widehat{T}_2, \\widehat{T}_3]$, with each value rounded to $6$ decimal places.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is evaluated against the validation criteria.\n\n-   **Scientific Grounding**: The problem concerns the nonlinear pendulum, a canonical system in classical mechanics. Its governing equation is correctly stated. The velocity Verlet algorithm is a standard, robust symplectic integrator for such systems. Richardson extrapolation is a fundamental technique in numerical analysis. The assumed $\\mathcal{O}(\\Delta t^2)$ global error for the Verlet method is correct. The problem is scientifically and mathematically sound.\n-   **Well-Posedness**: The problem is well-posed. The ODE with specified initial conditions has a unique solution. The numerical method, step sizes, and procedure for period estimation are explicitly defined. This structure guarantees that a unique, meaningful solution can be computed.\n-   **Objectivity**: The problem is stated in precise, objective language. All parameters are quantified, and the required output is specified unambiguously.\n-   **Completeness**: All necessary information is provided. The instruction to simulate for a \"long enough time window\" is a standard directive in such problems, meaning the simulation must span at least one full period to capture the necessary data points. This is not an ambiguity but a logical necessity of the task.\n\n**Step 3: Verdict and Action**\n\nThe problem is scientifically grounded, well-posed, objective, and complete. It is **valid**. A solution will be provided.\n\nThe task is to compute a high-accuracy estimate of the oscillation period of a nonlinear pendulum. This requires three components: a numerical simulation of the dynamics, a method to extract the period from the simulation data, and an extrapolation technique to improve the accuracy of the result.\n\nThe physical system is a simple pendulum of length $L$ in a gravitational field with acceleration $g$. Its motion is described by the angular displacement $\\theta(t)$. The governing second-order nonlinear ordinary differential equation is:\n$$\n\\frac{d^2 \\theta}{dt^2} = -\\frac{g}{L} \\sin(\\theta(t))\n$$\nWe define the state of the system with the angle $\\theta$ and angular velocity $\\omega = \\frac{d\\theta}{dt}$. The system is simulated starting from rest, so the initial conditions are $\\theta(0) = \\theta_0$ and $\\omega(0) = 0$.\n\nThe evolution of the system is computed numerically using the velocity Verlet algorithm, a second-order symplectic method well-suited for conservative mechanical systems. Given the state $(\\theta_n, \\omega_n)$ at time $t_n = n \\Delta t$, where $\\Delta t$ is the time step, the state at time $t_{n+1}$ is found through the following steps:\n1.  Compute the angle-dependent acceleration: $a_n = a(\\theta_n) = -\\frac{g}{L} \\sin(\\theta_n)$.\n2.  Update the velocity by a half-step: $\\omega_{n+1/2} = \\omega_n + a_n \\frac{\\Delta t}{2}$.\n3.  Update the position by a full step using this intermediate velocity: $\\theta_{n+1} = \\theta_n + \\omega_{n+1/2} \\Delta t$.\n4.  Compute the new acceleration: $a_{n+1} = a(\\theta_{n+1}) = -\\frac{g}{L} \\sin(\\theta_{n+1})$.\n5.  Update the velocity by the second half-step: $\\omega_{n+1} = \\omega_{n+1/2} + a_{n+1} \\frac{\\Delta t}{2}$.\n\nThe period of oscillation, $T$, is determined by tracking the angular position $\\theta(t)$. Since the pendulum is released from rest at a positive angle $\\theta_0$, its first zero-crossing will be in the negative direction (downward). A full period is the time elapsed between two successive zero-crossings in the same direction. We will find the time of the first downward crossing and the second downward crossing. If a crossing occurs between time $t_{n-1}$ and $t_n$, where $\\theta_{n-1} > 0$ and $\\theta_n \\leq 0$, we use linear interpolation to find a more precise estimate of the crossing time, $t_{cross}$:\n$$\nt_{cross} = t_{n-1} - \\theta_{n-1} \\frac{\\Delta t}{\\theta_n - \\theta_{n-1}}\n$$\nLet the times of the first two such crossings be $t_{cross,1}$ and $t_{cross,2}$. The numerical estimate of the period for a given time step $\\Delta t$ is then $T(\\Delta t) = t_{cross,2} - t_{cross,1}$.\n\nThe velocity Verlet algorithm has a global error of order two. This implies that the numerically computed period $T(\\Delta t)$ relates to the true period $T_{true}$ as:\n$$\nT(\\Delta t) = T_{true} + C (\\Delta t)^2 + \\mathcal{O}(\\Delta t^4)\n$$\nwhere $C$ is a constant independent of $\\Delta t$. We perform two simulations: one with step size $\\Delta t$ to get $T(\\Delta t)$, and another with step size $\\Delta t/2$ to get $T(\\Delta t/2)$. We have:\n$$\nT(\\Delta t/2) = T_{true} + C \\left(\\frac{\\Delta t}{2}\\right)^2 + \\mathcal{O}(\\Delta t^4) = T_{true} + \\frac{1}{4} C (\\Delta t)^2 + \\mathcal{O}(\\Delta t^4)\n$$\nWe can eliminate the leading $\\mathcal{O}(\\Delta t^2)$ error term by forming a linear combination of these two equations. Multiplying the second equation by $4$ and subtracting the first yields:\n$$\n4T(\\Delta t/2) - T(\\Delta t) = (4T_{true} - T_{true}) + (C(\\Delta t)^2 - C(\\Delta t)^2) + \\mathcal{O}(\\Delta t^4) = 3T_{true} + \\mathcal{O}(\\Delta t^4)\n$$\nSolving for $T_{true}$ gives the Richardson-extrapolated estimate, $\\widehat{T}$, which is accurate to $\\mathcal{O}(\\Delta t^4)$:\n$$\n\\widehat{T} = \\frac{4T(\\Delta t/2) - T(\\Delta t)}{3}\n$$\nThis procedure is applied to each test case to obtain the final, improved period estimates.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_period_from_simulation(L, g, theta0, dt):\n    \"\"\"\n    Simulates the nonlinear pendulum using the velocity Verlet algorithm and\n    calculates the oscillation period.\n\n    The period is determined by finding the time between two successive\n    downward zero-crossings of the angle theta, using linear interpolation\n    for precision.\n\n    Args:\n        L (float): Length of the pendulum in meters.\n        g (float): Gravitational acceleration in m/s^2.\n        theta0 (float): Initial angular displacement in radians.\n        dt (float): Time step for the simulation in seconds.\n\n    Returns:\n        float: The estimated period of oscillation in seconds.\n               Returns None if the period cannot be determined.\n    \"\"\"\n    theta = theta0\n    omega = 0.0\n    t = 0.0\n    \n    # Pre-calculate constant for acceleration\n    g_over_L = g / L\n\n    # Store previous state to detect crossing\n    theta_prev = theta\n\n    # Store times of downward zero crossings (theta from positive to negative)\n    crossing_times = []\n\n    # Estimate a safe maximum simulation time. The period increases with amplitude.\n    # The small angle period is 2*pi*sqrt(L/g). The true period is always longer.\n    # For theta0 near pi, the period can be very long.\n    # We simulate for at least 1.5 times a generous estimate of the period.\n    approx_period = 2.0 * np.pi * np.sqrt(L / g) * (1 + theta0**2 / 16.0)\n    if theta0 > 2.8: # Near separatrix, period grows rapidly\n        max_t = 10.0\n    else:\n        max_t = approx_period * 2.0\n    \n    # Simulation loop\n    num_steps = int(max_t / dt)\n    for _ in range(num_steps):\n        # Velocity Verlet integration step\n        accel_prev = -g_over_L * np.sin(theta)\n        omega_half = omega + 0.5 * accel_prev * dt\n        theta_next = theta + omega_half * dt\n        accel_next = -g_over_L * np.sin(theta_next)\n        omega_next = omega_half + 0.5 * accel_next * dt\n        \n        t += dt\n        theta_prev = theta\n        theta = theta_next\n        omega = omega_next\n\n        # Detect downward zero-crossing: theta from positive to non-positive\n        if theta_prev > 0 and theta <= 0:\n            # Linear interpolation to find the precise crossing time t_cross\n            # Point 1: (t-dt, theta_prev), Point 2: (t, theta)\n            # Equation of line: T(th) = (t-dt) + (th - theta_prev) * dt / (theta - theta_prev)\n            # Find T at th=0:\n            t_cross = (t - dt) - theta_prev * dt / (theta - theta_prev)\n            crossing_times.append(t_cross)\n            \n            # If two downward crossings are found, calculate period and exit\n            if len(crossing_times) >= 2:\n                return crossing_times[1] - crossing_times[0]\n                \n    # This part should not be reached if max_t is sufficient\n    return None\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the Richardson-extrapolated period for each case and\n    prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # (L, g, theta0, dt)\n        (1.0, 9.81, 0.5, 0.05),\n        (1.0, 9.81, 1.2, 0.05),\n        (1.0, 9.81, 2.9, 0.02),\n    ]\n\n    results = []\n    \n    for i, case in enumerate(test_cases):\n        L, g, theta0, dt = case\n        \n        # Calculate period with coarse time step dt\n        T_coarse = get_period_from_simulation(L, g, theta0, dt)\n        \n        # Calculate period with fine time step dt/2\n        T_fine = get_period_from_simulation(L, g, theta0, dt / 2.0)\n        \n        if T_coarse is None or T_fine is None:\n            raise ValueError(f\"Failed to determine period for case {i+1}\")\n\n        # Apply Richardson extrapolation for a method with O(h^2) error\n        # T_extrapolated = (4 * T_fine - T_coarse) / 3\n        T_extrapolated = (4.0 * T_fine - T_coarse) / 3.0\n        \n        # Format the result to 6 decimal places\n        results.append(f\"{T_extrapolated:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2435010"}]}