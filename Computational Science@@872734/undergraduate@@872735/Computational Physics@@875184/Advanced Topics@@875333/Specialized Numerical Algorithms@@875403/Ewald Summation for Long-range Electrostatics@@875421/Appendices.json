{"hands_on_practices": [{"introduction": "The foundation of any molecular dynamics simulation lies in the ability to accurately calculate the forces acting on each particle. This first exercise bridges the gap between the theoretical Ewald energy expression and a practical force calculation routine. You will derive the force vector expressions by analytically differentiating the real-space and reciprocal-space energy terms, a fundamental skill in computational physics, and then implement them to see the method in action [@problem_id:2390985].", "problem": "Consider a system of $N$ point charges with charges $\\{q_i\\}_{i=1}^N$ and positions $\\{\\mathbf{r}_i\\}_{i=1}^N$ inside a cubic simulation cell of edge length $L$ with Periodic Boundary Conditions (PBC). Work in reduced electrostatic units where $4\\pi\\varepsilon_0 = 1$, so that all energies and forces are expressed without additional physical constants. Distances are to be interpreted in nanometers, and forces must be reported in reduced units of $e^2\\,\\mathrm{nm}^{-2}$. Assume a conducting (tin-foil) boundary condition at infinity. \n\nStart from the standard Ewald-split total electrostatic energy for a three-dimensional periodic cubic cell, with a Gaussian screening parameter $\\alpha > 0$, real-space cutoff $r_{\\mathrm{cut}}$, and reciprocal-space cutoff $k_{\\max}$. Use the conventional decomposition of the energy into real-space, reciprocal-space, and self terms. In reciprocal space, define the set of reciprocal lattice vectors as $\\mathbf{k} = \\frac{2\\pi}{L}\\,\\mathbf{n}$ with $\\mathbf{n} \\in \\mathbb{Z}^3$, and include only those vectors satisfying $0 < \\lVert \\mathbf{k} \\rVert \\le k_{\\max}$. Define the structure factor $S(\\mathbf{k}) = \\sum_{j=1}^N q_j e^{-i \\mathbf{k}\\cdot \\mathbf{r}_j}$. In real space, use the minimum-image convention for interparticle displacement vectors and include a pair in the real-space sum if and only if the minimum-image separation $r_{ij}$ satisfies $r_{ij} \\le r_{\\mathrm{cut}}$. Assume $r_{\\mathrm{cut}} \\le L/2$ so that at most one image contributes per pair in real space. The self term must be accounted for in the energy but note that it does not contribute to the forces under these conditions.\n\nYour task: analytically differentiate the total Ewald energy with respect to $\\mathbf{r}_i$ to obtain the total force $\\mathbf{F}_i$ on each particle, and implement a program that computes these forces for each of the following test cases. All angles, if any appear in intermediate calculations, are to be interpreted in radians.\n\nTest suite (each case is strictly charge-neutral):\n\n- Case A (general configuration): \n  - $L = 1.0\\,\\mathrm{nm}$, $\\alpha = 5.0\\,\\mathrm{nm}^{-1}$, $r_{\\mathrm{cut}} = 0.49\\,\\mathrm{nm}$, $k_{\\max} = 25.132741228718345\\,\\mathrm{nm}^{-1}$.\n  - $N = 2$, charges $[+1,-1]$, positions (in $\\mathrm{nm}$): $\\mathbf{r}_1 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_2 = (0.3, 0.0, 0.0)$.\n- Case B (multiple charges near boundaries):\n  - $L = 1.0\\,\\mathrm{nm}$, $\\alpha = 5.0\\,\\mathrm{nm}^{-1}$, $r_{\\mathrm{cut}} = 0.49\\,\\mathrm{nm}$, $k_{\\max} = 25.132741228718345\\,\\mathrm{nm}^{-1}$.\n  - $N = 4$, charges $[+1,+1,-1,-1]$, positions (in $\\mathrm{nm}$): \n    $\\mathbf{r}_1 = (0.1, 0.1, 0.1)$, \n    $\\mathbf{r}_2 = (0.9, 0.1, 0.1)$, \n    $\\mathbf{r}_3 = (0.1, 0.9, 0.1)$, \n    $\\mathbf{r}_4 = (0.9, 0.9, 0.1)$.\n- Case C (boundary-distance edge case):\n  - $L = 1.0\\,\\mathrm{nm}$, $\\alpha = 7.0\\,\\mathrm{nm}^{-1}$, $r_{\\mathrm{cut}} = 0.50\\,\\mathrm{nm}$, $k_{\\max} = 31.41592653589793\\,\\mathrm{nm}^{-1}$.\n  - $N = 2$, charges $[+1,-1]$, positions (in $\\mathrm{nm}$): $\\mathbf{r}_1 = (0.25, 0.25, 0.25)$, $\\mathbf{r}_2 = (0.75, 0.25, 0.25)$.\n\nFor each test case, compute the force vectors $\\{\\mathbf{F}_i\\}_{i=1}^N$ in reduced units of $e^2\\,\\mathrm{nm}^{-2}$. For numerical reporting, round each Cartesian component to eight decimal places.\n\nFinal output format: Your program must produce a single line containing a Python-style list of lists. Each sublist corresponds to one test case and contains the flattened, comma-separated, rounded force components ordered by particle index and Cartesian component as $[F_{x,1},F_{y,1},F_{z,1},F_{x,2},F_{y,2},F_{z,2},\\dots]$. Eliminate all spaces in the printed line. For example, a line with two cases would look like [[${0.1}$,${0.0}$,${0.0}$,${-0.1}$,${0.0}$,${0.0}$],[${\\dots}$]], but with the actual computed numbers for these test cases.", "solution": "The problem presented is a standard, well-posed exercise in computational physics concerning the calculation of electrostatic forces using the Ewald summation method. It is scientifically sound, self-contained, and all parameters are specified unequivocally. The problem is therefore deemed valid and a full solution follows.\n\nThe objective is to compute the force $\\mathbf{F}_i$ on each particle $i$ in a periodic system of $N$ point charges. The force is the negative gradient of the total electrostatic potential energy $U$ with respect to the particle's position vector $\\mathbf{r}_i$:\n$$\n\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U\n$$\nThe Ewald method partitions the total energy $U$ into three components: a short-range real-space term ($U_{\\text{real}}$), a long-range reciprocal-space term ($U_{\\text{recip}}$), and a self-energy correction term ($U_{\\text{self}}$). The units are reduced such that $4\\pi\\varepsilon_0 = 1$.\n$$\nU = U_{\\text{real}} + U_{\\text{recip}} + U_{\\text{self}}\n$$\nThe force on particle $i$ is correspondingly partitioned:\n$$\n\\mathbf{F}_i = \\mathbf{F}_{i, \\text{real}} + \\mathbf{F}_{i, \\text{recip}} + \\mathbf{F}_{i, \\text{self}}\n$$\nWe will derive the expression for each force component by analytically differentiating the corresponding energy term.\n\nThe self-energy term is given by:\n$$\nU_{\\text{self}} = -\\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{j=1}^N q_j^2\n$$\nThis term is a constant with respect to particle positions. Therefore, its gradient is zero, and it does not contribute to the force:\n$$\n\\mathbf{F}_{i, \\text{self}} = -\\nabla_{\\mathbf{r}_i} U_{\\text{self}} = \\mathbf{0}\n$$\n\nThe real-space energy contribution for pairs of particles $(i,j)$ separated by a minimum-image distance $r_{ij} = |\\mathbf{r}_{ij}|$ within a specified cutoff $r_{\\text{cut}}$ is:\n$$\nU_{\\text{real}} = \\frac{1}{2} \\sum_{i \\ne j, r_{ij} \\le r_{\\text{cut}}} q_i q_j \\frac{\\text{erfc}(\\alpha r_{ij})}{r_{ij}}\n$$\nwhere $\\text{erfc}(x)$ is the complementary error function. The force on particle $i$ is obtained by differentiating this sum with respect to $\\mathbf{r}_i$. Only terms involving particle $i$ contribute.\n$$\n\\mathbf{F}_{i, \\text{real}} = -\\nabla_{\\mathbf{r}_i} \\sum_{j \\ne i, r_{ij} \\le r_{\\text{cut}}} q_i q_j \\frac{\\text{erfc}(\\alpha r_{ij})}{r_{ij}}\n$$\nApplying the chain rule, $\\nabla_{\\mathbf{r}_i} f(r_{ij}) = (\\frac{df}{dr_{ij}}) \\nabla_{\\mathbf{r}_i} r_{ij} = (\\frac{df}{dr_{ij}}) \\frac{\\mathbf{r}_{ij}}{r_{ij}}$, where $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$ is the minimum image displacement vector. We must differentiate the function $g(r) = q_i q_j \\text{erfc}(\\alpha r)/r$:\n$$\n\\frac{d}{dr} \\left( \\frac{\\text{erfc}(\\alpha r)}{r} \\right) = -\\frac{\\text{erfc}(\\alpha r)}{r^2} + \\frac{1}{r} \\left(-\\frac{2\\alpha}{\\sqrt{\\pi}}e^{-\\alpha^2 r^2}\\right)\n$$\nAssembling these parts, the real-space force on particle $i$ is:\n$$\n\\mathbf{F}_{i, \\text{real}} = \\sum_{j \\ne i, r_{ij} \\le r_{\\text{cut}}} q_i q_j \\left[ \\frac{\\text{erfc}(\\alpha r_{ij})}{r_{ij}^2} + \\frac{2\\alpha}{\\sqrt{\\pi} r_{ij}} e^{-\\alpha^2 r_{ij}^2} \\right] \\frac{\\mathbf{r}_{ij}}{r_{ij}}\n$$\n\nThe reciprocal-space energy is given by a sum over reciprocal lattice vectors $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{n}$ for integer vectors $\\mathbf{n} \\in \\mathbb{Z}^3$. For a charge-neutral system with conducting boundary conditions, the $\\mathbf{k}=\\mathbf{0}$ term is excluded.\n$$\nU_{\\text{recip}} = \\frac{2\\pi}{L^3} \\sum_{0 < |\\mathbf{k}| \\le k_{\\max}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} |S(\\mathbf{k})|^2\n$$\nwhere $k=|\\mathbf{k}|$ and $S(\\mathbf{k}) = \\sum_{j=1}^N q_j e^{-i\\mathbf{k}\\cdot\\mathbf{r}_j}$ is the structure factor. To find the force, we differentiate with respect to $\\mathbf{r}_i$. The only dependency on $\\mathbf{r}_i$ is within $|S(\\mathbf{k})|^2 = S(\\mathbf{k})S(-\\mathbf{k})$.\nThe gradient of the squared magnitude of the structure factor with respect to particle $i$'s position simplifies to:\n$$\n\\nabla_{\\mathbf{r}_i} |S(\\mathbf{k})|^2 = -2 q_i \\mathbf{k} \\sum_{j=1}^N q_j \\sin(\\mathbf{k}\\cdot(\\mathbf{r}_i-\\mathbf{r}_j))\n$$\nThe reciprocal-space force is therefore:\n$$\n\\mathbf{F}_{i, \\text{recip}} = -\\nabla_{\\mathbf{r}_i} U_{\\text{recip}} = \\frac{4\\pi q_i}{L^3} \\sum_{0 < |\\mathbf{k}| \\le k_{\\max}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\mathbf{k} \\sum_{j=1}^N q_j \\sin(\\mathbf{k}\\cdot(\\mathbf{r}_i-\\mathbf{r}_j))\n$$\nFor computational efficiency, the inner sum over $j$ is expanded using a trigonometric identity:\n$$\n\\sum_{j=1}^N q_j \\sin(\\mathbf{k}\\cdot(\\mathbf{r}_i-\\mathbf{r}_j)) = \\sin(\\mathbf{k}\\cdot\\mathbf{r}_i)\\left(\\sum_j q_j \\cos(\\mathbf{k}\\cdot\\mathbf{r}_j)\\right) - \\cos(\\mathbf{k}\\cdot\\mathbf{r}_i)\\left(\\sum_j q_j \\sin(\\mathbf{k}\\cdot\\mathbf{r}_j)\\right)\n$$\nLet $C(\\mathbf{k}) = \\sum_j q_j \\cos(\\mathbf{k}\\cdot\\mathbf{r}_j)$ and $S_{\\text{sum}}(\\mathbf{k}) = \\sum_j q_j \\sin(\\mathbf{k}\\cdot\\mathbf{r}_j)$. The final expression for the reciprocal-space force on particle $i$ is:\n$$\n\\mathbf{F}_{i, \\text{recip}} = \\frac{4\\pi q_i}{L^3} \\sum_{0 < |\\mathbf{k}| \\le k_{\\max}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\mathbf{k} \\left( \\sin(\\mathbf{k}\\cdot\\mathbf{r}_i) C(\\mathbf{k}) - \\cos(\\mathbf{k}\\cdot\\mathbf{r}_i) S_{\\text{sum}}(\\mathbf{k}) \\right)\n$$\nThe implementation will proceed by calculating the real-space force contribution for all pairs within the cutoff radius and then calculating the reciprocal-space contribution by summing over the specified set of $\\mathbf{k}$-vectors. The sums $C(\\mathbf{k})$ and $S_{\\text{sum}}(\\mathbf{k})$ are pre-calculated for each $\\mathbf{k}$ to optimize the computation. The final force is the sum of these two components.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Computes electrostatic forces on systems of point charges using Ewald summation.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {\n            \"L\": 1.0,\n            \"alpha\": 5.0,\n            \"r_cut\": 0.49,\n            \"k_max\": 25.132741228718345,\n            \"charges\": np.array([1.0, -1.0]),\n            \"positions\": np.array([[0.0, 0.0, 0.0], [0.3, 0.0, 0.0]])\n        },\n        # Case B\n        {\n            \"L\": 1.0,\n            \"alpha\": 5.0,\n            \"r_cut\": 0.49,\n            \"k_max\": 25.132741228718345,\n            \"charges\": np.array([1.0, 1.0, -1.0, -1.0]),\n            \"positions\": np.array([\n                [0.1, 0.1, 0.1],\n                [0.9, 0.1, 0.1],\n                [0.1, 0.9, 0.1],\n                [0.9, 0.9, 0.1]\n            ])\n        },\n        # Case C\n        {\n            \"L\": 1.0,\n            \"alpha\": 7.0,\n            \"r_cut\": 0.50,\n            \"k_max\": 31.41592653589793,\n            \"charges\": np.array([1.0, -1.0]),\n            \"positions\": np.array([[0.25, 0.25, 0.25], [0.75, 0.25, 0.25]])\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        L = case[\"L\"]\n        alpha = case[\"alpha\"]\n        r_cut = case[\"r_cut\"]\n        k_max = case[\"k_max\"]\n        charges = case[\"charges\"]\n        positions = case[\"positions\"]\n        \n        N = len(charges)\n        forces = np.zeros_like(positions)\n\n        # Real-space forces\n        for i in range(N):\n            for j in range(i + 1, N):\n                rij_vec = positions[i] - positions[j]\n                \n                # Minimum Image Convention\n                rij_vec = rij_vec - L * np.round(rij_vec / L)\n                \n                rij = np.linalg.norm(rij_vec)\n\n                # Check if within cutoff and non-zero distance\n                if 1e-9 < rij <= r_cut:\n                    q_i = charges[i]\n                    q_j = charges[j]\n                    \n                    term1 = erfc(alpha * rij) / rij**2\n                    term2 = (2.0 * alpha / np.sqrt(np.pi) / rij) * np.exp(-alpha**2 * rij**2)\n                    \n                    f_magnitude = q_i * q_j * (term1 + term2)\n                    f_vec = f_magnitude * (rij_vec / rij)\n                    \n                    forces[i] += f_vec\n                    forces[j] -= f_vec\n\n        # Reciprocal-space forces\n        n_max_int = int(np.floor(k_max * L / (2.0 * np.pi)))\n        \n        k_vecs = []\n        nx_vals = np.arange(-n_max_int, n_max_int + 1)\n        k_max_sq = k_max**2\n\n        for nx in nx_vals:\n            for ny in nx_vals:\n                for nz in nx_vals:\n                    if nx == 0 and ny == 0 and nz == 0:\n                        continue\n                    n_vec = np.array([nx, ny, nz])\n                    k_vec = (2.0 * np.pi / L) * n_vec\n                    k_sq = np.dot(k_vec, k_vec)\n                    if k_sq <= k_max_sq:\n                        k_vecs.append(k_vec)\n        \n        if not k_vecs:\n            # Handle case where no k-vectors are generated\n            case_results = [round(comp, 8) for comp in forces.flatten()]\n            all_results.append(case_results)\n            continue\n\n        k_vecs_arr = np.array(k_vecs)\n        k_sq_vals = np.sum(k_vecs_arr**2, axis=1)\n\n        # Vectorized calculation of cosine and sine sums\n        # k_dot_r has shape (num_k, N)\n        k_dot_r = np.dot(k_vecs_arr, positions.T)\n        \n        cos_k_dot_r = np.cos(k_dot_r)\n        sin_k_dot_r = np.sin(k_dot_r)\n        \n        # C_k and S_k sums over particles j, shape (num_k,)\n        C_k_vals = np.sum(charges[np.newaxis, :] * cos_k_dot_r, axis=1)\n        S_k_vals = np.sum(charges[np.newaxis, :] * sin_k_dot_r, axis=1)\n        \n        # Prefactor for force calculation for each k, shape (num_k,)\n        prefactor_k = (4.0 * np.pi / L**3) * np.exp(-k_sq_vals / (4.0 * alpha**2)) / k_sq_vals\n\n        for i in range(N):\n            q_i = charges[i]\n            \n            # Dot product of all k vectors with position r_i, shape (num_k,)\n            k_dot_ri = np.dot(k_vecs_arr, positions[i])\n            \n            sin_k_dot_ri = np.sin(k_dot_ri)\n            cos_k_dot_ri = np.cos(k_dot_ri)\n            \n            # The term in brackets in the force formula, shape (num_k,)\n            term_in_brackets = sin_k_dot_ri * C_k_vals - cos_k_dot_ri * S_k_vals\n            \n            # Combines scalar terms and vector k via broadcasting\n            # (num_k, 1) * (num_k, 3) -> (num_k, 3)\n            force_contrib_per_k = (prefactor_k * term_in_brackets)[:, np.newaxis] * k_vecs_arr\n            \n            # Sum over all k-vectors to get total reciprocal force on particle i\n            F_recip_i = q_i * np.sum(force_contrib_per_k, axis=0)\n            \n            forces[i] += F_recip_i\n\n        case_results = [round(comp, 8) for comp in forces.flatten()]\n        all_results.append(case_results)\n\n    # Format the final output string\n    results_str_parts = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(results_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2390985"}, {"introduction": "A program that runs without errors is not necessarily correct; it must also produce physically meaningful results. This practice guides you through the essential process of verification, where you will test your Ewald implementation against fundamental physical principles. By confirming that the calculated forces are invariant under translation and independent of the arbitrary simulation box boundaries, you can build confidence that your code is a faithful model of a periodic electrostatic system [@problem_id:2390997].", "problem": "You will implement a three-dimensional periodic electrostatics computation using Ewald summation to evaluate forces on point charges located near the edges of a cubic simulation box, and verify that the results are free of boundary artifacts. You must work from first principles starting at Coulomb’s law and the definition of periodic boundary conditions, and derive a computational algorithm that splits the interactions into a short-range real-space contribution and a long-range reciprocal-space contribution via a smooth screening procedure. You must assume conducting (tin-foil) boundary conditions. All calculations will use reduced, dimensionless units where the Coulomb prefactor is unity, that is, $1/(4\\pi\\epsilon_0) = 1$, and no physical unit conversion is required. There are no angles to report. All numerical answers must be printed as raw decimal numbers without any unit.\n\nStarting principles and definitions:\n- The system is a cubic box of side length $L$ with three-dimensional periodic boundary conditions (PBC). For any particle at position $\\mathbf{r}_i \\in [0,L)^3$ and any distinct particle at position $\\mathbf{r}_j \\in [0,L)^3$, interactions include all lattice images displaced by $\\mathbf{n}L$ with $\\mathbf{n} \\in \\mathbb{Z}^3$.\n- The electrostatic potential for point charges is governed by Coulomb’s law, and the total energy in a periodic system is conditionally convergent unless the total charge is zero. You must restrict to net-neutral charge configurations, $\\sum_i q_i = 0$.\n- The Ewald approach introduces a smooth Gaussian screening of width controlled by a parameter $\\alpha > 0$ to split the interaction into a rapidly decaying real-space sum over near images and a complementary reciprocal-space sum over wave vectors $\\mathbf{k} = \\frac{2\\pi}{L} \\mathbf{m}$ with $\\mathbf{m} \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$, omitting $\\mathbf{k} = \\mathbf{0}$. The real-space sum is truncated at a radius $r_\\mathrm{cut} > 0$, and the reciprocal-space sum is truncated by limiting the integer vector components to $|m_x|,|m_y|,|m_z| \\le k_\\mathrm{max}$.\n\nYour task:\n- Derive from the above principles an explicit and numerically stable algorithm to compute the electrostatic force $\\mathbf{F}_i$ on each particle $i$ using an Ewald sum, including the real-space and reciprocal-space contributions and the self-interaction correction. Use conducting boundary conditions so that no additional surface term is included. The algorithm must respect periodic boundary conditions exactly.\n- Implement the algorithm in a program that evaluates the following test suite. All positions are given in the interval $[0,L)$ and all quantities are dimensionless. Use the same cubic box side length $L = 10.0$ for all tests. Use the complementary error function where needed. Let $\\pi$ be the usual mathematical constant.\n\nGlobal Ewald parameters for the baseline evaluation:\n- Use $\\alpha = 0.35$, $r_\\mathrm{cut} = 4.5$, and $k_\\mathrm{max} = 6$ for the baseline computations.\n- For the alternate-parameter test, use $\\alpha' = 0.28$, $r_\\mathrm{cut}' = 4.5$, and $k_\\mathrm{max}' = 8$.\n\nTest systems:\n1. System $\\mathcal{S}_\\mathrm{edge}$ (two opposite charges near the edge across the boundary):\n   - Charges: $q_1 = +1.0$, $q_2 = -1.0$.\n   - Positions: $\\mathbf{r}_1 = (9.8, 5.0, 5.0)$, $\\mathbf{r}_2 = (0.2, 5.0, 5.0)$.\n2. System $\\mathcal{S}_\\mathrm{center}$ (same charges, same minimum-image separation, centered away from the edge):\n   - Charges: $q_1 = +1.0$, $q_2 = -1.0$.\n   - Positions: $\\mathbf{r}_1 = (0.2, 5.0, 5.0)$, $\\mathbf{r}_2 = (0.6, 5.0, 5.0)$.\n3. Translation vector for invariance test: $\\mathbf{t} = (3.7, 0.0, -1.1)$, applied via $\\mathbf{r}_i \\mapsto (\\mathbf{r}_i + \\mathbf{t}) \\bmod L$ componentwise.\n\nQuantities to compute:\n- Let $\\mathbf{F}^{(\\mathrm{edge})}$ denote the forces for system $\\mathcal{S}_\\mathrm{edge}$ computed with $(\\alpha, r_\\mathrm{cut}, k_\\mathrm{max})$.\n- Let $\\mathbf{F}^{(\\mathrm{center})}$ denote the forces for system $\\mathcal{S}_\\mathrm{center}$ with $(\\alpha, r_\\mathrm{cut}, k_\\mathrm{max})$.\n- Let $\\mathbf{F}^{(\\mathrm{trans})}$ denote the forces for system $\\mathcal{S}_\\mathrm{edge}$ after applying the translation $\\mathbf{t}$ and wrapping positions back into the box, computed with $(\\alpha, r_\\mathrm{cut}, k_\\mathrm{max})$.\n- Let $\\mathbf{F}^{(\\mathrm{alt})}$ denote the forces for system $\\mathcal{S}_\\mathrm{edge}$ computed with the alternate parameters $(\\alpha', r_\\mathrm{cut}', k_\\mathrm{max}')$.\n\nFrom these, compute the following four scalar diagnostics:\n- $D_1$: the maximum absolute componentwise difference between $\\mathbf{F}^{(\\mathrm{edge})}$ and $\\mathbf{F}^{(\\mathrm{center})}$, that is, $D_1 = \\max_{i\\in\\{1,2\\}, a\\in\\{x,y,z\\}} \\left|F^{(\\mathrm{edge})}_{i,a} - F^{(\\mathrm{center})}_{i,a}\\right|$.\n- $D_2$: the Euclidean norm of the net force vector in system $\\mathcal{S}_\\mathrm{edge}$, summed over both particles, $D_2 = \\left\\|\\sum_{i=1}^2 \\mathbf{F}^{(\\mathrm{edge})}_i \\right\\|_2$.\n- $D_3$: the maximum absolute componentwise difference between $\\mathbf{F}^{(\\mathrm{edge})}$ and $\\mathbf{F}^{(\\mathrm{trans})}$, $D_3 = \\max_{i\\in\\{1,2\\}, a\\in\\{x,y,z\\}} \\left|F^{(\\mathrm{edge})}_{i,a} - F^{(\\mathrm{trans})}_{i,a}\\right|$.\n- $D_4$: the maximum absolute componentwise difference between $\\mathbf{F}^{(\\mathrm{edge})}$ computed with the baseline parameters and the alternate parameters, $D_4 = \\max_{i\\in\\{1,2\\}, a\\in\\{x,y,z\\}} \\left|F^{(\\mathrm{edge})}_{i,a} - F^{(\\mathrm{alt})}_{i,a}\\right|$.\n\nInterpretation guidelines:\n- Small values of $D_1$ confirm that placing charges near the boundary yields the same forces as an equivalent centered configuration, indicating no boundary artifacts.\n- A small value of $D_2$ confirms that the total force vanishes for a neutral system under conducting boundary conditions, as required by translational invariance.\n- A small value of $D_3$ confirms invariance of the forces under global translation and periodic wrapping.\n- A small value of $D_4$ confirms that the physical result is independent of the arbitrary splitting parameter within numerical truncation error.\n\nFinal output format:\n- Your program must print a single line containing the four results as a comma-separated list enclosed in square brackets, in the order $[D_1, D_2, D_3, D_4]$. For example, a valid output format is $[0.0001,2.3e-06,0.0,1.2e-05]$.\n\nConstraints and notes:\n- You must implement the Ewald force computation directly. Do not call any black-box electrostatics solvers. You may use standard numerical libraries for basic functions such as exponentials and the complementary error function.\n- Use only net-neutral systems; all provided tests satisfy $\\sum_i q_i = 0$.\n- Ensure numerical stability and reasonable convergence with the specified truncations $(r_\\mathrm{cut}, k_\\mathrm{max})$.", "solution": "We base the computation on Coulomb’s law and the definition of periodic boundary conditions, then derive the Ewald decomposition to obtain a numerically convergent algorithm for the forces. All symbols in the derivation refer to reduced, dimensionless quantities with $1/(4\\pi\\epsilon_0) = 1$.\n\nFoundational principles:\n- Coulomb’s law gives the pair potential between charges $q_i$ and $q_j$ as $\\phi(\\mathbf{r}) = q_j / \\|\\mathbf{r}\\|$, where $\\mathbf{r} = \\mathbf{r}_i - \\mathbf{r}_j$.\n- In a periodic cubic box of side $L$, the interaction sums over all lattice images, which is only conditionally convergent. Ewald’s method regularizes this by introducing a Gaussian screening density that splits the interaction into rapidly convergent real-space and reciprocal-space series.\n\nEwald splitting:\nWe add and subtract a neutralizing Gaussian of width governed by $\\alpha > 0$. The potential from a screened point charge decomposes into a short-range contribution that decays like the complementary error function, and a long-range contribution expressible via Fourier components. For a neutral system, the $\\mathbf{k} = \\mathbf{0}$ component is omitted under conducting boundary conditions.\n\nForce expression conceptual derivation:\n- Real space. Define $\\mathbf{R} = \\mathbf{r}_i - \\mathbf{r}_j + \\mathbf{n}L$ for $\\mathbf{n} \\in \\mathbb{Z}^3$, and $R = \\|\\mathbf{R}\\|$. The pair potential in the screened representation is $q_j \\operatorname{erfc}(\\alpha R)/R$. The force on particle $i$ is $\\mathbf{F}_{ij}^{(\\mathrm{real})} = -q_i \\nabla_i \\left[q_j \\operatorname{erfc}(\\alpha R)/R\\right]$. Using the product rule and $\\frac{d}{dR}\\operatorname{erfc}(\\alpha R) = -\\frac{2\\alpha}{\\sqrt{\\pi}} e^{-\\alpha^2 R^2}$, and the identity $\\nabla_i R = \\mathbf{R}/R$, we obtain\n$$\n\\mathbf{F}_{ij}^{(\\mathrm{real})} = q_i q_j \\left( \\frac{\\operatorname{erfc}(\\alpha R)}{R^3} + \\frac{2\\alpha}{\\sqrt{\\pi}} \\frac{e^{-\\alpha^2 R^2}}{R^2} \\right) \\mathbf{R}.\n$$\nThis sum is truncated to $R \\le r_\\mathrm{cut}$ for numerical efficiency, as the neglected tail decays very rapidly.\n\n- Reciprocal space. Let $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$ for integer triplets $\\mathbf{m} \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$. The reciprocal-space potential at $\\mathbf{r}_i$ is\n$$\n\\phi^{(\\mathrm{rec})}(\\mathbf{r}_i) = \\frac{1}{V}\\sum_{\\mathbf{k}\\ne\\mathbf{0}} \\frac{4\\pi}{k^2} e^{-k^2/(4\\alpha^2)} \\sum_j q_j e^{i \\mathbf{k}\\cdot (\\mathbf{r}_i - \\mathbf{r}_j)},\n$$\nwith $V = L^3$ and $k = \\|\\mathbf{k}\\|$. The force is $\\mathbf{F}_i^{(\\mathrm{rec})} = -q_i \\nabla_i \\phi^{(\\mathrm{rec})}(\\mathbf{r}_i)$. Differentiating gives an $i\\mathbf{k}$ factor from $e^{i \\mathbf{k}\\cdot \\mathbf{r}_i}$ and yields a manifestly real form using sines:\n$$\n\\mathbf{F}_i^{(\\mathrm{rec})} = \\frac{4\\pi}{V}\\, q_i \\sum_{\\mathbf{k}\\ne\\mathbf{0}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\left[\\sum_j q_j \\sin\\left(\\mathbf{k}\\cdot (\\mathbf{r}_i - \\mathbf{r}_j)\\right)\\right] \\mathbf{k}.\n$$\nTo evaluate efficiently, we use the identity $\\sum_j q_j \\sin(\\mathbf{k}\\cdot(\\mathbf{r}_i - \\mathbf{r}_j)) = \\sin(\\mathbf{k}\\cdot \\mathbf{r}_i)\\sum_j q_j \\cos(\\mathbf{k}\\cdot \\mathbf{r}_j) - \\cos(\\mathbf{k}\\cdot \\mathbf{r}_i)\\sum_j q_j \\sin(\\mathbf{k}\\cdot \\mathbf{r}_j)$, so we only need global structure factors per $\\mathbf{k}$.\n\n- Self term. The self-interaction correction in the Ewald energy is $- \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_i q_i^2$, which has zero gradient with respect to particle positions. Therefore, the self term contributes no force and can be omitted for forces.\n\nConducting boundary conditions:\n- For conducting (tin-foil) boundaries, the $\\mathbf{k} = \\mathbf{0}$ term is dropped and there is no surface (dipole) correction. The system must be neutral, $\\sum_i q_i = 0$, to avoid divergence.\n\nAlgorithmic design:\n1. Input the particle positions $\\{\\mathbf{r}_i\\}$, charges $\\{q_i\\}$, box length $L$, and Ewald parameters $\\alpha$, $r_\\mathrm{cut}$, $k_\\mathrm{max}$.\n2. Real-space force:\n   - Determine the integer bound $n_\\mathrm{max} = \\lceil r_\\mathrm{cut}/L \\rceil$; loop over $\\mathbf{n} \\in \\{-n_\\mathrm{max},\\ldots,n_\\mathrm{max}\\}^3$.\n   - For each unordered pair $(i,j)$ with $i<j$, compute $\\mathbf{R} = \\mathbf{r}_i - \\mathbf{r}_j + \\mathbf{n}L$, its norm $R$, and if $R > 0$ and $R \\le r_\\mathrm{cut}$, accumulate the symmetric pair force using\n   $$\n   f(R) = \\frac{\\operatorname{erfc}(\\alpha R)}{R^3} + \\frac{2\\alpha}{\\sqrt{\\pi}} \\frac{e^{-\\alpha^2 R^2}}{R^2},\\qquad \\Delta\\mathbf{F} = q_i q_j f(R) \\mathbf{R}.\n   $$\n   - Add $+\\Delta\\mathbf{F}$ to $\\mathbf{F}_i$ and $-\\Delta\\mathbf{F}$ to $\\mathbf{F}_j$.\n3. Reciprocal-space force:\n   - Generate all integer triplets $\\mathbf{m}$ with $-k_\\mathrm{max} \\le m_x,m_y,m_z \\le k_\\mathrm{max}$, excluding $\\mathbf{m}=\\mathbf{0}$. For each, form $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$, $k^2 = \\mathbf{k}\\cdot \\mathbf{k}$, and the coefficient\n   $$\n   c(\\mathbf{k}) = \\frac{4\\pi}{V}\\,\\frac{e^{-k^2/(4\\alpha^2)}}{k^2}.\n   $$\n   - Compute the structure factors $C(\\mathbf{k}) = \\sum_j q_j \\cos(\\mathbf{k}\\cdot \\mathbf{r}_j)$ and $S(\\mathbf{k}) = \\sum_j q_j \\sin(\\mathbf{k}\\cdot \\mathbf{r}_j)$.\n   - For each particle $i$, compute $s_i = \\sin(\\mathbf{k}\\cdot \\mathbf{r}_i)$ and $c_i = \\cos(\\mathbf{k}\\cdot \\mathbf{r}_i)$, then accumulate\n   $$\n   \\Delta \\mathbf{F}_i = q_i\\, c(\\mathbf{k})\\, \\left( s_i\\, C(\\mathbf{k}) - c_i\\, S(\\mathbf{k}) \\right)\\, \\mathbf{k}.\n   $$\n4. The total force is $\\mathbf{F}_i = \\mathbf{F}_i^{(\\mathrm{real})} + \\mathbf{F}_i^{(\\mathrm{rec})}$ for each $i$.\n5. Validation diagnostics:\n   - Compute $D_1$ as the maximum absolute componentwise difference between forces for $\\mathcal{S}_\\mathrm{edge}$ and $\\mathcal{S}_\\mathrm{center}$ under the baseline parameters.\n   - Compute $D_2$ as the Euclidean norm of the net force for $\\mathcal{S}_\\mathrm{edge}$ under baseline parameters.\n   - Compute $D_3$ as the maximum absolute componentwise difference between forces for $\\mathcal{S}_\\mathrm{edge}$ and its globally translated-and-wrapped version under baseline parameters.\n   - Compute $D_4$ as the maximum absolute componentwise difference between forces for $\\mathcal{S}_\\mathrm{edge}$ under baseline parameters and under the alternate parameters.\n\nNumerical considerations:\n- The choice $\\alpha = 0.35$ with $r_\\mathrm{cut} = 4.5$ and $k_\\mathrm{max} = 6$ for $L=10.0$ strikes a reasonable balance between real- and reciprocal-space truncation errors for this small system. The alternate parameters $\\alpha' = 0.28$, $r_\\mathrm{cut}' = 4.5$, $k_\\mathrm{max}' = 8$ shift more work to reciprocal space, and the forces should agree closely, validating parameter independence.\n- All test systems have net charge zero, satisfying $\\sum_i q_i = 0$ as required for the Ewald sum to converge under conducting boundary conditions.\n- Invariance expectations: translating all positions by any $\\mathbf{t}$ and wrapping modulo $L$ does not change $\\mathbf{R}$-set distances or the set of phase factors $e^{i\\mathbf{k}\\cdot \\mathbf{r}}$ up to a common phase that cancels in the force expression, so forces are invariant. Likewise, centering a configuration that is equivalent under periodicity should yield indistinguishable forces. Therefore $D_1$, $D_2$, and $D_3$ should be small (close to machine precision within truncation error), and $D_4$ should be small as well, confirming parameter robustness.\n\nThe program implements the above algorithm, constructs the specified test cases, computes $\\mathbf{F}$ via Ewald summation, evaluates $D_1$, $D_2$, $D_3$, and $D_4$, and prints them as a single list $[D_1, D_2, D_3, D_4]$ on one line.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef ewald_forces(positions, charges, L, alpha, rcut, kmax):\n    \"\"\"\n    Compute Ewald forces for a 3D periodic cubic box with conducting boundary conditions.\n    positions: (N,3) array in [0,L)\n    charges: (N,) array, must sum to zero\n    L: box length\n    alpha: Ewald splitting parameter\n    rcut: real-space cutoff\n    kmax: maximum integer index for reciprocal vectors\n    Returns: (N,3) array of forces\n    \"\"\"\n    positions = np.asarray(positions, dtype=float)\n    charges = np.asarray(charges, dtype=float)\n    N = positions.shape[0]\n    assert positions.shape == (N, 3)\n    assert charges.shape == (N,)\n    # Neutrality check\n    if abs(np.sum(charges)) > 1e-12:\n        raise ValueError(\"System is not neutral; Ewald summation diverges.\")\n    forces = np.zeros_like(positions)\n    V = L**3\n    pi = np.pi\n    sqrt_pi = np.sqrt(pi)\n\n    # Real-space sum\n    nmax = int(np.ceil(rcut / L))\n    # Precompute image shifts\n    shifts = []\n    for nx in range(-nmax, nmax + 1):\n        for ny in range(-nmax, nmax + 1):\n            for nz in range(-nmax, nmax + 1):\n                shifts.append(np.array([nx, ny, nz], dtype=int))\n    shifts = np.array(shifts, dtype=int)\n\n    for i in range(N - 1):\n        ri = positions[i]\n        qi = charges[i]\n        for j in range(i + 1, N):\n            rj = positions[j]\n            qj = charges[j]\n            qiqj = qi * qj\n            # Loop over lattice vectors within cutoff\n            for nvec in shifts:\n                # Displacement including image\n                Rvec = ri - rj + L * nvec\n                R2 = np.dot(Rvec, Rvec)\n                if R2 == 0.0:\n                    continue\n                R = np.sqrt(R2)\n                if R <= rcut:\n                    aR = alpha * R\n                    erfc_term = erfc(aR)\n                    exp_term = np.exp(-(aR * aR))\n                    # Force scalar factor\n                    f = erfc_term / (R2 * R) + (2.0 * alpha / sqrt_pi) * exp_term / R2\n                    fij = qiqj * f * Rvec\n                    forces[i] += fij\n                    forces[j] -= fij\n\n    # Reciprocal-space sum\n    # Generate k-vectors\n    ms = np.arange(-kmax, kmax + 1, dtype=int)\n    k_list = []\n    for mx in ms:\n        for my in ms:\n            for mz in ms:\n                if mx == 0 and my == 0 and mz == 0:\n                    continue\n                m = np.array([mx, my, mz], dtype=float)\n                kvec = (2.0 * np.pi / L) * m\n                ksq = np.dot(kvec, kvec)\n                if ksq == 0.0:\n                    continue\n                k_list.append((kvec, ksq))\n    # Structure factors and force accumulation\n    # Precompute dot products k·r for all k and all particles can be memory heavy; loop over k\n    for kvec, ksq in k_list:\n        # Coefficient c(k)\n        ck = (4.0 * np.pi / V) * np.exp(-ksq / (4.0 * alpha * alpha)) / ksq\n        # Structure factors\n        kr = positions @ kvec  # shape (N,)\n        cos_kr = np.cos(kr)\n        sin_kr = np.sin(kr)\n        Ck = np.sum(charges * cos_kr)\n        Sk = np.sum(charges * sin_kr)\n        # Per-particle contributions\n        s_i = sin_kr\n        c_i = cos_kr\n        # term = (s_i * Ck - c_i * Sk)\n        term = (s_i * Ck - c_i * Sk) * charges * ck  # shape (N,)\n        # Add to forces: term[:, None] * kvec\n        forces += term[:, None] * kvec\n\n    return forces\n\ndef translate_and_wrap(positions, tvec, L):\n    \"\"\"Translate positions by tvec and wrap back into [0,L).\"\"\"\n    pos_new = positions + np.asarray(tvec, dtype=float)\n    pos_new = pos_new % L\n    return pos_new\n\ndef max_abs_componentwise_diff(A, B):\n    \"\"\"Max absolute component-wise difference between two (N,3) arrays.\"\"\"\n    return float(np.max(np.abs(A - B)))\n\ndef solve():\n    # Define global parameters\n    L = 10.0\n    alpha = 0.35\n    rcut = 4.5\n    kmax = 6\n\n    alpha_alt = 0.28\n    rcut_alt = 4.5\n    kmax_alt = 8\n\n    # Define systems\n    charges = np.array([+1.0, -1.0], dtype=float)\n\n    # Edge configuration (across boundary)\n    r_edge = np.array([\n        [9.8, 5.0, 5.0],\n        [0.2, 5.0, 5.0],\n    ], dtype=float)\n\n    # Centered configuration with same minimum-image separation (0.4 along +x)\n    r_center = np.array([\n        [0.2, 5.0, 5.0],\n        [0.6, 5.0, 5.0],\n    ], dtype=float)\n\n    # Translation vector\n    tvec = np.array([3.7, 0.0, -1.1], dtype=float)\n\n    # Compute forces with baseline parameters\n    F_edge = ewald_forces(r_edge, charges, L, alpha, rcut, kmax)\n    F_center = ewald_forces(r_center, charges, L, alpha, rcut, kmax)\n\n    # D1: max componentwise difference between edge and center\n    D1 = max_abs_componentwise_diff(F_edge, F_center)\n\n    # D2: norm of total force for edge system\n    total_force_edge = np.sum(F_edge, axis=0)\n    D2 = float(np.linalg.norm(total_force_edge))\n\n    # D3: translation invariance\n    r_edge_trans = translate_and_wrap(r_edge, tvec, L)\n    F_trans = ewald_forces(r_edge_trans, charges, L, alpha, rcut, kmax)\n    D3 = max_abs_componentwise_diff(F_edge, F_trans)\n\n    # D4: parameter invariance (alternate parameters)\n    F_alt = ewald_forces(r_edge, charges, L, alpha_alt, rcut_alt, kmax_alt)\n    D4 = max_abs_componentwise_diff(F_edge, F_alt)\n\n    results = [D1, D2, D3, D4]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2390997"}, {"introduction": "The Ewald summation method's efficiency comes from splitting the calculation into two sums, both of which must be truncated for practical computation. This final practice delves into the crucial concept of convergence and error analysis. You will systematically quantify how the choice of the real-space cutoff $r_{\\text{cut}}$ and reciprocal-space cutoff $k_{\\text{cut}}$ impacts the accuracy of the calculated forces, providing you with the skills to balance computational cost and scientific precision in your simulations [@problem_id:2390969].", "problem": "Implement a complete program that quantifies the truncation error in the Ewald summation force calculation for a three-dimensional periodic, charge-neutral system as a function of the real-space cutoff $r_{cut}$ and the reciprocal-space cutoff $k_{cut}$. Work in reduced, dimensionless units where the cubic simulation box has side length $L$, the elementary charge is set to unity, and the Coulomb prefactor $1/(4\\pi \\varepsilon_0)$ is set to unity. All quantities are thus dimensionless. The goal is to produce a numerically stable and reproducible estimate of the root-mean-square relative force error for several specified cutoff choices.\n\nStart from fundamental electrostatics and periodic boundary conditions: point charges $\\{q_i\\}$ at positions $\\{\\mathbf{r}_i\\}$ in a cubic domain of side $L$ with fully periodic boundary conditions. The exact electrostatic force on particle $i$ is obtained from the solution of the Poisson equation with a triply periodic Green’s function and is equivalent to summing the Coulomb interactions over all Bravais lattice images. To render the long-range sum absolutely convergent and practically computable, use the classical Ewald decomposition based on adding and subtracting a spherically symmetric Gaussian screening charge density of width parameter $\\alpha$ around each particle. This yields a decomposition of the force into a short-ranged real-space part (obtained from the screened potential in direct space) and a smooth long-ranged reciprocal-space part (obtained from the Fourier transform of the complementary screening). The self-interaction correction removes the interaction of each charge with its own screening cloud; it does not contribute to the force.\n\nYour task is to:\n- Derive from first principles the real-space and reciprocal-space expressions for the pairwise forces under Ewald decomposition, parameterized by the Ewald splitting parameter $\\alpha$, and implement them in a numerically robust way.\n- Implement the real-space force sum by enumerating direct lattice vectors $\\mathbf{n}=(n_x,n_y,n_z)$ with integer components such that the image displacement $\\mathbf{r}_{ij} + L\\mathbf{n}$ has magnitude strictly less than $r_{cut}$. Here $\\mathbf{r}_{ij}=\\mathbf{r}_i-\\mathbf{r}_j$, and the central cell corresponds to $\\mathbf{n}=\\mathbf{0}$. Exclude the self-term $i=j$ with $\\mathbf{n}=\\mathbf{0}$.\n- Implement the reciprocal-space force sum by enumerating nonzero reciprocal lattice vectors $\\mathbf{k}=\\frac{2\\pi}{L}\\mathbf{m}$ with integer triplets $\\mathbf{m}=(m_x,m_y,m_z)$ such that $\\lVert \\mathbf{k}\\rVert < k_{cut}$, and by accumulating the contribution of the smooth structure factor of the charge distribution. Use conducting boundary conditions (vanishing net field at infinity), and assume overall charge neutrality to avoid any $\\mathbf{k}=\\mathbf{0}$ term.\n- For each parameter set, compute a highly converged “reference” force by using the same $\\alpha$ but with large cutoffs $r_{cut}^{ref}$ and $k_{cut}^{ref}$, and then compute the truncated force with the specified $(r_{cut},k_{cut})$. Use these to evaluate the root-mean-square relative force error over all particles:\n$$\n\\mathrm{RMSRE}=\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left(\\frac{\\lVert \\mathbf{F}_i^{(trunc)}-\\mathbf{F}_i^{(ref)}\\rVert}{\\max\\{\\lVert \\mathbf{F}_i^{(ref)}\\rVert,\\epsilon\\}}\\right)^2}\\,,\n$$\nwith a small regularizer $\\epsilon$ to avoid division by zero. Report this error as a dimensionless float.\n\nSystem specification to use in all computations:\n- Number of particles: $N=4$.\n- Box length: $L=1.0$.\n- Particle charges: $(q_1,q_2,q_3,q_4)=(+1,-1,+1,-1)$.\n- Particle positions (in the primary cell with periodic images implied): $\\mathbf{r}_1=(0.10,0.10,0.10)$, $\\mathbf{r}_2=(0.40,0.20,0.70)$, $\\mathbf{r}_3=(0.80,0.90,0.30)$, $\\mathbf{r}_4=(0.65,0.25,0.95)$.\n- For the reference calculation for each $\\alpha$, use $r_{cut}^{ref}=3.0$ and $k_{cut}^{ref}=50.0$.\n- Use a regularizer $\\epsilon=10^{-12}$ in the error definition.\n\nImplement the following test suite of Ewald parameter sets $(\\alpha,r_{cut},k_{cut})$:\n- Case A: $(\\alpha,r_{cut},k_{cut})=(5.0,1.5,20.0)$.\n- Case B: $(\\alpha,r_{cut},k_{cut})=(5.0,0.5,20.0)$.\n- Case C: $(\\alpha,r_{cut},k_{cut})=(5.0,1.5,6.0)$.\n- Case D: $(\\alpha,r_{cut},k_{cut})=(5.0,0.0,20.0)$.\n- Case E: $(\\alpha,r_{cut},k_{cut})=(5.0,2.5,0.0)$.\n- Case F: $(\\alpha,r_{cut},k_{cut})=(2.5,1.5,20.0)$.\n\nYour program must:\n- Implement the Ewald force calculation as described, using only the provided system and parameter sets.\n- For each case, compute the root-mean-square relative force error using the corresponding reference truncation.\n- Produce a single line of output containing the six results, in order A through F, as a comma-separated list enclosed in square brackets. Each float must be rounded to $6$ digits after the decimal point in scientific notation (for example, $\"[1.234567e-03,2.000000e+00,3.140000e+00]\"$).\n\nAll computations are in reduced, dimensionless units. Angles, where they arise internally via dot products, are in radians, but you do not need to report any angles. The final program must be completely self-contained and require no input. The final outputs are pure numbers without units, as specified. Ensure numerical stability and avoid redundant double counting in both real and reciprocal sums by adhering to the cutoff rules stated above.", "solution": "The problem posed is a standard, well-defined exercise in computational physics. It is scientifically grounded, self-contained, and all parameters necessary for a unique numerical solution are provided. The system is specified to be charge-neutral ($\\sum_i q_i = +1 -1 +1 -1 = 0$), which is consistent with the instruction to omit the $\\mathbf{k}=\\mathbf{0}$ term in the reciprocal-space sum. The problem is therefore valid. We shall proceed with the derivation and implementation.\n\nThe objective is to compute the electrostatic forces on a set of $N$ point charges $\\{q_i\\}$ at positions $\\{\\mathbf{r}_i\\}$ within a cubic periodic box of side length $L$. The electrostatic force on particle $i$ is derived from the total potential energy $U$ as $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U$. The energy of a periodic lattice of charges is given by the conditionally convergent sum:\n$$\nU = \\frac{1}{2} \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3} \\sideset{}{'}{\\sum}_{i,j=1}^{N} \\frac{q_i q_j}{|\\mathbf{r}_{ij} + L\\mathbf{n}|}\n$$\nwhere $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$, and $\\mathbf{n}$ is a vector of integers representing the periodic images. The prime on the sum indicates that the term with $i=j$ is excluded for the primary cell ($\\mathbf{n}=\\mathbf{0}$). The long-range nature of the Coulomb interaction $1/r$ causes the slow and conditional convergence of this sum.\n\nThe Ewald summation method resolves this by splitting the interaction into two parts that are rapidly convergent. This is achieved by adding and subtracting a screening charge distribution, typically a Gaussian, centered on each point charge. The Coulomb potential is split using the identity involving the complementary error function, $\\mathrm{erfc}(x)$, and the error function, $\\mathrm{erf}(x)$:\n$$\n\\frac{1}{r} = \\underbrace{\\frac{\\mathrm{erfc}(\\alpha r)}{r}}_{\\text{short-range}} + \\underbrace{\\frac{\\mathrm{erf}(\\alpha r)}{r}}_{\\text{long-range}}\n$$\nThe parameter $\\alpha$ controls the width of the Gaussian and the range of the split potentials. The force on particle $i$ is then decomposed into a real-space contribution, a reciprocal-space contribution, and a self-interaction correction:\n$$\n\\mathbf{F}_i = \\mathbf{F}_i^{\\text{real}} + \\mathbf{F}_i^{\\text{recip}} + \\mathbf{F}_i^{\\text{self}}\n$$\n\n**1. Real-Space Force ($\\mathbf{F}_i^{\\text{real}}$)**\n\nThe real-space contribution arises from the direct, pairwise interaction via the short-range potential. The potential energy term is:\n$$\nU_{\\text{real}} = \\frac{1}{2} \\sum_{\\mathbf{n}} \\sideset{}{'}{\\sum}_{i,j} q_i q_j \\frac{\\mathrm{erfc}(\\alpha |\\mathbf{r}_{ij,n}|)}{|\\mathbf{r}_{ij,n}|}\n$$\nwhere $\\mathbf{r}_{ij,n} = \\mathbf{r}_{ij} + L\\mathbf{n}$. The force on particle $i$ due to an interaction with particle $j$ (and all its images) is found by taking the negative gradient. Let $\\mathbf{r} = \\mathbf{r}_{ij,n}$. The pairwise force is $\\mathbf{F}_{ij}(\\mathbf{r}) = -q_i q_j \\nabla \\frac{\\mathrm{erfc}(\\alpha r)}{r}$. Using the chain rule, $\\nabla f(r) = \\frac{df}{dr} \\frac{\\mathbf{r}}{r}$, and the derivative $\\frac{d}{dr}\\left(\\frac{\\mathrm{erfc}(\\alpha r)}{r}\\right) = -\\frac{\\mathrm{erfc}(\\alpha r)}{r^2} - \\frac{2\\alpha}{\\sqrt{\\pi}}e^{-\\alpha^2 r^2}\\frac{1}{r}$, we obtain:\n$$\n\\mathbf{F}_{ij}(\\mathbf{r}) = q_i q_j \\left[ \\frac{\\mathrm{erfc}(\\alpha r)}{r^3} + \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{e^{-\\alpha^2 r^2}}{r^2} \\right] \\mathbf{r}\n$$\nThe total real-space force on particle $i$ is the sum over all other particles $j$ and all periodic lattice images $\\mathbf{n}$, truncated at a cutoff distance $r_{\\text{cut}}$:\n$$\n\\mathbf{F}_i^{\\text{real}} = \\sum_{j=1}^{N} \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3} ' q_i q_j \\left[ \\frac{\\mathrm{erfc}(\\alpha |\\mathbf{r}_{ij,n}|)}{|\\mathbf{r}_{ij,n}|^3} + \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{e^{-\\alpha^2 |\\mathbf{r}_{ij,n}|^2}}{|\\mathbf{r}_{ij,n}|^2} \\right] \\mathbf{r}_{ij,n}\n$$\nThe sum is restricted to all pairs $(j, \\mathbf{n})$ such that $0 < |\\mathbf{r}_{ij,n}| < r_{\\text{cut}}$. The prime signifies that if $\\mathbf{n}=\\mathbf{0}$, then $j \\neq i$.\n\n**2. Reciprocal-Space Force ($\\mathbf{F}_i^{\\text{recip}}$)**\n\nThe long-range part of the potential is smooth and can be efficiently evaluated in reciprocal space using a Fourier series. The potential energy contribution is:\n$$\nU_{\\text{recip}} = \\frac{1}{2V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{4\\pi}{k^2} e^{-k^2/(4\\alpha^2)} |S(\\mathbf{k})|^2\n$$\nwhere $V=L^3$ is the box volume, $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$ are the reciprocal lattice vectors for integer vectors $\\mathbf{m}$, and $S(\\mathbf{k}) = \\sum_j q_j e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j}$ is the structure factor. The $\\mathbf{k}=\\mathbf{0}$ term is zero for a charge-neutral system. The force on particle $i$ is $\\mathbf{F}_i^{\\text{recip}} = -\\nabla_{\\mathbf{r}_i} U_{\\text{recip}}$. Taking the gradient with respect to $\\mathbf{r}_i$ yields:\n$$\n\\mathbf{F}_i^{\\text{recip}} = -\\frac{1}{2V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{4pi}{k^2} e^{-k^2/(4\\alpha^2)} \\nabla_{\\mathbf{r}_i}|S(\\mathbf{k})|^2\n$$\nThe gradient of the squared structure factor is $\\nabla_{\\mathbf{r}_i}|S(\\mathbf{k})|^2 = -2 q_i \\mathbf{k} \\sum_j q_j \\sin(\\mathbf{k} \\cdot (\\mathbf{r}_i - \\mathbf{r}_j))$. This leads to the final expression for the reciprocal-space force:\n$$\n\\mathbf{F}_i^{\\text{recip}} = \\frac{4\\pi q_i}{V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}, \\|\\mathbf{k}\\| < k_{\\text{cut}}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\left[ \\sum_{j=1}^{N} q_j \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{ij}) \\right] \\mathbf{k}\n$$\nFor computational efficiency, the inner sum can be expanded using $\\sin(A-B) = \\sin A \\cos B - \\cos A \\sin B$:\n$$\n\\sum_{j=1}^{N} q_j \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{ij}) = \\sin(\\mathbf{k} \\cdot \\mathbf{r}_i) \\left( \\sum_{j=1}^{N} q_j \\cos(\\mathbf{k} \\cdot \\mathbf{r}_j) \\right) - \\cos(\\mathbf{k} \\cdot \\mathbf{r}_i) \\left( \\sum_{j=1}^{N} q_j \\sin(\\mathbf{k} \\cdot \\mathbf{r}_j) \\right)\n$$\nThis allows pre-computation of the sums over $j$, reducing the complexity.\n\n**3. Self-Interaction Correction ($\\mathbf{F}_i^{\\text{self}}$)**\n\nThe Ewald splitting introduces an interaction of each charge with its own screening Gaussian. This unphysical energy must be subtracted. The self-energy is $U_{\\text{self}} = -\\frac{\\alpha}{\\sqrt{\\pi}} \\sum_i q_i^2$. Since this term is independent of particle positions, its gradient is zero, and the force contribution is null:\n$$\n\\mathbf{F}_i^{\\text{self}} = -\\nabla_{\\mathbf{r}_i} U_{\\text{self}} = \\mathbf{0}\n$$\n\n**4. Error Quantification**\n\nThe algorithm involves computing the total force $\\mathbf{F}_i = \\mathbf{F}_i^{\\text{real}} + \\mathbf{F}_i^{\\text{recip}}$ for each particle, first for a given set of truncated cutoffs $(r_{\\text{cut}}, k_{\\text{cut}})$ yielding $\\mathbf{F}^{(trunc)}$, and then for a set of highly converged reference cutoffs $(r_{\\text{cut}}^{\\text{ref}}, k_{\\text{cut}}^{\\text{ref}})$ yielding $\\mathbf{F}^{(ref)}$. The root-mean-square relative force error (RMSRE) is then calculated as:\n$$\n\\mathrm{RMSRE}=\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left(\\frac{\\lVert \\mathbf{F}_i^{(trunc)}-\\mathbf{F}_i^{(ref)}\\rVert}{\\max\\{\\lVert \\mathbf{F}_i^{(ref)}\\rVert,\\epsilon\\}}\\right)^2}\n$$\nThis quantity provides a measure of the accuracy lost due to truncation of the real and reciprocal space sums. The implementation will follow these derived formulas to evaluate the RMSRE for the specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the Ewald summation error analysis.\n    It solves the problem as stated, computing the RMS relative force error for several\n    parameter sets and printing the results in the specified format.\n    \"\"\"\n    # System specification\n    N = 4\n    L = 1.0\n    charges = np.array([+1.0, -1.0, +1.0, -1.0])\n    positions = np.array([\n        [0.10, 0.10, 0.10],\n        [0.40, 0.20, 0.70],\n        [0.80, 0.90, 0.30],\n        [0.65, 0.25, 0.95]\n    ])\n    epsilon_reg = 1e-12\n\n    # Test cases: (alpha, r_cut, k_cut)\n    test_cases = [\n        (5.0, 1.5, 20.0),  # Case A\n        (5.0, 0.5, 20.0),  # Case B\n        (5.0, 1.5, 6.0),   # Case C\n        (5.0, 0.0, 20.0),  # Case D\n        (5.0, 2.5, 0.0),   # Case E\n        (2.5, 1.5, 20.0),  # Case F\n    ]\n\n    # Reference calculation parameters\n    r_cut_ref = 3.0\n    k_cut_ref = 50.0\n\n    def calculate_ewald_force(alpha, r_cut, k_cut):\n        \"\"\"\n        Calculates the electrostatic forces on all particles using Ewald summation.\n        \n        Args:\n            alpha (float): Ewald splitting parameter.\n            r_cut (float): Real-space cutoff distance.\n            k_cut (float): Reciprocal-space cutoff magnitude.\n            \n        Returns:\n            numpy.ndarray: An (N, 3) array of force vectors for each particle.\n        \"\"\"\n        # --- Real-Space Contribution ---\n        F_real = np.zeros((N, 3))\n        if r_cut > 0:\n            n_max = int(np.ceil(r_cut / L))\n            for i in range(N):\n                for j in range(N):\n                    qiqj = charges[i] * charges[j]\n                    rij = positions[i] - positions[j]\n                    for nx in range(-n_max, n_max + 1):\n                        for ny in range(-n_max, n_max + 1):\n                            for nz in range(-n_max, n_max + 1):\n                                if i == j and nx == 0 and ny == 0 and nz == 0:\n                                    continue\n                                \n                                box_vec = L * np.array([nx, ny, nz])\n                                r_vec = rij + box_vec\n                                r_mag = np.linalg.norm(r_vec)\n\n                                if r_mag < r_cut:\n                                    ar = alpha * r_mag\n                                    term1 = erfc(ar) / r_mag**3\n                                    term2 = (2.0 * alpha / np.sqrt(np.pi)) * np.exp(-ar**2) / r_mag**2\n                                    force_vec = qiqj * (term1 + term2) * r_vec\n                                    F_real[i] += force_vec\n\n        # --- Reciprocal-Space Contribution ---\n        F_recip = np.zeros((N, 3))\n        V = L**3\n        if k_cut > 0:\n            m_max = int(np.ceil(k_cut * L / (2 * np.pi)))\n            for mx in range(-m_max, m_max + 1):\n                for my in range(-m_max, m_max + 1):\n                    for mz in range(-m_max, m_max + 1):\n                        if mx == 0 and my == 0 and mz == 0:\n                            continue\n\n                        m_vec = np.array([mx, my, mz])\n                        k_vec = (2 * np.pi / L) * m_vec\n                        k_sq = np.dot(k_vec, k_vec)\n\n                        if np.sqrt(k_sq) < k_cut:\n                            # Structure factor components\n                            k_dot_r = np.dot(positions, k_vec)\n                            C_sum = np.sum(charges * np.cos(k_dot_r))\n                            S_sum = np.sum(charges * np.sin(k_dot_r))\n\n                            prefac = (4 * np.pi / V) * np.exp(-k_sq / (4 * alpha**2)) / k_sq\n\n                            # Force on each particle i\n                            sin_kr_i = np.sin(k_dot_r)\n                            cos_kr_i = np.cos(k_dot_r)\n                            factor_i = charges * (C_sum * sin_kr_i - S_sum * cos_kr_i)\n                            \n                            F_recip += prefac * np.outer(factor_i, k_vec)\n        \n        return F_real + F_recip\n\n    results = []\n    for case in test_cases:\n        alpha, r_cut, k_cut = case\n\n        # Calculate force with truncated parameters\n        F_trunc = calculate_ewald_force(alpha, r_cut, k_cut)\n        \n        # Calculate force with reference parameters (using the same alpha)\n        F_ref = calculate_ewald_force(alpha, r_cut_ref, k_cut_ref)\n        \n        # Calculate Root-Mean-Square Relative Error (RMSRE)\n        sum_sq_rel_err = 0.0\n        for i in range(N):\n            delta_F_norm = np.linalg.norm(F_trunc[i] - F_ref[i])\n            F_ref_norm = np.linalg.norm(F_ref[i])\n            \n            denominator = max(F_ref_norm, epsilon_reg)\n            relative_error = delta_F_norm / denominator\n            sum_sq_rel_err += relative_error**2\n        \n        rmsre = np.sqrt(sum_sq_rel_err / N)\n        results.append(rmsre)\n\n    # Format and print the final output as a single line\n    output_str = \",\".join([f\"{res:.6e}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2390969"}]}