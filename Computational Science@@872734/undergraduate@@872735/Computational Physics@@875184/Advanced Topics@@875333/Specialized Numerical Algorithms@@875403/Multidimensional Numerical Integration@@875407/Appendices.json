{"hands_on_practices": [{"introduction": "The first step in any numerical integration problem is correctly formulating the integral itself. This exercise takes us back to the fundamentals of vector calculus, asking us to derive the surface area of a patch on a torus [@problem_id:2415007]. By setting up the double integral from the parametric definition of the surface, you will reinforce the crucial skill of translating a geometric or physical problem into a precise mathematical expression that can then be solved, whether analytically or numerically.", "problem": "A standard torus arises in computational physics when evaluating geometric factors in flux calculations and surface integrals. Consider the torus embedded in three-dimensional Euclidean space with major radius $R$ and minor radius $r$, parameterized by angles $\\theta$ and $\\phi$ according to\n$$\nx(\\theta,\\phi) = \\left(R + r \\cos\\theta\\right)\\cos\\phi,\\quad\ny(\\theta,\\phi) = \\left(R + r \\cos\\theta\\right)\\sin\\phi,\\quad\nz(\\theta,\\phi) = r \\sin\\theta,\n$$\nwhere $-\\pi \\le \\theta \\le \\pi$ and $0 \\le \\phi < 2\\pi$. All angles are measured in radians. A surface patch $\\mathcal{P}$ is defined by the parameter domain $\\theta \\in \\left[-\\frac{\\pi}{3},\\,\\frac{\\pi}{6}\\right]$ and $\\phi \\in \\left[\\frac{\\pi}{4},\\,\\frac{5\\pi}{4}\\right]$. Let $R=3$ and $r=1$.\n\nStarting from the definition of surface area for a smooth parametric surface embedded in three-dimensional Euclidean space, express the area of $\\mathcal{P}$ as a double integral over the parameter domain and evaluate it exactly in closed form. Provide the exact analytic value for the area. Do not approximate or round the result.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- Parametric equations for a torus:\n  $x(\\theta,\\phi) = \\left(R + r \\cos\\theta\\right)\\cos\\phi$\n  $y(\\theta,\\phi) = \\left(R + r \\cos\\theta\\right)\\sin\\phi$\n  $z(\\theta,\\phi) = r \\sin\\theta$\n- Parameter domain for the entire torus: $-\\pi \\le \\theta \\le \\pi$ and $0 \\le \\phi < 2\\pi$.\n- Parameter domain for the surface patch $\\mathcal{P}$: $\\theta \\in \\left[-\\frac{\\pi}{3},\\,\\frac{\\pi}{6}\\right]$ and $\\phi \\in \\left[\\frac{\\pi}{4},\\,\\frac{5\\pi}{4}\\right]$.\n- Constants: Major radius $R=3$ and minor radius $r=1$.\n- Objective: Express the area of $\\mathcal{P}$ as a double integral and evaluate it exactly.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is based on standard vector calculus and the geometry of surfaces of revolution. The parameterization of a torus is a well-established mathematical construct.\n- **Well-Posedness**: The problem is well-posed. It provides a specific parameterization, a well-defined domain of integration, and specific values for all parameters. The task, calculating the surface area, is a standard problem in multivariable calculus with a unique solution.\n- **Objectivity**: The problem is stated using precise, objective mathematical language.\n- **Flaw Analysis**:\n  1. The problem is free of scientific or factual unsoundness. The condition $R > r$ (specifically, $3 > 1$) ensures the torus is a standard, non-self-intersecting ring torus.\n  2. The problem is formalizable and relevant to its stated field. Calculating surface integrals is fundamental in many areas of physics and engineering.\n  3. The setup is complete and consistent. All necessary information is provided.\n  4. The conditions are physically and mathematically realistic.\n  5. The problem is well-structured and unambiguous.\n  6. The result is verifiable through standard mathematical derivation.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A solution will be derived.\n\nThe area $A$ of a smooth parametric surface $\\mathbf{r}(u, v)$ defined over a domain $D$ in the $uv$-plane is given by the integral:\n$$ A = \\iint_D \\left\\| \\frac{\\partial\\mathbf{r}}{\\partial u} \\times \\frac{\\partial\\mathbf{r}}{\\partial v} \\right\\| \\,du\\,dv $$\nFor the given torus, the parameters are $\\theta$ and $\\phi$. The position vector is:\n$$ \\mathbf{r}(\\theta, \\phi) = \\langle (R + r \\cos\\theta)\\cos\\phi, (R + r \\cos\\theta)\\sin\\phi, r \\sin\\theta \\rangle $$\nFirst, we compute the partial derivatives with respect to $\\theta$ and $\\phi$:\n$$ \\frac{\\partial\\mathbf{r}}{\\partial\\theta} = \\mathbf{r}_\\theta = \\langle -r\\sin\\theta\\cos\\phi, -r\\sin\\theta\\sin\\phi, r\\cos\\theta \\rangle $$\n$$ \\frac{\\partial\\mathbf{r}}{\\partial\\phi} = \\mathbf{r}_\\phi = \\langle -(R + r\\cos\\theta)\\sin\\phi, (R + r\\cos\\theta)\\cos\\phi, 0 \\rangle $$\nNext, we compute the cross product $\\mathbf{r}_\\theta \\times \\mathbf{r}_\\phi$:\n$$ \\mathbf{r}_\\theta \\times \\mathbf{r}_\\phi = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ -r\\sin\\theta\\cos\\phi & -r\\sin\\theta\\sin\\phi & r\\cos\\theta \\\\ -(R+r\\cos\\theta)\\sin\\phi & (R+r\\cos\\theta)\\cos\\phi & 0 \\end{vmatrix} $$\nThe components of the cross product are:\n- $\\mathbf{i}$: $( -r\\sin\\theta\\sin\\phi )(0) - ( r\\cos\\theta )((R+r\\cos\\theta)\\cos\\phi) = -r(R+r\\cos\\theta)\\cos\\theta\\cos\\phi$\n- $\\mathbf{j}$: $( r\\cos\\theta )(-(R+r\\cos\\theta)\\sin\\phi) - ( -r\\sin\\theta\\cos\\phi )(0) = -r(R+r\\cos\\theta)\\cos\\theta\\sin\\phi$\n- $\\mathbf{k}$: $( -r\\sin\\theta\\cos\\phi )((R+r\\cos\\theta)\\cos\\phi) - ( -r\\sin\\theta\\sin\\phi )(-(R+r\\cos\\theta)\\sin\\phi)$\n   $= -r(R+r\\cos\\theta)\\sin\\theta(\\cos^2\\phi + \\sin^2\\phi) = -r(R+r\\cos\\theta)\\sin\\theta$\nSo, the cross product vector is:\n$$ \\mathbf{r}_\\theta \\times \\mathbf{r}_\\phi = \\langle -r(R+r\\cos\\theta)\\cos\\theta\\cos\\phi, -r(R+r\\cos\\theta)\\cos\\theta\\sin\\phi, -r(R+r\\cos\\theta)\\sin\\theta \\rangle $$\nNow, we find the magnitude of this vector:\n$$ \\|\\mathbf{r}_\\theta \\times \\mathbf{r}_\\phi\\|^2 = \\left(-r(R+r\\cos\\theta)\\cos\\theta\\cos\\phi\\right)^2 + \\left(-r(R+r\\cos\\theta)\\cos\\theta\\sin\\phi\\right)^2 + \\left(-r(R+r\\cos\\theta)\\sin\\theta\\right)^2 $$\nFactor out the common term $r^2(R+r\\cos\\theta)^2$:\n$$ \\|\\mathbf{r}_\\theta \\times \\mathbf{r}_\\phi\\|^2 = r^2(R+r\\cos\\theta)^2 \\left( \\cos^2\\theta\\cos^2\\phi + \\cos^2\\theta\\sin^2\\phi + \\sin^2\\theta \\right) $$\n$$ = r^2(R+r\\cos\\theta)^2 \\left( \\cos^2\\theta(\\cos^2\\phi + \\sin^2\\phi) + \\sin^2\\theta \\right) $$\n$$ = r^2(R+r\\cos\\theta)^2 \\left( \\cos^2\\theta + \\sin^2\\theta \\right) = r^2(R+r\\cos\\theta)^2 $$\nThe magnitude, which represents the differential surface element $dS$, is the square root:\n$$ dS = \\|\\mathbf{r}_\\theta \\times \\mathbf{r}_\\phi\\| = \\sqrt{r^2(R+r\\cos\\theta)^2} = |r(R+r\\cos\\theta)| $$\nGiven $R=3$ and $r=1$, we have $R > r > 0$. The term $R+r\\cos\\theta = 3+\\cos\\theta$ is always positive, since $\\cos\\theta \\in [-1, 1]$. Therefore, the absolute value is redundant.\n$$ dS = r(R+r\\cos\\theta)d\\theta d\\phi $$\nThe area of the patch $\\mathcal{P}$ is the integral of $dS$ over the specified domain $D = \\{(\\theta, \\phi) | -\\frac{\\pi}{3} \\le \\theta \\le \\frac{\\pi}{6}, \\frac{\\pi}{4} \\le \\phi \\le \\frac{5\\pi}{4}\\}$:\n$$ A = \\iint_D r(R+r\\cos\\theta) \\,d\\theta\\,d\\phi = \\int_{\\pi/4}^{5\\pi/4} \\int_{-\\pi/3}^{\\pi/6} r(R+r\\cos\\theta) \\,d\\theta\\,d\\phi $$\nSubstitute the values $R=3$ and $r=1$:\n$$ A = \\int_{\\pi/4}^{5\\pi/4} \\int_{-\\pi/3}^{\\pi/6} (3+\\cos\\theta) \\,d\\theta\\,d\\phi $$\nSince the integrand $(3+\\cos\\theta)$ does not depend on $\\phi$, the integral is separable:\n$$ A = \\left(\\int_{\\pi/4}^{5\\pi/4} d\\phi\\right) \\left(\\int_{-\\pi/3}^{\\pi/6} (3+\\cos\\theta) \\,d\\theta\\right) $$\nEvaluate each integral separately. The integral with respect to $\\phi$ is:\n$$ \\int_{\\pi/4}^{5\\pi/4} d\\phi = [\\phi]_{\\pi/4}^{5\\pi/4} = \\frac{5\\pi}{4} - \\frac{\\pi}{4} = \\frac{4\\pi}{4} = \\pi $$\nThe integral with respect to $\\theta$ is:\n$$ \\int_{-\\pi/3}^{\\pi/6} (3+\\cos\\theta) \\,d\\theta = [3\\theta + \\sin\\theta]_{-\\pi/3}^{\\pi/6} $$\n$$ = \\left(3\\left(\\frac{\\pi}{6}\\right) + \\sin\\left(\\frac{\\pi}{6}\\right)\\right) - \\left(3\\left(-\\frac{\\pi}{3}\\right) + \\sin\\left(-\\frac{\\pi}{3}\\right)\\right) $$\n$$ = \\left(\\frac{\\pi}{2} + \\frac{1}{2}\\right) - \\left(-\\pi - \\sin\\left(\\frac{\\pi}{3}\\right)\\right) $$\n$$ = \\left(\\frac{\\pi}{2} + \\frac{1}{2}\\right) - \\left(-\\pi - \\frac{\\sqrt{3}}{2}\\right) $$\n$$ = \\frac{\\pi}{2} + \\frac{1}{2} + \\pi + \\frac{\\sqrt{3}}{2} = \\frac{3\\pi}{2} + \\frac{1+\\sqrt{3}}{2} = \\frac{3\\pi + 1 + \\sqrt{3}}{2} $$\nThe total area $A$ is the product of the two results:\n$$ A = (\\pi) \\left(\\frac{3\\pi + 1 + \\sqrt{3}}{2}\\right) = \\frac{3\\pi^2 + \\pi + \\pi\\sqrt{3}}{2} $$\nThis is the exact analytical value for the area of the surface patch $\\mathcal{P}$.", "answer": "$$\\boxed{\\frac{3\\pi^2 + \\pi + \\pi\\sqrt{3}}{2}}$$", "id": "2415007"}, {"introduction": "With the ability to set up integrals, we can now apply numerical methods to solve problems in physics. This practice provides a hands-on opportunity to verify one of the cornerstones of electromagnetism, Gauss's Law, by direct computation [@problem_id:2415017]. You will write a program to calculate the total electric flux through a cubical surface by numerically integrating over its six faces, demonstrating how computational techniques can confirm profound physical principles from the ground up.", "problem": "You are asked to write a complete, runnable program that numerically evaluates the total electric flux through a closed cubical surface due to a point charge and compares the result against the prediction from Gauss's Law. Work in vacuum under the International System of Units (SI). All physical answers involving flux must be expressed in $\\mathrm{N \\cdot m^2/C}$.\n\nA point charge of magnitude $q$ located at position $\\mathbf{r}_0 = (x_q,y_q,z_q)$ in vacuum produces an electric field given by Coulomb’s law,\n$$\n\\mathbf{E}(\\mathbf{r}) = \\frac{1}{4\\pi \\varepsilon_0}\\,\\frac{q\\,(\\mathbf{r}-\\mathbf{r}_0)}{\\lVert \\mathbf{r}-\\mathbf{r}_0\\rVert^3},\n$$\nwhere $\\varepsilon_0$ is the vacuum permittivity. The total electric flux $\\Phi$ through a closed surface $S$ is defined as\n$$\n\\Phi = \\iint_S \\mathbf{E}\\cdot d\\mathbf{A},\n$$\nwhere $d\\mathbf{A}$ is the outward-pointing area element. Gauss’s Law states that for a point charge, the exact flux through any closed surface is\n$$\n\\Phi_{\\text{exact}} = \\frac{q_{\\text{enclosed}}}{\\varepsilon_0},\n$$\nwhere $q_{\\text{enclosed}}=q$ if the charge lies strictly inside the closed surface and $q_{\\text{enclosed}}=0$ if it lies strictly outside. Cases in which the charge lies exactly on the surface are not considered here.\n\nLet the closed surface be an axis-aligned cube of side length $L>0$ centered at $\\mathbf{c}=(c_x,c_y,c_z)$, so its six faces are the planes $x=c_x\\pm L/2$, $y=c_y\\pm L/2$, and $z=c_z\\pm L/2$ with outward normals.\n\nYour program must:\n- Numerically compute the surface integral $\\Phi=\\iint_S \\mathbf{E}\\cdot d\\mathbf{A}$ by integrating over the six faces. Do not assume any symmetry reduction.\n- Determine $q_{\\text{enclosed}}$ by testing whether $(x_q,y_q,z_q)$ lies strictly within the open cube $(c_x-L/2,c_x+L/2)\\times(c_y-L/2,c_y+L/2)\\times(c_z-L/2,c_z+L/2)$.\n- Compute the absolute error $\\Delta=\\lvert \\Phi-\\Phi_{\\text{exact}}\\rvert$ for each test case.\n- Express each $\\Delta$ in $\\mathrm{N \\cdot m^2/C}$ and round each value to six significant figures in scientific notation in the final output.\n\nUse the vacuum permittivity $\\varepsilon_0=8.8541878128\\times 10^{-12}\\ \\mathrm{F/m}$, and assume standard SI values for all quantities. Any angles internal to your numerical method, if used, must be in radians.\n\nTest suite: Your program must evaluate the cases below, where $L$ is in $\\mathrm{m}$, positions are in $\\mathrm{m}$, and $q$ is in $\\mathrm{C}$.\n- Case $1$: $\\mathbf{c}=(0,0,0)$, $L=2$, $\\mathbf{r}_0=(0,0,0)$, $q=1.0\\times 10^{-6}$.\n- Case $2$: $\\mathbf{c}=(0,0,0)$, $L=2$, $\\mathbf{r}_0=(3,0,0)$, $q=1.0\\times 10^{-6}$.\n- Case $3$: $\\mathbf{c}=(0.2,-0.1,0.3)$, $L=1.4$, $\\mathbf{r}_0=(0.8,-0.1,0.3)$, $q=-2.0\\times 10^{-6}$.\n- Case $4$: $\\mathbf{c}=(1.0,1.0,1.0)$, $L=0.5$, $\\mathbf{r}_0=(1.1,1.1,1.1)$, $q=5.0\\times 10^{-7}$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the $k$-th entry is the absolute error $\\Delta$ for Case $k$ in $\\mathrm{N \\cdot m^2/C}$, rounded to six significant figures in scientific notation. For example, an output line with four results must look like\n$$\n[\\text{d}_1,\\text{d}_2,\\text{d}_3,\\text{d}_4]\n$$\nwith each $\\text{d}_k$ printed in scientific notation with six significant figures.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It constitutes a well-posed exercise in computational physics, is scientifically sound, and provides a complete set of parameters and unambiguous objectives. We will therefore proceed with a full solution. The objective is to numerically compute the electric flux through a closed cubical surface and compare this result to the exact theoretical value given by Gauss's Law.\n\nThe electric field $\\mathbf{E}$ generated by a point charge $q$ at position $\\mathbf{r}_0 = (x_q, y_q, z_q)$ is given by Coulomb's Law:\n$$\n\\mathbf{E}(\\mathbf{r}) = k_e q \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert^3}\n$$\nwhere $\\mathbf{r}=(x,y,z)$ is the observation point and $k_e = \\frac{1}{4\\pi\\varepsilon_0}$ is Coulomb's constant, with $\\varepsilon_0$ being the vacuum permittivity.\n\nThe total electric flux $\\Phi$ through a closed surface $S$ is the surface integral of the electric field:\n$$\n\\Phi = \\iint_S \\mathbf{E} \\cdot d\\mathbf{A}\n$$\nThe surface $S$ in this problem is an axis-aligned cube of side length $L$ centered at $\\mathbf{c} = (c_x, c_y, c_z)$. This closed surface is composed of six planar faces. The total flux is the sum of the fluxes through each of these six faces:\n$$\n\\Phi = \\sum_{i=1}^{6} \\Phi_i = \\sum_{i=1}^{6} \\iint_{S_i} \\mathbf{E} \\cdot d\\mathbf{A}_i\n$$\nwhere $S_i$ is the surface of the $i$-th face.\n\nTo compute the flux through a single face, we must define the integrand $\\mathbf{E} \\cdot d\\mathbf{A}$ and the limits of integration. Let us consider a generic face. For an axis-aligned cube, each face is defined by a constant coordinate (e.g., $x = c_x + L/2$) and has an outward-pointing normal vector $\\mathbf{\\hat{n}}$ that is parallel to one of the coordinate axes. The differential area element is $d\\mathbf{A} = \\mathbf{\\hat{n}} \\, du \\, dv$, where $u$ and $v$ are the two integration variables spanning the planar face. The flux through this face is then:\n$$\n\\Phi_i = \\iint_{S_i} (\\mathbf{E} \\cdot \\mathbf{\\hat{n}}) \\, du \\, dv\n$$\nThe integrand, $\\mathbf{E} \\cdot \\mathbf{\\hat{n}}$, can be expressed more explicitly. Substituting the expression for $\\mathbf{E}(\\mathbf{r})$:\n$$\n\\mathbf{E}(\\mathbf{r}(u,v)) \\cdot \\mathbf{\\hat{n}} = k_e q \\frac{(\\mathbf{r}(u,v) - \\mathbf{r}_0) \\cdot \\mathbf{\\hat{n}}}{\\lVert \\mathbf{r}(u,v) - \\mathbf{r}_0 \\rVert^3}\n$$\nwhere $\\mathbf{r}(u,v)$ is the position vector of a point on the face $S_i$. For example, for the face at $x = c_x + L/2$, the normal is $\\mathbf{\\hat{n}}=(1,0,0)$, the integration variables are $(u,v)=(y,z)$, and the position vector is $\\mathbf{r}(y,z) = (c_x + L/2, y, z)$. The integration limits for $y$ and $z$ are $[c_y - L/2, c_y + L/2]$ and $[c_z - L/2, c_z + L/2]$, respectively. This formulation is applied systematically to all six faces.\n\nThe calculation of each two-dimensional integral $\\Phi_i$ is performed numerically using an adaptive quadrature algorithm. The `scipy.integrate.dblquad` function is suitable for this purpose. This function iteratively refines a grid to achieve a desired accuracy for the integral of a given two-dimensional function over a rectangular domain. Since the problem statement guarantees that the charge $q$ is never located exactly on the surface $S$, the integrand is continuous and well-behaved on each face $S_i$, ensuring the reliability of the numerical integration.\n\nThe numerical result for the total flux, $\\Phi_{\\text{numerical}} = \\sum_i \\Phi_i$, is then compared against the exact theoretical value, $\\Phi_{\\text{exact}}$, given by Gauss's Law:\n$$\n\\Phi_{\\text{exact}} = \\frac{q_{\\text{enclosed}}}{\\varepsilon_0}\n$$\nTo determine $q_{\\text{enclosed}}$, we perform a simple geometric containment test. The charge $q$ is enclosed, so $q_{\\text{enclosed}} = q$, if and only if its coordinates $(x_q, y_q, z_q)$ lie strictly within the volume of the cube. This condition is formally expressed as:\n$$\n(c_x - L/2 < x_q < c_x + L/2) \\land (c_y - L/2 < y_q < c_y + L/2) \\land (c_z - L/2 < z_q < c_z + L/2)\n$$\nIf this condition is not met, the charge is outside the cube, and $q_{\\text{enclosed}} = 0$.\n\nFinally, the absolute error $\\Delta$ between the numerically computed flux and the exact flux is calculated to assess the accuracy of our numerical method:\n$$\n\\Delta = \\lvert \\Phi_{\\text{numerical}} - \\Phi_{\\text{exact}} \\rvert\n$$\nThis procedure is applied to each test case specified in the problem. The resulting error $\\Delta$ quantifies how closely our numerical integration of the fundamental definition of flux aligns with the powerful and elegant statement of Gauss's Law.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Physical constants in SI units\n    EPSILON_0 = 8.8541878128e-12  # Vacuum permittivity in F/m\n    K_E = 1.0 / (4.0 * np.pi * EPSILON_0)  # Coulomb's constant\n\n    # Test suite: (center, side_length, charge_position, charge_magnitude)\n    test_cases = [\n        # Case 1: Charge at center, inside\n        ((0.0, 0.0, 0.0), 2.0, (0.0, 0.0, 0.0), 1.0e-6),\n        # Case 2: Charge outside\n        ((0.0, 0.0, 0.0), 2.0, (3.0, 0.0, 0.0), 1.0e-6),\n        # Case 3: Charge inside, off-center\n        ((0.2, -0.1, 0.3), 1.4, (0.8, -0.1, 0.3), -2.0e-6),\n        # Case 4: Charge inside, near corner\n        ((1.0, 1.0, 1.0), 0.5, (1.1, 1.1, 1.1), 5.0e-7),\n    ]\n\n    results = []\n    for c_tuple, L, r0_tuple, q in test_cases:\n        c = np.array(c_tuple)\n        r0 = np.array(r0_tuple)\n        \n        # Calculate numerical flux by integrating over the six faces\n        numerical_flux = calculate_numerical_flux(c, L, r0, q, K_E)\n        \n        # Determine exact flux from Gauss's Law\n        h = L / 2.0\n        is_inside = (\n            (c[0] - h < r0[0] < c[0] + h) and\n            (c[1] - h < r0[1] < c[1] + h) and\n            (c[2] - h < r0[2] < c[2] + h)\n        )\n        q_enclosed = q if is_inside else 0.0\n        exact_flux = q_enclosed / EPSILON_0\n        \n        # Compute the absolute error\n        error = abs(numerical_flux - exact_flux)\n        \n        # Format result to 6 significant figures in scientific notation\n        # Precision p-1 for p significant digits, so 5 for 6 sig figs.\n        results.append(f\"{error:.5e}\")\n\n    # Print an output line in the required format\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_numerical_flux(c, L, r0, q, K_E):\n    \"\"\"\n    Numerically computes the total electric flux through a cubical surface.\n\n    Args:\n        c (np.ndarray): Center of the cube (cx, cy, cz).\n        L (float): Side length of the cube.\n        r0 (np.ndarray): Position of the point charge (xq, yq, zq).\n        q (float): Magnitude of the point charge.\n        K_E (float): Coulomb's constant.\n\n    Returns:\n        float: The total numerical flux.\n    \"\"\"\n    h = L / 2.0\n    total_flux = 0.0\n\n    # Define the six faces of the cube.\n    # Each tuple contains: (fixed_dim_idx, sign, integration_dims_indices)\n    # fixed_dim_idx: 0 for x, 1 for y, 2 for z\n    # sign: +1 for positive-side face, -1 for negative-side face\n    # integration_dims: indices of the two integration variables\n    faces = [\n        (0,  1, (1, 2)),  # Right face (x = cx + h)\n        (0, -1, (1, 2)),  # Left face  (x = cx - h)\n        (1,  1, (0, 2)),  # Top face   (y = cy + h)\n        (1, -1, (0, 2)),  # Bottom face(y = cy - h)\n        (2,  1, (0, 1)),  # Front face (z = cz + h)\n        (2, -1, (0, 1)),  # Back face  (z = cz - h)\n    ]\n\n    for fixed_dim, sign, int_dims in faces:\n        fixed_coord_val = c[fixed_dim] + sign * h\n        u_idx, v_idx = int_dims\n        \n        u_min, u_max = c[u_idx] - h, c[u_idx] + h\n        v_min, v_max = c[v_idx] - h, c[v_idx] + h\n\n        def integrand(v, u):\n            # `u` and `v` are the integration variables on the face.\n            # dblquad expects the function signature func(inner_var, outer_var)\n            # Here, v is inner, u is outer.\n            r_surf = np.zeros(3)\n            r_surf[fixed_dim] = fixed_coord_val\n            r_surf[u_idx] = u\n            r_surf[v_idx] = v\n            \n            vec_r = r_surf - r0\n            dist_sq = vec_r @ vec_r\n\n            if dist_sq == 0:\n                # Charge is on the integration path point, which is guaranteed\n                # not to happen for the overall surface but might be sampled\n                # by the quadrature. Return 0 to avoid division by zero.\n                return 0.0\n            \n            dist = np.sqrt(dist_sq)\n\n            # The integrand is the component of E normal to the surface: E . n_hat\n            # E . n_hat = (K_E * q * vec_r / dist^3) . n_hat\n            # vec_r . n_hat is simply the component of vec_r along the normal.\n            vec_r_dot_n_hat = vec_r[fixed_dim] * sign\n            \n            return K_E * q * vec_r_dot_n_hat / (dist**3)\n\n        flux_face, _ = dblquad(\n            integrand,\n            u_min, u_max,       # outer integration limits (u)\n            lambda u: v_min,    # inner integration lower limit (v)\n            lambda u: v_max     # inner integration upper limit (v)\n        )\n        total_flux += flux_face\n\n    return total_flux\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2415017"}, {"introduction": "Advanced algorithms for multidimensional integration, such as the VEGAS Monte Carlo method, are powerful but not magic. This final practice challenges you to think critically about the inner workings and limitations of such tools [@problem_id:2415025]. By analyzing a scenario where an integration algorithm is misapplied to an optimization problem, you will learn why understanding a method's underlying assumptions—like the use of separable marginals—is essential for avoiding incorrect conclusions.", "problem": "Consider the integral of a non-separable integrand in $4$ dimensions,\n$$\nI \\;=\\; \\int_{[0,1]^4} f(\\mathbf{x})\\,\\mathrm{d}\\mathbf{x}, \\quad \\mathbf{x}=(x_1,x_2,x_3,x_4),\n$$\nwith\n$$\nf(\\mathbf{x}) \\;=\\; \\exp\\!\\left(-\\alpha\\big[(x_1-0.2)^2+(x_2-0.8)^2\\big]\\right)\\,\\exp\\!\\left(-\\beta\\big[(x_3-0.7)^2+(x_4-0.3)^2\\big]\\right) \\;+\\; \\exp\\!\\left(-\\alpha\\big[(x_1-0.8)^2+(x_2-0.2)^2\\big]\\right)\\,\\exp\\!\\left(-\\beta\\big[(x_3-0.3)^2+(x_4-0.7)^2\\big]\\right),\n$$\nwhere $\\alpha>0$ and $\\beta>0$ are fixed constants. A team uses the VEGAS algorithm (importance-sampling Monte Carlo with an adaptive, separable sampling density) to estimate $I$. In particular, VEGAS adapts a separable sampling density $g(\\mathbf{x})=\\prod_{i=1}^{4} g_i(x_i)$ by iteratively building one-dimensional histograms intended to approximate the marginals of $|f|$ along each coordinate, and allocates finer grid bins where those marginals are larger.\n\nA student proposes to use the final VEGAS adaptive grid to “locate the maximum” of $f$ by identifying, in each coordinate $x_i$, the bin with the largest estimated weight and then taking the Cartesian product of the $4$ one-dimensional bin centers as an estimate of the maximizer of $f$ over $[0,1]^4$.\n\nWhich of the following statements is/are correct? Select all that apply.\n\nA. For a generic non-separable integrand in $4$ dimensions, a separable, marginal-based adaptive grid cannot, in general, identify the global maximizer of $f$ from grid information alone.\n\nB. If $f(\\mathbf{x})=\\prod_{i=1}^{4} f_i(x_i)$ with each $f_i$ unimodal on $[0,1]$, then the global maximizer of $f$ is the tuple of the coordinate-wise maximizers of the $f_i$, and, with sufficiently many VEGAS samples, the densest bins along each coordinate converge to those coordinates.\n\nC. Selecting the one-dimensional bins with largest weights and taking any corner of their Cartesian product yields a consistent estimator of the maximizer of $f$ for any continuous $f$ on $[0,1]^4$.\n\nD. For the specific non-separable $f$ given above, combining the positions of the maxima of the one-dimensional marginals of $|f|$ can produce a point at which $f$ is not locally maximal and can be small, illustrating a failure mode of separable adaptation.\n\nE. The maximum value of $f$ observed among the samples drawn during a VEGAS run is an unbiased estimator of the true maximum value of $f$ on $[0,1]^4$.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- Integral: $I = \\int_{[0,1]^4} f(\\mathbf{x})\\,\\mathrm{d}\\mathbf{x}$\n- Domain: $[0,1]^4$, with $\\mathbf{x}=(x_1,x_2,x_3,x_4)$ in $4$ dimensions.\n- Integrand: $f(\\mathbf{x}) = \\exp\\!\\left(-\\alpha\\big[(x_1-0.2)^2+(x_2-0.8)^2\\big]\\right)\\,\\exp\\!\\left(-\\beta\\big[(x_3-0.7)^2+(x_4-0.3)^2\\big]\\right) + \\exp\\!\\left(-\\alpha\\big[(x_1-0.8)^2+(x_2-0.2)^2\\big]\\right)\\,\\exp\\!\\left(-\\beta\\big[(x_3-0.3)^2+(x_4-0.7)^2\\big]\\right)$.\n- Constants: $\\alpha>0$ and $\\beta>0$.\n- Algorithm: VEGAS, which uses an adaptive, separable sampling density $g(\\mathbf{x})=\\prod_{i=1}^{4} g_i(x_i)$.\n- Adaptation rule: Grid refinement is based on one-dimensional histograms approximating the marginals of $|f(\\mathbf{x})|$ along each coordinate.\n- Student's proposal: To find the maximizer of $f$, one should identify the bin with the largest weight in each of the $4$ coordinate dimensions and take the Cartesian product of the centers of these bins.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is well-grounded in computational physics and numerical methods. The VEGAS algorithm is a standard technique for multidimensional integration. The integrand, while constructed for this problem, is a perfectly valid, continuous function. The concepts of separability, marginal distributions, and importance sampling are fundamental to the field.\n- **Well-Posedness**: The problem is well-posed. It asks for an evaluation of several statements concerning a specific application of information derived from the VEGAS algorithm. The question is clear and has a definite, logical resolution based on the properties of the algorithm and the function.\n- **Objectivity**: The problem is stated in precise mathematical and algorithmic language, free from subjectivity or ambiguity.\n\n**Step 3: Verdict and Action**\nThe problem statement is scientifically sound, self-contained, and unambiguous. It is a valid problem requiring analysis of the VEGAS algorithm's limitations. We proceed to solve it.\n\nThe central issue is the student's attempt to use an algorithm designed for integration to perform optimization. Specifically, the student conflates properties of marginal distributions with properties of the full multidimensional function. The VEGAS algorithm adapts a separable probability density, $g(\\mathbf{x}) = \\prod_{i=1}^4 g_i(x_i)$, to serve as an importance function for Monte Carlo integration. The adaptation process refines the grid for each coordinate $x_i$ based on an approximation of the marginal projection of the integrand, $P_i(x_i) = \\int_{[0,1]^3} |f(\\mathbf{x})| \\prod_{j \\neq i} \\mathrm{d}x_j$. For non-separable functions, information about correlations between variables, which is crucial for locating maxima, is lost during this projection.\n\nLet us analyze the given integrand $f(\\mathbf{x})$. Since $\\alpha > 0$ and $\\beta > 0$, the function $f(\\mathbf{x})$ is always positive, so $|f(\\mathbf{x})| = f(\\mathbf{x})$. The function is a sum of two terms. The first term is a Gaussian-like function peaked at $\\mathbf{p}_1 = (0.2, 0.8, 0.7, 0.3)$. The second term is a similar function peaked at $\\mathbf{p}_2 = (0.8, 0.2, 0.3, 0.7)$. If $\\alpha$ and $\\beta$ are sufficiently large, $f(\\mathbf{x})$ has two pronounced, well-separated maxima at $\\mathbf{p}_1$ and $\\mathbf{p}_2$.\n\nThe marginal distribution for $x_1$, for example, would be $P_1(x_1) = \\int_0^1 \\int_0^1 \\int_0^1 f(x_1, x_2, x_3, x_4) \\mathrm{d}x_2 \\mathrm{d}x_3 \\mathrm{d}x_4$. Due to the structure of $f(\\mathbf{x})$, this marginal will be bimodal, with peaks near $x_1=0.2$ (from the first term) and $x_1=0.8$ (from the second term). Similarly, the marginal $P_2(x_2)$ will be bimodal with peaks near $x_2=0.2$ and $x_2=0.8$. The marginal $P_3(x_3)$ will have peaks near $x_3=0.3$ and $x_3=0.7$, and $P_4(x_4)$ will have peaks near $x_4=0.3$ and $x_4=0.7$. The VEGAS grid will become dense around these eight locations in their respective dimensions. The student's method proposes combining the coordinates of these marginal \"maxima\". This leads to $2^4 = 16$ possible points. Of these, only two are the true maximizers: $(0.2, 0.8, 0.7, 0.3)$ and $(0.8, 0.2, 0.3, 0.7)$. Other combinations, such as $(0.2, 0.2, 0.3, 0.3)$, correspond to regions where $f(\\mathbf{x})$ is small, as the arguments of the exponentials do not simultaneously go to zero.\n\nNow we evaluate each statement.\n\n**A. For a generic non-separable integrand in $4$ dimensions, a separable, marginal-based adaptive grid cannot, in general, identify the global maximizer of $f$ from grid information alone.**\nThis statement is correct. A separable grid accounts only for the integrand's projections onto each axis. It is oblivious to the correlations between variables. The location of the global maximizer of a non-separable function is a property of the full joint distribution, not of its marginals. The student's proposal fails precisely because it assumes the coordinates of the global maximizer are the maximizers of the marginals, which is false in the general non-separable case.\n**Verdict: Correct.**\n\n**B. If $f(\\mathbf{x})=\\prod_{i=1}^{4} f_i(x_i)$ with each $f_i$ unimodal on $[0,1]$, then the global maximizer of $f$ is the tuple of the coordinate-wise maximizers of the $f_i$, and, with sufficiently many VEGAS samples, the densest bins along each coordinate converge to those coordinates.**\nThis statement is correct. If $f(\\mathbf{x})$ is separable, $f(\\mathbf{x}) = \\prod_i f_i(x_i)$, then finding the maximum of $f$ is equivalent to maximizing $\\ln f(\\mathbf{x}) = \\sum_i \\ln f_i(x_i)$. This sum is maximized when each term is individually maximized. Thus, the maximizer of $f$ is $(\\arg\\max_{x_1} f_1(x_1), \\dots, \\arg\\max_{x_4} f_4(x_4))$. The marginal projection for a given coordinate $x_i$ is $P_i(x_i) = \\int f(\\mathbf{x}) \\prod_{j \\neq i} \\mathrm{d}x_j = f_i(x_i) \\prod_{j \\neq i} \\int f_j(x_j) \\mathrm{d}x_j$. Since $\\prod_{j \\neq i} \\int f_j(x_j) \\mathrm{d}x_j$ is a positive constant, $P_i(x_i)$ is directly proportional to $f_i(x_i)$. Therefore, the maximum of the marginal $P_i(x_i)$ occurs at the same coordinate as the maximum of $f_i(x_i)$. VEGAS adapts its grid to be dense where the marginals are large, so its densest bins will indeed converge to the locations of the maxima of the $f_i$. In this special separable case, the student's method would work.\n**Verdict: Correct.**\n\n**C. Selecting the one-dimensional bins with largest weights and taking any corner of their Cartesian product yields a consistent estimator of the maximizer of $f$ for any continuous $f$ on $[0,1]^4$.**\nThis statement is incorrect. It makes a universal claim (\"for any continuous $f$\") that is easily falsified. As demonstrated by the non-separable function given in the problem, the method fails. The points constructed from the maxima of the marginals are not, in general, the maximizers of the function itself. A \"consistent estimator\" must converge in probability to the true value. This method converges to a value determined by the marginals, which is generally not the true maximizer. The claim is flagrantly false.\n**Verdict: Incorrect.**\n\n**D. For the specific non-separable $f$ given above, combining the positions of the maxima of the one-dimensional marginals of $|f|$ can produce a point at which $f$ is not locally maximal and can be small, illustrating a failure mode of separable adaptation.**\nThis statement is correct. As analyzed previously, the marginals are bimodal. For example, $P_1(x_1)$ has peaks near $x_1=0.2$ and $x_1=0.8$, and $P_2(x_2)$ has peaks near $x_2=0.2$ and $x_2=0.8$. Let us construct a point by combining these peak locations, for instance, $\\mathbf{x}_{\\text{test}} = (0.2, 0.2, 0.7, 0.3)$.\nEvaluating $f$ at this point:\n$f(\\mathbf{x}_{\\text{test}}) = \\exp(-\\alpha[0^2 + (-0.6)^2])\\exp(-\\beta[0^2+0^2]) + \\exp(-\\alpha[(-0.6)^2+0^2])\\exp(-\\beta[0.4^2+(-0.4)^2])$\n$f(\\mathbf{x}_{\\text{test}}) = \\exp(-0.36\\alpha) + \\exp(-0.36\\alpha)\\exp(-0.32\\beta)$.\nFor any significant $\\alpha > 0$, this value is small. For comparison, at the true maximum $\\mathbf{p}_1=(0.2, 0.8, 0.7, 0.3)$, the first term of $f$ is $1$. The point $\\mathbf{x}_{\\text{test}}$ is clearly not a maximum and has a small function value, which perfectly illustrates the failure of a separable approach on a non-separable problem.\n**Verdict: Correct.**\n\n**E. The maximum value of $f$ observed among the samples drawn during a VEGAS run is an unbiased estimator of the true maximum value of $f$ on $[0,1]^4$.**\nThis statement is incorrect. Let $M = \\sup_{\\mathbf{x} \\in [0,1]^4} f(\\mathbf{x})$. Let $\\mathbf{X}_1, \\dots, \\mathbf{X}_N$ be $N$ random samples drawn from the sampling distribution. The proposed estimator is $\\hat{M}_N = \\max_{k=1,\\dots,N} f(\\mathbf{X}_k)$. For any sample $\\mathbf{X}_k$, it is true that $f(\\mathbf{X}_k) \\leq M$. Consequently, $\\hat{M}_N \\leq M$. An estimator is unbiased if its expectation equals the true value, i.e., $E[\\hat{M}_N] = M$. However, since $\\hat{M}_N \\leq M$, we have $E[\\hat{M}_N] \\leq M$. Equality would hold only if $\\hat{M}_N = M$ with probability $1$, which would require that a random sample from a continuous distribution hits the precise maximizer, an event of probability zero. Therefore, $E[\\hat{M}_N] < M$, meaning the estimator is biased (it systematically underestimates the maximum). This is a well-known phenomenon called maximization bias.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{ABD}$$", "id": "2415025"}]}