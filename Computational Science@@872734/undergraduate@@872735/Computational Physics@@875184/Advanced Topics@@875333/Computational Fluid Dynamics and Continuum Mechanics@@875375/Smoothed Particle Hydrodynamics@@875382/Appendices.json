{"hands_on_practices": [{"introduction": "The heart of Smoothed Particle Hydrodynamics (SPH) lies in its ability to approximate continuous fields and their derivatives using a discrete set of particles, where the accuracy depends critically on the choice of the smoothing kernel. This practice [@problem_id:2439500] challenges you to implement and compare two common kernels—the cubic and quintic splines—to see firsthand how a kernel's mathematical properties translate into the accuracy of a second derivative calculation. Mastering this is vital for correctly modeling phenomena such as diffusion and viscous forces.", "problem": "Implement a program that, for one-dimensional Smoothed Particle Hydrodynamics (SPH), constructs the second derivative approximation of a scalar field using two compactly supported kernels: the standard cubic spline and a quintic spline. You must derive the needed formulas and implement them from first principles. The comparison must be performed on a periodic domain using equally spaced particles and a difference-consistent SPH operator for the second derivative. The quantities are all dimensionless and angles are in radians.\n\nStart from the fundamental base of SPH: the approximation of a function $f(x)$ via a normalized, positive, radially symmetric kernel $W(r,h)$ with compact support and smoothing length $h$, and the SPH replacement of integrals by sums over particle volumes. Use the following principles:\n- Kernel approximation of derivatives follows from differentiating the kernel inside the convolution integral.\n- For discrete particles with uniform spacing $\\Delta x$ and constant density, the particle volume is $V = \\Delta x$.\n- To avoid zeroth-order errors, use a difference-consistent discrete operator for the second derivative based on kernel second derivatives.\n\nYour tasks:\n1. Derive, from the SPH convolution integral and uniform sampling with periodic boundary conditions on $[0,L)$, a discrete, difference-consistent second derivative operator at particle position $x_i$ of the form\n   $$ f''(x_i) \\approx \\sum_{j} V \\, \\big(f(x_j) - f(x_i)\\big) \\, \\frac{\\partial^2}{\\partial x^2} W\\!\\big(|x_i - x_j|, h\\big), $$\n   where $V = \\Delta x$, $x_j$ are the particle positions, and the sum includes all neighbors within the kernel support. Explain why, in one dimension with $r = |x|$, $\\frac{\\partial^2}{\\partial x^2}W(r,h) = \\frac{d^2}{dr^2}W(r,h)$ for $r \\neq 0$.\n\n2. Implement in one dimension the standard cubic spline kernel and a quintic spline kernel, each with their correct normalizations and compact supports, and derive their one-dimensional second radial derivatives $d^2W/dr^2$ as functions of $q = r/h$ and $h$. The cubic spline has support radius $2h$ and the quintic spline has support radius $3h$. You must provide the piecewise-polynomial expressions you use for both kernels and their second derivatives in your solution.\n\n3. Use the operator from task $1$ to approximate $f''(x)$ for the following test suite. In all cases, use periodic boundary conditions, equally spaced particles, and $h = \\eta \\, \\Delta x$ with the given $\\eta$; angles are in radians.\n   - Case A (single mode): $L = 1$, $N = 200$, $\\eta = 1.2$, $f(x) = \\sin(2\\pi x)$, so the exact second derivative is $f''(x) = - (2\\pi)^2 \\sin(2\\pi x)$.\n   - Case B (two-mode superposition): $L = 1$, $N = 256$, $\\eta = 1.0$, $f(x) = \\sin(2\\pi x) + 0.5 \\sin(6\\pi x)$, so the exact second derivative is $f''(x) = - (2\\pi)^2 \\sin(2\\pi x) - 0.5 \\, (6\\pi)^2 \\sin(6\\pi x)$.\n   - Case C (coarser sampling, smaller smoothing): $L = 1$, $N = 64$, $\\eta = 0.7$, $f(x) = \\sin(2\\pi x)$, exact second derivative as in Case A.\n   - Case D (localized Gaussian): $L = 1$, $N = 400$, $\\eta = 1.0$, $f(x) = \\exp\\!\\big(-\\frac{(x - 0.3)^2}{2 \\sigma^2}\\big)$ with $\\sigma = 0.05$, so the exact second derivative is $f''(x) = f(x)\\Big(\\frac{(x - 0.3)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\Big)$.\n\n4. For each case, compute the relative root-mean-square (RMS) error for each kernel,\n   $$ \\varepsilon = \\frac{\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\big(\\hat f_i'' - f_i''\\big)^2}}{\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\big(f_i''\\big)^2}}, $$\n   where $\\hat f_i''$ is the SPH approximation and $f_i''$ is the exact value. Report, for each case, the pair of errors for the cubic and quintic kernels, each rounded to six decimal places, and a boolean indicating whether the quintic spline error is strictly smaller than the cubic spline error.\n\nFinal output format:\n- Your program should produce a single line of output containing a comma-separated list of sublists, one per test case, in the order A, B, C, D.\n- Each sublist must be of the form $[e_{\\mathrm{cubic}}, e_{\\mathrm{quintic}}, b]$, where $e_{\\mathrm{cubic}}$ and $e_{\\mathrm{quintic}}$ are the relative RMS errors rounded to six decimal places, and $b$ is a boolean that is $True$ if $e_{\\mathrm{quintic}}  e_{\\mathrm{cubic}}$ and $False$ otherwise.\n- Example pattern (not actual values): $[[0.012345,0.006789,True],[\\dots],\\dots]$.\n\nAll outputs are dimensionless floats for the errors and booleans for the comparisons, and the single line must contain only this list. No other text should be printed.", "solution": "The problem as stated is scientifically grounded, well-posed, and self-contained. It presents a standard exercise in the field of computational physics, specifically concerning the numerical approximation of derivatives using the Smoothed Particle Hydrodynamics (SPH) method. All required data and definitions are provided, and there are no evident contradictions or ambiguities. Therefore, we proceed directly to the derivation and solution.\n\nThe task is to construct and evaluate a one-dimensional SPH approximation for the second derivative of a scalar field, $f''(x)$, using two different smoothing kernels. The core of the problem lies in the correct formulation of the SPH operator and the kernels themselves.\n\nFirst, we derive the specified SPH operator for the second derivative. The foundation of SPH is the kernel approximation of a function $f(x)$, which is expressed as a convolution with a smoothing kernel $W$:\n$$ \\langle f(x) \\rangle = \\int_{\\Omega} f(x') W(|x-x'|, h) \\, dx' $$\nHere, $W$ is a normalized kernel with compact support defined by the smoothing length $h$. An approximation for the second derivative, $\\langle f''(x) \\rangle$, is obtained by differentiating this integral representation twice with respect to $x$. Assuming sufficient smoothness of $W$, we can pass the derivatives under the integral sign:\n$$ \\langle f''(x) \\rangle = \\int_{\\Omega} f(x') \\frac{\\partial^2}{\\partial x^2} W(|x-x'|, h) \\, dx' $$\nTo obtain a numerical method, this integral is discretized into a sum over a set of \"particles\" located at positions $x_j$. Each particle carries a value of the field, $f(x_j)$, and represents a small volume $V_j$. For a uniform one-dimensional particle distribution with spacing $\\Delta x$, each particle represents a volume $V = \\Delta x$. The integral is thus replaced by a summation:\n$$ f''(x_i) \\approx \\sum_{j} V f(x_j) \\frac{\\partial^2}{\\partial x^2} W(|x_i-x_j|, h) $$\nThis is a standard SPH second derivative formula. However, it is known to suffer from a zeroth-order error, meaning it does not yield exactly zero for a constant field due to discretization error. The problem specifies a superior, difference-consistent formulation:\n$$ f''(x_i) \\approx \\sum_{j} V \\left( f(x_j) - f(x_i) \\right) \\frac{\\partial^2}{\\partial x^2} W(|x_i - x_j|, h) $$\nThe merit of this form is immediately apparent. If $f(x)$ is a constant function, $f(x)=C$, then $f(x_j) - f(x_i) = 0$ for all $j$. Consequently, the summation yields $f''(x_i) \\approx 0$, which is the exact result. This operator corrects the zeroth-order inconsistency.\n\nThe operator requires evaluation of $\\frac{\\partial^2}{\\partial x^2} W(r, h)$, where $r = |x_i - x_j|$. Let $\\Delta x = x_i - x_j$. The relation between the second partial derivative with respect to $\\Delta x$ and the second ordinary derivative with respect to $r=|\\Delta x|$ is found using the chain rule.\n$$ \\frac{\\partial W}{\\partial \\Delta x} = \\frac{dW}{dr} \\frac{\\partial r}{\\partial \\Delta x} = \\frac{dW}{dr} \\text{sgn}(\\Delta x) $$\nDifferentiating again with respect to $\\Delta x$ using the product rule gives:\n$$ \\frac{\\partial^2 W}{\\partial (\\Delta x)^2} = \\left( \\frac{d^2W}{dr^2} \\frac{\\partial r}{\\partial \\Delta x} \\right) \\text{sgn}(\\Delta x) + \\frac{dW}{dr} \\frac{\\partial}{\\partial \\Delta x} (\\text{sgn}(\\Delta x)) = \\frac{d^2W}{dr^2} (\\text{sgn}(\\Delta x))^2 + \\frac{dW}{dr} (2\\delta(\\Delta x)) $$\nFor any distinct pair of particles $i \\ne j$, we have $\\Delta x \\ne 0$ and thus $r \\ne 0$. In this case, $(\\text{sgn}(\\Delta x))^2 = 1$ and the Dirac delta term $\\delta(\\Delta x)$ is zero. The contribution of the particle $j=i$ to the sum is zero because $f(x_i) - f(x_i) = 0$. Therefore, for all terms contributing to the sum, the identity holds:\n$$ \\frac{\\partial^2}{\\partial x^2} W(|x_i-x_j|, h) = \\frac{d^2 W}{dr^2}(r, h) \\quad \\text{for } r = |x_i-x_j| \\neq 0 $$\n\nNext, we specify the kernels and their second derivatives. Let $q=r/h$ be the dimensionless distance.\n\n**1. Cubic Spline Kernel**\nThis kernel has a support radius of $2h$. The one-dimensional normalized form is:\n$$ W(r, h) = \\frac{1}{h} \\begin{cases} \\frac{2}{3} - q^2 + \\frac{1}{2}q^3  0 \\le q  1 \\\\ \\frac{1}{6}(2-q)^3  1 \\le q \\le 2 \\\\ 0  q  2 \\end{cases} $$\nIts second derivative with respect to $r$ is found via $\\frac{d^2W}{dr^2} = \\frac{1}{h^3}\\frac{d^2}{dq^2}(hW)$. This gives:\n$$ \\frac{d^2W}{dr^2} = \\frac{1}{h^3} \\begin{cases} -2 + 3q  0 \\le q  1 \\\\ 2-q  1 \\le q \\le 2 \\\\ 0  q  2 \\end{cases} $$\n\n**2. Quintic Spline Kernel**\nThis kernel offers higher-order accuracy and has a larger support radius of $3h$. The one-dimensional normalized form is:\n$$ W(r, h) = \\frac{1}{120h} \\begin{cases} (3-q)^5 - 6(2-q)^5 + 15(1-q)^5  0 \\le q  1 \\\\ (3-q)^5 - 6(2-q)^5  1 \\le q  2 \\\\ (3-q)^5  2 \\le q \\le 3 \\\\ 0  q  3 \\end{cases} $$\nIts second derivative with respect to $r$ is:\n$$ \\frac{d^2W}{dr^2} = \\frac{20}{120h^3} \\left. \\frac{d^2}{dq^2}(\\dots) \\right|_{\\text{poly}} = \\frac{1}{6h^3} \\begin{cases} (3-q)^3 - 6(2-q)^3 + 15(1-q)^3  0 \\le q  1 \\\\ (3-q)^3 - 6(2-q)^3  1 \\le q  2 \\\\ (3-q)^3  2 \\le q \\le 3 \\\\ 0  q  3 \\end{cases} $$\nThese formulae are implemented to compute the SPH approximation $\\hat{f}_i''$ for each particle position $x_i$ in the specified test cases. The domain is periodic, so distances between particles are calculated using the minimum image convention: $r_{ij} = \\min(|x_i-x_j|, L-|x_i-x_j|)$. The accuracy of each kernel is quantified by the relative root-mean-square (RMS) error $\\varepsilon$:\n$$ \\varepsilon = \\frac{\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\big(\\hat f_i'' - f_i''\\big)^2}}{\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\big(f_i''\\big)^2}} $$\nwhere $\\hat f_i''$ is the SPH approximation and $f_i''$ is the analytical value of the second derivative at $x_i$. The following program performs these calculations for the given test suite.", "answer": "```python\nimport numpy as np\n\ndef d2W_cubic_dr2(r, h):\n    \"\"\"\n    Computes the second derivative of the 1D cubic spline kernel.\n    The kernel has support 2h.\n    \"\"\"\n    q = r / h\n    factor = 1.0 / (h ** 3)\n    val = 0.0\n    if q  1.0:\n        val = -2.0 + 3.0 * q\n    elif q  2.0:\n        val = 2.0 - q\n    return factor * val\n\ndef d2W_quintic_dr2(r, h):\n    \"\"\"\n    Computes the second derivative of the 1D quintic spline kernel.\n    The kernel has support 3h.\n    \"\"\"\n    q = r / h\n    # Normalization factor for d2W/dr2 is (1/120) * 20 / h^3 = 1 / (6*h^3)\n    factor = 1.0 / (6.0 * (h ** 3))\n    val = 0.0\n    if q  1.0:\n        val = (3.0 - q)**3 - 6.0 * (2.0 - q)**3 + 15.0 * (1.0 - q)**3\n    elif q  2.0:\n        val = (3.0 - q)**3 - 6.0 * (2.0 - q)**3\n    elif q  3.0:\n        val = (3.0 - q)**3\n    return factor * val\n\ndef calculate_f_double_prime_sph(x, f_vals, L, h, kernel_d2W_dr2, support_factor):\n    \"\"\"\n    Calculates the SPH approximation of the second derivative using a\n    difference-consistent operator.\n    \"\"\"\n    N = len(x)\n    dx = L / N\n    V = dx\n    f_pp_sph = np.zeros(N)\n    \n    support_radius = support_factor * h\n\n    for i in range(N):\n        sum_val = 0.0\n        for j in range(N):\n            if i == j:\n                continue\n            \n            dist_ij = x[i] - x[j]\n            # Apply periodic boundary conditions using minimum image convention\n            dist_ij -= L * np.round(dist_ij / L)\n            r = np.abs(dist_ij)\n\n            if r  support_radius:\n                d2W = kernel_d2W_dr2(r, h)\n                sum_val += (f_vals[j] - f_vals[i]) * d2W\n        \n        f_pp_sph[i] = V * sum_val\n        \n    return f_pp_sph\n\ndef compute_relative_rms_error(approx, exact):\n    \"\"\"\n    Computes the relative root-mean-square error.\n    \"\"\"\n    numerator = np.sqrt(np.mean((approx - exact)**2))\n    denominator = np.sqrt(np.mean(exact**2))\n    if denominator == 0:\n        return 0.0 if numerator == 0 else np.inf\n    return numerator / denominator\n\ndef solve():\n    test_cases = [\n        # Case A\n        {'L': 1.0, 'N': 200, 'eta': 1.2, \n         'f': lambda x: np.sin(2 * np.pi * x),\n         'f_pp': lambda x: -(2 * np.pi)**2 * np.sin(2 * np.pi * x)},\n        # Case B\n        {'L': 1.0, 'N': 256, 'eta': 1.0, \n         'f': lambda x: np.sin(2 * np.pi * x) + 0.5 * np.sin(6 * np.pi * x),\n         'f_pp': lambda x: -(2 * np.pi)**2 * np.sin(2 * np.pi * x) - 0.5 * (6 * np.pi)**2 * np.sin(6 * np.pi * x)},\n        # Case C\n        {'L': 1.0, 'N': 64, 'eta': 0.7, \n         'f': lambda x: np.sin(2 * np.pi * x),\n         'f_pp': lambda x: -(2 * np.pi)**2 * np.sin(2 * np.pi * x)},\n        # Case D\n        {'L': 1.0, 'N': 400, 'eta': 1.0, \n         'f': lambda x, sigma=0.05: np.exp(-(x - 0.3)**2 / (2 * sigma**2)),\n         'f_pp': lambda x, sigma=0.05: np.exp(-(x - 0.3)**2 / (2 * sigma**2)) * (((x - 0.3)**2 / sigma**4) - (1 / sigma**2))}\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        L = case['L']\n        N = case['N']\n        eta = case['eta']\n        f_func = case['f']\n        f_pp_func = case['f_pp']\n        \n        dx = L / N\n        h = eta * dx\n        x = np.linspace(0, L, N, endpoint=False)\n        \n        f_vals = f_func(x)\n        f_pp_exact = f_pp_func(x)\n\n        # Cubic spline calculation\n        f_pp_cubic = calculate_f_double_prime_sph(x, f_vals, L, h, d2W_cubic_dr2, 2.0)\n        error_cubic = compute_relative_rms_error(f_pp_cubic, f_pp_exact)\n        \n        # Quintic spline calculation\n        f_pp_quintic = calculate_f_double_prime_sph(x, f_vals, L, h, d2W_quintic_dr2, 3.0)\n        error_quintic = compute_relative_rms_error(f_pp_quintic, f_pp_exact)\n        \n        is_quintic_better = error_quintic  error_cubic\n        \n        results.append([round(error_cubic, 6), round(error_quintic, 6), is_quintic_better])\n        \n    output_parts = []\n    for res_list in results:\n        part = f\"[{res_list[0]},{res_list[1]},{res_list[2]}]\"\n        output_parts.append(part)\n    final_output_string = f\"[{','.join(output_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "2439500"}, {"introduction": "Having explored kernel approximations, the next step is to build a full dynamical simulation. This practice [@problem_id:2439484] guides you through the development of a two-dimensional SPH code to model a classic astrophysical scenario: a rotating, self-gravitating gas cloud. By implementing both pressure and gravitational forces and tracking the system's total angular momentum $\\vec{L}(t)$, you will perform a crucial verification test that is fundamental to validating any physics simulation: confirming the conservation of a key physical invariant.", "problem": "You are to write a complete, runnable program that numerically evolves a two-dimensional, self-gravitating gas cloud using Smoothed Particle Hydrodynamics (SPH) in nondimensional units and analyzes the conservation of total angular momentum. Work in nondimensional units with gravitational constant $G=1$. Consider a barotropic gas with pressure given by $P(\\rho) = c_s^2 \\rho$, where $c_s$ is a constant sound speed, and treat self-gravity via Newtonian pairwise attraction with a softening length $\\epsilon$.\n\nLet there be $N$ particles in the plane with equal masses $m_i = M/N$, total mass $M=1$, positions $\\vec{r}_i(t) \\in \\mathbb{R}^2$, and velocities $\\vec{v}_i(t) \\in \\mathbb{R}^2$. The total angular momentum about the origin is\n$$\n\\vec{L}(t) = \\sum_{i=1}^{N} m_i \\, \\vec{r}_i(t) \\times \\vec{v}_i(t),\n$$\nwhere the cross product is the standard three-dimensional cross product; in two dimensions, its magnitude corresponds to the out-of-plane component. Evolve the system under the Euler momentum equation with the stated equation of state and self-gravity. Assume no external forces and no physical viscosity. Initialize the particles at $t=0$ as described in each test case below.\n\nYour task is to numerically integrate the equations of motion from $t=0$ to $t=T$ for each test case, track the magnitude $|\\vec{L}(t)|$ at discrete times including the initial and all subsequent time steps, and compute the following diagnostic for each case:\n- If $|\\vec{L}(0)|  0$, report\n$$\n\\max_{0 \\le t \\le T} \\frac{\\left|\\,|\\vec{L}(t)| - |\\vec{L}(0)|\\,\\right|}{|\\vec{L}(0)|}.\n$$\n- If $|\\vec{L}(0)| = 0$, report\n$$\n\\max_{0 \\le t \\le T} |\\vec{L}(t)|.\n$$\n\nUse the following test suite. In all cases, place particles uniformly on a circle of radius $R$ centered at the origin, at polar angles $\\theta_k = 2\\pi k/N$ for $k \\in \\{0,1,\\dots,N-1\\}$, with positions $\\vec{r}_k(0) = R(\\cos\\theta_k, \\sin\\theta_k)$. Set initial velocities to solid-body rotation with angular speed $\\Omega$ about the origin, $\\vec{v}_k(0) = \\Omega(-y_k(0), x_k(0))$.\n\nTest suite (each tuple lists $(N, R, \\Omega, c_s, h, \\epsilon, T, \\Delta t)$):\n1. $(N=32, R=1.0, \\Omega=0.5, c_s=0.05, h=0.2, \\epsilon=0.02, T=2.0, \\Delta t=0.002)$\n2. $(N=1, R=1.0, \\Omega=1.0, c_s=0.0, h=0.1, \\epsilon=0.0, T=1.0, \\Delta t=0.005)$\n3. $(N=32, R=1.0, \\Omega=0.0, c_s=0.05, h=0.2, \\epsilon=0.02, T=1.0, \\Delta t=0.002)$\n\nFor each test case, use SPH to model pressure forces and pairwise softened Newtonian gravity to model self-gravity. You must use a spherically symmetric, compactly supported smoothing kernel with smoothing length $h$ and compute densities via standard SPH density summation, and compute pressure forces using a momentum-conserving symmetric form. Gravitational softening must be implemented so that the pairwise gravitational force between particles $i$ and $j$ is proportional to $(\\vec{r}_i - \\vec{r}_j)/\\left(|\\vec{r}_i - \\vec{r}_j|^2 + \\epsilon^2\\right)^{3/2}$.\n\nYour program must produce a single line of output containing the three diagnostic values for the three test cases, in order, as a comma-separated list enclosed in square brackets. For example, the output format must be exactly like:\n[diagnostic_case1,diagnostic_case2,diagnostic_case3]\nAll quantities are nondimensional; do not include any units in the output.", "solution": "We need to evolve a two-dimensional, self-gravitating, barotropic gas without external torques and analyze angular momentum conservation. The fundamental physical principle governing angular momentum is that, for a closed system subject only to internal forces that are central and pairwise antisymmetric, the total torque is zero, yielding conservation of total angular momentum. In continuous form, for a system of particles, the time derivative of the total angular momentum is\n$$\n\\frac{d\\vec{L}}{dt} = \\sum_{i=1}^{N} \\vec{r}_i \\times m_i \\vec{a}_i.\n$$\nIf the forces are sums of pairwise internal forces $m_i \\vec{a}_i = \\sum_{j\\ne i} \\vec{F}_{ij}$ with $\\vec{F}_{ij} = -\\vec{F}_{ji}$ and each $\\vec{F}_{ij}$ parallel to $(\\vec{r}_i - \\vec{r}_j)$, then the total torque\n$$\n\\sum_{i=1}^{N} \\vec{r}_i \\times \\sum_{j\\ne i} \\vec{F}_{ij} = \\frac{1}{2} \\sum_{i\\ne j} (\\vec{r}_i - \\vec{r}_j) \\times \\vec{F}_{ij} = \\vec{0},\n$$\nbecause $(\\vec{r}_i - \\vec{r}_j)$ is parallel to $\\vec{F}_{ij}$ for central forces and their cross product is zero. Hence, in the absence of external torques and non-central forces, $\\vec{L}(t)$ is conserved exactly in the continuous system.\n\nSmoothed Particle Hydrodynamics (SPH) represents the pressure force as a sum of pairwise interactions that, in a symmetric, momentum-conserving discretization, are antisymmetric and central. The density at particle $i$ is estimated by the summation\n$$\n\\rho_i = \\sum_{j=1}^{N} m_j W(|\\vec{r}_i - \\vec{r}_j|, h),\n$$\nwhere $W$ is a spherically symmetric kernel with compact support and smoothing length $h$. The barotropic pressure is $P_i = c_s^2 \\rho_i$. A symmetric SPH representation of the pressure acceleration that respects linear and angular momentum conservation is\n$$\n\\vec{a}_i^{\\mathrm{(P)}} = - \\sum_{j=1}^{N} m_j \\left( \\frac{P_i}{\\rho_i^2} + \\frac{P_j}{\\rho_j^2} \\right) \\nabla W(|\\vec{r}_i - \\vec{r}_j|, h),\n$$\nwhere, due to spherical symmetry of $W$, $\\nabla W$ is parallel to $(\\vec{r}_i - \\vec{r}_j)$, ensuring that each pairwise contribution is central and antisymmetric. Self-gravity is modeled by Newtonian attraction with softening length $\\epsilon$:\n$$\n\\vec{a}_i^{\\mathrm{(G)}} = - G \\sum_{j\\ne i} m_j \\frac{\\vec{r}_i - \\vec{r}_j}{\\left(|\\vec{r}_i - \\vec{r}_j|^2 + \\epsilon^2\\right)^{3/2}}.\n$$\nThis is also a sum of pairwise central forces. Therefore, in exact arithmetic, the total angular momentum is conserved:\n$$\n\\frac{d\\vec{L}}{dt} = \\sum_{i=1}^{N} \\vec{r}_i \\times m_i \\left( \\vec{a}_i^{\\mathrm{(P)}} + \\vec{a}_i^{\\mathrm{(G)}} \\right) = \\vec{0}.\n$$\n\nIn a numerical simulation, discretization and time-integration errors introduce small deviations. To minimize secular drift and preserve invariants in Hamiltonian-like systems, a symplectic second-order integrator such as velocity Verlet can be used. Given positions $\\vec{r}_i^n$, velocities $\\vec{v}_i^n$, and accelerations $\\vec{a}_i^n$ at time $t_n$, velocity Verlet advances by\n$$\n\\vec{r}_i^{n+1} = \\vec{r}_i^{n} + \\vec{v}_i^{n} \\Delta t + \\frac{1}{2} \\vec{a}_i^{n} \\Delta t^2,\n$$\n$$\n\\vec{a}_i^{n+1} = \\vec{a}_i\\big(\\{\\vec{r}_j^{n+1}\\}\\big),\n$$\n$$\n\\vec{v}_i^{n+1} = \\vec{v}_i^{n} + \\frac{1}{2}\\left(\\vec{a}_i^{n} + \\vec{a}_i^{n+1}\\right) \\Delta t,\n$$\nwhere $\\vec{a}_i(\\{\\vec{r}_j\\})$ is computed from the SPH pressure and gravitational interactions at the current positions. At each discrete time, the angular momentum magnitude is\n$$\n|\\vec{L}(t_n)| = \\left| \\sum_{i=1}^{N} m_i \\, \\vec{r}_i^n \\times \\vec{v}_i^n \\right|.\n$$\n\nAlgorithmic design for the program:\n1. For each test case, initialize $N$ particles on a circle of radius $R$ with equal masses $m_i = 1/N$ at angles $\\theta_k = 2\\pi k/N$ and positions $\\vec{r}_k(0) = R(\\cos\\theta_k, \\sin\\theta_k)$. Set velocities $\\vec{v}_k(0) = \\Omega(-y_k(0), x_k(0))$, which correspond to solid-body rotation with angular speed $\\Omega$.\n2. At each time step, compute densities via SPH summation using a spherically symmetric, compact kernel. Then compute pressures $P_i = c_s^2 \\rho_i$ and the pressure accelerations via the symmetric SPH force expression. Compute gravitational accelerations using the softened Newtonian formula with $G=1$ and the given $\\epsilon$.\n3. Advance positions and velocities with the velocity Verlet scheme over $T$ with time step $\\Delta t$.\n4. Track $|\\vec{L}(t)|$ from $t=0$ through all time steps. For cases with $|\\vec{L}(0)|  0$, compute the maximum relative deviation $\\max_t \\big||\\vec{L}(t)| - |\\vec{L}(0)|\\big|/|\\vec{L}(0)|$. For cases with $|\\vec{L}(0)| = 0$, compute $\\max_t |\\vec{L}(t)|$.\n5. Output the three diagnostic values in a single line as a comma-separated list enclosed in square brackets, in the order of the test cases.\n\nExpected qualitative outcomes:\n- For the rotating, self-gravitating cloud with $N=32$, $R=1.0$, and $\\Omega=0.5$, internal SPH pressure forces and gravity are central and pairwise symmetric, so the total angular momentum should be conserved up to small integration and discretization errors; thus the maximum relative deviation should be small.\n- For the single free particle ($N=1$) with $\\Omega=1.0$, there are no internal forces, so $\\vec{a}=\\vec{0}$ and $\\vec{L}(t)$ is exactly constant; numerically, any deviation arises from floating-point arithmetic and should be extremely small.\n- For the non-rotating cloud ($\\Omega=0.0$), the initial angular momentum magnitude is zero; by symmetry and central forces, it should remain near zero, so the maximum magnitude should be small.\n\nThese computations stem directly from Newtonian mechanics, the Euler equations for a barotropic fluid, and the SPH discretization that preserves the antisymmetry and central nature of pairwise internal forces, thereby conserving angular momentum in the absence of external torques.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Numpy print options (not strictly necessary, but consistent output)\nnp.set_printoptions(precision=10, floatmode='maxprec')\n\ndef cubic_spline_W_2d(r, h):\n    \"\"\"\n    2D cubic spline (M4) kernel value W(r,h).\n    Vectorized for numpy arrays.\n    \"\"\"\n    sigma = 10.0 / (7.0 * np.pi * h * h)\n    q = r / h\n    W = np.zeros_like(r)\n    mask1 = (q = 0)  (q  1)\n    mask2 = (q = 1)  (q  2)\n    q1 = q[mask1]\n    q2 = q[mask2]\n    W[mask1] = 1 - 1.5*q1*q1 + 0.75*q1*q1*q1\n    W[mask2] = 0.25 * (2 - q2)**3\n    return sigma * W\n\ndef cubic_spline_dW_dr_2d(r, h):\n    \"\"\"\n    Derivative dW/dr for 2D cubic spline kernel.\n    Vectorized for numpy arrays.\n    \"\"\"\n    sigma = 10.0 / (7.0 * np.pi * h * h)\n    q = r / h\n    dW_dq = np.zeros_like(r)\n    mask1 = (q = 0)  (q  1)\n    mask2 = (q = 1)  (q  2)\n    q1 = q[mask1]\n    q2 = q[mask2]\n    # d/dq of 1 - 1.5 q^2 + 0.75 q^3 is -3 q + 2.25 q^2\n    dW_dq[mask1] = -3.0*q1 + 2.25*q1*q1\n    # d/dq of 0.25 (2 - q)^3 is -0.75 (2 - q)^2\n    dW_dq[mask2] = -0.75 * (2 - q2)**2\n    # dW/dr = (dW/dq) * (1/h) * sigma\n    return sigma * dW_dq / h\n\ndef compute_densities(positions, masses, h):\n    \"\"\"\n    Compute SPH densities by direct summation using the 2D cubic spline kernel.\n    positions: (N,2)\n    masses: (N,)\n    \"\"\"\n    r_i = positions[:, None, :]  # (N,1,2)\n    r_j = positions[None, :, :]  # (1,N,2)\n    dx = r_i - r_j               # (N,N,2)\n    dist = np.linalg.norm(dx, axis=2)  # (N,N)\n    W = cubic_spline_W_2d(dist, h)     # (N,N)\n    rho = W @ masses  # (N,)\n    return rho\n\ndef compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0):\n    \"\"\"\n    Compute accelerations from SPH pressure forces and softened self-gravity.\n    positions: (N,2)\n    masses: (N,)\n    \"\"\"\n    N = positions.shape[0]\n    # Density and pressure\n    rho = compute_densities(positions, masses, h)\n    P = (cs * cs) * rho\n\n    # Pairwise vectors\n    r_i = positions[:, None, :]  # (N,1,2)\n    r_j = positions[None, :, :]  # (1,N,2)\n    dx = r_i - r_j               # (N,N,2)\n    dist = np.linalg.norm(dx, axis=2)  # (N,N)\n\n    # Kernel gradient\n    dW_dr = cubic_spline_dW_dr_2d(dist, h)  # (N,N)\n    # Avoid division by zero\n    inv_r = 1.0 / (dist + 1e-16)\n    gradW = (dW_dr * inv_r)[..., None] * dx  # (N,N,2)\n\n    # Symmetric pressure force factor: (P_i/rho_i^2 + P_j/rho_j^2)\n    # Build matrices via broadcasting\n    Pi_over_rhoi2 = (P / (rho * rho + 1e-30))  # (N,)\n    Pj_over_rhoj2 = Pi_over_rhoi2              # same array, but we'll broadcast\n    term_ij = Pi_over_rhoi2[:, None] + Pj_over_rhoj2[None, :]  # (N,N)\n    # Multiply by masses of j\n    mj = masses[None, :]  # (1,N)\n    facP = term_ij * mj   # (N,N)\n\n    # Pressure acceleration\n    aP = -np.sum(facP[..., None] * gradW, axis=1)  # (N,2)\n\n    # Gravity: softened Newtonian\n    soft2 = eps_soft * eps_soft\n    inv_r3 = 1.0 / (dist*dist + soft2)**1.5  # (N,N)\n    # Exclude self-interaction\n    np.fill_diagonal(inv_r3, 0.0)\n    aG = -G * np.sum((mj[..., None] * inv_r3[..., None]) * dx, axis=1)  # (N,2)\n\n    return aP + aG\n\ndef angular_momentum_z(positions, velocities, masses):\n    \"\"\"\n    Compute total angular momentum (z-component) for 2D system: Lz = sum m (x vy - y vx)\n    \"\"\"\n    x = positions[:, 0]\n    y = positions[:, 1]\n    vx = velocities[:, 0]\n    vy = velocities[:, 1]\n    Lz = np.sum(masses * (x * vy - y * vx))\n    return Lz\n\ndef simulate_case(N, R, Omega, cs, h, eps_soft, T, dt):\n    \"\"\"\n    Simulate one test case and return the diagnostic:\n    - If |L0|  0: max_t | |L(t)| - |L0| | / |L0|\n    - If |L0| == 0: max_t |L(t)|\n    \"\"\"\n    # Initialize masses\n    M = 1.0\n    masses = np.full(N, M / N)\n    # Initialize positions on a circle\n    if N == 1:\n        thetas = np.array([0.0])\n    else:\n        thetas = 2.0 * np.pi * np.arange(N) / N\n    positions = np.column_stack([R * np.cos(thetas), R * np.sin(thetas)])\n    # Solid-body rotation velocities v = Omega * (-y, x)\n    velocities = Omega * np.column_stack([-positions[:, 1], positions[:, 0]])\n\n    # Initial acceleration\n    acc = compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0)\n\n    # Track angular momentum magnitude over time\n    L0 = angular_momentum_z(positions, velocities, masses)\n    L_mags = [abs(L0)]\n\n    steps = int(np.round(T / dt))\n    # Velocity Verlet integration\n    for _ in range(steps):\n        # r_{n+1} = r_n + v_n dt + 0.5 a_n dt^2\n        positions = positions + velocities * dt + 0.5 * acc * (dt * dt)\n        # a_{n+1}\n        acc_new = compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0)\n        # v_{n+1} = v_n + 0.5 (a_n + a_{n+1}) dt\n        velocities = velocities + 0.5 * (acc + acc_new) * dt\n        # Prepare for next step\n        acc = acc_new\n        # Record angular momentum magnitude\n        L_mags.append(abs(angular_momentum_z(positions, velocities, masses)))\n\n    L0_abs = abs(L0)\n    if L0_abs  1e-14:\n        deviations = np.abs(np.array(L_mags) - L0_abs) / L0_abs\n        diagnostic = float(np.max(deviations))\n    else:\n        diagnostic = float(np.max(L_mags))\n    return diagnostic\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, R, Omega, cs, h, eps, T, dt)\n        (32, 1.0, 0.5, 0.05, 0.2, 0.02, 2.0, 0.002),\n        (1,  1.0, 1.0, 0.0,  0.1, 0.0,  1.0, 0.005),\n        (32, 1.0, 0.0, 0.05, 0.2, 0.02, 1.0, 0.002),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, R, Omega, cs, h, eps_soft, T, dt = case\n        result = simulate_case(N, R, Omega, cs, h, eps_soft, T, dt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2439484"}, {"introduction": "Real-world physical systems often evolve across a wide range of timescales, posing a challenge for simulations with fixed time increments. This practice [@problem_id:2439517] focuses on a critical technique for efficient and stable simulation: adaptive time-stepping. You will implement a variable time-step controller that adjusts the integration step $\\Delta t$ based on three fundamental criteria—the Courant–Friedrichs–Lewy (CFL) condition, an acceleration-based limit, and a viscous diffusion limit—ensuring your simulation remains both accurate and computationally tractable.", "problem": "You are tasked with implementing a variable time-step controller for an explicit Smoothed Particle Hydrodynamics (SPH) time integrator using three fundamental stability and accuracy considerations: a Courant–Friedrichs–Lewy (CFL) condition, a force (acceleration) condition, and a viscous diffusion condition. Your solution must start from first principles consistent with explicit methods for hyperbolic and parabolic problems and classical kinematics, and derive the exact expressions you will implement for the time-step at each iteration. The scenario is one-dimensional with uniform smoothing length, and the program should integrate only the time variable while sampling prescribed maximum field magnitudes over time. All physical quantities must be treated in the International System of Units (SI), and time should always be computed and reported in seconds.\n\nStarting point for derivation: Use only the following base principles as your fundamental starting point.\n- Characteristic signal propagation in hyperbolic systems: the information travels at a characteristic speed, so a stable explicit step must be limited by a ratio of spatial resolution to maximum signal speed.\n- Kinematics under constant acceleration over a time step: the displacement under uniform acceleration must remain small relative to the spatial resolution to preserve accuracy.\n- Stability limit for explicit schemes applied to parabolic diffusion: the time-step must be bounded proportionally to the square of the spatial resolution and inversely to the kinematic viscosity.\n\nAssume the following modeling setup:\n- Smoothing length $h$ is constant and uniform.\n- The maximum signal speed is modeled as the sum of the speed of sound and a convective speed, so the instantaneous maximum signal speed is $s(t) = c + \\lvert v_{\\max}(t)\\rvert$, where $c$ is the (constant) speed of sound and $v_{\\max}(t)$ is the time-varying maximum particle speed magnitude.\n- The maximum acceleration magnitude $a_{\\max}(t)$ is time-dependent.\n- The kinematic viscosity $\\nu$ is constant and uniform.\n- Each time-step uses a safety coefficient $C_{\\mathrm{CFL}}$, $C_{\\mathrm{force}}$, and $C_{\\mathrm{visc}}$ for the three limits, respectively, each strictly between $0$ and $1$.\n\nDerive, from the above principles, explicit formulas for the three candidate time-steps at time $t$: a hyperbolic (CFL) bound in terms of $h$ and $s(t)$, a force-based bound in terms of $h$ and $a_{\\max}(t)$, and a viscous-diffusion bound in terms of $h$ and $\\nu$. Then implement an explicit time-advancement controller that, starting at $t=0$, repeatedly:\n- Evaluates the three candidate bounds at the current time $t$;\n- Chooses the minimum of the three as the next time increment $\\Delta t$ (breaking ties by selecting the first in the order CFL, then force, then viscous);\n- Records which bound is limiting at that step using the integer codes: $0$ for CFL, $1$ for force, and $2$ for viscous;\n- Advances time by $\\Delta t$;\n- Stops when $t$ reaches a specified final time $T_{\\mathrm{end}}$ (you must ensure $t$ does not exceed $T_{\\mathrm{end}}$; if necessary, truncate the last step to end exactly at $T_{\\mathrm{end}}$ but classify the limiter using the untruncated candidate bounds).\n\nHandle edge cases robustly: if $a_{\\max}(t)=0$ at any time, the force-based bound should be treated as $+\\infty$; if $\\nu=0$, the viscous bound should be treated as $+\\infty$. You may assume $cgt;0$ so the CFL bound is always finite. The evaluation of $v_{\\max}(t)$ and $a_{\\max}(t)$ is defined by smooth functions of time given below. Angles do not appear in this problem. There are no percentage quantities.\n\nFor testing and reproducibility, use the following test suite of three cases. In each case, the maximum velocity and acceleration are prescribed by\n- $v_{\\max}(t) = v_{0} + A_{v}\\left(1 - e^{-t/\\tau_{v}}\\right)$,\n- $a_{\\max}(t) = a_{0} + A_{a} e^{-t/\\tau_{a}}$,\nwith all parameters given below. Use seconds for time, meters for length, meters per second for velocity, meters per second squared for acceleration, and meters squared per second for kinematic viscosity. Safety coefficients are dimensionless.\n\nTest case 1 (general mixed regime):\n- $h = 0.01$ m, $c = 5.0$ m/s, $\\nu = 1.0\\times 10^{-6}$ m$^{2}$/s,\n- $C_{\\mathrm{CFL}} = 0.25$, $C_{\\mathrm{force}} = 0.25$, $C_{\\mathrm{visc}} = 0.125$,\n- $T_{\\mathrm{end}} = 0.10$ s,\n- $v_{0} = 0.0$ m/s, $A_{v} = 3.0$ m/s, $\\tau_{v} = 0.02$ s,\n- $a_{0} = 0.0$ m/s$^{2}$, $A_{a} = 4000.0$ m/s$^{2}$, $\\tau_{a} = 0.015$ s.\n\nTest case 2 (viscous-limited with zero acceleration):\n- $h = 0.01$ m, $c = 5.0$ m/s, $\\nu = 0.5$ m$^{2}$/s,\n- $C_{\\mathrm{CFL}} = 0.25$, $C_{\\mathrm{force}} = 0.25$, $C_{\\mathrm{visc}} = 0.125$,\n- $T_{\\mathrm{end}} = 0.05$ s,\n- $v_{0} = 0.0$ m/s, $A_{v} = 3.0$ m/s, $\\tau_{v} = 0.02$ s,\n- $a_{0} = 0.0$ m/s$^{2}$, $A_{a} = 0.0$ m/s$^{2}$, $\\tau_{a} = 0.01$ s.\n\nTest case 3 (CFL-limited with zero viscosity):\n- $h = 0.005$ m, $c = 30.0$ m/s, $\\nu = 0.0$ m$^{2}$/s,\n- $C_{\\mathrm{CFL}} = 0.30$, $C_{\\mathrm{force}} = 0.30$, $C_{\\mathrm{visc}} = 0.30$,\n- $T_{\\mathrm{end}} = 0.010$ s,\n- $v_{0} = 0.0$ m/s, $A_{v} = 1.5$ m/s, $\\tau_{v} = 0.01$ s,\n- $a_{0} = 0.0$ m/s$^{2}$, $A_{a} = 5000.0$ m/s$^{2}$, $\\tau_{a} = 0.005$ s.\n\nProgram requirements:\n- Implement the variable time-step controller exactly as described.\n- For each test case, generate the list of integer codes indicating which bound limited the time-step at each iteration from $t=0$ until $t=T_{\\mathrm{end}}$.\n- Your program should produce a single line of output containing the results for all three test cases as a comma-separated list of lists in Python literal form, for example, $\\left[\\left[\\dots\\right],\\left[\\dots\\right],\\left[\\dots\\right]\\right]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the three lists of limiter codes, enclosed in a single pair of square brackets and separated by commas, e.g., $\\left[\\left[\\ell_{1,1}, \\ell_{1,2}, \\dots\\right], \\left[\\ell_{2,1}, \\ell_{2,2}, \\dots\\right], \\left[\\ell_{3,1}, \\ell_{3,2}, \\dots\\right]\\right]$, where each $\\ell_{i,j}$ is an integer in $\\left\\{0,1,2\\right\\}$.", "solution": "The problem proposed is valid. It is scientifically grounded in the principles of numerical methods for partial differential equations, specifically for smoothed particle hydrodynamics (SPH). The problem is well-posed, objective, and provides a complete and consistent set of data and instructions for implementing a deterministic time-stepping algorithm. We shall now proceed with the derivation and solution.\n\nThe objective is to construct a variable time-step controller for an explicit SPH simulation. The time increment, $\\Delta t$, at each step is chosen as the minimum of three candidate values derived from stability and accuracy considerations: the Courant–Friedrichs–Lewy (CFL) condition, a force-based acceleration limit, and a viscous diffusion limit.\n\nLet us derive the expressions for these three time-step bounds from the provided first principles. The characteristic spatial resolution of the SPH method is given by the smoothing length, $h$.\n\n1.  **CFL (Hyperbolic) Time-Step, $\\Delta t_{\\mathrm{CFL}}$**\nThe first principle is based on the stability of explicit methods for hyperbolic systems. Information, or a physical signal, propagates at a characteristic speed. For stability, the numerical domain of dependence must contain the physical domain of dependence. In an SPH context, this means that in a single time-step $\\Delta t$, information should not propagate further than the local interaction distance, which is on the order of the smoothing length $h$. The maximum speed of signal propagation, $s(t)$, is given as the sum of the speed of sound $c$ and the magnitude of the maximum particle velocity $|v_{\\max}(t)|$.\nThe condition is expressed as:\n$$ \\Delta t \\le C_{\\mathrm{CFL}} \\frac{h}{s(t)} $$\nwhere $C_{\\mathrm{CFL}}$ is a safety coefficient, typically less than $1$. Substituting the given expression for $s(t) = c + |v_{\\max}(t)|$, we obtain the candidate time-step from the CFL condition:\n$$ \\Delta t_{\\mathrm{CFL}}(t) = C_{\\mathrm{CFL}} \\frac{h}{c + |v_{\\max}(t)|} $$\n\n2.  **Force-Based (Kinematic) Time-Step, $\\Delta t_{\\mathrm{force}}$**\nThe second principle ensures accuracy by limiting the displacement of a particle due to acceleration within a single time-step. The principle states that this displacement should be small relative to the spatial resolution $h$. The displacement of a particle under a constant acceleration $a$ over a time $\\Delta t$ is $\\frac{1}{2}a(\\Delta t)^2$. The standard SPH criterion formalizing this principle limits the time-step such that:\n$$ \\frac{1}{2} a_{\\max}(t) (\\Delta t)^2 \\le \\alpha h $$\nwhere $a_{\\max}(t)$ is the maximum magnitude of acceleration in the system and $\\alpha$ is a small dimensionless constant. Rearranging for $\\Delta t$ yields $\\Delta t \\le \\sqrt{2\\alpha h / a_{\\max}(t)}$. This is commonly written in the form:\n$$ \\Delta t \\le C_{\\mathrm{force}} \\sqrt{\\frac{h}{a_{\\max}(t)}} $$\nwhere $C_{\\mathrm{force}}$ is a user-defined safety coefficient. We will adopt this standard form as the direct implementation of the stated principle. Thus, the force-based time-step is:\n$$ \\Delta t_{\\mathrm{force}}(t) = C_{\\mathrm{force}} \\sqrt{\\frac{h}{a_{\\max}(t)}} $$\nThis expression is valid only for $a_{\\max}(t)  0$. If $a_{\\max}(t) = 0$, there is no acceleration to limit, so this condition imposes no upper bound on the time-step. In this case, we treat $\\Delta t_{\\mathrm{force}}$ as being infinitely large.\n\n3.  **Viscous Diffusion Time-Step, $\\Delta t_{\\mathrm{visc}}$**\nThe third principle comes from the stability analysis of explicit numerical schemes for parabolic diffusion equations of the form $\\partial u/\\partial t = \\nu \\nabla^2 u$, where $\\nu$ is the kinematic viscosity. For a simple forward-time, centered-space (FTCS) discretization, the stability condition is $\\Delta t \\le (\\Delta x)^2/(2\\nu)$. In SPH, the spatial resolution $\\Delta x$ is replaced by the smoothing length $h$. The generic form of this stability constraint is:\n$$ \\Delta t \\le C_{\\mathrm{visc}} \\frac{h^2}{\\nu} $$\nwhere $C_{\\mathrm{visc}}$ is a safety coefficient that accounts for the constant prefactors (like $1/2$) and other details of the specific SPH discretization of the viscous term. The problem provides this coefficient directly. Therefore, the viscous time-step is:\n$$ \\Delta t_{\\mathrm{visc}} = C_{\\mathrm{visc}} \\frac{h^2}{\\nu} $$\nNote that this time-step is constant if $\\nu$ and $h$ are constant. If $\\nu = 0$, viscosity is absent, and this constraint does not apply. We thus treat $\\Delta t_{\\mathrm{visc}}$ as being infinitely large in this case.\n\n**Time Integration Algorithm**\nThe simulation proceeds from an initial time $t=0$ to a final time $T_{\\mathrm{end}}$. At each step, starting at time $t$, the algorithm is as follows:\n1.  Evaluate the time-dependent maximum velocity and acceleration, $v_{\\max}(t)$ and $a_{\\max}(t)$, using the prescribed functions:\n    $$ v_{\\max}(t) = v_{0} + A_{v}\\left(1 - e^{-t/\\tau_{v}}\\right) $$\n    $$ a_{\\max}(t) = a_{0} + A_{a} e^{-t/\\tau_{a}} $$\n2.  Calculate the three candidate time-steps: $\\Delta t_{\\mathrm{CFL}}(t)$, $\\Delta t_{\\mathrm{force}}(t)$, and $\\Delta t_{\\mathrm{visc}}$.\n3.  Determine the limiting time-step for the current iteration:\n    $$ \\Delta t_{\\mathrm{chosen}} = \\min(\\Delta t_{\\mathrm{CFL}}, \\Delta t_{\\mathrm{force}}, \\Delta t_{\\mathrm{visc}}) $$\n4.  Identify which condition is the limiting one. We use integer codes: $0$ for CFL, $1$ for force, and $2$ for viscous. The tie-breaking rule is to select the first one in this specified order. This code is recorded for the current step.\n5.  Advance the simulation time. The time increment $\\Delta t_{\\mathrm{step}}$ is set to $\\Delta t_{\\mathrm{chosen}}$. However, to ensure the simulation ends exactly at $T_{\\mathrm{end}}$, the last step is truncated if necessary. That is, if $t + \\Delta t_{\\mathrm{chosen}} \\ge T_{\\mathrm{end}}$, the current step is the final one, and the time is advanced to $T_{\\mathrm{end}}$. Otherwise, the time is advanced by $\\Delta t_{\\mathrm{chosen}}$: $t \\leftarrow t + \\Delta t_{\\mathrm{chosen}}$. The loop continues as long as $t  T_{\\mathrm{end}}$. The limiter code for the final step is determined from the untruncated $\\Delta t_{\\mathrm{chosen}}$.\n\nThis procedure is implemented for each test case to generate a sequence of limiter codes.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a variable time-step controller for an explicit SPH simulation.\n    The controller uses CFL, force, and viscous stability criteria.\n    \"\"\"\n\n    def run_simulation(h, c, nu, C_cfl, C_force, C_visc, T_end, v0, Av, tau_v, a0, Aa, tau_a):\n        \"\"\"\n        Runs a single SPH time-stepping simulation for a given set of parameters.\n        \n        Returns a list of integer codes indicating the limiter at each step.\n        \"\"\"\n\n        # Define the time-dependent functions for maximum velocity and acceleration\n        def v_max_func(t):\n            # The problem statement defines v_max(t) which may not be a magnitude, but\n            # all test cases result in v_max(t) = 0. The CFL condition uses |v_max(t)|.\n            if tau_v  0:\n                return v0 + Av * (1.0 - np.exp(-t / tau_v))\n            return v0 + Av # Case for tau_v - 0 or t - inf\n\n        def a_max_func(t):\n            if tau_a  0:\n                return a0 + Aa * np.exp(-t / tau_a)\n            return a0 # Case for tau_a - 0 or t - inf\n\n        t = 0.0\n        limiters = []\n\n        # The loop must continue as long as the current time is less than the end time.\n        while t  T_end:\n            # 1. Evaluate maximum velocity and acceleration at the current time t\n            current_v_max = v_max_func(t)\n            current_a_max = a_max_func(t)\n\n            # 2. Calculate the three candidate time steps\n            \n            # CFL (Hyperbolic) Condition\n            # s(t) = c + |v_max(t)|\n            # c  0 is assumed, so s_t is always positive.\n            s_t = c + abs(current_v_max)\n            dt_cfl = C_cfl * h / s_t\n\n            # Force (Kinematic) Condition\n            if current_a_max  0.0:\n                dt_force = C_force * np.sqrt(h / current_a_max)\n            else:\n                dt_force = np.inf\n\n            # Viscous Diffusion Condition\n            if nu  0.0:\n                dt_visc = C_visc * h**2 / nu\n            else:\n                dt_visc = np.inf\n\n            # 3. Determine the limiting time step and its corresponding code\n            dt_candidates = [dt_cfl, dt_force, dt_visc]\n            \n            # np.argmin implements the required tie-breaking rule (first minimum is chosen)\n            limiter_code = int(np.argmin(dt_candidates))\n            dt_chosen = dt_candidates[limiter_code]\n            \n            # 4. Record the limiter code for the current step\n            limiters.append(limiter_code)\n\n            # 5. Advance the simulation time.\n            # Truncate the last step to ensure t does not exceed T_end.\n            if t + dt_chosen = T_end:\n                t = T_end\n            else:\n                t += dt_chosen\n        \n        return limiters\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general mixed regime)\n        {'h': 0.01, 'c': 5.0, 'nu': 1.0e-6, 'C_cfl': 0.25, 'C_force': 0.25, 'C_visc': 0.125, 'T_end': 0.10, 'v0': 0.0, 'Av': 3.0, 'tau_v': 0.02, 'a0': 0.0, 'Aa': 4000.0, 'tau_a': 0.015},\n        # Case 2 (viscous-limited with zero acceleration)\n        {'h': 0.01, 'c': 5.0, 'nu': 0.5, 'C_cfl': 0.25, 'C_force': 0.25, 'C_visc': 0.125, 'T_end': 0.05, 'v0': 0.0, 'Av': 3.0, 'tau_v': 0.02, 'a0': 0.0, 'Aa': 0.0, 'tau_a': 0.01},\n        # Case 3 (CFL-limited with zero viscosity)\n        {'h': 0.005, 'c': 30.0, 'nu': 0.0, 'C_cfl': 0.30, 'C_force': 0.30, 'C_visc': 0.30, 'T_end': 0.010, 'v0': 0.0, 'Av': 1.5, 'tau_v': 0.01, 'a0': 0.0, 'Aa': 5000.0, 'tau_a': 0.005},\n    ]\n\n    results = []\n    for case in test_cases:\n        limiters = run_simulation(**case)\n        results.append(limiters)\n\n    # Format the output as a compact Python literal string for a list of lists.\n    # e.g., [[1,2,3],[4],[5,6]]\n    # This construction ensures no spaces are included, matching the example format style.\n    inner_lists_str = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output = f\"[{','.join(inner_lists_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2439517"}]}