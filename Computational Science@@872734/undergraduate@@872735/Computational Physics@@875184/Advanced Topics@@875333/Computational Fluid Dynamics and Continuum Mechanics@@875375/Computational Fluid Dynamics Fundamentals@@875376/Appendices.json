{"hands_on_practices": [{"introduction": "Before tackling complex physics, a computational scientist must first master numerical stability. This practice focuses on the Courant-Friedrichs-Lewy (CFL) condition, the fundamental \"speed limit\" governing explicit time-stepping schemes. By implementing a simple finite-volume solver and intentionally running it at, below, and above its stability limit, you will gain a visceral understanding of how information propagates on a discrete grid and witness the dramatic consequences of violating the CFL condition [@problem_id:2381376].", "problem": "You will investigate numerical stability of an explicit finite-volume solver for the one-dimensional linear advection equation, using the Courant-Friedrichs-Lewy (CFL) condition as the organizing principle. Start from the conservation-law form of linear advection,\n$$\n\\frac{\\partial q}{\\partial t} + \\frac{\\partial f}{\\partial x} = 0,\\quad f = a\\,q,\n$$\nwhere $q(x,t)$ is a scalar field and $a$ is a constant advection speed. Use the following physically consistent setup: the spatial domain is periodic with length $L$ in meters, the advection speed $a$ is in meters per second, and time $t$ is in seconds. The exact solution for smooth initial data is the constant-speed translation\n$$\nq(x,t) = q_0(x - a\\,t) \\quad \\text{on the periodic domain}.\n$$\nYour tasks are:\n- From the conservation form and explicit time advance, derive a first-order upwind finite-volume method appropriate for $a \\gt 0$ on a uniform grid. Do not use any pre-derived discrete update expressions; start from the definition of the numerical flux and the finite-volume update for a cell average.\n- Using discrete Fourier (von Neumann) analysis on the derived scheme, obtain the stability restriction on the nondimensional Courant number $C$, where\n$$\nC = \\frac{|a|\\,\\Delta t}{\\Delta x}.\n$$\n- Implement the derived method with periodic boundary conditions and advance an initial condition to a prescribed final time. Use a uniform mesh with $N$ cells and $\\Delta x = L/N$, and a constant time step $\\Delta t$ chosen from a target Courant number $C$ via $\\Delta t = C\\,\\Delta x/a$. For each run, use an integer number of time steps $n_{\\text{steps}}$, so that the final time is $T = n_{\\text{steps}}\\,\\Delta t$.\n- Use the smooth, periodic Gaussian initial condition of unit amplitude centered at $x_0$ with width $\\sigma$,\n$$\nq_0(x) = \\exp\\!\\left(-\\frac{d(x,x_0)^2}{2\\,\\sigma^2}\\right),\n$$\nwhere $d(x,x_0)$ is the shortest periodic distance on the interval $[0,L)$.\n- To assess stability numerically, declare a run unstable if at any time step the absolute value of any cell average exceeds a threshold equal to $M$ times the initial maximum amplitude, where $M$ is a fixed factor. Otherwise, declare the run stable. Quantify the accuracy at the final time by the relative discrete $\\ell^2$ error with respect to the exact solution on the grid,\n$$\n\\varepsilon = \\frac{\\left\\| q^{n_{\\text{steps}}} - q_{\\text{exact}}(\\cdot,T)\\right\\|_2}{\\left\\| q_{\\text{exact}}(\\cdot,T) \\right\\|_2},\n$$\nwhere $\\|\\cdot\\|_2$ is the Euclidean norm over grid point values. For an unstable run, report a large sentinel error value $E_{\\text{sentinel}}$.\n\nImplement a program that performs exactly the following test suite, returning for each case a list containing a boolean stability flag and the error $\\varepsilon$ (or the sentinel value if unstable):\n\n- Case A (below the stability limit): $L = 1.0$ meters, $a = 1.0$ meters per second, $N = 100$, $x_0 = 0.25$ meters, $\\sigma = 0.05$ meters, $C = 0.5$, $n_{\\text{steps}} = 200$, $M = 10$, $E_{\\text{sentinel}} = 10^{9}$.\n- Case B (at the stability limit): $L = 1.0$ meters, $a = 1.0$ meters per second, $N = 100$, $x_0 = 0.25$ meters, $\\sigma = 0.05$ meters, $C = 1.0$, $n_{\\text{steps}} = 100$, $M = 10$, $E_{\\text{sentinel}} = 10^{9}$.\n- Case C (above the stability limit): $L = 1.0$ meters, $a = 1.0$ meters per second, $N = 100$, $x_0 = 0.25$ meters, $\\sigma = 0.05$ meters, $C = 1.1$, $n_{\\text{steps}} = 50$, $M = 10$, $E_{\\text{sentinel}} = 10^{9}$.\n\nAngle units are not used in this problem. Ensure that the program uses meters and seconds consistently for all dimensional inputs as stated above. The final output must be a single line containing a list of the three results, each result itself being a list of the form $[\\text{stable}, \\varepsilon]$, in the exact order A, B, C. For example, the format must be\n$$\n\\big[\\,[\\text{True},\\,0.0123],[\\text{True},\\,0.0],[\\text{False},\\,1000000000.0]\\,\\big],\n$$\nwith boolean values for stability and floating-point values for errors. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.", "solution": "The problem as stated is subjected to validation.\n\n### Step 1: Extract Givens\n\nThe governing partial differential equation is the one-dimensional linear advection equation in conservation form:\n$$\n\\frac{\\partial q}{\\partial t} + \\frac{\\partial f}{\\partial x} = 0\n$$\nwith flux $f = a\\,q$, where $a$ is a constant advection speed.\n\nThe domain is periodic with length $L$.\nThe initial condition is a smooth Gaussian profile:\n$$\nq_0(x) = \\exp\\!\\left(-\\frac{d(x,x_0)^2}{2\\,\\sigma^2}\\right)\n$$\nwhere $d(x,x_0)$ is the shortest periodic distance on $[0,L)$.\nThe exact solution for smooth initial data is $q(x,t) = q_0(x - a\\,t)$.\n\nNumerical parameters are defined as follows:\n- Number of uniform grid cells: $N$\n- Cell width: $\\Delta x = L/N$\n- Courant number: $C = \\frac{|a|\\,\\Delta t}{\\Delta x}$\n- Time step: $\\Delta t = C\\,\\Delta x/a$ (for $a0$)\n- Number of time steps: $n_{\\text{steps}}$\n- Final time: $T = n_{\\text{steps}}\\,\\Delta t$\n\nStability and accuracy metrics are:\n- Stability threshold factor: $M$\n- A run is declared unstable if $\\max(|q|)  M \\times \\max(|q_0|)$ at any time.\n- Sentinel error for unstable runs: $E_{\\text{sentinel}}$\n- Relative discrete $\\ell^2$ error: $\\varepsilon = \\frac{\\left\\| q^{n_{\\text{steps}}} - q_{\\text{exact}}(\\cdot,T)\\right\\|_2}{\\left\\| q_{\\text{exact}}(\\cdot,T) \\right\\|_2}$\n\nTest cases:\n- Case A: $L = 1.0$, $a = 1.0$, $N = 100$, $x_0 = 0.25$, $\\sigma = 0.05$, $C = 0.5$, $n_{\\text{steps}} = 200$, $M = 10$, $E_{\\text{sentinel}} = 10^{9}$.\n- Case B: $L = 1.0$, $a = 1.0$, $N = 100$, $x_0 = 0.25$, $\\sigma = 0.05$, $C = 1.0$, $n_{\\text{steps}} = 100$, $M = 10$, $E_{\\text{sentinel}} = 10^{9}$.\n- Case C: $L = 1.0$, $a = 1.0$, $N = 100$, $x_0 = 0.25$, $\\sigma = 0.05$, $C = 1.1$, $n_{\\text{steps}} = 50$, $M = 10$, $E_{\\text{sentinel}} = 10^{9}$.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded:** The problem is based on the linear advection equation, the finite-volume method, and von Neumann stability analysis. These are fundamental, well-established concepts in computational physics and applied mathematics. The problem is scientifically sound.\n- **Well-Posed:** The problem statement is clear, and all necessary parameters and conditions are provided for each case. The tasks—derivation, analysis, and implementation—are unambiguously defined, leading to a unique and meaningful result.\n- **Objective:** The problem is formulated in precise, objective language. There are no subjective or opinion-based statements.\n- **Completeness and Consistency:** The problem is self-contained. All variables and constants are defined, and the test cases are fully specified. The physical units (meters, seconds) are consistent throughout.\n\n### Step 3: Verdict and Action\n\nThe problem is valid. It is a standard, well-posed exercise in numerical methods for partial differential equations. A full solution will be provided.\n\n### Derivation of the First-Order Upwind Finite-Volume Method\n\nWe begin with the integral form of the conservation law over a control volume, or cell, $I_i = [x_{i-1/2}, x_{i+1/2}]$, where the cell center is $x_i$ and the cell width is $\\Delta x = x_{i+1/2} - x_{i-1/2}$. Integrating the PDE over this cell gives:\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial q}{\\partial t} dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial f}{\\partial x} dx = 0\n$$\nApplying Leibniz integral rule and the fundamental theorem of calculus, we obtain:\n$$\n\\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} q(x,t) dx + \\left[ f(q(x_{i+1/2},t)) - f(q(x_{i-1/2},t)) \\right] = 0\n$$\nWe define the cell average of $q$ over cell $i$ at time $t$ as:\n$$\n\\bar{q}_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} q(x,t) dx\n$$\nSubstituting this definition into the integrated equation yields an exact ordinary differential equation for the cell average $\\bar{q}_i(t)$:\n$$\n\\frac{d\\bar{q}_i}{dt} = -\\frac{1}{\\Delta x} \\left[ f(q(x_{i+1/2},t)) - f(q(x_{i-1/2},t)) \\right]\n$$\nTo obtain a numerical scheme, we discretize in time using the forward Euler method and approximate the point values of the flux $f$ at the cell interfaces. Let $\\bar{q}_i^n \\approx \\bar{q}_i(t^n)$ where $t^n = n\\Delta t$. The time derivative is approximated as $\\frac{d\\bar{q}_i}{dt} \\approx \\frac{\\bar{q}_i^{n+1} - \\bar{q}_i^n}{\\Delta t}$.\nThe interface fluxes are approximated by a numerical flux function $F$, which depends on the states of the neighboring cells at time $t^n$. The equation becomes:\n$$\n\\frac{\\bar{q}_i^{n+1} - \\bar{q}_i^n}{\\Delta t} = -\\frac{1}{\\Delta x} \\left[ F_{i+1/2} - F_{i-1/2} \\right]\n$$\nwhere $F_{i+1/2}$ is the numerical flux at the interface $x_{i+1/2}$. This can be rewritten as the finite-volume update formula:\n$$\n\\bar{q}_i^{n+1} = \\bar{q}_i^n - \\frac{\\Delta t}{\\Delta x} \\left[ F_{i+1/2} - F_{i-1/2} \\right]\n$$\nFor the first-order upwind scheme, the numerical flux is determined by the direction of information propagation, which is given by the sign of the advection speed $a$. The problem specifies $a  0$, so information propagates from left to right. The flux at an interface should be determined by the state in the \"upwind\" cell, which is the cell to the left.\nTherefore, the flux at the right interface of cell $i$, $x_{i+1/2}$, is determined by the state in cell $i$:\n$$\nF_{i+1/2} = f(\\bar{q}_i^n) = a \\bar{q}_i^n\n$$\nSimilarly, the flux at the left interface of cell $i$, $x_{i-1/2}$, is determined by the state in cell $i-1$:\n$$\nF_{i-1/2} = f(\\bar{q}_{i-1}^n) = a \\bar{q}_{i-1}^n\n$$\nSubstituting these numerical fluxes into the update formula, we obtain the first-order upwind scheme for $a  0$:\n$$\n\\bar{q}_i^{n+1} = \\bar{q}_i^n - \\frac{\\Delta t}{\\Delta x} (a \\bar{q}_i^n - a \\bar{q}_{i-1}^n)\n$$\nAs per the problem definition, we introduce the nondimensional Courant number $C = \\frac{a \\Delta t}{\\Delta x}$ (since $a0$, $|a|=a$). The final scheme is:\n$$\n\\bar{q}_i^{n+1} = \\bar{q}_i^n - C (\\bar{q}_i^n - \\bar{q}_{i-1}^n)\n$$\n\n### Von Neumann Stability Analysis\n\nTo analyze the stability of the derived scheme, we employ discrete Fourier (von Neumann) analysis. We consider a single Fourier mode for the solution on the grid:\n$$\n\\bar{q}_j^n = \\hat{q}^n e^{i k x_j} = \\hat{q}^n e^{i k j \\Delta x}\n$$\nwhere $\\hat{q}^n$ is the complex amplitude of the mode at time step $n$, $k$ is the wavenumber, and $i = \\sqrt{-1}$. Substituting this ansatz into the numerical scheme:\n$$\n\\hat{q}^{n+1} e^{i k j \\Delta x} = \\hat{q}^n e^{i k j \\Delta x} - C \\left( \\hat{q}^n e^{i k j \\Delta x} - \\hat{q}^n e^{i k (j-1) \\Delta x} \\right)\n$$\nWe define the amplification factor $G(k) = \\frac{\\hat{q}^{n+1}}{\\hat{q}^n}$. Dividing the equation by $\\hat{q}^n e^{i k j \\Delta x}$ yields:\n$$\nG(k) = 1 - C \\left( 1 - e^{-i k \\Delta x} \\right)\n$$\nLet $\\theta = k \\Delta x$ be the nondimensional wavenumber. The amplification factor is a function of $\\theta$:\n$$\nG(\\theta) = 1 - C (1 - e^{-i\\theta}) = 1 - C (1 - (\\cos\\theta - i\\sin\\theta)) = (1 - C + C\\cos\\theta) + i(C\\sin\\theta)\n$$\nFor the scheme to be stable, the magnitude of the amplification factor must not exceed unity for all possible values of $\\theta$, i.e., $|G(\\theta)| \\le 1$. We analyze its magnitude squared:\n$$\n|G(\\theta)|^2 = (1 - C + C\\cos\\theta)^2 + (C\\sin\\theta)^2\n$$\n$$\n|G(\\theta)|^2 = (1-C)^2 + 2C(1-C)\\cos\\theta + C^2\\cos^2\\theta + C^2\\sin^2\\theta\n$$\n$$\n|G(\\theta)|^2 = 1 - 2C + C^2 + 2C(1-C)\\cos\\theta + C^2 = 1 - 2C + 2C^2 + (2C-2C^2)\\cos\\theta\n$$\n$$\n|G(\\theta)|^2 = 1 - 2C(1-C) + 2C(1-C)\\cos\\theta = 1 - 2C(1-C)(1-\\cos\\theta)\n$$\nThe stability condition $|G(\\theta)|^2 \\le 1$ implies:\n$$\n1 - 2C(1-C)(1-\\cos\\theta) \\le 1 \\implies -2C(1-C)(1-\\cos\\theta) \\le 0\n$$\nSince $\\theta$ is real, the term $(1-\\cos\\theta)$ is always non-negative, ranging from $0$ to $2$. Thus, stability requires:\n$$\nC(1-C) \\ge 0\n$$\nGiven that the Courant number $C = \\frac{a \\Delta t}{\\Delta x}$ is non-negative (as $a0, \\Delta t0, \\Delta x0$), this inequality is satisfied for:\n$$\n0 \\le C \\le 1\n$$\nThis is the Courant-Friedrichs-Lewy (CFL) stability condition for the first-order upwind scheme.\n\n### Numerical Implementation Strategy\n\nThe derived scheme is implemented on a uniform periodic grid.\n1.  **Grid and Parameters**: For a domain of length $L$ with $N$ cells, the cell width is $\\Delta x = L/N$. The grid points representing cell centers are $x_j = j \\Delta x$ for $j=0, 1, \\dots, N-1$.\n2.  **Initial Condition**: The initial state vector $q^0$ is populated with values $q_j^0 = q_0(x_j)$. The periodic distance function $d(x_1, x_2)$ on a domain of length $L$ is computed as $d(x_1, x_2) = \\min(|x_1-x_2|, L - |x_1-x_2|)$. The initial maximum amplitude is $\\max(|q_0|) = 1$ by construction.\n3.  **Time Stepping**: The time step $\\Delta t$ is calculated from the specified Courant number $C$ as $\\Delta t = C \\Delta x / a$. The simulation runs for a fixed number of steps, $n_{\\text{steps}}$.\n4.  **Update Step**: The update equation $\\bar{q}_i^{n+1} = \\bar{q}_i^n - C (\\bar{q}_i^n - \\bar{q}_{i-1}^n)$ is applied to all cells $i=0, \\dots, N-1$. The term $\\bar{q}_{i-1}^n$ for cell $i=0$ is $\\bar{q}_{N-1}^n$ due to periodic boundary conditions. This is efficiently implemented using a circular shift (`numpy.roll`).\n5.  **Stability Check**: At each time step $n$, before the update, the condition $\\max(|\\bar{q}^n|) \\le M \\times 1.0$ is checked. If violated, the run is flagged as unstable, and the simulation for that case terminates.\n6.  **Error Calculation**: If the simulation completes all $n_{\\text{steps}}$ without violating the stability criterion, it is flagged as stable. The final numerical solution is $q^{n_{\\text{steps}}}$. The exact solution at the final time $T=n_{\\text{steps}}\\Delta t$ is $q_{exact}(x,T) = q_0(x-aT)$. This is computed by evaluating the initial profile at grid points shifted by $-aT$. The final center of the Gaussian is $x_{0,final} = (x_0 + aT) \\pmod L$. The exact solution on the grid is then $q_{exact,j} = \\exp(-d(x_j, x_{0,final})^2 / (2\\sigma^2))$. The relative $\\ell^2$ error $\\varepsilon$ is then computed. For unstable runs, $\\varepsilon$ is set to $E_{\\text{sentinel}}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection problem for three test cases\n    to investigate numerical stability of the first-order upwind scheme.\n    \"\"\"\n    \n    test_cases = [\n        # Case A: C = 0.5 (stable)\n        {'L': 1.0, 'a': 1.0, 'N': 100, 'x0': 0.25, 'sigma': 0.05, \n         'C': 0.5, 'n_steps': 200, 'M': 10, 'E_sentinel': 1e9},\n        # Case B: C = 1.0 (marginally stable, exact shift)\n        {'L': 1.0, 'a': 1.0, 'N': 100, 'x0': 0.25, 'sigma': 0.05, \n         'C': 1.0, 'n_steps': 100, 'M': 10, 'E_sentinel': 1e9},\n        # Case C: C = 1.1 (unstable)\n        {'L': 1.0, 'a': 1.0, 'N': 100, 'x0': 0.25, 'sigma': 0.05, \n         'C': 1.1, 'n_steps': 50, 'M': 10, 'E_sentinel': 1e9},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack parameters\n        L = case['L']\n        a = case['a']\n        N = case['N']\n        x0 = case['x0']\n        sigma = case['sigma']\n        C = case['C']\n        n_steps = case['n_steps']\n        M = case['M']\n        E_sentinel = case['E_sentinel']\n\n        # Grid setup\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False) # Grid points for cell centers\n\n        # Time step calculation\n        dt = C * dx / a\n        T_final = n_steps * dt\n\n        # Helper for periodic distance\n        def periodic_distance(x1, x2, domain_length):\n            diff = np.abs(x1 - x2)\n            return np.minimum(diff, domain_length - diff)\n\n        # Initial condition\n        q = np.exp(-periodic_distance(x, x0, L)**2 / (2 * sigma**2))\n        \n        # Initial maximum amplitude is 1.0 by definition of the Gaussian\n        initial_max_q = 1.0\n        stability_threshold = M * initial_max_q\n\n        is_stable = True\n        # Time-stepping loop\n        for _ in range(n_steps):\n            if np.max(np.abs(q))  stability_threshold:\n                is_stable = False\n                break\n            \n            # Copy of current state for the update\n            q_n = q.copy()\n            \n            # First-order upwind scheme (for a  0)\n            # q_i^{n+1} = q_i^n - C * (q_i^n - q_{i-1}^n)\n            # np.roll(q_n, 1) provides q_{i-1} with periodic boundaries\n            q = q_n - C * (q_n - np.roll(q_n, 1))\n\n        # Final error calculation\n        if not is_stable:\n             # Check one last time after the final step for cases that blow up on the last step\n            if np.max(np.abs(q))  stability_threshold:\n                 error = E_sentinel\n            else: # Should not happen if loop broke, but as a safeguard\n                is_stable = True # If it did not actually exceed threshold\n\n        if is_stable:\n            # Exact solution at T_final\n            x_center_final = (x0 + a * T_final) % L\n            q_exact = np.exp(-periodic_distance(x, x_center_final, L)**2 / (2 * sigma**2))\n            \n            # Calculate relative L2 error\n            norm_diff = np.linalg.norm(q - q_exact)\n            norm_exact = np.linalg.norm(q_exact)\n            \n            if norm_exact  0:\n                error = norm_diff / norm_exact\n            else:\n                error = norm_diff # Should not happen for a Gaussian\n        else:\n            error = E_sentinel\n\n        results.append([is_stable, error])\n\n    # Final print statement in the exact required format\n    # The default str representation of a list in Python is '[item1, item2, ...]'\n    # which matches the required format including the space after the comma.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2381376"}, {"introduction": "Building on the principles of stability, this exercise advances to a nonlinear model that captures the essence of shock waves and diffusion. You will implement a solver for the viscous Burgers' equation, $u_t + u u_x = \\nu u_{xx}$, a canonical PDE that models the competition between nonlinear wave steepening and viscous smoothing. This practice will develop your skills in applying different discretization strategies for different physical terms—namely, an upwind scheme for the convective term and a central difference for the diffusive term—while managing a stability condition that accounts for both phenomena [@problem_id:2381332].", "problem": "Consider the viscous one-dimensional Burgers' equation, a canonical model for convection-diffusion dynamics in computational fluid dynamics fundamentals within computational physics:\n$$\nu_t + u\\,u_x = \\nu\\,u_{xx},\n$$\nposed on a finite one-dimensional domain with fixed boundary states. Start from the conservation-law viewpoint that balances a nonlinear convective flux with Fickian diffusion, and derive a stable semi-discrete method based on first principles: the rate of change of a field equals the negative divergence of its advective flux plus the diffusion term. Use this to design a fully discrete algorithm that approximates the time evolution of a shock-like initial profile and demonstrates how viscosity $\\,\\nu\\,$ smooths steep gradients.\n\nYour task is to write a complete, runnable program that:\n- Discretizes space uniformly on a domain $\\,x \\in [-L/2,\\,L/2]\\,$ with $\\,L = 2\\,$ using $\\,N_x\\,$ grid points with spacing $\\,\\Delta x\\,$.\n- Enforces fixed Dirichlet boundary conditions $\\,u(-L/2,t)=+1\\,$ and $\\,u(+L/2,t)=-1\\,$ for all $\\,t$.\n- Uses the smooth shock-like initial condition\n$$\nu(x,0) = -\\tanh\\!\\left(\\frac{x}{\\delta}\\right),\n$$\nwith $\\,\\delta  0\\,$ controlling the initial thickness.\n- Advances in time to a specified final time $\\,T\\,$ using an explicit method. Choose a time step $\\,\\Delta t\\,$ at each step to satisfy a stability restriction that accounts for both convection and diffusion. Specifically, enforce\n$$\n\\Delta t \\le C \\,\\min\\!\\left(\\frac{\\Delta x}{\\max_x |u|},\\,\\frac{\\Delta x^2}{2\\nu}\\right),\n$$\nwhere $\\,C \\in (0,1)\\,$ is a Courant–Friedrichs–Lewy (CFL) safety factor.\n- Approximates the convective derivative $\\,u\\,u_x\\,$ with a monotone, first-order upwind difference based on the local sign of $\\,u\\,$, and approximates the diffusive term $\\,u_{xx}\\,$ with a centered second-order difference, both applied to interior points. Keep boundary values fixed at each time level.\n\nFor each test case, after evolving to time $\\,T\\,$, compute the single scalar diagnostic\n$$\nG(T) = \\max_{x \\,\\text{on grid interior}} \\left| \\frac{\\partial u}{\\partial x}(x,T) \\right|,\n$$\napproximating the spatial derivative on interior points using a centered difference. Report $\\,G(T)\\,$ as a floating-point number rounded to $\\,6\\,$ decimal places. Larger $\\,G(T)\\,$ indicates a steeper profile; smaller $\\,G(T)\\,$ indicates stronger smoothing.\n\nAll quantities are dimensionless, so no physical units are required.\n\nImplement your solver to handle the following test suite of parameters, each specified as a tuple $\\,( \\nu,\\, T,\\, N_x,\\, \\delta,\\, C )\\,$:\n- Case $1$: $\\,(0.01,\\,0.2,\\,401,\\,0.05,\\,0.4)$\n- Case $2$: $\\,(0.001,\\,0.2,\\,401,\\,0.05,\\,0.4)$\n- Case $3$: $\\,(0.05,\\,0.2,\\,401,\\,0.05,\\,0.4)$\n- Case $4$ (edge case, no evolution): $\\,(0.01,\\,0.0,\\,401,\\,0.05,\\,0.4)$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where $\\,r_k = G(T)\\,$ for case $\\,k\\,$, each rounded to $\\,6\\,$ decimal places.", "solution": "The problem statement is scientifically sound and well-posed. It presents a standard problem in computational fluid dynamics: the numerical solution of the one-dimensional viscous Burgers' equation. All parameters, conditions, and numerical schemes are clearly defined, permitting a unique and verifiable solution. We proceed with the derivation and implementation of the specified algorithm.\n\nThe problem requires solving the viscous Burgers' equation,\n$$\n\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n$$\non a domain $x \\in [-L/2, L/2]$ with $L=2$. This equation is a fundamental model for phenomena where both nonlinear convection and viscous diffusion are present.\n\nThe governing equation can be interpreted from first principles, as requested. In one dimension, the conservation law for a quantity $u$ with flux $J$ is $\\frac{\\partial u}{\\partial t} + \\frac{\\partial J}{\\partial x} = 0$. The total flux $J$ is composed of an advective part and a diffusive part. The advective flux is given by the flow of the quantity with itself, which is described by the flux function $F(u) = \\frac{1}{2}u^2$. The diffusive flux is modeled by Fick's law, $q = -\\nu \\frac{\\partial u}{\\partial x}$. The total flux is thus $J = F(u) + q = \\frac{1}{2}u^2 - \\nu \\frac{\\partial u}{\\partial x}$. Substituting this into the conservation law gives\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x} \\left( \\frac{1}{2}u^2 - \\nu \\frac{\\partial u}{\\partial x} \\right) = 0\n$$\nApplying the chain rule, $\\frac{\\partial}{\\partial x}(\\frac{1}{2}u^2) = u \\frac{\\partial u}{\\partial x}$, and assuming viscosity $\\nu$ is constant, we recover the original form of the equation: $\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}$. This confirms the problem statement's basis in conservation principles. The term $u_t$ is the rate of change, $-u u_x$ is the negative divergence of the advective flux, and $\\nu u_{xx}$ is the diffusion term.\n\nWe develop a numerical solution using a finite difference method. The domain is discretized into $N_x$ equally spaced points $x_j = -L/2 + j \\cdot \\Delta x$ for $j=0, 1, \\dots, N_x-1$, with grid spacing $\\Delta x = L/(N_x-1)$. Let $u_j^n$ denote the numerical approximation of $u(x_j, t_n)$.\n\nThe semi-discrete form of the equation for an interior grid point $j$ is\n$$\n\\frac{d u_j}{d t} = - \\left(u \\frac{\\partial u}{\\partial x}\\right)_j + \\nu \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_j\n$$\n\nThe spatial derivatives are approximated as specified:\n1.  **Convective Term**: A first-order upwind scheme is used for the term $u \\frac{\\partial u}{\\partial x}$. The choice of difference stencil depends on the sign of the local velocity $u_j$. If $u_j  0$, information propagates from left to right, so a backward difference is used. If $u_j  0$, information propagates from right to left, requiring a forward difference.\n    $$\n    \\left(u \\frac{\\partial u}{\\partial x}\\right)_j \\approx\n    \\begin{cases}\n    u_j \\frac{u_j - u_{j-1}}{\\Delta x}  \\text{if } u_j  0 \\\\\n    u_j \\frac{u_{j+1} - u_j}{\\Delta x}  \\text{if } u_j \\le 0\n    \\end{cases}\n    $$\n    This scheme introduces numerical diffusion, which helps stabilize the solution in the presence of sharp gradients (shocks), making it a monotone scheme.\n\n2.  **Diffusive Term**: A second-order central difference is used for the viscous term $\\frac{\\partial^2 u}{\\partial x^2}$.\n    $$\n    \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_j \\approx \\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}\n    $$\n\nCombining these, the semi-discrete equation for interior points ($j=1, \\dots, N_x-2$) becomes:\n$$\n\\frac{d u_j}{d t} = -\\left( \\begin{cases} u_j \\frac{u_j - u_{j-1}}{\\Delta x}  \\text{if } u_j  0 \\\\ u_j \\frac{u_{j+1} - u_j}{\\Delta x}  \\text{if } u_j \\le 0 \\end{cases} \\right) + \\nu \\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}\n$$\n\nFor time integration, an explicit forward Euler method is employed. The solution at time step $n+1$ is calculated from the solution at step $n$:\n$$\nu_j^{n+1} = u_j^n + \\Delta t_n \\cdot \\left(\\frac{du_j}{dt}\\right)^n\n$$\nwhere $\\Delta t_n$ is the time step size at step $n$. The stability of this explicit scheme is contingent on the time step satisfying the Courant–Friedrichs–Lewy (CFL) condition. For a convection-diffusion equation, the condition combines constraints from both phenomena:\n$$\n\\Delta t_n \\le C \\cdot \\min\\left(\\frac{\\Delta x}{\\max_j |u_j^n|}, \\frac{\\Delta x^2}{2\\nu}\\right)\n$$\nwhere $C$ is a safety factor $(0  C  1)$. The first term in the minimum is the convective constraint, and the second is the diffusive constraint. An adaptive time step is calculated at each iteration to ensure stability.\n\nThe initial condition is a smooth shock-like profile:\n$$\nu(x,0) = -\\tanh(x/\\delta)\n$$\nThis is applied to the grid such that $u_j^0 = -\\tanh(x_j/\\delta)$. The boundary conditions are fixed (Dirichlet) for all time: $u(x_0, t) = u(-1, t) = +1$ and $u(x_{N_x-1}, t) = u(1, t) = -1$. In the discrete algorithm, these are enforced by setting $u_0^{n+1}=+1$ and $u_{N_x-1}^{n+1}=-1$ at every time level.\n\nThe overall algorithm proceeds as follows:\n1.  Initialize the solution vector $u^0$ from the initial condition. Enforce boundary values.\n2.  Set current time $t=0$.\n3.  Loop while $t  T$:\n    a. Calculate the maximum absolute velocity $\\max|u^n|$.\n    b. Compute the stable time step $\\Delta t_n$ using the CFL condition. Ensure $t + \\Delta t_n$ does not exceed $T$.\n    c. For all interior points $j=1, \\dots, N_x-2$, compute the right-hand side of the semi-discrete equation.\n    d. Update the interior points using the forward Euler step: $u_j^{n+1} = u_j^n + \\Delta t_n \\cdot (\\text{RHS})_j^n$.\n    e. The boundary values $u_0^{n+1}$ and $u_{N_x-1}^{n+1}$ remain fixed.\n    f. Advance time: $t \\leftarrow t + \\Delta t_n$.\n4.  Once $t=T$, the simulation is complete.\n\nFinally, the diagnostic metric $G(T)$ is computed. It is defined as the maximum absolute value of the spatial gradient on the grid interior at the final time $T$:\n$$\nG(T) = \\max_{j \\in \\{1, \\dots, N_x-2\\}} \\left| \\left(\\frac{\\partial u}{\\partial x}\\right)_j \\right|\n$$\nThe gradient is approximated using a second-order centered difference:\n$$\n\\left(\\frac{\\partial u}{\\partial x}\\right)_j \\approx \\frac{u_{j+1} - u_{j-1}}{2\\Delta x}\n$$\nThis metric quantifies the steepness of the profile, with larger values indicating a sharper \"shock.\"", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_burgers(nu, T, Nx, delta, C_cfl):\n    \"\"\"\n    Solves the 1D viscous Burgers' equation using a finite difference method.\n\n    Args:\n        nu (float): Viscosity coefficient.\n        T (float): Final time.\n        Nx (int): Number of grid points.\n        delta (float): Initial shock profile thickness parameter.\n        C_cfl (float): CFL safety factor.\n\n    Returns:\n        float: The diagnostic G(T) rounded to 6 decimal places.\n    \"\"\"\n    # 1. Setup the spatial grid and initial condition\n    L = 2.0\n    x = np.linspace(-L / 2.0, L / 2.0, Nx)\n    dx = L / (Nx - 1)\n\n    # Initial condition: u(x, 0) = -tanh(x / delta)\n    u = -np.tanh(x / delta)\n\n    # 2. Time evolution loop\n    t = 0.0\n    # The loop condition handles the T=0 case naturally.\n    while t  T:\n        # Enforce fixed Dirichlet boundary conditions at each step.\n        u[0] = 1.0\n        u[-1] = -1.0\n\n        # Calculate the adaptive time step based on the CFL condition.\n        umax = np.max(np.abs(u))\n        \n        # Convective time step constraint. Handle umax=0 to avoid division by zero.\n        if umax  1e-12:\n            dt_conv = dx / umax\n        else:\n            dt_conv = float('inf')\n\n        # Diffusive time step constraint.\n        dt_diff = dx**2 / (2.0 * nu)\n        \n        # Determine the time step, ensuring not to step over the final time T.\n        dt = C_cfl * min(dt_conv, dt_diff)\n        if t + dt  T:\n            dt = T - t\n\n        # Store the current state to compute the RHS of the PDE.\n        u_old = u.copy()\n        \n        # Isolate interior points for vectorization.\n        u_interior = u_old[1:-1]\n\n        # Calculate convective term using first-order upwind scheme.\n        # This is vectorized for efficiency.\n        grad_fwd = (u_old[2:] - u_old[1:-1]) / dx\n        grad_bwd = (u_old[1:-1] - u_old[0:-2]) / dx\n        \n        # np.where selects the appropriate difference based on the sign of u.\n        convection_term = np.where(u_interior  0, u_interior * grad_bwd, u_interior * grad_fwd)\n\n        # Calculate diffusive term using second-order central difference.\n        diffusion_term = nu * (u_old[2:] - 2 * u_old[1:-1] + u_old[0:-2]) / (dx**2)\n        \n        # Update the solution for interior points using forward Euler.\n        u[1:-1] = u_interior + dt * (-convection_term + diffusion_term)\n\n        # Advance time.\n        t += dt\n\n    # 3. Post-processing: Compute the diagnostic G(T).\n    # The gradient is computed on interior points using a centered difference.\n    du_dx_interior = (u[2:] - u[0:-2]) / (2.0 * dx)\n    \n    # G(T) is the max absolute value of this gradient.\n    G_T = np.max(np.abs(du_dx_interior))\n\n    return round(G_T, 6)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.01, 0.2, 401, 0.05, 0.4),   # Case 1\n        (0.001, 0.2, 401, 0.05, 0.4),  # Case 2\n        (0.05, 0.2, 401, 0.05, 0.4),   # Case 3\n        (0.01, 0.0, 401, 0.05, 0.4),   # Case 4 (edge case)\n    ]\n\n    results = []\n    for case in test_cases:\n        nu, T, Nx, delta, C_cfl = case\n        result = solve_burgers(nu, T, Nx, delta, C_cfl)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2381332"}, {"introduction": "In computational fluid dynamics, numerical errors are not always merely inaccuracies; they can have a physical interpretation. This advanced practice explores how the truncation error of a low-order scheme, which manifests as numerical dissipation, can be viewed as an implicit model for unresolved physics, akin to subgrid-scale (SGS) models in Large Eddy Simulation (LES). By quantifying the dissipative effects of a first-order upwind scheme and comparing them directly to an explicit Smagorinsky SGS model, you will uncover the profound dual role that numerical error can play in a simulation [@problem_id:2447860].", "problem": "You are asked to quantify and compare the instantaneous kinetic energy dissipation due to implicit numerical diffusion from a first-order upwind scheme and due to an explicit Smagorinsky subgrid-scale model in a one-dimensional, periodic, under-resolved setting. Work entirely in the one-dimensional periodic domain and use the definitions stated below. All angles are to be interpreted in radians. All outputs involving physical quantities must be reported in the International System of Units (SI).\n\nConsider a scalar field $u(x,t)$ as a surrogate for a velocity component evolving on a periodic domain $x \\in [0,L)$ with $L0$. Let the uniform grid have $N$ points with spacing $\\Delta x = L/N$ and periodic indexing. Define nodal locations $x_i = i\\,\\Delta x$ for $i \\in \\{0,1,\\dots,N-1\\}$, and the initial field\n$$\nu_i = u(x_i,0) = U_0 \\,\\sin\\!\\left(\\frac{2\\pi m}{L}\\,x_i\\right),\n$$\nwhere $U_00$ is an amplitude and $m \\in \\mathbb{Z}^+$ is the number of wavelengths in the domain. The uniform advection speed $a \\ge 0$ is constant. The Smagorinsky constant $C_s0$ is dimensionless, and the filter width is taken as $\\Delta=\\Delta x$.\n\nDefine the discrete kinetic energy per unit mass per unit length as\n$$\nE = \\frac{1}{2L}\\sum_{i=0}^{N-1} u_i^2\\,\\Delta x,\n$$\nand define the instantaneous kinetic energy dissipation rate per unit mass per unit length as\n$$\nD = -\\frac{\\mathrm{d}E}{\\mathrm{d}t}.\n$$\n\nYou must compute $D$ at $t=0$ for the following two semi-discrete models on the same grid, using periodic indexing:\n\n1) First-order upwind advection (constant speed $a \\ge 0$):\n$$\n\\frac{\\mathrm{d}u_i}{\\mathrm{d}t} = -\\,a\\,\\frac{u_i - u_{i-1}}{\\Delta x}.\n$$\n\n2) Central advection with explicit Smagorinsky subgrid-scale viscosity:\n$$\n\\frac{\\mathrm{d}u_i}{\\mathrm{d}t} = -\\,a\\,\\frac{u_{i+1}-u_{i-1}}{2\\,\\Delta x} \\;+\\; \\left[\\frac{\\partial}{\\partial x}\\left(\\nu_{t}\\,\\frac{\\partial u}{\\partial x}\\right)\\right]_i,\n$$\nwhere the discrete gradient is\n$$\n\\left(\\frac{\\partial u}{\\partial x}\\right)_i \\equiv g_i = \\frac{u_{i+1}-u_{i-1}}{2\\,\\Delta x},\n$$\nthe Smagorinsky eddy viscosity is\n$$\n\\nu_{t,i} = \\left(C_s\\,\\Delta x\\right)^2\\,|g_i|,\n$$\nand the discrete divergence of the viscous flux uses the central difference\n$$\n\\left[\\frac{\\partial}{\\partial x}\\left(\\nu_{t}\\,\\frac{\\partial u}{\\partial x}\\right)\\right]_i = \\frac{(\\nu_t g)_{i+1} - (\\nu_t g)_{i-1}}{2\\,\\Delta x}.\n$$\n\nFor each model, compute $D$ at $t=0$ directly from the semi-discrete right-hand side via\n$$\n\\frac{\\mathrm{d}E}{\\mathrm{d}t} = \\frac{1}{L}\\sum_{i=0}^{N-1} u_i \\left(\\frac{\\mathrm{d}u_i}{\\mathrm{d}t}\\right)\\Delta x,\n$$\nand then $D=-\\mathrm{d}E/\\mathrm{d}t$. Report the following for each test case:\n- $D_{\\text{up}}$ for the upwind model in $\\mathrm{m}^2/\\mathrm{s}^3$, rounded to six decimal places.\n- $D_{\\text{sgs}}$ for the Smagorinsky model in $\\mathrm{m}^2/\\mathrm{s}^3$, rounded to six decimal places.\n- The dimensionless ratio $R = D_{\\text{up}}/D_{\\text{sgs}}$, rounded to six decimal places.\n\nUse the following test suite, which is designed to probe a typical case, a more severely under-resolved case, and an edge case with zero advection speed:\n- Case A (general under-resolved): $L = 2\\pi\\,\\mathrm{m}$, $N=16$, $m=3$, $U_0 = 1.0\\,\\mathrm{m/s}$, $a=1.0\\,\\mathrm{m/s}$, $C_s=0.17$.\n- Case B (more severe under-resolution): $L = 2\\pi\\,\\mathrm{m}$, $N=12$, $m=3$, $U_0 = 1.0\\,\\mathrm{m/s}$, $a=1.0\\,\\mathrm{m/s}$, $C_s=0.17$.\n- Case C (edge case for implicit dissipation): $L = 2\\pi\\,\\mathrm{m}$, $N=16$, $m=3$, $U_0 = 1.0\\,\\mathrm{m/s}$, $a=0.0\\,\\mathrm{m/s}$, $C_s=0.17$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a three-element list for a test case in the order $\\left[D_{\\text{up}},D_{\\text{sgs}},R\\right]$. For example:\n\"[ [D_up_A,D_sgs_A,R_A], [D_up_B,D_sgs_B,R_B], [D_up_C,D_sgs_C,R_C] ]\"\nAll $D_{\\text{up}}$ and $D_{\\text{sgs}}$ values must be in $\\mathrm{m}^2/\\mathrm{s}^3$, and $R$ must be dimensionless. Each numeric value must be rounded to six decimal places and expressed as a decimal number.", "solution": "The problem as stated is valid. It is scientifically grounded in the principles of computational fluid dynamics, specifically the analysis of numerical schemes and turbulence modeling. It is well-posed, with all necessary parameters and equations provided for a unique solution. The language is objective and the requirements are unambiguous. We will proceed with a full solution.\n\nThe objective is to quantify and compare the instantaneous kinetic energy dissipation rate for two different semi-discrete models of a one-dimensional advection problem at time $t=0$. The analysis is performed on a periodic domain $x \\in [0, L)$ discretized by $N$ uniformly spaced points.\n\nFirst, we establish the fundamental definitions. The discrete kinetic energy per unit mass per unit length is given by:\n$$\nE = \\frac{1}{2L}\\sum_{i=0}^{N-1} u_i^2\\,\\Delta x\n$$\nwhere $u_i$ is the scalar field at grid point $i$ and $\\Delta x = L/N$. The instantaneous kinetic energy dissipation rate per unit mass per unit length, $D$, is defined as the negative time derivative of $E$:\n$$\nD = -\\frac{\\mathrm{d}E}{\\mathrm{d}t}\n$$\nBy applying the time derivative to the expression for $E$, we obtain a formula for its rate of change based on the semi-discrete evolution equation for $u_i$:\n$$\n\\frac{\\mathrm{d}E}{\\mathrm{d}t} = \\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(\\frac{1}{2L}\\sum_{i=0}^{N-1} u_i^2\\,\\Delta x\\right) = \\frac{\\Delta x}{2L}\\sum_{i=0}^{N-1} 2u_i\\frac{\\mathrm{d}u_i}{\\mathrm{d}t} = \\frac{1}{N}\\sum_{i=0}^{N-1} u_i\\frac{\\mathrm{d}u_i}{\\mathrm{d}t}\n$$\nThus, the dissipation rate to be computed is:\n$$\nD = -\\frac{1}{N}\\sum_{i=0}^{N-1} u_i \\left(\\frac{\\mathrm{d}u_i}{\\mathrm{d}t}\\right)_i\n$$\nThe initial condition is a single sinusoidal mode:\n$$\nu_i(0) = U_0 \\,\\sin\\!\\left(\\frac{2\\pi m}{L}\\,x_i\\right)\n$$\nWe will now analyze each model separately.\n\n**Model 1: First-Order Upwind Advection**\n\nThe semi-discrete equation for the first-order upwind scheme with constant advection speed $a \\ge 0$ is:\n$$\n\\frac{\\mathrm{d}u_i}{\\mathrm{d}t} = -a\\,\\frac{u_i - u_{i-1}}{\\Delta x}\n$$\nSubstituting this into the expression for the dissipation rate, we find the dissipation for the upwind scheme, $D_{\\text{up}}$:\n$$\nD_{\\text{up}} = -\\frac{1}{N}\\sum_{i=0}^{N-1} u_i \\left( -a\\,\\frac{u_i - u_{i-1}}{\\Delta x} \\right) = \\frac{a}{N\\Delta x}\\sum_{i=0}^{N-1} u_i(u_i - u_{i-1})\n$$\nUsing $\\Delta x = L/N$, this simplifies to:\n$$\nD_{\\text{up}} = \\frac{a}{L}\\sum_{i=0}^{N-1} (u_i^2 - u_i u_{i-1})\n$$\nThis formula shows that the dissipation is a direct consequence of the spatial discretization and is proportional to the advection speed $a$. This is the well-known numerical diffusion inherent to the first-order upwind scheme.\n\n**Model 2: Central Advection with Explicit Smagorinsky Subgrid-Scale (SGS) Model**\n\nThe semi-discrete equation combines a second-order central difference for advection with an explicit SGS viscous term:\n$$\n\\frac{\\mathrm{d}u_i}{\\mathrm{d}t} = \\underbrace{-\\,a\\,\\frac{u_{i+1}-u_{i-1}}{2\\,\\Delta x}}_{\\text{Advection}} \\;+\\; \\underbrace{\\frac{(\\nu_t g)_{i+1} - (\\nu_t g)_{i-1}}{2\\,\\Delta x}}_{\\text{SGS Diffusion}}\n$$\nwhere $g_i = (u_{i+1}-u_{i-1})/(2\\Delta x)$ is the discrete gradient and $\\nu_{t,i} = (C_s \\Delta x)^2 |g_i|$ is the Smagorinsky eddy viscosity. The total dissipation $D_{\\text{sgs}}$ is the sum of contributions from both terms on the right-hand side.\n\nThe contribution from the central advection term is:\n$$\nD_{\\text{adv}} = -\\frac{1}{N}\\sum_{i=0}^{N-1} u_i \\left( -a\\,\\frac{u_{i+1}-u_{i-1}}{2\\,\\Delta x} \\right) = \\frac{a}{2N\\Delta x}\\sum_{i=0}^{N-1} u_i(u_{i+1}-u_{i-1})\n$$\nThe summation term is zero due to periodicity via discrete summation by parts:\n$$\n\\sum_{i=0}^{N-1} u_i(u_{i+1}-u_{i-1}) = \\sum_{i=0}^{N-1} u_i u_{i+1} - \\sum_{i=0}^{N-1} u_i u_{i-1}\n$$\nBy re-indexing the second sum with $j=i-1$ (and using periodicity), it becomes $\\sum_{j=0}^{N-1} u_{j+1} u_j$. The two sums are identical and cancel, proving the central difference advection scheme is non-dissipative for the total kinetic energy.\n\nTherefore, dissipation in this model arises solely from the explicit SGS term.\n$$\nD_{\\text{sgs}} = -\\frac{1}{N}\\sum_{i=0}^{N-1} u_i \\left( \\frac{(\\nu_t g)_{i+1} - (\\nu_t g)_{i-1}}{2\\,\\Delta x} \\right)\n$$\nApplying summation by parts to this expression:\n$$\nD_{\\text{sgs}} = -\\frac{1}{2N\\Delta x} \\sum_i u_i ((\\nu_t g)_{i+1} - (\\nu_t g)_{i-1}) = \\frac{1}{2N\\Delta x} \\sum_i (u_{i+1}-u_{i-1}) (\\nu_t g)_i\n$$\nRecognizing that $g_i = (u_{i+1}-u_{i-1})/(2\\Delta x)$, we obtain a simplified, positive-definite formula:\n$$\nD_{\\text{sgs}} = \\frac{1}{N}\\sum_{i=0}^{N-1} g_i (\\nu_t g)_i = \\frac{1}{N}\\sum_{i=0}^{N-1} \\nu_{t,i} g_i^2\n$$\nSubstituting the definition of $\\nu_{t,i}$:\n$$\nD_{\\text{sgs}} = \\frac{1}{N}\\sum_{i=0}^{N-1} (C_s\\Delta x)^2|g_i| \\cdot g_i^2 = \\frac{(C_s\\Delta x)^2}{N}\\sum_{i=0}^{N-1} |g_i|^3\n$$\nThis physically represents the rate at which kinetic energy is removed from the resolved scales and transferred to the subgrid scales, which is the purpose of an SGS model.\n\n**Computational Procedure**\n\nFor each test case, we will perform the following steps:\n1. Initialize the grid $x_i$ and the field $u_i$ at $t=0$ using the given parameters $L, N, m, U_0$.\n2. Compute $D_{\\text{up}}$ using the formula $D_{\\text{up}} = \\frac{a}{L}\\sum_{i=0}^{N-1} (u_i^2 - u_i u_{i-1})$. For periodic boundaries, $u_{-1}$ is taken as $u_{N-1}$.\n3. Compute the discrete gradient $g_i = (u_{i+1}-u_{i-1})/(2\\Delta x)$, where $u_{N}$ is $u_0$ and $u_{-1}$ is $u_{N-1}$.\n4. Compute $D_{\\text{sgs}}$ using the formula $D_{\\text{sgs}} = \\frac{(C_s\\Delta x)^2}{N}\\sum_{i=0}^{N-1} |g_i|^3$.\n5. Compute the ratio $R = D_{\\text{up}}/D_{\\text{sgs}}$. For Case C where $a=0$, $D_{\\text{up}}$ will be zero, resulting in $R=0$.\n6. Round all numerical results to six decimal places as required. The implementation will be carried out using numerical arrays for efficiency.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the instantaneous kinetic energy dissipation rate for two numerical schemes\n    for a one-dimensional advection problem on a periodic domain.\n    \"\"\"\n\n    test_cases = [\n        # Case A: General under-resolved case\n        {'L': 2 * np.pi, 'N': 16, 'm': 3, 'U0': 1.0, 'a': 1.0, 'Cs': 0.17},\n        # Case B: More severe under-resolution\n        {'L': 2 * np.pi, 'N': 12, 'm': 3, 'U0': 1.0, 'a': 1.0, 'Cs': 0.17},\n        # Case C: Edge case with zero advection speed\n        {'L': 2 * np.pi, 'N': 16, 'm': 3, 'U0': 1.0, 'a': 0.0, 'Cs': 0.17},\n    ]\n\n    results = []\n    for params in test_cases:\n        # Extract parameters for the current test case\n        L = params['L']\n        N = params['N']\n        m = params['m']\n        U0 = params['U0']\n        a = params['a']\n        Cs = params['Cs']\n\n        # 1. Set up grid and initial condition\n        dx = L / N\n        # x_i = i * dx\n        x = np.arange(N) * dx\n        # Initial field u(x,0)\n        # Using the fact that L=2*pi simplifies the argument of sin\n        u = U0 * np.sin(m * x)\n\n        # 2. Compute dissipation for the first-order upwind scheme (D_up)\n        # u_{i-1} using periodic boundary condition\n        u_im1 = np.roll(u, 1)\n        # D_up = (a/L) * sum(u_i^2 - u_i * u_{i-1})\n        sum_term_up = np.sum(u**2 - u * u_im1)\n        D_up = a / L * sum_term_up\n\n        # 3. Compute dissipation for the Smagorinsky SGS model (D_sgs)\n        # u_{i+1} and u_{i-1} using periodic boundary conditions\n        u_ip1 = np.roll(u, -1)\n        # Gradient g_i = (u_{i+1} - u_{i-1}) / (2*dx)\n        g = (u_ip1 - u_im1) / (2 * dx)\n        # D_sgs = ((Cs*dx)^2 / N) * sum(|g_i|^3)\n        sum_term_sgs = np.sum(np.abs(g)**3)\n        D_sgs = ((Cs * dx)**2 / N) * sum_term_sgs\n        \n        # 4. Compute the ratio R = D_up / D_sgs\n        # This handles the case where D_sgs could be zero, although not expected here.\n        # For Case C, a=0 implies D_up=0, so R=0.\n        if D_sgs != 0:\n            R = D_up / D_sgs\n        elif D_up == 0:\n            R = 0.0\n        else:\n            R = np.inf # Should not occur in these test cases\n\n        # 5. Round results to six decimal places\n        D_up_rounded = round(D_up, 6)\n        D_sgs_rounded = round(D_sgs, 6)\n        R_rounded = round(R, 6)\n\n        results.append([D_up_rounded, D_sgs_rounded, R_rounded])\n\n    # Format the final output string exactly as specified in the problem,\n    # including spaces as shown in the example.\n    print(str(results).replace(\"'\", \"\"))\n\nsolve()\n```", "id": "2447860"}]}