{"hands_on_practices": [{"introduction": "Before tackling the full complexity of self-consistent fields, it is essential to master the fundamentals of particle motion on a discrete grid. This first exercise [@problem_id:2424083] focuses on the 'particle pusher' component, where you will implement an adaptive time step, $\\Delta t$, based on the Courant-Friedrichs-Lewy (CFL) condition. Mastering this concept is critical for ensuring numerical stability and efficiency in any time-dependent simulation.", "problem": "You are given a one-dimensional system of charged particles in a periodic domain, to be treated using the Particle-In-Cell (PIC) abstraction for kinematics only. The domain has length $L$ (in $\\mathrm{m}$) and is discretized into $N_x$ uniform cells with spacing $\\Delta x = L/N_x$ (in $\\mathrm{m}$). There are $N_p$ particles with positions $x_i$ (in $\\mathrm{m}$) and velocities $v_i$ (in $\\mathrm{m/s}$). The system is subject to a spatially uniform, time-independent electric field $E_0$ (in $\\mathrm{V/m}$), and all particles share a common charge-to-mass ratio $q/m$ (in $\\mathrm{C/kg}$). Assume periodic boundary conditions for positions.\n\nThe particle dynamics are governed by Newton’s second law, where the acceleration is $a = (q/m)\\,E_0$ (in $\\mathrm{m/s^2}$). Using a time-discrete evolution with a step size $\\Delta t_n$ at step index $n$, the kinematic update rules are\n$$\nv_i^{n+1} = v_i^{n} + a\\,\\Delta t_n,\n\\qquad\nx_i^{n+1} = \\bigl(x_i^{n} + v_i^{n}\\,\\Delta t_n\\bigr) \\bmod L.\n$$\n\nAt each time step $n$, the step size $\\Delta t_n$ must be chosen to satisfy a Courant-type restriction derived from the requirement that the maximum particle displacement in one step not exceed a fraction $C_{\\mathrm{cfl}}$ of the grid spacing. Let\n$$\nv_{\\max}^n = \\max_{1 \\le i \\le N_p} \\left| v_i^{n} \\right|.\n$$\nThe admissible time step sizes satisfy\n$$\n\\Delta t_n \\le \\frac{C_{\\mathrm{cfl}}\\,\\Delta x}{v_{\\max}^n} \\quad \\text{when } v_{\\max}^n > 0.\n$$\nAdditionally, a user-specified upper bound $\\Delta t_{\\mathrm{upper}}$ (in $\\mathrm{s}$) must be enforced. If $v_{\\max}^n = 0$, then take $\\Delta t_n = \\min\\{\\Delta t_{\\mathrm{upper}},\\, T_{\\mathrm{end}}-t_n\\}$, where $t_n$ is the current simulation time and $T_{\\mathrm{end}}$ (in $\\mathrm{s}$) is the prescribed final time. Otherwise, select\n$$\n\\Delta t_n = \\min\\!\\left\\{ \\frac{C_{\\mathrm{cfl}}\\,\\Delta x}{v_{\\max}^n},\\ \\Delta t_{\\mathrm{upper}},\\ T_{\\mathrm{end}}-t_n \\right\\}.\n$$\nSimulate until the accumulated time $t$ reaches exactly $T_{\\mathrm{end}}$ by truncating the final step if necessary as indicated.\n\nYour task is to write a complete, runnable program that, for each of the test cases below, runs the simulation described and returns the total number of time steps taken to reach $T_{\\mathrm{end}}$. Use the units as specified (International System of Units), update the positions with periodicity modulo $L$, and compute the adaptive time step $\\Delta t_n$ at each step strictly from the definition above.\n\nTest Suite (each test case is independent; all quantities are in the International System of Units):\n- Test A (happy path, upper bound active throughout):\n  - $L = 1.0\\,\\mathrm{m}$, $N_x = 100$, $C_{\\mathrm{cfl}} = 0.9$, $\\Delta t_{\\mathrm{upper}} = 2.0\\times 10^{-3}\\,\\mathrm{s}$, $T_{\\mathrm{end}} = 0.1\\,\\mathrm{s}$,\n  - $N_p = 3$, initial positions $[0.1, 0.5, 0.9]\\,\\mathrm{m}$, initial velocities $[0.0, 0.2, -0.1]\\,\\mathrm{m/s}$,\n  - $q/m = 1.0\\,\\mathrm{C/kg}$, $E_0 = 1.0\\,\\mathrm{V/m}$.\n- Test B (Courant limit active, constant velocities):\n  - $L = 1.0\\,\\mathrm{m}$, $N_x = 100$, $C_{\\mathrm{cfl}} = 0.8$, $\\Delta t_{\\mathrm{upper}} = 1.0\\,\\mathrm{s}$, $T_{\\mathrm{end}} = 0.05\\,\\mathrm{s}$,\n  - $N_p = 3$, initial positions $[0.0, 0.3, 0.7]\\,\\mathrm{m}$, initial velocities $[10.0, -5.0, 2.0]\\,\\mathrm{m/s}$,\n  - $q/m = 1.0\\,\\mathrm{C/kg}$, $E_0 = 0.0\\,\\mathrm{V/m}$.\n- Test C (edge case with zero velocities and zero field):\n  - $L = 1.0\\,\\mathrm{m}$, $N_x = 50$, $C_{\\mathrm{cfl}} = 0.5$, $\\Delta t_{\\mathrm{upper}} = 1.0\\times 10^{-2}\\,\\mathrm{s}$, $T_{\\mathrm{end}} = 3.5\\times 10^{-2}\\,\\mathrm{s}$,\n  - $N_p = 2$, initial positions $[0.2, 0.8]\\,\\mathrm{m}$, initial velocities $[0.0, 0.0]\\,\\mathrm{m/s}$,\n  - $q/m = 1.0\\,\\mathrm{C/kg}$, $E_0 = 0.0\\,\\mathrm{V/m}$.\n- Test D (time step transitions from upper bound to Courant regime):\n  - $L = 1.0\\,\\mathrm{m}$, $N_x = 200$, $C_{\\mathrm{cfl}} = 1.0$, $\\Delta t_{\\mathrm{upper}} = 1.0\\times 10^{-2}\\,\\mathrm{s}$, $T_{\\mathrm{end}} = 1.0\\times 10^{-1}\\,\\mathrm{s}$,\n  - $N_p = 3$, initial positions $[0.0, 0.4, 0.9]\\,\\mathrm{m}$, initial velocities $[0.0, 0.5, -0.2]\\,\\mathrm{m/s}$,\n  - $q/m = 2.0\\,\\mathrm{C/kg}$, $E_0 = 3.0\\,\\mathrm{V/m}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the tests A, B, C, D. Each entry must be an integer equal to the number of time steps taken in that test (for example, a line like $[n_A,n_B,n_C,n_D]$).", "solution": "The problem presented is a well-defined exercise in computational kinematics. It requires the implementation of a time-stepping simulation for a system of charged particles under a constant external electric field. The core of the problem lies in correctly implementing the particle state updates and the adaptive time-step calculation according to a specified Courant-type condition. The problem is scientifically grounded in classical mechanics and standard numerical methods. It is self-contained, with all necessary parameters and evolution rules provided. Therefore, it is valid, and we proceed to construct the solution.\n\nThe solution requires developing an algorithm that simulates the trajectory of $N_p$ particles from an initial time $t=0$ to a final time $T_{\\mathrm{end}}$. The algorithm is structured as a main loop that iteratively advances the simulation time.\n\nFirst, we establish the constants for a given test case. The grid spacing is $\\Delta x = L/N_x$, and the uniform acceleration experienced by all particles is $a = (q/m)E_0$. These values remain constant throughout the simulation.\n\nThe state of the system at any time step $n$ is defined by the set of particle positions $\\{x_i^n\\}$ and velocities $\\{v_i^n\\}$, and the current simulation time $t_n$. The simulation starts with the initial conditions: $t_0=0$, $\\{x_i^0\\}$, and $\\{v_i^0\\}$. A counter for the number of time steps, $n_{\\mathrm{steps}}$, is initialized to $0$.\n\nThe simulation proceeds iteratively using a `while` loop that continues as long as the condition $t_n < T_{\\mathrm{end}}$ holds. Within each iteration, the following sequence of operations is performed:\n\n1.  **Adaptive Time-Step Calculation**: The time step for the current iteration, $\\Delta t_n$, is determined. This is the most critical part of the algorithm's logic.\n    -   First, one must compute the maximum absolute velocity among all particles, $v_{\\max}^n = \\max_{i} |v_i^n|$.\n    -   If $v_{\\max}^n = 0$, the particles are stationary. In this special case, the Courant condition is irrelevant, and the time step is determined by the user-defined upper limit and the remaining simulation time:\n        $$\n        \\Delta t_n = \\min\\{\\Delta t_{\\mathrm{upper}}, T_{\\mathrm{end}} - t_n\\}.\n        $$\n    -   If $v_{\\max}^n > 0$, the time step is constrained by three factors: the Courant condition, the user-defined upper limit, and the remaining simulation time. The Courant condition imposes a limit $\\Delta t_{\\mathrm{cfl}} = (C_{\\mathrm{cfl}} \\Delta x) / v_{\\max}^n$. The actual time step is the minimum of these three values:\n        $$\n        \\Delta t_n = \\min\\left\\{ \\frac{C_{\\mathrm{cfl}}\\,\\Delta x}{v_{\\max}^n}, \\Delta t_{\\mathrm{upper}}, T_{\\mathrm{end}} - t_n \\right\\}.\n        $$\n    The inclusion of the term $T_{\\mathrm{end}} - t_n$ in the `min` function ensures that the final time step is automatically truncated, so the simulation concludes precisely at $t = T_{\\mathrm{end}}$.\n\n2.  **Particle State Update**: Once $\\Delta t_n$ is determined, the positions and velocities of all particles are updated to their values at step $n+1$. The problem specifies a forward Euler integration scheme.\n    -   The new positions are calculated using the velocities from the beginning of the time step, $v_i^n$:\n        $$\n        x_i^{n+1} = \\left(x_i^n + v_i^n \\Delta t_n\\right) \\bmod L.\n        $$\n        The modulo operation enforces the periodic boundary condition, ensuring that any particle exiting one side of the domain of length $L$ re-enters from the opposite side. The result of this operation must lie in the interval $[0, L)$.\n    -   The new velocities are calculated based on the constant acceleration $a$:\n        $$\n        v_i^{n+1} = v_i^n + a \\Delta t_n.\n        $$\n    It is crucial to note that the position update for step $n+1$ must use the velocity from step $n$, not the newly computed velocity $v_i^{n+1}$.\n\n3.  **Simulation Advancement**: After updating all particle states, the simulation time is advanced, and the step counter is incremented.\n    -   $t_{n+1} = t_n + \\Delta t_n$.\n    -   $n_{\\mathrm{steps}} \\leftarrow n_{\\mathrm{steps}} + 1$.\n\nThe loop terminates when the simulation time $t_n$ is no longer less than $T_{\\mathrm{end}}$. Upon termination, the final value of $n_{\\mathrm{steps}}$ is the total number of time steps taken, which is the required output for each test case.\n\nThis algorithm is to be implemented in a program. For efficiency, particle positions and velocities should be stored in arrays (or vectors), allowing for vectorized operations, especially for the update steps and the calculation of $v_{\\max}^n$. The program will execute this simulation for each of the four test cases provided, collecting the resulting step count for each. The final output will be a list of these integer counts.", "answer": "```python\nimport numpy as np\n\ndef run_simulation(**params):\n    \"\"\"\n    Runs a single particle kinematics simulation based on the provided parameters.\n    \n    The function implements a forward Euler time-stepping loop with an adaptive\n    time step determined by a Courant-like condition.\n    \"\"\"\n    # Unpack parameters from the input dictionary\n    L = params[\"L\"]\n    Nx = params[\"Nx\"]\n    Ccfl = params[\"Ccfl\"]\n    dt_upper = params[\"dt_upper\"]\n    Tend = params[\"Tend\"]\n    x_initial = params[\"x_initial\"]\n    v_initial = params[\"v_initial\"]\n    q_over_m = params[\"q_over_m\"]\n    E0 = params[\"E0\"]\n\n    # Calculate simulation constants\n    dx = L / Nx\n    a = q_over_m * E0\n\n    # Initialize simulation state variables\n    # Use copies to prevent modifying the original test case data\n    positions = np.copy(x_initial)\n    velocities = np.copy(v_initial)\n    t = 0.0\n    num_steps = 0\n    \n    # Main simulation loop\n    while t < Tend:\n        # 1. Calculate the adaptive time step dt\n        v_max = np.max(np.abs(velocities))\n\n        # Calculate the Courant-limited time step.\n        # If v_max is 0, the CFL limit is effectively infinite.\n        if v_max > 0:\n            dt_cfl = (Ccfl * dx) / v_max\n        else:\n            # According to the problem, if v_max is 0, we only consider\n            # dt_upper and the time remaining. Setting dt_cfl to infinity\n            # achieves this within the min() function below.\n            dt_cfl = float('inf')\n\n        # The time step dt is the minimum of the CFL limit, the user-\n        # specified upper bound, and the time remaining to reach Tend.\n        # This ensures the simulation ends exactly at Tend.\n        dt = min(dt_cfl, dt_upper, Tend - t)\n        \n        # A safeguard for floating point issues where dt could be infinitesimal\n        # and cause an infinite loop. If dt is zero or negative, break.\n        if dt <= 0:\n            break\n\n        # 2. Update particle states using forward Euler method\n        # Position update uses velocities from the start of the timestep (v^n)\n        positions = (positions + velocities * dt) % L\n        \n        # Velocity update\n        velocities = velocities + a * dt\n        \n        # 3. Advance simulation time and step count\n        t += dt\n        num_steps += 1\n        \n    return num_steps\n\ndef solve():\n    \"\"\"\n    Defines the test cases, runs the simulation for each, and prints the\n    results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Test A: happy path, upper bound active throughout\n        {\n            \"L\": 1.0, \"Nx\": 100, \"Ccfl\": 0.9, \"dt_upper\": 2.0e-3, \"Tend\": 0.1,\n            \"Np\": 3, \"x_initial\": np.array([0.1, 0.5, 0.9]),\n            \"v_initial\": np.array([0.0, 0.2, -0.1]),\n            \"q_over_m\": 1.0, \"E0\": 1.0\n        },\n        # Test B: Courant limit active, constant velocities\n        {\n            \"L\": 1.0, \"Nx\": 100, \"Ccfl\": 0.8, \"dt_upper\": 1.0, \"Tend\": 0.05,\n            \"Np\": 3, \"x_initial\": np.array([0.0, 0.3, 0.7]),\n            \"v_initial\": np.array([10.0, -5.0, 2.0]),\n            \"q_over_m\": 1.0, \"E0\": 0.0\n        },\n        # Test C: edge case with zero velocities and zero field\n        {\n            \"L\": 1.0, \"Nx\": 50, \"Ccfl\": 0.5, \"dt_upper\": 1.0e-2, \"Tend\": 3.5e-2,\n            \"Np\": 2, \"x_initial\": np.array([0.2, 0.8]),\n            \"v_initial\": np.array([0.0, 0.0]),\n            \"q_over_m\": 1.0, \"E0\": 0.0\n        },\n        # Test D: time step transitions from upper bound to Courant regime\n        {\n            \"L\": 1.0, \"Nx\": 200, \"Ccfl\": 1.0, \"dt_upper\": 1.0e-2, \"Tend\": 0.1,\n            \"Np\": 3, \"x_initial\": np.array([0.0, 0.4, 0.9]),\n            \"v_initial\": np.array([0.0, 0.5, -0.2]),\n            \"q_over_m\": 2.0, \"E0\": 3.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        num_steps = run_simulation(**case)\n        results.append(num_steps)\n\n    # Print the final output in the required format: [n_A,n_B,n_C,n_D]\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver\nsolve()\n```", "id": "2424083"}, {"introduction": "With particle kinematics established, you are now ready to build a complete, self-consistent simulation. This practice [@problem_id:2424112] guides you through creating a one-dimensional electrostatic PIC code where the electric field $E$ is determined by the charge density $\\rho$ via Gauss's Law, $\\frac{\\partial E}{\\partial x} = \\frac{\\rho}{\\varepsilon_0}$. You will implement the entire PIC cycle and see how the feedback between particles and fields gives rise to complex collective behavior.", "problem": "Implement a one-dimensional, electrostatic Particle-In-Cell (PIC) method with periodic boundary conditions that includes a photoionization source term producing new electron-ion pairs uniformly in space from a stationary, uniform neutral gas. The algorithm must be self-consistent: charges are deposited to a grid, the electric field is obtained from Gauss’s law, and particles are pushed by the Lorentz force specialized to electrostatics. New electron-ion pairs are created stochastically each time step according to a deterministic rate law and a fixed random seed.\n\nFundamental base:\n- Use Newton’s second law for each charged particle, $m \\, dv/dt = q \\, E(x,t)$, and kinematics $dx/dt = v$.\n- Use Gauss’s law in one dimension under electrostatic conditions, $\\partial E/\\partial x = \\rho/\\varepsilon_0$, with periodic boundary conditions on a domain of length $L$.\n- The source term for photoionization is a uniform volumetric pair-creation rate $S$ defined by $S = \\sigma \\, \\Phi \\, n_n$, where $\\sigma$ is the photoionization cross section, $\\Phi$ is the photon flux, and $n_n$ is the neutral gas number density. Per time step $\\Delta t$, the expected number of real pairs created in the domain of length $L$ (assuming unit cross-sectional area) is $S \\, L \\, \\Delta t$.\n- Use macro-particles of weight $W$ such that each macro-particle represents $W$ real particles. Therefore, the expected number of macro-pairs per time step is $\\mu = (S \\, L \\, \\Delta t)/W$.\n\nNumerical specification:\n- Represent the one-dimensional domain of length $L$ with $N_g$ uniformly spaced grid nodes and periodic boundary conditions.\n- Deposit charge density $\\rho(x)$ to the grid using a consistent first-order (cloud-in-cell) scheme from electron and ion macro-particles. For electrons use charge $q_e = -e \\, W$ per macro-particle, and for ions use charge $q_i = +e \\, W$ per macro-particle, where $e$ is the elementary charge. Divide by the cell volume $V_{\\text{cell}} = \\Delta x$ (unit cross-sectional area) so that $\\rho$ has units of $\\mathrm{C/m^3}$.\n- Solve for the electric field $E(x)$ such that $\\partial E/\\partial x = \\rho/\\varepsilon_0$ under periodic boundary conditions. Maintain the periodic solvability condition by enforcing zero mean of $E(x)$.\n- Interpolate $E(x)$ from the grid back to particle positions using the same first-order shape function used for charge deposition.\n- Advance particle velocities and positions using a time-centered leapfrog scheme:\n  - $v^{n+1/2} = v^{n-1/2} + (q/m) \\, E(x^n) \\, \\Delta t$\n  - $x^{n+1} = x^n + v^{n+1/2} \\, \\Delta t$\n  Impose periodic boundary conditions on positions.\n- At each time step, create new macro electron-ion pairs:\n  - Compute $\\mu = (S \\, L \\, \\Delta t)/W$ with $S = \\sigma \\, \\Phi \\, n_n$.\n  - Generate the actual number of new macro-pairs by probabilistic rounding: let $n_{\\text{base}} = \\lfloor \\mu \\rfloor$ and $f = \\mu - \\lfloor \\mu \\rfloor$. Add one more pair with probability $f$. Use independent, uniformly distributed random positions in $[0,L)$ for the new pairs, and set their initial leapfrog velocities to zero. Use a fixed pseudorandom number generator seed of $42$ so that results are reproducible.\n\nPhysical constants to use (in the International System of Units):\n- Elementary charge $e = 1.602176634 \\times 10^{-19}\\,\\mathrm{C}$.\n- Electron mass $m_e = 9.1093837015 \\times 10^{-31}\\,\\mathrm{kg}$.\n- Ion mass $m_i = 6.6335209 \\times 10^{-26}\\,\\mathrm{kg}$ (representative of singly ionized argon).\n- Vacuum permittivity $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}\\,\\mathrm{F/m}$.\n\nInitialization and boundary conditions:\n- Start with no charged particles in the domain.\n- Use periodic boundary conditions for both fields and particles.\n- Use unit cross-sectional area so that the effective domain volume is $L$.\n\nTask:\n- Implement the algorithm above and run it for the specified test suite below.\n- For each test case, after advancing exactly $N_t$ time steps, report the total number of macro-electrons present (an integer count). There is no need to report positions, velocities, or fields.\n- Angles do not appear in this problem.\n- No physical units are required in the final results since the outputs are counts (dimensionless).\n\nTest suite (each tuple encodes $(L, N_g, \\Delta t, N_t, \\sigma, \\Phi, n_n, W)$):\n1. $(L = 0.1\\,\\mathrm{m}, N_g = 64, \\Delta t = 1.0\\times 10^{-11}\\,\\mathrm{s}, N_t = 50, \\sigma = 1.0\\times 10^{-22}\\,\\mathrm{m}^2, \\Phi = 5.0\\times 10^{20}\\,\\mathrm{m}^{-2}\\mathrm{s}^{-1}, n_n = 1.0\\times 10^{19}\\,\\mathrm{m}^{-3}, W = 5.0\\times 10^{4})$.\n2. $(L = 0.1\\,\\mathrm{m}, N_g = 64, \\Delta t = 1.0\\times 10^{-11}\\,\\mathrm{s}, N_t = 50, \\sigma = 1.0\\times 10^{-22}\\,\\mathrm{m}^2, \\Phi = 0.0\\,\\mathrm{m}^{-2}\\mathrm{s}^{-1}, n_n = 1.0\\times 10^{19}\\,\\mathrm{m}^{-3}, W = 5.0\\times 10^{4})$.\n3. $(L = 0.1\\,\\mathrm{m}, N_g = 64, \\Delta t = 1.0\\times 10^{-11}\\,\\mathrm{s}, N_t = 50, \\sigma = 2.0\\times 10^{-22}\\,\\mathrm{m}^2, \\Phi = 1.0\\times 10^{21}\\,\\mathrm{m}^{-2}\\mathrm{s}^{-1}, n_n = 2.0\\times 10^{19}\\,\\mathrm{m}^{-3}, W = 2.0\\times 10^{5})$.\n4. $(L = 0.1\\,\\mathrm{m}, N_g = 64, \\Delta t = 1.0\\times 10^{-11}\\,\\mathrm{s}, N_t = 50, \\sigma = 1.0\\times 10^{-22}\\,\\mathrm{m}^2, \\Phi = 5.0\\times 10^{20}\\,\\mathrm{m}^{-2}\\mathrm{s}^{-1}, n_n = 1.0\\times 10^{19}\\,\\mathrm{m}^{-3}, W = 1.0\\times 10^{7})$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[x_1,x_2,x_3,x_4]$), where each $x_i$ is the final number of macro-electrons for test case $i$ as an integer.", "solution": "The problem presented is a well-posed and scientifically sound task in computational plasma physics. It requires the implementation of a one-dimensional electrostatic Particle-In-Cell (PIC) code. The model includes periodic boundary conditions and a photoionization source term, which introduces new electron-ion pairs into the simulation domain over time. The problem is self-contained, providing all necessary physical laws, numerical methods, physical constants, and test parameters. It is free of contradictions or vagaries. Therefore, we proceed with a full solution.\n\nThe core of the algorithm is the PIC cycle, which self-consistently models the interaction between charged particles and the electric field they collectively generate. This cycle is executed at each discrete time step, $\\Delta t$. We begin with a description of the discretized domain and then detail each step of the PIC cycle.\n\n**System Discretization**\n\nThe one-dimensional spatial domain of length $L$ is discretized into $N_g$ grid cells of uniform width $\\Delta x = L/N_g$. The grid nodes are located at positions $x_j = j \\Delta x$ for $j = 0, 1, \\dots, N_g-1$. Physical quantities defined on the grid, such as charge density $\\rho$ and electric field $E$, are discretized at these nodes. The simulation advances in discrete time steps of duration $\\Delta t$.\n\n**The Particle-In-Cell (PIC) Cycle**\n\nThe simulation starts with no charged particles. At each time step $n$, the following sequence of operations is performed for a total of $N_t$ steps.\n\n**1. Source Term: Particle Creation**\nThe photoionization of a stationary neutral gas creates new electron-ion pairs. The volumetric creation rate is given as $S = \\sigma \\Phi n_n$, where $\\sigma$ is the photoionization cross-section, $\\Phi$ is the photon flux, and $n_n$ is the neutral gas density. For the one-dimensional domain of length $L$ and unit cross-sectional area, the total number of real pairs created per time step $\\Delta t$ is $S L \\Delta t$.\n\nEach computational macro-particle represents $W$ real particles. Thus, the expected number of new macro-pairs to be created in one time step is:\n$$\n\\mu = \\frac{S L \\Delta t}{W}\n$$\nTo ensure a statistically correct injection rate, we employ probabilistic rounding. The number of pairs created in a given time step, $N_{\\text{new}}$, is determined as:\n$$\nN_{\\text{new}} = \\lfloor \\mu \\rfloor + \\begin{cases} 1 & \\text{with probability } f \\\\ 0 & \\text{with probability } 1-f \\end{cases}\n$$\nwhere $f = \\mu - \\lfloor \\mu \\rfloor$ is the fractional part of $\\mu$. This is implemented by drawing a random number $r$ from a uniform distribution on $[0, 1)$ and adding an extra pair if $r < f$. A fixed random seed ensures reproducibility. For each new pair, an electron and an ion are created at the same random position $x_{\\text{new}}$, drawn uniformly from $[0, L)$. Their initial velocities, required for the leapfrog integrator, are set to zero.\n\n**2. Charge Deposition (Scatter)**\nThe continuous charge distribution of the plasma is represented by a discrete set of macro-particles. The charge of these particles must be deposited onto the grid to compute the charge density $\\rho_j$. We use the first-order, or Cloud-in-Cell (CIC), weighting scheme.\n\nFor a particle $p$ with charge $q_p$ located at position $x_p$, we first identify the index of the grid node to its immediate left, $j = \\lfloor x_p / \\Delta x \\rfloor$. The particle's charge is distributed between this node and the adjacent node to the right, $j+1$ (with periodic wrap-around, i.e., index $(j+1) \\pmod{N_g}$). The fractions of charge assigned to each node are determined by linear weighting. Let $h = (x_p/\\Delta x) - j$ be the normalized distance from the left node. The charge contributions are:\n$$\n\\delta \\rho'_{j} = q_p (1-h)\n$$\n$$\n\\delta \\rho'_{(j+1) \\pmod{N_g}} = q_p h\n$$\nThe total charge on each grid node, $\\rho'_j$, is the sum of contributions from all particles (electrons and ions, with $q_e = -eW$ and $q_i = +eW$). The charge density $\\rho_j$ at node $j$ is then found by dividing by the cell volume, which in our one-dimensional case with unit area is just the cell width $\\Delta x$:\n$$\n\\rho_j = \\frac{\\rho'_j}{\\Delta x}\n$$\n\n**3. Field Solver**\nWith the charge density $\\rho_j$ known on the grid, we solve for the electric field $E_j$ using the one-dimensional Gauss's law under electrostatic conditions:\n$$\n\\frac{\\partial E}{\\partial x} = \\frac{\\rho}{\\varepsilon_0}\n$$\nFor a periodic domain, a spectral method using the Fast Fourier Transform (FFT) is highly efficient and accurate. In Fourier space, the spatial derivative $\\partial/\\partial x$ becomes a multiplication by $ik$, where $k$ is the wavenumber. Transforming Gauss's law gives:\n$$\nik \\hat{E}(k) = \\frac{\\hat{\\rho}(k)}{\\varepsilon_0}\n$$\nwhere $\\hat{E}(k)$ and $\\hat{\\rho}(k)$ are the Fourier transforms of the electric field and charge density, respectively.\n\nWe can solve for the Fourier components of the electric field:\n$$\n\\hat{E}(k) = \\frac{\\hat{\\rho}(k)}{ik\\varepsilon_0} = -i \\frac{\\hat{\\rho}(k)}{k\\varepsilon_0}, \\quad \\text{for } k \\neq 0\n$$\nFor the $k=0$ (DC) component, the denominator is zero. The solvability condition for the periodic system requires the net charge in the domain to be zero, which implies $\\hat{\\rho}(k=0) = 0$. This condition is satisfied here because we always create electron-ion pairs, maintaining charge neutrality. The problem specifies that the mean electric field must be zero, which corresponds to setting $\\hat{E}(k=0) = 0$.\n\nThe numerical procedure is:\n1. Compute the discrete Fourier transform of the charge density: $\\hat{\\rho}_m = \\text{FFT}(\\rho_j)$.\n2. For each discrete wavenumber $k_m$ (where $m$ is the frequency index), compute $\\hat{E}_m$. Set $\\hat{E}_0 = 0$.\n3. Compute the inverse Fourier transform to obtain the electric field on the grid: $E_j = \\text{IFFT}(\\hat{E}_m)$. The result must be real, so any small imaginary part due to numerical error is discarded.\n\n**4. Field Interpolation (Gather)**\nTo update the particle velocities, the electric field must be evaluated at each particle's position $x_p$. This is achieved by interpolating the grid-based field $E_j$ back to the particle positions. To ensure conservation of momentum and prevent self-forces, the interpolation scheme must be consistent with the charge deposition scheme. We therefore use the same first-order (CIC) weighting:\n$$\nE(x_p) = E_j (1-h) + E_{(j+1) \\pmod{N_g}} h\n$$\nwhere $j = \\lfloor x_p / \\Delta x \\rfloor$ and $h = (x_p/\\Delta x) - j$ are the same as in the deposition step.\n\n**5. Particle Pusher**\nThe motion of each particle is governed by Newton's second law, with the force given by the Lorentz force, which in this electrostatic case simplifies to $F = qE$. The equations of motion are:\n$$\n\\frac{d\\vec{v}}{dt} = \\frac{q}{m} \\vec{E}, \\quad \\frac{d\\vec{x}}{dt} = \\vec{v}\n$$\nThese equations are integrated using the time-centered leapfrog algorithm, known for its long-term stability and second-order accuracy. Velocities are defined at half-integer time steps ($t^{n-1/2}, t^{n+1/2}, \\dots$) and positions at integer time steps ($t^n, t^{n+1}, \\dots$). The update rules are:\n$$\nv_p^{n+1/2} = v_p^{n-1/2} + \\frac{q_p}{m_p} E(x_p^n) \\Delta t\n$$\n$$\nx_p^{n+1} = x_p^n + v_p^{n+1/2} \\Delta t\n$$\nAfter the position is updated, periodic boundary conditions are applied: $x_p^{n+1} \\leftarrow x_p^{n+1} \\pmod L$. This completes one cycle of the PIC algorithm. The entire process is repeated for $N_t$ time steps. The final required output is the total number of macro-electrons in the simulation at the end.", "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the 1D electrostatic PIC simulation.\n    \"\"\"\n    test_cases = [\n        (0.1, 64, 1.0e-11, 50, 1.0e-22, 5.0e20, 1.0e19, 5.0e4),\n        (0.1, 64, 1.0e-11, 50, 1.0e-22, 0.0, 1.0e19, 5.0e4),\n        (0.1, 64, 1.0e-11, 50, 2.0e-22, 1.0e21, 2.0e19, 2.0e5),\n        (0.1, 64, 1.0e-11, 50, 1.0e-22, 5.0e20, 1.0e19, 1.0e7),\n    ]\n\n    results = []\n    for params in test_cases:\n        final_electron_count = run_pic_simulation(*params)\n        results.append(final_electron_count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_pic_simulation(L, N_g, dt, N_t, sigma, Phi, n_n, W):\n    \"\"\"\n    Executes a one-dimensional electrostatic Particle-In-Cell simulation.\n\n    Args:\n        L (float): Domain length (m).\n        N_g (int): Number of grid nodes.\n        dt (float): Time step duration (s).\n        N_t (int): Total number of time steps.\n        sigma (float): Photoionization cross section (m^2).\n        Phi (float): Photon flux (m^-2 s^-1).\n        n_n (float): Neutral gas number density (m^-3).\n        W (float): Macro-particle weight.\n\n    Returns:\n        int: Total number of macro-electrons at the end of the simulation.\n    \"\"\"\n    # Physical constants\n    E_CHARGE = 1.602176634e-19\n    M_E = 9.1093837015e-31\n    M_I = 6.6335209e-26\n    EPS_0 = 8.8541878128e-12\n\n    # Grid parameters\n    dx = L / N_g\n\n    # Source term calculation\n    S = sigma * Phi * n_n\n    mu = (S * L * dt) / W\n    mu_base = int(mu)\n    mu_frac = mu - mu_base\n\n    # Pre-allocate particle arrays\n    # A safe upper bound for the number of particles is estimated\n    max_new_per_step = mu_base + 1\n    max_particles = max_new_per_step * N_t + 10 # Add a small buffer\n    \n    pos_e = np.zeros(max_particles)\n    vel_e = np.zeros(max_particles)\n    n_elec = 0\n    \n    pos_i = np.zeros(max_particles)\n    vel_i = np.zeros(max_particles)\n    n_ions = 0\n    \n    # Initialize random number generator with fixed seed\n    rng = np.random.default_rng(42)\n\n    # Pre-calculate FFT wavenumbers\n    k_fft = 2 * np.pi * fft.fftfreq(N_g, d=dx)\n    \n    # Main simulation loop\n    for _ in range(N_t):\n        # 1. Source: Create new particles\n        num_new = mu_base\n        if rng.random() < mu_frac:\n            num_new += 1\n\n        if num_new > 0:\n            # Add new electrons\n            start_idx_e = n_elec\n            end_idx_e = n_elec + num_new\n            pos_e[start_idx_e:end_idx_e] = rng.random(size=num_new) * L\n            vel_e[start_idx_e:end_idx_e] = 0.0 # Initial leapfrog velocity is zero\n            n_elec = end_idx_e\n\n            # Add new ions\n            start_idx_i = n_ions\n            end_idx_i = n_ions + num_new\n            pos_i[start_idx_i:end_idx_i] = pos_e[start_idx_e:end_idx_e] # Same position\n            vel_i[start_idx_i:end_idx_i] = 0.0\n            n_ions = end_idx_i\n\n        if n_elec == 0:\n            continue\n        \n        # Slices for active particles\n        active_pos_e = pos_e[:n_elec]\n        active_vel_e = vel_e[:n_elec]\n        active_pos_i = pos_i[:n_ions]\n        active_vel_i = vel_i[:n_ions]\n\n        # 2. Charge Deposition (Scatter)\n        rho_grid = np.zeros(N_g)\n\n        # Electrons\n        q_e = -E_CHARGE * W\n        norm_pos_e = active_pos_e / dx\n        i1_e = np.floor(norm_pos_e).astype(int)\n        h_e = norm_pos_e - i1_e\n        i2_e = (i1_e + 1) % N_g\n        np.add.at(rho_grid, i1_e, q_e * (1.0 - h_e))\n        np.add.at(rho_grid, i2_e, q_e * h_e)\n\n        # Ions\n        q_i = E_CHARGE * W\n        norm_pos_i = active_pos_i / dx\n        i1_i = np.floor(norm_pos_i).astype(int)\n        h_i = norm_pos_i - i1_i\n        i2_i = (i1_i + 1) % N_g\n        np.add.at(rho_grid, i1_i, q_i * (1.0 - h_i))\n        np.add.at(rho_grid, i2_i, q_i * h_i)\n        \n        rho_grid /= dx # Convert charge to charge density\n\n        # 3. Field Solve\n        rho_k = fft.fft(rho_grid)\n        E_k = np.zeros_like(rho_k)\n        \n        # Avoid division by zero for k=0\n        non_zero_k = k_fft != 0\n        E_k[non_zero_k] = -1j * rho_k[non_zero_k] / (k_fft[non_zero_k] * EPS_0)\n        \n        E_grid = np.real(fft.ifft(E_k))\n\n        # 4. Field Interpolation (Gather)\n        # Electrons\n        E_p_e = E_grid[i1_e] * (1.0 - h_e) + E_grid[i2_e] * h_e\n        # Ions\n        E_p_i = E_grid[i1_i] * (1.0 - h_i) + E_grid[i2_i] * h_i\n\n        # 5. Particle Push\n        # Electrons\n        active_vel_e += (q_e / M_E) * E_p_e * dt\n        active_pos_e += active_vel_e * dt\n        pos_e[:n_elec] = active_pos_e % L\n        \n        # Ions\n        active_vel_i += (q_i / M_I) * E_p_i * dt\n        active_pos_i += active_vel_i * dt\n        pos_i[:n_ions] = active_pos_i % L\n        \n    return n_elec\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2424112"}, {"introduction": "A simulation is only as good as the accuracy of its numerical methods. This final practice [@problem_id:2424113] moves from implementation to analysis, tasking you to evaluate your field solver's fidelity to the continuum solution. By constructing the Discrete Green's Function, $G_d$, you will quantify how the grid introduces errors and anisotropy, providing a direct measure of its deviation from the ideal $\\frac{1}{r}$ potential.", "problem": "You are tasked with developing a complete, runnable program that constructs and analyzes the Discrete Green’s Function for a three-dimensional electrostatic Particle-In-Cell (PIC) solver on a uniform Cartesian grid with periodic boundary conditions. Your PIC solver uses a second-order central-difference discretization of the Laplacian operator and solves Poisson’s equation in Fourier space.\n\nStart from the fundamental base: the electrostatic limit of Maxwell’s equations yields Poisson’s equation, $\\nabla^2 \\phi(\\mathbf{x}) = -\\rho(\\mathbf{x})/\\varepsilon_0$. On a uniform grid with spacing $h$ and periodic boundary conditions, the second-order discrete Laplacian approximates $\\nabla^2$. The discrete Green’s Function $G_d(\\mathbf{r})$ is defined as the potential response at grid points to a unit point charge placed at the origin, as computed by the specified discrete solver and grid. In Particle-In-Cell (PIC) methods, the finite particle size implied by the particle-to-grid assignment and the field-to-particle interpolation modifies the effective source and measurement in wave number space by the square of the Fourier transform of the chosen shape function.\n\nImplement the following in your program:\n\n1) Construct the discrete Green’s Function in three dimensions for a uniform periodic grid of size $N \\times N \\times N$, using the second-order central-difference Laplacian combined with a spectral (Discrete Fourier Transform) inversion of the Poisson equation. Enforce the zero-mean condition by setting the wave number zero mode to zero so that the potential is uniquely defined under periodic boundary conditions.\n\n2) Incorporate the effect of the particle shape. Use one-dimensional B-spline shape functions of order $m$ with Fourier transform $S_m(k) = \\left[\\operatorname{sinc}\\!\\left(\\frac{k h}{2}\\right)\\right]^{m+1}$, where $\\operatorname{sinc}(x) = \\frac{\\sin x}{x}$. Assume identical shape functions are used for both particle-to-grid deposition and grid-to-particle interpolation, so that the effective spectral response multiplies by $\\lvert S_m(\\mathbf{k}) \\rvert^2 = \\prod_{i=x,y,z}\\left[\\operatorname{sinc}\\!\\left(\\frac{k_i h}{2}\\right)\\right]^{2(m+1)}$. Use $m=0$ for Nearest-Grid-Point (NGP) and $m=1$ for Cloud-In-Cell (CIC).\n\n3) Work in dimensionless lattice units to compare with the continuum Green’s function. Let $\\hat{\\mathbf{r}} = \\mathbf{r}/h$ be the lattice coordinate. Define the dimensionless discrete Green’s function $\\hat{G}_d(\\hat{\\mathbf{r}})$ via the inverse Discrete Fourier Transform of the effective spectral Green’s function. Compare $\\hat{G}_d(\\hat{\\mathbf{r}})$ to the continuum expression $\\hat{G}_c(\\hat{r}) = \\frac{1}{4\\pi \\hat{r}}$ (which corresponds to the physical $1/(4\\pi r)$ after appropriate scaling). All metrics you report must be dimensionless.\n\n4) Analyze anisotropy and deviation from the continuum:\n   - Group grid points into spherical shells by integer squared distance $s = i^2 + j^2 + k^2$, where $(i,j,k)$ are the shortest periodic displacements from the source. For each shell with radius $\\hat{r} = \\sqrt{s}$, compute:\n     a) The shell mean $\\overline{G}_s$ and shell standard deviation $\\sigma_s$ of $\\hat{G}_d$ values on that shell.\n     b) The shell anisotropy as $\\sigma_s / \\overline{G}_s$.\n     c) The shell relative error $\\delta_s = \\overline{G}_s / \\hat{G}_c(\\hat{r}) - 1$.\n   - Consider only shells with $\\hat{r}_{\\min} < \\hat{r} < \\hat{r}_{\\max}$ to avoid the singular cell at the origin and to reduce the influence of periodic images. Use $\\hat{r}_{\\min} = 1.5$ and $\\hat{r}_{\\max} = N/4$.\n   - Report two global metrics per case: the maximum shell anisotropy and the root-mean-square of the shell relative error, $\\sqrt{\\langle \\delta_s^2 \\rangle}$, averaging uniformly over the considered shells. Both metrics are dimensionless.\n\n5) Use the following test suite of parameter sets to exercise your implementation:\n   - Case 1 (happy path): $N = 32$, $h = 1.0$, shape = NGP.\n   - Case 2 (shape effect): $N = 32$, $h = 1.0$, shape = CIC.\n   - Case 3 (resolution/spacing variation): $N = 48$, $h = 0.5$, shape = CIC.\n\nYour program must perform the computation for all cases and print a single line containing a flat list of six floats: for each case in order, print the maximum shell anisotropy followed by the root-mean-square relative error. The required final output format is a single line:\n\"[a1,e1,a2,e2,a3,e3]\"\nwhere each number is rounded to exactly six digits after the decimal point. For example, a syntactically correct output could look like \"[0.123456,0.012345,0.234567,0.023456,0.345678,0.034567]\". The reported quantities are dimensionless, so no physical units are required or permitted in the output.", "solution": "The problem requires the construction and analysis of the discrete Green's function for a three-dimensional electrostatic Particle-In-Cell (PIC) solver on a periodic Cartesian grid. The analysis will focus on quantifying the anisotropy and deviation from the continuum solution introduced by the grid, the finite-difference operator, and the particle shape function.\n\nThe fundamental equation is Poisson's equation for the electrostatic potential $\\phi(\\mathbf{x})$ given a charge density $\\rho(\\mathbf{x})$:\n$$ \\nabla^2 \\phi(\\mathbf{x}) = -\\frac{\\rho(\\mathbf{x})}{\\varepsilon_0} $$\nWe consider a uniform Cartesian grid of size $N \\times N \\times N$ with grid spacing $h$. The positions on the grid are denoted by $\\mathbf{r}_{\\mathbf{j}} = (j_x h, j_y h, j_z h)$, where $\\mathbf{j} = (j_x, j_y, j_z)$ is a triplet of integer indices. The potential and charge density are discretized on this grid as $\\phi_{\\mathbf{j}} = \\phi(\\mathbf{r}_{\\mathbf{j}})$ and $\\rho_{\\mathbf{j}} = \\rho(\\mathbf{r}_{\\mathbf{j}})$.\n\nThe Laplacian operator $\\nabla^2$ is approximated using a second-order accurate central-difference stencil. In three dimensions, this discrete operator $D^2$ acting on the potential at grid point $\\mathbf{j}$ is:\n$$ (D^2 \\phi)_{\\mathbf{j}} = \\frac{\\phi_{\\mathbf{j}+\\mathbf{e}_x} - 2\\phi_{\\mathbf{j}} + \\phi_{\\mathbf{j}-\\mathbf{e}_x}}{h^2} + \\frac{\\phi_{\\mathbf{j}+\\mathbf{e}_y} - 2\\phi_{\\mathbf{j}} + \\phi_{\\mathbf{j}-\\mathbf{e}_y}}{h^2} + \\frac{\\phi_{\\mathbf{j}+\\mathbf{e}_z} - 2\\phi_{\\mathbf{j}} + \\phi_{\\mathbf{j}-\\mathbf{e}_z}}{h^2} $$\nwhere $\\mathbf{e}_x, \\mathbf{e}_y, \\mathbf{e}_z$ are unit vectors along the grid axes.\nWith this, the discrete Poisson equation is $(D^2 \\phi)_{\\mathbf{j}} = -\\rho_{\\mathbf{j}}/\\varepsilon_0$.\n\nDue to the periodic boundary conditions, this system is efficiently solved in Fourier space. The Discrete Fourier Transform (DFT) of a grid quantity $f_{\\mathbf{j}}$ is $\\tilde{f}_{\\mathbf{n}} = \\sum_{\\mathbf{j}} f_{\\mathbf{j}} e^{-i \\mathbf{k}_{\\mathbf{n}} \\cdot \\mathbf{r}_{\\mathbf{j}}}$, where the discrete wave vectors are $\\mathbf{k}_{\\mathbf{n}} = (2\\pi n_x/(Nh), 2\\pi n_y/(Nh), 2\\pi n_z/(Nh))$ for integer mode indices $\\mathbf{n}=(n_x, n_y, n_z)$. The DFT transforms the convolution-like difference operator into a simple multiplication. The Fourier representation (eigenvalue) of the discrete Laplacian operator is:\n$$ \\hat{D}^2(\\mathbf{k}_{\\mathbf{n}}) = \\sum_{i \\in \\{x,y,z\\}} \\frac{2}{h^2} (\\cos(k_{n_i} h) - 1) = -\\frac{4}{h^2} \\sum_{i \\in \\{x,y,z\\}} \\sin^2\\left(\\frac{k_{n_i} h}{2}\\right) $$\nSubstituting the expression for $k_{n_i}$, this becomes:\n$$ \\hat{D}^2(\\mathbf{n}) = -\\frac{4}{h^2} \\sum_{i \\in \\{x,y,z\\}} \\sin^2\\left(\\frac{\\pi n_i}{N}\\right) $$\nThe discrete Poisson equation in Fourier space is $\\hat{D}^2(\\mathbf{n}) \\tilde{\\phi}_{\\mathbf{n}} = -\\tilde{\\rho}_{\\mathbf{n}}/\\varepsilon_0$.\n\nThe discrete Green's function $G_d$ is the potential response to a single unit point charge $q=1$ placed at the origin grid point $\\mathbf{j}=(0,0,0)$. This corresponds to a discrete charge density $\\rho_{\\mathbf{j}} = \\delta_{\\mathbf{j}0} / h^3$, where $\\delta_{\\mathbf{j}0}$ is the Kronecker delta and $h^3$ is the cell volume. The DFT of this source is a constant, $\\tilde{\\rho}_{\\mathbf{n}} = 1/h^3$.\n\nIn a PIC simulation, the interaction between particles is softened by the particle shape function, used for both charge deposition onto the grid and field interpolation back to the particles. For a deposition function $W(\\mathbf{x})$ and interpolation function $I(\\mathbf{x})$, the effective potential felt by a test particle from a source particle is mediated by the solver and these two filters. In Fourier space, this leads to a modification of the interaction by the factor $\\tilde{I}^*(\\mathbf{k})\\tilde{W}(\\mathbf{k})$. The problem states that the deposition and interpolation functions are identical B-splines of order $m$, $W=I=S_m$, for which the Fourier transform is real. Thus, the effective interaction is modified by $|S_m(\\mathbf{k})|^2$. The problem gives the form:\n$$ S_m(k) = \\left[\\operatorname{sinc}\\left(\\frac{kh}{2}\\right)\\right]^{m+1} \\quad \\text{where } \\operatorname{sinc}(x) = \\frac{\\sin x}{x} $$\nThe total modification factor in three dimensions is $\\lvert S_m(\\mathbf{k}) \\rvert^2 = \\prod_{i=x,y,z}\\left[\\operatorname{sinc}\\!\\left(\\frac{k_i h}{2}\\right)\\right]^{2(m+1)}$.\n\nCombining these elements, the effective spectral potential $\\tilde{G}_{d, \\text{eff}}$ that describes the particle-particle interaction is:\n$$ \\tilde{G}_{d, \\text{eff}}(\\mathbf{n}) = \\frac{-\\tilde{\\rho}_{\\mathbf{n}}/\\varepsilon_0}{\\hat{D}^2(\\mathbf{n})} |S_m(\\mathbf{k}_{\\mathbf{n}})|^2 = \\frac{-(1/h^3)/\\varepsilon_0}{-\\frac{4}{h^2} \\sum_i \\sin^2(\\frac{\\pi n_i}{N})} \\prod_j \\left[\\operatorname{sinc}\\left(\\frac{\\pi n_j}{N}\\right)\\right]^{2(m+1)} $$\n$$ \\tilde{G}_{d, \\text{eff}}(\\mathbf{n}) = \\frac{1}{4 \\varepsilon_0 h} \\frac{\\prod_j \\left[\\operatorname{sinc}(\\pi n_j/N)\\right]^{2(m+1)}}{\\sum_i \\sin^2(\\pi n_i/N)} $$\nWe seek a dimensionless Green's function, $\\hat{G}_d$. The continuum Green's function is $G_c(r) = 1/(4\\pi\\varepsilon_0 r)$. The dimensionless comparison function is given as $\\hat{G}_c(\\hat{r}) = 1/(4\\pi\\hat{r})$, where $\\hat{r}=r/h$. This suggests a normalization of $4\\pi\\varepsilon_0 h$ and setting $\\varepsilon_0=1/(4\\pi)$. A more direct way is to define the dimensionless spectral Green's function $\\hat{\\tilde{G}}_d(\\mathbf{n})$ that, when transformed to real space, can be compared to $\\hat{G}_c(\\hat{r})$. From the expression for $\\tilde{G}_{d, \\text{eff}}$, we can formulate a dimensionless spectral function independent of $h$ and $\\varepsilon_0$:\n$$ \\hat{\\tilde{G}}_d(\\mathbf{n}) = \\frac{\\prod_{j \\in \\{x,y,z\\}} \\left[\\operatorname{sinc}(\\pi n_j/N)\\right]^{2(m+1)}}{4 \\sum_{i \\in \\{x,y,z\\}} \\sin^2(\\pi n_i/N)} $$\nThe mode for $\\mathbf{n}=(0,0,0)$ has a zero denominator and represents the mean potential. For periodic systems with implicit charge neutrality, this mode is set to zero, $\\hat{\\tilde{G}}_d(\\mathbf{0}) = 0$.\n\nThe computational procedure is as follows:\n1. For a given grid size $N$ and shape order $m$, construct the $3$D array $\\hat{\\tilde{G}}_d(\\mathbf{n})$ for all mode indices $\\mathbf{n}$.\n2. Compute the real-space dimensionless Green's function $\\hat{G}_d(\\hat{\\mathbf{r}})$ by performing a $3$D inverse DFT of $\\hat{\\tilde{G}}_d(\\mathbf{n})$.\n3. To analyze the result, grid points are grouped into shells of constant squared distance $s = i^2+j^2+k^2$ from the origin, where $(i,j,k)$ are the shortest periodic displacements. The shell radius is $\\hat{r} = \\sqrt{s}$.\n4. For each shell within the range $1.5 < \\hat{r} < N/4$, we compute:\n   - The shell mean $\\overline{G}_s$ and standard deviation $\\sigma_s$ of the values of $\\hat{G}_d$ on that shell.\n   - The shell anisotropy $\\alpha_s = \\sigma_s / \\overline{G}_s$.\n   - The continuum value $\\hat{G}_c(\\hat{r}) = 1/(4\\pi\\hat{r})$.\n   - The shell relative error $\\delta_s = \\overline{G}_s / \\hat{G}_c(\\hat{r}) - 1$.\n5. Finally, we compute two global metrics over all considered shells: the maximum shell anisotropy, $\\max(\\alpha_s)$, and the root-mean-square of the shell relative errors, $\\sqrt{\\langle \\delta_s^2 \\rangle}$. These two dimensionless quantities are calculated for each test case.", "answer": "```python\nimport numpy as np\n\ndef calculate_metrics(N, h, shape_str):\n    \"\"\"\n    Constructs and analyzes the discrete Green's function for a 3D PIC solver.\n\n    Args:\n        N (int): The number of grid points in each dimension.\n        h (float): The grid spacing (not used in the dimensionless calculation but kept for parameter consistency).\n        shape_str (str): The particle shape function, \"NGP\" or \"CIC\".\n\n    Returns:\n        tuple[float, float]: A tuple containing the maximum shell anisotropy and the RMS relative error.\n    \"\"\"\n    if shape_str == 'NGP':\n        m = 0\n    elif shape_str == 'CIC':\n        m = 1\n    else:\n        raise ValueError(\"Invalid shape string. Must be 'NGP' or 'CIC'.\")\n\n    # 1. Create wave-number index grid\n    n_coords_1d = np.fft.fftfreq(N) * N\n    nx, ny, nz = np.meshgrid(n_coords_1d, n_coords_1d, n_coords_1d, indexing='ij')\n\n    # 2. Numerator: Shape function factor |S_m(k)|^2\n    # np.sinc(x) computes sin(pi*x)/(pi*x). We need sinc(pi*n/N) = sin(pi*n/N)/(pi*n/N).\n    # This corresponds to np.sinc(n/N).\n    sinc_arg_x = nx / N\n    sinc_arg_y = ny / N\n    sinc_arg_z = nz / N\n\n    sinc_val_x = np.sinc(sinc_arg_x)\n    sinc_val_y = np.sinc(sinc_arg_y)\n    sinc_val_z = np.sinc(sinc_arg_z)\n\n    shape_factor_sq = (sinc_val_x * sinc_val_y * sinc_val_z)**(2 * (m + 1))\n\n    # 3. Denominator: Fourier representation of the -Laplacian operator\n    # Denom = 4 * sum(sin^2(pi*n_i/N))\n    K_sq = 4 * (np.sin(np.pi * nx / N)**2 + \n                np.sin(np.pi * ny / N)**2 + \n                np.sin(np.pi * nz / N)**2)\n\n    # 4. Spectral Green's function, handling k=0 singularity\n    with np.errstate(divide='ignore', invalid='ignore'):\n        G_k = shape_factor_sq / K_sq\n    \n    G_k[0, 0, 0] = 0.0 # Set DC mode to zero\n    \n    # 5. Inverse FFT to get real-space Green's function\n    G_r = np.real(np.fft.ifftn(G_k))\n\n    # 6. Analysis of anisotropy and error\n    r_min = 1.5\n    r_max = N / 4.0\n\n    # Create coordinate grid for distance calculation. fftshift centers the result.\n    G_r_shifted = np.fft.fftshift(G_r)\n    coords_1d = np.arange(-N // 2, N // 2)\n    ix, iy, iz = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n    s = ix**2 + iy**2 + iz**2\n    \n    # Group grid points into shells by squared distance 's'\n    shell_data = {}\n    unique_s_values = np.unique(s)\n    \n    for s_val in unique_s_values:\n        if s_val == 0:\n            continue\n        \n        r_val = np.sqrt(s_val)\n        \n        if r_min < r_val < r_max:\n            indices = np.where(s == s_val)\n            g_d_values = G_r_shifted[indices]\n            \n            mean_g = np.mean(g_d_values)\n            std_g = np.std(g_d_values)\n            \n            anisotropy = 0.0\n            if abs(mean_g) > 1e-16: # Avoid division by zero\n                anisotropy = std_g / mean_g\n            \n            g_c = 1.0 / (4.0 * np.pi * r_val)\n            rel_error = mean_g / g_c - 1.0\n            \n            shell_data[s_val] = {\n                'anisotropy': anisotropy, \n                'rel_error_sq': rel_error**2\n            }\n\n    # 7. Compute final global metrics\n    anisotropies = [d['anisotropy'] for d in shell_data.values()]\n    rel_errors_sq = [d['rel_error_sq'] for d in shell_data.values()]\n    \n    max_anisotropy = 0.0\n    if anisotropies:\n        max_anisotropy = np.max(anisotropies)\n        \n    rms_rel_error = 0.0\n    if rel_errors_sq:\n        rms_rel_error = np.sqrt(np.mean(rel_errors_sq))\n        \n    return max_anisotropy, rms_rel_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (32, 1.0, \"NGP\"),\n        (32, 1.0, \"CIC\"),\n        (48, 0.5, \"CIC\"),\n    ]\n\n    results = []\n    for N, h, shape in test_cases:\n        max_anisotropy, rms_rel_error = calculate_metrics(N, h, shape)\n        results.append(max_anisotropy)\n        results.append(rms_rel_error)\n\n    # Format the final output string\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2424113"}]}