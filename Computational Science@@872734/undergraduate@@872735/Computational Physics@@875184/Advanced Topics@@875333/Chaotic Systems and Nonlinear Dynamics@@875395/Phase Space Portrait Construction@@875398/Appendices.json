{"hands_on_practices": [{"introduction": "The first step in understanding the dynamics of a system is to locate its equilibrium states, or fixed points, where motion ceases. This exercise provides practice in the fundamental analytical technique of using nullclines—curves where either $\\dot{x}=0$ or $\\dot{y}=0$—to find these fixed points. By then analyzing the system's behavior near these points using the Jacobian matrix, we can classify their stability and build the essential skeleton of the phase portrait [@problem_id:2426866].", "problem": "Consider the autonomous planar system of Ordinary Differential Equations (ODEs)\n$$\n\\dot{x} = x\\left(6 - x - 2y\\right), \\qquad \\dot{y} = y\\left(7 - 2x - y\\right),\n$$\nwhich defines a two-dimensional phase flow on the first quadrant of the phase plane. A fixed point is any point $\\left(x^{\\ast}, y^{\\ast}\\right)$ for which $\\dot{x} = 0$ and $\\dot{y} = 0$. The Jacobian matrix of the vector field at a point $\\left(x, y\\right)$ is the $2 \\times 2$ matrix of first partial derivatives of the right-hand side with respect to $x$ and $y$.\n\nDetermine the unique fixed point with $x^{\\ast}  0$ and $y^{\\ast}  0$, and then evaluate the trace of the Jacobian matrix at that fixed point. Provide your final answer as a simplified exact value. Do not round your answer.", "solution": "The problem statement is first subjected to validation. It is a standard, well-posed problem in the mathematical analysis of dynamical systems, specifically a competitive Lotka-Volterra model. The problem is scientifically grounded, self-contained, and objective, with no evident flaws. Therefore, it is deemed valid, and we shall proceed with its solution.\n\nThe autonomous planar system of ordinary differential equations is given by:\n$$\n\\dot{x} = x\\left(6 - x - 2y\\right)\n$$\n$$\n\\dot{y} = y\\left(7 - 2x - y\\right)\n$$\nA fixed point, denoted by $\\left(x^{\\ast}, y^{\\ast}\\right)$, is a point in the phase space where the system is stationary, i.e., where $\\dot{x} = 0$ and $\\dot{y} = 0$. This condition yields the pair of algebraic equations:\n$$\nx\\left(6 - x - 2y\\right) = 0\n$$\n$$\ny\\left(7 - 2x - y\\right) = 0\n$$\nThe problem asks for the unique fixed point where both coordinates are strictly positive, $x^{\\ast}  0$ and $y^{\\ast}  0$. This requirement excludes any solutions where $x=0$ or $y=0$. Consequently, we must find the simultaneous solution to the system of linear equations derived from the non-zero factors:\n$$\n6 - x - 2y = 0 \\quad \\implies \\quad x + 2y = 6\n$$\n$$\n7 - 2x - y = 0 \\quad \\implies \\quad 2x + y = 7\n$$\nThis is a simple system of two linear equations in two variables. From the second equation, we can express $y$ in terms of $x$:\n$$\ny = 7 - 2x\n$$\nSubstituting this expression into the first equation gives:\n$$\nx + 2\\left(7 - 2x\\right) = 6\n$$\nSolving for $x$:\n$$\nx + 14 - 4x = 6\n$$\n$$\n-3x = 6 - 14\n$$\n$$\n-3x = -8\n$$\n$$\nx^{\\ast} = \\frac{8}{3}\n$$\nNow, we substitute this value of $x^{\\ast}$ back into the expression for $y$:\n$$\ny^{\\ast} = 7 - 2\\left(\\frac{8}{3}\\right) = 7 - \\frac{16}{3} = \\frac{21}{3} - \\frac{16}{3} = \\frac{5}{3}\n$$\nThe unique fixed point with positive coordinates is therefore $\\left(x^{\\ast}, y^{\\ast}\\right) = \\left(\\frac{8}{3}, \\frac{5}{3}\\right)$.\n\nThe next step is to compute the Jacobian matrix of the vector field at this fixed point. Let the vector field be $F(x, y) = (f(x, y), g(x, y))$, where $f(x, y) = \\dot{x} = 6x - x^2 - 2xy$ and $g(x, y) = \\dot{y} = 7y - 2xy - y^2$. The Jacobian matrix is defined as:\n$$\nJ(x, y) = \\begin{pmatrix} \\frac{\\partial f}{\\partial x}  \\frac{\\partial f}{\\partial y} \\\\ \\frac{\\partial g}{\\partial x}  \\frac{\\partial g}{\\partial y} \\end{pmatrix}\n$$\nWe compute the necessary partial derivatives:\n$$\n\\frac{\\partial f}{\\partial x} = \\frac{\\partial}{\\partial x}\\left(6x - x^2 - 2xy\\right) = 6 - 2x - 2y\n$$\n$$\n\\frac{\\partial f}{\\partial y} = \\frac{\\partial}{\\partial y}\\left(6x - x^2 - 2xy\\right) = -2x\n$$\n$$\n\\frac{\\partial g}{\\partial x} = \\frac{\\partial}{\\partial x}\\left(7y - 2xy - y^2\\right) = -2y\n$$\n$$\n\\frac{\\partial g}{\\partial y} = \\frac{\\partial}{\\partial y}\\left(7y - 2xy - y^2\\right) = 7 - 2x - 2y\n$$\nSo the Jacobian matrix is:\n$$\nJ(x, y) = \\begin{pmatrix} 6 - 2x - 2y  -2x \\\\ -2y  7 - 2x - 2y \\end{pmatrix}\n$$\nWe must evaluate this matrix at the fixed point $\\left(\\frac{8}{3}, \\frac{5}{3}\\right)$. A more direct way to evaluate the diagonal elements at the fixed point is to use the fixed point conditions themselves. For $\\frac{\\partial f}{\\partial x}$, we have:\n$$\n\\frac{\\partial f}{\\partial x} = (6 - x - 2y) - x\n$$\nAt the fixed point $\\left(x^{\\ast}, y^{\\ast}\\right)$, the term $(6 - x^{\\ast} - 2y^{\\ast})$ is equal to $0$ by definition. Therefore:\n$$\nJ_{11}\\left(x^{\\ast}, y^{\\ast}\\right) = -x^{\\ast} = -\\frac{8}{3}\n$$\nSimilarly, for $\\frac{\\partial g}{\\partial y}$:\n$$\n\\frac{\\partial g}{\\partial y} = (7 - 2x - y) - y\n$$\nAt the fixed point, the term $(7 - 2x^{\\ast} - y^{\\ast})$ is also equal to $0$. Thus:\n$$\nJ_{22}\\left(x^{\\ast}, y^{\\ast}\\right) = -y^{\\ast} = -\\frac{5}{3}\n$$\nThe trace of the Jacobian matrix, $\\text{Tr}(J)$, is the sum of its diagonal elements, $J_{11} + J_{22}$.\n$$\n\\text{Tr}\\left(J\\left(x^{\\ast}, y^{\\ast}\\right)\\right) = -\\frac{8}{3} + \\left(-\\frac{5}{3}\\right) = \\frac{-8 - 5}{3} = -\\frac{13}{3}\n$$\nThis is the required simplified exact value.", "answer": "$$\n\\boxed{-\\frac{13}{3}}\n$$", "id": "2426866"}, {"introduction": "While fixed points act as anchors for the dynamics, the global structure of a phase portrait is woven by the stable and unstable manifolds of saddle points. These curves, which act as separatrices, partition the phase space into regions of qualitatively different long-term behavior. This practice moves from local analysis to global computation, guiding you to numerically trace these crucial manifolds by integrating forward and backward in time from near a saddle point [@problem_id:2426894].", "problem": "You are to write a complete, runnable program that constructs a phase space portrait of a two-dimensional dynamical system by numerically computing both the stable and unstable manifolds of a saddle point. The program must implement and integrate a two-dimensional autonomous ordinary differential equation and automatically extract quantitative diagnostics of the computed manifolds. No plotting or file input/output is required; your program must produce a single-line textual output that contains the requested numerical metrics for a specified test suite of initial offsets.\n\nConsider the conservative planar system defined by the first-order equations\n$$\n\\frac{dx}{dt} = y, \\quad \\frac{dy}{dt} = x - x^{3}.\n$$\nThis system has a saddle equilibrium at the origin. The Jacobian at the origin is\n$$\nJ(0,0) = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix},\n$$\nwith eigenvalues $+1$ and $-1$ and corresponding unit eigenvectors along the directions of $(1,1)$ and $(1,-1)$, respectively. The stable and unstable manifolds of the saddle are defined as the sets of points whose trajectories approach the saddle as $t \\to +\\infty$ and $t \\to -\\infty$, respectively. The system is Hamiltonian with conserved energy\n$$\nH(x,y) = \\frac{y^{2}}{2} - \\frac{x^{2}}{2} + \\frac{x^{4}}{4},\n$$\nso that trajectories lie on level sets of $H$. The separatrix curves that form the global stable and unstable manifolds of the saddle are the level set $H(x,y) = 0$.\n\nYour tasks are:\n- Using the fundamental definitions above, construct numerical approximations to the unstable and stable manifolds that leave the origin in the first quadrant, by integrating initial conditions that are tangent to the corresponding linear eigen-directions and lie on the separatrix energy level $H = 0$. Do not use any explicit pre-constructed manifold formulas; compute initial conditions by enforcing $H(x,y)=0$ and tangency to the appropriate eigen-direction near the origin.\n- For the unstable manifold branch in the first quadrant, integrate forward in time until the trajectory first returns to the horizontal axis, that is, until $y=0$ is crossed from positive to zero. Record the $x$-coordinate at this crossing.\n- For the stable manifold branch in the fourth quadrant that approaches the origin, integrate backward in time (equivalently, integrate the system with reversed time) until the trajectory first reaches $y=0$ from negative values. Record the $x$-coordinate at this crossing.\n- For both branches, quantify how well your numerical trajectory adheres to the separatrix by computing the maximum absolute deviation of $H(x(t),y(t))$ from the initial energy value along the numerically integrated segment. Also quantify the local alignment with the linear eigenvector by computing the angle between the system vector field at the initial condition and the relevant eigenvector. The angle must be reported in radians.\n\nDesign your program to carry out the following test suite of three initial offsets, each specified by a small positive scalar $\\varepsilon$ that sets the initial distance from the origin along the appropriate eigen-direction, while remaining on the separatrix $H=0$:\n- Case $1$: $\\varepsilon = 10^{-6}$.\n- Case $2$: $\\varepsilon = 10^{-3}$.\n- Case $3$: $\\varepsilon = 10^{-2}$.\n\nImplementation requirements and conventions:\n- For the unstable branch in the first quadrant, choose an initial condition $(x_{0},y_{0})$ with $x_{0} = \\varepsilon$, $y_{0}  0$, on the level set $H=0$, and tangent to the unstable eigen-direction at the origin. Integrate forward in time until the first crossing of $y=0$ from positive to zero. To avoid the trivial crossing at the start, you must use direction-sensitive event detection for the condition $y=0$ and detect only crossings with decreasing $y$. Use a sufficiently large final integration time so that the crossing is detected for all given $\\varepsilon$. The expected crossing $x$-coordinate is near $\\sqrt{2}$; your program must compute the absolute difference between the measured crossing $x$ and $\\sqrt{2}$.\n- For the stable branch in the fourth quadrant, choose an initial condition $(x_{0},y_{0})$ with $x_{0} = \\varepsilon$, $y_{0}  0$, on the level set $H=0$, and tangent to the stable eigen-direction at the origin. Integrate backward in time until the first crossing of $y=0$ from negative to zero, and compute the absolute difference between the measured crossing $x$ and $\\sqrt{2}$.\n- For the unstable branch only, compute the angle in radians between the system vector field evaluated at $(x_{0},y_{0})$ and the unit unstable eigenvector at the origin. Report this angle as a nonnegative value in radians.\n- For the unstable branch only, report the maximum absolute deviation of the Hamiltonian $H$ along the integrated trajectory segment from its initial value. Since the initial condition is on $H=0$, this is simply the maximum absolute value of $H$ along the segment.\n\nAll angles must be reported in radians. There are no physical units.\n\nNumerical specifications:\n- Use an accurate time integrator with adaptive steps and event detection.\n- Use an integration horizon large enough to reach the first $y=0$ crossing for all cases, for example a maximum time of $T_{\\max} = 50$ in the forward or backward direction.\n- Use tolerances sufficiently tight to resolve the manifolds and events.\n\nFinal output format:\n- For each $\\varepsilon$ in the test suite, your program must output a list of four floating-point numbers in the order: $[\\text{unstable\\_apex\\_error}, \\text{unstable\\_angle\\_error}, \\text{unstable\\_max\\_energy\\_deviation}, \\text{stable\\_apex\\_error}]$.\n- Aggregate the results for the three cases into a single line printed to standard output, containing a list of the three per-case lists, for example\n$[[r_{11},r_{12},r_{13},r_{14}],[r_{21},r_{22},r_{23},r_{24}],[r_{31},r_{32},r_{33},r_{34}]]$,\nwith each $r_{ij}$ a floating-point number. The values must be rounded to six significant figures when printed.\n\nYour program must not read any input and must not produce any other output besides the single required line.", "solution": "The problem presented is a standard exercise in computational nonlinear dynamics and has been validated as scientifically sound, well-posed, and objective. It requires the numerical construction of stable and unstable manifolds for a two-dimensional Hamiltonian system and the calculation of specific quantitative metrics. We proceed with the solution.\n\nThe system is defined by the autonomous ordinary differential equations:\n$$\n\\frac{dx}{dt} = \\dot{x} = y\n$$\n$$\n\\frac{dy}{dt} = \\dot{y} = x - x^3\n$$\nThis system is conservative, derived from the Hamiltonian function $H(x,y)$:\n$$\nH(x,y) = \\frac{y^2}{2} - \\frac{x^2}{2} + \\frac{x^4}{4}\n$$\nThe dynamics are constrained to the level sets of this Hamiltonian. The equilibrium points are found by setting $\\dot{x}=0$ and $\\dot{y}=0$, which yields $y=0$ and $x - x^3 = 0$. The solutions are $(0,0)$, $(1,0)$, and $(-1,0)$. We are concerned with the equilibrium at the origin, $(0,0)$.\n\nThe stability of the origin is determined by the Jacobian matrix of the vector field $F(x,y) = (y, x-x^3)$:\n$$\nJ(x,y) = \\begin{pmatrix} \\frac{\\partial \\dot{x}}{\\partial x}  \\frac{\\partial \\dot{x}}{\\partial y} \\\\ \\frac{\\partial \\dot{y}}{\\partial x}  \\frac{\\partial \\dot{y}}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 0  1 \\\\ 1 - 3x^2  0 \\end{pmatrix}\n$$\nAt the origin, this becomes:\n$$\nJ(0,0) = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}\n$$\nThe eigenvalues $\\lambda$ are found from $\\det(J - \\lambda I) = 0$, which gives $\\lambda^2 - 1 = 0$, so $\\lambda_{1,2} = \\pm 1$. The presence of one positive and one negative eigenvalue confirms that the origin is a saddle point. The eigenvector for the unstable eigenvalue $\\lambda_u = +1$ is $\\vec{v}_u \\propto (1,1)$, and for the stable eigenvalue $\\lambda_s = -1$ is $\\vec{v}_s \\propto (1,-1)$. These eigenvectors define the local directions of the unstable and stable manifolds, respectively.\n\nThe global manifolds, which are also the separatrices of the phase space, correspond to the specific energy level that passes through the saddle point. Evaluating the Hamiltonian at the origin gives $H(0,0)=0$. Therefore, the stable and unstable manifolds lie on the curve defined by $H(x,y)=0$.\n\nTo numerically compute a branch of a manifold, we must select an initial condition $(x_0, y_0)$ that is infinitesimally displaced from the saddle point along the corresponding eigenvector and lies on the separatrix energy level. The problem specifies a displacement characterized by a small parameter $\\varepsilon$.\n\nFor the unstable manifold branch in the first quadrant ($x0, y0$), we set $x_0 = \\varepsilon$. The condition $H(\\varepsilon, y_0) = 0$ gives:\n$$\n\\frac{y_0^2}{2} - \\frac{\\varepsilon^2}{2} + \\frac{\\varepsilon^4}{4} = 0 \\implies y_0^2 = \\varepsilon^2 - \\frac{\\varepsilon^4}{2}\n$$\nSince we are in the first quadrant, we take the positive root:\n$$\ny_0 = \\sqrt{\\varepsilon^2 - \\frac{\\varepsilon^4}{2}} = \\varepsilon \\sqrt{1 - \\frac{\\varepsilon^2}{2}}\n$$\nFor small $\\varepsilon$, Taylor expansion shows $y_0 \\approx \\varepsilon(1 - \\varepsilon^2/4) \\approx \\varepsilon$. Thus, the initial point $(x_0, y_0)$ is approximately $(\\varepsilon, \\varepsilon)$, which is tangent to the unstable eigenvector direction $(1,1)$. We integrate this initial condition forward in time ($t0$) until the trajectory first crosses the x-axis, i.e., $y=0$. The crossing point $x_{cross}$ is found when the homoclinic loop closes. On the separatrix, this occurs when $H(x,0) = 0$, which implies $-\\frac{x^2}{2} + \\frac{x^4}{4} = 0$. The non-zero solutions are $x = \\pm\\sqrt{2}$. The first quadrant branch will cross at $x = \\sqrt{2}$. The first metric is the deviation from this exact value: $|x_{cross} - \\sqrt{2}|$.\n\nFor the stable manifold branch that approaches the origin from the fourth quadrant ($x0, y0$), we similarly set $x_0 = \\varepsilon$. The condition $H(\\varepsilon, y_0) = 0$ requires the negative root:\n$$\ny_0 = -\\sqrt{\\varepsilon^2 - \\frac{\\varepsilon^4}{2}} = -\\varepsilon \\sqrt{1 - \\frac{\\varepsilon^2}{2}}\n$$\nFor small $\\varepsilon$, $y_0 \\approx -\\varepsilon$, and the initial point $(x_0, y_0)$ is approximately $(\\varepsilon, -\\varepsilon)$, tangent to the stable eigenvector direction $(1,-1)$. To trace this manifold away from the origin, we must integrate backward in time ($t0$). The crossing point $x_{cross}$ on the $y=0$ axis is, by symmetry, also expected at $x=\\sqrt{2}$. The final metric is $|x_{cross} - \\sqrt{2}|$.\n\nThe remaining metrics are computed for the unstable branch. The angle error quantifies how well the true vector field at the initial point $(x_0, y_0)$ aligns with the linear approximation (the eigenvector $\\vec{v}_u=(1,1)$). The vector field is $\\vec{F}(x_0, y_0) = (y_0, x_0 - x_0^3)$. The angle $\\theta$ between $\\vec{F}$ and $\\vec{v}_u$ is calculated using the dot product formula:\n$$\n\\theta = \\arccos\\left(\\frac{\\vec{F}(x_0, y_0) \\cdot \\vec{v}_u}{||\\vec{F}(x_0, y_0)|| \\cdot ||\\vec{v}_u||}\\right)\n$$\nThe energy deviation measures the accuracy of the numerical integrator. Since the initial condition is exactly on the $H=0$ level set, the maximum absolute value of the Hamiltonian, $\\max_t |H(x(t), y(t))|$, along the computed trajectory segment quantifies the accumulated numerical error.\n\nThe numerical implementation will use a high-precision, adaptive-step differential equation solver equipped with event detection capabilities to accurately locate the $y=0$ crossings. `scipy.integrate.solve_ivp` is suited for this purpose. The integration is performed for each value of $\\varepsilon$ in the test suite, and the four specified metrics are computed and formatted as required.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef format_float(val):\n    \"\"\"Formats a float to 6 significant figures in scientific notation if needed.\"\"\"\n    return f\"{val:.6g}\"\n\ndef solve():\n    \"\"\"\n    Computes stable and unstable manifolds for a 2D dynamical system,\n    and extracts quantitative diagnostics for a suite of initial offsets.\n    \"\"\"\n    test_cases = [1e-6, 1e-3, 1e-2]\n    all_results = []\n    \n    # The ODE system dx/dt = y, dy/dt = x - x^3\n    def diffeq(t, state):\n        x, y = state\n        return [y, x - x**3]\n\n    # Hamiltonian H(x,y) = y^2/2 - x^2/2 + x^4/4\n    def hamiltonian(x, y):\n        return 0.5 * y**2 - 0.5 * x**2 + 0.25 * x**4\n\n    # Event for y=0 crossing with y decreasing\n    def event_y_zero_down(t, state):\n        return state[1]\n    event_y_zero_down.terminal = True\n    event_y_zero_down.direction = -1\n\n    # Event for y=0 crossing with y increasing\n    def event_y_zero_up(t, state):\n        return state[1]\n    event_y_zero_up.terminal = True\n    event_y_zero_up.direction = 1\n\n    # Theoretical x-crossing on the separatrix\n    x_apex_theoretical = np.sqrt(2.0)\n\n    # Unit unstable eigenvector direction\n    evec_u = np.array([1.0, 1.0])\n\n    # Numerical integration settings\n    t_max = 50.0\n    rtol = 1e-12\n    atol = 1e-12\n\n    for eps in test_cases:\n        case_results = []\n\n        # --- Unstable Manifold (Q1) ---\n        x0_u = eps\n        y0_u = eps * np.sqrt(1.0 - 0.5 * eps**2)\n        ic_u = [x0_u, y0_u]\n\n        # Integrate forward in time\n        sol_u = solve_ivp(\n            diffeq, [0, t_max], ic_u,\n            events=event_y_zero_down,\n            dense_output=True,\n            rtol=rtol, atol=atol\n        )\n\n        unstable_apex_error = np.nan\n        unstable_angle_error = np.nan\n        unstable_max_energy_deviation = np.nan\n\n        if sol_u.status == 1 and sol_u.t_events[0].size > 0:\n            # Metric 1: Apex error\n            x_cross_u = sol_u.y_events[0][0, 0]\n            unstable_apex_error = np.abs(x_cross_u - x_apex_theoretical)\n\n            # Metric 2: Angle error at initial condition\n            vf_at_ic = np.array([y0_u, x0_u - x0_u**3])\n            cos_theta = np.dot(vf_at_ic, evec_u) / (np.linalg.norm(vf_at_ic) * np.linalg.norm(evec_u))\n            # Clip to handle potential floating point inaccuracies for arccos\n            cos_theta = np.clip(cos_theta, -1.0, 1.0)\n            unstable_angle_error = np.arccos(cos_theta)\n\n            # Metric 3: Max energy deviation\n            h_values = hamiltonian(sol_u.y[0, :], sol_u.y[1, :])\n            unstable_max_energy_deviation = np.max(np.abs(h_values))\n\n        # --- Stable Manifold (Q4) ---\n        x0_s = eps\n        y0_s = -eps * np.sqrt(1.0 - 0.5 * eps**2)\n        ic_s = [x0_s, y0_s]\n\n        # Integrate backward in time\n        sol_s = solve_ivp(\n            diffeq, [0, -t_max], ic_s,\n            events=event_y_zero_up,\n            dense_output=True,\n            rtol=rtol, atol=atol\n        )\n\n        stable_apex_error = np.nan\n        if sol_s.status == 1 and sol_s.t_events[0].size > 0:\n            # Metric 4: Apex error\n            x_cross_s = sol_s.y_events[0][0, 0]\n            stable_apex_error = np.abs(x_cross_s - x_apex_theoretical)\n        \n        case_results = [\n            unstable_apex_error,\n            unstable_angle_error,\n            unstable_max_energy_deviation,\n            stable_apex_error\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string\n    formatted_results = []\n    for row in all_results:\n        formatted_row = f\"[{','.join([format_float(v) for v in row])}]\"\n        formatted_results.append(formatted_row)\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2426894"}, {"introduction": "Not all dynamics are described by continuous flows; discrete-time maps are equally fundamental, particularly for modeling chaotic systems and in computational methods. This exercise explores the famous Arnol'd's cat map, a classic example of chaos, to reveal a critical lesson in computational physics. You will investigate how the theoretical, beautifully intricate structure of a chaotic map is profoundly affected by the practical limitations of finite-precision computer arithmetic, highlighting the crucial distinction between a mathematical model and its computational implementation [@problem_id:2426915].", "problem": "Construct a computational experiment to analyze how limited-precision arithmetic affects the phase space portrait of the Arnol'd cat map. The Arnol'd cat map is the linear map on the two-dimensional torus defined by the matrix $A = \\begin{pmatrix}1  1 \\\\ 1  2\\end{pmatrix}$, acting on a point $z_n = (x_n,y_n)$ in the unit square with torus identification by $z_{n+1} = A z_n \\bmod 1$. In exact integer arithmetic on the discrete torus of size $N$, one can represent the phase space as the lattice $\\{0,1,\\dots,N-1\\}^2$ with the update rule $(x_{n+1},y_{n+1}) \\equiv (x_n+y_n, x_n + 2 y_n) \\bmod N$. In floating-point arithmetic on the continuous torus, one computes $z_{n+1} = A z_n \\bmod 1$ with finite precision, and, for the purpose of constructing a discrete phase space portrait at resolution $N$, bins a continuous point $(x,y)$ to the cell indices $(\\lfloor N x \\rfloor, \\lfloor N y \\rfloor)$.\n\nStarting from the fundamental facts that (i) a linear map with determinant equal to one is invertible over the integers and preserves area, and (ii) floating-point arithmetic represents only a finite subset of real numbers and introduces rounding at every operation, you will design a program that constructs and compares three induced maps on the $N \\times N$ grid:\n- An exact integer-arithmetic induced map $f_{\\text{int}}: \\{0,\\dots,N-1\\}^2 \\to \\{0,\\dots,N-1\\}^2$ given by $f_{\\text{int}}(x,y) = \\big((x+y) \\bmod N, (x+2y) \\bmod N\\big)$.\n- A floating-point (32-bit) induced map $f_{32}: \\{0,\\dots,N-1\\}^2 \\to \\{0,\\dots,N-1\\}^2$ obtained by interpreting $(x,y)$ as $(x/N,y/N)$ in the unit torus, evolving one step via $z \\mapsto A z \\bmod 1$ using single-precision floating-point arithmetic, and then binning to integers by $\\big(\\lfloor N x \\rfloor, \\lfloor N y \\rfloor\\big)$.\n- A floating-point (64-bit) induced map $f_{64}$ defined analogously but using double-precision floating-point arithmetic.\n\nYou must compute, for each $N$ in the test suite, the following quantifiable properties that characterize the long-term and global structure of the induced discrete dynamics:\n1. Bijection property of $f_{\\text{int}}$: a boolean indicating whether every grid point has exactly one preimage (equivalently, whether $f_{\\text{int}}$ is a permutation of the $N^2$ states).\n2. Largest cycle length for $f_{\\text{int}}$: the length of the largest directed cycle in the functional graph induced by $f_{\\text{int}}$ on the $N^2$ states.\n3. For $f_{32}$:\n   - The number of unreachable states (grid cells with in-degree zero under $f_{32}$).\n   - The maximum in-degree over all states.\n   - The largest cycle length in its functional graph.\n4. For $f_{64}$: the same three quantities as in item 3.\n\nAll computations are purely mathematical over integers and floating-point numbers, and no physical units or angles are involved.\n\nTest Suite:\n- Case 1: $N = 16$.\n- Case 2: $N = 31$.\n- Case 3: $N = 64$.\n\nYour program must:\n- Implement the three induced maps for each $N$ exactly as defined.\n- For each case, produce the list of eight results in the following order:\n  1. $f_{\\text{int}}$ bijection (boolean),\n  2. $f_{\\text{int}}$ largest cycle length (integer),\n  3. $f_{32}$ unreachable states (integer),\n  4. $f_{32}$ maximum in-degree (integer),\n  5. $f_{32}$ largest cycle length (integer),\n  6. $f_{64}$ unreachable states (integer),\n  7. $f_{64}$ maximum in-degree (integer),\n  8. $f_{64}$ largest cycle length (integer).\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case is represented as an inner list in the specified order, for example: \"[[b1,c1,u32_1,m32_1,l32_1,u64_1,m64_1,l64_1],[b2,c2,u32_2,m32_2,l32_2,u64_2,m64_2,l64_2],[b3,c3,u32_3,m32_3,l32_3,u64_3,m64_3,l64_3]]\". There must be no spaces anywhere in the output line.\n\nConstraints and Notes:\n- The algorithm must start from the definitions given above and must not use precomputed properties of specific $N$.\n- The cycle length is defined as the number of distinct states along a directed cycle; in a functional graph where every node has out-degree one, each weakly connected component contains exactly one directed cycle, and trees (if any) feed into cycles.\n- Ensure numerical stability in the floating-point modulo by using a definition equivalent to $x \\mapsto x - \\lfloor x \\rfloor$ applied componentwise, with operations performed at the target precision.", "solution": "The problem requires a computational analysis of the Arnol'd cat map under different arithmetic systems: exact integer arithmetic versus finite-precision floating-point arithmetic (single and double precision). The goal is to quantify the structural changes in the map's phase space portrait when discretized on an $N \\times N$ grid.\n\n**1. Theoretical Framework**\n\nThe Arnol'd cat map is a linear automorphism of the two-dimensional torus $\\mathbb{T}^2 = \\mathbb{R}^2 / \\mathbb{Z}^2$. It is defined by the transformation $z \\mapsto A z \\pmod 1$, where $z = (x,y)$ and $A = \\begin{pmatrix} 1  1 \\\\ 1  2 \\end{pmatrix}$. Tiling the unit square with an $N \\times N$ grid of discrete states $\\{ (i/N, j/N) \\}_{i,j=0}^{N-1}$ and considering dynamics over the integer lattice $\\{0, 1, \\dots, N-1\\}^2$ leads to the three induced maps to be studied.\n\n**Map 1: Exact Integer Arithmetic ($f_{\\text{int}}$)**\nThe map $f_{\\text{int}}: \\mathbb{Z}_N^2 \\to \\mathbb{Z}_N^2$ is defined by the linear transformation $(x,y) \\mapsto (x+y, x+2y) \\pmod N$. This is a transformation over the module $\\mathbb{Z}_N^2$ represented by the matrix $A$. A fundamental theorem of linear algebra over rings states that such a map is a bijection (a permutation) if and only if its determinant is a unit in the ring of integers modulo $N$, $\\mathbb{Z}_N$. The determinant of the matrix $A$ is $\\det(A) = (1)(2) - (1)(1) = 1$. Since $\\gcd(1, N) = 1$ for any integer $N \\geq 1$, the determinant is always a unit in $\\mathbb{Z}_N$. Consequently, the map $f_{\\text{int}}$ is an invertible transformation on the finite set of $N^2$ states for any $N$. This implies that $f_{\\text{int}}$ is always a permutation. The phase space of $f_{\\text{int}}$ thus consists of a set of disjoint cycles. Every state belongs to exactly one cycle and has a unique preimage. Therefore, the number of unreachable states must be $0$ and the maximum in-degree must be $1$. Our computational check for the bijection property will serve as a verification of this theoretical result and the correctness of our implementation.\n\n**Maps 2  3: Floating-Point Arithmetic ($f_{32}, f_{64}$)**\nThe maps $f_{32}$ and $f_{64}$ are constructed through a multi-step process:\n1.  Map an integer grid point $(x,y)$ to a continuous coordinate in the unit square: $(x', y') = (x/N, y/N)$.\n2.  Apply the transformation using finite-precision arithmetic (32-bit or 64-bit): $(x'', y'') = (x'+y', x'+2y')$.\n3.  Apply the modulo $1$ operation component-wise, e.g., $x''' = x'' - \\lfloor x'' \\rfloor$.\n4.  Bin the resulting continuous point back to the integer grid: $(\\lfloor N x''' \\rfloor, \\lfloor N y''' \\rfloor)$.\n\nThis process introduces unavoidable rounding errors at every arithmetic operation. Finite-precision floating-point numbers can only represent a discrete subset of the real numbers. As a result, the properties of the original map are not preserved. The induced maps $f_{32}$ and $f_{64}$ are no longer linear, nor are they guaranteed to be bijections. Multiple distinct initial states might be mapped to the same final state due to numerical collapse, leading to states with an in-degree greater than $1$. Conversely, this implies some states will have an in-degree of $0$, becoming \"unreachable\" or \"Garden of Eden\" states. The long-term dynamics are expected to converge to attractors, which in a finite state space must be cycles. These cycles are often much shorter than those observed in the exact integer system, and the phase space portrait is characterized by these attractor basins. The precision of the floating-point arithmetic ($32$-bit vs. $64$-bit) directly influences the severity of these effects; higher precision is expected to better approximate the ideal dynamics, but will not eliminate the fundamental issues.\n\n**2. Algorithmic Implementation**\n\nTo compute the required properties, we will model each induced map as a functional graph on a set of $N^2$ vertices. The vertices represent the grid cells, which we can conveniently flatten into a single integer index $i \\in \\{0, \\dots, N^2-1\\}$ via the mapping $(x,y) \\to i = x + N \\cdot y$.\n\n**2.1. Functional Graph Construction**\nFor each map $f \\in \\{f_{\\text{int}}, f_{32}, f_{64}\\}$, we construct a successor array `F` of size $N^2$. `F[i]` stores the flattened index of the state that state `i` evolves to in one step. This is accomplished by iterating through each state $i=0, \\dots, N^2-1$, un-flattening it to its $(x,y)$ coordinates, applying the respective map function, and storing the flattened index of the resulting state.\n-   The implementation for $f_{\\text{int}}$ uses standard integer arithmetic and the `%` operator for the modulo operation.\n-   The implementations for $f_{32}$ and $f_{64}$ use `numpy.float32` and `numpy.float64` data types explicitly to ensure the computations are performed at the specified precision. The calculation $(x/N, y/N)$ is performed first. The matrix multiplication is then carried out. The modulo $1$ operation is implemented as $u \\mapsto u - \\text{np.floor}(u)$. Finally, the result is scaled by $N$ and binned using `np.floor`.\n\n**2.2. Graph Analysis**\nOnce the successor array `F` for a map is constructed, we analyze its structure to extract the required metrics.\n\n**In-degree and Unreachability:** The in-degree of each state (vertex) is the number of other states that map to it. We can efficiently compute the in-degree for all states simultaneously by creating a histogram of the values in the successor array `F`. The `numpy.bincount` function is ideal for this task. After computing the `in_degree` array, the number of unreachable states is simply the count of entries equal to $0$, and the maximum in-degree is the maximum value in the array. For $f_{\\text{int}}$, the bijection property is confirmed if the number of unreachable states is $0$ and the maximum in-degree is $1$.\n\n**Largest Cycle Length:** A functional graph consists of one or more weakly connected components, each containing exactly one directed cycle. To find the largest cycle length, we perform a traversal of the graph. We use a `visited` array to keep track of which states have already been assigned to a component.\nWe iterate through all states $i = 0, \\dots, N^2-1$. If a state `i` is unvisited, we begin a new traversal from it. During the traversal from `i`, we keep track of the nodes in the current path and their distance from the start (`path` dictionary). We follow the successor links `curr = F[curr]` until we encounter a node that has been visited before.\n-   If the re-encountered node was visited *during the current traversal*, we have found a cycle. Its length is the current path length minus the path length at which the node was first seen. We update our global maximum cycle length if this cycle is larger.\n-   If the re-encountered node was visited as part of a *previous component's traversal*, our current path is a tree that feeds into a previously analyzed cycle. No new cycle is found.\nAll nodes visited during the traversal are marked with the current component's ID to prevent re-processing. This systematic approach guarantees that every cycle is found exactly once and the largest length is determined.", "answer": "```python\nimport numpy as np\n\ndef get_functional_graph(N, map_func, dtype=None):\n    \"\"\"\n    Constructs the functional graph (successor array) for a given map on an N x N grid.\n\n    Args:\n        N (int): The grid size.\n        map_func (function): The function defining the map.\n        dtype (numpy.dtype, optional): The floating-point precision to use.\n\n    Returns:\n        numpy.ndarray: An array where F[i] is the successor of state i.\n    \"\"\"\n    num_states = N * N\n    next_state = np.zeros(num_states, dtype=np.int64)\n\n    # Vectorized implementation for speed\n    indices = np.arange(num_states)\n    x = indices % N\n    y = indices // N\n\n    if dtype is not None:\n        x_next, y_next = map_func(x, y, N, dtype)\n    else:\n        x_next, y_next = map_func(x, y, N)\n\n    next_state = (x_next + N * y_next).astype(np.int64)\n    \n    return next_state\n\ndef analyze_graph(F, N):\n    \"\"\"\n    Analyzes a functional graph to find unreachable states, max in-degree, and largest cycle length.\n\n    Args:\n        F (numpy.ndarray): The successor array of the graph.\n        N (int): The grid size.\n\n    Returns:\n        tuple: (unreachable_states, max_indegree, largest_cycle_length).\n    \"\"\"\n    num_states = N * N\n    if num_states == 0:\n        return 0, 0, 0\n\n    # In-degree and unreachability analysis\n    in_degree = np.bincount(F, minlength=num_states)\n    unreachable_states = np.sum(in_degree == 0)\n    max_indegree = np.max(in_degree)\n\n    # Cycle analysis\n    largest_cycle_length = 0\n    visited = np.zeros(num_states, dtype=np.int32)  # 0: unvisited, >0: component_id\n    component_id = 1\n\n    for i in range(num_states):\n        if visited[i] > 0:\n            continue\n\n        path = {}  # node -> path length from start of trace\n        curr = i\n        k = 0\n        while visited[curr] == 0:\n            visited[curr] = component_id\n            path[curr] = k\n            curr = F[curr]\n            k += 1\n\n        if visited[curr] == component_id:\n            # Cycle found in the current component\n            cycle_len = k - path[curr]\n            if cycle_len > largest_cycle_length:\n                largest_cycle_length = cycle_len\n\n        component_id += 1\n\n    return int(unreachable_states), int(max_indegree), int(largest_cycle_length)\n\n# Map definitions (vectorized)\ndef f_int(x, y, N):\n    x_next = (x + y) % N\n    y_next = (x + 2 * y) % N\n    return x_next, y_next\n\ndef f_float(x, y, N, dtype):\n    N_f = dtype(N)\n    one_f = dtype(1)\n    two_f = dtype(2)\n\n    x_c = x.astype(dtype) / N_f\n    y_c = y.astype(dtype) / N_f\n\n    x_next_c = x_c + y_c\n    y_next_c = x_c + two_f * y_c\n\n    # Modulo 1 operation\n    x_next_c -= np.floor(x_next_c)\n    y_next_c -= np.floor(y_next_c)\n\n    # Binning\n    x_next = np.floor(N_f * x_next_c)\n    y_next = np.floor(N_f * y_next_c)\n\n    return x_next, y_next\n\ndef solve_for_N(N):\n    \"\"\"\n    Solves the problem for a single value of N.\n    \"\"\"\n    # Integer map analysis\n    F_int = get_functional_graph(N, f_int)\n    unreachable_int, max_indegree_int, lcl_int = analyze_graph(F_int, N)\n    is_bijection = (unreachable_int == 0) and (max_indegree_int == 1)\n\n    # Float32 map analysis\n    F_32 = get_functional_graph(N, f_float, dtype=np.float32)\n    unreachable_32, max_indegree_32, lcl_32 = analyze_graph(F_32, N)\n\n    # Float64 map analysis\n    F_64 = get_functional_graph(N, f_float, dtype=np.float64)\n    unreachable_64, max_indegree_64, lcl_64 = analyze_graph(F_64, N)\n\n    return [\n        is_bijection, lcl_int,\n        unreachable_32, max_indegree_32, lcl_32,\n        unreachable_64, max_indegree_64, lcl_64\n    ]\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the final result.\n    \"\"\"\n    test_cases = [16, 31, 64]\n    \n    all_results = []\n    for N in test_cases:\n        results_for_N = solve_for_N(N)\n        all_results.append(results_for_N)\n        \n    # Format the output string according to the problem specification.\n    # e.g., [[val1,val2,...],[val1,val2,...]]\n    output_str = f\"[{','.join(f'[{\",\".join(map(str, res))}]' for res in all_results)}]\"\n    output_str = output_str.replace(\"True\", \"True\").replace(\"False\", \"False\")\n    print(output_str)\n\nsolve()\n```", "id": "2426915"}]}