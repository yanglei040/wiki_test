{"hands_on_practices": [{"introduction": "This first exercise takes a 'reverse-engineering' approach to connect the geometry of a phase space trajectory with its underlying physical laws. For a simple system with one degree of freedom, the trajectory itself forms a constant-energy curve. By analyzing the shape of this curve—in this case, a simple ellipse—you can deduce the form of the Hamiltonian that governs the system's dynamics [@problem_id:2427582]. This practice reinforces the fundamental principle that the Hamiltonian function shapes the geometry of motion in phase space.", "problem": "Consider a time-independent Hamiltonian system with one degree of freedom in canonical coordinates $(q,p)$. For such a system, the invariant curves observed in a Poincaré section coincide with the constant-energy level sets of the Hamiltonian in the $(q,p)$ plane. An experimentally obtained Poincaré section at a particular energy shows a single invariant curve given by the ellipse\n$$(\\tfrac{q}{2})^{2}+(\\tfrac{p}{3})^{2}=1.$$\nAssume dimensionless units with unit mass, and that the Hamiltonian is the simplest positive-definite quadratic form separable into kinetic and potential energy,\n$$H(q,p)=\\tfrac{1}{2}p^{2}+\\tfrac{1}{2}k q^{2},$$\nwith $k0$ to be determined so that the given ellipse is exactly one of its constant-energy curves. Determine the explicit closed-form expression for $H(q,p)$.\n\nExpress your final answer as a single analytic expression in $(q,p)$ using dimensionless units. No rounding is required.", "solution": "The problem statement is subjected to rigorous validation.\n\nStep 1: Extract Givens.\n- A time-independent Hamiltonian system with one degree of freedom in canonical coordinates $(q,p)$.\n- A specific invariant curve from a Poincaré section is given by the equation of an ellipse: $(\\frac{q}{2})^{2}+(\\frac{p}{3})^{2}=1$.\n- Dimensionless units are assumed, with unit mass. The Hamiltonian takes the form $H(q,p)=\\frac{1}{2}p^{2}+\\frac{1}{2}k q^{2}$.\n- The parameter $k$ is positive, $k0$.\n- The task is to find the explicit closed-form expression for $H(q,p)$.\n\nStep 2: Validate Using Extracted Givens.\n- Scientific Grounding: The problem describes a simple harmonic oscillator, a fundamental model in classical mechanics. The correspondence between constant-energy surfaces in phase space and system trajectories is a core tenet of Hamiltonian dynamics. The specified form of the Hamiltonian is standard for a harmonic oscillator with unit mass. The problem is scientifically sound.\n- Well-Posedness: The problem provides the functional form of the Hamiltonian with one unknown parameter, $k$, and a constraint (the equation of a specific energy level set). This is sufficient information to uniquely determine $k$ and thus the Hamiltonian. The problem is well-posed.\n- Objectivity: The problem is stated in precise, quantitative terms, free of ambiguity or subjective claims.\n\nStep 3: Verdict and Action.\nThe problem is valid as it is scientifically grounded, well-posed, objective, and contains sufficient information for a unique solution. I will proceed with the derivation of the solution.\n\nThe problem states that for a one-degree-of-freedom, time-independent Hamiltonian system, the constant-energy level sets in phase space are the invariant curves. The Hamiltonian is given in the form of a simple harmonic oscillator:\n$$H(q,p) = \\frac{1}{2}p^{2} + \\frac{1}{2}k q^{2}$$\nwhere $k0$ is a constant to be determined. A constant-energy curve is defined by the equation $H(q,p) = E$ for some constant energy $E$.\n$$\\frac{1}{2}p^{2} + \\frac{1}{2}k q^{2} = E$$\nSince the Hamiltonian is a sum of squares with $k0$, it is a positive-definite quadratic form. For a non-trivial ellipse as given, the energy must be positive, $E0$. To compare this equation to the standard form of an ellipse, we divide by $E$:\n$$\\frac{p^{2}}{2E} + \\frac{k q^{2}}{2E} = 1$$\nThis equation can be rewritten in the canonical form for an ellipse, $\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1$, as:\n$$\\left(\\frac{q}{\\sqrt{\\frac{2E}{k}}}\\right)^{2} + \\left(\\frac{p}{\\sqrt{2E}}\\right)^{2} = 1$$\nThis equation describes the family of all possible constant-energy curves for the given Hamiltonian form.\n\nThe problem provides an experimentally determined invariant curve, which must correspond to one specific energy level. The equation for this curve is:\n$$\\left(\\frac{q}{2}\\right)^{2} + \\left(\\frac{p}{3}\\right)^{2} = 1$$\nBy comparing the two expressions for the ellipse, we can equate the semi-axes in the $q$ and $p$ directions.\nThe semi-axis in the $q$ direction gives the equation:\n$$\\sqrt{\\frac{2E}{k}} = 2$$\nThe semi-axis in the $p$ direction gives the equation:\n$$\\sqrt{2E} = 3$$\nThis provides a system of two equations for the two unknowns, $E$ and $k$. From the second equation, we can solve for the energy $E$ of this specific invariant curve. Squaring both sides yields:\n$$2E = 9 \\implies E = \\frac{9}{2}$$\nNow, we substitute this value of $E$ into the first equation to solve for $k$:\n$$\\sqrt{\\frac{2\\left(\\frac{9}{2}\\right)}{k}} = 2$$\n$$\\sqrt{\\frac{9}{k}} = 2$$\nSquaring both sides of this equation gives:\n$$\\frac{9}{k} = 4$$\nSolving for $k$, we find:\n$$k = \\frac{9}{4}$$\nThis value satisfies the condition $k0$. The problem asks for the explicit closed-form expression for the Hamiltonian $H(q,p)$, not the energy of the particular observed curve. We now substitute the determined value of $k$ back into the general form of the Hamiltonian:\n$$H(q,p) = \\frac{1}{2}p^{2} + \\frac{1}{2}\\left(\\frac{9}{4}\\right)q^{2}$$\nSimplifying this expression gives the final form of the Hamiltonian:\n$$H(q,p) = \\frac{1}{2}p^{2} + \\frac{9}{8}q^{2}$$\nThis is the Hamiltonian that generates the given ellipse as its constant-energy curve for $E = \\frac{9}{2}$.", "answer": "$$\\boxed{\\frac{1}{2}p^{2} + \\frac{9}{8}q^{2}}$$", "id": "2427582"}, {"introduction": "Moving from a continuous trajectory to a discrete map, this problem explores the nuances of stroboscopic sampling. We use the familiar simple harmonic oscillator but observe it with a 'strobe light' whose frequency is slightly detuned from a perfect rational multiple of the oscillator's natural frequency. This exercise [@problem_id:2427546] challenges you to predict the resulting 'beat' pattern, providing deep insight into how the relationship between system frequencies and observation frequencies generates complex patterns even in simple systems.", "problem": "A point mass of mass $m$ is attached to a linear spring of stiffness $k$ and undergoes one-dimensional simple harmonic motion without damping. The angular frequency is $\\omega = \\sqrt{k/m}$. Let the position be $x(t)$ and the velocity be $v(t) = \\dot{x}(t)$. A stroboscopic Poincaré section is constructed by sampling the state $(x,v)$ at times $t_{n} = n T_{s}$ with a fixed strobe period $T_{s} = 2\\pi/\\Omega$, where the strobe angular frequency is\n$$\n\\Omega = \\frac{p}{q}\\,\\omega + \\delta,\n$$\nwith $p$ and $q$ coprime positive integers and a small detuning $|\\delta| \\ll \\omega$. The phase advance of the oscillator between successive strobes is measured in radians. Define the relative stroboscopic phase slip per strobe as the difference between the actual phase advance for the detuned strobe frequency and the phase advance in the exactly commensurate case $\\delta = 0$. Let $N_{\\mathrm{beat}}$ denote the number of strobes required for this relative phase to slip by a full $2\\pi$.\n\nDerive, to leading nonvanishing order in the small parameter $\\delta/\\omega$, a closed-form analytic expression for $N_{\\mathrm{beat}}$ in terms of $\\omega$, $p$, $q$, and $\\delta$. Provide your final answer as a single expression. Angles are measured in radians. No numerical evaluation is required.", "solution": "The problem statement has been validated and is deemed to be scientifically grounded, well-posed, and objective. It is a standard problem in the analysis of classical dynamical systems. We may therefore proceed with the derivation.\n\nThe state of a one-dimensional simple harmonic oscillator is described by its position $x(t)$ and velocity $v(t)$. In the phase plane $(x, v)$, the state vector traces an ellipse. The evolution of the system can be characterized by a single phase angle $\\phi(t)$ which evolves linearly with time: $\\phi(t) = \\omega t + \\phi_0$, where $\\omega$ is the natural angular frequency of the oscillator and $\\phi_0$ is the initial phase.\n\nA stroboscopic Poincaré section is constructed by observing the system at discrete time intervals $t_n = n T_s$, where $n$ is an integer and $T_s$ is the fixed strobe period. The phase of the oscillator at the $n$-th strobe is $\\phi(t_n) = \\omega t_n + \\phi_0$. The phase advance of the oscillator between two consecutive strobes, i.e., from time $t_n$ to $t_{n+1}$, is given by\n$$\n\\Delta\\phi = \\phi(t_{n+1}) - \\phi(t_n) = \\omega(t_{n+1} - t_n) = \\omega T_s.\n$$\nThe strobe period $T_s$ is related to the strobe angular frequency $\\Omega$ by $T_s = \\frac{2\\pi}{\\Omega}$. Thus, the phase advance per strobe is\n$$\n\\Delta\\phi = \\omega \\frac{2\\pi}{\\Omega}.\n$$\nThe problem specifies the strobe frequency as $\\Omega = \\frac{p}{q}\\omega + \\delta$, where $p$ and $q$ are coprime positive integers and $\\delta$ is a small detuning such that $|\\delta| \\ll \\omega$. We can express the phase advance $\\Delta\\phi$ as a function of $\\delta$:\n$$\n\\Delta\\phi(\\delta) = \\frac{2\\pi\\omega}{\\frac{p}{q}\\omega + \\delta}.\n$$\nThe problem defines the \"relative stroboscopic phase slip per strobe\" as the difference between the actual phase advance $\\Delta\\phi(\\delta)$ and the phase advance in the exactly commensurate case, $\\Delta\\phi_0$, which corresponds to $\\delta=0$. We first calculate $\\Delta\\phi_0$:\n$$\n\\Delta\\phi_0 = \\Delta\\phi(\\delta=0) = \\frac{2\\pi\\omega}{\\frac{p}{q}\\omega} = \\frac{2\\pi q}{p}.\n$$\nThe relative phase slip per strobe, which we denote as $\\Delta\\phi_{\\text{slip}}$, is therefore\n$$\n\\Delta\\phi_{\\text{slip}} = \\Delta\\phi(\\delta) - \\Delta\\phi_0 = \\frac{2\\pi\\omega}{\\frac{p}{q}\\omega + \\delta} - \\frac{2\\pi q}{p}.\n$$\nTo simplify this expression, we find a common denominator:\n$$\n\\Delta\\phi_{\\text{slip}} = 2\\pi \\left( \\frac{\\omega}{\\frac{p\\omega + q\\delta}{q}} - \\frac{q}{p} \\right) = 2\\pi \\left( \\frac{q\\omega}{p\\omega + q\\delta} - \\frac{q}{p} \\right).\n$$\n$$\n\\Delta\\phi_{\\text{slip}} = 2\\pi q \\left( \\frac{p\\omega - (p\\omega + q\\delta)}{p(p\\omega + q\\delta)} \\right) = 2\\pi q \\left( \\frac{-q\\delta}{p(p\\omega + q\\delta)} \\right) = -\\frac{2\\pi q^2 \\delta}{p^2\\omega + pq\\delta}.\n$$\nThe problem requires the result to the leading nonvanishing order in the small parameter $\\delta/\\omega$. We perform a Taylor expansion of $\\Delta\\phi_{\\text{slip}}$ for small $\\delta$. We can write the expression as:\n$$\n\\Delta\\phi_{\\text{slip}} = -\\frac{2\\pi q^2 \\delta}{p^2\\omega (1 + \\frac{q\\delta}{p\\omega})}.\n$$\nUsing the geometric series expansion $(1+x)^{-1} = 1 - x + O(x^2)$ for small $x = \\frac{q\\delta}{p\\omega}$, we get:\n$$\n\\Delta\\phi_{\\text{slip}} \\approx -\\frac{2\\pi q^2 \\delta}{p^2\\omega} \\left(1 - \\frac{q\\delta}{p\\omega}\\right) = -\\frac{2\\pi q^2 \\delta}{p^2\\omega} + O(\\delta^2).\n$$\nThe leading nonvanishing order term is linear in $\\delta$:\n$$\n\\Delta\\phi_{\\text{slip, leading order}} = -\\frac{2\\pi q^2 \\delta}{p^2\\omega}.\n$$\nThe quantity $N_{\\mathrm{beat}}$ is defined as the number of strobes required for the cumulative relative phase slip to reach $2\\pi$. Since $N_{\\mathrm{beat}}$ must be a positive quantity, we must use the magnitude of the phase slip per strobe. The total phase slip after $N_{\\mathrm{beat}}$ strobes is $N_{\\mathrm{beat}} |\\Delta\\phi_{\\text{slip, leading order}}|$. We set this equal to $2\\pi$:\n$$\nN_{\\mathrm{beat}} \\left| -\\frac{2\\pi q^2 \\delta}{p^2\\omega} \\right| = 2\\pi.\n$$\n$$\nN_{\\mathrm{beat}} \\frac{2\\pi q^2 |\\delta|}{p^2\\omega} = 2\\pi.\n$$\nSolving for $N_{\\mathrm{beat}}$, we cancel the $2\\pi$ term from both sides:\n$$\nN_{\\mathrm{beat}} = \\frac{p^2\\omega}{q^2|\\delta|}.\n$$\nThis is the closed-form analytic expression for $N_{\\mathrm{beat}}$ to the leading order in $\\delta$. It is given in terms of the specified parameters $\\omega$, $p$, $q$, and $\\delta$ (from which $|\\delta|$ is determined).", "answer": "$$\n\\boxed{\\frac{p^2 \\omega}{q^2 |\\delta|}}\n$$", "id": "2427546"}, {"introduction": "Our final practice ventures into the domain of chaos, where analytical solutions are no longer possible and computational tools are essential. You will generate a Poincaré section for the famous Duffing oscillator, revealing the intricate structure of its strange attractor. More importantly, this exercise [@problem_id:2427621] requires you to compare the results from a simple, first-order numerical integrator with a more robust fourth-order method, quantifying how numerical inaccuracies can distort the very structure you are trying to study. This is a crucial lesson in computational physics: understanding the limitations of your tools is as important as understanding the physics of the system itself.", "problem": "You will study how the choice of time-integration method affects the geometry of a Poincaré section for the forced Duffing oscillator. The Duffing oscillator is governed by the autonomous first-order system obtained from the second-order equation $$\\frac{d^2 x}{dt^2} + \\delta \\frac{dx}{dt} + \\alpha x + \\beta x^3 = \\gamma \\cos(\\omega t),$$ rewritten as $$\\frac{dx}{dt} = v,\\quad \\frac{dv}{dt} = -\\delta v - \\alpha x - \\beta x^3 + \\gamma \\cos(\\phi),\\quad \\frac{d\\phi}{dt} = \\omega,$$ where $x$ is the displacement, $v$ is the velocity, and $\\phi$ is the drive phase. The Poincaré section with respect to the drive is the set of states sampled at times when $\\phi$ is an integer multiple of $2\\pi$. Your task is to implement and compare two numerical time integrators, the explicit Euler method and the classical fourth-order Runge–Kutta method, and quantify how their numerical errors distort the Poincaré section of a chaotic Duffing attractor.\n\nStart from the foundational definitions of initial value problems for ordinary differential equations, the concept of a Poincaré map as stroboscopic sampling at a fixed phase, and deterministic numerical integration for time stepping. Do not assume any special-purpose formulas other than the standard update rules for the explicit Euler and classical fourth-order Runge–Kutta methods applied to $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y},t)$.\n\nUse the following physically plausible and widely studied parameter set for chaos in the Duffing oscillator: $$\\alpha = -1.0,\\ \\beta = 1.0,\\ \\delta = 0.3,\\ \\gamma = 0.37,\\ \\omega = 1.2.$$ Use initial conditions $$x(0) = 0,\\ v(0) = 0,\\ \\phi(0) = 0.$$ Interpret $t$ in seconds, $\\phi$ in radians, and treat $x$ and $v$ as dimensionless. Construct the Poincaré section by detecting successive crossings of $\\phi = 2\\pi k$ with $k \\in \\mathbb{Z}_{\\ge 1}$ and use linear interpolation between time steps to sample the state at the exact crossing. Discard the first $200$ crossings as transient, then collect the next $300$ Poincaré points $\\{(x_k, v_k)\\}$.\n\nTo quantify the geometric difference between two Poincaré sections $\\mathcal{A} = \\{(x_i, v_i)\\}_{i=1}^{N}$ and $\\mathcal{B} = \\{(x'_j, v'_j)\\}_{j=1}^{M}$, compute the symmetric average nearest-neighbor distance $$D(\\mathcal{A},\\mathcal{B}) = \\tfrac{1}{2}\\left(\\frac{1}{N}\\sum_{i=1}^{N} \\min_{1 \\le j \\le M} \\sqrt{(x_i - x'_j)^2 + (v_i - v'_j)^2} + \\frac{1}{M}\\sum_{j=1}^{M} \\min_{1 \\le i \\le N} \\sqrt{(x'_j - x_i)^2 + (v'_j - v_i)^2}\\right).$$\n\nImplement both the explicit Euler method and the classical fourth-order Runge–Kutta method for the autonomous system above and compute Poincaré sections for the following four test cases. In all cases, report $D(\\mathcal{A},\\mathcal{B})$ as a floating-point number rounded to $6$ decimal places. The time step $h$ is in seconds.\n\nTest suite:\n- Case $1$ (happy path): Compare explicit Euler versus classical fourth-order Runge–Kutta with $h = 0.02$.\n- Case $2$ (coarser step): Compare explicit Euler versus classical fourth-order Runge–Kutta with $h = 0.05$.\n- Case $3$ (method consistency control): Compare classical fourth-order Runge–Kutta with $h = 0.02$ against classical fourth-order Runge–Kutta with $h = 0.01$.\n- Case $4$ (Euler self-consistency): Compare explicit Euler with $h = 0.02$ against explicit Euler with $h = 0.01$.\n\nAngle units must be radians. The final output must be four floats, each equal to the $D(\\mathcal{A},\\mathcal{B})$ for the corresponding case, rounded to $6$ decimals. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\") with no additional text.\n\nEnsure scientific realism: use the precise phase-crossing construction for the Poincaré section with linear interpolation, deterministic stepping, and the stated parameter values, and perform all computations in double precision. The answers for each test case are floats without units because they are distances in the dimensionless $(x,v)$ plane. Angles must be in radians and time in seconds throughout.", "solution": "The problem presented requires a quantitative comparison of two numerical integration schemes—the explicit Euler method and the classical fourth-order Runge-Kutta method—by analyzing their effect on the computed Poincaré section of a forced Duffing oscillator. This analysis falls within the domain of computational dynamics and the study of numerical artifacts in simulations of chaotic systems. The problem is well-posed, scientifically grounded, and provides all necessary specifications for a rigorous solution.\n\nThe foundational physical system is the forced Duffing oscillator, a second-order non-linear ordinary differential equation (ODE) for displacement $x(t)$:\n$$\n\\frac{d^2 x}{dt^2} + \\delta \\frac{dx}{dt} + \\alpha x + \\beta x^3 = \\gamma \\cos(\\omega t)\n$$\nTo facilitate numerical integration, this equation is transformed into an autonomous system of three first-order ODEs by defining the state vector $\\mathbf{y}(t) = [x(t), v(t), \\phi(t)]^T$, where $v = dx/dt$ is the velocity and $\\phi = \\omega t$ is the phase of the external drive. The system is then given by $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$:\n$$\n\\frac{dx}{dt} = v\n$$\n$$\n\\frac{dv}{dt} = -\\delta v - \\alpha x - \\beta x^3 + \\gamma \\cos(\\phi)\n$$\n$$\n\\frac{d\\phi}{dt} = \\omega\n$$\nThe problem specifies the parameters for chaotic behavior: $\\alpha = -1.0$, $\\beta = 1.0$, $\\delta = 0.3$, $\\gamma = 0.37$, and $\\omega = 1.2$. The initial conditions are set to $\\mathbf{y}(0) = [0, 0, 0]^T$.\n\nNumerical integration methods are employed to approximate the solution trajectory $\\mathbf{y}(t)$ at discrete time steps. We consider a time step $h$. The state at time $t_{n+1} = t_n + h$ is approximated from the state at time $t_n$.\n\nFirst, the explicit Euler method is a first-order method defined by the update rule:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\cdot \\mathbf{f}(\\mathbf{y}_n)\n$$\nThis method is simple but has a local truncation error of order $O(h^2)$ and a global error of order $O(h)$, making it relatively inaccurate and potentially unstable for stiff or chaotic systems.\n\nSecond, the classical fourth-order Runge-Kutta method (RK4) provides a more accurate approximation. It is a fourth-order method with a global error of order $O(h^4)$. The update rule is given by:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nwhere the intermediate slopes are:\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n)\n$$\n$$\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1)\n$$\n$$\n\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_2)\n$$\n$$\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + h \\mathbf{k}_3)\n$$\n\nThe Poincaré section provides a method to visualize the dynamics of the system in a lower-dimensional space. For this periodically driven system, we use a stroboscopic map, sampling the state $(x, v)$ whenever the drive phase $\\phi$ crosses a multiple of $2\\pi$. Since $\\phi(0)=0$ and $\\dot{\\phi}=\\omega$ is a positive constant, we monitor the trajectory and record the state at times $t_k$ such that $\\phi(t_k) = 2\\pi k$ for integers $k \\ge 1$. A numerical time step from $\\mathbf{y}_n$ at $t_n$ to $\\mathbf{y}_{n+1}$ at $t_{n+1}$ may span such a crossing. If $\\phi_n  2\\pi k \\le \\phi_{n+1}$ for some integer $k$, a crossing has occurred. The state $(x^*, v^*)$ on the Poincaré section is found using linear interpolation. The interpolation factor $\\theta \\in [0, 1]$ is calculated from the phase:\n$$\n\\theta = \\frac{2\\pi k - \\phi_n}{\\phi_{n+1} - \\phi_n}\n$$\nThe interpolated state is then:\n$$\nx^* = (1 - \\theta)x_n + \\theta x_{n+1}\n$$\n$$\nv^* = (1 - \\theta)v_n + \\theta v_{n+1}\n$$\nThe first $200$ points are discarded to ensure the trajectory has settled onto the attractor, and the subsequent $300$ points are collected to form the Poincaré section.\n\nTo quantify the geometric difference between two Poincaré sections, $\\mathcal{A} = \\{(x_i, v_i)\\}_{i=1}^{N}$ and $\\mathcal{B} = \\{(x'_j, v'_j)\\}_{j=1}^{M}$ (where $N = M = 300$), we compute the specified symmetric average nearest-neighbor distance, $D(\\mathcal{A},\\mathcal{B})$:\n$$\nD(\\mathcal{A},\\mathcal{B}) = \\frac{1}{2}\\left(\\frac{1}{N}\\sum_{i=1}^{N} \\min_{1 \\le j \\le M} \\|\\mathbf{p}_i - \\mathbf{p}'_j\\|_2 + \\frac{1}{M}\\sum_{j=1}^{M} \\min_{1 \\le i \\le N} \\|\\mathbf{p}'_j - \\mathbf{p}_i\\|_2\\right)\n$$\nwhere $\\mathbf{p}_i = (x_i, v_i)$ and $\\mathbf{p}'_j = (x'_j, v'_j)$, and $\\|\\cdot\\|_2$ is the Euclidean distance. This metric averages the distance from each point in one set to its closest neighbor in the other set, and symmetrizes the result. It provides a robust measure of how well the two point clouds align.\n\nThe overall algorithm proceeds as follows: for each of the four test cases, we generate two Poincaré sections using the specified methods and time steps. For each section, we integrate the system from the initial condition, detect phase crossings, interpolate to find the $300$ attractor points after a $200$-point transient, and store these points. Then, we compute the distance $D(\\mathcal{A}, \\mathcal{B})$ between the two generated sets of points and report the value rounded to $6$ decimal places. This procedure systematically evaluates the impact of numerical method choice and step size on the geometric structure of the chaotic attractor.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef solve():\n    \"\"\"\n    Computes Poincaré sections of the Duffing oscillator and compares them\n    using a symmetric average nearest-neighbor distance.\n    \"\"\"\n\n    def generate_poincare_section(method, h, params):\n        \"\"\"\n        Generates a Poincaré section for the Duffing oscillator using a specified\n        integration method and step size.\n\n        Args:\n            method (str): The integration method, 'euler' or 'rk4'.\n            h (float): The time step.\n            params (dict): Dictionary of oscillator parameters.\n\n        Returns:\n            numpy.ndarray: An array of shape (300, 2) containing the (x, v)\n                           coordinates of the Poincaré section points.\n        \"\"\"\n        alpha = params['alpha']\n        beta = params['beta']\n        delta = params['delta']\n        gamma = params['gamma']\n        omega = params['omega']\n\n        def f(y):\n            \"\"\"The ODE function dy/dt = f(y) for the Duffing system.\"\"\"\n            x, v, phi = y\n            dxdt = v\n            dvdt = -delta * v - alpha * x - beta * x**3 + gamma * np.cos(phi)\n            dphidt = omega\n            return np.array([dxdt, dvdt, dphidt], dtype=np.float64)\n\n        y = np.array([0.0, 0.0, 0.0], dtype=np.float64)  # Initial state [x, v, phi]\n\n        poincare_points = []\n        num_transient = 200\n        total_points = num_transient + 300\n        \n        two_pi = 2.0 * np.pi\n\n        while len(poincare_points)  total_points:\n            y_prev = y\n            \n            if method == 'euler':\n                y = y_prev + h * f(y_prev)\n            elif method == 'rk4':\n                k1 = f(y_prev)\n                k2 = f(y_prev + 0.5 * h * k1)\n                k3 = f(y_prev + 0.5 * h * k2)\n                k4 = f(y_prev + h * k3)\n                y = y_prev + (h / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n            \n            phi_prev = y_prev[2]\n            phi_curr = y[2]\n\n            crossings_prev_count = np.floor(phi_prev / two_pi)\n            crossings_curr_count = np.floor(phi_curr / two_pi)\n\n            if crossings_curr_count  crossings_prev_count:\n                for k in range(int(crossings_prev_count) + 1, int(crossings_curr_count) + 1):\n                    if len(poincare_points) = total_points:\n                        break\n                    \n                    phi_target = k * two_pi\n                    \n                    # Linear interpolation factor\n                    theta = (phi_target - phi_prev) / (phi_curr - phi_prev)\n                    \n                    # Interpolate x and v to the exact crossing time\n                    x_cross = y_prev[0] + theta * (y[0] - y_prev[0])\n                    v_cross = y_prev[1] + theta * (y[1] - y_prev[1])\n                    \n                    poincare_points.append([x_cross, v_cross])\n\n        return np.array(poincare_points[num_transient:], dtype=np.float64)\n\n    def compute_distance(set_A, set_B):\n        \"\"\"\n        Computes the symmetric average nearest-neighbor distance between two point sets.\n        \"\"\"\n        dist_matrix = cdist(set_A, set_B)\n        \n        nn_dist_A_to_B = np.min(dist_matrix, axis=1)\n        nn_dist_B_to_A = np.min(dist_matrix, axis=0)\n        \n        avg_A_to_B = np.mean(nn_dist_A_to_B)\n        avg_B_to_A = np.mean(nn_dist_B_to_A)\n        \n        return 0.5 * (avg_A_to_B + avg_B_to_A)\n\n    params = {\n        'alpha': -1.0, 'beta': 1.0, 'delta': 0.3,\n        'gamma': 0.37, 'omega': 1.2\n    }\n\n    test_cases = [\n        # Case 1: Euler h=0.02 vs RK4 h=0.02\n        {'method1': 'euler', 'h1': 0.02, 'method2': 'rk4', 'h2': 0.02},\n        # Case 2: Euler h=0.05 vs RK4 h=0.05\n        {'method1': 'euler', 'h1': 0.05, 'method2': 'rk4', 'h2': 0.05},\n        # Case 3: RK4 h=0.02 vs RK4 h=0.01\n        {'method1': 'rk4', 'h1': 0.02, 'method2': 'rk4', 'h2': 0.01},\n        # Case 4: Euler h=0.02 vs Euler h=0.01\n        {'method1': 'euler', 'h1': 0.02, 'method2': 'euler', 'h2': 0.01}\n    ]\n\n    # Pre-compute all required sections to avoid redundant calculations\n    computations_to_run = set()\n    for case in test_cases:\n        computations_to_run.add((case['method1'], case['h1']))\n        computations_to_run.add((case['method2'], case['h2']))\n    \n    generated_sections = {\n        (method, h): generate_poincare_section(method, h, params)\n        for method, h in computations_to_run\n    }\n    \n    results = []\n    for case in test_cases:\n        set_A = generated_sections[(case['method1'], case['h1'])]\n        set_B = generated_sections[(case['method2'], case['h2'])]\n        \n        dist = compute_distance(set_A, set_B)\n        results.append(f\"{dist:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2427621"}]}