{"hands_on_practices": [{"introduction": "Moving from theory to practice is where true understanding is forged. This chapter guides you through a series of hands-on coding exercises designed to build your skills in particle-mesh methods from the ground up. We begin with the computational core of any PM simulation: the fast Poisson solver. This exercise challenges you to implement an FFT-based solver, but with a twist—you must first derive the correct gravitational Green's function for a hypothetical two-dimensional universe from first principles. This practice ([@problem_id:2424811]) not only builds a fundamental algorithmic component but also deepens your physical intuition by connecting the mathematical formalism of gravity to the dimensionality of space.", "problem": "You are asked to construct a complete, runnable program that implements a two-dimensional Fast Fourier Transform (FFT)-based Poisson solver for Newtonian gravity using the particle–mesh method. Your task is to reason from first principles and implement the correct Fourier-space Green’s function for a two-dimensional universe, starting from the fundamental law relating mass density to gravitational potential via Poisson’s equation. You must then validate your implementation on carefully designed test fields with known analytic solutions.\n\nFundamental base: In a continuous two-dimensional domain, the Newtonian gravitational potential $\\phi(\\vec{r})$ generated by a surface mass density $\\Sigma(\\vec{r})$ is related by Poisson’s equation, which must be chosen consistently with the dimension of space and the identity for the Laplacian of the logarithm. Use the identity $\\nabla^2 \\ln r = 2\\pi \\delta^{(2)}(\\vec{r})$ and the definition of gravitational potential to relate $\\nabla^2 \\phi$ and $\\Sigma$ in two spatial dimensions. In Fourier space, the Laplacian becomes multiplication by $-|\\vec{k}|^2$, and convolution with a Green’s function becomes multiplication by its Fourier transform. Your task is to derive, from this base, the correct two-dimensional Fourier-space Green’s function $\\tilde{G}(\\vec{k})$ that replaces the three-dimensional expression $\\tilde{G}(\\vec{k}) = -4\\pi G/|\\vec{k}|^2$.\n\nImplementation setting: Consider a square, periodic, two-dimensional domain of side length $L$, discretized on a uniform grid with $N \\times N$ points. Use the discrete Fourier transform via the Fast Fourier Transform to solve Poisson’s equation in Fourier space. Let the grid spacing be $\\Delta x = L/N$. Use the one-dimensional discrete frequency definition with $k$-components constructed from the real-space spacing $d=\\Delta x$: for each axis, define the discrete angular wave numbers as $k_\\alpha = 2\\pi \\,\\mathrm{fftfreq}(N, d=\\Delta x)$ for $\\alpha \\in \\{x,y\\}$, and then form $|\\vec{k}|^2 = k_x^2 + k_y^2$. You must handle the zero mode $\\vec{k}=\\vec{0}$ by enforcing a mean-zero potential (set the corresponding Fourier-space Green’s function to zero and subtract the mean of the density field in real space before transforming).\n\nYour program must:\n- Derive and implement the correct two-dimensional Fourier-space Green’s function $\\tilde{G}(\\vec{k})$ for gravity.\n- Construct a solver that, given a surface density field $\\Sigma(x,y)$, computes the gravitational potential $\\phi(x,y)$ by multiplying the Fourier transform of the mean-subtracted density by $\\tilde{G}(\\vec{k})$ and inverse transforming.\n- Additionally compute the gravitational acceleration field $\\vec{g}(x,y) = -\\nabla \\phi(x,y)$ using spectral derivatives in Fourier space, i.e., using the property that $\\partial/\\partial x \\leftrightarrow i k_x$ and $\\partial/\\partial y \\leftrightarrow i k_y$ in Fourier space.\n\nUnits: Use dimensionless code units with gravitational constant $G=1$. All requested outputs are dimensionless real numbers.\n\nAngle unit: All trigonometric functions must use radians.\n\nTest suite and required outputs: Your program must run the following four test cases on a periodic square domain and produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n\nDomain and constants for all tests: $N=64$, $L=1$, $G=1$.\n\nLet $x_i = i\\,\\Delta x$ and $y_j = j\\,\\Delta x$ for $i,j \\in \\{0,1,\\dots,N-1\\}$, with $\\Delta x = L/N$. Define the cosine fields using $\\cos\\left(2\\pi m x/L\\right)$ and $\\cos\\left(2\\pi n y/L\\right)$.\n\n- Test $1$ (Happy path, one-dimensional cosine): Surface density $\\Sigma(x,y) = A \\cos\\left(2\\pi m x/L\\right)$ with $A=1$, $m=1$, $n=0$. Compute the numerical potential $\\phi_{\\mathrm{num}}(x,y)$ from your solver. Independently derive the analytic potential $\\phi_{\\mathrm{an}}(x,y)$ corresponding to this $\\Sigma(x,y)$ using the correct two-dimensional Poisson relation and the fact that the cosine functions are eigenfunctions of the Laplacian on the periodic domain. Output the maximum absolute error $E_1 = \\max_{i,j} \\left| \\phi_{\\mathrm{num}}(x_i,y_j) - \\phi_{\\mathrm{an}}(x_i,y_j) \\right|$ as a single float.\n\n- Test $2$ (Two-dimensional cosine mode): Surface density $\\Sigma(x,y) = A \\cos\\left(2\\pi m x/L\\right)\\cos\\left(2\\pi n y/L\\right)$ with $A=0.5$, $m=3$, $n=2$. Compute the numerical potential and compare to the analytically derived $\\phi_{\\mathrm{an}}(x,y)$ for this field. Output $E_2 = \\max_{i,j} \\left| \\phi_{\\mathrm{num}}(x_i,y_j) - \\phi_{\\mathrm{an}}(x_i,y_j) \\right|$ as a single float.\n\n- Test $3$ (Vector field check via acceleration): Surface density $\\Sigma(x,y) = A \\cos\\left(2\\pi m x/L\\right)\\cos\\left(2\\pi n y/L\\right)$ with $A=0.8$, $m=5$, $n=1$. Using your solver, compute the numerical acceleration components $g_{x,\\mathrm{num}}(x,y)$ and $g_{y,\\mathrm{num}}(x,y)$ from the spectral gradients of the potential. Independently derive the analytic acceleration components $g_{x,\\mathrm{an}}(x,y)$ and $g_{y,\\mathrm{an}}(x,y)$ for this field, and output the maximum absolute error across both components, $E_3 = \\max\\left\\{\\max_{i,j} \\left| g_{x,\\mathrm{num}} - g_{x,\\mathrm{an}} \\right|,\\; \\max_{i,j} \\left| g_{y,\\mathrm{num}} - g_{y,\\mathrm{an}} \\right|\\right\\}$ as a single float.\n\n- Test $4$ (Zero-mode handling boundary case): Surface density $\\Sigma(x,y) = A$ with $A=7$. After subtracting the mean and setting the $\\vec{k}=\\vec{0}$ mode of the Green’s function to zero, the potential should be identically zero on a periodic domain. Compute the numerical potential $\\phi_{\\mathrm{num}}(x,y)$ and output the root-mean-square value $E_4 = \\sqrt{\\frac{1}{N^2}\\sum_{i,j} \\phi_{\\mathrm{num}}(x_i,y_j)^2}$ as a single float.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[E_1,E_2,E_3,E_4]$. For example, a valid output line has the form \"[0.0,0.0,0.0,0.0]\". All four outputs must be floats in dimensionless units, rounded by the default string conversion of your programming language. No additional text should be printed.", "solution": "The problem as stated is a well-defined exercise in computational physics. It requires the construction of a numerical solver for the two-dimensional gravitational Poisson equation on a periodic domain using spectral methods, specifically the Fast Fourier Transform (FFT). The problem is scientifically grounded, internally consistent, and provides a clear set of verifiable test cases. We shall proceed with the solution.\n\nThe fundamental task is to solve Poisson's equation, which relates the gravitational potential $\\phi$ to the surface mass density $\\Sigma$.\n\nFirst, we must establish the correct form of Poisson's equation in a two-dimensional universe. The problem guides us to use the identity for the Laplacian of the logarithm in two dimensions, $\\nabla^2 \\ln(r) = 2\\pi \\delta^{(2)}(\\vec{r})$, where $r=|\\vec{r}|$ is the distance from the origin and $\\delta^{(2)}(\\vec{r})$ is the two-dimensional Dirac delta function. In two dimensions, the gravitational force exhibits a $1/r$ dependence, leading to a potential that varies as $\\ln(r)$. For a point mass $m$ at the origin, the surface density is $\\Sigma(\\vec{r}) = m \\delta^{(2)}(\\vec{r})$ and the potential is $\\phi(\\vec{r}) = G m \\ln(r)$, where $G$ is the gravitational constant.\n\nTaking the Laplacian of this potential, we find:\n$$\n\\nabla^2 \\phi(\\vec{r}) = \\nabla^2 (G m \\ln r) = G m \\nabla^2(\\ln r) = G m (2\\pi \\delta^{(2)}(\\vec{r}))\n$$\nBy substituting $\\Sigma(\\vec{r}) / m$ for $\\delta^{(2)}(\\vec{r})$, we obtain the relation for a point mass:\n$$\n\\nabla^2 \\phi(\\vec{r}) = 2\\pi G \\Sigma(\\vec{r})\n$$\nBy the principle of superposition, this equation holds for any arbitrary mass distribution $\\Sigma(\\vec{r})$. This is the two-dimensional Poisson equation for gravity. In the problem's specified dimensionless units where $G=1$, this simplifies to:\n$$\n\\nabla^2 \\phi(\\vec{r}) = 2\\pi \\Sigma(\\vec{r})\n$$\n\nOur objective is to solve this partial differential equation using Fourier methods. The Fourier transform is defined as $\\tilde{f}(\\vec{k}) = \\mathcal{F}\\{f(\\vec{r})\\} = \\int f(\\vec{r}) e^{-i\\vec{k}\\cdot\\vec{r}} d^2r$. A key property of the Fourier transform is that it converts differentiation into multiplication. Specifically, the transform of the Laplacian operator is:\n$$\n\\mathcal{F}\\{\\nabla^2 f(\\vec{r})\\} = -|\\vec{k}|^2 \\tilde{f}(\\vec{k})\n$$\nwhere $|\\vec{k}|^2 = k_x^2 + k_y^2$ is the squared magnitude of the wavevector $\\vec{k}$.\n\nApplying the Fourier transform to both sides of our Poisson equation, we get:\n$$\n\\mathcal{F}\\{\\nabla^2 \\phi\\} = \\mathcal{F}\\{2\\pi \\Sigma\\}\n$$\n$$\n-|\\vec{k}|^2 \\tilde{\\phi}(\\vec{k}) = 2\\pi \\tilde{\\Sigma}(\\vec{k})\n$$\nThis algebraic equation can be solved for the Fourier transform of the potential, $\\tilde{\\phi}(\\vec{k})$:\n$$\n\\tilde{\\phi}(\\vec{k}) = \\left(\\frac{-2\\pi}{|\\vec{k}|^2}\\right) \\tilde{\\Sigma}(\\vec{k})\n$$\nThe solution to a convolution problem in real space becomes a simple multiplication in Fourier space. The term multiplying the transformed density is the Fourier-space Green's function, $\\tilde{G}(\\vec{k})$. Thus, for two-dimensional gravity with $G=1$:\n$$\n\\tilde{G}(\\vec{k}) = \\frac{-2\\pi}{|\\vec{k}|^2}\n$$\nA singularity exists at $\\vec{k}=\\vec{0}$. This reflects the physical reality that the absolute value of the potential is arbitrary; only potential differences are physically meaningful. For a system with periodic boundary conditions, a unique solution can be enforced by requiring the potential to have zero mean. This translates to $\\tilde{\\phi}(\\vec{k}=\\vec{0}) = 0$. We achieve this by two measures:\n1.  The mean of the density field is subtracted before the Fourier transform: $\\Sigma'(\\vec{r}) = \\Sigma(\\vec{r}) - \\langle \\Sigma \\rangle$. This ensures that $\\tilde{\\Sigma}'(\\vec{k}=\\vec{0})=0$.\n2.  The Green's function is explicitly set to zero at the origin: $\\tilde{G}(\\vec{k}=\\vec{0}) = 0$.\n\nFor the numerical implementation on a discrete $N \\times N$ grid over a domain of side length $L$, the continuous Fourier transform is replaced by the Discrete Fourier Transform (DFT), implemented via the FFT algorithm. The discrete wavevectors are given by $k_\\alpha = 2\\pi \\, \\mathrm{fftfreq}(N, d=\\Delta x)$ for each axis $\\alpha \\in \\{x, y\\}$, where $\\Delta x = L/N$ is the grid spacing.\n\nThe full algorithm to compute the potential $\\phi(x_i, y_j)$ from a density field $\\Sigma(x_i, y_j)$ is as follows:\n1.  Compute the discrete grid coordinates and wavevectors.\n2.  Construct the discrete density field $\\Sigma$ on the grid.\n3.  Subtract the mean: $\\Sigma' = \\Sigma - \\frac{1}{N^2} \\sum_{i,j} \\Sigma_{i,j}$.\n4.  Compute the 2D DFT of the mean-subtracted density: $\\tilde{\\Sigma}' = \\mathrm{FFT2}(\\Sigma')$.\n5.  Construct the discrete Fourier-space Green's function $\\tilde{G}(k_x, k_y) = -2\\pi/(k_x^2 + k_y^2)$, with the value at $(k_x, k_y)=(0,0)$ set to $0$.\n6.  Multiply in Fourier space: $\\tilde{\\phi}(k_x, k_y) = \\tilde{G}(k_x, k_y) \\tilde{\\Sigma}'(k_x, k_y)$.\n7.  Compute the inverse 2D DFT to obtain the potential in real space: $\\phi = \\mathrm{IFFT2}(\\tilde{\\phi})$. The result will be real-valued, up to numerical precision errors.\n\nThe gravitational acceleration field, $\\vec{g} = -\\nabla\\phi$, is also efficiently computed in Fourier space. The gradient operator transforms as $\\mathcal{F}\\{\\nabla f\\} = i\\vec{k} \\tilde{f}(\\vec{k})$. Therefore, the Fourier components of the acceleration are:\n$$\n\\tilde{g}_x(\\vec{k}) = -i k_x \\tilde{\\phi}(\\vec{k})\n$$\n$$\n\\tilde{g}_y(\\vec{k}) = -i k_y \\tilde{\\phi}(\\vec{k})\n$$\nThe real-space acceleration components $g_x$ and $g_y$ are then obtained by applying the inverse DFT to $\\tilde{g}_x$ and $\\tilde{g}_y$, respectively.\n\nWe validate this implementation against analytic solutions. The test cases use cosine functions, which are eigenfunctions of the Laplacian operator on a periodic domain. For a density of the form $\\Sigma(x,y) = A \\cos(2\\pi m x/L)\\cos(2\\pi n y/L)$, the corresponding potential that satisfies $\\nabla^2 \\phi = 2\\pi \\Sigma$ and has zero mean is:\n$$\n\\phi_{\\mathrm{an}}(x,y) = -\\frac{A L^2}{2\\pi(m^2+n^2)} \\cos(2\\pi m x/L)\\cos(2\\pi n y/L)\n$$\nfor $(m,n) \\neq (0,0)$. The corresponding acceleration components are found by taking the negative gradient of this potential:\n$$\ng_{x,\\mathrm{an}}(x,y) = -\\frac{A L m}{m^2+n^2} \\sin(2\\pi m x/L)\\cos(2\\pi n y/L)\n$$\n$$\ng_{y,\\mathrm{an}}(x,y) = -\\frac{A L n}{m^2+n^2} \\cos(2\\pi m x/L)\\sin(2\\pi n y/L)\n$$\nThese analytic solutions provide the ground truth for measuring the accuracy of the numerical solver. For the uniform density test case, subtracting the mean results in a zero field, for which the potential must also be zero. The numerical error in this case quantifies the solver's handling of the zero-mode.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 2D FFT-based Poisson solver for Newtonian gravity and validates it.\n    \"\"\"\n    # Domain and constants for all tests\n    N = 64\n    L = 1.0\n    G = 1.0 # Set to 1 as per problem statement\n\n    # Discretization\n    dx = L / N\n    x = np.arange(N) * dx\n    y = np.arange(N) * dx\n    \n    # Grid coordinates. Use 'xy' indexing for intuitive array layout.\n    # Sigma[i, j] will correspond to Sigma(x_j, y_i)\n    xx, yy = np.meshgrid(x, y, indexing='xy')\n\n    # Frequencies\n    k_1d = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    kx, ky = np.meshgrid(k_1d, k_1d, indexing='xy')\n\n    # Fourier-space Green's function for 2D Poisson equation \\nabla^2\\phi = 2\\pi*G*\\Sigma\n    k_sq = kx**2 + ky**2\n    \n    # Suppress division by zero warning for the k=0 case\n    with np.errstate(divide='ignore', invalid='ignore'):\n        green_k = -2 * np.pi * G / k_sq\n    \n    # Handle the k=0 mode (DC component)\n    green_k[0, 0] = 0.0\n\n    # Define a helper function for the solver core\n    def poisson_solver(Sigma):\n        # Subtract mean to enforce zero-mean potential\n        Sigma_mean_subtracted = Sigma - np.mean(Sigma)\n        \n        # Forward FFT\n        Sigma_k = np.fft.fft2(Sigma_mean_subtracted)\n        \n        # Solve in Fourier space\n        phi_k = green_k * Sigma_k\n        \n        # Inverse FFT to get potential\n        phi_num = np.fft.ifft2(phi_k).real\n        \n        return phi_num, phi_k\n\n    # Test cases from the problem statement.\n    test_cases = [\n        {'id': 1, 'A': 1.0, 'm': 1, 'n': 0},\n        {'id': 2, 'A': 0.5, 'm': 3, 'n': 2},\n        {'id': 3, 'A': 0.8, 'm': 5, 'n': 1},\n        {'id': 4, 'A': 7.0, 'm': 0, 'n': 0}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        A = case['A']\n        m = case['m']\n        n = case['n']\n\n        if case['id'] = 3: # Cosine-based density fields\n            # The general form is A * cos(2*pi*m*x/L) * cos(2*pi*n*y/L),\n            # with n=0 for Test 1.\n            term_x = np.cos(2 * np.pi * m * xx / L)\n            term_y = np.cos(2 * np.pi * n * yy / L)\n            Sigma = A * term_x * term_y\n            \n            # Solve numerically\n            phi_num, phi_k = poisson_solver(Sigma)\n\n            if case['id'] == 1 or case['id'] == 2:\n                # Analytic potential\n                k_norm_sq_mode = m**2 + n**2\n                C = -A * L**2 / (2 * np.pi * G * k_norm_sq_mode)\n                phi_an = C * term_x * term_y\n                \n                # Calculate error E1 or E2\n                error = np.max(np.abs(phi_num - phi_an))\n                results.append(error)\n            \n            elif case['id'] == 3:\n                # Compute numerical acceleration\n                gx_k = -1j * kx * phi_k\n                gy_k = -1j * ky * phi_k\n                gx_num = np.fft.ifft2(gx_k).real\n                gy_num = np.fft.ifft2(gy_k).real\n\n                # Analytic acceleration\n                k_norm_sq_mode = m**2 + n**2\n                C_gx = -A * L * m / (G * k_norm_sq_mode)\n                C_gy = -A * L * n / (G * k_norm_sq_mode)\n\n                gx_an = C_gx * np.sin(2 * np.pi * m * xx / L) * np.cos(2 * np.pi * n * yy / L)\n                gy_an = C_gy * np.cos(2 * np.pi * m * xx / L) * np.sin(2 * np.pi * n * yy / L)\n\n                # Calculate error E3\n                error_gx = np.max(np.abs(gx_num - gx_an))\n                error_gy = np.max(np.abs(gy_num - gy_an))\n                error = max(error_gx, error_gy)\n                results.append(error)\n\n        elif case['id'] == 4: # Constant density field\n            Sigma = np.full((N, N), A)\n            \n            # Solve numerically. The mean subtraction should make Sigma=0.\n            phi_num, _ = poisson_solver(Sigma)\n            \n            # The potential should be identically zero, up to machine precision.\n            # Calculate RMS error E4.\n            error = np.sqrt(np.mean(phi_num**2))\n            results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2424811"}, {"introduction": "With the Poisson solver engine built, the next step is to assemble the full machinery of a dynamic simulation. In this practice, you will construct a complete one-dimensional Particle-Mesh simulation, incorporating the mass assignment and force interpolation steps that link the particles to the mesh. You will bring the system to life using a leapfrog integrator to evolve particle positions and velocities over time. This exercise ([@problem_id:2424803]) is centered on a crucial practical aspect of numerical simulations: stability. By deliberately violating the Courant-Friedrichs-Lewy (CFL) condition, you will gain firsthand experience in how and why explicit time-integration schemes can fail, a vital lesson for any computational physicist.", "problem": "You are asked to implement a complete, self-contained program that simulates a one-dimensional Particle–Mesh (PM) method for self-gravity and uses it to investigate the numerical stability of explicit time integration when the Courant–Friedrichs–Lewy (CFL) condition is deliberately violated. The PM method stands for Particle–Mesh (PM), and the stability condition is Courant–Friedrichs–Lewy (CFL). All quantities are nondimensional. The spatial domain is periodic with length $L=1$. The mesh has $N_g=256$ uniformly spaced cells of width $\\Delta x=L/N_g$. There are $N_p=8192$ particles, each of mass $m_i=1/N_p$, with initial positions $x_i(0)=\\left(i+\\tfrac{1}{2}\\right)\\,L/N_p$ for $i=0,1,\\dots,N_p-1$. The initial velocities are $v_i(0)=v_0 \\sin\\!\\left(2\\pi x_i(0)/L\\right)$ with $v_0=0.5$. The gravitational constant is $G=1$. The evolution is governed by Newton’s equations, $\\,\\ddot{x}_i(t)=a\\!\\left(x_i(t),t\\right)\\,$, where the acceleration field $a(x,t)$ is obtained by solving Poisson’s equation on the mesh for the gravitational potential $\\phi(x,t)$, $$\\frac{\\mathrm{d}^2 \\phi}{\\mathrm{d}x^2}(x,t) = 4\\pi G \\left(\\rho(x,t)-\\bar{\\rho}\\right),$$ with periodic boundary conditions and zero-mean potential (i.e., the $k=0$ Fourier mode of $\\phi$ is set to zero). Here $\\rho(x,t)$ is the mass density on the mesh obtained by assigning particle masses to the mesh using Cloud-In-Cell (CIC) interpolation, and $\\bar{\\rho}$ is the spatial mean of $\\rho(x,t)$. The acceleration is $a(x,t)=-\\mathrm{d}\\phi/\\mathrm{d}x$. The acceleration at particle positions is obtained by interpolating the mesh acceleration back to particles using the same Cloud-In-Cell (CIC) scheme. Time integration must be carried out for $N_{\\text{steps}}=300$ steps using a second-order accurate, explicit, time-reversible integrator for Newton’s equations. The program must run four simulations that differ only in the choice of the time step $\\Delta t$. Define the initial CFL ratio to be $$r_0=\\frac{\\Delta t\\,\\max_i |v_i(0)|}{\\Delta x}=\\frac{\\Delta t\\,v_0}{\\Delta x}.$$ The four simulations must use $\\Delta t$ chosen so that $r_0$ takes the values from the set $\\{0.2,\\,0.9,\\,1.2,\\,2.5\\}$ (i.e., for each listed $r_0$, set $\\Delta t=r_0\\,\\Delta x/v_0$). For each simulation, determine a boolean stability indicator as follows. A run is declared stable if and only if all the conditions below are satisfied for all steps $n=0,1,\\dots,N_{\\text{steps}}-1$: - No floating-point Not-a-Number or infinity appears in any particle or mesh quantity at any time. - If $v_{i,n+\\tfrac{1}{2}}$ denotes the particle velocities evaluated at the time midpoint of step $n$, then the per-step path length constraint holds, $$\\max_i \\left|v_{i,n+\\tfrac{1}{2}}\\right|\\,\\Delta t \\le \\theta\\,\\Delta x,$$ with $\\theta=0.9$. - The maximum particle speed over the entire run satisfies $$\\max_{n}\\max_i |v_{i,n}| \\le \\gamma\\,v_0,$$ with $\\gamma=10$. - The mesh density field remains bounded in the sense $$\\max_{n}\\left(\\frac{\\max_j \\rho_j^{(n)}}{\\bar{\\rho}}\\right) \\le \\eta,$$ with $\\eta=100$, where $\\rho_j^{(n)}$ is the density in cell $j$ at step $n$ and $\\bar{\\rho}$ is the constant mean density. Your program must output the stability indicators for the four simulations, in the order of $r_0$ values $\\{0.2,\\,0.9,\\,1.2,\\,2.5\\}$, as a single line containing a comma-separated list of booleans enclosed in square brackets, for example, $[{\\rm True},{\\rm False},{\\rm True},{\\rm False}]$. No external input is allowed and no physical units are involved; all quantities are nondimensional. The test suite is the set of the four initial CFL ratios $r_0 \\in \\{0.2,\\,0.9,\\,1.2,\\,2.5\\}$, which probes a typical case well within the stability limit, a near-boundary case, a modest violation, and a severe violation. The final output format must be exactly one line with the list of booleans as specified.", "solution": "The problem requires the implementation of a one-dimensional Particle-Mesh (PM) simulation for a self-gravitating system of particles to investigate the numerical stability of an explicit time integration scheme. The validity of the problem statement is confirmed, as it is scientifically sound, well-posed, and all necessary parameters and conditions are provided for a reproducible computational experiment.\n\nThe core of the solution is the PM method, a hybrid technique that leverages the strengths of both Lagrangian and Eulerian approaches. Particle positions and velocities are tracked in a continuous phase space (Lagrangian), while the long-range gravitational force is calculated on a discrete mesh (Eulerian). This approach mitigates the computationally prohibitive $O(N_p^2)$ complexity of direct summation methods for $N_p$ particles, replacing it with a much more efficient sequence of operations dominated by the Fast Fourier Transform (FFT), which scales as $O(N_g \\log N_g)$ for a mesh of size $N_g$.\n\nThe simulation evolves a system of $N_p=8192$ particles, each of mass $m_i = 1/N_p$, on a periodic one-dimensional domain of length $L=1$. The particles are initialized with uniform spacing $x_i(0)=\\left(i+\\tfrac{1}{2}\\right)\\,L/N_p$ and a sinusoidal velocity profile $v_i(0)=v_0 \\sin\\!\\left(2\\pi x_i(0)/L\\right)$ with amplitude $v_0=0.5$. The evolution is governed by Newton's equations of motion, $\\ddot{x}_i(t) = a(x_i(t), t)$. The acceleration field $a(x,t)$ is derived from the gravitational potential $\\phi(x,t)$, which is obtained by solving Poisson's equation on a grid with $N_g=256$ cells.\n\nThe simulation proceeds in discrete time steps, with the main computational loop consisting of three phases: time integration, force calculation, and stability monitoring.\n\n**Time Integration: The Leapfrog (Kick-Drift-Kick) Scheme**\nTo update particle positions and velocities, we employ a second-order accurate, explicit, and time-reversible integrator known as the leapfrog scheme. Its Kick-Drift-Kick (KDK) formulation is particularly well-suited for gravitational dynamics as it is symplectic, meaning it conserves phase-space volume elements over time. Let $x_n$ and $v_n$ be the position and velocity at time $t_n = n\\Delta t$. The update from step $n$ to $n+1$ proceeds as follows:\n1.  **Half-step kick for velocity:** $v_{n+1/2} = v_n + a_n \\cdot \\frac{\\Delta t}{2}$\n2.  **Full-step drift for position:** $x_{n+1} = x_n + v_{n+1/2} \\cdot \\Delta t$\n3.  **Compute new acceleration:** $a_{n+1} = a(x_{n+1})$\n4.  **Second half-step kick for velocity:** $v_{n+1} = v_{n+1/2} + a_{n+1} \\cdot \\frac{\\Delta t}{2}$\nHere, $v_{n+1/2}$ represents the velocity at the time midpoint $t_n + \\Delta t/2$. For the very first step, an initial half-step kick $v_{1/2} = v_0 + a_0\\Delta t/2$ is performed to offset the velocities relative to positions, establishing the leapfrog staggering.\n\n**Force Calculation Cycle**\nThe acceleration $a_n = a(x_n)$ required at each step is calculated on the mesh and then interpolated to the particle locations.\n\n1.  **Mass Assignment (Particle-to-Mesh):** The particle masses are assigned to the nodes of the computational grid to obtain a mass density field $\\rho(x,t)$. We use the Cloud-In-Cell (CIC) scheme, which is a second-order interpolation method. For a particle at position $x_p$ located between grid nodes $j$ and $j+1$, its mass $m_p$ is distributed linearly to these two nodes based on proximity. If the grid spacing is $\\Delta x$, the weights are $w_j = 1 - (x_p/\\Delta x - \\lfloor x_p/\\Delta x \\rfloor)$ and $w_{j+1} = 1 - w_j$. The mass on each grid node $j$ is the sum of contributions from all particles. The grid density is then $\\rho_j = M_j/\\Delta x$. This scheme acts as a low-pass filter, smoothing the density field on the scale of the grid spacing.\n\n2.  **Poisson Solver (FFT):** The gravitational potential $\\phi(x,t)$ is found by solving Poisson's equation, given as $\\frac{\\mathrm{d}^2 \\phi}{\\mathrm{d}x^2} = 4\\pi G (\\rho(x,t)-\\bar{\\rho})$, where $\\bar{\\rho} = N_p m_i/L = 1$ is the mean density. Subtracting the mean density ensures that the source term has a zero spatial average, which is necessary for a well-posed problem on a periodic domain. We solve this equation in Fourier space, where differentiation becomes algebraic multiplication. Applying the Fourier transform $\\mathcal{F}$ yields:\n    $$ \\mathcal{F}\\left[\\frac{\\mathrm{d}^2 \\phi}{\\mathrm{d}x^2}\\right] (k) = (ik)^2 \\hat{\\phi}(k) = -k^2 \\hat{\\phi}(k) $$\n    where $k$ is the wavenumber and $\\hat{\\phi}(k)=\\mathcal{F}[\\phi(x)](k)$. The equation becomes:\n    $$ -k^2 \\hat{\\phi}(k) = 4\\pi G \\hat{\\rho}_{\\text{over}}(k) $$\n    where $\\hat{\\rho}_{\\text{over}}$ is the Fourier transform of the overdensity $\\rho(x,t)-\\bar{\\rho}$. The solution for the potential in Fourier space is:\n    $$ \\hat{\\phi}(k) = - \\frac{4\\pi G \\hat{\\rho}_{\\text{over}}(k)}{k^2} \\quad \\text{for } k \\neq 0 $$\n    For the $k=0$ mode (the DC component), the problem specifies $\\hat{\\phi}(0)=0$. The overdensity has $\\hat{\\rho}_{\\text{over}}(0)=0$ by construction, avoiding the singularity.\n\n3.  **Acceleration Calculation (FFT):** The acceleration field $a(x,t) = -\\frac{\\mathrm{d}\\phi}{\\mathrm{d}x}$ is also computed in Fourier space. The transform of the derivative is $\\hat{a}(k) = -ik \\hat{\\phi}(k)$. Substituting the expression for $\\hat{\\phi}(k)$:\n    $$ \\hat{a}(k) = ik \\left( \\frac{4\\pi G \\hat{\\rho}_{\\text{over}}(k)}{k^2} \\right) = \\frac{4\\pi i G \\hat{\\rho}_{\\text{over}}(k)}{k} \\quad \\text{for } k \\neq 0 $$\n    And $\\hat{a}(0)=0$ since $\\hat{\\phi}(0)=0$. The acceleration field on the grid, $a_j$, is then recovered by applying the inverse FFT to $\\hat{a}(k)$.\n\n4.  **Force Interpolation (Mesh-to-Particle):** The acceleration at each particle's position $x_i$ is interpolated from the grid-based acceleration field $a_j$. To ensure momentum conservation, the same CIC weighting scheme used for mass assignment is applied in reverse. The acceleration for a particle at $x_p$ is a weighted average of the accelerations at the two bracketing grid nodes: $a_p = a_j w_j + a_{j+1} w_{j+1}$.\n\n**Stability Analysis**\nThe simulation is run for four different time steps $\\Delta t$, corresponding to initial Courant–Friedrichs–Lewy (CFL) ratios $r_0 = \\Delta t v_0 / \\Delta x$ of $\\{0.2, 0.9, 1.2, 2.5\\}$. For each run, several stability criteria are monitored at every time step $n$:\n- **Numerical Integrity:** The simulation must not produce any floating-point `NaN` or `infinity` values. This is a basic check for catastrophic failure.\n- **Path Length Constraint:** $\\max_i |v_{i,n+\\tfrac{1}{2}}|\\,\\Delta t \\le \\theta\\,\\Delta x$ with $\\theta=0.9$. This is a strict CFL-like condition, ensuring that no particle travels more than a fraction $\\theta$ of a grid cell in a single time step. Violation leads to aliasing errors in the force calculation and is a primary cause of instability.\n- **Velocity Growth:** $\\max_{n,i} |v_{i,n}| \\le \\gamma\\,v_0$ with $\\gamma=10$. This guards against unphysical runaway kinetic energy growth.\n- **Density Contrast:** $\\max_{n,j} (\\rho_j^{(n)}/\\bar{\\rho}) \\le \\eta$ with $\\eta=100$. This checks for the formation of excessively dense structures, which can lead to numerical singularities.\n\nA simulation is deemed stable if and only if all four conditions are met throughout the entire run of $N_{\\text{steps}}=300$. The path length constraint $\\frac{\\max|v_{n+1/2}|}{v_0} r_0 \\le \\theta$ implies that for $v \\approx v_0$, stability requires $r_0 \\le \\theta=0.9$. Therefore, we anticipate that the simulations with $r_0=1.2$ and $r_0=2.5$ will fail immediately. The case $r_0=0.9$ is critically poised at the stability boundary and is expected to fail as particle velocities inevitably increase beyond their initial values due to gravitational collapse. The case $r_0=0.2$ should remain well within the stable regime.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main solver function to run simulations for all test cases and print results.\n    \"\"\"\n    \n    def run_simulation(r0: float) - bool:\n        \"\"\"\n        Runs a single 1D Particle-Mesh simulation for a given initial CFL ratio r0.\n\n        Args:\n            r0: The initial Courant-Friedrichs-Lewy (CFL) ratio.\n\n        Returns:\n            A boolean indicating whether the simulation remained stable.\n        \"\"\"\n        # --- Problem Parameters ---\n        L = 1.0  # Domain length\n        Ng = 256  # Number of grid cells\n        Np = 8192  # Number of particles\n        v0 = 0.5  # Initial velocity amplitude\n        G = 1.0  # Gravitational constant\n        N_steps = 300  # Number of time steps\n\n        # --- Stability Check Parameters ---\n        theta = 0.9  # Path length constraint factor\n        gamma = 10.0  # Max velocity factor\n        eta = 100.0  # Max density ratio\n\n        # --- Derived Constants ---\n        dx = L / Ng  # Grid cell width\n        m = 1.0 / Np  # Particle mass\n        rho_mean = 1.0  # Mean density: (Np * m) / L\n        dt = r0 * dx / v0  # Time step\n\n        # --- Helper function for acceleration calculation ---\n        def get_accel_and_density(pos: np.ndarray) - tuple[np.ndarray, np.ndarray]:\n            \"\"\"\n            Calculates particle accelerations and grid density using the PM method.\n            \"\"\"\n            # 1. Mass Assignment (Particle-to-Mesh) using CIC\n            grid_mass = np.zeros(Ng, dtype=np.float64)\n            pos_in_grid_units = pos / dx\n            j = np.floor(pos_in_grid_units).astype(int)\n            w_right = pos_in_grid_units - j\n            w_left = 1.0 - w_right\n            \n            # Use np.add.at for safe atomistic addition\n            np.add.at(grid_mass, j % Ng, m * w_left)\n            np.add.at(grid_mass, (j + 1) % Ng, m * w_right)\n\n            grid_density = grid_mass / dx\n\n            # 2. Solve Poisson's Equation in Fourier Space\n            overdensity = grid_density - rho_mean\n            overdensity_hat = fft.fft(overdensity)\n            \n            wavenumbers = 2.0 * np.pi * fft.fftfreq(Ng, d=dx)\n            \n            phi_hat = np.zeros_like(overdensity_hat)\n            k_sq = wavenumbers**2\n            \n            # Solve for phi_hat, handling k=0 case\n            non_zero_k = wavenumbers != 0\n            phi_hat[non_zero_k] = -4.0 * np.pi * G * overdensity_hat[non_zero_k] / k_sq[non_zero_k]\n            \n            # 3. Calculate Acceleration in Fourier Space\n            accel_hat = -1j * wavenumbers * phi_hat\n            \n            # 4. Transform Acceleration to Real Space\n            grid_accel = fft.ifft(accel_hat).real\n\n            # 5. Interpolate Acceleration to Particles (Mesh-to-Particle) using CIC\n            particle_accel = grid_accel[j % Ng] * w_left + grid_accel[(j + 1) % Ng] * w_right\n            \n            return particle_accel, grid_density\n        \n        # --- Initialization ---\n        particle_pos = (np.arange(Np, dtype=np.float64) + 0.5) * L / Np\n        particle_vel = v0 * np.sin(2.0 * np.pi * particle_pos / L)\n        \n        max_vel_history = [np.max(np.abs(particle_vel))]\n\n        try:\n            # Use np.errstate to catch floating point errors as exceptions\n            with np.errstate(all='raise'):\n                # --- Initial force calculation and half-step kick ---\n                accel, grid_density = get_accel_and_density(particle_pos)\n                \n                # Check initial density constraint\n                if np.max(grid_density) / rho_mean  eta:\n                    return False\n                \n                vel_half = particle_vel + accel * (dt / 2.0)\n                \n                # --- Main Time Integration Loop ---\n                for _ in range(N_steps):\n                    # --- Stability Check 1: Path Length (CFL) ---\n                    if np.max(np.abs(vel_half)) * dt  theta * dx:\n                        return False\n                    \n                    # --- Drift (full step) ---\n                    particle_pos += vel_half * dt\n                    particle_pos %= L  # Periodic boundary conditions\n                    \n                    # --- Force Calculation ---\n                    accel, grid_density = get_accel_and_density(particle_pos)\n\n                    # --- Stability Check 2: Density Contrast ---\n                    if np.max(grid_density) / rho_mean  eta:\n                        return False\n\n                    # --- Kick (full step for next half-step velocity) ---\n                    vel_half_next = vel_half + accel * dt\n\n                    # --- Store velocity at full step for max velocity check ---\n                    vel_full = (vel_half + vel_half_next) / 2.0\n                    max_vel_history.append(np.max(np.abs(vel_full)))\n                    \n                    # Update velocity for next iteration\n                    vel_half = vel_half_next\n\n        except FloatingPointError:\n            # --- Stability Check 3: NaN/inf detection ---\n            return False\n            \n        # --- Stability Check 4: Max velocity over entire run ---\n        if max(max_vel_history)  gamma * v0:\n            return False\n            \n        # If all checks passed for all steps\n        return True\n\n    # Define the test cases from the problem statement.\n    test_cases = [0.2, 0.9, 1.2, 2.5]\n    \n    results = [run_simulation(r0) for r0 in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2424803"}, {"introduction": "While standard PM methods are exceptionally efficient for calculating long-range gravitational forces, they suffer from a loss of accuracy at scales smaller than the grid spacing. This final exercise introduces a powerful hybrid technique to overcome this limitation: the Particle-Particle Particle-Mesh (P³M) method. Here, you will augment a standard PM force calculation with a direct, high-precision particle-particle (PP) force summation for pairs of particles that are very close to each other—specifically, those within the same grid cell. This practice ([@problem_id:2424778]) provides a window into the advanced algorithms used in state-of-the-art cosmological simulations, demonstrating how to combine the strengths of different methods to achieve both speed and accuracy.", "problem": "Implement a complete program that computes the total gravitational acceleration on a set of particles in a periodic cubic domain using a hybrid definition that combines a mesh-based long-range field with a direct short-range contribution restricted to particle pairs occupying the same grid cell. The cubic domain is the unit cube $[0,1)^3$ with periodic boundary conditions, and all quantities are in code units where the gravitational constant is $G=1$. The goal is to compute, for each specified test case, a single scalar result equal to the sum over particles of the Euclidean norms of their total accelerations. Express each result as a decimal float in code units.\n\nThe total acceleration $\\mathbf{a}_i^{\\mathrm{tot}}$ on particle $i$ is defined as\n$$\n\\mathbf{a}_i^{\\mathrm{tot}} \\equiv \\mathbf{a}_i^{\\mathrm{PM}} + \\mathbf{a}_i^{\\mathrm{PP}},\n$$\nwhere $\\mathbf{a}_i^{\\mathrm{PM}}$ is a particle–mesh long-range field and $\\mathbf{a}_i^{\\mathrm{PP}}$ is a direct particle–particle short-range term restricted to particle pairs within the same grid cell. The long-range field $\\mathbf{a}^{\\mathrm{PM}}(\\mathbf{x})$ is defined as follows.\n\n1. Let there be $N$ particles with positions $\\mathbf{x}_p \\in [0,1)^3$ and masses $m_p$, for $p=1,\\dots,N$. Let $N_g$ be the number of mesh points per dimension, and let the uniform grid spacing be $h \\equiv 1/N_g$. Define the mass density field on the mesh via cloud-in-cell assignment. Denote the one-dimensional cloud-in-cell weight by\n$$\nw(\\Delta) \\equiv \\begin{cases}\n1 - |\\Delta|/h,  \\text{if } |\\Delta|  h,\\\\\n0,  \\text{otherwise,}\n\\end{cases}\n$$\nand the three-dimensional shape by\n$$\nW_{\\mathrm{CIC}}(\\mathbf{x}-\\mathbf{x}_p) \\equiv w(x-x_p)\\,w(y-y_p)\\,w(z-z_p).\n$$\nLet $\\rho(\\mathbf{x}_{ijk})$ be the mesh density at node indices $(i,j,k)$ with $\\mathbf{x}_{ijk}$ the node position. The density is defined by the trilinear assignment\n$$\n\\rho(\\mathbf{x}_{ijk}) \\equiv \\sum_{p=1}^{N} \\frac{m_p}{h^3}\\, W_{\\mathrm{CIC}}(\\mathbf{x}_{ijk}-\\mathbf{x}_p),\n$$\ninterpreting indices periodically modulo $N_g$.\n\n2. Define the zero-mean density $\\rho^\\star(\\mathbf{x}_{ijk}) \\equiv \\rho(\\mathbf{x}_{ijk}) - \\bar{\\rho}$, where\n$$\n\\bar{\\rho} \\equiv \\frac{1}{N_g^3} \\sum_{i,j,k} \\rho(\\mathbf{x}_{ijk}).\n$$\n\n3. Let $\\widehat{\\rho^\\star}(\\mathbf{k})$ be the three-dimensional discrete Fourier transform of $\\rho^\\star(\\mathbf{x}_{ijk})$ with the standard discrete frequencies. Let the angular wavevector components be $k_x \\equiv 2\\pi n_x$, $k_y \\equiv 2\\pi n_y$, $k_z \\equiv 2\\pi n_z$, where $n_\\alpha$ are the integer frequencies returned by the discrete Fourier transform on a grid of spacing $h\\equiv 1/N_g$. Let $k^2 \\equiv k_x^2 + k_y^2 + k_z^2$. Define the Fourier components of the acceleration field by\n$$\n\\widehat{\\mathbf{a}}^{\\mathrm{PM}}(\\mathbf{k}) \\equiv \\begin{cases}\n\\mathbf{0},  \\text{if } \\mathbf{k}=\\mathbf{0},\\\\\n\\mathrm{i}\\,4\\pi\\,G\\,\\dfrac{\\mathbf{k}}{k^2}\\,\\widehat{\\rho^\\star}(\\mathbf{k}),  \\text{otherwise.}\n\\end{cases}\n$$\nLet $\\mathbf{a}^{\\mathrm{PM}}(\\mathbf{x}_{ijk})$ be obtained by the inverse transform of $\\widehat{\\mathbf{a}}^{\\mathrm{PM}}(\\mathbf{k})$.\n\n4. Define the long-range acceleration on particle $i$ by interpolating the mesh field to the particle position using the same cloud-in-cell weights:\n$$\n\\mathbf{a}_i^{\\mathrm{PM}} \\equiv \\sum_{i,j,k} \\mathbf{a}^{\\mathrm{PM}}(\\mathbf{x}_{ijk}) \\, W_{\\mathrm{CIC}}(\\mathbf{x}_{ijk}-\\mathbf{x}_i).\n$$\n\nThe short-range term is defined by direct summation restricted to particle pairs within the same grid cell. Let the base cell index mapping be\n$$\n\\mathbf{b}(\\mathbf{x}) \\equiv \\left(\\left\\lfloor N_g x \\right\\rfloor,\\left\\lfloor N_g y \\right\\rfloor,\\left\\lfloor N_g z \\right\\rfloor\\right) \\bmod N_g.\n$$\nLet $\\varepsilon  0$ be a softening length. For each unordered pair $\\{i,j\\}$ with $i\\neq j$ satisfying $\\mathbf{b}(\\mathbf{x}_i)=\\mathbf{b}(\\mathbf{x}_j)$, define the contribution\n$$\n\\mathbf{a}_{i\\leftarrow j}^{\\mathrm{PP}} \\equiv - G\\, m_j\\, \\frac{\\mathbf{r}_{ij}}{\\left(\\|\\mathbf{r}_{ij}\\|^2 + \\varepsilon^2\\right)^{3/2}},\n\\quad \\text{where } \\mathbf{r}_{ij}\\equiv \\mathbf{x}_i-\\mathbf{x}_j,\n$$\nand set\n$$\n\\mathbf{a}_i^{\\mathrm{PP}} \\equiv \\sum_{\\substack{j\\neq i\\\\ \\mathbf{b}(\\mathbf{x}_j)=\\mathbf{b}(\\mathbf{x}_i)}} \\mathbf{a}_{i\\leftarrow j}^{\\mathrm{PP}}.\n$$\nNote that the separation vector $\\mathbf{r}_{ij}$ is taken without any periodic image wrapping, as the same-cell condition ensures $|\\Delta_\\alpha|h$ for each component $\\alpha\\in\\{x,y,z\\}$.\n\nFor a given test case, with specified $N$, $\\{m_p\\}_{p=1}^N$, $\\{\\mathbf{x}_p\\}_{p=1}^N$, $N_g$, and $\\varepsilon$, compute the scalar\n$$\nS \\equiv \\sum_{i=1}^{N} \\left\\| \\mathbf{a}_i^{\\mathrm{tot}} \\right\\|,\n$$\nwhere $\\|\\cdot\\|$ denotes the Euclidean norm in $\\mathbb{R}^3$. Express $S$ in code units as a decimal float rounded to $10$ decimal places.\n\nUse the following test suite of parameter values:\n\n- Test case $1$ (general case with two particles in the same cell and one elsewhere):\n  - $N=3$, $N_g=16$, $\\varepsilon=10^{-3}$.\n  - Masses $(m_1,m_2,m_3)=\\left(1.0,\\,1.0,\\,2.5\\right)$.\n  - Positions $\\mathbf{x}_1=\\left(0.10,\\,0.10,\\,0.10\\right)$, $\\mathbf{x}_2=\\left(0.12,\\,0.10,\\,0.10\\right)$, $\\mathbf{x}_3=\\left(0.80,\\,0.80,\\,0.80\\right)$.\n\n- Test case $2$ (boundary-adjacent pair in different cells, no direct short-range contribution):\n  - $N=2$, $N_g=8$, $\\varepsilon=2\\times 10^{-3}$.\n  - Masses $(m_1,m_2)=\\left(1.0,\\,1.5\\right)$.\n  - Positions $\\mathbf{x}_1=\\left(0.499,\\,0.25,\\,0.25\\right)$, $\\mathbf{x}_2=\\left(0.501,\\,0.25,\\,0.25\\right)$.\n\n- Test case $3$ (multiple particles within one cell, exercising multiple direct interactions):\n  - $N=3$, $N_g=8$, $\\varepsilon=3\\times 10^{-3}$.\n  - Masses $(m_1,m_2,m_3)=\\left(0.5,\\,1.0,\\,0.75\\right)$.\n  - Positions $\\mathbf{x}_1=\\left(0.70,\\,0.10,\\,0.90\\right)$, $\\mathbf{x}_2=\\left(0.72,\\,0.09,\\,0.89\\right)$, $\\mathbf{x}_3=\\left(0.715,\\,0.105,\\,0.905\\right)$.\n\n- Test case $4$ (single particle, probing zero-mean long-range field behavior):\n  - $N=1$, $N_g=16$, $\\varepsilon=10^{-3}$.\n  - Mass $m_1=\\left(1.0\\right)$.\n  - Position $\\mathbf{x}_1=\\left(0.33,\\,0.66,\\,0.50\\right)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases. Each list element must be the value of $S$ for that test case, rounded to $10$ decimal places. For example, the output format should be exactly like\n$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$,\nwith no additional text.", "solution": "The problem requires the implementation of a hybrid particle-mesh (PM) and particle-particle (PP) method to calculate gravitational accelerations in a periodic cubic domain. The problem is well-defined, scientifically sound, and provides all necessary parameters and equations. It is a standard problem in computational physics, specifically N-body simulations. I will proceed with a detailed, step-by-step solution.\n\nThe total acceleration on a particle $i$ is the sum of a long-range PM component and a short-range PP component:\n$$\n\\mathbf{a}_i^{\\mathrm{tot}} = \\mathbf{a}_i^{\\mathrm{PM}} + \\mathbf{a}_i^{\\mathrm{PP}}\n$$\nThe final result is the sum of the magnitudes of these total accelerations over all particles, $S = \\sum_{i=1}^{N} \\left\\| \\mathbf{a}_i^{\\mathrm{tot}} \\right\\|$. We will set the gravitational constant $G = 1$.\n\n**Part 1: Particle-Mesh (PM) Acceleration**\n\nThe PM component is calculated in four stages: mass assignment, Fourier-space field solution, inverse Fourier transform, and force interpolation.\n\n**Stage 1.1: Mass Assignment**\nFirst, we discretize the mass of the $N$ particles onto a uniform grid of size $N_g \\times N_g \\times N_g$. The domain is a unit cube $[0,1)^3$, so the grid spacing is $h = 1/N_g$. We use the Cloud-in-Cell (CIC) assignment scheme. A particle at position $\\mathbf{x}_p$ contributes to the density of the $8$ nearest grid nodes. The contribution to each node is weighted by the volumetric overlap of a cloud (a cube of side length $h$ centered on the particle) and the grid cell.\n\nThe one-dimensional CIC weighting function is given by:\n$$\nw(\\Delta) = \\max(0, 1 - |\\Delta|/h)\n$$\nwhere $\\Delta$ is the distance from the particle to the grid node along one axis. The three-dimensional weight for a node at $\\mathbf{x}_{ijk}$ relative to a particle at $\\mathbf{x}_p$ is the product of the one-dimensional weights:\n$$\nW_{\\mathrm{CIC}}(\\mathbf{x}_{ijk} - \\mathbf{x}_p) = w(x_{ijk} - x_p) w(y_{ijk} - y_p) w(z_{ijk} - z_p)\n$$\nThe mass density $\\rho$ at grid node $\\mathbf{x}_{ijk}$ is the sum of contributions from all particles, normalized by the cell volume $h^3$:\n$$\n\\rho(\\mathbf{x}_{ijk}) = \\frac{1}{h^3} \\sum_{p=1}^{N} m_p W_{\\mathrm{CIC}}(\\mathbf{x}_{ijk} - \\mathbf{x}_p)\n$$\nIndices are handled periodically modulo $N_g$.\n\n**Stage 1.2: Fourier-Space Solution**\nThe gravitational potential $\\phi$ is related to the mass density by Poisson's equation, $\\nabla^2\\phi = 4\\pi G \\rho$. To solve this in a periodic domain, we use the Fourier transform. First, we compute the mean density $\\bar{\\rho}$ and subtract it to obtain the zero-mean density fluctuation field, $\\rho^\\star = \\rho - \\bar{\\rho}$. This step is crucial for periodic systems to ensure the mean gravitational force is zero, correctly handling the $\\mathbf{k}=\\mathbf{0}$ mode in Fourier space.\n$$\n\\bar{\\rho} = \\frac{1}{N_g^3} \\sum_{i,j,k=0}^{N_g-1} \\rho(\\mathbf{x}_{ijk})\n$$\nIn Fourier space, Poisson's equation becomes an algebraic relation. Let $\\widehat{\\rho^\\star}(\\mathbf{k})$ be the discrete Fourier transform (DFT) of $\\rho^\\star(\\mathbf{x}_{ijk})$. The DFT of the acceleration field $\\mathbf{a} = -\\nabla\\phi$ is given by:\n$$\n\\widehat{\\mathbf{a}}^{\\mathrm{PM}}(\\mathbf{k}) = -i\\mathbf{k}\\widehat{\\phi}(\\mathbf{k}) = -i\\mathbf{k} \\left( \\frac{4\\pi G \\widehat{\\rho^\\star}(\\mathbf{k})}{-k^2} \\right) = i 4\\pi G \\frac{\\mathbf{k}}{k^2} \\widehat{\\rho^\\star}(\\mathbf{k})\n$$\nwhere $\\mathbf{k} = (k_x, k_y, k_z)$ is the wavevector and $k^2 = \\|\\mathbf{k}\\|^2$. The wavevectors are determined by the grid: $k_\\alpha = 2\\pi n_\\alpha$ for a unit box, where $n_\\alpha$ are integer frequencies from the DFT. For $\\mathbf{k}=\\mathbf{0}$, the potential is undefined, but since we use $\\rho^\\star$, $\\widehat{\\rho^\\star}(\\mathbf{k}=\\mathbf{0})=0$, and we define $\\widehat{\\mathbf{a}}^{\\mathrm{PM}}(\\mathbf{k}=\\mathbf{0})=\\mathbf{0}$.\n\n**Stage 1.3: Inverse Transform**\nThe real-space acceleration field on the grid, $\\mathbf{a}^{\\mathrm{PM}}(\\mathbf{x}_{ijk})$, is obtained by applying the inverse DFT to each component of $\\widehat{\\mathbf{a}}^{\\mathrm{PM}}(\\mathbf{k})$.\n$$\n\\mathbf{a}^{\\mathrm{PM}}(\\mathbf{x}_{ijk}) = \\text{IDFT} \\left[ \\widehat{\\mathbf{a}}^{\\mathrm{PM}}(\\mathbf{k}) \\right]\n$$\n\n**Stage 1.4: Force Interpolation**\nFinally, the PM acceleration on particle $i$ at position $\\mathbf{x}_i$ is found by interpolating the grid-based acceleration field back to the particle's position. This is done using the same CIC weighting scheme used for mass assignment, which ensures momentum conservation:\n$$\n\\mathbf{a}_i^{\\mathrm{PM}} = \\sum_{i,j,k} \\mathbf{a}^{\\mathrm{PM}}(\\mathbf{x}_{ijk}) W_{\\mathrm{CIC}}(\\mathbf{x}_{ijk} - \\mathbf{x}_i)\n$$\n\n**Part 2: Particle-Particle (PP) Acceleration**\n\nThe PP component accounts for short-range interactions that are poorly resolved on the mesh. The problem defines this term as a direct summation over particle pairs that reside within the same grid cell.\n\nFirst, we associate each particle with a base grid cell index $\\mathbf{b}(\\mathbf{x}) = (\\lfloor N_g x \\rfloor, \\lfloor N_g y \\rfloor, \\lfloor N_g z \\rfloor) \\pmod{N_g}$.\nFor any two distinct particles $i$ and $j$ such that $\\mathbf{b}(\\mathbf{x}_i) = \\mathbf{b}(\\mathbf{x}_j)$, a direct force is calculated. The acceleration on particle $i$ due to particle $j$ is given by the softened Newtonian gravity law:\n$$\n\\mathbf{a}_{i\\leftarrow j}^{\\mathrm{PP}} = -G m_j \\frac{\\mathbf{r}_{ij}}{(\\|\\mathbf{r}_{ij}\\|^2 + \\varepsilon^2)^{3/2}}\n$$\nwhere $\\mathbf{r}_{ij} = \\mathbf{x}_i - \\mathbf{x}_j$ is the direct separation vector and $\\varepsilon$ is the softening length to prevent singularities at small separations. The total PP acceleration on particle $i$ is the sum over all other particles $j$ in the same cell:\n$$\n\\mathbf{a}_i^{\\mathrm{PP}} = \\sum_{\\substack{j \\neq i \\\\ \\mathbf{b}(\\mathbf{x}_j) = \\mathbf{b}(\\mathbf{x}_i)}} \\mathbf{a}_{i\\leftarrow j}^{\\mathrm{PP}}\n$$\n\n**Part 3: Final Calculation**\n\nFor each particle $i$, the total acceleration is computed by summing the two components: $\\mathbf{a}_i^{\\mathrm{tot}} = \\mathbf{a}_i^{\\mathrm{PM}} + \\mathbf{a}_i^{\\mathrm{PP}}$. The final quantity to be computed is the scalar sum of the Euclidean norms of these total acceleration vectors:\n$$\nS = \\sum_{i=1}^{N} \\left\\| \\mathbf{a}_i^{\\mathrm{tot}} \\right\\| = \\sum_{i=1}^{N} \\sqrt{(a_{i,x}^{\\mathrm{tot}})^2 + (a_{i,y}^{\\mathrm{tot}})^2 + (a_{i,z}^{\\mathrm{tot}})^2}\n$$\nThis procedure is applied to each of the provided test cases.", "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef _compute_s(N, masses, positions, Ng, eps):\n    \"\"\"\n    Computes the total gravitational acceleration sum S for a set of particles.\n    \"\"\"\n    G = 1.0\n    h = 1.0 / Ng\n\n    # --- Part 1: Particle-Mesh (PM) Acceleration ---\n\n    # 1.1: Mass Assignment (CIC)\n    rho = np.zeros((Ng, Ng, Ng), dtype=np.float64)\n    for p in range(N):\n        m_p = masses[p]\n        pos_p = positions[p]\n        \n        scaled_pos = pos_p * Ng\n        base_idx = np.floor(scaled_pos).astype(int)\n        frac_pos = scaled_pos - base_idx\n\n        # Distribute mass to 8 neighboring nodes\n        for di in range(2):\n            for dj in range(2):\n                for dk in range(2):\n                    node_idx = (\n                        (base_idx[0] + di) % Ng,\n                        (base_idx[1] + dj) % Ng,\n                        (base_idx[2] + dk) % Ng,\n                    )\n\n                    # Trilinear weight\n                    wx = (1 - di) * (1 - frac_pos[0]) + di * frac_pos[0]\n                    wy = (1 - dj) * (1 - frac_pos[1]) + dj * frac_pos[1]\n                    wz = (1 - dk) * (1 - frac_pos[2]) + dk * frac_pos[2]\n                    weight = wx * wy * wz\n                    \n                    rho[node_idx] += m_p * weight / (h**3)\n\n    # 1.2: Fourier-Space Field Solution\n    rho_mean = np.mean(rho)\n    rho_star = rho - rho_mean\n    rho_star_k = np.fft.fftn(rho_star)\n\n    # Generate k-vectors\n    k_freq = np.fft.fftfreq(Ng, h) * (2 * np.pi)\n    Kx, Ky, Kz = np.meshgrid(k_freq, k_freq, k_freq, indexing='ij')\n    K2 = Kx**2 + Ky**2 + Kz**2\n\n    # Avoid division by zero for k=0 mode\n    # The numerator rho_star_k[0,0,0] is already zero, but this is safer\n    K2[0, 0, 0] = 1.0\n    \n    # Fourier-space acceleration field\n    # a_hat = i * 4 * pi * G * k / k^2 * rho_star_k\n    prefactor = 1j * 4 * np.pi * G / K2\n    a_pm_k_x = prefactor * Kx * rho_star_k\n    a_pm_k_y = prefactor * Ky * rho_star_k\n    a_pm_k_z = prefactor * Kz * rho_star_k\n\n    # Set k=0 mode to zero explicitly\n    a_pm_k_x[0, 0, 0] = 0.0\n    a_pm_k_y[0, 0, 0] = 0.0\n    a_pm_k_z[0, 0, 0] = 0.0\n    \n    # 1.3: Inverse Transform to get grid-based acceleration\n    a_pm_grid_x = np.real(np.fft.ifftn(a_pm_k_x))\n    a_pm_grid_y = np.real(np.fft.ifftn(a_pm_k_y))\n    a_pm_grid_z = np.real(np.fft.ifftn(a_pm_k_z))\n    a_pm_grid = np.stack((a_pm_grid_x, a_pm_grid_y, a_pm_grid_z), axis=-1)\n\n    # 1.4: Force Interpolation (CIC)\n    a_pm = np.zeros((N, 3), dtype=np.float64)\n    for p in range(N):\n        pos_p = positions[p]\n        \n        scaled_pos = pos_p * Ng\n        base_idx = np.floor(scaled_pos).astype(int)\n        frac_pos = scaled_pos - base_idx\n        \n        accel_p = np.zeros(3, dtype=np.float64)\n        for di in range(2):\n            for dj in range(2):\n                for dk in range(2):\n                    node_idx = (\n                        (base_idx[0] + di) % Ng,\n                        (base_idx[1] + dj) % Ng,\n                        (base_idx[2] + dk) % Ng,\n                    )\n                    \n                    wx = (1 - di) * (1 - frac_pos[0]) + di * frac_pos[0]\n                    wy = (1 - dj) * (1 - frac_pos[1]) + dj * frac_pos[1]\n                    wz = (1 - dk) * (1 - frac_pos[2]) + dk * frac_pos[2]\n                    weight = wx * wy * wz\n                    \n                    accel_p += a_pm_grid[node_idx] * weight\n        a_pm[p] = accel_p\n\n    # --- Part 2: Particle-Particle (PP) Acceleration ---\n    \n    cell_map = defaultdict(list)\n    for p in range(N):\n        cell_idx = tuple(np.floor(positions[p] * Ng).astype(int))\n        cell_map[cell_idx].append(p)\n    \n    a_pp = np.zeros((N, 3), dtype=np.float64)\n    for cell_idx, particles_in_cell in cell_map.items():\n        if len(particles_in_cell)  1:\n            for i, j in combinations(particles_in_cell, 2):\n                rij = positions[i] - positions[j]\n                r_sq = np.sum(rij**2)\n                dist_cubed = (r_sq + eps**2)**1.5\n                \n                # Acceleration on i due to j\n                accel_on_i = -G * masses[j] * rij / dist_cubed\n                # Acceleration on j due to i (by Newton's 3rd law symmetry)\n                accel_on_j = G * masses[i] * rij / dist_cubed\n                \n                a_pp[i] += accel_on_i\n                a_pp[j] += accel_on_j\n\n    # --- Part 3: Final Calculation ---\n    \n    a_tot = a_pm + a_pp\n    norms = np.linalg.norm(a_tot, axis=1)\n    S = np.sum(norms)\n\n    return S\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 3, \"Ng\": 16, \"eps\": 1e-3,\n            \"masses\": np.array([1.0, 1.0, 2.5]),\n            \"positions\": np.array([\n                [0.10, 0.10, 0.10],\n                [0.12, 0.10, 0.10],\n                [0.80, 0.80, 0.80]\n            ])\n        },\n        {\n            \"N\": 2, \"Ng\": 8, \"eps\": 2e-3,\n            \"masses\": np.array([1.0, 1.5]),\n            \"positions\": np.array([\n                [0.499, 0.25, 0.25],\n                [0.501, 0.25, 0.25]\n            ])\n        },\n        {\n            \"N\": 3, \"Ng\": 8, \"eps\": 3e-3,\n            \"masses\": np.array([0.5, 1.0, 0.75]),\n            \"positions\": np.array([\n                [0.70, 0.10, 0.90],\n                [0.72, 0.09, 0.89],\n                [0.715, 0.105, 0.905]\n            ])\n        },\n        {\n            \"N\": 1, \"Ng\": 16, \"eps\": 1e-3,\n            \"masses\": np.array([1.0]),\n            \"positions\": np.array([\n                [0.33, 0.66, 0.50]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _compute_s(\n            case[\"N\"], case[\"masses\"], case[\"positions\"], case[\"Ng\"], case[\"eps\"]\n        )\n        results.append(f\"{result:.10f}\")\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2424778"}]}