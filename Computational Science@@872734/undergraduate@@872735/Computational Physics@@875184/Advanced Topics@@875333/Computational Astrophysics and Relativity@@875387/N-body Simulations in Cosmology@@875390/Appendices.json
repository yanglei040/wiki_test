{"hands_on_practices": [{"introduction": "Before running a large simulation, it's crucial to understand the properties of the objects we aim to model, such as dark matter halos. This exercise guides you through the construction of an idealized, stable halo, grounding the simulation in fundamental physics. By implementing a deterministic procedure to generate particle positions and velocities, you will test the virial theorem, $2T + U = 0$, which governs the equilibrium of self-gravitating systems and serves as a powerful diagnostic for the stability of simulated structures [@problem_id:2416301].", "problem": "You are to write a complete, runnable program that constructs deterministic, isolated, self-gravitating particle systems representing idealized dark matter halos and quantitatively tests the virial theorem condition $2T + U = 0$ by reporting the dimensionless virial residual for several specified cases. All quantities are in dimensionless $N$-body units with gravitational constant $G = 1$, and all angles are in radians. The outputs are to be dimensionless real numbers.\n\nConsider a system of $N$ equal-mass particles with total mass $M$ modeled under Newtonian gravity with Plummer-type softening of length $\\epsilon  0$. Let particle positions be $\\{\\mathbf{r}_i\\}_{i=1}^N$ and velocities be $\\{\\mathbf{v}_i\\}_{i=1}^N$. Define the kinetic energy in the center-of-mass frame as\n$$\nT = \\frac{1}{2} \\, m \\sum_{i=1}^N \\left\\lVert \\mathbf{v}_i - \\mathbf{v}_{\\mathrm{cm}} \\right\\rVert^2, \\quad \\text{with} \\quad \\mathbf{v}_{\\mathrm{cm}} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{v}_i,\n$$\nwhere $m = M/N$. Define the softened gravitational potential energy as\n$$\nU = - G \\sum_{1 \\le i  j \\le N} \\frac{m^2}{\\sqrt{\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert^2 + \\epsilon^2}}.\n$$\nThe virial theorem for a steady, isolated system under an inverse-square force predicts $2T + U = 0$.\n\nInitial conditions are fully specified deterministically as follows.\n\n- Positions: For a given $N$ and outer scale $R  0$, place particle $k \\in \\{1,\\dots,N\\}$ at spherical angles and radius\n$$\nq_k = \\frac{k}{N+1}, \\quad r_k = R \\, q_k, \\quad \\theta_k = \\arccos(1 - 2 q_k), \\quad \\phi_k = \\frac{2\\pi k}{\\varphi},\n$$\nwhere $\\varphi = \\frac{1+\\sqrt{5}}{2}$ is the golden ratio. The Cartesian position is\n$$\n\\mathbf{r}_k = r_k \\begin{bmatrix} \\cos \\phi_k \\, \\sin \\theta_k \\\\ \\sin \\phi_k \\, \\sin \\theta_k \\\\ \\cos \\theta_k \\end{bmatrix}.\n$$\n\n- Velocities: For a given nonnegative dimensionless factor $f$, define a deterministic tangential direction for each particle by\n$$\n\\hat{\\mathbf{t}}_k = \\frac{\\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k}{\\lVert \\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k \\rVert} \\quad \\text{if } \\lVert \\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k \\rVert  10^{-12}, \\quad \\text{otherwise} \\quad \\hat{\\mathbf{t}}_k = \\frac{\\mathbf{e}_x \\times \\hat{\\mathbf{r}}_k}{\\lVert \\mathbf{e}_x \\times \\hat{\\mathbf{r}}_k \\rVert},\n$$\nwhere $\\hat{\\mathbf{r}}_k = \\mathbf{r}_k / \\lVert \\mathbf{r}_k \\rVert$, $\\mathbf{e}_z = [0,0,1]^T$, and $\\mathbf{e}_x = [1,0,0]^T$. Construct the base tangential field $\\mathbf{u}_k = r_k \\, \\hat{\\mathbf{t}}_k$, its mean $\\mathbf{u}_{\\mathrm{cm}} = \\frac{1}{N}\\sum_{k=1}^N \\mathbf{u}_k$, and choose a scalar $s \\ge 0$ so that the center-of-mass kinetic energy equals\n$$\nT_{\\mathrm{target}} = f^2 \\left(-\\frac{U}{2}\\right).\n$$\nSpecifically, set\n$$\n\\mathbf{v}_k = s \\left(\\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}}\\right), \\quad \\text{with} \\quad s = \\sqrt{\\frac{2 T_{\\mathrm{target}}}{m \\sum_{k=1}^N \\lVert \\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}} \\rVert^2}},\n$$\nand interpret $s = 0$ when $T_{\\mathrm{target}} = 0$.\n\n- Softening: Use a Plummer softening length $\\epsilon = \\eta \\, R$ where $\\eta$ is a specified dimensionless fraction.\n\nFor each test case below, compute the dimensionless virial residual\n$$\n\\nu = \\frac{2T + U}{\\lvert U \\rvert}.\n$$\n\nYour program must implement the above deterministic construction and produce, for the following test suite, the value of $\\nu$ for each case:\n\n- Case $1$: $N = 64$, $M = 1.0$, $R = 1.0$, $\\eta = 0.05$, $f = 1.0$.\n- Case $2$: $N = 8$, $M = 2.0$, $R = 0.5$, $\\eta = 0.1$, $f = 0.5$.\n- Case $3$: $N = 2$, $M = 1.0$, $R = 1.0$, $\\eta = 0.01$, $f = 0.0$.\n- Case $4$: $N = 3$, $M = 1.0$, $R = 1.5$, $\\eta = 0.2$, $f = 1.2$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list of floats rounded to six decimals, enclosed in square brackets, in the same order as the cases above (for example, \"[0.000000,-0.750000,-1.000000,0.440000]\").", "solution": "The problem statement has been subjected to rigorous validation. All givens, definitions, and constraints have been extracted and analyzed. The problem is found to be valid. It is scientifically grounded in Newtonian mechanics, internally consistent, and methodologically well-posed. It presents a clear, deterministic algorithm for the construction of an N-body system and the subsequent calculation of a physical observable. The provided parameters for the test cases are physically reasonable and computationally feasible. The analytical relationship $\\nu = f^2 - 1$, which can be derived directly from the problem's definitions, serves as a crucial verification target for the numerical implementation. The problem is a valid exercise in computational physics, testing both theoretical comprehension and implementation accuracy. We shall proceed to construct the solution.\n\nThe task is to compute the virial residual, $\\nu = \\frac{2T + U}{\\lvert U \\rvert}$, for several specified multi-particle systems. This requires a systematic, step-by-step construction of the initial conditions (positions and velocities) for each system, followed by the calculation of the total kinetic ($T$) and potential ($U$) energies.\n\nFirst, we establish the system parameters for a given case: the number of particles $N$, total mass $M$, outer scale radius $R$, softening fraction $\\eta$, and kinetic energy factor $f$. The gravitational constant is given as $G=1$. From these, we derive the mass of each particle, $m = M/N$, and the Plummer softening length, $\\epsilon = \\eta R$.\n\nThe generation of particle positions $\\{\\mathbf{r}_k\\}_{k=1}^N$ is the initial step. This procedure is deterministic. For each particle indexed by $k \\in \\{1, \\dots, N\\}$, we compute an intermediate variable $q_k = \\frac{k}{N+1}$. This variable is used to define the spherical coordinates of the particle: the radius $r_k = R \\, q_k$, the polar angle $\\theta_k = \\arccos(1 - 2 q_k)$, and the azimuthal angle $\\phi_k = \\frac{2\\pi k}{\\varphi}$, where $\\varphi = \\frac{1+\\sqrt{5}}{2}$ is the golden ratio. This method of distributing points is a variant of a Fibonacci spiral on a sphere, which yields a reasonably uniform angular distribution. The radial distribution is a simple linear ramp. The spherical coordinates are then converted to Cartesian coordinates $\\mathbf{r}_k = [x_k, y_k, z_k]^T$ using the standard transformation:\n$$\n\\mathbf{r}_k = r_k \\begin{pmatrix} \\cos \\phi_k \\sin \\theta_k \\\\ \\sin \\phi_k \\sin \\theta_k \\\\ \\cos \\theta_k \\end{pmatrix}.\n$$\n\nOnce all particle positions are known, we can calculate the total potential energy $U$ of the system. The potential energy is the sum of pairwise interactions under a softened gravitational potential. The formula is:\n$$\nU = - G \\sum_{1 \\le i  j \\le N} \\frac{m^2}{\\sqrt{\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert^2 + \\epsilon^2}}.\n$$\nThe summation is over all unique pairs of particles $(i, j)$ with $i  j$ to avoid double-counting interactions. The term $\\epsilon^2$ in the denominator is the Plummer softening, which prevents the potential from diverging to negative infinity for very close particles. For any system with $N \\ge 2$, $U$ will be negative.\n\nNext, we establish the velocities. The procedure is designed to impart a specific amount of kinetic energy to the system, related to its potential energy. The target kinetic energy is defined as $T_{\\mathrm{target}} = f^2 \\left(-\\frac{U}{2}\\right)$. The factor $f$ scales the initial kinetic energy relative to the amount required for virial equilibrium (where $T = -U/2$).\n\nTo generate velocities that result in this kinetic energy, we first define a deterministic velocity field that is subsequently scaled. For each particle $k$, a tangential direction vector $\\hat{\\mathbf{t}}_k$ is constructed. This vector is orthogonal to the particle's position vector $\\hat{\\mathbf{r}}_k = \\mathbf{r}_k / \\lVert \\mathbf{r}_k \\rVert$. It is computed via the cross product with the fixed z-axis unit vector $\\mathbf{e}_z = [0,0,1]^T$:\n$$\n\\hat{\\mathbf{t}}_k = \\frac{\\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k}{\\lVert \\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k \\rVert}.\n$$\nA numerical stability check is included for cases where $\\hat{\\mathbf{r}}_k$ is nearly collinear with $\\mathbf{e}_z$, in which instance the cross product with $\\mathbf{e}_x = [1,0,0]^T$ is used instead. A base velocity field is then defined as $\\mathbf{u}_k = r_k \\, \\hat{\\mathbf{t}}_k$.\n\nTo ensure the final system has zero net momentum, the velocities are set in the center-of-mass frame of the base field $\\mathbf{u}_k$. We compute the mean $\\mathbf{u}_{\\mathrm{cm}} = \\frac{1}{N}\\sum_{k=1}^N \\mathbf{u}_k$ and define a set of unscaled, zero-center-of-mass velocities $\\mathbf{u}'_k = \\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}}$. The final velocities are obtained by scaling these vectors, $\\mathbf{v}_k = s \\, \\mathbf{u}'_k$, where the scalar $s \\ge 0$ is chosen to satisfy the target kinetic energy. The kinetic energy in the center-of-mass frame is $T = \\frac{1}{2} m \\sum_{k=1}^N \\lVert \\mathbf{v}_k \\rVert^2$ (since the final center-of-mass velocity is zero by construction). Substituting $\\mathbf{v}_k = s(\\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}})$ and setting $T = T_{\\mathrm{target}}$ yields the expression for the scaling factor:\n$$\ns = \\sqrt{\\frac{2 T_{\\mathrm{target}}}{m \\sum_{k=1}^N \\lVert \\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}} \\rVert^2}}.\n$$\nIf $T_{\\mathrm{target}} = 0$ (which occurs when $f=0$), then $s=0$ and all particles are at rest.\n\nWith the velocities $\\{\\mathbf{v}_k\\}_{k=1}^N$ fully determined, the actual kinetic energy $T$ of the system is computed. It is defined in the center-of-mass frame:\n$$\nT = \\frac{1}{2} \\, m \\sum_{i=1}^N \\left\\lVert \\mathbf{v}_i - \\mathbf{v}_{\\mathrm{cm}} \\right\\rVert^2, \\quad \\text{where} \\quad \\mathbf{v}_{\\mathrm{cm}} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{v}_i.\n$$\nBy construction, $\\mathbf{v}_{\\mathrm{cm}}$ is analytically zero, but its explicit calculation and subtraction provides numerical robustness. The computed value of $T$ should be equal to $T_{\\mathrm{target}}$ to within machine precision.\n\nFinally, the dimensionless virial residual $\\nu$ is calculated using the computed values of $T$ and $U$:\n$$\n\\nu = \\frac{2T + U}{\\lvert U \\rvert}.\n$$\nSince $U0$, this is equivalent to $\\nu = -(2T+U)/U$. As shown by the analytical check, since $T$ is constructed to be $T = f^2(-U/2)$, we expect $\\nu = f^2 - 1$. The numerical implementation must reproduce this result for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_virial_residual(N, M, R, eta, f):\n    \"\"\"\n    Constructs a deterministic N-body system and calculates its virial residual.\n\n    Args:\n        N (int): Number of particles.\n        M (float): Total mass of the system.\n        R (float): Outer scale radius.\n        eta (float): Dimensionless softening fraction.\n        f (float): Dimensionless factor for target kinetic energy.\n\n    Returns:\n        float: The dimensionless virial residual nu.\n    \"\"\"\n    # 1. System constants and derived parameters\n    G = 1.0\n    phi_const = (1.0 + np.sqrt(5.0)) / 2.0\n    m = M / float(N)\n    epsilon = eta * R\n\n    # 2. Generate particle positions\n    k = np.arange(1, N + 1, dtype=np.float64)\n    q_k = k / (N + 1.0)\n    r_k = R * q_k\n    theta_k = np.arccos(1.0 - 2.0 * q_k)\n    phi_k = 2.0 * np.pi * k / phi_const\n\n    x = r_k * np.sin(theta_k) * np.cos(phi_k)\n    y = r_k * np.sin(theta_k) * np.sin(phi_k)\n    z = r_k * np.cos(theta_k)\n    positions = np.vstack((x, y, z)).T  # Shape: (N, 3)\n\n    # 3. Calculate potential energy U\n    if N  2:\n        U = 0.0\n    else:\n        # Use broadcasting to get all pairwise squared distances efficiently\n        r_diff = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]\n        dist_sq = np.sum(r_diff**2, axis=-1)\n        \n        # Get indices for the upper triangle of the distance matrix to sum unique pairs\n        i_upper, j_upper = np.triu_indices(N, k=1)\n        \n        pairwise_dist = np.sqrt(dist_sq[i_upper, j_upper] + epsilon**2)\n        U = -G * m**2 * np.sum(1.0 / pairwise_dist)\n\n    # 4. Calculate target kinetic energy\n    T_target = f**2 * (-U / 2.0)\n\n    # 5. Generate particle velocities\n    if T_target  1e-15: # Handles f=0 case and avoids precision issues\n        velocities = np.zeros((N, 3))\n    else:\n        # Normalize position vectors to get unit vectors r_hat\n        r_norms = np.linalg.norm(positions, axis=1, keepdims=True)\n        r_hat = positions / r_norms\n\n        # Define canonical basis vectors\n        ez = np.array([0.0, 0.0, 1.0])\n        ex = np.array([1.0, 0.0, 0.0])\n\n        # Calculate tangential directions t_hat\n        c_z = np.cross(ez, r_hat)\n        c_z_norms = np.linalg.norm(c_z, axis=1, keepdims=True)\n        t_hat = np.zeros_like(positions)\n        \n        # Numerically stable case (not near z-axis)\n        mask_stable = (c_z_norms  1e-12).flatten()\n        if np.any(mask_stable):\n            t_hat[mask_stable] = c_z[mask_stable] / c_z_norms[mask_stable]\n\n        # Fallback for particles near z-axis\n        mask_unstable = ~mask_stable\n        if np.any(mask_unstable):\n            c_x = np.cross(ex, r_hat[mask_unstable])\n            c_x_norms = np.linalg.norm(c_x, axis=1, keepdims=True)\n            t_hat[mask_unstable] = c_x / c_x_norms\n\n        # Base tangential velocity field u\n        u = r_k[:, np.newaxis] * t_hat\n        \n        # Make field have zero center of mass\n        u_cm = np.mean(u, axis=0)\n        u_prime = u - u_cm\n        \n        # Calculate velocity scaling factor s\n        s_sq_denom = m * np.sum(np.linalg.norm(u_prime, axis=1)**2)\n        \n        if s_sq_denom  1e-15:\n            # This should not occur for N1 with this position generator\n            s = 0.0\n        else:\n            s = np.sqrt(2.0 * T_target / s_sq_denom)\n\n        velocities = s * u_prime\n\n    # 6. Calculate actual kinetic energy T in the center-of-mass frame\n    v_cm = np.mean(velocities, axis=0)\n    v_prime = velocities - v_cm\n    T = 0.5 * m * np.sum(np.linalg.norm(v_prime, axis=1)**2)\n    \n    # 7. Calculate the dimensionless virial residual\n    if np.abs(U)  1e-15:\n        # Unlikely for N1, but handles division by zero\n        return 0.0\n\n    nu = (2.0 * T + U) / np.abs(U)\n    \n    return nu\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, M, R, eta, f)\n        (64, 1.0, 1.0, 0.05, 1.0),\n        (8, 2.0, 0.5, 0.1, 0.5),\n        (2, 1.0, 1.0, 0.01, 0.0),\n        (3, 1.0, 1.5, 0.2, 1.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, R, eta, f = case\n        result = calculate_virial_residual(N, M, R, eta, f)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2416301"}, {"introduction": "The engine of any N-body simulation is its force calculation. Since directly summing pairwise forces is too slow for cosmological scales, efficient methods are essential. This practice delves into the Particle-Mesh (PM) method, which solves the gravitational Poisson equation, $\\nabla^2 \\phi = 4\\pi G \\rho$, on a grid using the Fast Fourier Transform (FFT). Implementing a PM solver from first principles will give you a deep understanding of how long-range gravitational forces are computed efficiently in modern simulations [@problem_id:2416244].", "problem": "Implement a complete two-dimensional Particle-Mesh (PM) solver using Fast Fourier Transform (FFT) methods to solve the Newtonian cosmological Poisson equation with periodic boundary conditions. The governing equation is the three-dimensional Poisson equation applied to a configuration that is translationally invariant along one axis, so that the field and source depend only on two spatial coordinates:\n$$\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi G \\rho(\\mathbf{x}),$$\nwith periodic boundary conditions on a square domain. Work in code units with box side length $L = 1$ and gravitational constant $G = 1$. In this setting, $\\rho(\\mathbf{x})$ is the mass density field per unit area induced by particles through mass assignment, or directly prescribed as an analytic function on the grid, and $\\phi(\\mathbf{x})$ is the gravitational potential. The acceleration field is given by\n$$\\mathbf{a}(\\mathbf{x}) = - \\nabla \\phi(\\mathbf{x}).$$\nStart from the fundamental definitions of the discrete Fourier transform on a periodic grid and Newtonian gravity, and derive the spectral solution that enables you to compute the acceleration field from the density field via FFTs. Do not use any pre-existing potential or force kernels; derive and implement them directly from the governing equation and the definition of the Fourier transform. Use Cloud-In-Cell (CIC) mass assignment to deposit particle masses onto the grid, and use the same CIC weights to interpolate the grid acceleration back to particle positions to minimize grid-induced self-force. Treat the zero wave number (mean-density) mode consistently with cosmological convention by enforcing a zero-mean source: set the $k=\\mathbf{0}$ mode to zero so that the potential has no uniform or linearly growing component.\n\nYour program must:\n- Implement periodic boundary conditions on a uniform two-dimensional grid of size $N \\times N$ with $N$ a power of $2$.\n- Implement the CIC mass assignment scheme to map particle masses to a gridded density field $\\rho_{i,j}$ on the domain $[0,L)\\times[0,L)$ with $L=1$.\n- Implement the FFT-based spectral Poisson solver to obtain either the potential $\\phi$ and then $\\mathbf{a}=-\\nabla \\phi$, or directly the acceleration field $\\mathbf{a}$ from $\\rho$ in Fourier space.\n- Interpolate the acceleration field from the grid back to particle positions using the same CIC weights used for mass assignment.\n- Use double precision floating point arithmetic.\n\nDesign a deterministic test suite to validate distinct aspects of the implementation. Use the following four test cases (all in code units with $L=1$ and $G=1$):\n- Test A (Fourier-mode solver accuracy): On a grid with $N=64$, set the density field analytically on the grid as $\\rho(x,y) = \\cos(2\\pi x)$. Solve for the potential $\\phi(x,y)$ via your spectral method and compare it to the exact solution implied by the governing equation and periodic boundary conditions. Compute the maximum absolute error over all grid points,\n$$\\varepsilon_{\\mathrm{mode}} = \\max_{i,j} \\left| \\phi_{\\mathrm{num}}(x_i,y_j) - \\phi_{\\mathrm{exact}}(x_i,y_j) \\right|,$$\nand report $\\varepsilon_{\\mathrm{mode}}$ as a floating-point number.\n- Test B (two-particle symmetry away from boundaries): On a grid with $N=64$, place two equal-mass particles of mass $m_1=m_2 = \\tfrac{1}{2}$ at positions $(x_1,y_1)=(0.25,0.5)$ and $(x_2,y_2)=(0.75,0.5)$. Deposit to the grid using CIC, subtract the mean density, compute the grid acceleration, and interpolate accelerations back to the particle positions. Define the symmetry error as\n$$\\varepsilon_{\\mathrm{sym}} = \\frac{\\max\\!\\left(\\left\\|\\mathbf{a}_1+\\mathbf{a}_2\\right\\|, \\, |a_{1,y}|+|a_{2,y}|\\right)}{\\max\\!\\left(\\left\\|\\mathbf{a}_1\\right\\|, \\left\\|\\mathbf{a}_2\\right\\|\\right)},$$\nand report $\\varepsilon_{\\mathrm{sym}}$ as a floating-point number.\n- Test C (net-force consistency for many particles): On a grid with $N=64$, place $N_{\\mathrm{p}}=200$ particles at positions drawn uniformly in $[0,1)\\times[0,1)$ with equal masses $m_i = 1/N_{\\mathrm{p}}$. Deposit via CIC, subtract the mean density, compute the acceleration grid, and interpolate to particle positions. Compute the magnitude of the net mass-weighted acceleration,\n$$\\varepsilon_{\\mathrm{net}} = \\left\\| \\sum_{i=1}^{N_{\\mathrm{p}}} m_i \\, \\mathbf{a}_i \\right\\|,$$\nand report $\\varepsilon_{\\mathrm{net}}$ as a floating-point number.\n- Test D (periodic wrap symmetry): On a grid with $N=64$, place two equal-mass particles of mass $m_1=m_2=\\tfrac{1}{2}$ at positions $(x_1,y_1)=(0.01,0.5)$ and $(x_2,y_2)=(0.99,0.5)$, which are separated across the periodic boundary. Repeat the CIC deposition, mean subtraction, acceleration computation, and interpolation. Compute and report the same symmetry error $\\varepsilon_{\\mathrm{sym,wrap}}$ as in Test B.\n\nAngle units are not used in this problem. All quantities are dimensionless code units as specified. Your program must compute the four scalar results for Tests A, B, C, and D in that order, and produce a single line of output containing these four values as a comma-separated list enclosed in square brackets, for example\n\"[v_A,v_B,v_C,v_D]\".\nEach value must be printed as a decimal in standard floating-point notation.\n\nYour implementation must be complete and self-contained, and it must not read any external input. The random particle positions in Test C must be generated with a fixed seed to ensure determinism.", "solution": "The user has provided a valid, well-posed problem in computational physics. The task is to implement a two-dimensional Particle-Mesh (PM) solver for the Newtonian Poisson equation with periodic boundary conditions and validate it with a specific suite of tests. The problem is scientifically grounded, algorithmically specific, and provides all necessary parameters for a deterministic implementation.\n\nThe solution proceeds by first deriving the spectral method for solving the Poisson equation, followed by an explanation of the mass assignment and force interpolation schemes. Finally, the numerical algorithm is outlined, which forms the basis for the provided code.\n\n### 1. The Poisson Equation and Spectral Methods\n\nThe governing equation is the two-dimensional Poisson equation for the gravitational potential $\\phi(\\mathbf{x})$ generated by a mass density distribution $\\rho(\\mathbf{x})$:\n$$ \\nabla^2 \\phi(\\mathbf{x}) = 4\\pi G \\rho(\\mathbf{x}) $$\nwhere $\\mathbf{x} = (x, y)$ are the spatial coordinates, $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ is the Laplacian operator, and $G$ is the gravitational constant. The problem is set in a square domain $[0, L) \\times [0, L)$ with periodic boundary conditions. We work in code units where $L=1$ and $G=1$.\n\nThe spectral method leverages the properties of the Fourier transform, which diagonalizes the differentiation operator. The continuous Fourier transform of a function $f(\\mathbf{x})$ is defined as $\\hat{f}(\\mathbf{k}) = \\int f(\\mathbf{x}) e^{-i \\mathbf{k} \\cdot \\mathbf{x}} d\\mathbf{x}$. Applying this to the Poisson equation, the Laplacian term becomes:\n$$ \\mathcal{F}\\{\\nabla^2 \\phi(\\mathbf{x})\\} = -\\|\\mathbf{k}\\|^2 \\hat{\\phi}(\\mathbf{k}) = -(k_x^2 + k_y^2) \\hat{\\phi}(\\mathbf{k}) $$\nHere, $\\mathbf{k}=(k_x, k_y)$ is the wavevector. The Poisson equation in Fourier space is thus an algebraic equation:\n$$ -k^2 \\hat{\\phi}(\\mathbf{k}) = 4\\pi G \\hat{\\rho}(\\mathbf{k}) $$\nwhere $k^2 = \\|\\mathbf{k}\\|^2$. This yields the solution for the potential in Fourier space:\n$$ \\hat{\\phi}(\\mathbf{k}) = - \\frac{4\\pi G \\hat{\\rho}(\\mathbf{k})}{k^2} $$\nThe acceleration field $\\mathbf{a}(\\mathbf{x}) = -\\nabla \\phi(\\mathbf{x})$ can also be found in Fourier space. The gradient operator $\\nabla$ transforms to multiplication by $i\\mathbf{k}$:\n$$ \\hat{\\mathbf{a}}(\\mathbf{k}) = -i\\mathbf{k} \\hat{\\phi}(\\mathbf{k}) = -i\\mathbf{k} \\left( -\\frac{4\\pi G \\hat{\\rho}(\\mathbf{k})}{k^2} \\right) = i \\frac{4\\pi G \\mathbf{k}}{k^2} \\hat{\\rho}(\\mathbf{k}) $$\nThis allows for direct computation of the acceleration from the density, which is often more efficient.\n\nA singularity occurs at $\\mathbf{k}=\\mathbf{0}$, where $k^2=0$. This corresponds to the mean density mode (DC component). For periodic boundary conditions, the Poisson equation has a solution only if the net source is zero, i.e., $\\int \\rho(\\mathbf{x}) d\\mathbf{x} = 0$, which implies $\\hat{\\rho}(\\mathbf{k=0}) = 0$. In cosmological simulations, one considers density fluctuations around a uniform mean density. By subtracting this mean, we ensure $\\hat{\\rho}(\\mathbf{0}) = 0$. Consequently, there is no contribution to the force from the $\\mathbf{k}=\\mathbf{0}$ mode, so we can set $\\hat{\\phi}(\\mathbf{0}) = 0$ and $\\hat{\\mathbf{a}}(\\mathbf{0}) = \\mathbf{0}$.\n\n### 2. Discretization and Numerical Implementation\n\nThe continuous domain is discretized on a uniform $N \\times N$ grid, with grid spacing $h=L/N$. A function $f(\\mathbf{x})$ is represented by its values $f_{i,j} = f(i h, j h)$ at the grid nodes. The Fourier transform is replaced by the Discrete Fourier Transform (DFT), which is computed efficiently using the Fast Fourier Transform (FFT) algorithm.\n\nThe DFT of a grid function $f_{i,j}$ is:\n$$ \\hat{f}_{k_x, k_y} = \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} f_{i,j} e^{-2\\pi i (k_x i / N + k_y j / N)} $$\nThe discrete wavevectors corresponding to the integer frequency indices $(k_x, k_y)$ are given by $\\mathbf{k} = (\\frac{2\\pi}{L} k'_x, \\frac{2\\pi}{L} k'_y)$, where $k'_x, k'_y$ are integer wavenumbers that range approximately from $-N/2$ to $N/2$.\n\nThe spectral solver algorithm is as follows:\n1.  Obtain the discrete density field $\\rho_{i,j}$ on the grid.\n2.  Compute its DFT, $\\hat{\\rho}_{k_x,k_y} = \\text{FFT}(\\rho_{i,j})$.\n3.  Enforce a zero mean density by setting $\\hat{\\rho}_{0,0} = 0$.\n4.  In Fourier space, compute the transform of the potential or acceleration. For acceleration, the components are:\n    $$ \\hat{a}_{x; k_x, k_y} = \\left( i \\frac{4\\pi G k_x}{k_x^2 + k_y^2} \\right) \\hat{\\rho}_{k_x, k_y}, \\quad \\hat{a}_{y; k_x, k_y} = \\left( i \\frac{4\\pi G k_y}{k_x^2 + k_y^2} \\right) \\hat{\\rho}_{k_x, k_y} $$\n    for $\\mathbf{k} \\ne \\mathbf{0}$, and $\\hat{\\mathbf{a}}_{0,0} = \\mathbf{0}$. The term in parentheses is the spectral response function or kernel.\n5.  Perform an inverse DFT on $\\hat{a}_{x}$ and $\\hat{a}_{y}$ to obtain the acceleration components $a_{x; i,j}$ and $a_{y; i,j}$ on the grid.\n    $$ \\mathbf{a}_{i,j} = \\text{IFFT}(\\hat{\\mathbf{a}}_{k_x,k_y}) $$\n\n### 3. Mass Assignment and Force Interpolation\n\nIn a Particle-Mesh simulation, particles represent discrete parcels of mass. The density field $\\rho_{i,j}$ is obtained by assigning the mass of each particle to the grid. The Cloud-In-Cell (CIC) scheme is a second-order mass assignment method. For a particle with mass $m_p$ at position $\\mathbf{x}_p = (x_p, y_p)$, we identify its host grid cell with bottom-left corner at $(i,j) = (\\lfloor x_p/h \\rfloor, \\lfloor y_p/h \\rfloor)$. The particle's mass is distributed to the four surrounding grid nodes using weights derived from bilinear interpolation. The fractional displacements of the particle within its cell are $\\delta_x = (x_p/h) - i$ and $\\delta_y = (y_p/h) - j$. The mass is assigned as follows:\n- To node $(i,j)$: $m_p (1-\\delta_x)(1-\\delta_y)$\n- To node $(i+1,j)$: $m_p \\delta_x(1-\\delta_y)$\n- To node $(i,j+1)$: $m_p (1-\\delta_x)\\delta_y$\n- To node $(i+1,j+1)$: $m_p \\delta_x \\delta_y$\nIndices are handled modulo $N$ to respect periodic boundary conditions. After summing contributions from all particles, the grid mass $M_{i,j}$ is converted to density via $\\rho_{i,j} = M_{i,j}/h^2$.\n\nOnce the acceleration field $\\mathbf{a}_{i,j}$ is computed on the grid, the acceleration $\\mathbf{a}_p$ at a particle's original position $\\mathbf{x}_p$ is found by interpolating from the grid. To ensure momentum conservation and cancel spurious self-forces, the interpolation must use the same weighting scheme as the mass assignment. The acceleration at the particle's position is therefore:\n$$ \\mathbf{a}_p = (1-\\delta_x)(1-\\delta_y)\\mathbf{a}_{i,j} + \\delta_x(1-\\delta_y)\\mathbf{a}_{i+1,j} + (1-\\delta_x)\\delta_y\\mathbf{a}_{i,j+1} + \\delta_x\\delta_y\\mathbf{a}_{i+1,j+1} $$\n\n### 4. Validation Tests\n\nThe problem specifies four tests to validate the implementation:\n- **Test A:** Uses an analytical density field $\\rho(x,y) = \\cos(2\\pi x)$, for which the potential is $\\phi(x,y) = -(1/\\pi)\\cos(2\\pi x)$. This tests the accuracy of the spectral Poisson solver itself, isolated from particle-grid operations. The numerical solution should match the analytical one to machine precision.\n- **Test B:** Places two particles symmetrically in the box. By symmetry, the net force on the pair should be zero, and the force on each particle should be purely along the line connecting them. This tests the PM force calculation and the CIC scheme's symmetry properties.\n- **Test C:** Uses a large number of randomly placed particles. For an isolated system, the sum of internal forces must be zero (an expression of Newton's third law). The test measures the magnitude of the net mass-weighted acceleration, $\\left\\| \\sum m_i \\mathbf{a}_i \\right\\|$, which should be close to zero for a correct implementation.\n- **Test D:** Is similar to Test B, but places particles close to the periodic boundary. This specifically tests the correct implementation of periodic wrap-around in the CIC assignment and interpolation steps.\n\nThe implementation will follow these principles to compute the required error metrics for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests a 2D Particle-Mesh (PM) solver.\n    \"\"\"\n\n    class PM_Solver:\n        \"\"\"\n        A 2D Particle-Mesh solver for the Poisson equation with periodic BCs.\n        \"\"\"\n        def __init__(self, N, L=1.0, G=1.0):\n            \"\"\"\n            Initializes the solver.\n            Args:\n                N (int): Grid size (N x N).\n                L (float): Box side length.\n                G (float): Gravitational constant.\n            \"\"\"\n            if not (N > 0 and (N  (N-1) == 0)):\n                # This is not strictly required by the mathematics but is a problem constraint\n                # pass\n                a = 1 \n            \n            self.N = N\n            self.L = float(L)\n            self.G = float(G)\n            self.h = self.L / self.N\n            self.dtype = np.float64\n\n            # Pre-compute wavevectors\n            k_freq = np.fft.fftfreq(self.N, d=self.h)\n            k_phys = 2.0 * np.pi * k_freq\n            kx_phys, ky_phys = np.meshgrid(k_phys, k_phys, indexing='ij')\n\n            # Pre-compute spectral kernels\n            k_sq = kx_phys**2 + ky_phys**2\n            \n            # Kernel for potential: -1/k^2\n            self.potential_kernel = np.zeros_like(k_sq, dtype=self.dtype)\n            nonzero = k_sq != 0\n            self.potential_kernel[nonzero] = -1.0 / k_sq[nonzero]\n\n            # Kernel for acceleration: i*k_x/k^2 and i*k_y/k^2\n            self.accel_kernel_x = np.zeros_like(k_sq, dtype=np.complex128)\n            self.accel_kernel_y = np.zeros_like(k_sq, dtype=np.complex128)\n            self.accel_kernel_x[nonzero] = 1j * kx_phys[nonzero] / k_sq[nonzero]\n            self.accel_kernel_y[nonzero] = 1j * ky_phys[nonzero] / k_sq[nonzero]\n\n\n        def _assign_mass(self, particles):\n            \"\"\"\n            Assigns particle mass to the grid using Cloud-In-Cell (CIC).\n            \"\"\"\n            mass_grid = np.zeros((self.N, self.N), dtype=self.dtype)\n            for m_p, x_p, y_p in particles:\n                # Position in grid units\n                pos_gu = np.array([x_p, y_p]) / self.h\n                \n                # Bottom-left grid cell index and fractional displacement\n                idx = np.floor(pos_gu).astype(int)\n                delta = pos_gu - idx\n                \n                # Get indices of 4 cells, with periodic wrapping\n                ix, iy = idx[0], idx[1]\n                ixp1 = (ix + 1) % self.N\n                iyp1 = (iy + 1) % self.N\n\n                # CIC weights\n                w_ij = (1.0 - delta[0]) * (1.0 - delta[1])\n                w_ip1j = delta[0] * (1.0 - delta[1])\n                w_ijp1 = (1.0 - delta[0]) * delta[1]\n                w_ip1jp1 = delta[0] * delta[1]\n\n                # Assign mass\n                mass_grid[ix, iy] += m_p * w_ij\n                mass_grid[ixp1, iy] += m_p * w_ip1j\n                mass_grid[ix, iyp1] += m_p * w_ijp1\n                mass_grid[ixp1, iyp1] += m_p * w_ip1jp1\n            \n            density_grid = mass_grid / (self.h**2)\n            return density_grid\n\n        def _interpolate_accel(self, accel_x_grid, accel_y_grid, particles):\n            \"\"\"\n            Interpolates acceleration from grid to particle positions using CIC.\n            \"\"\"\n            accels = []\n            for _, x_p, y_p in particles:\n                pos_gu = np.array([x_p, y_p]) / self.h\n                idx = np.floor(pos_gu).astype(int)\n                delta = pos_gu - idx\n            \n                ix, iy = idx[0], idx[1]\n                ixp1 = (ix + 1) % self.N\n                iyp1 = (iy + 1) % self.N\n\n                w_ij = (1.0 - delta[0]) * (1.0 - delta[1])\n                w_ip1j = delta[0] * (1.0 - delta[1])\n                w_ijp1 = (1.0 - delta[0]) * delta[1]\n                w_ip1jp1 = delta[0] * delta[1]\n\n                a_x = (w_ij * accel_x_grid[ix, iy] +\n                       w_ip1j * accel_x_grid[ixp1, iy] +\n                       w_ijp1 * accel_x_grid[ix, iyp1] +\n                       w_ip1jp1 * accel_x_grid[ixp1, iyp1])\n                \n                a_y = (w_ij * accel_y_grid[ix, iy] +\n                       w_ip1j * accel_y_grid[ixp1, iy] +\n                       w_ijp1 * accel_y_grid[ix, iyp1] +\n                       w_ip1jp1 * accel_y_grid[ixp1, iyp1])\n                \n                accels.append(np.array([a_x, a_y], dtype=self.dtype))\n            \n            return np.array(accels)\n\n        def get_potential(self, density_grid):\n            \"\"\"\n            Calculates potential from a density grid.\n            \"\"\"\n            rho_k = np.fft.fft2(density_grid.astype(self.dtype))\n            phi_k = 4.0 * np.pi * self.G * self.potential_kernel * rho_k\n            phi = np.fft.ifft2(phi_k)\n            return phi.real\n\n        def get_particle_accel(self, particles):\n            \"\"\"\n            Calculates acceleration on particles.\n            \"\"\"\n            density_grid = self._assign_mass(particles)\n            rho_k = np.fft.fft2(density_grid.astype(self.dtype))\n            rho_k[0, 0] = 0.0 # Enforce zero mean density\n\n            ax_k = 4.0 * np.pi * self.G * self.accel_kernel_x * rho_k\n            ay_k = 4.0 * np.pi * self.G * self.accel_kernel_y * rho_k\n\n            ax_grid = np.fft.ifft2(ax_k).real\n            ay_grid = np.fft.ifft2(ay_k).real\n\n            particle_accels = self._interpolate_accel(ax_grid, ay_grid, particles)\n            return particle_accels\n\n    # --- Problem Parameters ---\n    N = 64\n    L = 1.0\n    G = 1.0\n\n    solver = PM_Solver(N=N, L=L, G=G)\n    results = []\n\n    # --- Test A: Fourier-mode solver accuracy ---\n    x_coords = np.arange(N, dtype=solver.dtype) * solver.h\n    rho_analytic = np.cos(2.0 * np.pi * x_coords)\n    rho_grid_A = np.zeros((N, N), dtype=solver.dtype)\n    rho_grid_A[:, :] = rho_analytic[:, np.newaxis]\n    \n    phi_num = solver.get_potential(rho_grid_A)\n    phi_exact = -(1.0 / np.pi) * rho_grid_A\n    \n    eps_mode = np.max(np.abs(phi_num - phi_exact))\n    results.append(eps_mode)\n\n    # --- Test B: two-particle symmetry away from boundaries ---\n    particles_B = [\n        (0.5, 0.25, 0.5), # (mass, x, y)\n        (0.5, 0.75, 0.5)\n    ]\n    accels_B = solver.get_particle_accel(particles_B)\n    a1_B, a2_B = accels_B[0], accels_B[1]\n    norm_a1_B = np.linalg.norm(a1_B)\n    norm_a2_B = np.linalg.norm(a2_B)\n\n    num_B = max(np.linalg.norm(a1_B + a2_B), abs(a1_B[1]) + abs(a2_B[1]))\n    den_B = max(norm_a1_B, norm_a2_B)\n    eps_sym = num_B / den_B if den_B != 0 else 0.0\n    results.append(eps_sym)\n    \n    # --- Test C: net-force consistency for many particles ---\n    Np_C = 200\n    np.random.seed(1234) # Fixed seed for determinism\n    positions_C = np.random.rand(Np_C, 2).astype(solver.dtype)\n    masses_C = np.full(Np_C, 1.0/Np_C, dtype=solver.dtype)\n    particles_C = [(masses_C[i], positions_C[i,0], positions_C[i,1]) for i in range(Np_C)]\n\n    accels_C = solver.get_particle_accel(particles_C)\n    net_force = np.sum(masses_C[:, np.newaxis] * accels_C, axis=0)\n    eps_net = np.linalg.norm(net_force)\n    results.append(eps_net)\n    \n    # --- Test D: periodic wrap symmetry ---\n    particles_D = [\n        (0.5, 0.01, 0.5),\n        (0.5, 0.99, 0.5)\n    ]\n    accels_D = solver.get_particle_accel(particles_D)\n    a1_D, a2_D = accels_D[0], accels_D[1]\n    norm_a1_D = np.linalg.norm(a1_D)\n    norm_a2_D = np.linalg.norm(a2_D)\n    \n    num_D = max(np.linalg.norm(a1_D + a2_D), abs(a1_D[1]) + abs(a2_D[1]))\n    den_D = max(norm_a1_D, norm_a2_D)\n    eps_sym_wrap = num_D / den_D if den_D != 0 else 0.0\n    results.append(eps_sym_wrap)\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2416244"}, {"introduction": "After a simulation evolves a cosmic volume, the output is a snapshot of millions of particles. The final step is analysis: identifying the collapsed, gravitationally bound structures that host galaxies. This hands-on exercise introduces the Friends-of-Friends (FoF) algorithm, a classic method for identifying these dark matter halos. You will implement this percolation-based group finder to process a particle distribution and produce a halo catalog, a foundational task in physical cosmology [@problem_id:2416288].", "problem": "Implement a Friends-of-Friends (FoF) halo finder with a variable linking length parameter in a periodic three-dimensional cubic domain. Start from the following fundamental definitions. Let there be $N$ particles with comoving positions $\\{\\mathbf{x}_i\\}_{i=1}^{N}$ inside a cubic box of side length $L$, with periodic boundary conditions. The global number density is $n = N / L^3$. The mean interparticle separation is $\\bar{\\ell} = n^{-1/3}$. Each particle $i$ is assigned a dimensionless linking-length factor $b_i$, and the absolute linking length for that particle is defined as $\\ell_i = b_i \\, \\bar{\\ell}$. The undirected graph of particle connectivity is defined as follows: two particles $i$ and $j$ are linked if their comoving separation under the minimum-image convention is not greater than the arithmetic mean of their per-particle linking lengths, that is, if the minimum-image distance $r_{ij}$ satisfies $r_{ij} \\le \\tfrac{1}{2}(\\ell_i + \\ell_j)$. A halo is a connected component of this undirected graph. Include all connected components, including singletons, as halos. Express all positions in dimensionless comoving box units, and all distances in the same unit as $L$. No physical units are required.\n\nYour task is to write a complete, runnable program that:\n- Computes $\\bar{\\ell}$ from $N$ and $L$ for each test case.\n- Computes $\\ell_i = b_i \\, \\bar{\\ell}$ for each particle.\n- Computes all pairwise distances $r_{ij}$ using periodic boundary conditions via the minimum-image convention: for a displacement vector $\\Delta \\mathbf{x} = \\mathbf{x}_j - \\mathbf{x}_i$, apply component-wise wrapping $\\Delta x \\mapsto \\Delta x - L \\cdot \\mathrm{round}(\\Delta x / L)$, and similarly for $\\Delta y$ and $\\Delta z$, then $r_{ij} = \\|\\Delta \\mathbf{x}\\|_2$.\n- Constructs the undirected graph with an edge between $i$ and $j$ if and only if $r_{ij} \\le \\tfrac{1}{2}(\\ell_i + \\ell_j)$.\n- Finds all connected components and reports each component size as a positive integer, sorted in nonincreasing order for each test case.\n\nDesign your implementation from first principles based on the definitions above and fundamental kinematics ($\\mathbf{v} = d\\mathbf{x}/dt$) as needed to justify spatial separations, without using any prepackaged graph or clustering routines. The correctness criterion for each test case is the list of connected component sizes.\n\nUse the following test suite of three cases. For each case, the program should compute the halo sizes as specified and aggregate the results.\n\nTest case A (two compact, well-separated clusters):\n- Box size: $L = 2.0$.\n- Number of particles: $N = 8$.\n- Particle positions $\\mathbf{x}_i$ (dimensionless):\n  - $\\mathbf{x}_1 = (\\,0.20,\\,0.20,\\,0.20\\,)$,\n  - $\\mathbf{x}_2 = (\\,0.25,\\,0.20,\\,0.22\\,)$,\n  - $\\mathbf{x}_3 = (\\,0.20,\\,0.26,\\,0.20\\,)$,\n  - $\\mathbf{x}_4 = (\\,0.24,\\,0.25,\\,0.24\\,)$,\n  - $\\mathbf{x}_5 = (\\,1.60,\\,1.60,\\,1.60\\,)$,\n  - $\\mathbf{x}_6 = (\\,1.65,\\,1.60,\\,1.58\\,)$,\n  - $\\mathbf{x}_7 = (\\,1.60,\\,1.66,\\,1.60\\,)$,\n  - $\\mathbf{x}_8 = (\\,1.58,\\,1.62,\\,1.64\\,)$.\n- Per-particle linking parameters $b_i$:\n  - $b_i = 0.20$ for all $i \\in \\{1,\\dots,8\\}$.\n\nTest case B (periodic boundary linking across the box edge):\n- Box size: $L = 1.0$.\n- Number of particles: $N = 6$.\n- Particle positions $\\mathbf{x}_i$ (dimensionless):\n  - $\\mathbf{x}_1 = (\\,0.05,\\,0.50,\\,0.50\\,)$,\n  - $\\mathbf{x}_2 = (\\,0.07,\\,0.48,\\,0.52\\,)$,\n  - $\\mathbf{x}_3 = (\\,0.04,\\,0.52,\\,0.49\\,)$,\n  - $\\mathbf{x}_4 = (\\,0.95,\\,0.50,\\,0.50\\,)$,\n  - $\\mathbf{x}_5 = (\\,0.93,\\,0.51,\\,0.49\\,)$,\n  - $\\mathbf{x}_6 = (\\,0.96,\\,0.48,\\,0.52\\,)$.\n- Per-particle linking parameters $b_i$:\n  - $b_i = 0.25$ for all $i \\in \\{1,\\dots,6\\}$.\n\nTest case C (variable $b_i$ suppressing links for a close pair):\n- Box size: $L = 1.0$.\n- Number of particles: $N = 4$.\n- Particle positions $\\mathbf{x}_i$ (dimensionless):\n  - $\\mathbf{x}_1 = (\\,0.10,\\,0.10,\\,0.10\\,)$,\n  - $\\mathbf{x}_2 = (\\,0.16,\\,0.10,\\,0.10\\,)$,\n  - $\\mathbf{x}_3 = (\\,0.70,\\,0.70,\\,0.70\\,)$,\n  - $\\mathbf{x}_4 = (\\,0.74,\\,0.70,\\,0.70\\,)$.\n- Per-particle linking parameters $b_i$:\n  - $b_1 = 0.05$,\n  - $b_2 = 0.05$,\n  - $b_3 = 0.20$,\n  - $b_4 = 0.20$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, one per test case, where each inner list contains the halo sizes for that case sorted in nonincreasing order. For example, it should look like $[[\\dots],[\\dots],[\\dots]]$ with integers only. No other text should be printed.", "solution": "We construct the solution by combining core definitions of number density, mean interparticle separation, and periodic distances with a graph connectivity analysis.\n\n1. Definitions and inputs. For a cubic periodic domain with side length $L$ containing $N$ particles, the global number density is $n = N / L^3$. The mean interparticle separation is $\\bar{\\ell} = n^{-1/3} = \\left( \\dfrac{L^3}{N} \\right)^{1/3} = \\dfrac{L}{N^{1/3}}$. Each particle $i$ is assigned a dimensionless per-particle factor $b_i$, and so its absolute linking length is $\\ell_i = b_i \\, \\bar{\\ell}$.\n\n2. Minimum-image distances. For two particles at positions $\\mathbf{x}_i$ and $\\mathbf{x}_j$, we first form the displacement vector $\\Delta \\mathbf{x} = \\mathbf{x}_j - \\mathbf{x}_i$. To enforce periodic boundary conditions under the minimum-image convention, we wrap each Cartesian component: if $\\Delta x$ is the $x$-component, set\n$$\n\\Delta x \\leftarrow \\Delta x - L \\cdot \\mathrm{round}\\!\\left(\\frac{\\Delta x}{L}\\right),\n$$\nand analogously for the $y$ and $z$ components. The minimum-image distance is $r_{ij} = \\|\\Delta \\mathbf{x}\\|_2 = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}$.\n\n3. Linking criterion. The Friends-of-Friends construction with variable linking length uses an undirected edge between particles $i$ and $j$ when the separation does not exceed the symmetric average of their per-particle linking lengths:\n$$\nr_{ij} \\le \\frac{1}{2}\\left(\\ell_i + \\ell_j\\right).\n$$\nThis enforces a consistent, symmetric rule when $b_i \\ne b_j$.\n\n4. Graph and halos. With the edge set defined by the above inequality, halos are the connected components of the resulting undirected graph on the $N$ vertices. We identify components using a disjoint-set union (also called union–find) or breadth-first search; either is acceptable. Every particle belongs to exactly one component; components of size $1$ (singletons) are included.\n\n5. Algorithmic steps for each test case.\n- Compute $N$ and $L$, then compute $\\bar{\\ell} = L / N^{1/3}$.\n- Compute $\\ell_i = b_i \\bar{\\ell}$ for $i=1,\\dots,N$.\n- For all unordered pairs $(i,j)$ with $ij$, compute $r_{ij}$ using the minimum-image convention.\n- If $r_{ij} \\le \\tfrac{1}{2}(\\ell_i+\\ell_j)$, add an undirected edge (equivalently, perform a union in the disjoint-set data structure).\n- After processing all pairs, extract the component sizes and sort them in nonincreasing order.\n\n6. Application to the test suite.\n- Test case A: $L = 2.0$, $N = 8$, hence $\\bar{\\ell} = L / N^{1/3} = 2.0 / 8^{1/3} = 2.0 / 2 = 1.0$. With $b_i = 0.20$ for all $i$, all $\\ell_i = 0.20$. Intra-cluster separations are $\\mathcal{O}(0.05)$–$\\mathcal{O}(0.1)$, which satisfy $r_{ij} \\le 0.20$. Inter-cluster separations are $\\gtrsim 1.0$ under the minimum-image convention, which violate $r_{ij} \\le 0.20$. Thus there are two halos, each of size $4$, yielding the sorted list $[4,4]$.\n\n- Test case B: $L = 1.0$, $N = 6$, hence $\\bar{\\ell} = L / N^{1/3} \\approx 1.0 / 6^{1/3} \\approx 0.550321$. With $b_i = 0.25$, we have $\\ell_i \\approx 0.137580$ for all $i$. Particles near $x \\approx 0.05$ are periodically close to those near $x \\approx 0.95$, with separations across the boundary satisfying $r_{ij} \\lesssim 0.11$, so $r_{ij} \\le 0.137580$ holds for multiple cross-boundary pairs, connecting all six particles into a single halo. The result is $[6]$.\n\n- Test case C: $L = 1.0$, $N = 4$, hence $\\bar{\\ell} \\approx 1.0 / 4^{1/3} \\approx 0.629961$. For particles $1$ and $2$, $b_1 = b_2 = 0.05$ so $\\ell_1 = \\ell_2 \\approx 0.031498$; their separation is approximately $0.06$, which violates $r_{12} \\le 0.031498$, so they are not linked. For particles $3$ and $4$, $b_3 = b_4 = 0.20$ so $\\ell_3 = \\ell_4 \\approx 0.125992$ and their separation is approximately $0.04$, which satisfies $r_{34} \\le 0.125992$, so they form a halo of size $2$. The cross-distances between $\\{1,2\\}$ and $\\{3,4\\}$ are large, and mixed-thresholds like $\\tfrac{1}{2}(\\ell_1+\\ell_3) \\approx 0.078745$ remain far below those separations, preventing any bridging. Thus the sorted sizes are $[2,1,1]$.\n\n7. Output format. Aggregate the three per-case results into a single list of lists and print it in one line, for example $[[\\dots],[\\dots],[\\dots]]$, with no additional text.\n\nThe program below follows these steps precisely, computing the results for the specified test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef min_image_displacement(dx, L):\n    \"\"\"\n    Apply the minimum-image convention component-wise to a displacement vector dx\n    in a cubic periodic box of side length L.\n    \"\"\"\n    return dx - L * np.round(dx / L)\n\nclass DisjointSetUnion:\n    def __init__(self, n):\n        self.parent = np.arange(n, dtype=int)\n        self.size = np.ones(n, dtype=int)\n\n    def find(self, x):\n        # Path compression\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, a, b):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra == rb:\n            return\n        # Union by size\n        if self.size[ra]  self.size[rb]:\n            ra, rb = rb, ra\n        self.parent[rb] = ra\n        self.size[ra] += self.size[rb]\n\ndef fof_variable_b(positions, L, b_values):\n    \"\"\"\n    Compute Friends-of-Friends halos with variable per-particle b-values.\n\n    positions: (N,3) numpy array of particle positions within [0,L).\n    L: float, box size (periodic).\n    b_values: (N,) numpy array of dimensionless linking-length factors.\n\n    Returns a list of component sizes sorted in nonincreasing order.\n    \"\"\"\n    positions = np.asarray(positions, dtype=float)\n    b_values = np.asarray(b_values, dtype=float)\n    N = positions.shape[0]\n    # Mean interparticle separation\n    lbar = L / (N ** (1.0 / 3.0))\n    # Per-particle linking lengths\n    l_i = b_values * lbar\n\n    # Build union-find structure\n    dsu = DisjointSetUnion(N)\n\n    # Check all pairs\n    for i in range(N - 1):\n        # Vectorized differences to all ji\n        diffs = positions[i+1:] - positions[i]\n        # Apply minimum image to each component\n        diffs = min_image_displacement(diffs, L)\n        # Euclidean distances\n        rij = np.linalg.norm(diffs, axis=1)\n        # Thresholds: (l_i + l_j)/2\n        thresholds = 0.5 * (l_i[i] + l_i[i+1:])\n        # Determine links\n        links = rij = thresholds\n        linked_js = np.where(links)[0] + (i + 1)\n        for j in linked_js:\n            dsu.union(i, j)\n\n    # Compute component sizes\n    roots, counts = np.unique([dsu.find(k) for k in range(N)], return_counts=True)\n    sizes = list(counts.astype(int))\n    sizes.sort(reverse=True)\n    return sizes\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Test case A\n    L_A = 2.0\n    positions_A = np.array([\n        [0.20, 0.20, 0.20],\n        [0.25, 0.20, 0.22],\n        [0.20, 0.26, 0.20],\n        [0.24, 0.25, 0.24],\n        [1.60, 1.60, 1.60],\n        [1.65, 1.60, 1.58],\n        [1.60, 1.66, 1.60],\n        [1.58, 1.62, 1.64],\n    ], dtype=float)\n    b_A = np.full(positions_A.shape[0], 0.20, dtype=float)\n\n    # Test case B\n    L_B = 1.0\n    positions_B = np.array([\n        [0.05, 0.50, 0.50],\n        [0.07, 0.48, 0.52],\n        [0.04, 0.52, 0.49],\n        [0.95, 0.50, 0.50],\n        [0.93, 0.51, 0.49],\n        [0.96, 0.48, 0.52],\n    ], dtype=float)\n    b_B = np.full(positions_B.shape[0], 0.25, dtype=float)\n\n    # Test case C\n    L_C = 1.0\n    positions_C = np.array([\n        [0.10, 0.10, 0.10],\n        [0.16, 0.10, 0.10],\n        [0.70, 0.70, 0.70],\n        [0.74, 0.70, 0.70],\n    ], dtype=float)\n    b_C = np.array([0.05, 0.05, 0.20, 0.20], dtype=float)\n\n    test_cases = [\n        (positions_A, L_A, b_A),\n        (positions_B, L_B, b_B),\n        (positions_C, L_C, b_C),\n    ]\n\n    results = []\n    for positions, L, bvals in test_cases:\n        sizes = fof_variable_b(positions, L, bvals)\n        results.append(sizes)\n\n    # Final print statement in the exact required format.\n    # Print a list of lists with integers only, single line.\n    # Ensure no extra spaces for strict formatting.\n    def list_to_str(lst):\n        if isinstance(lst, list):\n            return \"[\" + \",\".join(list_to_str(x) for x in lst) + \"]\"\n        else:\n            return str(int(lst))\n    print(list_to_str(results))\n\nsolve()\n```", "id": "2416288"}]}