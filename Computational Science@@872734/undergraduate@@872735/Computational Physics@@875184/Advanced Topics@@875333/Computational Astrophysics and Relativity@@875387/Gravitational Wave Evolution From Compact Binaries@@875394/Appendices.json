{"hands_on_practices": [{"introduction": "This first practice serves as your entry point into simulating compact binary inspirals. You will implement a numerical solution to the fundamental equations governing the system's evolution, focusing on the change in gravitational-wave frequency over time. The primary goal is to understand the trade-offs between computational speed and accuracy by investigating how the choice of time-step size affects the error in your simulation [@problem_id:2399139].", "problem": "Consider an equal-mass compact binary on a circular orbit emitting gravitational waves (GW). You will model the inspiral in the quadrupole approximation using Newtonian orbital dynamics and energy balance, and investigate how the numerical error in the accumulated GW phase grows with the fixed time-step size. Your program must implement a fixed-step integrator to evolve the system, compare the phase against a high-accuracy reference computed with a much smaller step, and report the absolute phase error as a function of the step size.\n\nPhysical setup and fundamental base:\n- Let the component masses be $m_1 = m_2 = 1.4 \\, M_\\odot$, where $M_\\odot$ is the solar mass.\n- Use standard constants in International System of Units (SI): $G = 6.67430 \\times 10^{-11} \\ \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$, $c = 2.99792458 \\times 10^{8} \\ \\mathrm{m \\, s^{-1}}$, and $M_\\odot = 1.98847 \\times 10^{30} \\ \\mathrm{kg}$.\n- Assume a circular orbit and Newtonian gravity with Kepler’s law relating orbital frequency $f_{\\mathrm{orb}}$ and separation $r$: $(2\\pi f_{\\mathrm{orb}})^2 r^3 = G (m_1 + m_2)$.\n- The gravitational binding energy of the binary is $E = - \\dfrac{G m_1 m_2}{2 r}$.\n- The leading-order gravitational wave luminosity (power) for a circular binary is $P_{\\mathrm{GW}} = \\dfrac{32}{5} \\dfrac{G^4}{c^5} \\dfrac{m_1^2 m_2^2 (m_1 + m_2)}{r^5}$.\n- The gravitational wave frequency is twice the orbital frequency, $f(t) = 2 f_{\\mathrm{orb}}(t)$, and the GW phase satisfies $\\dfrac{d\\phi}{dt} = 2\\pi f(t)$.\n\nTask:\n1. Starting strictly from the relations above and the energy balance law $\\dfrac{dE}{dt} = - P_{\\mathrm{GW}}$, derive an explicit evolution equation for $\\dfrac{df}{dt}$ expressed only in terms of the chirp mass and the instantaneous GW frequency $f(t)$. Do not assume or quote any ready-made result without derivation.\n2. Implement a fixed-step ordinary differential equation (ODE) solver using the classical fourth-order Runge–Kutta method to integrate the coupled system for $(\\phi(t), f(t))$:\n   - Initial conditions: $f(0) = f_0$ and $\\phi(0) = 0$ with $f_0 = 30 \\ \\mathrm{Hz}$.\n   - Integrate up to final time $T_{\\mathrm{end}} = 40 \\ \\mathrm{s}$.\n   - Angles must be in radians, frequencies in $\\mathrm{Hz}$, times in $\\mathrm{s}$, and masses in $\\mathrm{kg}$.\n3. Compute a high-accuracy reference phase $\\phi_{\\mathrm{ref}}$ at $t = T_{\\mathrm{end}}$ using a very small fixed step $\\,\\Delta t_{\\mathrm{ref}} = 10^{-3} \\ \\mathrm{s}$ with the same integration scheme.\n4. For each prescribed step size $\\Delta t$, compute the absolute phase error at $t = T_{\\mathrm{end}}$ defined by $|\\phi_{\\Delta t} - \\phi_{\\mathrm{ref}}|$, where $\\phi_{\\Delta t}$ is the phase obtained with step $\\Delta t$.\n5. Your implementation must be numerically self-consistent: if $T_{\\mathrm{end}}$ is not an integer multiple of $\\Delta t$, the final RK4 step must use the remaining time so that the phase is evaluated exactly at $t = T_{\\mathrm{end}}$.\n\nTest suite:\n- Use the following fixed step sizes $\\Delta t$ (in seconds): $[0.5, 0.25, 0.1, 0.05, 0.025]$.\n- For each $\\Delta t$ above, output the absolute phase error at $t = T_{\\mathrm{end}}$ as a float in radians, rounded to six decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[x1,x2,x3,x4,x5]\"). Specifically, print the list of five rounded absolute phase errors corresponding to the five $\\Delta t$ values above, in the same order.", "solution": "The problem as stated is scientifically sound, well-posed, and objective. It describes a standard problem in computational astrophysics: the simulation of the inspiral phase of a compact binary system using post-Newtonian approximations. All physical laws, constants, and initial conditions are provided, forming a complete and consistent initial value problem. The task, which involves deriving the governing differential equations and analyzing the numerical error of an integration scheme, is a fundamental exercise in computational physics. Therefore, the problem is valid, and a solution will be provided.\n\nThe solution proceeds in three stages. First, we derive the evolution equation for the gravitational wave frequency. Second, we describe the numerical integration scheme. Third, we outline the implementation for computing the phase evolution and its numerical error.\n\n**1. Derivation of the Frequency Evolution Equation**\n\nThe goal is to derive an expression for $\\dfrac{df}{dt}$ in terms of the gravitational wave frequency $f$ and the system's chirp mass $\\mathcal{M}$. We begin with the provided physical relations.\n\nThe energy balance law states that the rate of change of the binary's orbital energy $E$ is equal to the negative of the power emitted in gravitational waves, $P_\\mathrm{GW}$:\n$$\n\\dfrac{dE}{dt} = -P_\\mathrm{GW}\n$$\nWe can find $\\dfrac{df}{dt}$ using the chain rule:\n$$\n\\dfrac{df}{dt} = \\dfrac{df}{dE} \\dfrac{dE}{dt} = -\\dfrac{df}{dE} P_\\mathrm{GW}\n$$\nTo proceed, we must express both $E$ and $P_\\mathrm{GW}$ as functions of $f$. This requires expressing the orbital separation $r$ in terms of $f$.\n\nFrom Kepler's third law for a circular orbit and the relation $f = 2f_{\\mathrm{orb}}$, we have:\n$$\n(2\\pi f_{\\mathrm{orb}})^2 r^3 = G(m_1 + m_2) \\implies \\left(2\\pi \\frac{f}{2}\\right)^2 r^3 = GM\n$$\nwhere $M = m_1 + m_2$ is the total mass. Simplifying and solving for $r$ gives:\n$$\nr = \\left( \\dfrac{GM}{(\\pi f)^2} \\right)^{1/3} = (GM)^{1/3}(\\pi f)^{-2/3}\n$$\nNow substitute this expression for $r$ into the formulas for energy $E$ and power $P_\\mathrm{GW}$.\nThe orbital energy is:\n$$\nE = -\\dfrac{G m_1 m_2}{2r} = -\\dfrac{G m_1 m_2}{2} (GM)^{-1/3} (\\pi f)^{2/3} = -\\dfrac{1}{2} G^{2/3} m_1 m_2 M^{-1/3} (\\pi f)^{2/3}\n$$\nThe gravitational wave power is:\n$$\nP_\\mathrm{GW} = \\dfrac{32}{5} \\dfrac{G^4}{c^5} \\dfrac{m_1^2 m_2^2 M}{r^5} = \\dfrac{32}{5} \\dfrac{G^4}{c^5} m_1^2 m_2^2 M \\left( (GM)^{1/3}(\\pi f)^{-2/3} \\right)^{-5}\n$$\n$$\nP_\\mathrm{GW} = \\dfrac{32}{5} \\dfrac{G^4}{c^5} m_1^2 m_2^2 M (GM)^{-5/3} (\\pi f)^{10/3} = \\dfrac{32}{5c^5} G^{7/3} (m_1 m_2)^2 M^{-2/3} (\\pi f)^{10/3}\n$$\nThe problem requires the final expression to be in terms of the chirp mass, $\\mathcal{M}$, defined as $\\mathcal{M} = \\dfrac{(m_1 m_2)^{3/5}}{(m_1+m_2)^{1/5}} = \\mu^{3/5}M^{2/5}$, where $\\mu = \\frac{m_1 m_2}{M}$ is the reduced mass. Let's rewrite the mass-dependent terms using $\\mathcal{M}$.\nThe term in the power expression is $(m_1 m_2)^2 M^{-2/3} = (\\mu M)^2 M^{-2/3} = \\mu^2 M^{4/3}$. From the definition of $\\mathcal{M}$, we have $\\mathcal{M}^5 = \\mu^3 M^2$, which gives $\\mu = \\mathcal{M}^{5/3} M^{-2/3}$. Substituting this into our mass term:\n$$\n\\mu^2 M^{4/3} = (\\mathcal{M}^{5/3} M^{-2/3})^2 M^{4/3} = \\mathcal{M}^{10/3} M^{-4/3} M^{4/3} = \\mathcal{M}^{10/3}\n$$\nSo, the power becomes:\n$$\nP_\\mathrm{GW} = \\dfrac{32}{5 c^5} (G\\mathcal{M})^{10/3} (\\pi f)^{10/3} = \\dfrac{32 \\pi^{10/3}}{5 c^5} (G\\mathcal{M})^{10/3} f^{10/3}\n$$\nThis is incorrect. A check of the derivation reveals an error in the mass term of $P_\\mathrm{GW}$.\nLet's restart the derivation of $df/dt$ rigorously from the provided formulas.\n$E = -\\frac{1}{2} m_1 m_2 G^{2/3} M^{-1/3} \\pi^{2/3} f^{2/3}$.\n$\\frac{dE}{df} = -\\frac{1}{3} m_1 m_2 G^{2/3} M^{-1/3} \\pi^{2/3} f^{-1/3}$.\n$\\frac{df}{dE} = -3 (m_1 m_2)^{-1} G^{-2/3} M^{1/3} \\pi^{-2/3} f^{1/3}$.\n$\\frac{df}{dt} = - \\frac{df}{dE} P_\\mathrm{GW} = 3 (m_1 m_2)^{-1} G^{-2/3} M^{1/3} \\pi^{-2/3} f^{1/3} \\times \\frac{32}{5c^5} G^{7/3} (m_1 m_2)^2 M^{-2/3} \\pi^{10/3} f^{10/3}$.\n$\\frac{df}{dt} = \\frac{96}{5c^5} (m_1 m_2) (G^{5/3} M^{-1/3}) \\pi^{8/3} f^{11/3}$.\nLet's express the mass term $(m_1 m_2) M^{-1/3}$ via the chirp mass $\\mathcal{M}$.\n$\\mathcal{M} = (m_1 m_2)^{3/5} M^{-1/5}$. So $\\mathcal{M}^{5/3} = (m_1 m_2) M^{-1/3}$.\nThis is a key step. Now substitute this into the equation for $\\frac{df}{dt}$:\n$$\n\\dfrac{df}{dt} = \\dfrac{96}{5 c^5} (G\\mathcal{M})^{5/3} \\pi^{8/3} f^{11/3}\n$$\nThis expression is the correct, standard result, and it has been derived strictly from the problem's given relations.\n\n**2. Numerical Method and System of Equations**\n\nThe evolution of the binary system is described by a pair of coupled first-order ordinary differential equations (ODEs) for the state vector $\\mathbf{y}(t) = [\\phi(t), f(t)]^T$.\n$$\n\\dfrac{d\\mathbf{y}}{dt} = \\begin{pmatrix} d\\phi/dt \\\\ df/dt \\end{pmatrix} = \\mathbf{F}(f) = \\begin{pmatrix} 2\\pi f \\\\ \\mathcal{K} f^{11/3} \\end{pmatrix}\n$$\nwhere $\\mathcal{K} = \\dfrac{96}{5 c^5} (G\\mathcal{M})^{5/3} \\pi^{8/3}$ is a constant. The system is autonomous, as the derivatives depend only on the state variables, not explicitly on time $t$. The initial conditions are $\\mathbf{y}(0) = [0, f_0]^T$.\n\nTo solve this system numerically, we employ the classical fourth-order Runge-Kutta (RK4) method. Given a state $\\mathbf{y}_n$ at time $t_n$, the state $\\mathbf{y}_{n+1}$ at time $t_{n+1} = t_n + \\Delta t$ is computed as follows:\n$$\n\\begin{align*}\n\\mathbf{k}_1 &= \\mathbf{F}(\\mathbf{y}_n) \\\\\n\\mathbf{k}_2 &= \\mathbf{F}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 &= \\mathbf{F}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 &= \\mathbf{F}(\\mathbf{y}_n + \\Delta t \\, \\mathbf{k}_3) \\\\\n\\mathbf{y}_{n+1} &= \\mathbf{y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{align*}\nNote that for our system, the derivatives only depend on $f$, not on $\\phi$.\n\n**3. Implementation Strategy**\n\nThe implementation follows a clear procedure to satisfy the problem's requirements.\n1.  **Constants and Parameters**: All physical constants ($G, c, M_\\odot$) and problem parameters ($m_1, m_2, f_0, T_{\\mathrm{end}}$) are defined in SI units. The chirp mass $\\mathcal{M}$ is computed from $m_1$ and $m_2$, and the constant factor $\\mathcal{K}$ for the $df/dt$ equation is pre-calculated.\n2.  **ODE Solver**: A function implements the RK4 integration loop. It takes the initial conditions and a step size $\\Delta t$ as input. The loop runs from $t=0$ to $t=T_{\\mathrm{end}}$. As specified, to ensure the integration terminates exactly at $T_{\\mathrm{end}}$, the final step size is adjusted using `h = min(Δt, T_end - t)`.\n3.  **Reference Solution**: A high-accuracy reference phase, $\\phi_{\\mathrm{ref}}$, is computed by running the integrator with a very small time step, $\\Delta t_{\\mathrm{ref}} = 10^{-3} \\ \\mathrm{s}$.\n4.  **Error Calculation**: The program iterates through the list of specified test step sizes $\\Delta t$. For each $\\Delta t$, it runs the integrator to find the final phase $\\phi_{\\Delta t}$. The absolute error is then computed as $|\\phi_{\\Delta t} - \\phi_{\\mathrm{ref}}|$.\n5.  **Output**: The calculated errors are collected into a list, rounded to six decimal places, and printed in the specified format. The RK4 method is known to have a global truncation error of order $O((\\Delta t)^4)$. We expect the computed phase errors to scale accordingly.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave inspiral problem, calculates phase errors\n    for different step sizes, and prints the results.\n    \"\"\"\n    # Physical constants in SI units\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    c = 2.99792458e8   # m s^-1\n    M_SUN = 1.98847e30 # kg\n\n    # Problem parameters\n    m1_msun = 1.4\n    m2_msun = 1.4\n    f0 = 30.0  # Hz\n    T_end = 40.0 # s\n    phi0 = 0.0 # rad\n\n    # Test suite and reference step size\n    dt_steps = [0.5, 0.25, 0.1, 0.05, 0.025] # s\n    dt_ref = 1e-3 # s\n\n    # --- Derived physical quantities ---\n    m1 = m1_msun * M_SUN\n    m2 = m2_msun * M_SUN\n    \n    # In the equal mass case m1=m2=m, M=2m, mu=m/2\n    # The chirp mass M_chirp = (m1*m2)^(3/5) / (m1+m2)^(1/5)\n    # simplifies to m / (2^(1/5))\n    m = m1 \n    chirp_mass = m / (2.0**(1.0/5.0))\n\n    # Pre-calculate the constant factor in the df/dt equation\n    # df/dt = K * f^(11/3)\n    K_FACTOR = (96.0 / 5.0) * (np.pi**(8.0/3.0) / c**5) * ((G * chirp_mass)**(5.0/3.0))\n\n    def derivatives(y):\n        \"\"\"\n        Computes the derivatives [d(phi)/dt, df/dt] for the ODE system.\n        y is a numpy array [phi, f].\n        \"\"\"\n        phi, f = y\n        dphi_dt = 2.0 * np.pi * f\n        df_dt = K_FACTOR * f**(11.0 / 3.0)\n        return np.array([dphi_dt, df_dt])\n\n    def integrate_inspiral(f_initial, phi_initial, t_final, dt):\n        \"\"\"\n        Integrates the ODE system using the RK4 method.\n        \n        Args:\n            f_initial (float): Initial GW frequency in Hz.\n            phi_initial (float): Initial GW phase in radians.\n            t_final (float): Final integration time in seconds.\n            dt (float): Fixed time step for integration.\n\n        Returns:\n            float: The final accumulated GW phase in radians.\n        \"\"\"\n        t = 0.0\n        y = np.array([phi_initial, f_initial])\n\n        while t < t_final:\n            # Ensure the last step ends exactly at t_final\n            h = min(dt, t_final - t)\n            \n            # Classical 4th-order Runge-Kutta step\n            k1 = derivatives(y)\n            k2 = derivatives(y + 0.5 * h * k1)\n            k3 = derivatives(y + 0.5 * h * k2)\n            k4 = derivatives(y + h * k3)\n            \n            y += (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            t += h\n            \n        return y[0] # Return the final phase phi\n\n    # 1. Compute the high-accuracy reference phase\n    phi_ref = integrate_inspiral(f0, phi0, T_end, dt_ref)\n\n    # 2. Compute phase for each step size and calculate error\n    errors = []\n    for dt in dt_steps:\n        phi_dt = integrate_inspiral(f0, phi0, T_end, dt)\n        error = abs(phi_dt - phi_ref)\n        errors.append(round(error, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, errors))}]\")\n\n\nsolve()\n```", "id": "2399139"}, {"introduction": "Building upon the basic integration of orbital evolution, this exercise takes you through the complete process of generating an observable gravitational waveform from first principles. You will translate the binary's orbital motion into a time-varying quadrupole moment and then into the strain detected far from the source. This practice will allow you to numerically verify a cornerstone prediction of general relativity: that the dominant gravitational-wave frequency is exactly twice the orbital frequency of the binary system [@problem_id:2399179].", "problem": "A circular, non-spinning compact binary can be modeled within the Newtonian limit and the leading-order quadrupole approximation for gravitational radiation. Starting from first principles, you will construct a numerical experiment that produces the gravitational-wave strain for a quasi-circular inspiral, extracts its instantaneous frequency, and compares it to the orbital frequency to validate the frequency-doubling property. The goal is to verify numerically that the gravitational-wave frequency tracks twice the orbital frequency throughout the evolution, within numerical tolerance, without assuming that relation in the construction.\n\nFundamental base to use:\n- Newtonian two-body dynamics for point masses: a binary with component masses $m_1$ and $m_2$, total mass $M = m_1 + m_2$, and reduced mass $\\mu = \\dfrac{m_1 m_2}{M}$. For an instantaneous circular orbit of separation $a(t)$, the orbital angular frequency is $\\omega(t) = \\sqrt{\\dfrac{G M}{a(t)^3}}$ and the orbital phase evolves as $\\dfrac{d\\phi}{dt} = \\omega(t)$.\n- Energy balance for circular inspiral (Peters formula) at leading quadrupole order: the binary orbit shrinks due to gravitational-wave emission according to\n$$\n\\frac{da}{dt} = - \\frac{64}{5} \\frac{G^3}{c^5} \\frac{\\mu M^2}{a^3}.\n$$\n- Quadrupole radiation in the far zone and transverse-traceless (TT) gauge: the trace-free mass quadrupole tensor is\n$$\nI_{ij}(t) = \\sum_A m_A \\left(x_A^i x_A^j - \\frac{1}{3}\\delta_{ij}\\, \\mathbf{x}_A^2\\right),\n$$\nwhich for the center-of-mass frame reduces to $I_{ij}(t) = \\mu \\left(r_i r_j - \\dfrac{1}{3}\\delta_{ij} r^2\\right)$ with $\\mathbf{r} = \\mathbf{x}_1 - \\mathbf{x}_2$. The gravitational-wave metric perturbation in TT gauge at luminosity distance $D$ is\n$$\nh_{ij}^{\\mathrm{TT}}(t) = \\frac{2 G}{c^4 D} \\frac{d^2 I_{ij}^{\\mathrm{TT}}(t)}{dt^2}.\n$$\nFor an observer along unit line-of-sight $\\hat{\\mathbf{n}}$, define orthonormal polarization basis vectors $\\hat{\\mathbf{p}}$ and $\\hat{\\mathbf{q}}$ such that $\\{\\hat{\\mathbf{p}}, \\hat{\\mathbf{q}}, \\hat{\\mathbf{n}}\\}$ is right-handed with $\\hat{\\mathbf{p}} \\cdot \\hat{\\mathbf{n}} = 0$ and $\\hat{\\mathbf{q}} \\cdot \\hat{\\mathbf{n}} = 0$. Then the plus polarization is obtained by projecting onto $e_+^{ij} = p^i p^j - q^i q^j$:\n$$\nh_{+}(t) = \\frac{2 G}{c^4 D}\\, e_+^{ij}\\, \\frac{d^2 I_{ij}(t)}{dt^2}.\n$$\n\nTask:\n- Implement a program that:\n  1. Evolves the binary through a quasi-circular inspiral by integrating the coupled system\n     $$\n     \\frac{d\\phi}{dt} = \\sqrt{\\frac{G M}{a^3}},\\quad\n     \\frac{da}{dt} = - \\frac{64}{5} \\frac{G^3}{c^5} \\frac{\\mu M^2}{a^3}\n     $$\n     using a fixed time step $\\,\\Delta t\\,$ and a fourth-order Runge–Kutta scheme on a uniform time grid.\n  2. Constructs the trace-free mass quadrupole $I_{ij}(t)$ from the relative position $\\mathbf{r}(t) = a(t)[\\cos\\phi(t), \\sin\\phi(t), 0]$ in the center-of-mass frame.\n  3. Computes the second time derivative $\\,\\dfrac{d^2 I_{ij}}{dt^2}\\,$ numerically using a centered finite-difference stencil on the uniform grid.\n  4. Defines the observer direction by an inclination angle $\\iota$ with respect to the orbital angular momentum (the $z$-axis) and azimuth $0$, i.e., $\\hat{\\mathbf{n}} = (\\sin\\iota, 0, \\cos\\iota)$, and uses $\\hat{\\mathbf{p}} = (\\cos\\iota, 0, -\\sin\\iota)$ and $\\hat{\\mathbf{q}} = (0, 1, 0)$ to build $e_+^{ij}$.\n  5. Forms $h_{+}(t)$ by contracting $e_+^{ij}$ with $\\,\\dfrac{d^2 I_{ij}}{dt^2}\\,$ and scaling by $\\,\\dfrac{2G}{c^4 D}\\,$.\n  6. Extracts the instantaneous gravitational-wave frequency $f_{\\mathrm{GW}}(t)$ from $h_{+}(t)$ by computing the analytic signal via the Hilbert transform, unwrapping its phase $\\psi(t)$, and differentiating: $f_{\\mathrm{GW}}(t) = \\dfrac{1}{2\\pi} \\dfrac{d\\psi}{dt}$.\n  7. Computes the orbital frequency $f_{\\mathrm{orb}}(t) = \\dfrac{1}{2\\pi} \\sqrt{\\dfrac{G M}{a(t)^3}}$ on the same time grid (aligned with the second-derivative stencil).\n  8. Forms the ratio $R(t) = \\dfrac{f_{\\mathrm{GW}}(t)}{f_{\\mathrm{orb}}(t)}$ and reports, for each test case, a single summary number equal to the median of $R(t)$ over the central fraction of the time series (discard the first and last $0.1$ fraction of the samples to avoid boundary artifacts of differentiation and Hilbert transform). To further improve robustness, exclude points where the analytic-signal envelope amplitude $A(t)$ satisfies $A(t) < \\alpha A_{\\max}$ with $\\alpha = 0.05$.\n\nNumerical details and units:\n- Use the International System of Units for all physical quantities: masses in kilograms, separations in meters, time in seconds, angles in radians, and distance in meters.\n- For each test case, set the number of uniform samples to $N = 8192$ and choose the time step as $\\Delta t = \\dfrac{1}{256 f_{\\mathrm{orb},0}}$ where $f_{\\mathrm{orb},0}$ is the initial orbital frequency computed from the initial separation $a_0$.\n- The final answers are unitless floats (dimensionless ratios).\n\nTest suite:\n- Case $1$: $m_1 = 1.4\\,M_\\odot$, $m_2 = 1.4\\,M_\\odot$, $a_0 = 5.0\\times 10^7\\,\\mathrm{m}$, $\\iota = 0.0\\,\\mathrm{rad}$, $D = 1.0\\times 10^{23}\\,\\mathrm{m}$.\n- Case $2$: $m_1 = 30\\,M_\\odot$, $m_2 = 10\\,M_\\odot$, $a_0 = 2.0\\times 10^8\\,\\mathrm{m}$, $\\iota = \\pi/3\\,\\mathrm{rad}$, $D = 1.0\\times 10^{23}\\,\\mathrm{m}$.\n- Case $3$: $m_1 = 1.4\\,M_\\odot$, $m_2 = 10\\,M_\\odot$, $a_0 = 1.0\\times 10^8\\,\\mathrm{m}$, $\\iota = \\pi/2\\,\\mathrm{rad}$, $D = 1.0\\times 10^{23}\\,\\mathrm{m}$.\n\nRequired output:\n- Your program should produce a single line of output containing the results for the three test cases as a comma-separated list of floats enclosed in square brackets, for example, $\"[r_1,r_2,r_3]\"$, where each $r_i$ is the median of $R(t)$ for the corresponding test case. Report the floats in standard decimal notation. The expected values should be near the integer $2$.\n\nAngle unit:\n- All angles must be in radians.\n\nPhysical unit specification:\n- All quantities are to be computed in the International System of Units, and the final outputs are dimensionless.\n\nNo user input should be read; all parameters must be defined in code exactly as specified above.", "solution": "The problem statement is subjected to rigorous validation and is found to be valid. It is scientifically grounded in the principles of Newtonian mechanics and the leading-order approximation of gravitational radiation from a compact binary system as described by general relativity. The problem is well-posed, providing a complete and consistent set of differential equations, numerical parameters, and procedural steps required for a unique and meaningful solution. The task constitutes a standard numerical experiment in computational astrophysics.\n\nThe core of the problem is to numerically validate the theoretical prediction that the frequency of gravitational waves emitted by a binary system is twice its orbital frequency. This will be achieved by constructing the solution from first principles without assuming this relationship a priori.\n\nThe evolution of the binary system is modeled by two coupled first-order ordinary differential equations (ODEs). The first describes the change in orbital phase $\\phi(t)$, driven by the orbital angular frequency $\\omega(t)$:\n$$\n\\frac{d\\phi}{dt} = \\omega(t) = \\sqrt{\\frac{G M}{a(t)^3}}\n$$\nwhere $G$ is the gravitational constant, $M = m_1 + m_2$ is the total mass of the binary, and $a(t)$ is the instantaneous orbital separation. The second ODE describes the decay of the orbital separation due to the emission of gravitational waves. At the leading (quadrupole) order, this is given by the Peters formula:\n$$\n\\frac{da}{dt} = - \\frac{64}{5} \\frac{G^3}{c^5} \\frac{\\mu M^2}{a^3}\n$$\nwhere $\\mu = \\frac{m_1 m_2}{M}$ is the reduced mass and $c$ is the speed of light. This system of ODEs defines a quasi-circular inspiral. We integrate this system numerically using the fourth-order Runge-Kutta (RK4) method with a fixed time step $\\Delta t$ to obtain the time series for the orbital state, $(a(t), \\phi(t))$.\n\nFrom the orbital trajectory, we construct the gravitational waveform. The relative position vector in the orbital plane ($z=0$) is $\\mathbf{r}(t) = (a(t)\\cos\\phi(t), a(t)\\sin\\phi(t), 0)$. The source of the gravitational radiation at this order is the time-varying mass quadrupole moment. The trace-free mass quadrupole tensor in the center-of-mass frame is given by:\n$$\nI_{ij}(t) = \\mu \\left( r_i(t) r_j(t) - \\frac{1}{3}\\delta_{ij} r(t)^2 \\right)\n$$\nwhere $r_i$ are the components of $\\mathbf{r}$ and $r^2 = a^2$. The gravitational-wave strain tensor in the transverse-traceless (TT) gauge is proportional to the second time derivative of the quadrupole tensor. For an observer at a luminosity distance $D$, the strain is:\n$$\nh_{ij}^{\\mathrm{TT}}(t) = \\frac{2 G}{c^4 D} \\frac{d^2 I_{ij}^{\\mathrm{TT}}(t)}{dt^2}\n$$\nWe compute the second time derivative $\\ddot{I}_{ij}(t)$ numerically from the time series $I_{ij}(t)$ using a second-order centered finite-difference stencil:\n$$\n\\frac{d^2 f(t)}{dt^2} \\approx \\frac{f(t+\\Delta t) - 2f(t) + f(t-\\Delta t)}{(\\Delta t)^2}\n$$\nThe observable waveform depends on the observer's line of sight, $\\hat{\\mathbf{n}}$, and the chosen polarization basis, $\\{\\hat{\\mathbf{p}}, \\hat{\\mathbf{q}}\\}$. The problem specifies $\\hat{\\mathbf n} = (\\sin\\iota, 0, \\cos\\iota)$, $\\hat{\\mathbf p} = (\\cos\\iota, 0, -\\sin\\iota)$, and $\\hat{\\mathbf q} = (0, 1, 0)$, where $\\iota$ is the inclination angle. The plus-polarization strain, $h_+(t)$, is obtained by projecting $\\ddot{I}_{ij}(t)$ onto the polarization tensor $e_+^{ij} = p^i p^j - q^i q^j$:\n$$\nh_{+}(t) = \\frac{2 G}{c^4 D} e_+^{ij} \\ddot{I}_{ij}(t)\n$$\n\nTo extract the instantaneous gravitational-wave frequency $f_{\\mathrm{GW}}(t)$ from the synthesized waveform $h_+(t)$, we employ the concept of the analytic signal. The analytic signal $z(t)$ is a complex time series whose real part is the original signal and whose imaginary part is the Hilbert transform of the original signal, $\\mathcal{H}[h_+](t)$:\n$$\nz(t) = h_+(t) + i \\mathcal{H}[h_+](t) = A(t) e^{i\\psi(t)}\n$$\nThe instantaneous phase of the wave is $\\psi(t)$, which is obtained from the argument of $z(t)$ and made continuous using an unwrapping algorithm. The instantaneous angular frequency is then the time derivative of this phase, $\\omega_{\\mathrm{GW}}(t) = d\\psi(t)/dt$, which we compute numerically using another centered finite-difference stencil. The desired frequency is $f_{\\mathrm{GW}}(t) = \\omega_{\\mathrm{GW}}(t) / (2\\pi)$.\n\nFinally, we perform the verification. We compute the theoretical orbital frequency directly from the evolved separation $a(t)$:\n$$\nf_{\\mathrm{orb}}(t) = \\frac{1}{2\\pi} \\sqrt{\\frac{G M}{a(t)^3}}\n$$\nThe ratio $R(t) = f_{\\mathrm{GW}}(t) / f_{\\mathrm{orb}}(t)$ is then calculated on a common time grid. To ensure a robust result, we discard the first and last $10\\%$ of the samples to mitigate boundary effects from the numerical differentiations and the Hilbert transform. Furthermore, we apply an amplitude filter, excluding points where the waveform envelope $A(t)$ is less than $5\\%$ of its maximum value, as low-amplitude regions can have poorly determined phase. The median of the resulting filtered ratio values is reported for each test case. This median is expected to be very close to $2$.", "answer": "```python\nimport numpy as np\nfrom scipy import signal\nfrom scipy.constants import G, c\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave evolution problem for three test cases.\n    \"\"\"\n    \n    # Physical constants\n    M_SOLAR = 1.98847e30  # Solar mass in kg\n\n    # Numerical parameters\n    N_SAMPLES = 8192\n    SAMPLING_FACTOR = 256.0\n    \n    # Test cases\n    test_cases = [\n        {\n            \"m1_solar\": 1.4, \"m2_solar\": 1.4, \"a0\": 5.0e7,\n            \"iota\": 0.0, \"D\": 1.0e23,\n        },\n        {\n            \"m1_solar\": 30.0, \"m2_solar\": 10.0, \"a0\": 2.0e8,\n            \"iota\": np.pi / 3, \"D\": 1.0e23,\n        },\n        {\n            \"m1_solar\": 1.4, \"m2_solar\": 10.0, \"a0\": 1.0e8,\n            \"iota\": np.pi / 2, \"D\": 1.0e23,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack parameters and convert to SI units\n        m1 = case[\"m1_solar\"] * M_SOLAR\n        m2 = case[\"m2_solar\"] * M_SOLAR\n        a0 = case[\"a0\"]\n        iota = case[\"iota\"]\n        dist = case[\"D\"]\n\n        # Derived masses\n        M = m1 + m2\n        mu = (m1 * m2) / M\n\n        # Initial conditions and time grid\n        f_orb_0 = (1 / (2 * np.pi)) * np.sqrt(G * M / a0**3)\n        dt = 1 / (SAMPLING_FACTOR * f_orb_0)\n        time_grid = np.linspace(0, (N_SAMPLES - 1) * dt, N_SAMPLES)\n\n        # Arrays to store evolution\n        a_t = np.zeros(N_SAMPLES)\n        phi_t = np.zeros(N_SAMPLES)\n        a_t[0] = a0\n        phi_t[0] = 0.0\n\n        # ODE system coefficients\n        Ca = (64/5) * (G**3 / c**5) * mu * M**2\n        Cphi = np.sqrt(G * M)\n\n        # ODE functions\n        def f_a(a_val):\n            return -Ca * a_val**-3\n\n        def f_phi(a_val):\n            return Cphi * a_val**-1.5\n\n        # RK4 integration\n        for i in range(N_SAMPLES - 1):\n            a_i, phi_i = a_t[i], phi_t[i]\n            \n            k1a = f_a(a_i)\n            k1phi = f_phi(a_i)\n\n            k2a = f_a(a_i + 0.5 * dt * k1a)\n            k2phi = f_phi(a_i + 0.5 * dt * k1a)\n\n            k3a = f_a(a_i + 0.5 * dt * k2a)\n            k3phi = f_phi(a_i + 0.5 * dt * k2a)\n            \n            k4a = f_a(a_i + dt * k3a)\n            k4phi = f_phi(a_i + dt * k3a)\n\n            a_t[i+1] = a_i + (dt/6.0) * (k1a + 2*k2a + 2*k3a + k4a)\n            phi_t[i+1] = phi_i + (dt/6.0) * (k1phi + 2*k2phi + 2*k3phi + k4phi)\n\n        # Construct Quadrupole Tensor I_ij\n        x = a_t * np.cos(phi_t)\n        y = a_t * np.sin(phi_t)\n        r_sq = a_t**2\n        \n        I11 = mu * (x**2 - r_sq / 3.0)\n        I22 = mu * (y**2 - r_sq / 3.0)\n        I33 = mu * (-r_sq / 3.0)\n        I12 = mu * x * y\n        I13 = np.zeros_like(a_t)\n        I23 = np.zeros_like(a_t)\n        \n        # Second time derivative via finite difference\n        # Stencil: (f[t+dt] - 2f[t] + f[t-dt]) / dt^2\n        # This reduces array length by 2\n        ddot_I11 = (I11[2:] - 2 * I11[1:-1] + I11[:-2]) / dt**2\n        ddot_I22 = (I22[2:] - 2 * I22[1:-1] + I22[:-2]) / dt**2\n        ddot_I33 = (I33[2:] - 2 * I33[1:-1] + I33[:-2]) / dt**2\n        ddot_I12 = (I12[2:] - 2 * I12[1:-1] + I12[:-2]) / dt**2\n\n        # Polarization tensor e_plus_ij\n        cos_i, sin_i = np.cos(iota), np.sin(iota)\n        e_plus = np.zeros((3, 3))\n        e_plus[0, 0] = cos_i**2\n        e_plus[1, 1] = -1.0\n        e_plus[2, 2] = sin_i**2\n        \n        # Construct h_plus(t)\n        h_plus_t = (2 * G / (c**4 * dist)) * (\n            e_plus[0, 0] * ddot_I11 +\n            e_plus[1, 1] * ddot_I22 +\n            e_plus[2, 2] * ddot_I33\n            # Symmetries in I_ij and e_plus mean we only need these terms\n        )\n\n        # Extract instantaneous frequency f_GW\n        analytic_signal = signal.hilbert(h_plus_t)\n        amplitude_gw = np.abs(analytic_signal)\n        phase_gw = np.unwrap(np.angle(analytic_signal))\n        \n        # Differentiate phase via finite difference: (psi[t+dt]-psi[t-dt])/(2*dt)\n        # This reduces array length by 2\n        omega_gw_t = (phase_gw[2:] - phase_gw[:-2]) / (2 * dt)\n        f_gw_t = omega_gw_t / (2 * np.pi)\n\n        # Align orbital frequency array\n        # f_gw_t corresponds to original time grid [2:-2]\n        a_t_aligned = a_t[2:-2]\n        f_orb_t = (1 / (2 * np.pi)) * np.sqrt(G * M / a_t_aligned**3)\n        \n        # Form ratio R(t)\n        ratio_t = f_gw_t / f_orb_t\n        \n        # Process the ratio: trim boundaries and filter by amplitude\n        num_pts = len(ratio_t)\n        start_idx = int(0.1 * num_pts)\n        end_idx = num_pts - start_idx\n        \n        ratio_slice = ratio_t[start_idx:end_idx]\n        \n        # Align amplitude for filtering\n        # amplitude_gw corresponds to time grid [1:-1]\n        # ratio_t corresponds to time grid [2:-2]\n        # So, align amplitude_gw by taking its [1:-1] slice\n        amplitude_aligned = amplitude_gw[1:-1]\n        amplitude_slice = amplitude_aligned[start_idx:end_idx]\n        \n        amplitude_max = np.max(amplitude_gw)\n        \n        # Apply amplitude filter\n        mask = amplitude_slice >= 0.05 * amplitude_max\n        \n        filtered_ratio = ratio_slice[mask]\n        \n        if len(filtered_ratio) > 0:\n            median_ratio = np.median(filtered_ratio)\n        else: # Should not happen with these parameters\n            median_ratio = np.nan\n            \n        results.append(median_ratio)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2399179"}, {"introduction": "Real gravitational-wave signals are more complex than the simple dominant mode, containing a symphony of higher-order harmonics that encode richer information about the source. This final practice introduces you to a key technique in gravitational-wave data analysis: filtering. You will construct a signal containing multiple modes and then design a filter to subtract the dominant component, thereby isolating the fainter, higher-order harmonics for study [@problem_id:2399144].", "problem": "You are asked to construct and apply a mathematically well-defined gravitational-wave filter that removes the dominant spherical-harmonic mode from a synthetic strain time series of a compact binary inspiral, in order to study the residual that contains only sub-dominant higher-order modes.\n\nYou will model the inspiral gravitational-wave strain in the time domain as a sum of modes. The dominant mode is the $(l,m)=(2,2)$ mode with instantaneous gravitational-wave frequency $f_{22}(t)$ and phase $\\Phi_{22}(t)$. Sub-dominant modes are taken to have instantaneous phases that are integer ratios of the $(2,2)$ phase according to $m$, i.e., for mode $(3,3)$ use $\\Phi_{33}(t) = \\tfrac{3}{2}\\,\\Phi_{22}(t) + \\delta_{33}$, and for mode $(2,1)$ use $\\Phi_{21}(t) = \\tfrac{1}{2}\\,\\Phi_{22}(t) + \\delta_{21}$. The overall detector strain is modeled as the linear superposition of these modes with leading-order inspiral amplitudes and fixed relative mode weights:\n$$\ns(t) \\;=\\; h_{22}(t) \\;+\\; h_{33}(t) \\;+\\; h_{21}(t),\n$$\nwith\n$$\nh_{22}(t) \\;=\\; A_{22}(t)\\,\\cos\\!\\big(\\Phi_{22}(t)\\big), \\quad\nh_{33}(t) \\;=\\; r_{33}\\,A_{22}(t)\\,\\cos\\!\\big(\\Phi_{33}(t)\\big), \\quad\nh_{21}(t) \\;=\\; r_{21}\\,A_{22}(t)\\,\\cos\\!\\big(\\Phi_{21}(t)\\big).\n$$\n\nThe dominant-mode amplitude $A_{22}(t)$ and the dominant-mode frequency $f_{22}(t)$ are given at leading order in the inspiral regime by\n$$\nA_{22}(t) \\;=\\; \\frac{\\big(4\\,G\\,\\mathcal{M}/c^2\\big)^{5/3}\\,\\big(\\pi\\,f_{22}(t)\\big)^{2/3}}{D},\n$$\n$$\n\\frac{\\mathrm{d} f_{22}}{\\mathrm{d} t} \\;=\\; \\frac{96}{5}\\,\\pi^{8/3}\\,\\left(\\frac{G\\,\\mathcal{M}}{c^3}\\right)^{5/3} f_{22}^{11/3}(t),\n$$\nand the dominant-mode phase obeys\n$$\n\\frac{\\mathrm{d}\\Phi_{22}}{\\mathrm{d}t} \\;=\\; 2\\pi\\,f_{22}(t), \\qquad \\Phi_{22}(t_0) = 0.\n$$\nHere $G$ is the gravitational constant, $c$ is the speed of light, and $\\mathcal{M}$ is the chirp mass defined by\n$$\n\\mathcal{M} \\;=\\; \\frac{(m_1 m_2)^{3/5}}{(m_1 + m_2)^{1/5}}.\n$$\nThe source distance is $D$. All physical constants and parameters must be used in International System of Units (SI). Use $G = 6.67430\\times 10^{-11}$, $c = 2.99792458\\times 10^{8}$, Solar mass $M_{\\odot} = 1.98847\\times 10^{30}$, and $1\\,\\mathrm{Mpc} = 3.085677581491367\\times 10^{22}\\,\\mathrm{m}$. Masses $m_1$ and $m_2$ are specified in units of $M_{\\odot}$ and must be converted to kilograms. Distances are specified in megaparsecs and must be converted to meters. Frequencies are in hertz, time is in seconds, and phases are in radians.\n\nConstruct the time series by numerically integrating the inspiral from a given initial dominant-mode frequency $f_{22}(t_0)=f_0$ to a given terminal frequency $f_{1}$, on a uniform time grid with sampling rate $f_s$ (in hertz). The uniform time step is $\\Delta t = 1/f_s$. The instantaneous dominant-mode frequency $f_{22}(t)$ is evolved using the ordinary differential equation above. The phase $\\Phi_{22}(t)$ is obtained by integrating its time derivative. The sub-dominant mode phases $\\Phi_{33}(t)$ and $\\Phi_{21}(t)$ are constructed from $\\Phi_{22}(t)$ as stated, with fixed offsets $\\delta_{33}$ and $\\delta_{21}$ in radians.\n\nDefine the dominant-mode removal filter as follows. Consider the two-parameter family of waveforms\n$$\n\\hat{h}_{22}(t; S,\\varphi) \\;=\\; S\\,A_{22}(t)\\,\\cos\\!\\big(\\Phi_{22}(t) + \\varphi\\big),\n$$\nwith real parameters $S$ and $\\varphi$. Choose $S^\\star$ and $\\varphi^\\star$ that minimize the discrete-time least-squares error\n$$\nE(S,\\varphi) \\;=\\; \\sum_{n=0}^{N-1} \\Big(s(t_n) - \\hat{h}_{22}(t_n; S,\\varphi)\\Big)^2,\n$$\nwhere $t_n = t_0 + n\\,\\Delta t$ and $N$ is the total number of samples accumulated before $f_{22}(t)$ first reaches $f_1$. Define the residual\n$$\nr(t) \\;=\\; s(t) \\;-\\; \\hat{h}_{22}(t; S^\\star,\\varphi^\\star).\n$$\n\nFor each test case, compute the ratio\n$$\nR \\;=\\; \\frac{\\mathrm{RMS}\\big(r(t)\\big)}{\\mathrm{RMS}\\big(s(t)\\big)},\n$$\nwhere for a discrete time series $x(t_n)$ with $N$ samples,\n$$\n\\mathrm{RMS}(x) \\;=\\; \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} x^2(t_n)}.\n$$\nReport $R$ as a floating-point number rounded to six decimal places (no unit).\n\nUse the sampling rate $f_s = 4096$.\n\nImplement your program to compute $R$ for the following three test cases (all distances $D$ are given in megaparsecs, all masses in units of $M_{\\odot}$, all phase offsets in radians):\n\n- Test case 1 (general case): $m_1 = 30$, $m_2 = 30$, $D = 500$, $f_0 = 30$, $f_1 = 150$, $r_{33} = 0.2$, $r_{21} = 0.1$, $\\delta_{33} = 0.3$, $\\delta_{21} = -0.5$.\n- Test case 2 (unequal-mass, stronger higher modes): $m_1 = 35$, $m_2 = 20$, $D = 300$, $f_0 = 25$, $f_1 = 200$, $r_{33} = 0.35$, $r_{21} = 0.15$, $\\delta_{33} = 0.1$, $\\delta_{21} = -0.2$.\n- Test case 3 (boundary case with no higher modes): $m_1 = 20$, $m_2 = 20$, $D = 400$, $f_0 = 40$, $f_1 = 120$, $r_{33} = 0.0$, $r_{21} = 0.0$, $\\delta_{33} = 0.0$, $\\delta_{21} = 0.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases above, for example, \"[result1,result2,result3]\". Each result must be the value of $R$ for that test case, rounded to six decimal places as specified. No other text should be printed.", "solution": "The problem statement is a valid computational physics task. It is scientifically grounded in the post-Newtonian approximation of general relativity for gravitational waves from a compact binary inspiral. The problem is well-posed, providing all necessary physical parameters, differential equations, initial conditions, and a clear definition of the computational goal. It is objective and uses standard, unambiguous terminology. We will therefore proceed with a complete solution.\n\nThe core of the problem is to generate a synthetic gravitational wave signal, apply a least-squares filter to remove its dominant component, and quantify the filter's performance. The solution is structured as follows:\n1.  Conversion of physical parameters to SI units and computation of derived constants.\n2.  Numerical integration of the system of ordinary differential equations (ODEs) to generate the time evolution of the dominant mode's frequency and phase.\n3.  Construction of the full gravitational wave strain time series, $s(t)$, by superimposing the dominant $(l,m)=(2,2)$ mode and the sub-dominant $(3,3)$ and $(2,1)$ modes.\n4.  Derivation and application of a linear least-squares filter to optimally subtract the dominant $(2,2)$ mode from the signal.\n5.  Calculation of the final performance metric, $R$, defined as the ratio of the root-mean-square (RMS) of the residual signal to the RMS of the original signal.\n\n**1. Physical Parameters and Constants**\n\nFirst, all input parameters are converted to SI units. The masses $m_1$ and $m_2$, given in solar masses ($M_{\\odot}$), are converted to kilograms ($kg$). The distance $D$, given in megaparsecs ($Mpc$), is converted to meters ($m$). The key physical parameter governing the inspiral is the chirp mass, $\\mathcal{M}$, defined as:\n$$\n\\mathcal{M} = \\frac{(m_1 m_2)^{3/5}}{(m_1 + m_2)^{1/5}}\n$$\nWe use the provided values for the gravitational constant $G$, the speed of light $c$, the solar mass $M_{\\odot}$, and the megaparsec-to-meter conversion factor.\n\n**2. Numerical Waveform Generation**\n\nThe evolution of the binary system is described by a system of two coupled first-order ODEs for the dominant mode's instantaneous frequency, $f_{22}(t)$, and phase, $\\Phi_{22}(t)$:\n$$\n\\frac{\\mathrm{d} f_{22}}{\\mathrm{d} t} = K_f \\cdot f_{22}^{11/3}(t)\n$$\n$$\n\\frac{\\mathrm{d}\\Phi_{22}}{\\mathrm{d}t} = 2\\pi f_{22}(t)\n$$\nwhere the constant $K_f$ is given by $K_f = \\frac{96}{5}\\pi^{8/3}\\left(\\frac{G\\mathcal{M}}{c^3}\\right)^{5/3}$.\n\nWe solve this system numerically on a uniform time grid with step $\\Delta t = 1/f_s$, where $f_s$ is the sampling frequency. A simple and adequate method is the forward Euler scheme. Starting from initial conditions $t_0=0$, $f_{22}(t_0)=f_0$, and $\\Phi_{22}(t_0)=0$, we iterate as follows for each time step $n$:\n$$\nf_{22}(t_{n+1}) = f_{22}(t_n) + \\Delta t \\cdot K_f \\cdot f_{22}^{11/3}(t_n)\n$$\n$$\n\\Phi_{22}(t_{n+1}) = \\Phi_{22}(t_n) + \\Delta t \\cdot 2\\pi f_{22}(t_n)\n$$\nThe integration proceeds until the frequency $f_{22}(t)$ first reaches or exceeds the terminal frequency $f_1$. The values of $t_n$, $f_{22}(t_n)$, and $\\Phi_{22}(t_n)$ are stored at each step, forming discrete time series.\n\n**3. Strain Time Series Construction**\n\nWith the frequency and phase evolution known, we construct the full signal $s(t_n)$. The amplitude of the dominant mode, $A_{22}(t)$, depends on the instantaneous frequency:\n$$\nA_{22}(t) = K_A \\cdot f_{22}^{2/3}(t), \\quad \\text{where} \\quad K_A = \\frac{\\big(4\\,G\\,\\mathcal{M}/c^2\\big)^{5/3}\\,\\big(\\pi\\big)^{2/3}}{D}\n$$\nThe individual mode contributions are then calculated:\n$$\nh_{22}(t_n) = A_{22}(t_n) \\cos\\big(\\Phi_{22}(t_n)\\big)\n$$\nThe sub-dominant mode phases are constructed from the dominant one:\n$$\n\\Phi_{33}(t_n) = \\frac{3}{2}\\Phi_{22}(t_n) + \\delta_{33}\n$$\n$$\n\\Phi_{21}(t_n) = \\frac{1}{2}\\Phi_{22}(t_n) + \\delta_{21}\n$$\nAnd their respective waveforms are:\n$$\nh_{33}(t_n) = r_{33} A_{22}(t_n) \\cos\\big(\\Phi_{33}(t_n)\\big)\n$$\n$$\nh_{21}(t_n) = r_{21} A_{22}(t_n) \\cos\\big(\\Phi_{21}(t_n)\\big)\n$$\nThe total observed signal is the linear superposition:\n$$\ns(t_n) = h_{22}(t_n) + h_{33}(t_n) + h_{21}(t_n)\n$$\n\n**4. Dominant Mode Filtering via Least Squares**\n\nWe aim to find the parameters $S^\\star$ and $\\varphi^\\star$ that best fit the data $s(t_n)$ with the template $\\hat{h}_{22}(t; S,\\varphi) = S A_{22}(t) \\cos(\\Phi_{22}(t) + \\varphi)$. This is achieved by minimizing the sum of squared errors:\n$$\nE(S,\\varphi) = \\sum_{n=0}^{N-1} \\Big(s(t_n) - S A_{22}(t_n) \\cos(\\Phi_{22}(t_n) + \\varphi)\\Big)^2\n$$\nThe problem can be linearized by re-parameterizing the template. Using the trigonometric identity $\\cos(\\alpha + \\beta) = \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta$, we write:\n$$\n\\hat{h}_{22}(t_n) = (S\\cos\\varphi) \\cdot \\big[ A_{22}(t_n)\\cos(\\Phi_{22}(t_n)) \\big] - (S\\sin\\varphi) \\cdot \\big[ A_{22}(t_n)\\sin(\\Phi_{22}(t_n)) \\big]\n$$\nLet's define two basis vectors, $u(t_n) = A_{22}(t_n)\\cos(\\Phi_{22}(t_n))$ and $v(t_n) = A_{22}(t_n)\\sin(\\Phi_{22}(t_n))$, and new linear coefficients $C_1 = S\\cos\\varphi$ and $C_2 = S\\sin\\varphi$. The template becomes $\\hat{h}_{22}(t_n) = C_1 u(t_n) - C_2 v(t_n)$.\nThe error is $E(C_1, C_2) = \\sum_{n=0}^{N-1} (s_n - C_1 u_n + C_2 v_n)^2$.\nMinimizing $E$ with respect to $C_1$ and $C_2$ by setting $\\partial E/\\partial C_1 = 0$ and $\\partial E/\\partial C_2 = 0$ yields a $2 \\times 2$ system of linear equations for the optimal coefficients $(C_1^\\star, C_2^\\star)$:\n$$\n\\begin{pmatrix} \\sum u_n^2 & -\\sum u_n v_n \\\\ -\\sum u_n v_n & \\sum v_n^2 \\end{pmatrix}\n\\begin{pmatrix} C_1 \\\\ C_2 \\end{pmatrix}\n=\n\\begin{pmatrix} \\sum s_n u_n \\\\ -\\sum s_n v_n \\end{pmatrix}\n$$\nIntroducing the notation for the dot product of two time series $x$ and $y$ as $\\langle x, y \\rangle = \\sum_n x_n y_n$, the system is:\n$$\n\\begin{pmatrix} \\langle u, u \\rangle & -\\langle u, v \\rangle \\\\ -\\langle u, v \\rangle & \\langle v, v \\rangle \\end{pmatrix}\n\\begin{pmatrix} C_1 \\\\ C_2 \\end{pmatrix}\n=\n\\begin{pmatrix} \\langle s, u \\rangle \\\\ -\\langle s, v \\rangle \\end{pmatrix}\n$$\nThis system is solved for the optimal coefficients $(C_1^\\star, C_2^\\star)$.\n\n**5. Residual and Performance Metric Calculation**\n\nThe best-fit dominant mode waveform is then constructed using the optimal coefficients:\n$$\n\\hat{h}_{22}(t_n; S^\\star,\\varphi^\\star) = C_1^\\star u(t_n) - C_2^\\star v(t_n)\n$$\nThe residual signal $r(t_n)$ is what remains after subtracting this fitted waveform from the original signal:\n$$\nr(t_n) = s(t_n) - \\hat{h}_{22}(t_n; S^\\star,\\varphi^\\star)\n$$\nFinally, we compute the performance metric $R$. For a discrete time series $x(t_n)$ of length $N$, the RMS is $\\mathrm{RMS}(x) = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} x_n^2}$. The ratio $R$ is:\n$$\nR = \\frac{\\mathrm{RMS}\\big(r\\big)}{\\mathrm{RMS}\\big(s\\big)}\n$$\nThis procedure is applied to each test case, and the resulting value of $R$ is reported, rounded to six decimal places. For the special case where sub-dominant modes are absent ($r_{33}=r_{21}=0$), the signal $s(t)$ is identical to the basis function $u(t)$. The analytical solution to the least-squares problem is $C_1^\\star=1, C_2^\\star=0$, yielding a zero residual and $R=0$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave filtering problem for the specified test cases.\n    \"\"\"\n    \n    # Physical constants in SI units\n    G = 6.67430e-11  # Gravitational constant (m^3 kg^-1 s^-2)\n    C = 2.99792458e8   # Speed of light (m/s)\n    M_SOLAR = 1.98847e30 # Solar mass (kg)\n    MPC_TO_M = 3.085677581491367e22 # Megaparsec to meter conversion\n\n    def solve_one_case(m1, m2, D, f0, f1, r33, r21, d33, d21, fs):\n        \"\"\"\n        Computes the residual-to-signal RMS ratio R for a single test case.\n        \"\"\"\n        # 1. Parameter conversion and pre-computation\n        m1_kg = m1 * M_SOLAR\n        m2_kg = m2 * M_SOLAR\n        D_m = D * MPC_TO_M\n        dt = 1.0 / fs\n\n        # Chirp mass calculation\n        M_chirp_si = ((m1_kg * m2_kg)**(3.0/5.0)) / ((m1_kg + m2_kg)**(1.0/5.0))\n\n        # Constant for frequency evolution ODE\n        K_f = (96.0 / 5.0) * np.pi**(8.0/3.0) * (G * M_chirp_si / C**3)**(5.0/3.0)\n        \n        # Constant for amplitude calculation\n        K_A = ((4.0 * G * M_chirp_si / C**2)**(5.0/3.0) * np.pi**(2.0/3.0)) / D_m\n\n        # 2. Numerical integration using forward Euler method\n        t_n = 0.0\n        f_n = f0\n        phi_n = 0.0\n\n        times, freqs, phases = [], [], []\n\n        while f_n < f1:\n            times.append(t_n)\n            freqs.append(f_n)\n            phases.append(phi_n)\n\n            # Euler step for the system of ODEs\n            f_dot = K_f * f_n**(11.0 / 3.0)\n            phi_dot = 2.0 * np.pi * f_n\n            \n            f_n += f_dot * dt\n            phi_n += phi_dot * dt\n            t_n += dt\n        \n        freqs_ts = np.array(freqs)\n        phases_ts = np.array(phases)\n\n        # 3. Waveform Generation\n        A22_ts = K_A * freqs_ts**(2.0/3.0)\n        \n        phi22 = phases_ts\n        phi33 = 1.5 * phi22 + d33\n        phi21 = 0.5 * phi22 + d21\n\n        h22 = A22_ts * np.cos(phi22)\n        h33 = r33 * A22_ts * np.cos(phi33)\n        h21 = r21 * A22_ts * np.cos(phi21)\n        \n        s_ts = h22 + h33 + h21\n\n        # 4. Least-Squares Minimization\n        # Define basis functions for the linear fit\n        u_ts = A22_ts * np.cos(phi22)\n        v_ts = A22_ts * np.sin(phi22)\n\n        # Assemble and solve the 2x2 linear system M * C = V\n        # Re-parameterization: h_hat = C1*u - C2*v where C1=S*cos(phi), C2=S*sin(phi)\n        V = np.array([np.dot(s_ts, u_ts), -np.dot(s_ts, v_ts)])\n        M = np.array([\n            [np.dot(u_ts, u_ts), -np.dot(u_ts, v_ts)],\n            [-np.dot(u_ts, v_ts), np.dot(v_ts, v_ts)]\n        ])\n        \n        # Handle the edge case where M might be singular (e.g., if u or v is zero)\n        if np.linalg.det(M) < 1e-15:\n            if np.allclose(s_ts, u_ts):\n                C1_star, C2_star = 1.0, 0.0\n            else:\n                 # Fallback for ill-conditioned systems not covered by test cases\n                C1_star, C2_star = 0.0, 0.0\n        else:\n             C_opt = np.linalg.solve(M, V)\n             C1_star, C2_star = C_opt[0], C_opt[1]\n    \n        # 5. Calculate Residual and RMS ratio\n        # Reconstruct the best-fit dominant mode waveform\n        h22_hat = C1_star * u_ts - C2_star * v_ts\n        \n        # Calculate the residual\n        r_ts = s_ts - h22_hat\n        \n        # Calculate RMS values\n        rms_s = np.sqrt(np.mean(s_ts**2))\n        rms_r = np.sqrt(np.mean(r_ts**2))\n        \n        # The ratio R. Handle potential division by zero.\n        if rms_s == 0:\n            return 0.0\n            \n        R = rms_r / rms_s\n        return R\n\n    # Sampling rate\n    fs = 4096.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m1, m2, D, f0, f1, r33, r21, d33, d21)\n        (30.0, 30.0, 500.0, 30.0, 150.0, 0.2, 0.1, 0.3, -0.5),\n        (35.0, 20.0, 300.0, 25.0, 200.0, 0.35, 0.15, 0.1, -0.2),\n        (20.0, 20.0, 400.0, 40.0, 120.0, 0.0, 0.0, 0.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_one_case(*case, fs=fs)\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    # Each result is a float formatted to six decimal places.\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    print(output_str)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2399144"}]}