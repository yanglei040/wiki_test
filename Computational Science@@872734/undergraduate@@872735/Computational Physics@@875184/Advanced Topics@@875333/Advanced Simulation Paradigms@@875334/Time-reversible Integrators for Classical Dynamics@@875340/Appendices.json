{"hands_on_practices": [{"introduction": "The theoretical advantages of time-reversible integrators become strikingly clear in long-term simulations, such as those in celestial mechanics. In this exercise, you will directly compare the performance of the time-reversible velocity Verlet algorithm against the classic fourth-order Runge-Kutta (RK4) method. By simulating a planetary orbit [@problem_id:2446756], a system where energy conservation is paramount, you will gain firsthand experience with the concepts of bounded energy error versus secular energy drift, providing a concrete answer to why symplectic methods are the standard for simulating Hamiltonian systems.", "problem": "Implement and compare two numerical integrators for Newtonian two-body motion in a plane, one that is time-reversible and symplectic (velocity Verlet) and one that is explicit and fourth-order but not time-reversible (Runge–Kutta of order four (RK4)). Consider a test particle of mass $m=1\\ \\mathrm{kg}$ moving under the gravitational field of a fixed central body with standard gravitational parameter $\\mu = G M = 1.32712440018\\times 10^{20}\\ \\mathrm{m^3/s^2}$. The equations of motion are the first-order system\n$$\n\\dot{\\mathbf{r}}(t) = \\mathbf{v}(t),\\qquad \\dot{\\mathbf{v}}(t) = -\\frac{\\mu}{\\|\\mathbf{r}(t)\\|^3}\\,\\mathbf{r}(t),\n$$\nwith total specific mechanical energy\n$$\nE(t) = \\frac{1}{2}\\,\\|\\mathbf{v}(t)\\|^2 - \\frac{\\mu}{\\|\\mathbf{r}(t)\\|},\n$$\nwhich is conserved exactly by the continuous dynamics. Use initial position $\\mathbf{r}_0 = (r_0,0)$ with $r_0 = 1.495978707\\times 10^{11}\\ \\mathrm{m}$ and initial velocity $\\mathbf{v}_0 = (0, v_{\\mathrm{init}})$ as specified in each test case. The velocity for a circular orbit at radius $r_0$ is $v_{\\mathrm{circ}} = \\sqrt{\\mu/r_0}$.\n\nSimulate the motion in two spatial dimensions using both integrators for each test case below. For each simulation, advance in uniform time steps of size $\\Delta t$ up to a total time $T$. Define the number of steps as $N=\\left\\lfloor T/\\Delta t \\right\\rfloor$, and advance exactly $N$ steps. Compute the absolute relative drift in the specific energy as\n$$\n\\varepsilon = \\left|\\frac{E_N - E_0}{|E_0|}\\right|,\n$$\nwhere $E_0$ is the initial specific energy and $E_N$ is the specific energy after $N$ steps. Report $\\varepsilon$ for both the velocity Verlet and the Runge–Kutta of order four (RK4) methods.\n\nUse the International System of Units (SI) throughout, with distances in $\\mathrm{m}$, time in $\\mathrm{s}$, and energy in $\\mathrm{J/kg}$ (specific energy). Angles, if any appear internally, should be in radians. The final outputs are dimensionless numbers.\n\nTest Suite:\n- Case $1$ (circular, fine step): $v_{\\mathrm{init}} = v_{\\mathrm{circ}}$, $\\Delta t = 86400\\ \\mathrm{s}$, $T = 50\\times 365.25\\times 86400\\ \\mathrm{s}$.\n- Case $2$ (circular, coarse step): $v_{\\mathrm{init}} = v_{\\mathrm{circ}}$, $\\Delta t = 5\\times 86400\\ \\mathrm{s}$, $T = 200\\times 365.25\\times 86400\\ \\mathrm{s}$.\n- Case $3$ (elliptical, more eccentric): $v_{\\mathrm{init}} = 0.7\\, v_{\\mathrm{circ}}$, $\\Delta t = 86400\\ \\mathrm{s}$, $T = 100\\times 365.25\\times 86400\\ \\mathrm{s}$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the six numbers in the following order: $[\\varepsilon_{\\mathrm{Verlet,1}}, \\varepsilon_{\\mathrm{RK4,1}}, \\varepsilon_{\\mathrm{Verlet,2}}, \\varepsilon_{\\mathrm{RK4,2}}, \\varepsilon_{\\mathrm{Verlet,3}}, \\varepsilon_{\\mathrm{RK4,3}}]$. Express each number in standard floating-point notation; scientific notation is acceptable. The results are dimensionless real numbers.", "solution": "The problem statement has been subjected to rigorous validation and is found to be scientifically grounded, well-posed, and objective. It represents a standard exercise in computational physics and celestial mechanics, with all necessary parameters and conditions clearly specified. There are no logical inconsistencies, factual errors, or ambiguities. Therefore, we shall proceed with a complete solution.\n\nThe problem requires the implementation and comparison of two numerical integration schemes for the classical Newtonian two-body problem in a plane. The system under consideration is a test particle orbiting a fixed central mass. The dynamics are governed by the following first-order system of ordinary differential equations:\n$$\n\\dot{\\mathbf{r}}(t) = \\mathbf{v}(t)\n$$\n$$\n\\dot{\\mathbf{v}}(t) = \\mathbf{a}(\\mathbf{r}(t)) = -\\frac{\\mu}{\\|\\mathbf{r}(t)\\|^3}\\,\\mathbf{r}(t)\n$$\nHere, $\\mathbf{r}(t)$ is the position vector, $\\mathbf{v}(t)$ is the velocity vector, and $\\mu$ is the standard gravitational parameter of the central body. A key conserved quantity in the exact continuous dynamics is the specific mechanical energy:\n$$\nE = \\frac{1}{2}\\,\\|\\mathbf{v}\\|^2 - \\frac{\\mu}{\\|\\mathbf{r}\\|}\n$$\nNumerical integrators will not conserve this quantity exactly. Our objective is to quantify this numerical error for two different methods: the velocity Verlet algorithm and the classical Runge-Kutta method of order four. The error is measured by the absolute relative energy drift, $\\varepsilon = \\left|\\frac{E_N - E_0}{|E_0|}\\right|$, after $N$ integration steps.\n\nLet us define the discrete time points as $t_n = n \\Delta t$, where $\\Delta t$ is the constant time step. The state of the system at time $t_n$ is $(\\mathbf{r}_n, \\mathbf{v}_n)$.\n\n**1. The Velocity Verlet Integrator**\n\nThe velocity Verlet algorithm is a member of the family of geometric integrators. It is specifically designed to be symplectic and time-reversible, which grants it excellent long-term stability for Hamiltonian systems like the one considered. It does not conserve energy exactly, but the energy error remains bounded and oscillates around the initial value, showing no secular drift. The algorithm is of second-order accuracy.\n\nGiven the state $(\\mathbf{r}_n, \\mathbf{v}_n)$, one step of the velocity Verlet algorithm to compute $(\\mathbf{r}_{n+1}, \\mathbf{v}_{n+1})$ proceeds as follows:\n1.  Compute the acceleration at the current position: $\\mathbf{a}_n = \\mathbf{a}(\\mathbf{r}_n)$.\n2.  Update the velocity by a half-step: $\\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\frac{\\Delta t}{2} \\mathbf{a}_n$.\n3.  Update the position by a full step using this intermediate velocity: $\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\Delta t \\, \\mathbf{v}_{n+1/2}$.\n4.  Compute the acceleration at the new position: $\\mathbf{a}_{n+1} = \\mathbf{a}(\\mathbf{r}_{n+1})$.\n5.  Update the velocity for the remaining half-step: $\\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\frac{\\Delta t}{2} \\mathbf{a}_{n+1}$.\n\nThese steps are combined for implementation, often into the form:\n$$\n\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t + \\frac{1}{2} \\mathbf{a}(\\mathbf{r}_n) \\Delta t^2\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{1}{2} (\\mathbf{a}(\\mathbf{r}_n) + \\mathbf{a}(\\mathbf{r}_{n+1})) \\Delta t\n$$\n\n**2. The Runge-Kutta 4th-Order (RK4) Integrator**\n\nThe classical fourth-order Runge-Kutta method is a widely used explicit integrator known for its high accuracy for a given step size. Its local truncation error is of order $O(\\Delta t^5)$ and its global error is of order $O(\\Delta t^4)$. However, RK4 is not symplectic. Consequently, for Hamiltonian systems, it typically introduces a systematic, or secular, drift in the energy, which accumulates over long integration times.\n\nFor our system $\\dot{\\mathbf{r}}=\\mathbf{v}$ and $\\dot{\\mathbf{v}}=\\mathbf{a}(\\mathbf{r})$, we define the state vector $\\mathbf{y} = (\\mathbf{r}, \\mathbf{v})$ and the function $\\mathbf{f}(\\mathbf{y}) = (\\mathbf{v}, \\mathbf{a}(\\mathbf{r}))$. The RK4 update from $\\mathbf{y}_n$ to $\\mathbf{y}_{n+1}$ is:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nThe intermediate stages $\\mathbf{k}_i = (\\mathbf{k}_{ri}, \\mathbf{k}_{vi})$ for $i=1, 2, 3, 4$ are calculated as:\n- Stage $1$:\n$$ \\mathbf{k}_{r1} = \\mathbf{v}_n \\qquad \\mathbf{k}_{v1} = \\mathbf{a}(\\mathbf{r}_n) $$\n- Stage $2$:\n$$ \\mathbf{k}_{r2} = \\mathbf{v}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{v1} \\qquad \\mathbf{k}_{v2} = \\mathbf{a}\\left(\\mathbf{r}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{r1}\\right) $$\n- Stage $3$:\n$$ \\mathbf{k}_{r3} = \\mathbf{v}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{v2} \\qquad \\mathbf{k}_{v3} = \\mathbf{a}\\left(\\mathbf{r}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{r2}\\right) $$\n- Stage $4$:\n$$ \\mathbf{k}_{r4} = \\mathbf{v}_n + \\Delta t \\, \\mathbf{k}_{v3} \\qquad \\mathbf{k}_{v4} = \\mathbf{a}\\left(\\mathbf{r}_n + \\Delta t \\, \\mathbf{k}_{r3}\\right) $$\nThe final updates for position and velocity are then computed by combining these stages:\n$$\n\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_{r1} + 2\\mathbf{k}_{r2} + 2\\mathbf{k}_{r3} + \\mathbf{k}_{r4})\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_{v1} + 2\\mathbf{k}_{v2} + 2\\mathbf{k}_{v3} + \\mathbf{k}_{v4})\n$$\n\n**3. Execution of Test Cases**\n\nFor each specified test case, we perform the following steps:\n1.  Establish the physical and simulation parameters: $\\mu = 1.32712440018 \\times 10^{20}\\ \\mathrm{m^3/s^2}$, $r_0 = 1.495978707 \\times 10^{11}\\ \\mathrm{m}$, and the case-specific values for $v_{\\mathrm{init}}$, $\\Delta t$, and $T$.\n2.  Calculate the circular velocity $v_{\\mathrm{circ}} = \\sqrt{\\mu/r_0}$ and the initial velocity $\\mathbf{v}_0 = (0, v_{\\mathrm{init}})$. The initial position is $\\mathbf{r}_0 = (r_0, 0)$.\n3.  Compute the initial specific energy $E_0 = E(\\mathbf{r}_0, \\mathbf{v}_0)$. For bound orbits, $E_0  0$.\n4.  Determine the number of integration steps $N = \\lfloor T/\\Delta t \\rfloor$.\n5.  Run two separate simulations, one with velocity Verlet and one with RK4. Each simulation starts from $(\\mathbf{r}_0, \\mathbf{v}_0)$ and runs for exactly $N$ steps.\n6.  After $N$ steps, obtain the final states $(\\mathbf{r}_{N,\\text{Verlet}}, \\mathbf{v}_{N,\\text{Verlet}})$ and $(\\mathbf{r}_{N,\\text{RK4}}, \\mathbf{v}_{N,\\text{RK4}})$.\n7.  Compute the final energies $E_{N,\\text{Verlet}}$ and $E_{N,\\text{RK4}}$.\n8.  Calculate the absolute relative energy drift $\\varepsilon$ for each method and store the results.\n\nThe comparison will highlight the fundamental difference between symplectic and non-symplectic integrators in long-term simulations of Hamiltonian systems. The velocity Verlet integrator is expected to demonstrate superior energy conservation properties over many orbits, even with a larger local error than RK4, while RK4's higher-order accuracy may be undermined by the accumulation of secular errors in energy.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares Velocity Verlet and RK4 integrators for the\n    Newtonian two-body problem, reporting the relative energy drift.\n    \"\"\"\n    # Physical and astronomical constants\n    MU_SUN = 1.32712440018e20  # Standard gravitational parameter of the Sun (m^3/s^2)\n    R0_EARTH = 1.495978707e11   # 1 Astronomical Unit (m)\n    DAY_S = 86400.0            # Seconds in one mean solar day\n    YEAR_S = 365.25 * DAY_S    # Seconds in one Julian year\n\n    # --- Core Physics and Numerical Functions ---\n\n    def acceleration(r_vec):\n        \"\"\"Computes gravitational acceleration vector.\"\"\"\n        dist = np.linalg.norm(r_vec)\n        if dist == 0:\n            # Avoid division by zero at the singularity, though it should not be reached.\n            return np.zeros_like(r_vec)\n        return -MU_SUN * r_vec / dist**3\n\n    def specific_energy(r_vec, v_vec):\n        \"\"\"Computes specific mechanical energy.\"\"\"\n        dist = np.linalg.norm(r_vec)\n        if dist == 0:\n            return np.inf\n        return 0.5 * np.dot(v_vec, v_vec) - MU_SUN / dist\n\n    def velocity_verlet_step(r, v, dt):\n        \"\"\"Performs a single step of the Velocity Verlet integration.\"\"\"\n        a_current = acceleration(r)\n        r_new = r + v * dt + 0.5 * a_current * dt**2\n        a_new = acceleration(r_new)\n        v_new = v + 0.5 * (a_current + a_new) * dt\n        return r_new, v_new\n\n    def rk4_step(r, v, dt):\n        \"\"\"Performs a single step of the RK4 integration.\"\"\"\n        # k1\n        k1_r = v\n        k1_v = acceleration(r)\n\n        # k2\n        r2 = r + 0.5 * dt * k1_r\n        k2_r = v + 0.5 * dt * k1_v\n        k2_v = acceleration(r2)\n\n        # k3\n        r3 = r + 0.5 * dt * k2_r\n        k3_r = v + 0.5 * dt * k2_v\n        k3_v = acceleration(r3)\n\n        # k4\n        r4 = r + dt * k3_r\n        k4_r = v + dt * k3_v\n        k4_v = acceleration(r4)\n\n        # Combine stages\n        r_new = r + (dt / 6.0) * (k1_r + 2*k2_r + 2*k3_r + k4_r)\n        v_new = v + (dt / 6.0) * (k1_v + 2*k2_v + 2*k3_v + k4_v)\n        return r_new, v_new\n\n    # --- Test Suite Setup ---\n    v_circ = np.sqrt(MU_SUN / R0_EARTH)\n\n    test_cases = [\n        # Case 1 (circular, fine step)\n        {'v_init_factor': 1.0, 'dt': 1.0 * DAY_S, 'T': 50.0 * YEAR_S},\n        # Case 2 (circular, coarse step)\n        {'v_init_factor': 1.0, 'dt': 5.0 * DAY_S, 'T': 200.0 * YEAR_S},\n        # Case 3 (elliptical, more eccentric)\n        {'v_init_factor': 0.7, 'dt': 1.0 * DAY_S, 'T': 100.0 * YEAR_S},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # --- Simulation Setup for the current case ---\n        v_init = case['v_init_factor'] * v_circ\n        dt = case['dt']\n        T = case['T']\n        \n        # Initial conditions\n        r0 = np.array([R0_EARTH, 0.0])\n        v0 = np.array([0.0, v_init])\n        \n        num_steps = int(T / dt) # As per problem spec: N = floor(T/dt)\n        \n        # Initial energy\n        E0 = specific_energy(r0, v0)\n\n        # --- Velocity Verlet Simulation ---\n        r_v, v_v = r0.copy(), v0.copy()\n        for _ in range(num_steps):\n            r_v, v_v = velocity_verlet_step(r_v, v_v, dt)\n        \n        E_N_verlet = specific_energy(r_v, v_v)\n        epsilon_verlet = abs((E_N_verlet - E0) / E0)\n        results.append(epsilon_verlet)\n        \n        # --- RK4 Simulation ---\n        r_rk, v_rk = r0.copy(), v0.copy()\n        for _ in range(num_steps):\n            r_rk, v_rk = rk4_step(r_rk, v_rk, dt)\n\n        E_N_rk4 = specific_energy(r_rk, v_rk)\n        epsilon_rk4 = abs((E_N_rk4 - E0) / E0)\n        results.append(epsilon_rk4)\n\n    # --- Final Output ---\n    # Convert results to string representation for printing\n    result_str = [f\"{res:.10e}\" for res in results]\n    print(f\"[{','.join(result_str)}]\")\n\nsolve()\n```", "id": "2446756"}, {"introduction": "Having established the superiority of Verlet integrators for long-term stability, we now turn to a critical implementation detail. The popular position Verlet algorithm is a multi-step method, meaning it requires information from previous time steps to advance, creating a \"bootstrapping\" problem for the first step. This exercise [@problem_id:2446800] explores how different bootstrapping techniques affect the integrator's long-term accuracy and energy conservation, demonstrating that maintaining the method's inherent order of accuracy from the very start is crucial for preserving its excellent performance.", "problem": "Construct a complete, runnable program that compares how the choice of the first-step construction (bootstrapping) affects the long-term numerical trajectory when using the time-reversible position Verlet integrator to propagate a one-dimensional classical harmonic oscillator. Consider a point mass of mass $m$ moving in the potential $V(x) = \\tfrac{1}{2} k x^{2}$, so that the acceleration is $a(x) = -\\tfrac{k}{m} x$. The exact angular frequency is $\\omega = \\sqrt{\\tfrac{k}{m}}$, and for initial conditions $x(0)=x_{0}$ and $v(0)=v_{0}$, the exact solution is\n$$\nx_{\\mathrm{exact}}(t) = x_{0} \\cos(\\omega t) + \\frac{v_{0}}{\\omega} \\sin(\\omega t),\n\\qquad\nv_{\\mathrm{exact}}(t) = -x_{0}\\,\\omega \\sin(\\omega t) + v_{0} \\cos(\\omega t).\n$$\nAll angles must be treated in radians. All physical quantities must be expressed using the International System of Units (SI): positions in meters, velocities in meters per second, mass in kilograms, stiffness in newtons per meter, and time in seconds. The mechanical energy at time $t$ is\n$$\nE(t) = \\tfrac{1}{2} m\\, v(t)^{2} + \\tfrac{1}{2} k\\, x(t)^{2}.\n$$\nUse the position Verlet recurrence for discrete times $t_{n} = n\\,\\Delta t$ with fixed time step $\\Delta t$:\n$$\nx_{n+1} = 2\\,x_{n} - x_{n-1} + a(x_{n})\\,(\\Delta t)^{2}, \\quad \\text{where } a(x_{n}) = -\\frac{k}{m}\\,x_{n}.\n$$\nThis update requires a first step $x_{1}$ given $x_{0}$ and $v_{0}$. Compare the following two first-step constructions:\n- Euler bootstrap: $x_{1}^{\\mathrm{E}} = x_{0} + v_{0}\\,\\Delta t$.\n- Second-order Taylor bootstrap: $x_{1}^{\\mathrm{T}} = x_{0} + v_{0}\\,\\Delta t + \\tfrac{1}{2}\\,a(x_{0})\\,(\\Delta t)^{2}$.\n\nFor a given parameter set, simulate for $N$ steps to time $T = N\\,\\Delta t$ using each bootstrap, and compute the following two dimensionless diagnostics for each bootstrap:\n- Final relative position error, defined as\n$$\n\\varepsilon_{x} = \\frac{\\left|x_{N} - x_{\\mathrm{exact}}(T)\\right|}{A}, \\quad \\text{where } A = \\sqrt{x_{0}^{2} + \\left(\\frac{v_{0}}{\\omega}\\right)^{2}}.\n$$\n- Maximum relative energy deviation over the trajectory, defined as\n$$\n\\varepsilon_{E}^{\\max} = \\max_{1 \\le n \\le N-1} \\frac{\\left|E_{n} - E_{0}\\right|}{E_{0}},\n$$\nwhere $E_{0} = \\tfrac{1}{2} m\\, v_{0}^{2} + \\tfrac{1}{2} k\\, x_{0}^{2}$ and $E_{n} = \\tfrac{1}{2} m\\, v_{n}^{2} + \\tfrac{1}{2} k\\, x_{n}^{2}$ with $v_{n}$ obtained by the centered finite difference $v_{n} = \\dfrac{x_{n+1} - x_{n-1}}{2\\,\\Delta t}$ for $1 \\le n \\le N-1$. If $E_{0} = 0$, define $\\varepsilon_{E}^{\\max} = 0$.\n\nYour program must implement this setup and produce results for the following test suite of parameter sets, each expressed in the International System of Units (SI):\n- Test set A (happy path): $m = 1$, $k = 1$, $x_{0} = 1$, $v_{0} = 0$, $\\Delta t = 0.1$, $N = 10000$.\n- Test set B (near-stability edge for the discrete scheme): $m = 1$, $k = 25$, $x_{0} = 1$, $v_{0} = 0.5$, $\\Delta t = 0.39$, $N = 8000$.\n- Test set C (purely kinetic start): $m = 1$, $k = 1$, $x_{0} = 0$, $v_{0} = 1$, $\\Delta t = 0.05$, $N = 20000$.\n\nFor each test set, output a list of four numbers in the following order:\n$[\\varepsilon_{x}^{\\mathrm{E}}, \\varepsilon_{x}^{\\mathrm{T}}, \\varepsilon_{E,\\mathrm{E}}^{\\max}, \\varepsilon_{E,\\mathrm{T}}^{\\max}]$, where superscripts $\\mathrm{E}$ and $\\mathrm{T}$ refer to the Euler and Taylor bootstraps, respectively. The final program output must be a single line containing the results for all three test sets as a comma-separated list of these lists, with no spaces, for example:\n$[[a_{1},a_{2},a_{3},a_{4}],[b_{1},b_{2},b_{3},b_{4}],[c_{1},c_{2},c_{3},c_{4}]]$.\nEach number must be printed as a decimal with at least $6$ significant digits. All reported diagnostics are dimensionless and must be printed as decimals (do not use a percentage sign).", "solution": "The problem statement is subjected to validation and is found to be scientifically sound, well-posed, and free of ambiguity. It constitutes a standard exercise in computational physics, suitable for rigorous analysis. We shall now proceed with the solution.\n\nThe problem requires a comparative study of two bootstrapping methods for the position Verlet integrator, applied to the one-dimensional harmonic oscillator. The system is defined by a mass $m$ in a potential $V(x) = \\frac{1}{2} k x^2$, leading to the equation of motion $\\ddot{x} = -\\frac{k}{m} x$. The dynamics are characterized by the natural angular frequency $\\omega = \\sqrt{k/m}$.\n\nThe position Verlet algorithm is a second-order, time-reversible, and symplectic integrator. Its recurrence relation for discrete time steps $t_n = n \\Delta t$ is given by\n$$\nx_{n+1} = 2 x_n - x_{n-1} + a(x_n) (\\Delta t)^2,\n$$\nwhere $x_n \\approx x(t_n)$ and $a(x_n) = -\\frac{k}{m} x_n$ is the acceleration at position $x_n$. This is a three-term recurrence, meaning the computation of the position at step $n+1$, $x_{n+1}$, requires the positions from two previous steps, $x_n$ and $x_{n-1}$. To initiate the integration, we are given the initial state $(x_0, v_0)$ at $t=0$. From this, we have $x_0$, but we need a value for $x_1$ to begin the iterative process for $n \\ge 1$. The choice of $x_1$ is the bootstrapping problem.\n\nThe problem proposes two methods for determining $x_1$:\n\n1.  **Euler Bootstrap**: $x_1^{\\mathrm{E}} = x_0 + v_0 \\Delta t$. This is a first-order forward Euler step for the position.\n2.  **Second-Order Taylor Bootstrap**: $x_1^{\\mathrm{T}} = x_0 + v_0 \\Delta t + \\frac{1}{2} a(x_0) (\\Delta t)^2$. This corresponds to a second-order Taylor series expansion of the position $x(\\Delta t)$.\n\nThe theoretical foundation of the Verlet integrator lies in the sum of two Taylor series expansions around time $t_n$:\n$$\nx(t_n + \\Delta t) = x(t_n) + \\dot{x}(t_n)\\Delta t + \\frac{1}{2}\\ddot{x}(t_n)(\\Delta t)^2 + \\frac{1}{6}\\dddot{x}(t_n)(\\Delta t)^3 + \\mathcal{O}((\\Delta t)^4)\n$$\n$$\nx(t_n - \\Delta t) = x(t_n) - \\dot{x}(t_n)\\Delta t + \\frac{1}{2}\\ddot{x}(t_n)(\\Delta t)^2 - \\frac{1}{6}\\dddot{x}(t_n)(\\Delta t)^3 + \\mathcal{O}((\\Delta t)^4)\n$$\nSumming these two equations eliminates the odd-powered derivative terms, yielding:\n$$\nx(t_n + \\Delta t) + x(t_n - \\Delta t) = 2x(t_n) + \\ddot{x}(t_n)(\\Delta t)^2 + \\mathcal{O}((\\Delta t)^4)\n$$\nIdentifying $x_{n \\pm 1}$ with $x(t_n \\pm \\Delta t)$ and $a(x_n)$ with $\\ddot{x}(t_n)$, we recover the position Verlet formula. The local truncation error of the method is $\\mathcal{O}((\\Delta t)^4)$, leading to a global error of $\\mathcal{O}((\\Delta t)^2)$.\n\nCrucially, the derivation reveals that the method's accuracy and desirable properties, such as time-reversibility, depend on this symmetric structure. The bootstrapping step must be chosen with care to not disrupt this structure.\n\nThe second-order Taylor bootstrap for $x_1$,\n$$\nx_1^\\mathrm{T} = x_0 + v_0 \\Delta t + \\frac{1}{2}a(x_0)(\\Delta t)^2,\n$$\nis directly derived from the Taylor expansion for $x(\\Delta t)$ up to second order. This is consistent with the order of the Verlet integrator itself.\n\nIn contrast, the Euler bootstrap,\n$$\nx_1^\\mathrm{E} = x_0 + v_0 \\Delta t,\n$$\nis only a first-order approximation. It introduces an error of magnitude $\\frac{1}{2}a(x_0)(\\Delta t)^2$ in the very first step. This initial error, being of lower order than what is consistent with the integrator, propagates through the simulation and is expected to degrade the overall accuracy and, most notably, the long-term energy conservation. The Verlet method is valued for its excellent long-term energy stability (the numerical energy does not drift systematically but oscillates around the true value). An inconsistent bootstrap damages this property.\n\nFor the special case where the initial position is at the equilibrium point, $x_0=0$, the initial acceleration is also zero, $a(x_0)=0$. In this scenario, the term $\\frac{1}{2} a(x_0) (\\Delta t)^2$ vanishes, and the two bootstrap methods yield identical results: $x_1^{\\mathrm{E}} = x_1^{\\mathrm{T}} = v_0 \\Delta t$. Consequently, for Test Set C where $x_0=0$, the numerical trajectories and all derived diagnostics must be identical for both bootstraps.\n\nThe implementation will proceed as follows: a general function will be constructed to propagate the trajectory for $N$ steps using the position Verlet algorithm. This function will accept the physical parameters ($m, k, x_0, v_0, \\Delta t, N$) and a flag to select the bootstrap method. For each of the three test sets, this simulation will be run twice, once for each bootstrap method.\n\nAfter each simulation run, which generates the position trajectory $\\{x_n\\}_{n=0}^N$, the required diagnostics are computed.\n- The final relative position error, $\\varepsilon_x$, requires computation of the exact position at time $T = N \\Delta t$, given by $x_{\\mathrm{exact}}(T) = x_0 \\cos(\\omega T) + \\frac{v_0}{\\omega} \\sin(\\omega T)$, and the amplitude $A = \\sqrt{x_0^2 + (v_0/\\omega)^2}$. The error is then $\\varepsilon_x = |x_N - x_{\\mathrm{exact}}(T)| / A$.\n- The maximum relative energy deviation, $\\varepsilon_E^{\\max}$, requires computing the numerical velocity $v_n$ and energy $E_n$ for $n \\in [1, N-1]$. The velocity is computed using the centered difference formula $v_n = \\frac{x_{n+1} - x_{n-1}}{2 \\Delta t}$, which is consistent with the time-reversibility of the Verlet scheme. The energy at each step is $E_n = \\frac{1}{2}mv_n^2 + \\frac{1}{2}kx_n^2$. The diagnostic is then found by taking the maximum of $|E_n - E_0|/E_0$ over the trajectory, where $E_0 = \\frac{1}{2}mv_0^2 + \\frac{1}{2}kx_0^2$.\n\nThe results from these computations for each test set will be formatted and presented as specified. The expected outcome is that the Taylor bootstrap will consistently yield smaller errors, particularly for the energy deviation, except in cases like Test Set C where the methods are mathematically equivalent.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n\n    # Test cases are defined as tuples: (m, k, x0, v0, dt, N)\n    test_cases = [\n        # Test set A (happy path)\n        (1.0, 1.0, 1.0, 0.0, 0.1, 10000),\n        # Test set B (near-stability edge)\n        (1.0, 25.0, 1.0, 0.5, 0.39, 8000),\n        # Test set C (purely kinetic start)\n        (1.0, 1.0, 0.0, 1.0, 0.05, 20000),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        m, k, x0, v0, dt, N = params\n        \n        # Run with Euler bootstrap\n        x_euler = propagate_trajectory(m, k, x0, v0, dt, N, 'euler')\n        eps_x_euler, eps_E_max_euler = compute_diagnostics(m, k, x0, v0, dt, N, x_euler)\n\n        # Run with Taylor bootstrap\n        x_taylor = propagate_trajectory(m, k, x0, v0, dt, N, 'taylor')\n        eps_x_taylor, eps_E_max_taylor = compute_diagnostics(m, k, x0, v0, dt, N, x_taylor)\n        \n        case_results = [eps_x_euler, eps_x_taylor, eps_E_max_euler, eps_E_max_taylor]\n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    formatted_case_results = []\n    for res_list in all_results:\n        # Use scientific notation to ensure at least 6 significant digits\n        formatted_list = [f\"{v:.15e}\" for v in res_list]\n        formatted_case_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output = f\"[{','.join(formatted_case_results)}]\"\n    print(final_output)\n\ndef propagate_trajectory(m, k, x0, v0, dt, N, bootstrap_method):\n    \"\"\"\n    Generates a trajectory using the position Verlet integrator.\n\n    Args:\n        m (float): Mass.\n        k (float): Spring constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        dt (float): Time step.\n        N (int): Number of steps.\n        bootstrap_method (str): 'euler' or 'taylor'.\n\n    Returns:\n        np.array: Array of positions [x_0, x_1, ..., x_N].\n    \"\"\"\n    x = np.zeros(N + 1)\n    x[0] = x0\n    \n    # Acceleration function\n    accel_factor = -k / m\n    def a(pos):\n        return accel_factor * pos\n\n    # First step (bootstrapping)\n    if bootstrap_method == 'euler':\n        x[1] = x0 + v0 * dt\n    elif bootstrap_method == 'taylor':\n        a0 = a(x0)\n        x[1] = x0 + v0 * dt + 0.5 * a0 * dt**2\n    else:\n        raise ValueError(\"Invalid bootstrap method specified.\")\n\n    # Main integration loop\n    dt_sq = dt**2\n    for n in range(1, N):\n        x[n+1] = 2 * x[n] - x[n-1] + a(x[n]) * dt_sq\n        \n    return x\n\ndef compute_diagnostics(m, k, x0, v0, dt, N, x_trajectory):\n    \"\"\"\n    Computes final position error and max energy deviation.\n\n    Args:\n        m (float): Mass.\n        k (float): Spring constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        dt (float): Time step.\n        N (int): Number of steps.\n        x_trajectory (np.array): Position trajectory.\n\n    Returns:\n        tuple: (eps_x, eps_E_max)\n    \"\"\"\n    omega = np.sqrt(k / m)\n\n    # 1. Final relative position error (eps_x)\n    T = N * dt\n    x_exact_T = x0 * np.cos(omega * T) + (v0 / omega) * np.sin(omega * T)\n    \n    amp_sq_term_v = v0 / omega\n    amplitude = np.sqrt(x0**2 + amp_sq_term_v**2)\n    \n    x_N = x_trajectory[N]\n    \n    if amplitude == 0.0:\n        # Trivial case: x0=0, v0=0. System is static.\n        eps_x = 0.0\n    else:\n        eps_x = np.abs(x_N - x_exact_T) / amplitude\n\n    # 2. Maximum relative energy deviation (eps_E_max)\n    E0 = 0.5 * m * v0**2 + 0.5 * k * x0**2\n    \n    if E0 == 0.0:\n        return eps_x, 0.0\n\n    max_rel_E_dev = 0.0\n    # Loop from n=1 to N-1\n    for n in range(1, N):\n        # Centered difference for velocity v_n\n        v_n = (x_trajectory[n+1] - x_trajectory[n-1]) / (2 * dt)\n        \n        # Energy E_n\n        E_n = 0.5 * m * v_n**2 + 0.5 * k * x_trajectory[n]**2\n        \n        rel_E_dev = np.abs(E_n - E0) / E0\n        if rel_E_dev > max_rel_E_dev:\n            max_rel_E_dev = rel_E_dev\n            \n    eps_E_max = max_rel_E_dev\n    \n    return eps_x, eps_E_max\n\nsolve()\n\n```", "id": "2446800"}, {"introduction": "We can construct even more powerful integrators by composing simpler ones, allowing us to achieve higher orders of accuracy while retaining the essential properties of time-reversibility and symplecticity. This advanced practice first guides you through building a fourth-order integrator from a second-order one. It then challenges you to numerically test the property of time-reversibility itself [@problem_id:2446743], revealing how the symmetric structure of these methods leads to remarkable cancellation of round-off errors, a subtle but profound feature critical for high-precision, reversible computations.", "problem": "Implement a time-reversible integrator for a one-dimensional Hamiltonian system and verify its numerical reversibility properties by direct computation. Consider a particle of mass $m = 1$ moving in the potential $V(x) = \\tfrac{1}{2} x^2 + \\tfrac{\\lambda}{4} x^4$, so that the Hamiltonian is $H(x,p) = \\tfrac{1}{2} p^2 + V(x)$ with canonical equations $\\dot{x} = \\partial H / \\partial p$ and $\\dot{p} = - \\partial H / \\partial x$. The force is $F(x) = - \\mathrm{d}V/\\mathrm{d}x = - x - \\lambda x^3$. Start from the fundamental flows generated by the kinetic energy $T(p) = \\tfrac{1}{2} p^2$ and the potential energy $V(x)$:\n- The exact flow of $T$ for time $h$ is the drift $\\Phi_T(h): (x,p) \\mapsto (x + h p, p)$.\n- The exact flow of $V$ for time $h$ is the kick $\\Phi_V(h): (x,p) \\mapsto (x, p + h F(x))$.\n\nConstruct a fourth-order symplectic integrator $S_4(h)$ by composing the second-order symmetric Strang splitting (also known as the velocity-Verlet or leapfrog step) $S_2(h) = \\Phi_V(h/2) \\circ \\Phi_T(h) \\circ \\Phi_V(h/2)$ using a palindromic triple-jump composition. Do not assume or state the composition coefficients in advance; instead, derive them from the requirement that the local error operator cancel all terms up to order $h^4$ in the Baker–Campbell–Hausdorff expansion, starting from the fundamental flows $\\Phi_T$ and $\\Phi_V$. Once derived, implement $S_4(h)$ for the given system.\n\nThen, numerically assess time reversibility in finite-precision arithmetic by the following two experiments, each repeated for many cycles to amplify floating-point effects. For both experiments, start from an initial condition $(x_0,p_0)$ and repeat the indicated cycle exactly $K$ times, updating the state in place each time:\n\n1. Single inverse cycle: Apply a forward single step, then its naive backward step,\n   $$\n   (x,p) \\leftarrow S_4(h)(x,p), \\quad (x,p) \\leftarrow S_4(-h)(x,p).\n   $$\n   Denote the final state after $K$ such cycles by $(x^{\\mathrm{single}}, p^{\\mathrm{single}})$.\n\n2. Symmetric inverse cycle: Apply a symmetric palindromic sequence,\n   $$\n   (x,p) \\leftarrow S_4(h/2)(x,p), \\quad (x,p) \\leftarrow S_4(-h)(x,p), \\quad (x,p) \\leftarrow S_4(h/2)(x,p).\n   $$\n   Denote the final state after $K$ such cycles by $(x^{\\mathrm{sym}}, p^{\\mathrm{sym}})$.\n\nFor each experiment, compute the relative phase-space error\n$$\n\\varepsilon_{\\mathrm{single}} = \\frac{\\sqrt{\\left(x^{\\mathrm{single}} - x_0\\right)^2 + \\left(p^{\\mathrm{single}} - p_0\\right)^2}}{\\sqrt{x_0^2 + p_0^2}}, \\qquad\n\\varepsilon_{\\mathrm{sym}} = \\frac{\\sqrt{\\left(x^{\\mathrm{sym}} - x_0\\right)^2 + \\left(p^{\\mathrm{sym}} - p_0\\right)^2}}{\\sqrt{x_0^2 + p_0^2}}.\n$$\nNo physical units are required in the output because $\\varepsilon_{\\mathrm{single}}$ and $\\varepsilon_{\\mathrm{sym}}$ are dimensionless by construction. Use real arithmetic in double precision as provided by a standard numerical library.\n\nYour program must implement the derived $S_4(h)$ and produce quantitative results for the following test suite. Each test case specifies $(\\lambda, h, K, x_0, p_0)$:\n- Case $1$: $\\lambda = 1.0$, $h = 0.3$, $K = 5000$, $x_0 = 1.2$, $p_0 = -0.7$.\n- Case $2$: $\\lambda = 0.0$, $h = 0.9$, $K = 5000$, $x_0 = -1.0$, $p_0 = 0.3$.\n- Case $3$: $\\lambda = 10.0$, $h = 0.05$, $K = 5000$, $x_0 = 0.5$, $p_0 = 0.0$.\n\nFor each case, compute and report the triple of floats $[\\varepsilon_{\\mathrm{single}}, \\varepsilon_{\\mathrm{sym}}, \\rho]$, where $\\rho = \\varepsilon_{\\mathrm{single}} / \\varepsilon_{\\mathrm{sym}}$ (if the denominator is zero, define $\\rho$ to be a large sentinel such as $10^{16}$). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of the cases, for example, $[[e_{1s}, e_{1y}, r_1],[e_{2s}, e_{2y}, r_2],[e_{3s}, e_{3y}, r_3]]$, where each $e_{js}$, $e_{jy}$, and $r_j$ is a float. The answers are thus fully quantifiable and machine-checkable.", "solution": "The user's problem is first subjected to critical validation.\n\n### Step 1: Extract Givens\n- **System**: One-dimensional Hamiltonian system.\n- **Mass**: $m = 1$.\n- **Potential Energy**: $V(x) = \\tfrac{1}{2} x^2 + \\tfrac{\\lambda}{4} x^4$.\n- **Kinetic Energy**: $T(p) = \\tfrac{1}{2} p^2$.\n- **Hamiltonian**: $H(x,p) = T(p) + V(x) = \\tfrac{1}{2} p^2 + \\tfrac{1}{2} x^2 + \\tfrac{\\lambda}{4} x^4$.\n- **Force**: $F(x) = - \\mathrm{d}V/\\mathrm{d}x = -x - \\lambda x^3$.\n- **Fundamental Flows**:\n    - Drift $\\Phi_T(h): (x,p) \\mapsto (x + h p, p)$.\n    - Kick $\\Phi_V(h): (x,p) \\mapsto (x, p + h F(x))$.\n- **Second-Order Integrator**: Strang splitting $S_2(h) = \\Phi_V(h/2) \\circ \\Phi_T(h) \\circ \\Phi_V(h/2)$.\n- **Fourth-Order Integrator**: To be constructed as $S_4(h)$ via a palindromic triple-jump composition of $S_2(h)$. The coefficients are to be derived.\n- **Numerical Experiments**:\n    1.  **Single inverse cycle**: $(x,p) \\leftarrow S_4(-h)(S_4(h)(x,p))$ repeated $K$ times.\n    2.  **Symmetric inverse cycle**: $(x,p) \\leftarrow S_4(h/2)(S_4(-h)(S_4(h/2)(x,p)))$ repeated $K$ times.\n- **Error Metric**: Relative phase-space error $\\varepsilon = \\frac{\\sqrt{\\left(x_{\\text{final}} - x_0\\right)^2 + \\left(p_{\\text{final}} - p_0\\right)^2}}{\\sqrt{x_0^2 + p_0^2}}$.\n- **Output**: For each test case, the triple $[\\varepsilon_{\\mathrm{single}}, \\varepsilon_{\\mathrm{sym}}, \\rho]$, where $\\rho = \\varepsilon_{\\mathrm{single}} / \\varepsilon_{\\mathrm{sym}}$. If $\\varepsilon_{\\mathrm{sym}} = 0$, $\\rho = 10^{16}$.\n- **Test Cases**:\n    - Case 1: $(\\lambda, h, K, x_0, p_0) = (1.0, 0.3, 5000, 1.2, -0.7)$.\n    - Case 2: $(\\lambda, h, K, x_0, p_0) = (0.0, 0.9, 5000, -1.0, 0.3)$.\n    - Case 3: $(\\lambda, h, K, x_0, p_0) = (10.0, 0.05, 5000, 0.5, 0.0)$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is rooted in classical mechanics (Hamiltonian dynamics) and computational physics (symplectic integrators, Baker-Campbell-Hausdorff formula). All concepts are standard and well-established. It is scientifically valid.\n- **Well-Posed**: The problem provides all necessary information: the system, the base integrator, the composition method, and the numerical experiments. The derivation of coefficients is a standard procedure, leading to a unique solution. The numerical tests are clearly defined. The problem is well-posed.\n- **Objective**: The problem is stated in precise mathematical and algorithmic terms, free of subjective language.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n---\n\n### Principle-Based Design of the Solution\n\n#### 1. Derivation of the Fourth-Order Integrator Coefficients\nThe total evolution of a Hamiltonian system $H = T + V$ is governed by the operator $\\exp(h L_H)$, where $L_H = L_T + L_V$ is the sum of the Lie operators for the kinetic and potential parts. A numerical integrator approximates this evolution operator.\n\nThe provided second-order integrator, the Strang splitting, is given by:\n$$S_2(h) = \\exp\\left(\\frac{h}{2}L_V\\right) \\exp(h L_T) \\exp\\left(\\frac{h}{2}L_V\\right)$$\nThis is a symmetric method, which implies that its effective evolution operator contains only even powers of the time step $h$ in the modified Hamiltonian. Using the symmetric Baker-Campbell-Hausdorff (BCH) formula, the operator for $S_2(h)$ can be expanded as:\n$$S_2(h) = \\exp\\left(h(L_T+L_V) + h^3 C_3 + O(h^5)\\right)$$\nwhere $C_3$ is the leading error term operator:\n$$C_3 = \\frac{1}{12}[L_T, [L_T, L_V]] + \\frac{1}{24}[L_V, [L_V, L_T]]$$\nThe presence of the $h^3$ term indicates that the local error is of order $O(h^3)$, and thus the global error is of order $O(h^2)$.\n\nTo construct a fourth-order integrator, we use a symmetric composition of the second-order integrator $S_2(h)$:\n$$S_4(h) = S_2(c_1 h) \\circ S_2(c_2 h) \\circ S_2(c_1 h)$$\nThe coefficients $c_1, c_2$ must satisfy two conditions. First, the total time step must be $h$:\n$$c_1 h + c_2 h + c_1 h = h \\implies 2c_1 + c_2 = 1$$\nSecond, the $O(h^3)$ error term from the composition must vanish. The operator for the composite step $S_4(h)$ is approximately the exponential of the sum of the operators for each sub-step:\n$$S_4(h) \\approx \\exp\\left( (2c_1+c_2)h(L_T+L_V) + (2c_1^3+c_2^3)h^3 C_3 + O(h^5) \\right)$$\nTo eliminate the $O(h^3)$ error term, its coefficient must be zero:\n$$2c_1^3 + c_2^3 = 0$$\nWe solve this system of equations for $c_1$ and $c_2$. Substituting $c_2 = 1 - 2c_1$ into the second equation gives:\n$$2c_1^3 + (1 - 2c_1)^3 = 0$$\n$$2c_1^3 + (1 - 6c_1 + 12c_1^2 - 8c_1^3) = 0$$\n$$-6c_1^3 + 12c_1^2 - 6c_1 + 1 = 0 \\implies 6c_1^3 - 12c_1^2 + 6c_1 - 1 = 0$$\nThis cubic equation has one real root, which can be found to be:\n$$c_1 = \\frac{1}{2 - 2^{1/3}}$$\nThe corresponding value for $c_2$ is:\n$$c_2 = 1 - 2c_1 = 1 - \\frac{2}{2 - 2^{1/3}} = \\frac{2 - 2^{1/3} - 2}{2 - 2^{1/3}} = \\frac{-2^{1/3}}{2 - 2^{1/3}}$$\nWith these coefficients, the integrator $S_4(h)$ is fourth-order accurate.\n\n#### 2. Algorithm Implementation\nThe integrator $S_4(h)$ is implemented by composing the velocity-Verlet step $S_2(h)$. The operations are as follows:\n$S_2(\\Delta t)$:\n1. Update momentum (kick): $p \\leftarrow p + F(x) \\frac{\\Delta t}{2}$\n2. Update position (drift): $x \\leftarrow x + p \\Delta t$\n3. Update momentum (kick): $p \\leftarrow p + F(x) \\frac{\\Delta t}{2}$\n\n$S_4(h)$:\n1. Perform $S_2(c_1 h)$.\n2. Perform $S_2(c_2 h)$.\n3. Perform $S_2(c_1 h)$.\n\n#### 3. Time Reversibility Experiments\nA numerical method $\\Psi(h)$ is time-reversible (or symmetric) if its inverse is identical to a step with negative time, i.e., $\\Psi(h)^{-1} = \\Psi(-h)$. In exact arithmetic, this implies $\\Psi(-h) \\circ \\Psi(h) = \\mathrm{Id}$, the identity map. In finite-precision arithmetic, this identity does not hold exactly due to floating-point round-off errors.\nThe two experiments are designed to show how the structure of the reversal operation affects error accumulation.\n\n1.  **Single Inverse Cycle**: The sequence of operations is $(S_4(-h) \\circ S_4(h))$. The sequence of floating-point operations is not palindromic, and round-off errors are expected to accumulate over many cycles.\n\n2.  **Symmetric Inverse Cycle**: The sequence is $S_4(h/2) \\circ S_4(-h) \\circ S_4(h/2)$. This composition is explicitly palindromic. Because the underlying integrator $S_4(h)$ is itself symmetric, this composed sequence of floating-point operations possesses a high degree of symmetry, leading to significant cancellation of round-off errors.\n\nIt is expected that the error $\\varepsilon_{\\mathrm{sym}}$ from the symmetric cycle will be several orders of magnitude smaller than the error $\\varepsilon_{\\mathrm{single}}$ from the single inverse cycle, resulting in a large ratio $\\rho$. This numerically demonstrates a key benefit of using symmetric compositions for operations that should theoretically be the identity.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a fourth-order symplectic integrator and verifies its numerical\n    time-reversibility properties as per the problem description.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (lambda, h, K, x0, p0)\n    test_cases = [\n        (1.0, 0.3, 5000, 1.2, -0.7),\n        (0.0, 0.9, 5000, -1.0, 0.3),\n        (10.0, 0.05, 5000, 0.5, 0.0),\n    ]\n\n    # Pre-calculate the fourth-order composition coefficients.\n    # c1 = 1 / (2 - 2^(1/3))\n    # c2 = 1 - 2*c1 = -2^(1/3) / (2 - 2^(1/3))\n    cbrt2 = np.cbrt(2.0)\n    c1 = 1.0 / (2.0 - cbrt2)\n    c2 = 1.0 - 2.0 * c1\n\n    def force(x, lam):\n        \"\"\"Calculates the force F(x) = -dV/dx.\"\"\"\n        return -x - lam * x**3\n\n    def s2_step(x, p, dt, lam):\n        \"\"\"\n        Performs a single step of the second-order Strang splitting\n        (velocity-Verlet) integrator, S_2(dt).\n        \"\"\"\n        # First kick (half step)\n        p_half = p + force(x, lam) * dt / 2.0\n        # Full drift\n        x_new = x + p_half * dt\n        # Second kick (half step)\n        p_new = p_half + force(x_new, lam) * dt / 2.0\n        return x_new, p_new\n\n    def s4_step(x, p, h, lam):\n        \"\"\"\n        Performs a single step of the fourth-order symplectic integrator, S_4(h),\n        constructed via a triple-jump composition of S_2.\n        \"\"\"\n        # S4(h) = S2(c1*h) o S2(c2*h) o S2(c1*h)\n        x, p = s2_step(x, p, c1 * h, lam)\n        x, p = s2_step(x, p, c2 * h, lam)\n        x, p = s2_step(x, p, c1 * h, lam)\n        return x, p\n\n    results = []\n    for case in test_cases:\n        lam, h, K, x0, p0 = case\n        norm0 = np.sqrt(x0**2 + p0**2)\n\n        # Experiment 1: Single inverse cycle\n        x, p = x0, p0\n        for _ in range(K):\n            x, p = s4_step(x, p, h, lam)\n            x, p = s4_step(x, p, -h, lam)\n        \n        x_single, p_single = x, p\n        error_single = np.sqrt((x_single - x0)**2 + (p_single - p0)**2)\n        eps_single = error_single / norm0 if norm0 != 0 else error_single\n\n        # Experiment 2: Symmetric inverse cycle\n        x, p = x0, p0\n        for _ in range(K):\n            x, p = s4_step(x, p, h / 2.0, lam)\n            x, p = s4_step(x, p, -h, lam)\n            x, p = s4_step(x, p, h / 2.0, lam)\n\n        x_sym, p_sym = x, p\n        error_sym = np.sqrt((x_sym - x0)**2 + (p_sym - p0)**2)\n        eps_sym = error_sym / norm0 if norm0 != 0 else error_sym\n\n        # Compute the ratio rho\n        if eps_sym == 0.0:\n            rho = 1.0e16\n        else:\n            rho = eps_single / eps_sym\n\n        results.append([eps_single, eps_sym, rho])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, with no spaces between elements.\n    # e.g., [[val1,val2,val3],[val4,val5,val6]]\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "2446743"}]}