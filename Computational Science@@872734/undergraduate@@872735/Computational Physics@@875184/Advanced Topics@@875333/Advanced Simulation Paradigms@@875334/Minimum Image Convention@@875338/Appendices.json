{"hands_on_practices": [{"introduction": "The first step in mastering any computational technique is to build a correct and robust implementation. This practice guides you through coding the Minimum Image Convention (MIC) for the most common scenario: a three-dimensional orthorhombic simulation box. By implementing the logic and testing it against several critical edge cases, you will solidify your understanding of how the MIC correctly calculates the shortest distance between particles in a periodic system [@problem_id:2458300]. This exercise forms the foundation for nearly all simulation codes that employ periodic boundary conditions.", "problem": "You are to write a complete, runnable program that demonstrates the effect of the minimum image convention for periodic boundary conditions in molecular dynamics (MD) simulations. The program must compute the Euclidean distance between two particles in an orthorhombic periodic simulation box in two ways: (1) the naive Euclidean distance that ignores periodicity, and (2) the Euclidean distance after applying the minimum image convention. Distances must be expressed in nanometers (nm) and reported rounded to exactly six decimal places.\n\nBackground and fundamental base: In molecular dynamics (MD) simulations with periodic boundary conditions (PBC), an infinite tiling of the finite simulation box is used to mimic bulk behavior. The physical distance between two particles is interpreted as the minimum distance between one particle and any periodic image of the other. The underlying geometric rule is derived from the definition of Euclidean distance and the translation symmetry of the lattice. For an orthorhombic box with side lengths $L_x$, $L_y$, and $L_z$, the minimum distance is obtained by selecting an integer number of box-length translations along each axis that minimizes the Euclidean norm of the displacement vector. Your program must implement this rule.\n\nYour task:\n- Define a function that, given two $3$-dimensional positions $\\mathbf{r}_i$ and $\\mathbf{r}_j$ in nanometers and box lengths $(L_x,L_y,L_z)$ in nanometers, returns two values:\n  1) the naive Euclidean distance $d_{\\text{naive}} = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert$ in nm,\n  2) the minimum image convention distance $d_{\\text{mic}}$ in nm, obtained by translating the displacement components by integer multiples of $(L_x,L_y,L_z)$ to minimize the norm.\n- Treat the box as orthorhombic and axis-aligned.\n- Positions may lie outside the primary box interval. Your implementation must still correctly compute $d_{\\text{mic}}$ using periodicity.\n- To make your implementation clear, also include within the program a multi-line pseudocode string (not printed) that outlines the minimum image convention logic you implemented.\n\nNumerical and unit requirements:\n- All distances must be in nanometers (nm).\n- Report distances rounded to exactly $6$ decimal places.\n\nTest suite:\nYour program must compute $[d_{\\text{naive}}, d_{\\text{mic}}]$ for each of the following $5$ test cases, in the stated order.\n\n1) Happy path, small separation well within the box:\n- Box: $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.5\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.5\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.7\\,\\text{nm},\\,1.2\\,\\text{nm},\\,1.6\\,\\text{nm}\\,)$\n\n2) Crossing a periodic boundary along one axis:\n- Box: $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.1\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.9\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n\n3) Anisotropic box and wrapping along multiple axes:\n- Box: $(L_x,L_y,L_z) = (\\,2.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,5.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,1.9\\,\\text{nm},\\,0.2\\,\\text{nm},\\,4.8\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.1\\,\\text{nm},\\,3.9\\,\\text{nm},\\,0.3\\,\\text{nm}\\,)$\n\n4) Exactly half-box separation along one axis (tie case):\n- Box: $(L_x,L_y,L_z) = (\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n\n5) Positions outside the primary box interval:\n- Box: $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm}\\,)$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of pairs enclosed in square brackets. Each pair corresponds to one test case in the specified order and must have the form $[d_{\\text{naive}},d_{\\text{mic}}]$, with both values rounded to exactly $6$ decimal places in nanometers. There must be no spaces in the output.\n- For example, the required overall format is like $[[a_1,b_1],[a_2,b_2],\\dots]$ where each $a_k$ and $b_k$ are floats in nanometers with exactly $6$ decimal places.", "solution": "The problem posed is a fundamental exercise in computational statistical mechanics, specifically concerning the implementation of periodic boundary conditions (PBC) in molecular dynamics (MD) simulations. The use of PBC is a standard and necessary technique to approximate the properties of a macroscopic system by simulating a small, finite number of particles. It mitigates the severe surface effects that would otherwise dominate the behavior of a small system. The core of this problem is the correct calculation of inter-particle distances, which is governed by the minimum image convention (MIC).\n\nThe problem is well-posed, scientifically grounded, and provides all necessary data for a unique and verifiable solution. We will proceed with a rigorous derivation and implementation.\n\nLet the orthorhombic simulation box be defined by a set of three orthogonal vectors corresponding to the side lengths, $\\mathbf{L} = (L_x, L_y, L_z)$. The position of two particles, $i$ and $j$, are given by vectors $\\mathbf{r}_i$ and $\\mathbf{r}_j$.\n\nFirst, we define the naive Euclidean distance, $d_{\\text{naive}}$. This is the standard distance in a non-periodic, three-dimensional Euclidean space. It is calculated from the norm of the displacement vector $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$.\n$$\nd_{\\text{naive}} = \\lVert \\Delta\\mathbf{r} \\rVert = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n$$\nwhere $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y, \\Delta z)$. This calculation ignores the periodic nature of the simulation box and treats the system as if it were isolated in a vacuum.\n\nSecond, we address the minimum image convention distance, $d_{\\text{mic}}$. In a periodic system, the simulation box is replicated infinitely in all directions. A particle at position $\\mathbf{r}$ has an infinite lattice of periodic images at positions $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$, where $n_x, n_y, n_z$ are any integers. The physical distance between particle $i$ and particle $j$ is the shortest distance between particle $i$ and *any* of the periodic images of particle $j$.\n\nMathematically, this is expressed as:\n$$\nd_{\\text{mic}} = \\min_{n_x, n_y, n_z \\in \\mathbb{Z}} \\left\\lVert (\\mathbf{r}_j - \\mathbf{r}_i) - (n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}) \\right\\rVert\n$$\nFor an orthorhombic box, the minimization of the norm can be performed independently for each Cartesian component. Let us consider the $x$-component of the displacement vector, $\\Delta x = x_j - x_i$. We must find an integer $n_x$ that minimizes $|\\Delta x - n_x L_x|$. This is achieved when $n_x$ is the integer nearest to the ratio $\\Delta x / L_x$. This is the \"nearest integer function,\" often denoted as $\\text{nint}(s)$ or implemented via `round(s)`.\n\nThe MIC-adjusted displacement component, $\\Delta x'$, is therefore:\n$$\n\\Delta x' = \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right)\n$$\nThis formula correctly \"wraps\" the displacement vector component into the interval $[-L_x/2, L_x/2]$. The same logic applies to the $y$ and $z$ components. The complete MIC-adjusted displacement vector, $\\Delta\\mathbf{r}'$, is then:\n$$\n\\Delta\\mathbf{r}' = \\left( \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right), \\Delta y - L_y \\cdot \\text{round}\\left(\\frac{\\Delta y}{L_y}\\right), \\Delta z - L_z \\cdot \\text{round}\\left(\\frac{\\Delta z}{L_z}\\right) \\right)\n$$\nThis vector operation is robust and correctly handles cases where particle coordinates may lie outside the primary simulation box, as only their relative displacement matters.\n\nThe minimum image distance, $d_{\\text{mic}}$, is the Euclidean norm of this adjusted displacement vector:\n$$\nd_{\\text{mic}} = \\lVert \\Delta\\mathbf{r}' \\rVert = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}\n$$\n\nThe provided test cases will be solved using this established methodology. The implementation will utilize the `numpy` library for efficient vector arithmetic. For each test case, we will compute $d_{\\text{naive}}$ and $d_{\\text{mic}}$ and report the results rounded to precisely $6$ decimal places as specified. The special case of a displacement of exactly half a box length, e.g., $\\Delta x = L_x/2$, is handled by the `round` function, which typically rounds to the nearest even integer (e.g., in `numpy`), but the resulting distance is uniquely $L_x/2$ regardless of the sign choice for the adjusted displacement. For $\\Delta x = L_x/2$, $\\Delta x' = L_x/2 - L_x \\cdot \\text{round}(0.5) = L_x/2 - L_x \\cdot 0 = L_x/2$. The magnitude is unambiguous.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating naive and minimum image convention (MIC)\n    distances for a set of test cases in a molecular dynamics context.\n    \"\"\"\n\n    # Per the problem specification, this multi-line string contains the\n    # pseudocode explaining the implemented MIC logic. It is not printed.\n    # noinspection PyUnusedLocal\n    MIC_PSEUDOCODE = \"\"\"\n    function calculate_minimum_image_distance(r_i, r_j, box_dims):\n        // r_i, r_j: 3D position vectors [x, y, z] of two particles in nm.\n        // box_dims: 3D vector of orthorhombic box lengths [L_x, L_y, L_z] in nm.\n\n        // 1. Calculate the raw displacement vector.\n        //    This is a simple vector subtraction.\n        delta_r = r_j - r_i\n\n        // 2. Apply the minimum image convention to each component of the displacement vector.\n        //    For an orthorhombic box, this can be done independently for each axis.\n        //    The principle is to find the closest periodic image by shifting the displacement\n        //    by an integer number of box lengths. This is mathematically equivalent to\n        //    finding the nearest integer multiple of the box length to subtract.\n        \n        //    Let dr_c be a component of delta_r (e.g., delta_x) and L_c be the\n        //    corresponding box length (e.g., L_x).\n        //    The scaled displacement is s = dr_c / L_c.\n        //    The nearest integer number of box lengths to shift by is n = round(s).\n        //    The MIC-adjusted displacement component is dr'_c = dr_c - n * L_c.\n\n        //    In vector notation, this is:\n        mic_delta_r = delta_r - box_dims * np.round(delta_r / box_dims)\n        \n        // 3. Calculate the Euclidean norm (length) of the MIC-adjusted displacement vector.\n        //    This is the final minimum image distance.\n        distance_mic = sqrt(mic_delta_r[0]^2 + mic_delta_r[1]^2 + mic_delta_r[2]^2)\n        \n        return distance_mic\n    \"\"\"\n\n    def compute_distances(r_i_tuple, r_j_tuple, box_dims_tuple):\n        \"\"\"\n        Calculates naive and MIC distances for a single pair of particles.\n        \n        Args:\n            r_i_tuple (tuple): Position of particle i.\n            r_j_tuple (tuple): Position of particle j.\n            box_dims_tuple (tuple): Orthorhombic box dimensions (Lx, Ly, Lz).\n        \n        Returns:\n            A list containing two floats: [d_naive, d_mic].\n        \"\"\"\n        r_i = np.array(r_i_tuple, dtype=float)\n        r_j = np.array(r_j_tuple, dtype=float)\n        box_dims = np.array(box_dims_tuple, dtype=float)\n\n        # 1. Naive Euclidean distance\n        delta_r_naive = r_j - r_i\n        d_naive = np.linalg.norm(delta_r_naive)\n\n        # 2. Minimum Image Convention (MIC) distance\n        # The logic delta_r - L * round(delta_r / L) correctly finds the\n        # shortest vector in a periodic lattice.\n        delta_r_mic = delta_r_naive - box_dims * np.round(delta_r_naive / box_dims)\n        d_mic = np.linalg.norm(delta_r_mic)\n        \n        return [d_naive, d_mic]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1) Happy path, small separation\n        {'r_i': (0.5, 1.0, 1.5), 'r_j': (0.7, 1.2, 1.6), 'box': (3.0, 3.0, 3.0)},\n        # 2) Crossing a periodic boundary\n        {'r_i': (0.1, 1.0, 1.0), 'r_j': (2.9, 1.0, 1.0), 'box': (3.0, 3.0, 3.0)},\n        # 3) Anisotropic box and multi-axis wrapping\n        {'r_i': (1.9, 0.2, 4.8), 'r_j': (0.1, 3.9, 0.3), 'box': (2.0, 4.0, 5.0)},\n        # 4) Exactly half-box separation\n        {'r_i': (0.0, 0.0, 0.0), 'r_j': (2.0, 0.0, 0.0), 'box': (4.0, 4.0, 4.0)},\n        # 5) Positions outside the primary box\n        {'r_i': (-0.1, -0.1, -0.1), 'r_j': (3.1, 3.1, 3.1), 'box': (3.0, 3.0, 3.0)},\n    ]\n\n    result_strings = []\n    for case in test_cases:\n        d_naive, d_mic = compute_distances(case['r_i'], case['r_j'], case['box'])\n        \n        # Format the numbers to exactly 6 decimal places and create the pair string.\n        # This ensures trailing zeros are included and meets the formatting requirement.\n        result_strings.append(f\"[{d_naive:.6f},{d_mic:.6f}]\")\n\n    # Final print statement in the exact required format: [[a1,b1],[a2,b2],...]\n    # without spaces between elements.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2458300"}, {"introduction": "With a working implementation of the MIC, we can now explore its deeper geometric implications. This thought experiment asks a simple but profound question: what is the maximum possible separation between any two particles according to the MIC within a cubic box? Answering this question reveals the fundamental shape and size of the primary interaction domain, known as the Wigner-Seitz cell, and provides the theoretical justification for setting the maximum cutoff radius for pair potentials in a simulation [@problem_id:2460029].", "problem": "In a molecular simulation employing Periodic Boundary Conditions (PBC) in a $3$-dimensional simple cubic simulation cell of side length $L$, the Minimum Image Convention (MIC) defines the distance between two particles at positions $\\mathbf{r}_{i}$ and $\\mathbf{r}_{j}$ as the Euclidean norm of the shortest vector connecting one particle to any periodic image of the other. Formally, the minimum image displacement is\n$$\n\\mathbf{d}_{\\text{MIC}} = \\operatorname*{arg\\,min}_{\\mathbf{n} \\in \\mathbb{Z}^{3}} \\left\\| \\left(\\mathbf{r}_{j} - \\mathbf{r}_{i}\\right) - L\\,\\mathbf{n} \\right\\|,\n$$\nand the corresponding minimum image distance is\n$$\nd_{\\text{MIC}} = \\left\\| \\mathbf{d}_{\\text{MIC}} \\right\\|.\n$$\nAssume each coordinate of $\\mathbf{r}_{i}$ and $\\mathbf{r}_{j}$ lies in the interval $[0,L)$. Over all possible choices of $\\mathbf{r}_{i}$ and $\\mathbf{r}_{j}$ in the cell, what is the maximum possible value of $d_{\\text{MIC}}$? Express your final answer as a closed-form analytic expression in terms of $L$. No numerical rounding is required.", "solution": "The problem statement is first subjected to validation.\n\nStep 1: Extract Givens\n- The system is a molecular simulation in a $3$-dimensional simple cubic simulation cell.\n- The side length of the cell is $L$.\n- The simulation employs Periodic Boundary Conditions (PBC).\n- Distances are calculated using the Minimum Image Convention (MIC).\n- The minimum image displacement is defined as $\\mathbf{d}_{\\text{MIC}} = \\operatorname*{arg\\,min}_{\\mathbf{n} \\in \\mathbb{Z}^{3}} \\left\\| \\left(\\mathbf{r}_{j} - \\mathbf{r}_{i}\\right) - L\\,\\mathbf{n} \\right\\|$.\n- The minimum image distance is $d_{\\text{MIC}} = \\left\\| \\mathbf{d}_{\\text{MIC}} \\right\\|$.\n- Particle position vectors $\\mathbf{r}_{i}$ and $\\mathbf{r}_{j}$ have coordinates in the interval $[0,L)$.\n- The objective is to find the maximum possible value of $d_{\\text{MIC}}$ over all possible choices of $\\mathbf{r}_{i}$ and $\\mathbf{r}_{j}$.\n\nStep 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It describes a standard and fundamental concept in computational statistical mechanics and condensed matter physics. The definitions are precise and mathematically rigorous. There are no contradictions, missing information, or pseudoscientific claims. The problem is a straightforward mathematical optimization problem based on the geometry of periodic space.\n\nStep 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\nThe task is to find the maximum value of the minimum image distance, $d_{\\text{MIC}}$, between any two particles in a cubic cell of side length $L$. Let the position vectors of the two particles be $\\mathbf{r}_{i} = (x_i, y_i, z_i)$ and $\\mathbf{r}_{j} = (x_j, y_j, z_j)$. The components of these vectors lie in the interval $[0, L)$.\n\nThe displacement vector between the two particles is $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$. Its components, $\\Delta x = x_j - x_i$, $\\Delta y = y_j - y_i$, and $\\Delta z = z_j - z_i$, each lie in the interval $(-L, L)$.\n\nThe Minimum Image Convention (MIC) seeks the shortest vector connecting particle $i$ to any periodic image of particle $j$. The positions of the images of particle $j$ are given by $\\mathbf{r}_j + L\\mathbf{n}$, where $\\mathbf{n} = (n_x, n_y, n_z)$ is a vector of integers. The displacement from particle $i$ to an image of particle $j$ is $(\\mathbf{r}_j - \\mathbf{r}_i) + L\\mathbf{n} = \\Delta\\mathbf{r} + L\\mathbf{n}$. The MIC finds the vector of this form with the minimum Euclidean norm.\n\nThis procedure can be analyzed component by component. For the $x$-component, we seek an integer $n_x$ that minimizes $|\\Delta x - n_x L|$. Since $\\Delta x \\in (-L, L)$, the possible integers for $n_x$ that can minimize this expression are $-1$, $0$, or $1$. The resulting minimum image displacement component, $d_{\\text{MIC},x} = \\Delta x - n_x L$, will lie in the interval $[-L/2, L/2]$. The same logic applies to the $y$ and $z$ components.\n\nThus, the minimum image displacement vector, $\\mathbf{d}_{\\text{MIC}} = (d_{\\text{MIC},x}, d_{\\text{MIC},y}, d_{\\text{MIC},z})$, is a vector whose components are all constrained to the interval $[-L/2, L/2]$. Geometrically, the set of all possible vectors $\\mathbf{d}_{\\text{MIC}}$ forms a cube in $\\mathbb{R}^3$ centered at the origin, with vertices at $(\\pm L/2, \\pm L/2, \\pm L/2)$.\n\nWe are asked to find the maximum possible value of the norm of this vector, $d_{\\text{MIC}} = \\|\\mathbf{d}_{\\text{MIC}}\\|$. The problem is thus reduced to finding the point within this cube that is farthest from the origin.\n$$\n\\max d_{\\text{MIC}} = \\max \\sqrt{d_{\\text{MIC},x}^2 + d_{\\text{MIC},y}^2 + d_{\\text{MIC},z}^2}\n$$\nsubject to the constraints\n$$\nd_{\\text{MIC},x} \\in [-L/2, L/2]\n$$\n$$\nd_{\\text{MIC},y} \\in [-L/2, L/2]\n$$\n$$\nd_{\\text{MIC},z} \\in [-L/2, L/2]\n$$\nMaximizing the norm is equivalent to maximizing its square, $d_{\\text{MIC}}^2 = d_{\\text{MIC},x}^2 + d_{\\text{MIC},y}^2 + d_{\\text{MIC},z}^2$. The function $f(d_x, d_y, d_z) = d_x^2 + d_y^2 + d_z^2$ is maximized over a closed, bounded box (a cube) when the absolute values of its variables are maximized. The maximum value for $|d_{\\text{MIC},k}|$ for each component $k \\in \\{x,y,z\\}$ is $L/2$.\n\nThis maximum is attained at the vertices of the cube, for instance, at the point $(L/2, L/2, L/2)$. We must confirm that such a displacement vector is physically achievable. Consider two particles at $\\mathbf{r}_i = (0,0,0)$ and $\\mathbf{r}_j = (L/2, L/2, L/2)$. Both positions are valid as their coordinates are in $[0,L)$. The displacement is $\\Delta\\mathbf{r} = (L/2, L/2, L/2)$. For each component $\\Delta r_k = L/2$, the minimum distance to an image is $|L/2 - n_k L|$. The minimum is achieved for $n_k=0$ and $n_k=1$, giving a distance of $L/2$. The corresponding displacement vectors are $L/2$ and $-L/2$. Thus, a displacement vector with components of magnitude $L/2$ is possible. For example, if we simply choose $n_x=n_y=n_z=0$, we get $\\mathbf{d}_{\\text{MIC}} = (L/2, L/2, L/2)$.\n\nThe maximum squared distance is then:\n$$\n(d_{\\text{MIC}}^2)_{\\max} = \\left(\\frac{L}{2}\\right)^2 + \\left(\\frac{L}{2}\\right)^2 + \\left(\\frac{L}{2}\\right)^2 = 3 \\frac{L^2}{4}\n$$\nTaking the square root gives the maximum distance:\n$$\n(d_{\\text{MIC}})_{\\max} = \\sqrt{3 \\frac{L^2}{4}} = \\frac{\\sqrt{3}}{2}L\n$$\nThis distance corresponds to half the length of the main space diagonal of the cubic simulation cell. Any particle in the cell is closer to the central particle (or one of its images) than this distance. This value is critical in simulations as it defines the maximum cutoff radius for pair potentials that is consistent with the minimum image convention in a cubic cell.", "answer": "$$\n\\boxed{\\frac{\\sqrt{3}}{2}L}\n$$", "id": "2460029"}, {"introduction": "While orthogonal boxes are simple to conceptualize, many advanced simulations—especially of crystalline solids or systems under anisotropic pressure—utilize non-orthogonal, or triclinic, simulation cells. In this more general geometry, a simple component-wise application of the MIC is no longer sufficient. This capstone practice challenges you to implement the universal algorithm for triclinic cells, which involves a change of basis into fractional coordinates [@problem_id:2414062]. Mastering this technique equips you with a powerful and general tool applicable to any simulation cell shape.", "problem": "You are asked to implement the Minimum Image Convention (MIC) for a general triclinic (non-orthogonal) periodic simulation box. The MIC defines, for any pair of points, the unique representative of their displacement in the central periodic image of the simulation cell. The simulation box is specified by a full-rank lattice matrix $H \\in \\mathbb{R}^{3 \\times 3}$ whose columns are the three Bravais lattice vectors $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$ in Cartesian coordinates. For any two points with Cartesian position vectors $\\mathbf{r}_i, \\mathbf{r}_j \\in \\mathbb{R}^3$, the raw displacement is $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$. Under periodic boundary conditions, periodic images differ by lattice translations $H \\mathbf{n}$ with $\\mathbf{n} \\in \\mathbb{Z}^3$. The MIC seeks the displacement $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ that lies in the central image of the simulation cell, obtained by a suitable integer lattice translation.\n\nStart from the fundamental definition of periodic boundary conditions: two Cartesian position vectors $\\mathbf{r}$ and $\\mathbf{r}'$ represent the same physical point if and only if $\\mathbf{r}' = \\mathbf{r} + H \\mathbf{n}$ for some $\\mathbf{n} \\in \\mathbb{Z}^3$. Use this to derive a numerically stable and general algorithm to compute $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ for a triclinic box by working in fractional coordinates $\\mathbf{s} = H^{-1} \\Delta \\mathbf{r}$ and reducing $\\mathbf{s}$ into a central parallelepiped of fractional space. Explicitly state how half-integer ties are handled when reducing fractional components, and justify your choice so that the reduced fractional components each lie in a half-open interval of length $1$.\n\nYour program must implement the derived algorithm and apply it to the following test suite. In each case, $H$ is given by its columns and the positions $\\mathbf{r}_i$ and $\\mathbf{r}_j$ are given in Cartesian coordinates. Your code must compute, for each case, the MIC displacement vector $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ in Cartesian coordinates and its Euclidean norm $\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2$.\n\nTest suite (each matrix and vector is in Cartesian components):\n\n- Case $1$ (orthogonal cube):\n  - $H = \\begin{bmatrix} 10  0  0 \\\\ 0  10  0 \\\\ 0  0  10 \\end{bmatrix}$,\n  - $\\mathbf{r}_i = (1, 2, 3)$,\n  - $\\mathbf{r}_j = (9, 9, 9)$.\n- Case $2$ (triclinic shear I):\n  - $\\mathbf{a} = (10, 0, 0)$, $\\mathbf{b} = (2, 8, 0)$, $\\mathbf{c} = (1, 1, 6)$,\n  - $H = \\begin{bmatrix} 10  2  1 \\\\ 0  8  1 \\\\ 0  0  6 \\end{bmatrix}$,\n  - $\\mathbf{r}_i = (1, 1, 1)$,\n  - $\\mathbf{r}_j = (9, 7, 5)$.\n- Case $3$ (boundary tie-handling):\n  - $\\mathbf{a} = (8, 0, 0)$, $\\mathbf{b} = (1, 7, 0)$, $\\mathbf{c} = (2, 1, 9)$,\n  - $H = \\begin{bmatrix} 8  1  2 \\\\ 0  7  1 \\\\ 0  0  9 \\end{bmatrix}$,\n  - Let $\\mathbf{s} = (0.5, -0.5, 0.5)$ and define $\\mathbf{r} = H \\mathbf{s}$,\n  - $\\mathbf{r}_i = (0, 0, 0)$,\n  - $\\mathbf{r}_j = \\mathbf{r}$.\n- Case $4$ (triclinic shear II):\n  - $\\mathbf{a} = (5, 0, 0)$, $\\mathbf{b} = (4, 5, 0)$, $\\mathbf{c} = (3, 2, 5)$,\n  - $H = \\begin{bmatrix} 5  4  3 \\\\ 0  5  2 \\\\ 0  0  5 \\end{bmatrix}$,\n  - $\\mathbf{r}_i = (4.9, 0.1, 0.1)$,\n  - $\\mathbf{r}_j = (0.2, 4.9, 0.2)$.\n\nFinal output specification:\n- For each case, output a list of four real numbers: the three Cartesian components of $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ followed by its Euclidean norm $\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2$.\n- Round each real number to $6$ decimal places.\n- Your program should produce a single line of output containing the results for the four cases as a Python-style list of lists, for example: $[\\,[x_1,y_1,z_1,n_1],[x_2,y_2,z_2,n_2],[x_3,y_3,z_3,n_3],[x_4,y_4,z_4,n_4]\\,]$.", "solution": "The problem presented is to formulate and implement a general algorithm for computing the minimum image convention (MIC) displacement vector in a triclinic periodic system. This is a fundamental task in computational physics, particularly in molecular dynamics and Monte Carlo simulations. The problem statement is scientifically sound, well-posed, and provides sufficient information for a unique solution.\n\nFirst, we establish the theoretical foundation. A triclinic simulation cell is defined by three linearly independent lattice vectors, $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$, which form the columns of a lattice matrix $H = [\\mathbf{a}, \\mathbf{b}, \\mathbf{c}] \\in \\mathbb{R}^{3 \\times 3}$. Due to periodic boundary conditions, a point with Cartesian position vector $\\mathbf{r}$ has an infinite number of equivalent periodic images given by $\\mathbf{r}' = \\mathbf{r} + H \\mathbf{n}$, where $\\mathbf{n} = (n_1, n_2, n_3)^T$ is any vector of integers, $\\mathbf{n} \\in \\mathbb{Z}^3$.\n\nThe displacement vector from a point $\\mathbf{r}_i$ to a point $\\mathbf{r}_j$ is also not unique. The raw displacement is $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$. Any equivalent displacement is given by $\\Delta \\mathbf{r}' = \\mathbf{r}_j' - \\mathbf{r}_i = (\\mathbf{r}_j + H\\mathbf{n}) - \\mathbf{r}_i = \\Delta \\mathbf{r} + H\\mathbf{n}$ for some $\\mathbf{n} \\in \\mathbb{Z}^3$. The minimum image convention seeks to find the unique representative of this set of vectors, denoted $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$, that is \"closest\" to the origin. In a general triclinic cell, this means finding the vector that lies within the central Wigner-Seitz cell, which is the locus of points in space closer to the origin lattice point than to any other lattice point.\n\nDirectly minimizing the norm $\\|\\Delta \\mathbf{r} + H\\mathbf{n}\\|_2$ over all $\\mathbf{n} \\in \\mathbb{Z}^3$ is computationally complex. A more robust and efficient method, as suggested by the problem, is to operate in fractional (or scaled) coordinates. A Cartesian vector $\\mathbf{v}$ is transformed into fractional coordinates $\\mathbf{s}$ by the linear transformation $\\mathbf{s} = H^{-1} \\mathbf{v}$. The components of $\\mathbf{s}$ express $\\mathbf{v}$ as a linear combination of the lattice vectors.\n\nLet us apply this to the displacement vector:\n$$\n\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = H^{-1} (\\mathbf{r}_j - \\mathbf{r}_i)\n$$\nAn arbitrary periodic image of the displacement, $\\Delta \\mathbf{r} - H\\mathbf{n}$, is transformed to fractional coordinates as:\n$$\nH^{-1} (\\Delta \\mathbf{r} - H\\mathbf{n}) = H^{-1} \\Delta \\mathbf{r} - H^{-1}H\\mathbf{n} = \\mathbf{s} - \\mathbf{n}\n$$\nThis demonstrates that moving between periodic images in Cartesian space is equivalent to shifting the fractional coordinate vector by an integer vector. The problem is now reduced to finding an integer vector $\\mathbf{n}$ such that the components of the reduced fractional vector, $\\mathbf{s}_{\\mathrm{MIC}} = \\mathbf{s} - \\mathbf{n}$, lie within a central unit cell in fractional space. The standard choice for this central cell is the range $[-0.5, 0.5)$ for each component.\n\nTo map an arbitrary fractional coordinate component $s_k$ to its central image $s_{k, \\mathrm{MIC}}$, we must find an integer $n_k$ such that $s_{k, \\mathrm{MIC}} = s_k - n_k \\in [-0.5, 0.5)$. The choice of a half-open interval, such as $[-0.5, 0.5)$, is crucial to ensure a unique mapping and resolve ambiguity when a component is exactly on a boundary (a half-integer). An integer $n_k$ that satisfies this is the nearest integer to $s_k$. This can be computed algorithmically. A standard and numerically stable method to find $n_k$ and perform the reduction is:\n$$\ns_{k, \\mathrm{MIC}} = s_k - \\lfloor s_k + 0.5 \\rfloor\n$$\nThis operation correctly handles the tie-breaking for half-integer values. For example, if $s_k = 2.5$, then $s_{k, \\mathrm{MIC}} = 2.5 - \\lfloor 2.5 + 0.5 \\rfloor = 2.5 - \\lfloor 3.0 \\rfloor = 2.5 - 3 = -0.5$. If $s_k = -1.5$, then $s_{k, \\mathrm{MIC}} = -1.5 - \\lfloor -1.5 + 0.5 \\rfloor = -1.5 - \\lfloor -1.0 \\rfloor = -1.5 - (-1) = -0.5$. This consistently maps the upper boundary $0.5$ to the lower boundary $-0.5$, ensuring that the reduced fractional components $s_{k, \\mathrm{MIC}}$ all lie in the half-open interval $[-0.5, 0.5)$. This choice is justified by its computational simplicity and its guarantee of a unique result for any floating-point input.\n\nThe complete algorithm is as follows:\n$1$. Calculate the raw displacement vector in Cartesian coordinates: $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$.\n$2$. Convert $\\Delta \\mathbf{r}$ to fractional coordinates: $\\mathbf{s} = H^{-1} \\Delta \\mathbf{r}$. This requires computing the inverse of the lattice matrix $H$.\n$3$. Apply the minimum image condition in fractional space by reducing each component $s_k$ to the interval $[-0.5, 0.5)$: $\\mathbf{s}_{\\mathrm{MIC}} = \\mathbf{s} - \\lfloor \\mathbf{s} + 0.5 \\rfloor$, where the operations are performed element-wise.\n$4$. Convert the reduced fractional vector back to Cartesian coordinates: $\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}}$.\n$5$. Compute the Euclidean norm of the final vector: $\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(\\Delta \\mathbf{r}_{\\mathrm{MIC}}) \\cdot (\\Delta \\mathbf{r}_{\\mathrm{MIC}})}$.\n\nThis algorithm is universally applicable to any periodic cell described by a full-rank matrix $H$, including orthogonal, and general triclinic forms. We now apply this to the specified test cases.\n\nCase $1$: $H = \\begin{bmatrix} 10  0  0 \\\\ 0  10  0 \\\\ 0  0  10 \\end{bmatrix}$, $\\mathbf{r}_i = (1, 2, 3)$, $\\mathbf{r}_j = (9, 9, 9)$.\n$\\Delta \\mathbf{r} = (8, 7, 6)$.\n$H^{-1} = \\begin{bmatrix} 0.1  0  0 \\\\ 0  0.1  0 \\\\ 0  0  0.1 \\end{bmatrix}$.\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = (0.8, 0.7, 0.6)$.\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.8 - 1, 0.7 - 1, 0.6 - 1) = (-0.2, -0.3, -0.4)$.\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-2, -3, -4)$.\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-2)^2+(-3)^2+(-4)^2} = \\sqrt{29} \\approx 5.385165$.\n\nCase $2$: $H = \\begin{bmatrix} 10  2  1 \\\\ 0  8  1 \\\\ 0  0  6 \\end{bmatrix}$, $\\mathbf{r}_i = (1, 1, 1)$, $\\mathbf{r}_j = (9, 7, 5)$.\n$\\Delta \\mathbf{r} = (8, 6, 4)$.\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} \\approx (0.6, 0.666667, 0.666667)$.\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.6 - 1, 0.666667 - 1, 0.666667 - 1) = (-0.4, -0.333333, -0.333333)$.\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-5, -3, -2)$.\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-5)^2+(-3)^2+(-2)^2} = \\sqrt{38} \\approx 6.164414$.\n\nCase $3$: $H = \\begin{bmatrix} 8  1  2 \\\\ 0  7  1 \\\\ 0  0  9 \\end{bmatrix}$, $\\mathbf{r}_i = (0, 0, 0)$, $\\mathbf{r}_j = H(0.5, -0.5, 0.5)^T$.\n$\\Delta \\mathbf{r} = \\mathbf{r}_j$.\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = H^{-1} \\mathbf{r}_j = (0.5, -0.5, 0.5)$.\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.5 - \\lfloor 1.0 \\rfloor, -0.5 - \\lfloor 0.0 \\rfloor, 0.5 - \\lfloor 1.0 \\rfloor) = (-0.5, -0.5, -0.5)$.\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-5.5, -4.0, -4.5)$.\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-5.5)^2+(-4)^2+(-4.5)^2} = \\sqrt{66.5} \\approx 8.154753$.\n\nCase $4$: $H = \\begin{bmatrix} 5  4  3 \\\\ 0  5  2 \\\\ 0  0  5 \\end{bmatrix}$, $\\mathbf{r}_i = (4.9, 0.1, 0.1)$, $\\mathbf{r}_j = (0.2, 4.9, 0.2)$.\n$\\Delta \\mathbf{r} = (-4.7, 4.8, 0.1)$.\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} \\approx (-1.7136, 0.952, 0.02)$.\n$\\mathbf{s}_{\\mathrm{MIC}} = (-1.7136 - \\lfloor -1.2136 \\rfloor, 0.952 - \\lfloor 1.452 \\rfloor, 0.02 - \\lfloor 0.52 \\rfloor) = (0.2864, -0.048, 0.02)$.\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (1.3, -0.2, 0.1)$.\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{1.3^2+(-0.2)^2+0.1^2} = \\sqrt{1.74} \\approx 1.319091$.\n\nThe implementation will follow this derived procedure.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Minimum Image Convention displacement for a series of test cases\n    in triclinic periodic boundary conditions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"H\": np.array([\n                [10.0, 0.0, 0.0],\n                [0.0, 10.0, 0.0],\n                [0.0, 0.0, 10.0]\n            ]),\n            \"r_i\": np.array([1.0, 2.0, 3.0]),\n            \"r_j\": np.array([9.0, 9.0, 9.0])\n        },\n        {\n            \"H\": np.array([\n                [10.0, 2.0, 1.0],\n                [0.0, 8.0, 1.0],\n                [0.0, 0.0, 6.0]\n            ]),\n            \"r_i\": np.array([1.0, 1.0, 1.0]),\n            \"r_j\": np.array([9.0, 7.0, 5.0])\n        },\n        {\n            \"H\": np.array([\n                [8.0, 1.0, 2.0],\n                [0.0, 7.0, 1.0],\n                [0.0, 0.0, 9.0]\n            ]),\n            \"r_i\": np.array([0.0, 0.0, 0.0]),\n            \"r_j\": np.dot(\n                np.array([\n                    [8.0, 1.0, 2.0],\n                    [0.0, 7.0, 1.0],\n                    [0.0, 0.0, 9.0]\n                ]),\n                np.array([0.5, -0.5, 0.5])\n            )\n        },\n        {\n            \"H\": np.array([\n                [5.0, 4.0, 3.0],\n                [0.0, 5.0, 2.0],\n                [0.0, 0.0, 5.0]\n            ]),\n            \"r_i\": np.array([4.9, 0.1, 0.1]),\n            \"r_j\": np.array([0.2, 4.9, 0.2])\n        }\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        H = case[\"H\"]\n        r_i = case[\"r_i\"]\n        r_j = case[\"r_j\"]\n\n        # Step 1: Calculate the raw displacement vector in Cartesian coordinates.\n        delta_r = r_j - r_i\n\n        # Step 2: Convert delta_r to fractional coordinates.\n        H_inv = np.linalg.inv(H)\n        s = H_inv @ delta_r\n\n        # Step 3: Apply the minimum image condition in fractional space.\n        # To find the central image, we subtract the nearest integer from each\n        # fractional coordinate. The expression `s - np.floor(s + 0.5)` achieves this\n        # by implementing a \"round half up\" logic for the integer part to subtract.\n        # This maps each component of `s` to the unique half-open interval [-0.5, 0.5).\n        s_mic = s - np.floor(s + 0.5)\n\n        # Step 4: Convert the reduced fractional vector back to Cartesian coordinates.\n        delta_r_mic = H @ s_mic\n\n        # Step 5: Compute the Euclidean norm of the final vector.\n        norm_mic = np.linalg.norm(delta_r_mic)\n\n        # Format the result for the final output string.\n        result_vector = [\n            delta_r_mic[0],\n            delta_r_mic[1],\n            delta_r_mic[2],\n            norm_mic\n        ]\n        \n        # Round each number to 6 decimal places and format as a string list.\n        formatted_vector = [f\"{val:.6f}\" for val in result_vector]\n        results_as_strings.append(f\"[{','.join(formatted_vector)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "2414062"}]}