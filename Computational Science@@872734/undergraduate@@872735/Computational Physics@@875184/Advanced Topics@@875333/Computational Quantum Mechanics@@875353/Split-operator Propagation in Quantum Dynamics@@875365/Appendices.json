{"hands_on_practices": [{"introduction": "This first exercise provides a direct, hands-on application of the spectral propagation method to its simplest case: a free particle. By evolving an initial Gaussian wavepacket in the absence of any potential, you will numerically observe the phenomenon of wavepacket spreading. More importantly, this practice [@problem_id:2452266] allows for a direct computational verification of one of the cornerstones of quantum theory, the Heisenberg Uncertainty Principle, by tracking the standard deviations of position and momentum over time.", "problem": "Consider a one-dimensional, nonrelativistic, spinless quantum particle of mass $m$ confined to a periodic interval of length $L$ in Hartree atomic units (so that $\\hbar=1$ and $m=1$). The dynamics are governed by the time-dependent Schrödinger equation\n$$\ni \\,\\frac{\\partial}{\\partial t}\\,\\psi(x,t) \\;=\\; \\hat{H}\\,\\psi(x,t), \\qquad \\hat{H} \\;=\\; \\frac{\\hat{p}^2}{2 m}, \\qquad \\hat{p} \\;=\\; -\\,i\\,\\frac{\\partial}{\\partial x},\n$$\nwith periodic boundary conditions on the interval $x\\in[-L/2,L/2)$. The initial wavefunction is the normalized Gaussian wavepacket\n$$\n\\psi(x,0) \\;=\\; \\left(\\frac{1}{2\\pi\\,\\sigma_x^2}\\right)^{1/4}\\,\\exp\\!\\left(-\\frac{(x-x_0)^2}{4\\,\\sigma_x^2}\\right)\\,\\exp\\!\\left(i\\,p_0\\,(x-x_0)\\right),\n$$\nwith position-space width parameter $\\sigma_x>0$, mean position $x_0$, and mean momentum $p_0$.\n\nFor each time $t$, define the expectation values and variances of position and momentum by\n$$\n\\langle x\\rangle_t \\;=\\; \\int_{-L/2}^{L/2} \\psi^*(x,t)\\,x\\,\\psi(x,t)\\,dx,\\quad\n\\langle x^2\\rangle_t \\;=\\; \\int_{-L/2}^{L/2} \\psi^*(x,t)\\,x^2\\,\\psi(x,t)\\,dx,\n$$\n$$\n\\langle p\\rangle_t \\;=\\; \\int_{-L/2}^{L/2} \\psi^*(x,t)\\,\\Big(-i\\,\\frac{\\partial}{\\partial x}\\Big)\\,\\psi(x,t)\\,dx,\\quad\n\\langle p^2\\rangle_t \\;=\\; \\int_{-L/2}^{L/2} \\psi^*(x,t)\\,\\Big(-\\frac{\\partial^2}{\\partial x^2}\\Big)\\,\\psi(x,t)\\,dx,\n$$\nand the associated standard deviations\n$$\n\\Delta x(t) \\;=\\; \\sqrt{\\langle x^2\\rangle_t - \\langle x\\rangle_t^2},\\qquad\n\\Delta p(t) \\;=\\; \\sqrt{\\langle p^2\\rangle_t - \\langle p\\rangle_t^2}.\n$$\nAll quantities are in atomic units; times must be treated in atomic time units, momenta in atomic momentum units, and lengths in Bohr radii. The Heisenberg uncertainty principle states that, for all $t$,\n$$\n\\Delta x(t)\\,\\Delta p(t) \\;\\ge\\; \\frac{1}{2}.\n$$\n\nTask: Evolve $\\psi(x,t)$ exactly according to the above Schrödinger equation on the periodic domain, using spatial discretization with $N$ grid points on $[-L/2,L/2)$, for the following test suite of parameter sets. For each parameter set, compute the list of values $\\{\\Delta x(t_k)\\,\\Delta p(t_k)\\}$ at the specified times $\\{t_k\\}$, then compute the minimum value $S=\\min_k \\Delta x(t_k)\\,\\Delta p(t_k)$ and compare it to $1/2$ with a numerical tolerance $\\tau=10^{-3}$. For each test case, return the boolean value $S \\ge 1/2 - \\tau$.\n\nUse the following test suite, where all numbers are in atomic units:\n- Case $1$: $L=100.0$, $N=4096$, $\\sigma_x=1.0$, $x_0=0.0$, $p_0=0.0$, times $t\\in\\{0.0,\\,1.0,\\,2.0,\\,5.0,\\,10.0\\}$.\n- Case $2$: $L=100.0$, $N=4096$, $\\sigma_x=0.2$, $x_0=0.0$, $p_0=0.0$, times $t\\in\\{0.0,\\,0.2,\\,0.5,\\,1.0,\\,2.0\\}$.\n- Case $3$: $L=100.0$, $N=4096$, $\\sigma_x=3.0$, $x_0=-10.0$, $p_0=2.0$, times $t\\in\\{0.0,\\,1.0,\\,5.0,\\,10.0,\\,20.0\\}$.\n- Case $4$: $L=100.0$, $N=4096$, $\\sigma_x=0.5$, $x_0=20.0$, $p_0=5.0$, times $t\\in\\{0.0,\\,0.5,\\,1.0,\\,2.0,\\,5.0\\}$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list of the boolean outcomes for Cases $1$ through $4$, enclosed in square brackets, with no spaces, for example, \"[True,False,True,True]\".", "solution": "The problem statement is parsed and validated.\n\nGivens:\nA one-dimensional, nonrelativistic, spinless quantum particle of mass $m=1$ in Hartree atomic units, where $\\hbar=1$. The particle is confined to a periodic interval of length $L$ defined by $x \\in [-L/2, L/2)$. The governing equation is the time-dependent Schrödinger equation (TDSE):\n$$\ni \\,\\frac{\\partial}{\\partial t}\\,\\psi(x,t) \\;=\\; \\hat{H}\\,\\psi(x,t)\n$$\nwith the free-particle Hamiltonian:\n$$\n\\hat{H} \\;=\\; \\frac{\\hat{p}^2}{2 m}, \\qquad \\hat{p} \\;=\\; -\\,i\\,\\frac{\\partial}{\\partial x}\n$$\nThe initial state at $t=0$ is a normalized Gaussian wavepacket:\n$$\n\\psi(x,0) \\;=\\; \\left(\\frac{1}{2\\pi\\,\\sigma_x^2}\\right)^{1/4}\\,\\exp\\!\\left(-\\frac{(x-x_0)^2}{4\\,\\sigma_x^2}\\right)\\,\\exp\\!\\left(i\\,p_0\\,(x-x_0)\\right)\n$$\nThe observables are defined by standard expectation value integrals over the domain $[-L/2, L/2)$. The standard deviations in position and momentum are $\\Delta x(t)$ and $\\Delta p(t)$, respectively. The task is to numerically evolve the system, compute the uncertainty product $\\Delta x(t_k)\\,\\Delta p(t_k)$ at specified times $t_k$, find the minimum value $S = \\min_k \\Delta x(t_k)\\,\\Delta p(t_k)$, and verify if $S \\ge 1/2 - \\tau$ for a tolerance $\\tau=10^{-3}$. Four test cases with specific parameters ($L, N, \\sigma_x, x_0, p_0, \\{t_k\\}$) are provided.\n\nValidation Verdict:\nThe problem is scientifically and mathematically sound. It describes a fundamental problem in quantum dynamics: the time evolution of a free particle. All concepts, equations, and parameters are well-defined and consistent with the principles of quantum mechanics. The request to \"evolve exactly... using spatial discretization\" is understood to mean the use of a spectral method, like the split-operator Fourier method, which is numerically exact for the discretized system in the case of a free particle. The problem is well-posed, objective, and computationally feasible. The initial Gaussian form is defined on an infinite domain, but for the given parameters, it is well-localized within the periodic box, making its use as an initial state on the periodic domain a valid approximation. We will proceed to the solution.\n\nPrinciple-Based Solution Design:\n\nThe solution to the time-dependent Schrödinger equation, $\\psi(x,t) = e^{-i\\hat{H}t}\\psi(x,0)$, can be efficiently computed using a spectral method in the basis of momentum eigenstates. The Hamiltonian $\\hat{H} = \\hat{p}^2/(2m)$ is diagonal in the momentum (Fourier) basis. The momentum operator's eigenfunctions on a periodic domain of length $L$ are the plane waves $\\phi_k(x) = \\frac{1}{\\sqrt{L}} e^{ikx}$, where the wavevectors $k$ are quantized as $k_n = 2\\pi n/L$ for integer $n$.\n\nThe action of the Hamiltonian on these basis states is simple multiplication: $\\hat{H} \\phi_k(x) = \\frac{k^2}{2m} \\phi_k(x)$. Consequently, the action of the time-evolution operator $e^{-i\\hat{H}t}$ is also a simple multiplication in this basis: $e^{-i\\hat{H}t} \\phi_k(x) = e^{-i\\frac{k^2}{2m}t} \\phi_k(x)$.\n\nThe numerical algorithm, known as the split-operator Fourier method, leverages this property via the Fast Fourier Transform (FFT), which efficiently transforms the wavefunction between the position and momentum representations.\n\nThe step-by-step procedure is as follows:\n\n1.  **Discretization and Initial State Preparation**:\n    The spatial domain $x \\in [-L/2, L/2)$ is discretized into $N$ grid points $x_j$ with spacing $\\Delta x = L/N$. The initial wavefunction $\\psi(x,0)$ is evaluated at these grid points. The given analytical form for $\\psi(x,0)$ is technically normalized on an infinite domain. For our finite, periodic domain, we must enforce normalization numerically on the grid:\n    $$\n    \\psi_j(0) = \\frac{\\phi_j}{\\sqrt{\\sum_{l=0}^{N-1} |\\phi_l|^2 \\Delta x}}\n    $$\n    where $\\phi_j$ is the unnormalized Gaussian wavepacket evaluated at $x_j$. This ensures that the initial state satisfies the probability conservation condition $\\int |\\psi|^2 dx \\approx \\sum_j |\\psi_j(0)|^2 \\Delta x = 1$.\n\n2.  **Time Evolution in Fourier Space**:\n    For each required time $t_k$, the wavefunction $\\psi(x, t_k)$ is computed from the initial state $\\psi(x, 0)$:\n    a.  The initial state is transformed to the momentum representation using the FFT: $\\tilde{\\psi}(k, 0) = \\mathcal{F}\\{\\psi(x, 0)\\}$. The corresponding momentum grid $k_n$ is determined by the spatial discretization via $k = 2\\pi \\cdot \\text{fftfreq}(N, \\Delta x)$.\n    b.  The state is evolved in momentum space by multiplying with the diagonal time-evolution operator:\n        $$\n        \\tilde{\\psi}(k, t_k) = \\tilde{\\psi}(k, 0) \\cdot e^{-i \\frac{k^2}{2m} t_k}\n        $$\n        Since we are using Hartree atomic units, $m=1$.\n    c.  The state is transformed back to the position representation using the inverse FFT: $\\psi(x, t_k) = \\mathcal{F}^{-1}\\{\\tilde{\\psi}(k, t_k)\\}$. The `numpy` FFT and IFFT functions are inverse pairs, ensuring that the norm of the state vector is preserved throughout the evolution.\n\n3.  **Calculation of Observables**:\n    For each evolved state $\\psi(x, t_k)$, we compute the required standard deviations $\\Delta x(t_k)$ and $\\Delta p(t_k)$.\n\n    a.  **Position Uncertainty $\\Delta x(t_k)$**: The expectation values $\\langle x \\rangle_{t_k}$ and $\\langle x^2 \\rangle_{t_k}$ are computed by numerical integration (summation over the grid points) as defined in the problem statement:\n        $$\n        \\langle x \\rangle_{t_k} \\approx \\sum_j x_j |\\psi_j(t_k)|^2 \\Delta x\n        $$\n        $$\n        \\langle x^2 \\rangle_{t_k} \\approx \\sum_j x_j^2 |\\psi_j(t_k)|^2 \\Delta x\n        $$\n        The position variance is $\\Delta x(t_k)^2 = \\langle x^2 \\rangle_{t_k} - \\langle x \\rangle_{t_k}^2$. Special care is taken with the definition of the position coordinate $x_j$ on the periodic domain, as this affects the expectation value calculation, particularly if the wavepacket approaches or crosses the boundaries at $x = \\pm L/2$.\n\n    b.  **Momentum Uncertainty $\\Delta p(t_k)$**: The momentum observables are most conveniently and accurately calculated in the momentum representation. For a free particle, the momentum distribution $|\\tilde{\\psi}(k, t)|^2$ is constant in time because the evolution operator is a pure phase factor. Therefore, $\\Delta p(t)$ is constant for all $t$. We can compute it once from the initial state $\\tilde{\\psi}(k, 0)$:\n        $$\n        \\langle p \\rangle \\approx \\frac{\\sum_n k_n |\\tilde{\\psi}_n(0)|^2}{\\sum_n |\\tilde{\\psi}_n(0)|^2}\n        $$\n        $$\n        \\langle p^2 \\rangle \\approx \\frac{\\sum_n k_n^2 |\\tilde{\\psi}_n(0)|^2}{\\sum_n |\\tilde{\\psi}_n(0)|^2}\n        $$\n        The momentum variance is $\\Delta p^2 = \\langle p^2 \\rangle - \\langle p \\rangle^2$. This calculation is robust as it computes the mean and variance directly from the momentum probability distribution.\n\n4.  **Verification Against Heisenberg Uncertainty Principle**:\n    For each test case, the list of uncertainty products $\\{\\Delta x(t_k)\\Delta p(t_k)\\}$ is generated. The minimum value, $S$, is found. The initial state is a minimum uncertainty wavepacket, for which $\\Delta x(0) \\Delta p(0) = 1/2$. For a free particle, $\\Delta p$ is constant while $\\Delta x$ increases with time (wavepacket spreading). Thus, the minimum uncertainty product must occur at $t=0$. The numerical simulation must confirm that $S \\ge 1/2 - \\tau$. A result of `True` for all cases is expected, as this is a numerical verification of the fundamental Heisenberg Uncertainty Principle.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum mechanics problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: L=100.0, N=4096, sigma_x=1.0, x0=0.0, p0=0.0, times\n        (100.0, 4096, 1.0, 0.0, 0.0, [0.0, 1.0, 2.0, 5.0, 10.0]),\n        # Case 2: L=100.0, N=4096, sigma_x=0.2, x0=0.0, p0=0.0, times\n        (100.0, 4096, 0.2, 0.0, 0.0, [0.0, 0.2, 0.5, 1.0, 2.0]),\n        # Case 3: L=100.0, N=4096, sigma_x=3.0, x0=-10.0, p0=2.0, times\n        (100.0, 4096, 3.0, -10.0, 2.0, [0.0, 1.0, 5.0, 10.0, 20.0]),\n        # Case 4: L=100.0, N=4096, sigma_x=0.5, x0=20.0, p0=5.0, times\n        (100.0, 4096, 0.5, 20.0, 5.0, [0.0, 0.5, 1.0, 2.0, 5.0]),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        results.append(run_simulation(*case_params))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(L, N, sigma_x, x0, p0, times):\n    \"\"\"\n    Performs the quantum simulation for a single parameter set.\n    \"\"\"\n    # Mass m=1 and h_bar=1 in Hartree atomic units\n    m = 1.0\n    h_bar = 1.0\n    \n    # 1. Discretization\n    # Spatial grid\n    dx = L / N\n    x = np.arange(N) * dx - L / 2.0\n\n    # Momentum grid\n    # fftfreq provides frequency f. Wavevector k = 2*pi*f. Momentum p = h_bar*k.\n    k = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # 2. Initial State Preparation\n    # Unnormalized initial wavepacket\n    psi0_unnormalized = np.exp(-((x - x0)**2) / (4.0 * sigma_x**2)) * \\\n                        np.exp(1j * p0 * (x - x0))\n\n    # Numerically normalize the state on the discrete grid\n    norm_factor = np.sqrt(np.sum(np.abs(psi0_unnormalized)**2) * dx)\n    psi0 = psi0_unnormalized / norm_factor\n\n    # 3. Calculate Momentum Uncertainty (constant for free particle)\n    psi0_k = np.fft.fft(psi0)\n    prob_k = np.abs(psi0_k)**2\n    k_norm = np.sum(prob_k)\n\n    # Expectation values for momentum\n    exp_p = np.sum(k * prob_k) / k_norm\n    exp_p2 = np.sum(k**2 * prob_k) / k_norm\n    \n    # Standard deviation of momentum\n    var_p = exp_p2 - exp_p**2\n    delta_p = np.sqrt(var_p)\n\n    uncertainty_products = []\n\n    # 4. Time Evolution and Observable Calculation\n    for t in times:\n        # Evolve in momentum space\n        time_evolution_operator = np.exp(-1j * (k**2) / (2.0 * m) * t)\n        psi_k_t = psi0_k * time_evolution_operator\n\n        # Transform back to position space\n        psi_t = np.fft.ifft(psi_k_t)\n        \n        # Calculate position uncertainty\n        prob_x = np.abs(psi_t)**2\n        \n        # Expectation values for position\n        # Normalization of psi_t is preserved by the unitary evolution\n        # so we can use the integral approximation sum(...)*dx directly.\n        # np.sum(prob_x)*dx should be 1.0\n        exp_x = np.sum(x * prob_x) * dx\n        exp_x2 = np.sum(x**2 * prob_x) * dx\n\n        # Standard deviation of position\n        var_x = exp_x2 - exp_x**2\n        delta_x = np.sqrt(var_x)\n\n        # Calculate and store the uncertainty product\n        uncertainty_products.append(delta_x * delta_p)\n\n    # 5. Final Verification\n    S = np.min(uncertainty_products)\n    tau = 1e-3\n    \n    # The Heisenberg Uncertainty Principle states delta_x * delta_p >= h_bar / 2\n    # With h_bar = 1, this is >= 0.5\n    return S >= (h_bar / 2.0 - tau)\n\nsolve()\n```", "id": "2452266"}, {"introduction": "Building on the free-particle propagator, this practice delves into the fundamental symmetries of the Schrödinger equation. You will computationally test the principle of Galilean invariance, which dictates how a quantum state's description changes when viewed from a moving reference frame. This exercise [@problem_id:2441280] is a powerful demonstration of how numerical methods can be used not just to solve equations, but to explore and confirm the deep, underlying structure of physical laws.", "problem": "Implement and use the split-operator propagation method to test the Galilean invariance of the time-dependent Schrödinger equation for a one-dimensional free particle. Start from the fundamental time-dependent Schrödinger equation in one spatial dimension, $$i\\hbar\\,\\frac{\\partial \\psi(x,t)}{\\partial t}=\\left[-\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2}+V(x,t)\\right]\\psi(x,t),$$ and from the definition of a Galilean boost between inertial frames, $$x' = x - vt,\\quad t'=t,$$ where $v$ is a constant relative velocity. You must derive, from first principles, the precise transformation that connects solutions between the unprimed and primed frames and state the condition(s) under which the Schrödinger dynamics is invariant in form. Then, implement a numerical experiment to verify this invariance.\n\nYou must proceed as follows.\n\n- Use the split-operator propagation method based on factorizing the time-evolution operator into kinetic and potential parts, and implement it spectrally via the Fast Fourier Transform (FFT). For the free particle, use $V(x,t)=0$.\n\n- Work in atomic units, i.e., set $\\hbar=1$ and $m=1$. All quantities are therefore dimensionless. Any phases must be treated in radians.\n\n- Discretize space on a uniform periodic grid with $N$ points over a domain of length $L$. Use $N=2048$ and $L=400$. Let the spatial grid be the $N$ equispaced points in $[-L/2,L/2)$.\n\n- Use a Gaussian wavepacket as the initial state in the unprimed (laboratory) frame, centered at position $x_0$ with mean momentum $p_0$ and spatial width $\\sigma$. Take $x_0=-50$, $p_0=2$, and $\\sigma=5$. Normalize the state so that the discrete approximation to $\\int |\\psi(x,0)|^2\\,dx$ equals $1$.\n\n- Evolve the state for a total time $T$ using a uniform time step $\\Delta t$. Use $T=10$ and $\\Delta t=0.1$.\n\n- For each test velocity $v$, perform two computations up to time $T$:\n  1. Propagate the initial state in the unprimed frame to obtain $\\psi(x,T)$. Then, transform this result into the primed frame at the same time using the correct transformation you derived from the Schrödinger equation and the Galilean boost $x' = x - vt$.\n  2. Construct the correctly boosted initial state in the primed frame at $t=0$ using your derived transformation, then propagate it to $t=T$ in the primed frame.\n\n- Quantify the discrepancy between the two primed-frame states at $t=T$ by computing the normalized root-mean-square error\n  $$\\varepsilon(v)=\\sqrt{\\frac{\\int | \\phi_{\\text{direct}}(x',T)-\\phi_{\\text{from-lab}}(x',T) |^2\\,dx'}{\\int |\\phi_{\\text{from-lab}}(x',T)|^2\\,dx'}}$$\n  using a consistent discrete approximation to the integral. The expected outcome, under correct invariance and numerics, is that $\\varepsilon(v)$ is very small.\n\nTest suite. Use the following velocities (in the same atomic units):\n- $v=0$ (baseline),\n- $v=0.5$ (moderate positive),\n- $v=-0.75$ (moderate negative),\n- $v=1.25$ (larger positive within resolution limits).\n\nYour program must produce a single line of output containing the four numerical values of $\\varepsilon(v)$ for the four velocities above, as a comma-separated list enclosed in square brackets, e.g., \"[$\\varepsilon(v_1)$,$\\varepsilon(v_2)$,$\\varepsilon(v_3)$,$\\varepsilon(v_4)$]\". The entries must be dimensionless real numbers. No other text should be printed. The numerical experiment must be implemented in a way that is fully deterministic and does not require any user input or external files.", "solution": "We begin from the one-dimensional time-dependent Schrödinger equation,\n$$i\\hbar\\,\\frac{\\partial \\psi(x,t)}{\\partial t}=\\left[-\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2}+V(x,t)\\right]\\psi(x,t).$$\nWe consider a Galilean boost to a primed frame moving with constant velocity $v$ relative to the unprimed (laboratory) frame, with coordinate relation $x'=x-vt$ and $t'=t$. We seek a transformation between wavefunctions such that if $\\psi(x,t)$ is a solution in the unprimed frame with a given potential, then $\\phi(x',t)$ defined by\n$$\\phi(x',t)=e^{i\\alpha(x',t)}\\psi(x'+vt,t)$$\nsatisfies the Schrödinger equation in the primed frame, ideally of the same form for the free particle case. We compute the derivatives using the chain rule. Define $x=x'+vt$ and suppress explicit functional dependencies for brevity. Then\n$$\\frac{\\partial \\phi}{\\partial t}=e^{i\\alpha}\\left(i\\frac{\\partial \\alpha}{\\partial t}\\psi+\\frac{\\partial \\psi}{\\partial t}+v\\frac{\\partial \\psi}{\\partial x}\\right),$$\n$$\\frac{\\partial \\phi}{\\partial x'}=e^{i\\alpha}\\left(i\\frac{\\partial \\alpha}{\\partial x'}\\psi+\\frac{\\partial \\psi}{\\partial x}\\right),\\quad\n\\frac{\\partial^2 \\phi}{\\partial x'^2}=e^{i\\alpha}\\left[(i\\frac{\\partial \\alpha}{\\partial x'})^2\\psi+i\\frac{\\partial^2 \\alpha}{\\partial x'^2}\\psi+2i\\frac{\\partial \\alpha}{\\partial x'}\\frac{\\partial \\psi}{\\partial x}+\\frac{\\partial^2 \\psi}{\\partial x^2}\\right].$$\nSubstitute into the primed Schrödinger equation for the free particle, $i\\hbar \\partial_t \\phi=-(\\hbar^2/2m)\\partial_{x'}^2\\phi$, use the unprimed free Schrödinger equation $i\\hbar \\partial_t \\psi=-(\\hbar^2/2m)\\partial_x^2\\psi$, and match coefficients of independent structures $\\psi$ and $\\partial_x \\psi$. This yields the conditions:\n$$\\frac{\\partial \\alpha}{\\partial x'}=-\\frac{mv}{\\hbar},\\qquad \\frac{\\partial \\alpha}{\\partial t}=-\\frac{mv^2}{2\\hbar}.$$\nIntegrating and discarding an irrelevant additive constant phase gives\n$$\\alpha(x',t)=-\\frac{mv}{\\hbar}x'-\\frac{mv^2}{2\\hbar}t.$$\nTherefore, for a free particle, the Galilean boost acts as\n$$\\phi(x',t)=\\exp\\left[-\\frac{i}{\\hbar}\\left(m v x'+\\frac{1}{2}m v^2 t\\right)\\right]\\psi(x'+vt,t),$$\nand this guarantees that $\\phi$ satisfies the free Schrödinger equation in the primed coordinates if $\\psi$ does so in the unprimed coordinates. At $t=0$ where $x'=x$, the initial state must transform as\n$$\\phi(x',0)=\\exp\\left(-\\frac{i}{\\hbar} m v x'\\right)\\psi(x',0),$$\nwhich changes the mean momentum by $-mv$ as expected for a Galilean boost.\n\nWe now design the numerical scheme. In atomic units, set $\\hbar=1$ and $m=1$. We use a periodic spatial domain of length $L$ discretized by $N$ uniform points, with spacing $\\Delta x=L/N$. The split-operator method is based on the second-order factorization\n$$e^{-i(T+V)\\Delta t}\\approx e^{-iV\\Delta t/2}\\,e^{-iT\\Delta t}\\,e^{-iV\\Delta t/2},$$\nwhere $T=\\hat{p}^2/(2m)$ and $V=V(\\hat{x},t)$ are kinetic and potential operators. For the free particle, $V=0$, and the propagator reduces exactly to\n$$\\psi(x,t+\\Delta t)=\\mathcal{F}^{-1}\\left[e^{-i\\frac{k^2}{2m}\\Delta t}\\,\\mathcal{F}\\{\\psi(x,t)\\}(k)\\right],$$\nwhere $\\mathcal{F}$ denotes the spatial Fourier transform, and $k$ is the wave number. Over a total time $T$, repeated application is equivalent to a single multiplication in Fourier space by $e^{-i\\frac{k^2}{2m}T}$.\n\nWe initialize a normalized Gaussian wavepacket\n$$\\psi(x,0)=\\mathcal{N}\\,\\exp\\left[-\\frac{(x-x_0)^2}{4\\sigma^2}\\right]\\exp\\left(i p_0 (x-x_0)\\right),$$\nwith $x_0=-50$, $p_0=2$, and $\\sigma=5$, and $\\mathcal{N}$ chosen so that the discrete approximation to $\\int |\\psi(x,0)|^2 dx$ equals $1$. The propagation in the unprimed frame gives $\\psi(x,T)$. To construct the primed-frame prediction from the unprimed evolution, we require $\\psi(x'+vt,T)$, i.e., the unprimed result evaluated at shifted coordinates. We compute this efficiently using the Fourier shift theorem: for any function $f(x)$,\n$$f(x+\\Delta)=\\mathcal{F}^{-1}\\left[e^{ik\\Delta}\\,\\mathcal{F}\\{f\\}(k)\\right].$$\nThus we obtain $\\psi(x'+vt,T)$ spectrally and multiply by the derived phase factor to produce\n$$\\phi_{\\text{from-lab}}(x',T)=\\exp\\left[-i\\left(m v x'+\\frac{1}{2}m v^2 T\\right)\\right]\\psi(x'+vT,T),$$\nwith $m=1$. Independently, we construct the boosted initial state\n$$\\phi(x',0)=\\exp(-i m v x')\\psi(x',0),$$\nand propagate it in the primed frame (which is identical to the unprimed propagation here because the free Hamiltonian is form-invariant). This yields $\\phi_{\\text{direct}}(x',T)$.\n\nWe quantify the discrepancy by the normalized root-mean-square error\n$$\\varepsilon(v)=\\sqrt{\\frac{\\int | \\phi_{\\text{direct}}(x',T)-\\phi_{\\text{from-lab}}(x',T) |^2\\,dx'}{\\int |\\phi_{\\text{from-lab}}(x',T)|^2\\,dx'}},$$\nwith discrete sums approximating the integrals, i.e., $\\int \\cdot\\,dx' \\approx \\Delta x \\sum \\cdot$. In exact arithmetic and continuum theory, $\\varepsilon(v)=0$ for the free particle. Numerically, using spectral propagation and spectral shifting on a sufficiently large grid with adequately short time to avoid wrap-around, $\\varepsilon(v)$ should be close to machine precision for all test velocities specified, namely $v=0$, $v=0.5$, $v=-0.75$, and $v=1.25$.\n\nAlgorithm summary:\n- Construct the spatial grid with $N=2048$ points over $[-L/2,L/2)$ with $L=400$, compute the Fourier wave numbers $k=2\\pi n/L$ for integer modes via the discrete FFT convention.\n- Build and normalize the initial Gaussian wavepacket with $x_0=-50$, $p_0=2$, and $\\sigma=5$.\n- Propagate in the unprimed frame to $T=10$ using the exact free-particle spectral propagator $e^{-i k^2 T/2}$.\n- For each test velocity $v\\in\\{0,0.5,-0.75,1.25\\}$:\n  - Compute $\\psi(x'+vT,T)$ using the Fourier shift theorem with $\\Delta=vT$.\n  - Form $\\phi_{\\text{from-lab}}(x',T)$ by multiplying by $\\exp\\left[-i\\left(v x'+\\frac{1}{2} v^2 T\\right)\\right]$ (with $m=1$).\n  - Form the boosted initial state $\\phi(x',0)=\\exp(-i v x')\\psi(x',0)$ and propagate it to obtain $\\phi_{\\text{direct}}(x',T)$.\n  - Compute $\\varepsilon(v)$ via the discrete normalized root-mean-square error.\n- Output the list $[\\varepsilon(0),\\varepsilon(0.5),\\varepsilon(-0.75),\\varepsilon(1.25)]$ as a single line.\n\nBecause all operations are spectral and the free-particle propagator is exact in this representation, the resulting errors should be extremely small, validating the Galilean invariance of the free Schrödinger equation when accompanied by the derived position-dependent and time-dependent phase transformation.", "answer": "```python\nimport numpy as np\n\ndef gaussian_wavepacket(x, x0, p0, sigma):\n    # Unnormalized minimal-uncertainty Gaussian with mean position x0 and momentum p0\n    psi = np.exp(-((x - x0) ** 2) / (4.0 * sigma ** 2)) * np.exp(1j * p0 * (x - x0))\n    return psi\n\ndef normalize(psi, dx):\n    norm = np.sqrt(np.sum(np.abs(psi) ** 2) * dx)\n    return psi / norm\n\ndef propagate_free_spectral(psi0, k, T, m=1.0):\n    # Exact free-particle spectral propagation over time T: multiply by exp(-i k^2 T / 2m) in k-space\n    psi_k0 = np.fft.fft(psi0)\n    phase = np.exp(-1j * (k ** 2) * T / (2.0 * m))\n    psi_kT = psi_k0 * phase\n    psi_T = np.fft.ifft(psi_kT)\n    return psi_T\n\ndef spectral_shift(psi, k, delta):\n    # Compute psi(x + delta) using the Fourier shift theorem\n    psi_k = np.fft.fft(psi)\n    shifted = np.fft.ifft(psi_k * np.exp(1j * k * delta))\n    return shifted\n\ndef boost_phase(x, v, t, m=1.0, hbar=1.0):\n    # Phase factor for Galilean boost: exp(-i (m v x + (1/2) m v^2 t) / hbar)\n    return np.exp(-1j * (m * v * x + 0.5 * m * v * v * t) / hbar)\n\ndef compute_error(phi_direct, phi_from_lab, dx):\n    num = np.sum(np.abs(phi_direct - phi_from_lab) ** 2) * dx\n    den = np.sum(np.abs(phi_from_lab) ** 2) * dx\n    return float(np.sqrt(num / den))\n\ndef solve():\n    # Parameters (atomic units): hbar = 1, m = 1\n    hbar = 1.0\n    m = 1.0\n    N = 2048\n    L = 400.0\n    dx = L / N\n    # Spatial grid centered at 0 with periodic boundary conditions\n    x = np.linspace(-L / 2.0, L / 2.0, N, endpoint=False)\n    # Fourier wavenumbers consistent with numpy FFT conventions\n    k = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # Initial Gaussian parameters\n    x0 = -50.0\n    p0 = 2.0\n    sigma = 5.0\n\n    # Time parameters\n    T = 10.0  # total propagation time\n\n    # Construct and normalize initial state in lab frame\n    psi0 = gaussian_wavepacket(x, x0, p0, sigma)\n    psi0 = normalize(psi0, dx)\n\n    # Propagate in lab frame to time T\n    psi_lab_T = propagate_free_spectral(psi0, k, T, m=m)\n\n    # Test velocities\n    test_cases = [0.0, 0.5, -0.75, 1.25]\n\n    results = []\n    for v in test_cases:\n        # Expected primed-frame state from lab propagation: phi_from_lab(x', T)\n        psi_shifted = spectral_shift(psi_lab_T, k, v * T)  # psi(x' + v T, T)\n        phase_T = boost_phase(x, v, T, m=m, hbar=hbar)\n        phi_from_lab = phase_T * psi_shifted\n\n        # Direct primed-frame propagation\n        phase_0 = boost_phase(x, v, 0.0, m=m, hbar=hbar)\n        phi0 = phase_0 * psi0  # boosted initial state at t=0\n        phi_direct_T = propagate_free_spectral(phi0, k, T, m=m)\n\n        # Compute normalized RMS error\n        err = compute_error(phi_direct_T, phi_from_lab, dx)\n        results.append(err)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2441280"}, {"introduction": "This final practice advances to a more complex and physically realistic scenario: the interaction of an atom with an intense, time-dependent laser field. You will implement the full split-operator method to handle a time-varying potential and incorporate a Complex Absorbing Potential (CAP) to model the ionization process in an open system. This problem [@problem_id:2421319] exemplifies how the techniques you've learned are applied in contemporary research to study phenomena like strong-field ionization.", "problem": "Implement a one-dimensional numerical solver for the time-dependent Schrödinger equation with a Complex Absorbing Potential to model ionization of a soft-core hydrogen atom in a strong laser field. Work entirely in atomic units, where $\\hbar = 1$, $m_e = 1$, and $e = 1$. Probabilities are dimensionless and require no units. Angles appearing in trigonometric functions must be in radians.\n\nStarting point and core definitions:\n- The time-dependent Schrödinger equation is $i \\,\\partial_t \\psi(x,t) = \\hat{H}(t)\\,\\psi(x,t)$ with Hamiltonian $\\hat{H}(t) = \\hat{T} + V(x) + x\\,E(t) - i\\,W(x)$, where $\\hat{T} = -\\tfrac{1}{2}\\partial_x^2$ is the kinetic energy operator, $V(x)$ is the soft-core Coulomb potential, $E(t)$ is the laser electric field in the dipole (length) gauge, and $W(x) \\ge 0$ is the Complex Absorbing Potential (CAP) that damps outgoing probability near the domain boundaries.\n- The soft-core potential is $V(x) = -\\dfrac{1}{\\sqrt{x^2 + a^2}}$ with softening parameter $a > 0$.\n- The laser field is a finite-duration pulse with envelope $E(t) = E_0\\,\\sin^2\\!\\big(\\pi t/T\\big)\\cos(\\omega t)$ for $0 \\le t \\le T$, and $E(t) = 0$ otherwise. The angular frequency is $\\omega$ and the total pulse duration is $T$.\n- The Complex Absorbing Potential is $W(x) = \\eta \\left(\\dfrac{|x| - x_{\\mathrm{cap}}}{x_{\\max} - x_{\\mathrm{cap}}}\\right)^m$ for $|x| \\ge x_{\\mathrm{cap}}$, and $W(x) = 0$ for $|x| < x_{\\mathrm{cap}}$, where $\\eta \\ge 0$ controls the absorption strength, $m \\ge 1$ is an even integer exponent, and $x_{\\max}$ is the half-domain size.\n\nYour tasks:\n1. Discretize space on a uniform grid $x_j$ with $N$ points and spacing $\\Delta x$. Use a periodic spectral representation for the kinetic propagator (via the Discrete Fourier Transform), and apply a symmetric second-order Trotter-Suzuki splitting in time for the evolution operator. The resulting algorithm should alternate half-steps of the potential and full steps of the kinetic operator, evaluated at the time-centered electric field $E(t + \\Delta t/2)$ within each time step. The CAP $W(x)$ must be included multiplicatively in the position-space potential factors.\n2. Construct the initial state $\\psi(x,0)$ as the normalized ground state of the field-free Hamiltonian $\\hat{H}_0 = \\hat{T} + V(x)$ using a finite-difference representation of $\\hat{T}$ and a sparse eigensolver to obtain the lowest eigenvector. Normalize with respect to the discrete $L^2$ inner product, i.e., ensure $\\sum_j |\\psi_j|^2 \\Delta x = 1$.\n3. Propagate $\\psi(x,t)$ from $t=0$ to $t=T$ under the Hamiltonian with the laser field and the CAP. Define the ionization probability by the absorbed norm, $P_{\\mathrm{ion}} = 1 - \\|\\psi(T)\\|_2^2$, where $\\|\\psi(T)\\|_2^2 = \\sum_j |\\psi_j(T)|^2 \\Delta x$; this equals the total norm removed by the non-Hermitian CAP over the propagation and serves as a proxy for the ionized flux.\n4. Implement the solver and compute $P_{\\mathrm{ion}}$ for each of the following test cases. Use the same spatial and temporal discretization across all tests. The laser phase is in radians.\n\nDiscretization and model parameters to use:\n- Grid size: $N = 512$ points.\n- Grid spacing: $\\Delta x = 0.3$, so $x_{\\max} = N \\Delta x / 2$ and $x \\in [-x_{\\max}, x_{\\max})$.\n- Soft-core parameter: $a = 1.0$.\n- Time step: $\\Delta t = 0.1$.\n- Angular frequency: $\\omega = 0.057$.\n- Number of cycles: $n_{\\mathrm{cyc}} = 2$, so total duration $T = n_{\\mathrm{cyc}} \\times \\dfrac{2\\pi}{\\omega}$.\n- CAP parameters: absorbing layer width $L_{\\mathrm{cap}} = 20.0$, so $x_{\\mathrm{cap}} = x_{\\max} - L_{\\mathrm{cap}}$; exponent $m = 2$.\n- Kinetic operator in momentum space: $\\exp\\!\\big(-i \\tfrac{k^2}{2} \\Delta t\\big)$ where $k$ are the discrete wave numbers consistent with the chosen grid and the Discrete Fourier Transform.\n\nTest suite:\n- Case A (no laser, CAP on): $E_0 = 0.0$, $\\eta = 1.0$.\n- Case B (moderately strong laser, CAP on): $E_0 = 0.08$, $\\eta = 1.0$.\n- Case C (same laser as B, CAP off): $E_0 = 0.08$, $\\eta = 0.0$.\n\nFor each case, compute the final absorbed probability $P_{\\mathrm{ion}}$ at $t = T$ as a floating-point number. Your program must produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, in the fixed order [Case A, Case B, Case C]. Express each result as a decimal number rounded to six digits after the decimal point. For example, an output like [$0.000001$, $0.123456$, $0.000000$] would be acceptable. No other output should be printed.", "solution": "The problem posed is a well-defined initial value problem in computational quantum mechanics, requiring the numerical solution of the one-dimensional time-dependent Schrödinger equation (TDSE). All provided equations, parameters, and numerical procedures are standard in the field of strong-field physics and are scientifically sound, consistent, and complete. The problem is therefore deemed valid and a solution will be provided.\n\nThe core of the problem is to simulate the time evolution of a quantum mechanical wavefunction $\\psi(x,t)$ governed by the TDSE:\n$$\ni \\frac{\\partial}{\\partial t}\\psi(x,t) = \\hat{H}(t)\\psi(x,t)\n$$\nThe Hamiltonian $\\hat{H}(t)$ is composed of several parts:\n$$\n\\hat{H}(t) = \\hat{T} + V(x) + V_{\\mathrm{laser}}(x,t) + V_{\\mathrm{CAP}}(x)\n$$\nwhere:\n-   $\\hat{T} = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2}$ is the kinetic energy operator (in atomic units, where $\\hbar=1$ and the electron mass $m_e=1$).\n-   $V(x) = -\\frac{1}{\\sqrt{x^2 + a^2}}$ is the soft-core Coulomb potential, which regularizes the singularity at $x=0$.\n-   $V_{\\mathrm{laser}}(x,t) = x E(t)$ is the interaction with the laser's electric field $E(t)$ in the dipole approximation and length gauge. The field is given by $E(t) = E_0\\sin^2(\\pi t/T)\\cos(\\omega t)$ for $t \\in [0, T]$ and zero otherwise.\n-   $V_{\\mathrm{CAP}}(x) = -iW(x)$ is the Complex Absorbing Potential (CAP), which is a non-Hermitian term designed to absorb outgoing probability flux, thereby modeling ionization. The form of $W(x)$ is given as a polynomial ramp near the grid boundaries.\n\nThe solution is constructed in three main stages: spatial and temporal discretization, determination of the initial state, and time propagation of the wavefunction.\n\n**1. Discretization and Numerical Representation**\n\nWe discretize the spatial domain into a uniform grid of $N$ points, $x_j = -x_{\\max} + j\\Delta x$ for $j = 0, 1, \\dots, N-1$, where $\\Delta x$ is the grid spacing and $x_{\\max} = N\\Delta x/2$. The wavefunction becomes a vector $\\psi_j(t) = \\psi(x_j, t)$. The potential operators $V(x)$, $V_{\\mathrm{laser}}(x,t)$, and $V_{\\mathrm{CAP}}(x)$ are diagonal in this position-space representation; their action is a simple element-wise multiplication.\n\nThe kinetic energy operator $\\hat{T}$ is not diagonal in position space. Its action is most efficiently calculated in momentum space, where it is a diagonal operator. The transformation between position and momentum space is achieved via the Discrete Fourier Transform (DFT) and its inverse (IDFT). The momentum-space (or k-space) grid points $k_n$ are determined by the properties of the DFT. For our spatial grid, the corresponding wave numbers are given by $k_n$, as provided by `scipy.fft.fftfreq(N, d=dx) * 2 * np.pi`. In this basis, the kinetic operator's action is multiplication by $\\hat{T}_k = \\frac{k^2}{2}$.\n\n**2. Initial State Calculation**\n\nThe system starts in the ground state of the field-free Hamiltonian, $\\hat{H}_0 = \\hat{T} + V(x)$. To find this state, we solve the time-independent Schrödinger equation $\\hat{H}_0 \\phi = E \\phi$. This is an eigenvalue problem. We construct a matrix representation of $\\hat{H}_0$ on our spatial grid. For this purpose, we use a second-order finite-difference approximation for the kinetic operator:\n$$\n\\frac{\\partial^2\\psi}{\\partial x^2}\\bigg|_{x_j} \\approx \\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{\\Delta x^2}\n$$\nThis turns $\\hat{T}$ into a sparse, tridiagonal matrix (with corner elements due to periodic boundary conditions). The potential $V(x)$ becomes a diagonal matrix with entries $V(x_j)$. The resulting Hamiltonian matrix $\\mathbf{H}_0$ is sparse. We use a sparse eigensolver `scipy.sparse.linalg.eigs` to find the eigenvector corresponding to the lowest eigenvalue (the ground state energy). The obtained eigenvector is then normalized according to the discrete inner product: $\\sum_{j=0}^{N-1} |\\psi_j(0)|^2 \\Delta x = 1$. This normalized vector is our initial state, $\\psi(x,0)$.\n\n**3. Time Propagation using the Split-Operator Method**\n\nThe time evolution of the wavefunction from time $t$ to $t+\\Delta t$ is formally given by $\\psi(t+\\Delta t) = \\exp(-i \\hat{H}_{\\text{eff}} \\Delta t) \\psi(t)$, where $\\hat{H}_{\\text{eff}}$ is the effective Hamiltonian over the time step. Since the kinetic operator $\\hat{T}$ and the various potential operators do not commute, we cannot simply exponentiate their sum. We employ a symmetric second-order Trotter-Suzuki decomposition of the evolution operator:\n$$\n\\hat{U}(\\Delta t) = e^{-i\\hat{H}\\Delta t} \\approx e^{-i\\hat{B}\\frac{\\Delta t}{2}} e^{-i\\hat{A}\\Delta t} e^{-i\\hat{B}\\frac{\\Delta t}{2}} + O(\\Delta t^3)\n$$\nHere, we split the Hamiltonian into the kinetic part $\\hat{A} = \\hat{T}$ and the total potential part $\\hat{B}(t) = V(x) + xE(t) - iW(x)$. The propagators for $\\hat{A}$ and $\\hat{B}$ are straightforward to apply in momentum space and position space, respectively.\n\nThe algorithm for a single time step from $t$ to $t+\\Delta t$ is as follows:\n1.  Calculate the total potential at the center of the time step, $V_{\\text{full}}(x, t+\\Delta t/2) = V(x) + x E(t+\\Delta t/2) - iW(x)$.\n2.  Apply the first half-step potential propagator in position space:\n    $$ \\psi'(x) = e^{-i V_{\\text{full}}(x, t+\\Delta t/2) \\frac{\\Delta t}{2}} \\psi(x,t) $$\n3.  Transform the result to momentum space using the Fast Fourier Transform (FFT): $\\tilde{\\psi}'(k) = \\text{FFT}[\\psi'(x)]$.\n4.  Apply the full-step kinetic propagator in momentum space:\n    $$ \\tilde{\\psi}''(k) = e^{-i \\frac{k^2}{2} \\Delta t} \\tilde{\\psi}'(k) $$\n5.  Transform back to position space using the Inverse Fast Fourier Transform (IFFT): $\\psi''(x) = \\text{IFFT}[\\tilde{\\psi}''(k)]$.\n6.  Apply the second half-step potential propagator in position space to obtain the final state for the step:\n    $$ \\psi(x,t+\\Delta t) = e^{-i V_{\\text{full}}(x, t+\\Delta t/2) \\frac{\\Delta t}{2}} \\psi''(x) $$\nThis sequence is repeated for the total duration of the laser pulse, $T$.\n\n**4. Calculation of Ionization Probability**\n\nThe CAP term $-iW(x)$ in the Hamiltonian is non-Hermitian, which leads to a non-conservation of the wavefunction's norm, $\\|\\psi(t)\\|_2^2 = \\sum_j |\\psi_j(t)|^2 \\Delta x$. The rate of norm decay is given by $\\frac{d}{dt} \\|\\psi\\|^2 = -2 \\langle \\psi | W | \\psi \\rangle$, which is non-positive since $W(x) \\ge 0$. The total norm absorbed by the CAP over the simulation time $[0, T]$ serves as a measure of the total ionization probability, $P_{\\mathrm{ion}}$. Given that the initial state is normalized, $\\|\\psi(0)\\|_2^2 = 1$, the ionization probability is:\n$$\nP_{\\mathrm{ion}} = 1 - \\|\\psi(T)\\|_2^2 = 1 - \\sum_{j=0}^{N-1} |\\psi_j(T)|^2 \\Delta x\n$$\nThis quantity is computed for each of the three test cases specified in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg as sla\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Solves the 1D TDSE for a soft-core hydrogen atom in a laser field,\n    calculates ionization probability for three test cases, and prints the results.\n    \"\"\"\n\n    # --- 1. Define physical and numerical parameters ---\n    # Discretization\n    N = 512              # Number of grid points\n    dx = 0.3             # Grid spacing\n    dt = 0.1             # Time step\n    \n    # Grid construction\n    x_max = N * dx / 2.0\n    x = np.arange(-x_max, x_max, dx)\n\n    # Momentum space grid (k-space)\n    # The factor 2*pi is necessary for the angular frequency definition of k in physics\n    k = 2.0 * np.pi * fft.fftfreq(N, d=dx)\n\n    # Physical parameters\n    a = 1.0              # Soft-core parameter\n    omega = 0.057        # Laser angular frequency\n    n_cyc = 2.0          # Number of laser cycles\n    T = n_cyc * (2.0 * np.pi / omega) # Total pulse duration\n    \n    # CAP parameters\n    L_cap = 20.0         # Width of the absorbing layer\n    m_cap = 2            # Exponent of the CAP\n    x_cap = x_max - L_cap\n\n    # --- 2. Define potentials and operators ---\n    \n    # Soft-core potential\n    V_sc = -1.0 / np.sqrt(x**2 + a**2)\n\n    # Laser electric field envelope\n    def E_laser(t, E0):\n        if 0 = t = T:\n            return E0 * (np.sin(np.pi * t / T)**2) * np.cos(omega * t)\n        else:\n            return 0.0\n\n    # Complex Absorbing Potential (CAP)\n    def W_cap(eta):\n        W = np.zeros(N)\n        # Condition |x| >= x_cap\n        mask = np.abs(x) >= x_cap\n        # The region where the CAP is active\n        active_x = np.abs(x[mask])\n        W[mask] = eta * ((active_x - x_cap) / (x_max - x_cap))**m_cap\n        return W\n\n    # Kinetic energy propagator in k-space\n    K_prop = np.exp(-1j * (k**2 / 2.0) * dt)\n\n    # --- 3. Calculate initial state (ground state of H0) ---\n    def get_initial_state():\n        \"\"\"\n        Computes the normalized ground state of the field-free Hamiltonian\n        H0 = T + V(x) using a finite-difference eigensolver.\n        \"\"\"\n        # Kinetic operator T = -1/2 * d^2/dx^2 using centered 2nd-order finite difference\n        # with periodic boundary conditions\n        diag = np.ones(N) * (-2.0)\n        off_diag = np.ones(N - 1)\n        # Create tridiagonal part\n        T_matrix = sparse.diags([off_diag, diag, off_diag], [-1, 0, 1], shape=(N, N))\n        # Add periodic boundary corners\n        T_matrix.setdiag(1, N - 1)\n        T_matrix.setdiag(1, -N + 1)\n        T_matrix *= -0.5 / dx**2\n        \n        # Potential operator V_sc as a sparse diagonal matrix\n        V_matrix = sparse.diags([V_sc], [0])\n        \n        # Field-free Hamiltonian H0\n        H0 = T_matrix + V_matrix\n        \n        # Find the ground state (eigenstate with the smallest real eigenvalue)\n        # We ask for a few eigenvalues around 0 to ensure we get the ground state\n        # The true ground state energy is negative.\n        eigenvalues, eigenvectors = sla.eigs(H0, k=5, which='SR')\n        \n        ground_state_index = np.argmin(np.real(eigenvalues))\n        psi0 = eigenvectors[:, ground_state_index]\n\n        # Normalize the wavefunction: integral |psi|^2 dx = 1\n        norm = np.sqrt(np.sum(np.abs(psi0)**2) * dx)\n        psi0_normalized = psi0 / norm\n        \n        return psi0_normalized\n\n    # --- 4. Define the time propagation function ---\n    def run_simulation(psi0, E0, eta):\n        \"\"\"\n        Propagates the initial wavefunction psi0 in time from t=0 to t=T.\n        \"\"\"\n        psi = np.copy(psi0).astype(np.complex128)\n        \n        # Pre-calculate time-independent part of potential\n        W = W_cap(eta)\n        V_base = V_sc - 1j * W\n        \n        num_steps = int(np.ceil(T / dt))\n        \n        for i in range(num_steps):\n            t = i * dt\n            \n            # Symmetric Trotter splitting requires field at t + dt/2\n            E_mid = E_laser(t + dt / 2.0, E0)\n            \n            V_full = V_base + x * E_mid\n            V_prop = np.exp(-1j * V_full * dt / 2.0)\n            \n            # (1) First half-step in potential\n            psi = V_prop * psi\n            \n            # (2) Full step in kinetic energy (in k-space)\n            psi_k = fft.fft(psi)\n            psi_k = K_prop * psi_k\n            psi = fft.ifft(psi_k)\n            \n            # (3) Second half-step in potential\n            psi = V_prop * psi\n\n        # Calculate final norm and ionization probability\n        final_norm_sq = np.sum(np.abs(psi)**2) * dx\n        p_ion = 1.0 - final_norm_sq\n        \n        return p_ion\n\n    # --- 5. Run test cases and format output ---\n    test_cases = [\n        # Case A: E0=0.0, eta=1.0 (CAP on, no laser)\n        (0.0, 1.0),\n        # Case B: E0=0.08, eta=1.0 (CAP on, strong laser)\n        (0.08, 1.0),\n        # Case C: E0=0.08, eta=0.0 (CAP off, strong laser)\n        (0.08, 0.0),\n    ]\n\n    results = []\n    # Calculate initial state once, as it is the same for all cases\n    initial_state = get_initial_state()\n\n    for E0_case, eta_case in test_cases:\n        p_ion_result = run_simulation(initial_state, E0_case, eta_case)\n        # Format to 6 decimal places as requested\n        results.append(f\"{p_ion_result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2421319"}]}