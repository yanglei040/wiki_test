{"hands_on_practices": [{"introduction": "To truly grasp call-by-name, we must learn to think like the compiler. This first exercise provides a concrete scenario to practice tracing the demand-driven evaluation of thunks, meticulously counting each time an argument is re-evaluated. By working through the nested expressions and recursive calls, you will build a robust mental model of how and when computation occurs under this non-strict strategy. [@problem_id:3675795]", "problem": "In the context of compiler principles, consider a first-order, call-by-name evaluation strategy implemented via thunks. A thunk is a deferred computation represented as a closure that captures an expression and its environment and is executed only when its value is demanded (forced). In call-by-name, there is no memoization: each use of a formal parameter re-evaluates the thunk from scratch. Assume a deterministic left-to-right evaluation order for primitive operations: for an addition operator, the left operand is evaluated before the right operand; for a conditional expression, the condition is evaluated before the selected branch; for a lexical binding, a $\\text{let}$ binds by name (non-strict) and the bound expression is not evaluated until the bound name is used.\n\nLet the actual argument be the expression $x_{n} = \\sum_{i=1}^{n} i$, where $n$ is an integer with $n \\geq 1$, and let the formal parameter be $a$. The argument is passed to a function $f$ as a thunk $\\theta_{a}$ that re-evaluates $x_{n}$ every time $a$ is referenced. Instrument the runtime so that each time $\\theta_{a}$ is forced, a global counter $F$ increases by $1$. We ignore any other costs and count only the number of forces of $\\theta_{a}$.\n\nDefine the function $f$ as follows, where $k$ is a nonnegative integer parameter:\n1. The auxiliary replication function is defined by\n$$\\operatorname{rep}_{k}(a) = \\begin{cases}\n0, & \\text{if } k = 0, \\\\\na + \\operatorname{rep}_{k-1}(a), & \\text{if } k > 0,\n\\end{cases}$$\nwith addition evaluated left-to-right.\n2. The function $f$ is defined by\n$$\nf(a, k) = \\text{if } a > 0 \\text{ then } \n\\Big(\n\\text{let } b = a + a \\text{ in }\n\\text{let } c = a + b \\text{ in }\n\\text{let } d = b + b \\text{ in }\nc + d + \\operatorname{rep}_{k}(a)\n\\Big)\n\\text{ else } 0.\n$$\n\nUnder the above call-by-name semantics with non-memoizing thunks and $n \\geq 1$, determine a closed-form expression in terms of $k$ for the total number of times $\\theta_{a}$ is forced during the evaluation of $f(a, k)$ when the actual argument is the thunk $\\theta_{a}$ for $x_{n}$. Express your final answer as a single analytic expression. No rounding is required.", "solution": "The fundamental basis for this derivation is the definition of call-by-name with thunks: a formal parameter $a$ denotes a thunk $\\theta_{a}$ that, when forced, re-evaluates its associated expression in the captured environment. Under call-by-name without memoization, each syntactic occurrence of $a$ in the executed code results in a separate force of $\\theta_{a}$. We also use the specified left-to-right evaluation order for primitive operations and non-strict $\\text{let}$ bindings that delay evaluation until use.\n\nWe proceed by analyzing the demand-driven forcing behavior of $\\theta_{a}$ in the evaluation of $f(a, k)$, counting how many times $a$ is referenced and thus how many times $\\theta_{a}$ is forced. We assume $n \\geq 1$, so $x_{n} = \\sum_{i=1}^{n} i$ is positive, and hence $a > 0$ holds. Therefore, the $\\text{then}$ branch is taken, and the $\\text{else}$ branch is not evaluated.\n\nStep 1: Evaluate the conditional guard $a > 0$.\n- The condition references $a$ once.\n- This forces $\\theta_{a}$ exactly once.\n- Contribution to $F$: $1$.\n\nStep 2: Enter the $\\text{then}$ branch and process the nested $\\text{let}$ bindings. Because $\\text{let}$ binds by name, the right-hand sides are not evaluated at binding time, but only when their bound names are used.\n\nThe $\\text{then}$ branch body is:\n$$\n\\text{let } b = a + a \\text{ in }\n\\text{let } c = a + b \\text{ in }\n\\text{let } d = b + b \\text{ in }\nc + d + \\operatorname{rep}_{k}(a).\n$$\n\nWe evaluate the final expression $c + d + \\operatorname{rep}_{k}(a)$ from left to right.\n\nStep 2a: Force $c$.\n- $c$ is defined as $a + b$, evaluated left-to-right.\n- First, evaluate $a$ in $a + b$: this forces $\\theta_{a}$ once.\n- Next, evaluate $b$ in $a + b$: this forces $b$.\n- Forcing $b$ evaluates $a + a$, left-to-right:\n  - Evaluate left $a$: forces $\\theta_{a}$ once.\n  - Evaluate right $a$: forces $\\theta_{a}$ once.\n- Total forces of $\\theta_{a}$ due to $c$: $1$ (for the $a$ in $a+b$) $+ 2$ (for the two $a$ in $b$) $= 3$.\n- Contribution to $F$: $3$.\n\nStep 2b: Force $d$.\n- $d$ is defined as $b + b$, evaluated left-to-right.\n- Evaluate the left $b$: forcing $b$ evaluates $a + a$, which forces $\\theta_{a}$ twice (left $a$ and right $a$).\n- Evaluate the right $b$: forcing $b$ again evaluates $a + a$, which forces $\\theta_{a}$ twice more.\n- Total forces of $\\theta_{a}$ due to $d$: $2 + 2 = 4$.\n- Contribution to $F$: $4$.\n\nStep 2c: Force $\\operatorname{rep}_{k}(a)$.\n- The definition is $\\operatorname{rep}_{k}(a) = 0$ if $k=0$, else $a + \\operatorname{rep}_{k-1}(a)$.\n- For $k > 0$, each recursive step evaluates $a$ first (left-to-right addition) and then recurses on $\\operatorname{rep}_{k-1}(a)$.\n- Therefore, for each of the $k$ steps, $a$ is referenced exactly once, and thus $\\theta_{a}$ is forced once per step.\n- Total forces of $\\theta_{a}$ due to $\\operatorname{rep}_{k}(a)$: $k$.\n- Contribution to $F$: $k$.\n\nStep 3: Summation of all contributions.\n- From the conditional guard: $1$.\n- From forcing $c$: $3$.\n- From forcing $d$: $4$.\n- From forcing $\\operatorname{rep}_{k}(a)$: $k$.\n\nThus, the total number of forces of $\\theta_{a}$ during the evaluation of $f(a, k)$ is\n$$k + 1 + 3 + 4 = k + 8.$$\n\nThis count depends only on the syntactic occurrences and the specified evaluation order; the value $x_{n}$ being positive for $n \\geq 1$ ensures the $\\text{then}$ branch is taken, but no further branching depends on $a$. Therefore, the closed-form expression for the total number of forces is $k + 8$.", "answer": "$$\\boxed{k+8}$$", "id": "3675795"}, {"introduction": "The repeated evaluation inherent in call-by-name is not just a theoretical curiosity; it has real performance consequences. This practice moves from simply counting thunk evaluations to analyzing their economic impact using a formal cost model. You will compare pure call-by-name with an optimized version that introduces memoization, learning to make quantitative trade-offs that are central to compiler design. [@problem_id:3675854]", "problem": "A compiler for a strict first-order arithmetic language implements call-by-name via thunks. A thunk is a closure that stores an unevaluated argument expression and its environment. Forcing a thunk triggers evaluation of that expression in the captured environment. Under pure call-by-name, each force re-evaluates the expression. Consider the function body $f(x,y) = x + y + x$ and assume that addition is a strict primitive operator in both operands.\n\nAssume the following cost model, where all costs are additive:\n- Forcing any thunk once incurs a fixed overhead cost $h$.\n- Evaluating the expression for $x$ (exclusive of thunk overhead) costs $c_{x}$.\n- Evaluating the expression for $y$ (exclusive of thunk overhead) costs $c_{y}$.\n- Each primitive addition $+$ costs $a$.\n- As an optional transformation, the compiler may introduce a local binding to share the value of $x$ across its multiple uses (simulating call-by-need for $x$ only): allocate a cell once at cost $m$, store the result of the first evaluation once at cost $s$, and satisfy each subsequent use of $x$ from the cell at cost $r$ without re-evaluating the $x$ expression. The first use of $x$ still forces and evaluates the thunk, incurring $h + c_{x}$.\n\nStarting from the basic definitions of call-by-name thunks and strict evaluation of $+$, do the following reasoning:\n- Determine the dynamic force multiplier for each of the arguments $x$ and $y$ in the body $f(x,y) = x + y + x$.\n- Derive, from first principles of the cost model and the determined multipliers, the total execution cost for evaluating $f(x,y)$ under pure call-by-name (no sharing).\n- Derive the total execution cost if the compiler applies the sharing transformation to $x$ only (do not share $y$).\n- Discuss whether reordering the summands using associativity and commutativity (for example, $(x + x) + y$ or $y + x + x$) changes the total cost under either regime, and choose the plan (pure call-by-name vs. sharing $x$) and ordering that minimizes the total cost.\n- Using the parameter values $h = 3$, $c_{x} = 40$, $c_{y} = 10$, $a = 1$, $m = 2$, $s = 1$, and $r = 1$, compute the minimal total cost for evaluating $f(x,y)$ under the optimal plan and ordering.\n\nExpress your final answer as a single real-valued number with no units. No rounding is required.", "solution": "**1. Dynamic Force Multipliers**\nThe function body is $f(x,y) = x + y + x$. Assuming standard left-to-right associativity for the $+$ operator, this expression is evaluated as $(x+y)+x$. The $+$ operator is strict, meaning it must evaluate both of its operands to produce a result.\n- To evaluate the outer $+$, the runtime system must first evaluate its left operand, $(x+y)$, and its right operand, $x$.\n- To evaluate the sub-expression $(x+y)$, the runtime must evaluate its operands, $x$ and $y$. This requires forcing the thunk for $x$ (first time) and forcing the thunk for $y$ (first time).\n- After the value of $(x+y)$ is computed, the evaluation of the main expression continues. The runtime now evaluates the right operand of the outer $+$, which is $x$. This requires forcing the thunk for $x$ a second time.\nTherefore, the dynamic force multiplier for $x$ is $2$, and for $y$ is $1$.\n\n**2. Total Cost under Pure Call-by-Name (CBN)**\nUnder a pure call-by-name regime, each time an argument's thunk is forced, its corresponding expression is re-evaluated.\nThe cost of one evaluation of $x$ is the sum of the thunk overhead $h$ and the expression evaluation cost $c_x$, totaling $h+c_x$.\nThe cost of one evaluation of $y$ is $h+c_y$.\nThe expression has two addition operations, contributing a total cost of $2a$.\nThe total cost, $C_{CBN}$, is the sum of the costs for two evaluations of $x$, one evaluation of $y$, and two additions.\n$$C_{CBN} = 2(h + c_x) + 1(h + c_y) + 2a$$\n$$C_{CBN} = 2h + 2c_x + h + c_y + 2a = 3h + 2c_x + c_y + 2a$$\n\n**3. Total Cost with Sharing Transformation for $x$**\nWith this transformation, the value of $x$ is computed once and stored.\n- A one-time cost $m$ is incurred to allocate a cell for $x$'s value.\n- The first time $x$ is needed, its thunk is forced (cost $h$), its expression is evaluated (cost $c_x$), and the result is stored (cost $s$). The cost of this first use is $h + c_x + s$.\n- The second (and any subsequent) time $x$ is needed, its value is retrieved from the cell at cost $r$.\n- The argument $y$ is not shared, so its single use costs $h+c_y$.\n- The two additions still contribute $2a$.\nThe total cost, $C_{share-x}$, is the sum of these individual costs.\n$$C_{share-x} = m + (h+c_x+s) + r + (h+c_y) + 2a$$\n$$C_{share-x} = m + s + r + 2h + c_x + c_y + 2a$$\n\n**4. Optimal Plan and Ordering**\nThe problem asks to consider reordering the summands, for example to $(x+x)+y$. Since addition is strict, the total number of times each operand must be evaluated is determined by its number of occurrences in the expression, regardless of the grouping. In $x+y+x$, $x$ appears twice and $y$ appears once. Any reordering, such as $(x+x)+y$ or $y+(x+x)$, preserves this count. Thus, the total cost for both the pure CBN and the sharing regimes is independent of the evaluation order. The ordering is therefore not a factor in the minimal cost.\n\nThe optimal plan is found by comparing $C_{CBN}$ and $C_{share-x}$. The sharing plan is better if $C_{share-x} < C_{CBN}$.\n$$m + s + r + 2h + c_x + c_y + 2a < 3h + 2c_x + c_y + 2a$$\nBy subtracting common terms ($2h + c_x + c_y + 2a$) from both sides, we simplify the inequality to:\n$$m + s + r < h + c_x$$\nThis inequality states that sharing is advantageous if the total overhead of sharing ($m+s+r$) is less than the cost of the re-evaluation it saves ($h+c_x$).\n\n**5. Minimal Total Cost Calculation**\nWe use the given parameter values: $h=3$, $c_x=40$, $c_y=10$, $a=1$, $m=2$, $s=1$, $r=1$.\nFirst, we check the condition to determine the optimal plan:\n$$m + s + r < h + c_x$$\n$$2 + 1 + 1 < 3 + 40$$\n$$4 < 43$$\nThe condition holds, so the optimal plan is to use the sharing transformation for $x$. The minimal cost is $C_{share-x}$.\nWe now compute this cost:\n$$C_{share-x} = m + s + r + 2h + c_x + c_y + 2a$$\n$$C_{share-x} = 2 + 1 + 1 + 2(3) + 40 + 10 + 2(1)$$\n$$C_{share-x} = 4 + 6 + 40 + 10 + 2$$\n$$C_{share-x} = 62$$\nFor completeness, the cost under pure CBN would be:\n$$C_{CBN} = 3h + 2c_x + c_y + 2a = 3(3) + 2(40) + 10 + 2(1) = 9 + 80 + 10 + 2 = 101$$\nAs expected, $62 < 101$. The minimal cost is $62$.", "answer": "$$\\boxed{62}$$", "id": "3675854"}, {"introduction": "Memoizing a thunk to avoid re-evaluation is a powerful optimization that transforms call-by-name into call-by-need. However, this change is not always semantically invisible. This final exercise challenges you to explore the crucial boundary conditions—such as side effects, non-termination, and aliasing—where these two evaluation strategies diverge, deepening your understanding of program correctness in non-strict languages. [@problem_id:3675807]", "problem": "In a standard interpreter for a language with lexical scope and first-class procedures, call-by-name (CBN) is implemented by passing a thunk for each actual argument. A thunk is a pair $\\langle e,\\rho\\rangle$, where $e$ is the unevaluated expression and $\\rho$ is the environment mapping free variables of $e$ to locations or values. Forcing a thunk, denoted $\\operatorname{force}(\\langle e,\\rho\\rangle)$, evaluates $e$ under $\\rho$. By definition of call-by-name, the actual argument expression is evaluated each time its corresponding formal parameter is used in the callee body; that is, there is no reuse of a previous evaluation result across uses.\n\nConsider a function application where the callee has two formal parameters and the caller supplies the same actual expression for both, so the callee receives two bindings that alias a single thunk $\\langle e,\\rho\\rangle$. You are evaluating whether the implementation of $\\operatorname{force}$ should recompute $e$ on each invocation or reuse a memoized result stored in the thunk after the first evaluation. Two implementation policies are under consideration:\n- Policy $1$: Never memoize; every call $\\operatorname{force}(\\langle e,\\rho\\rangle)$ re-evaluates $e$ in $\\rho$.\n- Policy $2$: Memoize inside the thunk; the first call to $\\operatorname{force}(\\langle e,\\rho\\rangle)$ evaluates $e$ in $\\rho$ and stores the result in the thunk; subsequent calls return the stored result without reevaluating $e$.\n\nAssume the language may include effects (such as mutation or printing) and may have non-terminating computations. The callee may use each parameter multiple times. The two formal parameters may alias the same thunk object when the caller passes the same expression twice, as in a call syntactically analogous to $f(x,x)$.\n\nWhich of the following statements are correct?\n\nA. Under call-by-name, Policy $1$ is required; even when two formals alias the same thunk $\\langle e,\\rho\\rangle$, each parameter force must recompute $e$ independently. Using Policy $2$ in general changes semantics when $e$ has effects or may diverge.\n\nB. Policy $2$ is observationally equivalent to call-by-name for all programs; memoization can only improve performance and cannot change observable behavior.\n\nC. Because of aliasing, the callee must duplicate the thunk object so that each formal parameter has a distinct thunk; otherwise, even with Policy $1$, forcing via one parameter can incorrectly affect forcing via the other.\n\nD. In a pure setting where $e$ is referentially transparent and terminating, Policies $1$ and $2$ are observationally equivalent for calls of the form $f(e,e)$; sharing a single memoized thunk yields the same results as call-by-name in that setting.", "solution": "The problem requires an analysis of two implementation policies for forcing thunks, which correspond to call-by-name and call-by-need evaluation strategies, especially in the presence of aliasing, side effects, and non-termination.\n\n*   **Policy 1 (Pure Call-by-Name, CBN):** The thunk's expression is re-evaluated on every force. This is the strict definition of call-by-name.\n*   **Policy 2 (Call-by-Need, Lazy Evaluation):** The thunk's expression is evaluated only on the first force, and the result is memoized (cached). Subsequent forces return the cached result.\n\nLet's evaluate each statement:\n\n**A. Correct.** By definition, call-by-name mandates re-evaluation upon every use of the parameter. Therefore, Policy 1 is the correct implementation of CBN. Policy 2 implements call-by-need. The two policies are not semantically equivalent in the general case.\n    *   **Side Effects:** Consider an expression `e` that prints a message and returns a value, e.g., `(print(\"eval!\"); 1)`. In a function call `f(e, e)` where `f(x, y) = x + y`, Policy 1 would cause \"eval!\" to be printed twice. Policy 2 would print it only once. The observable behavior is different.\n    *   **Non-termination:** If `e` is an expression that causes an infinite loop, any use of a parameter bound to `e` under Policy 1 will cause the program to hang. Under Policy 2, only the *first* use will cause it to hang.\n    Thus, changing from Policy 1 to Policy 2 changes the semantics when effects are present.\n\n**B. Incorrect.** This statement is the direct opposite of the conclusion for A. As demonstrated with the side-effect example, memoization is not just a performance optimization; it fundamentally changes the observable behavior of non-pure programs.\n\n**C. Incorrect.** In a call like `f(e, e)`, the language semantics specify that both formal parameters alias the *same* thunk. This is intended behavior, not a bug to be fixed by duplication. With Policy 1 (CBN), forcing the thunk via the first parameter and then via the second will correctly re-evaluate the expression `e` twice, and any side effects will be observable in sequence. Duplicating the thunk would be a different semantic model altogether. The core of CBN is re-evaluating the *original* argument expression in its *original* environment upon every access, regardless of aliasing.\n\n**D. Correct.** In a pure functional setting, expressions are referentially transparent. This means that an expression, given the same environment, will always evaluate to the same value. It has no side effects, and it is guaranteed to terminate. In this context, re-evaluating the expression `e` multiple times (Policy 1) is guaranteed to produce the same value as evaluating it once and caching the result (Policy 2). The final result of any computation will be identical. The only difference is performance, which is not considered an \"observational\" difference in this context. Therefore, for pure, terminating expressions, the two policies are observationally equivalent.\n\nBased on the analysis, statements A and D are correct.", "answer": "$$\\boxed{AD}$$", "id": "3675807"}]}