{"hands_on_practices": [{"introduction": "The core principle distinguishing call-by-need (lazy evaluation) from its predecessor, call-by-name, is memoization. While both strategies delay argument evaluation, call-by-need ensures that an argument is computed at most once, with the result being shared among all its uses. This exercise provides a concrete scenario to quantify this efficiency gain by comparing the number of times an argument is evaluated under both strategies. [@problem_id:3649720]", "problem": "Consider the untyped lambda calculus extended with integer literals and binary addition. Expressions are generated by the grammar: $e ::= n \\mid x \\mid \\lambda x.\\,e \\mid e\\ e \\mid e + e$, where $n$ ranges over integer literals and $x$ ranges over variables. Values are $v ::= n \\mid \\lambda x.\\,e$. Addition is strict in both operands and evaluates left-to-right. The small-step semantics for arithmetic are given by the following rules:\n- If $e_{1} \\to e_{1}'$ then $e_{1} + e_{2} \\to e_{1}' + e_{2}$.\n- If $e_{2} \\to e_{2}'$ and $e_{1}$ is a numeric value $n_{1}$, then $n_{1} + e_{2} \\to n_{1} + e_{2}'$.\n- If both operands are numeric values, then $n_{1} + n_{2} \\to n$ where $n$ is the integer sum of $n_{1}$ and $n_{2}$.\n\nTwo call strategies are considered:\n- Call-by-name (substitution-based): $(\\lambda x.\\,M)\\ N \\to M[x := N]$, with no prior evaluation of $N$.\n- Call-by-need (sharing via let-binding): $(\\lambda x.\\,M)\\ E \\to \\mathbf{let}\\ x = E\\ \\mathbf{in}\\ M$, and demand-driven forcing of $x$ evaluates $E$ at most once and updates the binding to the resulting value, after which all occurrences of $x$ use the memoized value.\n\nFix the closed argument expression $E \\equiv (1+1) + (1+1)$, which is not a value and reduces deterministically to the numeric value $4$ under the arithmetic rules above. Consider the program $(\\lambda x.\\, x + x + x)\\ E$, where the syntactic association of addition is left-associative, so $x + x + x$ means $(x + x) + x$.\n\nDefine “one evaluation of $x$” to mean a complete reduction of the bound argument expression $E$ to a numeric value in order to supply a demanded numeric operand at some occurrence of $x$ in the function body; that is, each time an occurrence of $x$ is forced to a numeric value under the small-step rules, it counts as one evaluation of $x$.\n\nUnder the call-by-name and call-by-need strategies described above, evaluate $(\\lambda x.\\, x + x + x)\\ E$ to a numeric value. Compute the number of evaluations of $x$ in the entire run under each strategy. Report your answer as a row matrix $\\begin{pmatrix} c_{\\text{name}}  c_{\\text{need}} \\end{pmatrix}$, where $c_{\\text{name}}$ is the count under call-by-name and $c_{\\text{need}}$ is the count under call-by-need. No rounding is necessary. Explain in your derivation how sharing arises under call-by-need and why it changes the count.", "solution": "The problem requires us to determine the number of times a specific argument expression, $E$, is evaluated when a lambda abstraction is applied to it, under two different evaluation strategies: call-by-name and call-by-need.\n\nThe program is given by $P \\equiv (\\lambda x.\\, x + x + x)\\ E$.\nThe argument expression is $E \\equiv (1+1) + (1+1)$.\nThe body of the lambda abstraction is $M \\equiv x + x + x$, which, due to left-associativity, is equivalent to $(x+x)+x$.\nThe `+` operator is strict, meaning it evaluates its operands before performing the addition. The evaluation order is left-to-right.\n\"One evaluation of $x$\" is defined as the complete reduction of the bound argument expression $E$ to a numeric value, which occurs when an occurrence of $x$ must yield a numeric value for an operation. The expression $E$ itself reduces to the value $4$:\n$E \\equiv (1+1) + (1+1) \\to 2 + (1+1) \\to 2 + 2 \\to 4$.\n\nLet us analyze the evaluation under each strategy.\n\n### Call-by-Name Evaluation\n\nUnder call-by-name, the reduction rule for function application is $(\\lambda x.\\,M)\\ N \\to M[x := N]$. The unevaluated argument expression $N$ is substituted for every occurrence of the formal parameter $x$ in the function body $M$.\n\n$1$. The initial $\\beta$-reduction is:\n$$(\\lambda x.\\, (x+x)+x) ( (1+1) + (1+1) ) \\to ( (x+x)+x )[x := (1+1)+(1+1) ]$$\nThis results in the expression:\n$$(( (1+1)+(1+1) ) + ( (1+1)+(1+1) )) + ( (1+1)+(1+1) )$$\nFor clarity, let's denote the unevaluated expression $(1+1)+(1+1)$ as $E$. The expression to evaluate is $(E + E) + E$.\n\n$2$. The evaluation of $(E+E)+E$ proceeds according to the strict, left-to-right semantics of addition.\nFirst, we must evaluate the left operand of the outermost `+`, which is the subexpression $(E+E)$.\nTo evaluate $(E+E)$, we must first evaluate its left operand, the first $E$. This is the first time a numeric operand is demanded.\n**First evaluation of $x$**: The first occurrence of $E$ is reduced to a value.\n$E \\equiv (1+1)+(1+1) \\to 2+(1+1) \\to 2+2 \\to 4$.\nThe expression becomes $(4 + E) + E$.\n\n$3$. Next, to evaluate the subexpression $(4+E)$, we must evaluate its right operand, the second $E$.\n**Second evaluation of $x$**: The second occurrence of $E$ is reduced to a value. This is a fresh copy of the expression from the substitution.\n$E \\equiv (1+1)+(1+1) \\to 2+(1+1) \\to 2+2 \\to 4$.\nThe expression becomes $(4 + 4) + E$.\n\n$4$. The inner addition can now be performed:\n$(4+4)+E \\to 8+E$.\n\n$5$. Finally, to evaluate $8+E$, we must evaluate its right operand, the third $E$.\n**Third evaluation of $x$**: The third occurrence of $E$ is reduced to a value.\n$E \\equiv (1+1)+(1+1) \\to 2+(1+1) \\to 2+2 \\to 4$.\nThe expression becomes $8+4$.\n\n$6$. The final addition occurs:\n$8+4 \\to 12$.\n\nIn this entire process, the argument expression $E$ was fully evaluated three times, once for each occurrence of $x$ in the function body. Therefore, the count of evaluations for call-by-name is $c_{\\text{name}} = 3$.\n\n### Call-by-Need Evaluation\n\nUnder call-by-need, the argument is not evaluated upon application. Instead, a \"thunk\" (a placeholder for the computation) is created. The evaluation of the argument expression is triggered only when its value is first required. The result is then memoized (cached), and all subsequent uses of the variable will use this cached value, avoiding re-computation.\n\n$1$. The initial reduction step transforms the application into a `let` binding:\n$$(\\lambda x.\\, (x+x)+x)\\ E \\to \\mathbf{let}\\ x = E\\ \\mathbf{in}\\ (x+x)+x$$\nHere, $x$ is bound to a thunk representing the unevaluated expression $E \\equiv (1+1)+(1+1)$.\n\n$2$. The evaluation of the body, $(x+x)+x$, begins. As with call-by-name, the evaluation of the outermost `+` requires the evaluation of its left operand, $(x+x)$.\nTo evaluate $(x+x)$, we must first evaluate its left operand, the first $x$. This is the first time the value of $x$ is demanded (or \"forced\").\n**First and only evaluation of $x$**: The thunk associated with $x$ is evaluated.\n$E \\equiv (1+1)+(1+1) \\to 2+(1+1) \\to 2+2 \\to 4$.\nThe result, $4$, is cached. The binding for $x$ is now updated to the value $4$. This counts as one evaluation.\nThe expression we are evaluating, $(x+x)$, becomes $(4+x)$ with the knowledge that $x$ is now $4$.\n\n$3$. To evaluate the subexpression $(4+x)$, we need the value of its right operand, the second $x$.\nWhen this second occurrence of $x$ is accessed, the call-by-need mechanism finds that the thunk has already been evaluated. It simply retrieves the memoized value, $4$, without re-computing $E$.\nThe expression becomes $(4+4)$.\n\n$4$. The inner addition is performed:\n$4+4 \\to 8$.\nThe overall expression becomes $8+x$.\n\n$5$. To evaluate $8+x$, we need the value of the third $x$.\nAgain, the memoized value $4$ is retrieved directly. No new evaluation of $E$ occurs.\nThe expression becomes $8+4$.\n\n$6$. The final addition is performed:\n$8+4 \\to 12$.\n\nIn this strategy, the expensive computation of $E$ was performed only once, upon the first demand for the value of $x$. All subsequent demands were satisfied by the cached result. This sharing is the core difference from call-by-name. The number of evaluations for call-by-need is $c_{\\text{need}} = 1$.\n\nThe final answer is the pair of counts $(c_{\\text{name}}, c_{\\text{need}})$.\n$c_{\\text{name}} = 3$\n$c_{\\text{need}} = 1$\nThis is represented as the row matrix $\\begin{pmatrix} 3  1 \\end{pmatrix}$.", "answer": "$$\\boxed{\\begin{pmatrix} 3  1 \\end{pmatrix}}$$", "id": "3649720"}, {"introduction": "Lazy evaluation's demand-driven nature has a powerful consequence: arguments that are never used in a function's body are never evaluated at all. This practice uses a thought experiment involving an exception to make this non-evaluation directly observable. By analyzing a function that discards its argument, you can see how laziness avoids unnecessary or even problematic computations. [@problem_id:3649715]", "problem": "Consider a core call-by-need lambda calculus extended with exceptions. The expressions are formed from variables $x$, numeric literals such as $1$, lambda abstractions $\\lambda x.\\, t$, applications $t_1 t_2$, and an exception constructor $\\text{throw}\\ e$ that denotes raising the exception payload $e$ when evaluated. Assume the call-by-need strategy (also called lazy evaluation) implements arguments as thunks that are not evaluated until their bound variables are demanded in the function body, and that exceptions are raised only when the expression $\\text{throw}\\ e$ is itself evaluated. The key operational facts to use as a foundation are:\n- In call-by-name (CBN) and call-by-need (CBNeed), an application $(\\lambda x.\\, t)\\, u$ proceeds by entering $t$ with $x$ bound to $u$ (CBN) or to a thunk of $u$ (CBNeed). In either case, $u$ is not evaluated at the point of application.\n- Under call-by-need, a thunk is forced only when the bound variable is actually needed to continue evaluation of the body. If a bound variable is not used, its thunk is never forced.\n- The expression $\\text{throw}\\ e$ raises the exception payload $e$ precisely when $\\text{throw}\\ e$ is evaluated; raising does not occur merely due to the presence of $\\text{throw}\\ e$ as a subterm unless that subterm is actually evaluated.\n\nEvaluate the program $(\\lambda x.\\, 1)\\,(\\text{throw}\\ e)$ under call-by-need with the above exception semantics. Which statement best characterizes the observable behavior?\n\nA. The program evaluates to $1$, and the exception payload $e$ is not thrown because the argument is not needed and thus not evaluated.\n\nB. The program throws $e$ before function application completes, because arguments are evaluated prior to substitution in a lazy language.\n\nC. The program throws $e$ under call-by-need due to sharing, which forces the argument early to avoid duplication.\n\nD. The behavior is implementation-dependent; a typical lazy compiler may evaluate arguments to weak-head normal form and thus throw $e$, or it may skip evaluation and return $1$ depending on heuristics.", "solution": "The validity of the problem statement must be established before a solution is attempted.\n\n### Step 1: Extract Givens\nThe problem specifies the following:\n- **System:** A core call-by-need lambda calculus.\n- **Syntax:** Expressions are formed from variables $x$, numeric literals (e.g., $1$), lambda abstractions $\\lambda x.\\, t$, applications $t_1 t_2$, and an exception constructor $\\text{throw}\\ e$.\n- **Evaluation Strategy:** Call-by-need (lazy evaluation).\n- **Semantics of Application:** For an application $(\\lambda x.\\, t)\\, u$, the argument $u$ is not evaluated at the point of application. Instead, the variable $x$ is bound to a *thunk* of $u$ within the body $t$.\n- **Semantics of Argument Evaluation:** A thunk is forced (evaluated) only when its corresponding bound variable is needed to continue the evaluation of the function body. If a bound variable is not used, its thunk is never forced.\n- **Semantics of Exceptions:** The expression $\\text{throw}\\ e$ raises an exception with payload $e$ precisely when the expression $\\text{throw}\\ e$ is itself evaluated.\n- **Program to Evaluate:** $(\\lambda x.\\, 1)\\,(\\text{throw}\\ e)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is evaluated against the validation criteria.\n- **Scientifically Grounded:** The problem is firmly rooted in the principles of programming language theory and compiler design. The concepts of lambda calculus, call-by-need evaluation, thunks, and exception handling are standard and well-defined in this field. The specified semantics are consistent with formal operational semantics for such a language.\n- **Well-Posed:** The problem provides a specific program and a clear, unambiguous set of evaluation rules. Applying these rules will lead to a unique, deterministic outcome.\n- **Objective:** The language is formal and technical, free of subjective or ambiguous terminology.\n- **Completeness and Consistency:** The problem provides all the necessary definitions to evaluate the program. The description of call-by-need is internally consistent and aligns with its standard definition in computer science.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. It is a well-posed question within the domain of theoretical computer science. The solution can now be derived.\n\n### Derivation of the Correct Answer\n\nThe program to be evaluated is $(\\lambda x.\\, 1)\\,(\\text{throw}\\ e)$. This expression is a function application of the form $(\\lambda x.\\, t)\\, u$, where:\n- The function is $\\lambda x.\\, 1$.\n- The function body is $t = 1$.\n- The argument is $u = \\text{throw}\\ e$.\n\nThe evaluation proceeds according to the specified call-by-need strategy.\n\n1.  **Function Application:** As per the rules, the argument $\\text{throw}\\ e$ is **not** evaluated at the point of application. Instead, a thunk (a suspended computation) is created for the argument $\\text{throw}\\ e$, and the variable $x$ is bound to this thunk. The evaluation then proceeds to the function's body, $1$.\n\n2.  **Evaluation of the Body:** The body of the function is the expression $1$. This is a numeric literal, which is a value. The evaluation of a value is the value itself.\n\n3.  **Argument Usage:** To determine if the thunk for $x$ must be forced, we inspect the function body, $1$. The variable $x$ does not appear anywhere in the body. Therefore, the value of $x$ is not needed to complete the evaluation of the body.\n\n4.  **Thunk Forcing:** The problem states: \"Under call-by-need, a thunk is forced only when the bound variable is actually needed... If a bound variable is not used, its thunk is never forced.\" Since $x$ is not used, the thunk containing the expression $\\text{throw}\\ e$ is never forced (i.e., never evaluated).\n\n5.  **Exception Handling:** The problem specifies: \"The expression $\\text{throw}\\ e$ raises the exception payload $e$ precisely when $\\text{throw}\\ e$ is evaluated\". Since the thunk for $\\text{throw}\\ e$ is never evaluated, the expression $\\text{throw}\\ e$ is never evaluated. Consequently, the exception is not thrown.\n\n6.  **Final Result:** The evaluation of the function body $1$ completes successfully, yielding the value $1$. The argument thunk is simply discarded. The observable behavior of the program is that it returns the value $1$.\n\n### Option-by-Option Analysis\n\n**A. The program evaluates to $1$, and the exception payload $e$ is not thrown because the argument is not needed and thus not evaluated.**\nThis statement is a precise and accurate description of the evaluation process derived above. The body of the function is the constant $1$, which does not depend on the argument $x$. In a call-by-need system, this means the argument is never evaluated. Since the argument is the expression $\\text{throw}\\ e$, and its evaluation is what triggers the exception, the exception is never thrown. The program correctly returns $1$.\n**Verdict: Correct.**\n\n**B. The program throws $e$ before function application completes, because arguments are evaluated prior to substitution in a lazy language.**\nThis statement is factually incorrect. The premise \"arguments are evaluated prior to substitution in a lazy language\" describes an eager evaluation strategy like call-by-value, not a lazy one like call-by-need. The problem explicitly defines a lazy evaluation strategy where arguments are passed unevaluated as thunks.\n**Verdict: Incorrect.**\n\n**C. The program throws $e$ under call-by-need due to sharing, which forces the argument early to avoid duplication.**\nThis statement misunderstands the concept of sharing in call-by-need. Sharing (the \"need\" part of call-by-need, distinguishing it from call-by-name) ensures that if a thunked argument is used *multiple times*, it is evaluated at most once, and the result is shared. It does not force the evaluation of an argument that is never used at all. The trigger for evaluation is the *need* for the variable's value, not the sharing mechanism itself. Since the variable $x$ is never needed, sharing is irrelevant, and no evaluation occurs.\n**Verdict: Incorrect.**\n\n**D. The behavior is implementation-dependent; a typical lazy compiler may evaluate arguments to weak-head normal form and thus throw $e$, or it may skip evaluation and return $1$ depending on heuristics.**\nThis statement contradicts the premise of the problem. The problem asks for the evaluation based on a *core call-by-need lambda calculus* with precisely defined rules, not on the potentially complex and heuristic-driven optimizations of a specific real-world compiler. According to the specified formal semantics, the behavior is deterministic and not implementation-dependent. Evaluating an unused argument would be a violation of the call-by-need strategy as defined.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "3649715"}, {"introduction": "The sharing mechanism of call-by-need, while efficient, introduces complexities when combined with side effects. This exercise explores how sharing an impure computation can lead to different observable behaviors compared to re-evaluating it each time, thereby breaking a key principle of functional programming called referential transparency. Understanding this interaction is crucial for writing correct and predictable programs in languages that mix lazy evaluation with effects. [@problem_id:3649688]", "problem": "Consider a call-by-need (lazy) implementation of a first-order expression language with integers, addition, and a single binding construct. Expressions are given by the grammar $e ::= n \\mid e_1 + e_2 \\mid \\mathbf{let}\\ x = e\\ \\mathbf{in}\\ e' \\mid \\mathsf{tick}()$, where $n \\in \\mathbb{Z}$ is an integer literal and $\\mathsf{tick}()$ is a primitive operation with an effect. The operational intent is:\n- In $\\mathbf{let}\\ x = e\\ \\mathbf{in}\\ e'$, the implementation allocates a thunk for $e$; when $x$ is demanded, the thunk is forced, its result memoized, and all subsequent demands of $x$ read the memoized result (this is call-by-need sharing).\n- The primitive $\\mathsf{tick}()$ appends a distinguished event $\\star$ to a global log $L$ and returns the integer $1$. The observable behavior of an expression is its resulting integer value together with the final log sequence $L$; two expressions are observationally equivalent if they yield the same value and the same log sequence for all initial logs.\n\nA language is referentially transparent if substitution of equals for equals preserves observable behavior in all contexts. A compiler optimization that introduces sharing (for example, common subexpression elimination that rewrites duplicated subexpressions into a single $\\mathbf{let}$-bound thunk) is semantics-preserving in a referentially transparent setting, but may be unsound in the presence of effects.\n\nUsing only the above definitions as the starting point, reason about the following candidate counterexample and remedies. Let $E_1 \\triangleq \\mathsf{tick}() + \\mathsf{tick}()$ and $E_2 \\triangleq \\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$.\n\nSelect all statements that are correct:\n\nA. In the pure sublanguage without $\\mathsf{tick}()$, $E_1$ and $E_2$ would be contextually equivalent. When $\\mathsf{tick}()$’s log is observable, call-by-need sharing causes $E_2$ to emit exactly $1$ tick while $E_1$ emits exactly $2$. Therefore, a compiler that naively rewrites $E_1$ into $E_2$ (or performs equivalent common subexpression elimination) is unsound unless effects are ruled out.\n\nB. Under call-by-need with sharing, evaluating $\\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$ forces the thunk for $x$ independently at each use, causing two ticks; sharing does not change the number of effects in this case.\n\nC. A sufficient constraint to make sharing semantics-preserving is to enforce purity for shared thunks: the bound expression $e$ in $\\mathbf{let}\\ x = e\\ \\mathbf{in}\\ e'$ must be effect-free. An effect system can enforce this by typing $\\mathsf{tick}$ as effectful (for example, with type $\\mathsf{IO}\\ \\mathbb{Z}$), and permitting sharing only for expressions of pure type (for example, of type $\\mathbb{Z}$), or by requiring explicit effect encapsulation.\n\nD. Because call-by-name (no sharing) does not memoize, the difference between $E_1$ and $E_2$ disappears, which implies that common subexpression elimination is safe regardless of effects under any non-strict strategy.\n\nE. Instead of forbidding effects, one can prevent duplication of effectful thunks using a linear or uniqueness type discipline. Under such a constraint, $\\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$ would be rejected because $x$ is used twice, thereby blocking the counterexample and making sharing safe without requiring global purity.", "solution": "### Problem Validation\n\n**Step 1: Extract Givens**\n-   **Language Grammar**: Expressions are defined by $e ::= n \\mid e_1 + e_2 \\mid \\mathbf{let}\\ x = e\\ \\mathbf{in}\\ e' \\mid \\mathsf{tick}()$, where $n \\in \\mathbb{Z}$ is an integer literal.\n-   **Evaluation Strategy**: Call-by-need (lazy) implementation.\n-   **Semantics of $\\mathbf{let}$**: In $\\mathbf{let}\\ x = e\\ \\mathbf{in}\\ e'$, a thunk is allocated for $e$. When $x$ is first demanded, the thunk is forced, its result is memoized, and all subsequent demands for $x$ retrieve the memoized result. This is explicitly defined as call-by-need sharing.\n-   **Semantics of $\\mathsf{tick}()$**: The primitive operation $\\mathsf{tick}()$ appends a distinguished event $\\star$ to a global log $L$ and returns the integer value $1$.\n-   **Observable Behavior**: The outcome of an expression evaluation is the pair of its resulting integer value and the final state of the log sequence $L$.\n-   **Observational Equivalence**: Two expressions are deemed observationally equivalent if they produce the same integer value and the same final log sequence for all possible initial log states.\n-   **Referential Transparency (RT)**: RT holds if substituting an expression with an observationally equivalent one preserves the observable behavior of the enclosing program.\n-   **Optimization Context**: The problem considers common subexpression elimination (CSE), which may rewrite an expression with duplicated subexpressions into a form that uses a single `let`-bound thunk for the common part.\n-   **Candidate Expressions**:\n    -   $E_1 \\triangleq \\mathsf{tick}() + \\mathsf{tick}()$\n    -   $E_2 \\triangleq \\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$\n\n**Step 2: Validate Using Extracted Givens**\nThe problem statement is a standard theoretical exercise in the domain of programming language semantics and compiler theory. It precisely defines a simple functional language with effects, an evaluation strategy (call-by-need), and a notion of observable behavior. These definitions are internally consistent and grounded in established computer science principles. The question asks for a logical deduction about the properties of the system based on these definitions. The problem is well-posed, as the provided semantics are sufficient to uniquely determine the behavior of the expressions in question. It is objective and contains no scientific or factual unsoundness, non-formalizable concepts, or ambiguities.\n\n**Step 3: Verdict and Action**\nThe problem statement is **valid**. A solution can be derived from the provided definitions.\n\n### Derivation and Analysis\n\nWe first determine the observable behavior of expressions $E_1$ and $E_2$ according to the specified call-by-need semantics. Let the initial log be $L_0$.\n\n**Analysis of $E_1 \\triangleq \\mathsf{tick}() + \\mathsf{tick}()$**\nTo evaluate the sum, its operands must be evaluated. Assuming a standard left-to-right evaluation order for the arguments of the `$+$` operator:\n1.  The left operand, $\\mathsf{tick}()$, is evaluated. This appends $\\star$ to the log, so the log becomes $L_0 \\cdot \\langle\\star\\rangle$. The operation returns the value $1$.\n2.  The right operand, $\\mathsf{tick}()$, is evaluated. This appends another $\\star$ to the log, making it $L_0 \\cdot \\langle\\star, \\star\\rangle$. The operation returns the value $1$.\n3.  The addition $1 + 1$ is performed, yielding the final value $2$.\n\nThe observable behavior of $E_1$ is (value: $2$, final log: $L_0 \\cdot \\langle\\star, \\star\\rangle$). It adds exactly two events to the log.\n\n**Analysis of $E_2 \\triangleq \\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$**\nThe evaluation proceeds according to the call-by-need rules:\n1.  A thunk (a suspended computation) for the expression $\\mathsf{tick}()$ is created and bound to the variable $x$. No evaluation occurs at this stage, and the log remains $L_0$.\n2.  The body of the `let`-expression, $x + x$, is evaluated. This requires evaluating the operands of `$+$`.\n3.  The left operand, $x$, is demanded for the first time. The thunk bound to $x$ is forced (evaluated).\n4.  Evaluating the thunk's expression, $\\mathsf{tick}()$, appends $\\star$ to the log (log becomes $L_0 \\cdot \\langle\\star\\rangle$) and returns the value $1$.\n5.  Crucially, according to the call-by-need specification, this result ($1$) is **memoized**.\n6.  The right operand, $x$, is demanded. Since this is a subsequent demand, the implementation retrieves the memoized result, $1$, without re-evaluating the thunk. No new event is added to the log.\n7.  The addition $1 + 1$ is performed, yielding the final value $2$.\n\nThe observable behavior of $E_2$ is (value: $2$, final log: $L_0 \\cdot \\langle\\star\\rangle$). It adds exactly one event to the log.\n\n**Conclusion on Equivalence**\n$E_1$ and $E_2$ both evaluate to the integer $2$, but they produce different final logs. Therefore, they are not observationally equivalent.\n\n### Option-by-Option Analysis\n\n**A. In the pure sublanguage without $\\mathsf{tick}()$, $E_1$ and $E_2$ would be contextually equivalent. When $\\mathsf{tick}()$’s log is observable, call-by-need sharing causes $E_2$ to emit exactly $1$ tick while $E_1$ emits exactly $2$. Therefore, a compiler that naively rewrites $E_1$ into $E_2$ (or performs equivalent common subexpression elimination) is unsound unless effects are ruled out.**\n\n-   In a pure sublanguage (without $\\mathsf{tick}()$), let's consider an arbitrary pure expression $e_{pure}$ instead of $\\mathsf{tick}()$. The expressions would be $e_{pure} + e_{pure}$ and $\\mathbf{let}\\ x = e_{pure}\\ \\mathbf{in}\\ x + x$. In a pure setting, the only observable is the final value. Both expressions would compute the same value. The number of evaluations does not alter the observable behavior. Thus, they would be contextually equivalent.\n-   The second sentence states that $E_2$ emits one tick while $E_1$ emits two. Our derivation above confirms this is correct.\n-   The conclusion follows directly: since the transformation from an $E_1$-like expression to an $E_2$-like one changes the program's observable behavior, the transformation is unsound (i.e., not semantics-preserving). This is precisely the classic problem of combining sharing with side effects.\n-   **Verdict: Correct.**\n\n**B. Under call-by-need with sharing, evaluating $\\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$ forces the thunk for $x$ independently at each use, causing two ticks; sharing does not change the number of effects in this case.**\n\n-   This statement directly contradicts the problem's definition of call-by-need, which explicitly states that the result of forcing a thunk is \"memoized, and all subsequent demands of $x$ read the memoized result.\"\n-   The behavior described (forcing the thunk at each use) is characteristic of **call-by-name**, a non-strict strategy without memoization. Call-by-need is defined by its use of memoization (sharing) to avoid re-computation.\n-   Our analysis of $E_2$ showed that sharing is the very reason only one tick is produced.\n-   **Verdict: Incorrect.**\n\n**C. A sufficient constraint to make sharing semantics-preserving is to enforce purity for shared thunks: the bound expression $e$ in $\\mathbf{let}\\ x = e\\ \\mathbf{in}\\ e'$ must be effect-free. An effect system can enforce this by typing $\\mathsf{tick}$ as effectful (for example, with type $\\mathsf{IO}\\ \\mathbb{Z}$), and permitting sharing only for expressions of pure type (for example, of type $\\mathbb{Z}$), or by requiring explicit effect encapsulation.**\n\n-   The unsoundness arises because the shared expression $\\mathsf{tick}()$ has an observable side effect. If an expression $e$ is pure (effect-free), evaluating it multiple times is observationally indistinguishable from evaluating it once and reusing the result.\n-   Therefore, if the common subexpression elimination transformation is restricted to only pure expressions, it cannot change the observable behavior of the program.\n-   Using a type and effect system is a standard and robust method for enforcing such a purity distinction. An effectful computation like $\\mathsf{tick}()$ would be given a type that marks it as impure (e.g., $\\mathsf{IO}\\ \\mathbb{Z}$), while pure computations like integer arithmetic would have a pure type (e.g., $\\mathbb{Z}$). The compiler would then permit the sharing optimization only for expressions of a pure type. This is a sufficient condition to restore soundness.\n-   **Verdict: Correct.**\n\n**D. Because call-by-name (no sharing) does not memoize, the difference between $E_1$ and $E_2$ disappears, which implies that common subexpression elimination is safe regardless of effects under any non-strict strategy.**\n\n-   Let's analyze the premise under call-by-name (lazy evaluation without memoization).\n    -   $E_1 \\triangleq \\mathsf{tick}() + \\mathsf{tick}()$: Evaluation still requires evaluating both operands, resulting in two ticks and the value $2$.\n    -   $E_2 \\triangleq \\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$: This is equivalent to substituting the definition of $x$ at each use site, leading to the evaluation of $\\mathsf{tick}() + \\mathsf{tick}()$. This also results in two ticks and the value $2$.\n-   The premise is correct: under call-by-name, $E_1$ and $E_2$ are observationally equivalent.\n-   However, the implication is false. It claims that CSE is safe under *any* non-strict strategy. Call-by-need is also a non-strict strategy, and we have shown that under call-by-need, the transformation is *unsafe*. The safety under one non-strict strategy (call-by-name) does not imply safety under all of them.\n-   **Verdict: Incorrect.**\n\n**E. Instead of forbidding effects, one can prevent duplication of effectful thunks using a linear or uniqueness type discipline. Under such a constraint, $\\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$ would be rejected because $x$ is used twice, thereby blocking the counterexample and making sharing safe without requiring global purity.**\n\n-   This statement proposes an alternative solution based on linear types, where a variable must be used exactly once.\n-   In the expression $\\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$, the variable $x$ is used twice in the body. If $x$ were given a linear type (which would be appropriate for an effectful, non-duplicable resource), a linear type checker would reject this program as ill-typed.\n-   The CSE optimization rewrites $E_1$ to $E_2$. If the target language incorporates a linear type system, this transformation could be guarded by the type checker. The compiler would be allowed to perform CSE only if the resulting `let`-expression is well-typed. In this case, the transformation from $\\mathsf{tick}() + \\mathsf{tick}()$ to $\\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x+x$ would be disallowed because the latter violates linearity.\n-   This correctly blocks the unsound optimization without requiring that all shared expressions be pure. It controls how effectful bindings are *used* rather than forbidding them from being shared. This is a valid and well-established technique for managing effects safely.\n-   **Verdict: Correct.**", "answer": "$$\\boxed{ACE}$$", "id": "3649688"}]}