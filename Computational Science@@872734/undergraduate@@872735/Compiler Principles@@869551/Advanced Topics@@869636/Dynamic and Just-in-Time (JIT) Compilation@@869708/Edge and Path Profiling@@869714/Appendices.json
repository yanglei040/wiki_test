{"hands_on_practices": [{"introduction": "Path profiling begins with a fundamental challenge: how can we assign a unique identifier to every possible execution path? The Ball-Larus algorithm provides an elegant solution by assigning weights to the edges of a program's control flow graph in such a way that the sum of weights along any path is unique. This exercise provides a hands-on walk-through of this foundational algorithm, guiding you through the process of calculating edge weights and path IDs, and exploring how these assignments must be updated when the program's structure changes [@problem_id:3640199].", "problem": "Consider the Ball–Larus path profiling scheme for an acyclic Control Flow Graph (CFG), where a unique path identifier is computed as the sum of edge weights along any entry-to-exit path. The scheme ensures uniqueness by assigning edge weights based on the number of distinct paths from each node to the exit and a fixed order of outgoing edges at each branching node. Assume the standard Ball–Larus convention that the first outgoing edge of a node receives weight $0$, and subsequent weights reflect the cumulative number of paths that would be skipped by taking earlier outgoing edges, under a fixed out-edge order.\n\nYou are given the following synthetic CFG with entry node $S$ and exit node $X$:\n- Nodes: $S, A, B, C, D, E, F, X$.\n- Directed edges: $(S,A)$, $(A,B)$, $(A,C)$, $(B,D)$, $(B,E)$, $(C,F)$, $(D,X)$, $(E,X)$, $(F,X)$.\n- Fixed ordering of outgoing edges:\n  - At node $A$: first $(A,B)$, then $(A,C)$.\n  - At node $B$: first $(B,D)$, then $(B,E)$.\n  - All other nodes have a single outgoing edge.\n\nTasks:\n1. Using the Ball–Larus path profiling principles and the given out-edge orders, compute the original edge weights $w(e)$ for all edges in the CFG and the resulting path identifiers for all entry-to-exit paths.\n2. Now introduce a topological change by adding a new shortcut edge $e_{s} = (B,X)$, making node $B$ have three outgoing edges. Under a naive patch that preserves the previously computed weights on all original edges and sets $w(e_{s}) = 0$, determine whether path identifier collisions occur. If collisions occur, exhibit two distinct entry-to-exit paths whose computed identifiers are equal under this naive assignment.\n3. Recompute the edge weights $w'(e)$ for the modified CFG (including $e_{s}$) using the Ball–Larus path profiling principles with the following fixed ordering at node $B$: first $(B,D)$, then $(B,E)$, then $(B,X)$. Keep the ordering at node $A$ unchanged as specified above. Confirm that the recomputed weights restore uniqueness of path identifiers for all entry-to-exit paths.\n4. Define the reweighting cost as\n$$\nC \\;=\\; \\sum_{e \\in E_{\\text{orig}}} \\left| w'(e) - w(e) \\right|,\n$$\nwhere $E_{\\text{orig}}$ is the set of edges in the original CFG before adding $e_{s}$. Compute $C$ as a single real-valued number. No rounding is necessary. Express your final answer as a pure number with no units.\n\nYour final answer should be the value of $C$ only.", "solution": "The problem requires a step-by-step application and analysis of the Ball–Larus path profiling algorithm on a given acyclic Control Flow Graph (CFG). The solution is structured into four parts, corresponding to the four tasks in the problem statement.\n\nThe Ball–Larus algorithm consists of two main passes:\n1.  A bottom-up pass from the exit node to the entry node to compute `NumPaths(n)` for each node $n$, which is the number of distinct paths from $n$ to the exit node $X$. For a node $n$ with successors $s_1, s_2, \\ldots, s_k$, `NumPaths(n)` is given by $\\sum_{i=1}^{k} \\text{NumPaths}(s_i)$. By definition, $\\text{NumPaths}(X) = 1$.\n2.  A top-down pass from the entry node to the exit node to assign a weight $w(e)$ to each edge $e = (u,v)$. At each node $u$ with outgoing edges $(u, v_1), (u, v_2), \\ldots, (u, v_k)$ in a fixed order, the weights are assigned as $w(u, v_1) = 0$ and $w(u, v_i) = \\sum_{j=1}^{i-1} \\text{NumPaths}(v_j)$ for $i > 1$.\n\nThe path identifier for any entry-to-exit path is the sum of the weights of the edges constituting that path.\n\n### Task 1: Original Edge Weights and Path Identifiers\n\nFirst, we compute `NumPaths(n)` for all nodes $n$ in the original CFG.\n-   Nodes: $S, A, B, C, D, E, F, X$.\n-   Exit node: $X$.\n-   By definition, $\\text{NumPaths}(X) = 1$.\n-   Working backwards from $X$:\n    -   $\\text{NumPaths}(D) = \\text{NumPaths}(X) = 1$.\n    -   $\\text{NumPaths}(E) = \\text{NumPaths}(X) = 1$.\n    -   $\\text{NumPaths}(F) = \\text{NumPaths}(X) = 1$.\n    -   $\\text{NumPaths}(C) = \\text{NumPaths}(F) = 1$.\n    -   $\\text{NumPaths}(B) = \\text{NumPaths}(D) + \\text{NumPaths}(E) = 1 + 1 = 2$.\n    -   $\\text{NumPaths}(A) = \\text{NumPaths}(B) + \\text{NumPaths}(C) = 2 + 1 = 3$.\n    -   $\\text{NumPaths}(S) = \\text{NumPaths}(A) = 3$.\nThis indicates there are $3$ unique paths from entry $S$ to exit $X$.\n\nNext, we compute the edge weights $w(e)$.\n-   Node $S$: Single outgoing edge $(S,A)$. Thus, $w(S,A)=0$.\n-   Node $A$: Outgoing edges ordered as $(A,B), (A,C)$.\n    -   $w(A,B) = 0$ (first edge).\n    -   $w(A,C) = \\text{NumPaths}(B) = 2$.\n-   Node $B$: Outgoing edges ordered as $(B,D), (B,E)$.\n    -   $w(B,D) = 0$ (first edge).\n    -   $w(B,E) = \\text{NumPaths}(D) = 1$.\n-   Nodes $C, D, E, F$ each have a single outgoing edge, so their weights are $0$.\n    -   $w(C,F) = 0$, $w(D,X) = 0$, $w(E,X) = 0$, $w(F,X) = 0$.\n\nThe original edge weights $w(e)$ are:\n$w(S,A)=0$, $w(A,B)=0$, $w(A,C)=2$, $w(B,D)=0$, $w(B,E)=1$, $w(C,F)=0$, $w(D,X)=0$, $w(E,X)=0$, $w(F,X)=0$.\n\nThe identifiers for the $3$ paths are:\n1.  Path $P_1: S \\to A \\to B \\to D \\to X$. Path ID = $w(S,A) + w(A,B) + w(B,D) + w(D,X) = 0 + 0 + 0 + 0 = 0$.\n2.  Path $P_2: S \\to A \\to B \\to E \\to X$. Path ID = $w(S,A) + w(A,B) + w(B,E) + w(E,X) = 0 + 0 + 1 + 0 = 1$.\n3.  Path $P_3: S \\to A \\to C \\to F \\to X$. Path ID = $w(S,A) + w(A,C) + w(C,F) + w(F,X) = 0 + 2 + 0 + 0 = 2$.\nThe path identifiers are $0, 1, 2$, which are unique.\n\n### Task 2: Analysis of the Naive Patch After Adding Edge $e_s = (B,X)$\n\nA new edge $e_s=(B,X)$ is added. A naive patch keeps all original weights $w(e)$ and sets $w(e_s) = 0$. This introduces a new path $P_4: S \\to A \\to B \\to X$. Let's compute the path identifiers in this modified graph with the naive weights.\n-   ID($P_1: S \\to A \\to B \\to D \\to X$) = $w(S,A) + w(A,B) + w(B,D) + w(D,X) = 0 + 0 + 0 + 0 = 0$.\n-   ID($P_2: S \\to A \\to B \\to E \\to X$) = $w(S,A) + w(A,B) + w(B,E) + w(E,X) = 0 + 0 + 1 + 0 = 1$.\n-   ID($P_3: S \\to A \\to C \\to F \\to X$) = $w(S,A) + w(A,C) + w(C,F) + w(F,X) = 0 + 2 + 0 + 0 = 2$.\n-   ID($P_4: S \\to A \\to B \\to X$) = $w(S,A) + w(A,B) + w(B,X) = 0 + 0 + 0 = 0$.\n\nA collision occurs. Two distinct paths have the same identifier $0$:\n-   Colliding Path 1: $S \\to A \\to B \\to D \\to X$.\n-   Colliding Path 2: $S \\to A \\to B \\to X$.\n\n### Task 3: Recomputation of Weights for the Modified CFG\n\nWe re-run the Ball–Larus algorithm on the modified CFG, which includes edge $(B,X)$.\nThe new ordering for outgoing edges at $B$ is $(B,D), (B,E), (B,X)$.\n\nFirst, we recompute `NumPaths'(n)` for the modified graph.\n-   $\\text{NumPaths'}(X) = 1$.\n-   $\\text{NumPaths'}(D) = 1$, $\\text{NumPaths'}(E) = 1$, $\\text{NumPaths'}(F) = 1$.\n-   $\\text{NumPaths'}(C) = \\text{NumPaths'}(F) = 1$.\n-   Node $B$ now has successors $D, E, X$.\n    $\\text{NumPaths'}(B) = \\text{NumPaths'}(D) + \\text{NumPaths'}(E) + \\text{NumPaths'}(X) = 1 + 1 + 1 = 3$.\n-   Node $A$ has successors $B, C$.\n    $\\text{NumPaths'}(A) = \\text{NumPaths'}(B) + \\text{NumPaths'}(C) = 3 + 1 = 4$.\n-   $\\text{NumPaths'}(S) = \\text{NumPaths'}(A) = 4$.\nThere are now $4$ unique paths from $S$ to $X$.\n\nNext, we recompute the edge weights $w'(e)$.\n-   Node $S$: Single edge $(S,A) \\implies w'(S,A)=0$.\n-   Node $A$: Edges $(A,B), (A,C)$.\n    -   $w'(A,B) = 0$.\n    -   $w'(A,C) = \\text{NumPaths'}(B) = 3$.\n-   Node $B$: Edges $(B,D), (B,E), (B,X)$.\n    -   $w'(B,D) = 0$.\n    -   $w'(B,E) = \\text{NumPaths'}(D) = 1$.\n    -   $w'(B,X) = \\text{NumPaths'}(D) + \\text{NumPaths'}(E) = 1 + 1 = 2$.\n-   Nodes $C, D, E, F$: Single edge each $\\implies$ weights are $0$.\n    -   $w'(C,F) = 0$, $w'(D,X) = 0$, $w'(E,X) = 0$, $w'(F,X) = 0$.\n\nThe new identifiers for the $4$ paths are:\n1.  Path $P'_1: S \\to A \\to B \\to D \\to X$. ID = $w'(S,A) + w'(A,B) + w'(B,D) + w'(D,X) = 0+0+0+0 = 0$.\n2.  Path $P'_2: S \\to A \\to B \\to E \\to X$. ID = $w'(S,A) + w'(A,B) + w'(B,E) + w'(E,X) = 0+0+1+0 = 1$.\n3.  Path $P'_3: S \\to A \\to B \\to X$. ID = $w'(S,A) + w'(A,B) + w'(B,X) = 0+0+2 = 2$.\n4.  Path $P'_4: S \\to A \\to C \\to F \\to X$. ID = $w'(S,A) + w'(A,C) + w'(C,F) + w'(F,X) = 0+3+0+0 = 3$.\nThe path identifiers $0, 1, 2, 3$ are unique, confirming that re-running the algorithm restores correctness.\n\n### Task 4: Calculation of the Reweighting Cost $C$\n\nThe reweighting cost is defined as $C = \\sum_{e \\in E_{\\text{orig}}} | w'(e) - w(e) |$, where $E_{\\text{orig}}$ is the set of edges in the original CFG. We compare the new weights $w'(e)$ with the original weights $w(e)$ for each of the $9$ original edges.\n\n-   $e = (S,A)$: $|w'(S,A) - w(S,A)| = |0 - 0| = 0$.\n-   $e = (A,B)$: $|w'(A,B) - w(A,B)| = |0 - 0| = 0$.\n-   $e = (A,C)$: $|w'(A,C) - w(A,C)| = |3 - 2| = 1$. This is because the weight of this edge depends on $\\text{NumPaths}(B)$, which changed from $2$ to $3$.\n-   $e = (B,D)$: $|w'(B,D) - w(B,D)| = |0 - 0| = 0$.\n-   $e = (B,E)$: $|w'(B,E) - w(B,E)| = |1 - 1| = 0$. The weight depends on $\\text{NumPaths}(D)$, which did not change.\n-   $e = (C,F)$: $|w'(C,F) - w(C,F)| = |0 - 0| = 0$.\n-   $e = (D,X)$: $|w'(D,X) - w(D,X)| = |0 - 0| = 0$.\n-   $e = (E,X)$: $|w'(E,X) - w(E,X)| = |0 - 0| = 0$.\n-   $e = (F,X)$: $|w'(F,X) - w(F,X)| = |0 - 0| = 0$.\n\nThe total reweighting cost $C$ is the sum of these absolute differences:\n$$ C = 0 + 0 + 1 + 0 + 0 + 0 + 0 + 0 + 0 = 1 $$\n\nThe cost is $1$, solely due to the change in weight of edge $(A,C)$, which is upstream of the structural modification at node $B$.", "answer": "$$\\boxed{1}$$", "id": "3640199"}, {"introduction": "While algorithmic methods like Ball-Larus assign path IDs, another approach is to identify paths by observing their \"signatures\"—the set of instrumented counters they trigger. This raises a critical design question: where should we place counters to minimize performance overhead while still gathering enough information to tell paths apart? This practice challenges you to formalize this as an optimization problem, using Integer Linear Programming (ILP) to find the most cost-effective instrumentation strategy that can uniquely distinguish a given set of important program paths [@problem_id:3640258].", "problem": "Consider a control-flow graph $G=(V,E)$ with entry node $s$ and exit node $t$. A set of acyclic, entry-to-exit paths $\\mathcal{P}$ is given. Each edge $e \\in E$ has a nonnegative instrumentation overhead cost $w_{e}$, and you may place a hardware counter on edge $e$ (modeled by a binary decision variable $y_{e} \\in \\{0,1\\}$) that increments by $1$ whenever $e$ is traversed. For any path $p \\in \\mathcal{P}$, its counter signature is the vector of counter values along the instrumented edges, obtained by concatenating the per-edge counts in a fixed edge ordering. Assume each path in $\\mathcal{P}$ traverses any edge at most once.\n\nStarting from fundamental definitions of control-flow graphs and path profiling, formalize an Integer Linear Programming (ILP) model that chooses a subset of edges to instrument so that the counter signatures of all distinct paths in $\\mathcal{P}$ are unique, while minimizing the total overhead $\\sum_{e \\in E} w_{e} y_{e}$. Then, for the specific instance below, solve the ILP and report the minimal total overhead as a single real number.\n\nInstance specification:\n- Edges and costs: $E=\\{e_{1},e_{2},e_{3},e_{4},e_{5}\\}$ with $w_{e_{1}}=2$, $w_{e_{2}}=4$, $w_{e_{3}}=3$, $w_{e_{4}}=1$, $w_{e_{5}}=5$.\n- Paths: $\\mathcal{P}=\\{p_{1},p_{2},p_{3},p_{4}\\}$ where $p_{1}=(e_{1},e_{2},e_{5})$, $p_{2}=(e_{1},e_{3},e_{5})$, $p_{3}=(e_{4},e_{2},e_{5})$, and $p_{4}=(e_{4},e_{3},e_{5})$.\n\nYour answer must be the minimal total overhead value of the optimal instrumentation, expressed as a single real number. Do not include units. If you choose to approximate, justify why approximation is necessary and round to a stated number of significant figures. Otherwise, provide the exact value.", "solution": "First, we formalize the general Integer Linear Programming (ILP) model. Let $y_e \\in \\{0, 1\\}$ be the binary decision variable for each edge $e \\in E$, where $y_e=1$ if edge $e$ is instrumented with a counter, and $y_e=0$ otherwise. The total instrumentation overhead is the sum of the costs of the instrumented edges. The objective function is to minimize this total cost:\n$$\n\\text{Minimize} \\quad Z = \\sum_{e \\in E} w_e y_e\n$$\nThe primary constraint is that the counter signatures for any two distinct paths must be unique. Let $p_i$ and $p_j$ be two distinct paths in $\\mathcal{P}$ ($i \\neq j$). The counter signature for a path is the vector of counter readings from the instrumented edges. Given the assumption that each path is simple (traverses an edge at most once), the counter on an instrumented edge $e$ will read $1$ if $e \\in p_i$ and $0$ if $e \\notin p_i$.\n\nFor the signatures of $p_i$ and $p_j$ to be different, there must be at least one instrumented edge $e$ (i.e., $y_e = 1$) that is in one path but not the other. The set of edges that can distinguish between $p_i$ and $p_j$ is their symmetric difference, denoted $p_i \\Delta p_j = (p_i \\cup p_j) \\setminus (p_i \\cap p_j)$.\nTo ensure distinguishability for the pair $(p_i, p_j)$, we must instrument at least one edge from their symmetric difference. This can be expressed as a linear inequality:\n$$\n\\sum_{e \\in p_i \\Delta p_j} y_e \\ge 1\n$$\nThis constraint must hold for every pair of distinct paths in $\\mathcal{P}$.\n\nThe complete ILP model is:\n- **Decision Variables**: $y_e \\in \\{0, 1\\}$ for all $e \\in E$.\n- **Objective Function**: Minimize $Z = \\sum_{e \\in E} w_e y_e$.\n- **Constraints**: For every pair of distinct paths $(p_i, p_j) \\in \\mathcal{P} \\times \\mathcal{P}$ with $i \\neq j$,\n$$\n\\sum_{e \\in p_i \\Delta p_j} y_e \\ge 1\n$$\n\n### Solving the Specific Instance\nWe now apply this model to the provided instance.\nThe set of edges is $E=\\{e_{1},e_{2},e_{3},e_{4},e_{5}\\}$ with costs $w_{e_{1}}=2$, $w_{e_{2}}=4$, $w_{e_{3}}=3$, $w_{e_{4}}=1$, $w_{e_{5}}=5$.\nThe set of paths is $\\mathcal{P}=\\{p_{1},p_{2},p_{3},p_{4}\\}$:\n- $p_{1} = \\{e_{1},e_{2},e_{5}\\}$\n- $p_{2} = \\{e_{1},e_{3},e_{5}\\}$\n- $p_{3} = \\{e_{4},e_{2},e_{5}\\}$\n- $p_{4} = \\{e_{4},e_{3},e_{5}\\}$\n\nThe objective function to minimize is:\n$$\nZ = 2y_{e_{1}} + 4y_{e_{2}} + 3y_{e_{3}} + y_{e_{4}} + 5y_{e_{5}}\n$$\nWe must generate a constraint for each unique pair of paths from $\\mathcal{P}$. There are $\\binom{4}{2}=6$ such pairs.\n\n1.  **Pair $(p_1, p_2)$**:\n    $p_1 \\Delta p_2 = (\\{e_1,e_2,e_5\\} \\cup \\{e_1,e_3,e_5\\}) \\setminus (\\{e_1,e_2,e_5\\} \\cap \\{e_1,e_3,e_5\\}) = \\{e_1,e_2,e_3,e_5\\} \\setminus \\{e_1,e_5\\} = \\{e_2,e_3\\}$.\n    Constraint (C1): $y_{e_2} + y_{e_3} \\ge 1$.\n\n2.  **Pair $(p_1, p_3)$**:\n    $p_1 \\Delta p_3 = (\\{e_1,e_2,e_5\\} \\cup \\{e_4,e_2,e_5\\}) \\setminus (\\{e_1,e_2,e_5\\} \\cap \\{e_4,e_2,e_5\\}) = \\{e_1,e_2,e_4,e_5\\} \\setminus \\{e_2,e_5\\} = \\{e_1,e_4\\}$.\n    Constraint (C2): $y_{e_1} + y_{e_4} \\ge 1$.\n\n3.  **Pair $(p_1, p_4)$**:\n    $p_1 \\Delta p_4 = (\\{e_1,e_2,e_5\\} \\cup \\{e_4,e_3,e_5\\}) \\setminus (\\{e_1,e_2,e_5\\} \\cap \\{e_4,e_3,e_5\\}) = \\{e_1,e_2,e_3,e_4,e_5\\} \\setminus \\{e_5\\} = \\{e_1,e_2,e_3,e_4\\}$.\n    Constraint (C3): $y_{e_1} + y_{e_2} + y_{e_3} + y_{e_4} \\ge 1$.\n\n4.  **Pair $(p_2, p_3)$**:\n    $p_2 \\Delta p_3 = (\\{e_1,e_3,e_5\\} \\cup \\{e_4,e_2,e_5\\}) \\setminus (\\{e_1,e_3,e_5\\} \\cap \\{e_4,e_2,e_5\\}) = \\{e_1,e_2,e_3,e_4,e_5\\} \\setminus \\{e_5\\} = \\{e_1,e_2,e_3,e_4\\}$.\n    Constraint (C4): $y_{e_1} + y_{e_2} + y_{e_3} + y_{e_4} \\ge 1$. (This is identical to C3).\n\n5.  **Pair $(p_2, p_4)$**:\n    $p_2 \\Delta p_4 = (\\{e_1,e_3,e_5\\} \\cup \\{e_4,e_3,e_5\\}) \\setminus (\\{e_1,e_3,e_5\\} \\cap \\{e_4,e_3,e_5\\}) = \\{e_1,e_3,e_4,e_5\\} \\setminus \\{e_3,e_5\\} = \\{e_1,e_4\\}$.\n    Constraint (C5): $y_{e_1} + y_{e_4} \\ge 1$. (This is identical to C2).\n\n6.  **Pair $(p_3, p_4)$**:\n    $p_3 \\Delta p_4 = (\\{e_4,e_2,e_5\\} \\cup \\{e_4,e_3,e_5\\}) \\setminus (\\{e_4,e_2,e_5\\} \\cap \\{e_4,e_3,e_5\\}) = \\{e_2,e_3,e_4,e_5\\} \\setminus \\{e_4,e_5\\} = \\{e_2,e_3\\}$.\n    Constraint (C6): $y_{e_2} + y_{e_3} \\ge 1$. (This is identical to C1).\n\nThe set of unique constraints is:\n- (C1): $y_{e_2} + y_{e_3} \\ge 1$\n- (C2): $y_{e_1} + y_{e_4} \\ge 1$\n- (C3): $y_{e_1} + y_{e_2} + y_{e_3} + y_{e_4} \\ge 1$\n\nWe observe that if (C1) and (C2) are satisfied, then at least one term in each is $1$. For instance, let $y_{e_i} \\ge 1$ for $e_i \\in \\{e_2, e_3\\}$ and $y_{e_j} \\ge 1$ for $e_j \\in \\{e_1, e_4\\}$. Then the sum in (C3) must be at least $1+1=2$ (since variables are non-negative), which is greater than $1$. Therefore, constraint (C3) is redundant and can be removed. The problem simplifies to:\n$$\n\\text{Minimize} \\quad Z = 2y_{e_{1}} + 4y_{e_{2}} + 3y_{e_{3}} + y_{e_{4}} + 5y_{e_{5}}\n$$\nSubject to:\n$$\ny_{e_2} + y_{e_3} \\ge 1 \\\\\ny_{e_1} + y_{e_4} \\ge 1 \\\\\ny_e \\in \\{0,1\\} \\text{ for } e \\in E\n$$\nThe objective function is a sum of positive terms. To minimize $Z$, we should set as many $y_e$ variables to $0$ as possible.\nThe variable $y_{e_5}$ does not appear in any constraint. Since its cost $w_{e_{5}}=5$ is positive, we must set $y_{e_5}=0$ in any optimal solution.\n\nThe remaining problem can be decomposed into two independent subproblems because the constraints operate on disjoint sets of variables:\nSubproblem 1: Minimize $4y_{e_{2}} + 3y_{e_{3}}$ subject to $y_{e_2} + y_{e_3} \\ge 1$.\n- Option (a): $y_{e_2}=1, y_{e_3}=0$. Cost contribution: $4(1) + 3(0) = 4$.\n- Option (b): $y_{e_2}=0, y_{e_3}=1$. Cost contribution: $4(0) + 3(1) = 3$.\n- Option (c): $y_{e_2}=1, y_{e_3}=1$. Cost contribution: $4(1) + 3(1) = 7$.\nThe minimum cost for this subproblem is $3$, achieved by setting $y_{e_2}=0$ and $y_{e_3}=1$.\n\nSubproblem 2: Minimize $2y_{e_{1}} + y_{e_{4}}$ subject to $y_{e_1} + y_{e_4} \\ge 1$.\n- Option (a): $y_{e_1}=1, y_{e_4}=0$. Cost contribution: $2(1) + 1(0) = 2$.\n- Option (b): $y_{e_1}=0, y_{e_4}=1$. Cost contribution: $2(0) + 1(1) = 1$.\n- Option (c): $y_{e_1}=1, y_{e_4}=1$. Cost contribution: $2(1) + 1(1) = 3$.\nThe minimum cost for this subproblem is $1$, achieved by setting $y_{e_1}=0$ and $y_{e_4}=1$.\n\nCombining the optimal solutions for the subproblems and including $y_{e_5}=0$, the overall optimal solution is:\n$y_{e_1}=0$, $y_{e_2}=0$, $y_{e_3}=1$, $y_{e_4}=1$, $y_{e_5}=0$.\nThis means we should instrument edges $e_3$ and $e_4$.\n\nThe minimal total overhead is the sum of the costs from the optimal solutions of the subproblems:\n$$\nZ_{min} = (4y_{e_{2}} + 3y_{e_{3}}) + (2y_{e_{1}} + y_{e_{4}}) + (5y_{e_{5}})\n$$\n$$\nZ_{min} = (3) + (1) + (0) = 4\n$$\nThe minimal total overhead is $4$. This corresponds to instrumenting edges $e_3$ (cost $3$) and $e_4$ (cost $1$).\nWith edges $e_3$ and $e_4$ instrumented, the signatures are:\n- $p_1$: contains neither $e_3$ nor $e_4$. Signature: $(0,0)$.\n- $p_2$: contains $e_3$ but not $e_4$. Signature: $(1,0)$.\n- $p_3$: contains $e_4$ but not $e_3$. Signature: $(0,1)$.\n- $p_4$: contains both $e_3$ and $e_4$. Signature: $(1,1)$.\nAll four signatures are unique, confirming the correctness of the solution.", "answer": "$$\\boxed{4}$$", "id": "3640258"}, {"introduction": "After mastering techniques to gather detailed path information, we can explore its true value. Why is knowing the exact path taken more powerful than just counting how many times each branch is taken? This practice demonstrates the payoff by contrasting path profiling with simpler edge profiling, revealing how only the former can uncover deep correlations between different branches. You will see how this insight enables aggressive and sound compiler optimizations that would otherwise be impossible [@problem_id:3640289].", "problem": "Consider the following Control Flow Graph (CFG) for a procedure, where nodes are Basic Blocks (BB) and directed edges represent possible control transfers. The entry is $S$ and the exit is $W$.\n\n- $S \\rightarrow B_1$.\n- $B_1$ branches on a predicate $P$: the true edge goes to $B_2$ and the false edge goes to $B_3$.\n- $B_2$ and $B_3$ are straight-line code (e.g., calls to side-effecting functions) and both flow into $B_5$.\n- $B_5$ branches on a predicate $Q$: the true edge goes to $U$ and the false edge goes to $V$.\n- $U \\rightarrow W$ and $V \\rightarrow W$.\n\nAssume the following are given.\n\n1) Definitions (fundamental base):\n- A Control Flow Graph (CFG) is a directed graph $G=(V,E)$ with vertices $V$ as basic blocks and edges $E$ as possible control-flow transfers; an execution corresponds to a path in $G$.\n- Edge profiling (EP) records, for each edge $e \\in E$, the number of times $e$ is traversed. It captures marginal frequencies of individual edges.\n- Path profiling (PP) records, for each acyclic path $\\pi$ in a designated region of $G$, the number of times $\\pi$ is executed. It captures joint frequencies for sequences of edges and can reveal correlations between branch outcomes that EP alone cannot.\n- A transformation is sound if for all program inputs it preserves the observable semantics; when using profiling, soundness can be preserved by guarded versioning: execute a specialized version along a predicted-hot path only under a run-time guard that ensures semantic equivalence, and otherwise fall back to the original.\n\n2) Measured profiling data over a representative workload:\n- Edge profiling counts at $B_1$: the true edge is taken $600$ times and the false edge is taken $400$ times.\n- Edge profiling counts at $B_5$: the true edge is taken $400$ times and the false edge is taken $600$ times.\n- Path profiling identifies two frequently executed acyclic paths and their counts:\n  - $p^* = \\langle S, B_1^{\\text{true}}, B_2, B_5^{\\text{false}}, V, W \\rangle$ executed $600$ times.\n  - $p' = \\langle S, B_1^{\\text{false}}, B_3, B_5^{\\text{true}}, U, W \\rangle$ executed $400$ times.\n  - The two complementary combinations $\\langle S, B_1^{\\text{true}}, B_2, B_5^{\\text{true}}, U, W \\rangle$ and $\\langle S, B_1^{\\text{false}}, B_3, B_5^{\\text{false}}, V, W \\rangle$ are observed $0$ times.\n\nIntuitively, the path profiling reveals a strong mutual exclusivity correlation between the outcomes at $B_1$ and $B_5$ in the observed executions: along the hot path $p^*$, whenever $P$ is true upstream, $Q$ is subsequently false at $B_5$. Edge counts alone do not expose this correlation because they provide only marginal frequencies for $B_1$ and $B_5$ independently.\n\nYour goal is to exploit this information to remove the dynamic check at $B_5$ on the hot path $p^*$ while preserving correctness for all inputs.\n\nWhich of the following compiler transformations is sound and uses the path profiling information to remove the redundant check at $B_5$ along $p^*$?\n\nA. Use only edge profiling to infer that $B_1^{\\text{true}}$ implies $B_5^{\\text{false}}$, and replace the branch at $B_5$ with an unconditional jump to $V$ whenever the immediate predecessor is $B_2$.\n\nB. Clone the region forming $p^*$ into a specialized trace version $T^*$ entered from $B_1^{\\text{true}}$. Insert at the head of $T^*$ a run-time guard that evaluates $Q$ and checks $Q=\\text{false}$; if the guard passes, bypass $B_5$ and jump directly to $V$ (deleting the $Q$ test in $T^*$), otherwise branch to the original code. Keep the original CFG intact as a fallback.\n\nC. From the path profiling, infer the invariant $Q \\equiv \\lnot P$ and eliminate both branches at $B_1$ and $B_5$ globally by constant-folding successors accordingly.\n\nD. Reorder basic blocks to place $B_2 \\rightarrow B_5 \\rightarrow V$ contiguously in memory (layout optimization), but leave all branches in place unchanged.\n\nSelect the correct option(s).", "solution": "The user wants me to validate and solve a problem concerning compiler optimizations, specifically contrasting edge profiling with path profiling to enable a sound transformation.\n\n### Step 1: Extract Givens\n\n- **Control Flow Graph (CFG) Structure:**\n  - A directed graph with entry $S$ and exit $W$.\n  - $S \\rightarrow B_1$.\n  - $B_1$ is a conditional branch on predicate $P$. The true edge is $B_1 \\rightarrow B_2$ and the false edge is $B_1 \\rightarrow B_3$.\n  - $B_2 \\rightarrow B_5$ and $B_3 \\rightarrow B_5$.\n  - $B_5$ is a conditional branch on predicate $Q$. The true edge is $B_5 \\rightarrow U$ and the false edge is $B_5 \\rightarrow V$.\n  - $U \\rightarrow W$ and $V \\rightarrow W$.\n\n- **Definitions:**\n  - **Edge Profiling (EP):** Records traversal count for each edge $e$.\n  - **Path Profiling (PP):** Records execution count for each acyclic path $\\pi$. It can reveal correlations that EP cannot.\n  - **Sound Transformation:** A transformation that preserves observable semantics for all program inputs. Soundness with profiling can be achieved by \"guarded versioning,\" which uses a run-time guard to check conditions before executing a specialized, optimized version of the code, with a fallback to the original unoptimized code.\n\n- **Profiling Data:**\n  - EP at $B_1$: $B_1 \\xrightarrow{\\text{true}} B_2$ is taken $600$ times. $B_1 \\xrightarrow{\\text{false}} B_3$ is taken $400$ times.\n  - EP at $B_5$: $B_5 \\xrightarrow{\\text{true}} U$ is taken $400$ times. $B_5 \\xrightarrow{\\text{false}} V$ is taken $600$ times.\n  - PP data:\n    - Path $p^* = \\langle S, B_1^{\\text{true}}, B_2, B_5^{\\text{false}}, V, W \\rangle$ executed $600$ times.\n    - Path $p' = \\langle S, B_1^{\\text{false}}, B_3, B_5^{\\text{true}}, U, W \\rangle$ executed $400$ times.\n    - Path $\\langle S, B_1^{\\text{true}}, B_2, B_5^{\\text{true}}, U, W \\rangle$ executed $0$ times.\n    - Path $\\langle S, B_1^{\\text{false}}, B_3, B_5^{\\text{false}}, V, W \\rangle$ executed $0$ times.\n\n- **Goal:**\n  - To exploit the path profiling data to remove the dynamic check of predicate $Q$ at $B_5$ when on the hot path $p^*$, while ensuring the transformation is sound.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientific Grounding:** The problem is firmly based on established principles of compiler design, specifically profile-guided optimization, control flow analysis, and code transformation techniques like trace specialization. The concepts of edge profiling, path profiling, and soundness are central to this field. The problem is scientifically sound.\n- **Well-Posed:** The CFG is unambiguously defined. The profiling data is explicit and internally consistent. For example, the total flow through $B_1$ is $600+400=1000$. The total flow through $B_5$ is also $600+400=1000$. The path counts sum to the total execution count ($600+400+0+0=1000$) and are consistent with the edge counts (e.g., edge $B_1 \\rightarrow B_2$ count of $600$ matches the sum of paths starting with $B_1^{\\text{true}}$, which is $600+0=600$). The goal is clear and specific.\n- **Objectivity:** The problem is stated using precise, technical terminology from computer science. There are no subjective or ambiguous statements.\n- **Flaw Checklist:**\n  1. **Scientific/Factual Unsoundness:** None.\n  2. **Non-Formalizable/Irrelevant:** None. The problem is a classic, formalizable compiler optimization problem.\n  3. **Incomplete/Contradictory Setup:** None. The data is complete and consistent.\n  4. **Unrealistic/Infeasible:** None. Correlated branches are a common occurrence in programs, and the described optimization techniques are realistic.\n  5. **Ill-Posed/Poorly Structured:** None. The problem is well-structured.\n  6. **Pseudo-Profound/Trivial:** None. The problem requires understanding the crucial difference between edge and path profiling and the concept of soundness in optimization.\n  7. **Outside Scientific Verifiability:** None.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. It is a well-formed, consistent, and scientifically grounded problem in the domain of compiler principles. I will now proceed with the solution derivation and option analysis.\n\n### Solution Derivation\n\nThe core of the problem lies in the distinction between what can be inferred from edge profiling versus path profiling, and how to use this information to perform a *sound* optimization.\n\n1.  **Information from Profiling:**\n    - Edge profiling shows that the branch at $B_1$ is taken with probabilities $(\\text{true}: 0.6, \\text{false}: 0.4)$ and the branch at $B_5$ is taken with probabilities $(\\text{true}: 0.4, \\text{false}: 0.6)$. If the branches were independent, we would expect the path $B_1^{\\text{true}} \\to \\dots \\to B_5^{\\text{false}}$ to be taken $1000 \\times 0.6 \\times 0.6 = 360$ times.\n    - Path profiling reveals a strong correlation. The path $p^* = \\langle S, B_1^{\\text{true}}, \\dots, B_5^{\\text{false}}, \\dots \\rangle$ is taken $600$ times, while the path $\\langle S, B_1^{\\text{true}}, \\dots, B_5^{\\text{true}}, \\dots \\rangle$ is taken $0$ times. This indicates that for the observed workload, whenever $P$ is true, $Q$ is false.\n\n2.  **The Soundness Constraint:** A crucial constraint is that any transformation must be *sound*, meaning it must be correct for *all possible inputs*, not just those in the profiling run. A profiling result, however strong, is a statistical observation, not a formal proof of a program invariant. We cannot conclude that $Q \\equiv \\lnot P$ is true for all executions. There might exist an execution path, not encountered during profiling, where $P$ is true and $Q$ is also true. A sound optimization must correctly handle this case.\n\n3.  **The Goal:** The goal is to eliminate the check of $Q$ at $B_5$ along the hot path $p^*$. This path is taken after $P$ evaluates to true.\n\n4.  **The Mechanism (Guarded Versioning):** The problem statement itself defines the correct mechanism: \"guarded versioning.\" This involves creating a specialized, faster version of the code for the predicted (hot) path and using a run-time check (a guard) to ensure the conditions for entering this specialized path are met. If the guard fails, control is transferred to the original, unoptimized code (a fallback).\n\n    Applying this to our problem:\n    - The hot path is entered when $P$ is true.\n    - On this path, we predict that $Q$ will be false.\n    - So, we can create a specialized code sequence that executes the body of $B_2$ and then unconditionally jumps to $V$, completely bypassing the test of $Q$ at $B_5$.\n    - To preserve soundness, we must introduce a guard. Before committing to this specialized path, we must verify that our prediction holds. The guard must check if $Q$ is indeed false.\n    - The new control flow after $B_1$ would look like this: If $P$ is true, jump to a new block, the guard.\n    - The guard block checks if $Q$ is false.\n        - If `true` ($Q$ is false), execute the specialized path (code of $B_2$, then jump to $V$).\n        - If `false` ($Q$ is true), this is the unpredicted case. We fall back to the original code path by jumping to $B_2$, which will then proceed to $B_5$, correctly evaluate $Q$ as true, and jump to $U$.\n\nThis structure achieves the goal: on the frequently executed path where $P$ is true and $Q$ is false, the check at $B_5$ is eliminated. Correctness is maintained for the rare (or unobserved) case where $P$ is true and $Q$ is also true.\n\n### Option-by-Option Analysis\n\n**A. Use only edge profiling to infer that $B_1^{\\text{true}}$ implies $B_5^{\\text{false}}$, and replace the branch at $B_5$ with an unconditional jump to $V$ whenever the immediate predecessor is $B_2$.**\n\n- The premise \"Use only edge profiling\" is false. As established, edge profiling alone is insufficient to detect the correlation between the branches at $B_1$ and $B_5$. This information comes from path profiling.\n- The transformation \"replace the branch at $B_5$ with an unconditional jump\" is **unsound**. It is based on an inference from a statistical sample (\"profiling data\") but applies it as if it were a proven invariant. If any input exists for which control flows through $B_2$ to $B_5$ and predicate $Q$ evaluates to true, this transformation would cause the program to execute incorrectly by jumping to $V$ instead of $U$.\n- **Verdict:** Incorrect.\n\n**B. Clone the region forming $p^*$ into a specialized trace version $T^*$ entered from $B_1^{\\text{true}}$. Insert at the head of $T^*$ a run-time guard that evaluates $Q$ and checks $Q=\\text{false}$; if the guard passes, bypass $B_5$ and jump directly to $V$ (deleting the $Q$ test in $T^*$), otherwise branch to the original code. Keep the original CFG intact as a fallback.**\n\n- This option correctly identifies path profiling as the source of information (implicitly, as it refers to path $p^*$).\n- It describes the standard \"guarded versioning\" technique.\n  - \"Clone the region ... into a specialized trace version $T^*$\": This is the creation of the optimized path.\n  - \"Insert ... a run-time guard that evaluates $Q$ and checks $Q=\\text{false}$\": This is the crucial check to ensure the condition for the optimization holds at run-time.\n  - \"if the guard passes, bypass $B_5$ and jump directly to $V$ (deleting the $Q$ test in $T^*$)\": This is the optimized execution path where the redundant check is removed.\n  - \"otherwise branch to the original code\": This is the fallback mechanism that guarantees soundness for unpredicted cases.\n- This transformation is **sound** and directly achieves the stated goal of removing the check at $B_5$ on the hot path. While there can be practical complexities in hoisting the evaluation of $Q$ to before $B_2$, the described logical structure is the correct and standard approach for this kind of profile-guided optimization.\n- **Verdict:** Correct.\n\n**C. From the path profiling, infer the invariant $Q \\equiv \\lnot P$ and eliminate both branches at $B_1$ and $B_5$ globally by constant-folding successors accordingly.**\n\n- The key phrase \"infer the invariant $Q \\equiv \\lnot P$\" is a logical fallacy in the context of compiler correctness. Profiling data suggests a correlation; it does not prove a universally true invariant. Making this assumption is the primary source of unsoundness.\n- The proposed transformation \"eliminate both branches ... globally\" would alter program behavior for any input that violates the assumed invariant. For example, if an input exists where $P$ and $Q$ are both true, the original program would follow the path to $U$. The transformed program, having assumed $P \\implies \\lnot Q$, would incorrectly force the path to $V$. This is an **unsound** transformation.\n- **Verdict:** Incorrect.\n\n**D. Reorder basic blocks to place $B_2 \\rightarrow B_5 \\rightarrow V$ contiguously in memory (layout optimization), but leave all branches in place unchanged.**\n\n- This describes a code layout optimization. Such an optimization uses profiling to identify hot paths ($B_2 \\rightarrow B_5 \\rightarrow V$ is part of the hot path $p^*$) and arranges them sequentially in memory to improve instruction cache locality and potentially reduce branch penalties.\n- However, the option explicitly states \"leave all branches in place unchanged.\"\n- The problem's goal is to \"**remove the dynamic check at $B_5$**\". This transformation does not remove any checks or branches. While it is a valid optimization that uses profiling information, it does not address the specific goal of the problem.\n- **Verdict:** Incorrect.", "answer": "$$\\boxed{B}$$", "id": "3640289"}]}