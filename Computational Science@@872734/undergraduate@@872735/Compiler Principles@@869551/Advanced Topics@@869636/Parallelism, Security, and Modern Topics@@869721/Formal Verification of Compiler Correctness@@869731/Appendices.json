{"hands_on_practices": [{"introduction": "A fundamental assumption in algebra is that addition is associative, meaning the order of operations does not change the sum. Compilers often leverage this property to reorder computations for better performance. This practice demonstrates vividly why this assumption is unsafe for floating-point numbers, whose finite precision introduces rounding errors. By working through a concrete calculation [@problem_id:3642459], you will gain a hands-on understanding of how different evaluation orders can lead to dramatically different results due to numerical phenomena like catastrophic cancellation and absorption.", "problem": "A core step in formally verifying the correctness of a compiler optimization is to justify that the source and target program fragments are observationally equivalent under the language’s semantics. Consider a language whose arithmetic semantics follow the Institute of Electrical and Electronics Engineers (IEEE) Standard $754$ rounding rule “round to nearest, ties to even,” but, to make reasoning explicit, we replace the usual binary floating-point with a mathematically idealized decimal floating-point model. In this model, the set of representable floating-point numbers consists of all normalized decimal numbers of the form $\\pm d_{0}.d_{1}d_{2}\\times 10^{e}$ with exactly $p=3$ significant digits, where $d_{0}\\in\\{1,2,\\dots,9\\}$, $d_{1},d_{2}\\in\\{0,1,\\dots,9\\}$, and $e\\in\\mathbb{Z}$ is an unbounded exponent; additionally, the number $0$ is representable. Let $\\mathrm{fl}(x)$ denote the result of rounding a real $x$ to the nearest representable number in this model, with ties broken toward the representable number whose least significant digit $d_{2}$ is even. Define floating-point addition by $x\\oplus y \\triangleq \\mathrm{fl}(x+y)$.\n\nA widely used reassociation optimization replaces $(a+b)+c$ by $a+(b+c)$ under the assumption that addition is associative. In the presence of floating-point rounding, this assumption can be invalid, which is a critical concern in the formal verification of compiler correctness.\n\nUsing the above decimal floating-point semantics with base $10$, precision $p=3$, and rounding to nearest ties to even, let\n- $a = 1.00\\times 10^{5}$,\n- $b = -1.00\\times 10^{5}$,\n- $c = 1.23\\times 10^{0}$.\n\nCompute the exact real-number value of\n$$D \\triangleq \\bigl((a\\oplus b)\\oplus c\\bigr)\\;-\\;\\bigl(a\\oplus (b\\oplus c)\\bigr).$$\nExpress your final answer as an exact decimal number. Do not round the final answer.", "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- **Decimal Floating-Point Model:**\n  - Set of representable numbers: $\\pm d_{0}.d_{1}d_{2}\\times 10^{e}$ and $0$.\n  - Precision: $p=3$ significant digits.\n  - Digits: $d_{0}\\in\\{1,2,\\dots,9\\}$, $d_{1},d_{2}\\in\\{0,1,\\dots,9\\}$.\n  - Exponent: $e\\in\\mathbb{Z}$ (unbounded).\n- **Rounding Rule:** $\\mathrm{fl}(x)$ rounds a real number $x$ to the nearest representable number. Ties are broken by choosing the representable number whose least significant digit, $d_{2}$, is even.\n- **Floating-Point Addition:** $x\\oplus y \\triangleq \\mathrm{fl}(x+y)$.\n- **Given Values:**\n  - $a = 1.00\\times 10^{5}$\n  - $b = -1.00\\times 10^{5}$\n  - $c = 1.23\\times 10^{0}$\n- **Quantity to Compute:** The exact real-number value of $D \\triangleq \\bigl((a\\oplus b)\\oplus c\\bigr)\\;-\\;\\bigl(a\\oplus (b\\oplus c)\\bigr)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is a well-defined exercise in numerical analysis, specifically concerning the properties of floating-point arithmetic. It uses a simplified but rigorously defined decimal model to illustrate the non-associativity of floating-point addition, a critical concept in computer science and compiler design.\n- **Scientific Grounding:** The problem is based on the fundamental principles of floating-point representation and rounding, analogous to the real-world IEEE $754$ standard. It is scientifically sound.\n- **Well-Posedness:** All terms, functions ($\\mathrm{fl}$, $\\oplus$), and number formats are defined precisely. The given values are unambiguous. A unique solution can be determined by direct application of the specified rules.\n- **Objectivity:** The problem is stated in formal, mathematical language, free of any subjectivity or ambiguity.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\nThe goal is to compute the value of $D \\triangleq \\bigl((a\\oplus b)\\oplus c\\bigr)\\;-\\;\\bigl(a\\oplus (b\\oplus c)\\bigr)$. We will compute each of the two terms separately. The given values are:\n$a = 1.00 \\times 10^{5} = 100000$\n$b = -1.00 \\times 10^{5} = -100000$\n$c = 1.23 \\times 10^{0} = 1.23$\n\nAll three given values ($a, b, c$) are representable numbers in the specified floating-point model. For instance, $a=1.00\\times 10^5$ fits the form $d_0.d_1d_2 \\times 10^e$ with $d_0=1, d_1=0, d_2=0$ and $e=5$.\n\n**1. Calculation of $\\bigl((a\\oplus b)\\oplus c\\bigr)$**\n\nFirst, we compute the inner expression, $a\\oplus b$:\n$$a\\oplus b \\triangleq \\mathrm{fl}(a+b)$$\nThe exact real-number sum is:\n$$a+b = (1.00 \\times 10^{5}) + (-1.00 \\times 10^{5}) = 100000 - 100000 = 0$$\nThe problem statement specifies that $0$ is a representable number. The rounding of a representable number is the number itself.\n$$a\\oplus b = \\mathrm{fl}(0) = 0$$\nNext, we compute the full expression by adding $c$ to this result:\n$$(a\\oplus b)\\oplus c = 0 \\oplus c \\triangleq \\mathrm{fl}(0+c)$$\nThe exact sum is:\n$$0+c = 0 + 1.23 = 1.23$$\nWe must round $1.23$ to the nearest representable number. A representable number has the form $\\pm d_{0}.d_{1}d_{2}\\times 10^{e}$. The number $1.23$ can be written as $1.23\\times 10^{0}$. With $d_0=1$, $d_1=2$, and $d_2=3$, this fits the specified three-digit normalized form. Thus, $1.23$ is a representable number.\n$$\\mathrm{fl}(1.23) = 1.23$$\nTherefore, the first term is:\n$$\\bigl((a\\oplus b)\\oplus c\\bigr) = 1.23$$\n\n**2. Calculation of $\\bigl(a\\oplus (b\\oplus c)\\bigr)$**\n\nFirst, we compute the inner expression, $b\\oplus c$:\n$$b\\oplus c \\triangleq \\mathrm{fl}(b+c)$$\nThe exact real-number sum is:\n$$b+c = (-1.00 \\times 10^{5}) + (1.23 \\times 10^{0}) = -100000 + 1.23 = -99998.77$$\nNow, we must round the real number $x = -99998.77$ to the nearest representable number with $p=3$ significant digits. We write $x$ in normalized scientific notation:\n$$x = -9.999877 \\times 10^{4}$$\nThe exponent is $e=4$. We need to round the mantissa $9.999877$ to three significant digits. The two nearest candidate mantissas of the form $d_0.d_1d_2$ are $9.99$ and the next representable one. Incrementing the last digit of $9.99$ yields $10.0$.\nThis leads to two candidate representable numbers:\n- Rounding down: $-10.0 \\times 10^4 = -1.00 \\times 10^5$. To be more precise, the representable number just \"below\" (in magnitude) is $-9.99 \\times 10^4 = -99900$. Let this be $N_1$.\n- Rounding up: The representable number just \"above\" (in magnitude) is $-1.00 \\times 10^5 = -100000$. Let this be $N_2$.\nThe midpoint between these two numbers is $\\frac{(-99900) + (-100000)}{2} = -99950$.\nOur value is $x=-99998.77$. Since $|x| = 99998.77$ is greater than the midpoint's magnitude $|-99950|=99950$, we round away from zero. Hence, we round to the number with the larger magnitude, which is $N_2=-100000$.\nAlternatively, we compare the distances:\n$$|x - N_1| = |-99998.77 - (-99900)| = |-98.77| = 98.77$$\n$$|x - N_2| = |-99998.77 - (-100000)| = |1.23| = 1.23$$\nSince $1.23  98.77$, the nearest representable number is $N_2 = -100000 = -1.00 \\times 10^{5}$.\nNo tie occurred, so the \"ties to even\" rule is not invoked.\n$$b\\oplus c = \\mathrm{fl}(-99998.77) = -1.00 \\times 10^{5}$$\nThis result is equal to the original value of $b$. This phenomenon, where adding a small number to a very large one results in no change to the large number after rounding, is known as \"swamping\" or \"absorption\".\n\nNext, we compute the full expression:\n$$a\\oplus (b\\oplus c) = a \\oplus (-1.00 \\times 10^{5})$$\nThis is defined as $\\mathrm{fl}\\left(a + (-1.00 \\times 10^{5})\\right)$. The exact sum is:\n$$a + (-1.00 \\times 10^{5}) = (1.00 \\times 10^{5}) + (-1.00 \\times 10^{5}) = 0$$\nAs before, $\\mathrm{fl}(0) = 0$.\nTherefore, the second term is:\n$$\\bigl(a\\oplus (b\\oplus c)\\bigr) = 0$$\n\n**3. Final Computation of $D$**\n\nFinally, we compute the difference $D$:\n$$D = \\bigl((a\\oplus b)\\oplus c\\bigr) \\;-\\; \\bigl(a\\oplus (b\\oplus c)\\bigr) = 1.23 - 0 = 1.23$$\nThe result demonstrates that floating-point addition is not associative. The difference $D$ is non-zero, highlighting a potential correctness issue when a compiler performs reassociation optimization on floating-point expressions without formal justification.", "answer": "$$\\boxed{1.23}$$", "id": "3642459"}, {"introduction": "Building on the failure of basic algebraic laws, we now examine the distributive property, which governs the interaction between addition and multiplication. This exercise illustrates how rounding errors can accumulate and interact in more complex expressions, causing the familiar identity $x \\times (y+z) = x \\times y + x \\times z$ to fail. Beyond just finding a counterexample, this problem [@problem_id:3642458] challenges you to generalize from the specific case and define a sufficient condition under which this optimization *is* provably safe, a core task in formal verification.", "problem": "Consider a source-level algebraic rewrite that a compiler might apply to an arithmetic expression: distribute multiplication over addition, replacing $x \\times (y+z)$ with $x \\times y + x \\times z$. In real-number arithmetic this transformation is correct by the distributive law. However, in floating-point arithmetic, correctness depends on the rounded semantics the compiler targets. To reason from first principles, use the following operational model of floating-point evaluation and rounding:\n\n- The machine floating-point set $\\mathbb{F}$ consists of base-$10$ normalized numbers with $3$ significant digits (mantissa $d_{1}.d_{2}d_{3}$ where $d_{1} \\in \\{1,\\dots,9\\}$ and $d_{2},d_{3} \\in \\{0,\\dots,9\\}$) times an integer power of $10$.\n- The rounding function $R : \\mathbb{R} \\to \\mathbb{F}$ maps any real input to the nearest element of $\\mathbb{F}$ using round-to-nearest, ties-to-even. Specifically, when the first discarded digit is $5$ and all subsequent discarded digits are $0$, $R$ rounds so that the last retained digit becomes even; otherwise, $R$ rounds to the nearest representable value with the usual comparison rule ($5$ rounds down, $>5$ rounds up).\n- Expression evaluation is defined by applying $R$ after each primitive operation. For variables $u,v \\in \\mathbb{F}$, the semantics are\n$$\\llbracket u \\rrbracket = u,\\quad \\llbracket u+v \\rrbracket = R(\\llbracket u \\rrbracket + \\llbracket v \\rrbracket),\\quad \\llbracket u \\times v \\rrbracket = R(\\llbracket u \\rrbracket \\times \\llbracket v \\rrbracket),$$\nand composition follows the abstract syntax tree (that is, $x \\times (y+z)$ evaluates by first computing $\\llbracket y+z \\rrbracket$ and then multiplying by $x$, with rounding after each operation).\n\nLet the program variables be the machine-representable values $x = 9.99 \\times 10^{6}$, $y = 1.00$, and $z = 5.00 \\times 10^{-3}$, all members of $\\mathbb{F}$.\n\n1. Using the above semantics, evaluate both $\\llbracket x \\times (y+z) \\rrbracket$ and $\\llbracket x \\times y + x \\times z \\rrbracket$ and compute the absolute difference\n$$\\Delta = \\left|\\,\\llbracket x \\times y + x \\times z \\rrbracket - \\llbracket x \\times (y+z) \\rrbracket\\,\\right|.$$\nProvide $\\Delta$ as a single real-valued number.\n\n2. In addition to the calculation, state a sufficient condition, expressed in terms of exact representability under $R$, under which the algebraic rewrite $x \\times (y+z) \\to x \\times y + x \\times z$ is semantics-preserving for this floating-point model. Your condition should be derived from the core definitions above and not rely on unproven heuristics.\n\nGive your final numerical answer for $\\Delta$ without units. No rounding specification is required for the final number because it is exact in this setting.", "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It presents a simplified but consistent model of floating-point arithmetic to analyze the correctness of a compiler optimization. All definitions and values are provided, allowing for a unique solution. We may therefore proceed with the derivation.\n\nThe problem requires us to perform two tasks: first, compute the numerical difference between two expressions under a specific floating-point semantics, and second, state a general sufficient condition under which the algebraic identity holds.\n\nThe floating-point system $\\mathbb{F}$ consists of numbers of the form $d_{1}.d_{2}d_{3} \\times 10^e$, where $d_{1} \\in \\{1, \\dots, 9\\}$, $d_{2}, d_{3} \\in \\{0, \\dots, 9\\}$, and $e$ is an integer. Rounding $R$ is round-to-nearest, ties-to-even. The given machine-representable values are:\n$x = 9.99 \\times 10^{6}$\n$y = 1.00 = 1.00 \\times 10^{0}$\n$z = 5.00 \\times 10^{-3}$\n\n**Part 1: Calculation of the absolute difference $\\Delta$**\n\nFirst, we evaluate the expression $\\llbracket x \\times (y+z) \\rrbracket$ according to the specified semantics, which is $R(x \\times R(y+z))$.\n\n1.  Compute the inner sum, $y+z$:\n    $$y+z = 1.00 + 5.00 \\times 10^{-3} = 1.00 + 0.005 = 1.005$$\n2.  Round the result to fit in $\\mathbb{F}$. The value is $1.005 \\times 10^0$. We must round to $3$ significant digits. The digits to retain are $1.00$. The first discarded digit is $5$, and all subsequent discarded digits are zero. This is a tie-breaking situation. The rounding rule is ties-to-even, which means we round such that the last retained digit is even. The last retained digit is the second $0$ in $1.00$. Since $0$ is already even, we round down.\n    $$R(1.005) = 1.00$$\n    So, $\\llbracket y+z \\rrbracket = 1.00 \\times 10^{0}$. Let's denote this intermediate result as $t_1 = 1.00$.\n\n3.  Compute the product of $x$ and the intermediate result $t_1$:\n    $$x \\times t_1 = (9.99 \\times 10^{6}) \\times 1.00 = 9.99 \\times 10^{6}$$\n4.  Round the final product. The result $9.99 \\times 10^{6}$ is already a member of the set $\\mathbb{F}$. Therefore, rounding has no effect.\n    $$R(9.99 \\times 10^{6}) = 9.99 \\times 10^{6}$$\n    Thus, the value of the first expression is:\n    $$\\llbracket x \\times (y+z) \\rrbracket = 9.99 \\times 10^{6}$$\n\nNext, we evaluate the expression $\\llbracket x \\times y + x \\times z \\rrbracket$ according to the semantics $R(R(x \\times y) + R(x \\times z))$.\n\n1.  Compute the first product, $x \\times y$:\n    $$x \\times y = (9.99 \\times 10^{6}) \\times 1.00 = 9.99 \\times 10^{6}$$\n    This value is already in $\\mathbb{F}$, so $R(x \\times y) = 9.99 \\times 10^{6}$. Let's call this $t_{xy} = \\llbracket x \\times y \\rrbracket$.\n\n2.  Compute the second product, $x \\times z$:\n    $$x \\times z = (9.99 \\times 10^{6}) \\times (5.00 \\times 10^{-3}) = (9.99 \\times 5.00) \\times 10^{3} = 49.95 \\times 10^{3}$$\n    To normalize this to the form $d_1.d_2d_3 \\times 10^e$, we write it as $4.995 \\times 10^{4}$.\n\n3.  Round this product to fit in $\\mathbb{F}$. We must round $4.995 \\times 10^4$ to $3$ significant digits. The digits to retain are $4.99$. The first discarded digit is $5$, which indicates a tie. The last retained digit is $9$, which is odd. The ties-to-even rule requires us to round to make this last digit even, which means rounding up.\n    $$R(4.995 \\times 10^{4}) = 5.00 \\times 10^{4}$$\n    Let's call this $t_{xz} = \\llbracket x \\times z \\rrbracket$.\n\n4.  Compute the sum of the two intermediate results, $t_{xy} + t_{xz}$:\n    $$t_{xy} + t_{xz} = 9.99 \\times 10^{6} + 5.00 \\times 10^{4}$$\n    To perform the addition, we align the exponents:\n    $$9.99 \\times 10^{6} + 0.05 \\times 10^{6} = (9.99 + 0.05) \\times 10^{6} = 10.04 \\times 10^{6}$$\n    Alternatively, in fixed-point representation: $9990000 + 50000 = 10040000$.\n    Expressed in normalized form for $\\mathbb{F}$, this is $1.004 \\times 10^{7}$.\n\n5.  Round the final sum. We must round $1.004 \\times 10^7$ to $3$ significant digits. The digits to retain are $1.00$. The first discarded digit is $4$, which is less than $5$. Therefore, we round down.\n    $$R(1.004 \\times 10^{7}) = 1.00 \\times 10^{7}$$\n    Thus, the value of the second expression is:\n    $$\\llbracket x \\times y + x \\times z \\rrbracket = 1.00 \\times 10^{7}$$\n\nFinally, we compute the absolute difference $\\Delta$:\n$$\\Delta = |\\llbracket x \\times y + x \\times z \\rrbracket - \\llbracket x \\times (y+z) \\rrbracket|$$\n$$\\Delta = |1.00 \\times 10^{7} - 9.99 \\times 10^{6}|$$\n$$\\Delta = |10000000 - 9990000| = |10000| = 10000$$\n\n**Part 2: Sufficient condition for semantic preservation**\n\nWe are seeking a sufficient condition on $x, y, z \\in \\mathbb{F}$ for the algebraic rewrite to be semantics-preserving, meaning:\n$$\\llbracket x \\times (y+z) \\rrbracket = \\llbracket x \\times y + x \\times z \\rrbracket$$\nUsing the given semantic definitions, this equality is:\n$$R(x \\times R(y+z)) = R(R(x \\times y) + R(x \\times z))$$\nIn real-number arithmetic, the distributive law guarantees that $x \\times (y+z) = x \\times y + x \\times z$. The discrepancy in floating-point arithmetic arises from the rounding function $R$ applied after each operation.\n\nA straightforward way to ensure the equality holds is to demand that the intermediate calculations, which are subject to rounding, introduce no error. If the real-valued results of the sub-expressions are all exactly representable in $\\mathbb{F}$, then the rounding function $R$ becomes an identity function for those specific values.\n\nLet's assume the following three conditions hold:\n1.  The sum $y+z$ is exactly representable in $\\mathbb{F}$. This is equivalent to $R(y+z) = y+z$.\n2.  The product $x \\times y$ is exactly representable in $\\mathbb{F}$. This is equivalent to $R(x \\times y) = x \\times y$.\n3.  The product $x \\times z$ is exactly representable in $\\mathbb{F}$. This is equivalent to $R(x \\times z) = x \\times z$.\n\nUnder these assumptions, let's re-evaluate both sides of the main equality.\nThe left-hand side becomes:\n$$\\llbracket x \\times (y+z) \\rrbracket = R(x \\times R(y+z)) = R(x \\times (y+z))$$\nThe right-hand side becomes:\n$$\\llbracket x \\times y + x \\times z \\rrbracket = R(R(x \\times y) + R(x \\times z)) = R((x \\times y) + (x \\times z))$$\nBy the distributive law for real numbers, the arguments to the outer rounding function $R$ on both sides are identical: $x \\times (y+z) = (x \\times y) + (x \\times z)$. Since the rounding function $R$ is a function, it will map identical inputs to identical outputs. Therefore, the equality $\\llbracket x \\times (y+z) \\rrbracket = \\llbracket x \\times y + x \\times z \\rrbracket$ is guaranteed.\n\nThus, a sufficient condition, expressed in terms of exact representability under $R$, is that the results of all three sub-expressions within the larger computation are exactly representable in the floating-point set $\\mathbb{F}$. Formally:\nThe transformation $x \\times (y+z) \\to x \\times y + x \\times z$ is semantics-preserving if the real-valued results of the operations $(y+z)$, $(x \\times y)$, and $(x \\times z)$ are all exactly representable in the floating-point set $\\mathbb{F}$. This is equivalent to stating that $R(y+z) = y+z$, $R(x \\times y) = x \\times y$, and $R(x \\times z) = x \\times z$.", "answer": "$$\\boxed{10000}$$", "id": "3642458"}, {"introduction": "The correctness of a program often depends on more than just producing the right numerical answer; it must also handle exceptional cases and special values according to well-defined rules. This problem shifts our focus from rounding errors in standard arithmetic to the semantics of non-finite values, exploring why the seemingly obvious simplification $x/x \\to 1$ is invalid. To formally justify this, you will need to define the \"observable behavior\" of a program to include not just the output value but also exception flags [@problem_id:3642454], providing essential practice in the kind of rigorous semantic reasoning that underpins formal verification.", "problem": "Consider a simple expression language with variables and arithmetic over floating-point values modeled after the Institute of Electrical and Electronics Engineers (IEEE) 754 standard. The observable behavior of evaluating an expression is defined to be a pair $(v, f)$, where $v$ is the resulting value and $f \\in \\{0,1\\}$ indicates whether the invalid-operation exception was raised during evaluation. For this problem, you may assume the following well-tested facts from IEEE 754 arithmetic under a default rounding mode and ignoring signaling not-a-number inputs: \n- For any finite nonzero $x$, the division $x/x$ is exactly $1$ and does not raise the invalid-operation exception. \n- The division $0/0$ produces a quiet not-a-number value and raises the invalid-operation exception. \n- The division $\\infty/\\infty$ produces a quiet not-a-number value and raises the invalid-operation exception. \n- Any arithmetic operation with a quiet not-a-number operand propagates quiet not-a-number as the result and does not raise the invalid-operation exception, except for the specific invalid cases already stated.\n\nA compiler optimization replaces the expression $x/x$ with the constant $1$. Let the semantics of a constant be its value with no exceptions, so evaluating the constant $1$ yields the observable pair $(1, 0)$. Let the observable semantics of the original expression $x/x$ on input $x$ be denoted by $\\llbracket x/x \\rrbracket(x)$ and that of the optimized expression by $\\llbracket 1 \\rrbracket$.\n\n1. Define a precise big-step semantics for $\\llbracket x/x \\rrbracket(x)$ consistent with the facts above that captures the value and invalid-operation exception behavior for the following disjoint input categories: quiet not-a-number, zero (including both `+0` and `-0`), infinities (both $+\\infty$ and $-\\infty$), and finite nonzero numbers. Your semantics must produce an observable pair $(v,f)$ for each category.\n\n2. Using your semantics, formally justify why the replacement $x/x \\to 1$ is not semantics-preserving for inputs where $x$ is zero, infinite, or quiet not-a-number, with respect to the observable behavior $(v,f)$.\n\n3. Suppose $x$ is drawn from a distribution over the four categories with probabilities $\\mathbb{P}[\\text{quiet not-a-number}] = \\frac{1}{50}$, $\\mathbb{P}[\\text{zero}] = \\frac{1}{100}$, $\\mathbb{P}[\\text{infinite}] = \\frac{1}{200}$, and the remaining probability mass assigned to finite nonzero numbers. Under this model, compute the probability that the observable behavior of $\\llbracket x/x \\rrbracket(x)$ differs from that of $\\llbracket 1 \\rrbracket$. Provide your final answer as a single number rounded to four significant figures.", "solution": "### Step 1: Problem Validation\n\n#### Givens Extraction\nThe problem provides the following data, definitions, and conditions:\n- **Observable Behavior**: The evaluation of an expression yields a pair `$(v, f)$`, where `$v$` is the result value and `$f \\in \\{0,1\\}$` is a flag indicating if the invalid-operation exception was raised (`$f=1$`) or not (`$f=0$`).\n- **Floating-Point Facts (IEEE 754 simplifications)**:\n    1. For any finite nonzero `$x$`, the division `$x/x$` results in `$1$` and does not raise the invalid-operation exception (`$f=0$`).\n    2. The division `$0/0$` produces a quiet not-a-number (`qNaN`) value and raises the invalid-operation exception (`$f=1$`).\n    3. The division `$\\infty/\\infty$` produces a `qNaN` value and raises the invalid-operation exception (`$f=1$`).\n    4. An arithmetic operation with a `qNaN` operand propagates `qNaN` as the result and does not raise the invalid-operation exception (`$f=0$`), excluding the specific cases already stated.\n- **Compiler Optimization**: The expression `$x/x$` is replaced by the constant `$1$`.\n- **Semantics**:\n    - The semantics of the original expression is denoted `$\\llbracket x/x \\rrbracket(x)$`.\n    - The semantics of a constant `$C$` is its value with no exceptions. Thus, `$\\llbracket 1 \\rrbracket$` yields the observable pair `$(1, 0)$`.\n- **Input Categories**: The input `$x$` can fall into one of four disjoint categories: quiet not-a-number, zero (both `+0` and `-0`), infinities (both `$+\\infty$` and `$-\\infty$`), and finite nonzero numbers.\n- **Probabilities**:\n    - `$\\mathbb{P}[\\text{quiet not-a-number}] = \\frac{1}{50}$`\n    - `$\\mathbb{P}[\\text{zero}] = \\frac{1}{100}$`\n    - `$\\mathbb{P}[\\text{infinite}] = \\frac{1}{200}$`\n    - The remaining probability mass is for finite nonzero numbers.\n\n#### Validation\n- **Scientific Grounding**: The problem is well-grounded in the principles of computer science, specifically compiler theory and computer arithmetic. The facts presented are correct and standard simplifications of the IEEE 754 floating-point standard.\n- **Well-Posedness**: The problem is well-posed. It asks for three distinct tasks: defining a formal semantics, using that semantics to prove a property, and calculating a probability based on a given distribution. Each part is clearly specified and leads to a unique, stable, and meaningful solution.\n- **Objectivity**: The problem is stated in precise, objective, and formal language, free of ambiguity or subjective claims.\n\nThe problem is self-contained, consistent, and does not violate any of the criteria for invalidity. It is a valid formal problem.\n\n### Step 2: Solution\n\n#### 1. Big-Step Semantics for $\\llbracket x/x \\rrbracket(x)$\n\nLet `$x_{in}$` be the input value for the variable `$x$`. The big-step semantics `$\\llbracket x/x \\rrbracket(x_{in})$` maps this input to an observable pair `$(v,f)$`. We construct the semantics by considering each of the four disjoint input categories, based on the provided facts. Let `qNaN` denote a quiet not-a-number value.\n\n- **Category: Finite nonzero number.** According to fact 1, for a finite nonzero input `$x_{in}$`, the division `$x_{in}/x_{in}$` evaluates to `$1$` and does not raise the invalid-operation exception. Therefore, `$v=1$` and `$f=0$`.\n- **Category: Zero.** According to fact 2, for `$x_{in}=0$`, the division `$0/0$` produces `qNaN` and raises the invalid-operation exception. Therefore, `$v=\\text{qNaN}$` and `$f=1$`.\n- **Category: Infinity.** According to fact 3, for `$x_{in}=\\infty$`, the division `$\\infty/\\infty$` produces `qNaN` and raises the invalid-operation exception. Therefore, `$v=\\text{qNaN}$` and `$f=1$`.\n- **Category: Quiet not-a-number.** According to fact 4, an operation with a `qNaN` operand propagates `qNaN` without raising a new exception. Thus, for `$x_{in}=\\text{qNaN}$`, the division `$\\text{qNaN}/\\text{qNaN}$` results in `qNaN` and does not raise the invalid-operation exception. Therefore, `$v=\\text{qNaN}$` and `$f=0$`.\n\nWe can formalize this case analysis as a piecewise definition of the semantics:\n$$\n\\llbracket x/x \\rrbracket(x_{in}) = \\begin{cases}\n(1, 0)  \\text{if } x_{in} \\text{ is a finite nonzero number} \\\\\n(\\text{qNaN}, 1)  \\text{if } x_{in} \\in \\{+0, -0\\} \\\\\n(\\text{qNaN}, 1)  \\text{if } x_{in} \\in \\{+\\infty, -\\infty\\} \\\\\n(\\text{qNaN}, 0)  \\text{if } x_{in} \\text{ is a quiet not-a-number}\n\\end{cases}\n$$\n\n#### 2. Justification for Non-Equivalence\n\nThe compiler optimization replaces the expression `$x/x$` with the constant `$1$`. The semantics of the optimized expression is given as `$\\llbracket 1 \\rrbracket = (1, 0)$`. This means for any input value `$x_{in}$`, the optimized code produces the observable pair `$(1, 0)$`.\n\nTo show the transformation `$x/x \\to 1$` is not semantics-preserving, we must demonstrate that `$\\llbracket x/x \\rrbracket(x_{in}) \\neq \\llbracket 1 \\rrbracket$` for some inputs `$x_{in}$`. We check the cases where `$x$` is zero, infinite, or quiet not-a-number.\n\n- **Case: `$x_{in}$` is zero.**\n  From our semantics, `$\\llbracket x/x \\rrbracket(0) = (\\text{qNaN}, 1)$`.\n  The optimized semantics is `$\\llbracket 1 \\rrbracket = (1, 0)$`.\n  Since `$(\\text{qNaN}, 1) \\neq (1, 0)$`, the semantics are not preserved. Both the resulting value and the exception flag differ.\n\n- **Case: `$x_{in}$` is infinite.**\n  From our semantics, `$\\llbracket x/x \\rrbracket(\\infty) = (\\text{qNaN}, 1)$`.\n  The optimized semantics is `$\\llbracket 1 \\rrbracket = (1, 0)$`.\n  Since `$(\\text{qNaN}, 1) \\neq (1, 0)$`, the semantics are not preserved. Again, both the value and the flag differ.\n\n- **Case: `$x_{in}$` is a quiet not-a-number.**\n  From our semantics, `$\\llbracket x/x \\rrbracket(\\text{qNaN}) = (\\text{qNaN}, 0)$`.\n  The optimized semantics is `$\\llbracket 1 \\rrbracket = (1, 0)$`.\n  Since `$(\\text{qNaN}, 0) \\neq (1, 0)$`, the semantics are not preserved. The resulting value differs, although the exception flag is the same.\n\nIn all three specified categories—zero, infinite, and quiet not-a-number—the observable behavior of the original expression differs from that of the optimized expression. Therefore, the replacement `$x/x \\to 1$` is not a semantics-preserving transformation. It is only valid under the precondition that `$x$` is a finite nonzero number.\n\n#### 3. Probability of Mismatched Behavior\n\nThe observable behavior of `$\\llbracket x/x \\rrbracket(x)$` differs from that of `$\\llbracket 1 \\rrbracket$` if and only if `$\\llbracket x/x \\rrbracket(x_{in}) \\neq (1, 0)$`.\n\nFrom the semantics defined in part 1, we can see that:\n- If `$x_{in}$` is a finite nonzero number, `$\\llbracket x/x \\rrbracket(x_{in}) = (1, 0)$`. In this case, the behavior matches.\n- If `$x_{in}$` is a zero, `$\\llbracket x/x \\rrbracket(x_{in}) = (\\text{qNaN}, 1) \\neq (1, 0)$`. The behavior differs.\n- If `$x_{in}$` is an infinity, `$\\llbracket x/x \\rrbracket(x_{in}) = (\\text{qNaN}, 1) \\neq (1, 0)$`. The behavior differs.\n- If `$x_{in}$` is a quiet not-a-number, `$\\llbracket x/x \\rrbracket(x_{in}) = (\\text{qNaN}, 0) \\neq (1, 0)$`. The behavior differs.\n\nThus, the observable behavior of the original expression differs from the optimized one if and only if the input `$x$` belongs to one of the three categories: quiet not-a-number, zero, or infinite.\n\nThe problem states that these input categories are disjoint. Therefore, the probability of the behavior differing, let's call this event `$D$`, is the sum of the probabilities of `$x$` falling into each of these three categories.\n\n$$\n\\mathbb{P}[D] = \\mathbb{P}[\\text{quiet not-a-number}] + \\mathbb{P}[\\text{zero}] + \\mathbb{P}[\\text{infinite}]\n$$\n\nSubstituting the given probabilities:\n$$\n\\mathbb{P}[D] = \\frac{1}{50} + \\frac{1}{100} + \\frac{1}{200}\n$$\n\nTo sum these fractions, we find a common denominator, which is `$200$`:\n$$\n\\mathbb{P}[D] = \\frac{1 \\times 4}{50 \\times 4} + \\frac{1 \\times 2}{100 \\times 2} + \\frac{1}{200}\n$$\n$$\n\\mathbb{P}[D] = \\frac{4}{200} + \\frac{2}{200} + \\frac{1}{200} = \\frac{4+2+1}{200} = \\frac{7}{200}\n$$\n\nTo express this as a decimal rounded to four significant figures:\n$$\n\\frac{7}{200} = 0.035\n$$\nTo write `$0.035$` with four significant figures, we add trailing zeros: `$0.03500$`. The significant figures are `$3$`, `$5$`, `$0$`, and `$0$`.", "answer": "$$\\boxed{0.03500}$$", "id": "3642454"}]}