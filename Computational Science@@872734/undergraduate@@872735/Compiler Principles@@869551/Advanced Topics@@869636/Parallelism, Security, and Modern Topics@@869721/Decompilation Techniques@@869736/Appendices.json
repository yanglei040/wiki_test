{"hands_on_practices": [{"introduction": "A crucial first step in decompilation is to simplify the underlying computations to reveal the program's true intent. This exercise demonstrates one of the most powerful techniques for this purpose: global constant propagation. By tracking constant values across a program's Control Flow Graph (CFG), we can evaluate expressions at decompile-time, which often exposes unreachable code paths and simplifies the logic, as you will see in this practice. [@problem_id:3636449]", "problem": "You are given a lifted Intermediate Representation (IR) of a function from a decompiler pipeline operating on machine code with statically known read-only data. The function takes one integer input parameter $n \\in \\mathbb{Z}$ and returns an integer. The IR is expressed over a Control Flow Graph (CFG) with basic blocks $B_{0}$, $B_{1}$, $B_{2}$, and $B_{3}$, and the following semantics. A single read-only memory location at address $\\alpha$ contains the constant $7$, which the lifter represents as a load from read-only data. All arithmetic is over mathematical integers and there is no wrap-around. The function is as follows, using assignment operator $:=$:\n\n- In $B_{0}$:\n  - $K := \\mathrm{ROLOAD}(\\alpha)$\n  - $a := K - 7$\n  - if $(a \\neq 0)$ then goto $B_{\\mathrm{dead}}$ else goto $B_{1}$\n- In $B_{1}$:\n  - $b := 2$\n  - if $\\big((b + a) \\neq 2\\big)$ then goto $B_{2}$ else goto $B_{3}$\n- In $B_{2}$:\n  - $c := n \\cdot 0$\n  - $t := c + b$\n  - goto $B_{3}$\n- In $B_{3}$:\n  - $x := n + b + K - 9$\n  - return $x$\n\nAssume $B_{\\mathrm{dead}}$ has no side effects and simply returns immediately if reached. Perform global constant propagation across basic blocks on this IR using the standard forward dataflow analysis with the classic constant lattice $L = \\mathbb{Z} \\cup \\{\\top, \\bot\\}$, where $\\bot$ denotes unreachable and $\\top$ denotes unknown non-constant. Use meet operator $\\sqcap$ defined by the usual constant propagation rules. Based on the fixed point of this analysis, produce the decompiled high-level pseudo-code after simplification (dead paths removed and expressions folded), and then verify the correctness of the simplification by explicitly writing and applying state transition equations of the form $x' = f(x)$ for the program state vector, showing that only one path is feasible.\n\nFinally, extract from your simplified pseudo-code the returned value as a closed-form analytic expression in terms of the input $n$. Provide this single expression as your final answer. No rounding is required and no units are to be included in the final answer.", "solution": "The problem is first subjected to a validation check.\n\n### Step 1: Extract Givens\n- **Input Parameter**: An integer $n \\in \\mathbb{Z}$.\n- **Return Value**: An integer.\n- **Control Flow Graph (CFG)**: Comprises basic blocks $B_{0}$, $B_{1}$, $B_{2}$, $B_{3}$. An additional block $B_{\\mathrm{dead}}$ is mentioned.\n- **Read-Only Data**: A memory location at address $\\alpha$ contains the constant value $7$. This is represented as `ROLOAD($\\alpha$)`.\n- **Arithmetic Semantics**: All arithmetic is over mathematical integers without wrap-around.\n- **IR Semantics**:\n    - **In $B_{0}$**:\n        1. $K := \\mathrm{ROLOAD}(\\alpha)$\n        2. $a := K - 7$\n        3. if $(a \\neq 0)$ then goto $B_{\\mathrm{dead}}$ else goto $B_{1}$\n    - **In $B_{1}$**:\n        1. $b := 2$\n        2. if $\\big((b + a) \\neq 2\\big)$ then goto $B_{2}$ else goto $B_{3}$\n    - **In $B_{2}$**:\n        1. $c := n \\cdot 0$\n        2. $t := c + b$\n        3. goto $B_{3}$\n    - **In $B_{3}$**:\n        1. $x := n + b + K - 9$\n        2. return $x$\n- **$B_{\\mathrm{dead}}$ Semantics**: Has no side effects and returns immediately.\n- **Analysis Task**: Perform global constant propagation using a forward dataflow analysis.\n- **Lattice for Analysis**: $L = \\mathbb{Z} \\cup \\{\\top, \\bot\\}$, where $\\top$ represents an unknown non-constant value, and $\\bot$ represents an unreachable/undefined state.\n- **Meet Operator ($\\sqcap$)**: Defined by standard constant propagation rules. For any values $v_1, v_2 \\in L$:\n    - $v \\sqcap \\bot = v$ and $\\bot \\sqcap v = v$ ($\\bot$ is the identity for meet)\n    - $v \\sqcap \\top = \\top$ and $\\top \\sqcap v = \\top$ for $v \\neq \\bot$\n    - $c_1 \\sqcap c_2 = c_1$ if $c_1 = c_2$ where $c_1, c_2 \\in \\mathbb{Z}$\n    - $c_1 \\sqcap c_2 = \\top$ if $c_1 \\neq c_2$ where $c_1, c_2 \\in \\mathbb{Z}$\n- **Goal**:\n    1. Produce simplified high-level pseudo-code after analysis.\n    2. Verify the simplification using state transition equations.\n    3. Extract the final returned value as a closed-form expression in $n$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective.\n- **Scientific Grounding**: The problem is a classic exercise in compiler theory, specifically involving dataflow analysis (constant propagation), control-flow graph simplification, and code generation/decompilation. The lattice, meet operator, and analysis algorithm are standard concepts.\n- **Well-Posedness**: The IR is fully specified, the analysis framework is defined, and the desired outputs are clear. A unique, meaningful solution can be derived through the specified procedure.\n- **Objectivity**: The problem is stated using formal, unambiguous computer science terminology. There are no subjective elements.\n- The problem is self-contained and internally consistent.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n### Solution Derivation\n\nThe solution process involves three main parts: (1) performing constant propagation dataflow analysis, (2) simplifying the IR based on the analysis results, and (3) verifying the simplification and extracting the final expression.\n\n#### 1. Constant Propagation Analysis\n\nWe perform a forward dataflow analysis to determine the constant values of variables at various program points. The state at each point is a map from variables $\\{K, a, b, c, t, x\\}$ to values in the lattice $L$. The input parameter $n$ is considered $\\top$ at the function entry. The analysis proceeds iteratively until a fixed point is reached.\n\n**Initialization**:\n- The state map for the input of every block is initialized with all variables mapped to $\\bot$.\n- The state at the entry of the function (input to $B_0$) has $n \\mapsto \\top$.\n- We use a worklist algorithm, initially containing the entry block $B_0$.\n\n**Iteration 1**:\n- **Process $B_0$**:\n    - The input state to $B_0$ has $n \\mapsto \\top$ and all other variables $\\mapsto \\bot$.\n    - Instruction $K := \\mathrm{ROLOAD}(\\alpha)$: Since $\\mathrm{ROLOAD}(\\alpha)$ loads the constant $7$, the state for $K$ becomes $7$.\n    - Instruction $a := K - 7$: Using the value of $K$, we compute $a := 7 - 7 = 0$. The state for $a$ becomes $0$.\n    - The output state from $B_0$ is $\\{ n \\mapsto \\top, K \\mapsto 7, a \\mapsto 0, \\dots \\}$. The dots imply unassigned variables remain $\\bot$.\n    - Conditional branch `if (a != 0)`: With $a=0$, the condition $0 \\neq 0$ is definitively false. Thus, control flow unconditionally proceeds to $B_1$. The path to $B_{\\mathrm{dead}}$ is unreachable (dead code).\n    - We propagate the output state of $B_0$ to $B_1$ and add $B_1$ to the worklist.\n\n- **Process $B_1$**:\n    - The input state to $B_1$ is the output state from $B_0$: $\\{ n \\mapsto \\top, K \\mapsto 7, a \\mapsto 0, \\dots \\}$.\n    - Instruction $b := 2$: The state for $b$ becomes $2$.\n    - The state before the branch is $\\{ n \\mapsto \\top, K \\mapsto 7, a \\mapsto 0, b \\mapsto 2, \\dots \\}$.\n    - Conditional branch `if ((b + a) != 2)`: With $b=2$ and $a=0$, the condition is $(2 + 0) \\neq 2$, which simplifies to $2 \\neq 2$, which is definitively false. Thus, control flow unconditionally proceeds to $B_3$. The path to $B_2$ is unreachable.\n    - We propagate the output state of $B_1$ to $B_3$ and add $B_3$ to the worklist.\n\n- **Process $B_3$**:\n    - The input state to $B_3$ comes from its predecessors. At this point, only $B_1$ has contributed. The state flowing from $B_2$ is still all $\\bot$. The meet operation is $IN(B_3) = OUT(B_1) \\sqcap OUT(B_2)$. Since $OUT(B_2)$ is all $\\bot$ and $\\bot$ is the identity for $\\sqcap$, the input state to $B_3$ is simply the state from $B_1$: $\\{ n \\mapsto \\top, K \\mapsto 7, a \\mapsto 0, b \\mapsto 2, \\dots \\}$.\n    - Instruction $x := n + b + K - 9$: We evaluate this using the known constant values: $x := n + 2 + 7 - 9 = n + 0 = n$. Since $n \\mapsto \\top$, the result is $x \\mapsto \\top$.\n    - The output state of $B_3$ is $\\{ n \\mapsto \\top, K \\mapsto 7, a \\mapsto 0, b \\mapsto 2, x \\mapsto \\top, \\dots \\}$.\n\nThe worklist is now empty, and subsequent iterations will not change any state maps. The fixed point is reached. The analysis concludes that the blocks $B_{\\mathrm{dead}}$ and $B_2$ are unreachable.\n\n#### 2. IR Simplification and Pseudo-code Generation\n\nBased on the analysis, we can simplify the IR by propagating constants and eliminating dead code.\n\n- **Block $B_0$**: The assignment `K := ROLOAD($\\alpha$)` is replaced by `K := 7`. The assignment `a := K - 7` becomes `a := 0`. The branch `if (a != 0)` becomes `if (0 != 0)`, which is an unconditional jump to $B_1$.\n- **Block $B_1$**: It receives `a=0` from $B_0$. The assignment `b := 2` is preserved. The branch `if ((b + a) != 2)` becomes `if ((2 + 0) != 2)`, which is an unconditional jump to $B_3$.\n- **Block $B_2$**: This block is identified as unreachable and is removed entirely.\n- **Block $B_3$**: This block is reached from $B_1$ with constant values `K=7` and `b=2`. The assignment `x := n + b + K - 9` is subjected to constant folding:\n$$x := n + 2 + 7 - 9$$\n$$x := n + 9 - 9$$\n$$x := n$$\n\nThe entire CFG collapses into a single linear sequence of operations leading to `return x`. Merging the logic, the function's behavior is simplified to calculating $x=n$ and returning it.\n\n**Simplified High-Level Pseudo-code**:\n```\nfunction simplified_function(n: integer): integer\n  return n\nend function\n```\n\n#### 3. Verification with State Transition Equations\n\nWe verify that only one execution path is feasible. Let the state be a tuple of values for the program variables $(K, a, b, c, t, x)$ and the program counter (PC). The input $n$ is a symbolic constant.\n\n**Initial State**: $S_0 = (\\text{PC}=B_0, K=?, a=?, b=?, c=?, t=?, x=?)$\n\n1.  **At $B_0$**:\n    - $K := \\mathrm{ROLOAD}(\\alpha) \\implies K' = 7$.\n    - $a := K - 7 \\implies a' = 7 - 7 = 0$.\n    - State before branch: $(K=7, a=0, \\dots)$.\n    - `if (a != 0)`: The condition is $0 \\neq 0$, which is false.\n    - **Path Feasibility**: The branch to $B_{\\mathrm{dead}}$ is infeasible. The only feasible transition is to $B_1$.\n    - State after $B_0$: $S_1 = (\\text{PC}=B_1, K=7, a=0, b=?, \\dots)$.\n\n2.  **At $B_1$**:\n    - State upon entry: $S_1$.\n    - $b := 2 \\implies b' = 2$.\n    - State before branch: $(K=7, a=0, b=2, \\dots)$.\n    - `if ((b + a) != 2)`: The condition is $(2 + 0) \\neq 2$, which is $2 \\neq 2$, which is false.\n    - **Path Feasibility**: The branch to $B_2$ is infeasible. The only feasible transition is to $B_3$.\n    - State after $B_1$: $S_2 = (\\text{PC}=B_3, K=7, a=0, b=2, c=?, \\dots)$.\n\n3.  **At $B_3$**:\n    - State upon entry: $S_2$.\n    - $x := n + b + K - 9 \\implies x' = n + 2 + 7 - 9 = n$.\n    - **Final Computation**: The returned value is $x=n$.\n\nThis state transition analysis confirms that the only feasible execution path is $B_0 \\rightarrow B_1 \\rightarrow B_3$. The simplifications performed are correct.\n\n#### Final Expression\n\nThe returned value of the function is the value of the variable $x$. From the simplified and verified logic, the expression for $x$ is:\n$$x = n$$\nThis is the closed-form analytic expression for the returned value in terms of the input $n$.", "answer": "$$\\boxed{n}$$", "id": "3636449"}, {"introduction": "Low-level assembly code relies on conditional jumps, creating a complex web of control flow that can be hard for humans to understand. A decompiler's job is to transform this 'spaghetti code' back into structured conditional statements like `if-else`. This practice challenges you to reconstruct such a structure by analyzing the Control Flow Graph (CFG) and applying the concepts of dominance and post-dominance to identify logical blocks and their relationships. [@problem_id:3636537]", "problem": "A decompiler recovers structured control flow by reasoning about the Control Flow Graph (CFG) and its dominance and post-dominance relations. Consider the following simplified x86-32 assembly snippet (assume Intel syntax, and that each label introduces a unique Basic Block (BB), with fall-through semantics as usual):\n\nentry:\n  mov eax, [x]\n  test eax, eax           ; sets Sign Flag (SF) and Zero Flag (ZF)\n  js L_neg                ; jump if SF=1 (negative)\n  cmp eax, [y]            ; sets ZF based on eax == [y]\n  je L_eq                 ; jump if ZF=1 (equal)\nL_ne:\n  add eax, 5\n  jmp L_join\nL_eq:\n  imul eax, 3\n  sub eax, 4\n  jmp L_join\nL_neg:\n  neg eax\n  add eax, 7\n  imul eax, 2\nL_join:\n  lea eax, [eax + 3*eax]  ; multiply eax by 4\n  sub eax, 6\n  mov [out], eax\n  ret\n\nAssume the standard semantics of the Intel Extended Flags Register (EFLAGS): the Sign Flag (SF) is set if the most-significant bit of the result is $1$, and the Zero Flag (ZF) is set if the result is $0$. The Control Flow Graph (CFG) has an entry at the label $entry$ and an exit at $ret$. For the purpose of counting, define an arithmetic operation as any instruction among $\\{\\text{neg}, \\text{add}, \\text{sub}, \\text{imul}, \\text{lea}\\}$; other instructions do not count as arithmetic operations.\n\nTasks:\n1. Using the standard definitions of dominance and post-dominance in a CFG (a node $d$ dominates a node $n$ if every path from the entry to $n$ passes through $d$; a node $p$ post-dominates a node $n$ if every path from $n$ to the exit passes through $p$), recover the structured high-level if-else nesting implied by the snippet and justify the structure by identifying which Basic Blocks (BBs) dominate or post-dominate the branch and merge points. Do not provide code; provide only the structural description in prose.\n\n2. Let $p \\in [0,1]$ be the probability that the branch at $js$ is taken (that is, that $SF=1$ after $test$), and let $q \\in [0,1]$ be the conditional probability that the branch at $je$ is taken (that is, that $ZF=1$ after $cmp$) given that the $js$ branch is not taken. Under these definitions, derive a closed-form expression for the expected number of arithmetic operations executed on a single run of the snippet.\n\nExpress the final expected arithmetic-operation count as a single simplified analytic expression in terms of $p$ and $q$. No rounding is required. The final answer must be given as the closed-form expression only.", "solution": "The problem requires a two-part analysis of a given x86-32 assembly snippet. The first part is to recover the high-level control structure using dominance and post-dominance analysis. The second part is to derive the expected number of arithmetic operations executed, given probabilistic information about the branches.\n\nFirst, we must construct the Control Flow Graph (CFG) from the assembly code. A Basic Block (BB) is a sequence of instructions with a single entry point and a single exit point. The provided labels and branching instructions define the structure of the CFG.\n\nThe Basic Blocks are:\n1.  **B_entry**: This block starts at the `entry` label and ends with the first conditional jump.\n    ```assembly\n    entry:\n      mov eax, [x]\n      test eax, eax\n      js L_neg\n    ```\n    This block has two successors: `B_neg` if the jump is taken (`SF=1`), and `B_cmp` if it falls through.\n\n2.  **B_cmp**: This block begins after the `js` instruction and ends with the `je` jump.\n    ```assembly\n    cmp eax, [y]\n    je L_eq\n    ```\n    This block has two successors: `B_eq` if the jump is taken (`ZF=1`), and `B_ne` if it falls through.\n\n3.  **B_ne**: This block corresponds to the `L_ne` label.\n    ```assembly\n    L_ne:\n      add eax, 5\n      jmp L_join\n    ```\n    This block has one successor: `B_join`.\n\n4.  **B_eq**: This block corresponds to the `L_eq` label.\n    ```assembly\n    L_eq:\n      imul eax, 3\n      sub eax, 4\n      jmp L_join\n    ```\n    This block has one successor: `B_join`.\n\n5.  **B_neg**: This block corresponds to the `L_neg` label.\n    ```assembly\n    L_neg:\n      neg eax\n      add eax, 7\n      imul eax, 2\n    ```\n    This block falls through to its successor, `B_join`.\n\n6.  **B_join**: This block corresponds to the `L_join` label and contains the final `ret` instruction.\n    ```assembly\n    L_join:\n      lea eax, [eax + 3*eax]\n      sub eax, 6\n      mov [out], eax\n      ret\n    ```\n    This block is the exit block of the function.\n\nThe CFG can be summarized as follows:\n- `B_entry` branches to `B_neg` and `B_cmp`.\n- `B_cmp` branches to `B_eq` and `B_ne`.\n- `B_neg`, `B_eq`, and `B_ne` all proceed to `B_join`.\n- `B_join` is the single exit point.\n\n**Part 1: Control Flow Structure Recovery**\n\nTo recover the high-level structure, we analyze the dominance and post-dominance properties of the CFG.\n- A node $d$ **dominates** a node $n$ if every path from the entry node to $n$ must pass through $d$.\n- A node $p$ **post-dominates** a node $n$ if every path from $n$ to the exit node must pass through $p$.\n\nA structured `if-then-else` statement corresponds to a region in the CFG with a single entry (the header) and a single exit (the merge point). The header must dominate all blocks in the region, and the merge point must post-dominate all blocks in the region.\n\n1.  **Outer Structure**:\n    - The branch is in `B_entry`, which acts as the header. As the entry block, `B_entry` dominates all other blocks in the CFG.\n    - The two paths starting from `B_entry` go to `B_neg` and `B_cmp`.\n    - All possible execution paths (`B_entry` $\\rightarrow$ `B_neg` $\\rightarrow$ `B_join`; `B_entry` $\\rightarrow$ `B_cmp` $\\rightarrow$ `B_eq` $\\rightarrow$ `B_join`; `B_entry` $\\rightarrow$ `B_cmp` $\\rightarrow$ `B_ne` $\\rightarrow$ `B_join`) must converge at `B_join` before exiting.\n    - Therefore, `B_join` post-dominates `B_entry` and all intermediate blocks (`B_neg`, `B_cmp`, `B_eq`, `B_ne`).\n    - This single-entry (`B_entry`), single-exit (`B_join`) pattern identifies an `if-else` structure. The test is `js L_neg`. The `then` clause corresponds to the path through `B_neg`. The `else` clause corresponds to the path through `B_cmp`.\n\n2.  **Inner Structure**:\n    - Within the `else` clause of the outer structure, we start at `B_cmp`.\n    - `B_cmp` contains a second conditional branch, `je L_eq`. This block acts as the header for a nested region.\n    - `B_cmp` is dominated by `B_entry` and dominates its successors, `B_eq` and `B_ne`.\n    - The paths from `B_cmp` go to `B_eq` and `B_ne`.\n    - Both `B_eq` and `B_ne` have `B_join` as their sole successor. Therefore, `B_join` post-dominates both `B_eq` and `B_ne`.\n    - This forms a nested `if-else` structure with `B_cmp` as the header and `B_join` as the merge point. The test is `je L_eq`. The `then` clause is `B_eq`. The `else` clause is `B_ne`.\n\n**Structural Description**: The assembly snippet implements a nested `if-else` structure. The outer `if` condition is based on the result of `test eax, eax`, corresponding to checking if the value of `eax` is negative. If it is negative, the code in block `B_neg` is executed. Otherwise (if it is zero or positive), a nested `if-else` is executed. The inner `if` condition, in block `B_cmp`, is based on `cmp eax, [y]`, checking if `eax` is equal to the value at memory location `y`. If they are equal, the code in block `B_eq` is executed; otherwise, the code in block `B_ne` is executed. All three possible execution paths (`B_neg`, `B_eq`, `B_ne`) merge at block `B_join`, which contains code common to all paths before the function returns.\n\n**Part 2: Expected Number of Arithmetic Operations**\n\nLet $N$ be the random variable representing the number of arithmetic operations executed. The set of arithmetic operations is defined as $\\{\\text{neg}, \\text{add}, \\text{sub}, \\text{imul}, \\text{lea}\\}$.\n\nFirst, we count the number of arithmetic operations in each relevant basic block:\n- `B_neg`: `neg`, `add`, `imul` $\\implies 3$ operations.\n- `B_eq`: `imul`, `sub` $\\implies 2$ operations.\n- `B_ne`: `add` $\\implies 1$ operation.\n- `B_join`: `lea`, `sub` $\\implies 2$ operations.\n- All other blocks (`B_entry`, `B_cmp`) contain $0$ arithmetic operations as defined.\n\nThe total number of operations depends on the execution path. The code in `B_join` is executed on every path.\n- **Path 1**: `B_entry` $\\rightarrow$ `B_neg` $\\rightarrow$ `B_join`. This path is taken if the `js` branch is taken.\n  - Number of operations, $C_1 = (\\text{ops in } B_{neg}) + (\\text{ops in } B_{join}) = 3 + 2 = 5$.\n  - The probability of this path is given as $P_1 = p$.\n\n- **Path 2**: `B_entry` $\\rightarrow$ `B_cmp` $\\rightarrow$ `B_eq` $\\rightarrow$ `B_join`. This path is taken if the `js` branch is not taken, and the subsequent `je` branch is taken.\n  - Number of operations, $C_2 = (\\text{ops in } B_{eq}) + (\\text{ops in } B_{join}) = 2 + 2 = 4$.\n  - The probability of the `js` branch not being taken is $1-p$. The conditional probability of the `je` branch being taken is $q$.\n  - The probability of this path is $P_2 = (1-p)q$.\n\n- **Path 3**: `B_entry` $\\rightarrow$ `B_cmp` $\\rightarrow$ `B_ne` $\\rightarrow$ `B_join`. This path is taken if the `js` branch is not taken, and the subsequent `je` branch is also not taken.\n  - Number of operations, $C_3 = (\\text{ops in } B_{ne}) + (\\text{ops in } B_{join}) = 1 + 2 = 3$.\n  - The probability of the `js` branch not being taken is $1-p$. The conditional probability of the `je` branch not being taken is $1-q$.\n  - The probability of this path is $P_3 = (1-p)(1-q)$.\n\nThe expected number of arithmetic operations, $E[N]$, is the sum of the products of the number of operations on each path and the probability of that path:\n$$ E[N] = C_1 P_1 + C_2 P_2 + C_3 P_3 $$\n$$ E[N] = 5 \\cdot p + 4 \\cdot (1-p)q + 3 \\cdot (1-p)(1-q) $$\n\nNow, we simplify this expression:\n$$ E[N] = 5p + (4q - 4pq) + (3 - 3q - 3p + 3pq) $$\n$$ E[N] = (5p - 3p) + (4q - 3q) + (-4pq + 3pq) + 3 $$\n$$ E[N] = 2p + q - pq + 3 $$\n\nThus, the expected number of arithmetic operations is $2p + q - pq + 3$.", "answer": "$$\\boxed{2p + q - pq + 3}$$", "id": "3636537"}, {"introduction": "Beyond simple conditional branches, loops represent another fundamental high-level construct that must be recovered from low-level code. This exercise focuses on identifying a canonical `for`-loop from a Control Flow Graph presented in Static Single Assignment (SSA) form. You will learn to recognize the key components of a structured loop—the preheader for initialization, the header for the exit condition, and the latch for the update—and see how SSA's $\\phi$-functions clarify the role of the induction variable. [@problem_id:3636518]", "problem": "You are given a control-flow graph in Static Single Assignment (SSA) form for a function whose loop should be decompiled into a high-level C-like for-statement. The machine uses unbounded signed integer arithmetic, and all arithmetic is over the integers. The control-flow graph has basic blocks labeled $B_0, B_1, B_2, B_3, B_4, B_5$ with the following structure and statements:\n\nFrom entry block $B_0$, control transfers to preheader block $B_1$. In the preheader $B_1$, the following definitions occur:\n- $T \\leftarrow 10N + 1$\n- $i_0 \\leftarrow 2N + 5$\n- $\\text{goto } B_2$\n\nIn the loop header $B_2$, a $\\phi$-function determines the current value of the induction variable:\n- $i \\leftarrow \\phi(B_1: i_0,\\; B_4: i_1)$\n- If $3i + 2  3T + 2$ then $\\text{goto } B_3$ else $\\text{goto } B_5$\n\nIn the loop body $B_3$, computations unrelated to loop control occur (you may treat them as opaque), followed by $\\text{goto } B_4$.\n\nIn the loop latch $B_4$, the induction variable is updated and control returns to the header:\n- $i_1 \\leftarrow i + 4$\n- $\\text{goto } B_2$\n\nBlock $B_5$ is the loop exit.\n\nAssume $N$ is a non-negative integer parameter defined before $B_1$ and does not change during the loop. Using the standard compiler principles definitions of dominance, natural loops, and properties of SSA $\\phi$-functions for induction variables, reconstruct the loop in canonical for-form $\\,\\texttt{for(init; cond; upd)}\\,$ by identifying the preheader initialization, the latch update, and the exit test, and then algebraically normalizing the exit test to expose a simple linear bound on $i$.\n\nFinally, derive a closed-form expression for the exact dynamic trip count (the number of times the loop body in $B_3$ executes) as a function of $N$, and evaluate it for $N = 37$. Your final answer must be the exact number of iterations as a single real-valued number. Do not round. Express the final answer without any units.", "solution": "The user has provided a control-flow graph for a loop in Static Single Assignment (SSA) form and has asked for a decompilation into a C-like `for`-loop, a closed-form expression for the loop's trip count, and the evaluation of this trip count for a specific value of the parameter $N$.\n\nFirst, we validate the problem statement.\nThe problem is well-defined within the domain of compiler theory and program analysis. The provided control-flow graph, with its basic blocks, SSA $\\phi$-functions, and conditional branches, represents a standard structure for a `while` or `for` loop. All variables and constants are clearly defined. The premise is scientifically grounded in computer science principles. The problem is self-contained, objective, and well-posed, admitting a unique, verifiable solution. Therefore, the problem is valid.\n\nWe will proceed by first reconstructing the canonical `for`-loop and then deriving the trip count. A canonical `for`-loop has the structure `for(initialization; condition; update)`. We can map the components of the given control-flow graph to these parts.\n\n1.  **Initialization (`init`)**: The initialization of the loop's induction variable occurs in the loop preheader, which is block $B_1$. The preheader is executed exactly once before the loop begins. The relevant statement is $i_0 \\leftarrow 2N + 5$. The $\\phi$-function in the header, $i \\leftarrow \\phi(B_1: i_0, \\dots)$, confirms that $i_0$ is the initial value of $i$ on the first entry to the loop header $B_2$. Thus, the initialization is `i = 2N + 5`.\n\n2.  **Condition (`cond`)**: The loop condition is the test performed in the loop header, $B_2$, to decide whether to execute the loop body or exit the loop. The statement `If $3i + 2  3T + 2$ then goto $B_3$ else goto $B_5$` shows that the loop continues as long as the inequality $3i + 2  3T + 2$ holds. The loop body is in block $B_3$, and the loop exit is block $B_5$. We must normalize this condition.\n    $$3i + 2  3T + 2$$\n    Subtracting $2$ from both sides gives:\n    $$3i  3T$$\n    Dividing by $3$ (since $3  0$, the inequality direction is preserved):\n    $$i  T$$\n    From the preheader $B_1$, we have the definition $T \\leftarrow 10N + 1$. Substituting this into the inequality gives the final loop condition:\n    $$i  10N + 1$$\n\n3.  **Update (`upd`)**: The update of the induction variable occurs in the loop latch, which is block $B_4$. This block is executed at the end of each iteration and unconditionally jumps back to the loop header. The statement is $i_1 \\leftarrow i + 4$. The value $i_1$ is then fed into the $\\phi$-function in the next iteration. This corresponds to the update statement `i = i + 4`, or more idiomatically, `i += 4`.\n\nCombining these three parts, the reconstructed C-like `for`-loop is:\n$\\texttt{for (i = 2N + 5; i  10N + 1; i += 4)}$\n\nNext, we derive a closed-form expression for the exact dynamic trip count, which is the number of times the loop body ($B_3$) is executed. Let $k$ be the iteration index, starting from $k=0$ for the first iteration. The value of the induction variable $i$ at the beginning of iteration $k$ can be expressed as a function of $k$.\nThe initial value (for $k=0$) is $i_0 = 2N + 5$.\nThe value is incremented by $4$ in each iteration. This forms an arithmetic progression.\nThe value of $i$ in the $k$-th iteration, denoted $i_k$, is given by:\n$$i_k = i_0 + k \\cdot 4 = (2N + 5) + 4k$$\nThe loop continues as long as the condition $i_k  10N + 1$ is satisfied. We substitute the expression for $i_k$ into this inequality:\n$$(2N + 5) + 4k  10N + 1$$\nWe solve for $k$. Since $N$ is a non-negative integer, all terms are integers.\n$$4k  (10N + 1) - (2N + 5)$$\n$$4k  8N - 4$$\n$$k  2N - 1$$\nThe iterations are indexed by non-negative integers $k = 0, 1, 2, \\dots$. The loop executes for all values of $k$ that satisfy this inequality.\nSo, the allowed values for $k$ are $\\{k \\in \\mathbb{Z} \\mid k \\ge 0 \\land k  2N-1\\}$.\n\nWe must consider two cases based on the value of $N$.\nCase 1: If $2N - 1 \\le 0$. Since $N$ is a non-negative integer, this only occurs when $N=0$, for which $2N-1 = -1$. The condition $k  -1$ has no solution for $k \\ge 0$. Therefore, the trip count is $0$. This aligns with checking the initial condition: for $N=0$, the initial value is $i_0 = 2(0)+5=5$ and the bound is $10(0)+1=1$. The condition $51$ is false, so the loop is not entered.\n\nCase 2: If $2N - 1  0$. This holds for all integers $N \\ge 1$. The set of integers for $k$ is $\\{0, 1, 2, \\dots, 2N-2\\}$. The number of elements in this set is the trip count.\n$$\\text{Trip Count} = (2N - 2) - 0 + 1 = 2N - 1$$\nWe can combine these two cases into a single expression using the maximum function:\n$$\\text{Trip Count}(N) = \\max(0, 2N - 1)$$\n\nFinally, we are asked to evaluate the trip count for $N = 37$.\nSince $N=37$ is an integer and $37 \\ge 1$, we use the formula $2N-1$.\n$$\\text{Trip Count}(37) = 2(37) - 1$$\n$$\\text{Trip Count}(37) = 74 - 1$$\n$$\\text{Trip Count}(37) = 73$$\nAlternatively, using the combined formula:\n$$\\text{Trip Count}(37) = \\max(0, 2(37) - 1) = \\max(0, 73) = 73$$\nThe number of times the loop body executes is $73$.", "answer": "$$\\boxed{73}$$", "id": "3636518"}]}