{"hands_on_practices": [{"introduction": "A frequent and subtle source of compiler bugs is the misinterpretation of undefined behavior (UB). This exercise explores how to create a fuzzer that detects when a compiler relies on UB assumptions for optimization [@problem_id:3642978]. By implementing a mutation operator that systematically removes branches designed to handle undefined states, you will learn to verify whether a compiler's transformations preserve the program's defined semantics across all possible inputs.", "problem": "You are given a simplified setting to explore fuzzing compilers by detecting reliance on undefined behavior using a mutation operator. The task is to construct a small interpreter for a toy expression language that models integer computations and a notion of undefined behavior, apply a systematic mutation operator that removes undefined-guarded branches, and compare the outputs of the original program (interpreted under a defined semantics) with the mutated program. The comparison is done over a finite test suite of input environments.\n\nFundamental base and definitions:\n- The guiding principle of compiler optimization correctness is semantic preservation: an optimization must not change the observable semantics of a program. If a compiler relies on Undefined Behavior (UB), it may assume certain conditions that are not guaranteed by the defined semantics. We model UB by a partial semantics that can fail to produce a defined integer result.\n- Consider a toy expression language over integer inputs with variables $x$, $y$, and $z$, and the following expressions: constants, variables, addition, subtraction, multiplication, a checked division, a definedness predicate, and a conditional expression. Formally, expressions $E$ are built from:\n  1. $E ::= c$ where $c \\in \\mathbb{Z}$,\n  2. $E ::= x \\mid y \\mid z$,\n  3. $E ::= E_1 + E_2 \\mid E_1 - E_2 \\mid E_1 \\times E_2$,\n  4. $E ::= \\mathrm{div\\_checked}(E_1,E_2)$,\n  5. $E ::= \\mathrm{is\\_defined}(E)$,\n  6. $E ::= \\mathrm{if}(C, T, F)$ where $C$ is a condition expression that yields an integer interpreted as a Boolean (nonzero is true, zero is false).\n- The semantics maps expressions to either a defined integer or an undefined result. Let $\\llbracket E \\rrbracket(\\rho)$ denote the evaluation of $E$ under an environment $\\rho$ assigning integer values to variables $x$, $y$, and $z$. We define:\n  1. Constants and variables: $\\llbracket c \\rrbracket(\\rho) = \\langle \\mathrm{def}, c \\rangle$, $\\llbracket x \\rrbracket(\\rho) = \\langle \\mathrm{def}, \\rho(x) \\rangle$, similarly for $y$ and $z$.\n  2. Binary arithmetic: For $E_1 \\circ E_2$ with $\\circ \\in \\{+, -, \\times\\}$, if either $\\llbracket E_1 \\rrbracket(\\rho)$ or $\\llbracket E_2 \\rrbracket(\\rho)$ is undefined, the result is undefined; otherwise it is the integer arithmetic result.\n  3. Checked division: $\\llbracket \\mathrm{div\\_checked}(E_1,E_2) \\rrbracket(\\rho)$ is undefined if either operand is undefined or if the divisor evaluates to $0$; otherwise it is integer division $E_1 / E_2$.\n  4. Definedness predicate: $\\llbracket \\mathrm{is\\_defined}(E) \\rrbracket(\\rho) = \\langle \\mathrm{def}, b \\rangle$ where $b = 1$ if $\\llbracket E \\rrbracket(\\rho)$ is defined, and $b = 0$ otherwise. This predicate does not itself become undefined.\n  5. Conditional: $\\llbracket \\mathrm{if}(C,T,F) \\rrbracket(\\rho)$ evaluates $C$ first. If $C$ is undefined, the defined semantics treats it as false, choosing $F$; if $C$ is defined and nonzero, it evaluates and returns $\\llbracket T \\rrbracket(\\rho)$; if $C$ is defined and zero, it evaluates and returns $\\llbracket F \\rrbracket(\\rho)$. If the chosen branch evaluates to undefined, the result is undefined.\n\nMutation operator:\n- A mutation operator models a class of compiler transforms that rely on undefined behavior by removing guards that check for definedness. The operator $\\mathcal{M}$ acts on the abstract syntax tree and replaces any conditional of the form $\\mathrm{if}(\\mathrm{is\\_defined}(E), T, F)$ with the branch $T$, thereby systematically removing the “undefined” branch $F$. The operator recurses into subexpressions to produce a mutated program $\\mathcal{M}(E)$.\n\nTask:\n- Implement an interpreter for the toy language as defined above, and implement the mutation operator $\\mathcal{M}$.\n- For each test case below, instantiate the program as an abstract syntax tree $E$, apply $\\mathcal{M}$ to obtain the mutated program $\\mathcal{M}(E)$, and compare the outputs of $\\llbracket E \\rrbracket(\\rho)$ and $\\llbracket \\mathcal{M}(E) \\rrbracket(\\rho)$ over the specified input environments $\\rho$. An environment $\\rho$ is a triple $(x,y,z) \\in \\mathbb{Z}^3$. A result is considered equal if both are defined and equal integers; otherwise they differ.\n- The final output of your program must be a single line that contains a comma-separated list of integers $0$ or $1$ enclosed in square brackets, where each entry corresponds to a test case and is $1$ if the mutated program is observationally equivalent to the original over all listed environments, and $0$ otherwise.\n\nTest suite:\n- Test case $1$ (basic guarded division with fallback):\n  - Program $E_1 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)),\\, \\mathrm{div\\_checked}(x,y) + 1,\\, 0)$.\n  - Environments: $(10,2,0)$, $(10,0,0)$, $(0,5,0)$, $(-9,3,0)$.\n- Test case $2$ (always-defined guard, happy path):\n  - Program $E_2 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)),\\, x \\times 2,\\, -1)$.\n  - Environments: $(7,123,0)$, $(-8,42,0)$, $(0,999,0)$.\n- Test case $3$ (nested guards, multiple potential undefined points):\n  - Program $E_3 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)),\\, \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(y,z)),\\, \\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z),\\, 7),\\, 8)$.\n  - Environments: $(12,3,2)$, $(12,0,2)$, $(12,3,0)$, $(0,10,2)$, $(9,-3,-3)$.\n- Test case $4$ (guard removal is semantics-preserving due to identical branches):\n  - Program $E_4 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)),\\, x + 0,\\, x + 0)$.\n  - Environments: $(5,100,0)$, $(-1,2,0)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where each $r_i \\in \\{0,1\\}$ corresponds to the equivalence check for test case $i$.", "solution": "The user-provided problem statement is valid. It is a well-posed, scientifically grounded problem within the domain of computer science, specifically concerning compiler theory and program semantics. It provides a formal system consisting of a toy programming language, a defined operational semantics including the concept of undefined behavior, and a mutation operator designed to model compiler optimizations that rely on assumptions about undefined behavior. The task is to implement this system, apply it to a given set of test cases, and determine the observational equivalence between the original and mutated programs. The problem is self-contained, logically consistent, and free of ambiguity.\n\nThe solution proceeds by first constructing the necessary data structures to represent the abstract syntax tree (AST) of the language. Then, two primary functions are implemented: an interpreter that computes the value of an expression according to the specified semantics, and a mutation function that transforms an expression's AST according to the given operator rule. Finally, each test case is executed by building the program's AST, mutating it, and comparing the evaluation results of both the original and mutated ASTs over a suite of input environments.\n\n### 1. Data Representation and Semantics\n\nAn expression $E$ is represented as a node in an AST. Each node contains a type tag and a payload corresponding to that type (e.g., a constant value, a variable identifier, or pointers to child nodes for operations).\n\nThe evaluation semantics $\\llbracket E \\rrbracket(\\rho)$ maps an expression $E$ and an environment $\\rho$ (a mapping from variables $x, y, z$ to integer values) to a result. The result is a pair $\\langle \\text{status}, \\text{value} \\rangle$, where status is either defined or undefined. This is implemented using a structure containing a boolean flag and an integer value.\n\nThe interpreter is a recursive function, `eval(E, rho)`, which traverses the AST.\n- For constants and variables, it returns the defined value directly from the AST node or the environment $\\rho$.\n- For arithmetic operations $E_1 \\circ E_2$ (where $\\circ \\in \\{+, -, \\times\\}$), it recursively evaluates $E_1$ and $E_2$. If either sub-evaluation results in an undefined status, the operation's result is also undefined. Otherwise, the integer operation is performed.\n- For $\\mathrm{div\\_checked}(E_1, E_2)$, it follows the arithmetic operation logic but adds a check for the divisor: if the value of $\\llbracket E_2 \\rrbracket(\\rho)$ is $0$, the result is undefined.\n- The predicate $\\llbracket \\mathrm{is\\_defined}(E) \\rrbracket(\\rho)$ evaluates $E$. It returns a defined result of $\\langle \\mathrm{def}, 1 \\rangle$ if $\\llbracket E \\rrbracket(\\rho)$ is defined, and $\\langle \\mathrm{def}, 0 \\rangle$ if it is not. This operation itself never yields an undefined result.\n- The conditional $\\llbracket \\mathrm{if}(C, T, F) \\rrbracket(\\rho)$ is unique. It first evaluates the condition $C$. If $\\llbracket C \\rrbracket(\\rho)$ is undefined, the semantics specify treating this as a false condition, thus evaluating the false-branch $F$. If $\\llbracket C \\rrbracket(\\rho)$ is defined, its integer value is treated as a boolean ($0$ is false, non-zero is true) to select either the $T$ or $F$ branch for evaluation.\n\n### 2. Mutation Operator\n\nThe mutation operator $\\mathcal{M}$ is implemented as a recursive function, `mutate(E)`, that constructs a new, mutated AST. The transformation is compositional:\n- For expression types other than `if`, the operator recurses on the subexpressions and rebuilds the same expression type with the mutated subexpressions. For example, $\\mathcal{M}(E_1+E_2) = \\mathcal{M}(E_1) + \\mathcal{M}(E_2)$.\n- For a conditional expression $\\mathrm{if}(C, T, F)$, the operator inspects the condition $C$.\n  - If $C$ is of the form $\\mathrm{is\\_defined}(E')$, the entire `if` expression is replaced by the result of mutating the true branch, $T$. That is, $\\mathcal{M}(\\mathrm{if}(\\mathrm{is\\_defined}(E'), T, F)) = \\mathcal{M}(T)$. This models the compiler assuming the guard is always true and thus eliminating the check and the false branch.\n  - Otherwise, the operator recurses into all three subexpressions: $\\mathcal{M}(\\mathrm{if}(C, T, F)) = \\mathrm{if}(\\mathcal{M}(C), \\mathcal{M}(T), \\mathcal{M}(F))$.\n\n### 3. Test Case Analysis\n\nA program is observationally equivalent to its mutation for a given test case if and only if for every specified environment $\\rho$, $\\llbracket E \\rrbracket(\\rho)$ and $\\llbracket \\mathcal{M}(E) \\rrbracket(\\rho)$ are either both undefined, or both defined with the same integer value.\n\n**Test Case 1:** $E_1 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)),\\, \\mathrm{div\\_checked}(x,y) + 1,\\, 0)$\n- Mutated program: $\\mathcal{M}(E_1) = \\mathcal{M}(\\mathrm{div\\_checked}(x,y) + 1) = \\mathrm{div\\_checked}(x,y) + 1$.\n- Environment $(10, 0, 0)$:\n  - $\\llbracket E_1 \\rrbracket((10,0,0))$: $\\mathrm{div\\_checked}(10,0)$ is undefined. $\\mathrm{is\\_defined}(\\dots)$ is false ($0$). The `if` evaluates its false branch, yielding a defined result of $0$.\n  - $\\llbracket \\mathcal{M}(E_1) \\rrbracket((10,0,0))$: $\\mathrm{div\\_checked}(10,0) + 1$ attempts to evaluate division by zero, resulting in an undefined result.\n- The results differ ($0$ vs. undefined). Thus, equivalence is $0$.\n\n**Test Case 2:** $E_2 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)),\\, x \\times 2,\\, -1)$\n- Mutated program: $\\mathcal{M}(E_2) = \\mathcal{M}(x \\times 2) = x \\times 2$.\n- The condition $\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1))$ is always true for any integer $x$, since division by $1$ is always defined.\n- Therefore, $\\llbracket E_2 \\rrbracket(\\rho)$ always evaluates the true branch, $x \\times 2$, which is identical to the mutated program $\\mathcal{M}(E_2)$.\n- The programs are equivalent for all inputs. Thus, equivalence is $1$.\n\n**Test Case 3:** $E_3 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)),\\, \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(y,z)),\\, \\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z),\\, 7),\\, 8)$\n- Mutated program: The mutation operator is applied recursively. The outer `if` condition matches the pattern, so it is replaced by the mutation of its true branch. The true branch is another `if` that also matches the pattern.\n  - $\\mathcal{M}(E_3) = \\mathcal{M}(\\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(y,z)), \\dots, 7))$\n  - $= \\mathcal{M}(\\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z)) = \\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z)$.\n- Environment $(12, 0, 2)$:\n  - $\\llbracket E_3 \\rrbracket((12,0,2))$: $\\mathrm{div\\_checked}(12,0)$ is undefined. The outer `is_defined` is false ($0$). The `if` evaluates the false branch, yielding a defined result of $8$.\n  - $\\llbracket \\mathcal{M}(E_3) \\rrbracket((12,0,2))$: $\\mathrm{div\\_checked}(12,0) + \\mathrm{div\\_checked}(0,2)$ is undefined due to the first term.\n- The results differ ($8$ vs. undefined). Thus, equivalence is $0$.\n\n**Test Case 4:** $E_4 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)),\\, x + 0,\\, x + 0)$\n- Mutated program: $\\mathcal{M}(E_4) = \\mathcal{M}(x+0) = x+0$.\n- The condition $\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1))$ is always true. The original program always evaluates the true branch, $x+0$.\n- The true and false branches are identical, and the mutated program is also equivalent to $x+0$. Therefore, both original and mutated programs will produce identical results for all inputs.\n- The programs are equivalent. Thus, equivalence is $1$.\n\nThe final results for the test cases are $[0, 1, 0, 1]$.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include stdbool.h\n#include string.h\n#include math.h\n\n// --- Data Structures for AST and Evaluation ---\n\n// Defines the type of an expression node in the AST.\ntypedef enum {\n    EXPR_CONST, EXPR_VAR,\n    EXPR_ADD, EXPR_SUB, EXPR_MUL,\n    EXPR_DIV_CHECKED, EXPR_IS_DEFINED, EXPR_IF\n} ExprType;\n\n// Forward declaration for the expression structure.\ntypedef struct Expr Expr;\n\n// The structure for an Abstract Syntax Tree (AST) node.\nstruct Expr {\n    ExprType type;\n    union {\n        int value; // For EXPR_CONST\n        int var_idx; // 0 for x, 1 for y, 2 for z\n        struct { Expr *e1; Expr *e2; } bin_op;\n        struct { Expr *e; } un_op;\n        struct { Expr *cond; Expr *t_branch; Expr *f_branch; } if_op;\n    } as;\n};\n\n// Represents the result of an evaluation, which can be defined or undefined.\ntypedef struct {\n    bool is_defined;\n    int value;\n} Result;\n\n// Represents an input environment (x, y, z).\ntypedef struct {\n    int x;\n    int y;\n    int z;\n} Environment;\n\n\n// --- AST Node Factory Functions ---\n\nExpr* make_const(int value) {\n    Expr* e = malloc(sizeof(Expr));\n    e-type = EXPR_CONST;\n    e-as.value = value;\n    return e;\n}\n\nExpr* make_var(int var_idx) {\n    Expr* e = malloc(sizeof(Expr));\n    e-type = EXPR_VAR;\n    e-as.var_idx = var_idx;\n    return e;\n}\n\nExpr* make_bin_op(ExprType type, Expr* e1, Expr* e2) {\n    Expr* e = malloc(sizeof(Expr));\n    e-type = type;\n    e-as.bin_op.e1 = e1;\n    e-as.bin_op.e2 = e2;\n    return e;\n}\n\nExpr* make_is_defined(Expr* sub_expr) {\n    Expr* e = malloc(sizeof(Expr));\n    e-type = EXPR_IS_DEFINED;\n    e-as.un_op.e = sub_expr;\n    return e;\n}\n\nExpr* make_if(Expr* cond, Expr* t_branch, Expr* f_branch) {\n    Expr* e = malloc(sizeof(Expr));\n    e-type = EXPR_IF;\n    e-as.if_op.cond = cond;\n    e-as.if_op.t_branch = t_branch;\n    e-as.if_op.f_branch = f_branch;\n    return e;\n}\n\n// Recursively frees an AST.\nvoid free_expr(Expr* e) {\n    if (e == NULL) return;\n    switch (e-type) {\n        case EXPR_CONST:\n        case EXPR_VAR:\n            break;\n        case EXPR_ADD:\n        case EXPR_SUB:\n        case EXPR_MUL:\n        case EXPR_DIV_CHECKED:\n            free_expr(e-as.bin_op.e1);\n            free_expr(e-as.bin_op.e2);\n            break;\n        case EXPR_IS_DEFINED:\n            free_expr(e-as.un_op.e);\n            break;\n        case EXPR_IF:\n            free_expr(e-as.if_op.cond);\n            free_expr(e-as.if_op.t_branch);\n            free_expr(e-as.if_op.f_branch);\n            break;\n    }\n    free(e);\n}\n\n// --- Interpreter and Mutation Operator ---\n\n// Evaluates an expression AST according to the defined semantics.\nResult eval(const Expr* e, const Environment* rho) {\n    if (e == NULL) return (Result){false, 0};\n\n    switch (e-type) {\n        case EXPR_CONST:\n            return (Result){true, e-as.value};\n        case EXPR_VAR: {\n            int val = 0;\n            if (e-as.var_idx == 0) val = rho-x;\n            else if (e-as.var_idx == 1) val = rho-y;\n            else val = rho-z;\n            return (Result){true, val};\n        }\n        case EXPR_ADD:\n        case EXPR_SUB:\n        case EXPR_MUL:\n        case EXPR_DIV_CHECKED: {\n            Result r1 = eval(e-as.bin_op.e1, rho);\n            if (!r1.is_defined) return r1;\n            Result r2 = eval(e-as.bin_op.e2, rho);\n            if (!r2.is_defined) return r2;\n\n            if (e-type == EXPR_ADD) return (Result){true, r1.value + r2.value};\n            if (e-type == EXPR_SUB) return (Result){true, r1.value - r2.value};\n            if (e-type == EXPR_MUL) return (Result){true, r1.value * r2.value};\n            if (e-type == EXPR_DIV_CHECKED) {\n                if (r2.value == 0) return (Result){false, 0};\n                return (Result){true, r1.value / r2.value};\n            }\n        }\n        case EXPR_IS_DEFINED: {\n            Result r = eval(e-as.un_op.e, rho);\n            return (Result){true, r.is_defined ? 1 : 0};\n        }\n        case EXPR_IF: {\n            Result c_res = eval(e-as.if_op.cond, rho);\n            if (!c_res.is_defined) {\n                return eval(e-as.if_op.f_branch, rho);\n            }\n            if (c_res.value != 0) {\n                return eval(e-as.if_op.t_branch, rho);\n            } else {\n                return eval(e-as.if_op.f_branch, rho);\n            }\n        }\n    }\n    return (Result){false, 0}; // Should be unreachable\n}\n\n// Creates a new, mutated AST based on the mutation operator rules.\nExpr* mutate(const Expr* e) {\n    if (e == NULL) return NULL;\n\n    if (e-type == EXPR_IF  e-as.if_op.cond-type == EXPR_IS_DEFINED) {\n        // Special rule: if(is_defined(E), T, F) - M(T)\n        return mutate(e-as.if_op.t_branch);\n    }\n    \n    switch (e-type) {\n        case EXPR_CONST:\n            return make_const(e-as.value);\n        case EXPR_VAR:\n            return make_var(e-as.var_idx);\n        case EXPR_ADD:\n        case EXPR_SUB:\n        case EXPR_MUL:\n        case EXPR_DIV_CHECKED:\n            return make_bin_op(e-type, mutate(e-as.bin_op.e1), mutate(e-as.bin_op.e2));\n        case EXPR_IS_DEFINED:\n            return make_is_defined(mutate(e-as.un_op.e));\n        case EXPR_IF:\n             return make_if(mutate(e-as.if_op.cond),\n                            mutate(e-as.if_op.t_branch),\n                            mutate(e-as.if_op.f_branch));\n    }\n    return NULL; // Should be unreachable\n}\n\n// --- Test Case Definitions ---\n\n// Test Case 1: E1 = if(is_defined(div_checked(x,y)), div_checked(x,y) + 1, 0)\nExpr* build_e1() {\n    return make_if(\n        make_is_defined(make_bin_op(EXPR_DIV_CHECKED, make_var(0), make_var(1))),\n        make_bin_op(EXPR_ADD, make_bin_op(EXPR_DIV_CHECKED, make_var(0), make_var(1)), make_const(1)),\n        make_const(0)\n    );\n}\n\n// Test Case 2: E2 = if(is_defined(div_checked(x,1)), x * 2, -1)\nExpr* build_e2() {\n    return make_if(\n        make_is_defined(make_bin_op(EXPR_DIV_CHECKED, make_var(0), make_const(1))),\n        make_bin_op(EXPR_MUL, make_var(0), make_const(2)),\n        make_const(-1)\n    );\n}\n\n// Test Case 3: E3 = if(is_defined(div_checked(x,y)), if(is_defined(div_checked(y,z)), div_checked(x,y) + div_checked(y,z), 7), 8)\nExpr* build_e3() {\n    Expr* inner_if = make_if(\n        make_is_defined(make_bin_op(EXPR_DIV_CHECKED, make_var(1), make_var(2))),\n        make_bin_op(EXPR_ADD,\n            make_bin_op(EXPR_DIV_CHECKED, make_var(0), make_var(1)),\n            make_bin_op(EXPR_DIV_CHECKED, make_var(1), make_var(2))\n        ),\n        make_const(7)\n    );\n    return make_if(\n        make_is_defined(make_bin_op(EXPR_DIV_CHECKED, make_var(0), make_var(1))),\n        inner_if,\n        make_const(8)\n    );\n}\n\n// Test Case 4: E4 = if(is_defined(div_checked(x,1)), x + 0, x + 0)\nExpr* build_e4() {\n    return make_if(\n        make_is_defined(make_bin_op(EXPR_DIV_CHECKED, make_var(0), make_const(1))),\n        make_bin_op(EXPR_ADD, make_var(0), make_const(0)),\n        make_bin_op(EXPR_ADD, make_var(0), make_const(0))\n    );\n}\n\n// Structure for a complete test case.\ntypedef struct {\n    Expr* (*builder)(void);\n    Environment* envs;\n    int num_envs;\n} TestCase;\n\nint main(void) {\n    Environment envs1[] = {{10,2,0}, {10,0,0}, {0,5,0}, {-9,3,0}};\n    Environment envs2[] = {{7,123,0}, {-8,42,0}, {0,999,0}};\n    Environment envs3[] = {{12,3,2}, {12,0,2}, {12,3,0}, {0,10,2}, {9,-3,-3}};\n    Environment envs4[] = {{5,100,0}, {-1,2,0}};\n\n    TestCase test_cases[] = {\n        {build_e1, envs1, sizeof(envs1) / sizeof(envs1[0])},\n        {build_e2, envs2, sizeof(envs2) / sizeof(envs2[0])},\n        {build_e3, envs3, sizeof(envs3) / sizeof(envs3[0])},\n        {build_e4, envs4, sizeof(envs4) / sizeof(envs4[0])},\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    for (int i = 0; i  num_cases; ++i) {\n        Expr* original_e = test_cases[i].builder();\n        Expr* mutated_e = mutate(original_e);\n        \n        int is_equivalent = 1; // Assume equivalence until a counterexample is found.\n        for (int j = 0; j  test_cases[i].num_envs; ++j) {\n            Result r_orig = eval(original_e, test_cases[i].envs[j]);\n            Result r_mut = eval(mutated_e, test_cases[i].envs[j]);\n            \n            bool are_equal = (r_orig.is_defined == r_mut.is_defined) \n                             (!r_orig.is_defined || r_orig.value == r_mut.value);\n            \n            if (!are_equal) {\n                is_equivalent = 0;\n                break;\n            }\n        }\n        results[i] = is_equivalent;\n        \n        free_expr(original_e);\n        free_expr(mutated_e);\n    }\n    \n    printf(\"[%d,%d,%d,%d]\", results[0], results[1], results[2], results[3]);\n    \n    return EXIT_SUCCESS;\n}\n```", "id": "3642978"}, {"introduction": "Metamorphic testing is an essential technique for fuzzing compilers, especially for verifying complex optimizations where a simple input-output oracle is unavailable. This practice demonstrates how to construct a metamorphic test for Dead Code Elimination (DCE), a common optimization [@problem_id:3643049]. You will verify the principle that code with observable side effects is not \"dead\" and must not be eliminated, even when guarded by a condition that appears to be constant.", "problem": "You are asked to design and implement a metamorphic test generator and checker for dead code elimination within the context of fuzzing compilers. The goal is to capture a semantics-preserving relation that holds under constant guards and to detect violations due to missed side effects. You will work with a small, deterministic, imperative core that models observable outputs. The final deliverable must be a complete, runnable program that produces a single line of output in the exact format specified.\n\nThe fundamental base for this exercise draws from two principles in compiler theory:\n- Semantics-preserving optimization: If a transformation maps a program $P$ to $P'$ such that both yield the same observable behavior for all initial states, then the transformation is valid.\n- Dead Code Elimination (DCE): Code that does not affect the observable behavior of the program can be eliminated. For a constant guard, if a block is guarded by a condition that is provably always false, then executing or removing that block must not alter the observable outputs when the block is free of side effects.\n\nWe define the observable behavior of a program to be a vector of outputs measured after execution. Let the program be a function $E(P, \\sigma) \\rightarrow \\mathbf{o}$ mapping program $P$ and initial state $\\sigma$ to an output vector $\\mathbf{o}$. For a constant guard $G \\in \\{0,1\\}$ and a block $B$:\n- If $B$ is pure (no side effects and does not change observable outputs), then the program with $G = 0$ and the same program with $G = 1$ must have identical $\\mathbf{o}$, that is, $E(P; G \\!=\\! 0, \\sigma) = E(P; G \\!=\\! 1, \\sigma)$.\n- If $B$ has side effects (e.g., writes to a global state, writes to a volatile location, atomic operations), then toggling a constant guard may change $\\mathbf{o}$, revealing that $B$ affects observable behavior and therefore must not be eliminated under DCE.\n\nYour task is to:\n1. Implement a deterministic evaluator for a small, safe subset of imperative operations with the following observable outputs:\n   - A computed result $r = a \\cdot b + b + a$ from inputs $a$ and $b$.\n   - A global state $g$.\n   - A volatile sink $v$.\n   - An atomic counter $c$.\n   The observable output vector is $\\mathbf{o} = [r, g, v, c]$.\n\n2. Implement a metamorphic checker that evaluates two versions of the program: one with the constant guard set to $0$ (the guarded block does not execute) and one with the constant guard set to $1$ (the guarded block executes). For each test case, compute the distance\n   $$ d = |r_0 - r_1| + |g_0 - g_1| + |v_0 - v_1| + |c_0 - c_1|, $$\n   where $\\mathbf{o}_0 = [r_0, g_0, v_0, c_0]$ is the output with $G = 0$, and $\\mathbf{o}_1 = [r_1, g_1, v_1, c_1]$ is the output with $G = 1$. A value of $d = 0$ indicates metamorphic equivalence under dead code elimination; a value of $d \\neq 0$ reveals observed differences that could be due to side effects.\n\n3. Use a fixed test suite that exercises:\n   - The general case where the guarded block is pure and does not affect outputs.\n   - Boundary conditions such as an empty block.\n   - Significant edge cases where the guarded block contains side effects (global writes, volatile writes, atomic operations).\n\nThe mini-language supports the following instruction kinds inside the guarded block:\n- Pure local arithmetic on a local variable $x$: add and multiply by a constant.\n- Side-effect operations:\n  - Incrementing the global state $g$ by a constant.\n  - Writing to a volatile sink $v$ by a constant.\n  - Performing an atomic fetch-and-add on atomic counter $c$ by a constant.\n\nThe base program uses inputs $(a,b)$ and computes $r = a \\cdot b + b + a$, independent of the guarded block if it is pure. The guarded block does not modify $r$ directly in any test.\n\nTest Suite (all initial states and constants are integers, chosen to avoid undefined behavior):\n- Case $1$ (pure local changes only):\n  - Inputs: $(a,b) = (3,4)$.\n  - Initial state: $(g,v,c) = (10,100,0)$.\n  - Block: add $5$ to local $x$, then multiply local $x$ by $2$.\n  - Expected metamorphic result: $d = 0$.\n- Case $2$ (global side effect):\n  - Inputs: $(a,b) = (2,5)$.\n  - Initial state: $(g,v,c) = (0,0,0)$.\n  - Block: increment global $g$ by $7$.\n  - Expected metamorphic result: $d = 7$.\n- Case $3$ (empty block boundary):\n  - Inputs: $(a,b) = (0,0)$.\n  - Initial state: $(g,v,c) = (0,0,0)$.\n  - Block: empty.\n  - Expected metamorphic result: $d = 0$.\n- Case $4$ (volatile side effect):\n  - Inputs: $(a,b) = (7,1)$.\n  - Initial state: $(g,v,c) = (0,3,2)$.\n  - Block: write $3$ to volatile sink $v$ by increment.\n  - Expected metamorphic result: $d = 3$.\n- Case $5$ (atomic side effect):\n  - Inputs: $(a,b) = (4,2)$.\n  - Initial state: $(g,v,c) = (1,0,5)$.\n  - Block: atomic fetch-and-add $5$ to $c$.\n  - Expected metamorphic result: $d = 5$.\n- Case $6$ (mixed pure and side effects):\n  - Inputs: $(a,b) = (1,3)$.\n  - Initial state: $(g,v,c) = (2,8,0)$.\n  - Block: add $1$ to local $x$, increment global $g$ by $4$, volatile write $2$ to $v$, atomic add $1$ to $c$.\n  - Expected metamorphic result: $d = 7$.\n\nFinal Output Specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite cases:\n  - For the above test suite, the program must print a single line in the format\n    $$ [d_1,d_2,d_3,d_4,d_5,d_6]. $$\n- No additional text should be printed.\n\nThere are no physical units involved. Angles do not apply. Express any fractional quantities as decimals if needed, though this test suite uses integers only.\n\nYour implementation must be entirely self-contained, deterministic, and require no input. It must adhere to the constraints in the final answer section.", "solution": "The user has provided a valid problem statement. The problem is scientifically grounded in the principles of compiler theory, specifically concerning semantics-preserving optimizations like Dead Code Elimination (DCE) and the handling of side effects. It is well-posed, with a clear objective, a deterministic computational model, and a complete set of test cases and expected outcomes. The language is objective and formal. A minor ambiguity in the wording of \"volatile write\" operations is noted but is resolved through consistent interpretation guided by the provided expected results.\n\nThe core task is to implement a metamorphic test for a compiler's DCE optimization. Metamorphic testing is a technique used to verify software properties when a formal oracle (a source of expected correct outputs) is unavailable. Instead, it checks for the preservation of mathematical relations, known as metamorphic relations, between different program inputs and their corresponding outputs.\n\nIn this context, the metamorphic relation concerns a program $P$ containing a code block $B$ guarded by a constant conditional. Let $E(P, \\sigma) \\rightarrow \\mathbf{o}$ be a function that executes program $P$ with an initial state $\\sigma$ to produce an observable output vector $\\mathbf{o}$. The two test inputs are two variants of the same program: one where block $B$ is guarded by a condition that is always false (e.g., `if (0)`), and one where the guard is always true (e.g., `if (1)`).\n\nIf the block $B$ is \"pure,\" meaning it has no side effects on the observable state of the program, then a correct DCE optimization could eliminate the block and its guard entirely. In this scenario, the observable outputs must be identical regardless of whether the block was notionally executed or not. This gives the metamorphic relation:\n$$\nE(P; G = 0, \\sigma) = E(P; G = 1, \\sigma)\n$$\nwhere $G \\in \\{0, 1\\}$ is the constant guard.\n\nHowever, if block $B$ contains side effects (e.g., modifying global variables, performing I/O, or executing atomic operations), it is no longer \"dead code,\" even if it does not contribute to a specific computed result. A correct compiler must not eliminate such a block, and its execution will alter the observable state. This leads to a violation of the metamorphic relation, i.e., $E(P; G = 0, \\sigma) \\neq E(P; G = 1, \\sigma)$. Detecting this difference is the goal of our test.\n\nThe observable output vector is defined as $\\mathbf{o} = [r, g, v, c]$, where:\n- $r$ is a computed result, $r = a \\cdot b + b + a$, derived from program inputs $(a,b)$.\n- $g$ is a global integer variable.\n- $v$ is a volatile integer sink, modeling a memory location whose modification is an observable side effect.\n- $c$ is an atomic integer counter, modeling a state that must be correctly handled in concurrent contexts.\n\nTo quantify the difference between the outputs of the two program variants, we compute the Manhattan distance $d$ between the output vectors $\\mathbf{o}_0$ (for guard $G=0$) and $\\mathbf{o}_1$ (for guard $G=1$):\n$$\nd = |r_0 - r_1| + |g_0 - g_1| + |v_0 - v_1| + |c_0 - c_1|\n$$\nA distance $d=0$ indicates that the metamorphic relation holds, suggesting the guarded block is pure with respect to the observable state. A distance $d \\neq 0$ indicates a broken relation, correctly identifying the presence of side effects.\n\nThe implementation strategy is as follows:\n1.  Define data structures to represent the test case parameters (`TestCase`), the initial state (`InitialState`), the program's runtime state (`RuntimeState`, including the `_Atomic` counter), and the final output vector (`OutputVector`).\n2.  Implement an evaluator function, `evaluate`, that simulates the program execution. This function takes a test case and a guard value ($0$ or $1$) as input. It initializes the `RuntimeState`, computes the result $r$, and, if the guard is $1$, calls a helper function `execute_guarded_block` to apply the operations within the guarded block. Finally, it assembles and returns the `OutputVector`.\n3.  The `execute_guarded_block` function implements the logic for each of the $6$ test cases using a `switch` statement. It modifies the `RuntimeState` passed by a pointer. Operations involving the global state $g$, volatile sink $v$, and atomic counter $c$ directly modify the corresponding fields in the `RuntimeState` struct. The atomic operations are correctly implemented using functions from `stdatomic.h` to model the semantics that a compiler must respect.\n4.  The main function defines the test suite as an array of `TestCase` structs. It iterates through this array, calling the `evaluate` function for each test case with guard $G=0$ and $G=1$ to obtain $\\mathbf{o}_0$ and $\\mathbf{o}_1$.\n5.  For each test case, it computes the distance $d$ and stores it.\n6.  Finally, it prints all computed distances in the precise format $[d_1,d_2,d_3,d_4,d_5,d_6]$.\n\nA minor ambiguity in the problem description, \"write $X$ to $Y$ by increment\", is interpreted as `Y += X` for both volatile and global writes, as this interpretation is the only one that yields the provided expected results, ensuring internal consistency.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include stdatomic.h\n\n// Represents the initial non-atomic state for a test case.\ntypedef struct {\n    int g; // Initial global state\n    int v; // Initial volatile sink value\n    int c; // Initial atomic counter value\n} InitialState;\n\n// Encapsulates all parameters for a single test case.\ntypedef struct {\n    int case_id;\n    int a, b;\n    InitialState initial_state;\n} TestCase;\n\n// Represents the program's runtime state, including the atomic counter.\n// Objects of this type are not copyable due to the _Atomic member.\ntypedef struct {\n    int g;\n    int v;\n    _Atomic int c;\n} RuntimeState;\n\n// Represents the final observable output vector [r, g, v, c].\ntypedef struct {\n    int r;\n    int g;\n    int v;\n    int c;\n} OutputVector;\n\n// Simulates the execution of the guarded code block for a given test case.\n// This function modifies the runtime state to reflect side effects.\nvoid execute_guarded_block(int case_id, RuntimeState* state) {\n    int local_x = 0; // A purely local variable, not part of observable state.\n\n    switch (case_id) {\n        case 1: // Pure local changes only\n            local_x += 5;\n            local_x *= 2;\n            // No observable side effects.\n            break;\n        case 2: // Global side effect\n            state-g += 7;\n            break;\n        case 3: // Empty block\n            // No operations, no side effects.\n            break;\n        case 4: // Volatile side effect\n            state-v += 3;\n            break;\n        case 5: // Atomic side effect\n            atomic_fetch_add(state-c, 5);\n            break;\n        case 6: // Mixed pure and side effects\n            local_x += 1;\n            state-g += 4;\n            state-v += 2;\n            atomic_fetch_add(state-c, 1);\n            break;\n    }\n}\n\n// Evaluates the program for a given test case and guard value.\n// Returns the final observable output vector.\nOutputVector evaluate(const TestCase* tc, int guard) {\n    // Initialize the runtime state from the test case's initial parameters.\n    // The .c member is an _Atomic int initialized with an int value.\n    RuntimeState state = {\n        .g = tc-initial_state.g,\n        .v = tc-initial_state.v,\n        .c = tc-initial_state.c\n    };\n\n    // If the guard is active, execute the block which may have side effects.\n    if (guard == 1) {\n        execute_guarded_block(tc-case_id, state);\n    }\n\n    // Assemble the final output vector from the inputs and the final state.\n    OutputVector out = {\n        .r = tc-a * tc-b + tc-b + tc-a,\n        .g = state.g,\n        .v = state.v,\n        .c = atomic_load(state.c) // Safely read the atomic value.\n    };\n\n    return out;\n}\n\nint main(void) {\n    // Define the fixed test suite as specified in the problem.\n    TestCase test_cases[] = {\n        {1, 3, 4, {10, 100, 0}},\n        {2, 2, 5, {0, 0, 0}},\n        {3, 0, 0, {0, 0, 0}},\n        {4, 7, 1, {0, 3, 2}},\n        {5, 4, 2, {1, 0, 5}},\n        {6, 1, 3, {2, 8, 0}}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int distances[num_cases];\n\n    // Process each test case to find the metamorphic distance.\n    for (int i = 0; i  num_cases; ++i) {\n        const TestCase* current_case = test_cases[i];\n\n        // Evaluate the program with the guarded block disabled (guard = 0).\n        OutputVector o0 = evaluate(current_case, 0);\n\n        // Evaluate the program with the guarded block enabled (guard = 1).\n        OutputVector o1 = evaluate(current_case, 1);\n\n        // Calculate the Manhattan distance between the two output vectors.\n        distances[i] = abs(o0.r - o1.r) + abs(o0.g - o1.g) + abs(o0.v - o1.v) + abs(o0.c - o1.c);\n    }\n\n    // Print the results in the exact required format.\n    // The format is a single line with comma-separated values in brackets.\n    // No other text or newlines are printed.\n    printf(\"[%d,%d,%d,%d,%d,%d]\", distances[0], distances[1], distances[2], distances[3], distances[4], distances[5]);\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3643049"}, {"introduction": "Fuzzing isn't just about the source language; it's also about the compiler's internal structures, like the Intermediate Representation (IR). A compiler's IR often has layout-dependent semantics, such as implicit fallthroughs between basic blocks, and a robust compiler should behave identically if these implicit flows are made explicit and the block layout is shuffled [@problem_id:3643018]. This exercise moves the focus to the compiler's backend, teaching you to verify the structural integrity of the IR by confirming that a core program property—the set of reachable blocks—remains invariant.", "problem": "You are to implement a self-contained Intermediate Representation (IR) level fuzzer that operates on a Control Flow Graph (CFG) representation of a function and verifies that reordering independent basic blocks does not change the semantics with respect to reachability from the entry block. Work from first principles of CFG semantics.\n\nUse the following formal base. A Control Flow Graph is a directed graph $G=(V,E)$ where $V$ is the finite set of basic blocks and $E \\subseteq V \\times V$ is the finite set of directed edges representing possible control transfers. The designated entry block is denoted $entry \\in V$ and is fixed. The reachability set $R(entry) \\subseteq V$ is the set of all blocks that are reachable from $entry$ via zero or more edges in $E$. In a linear IR layout, an implicit fallthrough exists when a basic block has zero out-degree and is not the final block in the linear order; formally, if block $b_i$ has out-degree $0$ and $i  |V|-1$, then control implicitly flows to $b_{i+1}$.\n\nYour fuzzer must:\n- Take a CFG with an implicit linear layout $b_0=entry, b_1, \\dots, b_{n-1}$, where $n=|V|$.\n- Compute $R(entry)$ under implicit fallthrough semantics, that is, treat each block $b_i$ with out-degree $0$ and $in-1$ as having an implicit edge to $b_{i+1}$.\n- Rewrite the CFG by inserting explicit fallthrough edges for every applicable block $b_i$ (for $in-1$) that has out-degree $0$, thereby eliminating layout-dependent semantics.\n- Randomly permute the linear order of basic blocks while preserving $b_0=entry$. This permutation must be layout-only; it must not relabel nodes or modify $E$ beyond explicit fallthrough insertion. After this transformation, compute $R(entry)$ again using only explicit edges (i.e., no implicit fallthroughs).\n- Assert equivalence by checking that the pre-transformation and post-transformation reachability sets from $entry$ are identical.\n\nConstruct your program to run a fixed test suite without external input. For reproducibility, use a deterministic pseudo-random shuffle with a fixed seed for the permutation.\n\nTest suite specification. Implement the following four CFGs, each defined by a block count $n$ and directed edge set $E$ over the block indices $\\{0,1,\\dots,n-1\\}$.\n- Test $1$ (general case with implicit fallthrough and explicit branch): $n=4$, $E=\\{(0,1),(2,3)\\}$. Here $b_1$ has an implicit fallthrough to $b_2$ in the original layout.\n- Test $2$ (boundary: single block): $n=1$, $E=\\emptyset$.\n- Test $3$ (unreachable blocks present): $n=5$, $E=\\{(0,1),(1,3),(3,3)\\}$. Blocks $2$ and $4$ are unreachable from $entry$ under both implicit and explicit semantics.\n- Test $4$ (loop structure): $n=4$, $E=\\{(0,1),(1,2),(2,1)\\}$.\n\nRequired output. For each test case $i \\in \\{1,2,3,4\\}$, produce an integer result $r_i$ where $r_i=1$ if the pre- and post-transformation reachability sets $R(entry)$ are equal, and $r_i=0$ otherwise. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, that is, the string representing the list $[r_1,r_2,r_3,r_4]$. No other output is permitted.", "solution": "The problem requires the implementation of a verification routine, framed as a fuzzer, to confirm a fundamental principle of compiler correctness: that making implicit control flow explicit preserves program semantics with respect to basic block reachability. The fuzzer must operate on a Control Flow Graph (CFG) and validate this principle across a suite of test cases.\n\nFirst, we formalize the components of the problem. A CFG is a directed graph $G=(V, E)$, where $V$ is a set of basic blocks, indexed from $0$ to $n-1$ where $n=|V|$, and $E$ is a set of directed edges representing explicit jumps or branches. The block $b_0$ is the designated, fixed entry block, denoted $entry$. The program semantics under consideration is the reachability set $R(entry)$, which contains all blocks reachable from $entry$.\n\nThe problem introduces layout-dependent semantics through the rule of **implicit fallthrough**. A linear arrangement of blocks in memory, $b_0, b_1, \\dots, b_{n-1}$, implies that if a block $b_i$ has an out-degree of $0$ (i.e., it does not end in an explicit branch) and it is not the last block in the sequence ($i  n-1$), control flow implicitly transfers to the next block in the sequence, $b_{i+1}$.\n\nThe process involves two main stages of analysis for each test case.\n\n**1. Pre-Transformation Analysis: Semantics with Implicit Fallthrough**\n\nIn this stage, we determine the reachability set based on the initial layout-dependent semantics.\nLet the initial CFG be $G_{orig}=(V, E_{explicit})$ with the linear layout $L_{orig}=(b_0, b_1, \\dots, b_{n-1})$.\nWe first identify all implicit edges. For each block $b_i$ where $0 \\le i  n-1$, we calculate its out-degree based solely on the explicit edge set $E_{explicit}$. If the out-degree of $b_i$ is $0$, we introduce an implicit edge $(b_i, b_{i+1})$. Let the set of these newly identified edges be $E_{implicit}$.\nAn \"effective\" CFG, $G_{effective}=(V, E_{explicit} \\cup E_{implicit})$, is constructed. The pre-transformation reachability set, $R_{pre}(entry)$, is then computed on this graph. This set represents the complete control flow behavior of the program in its original, layout-dependent form.\n\nTo compute the reachability set, a graph traversal algorithm such as a Depth-First Search (DFS) or Breadth-First Search (BFS) is employed. Starting from the entry block $b_0$, the algorithm explores all reachable blocks by following the edges in $G_{effective}$. The set of all visited blocks constitutes $R_{pre}(entry)$.\n\n**2. Post-Transformation Analysis: Semantics with Explicit Fallthrough**\n\nThe core of the transformation is to make the CFG's semantics layout-independent. This is achieved by converting all implicit fallthrough edges into explicit edges. The rewritten CFG, $G_{rewritten}=(V, E_{rewritten})$, has an edge set $E_{rewritten} = E_{explicit} \\cup E_{implicit}$. By definition, this graph is identical to $G_{effective}$.\n\nThe problem states that after this rewriting, the block layout is randomly permuted (while keeping $b_0$ as the entry) and reachability is re-computed. This permutation is the \"fuzzing\" aspect, designed to test if the program semantics have become truly layout-independent. The key instruction is that this new reachability calculation must use \"only explicit edges (i.e., no implicit fallthroughs)\". Since all control flow in $G_{rewritten}$ is explicit, its reachability is inherently independent of any linear block layout. Therefore, permuting the blocks has no effect on the reachability calculation for $G_{rewritten}$.\n\nThe post-transformation reachability set, $R_{post}(entry)$, is computed by performing the same traversal algorithm (DFS or BFS) on $G_{rewritten}$, starting from $entry=b_0$.\n\n**3. Verification**\n\nThe final step is to assert the equivalence of the semantics before and after the transformation. This is done by comparing the two reachability sets: $R_{pre}(entry)$ and $R_{post}(entry)$. The assertion holds if and only if $R_{pre}(entry) = R_{post}(entry)$.\n\nSince $G_{effective}$ and $G_{rewritten}$ are constructed to be the same graph, their reachability sets from the same entry point must be identical. Thus, for any valid CFG, the check $R_{pre}(entry) = R_{post}(entry)$ must always pass. The program's output, a list of $1$s, serves as a computational proof of this principle for the given test cases.\n\nThe implementation will therefore proceed as follows for each test case:\n- Represent the CFG using an adjacency matrix.\n- Construct the initial graph $G_{orig}$ with only explicit edges from the test case specification.\n- Construct the effective graph $G_{effective}$ by adding edges corresponding to implicit fallthroughs in the original layout.\n- Compute the reachability set $R_{pre}$ on $G_{effective}$ using DFS from block $0$.\n- The post-transformation graph $G_{rewritten}$ is identical to $G_{effective}$.\n- The conceptual permutation of blocks is implemented but is irrelevant to the subsequent calculation, as per the problem's explicit instruction to use only explicit edges.\n- Compute the reachability set $R_{post}$ on $G_{rewritten}$ (which is the same as $G_{effective}$) using DFS from block $0$.\n- Compare $R_{pre}$ and $R_{post}$. If they are identical, the result for the test case is $1$; otherwise, it is $0$.\n\nThe final output for all test cases will be $[1,1,1,1]$, verifying the correctness of the layout-independent transformation.", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n#include string.h\n// #include math.h\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n// A struct to represent a directed edge in the CFG.\ntypedef struct {\n    int from;\n    int to;\n} Edge;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int n;           // Number of basic blocks\n    Edge* edges;     // Array of explicit edges\n    int num_edges;   // Number of explicit edges\n} TestCase;\n\n/**\n * @brief Computes the set of reachable blocks from a starting block using DFS.\n *\n * @param u The current block being visited.\n * @param n The total number of blocks in the CFG.\n * @param adj The n x n adjacency matrix of the CFG.\n * @param visited An array of size n to mark visited blocks.\n */\nvoid compute_reachability_dfs(int u, int n, int adj[][n], int visited[]) {\n    visited[u] = 1;\n    for (int v = 0; v  n; ++v) {\n        if (adj[u][v]  !visited[v]) {\n            compute_reachability_dfs(v, n, adj, visited);\n        }\n    }\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    Edge edges1[] = {{0, 1}, {2, 3}};\n    Edge edges2[] = {};\n    Edge edges3[] = {{0, 1}, {1, 3}, {3, 3}};\n    Edge edges4[] = {{0, 1}, {1, 2}, {2, 1}};\n\n    TestCase test_cases[] = {\n        {4, edges1, sizeof(edges1) / sizeof(edges1[0])},\n        {1, edges2, sizeof(edges2) / sizeof(edges2[0])},\n        {5, edges3, sizeof(edges3) / sizeof(edges3[0])},\n        {4, edges4, sizeof(edges4) / sizeof(edges4[0])}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        int n = test_cases[i].n;\n        Edge* edges = test_cases[i].edges;\n        int num_edges = test_cases[i].num_edges;\n\n        // VLA for adjacency matrix. C23 standard supports this.\n        int adj_explicit[n][n];\n        memset(adj_explicit, 0, sizeof(adj_explicit));\n        for (int j = 0; j  num_edges; ++j) {\n            adj_explicit[edges[j].from][edges[j].to] = 1;\n        }\n\n        // --- Pre-Transformation Analysis ---\n        // Build the effective CFG including implicit fallthroughs.\n        int adj_effective[n][n];\n        memcpy(adj_effective, adj_explicit, sizeof(adj_effective));\n\n        for (int j = 0; j  n - 1; ++j) {\n            int out_degree = 0;\n            for (int k = 0; k  n; ++k) {\n                out_degree += adj_explicit[j][k];\n            }\n            if (out_degree == 0) {\n                adj_effective[j][j + 1] = 1; // Add implicit fallthrough edge.\n            }\n        }\n\n        // Compute reachability on the layout-dependent (effective) CFG.\n        int reachable_pre[n];\n        memset(reachable_pre, 0, sizeof(reachable_pre));\n        if (n  0) {\n            compute_reachability_dfs(0, n, adj_effective, reachable_pre);\n        }\n\n        // --- Post-Transformation Analysis ---\n        // The transformation creates a new CFG with explicit fallthroughs. This\n        // is identical to our `adj_effective` graph.\n        \n        // The problem mentions permuting the layout to fuzz test. We implement\n        // this step, but as per the rules, the subsequent reachability check\n        // uses only explicit edges, making the layout irrelevant.\n        int layout[n  0 ? n : 1];\n        for(int j=0; jn; ++j) layout[j] = j;\n\n        if (n  1) { // Shuffle only if there's more than one block\n            srand(42); // Fixed seed for reproducibility\n            // Fisher-Yates shuffle on blocks {1, ..., n-1}\n            for (int j = n - 1; j  1; --j) {\n                int k = 1 + rand() % j; // k is in [1, j]\n                int temp = layout[j];\n                layout[j] = layout[k];\n                layout[k] = temp;\n            }\n        }\n        \n        // Compute reachability on the rewritten, layout-independent CFG.\n        int reachable_post[n];\n        memset(reachable_post, 0, sizeof(reachable_post));\n        if (n  0) {\n            // The graph is `adj_effective`, which now contains all edges explicitly.\n            compute_reachability_dfs(0, n, adj_effective, reachable_post);\n        }\n\n        // --- Verification ---\n        // Assert that the reachability sets are identical.\n        int are_equal = 1;\n        for (int j = 0; j  n; ++j) {\n            if (reachable_pre[j] != reachable_post[j]) {\n                are_equal = 0;\n                break;\n            }\n        }\n        results[i] = are_equal;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3643018"}]}