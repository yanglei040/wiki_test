{"hands_on_practices": [{"introduction": "Differential testing often begins by scrutinizing the most fundamental aspects of a language. This first practice dives into C's integer promotion rules, a subtle but critical feature where small integer types like `char` are promoted to `int` before arithmetic operations. By building an oracle based on the mathematical definition of signed and unsigned numbers, you will verify that a compiler correctly implements these standard-mandated promotions and also reveal implementation-defined behaviors, such as the default signedness of `char` [@problem_id:3637901].", "problem": "You are to design and implement a self-contained program to differentially test the integer promotion rules for character arithmetic in the C Programming Language (C), focusing on whether the runtime results of addition of character operands match the mathematical addition in the set of integers $\\mathbb{Z}$ when the operands are promoted to type $int$ before evaluation. The fundamental base for this task is the definition of integer promotions and the usual arithmetic conversions in C, and the well-tested mathematical properties of addition in $\\mathbb{Z}$. Integer promotions state that for the additive operator $+$, both operands undergo promotion to $int$ (or $unsigned\\ int$) when their original type is one of the smaller integer types (for example, $char$, $signed\\ char$, $unsigned\\ char$), provided that all values of the original type can be represented in $int$. In mainstream systems, all values of $char$ are representable in $int$, so $char$, $signed\\ char$, and $unsigned\\ char$ are promoted to $int$ prior to addition. Your program must verify that this promotion yields results equal to mathematical addition in $\\mathbb{Z}$ under clearly defined interpretations of the original $8$-bit values.\n\nDefine two interpretation functions for an $8$-bit quantity $x \\in \\{0,1,\\dots,255\\}$:\n- The signed interpretation $f_s(x)$, which maps to $\\mathbb{Z}$ as two's-complement style signed $8$-bit values:\n$$\nf_s(x) = \\begin{cases}\nx,  \\text{if } 0 \\le x \\le 127, \\\\\nx - 256,  \\text{if } 128 \\le x \\le 255,\n\\end{cases}\n$$\n- The unsigned interpretation $f_u(x)$, which maps directly to $\\mathbb{Z}$:\n$$\nf_u(x) = x.\n$$\n\nFor each test case pair $(a,b)$ with $a,b \\in \\{0,1,\\dots,255\\}$, you must compute four booleans (encoded as integers $0$ or $1$) that check whether C’s integer-promotion-based addition agrees with the corresponding mathematical addition in $\\mathbb{Z}$:\n- $b_s$: equals $1$ if `((signed char)a) + ((signed char)b)`, evaluated in C with integer promotions, equals $f_s(a) + f_s(b)$ in $\\mathbb{Z}$; otherwise $0$.\n- $b_u$: equals $1$ if `((unsigned char)a) + ((unsigned char)b)`, evaluated in C with integer promotions, equals $f_u(a) + f_u(b)$ in $\\mathbb{Z}$; otherwise $0$.\n- $b_{p=s}$: equals $1$ if `((char)a) + ((char)b)`, evaluated in C with integer promotions, equals $f_s(a) + f_s(b)$ in $\\mathbb{Z}$; otherwise $0$.\n- $b_{p=u}$: equals $1$ if `((char)a) + ((char)b)`, evaluated in C with integer promotions, equals $f_u(a) + f_u(b)$ in $\\mathbb{Z}$; otherwise $0$.\n\nThis design enables Differential Testing (DT) across compilers: the first two booleans $b_s$ and $b_u$ must be $1$ for conforming compilers, while $b_{p=s}$ versus $b_{p=u}$ may uncover differences due to implementation-defined default signedness of $char$.\n\nUse the following test suite of pairs $(a,b)$, which is chosen to cover a general case, boundaries, and edge conditions:\n- Test $1$: $(a,b) = (100,27)$, both within $[0,127]$.\n- Test $2$: $(a,b) = (200,60)$, one above $127$ and one within $[0,127]$.\n- Test $3$: $(a,b) = (255,1)$, an upper boundary and a small positive.\n- Test $4$: $(a,b) = (128,128)$, both exactly at the signed negative boundary.\n- Test $5$: $(a,b) = (0,0)$, the minimum boundary values.\n- Test $6$: $(a,b) = (127,1)$, straddling the signed boundary.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the four booleans per test case listed in order $(b_s,b_u,b_{p=s},b_{p=u})$ for each test and flattened across all six tests. The final output format is:\n[$b_s^{(1)}$,$b_u^{(1)}$,$b_{p=s}^{(1)}$,$b_{p=u}^{(1)}$,$b_s^{(2)}$,$b_u^{(2)}$,$b_{p=s}^{(2)}$,$b_{p=u}^{(2)}$,$b_s^{(3)}$,$b_u^{(3)}$,$b_{p=s}^{(3)}$,$b_{p=u}^{(3)}$,$b_s^{(4)}$,$b_u^{(4)}$,$b_{p=s}^{(4)}$,$b_{p=u}^{(4)}$,$b_s^{(5)}$,$b_u^{(5)}$,$b_{p=s}^{(5)}$,$b_{p=u}^{(5)}$,$b_s^{(6)}$,$b_u^{(6)}$,$b_{p=s}^{(6)}$,$b_{p=u}^{(6)}$].\n\nNo external input is required. No physical units, angle units, or percentage formats are involved; all outputs are integers. The program must be self-contained and runnable as is. The verification must avoid Undefined Behavior (UB) by ensuring that all actual additions occur in $int$ after promotion, and by not narrowing the results back to narrower integer types. This differential test highlights implementation-defined behavior of plain $char$ signedness, while confirming portable promotion semantics for $signed\\ char$ and $unsigned\\ char$.", "solution": "The problem is valid. It is scientifically grounded in the formal specifications of the C programming language and fundamental integer arithmetic, well-posed with a clear objective and methodology, and free of ambiguity or contradiction.\n\nThe task is to design a program to empirically verify the C language's integer promotion rules for character arithmetic. The core principle being tested is defined in the C standard (ISO/IEC 9899, section 6.3.1.1 on \"Integer promotions\"): if an `int` can represent all values of an integer type, the value is converted to `int`. For small integer types such as `char`, `signed char`, and `unsigned char` on typical modern architectures where `sizeof(int) > sizeof(char)`, this promotion to `int` occurs for operands of binary arithmetic operators like `+`. Our program will test whether the result of this promotion and subsequent addition in C aligns with the mathematically expected result in the set of integers, $\\mathbb{Z}$.\n\nThe verification is based on two distinct interpretations of an 8-bit value $x \\in \\{0, 1, \\dots, 255\\}$.\n1.  The signed interpretation, $f_s(x)$, which corresponds to the two's complement representation:\n    $f_s(x) = x$ for $0 \\le x \\le 127$ and $f_s(x) = x - 256$ for $128 \\le x \\le 255$.\n2.  The unsigned interpretation, $f_u(x)$, which is a direct mapping:\n    $f_u(x) = x$.\n\nThese functions serve as our mathematical ground truth. For a given pair of 8-bit values $(a, b)$, the program will compute four boolean values, represented as integers $1$ (true) or $0$ (false), based on four distinct comparisons.\n\n**1. Verification of `signed char` Arithmetic ($b_s$)**\nThe first test verifies the behavior of explicitly `signed char` operands. In C, the expression `((signed char)a) + ((signed char)b)` is evaluated. The bit patterns of $a$ and $b$ are first interpreted as `signed char`. According to the C standard, both operands are then promoted to type `int`. The addition is performed on these `int` values. We will compare this computed result with the mathematical sum $f_s(a) + f_s(b)$.\n$$b_s = \\begin{cases} 1  \\text{if } (\\mathtt{(int)((signed\\ char)}a\\mathtt{) + (int)((signed\\ char)}b\\mathtt{)}) = (f_s(a) + f_s(b)) \\\\ 0  \\text{otherwise} \\end{cases}$$\nFor any conforming compiler, this test is expected to pass, yielding $b_s=1$.\n\n**2. Verification of `unsigned char` Arithmetic ($b_u$)**\nThe second test verifies the behavior of `unsigned char` operands. In C, the expression `((unsigned char)a) + ((unsigned char)b)` is evaluated. Both operands, being of type `unsigned char`, are promoted to `int` (as `int` can represent the full range of `unsigned char`, which is typically $[0, 255]$). The addition is performed on the resulting `int` values. This result is compared against the mathematical sum $f_u(a) + f_u(b)$, which is simply $a+b$.\n$$b_u = \\begin{cases} 1  \\text{if } (\\mathtt{(int)}a + \\mathtt{(int)}b) = (f_u(a) + f_u(b)) \\\\ 0  \\text{otherwise} \\end{cases}$$\nThis test is also expected to pass on any conforming compiler, yielding $b_u=1$.\n\n**3. Verification of `char` Arithmetic (Implementation-Defined Behavior)**\nThe third and fourth tests probe the implementation-defined signedness of the plain `char` type. The C standard allows `char` to behave either as `signed char` or `unsigned char`. We evaluate the C expression `((char)a) + ((char)b)`, where again the operands are promoted to `int` before addition. The result is then compared against both the signed and unsigned mathematical models.\n-   $b_{p=s}$ tests if `char` behaves like `signed char`:\n    $$b_{p=s} = \\begin{cases} 1  \\text{if } (\\mathtt{(int)((char)}a\\mathtt{) + (int)((char)}b\\mathtt{)}) = (f_s(a) + f_s(b)) \\\\ 0  \\text{otherwise} \\end{cases}$$\n-   $b_{p=u}$ tests if `char` behaves like `unsigned char`:\n    $$b_{p=u} = \\begin{cases} 1  \\text{if } (\\mathtt{(int)((char)}a\\mathtt{) + (int)((char)}b\\mathtt{)}) = (f_u(a) + f_u(b)) \\\\ 0  \\text{otherwise} \\end{cases}$$\nFor any given compiler, exactly one of $b_{p=s}$ or $b_{p=u}$ will be $1$ for test cases where $f_s$ and $f_u$ differ. This pair of booleans reveals the implementation's choice for the signedness of `char`. This is the differential aspect of the test, as different compilers may yield different results for this pair.\n\nThe program is structured to iterate through a suite of test cases $(a,b)$ carefully selected to probe boundary conditions and general behavior. For each pair, it computes the four C results and the two mathematical results, performs the four comparisons, and stores the resulting integer booleans. Finally, it prints all $6 \\times 4 = 24$ results in a flattened, comma-separated list enclosed in square brackets as specified. The implementation uses a `struct` to represent test cases for code clarity and stores the final boolean values in an integer array before printing. The mathematical interpretation functions $f_s(x)$ and $f_u(x)$ are implemented as helper functions in C. All arithmetic in C is performed using the `int` type after promotion to ensure results are not subject to 8-bit overflow, thus correctly modeling the mathematical domain $\\mathbb{Z}$ for the purposes of this test.", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n// #include string.h\n// #include math.h\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    unsigned char a;\n    unsigned char b;\n} TestCase;\n\n// Mathematical signed interpretation function f_s(x) for an 8-bit value.\n// Maps an 8-bit unsigned value x to its two's-complement signed integer value.\nstatic int f_s(unsigned char x) {\n    if (x = 127) {\n        return (int)x;\n    } else {\n        return (int)x - 256;\n    }\n}\n\n// Mathematical unsigned interpretation function f_u(x) for an 8-bit value.\n// Maps an 8-bit unsigned value x to its direct integer value.\nstatic int f_u(unsigned char x) {\n    return (int)x;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    // The values are specified as integers in {0, ..., 255}, which\n    // are stored as unsigned char to preserve their bit patterns.\n    const TestCase test_cases[] = {\n        {100, 27},  // Test 1: Both positive in signed interpretation\n        {200, 60},  // Test 2: One negative, one positive\n        {255, 1},   // Test 3: Boundary case (-1 + 1)\n        {128, 128}, // Test 4: Boundary case (-128 + -128)\n        {0, 0},     // Test 5: Zero identity\n        {127, 1}    // Test 6: Straddling the signed boundary\n    };\n\n    // Calculate the number of test cases and total results.\n    const int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    const int num_results = num_cases * 4;\n    int results[num_results];\n    int result_idx = 0;\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        unsigned char a = test_cases[i].a;\n        unsigned char b = test_cases[i].b;\n\n        // Perform additions in C. According to integer promotion rules,\n        // operands of types char, signed char, and unsigned char are promoted\n        // to 'int' before the addition. The result is of type 'int'.\n        // This avoids overflow that would occur in 8-bit arithmetic.\n        int c_res_s = (signed char)a + (signed char)b;\n        int c_res_u = a + b; // a and b are unsigned char and get promoted.\n        int c_res_p = (char)a + (char)b;\n\n        // Calculate the expected mathematical results in the domain of integers Z.\n        int math_res_s = f_s(a) + f_s(b);\n        int math_res_u = f_u(a) + f_u(b);\n\n        // Compare C results with mathematical results and store the booleans (1 or 0).\n        // b_s: Check signed char arithmetic\n        results[result_idx++] = (c_res_s == math_res_s);\n        // b_u: Check unsigned char arithmetic\n        results[result_idx++] = (c_res_u == math_res_u);\n        // b_{p=s}: Check if plain char behaves as signed\n        results[result_idx++] = (c_res_p == math_res_s);\n        // b_{p=u}: Check if plain char behaves as unsigned\n        results[result_idx++] = (c_res_p == math_res_u);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    // The format is a single line: [b1,b2,b3,...,bN].\n    printf(\"[\");\n    for (int i = 0; i  num_results; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_results - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3637901"}, {"introduction": "Beyond arithmetic, a compiler's correctness hinges on its handling of core structural rules like lexical scoping. This exercise shifts our focus to name resolution, exploring how compilers manage variable shadowing—where a variable in an inner scope hides one in an outer scope. You will construct a series of tests to confirm that variable references are correctly resolved and that scope boundaries are properly enforced, ensuring that a compiler's symbol table management adheres to the language standard [@problem_id:3637957].", "problem": "You are asked to design and implement a self-contained differential test in the context of compiler principles, focusing on the semantic correctness of name resolution under lexical (static) scoping and variable shadowing. The goal is to produce a program whose observable behavior (a fixed list of boolean outputs encoded as integers) can be compared across different compilers to detect inconsistent handling of shadowing. Use a programming language with block-structured scope and well-defined lexical scoping rules.\n\nFundamental base: In block-structured, lexically scoped languages, the binding of an identifier $x$ is determined by the nearest enclosing declaration at compile time. More formally, if an identifier $x$ is referenced in a context, the compiler resolves $x$ to the declaration with the smallest scope that contains the reference, according to a well-defined scoping hierarchy. Variable shadowing occurs when a declaration of $x$ in an inner scope hides the declaration of $x$ in an outer scope. The program’s behavior should be derived from these rules without relying on undefined or implementation-specific behavior.\n\nYour task is to implement a deterministic test program that exercises shadowing in four controlled scenarios and validates observable properties consistent with lexical scoping:\n\n1. Inner block shadowing: An inner block declares a new $x$ that hides an outer $x$. The inner $x$ stores a computed value based on the test parameter; its address must differ from the address of the outer $x$, and reading $x$ inside the inner block must yield the inner value.\n2. Post-block restoration: After leaving the inner block, the outer $x$ should retain its original value (the inner modification must not affect the outer variable).\n3. Loop-initializer shadowing: A for-loop initializes its own $x$ and uses it within the loop; the loop accumulates a sum based solely on the loop’s $x$ and must leave the outer $x$ unchanged afterward.\n4. Parameter shadowing of a global: A function with parameter $x$ must use the parameter rather than any global $x$, returning the parameter value. Additionally, an inner block inside the function should be able to declare a new $x$ that hides the parameter $x$, and operations inside that inner block should refer to the inner $x$ exclusively.\n5. Type-changing shadowing: Inside an inner block, declare $x$ with a different type than the outer $x$ and check that operations and type-based properties (such as size) match the inner declaration and do not depend on the outer type.\n\nDerive the expected boolean outcomes from the lexical scoping rules and encode them as integers ($1$ for true, $0$ for false). Avoid any undefined behavior (e.g., referencing an uninitialized variable or relying on unspecified evaluation order). Use only constructs with well-defined semantics. Do not rely on architecture-dependent quantities except for comparisons that are defined by the language standard (e.g., comparing $\\mathrm{sizeof}$ of identically typed objects).\n\nTest Suite:\nProvide a small, explicit test suite with three parameter values for the outer variable $x$ to validate behavior across compilers. Use the following $x$ values:\n- $x=1$ (happy path),\n- $x=2$ (second nominal value),\n- $x=0$ (boundary case for zero).\n\nFor each test case with parameter $x_{\\text{outer}}$, compute the following eight boolean checks, encoded as integers, in the exact order below:\n- $r_{1a}$: Inside an inner block that declares $x$ as $x_{\\text{inner}} = 10 \\cdot x_{\\text{outer}}$, reading $x$ yields $10 \\cdot x_{\\text{outer}}$.\n- $r_{1b}$: The address of the inner $x$ differs from the address of the outer $x$ inside the inner block, i.e., $\\x_{\\text{inner}} \\ne \\x_{\\text{outer}}$.\n- $r_{2}$: After leaving the inner block, the outer $x$ equals $x_{\\text{outer}}$.\n- $r_{3a}$: A for-loop with its own initializer variable $x$ computing $\\sum_{x=0}^{2} x$ yields $3$.\n- $r_{3b}$: After the for-loop ends, the outer $x$ equals $x_{\\text{outer}}$.\n- $r_{4}$: A function with parameter $x$ returns the parameter value when called with $x_{\\text{outer}}$, regardless of any global $x$.\n- $r_{5a}$: Inside an inner block where $x$ is declared with type double, `sizeof(x)` equals `sizeof(double)`.\n- $r_{5b}$: Inside that inner block, reading $x$ yields the exact double literal $3.25$ up to a tolerance, i.e., $|x - 3.25|  10^{-12}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\"). The list must be flattened across test cases in the order of the test suite values $[1,2,0]$, with each test case contributing its eight results in the fixed order $[r_{1a},r_{1b},r_{2},r_{3a},r_{3b},r_{4},r_{5a},r_{5b}]\". Therefore, the output will contain exactly $24$ integers in total.\n\nThe program must be completely deterministic and free of undefined behavior, and it must implement only the described checks. This differential test is designed such that compilers with correct lexical scoping and shadowing semantics will all produce the same output, enabling differential testing by comparing outputs across compilers.", "solution": "The problem statement has been critically validated and is deemed **valid**. It is scientifically grounded in the principles of compiler design, specifically lexical (static) scoping, and presents a well-posed, objective task. All necessary data and constraints for constructing a deterministic differential test program are provided, and there are no internal contradictions, ambiguities, or reliance on undefined behavior. The task is to create a C program that tests a compiler's handling of variable shadowing in several controlled scenarios, producing a deterministic integer sequence as output.\n\nThe solution is a C program designed to execute a series of checks derived directly from the formal rules of lexical scoping in block-structured languages. The program is structured to test these rules under five specific scenarios for three different initial values of an outer variable, $x_{\\text{outer}} \\in \\{1, 2, 0\\}$. The expected outcome for each of the $8$ boolean checks per test case is $1$ (true), as they are designed to confirm behavior mandated by the C standard. Any deviation, resulting in a $0$, would indicate a potential compiler bug. The final output is a flattened list of $3 \\times 8 = 24$ integers.\n\nThe program's design is based on the following principles and their implementation:\n\n1.  **Inner Block Shadowing ($r_{1a}, r_{1b}$)**: Lexical scoping dictates that a variable declaration within an inner block hides (shadows) any variable with the same name in an enclosing scope.\n    - **Principle**: When a reference to an identifier $x$ occurs, the compiler binds it to the declaration of $x$ in the nearest enclosing scope.\n    - **Implementation**: An outer integer variable $x$ is initialized to $x_{\\text{outer}}$. A new block `{...}` is introduced, containing a new declaration `int x = 10 * x_outer;`.\n    - **Check $r_{1a}$**: Inside this block, any reference to $x$ must resolve to the inner variable. We verify that reading $x$ yields the value $10 \\cdot x_{\\text{outer}}$.\n    - **Check $r_{1b}$**: The inner and outer variables $x$ are distinct objects. Because the outer $x$ is used after the inner block concludes (it is *live*), a compliant compiler must allocate separate storage for each. We verify this by ensuring their memory addresses are not equal: ` != `.\n\n2.  **Post-Block Restoration ($r_{2}$)**: The scope of a variable is limited to the block in which it is declared. Once execution leaves the block, the variable is destroyed, and any shadowed variables from outer scopes become visible again.\n    - **Principle**: An identifier's binding is statically determined by its position in the source code; the scope of an inner variable does not persist beyond its syntactic block.\n    - **Implementation**: Following the inner block from the previous test, we access $x$ again.\n    - **Check $r_{2}$**: This reference must now resolve to the outer variable $x$. We verify that its value is still the original $x_{\\text{outer}}$, confirming that the inner block's operations did not affect the outer variable.\n\n3.  **Loop-Initializer Shadowing ($r_{3a}, r_{3b}$)**: In modern C (C99 and later), a variable declared in the initialization part of a `for` loop is scoped exclusively to that loop.\n    - **Principle**: The scope of `for (declaration; ...)` is the loop's header and body. This declaration shadows any same-named variables in the enclosing scope.\n    - **Implementation**: A `for` loop is defined as `for (int x = 0; x = 2; ++x)`. This loop exists within the scope where the outer variable $x$ is defined.\n    - **Check $r_{3a}$**: The loop computes a sum using its local variable $x$. We verify that the sum is correct: $\\sum_{x=0}^{2} x = 3$.\n    - **Check $r_{3b}$**: After the loop terminates, its local $x$ is no longer in scope. We verify that a subsequent access to $x$ correctly resolves to the outer variable, whose value must remain $x_{\\text{outer}}$.\n\n4.  **Parameter Shadowing of a Global ($r_{4}$)**: Function parameters behave as local variables within the function's scope, shadowing any global variables with the same name.\n    - **Principle**: A function's formal parameters are bound within the scope of the function body, taking precedence over global bindings.\n    - **Implementation**: A global variable `global_x` is declared. A function, `test_param_shadowing(int x)`, is defined. This function is called with $x_{\\text{outer}}$ as its argument.\n    - **Check $r_{4}$**: Inside the function, the identifier $x$ must refer to the parameter, not the global variable. The function is designed to return the value of its parameter $x$. We verify that the function call `test_param_shadowing(x_outer)` returns $x_{\\text{outer}}$.\n\n5.  **Type-Changing Shadowing ($r_{5a}, r_{5b}$)**: Shadowing is not limited to variables of the same type. An inner declaration can introduce a variable with a completely different type, and all operations within that scope must respect the new type.\n    - **Principle**: The static type of an identifier is determined by its specific declaration. Static operators like `sizeof` operate on this compile-time type information.\n    - **Implementation**: Within an inner block, a new variable $x$ is declared with type `double` and initialized to a literal value: `double x = 3.25;`.\n    - **Check $r_{5a}$**: The `sizeof` operator should report the size of the inner variable's type. We verify that `sizeof(x)` equals `sizeof(double)`.\n    - **Check $r_{5b}$**: Operations on the inner $x$ must be consistent with its `double` type. We verify that its value is approximately $3.25$ by checking if $|x - 3.25|  10^{-12}$.\n\nThe C code systematically performs these checks for each value in the test suite and aggregates the $24$ resulting boolean integers ($1$ or $0$) into a single, flat array before printing them in the specified format.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include math.h\n\n// Permitted but not used headers:\n// #include string.h\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n// A global variable to test parameter shadowing (for check r4).\n// Its value should be shadowed by the function parameter.\nint global_x = -1;\n\n// A function to test parameter shadowing of a global variable.\n// The parameter 'x' should shadow 'global_x'.\n// The function also includes an inner block that shadows the parameter 'x',\n// as suggested by the problem description for a more complete test scenario.\nint test_param_shadowing(int x) {\n    // This inner block demonstrates further shadowing but does not affect the outcome\n    // of the check, which is solely based on the return value.\n    {\n        // This 'x' is local to this block and shadows the parameter 'x'.\n        int x = 999;\n        // Suppress unused variable warning. The existence of this scope is part of the test.\n        (void)x;\n    }\n    // This return statement must refer to the parameter 'x', not 'global_x'\n    // or the 'x' from the inner scope.\n    return x;\n}\n\n// A struct to hold the parameters for a single test case, as per the problem description's template.\ntypedef struct {\n    int x_outer_val;\n} TestCase;\n\nint main(void) {\n    // Define the test cases with parameter values for the outer variable 'x'.\n    TestCase test_cases[] = {\n        {1}, // Happy path\n        {2}, // Second nominal value\n        {0}  // Boundary case\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int num_checks_per_case = 8;\n    int total_results = num_cases * num_checks_per_case;\n    int all_results[total_results];\n\n    int result_idx = 0;\n\n    // Iterate through each test case defined in the test suite.\n    for (int i = 0; i  num_cases; ++i) {\n        int x_outer = test_cases[i].x_outer_val;\n\n        // The outer 'x' for this test run. Its scope is the loop iteration.\n        int x = x_outer;\n        // The address of the outer 'x' must be captured before any inner blocks.\n        const int* addr_outer_x = x;\n\n        // Check r1a  r1b: Inner block shadowing.\n        {\n            // This 'x' is a new variable, local to this block, shadowing the outer 'x'.\n            int x = 10 * x_outer;\n            const int* addr_inner_x = x;\n\n            // r1a: The value of 'x' inside this block must be the inner value.\n            all_results[result_idx++] = (x == (10 * x_outer));\n\n            // r1b: The inner 'x' must have a different address from the outer 'x',\n            // because the outer 'x' is still live (used in subsequent checks).\n            all_results[result_idx++] = (addr_inner_x != addr_outer_x);\n        }\n\n        // Check r2: Post-block restoration.\n        // After the inner block, 'x' must refer to the outer variable, which should be unaffected.\n        all_results[result_idx++] = (x == x_outer);\n\n        // Check r3a  r3b: Loop-initializer shadowing (requires C99 or later).\n        // The problem specification of C23 ensures this syntax is valid.\n        int sum = 0;\n        for (int x = 0; x = 2; ++x) { // This 'x' is scoped only to the for-loop.\n            sum += x;\n        }\n\n        // r3a: The sum must be 0 + 1 + 2 = 3.\n        all_results[result_idx++] = (sum == 3);\n\n        // r3b: After the loop, 'x' refers to the outer variable, which should be unchanged.\n        all_results[result_idx++] = (x == x_outer);\n\n        // Check r4: Parameter shadowing of a global.\n        // The function call should use the parameter 'x_outer', not 'global_x'.\n        all_results[result_idx++] = (test_param_shadowing(x_outer) == x_outer);\n\n        // Check r5a  r5b: Type-changing shadowing.\n        {\n            // This 'x' is a new variable of type double, shadowing the outer int 'x'.\n            double x = 3.25;\n\n            // r5a: The size of this 'x' must be the size of a double.\n            all_results[result_idx++] = (sizeof(x) == sizeof(double));\n\n            // r5b: The value must be the assigned double literal, checked with a tolerance.\n            double tolerance = 1e-12;\n            all_results[result_idx++] = (fabs(x - 3.25)  tolerance);\n        }\n    }\n\n    // Print the results in the EXACT required single-line format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i  total_results; ++i) {\n        printf(\"%d\", all_results[i]);\n        if (i  total_results - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3637957"}, {"introduction": "This final practice introduces a powerful, scalable technique known as metamorphic testing, where we test a compiler by checking its behavior against known properties or relations. Instead of comparing just two implementations, we will generate multiple, syntactically diverse but semantically equivalent programs and verify that they all produce the same output. You will leverage the mathematical identity for an arithmetic sum, $\\sum_{i=0}^{n-1} i = \\frac{n(n-1)}{2}$, as a metamorphic relation to create an oracle that can test a compiler's optimization of various loop structures [@problem_id:3637908].", "problem": "Design and implement a complete, runnable program that instantiates a practical harness for differential testing of compilers using metamorphic properties of loop-based programs. The fundamental base consists of: (i) the semantics of deterministic program execution for well-defined code; (ii) standard integer arithmetic laws under the absence of overflow; and (iii) the identity for an arithmetic progression (a well-tested mathematical fact): for any nonnegative integer $n$, the summation of consecutive integers from $0$ to $n-1$ satisfies\n$$\n\\sum_{i=0}^{n-1} i \\;=\\; \\frac{n(n-1)}{2}.\n$$\nYour task is to exploit this identity as a compiler-agnostic oracle for metamorphic testing: multiple syntactically distinct but semantically equivalent loop constructs must compute the same numerical result for the summation, and that result must equal the closed-form identity. If a compiler’s optimizer introduces a bug, different loop variants may disagree with one another or disagree with the oracle.\n\nRequirements:\n1. Construct $8$ loop variants that each compute the sum $\\sum_{i=0}^{n-1} i$ using distinct control-flow shapes, including but not limited to:\n   - A canonical counted loop with post-increment,\n   - A counted loop with pre-increment,\n   - A reverse loop counting down,\n   - A while-loop,\n   - A do-while-loop,\n   - A pairwise two-index summation that converges from both ends,\n   - A loop that uses a post-decrement induction variable,\n   - A structurally equivalent loop using an explicit jump or equivalent control construct.\n   These variants must be free of undefined behavior. All arithmetic must be performed in unsigned $64$-bit integer arithmetic to avoid signed overflow. Ensure integer ranges are chosen so that no unsigned $64$-bit overflow occurs for the provided test suite.\n\n2. Implement a closed-form oracle function that returns $\\frac{n(n-1)}{2}$ for a given nonnegative integer $n$ without overflow in intermediate products for the provided test suite. You must implement it in integer arithmetic by dividing by $2$ before multiplying to keep the intermediate product within range; for example, compute $(n/2)\\cdot(n-1)$ if $n$ is even, or $n\\cdot\\big((n-1)/2\\big)$ if $n$ is odd.\n\n3. Differential test harness:\n   - For each test value $n$, compute the result of each loop variant and the oracle.\n   - For each $n$, output a boolean value that is true if and only if all loop variants produce the identical value and that value equals the oracle.\n\n4. Test suite:\n   Use the following set of $8$ test values for $n$, designed to cover the happy path and boundary-like behaviors while remaining efficient and overflow-safe in $64$-bit arithmetic:\n   - $n \\in \\{0, 1, 2, 3, 10, 127, 1000, 200000\\}$.\n\n5. Output format:\n   Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each boolean must be represented as an integer $1$ for true and $0$ for false. The list must be ordered to correspond to the $n$ values in the test suite above. For example, an output with all passing checks must look like\n   $[1,1,1,1,1,1,1,1]$.\n\nNo external input is required. The code must be self-contained and deterministic.\n\nScientific realism and constraints:\n- All computations must be performed using unsigned $64$-bit integers to avoid signed overflow and undefined behavior, and the test suite chosen ensures that the total sum $\\frac{n(n-1)}{2}$ fits within the range $[0, 2^{64}-1]$.\n- Ensure all loop forms terminate correctly for $n=0$ and small $n$.\n- The reasoning must be purely logical and mathematical; no physical units apply.", "solution": "The present problem requires the design and implementation of a differential testing harness for compilers. The core principle of this exercise rests on the concept of metamorphic testing, a powerful technique for test oracle generation. In this paradigm, we exploit known properties, or metamorphic relations, of the function under test to verify its output without needing a pre-computed set of expected results for all inputs. If a property is violated, a bug is likely present.\n\nHere, the \"function under test\" is not a single piece of code, but rather the compilation process itself, especially the optimization phases of a C compiler. The metamorphic property is derived from a fundamental mathematical identity: the sum of the first $n$ non-negative integers is given by the closed-form expression $\\sum_{i=0}^{n-1} i = \\frac{n(n-1)}{2}$.\n\nThe testing strategy is as follows: we create multiple, syntactically distinct C functions that are all semantically designed to compute this same sum, $\\sum_{i=0}^{n-1} i$. A correct, non-buggy compiler should generate machine code for each of these variants that produces the exact same numerical result, given there is no undefined behavior or arithmetic overflow. Furthermore, this result must match the value computed by a trusted \"oracle\" function that implements the closed-form identity $\\frac{n(n-1)}{2}$. A discrepancy between any of the loop variants, or between a variant and the oracle, signals a potential compiler defect, where an optimization may have incorrectly altered the program's semantics.\n\nThe implementation comprises three primary components: the test oracle, the set of loop variants, and the test harness.\n\n**1. The Test Oracle**\n\nThe oracle provides the ground truth against which all loop variants are measured. It computes the sum using the direct mathematical formula $S(n) = \\frac{n(n-1)}{2}$. To prevent intermediate integer overflow, which could occur with a naive evaluation of $n \\cdot (n-1)$ for very large $n$, the implementation is designed to perform the division by 2 first. Since for any integer $n$, either $n$ is even or $n-1$ is even, this division always yields an integer. The calculation is performed as:\n- If $n$ is even: $S(n) = (n/2) \\cdot (n-1)$\n- If $n$ is odd: $S(n) = n \\cdot ((n-1)/2)$\nAll arithmetic is performed using `unsigned long long`, a type guaranteed to be at least 64 bits wide, which is sufficient to hold all intermediate and final results for the given test suite without overflow. The largest sum for $n = 200000$ is $19,999,900,000$, well within the range of a 64-bit unsigned integer (approx. $1.84 \\times 10^{19}$).\n\n**2. The Loop Variants**\n\nA set of 8 distinct loop functions is implemented to compute the summation. These variants are designed to have different control-flow structures, thereby exercising different potential optimization pathways in the compiler. Each function takes a single `unsigned long long` parameter $n$ and returns the computed sum. All loops are carefully constructed to be free of undefined behavior and to correctly handle edge cases, particularly $n=0$ and $n=1$. The variants are:\n- **Canonical `for` loop (post-increment):** The most common summation loop, `for (i = 0; i  n; i++)`.\n- **`for` loop (pre-increment):** Uses `++i` instead of `i++`. Functionally identical for this loop body, but syntactically distinct.\n- **Reverse `for` loop:** Counts down from $n$ to $1$, summing `i-1` in each step. This tests optimizations on downward-counting loops. The condition `i > 0` is used for safety with unsigned types.\n- **`while` loop:** A straightforward conversion of the canonical `for` loop, separating initialization, condition, and update statements.\n- **`do-while` loop:** This variant always executes at least once, requiring an explicit check to correctly handle the $n=0$ case, where the loop body should not be entered.\n- **Pairwise summation:** Uses two index variables, `low` starting at 0 and `high` at $n-1$, that converge toward the middle. In each step, `sum += low + high`. An additional step is required to add the middle element if $n$ is an odd number.\n- **Post-decrement loop:** This variant uses a `for(;;)` an infinite loop construct with a `break` condition based on a post-decrement operator (`i--`), providing another unique control flow.\n- **`goto`-based loop:** Mimics the structure of a `while` loop using explicit labels and `goto` statements, directly testing the compiler's handling of non-structured control flow.\n\n**3. The Test Harness**\n\nThe `main` function serves as the test harness. It defines the test suite for $n$, which includes the values $\\{0, 1, 2, 3, 10, 127, 1000, 200000\\}$. For each value of $n$ in this suite, the harness performs the following steps:\n- It computes the expected result using the `oracle_sum` function.\n- It iterates through an array of function pointers, where each pointer references one of the 8 loop variants.\n- For each variant, it calls the function with $n$ and compares its return value to the oracle's result.\n- If any variant produces a result that deviates from the oracle's, a flag for the current $n$ is set to 0 (false). If all variants match the oracle, the flag remains 1 (true).\n- Finally, the program prints a single line of output: a comma-separated list of these boolean flags (as 1 or 0), enclosed in square brackets, corresponding to the sequence of test values for $n$.\n\nThis complete structure provides a self-contained, deterministic program that acts as a practical metamorphic test for a C compiler's implementation of loop-based integer arithmetic. A correct compiler should produce the output `[1,1,1,1,1,1,1,1]`.", "answer": "```c\n// This program implements a differential testing harness for C compilers.\n// It uses a known mathematical identity as a metamorphic relation to verify\n// that multiple, structurally distinct loop constructs produce identical results.\n#include stdio.h\n#include stdlib.h\n\n// Use 'unsigned long long' for 64-bit unsigned integers. This type is\n// guaranteed by the C standard (since C99) to be at least 64 bits wide.\n// The C23 standard is specified in the problem.\ntypedef unsigned long long uint64_t_t;\n\n// Function prototypes for the 8 loop variants and the oracle.\nuint64_t_t sum_for_post_inc(uint64_t_t n);\nuint64_t_t sum_for_pre_inc(uint64_t_t n);\nuint64_t_t sum_reverse_for(uint64_t_t n);\nuint64_t_t sum_while(uint64_t_t n);\nuint64_t_t sum_do_while(uint64_t_t n);\nuint64_t_t sum_pairwise(uint64_t_t n);\nuint64_t_t sum_post_decrement(uint64_t_t n);\nuint64_t_t sum_goto(uint64_t_t n);\nuint64_t_t oracle_sum(uint64_t_t n);\n\n// 1. Canonical counted loop with post-increment.\nuint64_t_t sum_for_post_inc(uint64_t_t n) {\n    uint64_t_t sum = 0;\n    for (uint64_t_t i = 0; i  n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n\n// 2. Counted loop with pre-increment.\nuint64_t_t sum_for_pre_inc(uint64_t_t n) {\n    uint64_t_t sum = 0;\n    for (uint64_t_t i = 0; i  n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// 3. Reverse loop counting down.\nuint64_t_t sum_reverse_for(uint64_t_t n) {\n    uint64_t_t sum = 0;\n    // Loop from n down to 1. The summand is i-1.\n    // This is safe with unsigned integers as i  0 becomes false when i is 0.\n    for (uint64_t_t i = n; i  0; i--) {\n        sum += (i - 1);\n    }\n    return sum;\n}\n\n// 4. A while-loop.\nuint64_t_t sum_while(uint64_t_t n) {\n    uint64_t_t sum = 0;\n    uint64_t_t i = 0;\n    while (i  n) {\n        sum += i;\n        i++;\n    }\n    return sum;\n}\n\n// 5. A do-while-loop.\nuint64_t_t sum_do_while(uint64_t_t n) {\n    uint64_t_t sum = 0;\n    // A do-while loop executes at least once, so n=0 must be handled separately.\n    if (n == 0) {\n        return 0;\n    }\n    uint64_t_t i = 0;\n    do {\n        sum += i;\n        i++;\n    } while (i  n);\n    return sum;\n}\n\n// 6. A pairwise two-index summation that converges from both ends.\nuint64_t_t sum_pairwise(uint64_t_t n) {\n    if (n == 0) {\n        return 0;\n    }\n    uint64_t_t sum = 0;\n    uint64_t_t low = 0;\n    uint64_t_t high = n - 1;\n    while (low  high) {\n        sum += low + high;\n        low++;\n        high--;\n    }\n    // If n is odd, the middle element `low == high` is left over.\n    if (low == high) {\n        sum += low;\n    }\n    return sum;\n}\n\n// 7. A loop that uses a post-decrement induction variable.\nuint64_t_t sum_post_decrement(uint64_t_t n) {\n    uint64_t_t sum = 0;\n    if (n  0) {\n        uint64_t_t i = n - 1;\n        // The loop sums from n-1 down to 0.\n        for (;;) {\n            sum += i;\n            // The post-decrement i-- evaluates to i's value before decrement.\n            // When i is 0, the expression `i-- == 0` is true, and we break.\n            if (i-- == 0) {\n                break;\n            }\n        }\n    }\n    return sum;\n}\n\n// 8. A structurally equivalent loop using an explicit jump (goto).\nuint64_t_t sum_goto(uint64_t_t n) {\n    uint64_t_t sum = 0;\n    uint64_t_t i = 0;\nloop_start:\n    if (i = n) {\n        goto loop_end;\n    }\n    sum += i;\n    i++;\n    goto loop_start;\nloop_end:\n    return sum;\n}\n\n// The closed-form oracle function.\nuint64_t_t oracle_sum(uint64_t_t n) {\n    // For n=0 and n=1, the sum is 0.\n    if (n  2) {\n        return 0;\n    }\n    // To prevent intermediate overflow (good practice), divide before multiplying.\n    if (n % 2 == 0) {\n        // n is even: (n / 2) * (n - 1)\n        return (n / 2) * (n - 1);\n    } else {\n        // n is odd, so n-1 is even: n * ((n - 1) / 2)\n        return n * ((n - 1) / 2);\n    }\n}\n\nint main(void) {\n    // Define the test suite for n.\n    uint64_t_t test_n[] = {0, 1, 2, 3, 10, 127, 1000, 200000};\n    int num_cases = sizeof(test_n) / sizeof(test_n[0]);\n    int results[num_cases];\n\n    // Create an array of function pointers to the loop variants.\n    typedef uint64_t_t (*sum_func_t)(uint64_t_t);\n    sum_func_t loops[] = {\n        sum_for_post_inc,\n        sum_for_pre_inc,\n        sum_reverse_for,\n        sum_while,\n        sum_do_while,\n        sum_pairwise,\n        sum_post_decrement,\n        sum_goto\n    };\n    int num_loops = sizeof(loops) / sizeof(loops[0]);\n\n    // Apply the differential test for each value of n.\n    for (int i = 0; i  num_cases; ++i) {\n        uint64_t_t n = test_n[i];\n        uint64_t_t oracle_val = oracle_sum(n);\n        \n        // Assume true unless a mismatch is found.\n        results[i] = 1;\n\n        for (int j = 0; j  num_loops; ++j) {\n            uint64_t_t loop_val = loops[j](n);\n            if (loop_val != oracle_val) {\n                results[i] = 0;\n                break; // Mismatch found, no need to check other loops for this n.\n            }\n        }\n    }\n\n    // Print the results in the EXACT required format.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3637908"}]}