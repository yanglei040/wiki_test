{"hands_on_practices": [{"introduction": "To build a solid understanding of control dependence, we begin with a foundational exercise. This problem examines a simple sequence of conditional statements to highlight the core principle: a statement is control-dependent on a condition if the condition's outcome determines whether the statement executes. By applying the formal definitions of postdominance and control dependence, you will learn to distinguish between code that is truly conditional and code that simply follows a control-flow merge point.", "problem": "Consider the following straight-line fragment with two conditionals over the same boolean expression and a trailing statement:\n```\nif (p) S1;\nif ($\\neg p$) S2;\nS3;\n```\nAssume that $p$ has no side effects when evaluated; `S1`, `S2`, and `S3` are basic blocks that do not throw exceptions, do not perform abnormal control transfers, and always fall through to their successor. Model this fragment as a control flow graph (CFG) with an `Entry` node, an `Exit` node, and two distinct predicate nodes: `B1` for the first test of $p$ and `B2` for the second test of $\\neg p$; the then-edges go to `S1` and `S2` respectively, and the else-edges fall through to the next statement in sequence.\n\nUsing the standard foundation for control dependence based on postdominance:\n- A node $X$ postdominates a node $Y$ if every path from $Y$ to the `Exit` node contains $X$. A node $X$ **strictly postdominates** $Y$ if $X$ postdominates $Y$ and $X \\neq Y$.\n- A node $S$ is control-dependent on a predicate node $P$ if there exists an edge $P \\to Q$ such that $S$ postdominates $Q$, but $S$ does not strictly postdominate $P$.\n\nInterpret “control-dependent on $p$” to mean “control-dependent on one of the predicate nodes that evaluate $p$ or $\\neg p$,” namely `B1` or `B2`. Which of `S1`, `S2`, `S3` are control-dependent on $p$ in this sense?\n\nChoose the single best option:\n\nA. Only `S1`\n\nB. Only `S2`\n\nC. `S1` and `S2`, but not `S3`\n\nD. `S1`, `S2`, and `S3`\n\nE. None of `S1`, `S2`, `S3`", "solution": "The problem statement is a valid exercise in control dependence analysis, a standard topic in compiler theory. It provides a clear code fragment, a specific set of rules for constructing the corresponding control flow graph (CFG), and precise definitions for postdominance and control dependence. The problem is self-contained, logically consistent, and well-posed.\n\nThe solution proceeds in three steps:\n1.  Construction of the Control Flow Graph (CFG) as per the problem description.\n2.  Analysis of postdominance relationships within the CFG.\n3.  Application of the control dependence definition to determine the dependencies of statements `S1`, `S2`, and `S3` on the predicate nodes `B1` and `B2`.\n\n**1. Control Flow Graph (CFG) Construction**\n\nThe problem specifies the program fragment and the structure of the CFG.\nProgram fragment:\n```\nif (p) S1;\nif ($\\neg p$) S2;\nS3;\n```\nThe nodes are `Entry`, `B1` (for `if (p)`), `S1`, `B2` (for `if ($\\neg p$)`), `S2`, `S3`, and `Exit`. The edges are determined by the control flow and the fall-through behavior:\n\n-   `Entry` $\\rightarrow$ `B1`: Execution begins at the first conditional.\n-   `B1` $\\xrightarrow{\\text{true}}$ `S1`: If $p$ is true, execute `S1`.\n-   `B1` $\\xrightarrow{\\text{false}}$ `B2`: If $p$ is false, skip `S1` and fall through to the next statement, which starts at `B2`.\n-   `S1` $\\rightarrow$ `B2`: After `S1` executes, it falls through to the next statement, which starts at `B2`.\n-   `B2` $\\xrightarrow{\\text{true}}$ `S2`: If $\\neg p$ is true (i.e., $p$ is false), execute `S2`.\n-   `B2` $\\xrightarrow{\\text{false}}$ `S3`: If $\\neg p$ is false (i.e., $p$ is true), skip `S2` and fall through to `S3`.\n-   `S2` $\\rightarrow$ `S3`: After `S2` executes, it falls through to `S3`.\n-   `S3` $\\rightarrow$ `Exit`: After `S3` executes, the fragment terminates.\n\nWe can trace the two possible execution paths based on the value of $p$:\n-   If $p$ is true: `Entry` $\\rightarrow$ `B1` $\\rightarrow$ `S1` $\\rightarrow$ `B2` $\\rightarrow$ `S3` $\\rightarrow$ `Exit`.\n-   If $p$ is false: `Entry` $\\rightarrow$ `B1` $\\rightarrow$ `B2` $\\rightarrow$ `S2` $\\rightarrow$ `S3` $\\rightarrow$ `Exit`.\n\n**2. Postdominance Analysis**\n\nThe definition provided states: A node `X` postdominates a node `Y` if every path from `Y` to `Exit` contains `X`. We analyze the key postdominance relationships required for the control dependence check.\n\n-   **Postdominance of `S3`**:\n    -   Any path from `S2` must go through `S3` (`S2` $\\rightarrow$ `S3` $\\rightarrow$ `Exit`). Thus, `S3` postdominates `S2`.\n    -   The paths from `B2` are `B2` $\\rightarrow$ `S2` $\\rightarrow$ `S3` $\\rightarrow$ `Exit` and `B2` $\\rightarrow$ `S3` $\\rightarrow$ `Exit`. Both contain `S3`. Thus, `S3` postdominates `B2`.\n    -   Any path from `S1` must go through `B2` (`S1` $\\rightarrow$ `B2` $\\rightarrow$ ...), and we've established `S3` postdominates `B2`. Thus, `S3` postdominates `S1`.\n    -   The paths from `B1` are `B1` $\\rightarrow$ `S1` $\\rightarrow$ `B2` $\\rightarrow$ `S3` $\\rightarrow$ `Exit` and `B1` $\\rightarrow$ `B2` $\\rightarrow$ `S2` $\\rightarrow$ `S3` $\\rightarrow$ `Exit`. Both contain `S3`. Thus, `S3` postdominates `B1`.\n\n-   **Postdominance involving `S1`**:\n    -   A path from `B1` is `B1` $\\rightarrow$ `B2` $\\rightarrow$ ... This path does not contain `S1`. Therefore, `S1` does not postdominate `B1`.\n    -   A path from `B2` is `B2` $\\rightarrow$ `S2` $\\rightarrow$ `S3` $\\rightarrow$ `Exit`. This path does not contain `S1`. Therefore, `S1` does not postdominate `B2`.\n\n-   **Postdominance involving `S2`**:\n    -   A path from `B2` is `B2` $\\rightarrow$ `S3` $\\rightarrow$ `Exit`. This path does not contain `S2`. Therefore, `S2` does not postdominate `B2`.\n    -   A path from `S3` is `S3` $\\rightarrow$ `Exit`. This path does not contain `S2`. Therefore, `S2` does not postdominate `S3`.\n\n**3. Control Dependence Analysis**\n\nThe problem provides the standard definition of control dependence. We check this for each statement `S1, S2, S3` with respect to predicates `B1` and `B2`.\n\n**Control Dependence on `B1`**\n-   The predicate node is `P`=`B1`. Its successors are `S1` (true branch) and `B2` (false branch).\n\n-   Is `S1` control-dependent on `B1`? We check if `S1` postdominates a successor of `B1` but does not strictly postdominate `B1`.\n    -   Consider successor `Q`=`S1`. `S1` postdominates `S1` trivially.\n    -   Does `S1` strictly postdominate `B1`? No, because there's a path `B1` $\\rightarrow$ `B2` $\\rightarrow$ `S2` $\\rightarrow$ `S3` $\\rightarrow$ `Exit` that bypasses `S1`.\n    -   Since the conditions are met, **`S1` is control-dependent on `B1`**.\n\n-   Is `S2` control-dependent on `B1`?\n    -   Does `S2` postdominate `S1`? No.\n    -   Does `S2` postdominate `B2`? No.\n    -   `S2` does not postdominate any successor of `B1`. Therefore, **`S2` is not control-dependent on `B1`**.\n\n-   Is `S3` control-dependent on `B1`?\n    -   Does `S3` strictly postdominate `B1`? No, `S3` postdominates `B1` but is not equal to `B1`. So `S3` strictly postdominates `B1`.\n    -   The second condition for control dependence (\"does not strictly postdominate `P`\") is not met. Therefore, **`S3` is not control-dependent on `B1`**.\n\n**Control Dependence on `B2`**\n-   The predicate node is `P`=`B2`. Its successors are `S2` (true branch for $\\neg p$) and `S3` (false branch for $\\neg p$).\n\n-   Is `S1` control-dependent on `B2`?\n    -   Does `S1` postdominate `S2`? No.\n    -   Does `S1` postdominate `S3`? No.\n    -   Therefore, **`S1` is not control-dependent on `B2`**.\n\n-   Is `S2` control-dependent on `B2`?\n    -   Consider successor `Q`=`S2`. `S2` postdominates `S2` trivially.\n    -   Does `S2` strictly postdominate `B2`? No, because there's a path `B2` $\\rightarrow$ `S3` $\\rightarrow$ `Exit` that bypasses `S2`.\n    -   Since the conditions are met, **`S2` is control-dependent on `B2`**.\n\n-   Is `S3` control-dependent on `B2`?\n    -   `S3` strictly postdominates `B2` (since every path from `B2` goes through `S3`).\n    -   The second condition for control dependence is not met. Therefore, **`S3` is not control-dependent on `B2`**.\n\n**Conclusion**\n-   `S1` is control-dependent on `B1`.\n-   `S2` is control-dependent on `B2`.\n-   `S3` is not control-dependent on `B1` or `B2`.\n\nThe question asks which statements are \"control-dependent on $p$\", meaning control-dependent on either `B1` or `B2`. Based on our analysis, these are `S1` and `S2`.\n\n**Option-by-Option Analysis**\n-   A. Only `S1`: **Incorrect**. `S2` is control-dependent on `B2`.\n-   B. Only `S2`: **Incorrect**. `S1` is control-dependent on `B1`.\n-   C. `S1` and `S2`, but not `S3`: **Correct**. This matches our analysis. `S1` is dependent on `B1`, `S2` is dependent on `B2`, and `S3` is dependent on neither because it is a postdominator of the join points.\n-   D. `S1`, `S2`, and `S3`: **Incorrect**. `S3` is not control-dependent on either predicate.\n-   E. None of `S1`, `S2`, `S3`: **Incorrect**. `S1` and `S2` are control-dependent as shown.", "answer": "$$\\boxed{C}$$", "id": "3632542"}, {"introduction": "Moving from simple conditionals, we now tackle the more complex and dynamic nature of loops. This practice explores a control flow graph featuring a loop with internal branches, a `continue` statement that restarts the iteration, and a `break` statement that exits the loop prematurely. Analyzing the control dependencies within this structure will deepen your understanding of how iterative control flow and early exits affect which parts of a program are governed by which decisions.", "problem": "Consider the Control Flow Graph (CFG) of the loop described below. The loop guard is the predicate node $G$. The loop body contains straight-line statements $S_1, S_2, S_3, S_4, S_5, S_6$, a $continue$ statement $K$, and a $break$ statement $R$. There are two internal branch predicates inside the loop body, denoted $C_1$ and $C_2$. The unique exit node is $X$, and the unique entry node is $E$. The graph is reducible and has a single exit. The edges are as follows:\n- $E \\to G$.\n- $G \\xrightarrow{\\text{true}} S_1$, $G \\xrightarrow{\\text{false}} X$.\n- $S_1 \\to C_1$.\n- $C_1 \\xrightarrow{\\text{true}} S_2$, $C_1 \\xrightarrow{\\text{false}} S_3$.\n- $S_2 \\to K$, $K \\to G$.\n- $S_3 \\to C_2$.\n- $C_2 \\xrightarrow{\\text{true}} S_4$, $S_4 \\to R$, $R \\to X$.\n- $C_2 \\xrightarrow{\\text{false}} S_5$, $S_5 \\to S_6$, $S_6 \\to G$.\n\nAssume standard semantics: $continue$ transfers control directly to $G$ in the same loop iteration, and $break$ transfers control to $X$.\n\nStarting only from core definitions, use control dependence analysis to determine, for each of the three predicate nodes $G$, $C_1$, and $C_2$, which loop body statements are control-dependent on that predicate. Use the following foundational definitions.\n- A node $p$ postdominates a node $n$ if and only if every path from $n$ to the unique exit $X$ contains $p$.\n- The immediate postdominator $\\operatorname{idom}(n)$ of a node $n$ is the unique postdominator of $n$ that strictly postdominates $n$ and is closest to $n$ in the postdominator tree.\n- A node $Y$ is control-dependent on a node $X$ if and only if there exists a directed path from $X$ to $Y$ such that $Y$ postdominates every node on this path after $X$, and $Y$ does not postdominate $X$.\n\nCount only loop body statements among the set $\\{S_1, S_2, S_3, S_4, S_5, S_6, K, R\\}$; do not count $G$, $C_1$, or $C_2$ themselves. Report your final answer as the ordered triple of counts $\\left(|CD(G)|, |CD(C_1)|, |CD(C_2)|\\right)$, where $|CD(\\cdot)|$ denotes the number of loop body statements control-dependent on the given predicate. Express your final answer as a row matrix using the $\\operatorname{pmatrix}$ environment. No rounding is required, and no units are involved.", "solution": "The problem requires a control dependence analysis of a given Control Flow Graph (CFG). The analysis will be conducted by first establishing the postdominance relationships within the graph, constructing the postdominator tree, and then applying the formal definition of control dependence to the specified predicate nodes $G$, $C_1$, and $C_2$.\n\nFirst, we formalize the structure of the CFG. The set of nodes is $\\{E, G, S_1, C_1, S_2, K, S_3, C_2, S_4, R, S_5, S_6, X\\}$. The edges are given as:\n$E \\to G$\n$G \\to S_1$ (true branch)\n$G \\to X$ (false branch)\n$S_1 \\to C_1$\n$C_1 \\to S_2$ (true branch)\n$C_1 \\to S_3$ (false branch)\n$S_2 \\to K$\n$K \\to G$\n$S_3 \\to C_2$\n$C_2 \\to S_4$ (true branch)\n$C_2 \\to S_5$ (false branch)\n$S_4 \\to R$\n$R \\to X$\n$S_5 \\to S_6$\n$S_6 \\to G$\n\nThe core of the analysis relies on postdominance. A node $p$ postdominates a node $n$ if every path from $n$ to the unique exit node $X$ necessarily includes $p$. We denote the set of postdominators of $n$ as $\\operatorname{pdom}(n)$. By systematically analyzing all paths from each node to $X$, we determine these sets.\n\n- Paths from $R$ to $X$: The only path is $R \\to X$. Thus, $\\operatorname{pdom}(R) = \\{R, X\\}$.\n- Paths from $S_4$: The only path is $S_4 \\to R \\to X$. Thus, $\\operatorname{pdom}(S_4) = \\{S_4, R, X\\}$.\n- Paths from $S_6$: The only path is $S_6 \\to G \\to \\dots$. Any path from $G$ to $X$ can be taken. However, all paths from $S_6$ must first go through $G$. Therefore, $G$ postdominates $S_6$. $\\operatorname{pdom}(S_6) = \\{S_6, G, X\\}$.\n- Paths from $S_5$: The only path is $S_5 \\to S_6 \\to \\dots$. Thus, $S_6$ postdominates $S_5$. $\\operatorname{pdom}(S_5) = \\{S_5, S_6, G, X\\}$.\n- Paths from $K$: The only path is $K \\to G \\to \\dots$. Thus, $G$ postdominates $K$. $\\operatorname{pdom}(K) = \\{K, G, X\\}$.\n- Paths from $S_2$: The only path is $S_2 \\to K \\to \\dots$. Thus, $K$ postdominates $S_2$. $\\operatorname{pdom}(S_2) = \\{S_2, K, G, X\\}$.\n- Paths from $S_3$: The only path is $S_3 \\to C_2 \\to \\dots$. Thus, $C_2$ postdominates $S_3$. $\\operatorname{pdom}(S_3) = \\{S_3, C_2, X\\}$.\n- Paths from $S_1$: The only path is $S_1 \\to C_1 \\to \\dots$. Thus, $C_1$ postdominates $S_1$. $\\operatorname{pdom}(S_1) = \\{S_1, C_1, X\\}$.\n- Paths from $E$: The only path is $E \\to G \\to \\dots$. Thus, $G$ postdominates $E$. $\\operatorname{pdom}(E) = \\{E, G, X\\}$.\n- Paths from predicate nodes:\n  - From $G$: There is a direct path $G \\to X$ and paths through the loop body (e.g., $G \\to S_1 \\to C_1 \\to S_3 \\to C_2 \\to S_4 \\to R \\to X$). These paths have no common node except $G$ and $X$. Thus, $\\operatorname{pdom}(G) = \\{G, X\\}$.\n  - From $C_1$: The true branch leads to $S_2 \\to K \\to G$, and the false branch leads to $S_3 \\to C_2$. Paths from $G$ can exit directly at $X$. Paths from $C_2$ can exit via $R \\to X$. For example, the path $C_1 \\to S_2 \\to K \\to G \\to X$ and the path $C_1 \\to S_3 \\to C_2 \\to S_4 \\to R \\to X$ share no nodes other than $C_1$ and $X$. Thus, $\\operatorname{pdom}(C_1) = \\{C_1, X\\}$.\n  - From $C_2$: The true branch leads to $S_4 \\to R \\to X$, exiting the loop. The false branch leads to $S_5 \\to S_6 \\to G$, re-entering the loop structure. The paths $C_2 \\to S_4 \\to R \\to X$ and $C_2 \\to S_5 \\to S_6 \\to G \\to X$ share no nodes other than $C_2$ and $X$. Thus, $\\operatorname{pdom}(C_2) = \\{C_2, X\\}$.\n\nFrom the postdominator sets, we determine the immediate postdominator, $\\operatorname{idom}(n)$, for each node $n \\neq X$. This defines the postdominator tree, where the parent of a node $n$ is $\\operatorname{idom}(n)$.\n- $\\operatorname{idom}(E) = G$\n- $\\operatorname{idom}(G) = X$\n- $\\operatorname{idom}(S_1) = C_1$\n- $\\operatorname{idom}(C_1) = X$\n- $\\operatorname{idom}(S_2) = K$\n- $\\operatorname{idom}(K) = G$\n- $\\operatorname{idom}(S_3) = C_2$\n- $\\operatorname{idom}(C_2) = X$\n- $\\operatorname{idom}(S_4) = R$\n- $\\operatorname{idom}(R) = X$\n- $\\operatorname{idom}(S_5) = S_6$\n- $\\operatorname{idom}(S_6) = G$\n\nThe postdominator tree has root $X$ and the following parent-child relationships: $X$ is parent of $G, C_1, C_2, R$. $G$ is parent of $E, K, S_6$. $C_1$ is parent of $S_1$. $C_2$ is parent of $S_3$. $R$ is parent of $S_4$. $K$ is parent of $S_2$. $S_6$ is parent of $S_5$.\n\nNow we apply a common algorithm for computing control dependencies based on the postdominator tree. For a predicate node $P$ with an outgoing edge $P \\to A$, the nodes on the postdominator tree path from $A$ up to, but not including, the least common ancestor of $P$ and $A$ in the tree, $\\operatorname{lca}(P, A)$, are control-dependent on $P$.\n\n1.  Control Dependence on $G$:\n    - The predicate is $P=G$. It has two outgoing edges: $G \\to S_1$ and $G \\to X$.\n    - For edge $G \\to S_1$: $A=S_1$. In the postdominator tree, the path from $G$ to the root is $G \\to X$. The path from $S_1$ to the root is $S_1 \\to C_1 \\to X$. The least common ancestor is $\\operatorname{lca}(G, S_1) = X$. The nodes on the tree path from $S_1$ up to, but not including, $X$ are $\\{S_1, C_1\\}$.\n    - For edge $G \\to X$: $A=X$. $\\operatorname{lca}(G, X) = X$. The path from $X$ to $X$ is empty, yielding no dependencies.\n    - Thus, the set of nodes control-dependent on $G$ is $\\{S_1, C_1\\}$.\n    - Filtering for loop body statements from the set $\\{S_1, S_2, S_3, S_4, S_5, S_6, K, R\\}$, we get $\\{S_1\\}$.\n    - The count is $|CD(G)| = 1$.\n\n2.  Control Dependence on $C_1$:\n    - The predicate is $P=C_1$. It has two outgoing edges: $C_1 \\to S_2$ and $C_1 \\to S_3$.\n    - For edge $C_1 \\to S_2$: $A=S_2$. The tree path from $C_1$ is $C_1 \\to X$. The tree path from $S_2$ is $S_2 \\to K \\to G \\to X$. $\\operatorname{lca}(C_1, S_2) = X$. The nodes on the tree path from $S_2$ up to $X$ are $\\{S_2, K, G\\}$.\n    - For edge $C_1 \\to S_3$: $A=S_3$. The tree path from $C_1$ is $C_1 \\to X$. The tree path from $S_3$ is $S_3 \\to C_2 \\to X$. $\\operatorname{lca}(C_1, S_3) = X$. The nodes on the tree path from $S_3$ up to $X$ are $\\{S_3, C_2\\}$.\n    - Combining these results, $CD(C_1) = \\{S_2, K, G\\} \\cup \\{S_3, C_2\\} = \\{S_2, S_3, K, G, C_2\\}$.\n    - Filtering for loop body statements, we get $\\{S_2, S_3, K\\}$.\n    - The count is $|CD(C_1)| = 3$.\n\n3.  Control Dependence on $C_2$:\n    - The predicate is $P=C_2$. It has two outgoing edges: $C_2 \\to S_4$ and $C_2 \\to S_5$.\n    - For edge $C_2 \\to S_4$: $A=S_4$. The tree path from $C_2$ is $C_2 \\to X$. The tree path from $S_4$ is $S_4 \\to R \\to X$. $\\operatorname{lca}(C_2, S_4) = X$. The nodes on the tree path from $S_4$ up to $X$ are $\\{S_4, R\\}$.\n    - For edge $C_2 \\to S_5$: $A=S_5$. The tree path from $C_2$ is $C_2 \\to X$. The tree path from $S_5$ is $S_5 \\to S_6 \\to G \\to X$. $\\operatorname{lca}(C_2, S_5) = X$. The nodes on the tree path from $S_5$ up to $X$ are $\\{S_5, S_6, G\\}$.\n    - Combining these results, $CD(C_2) = \\{S_4, R\\} \\cup \\{S_5, S_6, G\\} = \\{S_4, S_5, S_6, R, G\\}$.\n    - Filtering for loop body statements, we get $\\{S_4, S_5, S_6, R\\}$.\n    - The count is $|CD(C_2)| = 4$.\n\nThe ordered triple of counts $(|CD(G)|, |CD(C_1)|, |CD(C_2)|)$ is $(1, 3, 4)$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  3  4\n\\end{pmatrix}\n}\n$$", "id": "3632566"}, {"introduction": "Our final practice connects control dependence analysis to the practical realities of compilation. High-level code often contains implicit control flow, such as the short-circuiting logic in boolean expressions like `A  (B || C)`. This exercise asks you to analyze the low-level control flow graph that a compiler generates for such expressions. By tracing the dependencies, you will see how the evaluation of each sub-expression is controlled by the outcomes of the preceding ones, revealing the hidden decision-making structure that is essential for compiler optimizations.", "problem": "Consider a compiler that lowers short-circuit evaluation of logical conjunction and disjunction into explicit branch-based basic blocks. The following function body contains two compound conditions that are compiled to short-circuit form. The resulting Control Flow Graph (CFG) is given by the set of basic blocks $\\{b_0, b_1, b_2, b_3, b_5, b_6, b_7, b_8, b_9, b_{11}, b_{12}, b_{13}, b_{14}\\}$ with directed edges as follows:\n- $b_0 \\rightarrow b_1$.\n- $b_1$ is a predicate block testing the first condition’s left operand; it has $2$ successors: $b_1 \\xrightarrow{\\text{true}} b_2$ and $b_1 \\xrightarrow{\\text{false}} b_5$.\n- $b_2$ is a predicate block testing the first condition’s inner disjunction’s first operand; it has $2$ successors: $b_2 \\xrightarrow{\\text{true}} b_6$ and $b_2 \\xrightarrow{\\text{false}} b_3$.\n- $b_3$ is a predicate block testing the first condition’s inner disjunction’s second operand; it has $2$ successors: $b_3 \\xrightarrow{\\text{true}} b_6$ and $b_3 \\xrightarrow{\\text{false}} b_5$.\n- $b_5 \\rightarrow b_7$ and $b_6 \\rightarrow b_7$.\n- $b_7 \\rightarrow b_8$.\n- $b_8$ is a predicate block testing the second condition’s inner disjunction’s first operand; it has $2$ successors: $b_8 \\xrightarrow{\\text{true}} b_{11}$ and $b_8 \\xrightarrow{\\text{false}} b_9$.\n- $b_9$ is a predicate block testing the second condition’s inner disjunction’s second operand; it has $2$ successors: $b_9 \\xrightarrow{\\text{true}} b_{11}$ and $b_9 \\xrightarrow{\\text{false}} b_{12}$.\n- $b_{11}$ is a predicate block testing the second condition’s conjunction’s right operand; it has $2$ successors: $b_{11} \\xrightarrow{\\text{true}} b_{13}$ and $b_{11} \\xrightarrow{\\text{false}} b_{12}$.\n- $b_{13} \\rightarrow b_{12}$ and $b_{12} \\rightarrow b_{14}$, where $b_{14}$ is the unique exit.\n\nTreat control dependence in the classical sense based on postdominators. Let $S$ be the set of all predicate blocks introduced solely to implement short-circuit evaluation of the compound conditions, namely $S = \\{b_1, b_2, b_3, b_8, b_9, b_{11}\\}$. Let $T$ be the total number of distinct control-dependence edges whose source lies in $S$ and whose target is any basic block in the CFG.\n\nCompute the value of $T$. The final answer must be a single real-valued number with no units. No rounding is required.", "solution": "The user wants me to compute the total number of control-dependence edges, $T$, originating from a specific set of predicate blocks $S$ in a given Control Flow Graph (CFG).\n\nThe solution proceeds in three main steps:\n1.  First, we construct the postdominator tree for the given CFG.\n2.  Second, using the postdominator tree, we determine the control dependencies for each predicate block in the set $S$.\n3.  Finally, we sum the number of distinct control-dependence edges found.\n\nA node $U$ postdominates a node $V$ if every path in the CFG from $V$ to the unique exit node contains $U$. The exit node is $b_{14}$. The immediate postdominator of a node $V$ (where $V$ is not the exit node), denoted $ipdom(V)$, is the postdominator of $V$ that is closest to $V$ on any path from $V$ to the exit. The set of all pairs $(ipdom(V), V)$ defines the postdominator tree, where $ipdom(V)$ is the parent of $V$.\n\nA node $Y$ is control dependent on a node $X$ if there exists a path from $X$ to $Y$ starting with an edge $X \\rightarrow Z$ such that $Y$ postdominates $Z$, and $Y$ does not strictly postdominate $X$. An operational method using the postdominator tree is to find, for each successor $Z$ of $X$, the set of nodes on the tree path from $Z$ up to (but not including) the immediate postdominator of $X$, $ipdom(X)$. The union of these sets over all successors gives the control dependents of $X$.\n\n**Step 1: Construct the Postdominator Tree**\n\nFirst, we must determine the postdominator set, $PDOM(n)$, for each node $n$ in the CFG. We work backward from the exit node $b_{14}$. For a node $n$, its postdominator set is $PDOM(n) = \\{n\\} \\cup (\\bigcap_{s \\in successors(n)} PDOM(s))$.\n\n- $PDOM(b_{14}) = \\{b_{14}\\}$\n- $PDOM(b_{12}) = \\{b_{12}\\} \\cup PDOM(b_{14}) = \\{b_{12}, b_{14}\\}$\n- $PDOM(b_{13}) = \\{b_{13}\\} \\cup PDOM(b_{12}) = \\{b_{13}, b_{12}, b_{14}\\}$\n- $PDOM(b_{11}) = \\{b_{11}\\} \\cup (PDOM(b_{13}) \\cap PDOM(b_{12})) = \\{b_{11}\\} \\cup \\{b_{12}, b_{14}\\} = \\{b_{11}, b_{12}, b_{14}\\}$\n- $PDOM(b_9) = \\{b_9\\} \\cup (PDOM(b_{11}) \\cap PDOM(b_{12})) = \\{b_9\\} \\cup \\{b_{12}, b_{14}\\} = \\{b_9, b_{12}, b_{14}\\}$\n- $PDOM(b_8) = \\{b_8\\} \\cup (PDOM(b_{11}) \\cap PDOM(b_9)) = \\{b_8\\} \\cup \\{b_{12}, b_{14}\\} = \\{b_8, b_{12}, b_{14}\\}$\n- $PDOM(b_7) = \\{b_7\\} \\cup PDOM(b_8) = \\{b_7, b_8, b_{12}, b_{14}\\}$\n- $PDOM(b_6) = \\{b_6\\} \\cup PDOM(b_7) = \\{b_6, b_7, b_8, b_{12}, b_{14}\\}$\n- $PDOM(b_5) = \\{b_5\\} \\cup PDOM(b_7) = \\{b_5, b_7, b_8, b_{12}, b_{14}\\}$\n- $PDOM(b_3) = \\{b_3\\} \\cup (PDOM(b_6) \\cap PDOM(b_5)) = \\{b_3\\} \\cup PDOM(b_7) = \\{b_3, b_7, b_8, b_{12}, b_{14}\\}$\n- $PDOM(b_2) = \\{b_2\\} \\cup (PDOM(b_6) \\cap PDOM(b_3)) = \\{b_2\\} \\cup PDOM(b_7) = \\{b_2, b_7, b_8, b_{12}, b_{14}\\}$\n- $PDOM(b_1) = \\{b_1\\} \\cup (PDOM(b_2) \\cap PDOM(b_5)) = \\{b_1\\} \\cup PDOM(b_7) = \\{b_1, b_7, b_8, b_{12}, b_{14}\\}$\n- $PDOM(b_0) = \\{b_0\\} \\cup PDOM(b_1) = \\{b_0, b_1, b_7, b_8, b_{12}, b_{14}\\}$\n\nFrom the postdominator sets, we find the immediate postdominator for each node:\n- $ipdom(b_{12}) = b_{14}$\n- $ipdom(b_{13}) = b_{12}$\n- $ipdom(b_{11}) = b_{12}$\n- $ipdom(b_9) = b_{12}$\n- $ipdom(b_8) = b_{12}$\n- $ipdom(b_7) = b_8$\n- $ipdom(b_6) = b_7$\n- $ipdom(b_5) = b_7$\n- $ipdom(b_3) = b_7$\n- $ipdom(b_2) = b_7$\n- $ipdom(b_1) = b_7$\n- $ipdom(b_0) = b_1$\n\nThis defines the postdominator tree where the exit $b_{14}$ is the root, and the children of a node $U$ are all nodes $V$ such that $ipdom(V)=U$. The tree structure is: $b_{14}$ is the parent of $b_{12}$; $b_{12}$ is the parent of $b_8, b_9, b_{11}, b_{13}$; $b_8$ is the parent of $b_7$; $b_7$ is the parent of $b_1, b_2, b_3, b_5, b_6$; and $b_1$ is the parent of $b_0$.\n\n**Step 2: Calculate Control Dependencies**\n\nWe now analyze each predicate block in $S = \\{b_1, b_2, b_3, b_8, b_9, b_{11}\\}$.\n\n1.  **Source: $b_1$**\n    - Successors: $b_2, b_5$.\n    - Join point: $ipdom(b_1) = b_7$.\n    - Path from $b_2$ to $b_7$ in postdominator tree: $b_2 \\rightarrow b_7$. Nodes on path excluding $b_7$: $\\{b_2\\}$.\n    - Path from $b_5$ to $b_7$ in postdominator tree: $b_5 \\rightarrow b_7$. Nodes on path excluding $b_7$: $\\{b_5\\}$.\n    - Nodes control dependent on $b_1$: $\\{b_2, b_5\\}$. Number of dependencies: $2$.\n\n2.  **Source: $b_2$**\n    - Successors: $b_3, b_6$.\n    - Join point: $ipdom(b_2) = b_7$.\n    - Path from $b_3$ to $b_7$: $b_3 \\rightarrow b_7$. Nodes: $\\{b_3\\}$.\n    - Path from $b_6$ to $b_7$: $b_6 \\rightarrow b_7$. Nodes: $\\{b_6\\}$.\n    - Nodes control dependent on $b_2$: $\\{b_3, b_6\\}$. Number of dependencies: $2$.\n\n3.  **Source: $b_3$**\n    - Successors: $b_5, b_6$.\n    - Join point: $ipdom(b_3) = b_7$.\n    - Path from $b_5$ to $b_7$: $b_5 \\rightarrow b_7$. Nodes: $\\{b_5\\}$.\n    - Path from $b_6$ to $b_7$: $b_6 \\rightarrow b_7$. Nodes: $\\{b_6\\}$.\n    - Nodes control dependent on $b_3$: $\\{b_5, b_6\\}$. Number of dependencies: $2$.\n\n4.  **Source: $b_8$**\n    - Successors: $b_9, b_{11}$.\n    - Join point: $ipdom(b_8) = b_{12}$.\n    - Path from $b_9$ to $b_{12}$: $b_9 \\rightarrow b_{12}$. Nodes: $\\{b_9\\}$.\n    - Path from $b_{11}$ to $b_{12}$: $b_{11} \\rightarrow b_{12}$. Nodes: $\\{b_{11}\\}$.\n    - Nodes control dependent on $b_8$: $\\{b_9, b_{11}\\}$. Number of dependencies: $2$.\n\n5.  **Source: $b_9$**\n    - Successors: $b_{11}, b_{12}$.\n    - Join point: $ipdom(b_9) = b_{12}$.\n    - Path from $b_{11}$ to $b_{12}$: $b_{11} \\rightarrow b_{12}$. Nodes: $\\{b_{11}\\}$.\n    - Path from $b_{12}$ to $b_{12}$: The path is empty (it starts and ends at the join point).\n    - Node control dependent on $b_9$: $\\{b_{11}\\}$. Number of dependencies: $1$.\n\n6.  **Source: $b_{11}$**\n    - Successors: $b_{13}, b_{12}$.\n    - Join point: $ipdom(b_{11}) = b_{12}$.\n    - Path from $b_{13}$ to $b_{12}$: $b_{13} \\rightarrow b_{12}$. Nodes: $\\{b_{13}\\}$.\n    - Path from $b_{12}$ to $b_{12}$: The path is empty.\n    - Node control dependent on $b_{11}$: $\\{b_{13}\\}$. Number of dependencies: $1$.\n\n**Step 3: Compute the Total Number of Dependencies $T$**\n\nThe total number of distinct control-dependence edges $T$ is the sum of the counts for each source block in $S$. The set of all such edges is $\\{ (b_1, b_2), (b_1, b_5), (b_2, b_3), (b_2, b_6), (b_3, b_5), (b_3, b_6), (b_8, b_9), (b_8, b_{11}), (b_9, b_{11}), (b_{11}, b_{13}) \\}$. All these pairs are distinct.\n$$T = 2 + 2 + 2 + 2 + 1 + 1 = 10$$\nThe total number of distinct control-dependence edges is $10$.", "answer": "$$\\boxed{10}$$", "id": "3632598"}]}