{"hands_on_practices": [{"introduction": "This first exercise is a fundamental warm-up, designed to build your intuition for interprocedural constant propagation. You will manually trace the flow of constant values through a series of nested function calls involving common bitwise operations. This practice [@problem_id:3648241] solidifies the core mechanism of substituting arguments and folding expressions across procedural boundaries, which is the heart of this optimization.", "problem": "Consider unsigned $32$-bit integers with the usual bitwise operators: bitwise AND $\\mathbin{\\}$, bitwise OR $\\mathbin{|}$, exclusive OR $\\oplus$, logical right shift $\\gg$, and left shift $\\ll$. Assume a pure, side-effect-free program comprising the following functions, modeled as mathematical functions over unsigned $32$-bit integers:\n- $g(x) \\triangleq x \\mathbin{\\} 0x\\mathrm{FF}$.\n- $h(z) \\triangleq g(z) \\mathbin{|} \\big((z \\gg 8) \\mathbin{\\} 0x\\mathrm{0F}\\big)$.\n- $f(p) \\triangleq \\big(\\big(g(p) + g(0x\\mathrm{1234})\\big) \\oplus h\\big(p \\mathbin{|} 0x\\mathrm{00F0}\\big)\\big) \\mathbin{\\} 0x\\mathrm{7F}$.\n\nThe entry point computes $f(0x\\mathrm{5600})$. Using only first principles about data-flow analysis and the semantics of the above operators, explain how interprocedural constant propagation discovers and folds constants across calls to $g$ and $h$, including the cross-procedural folding of $g(0x\\mathrm{1234})$ to $0x\\mathrm{34}$. Then, by fully applying these constant folds, determine the exact value returned by $f(0x\\mathrm{5600})$.\n\nExpress your final answer as an exact base-$10$ integer. No rounding is required.", "solution": "The problem requires an explanation of how interprocedural constant propagation (ICP) determines the value of $f(0x\\mathrm{5600})$ and the calculation of this value. The process involves tracking constant values across function boundaries and folding expressions whose operands are all constants.\n\nFirst, we will provide a brief overview of interprocedural constant propagation from first principles, as requested. ICP operates on a lattice of abstract values. For each variable, this lattice includes:\n- **$\\bot$ (Bottom):** Represents an undefined value or unreachable code. It is the least informative state.\n- **Constants ($c \\in \\mathbb{Z}$):** Specific integer values.\n- **$\\top$ (Top):** Represents a value that is not a single known constant (it is variable). It is the most general, least precise state for reachable code.\n\nThe analysis propagates these abstract values. When a function is called with constant arguments, the analysis can specialize its body, replacing parameters with these constants and evaluating (or \"folding\") expressions at compile time. If a function call is determined to always return a specific constant, the call itself can be replaced by that value. This replacement is the essence of interprocedural constant folding.\n\nNow, we apply this process to compute $f(0x\\mathrm{5600})$. The entry point is the expression $f(p)$ with the argument $p$ having the constant value $0x\\mathrm{5600}$. The definition of $f(p)$ is:\n$$f(p) \\triangleq \\big(\\big(g(p) + g(0x\\mathrm{1234})\\big) \\oplus h\\big(p \\mathbin{|} 0x\\mathrm{00F0}\\big)\\big) \\mathbin{\\} 0x\\mathrm{7F}$$\nSubstituting $p = 0x\\mathrm{5600}$ gives:\n$$f(0x\\mathrm{5600}) = \\big(\\big(g(0x\\mathrm{5600}) + g(0x\\mathrm{1234})\\big) \\oplus h\\big(0x\\mathrm{5600} \\mathbin{|} 0x\\mathrm{00F0}\\big)\\big) \\mathbin{\\} 0x\\mathrm{7F}$$\n\nThe analysis proceeds by evaluating sub-expressions that can be reduced to constants.\n\n1.  **Analyze the call $g(0x\\mathrm{1234})$**. The argument $0x\\mathrm{1234}$ is a constant. The compiler analyzes the body of $g(x) \\triangleq x \\mathbin{\\} 0x\\mathrm{FF}$ with $x = 0x\\mathrm{1234}$.\n    $$g(0x\\mathrm{1234}) = 0x\\mathrm{1234} \\mathbin{\\} 0x\\mathrm{FF}$$\n    In binary, this is $0001\\,0010\\,0011\\,0100_2 \\mathbin{\\} 1111\\,1111_2$, which yields $0011\\,0100_2$.\n    $$g(0x\\mathrm{1234}) = 0x\\mathrm{34}$$\n    ICP determines that $g(0x\\mathrm{1234})$ returns the constant $0x\\mathrm{34}$. This call is then folded, replacing $g(0x\\mathrm{1234})$ with $0x\\mathrm{34}$.\n\n2.  **Analyze the argument to $h$**. The argument is $p \\mathbin{|} 0x\\mathrm{00F0}$. Since $p$ is the constant $0x\\mathrm{5600}$, this expression can be folded.\n    $$0x\\mathrm{5600} \\mathbin{|} 0x\\mathrm{00F0} = 0101\\,0110\\,0000\\,0000_2 \\mathbin{|} 0000\\,0000\\,1111\\,0000_2 = 0101\\,0110\\,1111\\,0000_2 = 0x\\mathrm{56F0}$$\n    The call to $h$ becomes $h(0x\\mathrm{56F0})$.\n\n3.  The main expression for $f$ is now simplified to:\n    $$f(0x\\mathrm{5600}) = \\big(\\big(g(0x\\mathrm{5600}) + 0x\\mathrm{34}\\big) \\oplus h(0x\\mathrm{56F0})\\big) \\mathbin{\\} 0x\\mathrm{7F}$$\n\n4.  **Analyze the call $g(0x\\mathrm{5600})$**. The argument is the constant $0x\\mathrm{5600}$.\n    $$g(0x\\mathrm{5600}) = 0x\\mathrm{5600} \\mathbin{\\} 0x\\mathrm{FF} = 0x\\mathrm{00}$$\n    This call is folded to the constant $0x\\mathrm{00}$.\n\n5.  **Analyze the call $h(0x\\mathrm{56F0})$**. The argument is the constant $0x\\mathrm{56F0}$. The definition is $h(z) \\triangleq g(z) \\mathbin{|} \\big((z \\gg 8) \\mathbin{\\} 0x\\mathrm{0F}\\big)$. With $z=0x\\mathrm{56F0}$, this becomes:\n    $$h(0x\\mathrm{56F0}) = g(0x\\mathrm{56F0}) \\mathbin{|} \\big((0x\\mathrm{56F0} \\gg 8) \\mathbin{\\} 0x\\mathrm{0F}\\big)$$\n    This requires an inner analysis of $g(0x\\mathrm{56F0})$:\n    $$g(0x\\mathrm{56F0}) = 0x\\mathrm{56F0} \\mathbin{\\} 0x\\mathrm{FF} = 0x\\mathrm{F0}$$\n    And the other part of the expression is folded:\n    $$0x\\mathrm{56F0} \\gg 8 = 0x\\mathrm{56}$$\n    $$(0x\\mathrm{56F0} \\gg 8) \\mathbin{\\} 0x\\mathrm{0F} = 0x\\mathrm{56} \\mathbin{\\} 0x\\mathrm{0F} = 0101\\,0110_2 \\mathbin{\\} 0000\\,1111_2 = 0000\\,0110_2 = 0x\\mathrm{06}$$\n    Substituting these back into the expression for $h$:\n    $$h(0x\\mathrm{56F0}) = 0x\\mathrm{F0} \\mathbin{|} 0x\\mathrm{06} = 1111\\,0000_2 \\mathbin{|} 0000\\,0110_2 = 1111\\,0110_2 = 0x\\mathrm{F6}$$\n    The call $h(0x\\mathrm{56F0})$ is folded to the constant $0x\\mathrm{F6}$.\n\n6.  **Final Calculation**. All function calls have been folded to constants. We substitute these values back into the expression for $f(0x\\mathrm{5600})$:\n    $$f(0x\\mathrm{5600}) = \\big((0x\\mathrm{00} + 0x\\mathrm{34}) \\oplus 0x\\mathrm{F6}\\big) \\mathbin{\\} 0x\\mathrm{7F}$$\n    Now, we perform the final arithmetic and bitwise operations.\n    - Addition: $0x\\mathrm{00} + 0x\\mathrm{34} = 0x\\mathrm{34}$.\n    - Exclusive OR: $0x\\mathrm{34} \\oplus 0x\\mathrm{F6}$. In binary:\n      $0x\\mathrm{34} = 0011\\,0100_2$\n      $0x\\mathrm{F6} = 1111\\,0110_2$\n      $0x\\mathrm{34} \\oplus 0x\\mathrm{F6} = 1100\\,0010_2 = 0x\\mathrm{C2}$.\n    - Bitwise AND: $0x\\mathrm{C2} \\mathbin{\\} 0x\\mathrm{7F}$. In binary:\n      $0x\\mathrm{C2} = 1100\\,0010_2$\n      $0x\\mathrm{7F} = 0111\\,1111_2$\n      $0x\\mathrm{C2} \\mathbin{\\} 0x\\mathrm{7F} = 0100\\,0010_2 = 0x\\mathrm{42}$.\n\nThe final value is $0x\\mathrm{42}$. The problem requires the answer in base-$10$. We convert the hexadecimal result to decimal:\n$$0x\\mathrm{42} = 4 \\times 16^1 + 2 \\times 16^0 = 64 + 2 = 66$$\nThus, the value returned by $f(0x\\mathrm{5600})$ is $66$.", "answer": "$$\\boxed{66}$$", "id": "3648241"}, {"introduction": "Building on basic tracing, this problem introduces the crucial concept of context sensitivity. Real-world programs often call the same function with different arguments, leading to different behaviors. This exercise [@problem_id:3648314] demonstrates how a more precise analysis keeps track of these distinct call sites, preventing information from one call from incorrectly influencing another and thereby enabling more aggressive optimization.", "problem": "A language uses call-by-value with pure functions and supports default parameter values. Consider the following program, written in first-order, side-effect-free pseudo-code. If a call omits an actual argument for a formal parameter with a default, the calleeâ€™s formal takes the default. All arithmetic is over integers.\n\n- Function definitions:\n  - $\\;k(v)$:\n    - if $\\;v \\bmod 2 = 1\\;$ then return $\\;v\\;$ else return $\\;2 \\times v$.\n  - $\\;h(u)$:\n    - return $\\;u^{2} - 2u + 1$.\n  - $\\;g(x = 5)$:\n    - let $\\;y := x + 3$.\n    - if $\\;y  10\\;$ then let $\\;z := y \\times 2\\;$ else let $\\;z := y - 4$.\n    - return $\\;h(z) + k(x)$.\n\n- Main:\n  - let $\\;a := g()$.\n  - let $\\;b := g(7)$.\n  - let $\\;c := a + 2 \\times b$.\n  - output $\\;c$.\n\nUsing interprocedural constant propagation with per-call-site context sensitivity over the interprocedural control flow graph (ICFG), and the standard constant propagation lattice with elements $\\;\\{\\bot\\;\\} \\cup \\mathbb{Z} \\cup \\{\\top\\;\\}$ ordered by $\\;\\bot \\sqsubseteq n \\sqsubseteq \\top\\;$ for any integer $\\;n$, propagate constants from actual arguments (including the default binding in the call $\\;g()$) into the body of $\\;g$ and then into $\\;h$ and $\\;k$, and perform constant folding wherever the lattice value is a known integer. Assume no aliasing, no exceptions, and that the control flow graph (CFG) has only the branches shown.\n\nWhat is the exact value computed for $\\;c\\;$ at runtime after fully applying interprocedural constant propagation and constant folding as described? Give your answer as an exact integer with no rounding.", "solution": "The objective is to determine the value of the variable $c$ after applying interprocedural constant propagation and constant folding. The analysis will proceed by simulating this optimization technique on the provided pseudo-code. The technique requires analyzing each function call in its specific context, which is defined by the constant values of its actual arguments at a particular call site.\n\nThe main program contains three sequential assignments:\n1. `let a := g()`\n2. `let b := g(7)`\n3. `let c := a + 2 * b`\n\nWe will analyze each assignment in order.\n\n**1. Analysis of `let a := g()`**\n\nThis statement involves a call to the function $g$ without an explicit argument. According to the problem description, the default parameter value is used. Therefore, for this call site, the formal parameter $x$ of function $g$ is bound to the constant value $5$. We now analyze the body of $g$ with $x=5$.\n\n- **`let y := x + 3`**: With $x=5$, this expression is constant-folded to $y := 5 + 3$, which yields $y=8$.\n- **`if y  10`**: The condition becomes $8  10$, which evaluates to true. The analysis proceeds along the `then` branch.\n- **`let z := y \\times 2`**: With $y=8$, this expression is constant-folded to $z := 8 \\times 2$, yielding $z=16$.\n- **`return h(z) + k(x)`**: The return expression involves two function calls. We analyze each one with the propagated constant values for their arguments.\n  - **Call to `h(z)`**: This becomes a call to $h(16)$, as $z=16$.\n    - In the body of $h(u)$, the formal parameter $u$ is bound to $16$.\n    - The return expression is `u^2 - 2u + 1`. This can be simplified to $(u-1)^2$.\n    - Substituting $u=16$, we get $(16-1)^2 = 15^2 = 225$.\n    - The call $h(16)$ returns the constant value $225$.\n  - **Call to `k(x)`**: This becomes a call to $k(5)$, as $x=5$.\n    - In the body of $k(v)$, the formal parameter $v$ is bound to $5$.\n    - The condition is `v mod 2 = 1`. Substituting $v=5$, we get $5 \\bmod 2 = 1$, which is true.\n    - The `then` branch is taken, which is `return v`.\n    - The call $k(5)$ returns the constant value $5$.\n- **Final return value of `g()`**: The expression `h(z) + k(x)` is evaluated with the returned constants: $225 + 5 = 230$.\n\nTherefore, after interprocedural constant propagation and folding, the assignment `let a := g()` is effectively transformed into `let a := 230`.\n\n**2. Analysis of `let b := g(7)`**\n\nThis statement involves a call to the function $g$ with the explicit argument $7$. For this call site, the formal parameter $x$ is bound to the constant value $7$. We analyze the body of $g$ with $x=7$.\n\n- **`let y := x + 3`**: With $x=7$, this expression is constant-folded to $y := 7 + 3$, which yields $y=10$.\n- **`if y  10`**: The condition becomes $10  10$, which evaluates to false. The analysis proceeds along the `else` branch.\n- **`let z := y - 4`**: With $y=10$, this expression is constant-folded to $z := 10 - 4$, yielding $z=6$.\n- **`return h(z) + k(x)`**: We analyze the function calls with the new propagated constants.\n  - **Call to `h(z)`**: This becomes a call to $h(6)$, as $z=6$.\n    - In the body of $h(u)$, $u$ is bound to $6$.\n    - The return expression $(u-1)^2$ becomes $(6-1)^2 = 5^2 = 25$.\n    - The call $h(6)$ returns the constant value $25$.\n  - **Call to `k(x)`**: This becomes a call to $k(7)$, as $x=7$.\n    - In the body of $k(v)$, $v$ is bound to $7$.\n    - The condition `v mod 2 = 1` becomes $7 \\bmod 2 = 1$, which is true.\n    - The `then` branch is taken, returning $v$.\n    - The call $k(7)$ returns the constant value $7$.\n- **Final return value of `g(7)`**: The expression `h(z) + k(x)` is evaluated with the returned constants: $25 + 7 = 32$.\n\nTherefore, the assignment `let b := g(7)` is effectively transformed into `let b := 32$.\n\n**3. Analysis of `let c := a + 2 * b`**\n\nAt this point in the program, the optimizer has determined that $a=230$ and $b=32$. The final assignment can be constant-folded.\n\n- **`let c := a + 2 * b`**: Substituting the constant values for $a$ and $b$, we get `c := 230 + 2 * 32`.\n- Following the order of operations, the multiplication is performed first: $2 \\times 32 = 64$.\n- The expression becomes `c := 230 + 64`.\n- The final addition gives $c := 294$.\n\nThe value computed for $c$ at runtime after these optimizations is $294$.", "answer": "$$\\boxed{294}$$", "id": "3648314"}, {"introduction": "The true power of interprocedural analysis lies in its ability to optimize code across module boundaries and enable other transformations. This practice [@problem_id:3648217] explores the use of function summaries, which encapsulate the behavior of a function without needing its source code. You will see how a summary, combined with constant propagation, can prove a conditional branch is unreachable, allowing the compiler to perform dead code elimination.", "problem": "Consider an interprocedural constant propagation analysis over integer variables using the classic constant propagation lattice. The lattice for a single variable is defined as $D = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$, where $\\bot$ denotes no information, each $c \\in \\mathbb{Z}$ denotes the constant $c$, and $\\top$ denotes conflicting or unknown information. The partial order is given by $\\bot \\leq c \\leq \\top$ for any $c \\in \\mathbb{Z}$, with $\\bot \\leq \\top$ and $c \\leq \\top$ for all $c \\in \\mathbb{Z}$. The join operator is defined pointwise over environments, and for a single variable $v$ is: $c \\sqcup c = c$, $c \\sqcup c' = \\top$ for $c \\neq c'$, $c \\sqcup \\bot = c$, $c \\sqcup \\top = \\top$, and symmetrically for other cases. Transfer functions for assignments and arithmetic are the standard ones for constant propagation (for example, for an assignment $v := n$ with $n \\in \\mathbb{Z}$, the transfer sets $v$ to $n$; for a binary operation $v := a \\,\\text{op}\\, b$, the transfer sets $v$ to the evaluated constant if both $a$ and $b$ are constants, otherwise to $\\top$).\n\nYou are given the following two procedures over integers:\n- Procedure $g$ takes an integer input $y$ and returns an integer. The body of $g$ is unknown to the analysis, but it has a summary $S_{g}$ that is sound and precise enough to guarantee the following property: $S_{g}$ asserts $g(2) \\neq 0$.\n- Procedure $f$ is defined as follows (in pseudocode, with all integer literals as mathematical constants):\n  1. Let $r := 9$.\n  2. If $g(x) = 0$ then set $r := x + 7$.\n  3. Return $r$.\n\nAssume the interprocedural constant propagation analysis is context-sensitive at the level of argument values and uses $S_{g}$ when analyzing calls to $g$. The analysis is run starting from an initial environment in which at the call site to $f$ we have $x = 2$ as a constant, that is, the input environment maps $x$ to $2$.\n\nUsing the lattice and transfer semantics described above as the fundamental base, determine the constant deduced by the analysis for the value of $r$ at the exit of procedure $f$ when $x = 2$ and the summary $S_{g}$ holds. Provide your final result as a single integer. No rounding is needed. Express the answer as a pure number without any units.", "solution": "The task is to determine the constant value deduced for the variable $r$ at the exit of procedure $f$, given the analysis starts with the information that the input $x$ is the constant $2$.\n\nLet the environment (or abstract state) be a map from variables to values in the lattice $D$. The analysis proceeds as follows:\n\n1.  **Entry to procedure $f$:** The analysis is context-sensitive and is being performed for a call to $f$ where the argument $x$ is known to be $2$. The initial environment at the start of $f$ is $\\sigma_{0} = \\{x \\to 2\\}$. All other local variables, such as $r$, are implicitly at $\\bot$.\n\n2.  **Analysis of line 1: `Let r := 9.`**\n    This is a constant assignment. The transfer function for this statement updates the environment. The value of $r$ is set to the constant $9$. The environment becomes:\n    $$ \\sigma_{1} = \\sigma_{0}[r \\to 9] = \\{x \\to 2, r \\to 9\\} $$\n\n3.  **Analysis of line 2: `If g(x) = 0 then set r := x + 7.`**\n    The analysis must evaluate the branch condition `g(x) = 0`.\n    -   From the environment $\\sigma_1$, the analysis knows that $x$ is the constant $2$. Therefore, the function call is effectively $g(2)$.\n    -   The problem states that the analysis uses the summary $S_{g}$ for the procedure $g$. The summary $S_{g}$ asserts that $g(2) \\neq 0$.\n    -   This means that for the specific context where $x=2$, the condition `g(x) = 0` is guaranteed to evaluate to **false**.\n    -   A sound static analysis can use this information to determine that the `then` branch of the conditional statement is an infeasible path. This path will never be executed when $x=2$.\n\n4.  **Control Flow and State Merging:**\n    The analysis deduces that control flow will always bypass the `then` block and proceed along the implicit `else` path.\n    -   **State from the `then` branch:** Since this path is unreachable, it contributes no information to the state after the conditional. In the data-flow framework, its output state can be considered the bottom element for all variables, $\\sigma_{then} = \\{x \\to \\bot, r \\to \\bot\\}$, representing that no execution flow reaches this point.\n    -   **State from the `else` branch:** The `else` branch is taken. The environment entering this path is $\\sigma_1 = \\{x \\to 2, r \\to 9\\}$. The implicit `else` block contains no statements, so the environment leaving this path is unchanged: $\\sigma_{else} = \\sigma_1 = \\{x \\to 2, r \\to 9\\}$.\n    -   The environment at the program point immediately following the `if-then` statement is the join of the environments from all incoming control-flow paths (the `then` and `else` branches).\n    $$ \\sigma_{2} = \\sigma_{then} \\sqcup \\sigma_{else} $$\n    We perform the join pointwise for each variable:\n    -   For $x$: $\\sigma_2(x) = \\sigma_{then}(x) \\sqcup \\sigma_{else}(x) = \\bot \\sqcup 2 = 2$.\n    -   For $r$: $\\sigma_2(r) = \\sigma_{then}(r) \\sqcup \\sigma_{else}(r) = \\bot \\sqcup 9 = 9$.\n    Thus, the environment after the conditional statement is $\\sigma_{2} = \\{x \\to 2, r \\to 9\\}$. The value of $r$ remains $9$.\n\n5.  **Analysis of line 3: `Return r.`**\n    The procedure returns the value of the variable $r$. At this point, the analysis has determined that the value of $r$ in the current environment $\\sigma_2$ is the constant $9$.\n\nTherefore, the interprocedural constant propagation analysis deduces that for an input of $x=2$, the value of $r$ at the exit of procedure $f$ is the constant $9$.", "answer": "$$\\boxed{9}$$", "id": "3648217"}]}