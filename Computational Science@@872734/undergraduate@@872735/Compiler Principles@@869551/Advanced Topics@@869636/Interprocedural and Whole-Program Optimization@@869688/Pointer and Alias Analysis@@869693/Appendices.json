{"hands_on_practices": [{"introduction": "This first exercise provides a foundational workout in flow-sensitive pointer analysis. By tracing a simple sequence of assignments step-by-step, you will construct the points-to graph and see how it evolves. This practice will solidify your understanding of how a compiler can definitively prove that two pointers refer to the same memory location, a concept known as a must-alias relation [@problem_id:3662990].", "problem": "Consider a straight-line program fragment with three pointer variables and two distinct stack-allocated integer locations. The statements, executed in order, are:\nStatement $s_{1}$: `p = x;`\nStatement $s_{2}$: `q = p;`\nStatement $s_{3}$: `r = x;`\nStatement $s_{4}$: `p = y;`\n\nAssume a flow-sensitive, context-insensitive pointer analysis that performs strong updates on pointer variables and models each stack-allocated scalar as a unique abstract location. The language has standard address-of semantics: the operator `` yields the address of a scalar, pointer assignment copies the referenced address value, and there are no aliases to the variables $p$, $q$, $r$ themselves (i.e., no pointers-to-pointers), no interference from concurrency, and no function calls.\n\nStarting from the foundational definitions that the points-to set $PT(v)$ of a pointer variable $v$ at a program point is the set of abstract locations that $v$ may denote at that point, and that two pointers $a$ and $b$ are in a must-alias relation at a program point if, in all possible executions reaching that point, $a$ and $b$ denote the same single abstract location, construct the points-to graph after each statement and determine, immediately after Statement $s_{4}$, the number of unordered pointer pairs among $\\{p, q, r\\}$ that are in a must-alias relation. Provide your final answer as an integer with no units and do not round.", "solution": "The problem requires us to perform a flow-sensitive pointer analysis on a given program fragment and determine the number of must-alias pointer pairs at the end of the execution.\n\nLet us first formalize the model as described. We have two distinct stack-allocated scalar variables, $x$ and $y$. In the abstract memory model for the analysis, these correspond to two unique abstract locations, which we will denote as $l_x$ and $l_y$, respectively. We have three pointer variables: $p$, $q$, and $r$. The state of our analysis at any program point is the set of points-to sets for each of these pointers: $(PT(p), PT(q), PT(r))$. The points-to set $PT(v)$ for a pointer $v$ contains the abstract locations that $v$ might point to.\n\nThe analysis is flow-sensitive, meaning we compute the points-to information for each program point, taking into account the order of statements. It employs strong updates, meaning that an assignment to a pointer variable $v$ kills the previous points-to information for $v$. This is permissible because there are no pointers to $p$, $q$, or $r$ themselves.\n\nWe begin with the initial state before statement $s_1$, where the pointers are uninitialized. Their points-to sets are empty. Let $PT_k(v)$ denote the points-to set of variable $v$ after statement $s_k$.\n\nInitial State (before $s_1$):\n$PT_0(p) = \\emptyset$\n$PT_0(q) = \\emptyset$\n$PT_0(r) = \\emptyset$\n\nNow, we trace the effect of each statement in sequence.\n\nAfter Statement $s_1$: `p = x;`\nThis statement assigns the address of the scalar variable $x$ to the pointer $p$. In our abstract model, this means $p$ now points to the abstract location $l_x$. The analysis performs a strong update, so the previous points-to set for $p$ is discarded and replaced.\n$PT_1(p) = \\{l_x\\}$\nThe other pointers are unaffected.\n$PT_1(q) = PT_0(q) = \\emptyset$\n$PT_1(r) = PT_0(r) = \\emptyset$\nThe points-to graph after $s_1$ consists of a single edge from $p$ to $l_x$.\n\nAfter Statement $s_2$: `q = p;`\nThis statement assigns the value of pointer $p$ to pointer $q$. In a pointer analysis context, this means $q$ now points to whatever $p$ points to. The information flows from $p$ to $q$.\nThe points-to set for $q$ becomes a copy of the points-to set for $p$.\n$PT_2(q) = PT_1(p) = \\{l_x\\}$\nThe other pointers are unaffected in this step.\n$PT_2(p) = PT_1(p) = \\{l_x\\}$\n$PT_2(r) = PT_1(r) = \\emptyset$\nThe points-to graph after $s_2$ has two edges: one from $p$ to $l_x$ and another from $q$ to $l_x$.\n\nAfter Statement $s_3$: `r = x;`\nThis statement assigns the address of the scalar variable $x$ to the pointer $r$. This is similar to statement $s_1$. The pointer $r$ now points to the abstract location $l_x$.\n$PT_3(r) = \\{l_x\\}$\nThe other pointers are unaffected.\n$PT_3(p) = PT_2(p) = \\{l_x\\}$\n$PT_3(q) = PT_2(q) = \\{l_x\\}$\nAfter $s_3$, all three pointers $p$, $q$, and $r$ point to the same abstract location $l_x$. The points-to graph has three edges, all directed to $l_x$.\n\nAfter Statement $s_4$: `p = y;`\nThis statement assigns the address of the scalar variable $y$ to the pointer $p$. This corresponds to the abstract location $l_y$. The analysis performs a strong update on $p$, so its previous points-to information (pointing to $l_x$) is killed and replaced.\n$PT_4(p) = \\{l_y\\}$\nThe points-to sets for $q$ and $r$ are unchanged by this statement.\n$PT_4(q) = PT_3(q) = \\{l_x\\}$\n$PT_4(r) = PT_3(r) = \\{l_x\\}$\nThis is the final state of the points-to sets after the entire program fragment has been executed.\n\nNow, we must determine the number of unordered pairs among $\\{p, q, r\\}$ that are in a must-alias relation.\nThe definition of a must-alias relation between two pointers $a$ and $b$ is that in all possible executions, they are guaranteed to point to the same single abstract location. Formally, this requires three conditions to be met at the specific program point:\n1. The points-to set of $a$ must be a singleton: $|PT(a)| = 1$.\n2. The points-to set of $b$ must be a singleton: $|PT(b)| = 1$.\n3. The two singleton sets must be identical: $PT(a) = PT(b)$.\n\nLet's examine the three unordered pairs using the final points-to sets:\n- $PT_4(p) = \\{l_y\\}$\n- $PT_4(q) = \\{l_x\\}$\n- $PT_4(r) = \\{l_x\\}$\n\nPair 1: $(p, q)$\n$|PT_4(p)| = |\\{l_y\\}| = 1$.\n$|PT_4(q)| = |\\{l_x\\}| = 1$.\nHowever, $PT_4(p) = \\{l_y\\} \\neq \\{l_x\\} = PT_4(q)$.\nTherefore, $p$ and $q$ are not in a must-alias relation. They are in a must-not-alias relation, as they are guaranteed to point to different locations.\n\nPair 2: $(p, r)$\n$|PT_4(p)| = |\\{l_y\\}| = 1$.\n$|PT_4(r)| = |\\{l_x\\}| = 1$.\nHowever, $PT_4(p) = \\{l_y\\} \\neq \\{l_x\\} = PT_4(r)$.\nTherefore, $p$ and $r$ are not in a must-alias relation.\n\nPair 3: $(q, r)$\n$|PT_4(q)| = |\\{l_x\\}| = 1$.\n$|PT_4(r)| = |\\{l_x\\}| = 1$.\nAnd, $PT_4(q) = \\{l_x\\} = PT_4(r)$.\nAll three conditions for a must-alias relation are satisfied.\nTherefore, $q$ and $r$ are in a must-alias relation.\n\nCounting the number of unordered pointer pairs in a must-alias relation, we find there is exactly one such pair: $(q, r)$.\nThe final answer is $1$.", "answer": "$$\\boxed{1}$$", "id": "3662990"}, {"introduction": "Real-world programs often involve multiple levels of indirection, such as pointers to other pointers. This next practice challenges you to analyze such a scenario, where an assignment through a double pointer, `**pp`, indirectly modifies the target of another pointer, `$p$`. Mastering this concept is essential for correctly analyzing programs that pass pointers by reference or use complex dynamic data structures [@problem_id:3663003].", "problem": "You are analyzing a C-like program fragment at the level of static pointer and alias analysis. Consider four distinct scalar locations with disjoint addresses: two integer variables $x$ and $y$, one pointer to integer $p$, and one pointer to pointer to integer $pp$. Assume a flow-sensitive, path-insensitive, context-insensitive, field-insensitive, may-points-to analysis with strong updates on singleton abstract locations. The program executes the following sequence of statements in order, starting from an uninitialized state where no points-to information is known:\n- `p := x;`\n- `pp := p;`\n- `*pp := y;`\n- `*p := 3;`\n\nStarting from the foundational definitions of the points-to relation and the operational meaning of assignments and indirect stores in a C-like language, derive:\n1. The final memory target (that is, the specific scalar location) written by the last statement `*p := 3;`.\n2. The final points-to sets $\\operatorname{Pts}(p)$ and $\\operatorname{Pts}(pp)$ at the end of the sequence, where for a pointer variable $v$, $\\operatorname{Pts}(v)$ is the set of abstract locations that $v$ may point to.\n\nLet $R$ be the integer defined by\n$$\nR \\;=\\; |\\operatorname{Pts}(p)| \\;+\\; 2\\,|\\operatorname{Pts}(pp)| \\;+\\; v,\n$$\nwhere $|\\,\\cdot\\,|$ denotes set cardinality and $v$ is the value written by the last store `*p := 3;`. Compute $R$. Express your final answer as an integer. No rounding is required.", "solution": "The problem requires a flow-sensitive, path-insensitive, may-points-to analysis of a sequence of C-like statements. We will trace the state of the points-to sets for the pointers $p$ and $pp$ through each statement. Let the distinct abstract memory locations for the variables $x$, $y$, $p$, and $pp$ be denoted by $l_x$, $l_y$, $l_p$, and $l_{pp}$, respectively. The points-to set for a pointer variable $v$ will be denoted by $\\operatorname{Pts}(v)$. The analysis is specified to perform strong updates when the pointer being dereferenced on the left-hand side of an assignment points to a singleton abstract location.\n\nInitial State:\nThe program begins in an uninitialized state where no points-to information is known.\nLet $\\operatorname{Pts}_i(v)$ be the points-to set of $v$ after statement $i$.\nThe state before the first statement is:\n$$ \\operatorname{Pts}_{0}(p) = \\emptyset $$\n$$ \\operatorname{Pts}_{0}(pp) = \\emptyset $$\n\nStatement 1: `p := x;`\nThis is a direct address-of assignment. The pointer $p$ is assigned the address of the variable $x$. The analysis updates the points-to set of $p$ to include the location of $x$. The old set is discarded, and the new set is $\\{l_x\\}$.\n$$ \\operatorname{Pts}_{1}(p) = \\{l_x\\} $$\n$$ \\operatorname{Pts}_{1}(pp) = \\operatorname{Pts}_{0}(pp) = \\emptyset $$\n\nStatement 2: `pp := p;`\nThis is another direct address-of assignment. The pointer $pp$ is assigned the address of the pointer variable $p$. The analysis updates the points-to set of $pp$ to include the location of $p$.\nThe points-to set for $p$ remains unchanged.\n$$ \\operatorname{Pts}_{2}(p) = \\operatorname{Pts}_{1}(p) = \\{l_x\\} $$\n$$ \\operatorname{Pts}_{2}(pp) = \\{l_p\\} $$\n\nStatement 3: `*pp := y;`\nThis is an indirect assignment, also known as a store through a pointer. The variable on the left-hand side is an indirection, `*pp`. To determine which location is modified, we must examine the points-to set of $pp$.\nFrom the previous step, $\\operatorname{Pts}_{2}(pp) = \\{l_p\\}$.\nThis is a singleton set, containing only the abstract location $l_p$. The problem specifies that strong updates are performed on singleton abstract locations. A strong update means that the existing information at the target location is killed (removed) and replaced by the new information from the right-hand side of the assignment.\nThe target of the update is the location pointed to by $pp$, which is $l_p$. The variable $p$ resides at location $l_p$. Therefore, this statement modifies the pointer $p$ itself.\nThe right-hand side is `y`, which represents the address of variable $y$.\nThus, the effect of the statement is to change what $p$ points to. The old points-to set of $p$, which was $\\{l_x\\}$, is killed and replaced by a new set containing $l_y$.\nThe points-to set for $pp$ is not affected by this operation.\n$$ \\operatorname{Pts}_{3}(p) = \\{l_y\\} $$\n$$ \\operatorname{Pts}_{3}(pp) = \\operatorname{Pts}_{2}(pp) = \\{l_p\\} $$\n\nStatement 4: `*p := 3;`\nThis is another indirect assignment, storing the integer value $3$. To determine the memory target, we examine the points-to set of $p$.\nFrom the previous step, $\\operatorname{Pts}_{3}(p) = \\{l_y\\}$.\nThis is also a singleton set. The single location pointed to by $p$ is $l_y$, which is the abstract location corresponding to the scalar integer variable $y$.\nTherefore, the statement writes the value $3$ into the memory location for $y$.\nThis operation modifies the value of a scalar variable ($y$), not a pointer. Thus, the points-to sets for $p$ and $pp$ remain unchanged.\n\nThe state after the final statement is:\n$$ \\operatorname{Pts}_{\\text{final}}(p) = \\operatorname{Pts}_{3}(p) = \\{l_y\\} $$\n$$ \\operatorname{Pts}_{\\text{final}}(pp) = \\operatorname{Pts}_{3}(pp) = \\{l_p\\} $$\n\nWe can now address the specific questions posed.\n\n1. The final memory target written by the last statement `*p := 3;`:\nAs derived above, the pointer $p$ points exclusively to the location $l_y$. Therefore, the store operation `*p := 3` writes to the location $l_y$, which corresponds to the scalar variable $y$.\n\n2. The final points-to sets $\\operatorname{Pts}(p)$ and $\\operatorname{Pts}(pp)$:\nThe final points-to sets are:\n$$ \\operatorname{Pts}(p) = \\{l_y\\} $$\n$$ \\operatorname{Pts}(pp) = \\{l_p\\} $$\n\nNow, we must compute the value of $R$. The formula is given as:\n$$ R = |\\operatorname{Pts}(p)| + 2\\,|\\operatorname{Pts}(pp)| + v $$\nThe components of this formula are:\n- $|\\operatorname{Pts}(p)|$: The cardinality of the final points-to set of $p$. Since $\\operatorname{Pts}(p) = \\{l_y\\}$, its cardinality is $1$.\n$$ |\\operatorname{Pts}(p)| = 1 $$\n- $|\\operatorname{Pts}(pp)|$: The cardinality of the final points-to set of $pp$. Since $\\operatorname{Pts}(pp) = \\{l_p\\}$, its cardinality is $1$.\n$$ |\\operatorname{Pts}(pp)| = 1 $$\n- $v$: The value written by the last store, `*p := 3;`. The value written is $3$.\n$$ v = 3 $$\n\nSubstituting these values into the expression for $R$:\n$$ R = 1 + 2 \\times 1 + 3 $$\n$$ R = 1 + 2 + 3 $$\n$$ R = 6 $$", "answer": "$$\\boxed{6}$$", "id": "3663003"}, {"introduction": "Pointer analysis is not just an academic exercise; it is a critical enabler for many compiler optimizations. This final problem demonstrates the interplay between alias analysis and constant propagation by examining a store through a pointer $q$ whose target is uncertain due to control flow. You will see firsthand how a *may-alias* situation forces a compiler to be conservative, ultimately preventing an optimization from being applied [@problem_id:3662967].", "problem": "You are given the following C code fragment executed in a single procedure without function calls and with no undefined behavior:\n```c\nint x = 1;\nint y = 2;\nint *p = x;\nint *q = p ? y : x;\n*q = 5;\n```\n\nAssume a standard conservative pointer analysis that is flow-insensitive and context-insensitive, using a may-points-to interpretation. The analysis does not evaluate the conditional expression using constant reasoning; it treats both outcomes of the conditional as potentially executable. Let the may-points-to set for a pointer variable $v$ be denoted by $\\text{PT}(v)$ and let $|\\text{PT}(v)|$ be its cardinality. For constant propagation, use Sparse Conditional Constant Propagation (SCCP), whose value lattice is $\\mathcal{L} = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$, where $\\bot$ denotes unreachable, every integer in $\\mathbb{Z}$ denotes a known constant, and $\\top$ denotes an unknown non-constant value. When a store via a pointer may alias multiple variables, model the effect by updating all targets in the may-points-to set; if a store may write multiple distinct values along different paths, represent the merged result using the lattice join.\n\nStarting from the fundamental semantics that the C conditional operator evaluates its first operand as a Boolean and selects one of two pointer expressions, define and compute:\n- The cardinality $|\\text{PT}(q)|$ under the specified may-points-to analysis.\n- The SCCP lattice values of $x$ and $y$ at the end of the fragment, denoted $V_{x}$ and $V_{y}$, respectively, given the specified interaction between pointer analysis and SCCP.\n\nExpress your final answer as a single row matrix $\\begin{pmatrix} |\\text{PT}(q)|  V_{x}  V_{y} \\end{pmatrix}$. No rounding is required and no physical units are involved. Use the symbols $\\top$ and $\\bot$ from the lattice definition as needed, and integers for known constant values.", "solution": "The problem requires an analysis of a C code fragment using specified models for pointer analysis and constant propagation. We must determine the cardinality of the may-points-to set for the pointer `q`, denoted $|\\text{PT}(q)|$, and the final lattice values for the variables `x` and `y` under Sparse Conditional Constant Propagation (SCCP), denoted $V_x$ and $V_y$.\n\nFirst, we perform the may-points-to analysis as specified. The analysis is flow-insensitive, context-insensitive, and must treat both outcomes of the conditional operator as potentially executable. A flow-insensitive analysis computes a single points-to map for the entire procedure, aggregating the effects of all assignment statements regardless of control flow.\n\nThe statements relevant to pointer analysis are:\n1.  `int *p = x;`\n2.  `int *q = p ? y : x;`\n\nFrom statement 1, the pointer `p` is assigned the address of `x`. This creates a points-to relationship, which we can write as `p → x`. In terms of sets, this means $x \\in \\text{PT}(p)$. For a flow-insensitive analysis considering the entire procedure, we can establish that $\\text{PT}(p) = \\{x\\}$.\n\nFrom statement 2, the pointer `q` is assigned a value based on a conditional expression. The problem explicitly states that the analysis does not use constant reasoning to evaluate the condition `p`. Instead, it must assume both the true and false branches are executable.\n-   If the condition were true, the assignment would be `q = y;`, leading to the relation `q → y`.\n-   If the condition were false, the assignment would be `q = x;`, leading to the relation `q → x`.\n\nA conservative, flow-insensitive may-points-to analysis collects all possible targets from all possible assignments. Therefore, the may-points-to set for `q` is the union of the targets from both branches: $\\text{PT}(q) = \\{x\\} \\cup \\{y\\} = \\{x, y\\}$.\n\nThe cardinality of this set is the number of distinct variables it may point to.\n$$|\\text{PT}(q)| = |\\{x, y\\}| = 2$$\n\nNext, we perform Sparse Conditional Constant Propagation (SCCP) to determine the final values of `x` and `y`. The SCCP analysis uses the value lattice $\\mathcal{L} = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$. The analysis proceeds by simulating the program's execution on this lattice, using the results of the pre-computed pointer analysis.\n\nLet $V_x$ and $V_y$ be the lattice values for variables `x` and `y`, respectively. We trace their values through the program:\n1.  `int x = 1;`\n    This statement initializes `x` with a constant value. The lattice value for `x` becomes $1$.\n    $V_x \\leftarrow 1$.\n\n2.  `int y = 2;`\n    Similarly, this initializes `y` with the constant value $2$.\n    $V_y \\leftarrow 2$.\n    At this point, we have $V_x = 1$ and $V_y = 2$.\n\n3.  `int *p = x;`\n    This statement assigns a pointer value and does not modify the integer variables `x` or `y`. Their lattice values remain unchanged.\n\n4.  `int *q = p ? y : x;`\n    This statement also assigns a pointer value and does not modify `x` or `y`. Their lattice values remain $V_x = 1$ and $V_y = 2$.\n\n5.  `*q = 5;`\n    This is a store operation through the pointer `q`. The SCCP analysis must consult the results of the pointer analysis to determine the effect of this store. We have already determined that $\\text{PT}(q) = \\{x, y\\}$. This means the store operation may modify either `x` or `y`.\n\n    The problem provides the rule for this scenario: \"When a store via a pointer may alias multiple variables, model the effect by updating all targets in the may-points-to set\". This is interpreted as a \"weak update\" for each variable in the points-to set. A weak update on a variable `v` from a store of value `C` means its new lattice value becomes the join of its old value and `C`. The join operation, denoted by `sqcup`, is defined for the lattice as follows:\n    -   $a \\sqcup b = b \\sqcup a$ (commutative)\n    -   $C \\sqcup C = C$ for any constant $C \\in \\mathbb{Z}$.\n    -   $C_1 \\sqcup C_2 = \\top$ for any distinct constants $C_1, C_2 \\in \\mathbb{Z}$.\n    -   $v \\sqcup \\top = \\top$ for any value $v \\in \\mathcal{L}$.\n    -   $v \\sqcup \\bot = v$ for any value $v \\in \\mathcal{L}$.\n\n    We apply this update rule to both `x` and `y`.\n    -   For `x`: The current value is $V_x = 1$. The new value is $V_x^{\\text{new}} = V_x \\sqcup 5 = 1 \\sqcup 5$. Since $1$ and $5$ are distinct constants, their join is $\\top$.\n      $$V_x \\leftarrow \\top$$\n    -   For `y`: The current value is $V_y = 2$. The new value is $V_y^{\\text{new}} = V_y \\sqcup 5 = 2 \\sqcup 5$. Since $2$ and $5$ are distinct constants, their join is also $\\top$.\n      $$V_y \\leftarrow \\top$$\n\nAfter this final statement, the lattice values for `x` and `y` are both $\\top$, indicating that the analysis can no longer guarantee they hold a specific constant value.\n\nIn summary, the results of the analyses are:\n-   $|\\text{PT}(q)| = 2$\n-   $V_x = \\top$\n-   $V_y = \\top$", "answer": "$$\\boxed{\\begin{pmatrix} 2  \\top  \\top \\end{pmatrix}}$$", "id": "3662967"}]}