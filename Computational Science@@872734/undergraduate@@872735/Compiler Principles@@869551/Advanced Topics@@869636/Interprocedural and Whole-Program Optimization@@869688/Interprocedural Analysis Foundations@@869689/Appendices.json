{"hands_on_practices": [{"introduction": "A cornerstone of interprocedural analysis is creating a \"summary\" of what each function does, so we don't have to re-analyze its body at every call site. This exercise [@problem_id:3647898] walks you through one of the most fundamental summarization techniques: Mod-Ref analysis. By systematically calculating which global variables a function might modify ($\\mathrm{Mod}$) or read ($\\mathrm{Ref}$), you'll gain hands-on practice in propagating information up the call graph and applying the results to a crucial task: determining function purity.", "problem": "You are given a small library of functions over integers designed to study interprocedural analysis foundations. The program has global symbols partitioned as follows:\n- Mutable globals: $G_a$, $G_b$.\n- Read-only constants: $C_a$, $C_b$.\n- A pseudo-global $I$ that summarizes all Input/Output (I/O) effects.\n\nThe following functions are defined (all arithmetic is pure integer arithmetic and terminates):\n- $f_1(x)$: returns $x + C_a$.\n- $f_2(x)$: assigns $G_a := G_a + 1$ and returns $x$.\n- $f_3(x)$: computes $t := f_1(x)$ and returns $t + C_b$.\n- $f_4(x)$: if $x$ is odd, assigns $G_b := x$; in all cases returns $f_2(x)$.\n- $f_5(x)$: returns $f_3(x) + f_1(0)$.\n- $f_6(x)$: reads the current value of $G_b$ and returns $x + G_b$.\n- $f_7(x)$: performs a $print(x)$ (modeled as an I/O effect) and returns $x$.\n- $f_8(x)$: returns $f_5(x) + f_6(0) - f_2(0)$.\n\nAssume a whole-program, context-insensitive, flow-insensitive mod-ref analysis. For each function $f$, the analysis computes two sets: $\\mathrm{Mod}(f)$, the set of globals that $f$ may write, and $\\mathrm{Ref}(f)$, the set of globals that $f$ may read. The sets are defined by these foundational rules:\n- If the body of $f$ directly writes a global $g$, then $g \\in \\mathrm{Mod}(f)$; if it directly reads a global $g$, then $g \\in \\mathrm{Ref}(f)$.\n- If $f$ calls a function $h$, then $\\mathrm{Mod}(h) \\subseteq \\mathrm{Mod}(f)$ and $\\mathrm{Ref}(h) \\subseteq \\mathrm{Ref}(f)$.\n- For conditional control flow, the analysis takes set unions across branches (flow-insensitivity).\n- The built-in $print$ is modeled as $\\mathrm{Mod}(\\text{print}) = \\{I\\}$ and $\\mathrm{Ref}(\\text{print}) = \\varnothing$.\n- A function $f$ is considered pure if and only if $\\mathrm{Mod}(f) = \\varnothing$ and $\\mathrm{Ref}(f) \\subseteq \\{C_a, C_b\\}$; that is, it does not write any mutable global or $I$, and it reads only read-only constants.\n\nDefine the composition of two functions $f$ and $g$ on argument $x$ as $(f \\circ g)(x) = f(g(x))$.\n\nTask:\n- Using only the above definitions, infer $\\mathrm{Mod}(f_i)$ and $\\mathrm{Ref}(f_i)$ for all $i \\in \\{1,2,3,4,5,6,7,8\\}$, and determine which functions are pure.\n- Let $S = \\{f_1,f_2,f_3,f_4,f_5,f_6,f_7,f_8\\}$. Using the same analysis, a composed function $f \\circ g$ is considered pure if, under the interprocedural mod-ref rules, it satisfies the purity criterion. Let $N$ be the number of ordered pairs $(f,g) \\in S \\times S$ such that $f \\circ g$ is provably pure by this analysis.\n- Compute the value of $N$. Provide your answer as a single integer. No rounding is needed.", "solution": "The user wants me to solve a problem based on the principles of interprocedural static analysis in compiler design. The problem is deemed valid as it is scientifically grounded in established compiler theory, well-posed with clear and consistent rules, and objective in its formulation. It requires a systematic application of the provided definitions for mod-ref analysis and function purity to derive a numerical result.\n\nThe analysis is defined as a whole-program, context-insensitive, and flow-insensitive mod-ref analysis. The sets $\\mathrm{Mod}(f)$ and $\\mathrm{Ref}(f)$ for a function $f$ are computed by aggregating the effects from the function's body and all functions it transitively calls. For a function $f$ that calls a set of functions $H$, the rules are:\n$$ \\mathrm{Mod}(f) = (\\text{direct modifications in } f) \\cup \\bigcup_{h \\in H} \\mathrm{Mod}(h) $$\n$$ \\mathrm{Ref}(f) = (\\text{direct references in } f) \\cup \\bigcup_{h \\in H} \\mathrm{Ref}(h) $$\nSince the entire program's source is available, these sets can be determined by finding the least fixed point of this system of equations. The call graph among the functions $f_1, \\dots, f_8$ is a Directed Acyclic Graph (DAG), so we can compute the sets in a single pass following a reverse topological sort of the call graph.\n\nFirst, we determine the direct effects and calls for each function:\n- $f_1(x)$: Reads $C_a$. No calls. Direct-Mod: $\\varnothing$, Direct-Ref: $\\{C_a\\}$.\n- $f_2(x)$: Reads and writes $G_a$. No calls. Direct-Mod: $\\{G_a\\}$, Direct-Ref: $\\{G_a\\}$.\n- $f_3(x)$: Calls $f_1$. Reads $C_b$. Direct-Mod: $\\varnothing$, Direct-Ref: $\\{C_b\\}$. Calls: $\\{f_1\\}$.\n- $f_4(x)$: Writes $G_b$ (flow-insensitivity means we include effects from all branches). Calls $f_2$. Direct-Mod: $\\{G_b\\}$, Direct-Ref: $\\varnothing$. Calls: $\\{f_2\\}$.\n- $f_5(x)$: Calls $f_3$ and $f_1$. Direct-Mod: $\\varnothing$, Direct-Ref: $\\varnothing$. Calls: $\\{f_1, f_3\\}$.\n- $f_6(x)$: Reads $G_b$. No calls. Direct-Mod: $\\varnothing$, Direct-Ref: $\\{G_b\\}$.\n- $f_7(x)$: Calls `print`. The problem states $\\mathrm{Mod}(\\text{print}) = \\{I\\}$ and $\\mathrm{Ref}(\\text{print}) = \\varnothing$. Direct-Mod: $\\varnothing$, Direct-Ref: $\\varnothing$. Calls: $\\{\\text{print}\\}$.\n- $f_8(x)$: Calls $f_5, f_6, f_2$. Direct-Mod: $\\varnothing$, Direct-Ref: $\\varnothing$. Calls: $\\{f_2, f_5, f_6\\}$.\n\nNow, we compute the final $\\mathrm{Mod}$ and $\\mathrm{Ref}$ sets for each function by propagating effects up the call graph.\n\n1.  **Functions with no calls to other $f_i$ (leaves of the call graph):**\n    -   $f_1$: $\\mathrm{Mod}(f_1) = \\varnothing$; $\\mathrm{Ref}(f_1) = \\{C_a\\}$.\n    -   $f_2$: $\\mathrm{Mod}(f_2) = \\{G_a\\}$; $\\mathrm{Ref}(f_2) = \\{G_a\\}$.\n    -   $f_6$: $\\mathrm{Mod}(f_6) = \\varnothing$; $\\mathrm{Ref}(f_6) = \\{G_b\\}$.\n    -   $f_7$: $\\mathrm{Mod}(f_7) = \\mathrm{Mod}(\\text{print}) = \\{I\\}$; $\\mathrm{Ref}(f_7) = \\mathrm{Ref}(\\text{print}) = \\varnothing$.\n\n2.  **Functions calling the above:**\n    -   $f_3$ calls $f_1$:\n        $\\mathrm{Mod}(f_3) = \\mathrm{Mod}(f_1) = \\varnothing$.\n        $\\mathrm{Ref}(f_3) = \\{C_b\\} \\cup \\mathrm{Ref}(f_1) = \\{C_b\\} \\cup \\{C_a\\} = \\{C_a, C_b\\}$.\n    -   $f_4$ calls $f_2$:\n        $\\mathrm{Mod}(f_4) = \\{G_b\\} \\cup \\mathrm{Mod}(f_2) = \\{G_b\\} \\cup \\{G_a\\} = \\{G_a, G_b\\}$.\n        $\\mathrm{Ref}(f_4) = \\mathrm{Ref}(f_2) = \\{G_a\\}$.\n\n3.  **Functions calling the above:**\n    -   $f_5$ calls $f_3$ and $f_1$:\n        $\\mathrm{Mod}(f_5) = \\mathrm{Mod}(f_3) \\cup \\mathrm{Mod}(f_1) = \\varnothing \\cup \\varnothing = \\varnothing$.\n        $\\mathrm{Ref}(f_5) = \\mathrm{Ref}(f_3) \\cup \\mathrm{Ref}(f_1) = \\{C_a, C_b\\} \\cup \\{C_a\\} = \\{C_a, C_b\\}$.\n\n4.  **Top-level function:**\n    -   $f_8$ calls $f_5, f_6, f_2$:\n        $\\mathrm{Mod}(f_8) = \\mathrm{Mod}(f_5) \\cup \\mathrm{Mod}(f_6) \\cup \\mathrm{Mod}(f_2) = \\varnothing \\cup \\varnothing \\cup \\{G_a\\} = \\{G_a\\}$.\n        $\\mathrm{Ref}(f_8) = \\mathrm{Ref}(f_5) \\cup \\mathrm{Ref}(f_6) \\cup \\mathrm{Ref}(f_2) = \\{C_a, C_b\\} \\cup \\{G_b\\} \\cup \\{G_a\\} = \\{G_a, G_b, C_a, C_b\\}$.\n\nNext, we identify which functions are pure. A function $f$ is pure if $\\mathrm{Mod}(f) = \\varnothing$ and $\\mathrm{Ref}(f) \\subseteq \\{C_a, C_b\\}$.\n-   $f_1$: $\\mathrm{Mod}(f_1) = \\varnothing$ and $\\mathrm{Ref}(f_1) = \\{C_a\\} \\subseteq \\{C_a, C_b\\}$. **Pure**.\n-   $f_2$: $\\mathrm{Mod}(f_2) = \\{G_a\\} \\neq \\varnothing$. Not pure.\n-   $f_3$: $\\mathrm{Mod}(f_3) = \\varnothing$ and $\\mathrm{Ref}(f_3) = \\{C_a, C_b\\} \\subseteq \\{C_a, C_b\\}$. **Pure**.\n-   $f_4$: $\\mathrm{Mod}(f_4) = \\{G_a, G_b\\} \\neq \\varnothing$. Not pure.\n-   $f_5$: $\\mathrm{Mod}(f_5) = \\varnothing$ and $\\mathrm{Ref}(f_5) = \\{C_a, C_b\\} \\subseteq \\{C_a, C_b\\}$. **Pure**.\n-   $f_6$: $\\mathrm{Mod}(f_6) = \\varnothing$ but $\\mathrm{Ref}(f_6) = \\{G_b\\} \\not\\subseteq \\{C_a, C_b\\}$. Not pure.\n-   $f_7$: $\\mathrm{Mod}(f_7) = \\{I\\} \\neq \\varnothing$. Not pure.\n-   $f_8$: $\\mathrm{Mod}(f_8) = \\{G_a\\} \\neq \\varnothing$. Not pure.\n\nThe set of pure functions is $P = \\{f_1, f_3, f_5\\}$.\n\nThe final task is to find the number $N$ of ordered pairs $(f, g) \\in S \\times S$ such that the composition $(f \\circ g)(x) = f(g(x))$ is provably pure. To analyze $f \\circ g$, we conceptualize it as a new function, $h(x)$, whose body consists of calls to $f$ and $g$. Due to the context-insensitive and flow-insensitive nature of the analysis, the effects of $h$ are the union of the effects of its constituent calls.\n$$ \\mathrm{Mod}(f \\circ g) = \\mathrm{Mod}(f) \\cup \\mathrm{Mod}(g) $$\n$$ \\mathrm{Ref}(f \\circ g) = \\mathrm{Ref}(f) \\cup \\mathrm{Ref}(g) $$\nFor $f \\circ g$ to be pure, it must satisfy the purity conditions:\n1.  $\\mathrm{Mod}(f \\circ g) = \\mathrm{Mod}(f) \\cup \\mathrm{Mod}(g) = \\varnothing$. This holds if and only if $\\mathrm{Mod}(f) = \\varnothing$ and $\\mathrm{Mod}(g) = \\varnothing$.\n2.  $\\mathrm{Ref}(f \\circ g) = \\mathrm{Ref}(f) \\cup \\mathrm{Ref}(g) \\subseteq \\{C_a, C_b\\}$. This holds if and only if $\\mathrm{Ref}(f) \\subseteq \\{C_a, C_b\\}$ and $\\mathrm{Ref}(g) \\subseteq \\{C_a, C_b\\}$.\n\nThese two conditions together are equivalent to stating that both function $f$ and function $g$ must themselves be pure. Therefore, we are looking for the number of ordered pairs $(f, g)$ where both $f$ and $g$ are elements of the set of pure functions $P$.\nThe set of pure functions is $P = \\{f_1, f_3, f_5\\}$, which has a size of $|P| = 3$.\nThe number of such ordered pairs is the size of the Cartesian product $P \\times P$.\n$$ N = |P \\times P| = |P| \\times |P| = 3 \\times 3 = 9 $$\nThe value of $N$ is $9$.", "answer": "$$\n\\boxed{9}\n$$", "id": "3647898"}, {"introduction": "While propagating summaries is powerful, simple context-insensitive analyses have inherent limitations that can lead to incorrect conclusions. This exercise [@problem_id:3647942] presents a classic scenario where an analysis that fails to match function returns to their corresponding calls can report a \"false positive.\" By tracing the flow of tainted data through a recursive function, you will see firsthand how spurious, \"unrealizable\" paths are created and why context sensitivity is a critical concept for improving analysis precision.", "problem": "Consider the following program skeleton with explicit sources and return values. Variable names, function names, and constants are all mathematical entities and are written in LaTeX.\n\nFunction $id$ takes two parameters $x$ and $d$ and is defined as:\n- If $d = 0$, return $x$.\n- Otherwise, return $id(x, d - 1)$.\n\nProcedure $callerTainted$:\n- $a := \\text{source}()$ which returns a tainted integer,\n- $r_1 := id(a, 1)$,\n- $\\text{sinkTainted}(r_1)$.\n\nProcedure $callerClean$:\n- $b := 0$,\n- $r_2 := id(b, 1)$,\n- $y := r_2$.\n\nProcedure $main$:\n- call $callerTainted$,\n- call $callerClean$.\n\nAssume a standard Interprocedural Control Flow Graph (ICFG) model in which call edges connect a call site to the callee’s entry and return edges connect the callee’s exit back to the caller’s return site. A valid interprocedural path respects matched call-return discipline: each return must go back to the dynamic caller that issued the most recent unmatched call (i.e., a well-balanced parentheses condition corresponding to a pushdown system).\n\nNow consider an interprocedural taint analysis that, in the presence of recursion, performs graph reachability over the ICFG but ignores the return-to-caller matching constraint, effectively treating return edges as ordinary edges that may connect to any post-call site of the same function (call-site insensitivity for returns). The taint source is $\\text{source}()$ in $callerTainted$. Taint propagates along def-use chains and along returns of $id$ because $id$ returns its argument by the above definition.\n\nWhich statement correctly characterizes the analysis outcome under this “ignore return-to-caller matching” approximation?\n\nA. Only $r_1$ is tainted; $y$ stays untainted under both sound and unsound analyses, because recursion does not affect propagation of returns.\n\nB. $y$ becomes spuriously tainted: a mismatched return path from the recursive invocation of $id$ in $callerTainted$ can flow to the post-call site in $callerClean$, over-tainting $r_2$ and thus $y$.\n\nC. Both $r_1$ and $r_2$ are legitimately tainted even with properly matched returns; recursion causes $id$ to return a tainted value in all contexts.\n\nD. No variables are tainted under any interprocedural analysis because returns do not propagate taint across procedure boundaries.", "solution": "The problem statement is validated as scientifically grounded, well-posed, and objective. It describes a standard scenario in static program analysis, specifically interprocedural taint analysis, and explores the consequences of a common precision-performance trade-off.\n\nThe core of the problem lies in understanding the behavior of an interprocedural taint analysis that uses a simplified model for function returns. The analysis performs graph reachability on an Interprocedural Control Flow Graph (ICFG), but it \"ignores the return-to-caller matching constraint.\" This means that when a function, say `$f$`, returns, the analysis assumes the control flow (and data flow) can proceed to the statement following *any* call to `$f$` in the program, not just the one that initiated the current execution of `$f$`. This is a form of context-insensitivity.\n\nLet us trace the analysis step-by-step.\n\nThe program execution begins in `main`, which first calls `callerTainted` and then `callerClean`.\n\n1.  **Analysis of `callerTainted`:**\n    *   The statement `$a := \\text{source}()$` is executed. By definition, the value assigned to `$a$` is tainted.\n    *   The function `$id$` is called with `$r_1 := id(a, 1)$`. Since `$a$` is tainted, the first argument to `$id$`, let's call it `$x$`, becomes tainted. The second argument, `$d$`, is `$1$`.\n    *   Inside `$id(x, 1)$`, the condition `$d = 0$` is false. The function recursively calls itself: `$id(x, d - 1)`, which is `$id(x, 0)$`. The tainted value of `$x$` is passed to this recursive call.\n    *   Inside `$id(x, 0)$`, the condition `$d = 0$` is true. The function returns its argument `$x$`. Since `$x$` is tainted, the return value of `$id$` is tainted.\n    *   This tainted value is returned from the recursive call back to the outer `$id(x, 1)$`, which then promptly returns it.\n    *   At the exit point of the top-level `$id(a, 1)$` call, a tainted value is returned.\n\n2.  **Analysis of Return Flow and `callerClean`:**\n    *   A sound analysis, which respects matched call-return pairs, would propagate this tainted return value only to its corresponding call site in `callerTainted`. This would taint `$r_1$` and the analysis of `callerTainted` would conclude. The subsequent analysis of `callerClean` would start with no tainted data.\n    *   However, the problem specifies an analysis that **ignores the return-to-caller matching constraint**. The analysis model connects the exit of `$id$` to all possible return sites.\n    *   The program contains two top-level call sites for `$id$`:\n        1.  In `callerTainted`: `$r_1 := id(a, 1)$`. Let its return site be `$RS_1$`.\n        2.  In `callerClean`: `$r_2 := id(b, 1)$`. Let its return site be `$RS_2$`.\n    *   When the tainted value is produced at the exit of `$id$` (originating from the call in `callerTainted`), the unsound analysis creates data-flow paths to both `$RS_1$` and `$RS_2$`.\n    *   The path to `$RS_1$` is legitimate. It results in `$r_1$` being assigned the tainted value.\n    *   The path to `$RS_2$` is spurious. It creates a \"cross-talk\" or \"unrealizable path\" where the result of one function call (`$id(a, 1)$`) appears to be the result of a completely different call (`$id(b, 1)$`).\n    *   Due to this spurious path, the analysis concludes that the call `$id(b, 1)$` in `callerClean` can return a tainted value.\n    *   Consequently, the variable `$r_2$` is marked as tainted.\n    *   The next statement is `$y := r_2$`. Due to this definition-use relationship, the taint propagates from `$r_2$` to `$y$`.\n    *   Therefore, `$y$` becomes tainted in this analysis. This is a false positive, as no real execution of the program can cause `$y$` to hold a tainted value.\n\nIn summary, the specified analysis correctly identifies `$r_1$` as tainted but spuriously identifies `$r_2$` and `$y$` as tainted due to its inability to distinguish between different calling contexts for the function `$id$`.\n\nNow, we evaluate each option:\n\n**A. Only $r_1$ is tainted; $y$ stays untainted under both sound and unsound analyses, because recursion does not affect propagation of returns.**\nThis statement is **Incorrect**. While `$y$` would stay untainted under a sound analysis, the problem explicitly describes an unsound analysis where mismatched returns are allowed. As derived above, this specific unsoundness leads to `$y$` being spuriously tainted. The reason provided is also flawed; the combination of recursion and a shared function called from different contexts is precisely what exposes the imprecision of the analysis model.\n\n**B. $y$ becomes spuriously tainted: a mismatched return path from the recursive invocation of $id$ in $callerTainted$ can flow to the post-call site in $callerClean$, over-tainting $r_2$ and thus $y$.**\nThis statement is **Correct**. It accurately describes the outcome (`$y$` becomes spuriously tainted) and the exact mechanism causing it. The analysis creates a \"mismatched return path\" from the call chain initiated in `callerTainted` to the return site in `callerClean`. This leads to the tainting of `$r_2$` and subsequently `$y$`. This aligns perfectly with our derivation.\n\n**C. Both $r_1$ and $r_2$ are legitimately tainted even with properly matched returns; recursion causes $id$ to return a tainted value in all contexts.**\nThis statement is **Incorrect**. The tainting of `$r_2$` (and `$y$`) is not legitimate; it's a false positive resulting from the analysis's imprecision. An analysis with \"properly matched returns\" (a sound, context-sensitive analysis) would find that the call `$id(b, 1)` in `callerClean` operates only on clean data (`$b=0$`) and thus its return value is clean. Recursion does not cause a function to be tainted in all contexts, only in contexts where its inputs are tainted.\n\n**D. No variables are tainted under any interprocedural analysis because returns do not propagate taint across procedure boundaries.**\nThis statement is **Incorrect**. It makes a factual claim that contradicts a premise given in the problem statement. The problem explicitly states that \"Taint propagates along def-use chains and along returns of `$id$`\". The function `$id$` is an identity function on its first argument, so it is a classic example of a function that precisely propagates data (and thus taint) from its argument to its return value across a procedure boundary. Therefore, `$r_1$` must be tainted.", "answer": "$$\\boxed{B}$$", "id": "3647942"}, {"introduction": "Interprocedural analysis is not just for compilers; it's a powerful engine for automated bug-finding tools. In this practice problem [@problem_id:3647964], you'll apply the principles of summarization to a practical task: enforcing a correct usage protocol for a resource, such as a file handle or network connection. By modeling the resource lifecycle as a state machine and propagating its state across function calls, you will build a simple static checker that can automatically flag potential misuse bugs in a program.", "problem": "You are given a simple type-state protocol for a single resource, with states and operations defined as follows. The resource type-state is modeled by the finite set $\\{U,O,X,E\\}$, where $U$ means unopened, $O$ means open, $X$ means closed, and $E$ is an error sink state. The intended protocol is to call open exactly once on an unopened resource to enter state $O$, to call write any number of times while in state $O$, and to call close exactly once from state $O$ to enter state $X$. Any operation applied in a state where it is not permitted immediately transitions the abstract state to $E$ and is a misuse. Once in $E$, the abstract state remains $E$ under any operation, and operations on $E$ do not generate additional misuse reports. The primitive operations have pointwise effects on singleton states:\n- $T_{\\mathrm{open}}(U)=O$, $T_{\\mathrm{open}}(O)=E$, $T_{\\mathrm{open}}(X)=E$, $T_{\\mathrm{open}}(E)=E$.\n- $T_{\\mathrm{write}}(O)=O$, $T_{\\mathrm{write}}(U)=E$, $T_{\\mathrm{write}}(X)=E$, $T_{\\mathrm{write}}(E)=E$.\n- $T_{\\mathrm{close}}(O)=X$, $T_{\\mathrm{close}}(U)=E$, $T_{\\mathrm{close}}(X)=E$, $T_{\\mathrm{close}}(E)=E$.\n\nConsider the following program in pseudo-code, where $b_1$ and $b_2$ are nondeterministic booleans (both branches are considered possible), and calls are by reference to a single shared resource $r$:\n\nproc h(r):\n  write(r)\n\nproc k(r):\n  if b2? then close(r) else write(r)\n\nproc f(r):\n  if b1? then open(r)\n  h(r)\n\nproc g(r):\n  f(r)\n  k(r)\n\nmain:\n  r := new Resource()  // initial state is U\n  g(r)\n  close(r)\n\nWe perform a forward, flow-sensitive, context-insensitive, may analysis in the framework of monotone dataflow analysis. The abstract domain is $D=\\mathcal{P}(\\{U,O,X,E\\})$ with pointwise lifting of the single-state transfer functions so that, for $S \\subseteq \\{U,O,X,E\\}$, $T_{\\mathrm{op}}(S)=\\bigcup_{s \\in S} \\{T_{\\mathrm{op}}(s)\\}$. Within a procedure, control-flow joins are modeled by set union on $D$. At a call site, interprocedural summarization is used: each procedure $p \\in \\{h,k,f,g\\}$ is summarized by a monotone transformer $\\tau_p:D \\to D$ that maps the abstract input state at call entry to the abstract output state at return. A misuse is flagged at a specific operation site if, at that site, there exists a reachable non-error abstract state $s \\in \\{U,O,X\\}$ from which the operation is not permitted by the protocol. Operations executed while in state $E$ do not generate new misuse flags.\n\nStarting from the initial abstract state $\\{U\\}$ at the entry of main, derive, from first principles of monotone dataflow frameworks and interprocedural summarization, the summaries $\\tau_h$, $\\tau_k$, $\\tau_f$, and $\\tau_g$, and then compute the abstract state at main’s final close site. Using these results, determine the set of distinct operation sites in the whole program that are flagged as misuses under this analysis. Report, as your final answer, the number of distinct flagged operation sites. Your answer must be a single integer with no units. If you choose to write the number in words, also include the numeral in parentheses. No rounding is required.", "solution": "The problem requires us to perform a forward, flow-sensitive, context-insensitive, may dataflow analysis on a given program to identify type-state protocol misuses. We must first validate the problem statement.\n\n### Step 1: Extract Givens\n- **Type-State Model**: The set of states is $\\{U, O, X, E\\}$, where $U$ is unopened, $O$ is open, $X$ is closed, and $E$ is an error sink state.\n- **State Transition Functions**: The primitive operations induce the following state transitions for a singleton state $s$:\n  - $T_{\\mathrm{open}}(U)=O$, $T_{\\mathrm{open}}(O)=E$, $T_{\\mathrm{open}}(X)=E$, $T_{\\mathrm{open}}(E)=E$.\n  - $T_{\\mathrm{write}}(O)=O$, $T_{\\mathrm{write}}(U)=E$, $T_{\\mathrm{write}}(X)=E$, $T_{\\mathrm{write}}(E)=E$.\n  - $T_{\\mathrm{close}}(O)=X$, $T_{\\mathrm{close}}(U)=E$, $T_{\\mathrm{close}}(X)=E$, $T_{\\mathrm{close}}(E)=E$.\n- **Program Pseudo-Code**:\n  ```\n  proc h(r):\n    write(r)\n  \n  proc k(r):\n    if b2? then close(r) else write(r)\n  \n  proc f(r):\n    if b1? then open(r)\n    h(r)\n  \n  proc g(r):\n    f(r)\n    k(r)\n  \n  main:\n    r := new Resource()  // initial state is U\n    g(r)\n    close(r)\n  ```\n  $b_1$ and $b_2$ are nondeterministic booleans. The resource $r$ is shared by reference.\n- **Dataflow Analysis Framework**:\n  - **Direction**: Forward.\n  - **Sensitivity**: Flow-sensitive, context-insensitive.\n  - **Analysis Type**: May analysis.\n  - **Abstract Domain**: $D=\\mathcal{P}(\\{U,O,X,E\\})$, the powerset of the states.\n  - **Join Operator**: Set union ($\\cup$) at control-flow joins.\n  - **Transfer Function Lifting**: For $S \\in D$, $T_{\\mathrm{op}}(S)=\\bigcup_{s \\in S} \\{T_{\\mathrm{op}}(s)\\}$.\n  - **Interprocedural Strategy**: Summarization. Each procedure $p$ is summarized by a monotone transformer $\\tau_p:D \\to D$.\n- **Misuse Definition**: A misuse is flagged at an operation site if the abstract state $S$ at that site's entry contains a non-error state $s \\in \\{U,O,X\\}$ for which the operation is not permitted. Operations from state $E$ do not generate new misuse flags.\n- **Initial Condition**: The resource $r$ starts in state $\\{U\\}$ in `main`.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the established principles of static program analysis and compiler theory. It uses standard terminology (flow-sensitivity, context-insensitivity, may analysis, monotone dataflow frameworks). The setup is complete and internally consistent. The goals are clearly defined. The language is objective and precise. The problem is well-posed; a unique solution can be derived through systematic application of the defined analysis rules. There are no violations of the validation criteria.\n\n### Step 3: Verdict and Action\nThe problem is valid. We proceed with the solution.\n\n### Detailed Solution\n\nThe analysis proceeds by first deriving the summary transformer for each procedure in a bottom-up fashion according to the call graph, and then performing a top-down analysis of the `main` procedure to find misuses.\n\n**Formal Preliminaries**\nThe abstract domain is the lattice $(D, \\subseteq)$ where $D = \\mathcal{P}(\\{U, O, X, E\\})$. The join operator is $\\cup$. The transfer functions for operations are lifted to sets as defined.\nThe misuse condition for an operation `op` with pre-state $S$ is:\n- `open(r)`: Misuse if $S \\cap \\{O, X\\} \\neq \\emptyset$.\n- `write(r)`: Misuse if $S \\cap \\{U, X\\} \\neq \\emptyset$.\n- `close(r)`: Misuse if $S \\cap \\{U, X\\} \\neq \\emptyset$.\n\n**Derivation of Procedure Summaries**\nLet $S_{in} \\in D$ be the abstract state at the entry of a procedure.\n\n1.  **Summary for `proc h(r)`:**\n    The procedure contains a single operation, `write(r)`. The output state is the result of applying the `write` transfer function to the input state.\n    $$ \\tau_h(S_{in}) = T_{\\mathrm{write}}(S_{in}) $$\n\n2.  **Summary for `proc k(r)`:**\n    The procedure has a nondeterministic branch. For a may analysis, we consider both paths and join the results.\n    - `then` branch: `close(r)`. The state becomes $T_{\\mathrm{close}}(S_{in})$.\n    - `else` branch: `write(r)`. The state becomes $T_{\\mathrm{write}}(S_{in})$.\n    The summary is the union of the outcomes of the two branches.\n    $$ \\tau_k(S_{in}) = T_{\\mathrm{close}}(S_{in}) \\cup T_{\\mathrm{write}}(S_{in}) $$\n\n3.  **Summary for `proc f(r)`:**\n    This procedure also contains a nondeterministic branch followed by a call to `h`.\n    - `then` branch: `open(r)`. The state becomes $T_{\\mathrm{open}}(S_{in})$.\n    - `else` branch: The state remains $S_{in}$.\n    The state before the call to `h(r)` is the join of the states from the `if-else` construct: $S_{before\\_h} = S_{in} \\cup T_{\\mathrm{open}}(S_{in})$.\n    The output of `f` is the result of applying the summary $\\tau_h$ to this state.\n    $$ \\tau_f(S_{in}) = \\tau_h(S_{in} \\cup T_{\\mathrm{open}}(S_{in})) = T_{\\mathrm{write}}(S_{in} \\cup T_{\\mathrm{open}}(S_{in})) $$\n\n4.  **Summary for `proc g(r)`:**\n    This procedure consists of a sequence of calls to `f` and `k`.\n    - First, `f(r)` is called. The state after this call is $S_{after\\_f} = \\tau_f(S_{in})$.\n    - Then, `k(r)` is called with $S_{after\\_f}$ as its input. The final state is $\\tau_k(S_{after\\_f})$.\n    The summary for `g` is the composition of the summaries for `f` and `k`.\n    $$ \\tau_g(S_{in}) = \\tau_k(\\tau_f(S_{in})) = \\tau_k(T_{\\mathrm{write}}(S_{in} \\cup T_{\\mathrm{open}}(S_{in}))) $$\n\n**Forward Analysis of `main`**\nWe now trace the execution starting from the entry of `main`.\n\n1.  `r := new Resource()`: The abstract state of $r$ becomes $S_0 = \\{U\\}$.\n\n2.  Call `g(r)`: The analysis of `g` is performed with the input state $S_{g,in} = S_0 = \\{U\\}$.\n    - Call `f(r)` with input $S_{f,in} = \\{U\\}$.\n        - Inside `f`: There's a nondeterministic choice.\n            - `then` branch (`open(r)` at site `f1`):\n                - Pre-state: $\\{U\\}$. Misuse check: $\\{U\\} \\cap \\{O, X\\} = \\emptyset$. **No misuse**.\n                - Post-state: $T_{\\mathrm{open}}(\\{U\\}) = \\{O\\}$.\n            - `else` branch: State remains $\\{U\\}$.\n        - The state before the `h(r)` call is the join: $S_{h,in} = \\{O\\} \\cup \\{U\\} = \\{U, O\\}$.\n        - Call `h(r)` with input $S_{h,in} = \\{U, O\\}$.\n            - Inside `h`, at `write(r)` (site `h1`):\n                - Pre-state: $\\{U, O\\}$. Misuse check: $\\{U, O\\} \\cap \\{U, X\\} = \\{U\\} \\neq \\emptyset$. **Misuse flagged at `h1`**.\n                - Post-state: $T_{\\mathrm{write}}(\\{U, O\\}) = T_{\\mathrm{write}}(\\{U\\}) \\cup T_{\\mathrm{write}}(\\{O\\}) = \\{E\\} \\cup \\{O\\} = \\{O, E\\}$.\n        - The state returned from `h` to `f` is $\\{O, E\\}$. This is also the exit state of `f`, so $\\tau_f(\\{U\\}) = \\{O, E\\}$.\n    - The state in `g` after `f(r)` returns is $S_{g,mid} = \\{O, E\\}$.\n    - Call `k(r)` with input $S_{k,in} = \\{O, E\\}$.\n        - Inside `k`: There's a nondeterministic choice.\n            - `then` branch (`close(r)` at site `k1`):\n                - Pre-state: $\\{O, E\\}$. Misuse check: $\\{O, E\\} \\cap \\{U, X\\} = \\emptyset$. **No misuse**.\n                - Post-state: $T_{\\mathrm{close}}(\\{O, E\\}) = T_{\\mathrm{close}}(\\{O\\}) \\cup T_{\\mathrm{close}}(\\{E\\}) = \\{X\\} \\cup \\{E\\} = \\{X, E\\}$.\n            - `else` branch (`write(r)` at site `k2`):\n                - Pre-state: $\\{O, E\\}$. Misuse check: $\\{O, E\\} \\cap \\{U, X\\} = \\emptyset$. **No misuse**.\n                - Post-state: $T_{\\mathrm{write}}(\\{O, E\\}) = T_{\\mathrm{write}}(\\{O\\}) \\cup T_{\\mathrm{write}}(\\{E\\}) = \\{O\\} \\cup \\{E\\} = \\{O, E\\}$.\n        - The state at the exit of `k` is the join: $\\{X, E\\} \\cup \\{O, E\\} = \\{O, X, E\\}$. Thus, $\\tau_k(\\{O, E\\}) = \\{O, X, E\\}$.\n    - The state returned from `k` to `g` (and thus exiting `g`) is $\\{O, X, E\\}$. So, $\\tau_g(\\{U\\}) = \\{O, X, E\\}$.\n\n3.  The abstract state in `main` after `g(r)` returns is $S_1 = \\{O, X, E\\}$. This is a required intermediate result: the abstract state at `main`'s final `close` site.\n\n4.  Execute `close(r)` (site `m2` in `main`):\n    - Pre-state: $\\{O, X, E\\}$.\n    - Misuse check: $\\{O, X, E\\} \\cap \\{U, X\\} = \\{X\\} \\neq \\emptyset$. **Misuse flagged at `m2`**.\n    - Post-state: $T_{\\mathrm{close}}(\\{O, X, E\\}) = T_{\\mathrm{close}}(\\{O\\}) \\cup T_{\\mathrm{close}}(\\{X\\}) \\cup T_{\\mathrm{close}}(\\{E\\}) = \\{X\\} \\cup \\{E\\} \\cup \\{E\\} = \\{X, E\\}$.\n\n**Conclusion**\nThe analysis reveals misuses at two distinct operation sites:\n1.  The `write(r)` operation in procedure `h` (site `h1`).\n2.  The final `close(r)` operation in `main` (site `m2`).\n\nThe total number of distinct flagged operation sites is $2$.", "answer": "$$\\boxed{2}$$", "id": "3647964"}]}