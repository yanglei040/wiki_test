{"hands_on_practices": [{"introduction": "A common misconception is that inlining is always beneficial. In reality, compilers operate under strict constraints, most notably a limit on the final code size. This exercise challenges you to step into the role of the compiler's optimization strategist, formalizing the decision to inline as a classic cost-benefit analysis. You will learn to model this choice as a 0-1 knapsack problem, where you must select the most 'valuable' call sites to inline without exceeding a 'weight' limit corresponding to the code size budget [@problem_id:3664279].", "problem": "Consider a compiler performing procedure inlining on a program represented by a call graph whose nodes are procedures and whose directed edges $(i,j)$ indicate a call from procedure $i$ to procedure $j$. Each procedure $i$ has code size $s_i$ (in bytes), each call edge $(i,j)$ is executed with frequency $f_{ij}$ (number of invocations per run), and inlining call $(i,j)$ yields a per-invocation runtime reduction $b_{ij}$ (in cycles). Inlining duplicates the callee body into the caller and removes the call-site sequence, causing a code size change on edge $(i,j)$ equal to $\\Delta s_{ij} = s_j - o_{ij}$, where $o_{ij}$ (in bytes) is the size of call-sequence and prologue/epilogue code eliminated by inlining. A global code size budget $B$ (in bytes) constrains the total code size increase from all chosen inlinings.\n\nStart from the fundamental compiler principle that the total expected runtime reduction from a set of inlined calls equals the sum over call sites of the per-invocation savings multiplied by their execution frequencies, and that inlining increases code size due to duplication of callee code minus removed call-site overhead. From this base, formulate the optimization problem that chooses a subset of call edges to inline in order to maximize the total expected runtime reduction subject to the code size budget constraint. Then, solve the optimization for the concrete instance below and compute the exact maximum total runtime reduction, expressed as an integer number of cycles.\n\nProcedures and sizes (bytes):\n- $F_1$: $s_1 = 120$, $F_2$: $s_2 = 80$, $F_3$: $s_3 = 200$, $F_4$: $s_4 = 50$, $F_5$: $s_5 = 160$.\n\nCall edges with frequencies $f_{ij}$ (invocations per run), per-invocation savings $b_{ij}$ (cycles), and removable overhead sizes $o_{ij}$ (bytes):\n- $(1,2)$: $f_{12} = 4000$, $b_{12} = 25$, $o_{12} = 6$.\n- $(1,3)$: $f_{13} = 500$, $b_{13} = 90$, $o_{13} = 10$.\n- $(4,2)$: $f_{42} = 6000$, $b_{42} = 10$, $o_{42} = 6$.\n- $(4,5)$: $f_{45} = 800$, $b_{45} = 120$, $o_{45} = 12$.\n- $(3,5)$: $f_{35} = 300$, $b_{35} = 200$, $o_{35} = 12$.\n\nBudget:\n- $B = 300$ bytes.\n\nInstructions:\n- Derive the objective and constraint from first principles as described above.\n- Compute the optimal selection of call edges to inline and the resulting maximum total runtime reduction in cycles.\n- Express your final answer as an integer number of cycles. No rounding is required.", "solution": "The foundational principles for procedure inlining in compilers are:\n- Inlining replaces a call $(i,j)$ with the body of procedure $j$ in the caller $i$, which can reduce runtime by removing call overhead and enabling local optimizations. If the per-invocation reduction for $(i,j)$ is $b_{ij}$ cycles, and the edge executes $f_{ij}$ times per run, the total expected runtime reduction contributed by inlining $(i,j)$ is $f_{ij} \\cdot b_{ij}$ cycles.\n- Inlining increases code size because it duplicates the callee's body into the caller. Under a simple additive model, the code size increase on edge $(i,j)$ is $\\Delta s_{ij} = s_j - o_{ij}$, where $o_{ij}$ accounts for eliminated call-sequence and prologue/epilogue code at the call site.\n\nTo select a subset of call edges to inline, define a binary decision variable $x_{ij} \\in \\{0,1\\}$ for each call edge $(i,j)$, where $x_{ij} = 1$ means inline $(i,j)$ and $x_{ij} = 0$ means do not inline. The total expected runtime reduction is\n$$\n\\sum_{(i,j)} f_{ij} \\, b_{ij} \\, x_{ij},\n$$\nand the total code size increase is\n$$\n\\sum_{(i,j)} \\Delta s_{ij} \\, x_{ij} = \\sum_{(i,j)} (s_j - o_{ij}) \\, x_{ij}.\n$$\nSubject to the code size budget $B$, the optimization problem is the $0$-$1$ knapsack:\n$$\n\\max_{x_{ij} \\in \\{0,1\\}} \\sum_{(i,j)} f_{ij} \\, b_{ij} \\, x_{ij}\n\\quad \\text{subject to} \\quad\n\\sum_{(i,j)} (s_j - o_{ij}) \\, x_{ij} \\le B.\n$$\n\nFor the concrete instance, first compute the weights $\\Delta s_{ij}$ and values $v_{ij} = f_{ij} \\cdot b_{ij}$:\n\n- $(1,2)$: $\\Delta s_{12} = s_2 - o_{12} = 80 - 6 = 74$ bytes, $v_{12} = f_{12} \\cdot b_{12} = 4000 \\cdot 25 = 100000$ cycles.\n- $(1,3)$: $\\Delta s_{13} = s_3 - o_{13} = 200 - 10 = 190$ bytes, $v_{13} = f_{13} \\cdot b_{13} = 500 \\cdot 90 = 45000$ cycles.\n- $(4,2)$: $\\Delta s_{42} = s_2 - o_{42} = 80 - 6 = 74$ bytes, $v_{42} = f_{42} \\cdot b_{42} = 6000 \\cdot 10 = 60000$ cycles.\n- $(4,5)$: $\\Delta s_{45} = s_5 - o_{45} = 160 - 12 = 148$ bytes, $v_{45} = f_{45} \\cdot b_{45} = 800 \\cdot 120 = 96000$ cycles.\n- $(3,5)$: $\\Delta s_{35} = s_5 - o_{35} = 160 - 12 = 148$ bytes, $v_{35} = f_{35} \\cdot b_{35} = 300 \\cdot 200 = 60000$ cycles.\n\nBudget: $B = 300$ bytes. We must select a subset of these five items with total weight at most $300$ and maximum total value.\n\nTo solve the knapsack problem, we can enumerate feasible combinations of items (call edges) that fit within the budget of 300 bytes.\n\n- **Single-edge choices:** All single items are feasible. The best is $(1,2)$ with value 100,000.\n- **Two-edge combinations:** The best feasible combination is $(1,2)+(4,5)$ with weight $74+148 = 222$ and value $100,000 + 96,000 = 196,000$.\n- **Three-edge combinations:**\n  - Let's try to include the three items with the highest values: $(1,2)$, $(4,5)$, and $(4,2)$.\n  - Total weight: $\\Delta s_{12} + \\Delta s_{45} + \\Delta s_{42} = 74 + 148 + 74 = 296$ bytes. This is within the budget ($296 \\le 300$).\n  - Total value: $v_{12} + v_{45} + v_{42} = 100,000 + 96,000 + 60,000 = 256,000$ cycles.\n- **Four-edge combinations:** Any combination of four items will have a weight greater than 300 bytes. For example, the four lightest items are $(1,2), (4,2), (4,5), (3,5)$, with a total weight of $74+74+148+148 = 444$ bytes, which is infeasible.\n\nComparing all feasible combinations, the three-edge combination of inlining call sites $(1,2)$, $(4,2)$, and $(4,5)$ yields the maximum runtime reduction.\n\nThe maximum total runtime reduction is $256,000$ cycles.", "answer": "$$\\boxed{256000}$$", "id": "3664279"}, {"introduction": "Having modeled the high-level trade-off, we now dive into the complexities of calculating the 'cost' side of the equation. The impact of inlining on code size is not as simple as just adding the callee's size. Modern compilers employ sophisticated techniques like Identical Code Folding (ICF) and are sensitive to language linkage rules. This practice provides a realistic scenario to meticulously calculate the final program size, revealing how different factors interact to determine the true code-bloat cost of inlining [@problem_id:3664209].", "problem": "Consider a whole-program compilation pipeline for a language with function inlining implemented over an Intermediate Representation (IR). The pipeline uses Link-Time Optimization (LTO) with Identical Code Folding (ICF), where inline clones of the same callee under the same optimization context label are shared across the entire program. The following foundational definitions govern the code-size accounting:\n- Replacing a call with inlining removes the call instruction of size $d$ and emits the calleeâ€™s inline clone of size $s_i$.\n- If multiple callsites inline the same callee $i$ under the same context label $\\mathcal{C}$ anywhere in the program, ICF shares a single emitted clone; therefore the size $s_i$ is counted once per unique pair $(i, \\mathcal{C})$ across the whole program.\n- A callee with internal linkage whose callsites are all inlined contributes no standalone body in the final binary. A callee with external linkage retains its standalone body even if all its callsites are inlined.\n\nYou are given a program with three caller functions and four potential callees:\n\n- Caller functions and their original (pre-inlining) sizes: $F_1$ has $b_1 = 600$ bytes, $F_2$ has $b_2 = 480$ bytes, $F_3$ has $b_3 = 520$ bytes.\n- Callee functions and their sizes: $G_1$ has $s_1 = 200$ bytes (internal linkage), $G_2$ has $s_2 = 150$ bytes (internal linkage), $G_3$ has $s_3 = 180$ bytes (external linkage), $G_4$ has $s_4 = 300$ bytes (internal linkage).\n- All listed callsites below are inlined. Call instruction sizes are specified per callsite.\n\nCallsites to be inlined and their context labels:\n- In $F_1$:\n  - Two callsites to $G_1$ with context $\\mathcal{A}$, call sizes $d_{11} = 5$ and $d_{12} = 5$.\n  - One callsite to $G_2$ with context $\\mathcal{C}$, call size $d_{13} = 6$.\n  - One callsite to $G_4$ with context $\\mathcal{H}$, call size $d_{14} = 5$.\n- In $F_2$:\n  - Two callsites to $G_1$ with contexts $\\mathcal{A}$ and $\\mathcal{B}$, call sizes $d_{21} = 5$ and $d_{22} = 5$.\n  - One callsite to $G_2$ with context $\\mathcal{D}$, call size $d_{23} = 6$.\n  - One callsite to $G_4$ with context $\\mathcal{G}$, call size $d_{24} = 5$.\n- In $F_3$:\n  - One callsite to $G_2$ with context $\\mathcal{C}$, call size $d_{31} = 6$.\n  - Three callsites to $G_3$ with contexts $\\mathcal{E}$, $\\mathcal{E}$, and $\\mathcal{F}$, call sizes $d_{32} = 4$, $d_{33} = 4$, and $d_{34} = 4$.\n\nAssumptions:\n- There is no additional inlining overhead besides the emitted clone size $s_i$.\n- ICF shares clones across the entire program per unique $(i, \\mathcal{C})$ pair.\n- Standalone bodies of $G_1$, $G_2$, and $G_4$ are removed after inlining (all have internal linkage and no remaining calls); $G_3$ is retained (external linkage).\n\nStarting from the fundamental definitions above, compute the exact final code size in bytes after inlining and ICF-based clone sharing. Express your answer as an integer number of bytes. No rounding is required.", "solution": "The final program size is calculated by determining the net change from the initial total size. The initial size is the sum of all original caller and callee function bodies: $(600 + 480 + 520) + (200 + 150 + 180 + 300) = 2430$ bytes.\n\n1.  **Code Size Removed:**\n    *   **Call Instructions:** The sum of all individual call instruction sizes is removed.\n    Total = $(5+5+6+5) + (5+5+6+5) + (6+4+4+4) = 60$ bytes.\n    *   **Standalone Function Bodies:** The bodies of callees with internal linkage ($G_1, G_2, G_4$) are removed since all their callsites are inlined.\n    Total = $s_1 + s_2 + s_4 = 200 + 150 + 300 = 650$ bytes.\n    The body of $G_3$ is retained due to its external linkage.\n    *   Total size removed = $60 + 650 = 710$ bytes.\n\n2.  **Code Size Added:**\n    *   **Inline Clones:** Due to Identical Code Folding (ICF), one clone is generated for each unique (callee, context) pair across the entire program. We identify these unique pairs and sum their sizes.\n    *   Unique pairs and their sizes:\n        *   $(G_1, \\mathcal{A}): 200$ bytes\n        *   $(G_1, \\mathcal{B}): 200$ bytes\n        *   $(G_2, \\mathcal{C}): 150$ bytes\n        *   $(G_2, \\mathcal{D}): 150$ bytes\n        *   $(G_3, \\mathcal{E}): 180$ bytes\n        *   $(G_3, \\mathcal{F}): 180$ bytes\n        *   $(G_4, \\mathcal{G}): 300$ bytes\n        *   $(G_4, \\mathcal{H}): 300$ bytes\n    *   Total size added = $200+200+150+150+180+180+300+300 = 1660$ bytes.\n\n3.  **Final Code Size:**\n    The final size is calculated as: Final Size = Initial Size - Total Removed + Total Added.\n    Final Size = $2430 - 710 + 1660 = 3380$ bytes.", "answer": "$$\\boxed{3380}$$", "id": "3664209"}, {"introduction": "Perhaps the most surprising effects of inlining arise from its interaction with the deep rules of a programming language. Inlining exposes the internal logic of a function to the optimizer, which can have unexpected consequences when the code relies on behavior that the language standard deems 'undefined.' This exercise demonstrates how inlining can enable an optimizer to remove what seems like a programmer's safety check by leveraging the rules of signed integer overflow in C, highlighting a critical lesson about the contract between the programmer and the compiler [@problem_id:3664201].", "problem": "Consider a program in the C language that uses signed integers. The program defines three procedures: a helper procedure that computes a sum, a procedure that tries to guard against overflow by comparing the result to one operand, and a client that passes a constant increment. Specifically, let $\\text{add}$ be a procedure defined as $\\text{add}(\\text{a}, \\text{b})$ returning the signed sum $\\text{a} + \\text{b}$. Let $\\text{safe\\_sum}(\\text{x}, \\text{y})$ compute $\\text{s} = \\text{add}(\\text{x}, \\text{y})$ and then return $\\text{x}$ if $\\text{s} < \\text{x}$, otherwise return $\\text{s}$. Let $\\text{client}(\\text{n})$ call $\\text{safe\\_sum}(\\text{n}, 1)$ and return the result. Assume separate compilation without Link-Time Optimization (LTO), so that compiling the unit containing $\\text{safe\\_sum}$ does not inline $\\text{add}$ nor does it see the actual argument $\\text{y} = 1$ from $\\text{client}$; and contrast this with a build that enables whole-program inlining, allowing the compiler to inline both $\\text{add}$ into $\\text{safe\\_sum}$ and $\\text{safe\\_sum}$ into $\\text{client}$.\n\nFundamental base facts to use:\n- In the C language, signed integer overflow is undefined behavior: if the mathematical result of $\\text{a} + \\text{b}$ does not fit in the range of type $\\text{int}$, the program has no defined semantics for that operation.\n- Procedure inlining is a semantics-preserving transformation that replaces a call with the body of the callee, thereby exposing more code to optimizations such as value-range propagation and algebraic simplification.\n- On two's complement hardware, the machine addition performed on $w$-bit words computes results modulo $2^w$. However, unless the implementation or flags specify otherwise, the C language does not define signed overflow to use modulo $2^w$; instead, it is undefined behavior.\n- For mathematical integers, addition by a positive constant is strictly monotone: for all integers $x$, $x + 1 > x$.\n\nSuppose the client may be called with $\\text{n} = \\text{INT\\_MAX}$, where $\\text{INT\\_MAX}$ denotes the maximum representable value of type $\\text{int}$. Answer the following multiple-choice question about how procedure inlining can expose undefined behavior in a way that changes optimization outcomes, and about mitigations such as compiler flag $\\text{-fwrapv}$ or instrumentation via sanitizers like Undefined Behavior Sanitizer (UBSan).\n\nWhich of the following statements are correct? Select all that apply.\n\nA. After inlining the body of `add` into `safe_sum` and further into `client`, the optimizer can use the fact that addition by $1$ is strictly monotone for defined signed integer executions to prove $(\\text{n} + 1) < \\text{n}$ is false and remove the conditional, changing the observable outcome on inputs like `n = INT_MAX` because those inputs trigger undefined behavior.\n\nB. Compiling with `-fwrapv` forces signed addition to wrap modulo $2^w$, so the optimizer may not assume that $(\\text{n} + 1) > \\text{n}$ for all `n`, and therefore cannot eliminate the conditional; the behavior remains consistent whether or not procedures are inlined.\n\nC. Enabling `-fsanitize=signed-integer-overflow` changes the language semantics to define signed overflow as modulo arithmetic, thereby guaranteeing identical results with or without inlining.\n\nD. If the program is rewritten to use unsigned integers for `x`, `y`, and `s`, then overflow is defined modulo $2^w$, and the test `s  x` becomes a well-defined detection of a carry-out when adding a positive `y`; the compiler must preserve the observable result regardless of inlining.\n\nE. Procedure inlining cannot alter optimization outcomes, because it never changes the data or control dependencies visible to the optimizer and therefore has no interaction with undefined behavior.", "solution": "The key principle is that signed integer overflow is undefined behavior (UB) in C. An optimizer is free to assume UB does not occur in any valid program execution.\n\n-   **A (Correct):** After inlining, the compiler sees the code `if ((n + 1)  n)`. Assuming no UB, the mathematical property that `n + 1 > n` holds. The compiler can thus prove the condition is always false and eliminate the branch, changing the code to `return n + 1;`. When run with `n = INT_MAX`, this optimized code overflows and (on typical hardware) returns `INT_MIN`, whereas the unoptimized code might have returned `INT_MAX`. Inlining enables this optimization and changes the observable behavior for inputs that trigger UB.\n\n-   **B (Correct):** The `-fwrapv` flag instructs the compiler to treat signed integer overflow as well-defined two's complement wrap-around. Under this rule, `n + 1 > n` is no longer universally true (it's false for `n = INT_MAX`). The optimizer can no longer assume the condition is false and must preserve the check. Therefore, the program's behavior is consistent whether or not inlining occurs.\n\n-   **C (Incorrect):** `-fsanitize=signed-integer-overflow` instruments the code to detect and report UB at runtime, typically by aborting the program. It does not change the language semantics to be modulo arithmetic for the optimizer. The compiler's UB-based assumptions remain, so the premise of this option is false.\n\n-   **D (Correct):** Unsigned integer arithmetic in C is well-defined to be modular (wrap-around). The condition `s  x` after `s = x + y` (for positive `y`) is the standard, portable way to detect overflow. Since the behavior is well-defined, the compiler must preserve this logic. Inlining, being a semantics-preserving transformation, will not change the well-defined outcome.\n\n-   **E (Incorrect):** This is fundamentally false. A major purpose of inlining is to expand the optimization scope for the compiler, exposing new data and control flow information (like constant arguments) that enables more powerful transformations, including those related to UB.\n\nTherefore, the correct statements are A, B, and D.", "answer": "$$\\boxed{ABD}$$", "id": "3664201"}]}