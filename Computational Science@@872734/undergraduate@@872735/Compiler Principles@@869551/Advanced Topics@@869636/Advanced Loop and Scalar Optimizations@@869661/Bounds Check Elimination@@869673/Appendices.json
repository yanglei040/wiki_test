{"hands_on_practices": [{"introduction": "This first practice lays the groundwork for understanding how a compiler analyzes related array accesses within a single loop. We will explore a scenario with two indices linked by a simple affine relation, $j = i + c$. The core task is to derive the tightest possible loop bound that guarantees both accesses, $a[i]$ and $a[j]$, are safe, which is a fundamental skill in proving memory safety and enabling optimization [@problem_id:3625287].", "problem": "Consider a statically typed language with zero-based arrays where a bounds check ensures memory safety by requiring that any array access $a[k]$ satisfy $0 \\le k  n$ for an array $a$ of length $n$. A compiler uses bounds check elimination when it can prove, from program structure and arithmetic, that all array accesses in a loop satisfy the bounds for every iteration. Suppose we have a loop variable $i$ ranging over consecutive integers and an affine relation between indices $j = i + c$, where $c$ is a loop-invariant integer constant. The loop body performs two array accesses $a[i]$ and $a[j]$ on the same array $a$ of length $n$. Assume $n$ and $c$ are integers satisfying $0 \\le c  n$, and the loop lower bound is $0$ so that $i$ starts at $0$ and increases by $1$ on each iteration. You are to design a loop upper bound $U$ (inclusive) and derive the simultaneous bounds on $i$ and $j$ needed to eliminate both $a[i]$ and $a[j]$ bounds checks.\n\nUsing only the fundamental facts that valid array indices must satisfy $0 \\le k  n$, that $j = i + c$, that $i$ ranges over integers, and that monotone affine functions preserve order over integers, derive the tightest possible inclusive upper bound $U$ such that for all integers $i$ with $0 \\le i \\le U$, both accesses $a[i]$ and $a[j]$ are provably in-bounds. Your final answer must be a single closed-form expression in terms of $n$ and $c$ for this maximal $U$. Do not provide an inequality or an equation in the final answer; provide only the expression. No rounding is required.", "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of compiler design and static analysis, is well-posed with a clear objective and sufficient constraints, and is expressed in objective, formal language. It is a standard problem in program optimization that can be solved through rigorous mathematical and logical deduction.\n\nThe objective is to find the maximal inclusive integer upper bound, denoted as $U$, for a loop index $i$, such that two array accesses, $a[i]$ and $a[j]$, are guaranteed to be within the valid bounds of an array $a$ of length $n$. The loop iterates over integers $i$ starting from $0$ up to $U$, i.e., for all integers $i$ satisfying $0 \\le i \\le U$.\n\nThe fundamental condition for a valid array access in a zero-based array of length $n$ is that the index $k$ must satisfy the inequality:\n$$0 \\le k  n$$\n\nThis condition must hold for both accesses performed within the loop body: $a[i]$ and $a[j]$.\n\nFor the access $a[i]$, the index is $i$. The validity condition is:\n$$0 \\le i  n \\quad (\\text{Constraint 1})$$\n\nFor the access $a[j]$, the index is $j$. The validity condition is:\n$$0 \\le j  n \\quad (\\text{Constraint 2})$$\n\nThe problem provides an affine relation between the indices $i$ and $j$:\n$$j = i + c$$\nwhere $c$ is a loop-invariant integer constant. Substituting this relation into Constraint 2, we obtain a constraint on $i$:\n$$0 \\le i + c  n$$\nThis inequality can be decomposed into two separate inequalities:\n$$0 \\le i + c \\implies -c \\le i \\quad (\\text{Constraint 2a})$$\n$$i + c  n \\implies i  n - c \\quad (\\text{Constraint 2b})$$\n\nTo ensure both $a[i]$ and $a[j]$ are always in-bounds, the loop index $i$ must satisfy all derived constraints for every iteration. The set of constraints on $i$ is:\n1.  From the loop structure: $i \\ge 0$.\n2.  From Constraint 1: $i  n$.\n3.  From Constraint 2a: $i \\ge -c$.\n4.  From Constraint 2b: $i  n - c$.\n\nWe must find a single range for $i$ that satisfies all these simultaneously. Let's combine the lower bounds and the upper bounds.\n\nThe lower bounds on $i$ are $i \\ge 0$ and $i \\ge -c$. The problem states that $c$ is an integer satisfying $0 \\le c  n$. Since $c$ is non-negative, $-c$ must be non-positive, i.e., $-c \\le 0$. The condition $i \\ge 0$ is therefore more restrictive than (or equal to, if $c=0$) the condition $i \\ge -c$. Thus, the effective lower bound on $i$ is $i \\ge 0$. This aligns with the given information that the loop starts at $i=0$.\n\nThe upper bounds on $i$ are $i  n$ and $i  n - c$. Again, we are given $0 \\le c  n$.\n- If $c=0$, the two inequalities are identical: $i  n$.\n- If $c  0$, then $n - c  n$. In this case, the inequality $i  n - c$ is strictly more restrictive than $i  n$.\nIn all cases specified by $0 \\le c  n$, the condition $i  n - c$ is the governing upper bound, as it is always at least as restrictive as $i  n$.\n\nCombining the effective lower and upper bounds, any valid value for the index $i$ must satisfy:\n$$0 \\le i  n - c$$\n\nThe loop is defined to execute for all integers $i$ in the inclusive range $[0, U]$. For the bounds checks to be eliminated, every value of $i$ in this range must satisfy the derived condition $0 \\le i  n - c$. This is true if and only if the maximum value in the loop's range, which is $U$, also satisfies the condition.\nThe lower bound is trivially satisfied since $U \\ge 0$. The critical constraint comes from the upper bound:\n$$U  n - c$$\n\nThe problem asks for the *tightest possible inclusive upper bound* $U$. This is the largest integer value of $U$ that satisfies the strict inequality $U  n - c$. Since $n$, $c$, and $U$ are all integers, the largest integer $U$ that is strictly less than the integer $n - c$ is given by:\n$$U = (n - c) - 1$$\n\nTo verify this, if we choose $U = n - c - 1$, the largest value $i$ will take is $n - c - 1$.\n- The access $a[i]$ becomes $a[n - c - 1]$. Since $c \\ge 0$, we have $c+1 \\ge 1$, so $n-c-1 \\le n-1  n$. Also, since $cn$, $n-c  0$, so $n-c-1 \\ge 0$. Thus $0 \\le n-c-1  n$ and $a[i]$ is in-bounds.\n- The access $a[j]$ has index $j = i + c$. The maximum value for $j$ is $(n - c - 1) + c = n - 1$. The minimum value for $j$ is $0+c = c$. Since $0 \\le c  n$, the range for $j$ is $[c, n - 1]$, which is entirely within the valid index range $[0, n-1]$. Both accesses are therefore safe.\n\nIf we were to choose a larger upper bound, for example $U = n - c$, the loop would execute for $i = n - c$. In this case, the index $j$ would be $j = i + c = (n - c) + c = n$. The access $a[j]$ would become $a[n]$, which is out of bounds for an array of length $n$. Therefore, $U = n - c - 1$ is indeed the maximal possible inclusive upper bound.", "answer": "$$\\boxed{n - c - 1}$$", "id": "3625287"}, {"introduction": "Building on the foundational skill of analyzing related indices, this practice applies the same principles to a common, real-world algorithm: in-place subarray reversal. You will analyze two array accesses, $a[k]$ and $a[r - (k - l)]$, whose indices are part of a symmetric swapping pattern. This exercise demonstrates how the abstract logic of interval arithmetic can be used to formally prove the safety of practical code, a crucial step for any optimizing compiler [@problem_id:3625309].", "problem": "Consider an array $a$ of length $n$ with valid indices $i$ satisfying $0 \\le i  n$. A program reverses the subarray $a[l \\ldots r]$ by iterating an integer loop variable $k$ over the inclusive range $[l, r]$ and performing two array accesses per iteration: $a[k]$ and $a[r - (k - l)]$. Assume the program has established the precondition $0 \\le l \\le r  n$ before the loop. The compiler performs Bounds Check Elimination (BCE), which removes an array bounds check whenever it can prove from the programâ€™s arithmetic and control-flow constraints that the accessed index always satisfies $0 \\le \\text{index}  n$.\n\nStarting from the core definition of an array bounds check (that a valid access requires $0 \\le \\text{index}  n$) and the well-tested facts of integer interval arithmetic (that for an affine function $f(k) = \\alpha k + \\beta$ over $k \\in [p, q]$, the image $f([p,q])$ is $[\\alpha p + \\beta, \\alpha q + \\beta]$ if $\\alpha \\ge 0$ and $[\\alpha q + \\beta, \\alpha p + \\beta]$ if $\\alpha \\le 0$), formally derive the tight bounds for both indices $k$ and $r - (k - l)$ across the loop. Use these bounds to justify whether the compiler can eliminate the bounds checks for both array accesses throughout the loop under the stated precondition. Finally, assuming that each array access would otherwise incur exactly one bounds check, compute the exact total number of bounds checks the compiler can eliminate over the entire loop as a closed-form expression in terms of $l$ and $r$. The final answer must be a single closed-form analytic expression with no units. No rounding is required.", "solution": "The objective is to determine whether a compiler can eliminate the bounds checks for two array accesses, `$a[k]$` and `$a[r - (k - l)]$`, within a loop that reverses a subarray, and to compute the total number of eliminated checks.\n\nThe problem provides the following givens:\n- An array `$a$` of length `$n$`.\n- The range of valid indices `$i$` is defined by `$0 \\le i  n$`.\n- A loop iterates with an integer variable `$k$` over the inclusive range `$[l, r]$`, so `$l \\le k \\le r$`.\n- A precondition is established before the loop: `$0 \\le l \\le r  n$`.\n- Two array accesses are performed in each iteration: one at index `$k$` and another at index `$r - (k - l)$`.\n- A bounds check for an index `$\\text{index}$` is defined by the condition `$0 \\le \\text{index}  n$`. Elimination is possible if this condition can be proven to hold for all executions.\n- A rule for integer interval arithmetic is provided: for an affine function `$f(k) = \\alpha k + \\beta$` over `$k \\in [p, q]$`, its image is `$[\\alpha p + \\beta, \\alpha q + \\beta]$` if `$\\alpha \\ge 0$` and `$[\\alpha q + \\beta, \\alpha p + \\beta]$` if `$\\alpha \\le 0$`.\n\nWe will analyze each array access separately to determine if its bounds check can be eliminated.\n\n**Analysis of the first access: `$a[k]$`**\n\nThe index for this access is simply `$k$`. The problem states that the loop iterates for `$k \\in [l, r]$`, which means `$l \\le k \\le r$`. The established precondition is `$0 \\le l \\le r  n$`.\n\nWe can combine these two facts into a single chain of inequalities:\n$$\n0 \\le l \\le k \\le r  n\n$$\nFrom this chain, we can extract two specific inequalities concerning `$k$`:\n1. `$0 \\le l \\le k \\implies 0 \\le k$`\n2. `$k \\le r  n \\implies k  n$`\n\nCombining these gives `$0 \\le k  n$`. This is precisely the condition required for a valid array access. Since this holds true for every value of `$k$` in its iteration range, the compiler can prove that the index `$k$` is always within the valid bounds of the array `$a$`. Therefore, the bounds check for the access `$a[k]$` can be eliminated for every iteration of the loop.\n\n**Analysis of the second access: `$a[r - (k - l)]$`**\n\nLet the index for this access be `$\\text{idx}_2$`.\n$$\n\\text{idx}_2(k) = r - (k - l) = r - k + l\n$$\nThis can be expressed as an affine function of `$k$`:\n$$\n\\text{idx}_2(k) = (-1)k + (r + l)\n$$\nWe apply the provided rule for integer interval arithmetic. In this context, the function is `$f(k) = \\text{idx}_2(k)$`, the coefficient `$\\alpha = -1$`, the constant `$\\beta = r + l$`, and the interval for `$k$` is `$[p, q] = [l, r]$`.\n\nSince `$\\alpha = -1 \\le 0$`, the range of `$\\text{idx}_2(k)$` is given by the interval `$[\\alpha q + \\beta, \\alpha p + \\beta]$`. We substitute the specific values for `$\\alpha$`, `$\\beta$`, `$p$`, and `$q$`:\n- The lower bound of the range is `$\\alpha q + \\beta = (-1)r + (r + l) = -r + r + l = l$`.\n- The upper bound of the range is `$\\alpha p + \\beta = (-1)l + (r + l) = -l + r + l = r$`.\n\nThus, for all `$k \\in [l, r]$`, the index `$\\text{idx}_2(k)$` falls within the range `$[l, r]$`. This means `$l \\le \\text{idx}_2(k) \\le r$`.\n\nNow, we use the precondition `$0 \\le l \\le r  n$` again. We can construct a new chain of inequalities for `$\\text{idx}_2(k)$`:\n$$\n0 \\le l \\le \\text{idx}_2(k) \\le r  n\n$$\nFrom this chain, we deduce:\n1. `$0 \\le l \\le \\text{idx}_2(k) \\implies 0 \\le \\text{idx}_2(k)$`\n2. `$\\text{idx}_2(k) \\le r  n \\implies \\text{idx}_2(k)  n$`\n\nCombining these gives `$0 \\le \\text{idx}_2(k)  n$`. This condition for a valid array access holds for all possible values of `$\\text{idx}_2(k)$` throughout the loop. Consequently, the compiler can also eliminate the bounds check for the access `$a[r - (k - l)]` for every iteration.\n\n**Calculation of Total Eliminated Bounds Checks**\n\nThe loop iterates for each integer value of `$k$` from `$l$` to `$r$`, inclusive. The total number of iterations is `$(r - l) + 1$`.\n\nIn each iteration, there are two array accesses. We have formally proven that the bounds check for both accesses can be safely eliminated. Therefore, `$2$` bounds checks are eliminated per iteration.\n\nThe total number of eliminated bounds checks, `$N_{\\text{elim}}$`, is the product of the number of iterations and the number of checks eliminated per iteration:\n$$\nN_{\\text{elim}} = (\\text{number of iterations}) \\times (\\text{checks eliminated per iteration})\n$$\n$$\nN_{\\text{elim}} = (r - l + 1) \\times 2\n$$\nThis gives the final closed-form expression for the total number of bounds checks the compiler can eliminate.", "answer": "$$\n\\boxed{2(r - l + 1)}\n$$", "id": "3625309"}, {"introduction": "Our final practice introduces the complexity of control flow, moving beyond a single, linear sequence of operations. Here, the value of an array index is determined by a `switch-case` statement, representing multiple possible execution paths. This thought experiment simulates how a compiler must conservatively merge information from all branches to make a sound decision, a key concept in dataflow analysis that ensures optimizations are correct no matter which path the program takes [@problem_id:3625305].", "problem": "A compiler is attempting to eliminate array bounds checks for an access to an array $A$ of length $n$ in a program whose index $i$ is set by a switch-case on a mode variable $m$. All variables are integers. A prior static analysis has soundly established the following case-wise definitions and ranges, where all intervals are inclusive and all variables are independent of one another:\n- Case $0$: $i := 2x + 3$ with $x \\in [0,5]$.\n- Case $1$: $i := y - 1$ with $y \\in [4,20]$.\n- Case $2$: $i := r + s$ with $r \\in [1,6]$ and $s \\in [2,7]$.\n- Case $3$: $i := 5u$ with $u \\in [1,4]$.\n- Default case: $i := v$ with $v \\in [10,12]$.\n\nThe compiler performs bounds check elimination if and only if it can soundly prove, from the above facts alone, that for all possible executions $0 \\le i  n$ holds at the access. Using the semantics of set union $\\bigcup$ to conservatively summarize all possible values of $i$ across the cases, compute the smallest integer $n^{\\star}$ such that the union of all case-wise ranges of $i$ is a subset of $[0,n^{\\star})$, thereby permitting sound elimination of the checks. Provide your final answer as a single integer. No rounding is necessary.", "solution": "The user wants to find the smallest integer value for an array length, denoted as $n^{\\star}$, that guarantees an array access $A[i]$ is always in bounds, based on a static analysis of the index variable $i$. The condition for the access to be in bounds for an array of length $n$ is $0 \\le i  n$. The compiler can eliminate the bounds checks if it can prove this condition holds for all possible program executions. The problem states that this proof is constructed by calculating the possible range of values for $i$ in each case of a switch statement and then taking the union of these ranges.\n\nLet $I$ be the set of all possible integer values that the index $i$ can assume. The condition $0 \\le i  n$ must hold for every value in $I$. This is equivalent to requiring that the set $I$ be a subset of the integer interval $[0, n-1]$. This implies two conditions: $\\min(I) \\ge 0$ and $\\max(I) \\le n-1$. We are asked to find the smallest integer $n^{\\star}$ that satisfies this, so we need to find the overall minimum and maximum possible values for $i$.\n\nWe will use interval arithmetic to determine the range of $i$ for each case presented in the problem statement. The variables $x$, $y$, $r$, $s$, $u$, and $v$ are all integers within their specified inclusive intervals.\n\n1.  **Case $0$**: $i := 2x + 3$ with $x \\in [0, 5]$.\n    The function $f(x) = 2x + 3$ is monotonically increasing. Therefore, the minimum and maximum values of $i$ correspond to the minimum and maximum values of $x$.\n    The minimum value of $i$ is $i_{\\min,0} = 2(0) + 3 = 3$.\n    The maximum value of $i$ is $i_{\\max,0} = 2(5) + 3 = 13$.\n    The range of values for $i$ in this case, let's call it $R_0$, is the integer interval $[3, 13]$.\n\n2.  **Case $1$**: $i := y - 1$ with $y \\in [4, 20]$.\n    The function $f(y) = y - 1$ is monotonically increasing.\n    The minimum value of $i$ is $i_{\\min,1} = 4 - 1 = 3$.\n    The maximum value of $i$ is $i_{\\max,1} = 20 - 1 = 19$.\n    The range of values for $i$, $R_1$, is the integer interval $[3, 19]$.\n\n3.  **Case $2$**: $i := r + s$ with $r \\in [1, 6]$ and $s \\in [2, 7]$.\n    For a sum of independent variables, the minimum of the sum is the sum of the minimums, and the maximum of the sum is the sum of the maximums.\n    The minimum value of $i$ is $i_{\\min,2} = \\min(r) + \\min(s) = 1 + 2 = 3$.\n    The maximum value of $i$ is $i_{\\max,2} = \\max(r) + \\max(s) = 6 + 7 = 13$.\n    The range of values for $i$, $R_2$, is the integer interval $[3, 13]$.\n\n4.  **Case $3$**: $i := 5u$ with $u \\in [1, 4]$.\n    The function $f(u) = 5u$ is monotonically increasing.\n    The minimum value of $i$ is $i_{\\min,3} = 5(1) = 5$.\n    The maximum value of $i$ is $i_{\\max,3} = 5(4) = 20$.\n    The range of values for $i$, $R_3$, is the integer interval $[5, 20]$.\n\n5.  **Default case**: $i := v$ with $v \\in [10, 12]$.\n    The value of $i$ is directly assigned from $v$.\n    The minimum value of $i$ is $i_{\\min,def} = 10$.\n    The maximum value of $i$ is $i_{\\max,def} = 12$.\n    The range of values for $i$, $R_{def}$, is the integer interval $[10, 12]$.\n\nNow, we must determine the overall range for $i$ by taking the union of the ranges from all possible cases. Let $R_{total}$ be this union.\n$R_{total} = R_0 \\cup R_1 \\cup R_2 \\cup R_3 \\cup R_{def}$\n$R_{total} = [3, 13] \\cup [3, 19] \\cup [3, 13] \\cup [5, 20] \\cup [10, 12]$\nThe union of these intervals results in a single, continuous interval. To find it, we take the minimum of all lower bounds and the maximum of all upper bounds.\nThe overall minimum value of $i$ is $\\min(i) = \\min(3, 3, 3, 5, 10) = 3$.\nThe overall maximum value of $i$ is $\\max(i) = \\max(13, 19, 13, 20, 12) = 20$.\nSo, the static analysis has soundly determined that the value of $i$ at the point of the array access must lie in the integer interval $[3, 20]$. Let $I$ be the set of all possible integer values for $i$, so $I \\subseteq \\{3, 4, \\dots, 20\\}$.\n\nThe compiler can eliminate the bounds check if it can prove that $0 \\le i  n$ for an array length $n$. We are looking for the smallest integer $n^{\\star}$ that can serve as this $n$. The condition must hold for all possible values of $i$.\nThis means the interval of possible values for $i$, which is $[3, 20]$, must be a subset of the valid index interval $[0, n^{\\star}-1]$.\nThis gives us two conditions:\n1.  $\\min(i) \\ge 0$: Since the minimum possible value of $i$ is $3$, the condition $3 \\ge 0$ is satisfied. The lower bound check can be eliminated.\n2.  $\\max(i)  n^{\\star}$: The maximum possible value of $i$ is $20$. Therefore, we must have $20  n^{\\star}$.\n\nWe need to find the smallest integer $n^{\\star}$ that satisfies the inequality $20  n^{\\star}$. The smallest integer greater than $20$ is $21$.\nThus, by choosing $n^{\\star} = 21$, the array length is $21$, and the valid indices are $0, 1, \\dots, 20$. Since the analysis proved that $3 \\le i \\le 20$, the condition $0 \\le i  21$ is always true, and the bounds check can be safely eliminated. Any value of $n$ smaller than $21$ would not be sufficient, as the index $i=20$ is a possible value. For example, if $n=20$, the access $A[20]$ would be out of bounds.\n\nTherefore, the smallest integer $n^{\\star}$ is $21$.", "answer": "$$\\boxed{21}$$", "id": "3625305"}]}