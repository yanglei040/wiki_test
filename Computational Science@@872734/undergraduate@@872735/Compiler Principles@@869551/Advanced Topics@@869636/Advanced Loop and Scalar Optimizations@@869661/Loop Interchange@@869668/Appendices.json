{"hands_on_practices": [{"introduction": "Before applying any optimization, a compiler must prove that the transformation does not change the program's observable behavior. For loop interchange, this proof rests on a rigorous analysis of data dependences. This exercise challenges you to identify all flow, anti-, and output dependences in a given loop nest, represent them using direction vectors, and apply the formal legality test to determine if the interchange is semantics-preserving. Mastering this process is the first and most critical step in safely restructuring loops for performance. [@problem_id:3652959]", "problem": "You are analyzing a perfectly nested two-level loop in a compiler that targets Random Access Memory (RAM) with a row-major array layout. The program operates on a two-dimensional array $A$ of size $N \\times N$ where $N \\geq 3$, and the array $A$ is initialized before the loop nest. The loop indices iterate over the following finite, convex iteration space:\n- For the outer loop, $i$ ranges from $1$ to $N-1$.\n- For the inner loop, $j$ ranges from $1$ to $N-1$.\n\nThe loop body performs two writes and one read of $A$ as follows:\n- A write to $A[i][j]$,\n- A write to $A[i][j+1]$,\n- A read from $A[i+1][j]$.\n\nAssume there is no aliasing and no intervening function calls that modify $A$. The semantic meaning of the program depends only on the relative order of memory operations to $A$.\n\nTask: Using the foundational definitions of data dependences (flow, anti, and output) and direction/distance vectors for nested loops, treat the original execution order as lexicographic with $i$ outer and $j$ inner, written as $(i,j)$. Consider interchanging the loops to $(j,i)$ and determine whether semantics are preserved by examining the permuted direction vectors. A loop interchange is legal if and only if, for every dependence direction vector, the source iteration still precedes the sink iteration under the new lexicographic order (i.e., the leftmost non-equal direction after permutation is a “$$”).\n\nDefine the legality indicator $L$ by\n$$\nL =\n\\begin{cases}\n1,  \\text{if the interchange from } (i,j) \\text{ to } (j,i) \\text{ preserves semantics},\\\\\n0,  \\text{otherwise.}\n\\end{cases}\n$$\n\nCompute $L$ for this loop nest using only direction/distance vector reasoning as the fundamental base. The answer must be a single real number equal to $0$ or $1$. No renaming transformations (such as value splitting or temporary creation) are allowed. You do not need to provide any rounding, and no physical units apply.", "solution": "The problem requires us to determine the legality of interchanging a perfectly nested two-level loop. The legality is denoted by an indicator variable $L$, where $L=1$ for a legal interchange and $L=0$ otherwise. The legality analysis must be based on data dependence relations formalized using direction vectors.\n\nFirst, let us establish the framework for our analysis. The execution of the loop nest defines a lexicographical order on the set of iteration vectors $(i,j)$. An iteration $(i_1, j_1)$ is executed before an iteration $(i_2, j_2)$, denoted as $(i_1, j_1) \\prec (i_2, j_2)$, if $i_1  i_2$ or ($i_1 = i_2$ and $j_1  j_2$).\n\nA data dependence exists from an operation in a source iteration $\\vec{I}_1 = (i_1, j_1)$ to an operation in a sink iteration $\\vec{I}_2 = (i_2, j_2)$ if:\n1. Both operations access the same memory location.\n2. At least one of the operations is a write.\n3. The execution order is $\\vec{I}_1 \\prec \\vec{I}_2$.\n\nThe loop body contains three memory operations on a two-dimensional array $A$ of size $N \\times N$:\n- $S_1$: A write to $A[i][j]$.\n- $S_2$: A write to $A[i][j+1]$.\n- $S_3$: A read from $A[i+1][j]$.\n\nThe iteration space is defined by $1 \\le i \\le N-1$ and $1 \\le j \\le N-1$.\n\nA dependence is characterized by a distance vector $\\vec{d} = \\vec{I}_2 - \\vec{I}_1 = (i_2-i_1, j_2-j_1) = (d_i, d_j)$ and a direction vector $\\vec{v} = (\\text{sgn}(d_i), \\text{sgn}(d_j))$, where $\\text{sgn}$ is the signum function represented by $\\{, =, >\\}$. For a dependence to be carried by the loops, the direction vector must be lexicographically positive.\n\nWe analyze all possible pairs of operations between two distinct iterations $\\vec{I}_1$ and $\\vec{I}_2$ (where $\\vec{I}_1 \\prec \\vec{I}_2$) to find all loop-carried dependencies.\n\n1.  **Flow dependence (Read-After-Write, RAW):** from a write at $\\vec{I}_1$ to a read at $\\vec{I}_2$.\n    - $S_1(\\vec{I}_1) \\to S_3(\\vec{I}_2)$: `write A[i_1][j_1]` to `read A[i_2+1][j_2]`.\n      For a memory collision, we need $i_1 = i_2+1$ and $j_1 = j_2$. This gives a distance vector component $d_i = i_2 - i_1 = -1$. Since $d_i  0$, $\\vec{I}_1$ would execute after $\\vec{I}_2$, which violates the dependence condition $\\vec{I}_1 \\prec \\vec{I}_2$. Thus, no dependence exists.\n    - $S_2(\\vec{I}_1) \\to S_3(\\vec{I}_2)$: `write A[i_1][j_1+1]` to `read A[i_2+1][j_2]`.\n      For a collision, $i_1 = i_2+1$ and $j_1+1 = j_2$. This gives $d_i = i_2 - i_1 = -1$, again violating $\\vec{I}_1 \\prec \\vec{I}_2$. No dependence exists.\n\n2.  **Anti-dependence (Write-After-Read, WAR):** from a read at $\\vec{I}_1$ to a write at $\\vec{I}_2$.\n    - $S_3(\\vec{I}_1) \\to S_1(\\vec{I}_2)$: `read A[i_1+1][j_1]` to `write A[i_2][j_2]`.\n      For a collision, $i_1+1 = i_2$ and $j_1 = j_2$.\n      The distance vector is $\\vec{d} = (i_2-i_1, j_2-j_1) = (1, 0)$.\n      The condition $\\vec{I}_1 \\prec \\vec{I}_2$ is met since $i_2 = i_1+1 > i_1$.\n      This dependence exists if there are valid iteration vectors. For $N \\ge 3$, we can choose $i_1=1, j_1=1$, which gives $\\vec{I}_1 = (1,1)$ and $\\vec{I}_2 = (2,1)$. Both are in the iteration space.\n      The direction vector is $\\vec{v}_1 = (, =)$.\n\n    - $S_3(\\vec{I}_1) \\to S_2(\\vec{I}_2)$: `read A[i_1+1][j_1]` to `write A[i_2][j_2+1]`.\n      For a collision, $i_1+1 = i_2$ and $j_1 = j_2+1$.\n      The distance vector is $\\vec{d} = (i_2-i_1, j_2-j_1) = (1, -1)$.\n      The condition $\\vec{I}_1 \\prec \\vec{I}_2$ is met since $i_2 = i_1+1 > i_1$.\n      This dependence exists if there are valid iteration vectors. We need $1 \\le i_1 \\le N-2$ and $2 \\le j_1 \\le N-1$. For $N \\ge 3$, we can choose $i_1=1, j_1=2$, giving $\\vec{I}_1=(1,2)$ and $\\vec{I}_2=(2,1)$. Both are valid iterations.\n      The direction vector is $\\vec{v}_2 = (, >)$.\n\n3.  **Output dependence (Write-After-Write, WAW):** from a write at $\\vec{I}_1$ to a write at $\\vec{I}_2$.\n    - $S_1(\\vec{I}_1) \\to S_1(\\vec{I}_2)$: `write A[i_1][j_1]` to `write A[i_2][j_2]`. Collision implies $\\vec{I}_1 = \\vec{I}_2$, so no loop-carried dependence.\n    - $S_2(\\vec{I}_1) \\to S_2(\\vec{I}_2)$: `write A[i_1][j_1+1]` to `write A[i_2][j_2+1]`. Collision implies $\\vec{I}_1 = \\vec{I}_2$, so no loop-carried dependence.\n    - $S_1(\\vec{I}_1) \\to S_2(\\vec{I}_2)$: `write A[i_1][j_1]` to `write A[i_2][j_2+1]`.\n      For a collision, $i_1=i_2$ and $j_1=j_2+1$. This gives $d_j = j_2 - j_1 = -1$. Since $d_i=0$, this would require $j_1  j_2$ for a valid dependence, which is contradicted by $j_1 > j_2$. No dependence.\n    - $S_2(\\vec{I}_1) \\to S_1(\\vec{I}_2)$: `write A[i_1][j_1+1]` to `write A[i_2][j_2]`.\n      For a collision, $i_1=i_2$ and $j_1+1=j_2$.\n      The distance vector is $\\vec{d} = (i_2-i_1, j_2-j_1) = (0, 1)$.\n      The condition $\\vec{I}_1 \\prec \\vec{I}_2$ is met since $i_1=i_2$ and $j_2 = j_1+1 > j_1$.\n      This dependence is valid. For $N \\ge 3$, choose $i_1=1, j_1=1$, giving $\\vec{I}_1=(1,1)$ and $\\vec{I}_2=(1,2)$.\n      The direction vector is $\\vec{v}_3 = (=, )$.\n\nThe loop-carried dependencies are summarized by their direction vectors:\n- $\\vec{v}_1 = (, =)$\n- $\\vec{v}_2 = (, >)$\n- $\\vec{v}_3 = (=, )$\n\nAccording to the legality test, a loop interchange from $(i,j)$ to $(j,i)$ is legal if and only if for every dependence direction vector $\\vec{v} = (v_i, v_j)$, the permuted vector $\\vec{v}' = (v_j, v_i)$ is lexicographically positive (its first non-'=' component is '').\n\nLet's test our direction vectors:\n1.  For $\\vec{v}_1 = (, =)$, the permuted vector is $\\vec{v}'_1 = (=, )$. This is lexicographically positive. This dependence does not prevent interchange.\n2.  For $\\vec{v}_2 = (, >)$, the permuted vector is $\\vec{v}'_2 = (>, )$. The first component is '>', which is not ''. This vector is not lexicographically positive. The existence of this dependence makes the loop interchange illegal.\n3.  For $\\vec{v}_3 = (=, )$, the permuted vector is $\\vec{v}'_3 = (, =)$. This is lexicographically positive. This dependence does not prevent interchange.\n\nThe presence of the anti-dependence with direction vector $\\vec{v}_2 = (, >)$ makes the loop interchange from $(i,j)$ to $(j,i)$ illegal. This dependence reverses upon interchange, meaning an operation that was supposed to happen before another would happen after it, violating the program's semantics. For example, the anti-dependence from source $\\vec{I}_1=(1,2)$ to sink $\\vec{I}_2=(2,1)$ ensures that `read A[2][2]` at iteration $(1,2)$ occurs before `write A[2][2]` at iteration $(2,1)$. After interchange, the iteration vectors are ordered by $(j,i)$. The read occurs at iteration $(1,2)$ and the write occurs at iteration $(2,1)$ (using $(i,j)$ coordinates). Under the new order, the iteration with $j=1$ (the write) executes before the iteration with $j=2$ (the read), which is incorrect.\n\nSince the loop interchange is illegal, the legality indicator $L$ is $0$.", "answer": "$$\\boxed{0}$$", "id": "3652959"}, {"introduction": "Once we know a loop interchange is legal, the next question is whether it is profitable. The primary motivation is often to improve memory access patterns, specifically to enhance spatial locality by creating stride-$1$ access. This practice guides you through building a quantitative cost model to compare the performance of two loop orders, forcing you to weigh the competing locality benefits for different arrays. By translating concepts like cache lines, strides, and memory access costs into a concrete formula, you will gain a deeper understanding of how loop structure directly impacts program execution time. [@problem_id:3652895]", "problem": "Consider two dense, rectangular, two-dimensional arrays stored in row-major order: an array $A$ of shape $N \\times M$ and an array $B$ of shape $M \\times N$, where $N$ and $M$ are positive integers with $N \\geq 1$ and $M \\geq 1$. In row-major layout, the element $A[i][j]$ resides at address offset $i \\cdot M + j$ from the base of $A$, and $B[j][i]$ resides at address offset $j \\cdot N + i$ from the base of $B$. Consider the nested iteration space $\\{(i,j) \\mid 0 \\leq i \\leq N-1,\\ 0 \\leq j \\leq M-1\\}$ that performs a transpose-like computation: for each $(i,j)$, read $A[i][j]$ and write that value to $B[j][i]$. Loop interchange exchanges the order of iterating $i$ and $j$.\n\nUse the following fundamental base for locality and cost modeling:\n- In row-major order, the dimension associated with the rightmost index is contiguous in memory. Thus, with $i$ outer and $j$ inner, the access to $A[i][j]$ is stride-$1$ in memory (contiguous) while the access to $B[j][i]$ is a stride-$k$ stream with $k = N$. With $j$ outer and $i$ inner (interchanged), the access to $B[j][i]$ becomes stride-$1$ while the access to $A[i][j]$ becomes a stride-$k'$ stream with $k' = M$.\n- A cache line holds $L$ elements (assume $L \\geq 1$ is an integer), and the arrays are sufficiently large that there is no temporal reuse of a cache line once it is evicted; ignore capacity and conflict effects beyond spatial reuse within a line.\n- For reads, a cache hit costs $h_r$ cycles and a cache miss costs $c_r$ cycles, with $c_r \\geq h_r \\geq 0$.\n- For writes, assume a write-allocate, write-back policy: the first write to a cache line that is not present incurs an allocate-and-eventual-write-back cost of $c_{wa}$ cycles; subsequent writes to that same resident line hit at cost $h_w$ cycles, with $c_{wa} \\geq h_w \\geq 0$.\n- For a stride-$1$ stream, there is one miss per $L$ elements, followed by $L-1$ hits. For a stride-$s$ stream with $s \\geq L$, assume every access maps to a different cache line and thus misses.\n\nProvide a concrete example of the two loop orders by identifying which array has stride-$1$ and which has stride-$k$ in each order, and then construct a cost model as follows. Let $C_{\\text{orig}}$ denote the total expected execution cost (in cycles) when $i$ is the outer loop and $j$ is the inner loop, and let $C_{\\text{int}}$ denote the total expected execution cost (in cycles) when $j$ is the outer loop and $i$ is the inner loop (the interchanged order). Under the assumptions above, and further assuming $k = N \\geq L$ and $k' = M \\geq L$, derive a single, fully simplified, closed-form analytic expression for the difference\n$$\\Delta C \\triangleq C_{\\text{int}} - C_{\\text{orig}}$$\nas a function of $N$, $M$, $L$, $c_r$, $h_r$, $c_{wa}$, and $h_w$. Your final answer must be a single analytical expression. If you introduce any auxiliary quantities, they must be algebraically eliminated so that the final expression depends only on $N$, $M$, $L$, $c_r$, $h_r$, $c_{wa}$, and $h_w$. Express the final cost difference in cycles. No rounding is required.", "solution": "The problem requires deriving the cost difference between two loop orders for a matrix transpose operation. We will construct a cost model for each loop order and then compute their difference.\n\n**Total Iterations:** The total number of iterations is $N \\cdot M$. Each iteration performs one read from array $A$ and one write to array $B$.\n\n**Cost of the Original Loop Order ($C_{\\text{orig}}$)**\nIn the original order (`for i... for j...`), the inner loop iterates over $j$.\n1.  **Read cost from A ($C_{A, \\text{orig}}^{\\text{read}}$)**: The access to $A[i][j]$ is stride-1. For a stride-1 stream of $N \\cdot M$ elements, the total number of cache misses is $\\frac{N \\cdot M}{L}$ and the number of hits is $N \\cdot M \\cdot (1 - \\frac{1}{L})$.\n    - Total read cost: $C_{A, \\text{orig}}^{\\text{read}} = \\frac{N \\cdot M}{L} c_r + N \\cdot M \\frac{L-1}{L} h_r = \\frac{N \\cdot M}{L} (c_r + (L-1)h_r)$.\n\n2.  **Write cost to B ($C_{B, \\text{orig}}^{\\text{write}}$)**: The access to $B[j][i]$ has a stride of $N$. Since we assume $N \\geq L$, every access is a cache miss. Under the write-allocate policy, each of the $N \\cdot M$ writes incurs a miss cost.\n    - Total write cost: $C_{B, \\text{orig}}^{\\text{write}} = (N \\cdot M) \\cdot c_{wa}$.\n\n3.  **Total original cost ($C_{\\text{orig}}$)**:\n    $$C_{\\text{orig}} = C_{A, \\text{orig}}^{\\text{read}} + C_{B, \\text{orig}}^{\\text{write}} = \\frac{N \\cdot M}{L} (c_r + (L-1)h_r) + N \\cdot M \\cdot c_{wa}$$\n    $$C_{\\text{orig}} = N \\cdot M \\left( \\frac{c_r - h_r}{L} + h_r + c_{wa} \\right)$$\n\n**Cost of the Interchanged Loop Order ($C_{\\text{int}}$)**\nIn the interchanged order (`for j... for i...`), the inner loop iterates over $i$.\n1.  **Read cost from A ($C_{A, \\text{int}}^{\\text{read}}$)**: The access to $A[i][j]$ has a stride of $M$. Since we assume $M \\geq L$, every access is a cache miss.\n    - Total read cost: $C_{A, \\text{int}}^{\\text{read}} = (N \\cdot M) \\cdot c_r$.\n\n2.  **Write cost to B ($C_{B, \\text{int}}^{\\text{write}}$)**: The access to $B[j][i]$ is stride-1. This is analogous to the read case for the original loop, but with write costs. For a stride-1 stream of $N \\cdot M$ elements, there are $\\frac{N \\cdot M}{L}$ write misses and $N \\cdot M \\cdot (1 - \\frac{1}{L})$ write hits.\n    - Total write cost: $C_{B, \\text{int}}^{\\text{write}} = \\frac{N \\cdot M}{L} c_{wa} + N \\cdot M \\frac{L-1}{L} h_w = \\frac{N \\cdot M}{L} (c_{wa} + (L-1)h_w)$.\n\n3.  **Total interchanged cost ($C_{\\text{int}}$)**:\n    $$C_{\\text{int}} = C_{A, \\text{int}}^{\\text{read}} + C_{B, \\text{int}}^{\\text{write}} = N \\cdot M \\cdot c_r + \\frac{N \\cdot M}{L} (c_{wa} + (L-1)h_w)$$\n    $$C_{\\text{int}} = N \\cdot M \\left( c_r + \\frac{c_{wa} - h_w}{L} + h_w \\right)$$\n\n**Derivation of the Cost Difference ($\\Delta C$)**\nNow, we compute the difference $\\Delta C = C_{\\text{int}} - C_{\\text{orig}}$.\n$$\\Delta C = N \\cdot M \\left( c_r + h_w + \\frac{c_{wa} - h_w}{L} \\right) - N \\cdot M \\left( h_r + c_{wa} + \\frac{c_r - h_r}{L} \\right)$$\nFactor out the common term $N \\cdot M$:\n$$\\frac{\\Delta C}{N \\cdot M} = \\left( c_r + h_w + \\frac{c_{wa}}{L} - \\frac{h_w}{L} \\right) - \\left( h_r + c_{wa} + \\frac{c_r}{L} - \\frac{h_r}{L} \\right)$$\nGroup terms by the cost parameters:\n$$\\frac{\\Delta C}{N \\cdot M} = (c_r - \\frac{c_r}{L}) - (h_r - \\frac{h_r}{L}) - (c_{wa} - \\frac{c_{wa}}{L}) + (h_w - \\frac{h_w}{L})$$\n$$\\frac{\\Delta C}{N \\cdot M} = c_r\\left(1 - \\frac{1}{L}\\right) - h_r\\left(1 - \\frac{1}{L}\\right) - c_{wa}\\left(1 - \\frac{1}{L}\\right) + h_w\\left(1 - \\frac{1}{L}\\right)$$\nFactor out the common term $\\left(1 - \\frac{1}{L}\\right)$:\n$$\\frac{\\Delta C}{N \\cdot M} = \\left(1 - \\frac{1}{L}\\right) (c_r - h_r - c_{wa} + h_w)$$\n$$\\frac{\\Delta C}{N \\cdot M} = \\frac{L-1}{L} (c_r - h_r + h_w - c_{wa})$$\nFinally, multiplying by $N \\cdot M$ yields the fully simplified expression for $\\Delta C$:\n$$\\Delta C = N \\cdot M \\cdot \\frac{L-1}{L} (c_r - h_r + h_w - c_{wa})$$\nThis expression is a function of only the specified variables $N, M, L, c_r, h_r, c_{wa}$, and $h_w$, as required.", "answer": "$$\\boxed{N \\cdot M \\cdot \\frac{L-1}{L} (c_r - h_r + h_w - c_{wa})}$$", "id": "3652895"}, {"introduction": "While many examples focus on simple rectangular loops, real-world code often contains non-rectangular iteration spaces, such as the triangular loops found in linear algebra algorithms. Interchanging such loops introduces an additional challenge: correctly transforming the loop bounds to preserve the original set of computations. This problem combines the dependence analysis from our first exercise with the geometric reasoning needed to derive the new bounds for a triangular loop, ensuring you can apply loop interchange correctly in more complex and practical scenarios. [@problem_id:3652944]", "problem": "Consider a two-level loop nest defining the triangular iteration space $\\mathcal{D} = \\{(i,j) \\mid 0 \\le j \\le i  n\\}$ where $n$ is a positive integer. The body consists of a single statement $S(i,j)$ that writes to a memory location indexed by $(i,j)$ and, for $j \\ge 1$, reads the memory location indexed by $(i,j-1)$:\n$$\nS(i,j):\\quad X[i,j] \\leftarrow F\\big(X[i,j],\\,X[i,j-1]\\big) \\quad \\text{for } j \\ge 1,\n$$\nand for the boundary case $j=0$,\n$$\nS(i,0):\\quad X[i,0] \\leftarrow F_0\\big(X[i,0]\\big),\n$$\nwhere $F(\\cdot,\\cdot)$ and $F_0(\\cdot)$ are pure functions with no side effects. The original execution order is lexicographic by $(i,j)$: the iteration $(i_s,j_s)$ precedes $(i_t,j_t)$ if and only if either $i_s  i_t$, or $i_s = i_t$ and $j_s  j_t$.\n\nYou are to reason from the following foundational base:\n- A data dependence exists from $S(i_s,j_s)$ to $S(i_t,j_t)$ if $S(i_t,j_t)$ reads a memory location that $S(i_s,j_s)$ wrote, and the execution must preserve the program semantics by ensuring that the source iteration precedes the sink iteration in the chosen lexicographic order.\n- A dependence direction vector $(d_i,d_j)$ records, for the source $(i_s,j_s)$ and sink $(i_t,j_t)$, the component-wise comparison outcomes with $d_k \\in \\{,=,\\}$, where $$ means $k_s  k_t$, $=$ means $k_s = k_t$, and $$ means $k_s  k_t$.\n- A loop interchange that permutes the schedule from $(i,j)$ to $(j,i)$ is legal if, for every dependence, the source still lexicographically precedes the sink under the permuted order. Equivalently, under the permuted order, the first non-equal component of the dependence direction vector must be $$.\n\nTasks:\n1. Using the definitions above, determine the dependence direction vector(s) induced by $S(i,j)$ within $\\mathcal{D}$ in the original order $(i,j)$.\n2. State the condition on these dependence direction vector(s) that ensures loop interchange from $(i,j)$ to $(j,i)$ is legal, expressed in terms of the first non-equal component under the permuted order.\n3. Derive the transformed bounds that preserve the triangular iteration space after interchange so that the interchanged iteration space $\\mathcal{D}'$ satisfies $\\mathcal{D}' = \\mathcal{D}$ as sets of index pairs, but is ordered lexicographically by $(j,i)$.\n4. Compute, as a function of $n$, the total number of dynamic executions of $S$ under the interchanged bounds that preserve the triangular iteration space. Provide your final answer as a single closed-form expression. No rounding is required.", "solution": "The solution addresses the four tasks in the specified order.\n\n**1. Dependence Direction Vector(s)**\nA data dependence arises when one statement instance (the sink) reads a memory location that was previously written by another statement instance (the source). We analyze the statement $S(i,j)$ for $j \\ge 1$, which is $X[i,j] \\leftarrow F\\big(X[i,j],\\,X[i,j-1]\\big)$.\n\nA dependence exists if a sink iteration $S(i_t, j_t)$ reads a location written by a source iteration $S(i_s, j_s)$.\n*   The memory location written by the source $S(i_s, j_s)$ is $X[i_s, j_s]$.\n*   The memory location read by the sink $S(i_t, j_t)$ is $X[i_t, j_t-1]$. This read is conditional on $j_t \\ge 1$.\n\nFor a flow dependence to exist, the location written by the source must be the same as the location read by the sink. Therefore, their indices must be equal:\n$$i_s = i_t$$\n$$j_s = j_t - 1$$\nThis establishes the relationship between a source-sink pair. The source iteration is $(i_s, j_s) = (i_t, j_t-1)$ and the sink iteration is $(i_t, j_t)$.\n\nFor this dependence to be present in the program, both the source and sink iterations must lie within the iteration space $\\mathcal{D}$:\n*   Sink: $(i_t, j_t) \\in \\mathcal{D} \\implies 0 \\le j_t \\le i_t  n$.\n*   Source: $(i_t, j_t-1) \\in \\mathcal{D} \\implies 0 \\le j_t-1 \\le i_t  n$.\n\nThe condition $j_t-1 \\ge 0$ implies $j_t \\ge 1$, which is consistent with the condition for the read access to occur. Thus, such a dependence exists for all iterations $(i_t, j_t)$ where $1 \\le j_t \\le i_t  n$.\n\nThe dependence direction vector $(d_i, d_j)$ is defined by the relationship between source and sink indices:\n*   $d_i$: Since $i_s = i_t$, the direction is $=$.\n*   $d_j$: Since $j_s = j_t - 1$, we have $j_s  j_t$, so the direction is $$.\n\nThe only loop-carried dependence in this loop nest is characterized by the direction vector $(=, )$. This vector is lexicographically positive in the original $(i,j)$ order, confirming the validity of the original loop execution.\n\n**2. Legality of Loop Interchange**\nA loop interchange transforming the execution order from $(i,j)$ to $(j,i)$ is legal if and only if all dependence vectors remain lexicographically positive after permuting their components in the same way as the loops.\nThe original dependence direction vector is $(=, )$.\nAfter permuting the loop order to $(j,i)$, the dependence direction vector's components are also permuted, yielding the new vector $(, =)$.\nTo test for legality, we check if this permuted vector is lexicographically positive. The rule states that the first non-equal component must be $$. In the vector $(, =)$, the first component is $$. Therefore, this condition is satisfied. The loop interchange is legal.\n\n**3. Transformed Loop Bounds**\nThe original iteration space $\\mathcal{D}$ is defined by the set of inequalities:\n$$0 \\le j \\le i  n$$\nThis can be expressed as a set of three constraints on any point $(i,j) \\in \\mathcal{D}$:\n1. $j \\ge 0$\n2. $i \\ge j$\n3. $i \\le n-1$\n\nTo find the bounds for the interchanged loop, where $j$ is the outer loop and $i$ is the inner loop, we first find the overall range of $j$. From constraint (1), $j$ has a lower bound of $0$. From constraints (2) and (3), we have $j \\le i$ and $i \\le n-1$, which implies $j \\le n-1$. Combining these, the outer $j$-loop runs over the range:\n$$0 \\le j \\le n-1$$\nFor any fixed value of $j$ in this range, we find the bounds for the inner $i$-loop. Constraints (2) and (3) directly provide these bounds:\n$$j \\le i \\le n-1$$\nTherefore, the transformed loop nest that preserves the iteration space is:\n`for j from` $0$ `to` $n-1$:\n`  for i from` $j$ `to` $n-1$:\n`    S(i,j)`\nThe transformed bounds are $j \\in [0, n-1]$ and $i \\in [j, n-1]$.\n\n**4. Total Number of Dynamic Executions**\nThe total number of dynamic executions of the statement $S$ is the cardinality of the iteration space, $|\\mathcal{D}|$, which is preserved by the loop interchange transformation. We can calculate this count using the new, interchanged loop bounds. The total number of executions, $N_{exec}$, is the sum over the transformed iteration space:\n$$N_{exec} = \\sum_{j=0}^{n-1} \\sum_{i=j}^{n-1} 1$$\nWe first evaluate the inner sum, which counts the number of iterations of the $i$-loop for a fixed $j$:\n$$\\sum_{i=j}^{n-1} 1 = (n-1) - j + 1 = n - j$$\nSubstituting this back into the outer sum gives:\n$$N_{exec} = \\sum_{j=0}^{n-1} (n - j)$$\nThis is an arithmetic series. We can re-index by letting $k = n-j$. As $j$ ranges from $0$ to $n-1$, $k$ ranges from $n$ down to $1$. The sum is equivalent to:\n$$N_{exec} = \\sum_{k=1}^{n} k$$\nThis is the sum of the first $n$ positive integers, which has the well-known closed-form solution:\n$$N_{exec} = \\frac{n(n+1)}{2}$$\nThis expression represents the total number of dynamic executions of $S$ as a function of $n$.", "answer": "$$\\boxed{\\frac{n(n+1)}{2}}$$", "id": "3652944"}]}