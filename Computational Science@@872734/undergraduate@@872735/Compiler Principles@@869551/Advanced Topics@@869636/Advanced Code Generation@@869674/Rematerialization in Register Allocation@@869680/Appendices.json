{"hands_on_practices": [{"introduction": "The core of rematerialization lies in a fundamental trade-off: is it cheaper to re-calculate a value from scratch or to load it from memory? This exercise guides you through deriving a simple but powerful mathematical threshold that allows a compiler to make this decision quantitatively. By formalizing the costs of spilling versus recomputing, you will establish the foundational cost-benefit analysis for this optimization. [@problem_id:3668340]", "problem": "A compiler performing Register Allocation (RA) must decide, for a value whose live range cannot be entirely assigned to a register, whether to spill the value to memory and reload it at each use, or to rematerialize the value at each use by recomputing it from its operands. Consider a cost model in which all dynamic costs add linearly across independent events and are measured in machine cycles per execution. Let $C_{\\text{spill}}$ denote the total dynamic cost accrued over the entire live range if the value is spilled, including any one-time store and all reloads. Let $C_{\\text{rm}}$ denote the per-use dynamic cost of rematerializing the value (for example, the cost of regenerating an immediate and applying a simple arithmetic operation). Let $U$ denote the dynamic use count of the value across the programâ€™s execution profile, defined as the sum of execution counts of all static use sites.\n\nStarting only from these definitions and the assumption of linear additivity of independent costs, derive a threshold expression $C_{\\text{rm}}^{*}$ in terms of $C_{\\text{spill}}$ and $U$ such that choosing rematerialization minimizes the total dynamic cost precisely when $C_{\\text{rm}}$ is below this threshold. State the decision criterion in terms of $C_{\\text{rm}}$ and $C_{\\text{rm}}^{*}$.\n\nThen validate the expression with the following worked example. A value $v$ has three static uses: one in basic block $B_{1}$ executed $10$ times, one in $B_{2}$ executed $2$ times, and one in $B_{3}$ executed $2$ times, so that the dynamic use count is the sum across these sites. If spilled, $v$ incurs a one-time store cost of $c_{s} = 12$ cycles and a reload cost of $c_{\\ell} = 6$ cycles per dynamic use, so the total spill cost is the one-time store plus the sum of reloads across all dynamic uses. If rematerialized, $v$ can be recomputed at each use by loading an immediate and performing a single arithmetic operation with costs $c_{\\text{imm}} = 2$ cycles and $c_{\\text{op}} = 1$ cycle respectively, so the per-use rematerialization cost is the sum of these operation costs.\n\nCompute:\n1. The threshold $C_{\\text{rm}}^{*}$.\n2. The decision indicator $D$, where $D = 1$ if rematerialization is selected and $D = 0$ otherwise.\n\nExpress the numerical threshold in machine cycles per use and the decision indicator as a dimensionless value. Report your final answer as a row matrix $\\begin{pmatrix} C_{\\text{rm}}^{*} & D \\end{pmatrix}$.", "solution": "The problem requires the derivation of a decision criterion for choosing between two compiler optimization strategies for a value that cannot be held in a register for its entire live range: spilling to memory or rematerialization. The decision is to be based on minimizing the total dynamic cost, measured in machine cycles.\n\nFirst, we establish the total dynamic cost for each strategy based on the provided definitions. Let $C_{\\text{total, spill}}$ be the total cost of the spilling strategy and $C_{\\text{total, rm}}$ be the total cost of the rematerialization strategy.\n\nThe problem defines $C_{\\text{spill}}$ as the total dynamic cost for the spilling strategy, which includes a one-time store and all subsequent reloads. Thus, we have:\n$$C_{\\text{total, spill}} = C_{\\text{spill}}$$\n\nThe problem defines $C_{\\text{rm}}$ as the per-use dynamic cost of rematerializing the value. The total number of dynamic uses of the value is given by $U$. The problem states that costs add linearly across independent events. Since rematerialization is performed at each of the $U$ dynamic uses, the total cost for this strategy is the per-use cost multiplied by the number of uses:\n$$C_{\\text{total, rm}} = C_{\\text{rm}} \\times U$$\n\nTo minimize the total dynamic cost, the compiler should choose rematerialization if and only if its total cost is strictly less than the total cost of spilling. This gives us the following inequality:\n$$C_{\\text{total, rm}} < C_{\\text{total, spill}}$$\nSubstituting the expressions for the total costs, we get:\n$$C_{\\text{rm}} \\times U < C_{\\text{spill}}$$\n\nThe problem asks for a threshold, $C_{\\text{rm}}^{*}$, such that rematerialization is the optimal choice precisely when $C_{\\text{rm}} < C_{\\text{rm}}^{*}$. To derive this threshold, we isolate $C_{\\text{rm}}$ in the inequality. Assuming the value is used at least once, the dynamic use count $U$ is a positive integer ($U \\ge 1$). Therefore, we can divide both sides of the inequality by $U$ without altering its direction:\n$$C_{\\text{rm}} < \\frac{C_{\\text{spill}}}{U}$$\nBy comparing this inequality to the required form $C_{\\text{rm}} < C_{\\text{rm}}^{*}$, we can directly identify the threshold $C_{\\text{rm}}^{*}$:\n$$C_{\\text{rm}}^{*} = \\frac{C_{\\text{spill}}}{U}$$\nThe decision criterion is: select rematerialization if $C_{\\text{rm}} < C_{\\text{rm}}^{*}$; otherwise, select spilling.\n\nNext, we apply this formal derivation to the worked example to compute the numerical values for $C_{\\text{rm}}^{*}$ and the decision indicator $D$.\n\n1.  **Compute the dynamic use count, $U$**.\n    $U$ is the sum of the execution counts of all static use sites.\n    $$U = 10 + 2 + 2 = 14$$\n\n2.  **Compute the total spill cost, $C_{\\text{spill}}$**.\n    This cost consists of a one-time store cost, $c_{s} = 12$ cycles, and a reload cost, $c_{\\ell} = 6$ cycles, incurred for each of the $U$ dynamic uses.\n    $$C_{\\text{spill}} = c_{s} + (c_{\\ell} \\times U) = 12 + (6 \\times 14) = 12 + 84 = 96$$\n    The total spill cost is $96$ cycles.\n\n3.  **Compute the per-use rematerialization cost, $C_{\\text{rm}}$**.\n    This cost is the sum of the cost to load an immediate, $c_{\\text{imm}} = 2$ cycles, and the cost of a single arithmetic operation, $c_{\\text{op}} = 1$ cycle.\n    $$C_{\\text{rm}} = c_{\\text{imm}} + c_{\\text{op}} = 2 + 1 = 3$$\n    The per-use rematerialization cost is $3$ cycles per use.\n\n4.  **Compute the threshold, $C_{\\text{rm}}^{*}$**.\n    Using the derived formula and the computed values for $C_{\\text{spill}}$ and $U$:\n    $$C_{\\text{rm}}^{*} = \\frac{C_{\\text{spill}}}{U} = \\frac{96}{14} = \\frac{48}{7}$$\n    The threshold is $\\frac{48}{7}$ machine cycles per use.\n\n5.  **Determine the decision indicator, $D$**.\n    We apply the decision criterion by comparing the actual per-use cost $C_{\\text{rm}}$ with the threshold $C_{\\text{rm}}^{*}$:\n    $$C_{\\text{rm}} = 3$$\n    $$C_{\\text{rm}}^{*} = \\frac{48}{7} \\approx 6.857$$\n    The inequality to check is $C_{\\text{rm}} < C_{\\text{rm}}^{*}$, which is $3 < \\frac{48}{7}$. Multiplying both sides by $7$ gives $21 < 48$, which is true.\n    Since the condition is met, rematerialization is the cost-minimizing strategy. The problem defines the decision indicator $D$ to be $1$ if rematerialization is selected. Therefore:\n    $$D = 1$$", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{48}{7} & 1 \\end{pmatrix}}$$", "id": "3668340"}, {"introduction": "After establishing the cost trade-off, it is crucial to understand *why* rematerialization is so effective. This practice explores the underlying impact of this technique on the register allocation process itself. You will analyze how rematerializing a value shortens its live range, which in turn can reduce its interference with other values, ultimately lowering register pressure and making the allocator's job easier. [@problem_id:3668375]", "problem": "Consider a loop with induction variable $i$ and an address expression $a = \\text{base} + i \\cdot \\text{stride}$ used inside the loop and also used once immediately after the loop. Assume the following canonical control flow: a preheader initializes $i$, a single-entry single-exit loop updates $i$ by a fixed increment $\\text{stride}$ each iteration and terminates when $i$ reaches a bound $N$, and there is an exit block that uses $a$ exactly once. The target architecture supports a single-instruction computation of $a$ from $\\text{base}$, $i$, and $\\text{stride}$.\n\nThe register allocator currently keeps a virtual register $v_a$ holding the running value of $a$ across the loop and into the exit block (for example, by computing $a$ once and then updating it by adding $\\text{stride}$ each iteration). Consider instead a rematerialization transformation that does not carry $v_a$ across the loop and instead recomputes $a$ at the exit from $\\text{base}$, $i$, and $\\text{stride}$ in a fresh virtual register $v_a^{\\text{exit}}$.\n\nUse the following foundational definitions from compiler theory:\n- A variable is live at a program point if its current value may be read along some path starting at that point before being overwritten. The live range of a virtual register is the set of program points where it is live. A reduction in live range length means strictly fewer program points where it is live.\n- The interference graph has one node per virtual register, with an edge between two nodes if their live ranges overlap at any program point. The interference degree $\\Delta$ of a node is the number of its neighbors.\n\nAssume that $\\text{base}$, $i$, and $\\text{stride}$ are either already available at the exit or are themselves cheap to rematerialize so that recomputing $a$ in the exit block is legal and has negligible cost relative to a spill.\n\nWhich statement best characterizes the effect of rematerializing $a$ at the loop exit on the live range length and the interference degree $\\Delta$ of the original $v_a$?\n\nA. If $a$ is rematerialized at the exit, the live range of $v_a$ no longer spans the loop to the exit; it strictly shortens to end after the last in-loop use. Consequently, $v_a$ loses all interferences due to overlap with values outside the loop and cannot gain new ones in the exit, so its interference degree $\\Delta$ weakly decreases and never increases.\n\nB. Rematerializing $a$ at the exit does not affect the live range of $v_a$ because $a$ depends on $i$ updated in the loop; $v_a$ must remain live across the loop to maintain correctness, so $\\Delta$ is unchanged.\n\nC. Rematerializing $a$ at the exit lengthens the live range of $v_a$ because $i$ must be kept live to the exit, increasing the number of simultaneous live values and therefore increasing $\\Delta$ of $v_a$.\n\nD. The benefit depends on $\\text{stride}$: only when $\\text{stride} = 0$ or $\\text{stride} = 1$ can rematerialization shorten the live range; otherwise, the multiplication in $a = \\text{base} + i \\cdot \\text{stride}$ prevents any reduction in $\\Delta$ for $v_a$.", "solution": "The problem analyzes the effect of rematerializing a value after a loop, instead of keeping it live through the loop's exit. The core concepts are liveness, live ranges, and the interference graph.\n\n1.  **Analyze the live range of $v_a$ without rematerialization.**\n    In the original scenario, the virtual register $v_a$ holds the value of the expression $a$. This value is used within the loop and, crucially, is also used in the block immediately after the loop (the \"exit block\"). For the use in the exit block to be satisfied, the value in $v_a$ must be preserved from its last update inside the loop until its use in the exit block. By the definition of liveness, this means $v_a$ is live on the control-flow path from the last in-loop use, out of the loop, and into the exit block up to the point of its final use. Thus, the live range of $v_a$ spans the loop and extends into the exit block.\n\n2.  **Analyze the live range of $v_a$ with rematerialization.**\n    In the transformed scenario, the use of $a$ in the exit block is satisfied by a new computation (rematerialization). This means the original virtual register $v_a$ is no longer needed after the loop concludes. Its last use is now the final use that occurs *inside* the loop. After this point, the value in $v_a$ is never read again, so $v_a$ becomes \"dead\" as soon as the loop is exited. The live range of $v_a$ has been shortened; it no longer includes the program points between the loop and the use in the exit block. This is a strict reduction.\n\n3.  **Analyze the effect on the interference degree, $\\Delta(v_a)$.**\n    The interference degree $\\Delta(v_a)$ is the number of other virtual registers whose live ranges overlap with that of $v_a$. Since the new live range of $v_a$ is a strict subset of the old live range, two consequences follow:\n    *   **No new interferences:** A new interference with another register $v_x$ cannot be created, because if the new (smaller) live range of $v_a$ overlaps with $v_x$'s live range, the old (larger) live range must also have overlapped.\n    *   **Potential removal of interferences:** It's possible that an interference with another register $v_x$ existed only in the portion of $v_a$'s live range that was removed (i.e., the part after the loop). In this case, shortening the live range of $v_a$ eliminates this interference, decreasing its interference degree.\n    Combining these points, the interference degree $\\Delta(v_a)$ can either decrease or stay the same. It can never increase. This is known as a \"weak decrease\".\n\n4.  **Evaluate the options.**\n    *   **A:** This option correctly states that the live range of $v_a$ is strictly shortened, ending after the last in-loop use. It also correctly concludes that the interference degree weakly decreases (and never increases). This matches our analysis perfectly.\n    *   **B:** This is incorrect. The purpose of rematerialization is precisely to break the need for $v_a$ to remain live. The dependency on $i$ is handled by using the final value of $i$ for the recomputation, not by preserving $v_a$.\n    *   **C:** This is incorrect. The live range of $v_a$ is shortened, not lengthened. While the liveness of operands like $i$ might be affected, this does not lengthen the live range of the original value $v_a$.\n    *   **D:** This is incorrect. The logic of live range shortening via rematerialization is based on dataflow, not on the specific arithmetic operations like multiplication or the value of `stride`. The transformation is valid regardless of the specific computation as long as it is rematerializable.\n\nTherefore, option A provides the best characterization.", "answer": "$$\\boxed{A}$$", "id": "3668375"}, {"introduction": "In a real compiler, optimization decisions are not made in isolation. This final exercise elevates the concept to a global optimization challenge by framing it as a resource allocation problem under a fixed budget. You will determine the optimal set of values to rematerialize to maximize performance gains, revealing how local cost-benefit analyses must fit into a broader, budget-constrained strategy. [@problem_id:3668299]", "problem": "Consider a compiler performing register allocation on an Intermediate Representation (IR). When the register pressure exceeds a threshold, the allocator inserts memory spills, which incur dynamic execution cost. Rematerialization is permitted for a subset of values that are pure and inexpensive to recompute; by recomputing such values at their use sites, the allocator can eliminate some spills at the expense of inserting extra instructions. Assume the following model, grounded in standard compiler cost accounting: the dynamic spill cost reduction contributed by rematerializing a value is additive across independent values, and the dynamic count of extra instructions introduced by rematerialization is additive across chosen values. Let $B$ denote the maximum allowed total dynamic count of extra instructions due to rematerialization.\n\nYou are given $6$ rematerializable values $v_1, v_2, v_3, v_4, v_5, v_6$. For each value $v_i$, you are given:\n- $c_i$: the dynamic count of extra instructions required if $v_i$ is rematerialized wherever needed.\n- $S_i$: the dynamic spill cost reduction achieved if $v_i$ is rematerialized wherever needed.\n\nThe data are:\n- $v_1$: $c_1 = 9$, $S_1 = 37$.\n- $v_2$: $c_2 = 5$, $S_2 = 20$.\n- $v_3$: $c_3 = 5$, $S_3 = 20$.\n- $v_4$: $c_4 = 4$, $S_4 = 16$.\n- $v_5$: $c_5 = 3$, $S_5 = 9$.\n- $v_6$: $c_6 = 2$, $S_6 = 7$.\n\nThe budget is $B = 10$. The goal is to select a subset $X \\subset \\{v_1,\\dots,v_6\\}$ that maximizes the total spill cost reduction $\\sum_{v_i \\in X} S_i$ subject to the budget constraint $\\sum_{v_i \\in X} c_i \\leq B$.\n\nPerform the following:\n1. Apply the greedy heuristic that sorts values by decreasing ratio $S_i / c_i$ and selects values in that order while respecting the budget $B$. If ratios are equal, break ties by any consistent rule; your answer must still be correct under the given data. Compute the greedy-selected set and its total spill cost reduction.\n2. Compute the optimal subset that maximizes $\\sum_{v_i \\in X} S_i$ under $\\sum_{v_i \\in X} c_i \\leq B$.\n3. Let $R$ be the ratio of the greedy total spill cost reduction to the optimal total spill cost reduction. Express $R$ as a simplified exact fraction. Do not round.\nYour final answer must be the single value of $R$.", "solution": "This problem is an instance of the 0/1 Knapsack Problem, a classic optimization problem. We are asked to select a subset of items (rematerializable values) to maximize total value (spill cost reduction, $S_i$) without exceeding a total weight capacity (instruction budget, $B$). The items are defined by their cost $c_i$ and benefit $S_i$.\n\n**1. Apply the Greedy Heuristic**\n\nThe greedy approach requires sorting the values by their benefit-to-cost ratio, $S_i / c_i$, in descending order.\n\nFirst, we calculate the ratios:\n- $v_1: S_1 / c_1 = 37 / 9 \\approx 4.11$\n- $v_2: S_2 / c_2 = 20 / 5 = 4.00$\n- $v_3: S_3 / c_3 = 20 / 5 = 4.00$\n- $v_4: S_4 / c_4 = 16 / 4 = 4.00$\n- $v_5: S_5 / c_5 = 9 / 3 = 3.00$\n- $v_6: S_6 / c_6 = 7 / 2 = 3.50$\n\nThe sorted order of values by decreasing ratio is: $v_1, (v_2, v_3, v_4), v_6, v_5$.\nNow, we select items from this list as long as they fit within the budget $B=10$.\n- **Select $v_1$**: cost $c_1=9$. This fits in the budget.\n  - Selected set: $\\{v_1\\}$\n  - Total cost: $9$\n  - Total benefit: $37$\n  - Remaining budget: $10 - 9 = 1$.\n- **Consider $v_2$**: cost $c_2=5$. This does not fit in the remaining budget of $1$.\n- No other item can fit in the remaining budget.\n\nThe greedy heuristic selects the set $\\{v_1\\}$, for a total spill cost reduction of $S_{\\text{greedy}} = 37$.\n\n**2. Compute the Optimal Solution**\n\nFor a small number of items, we can find the optimal solution by examining combinations of items that fit within the budget $B=10$. This is equivalent to solving the 0/1 knapsack problem.\n\nLet's test key combinations:\n- **Greedy solution:** $\\{v_1\\}$ gives a cost of $9$ and a benefit of $37$.\n- **Combination of high-ratio items:** The items $v_2, v_3, v_4$ have a high ratio.\n  - $\\{v_2, v_3\\}$: cost $c_2+c_3 = 5+5=10$. Benefit $S_2+S_3 = 20+20=40$. This fits the budget exactly.\n  - $\\{v_2, v_4\\}$: cost $c_2+c_4 = 5+4=9$. Benefit $S_2+S_4 = 20+16=36$.\n- **Combination of small-cost items:**\n  - $\\{v_4, v_5, v_6\\}$: cost $c_4+c_5+c_6 = 4+3+2=9$. Benefit $S_4+S_5+S_6 = 16+9+7=32$.\n  - $\\{v_2, v_5, v_6\\}$: cost $c_2+c_5+c_6 = 5+3+2=10$. Benefit $S_2+S_5+S_6 = 20+9+7=36$.\n\nComparing the total benefits of the valid combinations:\n- Benefit of $\\{v_1\\}$ is $37$.\n- Benefit of $\\{v_2, v_3\\}$ is $40$.\n- Benefit of $\\{v_2, v_4\\}$ is $36$.\n- Benefit of $\\{v_2, v_5, v_6\\}$ is $36$.\n\nThe maximum benefit is $40$, achieved by selecting the set $\\{v_2, v_3\\}$. This is the optimal solution.\n$S_{\\text{optimal}} = 40$.\n\n**3. Compute the Ratio R**\n\nThe ratio $R$ is the greedy solution's benefit divided by the optimal solution's benefit.\n$$R = \\frac{S_{\\text{greedy}}}{S_{\\text{optimal}}} = \\frac{37}{40}$$\nThe fraction $\\frac{37}{40}$ is already in its simplest form, as $37$ is a prime number and not a factor of $40$.", "answer": "$$\n\\boxed{\\frac{37}{40}}\n$$", "id": "3668299"}]}