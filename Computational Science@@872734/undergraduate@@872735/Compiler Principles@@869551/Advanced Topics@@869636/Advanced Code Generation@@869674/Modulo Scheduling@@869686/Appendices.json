{"hands_on_practices": [{"introduction": "Before building a complex schedule, it's essential to develop an intuition for how one behaves. This first exercise places you in the role of a performance analyst. By examining a raw execution trace from a software-pipelined loop, you will reverse-engineer its core properties. This practice will solidify your understanding of the Initiation Interval ($II$) and the repeating \"kernel\" pattern, which are the fundamental concepts of modulo scheduling [@problem_id:3658362].", "problem": "You are given a steady-state hardware issue trace produced by a software-pipelined loop under modulo scheduling. In each loop iteration, exactly one load, one multiply, and one add are executed, denoted respectively by $\\mathrm{L}$, $\\mathrm{M}$, and $\\mathrm{A}$. The modulo schedule’s Initiation Interval (II) is unknown. By definition, the Initiation Interval (II) is the constant number of cycles between the issue times of corresponding operations from successive iterations in the steady state. In the kernel (the repeating steady-state pattern), each operation has a fixed kernel offset modulo $II$.\n\nA time-stamped trace of issued operations over the cycle window $t \\in [\\,1, 35\\,]$ is observed. The trace (grouped by operation type) is:\n- $\\mathrm{L}$ issues at cycles $ \\{\\, 1, 6, 11, 16, 21, 26, 31 \\,\\}$.\n- $\\mathrm{M}$ issues at cycles $ \\{\\, 3, 8, 13, 18, 23, 28, 33 \\,\\}$.\n- $\\mathrm{A}$ issues at cycles $ \\{\\, 4, 9, 14, 19, 24, 29, 34 \\,\\}$.\n\nAssume:\n- The listed window lies within the loop’s steady state (ignore any prologue or epilogue outside $[\\,1, 35\\,]$).\n- The machine can issue at most one instance of each operation type per cycle, and the given times are issue times (not completion times).\n- There are no dropped or extraneous records in the trace within the window.\n\nTask:\n- From first principles, infer the Initiation Interval $II$ by detecting periodicity in the occurrence of corresponding operations across successive iterations.\n- Reconstruct the kernel offsets $o_{\\mathrm{L}}$, $o_{\\mathrm{M}}$, and $o_{\\mathrm{A}}$ modulo $II$ for the operations $\\mathrm{L}$, $\\mathrm{M}$, and $\\mathrm{A}$, respectively, using the observed periodic structure.\n\nReport only the value of $II$ as your final answer. Express it as an exact integer; no rounding is required.", "solution": "The problem statement is critically evaluated and found to be valid. It is scientifically grounded in the principles of compiler theory and computer architecture, specifically instruction scheduling for pipelined processors. The problem is well-posed, objective, and contains sufficient, consistent data to determine a unique solution.\n\nThe core principle for solving this problem is the definition of the Initiation Interval ($II$) in the context of modulo scheduling. For a loop in its steady state, the $II$ is the constant number of clock cycles separating the issue times of corresponding operations from successive loop iterations. Let $t_{op, i}$ denote the issue time of a specific operation type, $op$, in iteration $i$. Then, for any two consecutive iterations $i$ and $i+1$, the relationship is:\n$$t_{op, i+1} = t_{op, i} + II$$\nThis implies that the sequence of issue times for any given operation type must form an arithmetic progression with a common difference equal to the Initiation Interval, $II$. We will now analyze the provided time-stamped trace for each operation type to determine this common period.\n\nFirst, we examine the issue times for the load operation, $\\mathrm{L}$. The set of observed issue times is:\n$$T_{\\mathrm{L}} = \\{1, 6, 11, 16, 21, 26, 31\\}$$\nWe compute the difference between consecutive time stamps in this sequence:\n$6 - 1 = 5$\n$11 - 6 = 5$\n$16 - 11 = 5$\n$21 - 16 = 5$\n$26 - 21 = 5$\n$31 - 26 = 5$\nThe difference is constant and equals $5$. Based on the definition of the Initiation Interval, this common difference represents the value of $II$. Thus, from the trace of operation $\\mathrm{L}$, we infer that $II = 5$.\n\nNext, we perform the same analysis for the multiply operation, $\\mathrm{M}$. The set of observed issue times is:\n$$T_{\\mathrm{M}} = \\{3, 8, 13, 18, 23, 28, 33\\}$$\nWe compute the difference between consecutive time stamps:\n$8 - 3 = 5$\n$13 - 8 = 5$\n$18 - 13 = 5$\n$23 - 18 = 5$\n$28 - 23 = 5$\n$33 - 28 = 5$\nThe difference is again constant and equals $5$. This result is consistent with the analysis of operation $\\mathrm{L}$ and independently confirms that $II = 5$.\n\nFinally, we analyze the issue times for the add operation, $\\mathrm{A}$. The set of observed issue times is:\n$$T_{\\mathrm{A}} = \\{4, 9, 14, 19, 24, 29, 34\\}$$\nWe compute the difference between consecutive time stamps:\n$9 - 4 = 5$\n$14 - 9 = 5$\n$19 - 14 = 5$\n$24 - 19 = 5$\n$29 - 24 = 5$\n$34 - 29 = 5$\nThe difference is once more constant and equals $5$. The trace for operation $\\mathrm{A}$ provides a third, consistent verification that the Initiation Interval is $II = 5$.\n\nHaving rigorously analyzed the periodic behavior of all three operation types and found a consistent period of $5$ cycles, we conclude that the Initiation Interval is $II = 5$.\n\nThe problem also requires the reconstruction of the kernel offsets, denoted $o_{\\mathrm{L}}$, $o_{\\mathrm{M}}$, and $o_{\\mathrm{A}}$. The kernel offset for an operation is its issue time modulo the Initiation Interval, i.e., $o_{op} = t_{op} \\pmod{II}$. We can use any issue time from the respective trace.\nFor the load operation $\\mathrm{L}$, using the first issue time $t=1$:\n$$o_{\\mathrm{L}} = 1 \\pmod{5} = 1$$\nFor the multiply operation $\\mathrm{M}$, using the first issue time $t=3$:\n$$o_{\\mathrm{M}} = 3 \\pmod{5} = 3$$\nFor the add operation $\\mathrm{A}$, using the first issue time $t=4$:\n$$o_{\\mathrm{A}} = 4 \\pmod{5} = 4$$\nThe reconstructed kernel consists of the operations $\\mathrm{L}$, $\\mathrm{M}$, and $\\mathrm{A}$ being issued at cycles $1$, $3$, and $4$ respectively, within each repeating interval of $II=5$ cycles.\n\nThe final answer required is the value of the Initiation Interval, $II$.", "answer": "$$\\boxed{5}$$", "id": "3658362"}, {"introduction": "The efficiency of a software pipeline is governed by two primary factors: the availability of functional units and the data dependencies that chain operations together. This exercise guides you through the process of calculating both the resource-constrained ($ResMII$) and recurrence-constrained ($RecMII$) lower bounds for the initiation interval. You will then use these bounds to determine the optimal $II$ and construct a conflict-free schedule, providing a complete, foundational walkthrough of the modulo scheduling process [@problem_id:3658402].", "problem": "A compiler uses modulo scheduling to pipeline a loop on a machine with two Arithmetic Logic Units (ALUs) and one Multiply unit (MUL). The ALUs execute addition operations and the MUL executes multiplication operations. All functional units are fully pipelined with an issue rate of $1$ per cycle, and an operation occupies its unit for only the cycle in which it is issued. The add latency is $1$ cycle and the multiply latency is $2$ cycles; that is, an add produces its result $1$ cycle after it starts, and a multiply produces its result $2$ cycles after it starts.\n\nConsider the following loop body per iteration $i$:\n- $N_1$: $x_i \\leftarrow a_i + b_i$ (add),\n- $N_2$: $y_i \\leftarrow c_i + d_i$ (add),\n- $N_3$: $s_i \\leftarrow s_{i-1} + e_i$ (add, loop-carried dependence from iteration $i-1$ to $i$ with dependence distance $1$),\n- $N_4$: $z_i \\leftarrow x_i \\times k$ (multiply, depends on $N_1$ within the same iteration).\n\nAssume unlimited registers and that memory accesses are perfectly overlapped with computation (no additional resource or latency constraints from memory), and that only the stated functional units and latencies constrain scheduling.\n\nStarting from first principles about resource throughput and dependence timing in modulo scheduling, determine the resource-constrained Minimum Initiation Interval (ResMII) for this loop on the given machine, and then construct a conflict-free modulo scheduling kernel at the initiation interval equal to the computed $ResMII$. The kernel must:\n- assign each operation $N_1$, $N_2$, $N_3$, $N_4$ a modulo start time $t(N_j) \\in \\{0, 1, \\ldots, \\mathrm{II}-1\\}$,\n- respect the resource capacities at each modulo time (no more than $2$ adds and no more than $1$ multiply issued per modulo time),\n- satisfy all data-dependence timing constraints, including the loop-carried dependence.\n\nExpress your final answer as the numerical value of $ResMII$. No rounding is required.", "solution": "The user-provided problem statement has been analyzed and is deemed valid. It is a well-posed problem grounded in the principles of compiler theory and computer architecture, specifically in the area of instruction-level parallelism and software pipelining. All parameters and constraints are clearly defined, and there are no internal contradictions or factual inaccuracies.\n\nThe problem requires us to determine the resource-constrained Minimum Initiation Interval ($ResMII$) for a given loop body and to construct a valid modulo schedule for that $II$. The Initiation Interval ($II$) is the number of clock cycles between the start of successive iterations in a software-pipelined loop. The minimum possible $II$, denoted as $MII$, is constrained by both resource availability and loop-carried data dependencies.\n\nThe $MII$ is given by the maximum of two lower bounds: the Resource-constrained $MII$ ($ResMII$) and the Recurrence-constrained $MII$ ($RecMII$).\n$$\nMII = \\max(ResMII, RecMII)\n$$\n\nFirst, we calculate the $ResMII$. This is determined by the resource usage of the loop. For each resource type $r$, the minimum interval is the ceiling of the ratio of the number of operations requiring that resource, $N_r$, to the number of available functional units of that type, $R_r$. The overall $ResMII$ is the maximum over all resource types.\n$$\nResMII = \\max_{r} \\left\\lceil \\frac{N_r}{R_r} \\right\\rceil\n$$\nThe loop body contains the following operations:\n- $N_1$: add (ALU)\n- $N_2$: add (ALU)\n- $N_3$: add (ALU)\n- $N_4$: multiply (MUL)\n\nThe number of operations for each resource type is:\n- Adds for ALUs: $N_{ALU} = 3$\n- Multiplies for MULs: $N_{MUL} = 1$\n\nThe available machine resources are:\n- ALU units: $R_{ALU} = 2$\n- MUL units: $R_{MUL} = 1$\n\nThe $ResMII$ contributions from each resource type are:\n- For ALUs: $\\text{ResMII}_{\\text{ALU}} = \\left\\lceil \\frac{N_{ALU}}{R_{ALU}} \\right\\rceil = \\left\\lceil \\frac{3}{2} \\right\\rceil = \\lceil 1.5 \\rceil = 2$\n- For MULs: $\\text{ResMII}_{\\text{MUL}} = \\left\\lceil \\frac{N_{MUL}}{R_{MUL}} \\right\\rceil = \\left\\lceil \\frac{1}{1} \\right\\rceil = 1$\n\nThe overall $ResMII$ is the maximum of these values:\n$$\nResMII = \\max(2, 1) = 2\n$$\n\nNext, we calculate the $RecMII$. This is determined by loop-carried dependencies, also known as recurrences. For a recurrence cycle involving a sequence of operations, the $RecMII$ is the ceiling of the ratio of the sum of the latencies of the operations in the cycle to the sum of the dependence distances.\n$$\nRecMII = \\max_{\\text{recurrences } p} \\left\\lceil \\frac{\\sum_{\\text{ops } j \\in p} \\text{latency}(j)}{\\sum_{\\text{deps } e \\in p} \\text{distance}(e)} \\right\\rceil\n$$\nIn this problem, there is one specified recurrence:\n- The operation $N_3: s_i \\leftarrow s_{i-1} + e_i$ depends on its own result from the previous iteration. This forms a recurrence cycle $N_3 \\to N_3$.\n- The latency of the operation $N_3$ (add) is $L(N_3) = 1$ cycle.\n- The dependence distance is given as $\\delta = 1$ iteration.\n\nThe $RecMII$ for this recurrence is:\n$$\nRecMII = \\left\\lceil \\frac{L(N_3)}{\\delta} \\right\\rceil = \\left\\lceil \\frac{1}{1} \\right\\rceil = 1\n$$\n\nNow, we can find the overall Minimum Initiation Interval ($MII$):\n$$\nMII = \\max(ResMII, RecMII) = \\max(2, 1) = 2\n$$\nThe smallest possible initiation interval is $2$ cycles. The problem asks for the value of $ResMII$, which we calculated to be $2$. We must now verify that a conflict-free schedule can be constructed for an $II = ResMII = 2$.\n\nA modulo schedule assigns a start time $t(N_j) \\in \\{0, 1, \\dots, II-1\\}$ to each operation $N_j$ in the loop body. For $II=2$, the possible times are $t=0$ and $t=1$. The schedule must satisfy both resource and dependence constraints.\n\nThe data dependence constraints are expressed by the inequality for a dependence from operation $N_u$ to $N_v$ with latency $L(N_u)$ and distance $\\delta$:\n$$\nt(N_u) + L(N_u) \\le t(N_v) + \\delta \\times II\n$$\nLet's analyze the dependencies for our problem with $II=2$:\n1.  Intra-iteration dependence $N_1 \\to N_4$:\n    - $N_u=N_1$, $N_v=N_4$, $L(N_1)=1$ (add latency), $\\delta=0$.\n    - $t(N_1) + 1 \\le t(N_4) + 0 \\times 2 \\implies t(N_1) + 1 \\le t(N_4)$.\n2.  Loop-carried dependence $N_3 \\to N_3$:\n    - $N_u=N_3$, $N_v=N_3$, $L(N_3)=1$ (add latency), $\\delta=1$.\n    - $t(N_3) + 1 \\le t(N_3) + 1 \\times 2 \\implies 1 \\le 2$. This is a trivial constraint, always satisfied, and confirms our $RecMII$ calculation.\n\nThe primary scheduling constraint is $t(N_1) + 1 \\le t(N_4)$. Since $t(N_1)$ and $t(N_4)$ must be in $\\{0, 1\\}$, this inequality can only be satisfied if $t(N_1)=0$ and $t(N_4)=1$.\n\nLet's fix these assignments and schedule the remaining operations, $N_2$ (add) and $N_3$ (add).\n- Schedule at time $t=0$: We have scheduled $N_1$ (add). One ALU is used. We have one remaining ALU unit and one MUL unit.\n- Schedule at time $t=1$: We have scheduled $N_4$ (mul). One MUL is used. We have two remaining ALU units and zero MUL units.\n\nWe can place the remaining two additions, $N_2$ and $N_3$, in the available slots. A possible valid schedule is:\n- Place $N_2$ (add) at time $t=0$.\n- Place $N_3$ (add) at time $t=1$.\n\nThe proposed kernel schedule is:\n- $t(N_1) = 0$\n- $t(N_2) = 0$\n- $t(N_3) = 1$\n- $t(N_4) = 1$\n\nLet's verify this schedule:\n- **Resource Constraints:**\n  - At time $t=0$: $N_1$ and $N_2$ are issued. This requires $2$ ALUs. The machine has $2$ ALUs. This is valid.\n  - At time $t=1$: $N_3$ and $N_4$ are issued. This requires $1$ ALU and $1$ MUL. The machine has $2$ ALUs and $1$ MUL. This is valid.\n- **Dependence Constraints:**\n  - $t(N_1) + 1 \\le t(N_4) \\implies 0 + 1 \\le 1$, which is true.\n\nThe schedule is valid. This confirms that the loop can be pipelined with an initiation interval of $II=2$, which is equal to the computed $ResMII$.\n\nThe problem asks for the numerical value of the resource-constrained Minimum Initiation Interval ($ResMII$). Based on our derivation, this value is $2$.", "answer": "$$\\boxed{2}$$", "id": "3658402"}, {"introduction": "An optimizing compiler's power lies in its ability to transform code to enable better performance. This final practice demonstrates the synergistic relationship between code optimization and scheduling. You will see how a classic strength-reduction transformation—replacing a slow multiplication with a faster shift and add—can break a critical recurrence and lower the minimum initiation interval. This problem highlights how modifying the source code directly impacts the fundamental scheduling bounds, leading to a more efficient pipeline [@problem_id:3658415].", "problem": "Consider the following loop and target machine model, used in software pipelining with modulo scheduling. You are asked to reason about the initiation interval (II) from first principles of dependence-constrained and resource-constrained lower bounds.\n\nLoop body (single basic block, steady state):\n- Let $x$ and $acc$ be scalar variables carried across iterations with initial values $x_{0}$ and $acc_{0}$ set before the loop.\n- In each iteration $i$:\n  - Update $x$ by $x \\leftarrow 8 \\cdot x + b$, where $b$ is an integer constant available in a register.\n  - Accumulate $acc \\leftarrow acc + x$.\n  - Store the current accumulator to memory $B[i] \\leftarrow acc$.\n  - Increment the loop index $i \\leftarrow i + 1$.\n\nMachine model:\n- Operation latencies (in cycles) for register-to-register instructions:\n  - Integer add has latency $1$.\n  - Shift left by a constant amount has latency $1$.\n  - Integer multiply has latency $4$.\n- Memory model:\n  - A store issues in $1$ cycle on a dedicated memory pipeline (store completion latency does not enter any loop-carried recurrence; there are no cross-iteration memory dependences).\n- Issue capacities (per cycle):\n  - Integer multiply (MUL) pipeline: capacity $1$ per cycle.\n  - Integer arithmetic and logical unit (ALU), shared by add and shift: capacity $2$ per cycle.\n  - Memory pipeline for stores: capacity $1$ per cycle.\n\nAssumptions about dependences:\n- The only loop-carried scalar dependences are:\n  - The recurrence on $x$ defined by the update $x \\leftarrow 8 \\cdot x + b$ with distance $1$.\n  - The recurrence on $acc$ defined by $acc \\leftarrow acc + x$ with distance $1$.\n- There are no cross-iteration memory dependences (each $B[i]$ is distinct).\n- All values are in registers when used; $b$ is loop-invariant; instruction latencies are exact and fully pipelined.\n\nTask:\n- A strength-reducing induction update is applied to the $x$-update by replacing the multiplication by $8$ with a shift-left by $3$ bits. That is, the update becomes $x \\leftarrow (x \\ll 3) + b$, where $\\ll$ denotes left shift and uses the ALU.\n- Using only the definitions of the recurrence-constrained lower bound and the resource-constrained lower bound for the initiation interval in modulo scheduling, determine the new initiation interval after this transformation. You must account for both bounds and report the final $II$ after the transformation.\n\nProvide your final answer as a single integer. No intermediate results are to be reported in the final answer. There is no rounding requirement.", "solution": "The problem is valid. It is a well-posed problem within the domain of compiler theory and computer architecture, specifically concerning instruction scheduling and loop optimization. All necessary data, such as operation latencies, resource capacities, and dependence information, are provided, and there are no internal contradictions or scientific inaccuracies.\n\nThe task is to determine the minimum initiation interval ($II$) for the given loop after a strength-reduction transformation. The initiation interval in modulo scheduling is constrained by two lower bounds: the recurrence-constrained initiation interval ($RecMII$) and the resource-constrained initiation interval ($ResMII$). The final $II$ must be at least the maximum of these two bounds.\n$$II \\ge \\max(RecMII, ResMII)$$\nWe will calculate each of these bounds for the transformed loop.\n\nFirst, let us analyze the operations within the loop body after the strength reduction. The multiplication $x \\leftarrow 8 \\cdot x + b$ is replaced by a left shift and an addition: $x \\leftarrow (x \\ll 3) + b$. The $\\ll$ operation, a shift left by $3$, uses the Arithmetic and Logical Unit (ALU).\n\nThe operations in one iteration of the transformed loop are:\n1.  A shift-left operation: $t \\leftarrow x \\ll 3$. This uses the ALU, and its latency is $1$ cycle.\n2.  An addition: $x \\leftarrow t + b$. This uses the ALU, and its latency is $1$ cycle.\n3.  An addition: $acc \\leftarrow acc + x$. This uses the ALU, and its latency is $1$ cycle.\n4.  A store operation: $B[i] \\leftarrow acc$. This uses the memory (MEM) pipeline and issues in $1$ cycle.\n\nNow we calculate the two lower bounds for the initiation interval.\n\n**1. Recurrence-Constrained Initiation Interval ($RecMII$)**\n\nThe $RecMII$ is determined by the longest loop-carried dependence cycle. The formula for the contribution of a cycle $c$ is $\\lceil \\frac{\\text{sum of latencies in } c}{\\text{sum of dependence distances in } c} \\rceil$. We must find the maximum of these values over all elementary recurrence cycles in the loop's dependence graph. The problem states there are two loop-carried scalar dependences, each with a distance of $1$.\n\n-   **Recurrence on $x$**: The value of $x$ in an iteration depends on its value from the previous iteration. The update $x \\leftarrow (x \\ll 3) + b$ consists of a chain of two dependent operations: a shift followed by an addition.\n    -   The path of this recurrence within the processor is: value of $x$ from previous iteration $\\rightarrow$ SHIFT operation $\\rightarrow$ ADD operation $\\rightarrow$ new value of $x$.\n    -   The total latency of this operation chain is the sum of the latencies of the shift and the add: $1 + 1 = 2$ cycles.\n    -   The dependence distance is given as $1$.\n    -   The minimum initiation interval imposed by this recurrence is $\\lceil \\frac{2}{1} \\rceil = 2$.\n\n-   **Recurrence on $acc$**: The value of $acc$ in an iteration depends on its value from the previous iteration. The update is $acc \\leftarrow acc + x$.\n    -   The core operation in this recurrence is the addition itself. The value of $acc$ from the previous iteration is an input to this ADD operation.\n    -   The latency of the ADD operation is $1$ cycle.\n    -   The dependence distance is given as $1$.\n    -   The minimum initiation interval imposed by this recurrence is $\\lceil \\frac{1}{1} \\rceil = 1$. Note that while the calculation of $acc$ also depends on the new value of $x$, this intra-iteration dependence does not create a longer elementary recurrence cycle for $acc$. The cycle for $acc$ involves only the ADD operation that sums the prior $acc$ with the new $x$.\n\nThe $RecMII$ is the maximum of the minimum intervals required by each recurrence.\n$$RecMII = \\max(2, 1) = 2$$\n\n**2. Resource-Constrained Initiation Interval ($ResMII$)**\n\nThe $ResMII$ is determined by the demand for each type of functional unit. For each resource type $R$, the contribution is $\\lceil \\frac{\\text{number of operations using } R}{\\text{capacity of } R \\text{ per cycle}} \\rceil$.\n\nLet's tally the resource usage for one iteration of the transformed loop:\n-   **Integer Multiply (MUL) unit:** The multiplication has been replaced by a shift, so there are $0$ operations using the MUL unit.\n    -   Capacity: $1$ per cycle.\n    -   $ResMII_{MUL} = \\lceil \\frac{0}{1} \\rceil = 0$.\n\n-   **Arithmetic and Logical Unit (ALU):** The ALU is used for the shift and two additions.\n    -   Operations: $1$ (shift) $+ 2$ (add) $= 3$ operations.\n    -   Capacity: $2$ per cycle.\n    -   $ResMII_{ALU} = \\lceil \\frac{3}{2} \\rceil = \\lceil 1.5 \\rceil = 2$.\n\n-   **Memory (MEM) unit:** The MEM unit is used for the store operation.\n    -   Operations: $1$ (store).\n    -   Capacity: $1$ per cycle.\n    -   $ResMII_{MEM} = \\lceil \\frac{1}{1} \\rceil = 1$.\n\nThe $ResMII$ is the maximum demand placed on any single resource type.\n$$ResMII = \\max(ResMII_{MUL}, ResMII_{ALU}, ResMII_{MEM}) = \\max(0, 2, 1) = 2$$\n\n**Conclusion: Final Initiation Interval ($II$)**\n\nThe minimum initiation interval for the loop is the maximum of the recurrence-constrained and resource-constrained lower bounds.\n$$II = \\max(RecMII, ResMII) = \\max(2, 2) = 2$$\nTherefore, the new initiation interval after the transformation is $2$.", "answer": "$$\\boxed{2}$$", "id": "3658415"}]}