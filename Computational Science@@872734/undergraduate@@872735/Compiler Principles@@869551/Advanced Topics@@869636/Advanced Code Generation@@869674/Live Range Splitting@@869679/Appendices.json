{"hands_on_practices": [{"introduction": "At its heart, live range splitting is an economic decision where a compiler must weigh the cost of inserting split instructions against the savings from avoiding memory spills. This exercise provides a simplified but powerful cost model to help you formalize this trade-off. By deriving the optimal number of splits, you will practice transforming a qualitative optimization goal into a precise, quantitative strategy, a core skill in compiler design [@problem_id:3651169].", "problem": "Consider register allocation for a single scalar variable with a long live interval $I$ in a compilerâ€™s intermediate representation. A live interval is the set of program points over which a value must be kept available. When the instantaneous register pressure exceeds the number of available registers, a live interval may be removed from a register (spilled) and later restored. Live range splitting inserts definition or use boundaries that cut one live interval into multiple sub-intervals, allowing more precise placement in registers or memory.\n\nAssume the following model of cost along a single linearized execution path where control-flow has been frequency-weighted into a single sequence:\n\n- The long live interval $I$ overlaps exactly $K \\in \\mathbb{N}$ disjoint high-pressure regions. In each such region, if $I$ is not made dead across the region by splitting, the allocator must insert a spill for $I$ whose total expected dynamic cost is $c_p > 0$.\n- Each split operation is a single program point at which $I$ is cut into two sub-intervals, and it adds an expected dynamic cost $c_s > 0$ (e.g., due to additional move or copy, bookkeeping, or reduced coalescing).\n- To eliminate the need to spill $I$ in one high-pressure region, exactly $2$ splits are required: one immediately before the region to make $I$ dead across it and one immediately after to resume $I$.\n- Splits have no other effects and do not change the number or placement of high-pressure regions. High-pressure regions are non-overlapping, and $K$ is fixed.\n- The total expected dynamic cost is the sum of the costs of all splits used plus the costs of all spills that remain necessary after splitting.\n- You are free to choose any nonnegative integer number of splits $S \\in \\mathbb{Z}_{\\ge 0}$, and you may place them optimally with respect to the $K$ regions.\n- Assume $c_s \\ll c_p$ in the sense that it is always preferable to add splits if doing so eliminates a spill at the expense of only those splits.\n\nStarting from the core definitions above and the principle that the register allocation decision minimizes total expected dynamic cost, derive a function of $S$ that captures the total cost under this model, and then compute the optimal number of splits $S^{\\star}$ that minimizes this cost. Express $S^{\\star}$ in closed form in terms of $K$, $c_s$, and $c_p$. Your final answer must be a single analytical expression for $S^{\\star}$. No rounding is required, and no physical units apply.", "solution": "The problem asks for the optimal number of splits, denoted $S^{\\star}$, that minimizes the total expected dynamic cost of register allocation for a single live interval $I$ that overlaps with $K$ high-pressure regions.\n\nFirst, we validate the problem statement.\n\n### Step 1: Extract Givens\n- A single live interval $I$.\n- $K \\in \\mathbb{N}$ disjoint high-pressure regions.\n- The cost of a spill for $I$ in one high-pressure region is $c_p > 0$. Without any splitting, the total spill cost is $K c_p$.\n- The cost of a single split operation is $c_s > 0$.\n- To eliminate the need for one spill in one high-pressure region, exactly $2$ splits are required.\n- The total number of splits is a non-negative integer $S \\in \\mathbb{Z}_{\\ge 0}$.\n- The total expected dynamic cost is the sum of costs from splits and remaining spills.\n- An assumption is given: $c_s \\ll c_p$ is interpreted as \"it is always preferable to add splits if doing so eliminates a spill at the expense of only those splits.\" This means the cost of two splits is less than the cost of one spill, i.e., $2c_s < c_p$.\n- The goal is to derive the total cost as a function of $S$ and find the optimal number of splits $S^{\\star}$ that minimizes this cost.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is a well-established modeling problem in compiler design, specifically in the area of register allocation and code optimization. It uses a simplified but valid cost model.\n- **Well-Posed**: The problem provides a clear objective (minimizing a cost function) and sufficient parameters to define that function. The given assumption $2c_s < c_p$ ensures that a unique minimum exists.\n- **Objective**: The problem is stated in precise, quantitative terms.\n- **Complete and Consistent**: All necessary information is provided symbolically. There are no contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. We proceed to the solution.\n\nThe total cost, $C(S)$, is a function of the number of splits $S$. It is the sum of the cost of all splits and the cost of all remaining spills.\n$$ C(S) = (\\text{Cost of splits}) + (\\text{Cost of remaining spills}) $$\nThe cost of $S$ splits is directly given by:\n$$ \\text{Cost of splits} = S \\cdot c_s $$\nTo determine the cost of remaining spills, we must first find out how many spills are eliminated by using $S$ splits. The problem states that $2$ splits are required to eliminate $1$ spill. Therefore, with $S$ splits, the number of spills that can be potentially eliminated is $\\lfloor S/2 \\rfloor$.\nThe total number of high-pressure regions is $K$, so at most $K$ spills can be eliminated. The number of spills actually eliminated, $n_{\\text{elim}}$, is the minimum of the number of available spill-eliminating split pairs and the total number of spills:\n$$ n_{\\text{elim}}(S) = \\min(K, \\lfloor S/2 \\rfloor) $$\nThe number of spills that remain necessary, $n_{\\text{rem}}$, is the initial number of spills, $K$, minus the number of eliminated spills:\n$$ n_{\\text{rem}}(S) = K - n_{\\text{elim}}(S) = K - \\min(K, \\lfloor S/2 \\rfloor) $$\nThis can be rewritten using the identity $\\min(a,b) = a - \\max(0, a-b)$ as $K - (K - \\max(0, K-\\lfloor S/2 \\rfloor)) = \\max(0, K - \\lfloor S/2 \\rfloor)$.\nThe total cost of remaining spills is $n_{\\text{rem}}(S)$ multiplied by the cost per spill, $c_p$:\n$$ \\text{Cost of remaining spills} = c_p \\cdot \\max(0, K - \\lfloor S/2 \\rfloor) $$\nCombining these parts, the total cost function $C(S)$ is:\n$$ C(S) = S \\cdot c_s + c_p \\cdot \\max(0, K - \\lfloor S/2 \\rfloor) $$\nOur goal is to find the integer $S \\geq 0$ that minimizes $C(S)$.\n\nLet's analyze the behavior of $C(S)$. Note that the term $\\lfloor S/2 \\rfloor$ is constant for $S=2s$ and $S=2s+1$, where $s$ is a non-negative integer. Let's compare the cost for an odd number of splits, $S = 2s+1$, with an even number, $S = 2s$.\n$$ C(2s) = (2s)c_s + c_p \\cdot \\max(0, K - \\lfloor (2s)/2 \\rfloor) = 2sc_s + c_p \\cdot \\max(0, K-s) $$\n$$ C(2s+1) = (2s+1)c_s + c_p \\cdot \\max(0, K - \\lfloor (2s+1)/2 \\rfloor) = (2s+1)c_s + c_p \\cdot \\max(0, K-s) $$\nThe difference is:\n$$ C(2s+1) - C(2s) = \\left((2s+1)c_s + c_p \\cdot \\max(0, K-s)\\right) - \\left(2sc_s + c_p \\cdot \\max(0, K-s)\\right) = c_s $$\nSince $c_s > 0$, we have $C(2s+1) > C(2s)$. This means that for any odd number of splits $2s+1$, the cost is strictly greater than for $2s$ splits. An odd-numbered split adds cost without eliminating an additional spill. Therefore, the optimal number of splits $S^{\\star}$ cannot be odd; it must be an even number.\n\nWe can thus restrict our search to even values of $S$. Let $S = 2s$, where $s$ is the number of pairs of splits. Here, $s$ represents the number of high-pressure regions whose spills we choose to eliminate. The possible values for $s$ are non-negative integers.\nThe cost function becomes a function of $s$:\n$$ C(2s) = 2s \\cdot c_s + c_p \\cdot \\max(0, K - s) $$\nLet's analyze this function for two regimes of $s$.\n\nCase 1: $0 \\le s \\le K$.\nIn this range, $K-s \\ge 0$, so $\\max(0, K-s) = K-s$. The cost function is:\n$$ C(2s) = 2sc_s + c_p(K-s) \\quad \\text{for } 0 \\le s \\le K $$\nWe can rearrange this to see its dependence on $s$:\n$$ C(2s) = (2c_s - c_p)s + K c_p $$\nThis is a linear function of $s$. Its behavior depends on the slope, $m = 2c_s - c_p$. The problem states that \"it is always preferable to add splits if doing so eliminates a spill at the expense of only those splits\". This implies that the cost of adding two splits ($2c_s$) is less than the benefit of saving one spill ($c_p$). Mathematically, this is the inequality $2c_s < c_p$.\nGiven this condition, the slope $m = 2c_s - c_p$ is strictly negative.\nA linear function with a negative slope is a strictly decreasing function. To minimize this function on the interval of integers $s \\in [0, K]$, we must choose the largest possible value for $s$. The maximum value in this domain is $s=K$.\nThis suggests that the minimum cost in this range is achieved at $s=K$, which corresponds to $S=2K$.\n\nCase 2: $s > K$.\nIn this range, $K-s < 0$, so $\\max(0, K-s) = 0$. The cost function is:\n$$ C(2s) = 2sc_s \\quad \\text{for } s > K $$\nThis is a strictly increasing function of $s$ since $c_s > 0$. Therefore, any value of $s > K$ will yield a higher cost than at $s=K$. For instance, at $s=K+1$, the cost is $C(2(K+1)) = 2(K+1)c_s = 2Kc_s + 2c_s$.\nThe cost at the boundary point $s=K$ is $C(2K) = (2c_s - c_p)K + K c_p = 2Kc_s$.\nSince $C(2(K+1)) > C(2K)$, and the cost continues to increase for $s > K$, the minimum cannot occur in this region.\n\nCombining both cases, the cost function $C(2s)$ is strictly decreasing for $s \\in [0, K]$ and strictly increasing for $s \\in [K, \\infty)$. The global minimum must therefore occur at the point $s=K$.\nThe optimal number of split pairs is $s^{\\star} = K$.\nThis corresponds to an optimal total number of splits $S^{\\star} = 2s^{\\star} = 2K$. At this point, all $K$ high-pressure regions are handled by splits, and no spills for interval $I$ are needed. The total cost is the cost of these $2K$ splits, which is $2Kc_s$.", "answer": "$$\n\\boxed{2K}\n$$", "id": "3651169"}, {"introduction": "The previous exercise established the abstract trade-off of live range splitting; now, we apply this concept to one of the most critical areas for optimization: loops. This problem explores a common scenario where a loop-invariant value creates high register pressure, forcing costly spills. By comparing the cost of keeping the value live versus splitting its range and rematerializing it, you will gain a concrete understanding of how splitting enables more efficient register usage in performance-critical code [@problem_id:3651136].", "problem": "Consider the following three-address style intermediate representation (IR) for a simple loop, together with a concrete machine model and a toy register-allocation scenario designed to study the effect of live range splitting and rematerialization of a loop-invariant value:\n- Code\n  - Preheader: compute a loop-invariant address-like constant\n    - $c := \\text{base} + 4096$\n    - $i := 0$\n    - $acc := 0$\n  - Loop body (repeats for $T$ iterations):\n    - $t := \\mathrm{load}[p + i]$\n    - $acc := acc + t \\times c$\n    - $i := i + 4$\n    - if $(i < M)$ goto loop head\n- Live set assumptions\n  - At the program point immediately before the multiplication $t \\times c$, the set of simultaneously live values excluding $c$ has cardinality $3$: specifically $\\{acc, i, t\\}$.\n  - If $c$ is kept live across the entire loop body, then the peak simultaneously live set at that point has cardinality $4$ (the above three plus $c$).\n  - Assume the compiler cannot further reschedule or change uses to reduce this peak live count at that program point.\n- Register and cost model\n  - The target has $R = 3$ general-purpose registers available for this loop.\n  - Memory operations used for spilling have additive cost: each $\\mathrm{store}$ or $\\mathrm{load}$ used by spilling costs $C_{\\mathrm{mem}} = 6$ cycles, independent and non-overlapped.\n  - A single add-immediate (e.g., an address computation $\\mathrm{lea}$) that rematerializes $c$ from $\\text{base}$ and the immediate $4096$ costs $C_{\\mathrm{remat}} = 1$ cycle.\n  - The loop runs for $T = 100$ iterations.\n  - Ignore cache misses and assume all other loop instructions are identical across the compared strategies; only count costs that differ between the strategies described below.\n- Two allocation strategies to compare\n  - Strategy K (Keep): Compute $c$ once in the preheader and keep $c$ live across the loop. Because the peak live count inside the loop is $4$ while $R = 3$, assume the allocator spills exactly one other value at the critical point, inducing one $\\mathrm{store}$ and one $\\mathrm{load}$ per iteration.\n  - Strategy S (Split + Rematerialize): Split the live range of $c$ at loop entry so that $c$ is not live across the loop. Instead, rematerialize $c$ immediately before its use inside the loop via a single add-immediate each iteration. This reduces the peak live count at the critical point to $3$, eliminating the spill.\n\nFrom the fundamental definitions that govern liveness and register allocation, recall:\n- A value is live at a program point if its current content may be used along some path before being redefined.\n- The peak number of simultaneously live values at a program point lower-bounds the number of registers required to avoid spilling at that point.\n- If the number of simultaneously live values exceeds the available registers by $k$, then at least $k$ values must be spilled, which typically induces at least one $\\mathrm{store}$ and one $\\mathrm{load}$ per iteration in this toy model when the excess is $1$.\n- Rematerialization recomputes a cheap expression (such as an add-immediate from invariants) instead of loading it from memory or keeping it live across regions of high pressure.\n\nQuestion: Under the above assumptions and this cost model, which statement is correct about which strategy minimizes the dynamic cost attributable to register pressure, and by how much relative to the other strategy?\n\nA. Splitting the live range of $c$ at loop entry and rematerializing it just before its use each iteration strictly reduces dynamic cost compared to keeping $c$ live, saving $1101$ cycles for $T = 100$; under this model it is optimal among the two strategies.\n\nB. Keeping $c$ live across the loop is cheaper because computing $c$ once in the preheader saves $T \\cdot C_{\\mathrm{remat}} = 100$ cycles, which outweighs the $2T \\cdot C_{\\mathrm{mem}} = 1200$ cycles of spill traffic; thus it wins by $1100$ cycles.\n\nC. Both strategies have equal cost under the assumptions because the spill $\\mathrm{store}$ and $\\mathrm{load}$ in Strategy K can be overlapped and hidden by other instructions, making their additive cost effectively $0$.\n\nD. Splitting the live range of $c$ increases interference at the loop backedge and forces two spills per iteration, costing $2400$ cycles, so Strategy K is strictly better.", "solution": "### Problem Validation\n\n#### Step 1: Extract Givens\n\nThe problem provides the following information:\n\n*   **Code Structure:**\n    *   Preheader: $c := \\text{base} + 4096$; $i := 0$; $acc := 0$\n    *   Loop body: $t := \\mathrm{load}[p + i]$; $acc := acc + t \\times c$; $i := i + 4$; if $(i < M)$ goto loop head\n*   **Live Set Assumptions:**\n    *   At the point before the multiplication $t \\times c$, the set of live values excluding $c$ is $\\{acc, i, t\\}$, with cardinality $3$.\n    *   If $c$ is kept live, the peak cardinality of the simultaneously live set at that point is $4$.\n    *   Compiler cannot reschedule to reduce this peak live count.\n*   **Register and Cost Model:**\n    *   Number of available general-purpose registers: $R = 3$.\n    *   Cost of a memory operation (store or load) for spilling: $C_{\\mathrm{mem}} = 6$ cycles. These costs are additive and non-overlapped.\n    *   Cost of rematerializing $c$: $C_{\\mathrm{remat}} = 1$ cycle per instance.\n    *   Number of loop iterations: $T = 100$.\n    *   Analysis should only count costs that differ between the two strategies.\n*   **Allocation Strategies:**\n    *   **Strategy K (Keep):** $c$ is computed once in the preheader. Peak live count inside the loop is $4$. With $R=3$, this forces one value to be spilled, incurring one $\\mathrm{store}$ and one $\\mathrm{load}$ per iteration.\n    *   **Strategy S (Split + Rematerialize):** The live range of $c$ is split. $c$ is rematerialized inside each loop iteration just before its use. Peak live count is reduced to $3$, which eliminates spilling.\n\n#### Step 2: Validate Using Extracted Givens\n\n*   **Scientific Grounding:** The problem is firmly rooted in the principles of compiler design, specifically register allocation. The concepts of live ranges, register pressure, spilling, live range splitting, and rematerialization are standard topics in this field. The cost model, while simplified, reflects the realistic trade-off where memory access ($C_{\\mathrm{mem}}=6$) is significantly more expensive than a simple arithmetic instruction ($C_{\\mathrm{remat}}=1$). The problem is scientifically sound.\n*   **Well-Posedness:** The problem is well-posed. It provides a clear, quantitative scenario with all necessary parameters ($R$, $T$, $C_{\\mathrm{mem}}$, $C_{\\mathrm{remat}}$) and explicit assumptions about the consequences of each strategy (number of spills, etc.). The question asks for a specific comparison of costs, which can be uniquely determined from the givens.\n*   **Objectivity:** The problem statement is objective and uses precise terminology from compiler theory. It establishes a \"toy model\" to a-priori fix the outcomes of complex compiler heuristics (like which variable to spill), which is a valid method for creating a solvable, analytical problem.\n\nThe problem does not exhibit any of the invalidity flaws. It is self-contained, consistent, scientifically grounded, and well-posed.\n\n#### Step 3: Verdict and Action\n\nThe problem statement is **valid**. The solution process will now proceed.\n\n### Derivation of Solution\n\nThe task is to compare the total dynamic cost attributable to register pressure for two different register allocation strategies over $T=100$ iterations. We must account for all costs that differ between the two strategies.\n\n**Strategy K (Keep):**\nIn this strategy, the value $c$ is computed once in the preheader and kept in a register throughout the loop's execution.\n1.  **Preheader Cost:** The computation $c := \\text{base} + 4096$ is performed once before the loop begins. This is an add-immediate instruction, and its cost is given as equivalent to a rematerialization cost, $C_{\\mathrm{remat}} = 1$ cycle. This is a cost incurred by this strategy that is not present in the same way in Strategy S (where there is no value `c` computed in the preheader).\n2.  **Loop Body Cost:** The problem states that keeping $c$ live raises the peak number of simultaneously live variables to $4$. Since there are only $R=3$ registers, one value must be spilled to memory. The problem specifies this spill induces one $\\mathrm{store}$ operation and one $\\mathrm{load}$ operation per iteration.\n    *   Cost of one store: $C_{\\mathrm{mem}} = 6$ cycles.\n    *   Cost of one load: $C_{\\mathrm{mem}} = 6$ cycles.\n    *   Total spill cost per iteration: $C_{\\mathrm{spill\\_iter}} = C_{\\mathrm{mem}} + C_{\\mathrm{mem}} = 6 + 6 = 12$ cycles.\n3.  **Total Cost for Strategy K:** The total cost is the sum of the one-time preheader computation and the cumulative cost of spilling over all iterations.\n    $$ \\text{Cost}_K = C_{\\mathrm{remat}} + T \\times C_{\\mathrm{spill\\_iter}} $$\n    $$ \\text{Cost}_K = 1 + 100 \\times 12 = 1 + 1200 = 1201 \\text{ cycles} $$\n\n**Strategy S (Split + Rematerialize):**\nIn this strategy, the live range of $c$ is split, so it is not live across loop iterations. Instead, it is recomputed inside the loop just before it is needed.\n1.  **Preheader Cost:** There is no computation of $c$ in the preheader.\n2.  **Loop Body Cost:** The problem states this strategy reduces the peak live count to $3$. With $R=3$ registers, spilling is avoided. However, the value $c$ must be recomputed in each iteration.\n    *   Cost of rematerialization per iteration: $C_{\\mathrm{remat}} = 1$ cycle.\n3.  **Total Cost for Strategy S:** The total cost is the cumulative cost of rematerializing $c$ in each of the $T$ iterations.\n    $$ \\text{Cost}_S = T \\times C_{\\mathrm{remat}} $$\n    $$ \\text{Cost}_S = 100 \\times 1 = 100 \\text{ cycles} $$\n\n**Comparison:**\nWe compare the total costs of the two strategies:\n*   $\\text{Cost}_K = 1201$ cycles.\n*   $\\text{Cost}_S = 100$ cycles.\n\nStrategy S is significantly cheaper than Strategy K. The total saving achieved by using Strategy S instead of Strategy K is:\n$$ \\text{Savings} = \\text{Cost}_K - \\text{Cost}_S = 1201 - 100 = 1101 \\text{ cycles} $$\nTherefore, Strategy S (Splitting + Rematerialization) is the optimal choice between the two, and it reduces the dynamic cost by $1101$ cycles.\n\n### Option-by-Option Analysis\n\n**A. Splitting the live range of $c$ at loop entry and rematerializing it just before its use each iteration strictly reduces dynamic cost compared to keeping $c$ live, saving $1101$ cycles for $T = 100$; under this model it is optimal among the two strategies.**\nThis statement aligns perfectly with our derivation.\n*   Strategy S reduces dynamic cost: $\\text{Cost}_S = 100$ is less than $\\text{Cost}_K = 1201$.\n*   The saving is $1101$ cycles.\n*   It is the optimal strategy of the two presented.\nThe statement is **Correct**.\n\n**B. Keeping $c$ live across the loop is cheaper because computing $c$ once in the preheader saves $T \\cdot C_{\\mathrm{remat}} = 100$ cycles, which outweighs the $2T \\cdot C_{\\mathrm{mem}} = 1200$ cycles of spill traffic; thus it wins by $1100$ cycles.**\nThis statement contains multiple errors.\n*   \"Keeping $c$ live... is cheaper\": This is false. Our analysis shows it is more expensive by $1101$ cycles.\n*   \"...saves $T \\cdot C_{\\mathrm{remat}} = 100$ cycles...\": The premise is flawed. Computing $c$ once avoids $T-1=99$ rematerializations, saving $99$ cycles on that specific operation, but it forces $1200$ cycles of spilling. The number $100$ represents the total cost of rematerialization in Strategy S, not the savings of Strategy K.\n*   \"...which outweighs the... $1200$ cycles...\": A saving of $\\approx 100$ cycles cannot outweigh a cost of $1200$ cycles. The logical reasoning is inverted.\n*   \"...it wins by $1100$ cycles\": The strategy loses, and our calculated difference is $1101$, not $1100$.\nThe statement is **Incorrect**.\n\n**C. Both strategies have equal cost under the assumptions because the spill $\\mathrm{store}$ and $\\mathrm{load}$ in Strategy K can be overlapped and hidden by other instructions, making their additive cost effectively $0$.**\nThis statement directly contradicts a premise of the problem. The problem states that spill costs are \"$C_{\\mathrm{mem}} = 6$ cycles, independent and non-overlapped.\" Therefore, their cost cannot be considered $0$.\nThe statement is **Incorrect**.\n\n**D. Splitting the live range of $c$ increases interference at the loop backedge and forces two spills per iteration, costing $2400$ cycles, so Strategy K is strictly better.**\nThis statement misrepresents the effect of live range splitting.\n*   \"Splitting the live range of $c$ increases interference...\": The fundamental purpose and stated effect of splitting $c$'s live range is to *reduce* interference and register pressure. The problem explicitly confirms this: \"This reduces the peak live count... to $3$\".\n*   \"...and forces two spills per iteration...\": This is false. By reducing the peak live count to match the number of registers ($3$), Strategy S *eliminates* spills, as stated in the problem. The cost of $2400$ cycles ($2 \\times (100 \\times 12)$) is therefore baseless.\n*   \"...so Strategy K is strictly better\": This conclusion is derived from false premises and is the opposite of the correct result.\nThe statement is **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "3651136"}, {"introduction": "Real-world programs consist of complex control-flow graphs with hot loops and rarely executed cold paths, and this practice problem elevates our analysis by introducing profile-guided optimization. You will design a sophisticated splitting strategy for a spilled variable, keeping it in a register only along the program's hot path while ensuring correctness on cold paths. This exercise demonstrates how to minimize the *expected* dynamic cost, a key technique used by modern compilers to focus optimization efforts where they have the most impact [@problem_id:3651198].", "problem": "Consider a compiler back end after register allocation where a single variable $v$ has been globally spilled to a stack slot. You are given a Control Flow Graph (CFG) with an entry block, a hot loop, and a post-loop branch with a cold error path:\n- Block $B_0$ (entry): defines $v$ once, then jumps to a loop preheader.\n- Loop preheader $H$: falls into loop header $L$.\n- Loop body $B$: executed inside the loop. Each loop iteration contains exactly two uses of $v$ and one definition of $v$ that updates its value for the next iteration.\n- Loop exit $X$: from $X$, control branches to a normal path $N$ with probability $0.99$ (no further uses of $v$), or to a cold error path $C$ with probability $0.01$, where there is exactly one use of $v$.\n\nAssume the loop iterates exactly $N = 1000$ times per function invocation. Assume the following cost model for dynamic memory traffic due to spilling and reloading:\n- Each load from the spill slot costs $c_L = 4$ cycles.\n- Each store to the spill slot costs $c_S = 4$ cycles.\n- Register-to-register moves cost $c_M = 1$ cycle, but you may ignore such moves unless an option explicitly uses them.\n- The expected dynamic cost per function invocation is the sum over all dynamically executed loads and stores, each multiplied by its cost; when a branch is probabilistic, use its probability.\n\nDefinitions and constraints:\n- A live range split creates a subrange where $v$ is carried in a dedicated register $t$ and uses/defs refer to $t$; at the boundary between a spilled region and an in-register region, a reload (load from the spill slot into $t$) is required on entry, and a store back to the spill slot is required on exit if the value is live-out to a spilled region that may subsequently use $v$.\n- Correctness requires that any use of $v$ observes the latest definition along that path. When $v$ is in a register-only subrange, any path leaving that subrange into a spilled region must materialize the current value in memory before a use from the spilled region can occur.\n- You may split critical edges as needed to place a store or load along only one of the outgoing branches.\n\nGoal: Propose a re-splitting and partial reloading scheme so that only the hot subrange of $v$ is kept in a register and reloaded, while other regions remain spilled, and such that the expected dynamic spill cost per invocation is minimized subject to correctness.\n\nWhich option best satisfies the goal?\n\nA. Create a register-only subrange for $v$ covering the entire loop. Insert a single reload in preheader $H$ to load $v$ into register $t$ before entering the loop. Keep $v$ in $t$ throughout the loop, and insert a single unconditional store in $X$ to write back $t$ to the spill slot before branching to $N$ or $C$. Outside the loop (including in $C$), keep $v$ spilled and insert a load before the use in $C$.\n\nB. Create a register-only subrange for $v$ covering the entire loop. Insert a single reload in preheader $H$ to load $v$ into $t$ before entering the loop. Keep $v$ in $t$ throughout the loop. Do not store in $X$. Instead, split the critical edge $X \\rightarrow C$ (if needed) and place a store on only the cold path to $C$ to materialize the current value of $v$ in memory; then in $C$ perform the load before its single use. Keep $v$ spilled everywhere outside the loop, including both $N$ and $C$.\n\nC. Keep $v$ spilled everywhere. Insert a reload immediately before every use and a store immediately after every definition, in all blocks, including the loop and the cold path $C$.\n\nD. Create a register-only subrange for $v$ spanning only a single iteration at a time: reload $v$ into $t$ at the top of the loop header $L$ in every iteration; use and define $t$ within the iteration; then store $t$ back to memory at the loop latch of each iteration. Outside the loop, keep $v$ spilled and insert a load before the use in $C$.\n\nE. Create a register-only subrange for $v$ covering the loop, with a single reload in $H$ and no stores at or after $X$ on any path. Keep $v$ spilled everywhere else, and in $C$ directly use the spilled value without inserting any additional store after the loop.\n\nSelect the option that both preserves correctness and minimizes the expected dynamic spill cost per function invocation, under the stated model and constraints. Provide no partial credit; choose the single best option.", "solution": "The user has provided a problem statement regarding compiler optimization, specifically live range splitting for a spilled variable. I will first validate the problem statement and then proceed to a rigorous solution.\n\n### Step 1: Extract Givens\n\n-   **Variable and State**: A single variable, $v$, is globally spilled to a stack slot.\n-   **Control Flow Graph (CFG)**:\n    -   Entry block $B_0$ defines $v$ once.\n    -   A loop composed of a preheader $H$, a header $L$, and a body $B$.\n    -   The loop iterates $N = 1000$ times.\n    -   The loop body $B$ contains two uses and one definition of $v$ per iteration.\n    -   The loop exit block is $X$.\n    -   From $X$, control flows to a normal path $N$ with probability $P(N) = 0.99$. There are no further uses of $v$ on path $N$.\n    -   From $X$, control flows to a cold error path $C$ with probability $P(C) = 0.01$. There is one use of $v$ on path $C$.\n-   **Cost Model**:\n    -   Load cost: $c_L = 4$ cycles.\n    -   Store cost: $c_S = 4$ cycles.\n-   **Definitions**:\n    -   Live range splitting involves creating a subrange where $v$ is held in a register $t$.\n    -   A reload (load from spill slot) is needed to enter a register-only subrange.\n    -   A store to the spill slot is needed on exit if the value is live-out to a spilled region.\n-   **Correctness Constraint**: Any use of $v$ must observe the value from the latest preceding definition on its execution path.\n-   **Goal**: Minimize the expected dynamic spill cost per function invocation while preserving correctness.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is scientifically grounded in the domain of compiler construction and optimization. The concepts of Control Flow Graphs, global spilling, live ranges, liveness analysis, and live range splitting are standard and well-defined. The problem is well-posed: it provides all necessary data (CFG structure, iteration count, probabilities, instruction counts, and costs) to formulate an objective function (expected dynamic cost) to be minimized under a clear correctness constraint. The problem is expressed in objective, technical language. There are no contradictions, ambiguities, or missing information that would prevent a formal analysis.\n\n### Step 3: Verdict and Action\n\nThe problem is valid. I will now derive the solution by analyzing the expected cost of each proposed scheme.\n\n### Derivation of Solution\n\nThe objective is to minimize the expected dynamic cost, which is the sum of the costs of all dynamically executed load and store instructions related to the spilled variable $v$. The cost of an instruction executed on a probabilistic path is weighted by the path's probability.\n\n#### Baseline Cost (Global Spilling)\n\nFirst, let's analyze the cost of the initial state where $v$ is globally spilled, which corresponds to the strategy described in Option C.\n1.  **Block $B_0$**: A definition of $v$ occurs. Since the value of $v$ is used in the first loop iteration, it is live-out of $B_0$. Thus, a store instruction must follow the definition in $B_0$.\n    -   Cost in $B_0$: $1 \\times c_S = 4$ cycles. This is executed once per invocation.\n2.  **Loop Body $B$**: There are two uses and one definition of $v$. For a globally spilled variable, each use is preceded by a load, and each definition is followed by a store.\n    -   Cost per iteration: $2 \\times c_L + 1 \\times c_S = 2 \\times 4 + 1 \\times 4 = 12$ cycles.\n    -   Total loop cost: $N \\times 12 = 1000 \\times 12 = 12000$ cycles.\n3.  **Cold Path $C$**: There is one use of $v$, which requires a preceding load. This path is taken with probability $0.01$.\n    -   Expected cost for path $C$: $P(C) \\times (1 \\times c_L) = 0.01 \\times 4 = 0.04$ cycles.\n\nThe total expected cost for the fully spilled scheme (Option C) is:\n$C_{total} = C_{B_0} + C_{loop} + E[C_C] = 4 + 12000 + 0.04 = 12004.04$ cycles.\n\nNow, we evaluate each option.\n\n#### Option-by-Option Analysis\n\n**A. Create a register-only subrange for $v$ covering the entire loop. Insert a single reload in preheader $H$ to load $v$ into register $t$ before entering the loop. Keep $v$ in $t$ throughout the loop, and insert a single unconditional store in $X$ to write back $t$ to the spill slot before branching to $N$ or $C$. Outside the loop (including in $C$), keep $v$ spilled and insert a load before the use in $C$.**\n\n-   **Correctness**:\n    -   The def in $B_0$ is followed by a store (cost not included in this option, but necessary for the reload). The reload in $H$ correctly loads this value into register $t$.\n    -   All operations inside the loop are on $t$, which is correct.\n    -   The unconditional store in $X$ materializes the final value of $t$ back into the spill slot for $v$.\n    -   The subsequent load in $C$ will correctly read this materialized value.\n    -   The scheme is **Correct**.\n\n-   **Cost Analysis**:\n    1.  Store after def in $B_0$: Executed once. Cost = $c_S = 4$. (This is a necessary precondition).\n    2.  Reload in $H$: Executed once. Cost = $c_L = 4$.\n    3.  Loop: All operations are on register $t$. Cost = $0$.\n    4.  Unconditional store in $X$: Executed once. Cost = $c_S = 4$.\n    5.  Load in $C$: Executed with probability $0.01$. Expected cost = $0.01 \\times c_L = 0.04$.\n    -   Total Expected Cost (A): $4 + 4 + 4 + 0.04 = 12.04$ cycles.\n\n**B. Create a register-only subrange for $v$ covering the entire loop. Insert a single reload in preheader $H$ to load $v$ into $t$ before entering the loop. Keep $v$ in $t$ throughout the loop. Do not store in $X$. Instead, split the critical edge $X \\rightarrow C$ (if needed) and place a store on only the cold path to $C$ to materialize the current value of $v$ in memory; then in $C$ perform the load before its single use. Keep $v$ spilled everywhere outside the loop, including both $N$ and $C$.**\n\n-   **Correctness**:\n    -   Reload in $H$ is correct. Loop operations on $t$ are correct.\n    -   On exit from the loop, the value of $v$ is live only on the path to $C$. It is not live on the path to $N$.\n    -   Placing the store only on the edge $X \\rightarrow C$ correctly materializes the value only where it is needed. The subsequent load in $C$ reads the correct value.\n    -   The scheme is **Correct**.\n\n-   **Cost Analysis**:\n    1.  Store after def in $B_0$: Executed once. Cost = $c_S = 4$.\n    2.  Reload in $H$: Executed once. Cost = $c_L = 4$.\n    3.  Loop: Cost = $0$.\n    4.  Store on edge $X \\rightarrow C$: Executed with probability $0.01$. Expected cost = $0.01 \\times c_S = 0.04$.\n    5.  Load in $C$: Executed with probability $0.01$. Expected cost = $0.01 \\times c_L = 0.04$.\n    -   Total Expected Cost (B): $4 + 4 + 0.04 + 0.04 = 8.08$ cycles.\n\n**C. Keep $v$ spilled everywhere. Insert a reload immediately before every use and a store immediately after every definition, in all blocks, including the loop and the cold path $C$.**\n\n-   **Correctness**: This is the naive, unoptimized global spilling strategy. It is inherently correct as every use is preceded by a load and every def is followed by a store, ensuring data-flow consistency.\n    -   The scheme is **Correct**.\n\n-   **Cost Analysis**: As calculated in the baseline analysis above.\n    -   Total Expected Cost (C): $12004.04$ cycles.\n\n**D. Create a register-only subrange for $v$ spanning only a single iteration at a time: reload $v$ into $t$ at the top of the loop header $L$ in every iteration; use and define $t$ within the iteration; then store $t$ back to memory at the loop latch of each iteration. Outside the loop, keep $v$ spilled and insert a load before the use in $C$.**\n\n-   **Correctness**: In each iteration, the value from the previous iteration is reloaded. Within the iteration, operations on $t$ are consistent. The value is stored back for the next iteration. After the final iteration, the correct value is in memory for the use in $C$.\n    -   The scheme is **Correct**.\n\n-   **Cost Analysis**:\n    1.  Store after def in $B_0$: Executed once. Cost = $c_S = 4$.\n    2.  Loop ($1000$ iterations): In each iteration, there is one reload and one store.\n        -   Cost per iteration: $c_L + c_S = 4 + 4 = 8$.\n        -   Total loop cost: $1000 \\times 8 = 8000$.\n    3.  Load in $C$: Executed with probability $0.01$. Expected cost = $0.01 \\times c_L = 0.04$.\n    -   Total Expected Cost (D): $4 + 8000 + 0.04 = 8004.04$ cycles.\n\n**E. Create a register-only subrange for $v$ covering the loop, with a single reload in $H$ and no stores at or after $X$ on any path. Keep $v$ spilled everywhere else, and in $C$ directly use the spilled value without inserting any additional store after the loop.**\n\n-   **Correctness**: The value of $v$ is modified $1000$ times inside the loop, with the final value residing in register $t$. This option proposes *no store* to write this final value back to the spill slot. The original value of $v$ (from before the loop) remains in the spill slot. The use in $C$ would load this stale, incorrect value. This violates the correctness constraint that \"any use of v observes the latest definition\".\n    -   The scheme is **Incorrect**.\n\n### Comparison and Conclusion\n\nLet's compare the total expected costs of the correct options:\n-   Cost(A) = $12.04$ cycles\n-   Cost(B) = $8.08$ cycles\n-   Cost(C) = $12004.04$ cycles\n-   Cost(D) = $8004.04$ cycles\n\nThe lowest expected cost among the correct options is $8.08$ cycles, which is achieved by Option B. This strategy is superior because it confines the variable to a register for the entire duration of the hot loop, eliminating all $3000$ memory operations within it, and it intelligently places the required store-back operation only on the low-probability cold path where the value is actually needed, avoiding the cost on the high-probability normal path. Option A is suboptimal because its unconditional store is wasteful. Options C and D are drastically more expensive due to incurring memory operations inside the loop.\n\nTherefore, Option B represents the optimal strategy among the choices.", "answer": "$$\\boxed{B}$$", "id": "3651198"}]}