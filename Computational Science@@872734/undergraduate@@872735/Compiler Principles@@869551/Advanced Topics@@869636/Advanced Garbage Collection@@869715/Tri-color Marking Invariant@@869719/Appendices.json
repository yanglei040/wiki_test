{"hands_on_practices": [{"introduction": "The tri-color marking invariant is not just a theoretical concept; its enforcement through write barriers carries a tangible performance cost. This practice problem ([@problem_id:3679450]) provides a concrete scenario to quantify this overhead by comparing a traditional mutable data structure with a persistent immutable one. By calculating the expected number of write barrier triggers in each case, you will gain a deeper appreciation for how architectural choices, like embracing immutability, can directly influence the efficiency of garbage collection.", "problem": "A garbage collector (GC) that performs incremental mark-sweep uses the tri-color abstraction of the heap: every object is colored either white (unreached), gray (reached but not fully scanned), or black (reached and fully scanned). The tri-color marking invariant states that there must be no edge from a black object to a white object during a collection cycle. A write barrier is a mechanism used by the runtime to preserve this invariant in the presence of mutator writes.\n\nConsider two implementations of an application-level data structure under an incremental marking collector that uses Dijkstra-style coloring, where newly allocated objects are initially white. In both implementations, logical operations occur while the GC is in a marking phase and the mutator and collector interleave arbitrarily.\n\nBaseline mutable implementation:\n- Each logical operation performs on average $m = 40$ pointer writes into already existing mutable objects.\n- During the marking phase, for any given mutation write, the probability that the receiver object is black is $p_{B} = 0.7$, and independently, the probability that the new target object pointed to by the write is white is $p_{W} = 0.6$.\n\nPersistent immutable implementation with tail-sharing:\n- Each logical operation allocates $L = 12$ fresh immutable nodes, each with $c = 3$ pointer fields that are initialized at allocation time to point to existing nodes, exploiting tail-sharing.\n- Newly allocated nodes are white at allocation. Writes that initialize fields of these fresh nodes occur before any coloring change on the fresh nodes.\n- The only mutation to existing state per operation is a single update of a global root variable to point to the newly constructed head node. At the time of this root update, the probability that the root variable (the receiver) is black is $p_{R} = 0.95$.\n\nUsing only the definition of the tri-color marking invariant and the fact that a write barrier is required precisely to prevent creation of edges from black receivers to white targets, derive from first principles the expected fraction of write-barrier-protected stores eliminated by switching from the baseline mutable implementation to the persistent immutable implementation with tail-sharing. Express this expected elimination fraction as a single real number in decimal form and round your answer to four significant figures.", "solution": "To determine the fraction of write barrier invocations eliminated, we first need to calculate the expected number of barrier triggers per logical operation for each implementation. A write barrier is triggered precisely when a pointer is stored from a black object to a white object.\n\n**1. Expected Barrier Triggers in Mutable Implementation ($E_{mut}$)**\n\n- A single logical operation performs $m = 40$ pointer writes.\n- For each write, the probability of the receiver object being black is $p_B = 0.7$.\n- For each write, the probability of the target object being white is $p_W = 0.6$.\n- Since these events are independent, the probability that any single write triggers the barrier is $p_B \\times p_W$.\n- The expected number of barrier triggers per operation is the total number of writes multiplied by this probability:\n  $E_{mut} = m \\times p_B \\times p_W = 40 \\times 0.7 \\times 0.6 = 16.8$\n\n**2. Expected Barrier Triggers in Immutable Implementation ($E_{imm}$)**\n\nThis implementation involves two distinct types of writes:\n\n- **Initialization of new nodes**:\n  - $L=12$ new nodes are allocated, each with $c=3$ pointers, for a total of $L \\times c = 12 \\times 3 = 36$ writes.\n  - The problem states these writes occur into \"fresh immutable nodes\" which are \"white at allocation.\"\n  - Since the receiver object of these writes is always white, the condition for a barrier trigger (a black receiver) is never met.\n  - Therefore, the number of barrier triggers for these initialization writes is $0$.\n\n- **Update of the global root variable**:\n  - There is a single pointer write to update the root.\n  - The probability that the receiver of this write is black is given as $p_R = 0.95$.\n  - The target of this write is the \"newly constructed head node,\" which is a new and therefore white object. So, the probability of the target being white is $1$.\n  - The expected number of barrier triggers for this single write is $1 \\times p_R \\times 1 = 0.95$.\n\n- The total expected number of triggers for the immutable implementation is the sum of these two parts:\n  $E_{imm} = 0 + 0.95 = 0.95$\n\n**3. Fraction of Eliminated Barrier Triggers**\n\n- The number of barrier triggers eliminated per operation is $E_{mut} - E_{imm}$.\n- The fraction of eliminated triggers is this difference divided by the original number of triggers:\n  Fraction Eliminated = $\\frac{E_{mut} - E_{imm}}{E_{mut}} = \\frac{16.8 - 0.95}{16.8} = \\frac{15.85}{16.8}$\n- Calculating the value:\n  $\\frac{15.85}{16.8} \\approx 0.94345238...$\n\n- Rounding to four significant figures, we get $0.9435$.", "answer": "$$\n\\boxed{0.9435}\n$$", "id": "3679450"}, {"introduction": "Real-world programming languages often include features that complicate the simple 'object-as-a-node' heap model. This exercise ([@problem_id:3679535]) delves into one such feature: interior pointers, where a reference can point inside an object rather than to its start. You are challenged to think like a language implementer and evaluate different write barrier schemes designed to uphold the crucial $B \\not\\to W$ invariant in the presence of this complexity, highlighting the design trade-offs involved in building a robust garbage collector.", "problem": "An incremental tracing Garbage Collector (GC) uses the tri-color marking invariant in which reachable objects are partitioned into white, gray, and black sets. The invariant requires that no black object points to any white object, formally $B \\not\\to W$, at all points during the marking phase. Consider a language that permits interior pointers: a pointer $p$ may be computed as $p = b + \\Delta$ where $b$ is the base address of an object and $\\Delta$ is an offset to a location inside that object. The mutator performs stores that may install $p$ into fields of already scanned (black) objects while the GC is concurrently marking.\n\nAssume the collector maintains standard heap metadata sufficient to find object boundaries at allocation time, and that the write barrier can consult metadata at store time. The requirement is to ensure that, when a pointer to the interior of an object is written during concurrent marking, the barrier scheme maintains $B \\not\\to W$ even when the pointer representation is $p = b + \\Delta$ and the target base object is currently white.\n\nWhich of the following barrier schemes ensure the tri-color invariant under these conditions? Select all that apply.\n\nA. An insertion write barrier that, on any store of a pointer $p$, computes the base object $b = \\mathrm{base}(p)$ using a precise address-to-object map maintained by the runtime; if the collector is in its marking phase and $b$ is white, the barrier shades $b$ gray immediately.\n\nB. A deletion write barrier that, on overwriting a field in a black object, records the old pointer value in a remembered set without consulting or shading the new pointer’s target; the collector relies on snapshot-at-beginning semantics to eventually mark all reachable objects.\n\nC. A fat-pointer scheme in which every interior pointer is represented as a pair $(b, \\Delta)$ carried explicitly by the pointer; the insertion write barrier uses $b$ to test and, if necessary, shade the base object when such a pointer is stored during marking.\n\nD. A pure card-marking barrier that, on any store, marks the destination card containing the black object without inspecting the stored pointer; the collector later rescans marked cards to discover and process new references, with no immediate shading of the stored pointer’s base object.", "solution": "The problem asks which barrier schemes maintain the strong tri-color invariant ($B \\not\\to W$) when a mutator stores an interior pointer to a white object into a field of a black object. The key challenge is for the barrier to identify the white base object from the interior pointer and take corrective action.\n\n- **A. Correct.** This scheme directly addresses the problem. The write barrier intercepts the store, uses runtime metadata to find the base object `b` corresponding to the interior pointer `p`, checks if `b` is white, and shades it gray. This action prevents the creation of a $B \\to W$ edge by converting it into a permissible $B \\to G$ edge, thus upholding the invariant.\n\n- **B. Incorrect.** A deletion barrier is designed to preserve snapshot-at-the-beginning (SATB) semantics by tracking *overwritten* pointers, not newly inserted ones. It does nothing to prevent the creation of a new $B \\to W$ pointer, which is the threat described in the problem. Therefore, it does not maintain the invariant in this scenario.\n\n- **C. Correct.** This scheme makes the job of the write barrier easier. By representing interior pointers as a \"fat pointer\" pair $(b, \\Delta)$, the base object `b` is immediately available to the barrier without needing a metadata lookup. The barrier can then directly check the color of `b` and shade it gray if necessary. This is a practical and efficient implementation of the logic described in option A and correctly maintains the invariant.\n\n- **D. Incorrect.** A pure card-marking barrier is a source-based barrier. It marks the card containing the *source* of the write (the black object) as dirty. It does not immediately shade the target white object. This means the $B \\not\\to W$ invariant is *temporarily violated* at the moment of the store. Safety is maintained by a weaker invariant (any $B \\to W$ pointer must be on a dirty card), and the violation is only repaired later when the collector rescans the dirty card. Because the question requires maintaining the invariant *at all points*, this scheme is not a valid answer.\n\nTherefore, schemes A and C are the correct solutions.", "answer": "$$\\boxed{AC}$$", "id": "3679535"}, {"introduction": "There is no better way to truly understand an algorithm than to implement it. This final hands-on challenge ([@problem_id:3251661]) guides you through building a complete, albeit simplified, simulation of a concurrent tri-color marking garbage collector. By coding the interactions between the collector, a mutator thread, and the necessary write barrier, you will confront the practical realities of concurrency, synchronization, and algorithmic correctness, solidifying your grasp of how these complex systems function in harmony.", "problem": "You are to implement a concurrent tri-color marking garbage collector and demonstrate its correctness in the presence of a mutator thread that performs allocations and pointer updates while marking proceeds. The heap is modeled as a directed graph $G = (V, E)$, where $V$ is a finite set of object identifiers and $E \\subseteq V \\times V$ represents pointers between objects. There is a distinguished set of root references $R \\subseteq V$ from which reachability is defined. An object $u \\in V$ is considered live if and only if there exists a directed path from some root $r \\in R$ to $u$, and otherwise the object is garbage.\n\nFundamental base: use the following well-tested facts and core definitions.\n- Directed graph reachability: an object $u \\in V$ is reachable from $R$ if there exists a path $(r = v_0, v_1, \\dots, v_k = u)$ with $k \\geq 0$ and $(v_i, v_{i+1}) \\in E$ for all $i \\in \\{0, \\dots, k-1\\}$.\n- Heap safety constraint for incremental marking, known as the tri-color invariant: during the marking phase, maintain three disjoint sets $W$ (white), $G$ (grey), and $B$ (black), partitioning $V$, such that no black object points to a white object. Informally, $W$ contains potentially garbage objects, $G$ contains discovered but not yet fully scanned objects, and $B$ contains fully scanned objects.\n- A write barrier is required for concurrent marking to uphold the tri-color invariant when the mutator stores a pointer from a black object to a white object.\n\nYour program must implement:\n1. A concurrent tri-color marking collector that runs in a separate thread. Initially, set $W = V$, $G = R$, $B = \\emptyset$. As marking proceeds, move objects from $G$ to $B$, and when scanning a grey object, any white child discovered must be moved into $G$.\n2. A mutator thread that performs allocations and pointer updates. Allocations during marking start in $W$. The mutator must employ an insertion write barrier: when storing a pointer from a black source to a white target during marking, the target must be moved to $G$ so that no black-to-white edge exists.\n3. A sweep phase that reclaims all objects still in $W$ after marking completes.\n\nYou must design the program to be deterministic and thread-safe. Concurrency must be demonstrable by interleaving collector and mutator operations via explicit synchronization (for example, signaling when specific objects transition to black). Your program will execute a single marking-sweep cycle per test case and produce quantitative outcomes.\n\nTest Suite. Use the following three test cases, each described by the initial heap graph and the mutator’s actions. For each case, after the mutator finishes and the collector completes marking, compute:\n- The number of objects reclaimed by the sweep (an integer).\n- Whether the tri-color invariant “no black object points to a white object” holds at the end of marking (a boolean).\n- Whether all retained objects after sweep (the black set) are exactly the objects reachable from $R$ in the final heap state (a boolean).\n\nThe three test cases are:\n- Test case $1$ (static graph, happy path): $V = \\{0, 1, 2, 3, 4\\}$, $R = \\{0\\}$, and $E = \\{(0, 1), (1, 2)\\}$. The mutator performs no operations. After marking, perform sweep and compute results.\n- Test case $2$ (black-to-white insertion under a write barrier): initial $V = \\{0, 1\\}$, $R = \\{0\\}$, $E = \\{(0, 1)\\}$. The mutator waits until node $1$ is marked black, then allocates node $2$ and stores the pointer $(0, 2)$. The write barrier must shade $2$ to grey immediately. After marking, perform sweep and compute results.\n- Test case $3$ (floating garbage due to deletion): initial $V = \\{0, 1, 2\\}$, $R = \\{0\\}$, $E = \\{(0, 1), (1, 2)\\}$. The mutator waits until node $2$ is marked black, then removes the pointer $(1, 2)$. This can produce floating garbage (an unreachable black object) that should not be reclaimed in the current cycle. After marking, perform sweep and compute results.\n\nFinal Output Format. Your program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets. Each test case’s result is a list of the form `[k, i, j]` where $k$ is the integer count of reclaimed objects, $i$ is the boolean tri-color invariant check at the end of marking, and $j$ is the boolean test “all retained objects equal final reachable set.” For example, the output format must be like `[[2,True,True],[0,True,True],[0,True,False]]`.", "solution": "The problem requires the implementation and validation of a concurrent tri-color marking garbage collector. The heap is modeled as a directed graph $G = (V, E)$, with a set of roots $R \\subseteq V$. An object is live if it is reachable from $R$. The core of the problem lies in correctly simulating the interaction between a garbage collector thread and a mutator thread, ensuring heap safety via a write barrier, and demonstrating the outcomes for specific test cases.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **Heap Model**: A directed graph $G = (V, E)$, where $V$ is a set of objects and $E \\subseteq V \\times V$ represents pointers.\n- **Roots**: A distinguished set $R \\subseteq V$.\n- **Liveness Definition**: An object $u \\in V$ is live if reachable from a root in $R$.\n- **Tri-color Marking**: The set of objects $V$ is partitioned into three disjoint sets: $W$ (white), $G$ (grey), and $B$ (black).\n    - Initial State: $W = V \\setminus R$, $G = R$, $B = \\emptyset$.\n    - Marking Logic: An object is moved from $G$ to $B$ after its children have been processed. Any white child of a grey object is moved to $G$.\n- **Tri-color Invariant**: No black object may point to a white object.\n- **Write Barrier**: An insertion write barrier is mandated. When the mutator creates a pointer from a black object to a white object, the target white object must be shaded grey (moved to $G$).\n- **Allocation Policy**: Newly allocated objects are initially white.\n- **Sweep Phase**: After marking, all objects remaining in $W$ are reclaimed.\n- **Concurrency Model**: The collector and mutator run as separate threads. Their interactions are to be made deterministic through explicit synchronization.\n- **Test Cases**:\n    1.  **Static Graph**: $V = \\{0, 1, 2, 3, 4\\}$, $R = \\{0\\}$, $E = \\{(0, 1), (1, 2)\\}$. The mutator is idle.\n    2.  **Insertion with Write Barrier**: Initial $V = \\{0, 1\\}$, $R = \\{0\\}$, $E = \\{(0, 1)\\}$. The mutator waits for object $1$ to become black, then allocates object $2$ and adds a pointer $(0, 2)$. The write barrier must grey-shade object $2$.\n    3.  **Deletion causing Floating Garbage**: Initial $V = \\{0, 1, 2\\}$, $R = \\{0\\}$, $E = \\{(0, 1), (1, 2)\\}$. The mutator waits for object $2$ to become black, then removes the pointer $(1, 2)$.\n- **Required Output Metrics**: For each case, compute: (1) number of reclaimed objects, (2) a boolean indicating if the tri-color invariant holds post-marking, and (3) a boolean indicating if the set of retained objects equals the set of truly reachable objects in the final heap state.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem statement is evaluated as valid.\n- **Scientifically Grounded**: The problem is based on the foundational principles of automatic memory management, specifically the tri-color abstraction for incremental garbage collection, which is a standard and well-documented algorithm in computer science.\n- **Well-Posed**: The problem is clearly defined with explicit initial conditions, rules of operation for the collector and mutator, and precise, quantitative goals. The requirement for deterministic simulation via explicit synchronization ensures a unique solution exists for each test case.\n- **Objective**: The problem uses formal, unambiguous language ($G = (V, E)$, $R \\subseteq V$) and established terminology (write barrier, floating garbage).\n\nThe problem exhibits no flaws such as scientific unsoundness, ambiguity, or incompleteness. It constitutes a well-structured challenge in algorithmic simulation.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A reasoned solution follows.\n\n### Algorithmic Design and Principles\n\nThe simulation is architected around a central class that encapsulates the heap state and manages the concurrent execution of the collector and mutator.\n\n**1. Heap and State Representation**\n- The graph $G=(V, E)$ is represented using a dictionary where keys are object identifiers (integers) and values are sets of identifiers of the objects they point to.\n- The sets $V, R, W, G, B$ are modeled using Python's `set` data structure, which provides efficient membership testing and modification. To ensure deterministic marking order, the grey set $G$ is implemented as a queue (using a `list` with `pop(0)`), ensuring a Breadth-First Search (BFS) traversal pattern.\n- Thread safety for all shared state (the graph and the color sets) is guaranteed by a single `threading.Lock`. All accesses and modifications to these shared resources by either the collector or the mutator must acquire this lock.\n\n**2. Collector Thread**\nThe collector's task is to execute the marking phase. Its core logic is an event loop that continues as long as there is potential work to be done. The termination condition for this loop is critical for correctness: it must cease only when the mutator thread has terminated *and* the grey set $G$ is empty. This ensures that any objects greyed by the mutator's write barrier are processed by the collector.\nThe loop proceeds as follows:\n- `while mutator_is_alive or len(G) > 0:`\n    - Attempt to dequeue an object $u$ from $G$.\n    - If an object $u$ is dequeued:\n        1.  Scan its children. For each child $v$ of $u$, if $v$ is in the white set $W$, move it from $W$ to $G$.\n        2.  After scanning, move $u$ from $G$ to the black set $B$.\n        3.  Signal an event to indicate that $u$ is now black. This is used for synchronizing with the mutator as required by test cases $2$ and $3$.\n    - If $G$ is empty, the thread briefly sleeps to yield the CPU, allowing the mutator to run and potentially add new objects to $G$.\n\n**3. Mutator Thread and Write Barrier**\nThe mutator executes a pre-defined sequence of operations for each test case. These operations include waiting for specific collector events, allocating new objects, and modifying pointers.\n- **Allocation**: A new object is created by adding it to the set of all objects $V$ and the white set $W$.\n- **Pointer Update**: Modifying the heap graph involves two key operations:\n    - **Edge Addition**: `add_edge(source, target)`. This is where the write barrier is implemented. Before adding the edge $(source, target)$ to the graph, the barrier checks the colors. If `source` $\\in B$ and `target` $\\in W$, the tri-color invariant would be violated. To prevent this, the barrier moves `target` from $W$ to $G$. This action ensures that the newly reachable object `target` will be scanned by the collector.\n    - **Edge Removal**: `remove_edge(source, target)`. In this specific garbage collector model (an incremental update collector without a deletion barrier), removing a pointer requires no special action from the barrier. This can lead to \"floating garbage,\" where an object becomes unreachable but remains black (e.g., test case $3$), and is therefore not collected in the current cycle.\n\n**4. Post-Simulation Analysis**\nAfter both threads have completed, a final analysis is performed to compute the required metrics.\n- **Reclaimed Objects**: The set of reclaimed objects is precisely the final white set $W$. The count is simply $|W|$.\n- **Tri-color Invariant Verification**: The invariant \"no black object points to a white object\" is checked by iterating through every object $u \\in B$ and verifying that for every child $v$ of $u$, $v \\notin W$.\n- **Correctness Verification**: The set of objects retained by the collector is $B$ (since at termination, $G$ is empty). The \"ground truth\" set of live objects is determined by performing a fresh reachability traversal (e.g., BFS) on the *final* state of the heap graph, starting from the roots $R$. The collector is deemed correct for that cycle if the set of retained objects $B$ is identical to this computed set of reachable objects. Test case $3$ is designed to show a scenario where this is not the case due to floating garbage.\n\nThis design provides a deterministic and thread-safe simulation of a concurrent garbage collector, correctly modeling the key interactions and trade-offs inherent in the tri-color marking algorithm.", "answer": "```python\nimport threading\nimport time\nfrom typing import List, Set, Dict, Tuple, Callable\n\n# According to the problem spec, numpy must be imported.\nimport numpy as np\n\nclass GCSimulator:\n    \"\"\"\n    Simulates a concurrent tri-color marking garbage collector and a mutator.\n    This class encapsulates the state of the heap, the collector, and the mutator\n    for a single test run, ensuring thread safety and deterministic behavior.\n    \"\"\"\n\n    def __init__(self,\n                 initial_V: Set[int],\n                 initial_R: Set[int],\n                 initial_E: Set[Tuple[int, int]],\n                 mutator_func: Callable[['GCSimulator'], None]):\n        # Heap representation\n        self.V: Set[int] = initial_V.copy()\n        self.R: Set[int] = initial_R.copy()\n        self.adj: Dict[int, Set[int]] = {u: set() for u in self.V}\n        for u, v in initial_E:\n            if u in self.adj:\n                self.adj[u].add(v)\n\n        # Tri-color sets\n        self.W: Set[int] = self.V - self.R\n        # Use a list as a queue for deterministic (BFS-like) marking\n        self.G: List[int] = list(self.R)\n        self.B: Set[int] = set()\n\n        # Concurrency control\n        self.lock = threading.Lock()\n        self.black_events: Dict[int, threading.Event] = {\n            # Lazily create events as objects are added\n        }\n        for v_obj in self.V:\n            self.black_events[v_obj] = threading.Event()\n            \n        self.mutator_alive = True\n        self._mutator_func = mutator_func\n        \n        self.collector_thread = threading.Thread(target=self._collector_task)\n        self.mutator_thread = threading.Thread(target=self._mutator_task)\n\n    def _collector_task(self):\n        \"\"\"The main loop for the garbage collector thread.\"\"\"\n        while self.mutator_alive or self.G:\n            u = -1  # Use a sentinel value\n            work_to_do = False\n            with self.lock:\n                if self.G:\n                    u = self.G.pop(0)\n                    work_to_do = True\n            \n            if work_to_do:\n                # Process the grey object u\n                with self.lock:\n                    children = self.adj.get(u, set()).copy()\n                \n                for v in children:\n                    with self.lock:\n                        if v in self.W:\n                            self.W.remove(v)\n                            self.G.append(v)\n                \n                with self.lock:\n                    self.B.add(u)\n                    if u in self.black_events:\n                        self.black_events[u].set()\n            else:\n                # If no work, yield to allow mutator to run\n                time.sleep(0.001)\n\n    def _mutator_task(self):\n        \"\"\"Wrapper to run the mutator function and signal completion.\"\"\"\n        self._mutator_func(self)\n        self.mutator_alive = False\n\n    def run_simulation(self):\n        \"\"\"Starts and joins collector and mutator threads.\"\"\"\n        self.collector_thread.start()\n        self.mutator_thread.start()\n        self.collector_thread.join()\n        self.mutator_thread.join()\n\n    # --- Mutator API ---\n    def add_object(self, u: int):\n        with self.lock:\n            self.V.add(u)\n            self.W.add(u)\n            self.adj[u] = set()\n            self.black_events[u] = threading.Event()\n    \n    def add_edge(self, source: int, target: int):\n        with self.lock:\n            # Insertion Write Barrier implementation\n            if source in self.B and target in self.W:\n                self.W.remove(target)\n                self.G.append(target)\n            \n            if source in self.adj:\n                self.adj[source].add(target)\n\n    def remove_edge(self, source: int, target: int):\n        with self.lock:\n            if source in self.adj and target in self.adj[source]:\n                self.adj[source].remove(target)\n\n    # --- Analysis ---\n    def analyze_results(self) -> List:\n        \"\"\"Computes the required metrics after the simulation.\"\"\"\n        \n        # 1. Count reclaimed objects\n        reclaimed_count = len(self.W)\n\n        # 2. Check tri-color invariant: no black object points to a white one\n        invariant_holds = True\n        with self.lock:\n            for u in self.B:\n                for v in self.adj.get(u, set()):\n                    if v in self.W:\n                        invariant_holds = False\n                        break\n                if not invariant_holds:\n                    break\n        \n        # 3. Check if retained set (B) equals the final reachable set\n        final_reachable = set()\n        q = list(self.R)\n        visited = set(self.R)\n        while q:\n            u = q.pop(0)\n            final_reachable.add(u)\n            for v in self.adj.get(u, set()):\n                if v not in visited:\n                    visited.add(v)\n                    q.append(v)\n        \n        retained_is_reachable = (self.B == final_reachable)\n\n        return [reclaimed_count, invariant_holds, retained_is_reachable]\n\n# --- Mutator Functions for Test Cases ---\ndef mutator_case1(sim: GCSimulator):\n    pass # No operations\n\ndef mutator_case2(sim: GCSimulator):\n    # Wait until node 1 is marked black\n    sim.black_events[1].wait()\n    # Allocate node 2\n    sim.add_object(2)\n    # Store pointer (0, 2), triggering write barrier\n    sim.add_edge(0, 2)\n\ndef mutator_case3(sim: GCSimulator):\n    # Wait until node 2 is marked black\n    sim.black_events[2].wait()\n    # Remove pointer (1, 2), potentially creating floating garbage\n    sim.remove_edge(1, 2)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"V\": {0, 1, 2, 3, 4},\n            \"R\": {0},\n            \"E\": {(0, 1), (1, 2)},\n            \"mutator\": mutator_case1\n        },\n        {\n            \"V\": {0, 1},\n            \"R\": {0},\n            \"E\": {(0, 1)},\n            \"mutator\": mutator_case2\n        },\n        {\n            \"V\": {0, 1, 2},\n            \"R\": {0},\n            \"E\": {(0, 1), (1, 2)},\n            \"mutator\": mutator_case3\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        simulator = GCSimulator(case[\"V\"], case[\"R\"], case[\"E\"], case[\"mutator\"])\n        simulator.run_simulation()\n        result = simulator.analyze_results()\n        results.append(result)\n\n    # Format the output string exactly as specified, without spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3251661"}]}