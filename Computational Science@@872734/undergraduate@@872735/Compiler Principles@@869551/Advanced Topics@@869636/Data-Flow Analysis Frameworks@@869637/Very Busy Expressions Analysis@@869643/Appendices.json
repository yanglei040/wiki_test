{"hands_on_practices": [{"introduction": "To begin, let's solidify our understanding of the fundamental definition of a very busy expression. This practice problem [@problem_id:3682374] focuses on the 'must' nature of the analysis, requiring an expression to be evaluated on *every* possible execution path. By tracing the control flow, you will see how a single path that bypasses a computation can prevent an expression from being considered very busy at an earlier point.", "problem": "Consider the following straight-line fragment with explicit gotos and a merge. Let the goal expression be $e \\equiv x + y$. Assume $b$ is a boolean whose evaluation has no side effects and does not modify $x$ or $y$. Also assume no hidden side effects in any statement other than those explicitly shown.\n\n$S_1$: if $(b)$ goto $S_2$ else goto $S_4$\n\n$S_2$: $t \\leftarrow x + y$\n\n$S_3$: goto $S_5$\n\n$S_4$: goto $S_5$\n\n$S_5$: $y \\leftarrow y + 1$\n\n$S_6$: $u \\leftarrow x + y$\n\nThe control transfers are: from $S_1$ to either $S_2$ or $S_4$; from $S_2$ to $S_3$; from $S_3$ and $S_4$ to the merge at $S_5$; and then to $S_6$.\n\nDefinition (fundamental base): An expression $e$ is very busy at a program point $p$ if along every path starting at $p$, an evaluation of $e$ occurs before any assignment to any operand of $e$. This is a backward must property in data-flow analysis.\n\nQuestion: Which of the following program points have $x+y$ very busy, in the sense of the above definition?\n\nA. Immediately before $S_1$\n\nB. Immediately before $S_2$\n\nC. Immediately before $S_4$\n\nD. Immediately before $S_5$\n\nE. Immediately before $S_6$\n\nSelect all that apply. Your justification should rely on the stated definition and the control flow described, paying careful attention to the path that uses a goto to skip the computation at $S_2$ and the merge at $S_5$ where paths rejoin.", "solution": "The problem asks to determine at which program points the expression $e \\equiv x + y$ is \"very busy\".\n\nFirst, let us formalize the problem based on the provided information.\nThe program consists of a sequence of statements $S_1$ through $S_6$. The control flow graph (CFG) is as follows:\n- An initial block enters $S_1$.\n- From $S_1$, there are two branches: to $S_2$ or to $S_4$.\n- From $S_2$, control flows to $S_3$.\n- From $S_4$, control flows to $S_5$.\n- From $S_3$, control flows to $S_5$. Thus, $S_5$ is a merge point for the paths from $S_3$ and $S_4$.\n- From $S_5$, control flows to $S_6$.\n- From $S_6$, the fragment ends.\n\nThe statements are:\n- $S_1$: `if (b) goto S_2 else goto S_4`\n- $S_2$: `t ← x + y`\n- $S_3$: `goto S_5`\n- $S_4$: `goto S_5`\n- $S_5$: `y ← y + 1`\n- $S_6$: `u ← x + y`\n\nThe goal expression is $e \\equiv x + y$. The operands of $e$ are $x$ and $y$.\n- The expression $e$ is evaluated in statements $S_2$ and $S_6$.\n- An operand of $e$ is modified (a \"kill\" for $e$) in statement $S_5$, where $y$ is assigned a new value.\n\nThe provided definition is: \"An expression $e$ is very busy at a program point $p$ if along every path starting at $p$, an evaluation of $e$ occurs before any assignment to any operand of $e$.\"\n\nWe will now analyze each program point specified in the options.\n\nA. **Immediately before $S_1$**\nLet the program point immediately before $S_1$ be $p_1$. From $p_1$, there are two possible paths through the code fragment:\n1. Path 1: $S_1 \\rightarrow S_2 \\rightarrow S_3 \\rightarrow S_5 \\rightarrow S_6 \\rightarrow \\dots$\n2. Path 2: $S_1 \\rightarrow S_4 \\rightarrow S_5 \\rightarrow S_6 \\rightarrow \\dots$\n\nThe definition requires the condition to hold for *every* path. Let's examine Path 2.\n- On this path, the first statement that involves $e$ or its operands is $S_5$, which contains the assignment $y \\leftarrow y + 1$. This is an assignment to an operand of $e$.\n- The first evaluation of $e$ on this path occurs later, in statement $S_6$.\n- Therefore, on Path 2, an assignment to an operand of $e$ occurs *before* an evaluation of $e$.\nSince the condition fails for one of the paths starting at $p_1$, the expression $x+y$ is not very busy immediately before $S_1$.\n**Verdict: Incorrect**\n\nB. **Immediately before $S_2$**\nLet the program point immediately before $S_2$ be $p_2$. There is only one path starting from $p_2$:\n1. Path 1: $S_2 \\rightarrow S_3 \\rightarrow S_5 \\rightarrow S_6 \\rightarrow \\dots$\n\nLet's examine this path.\n- The very first statement on this path is $S_2$.\n- $S_2$ contains the evaluation $t \\leftarrow x + y$.\n- No assignment to $x$ or $y$ occurs before this evaluation on this path (the first such assignment is in $S_5$, which is after $S_2$).\n- Thus, along this path, an evaluation of $e$ occurs before any assignment to an operand of $e$.\nSince this is the only path starting from $p_2$, the condition holds for \"every path\". Therefore, the expression $x+y$ is very busy immediately before $S_2$.\n**Verdict: Correct**\n\nC. **Immediately before $S_4$**\nLet the program point immediately before $S_4$ be $p_4$. There is only one path starting from $p_4$:\n1. Path 1: $S_4 \\rightarrow S_5 \\rightarrow S_6 \\rightarrow \\dots$\n\nLet's examine this path.\n- The first statement on this path is $S_4$, which is a `goto` and does not affect $e$ or its operands.\n- The next statement is $S_5$, which contains the assignment $y \\leftarrow y + 1$. This is an assignment to an operand of $e$.\n- The first evaluation of $e$ on this path occurs later, in statement $S_6$.\n- Therefore, on this path, an assignment to an operand of $e$ occurs *before* an evaluation of $e$.\nThe condition fails. Therefore, the expression $x+y$ is not very busy immediately before $S_4$.\n**Verdict: Incorrect**\n\nD. **Immediately before $S_5$**\nLet the program point immediately before $S_5$ be $p_5$. There is only one path starting from $p_5$:\n1. Path 1: $S_5 \\rightarrow S_6 \\rightarrow \\dots$\n\nLet's examine this path.\n- The first statement is $S_5$, which contains the assignment $y \\leftarrow y + 1$. This is an assignment to an operand of $e$.\n- The first evaluation of $e$ on this path occurs in the next statement, $S_6$.\n- Therefore, on this path, an assignment to an operand of $e$ occurs *before* an evaluation of $e$.\nThe condition fails. Therefore, the expression $x+y$ is not very busy immediately before $S_5$.\n**Verdict: Incorrect**\n\nE. **Immediately before $S_6$**\nLet the program point immediately before $S_6$ be $p_6$. There is only one path starting from $p_6$:\n1. Path 1: $S_6 \\rightarrow \\dots$\n\nLet's examine this path.\n- The very first statement on this path is $S_6$.\n- $S_6$ contains the evaluation $u \\leftarrow x + y$.\n- No assignment to $x$ or $y$ occurs before this evaluation (or within $S_6$ before the evaluation).\n- Thus, along this path, an evaluation of $e$ occurs before any (possible subsequent) assignment to an operand of $e$.\nSince this is the only path starting from $p_6$, the condition holds for \"every path\". Therefore, the expression $x+y$ is very busy immediately before $S_6$.\n**Verdict: Correct**\n\nSummary of analysis:\n- A: Not very busy.\n- B: Very busy.\n- C: Not very busy.\n- D: Not very busy.\n- E: Very busy.\n\nThe correct options are B and E.", "answer": "$$\\boxed{BE}$$", "id": "3682374"}, {"introduction": "Building on the core definition, this exercise [@problem_id:3682423] zeroes in on the crucial 'kill' condition, where an expression is invalidated if one of its operands is redefined. This problem explores the subtle but important impact of a *conditional* redefinition on the analysis. You will determine how the mere possibility of a variable changing on one branch is sufficient to prevent an expression from being very busy, reinforcing the strict requirements of this 'must' analysis.", "problem": "Consider the following straight-line fragment with a conditional, written in terms of a Control Flow Graph (CFG) with the usual semantics of assignments and conditionals. All variables are scalar integers, and the condition is a boolean value. The fragment has two computations of the same binary arithmetic expression $x+y$ separated by an increment to $x$:\n- Line $1$: $t_1 := x + y$\n- Line $2$: if $c$ then $x := x + 1$ else skip\n- Line $3$: $t_2 := x + y$\nAssume $c$ is an arbitrary boolean and there is no additional information about its value (that is, $c$ is not known to be always true or always false). Focus on the expression $x+y$ and the following two program points:\n- $P_{\\text{entry}}$: the program point immediately before line $1$.\n- $P_{1}$: the program point immediately after line $1$ and before line $2$.\nUse the standard definition of a very busy expression: an expression $e$ is very busy at a program point $p$ if, along every path starting at $p$ and proceeding to a program exit (or the end of the region under consideration), there is a subsequent evaluation of $e$ that occurs before any assignment to any variable appearing in $e$. Also use the standard kill concept: a statement $v := \\cdots$ kills any expression containing the variable $v$ in the sense that, from that statement forward, the previously anticipated value of such an expression cannot be reused without recomputation.\n\nBased solely on these definitions, and the fragment above, which of the following statements are correct? Select all that apply.\n\nA. The assignment $x := x + 1$ kills the expression $x+y$ for the purpose of very busy analysis at $P_{1}$; therefore $x+y$ is not very busy at $P_{1}$, but $x+y$ is very busy at $P_{\\text{entry}}$ due to the imminent evaluation at line $1$.\n\nB. The assignment $x := x + 1$ does not kill $x+y$ because the expression is recomputed at line $3$; therefore $x+y$ is very busy at both $P_{1}$ and $P_{\\text{entry}}$.\n\nC. An assignment kills $x+y$ only if both $x$ and $y$ are assigned before the next evaluation; since only $x$ is assigned at line $2$, $x+y$ remains very busy at $P_{1}$.\n\nD. The expression $x+y$ would be very busy at $P_{1}$ only if $c$ is known to be definitely false; otherwise, the possible execution of $x := x + 1$ on the true branch prevents $x+y$ from being very busy at $P_{1}$.", "solution": "The problem statement is critically validated and found to be valid. It is a well-posed problem within the standard framework of data-flow analysis in compiler theory. The definitions provided for a \"very busy expression\" and the \"kill\" concept are standard and unambiguous. The code fragment is simple and sufficient for the analysis requested.\n\nWe are asked to determine the \"very busy\" status of the expression $x+y$ at two program points: $P_{\\text{entry}}$ (before line $1$) and $P_1$ (after line $1$, before line $2$).\n\nThe definition of a very busy expression is as follows: an expression $e$ is very busy at a program point $p$ if, along **every path** starting at $p$ and proceeding to an exit, there is a subsequent evaluation of $e$ that occurs **before any assignment** to any variable appearing in $e$. This is a backward data-flow analysis problem. The \"every path\" requirement implies that the confluence operator at a point where control flow joins (or diverges, in a backward analysis) is intersection.\n\nLet's analyze the liveness of $x+y$ by working backward from the end of the fragment.\n\n1.  **At the point immediately after line $3$ (the exit of this fragment):** The expression $x+y$ is not very busy because there are no subsequent paths, and thus no subsequent evaluations.\n\n2.  **At the point immediately before line $3$:** There is exactly one path forward, which is the execution of line $3$: $t_2 := x + y$. This is an evaluation of $x+y$, and it occurs before any other assignments to $x$ or $y$. Therefore, $x+y$ is very busy at the point just before line $3$. This point is the merge point after the conditional in line $2$.\n\n3.  **At program point $P_1$ (before line $2$):** To determine if $x+y$ is very busy at $P_1$, we must examine all paths starting from $P_1$. Due to the conditional `if c`, there are two paths:\n    *   **Path A (the 'true' branch):** The statement $x := x + 1$ is executed. This is an assignment to the variable $x$, which appears in the expression $x+y$. According to the definition, an assignment to any variable in an expression prevents that expression from being anticipated along that path. The problem states that a statement $v := \\cdots$ *kills* any expression containing $v$. The assignment $x := x + 1$ thus kills the anticipation of $x+y$. Although $x+y$ is evaluated later at line $3$, this evaluation occurs *after* the variable $x$ has been redefined. So, along this path, the condition for being very busy is not met.\n    *   **Path B (the 'false' branch):** The `skip` statement is executed. This does not modify any variables. The path continues to line $3$, where $x+y$ is evaluated. Along this path, $x+y$ is evaluated before any of its constituent variables are reassigned. So, along this path, the condition for being very busy is met.\n\n    The definition of \"very busy\" requires the condition to hold on **every path**. Since the condition fails for Path A, the expression $x+y$ is **not very busy** at program point $P_1$. The problem explicitly states that $c$ is arbitrary, so we must assume both paths are possible.\n\n4.  **At program point $P_{\\text{entry}}$ (before line $1$):** From $P_{\\text{entry}}$, there is only one path forward, leading immediately to line $1$: $t_1 := x + y$. This is an evaluation of the expression $x+y$. This evaluation is the very first event on the path, so it necessarily occurs before any redefinition of $x$ or $y$. Therefore, the expression $x+y$ **is very busy** at program point $P_{\\text{entry}}$.\n\nSummary of analysis:\n*   At $P_{\\text{entry}}$, $x+y$ is very busy.\n*   At $P_1$, $x+y$ is not very busy.\n\nNow we evaluate each option.\n\n**A. The assignment $x := x + 1$ kills the expression $x+y$ for the purpose of very busy analysis at $P_{1}$; therefore $x+y$ is not very busy at $P_{1}$, but $x+y$ is very busy at $P_{\\text{entry}}$ due to the imminent evaluation at line $1$.**\nThis statement aligns perfectly with our analysis. The assignment $x := x + 1$ on the true branch does indeed kill the anticipation of $x+y$. Because the \"very busy\" property must hold for all paths, and it fails for this path, $x+y$ is not very busy at $P_1$. The statement also correctly concludes that $x+y$ is very busy at $P_{\\text{entry}}$ because of the immediate evaluation at line $1$.\n**Verdict: Correct**\n\n**B. The assignment $x := x + 1$ does not kill $x+y$ because the expression is recomputed at line $3$; therefore $x+y$ is very busy at both $P_{1}$ and $P_{\\text{entry}}$.**\nThis statement misinterprets the concept of \"kill\" in data-flow analysis. An assignment to a variable $v$ kills any expression containing $v$. The fact that the expression is recomputed later does not negate the kill. The kill action on a path means that the value of the expression from before the assignment cannot be used, which breaks the \"very busy\" condition for that path. The conclusion that $x+y$ is very busy at $P_1$ is incorrect, as derived above.\n**Verdict: Incorrect**\n\n**C. An assignment kills $x+y$ only if both $x$ and $y$ are assigned before the next evaluation; since only $x$ is assigned at line $2$, $x+y$ remains very busy at $P_{1}$.**\nThis statement presents an incorrect definition of \"kill\". An expression is killed if **any** of its variables are redefined. Modifying $x$ is sufficient to kill $x+y$. The premise is false, and the conclusion that $x+y$ remains very busy at $P_1$ is consequently incorrect.\n**Verdict: Incorrect**\n\n**D. The expression $x+y$ would be very busy at $P_{1}$ only if $c$ is known to be definitely false; otherwise, the possible execution of $x := x + 1$ on the true branch prevents $x+y$ from being very busy at $P_{1}$.**\nThis statement provides a correct and nuanced explanation. If $c$ were known to be false, the control flow would bypass the assignment $x := x + 1$, effectively reducing the code to a straight line where $x+y$ is evaluated at line $3$ without any intermediate modification to $x$ or $y$. In that hypothetical case, $x+y$ would be very busy at $P_1$. The second part of the statement, \"otherwise, the possible execution of $x := x + 1$ on the true branch prevents $x+y$ from being very busy,\" correctly identifies the reason why $x+y$ is not very busy in the scenario given in the problem, where $c$ is arbitrary. This is a precise description of the \"every path\" rule in action.\n**Verdict: Correct**", "answer": "$$\\boxed{AD}$$", "id": "3682423"}, {"introduction": "Now, let's apply these concepts in a full, systematic data-flow analysis. This comprehensive practice [@problem_id:3682393] guides you through the entire algorithmic process for a small program with branching and merging control flow. You will compute the $B_{GEN}$, $B_{KILL}$, $IN$, and $OUT$ sets for each basic block, bringing all the pieces together to see how the data-flow equations are solved to reach a fixed-point solution.", "problem": "You are given the following three-address program, where all variables are scalar, the boolean predicate $p$ has no side effects, constants are immutable, and temporaries $t_{1}$ and $t_{2}$ never appear as operands in expressions of interest:\n- $1:$ $t_{1} := a \\times b$\n- $2:$ if $p$ then goto $L_{1}$ else goto $L_{2}$\n- $L_{1}:$ $a := a + 1$; goto $L_{3}$\n- $L_{2}:$ $b := b + 1$; goto $L_{3}$\n- $L_{3}:$ $t_{2} := a \\times b$\n\nConsider the control-flow graph with basic blocks $B_{1}$ containing lines $1$–$2$, $B_{2}$ containing line $L_{1}$, $B_{3}$ containing line $L_{2}$, and $B_{4}$ containing line $L_{3}$. Successors are $\\text{succ}(B_{1})=\\{B_{2},B_{3}\\}$, $\\text{succ}(B_{2})=\\{B_{4}\\}$, $\\text{succ}(B_{3})=\\{B_{4}\\}$, and $\\text{succ}(B_{4})=\\emptyset$.\n\nPerform the classical backward must data-flow analysis of very busy expressions as follows:\n- Expression universe $E$ is the set of all side-effect-free binary arithmetic expressions that appear in the program: $E=\\{a \\times b,\\ a+1,\\ b+1\\}$.\n- Meet over successors is set intersection $\\cap$.\n- Transfer function for each basic block $B$ is $IN[B] = B_{GEN} \\cup \\bigl(OUT[B] - B_{KILL}\\bigr)$.\n- By convention for very busy expressions at program exit, $OUT[B_{4}] = \\varnothing$.\n\nUsing only the fundamental definitions of basic blocks, control-flow graphs, sets $B_{GEN}$ and $B_{KILL}$ for very busy expressions, and the above meet and transfer specifications, compute all four sets $B_{GEN}$, $B_{KILL}$, $IN$, and $OUT$ for each basic block $B \\in \\{B_{1},B_{2},B_{3},B_{4}\\}$.\n\nFinally, let $N$ be the scalar given by\n$$\nN \\;=\\; |IN[B_{1}]| \\;+\\; |OUT[B_{1}]| \\;+\\; |IN[B_{2}]| \\;+\\; |OUT[B_{2}]| \\;+\\; |IN[B_{3}]| \\;+\\; |OUT[B_{3}]| \\;+\\; |IN[B_{4}]| \\;+\\; |OUT[B_{4}]|\\,.\n$$\nReport the value of $N$ as a single real number. No rounding is required.", "solution": "The goal is to perform a very busy expressions analysis on the given program and compute the value of $N$. The expression universe is $E=\\{a \\times b, a+1, b+1\\}$.\n\n**Step 1: Compute GEN and KILL sets for each basic block.**\n\nThe GEN set for a block $B$, denoted $B_{GEN}$, contains expressions evaluated in $B$ before any of their operands are modified in $B$.\nThe KILL set for a block $B$, denoted $B_{KILL}$, contains expressions where at least one operand is redefined in $B$.\n\n- **Block $B_1$**: `t1 := a * b`\n  - The expression $a \\times b$ is evaluated. No variables are redefined.\n  - $B_{1,GEN} = \\{a \\times b\\}$\n  - $B_{1,KILL} = \\emptyset$\n\n- **Block $B_2$**: `a := a + 1`\n  - The expression $a + 1$ is evaluated as part of the assignment. The variable `a` is then redefined.\n  - The redefinition of `a` kills any expression containing `a`, which are $a \\times b$ and $a+1$.\n  - $B_{2,GEN} = \\{a + 1\\}$\n  - $B_{2,KILL} = \\{a \\times b, a + 1\\}$\n\n- **Block $B_3$**: `b := b + 1`\n  - The expression $b + 1$ is evaluated. The variable `b` is then redefined.\n  - The redefinition of `b` kills any expression containing `b`, which are $a \\times b$ and $b+1$.\n  - $B_{3,GEN} = \\{b + 1\\}$\n  - $B_{3,KILL} = \\{a \\times b, b + 1\\}$\n\n- **Block $B_4$**: `t2 := a * b`\n  - The expression $a \\times b$ is evaluated. No variables are redefined.\n  - $B_{4,GEN} = \\{a \\times b\\}$\n  - $B_{4,KILL} = \\emptyset$\n\n**Step 2: Solve the data-flow equations.**\n\nThis is a backward analysis, so we work from the exit block ($B_4$) backward. The equations are:\n$OUT[B] = \\bigcap_{S \\in \\text{succ}(B)} IN[S]$\n$IN[B] = B_{GEN} \\cup (OUT[B] - B_{KILL})$\n\nSince the CFG is acyclic, we can solve the equations in a single pass by processing blocks in reverse topological order: $B_4, B_3, B_2, B_1$.\n\n- **Block $B_4$**:\n  - $OUT[B_4] = \\emptyset$ (by the boundary condition for program exit).\n  - $IN[B_4] = B_{4,GEN} \\cup (OUT[B_4] - B_{4,KILL}) = \\{a \\times b\\} \\cup (\\emptyset - \\emptyset) = \\{a \\times b\\}$.\n\n- **Block $B_3$**: (Successor is $B_4$)\n  - $OUT[B_3] = IN[B_4] = \\{a \\times b\\}$.\n  - $IN[B_3] = B_{3,GEN} \\cup (OUT[B_3] - B_{3,KILL}) = \\{b+1\\} \\cup (\\{a \\times b\\} - \\{a \\times b, b+1\\}) = \\{b+1\\} \\cup \\emptyset = \\{b+1\\}$.\n\n- **Block $B_2$**: (Successor is $B_4$)\n  - $OUT[B_2] = IN[B_4] = \\{a \\times b\\}$.\n  - $IN[B_2] = B_{2,GEN} \\cup (OUT[B_2] - B_{2,KILL}) = \\{a+1\\} \\cup (\\{a \\times b\\} - \\{a \\times b, a+1\\}) = \\{a+1\\} \\cup \\emptyset = \\{a+1\\}$.\n\n- **Block $B_1$**: (Successors are $B_2$ and $B_3$)\n  - $OUT[B_1] = IN[B_2] \\cap IN[B_3] = \\{a+1\\} \\cap \\{b+1\\} = \\emptyset$.\n  - $IN[B_1] = B_{1,GEN} \\cup (OUT[B_1] - B_{1,KILL}) = \\{a \\times b\\} \\cup (\\emptyset - \\emptyset) = \\{a \\times b\\}$.\n\n**Step 3: Summarize the sets and calculate N.**\n\nThe final sets are:\n- $IN[B_1] = \\{a \\times b\\}$\n- $OUT[B_1] = \\emptyset$\n- $IN[B_2] = \\{a+1\\}$\n- $OUT[B_2] = \\{a \\times b\\}$\n- $IN[B_3] = \\{b+1\\}$\n- $OUT[B_3] = \\{a \\times b\\}$\n- $IN[B_4] = \\{a \\times b\\}$\n- $OUT[B_4] = \\emptyset$\n\nNow, we calculate the sum of the cardinalities of the $IN$ and $OUT$ sets for all blocks:\n$N = |IN[B_1]| + |OUT[B_1]| + |IN[B_2]| + |OUT[B_2]| + |IN[B_3]| + |OUT[B_3]| + |IN[B_4]| + |OUT[B_4]|$\n$N = 1 + 0 + 1 + 1 + 1 + 1 + 1 + 0$\n$N = 6$\n\nThe final value of $N$ is 6.", "answer": "$$\\boxed{6}$$", "id": "3682393"}]}