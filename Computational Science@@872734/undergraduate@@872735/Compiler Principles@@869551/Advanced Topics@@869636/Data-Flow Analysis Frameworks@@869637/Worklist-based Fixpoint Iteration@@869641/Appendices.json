{"hands_on_practices": [{"introduction": "This first exercise puts the worklist algorithm to work on a classic compiler optimization: constant propagation. By tracing the algorithm on a Static Single Assignment (SSA) graph, you will gain a concrete understanding of how dataflow values propagate and stabilize on a lattice. Pay close attention to how the transfer functions for arithmetic and $\\phi$-nodes interact to drive the system towards a fixpoint [@problem_id:3683107].", "problem": "Consider forward constant propagation formulated as a monotone dataflow analysis over a three-level lattice for each Static Single Assignment (SSA) name. The lattice for each SSA value $V$ is $L = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$ with partial order $\\bot \\leq n \\leq \\top$ for any integer $n \\in \\mathbb{Z}$, and distinct integers are incomparable except through $\\top$. The join operator $\\sqcup$ satisfies: for any $x \\in L$, $x \\sqcup \\bot = x$; for any integers $m, n \\in \\mathbb{Z}$, $m \\sqcup n = m$ if $m = n$ and $m \\sqcup n = \\top$ if $m \\neq n$; and for any $x \\in L$, $x \\sqcup \\top = \\top$. Transfer functions are monotone with respect to this lattice and defined as follows:\n- For a constant definition $v := \\text{Const}(k)$ with $k \\in \\mathbb{Z}$, the transfer yields $k$.\n- For an addition $v := \\text{add}(u, w)$, the transfer yields $Val[u] + Val[w]$ if both $Val[u]$ and $Val[w]$ are integers; yields $\\bot$ if $Val[u] = \\bot$ or $Val[w] = \\bot$; and yields $\\top$ otherwise.\n- For a phi-node $v := \\phi(u, w)$, the transfer yields $Val[u] \\sqcup Val[w]$.\n\nA standard First-In, First-Out (FIFO) worklist algorithm is used. Initially, for every SSA name $v$, $Val[v] = \\bot$. The worklist is initialized with the SSA definitions in the exact order given below. When an SSA name $n$ is dequeued, its right-hand side is evaluated using the current $Val[\\cdot]$ to produce a candidate value $new$. If $new \\neq Val[n]$, then set $Val[n] := new$ and enqueue all users of $n$ to the back of the worklist (duplicates are allowed). Users are enqueued in the order listed in the Users mapping below. The algorithm terminates when the worklist is empty.\n\nThe SSA fragment and its def-use relations are:\n- Definitions (each defines a unique SSA name):\n  1. $c := \\text{Const}(4)$\n  2. $d := \\text{Const}(9)$\n  3. $e := \\text{add}(c, c)$\n  4. $y := \\phi(c, c)$\n  5. $b := \\phi(e, d)$\n  6. $a := \\phi(c, b)$\n  7. $x := \\phi(y, d)$\n  8. $f := \\text{add}(x, a)$\n- Users mapping (for each SSA name, the list of users to be enqueued upon its update, in this exact order):\n  - $c$: users $e, y, a$\n  - $d$: users $b, x$\n  - $e$: users $b$\n  - $y$: users $x$\n  - $b$: users $a$\n  - $a$: users $f$\n  - $x$: users $f$\n  - $f$: no users\n- Initial worklist order (front to back): $[x, a, b, y, e, f, c, d]$.\n\nStarting from $Val[\\cdot] = \\bot$ for all SSA names, run the FIFO worklist-based fixpoint iteration with the transfer functions above. Compute the total number of dequeues (worklist pop operations) executed until the algorithm reaches a fixpoint and the worklist becomes empty. Give your answer as a single integer with no units. No rounding is required.", "solution": "The problem is first validated against the required criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Lattice:** For each SSA name $v$, the lattice is $L = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$.\n- **Partial Order:** $\\bot \\leq n \\leq \\top$ for any integer $n \\in \\mathbb{Z}$. Distinct integers are incomparable.\n- **Join Operator ($\\sqcup$):**\n    - For any $x \\in L$, $x \\sqcup \\bot = x$.\n    - For any integers $m, n \\in \\mathbb{Z}$, $m \\sqcup n = m$ if $m=n$, and $m \\sqcup n = \\top$ if $m \\neq n$.\n    - For any $x \\in L$, $x \\sqcup \\top = \\top$.\n- **Transfer Functions:**\n    - For $v := \\text{Const}(k)$ with $k \\in \\mathbb{Z}$, the transfer function yields $k$.\n    - For $v := \\text{add}(u, w)$, the transfer function yields:\n        - $Val[u] + Val[w]$ if both $Val[u]$ and $Val[w]$ are integers.\n        - $\\bot$ if $Val[u] = \\bot$ or $Val[w] = \\bot$.\n        - $\\top$ otherwise.\n    - For $v := \\phi(u, w)$, the transfer function yields $Val[u] \\sqcup Val[w]$.\n- **Algorithm:** First-In, First-Out (FIFO) worklist algorithm.\n- **Initial State:**\n    - For every SSA name $v$, $Val[v] = \\bot$.\n    - The initial worklist is $[x, a, b, y, e, f, c, d]$, ordered from front to back.\n- **Update Rule:** When an SSA name $n$ is dequeued, its right-hand side is evaluated to get a value $new$. If $new \\neq Val[n]$, then $Val[n]$ is updated to $new$ and all users of $n$ are enqueued to the back of the worklist according to the specified order.\n- **SSA Definitions:**\n    1. $c := \\text{Const}(4)$\n    2. $d := \\text{Const}(9)$\n    3. $e := \\text{add}(c, c)$\n    4. $y := \\phi(c, c)$\n    5. $b := \\phi(e, d)$\n    6. $a := \\phi(c, b)$\n    7. $x := \\phi(y, d)$\n    8. $f := \\text{add}(x, a)$\n- **Users Mapping (Def-Use Chains):**\n    - $c$: users $e, y, a$\n    - $d$: users $b, x$\n    - $e$: users $b$\n    - $y$: users $x$\n    - $b$: users $a$\n    - $a$: users $f$\n    - $x$: users $f$\n    - $f$: no users\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded:** The problem is a standard exercise in dataflow analysis, a fundamental topic in compiler design and program analysis. The concepts of SSA, lattices, monotone frameworks, and worklist algorithms are well-established in computer science.\n- **Well-Posed:** The problem provides a deterministic algorithm, a complete set of initial conditions, and unambiguous rules for state transition. The lattice has a finite height ($3$ levels), and the values in the state can only move up the lattice. This guarantees that the algorithm will terminate and produce a unique result.\n- **Objective:** The problem is stated using formal and precise language. All definitions, rules, and data are given explicitly, leaving no room for subjective interpretation.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. A detailed solution will be provided by simulating the specified worklist algorithm.\n\n### Solution\n\nWe trace the execution of the FIFO worklist algorithm. Let $W$ be the worklist and $D$ be the dequeue count. The state is maintained in the map $Val[\\cdot]$. Initially, $Val[v] = \\bot$ for all SSA names $v \\in \\{a, b, c, d, e, f, x, y\\}$, $D=0$, and $W = [x, a, b, y, e, f, c, d]$.\n\n1.  Dequeue $x$. $D=1$. $x := \\phi(y, d)$. We evaluate $Val[y] \\sqcup Val[d] = \\bot \\sqcup \\bot = \\bot$. This equals the current $Val[x] = \\bot$. No update. $W = [a, b, y, e, f, c, d]$.\n2.  Dequeue $a$. $D=2$. $a := \\phi(c, b)$. We evaluate $Val[c] \\sqcup Val[b] = \\bot \\sqcup \\bot = \\bot$. This equals the current $Val[a] = \\bot$. No update. $W = [b, y, e, f, c, d]$.\n3.  Dequeue $b$. $D=3$. $b := \\phi(e, d)$. We evaluate $Val[e] \\sqcup Val[d] = \\bot \\sqcup \\bot = \\bot$. This equals the current $Val[b] = \\bot$. No update. $W = [y, e, f, c, d]$.\n4.  Dequeue $y$. $D=4$. $y := \\phi(c, c)$. We evaluate $Val[c] \\sqcup Val[c] = \\bot \\sqcup \\bot = \\bot$. This equals the current $Val[y] = \\bot$. No update. $W = [e, f, c, d]$.\n5.  Dequeue $e$. $D=5$. $e := \\text{add}(c, c)$. Since $Val[c]=\\bot$, the transfer function yields $\\bot$. This equals the current $Val[e] = \\bot$. No update. $W = [f, c, d]$.\n6.  Dequeue $f$. $D=6$. $f := \\text{add}(x, a)$. Since $Val[x]=\\bot$ (or $Val[a]=\\bot$), the transfer function yields $\\bot$. This equals the current $Val[f] = \\bot$. No update. $W = [c, d]$.\n7.  Dequeue $c$. $D=7$. $c := \\text{Const}(4)$. The new value is $4$. This is different from $Val[c] = \\bot$. Update $Val[c] := 4$. Enqueue users of $c$: $e, y, a$. $W = [d, e, y, a]$.\n8.  Dequeue $d$. $D=8$. $d := \\text{Const}(9)$. The new value is $9$. This is different from $Val[d] = \\bot$. Update $Val[d] := 9$. Enqueue users of $d$: $b, x$. $W = [e, y, a, b, x]$.\n9.  Dequeue $e$. $D=9$. $e := \\text{add}(c, c)$. We evaluate $Val[c] + Val[c] = 4 + 4 = 8$. This is different from $Val[e] = \\bot$. Update $Val[e] := 8$. Enqueue users of $e$: $b$. $W = [y, a, b, x, b]$.\n10. Dequeue $y$. $D=10$. $y := \\phi(c, c)$. We evaluate $Val[c] \\sqcup Val[c] = 4 \\sqcup 4 = 4$. This is different from $Val[y] = \\bot$. Update $Val[y] := 4$. Enqueue users of $y$: $x$. $W = [a, b, x, b, x]$.\n11. Dequeue $a$. $D=11$. $a := \\phi(c, b)$. We evaluate $Val[c] \\sqcup Val[b] = 4 \\sqcup \\bot = 4$. This is different from $Val[a] = \\bot$. Update $Val[a] := 4$. Enqueue users of $a$: $f$. $W = [b, x, b, x, f]$.\n12. Dequeue $b$. $D=12$. $b := \\phi(e, d)$. We evaluate $Val[e] \\sqcup Val[d] = 8 \\sqcup 9 = \\top$ (since $8 \\neq 9$). This is different from $Val[b] = \\bot$. Update $Val[b] := \\top$. Enqueue users of $b$: $a$. $W = [x, b, x, f, a]$.\n13. Dequeue $x$. $D=13$. $x := \\phi(y, d)$. We evaluate $Val[y] \\sqcup Val[d] = 4 \\sqcup 9 = \\top$ (since $4 \\neq 9$). This is different from $Val[x] = \\bot$. Update $Val[x] := \\top$. Enqueue users of $x$: $f$. $W = [b, x, f, a, f]$.\n14. Dequeue $b$. $D=14$. $b := \\phi(e, d)$. We evaluate $Val[e] \\sqcup Val[d] = 8 \\sqcup 9 = \\top$. This equals the current $Val[b] = \\top$. No update. $W = [x, f, a, f]$.\n15. Dequeue $x$. $D=15$. $x := \\phi(y, d)$. We evaluate $Val[y] \\sqcup Val[d] = 4 \\sqcup 9 = \\top$. This equals the current $Val[x] = \\top$. No update. $W = [f, a, f]$.\n16. Dequeue $f$. $D=16$. $f := \\text{add}(x, a)$. Current values are $Val[x]=\\top$ and $Val[a]=4$. Since $Val[x]$ is not an integer, the transfer function yields $\\top$. This is different from $Val[f] = \\bot$. Update $Val[f] := \\top$. There are no users of $f$ to enqueue. $W = [a, f]$.\n17. Dequeue $a$. $D=17$. $a := \\phi(c, b)$. We evaluate $Val[c] \\sqcup Val[b] = 4 \\sqcup \\top = \\top$. This is different from $Val[a] = 4$. Update $Val[a] := \\top$. Enqueue users of $a$: $f$. $W = [f, f]$.\n18. Dequeue $f$. $D=18$. $f := \\text{add}(x, a)$. Current values are $Val[x]=\\top$ and $Val[a]=\\top$. Since one or both inputs are not integers, the transfer function yields $\\top$. This equals the current $Val[f] = \\top$. No update. $W = [f]$.\n19. Dequeue $f$. $D=19$. $f := \\text{add}(x, a)$. Current values are $Val[x]=\\top$ and $Val[a]=\\top$. The transfer function yields $\\top$. This equals the current $Val[f] = \\top$. No update. $W = []$.\n\nThe worklist is now empty. The algorithm terminates. The total number of dequeues is $19$.\nThe final state is:\n$Val[a] = \\top$\n$Val[b] = \\top$\n$Val[c] = 4$\n$Val[d] = 9$\n$Val[e] = 8$\n$Val[f] = \\top$\n$Val[x] = \\top$\n$Val[y] = 4$\n\nThe question asks for the total number of dequeues performed. Based on the trace, this number is $19$.", "answer": "$$\n\\boxed{19}\n$$", "id": "3683107"}, {"introduction": "The worklist algorithm's power extends beyond traditional dataflow analysis, as it provides a general method for computing reachability on a graph. This practice reframes the computation of $\\epsilon$-closure in a Non-deterministic Finite Automaton (NFA)—a core task in lexical analysis—as a fixpoint iteration problem. This exercise [@problem_id:3683091] will help you see the underlying unity between different problems that can be solved with this versatile algorithm.", "problem": "A compiler front end models a lexical recognizer as a non-deterministic finite automaton (NFA) embedded in the compiler’s Intermediate Representation (IR). The IR nodes are basic blocks that correspond to NFA states. Among the control-flow edges, some are special $\\epsilon$-transitions that do not consume input. The $\\epsilon$-closure of a set of states is defined as the least set of states that contains the set and is closed under reachability by zero or more $\\epsilon$-transitions. You will compute the size of an $\\epsilon$-closure by viewing the problem as a monotone dataflow analysis on a finite lattice and using a worklist-based fixpoint iteration.\n\nLet the set of states be $Q=\\{q_0,q_1,q_2,q_3,q_4,q_5,q_6,q_7,q_8,q_9,q_{10},q_{11}\\}$. The $\\epsilon$-transitions (and only these transitions) are:\n- $q_0 \\to q_1$, $q_0 \\to q_2$.\n- $q_1 \\to q_3$.\n- $q_2 \\to q_3$, $q_2 \\to q_4$.\n- $q_3 \\to q_5$.\n- $q_4 \\to q_2$, $q_4 \\to q_6$.\n- $q_5 \\to q_7$.\n- $q_6 \\to q_7$.\n- $q_7 \\to q_8$, $q_7 \\to q_9$.\n- $q_8 \\to q_{10}$.\n- $q_9 \\to q_{10}$, $q_9 \\to q_{11}$.\n- $q_{10}$ has no outgoing $\\epsilon$-transitions.\n- $q_{11} \\to q_6$.\n\nIn addition, there exist several non-$\\epsilon$ symbol-labeled transitions (for example, $q_1 \\xrightarrow{a} q_2$, $q_2 \\xrightarrow{b} q_9$, $q_6 \\xrightarrow{c} q_3$, $q_7 \\xrightarrow{d} q_0$, $q_{10} \\xrightarrow{e} q_4$), but these do not participate in the $\\epsilon$-closure and must be ignored for the computation below.\n\nDefine the initial set of states as $S_0=\\{q_0,q_4,q_9\\}$. Consider the powerset lattice $\\langle 2^{Q}, \\subseteq \\rangle$ with set union as the least upper bound. Model $\\epsilon$-closure computation as the least fixpoint of a monotone function over this lattice, and implement the computation conceptually via a worklist: begin with the worklist containing exactly the elements of $S_0$, maintain a visited set initialized to $S_0$, repeatedly pop a state from the worklist, and for each outgoing $\\epsilon$-successor not yet in the visited set, add it to the visited set and push it onto the worklist; terminate when the worklist becomes empty. The visited set at termination is the $\\epsilon$-closure of $S_0$.\n\nUsing this formulation and only the $\\epsilon$-transitions listed above, what is the exact cardinality of the $\\epsilon$-closure of $S_0$? Express your final answer as an integer. No rounding is required or permitted, and no physical units are involved.", "solution": "The problem asks for the cardinality of the $\\epsilon$-closure of an initial set of states $S_0$ within a given non-deterministic finite automaton (NFA). The computation is to be performed using a worklist-based fixpoint iteration algorithm, as described.\n\nFirst, we establish the formal components of the problem.\nThe set of all states is $Q=\\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_8, q_9, q_{10}, q_{11}\\}$. The total number of states is $|Q| = 12$.\nThe initial set of states for which the closure is to be computed is $S_0 = \\{q_0, q_4, q_9\\}$.\nThe $\\epsilon$-transitions define a directed graph $G=(Q, E)$, where an edge $(u, v) \\in E$ exists if there is an $\\epsilon$-transition from state $u$ to state $v$. The set of edges $E$ is given by:\n$E = \\{$\n$(q_0, q_1), (q_0, q_2),$\n$(q_1, q_3),$\n$(q_2, q_3), (q_2, q_4),$\n$(q_3, q_5),$\n$(q_4, q_2), (q_4, q_6),$\n$(q_5, q_7),$\n$(q_6, q_7),$\n$(q_7, q_8), (q_7, q_9),$\n$(q_8, q_{10}),$\n$(q_9, q_{10}), (q_9, q_{11}),$\n$(q_{11}, q_6)$\n$\\}$\nThe non-$\\epsilon$ transitions are explicitly stated to be ignored for this computation.\n\nThe $\\epsilon$-closure of $S_0$, denoted $\\epsilon\\text{-closure}(S_0)$, is the set of all states reachable from any state in $S_0$ by following zero or more $\\epsilon$-transitions. The problem specifies a worklist algorithm to compute this set. Let $V$ be the set of visited states (which will become the closure set) and $W$ be the worklist.\n\nThe algorithm proceeds as follows:\n1. Initialize the visited set $V$ and the worklist $W$ with the initial set of states $S_0$.\n2. While the worklist $W$ is not empty:\n   a. Remove a state $u$ from $W$.\n   b. For each state $v$ such that there is an $\\epsilon$-transition from $u$ to $v$:\n      i. If $v$ is not in $V$:\n         - Add $v$ to $V$.\n         - Add $v$ to $W$.\n3. The final set $V$ is the $\\epsilon$-closure of $S_0$.\n\nWe now trace the execution of this algorithm. The order of processing elements from the worklist does not affect the final result, only the sequence of intermediate steps. We will treat the worklist as a queue (First-In, First-Out) for a systematic traversal.\n\n**Initialization:**\n- Visited set: $V = \\{q_0, q_4, q_9\\}$\n- Worklist: $W = [q_0, q_4, q_9]$\n\n**Iteration 1:** Pop $q_0$ from $W$.\n- Successors of $q_0$ are $q_1$ and $q_2$.\n- $q_1 \\notin V$. Add $q_1$ to $V$ and $W$.\n- $q_2 \\notin V$. Add $q_2$ to $V$ and $W$.\n- $V = \\{q_0, q_1, q_2, q_4, q_9\\}$\n- $W = [q_4, q_9, q_1, q_2]$\n\n**Iteration 2:** Pop $q_4$ from $W$.\n- Successors of $q_4$ are $q_2$ and $q_6$.\n- $q_2 \\in V$. No action.\n- $q_6 \\notin V$. Add $q_6$ to $V$ and $W$.\n- $V = \\{q_0, q_1, q_2, q_4, q_6, q_9\\}$\n- $W = [q_9, q_1, q_2, q_6]$\n\n**Iteration 3:** Pop $q_9$ from $W$.\n- Successors of $q_9$ are $q_{10}$ and $q_{11}$.\n- $q_{10} \\notin V$. Add $q_{10}$ to $V$ and $W$.\n- $q_{11} \\notin V$. Add $q_{11}$ to $V$ and $W$.\n- $V = \\{q_0, q_1, q_2, q_4, q_6, q_9, q_{10}, q_{11}\\}$\n- $W = [q_1, q_2, q_6, q_{10}, q_{11}]$\n\n**Iteration 4:** Pop $q_1$ from $W$.\n- Successor of $q_1$ is $q_3$.\n- $q_3 \\notin V$. Add $q_3$ to $V$ and $W$.\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_6, q_9, q_{10}, q_{11}\\}$\n- $W = [q_2, q_6, q_{10}, q_{11}, q_3]$\n\n**Iteration 5:** Pop $q_2$ from $W$.\n- Successors of $q_2$ are $q_3$ and $q_4$.\n- $q_3 \\in V$. No action.\n- $q_4 \\in V$. No action.\n- $W = [q_6, q_{10}, q_{11}, q_3]$\n\n**Iteration 6:** Pop $q_6$ from $W$.\n- Successor of $q_6$ is $q_7$.\n- $q_7 \\notin V$. Add $q_7$ to $V$ and $W$.\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_6, q_7, q_9, q_{10}, q_{11}\\}$\n- $W = [q_{10}, q_{11}, q_3, q_7]$\n\n**Iteration 7:** Pop $q_{10}$ from $W$.\n- $q_{10}$ has no outgoing $\\epsilon$-transitions.\n- $W = [q_{11}, q_3, q_7]$\n\n**Iteration 8:** Pop $q_{11}$ from $W$.\n- Successor of $q_{11}$ is $q_6$.\n- $q_6 \\in V$. No action.\n- $W = [q_3, q_7]$\n\n**Iteration 9:** Pop $q_3$ from $W$.\n- Successor of $q_3$ is $q_5$.\n- $q_5 \\notin V$. Add $q_5$ to $V$ and $W$.\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_9, q_{10}, q_{11}\\}$\n- $W = [q_7, q_5]$\n\n**Iteration 10:** Pop $q_7$ from $W$.\n- Successors of $q_7$ are $q_8$ and $q_9$.\n- $q_8 \\notin V$. Add $q_8$ to $V$ and $W$.\n- $q_9 \\in V$. No action.\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_8, q_9, q_{10}, q_{11}\\}$\n- $W = [q_5, q_8]$\n\nAt this point, the visited set $V$ contains all $12$ states from $q_0$ to $q_{11}$. The algorithm continues until the worklist is empty, but no new states can be added to $V$.\n\n**Iteration 11:** Pop $q_5$ from $W$.\n- Successor of $q_5$ is $q_7$.\n- $q_7 \\in V$. No action.\n- $W = [q_8]$\n\n**Iteration 12:** Pop $q_8$ from $W$.\n- Successor of $q_8$ is $q_{10}$.\n- $q_{10} \\in V$. No action.\n- $W = []$\n\n**Termination:**\nThe worklist $W$ is now empty. The algorithm terminates. The final visited set is the $\\epsilon$-closure of $S_0$.\n$\\epsilon\\text{-closure}(S_0) = V_{final} = \\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_8, q_9, q_{10}, q_{11}\\}$.\nThis is the complete set of states $Q$.\n\nThe problem asks for the cardinality of this set.\n$|\\epsilon\\text{-closure}(S_0)| = |Q| = 12$.\n\nAlternatively, we can reason about reachability more directly. The $\\epsilon$-closure of $S_0$ is the union of the closures of its individual elements: $\\epsilon\\text{-closure}(S_0) = \\bigcup_{s \\in S_0} \\epsilon\\text{-closure}(\\{s\\})$. We only need to find one element in $S_0$ from which all states are reachable.\nLet's analyze reachability from $q_0 \\in S_0$:\n- $q_0 \\to \\{q_1, q_2\\}$\n- from $\\{q_1, q_2\\} \\to \\{q_3, q_4\\}$\n- from $\\{q_3, q_4\\} \\to \\{q_5, q_2, q_6\\}$\n- from $\\{q_5, q_6\\} \\to \\{q_7\\}$\n- from $\\{q_7\\} \\to \\{q_8, q_9\\}$\n- from $\\{q_8, q_9\\} \\to \\{q_{10}, q_{11}\\}$\n- from $\\{q_{11}\\} \\to \\{q_6\\}$\nThrough these paths, it is evident that all states $q_1, \\dots, q_{11}$ are reachable from $q_0$. Since the closure of $\\{q_0\\}$ by definition includes $q_0$ itself, $\\epsilon\\text{-closure}(\\{q_0\\}) = Q$.\nBecause $\\epsilon\\text{-closure}(S_0) = \\epsilon\\text{-closure}(\\{q_0\\}) \\cup \\epsilon\\text{-closure}(\\{q_4\\}) \\cup \\epsilon\\text{-closure}(\\{q_9\\})$, and $\\epsilon\\text{-closure}(\\{q_0\\}) = Q$, the resulting union must also be $Q$.\nThus, the cardinality of the $\\epsilon$-closure of $S_0$ is the cardinality of $Q$, which is $12$.", "answer": "$$\n\\boxed{12}\n$$", "id": "3683091"}, {"introduction": "To build a precise Control Flow Graph (CFG) for programs with indirect calls, a compiler must first determine the possible targets of function pointers. This practice dives into this essential prerequisite, using a flow-insensitive points-to analysis to compute these targets. You will see how a fixpoint iteration over a powerset lattice can resolve pointer targets, directly enabling the construction of a more accurate CFG [@problem_id:3683055].", "problem": "Consider a static construction of a Control Flow Graph (CFG) for a program with indirect calls through function pointers. To ensure soundness before any analysis, dynamic edges from each indirect call site to all functions in a known universe are first materialized as top edges. These edges are then refined by a worklist-based fixpoint iteration over a points-to lattice.\n\nLet the universe of possible function targets be the finite set $U = \\{ f_{1}, f_{2}, f_{3}, f_{4}, f_{5}, f_{6} \\}$. The program uses three pointer variables $p$, $q$, and $r$, with the following whole-program, flow-insensitive constraints (i.e., assignments may occur along any control-flow path and all are accumulated):\n- $p := \\ f_{1}$\n- $q := \\ f_{2}$\n- $r := \\ f_{3}$\n- $q := r$\n- $p := q$\n\nThere are exactly two indirect call sites:\n- $c_{p}$: an indirect call through $p$ (denoted $(*p)()$).\n- $c_{q}$: an indirect call through $q$ (denoted $(*q)()$).\n\nModel the points-to information using the powerset lattice $\\mathcal{P}(U)$ ordered by $\\subseteq$, with bottom $\\varnothing$ and top $U$. Each assignment induces a monotone transfer over this lattice:\n- For $v := \\ f_{i}$, the constraint is $\\mathrm{PTS}(v) \\supseteq \\{ f_{i} \\}$.\n- For $v := w$, the constraint is $\\mathrm{PTS}(v) \\supseteq \\mathrm{PTS}(w)$.\n\nThe worklist algorithm initializes all $\\mathrm{PTS}(v)$ to $\\varnothing$ and iteratively applies these monotone transfers until a fixpoint is reached. Independently, each indirect call site begins with top edges to all targets in $U$ and then discards edges to any $f \\in U$ not in the converged $\\mathrm{PTS}$ set at that call site.\n\nStarting from these definitions and facts:\n- The Tarski fixpoint theorem for monotone functions on complete lattices.\n- The standard worklist algorithm for data-flow analysis on finite lattices.\n- The semantics of the transfer functions given above.\n\nDerive the converged points-to sets $\\mathrm{PTS}(p)$ and $\\mathrm{PTS}(q)$ and then compute the total number of precise indirect call edges present in the refined Control Flow Graph after convergence. Count edges per call site, i.e., if a function $f$ is a target of both $c_{p}$ and $c_{q}$, it contributes $2$ edges to the total.\n\nExpress the final answer as a single integer with no units. No rounding is required.", "solution": "The problem requires us to determine the total number of control-flow edges from two indirect call sites after a flow-insensitive points-to analysis has converged. The analysis is performed using a worklist-based fixpoint iteration over a powerset lattice.\n\nFirst, we formalize the problem. The universe of functions is the set $U = \\{ f_{1}, f_{2}, f_{3}, f_{4}, f_{5}, f_{6} \\}$. The analysis operates on the complete lattice $(\\mathcal{P}(U), \\subseteq)$, where $\\mathcal{P}(U)$ is the powerset of $U$ and $\\subseteq$ is the subset inclusion operator. The bottom element of this lattice is the empty set $\\varnothing$, and the top element is the set $U$. The variables for which points-to information is tracked are $p$, $q$, and $r$. Their points-to sets are denoted $\\mathrm{PTS}(p)$, $\\mathrm{PTS}(q)$, and $\\mathrm{PTS}(r)$, respectively.\n\nThe program's constraints, being flow-insensitive, can be modeled as a system of set-inclusion equations that must hold at the fixpoint. The transfer functions given in the problem statement translate the program's assignment statements into these constraints:\n1.  From $p := \\ f_{1}$, we derive the constraint: $\\mathrm{PTS}(p) \\supseteq \\{ f_{1} \\}$.\n2.  From $q := \\ f_{2}$, we derive the constraint: $\\mathrm{PTS}(q) \\supseteq \\{ f_{2} \\}$.\n3.  From $r := \\ f_{3}$, we derive the constraint: $\\mathrm{PTS}(r) \\supseteq \\{ f_{3} \\}$.\n4.  From $q := r$, we derive the constraint: $\\mathrm{PTS}(q) \\supseteq \\mathrm{PTS}(r)$.\n5.  From $p := q$, we derive the constraint: $\\mathrm{PTS}(p) \\supseteq \\mathrm{PTS}(q)$.\n\nThe worklist algorithm starts with the minimal solution, where all points-to sets are initialized to the bottom element of the lattice, $\\varnothing$:\n$\\mathrm{PTS}(p) = \\varnothing$\n$\\mathrm{PTS}(q) = \\varnothing$\n$\\mathrm{PTS}(r) = \\varnothing$\n\nThe algorithm then iteratively applies the constraints, which correspond to monotone functions over the lattice, until no points-to set can be further enlarged. This process is guaranteed to terminate and find the least fixpoint because the lattice is finite and the functions are monotone. Let's trace the iterative computation of the least solution satisfying all five constraints.\n\nWe can solve this system by iteratively propagating information until a stable state (the fixpoint) is reached.\n\nInitially:\n$\\mathrm{PTS}(p) = \\varnothing$\n$\\mathrm{PTS}(q) = \\varnothing$\n$\\mathrm{PTS}(r) = \\varnothing$\n\nApply the 'address-of' constraints ($1, 2, 3$), which form the base of the analysis:\n$\\mathrm{PTS}(p) = \\{ f_{1} \\}$\n$\\mathrm{PTS}(q) = \\{ f_{2} \\}$\n$\\mathrm{PTS}(r) = \\{ f_{3} \\}$\n\nNow, we propagate these sets according to the copy constraints ($4, 5$).\nApply constraint $4$: $\\mathrm{PTS}(q) \\supseteq \\mathrm{PTS}(r)$.\nThe current $\\mathrm{PTS}(q)$ must be updated to include elements from the current $\\mathrm{PTS}(r)$.\nNew $\\mathrm{PTS}(q) = \\mathrm{PTS}(q) \\cup \\mathrm{PTS}(r) = \\{ f_{2} \\} \\cup \\{ f_{3} \\} = \\{ f_{2}, f_{3} \\}$.\nThe sets are now:\n$\\mathrm{PTS}(p) = \\{ f_{1} \\}$\n$\\mathrm{PTS}(q) = \\{ f_{2}, f_{3} \\}$\n$\\mathrm{PTS}(r) = \\{ f_{3} \\}$\n\nApply constraint $5$: $\\mathrm{PTS}(p) \\supseteq \\mathrm{PTS}(q)$.\nThe current $\\mathrm{PTS}(p)$ must be updated to include elements from the current $\\mathrm{PTS}(q)$.\nNew $\\mathrm{PTS}(p) = \\mathrm{PTS}(p) \\cup \\mathrm{PTS}(q) = \\{ f_{1} \\} \\cup \\{ f_{2}, f_{3} \\} = \\{ f_{1}, f_{2}, f_{3} \\}$.\nThe sets are now:\n$\\mathrm{PTS}(p) = \\{ f_{1}, f_{2}, f_{3} \\}$\n$\\mathrm{PTS}(q) = \\{ f_{2}, f_{3} \\}$\n$\\mathrm{PTS}(r) = \\{ f_{3} \\}$\n\nAt this point, we must check if further iterations will change any set.\n- Constraint $1$: $\\mathrm{PTS}(p) = \\{ f_{1}, f_{2}, f_{3} \\} \\supseteq \\{ f_{1} \\}$. (Satisfied)\n- Constraint $2$: $\\mathrm{PTS}(q) = \\{ f_{2}, f_{3} \\} \\supseteq \\{ f_{2} \\}$. (Satisfied)\n- Constraint $3$: $\\mathrm{PTS}(r) = \\{ f_{3} \\} \\supseteq \\{ f_{3} \\}$. (Satisfied)\n- Constraint $4$: $\\mathrm{PTS}(q) \\supseteq \\mathrm{PTS}(r) \\implies \\{ f_{2}, f_{3} \\} \\supseteq \\{ f_{3} \\}$. (Satisfied)\n- Constraint $5$: $\\mathrm{PTS}(p) \\supseteq \\mathrm{PTS}(q) \\implies \\{ f_{1}, f_{2}, f_{3} \\} \\supseteq \\{ f_{2}, f_{3} \\}$. (Satisfied)\n\nSince all constraints are satisfied and no set can be made smaller while satisfying the 'address-of' constraints, these are the smallest sets satisfying the system. Thus, we have reached the least fixpoint. The converged points-to sets are:\n- $\\mathrm{PTS}(p) = \\{ f_{1}, f_{2}, f_{3} \\}$\n- $\\mathrm{PTS}(q) = \\{ f_{2}, f_{3} \\}$\n\nThe second part of the problem is to compute the number of edges in the refined Control Flow Graph (CFG). The refinement rule states that for an indirect call site via a pointer $v$, the final set of call edges consists of one edge to each function $f$ in the converged set $\\mathrm{PTS}(v)$.\n\nThe program contains two indirect call sites:\n1.  $c_{p}$: an indirect call through pointer $p$. The targets of this call are the functions in $\\mathrm{PTS}(p)$. The number of edges from this site is $|\\mathrm{PTS}(p)|$.\n2.  $c_{q}$: an indirect call through pointer $q$. The targets of this call are the functions in $\\mathrm{PTS}(q)$. The number of edges from this site is $|\\mathrm{PTS}(q)|$.\n\nUsing the converged sets we derived:\n- Number of edges from $c_{p} = |\\mathrm{PTS}(p)| = |\\{ f_{1}, f_{2}, f_{3} \\}| = 3$.\n- Number of edges from $c_{q} = |\\mathrm{PTS}(q)| = |\\{ f_{2}, f_{3} \\}| = 2$.\n\nThe total number of precise indirect call edges is the sum of the edges from each call site.\nTotal edges = $|\\mathrm{PTS}(p)| + |\\mathrm{PTS}(q)| = 3 + 2 = 5$.", "answer": "$$\\boxed{5}$$", "id": "3683055"}]}