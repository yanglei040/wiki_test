{"hands_on_practices": [{"introduction": "One of the primary motivations for studying dominator trees is their application in constructing the Static Single Assignment (SSA) form, a cornerstone of modern optimizing compilers. This first practice focuses on the crucial case of variables defined within a loop. You will see firsthand how the dominance frontier of a loop's header node precisely identifies where to place a $\\phi$-function to merge values from different loop iterations, a concept central to handling loop-carried dependencies [@problem_id:3638820].", "problem": "Consider the following Control-Flow Graph (CFG) with basic blocks labeled $S$, $H$, $B$, $B_1$, $B_2$, $B_3$, $J$, and $T$. The directed edges are: $S \\to H$, $H \\to B$, $H \\to T$, $B \\to B_1$, $B \\to B_2$, $B_1 \\to J$, $B_2 \\to B_3$, $B_3 \\to J$, and $J \\to H$. The block $H$ is the loop header, and the backedge is $J \\to H$. Assume that a scalar variable $x$ is defined initially in $S$, updated in exactly two distinct loop-body blocks $B_1$ and $B_3$, and used at $J$ (before taking the backedge), at $H$ in the loop continuation test, and at $T$ after loop exit. The Static Single Assignment (SSA) form is to be constructed using the iterated dominance frontier method, and assume pruned SSA placement with liveness as specified by the aforementioned uses.\n\nTasks:\n- Compute the dominance sets and the immediate dominator tree rooted at $S$ for the given CFG.\n- From first principles, compute the dominance frontier of the loop header $H$ and justify each element of the set.\n- Using only the definitions of dominance, immediate dominator, and dominance frontier, determine the minimal SSA $\\phi$-function placement for $x$ via the iterated dominance frontier of its definition sites. Explain, in particular, how the dominance frontier of $H$ guides $\\phi$-function placement for loop-carried values.\n- Finally, report the total number of distinct basic blocks that must contain a $\\phi$-function for $x$ after minimal SSA placement using iterated dominance frontiers, under the given liveness assumptions.\n\nYour final answer must be a single integer equal to the number of distinct basic blocks containing a $\\phi$-function for $x$. Do not include any units. No rounding is required.", "solution": "The problem statement is valid. It is a well-posed problem in compiler theory, grounded in the established principles of Control-Flow Graphs (CFGs), dominator analysis, and Static Single Assignment (SSA) form construction. The givens are self-contained and consistent, allowing for a unique solution.\n\nThe problem describes a CFG with a set of basic blocks $V = \\{S, H, B, B_1, B_2, B_3, J, T\\}$. The entry block is $S$. The set of directed edges is $E = \\{(S, H), (H, B), (H, T), (B, B_1), (B, B_2), (B_1, J), (B_2, B_3), (B_3, J), (J, H)\\}$. A variable $x$ is defined in blocks $\\{S, B_1, B_3\\}$ and used in blocks $\\{H, J, T\\}$.\n\n**1. Dominance Sets and Immediate Dominator Tree**\n\nA node $N$ dominates a node $M$ if every path from the entry node $S$ to $M$ includes $N$. A node $N$ strictly dominates $M$ if $N$ dominates $M$ and $N \\neq M$. The immediate dominator of $M$, denoted $idom(M)$, is the strict dominator of $M$ that is closest to $M$ on any path from the entry.\n\nBy analyzing all paths from the entry node $S$ to every other node, we compute the dominance sets $Dom(N)$ for each node $N \\in V$:\n- $Dom(S) = \\{S\\}$\n- $Dom(H) = \\{S, H\\}$. Any path to $H$ must either be $S \\to H$ or pass through $H$ itself via the loop.\n- $Dom(B) = \\{S, H, B\\}$. Any path to $B$ is of the form $S \\to \\dots \\to H \\to B$.\n- $Dom(T) = \\{S, H, T\\}$. Any path to $T$ is of the form $S \\to \\dots \\to H \\to T$.\n- $Dom(B_1) = \\{S, H, B, B_1\\}$. Any path to $B_1$ is of the form $S \\to \\dots \\to H \\to B \\to B_1$.\n- $Dom(B_2) = \\{S, H, B, B_2\\}$. Any path to $B_2$ is of the form $S \\to \\dots \\to H \\to B \\to B_2$.\n- $Dom(B_3) = \\{S, H, B, B_2, B_3\\}$. Any path to $B_3$ is of the form $S \\to \\dots \\to H \\to B \\to B_2 \\to B_3$.\n- $Dom(J) = \\{S, H, B, J\\}$. Paths to $J$ are $S \\to \\dots \\to B_1 \\to J$ and $S \\to \\dots \\to B_3 \\to J$. The common dominators of $B_1$ and $B_3$ are $\\{S, H, B\\}$, so these must be on any path to $J$.\n\nFrom the dominance sets, we determine the immediate dominator $idom(N)$ for each node $N \\neq S$:\n- $idom(H) = S$\n- $idom(B) = H$\n- $idom(T) = H$\n- $idom(B_1) = B$\n- $idom(B_2) = B$\n- $idom(B_3) = B_2$\n- $idom(J) = B$. The predecessors of $J$ are $B_1$ and $B_3$. The lowest common ancestor of $B_1$ and $B_3$ in the dominator tree is $B$.\n\nThe resulting immediate dominator tree, rooted at $S$, is:\n$S$ is the parent of $H$.\n$H$ is the parent of $B$ and $T$.\n$B$ is the parent of $B_1$, $B_2$, and $J$.\n$B_2$ is the parent of $B_3$.\n\n**2. Dominance Frontier of the Loop Header $H$**\n\nThe dominance frontier of a node $N$, denoted $DF(N)$, is the set of all nodes $Y$ such that $N$ dominates an immediate predecessor of $Y$ in the CFG, but $N$ does not strictly dominate $Y$. Formally:\n$$DF(N) = \\{ Y \\in V \\mid (\\exists P \\in pred_{CFG}(Y) \\text{ s.t. } N \\in Dom(P)) \\land (N \\notin Dom(Y) \\setminus \\{Y\\}) \\}$$\nWe compute $DF(H)$ from this first principle. We must find nodes $Y$ such that $H$ dominates a predecessor $P$ of $Y$, but $H$ does not strictly dominate $Y$. The set of nodes not strictly dominated by $H$ is $\\{S, H\\}$. We only need to check these $2$ nodes as potential candidates for $Y$.\n- **Candidate $Y=S$**: The node $S$ has no predecessors in the given CFG. The condition $(\\exists P \\in pred_{CFG}(S))$ is false. Thus, $S \\notin DF(H)$.\n- **Candidate $Y=H$**: The predecessors of $H$ are $S$ and $J$.\n    - Consider the predecessor $P=S$: $H$ does not dominate $S$ (in fact, $S$ dominates $H$), so this predecessor does not satisfy the condition.\n    - Consider the predecessor $P=J$: $H$ dominates $J$, since $Dom(J) = \\{S, H, B, J\\}$. The first part of the condition is met. Now we check the second part: does $H$ not strictly dominate $H$? Yes, $H$ dominates itself, but not strictly. The second part of the condition is also met.\nTherefore, $H \\in DF(H)$.\n\nSince no other nodes can be in the dominance frontier of $H$, we conclude that $DF(H) = \\{H\\}$. This result is characteristic of loop headers; they are merge points for control flow from outside the loop and from the loop's backedge.\n\n**3. Minimal SSA $\\phi$-function Placement**\n\nThe minimal set of $\\phi$-functions for a variable $x$ is placed at the iterated dominance frontier, $IDF(Defs(x))$, of the set of blocks containing definitions of $x$. The initial definition sites are $Defs(x) = \\{S, B_1, B_3\\}$. The $IDF$ is computed using a worklist algorithm.\n\nFirst, we need the dominance frontiers of the definition sites and any sites where we subsequently place $\\phi$-functions.\n- $DF(S) = \\emptyset$, as $S$ has no predecessors and its only successor, $H$, is strictly dominated by $S$.\n- $DF(B_1) = \\{J\\}$. $B_1$ has one successor, $J$. A predecessor of $J$ is $B_1$, which is dominated by $B_1$. However, $B_1$ does not strictly dominate $J$ (in fact, $B$ does). Thus, $J \\in DF(B_1)$.\n- $DF(B_3) = \\{J\\}$. A predecessor of $J$ is $B_3$, which is dominated by $B_3$. However, $B_3$ does not strictly dominate $J$. Thus, $J \\in DF(B_3)$.\n- $DF(J) = \\{H\\}$. A predecessor of $H$ is $J$, which is dominated by $J$. However, $J$ does not strictly dominate $H$. Thus, $H \\in DF(J)$.\n- $DF(H) = \\{H\\}$, as computed previously.\n\nThe worklist algorithm proceeds as follows:\n- Initialize worklist $W = \\{S, B_1, B_3\\}$. Initialize the set of nodes with $\\phi$-functions, $\\Phi = \\emptyset$.\n- **Step 1**: Pop $S$ from $W$. Compute $DF(S) = \\emptyset$. No new $\\phi$-functions are added. $W = \\{B_1, B_3\\}$.\n- **Step 2**: Pop $B_1$ from $W$. Compute $DF(B_1) = \\{J\\}$. Since $J \\notin \\Phi$, add a $\\phi$-function to $J$. Update $\\Phi = \\{J\\}$ and add $J$ to the worklist: $W = \\{B_3, J\\}$.\n- **Step 3**: Pop $B_3$ from $W$. Compute $DF(B_3) = \\{J\\}$. Since $J \\in \\Phi$, do nothing. $W = \\{J\\}$.\n- **Step 4**: Pop $J$ from $W$. Compute $DF(J) = \\{H\\}$. Since $H \\notin \\Phi$, add a $\\phi$-function to $H$. Update $\\Phi = \\{J, H\\}$ and add $H$ to the worklist: $W = \\{H\\}$.\n- **Step 5**: Pop $H$ from $W$. Compute $DF(H) = \\{H\\}$. Since $H \\in \\Phi$, do nothing. $W = \\emptyset$.\n\nThe worklist is now empty. The algorithm terminates. The set of blocks requiring $\\phi$-functions is $\\Phi = \\{J, H\\}$.\n\nThe problem specifies *pruned* SSA placement, which means a $\\phi$-function is placed at a node $Y$ only if the variable $x$ is live at the entry of $Y$.\n- A $\\phi$-function is placed at $J$. The problem states $x$ is used at $J$. Therefore, $x$ is live on entry to $J$, and this $\\phi$-function is necessary.\n- A $\\phi$-function is placed at $H$. The problem states $x$ is used at $H$ for the loop test. Therefore, $x$ is live on entry to $H$, and this $\\phi$-function is necessary.\nThe liveness analysis confirms that both $\\phi$-functions are required.\n\nThe placement of a $\\phi$-function at the loop header $H$ is crucial for handling loop-carried values. A value of $x$ is considered loop-carried if it is defined in one iteration and used in a subsequent one. In this case, definitions of $x$ occur in the loop body ($B_1$, $B_3$). These definitions reach the end of the iteration at block $J$. The backedge $J \\to H$ carries this value to the start of the next iteration. The loop header $H$ is a merge point for two different sets of reaching definitions of $x$: the initial value from $S$ (on the first entry) and the value from the previous iteration from $J$. The dominance frontier formalism correctly identifies $H$ as this merge point. The iterated algorithm first finds the join point $J$ for the two paths inside the loop body ($DF(B_1) \\cup DF(B_3) = \\{J\\}$). Then, treating $J$ as a new definition site, the algorithm finds the join point for the loop itself ($DF(J)=\\{H\\}$). The $\\phi$-function at $H$ thus correctly merges the initial value of $x$ with the loop-carried value of $x$.\n\n**4. Final Count**\n\nThe set of distinct basic blocks that must contain a $\\phi$-function for $x$ is $\\{J, H\\}$. The total number of such blocks is $2$.", "answer": "$$\n\\boxed{2}\n$$", "id": "3638820"}, {"introduction": "While the previous exercise focused on a single loop, variables are often defined in multiple, disjoint locations throughout a program. To correctly place $\\phi$-functions in the general case, we must find all control flow merge points that are reached by these disparate definitions. This practice challenges you to apply the iterated dominance frontier algorithm, denoted $DF^{+}$, on a more complex control-flow graph, providing a robust, hands-on test of your ability to systematically identify the complete and minimal set of required $\\phi$-functions [@problem_id:3638854].", "problem": "Consider a Control Flow Graph (CFG) with a single entry block $B_{0}$ and the following basic blocks and directed edges. Blocks are denoted by $B_{i}$, and an edge $B_{i} \\to B_{j}$ indicates possible flow of control from $B_{i}$ to $B_{j}$.\n\nThe CFG is:\n- $B_{0} \\to B_{1}$\n- $B_{1} \\to B_{2}$ and $B_{1} \\to B_{3}$\n- $B_{2} \\to B_{4}$\n- $B_{3} \\to B_{5}$ and $B_{3} \\to B_{6}$\n- $B_{5} \\to B_{4}$\n- $B_{6} \\to B_{7}$ and $B_{6} \\to B_{8}$\n- $B_{7} \\to B_{6}$ (loop backedge)\n- $B_{8} \\to B_{4}$\n- $B_{4} \\to B_{9}$ and $B_{4} \\to B_{10}$\n- $B_{9} \\to B_{11}$\n- $B_{10} \\to B_{11}$\n- $B_{11} \\to B_{12}$\n- $B_{12} \\to B_{13}$ and $B_{12} \\to B_{14}$\n- $B_{13} \\to B_{12}$ (loop backedge)\n- $B_{14} \\to B_{15}$\n\nAssume a single program variable $x$ is defined (assigned) in exactly the following disjoint blocks:\n- $B_{2}$, $B_{5}$, $B_{7}$, $B_{9}$, and $B_{13}$.\n\nYou are to determine the minimal set of $\\phi$-function insertion points for $x$ under the Static Single Assignment (SSA) construction that uses the iterated dominance frontier. Use only the following foundational definitions:\n\n- Dominance: A node $d$ dominates a node $n$ if every path from the entry node $B_{0}$ to $n$ includes $d$. We write that $d$ strictly dominates $n$ if $d$ dominates $n$ and $d \\neq n$.\n- Dominator tree: The tree formed by assigning to each node (except the entry) its immediate dominator, defined as the unique strict dominator that dominates the node but does not strictly dominate any other strict dominator of the node.\n- Dominance frontier (DF): For a node $n$, the dominance frontier $\\mathrm{DF}(n)$ is the set of all nodes $y$ such that $n$ dominates at least one predecessor of $y$, but $n$ does not strictly dominate $y$.\n- Iterated dominance frontier: For a set of nodes $S$, the iterated dominance frontier $\\mathrm{DF}^{+}(S)$ is the smallest set containing $\\mathrm{DF}(S)$ and closed under repeated application of $\\mathrm{DF}$, i.e., the least fixed point under $X \\mapsto X \\cup \\mathrm{DF}(X)$ starting from $\\mathrm{DF}(S)$.\n\nStarting from these definitions and the given CFG, compute the number of distinct blocks that belong to the minimal set $\\mathrm{DF}^{+}(S)$ where $S = \\{B_{2}, B_{5}, B_{7}, B_{9}, B_{13}\\}$. Report your final answer as an exact integer equal to the number of $\\phi$-functions needed for $x$ in this CFG under minimal non-pruned insertion using $\\mathrm{DF}^{+}$.", "solution": "The user wants me to solve the problem by following strict formatting rules, including full LaTeX for every mathematical entity. The problem is valid, so I will now generate the solution.\n\nThe problem asks for the number of $\\phi$-functions required for a variable $x$ given its definition sites in a Control Flow Graph (CFG). According to the principles of Static Single Assignment (SSA) form construction, this is equivalent to finding the size of the iterated dominance frontier, denoted $\\mathrm{DF}^{+}(S)$, where $S$ is the set of basic blocks containing definitions of $x$.\n\nThe set of definition blocks is given as $S = \\{B_{2}, B_{5}, B_{7}, B_{9}, B_{13}\\}$.\n\nThe computation of $\\mathrm{DF}^{+}(S)$ requires three main steps:\n1.  Determine the dominator relationships for the given CFG and construct the dominator tree.\n2.  Compute the dominance frontier, $\\mathrm{DF}(n)$, for each relevant node $n$.\n3.  Compute the iterated dominance frontier, $\\mathrm{DF}^{+}(S)$, by repeatedly applying the $\\mathrm{DF}$ operator until a fixed point is reached.\n\n**Step 1: Dominator Tree Construction**\n\nA node $d$ dominates a node $n$ if every path from the entry block $B_{0}$ to $n$ must pass through $d$. The immediate dominator of a node $n$, $\\mathrm{idom}(n)$, is the unique strict dominator of $n$ that is closest to $n$ on any path from the entry. By finding the immediate dominator for each block (except for the entry block $B_{0}$), we can construct the dominator tree.\n\nBased on the CFG structure, the immediate dominators are:\n- $\\mathrm{idom}(B_{1}) = B_{0}$\n- $\\mathrm{idom}(B_{2}) = B_{1}$\n- $\\mathrm{idom}(B_{3}) = B_{1}$\n- $\\mathrm{idom}(B_{4}) = B_{1}$ (Paths $B_{0}$-$B_{1}$-$B_{2}$-$B_{4}$, $B_{0}$-$B_{1}$-$B_{3}$-$B_{5}$-$B_{4}$, etc., all pass through $B_{1}$ before diverging and reconverging at $B_{4}$)\n- $\\mathrm{idom}(B_{5}) = B_{3}$\n- $\\mathrm{idom}(B_{6}) = B_{3}$ (Block $B_{6}$ is the head of a loop, entered from $B_{3}$)\n- $\\mathrm{idom}(B_{7}) = B_{6}$\n- $\\mathrm{idom}(B_{8}) = B_{6}$\n- $\\mathrm{idom}(B_{9}) = B_{4}$\n- $\\mathrm{idom}(B_{10}) = B_{4}$\n- $\\mathrm{idom}(B_{11}) = B_{4}$ (Paths from $B_{9}$ and $B_{10}$ reconverge at $B_{11}$)\n- $\\mathrm{idom}(B_{12}) = B_{11}$ (Block $B_{12}$ is the head of a loop, entered from $B_{11}$)\n- $\\mathrm{idom}(B_{13}) = B_{12}$\n- $\\mathrm{idom}(B_{14}) = B_{12}$\n- $\\mathrm{idom}(B_{15}) = B_{14}$\n\nThe resulting dominator tree has parent-child relationships defined by $( \\mathrm{idom}(n) \\to n )$.\n\n**Step 2: Dominance Frontier (DF) Calculation**\n\nThe dominance frontier $\\mathrm{DF}(n)$ is the set of all nodes $y$ such that $n$ dominates a predecessor of $y$, but $n$ does not strictly dominate $y$. We need to compute the DFs for the blocks in $S$ and subsequently for any blocks added to our set of $\\phi$-nodes.\n\nDFs for the initial set $S = \\{B_{2}, B_{5}, B_{7}, B_{9}, B_{13}\\}$:\n- $\\mathrm{DF}(B_{2})$: $B_{2}$ dominates its successor's predecessor (itself). The successor is $B_{4}$. $B_{2}$ does not strictly dominate $B_{4}$. Thus, $\\mathrm{DF}(B_{2}) = \\{B_{4}\\}$.\n- $\\mathrm{DF}(B_{5})$: $B_{5}$ dominates its successor's predecessor (itself). The successor is $B_{4}$. $B_{5}$ does not strictly dominate $B_{4}$. Thus, $\\mathrm{DF}(B_{5}) = \\{B_{4}\\}$.\n- $\\mathrm{DF}(B_{7})$: $B_{7}$ has a successor $B_{6}$ via a backedge. $B_{7}$ dominates its successor's predecessor (itself). $B_{7}$ does not strictly dominate the loop header $B_{6}$. Thus, $\\mathrm{DF}(B_{7}) = \\{B_{6}\\}$.\n- $\\mathrm{DF}(B_{9})$: $B_{9}$ dominates its successor's predecessor (itself). The successor is $B_{11}$. $B_{9}$ does not strictly dominate $B_{11}$. Thus, $\\mathrm{DF}(B_{9}) = \\{B_{11}\\}$.\n- $\\mathrm{DF}(B_{13})$: $B_{13}$ has a successor $B_{12}$ via a backedge. $B_{13}$ dominates its successor's predecessor (itself). $B_{13}$ does not strictly dominate the loop header $B_{12}$. Thus, $\\mathrm{DF}(B_{13}) = \\{B_{12}\\}$.\n\n**Step 3: Iterated Dominance Frontier (DF+) Calculation**\n\nThe set of nodes requiring $\\phi$-functions, which we denote $\\Phi$, is the smallest set satisfying $\\Phi = \\mathrm{DF}(S \\cup \\Phi)$. We can compute this as the least fixed point using a worklist algorithm.\n\nLet $W$ be a worklist of blocks whose DF needs to be processed.\nLet $\\Phi$ be the set of blocks where $\\phi$-functions are placed.\n\n1.  Initialize $\\Phi = \\emptyset$ and $W = S = \\{B_{2}, B_{5}, B_{7}, B_{9}, B_{13}\\}$.\n\n2.  Process the initial worklist:\n    - Pop $B_{2}$ from $W$. Compute $\\mathrm{DF}(B_{2}) = \\{B_{4}\\}$. Since $B_{4} \\notin \\Phi$, add $B_{4}$ to $\\Phi$ and $W$.\n      $\\Phi = \\{B_{4}\\}$, $W = \\{B_{5}, B_{7}, B_{9}, B_{13}, B_{4}\\}$.\n    - Pop $B_{5}$ from $W$. Compute $\\mathrm{DF}(B_{5}) = \\{B_{4}\\}$. Since $B_{4} \\in \\Phi$, do nothing.\n      $\\Phi = \\{B_{4}\\}$, $W = \\{B_{7}, B_{9}, B_{13}, B_{4}\\}$.\n    - Pop $B_{7}$ from $W$. Compute $\\mathrm{DF}(B_{7}) = \\{B_{6}\\}$. Since $B_{6} \\notin \\Phi$, add $B_{6}$ to $\\Phi$ and $W$.\n      $\\Phi = \\{B_{4}, B_{6}\\}$, $W = \\{B_{9}, B_{13}, B_{4}, B_{6}\\}$.\n    - Pop $B_{9}$ from $W$. Compute $\\mathrm{DF}(B_{9}) = \\{B_{11}\\}$. Since $B_{11} \\notin \\Phi$, add $B_{11}$ to $\\Phi$ and $W$.\n      $\\Phi = \\{B_{4}, B_{6}, B_{11}\\}$, $W = \\{B_{13}, B_{4}, B_{6}, B_{11}\\}$.\n    - Pop $B_{13}$ from $W$. Compute $\\mathrm{DF}(B_{13}) = \\{B_{12}\\}$. Since $B_{12} \\notin \\Phi$, add $B_{12}$ to $\\Phi$ and $W$.\n      $\\Phi = \\{B_{4}, B_{6}, B_{11}, B_{12}\\}$, $W = \\{B_{4}, B_{6}, B_{11}, B_{12}\\}$.\n\n3.  The first pass over $S$ is complete. Now we process the blocks that were added to $W$. To do this, we need their DFs.\n    - $\\mathrm{DF}(B_{4})$: Any path from $B_{4}$ stays within the subgraph dominated by $B_{4}$. There are no edges from a node dominated by $B_{4}$ to a node not strictly dominated by $B_{4}$. Thus, $\\mathrm{DF}(B_{4}) = \\emptyset$.\n    - $\\mathrm{DF}(B_{6})$: $B_{6}$ dominates $B_{8}$, which has a successor $B_{4}$. $B_{6}$ does not strictly dominate $B_{4}$, so $B_{4} \\in \\mathrm{DF}(B_{6})$. Also, $B_{6}$ dominates $B_{7}$, which has successor $B_{6}$. $B_{6}$ does not strictly dominate itself, so $B_{6} \\in \\mathrm{DF}(B_{6})$. Thus, $\\mathrm{DF}(B_{6}) = \\{B_{4}, B_{6}\\}$.\n    - $\\mathrm{DF}(B_{11})$: Symmetrically to $B_{4}$, $\\mathrm{DF}(B_{11}) = \\emptyset$.\n    - $\\mathrm{DF}(B_{12})$: $B_{12}$ dominates $B_{13}$, whose successor is $B_{12}$. $B_{12}$ does not strictly dominate itself. Thus, $\\mathrm{DF}(B_{12}) = \\{B_{12}\\}$.\n\n4.  Continue processing the worklist:\n    - Pop $B_{4}$ from $W$. Compute $\\mathrm{DF}(B_{4}) = \\emptyset$. No changes.\n      $\\Phi = \\{B_{4}, B_{6}, B_{11}, B_{12}\\}$, $W = \\{B_{6}, B_{11}, B_{12}\\}$.\n    - Pop $B_{6}$ from $W$. Compute $\\mathrm{DF}(B_{6}) = \\{B_{4}, B_{6}\\}$. Both $B_{4}$ and $B_{6}$ are already in $\\Phi$. No changes.\n      $\\Phi = \\{B_{4}, B_{6}, B_{11}, B_{12}\\}$, $W = \\{B_{11}, B_{12}\\}$.\n    - Pop $B_{11}$ from $W$. Compute $\\mathrm{DF}(B_{11}) = \\emptyset$. No changes.\n      $\\Phi = \\{B_{4}, B_{6}, B_{11}, B_{12}\\}$, $W = \\{B_{12}\\}$.\n    - Pop $B_{12}$ from $W$. Compute $\\mathrm{DF}(B_{12}) = \\{B_{12}\\}$. $B_{12}$ is already in $\\Phi$. No changes.\n      $\\Phi = \\{B_{4}, B_{6}, B_{11}, B_{12}\\}$, $W = \\emptyset$.\n\n5.  The worklist $W$ is now empty. The algorithm terminates.\n\nThe minimal set of blocks requiring $\\phi$-functions is $\\mathrm{DF}^{+}(S) = \\Phi = \\{B_{4}, B_{6}, B_{11}, B_{12}\\}$.\nThe problem asks for the number of distinct blocks in this set.\nThe size of the set is $|\\Phi| = 4$.", "answer": "$$\\boxed{4}$$", "id": "3638854"}, {"introduction": "Our analysis of loops often assumes they are 'well-behaved' or 'reducible,' meaning they have a single entry point—the header—that dominates all other nodes in the loop. However, certain control-flow patterns, such as those created by unstructured `goto` statements, can lead to irreducible loops with multiple entries, complicating analysis and optimization. This exercise demonstrates how to detect such a case and apply a graph transformation technique called node splitting to repair the irreducibility, restoring the single-entry property required by many standard compiler algorithms [@problem_id:3638857].", "problem": "Consider the following Control Flow Graph (CFG) with a unique entry node $S$ and a unique exit node $T$. The nodes are $S, A, B, C, D, E, F, T$. Directed edges are:\n- $S \\to A$,\n- $A \\to B$, $A \\to C$, $A \\to F$,\n- $F \\to D$,\n- $B \\to D$,\n- $D \\to C$,\n- $C \\to E$,\n- $E \\to B$, $E \\to T$.\n\nThis CFG contains a strongly connected component (SCC) on the node set $\\{B, C, D, E\\}$ with the cycle $B \\to D \\to C \\to E \\to B$. We will regard this SCC as a loop candidate.\n\nYou will use the following foundational definitions:\n- Dominance: In a CFG with entry $S$, a node $X$ dominates a node $Y$ if every path from $S$ to $Y$ includes $X$.\n- Loop header: A loop header is a node that dominates all nodes in its loop body.\n- Reducible flow graph: A CFG is reducible if every cycle is single-entry; equivalently, each loop has a single header that dominates all nodes in the loop body.\n- Irreducible flow graph: A CFG is irreducible if there exists some cycle with multiple distinct entry edges from outside the SCC into different nodes of the SCC, so that no single node dominates the entire SCC.\n\nTask:\n1) Using only the definitions above, argue whether node $B$ can serve as a loop header for the SCC $\\{B, C, D, E\\}$ by checking whether $B$ dominates $C$ and $D$. Based on your reasoning, decide whether the SCC is irreducible with respect to $B$.\n\n2) To repair irreducibility, apply the following deterministic node-splitting procedure with $B$ designated as the header $H$:\n   - Define the unique headerward successor mapping on the SCC by the edges $B \\mapsto D$, $D \\mapsto C$, $C \\mapsto E$, $E \\mapsto B$. This choice induces, for any $v \\in \\{B,C,D,E\\}$, a unique headerward path to $H = B$ by repeatedly following this mapping until $B$ is reached.\n   - For every edge $(u \\to v)$ where $u \\notin \\{B,C,D,E\\}$ and $v \\in \\{B,C,D,E\\}$ with $v \\neq B$, perform node splitting along the headerward path from $v$ to $B$:\n     • Create fresh copies of each node on the headerward path starting at $v$ and ending just before $B$. If the path is $v = w_{0} \\to w_{1} \\to \\dots \\to w_{k-1} \\to w_{k} = B$, create fresh nodes $w_{0}', w_{1}', \\dots, w_{k-1}'$.\n     • Redirect $(u \\to v)$ to $(u \\to w_{0}')$ and add edges $w_{i}' \\to w_{i+1}'$ for $i = 0, \\dots, k-2$, and $w_{k-1}' \\to B$.\n     • For any original exit edge from any $w_{i}$ to a node outside the SCC, add the same exit edge from $w_{i}'$ to that outside target.\n     • Do not share copies between distinct external entry edges; each external entry produces its own set of fresh copies along its path to $B$.\n   - Do nothing for $(u \\to v)$ if $v = B$ (the header).\n\n3) Let $N$ be the total number of fresh node copies created by this repair procedure on the given CFG. Compute $N$. Your final answer must be a single real number. No rounding is required.", "solution": "We begin from the definitions of dominance, loop header, and reducible versus irreducible flow graphs.\n\nStep 1: Detecting irreducibility and non-dominance.\n- The SCC $\\{B, C, D, E\\}$ forms a cycle via $B \\to D \\to C \\to E \\to B$, so these four nodes are mutually reachable. This is a loop candidate.\n- External entry edges into this SCC are edges from nodes outside the SCC into nodes inside the SCC. From the edge list:\n  • $A \\to B$ enters the SCC at $B$.\n  • $A \\to C$ enters the SCC at $C$.\n  • $F \\to D$ enters the SCC at $D$.\n  Thus, there are three distinct entry edges into the SCC, targeting $B$, $C$, and $D$.\n- To test if $B$ can be a loop header, we must verify whether $B$ dominates every node in the SCC. Using the definition of dominance, check $C$ and $D$:\n  • For $C$: There exists a path $S \\to A \\to C$ that reaches $C$ without passing through $B$. Therefore, not every path from $S$ to $C$ includes $B$, so $B$ does not dominate $C$.\n  • For $D$: There exists a path $S \\to A \\to F \\to D$ that reaches $D$ without passing through $B$. Therefore, $B$ does not dominate $D$.\n  Since $B$ fails to dominate at least $C$ and $D$, $B$ cannot serve as a loop header for the SCC. The presence of multiple external entries $(A \\to C)$ and $(F \\to D)$ into distinct nodes of the SCC implies the SCC is irreducible with respect to $B$ by the single-entry criterion.\n\nStep 2: Applying the deterministic node-splitting repair with headerward successor mapping.\n- The headerward successor mapping is specified as $B \\mapsto D$, $D \\mapsto C$, $C \\mapsto E$, $E \\mapsto B$. This yields unique headerward paths to $B$ for any node in the SCC:\n  • From $C$: $C \\to E \\to B$.\n  • From $D$: $D \\to C \\to E \\to B$.\n  • From $E$: $E \\to B$.\n  • From $B$: already at $B$.\n- We must process each external entry $(u \\to v)$ with $u \\notin \\{B,C,D,E\\}$ and $v \\in \\{B,C,D,E\\}$, $v \\neq B$.\n\nThere are two such edges:\n- Edge $(A \\to C)$ with $v = C \\neq B$.\n  • Headerward path from $C$ to $B$ is $C \\to E \\to B$. The nodes strictly before $B$ on this path are $C$ and $E$.\n  • Create fresh copies $C_{1}$ and $E_{1}$.\n  • Redirect $A \\to C$ to $A \\to C_{1}$.\n  • Add edges $C_{1} \\to E_{1}$ and $E_{1} \\to B$.\n  • Replicate exit edges from the originals to outside the SCC: $E$ has an exit edge $E \\to T$, so add $E_{1} \\to T$. Node $C$ has no exit to outside the SCC in the original graph, so no exit replication is needed for $C_{1}$.\n  • Fresh node count contributed by this external entry is $2$ (the nodes $C_{1}$ and $E_{1}$).\n\n- Edge $(F \\to D)$ with $v = D \\neq B$.\n  • Headerward path from $D$ to $B$ is $D \\to C \\to E \\to B$. The nodes strictly before $B$ on this path are $D$, $C$, and $E$.\n  • Create fresh copies $D_{2}$, $C_{2}$, and $E_{2}$.\n  • Redirect $F \\to D$ to $F \\to D_{2}$.\n  • Add edges $D_{2} \\to C_{2}$, $C_{2} \\to E_{2}$, and $E_{2} \\to B$.\n  • Replicate exit edges from the originals to outside the SCC: $E$ has exit $E \\to T$, so add $E_{2} \\to T$. Nodes $D$ and $C$ have no exits to outside the SCC in the original graph, so no exit replication is needed for $D_{2}$ or $C_{2}$.\n  • Fresh node count contributed by this external entry is $3$ (the nodes $D_{2}$, $C_{2}$, and $E_{2}$).\n\nPer the procedure, copies are not shared between distinct external entries. Therefore, the total number of fresh nodes created is the sum of the contributions from these two entries.\n\nStep 3: Compute $N$.\n- From $(A \\to C)$: $2$ fresh nodes.\n- From $(F \\to D)$: $3$ fresh nodes.\nThus,\n$$\nN = 2 + 3 = 5.\n$$\n\nStep 4: Postcondition check (why this repair works conceptually).\n- After these transformations, the only remaining edge from outside the SCC $\\{B, C, D, E\\}$ into the original SCC nodes is $A \\to B$ (the header). The redirected edges now enter the fresh copies and then reach $B$ or exit at $T$ without entering any original SCC node other than $B$.\n- Consequently, every path from $S$ to any node in the original SCC must pass through $B$, so $B$ now dominates all nodes in the SCC, making the loop single-entry and the CFG reducible with respect to that loop.\n- The computed $N$ quantifies the size of the repair via node splitting under the specified deterministic procedure.\n\nTherefore, the total number of fresh node copies created is $5$.", "answer": "$$\\boxed{5}$$", "id": "3638857"}]}