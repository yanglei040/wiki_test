{"hands_on_practices": [{"introduction": "To truly grasp the value of pruned SSA, we start with a clear-cut scenario. This exercise explores a program where a variable is frequently defined but never actually used, making it a \"dead\" variable. By calculating the $\\phi$-functions required by both minimal and pruned SSA, you will directly quantify the optimization benefit of using liveness information to eliminate unnecessary code. [@problem_id:3665127]", "problem": "Consider the following control-flow graph (CFG) with basic blocks labeled $B_{0}$ through $B_{9}$. The program has variables $a$ and $b$, and boolean conditions $p$, $q$, and $r$. Each basic block contains the following statements and control transfers:\n- $B_{0}$: $a \\leftarrow 0$; $b \\leftarrow 0$; $\\text{goto } B_{1}$.\n- $B_{1}$: $\\text{if } p \\text{ then goto } B_{2} \\text{ else goto } B_{3}$.\n- $B_{2}$: $a \\leftarrow 1$; $\\text{goto } B_{4}$.\n- $B_{3}$: $\\text{if } q \\text{ then goto } B_{5} \\text{ else goto } B_{6}$.\n- $B_{5}$: $a \\leftarrow 2$; $\\text{goto } B_{4}$.\n- $B_{6}$: $b \\leftarrow b + 1$; $\\text{goto } B_{4}$.\n- $B_{4}$: $\\text{if } r \\text{ then goto } B_{7} \\text{ else goto } B_{8}$.\n- $B_{7}$: $a \\leftarrow 3$; $\\text{goto } B_{9}$.\n- $B_{8}$: $t \\leftarrow b$; $\\text{goto } B_{9}$.\n- $B_{9}$: $u \\leftarrow b$; \\text{return}.\n\nAssume the unique entry is $B_{0}$ and the unique exit is $B_{9}$. The only variable possibly used in expressions on the right-hand side in this program is $b$; there is no use of $a$ in any right-hand side or condition.\n\nUsing the standard definitions of dominance, dominance frontier, and liveness from compiler theory, perform the following tasks:\n1. Compute the dominance frontier of all basic blocks that define $a$ and report the union set $DF(a)$.\n2. Using the minimal Static Single Assignment (SSA) construction (placing $\\phi$-functions at the iterated dominance frontier of the definition sites), determine at which join blocks $\\phi(a)$ would be placed.\n3. Perform liveness analysis for variable $a$ on the original program (before inserting any $\\phi$-functions) to determine at which join blocks $a$ is live-in.\n4. Focusing on pruned SSA form (which places $\\phi$-functions only at join blocks where the variable is live-in), determine how many $\\phi(a)$ insertions from minimal SSA are eliminated by pruning because $a$ is dead-in at those join points.\n\nProvide as your final answer the total number of $\\phi(a)$ insertions eliminated by pruned SSA compared to minimal SSA. Your answer must be a single integer. No rounding is necessary. Express your final answer as a pure number without any units.", "solution": "The user wants to solve a problem about Static Single Assignment (SSA) form, specifically comparing minimal SSA with pruned SSA.\n\n### Step 1: Problem Validation\n\n**1.1. Extract Givens**\n\n*   **Control-Flow Graph (CFG):**\n    *   Basic blocks: $B_{0}, B_{1}, B_{2}, B_{3}, B_{4}, B_{5}, B_{6}, B_{7}, B_{8}, B_{9}$.\n    *   Unique entry: $B_{0}$.\n    *   Unique exit: $B_{9}$.\n*   **Block Contents and Control Flow:**\n    *   $B_{0}$: $a \\leftarrow 0$; $b \\leftarrow 0$; goto $B_{1}$.\n    *   $B_{1}$: if $p$ then goto $B_{2}$ else goto $B_{3}$.\n    *   $B_{2}$: $a \\leftarrow 1$; goto $B_{4}$.\n    *   $B_{3}$: if $q$ then goto $B_{5}$ else goto $B_{6}$.\n    *   $B_{5}$: $a \\leftarrow 2$; goto $B_{4}$.\n    *   $B_{6}$: $b \\leftarrow b + 1$; goto $B_{4}$.\n    *   $B_{4}$: if $r$ then goto $B_{7}$ else goto $B_{8}$.\n    *   $B_{7}$: $a \\leftarrow 3$; goto $B_{9}$.\n    *   $B_{8}$: $t \\leftarrow b$; goto $B_{9}$.\n    *   $B_{9}$: $u \\leftarrow b$; return.\n*   **Variables:** $a, b, t, u$.\n*   **Conditions:** $p, q, r$.\n*   **Crucial Constraint:** \"The only variable possibly used in expressions on the right-hand side in this program is $b$; there is no use of $a$ in any right-hand side or condition.\"\n*   **Tasks:**\n    1.  Compute the dominance frontier union set $DF(a)$ for all blocks defining $a$.\n    2.  Determine where $\\phi(a)$ functions are placed for minimal SSA.\n    3.  Determine at which join blocks $a$ is live-in.\n    4.  Determine how many $\\phi(a)$ insertions are eliminated by pruned SSA compared to minimal SSA.\n\n**1.2. Validate Using Extracted Givens**\n\n*   **Scientifically Grounded:** The problem uses standard, well-defined concepts from compiler theory: control-flow graphs, dominance, dominance frontiers, liveness analysis, and Static Single Assignment (SSA) form (both minimal and pruned). These concepts are fundamental to compiler construction and optimization. The problem is scientifically sound.\n*   **Well-Posed:** The CFG is completely specified, the tasks are clearly defined, and they lead to a unique, quantifiable answer.\n*   **Objective:** The problem statement is written in formal, objective language without ambiguity or subjective claims.\n*   **Completeness:** The problem provides all necessary information to solve it. The constraint about the use of variable $a$ is critical and explicitly stated.\n*   **Consistency:** The provided information is internally consistent.\n\n**1.3. Verdict and Action**\n\nThe problem is valid. I will proceed with a full solution.\n\n### Step 2: Solution\n\nThe overall goal is to compare the number of $\\phi$-functions inserted for variable $a$ under minimal SSA and pruned SSA. This requires four main steps as outlined in the problem.\n\n**CFG Structure and Dominators**\n\nFirst, we establish the structure of the CFG and compute the dominator tree, which is essential for calculating dominance frontiers.\nThe predecessors (Pred) and successors (Succ) of each block are:\n*   $Pred(B_{0}) = \\emptyset$ (entry)\n*   $Pred(B_{1}) = \\{B_{0}\\}$, $Succ(B_{1}) = \\{B_{2}, B_{3}\\}$\n*   $Pred(B_{2}) = \\{B_{1}\\}$, $Succ(B_{2}) = \\{B_{4}\\}$\n*   $Pred(B_{3}) = \\{B_{1}\\}$, $Succ(B_{3}) = \\{B_{5}, B_{6}\\}$\n*   $Pred(B_{4}) = \\{B_{2}, B_{5}, B_{6}\\}$, $Succ(B_{4}) = \\{B_{7}, B_{8}\\}$\n*   $Pred(B_{5}) = \\{B_{3}\\}$, $Succ(B_{5}) = \\{B_{4}\\}$\n*   $Pred(B_{6}) = \\{B_{3}\\}$, $Succ(B_{6}) = \\{B_{4}\\}$\n*   $Pred(B_{7}) = \\{B_{4}\\}$, $Succ(B_{7}) = \\{B_{9}\\}$\n*   $Pred(B_{8}) = \\{B_{4}\\}$, $Succ(B_{8}) = \\{B_{9}\\}$\n*   $Pred(B_{9}) = \\{B_{7}, B_{8}\\}$, $Succ(B_{9}) = \\emptyset$ (exit)\n\nBlocks with more than one predecessor are called join points. The join points in this CFG are $B_{4}$ and $B_{9}$.\n\nNext, we determine the immediate dominator ($idom$) for each block. A block $X$ dominates block $Y$ if every path from the entry to $Y$ includes $X$. The immediate dominator of $Y$ is the last dominator on any path from the entry to $Y$.\n*   $idom(B_{0}) = \\text{none}$ (entry node)\n*   $idom(B_{1}) = B_{0}$\n*   $idom(B_{2}) = B_{1}$\n*   $idom(B_{3}) = B_{1}$\n*   $idom(B_{4}) = B_{1}$ (The common dominator of its predecessors $\\{B_{2}, B_{5}, B_{6}\\}$ is $B_{1}$)\n*   $idom(B_{5}) = B_{3}$\n*   $idom(B_{6}) = B_{3}$\n*   $idom(B_{7}) = B_{4}$\n*   $idom(B_{8}) = B_{4}$\n*   $idom(B_{9}) = B_{4}$ (The common dominator of its predecessors $\\{B_{7}, B_{8}\\}$ is $B_{4}$)\n\nThe dominator tree is:\n$B_{0} \\to B_{1} \\to \\{B_{2}, B_{3}, B_{4}\\}$\n$B_{3} \\to \\{B_{5}, B_{6}\\}$\n$B_{4} \\to \\{B_{7}, B_{8}, B_{9}\\}$\n\n**Task 1 & 2: Minimal SSA Construction**\n\nMinimal SSA form requires placing $\\phi$-functions at the iterated dominance frontier of the set of blocks containing definitions of a variable. The dominance frontier $DF(X)$ of a block $X$ is the set of all blocks $Y$ such that $X$ dominates a predecessor of $Y$, but $X$ does not strictly dominate $Y$.\n\nLet's compute the dominance frontiers ($DF$) for the blocks that define variable $a$. The set of blocks defining $a$, let's call it $Defs(a)$, is:\n$Defs(a) = \\{B_{0}, B_{2}, B_{5}, B_{7}\\}$\n\nWe compute the $DF$ for these blocks:\n*   $DF(B_{0})$: $B_{0}$ dominates all blocks. It has no dominance frontier. $DF(B_{0}) = \\emptyset$.\n*   $DF(B_{2})$: $B_{2}$ has one successor, $B_{4}$. $B_{2}$ dominates one of $B_{4}$'s predecessors (namely, $B_{2}$ itself), but $B_{2}$ ($idom(B_2)=B_1$) does not strictly dominate $B_{4}$ ($idom(B_4)=B_1$). Thus, $B_{4} \\in DF(B_{2})$. So, $DF(B_{2}) = \\{B_{4}\\}$.\n*   $DF(B_{5})$: $B_{5}$ has one successor, $B_{4}$. $B_{5}$ dominates a predecessor of $B_{4}$ (itself), but does not strictly dominate $B_{4}$. Thus, $B_{4} \\in DF(B_{5})$. So, $DF(B_{5}) = \\{B_{4}\\}$.\n*   $DF(B_{7})$: $B_{7}$ has one successor, $B_{9}$. $B_{7}$ dominates a predecessor of $B_{9}$ (itself), but does not strictly dominate $B_{9}$ ($idom(B_9)=B_4$). Thus, $B_{9} \\in DF(B_{7})$. So, $DF(B_{7}) = \\{B_{9}\\}$.\n\nFor Task 1, the union set $DF(a)$ is:\n$DF(a) = DF(B_{0}) \\cup DF(B_{2}) \\cup DF(B_{5}) \\cup DF(B_{7}) = \\emptyset \\cup \\{B_{4}\\} \\cup \\{B_{4}\\} \\cup \\{B_{9}\\} = \\{B_{4}, B_{9}\\}$.\n\nFor Task 2, we find the iterated dominance frontier, $IDF(Defs(a))$. We start with the set $\\Phi = DF(a) = \\{B_{4}, B_{9}\\}$. We then add the dominance frontiers of the blocks in $\\Phi$ to the set, and iterate until no new blocks are added.\n*   $DF(B_{4})$: The successors of $B_{4}$ are $B_{7}$ and $B_{8}$. $B_{4}$ strictly dominates both, so $DF_{local}(B_{4}) = \\emptyset$. The children of $B_4$ in the dominator tree are $B_7, B_8, B_9$. $DF(B_7)=\\{B_9\\}$, but $B_4$ strictly dominates $B_9$. $DF(B_8)=\\{B_9\\}$, but $B_4$ strictly dominates $B_9$. $DF(B_9)=\\emptyset$. So $DF(B_{4}) = \\emptyset$.\n*   $DF(B_{9})$: $B_{9}$ has no successors, so $DF(B_{9}) = \\emptyset$.\n\nSince $DF(B_{4})$ and $DF(B_{9})$ are empty, the iteration stops immediately. The set of nodes where $\\phi(a)$ must be placed for minimal SSA is $IDF(Defs(a)) = \\{B_{4}, B_{9}\\}$.\nMinimal SSA will insert $\\mathbf{2}$ $\\phi$-functions for variable $a$, one at $B_{4}$ and one at $B_{9}$.\n\n**Task 3: Liveness Analysis for Variable $a$**\n\nA variable is *live* at a program point if its current value might be used in the future. Liveness is a backward data-flow analysis problem. The data-flow equations for a block $B$ are:\n$LiveOut(B) = \\bigcup_{S \\in Succ(B)} LiveIn(S)$\n$LiveIn(B) = Use(B) \\cup (LiveOut(B) \\setminus Def(B))$\n\nHere, $Use(B)$ is the set of variables used in $B$ before they are defined, and $Def(B)$ is the set of variables defined in $B$.\n\nThe problem statement provides a critical piece of information: \"...there is no use of $a$ in any right-hand side or condition.\" This means that for variable $a$, the set $Use(B)$ is empty for all blocks $B \\in \\{B_{0}, \\dots, B_{9}\\}$.\nLet's analyze the consequence:\n$LiveIn(B) = \\emptyset \\cup (LiveOut(B) \\setminus Def_{a}(B)) = LiveOut(B) \\setminus Def_{a}(B)$.\n\nThe analysis starts from the exit block, assuming all live sets are initially empty. At the program exit (after $B_{9}$), no variables are live.\n*   $LiveOut(B_{9}) = \\emptyset$.\n*   $LiveIn(B_{9}) = Use(B_{9}) \\cup (LiveOut(B_{9}) \\setminus Def(B_{9})) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset$.\n*   For any predecessor $P$ of $B_{9}$ (i.e., $B_{7}, B_{8}$), $LiveOut(P)$ will include $LiveIn(B_{9})$, which is $\\emptyset$.\n*   $LiveOut(B_{8}) = LiveIn(B_{9}) = \\emptyset$.\n*   $LiveIn(B_{8}) = Use(B_{8}) \\cup (LiveOut(B_{8}) \\setminus Def(B_{8})) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset$.\n*   $LiveOut(B_{7}) = LiveIn(B_{9}) = \\emptyset$.\n*   $LiveIn(B_{7}) = Use(B_{7}) \\cup (LiveOut(B_{7}) \\setminus \\{a\\}) = \\emptyset \\cup (\\emptyset \\setminus \\{a\\}) = \\emptyset$.\n\nThis pattern propagates backward through the entire graph. Since $Use(a)$ is always empty, the liveness of $a$ is never initiated. Any definition of $a$ is a \"dead store\" because the value is never read. The fixed-point solution for the liveness of $a$ is that $LiveIn_{a}(B) = \\emptyset$ and $LiveOut_{a}(B) = \\emptyset$ for all blocks $B$.\n\nFor Task 3, we are asked at which join blocks ($B_{4}$, $B_{9}$) the variable $a$ is live-in.\n*   Is $a$ live-in at $B_{4}$? No, $LiveIn_{a}(B_{4}) = \\emptyset$.\n*   Is $a$ live-in at $B_{9}$? No, $LiveIn_{a}(B_{9}) = \\emptyset$.\nThe answer is that $a$ is not live-in at any join block.\n\n**Task 4: Pruning and Final Calculation**\n\n*   **Minimal SSA:** Inserts $\\phi(a)$ functions at all join points in the iterated dominance frontier of definition sites. As found in Task 2, these are $B_{4}$ and $B_{9}$. Total insertions = $2$.\n\n*   **Pruned SSA:** Inserts $\\phi(a)$ functions only at join points where the variable $a$ is also live. These are the nodes in the set $\\{B | B \\text{ is a join point}\\} \\cap IDF(Defs(a)) \\cap \\{B | a \\in LiveIn(B)\\}$.\n    *   The join points are $\\{B_{4}, B_{9}\\}$.\n    *   $IDF(Defs(a)) = \\{B_{4}, B_{9}\\}$.\n    *   The set of blocks where $a$ is live-in is $\\emptyset$.\n    *   The intersection of these three sets is $\\emptyset$.\n    *   Therefore, pruned SSA inserts $0$ $\\phi(a)$ functions.\n\nThe number of $\\phi(a)$ insertions eliminated by pruned SSA is the number of insertions in minimal SSA minus the number in pruned SSA.\nNumber eliminated = (Minimal SSA insertions) - (Pruned SSA insertions) = $2 - 0 = 2$.\nThe two eliminated $\\phi$-functions are the ones at $B_{4}$ and $B_{9}$.", "answer": "$$\\boxed{2}$$", "id": "3665127"}, {"introduction": "After understanding the impact of globally dead variables, let's zoom in on how liveness is determined at a specific join point. This practice presents a simple control-flow diamond and asks you to analyze three variations, each with subtle changes to the code within and after the join. This will sharpen your ability to apply the liveness definition precisely, seeing how a variable can be live-in in one case and dead-in another, directly affecting $\\phi$-function placement. [@problem_id:3665069]", "problem": "Consider a Control Flow Graph (CFG) for a straight-line fragment in a compiler front-end. You are to reason about converting the program to Static Single Assignment (SSA) form, specifically the pruned variant, which inserts only those merge functions that are justified by variable liveness.\n\nUse the following fundamental base:\n- Definition of Static Single Assignment (SSA): each variable is assigned exactly once, and special merge functions $\\phi$ are placed at control-flow joins to merge values from different paths.\n- Definition of pruned SSA: identical to SSA, except that a $\\phi$-function for a variable $v$ at a join block is inserted only if $v$ is live at that join block.\n- Definition of liveness at a program point: a variable $v$ is live at a point if there exists a path from that point to a use of $v$ without an intervening redefinition of $v$.\n- Block-level dataflow sets: for a basic block $B$, $\\text{use}(B)$ is the set of variables used in $B$ before any redefinition in $B$; $\\text{def}(B)$ is the set of variables defined in $B$; $\\text{live-in}(B) = \\text{use}(B) \\cup (\\text{live-out}(B) \\setminus \\text{def}(B))$ and $\\text{live-out}(B) = \\bigcup_{S \\in \\text{succ}(B)} \\text{live-in}(S)$.\n\nThe CFG shape is the same for all variants below:\n- $B_0$: $x := 0$; if $p$ then goto $B_1$ else goto $B_2$.\n- $B_1$: $x := 1$; goto $B_3$.\n- $B_2$: goto $B_3$.\n- $B_3$: variant-specific code; then goto $B_4$.\n- $B_4$: variant-specific code; then exit.\n\nThree variants differ only in $B_3$ and $B_4$ as follows.\n- Variant I:\n  - $B_3$: $t := x + 1$; goto $B_4$.\n  - $B_4$: return $t$.\n- Variant II:\n  - $B_3$: $x := 5$; $t := x + 1$; goto $B_4$.\n  - $B_4$: return $t$.\n- Variant III:\n  - $B_3$: goto $B_4$.\n  - $B_4$: $y := x$; return $y$.\n\nAssume $x$, $t$, $y$ are distinct program variables, and $p$ is a boolean condition. For each variant, decide whether pruned SSA will insert a $\\phi(x)$ at the join block $B_3$, using only the base definitions above. Choose the correct claim from the options below.\n\nA. Pruned SSA inserts $\\phi(x)$ at $B_3$ in Variant I and Variant III, but not in Variant II, because $x$ is live at $B_3$ only in Variant I and Variant III.\n\nB. Pruned SSA inserts $\\phi(x)$ at $B_3$ in all three variants, because $B_3$ lies in the dominance frontier of the definitions of $x$ regardless of liveness.\n\nC. Pruned SSA inserts $\\phi(x)$ at $B_3$ only if both $B_1$ and $B_2$ redefine $x$; with a redefinition on only one side, no $\\phi(x)$ is needed at $B_3$.\n\nD. Pruned SSA inserts $\\phi(x)$ at $B_3$ in Variant II, because there are two reaching definitions of $x$ at $B_3$ even if $x$ is immediately redefined in $B_3$.\n\nSelect all options that are correct and justify your choice using the notion of liveness at the join. Be precise: your reasoning must follow from the given base definitions and the control-flow structure above, not from any unstated algorithmic shortcut.", "solution": "The user has requested a an analysis of a compiler problem related to pruned Static Single Assignment (SSA) form.\n\n### Step 1: Extract Givens\n\n-   **Definition of Static Single Assignment (SSA):** Each variable is assigned exactly once. Special merge functions, denoted as $\\phi$, are placed at control-flow joins to merge values from different paths.\n-   **Definition of pruned SSA:** A $\\phi$-function for a variable $v$ is inserted at a join block only if $v$ is live at that join block.\n-   **Definition of Liveness:** A variable $v$ is live at a point if there exists a path from that point to a use of $v$ without an intervening redefinition of $v$.\n-   **Block-level Dataflow Sets:** For a basic block $B$:\n    -   $\\text{use}(B)$: set of variables used in $B$ before any redefinition in $B$.\n    -   $\\text{def}(B)$: set of variables defined in $B$.\n    -   $\\text{live-in}(B) = \\text{use}(B) \\cup (\\text{live-out}(B) \\setminus \\text{def}(B))$.\n    -   $\\text{live-out}(B) = \\bigcup_{S \\in \\text{succ}(B)} \\text{live-in}(S)$.\n-   **Control Flow Graph (CFG) Structure:**\n    -   $B_0$: $x := 0$; if $p$ then goto $B_1$ else goto $B_2$.\n    -   $B_1$: $x := 1$; goto $B_3$.\n    -   $B_2$: goto $B_3$.\n    -   $B_3$: variant-specific code; then goto $B_4$.\n    -   $B_4$: variant-specific code; then exit.\n-   **CFG Successors:**\n    -   $\\text{succ}(B_0) = \\{B_1, B_2\\}$.\n    -   $\\text{succ}(B_1) = \\{B_3\\}$.\n    -   $\\text{succ}(B_2) = \\{B_3\\}$.\n    -   $\\text{succ}(B_3) = \\{B_4\\}$.\n    -   $\\text{succ}(B_4) = \\{\\text{exit}\\}$.\n-   **Code Variants:**\n    -   **Variant I:**\n        -   $B_3$: $t := x + 1$; goto $B_4$.\n        -   $B_4$: return $t$.\n    -   **Variant II:**\n        -   $B_3$: $x := 5$; $t := x + 1$; goto $B_4$.\n        -   $B_4$: return $t$.\n    -   **Variant III:**\n        -   $B_3$: goto $B_4$.\n        -   $B_4$: $y := x$; return $y$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is scientifically grounded, well-posed, and objective.\n1.  **Scientific or Factual Soundness:** The problem is based on established concepts in compiler theory, namely Control Flow Graphs, Static Single Assignment form (both standard and pruned), and liveness analysis. The definitions provided are standard and correct.\n2.  **Non-Formalizable or Irrelevant:** The problem is a formal exercise in applying dataflow analysis, directly relevant to compiler principles.\n3.  **Incomplete or Contradictory Setup:** The problem provides a complete CFG structure, explicit code for each block in three different variants, and all necessary definitions for liveness analysis and pruned SSA. The information is self-contained and consistent.\n4.  **Unrealistic or Infeasible:** The code fragments are simple, valid, and represent plausible program structures. The analysis is computationally feasible.\n5.  **Ill-Posed or Poorly Structured:** The problem is well-posed. For each variant, a unique determination can be made about the insertion of a $\\phi$-function based on the provided rules. The terminology is precise.\n6.  **Pseudo-Profound, Trivial, or Tautological:** The problem requires a careful, step-by-step application of liveness analysis, distinguishing between different program variants. It tests a core conceptual distinction between standard and pruned SSA.\n7.  **Outside Scientific Verifiability:** The claims can be verified by executing the defined dataflow analysis algorithm.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. The solution process will now proceed.\n\n### Derivation of the Correct Answer\n\nThe core of the problem is to determine, for each variant, whether a $\\phi$-function for the variable $x$, denoted $\\phi(x)$, should be inserted at the beginning of block $B_3$.\n\nA $\\phi$-function for a variable is inserted at a control-flow join point if there are multiple distinct definitions of that variable reaching the join. In the given CFG, $B_3$ is a join point, as it is the successor of both $B_1$ and $B_2$. The variable $x$ is defined in $B_0$ (as $x := 0$) and redefined in $B_1$ (as $x := 1$). The path through $B_2$ does not redefine $x$. Therefore, two different definitions of $x$ reach the entry of $B_3$: the one from $B_1$ and the one from $B_0$ (which flows through $B_2$). This satisfies the condition for inserting a $\\phi$-function in standard SSA.\n\nHowever, the problem specifies **pruned SSA**. According to the provided definition, a $\\phi(x)$ function is inserted at $B_3$ only if $x$ is **live** at the entry of $B_3$. We must therefore perform a liveness analysis for each variant. Liveness is a backward dataflow analysis problem. We will compute the sets $\\text{live-in}(B)$ and $\\text{live-out}(B)$ for each block $B$, iterating until a fixed point is reached. We assume nothing is live at the program's exit, so $\\text{live-out}(B_4) = \\text{live-in}(\\text{exit}) = \\emptyset$. The question hinges on whether $x \\in \\text{live-in}(B_3)$.\n\n**Analysis of Variant I**\n-   $B_3$: $t := x + 1$; goto $B_4$.\n-   $B_4$: return $t$.\n\n1.  **Block $B_4$**:\n    -   The statement is `return t`. The variable $t$ is used.\n    -   $\\text{use}(B_4) = \\{t\\}$, $\\text{def}(B_4) = \\emptyset$.\n    -   $\\text{live-out}(B_4) = \\emptyset$.\n    -   $\\text{live-in}(B_4) = \\text{use}(B_4) \\cup (\\text{live-out}(B_4) \\setminus \\text{def}(B_4)) = \\{t\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{t\\}$.\n\n2.  **Block $B_3$**:\n    -   The statement is $t := x + 1$. The variable $x$ is used, and $t$ is defined.\n    -   $\\text{use}(B_3) = \\{x\\}$, $\\text{def}(B_3) = \\{t\\}$.\n    -   $\\text{live-out}(B_3) = \\text{live-in}(\\text{succ}(B_3)) = \\text{live-in}(B_4) = \\{t\\}$.\n    -   $\\text{live-in}(B_3) = \\text{use}(B_3) \\cup (\\text{live-out}(B_3) \\setminus \\text{def}(B_3)) = \\{x\\} \\cup (\\{t\\} \\setminus \\{t\\}) = \\{x\\} \\cup \\emptyset = \\{x\\}$.\n\nConclusion for Variant I: $x$ is in $\\text{live-in}(B_3)$. Therefore, in pruned SSA, a $\\phi(x)$ function is inserted at $B_3$.\n\n**Analysis of Variant II**\n-   $B_3$: $x := 5$; $t := x + 1$; goto $B_4$.\n-   $B_4$: return $t$.\n\n1.  **Block $B_4$**: Same as in Variant I.\n    -   $\\text{live-in}(B_4) = \\{t\\}$.\n\n2.  **Block $B_3$**:\n    -   The statements are $x := 5$ followed by $t := x + 1$. The use of $x$ in the second statement is preceded by a redefinition of $x$ within the same block. According to the definition $\\text{use}(B)$ is the set of variables \"used in $B$ before any redefinition in $B$\". Thus, $x$ is not in $\\text{use}(B_3)$.\n    -   $\\text{use}(B_3) = \\emptyset$.\n    -   Both $x$ and $t$ are defined. $\\text{def}(B_3) = \\{x, t\\}$.\n    -   $\\text{live-out}(B_3) = \\text{live-in}(B_4) = \\{t\\}$.\n    -   $\\text{live-in}(B_3) = \\text{use}(B_3) \\cup (\\text{live-out}(B_3) \\setminus \\text{def}(B_3)) = \\emptyset \\cup (\\{t\\} \\setminus \\{x, t\\}) = \\emptyset \\cup \\emptyset = \\emptyset$.\n\nConclusion for Variant II: $x$ is **not** in $\\text{live-in}(B_3)$ because it is redefined in $B_3$ before any subsequent use on any path starting from the entry of $B_3$. Therefore, in pruned SSA, a $\\phi(x)$ function is **not** inserted at $B_3$.\n\n**Analysis of Variant III**\n-   $B_3$: goto $B_4$.\n-   $B_4$: $y := x$; return $y$.\n\n1.  **Block $B_4$**:\n    -   The statements are $y := x$ followed by `return y`. The variable $x$ is used to define $y$. The variable $y$ is used in the return statement, but this use is preceded by its definition within $B_4$. Thus, $\\text{use}(B_4)$ contains $x$.\n    -   $\\text{use}(B_4) = \\{x\\}$, $\\text{def}(B_4) = \\{y\\}$.\n    -   $\\text{live-out}(B_4) = \\emptyset$.\n    -   $\\text{live-in}(B_4) = \\text{use}(B_4) \\cup (\\text{live-out}(B_4) \\setminus \\text{def}(B_4)) = \\{x\\} \\cup (\\emptyset \\setminus \\{y\\}) = \\{x\\}$.\n\n2.  **Block $B_3$**:\n    -   This is an empty block containing only a goto.\n    -   $\\text{use}(B_3) = \\emptyset$, $\\text{def}(B_3) = \\emptyset$.\n    -   $\\text{live-out}(B_3) = \\text{live-in}(B_4) = \\{x\\}$.\n    -   $\\text{live-in}(B_3) = \\text{use}(B_3) \\cup (\\text{live-out}(B_3) \\setminus \\text{def}(B_3)) = \\emptyset \\cup (\\{x\\} \\setminus \\emptyset) = \\{x\\}$.\n\nConclusion for Variant III: $x$ is in $\\text{live-in}(B_3)$. Therefore, in pruned SSA, a $\\phi(x)$ function is inserted at $B_3$.\n\n**Summary of Results**\n-   Variant I: $\\phi(x)$ is inserted at $B_3$.\n-   Variant II: $\\phi(x)$ is **not** inserted at $B_3$.\n-   Variant III: $\\phi(x)$ is inserted at $B_3$.\n\n### Option-by-Option Analysis\n\n**A. Pruned SSA inserts $\\phi(x)$ at $B_3$ in Variant I and Variant III, but not in Variant II, because $x$ is live at $B_3$ only in Variant I and Variant III.**\nThis statement perfectly matches our derived results. Our analysis shows that a $\\phi(x)$ is required in Variant I and Variant III, but not in Variant II. The reason provided, that $x$ is live at the entry of $B_3$ only in Variants I and III, is precisely the outcome of our liveness analysis.\n**Verdict: Correct**\n\n**B. Pruned SSA inserts $\\phi(x)$ at $B_3$ in all three variants, because $B_3$ lies in the dominance frontier of the definitions of $x$ regardless of liveness.**\nThis statement incorrectly claims that a $\\phi(x)$ is inserted in all three variants. Our analysis shows it is not inserted in Variant II. The reasoning provided describes the criterion for standard (non-pruned) SSA, but the problem explicitly concerns pruned SSA, which adds a liveness requirement. This option ignores the crucial \"pruned\" aspect.\n**Verdict: Incorrect**\n\n**C. Pruned SSA inserts $\\phi(x)$ at $B_3$ only if both $B_1$ and $B_2$ redefine $x$; with a redefinition on only one side, no $\\phi(x)$ is needed at $B_3$.**\nThis statement's reasoning is fundamentally flawed. A $\\phi$-function is needed precisely because multiple, different definitions reach a join point. In this CFG, the definition $x := 1$ from $B_1$ and the definition $x:=0$ from $B_0$ (via $B_2$) meet at $B_3$. This necessitates a merge. The claim that a redefinition on only one side means no $\\phi(x)$ is needed is the opposite of the truth.\n**Verdict: Incorrect**\n\n**D. Pruned SSA inserts $\\phi(x)$ at $B_3$ in Variant II, because there are two reaching definitions of $x$ at $B_3$ even if $x$ is immediately redefined in $B_3$.**\nThis statement incorrectly claims a $\\phi(x)$ is inserted in Variant II. The condition of having two reaching definitions is necessary but not sufficient for pruned SSA. The fact that \"$x$ is immediately redefined in $B_3$\" is precisely the reason why $x$ is not live-in at $B_3$, and thus the reason why the $\\phi(x)$ is **not** inserted. The logic presented is backwards.\n**Verdict: Incorrect**", "answer": "$$\\boxed{A}$$", "id": "3665069"}, {"introduction": "Our final practice tackles a critical nuance in liveness analysis that is essential for correctness. The standard definition of liveness is a \"may-analysis\": a variable is live if it might be used on *at least one* future path. This exercise presents a case where misinterpreting this as a \"must-analysis\" (used on *all* paths) leads to unsound pruning, and asks you to identify the principles that ensure a correct and robust pruned SSA form. [@problem_id:3665093]", "problem": "Consider the construction of pruned Static Single Assignment (SSA) form for a scalar variable $d$ in the control flow graph (CFG) of a function. The goal of pruned SSA is to insert $\\phi$-functions only at join points where they are actually needed, typically guided by liveness. Use the following fundamentals as the base for reasoning:\n- Backward liveness dataflow equations for a variable $x$ over a basic block $b$: \n  - $in[b] = use[b] \\cup (out[b] \\setminus def[b])$\n  - $out[b] = \\bigcup_{s \\in succ(b)} in[s]$\n- The SSA property that every use of a variable $x$ reads from exactly one dominating definition of the SSA name used at that point.\n- The standard characterization of $\\phi$-placement by the iterated dominance frontier, optionally pruned by liveness.\n\nYou are given the following CFG (block labels and constants are all program entities):\n- Block $B_0$: conditional branch to $B_1$ or $B_2$.\n- Block $B_1$: $d := 1$; unconditional branch to $B_3$.\n- Block $B_2$: $d := 2$; unconditional branch to $B_3$.\n- Block $B_3$: conditional branch on predicate $e$ to $B_4$ or $B_5$.\n- Block $B_4$: $r := d$; branch to $B_7$.\n- Block $B_5$: $d := 3$; branch to $B_6$.\n- Block $B_6$: $r := d$; branch to $B_7$.\n- Block $B_7$: return $r$.\n\nSuppose an implementer attempts to prune $\\phi$-functions by a flawed “all-successors” liveness filter at join blocks: they declare that a variable $x$ is live-in at a join block $b$ only if $x$ is live-in to every successor of $b$ (i.e., they use an intersection over successors instead of a union). They then use this test at $B_3$ to decide whether a $\\phi(d)$ is required there.\n\nTasks:\n1) Using only the fundamental dataflow equations above, determine whether $d$ is live-in at $B_3$ under the correct may-liveness semantics and whether it would be considered live-in under the flawed “all-successors” filter. Explain, in terms of $use(d)$ and $def(d)$ along the successors of $B_3$, why the flawed filter would drop a necessary $\\phi(d)$ at $B_3$ and how that violates the SSA property that $use(d) \\rightarrow def(d)$ paths are unique.\n2) Which of the following constraints, if adopted when pruning $\\phi$-functions, are sufficient to prevent the erroneous drop of $\\phi(d)$ at $B_3$ and thereby maintain the $use(d) \\rightarrow def(d)$ uniqueness property for $d$? Select all that apply.\n\nOptions:\nA. Define liveness with “may” reachability: $out[b] = \\bigcup_{s \\in succ(b)} in[s]$, so $x$ is live-in at a block $b$ if there exists at least one successor path from $b$ to a $use(x)$ with no intervening $def(x)$.\nB. Treat each $\\phi$ at block $X$ as a use of its operands on the corresponding incoming edges, i.e., for predecessor $p \\rightarrow X$, include the operand for $p$ in $out[p]$ when computing liveness, so edge-specific $use(x)$ by $\\phi$-arguments is respected.\nC. Require that $x$ be live-in at a join block $b$ only if $x$ is live-in to all successors of $b$ (intersection over successors), thereby ensuring that $x$ flows to both sides before any $\\phi(x)$ is placed at $b$.\nD. Skip liveness pruning altogether and place $\\phi$-functions for $d$ at all nodes in the iterated dominance frontier of each $def(d)$ (classical SSA), accepting more $\\phi$-functions in exchange for guaranteed correctness.\nE. Replace dominance-frontier-based placement by placing $\\phi$-functions only at blocks in the post-dominance frontier of $use(d)$, ensuring that all uses reconverge before any $\\phi(d)$ is inserted.\n\nAnswer format: Choose the correct option letter(s).", "solution": "The problem statement is scientifically grounded in compiler theory, specifically the construction of Static Single Assignment (SSA) form and dataflow analysis. The provided Control Flow Graph (CFG), dataflow equations, and definitions are self-contained, consistent, and well-posed. The scenario describes a plausible implementation flaw and asks for a rigorous analysis of its consequences and potential remedies. The problem is valid.\n\n### Task 1: Liveness Analysis and SSA Violation\n\nFirst, we analyze the liveness of the variable `$d$` in the given CFG. The standard backward may-liveness dataflow equations are:\n$$in[b] = use[b] \\cup (out[b] \\setminus def[b])$$\n$$out[b] = \\bigcup_{s \\in succ(b)} in[s]$$\n\nThe `use` and `def` sets for the variable `$d$` in each basic block `$b$` are as follows:\n- $def[B_1] = \\{d\\}$\n- $def[B_2] = \\{d\\}$\n- $def[B_5] = \\{d\\}$\n- $use[B_4] = \\{d\\}$\n- $use[B_6] = \\{d\\}$\n- All other `use` and `def` sets for `$d$` are empty. Specifically, $use[B_3] = \\emptyset$ and $def[B_3] = \\emptyset$.\n\nWe compute the liveness sets by iterating backwards from the exit block `$B_7$` until a fixed point is reached. We initialize all `$in$` and `$out$` sets to `$\\emptyset$`.\n\n**Liveness Calculation (Correct May-Liveness):**\n1.  The analysis starts at the end of the function. For block `$B_7$`, which has no successors, $out[B_7] = \\emptyset$. Since $use[B_7] = \\emptyset$ and $def[B_7] = \\emptyset$, we have $in[B_7] = \\emptyset$.\n2.  For `$B_4$`, $succ(B_4) = \\{B_7\\}$. So, $out[B_4] = in[B_7] = \\emptyset$. Then $in[B_4] = use[B_4] \\cup (out[B_4] \\setminus def[B_4]) = \\{d\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{d\\}$. So, `$d$` is live-in to `$B_4$`.\n3.  For `$B_6$`, $succ(B_6) = \\{B_7\\}$. So, $out[B_6] = in[B_7] = \\emptyset$. Then $in[B_6] = use[B_6] \\cup (out[B_6] \\setminus def[B_6]) = \\{d\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{d\\}$. So, `$d$` is live-in to `$B_6$`.\n4.  For `$B_5$`, $succ(B_5) = \\{B_6\\}$. So, $out[B_5] = in[B_6] = \\{d\\}$. Then $in[B_5] = use[B_5] \\cup (out[B_5] \\setminus def[B_5]) = \\emptyset \\cup (\\{d\\} \\setminus \\{d\\}) = \\emptyset$. So, `$d$` is not live-in to `$B_5$` because it is redefined there.\n5.  For `$B_3$`, $succ(B_3) = \\{B_4, B_5\\}$. Using the correct union-based equation: $out[B_3] = in[B_4] \\cup in[B_5] = \\{d\\} \\cup \\emptyset = \\{d\\}$. Since `$d$` is live-out of `$B_3$` and is not defined in `$B_3$`, it must be live-in: $in[B_3] = use[B_3] \\cup (out[B_3] \\setminus def[B_3]) = \\emptyset \\cup (\\{d\\} \\setminus \\emptyset) = \\{d\\}$.\n    - **Conclusion on correct liveness**: Under the standard definition, `$d$` **is** live-in at `$B_3$`.\n\n**Analysis with the Flawed \"All-Successors\" Filter:**\nThe flawed filter for pruning requires that a variable be live-in to *every* successor of a join block to be considered for a `$\\phi$`. At block `$B_3$`, this means checking if `$d$` is live-in at both `$B_4$` and `$B_5$`.\n- Is `$d$` live-in at `$B_4$`? Yes, $in[B_4] = \\{d\\}$.\n- Is `$d$` live-in at `$B_5$`? No, $in[B_5] = \\emptyset$.\nSince the condition is not met for all successors, the flawed filter concludes that `$d$` is not live-in at `$B_3$` for the purpose of placing a `$\\phi$`. This would lead to pruning the otherwise necessary `$\\phi$`.\n\n**Violation of SSA Property:**\nA `$\\phi$`-function is required at a join point when different definitions of the same variable reach that point. Block `$B_3$` is a join point where a definition of `$d$` from `$B_1$` (value `$1$`) and a definition of `$d$` from `$B_2$` (value `$2$`) both arrive. The path $B_3 \\rightarrow B_4$ leads to a use of `$d$` in `$B_4$` ($`r := d`$).\nWithout a `$\\phi$`, the use of `$d$` in `$B_4$` is reached by two distinct definitions: the one in `$B_1$` and the one in `$B_2$`. This violates the fundamental SSA property that every use of a variable must be dominated by a single definition. The flawed filter's failure to place a `$\\phi(d)$` at `$B_3$` directly causes this violation.\n\n### Task 2: Evaluation of Proposed Constraints\n\nWe now evaluate each option as a potential method to prevent this error.\n\n**A. Define liveness with “may” reachability: $out[b] = \\bigcup_{s \\in succ(b)} in[s]$, so $x$ is live-in at a block $b$ if there exists at least one successor path from $b$ to a $use(x)$ with no intervening $def(x)$.**\nThis option describes the standard may-liveness computation. The problem arises not from an incorrect definition of liveness, but from the flawed filter that uses this information improperly (intersection instead of union). If this option is interpreted as enforcing the use of the correct liveness test for pruning—namely, placing a `$\\phi(d)$` at join point `$B_3$` if `$d \\in in[B_3]$`—then it corrects the error. As we calculated, `$d \\in in[B_3]$` under this standard definition. Therefore, this strategy would place the required `$\\phi$-function at `$B_3$`, preventing the SSA violation.\n**Verdict: Correct**\n\n**B. Treat each $\\phi$ at block $X$ as a use of its operands on the corresponding incoming edges, i.e., for predecessor $p \\rightarrow X$, include the operand for $p$ in $out[p]$ when computing liveness, so edge-specific $use(x)$ by $\\phi$-arguments is respected.**\nThis option describes a more sophisticated approach to pruned SSA, often called \"pragmatic\" or \"live-`$\\phi$`\" analysis. The criterion for placing a `$\\phi$` is that the `$\\phi$` itself must be *live*. A `$\\phi$` is live if its result is used by some subsequent instruction or another `$\\phi$`. In this CFG, if a `$\\phi$`-function for `$d$` were placed at `$B_3$`, its result would be used by the instruction `$r := d$` in block `$B_4$`. Since the result has a use, the `$\\phi$` is live. A pruning strategy based on this principle would correctly decide to place the `$\\phi$` at `$B_3$`. This method is sufficient to prevent the error.\n**Verdict: Correct**\n\n**C. Require that $x$ be live-in at a join block $b$ only if $x$ is live-in to all successors of $b$ (intersection over successors), thereby ensuring that $x$ flows to both sides before any $\\phi(x)$ is placed at $b$.**\nThis option is a precise restatement of the flawed filter described in the problem statement. Adopting this constraint is what *causes* the erroneous pruning of the `$\\phi$`-function at `$B_3$`. It is the problem, not the solution.\n**Verdict: Incorrect**\n\n**D. Skip liveness pruning altogether and place $\\phi$-functions for $d$ at all nodes in the iterated dominance frontier of each $def(d)$ (classical SSA), accepting more $\\phi$-functions in exchange for guaranteed correctness.**\nThis describes the original, unpruned SSA construction algorithm (e.g., Cytron et al.). This algorithm places `$\\phi$`-functions based purely on the CFG structure, specifically at all nodes in the iterated dominance frontier (IDF) of the set of definition blocks. The blocks containing definitions of `$d$` are `$S = \\{B_1, B_2, B_5\\}$`. The dominance frontier of `$B_1$` and `$B_2$` is `$\\{B_3\\}$`. Thus, `$B_3$` is in `$IDF(S)$`. The classical algorithm would therefore place a `$\\phi$`-function for `$d$` at `$B_3$` regardless of liveness. This guarantees correctness and avoids the error introduced by flawed pruning.\n**Verdict: Correct**\n\n**E. Replace dominance-frontier-based placement by placing $\\phi$-functions only at blocks in the post-dominance frontier of $use(d)$, ensuring that all uses reconverge before any $\\phi(d)$ is inserted.**\nThis proposes a fundamentally different and incorrect algorithm for `$\\phi$`-placement. `$\\phi$`-functions are needed at points where control flow *merges* following multiple definitions; this is captured by the dominance frontier of definition sites. The post-dominance frontier relates to points where control flow *diverges* before reaching a common future block, and it is relevant for code motion optimizations (e.g., sinking), not for SSA construction. Applying this method would not correctly identify `$B_3$` as a required site for a `$\\phi$`.\n**Verdict: Incorrect**", "answer": "$$\\boxed{ABD}$$", "id": "3665093"}]}