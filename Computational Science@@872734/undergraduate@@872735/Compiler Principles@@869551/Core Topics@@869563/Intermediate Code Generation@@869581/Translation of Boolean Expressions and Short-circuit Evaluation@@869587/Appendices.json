{"hands_on_practices": [{"introduction": "Many modern programming languages, like Python, offer convenient syntax such as chained comparisons ($a \\lt b \\lt c$). A compiler must translate this into code that is not only logically correct but also efficient, avoiding the re-evaluation of shared operands like $b$. This first practice challenges you to generate such code using short-circuiting and then analyze its performance, providing a foundational look at how language features map to low-level control flow. [@problem_id:3677567]", "problem": "A compiler front-end targets a three-address intermediate representation with conditional and unconditional jumps and uses short-circuit evaluation for boolean expressions. The source language’s chained comparison semantics match those of Python: the expression $a  b  c  d$ is defined to be logically equivalent to $(a  b) \\land (b  c) \\land (c  d)$, with the following operational constraints: operands are evaluated from left to right, a middle operand such as $b$ or $c$ is evaluated exactly once and is reused in adjacent comparisons, and evaluation short-circuits as soon as the result is determined. Assume that evaluating an operand may have side effects, so recomputation of $b$ or $c$ is forbidden.\n\nTask:\n- Derive a short-circuit three-address code sequence that computes the boolean value of $a  b  c  d$ into a destination temporary $t_{\\mathrm{res}}$, where booleans are represented as $1$ (true) and $0$ (false). Your sequence must:\n  - Evaluate operands $a$, $b$, $c$, and $d$ strictly left to right, each at most once.\n  - Avoid recomputation of $b$ and $c$ by reusing temporaries.\n  - Use conditional branches to short-circuit on the first failing comparison.\n  - Set $t_{\\mathrm{res}}$ to $1$ if and only if the chained comparison holds, otherwise set $t_{\\mathrm{res}}$ to $0$, and then jump to a common exit label.\n\n- Under a cost model where evaluating each operand has zero cost, and each primitive comparison $x  y$ incurs unit cost, suppose the events $(a  b)$, $(b  c)$, and $(c  d)$ are independent with $\\Pr(a  b) = p_{ab}$, $\\Pr(b  c) = p_{bc}$, and $\\Pr(c  d) = p_{cd}$. Using the operational semantics above and your code structure, derive a closed-form analytic expression for the expected number of primitive comparisons executed as a function of $p_{ab}$, $p_{bc}$, and $p_{cd}$. Provide this expression as your final answer. No rounding is required.", "solution": "The problem is valid as it is scientifically grounded in the principles of compiler design, well-posed with sufficient and consistent information, and objectively stated. It presents a formalizable task with a unique, derivable solution.\n\nThe task consists of two parts. First, to derive a three-address code sequence for the chained comparison $a  b  c  d$ under specific operational semantics. Second, to calculate the expected number of primitive comparisons executed based on a given probabilistic model.\n\n### Part 1: Three-Address Code Generation\n\nThe expression $a  b  c  d$ is equivalent to $(a  b) \\land (b  c) \\land (c  d)$. The operational semantics require short-circuit evaluation, left-to-right operand evaluation, and single evaluation of shared operands ($b$ and $c$). We can achieve this using conditional branches. If any comparison in the conjunction fails, the entire expression is false, and we can immediately jump to a location that handles the false case.\n\nLet $t_{\\mathrm{res}}$ be the destination temporary that holds the result, with $1$ representing true and $0$ representing false. The evaluation of operands $a, b, c, d$ may have side effects, so they must be evaluated in order and exactly once. We can store their values in temporary variables $t_a, t_b, t_c, t_d$, although for brevity in the final code, we can use the operands directly assuming the three-address code evaluator handles the required single evaluation. The key is the control flow.\n\nA suitable three-address code sequence is as follows. We define two labels: `L_false` for the case where the expression evaluates to false, and `L_end` for a common exit point.\n\n1.  Evaluate the first comparison, $a  b$. If it is false, the entire expression is false.\n    `if a  b goto L1`\n    `goto L_false`\n\n2.  `L1:` Evaluate the second comparison, $b  c$. This reuses the operand $b$. If it is false, the expression is false.\n    `if b  c goto L2`\n    `goto L_false`\n\n3.  `L2:` Evaluate the third comparison, $c  d$. This reuses the operand $c$. If it is false, the expression is false.\n    `if c  d goto L_true`\n    `goto L_false`\n\n4.  `L_true:` If control reaches this point, all comparisons have succeeded. The expression is true.\n    `t_res = 1`\n    `goto L_end`\n\n5.  `L_false:` If any comparison fails, control jumps here. The expression is false.\n    `t_res = 0`\n\n6.  `L_end:` Common exit point for subsequent code.\n\nThis sequence can be written more compactly, which is typical for intermediate representations:\n\n`if not (a  b) goto L_false`\n`if not (b  c) goto L_false`\n`if not (c  d) goto L_false`\n`t_res = 1`\n`goto L_end`\n`L_false: t_res = 0`\n`L_end: ...`\n\nThis structure correctly implements the specified short-circuiting semantics. The comparisons $(a  b)$, $(b  c)$, and $(c  d)$ are executed sequentially, and evaluation stops at the first one that returns false.\n\n### Part 2: Expected Number of Comparisons\n\nLet $N$ be the random variable representing the number of primitive comparisons executed. The cost model assigns a cost of $1$ to each comparison and $0$ to operand evaluation. We are given the probabilities of each comparison being true as independent events: $\\Pr(a  b) = p_{ab}$, $\\Pr(b  c) = p_{bc}$, and $\\Pr(c  d) = p_{cd}$.\n\nWe can determine the expected value of $N$, denoted $E[N]$, by using the linearity of expectation. Let $I_k$ be an indicator random variable for the event that the $k$-th comparison is executed.\n-   $I_1 = 1$ if the comparison $(a  b)$ is executed, and $I_1 = 0$ otherwise.\n-   $I_2 = 1$ if the comparison $(b  c)$ is executed, and $I_2 = 0$ otherwise.\n-   $I_3 = 1$ if the comparison $(c  d)$ is executed, and $I_3 = 0$ otherwise.\n\nThe total number of comparisons is $N = I_1 + I_2 + I_3$.\nBy the linearity of expectation, $E[N] = E[I_1] + E[I_2] + E[I_3]$. The expectation of an indicator variable is the probability of the event it indicates, so $E[I_k] = \\Pr(I_k = 1)$.\n\n1.  **Expected value of $I_1$**: The first comparison, $(a  b)$, is always executed. Therefore, the probability of it being executed is $1$.\n    $$E[I_1] = \\Pr(I_1 = 1) = 1$$\n\n2.  **Expected value of $I_2$**: The second comparison, $(b  c)$, is executed only if the first comparison, $(a  b)$, evaluates to true. Due to the short-circuit rule, if $(a  b)$ is false, the evaluation terminates.\n    $$E[I_2] = \\Pr(I_2 = 1) = \\Pr(a  b) = p_{ab}$$\n\n3.  **Expected value of $I_3$**: The third comparison, $(c  d)$, is executed only if both the first comparison, $(a  b)$, and the second comparison, $(b  c)$, evaluate to true.\n    $$E[I_3] = \\Pr(I_3 = 1) = \\Pr((a  b) \\land (b  c))$$\n    Since the events are given to be independent, we can multiply their probabilities:\n    $$\\Pr((a  b) \\land (b  c)) = \\Pr(a  b) \\cdot \\Pr(b  c) = p_{ab} p_{bc}$$\n    Thus,\n    $$E[I_3] = p_{ab} p_{bc}$$\n\nThe total expected number of comparisons is the sum of these expectations:\n$$E[N] = E[I_1] + E[I_2] + E[I_3]$$\n$$E[N] = 1 + p_{ab} + p_{ab}p_{bc}$$\n\nThis is the closed-form analytic expression for the expected number of comparisons. It is noteworthy that the probability $p_{cd}$ does not appear in the expression. This is correct, as the *number* of comparisons performed depends only on the outcomes of the first two comparisons, not the third. The third comparison, if reached, is always executed regardless of its outcome. The value of $p_{cd}$ would be relevant for calculating the probability of the entire expression being true, but not for the expected number of evaluation steps under this cost model.", "answer": "$$\\boxed{1 + p_{ab} + p_{ab}p_{bc}}$$", "id": "3677567"}, {"introduction": "Moving beyond the control-flow graph, we now explore the mechanics of *how* a compiler generates this structure, specifically using the backpatching technique. Backpatching defers the resolution of jump targets by managing lists of unresolved branches. This exercise contrasts two strategies for compiling a negated expression, demonstrating how an elegant implementation detail—swapping the true and false lists—can be more efficient than a more literal translation. [@problem_id:3677573]", "problem": "Consider an imperative language translated to Intermediate Representation (IR), where boolean expressions are compiled using short-circuit evaluation and the backpatching method. In this method, each boolean subexpression is represented by two lists of forward branches, a true list and a false list, denoted by $TL(\\cdot)$ and $FL(\\cdot)$, respectively. Each element in these lists is one unresolved branch that will later be backpatched to a concrete label when control destinations become known. A backpatch operation is defined as the act of filling one unresolved branch target with a concrete label; each unresolved jump counts as one backpatch operation when it is resolved.\n\nYou are to translate a statement of the form $if (!(A \\wedge B))$ using short-circuit evaluation. Two strategies are considered:\n\n- Strategy $\\mathsf{Swap}$: Translate $A \\wedge B$ using short-circuit control flow and implement logical negation by flipping the true and false lists of the resulting expression, without introducing any additional IR nodes or branch instructions for the negation.\n\n- Strategy $\\mathsf{NegNode}$: Translate $A \\wedge B$ to produce code with explicit temporary true and false labels for the conjunction’s outcome, then materialize the logical negation as a separate IR node that, at those temporary labels, emits forward branches to the final then and else destinations. The final then/else destinations are not known at the time the negation node is emitted, so these two branches are forward branches that must be backpatched later.\n\nAssume the following properties of the subexpressions $A$ and $B$, based on their internal structure and the standard short-circuit translation of relational atoms into $if \\cdots goto L_{true}; goto L_{false}$ form:\n\n- $|TL(A)| = 3$, $|FL(A)| = 2$.\n- $|TL(B)| = 4$, $|FL(B)| = 3$.\n\nUnder short-circuit evaluation of $A \\wedge B$, evaluating $B$ occurs only when $A$ evaluates to true, which implies that all entries in $TL(A)$ must be backpatched to the entry label of $B$. After building the conjunction, $TL(A \\wedge B)$ is the set of forward branches that reach the overall true outcome of the conjunction, and $FL(A \\wedge B)$ is the set that reach the overall false outcome.\n\nUsing the definitions above and these cardinalities, compute the total number of backpatch operations required for Strategy $\\mathsf{Swap}$ and Strategy $\\mathsf{NegNode}$, and then compute the savings (defined as the number of backpatch operations in Strategy $\\mathsf{NegNode}$ minus the number in Strategy $\\mathsf{Swap}$). Express your final answer as a single integer with no units. No rounding is needed; report the exact integer.", "solution": "The problem requires an analysis of the total number of backpatch operations for two different compiler strategies for translating the statement `if (!(A \\wedge B))`. A backpatch operation is defined as the resolution of a single unresolved forward branch. Therefore, the total number of backpatch operations is equivalent to the total number of unresolved forward branches created and resolved during the compilation process.\n\nFirst, we establish the semantics of short-circuit evaluation for a conjunction $E = A \\wedge B$. The control flow dictates that $B$ is evaluated only if $A$ is true. If $A$ is false, the entire expression is false.\n1.  The branches in the true list of $A$, $TL(A)$, must be resolved to target the entry point of the code for subexpression $B$. This constitutes a set of backpatch operations, numbering $|TL(A)|$.\n2.  The true list for the combined expression $E$, $TL(E)$, consists of only those branches that make the entire expression true. This occurs only if both $A$ and $B$ are true. Thus, $TL(A \\wedge B) = TL(B)$.\n3.  The false list for the combined expression $E$, $FL(E)$, consists of any branch that makes the expression false. This occurs if $A$ is false, or if $A$ is true and $B$ is false. Thus, $FL(A \\wedge B)$ is the union of the false lists of its components: $FL(A \\wedge B) = FL(A) \\cup FL(B)$. The subexpressions $A$ and $B$ are distinct, so their lists of jumps are disjoint. The cardinality is $|FL(A \\wedge B)| = |FL(A)| + |FL(B)|$.\n\nThe given cardinalities for the subexpressions are:\n- $|TL(A)| = 3$\n- $|FL(A)| = 2$\n- $|TL(B)| = 4$\n- $|FL(B)| = 3$\n\nThe total number of unresolved branches originating from the atomic translation of $A$ and $B$ is $|TL(A)| + |FL(A)| + |TL(B)| + |FL(B)| = 3 + 2 + 4 + 3 = 12$.\n\nWe now analyze each strategy.\n\n**Strategy $\\mathsf{Swap}$**\n\nThis strategy first computes the lists for $A \\wedge B$ and then swaps them to implement the logical negation.\n1.  **Code Generation:** The translation of subexpressions $A$ and $B$ introduces a total of $12$ unresolved branches, as calculated above. The $\\mathsf{Swap}$ strategy does not introduce any new branches; it only re-purposes the existing ones. Therefore, the total number of backpatch operations must be exactly $12$. We can verify this by tracing their resolution.\n2.  **Internal Backpatching:** To form the code for $A \\wedge B$, the branches in $TL(A)$ are backpatched to the beginning of the code for $B$. This requires $|TL(A)| = 3$ backpatch operations.\n3.  **Final List Resolution:** The `if` statement evaluates the condition $C = !(A \\wedge B)$.\n    - The true list for $C$, $TL(C)$, is obtained by swapping, so $TL(C) = FL(A \\wedge B) = FL(A) \\cup FL(B)$. These branches are backpatched to the `then` clause. The number of operations is $|FL(A)| + |FL(B)| = 2 + 3 = 5$.\n    - The false list for $C$, $FL(C)$, is similarly $FL(C) = TL(A \\wedge B) = TL(B)$. These branches are backpatched to the `else` clause. The number of operations is $|TL(B)| = 4$.\n4.  **Total Operations:** The total number of backpatch operations for Strategy $\\mathsf{Swap}$, denoted $N_{\\mathsf{Swap}}$, is the sum of all resolved branches.\n    $$N_{\\mathsf{Swap}} = |TL(A)| + (|FL(A)| + |FL(B)|) + |TL(B)|$$\n    $$N_{\\mathsf{Swap}} = 3 + (2 + 3) + 4 = 3 + 5 + 4 = 12$$\n    This confirms that all $12$ initial unresolved branches are resolved.\n\n**Strategy $\\mathsf{NegNode}$**\n\nThis strategy first resolves the true and false outcomes of $A \\wedge B$ to temporary labels and then generates new branches for the negation.\n1.  **Code Generation and Internal Resolution:** As before, translating $A$ and $B$ creates $12$ initial unresolved branches. This strategy resolves all of them internally and then creates new ones.\n    - Backpatching $TL(A)$ to the entry of $B$: $|TL(A)| = 3$ operations.\n    - The lists for $A \\wedge B$ are $TL(A \\wedge B)=TL(B)$ and $FL(A \\wedge B)=FL(A) \\cup FL(B)$.\n    - Backpatching $TL(A \\wedge B)$ to a temporary true label $L_{true\\_temp}$: $|TL(B)| = 4$ operations.\n    - Backpatching $FL(A \\wedge B)$ to a temporary false label $L_{false\\_temp}$: $|FL(A)| + |FL(B)| = 2 + 3 = 5$ operations.\n    - At this point, all $3 + 4 + 5 = 12$ of the original unresolved branches have been backpatched.\n2.  **Negation Node Generation:** The `NegNode` itself generates new code and new unresolved branches at the temporary labels.\n    - At $L_{true\\_temp}$ (where $A \\wedge B$ is true), the negation `!` makes the outcome false. A new branch `goto L_final_else` is created. This is $1$ new unresolved branch.\n    - At $L_{false\\_temp}$ (where $A \\wedge B$ is false), the negation `!` makes the outcome true. A new branch `goto L_final_true` is created. This is a $2^{nd}$ new unresolved branch.\n3.  **Final List Resolution:** These two new branches form the final true and false lists for the condition $C = !(A \\wedge B)$.\n    - $TL(C)$ contains the one branch to `L_final_true`. Backpatching this to the `then` clause requires $1$ operation.\n    - $FL(C)$ contains the one branch to `L_final_false`. Backpatching this to the `else` clause requires $1$ operation.\n4.  **Total Operations:** The total number of backpatch operations for Strategy $\\mathsf{NegNode}$, $N_{\\mathsf{NegNode}}$, is the sum of operations for resolving the initial branches and the newly generated branches.\n    $$N_{\\mathsf{NegNode}} = (\\text{ops for initial branches}) + (\\text{ops for new branches})$$\n    $$N_{\\mathsf{NegNode}} = (|TL(A)| + |TL(B)| + |FL(A)| + |FL(B)|) + 2$$\n    $$N_{\\mathsf{NegNode}} = (3 + 4 + 2 + 3) + 2 = 12 + 2 = 14$$\n\n**Calculation of Savings**\n\nThe problem defines savings as the number of backpatch operations in Strategy $\\mathsf{NegNode}$ minus the number in Strategy $\\mathsf{Swap}$.\n$$Savings = N_{\\mathsf{NegNode}} - N_{\\mathsf{Swap}}$$\n$$Savings = 14 - 12 = 2$$\nThe $\\mathsf{NegNode}$ strategy requires $2$ more backpatch operations than the $\\mathsf{Swap}$ strategy, resulting in a saving of $2$ for the latter over the former.", "answer": "$$\\boxed{2}$$", "id": "3677573"}, {"introduction": "Short-circuit evaluation is not merely an optimization; it is a critical feature for writing safe and correct code. This is most evident in loops that perform bounds-checking before accessing an array, a pattern this exercise explores. You will translate a `while` loop condition that relies on short-circuiting to prevent an out-of-bounds memory access, and then apply probabilistic analysis to calculate the expected number of array reads, connecting compiler theory directly to program safety and performance. [@problem_id:3677647]", "problem": "A compiler backend must translate the loop condition in the high-level statement\nwhile ((i  n)  a[i] != 0) { i := i + 1; }\ninto low-level control-flow that respects short-circuit evaluation, meaning the second conjunct is evaluated only if the first conjunct evaluates to true. Use the standard control-flow-oriented translation of boolean expressions into Three-Address Code (TAC) with explicit labels, ensuring that the bound check $i  n$ is always performed before the array access $a[i]$. Then, extend this translation to the canonicalized form of the equivalent for-loop:\nfor (i := i_0; (i  n)  (a[i] \\neq 0); i := i + 1) { /* empty body */ }\nwhere $i_0$ is the given initial value of $i$ and $0 \\le i_0 \\le n$.\n\nAssume the following probabilistic model of program inputs for the canonicalized for-loop:\n- The array segment $a[i_0], a[i_0+1], \\dots, a[n-1]$ consists of independent elements.\n- For each index $j \\in \\{i_0, i_0+1, \\dots, n-1\\}$, the event $a[j] = 0$ occurs with probability $p$, where $p \\in (0,1]$, and $a[j] \\neq 0$ otherwise.\n\nUnder this model, the translated TAC executes the test sequence in each iteration in short-circuit fashion: it checks $i  n$ first; only if true does it read and compare $a[i]$. Let $X$ be the random variable equal to the total number of array reads of the form $a[i]$ performed by this TAC until the loop exits.\n\nUsing only fundamental definitions of short-circuit evaluation and the semantics of TAC-generated control flow, together with the definition of mathematical expectation for a nonnegative, integer-valued random variable, derive a closed-form analytic expression for the expected value $\\mathbb{E}[X]$ as a function of $n$, $i_0$, and $p$. Express your final answer in simplest closed form. No rounding is required.", "solution": "The problem requires the derivation of the expected number of array reads for a loop with a short-circuiting condition, based on a probabilistic model of the array's contents. We begin by formalizing the control flow semantics implied by the problem statement and then proceed to the probabilistic analysis.\n\nFirst, we analyze the control flow generated for the boolean expression `(i  n)  (a[i] != 0)`. The `` operator implies short-circuit evaluation, meaning the second operand `a[i] != 0` is evaluated only if the first operand `i  n` is true. In a standard translation to Three-Address Code (TAC), this is implemented using conditional jumps. For a `while` loop of the form `while (B1  B2) S`, the structure is as follows:\n\n`L_loop:`\n`  if not B1 goto L_exit`\n`  if not B2 goto L_exit`\n`  S`\n`  goto L_loop`\n`L_exit:`\n\nApplying this to the specific problem, with `B1` as `$i  n$` and `B2` as `$a[i] \\neq 0$`, and the body `S` as `$i := i + 1$`, the TAC would be:\n`L_loop:`\n`  t1 := i  n`\n`  if t1 = 0 goto L_exit`\n`  t2 := a[i]       ; Array read occurs here`\n`  t3 := t2 != 0`\n`  if t3 = 0 goto L_exit`\n`  i := i + 1`\n`  goto L_loop`\n`L_exit:`\n\nThis control flow explicitly confirms that the array access `a[i]` occurs only if the condition `$i  n$` is satisfied. This is the crucial semantic property we will use. The given `for`-loop is equivalent to an initialization `$i := i_0$` followed by this `while` loop structure.\n\nLet `$X$` be the random variable representing the total number of array reads. An array read takes the form `$a[i]$`. According to the control flow, an array read occurs during an iteration with a given value of `$i$` if and only if the test `$i  n$` evaluates to true. The loop starts with `$i = i_0$` and increments `$i$` in each successful iteration. The loop can potentially run for values of `$i$` from `$i_0$` up to `$n-1$`. If `$i$` reaches `$n$`, the condition `$i  n$` becomes false, and the loop terminates without an array read for that value of `$i$`.\n\nWe need to calculate the expected value of `$X$`, denoted `$\\mathbb{E}[X]$`. Since `$X$` is a non-negative, integer-valued random variable, its expectation can be calculated using the tail-sum formula:\n$$ \\mathbb{E}[X] = \\sum_{k=1}^{\\infty} P(X \\ge k) $$\nThe number of array reads cannot exceed the number of possible values of `$i$` for which a read could occur, which is `$n - i_0$` (for `$i = i_0, i_0+1, \\dots, n-1$`). Therefore, the maximum value of `$X$` is `$n-i_0$`, and the sum is finite:\n$$ \\mathbb{E}[X] = \\sum_{k=1}^{n-i_0} P(X \\ge k) $$\nNote that if `$i_0 \\ge n$`, the range of summation is empty, correctly yielding `$\\mathbb{E}[X] = 0$`, as the loop condition `$i  n$` is false initially. We will assume `$i_0  n$` for the main derivation.\n\nLet's determine the probability `$P(X \\ge k)$` for an integer `$k$` where `$1 \\le k \\le n-i_0$`. The event `$X \\ge k$` means that at least `$k$` array reads are performed. The first read is `$a[i_0]`, the second is `$a[i_0+1]`, and the `$k$`-th read is `$a[i_0+k-1]$`.\nFor the `$k$`-th read (of `$a[i_0+k-1]`) to occur, two conditions must be met:\n1. The loop must not have terminated in any of the previous iterations for `$i = i_0, i_0+1, \\dots, i_0+k-2$`. This requires that the second part of the loop condition, `$a[i] \\neq 0$`, was true for all these values of `$i$`.\n2. The bounds check `$i  n$` must pass for the current iteration, i.e., `$i_0+k-1  n$`. This is guaranteed by our summation limit `$k \\le n-i_0$`.\n\nThe condition for the `$k$`-th read to happen is thus `$a[j] \\neq 0$` for all `$j \\in \\{i_0, i_0+1, \\dots, i_0+k-2\\}$`. The probabilistic model states that for any `$j$`, `$P(a[j] \\neq 0) = 1 - p$`, and the events are independent. Therefore, the probability of this sequence of `$k-1$` events is:\n$$ P(X \\ge k) = \\prod_{j=i_0}^{i_0+k-2} P(a[j] \\neq 0) = (1-p)^{k-1} $$\nThis holds for `$1 \\le k \\le n-i_0$`. For `$k=1$`, the product is over an empty set, which is `$1$`, so `$P(X \\ge 1) = (1-p)^0 = 1$`, which is correct as `$a[i_0]$` is always read if `$i_0n$`.\n\nNow we can substitute this back into the formula for the expectation:\n$$ \\mathbb{E}[X] = \\sum_{k=1}^{n-i_0} (1-p)^{k-1} $$\nThis is a finite geometric series. Let's perform a change of index by setting `$j = k-1$`. When `$k=1$`, `$j=0$`. When `$k=n-i_0$`, `$j=n-i_0-1$`.\nThe sum becomes:\n$$ \\mathbb{E}[X] = \\sum_{j=0}^{n-i_0-1} (1-p)^j $$\nLet `$r = 1-p$`. The sum is `$\\sum_{j=0}^{N} r^j$` where `$N = n-i_0-1$`. The number of terms is `$N+1 = n-i_0$`.\n\nWe analyze two cases for the value of `$p \\in (0,1]$`.\n\nCase 1: `$p=1$`.\nIn this case, `$r = 1-p = 0$`. The sum becomes:\n$$ \\mathbb{E}[X] = \\sum_{j=0}^{n-i_0-1} 0^j = 0^0 + 0^1 + 0^2 + \\dots $$\nBy convention, `$0^0=1$`. All other terms are `$0$`. Thus, if `$n-i_0-1 \\ge 0$` (i.e. `$ni_0$`), the sum is `$1$`. If `$n \\le i_0$`, the sum is empty and equals `$0$`. This aligns with the physical situation: if `$p=1$`, the first array element read, `$a[i_0]$`, will be `$0$` with certainty, causing the loop to terminate. Thus, exactly one read occurs if the loop starts (`$i_0n$`), and zero reads occur otherwise.\n\nCase 2: `$p \\in (0,1)$`.\nIn this case, `$r = 1-p \\in (0,1)` and is not equal to `$1$`. We can use the standard formula for a finite geometric series: `$\\sum_{j=0}^{N} r^j = \\frac{1-r^{N+1}}{1-r}$`.\nSubstituting `$r=1-p$` and `$N+1 = n-i_0$`:\n$$ \\mathbb{E}[X] = \\frac{1 - (1-p)^{n-i_0}}{1 - (1-p)} = \\frac{1 - (1-p)^{n-i_0}}{p} $$\n\nThis single expression also correctly handles the edge cases.\n- If `$p=1$`, and `$i_0  n$`, the expression gives `$\\frac{1 - (0)^{n-i_0}}{1} = 1$`.\n- If `$i_0 = n$`, the exponent `$n-i_0 = 0$`, and the expression becomes `$\\frac{1-(1-p)^0}{p} = \\frac{1-1}{p} = 0$`.\nBoth results match our analysis. Thus, the derived expression is valid for all `$p \\in (0,1]$` and `$0 \\le i_0 \\le n$`.\n\nThe expression is in its simplest closed form.", "answer": "$$ \\boxed{\\frac{1 - (1-p)^{n-i_0}}{p}} $$", "id": "3677647"}]}