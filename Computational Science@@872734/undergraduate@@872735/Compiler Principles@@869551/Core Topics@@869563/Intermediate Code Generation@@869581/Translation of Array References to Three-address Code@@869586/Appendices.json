{"hands_on_practices": [{"introduction": "The journey into array address translation begins with the fundamental building block: the affine address formula. While many programming languages use zero-based indexing, a robust compiler must handle arrays with arbitrary lower bounds. This first practice [@problem_id:3677213] focuses on this core skill, guiding you to translate an access to a one-dimensional array with a negative lower bound into a clean sequence of three-address code instructions.", "problem": "In a conventional compiler intermediate representation, three-address code ($3$AC) is used to translate array references into explicit address computations guided by a standard memory model. Consider a one-dimensional array $A$ with lower and upper bounds $-5$ and $5$, written as $A[-5..5]$, whose elements occupy $w$ bytes each and are laid out contiguously in memory. Let $B$ denote the machine address of the first element $A[-5]$. A high-level program computes an index at run time as $i := t - 2$, where $t$ is an integer variable, and then references $A[i]$.\n\nUse the following fundamental base:\n- A one-dimensional array is stored contiguously so that successive elements differ in address by the element width $w$.\n- The base address $B$ points to the element at the lower bound index, here $A[-5]$.\n- To reference $A[i]$, the compiler must compute the number of elements between the lower-bound element and the target element, convert that count to a byte displacement by scaling with $w$, and add the result to $B$ to obtain the effective address.\n\nDerive the three-address code (3AC) sequence that correctly handles the negative lower bound by first offsetting the logical index $i$ to a zero-based displacement (i.e., add $+5$ before scaling) and then computes the effective address. From that derivation, simplify the effective-address computation to a single closed-form algebraic expression for the address $E$ of $A[i]$ in terms of $B$, $w$, and $t$.\n\nProvide only the simplified algebraic expression for $E$ as your final answer. No rounding is required.", "solution": "The problem as stated is valid. It is a well-posed problem within the domain of compiler design, specifically concerning intermediate code generation for array addressing. All necessary parameters and definitions are provided, and the problem is free of scientific inaccuracies, contradictions, and ambiguities.\n\nThe task is to derive the three-address code ($3$AC) for an array access and then simplify the underlying calculation into a single algebraic expression for the effective memory address.\n\nFirst, let us establish the fundamental formula for calculating the address of an element in a one-dimensional array. For an array declared as `Array[low..high]`, where `low` is the lower index bound, the memory address of an element `Array[i]` is given by:\n$$\n\\text{Address}(\\text{Array}[i]) = \\text{BaseAddress} + (i - \\text{low}) \\times w\n$$\nwhere `BaseAddress` is the memory address of the first element `Array[low]`, and `$w$` is the width (in bytes) of each element in the array.\n\nIn the given problem, we have the array `$A[-5..5]$`. The givens are:\n- Lower bound, `low` $= -5$.\n- Upper bound, `high` $= 5$.\n- Element width is `$w$`.\n- Base address is `$B$`, defined as the address of the first element, `$A[-5]$`.\n- The index `$i$` is computed at runtime as `$i := t - 2$`, where `$t$` is an integer variable.\n\nThe problem requires a specific derivation path using three-address code. The high-level operation is to compute the effective address `$E$` of the element `$A[i]$`.\n\nThe sequence of operations to compute the effective address `$E$` of `$A[i]$` can be broken down into a sequence of three-address instructions. We use temporary variables `$t_1, t_2, \\dots$` to hold intermediate results.\n\n1.  First, compute the value of the index `$i$` from the variable `$t$`.\n    $$t_1 = t - 2$$\n    Here, the temporary variable `$t_1$` holds the value of `$i$`.\n\n2.  Next, compute the zero-based displacement from the start of the array. The array starts at index `$-5$`. The number of elements between the start (`$A[-5]$`) and the target element `$A[i]$` (or `$A[t_1]$`) is given by `$i - \\text{low} = t_1 - (-5) = t_1 + 5$`. The problem statement explicitly says to \"add $+5$ before scaling\".\n    $$t_2 = t_1 + 5$$\n    Here, `$t_2$` represents the zero-based offset of the element, i.e., its position if the array were indexed from `$0$`.\n\n3.  Then, this zero-based offset must be scaled by the element width `$w$` to obtain the byte offset from the base address `$B$`.\n    $$t_3 = t_2 \\times w$$\n    Here, `$t_3$` is the total byte displacement from the beginning of the array.\n\n4.  Finally, the effective address `$E$` is obtained by adding this byte offset `$t_3$` to the base address `$B$`.\n    $$E = B + t_3$$\n\nThis completes the derivation of the three-address code sequence. To find the simplified, single closed-form algebraic expression for `$E$`, we perform back-substitution on these intermediate steps.\n\nStarting with the final expression for `$E$`:\n$$E = B + t_3$$\n\nSubstitute the expression for `$t_3$`:\n$$E = B + (t_2 \\times w)$$\n\nSubstitute the expression for `$t_2$`:\n$$E = B + ((t_1 + 5) \\times w)$$\n\nSubstitute the expression for `$t_1$`:\n$$E = B + (((t - 2) + 5) \\times w)$$\n\nNow, we simplify the expression inside the parentheses:\n$$E = B + ((t + 3) \\times w)$$\n\nThis can be written more cleanly as:\n$$E = B + w(t + 3)$$\n\nThis final expression represents the effective address `$E]` of the element `$A[t-2]$` in terms of the base address `$B$`, the element width `$w$`, and the runtime variable `$t$`. This result correctly incorporates the negative lower bound of the array by calculating the proper offset from the base address.", "answer": "$$\\boxed{B + w(t + 3)}$$", "id": "3677213"}, {"introduction": "Real-world programs often involve complex, nested data structures. This practice builds upon the basics by tackling a nested array access, $A[B[i]]$, a common pattern in many algorithms. The exercise [@problem_id:3677330] requires you to carefully sequence the address calculation, explicitly modeling the crucial distinction between computing a memory address and loading the value stored at that address, a key concept in intermediate code generation.", "problem": "Consider a standard compilation setting for arrays with zero-based indexing on a byte-addressed machine. The following fundamental bases apply:\n\n- The linear address of an array element is given by $ \\mathrm{addr}(X[k]) = \\mathrm{base}(X) + k \\cdot \\mathrm{size}(X) $, where $ \\mathrm{base}(X) $ is the arrayâ€™s base address in bytes, $ k $ is the zero-based index, and $ \\mathrm{size}(X) $ is the element size in bytes.\n- Three-Address Code (TAC) is an intermediate representation where each statement has at most three operands and performs one operation, such as $ t := a \\ \\text{op} \\ b $, $ t := \\mathrm{mem}[\\alpha] $, or $ \\mathrm{mem}[\\alpha] := t $. TAC is used to sequence computations and explicitly model memory loads and stores.\n\nYou are to translate the nested array reference $ A[B[i]] $ into TAC that safely sequences the computation of the inner index and the outer address and minimizes memory loads by reusing temporaries rather than recomputing subexpressions. Assume the following concrete scenario with compile-time known layout metadata:\n\n- Array $ A $ has base address $ A_0 = 4096 $, element size $ s_A = 8 $, and length $ n_A = 100 $.\n- Array $ B $ has base address $ B_0 = 2048 $, element size $ s_B = 4 $, and length $ n_B = 64 $.\n- The runtime index is $ i = 11 $.\n- The memory content at the position $ B[i] $ is the integer $ 17 $, i.e., $ B[11] = 17 $.\n\nAssume bounds metadata $ n_A $ and $ n_B $ are compile-time constants available to the code generator, and base addresses $ A_0 $ and $ B_0 $ are also compile-time constants; therefore, using them does not incur any memory loads. Model memory loads explicitly as $ t := \\mathrm{mem}[\\alpha] $ where $ \\alpha $ is a computed byte address.\n\nDerive TAC that:\n- Computes the address of $ B[i] $,\n- Loads the value $ j = B[i] $ once and reuses it as a temporary for the outer access,\n- Computes the address of $ A[j] $ without reloading $ B[i] $ or recomputing the inner address.\n\nAfter deriving your TAC, compute the final byte address of the outer access $ \\mathrm{addr}(A[B[i]]) $ using the provided numeric data. Provide the final answer as a single real-valued number representing the byte address. No rounding is necessary. Express the final answer without units in your final boxed output.", "solution": "The problem has been validated and is deemed valid. It is a well-posed, scientifically grounded problem within the domain of compiler principles, with a complete and consistent set of givens. All necessary data for translating the array reference to three-address code and computing the final address are provided.\n\nThe primary task is to translate the nested array reference $A[B[i]]$ into a sequence of three-address code (TAC) instructions and then compute the final memory address using the provided numerical data. The evaluation must proceed from the innermost expression outwards.\n\nFirst, we must determine the value of the inner index, which is given by the expression $B[i]$. This involves two steps:\n1.  Compute the memory address of the element $B[i]$.\n2.  Load the value from that memory address.\n\nThe address of an element $X[k]$ is given by the formula $\\mathrm{addr}(X[k]) = \\mathrm{base}(X) + k \\cdot \\mathrm{size}(X)$. For the inner array access $B[i]$, the base address is $B_0$, the index is $i$, and the element size is $s_B$. Thus, the address of $B[i]$ is:\n$$ \\mathrm{addr}(B[i]) = B_0 + i \\cdot s_B $$\n\nLet's represent this computation in TAC. We use temporary variables, denoted as $t_n$, to hold intermediate results.\n1.  Calculate the offset in bytes: $t_0 := i \\cdot s_B$.\n2.  Calculate the full address of $B[i]$: $t_1 := B_0 + t_0$.\n\nWith the address computed and stored in $t_1$, the next step is to load the value from this memory location. This value will serve as the index for the outer array $A$. Let's call this value $j$, as suggested by the problem statement.\n3.  Load the value: $j := \\mathrm{mem}[t_1]$.\n\nNow that we have the value of the inner index $j = B[i]$, we can proceed to the outer array access, $A[j]$. The address of this element is given by the same general formula:\n$$ \\mathrm{addr}(A[j]) = A_0 + j \\cdot s_A $$\n\nThis computation is also translated into TAC, reusing the temporary $j$ that holds the value of $B[i]$, thereby avoiding a second memory load.\n4.  Calculate the offset for the outer array: $t_2 := j \\cdot s_A$.\n5.  Calculate the final address of $A[B[i]]$: $t_3 := A_0 + t_2$.\n\nThe variable $t_3$ now holds the final target byte address. The complete TAC sequence is:\n1.  $t_0 := i \\cdot s_B$\n2.  $t_1 := B_0 + t_0$\n3.  $j := \\mathrm{mem}[t_1]$\n4.  $t_2 := j \\cdot s_A$\n5.  $t_3 := A_0 + t_2$\n\nNow, we substitute the given numerical values to compute the final address.\nThe provided data are:\n- Array $A$: base address $A_0 = 4096$, element size $s_A = 8$.\n- Array $B$: base address $B_0 = 2048$, element size $s_B = 4$.\n- Runtime index: $i = 11$.\n- Memory content: The value at $B[11]$ is given as $17$.\n\nLet's execute the TAC sequence with these values.\n\nStep 1: Compute the address of $B[11]$.\nThe offset is $i \\cdot s_B = 11 \\cdot 4 = 44$.\nThe address is $\\mathrm{addr}(B[11]) = B_0 + 44 = 2048 + 44 = 2092$.\nSo, $t_1 = 2092$.\n\nStep 2: Load the value of $B[11]$.\nThe problem states that the value at this location is $17$.\nSo, $j = \\mathrm{mem}[2092] = 17$.\n\nStep 3: Compute the address of $A[17]$.\nWe use the loaded value $j = 17$ as the index for array $A$.\nThe offset is $j \\cdot s_A = 17 \\cdot 8 = 136$.\nThe final address is $\\mathrm{addr}(A[17]) = A_0 + 136 = 4096 + 136 = 4232$.\n\nTherefore, the final byte address of the expression $A[B[i]]$ is $4232$.", "answer": "$$\n\\boxed{4232}\n$$", "id": "3677330"}, {"introduction": "The true power of three-address code becomes apparent when we consider optimization. This final practice challenges you to scale up your understanding to multi-dimensional arrays and apply powerful optimization techniques. By analyzing the address calculation for a 3D array within a nested loop [@problem_id:3677304], you will learn to identify loop-invariant computations and use strength reduction to replace expensive multiplications with simple, repeated additions, a foundational technique for generating high-performance code.", "problem": "A three-dimensional array $B[i][j][k]$ is stored in row-major order, meaning the rightmost index varies fastest in memory. The array has arbitrary lower and upper bounds $[l_1..u_1][l_2..u_2][l_3..u_3]$ along the three dimensions, respectively. Each element occupies $w$ bytes. Let the base address of the array $B$ be $\\text{base}(B)$. Consider translating a source-level reference $B[i][j][k]$ to an effective address using three-address code (3AC) and then refactoring the 3AC using loop-invariant code motion, in a nested-loop context where $j$ and $k$ are held constant within the inner loop over $i$.\n\nTasks:\n1. Starting only from the definitions of row-major layout, array extents, and affine address computation for multi-dimensional arrays, derive the effective-address expression for $B[i][j][k]$ in terms of $\\text{base}(B)$, $i$, $j$, $k$, $l_1$, $l_2$, $l_3$, $u_2$, $u_3$, and $w$.\n2. Produce a straight-line three-address code (3AC) sequence that computes this effective address for a given triple $(i,j,k)$.\n3. Now consider the following perfectly nested loops, where $i$ is the innermost loop index and $j$ and $k$ are invariant within the inner loop body:\nFor $k = K_0$ to $K_1$:\n  For $j = J_0$ to $J_1$:\n    For $i = I_0$ to $I_1$:\n      use $B[i][j][k]$\nRefactor your 3AC using loop-invariant code motion so that computations independent of $i$ are hoisted out of the inner loop, and the inner loop uses strength reduction with an induction variable to advance the effective address by a constant increment per iteration.\n\nAnswer specification:\nProvide, as your final answer, a single closed-form analytic expression for the per-iteration increment of the effective address, as a function of $l_2$, $u_2$, $l_3$, $u_3$, and $w$, when moving from $i$ to $i+1$ with $j$ and $k$ fixed. Do not include any units in the final boxed answer. If you choose to simplify using the extents $n_2 = u_2 - l_2 + 1$ and $n_3 = u_3 - l_3 + 1$, ensure your final expression depends only on $l_2$, $u_2$, $l_3$, $u_3$, and $w$. No rounding is required.", "solution": "The problem requires the derivation and optimization of the address calculation for a three-dimensional array element $B[i][j][k]$. The array is defined with lower and upper bounds $[l_1..u_1]$, $[l_2..u_2]$, and $[l_3..u_3]$, and is stored in row-major order. Each element occupies $w$ bytes.\n\n### Step 1: Derivation of the Effective Address Formula\nIn a row-major storage scheme, the rightmost index varies the fastest. To compute the address of an element $B[i][j][k]$, we determine its offset from the base address, $\\text{base}(B)$, which is the address of the first element $B[l_1][l_2][l_3]$. The offset is the product of the number of elements preceding $B[i][j][k]$ and the element size $w$.\n\nFirst, we define the extent, or the number of elements, along each dimension:\n- Extent of the 1st dimension ($i$): $n_1 = u_1 - l_1 + 1$\n- Extent of the 2nd dimension ($j$): $n_2 = u_2 - l_2 + 1$\n- Extent of the 3rd dimension ($k$): $n_3 = u_3 - l_3 + 1$\n\nThe total number of elements that precede $B[i][j][k]$ in the linear memory layout is calculated by considering the contributions from each index, relative to their lower bounds:\n1.  Contribution from the first index, $i$: The array consists of $n_1$ two-dimensional \"planes\", each of size $n_2 \\times n_3$. The number of complete planes to skip to reach the plane corresponding to index $i$ is $(i - l_1)$. This accounts for $(i - l_1) \\times n_2 \\times n_3$ elements.\n2.  Contribution from the second index, $j$: Within the $i$-th plane, the data is organized into $n_2$ \"rows\", each of size $n_3$. The number of complete rows to skip to reach the row corresponding to index $j$ is $(j - l_2)$. This accounts for an additional $(j - l_2) \\times n_3$ elements.\n3.  Contribution from the third index, $k$: Within the $j$-th row of the $i$-th plane, the number of elements to skip to reach the element at index $k$ is $(k - l_3)$.\n\nThe total number of elements preceding $B[i][j][k]$ is the sum of these contributions:\n$$ \\text{offset\\_in\\_elements} = (i - l_1) n_2 n_3 + (j - l_2) n_3 + (k - l_3) $$\nThe byte offset is this quantity multiplied by the element size $w$. The effective address of $B[i][j][k]$ is therefore:\n$$ \\text{addr}(B[i][j][k]) = \\text{base}(B) + w \\times \\left[ (i - l_1) n_2 n_3 + (j - l_2) n_3 + (k - l_3) \\right] $$\nSubstituting the definitions for $n_2$ and $n_3$, we obtain the required expression:\n$$ \\text{addr}(B[i][j][k]) = \\text{base}(B) + w \\left[ (i - l_1)(u_2 - l_2 + 1)(u_3 - l_3 + 1) + (j - l_2)(u_3 - l_3 + 1) + (k - l_3) \\right] $$\n\n### Step 2: Three-Address Code (3AC) Sequence\nThe formula above can be translated into a straight-line sequence of three-address code instructions. Let's denote $n_2 = u_2 - l_2 + 1$ and $n_3 = u_3 - l_3 + 1$. The 3AC is as follows:\n$$ t_1 = i - l_1 $$\n$$ t_2 = t_1 \\times n_2 $$\n$$ t_3 = t_2 \\times n_3 $$\n$$ t_4 = j - l_2 $$\n$$ t_5 = t_4 \\times n_3 $$\n$$ t_6 = k - l_3 $$\n$$ t_7 = t_3 + t_5 $$\n$$ t_8 = t_7 + t_6 $$\n$$ t_9 = w \\times t_8 $$\n$$ \\text{addr} = \\text{base}(B) + t_9 $$\n\n### Step 3: Refactoring for Loop Optimization and Increment Calculation\nThe problem specifies a nested loop structure where the innermost loop iterates over $i$, while $j$ and $k$ are held constant.\n$$\n\\text{For } k = K_0 \\text{ to } K_1: \\\\\n\\quad \\text{For } j = J_0 \\text{ to } J_1: \\\\\n\\quad\\quad \\text{For } i = I_0 \\text{ to } I_1: \\\\\n\\quad\\quad\\quad \\text{use } B[i][j][k]\n$$\nTo optimize the address calculation within the $i$-loop, we apply loop-invariant code motion. We rearrange the address formula to separate terms that depend on $i$ from those that do not.\n$$ \\text{addr}(B[i][j][k]) = \\text{base}(B) + w(i \\cdot n_2 n_3 - l_1 n_2 n_3) + w((j - l_2) n_3) + w(k - l_3) $$\n$$ \\text{addr}(B[i][j][k]) = \\left[ \\text{base}(B) - w \\cdot l_1 n_2 n_3 + w \\cdot (j - l_2) n_3 + w \\cdot (k - l_3) \\right] + i \\cdot (w \\cdot n_2 n_3) $$\nThis expression has the form $C_{j,k} + i \\cdot S_i$, where:\n- $C_{j,k} = \\text{base}(B) - w l_1 n_2 n_3 + w (j - l_2) n_3 + w (k - l_3)$ is the loop-invariant part with respect to the $i$-loop.\n- $S_i = w n_2 n_3$ is the stride, or the constant factor by which $i$ is multiplied.\n\nThe computation of $C_{j,k}$ and $S_i$ can be hoisted out of the $i$-loop. The address calculation inside the loop, $C_{j,k} + i \\cdot S_i$, is a candidate for strength reduction. Instead of a multiplication in each iteration, we can maintain an induction variable, say $p$, that holds the current address. Before the loop, $p$ is initialized to the address of the first element, $B[I_0][j][k]$. In each iteration, $p$ is updated by adding a constant increment to get the address of the next element, $B[i+1][j][k]$.\n\nThe per-iteration increment is the difference in address when $i$ is incremented by $1$:\n$$ \\text{Increment} = \\text{addr}(B[i+1][j][k]) - \\text{addr}(B[i][j][k]) $$\nUsing the optimized form, $C_{j,k} + i \\cdot S_i$:\n$$ \\text{Increment} = [C_{j,k} + (i+1) \\cdot S_i] - [C_{j,k} + i \\cdot S_i] $$\n$$ \\text{Increment} = (C_{j,k} + i \\cdot S_i + S_i) - (C_{j,k} + i \\cdot S_i) = S_i $$\nSo, the increment is simply the stride $S_i = w n_2 n_3$. This constant represents the memory size of a full $(j,k)$-plane of the array.\n\nThe final step is to express this increment using the variables specified in the problem statement: $l_2$, $u_2$, $l_3$, $u_3$, and $w$. We substitute the expressions for $n_2$ and $n_3$:\n$$ \\text{Increment} = w \\times (u_2 - l_2 + 1) \\times (u_3 - l_3 + 1) $$\nThis is the closed-form analytic expression for the constant value added to the address induction variable in each iteration of the inner loop.", "answer": "$$\n\\boxed{w (u_2 - l_2 + 1) (u_3 - l_3 + 1)}\n$$", "id": "3677304"}]}