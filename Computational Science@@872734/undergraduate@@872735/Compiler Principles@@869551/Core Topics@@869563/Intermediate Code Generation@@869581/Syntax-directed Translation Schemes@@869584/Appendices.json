{"hands_on_practices": [{"introduction": "A fundamental application of syntax-directed translation is the conversion of high-level arithmetic expressions into low-level code for a target machine. This first practice challenges you to build a translator for a simple expression grammar, using synthesized attributes to generate a correct sequence of instructions for a stack-based virtual machine. By working through this exercise [@problem_id:3673805], you will gain hands-on experience with how a compiler methodically translates the structure of source code into an executable format.", "problem": "Consider the context-free grammar for left-associative multiplication expressions given by $E \\rightarrow E * T \\mid T$ and $T \\rightarrow \\mathrm{id}$. Design a Syntax-Directed Translation (SDT) scheme that uses a synthesized attribute $X.\\mathrm{code}$ for each nonterminal $X \\in \\{E, T\\}$ to generate a sequence of instructions for a stack machine that evaluates the expression. The stack machine supports the instructions $\\mathrm{LOAD}(x)$, which pushes the value of the identifier `x` onto the stack, and $\\mathrm{MUL}$, which pops the top two values $r_2$ and $r_1$, computes $r_1 \\times r_2$, and pushes the result. All identifiers are evaluated according to an environment mapping $\\sigma$ where $\\sigma(x)$ is the real value bound to the identifier $x$.\n\nStarting from the fundamental definitions of context-free grammars and the operational semantics of the given stack machine, propose an SDT that correctly enforces the left-associative evaluation defined by the grammar and annotates $E.\\mathrm{code}$ so that the generated code pushes and pops correctly.\n\nThen, apply your SDT to the input expression $w * x * y * z$ with the environment mapping $\\sigma(w) = \\frac{6}{5}$, $\\sigma(x) = -3$, $\\sigma(y) = \\frac{7}{5}$, and $\\sigma(z) = 2$. After generating the code, conceptually execute it on the stack machine as per the specified semantics and compute the exact final top-of-stack value. No rounding is required; express your answer exactly as a fraction or a decimal number without using a percentage sign.", "solution": "The problem requires the design of a Syntax-Directed Translation (SDT) scheme for a given context-free grammar, the application of this SDT to a specific input expression, and the conceptual execution of the generated code to find a final numerical result.\n\n### Problem Validation\nFirst, the problem statement is validated.\n\n**1. Extracted Givens:**\n*   **Grammar:** $E \\rightarrow E * T \\mid T$ and $T \\rightarrow \\mathrm{id}$.\n*   **Associativity:** Left-associative multiplication.\n*   **Attribute:** A synthesized attribute $X.\\text{code}$ for each nonterminal $X \\in \\{E, T\\}$. This attribute is a sequence of instructions.\n*   **Target Machine:** A stack machine.\n*   **Instructions:**\n    *   $\\mathrm{LOAD}(x)$: Pushes the value of identifier $x$ onto the stack.\n    *   $\\mathrm{MUL}$: Pops the top two values, $r_2$ (top) and $r_1$ (next-to-top), computes $r_1 \\times r_2$, and pushes the result.\n*   **Environment:** $\\sigma$, a mapping from identifiers to real values.\n*   **Input Expression:** $w * x * y * z$.\n*   **Specific Environment:** $\\sigma(w) = \\frac{6}{5}$, $\\sigma(x) = -3$, $\\sigma(y) = \\frac{7}{5}$, and $\\sigma(z) = 2$.\n*   **Objective:** Design the SDT, generate code for the input, execute it, and find the final value.\n\n**2. Validation Verdict:**\nThe problem is **valid**. It is a well-posed and self-contained problem within the established domain of compiler theory. The grammar, machine semantics, and translation task are all clearly and formally defined. There are no scientific or logical contradictions, no missing information, and no subjective elements. The problem is a standard exercise in syntax-directed translation.\n\n### Part 1: Design of the Syntax-Directed Translation (SDT) Scheme\n\nThe goal is to define semantic rules for each production in the grammar to generate a sequence of stack machine instructions. The attribute $X.\\text{code}$ for a nonterminal $X$ will store the instruction sequence that evaluates the expression derived from $X$ and leaves the result on top of the stack. We use $||$ to denote the concatenation of instruction sequences.\n\n**Production 1: $T \\rightarrow \\mathrm{id}$**\nThis production represents the base case of an expression, a single identifier. To evaluate it, we must load its value onto the stack. The lexical value (name) of the token $\\mathrm{id}$ is available via an attribute, which we denote as $\\mathrm{id}.\\text{lexval}$.\nThe semantic rule is:\n$T.\\text{code} := \"\\mathrm{LOAD}(\" \\ || \\ \\mathrm{id}.\\text{lexval} \\ || \\ \")\"$\n\n**Production 2: $E \\rightarrow T$**\nThis production handles expressions that consist of only a single term. The code to evaluate such an expression is simply the code to evaluate the term itself.\nThe semantic rule is:\n$E.\\text{code} := T.\\text{code}$\n\n**Production 3: $E \\rightarrow E_1 * T$**\nThis is the left-recursive production that captures left-associativity. To evaluate an expression of the form $E_1 * T$, we must first evaluate the left subexpression $E_1$, which leaves its result on the stack. Then, we evaluate the right subexpression $T$, which leaves its result on top of the result from $E_1$. Finally, we execute the multiplication instruction, which pops the two results and pushes their product.\nThe semantic rules for synthesized attributes are applied during a bottom-up parse. The code for $E_1$ and $T$ will have already been generated. Therefore, we can concatenate them.\nThe semantic rule is:\n$E.\\text{code} := E_1.\\text{code} \\ || \\ T.\\text{code} \\ || \\ \"\\mathrm{MUL}\"$\n\nThe complete SDT is summarized as:\n| Production             | Semantic Rule                                         |\n|------------------------|-------------------------------------------------------|\n| $T \\rightarrow \\mathrm{id}$  | $T.\\text{code} := \"\\mathrm{LOAD}(\\mathrm{id}.\\text{lexval})\"$ |\n| $E \\rightarrow T$        | $E.\\text{code} := T.\\text{code}$                      |\n| $E \\rightarrow E_1 * T$  | $E.\\text{code} := E_1.\\text{code} \\ || \\ T.\\text{code} \\ || \\ \"\\mathrm{MUL}\"$ |\n\n### Part 2: Code Generation for $w * x * y * z$\n\nWe apply the SDT to the input string $w * x * y * z$. A left-recursive grammar naturally leads to a left-associative parse. The expression is parsed as $(((w * x) * y) * z)$. We can trace the code generation by simulating a bottom-up parse (or annotating a parse tree).\n\n1.  **Parse $w$**:\n    *   $T \\rightarrow \\mathrm{id}_w \\implies T.\\text{code} = \"\\mathrm{LOAD}(w)\"$\n    *   $E \\rightarrow T \\implies E_1.\\text{code} = \"\\mathrm{LOAD}(w)\"$\n\n2.  **Parse $w * x$**: This corresponds to the production $E \\rightarrow E_1 * T_x$.\n    *   For the subexpression $x$: $T_x \\rightarrow \\mathrm{id}_x \\implies T_x.\\text{code} = \"\\mathrm{LOAD}(x)\"$\n    *   For the expression $w * x$: $E_2.\\text{code} = E_1.\\text{code} \\ || \\ T_x.\\text{code} \\ || \\ \"\\mathrm{MUL}\" = \"\\mathrm{LOAD}(w) \\ \\mathrm{LOAD}(x) \\ \\mathrm{MUL}\"$\n\n3.  **Parse $(w * x) * y$**: This corresponds to the production $E \\rightarrow E_2 * T_y$.\n    *   For the subexpression $y$: $T_y \\rightarrow \\mathrm{id}_y \\implies T_y.\\text{code} = \"\\mathrm{LOAD}(y)\"$\n    *   For the expression $(w * x) * y$: $E_3.\\text{code} = E_2.\\text{code} \\ || \\ T_y.\\text{code} \\ || \\ \"\\mathrm{MUL}\" = \"\\mathrm{LOAD}(w) \\ \\mathrm{LOAD}(x) \\ \\mathrm{MUL} \\ \\mathrm{LOAD}(y) \\ \\mathrm{MUL}\"$\n\n4.  **Parse $((w * x) * y) * z$**: This corresponds to the production $E \\rightarrow E_3 * T_z$.\n    *   For the subexpression $z$: $T_z \\rightarrow \\mathrm{id}_z \\implies T_z.\\text{code} = \"\\mathrm{LOAD}(z)\"$\n    *   For the full expression: $E.\\text{code} = E_3.\\text{code} \\ || \\ T_z.\\text{code} \\ || \\ \"\\mathrm{MUL}\" = \"\\mathrm{LOAD}(w) \\ \\mathrm{LOAD}(x) \\ \\mathrm{MUL} \\ \\mathrm{LOAD}(y) \\ \\mathrm{MUL} \\ \\mathrm{LOAD}(z) \\ \\mathrm{MUL}\"$\n\nThe final generated sequence of instructions is:\n$\\mathrm{LOAD}(w)$, $\\mathrm{LOAD}(x)$, $\\mathrm{MUL}$, $\\mathrm{LOAD}(y)$, $\\mathrm{MUL}$, $\\mathrm{LOAD}(z)$, $\\mathrm{MUL}$\n\n### Part 3: Conceptual Execution and Final Value Calculation\n\nWe execute this code sequence with the given environment: $\\sigma(w) = \\frac{6}{5}$, $\\sigma(x) = -3$, $\\sigma(y) = \\frac{7}{5}$, $\\sigma(z) = 2$.\nThe stack is denoted by a list `[...]` with the top at the right.\n\n1.  **Initial Stack:** `[]`\n2.  **$\\mathrm{LOAD}(w)$:** `[ $\\frac{6}{5}$ ]`\n3.  **$\\mathrm{LOAD}(x)$:** `[ $\\frac{6}{5}$, $-3$ ]`\n4.  **$\\mathrm{MUL}$:**\n    *   Pop $r_2 = -3$.\n    *   Pop $r_1 = \\frac{6}{5}$.\n    *   Compute $r_1 \\times r_2 = \\frac{6}{5} \\times (-3) = -\\frac{18}{5}$.\n    *   Push result. Stack: `[ $-\\frac{18}{5}$ ]`\n5.  **$\\mathrm{LOAD}(y)$:** `[ $-\\frac{18}{5}$, $\\frac{7}{5}$ ]`\n6.  **$\\mathrm{MUL}$:**\n    *   Pop $r_2 = \\frac{7}{5}$.\n    *   Pop $r_1 = -\\frac{18}{5}$.\n    *   Compute $r_1 \\times r_2 = (-\\frac{18}{5}) \\times (\\frac{7}{5}) = -\\frac{126}{25}$.\n    *   Push result. Stack: `[ $-\\frac{126}{25}$ ]`\n7.  **$\\mathrm{LOAD}(z)$:** `[ $-\\frac{126}{25}$, $2$ ]`\n8.  **$\\mathrm{MUL}$:**\n    *   Pop $r_2 = 2$.\n    *   Pop $r_1 = -\\frac{126}{25}$.\n    *   Compute $r_1 \\times r_2 = (-\\frac{126}{25}) \\times 2 = -\\frac{252}{25}$.\n    *   Push result. Stack: `[ $-\\frac{252}{25}$ ]`\n\nThe execution terminates with the value $-\\frac{252}{25}$ on top of the stack. This value can also be expressed as $-10.08$. As per the problem instructions, the exact fractional form is appropriate.\nFinal calculation:\n$$\n\\left( \\left( \\frac{6}{5} \\times (-3) \\right) \\times \\frac{7}{5} \\right) \\times 2 = \\left( -\\frac{18}{5} \\times \\frac{7}{5} \\right) \\times 2 = \\left( -\\frac{126}{25} \\right) \\times 2 = -\\frac{252}{25}\n$$", "answer": "$$\\boxed{-\\frac{252}{25}}$$", "id": "3673805"}, {"introduction": "Real-world programming languages often use the same symbol for different operations depending on context, a feature known as operator overloading. This exercise explores how a syntax-directed translation scheme can manage such complexity by using attributes to track the data types of subexpressions. You will design a system [@problem_id:3673777] that correctly interprets the unary minus operator as either arithmetic negation or boolean complement, illustrating a core principle of semantic analysis.", "problem": "Consider an expression grammar fragment that permits parenthesized factors, integer literals, and the unary minus operator:\n- Production: $F \\to -\\,F$\n- Production: $F \\to (\\,F\\,)$\n- Production: $F \\to \\text{num}$\n- Production: $F \\to \\text{true}$\n- Production: $F \\to \\text{false}$\n\nDesign a Syntax-Directed Translation (SDT) that distinguishes the two overloaded interpretations of the unary minus on a factor $F$: for numeric operands, it performs arithmetic negation; for boolean operands, it performs boolean complement. Your SDT must use attributes $F.\\text{type}$ and $F.\\text{opkind}$ to decide and record the operator semantics, and a synthesized attribute $F.\\text{val}$ to carry the computed numeric result of evaluating the expression. Assume the following conventions:\n- The attribute $F.\\text{type}$ ranges over $\\{\\text{int}, \\text{bool}\\}$.\n- The attribute $F.\\text{opkind}$ ranges over $\\{\\text{neg}, \\text{not}\\}$, indicating arithmetic negation and boolean complement respectively.\n- The attribute $F.\\text{val}$ is numeric and, for boolean values, uses $1$ for $\\text{true}$ and $0$ for $\\text{false}$.\n\nStarting from the foundational definitions of syntax-directed definitions and synthesized attributes, construct an S-attributed SDT for the given productions that correctly sets $F.\\text{type}$, $F.\\text{opkind}$, and $F.\\text{val}$ in each case. Then, apply your SDT to the input string consisting of $11$ successive unary minuses applied to the parenthesized literal $\\text{false}$, that is, the string\n$-(-(-(-(-(-(-(-(-(-(-(\\text{false})))))))))))$,\nand compute the numeric value of the synthesized attribute $F.\\text{val}$ at the root of the parse. Express your final answer as a single real-valued number. No rounding is required.", "solution": "The problem requires designing an S-attributed Syntax-Directed Translation (SDT) for a given grammar fragment and then using it to evaluate a specific input string. An S-attributed SDT is a syntax-directed definition that exclusively uses synthesized attributes. The value of a synthesized attribute at a node in a parse tree is computed from the attributes of its children. This allows for a straightforward, bottom-up evaluation.\n\nFirst, we will formally define the SDT by specifying the semantic rules for each production in the grammar. The attributes are $F.\\text{type}$, which can be $\\text{int}$ or $\\text{bool}$; $F.\\text{opkind}$, which can be $\\text{neg}$ or $\\text{not}$; and $F.\\text{val}$, which holds the numeric value.\n\nThe grammar productions and their corresponding semantic rules are as follows:\n\n1.  Production: $F \\to \\text{num}$\n    This production handles integer literals. The type is $\\text{int}$, and the value is the lexical value of the number.\n    -   Semantic Rule for type: $F.\\text{type} := \\text{int}$\n    -   Semantic Rule for value: $F.\\text{val} := \\text{num.lexval}$\n    \n2.  Production: $F \\to \\text{true}$\n    This production handles the boolean literal $\\text{true}$. The type is $\\text{bool}$, and the numeric value is defined as $1$.\n    -   Semantic Rule for type: $F.\\text{type} := \\text{bool}$\n    -   Semantic Rule for value: $F.\\text{val} := 1$\n\n3.  Production: $F \\to \\text{false}$\n    This production handles the boolean literal $\\text{false}$. The type is $\\text{bool}$, and the numeric value is defined as $0$.\n    -   Semantic Rule for type: $F.\\text{type} := \\text{bool}$\n    -   Semantic Rule for value: $F.\\text{val} := 0$\n\n4.  Production: $F \\to (F_1)$\n    This production handles parenthesized expressions. The parentheses do not change the type or value of the inner expression $F_1$. Attributes are synthesized directly from the child node. Let $F_1$ denote the non-terminal on the right-hand side.\n    -   Semantic Rule for type: $F.\\text{type} := F_1.\\text{type}$\n    -   Semantic Rule for value: $F.\\text{val} := F_1.\\text{val}$\n\n5.  Production: $F \\to - F_1$\n    This is the core production where the unary minus operator is overloaded. The semantic action depends on the type of the operand, $F_1$. Let $F_1$ denote the non-terminal on the right-hand side.\n    -   If $F_1.\\text{type} = \\text{int}$: The operator performs arithmetic negation.\n        -   $F.\\text{type} := \\text{int}$\n        -   $F.\\text{opkind} := \\text{neg}$\n        -   $F.\\text{val} := -F_1.\\text{val}$\n    -   If $F_1.\\text{type} = \\text{bool}$: The operator performs boolean complement (logical NOT). Using the numeric convention ($1$ for $\\text{true}$, $0$ for $\\text{false}$), the NOT operation on a value $v$ is equivalent to $1-v$.\n        -   $F.\\text{type} := \\text{bool}$\n        -   $F.\\text{opkind} := \\text{not}$\n        -   $F.\\text{val} := 1 - F_1.\\text{val}$\n\nNow, we apply this SDT to evaluate the input string $-(-(-(-(-(-(-(-(-(-(-(\\text{false}))))))))))))$. This string consists of the parenthesized literal $\\text{false}$ nested inside $11$ successive applications of the unary minus operator.\n\nThe evaluation of synthesized attributes proceeds bottom-up on the parse tree. Let's trace the computation from the innermost expression outwards.\n\nLet $F_{(0)}$ be the non-terminal node for the innermost expression, $\\text{false}$.\n-   Using production $F \\to \\text{false}$:\n    $F_{(0)}.\\text{type} = \\text{bool}$\n    $F_{(0)}.\\text{val} = 0$\n\nLet $F_{(1)}$ be the node for $(\\text{false})$, corresponding to the production $F \\to (F_{(0)})$.\n-   Using production $F \\to (F_1)$:\n    $F_{(1)}.\\text{type} = F_{(0)}.\\text{type} = \\text{bool}$\n    $F_{(1)}.\\text{val} = F_{(0)}.\\text{val} = 0$\n\nNow we begin the chain of $11$ unary minus applications. Let's denote the value of the attribute $F.\\text{val}$ after $k$ applications of the unary minus as $v_k$. The initial value, before any minus operators are applied, is $v_0 = F_{(1)}.\\text{val} = 0$.\n\nThe first application of unary minus is on $F_{(1)}$, creating a new node $F_{(2)}$ for the expression $-(\\text{false})$.\n-   Using production $F \\to -F_1$ with $F_1 = F_{(1)}$:\n    Since $F_{(1)}.\\text{type}$ is $\\text{bool}$, we apply the boolean complement rule.\n    $F_{(2)}.\\text{type}$ becomes $\\text{bool}$.\n    $F_{(2)}.\\text{opkind}$ becomes $\\text{not}$.\n    The value $v_1 = F_{(2)}.\\text{val}$ is computed as:\n    $$v_1 = 1 - F_{(1)}.\\text{val} = 1 - v_0 = 1 - 0 = 1$$\n\nThe second application of unary minus is on $F_{(2)}$.\n-   Using production $F \\to -F_1$ with $F_1 = F_{(2)}$:\n    Since $F_{(2)}.\\text{type}$ is $\\text{bool}$, we again apply the boolean complement rule.\n    The value $v_2 = F_{(3)}.\\text{val}$ is computed as:\n    $$v_2 = 1 - F_{(2)}.\\text{val} = 1 - v_1 = 1 - 1 = 0$$\n\nA clear pattern emerges. At each step, the type of the expression remains $\\text{bool}$, so the semantic rule for boolean complement is always chosen. The value of the expression after $k$ applications of the unary minus, $v_k$, follows the recurrence relation:\n$$v_k = 1 - v_{k-1} \\quad \\text{for } k \\geq 1$$\nwith the initial condition $v_0 = 0$.\n\nLet's compute the sequence of values:\n-   $v_0 = 0$\n-   $v_1 = 1 - v_0 = 1$\n-   $v_2 = 1 - v_1 = 0$\n-   $v_3 = 1 - v_2 = 1$\n-   $v_4 = 1 - v_3 = 0$\n\nThe value $v_k$ alternates between $1$ and $0$. Specifically, for an initial value of $v_0=0$:\n$$v_k = \\begin{cases} 0 & \\text{if } k \\text{ is even} \\\\ 1 & \\text{if } k \\text{ is odd} \\end{cases}$$\nThis can be expressed as $v_k = k \\pmod 2$.\n\nThe problem asks for the value of the full expression, which involves $11$ applications of the unary minus operator. Therefore, we need to compute $v_{11}$.\nSince $k=11$ is an odd number, the final value is:\n$$v_{11} = 1$$\n\nThe synthesized attribute $F.\\text{val}$ at the root of the parse tree for the entire input string is therefore $1$.", "answer": "$$\\boxed{1}$$", "id": "3673777"}, {"introduction": "Effective compilers do more than just translate code; they actively analyze it to improve safety and performance. This final practice delves into the realm of static analysis, where you will design a translation scheme that can identify constant expressions at compile time. By doing so, your system [@problem_id:3673782] will be able to flag definitive errors like division-by-zero before the program even runs, while correctly inserting checks for cases that can only be resolved at runtime.", "problem": "Design a Syntax-Directed Translation (SDT) within the framework of a Context-Free Grammar (CFG) for arithmetic expressions that can statically flag division-by-zero when the denominator is a constant zero at parse-time, and otherwise emit a runtime check for each division. Use synthesized attributes only. Your SDT must determine whether each subexpression is a constant and, if so, compute its numeric value; if any variable is present, the subexpression should be treated as non-constant. Let numeric literals be integers and identifiers be non-constant unknowns. Consider the following CFG with standard precedence and associativity (multiplication and division bind tighter than addition and subtraction, and parentheses may override precedence). The grammar is:\n$$\nE \\to E + T \\mid E - T \\mid T\n$$\n$$\nT \\to T \\times F \\mid T \\div F \\mid F\n$$\n$$\nF \\to (E) \\mid \\text{num} \\mid \\text{id}\n$$\nThe SDT must:\n- For each production of the form $T \\to T \\div F$, if $F$ is constant and $F.\\text{val} = 0$, flag a static division-by-zero. Otherwise, emit a runtime check for that division.\n- Propagate and compute a synthesized attribute $\\text{val}$ for $E$, $T$, and $F$ whenever a subexpression is provably constant from numeric literals and fully constant subexpressions; if a subexpression is not constant, set $\\text{val}$ to an unknown marker.\n- Accumulate a synthesized count of runtime checks inserted and static division-by-zero flags across the tree, and make these totals available at the root.\n\nAssume the unknown marker is denoted by the symbol $\\bot$ and that the evaluation of $\\text{val}$ follows the usual arithmetic of integers when fully constant and is $\\bot$ otherwise. For the input expression\n$$\n\\big((8 \\div (4 - 4)) \\div (7 \\div 1)\\big) \\div \\big(x \\div (2 - 3)\\big),\n$$\nuse your SDT to compute the total number of runtime checks that are emitted during parsing of this expression. Report only the number of runtime checks. You do not need to report the number of static flags. Express your final answer as a single integer, with no rounding instructions needed.", "solution": "The problem statement is evaluated as valid. It is a well-posed, self-contained, and scientifically-grounded problem within the domain of compiler design and syntax-directed translation. It is free of contradictions, ambiguities, and factual errors.\n\nThe task is to design a Syntax-Directed Translation (SDT) using only synthesized attributes to analyze arithmetic expressions. The SDT must statically detect division by a constant zero and, for all other division operations, emit a runtime check. We are asked to compute the total number of runtime checks for the specific expression $\\big((8 \\div (4 - 4)) \\div (7 \\div 1)\\big) \\div \\big(x \\div (2 - 3)\\big)$.\n\nFirst, we define the SDT. For each non-terminal symbol $X \\in \\{E, T, F\\}$ in the grammar, we define a set of synthesized attributes:\n1.  $X.\\text{is\\_const}$: A boolean attribute that is true if the subexpression rooted at $X$ is a compile-time constant, and false otherwise.\n2.  $X.\\text{val}$: The integer value of the subexpression if $X.\\text{is\\_const}$ is true. If the subexpression is not constant or its evaluation results in an error (like division by zero), its value is an unknown marker, denoted by $\\bot$.\n3.  $X.\\text{rc}$: An integer attribute counting the number of runtime checks emitted for the subexpression rooted at $X$.\n4.  $X.\\text{sf}$: An integer attribute counting the number of static division-by-zero flags raised for the subexpression rooted at $X$.\n\nThe semantic rules for each production of the context-free grammar are as follows.\n\nFor the terminal productions:\n-   $F \\to \\text{num}$:\n    $$F.\\text{is\\_const} \\leftarrow \\text{true}$$\n    $$F.\\text{val} \\leftarrow \\text{num.lexval}$$\n    $$F.\\text{rc} \\leftarrow 0$$\n    $$F.\\text{sf} \\leftarrow 0$$\n-   $F \\to \\text{id}$:\n    $$F.\\text{is\\_const} \\leftarrow \\text{false}$$\n    $$F.\\text{val} \\leftarrow \\bot$$\n    $$F.\\text{rc} \\leftarrow 0$$\n    $$F.\\text{sf} \\leftarrow 0$$\n\nFor the non-terminal productions:\n-   $F \\to (E)$:\n    $$F.\\text{is\\_const} \\leftarrow E.\\text{is\\_const}$$\n    $$F.\\text{val} \\leftarrow E.\\text{val}$$\n    $$F.\\text{rc} \\leftarrow E.\\text{rc}$$\n    $$F.\\text{sf} \\leftarrow E.\\text{sf}$$\n-   $T \\to F$:\n    $$T.\\text{is\\_const} \\leftarrow F.\\text{is\\_const}$$\n    $$T.\\text{val} \\leftarrow F.\\text{val}$$\n    $$T.\\text{rc} \\leftarrow F.\\text{rc}$$\n    $$T.\\text{sf} \\leftarrow F.\\text{sf}$$\n-   $E \\to T$:\n    $$E.\\text{is\\_const} \\leftarrow T.\\text{is\\_const}$$\n    $$E.\\text{val} \\leftarrow T.\\text{val}$$\n    $$E.\\text{rc} \\leftarrow T.\\text{rc}$$\n    $$E.\\text{sf} \\leftarrow T.\\text{sf}$$\n-   $E \\to E_1 + T_2$:\n    $$E.\\text{is\\_const} \\leftarrow E_1.\\text{is\\_const} \\land T_2.\\text{is\\_const}$$\n    $$E.\\text{val} \\leftarrow \\begin{cases} E_1.\\text{val} + T_2.\\text{val} & \\text{if } E.\\text{is\\_const} \\\\ \\bot & \\text{otherwise} \\end{cases}$$\n    $$E.\\text{rc} \\leftarrow E_1.\\text{rc} + T_2.\\text{rc}$$\n    $$E.\\text{sf} \\leftarrow E_1.\\text{sf} + T_2.\\text{sf}$$\n-   $E \\to E_1 - T_2$:\n    $$E.\\text{is\\_const} \\leftarrow E_1.\\text{is\\_const} \\land T_2.\\text{is\\_const}$$\n    $$E.\\text{val} \\leftarrow \\begin{cases} E_1.\\text{val} - T_2.\\text{val} & \\text{if } E.\\text{is\\_const} \\\\ \\bot & \\text{otherwise} \\end{cases}$$\n    $$E.\\text{rc} \\leftarrow E_1.\\text{rc} + T_2.\\text{rc}$$\n    $$E.\\text{sf} \\leftarrow E_1.\\text{sf} + T_2.\\text{sf}$$\n-   $T \\to T_1 \\times F_2$:\n    $$T.\\text{is\\_const} \\leftarrow T_1.\\text{is\\_const} \\land F_2.\\text{is\\_const}$$\n    $$T.\\text{val} \\leftarrow \\begin{cases} T_1.\\text{val} \\times F_2.\\text{val} & \\text{if } T.\\text{is\\_const} \\\\ \\bot & \\text{otherwise} \\end{cases}$$\n    $$T.\\text{rc} \\leftarrow T_1.\\text{rc} + F_2.\\text{rc}$$\n    $$T.\\text{sf} \\leftarrow T_1.\\text{sf} + F_2.\\text{sf}$$\n-   $T \\to T_1 \\div F_2$:\n    If $F_2.\\text{is\\_const} = \\text{true}$ and $F_2.\\text{val} = 0$:\n    $$T.\\text{is\\_const} \\leftarrow \\text{false}$$\n    $$T.\\text{val} \\leftarrow \\bot$$\n    $$T.\\text{rc} \\leftarrow T_1.\\text{rc} + F_2.\\text{rc}$$\n    $$T.\\text{sf} \\leftarrow T_1.\\text{sf} + F_2.\\text{sf} + 1$$\n    Else:\n    $$T.\\text{is\\_const} \\leftarrow T_1.\\text{is\\_const} \\land F_2.\\text{is\\_const}$$\n    $$T.\\text{val} \\leftarrow \\begin{cases} T_1.\\text{val} \\div F_2.\\text{val} & \\text{if } T.\\text{is\\_const} \\\\ \\bot & \\text{otherwise} \\end{cases}$$\n    $$T.\\text{rc} \\leftarrow T_1.\\text{rc} + F_2.\\text{rc} + 1$$\n    $$T.\\text{sf} \\leftarrow T_1.\\text{sf} + F_2.\\text{sf}$$\n\nNow, we apply these rules to the input expression $\\big((8 \\div (4 - 4)) \\div (7 \\div 1)\\big) \\div \\big(x \\div (2 - 3)\\big)$ in a bottom-up fashion, which corresponds to a post-order traversal of the parse tree. We will denote the attributes of a node for subexpression $s$ as $A(s) = (\\text{is\\_const}, \\text{val}, \\text{rc}, \\text{sf})$.\n\n1.  **Innermost subexpressions:**\n    -   $s_1 = (4-4)$: The operands are $\\text{num}_4$ and $\\text{num}_4$. For $\\text{num}_4$, $A(\\text{num}_4) = (\\text{true}, 4, 0, 0)$.\n        Applying the rule for $E \\to E_1 - T_2$:\n        $A(s_1) = (\\text{true} \\land \\text{true}, 4-4, 0+0, 0+0) = (\\text{true}, 0, 0, 0)$.\n    -   $s_2 = (7 \\div 1)$: The operands are $\\text{num}_7$ and $\\text{num}_1$. $A(\\text{num}_7) = (\\text{true}, 7, 0, 0)$ and $A(\\text{num}_1) = (\\text{true}, 1, 0, 0)$. The denominator is constant and its value is $1$, not $0$.\n        Applying the \"Else\" part of the rule for $T \\to T_1 \\div F_2$:\n        $A(s_2) = (\\text{true} \\land \\text{true}, 7 \\div 1, 0+0+1, 0+0) = (\\text{true}, 7, 1, 0)$.\n        A runtime check is added.\n    -   $s_3 = (2 - 3)$: The operands are $\\text{num}_2$ and $\\text{num}_3$. $A(\\text{num}_2) = (\\text{true}, 2, 0, 0)$ and $A(\\text{num}_3) = (\\text{true}, 3, 0, 0)$.\n        Applying the rule for $E \\to E_1 - T_2$:\n        $A(s_3) = (\\text{true} \\land \\text{true}, 2-3, 0+0, 0+0) = (\\text{true}, -1, 0, 0)$.\n\n2.  **Intermediate subexpressions:**\n    -   $s_4 = (8 \\div (4-4))$: The operands are $\\text{num}_8$ with $A(\\text{num}_8) = (\\text{true}, 8, 0, 0)$ and $s_1$ with $A(s_1) = (\\text{true}, 0, 0, 0)$. The denominator is constant and its value is $0$.\n        Applying the \"If\" part of the rule for $T \\to T_1 \\div F_2$:\n        $A(s_4) = (\\text{false}, \\bot, 0+0, 0+0+1) = (\\text{false}, \\bot, 0, 1)$.\n        A static flag is raised. No runtime check is added for this division.\n    -   $s_5 = (x \\div (2-3))$: The operands are $\\text{id}_x$ with $A(\\text{id}_x) = (\\text{false}, \\bot, 0, 0)$ and $s_3$ with $A(s_3) = (\\text{true}, -1, 0, 0)$. The denominator is constant and its value is $-1$, not $0$.\n        Applying the \"Else\" part of the rule for $T \\to T_1 \\div F_2$:\n        The condition $T.\\text{is\\_const}$ is false because $T_1.\\text{is\\_const}$ (for $x$) is false.\n        $A(s_5) = (\\text{false} \\land \\text{true}, \\bot, 0+0+1, 0+0) = (\\text{false}, \\bot, 1, 0)$.\n        A runtime check is added.\n\n3.  **Higher-level subexpressions:**\n    -   $s_6 = \\big((8 \\div (4 - 4)) \\div (7 \\div 1)\\big)$: This is $s_4 \\div s_2$. The operands are $s_4$ with $A(s_4) = (\\text{false}, \\bot, 0, 1)$ and $s_2$ with $A(s_2) = (\\text{true}, 7, 1, 0)$. The denominator $s_2$ is constant and its value is $7$, not $0$.\n        Applying the \"Else\" part of the rule for $T \\to T_1 \\div F_2$:\n        The condition $T.\\text{is\\_const}$ is false because $T_1.\\text{is\\_const}$ (for $s_4$) is false.\n        The runtime check count is the sum of children's counts plus one for the current division: $T.\\text{rc} = s_4.\\text{rc} + s_2.\\text{rc} + 1 = 0 + 1 + 1 = 2$.\n        The static flag count is the sum of children's counts: $T.\\text{sf} = s_4.\\text{sf} + s_2.\\text{sf} = 1 + 0 = 1$.\n        $A(s_6) = (\\text{false}, \\bot, 2, 1)$.\n        A runtime check is added.\n\n4.  **Root expression:**\n    -   $s_7 = \\big((8 \\div (4 - 4)) \\div (7 \\div 1)\\big) \\div \\big(x \\div (2 - 3)\\big)$: This is $s_6 \\div s_5$. The operands are $s_6$ with $A(s_6) = (\\text{false}, \\bot, 2, 1)$ and $s_5$ with $A(s_5) = (\\text{false}, \\bot, 1, 0)$. The denominator $s_5$ is not constant.\n        Applying the \"Else\" part of the rule for $T \\to T_1 \\div F_2$:\n        The condition $T.\\text{is\\_const}$ is false because both operands are not constant.\n        The runtime check count is $T.\\text{rc} = s_6.\\text{rc} + s_5.\\text{rc} + 1 = 2 + 1 + 1 = 4$.\n        The static flag count is $T.\\text{sf} = s_6.\\text{sf} + s_5.\\text{sf} = 1 + 0 = 1$.\n        $A(s_7) = (\\text{false}, \\bot, 4, 1)$.\n        A runtime check is added.\n\nSummary of divisions and their checks:\n-   $8 \\div (4-4)$: Denominator is constant $0 \\implies$ static flag. ($\\text{rc}=0$)\n-   $7 \\div 1$: Denominator is constant non-zero $\\implies$ runtime check. ($\\text{rc}=1$)\n-   $x \\div (2-3)$: Denominator is constant non-zero $\\implies$ runtime check. ($\\text{rc}=1$)\n-   $(...) \\div (7 \\div 1)$: Denominator is constant non-zero $\\implies$ runtime check. ($\\text{rc}=1$)\n-   $(...) \\div (x \\div (2-3))$: Denominator is not constant $\\implies$ runtime check. ($\\text{rc}=1$)\n\nThe total number of runtime checks is the sum of checks for each division that does not have a constant zero denominator: $0 + 1 + 1 + 1 + 1 = 4$.\nThe final value of the `rc` attribute at the root of the parse tree is $4$.", "answer": "$$\\boxed{4}$$", "id": "3673782"}]}