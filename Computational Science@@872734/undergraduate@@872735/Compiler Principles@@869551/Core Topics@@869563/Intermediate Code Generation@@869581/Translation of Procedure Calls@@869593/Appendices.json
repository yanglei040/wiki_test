{"hands_on_practices": [{"introduction": "The activation record, or stack frame, is the cornerstone of procedure call implementation, organizing local variables, parameters, and control information on the runtime stack. The size of this frame, and consequently the total stack space a program consumes, is profoundly affected by the chosen parameter passing convention. This practice ([@problem_id:3678364]) will guide you through a simulation of stack behavior to quantify the stark difference between passing large data structures by value versus by reference, a fundamental trade-off between performance and memory usage.", "problem": "A machine implements a downward-growing runtime stack for procedure calls. The following core facts and definitions govern its execution model.\n\n- The runtime stack holds activation records (also called stack frames) for active procedures. The Stack Pointer (SP) always points to the top of the stack, and pushing $k$ bytes subtracts $k$ from $SP$, while popping $k$ bytes adds $k$ to $SP$. The Frame Pointer (FP) is a stable pointer within the current activation record; it is saved on entry and restored on return.\n- Each call follows a standard caller-push, callee-save convention:\n  1. Caller evaluates and pushes actual parameters for the callee, occupying a total of $P$ bytes.\n  2. The `call` instruction pushes the return address of size $w$ bytes.\n  3. The callee’s prologue pushes the caller’s $FP$ (size $w$), sets $FP \\leftarrow SP$, and subtracts its local storage size $L$ from $SP$.\n  4. On return, the callee’s epilogue adds $L$ back to $SP$, pops the old $FP$ (adding $w$ to $SP$), and executes a `return` instruction. The `return` pops the return address (adding another $w$ to $SP$). Finally, the caller removes the argument block by adding $P$ to $SP$.\n- Pass-by-value copies the actual argument into the callee’s parameter area. Pass-by-reference passes only the address (a pointer) of the actual argument. In both cases, the integer parameter occupies $w$ bytes, and a pointer also occupies $w$ bytes.\n\nConsider two mutually recursive procedures $f$ and $g$ defined as follows. They take two parameters: a structured aggregate $S$ of size $s$ bytes and an integer $n$. The procedures perform simple mutual recursion that terminates when $n \\le 0$.\n\n- Procedure $f(S, n)$:\n  - If $n \\le 0$, return immediately.\n  - Otherwise, call $g(S, n - 1)$ and then return.\n- Procedure $g(S, n)$:\n  - If $n \\le 0$, return immediately.\n  - Otherwise, call $f(S, n - 1)$ and then return.\n\nAssume the following concrete sizes:\n- Word size $w = 8$ bytes.\n- Size of aggregate $s = 48$ bytes.\n- Local storage (including saved callee-saved registers if any) for $f$ is $L_f = 16$ bytes.\n- Local storage for $g$ is $L_g = 24$ bytes.\n- The program starts in a procedure $main$ with local storage $L_{m} = 32$ bytes and no parameters. After setting up its own activation record, $main$ calls $f(S_0, N)$ where $S_0$ is a global aggregate and $N = 4$.\n\nYou are to simulate the stack growth and contents through the entire execution for two separate calling conventions for the first parameter $S$:\n- Scenario A: $S$ is passed by value.\n- Scenario B: $S$ is passed by reference.\n\nFor both scenarios, track the stepwise changes in $SP$ and $FP$ implied by the above convention at each call and return, and determine the maximum downward displacement of $SP$ from its value immediately after $main$’s prologue completes. Then compute the difference between the maxima (Scenario A minus Scenario B). Express your final answer as a single number in bytes. No rounding is required.", "solution": "This problem requires us to analyze the stack space consumed by a series of recursive calls under two different parameter-passing conventions. We need to calculate the maximum stack displacement and then find the difference between the two scenarios.\n\nFirst, let's determine the total stack space consumed by a single procedure call. This displacement is the sum of the sizes of the parameters ($P$), the return address ($w$), the saved frame pointer ($w$), and the local storage ($L$).\n$$ \\text{Displacement per call} = P + w + w + L = P + 2w + L $$\nThe problem asks for the maximum downward displacement of the Stack Pointer ($SP$) relative to its position after `main`'s prologue. The call sequence starts with `main` calling $f(S_0, 4)$, which leads to the following chain of calls until termination:\n$$ f(4) \\to g(3) \\to f(2) \\to g(1) \\to f(0) $$\nThe stack reaches its maximum depth when $f(0)$ is called and its prologue completes. At this point, the activation records for $f(4)$, $g(3)$, $f(2)$, $g(1)$, and $f(0)$ are on the stack. This is a total of 5 nested calls (3 calls to $f$ and 2 calls to $g$).\n\nThe total maximum displacement $D$ is the sum of the displacements for these 5 calls:\n$$ D = 3 \\times (\\text{displacement for } f) + 2 \\times (\\text{displacement for } g) $$\n\n**Scenario A: $S$ is passed by value**\nIn this scenario, the entire aggregate of size $s$ is copied to the stack for each call. The parameter block size $P_A$ is the size of the aggregate plus the size of the integer.\n$$ P_A = s + w = 48 + 8 = 56 \\text{ bytes} $$\nNow we can calculate the displacement for each function call:\n- Displacement for $f$: $\\Delta_{f, A} = P_A + 2w + L_f = 56 + 2(8) + 16 = 56 + 16 + 16 = 88 \\text{ bytes}$\n- Displacement for $g$: $\\Delta_{g, A} = P_A + 2w + L_g = 56 + 2(8) + 24 = 56 + 16 + 24 = 96 \\text{ bytes}$\n\nThe maximum total displacement for Scenario A is:\n$$ D_A = 3 \\times \\Delta_{f, A} + 2 \\times \\Delta_{g, A} = 3(88) + 2(96) = 264 + 192 = 456 \\text{ bytes} $$\n\n**Scenario B: $S$ is passed by reference**\nIn this scenario, only a pointer to the aggregate is passed. The size of a pointer is one word, $w$. The parameter block size $P_B$ is the size of the pointer plus the size of the integer.\n$$ P_B = w + w = 8 + 8 = 16 \\text{ bytes} $$\nThe displacement for each function call is:\n- Displacement for $f$: $\\Delta_{f, B} = P_B + 2w + L_f = 16 + 2(8) + 16 = 16 + 16 + 16 = 48 \\text{ bytes}$\n- Displacement for $g$: $\\Delta_{g, B} = P_B + 2w + L_g = 16 + 2(8) + 24 = 16 + 16 + 24 = 56 \\text{ bytes}$\n\nThe maximum total displacement for Scenario B is:\n$$ D_B = 3 \\times \\Delta_{f, B} + 2 \\times \\Delta_{g, B} = 3(48) + 2(56) = 144 + 112 = 256 \\text{ bytes} $$\n\n**Final Calculation**\nThe problem asks for the difference between the maximum displacements of the two scenarios.\n$$ \\text{Difference} = D_A - D_B = 456 - 256 = 200 \\text{ bytes} $$\nAlternatively, we can note that the difference per call is only in the parameter size, $P_A - P_B = (s+w) - (w+w) = s-w = 48 - 8 = 40$ bytes. Since there are 5 calls in total at maximum depth, the total difference is $5 \\times 40 = 200$ bytes.", "answer": "$$\n\\boxed{200}\n$$", "id": "3678364"}, {"introduction": "While the stack provides the space for communication, the precise rules are dictated by an Application Binary Interface (ABI), which acts as a contract between caller and callee. A critical part of this contract is argument marshalling, especially when integer types of different bit-widths are involved. This exercise ([@problem_id:3678301]) focuses on the crucial ABI rules of sign-extension for signed types and zero-extension for unsigned types, challenging you to ensure that integer values are passed correctly into wider machine registers.", "problem": "Consider a $64$-bit architecture whose Application Binary Interface (ABI) requires that all integer arguments narrower than the machine register width be extended to $64$ bits at the call site before being placed into the argument registers. The rule is: signed narrow integers must be sign-extended to $64$ bits and unsigned narrow integers must be zero-extended to $64$ bits. The callee will read the arguments from its $64$-bit argument registers. Assume two’s-complement representation for all signed integers and that machine registers interpret bitwise operations in the standard manner for two’s-complement arithmetic.\n\nYou are compiling a call from a caller procedure to a callee procedure $g$ with the following source-level types and values in the caller:\n- A signed $8$-bit integer $a$ with value $-45$.\n- An unsigned $16$-bit integer $b$ with value $0x\\mathrm{F234}$.\n- A signed $32$-bit integer $c$ with value $0x\\mathrm{80001234}$.\n\nThe callee $g$ expects three $64$-bit arguments in its registers $\\mathrm{X0}$, $\\mathrm{X1}$, and $\\mathrm{X2}$, corresponding to the caller’s $a$, $b$, and $c$, respectively. In its prologue, $g$ performs the following verification and computation using bitwise and arithmetic operations on the $64$-bit registers:\n- It computes a canonical sign-extension of the low $8$ bits of $\\mathrm{X0}$ by taking those low $8$ bits and arithmetically extending them to $64$ bits, obtaining a value $x'$.\n- It computes a canonical zero-extension of the low $16$ bits of $\\mathrm{X1}$ by taking those low $16$ bits and logically extending them to $64$ bits, obtaining a value $y'$.\n- It computes a canonical sign-extension of the low $32$ bits of $\\mathrm{X2}$ by taking those low $32$ bits and arithmetically extending them to $64$ bits, obtaining a value $z'$.\n- It forms a penalty term $P$ defined by\n$$\nP \\;=\\; |\\mathrm{X0} - x'| \\;+\\; 2\\,|\\mathrm{X1} - y'| \\;+\\; 3\\,|\\mathrm{X2} - z'| ,\n$$\nwhere $|\\,\\cdot\\,|$ is the absolute value over the signed $64$-bit integers.\n- It returns the $64$-bit integer\n$$\nR \\;=\\; x' \\;+\\; 2y' \\;+\\; 4z' \\;+\\; P .\n$$\n\nYour task is to translate the caller’s procedure call into the callee’s calling convention by inserting the required extensions at the call site, in accordance with the ABI rule stated above, and then determine the exact numeric return value $R$ produced by $g$ for the given $a$, $b$, and $c$ when the call site obeys the ABI. Provide the final answer as a single integer. No rounding is required and no units are involved. Express any intermediate hexadecimal constants and all numbers as mathematical entities wherever relevant, but the final answer must be a single integer.", "solution": "To solve this problem, we must simulate the argument passing and computation according to the specified ABI rules.\n\n**Step 1: Determine the values in registers $\\mathrm{X0}$, $\\mathrm{X1}$, and $\\mathrm{X2}$**\nThe ABI requires extending narrow integers to 64 bits at the call site.\n- **Argument `a` (signed 8-bit, -45) -> $\\mathrm{X0}$**: The 8-bit two's complement of -45 is $0x\\mathrm{D3}$. Since `a` is signed and its most significant bit (MSB) is 1, it must be sign-extended. This means the upper 56 bits are filled with 1s.\n  $$ \\mathrm{X0} = 0x\\mathrm{FFFFFFFFFFFFFFD3} $$\n- **Argument `b` (unsigned 16-bit, $0x\\mathrm{F234}$) -> $\\mathrm{X1}$**: Since `b` is unsigned, it must be zero-extended. The upper 48 bits are filled with 0s.\n  $$ \\mathrm{X1} = 0x\\mathrm{000000000000F234} $$\n- **Argument `c` (signed 32-bit, $0x\\mathrm{80001234}$) -> $\\mathrm{X2}$**: The 32-bit value $0x\\mathrm{80001234}$ has its MSB set to 1, indicating a negative number. It must be sign-extended. The upper 32 bits are filled with 1s.\n  $$ \\mathrm{X2} = 0x\\mathrm{FFFFFFFF80001234} $$\n\n**Step 2: Determine the callee's canonical values $x'$, $y'$, and $z'$**\nThe callee re-computes the extensions from the low bits of the received registers.\n- **Value $x'$**: Callee takes the low 8 bits of $\\mathrm{X0}$ ($0x\\mathrm{D3}$) and sign-extends them. This produces the same value as $\\mathrm{X0}$.\n  $$ x' = 0x\\mathrm{FFFFFFFFFFFFFFD3} \\quad (\\text{decimal value } -45) $$\n- **Value $y'$**: Callee takes the low 16 bits of $\\mathrm{X1}$ ($0x\\mathrm{F234}$) and zero-extends them. This produces the same value as $\\mathrm{X1}$.\n  $$ y' = 0x\\mathrm{000000000000F234} \\quad (\\text{decimal value } 62004) $$\n- **Value $z'$**: Callee takes the low 32 bits of $\\mathrm{X2}$ ($0x\\mathrm{80001234}$) and sign-extends them. This produces the same value as $\\mathrm{X2}$.\n  $$ z' = 0x\\mathrm{FFFFFFFF80001234} \\quad (\\text{decimal value } -2147478988) $$\n\n**Step 3: Calculate the penalty term $P$**\nThe penalty term measures the difference between the value passed by the caller and the canonical value re-computed by the callee. Since the caller correctly followed the ABI, the passed values are already correctly extended.\n$$ \\mathrm{X0} = x', \\quad \\mathrm{X1} = y', \\quad \\mathrm{X2} = z' $$\nTherefore, each term in the penalty calculation is zero.\n$$ P = |\\mathrm{X0} - x'| + 2|\\mathrm{X1} - y'| + 3|\\mathrm{X2} - z'| = |0| + 2|0| + 3|0| = 0 $$\n\n**Step 4: Calculate the final return value $R$**\nThe return value is $R = x' + 2y' + 4z' + P$. We use the decimal values calculated in Step 2.\n$$ R = (-45) + 2(62004) + 4(-2147478988) + 0 $$\n$$ R = -45 + 124008 - 8589915952 $$\n$$ R = 123963 - 8589915952 $$\n$$ R = -8589791989 $$\nThe final return value is $-8589791989$.", "answer": "$$ \\boxed{-8589791989} $$", "id": "3678301"}, {"introduction": "A complete procedure call involves more than just preparing arguments; it requires adhering to strict conventions for register usage for both arguments and return values. This final practice ([@problem_id:3678249]) integrates these concepts by asking you to trace a value through a complete, realistic indirect function call. By simulating the flow from argument preparation to computation in the callee and handling the return value, you will solidify your understanding of how modern ABIs orchestrate the entire process.", "problem": "A compiler must translate a high-level indirect call through a function pointer with signature `int (*p)(int)` on a $64$-bit little-endian machine that follows the System V Application Binary Interface (ABI). The translation must ensure type-safe argument marshalling and correct return handling. Consider the following setting, which specifies only the foundational operational facts needed for reasoning about the calling sequence at the machine interface:\n\n- The Application Binary Interface (ABI) uses the following conventions for integer arguments and return values:\n  - An `int` is a $32$-bit two’s complement integer.\n  - The first integer argument is passed in the low $32$ bits of register $RDI$ (that is, in $EDI$). The caller must marshal the argument by placing the exact $32$-bit two’s complement representation of the `int` into $EDI$. The contents of the upper $32$ bits of $RDI$ are not assumed by the callee.\n  - A function that returns `int` produces its result in $EAX$. Writing to $EAX$ implicitly zero-extends into $RAX$.\n- An indirect call uses the target address in $RAX$: the instruction transfers control to the code at the address contained in $RAX$ and pushes a return address on the run-time stack. You may assume the return address and stack management do not affect any general-purpose argument or return registers relevant to this problem.\n- The Instruction Set Architecture (ISA) is little-endian; all arithmetic in the callee below is performed modulo $2^{32}$ on $EAX$.\n\nThe high-level source contains:\n- A function pointer `p` of type `int (*)(int)` stored at address `0x0000000000403000`.\n- A function `f` located at address `0x0000000000401100`.\n- The pointer `p` is initialized to the address of `f` (that is, memory at `0x0000000000403000` holds the $64$-bit little-endian encoding of `0x0000000000401100`).\n- A call expression `r = (*p)(a);` where `a` is an `int` with value $-123456789$.\n\nThe compiler emits a standard call sequence implementing type-safe marshalling and correct return handling, adhering strictly to the ABI rules stated above:\n- It loads `p`’s $64$-bit value from memory into $RAX$.\n- It moves the $32$-bit two’s complement representation of `a` into $EDI$.\n- It performs the indirect call via $RAX$.\n- It reads the `int` return value from $EAX$ (which is thereby zero-extended in $RAX$).\n\nThe machine code body of `f` (expressed at the level of observable arithmetic effects on $EAX$) is:\n- Copy argument $EDI$ into $EAX$.\n- Compute $EAX \\leftarrow (EAX \\times 3) \\pmod{2^{32}}$.\n- Compute $EAX \\leftarrow (EAX + 1) \\pmod{2^{32}}$.\n- Compute $EAX \\leftarrow EAX \\oplus 0x80000000$.\n- Return, leaving the `int` result in $EAX$ (and thus zero-extended into $RAX$).\n\nUnder these conditions, what is the exact unsigned $64$-bit integer value held in $RAX$ immediately after the call returns to the caller? Express your answer in base $10$ as a single exact integer with no rounding.", "solution": "The problem requires us to trace a value through an indirect function call, respecting the rules of the specified Application Binary Interface (ABI). We will follow the value of the argument `a` from the caller, through the computations in the callee `f`, and finally to the return value in the caller's `RAX` register.\n\n**Step 1: Argument Marshalling**\nThe argument `a` is an `int` with the value $-123456789$. The ABI specifies that an `int` is a 32-bit two's complement integer and that the first argument is passed in the $EDI$ register. We need to find the 32-bit two's complement representation of $-123456789$.\n\nFirst, find the binary representation of the positive value, $123456789$:\n$$ 123456789_{10} = 0x075BCD15 $$\nTo find the two's complement, we invert the bits and add one.\n$$ \\text{NOT}(0x075BCD15) = 0xF8A432EA $$\n$$ 0xF8A432EA + 1 = 0xF8A432EB $$\nSo, the caller places this value into the $EDI$ register.\n$$ EDI \\leftarrow 0xF8A432EB $$\n\n**Step 2: Execution of Function `f`**\nThe function `f` performs its computations in the $EAX$ register. All arithmetic is modulo $2^{32}$.\n\n1.  **Copy argument $EDI$ into $EAX$**:\n    $$ EAX \\leftarrow 0xF8A432EB $$\n\n2.  **Compute $EAX \\leftarrow (EAX \\times 3) \\pmod{2^{32}}$**:\n    We multiply the current value in $EAX$ by 3.\n    $$ 0xF8A432EB \\times 3 = 0x2E9EC98C1 $$\n    Since the arithmetic is modulo $2^{32}$, we take the lower 32 bits of the result.\n    $$ EAX \\leftarrow 0xE9EC98C1 $$\n\n3.  **Compute $EAX \\leftarrow (EAX + 1) \\pmod{2^{32}}$**:\n    We add 1 to the current value of $EAX$.\n    $$ 0xE9EC98C1 + 1 = 0xE9EC98C2 $$\n    $$ EAX \\leftarrow 0xE9EC98C2 $$\n\n4.  **Compute $EAX \\leftarrow EAX \\oplus 0x80000000$**:\n    We perform a bitwise XOR with $0x80000000$. This flips the most significant bit (bit 31) of the 32-bit value. The current value is $0xE9EC98C2$, which in binary starts with $1110...$. Flipping the first bit changes it to $0110...$, which is `6` in hexadecimal.\n    $$ 0xE9EC98C2 \\oplus 0x80000000 = 0x69EC98C2 $$\n    This is the final value in $EAX$ before `f` returns.\n\n**Step 3: Return Value Handling**\nThe ABI states that when a 32-bit value is written to $EAX$, it is implicitly zero-extended into the 64-bit $RAX$ register. This means the upper 32 bits of $RAX$ are set to zero.\nAfter `f` returns, the value in $RAX$ will be:\n$$ RAX \\leftarrow 0x0000000069EC98C2 $$\n\n**Step 4: Final Conversion**\nThe problem asks for the final unsigned 64-bit integer value in $RAX$, expressed in base 10. We convert the hexadecimal value $0x69EC98C2$ to decimal.\n$$ 0x69EC98C2 = 6 \\cdot 16^7 + 9 \\cdot 16^6 + 14 \\cdot 16^5 + 12 \\cdot 16^4 + 9 \\cdot 16^3 + 8 \\cdot 16^2 + 12 \\cdot 16^1 + 2 \\cdot 16^0 $$\n$$ = 1610612736 + 150994944 + 14680064 + 786432 + 36864 + 2048 + 192 + 2 $$\n$$ = 1777113282 $$\nThe final unsigned value in $RAX$ is $1777113282$.", "answer": "$$\\boxed{1777113282}$$", "id": "3678249"}]}