{"hands_on_practices": [{"introduction": "The core of Global Common Subexpression Elimination (GCSE) is identifying when two syntactically different expressions will always compute the same value. This practice delves into that foundational concept by examining how a compiler's choice of algebraic rules, or normalization policies, affects its ability to prove expression equivalence. By comparing a policy based on commutativity alone versus one that also understands associativity, you will gain a concrete understanding of how value numbering establishes congruence classes to find optimization opportunities. [@problem_id:3644049]", "problem": "Consider a straight-line fragment of a program in a three-address Intermediate Representation (IR) with a Control-Flow Graph (CFG), where variables $a$, $b$, $c$, and $d$ are parameters defined at procedure entry and never reassigned. The CFG consists of four basic blocks $B_0$, $B_1$, $B_2$, and $B_3$, connected as follows: $B_0$ is the unique entry and branches to both $B_1$ and $B_2$; both $B_1$ and $B_2$ flow into $B_3$. All computations are pure, and operator $+$ is integer addition. The IR statements are:\n\nIn $B_1$:\n- $e_1 \\leftarrow a + (b + c)$\n- $e_2 \\leftarrow (a + b) + c$\n\nIn $B_2$:\n- $e_3 \\leftarrow (b + c) + a$\n- $e_4 \\leftarrow (c + a) + b$\n\nIn $B_3$:\n- $e_5 \\leftarrow a + (c + b)$\n- $e_6 \\leftarrow (a + c) + b$\n- $e_7 \\leftarrow a + (b + d)$\n- $e_8 \\leftarrow (a + b) + c$\n- $e_9 \\leftarrow a + (b + c)$\n\nAssume Global Common Subexpression Elimination (GCSE) is performed using global value numbering across the CFG, and that the language semantics permit algebraic normalization of addition according to the chosen policy. You will compare two normalization policies used by the value numbering:\n\n- Policy $\\mathcal{C}$: Canonicalize only commutativity of each binary $+$ node independently (for any $x$ and $y$, $x + y$ is canonically represented as a sorted pair of operands), without using associativity across different $+$ nodes.\n- Policy $\\mathcal{AC}$: Canonicalize both associativity and commutativity of $+$ by first flattening nested additions into a multiset of operands and then sorting that multiset.\n\nStarting from the foundational definitions that (i) a congruence class groups IR expressions that are provably equal under the chosen normalization and program semantics, and (ii) global value numbering must assign the same value number to all members of a congruence class regardless of their basic blocks, determine, for the set of all nine right-hand-side expressions $E = \\{a + (b + c), (a + b) + c, (b + c) + a, (c + a) + b, a + (c + b), (a + c) + b, a + (b + d), (a + b) + c, a + (b + c)\\}$ appearing in $B_1$, $B_2$, and $B_3$:\n\n- $K_{\\mathcal{C}}$: the number of distinct congruence classes under policy $\\mathcal{C}$,\n- $K_{\\mathcal{AC}}$: the number of distinct congruence classes under policy $\\mathcal{AC}}$.\n\nCompute the single quantity $K_{\\mathcal{C}} - K_{\\mathcal{AC}}$. Provide your final answer as an exact integer. No rounding is required.", "solution": "The problem requires us to determine the number of distinct congruence classes for a given set of nine expressions under two different normalization policies, $\\mathcal{C}$ and $\\mathcal{AC}$. A congruence class groups expressions that are proven to be equivalent. The number of such classes is the number of unique canonical forms the expressions can be reduced to under a given policy. The set of nine right-hand-side expressions, denoted $E$, is:\n$E = \\{a + (b + c), (a + b) + c, (b + c) + a, (c + a) + b, a + (c + b), (a + c) + b, a + (b + d), (a + b) + c, a + (b + c)\\}$.\nThe number of congruence classes depends on the set of unique expressions within $E$. Let $S$ be the set of syntactically distinct expressions in $E$.\n$S = \\{a + (b + c), (a + b) + c, (b + c) + a, (c + a) + b, a + (c + b), (a + c) + b, a + (b + d)\\}$.\nWe will partition this set $S$ according to each policy.\n\n**Analysis under Policy $\\mathcal{C}$ (Commutativity Only)**\n\nPolicy $\\mathcal{C}$ allows for canonicalization based on the commutativity of the addition operator `+` at each node in an expression's syntax tree, but not associativity. This means for any subexpression $x+y$, its canonical form is determined by sorting its operands. We assume an alphabetical ordering for the variables, i.e., $a < b < c < d$. An expression involving a subexpression, such as $a + (b+c)$, is treated as an operation on the atom $a$ and the value represented by $(b+c)$.\n\nLet's derive the canonical form for each unique expression in $S$:\n1.  For $a + (b + c)$: The inner subexpression is $b+c$. Its canonical form is $b+c$. The outer expression is $a$ plus the result of the inner one. So the canonical form of the entire expression is $a + (b+c)$.\n\n2.  For $(a + b) + c$: The inner subexpression is $a+b$. Its canonical form is $a+b$. The outer expression adds $c$ to this result. The canonical form is $(a+b) + c$. This structural form is distinct from the previous one.\n\n3.  For $(b + c) + a$: The inner subexpression $b+c$ is canonical. The outer expression is $($result of $b+c) + a$. Applying commutativity, we sort the operands to get $a + (b+c)$, which is identical to the canonical form of the first expression.\n\n4.  For $(c + a) + b$: The inner subexpression $c+a$ canonicalizes to $a+c$. The full expression's canonical form is $(a+c)+b$. This is a new structural form.\n\n5.  For $a + (c + b)$: The inner subexpression $c+b$ canonicalizes to $b+c$. The full expression's canonical form is $a + (b+c)$, identical to the first expression.\n\n6.  For $(a + c) + b$: The inner subexpression $a+c$ is canonical. The canonical form of the full expression is $(a+c)+b$, identical to the fourth expression.\n\n7.  For $a + (b + d)$: The inner subexpression $b+d$ is canonical. The full expression's canonical form is $a+(b+d)$. This is a new form as it involves the variable $d$.\n\nWe have identified the following distinct canonical forms under Policy $\\mathcal{C}$:\n- Class 1: $a + (b+c)$, which represents $\\{a + (b + c), (b + c) + a, a + (c + b)\\}$.\n- Class 2: $(a+b)+c$, which represents $\\{(a + b) + c\\}$.\n- Class 3: $(a+c)+b$, which represents $\\{(c + a) + b, (a + c) + b\\}$.\n- Class 4: $a+(b+d)$, which represents $\\{a + (b + d)\\}$.\n\nThere are $4$ distinct congruence classes. Therefore, $K_{\\mathcal{C}} = 4$.\n\n**Analysis under Policy $\\mathcal{AC}$ (Associativity and Commutativity)**\n\nPolicy $\\mathcal{AC}$ treats nested additions as a single $n$-ary operation. The canonical form is derived by flattening the expression into a multiset of its base variable operands and then sorting this multiset.\n\nLet's apply this policy to the expressions in $S$:\n1.  For $a + (b + c)$: Flattening yields the multiset $\\{a, b, c\\}$. The sorted list of operands is $(a, b, c)$.\n2.  For $(a + b) + c$: Flattening yields $\\{a, b, c\\}$. The sorted list is $(a, b, c)$.\n3.  For $(b + c) + a$: Flattening yields $\\{b, c, a\\}$. The sorted list is $(a, b, c)$.\n4.  For $(c + a) + b$: Flattening yields $\\{c, a, b\\}$. The sorted list is $(a, b, c)$.\n5.  For $a + (c + b)$: Flattening yields $\\{a, c, b\\}$. The sorted list is $(a, b, c)$.\n6.  For $(a + c) + b$: Flattening yields $\\{a, c, b\\}$. The sorted list is $(a, b, c)$.\n\nAll six expressions listed above are equivalent under Policy $\\mathcal{AC}$, as they all reduce to the canonical form represented by the sorted operand list $(a, b, c)$.\n\n7.  For $a + (b + d)$: Flattening yields the multiset $\\{a, b, d\\}$. The sorted list of operands is $(a, b, d)$. This is a distinct canonical form because it contains $d$ instead of $c$.\n\nUnder Policy $\\mathcal{AC}$, we have identified two distinct canonical forms:\n- Class 1: Represented by $(a, b, c)$, which includes all expressions from $S$ except $a+(b+d)$.\n- Class 2: Represented by $(a, b, d)$, which corresponds to the expression $a+(b+d)$.\n\nThere are $2$ distinct congruence classes. Therefore, $K_{\\mathcal{AC}} = 2$.\n\n**Final Calculation**\n\nThe problem asks for the value of $K_{\\mathcal{C}} - K_{\\mathcal{AC}}$. Based on our analysis:\n$K_{\\mathcal{C}} = 4$\n$K_{\\mathcal{AC}} = 2$\n\nThe final result is $K_{\\mathcal{C}} - K_{\\mathcal{AC}} = 4 - 2 = 2$.", "answer": "$$\\boxed{2}$$", "id": "3644049"}, {"introduction": "While expressions like $a * b$ may appear identical, their safety for elimination is complicated by memory operations and function calls in real-world programs. This exercise explores the critical role of memory alias analysis in determining whether a function call might invalidate a previously computed value by modifying its operands through pointers. You will analyze why a compiler must be conservative in the face of uncertainty and how precise interprocedural analysis enables more aggressive optimization without sacrificing program correctness. [@problem_id:3643954]", "problem": "Consider the following straight-line fragment in a language with first-class functions and pointers. Variables $a$ and $b$ denote integers stored in memory (e.g., globals or heap-located), and $t_1$ and $t_2$ are temporaries. The function call callee may have memory side effects.\n\nCode:\n- $S_1$: $t_1 \\leftarrow a * b$\n- $C$: call callee$(q)$\n- $S_2$: $t_2 \\leftarrow a * b$\n- use$(t_1)$; use$(t_2)$\n\nAssumptions:\n- The pointer $q$ may or may not point to the storage locations of $a$ or $b$; this depends on alias information.\n- The function callee may write to memory reachable from $q$, and may also have other side effects not involving $q$ only if so specified.\n- No undefined behavior occurs.\n- The goal is to perform Global Common Subexpression Elimination (GCSE), using standard data flow concepts: an expression $e$ is available at a program point $p$ if along all paths to $p$, $e$ has been computed and not invalidated; a statement is transparent with respect to $e$ if it does not modify any operand or any memory location on which those operands depend.\n\nBase definitions you may use:\n- An expression $x * y$ is killed at a program point if a statement at that point may modify the value of $x$ or $y$ (including via memory effects).\n- In the absence of precise alias information, a call that may write through a pointer that could alias an operand’s storage must be conservatively assumed to modify that operand.\n- Static Single Assignment (SSA) form renames definitions of scalar variables but does not, by itself, capture memory aliasing or side effects; memory effects require separate modeling (e.g., memory SSA or mod/ref analysis).\n\nSelect all statements that are correct about safe GCSE placement for the expression $a * b$ in this code under the indicated alias assumptions.\n\nA. Under a conservative may-alias model where $q$ may point to the storage of $a$ or $b$, the call at $C$ is not transparent for $a * b$, so $a * b$ is not available after $C$. Eliminating $S_2$ or moving it above $C$ is unsafe.\n\nB. If interprocedural mod/ref and alias analysis proves that callee neither writes to the storage of $a$ nor $b$ (and has no other side effects affecting them), then the call at $C$ is transparent for $a * b$, and GCSE may compute $a * b$ once before $C$ and reuse that value after $C$.\n\nC. Even when $q$ may alias $a$ or $b$, saving the pre-call value of $a * b$ into a temporary at $S_1$ and reusing it after $C$ is always safe, because temporaries are not affected by aliasing.\n\nD. Converting the code to Static Single Assignment (SSA) form and applying Global Value Numbering (GVN) is sufficient to reuse the pre-call value of $a * b$ after $C$ even without alias information.\n\nE. When aliasing is unknown, a safe conservative approximation for GCSE is to treat callee as read-only with respect to $a$ and $b$, allowing elimination of $S_2$ by reusing the value from $S_1$ across $C$.", "solution": "### Solution Derivation\n\nThe central issue is whether the common subexpression $a * b$ can be eliminated. The second computation, $S_2: t_2 \\leftarrow a * b$, can be replaced by $t_2 \\leftarrow t_1$ if and only if the expression $a * b$ is *available* immediately before $S_2$. According to the provided definition, an expression is available if it has been computed and its operands have not been modified since the computation.\n\nHere, $a * b$ is computed at $S_1$. The only intervening statement is the function call $C$: call callee$(q)$. Therefore, the safety of the optimization hinges entirely on whether the call to `callee` can modify the values of the operands $a$ or $b$. Since $a$ and $b$ are stored in memory, this is a question of memory side effects and aliasing.\n\n- The expression $a * b$ is *generated* at statement $S_1$.\n- To be available before $S_2$, the expression must not be *killed* by the call at $C$.\n- The expression $a * b$ is killed by the call at $C$ if `callee` might modify the memory location of $a$ or the memory location of $b$.\n\nWith this framework, each option is evaluated.\n\n**A. Under a conservative may-alias model where $q$ may point to the storage of $a$ or $b$, the call at $C$ is not transparent for $a * b$, so $a * b$ is not available after $C$. Eliminating $S_2$ or moving it above $C$ is unsafe.**\n\nThis statement describes the standard conservative approach to compiler optimization. In the absence of definitive information to the contrary (i.e., a \"no-alias\" proof), a \"may-alias\" situation requires the compiler to assume the worst case for safety.\n- **Assumption:** `callee` may write to memory via pointer $q$, and $q$ may alias $a$ or $b$.\n- **Implication:** The call at $C$ must be assumed to potentially modify the values of $a$ and/or $b$.\n- **Consequence:** If the operands $a$ or $b$ are modified, the expression $a * b$ is killed by the call. The call is therefore not transparent with respect to $a * b$. Consequently, the value computed at $S_1$ is not guaranteed to be equivalent to the value that would be computed at $S_2$. The expression is not available after $C$.\n- **Safety:** Eliminating $S_2$ and using $t_1$ instead would be an unsafe optimization, as it could lead to using a stale value, thus altering the program's semantics. The statement is a correct application of conservative data-flow analysis principles.\n\n**Verdict on A: Correct**\n\n**B. If interprocedural mod/ref and alias analysis proves that callee neither writes to the storage of $a$ nor $b$ (and has no other side effects affecting them), then the call at $C$ is transparent for $a * b$, and GCSE may compute $a * b$ once before $C$ and reuse that value after $C$.**\n\nThis statement describes a scenario with more precise, powerful program analysis.\n- **Assumption:** A sound analysis has proven that `callee` does not modify the memory locations of $a$ and $b$. This is what \"mod/ref\" (modification/reference) analysis aims to determine.\n- **Implication:** The call at $C$ does not modify the operands of the expression $a * b$.\n- **Consequence:** The call is transparent with respect to the expression $a * b$. The expression is not killed by the call.\n- **Safety:** Since the expression computed at $S_1$ is not invalidated by the call, it remains available at point $S_2$. Therefore, GCSE is safe. The computation at $S_2$ is redundant and can be eliminated by reusing the result from $S_1$. This is the primary motivation for performing expensive interprocedural analyses.\n\n**Verdict on B: Correct**\n\n**C. Even when $q$ may alias $a$ or $b$, saving the pre-call value of $a * b$ into a temporary at $S_1$ and reusing it after $C$ is always safe, because temporaries are not affected by aliasing.**\n\nThis statement misinterprets the goal of GCSE. The point of the optimization is not just to reuse a value, but to reuse the *correct* value while preserving program semantics.\n- **Logic:** The statement correctly observes that the temporary variable $t_1$ is likely not aliased by $q$. Thus, the value *in* $t_1$ is not directly changed by the call.\n- **Flaw:** However, GCSE aims to replace the computation $t_2 \\leftarrow a * b$ (which, after the call, would use the potentially modified values of $a$ and $b$) with the result from $S_1$. If `callee` modifies $a$ to $a'$, the correct value for $t_2$ should be $a' * b$. The value in $t_1$ is $a * b$. Reusing $t_1$ for $t_2$ would be semantically incorrect. The transformation is safe only if the values of the operands are unchanged, which is not guaranteed under the stated conditions. The statement confuses the safety of the temporary's storage with the semantic validity of the value it holds.\n\n**Verdict on C: Incorrect**\n\n**D. Converting the code to Static Single Assignment (SSA) form and applying Global Value Numbering (GVN) is sufficient to reuse the pre-call value of $a * b$ after $C$ even without alias information.**\n\nThis statement overstates the power of standard SSA and GVN.\n- **SSA for Scalars:** Standard SSA form provides unique names for each definition of a *scalar* variable. It does not natively model memory. The variables $a$ and $b$ are explicitly stated to be in memory. A naive SSA translation that treats them as scalars would be unsound.\n- **Modeling Memory:** To handle memory correctly, SSA must be extended (e.g., with Memory SSA). In such a model, the state of memory is threaded through the program like a variable. The call at $C$ would be modeled as taking the pre-call memory state ($Mem_{in}$) and producing a post-call memory state ($Mem_{out}$). The expression at $S_1$ depends on loads from $Mem_{in}$, while the expression at $S_2$ depends on loads from $Mem_{out}$. Without alias information, the compiler cannot prove that a load of $a$ from $Mem_{in}$ is equivalent to a load of $a$ from $Mem_{out}$. GVN would therefore assign different value numbers to the two expressions. Thus, standard SSA/GVN is insufficient without alias analysis.\n\n**Verdict on D: Incorrect**\n\n**E. When aliasing is unknown, a safe conservative approximation for GCSE is to treat callee as read-only with respect to $a$ and $b$, allowing elimination of $S_2$ by reusing the value from $S_1$ across $C$.**\n\nThis statement incorrectly defines \"conservative approximation.\"\n- **Conservative vs. Optimistic:** A conservative approximation in optimization must assume the worst-case scenario to guarantee correctness. For an operation that could have side effects (like the call to `callee`), the worst case is that it *does* have side effects that invalidate subsequent computations. Assuming the call is read-only (i.e., has no side effects on $a$ and $b$) is an *optimistic* assumption.\n- **Safety:** Making an optimistic assumption when information is lacking is inherently unsafe. A compiler that did this would generate incorrect code for any program where `callee` did, in fact, modify $a$ or $b$. The correct conservative approach is to assume the call kills the expression, as stated in option A.\n\n**Verdict on E: Incorrect**\n\nIn summary, statements A and B correctly describe the conditions for compiler safety under conservative and precise analysis, respectively. Statements C, D, and E contain fundamental misconceptions about optimization safety, the semantics of temporaries, the limitations of SSA, and the definition of a conservative approximation.", "answer": "$$\\boxed{AB}$$", "id": "3643954"}, {"introduction": "Often, an expression is computed on some, but not all, paths leading to a potential reuse site, which blocks simple elimination. This scenario requires the compiler to actively transform the program's control flow structure to make the expression fully available. This practice challenges you to apply edge splitting, a key technique to resolve this issue on \"critical edges,\" thereby enabling GCSE while respecting important semantic constraints like avoiding speculative execution of potentially trapping instructions. [@problem_id:3644037]", "problem": "Consider a function in three-address code form, represented by a Control Flow Graph (CFG). A Control Flow Graph (CFG) is a directed graph whose nodes are basic blocks and edges represent possible control transfers between blocks. A node $B_x$ is said to dominate a node $B_y$ if every path from the entry to $B_y$ goes through $B_x$. An edge $(B_p,B_s)$ is a critical edge if $B_p$ has two or more successors and $B_s$ has two or more predecessors. In Static Single Assignment (SSA) form, each variable is assigned exactly once, and join points use $\\phi$-functions to merge values from different predecessors.\n\nYou are given the following CFG structure with basic blocks and statements, where $+$ denotes integer addition that may raise an overflow exception under the source language semantics. Therefore, speculative execution of $+$ on paths where it did not originally execute is not permitted. Assume that $a$ and $b$ are defined in a unique dominating entry block $B_0$, neither $a$ nor $b$ is redefined in any of the blocks $B_1$, $B_2$, $B_3$, $B_5$, and $B_4$, and both $a$ and $b$ reach all uses. All variables are in SSA form except where $\\phi$-functions are introduced in this transformation.\n\nCFG skeleton:\n- $B_0$: defines $a$ and $b$, then branches to $B_1$.\n- $B_1$: evaluates a predicate $cond$ and branches to $B_2$ on true and to $B_3$ on false.\n- $B_2$: computes $t_1 := a + b$, then unconditionally branches to $B_4$.\n- $B_3$: does not redefine $a$ or $b$, evaluates a predicate $cond_2$, and branches to $B_4$ on true and to $B_5$ on false.\n- $B_5$: does not redefine $a$ or $b$, then unconditionally branches to $B_4$.\n- $B_4$: computes $t_2 := a + b$, then uses $t_2$.\n\nObserve that $t_2 := a + b$ in $B_4$ duplicates the computation performed in $B_2$, but that computation is only available along the path through $B_2$. Because $+$ may trap, you must not move $a + b$ to a block where it did not execute originally. You are to enable Global Common Subexpression Elimination (GCSE) of $t_2 := a + b$ at $B_4$ without changing the program’s observable behavior, by making $a + b$ available along all paths to $B_4$ via legal insertions. Insertions on edges require edge splitting if the edge is critical.\n\nWhich of the following transformations is the minimal semantics-preserving change that enables eliminating the recomputation $t_2 := a + b$ in $B_4$ via a $\\phi$-merged value, under the constraints above?\n\nA. Split the critical edge $(B_3,B_4)$ by creating a new block $S_{34}$ placed on that edge. In $S_{34}$, insert $t_3 := a + b$ and branch to $B_4$. Also insert $t_4 := a + b$ at the end of $B_5$ (before branching to $B_4$). In $B_4$, replace $t_2 := a + b$ with $t := \\phi(B_2 \\mapsto t_1,\\ S_{34} \\mapsto t_3,\\ B_5 \\mapsto t_4)$ and use $t$.\n\nB. Split only the edge $(B_2,B_4)$ by creating a new block $S_{24}$ on that edge and moving $t_1 := a + b$ from $B_2$ into $S_{24}$. Leave $(B_3,B_4)$ and $(B_5,B_4)$ unchanged. In $B_4$, replace $t_2 := a + b$ with $t := \\phi(S_{24} \\mapsto t_1,\\ B_3 \\mapsto \\bot,\\ B_5 \\mapsto \\bot)$ and use $t$, where $\\bot$ denotes no available value.\n\nC. Without splitting any edges, hoist $a + b$ from $B_2$ to $B_1$ by inserting $t_h := a + b$ at the end of $B_1$. Remove $t_1 := a + b$ from $B_2$ and replace $t_2 := a + b$ in $B_4$ with the already computed $t_h$.\n\nD. Split both $(B_3,B_4)$ and $(B_5,B_4)$ by creating new blocks $S_{34}$ and $S_{54}$ on those edges. Insert $t_3 := a + b$ in $S_{34}$ and $t_4 := a + b$ in $S_{54}$. Also move $t_1 := a + b$ from $B_2$ into a new split block $S_{24}$ on $(B_2,B_4)$. In $B_4$, replace $t_2 := a + b$ with $t := \\phi(S_{24} \\mapsto t_1,\\ S_{34} \\mapsto t_3,\\ S_{54} \\mapsto t_4)$ and use $t$.\n\nChoose the best option.", "solution": "The objective is to eliminate the redundant computation $t_2 := a + b$ in basic block $B_4$ by ensuring the value of $a+b$ is available upon entry to $B_4$ from all predecessor paths. This requires a transformation that is both semantics-preserving and minimal.\n\nFirst, we analyze the Control Flow Graph (CFG) structure and the paths to $B_4$.\nThe basic blocks and their control flow are:\n- $B_0 \\to B_1$\n- $B_1 \\to B_2$ (if $cond$ is true), $B_1 \\to B_3$ (if $cond$ is false)\n- $B_2 \\to B_4$\n- $B_3 \\to B_4$ (if $cond_2$ is true), $B_3 \\to B_5$ (if $cond_2$ is false)\n- $B_5 \\to B_4$\nThe predecessors of $B_4$ are $\\{B_2, B_3, B_5\\}$. The computation $a+b$ exists in $B_2$ (as $t_1$) and is recomputed in $B_4$ (as $t_2$). To eliminate the recomputation, the value of $a+b$ must be available along all three paths into $B_4$.\n1. Path $... \\to B_2 \\to B_4$: The expression $a+b$ is computed as $t_1$ in $B_2$. The value is available.\n2. Path $... \\to B_3 \\to B_4$: The expression $a+b$ is not computed. We must insert a computation $t_3 := a+b$ on this path.\n3. Path $... \\to B_5 \\to B_4$: The expression $a+b$ is not computed. We must insert a computation $t_4 := a+b$ on this path.\n\nNext, we consider the constraints.\n- **No speculative execution**: The operation `+` may trap. Therefore, we cannot move the computation $a+b$ to a block where it would execute on a path that did not originally contain it. For example, hoisting $a+b$ to $B_1$ is illegal, as it would execute speculatively for the control flow path $B_1 \\to B_3 \\to ...$, where it was not present originally. This rules out simple hoisting.\n- **Code placement on edges**: Inserting computations \"on an edge\" is the correct approach. The problem specifies that an edge $(B_p, B_s)$ is critical if $B_p$ has two or more successors and $B_s$ has two or more predecessors. Code insertion on a critical edge requires *edge splitting*: creating a new basic block on the edge to hold the inserted code.\n\nLet's identify the critical edges into $B_4$:\n- Predecessors of $B_4$: $\\{B_2, B_3, B_5\\}$. Thus, $B_4$ has $3$ predecessors.\n- Successors of $B_2$: $\\{B_4\\}$. $B_2$ has $1$ successor. Edge $(B_2, B_4)$ is **not** critical.\n- Successors of $B_3$: $\\{B_4, B_5\\}$. $B_3$ has $2$ successors. Edge $(B_3, B_4)$ is **critical**.\n- Successors of $B_5$: $\\{B_4\\}$. $B_5$ has $1$ successor. Edge $(B_5, B_4)$ is **not** critical.\n\nBased on this analysis, the required insertions are:\n- For the path from $B_3$ to $B_4$: a computation must be inserted on the edge $(B_3, B_4)$. Since this edge is critical, it must be split. A new block, say $S_{34}$, is created. The edge $(B_3, B_4)$ is replaced by two edges, $(B_3, S_{34})$ and $(S_{34}, B_4)$. The computation $t_3 := a+b$ is placed in $S_{34}$.\n- For the path from $B_5$ to $B_4$: a computation must be inserted on the edge $(B_5, B_4)$. Since this edge is not critical, we do not need to split it. The computation $t_4 := a+b$ can be placed at the end of block $B_5$, just before the branch to $B_4$.\n\nAfter these transformations, the expression $a+b$ is available on all paths to $B_4$. Block $B_4$ now has predecessors $\\{B_2, S_{34}, B_5\\}$. The redundant computation can be replaced by a $\\phi$-function that merges the values:\nIn $B_4$: replace $t_2 := a+b$ with $t := \\phi(B_2 \\mapsto t_1, S_{34} \\mapsto t_3, B_5 \\mapsto t_4)$.\n\nThis set of changes is minimal because splitting the critical edge is required by rule, and adding computations to cover the missing paths is necessary to make the expression fully available.\n\nNow, we evaluate the given options.\n\n**A. Split the critical edge $(B_3,B_4)$ by creating a new block $S_{34}$ placed on that edge. In $S_{34}$, insert $t_3 := a + b$ and branch to $B_4$. Also insert $t_4 := a + b$ at the end of $B_5$ (before branching to $B_4$). In $B_4$, replace $t_2 := a + b$ with $t := \\phi(B_2 \\mapsto t_1,\\ S_{34} \\mapsto t_3,\\ B_5 \\mapsto t_4)$ and use $t$.**\nThis option perfectly matches our derived minimal and correct transformation. It correctly identifies the critical edge $(B_3, B_4)$, splits it, and inserts the computation in the new block $S_{34}$. It correctly handles the non-critical path from $B_5$ by inserting the computation into $B_5$. Finally, it constructs the correct $\\phi$-function in $B_4$ using the now-valid predecessors.\n**Verdict: Correct.**\n\n**B. Split only the edge $(B_2,B_4)$ by creating a new block $S_{24}$ on that edge and moving $t_1 := a + b$ from $B_2$ into $S_{24}$. Leave $(B_3,B_4)$ and $(B_5,B_4)$ unchanged. In $B_4$, replace $t_2 := a + b$ with $t := \\phi(S_{24} \\mapsto t_1,\\ B_3 \\mapsto \\bot,\\ B_5 \\mapsto \\bot)$ and use $t$, where $\\bot$ denotes no available value.**\nThis transformation is flawed. It fails to make the expression $a+b$ available on the paths from $B_3$ and $B_5$. A $\\phi$-function in standard SSA form requires a valid variable from each predecessor path. The use of $\\bot$ signifies that the value is not available, which means the common subexpression cannot be eliminated. The goal of the transformation is not met.\n**Verdict: Incorrect.**\n\n**C. Without splitting any edges, hoist $a + b$ from $B_2$ to $B_1$ by inserting $t_h := a + b$ at the end of $B_1$. Remove $t_1 := a + b$ from $B_2$ and replace $t_2 := a + b$ in $B_4$ with the already computed $t_h$.**\nThis transformation violates the constraint of no speculative execution. Placing $t_h := a+b$ in $B_1$ causes it to be executed on the path $B_1 \\to B_3$, on which it did not originally execute. Since the `+` operation may trap, this changes the program's observable behavior if an overflow occurs on that path.\n**Verdict: Incorrect.**\n\n**D. Split both $(B_3,B_4)$ and $(B_5,B_4)$ by creating new blocks $S_{34}$ and $S_{54}$ on those edges. Insert $t_3 := a + b$ in $S_{34}$ and $t_4 := a + b$ in $S_{54}$. Also move $t_1 := a + b$ from $B_2$ into a new split block $S_{24}$ on $(B_2,B_4)$. In $B_4$, replace $t_2 := a + b$ with $t := \\phi(S_{24} \\mapsto t_1,\\ S_{34} \\mapsto t_3,\\ S_{54} \\mapsto t_4)$ and use $t$.**\nThis transformation is semantics-preserving and achieves the goal of enabling GCSE. However, it is not minimal. It splits the non-critical edges $(B_2, B_4)$ and $(B_5, B_4)$ unnecessarily. As established, code can be placed at the end of $B_5$ without splitting the edge, and the computation in $B_2$ does not need to be moved at all. This option creates $3$ new blocks, whereas option A creates only $1$. Therefore, this solution is not minimal.\n**Verdict: Incorrect.**\n\nBased on the analysis, option A is the only one that describes a transformation that is correct, semantics-preserving, and minimal.", "answer": "$$\\boxed{A}$$", "id": "3644037"}]}