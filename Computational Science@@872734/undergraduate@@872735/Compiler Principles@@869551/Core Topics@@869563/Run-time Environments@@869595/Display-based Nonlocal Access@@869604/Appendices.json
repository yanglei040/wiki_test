{"hands_on_practices": [{"introduction": "Before a display can be used at runtime, the compiler must perform static analysis on the source code. This practice guides you through the core algorithm for traversing an Abstract Syntax Tree (AST) to determine the static nesting level of each variable's declaration and use. By mastering this process, you will understand how a compiler computes the exact display index required to access any non-local variable, bridging the gap between the program's static text and its dynamic runtime representation [@problem_id:3638316].", "problem": "A statically scoped language supports nested procedure declarations and lexical blocks. The compiler uses an Abstract Syntax Tree (AST) representation for the program and a display-based mechanism for nonlocal access, where the display $D$ is an array of pointers to currently active Activation Records (ARs) indexed by the static nesting level of the corresponding scope. The static nesting level of a scope is the number of lexical nesting steps from the root environment to that scope. The compiler must determine, for each identifier occurrence, a lexical depth $h$ that quantifies how far outward in the static nesting structure one must move from the use site to find its declaration. The goal is to compute $h$ by traversing the AST and then generate code that uses $D$ to locate the base address for the identifier at compile time.\n\nConsider the following program with nested procedures (assume a single global environment enclosing all top-level declarations). The program’s lexical structure is:\n\n- A top-level procedure P that declares a variable a.\n- Inside P, a nested procedure Q that declares a variable b.\n- Inside Q, a nested procedure R that contains two uses: a and b.\n- Inside Q (but outside R), a use of a.\n- Inside P (outside Q), a use of a.\n\nAssume the global environment has static nesting level $0$, procedure P has static nesting level $1$, procedure Q has static nesting level $2$, and procedure R has static nesting level $3$. For each of the identifier uses described above, the compiler should compute the corresponding lexical depth $h$ and the index into the display $D$ that will be used in the generated address calculation for that identifier (base = $D[\\text{index}]$ plus the identifier’s offset within its AR).\n\nWhich option correctly specifies an AST traversal algorithm to compute $h$ for each identifier use and the corresponding compile-time mapping to the index of $D$ for the example program?\n\nA. Traverse the AST while maintaining a current static level $L$, starting at $0$ for the global environment and incrementing by $1$ upon entering each new lexical scope. Record each declaration’s level $L_d$ when first encountered. For a use in a scope at level $L_u$, find the nearest lexically enclosing declaration and set $h$ to $L_u - L_d$. Generate code that uses $D[L_u - h]$ as the base for the identifier. Applied to the program: in R, use a gives $h = 3 - 1 = 2$ and base $D[1]$; in R, use b gives $h = 3 - 2 = 1$ and base $D[2]$; in Q, use a gives $h = 2 - 1 = 1$ and base $D[1]$; in P, use a gives $h = 1 - 1 = 0$ and base $D[1]$.\n\nB. Traverse the AST while maintaining a current static level $L$ starting at $1$, incrementing by $1$ upon entering each new scope. For a use at level $L_u$, set $h$ to $L_u - L_d$ and use $D[L_d + 1]$ as the base. Applied to the program: in R, use a gives $h = 3 - 1 = 2$ and base $D[2]$; in R, use b gives $h = 3 - 2 = 1$ and base $D[3]$; in Q, use a gives $h = 2 - 1 = 1$ and base $D[2]$; in P, use a gives $h = 1 - 1 = 0$ and base $D[2]$.\n\nC. Traverse the AST and for each declaration record its level $L_d$. For a use at level $L_u$, compute $h$ as $L_d - L_u$ and use $D[h]$ as the base. Applied to the program: in R, use a gives $h = 1 - 3 = -2$ and base $D[-2]$; in R, use b gives $h = 2 - 3 = -1$ and base $D[-1]$; in Q, use a gives $h = 1 - 2 = -1$ and base $D[-1]$; in P, use a gives $h = 1 - 1 = 0$ and base $D[0]$.\n\nD. Do not traverse the AST for static levels; instead, compute $h$ from the dynamic call stack depth at the point of each use. Use $D[L_u]$ as the base for all identifiers used at level $L_u$. Applied to the program: in R, both uses a and b have base $D[3]$; in Q, use a has base $D[2]$; in P, use a has base $D[1]$.\n\nE. Traverse the AST and compute $h$ as the number of edges between the use node and the declaration node along the unique path in the AST. Use $D[h]$ for the base. Applied to the program: in R, use a gives $h = 2$ and base $D[2]$; in R, use b gives $h = 1$ and base $D[1]$; in Q, use a gives $h = 1$ and base $D[1]$; in P, use a gives $h = 0$ and base $D[0]$.", "solution": "The problem statement is subjected to validation.\n\n### Step 1: Extract Givens\n\n-   **Language Model**: Statically scoped, supports nested procedure declarations and lexical blocks.\n-   **Compiler Data Structures**: Abstract Syntax Tree (AST), Display $D$ (an array of pointers to active Activation Records, ARs).\n-   **Display Indexing**: $D$ is indexed by the static nesting level of the scope.\n-   **Definition of Static Nesting Level**: The number of lexical nesting steps from the root environment to a scope.\n-   **Definition of Lexical Depth $h$**: The number of outward steps in the static nesting structure from the use site to the declaration site.\n-   **Goal**: Find an algorithm to compute $h$ and the corresponding display index for address calculation (base = $D[\\text{index}] + \\text{offset}$).\n-   **Program Structure and Levels**:\n    -   Global environment: static nesting level $0$.\n    -   Procedure P: static nesting level $1$, declares variable `a`.\n    -   Procedure Q (nested in P): static nesting level $2$, declares variable `b`.\n    -   Procedure R (nested in Q): static nesting level $3$.\n-   **Identifier Uses to Analyze**:\n    1.  Use of `a` in R.\n    2.  Use of `b` in R.\n    3.  Use of `a` in Q (outside R).\n    4.  Use of `a` in P (outside Q).\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientific Grounding**: The problem is firmly grounded in the established principles of compiler design for block-structured, statically-scoped languages. The concepts of static nesting, activation records, and the display mechanism for handling nonlocal variable access are canonical topics in computer science. The problem is scientifically sound.\n-   **Well-Posed**: The problem is well-posed. It provides clear definitions for all terms (static level, lexical depth), a concrete program structure, and a specific question to be answered. A unique and stable solution based on standard compiler algorithms exists.\n-   **Objective**: The problem is stated using precise, objective, and technical terminology common to the field of compiler construction. It is free of ambiguity or subjective claims.\n-   **Completeness and Consistency**: The problem is self-contained. All necessary information regarding language semantics, compiler data structures, and the example program is provided. There are no internal contradictions.\n\n### Step 3: Verdict and Action\n\nThe problem statement is valid. It presents a standard, well-defined problem in compiler theory. The solution process may proceed.\n\n### Principle-Based Derivation\n\nIn a statically scoped language with nested procedures, the compiler must resolve identifier references according to the lexical structure of the program. The display mechanism is a runtime optimization for this.\n\n1.  **Static Nesting Level**: Let $L(\\text{scope})$ denote the static nesting level of a given scope. According to the problem:\n    -   $L(\\text{global}) = 0$\n    -   $L(P) = 1$\n    -   $L(Q) = 2$\n    -   $L(R) = 3$\n\n2.  **Symbol Table and AST Traversal**: A compiler typically performs a depth-first traversal of the AST. It maintains a stack of symbol tables, corresponding to the chain of lexically enclosing scopes. When entering a scope `S` at level $L(S)$, a new symbol table is created for `S`. When a variable `x` is declared, it is entered into the symbol table for the current scope, and its declaration level, $L_d$, is recorded as the current level.\n\n3.  **Resolving Identifier Use**: When a use of an identifier `x` is encountered in a scope `U` with level $L_u = L(U)$, the compiler searches for its declaration. The static scope rule dictates that the search starts in the symbol table for `U`, and if not found, proceeds to the symbol table of the lexically enclosing scope, and so on, until the declaration is found in some scope `S_d`. Let the declaration level be $L_d = L(S_d)$.\n\n4.  **Calculating Lexical Depth $h$**: The problem defines $h$ as the number of outward steps from the use site to the declaration site. This is precisely the difference between the static nesting levels of the use scope and the declaration scope.\n    $$h = L_u - L_d$$\n    A local variable has $h=0$ since $L_u = L_d$. A non-local variable has $h > 0$.\n\n5.  **Using the Display $D$**: The display $D$ is an array of pointers. At runtime, when code within scope `U` is executing, $D[i]$ holds a pointer to the activation record (AR) of the most recently called procedure at static nesting level $i$. To access a variable `x` declared at level $L_d$, the program must find the base address of the AR for the scope where `x` lives. This AR corresponds to the static level $L_d$. Therefore, the correct pointer is stored in $D[L_d]$. The index into the display is the declaration level, $L_d$.\n\n6.  **Relating Display Index to $h$**: We have two key equations:\n    -   $h = L_u - L_d$\n    -   $\\text{index} = L_d$\n    We can express the index in terms of $L_u$ and $h$. From the first equation, $L_d = L_u - h$. Substituting this into the second equation gives:\n    $$\\text{index} = L_u - h$$\n    So, the address calculation for a variable used at level $L_u$ with lexical depth $h$ is `base = $D[L_u - h] + \\text{offset}$`.\n\n### Application to the Example Program\n\nLet's apply these principles to the given uses.\n\n-   Declaration of `a` is in P, so $L_d(a) = 1$.\n-   Declaration of `b` is in Q, so $L_d(b) = 2$.\n\n1.  **Use of `a` in R**:\n    -   Use level $L_u = 3$. Declaration level $L_d = 1$.\n    -   Lexical depth $h = L_u - L_d = 3 - 1 = 2$.\n    -   Display index = $L_d = 1$. (Check: $L_u - h = 3 - 2 = 1$).\n    -   Base access: $D[1]$.\n\n2.  **Use of `b` in R**:\n    -   Use level $L_u = 3$. Declaration level $L_d = 2$.\n    -   Lexical depth $h = L_u - L_d = 3 - 2 = 1$.\n    -   Display index = $L_d = 2$. (Check: $L_u - h = 3 - 1 = 2$).\n    -   Base access: $D[2]$.\n\n3.  **Use of `a` in Q**:\n    -   Use level $L_u = 2$. Declaration level $L_d = 1$.\n    -   Lexical depth $h = L_u - L_d = 2 - 1 = 1$.\n    -   Display index = $L_d = 1$. (Check: $L_u - h = 2 - 1 = 1$).\n    -   Base access: $D[1]$.\n\n4.  **Use of `a` in P**:\n    -   Use level $L_u = 1$. Declaration level $L_d = 1$.\n    -   Lexical depth $h = L_u - L_d = 1 - 1 = 0$.\n    -   Display index = $L_d = 1$. (Check: $L_u - h = 1 - 0 = 1$).\n    -   Base access: $D[1]$.\n\n### Option-by-Option Analysis\n\n**A. Traverse the AST while maintaining a current static level $L$, starting at $0$ for the global environment and incrementing by $1$ upon entering each new lexical scope. Record each declaration’s level $L_d$ when first encountered. For a use in a scope at level $L_u$, find the nearest lexically enclosing declaration and set $h$ to $L_u - L_d$. Generate code that uses $D[L_u - h]$ as the base for the identifier. Applied to the program: in R, use a gives $h = 3 - 1 = 2$ and base $D[1]$; in R, use b gives $h = 3 - 2 = 1$ and base $D[2]$; in Q, use a gives $h = 2 - 1 = 1$ and base $D[1]$; in P, use a gives $h = 1 - 1 = 0$ and base $D[1]$.**\n\n-   **Algorithm**: The described algorithm for computing $h$ as $L_u - L_d$ and using the display index $L_u - h$ is perfectly consistent with our derivation.\n-   **Application**:\n    -   Use of `a` in R: $h=3-1=2$, index=$3-2=1$. Base $D[1]$. Matches our calculation.\n    -   Use of `b` in R: $h=3-2=1$, index=$3-1=2$. Base $D[2]$. Matches our calculation.\n    -   Use of `a` in Q: $h=2-1=1$, index=$2-1=1$. Base $D[1]$. Matches our calculation.\n    -   Use of `a` in P: $h=1-1=0$, index=$1-0=1$. Base $D[1]$. Matches our calculation.\n-   **Verdict**: **Correct**.\n\n**B. Traverse the AST while maintaining a current static level $L$ starting at $1$, incrementing by $1$ upon entering each new scope. For a use at level $L_u$, set $h$ to $L_u - L_d$ and use $D[L_d + 1]$ as the base. Applied to the program: in R, use a gives $h = 3 - 1 = 2$ and base $D[2]$; in R, use b gives $h = 3 - 2 = 1$ and base $D[3]$; in Q, use a gives $h = 2 - 1 = 1$ and base $D[2]$; in P, use a gives $h = 1 - 1 = 0$ and base $D[2]$.**\n\n-   **Algorithm**: The formula for the display index, $D[L_d + 1]$, is incorrect. The display is indexed directly by the static nesting level of the declaration, which is $L_d$. The $+1$ term is baseless.\n-   **Application**: For the use of `a` in R, $L_d=1$. The base would be $D[1+1] = D[2]$. Our correct calculation gives $D[1]$. The application is therefore incorrect.\n-   **Verdict**: **Incorrect**.\n\n**C. Traverse the AST and for each declaration record its level $L_d$. For a use at level $L_u$, compute $h$ as $L_d - L_u$ and use $D[h]$ as the base. Applied to the program: in R, use a gives $h = 1 - 3 = -2$ and base $D[-2]$; in R, use b gives $h = 2 - 3 = -1$ and base $D[-1]$; in Q, use a gives $h = 1 - 2 = -1$ and base $D[-1]$; in P, use a gives $h = 1 - 1 = 0$ and base $D[0]$.**\n\n-   **Algorithm**: The definition of `h` as $L_d - L_u$ is inverted. Lexical depth is a non-negative count of enclosing scopes. This formula produces negative values for nonlocal accesses. Using a negative value `h` as an array index, e.g., $D[-2]$, is invalid.\n-   **Application**: The example calculations confirm this flaw, yielding negative indices.\n-   **Verdict**: **Incorrect**.\n\n**D. Do not traverse the AST for static levels; instead, compute $h$ from the dynamic call stack depth at the point of each use. Use $D[L_u]$ as the base for all identifiers used at level $L_u$. Applied to the program: in R, both uses a and b have base $D[3]$; in Q, use a has base $D[2]$; in P, use a has base $D[1]$.**\n\n-   **Algorithm**: This describes dynamic scoping (`compute h from the dynamic call stack depth`), which directly contradicts the problem's premise of a statically scoped language. Furthermore, using $D[L_u]$ as the base for all variables implies all variables are local to the current scope, which defeats the purpose of nonlocal access.\n-   **Application**: The proposed logic is fundamentally flawed for a statically scoped language.\n-   **Verdict**: **Incorrect**.\n\n**E. Traverse the AST and compute $h$ as the number of edges between the use node and the declaration node along the unique path in the AST. Use $D[h]$ for the base. Applied to the program: in R, use a gives $h = 2$ and base $D[2]$; in R, use b gives $h = 1$ and base $D[1]$; in Q, use a gives $h = 1$ and base $D[1]$; in P, use a gives $h = 0$ and base $D[0]$.**\n\n-   **Algorithm**: The display $D$ is indexed by absolute static nesting level, not by relative lexical depth $h$. Using $D[h]$ is a fundamental misunderstanding. For a local variable, $h=0$, and this algorithm would use $D[0]$ (the global AR), which is incorrect. The local variable is in the current AR, pointed to by $D[L_u]$.\n-   **Application**: Let's check the use of `a` in P. This is a local variable, so $h=0$. The option claims the base is $D[0]$. This is wrong. The variable `a` is declared in P (level $1$), so its data is in the AR for P, which is pointed to by $D[1]$.\n-   **Verdict**: **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "3638316"}, {"introduction": "The display mechanism offers fast access to non-local variables, but this efficiency is not without cost. Every procedure call and return may require updating the display, and every non-local access involves reading from it. This exercise provides a quantitative framework for analyzing this performance trade-off by asking you to construct a cost model based on the dynamic frequency of access and update operations [@problem_id:3638318]. This type of analysis is a fundamental skill in performance engineering for compilers.", "problem": "A compiler for a block-structured language uses a display to implement nonlocal variable access. The display is an array indexed by static lexical level that stores the most recent Activation Record (AR) pointer for each level. On procedure entry at static level $h$, the runtime system saves the old display entry at index $h$ and installs the new AR pointer, and on procedure exit it restores the saved entry. Assume each such display update writes costs $c_{\\text{update}}$ Central Processing Unit (CPU) cycles. A nonlocal variable access from the current activation that targets a declaration at level $h$ reads the display entry at index $h$ to obtain the base address for addressing; assume this display read costs $c_{\\text{load}}$ CPU cycles. Ignore all other costs (such as arithmetic and data memory access) and focus only on display reads and writes.\n\nSuppose a particular program is run once, and dynamic instrumentation yields the following aggregate counts across the entire run:\n- For each level $h \\in \\{0,1,\\dots,H\\}$, the total number of nonlocal accesses that target declarations at level $h$ is $A_h$.\n- For each level $h \\in \\{0,1,\\dots,H\\}$, the total number of display update operations performed at index $h$ (counting both procedure entries and exits) is $U_h$.\n\nStarting from the fundamental cost-accounting principle that the total cost of a mechanism equals the sum over all distinct event types of the product of per-event cost and event frequency, derive a symbolic expression for the total display-related cost over the execution in terms of $\\{A_h\\}$, $\\{U_h\\}$, $c_{\\text{load}}$, $c_{\\text{update}}$, and $H$. Then evaluate this total cost for the following concrete data:\n- $H = 4$,\n- $c_{\\text{load}} = 3$ cycles,\n- $c_{\\text{update}} = 7$ cycles,\n- $\\{A_h\\}_{h=0}^{4} = \\{1500, 600, 240, 90, 20\\}$,\n- $\\{U_h\\}_{h=0}^{4} = \\{2, 400, 260, 120, 40\\}$.\n\nExpress the final total cost as a single number in cycles. No rounding is required.", "solution": "The user wants me to solve the following problem.\n\n### Step 1: Extract Givens\n- A compiler uses a display, an array indexed by static lexical level, for nonlocal variable access.\n- The cost of a display update operation (write) is $c_{\\text{update}}$ CPU cycles.\n- The cost of a display read operation for nonlocal access is $c_{\\text{load}}$ CPU cycles.\n- For each static lexical level $h \\in \\{0, 1, \\dots, H\\}$, the total number of nonlocal accesses targeting declarations at level $h$ is $A_h$.\n- For each static lexical level $h \\in \\{0, 1, \\dots, H\\}$, the total number of display update operations performed at index $h$ is $U_h$.\n- The cost-accounting principle states that the total cost is the sum over all distinct event types of the product of the per-event cost and the event frequency.\n- The task is to derive a symbolic expression for the total display-related cost and then evaluate it for the specific data:\n- $H = 4$\n- $c_{\\text{load}} = 3$ cycles\n- $c_{\\text{update}} = 7$ cycles\n- $\\{A_h\\}_{h=0}^{4} = \\{1500, 600, 240, 90, 20\\}$\n- $\\{U_h\\}_{h=0}^{4} = \\{2, 400, 260, 120, 40\\}$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, as it describes the standard display mechanism used in compiler runtime systems for managing scope in block-structured languages. The cost model is a simplified but valid abstraction for performance analysis. The problem is well-posed, providing all necessary data and definitions to compute a unique solution. The terminology is precise and objective, belonging to the field of compiler design. The numerical values are plausible. The problem does not violate any of the invalidity criteria.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\nThe problem asks for the total cost related to display operations, which can be broken down into two distinct types of events: display reads for nonlocal variable accesses and display writes for procedure entry and exit. We will calculate the total cost for each event type and sum them, following the provided cost-accounting principle.\n\nLet $C_{\\text{total}}$ be the total display-related cost. It is the sum of the total cost of all display reads, $C_{\\text{load}}$, and the total cost of all display writes (updates), $C_{\\text{update}}$.\n$$\nC_{\\text{total}} = C_{\\text{load}} + C_{\\text{update}}\n$$\n\nFirst, we calculate the total cost of display reads, $C_{\\text{load}}$.\nA single display read operation costs $c_{\\text{load}}$. The problem states that for each lexical level $h$ from $0$ to $H$, there are $A_h$ nonlocal accesses targeting that level. Each such access requires one display read. Therefore, the total number of display reads is the sum of all $A_h$ over all levels.\nThe total cost for accesses targeting level $h$ is $A_h \\cdot c_{\\text{load}}$.\nSumming over all levels from $h=0$ to $h=H$ gives the total cost for display reads:\n$$\nC_{\\text{load}} = \\sum_{h=0}^{H} A_h \\cdot c_{\\text{load}}\n$$\nSince $c_{\\text{load}}$ is a constant, it can be factored out of the summation:\n$$\nC_{\\text{load}} = c_{\\text{load}} \\left( \\sum_{h=0}^{H} A_h \\right)\n$$\n\nNext, we calculate the total cost of display updates, $C_{\\text{update}}$.\nA single display update operation costs $c_{\\text{update}}$. The problem provides $U_h$ as the total count of update operations performed at display index $h$.\nThe total cost for updates at level $h$ is $U_h \\cdot c_{\\text{update}}$.\nSumming over all levels from $h=0$ to $h=H$ gives the total cost for display updates:\n$$\nC_{\\text{update}} = \\sum_{h=0}^{H} U_h \\cdot c_{\\text{update}}\n$$\nSimilarly, $c_{\\text{update}}$ can be factored out:\n$$\nC_{\\text{update}} = c_{\\text{update}} \\left( \\sum_{h=0}^{H} U_h \\right)\n$$\n\nCombining these two components yields the symbolic expression for the total cost:\n$$\nC_{\\text{total}} = c_{\\text{load}} \\left( \\sum_{h=0}^{H} A_h \\right) + c_{\\text{update}} \\left( \\sum_{h=0}^{H} U_h \\right)\n$$\nThis is the required symbolic expression.\n\nNow, we evaluate this expression using the provided concrete data.\nThe given values are:\n- $H = 4$\n- $c_{\\text{load}} = 3$\n- $c_{\\text{update}} = 7$\n- $\\{A_h\\}_{h=0}^{4} = \\{1500, 600, 240, 90, 20\\}$\n- $\\{U_h\\}_{h=0}^{4} = \\{2, 400, 260, 120, 40\\}$\n\nFirst, we compute the total number of nonlocal accesses, which is the sum $\\sum_{h=0}^{4} A_h$:\n$$\n\\sum_{h=0}^{4} A_h = A_0 + A_1 + A_2 + A_3 + A_4 = 1500 + 600 + 240 + 90 + 20\n$$\n$$\n\\sum_{h=0}^{4} A_h = 2450\n$$\n\nNext, we compute the total number of display updates, which is the sum $\\sum_{h=0}^{4} U_h$:\n$$\n\\sum_{h=0}^{4} U_h = U_0 + U_1 + U_2 + U_3 + U_4 = 2 + 400 + 260 + 120 + 40\n$$\n$$\n\\sum_{h=0}^{4} U_h = 822\n$$\n\nNow, we substitute these sums and the cost constants into the total cost formula:\n$$\nC_{\\text{total}} = c_{\\text{load}} \\cdot (2450) + c_{\\text{update}} \\cdot (822)\n$$\n$$\nC_{\\text{total}} = 3 \\cdot 2450 + 7 \\cdot 822\n$$\nLet's calculate each term separately:\n$$\n3 \\cdot 2450 = 7350\n$$\n$$\n7 \\cdot 822 = 5754\n$$\nFinally, we sum the two terms to find the total cost in CPU cycles:\n$$\nC_{\\text{total}} = 7350 + 5754 = 13104\n$$\nThe total display-related cost over the execution is $13104$ CPU cycles.", "answer": "$$\n\\boxed{13104}\n$$", "id": "3638318"}, {"introduction": "Taking performance analysis a step further, we can explore optimizations that are sensitive to the target hardware. This problem presents a classic compiler trade-off: should we use precious CPU registers to cache display entries for even faster access, or should we reserve those registers for general-purpose computations to minimize costly memory spills? By modeling and minimizing a total cost function, you will engage in the kind of resource management and optimization decisions that real-world compiler developers face [@problem_id:3638307].", "problem": "In a statically scoped language, nonlocal variables are accessed using a display of activation records. The display is an array of frame pointers for lexically enclosing procedures, where the entry for lexical depth $\\ell$ allows constant-time access to variables at that depth. A compiler targeting a machine with $R$ architectural registers can optionally reserve some registers to hold display entries, reducing nonlocal access latency at the cost of increased register pressure for general-purpose values. Spilling occurs when the average number of simultaneously live general-purpose values exceeds the number of registers available to hold them; each unit of spill generates an expected penalty per instruction.\n\nConsider a program with a small display depth $d = 3$. You may reserve an integer number $k$ of registers for display entries, with $0 \\leq k \\leq d$, always holding the $k$ most frequently needed display entries (assume the $k$ topmost lexical levels). The machine has $R = 16$ registers. The program’s average general-purpose live value demand is $W = 14$ registers per instruction. Each unit of register shortage per instruction yields an expected spill penalty of $c_s = 3$ cycles per instruction. Nonlocal variable accesses occur with frequency $f = 0.2$ per instruction, and the lexical depth of a nonlocal access is uniformly distributed over the $d$ possible levels. If the required display entry is in a reserved register, its cost is negligible; otherwise, loading the display entry from memory costs $M = 25$ cycles.\n\nAssume the following simple model:\n- The expected nonlocal access cost per instruction is $f$ times the expected cost of a single nonlocal access under uniform depth, given $k$ reserved display entries.\n- The spill penalty per instruction is $c_s$ times the shortage, where shortage is $\\max\\{0, W - (R - k)\\}$.\n- All events are independent across instructions in steady state.\n\nDerive from first principles an expression for the expected cycles per instruction as a function of $k$, and determine the integer $k \\in \\{0,1,2,3\\}$ that minimizes this expected cost. Report only the optimal $k$ as your final answer. No rounding is required.", "solution": "The user wants me to solve this problem. I have to validate it first.\n\n### Step 1: Extract Givens\n- Display depth: $d = 3$\n- Number of registers reserved for display entries: $k$, an integer such that $0 \\leq k \\leq d$\n- Total architectural registers: $R = 16$\n- Average general-purpose live value demand per instruction: $W = 14$\n- Spill penalty per unit of register shortage per instruction: $c_s = 3$ cycles\n- Frequency of nonlocal variable accesses per instruction: $f = 0.2$\n- Cost to load a display entry from memory: $M = 25$ cycles\n- The lexical depth of a nonlocal access is uniformly distributed over the $d$ possible levels.\n- The $k$ reserved registers hold entries for the $k$ topmost lexical levels.\n- The expected nonlocal access cost per instruction is $f$ times the expected cost of a single nonlocal access.\n- The spill penalty per instruction is $c_s$ times the shortage, where shortage is $\\max\\{0, W - (R - k)\\}$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded:** The problem describes a classic trade-off in compiler design concerning register allocation for special-purpose data structures (like a display) versus general-purpose values. The model, while simplified, is based on established principles of static scoping, activation records, and register pressure. The concepts of spill cost and memory access latency are fundamental in performance analysis of compiled code. The problem is scientifically sound.\n2.  **Well-Posed:** The problem asks to find the integer value of $k$ within a finite set $\\{0, 1, 2, 3\\}$ that minimizes a well-defined cost function. The existence of a minimum is guaranteed since the domain is finite. All parameters required to build and evaluate the cost function are provided, ensuring a unique solution can be determined.\n3.  **Objective:** The problem is stated using precise, quantitative language. All models for calculating costs are given explicitly, leaving no room for subjective interpretation.\n4.  **Incomplete or Contradictory Setup:** The problem is self-contained and provides all necessary data and definitions. There are no contradictions.\n5.  **Unrealistic or Infeasible:** The numerical values provided ($R=16$, $W=14$, etc.) are within a plausible range for a simplified model of a real processor and program.\n6.  **Ill-Posed or Poorly Structured:** The problem is clearly structured and asks for a specific optimization. The logic is straightforward.\n7.  **Pseudo-Profound, Trivial, or Tautological:** The problem requires a careful derivation and comparison of costs, representing a genuine optimization problem, not a trivial exercise.\n8.  **Outside Scientific Verifiability:** The result is derivable through mathematical calculation and is therefore verifiable.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\nThe objective is to find the integer $k \\in \\{0, 1, 2, 3\\}$ that minimizes the total expected cost per instruction, $C(k)$. This total cost is the sum of the expected spill penalty per instruction, $C_{\\text{spill}}(k)$, and the expected nonlocal access cost per instruction, $C_{\\text{nonlocal}}(k)$.\n$$C(k) = C_{\\text{spill}}(k) + C_{\\text{nonlocal}}(k)$$\n\nFirst, let's derive the expression for the spill penalty, $C_{\\text{spill}}(k)$.\nThe total number of architectural registers is $R = 16$. If $k$ registers are reserved for the display, the number of registers available for general-purpose values is $R - k$.\nThe average demand for general-purpose registers is $W = 14$. A register shortage occurs if this demand exceeds the available supply.\nThe shortage, $S(k)$, is defined as:\n$$S(k) = \\max\\{0, W - (R - k)\\}$$\nSubstituting the given values $W = 14$ and $R = 16$:\n$$S(k) = \\max\\{0, 14 - (16 - k)\\} = \\max\\{0, 14 - 16 + k\\} = \\max\\{0, k - 2\\}$$\nThe spill penalty per instruction is the shortage multiplied by the cost per unit of shortage, $c_s = 3$.\n$$C_{\\text{spill}}(k) = c_s \\cdot S(k) = 3 \\cdot \\max\\{0, k - 2\\}$$\n\nNext, we derive the expression for the nonlocal access cost, $C_{\\text{nonlocal}}(k)$.\nNonlocal accesses occur with a frequency of $f = 0.2$ per instruction. The cost of such an access depends on whether the required display entry is in a register or in memory.\nThe display depth is $d = 3$. The lexical depth of a nonlocal access is uniformly distributed over the $d$ levels. The probability of an access to any specific level is $\\frac{1}{d} = \\frac{1}{3}$.\nThe $k$ reserved registers hold the display entries for the $k$ topmost lexical levels (levels $1, 2, \\dots, k$). An access to one of these levels has a cost of $0$.\nThe remaining $d-k$ levels are not in registers. An access to one of these levels (levels $k+1, \\dots, d$) requires loading the display entry from memory, which costs $M = 25$ cycles.\nThe probability that a given nonlocal access is for a level whose entry is in a register is $\\frac{k}{d}$.\nThe probability that a given nonlocal access is for a level whose entry is in memory is $\\frac{d-k}{d}$.\nThe expected cost of a single nonlocal access, $E_{\\text{access}}(k)$, is:\n$$E_{\\text{access}}(k) = \\left(\\frac{k}{d}\\right) \\cdot 0 + \\left(\\frac{d-k}{d}\\right) \\cdot M = \\frac{d-k}{d} M$$\nThe expected nonlocal access cost per instruction is this value multiplied by the frequency of nonlocal accesses, $f$.\n$$C_{\\text{nonlocal}}(k) = f \\cdot E_{\\text{access}}(k) = f \\cdot M \\cdot \\frac{d-k}{d}$$\nSubstituting the given values $f = 0.2$, $M = 25$, and $d = 3$:\n$$C_{\\text{nonlocal}}(k) = 0.2 \\cdot 25 \\cdot \\frac{3-k}{3} = 5 \\cdot \\frac{3-k}{3}$$\n\nNow we can write the total cost function $C(k)$:\n$$C(k) = 3 \\cdot \\max\\{0, k - 2\\} + 5 \\cdot \\frac{3-k}{3}$$\nWe must evaluate this function for each possible integer value of $k$ in the domain $\\{0, 1, 2, 3\\}$.\n\nFor $k = 0$:\n$$C(0) = 3 \\cdot \\max\\{0, 0 - 2\\} + 5 \\cdot \\frac{3-0}{3} = 3 \\cdot 0 + 5 \\cdot \\frac{3}{3} = 0 + 5 = 5$$\n\nFor $k = 1$:\n$$C(1) = 3 \\cdot \\max\\{0, 1 - 2\\} + 5 \\cdot \\frac{3-1}{3} = 3 \\cdot 0 + 5 \\cdot \\frac{2}{3} = 0 + \\frac{10}{3} \\approx 3.33$$\n\nFor $k = 2$:\n$$C(2) = 3 \\cdot \\max\\{0, 2 - 2\\} + 5 \\cdot \\frac{3-2}{3} = 3 \\cdot 0 + 5 \\cdot \\frac{1}{3} = 0 + \\frac{5}{3} \\approx 1.67$$\n\nFor $k = 3$:\n$$C(3) = 3 \\cdot \\max\\{0, 3 - 2\\} + 5 \\cdot \\frac{3-3}{3} = 3 \\cdot 1 + 5 \\cdot \\frac{0}{3} = 3 + 0 = 3$$\n\nWe compare the total costs for each value of $k$:\n$C(0) = 5 = \\frac{15}{3}$\n$C(1) = \\frac{10}{3}$\n$C(2) = \\frac{5}{3}$\n$C(3) = 3 = \\frac{9}{3}$\n\nThe minimum cost is $\\frac{5}{3}$, which occurs at $k=2$. Therefore, reserving $k=2$ registers for the display minimizes the total expected cycles per instruction.", "answer": "$$\\boxed{2}$$", "id": "3638307"}]}