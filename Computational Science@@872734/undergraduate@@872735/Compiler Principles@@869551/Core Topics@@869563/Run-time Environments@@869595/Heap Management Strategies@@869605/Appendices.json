{"hands_on_practices": [{"introduction": "To truly understand heap management, we must move beyond simply knowing the steps of an algorithm and begin to analyze its performance quantitatively. This first practice provides a framework for comparing two foundational garbage collection strategies—Mark-Sweep and Copying GC—by modeling their costs based on the structure of the live object graph. By deriving expressions for their operational costs, you will gain a deeper appreciation for the trade-offs that guide the choice of a garbage collector in real-world systems. [@problem_id:3644886]", "problem": "A managed runtime uses two distinct heap management strategies for reclaiming memory: Mark-Sweep Garbage Collection (GC) and Semi-Space Copying Garbage Collection (GC). The heap at the instant of collection can be modeled as a directed graph of live objects and pointers, called the live object graph. Let the live object graph be denoted by $G = (V,E)$ where $|V|$ is the number of live objects and $|E|$ is the number of live pointer fields among those objects. Assume that every edge in $E$ corresponds to a unique pointer field stored in exactly one object in $V$. For this analysis, ignore the cost of scanning the root set and ignore the sweep of dead memory.\n\nAdopt the following cost model for primitive operations:\n- Setting or testing an object’s mark bit, header flag, or forwarding state during traversal incurs a constant cost of $\\alpha$ per live object visited.\n- Scanning a single pointer field (that is, reading the field and performing the requisite reachability or forwarding check) incurs a constant cost of $\\beta$ per edge scanned.\n- Copying an object’s payload incurs a cost proportional to the number of bytes moved; for an object of payload size $b$ bytes this cost is $\\gamma b$. Assume all live objects have identical payload size $\\bar{b}$ bytes.\n\nUnder this model, and using only graph-theoretic accounting grounded in the definition of reachability and traversal invariants, derive closed-form expressions for the total live set traversal cost of:\n- Mark-Sweep GC, which marks all reachable objects and scans their outgoing pointer fields.\n- Semi-Space Copying GC (for example, Cheney’s algorithm), which evacuates each reachable object exactly once and scans all outgoing pointer fields exactly once.\n\nReport your final answer as the simplified analytic expression for the ratio $R$ of the copying collector’s total live set traversal cost to the mark-sweep collector’s total live set traversal cost, expressed in terms of $|V|$, $|E|$, $\\alpha$, $\\beta$, $\\gamma$, and $\\bar{b}$. Do not include any asymptotic notation. Your final answer should be a single closed-form expression.", "solution": "The problem requires the derivation of an analytical expression for the ratio of the total live set traversal costs of two different garbage collection algorithms: Semi-Space Copying and Mark-Sweep. The analysis will be performed based on the provided cost model and a graph-theoretic representation of the memory heap. Let the live object graph be $G = (V, E)$, where $|V|$ is the number of live objects and $|E|$ is the number of pointers between them. Let $C_{MS}$ be the cost for Mark-Sweep GC and $C_{Copy}$ be the cost for Semi-Space Copying GC.\n\nFirst, we determine the total cost for Mark-Sweep Garbage Collection, $C_{MS}$. The problem describes this process as consisting of two main operations on the live set: marking reachable objects and scanning their pointer fields.\n1.  Marking Cost: The traversal must visit every live object to set its mark bit. There are $|V|$ live objects. The cost per object for this operation is given as $\\alpha$. Therefore, the total cost for marking all $|V|$ objects is $\\alpha |V|$.\n2.  Scanning Cost: The traversal must examine every pointer field within the live objects to discover the full extent of the reachable graph. The total number of such pointer fields is $|E|$. The cost to scan a single pointer is given as $\\beta$. Consequently, the total cost for scanning all pointers is $\\beta |E|$.\n\nThe problem specifies to ignore other costs, such as scanning the root set and sweeping dead memory. Thus, the total live set traversal cost for the Mark-Sweep collector is the sum of the marking and scanning costs:\n$$C_{MS} = \\alpha |V| + \\beta |E|$$\n\nNext, we determine the total cost for Semi-Space Copying Garbage Collection, $C_{Copy}$. This algorithm's cost, according to the provided model, is composed of three components:\n1.  Object State Management Cost: Each live object is visited and processed exactly once. This processing involves checking the object's state (e.g., if it has already been forwarded) and, if it is being evacuated for the first time, setting a forwarding pointer. The model specifies a cost of $\\alpha$ for such operations per object visited. For all $|V|$ live objects, this contributes a total cost of $\\alpha |V|$.\n2.  Object Copying Cost: Each of the $|V|$ live objects is physically copied from its current location (from-space) to a new location (to-space). All objects are assumed to have a uniform payload size of $\\bar{b}$ bytes. The cost of copying is $\\gamma$ per byte. The cost to copy one object is $\\gamma \\bar{b}$. Therefore, the total cost to copy all $|V|$ objects is $\\gamma \\bar{b} |V|$.\n3.  Scanning Cost: Similar to Mark-Sweep, the copying collector must scan all pointer fields of the live objects to update them to point to the new locations in to-space and to find further objects to copy. This involves scanning each of the $|E|$ pointers exactly once. At a cost of $\\beta$ per pointer, the total scanning cost is $\\beta |E|$.\n\nSumming these three components gives the total live set traversal cost for the Semi-Space Copying collector:\n$$C_{Copy} = \\alpha |V| + \\gamma \\bar{b} |V| + \\beta |E|$$\nThis expression can be rearranged by factoring out the common term $|V|$:\n$$C_{Copy} = (\\alpha + \\gamma \\bar{b})|V| + \\beta |E|$$\n\nFinally, the problem asks for the ratio $R$ of the copying collector’s cost to the mark-sweep collector’s cost.\n$$R = \\frac{C_{Copy}}{C_{MS}}$$\nSubstituting the derived expressions for $C_{Copy}$ and $C_{MS}$:\n$$R = \\frac{(\\alpha + \\gamma \\bar{b})|V| + \\beta |E|}{\\alpha |V| + \\beta |E|}$$\nTo simplify this expression, we can separate the numerator into two parts, one of which is identical to the denominator:\n$$R = \\frac{(\\alpha |V| + \\beta |E|) + \\gamma \\bar{b} |V|}{\\alpha |V| + \\beta |E|}$$\nSplitting the fraction yields:\n$$R = \\frac{\\alpha |V| + \\beta |E|}{\\alpha |V| + \\beta |E|} + \\frac{\\gamma \\bar{b} |V|}{\\alpha |V| + \\beta |E|}$$\nThe first term simplifies to $1$, resulting in the final closed-form expression for the ratio:\n$$R = 1 + \\frac{\\gamma \\bar{b} |V|}{\\alpha |V| + \\beta |E|}$$\nThis expression is the simplified analytical result for the requested ratio, expressed in terms of the given parameters $|V|$, $|E|$, $\\alpha$, $\\beta$, $\\gamma$, and $\\bar{b}$.", "answer": "$$\\boxed{1 + \\frac{\\gamma \\bar{b} |V|}{\\alpha |V| + \\beta |E|}}$$", "id": "3644886"}, {"introduction": "While precise garbage collectors have perfect knowledge of pointer locations, conservative collectors offer flexibility by scanning memory for pointer-like values, a strategy with its own pitfalls. This exercise explores a classic problem known as false retention, where a random integer can be mistaken for a pointer, unnecessarily keeping dead memory alive. You will analyze the probability of this occurring and then investigate how a compiler technique called pointer tagging can eliminate this issue entirely, demonstrating a powerful synergy between compiler design and runtime memory management. [@problem_id:3644938]", "problem": "A run-time system on a $w$-bit architecture uses a conservative garbage collector that scans the execution stack and registers as a root set. The heap is a single contiguous region of size $S$ bytes starting at base address $H$ and uses allocation alignment of $a$ bytes, where $a$ divides $S$. The collector treats any machine word $x$ in the root set as a possible reference if and only if $x$ is in the half-open interval $\\left[H, H + S\\right)$ and $x \\bmod a = 0$. It also retains an object when it finds an interior aligned address within that object (interior-pointer policy). Consider a buffer object of size $b$ bytes allocated in the heap that has become unreachable except for a spurious integer alias on the stack.\n\nAssume the following:\n- There are $N$ machine words on the stack and in registers that are not true pointers. Model these $N$ words as independent samples uniformly distributed over $\\left\\{0, 1, \\dots, 2^{w} - 1\\right\\}$.\n- The buffer occupies $b$ consecutive bytes and contains $\\frac{b}{a}$ distinct $a$-aligned addresses that the collector would accept as interior pointers into the buffer.\n- A false retention occurs if at least one of the $N$ sampled words equals one of these $\\frac{b}{a}$ aligned addresses in the buffer.\n\nTo avoid such false retention, a compiler transformation is proposed. The compiler inserts pointer tagging as follows:\n- It chooses a fixed tag pattern occupying the top $t$ bits. For every true pointer value $p$, the representable value stored in memory and registers is $v = p \\oplus T$, where $T$ has the top $t$ bits set to the tag pattern and all other bits equal to $0$.\n- All pointer uses are rewritten to de-tag on dereference by computing $p = v \\oplus T$ before memory access; allocation and pointer arithmetic operate on de-tagged $p$.\n- Before spilling any non-pointer machine word to the stack (including integers), the compiler force-clears the top $t$ bits to $0$ by masking, ensuring these words never accidentally carry the pointer tag.\n- The conservative garbage collector is modified to accept a word $x$ as a pointer only if the top $t$ bits match the tag pattern and, after de-tagging $x \\oplus T$, the result lies in $\\left[H, H + S\\right)$ and is $a$-aligned.\n\nUnder these assumptions, which option correctly characterizes the expected number of bytes of the unreachable buffer that are retained before versus after the tagging transformation?\n\nA. Without tagging, the expected retained bytes equal\n$$\nb \\left(1 - \\left(1 - \\frac{b}{a \\cdot 2^{w}}\\right)^{N}\\right).\n$$\nWith tagging and compiler clearing of the top $t$ bits of all non-pointer words, the expected retained bytes drop to\n$$\n0.\n$$\n\nB. Without tagging, the expected retained bytes equal\n$$\nb \\cdot \\frac{N b}{a \\cdot 2^{w}}.\n$$\nWith tagging, the expected retained bytes become\n$$\nb \\left(1 - \\left(1 - \\frac{b}{a \\cdot 2^{w - t}}\\right)^{N}\\right).\n$$\n\nC. Without tagging, the expected retained bytes equal\n$$\nb \\left(1 - \\left(1 - \\frac{b}{a \\cdot 2^{w}}\\right)^{N}\\right).\n$$\nWith tagging, the expected retained bytes become\n$$\nb \\left(1 - \\left(1 - \\frac{b}{a \\cdot 2^{w + t}}\\right)^{N}\\right).\n$$\n\nD. Without tagging, the expected retained bytes equal\n$$\nb \\left(1 - \\left(1 - \\frac{1}{2^{w}}\\right)^{N}\\right),\n$$\nbecause alignment cancels out. With tagging, tagging has no effect on a conservative collector, so the expected retained bytes are unchanged.", "solution": "The solution is derived by analyzing the system before and after the tagging transformation.\n\n### I. Analysis Without Tagging\n\nThe problem asks for the expected number of retained bytes of the unreachable buffer. The buffer has a size of $b$ bytes. The entire buffer is retained if a false retention event occurs. If no such event occurs, $0$ bytes are retained.\n\nLet $R_1$ be the random variable representing the number of bytes retained without tagging. The expected value of $R_1$ is:\n$$\nE[R_1] = b \\cdot P(\\text{buffer is retained}) + 0 \\cdot P(\\text{buffer is not retained}) = b \\cdot P(\\text{false retention occurs})\n$$\nA false retention event occurs if at least one of the $N$ non-pointer words matches one of the vulnerable addresses within the buffer.\n\n1.  **Probability of a single word causing a false retention:**\n    -   The total number of possible values for a $w$-bit word is $2^w$.\n    -   The non-pointer words are modeled as independent samples from a uniform distribution over $\\{0, 1, \\dots, 2^w - 1\\}$.\n    -   The number of vulnerable addresses in the buffer is given as $k = \\frac{b}{a}$. These are specific values that a word can take to be misinterpreted as a pointer into the buffer.\n    -   The probability that a single, randomly chosen $w$-bit word happens to be one of these $k$ specific values is:\n        $$\n        p_1 = \\frac{\\text{Number of vulnerable addresses}}{\\text{Total number of possible word values}} = \\frac{k}{2^w} = \\frac{b/a}{2^w} = \\frac{b}{a \\cdot 2^w}\n        $$\n\n2.  **Probability of the buffer being retained:**\n    -   The probability that a single non-pointer word does *not* cause a false retention is $1 - p_1$.\n    -   Since the $N$ non-pointer words are independent samples, the probability that *none* of them cause a false retention is $(1 - p_1)^N$.\n    -   The event of false retention is the complement of \"no false retention\". Thus, the probability of false retention (at least one hit) is:\n        $$\n        P(\\text{false retention}) = 1 - (1 - p_1)^N = 1 - \\left(1 - \\frac{b}{a \\cdot 2^w}\\right)^N\n        $$\n\n3.  **Expected number of retained bytes:**\n    -   Substituting this probability back into the expectation formula:\n        $$\n        E[\\text{retained bytes, no tagging}] = b \\left(1 - \\left(1 - \\frac{b}{a \\cdot 2^w}\\right)^N\\right)\n        $$\n\n### II. Analysis With Tagging\n\nThe compiler transformation and modified GC policy are designed to eliminate false retention from non-pointer data.\n\n1.  **State of non-pointers on the stack:** The problem states that before spilling any non-pointer machine word to the stack, the compiler force-clears the top $t$ bits to $0$. This means every one of the $N$ non-pointer words on the stack (the root set) will have its top $t$ bits as $00...0$.\n\n2.  **GC check for pointers:** The modified GC will only consider a word $x$ to be a potential pointer if its top $t$ bits match the \"fixed tag pattern\". For pointer tagging to be effective, this tag pattern must be non-zero. A non-pointer word $x_{np}$ on the stack has its top $t$ bits as $0$. The GC checks if the top $t$ bits of a word match the non-zero tag pattern. This check will always fail for any non-pointer word.\n\nTherefore, the modified GC will never classify any of the $N$ non-pointer words as a potential pointer. The probability of one of these words causing a false retention is exactly $0$.\n\n3.  **Expected number of retained bytes:**\n    -   The probability of false retention is $0$.\n    -   The expected number of retained bytes is:\n        $$\n        E[\\text{retained bytes, with tagging}] = b \\cdot P(\\text{false retention}) = b \\cdot 0 = 0\n        $$\n\n### III. Evaluation of Options\n\nComparing our derived results with the given options, we find that Option A is the only one that matches both calculations. The expression for the case without tagging is correct, and the expected retained bytes with tagging correctly drops to zero due to the compiler and GC modifications. The other options either use incorrect approximations, misinterpret the effect of tagging, or use incorrect parameters in the probability calculation.", "answer": "$$\\boxed{A}$$", "id": "3644938"}, {"introduction": "Having analyzed the theoretical costs of collectors and specific runtime issues, the final step is to build one yourself. This comprehensive programming exercise challenges you to implement a complete semi-space copying garbage collector, translating algorithmic theory into practice. The core task focuses on a subtle but critical detail for object-oriented runtimes: ensuring that an object's metadata, specifically its virtual method table (vtable) pointer, remains stable during relocation, thereby preserving type identity. [@problem_id:3644873]", "problem": "You must write a complete, runnable program in the C programming language that builds a small, explicitly modeled heap, performs a moving Garbage Collector (GC) pass using a semispace copying strategy, and verifies invariants related to virtual method table pointer (vtable pointer) stability and Runtime Type Information (RTTI) preservation under relocation. The setting is compiler principles with a focus on heap management strategies.\n\nThe fundamental base of this task starts from the standard definitions used in memory management and garbage collection:\n\n- A heap object is modeled as a record with a header and a payload. The header carries a type identifier and a virtual method table pointer. The payload contains zero or more pointer fields referencing other heap objects.\n- The reachable set is defined by a root set and the directed pointer graph among objects. An object is reachable if and only if there exists a path from the root set to the object through pointer fields.\n- A semispace copying collector partitions memory into a from-space and a to-space, evacuates reachable objects from the from-space to the to-space, and updates all pointers to reference the relocated copies.\n\nRequirements about correctness to be verified by your program:\n\n- Each object has a vtable pointer $v$ and a type identifier $\\tau$. The object's payload contains $p$ pointer fields, where $p \\ge 0$.\n- The collector must implement a relocation function $M$ that maps each original address in the from-space to the new address in the to-space for each reachable object. All root and intra-object pointers must be updated to use $M$.\n- The vtable pointer $v$ must remain bitwise identical under relocation, i.e., if an object in the from-space has vtable pointer $v$, then its relocated copy in the to-space must also have the same pointer value $v$. This must hold for all relocated objects.\n- The type identity represented by $\\tau$ must be preserved, and RTTI checks that compare $v$ for equality to the unique vtable representative of a type must continue to agree with equality of $\\tau$ to the type’s identifier after relocation.\n\nYou must implement a relocation strategy that preserves vtable pointer stability. Two common forwarding strategies are:\n- Header-forwarding: storing a forwarding pointer in the object header in from-space after evacuation.\n- Side table mapping: storing the old-to-new address mapping in a separate table, leaving the object header unmodified until the entire graph is updated.\n\nYour program must adopt the side table mapping strategy, ensuring that no temporary mutation of $v$ occurs during GC. The use of a separate mapping $F$ prevents any write to header fields in from-space, thereby protecting $v$.\n\nDefinitions to use:\n- The heap graph is $G = (V, E)$, where $V$ is the set of objects and $E$ connotes pointer fields as directed edges.\n- The root set is $\\mathcal{R} \\subseteq V$.\n- The relocation mapping is $M : V_{\\text{from}} \\to V_{\\text{to}}$ defined exactly for reachable objects, i.e., for all $o \\in \\text{Reach}(\\mathcal{R}, G)$, $M(o)$ is the relocated copy.\n- The invariants to check after GC are:\n  1. For every relocated object $o$, its vtable pointer $v$ is unchanged: $v_{\\text{before}}(o) = v_{\\text{after}}(M(o))$.\n  2. For every relocated object $o$, its type identifier $\\tau$ is preserved: $\\tau_{\\text{before}}(o) = \\tau_{\\text{after}}(M(o))$.\n  3. For every pointer field $f$ of relocated object $o$, if it referenced $o'$ in from-space, then after GC it references $M(o')$ in to-space. That is, all edges $E$ among reachable objects must be rewritten from from-space addresses to to-space addresses using $M$.\n  4. No pointer field of any relocated object references into from-space after GC.\n  5. Unreachable objects are not evacuated: if $u \\notin \\text{Reach}(\\mathcal{R}, G)$, then $M(u)$ is undefined and $u$ must not appear in to-space.\n\nImplementation constraints:\n- Model exactly two types with unique vtables:\n  - Type $\\text{A}$ has identifier $\\tau_{\\text{A}} = 1$.\n  - Type $\\text{B}$ has identifier $\\tau_{\\text{B}} = 2$.\n- Each object header must contain a vtable pointer $v$, a type identifier $\\tau$, a pointer field count $p$, and the total object size in bytes $s$ (which should be padded to the alignment of pointer-sized fields to ensure correct scanning).\n- Your semispaces must be explicitly represented as contiguous byte arrays; allocation must be a bump-pointer scheme with alignment to the alignment of pointer-sized fields.\n- Your GC must be a copying collector with breadth-first scanning (Cheney-style), but using the side table mapping for forwarding to preserve vtable pointer stability.\n- RTTI check to verify after relocation: for each object $o$, the predicate $v(o) = v_{\\text{A}}$ must be equivalent to $\\tau(o) = \\tau_{\\text{A}}$, and $v(o) = v_{\\text{B}}$ must be equivalent to $\\tau(o) = \\tau_{\\text{B}}$, where $v_{\\text{A}}$ and $v_{\\text{B}}$ are the unique vtable addresses of Type $\\text{A}$ and Type $\\text{B}$ respectively.\n\nTest suite:\nYour program must construct the following four test heaps and run the GC on each, verifying all invariants, and produce a single boolean per test case ($1$ for pass, $0$ for fail):\n\n- Test case $1$ (happy path): A chain $\\text{A}_1 \\to \\text{B}_1 \\to \\text{A}_2$ with one root $\\text{A}_1$. Here, $\\text{A}_1$ has $p = 1$, $\\text{B}_1$ has $p = 1$, and $\\text{A}_2$ has $p = 0$.\n- Test case $2$ (boundary condition): A single root object of type $\\text{A}$ with $p = 0$.\n- Test case $3$ (cycle): Two objects $\\text{A}_1$ and $\\text{B}_1$ with pointers $\\text{A}_1 \\to \\text{B}_1$ and $\\text{B}_1 \\to \\text{A}_1$, and a single root $\\text{A}_1$; both have $p = 1$.\n- Test case $4$ (null and unreachable): One root $\\text{A}_1$ with $p = 2$ whose first field points to a $\\text{B}_1$ with $p = 0$ and second field is $\\text{NULL}$, plus an unreachable $\\text{B}_2$ with $p = 0$ that is not in the root set and is not pointed to by any reachable object.\n\nSemispace sizes:\n- Use a from-space and a to-space, each with capacity $8192$ bytes. This capacity must be sufficient to hold all objects in each test case.\n\nFinal output specification:\n- For each test case, compute a boolean that is $1$ if and only if all invariants hold, and $0$ otherwise.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact format $[r_1,r_2,r_3,r_4]$, where $r_i \\in \\{0,1\\}$ is the boolean for test case $i$.\n- There is no user input, and no physical units or angles are involved in this problem.\n\nYour program must be self-contained and runnable \"as is\". The solution must derive and justify the design choices from the fundamental definitions above and implement the checks required by the test suite.", "solution": "The problem requires the implementation and verification of a moving garbage collector based on a semispace copying strategy. The central constraint is the use of a side table for forwarding pointers to ensure the stability of virtual method table (vtable) pointers in object headers throughout the collection cycle. This solution is designed around fundamental principles of memory management, data structure representation in low-level languages, and algorithmic verification.\n\nFirst, we establish the data structures to model the heap, objects, and types as specified.\n\nA heap object is a contiguous block of memory comprising a header and a payload. The header, `ObjectHeader`, is defined as a C `struct` containing four fields as required:\n1.  A vtable pointer $v$, represented as `void* vtable_ptr`.\n2.  A type identifier $\\tau$, represented as `int type_id`.\n3.  The number of pointer fields $p$ in the payload, represented as `int num_pointers`.\n4.  The total aligned size of the object in bytes $s$, represented as `size_t total_size`.\n\nThe payload directly follows the header and consists of $p$ pointers, each of size `sizeof(void*)`. The total object size $s$ is calculated as the sum of the header size and the payload size, padded to ensure alignment on a `sizeof(void*)` boundary. This alignment is crucial for correctly scanning pointer fields and for performance on many hardware architectures. Allocation is performed within a contiguous memory region, the `from-space`, using a simple bump-pointer technique, where a pointer is advanced by the aligned size of each new object.\n\nTwo distinct object types, Type $\\text{A}$ and Type $\\text{B}$, are defined with unique type identifiers $\\tau_{\\text{A}} = 1$ and $\\tau_{\\text{B}} = 2$. Their unique vtable pointers, $v_{\\text{A}}$ and $v_{\\text{B}}$, are realized by taking the addresses of two distinct `static` global variables. This ensures each type has a unique, constant vtable address throughout the program's execution, which is essential for Runtime Type Information (RTTI) checks.\n\nThe core of the solution is the `run_gc` function, which implements the semispace copying collector. The heap is divided into two equally sized semispaces, `from-space` and `to-space`, each a byte array of size $8192$. The collection process proceeds in three main phases:\n\n1.  **Initialization**: The roles of the spaces are designated. Objects are initially allocated in what is considered the `from-space`. The `to-space` is initially empty. Two pointers, `scan_ptr` and `free_ptr`, are initialized to the start of `to-space`. A side table, an array of `{old_address, new_address}` pairs, is cleared. This table, denoted $F$, will store the relocation mapping $M$.\n\n2.  **Evacuation and Traversal**: The collector starts by evacuating objects directly reachable from the root set $\\mathcal{R}$. For each root pointer, the referenced object is copied from `from-space` to `to-space` by the `copy_and_forward` helper function. This function first consults the side table $F$ to see if the object has already been moved. If not, it allocates space for the object in `to-space` (at `free_ptr`), copies the object's data bit-for-bit, records the mapping from its old address to its new address in $F$, and advances `free_ptr`. The root pointer is then updated to point to the new location in `to-space`. This use of a side table is critical, as it avoids modifying the original object in `from-space`, thereby preserving its header fields, including the vtable pointer $v$, until the `from-space` is completely discarded.\n\n    After evacuating the roots, the collector enters a loop analogous to a breadth-first search, commonly associated with Cheney's algorithm. It iterates while `scan_ptr  free_ptr`. The `scan_ptr` points to the next object in `to-space` whose pointers need to be updated. For each pointer field in the object at `scan_ptr`, the collector evacuates the referenced object (if it's not `NULL` and resides in `from-space`) using the same `copy_and_forward` logic. The pointer field is then updated to the object's new address in `to-space`. After all pointers in the current object are processed, `scan_ptr` is advanced to the next object. The region between `scan_ptr` and `free_ptr` acts as a queue of objects that have been copied but not yet scanned. The loop terminates when `scan_ptr` catches up to `free_ptr`, at which point all reachable objects have been copied to `to-space` and all their internal and root pointers have been updated.\n\n3.  **Finalization**: Once the traversal is complete, the `to-space` contains the compacted, live data set, and the `from-space` contains only garbage and abandoned original objects. The `from-space` can be cleared and becomes the `to-space` for the next GC cycle.\n\nA rigorous verification process is implemented to confirm the correctness of the collector against the specified invariants. This process consists of two stages:\n\n1.  **Pre-GC Snapshot**: Before garbage collection, a traversal of the object graph $G = (V, E)$ is performed starting from the root set $\\mathcal{R}$ to identify the full set of reachable objects, $\\text{Reach}(\\mathcal{R}, G)$. The state of each reachable object (its address, header contents $v, \\tau, p, s$, and payload pointers) is recorded in a \"snapshot\" data structure. This provides a definitive baseline for comparison. A list of all allocated objects is also maintained to identify unreachable objects.\n\n2.  **Post-GC Verification**: After the GC completes, a comprehensive set of checks is performed:\n    -   **Invariant $1$  $2$ (Vtable/Type Stability)**: For each object $o$ in the pre-GC snapshot, its relocated copy $M(o)$ is located using the side table $F$. The vtable pointer and type ID of $M(o)$ are compared against the snapshot of $o$ to verify $v_{\\text{before}}(o) = v_{\\text{after}}(M(o))$ and $\\tau_{\\text{before}}(o) = \\tau_{\\text{after}}(M(o))$.\n    -   **Invariant $3$ (Pointer Fixup)**: For each pointer field in $o$ that pointed to an object $o'$, it is verified that the corresponding field in $M(o)$ now points to $M(o')$. `NULL` pointers must remain `NULL`.\n    -   **Invariant $4$ (To-space Integrity)**: Every object in `to-space` is scanned to ensure none of its pointer fields point back to `from-space`. All non-`NULL` pointers must lie within the bounds of `to-space`.\n    -   **Invariant $5$ (Unreachables Discarded)**: It is verified that any object identified as unreachable before the GC does not have a corresponding entry in the forwarding side table $F$, confirming it was not evacuated.\n    -   **RTTI Verification**: For every relocated object $o'$ in `to-space`, the RTTI-like predicates $v(o') = v_{\\text{A}} \\iff \\tau(o') = \\tau_{\\text{A}}$ and $v(o') = v_{\\text{B}} \\iff \\tau(o') = \\tau_{\\text{B}}$ are checked to ensure type information remains consistent.\n\nThis two-stage verification process, combined with the careful implementation of the side-table-based copying collector, provides a robust confirmation that all specified correctness criteria, especially the critical invariant of vtable pointer stability, are met for each of the four test cases. A test case passes (evaluates to $1$) if and only if all these checks succeed.", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// Disable complex.h, threads.h, and stdatomic.h as they are not used.\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n// =============================================================================\n// GLOBAL DEFINITIONS\n// =============================================================================\n\n#define HEAP_SIZE 8192\n#define MAX_OBJECTS_PER_TEST 10\n#define MAX_POINTERS_PER_OBJECT 4\n\n// Type system definitions\n#define TYPE_A_ID 1\n#define TYPE_B_ID 2\n\n// V-tables are modeled by the addresses of static variables.\nstatic char vtable_A_storage;\nstatic char vtable_B_storage;\nstatic void* VTABLE_A = vtable_A_storage;\nstatic void* VTABLE_B = vtable_B_storage;\n\n// Object header structure\ntypedef struct {\n    void* vtable_ptr;\n    int type_id;\n    int num_pointers;\n    size_t total_size;\n} ObjectHeader;\n\n// =============================================================================\n// HELPER FUNCTIONS  STRUCTURES\n// =============================================================================\n\n// Aligns a size to the machine's pointer size.\nstatic size_t align_size(size_t size) {\n    const size_t alignment = sizeof(void*);\n    return (size + alignment - 1)  ~(alignment - 1);\n}\n\n// Gets a pointer to the payload (the first pointer field) of an object.\nstatic void** get_payload(void* obj_ptr) {\n    return (void**)((char*)obj_ptr + sizeof(ObjectHeader));\n}\n\n// Allocates an object in a given memory space using a bump pointer.\nstatic void* allocate_object(char** alloc_ptr, char* heap_end, int type_id, int num_pointers) {\n    void* vtable = (type_id == TYPE_A_ID) ? VTABLE_A : VTABLE_B;\n    size_t size = align_size(sizeof(ObjectHeader) + (size_t)num_pointers * sizeof(void*));\n\n    if (*alloc_ptr + size  heap_end) {\n        return NULL; // Out of memory\n    }\n\n    void* obj_ptr = *alloc_ptr;\n    *alloc_ptr += size;\n\n    ObjectHeader* header = (ObjectHeader*)obj_ptr;\n    header-vtable_ptr = vtable;\n    header-type_id = type_id;\n    header-num_pointers = num_pointers;\n    header-total_size = size;\n\n    // Initialize payload pointers to NULL\n    void** payload = get_payload(obj_ptr);\n    for (int i = 0; i  num_pointers; ++i) {\n        payload[i] = NULL;\n    }\n\n    return obj_ptr;\n}\n\n// =============================================================================\n// GARBAGE COLLECTOR IMPLEMENTATION\n// =============================================================================\n\ntypedef struct {\n    void* old_addr;\n    void* new_addr;\n} ForwardingEntry;\n\n// Finds the new address for an old address in the side table.\nstatic void* find_forwarding_address(void* old_addr, const ForwardingEntry* table, int table_size) {\n    for (int i = 0; i  table_size; ++i) {\n        if (table[i].old_addr == old_addr) {\n            return table[i].new_addr;\n        }\n    }\n    return NULL;\n}\n\n// Copies an object to to-space and sets up forwarding, if not already done.\nstatic void* copy_and_forward(void* old_obj_ptr, char** free_ptr, char* to_space_end, ForwardingEntry* table, int* table_size) {\n    if (old_obj_ptr == NULL) {\n        return NULL;\n    }\n\n    // Check if already forwarded\n    void* new_addr = find_forwarding_address(old_obj_ptr, table, *table_size);\n    if (new_addr != NULL) {\n        return new_addr;\n    }\n\n    // Copy the object\n    ObjectHeader* old_header = (ObjectHeader*)old_obj_ptr;\n    size_t size = old_header-total_size;\n\n    if (*free_ptr + size  to_space_end) {\n        // This case should not happen with the given problem constraints.\n        return NULL; // To-space full\n    }\n\n    void* new_obj_ptr = *free_ptr;\n    *free_ptr += size;\n\n    memcpy(new_obj_ptr, old_obj_ptr, size);\n\n    // Add to forwarding table\n    table[*table_size].old_addr = old_obj_ptr;\n    table[*table_size].new_addr = new_obj_ptr;\n    (*table_size)++;\n    \n    return new_obj_ptr;\n}\n\n// Main GC function\nstatic void run_gc(void** roots, int num_roots, char* from_space, char* to_space,\n                   ForwardingEntry* forwarding_table, int* forwarding_table_size) {\n    \n    char* scan_ptr = to_space;\n    char* free_ptr = to_space;\n    char* to_space_end = to_space + HEAP_SIZE;\n\n    // 1. Evacuate roots\n    for (int i = 0; i  num_roots; ++i) {\n        if (roots[i] != NULL) {\n            roots[i] = copy_and_forward(roots[i], free_ptr, to_space_end, forwarding_table, forwarding_table_size);\n        }\n    }\n\n    // 2. Scan to-space\n    while (scan_ptr  free_ptr) {\n        ObjectHeader* current_header = (ObjectHeader*)scan_ptr;\n        void** payload = get_payload(scan_ptr);\n\n        for (int i = 0; i  current_header-num_pointers; ++i) {\n            void* old_child_ptr = payload[i];\n            if (old_child_ptr != NULL) {\n                payload[i] = copy_and_forward(old_child_ptr, free_ptr, to_space_end, forwarding_table, forwarding_table_size);\n            }\n        }\n        scan_ptr += current_header-total_size;\n    }\n}\n\n// =============================================================================\n// VERIFICATION LOGIC\n// =============================================================================\n\n// Snapshot of an object's state for verification\ntypedef struct {\n    void* addr;\n    ObjectHeader header;\n    void* pointers[MAX_POINTERS_PER_OBJECT];\n} ObjectSnapshot;\n\n// Simple set for tracking visited addresses during graph traversal\ntypedef struct {\n    void* addresses[MAX_OBJECTS_PER_TEST];\n    int count;\n} AddressSet;\n\nstatic int address_set_contains(const AddressSet* set, void* addr) {\n    for (int i = 0; i  set-count; ++i) {\n        if (set-addresses[i] == addr) return 1;\n    }\n    return 0;\n}\n\nstatic void address_set_add(AddressSet* set, void* addr) {\n    if (!address_set_contains(set, addr)) {\n        if (set-count  MAX_OBJECTS_PER_TEST) {\n            set-addresses[set-count++] = addr;\n        }\n    }\n}\n\n// Recursively captures the state of all reachable objects.\nstatic void capture_state_recursive(void* obj_ptr, ObjectSnapshot* snapshots, int* num_snapshots, AddressSet* visited) {\n    if (obj_ptr == NULL || address_set_contains(visited, obj_ptr)) {\n        return;\n    }\n    address_set_add(visited, obj_ptr);\n\n    ObjectHeader* header = (ObjectHeader*)obj_ptr;\n    ObjectSnapshot* snap = snapshots[*num_snapshots];\n    *num_snapshots = *num_snapshots + 1;\n\n    snap-addr = obj_ptr;\n    snap-header = *header;\n    void** payload = get_payload(obj_ptr);\n    for (int i = 0; i  header-num_pointers; i++) {\n        snap-pointers[i] = payload[i];\n    }\n\n    for (int i = 0; i  header-num_pointers; i++) {\n        capture_state_recursive(payload[i], snapshots, num_snapshots, visited);\n    }\n}\n\n// Main verification function\nstatic int verify_all_invariants(const ObjectSnapshot* pre_gc_snapshots, int num_pre_gc_snapshots,\n                                const void* const* all_allocated_objs, int num_all_allocated,\n                                const ForwardingEntry* fwd_table, int fwd_table_size,\n                                const char* to_space) {\n\n    // Check 5 (part 1): Number of moved objects must match number of reachable objects.\n    if (num_pre_gc_snapshots != fwd_table_size) return 0;\n\n    // Check 5 (part 2): Unreachable objects must not be copied.\n    for (int i = 0; i  num_all_allocated; ++i) {\n        void* obj = (void*)all_allocated_objs[i];\n        int is_reachable = 0;\n        for (int j = 0; j  num_pre_gc_snapshots; ++j) {\n            if (pre_gc_snapshots[j].addr == obj) {\n                is_reachable = 1;\n                break;\n            }\n        }\n        if (!is_reachable) {\n            if (find_forwarding_address(obj, fwd_table, fwd_table_size) != NULL) {\n                return 0; // Unreachable object was copied.\n            }\n        }\n    }\n\n    // Check invariants 1, 2, 3 for all reachable objects\n    for (int i = 0; i  num_pre_gc_snapshots; ++i) {\n        const ObjectSnapshot* old_snap = pre_gc_snapshots[i];\n        void* new_addr = find_forwarding_address(old_snap-addr, fwd_table, fwd_table_size);\n        if (new_addr == NULL) return 0; // Reachable object was not copied.\n\n        ObjectHeader* new_header = (ObjectHeader*)new_addr;\n\n        // Invariant 1: Vtable pointer stability\n        if (old_snap-header.vtable_ptr != new_header-vtable_ptr) return 0;\n        // Invariant 2: Type ID preservation\n        if (old_snap-header.type_id != new_header-type_id) return 0;\n\n        // Invariant 3: Pointer fixup\n        void** new_payload = get_payload(new_addr);\n        for (int j = 0; j  old_snap-header.num_pointers; ++j) {\n            void* old_child_addr = old_snap-pointers[j];\n            void* expected_new_child_addr = find_forwarding_address(old_child_addr, fwd_table, fwd_table_size);\n            if (new_payload[j] != expected_new_child_addr) return 0;\n        }\n    }\n\n    // Check invariant 4 and RTTI\n    char* current = (char*)to_space;\n    char* end_of_used_space = (char*)find_forwarding_address(NULL, NULL, 0); // Effectively start of free block\n    if(fwd_table_size  0){\n        void* last_obj_old_addr = fwd_table[fwd_table_size - 1].old_addr;\n        ObjectHeader* last_obj_old_header = (ObjectHeader*) last_obj_old_addr;\n        end_of_used_space = (char*)fwd_table[fwd_table_size-1].new_addr + last_obj_old_header-total_size;\n\n        // This is a bit of a hack to get the end of used space\n        // A better GC would track the free pointer in to_space\n        // Find the object with the highest new address\n        char* max_addr = (char*)to_space;\n        for (int i=0; ifwd_table_size; ++i) {\n            ObjectHeader* h = (ObjectHeader*)fwd_table[i].old_addr;\n            char* obj_end = (char*)fwd_table[i].new_addr + h-total_size;\n            if(obj_end  max_addr) max_addr = obj_end;\n        }\n        end_of_used_space = max_addr;\n    } else {\n        end_of_used_space = (char*)to_space;\n    }\n\n\n    while (current  end_of_used_space) {\n        ObjectHeader* header = (ObjectHeader*)current;\n        void** payload = get_payload(current);\n\n        // Invariant 4: No pointers from to-space to from-space\n        for (int i = 0; i  header-num_pointers; ++i) {\n            if (payload[i] != NULL  (payload[i]  (void*)to_space || payload[i] = (void*)end_of_used_space)) {\n                return 0; // Pointer points outside to-space\n            }\n        }\n\n        // RTTI check\n        int rtti_a_ok = (header-vtable_ptr == VTABLE_A) == (header-type_id == TYPE_A_ID);\n        int rtti_b_ok = (header-vtable_ptr == VTABLE_B) == (header-type_id == TYPE_B_ID);\n        if (!rtti_a_ok || !rtti_b_ok) return 0;\n\n        current += header-total_size;\n    }\n\n    return 1; // All invariants passed\n}\n\n// =============================================================================\n// TEST CASES\n// =============================================================================\n\n// Run a test with a given setup function.\nstatic int run_test(void (*setup_func)(char*, void**, int*, void**, int*)) {\n    char from_space[HEAP_SIZE];\n    char to_space[HEAP_SIZE];\n    memset(from_space, 0, HEAP_SIZE);\n    memset(to_space, 0, HEAP_SIZE);\n\n    void* roots[MAX_OBJECTS_PER_TEST];\n    int num_roots = 0;\n    void* all_allocated[MAX_OBJECTS_PER_TEST];\n    int num_all_allocated = 0;\n\n    setup_func(from_space, roots, num_roots, all_allocated, num_all_allocated);\n\n    ObjectSnapshot pre_gc_snapshots[MAX_OBJECTS_PER_TEST];\n    int  num_pre_gc_snapshots = 0;\n    AddressSet visited = { .count = 0 };\n    for (int i = 0; i  num_roots; ++i) {\n        capture_state_recursive(roots[i], pre_gc_snapshots, num_pre_gc_snapshots, visited);\n    }\n    \n    ForwardingEntry fwd_table[MAX_OBJECTS_PER_TEST] = {0};\n    int fwd_table_size = 0;\n    \n    run_gc(roots, num_roots, from_space, to_space, fwd_table, fwd_table_size);\n    \n    return verify_all_invariants(pre_gc_snapshots, num_pre_gc_snapshots, all_allocated, num_all_allocated, fwd_table, fwd_table_size, to_space);\n}\n\nvoid setup_test_case_1(char* heap, void** roots, int* num_roots, void** all_allocated, int* num_all_allocated) {\n    char* alloc_ptr = heap;\n    void* a1 = allocate_object(alloc_ptr, heap + HEAP_SIZE, TYPE_A_ID, 1);\n    void* b1 = allocate_object(alloc_ptr, heap + HEAP_SIZE, TYPE_B_ID, 1);\n    void* a2 = allocate_object(alloc_ptr, heap + HEAP_SIZE, TYPE_A_ID, 0);\n    *get_payload(a1) = b1;\n    *get_payload(b1) = a2;\n    roots[0] = a1; *num_roots = 1;\n    all_allocated[0] = a1; all_allocated[1] = b1; all_allocated[2] = a2; *num_all_allocated = 3;\n}\n\nvoid setup_test_case_2(char* heap, void** roots, int* num_roots, void** all_allocated, int* num_all_allocated) {\n    char* alloc_ptr = heap;\n    void* a1 = allocate_object(alloc_ptr, heap + HEAP_SIZE, TYPE_A_ID, 0);\n    roots[0] = a1; *num_roots = 1;\n    all_allocated[0] = a1; *num_all_allocated = 1;\n}\n\nvoid setup_test_case_3(char* heap, void** roots, int* num_roots, void** all_allocated, int* num_all_allocated) {\n    char* alloc_ptr = heap;\n    void* a1 = allocate_object(alloc_ptr, heap + HEAP_SIZE, TYPE_A_ID, 1);\n    void* b1 = allocate_object(alloc_ptr, heap + HEAP_SIZE, TYPE_B_ID, 1);\n    *get_payload(a1) = b1;\n    *get_payload(b1) = a1;\n    roots[0] = a1; *num_roots = 1;\n    all_allocated[0] = a1; all_allocated[1] = b1; *num_all_allocated = 2;\n}\n\nvoid setup_test_case_4(char* heap, void** roots, int* num_roots, void** all_allocated, int* num_all_allocated) {\n    char* alloc_ptr = heap;\n    void* a1 = allocate_object(alloc_ptr, heap + HEAP_SIZE, TYPE_A_ID, 2);\n    void* b1 = allocate_object(alloc_ptr, heap + HEAP_SIZE, TYPE_B_ID, 0);\n    void* b2 = allocate_object(alloc_ptr, heap + HEAP_SIZE, TYPE_B_ID, 0); // Unreachable\n    void** a1_payload = get_payload(a1);\n    a1_payload[0] = b1;\n    a1_payload[1] = NULL;\n    roots[0] = a1; *num_roots = 1;\n    all_allocated[0] = a1; all_allocated[1] = b1; all_allocated[2] = b2; *num_all_allocated = 3;\n}\n\n\nint main(void) {\n    int results[4];\n    results[0] = run_test(setup_test_case_1);\n    results[1] = run_test(setup_test_case_2);\n    results[2] = run_test(setup_test_case_3);\n    results[3] = run_test(setup_test_case_4);\n\n    printf(\"[%d,%d,%d,%d]\\n\", results[0], results[1], results[2], results[3]);\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3644873"}]}