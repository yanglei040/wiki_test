{"hands_on_practices": [{"introduction": "Understanding how a program locates variables in memory is a cornerstone of compiler design. This first exercise provides a concrete scenario to practice the fundamental calculation for determining a variable's absolute address. By working with given activation record base addresses and compile-time offsets, you will see precisely how the runtime system combines these two pieces of information to access data, reinforcing the core principles of memory layout in a block-structured language. [@problem_id:3633091]", "problem": "A statically scoped language with nested procedures uses activation records with both a Control Link (dynamic link, DL) and an Access Link (static link, SL). The Control Link (DL) points to the activation record of the caller to support returns. The Access Link (SL) points to the activation record of the lexically enclosing procedure to support nonlocal access. Each activation record has a base (frame) address, and a local variable declared in a procedure at compile-time offset is addressed at the sum of the procedure’s activation record base and that offset. Assume that an Access Link (SL) field always contains the base address of the lexically enclosing activation record, and that offsets are measured relative to the base address of the activation record.\n\nConsider the following two scenarios. In both scenarios, a global procedure $G$ lexically contains procedure $A$, which (in Scenario $1$) lexically contains $B$, which contains $C$, which contains $D$. Procedure $D$ references a nonlocal variable $x$ declared in $A$ at compile-time offset $+48$ from $A$’s activation record base.\n\nScenario $1$ (original nesting):\n- Live activation records at the moment of the reference in $D$ have the following base addresses and Access Link (SL) contents:\n  - $D$: base $= 8280$, $SL(D) = 8420$.\n  - $C$: base $= 8420$, $SL(C) = 8600$.\n  - $B$: base $= 8600$, $SL(B) = 8800$.\n  - $A$: base $= 8800$, $SL(A) = 9000$.\n  - $G$: base $= 9000$.\n\nScenario $2$ (modified nesting): insert a new lexical wrapper procedure $E$ between $A$ and $B$ (so that $G$ contains $A$, $A$ contains $E$, $E$ contains $B$, $B$ contains $C$, and $C$ contains $D$). In a separate run under this modified nesting, the live activation records at the moment of the reference in $D$ have:\n- $D$: base $= 10840$, $SL(D) = 11000$.\n- $C$: base $= 11000$, $SL(C) = 11240$.\n- $B$: base $= 11240$, $SL(B) = 11520$.\n- $E$: base $= 11520$, $SL(E) = 11720$.\n- $A$: base $= 11720$, $SL(A) = 12000$.\n- $G$: base $= 12000$.\n\nUsing only the foundational facts above about Control Links (DL), Access Links (SL), and activation record addressing, compute the address of the nonlocal variable $x$ as referenced from within $D$ in Scenario $1$, and then recompute it for Scenario $2$. Report the single scalar quantity $\\Delta$ defined as\n$$\n\\Delta \\;=\\; \\text{addr}_{2}(x) \\;-\\; \\text{addr}_{1}(x),\n$$\nwhere $\\text{addr}_{1}(x)$ and $\\text{addr}_{2}(x)$ are the addresses of $x$ in Scenarios $1$ and $2$, respectively. Provide the final value of $\\Delta$ as an exact integer. Do not round.", "solution": "The problem requires the computation of the difference in the memory address of a nonlocal variable $x$ between two scenarios involving nested procedures in a statically scoped language. The fundamental principle for addressing, as stated in the problem, is that the address of a variable is the sum of the base address of its procedure's activation record and its compile-time offset within that record.\n\nThe variable in question, $x$, is declared in procedure $A$ at a compile-time offset of $48$. Let $\\text{base\\_addr}(A)$ be the base address of the activation record for procedure $A$, and $\\text{offset}(x)$ be the compile-time offset of $x$. The memory address of $x$, denoted as $\\text{addr}(x)$, is given by the formula:\n$$\n\\text{addr}(x) = \\text{base\\_addr}(A) + \\text{offset}(x)\n$$\nThe problem describes Access Links ($SL$) as the mechanism to locate the activation record of a lexically enclosing procedure. For instance, when code in procedure $D$ references the variable $x$ declared in $A$, the runtime system would typically follow a chain of Access Links from $D$'s activation record until it reaches $A$'s activation record. The length of this chain depends on the static nesting depth between the referencing procedure ($D$) and the defining procedure ($A$). However, the problem provides the base addresses of all relevant activation records directly for both scenarios, which obviates the need to perform this traversal. We can use the given base addresses of $A$'s activation record directly.\n\nIn Scenario $1$, the lexical nesting is $G \\supset A \\supset B \\supset C \\supset D$. The problem provides the live activation record data at the moment of reference. Specifically for procedure $A$, it states:\n- $A$: base = 8800.\n\nLet $\\text{addr}_1(x)$ be the address of $x$ in Scenario 1. Using the given base address and the constant offset of $x$:\n$$\n\\text{addr}_1(x) = \\text{base\\_addr}_1(A) + \\text{offset}(x) = 8800 + 48 = 8848\n$$\n\nIn Scenario $2$, a new procedure $E$ is introduced, modifying the lexical nesting to $G \\supset A \\supset E \\supset B \\supset C \\supset D$. The problem provides a new set of activation record data for a separate run. For procedure $A$, this data is:\n- $A$: base = 11720.\n\nLet $\\text{addr}_2(x)$ be the address of $x$ in Scenario 2. The offset of $x$ within $A$ is a compile-time constant and remains unchanged. The base address of $A$'s activation record is different in this run.\n$$\n\\text{addr}_2(x) = \\text{base\\_addr}_2(A) + \\text{offset}(x) = 11720 + 48 = 11768\n$$\nThe problem asks for the quantity $\\Delta$, defined as the difference between these two addresses:\n$$\n\\Delta = \\text{addr}_2(x) - \\text{addr}_1(x)\n$$\nSubstituting the calculated values:\n$$\n\\Delta = 11768 - 8848\n$$\nPerforming the subtraction:\n$$\n\\Delta = 2920\n$$\nThe information regarding Control Links ($DL$), the base addresses of other procedures ($B$, $C$, $D$, $E$, $G$), and the contents of the Access Link ($SL$) fields, while consistent with the described static scoping rules, is ultimately auxiliary to the calculation, as the determinative values—the base addresses of $A$'s activation record in each scenario—are provided directly.", "answer": "$$\\boxed{2920}$$", "id": "3633091"}, {"introduction": "Moving from pure calculation to active simulation provides a much deeper insight into runtime mechanics. This practice challenges you to implement the very data structures that manage program execution: activation records, complete with their control and access links. By building a small program that simulates a nested call sequence, you will directly manipulate the dynamic call chain and the static scope chain, solidifying your understanding of how they work together to enable complex features like recursion and non-local variable access. [@problem_id:3633059]", "problem": "You are to construct a small, self-contained correctness test program that simulates how a compiler’s runtime system maintains activation records, control links, and access links for lexically nested functions. The goal is to reason from principles and produce an executable artifact that demonstrates the interplay of dynamic links and access links.\n\nFundamental base:\n- The term Activation Record (AR) denotes the runtime data structure created for each function activation; it contains bookkeeping information such as a return address, local variables, a dynamic link, and an access link.\n- The dynamic link is a pointer from the current activation record to the activation record of its caller, representing the call chain in the order actually executed (dynamic chain).\n- The access link, also called static link, is a pointer from the current activation record to the activation record of the lexically enclosing function, representing the lexical nesting structure (static chain).\n- Under lexically scoped languages, variable resolution proceeds along the static chain: to access a nonlocal variable defined at an ancestor lexical level, follow the access link the required number of hops until the appropriate activation record is reached.\n\nProblem scenario:\n- Consider a lexically nested trio of functions with levels denoted by $L=0$ for the outermost root function, $L=1$ for its nested outer function, and $L=2$ for the inner function nested inside the outer function. Let the root function at level $L=0$ have a local variable $A$, the outer function at level $L=1$ have a local variable $B$, and the inner function at level $L=2$ have a local variable $C$.\n- The outer function’s value is defined as the sum of the root’s $A$ and the outer’s $B$. Because $A$ is defined at the lexical level $L=0$, the outer function must obtain $A$ by following its access link to the root’s activation record and reading $A$ there.\n- The inner function must perform two actions:\n  1. It must call the outer function while the outer function is already active. This call requires the correct dynamic link for return and the correct access link for the callee so that the outer function, when reentered, still refers to the appropriate root $A$. This embodies the need to compute and pass the callee’s access link based on lexical levels.\n  2. It must reference the root’s $A$ by following its own access link twice (from level $L=2$ to $L=1$, then $L=1$ to $L=0$), thereby reading the outer’s outer variable.\n- The inner function’s result is the sum of the outer function’s current value (obtained by calling it), plus the root’s $A$ that it reached via two access-link hops, plus its own local $C$. This enforces both the dynamic link (for the call/return between inner and outer) and the access link (for traversing $L=2 \\rightarrow L=1 \\rightarrow L=0$).\n\nImplementation requirements:\n- Write a complete program that constructs explicit activation records with fields for lexical level, dynamic link, access link, and locals. It should implement function calls that compute the callee’s access link from the caller’s access chain using the lexical nesting rule: the callee’s access link must point to its lexically enclosing activation record, which is reached by walking up the caller’s access chain until the appropriate level is found.\n- The program must simulate one top-level run per test case as follows: create the root activation record with its local $A$, then call the outer function with its local $B$, which in turn calls the inner function with its local $C$. The inner function must both call the outer function and follow two access-link hops to reach $A$.\n- Your program should produce numerical results for each test case equal to the inner function’s result as defined above. No external input is allowed; embed the test cases in code.\n\nTest suite:\n- Use the following four test cases, where each test case is a triple $(A,B,C)$:\n  - $(3,4,5)$\n  - $(0,0,0)$\n  - $(-2,5,1)$\n  - $(1000000000,1,2)$\nThese cover a general case, a zero boundary case, a mix of negative and positive values, and a large-value case that remains within safe integer range.\n\nAnswer format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3,r_4]$, where each $r_i$ is the computed integer for the $i$-th test case in the order listed above. There must be no other output.\n\nAngle units and physical units are not applicable here.\n\nConstraints and realism:\n- You must adhere to the definitions of activation record, dynamic link, and access link under lexical scoping. The callee’s access link must be derived from the caller’s current access chain according to the lexical parent of the callee’s lexical level; no shortcuts or direct sharing of caller locals is permitted.\n- Your implementation must be logically consistent, scientifically sound within compiler principles, and must explicitly create and link activation records to reflect both dynamic and static chains.", "solution": "The provided problem statement is valid. It is a well-posed and scientifically grounded problem within the domain of compiler principles, requiring the simulation of runtime data structures for a lexically scoped language. The definitions of activation records, dynamic links, and access links are standard and internally consistent. The scenario is designed to test the core logic of managing these structures, particularly the computation of an access link for a callee and the traversal of the access link chain to resolve non-local variable references.\n\nThe solution involves creating an explicit simulation of the call stack and its associated activation records (ARs). Each AR is represented by a data structure containing pointers for the dynamic and access links, the lexical nesting level of the corresponding function, and storage for its local variable. The program simulates the prescribed call sequence and the internal logic of each function by manually manipulating this stack of ARs.\n\nFirst, we define the structure for an Activation Record, `ActivationRecord`. This structure is the fundamental unit of our simulation.\n- `struct ActivationRecord* dynamic_link`: A pointer to the AR of the calling function. This chain of links represents the dynamic execution path of the program.\n- `struct ActivationRecord* access_link`: A pointer to the AR of the function that lexically encloses the current function. This chain of links represents the static, or lexical, nesting structure of the source code.\n- `int lexical_level`: An integer representing the nesting depth of the function, starting from $L=0$ for the global (root) scope.\n- `long long local_variable`: Storage for the function's local variable. We use `long long` to accommodate the large values in the test suite.\n\nThe simulation proceeds by executing the specified call chain: the top-level environment calls `root` (level $L=0$), which calls `outer` (level $L=1$), which in turn calls `inner` (level $L=2$).\n\n1.  **Call to `root(A)`**: An AR is created for `root`. Its lexical level is set to $L=0$. Its `dynamic_link` and `access_link` are `NULL`, as it is the outermost function with no caller or lexical parent in our simulation scope. Its local variable $A$ is stored.\n\n2.  **Call to `outer(B)` from `root`**: A new AR is created for this first activation of `outer`. Its lexical level is $L=1$.\n    - The `dynamic_link` is set to point to the `root` AR, which is the caller.\n    - The `access_link` must point to the AR of `outer`'s lexical parent, which is `root` (at level $L=0$). The caller (`root` at $L=0$) can find the AR for the callee's parent (level $L=1-1=0$) in its own context; it is simply its own AR.\n\n3.  **Call to `inner(C)` from `outer`**: A new AR is created for `inner`. Its lexical level is $L=2$.\n    - The `dynamic_link` points to the `outer` AR, its caller.\n    - The `access_link` points to `inner`'s lexical parent, which is `outer` (at level $L=1$). The caller (`outer` at $L=1$) provides its own AR as the access link for the callee.\n\nThe core of the problem lies in the logic executed within the `inner` function's context.\n\n**Action 1: `inner` calls `outer`**\nThe `inner` function (at level $L=2$) calls the `outer` function (at level $L=1$). This creates a second, distinct activation record for `outer`.\n- The `dynamic_link` of this new `outer` AR points to the `inner` AR, its caller.\n- The `access_link` must be computed. The callee (`outer`) is defined at level $L=1$, so its lexical parent is at level $L=1-1=0$. The caller (`inner` at $L=2$) must find the most recent AR for level $L=0$ by traversing its own access link chain. The number of hops required is the difference in lexical levels between the caller's level and the callee's parent's level: $L_{\\text{caller}} - L_{\\text{callee_parent}} = 2 - 0 = 2$. However, a more general algorithm states that to find the display entry for the callee's parent, the caller at level $L_c$ must traverse $L_c - (L_q - 1)$ links, where $L_q$ is the callee's level. Here, this is $2 - (1-1) = 2$ hops. Following the chain from `inner`'s AR (`inner_AR` $\\rightarrow$ `outer_AR_1` $\\rightarrow$ `root_AR`) for two steps correctly identifies `root`'s AR. This becomes the `access_link` for the new `outer` AR.\n- The value returned by this `outer` call is defined as the sum of its local $B$ and its lexical parent's $A$. The function finds $A$ by following its newly established `access_link` one step to the `root` AR. The result of this call is thus $A+B$.\n\n**Action 2: `inner` accesses `root`'s variable $A$**\nThe `inner` function needs to access the variable $A$, which is defined in `root`'s scope (level $L=0$).\n- Variable resolution proceeds up the static (access) chain. Starting from `inner`'s AR at level $L=2$, we must find the AR at level $L=0$. This requires traversing $L_{\\text{inner}} - L_{\\text{root}} = 2 - 0 = 2$ access links. The path is again `inner_AR` $\\rightarrow$ `outer_AR_1` $\\rightarrow$ `root_AR`. The value of $A$ is read from this AR.\n\n**Final Calculation**\nThe final result for the `inner` function is the sum of three components as specified:\n1.  The result of its call to the `outer` function: $(A+B)$.\n2.  The value of `root`'s $A$ obtained by traversing two access links: $A$.\n3.  Its own local variable: $C$.\nThe total result is therefore $(A+B) + A + C = 2A + B + C$.\n\nThe provided C program implements this logic in a function `run_simulation`, which meticulously constructs and links activation records on a simulated stack for each test case $(A, B, C)$ and calculates the result according to this derived formula. The `main` function iterates through the test suite and prints the results in the required format.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// Represents an Activation Record (AR) on the call stack.\ntypedef struct ActivationRecord {\n    // Dynamic link (or control link) points to the AR of the caller.\n    struct ActivationRecord* dynamic_link;\n    // Access link (or static link) points to the AR of the lexically enclosing function.\n    struct ActivationRecord* access_link;\n    // The lexical nesting level of the function (e.g., root=0, outer=1, inner=2).\n    int lexical_level;\n    // The value of the single local variable for the function (A, B, or C).\n    long long local_variable;\n} ActivationRecord;\n\n// A simple fixed-size array to act as the call stack for ARs.\n// A size of 10 is more than sufficient for this problem's shallow call depth.\nstatic ActivationRecord stack[10];\n// The stack pointer, pointing to the index of the current (topmost) AR.\nstatic int sp = -1;\n\n// Helper function to find the AR at a specific lexical level by traversing\n// the access link chain from a starting AR.\nActivationRecord* find_ar_for_level(ActivationRecord* start_ar, int target_level) {\n    ActivationRecord* current = start_ar;\n    // Follow the access links until an AR with the target lexical level is found.\n    while (current != NULL && current->lexical_level != target_level) {\n        current = current->access_link;\n    }\n    return current;\n}\n\n// Simulates the entire call chain and computation for a given test case (A, B, C).\nlong long run_simulation(long long A, long long B, long long C) {\n    // Reset stack for the current test case.\n    sp = -1;\n\n    // 1. Simulate top-level call to root(A).\n    // Push AR for root.\n    sp++;\n    ActivationRecord* ar_root = &stack[sp];\n    ar_root->lexical_level = 0;\n    ar_root->local_variable = A;\n    // Root is at the top of the call chain and lexical scope.\n    ar_root->dynamic_link = NULL;\n    ar_root->access_link = NULL;\n\n    // 2. Simulate root calling outer(B).\n    // Push AR for the first activation of outer.\n    sp++;\n    ActivationRecord* ar_outer1 = &stack[sp];\n    ar_outer1->lexical_level = 1;\n    ar_outer1->local_variable = B;\n    // Dynamic link points to the caller, root.\n    ar_outer1->dynamic_link = ar_root;\n    // Access link for outer (level 1) points to its lexical parent (level 0).\n    // The caller (root) is at level 0, so its AR is the one we need.\n    ar_outer1->access_link = find_ar_for_level(ar_root, 0);\n\n    // 3. Simulate outer calling inner(C).\n    // Push AR for inner.\n    sp++;\n    ActivationRecord* ar_inner = &stack[sp];\n    ar_inner->lexical_level = 2;\n    ar_inner->local_variable = C;\n    // Dynamic link points to the caller, outer1.\n    ar_inner->dynamic_link = ar_outer1;\n    // Access link for inner (level 2) points to its lexical parent (level 1).\n    // The caller (outer1) is at level 1, so its AR is the one we need.\n    ar_inner->access_link = find_ar_for_level(ar_outer1, 1);\n\n    // --- Begin execution of logic inside the 'inner' function ---\n\n    // 4. Inner calls outer(B) again.\n    // Push AR for the second activation of outer.\n    sp++;\n    ActivationRecord* ar_outer2 = &stack[sp];\n    ar_outer2->lexical_level = 1;\n    ar_outer2->local_variable = B;\n    // Dynamic link points to the new caller, inner.\n    ar_outer2->dynamic_link = ar_inner;\n    // Access link must point to outer's lexical parent (root at level 0).\n    // The caller (inner at level 2) finds this by traversing its access links.\n    ar_outer2->access_link = find_ar_for_level(ar_inner, 0); // Finds ar_root.\n\n    // 4a. Calculate the return value of this second 'outer' call.\n    // Value = (root's A) + (outer's B).\n    // Get root's A by following outer2's access link.\n    ActivationRecord* root_ar_for_outer2 = ar_outer2->access_link;\n    long long a_val_for_outer2 = root_ar_for_outer2->local_variable;\n    long long b_val_for_outer2 = ar_outer2->local_variable;\n    long long outer2_return_value = a_val_for_outer2 + b_val_for_outer2;\n\n    // 4b. Simulate return from outer2. Pop its AR.\n    sp--;\n\n    // 5. Inner accesses root's A variable.\n    // It must traverse its access links twice (from level 2 to level 0).\n    ActivationRecord* root_ar_for_inner = find_ar_for_level(ar_inner, 0);\n    long long a_val_for_inner = root_ar_for_inner->local_variable;\n\n    // 6. Inner calculates its final result.\n    // Result = (return from outer2) + (A accessed by inner) + (inner's local C).\n    long long c_val_local = ar_inner->local_variable;\n    long long final_result = outer2_return_value + a_val_for_inner + c_val_local;\n\n    // The full call chain would now unwind (pop inner, outer1, root),\n    // but we only need to return the computed result.\n    return final_result;\n}\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    long long A;\n    long long B;\n    long long C;\n} TestCase;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {3, 4, 5},\n        {0, 0, 0},\n        {-2, 5, 1},\n        {1000000000, 1, 2}\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    long long results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        results[i] = run_simulation(test_cases[i].A, test_cases[i].B, test_cases[i].C);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"%lld\", results[i]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3633059"}, {"introduction": "A true test of understanding is not just knowing how a system works, but also being able to predict how it fails. This exercise presents a \"failure injection\" thought experiment where the control and access links are intentionally swapped, a subtle but catastrophic bug. By analyzing the distinct misbehaviors that result—one affecting variable access and the other affecting function returns—you will gain a powerful appreciation for the separate and essential roles these two links play in maintaining program correctness. [@problem_id:3633102]", "problem": "A compiler for a statically scoped, block-structured language (think Pascal-like nested procedures) targets a simple run-time system with the following activation record (AR) conventions. The AR of a callee at frame pointer $FP$ contains two interprocedural links:\n- The control link (also called the dynamic link) at memory address $[FP - 2]$, which must point to the caller’s frame pointer so that the epilogue can restore the caller’s environment.\n- The access link (also called the static link) at memory address $[FP - 1]$, which must point to the lexically enclosing procedure’s frame to support non-local variable access under static scoping.\n\nAssume the following well-tested facts:\n- Statically scoped non-local variable access from a procedure at static nesting depth $d$ to a variable declared $\\Delta d$ levels outward is implemented by following the access link chain $\\Delta d$ times to reach the defining frame, then using a known offset within that frame.\n- The function epilogue restores control by first setting $FP := \\text{mem}[FP - 2]$ and then jumping to a return address stored at a fixed offset $k$ in the caller’s AR, that is, it performs a jump to $\\text{mem}[FP + k]$ after restoring $FP$.\n- The return address itself is not stored in the callee’s AR; it is stored in the caller’s AR at offset $k$ from the caller’s $FP$.\n\nYou are tasked with designing a failure injection test that, at each call, intentionally swaps the values written into the control and access link fields of the callee’s AR (that is, it writes the lexical parent’s frame pointer to $[FP - 2]$ and the caller’s frame pointer to $[FP - 1]$). You must predict the kinds of misbehavior that will result and how to detect each.\n\nConsider two classes of test programs:\n- Class $\\mathcal{V}$ (variable-binding test): A program with three nested procedures $P$, $Q$, and $R$ where $Q$ is nested in $P$, $R$ is also nested in $P$ (so $Q$ and $R$ are siblings), and $Q$ calls $R$. Let $P$ declare a variable $x$ initialized to $x = 1$, let $Q$ declare a local $x = 2$ (shadowing $P$’s $x$), and let $R$ read the non-local $x$ visible under static scoping and return it to $Q$, which then prints it.\n- Class $\\mathcal{C}$ (control-transfer test): A program with $P$ that calls $Q$, and $Q$ that calls $R$. Immediately after the call to $R$, $Q$ executes a distinctive side effect (for example, print the integer $1$), and after $Q$ returns, $P$ executes a different distinctive side effect (for example, print the integer $2$). There are no non-local variable accesses in this program.\n\nSelect all statements that correctly describe the expected misbehavior under the injected fault and a sound detection method for each class of test.\n\nA. In class $\\mathcal{V}$, $R$ will follow the wrong link chain when resolving the non-local $x$, effectively behaving as if the language used dynamic scoping. The observed printout will be $2$ instead of the statically correct $1$. A robust detection method is to use deliberate shadowing as described and compare the observed value against the statically scoped expectation.\n\nB. Swapping the control and access links only affects returns when the caller is also the lexical parent; otherwise, it is harmless. Therefore, class $\\mathcal{C}$ detects no error if $Q$ and $R$ are siblings nested in $P$.\n\nC. In class $\\mathcal{V}$, the first non-local access in $R$ will almost surely crash immediately because the wrong link chain will point to deallocated memory. Thus, a null-dereference or segmentation fault is the primary expected symptom, not a wrong value.\n\nD. In class $\\mathcal{C}$, when $Q$ calls $R$, the epilogue of $R$ will restore $FP$ from the wrong link and then fetch the return address from the wrong caller’s AR (the lexical parent’s frame). Control will resume at $P$’s continuation rather than at $Q$’s post-call site, so the side effect in $Q$ immediately after the call to $R$ will be skipped, and only $P$’s side effect will be observed. A robust detection method is to place distinctive side effects at both post-call sites and check which occur and in what order.\n\nE. General-purpose stack canaries and Address Space Layout Randomization (ASLR) are sufficient to specifically detect the swap of control and access links; therefore, neither class $\\mathcal{V}$ nor class $\\mathcal{C}$ is necessary to reveal the fault with high confidence.\n\nChoose all that apply.", "solution": "### Analysis of the Fault Injection Scenario\n\nThe core of the problem is a fault that swaps the control link and the access link.\n- **Correct State:**\n  - Control Link (at `[FP-2]`) $\\rightarrow$ Caller's Frame\n  - Access Link (at `[FP-1]`) $\\rightarrow$ Lexical Parent's Frame\n- **Faulty State:**\n  - Control Link (at `[FP-2]`) $\\rightarrow$ Lexical Parent's Frame\n  - Access Link (at `[FP-1]`) $\\rightarrow$ Caller's Frame\n\nThis swap has consequences only when the caller is different from the lexical parent. Both test classes are designed to create this divergence.\n\n#### Analysis of Test Class $\\mathcal{V}$ (Variable-Binding Test)\n- **Structure:** $P$ contains siblings $Q$ and $R$.\n- **Call:** $Q$ calls $R$.\n- **Caller vs. Lexical Parent for R:** The caller is $Q$. The lexical parent is $P$. They are different.\n- **Fault Effect:** In $R$'s activation record, the access link will incorrectly point to $Q$'s frame instead of $P$'s frame.\n- **Behavior:** When $R$ needs to access the non-local variable $x$, it follows its access link.\n  - **Correctly:** It would follow the link to $P$'s frame and find $P.x=1$. The program would print $1$.\n  - **Faulty:** It follows the link to $Q$'s frame, finds $Q.x=2$, and returns this value. The program prints $2$.\n- **Conclusion for $\\mathcal{V}$:** The fault causes the program to behave as if it used dynamic scoping (resolving non-local variables by looking in the caller's scope). The result is a wrong value, not a crash, because the caller's frame ($Q$'s) is valid and active on the stack. **Statement A correctly describes this behavior and detection method.** Statement C is incorrect because the faulty link points to a valid, active stack frame, not deallocated memory.\n\n#### Analysis of Test Class $\\mathcal{C}$ (Control-Transfer Test)\n- **Structure:** Assume a similar structure where the call exposes the fault (e.g., $P$ calls $Q$, $Q$ calls $R$, and $Q$ and $R$ are siblings in $P$).\n- **Call:** $Q$ calls $R$.\n- **Caller vs. Lexical Parent for R:** The caller is $Q$. The lexical parent is $P$. They are different.\n- **Fault Effect:** In $R$'s activation record, the control link will incorrectly point to $P$'s frame instead of $Q$'s frame.\n- **Behavior:** When $R$ finishes and executes its epilogue:\n  1. It restores the Frame Pointer: $FP := \\text{mem}[FP_R - 2]$. Due to the fault, this sets $FP$ to $FP_P$ (the frame pointer of $P$).\n  2. It jumps to the return address: `jump to mem[FP + k]`, which is now `jump to mem[FP_P + k]`.\n  3. The return address for the call from $P$ to $Q$ was stored at `mem[FP_P + k]`.\n  4. Therefore, control transfers back to $P$, to the instruction right after its call to $Q$.\n- **Result:** The execution of $Q$ after its call to $R$ is completely bypassed. The side effect `print(1)` is never executed. Execution resumes in $P$, which eventually performs its side effect `print(2)`. The only observed output is $2$.\n- **Conclusion for $\\mathcal{C}$:** The fault causes an incorrect return, skipping part of the caller's code. **Statement D correctly describes this \"long return\" behavior and the detection method.** Statement B is incorrect; it misstates the condition under which the fault is observable—it is observable precisely when the caller and lexical parent are different, which is the case in the described test.\n\n#### Analysis of General Defenses (Statement E)\n- **ASLR and Stack Canaries** are security mechanisms designed to mitigate specific types of memory corruption attacks.\n  - Stack canaries detect buffer overflows that overwrite return addresses on the stack.\n  - ASLR randomizes memory locations to make it harder for an attacker to predict the address of useful code or data.\n- The fault described here is a logical bug in the compiler's code generation. It writes valid, well-aligned pointers to the wrong locations. It does not overflow any buffers or corrupt canaries. ASLR is irrelevant to this logic error. Therefore, these general-purpose defenses will not detect this specific fault.\n- **Conclusion for E:** Statement E is incorrect.\n\n### Final Selection\nBased on the analysis, statements A and D accurately describe the misbehavior and detection methods for the two test classes. Statements B, C, and E are incorrect.", "answer": "$$\\boxed{AD}$$", "id": "3633102"}]}