{"hands_on_practices": [{"introduction": "The decision to designate a register as callee-saved or caller-saved is fundamentally an economic one, balancing the cost paid by the callee against the cost paid by the caller. This exercise [@problem_id:3626228] provides a concrete scenario with two mutually recursive functions, challenging you to perform this cost-benefit analysis on a per-register basis. By calculating the total overhead for different choices based on dynamic execution counts, you will develop a quantitative intuition for making optimal calling convention decisions.", "problem": "Two mutually recursive functions $A$ and $B$ execute under a custom Application Binary Interface (ABI) where the calling convention (assignment of registers as callee-saved versus caller-saved) may be chosen per register. The architecture provides a uniform cost model: each save or restore of a register to the stack costs $\\sigma$ cycles, with $\\sigma = 5$ cycles. Every save is paired with a corresponding restore, so a save-restore pair costs $2\\sigma$ cycles. Assume no optimization eliminates redundant saves or restores, and that all saves and restores required by the chosen convention are performed.\n\nThere is a finite run in which the dynamic counts are measured as follows: the number of entries into $A$ is $N_A = 310$, the number of entries into $B$ is $N_B = 300$, the number of calls from $A$ to $B$ is $C_{AB} = 300$, and the number of calls from $B$ to $A$ is $C_{BA} = 300$. The sets of registers that are live across calls (and also used within the functions) are $L_A = \\{r_1, r_2, r_5\\}$ for function $A$, and $L_B = \\{r_2, r_3, r_5\\}$ for function $B$. The universe of general-purpose registers of interest is $R = \\{r_1, r_2, r_3, r_4, r_5, r_6\\}$, but only the union $U = L_A \\cup L_B = \\{r_1, r_2, r_3, r_5\\}$ appears in the live sets during this run.\n\nBy the foundational definitions of calling conventions:\n- If a register $r$ is designated callee-saved and a function $F$ uses $r$, then on each entry to $F$ the function must save $r$ and, on exit, restore $r$, incurring $2\\sigma$ cycles per entry to $F$.\n- If a register $r$ is designated caller-saved and is live in the caller at a call site, the caller must save $r$ before the call and restore $r$ after the call, incurring $2\\sigma$ cycles per such call.\n\nYou may assign, independently for each register in $U$, whether it is callee-saved or caller-saved. Under these rules and the given dynamic counts, determine the minimal possible total dynamic save/restore overhead across the entire run, expressed in cycles. Provide a single numerical answer; no rounding is required. Express the final answer in cycles.", "solution": "### Step 1: Extract Givens\n- Cost of a single register save or restore operation: $\\sigma = 5$ cycles.\n- Cost of a save-restore pair: $2\\sigma = 10$ cycles.\n- Number of entries into function $A$: $N_A = 310$.\n- Number of entries into function $B$: $N_B = 300$.\n- Number of calls from $A$ to $B$: $C_{AB} = 300$.\n- Number of calls from $B$ to $A$: $C_{BA} = 300$.\n- Set of registers live across calls in function $A$: $L_A = \\{r_1, r_2, r_5\\}$.\n- Set of registers live across calls in function $B$: $L_B = \\{r_2, r_3, r_5\\}$.\n- Universe of registers of interest: $U = L_A \\cup L_B = \\{r_1, r_2, r_3, r_5\\}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is grounded in the principles of computer architecture and compiler design, specifically regarding calling conventions and register allocation. The concepts of callee-saved and caller-saved registers, function call overhead, and liveness analysis are standard and well-defined.\n- **Well-Posedness**: The problem asks for the minimum possible overhead, which is a well-defined optimization problem. The rules for calculating overhead are explicit and unambiguous. The provided data is sufficient to calculate the costs for each possible register convention assignment.\n- **Consistency**: The dynamic counts are consistent. The $N_A = 310$ entries into function $A$ and $C_{BA} = 300$ calls from $B$ to $A$ imply that there were $N_A - C_{BA} = 310 - 300 = 10$ initial entries into $A$ from an external context. The $N_B = 300$ entries into function $B$ and $C_{AB} = 300$ calls from $A$ to $B$ imply that all entries into $B$ originated from $A$. This describes a valid execution trace.\n- **Objectivity**: The problem is stated using objective, quantitative data and formal definitions.\n\nThe problem is valid.\n\n### Step 3: Solution\nThe objective is to determine a calling convention for each register in the set $U = \\{r_1, r_2, r_3, r_5\\}$ that minimizes the total dynamic save/restore overhead. The choice for each register (callee-saved vs. caller-saved) is independent. Therefore, we can minimize the overhead for each register individually and sum the results to find the total minimum overhead.\n\nFor any register $r$, we must compare the cost of designating it as callee-saved versus caller-saved. The cost for a save-restore pair is $2\\sigma = 2 \\times 5 = 10$ cycles.\n\n**Cost of Callee-Saved Convention**\nIf a register $r$ is designated callee-saved, the callee function must save it upon entry and restore it upon exit if the function itself uses the register. The problem states that a function $F$ \"uses\" a register $r$ if $r$ is in its live set $L_F$.\nThe total cost for a callee-saved register $r$ is the sum of costs for each function that uses it.\n- If function $A$ uses $r$ (i.e., $r \\in L_A$), the cost incurred is $N_A \\times 2\\sigma$, as $A$ is entered $N_A$ times.\n- If function $B$ uses $r$ (i.e., $r \\in L_B$), the cost incurred is $N_B \\times 2\\sigma$, as $B$ is entered $N_B$ times.\n\nThe total cost for a callee-saved register $r$ is:\n$$Cost_{callee}(r) = 2\\sigma \\times (\\mathbb{I}(r \\in L_A) \\cdot N_A + \\mathbb{I}(r \\in L_B) \\cdot N_B)$$\nwhere $\\mathbb{I}(\\cdot)$ is the indicator function, which is $1$ if the condition is true and $0$ otherwise.\n\n**Cost of Caller-Saved Convention**\nIf a register $r$ is designated caller-saved, the caller function must save it before a call and restore it after the call, if the register's value is live in the caller.\n- Function $A$ makes $C_{AB}$ calls to $B$. If $r$ is live in $A$ (i.e., $r \\in L_A$), a save/restore is needed for each of these calls. The cost is $C_{AB} \\times 2\\sigma$.\n- Function $B$ makes $C_{BA}$ calls to $A$. If $r$ is live in $B$ (i.e., $r \\in L_B$), a save/restore is needed for each of these calls. The cost is $C_{BA} \\times 2\\sigma$.\n\nThe total cost for a caller-saved register $r$ is:\n$$Cost_{caller}(r) = 2\\sigma \\times (\\mathbb{I}(r \\in L_A) \\cdot C_{AB} + \\mathbb{I}(r \\in L_B) \\cdot C_{BA})$$\n\nNow, we calculate the minimum cost for each register in $U$.\n\n**For register $r_1$:**\n$r_1 \\in L_A$ and $r_1 \\notin L_B$.\n- $Cost_{callee}(r_1) = 2\\sigma \\times (1 \\cdot N_A + 0 \\cdot N_B) = 10 \\times 310 = 3100$ cycles.\n- $Cost_{caller}(r_1) = 2\\sigma \\times (1 \\cdot C_{AB} + 0 \\cdot C_{BA}) = 10 \\times 300 = 3000$ cycles.\nThe minimum cost for $r_1$ is $\\min(3100, 3000) = 3000$ cycles. This is achieved by making $r_1$ caller-saved.\n\n**For register $r_2$:**\n$r_2 \\in L_A$ and $r_2 \\in L_B$.\n- $Cost_{callee}(r_2) = 2\\sigma \\times (1 \\cdot N_A + 1 \\cdot N_B) = 10 \\times (310 + 300) = 10 \\times 610 = 6100$ cycles.\n- $Cost_{caller}(r_2) = 2\\sigma \\times (1 \\cdot C_{AB} + 1 \\cdot C_{BA}) = 10 \\times (300 + 300) = 10 \\times 600 = 6000$ cycles.\nThe minimum cost for $r_2$ is $\\min(6100, 6000) = 6000$ cycles. This is achieved by making $r_2$ caller-saved.\n\n**For register $r_3$:**\n$r_3 \\notin L_A$ and $r_3 \\in L_B$.\n- $Cost_{callee}(r_3) = 2\\sigma \\times (0 \\cdot N_A + 1 \\cdot N_B) = 10 \\times 300 = 3000$ cycles.\n- $Cost_{caller}(r_3) = 2\\sigma \\times (0 \\cdot C_{AB} + 1 \\cdot C_{BA}) = 10 \\times 300 = 3000$ cycles.\nThe minimum cost for $r_3$ is $\\min(3000, 3000) = 3000$ cycles. The cost is the same for either convention.\n\n**For register $r_5$:**\n$r_5 \\in L_A$ and $r_5 \\in L_B$. This case is identical to $r_2$.\n- $Cost_{callee}(r_5) = 10 \\times (310 + 300) = 6100$ cycles.\n- $Cost_{caller}(r_5) = 10 \\times (300 + 300) = 6000$ cycles.\nThe minimum cost for $r_5$ is $\\min(6100, 6000) = 6000$ cycles. This is achieved by making $r_5$ caller-saved.\n\n**Total Minimal Overhead**\nThe total minimal overhead is the sum of the minimum costs for each register in $U$. Registers outside of $U$ (i.e., $r_4$ and $r_6$) are not live across any calls in $A$ or $B$, so they incur no save/restore overhead.\n$$Cost_{total} = \\min Cost(r_1) + \\min Cost(r_2) + \\min Cost(r_3) + \\min Cost(r_5)$$\n$$Cost_{total} = 3000 + 6000 + 3000 + 6000 = 18000$$\n\nThe minimal possible total dynamic save/restore overhead across the entire run is $18000$ cycles.", "answer": "$$\\boxed{18000}$$", "id": "3626228"}, {"introduction": "Beyond simple cost analysis, the principles of calling conventions directly influence the design of register allocators. This practice [@problem_id:3626224] moves from theory to implementation by asking you to formalize a heuristic that intelligently assigns values to either caller-saved or callee-saved registers. By considering factors like call density and liveness, you will build a simplified allocator that actively works to minimize spill costs, providing a window into how compilers make these critical performance decisions.", "problem": "You are to formalize and implement a simplified, principled register allocation heuristic that is aware of the distinction between caller-saved and callee-saved registers and leverages a call density map. The goal is to minimize a spill metric normalized per basic block. The core foundation you must start from consists of the following accepted definitions and facts from compiler principles:\n\n1. A calling convention partitions the architectural registers into two sets: caller-saved registers and callee-saved registers. A call instruction may clobber the caller-saved registers, while callee-saved registers are preserved across calls by the callee. Formally, if a call occurs inside basic block $b$, then any value resident in a caller-saved register at the call site must be preserved by explicit save and restore if the value is live across the call site.\n\n2. Liveness is defined over basic blocks. A value $v$ is live in basic block $b$ if there exists some path from $b$ to a use of $v$ that does not redefine $v$. We model liveness as a boolean matrix $L[v,b] \\in \\{0,1\\}$, where $L[v,b] = 1$ indicates that $v$ is live in $b$.\n\n3. A call density map specifies, for each basic block $b$, the number of call sites $C_b \\in \\mathbb{Z}_{\\ge 0}$ contained in that block.\n\n4. A value may have a hole at call sites inside a basic block. For a live value $v$ in block $b$, $H[v,b] = 1$ means that $v$ is not live at the exact program points corresponding to call sites inside $b$; $H[v,b] = 0$ means it remains live across call sites in $b$.\n\n5. A spill is a memory traffic event introduced by the allocator due to either register pressure or call clobbering. In this model:\n   - If, in a basic block $b$, the number of live values exceeds the number of available registers, any excess live value not assigned a register incurs a spill with unit cost $1$ for that block.\n   - If, in a basic block $b$ with $C_b  0$, a live value with $H[v,b] = 0$ is assigned to a caller-saved register, then protecting it across the $C_b$ call sites incurs an additional spill cost of $C_b$ for that value in that block.\n   - Assigning a live value to a callee-saved register incurs no per-call spill cost in this model. Inter-block move costs and callee-save prologue/epilogue costs are ignored for this problem to isolate the effect of call density.\n\nYour allocator must operate per basic block using only the following data for each test case:\n- The number of basic blocks $B$.\n- The number of caller-saved registers $R_{\\text{caller}}$ and callee-saved registers $R_{\\text{callee}}$.\n- The number of values $V$.\n- The call counts per block $C_b$ for $b \\in \\{0,\\dots,B-1\\}$.\n- The liveness matrix $L[v,b]$ for $v \\in \\{0,\\dots,V-1\\}$ and $b \\in \\{0,\\dots,B-1\\}$.\n- The hole matrix $H[v,b]$ for $v \\in \\{0,\\dots,V-1\\}$ and $b \\in \\{0,\\dots,B-1\\}$.\n\nThe allocator you implement must follow this principled policy derived from the above facts:\n- Within each basic block $b$, classify the live values into the set $P_b = \\{ v \\mid L[v,b] = 1 \\land (H[v,b] = 1 \\lor C_b = 0)\\}$ for which assigning to a caller-saved register incurs no per-call spill cost, and its complement $N_b = \\{ v \\mid L[v,b] = 1 \\land H[v,b] = 0 \\land C_b  0\\}$.\n- Assign up to $R_{\\text{caller}}$ values from $P_b$ to caller-saved registers.\n- Assign up to $R_{\\text{callee}}$ remaining live values (not already assigned) to callee-saved registers.\n- Do not assign values from $N_b$ to caller-saved registers, because doing so would incur an additional per-call spill cost of $C_b$ each; instead, leave them either in callee-saved registers if available or spilled.\n\nUnder these rules, the total spill cost in block $b$ is the sum of:\n- Pressure spills: the count of live values left unassigned to any register in $b$.\n- Call clobber spills: the count of assigned caller-saved values from $N_b$ times $C_b$. By construction of the policy above, this latter term is $0$.\n\nThe objective is to compute the scalar metric\n$$\n\\text{spills\\_per\\_BB} \\;=\\; \\frac{1}{B}\\sum_{b=0}^{B-1} \\text{spills}(b),\n$$\nwhere $\\text{spills}(b)$ is the total spill cost in block $b$ under the allocation described.\n\nImplement a complete, runnable program in the C programming language that, without reading any input, evaluates the above policy on the following test suite and prints the resulting $\\text{spills\\_per\\_BB}$ for each case on a single line as a comma-separated list in square brackets.\n\nTest Suite:\n- Case $1$ (general mixed scenario):\n  - $B = 3$, $R_{\\text{caller}} = 2$, $R_{\\text{callee}} = 1$, $V = 4$.\n  - Calls per block: $C = [2, 0, 1]$.\n  - Liveness $L$ by value across blocks:\n    - $v_0$: $[1, 1, 1]$, holes $H$: $[1, 0, 0]$.\n    - $v_1$: $[1, 1, 0]$, holes $H$: $[0, 0, -]$ (ignore entries where $L=0$).\n    - $v_2$: $[1, 0, 1]$, holes $H$: $[1, -, 1]$.\n    - $v_3$: $[0, 1, 1]$, holes $H$: $[-, 0, 0]$.\n- Case $2$ (no calls anywhere):\n  - $B = 2$, $R_{\\text{caller}} = 1$, $R_{\\text{callee}} = 1$, $V = 3$.\n  - $C = [0, 0]$.\n  - $v_0$: $L=[1, 1]$, $H=[0, 0]$.\n  - $v_1$: $L=[1, 0]$, $H=[0, -]$.\n  - $v_2$: $L=[0, 1]$, $H=[-, 0]$.\n- Case $3$ (high call density, zero holes, only caller-saved available):\n  - $B = 1$, $R_{\\text{caller}} = 3$, $R_{\\text{callee}} = 0$, $V = 3$.\n  - $C = [3]$.\n  - $v_0$: $L=[1]$, $H=[0]$.\n  - $v_1$: $L=[1]$, $H=[0]$.\n  - $v_2$: $L=[1]$, $H=[0]$.\n- Case $4$ (more caller-saved registers than needed, all values have holes at call sites):\n  - $B = 2$, $R_{\\text{caller}} = 4$, $R_{\\text{callee}} = 0$, $V = 3$.\n  - $C = [1, 2]$.\n  - $v_0$: $L=[1, 1]$, $H=[1, 1]$.\n  - $v_1$: $L=[1, 1]$, $H=[1, 1]$.\n  - $v_2$: $L=[1, 1]$, $H=[1, 1]$.\n- Case $5$ (one call, limited callee-saved, surplus caller-saved, no holes):\n  - $B = 1$, $R_{\\text{caller}} = 5$, $R_{\\text{callee}} = 1$, $V = 2$.\n  - $C = [1]$.\n  - $v_0$: $L=[1]$, $H=[0]$.\n  - $v_1$: $L=[1]$, $H=[0]$.\n\nYour program should produce a single line of output containing the five results as a comma-separated list enclosed in square brackets, with each value rounded to exactly three digits after the decimal point (for instance, $[0.333,0.000,3.000,0.000,1.000]$).", "solution": "The problem presented is a valid, well-posed exercise in compiler theory, specifically concerning register allocation heuristics. It is scientifically grounded in established principles of calling conventions and liveness analysis, is internally consistent, and provides all necessary data to arrive at a unique, verifiable solution.\n\nThe task is to implement a specific register allocation policy for a set of basic blocks and calculate the resulting average spill metric. The policy distinguishes between caller-saved and callee-saved registers and prioritizes register assignments based on whether a live value spans a call instruction within a basic block.\n\nThe core of the problem is to implement the given allocation policy for each basic block $b$. The policy is defined as follows:\n1.  Partition the set of live values in block $b$ into two disjoint sets:\n    -   $P_b = \\{ v \\mid L[v,b] = 1 \\land (H[v,b] = 1 \\lor C_b = 0) \\}$: These are values that are \"preferred\" for caller-saved registers because they are either not live across calls ($H[v,b]=1$) or exist in a block with no calls ($C_b=0$).\n    -   $N_b = \\{ v \\mid L[v,b] = 1 \\land H[v,b] = 0 \\land C_b  0) \\}$: These are values that are \"not preferred\" for caller-saved registers because they are live across one or more calls ($C_b  0$) and do not have a hole at the call sites ($H[v,b]=0$). Assigning such a value to a caller-saved register would require saving and restoring it, incurring a spill cost of $C_b$. The policy forbids this assignment.\n\n2.  Perform register assignment in two stages:\n    -   First, assign values from the set $P_b$ to the available $R_{\\text{caller}}$ caller-saved registers. As many values from $P_b$ as possible, up to $R_{\\text{caller}}$, are assigned.\n    -   Second, any remaining live values (those from $P_b$ not assigned a caller-saved register, plus all values from $N_b$) are candidates for the $R_{\\text{callee}}$ callee-saved registers. As many of these remaining values as possible, up to $R_{\\text{callee}}$, are assigned.\n\n3.  Calculate the spill cost for block $b$, denoted $\\text{spills}(b)$. According to the policy, no call clobber spills occur. The only source of spills is register pressure: any live value that is not assigned to either a caller-saved or a callee-saved register is considered spilled, contributing a cost of $1$. Thus, $\\text{spills}(b)$ is simply the count of unassigned live values.\n\nThe final metric is the average spill cost per basic block:\n$$\n\\text{spills\\_per\\_BB} \\;=\\; \\frac{1}{B}\\sum_{b=0}^{B-1} \\text{spills}(b)\n$$\n\nWe will now apply this procedure to each test case.\n\n**Case 1:** $B = 3$, $R_{\\text{caller}} = 2$, $R_{\\text{callee}} = 1$, $V = 4$. $C = [2, 0, 1]$.\n-   **Block $b=0$**: $C_0 = 2$. Live values are $v_0, v_1, v_2$.\n    -   $v_0: H[0,0]=1 \\implies v_0 \\in P_0$.\n    -   $v_1: H[1,0]=0 \\implies v_1 \\in N_0$.\n    -   $v_2: H[2,0]=1 \\implies v_2 \\in P_0$.\n    -   Sets are $P_0 = \\{v_0, v_2\\}$ (size $|P_0|=2$) and $N_0 = \\{v_1\\}$ (size $|N_0|=1$). Total live: $3$.\n    -   Allocation: Assign $|P_0|=2$ values to the $R_{\\text{caller}}=2$ registers. $v_0, v_2$ are assigned. Remaining live values: $\\{v_1\\}$. Assign this value to the $R_{\\text{callee}}=1$ register.\n    -   All $3$ live values are assigned. $\\text{spills}(0) = 0$.\n-   **Block $b=1$**: $C_1 = 0$. Live values are $v_0, v_1, v_3$.\n    -   Since $C_1=0$, all live values are in $P_1$. $|P_1|=3$, $|N_1|=0$. Total live: $3$.\n    -   Allocation: Assign $\\min(3, R_{\\text{caller}}) = \\min(3,2) = 2$ values from $P_1$ to caller-saved registers. One value from $P_1$ remains. Assign this remaining value to the $R_{\\text{callee}}=1$ register.\n    -   All $3$ live values are assigned. $\\text{spills}(1) = 0$.\n-   **Block $b=2$**: $C_2 = 1$. Live values are $v_0, v_2, v_3$.\n    -   $v_0: H[0,2]=0 \\implies v_0 \\in N_2$.\n    -   $v_2: H[2,2]=1 \\implies v_2 \\in P_2$.\n    -   $v_3: H[3,2]=0 \\implies v_3 \\in N_2$.\n    -   Sets are $P_2 = \\{v_2\\}$ ($|P_2|=1$) and $N_2 = \\{v_0, v_3\\}$ ($|N_2|=2$). Total live: $3$.\n    -   Allocation: Assign $|P_2|=1$ value ($v_2$) to a caller-saved register ($R_{\\text{caller}}=2$ available). Remaining live values are $\\{v_0, v_3\\}$. Assign $\\min(2, R_{\\text{callee}}) = \\min(2,1)=1$ of these to the callee-saved register. One value is left unassigned.\n    -   One value is spilled. $\\text{spills}(2) = 1$.\n-   **Metric**: $\\text{spills\\_per\\_BB} = \\frac{1}{3} (\\text{spills}(0) + \\text{spills}(1) + \\text{spills}(2)) = \\frac{1}{3}(0 + 0 + 1) \\approx 0.333$.\n\n**Case 2:** $B = 2$, $R_{\\text{caller}} = 1$, $R_{\\text{callee}} = 1$, $V = 3$. $C = [0, 0]$.\n-   Since $C_b = 0$ for all blocks, all live values fall into the set $P_b$.\n-   **Block $b=0$**: $C_0=0$. Live values are $v_0, v_1$. Total live: $2$.\n    -   Allocation: $R_{\\text{caller}} = 1$, $R_{\\text{callee}} = 1$. Total registers: $2$. All $2$ live values are assigned.\n    -   $\\text{spills}(0) = 0$.\n-   **Block $b=1$**: $C_1=0$. Live values are $v_0, v_2$. Total live: $2$.\n    -   Allocation: $R_{\\text{caller}} = 1$, $R_{\\text{callee}} = 1$. Total registers: $2$. All $2$ live values are assigned.\n    -   $\\text{spills}(1) = 0$.\n-   **Metric**: $\\text{spills\\_per\\_BB} = \\frac{1}{2}(0 + 0) = 0.000$.\n\n**Case 3:** $B = 1$, $R_{\\text{caller}} = 3$, $R_{\\text{callee}} = 0$, $V = 3$. $C = [3]$.\n-   **Block $b=0$**: $C_0 = 3$. Live values are $v_0, v_1, v_2$. For all of them, $H[v,0]=0$.\n    -   All $3$ live values fall into $N_0$. $|P_0|=0, |N_0|=3$.\n    -   Allocation: No values in $P_0$ are assigned to caller-saved registers. The remaining live values are all $3$ values from $N_0$. We have $R_{\\text{callee}}=0$ registers. None can be assigned.\n    -   All $3$ live values are unassigned. $\\text{spills}(0) = 3$.\n-   **Metric**: $\\text{spills\\_per\\_BB} = \\frac{1}{1}(3) = 3.000$.\n\n**Case 4:** $B = 2$, $R_{\\text{caller}} = 4$, $R_{\\text{callee}} = 0$, $V = 3$. $C = [1, 2]$.\n-   For all live values in all blocks, $H[v,b]=1$. This means all live values always fall into set $P_b$.\n-   **Block $b=0$**: $C_0=1$. Live values are $v_0, v_1, v_2$. All are in $P_0$. Total live: $3$.\n    -   Allocation: We have $R_{\\text{caller}}=4$ registers. All $3$ live values are assigned to caller-saved registers.\n    -   $\\text{spills}(0) = 0$.\n-   **Block $b=1$**: $C_1=2$. Live values are $v_0, v_1, v_2$. All are in $P_1$. Total live: $3$.\n    -   Allocation: We have $R_{\\text{caller}}=4$ registers. All $3$ live values are assigned.\n    -   $\\text{spills}(1) = 0$.\n-   **Metric**: $\\text{spills\\_per\\_BB} = \\frac{1}{2}(0+0) = 0.000$.\n\n**Case 5:** $B = 1$, $R_{\\text{caller}} = 5$, $R_{\\text{callee}} = 1$, $V = 2$. $C = [1]$.\n-   **Block $b=0$**: $C_0=1$. Live values are $v_0, v_1$. For both, $H[v,0]=0$.\n    -   Both live values fall into $N_0$. $|P_0|=0, |N_0|=2$.\n    -   Allocation: No values in $P_0$ are assigned to caller-saved registers. The remaining live values are $\\{v_0, v_1\\}$. We have $R_{\\text{callee}}=1$. Assign one value to the callee-saved register.\n    -   One value is left unassigned. $\\text{spills}(0) = 1$.\n-   **Metric**: $\\text{spills\\_per\\_BB} = \\frac{1}{1}(1) = 1.000$.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    const char* name;\n    int B;\n    int R_caller;\n    int R_callee;\n    int V;\n    const int *C;\n    const int **L;\n    const int **H;\n} TestCase;\n\n// Function to calculate the spill metric for a single test case.\ndouble calculate_spills_per_bb(const TestCase* tc) {\n    double total_spills = 0.0;\n\n    // Iterate over each basic block\n    for (int b = 0; b  tc-B; ++b) {\n        int p_b_count = 0;\n        int n_b_count = 0;\n\n        // Partition live values into sets P_b and N_b\n        for (int v = 0; v  tc-V; ++v) {\n            if (tc-L[v][b] == 1) {\n                // A value v is in P_b if it's live and has a hole, or if there are no calls in the block.\n                if (tc-C[b] == 0 || tc-H[v][b] == 1) {\n                    p_b_count++;\n                } else { // Otherwise, it's live across a call and is in N_b.\n                    n_b_count++;\n                }\n            }\n        }\n        \n        int live_count = p_b_count + n_b_count;\n        int assigned_to_caller = 0;\n        int assigned_to_callee = 0;\n        int spills_in_block = 0;\n\n        // Step 1: Assign values from P_b to caller-saved registers\n        if (p_b_count  tc-R_caller) {\n            assigned_to_caller = p_b_count;\n        } else {\n            assigned_to_caller = tc-R_caller;\n        }\n        \n        // Step 2: Assign remaining live values to callee-saved registers\n        int remaining_live_values = live_count - assigned_to_caller;\n        if (remaining_live_values  tc-R_callee) {\n            assigned_to_callee = remaining_live_values;\n        } else {\n            assigned_to_callee = tc-R_callee;\n        }\n\n        // Calculate pressure spills\n        int total_assigned = assigned_to_caller + assigned_to_callee;\n        spills_in_block = live_count - total_assigned;\n        \n        total_spills += spills_in_block;\n    }\n\n    if (tc-B == 0) {\n        return 0.0;\n    }\n    \n    return total_spills / (double)tc-B;\n}\n\nint main(void) {\n    // --- Test Case 1 Data ---\n    const int C1[] = {2, 0, 1};\n    const int L1_data[] = {1,1,1, 1,1,0, 1,0,1, 0,1,1};\n    const int *L1_rows[] = {L1_data, L1_data+3, L1_data+6, L1_data+9};\n    const int H1_data[] = {1,0,0, 0,0,0, 1,0,1, 0,0,0}; // '-' entries are 0, doesn't matter as L is 0 there.\n    const int *H1_rows[] = {H1_data, H1_data+3, H1_data+6, H1_data+9};\n\n    // --- Test Case 2 Data ---\n    const int C2[] = {0, 0};\n    const int L2_data[] = {1,1, 1,0, 0,1};\n    const int *L2_rows[] = {L2_data, L2_data+2, L2_data+4};\n    const int H2_data[] = {0,0, 0,0, 0,0};\n    const int *H2_rows[] = {H2_data, H2_data+2, H2_data+4};\n\n    // --- Test Case 3 Data ---\n    const int C3[] = {3};\n    const int L3_data[] = {1, 1, 1};\n    const int *L3_rows[] = {L3_data, L3_data+1, L3_data+2};\n    const int H3_data[] = {0, 0, 0};\n    const int *H3_rows[] = {H3_data, H3_data+1, H3_data+2};\n\n    // --- Test Case 4 Data ---\n    const int C4[] = {1, 2};\n    const int L4_data[] = {1,1, 1,1, 1,1};\n    const int *L4_rows[] = {L4_data, L4_data+2, L4_data+4};\n    const int H4_data[] = {1,1, 1,1, 1,1};\n    const int *H4_rows[] = {H4_data, H4_data+2, H4_data+4};\n\n    // --- Test Case 5 Data ---\n    const int C5[] = {1};\n    const int L5_data[] = {1, 1};\n    const int *L5_rows[] = {L5_data, L5_data+1};\n    const int H5_data[] = {0, 0};\n    const int *H5_rows[] = {H5_data, H5_data+1};\n\n    // Define the test suite\n    TestCase test_cases[] = {\n        {\"Case 1\", 3, 2, 1, 4, C1, L1_rows, H1_rows},\n        {\"Case 2\", 2, 1, 1, 3, C2, L2_rows, H2_rows},\n        {\"Case 3\", 1, 3, 0, 3, C3, L3_rows, H3_rows},\n        {\"Case 4\", 2, 4, 0, 3, C4, L4_rows, H4_rows},\n        {\"Case 5\", 1, 5, 1, 2, C5, L5_rows, H5_rows}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    double results[num_cases];\n\n    for (int i = 0; i  num_cases; ++i) {\n        results[i] = calculate_spills_per_bb(test_cases[i]);\n    }\n\n    printf(\"[%.3f,%.3f,%.3f,%.3f,%.3f]\", results[0], results[1], results[2], results[3], results[4]);\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3626224"}, {"introduction": "A defined Application Binary Interface (ABI) is a contract, but how can we verify that a compiler's generated code actually adheres to it? This final exercise [@problem_id:3626201] tackles the practical challenge of testing, a crucial aspect of systems programming and compiler development. You will evaluate different strategies for building a test harness to detect violations of the callee-saved register rule, learning to account for confounding factors like compiler optimizations that can hide bugs or invalidate tests.", "problem": "You are evaluating whether a compilerâ€™s code generator correctly implements the Application Binary Interface (ABI) with respect to callee-saved and caller-saved register conventions. Let the machine have a finite set of general-purpose registers denoted by $R$, partitioned into a callee-saved subset $R_c$ and a caller-saved subset $R_{k}$, such that $R = R_c \\cup R_{k}$ and $R_c \\cap R_{k} = \\varnothing$. By definition of the ABI and calling convention, for any function $f$, if $f$ is called in a context that obeys the ABI, then upon normal return, the contents of all registers in $R_c$ must be exactly those present at call entry; the caller is responsible for preserving any needed values in $R_{k}$. Assume single-threaded execution and that you can emit inline assembly and raw assembly as needed, but the optimizing compiler may reorder instructions unless prevented by a proper barrier. You want to build an automated test harness that generates randomized functions $\\{f_i\\}_{i=1}^{N}$ that claim to follow the convention, and then verifies compliance by placing canary values into $R_c$ at call entry, letting $f_i$ execute, and checking that the canaries remain unchanged at return.\n\nWhich of the following testing plans most reliably detects violations of the callee-saved convention in $R_c$ without introducing avoidable false positives or false negatives? Select all that apply.\n\nA. Build a small assembly harness that, just before calling a function under test $f_i$, performs the following steps: it loads distinct canary values into each register in $R_c$ using explicit register-targeted moves; it saves all caller-saved registers in $R_{k}$ to a private aligned stack scratch area; it issues a compiler barrier that clobbers memory and all of $R$ as seen by the high-level compiler to prevent reordering across the call site; it calls $f_i$ indirectly via a function pointer located in a separately compiled translation unit with inlining disabled; upon return, it first restores $R_{k}$ from the scratch area, then compares the current contents of all registers in $R_c$ against the original canaries. The generator produces $f_i$ that may have nested calls and arbitrary register pressure but must return normally. Any mismatch in $R_c$ is reported as a violation.\n\nB. Write a high-level language harness that stores canary constants in volatile local variables and relies on the optimizing compiler to allocate those variables into $R_c$. It then calls $f_i$ directly and, after return, compares the volatile variables to the constants. If they match, $f_i$ is deemed compliant; otherwise, noncompliant. No special compiler barriers or anti-inlining measures are used.\n\nC. Instrument each generated function $f_i$ by injecting, at its entry, stores of all registers in $R_c$ to its stack frame and, at each return, loads of the same $R_c$ locations back into the registers, then report success if the injected loads match the injected stores. Do not place canaries in the caller or check $R_c$ at the call boundary.\n\nD. Use an assembly harness that writes canaries into $R_c$, calls $f_i$, and checks $R_c$ on return. To increase coverage, enable random asynchronous signal delivery whose handlers execute arbitrary code that may touch general-purpose registers during the call. Any mismatch in $R_c$ is attributed to $f_i$ and reported as a violation.\n\nE. Use an assembly harness to place canaries into $R_c$ and immediately call $f_i$ compiled with aggressive optimizations and inlining enabled. Do not prevent inlining or tail-call optimization, and do not save $R_{k}$. After the call, check $R_c$ for equality with the canaries; if unequal, report a violation.\n\nAssume that stack alignment, shadow space, and any mandated red zones are honored by the harness in all options that use assembly. You may also assume that the canary values are drawn from a distribution over the $w$-bit word space, where $w$ is the machine word size, and that the harness records the exact canaries it wrote for later comparison. Choose the option or options that are methodologically sound under the ABI definition stated above.", "solution": "The problem requires the design of a reliable test harness to verify a compiler's adherence to the callee-saved register convention as defined by an Application Binary Interface (ABI). A reliable test must accurately detect violations (true positives) while avoiding false alarms (false positives) and missed violations (false negatives). The core principle to be tested is that for any function $f$, the values in the set of callee-saved registers, $R_c$, must be identical upon the function's return to their values at the moment of the call.\n\nLet us analyze each proposed testing plan.\n\n**A. Build a small assembly harness that, just before calling a function under test $f_i$, performs the following steps: it loads distinct canary values into each register in $R_c$ using explicit register-targeted moves; it saves all caller-saved registers in $R_{k}$ to a private aligned stack scratch area; it issues a compiler barrier that clobbers memory and all of $R$ as seen by the high-level compiler to prevent reordering across the call site; it calls $f_i$ indirectly via a function pointer located in a separately compiled translation unit with inlining disabled; upon return, it first restores $R_{k}$ from the scratch area, then compares the current contents of all registers in $R_c$ against the original canaries. The generator produces $f_i$ that may have nested calls and arbitrary register pressure but must return normally. Any mismatch in $R_c$ is reported as a violation.**\n\nThis option describes a methodologically sound and robust testing strategy.\n1.  **Assembly Harness:** Using an assembly harness provides direct, low-level control over the CPU state, which is essential for placing canaries into specific registers ($R_c$) and checking them. This bypasses the ambiguity of high-level language-to-register mapping.\n2.  **Saving $R_k$:** The harness, as a caller, may use registers in $R_k$ for its own operations (e.g., loop counters, pointers for the check phase). According to the ABI, the caller is responsible for saving these if their values are needed across a call. Doing so makes the harness itself robust and ABI-compliant, preventing its own logic from failing due to the (expected) clobbering of $R_k$ by $f_i$.\n3.  **Compiler Barrier:** The `clobber` barrier is critical. It informs the compiler that its knowledge of register and memory state is invalidated by the `call` to $f_i$. This prevents the optimizing compiler, which might be compiling the harness code, from reordering the canary setup, the function call, and the canary check. Without this, the optimizer could move the check before the call or the setup after the call, rendering the test meaningless and leading to false negatives.\n4.  **Indirect Call  No Inlining:** Calling $f_i$ indirectly through a function pointer and ensuring it is in a separately compiled unit with inlining disabled is crucial. This forces the generation of a true `call` instruction and treats $f_i$ as a black box that must communicate solely via the ABI. If $f_i$ were inlined, the compiler could perform inter-procedural optimizations, potentially \"optimizing away\" the very violation we seek to detect, leading to a false negative.\n5.  **Conclusion on A:** This plan correctly isolates the unit under test ($f_i$) and ensures the integrity of the test's setup and verification steps against compiler optimizations. It directly tests the ABI contract at the machine level. Therefore, it is a reliable method for detecting violations with a low probability of false positives or false negatives.\n\n**Verdict: Correct**\n\n**B. Write a high-level language harness that stores canary constants in volatile local variables and relies on the optimizing compiler to allocate those variables into $R_c$. It then calls $f_i$ directly and, after return, compares the volatile variables to the constants. If they match, $f_i$ is deemed compliant; otherwise, noncompliant. No special compiler barriers or anti-inlining measures are used.**\n\nThis approach is fundamentally flawed and unreliable.\n1.  **Register Allocation:** There is no standard mechanism in languages like C or C++ to force a local variable into a specific register, let alone a register from the callee-saved set $R_c$. The compiler is free to store the variable on the stack or in any register of its choosing (from $R_c$ or $R_k$). The `volatile` keyword prevents the optimizer from eliding reads/writes to the variable's memory location but does not influence register allocation. Thus, the test may not even place canaries in $R_c$, leading to massive false negatives.\n2.  **Direct Call and Inlining:** Calling $f_i$ directly with no measures to prevent inlining allows the compiler to perform optimizations across the function call boundary. As explained for option A, this can obscure or eliminate the violation, causing a false negative.\n3.  **No Barriers:** The absence of compiler barriers allows the optimizer to reorder the test logic, invalidating the test's premises.\n\n**Verdict: Incorrect**\n\n**C. Instrument each generated function $f_i$ by injecting, at its entry, stores of all registers in $R_c$ to its stack frame and, at each return, loads of the same $R_c$ locations back into the registers, then report success if the injected loads match the injected stores. Do not place canaries in the caller or check $R_c$ at the call boundary.**\n\nThis plan tests the wrong thing.\n1.  **Altering the Subject:** The described instrumentation modifies the function under test, $f_i$, into a new function, $f_i'$. The injected code (a standard function prologue/epilogue for saving/restoring $R_c$) effectively *corrects* any callee-saved violation that the original $f_i$ might have had.\n2.  **Guaranteed Success:** The instrumented function $f_i'$ will, by construction, always preserve the registers in $R_c$ from the perspective of its caller. The internal check (matching injected loads and stores) merely verifies that the instrumentation itself works, not whether the original code of $f_i$ was compliant. This will result in a $100\\%$ rate of false negatives for any non-compliant function.\n\n**Verdict: Incorrect**\n\n**D. Use an assembly harness that writes canaries into $R_c$, calls $f_i$, and checks $R_c$ on return. To increase coverage, enable random asynchronous signal delivery whose handlers execute arbitrary code that may touch general-purpose registers during the call. Any mismatch in $R_c$ is attributed to $f_i$ and reported as a violation.**\n\nThis approach introduces confounding variables, making it unreliable.\n1.  **Conflating Concerns:** The ABI for a function call is distinct from the ABI and system-level protocol for handling asynchronous signals or interrupts. When a signal is delivered, the operating system is responsible for saving the full context of the interrupted thread (including all registers in $R_c$ and $R_k$), running the signal handler, and then restoring that context.\n2.  **Source of False Positives:** If a canary value in a register from $R_c$ is corrupted, this plan attributes the fault to $f_i$. However, the corruption could be due to a bug in the OS's context-switch code for signal handling. The test is no longer isolating $f_i$; it is simultaneously testing the OS. This violates the principle of a specific unit test and is a direct cause of potential false positives.\n3.  **Context Violation:** The problem specifies analysis under the assumption of single-threaded execution. Asynchronous signals introduce a form of preemption and concurrent execution (the handler interrupting the main thread) that complicates the clean, single-threaded model the ABI is defined for.\n\n**Verdict: Incorrect**\n\n**E. Use an assembly harness to place canaries into $R_c$ and immediately call $f_i$ compiled with aggressive optimizations and inlining enabled. Do not prevent inlining or tail-call optimization, and do not save $R_{k}$. After the call, check $R_c$ for equality with the canaries; if unequal, report a violation.**\n\nThis plan contains multiple, severe methodological flaws.\n1.  **Inlining and TCO:** As with option B, allowing inlining and tail-call optimization (TCO) is fatal to the test's reliability. Inlining allows the compiler to reason about the combined code of the harness and $f_i$, potentially hiding violations (false negatives). TCO replaces a `call`/`ret` sequence with a `jmp`, which breaks the fundamental model of a function call that the ABI governs. A test of $f_i$ could become a test of a different function that $f_i$ tail-calls.\n2.  **Not Saving $R_k$:** The harness itself is a program. If its checking logic after the call to $f_i$ depends on values it held in caller-saved registers ($R_k$) before the call, failing to save them will lead to the harness's own failure. Function $f_i$ is explicitly permitted by the ABI to modify $R_k$. This makes the harness itself buggy and unreliable. Any failure could be due to the harness corrupting its own state, not a violation in $f_i$.\n\n**Verdict: Incorrect**\n\n**Summary:**\n\nOnly option A provides a complete and methodologically rigorous framework for testing callee-saved register conventions. It correctly uses low-level control, isolates the test subject, and protects the test's integrity from compiler optimizations, thus minimizing the risk of both false positives and false negatives.", "answer": "$$\\boxed{A}$$", "id": "3626201"}]}