{"hands_on_practices": [{"introduction": "A common challenge in parsing expression languages is that simple context-free grammars are often ambiguous. This first exercise tackles this fundamental problem head-on, showing how to use attributes to enforce mathematical conventions of operator precedence and associativity that are not captured by the grammar's syntax alone [@problem_id:3621665]. By annotating the parse tree with `prec` and `assoc` attributes, you will create a single, unambiguous interpretation of an expression and then use a `val` attribute to compute its final numerical result.", "problem": "Consider the ambiguous expression grammar $G$ with the single nonterminal $E$ and productions $E \\rightarrow E \\,\\text{^}\\, E \\mid E * E \\mid E + E \\mid \\text{num}$, where $\\text{num}$ denotes a positive integer literal. In the framework of an annotated parse tree and an attribute grammar, each interior node labeled by a binary operator token is to be annotated with two attributes: a numerical precedence attribute $prec$ and an associativity attribute $assoc$. The attributes should encode the conventional arithmetic intent that exponentiation binds more tightly than multiplication, which binds more tightly than addition, and that exponentiation associates to the right while multiplication and addition associate to the left. You are to use these attributes purely to disambiguate the parse by enforcing that higher-precedence operators dominate lower-precedence ones in the tree structure, and that ties at the same precedence level are broken according to associativity.\n\nLet the intended attribute values be $prec(\\text{^})=3$, $prec(*)=2$, $prec(+)=1$, and $assoc(\\text{^})=\\text{right}$, $assoc(*)=\\text{left}$, $assoc(+)=\\text{left}$. In addition, define a synthesized attribute $val$ at each $E$-node that gives the numerical value of the subexpression at that node according to the following semantic basis: if $E \\rightarrow \\text{num}$ then $val$ is the integer value of the literal; if $E \\rightarrow E_1 + E_2$ then $val = E_1.val + E_2.val$; if $E \\rightarrow E_1 * E_2$ then $val = E_1.val \\times E_2.val$; if $E \\rightarrow E_1 \\,\\text{^}\\, E_2$ then $val = E_1.val^{E_2.val}$.\n\nStarting from the foundational definitions of parse trees for context-free grammars and annotated parse trees for attribute grammars, determine the unique parenthesization enforced by the given $prec$ and $assoc$ attributes for the input string $s = 2 \\,\\text{^}\\, 3 \\,\\text{^}\\, 2 + 4 * 5 + 6$. Then, using the above semantic basis for $val$, compute the numerical value of the root nodeâ€™s $val$ for the disambiguated parse of $s$. Express the final value as an exact integer. No rounding is required.", "solution": "The problem is valid as it is a well-posed, scientifically grounded exercise in compiler theory. It provides a complete and consistent set of rules (an attribute grammar) to disambiguate an expression generated by an ambiguous context-free grammar and to compute its value. All necessary data are provided, and the task is to apply these formal rules to a specific input string.\n\nThe problem requires a two-step process: first, to determine the structure of the unique parse tree for the input string $s = 2 \\,\\text{^}\\, 3 \\,\\text{^}\\, 2 + 4 * 5 + 6$ using the provided precedence and associativity attributes; and second, to compute the synthesized attribute $val$ at the root of this tree using the given semantic rules.\n\nThe grammar is given by the productions $E \\rightarrow E \\,\\text{^}\\, E \\mid E * E \\mid E + E \\mid \\text{num}$.\nThe attributes for the operators are:\nPrecedence: $prec(\\text{^})=3$ (highest), $prec(*)=2$, $prec(+)=1$ (lowest).\nAssociativity: $assoc(\\text{^})=\\text{right}$, $assoc(*)=\\text{left}$, $assoc(+)=\\text{left}$.\n\n**Step 1: Determining the Unique Parse Tree Structure (Parenthesization)**\n\nThe structure of the parse tree is dictated by operator precedence and associativity. An operator with higher precedence is applied before an operator with lower precedence, which means it will appear at a lower level in the parse tree. For operators of equal precedence, associativity determines the grouping: left-associativity implies grouping from left to right (e.g., $a+b+c$ is $(a+b)+c$), and right-associativity implies grouping from right to left (e.g., $a\\,\\text{^}\\,b\\,\\text{^}\\,c$ is $a\\,\\text{^}\\,(b\\,\\text{^}\\,c)$).\n\nLet us analyze the input string $s = 2 \\,\\text{^}\\, 3 \\,\\text{^}\\, 2 + 4 * 5 + 6$.\nThe operators present are $\\text{^}$, $\\text{^}$, $+$, $*$, $+$.\n\n1.  **Highest Precedence:** The exponentiation operator, $\\text{^}$, has the highest precedence ($prec=3$). The operators in the string involving exponentiation form the substring $2 \\,\\text{^}\\, 3 \\,\\text{^}\\, 2$. Since there are two such operators of equal precedence, we use associativity. The attribute is $assoc(\\text{^})=\\text{right}$, which means this expression is grouped from right to left. Therefore, its structure is $2 \\,\\text{^}\\, (3 \\,\\text{^}\\, 2)$. This subexpression must be evaluated before any surrounding additions or multiplications. In the parse tree, the first $\\text{^}$ will be a parent to the node representing $3\\,\\text{^}\\,2$.\n\n2.  **Next Precedence:** The multiplication operator, $*$, has the next highest precedence ($prec=2$). The substring involving multiplication is $4 * 5$. Since there is only one such operator, its grouping is simply $(4 * 5)$. This must be evaluated after any exponentiations but before any additions.\n\n3.  **Lowest Precedence:** The addition operator, $+$, has the lowest precedence ($prec=1$). The original string contains two addition operators. With the higher-precedence operations now grouped, the expression string can be seen as having the structure $(2 \\,\\text{^}\\, (3 \\,\\text{^}\\, 2)) + (4 * 5) + 6$. The two addition operators have equal precedence, so we use their associativity, which is $assoc(+)=\\text{left}$. This implies grouping from left to right. Therefore, the expression is grouped as $((2 \\,\\text{^}\\, (3 \\,\\text{^}\\, 2)) + (4 * 5)) + 6$.\n\nThe final, fully parenthesized expression, which uniquely specifies the structure of the disambiguated parse tree, is:\n$$((2 \\,\\text{^}\\, (3 \\,\\text{^}\\, 2)) + (4 * 5)) + 6$$\nThe root of the parse tree for this expression corresponds to the last operation performed, which is the second addition.\n\n**Step 2: Computing the Synthesized Attribute `val`**\n\nWe now compute the numerical value by evaluating the expression according to the parenthesization derived above and the semantic rules for the `val` attribute. This process is equivalent to a post-order traversal of the annotated parse tree, where the `val` attribute of a parent node is computed from the `val` attributes of its children.\n\n1.  Evaluate the innermost parenthesized expression, $(3 \\,\\text{^}\\, 2)$. The semantic rule is $E.val = (E_1.val)^{E_2.val}$.\n    $$3^2 = 9$$\n    The expression becomes $((2 \\,\\text{^}\\, 9) + (4 * 5)) + 6$.\n\n2.  Evaluate the next innermost expression, $(2 \\,\\text{^}\\, 9)$.\n    $$2^9 = 512$$\n    The expression becomes $((512) + (4 * 5)) + 6$.\n\n3.  Evaluate the other parenthesized expression at this level, $(4 * 5)$. The semantic rule is $E.val = E_1.val \\times E_2.val$.\n    $$4 \\times 5 = 20$$\n    The expression becomes $(512 + 20) + 6$.\n\n4.  Evaluate the sum inside the remaining parentheses, $(512 + 20)$. The semantic rule is $E.val = E_1.val + E_2.val$.\n    $$512 + 20 = 532$$\n    The expression becomes $532 + 6$.\n\n5.  Finally, perform the last addition.\n    $$532 + 6 = 538$$\n\nThis final result, $538$, is the value of the synthesized attribute $val$ at the root node of the disambiguated parse tree for the input string $s$.", "answer": "$$\\boxed{538}$$", "id": "3621665"}, {"introduction": "Annotated parse trees are not limited to just evaluating expressions; they are a powerful tool for sophisticated static analysis. This practice moves beyond simple computation to error detection, a critical function of modern compilers [@problem_id:3621702]. You will design an attribute grammar that uses interval analysis to approximate the possible range of values for subexpressions, allowing you to statically detect definite undefined behaviors like division by zero, thereby improving program safety before execution.", "problem": "Consider the context-free grammar with a single nonterminal $E$ and the productions $E \\to E \\;\\% \\; E \\mid \\text{num}$. You will design and use an attribute grammar to annotate a specific parse tree so as to (i) compute the synthesized integer value attribute $val$ at each $E$, and (ii) detect definite undefined behavior of the modulo operator when the right operand must be zero, using a boolean attribute $must\\_zero$ derived from interval analysis. All values are non-negative integers, and the modulo operator is the Euclidean remainder: for $a \\in \\mathbb{Z}_{\\ge 0}$ and $b \\in \\mathbb{Z}_{\\ge 1}$, $a \\bmod b \\in \\{0,1,\\dots,b-1\\}$.\n\nBase your construction only on the core definitions of attribute grammars and on sound interval analysis rules:\n- An attribute grammar assigns to each node synthesized attributes that are computed from its children and inherited attributes that are supplied by its parent; here, you will only use synthesized attributes.\n- Interval analysis abstracts the set of possible integer values of an expression by an interval $[l,h]$ with $0 \\le l \\le h$, and combines intervals with sound over-approximation rules.\n\nDefine, for every node labeled $E$, the following synthesized attributes:\n- $val(E)$: the integer value of the expression denoted by $E$ under the given concrete inputs.\n- $I(E) = [l(E),h(E)]$: an interval over-approximating all possible values $E$ may take under static information provided below.\n- $must\\_zero(E)$: a boolean that is true if and only if $I(E) = [0,0]$.\n\nDefine the attribute computation rules as follows:\n- For a leaf $E \\Rightarrow \\text{num}$ with concrete integer lexeme value $v$ and a statically known interval $[L,H]$ supplied by analysis, set $val(E) = v$, $I(E) = [L,H]$, and $must\\_zero(E)$ is true if and only if $L = 0$ and $H = 0$.\n- For an internal node $E \\Rightarrow E_1 \\;\\% \\; E_2$:\n  - If $must\\_zero(E_2)$ is true, then the operation has definite undefined behavior (right operand is definitely zero). You must still compute $I(E)$ for analysis but you must not use $val(E)$ in any further computation of program behavior. For $I(E)$, use the sound over-approximation rule\n    $$I(E) = \\left[\\,0,\\; \\min\\!\\left(h(E_1),\\; \\max\\!\\left(h(E_2) - 1,\\; 0\\right)\\right)\\right]\\,.$$\n  - If $must\\_zero(E_2)$ is false, then set\n    $$val(E) = val(E_1) \\bmod val(E_2),$$\n    and set\n    $$I(E) = \\left[\\,0,\\; \\min\\!\\left(h(E_1),\\; \\max\\!\\left(h(E_2) - 1,\\; 0\\right)\\right)\\right],$$\n    with $must\\_zero(E)$ true if and only if $I(E) = [0,0]$.\n\nNow consider the fully parenthesized expression whose parse tree is\n$$E \\;\\Rightarrow\\; \\big(\\,\\big(\\,(n_1 \\;\\% \\; n_2)\\; \\% \\; (n_3 \\;\\% \\; n_4)\\,\\big)\\; \\% \\; n_5\\,\\big),$$\nwhere $n_i$ are terminals of the form $\\text{num}$ with the following concrete lexeme values and statically known intervals:\n- $n_1$: concrete value $v_1 = 47$, interval $[L_1,H_1] = [40,60]$,\n- $n_2$: concrete value $v_2 = 13$, interval $[L_2,H_2] = [10,15]$,\n- $n_3$: concrete value $v_3 = 9$, interval $[L_3,H_3] = [0,12]$,\n- $n_4$: concrete value $v_4 = 4$, interval $[L_4,H_4] = [2,5]$,\n- $n_5$: concrete value $v_5 = 6$, interval $[L_5,H_5] = [5,9]$.\n\nTasks:\n- Using only the rules above, annotate the parse tree bottom-up to compute $I(E)$ and $must\\_zero(E)$ at every interior node, and detect whether any interior node $E \\Rightarrow E_1 \\;\\% \\; E_2$ has definite undefined behavior due to $must\\_zero(E_2)$ being true.\n- Assuming no definite undefined behavior is detected, compute the exact integer value $val$ at the root.\n\nGive your answer as an exact integer. If the expression is detected to have definite undefined behavior under these rules, do not compute $val$; however, the provided data are consistent and self-contained, and you should proceed accordingly based on your analysis.", "solution": "The problem is well-defined, internally consistent, and scientifically grounded in the principles of compiler design, specifically attribute grammars and static analysis via interval arithmetic. All necessary rules and data are provided. We may therefore proceed with a solution.\n\nThe problem requires the evaluation of attributes on a parse tree for the expression `(((n1 % n2) % (n3 % n4)) % n5)`. The grammar provided is $E \\to E \\;\\% \\; E \\mid \\text{num}$. The parenthesization of the expression dictates a unique abstract syntax tree (AST). We will perform a bottom-up evaluation (a post-order traversal) of this tree to compute the synthesized attributes at each node.\n\nLet us denote the nodes of the AST as follows:\n- Leaf nodes $E_{n1}, E_{n2}, E_{n3}, E_{n4}, E_{n5}$ correspond to the terminals $n_1, n_2, n_3, n_4, n_5$.\n- Internal node $E_B$ is the parent for the operation $E_{n1} \\;\\% \\; E_{n2}$.\n- Internal node $E_C$ is the parent for the operation $E_{n3} \\;\\% \\; E_{n4}$.\n- Internal node $E_A$ is the parent for the operation $E_B \\;\\% \\; E_C$.\n- The root node $E_R$ is the parent for the operation $E_A \\;\\% \\; E_{n5}$.\n\nThe evaluation proceeds in the following stages:\n\n**1. Attributes of Leaf Nodes**\nAccording to the problem statement, for a leaf node $E \\Rightarrow \\text{num}$ with concrete value $v$ and static interval $[L,H]$, the attributes are set as: $val(E) = v$, $I(E) = [L,H]$, and $must\\_zero(E)$ is true iff $L=0$ and $H=0$.\n\nUsing the provided data:\n- For $E_{n1}$: $v_1 = 47$, $I(E_{n1}) = [40, 60]$. Since the interval is not $[0,0]$, $must\\_zero(E_{n1}) = \\text{false}$.\n- For $E_{n2}$: $v_2 = 13$, $I(E_{n2}) = [10, 15]$. Since the interval is not $[0,0]$, $must\\_zero(E_{n2}) = \\text{false}$.\n- For $E_{n3}$: $v_3 = 9$, $I(E_{n3}) = [0, 12]$. Since the interval is not $[0,0]$, $must\\_zero(E_{n3}) = \\text{false}$.\n- For $E_{n4}$: $v_4 = 4$, $I(E_{n4}) = [2, 5]$. Since the interval is not $[0,0]$, $must\\_zero(E_{n4}) = \\text{false}$.\n- For $E_{n5}$: $v_5 = 6$, $I(E_{n5}) = [5, 9]$. Since the interval is not $[0,0]$, $must\\_zero(E_{n5}) = \\text{false}$.\n\n**2. Evaluation of Node $E_B \\to E_{n1} \\;\\% \\; E_{n2}$**\nFirst, we check the condition for undefined behavior. The right operand is $E_{n2}$, and $must\\_zero(E_{n2})$ is false. Thus, no definite undefined behavior is detected at this node, and we can compute $val(E_B)$.\n\n- Compute $val(E_B)$:\n  $val(E_B) = val(E_{n1}) \\bmod val(E_{n2}) = 47 \\bmod 13 = 8$.\n\n- Compute $I(E_B)$:\n  The rule is $I(E) = [0, \\min(h(E_1), \\max(h(E_2) - 1, 0))]$.\n  $h(E_{n1}) = 60$ and $h(E_{n2}) = 15$.\n  $I(E_B) = [0, \\min(60, \\max(15 - 1, 0))] = [0, \\min(60, 14)] = [0, 14]$.\n\n- Compute $must\\_zero(E_B)$:\n  Since $I(E_B) = [0, 14]$ is not $[0,0]$, $must\\_zero(E_B) = \\text{false}$.\n\n**3. Evaluation of Node $E_C \\to E_{n3} \\;\\% \\; E_{n4}$**\nThe right operand is $E_{n4}$, and $must\\_zero(E_{n4})$ is false. No definite undefined behavior is detected.\n\n- Compute $val(E_C)$:\n  $val(E_C) = val(E_{n3}) \\bmod val(E_{n4}) = 9 \\bmod 4 = 1$.\n\n- Compute $I(E_C)$:\n  $h(E_{n3}) = 12$ and $h(E_{n4}) = 5$.\n  $I(E_C) = [0, \\min(12, \\max(5 - 1, 0))] = [0, \\min(12, 4)] = [0, 4]$.\n\n- Compute $must\\_zero(E_C)$:\n  Since $I(E_C) = [0, 4]$ is not $[0,0]$, $must\\_zero(E_C) = \\text{false}$.\n\n**4. Evaluation of Node $E_A \\to E_B \\;\\% \\; E_C$**\nThe right operand is $E_C$, and we have computed $must\\_zero(E_C) = \\text{false}$. No definite undefined behavior is detected.\n\n- Compute $val(E_A)$:\n  $val(E_A) = val(E_B) \\bmod val(E_C) = 8 \\bmod 1 = 0$.\n\n- Compute $I(E_A)$:\n  $h(E_B) = 14$ and $h(E_C) = 4$.\n  $I(E_A) = [0, \\min(14, \\max(4 - 1, 0))] = [0, \\min(14, 3)] = [0, 3]$.\n\n- Compute $must\\_zero(E_A)$:\n  Since $I(E_A) = [0, 3]$ is not $[0,0]$, $must\\_zero(E_A) = \\text{false}$.\n\n**5. Evaluation of Root Node $E_R \\to E_A \\;\\% \\; E_{n5}$**\nThe right operand is $E_{n5}$, and $must\\_zero(E_{n5})$ is false. No definite undefined behavior is detected.\n\n- Compute $val(E_R)$:\n  $val(E_R) = val(E_A) \\bmod val(E_{n5}) = 0 \\bmod 6 = 0$.\n\n- Compute $I(E_R)$:\n  $h(E_A) = 3$ and $h(E_{n5}) = 9$.\n  $I(E_R) = [0, \\min(3, \\max(9 - 1, 0))] = [0, \\min(3, 8)] = [0, 3]$.\n\n- Compute $must\\_zero(E_R)$:\n  Since $I(E_R) = [0, 3]$ is not $[0,0]$, $must\\_zero(E_R) = \\text{false}$.\n\n**Conclusion**\nThe bottom-up evaluation of the attribute grammar is complete. At no point in the computation for an interior node $E \\to E_1 \\;\\% \\; E_2$ was the condition $must\\_zero(E_2)$ found to be true. Therefore, the static analysis, according to the specified rules, does not detect definite undefined behavior (division by zero) in the given expression.\n\nSince no undefined behavior was detected, the computation of the $val$ attribute is valid throughout the tree. The final integer value of the expression is the value of the $val$ attribute at the root node, $val(E_R)$.\n\nThe computed value at the root is $val(E_R) = 0$.", "answer": "$$\n\\boxed{0}\n$$", "id": "3621702"}, {"introduction": "For some operations, such as matrix multiplication, the order of evaluation can dramatically affect performance without changing the final result. This final exercise demonstrates how attribute grammars can be used to solve complex optimization problems by finding the most efficient evaluation strategy [@problem_id:3621717]. You will annotate a parse tree for matrix expressions with `shape` and `cost` attributes, transforming the problem of finding the optimal parenthesization into a systematic, syntax-directed computation.", "problem": "You are given the ambiguous context-free grammar (Context-Free Grammar (CFG)) for matrix expressions\n$$\nM \\to M * M \\mid M + M \\mid M^{\\top} \\mid \\text{id},\n$$\nwhere $\\text{id}$ denotes a matrix identifier. Define a synthesized-attribute specification that annotates every parse tree node with two attributes:\n- $shape \\in \\mathbb{N} \\times \\mathbb{N}$, giving the matrix dimensions $(rows, cols)$ of the subexpression, and\n- $cost \\in \\mathbb{R}_{\\ge 0} \\cup \\{\\infty\\}$, giving a scalar-operation cost of evaluating the subexpression.\n\nAssume the following foundational rules for typing and cost:\n- If $X$ has shape $(r,k)$ and $Y$ has shape $(k,c)$, then $X * Y$ has shape $(r,c)$ and costs $r \\cdot k \\cdot c$.\n- If $X$ and $Y$ have the same shape $(r,c)$, then $X + Y$ has shape $(r,c)$ and costs $r \\cdot c$.\n- If $X$ has shape $(r,c)$, then $X^{\\top}$ has shape $(c,r)$ and costs $0$.\n- Each identifier $\\text{id}$ has a known shape from the symbol table and costs $0$.\n- Any ill-typed combination yields $cost = \\infty$ and an undefined $shape$.\n\nBecause the grammar is ambiguous for $*$ and $+$, interpret the attributes for a nonterminal $M$ as selecting, among all parse trees for the same terminal string, the finite $cost$ minimum, with $shape$ taken from the minimizing alternative.\n\nUsing this attribute-based interpretation, compute the minimal total $cost$ for the expression\n$$\nA * B * C \\; + \\; D^{\\top} * E,\n$$\nunder the symbol table\n- $A : (10,100)$,\n- $B : (100,5)$,\n- $C : (5,50)$,\n- $D : (50,10)$,\n- $E : (50,50)$.\n\nUnary transpose $^{\\top}$ binds more tightly than binary operators; binary operators are fully parenthesized by the parse and may be grouped in any way consistent with token order. Provide the minimal total $cost$ as an exact integer (no rounding). Do not include any units in your final answer.", "solution": "This problem is a classic example of using attribute grammars for optimization, specifically an adaptation of the matrix chain multiplication problem. The goal is to find the minimum cost parenthesization for a matrix expression. The ambiguity of the grammar means we must consider all valid groupings and select the one with the lowest cost. This is a dynamic programming problem solved on the structure of the expression.\n\nFirst, let's establish the attributes (shape and cost) for the base matrices. The cost of a base matrix is $0$.\n- $A$: `shape` = $(10, 100)$, `cost` = $0$\n- $B$: `shape` = $(100, 5)$, `cost` = $0$\n- $C$: `shape` = $(5, 50)$, `cost` = $0$\n- $D$: `shape` = $(50, 10)$, `cost` = $0$\n- $E$: `shape` = $(50, 50)$, `cost` = $0$\n\nThe expression is $A * B * C + D^{\\top} * E$. The transpose operator $^\\top$ binds tightest.\n- Let $D' = D^{\\top}$.\n- $D.shape = (50, 10)$, so $D'.shape = (10, 50)$.\n- The cost of transpose is $0$, so $D'.cost = D.cost = 0$.\n\nThe expression becomes a sequence of five operands with four binary operators: $A * B * C + D' * E$. We must find the minimum cost by trying all valid parenthesizations. Let $M_1=A, M_2=B, M_3=C, M_4=D', M_5=E$. The expression is $M_1 * M_2 * M_3 + M_4 * M_5$. The overall cost of an operation $X \\text{ op } Y$ is $X.cost + Y.cost + \\text{op_cost}$.\n\n**1. Analyze $S_1 = A * B * C$**\nThis subexpression can be grouped in two ways:\n- **Grouping 1: $(A * B) * C$**\n    - First, compute $T_1 = A * B$.\n        - Shapes are compatible: $A:(10, \\underline{100})$ and $B:(\\underline{100}, 5)$.\n        - $T_1.shape = (10, 5)$.\n        - $T_1.cost = A.cost + B.cost + (10 \\times 100 \\times 5) = 0 + 0 + 5000 = 5000$.\n    - Then, compute $T_1 * C$.\n        - Shapes are compatible: $T_1:(10, \\underline{5})$ and $C:(\\underline{5}, 50)$.\n        - Resulting shape is $(10, 50)$.\n        - Total cost = $T_1.cost + C.cost + (10 \\times 5 \\times 50) = 5000 + 0 + 2500 = 7500$.\n- **Grouping 2: $A * (B * C)$**\n    - First, compute $T_2 = B * C$.\n        - Shapes are compatible: $B:(100, \\underline{5})$ and $C:(\\underline{5}, 50)$.\n        - $T_2.shape = (100, 50)$.\n        - $T_2.cost = B.cost + C.cost + (100 \\times 5 \\times 50) = 0 + 0 + 25000 = 25000$.\n    - Then, compute $A * T_2$.\n        - Shapes are compatible: $A:(10, \\underline{100})$ and $T_2:(\\underline{100}, 50)$.\n        - Resulting shape is $(10, 50)$.\n        - Total cost = $A.cost + T_2.cost + (10 \\times 100 \\times 50) = 0 + 25000 + 50000 = 75000$.\n\nComparing the two groupings, the minimum cost for $A * B * C$ is $7500$, with a resulting shape of $(10, 50)$. So, $S_1.cost = 7500$ and $S_1.shape = (10, 50)$.\n\n**2. Analyze $S_2 = D^{\\top} * E$ (or $D' * E$)**\nThis subexpression is unambiguous.\n- Shapes are compatible: $D':(10, \\underline{50})$ and $E:(\\underline{50}, 50)$.\n- Resulting shape is $(10, 50)$.\n- Total cost = $D'.cost + E.cost + (10 \\times 50 \\times 50) = 0 + 0 + 25000 = 25000$.\nSo, $S_2.cost = 25000$ and $S_2.shape = (10, 50)$.\n\n**3. Combine Sub-expressions**\nThe problem instruction to allow any grouping consistent with token order means we must check all top-level splits. The possible splits are:\n- $(A * B * C) + (D^{\\top} * E)$\n- $(A * B * C + D^{\\top}) * E$\n- Any other splits like $A * (B * C + D^{\\top} * E)$ will lead to type errors (e.g., adding matrices of incompatible shapes), resulting in infinite cost.\n\n**Case a: Split at `+`, parsing as $(A * B * C) + (D^{\\top} * E)$**\n- We use the minimum cost attributes for each sub-part.\n- $S_1 = A*B*C$: `cost` = $7500$, `shape` = $(10, 50)$.\n- $S_2 = D^{\\top}*E$: `cost` = $25000$, `shape` = $(10, 50)$.\n- For the addition $S_1 + S_2$, the shapes must be identical. They are, so the operation is valid.\n- The cost of addition is $r \\times c = 10 \\times 50 = 500$.\n- Total cost = $S_1.cost + S_2.cost + \\text{cost of addition} = 7500 + 25000 + 500 = 33000$.\n\n**Case b: Split at last `*`, parsing as $(A * B * C + D^{\\top}) * E$**\n- First, compute $S_3 = A * B * C + D^{\\top}$.\n    - This is $(A*B*C) + D^{\\top}$. The other grouping $A*(B*C+D^{\\top})$ is ill-typed.\n    - We use the min-cost result for $A*B*C$, which has shape $(10, 50)$ and cost $7500$.\n    - We add this to $D^{\\top}$, which has shape $(10, 50)$ and cost $0$.\n    - The shapes match. Cost of addition is $10 \\times 50 = 500$.\n    - $S_3.cost = 7500 + 0 + 500 = 8000$. $S_3.shape = (10, 50)$.\n- Then compute $S_3 * E$.\n    - Shapes are compatible: $S_3:(10, \\underline{50})$ and $E:(\\underline{50}, 50)$.\n    - Cost of multiplication is $10 \\times 50 \\times 50 = 25000$.\n    - Total cost = $S_3.cost + E.cost + \\text{cost of multiplication} = 8000 + 0 + 25000 = 33000$.\n\nBoth valid top-level parsings yield the same minimum cost.\n\n**Conclusion**\nBy applying the attribute grammar rules and exploring all valid parse trees to find the one with the minimum finite cost, we find that the minimal total cost for evaluating the expression is $33000$.", "answer": "$$ \\boxed{33000} $$", "id": "3621717"}]}