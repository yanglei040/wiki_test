{"hands_on_practices": [{"introduction": "We begin by exploring the core concepts of name versus structural equivalence. This exercise [@problem_id:3681308] uses record types to demonstrate how the order of fields can determine equivalence under different rule sets. Mastering this distinction is the first step toward understanding the design of any statically typed language.", "problem": "Consider a statically typed language with record types. A record type is a finite collection of labeled fields, each associated with a component type. Two widely used notions of type equivalence in compiler theory are as follows.\n\n1. Structural equivalence: Two types are structurally equivalent, written $T \\equiv_{\\text{struct}} S$, if their structures match under the language’s chosen notion of record structure comparison. For records, there are two common regimes: \n   - Order-insensitive records: the record is treated as a finite mapping from labels to types; two records are structurally equivalent if and only if they have the same set of labels and each corresponding label maps to an equivalent component type, ignoring field order.\n   - Order-sensitive records: the record is treated as a finite sequence of labeled fields; two records are structurally equivalent if and only if they have the same sequence of labels and corresponding component types in the same order.\n2. Name equivalence: Types introduced by declarations receive names. Under strong name equivalence, two types are equivalent if and only if they are introduced by the same type name (i.e., the same declaration). Under weak name equivalence, two named types are equivalent if their definitions expand to identical type expressions according to the language’s notion of syntactic identity; some languages treat record fields as unordered in this comparison, while others treat the sequence as ordered.\n\nLet the following type expressions be introduced by two distinct type alias declarations named $\\mathtt{T}$ and $\\mathtt{S}$, respectively:\n$$\nT = \\text{record}\\{a:\\mathtt{int},\\; b:(\\mathtt{int}\\to\\mathtt{int})\\},\\qquad\nS = \\text{record}\\{b:(\\mathtt{int}\\to\\mathtt{int}),\\; a:\\mathtt{int}\\}.\n$$\nAssume $\\mathtt{int}$ denotes the integer type and $(\\mathtt{int}\\to\\mathtt{int})$ denotes the type of total functions from integers to integers. Using only the fundamental definitions above, determine which statements correctly characterize whether $T \\equiv S$ under the stated equivalence regime. Select all that apply.\n\nA. Under structural equivalence with order-insensitive records (labels compared as a set and field order ignored), $T \\equiv S$ holds.\n\nB. Under structural equivalence with order-sensitive records (the exact sequence of labeled fields must match), $T \\equiv S$ holds.\n\nC. Under strong name equivalence, where $\\mathtt{T}$ and $\\mathtt{S}$ are distinct type names introduced by separate declarations, $T \\equiv S$ holds.\n\nD. Under weak name equivalence that compares expanded definitions but treats record fields as unordered in the syntactic identity, $T \\equiv S$ holds.", "solution": "The problem statement will first be validated for correctness, completeness, and scientific grounding.\n\n### Step 1: Extract Givens\n\nThe problem provides the following definitions and data:\n1.  **Language Features**: A statically typed language with record types.\n2.  **Structural Equivalence ($T \\equiv_{\\text{struct}} S$)**:\n    *   **Order-insensitive records**: Equivalence holds if records have the same set of labels and corresponding component types are equivalent. Field order is ignored.\n    *   **Order-sensitive records**: Equivalence holds if records have the same sequence of labels and corresponding component types in the same order.\n3.  **Name Equivalence**:\n    *   **Strong name equivalence**: Equivalence holds if and only if two types are introduced by the same type name (i.e., the same declaration).\n    *   **Weak name equivalence**: Equivalence holds if the definitions of two named types expand to identical type expressions. The problem specifies a variant where record fields are compared as unordered.\n4.  **Type Declarations**: Two distinct type alias declarations, named $\\mathtt{T}$ and $\\mathtt{S}$, introduce the following type expressions (which we will refer to as $T$ and $S$ respectively for the purpose of comparison):\n    $$\n    T = \\text{record}\\{a:\\mathtt{int},\\; b:(\\mathtt{int}\\to\\mathtt{int})\\}\n    $$\n    $$\n    S = \\text{record}\\{b:(\\mathtt{int}\\to\\mathtt{int}),\\; a:\\mathtt{int}\\}\n    $$\n5.  **Primitive Types**: $\\mathtt{int}$ is the integer type. $(\\mathtt{int}\\to\\mathtt{int})$ is the type of total functions from integers to integers.\n\n### Step 2: Validate Using Extracted Givens\n\nThe provided problem statement is a standard exercise in programming language theory, specifically concerning type systems.\n-   **Scientifically Grounded**: The concepts of structural equivalence, name equivalence (strong and weak), and record types are fundamental and well-established in the field of compiler design and programming language semantics. The definitions provided are correct representations of these concepts. The problem is scientifically sound.\n-   **Well-Posed**: The problem is clearly defined. The types $T$ and $S$ are explicitly given, as are the rules for four different equivalence regimes. The task is to apply these rules to the given types, which allows for a unique and verifiable solution for each part of the question. The problem is well-posed.\n-   **Objective**: The language used is precise and technical, free of ambiguity, subjectivity, or opinion.\n-   **Completeness**: The problem is self-contained. All necessary definitions and data required to evaluate the statements are provided within the text.\n\n### Step 3: Verdict and Action\n\nThe problem statement is valid. A rigorous derivation of the solution can proceed.\n\n### Solution Derivation\n\nWe are asked to evaluate the equivalence of two type expressions, $T$ and $S$, under different regimes. The types are:\n$$\nT = \\text{record}\\{a:\\mathtt{int},\\; b:(\\mathtt{int}\\to\\mathtt{int})\\}\n$$\n$$\nS = \\text{record}\\{b:(\\mathtt{int}\\to\\mathtt{int}),\\; a:\\mathtt{int}\\}\n$$\nWe will analyze each option based on the provided definitions.\n\n**A. Under structural equivalence with order-insensitive records (labels compared as a set and field order ignored), $T \\equiv S$ holds.**\n\nAccording to the definition of order-insensitive structural equivalence, two record types are equivalent if they possess the same set of labels, and the types associated with each corresponding label are equivalent.\n\n1.  **Compare sets of labels**:\n    -   The set of labels for type $T$ is $\\{a, b\\}$.\n    -   The set of labels for type $S$ is $\\{b, a\\}$.\n    -   Since sets are unordered collections, $\\{a, b\\} = \\{b, a\\}$. The condition on the sets of labels is met.\n\n2.  **Compare component types for each label**:\n    -   For the label $a$: In $T$, its type is $\\mathtt{int}$. In $S$, its type is also $\\mathtt{int}$. The types are equivalent.\n    -   For the label $b$: In $T$, its type is $(\\mathtt{int}\\to\\mathtt{int})$. In $S$, its type is also $(\\mathtt{int}\\to\\mathtt{int})$. The types are equivalent.\n\nSince both conditions are met, the types $T$ and $S$ are structurally equivalent under an order-insensitive regime. Therefore, $T \\equiv S$ holds.\n\n**Verdict: Correct.**\n\n**B. Under structural equivalence with order-sensitive records (the exact sequence of labeled fields must match), $T \\equiv S$ holds.**\n\nAccording to the definition of order-sensitive structural equivalence, two record types are equivalent if they have the same sequence of labeled fields. This means both the labels and their order must match.\n\n1.  **Compare sequences of labeled fields**:\n    -   The sequence of labeled fields for $T$ is $(a:\\mathtt{int}, b:(\\mathtt{int}\\to\\mathtt{int}))$.\n    -   The sequence of labeled fields for $S$ is $(b:(\\mathtt{int}\\to\\mathtt{int}), a:\\mathtt{int}))$.\n\nThe first field in the sequence for $T$ has the label $a$. The first field in the sequence for $S$ has the label $b$. Since $a \\neq b$, the sequences of labels are not the same. Therefore, the types are not equivalent under this regime.\n\n**Verdict: Incorrect.**\n\n**C. Under strong name equivalence, where $\\mathtt{T}$ and $\\mathtt{S}$ are distinct type names introduced by separate declarations, $T \\equiv S$ holds.**\n\nThe definition of strong name equivalence states that two types are equivalent if and only if they are introduced by the same type name, meaning they originate from the exact same declaration.\n\nThe problem states that the types are introduced by \"two distinct type alias declarations named $\\mathtt{T}$ and $\\mathtt{S}$\". Because the declarations are distinct, the type names $\\mathtt{T}$ and $\\mathtt{S}$ are not the same. Under strong name equivalence, non-identical names imply non-equivalent types, regardless of the underlying structural definition. Thus, $\\mathtt{T} \\not\\equiv \\mathtt{S}$.\n\n**Verdict: Incorrect.**\n\n**D. Under weak name equivalence that compares expanded definitions but treats record fields as unordered in the syntactic identity, $T \\equiv S$ holds.**\n\nThe definition of weak name equivalence requires that we first expand the type names to their underlying type expressions and then compare those expressions. The specific rule for comparison given here is that \"record fields [are treated] as unordered\".\n\n1.  **Expand the type names**:\n    -   The name $\\mathtt{T}$ expands to the type expression $T = \\text{record}\\{a:\\mathtt{int},\\; b:(\\mathtt{int}\\to\\mathtt{int})\\}$.\n    -   The name $\\mathtt{S}$ expands to the type expression $S = \\text{record}\\{b:(\\mathtt{int}\\to\\mathtt{int}),\\; a:\\mathtt{int}\\}$.\n\n2.  **Compare the expanded definitions**: The comparison is to be performed by treating the record fields as an unordered set. This is precisely the same comparison criterion as for order-insensitive structural equivalence.\n    -   The set of fields for the expansion of $\\mathtt{T}$ is $\\{a:\\mathtt{int}, b:(\\mathtt{int}\\to\\mathtt{int})\\}$.\n    -   The set of fields for the expansion of $\\mathtt{S}$ is $\\{b:(\\mathtt{int}\\to\\mathtt{int}), a:\\mathtt{int}\\}$.\n    -   As established in the analysis of option A, these two sets of fields are identical.\nTherefore, under this specific variant of weak name equivalence, the types are equivalent.\n\n**Verdict: Correct.**", "answer": "$$\\boxed{AD}$$", "id": "3681308"}, {"introduction": "Now, let's see why these rules matter in practice. This problem [@problem_id:3681340] explores how nominal typing provides a powerful mechanism for ensuring program safety, even when types share the same underlying representation. You will see how creating a distinct type name prevents logical errors, such as confusing a unit of measurement with a generic number.", "problem": "Consider a statically typed language with nominal (name-based) type equivalence and a zero-cost user-defined wrapper construct $\\mathtt{newtype}$ that creates a distinct static type sharing the same runtime representation as its underlying type. Let $S = \\mathtt{int}$ be the built-in integer type, and let $T = \\mathtt{newtype}\\ \\mathtt{Meters} = \\mathtt{int}$ be a user-defined distinct type that wraps $\\mathtt{int}$. By construction in this language, $T \\neq S$ at the type level, even though their runtime layouts are identical. The language enforces the following rules:\n- Two types are equivalent for static type checking if and only if they are the same nominal type.\n- An assignment $\\mathtt{lhs} := \\mathtt{rhs}$ type-checks if and only if the static type of $\\mathtt{rhs}$ is equivalent to the static type of $\\mathtt{lhs}$.\n- A function application type-checks if and only if the actual argument’s static type is equivalent to the formal parameter’s static type.\n- The equality operator $\\mathtt{=}$ is defined only for pairs of operands with the same static type.\n- The language provides an explicit, zero-cost coercion function $\\mathtt{unwrap}: T \\rightarrow S$ that reveals the underlying $\\mathtt{int}$ from a $\\mathtt{Meters}$ value. No other implicit conversions exist.\n- Although $T$ and $S$ share the same runtime calling convention and memory layout according to the Application Binary Interface (ABI), the type checker does not use ABI information to establish type equivalence.\n\nSuppose we have the following declarations and definitions:\n- $\\mathtt{f} : S \\rightarrow S$, where $\\mathtt{f}(u) = u + 1$ for $u : S$.\n- Variables $\\mathtt{x} : S$ and $\\mathtt{y} : T$ initialized as $\\mathtt{x} := 3$ and $\\mathtt{y} := \\mathtt{Meters}(3)$.\n\nWhich of the following program fragments are guaranteed to type-check without errors under the rules above?\n\nA. $\\mathtt{x} := \\mathtt{y}$\n\nB. $\\mathtt{f}(\\mathtt{y})$\n\nC. $\\mathtt{x} = \\mathtt{y}$\n\nD. $\\mathtt{f(\\, \\mathtt{unwrap}(y) \\,)}$", "solution": "The fundamental principle governing this problem is **nominal type equivalence**. Two types are considered equivalent by the static type checker if and only if they share the same name.\n\nThe problem defines two types:\n1.  $S = \\mathtt{int}$, a built-in integer type.\n2.  $T = \\mathtt{newtype}\\ \\mathtt{Meters} = \\mathtt{int}$, a user-defined type.\n\nThe `newtype` construct explicitly creates a new, distinct static type. Therefore, even though $T$ and $S$ have the same runtime representation, their nominal types are different. The problem states this directly: $T \\neq S$ at the type level.\n\nWe are given the following variables and functions with their static types:\n- Variable $\\mathtt{x}$ has type $S$, denoted as $\\mathtt{type}(\\mathtt{x}) = S$.\n- Variable $\\mathtt{y}$ has type $T$, denoted as $\\mathtt{type}(\\mathtt{y}) = T$.\n- Function $\\mathtt{f}$ has the signature $\\mathtt{f} : S \\rightarrow S$. This means it accepts one argument of type $S$ and returns a value of type $S$.\n- Function $\\mathtt{unwrap}$ has the signature $\\mathtt{unwrap}: T \\rightarrow S$. This means it accepts one argument of type $T$ and returns a value of type $S$.\n\nWe will now evaluate each program fragment against the provided type-checking rules.\n\n**Option A: $\\mathtt{x} := \\mathtt{y}$**\nThis is an assignment statement. The rule for assignment, $\\mathtt{lhs} := \\mathtt{rhs}$, requires that $\\mathtt{type}(\\mathtt{rhs})$ be equivalent to $\\mathtt{type}(\\mathtt{lhs})$.\n- The type of the left-hand side, $\\mathtt{lhs}$, is $\\mathtt{type}(\\mathtt{x}) = S$.\n- The type of the right-hand side, $\\mathtt{rhs}$, is $\\mathtt{type}(\\mathtt{y}) = T$.\nThe type checker must verify if $T$ is equivalent to $S$. Under nominal typing, these are distinct types, so $T \\neq S$. The assignment is not type-correct.\nVerdict: **Incorrect**.\n\n**Option B: $\\mathtt{f}(\\mathtt{y})$**\nThis is a function application. The rule requires that the static type of the actual argument be equivalent to the static type of the formal parameter.\n- The function $\\mathtt{f}$ has signature $\\mathtt{f} : S \\rightarrow S$, so its formal parameter has type $S$.\n- The actual argument is $\\mathtt{y}$, and its type is $\\mathtt{type}(\\mathtt{y}) = T$.\nThe type checker must verify if the argument type $T$ is equivalent to the parameter type $S$. As established, $T \\neq S$. The function application is not type-correct.\nVerdict: **Incorrect**.\n\n**Option C: $\\mathtt{x} = \\mathtt{y}$**\nThis is an equality comparison. The rule states that the equality operator $\\mathtt{=}$ is defined only for pairs of operands with the same static type.\n- The type of the left operand $\\mathtt{x}$ is $S$.\n- The type of the right operand $\\mathtt{y}$ is $T$.\nThe types of the operands, $S$ and $T$, are not the same. The expression is not type-correct.\nVerdict: **Incorrect**.\n\n**Option D: $\\mathtt{f(\\, \\mathtt{unwrap}(y) \\,)}$**\nThis is a nested expression involving two function calls. We analyze it from the innermost expression outwards.\n1.  Inner expression: $\\mathtt{unwrap}(y)$.\n    - This is a function application of $\\mathtt{unwrap}$ to the argument $\\mathtt{y}$.\n    - The function $\\mathtt{unwrap}$ has signature $\\mathtt{unwrap}: T \\rightarrow S$. Its formal parameter has type $T$.\n    - The actual argument is $\\mathtt{y}$, with $\\mathtt{type}(\\mathtt{y}) = T$.\n    - Since the argument type $T$ matches the parameter type $T$, this application is type-correct.\n    - The result of the expression $\\mathtt{unwrap}(y)$ has the return type of the function, which is $S$.\n\n2.  Outer expression: $\\mathtt{f(\\dots)}$.\n    - This is a function application of $\\mathtt{f}$ to the result of the inner expression, $\\mathtt{unwrap}(y)$.\n    - The function $\\mathtt{f}$ has signature $\\mathtt{f} : S \\rightarrow S$. Its formal parameter has type $S$.\n    - The actual argument is the result of $\\mathtt{unwrap}(y)$, which we determined has type $S$.\n    - Since the argument type $S$ matches the parameter type $S$, this application is type-correct.\n\nThe entire program fragment $\\mathtt{f(\\, \\mathtt{unwrap}(y) \\,)}$ is well-typed because the explicit coercion via $\\mathtt{unwrap}$ correctly converts the value of type $T$ into a value of type $S$ before it is passed to function $\\mathtt{f}$, satisfying all type-checking rules.\nVerdict: **Correct**.", "answer": "$$\\boxed{D}$$", "id": "3681340"}, {"introduction": "Finally, we address a classic point of confusion: the relationship between pointers and arrays. Many language features can make distinct types seem interchangeable, but a robust type system relies on clear definitions. This practice [@problem_id:3681349] challenges you to separate true structural equivalence from context-sensitive rules like implicit conversion, clarifying a notoriously subtle concept.", "problem": "Consider a statically typed language $\\mathcal{L}$ with a conventional type system that includes base types and the following type constructors: pointer types $\\mathtt{ptr}(\\tau)$ written $\\mathtt{T}*$ for element type $\\tau$, and array types $\\mathtt{array}(n,\\tau)$ written $\\mathtt{T}[n]$ for length $n \\in \\mathbb{N}$ and element type $\\tau$. The language adopts the standard array-to-pointer decay in expression typing and the standard adjustment of array-typed formal parameters to pointer types, as follows.\n\nFundamental base definitions for the type system of $\\mathcal{L}$:\n- Structural type equivalence $\\equiv$ is defined inductively by constructors: two types are equivalent if and only if they have the same outer constructor and their corresponding components are equivalent. For a base type $\\mathtt{int}$, $\\mathtt{int} \\equiv \\mathtt{int}$. For pointers, $\\mathtt{ptr}(\\tau_1) \\equiv \\mathtt{ptr}(\\tau_2)$ if and only if $\\tau_1 \\equiv \\tau_2$. For arrays, $\\mathtt{array}(n_1,\\tau_1) \\equiv \\mathtt{array}(n_2,\\tau_2)$ if and only if $n_1 = n_2$ and $\\tau_1 \\equiv \\tau_2$.\n- Array-to-pointer decay is a context-sensitive implicit conversion rule at the expression level: in rvalue contexts, an expression $E$ with type $\\mathtt{array}(n,\\tau)$ is implicitly converted to an expression $E'$ with type $\\mathtt{ptr}(\\tau)$ that denotes the address of the first element of $E$.\n- Formal parameter adjustment: if a function is declared with a parameter of type $\\mathtt{array}(n,\\tau)$ or $\\mathtt{array}(\\_,\\tau)$ (where $\\_$ denotes an unspecified or syntactically elided bound permitted only in parameter declarations), the function’s internal type for that parameter is adjusted to $\\mathtt{ptr}(\\tau)$ prior to type checking of calls, so the function type records $\\mathtt{ptr}(\\tau)$ at that parameter position.\n\nAssume an Application Binary Interface (ABI) with pointer width $w \\in \\mathbb{N}$ bytes and that $\\operatorname{sizeof}(\\mathtt{int}) = s \\in \\mathbb{N}$ bytes. Let $T = \\mathtt{int}*$ denote $\\mathtt{ptr}(\\mathtt{int})$, and let $S = \\mathtt{int}[\\,]$ denote an unspecified-bound array type used only in parameter declarations; outside of parameter declarations, concrete arrays have a known bound $n$ and type $\\mathtt{int}[n] = \\mathtt{array}(n,\\mathtt{int})$.\n\nSelect all statements that are correct under these rules.\n\nA. Under structural equivalence, $T \\equiv S$ because arrays decay to pointers in expressions and both denote addresses of elements.\n\nB. $T \\not\\equiv S$ by structural equivalence, since pointer and array are distinct constructors; array decay is an implicit conversion, not an equivalence.\n\nC. If a function is declared with a parameter of type $S$, the compiler adjusts the parameter’s type to $T$ before forming the function type; therefore, the parameter types in the function type for declarations using $S$ and using $T$ are equivalent.\n\nD. For all $n \\in \\mathbb{N}$, $\\operatorname{sizeof}(a)$ for $a : \\mathtt{int}[n]$ equals $\\operatorname{sizeof}(p)$ for $p : T$, so arrays and pointers have the same representation size in every context.\n\nE. The assignment $p = a$ where $p : T$ and $a : \\mathtt{int}[n]$ is well-typed without a cast due to array-to-pointer decay; hence $T \\equiv S$ follows from assignability.", "solution": "The problem statement is first validated to ensure its correctness and solvability.\n\n### Step 1: Extract Givens\n- A statically typed language $\\mathcal{L}$ is considered.\n- Type constructors include pointer types $\\mathtt{ptr}(\\tau)$ (written $\\mathtt{T}*$) and array types $\\mathtt{array}(n,\\tau)$ (written $\\mathtt{T}[n]$), where $n \\in \\mathbb{N}$.\n- Structural type equivalence, $\\equiv$, is defined:\n    - Types are equivalent if they have the same outer constructor and their components are equivalent.\n    - $\\mathtt{int} \\equiv \\mathtt{int}$.\n    - $\\mathtt{ptr}(\\tau_1) \\equiv \\mathtt{ptr}(\\tau_2)$ if and only if $\\tau_1 \\equiv \\tau_2$.\n    - $\\mathtt{array}(n_1,\\tau_1) \\equiv \\mathtt{array}(n_2,\\tau_2)$ if and only if $n_1 = n_2$ and $\\tau_1 \\equiv \\tau_2$.\n- Array-to-pointer decay: In rvalue contexts, an expression of type $\\mathtt{array}(n,\\tau)$ is implicitly converted to an expression of type $\\mathtt{ptr}(\\tau)$.\n- Formal parameter adjustment: A function parameter of type $\\mathtt{array}(n,\\tau)$ or $\\mathtt{array}(\\_,\\tau)$ is adjusted to type $\\mathtt{ptr}(\\tau)$ in the function's type.\n- ABI constants: Pointer width is $w \\in \\mathbb{N}$ bytes; $\\operatorname{sizeof}(\\mathtt{int}) = s \\in \\mathbb{N}$ bytes.\n- Type aliases: $T = \\mathtt{int}*$, which is $\\mathtt{ptr}(\\mathtt{int})$. $S = \\mathtt{int}[\\,]$, which denotes $\\mathtt{array}(\\_, \\mathtt{int})$ for use in parameter declarations. Concrete arrays are $\\mathtt{int}[n]$, which is $\\mathtt{array}(n,\\mathtt{int})$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem is firmly based on established concepts in compiler theory and programming language design, specifically regarding type systems. The rules for structural equivalence, array-to-pointer decay, and parameter adjustment are modeled on real-world languages like C and C++.\n- **Well-Posed:** The problem provides a clear, axiomatic system of type rules and asks for an evaluation of statements within that system. The provided definitions are sufficient to determine the truth value of each statement.\n- **Objective:** The language is formal and precise, with no subjective or ambiguous terminology.\n- **Consistency and Completeness:** The definitions are self-contained and do not contradict one another. The distinction between type equivalence ($\\equiv$), implicit conversion (decay), and type adjustment is clear and central to the problem.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. It is a well-defined question in the formal study of type systems. The solution process can proceed.\n\n### Derivation of Principles\nThe core of this problem lies in the strict distinction between three concepts:\n$1$. **Type Equivalence ($\\equiv$)**: This is a static, structural property. Two types are equivalent only if they are built with the same constructor and have equivalent component types. The definition is rigid and context-independent. For example, $\\mathtt{ptr}(\\tau)$ and $\\mathtt{array}(n, \\tau)$ can never be structurally equivalent because their outermost constructors, $\\mathtt{ptr}$ and $\\mathtt{array}$, are different.\n$2$. **Implicit Conversion**: This is a rule that allows an expression of one type to be used where an expression of another type is expected. The types themselves remain distinct. \"Array-to-pointer decay\" is an example of such a conversion. It does not imply that the array type *is* a pointer type; it only means it can be *converted to* a pointer type in certain contexts.\n$3$. **Type Adjustment**: This is a special-case rule that modifies a type in a specific syntactic context. The \"formal parameter adjustment\" rule is an example, where the type of a function parameter declared as an array is changed to a pointer type for the purpose of defining the function's signature. This is a transformation, not a statement of a general equivalence.\n\nBased on these principles, let's establish the relationship between $T$ and $S$.\n- $T$ is the type $\\mathtt{ptr}(\\mathtt{int})$. Its constructor is $\\mathtt{ptr}$.\n- $S$ is the syntactic form $\\mathtt{int}[\\,]$ which represents an array type, $\\mathtt{array}(\\_, \\mathtt{int})$. Its constructor is $\\mathtt{array}$.\n- By the rule of structural equivalence, since $\\mathtt{ptr} \\neq \\mathtt{array}$, it must be that $T \\not\\equiv S$. In fact, $T$ is not equivalent to any array type $\\mathtt{array}(n, \\mathtt{int})$.\n\n### Option-by-Option Analysis\n\n**A. Under structural equivalence, $T \\equiv S$ because arrays decay to pointers in expressions and both denote addresses of elements.**\nThis statement claims that $T$ and $S$ are structurally equivalent ($T \\equiv S$). As established, this is false. The type constructor for $T$ is $\\mathtt{ptr}$, while the type constructor for $S$ (any array type) is $\\mathtt{array}$. The definition of structural equivalence requires the constructors to be identical. The reasoning provided (\"because arrays decay to pointers\") conflates implicit type conversion with type equivalence. Array decay is a conversion rule that applies to expressions, not a rule that equates the types themselves.\n**Verdict: Incorrect.**\n\n**B. $T \\not\\equiv S$ by structural equivalence, since pointer and array are distinct constructors; array decay is an implicit conversion, not an equivalence.**\nThis statement correctly asserts that $T \\not\\equiv S$. It provides the correct reason based on the problem's definition of structural equivalence: the constructors $\\mathtt{ptr}$ and $\\mathtt{array}$ are distinct. It also correctly identifies that array decay is an implicit conversion rule, which is separate from the concept of type equivalence. This analysis aligns perfectly with the foundational principles given.\n**Verdict: Correct.**\n\n**C. If a function is declared with a parameter of type $S$, the compiler adjusts the parameter’s type to $T$ before forming the function type; therefore, the parameter types in the function type for declarations using $S$ and using $T$ are equivalent.**\nThis statement describes the \"formal parameter adjustment\" rule.\n- A declaration `func(arg: S)` (syntactically, `func(int arg[])`) is processed by adjusting the parameter's type to $\\mathtt{ptr}(\\tau)$. Here, $\\tau$ is $\\mathtt{int}$, so the adjusted type is $\\mathtt{ptr}(\\mathtt{int})$, which is $T$.\n- A declaration `func(arg: T)` (syntactically, `func(int *arg)`) already uses the type $T$.\nSo, in both cases, when the compiler constructs the internal representation of the function's type (its signature), the parameter type is recorded as $T$. Therefore, the function types resulting from a declaration using $S$ and a declaration using $T$ for a parameter are identical. The parameter types in the final function type are indeed equivalent ($T \\equiv T$).\n**Verdict: Correct.**\n\n**D. For all $n \\in \\mathbb{N}$, $\\operatorname{sizeof}(a)$ for $a : \\mathtt{int}[n]$ equals $\\operatorname{sizeof}(p)$ for $p : T$, so arrays and pointers have the same representation size in every context.**\nThis statement makes a claim about the sizes of arrays and pointers.\n- For a variable $p$ of type $T = \\mathtt{ptr}(\\mathtt{int})$, its size is the size of a pointer, given as $w$. So, $\\operatorname{sizeof}(p) = w$.\n- For a variable $a$ of type $\\mathtt{int}[n] = \\mathtt{array}(n, \\mathtt{int})$, its size is the size of the entire array. Assuming no padding between elements, this is $n$ times the size of one element. So, $\\operatorname{sizeof}(a) = n \\cdot \\operatorname{sizeof}(\\mathtt{int}) = n \\cdot s$.\nThe statement claims that $n \\cdot s = w$ for all $n \\in \\mathbb{N}$. This is demonstrably false. If we take $n=1$, we get $s=w$. If we take $n=2$, we get $2s=w$. These two equations together imply $s = 2s$, which means $s=0$. However, the problem specifies $s \\in \\mathbb{N}$, which means $s \\geq 1$. Thus, the premise is false. The conclusion that arrays and pointers have the same representation size in every context is also false, as the `sizeof` operator provides a clear counterexample.\n**Verdict: Incorrect.**\n\n**E. The assignment $p = a$ where $p : T$ and $a : \\mathtt{int}[n]$ is well-typed without a cast due to array-to-pointer decay; hence $T \\equiv S$ follows from assignability.**\nThis statement has two parts.\n- The first part concerns the assignment $p=a$. The variable $p$ has type $T = \\mathtt{ptr}(\\mathtt{int})$. The variable $a$ has type $\\mathtt{array}(n, \\mathtt{int})$. In the context of an assignment, the right-hand side `a` is an rvalue. The \"array-to-pointer decay\" rule applies, implicitly converting the expression `a` to one of type $\\mathtt{ptr}(\\mathtt{int})$, which is precisely type $T$. Since the type of the left-hand side ($T$) now matches the type of the converted right-hand side, the assignment is well-typed. The first part of the statement is correct.\n- The second part concludes \"hence $T \\equiv S$ follows from assignability.\" This is a logical fallacy. Assignability, especially when mediated by an implicit conversion, does not imply type equivalence. The language is explicitly defined to have a conversion rule precisely because the types are *not* equivalent. The ability to assign an array expression to a pointer variable is a consequence of the conversion rule, not of the types being the same.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{BC}$$", "id": "3681349"}]}