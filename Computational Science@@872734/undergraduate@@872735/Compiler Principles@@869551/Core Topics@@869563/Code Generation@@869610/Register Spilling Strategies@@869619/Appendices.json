{"hands_on_practices": [{"introduction": "Effective register spilling is fundamentally about cost management. This first exercise explores the primary trade-off between spilling a value to memory versus saving it in another register. By analyzing a scenario with an `asm` block inside a loop, you'll learn to apply loop-invariant code motion and leverage the cost hierarchy—where register moves are far cheaper than memory access—to devise the most efficient strategy.", "problem": "You are implementing a local register-allocation decision around an inline assembly (`asm`) block in a loop in a compiler backend. The target machine has allocatable integer registers $\\{r_0, r_1, r_2, r_3, r_4, r_5\\}$. The inline assembly block lists a clobber set $\\{r_0, r_1\\}$, meaning that after the `asm` executes, the values in $r_0$ and $r_1$ are undefined and must be treated as destroyed by the compiler. Assume the clobber applies to the entire duration of the `asm`, and the compiler cannot inspect the `asm` body. At the program point immediately before the `asm` inside a loop of $N$ iterations, the allocator has assigned:\n- variable $x$ in $r_0$, and $x$ is used immediately after the `asm` in each iteration (inside the loop);\n- variable $y$ in $r_2$, and $y$ is live across the `asm` in every iteration and is used multiple times inside the loop, so keeping $y$ in a register across the `asm` is desirable;\n- variable $z$ in $r_1$, and $z$ is loop-invariant, live across the entire loop, and is used only once after the loop exits (no uses inside the loop body);\n- registers $r_3$ and $r_4$ hold other temporaries that are live across the `asm` inside the loop, and thus are not available;\n- register $r_5$ is the only non-clobbered free register at the `asm` boundary.\n\nAssume a simple and consistent cost model:\n- storing a register to its spill slot (a spill store) has cost $c_s = 3$;\n- loading a value from its spill slot (a reload) has cost $c_l = 3$;\n- moving a value between registers (a register-to-register move) has cost $c_m = 1$.\n\nThe compiler must ensure semantic correctness with respect to liveness and `asm` clobbers, and minimize the expected total cost across the loop. You may assume that code motion across the `asm` is restricted only by the clobber set and usual data dependencies; there are no aliasing or memory-barrier constraints beyond those implied by the clobbers listed.\n\nWhich strategy is correct and minimizes total expected cost across the $N$ iterations?\n\nA. Spill both $x$ and $z$ immediately before each `asm` and reload both immediately after each `asm`.\n\nB. Before entering the loop, spill $z$ once and defer its reload until its single use after the loop; in each iteration, move $x$ from $r_0$ to the free non-clobbered $r_5$ just before the `asm` so it survives the `asm` without spilling.\n\nC. Before entering the loop, move $z$ from $r_1$ to the free non-clobbered $r_5$ and keep it there across the loop; in each iteration, spill $x$ before the `asm` and reload it immediately after.\n\nD. In each iteration, spill $y$ before the `asm` to free $r_2$ and then move both $x$ and $z$ to non-clobbered registers before the `asm`; reload $y$ immediately after the `asm` in each iteration.\n\nYour answer should be based on the foundational definitions that (i) a variable is live at a program point if it may be used along some path before being redefined, (ii) an `asm` clobber on a register means its value must not be relied upon after the `asm` unless saved elsewhere, and (iii) spilling stores a live value to memory and reloading brings it back, extending or shrinking live ranges accordingly. Use these to reason about correctness and total cost. Assume $N \\ge 1$ is a known positive integer at compile-time for this cost analysis, but do not assume any special values of $N$.", "solution": "This problem requires analyzing different strategies for preserving live variables in clobbered registers, considering both correctness and cost over $N$ loop iterations. The key is to handle the loop-invariant variable $z$ differently from the loop-variant variable $x$.\n\n**1. Analyze the Constraints and Resources**\n\n-   **Variables to save:** $x$ (in clobbered $r_0$) and $z$ (in clobbered $r_1$) are live across the `asm` block and must be preserved.\n-   **Safe variables:** $y$ (in $r_2$), and temporaries in $r_3$ and $r_4$ are in non-clobbered registers and need no special handling.\n-   **Available resources:** We have memory (spill/reload cost of $3+3=6$) and one free, non-clobbered register, $r_5$ (move cost of $1$).\n-   **Optimization principle:** Operations on loop-invariant variables should be hoisted out of the loop whenever possible to avoid repeating the cost $N$ times.\n\n**2. Evaluate Each Strategy**\n\nLet's calculate the total cost for each option for $N \\ge 1$ iterations.\n\n**A. Spill both $x$ and $z$ before each `asm` and reload after.**\n-   **Correctness:** This is correct. Spilling to memory preserves both values.\n-   **Cost Analysis (per iteration):**\n    -   Spill $x$: $c_s = 3$.\n    -   Spill $z$: $c_s = 3$.\n    -   Reload $x$: $c_l = 3$.\n    -   Reload $z$: $c_l = 3$.\n-   **Total Cost:** $(3 + 3 + 3 + 3) \\times N = 12N$. This strategy fails to recognize that $z$ is loop-invariant and pays the full spill cost for it in every single iteration.\n\n**B. Hoist handling of $z$ via spilling; use free register for $x$.**\n-   **Correctness:**\n    -   **For $z$:** Since $z$ is loop-invariant, spilling it once before the loop (`cost = c_s = 3`) and reloading it once after the loop (`cost = c_l = 3`) is a correct way to preserve its value for its single use after the loop. This is classic loop-invariant code motion.\n    -   **For $x$:** In each iteration, $x$ is moved from the clobbered $r_0$ to the safe $r_5$ just before the `asm` (`cost = c_m = 1`). After the `asm`, the value of $x$ is available in $r_5$ for its use. This correctly preserves $x$ using a cheap register move.\n-   **Cost Analysis:**\n    -   Pre-loop cost (for $z$): $c_s = 3$.\n    -   Cost per iteration (for $x$): $c_m = 1$.\n    -   Post-loop cost (for $z$): $c_l = 3$.\n-   **Total Cost:** $3 + (1 \\times N) + 3 = N + 6$.\n\n**C. Hoist handling of $z$ via register move; spill $x$.**\n-   **Correctness:**\n    -   **For $z$:** Move $z$ from $r_1$ to the safe register $r_5$ before the loop starts (`cost = c_m = 1`). This is correct and keeps $z$ in $r_5$ for the loop's duration.\n    -   **For $x$:** Because $r_5$ is now occupied by $z$, there are no free non-clobbered registers. The only way to save $x$ is to spill it to memory before the `asm` and reload it after.\n-   **Cost Analysis:**\n    -   Pre-loop cost (for $z$): $c_m = 1$.\n    -   Cost per iteration (for $x$): Spill $x$ ($c_s = 3$) + Reload $x$ ($c_l = 3$) = $6$.\n-   **Total Cost:** $1 + (6 \\times N) = 6N + 1$.\n\n**D. Spill the safe variable $y$ to make space.**\n-   **Correctness:** This strategy is unnecessarily complex and inefficient. It spills $y$, which is already in a safe, non-clobbered register, to free up $r_2$. This is a valid but poor choice.\n-   **Cost Analysis (per iteration):**\n    -   Spill $y$: $c_s = 3$.\n    -   Move $x \\to r_2$: $c_m = 1$.\n    -   Move $z \\to r_5$: $c_m = 1$.\n    -   Reload $y$: $c_l = 3$.\n-   **Total Cost:** $(3 + 1 + 1 + 3) \\times N = 8N$. This ignores the loop-invariant nature of $z$ and spills a variable that didn't need to be touched.\n\n**3. Compare Costs and Conclude**\n\n-   Cost(A) = $12N$\n-   Cost(B) = $N + 6$\n-   Cost(C) = $6N + 1$\n-   Cost(D) = $8N$\n\nFor any $N \\ge 1$, we can see that $N+6$ is significantly smaller than $12N$ and $8N$.\nComparing B and C:\n-   If $N=1$, Cost(B) = $1+6=7$ and Cost(C) = $6+1=7$. They are equal.\n-   If $N>1$, $N+6$ grows much slower than $6N+1$. For $N=2$, Cost(B) = $8$ while Cost(C) = $13$.\nStrategy B is optimal or tied for optimal for all $N \\ge 1$. It correctly applies loop-invariant code motion to the handling of $z$ and uses the cheapest available resource (a register move) for the loop-variant variable $x$.", "answer": "$$\\boxed{B}$$", "id": "3667822"}, {"introduction": "Sometimes, a spill is unavoidable due to high register pressure, often caused by specific hardware constraints. This problem presents such a scenario and challenges you to think beyond naive global spilling. You will evaluate a more surgical technique, live-range splitting, which confines memory operations to the smallest necessary code region, drastically reducing performance overhead.", "problem": "Consider a hypothetical Reduced Instruction Set Computer (RISC) architecture with $4$ integer registers $\\{r0, r1, r2, r3\\}$. The Application Binary Interface (ABI) reserves $r0$ for certain fixed roles: it is clobbered by calls and, critically, some instructions require operands and results in $r0$. In particular, the unsigned multiply-high instruction `mulhi`(x, y) requires its first operand in $r0$ and writes its result to $r0$.\n\nA compiler is performing global register allocation on the following straight-line basic block inside a loop. The block has instructions $I_1$ through $I_{10}$ and uses temporaries $\\{p, q, r, w, s, m, t, u, d, g, v\\}$, with data dependencies and uses given by:\n- $I_1$: $p \\leftarrow \\mathrm{load}(P)$\n- $I_2$: $q \\leftarrow \\mathrm{load}(Q)$\n- $I_3$: $r \\leftarrow p + q$\n- $I_4$: $w \\leftarrow r + q$\n- $I_5$: $s \\leftarrow w + p$\n- $I_6$: $t \\leftarrow \\mathrm{mulhi}(s, m)$ with the hardware constraint that at $I_6$ the operand $s$ must be in $r0$, and the result $t$ is produced in $r0$; the second operand $m$ must be in some register (no memory operands for `mulhi`).\n- $I_7$: $u \\leftarrow t + s$\n- $I_8$: $v \\leftarrow u + r$\n- $I_9$: $v \\leftarrow v + d$\n- $I_{10}$: $v \\leftarrow v + g$\n\nAssume $m$ is loaded earlier and only used at $I_6$, and both $d$ and $g$ are defined before $I_6$ and each used after $I_6$ as shown. There are no calls in the block, and no other special instructions. Assume the allocator performs Chaitin-style graph coloring: it builds an interference graph from liveness and tries to color with the available registers; if coloring fails due to register pressure, it spills by inserting stores and loads.\n\nAt $I_6$, the set of values simultaneously live is $\\{s, r, d, g, m\\}$ because $s$ is used at $I_6$ and again at $I_7$, $r$ is used later at $I_8$, $d$ at $I_9$, $g$ at $I_{10}$, and $m$ is used at $I_6$. Due to the pre-coloring at $I_6$, $s$ must be in $r0$, making $r0$ unavailable for any other live value. This leaves only $\\{r1, r2, r3\\}$ for the remaining $4$ live values $\\{r, d, g, m\\}$, guaranteeing at least $1$ spill across $I_6$.\n\nThe compiler must choose a strategy that satisfies the pre-coloring constraint while minimizing extra spill traffic. Which strategy yields a valid allocation that respects the pre-coloring constraint and minimizes additional spill traffic (measured in inserted loads and stores per loop iteration) while keeping semantics unchanged?\n\nA. Spill $r$ globally across its entire live range in the block, i.e., after its definition at $I_3$ insert a store to memory, and insert loads at each of its uses ($I_4$ and $I_8$), keeping $r$ mostly in memory rather than a register.\n\nB. Perform live-range splitting of $r$ around $I_6$: keep $r$ in a register up to just before $I_6$, insert a store of $r$ immediately before $I_6$ to relieve the pressure peak, and insert a single reload of $r$ immediately before $I_8$; elsewhere $r$ remains in a register.\n\nC. Assign $m$ to $r2$ and use a memory operand for $m$ in `mulhi` to avoid occupying a register at $I_6$.\n\nD. Split $s$ around $I_6$ by keeping $s$ in $r2$ before $I_6$, moving $s$ into $r0$ just before $I_6$, and moving it back out after $I_6$, with no spills of other values.", "solution": "The problem describes a classic register allocation scenario where register pressure exceeds available resources at a specific program point, forcing a spill. We must find the most efficient and valid strategy among the given options.\n\n**1. Analyze the Register Pressure Conflict**\n- **Live variables at $I_6$**: The problem correctly identifies the live set as $\\{s, r, d, g, m\\}$, a total of $5$ variables.\n- **Available registers**: We have $4$ registers, $\\{r0, r1, r2, r3\\}$.\n- **Pre-coloring constraint**: For the `mulhi` instruction at $I_6$, variable $s$ must be in $r0$.\n- **Operand constraint**: Variable $m$ must also be in a register.\n- **The conflict**: With $s$ occupying $r0$, we are left with only $3$ registers ($r1, r2, r3$) for the other $4$ live variables $\\{r, d, g, m\\}$. Since $m$ must be in a register, it will take one of these. This leaves only $2$ registers for the remaining $3$ variables $\\{r, d, g\\}$. It is therefore impossible to hold all of them in registers. At least one variable from the set $\\{r, d, g\\}$ must be spilled (stored to memory) across instruction $I_6$.\n\n**2. Evaluate Each Strategy**\n\nThe goal is to resolve this conflict while adding the minimum number of memory operations (stores and loads).\n\n**A. Global spill of $r$.**\n- **Validity:** This strategy resolves the conflict. By spilling $r$ for its entire lifetime, it is removed from the set of variables competing for registers at $I_6$. The remaining variables $\\{s, d, g, m\\}$ can be assigned to the $4$ available registers. This is a valid approach.\n- **Cost:** To implement this, we need to:\n  1. Insert a `store` instruction after $I_3$ (where $r$ is defined).\n  2. Insert a `load` instruction before $I_4$ (first use of $r$).\n  3. Insert another `load` instruction before $I_8$ (second use of $r$).\n- **Total Spill Traffic:** $1$ store + $2$ loads = $3$ memory operations.\n\n**B. Live-range split of $r$ around $I_6$.**\n- **Validity:** This is a more targeted approach. It keeps $r$ in a register where pressure is low and only spills it across the high-pressure region of $I_6$. This is a valid strategy.\n- **Cost:** To implement this, we need to:\n  1. Keep $r$ in a register from its definition at $I_3$ through its use at $I_4$.\n  2. Insert a `store` instruction for $r$ just before $I_6$ to free up its register.\n  3. Insert a `load` instruction for $r$ just before its next use at $I_8$.\n- **Total Spill Traffic:** $1$ store + $1$ load = $2$ memory operations. This approach avoids the unnecessary load before $I_4$ by keeping $r$ in a register for the first part of its life.\n\n**C. Use a memory operand for $m$.**\n- **Validity:** This strategy is explicitly forbidden by the problem statement. The `mulhi` instruction constraint states that \"the second operand $m$ must be in some register (no memory operands for `mulhi`)\".\n- **Verdict:** This strategy is invalid.\n\n**D. Copy $s$ into $r0$ only at $I_6$, without spilling others.**\n- **Validity:** This strategy is based on a false premise. It claims the conflict can be resolved \"without spilling others\". As established in the analysis, there are $5$ variables live at $I_6$ and only $4$ registers. By the pigeonhole principle, at least one variable must be spilled to memory. Moving $s$ around between registers does not change the fact that $5$ values need to be live simultaneously.\n- **Verdict:** This strategy is invalid because its claim is impossible.\n\n**3. Conclusion**\nComparing the valid and costed strategies:\n- Strategy A (Global Spill): $3$ memory operations.\n- Strategy B (Live-Range Split): $2$ memory operations.\n\nStrategy B is more efficient as it confines the spill to the smallest necessary code region, saving one `load` instruction per loop iteration compared to the naive global spill. Therefore, live-range splitting is the optimal choice.", "answer": "$$\\boxed{B}$$", "id": "3667850"}, {"introduction": "Real-world programs are full of branches, meaning the cost of a spill can vary dramatically depending on the execution path taken. This final practice introduces a powerful technique from profile-guided optimization (PGO). You will learn how to use path probabilities to compute the *expected* cost of spilling different variables, allowing you to make an informed, data-driven decision that minimizes the average performance penalty.", "problem": "A compiler for a target with $R$ architectural registers uses global register allocation over a Control Flow Graph (CFG). At a particular program point, the live set size is $L = R + 1$, so exactly one live range must be spilled. The program structure is a single dynamically frequent multiway branch (such as a switch) that creates $3$ disjoint, acyclic paths that reconverge. Profile-guided path probabilities for a single invocation of the function are $p_1 = \\frac{4}{5}$, $p_2 = \\frac{3}{20}$, and $p_3 = \\frac{1}{20}$, which satisfy $p_1 + p_2 + p_3 = 1$ by construction. Three candidate live ranges, denoted $v_A$, $v_B$, and $v_C$, have been identified by liveness analysis as equally spillable from a correctness perspective. However, their dynamic memory-operation counts (the sum of loads and stores caused by the spill and subsequent reloads along a path) differ by path due to differing use densities. Let $c_i(v)$ denote the number of memory operations executed on path $i \\in \\{1,2,3\\}$ if live range $v \\in \\{v_A, v_B, v_C\\}$ is spilled. The measured counts are:\n$$\nc_1(v_A) = 30,\\quad c_2(v_A) = 2,\\quad c_3(v_A) = 1,\n$$\n$$\nc_1(v_B) = 18,\\quad c_2(v_B) = 6,\\quad c_3(v_B) = 6,\n$$\n$$\nc_1(v_C) = 10,\\quad c_2(v_C) = 12,\\quad c_3(v_C) = 12.\n$$\nAssume a single function invocation selects exactly one path $i$ with probability $p_i$, and along that path the chosen spill incurs $c_i(v)$ memory operations deterministically. A path-probability-weighted spill heuristic prefers spilling live ranges whose spill-induced memory operations are biased toward colder paths. Using the definition of expectation for a discrete random variable, derive the expected number of memory operations for each candidate spill and select the candidate that minimizes the expectation under the path-probability-weighted heuristic. For comparison, a naive path-unaware heuristic ignores the profile and uses a uniform average over the $3$ paths to choose the spill.\n\nCompute the ratio of the naive heuristic’s expected number of memory operations to the path-probability-weighted heuristic’s expected number of memory operations, after each heuristic makes its choice. Express the final ratio as a single real number. No rounding is required.", "solution": "**1. Analysis of the Path-Probability-Weighted (Optimal) Heuristic**\n\nThis heuristic chooses the spill candidate that minimizes the expected number of memory operations, $E[C(v)]$. The expectation is the sum of costs on each path weighted by the probability of taking that path:\n$$E[C(v)] = \\sum_{i=1}^{3} p_i \\cdot c_i(v)$$\nGiven probabilities are $p_1 = \\frac{4}{5} = \\frac{16}{20}$, $p_2 = \\frac{3}{20}$, and $p_3 = \\frac{1}{20}$.\n\nFor candidate $v_A$:\n$$E[C(v_A)] = \\left(\\frac{16}{20}\\right)(30) + \\left(\\frac{3}{20}\\right)(2) + \\left(\\frac{1}{20}\\right)(1) = \\frac{480 + 6 + 1}{20} = \\frac{487}{20} = 24.35$$\n\nFor candidate $v_B$:\n$$E[C(v_B)] = \\left(\\frac{16}{20}\\right)(18) + \\left(\\frac{3}{20}\\right)(6) + \\left(\\frac{1}{20}\\right)(6) = \\frac{288 + 18 + 6}{20} = \\frac{312}{20} = 15.6$$\n\nFor candidate $v_C$:\n$$E[C(v_C)] = \\left(\\frac{16}{20}\\right)(10) + \\left(\\frac{3}{20}\\right)(12) + \\left(\\frac{1}{20}\\right)(12) = \\frac{160 + 36 + 12}{20} = \\frac{208}{20} = 10.4$$\n\nComparing the expected costs: $10.4  15.6  24.35$. The optimal heuristic selects $v_C$, as it has the lowest expected cost. The expected cost of this optimal choice is $E_{opt} = E[C(v_C)] = 10.4$.\n\n**2. Analysis of the Naive Path-Unaware Heuristic**\n\nThis heuristic ignores the probabilities and chooses the candidate with the lowest simple average cost, assuming a uniform probability of $p' = \\frac{1}{3}$ for each path.\n$$Avg(v) = \\frac{c_1(v) + c_2(v) + c_3(v)}{3}$$\n\nFor candidate $v_A$:\n$$Avg(v_A) = \\frac{30 + 2 + 1}{3} = \\frac{33}{3} = 11$$\n\nFor candidate $v_B$:\n$$Avg(v_B) = \\frac{18 + 6 + 6}{3} = \\frac{30}{3} = 10$$\n\nFor candidate $v_C$:\n$$Avg(v_C) = \\frac{10 + 12 + 12}{3} = \\frac{34}{3} \\approx 11.33$$\n\nComparing the average costs: $10  11  11.33$. The naive heuristic selects $v_B$, as it has the lowest average cost.\n\nThe question asks for the *actual* expected number of memory operations resulting from the naive heuristic's choice. We must evaluate the true expected cost of spilling $v_B$ using the actual path probabilities. This value was already computed in the first step.\nThe expected cost for the naive heuristic's choice is $E_{naive} = E[C(v_B)] = 15.6$.\n\n**3. Computation of the Ratio**\n\nThe final step is to compute the ratio of the naive heuristic's expected cost to the optimal heuristic's expected cost.\n$$Ratio = \\frac{E_{naive}}{E_{opt}} = \\frac{15.6}{10.4}$$\nUsing the fractional forms for precision:\n$$Ratio = \\frac{312/20}{208/20} = \\frac{312}{208}$$\nSimplifying the fraction:\n$$\\frac{312}{208} = \\frac{156}{104} = \\frac{78}{52} = \\frac{39}{26} = \\frac{3}{2} = 1.5$$\nThe choice made by the naive heuristic is expected to incur $50\\%$ more memory operations than the choice made by the optimal, profile-guided heuristic.", "answer": "$$\\boxed{1.5}$$", "id": "3667851"}]}