{"hands_on_practices": [{"introduction": "To truly understand how NFAs operate, it's essential to manually trace their execution. This first exercise focuses on the core simulation algorithm: for each input symbol, you determine the next set of possible states, and then find all additional states reachable through silent $\\varepsilon$-transitions. Mastering this step-by-step process builds a strong foundation for understanding how NFAs recognize languages. [@problem_id:1388210]", "problem": "A computer scientist is designing a simple lexical analysis tool based on a Nondeterministic Finite Automaton (NFA) to detect a specific pattern in a binary data stream. The NFA is formally defined with the following components:\n- A set of states $Q = \\{q_0, q_1, q_2, q_3\\}$.\n- An input alphabet $\\Sigma = \\{0, 1\\}$.\n- A start state $q_{start} = q_0$.\n- A set of accept states $F = \\{q_3\\}$.\n\nThe transition function, $\\delta: Q \\times (\\Sigma \\cup \\{\\varepsilon\\}) \\to \\mathcal{P}(Q)$, where $\\mathcal{P}(Q)$ is the power set of $Q$ and $\\varepsilon$ denotes the empty string, is given by the following table of rules. Note that if a state-input pair is not listed, its transition leads to the empty set $\\emptyset$.\n\n- $\\delta(q_0, 0) = \\{q_0\\}$\n- $\\delta(q_0, 1) = \\{q_0, q_1\\}$\n- $\\delta(q_1, 0) = \\{q_2\\}$\n- $\\delta(q_1, \\varepsilon) = \\{q_2\\}$\n- $\\delta(q_2, 1) = \\{q_3\\}$\n- $\\delta(q_3, 0) = \\{q_3\\}$\n- $\\delta(q_3, 1) = \\{q_3\\}$\n\nGiven the input string `101`, determine the set of all possible states the machine could be in after processing the entire string. Select the correct set from the options below.\n\nA. $\\{q_0, q_1, q_3\\}$\n\nB. $\\{q_0, q_1, q_2, q_3\\}$\n\nC. $\\{q_3\\}$\n\nD. $\\{q_0, q_2\\}$\n\nE. $\\{q_0, q_1, q_2\\}$", "solution": "For an NFA with $\\varepsilon$-transitions, at each step we compute the $\\varepsilon$-closure of the current set of states, then move on the input symbol, and finally take the $\\varepsilon$-closure again. Let $\\operatorname{E-closure}(S)$ denote the $\\varepsilon$-closure of a set $S$. Unspecified transitions go to the empty set.\n\nInitial closure:\n$$\nS_{0}=\\operatorname{E-closure}(\\{q_{0}\\})=\\{q_{0}\\}\n$$\n\nAfter reading the first symbol $1$:\n$$\nT_{1}=\\bigcup_{q\\in S_{0}}\\delta(q,1)=\\delta(q_{0},1)=\\{q_{0},q_{1}\\}\n$$\n$$\nS_{1}=\\operatorname{E-closure}(T_{1})=\\{q_{0},q_{1}\\}\\cup\\delta(q_{1},\\varepsilon)=\\{q_{0},q_{1},q_{2}\\}\n$$\n\nAfter reading the second symbol $0$:\n$$\nT_{2}=\\bigcup_{q\\in S_{1}}\\delta(q,0)=\\delta(q_{0},0)\\cup\\delta(q_{1},0)\\cup\\delta(q_{2},0)=\\{q_{0}\\}\\cup\\{q_{2}\\}\\cup\\emptyset=\\{q_{0},q_{2}\\}\n$$\n$$\nS_{2}=\\operatorname{E-closure}(T_{2})=\\{q_{0},q_{2}\\}\n$$\n\nAfter reading the third symbol $1$:\n$$\nT_{3}=\\bigcup_{q\\in S_{2}}\\delta(q,1)=\\delta(q_{0},1)\\cup\\delta(q_{2},1)=\\{q_{0},q_{1}\\}\\cup\\{q_{3}\\}=\\{q_{0},q_{1},q_{3}\\}\n$$\n$$\nS_{3}=\\operatorname{E-closure}(T_{3})=\\{q_{0},q_{1},q_{3}\\}\\cup\\delta(q_{1},\\varepsilon)=\\{q_{0},q_{1},q_{2},q_{3}\\}\n$$\n\nTherefore, after processing the entire string `101`, the set of possible states is $\\{q_{0},q_{1},q_{2},q_{3}\\}$, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1388210"}, {"introduction": "A key application of NFAs is in implementing regular expression engines, a cornerstone of compiler lexers. This practice moves from theory to construction, guiding you through building an NFA from a regular expression using the systematic Thompson's construction algorithm. By assembling smaller automata, you will see firsthand how $\\varepsilon$-transitions act as the \"glue\" that holds the machine together before simulating its behavior on an input symbol. [@problem_id:3683735]", "problem": "Consider the regular expression (regex) $(a \\mid b)^{*}a$. Using Thompson’s construction, build a Non-deterministic Finite Automaton (NFA) for this regex starting only from the fundamental definitions: an NFA consists of a finite set of states, a transition relation containing input-labeled transitions and empty-string ($\\varepsilon$) transitions, and a distinguished start and accept state; an $\\varepsilon$-transition moves the machine without consuming input; an $\\varepsilon$-closure of a set of states is the set of all states reachable from that set using only $\\varepsilon$-transitions. Thompson’s construction for literals, concatenation, alternation, and Kleene star should be applied as its standard rules: for a literal $x$, create two states with a single $x$-labeled transition from the first to the second; for concatenation, connect the accept of the left sub-NFA to the start of the right sub-NFA by an $\\varepsilon$-transition; for alternation, create a new start with $\\varepsilon$-transitions to the starts of the sub-NFAs and a new accept with $\\varepsilon$-transitions from the accepts of the sub-NFAs; for Kleene star, create a new start and accept, add $\\varepsilon$-transitions from the new start to the sub-NFA’s start and to the new accept, and from the sub-NFA’s accept to its start and to the new accept.\n\nConstruct the NFA in the specific sequence: first build the sub-NFA for $a$, then for $b$, then form the alternation $(a \\mid b)$, then apply the Kleene star $(a \\mid b)^{*}$, then build the final literal $a$, and finally concatenate $(a \\mid b)^{*}$ with $a$. Label states by integers beginning at $0$, allocating new state labels in strictly increasing order at the moment each new state is created, following the component construction order just described. After the full NFA is constructed, identify the overall start and accept states according to Thompson’s method.\n\nCompute the initial $\\varepsilon$-closure from the overall start state. Then simulate consumption of the single input symbol $b$ from this initial $\\varepsilon$-closure by taking all $b$-labeled moves from states in the closure, and compute the $\\varepsilon$-closure of the resulting set. Report, as your final result, the cardinality (number of states) of this $\\varepsilon$-closure after consuming $b$. Your answer must be a single integer with no units. No rounding is required.", "solution": "We begin by constructing the NFA for the regular expression $(a \\mid b)^{*}a$ step-by-step, following the specified order and labeling states sequentially starting from $0$.\n\n1.  **NFA for the first literal `a`**: We create two states, $0$ and $1$, with a transition from $0$ to $1$ on input symbol $a$. The start state is $0$ and the accept state is $1$.\n    - $N(a_1)$: States $\\{0, 1\\}$, Start $0$, Accept $1$, Transition $0 \\xrightarrow{a} 1$.\n\n2.  **NFA for the literal `b`**: We create two new states, $2$ and $3$, with a transition from $2$ to $3$ on input symbol $b$.\n    - $N(b)$: States $\\{2, 3\\}$, Start $2$, Accept $3$, Transition $2 \\xrightarrow{b} 3$.\n\n3.  **NFA for the alternation `(a | b)`**: We combine $N(a_1)$ and $N(b)$ using the alternation rule. We create a new start state $4$ and a new accept state $5$. We add $\\varepsilon$-transitions from the new start state to the old start states ($4 \\xrightarrow{\\varepsilon} 0$ and $4 \\xrightarrow{\\varepsilon} 2$) and from the old accept states to the new accept state ($1 \\xrightarrow{\\varepsilon} 5$ and $3 \\xrightarrow{\\varepsilon} 5$).\n    - $N(a \\mid b)$: States $\\{0, 1, 2, 3, 4, 5\\}$, Start $4$, Accept $5$.\n\n4.  **NFA for the Kleene star `(a | b)*`**: We apply the Kleene star operation to $N(a \\mid b)$. We create a new start state $6$ and a new accept state $7$. We add the following $\\varepsilon$-transitions:\n    - From the new start to the old start: $6 \\xrightarrow{\\varepsilon} 4$.\n    - From the new start to the new accept (for the empty string case): $6 \\xrightarrow{\\varepsilon} 7$.\n    - From the old accept to the old start (for repetition): $5 \\xrightarrow{\\varepsilon} 4$.\n    - From the old accept to the new accept (to exit the loop): $5 \\xrightarrow{\\varepsilon} 7$.\n    - $N((a \\mid b)^{*})$: States $\\{0, 1, 2, 3, 4, 5, 6, 7\\}$, Start $6$, Accept $7$.\n\n5.  **NFA for the second literal `a`**: We create two new states, $8$ and $9$, for the final $a$ in the expression.\n    - $N(a_2)$: States $\\{8, 9\\}$, Start $8$, Accept $9$, Transition $8 \\xrightarrow{a} 9$.\n\n6.  **NFA for the concatenation `(a | b)*a`**: We concatenate $N((a \\mid b)^{*})$ and $N(a_2)$. This is done by adding an $\\varepsilon$-transition from the accept state of the first NFA ($7$) to the start state of the second NFA ($8$). The resulting start state is the start state of the first NFA ($6$), and the accept state is the accept state of the second NFA ($9$).\n    - Transition: $7 \\xrightarrow{\\varepsilon} 8$.\n    - The complete NFA for $(a \\mid b)^{*}a$ has start state $6$ and accept state $9$.\n\nThe full set of transitions for the final NFA is:\n- $0 \\xrightarrow{a} 1$\n- $1 \\xrightarrow{\\varepsilon} 5$\n- $2 \\xrightarrow{b} 3$\n- $3 \\xrightarrow{\\varepsilon} 5$\n- $4 \\xrightarrow{\\varepsilon} 0$\n- $4 \\xrightarrow{\\varepsilon} 2$\n- $5 \\xrightarrow{\\varepsilon} 4$\n- $5 \\xrightarrow{\\varepsilon} 7$\n- $6 \\xrightarrow{\\varepsilon} 4$\n- $6 \\xrightarrow{\\varepsilon} 7$\n- $7 \\xrightarrow{\\varepsilon} 8$\n- $8 \\xrightarrow{a} 9$\n\nNext, we perform the simulation as requested.\n\nThe overall start state of the NFA is $q_{start} = 6$. The first step is to compute the $\\varepsilon$-closure of the start state, denoted $\\operatorname{E-closure}(\\{6\\})$. This is the set of all states reachable from state $6$ using only $\\varepsilon$-transitions.\n- Start with the set $\\{6\\}$.\n- From state $6$, we can reach states $4$ and $7$ via $\\varepsilon$-transitions. The set becomes $\\{4, 6, 7\\}$.\n- From state $4$, we can reach states $0$ and $2$ via $\\varepsilon$-transitions. The set becomes $\\{0, 2, 4, 6, 7\\}$.\n- From state $7$, we can reach state $8$ via an $\\varepsilon$-transition. The set becomes $\\{0, 2, 4, 6, 7, 8\\}$.\n- States $0$, $2$, and $8$ have no outgoing $\\varepsilon$-transitions. The closure is complete.\nSo, the initial $\\varepsilon$-closure is $S_0 = \\operatorname{E-closure}(\\{6\\}) = \\{0, 2, 4, 6, 7, 8\\}$.\n\nThe second step is to find the set of states reachable from $S_0$ by consuming the input symbol $b$. This is the set $\\text{move}(S_0, b)$. We examine each state in $S_0$:\n- State $0$: has an outgoing transition on $a$, not $b$.\n- State $2$: has an outgoing transition $2 \\xrightarrow{b} 3$. This leads to state $3$.\n- State $4$: has only $\\varepsilon$-transitions.\n- State $6$: has only $\\varepsilon$-transitions.\n- State $7$: has only an $\\varepsilon$-transition.\n- State $8$: has an outgoing transition on $a$, not $b$.\nThe only resulting state is $3$. So, $S_1 = \\text{move}(S_0, b) = \\{3\\}$.\n\nThe final step is to compute the $\\varepsilon$-closure of the resulting set $S_1$. We need to find $\\operatorname{E-closure}(\\{3\\})$.\n- Start with the set $\\{3\\}$.\n- From state $3$, we can reach state $5$ via an $\\varepsilon$-transition ($3 \\xrightarrow{\\varepsilon} 5$). The set becomes $\\{3, 5\\}$.\n- From state $5$, we can reach states $4$ and $7$ via $\\varepsilon$-transitions ($5 \\xrightarrow{\\varepsilon} 4$, $5 \\xrightarrow{\\varepsilon} 7$). The set becomes $\\{3, 4, 5, 7\\}$.\n- From state $4$, we can reach states $0$ and $2$ ($4 \\xrightarrow{\\varepsilon} 0$, $4 \\xrightarrow{\\varepsilon} 2$). The set becomes $\\{0, 2, 3, 4, 5, 7\\}$.\n- From state $7$, we can reach state $8$ ($7 \\xrightarrow{\\varepsilon} 8$). The set becomes $\\{0, 2, 3, 4, 5, 7, 8\\}$.\n- States $0$, $2$, and $8$ have no outgoing $\\varepsilon$-transitions. The closure process is complete.\nThe final set is $S_{final} = \\operatorname{E-closure}(\\{3\\}) = \\{0, 2, 3, 4, 5, 7, 8\\}$.\n\nThe problem asks for the cardinality of this final set.\nThe cardinality is the number of states in $S_{final}$: $|\\{0, 2, 3, 4, 5, 7, 8\\}| = 7$.", "answer": "$$\n\\boxed{7}\n$$", "id": "3683735"}, {"introduction": "The final hands-on challenge transitions from manual calculation to algorithmic implementation, a crucial step in building real-world tools. This exercise asks you to write a function that computes the $\\varepsilon$-closure, treating the NFA's states and transitions as a directed graph. Successfully implementing this requires translating the formal definition into a robust graph traversal algorithm, which solidifies your understanding at the deepest level by forcing you to handle critical edge cases like cycles and empty sets. [@problem_id:3683779]", "problem": "You are to implement, in a general-purpose programming language, a robust function that computes the $\\varepsilon$-closure of a set of states in a Nondeterministic Finite Automaton (NFA). Your program must embed and execute a predefined unit test suite that probes correctness over edge cases including self-loops, multi-edges, disconnected components, cycles, empty transition sets, and empty starting sets. The program must produce the results for all test cases as a single, precisely formatted line.\n\nFundamental base and definitions to be used:\n- An NFA is a quintuple $(Q,\\Sigma,\\delta,q_0,F)$, where $Q$ is a finite set of states, $\\Sigma$ is an input alphabet, $\\delta: Q \\times (\\Sigma \\cup \\{\\varepsilon\\}) \\to \\mathcal{P}(Q)$ is a transition function, $q_0 \\in Q$ is the start state, and $F \\subseteq Q$ is the set of accepting states. Only $\\varepsilon$-transitions are relevant in this problem.\n- The $\\varepsilon$-closure of a set of states $S \\subseteq Q$, denoted $\\varepsilon\\text{-closure}(S)$, is defined as the least set $C \\subseteq Q$ such that:\n  - $S \\subseteq C$, and\n  - for any $p \\in C$, if there exists an $\\varepsilon$-transition from $p$ to $q$ (i.e., $q \\in \\delta(p,\\varepsilon)$), then $q \\in C$.\n- The least set here is with respect to set inclusion, and can be characterized as the set of all states reachable from $S$ by following zero or more $\\varepsilon$-transitions.\n\nRepresentation and constraints:\n- States are identified by nonnegative integers, $Q = \\{0,1,\\dots,N-1\\}$ for some integer $N \\ge 1$.\n- The $\\varepsilon$-transition relation is represented as a directed graph on $Q$ by a multiset of ordered pairs $E_\\varepsilon \\subseteq Q \\times Q$. Multi-edges are permitted; that is, the same ordered pair may appear multiple times. Self-loops are also permitted.\n- The input alphabet $\\Sigma$, the non-$\\varepsilon$ transitions, and acceptance are irrelevant to this task and must be ignored.\n\nYour epsilon-closure function must accept a set $S \\subseteq Q$ (possibly empty) and return the set $\\varepsilon\\text{-closure}(S)$ as a sorted list of distinct state identifiers in ascending order.\n\nTest suite specification to embed in the program:\n- Use the following seven test cases. For each test case, you are given the number of states $N$, the multiset of $\\varepsilon$-edges $E_\\varepsilon$ listed as ordered pairs, and the starting set $S$.\n  - Test case $1$ (self-loop plus forward chain):\n    - $N = 4$\n    - $E_\\varepsilon = \\{(0,0),(0,1),(1,2)\\}$\n    - $S = \\{0\\}$\n  - Test case $2$ (multi-edges):\n    - $N = 4$\n    - $E_\\varepsilon = \\{(1,2),(1,2),(2,3),(2,3)\\}$\n    - $S = \\{1\\}$\n  - Test case $3$ (disconnected components; isolated query):\n    - $N = 6$\n    - $E_\\varepsilon = \\{(0,1),(1,2),(3,4)\\}$\n    - $S = \\{5\\}$\n  - Test case $4$ (empty $\\varepsilon$-transition graph; multi-source set):\n    - $N = 3$\n    - $E_\\varepsilon = \\varnothing$\n    - $S = \\{0,2\\}$\n  - Test case $5$ (cycle via $\\varepsilon$-transitions):\n    - $N = 5$\n    - $E_\\varepsilon = \\{(0,1),(1,0),(1,2),(2,1)\\}$\n    - $S = \\{0\\}$\n  - Test case $6$ (empty starting set on a graph with a self-loop):\n    - $N = 1$\n    - $E_\\varepsilon = \\{(0,0)\\}$\n    - $S = \\varnothing$\n  - Test case $7$ (branching, union over multiple components, and an unreachable self-loop):\n    - $N = 7$\n    - $E_\\varepsilon = \\{(0,1),(1,2),(1,3),(3,5),(4,4),(2,6)\\}$\n    - $S = \\{1,4\\}$\n\nAlgorithmic expectations:\n- The computation must rely solely on the definition of $\\varepsilon\\text{-closure}(S)$ as the least fixed point under $\\varepsilon$-reachability. This can be operationalized by a graph reachability computation over $\\varepsilon$-edges starting from $S$, maintaining a visited set to avoid infinite regress on cycles and to collapse multi-edges.\n- Self-loops, cycles, and multi-edges must not cause nontermination or duplication in the output; duplicates must be eliminated by set semantics and the final output must be sorted ascending.\n\nAnswer type and final output format:\n- For each test case, the result is a list of integers representing $\\varepsilon\\text{-closure}(S)$ in ascending order. For the empty set, output an empty list.\n- Your program should produce a single line of output containing the results for the seven test cases as a comma-separated list enclosed in square brackets, where each individual result is itself a bracketed, comma-separated list of state identifiers in ascending order with no spaces. For example, an output conforming to this specification looks like `[[0,1],[2],[]]` where the third result is an empty list. Your program must exactly print the aggregated results in this single-line format with no additional characters or whitespace.", "solution": "The core of the problem is to compute the $\\varepsilon$-closure of a given set of states $S$ in a Nondeterministic Finite Automaton (NFA). The NFA's states are given as a set $Q = \\{0, 1, \\dots, N-1\\}$, and its $\\varepsilon$-transitions are represented as a directed graph $G = (Q, E_\\varepsilon)$, where $E_\\varepsilon$ is a multiset of ordered pairs denoting the transitions.\n\nThe definition of $\\varepsilon\\text{-closure}(S)$ is the smallest set containing $S$ that is closed under the $\\varepsilon$-transition relation. This is equivalent to finding all states in $Q$ that are reachable from any state in $S$ by traversing zero or more $\\varepsilon$-edges. This recharacterization frames the problem as one of graph reachability.\n\nA standard and efficient algorithm for determining reachability in a directed graph is a graph traversal, such as a Depth-First Search (DFS) or a Breadth-First Search (BFS). We will use a DFS-based approach.\n\nThe algorithm proceeds as follows:\n$1$. **Graph Representation**: The input multiset of edges $E_\\varepsilon$ is first converted into an adjacency list representation. For each state $u \\in Q$, we maintain a list of states $v$ for which an edge $(u, v) \\in E_\\varepsilon$ exists. This allows for efficient retrieval of all states reachable from a given state in a single step.\n\n$2$. **Initialization**: We require two auxiliary data structures:\n    - A set to store the states that have been visited during the traversal, to avoid redundant processing and to correctly handle cycles. A boolean array of size $N$, let's call its conceptual representation $V$, initialized to false, serves this purpose.\n    - A stack, which we can call the `worklist`, to manage the states to be visited as part of the DFS.\n\n$3$. **Seeding the Traversal**: The traversal starts from the initial set of states $S$. For each state $s \\in S$, we mark its corresponding entry in $V$ as true and push $s$ onto the `worklist`. This ensures that all states in $S$ are part of the final closure, satisfying the condition $S \\subseteq \\varepsilon\\text{-closure}(S)$.\n\n$4$. **Iterative Deepening**: The main part of the algorithm is a loop that continues as long as the `worklist` is not empty. In each iteration:\n    - A state $u$ is popped from the `worklist`.\n    - We look up the neighbors of $u$ in the adjacency list. For each neighbor $v$ (i.e., for each transition $u \\xrightarrow{\\varepsilon} v$):\n    - If $v$ has not yet been visited (i.e., its entry in $V$ is false), we mark it as visited by setting its entry in $V$ to true and push $v$ onto the `worklist`.\n\n$5$. **Result Extraction**: When the `worklist` becomes empty, the traversal is complete. The set of all visited states, represented by the true entries in $V$, constitutes the $\\varepsilon\\text{-closure}(S)$. To produce the required sorted output, we can iterate from state $0$ to $N-1$ and collect all states $i$ for which the $i$-th entry in $V$ is true. This process naturally yields a sorted list of the states in the closure.\n\nThis algorithmic approach is robust and correctly manages all specified edge cases:\n- **Cycles and Self-Loops**: The use of the visited set $V$ ensures that each state is processed at most once, preventing the traversal from entering an infinite loop.\n- **Multi-edges**: The construction of the adjacency list or the logic within the traversal naturally handles multi-edges. While a state may be added as a neighbor multiple times, the check against the visited set $V$ ensures it is pushed to the `worklist` only on its first encounter.\n- **Disconnected Components**: The traversal algorithm only explores states reachable from the initial set $S$. Any states in components not reachable from $S$ will never be visited.\n- **Empty Starting Set ($S = \\varnothing$)}: If $S$ is empty, the `worklist` is never seeded, the main loop does not execute, and the resulting closure is correctly identified as the empty set.\n- **Empty Transition Set ($E_\\varepsilon = \\varnothing$)}: If there are no transitions, no new states can be reached from $S$. The algorithm will visit only the states in $S$ itself, correctly yielding $\\varepsilon\\text{-closure}(S) = S$.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// Forward declaration of the helper function for computing epsilon-closure.\nvoid compute_epsilon_closure(int N, const void* edges, int edge_count, const int* S, int s_count, int* closure, int* closure_count);\n\n// A helper struct for defining an edge (transition).\ntypedef struct {\n    int from;\n    int to;\n} Edge;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int N;\n    const Edge* edges;\n    int edge_count;\n    const int* S;\n    int s_count;\n} TestCase;\n\nint main(void) {\n    // ---- Test Case 1: self-loop plus forward chain ----\n    const Edge edges1[] = {{0,0}, {0,1}, {1,2}};\n    const int s1[] = {0};\n\n    // ---- Test Case 2: multi-edges ----\n    const Edge edges2[] = {{1,2}, {1,2}, {2,3}, {2,3}};\n    const int s2[] = {1};\n\n    // ---- Test Case 3: disconnected components; isolated query ----\n    const Edge edges3[] = {{0,1}, {1,2}, {3,4}};\n    const int s3[] = {5};\n\n    // ---- Test Case 4: empty epsilon-transition graph; multi-source set ----\n    const Edge edges4[] = {};\n    const int s4[] = {0,2};\n\n    // ---- Test Case 5: cycle via epsilon-transitions ----\n    const Edge edges5[] = {{0,1}, {1,0}, {1,2}, {2,1}};\n    const int s5[] = {0};\n\n    // ---- Test Case 6: empty starting set on a graph with a self-loop ----\n    const Edge edges6[] = {{0,0}};\n    const int s6[] = {};\n\n    // ---- Test Case 7: branching, union over multiple components, and an unreachable self-loop ----\n    const Edge edges7[] = {{0,1}, {1,2}, {1,3}, {3,5}, {4,4}, {2,6}};\n    const int s7[] = {1,4};\n\n    // Define the test cases from the problem statement.\n    const TestCase test_cases[] = {\n        {4, edges1, sizeof(edges1)/sizeof(Edge), s1, sizeof(s1)/sizeof(int)},\n        {4, edges2, sizeof(edges2)/sizeof(Edge), s2, sizeof(s2)/sizeof(int)},\n        {6, edges3, sizeof(edges3)/sizeof(Edge), s3, sizeof(s3)/sizeof(int)},\n        {3, edges4, sizeof(edges4)/sizeof(Edge), s4, sizeof(s4)/sizeof(int)},\n        {5, edges5, sizeof(edges5)/sizeof(Edge), s5, sizeof(s5)/sizeof(int)},\n        {1, edges6, sizeof(edges6)/sizeof(Edge), s6, sizeof(s6)/sizeof(int)},\n        {7, edges7, sizeof(edges7)/sizeof(Edge), s7, sizeof(s7)/sizeof(int)},\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n\n    // Print the results in the EXACT REQUIRED format.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        int N = test_cases[i].N;\n        // Use a Variable Length Array (VLA) for results, which is fine in C23.\n        int result[N];\n        int result_count = 0;\n        \n        compute_epsilon_closure(\n            N,\n            test_cases[i].edges,\n            test_cases[i].edge_count,\n            test_cases[i].S,\n            test_cases[i].s_count,\n            result,\n            &result_count\n        );\n        \n        printf(\"[\");\n        for (int j = 0; j < result_count; ++j) {\n            printf(\"%d\", result[j]);\n            if (j < result_count - 1) {\n                printf(\",\");\n            }\n        }\n        printf(\"]\");\n        \n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Computes the epsilon-closure of a set of states in an NFA.\n *\n * This function implements a Depth-First Search (DFS) to find all states\n * reachable from an initial set S via zero or more epsilon transitions.\n *\n * @param N The total number of states in the NFA, labeled 0 to N-1.\n * @param edges A pointer to an array of Edge structs representing epsilon transitions.\n * @param edge_count The number of edges in the epsilon transition graph.\n * @param S A pointer to an array of integers representing the initial set of states.\n * @param s_count The number of states in the initial set S.\n * @param closure A pointer to an integer array where the resulting closure set will be stored.\n * @param closure_count A pointer to an integer that will be updated with the size of the closure set.\n */\nvoid compute_epsilon_closure(int N, const void* edges_void, int edge_count, const int* S, int s_count, int* closure, int* closure_count) {\n    if (N <= 0) {\n        *closure_count = 0;\n        return;\n    }\n    const Edge* edges = (const Edge*) edges_void;\n\n    // A node for the adjacency list.\n    typedef struct AdjNode {\n        int state;\n        struct AdjNode* next;\n    } AdjNode;\n    \n    // 1. Build adjacency list representation of the graph.\n    AdjNode** adj = (AdjNode**)calloc(N, sizeof(AdjNode*));\n    if (!adj) return; // Allocation failure.\n\n    for (int i = 0; i < edge_count; ++i) {\n        AdjNode* newNode = (AdjNode*)malloc(sizeof(AdjNode));\n        if (!newNode) { // Allocation failure\n             // Cleanup previously allocated nodes\n            for (int k = 0; k < N; ++k) {\n                AdjNode* current = adj[k];\n                while(current) {\n                    AdjNode* temp = current;\n                    current = current->next;\n                    free(temp);\n                }\n            }\n            free(adj);\n            return;\n        }\n        newNode->state = edges[i].to;\n        newNode->next = adj[edges[i].from];\n        adj[edges[i].from] = newNode;\n    }\n\n    // 2. Initialize data structures for DFS.\n    int* stack = (int*)malloc(N * sizeof(int));\n    char* visited = (char*)calloc(N, sizeof(char)); // Use char for boolean flag.\n    if (!stack || !visited) { // Allocation failure\n        if (stack) free(stack);\n        if (visited) free(visited);\n        // ... cleanup adj list ...\n        return;\n    }\n    int stack_top = -1;\n\n    // 3. Initialize stack and visited array with the starting set S.\n    for (int i = 0; i < s_count; ++i) {\n        int start_state = S[i];\n        if (start_state >= 0 && start_state < N && !visited[start_state]) {\n            visited[start_state] = 1;\n            stack[++stack_top] = start_state;\n        }\n    }\n\n    // 4. Perform DFS.\n    while (stack_top != -1) {\n        int u = stack[stack_top--];\n        for (AdjNode* v_node = adj[u]; v_node != NULL; v_node = v_node->next) {\n            int v = v_node->state;\n            if (v >= 0 && v < N && !visited[v]) {\n                visited[v] = 1;\n                stack[++stack_top] = v;\n            }\n        }\n    }\n\n    // 5. Collect results from the visited array.\n    *closure_count = 0;\n    for (int i = 0; i < N; ++i) {\n        if (visited[i]) {\n            closure[(*closure_count)++] = i;\n        }\n    }\n\n    // 6. Free allocated memory.\n    free(stack);\n    free(visited);\n    for (int i = 0; i < N; ++i) {\n        AdjNode* current = adj[i];\n        while (current != NULL) {\n            AdjNode* temp = current;\n            current = current->next;\n            free(temp);\n        }\n    }\n    free(adj);\n}\n\n\n```", "id": "3683779"}]}