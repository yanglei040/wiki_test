{"hands_on_practices": [{"introduction": "Understanding the theory of microprogramming is one thing; designing the hardware that enables it is another. This first exercise challenges you to create a blueprint for a control store, the specialized memory that houses the microcode.\n\nBy translating the control signals of a given datapath into a concrete microinstruction format, you will calculate the control store's essential dimensions—its width and depth—providing a tangible link between abstract control logic and its physical implementation [@problem_id:3660292].", "problem": "You are asked to design a microprogrammed control store for a multi-cycle processor datapath implementing a 32-instruction Instruction Set Architecture (ISA). The microcode encoding must ensure one-hot control for all multiplexer selections and explicit single-bit strobes for loads and writes. Use the following scientifically grounded base assumptions about microprogrammed control and multi-cycle datapaths: a microinstruction is a fixed-width word whose bits directly gate control signals; one-hot encoding for a $k$-way selector uses $k$ distinct control lines such that exactly one is asserted to choose a source; and the control store depth equals the number of distinct microinstructions required to implement the instruction sequences under the chosen microcode organization.\n\nThe datapath has these control points, each of which must be represented in the microinstruction under a one-hot or strobe convention as specified:\n\n- Memory address source selector $\\mathrm{IorD}$: $2$ options $\\{ \\mathrm{PC}, \\mathrm{ALUOut} \\}$, encoded one-hot with $2$ lines.\n- Arithmetic Logic Unit (ALU) input A selector $\\mathrm{ALUSrcA}$: $2$ options $\\{ \\mathrm{PC}, \\mathrm{A} \\}$, encoded one-hot with $2$ lines.\n- Arithmetic Logic Unit (ALU) input B selector $\\mathrm{ALUSrcB}$: $4$ options $\\{ \\mathrm{B}, \\mathrm{const}\\ 4, \\mathrm{Imm}, \\mathrm{Imm}\\ll 2 \\}$, encoded one-hot with $4$ lines.\n- Program Counter source selector $\\mathrm{PCSource}$: $3$ options $\\{ \\mathrm{ALUResult}, \\mathrm{ALUOut}, \\mathrm{JumpAddr} \\}$, encoded one-hot with $3$ lines.\n- Register destination selector $\\mathrm{RegDst}$: $3$ options $\\{ rt, rd, r_{31} \\}$, encoded one-hot with $3$ lines.\n- Register write-back data selector $\\mathrm{MemtoReg}$: $3$ options $\\{ \\mathrm{ALUResult}, \\mathrm{MDR}, \\mathrm{PC}+4 \\}$, encoded one-hot with $3$ lines.\n- ALU operation control $\\mathrm{ALUOp}$: $8$ one-hot lines for the implemented ALU functions.\n- Immediate extension selector $\\mathrm{ExtOp}$: $2$ options $\\{ \\mathrm{sign\\ extend}, \\mathrm{zero\\ extend} \\}$, encoded one-hot with $2$ lines.\n- Single-bit strobes: $\\mathrm{IRWrite}$, $\\mathrm{PCWrite}$, $\\mathrm{PCWriteCond}$, $\\mathrm{MemRead}$, $\\mathrm{MemWrite}$, $\\mathrm{RegWrite}$, $\\mathrm{MDRWrite}$, $\\mathrm{AWrite}$, $\\mathrm{BWrite}$, $\\mathrm{ALUOutWrite}$, each a single control bit, totaling $10$ bits.\n\nAssume a simple microprogram organization in which each instruction has its own microsequence that includes its fetch and decode steps (no subroutine sharing or compression). The ISA is partitioned into classes with the following counts and cycle requirements per instruction:\n\n- $10$ register-type ALU instructions: $4$ cycles each.\n- $6$ immediate-type ALU instructions: $3$ cycles each.\n- $5$ load instructions: $5$ cycles each.\n- $3$ store instructions: $4$ cycles each.\n- $4$ conditional branch instructions: $3$ cycles each.\n- $3$ jump instructions (no link): $2$ cycles each.\n- $1$ jump-and-link instruction: $3$ cycles.\n\nTasks:\n\n1. Propose a concrete microinstruction format consistent with the above control points and one-hot requirements by listing the fields and their bit widths.\n2. Using first principles of microprogrammed control, determine the control store width (in bits) and the control store depth (in microinstructions).\n3. Compute the total number of bits stored in the control store as the product of the width and the depth.\n\nExpress the final total control store size as a single number of bits. No rounding is required. The final answer must be a single real-valued number. State any symbols inside $...$ and ensure every number appears in LaTeX. Do not include units inside the boxed final answer; however, interpret the value as bits.", "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n-   Instruction Set Architecture (ISA) size: $32$ instructions.\n-   Control signal encoding: one-hot for all multiplexer selections, single-bit strobes for loads and writes.\n-   Microprogram organization: Each instruction has its own microsequence, including fetch and decode. No subroutine sharing or compression.\n-   Control store depth is the total number of distinct microinstructions.\n-   Control Points and Encoding:\n    -   $\\mathrm{IorD}$ (Memory address selector): $2$ options, one-hot ($2$ bits).\n    -   $\\mathrm{ALUSrcA}$ (ALU input A selector): $2$ options, one-hot ($2$ bits).\n    -   $\\mathrm{ALUSrcB}$ (ALU input B selector): $4$ options, one-hot ($4$ bits).\n    -   $\\mathrm{PCSource}$ (PC source selector): $3$ options, one-hot ($3$ bits).\n    -   $\\mathrm{RegDst}$ (Register destination selector): $3$ options, one-hot ($3$ bits).\n    -   $\\mathrm{MemtoReg}$ (Register write-back data selector): $3$ options, one-hot ($3$ bits).\n    -   $\\mathrm{ALUOp}$ (ALU operation control): $8$ one-hot lines ($8$ bits).\n    -   $\\mathrm{ExtOp}$ (Immediate extension selector): $2$ options, one-hot ($2$ bits).\n    -   Strobes: $\\mathrm{IRWrite}$, $\\mathrm{PCWrite}$, $\\mathrm{PCWriteCond}$, $\\mathrm{MemRead}$, $\\mathrm{MemWrite}$, $\\mathrm{RegWrite}$, $\\mathrm{MDRWrite}$, $\\mathrm{AWrite}$, $\\mathrm{BWrite}$, $\\mathrm{ALUOutWrite}$. A total of $10$ single-bit strobes ($10$ bits).\n-   ISA Partition and Cycle Counts:\n    -   $10$ register-type ALU instructions at $4$ cycles each.\n    -   $6$ immediate-type ALU instructions at $3$ cycles each.\n    -   $5$ load instructions at $5$ cycles each.\n    -   $3$ store instructions at $4$ cycles each.\n    -   $4$ conditional branch instructions at $3$ cycles each.\n    -   $3$ jump instructions at $2$ cycles each.\n    -   $1$ jump-and-link instruction at $3$ cycles.\n-   The sum of instructions is $10 + 6 + 5 + 3 + 4 + 3 + 1 = 32$, which is consistent with the stated ISA size.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria.\n-   **Scientifically Grounded**: The problem is a standard exercise in computer organization and architecture, dealing with the design of a microprogrammed control unit for a multi-cycle datapath. All concepts, such as one-hot encoding, control stores, and multi-cycle execution, are fundamental to the field. The setup is scientifically and technically sound.\n-   **Well-Posed**: The problem provides a complete and consistent set of specifications to uniquely determine the width, depth, and total size of the control store. The tasks are clearly defined, and a unique solution can be derived from the givens.\n-   **Objective**: The problem is stated in precise, technical language, free of subjectivity or ambiguity. The encoding schemes and datapath components are explicitly defined.\n-   **Completeness**: All necessary information is provided. The number of options for each multiplexer, the encoding scheme, the list of all control signals, and the instruction breakdown with cycle counts are all explicitly given. The problem does not require any external information or unstated assumptions, apart from the ones explicitly provided as the basis for the design. The assumption of \"no sharing\" of microcode sequences, while a simplification, is clearly stated and makes the problem tractable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-defined, self-contained, and scientifically sound problem in computer architecture. The solution process can proceed.\n\n### Solution Derivation\n\nThe solution is derived by addressing the three tasks in order: calculating the microinstruction width, the control store depth, and finally, their product.\n\n**Task 1  2: Control Store Width and Depth**\n\nFirst, the width of the control store, which is equivalent to the width of a single microinstruction, is determined. The problem specifies that the microinstruction word's bits directly gate the datapath control signals. The total width is the sum of bits required for each control field.\n\n-   $\\mathrm{IorD}$ (2-way MUX, one-hot): $2$ bits\n-   $\\mathrm{ALUSrcA}$ (2-way MUX, one-hot): $2$ bits\n-   $\\mathrm{ALUSrcB}$ (4-way MUX, one-hot): $4$ bits\n-   $\\mathrm{PCSource}$ (3-way MUX, one-hot): $3$ bits\n-   $\\mathrm{RegDst}$ (3-way MUX, one-hot): $3$ bits\n-   $\\mathrm{MemtoReg}$ (3-way MUX, one-hot): $3$ bits\n-   $\\mathrm{ALUOp}$ (8 functions, one-hot): $8$ bits\n-   $\\mathrm{ExtOp}$ (2-way MUX, one-hot): $2$ bits\n-   Strobes ($10$ individual signals): $10 \\times 1 = 10$ bits\n\nThe total width, $W$, of a microinstruction is the sum of these bit-widths:\n$$W = 2 + 2 + 4 + 3 + 3 + 3 + 8 + 2 + 10 = 37 \\text{ bits}$$\n\nNext, the depth of the control store is determined. The depth is the total number of unique microinstructions. The problem specifies a \"simple microprogram organization in which each instruction has its own microsequence that includes its fetch and decode steps (no subroutine sharing or compression).\" This means the total number of states (microinstructions) is the sum of the cycle counts for every instruction in the ISA.\n\n-   Register-type ALU instructions: $10 \\text{ instructions} \\times 4 \\text{ cycles/instruction} = 40$ microinstructions.\n-   Immediate-type ALU instructions: $6 \\text{ instructions} \\times 3 \\text{ cycles/instruction} = 18$ microinstructions.\n-   Load instructions: $5 \\text{ instructions} \\times 5 \\text{ cycles/instruction} = 25$ microinstructions.\n-   Store instructions: $3 \\text{ instructions} \\times 4 \\text{ cycles/instruction} = 12$ microinstructions.\n-   Conditional branch instructions: $4 \\text{ instructions} \\times 3 \\text{ cycles/instruction} = 12$ microinstructions.\n-   Jump instructions: $3 \\text{ instructions} \\times 2 \\text{ cycles/instruction} = 6$ microinstructions.\n-   Jump-and-link instruction: $1 \\text{ instruction} \\times 3 \\text{ cycles/instruction} = 3$ microinstructions.\n\nThe total depth, $D$, of the control store is the sum of these microinstruction counts:\n$$D = 40 + 18 + 25 + 12 + 12 + 6 + 3 = 116 \\text{ microinstructions}$$\n\n**Task 3: Total Control Store Size**\n\nThe total number of bits in the control store is the product of its width ($W$) and depth ($D$).\n\n$$ \\text{Total Size} = W \\times D $$\n$$ \\text{Total Size} = 37 \\text{ bits} \\times 116 $$\n$$ \\text{Total Size} = 4292 \\text{ bits} $$\n\nThus, the control store requires a total of $4292$ bits.\nThe microinstruction format consists of fields for `IorD` ($2$ bits), `ALUSrcA` ($2$ bits), `ALUSrcB` ($4$ bits), `PCSource` ($3$ bits), `RegDst` ($3$ bits), `MemtoReg` ($3$ bits), `ALUOp` ($8$ bits), `ExtOp` ($2$ bits), and $10$ strobe bits, totaling a width of $37$ bits. The control store depth is $116$ microinstructions. The total size is the product of these two values.", "answer": "$$ \\boxed{4292} $$", "id": "3660292"}, {"introduction": "With a control store designed, the focus shifts to writing efficient microcode to maximize processor performance. This practice delves into loop unrolling, a classic optimization technique used to reduce dynamic instruction counts at the expense of a larger static code footprint.\n\nYou will mathematically model this fundamental speed-versus-space trade-off, tasked with finding an optimal unroll factor `$u$` that minimizes execution time while adhering to a strict memory budget [@problem_id:3659448].", "problem": "A microprogrammed control unit implements a single Complex Instruction Set Computer (CISC) machine instruction that copies a fixed-size block of memory using a micro-operation (micro-op) loop. The control store contains a sequence of microinstructions that are executed by the control unit, and each microinstruction consumes exactly one processor clock cycle. Therefore, the Cycles Per Instruction (CPI) for this machine instruction equals the total number of microinstructions dynamically executed when the instruction runs once. The static control store size for this microcode equals the microinstruction word width multiplied by the number of microinstructions stored.\n\nConsider the following baseline for the loop-based microcode implementation:\n- The microinstruction word width is $w = 64$ bits.\n- The loop body performs $p = 5$ microinstructions per iteration for the data move and address update work.\n- The loop control overhead per iteration (decrement counter, test, and branch) is $h = 3$ microinstructions.\n- The fixed setup overhead before the loop is $s = 12$ microinstructions, and the fixed teardown after the loop is $f = 8$ microinstructions.\n- The total number of iterations required to complete the block move is $T = 240$.\n\nTo reduce dynamic loop control overhead, the micro-op loop is unrolled by a factor $u$, meaning $u$ copies of the loop body are laid out contiguously in the control store and executed per single loop control check. Under this unrolling:\n- The loop control overhead $h$ is incurred once per $u$ consecutive body copies.\n- The static code size of the unrolled loop group equals the $u$ replicated body copies plus one set of loop control microinstructions.\n\nAssume that the microcode for this instruction must fit within a dedicated control store budget $M_{\\max} = 64 \\times 83$ bits. The unroll factor $u$ must be a positive integer and must divide $T$ exactly so that the loop executes an integer number of unrolled groups with no remainder iterations.\n\nStarting from the definitions above and the one-cycle-per-microinstruction model, derive the dynamic microinstruction count $D(u)$ for executing the instruction once and the static control store size $M(u)$ in bits. Then, choosing $u$ to minimize $D(u)$ subject to the constraints $M(u) \\leq M_{\\max}$ and $u \\mid T$, compute:\n- The selected unroll factor $u$,\n- The resulting CPI for the instruction (equal to $D(u)$),\n- The resulting control store size $M(u)$.\n\nExpress the control store size in bits. No rounding is required. Provide the final answer as three values in the order $u$, CPI, and control store size $M(u)$.", "solution": "The problem is well-posed, scientifically grounded in computer architecture principles, and contains all necessary information for a unique solution. Therefore, it is valid.\n\nThe objective is to find the optimal loop unroll factor $u$ that minimizes the dynamic microinstruction count $D(u)$ for a block move instruction, subject to constraints on the static control store size $M(u)$ and the properties of $u$.\n\nFirst, we derive the expressions for the dynamic microinstruction count $D(u)$ and the static control store size $M(u)$.\n\nThe dynamic microinstruction count, which is equivalent to the Cycles Per Instruction (CPI), is the sum of the microinstructions for setup, loop execution, and teardown.\nThe given parameters are:\n- Setup overhead: $s = 12$ microinstructions\n- Teardown overhead: $f = 8$ microinstructions\n- Total original iterations: $T = 240$\n- Micro-ops per loop body: $p = 5$\n- Micro-ops for loop control: $h = 3$\n- Unroll factor: $u$\n\nThe total number of dynamic microinstructions $D(u)$ is given by:\n$$D(u) = s + (\\text{loop execution}) + f$$\nThe loop is unrolled by a factor of $u$. This means the body of the loop is replicated $u$ times, and the loop control logic (decrement, test, branch) is executed only once for every $u$ data moves. Since the total number of data moves is $T$, the number of times the unrolled loop group executes is $\\frac{T}{u}$. Each execution of the unrolled group consists of $u$ copies of the loop body work and one instance of the loop control overhead.\nThe number of microinstructions for one unrolled group is $(u \\cdot p + h)$.\nThus, the total microinstructions for the loop execution part is:\n$$(\\text{loop execution}) = \\left(\\frac{T}{u}\\right) \\cdot (u \\cdot p + h)$$\nExpanding this term, we get:\n$$(\\text{loop execution}) = \\frac{T}{u} \\cdot u \\cdot p + \\frac{T \\cdot h}{u} = T \\cdot p + \\frac{T \\cdot h}{u}$$\nSubstituting this back into the expression for $D(u)$:\n$$D(u) = s + f + T \\cdot p + \\frac{T \\cdot h}{u}$$\nTo minimize $D(u)$, we observe that $s$, $f$, $T$, $p$, and $h$ are positive constants. The term $(s + f + T \\cdot p)$ is constant with respect to $u$. Therefore, minimizing $D(u)$ is equivalent to minimizing the term $\\frac{T \\cdot h}{u}$, which requires maximizing the unroll factor $u$.\n\nNext, we derive the expression for the static control store size $M(u)$. The size is the total number of static microinstructions multiplied by the word width $w = 64$ bits. The static microcode for the entire instruction includes the setup code, the single unrolled loop body, and the teardown code.\nThe number of static microinstructions is the sum of:\n- Setup microinstructions: $s$\n- Unrolled loop microinstructions: $u \\cdot p + h$\n- Teardown microinstructions: $f$\nTotal static microinstructions = $s + f + u \\cdot p + h$.\nThe static control store size $M(u)$ in bits is:\n$$M(u) = w \\cdot (s + f + u \\cdot p + h)$$\nThis is a linear function of $u$.\n\nThe problem specifies two constraints on $u$:\n1. $u$ must be a positive integer that divides the total number of iterations $T=240$ exactly. So, $u \\in \\{1, 2, 3, 4, 5, 6, 8, 10, 12, 15, 16, 20, 24, 30, 40, 48, 60, 80, 120, 240\\}$.\n2. The static control store size $M(u)$ must not exceed the budget $M_{\\max} = 64 \\times 83$ bits.\n$$M(u) \\leq M_{\\max}$$\n$$w \\cdot (s + f + u \\cdot p + h) \\leq M_{\\max}$$\nWe substitute the given values: $w=64$, $s=12$, $f=8$, $p=5$, $h=3$, and $M_{\\max} = 64 \\times 83 = 5312$.\n$$64 \\cdot (12 + 8 + u \\cdot 5 + 3) \\leq 5312$$\n$$64 \\cdot (23 + 5u) \\leq 5312$$\nDividing both sides by $64$:\n$$23 + 5u \\leq 83$$\n$$5u \\leq 83 - 23$$\n$$5u \\leq 60$$\n$$u \\leq 12$$\n\nTo minimize $D(u)$, we must find the largest possible value of $u$ that satisfies both constraints:\n1. $u$ is a divisor of $240$.\n2. $u \\leq 12$.\n\nFrom the list of divisors of $240$, the largest value that is less than or equal to $12$ is $u=12$.\nSo, the selected unroll factor is $u = 12$.\n\nNow we compute the resulting CPI ($D(u)$) and control store size ($M(u)$) for $u=12$.\n\nThe CPI is $D(12)$:\n$$D(u) = s + f + T \\cdot p + \\frac{T \\cdot h}{u}$$\n$$D(12) = 12 + 8 + 240 \\cdot 5 + \\frac{240 \\cdot 3}{12}$$\n$$D(12) = 20 + 1200 + \\frac{720}{12}$$\n$$D(12) = 1220 + 60 = 1280$$\nThe resulting CPI is $1280$.\n\nThe control store size is $M(12)$:\n$$M(u) = w \\cdot (s + f + u \\cdot p + h)$$\n$$M(12) = 64 \\cdot (12 + 8 + 12 \\cdot 5 + 3)$$\n$$M(12) = 64 \\cdot (20 + 60 + 3)$$\n$$M(12) = 64 \\cdot (83)$$\n$$M(12) = 5312$$\nThe resulting control store size is $5312$ bits.\n\nThe three requested values are the unroll factor $u$, the CPI, and the control store size $M(u)$.\n- Selected unroll factor $u = 12$.\n- Resulting CPI for the instruction $D(12) = 1280$.\n- Resulting control store size $M(12) = 5312$ bits.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n12  1280  5312\n\\end{pmatrix}\n}\n$$", "id": "3659448"}, {"introduction": "A microprogrammed control unit's true power lies in its flexibility to manage complex processor behaviors. This final exercise moves beyond simple instruction implementation to the sophisticated task of handling pipeline control hazards.\n\nYou will evaluate competing microcode strategies to implement a branch delay slot, a mechanism for improving performance, and quantify the impact on the processor's overall Cycles Per Instruction ($\\mathrm{CPI}$). This problem demonstrates how clever microcode can solve hardware-level challenges and directly boost system efficiency [@problem_id:3659432].", "problem": "A microprogrammed control unit governs a classical $5$-stage pipeline (Instruction Fetch, Instruction Decode, Execute, Memory, Write Back). In the current microcode (which implements branches without a delay slot), conditional branches are resolved in the Execute stage; when a branch is taken, the next two younger instructions residing in the Instruction Fetch and Instruction Decode stages are flushed, incurring a branch penalty of $2$ wasted cycles per taken branch. There is no branch prediction, and a not-taken branch incurs zero penalty. The base (hazard-free) Cycles Per Instruction (CPI) is $1$.\n\nA software requirement mandates support for a single delayed branch slot: the instruction immediately following a branch must always execute, regardless of whether the branch is taken or not. Hardware cannot be modified; only the microcode may be changed. You must choose a microcode workaround that preserves correctness and minimizes the expected CPI:\n\n- Strategy $\\mathrm{S1}$ (deferral): In the branch microcode, suppress the program counter redirection and pipeline flush for just long enough to allow the next sequential instruction to proceed and complete as the required delay slot. This requires asserting a microcoded interlock that adds $1$ extra cycle only when the branch is taken; there is no added cost when the branch is not taken.\n- Strategy $\\mathrm{S2}$ (replay): Retain the original taken-branch flush behavior and then microcode a slot-replay subroutine that re-injects and executes the flushed delay-slot instruction. This subroutine adds $3$ extra cycles only when the branch is taken; there is no added cost when the branch is not taken.\n\nAssume the following instruction mix and branch behavior are representative of the workload:\n- The dynamic fraction of branch instructions is $f_{b} = 0.18$.\n- The conditional branch taken probability is $p_{t} = 0.55$.\n\nUsing only fundamental definitions (e.g., the definition of Cycles Per Instruction (CPI) as average cycles per retired instruction and the notion that penalties add expected cycles weighted by their event probabilities), select the minimal-cost microcode workaround, derive the resulting new CPI, and then compute the net CPI change\n$$\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{\\text{new}} - \\mathrm{CPI}_{\\text{old}}.$$\nRound your final numerical answer for $\\Delta \\mathrm{CPI}$ to four significant figures and express it as a pure number (unitless).", "solution": "The problem requires an analysis of pipeline performance, measured in Cycles Per Instruction (CPI), under three different microcode implementations for a $5$-stage pipeline: an original configuration and two proposed workarounds (S1 and S2) to support a delayed branch instruction. The goal is to select the superior workaround and quantify the resulting change in CPI.\n\nThe total CPI of a pipelined processor can be expressed as the sum of a base CPI (assuming no hazards or stalls) and the additional cycles per instruction contributed by various pipeline penalties. The general formula is:\n$$\n\\mathrm{CPI} = \\mathrm{CPI}_{\\text{base}} + \\sum_{i} (\\text{Penalty}_{i} \\times \\text{Frequency}_{i})\n$$\nwhere $\\text{Penalty}_{i}$ is the number of wasted cycles for event $i$, and $\\text{Frequency}_{i}$ is the probability of event $i$ occurring per instruction.\n\nThe givens for this problem are:\n- Base (hazard-free) CPI: $\\mathrm{CPI}_{\\text{base}} = 1$.\n- Dynamic fraction of branch instructions: $f_{b} = 0.18$.\n- Conditional branch taken probability: $p_{t} = 0.55$.\n\nFirst, we calculate the CPI for the original system, denoted as $\\mathrm{CPI}_{\\text{old}}$. In this system, there is no branch prediction, and conditional branches are resolved in the Execute stage. A taken branch incurs a penalty of $2$ cycles by flushing the instructions in the Instruction Fetch (IF) and Instruction Decode (ID) stages. A not-taken branch has a penalty of $0$ cycles.\n\nThe only source of penalty is a taken branch. The frequency of a taken branch per instruction is the product of the fraction of instructions that are branches and the probability that a branch is taken: $f_b \\times p_{t}$.\n$$\n\\mathrm{Frequency}_{\\text{taken branch}} = f_{b} \\times p_{t} = 0.18 \\times 0.55 = 0.099\n$$\nThe CPI for the original system is therefore:\n$$\n\\mathrm{CPI}_{\\text{old}} = \\mathrm{CPI}_{\\text{base}} + (\\text{Penalty for taken branch}) \\times (\\text{Frequency of taken branch})\n$$\n$$\n\\mathrm{CPI}_{\\text{old}} = 1 + 2 \\times (f_{b} p_{t}) = 1 + 2 \\times (0.099) = 1 + 0.198 = 1.198\n$$\n\nNext, we analyze the two proposed strategies for implementing a single delayed branch slot. The instruction in the delay slot (the one immediately following the branch) must always execute. We must select the strategy that minimizes the expected CPI.\n\nStrategy S1 (deferral): This strategy introduces a microcoded interlock that adds $1$ extra cycle only when the branch is taken. The penalty for a not-taken branch is $0$.\nThe CPI for Strategy S1 is:\n$$\n\\mathrm{CPI}_{\\text{S1}} = \\mathrm{CPI}_{\\text{base}} + (\\text{Penalty}_{\\text{S1, taken}}) \\times (f_{b} p_{t})\n$$\n$$\n\\mathrm{CPI}_{\\text{S1}} = 1 + 1 \\times (f_{b} p_{t}) = 1 + 1 \\times (0.099) = 1.099\n$$\n\nStrategy S2 (replay): This strategy retains the original flush but uses a subroutine to re-execute the flushed delay-slot instruction. This process adds $3$ extra cycles only when the branch is taken. The penalty for a not-taken branch is $0$.\nThe CPI for Strategy S2 is:\n$$\n\\mathrm{CPI}_{\\text{S2}} = \\mathrm{CPI}_{\\text{base}} + (\\text{Penalty}_{\\text{S2, taken}}) \\times (f_{b} p_{t})\n$$\n$$\n\\mathrm{CPI}_{\\text{S2}} = 1 + 3 \\times (f_{b} p_{t}) = 1 + 3 \\times (0.099) = 1 + 0.297 = 1.297\n$$\n\nTo select the minimal-cost microcode workaround, we compare the resulting CPI values:\n$$\n\\mathrm{CPI}_{\\text{S1}} = 1.099\n$$\n$$\n\\mathrm{CPI}_{\\text{S2}} = 1.297\n$$\nSince $1.099  1.297$, Strategy S1 yields a lower expected CPI. Therefore, S1 is the optimal choice. The new CPI for the system will be $\\mathrm{CPI}_{\\text{new}} = \\mathrm{CPI}_{\\text{S1}} = 1.099$.\n\nFinally, we compute the net CPI change, $\\Delta \\mathrm{CPI}$, which is defined as the difference between the new CPI and the old CPI.\n$$\n\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{\\text{new}} - \\mathrm{CPI}_{\\text{old}}\n$$\nSubstituting the derived values:\n$$\n\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{\\text{S1}} - \\mathrm{CPI}_{\\text{old}} = 1.099 - 1.198 = -0.099\n$$\nSymbolically, the change can be expressed as:\n$$\n\\Delta \\mathrm{CPI} = (1 + 1 \\cdot f_{b} p_{t}) - (1 + 2 \\cdot f_{b} p_{t}) = -f_{b} p_{t}\n$$\nThe problem requires the final numerical answer to be rounded to four significant figures. The calculated value is $-0.099$. To express this with four significant figures, we add two trailing zeros.\n$$\n\\Delta \\mathrm{CPI} = -0.09900\n$$", "answer": "$$\n\\boxed{-0.09900}\n$$", "id": "3659432"}]}