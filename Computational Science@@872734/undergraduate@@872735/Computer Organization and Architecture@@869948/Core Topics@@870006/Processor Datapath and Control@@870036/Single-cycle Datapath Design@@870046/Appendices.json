{"hands_on_practices": [{"introduction": "Understanding how a processor executes different instructions begins with mastering the role of control signals. These signals act as the datapath's traffic directors, configuring multiplexers and functional units to perform the correct operations. This first practice focuses on that core skill, asking you to trace the state of key control signals like $ALUSrc$, $MemtoReg$, and $RegDst$ for a variety of instruction types, from arithmetic to memory access and branching [@problem_id:3677903]. By working through this exercise, you will build a concrete mental model of how an instruction's opcode is translated into a specific flow of data through the processor's hardware.", "problem": "A single-cycle datapath for a MIPS-like instruction set uses the following select signals to control its multiplexers (Multiplexer (MUX), Arithmetic Logic Unit (ALU), Program Counter (PC)):\n\n- The input select to the second ALU operand is controlled by $ALUSrc$: $ALUSrc = 0$ selects the register file’s second read port (the $rt$ operand), and $ALUSrc = 1$ selects the sign-extended immediate.\n- The register write-back data MUX is controlled by $MemtoReg$: $MemtoReg = 0$ selects the ALU result, and $MemtoReg = 1$ selects the data memory output.\n- The register destination MUX is controlled by $RegDst$: $RegDst = 0$ selects the $rt$ field, and $RegDst = 1$ selects the $rd$ field.\n- The next-$PC$ MUX is selected in two stages: $PCSrc$ controls selection between $PC + 4$ and the branch target, and $Jump$ controls selection between the output of that $PC$ MUX and the jump target. Thus, $PCSrc = 0$ selects $PC + 4$, $PCSrc = 1$ selects the branch target; $Jump = 0$ leaves the selected value unchanged, and $Jump = 1$ selects the jump target.\n\nAssume a conventional textbook single-cycle control where, for instructions that do not functionally use a given select signal (for example, no register write-back implies the write-back MUX is irrelevant), the control unit nevertheless drives that unused select to $0$.\n\nConsider the following instruction sequence, executed in order, with the indicated register state so that the conditional branch’s outcome is determined at run time:\n\n- $I_1$: add $t0, t1, t2$\n- $I_2$: lw $t3, 8(t0)$\n- $I_3$: sw $t3, 12(t0)$\n- $I_4$: beq $t1, t2, L$    with initial register values $t1 = 5$, $t2 = 5$ (so the branch is taken)\n- $I_5$: j $K$\n\nFor each instruction $I_k$, form the $5$-tuple $\\left(ALUSrc, MemtoReg, RegDst, PCSrc, Jump\\right)$ of bit values actually driven during that instruction’s execution under the assumptions above. Which option lists the correct $5$-tuple for each $I_k$ in order $I_1$ through $I_5$?\n\nA.\n- $I_1$: $\\left(0, 0, 1, 0, 0\\right)$\n- $I_2$: $\\left(1, 1, 0, 0, 0\\right)$\n- $I_3$: $\\left(1, 0, 0, 0, 0\\right)$\n- $I_4$: $\\left(0, 0, 0, 1, 0\\right)$\n- $I_5$: $\\left(0, 0, 0, 0, 1\\right)$\n\nB.\n- $I_1$: $\\left(0, 0, 1, 0, 0\\right)$\n- $I_2$: $\\left(1, 0, 1, 0, 0\\right)$\n- $I_3$: $\\left(0, 0, 0, 0, 0\\right)$\n- $I_4$: $\\left(1, 0, 0, 0, 0\\right)$\n- $I_5$: $\\left(0, 0, 0, 1, 1\\right)$\n\nC.\n- $I_1$: $\\left(0, 0, 1, 0, 0\\right)$\n- $I_2$: $\\left(0, 1, 1, 0, 0\\right)$\n- $I_3$: $\\left(0, 0, 1, 0, 0\\right)$\n- $I_4$: $\\left(0, 0, 1, 1, 0\\right)$\n- $I_5$: $\\left(0, 0, 1, 0, 1\\right)$\n\nD.\n- $I_1$: $\\left(0, 0, 0, 0, 0\\right)$\n- $I_2$: $\\left(1, 1, 0, 0, 0\\right)$\n- $I_3$: $\\left(1, 0, 0, 0, 0\\right)$\n- $I_4$: $\\left(1, 0, 0, 1, 0\\right)$\n- $I_5$: $\\left(0, 0, 0, 1, 1\\right)$", "solution": "The problem statement is subjected to validation.\n\n### Step 1: Extract Givens\n\n- **Datapath**: A single-cycle datapath for a MIPS-like instruction set.\n- **Control Signal Definitions**:\n    - `$ALUSrc$`: Controls the MUX for the second ALU operand. $ALUSrc = 0$ selects the register file's second read port (the `$rt$` operand). $ALUSrc = 1$ selects the sign-extended immediate.\n    - `$MemtoReg$`: Controls the register write-back data MUX. $MemtoReg = 0$ selects the ALU result. $MemtoReg = 1$ selects the data memory output.\n    - `$RegDst$`: Controls the register destination MUX. $RegDst = 0$ selects the `$rt$` field. $RegDst = 1$ selects the `$rd$` field.\n    - Next-$PC$ Selection: A two-stage process.\n        - `$PCSrc$`: Controls the first MUX. $PCSrc = 0$ selects `$PC + 4$`. $PCSrc = 1$ selects the branch target.\n        - `$Jump$`: Controls the second MUX. $Jump = 0$ passes the output of the first MUX. $Jump = 1$ selects the jump target.\n- **Control Unit Convention**: For any instruction, if a select signal is not functionally required (i.e., it is a \"don't care\" condition), the control unit drives that signal to $0$.\n- **Instruction Sequence and State**:\n    - $I_1$: `add $t0, $t1, $t2`\n    - $I_2$: `lw $t3, 8($t0)`\n    - $I_3$: `sw $t3, 12($t0)`\n    - $I_4$: `beq $t1, $t2, L` with initial register values `$t1 = 5$` and `$t2 = 5$`, so the branch is taken.\n    - $I_5$: `j K`\n- **Objective**: Determine the $5$-tuple of control signal values $\\left(ALUSrc, MemtoReg, RegDst, PCSrc, Jump\\right)$ for each instruction $I_1$ through $I_5$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is scientifically grounded in the established principles of computer organization and architecture, specifically the design of a single-cycle MIPS-like processor. It is well-posed, providing all necessary definitions of control signals, a specific set of instructions, and a clear rule for handling \"don't care\" conditions. The language is objective and unambiguous. The problem does not violate any fundamental principles, is not incomplete or contradictory, and is directly solvable using standard analysis techniques for datapath control.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. A solution will be derived.\n\n### Derivation of Control Signal Tuples\n\nWe will analyze each instruction to determine the value of the $5$ specified control signals: $\\left(ALUSrc, MemtoReg, RegDst, PCSrc, Jump\\right)$. The analysis will adhere to the provided definitions and the \"don't care is $0$\" rule.\n\n**Instruction $I_1$: `add $t0, $t1, $t2`**\nThis is an R-type instruction that performs `$t0 \\leftarrow$ $t1 + $t2`.\n- `$ALUSrc$`: The ALU adds two register values (`$t1` and `$t2`). The second operand comes from the register file's second read port, which corresponds to the `$rt$` field. Therefore, `$ALUSrc = 0$`.\n- `$MemtoReg$`: The result of the ALU operation (`$t1 + $t2`) is written to the destination register. The data does not come from memory. Therefore, `$MemtoReg = 0$`.\n- `$RegDst$`: The destination register is specified by the `$rd$` field of the instruction (`$t0$). Therefore, `$RegDst = 1$`.\n- `$PCSrc$`: This is not a branch instruction. The program counter is updated to `$PC + 4$`. Therefore, `$PCSrc = 0$`.\n- `$Jump$`: This is not a jump instruction. Therefore, `$Jump = 0$`.\nThe tuple for $I_1$ is $\\left(0, 0, 1, 0, 0\\right)$.\n\n**Instruction $I_2$: `lw $t3, 8($t0)`**\nThis is an I-type instruction that loads a word from memory into a register: `$t3 \\leftarrow Memory[$t0 + 8]`.\n- `$ALUSrc$`: The ALU calculates the memory address by adding a register value (`$t0`) and the sign-extended immediate (`$8$`). The second ALU operand is the immediate. Therefore, `$ALUSrc = 1$`.\n- `$MemtoReg$`: The value written back to the register file is the data loaded from memory. Therefore, `$MemtoReg = 1$`.\n- `$RegDst$`: The destination register (`$t3`) is specified by the `$rt$` field of the instruction. Therefore, `$RegDst = 0$`.\n- `$PCSrc$`: This is not a branch instruction. The program counter is updated to `$PC + 4$`. Therefore, `$PCSrc = 0$`.\n- `$Jump$`: This is not a jump instruction. Therefore, `$Jump = 0$`.\nThe tuple for $I_2$ is $\\left(1, 1, 0, 0, 0\\right)$.\n\n**Instruction $I_3$: `sw $t3, 12($t0)`**\nThis is an I-type instruction that stores a word from a register into memory: `$Memory[$t0 + 12] \\leftarrow $t3`.\n- `$ALUSrc$`: The ALU calculates the memory address by adding a register value (`$t0`) and the sign-extended immediate (`$12$`). The second ALU operand is the immediate. Therefore, `$ALUSrc = 1$`.\n- `$MemtoReg$`: This instruction does not write to the register file (the `$RegWrite$` signal would be $0$). The `$MemtoReg$` signal controls a MUX whose output is only used if a register is written. Thus, `$MemtoReg$` is a \"don't care\". By the problem's rule, it is set to $0$. Therefore, `$MemtoReg = 0$`.\n- `$RegDst$`: Similar to `$MemtoReg$`, this instruction does not write to a register, so `$RegDst$` is a \"don't care\". By rule, it is set to $0$. Therefore, `$RegDst = 0$`.\n- `$PCSrc$`: This is not a branch instruction. The program counter is updated to `$PC + 4$`. Therefore, `$PCSrc = 0$`.\n- `$Jump$`: This is not a jump instruction. Therefore, `$Jump = 0$`.\nThe tuple for $I_3$ is $\\left(1, 0, 0, 0, 0\\right)$.\n\n**Instruction $I_4$: `beq $t1, $t2, L` (branch is taken)**\nThis is a conditional branch instruction. It branches to label `$L$` if `$t1 == $t2`. The problem states the branch is taken.\n- `$ALUSrc$`: The ALU compares the values of two registers (`$t1` and `$t2`), typically by subtraction. The second operand comes from the register file (`$t2`, the `$rt$` field). Therefore, `$ALUSrc = 0$`.\n- `$MemtoReg$`: This instruction does not write to the register file. `$MemtoReg$` is a \"don't care\" and is set to $0$.\n- `$RegDst$`: This instruction does not write to the register file. `$RegDst$` is a \"don't care\" and is set to $0$.\n- `$PCSrc$`: The branch is taken. The `PCSrc` MUX must select the branch target address. Therefore, `$PCSrc = 1$`.\n- `$Jump$`: This is not a jump instruction. Therefore, `$Jump = 0$`.\nThe tuple for $I_4$ is $\\left(0, 0, 0, 1, 0\\right)$.\n\n**Instruction $I_5$: `j K`**\nThis is a J-type instruction that unconditionally jumps to label `$K$`.\n- `$ALUSrc$`: The ALU is not used for any functional purpose in a jump instruction. Its control signal `$ALUSrc$` is a \"don't care\" and is set to $0$.\n- `$MemtoReg$`: This instruction does not write to the register file. `$MemtoReg$` is a \"don't care\" and is set to $0$.\n- `$RegDst$`: This instruction does not write to the register file. `$RegDst$` is a \"don't care\" and is set to $0$.\n- `$PCSrc$`: The next PC is determined by the jump target, not the branch target. The branch-related control signals would be inactive. `$PCSrc$` is a \"don't care\" and is set to $0$. The `$PC+4$`/branch MUX output is irrelevant because the next MUX will select the jump target.\n- `$Jump$`: This is a jump instruction. The final PC-selection MUX must select the jump target address. Therefore, `$Jump = 1$`.\nThe tuple for $I_5$ is $\\left(0, 0, 0, 0, 1\\right)$.\n\n### Summary of Derived Tuples\n- $I_1$: `add` $\\rightarrow \\left(0, 0, 1, 0, 0\\right)$\n- $I_2$: `lw`  $\\rightarrow \\left(1, 1, 0, 0, 0\\right)$\n- $I_3$: `sw`  $\\rightarrow \\left(1, 0, 0, 0, 0\\right)$\n- $I_4$: `beq` (taken) $\\rightarrow \\left(0, 0, 0, 1, 0\\right)$\n- $I_5$: `j`   $\\rightarrow \\left(0, 0, 0, 0, 1\\right)$\n\n### Option-by-Option Analysis\n\n**A.**\n- $I_1$: $\\left(0, 0, 1, 0, 0\\right)$ - matches our derivation.\n- $I_2$: $\\left(1, 1, 0, 0, 0\\right)$ - matches our derivation.\n- $I_3$: $\\left(1, 0, 0, 0, 0\\right)$ - matches our derivation.\n- $I_4$: $\\left(0, 0, 0, 1, 0\\right)$ - matches our derivation.\n- $I_5$: $\\left(0, 0, 0, 0, 1\\right)$ - matches our derivation.\nVerdict: **Correct**.\n\n**B.**\n- $I_2$: $\\left(1, 0, 1, 0, 0\\right)$ - Incorrect. For `lw`, `$MemtoReg` must be $1$ to write from memory, and `$RegDst$` must be $0$ to select the `$rt$` register.\n- $I_3$: $\\left(0, 0, 0, 0, 0\\right)$ - Incorrect. For `sw`, `$ALUSrc$` must be $1$ to use the immediate offset for the address calculation.\nVerdict: **Incorrect**.\n\n**C.**\n- $I_2$: $\\left(0, 1, 1, 0, 0\\right)$ - Incorrect. For `lw`, `$ALUSrc$` must be $1$ to use the immediate offset, and `$RegDst$` must be $0$ to select the `$rt$` register.\n- $I_3$: $\\left(0, 0, 1, 0, 0\\right)$ - Incorrect. For `sw`, `$ALUSrc$` is $1$, and `$RegDst$` is a don't care, thus $0$.\nVerdict: **Incorrect**.\n\n**D.**\n- $I_1$: $\\left(0, 0, 0, 0, 0\\right)$ - Incorrect. For `add` (an R-type instruction), `$RegDst$` must be $1$ to select the `$rd$` field as the destination register.\n- $I_4$: $\\left(1, 0, 0, 1, 0\\right)$ - Incorrect. For `beq`, `$ALUSrc$` must be $0$ to compare two register values.\nVerdict: **Incorrect**.\n\nBased on the thorough analysis, only option A correctly lists the control signal tuples for all five instructions.", "answer": "$$\\boxed{A}$$", "id": "3677903"}, {"introduction": "Once we understand the different paths data can take, the next logical question is: how fast can the processor run? This practice delves into the performance limitations inherent in a single-cycle design, where the clock period is dictated by the slowest instruction. You will analyze the timing of a load instruction versus a branch instruction by calculating their respective path delays from component-level propagation times [@problem_id:3677808]. This exercise will solidify your understanding of the critical path and why it is the ultimate bottleneck on a single-cycle processor's performance.", "problem": "Consider a synchronous single-cycle processor datapath that supports a conditional branch and a load. The datapath includes the following components: Program Counter (PC) register, instruction memory, register file, sign extender, shift-left-by-two, an adder that computes $PC+4$, a branch target adder, a comparator that evaluates the branch condition, a PC Multiplexer (MUX), an Arithmetic Logic Unit (ALU), and data memory. Assume negligible clock skew.\n\nUse the following timing parameters, all given as propagation delays in nanoseconds for combinational blocks and as timing parameters for registers:\n- PC register clock-to-$q$: $0.12\\,\\mathrm{ns}$.\n- PC register setup time: $0.09\\,\\mathrm{ns}$.\n- Instruction memory: $0.98\\,\\mathrm{ns}$.\n- Register file read: $0.64\\,\\mathrm{ns}$.\n- Sign extender: $0.19\\,\\mathrm{ns}$.\n- Shift-left-by-two: $0.11\\,\\mathrm{ns}$.\n- $PC+4$ adder: $0.26\\,\\mathrm{ns}$.\n- Branch target adder: $0.31\\,\\mathrm{ns}$.\n- Comparator: $0.21\\,\\mathrm{ns}$.\n- PC Multiplexer (MUX): $0.13\\,\\mathrm{ns}$.\n- Arithmetic Logic Unit (ALU): $0.37\\,\\mathrm{ns}$.\n- Data memory: $1.45\\,\\mathrm{ns}$.\n- Register file setup time: $0.08\\,\\mathrm{ns}$.\n\nFundamental base: In synchronous sequential circuits, the minimum feasible clock period is determined by the worst-case register-to-register path and must be no less than the sum of the source register clock-to-$q$ delay, all intermediate combinational propagation delays on the path, and the destination register setup time.\n\nTasks:\n1. Determine the combined delay contributed specifically by the $PC+4$ adder, branch target adder, comparator, and PC MUX along a correctly identified branch path.\n2. Using the fundamental timing rule for synchronous circuits, determine the total branch path delay from the PC register, through instruction fetch and operand preparation, the branch decision and target computation, and back to the PC register.\n3. Using the same rule, determine the total load instruction path delay from the PC register, through instruction fetch, register read, address calculation in the ALU, data memory access, and finally to the register file write stage.\n4. Identify the minimum feasible clock period for the single-cycle implementation as the larger of the two total path delays.\n\nReport only the minimum feasible clock period in nanoseconds, and round your final answer to four significant figures. Express the final answer in $\\mathrm{ns}$.", "solution": "The problem is valid. It is a well-posed problem in computer organization and architecture, grounded in the fundamental principles of synchronous sequential circuit timing. The provided data is self-contained and sufficient to determine the minimum clock period for the specified single-cycle datapath.\n\nThe minimum feasible clock period ($T_{clk}$) for a single-cycle processor is determined by the propagation delay of the longest path, or critical path, from a register's output to a register's input. The clock period must be long enough to accommodate the cumulative delay of all components on this path, plus the initial clock-to-q delay of the source register and the final setup time of the destination register. The formula for the total delay of any given path is:\n$$T_{path} = T_{clk-q} + \\sum T_{comb} + T_{setup}$$\nwhere $T_{clk-q}$ is the clock-to-q delay of the source state element, $\\sum T_{comb}$ is the sum of propagation delays of all combinational logic blocks on the path, and $T_{setup}$ is the setup time of the destination state element.\n\nThe problem requires us to find the minimum clock period for a processor that supports at least a conditional branch instruction and a load instruction. We must therefore calculate the total path delay for each of these instruction types and take the maximum value, as the clock period must be long enough for the slowest instruction to complete.\n\nLet's analyze the two main paths: the load instruction path and the conditional branch instruction path.\n\nPath 1: Load Instruction (`lw`)\nThe load instruction fetches a word from data memory and writes it into the register file. The critical path for this instruction involves reading the base address from the register file, calculating the effective memory address in the ALU, reading from data memory, and finally writing the result back to the register file. The path starts with the PC providing an address to instruction memory and ends with the data being stable at the register file's write port for its setup time.\n\nThe sequence of operations and their delays are as follows:\n1.  PC provides address to Instruction Memory: $T_{PC, clk-q} = 0.12\\,\\mathrm{ns}$.\n2.  Instruction Memory access: $T_{IM} = 0.98\\,\\mathrm{ns}$.\n3.  Register File read (to get base address for ALU): $T_{RF, read} = 0.64\\,\\mathrm{ns}$.\n4.  ALU computes effective memory address: $T_{ALU} = 0.37\\,\\mathrm{ns}$.\n5.  Data Memory access: $T_{DM} = 1.45\\,\\mathrm{ns}$.\n6.  Data must be stable for Register File setup: $T_{RF, setup} = 0.08\\,\\mathrm{ns}$.\n\nThe total delay for the load path, $T_{load}$, is the sum of all delays from the start of the cycle until the data is set up at the destination register.\n$$T_{load} = T_{PC, clk-q} + T_{IM} + T_{RF, read} + T_{ALU} + T_{DM} + T_{RF, setup}$$\n$$T_{load} = 0.12 + 0.98 + 0.64 + 0.37 + 1.45 + 0.08\\,\\mathrm{ns}$$\n$$T_{load} = 3.64\\,\\mathrm{ns}$$\n\nPath 2: Conditional Branch Instruction (`beq`)\nThe conditional branch instruction calculates a target address and compares two registers. If the condition is met, the PC is updated with the target address; otherwise, it is updated with $PC+4$. The critical path for this instruction is the longer of the path to calculate the target address and the path to determine the branch condition. The final value for the next PC must be ready at the PC's input before its setup time.\n\nThe process involves several parallel sub-paths that converge at the PC Multiplexer (MUX). The MUX's output is determined by its data inputs and its select signal. The MUX's output will be stable only after its latest-arriving input (data or select) is stable, plus the MUX's own delay.\n1.  Path to MUX data input 0 ($PC+4$): This path is not critical as it is very fast.\n2.  Path to MUX data input 1 (Branch Target Address): This path is also not the bottleneck.\n3.  Path to MUX select signal (Branch Condition): This is typically the longest path for a branch. The path is: PC clk-q $\\rightarrow$ Instruction Memory $\\rightarrow$ Register File read $\\rightarrow$ Comparator.\n    - Time for select signal to be ready at MUX input: $T_{PC, clk-q} + T_{IM} + T_{RF, read} + T_{Comp} = 0.12 + 0.98 + 0.64 + 0.21 = 1.95\\,\\mathrm{ns}$.\n4.  The MUX output is then stable after the MUX delay: $1.95\\,\\mathrm{ns} + T_{PC, MUX} = 1.95 + 0.13 = 2.08\\,\\mathrm{ns}$.\n5.  This value must satisfy the PC's setup time, $T_{PC, setup} = 0.09\\,\\mathrm{ns}$, before the next clock edge.\n\nThe total delay for the branch path, $T_{branch}$, is the time from the start of the cycle until the next PC value is stable at the PC's input.\n$$T_{branch} = (T_{PC, clk-q} + T_{IM} + T_{RF, read} + T_{Comp}) + T_{PC, MUX} + T_{PC, setup}$$\n$$T_{branch} = (0.12 + 0.98 + 0.64 + 0.21) + 0.13 + 0.09\\,\\mathrm{ns}$$\n$$T_{branch} = 1.95 + 0.13 + 0.09 = 2.17\\,\\mathrm{ns}$$\n\nMinimum Clock Period\nThe minimum clock period must be greater than or equal to the longest path delay in the datapath.\n$$T_{clk, min} = \\max(T_{load}, T_{branch})$$\n$$T_{clk, min} = \\max(3.64\\,\\mathrm{ns}, 2.17\\,\\mathrm{ns}) = 3.64\\,\\mathrm{ns}$$\n\nThe critical path is that of the load instruction. The minimum feasible clock period is $3.64\\,\\mathrm{ns}$. The problem requires the answer to be rounded to four significant figures.\n\n$$T_{clk, min} = 3.640\\,\\mathrm{ns}$$", "answer": "$$\\boxed{3.640}$$", "id": "3677808"}, {"introduction": "A key task for a computer architect is to enhance a processor's capabilities by extending its instruction set. This design-oriented practice challenges you to add a new instruction, `SEXT`, for sign-extending a byte within a register [@problem_id:3677867]. The challenge lies in implementing this functionality using only the existing datapath components without increasing the clock cycle time. This problem forces you to confront a fundamental trade-off in computer design: when is a hardware solution feasible, and when is it more practical to achieve the same result using a sequence of existing instructions (a pseudo-instruction)?", "problem": "Consider a classic single-cycle datapath for a Reduced Instruction Set Computer (RISC) style processor at the advanced undergraduate level. The datapath includes instruction memory, register file, arithmetic logic unit ($ALU$), a barrel shifter capable of shift-left logical ($SLL$), shift-right logical ($SRL$), and shift-right arithmetic ($SRA$), data memory, and standard multiplexers ($MUX$) controlling operand selection and write-back. No microprogramming or multicycle execution is used; every instruction must complete in exactly one clock period. The clock period is constrained by the longest combinational path (the critical path). For the baseline design, the longest path is assumed to be the load word ($lw$) path.\n\nYou are asked to add a new instruction, $SEXT$, which for a source register value $x \\in \\{0,1\\}^{32}$ produces the $32$-bit two’s complement sign extension of the low byte of $x$. Formally, denoting the low byte as $x_{7:0}$, $SEXT$ computes\n$$\ny \\triangleq \\operatorname{sext8}(x) = \\text{the unique } 32\\text{-bit two's complement integer whose low byte equals } x_{7:0} \\text{ and whose bits } y_{31:8} \\text{ all equal } x_7.\n$$\nEquivalently (purely as a specification), one may characterize $\\operatorname{sext8}(x)$ as\n$$\n\\operatorname{sext8}(x) = \\big((x \\ll 24) \\ggg 24\\big),\n$$\nwhere $\\ll$ denotes shift-left logical and $\\ggg$ denotes shift-right arithmetic.\n\nYou must decide whether $SEXT$ can be realized using only the existing units ($ALU$, shifter, $MUX$) without introducing new modules, and whether this realization preserves the single-cycle timing (i.e., does not increase the required clock period). The baseline component propagation delays are:\n- Instruction memory: $t_{\\mathrm{IMEM}} = 250\\,\\mathrm{ps}$,\n- Register file read: $t_{\\mathrm{RF}} = 150\\,\\mathrm{ps}$,\n- $ALU$ (non-shift ops): $t_{\\mathrm{ALU}} = 180\\,\\mathrm{ps}$,\n- Shifter ($SLL$, $SRL$, $SRA$): $t_{\\mathrm{SH}} = 220\\,\\mathrm{ps}$,\n- Data memory: $t_{\\mathrm{DMEM}} = 280\\,\\mathrm{ps}$,\n- Each $MUX$: $t_{\\mathrm{MUX}} = 30\\,\\mathrm{ps}$,\n- Write-back setup (register file input setup and clock-to-$Q$ overhead aggregate): $t_{\\mathrm{WB}} = 20\\,\\mathrm{ps}$.\n\nAssume the baseline critical path is the $lw$ path, with clock period\n$$\nT_{\\mathrm{clk}}^{\\mathrm{base}} = t_{\\mathrm{IMEM}} + t_{\\mathrm{RF}} + t_{\\mathrm{ALU}} + t_{\\mathrm{DMEM}} + t_{\\mathrm{MUX}} + t_{\\mathrm{WB}}.\n$$\nThe datapath places the shifter as one of the $ALU$ function options, with no internal loop that allows the shifter’s output to be immediately re-fed as its own input within the same cycle; that is, there is exactly one traversal of the shifter per instruction in the unmodified datapath.\n\nWhich option best describes a correct procedure to add $SEXT$ using existing units without new modules, together with the correct feasibility and timing conclusion?\n\nA. Add a control setting that routes the source register $x$ through the shifter twice in the same cycle, first with $SLL$ by $24$ and then with $SRA$ by $24$, using existing $MUX$es to loop the shifter output back to its input. This preserves single-cycle execution and fits within $T_{\\mathrm{clk}}^{\\mathrm{base}}$ because the added shifter traversal delay remains below the baseline $lw$ critical path.\n\nB. Implement $SEXT$ by masking: compute $y = x \\,\\&\\, 255$ using the $ALU$ and write back the result. This uses only existing $ALU$ and $MUX$ paths, executes in one cycle, and meets timing because it avoids the shifter altogether while still sign-extending the byte.\n\nC. Do not change hardware. Define $SEXT$ in the instruction set architecture as a pseudo-instruction that the assembler expands into two existing instructions: $SLL$ by $24$ followed by $SRA$ by $24$. Each constituent instruction executes in one cycle using existing units. This preserves the baseline clock period and yields the exact $SEXT$ semantics without introducing new modules, but $SEXT$ itself is not a single-cycle hardware instruction.\n\nD. Reuse the immediate sign-extension unit (which sign-extends $16$-bit immediate fields from the instruction) to sign-extend the low byte of the register $x$ by steering $x$ into that unit via existing $MUX$es. This executes in one cycle and meets timing because the immediate sign-extension unit is already present and fast.\n\nSelect the most accurate option.", "solution": "The user wants me to analyze the feasibility of adding a new instruction, `SEXT`, to a single-cycle RISC datapath.\n\n### Step 1: Extract Givens\n\n*   **Processor Architecture**: Single-cycle RISC datapath.\n*   **Datapath Components**: Instruction Memory, Register File, ALU, Barrel Shifter (`SLL`, `SRL`, `SRA`), Data Memory, MUXes.\n*   **Execution Model**: Each instruction completes in one clock cycle.\n*   **New Instruction `SEXT`**: Performs a $32$-bit two's complement sign extension of the low byte of a source register $x$.\n    *   **Specification 1**: The output $y$ satisfies $y_{7:0} = x_{7:0}$ and $y_{31:8}$ are all equal to $x_7$.\n    *   **Specification 2**: An equivalent characterization is $y = ((x \\ll 24) \\ggg 24)$, where $\\ll$ is shift-left logical and $\\ggg$ is shift-right arithmetic.\n*   **Constraints**:\n    1.  The implementation must use only existing functional units and multiplexers. No new modules can be added.\n    2.  The implementation must not increase the required clock period.\n*   **Datapath Structure Constraint**: \"no internal loop that allows the shifter’s output to be immediately re-fed as its own input within the same cycle; that is, there is exactly one traversal of the shifter per instruction\".\n*   **Component Delays**:\n    *   $t_{\\mathrm{IMEM}} = 250\\,\\mathrm{ps}$\n    *   $t_{\\mathrm{RF}} = 150\\,\\mathrm{ps}$ (read)\n    *   $t_{\\mathrm{ALU}} = 180\\,\\mathrm{ps}$ (non-shift operations)\n    *   $t_{\\mathrm{SH}} = 220\\,\\mathrm{ps}$ (shifter)\n    *   $t_{\\mathrm{DMEM}} = 280\\,\\mathrm{ps}$\n    *   $t_{\\mathrm{MUX}} = 30\\,\\mathrm{ps}$\n    *   $t_{\\mathrm{WB}} = 20\\,\\mathrm{ps}$ (write-back setup)\n*   **Baseline Critical Path**: The load-word ($lw$) instruction, with a clock period given by:\n    $$ T_{\\mathrm{clk}}^{\\mathrm{base}} = t_{\\mathrm{IMEM}} + t_{\\mathrm{RF}} + t_{\\mathrm{ALU}} + t_{\\mathrm{DMEM}} + t_{\\mathrm{MUX}} + t_{\\mathrm{WB}} $$\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement describes a standard academic problem in computer architecture concerning datapath modification and performance analysis.\n*   **Scientifically Grounded**: The concepts of single-cycle datapaths, critical path timing, instruction set extension, and specific operations like sign extension are all fundamental and well-established in computer organization and architecture.\n*   **Well-Posed**: The new instruction `SEXT` is unambiguously defined. The constraints on implementation (no new modules, no increase in clock period) are clear. All necessary data (component delays, critical path formula) are provided.\n*   **Objective**: The problem is stated in precise, technical language with no subjective elements.\n*   **Consistency Check**: The provided formula for the baseline critical path is an explicit premise of the problem. While it's a simplification of a real `lw` path (which also involves an immediate sign-extender), we must accept it as given. The constraint about \"one traversal of the shifter\" and \"no internal loop\" is a crucial, non-contradictory piece of information about the datapath's structure.\n\nThe problem is valid. It is a well-posed, self-contained, and scientifically sound exercise. I will now proceed with the solution.\n\n### Step 3: Derivation and Option Analysis\n\nFirst, let's calculate the baseline clock period, which is the maximum time a new instruction can take.\n$$ T_{\\mathrm{clk}}^{\\mathrm{base}} = t_{\\mathrm{IMEM}} + t_{\\mathrm{RF}} + t_{\\mathrm{ALU}} + t_{\\mathrm{DMEM}} + t_{\\mathrm{MUX}} + t_{\\mathrm{WB}} $$\n$$ T_{\\mathrm{clk}}^{\\mathrm{base}} = 250\\,\\mathrm{ps} + 150\\,\\mathrm{ps} + 180\\,\\mathrm{ps} + 280\\,\\mathrm{ps} + 30\\,\\mathrm{ps} + 20\\,\\mathrm{ps} = 910\\,\\mathrm{ps} $$\nAny new single-cycle hardware instruction must have a total path delay less than or equal to $910\\,\\mathrm{ps}$.\n\nThe definition of `SEXT` is given as $y = ((x \\ll 24) \\ggg 24)$. This operation requires two sequential shift operations on the data from the source register. A standard single-cycle datapath is designed to perform only one ALU or shifter operation per cycle. The outputs of these units are typically routed towards the data memory or register file write port and are latched at the end of the clock cycle. They are not available as inputs to the same functional units within the same cycle. The problem statement explicitly confirms this structural limitation: \"no internal loop that allows the shifter’s output to be immediately re-fed as its own input within the same cycle\".\n\nThis fundamental constraint means it is impossible to perform two sequential shifts in a single clock cycle using the described datapath without significant modification (i.e., adding a path and control for a loop).\n\nNow, let's evaluate each option based on this understanding.\n\n**A. Add a control setting that routes the source register $x$ through the shifter twice in the same cycle, first with $SLL$ by $24$ and then with $SRA$ by $24$, using existing $MUX$es to loop the shifter output back to its input. This preserves single-cycle execution and fits within $T_{\\mathrm{clk}}^{\\mathrm{base}}$ because the added shifter traversal delay remains below the baseline $lw$ critical path.**\n\nThis option suggests creating a loop to use the shifter twice.\n1.  **Feasibility**: This directly violates the explicit problem constraint that \"no internal loop that allows the shifter’s output to be immediately re-fed as its own input within the same cycle\". Therefore, this procedure is not possible on the *given* datapath.\n2.  **Timing**: Even if such a loop were possible, let's calculate the path delay. The data would have to flow from the register file, through the shifter, through a new MUX path, back through the shifter, and then to the register file write port.\n    The path delay would be at least:\n    $T_{\\mathrm{A}} = t_{\\mathrm{IMEM}} + t_{\\mathrm{RF}} + t_{\\mathrm{SH}} + t_{\\mathrm{MUX}} + t_{\\mathrm{SH}} + t_{\\mathrm{MUX}} + t_{\\mathrm{WB}}$\n    $T_{\\mathrm{A}} = 250 + 150 + 220 + 30 + 220 + 30 + 20 = 920\\,\\mathrm{ps}$\n    This delay of $920\\,\\mathrm{ps}$ is greater than the baseline clock period of $910\\,\\mathrm{ps}$. Thus, this would require increasing the clock period. The option's claim that it \"fits within $T_{\\mathrm{clk}}^{\\mathrm{base}}$\" is false.\n**Verdict: Incorrect.**\n\n**B. Implement $SEXT$ by masking: compute $y = x \\,\\&\\, 255$ using the $ALU$ and write back the result. This uses only existing $ALU$ and $MUX$ paths, executes in one cycle, and meets timing because it avoids the shifter altogether while still sign-extending the byte.**\n\nThis option proposes a different implementation: bitwise AND with the constant $255$ (hexadecimal `0x000000FF`).\n1.  **Functionality**: This operation, $y = x \\,\\&\\, 0x000000FF$, isolates the low byte of $x$ and sets all upper $24$ bits to $0$. This is known as *zero extension*. The `SEXT` instruction requires *sign extension*, where the upper $24$ bits are set to the value of the sign bit of the byte ($x_7$). For any value $x$ where the low byte is negative (i.e., $x_7 = 1$), this implementation will produce the wrong result. For example, if $x_{7:0} = 1000\\,0000_2$, sign extension yields $11...1000\\,0000_2$, while masking yields $00...01000\\,0000_2$.\nThe proposed logic is functionally incorrect.\n**Verdict: Incorrect.**\n\n**C. Do not change hardware. Define $SEXT$ in the instruction set architecture as a pseudo-instruction that the assembler expands into two existing instructions: $SLL$ by $24$ followed by $SRA$ by $24$. Each constituent instruction executes in one cycle using existing units. This preserves the baseline clock period and yields the exact $SEXT$ semantics without introducing new modules, but $SEXT$ itself is not a single-cycle hardware instruction.**\n\nThis option proposes a software-based solution using the concept of a pseudo-instruction.\n1.  **Functionality**: The sequence `sll $t0, $rs, 24` followed by `sra $rd, $t0, 24` correctly implements the operation $((x \\ll 24) \\ggg 24)$. The first instruction moves the low byte to the top byte position, making its sign bit ($x_7$) the most significant bit of the word. The second instruction, an arithmetic right shift, shifts the byte back to the low position while replicating the sign bit throughout the upper $24$ bits. This sequence correctly performs the sign extension.\n2.  **Feasibility & Constraints**:\n    *   This approach requires no changes to the datapath hardware (\"Do not change hardware\"). It uses existing instructions (`SLL`, `SRA`) supported by the existing shifter.\n    *   Because the hardware is unchanged, the critical path remains the `lw` instruction, and the clock period $T_{\\mathrm{clk}}^{\\mathrm{base}}$ is preserved.\n    *   It correctly notes the trade-off: `SEXT` is not a new *hardware* instruction that executes in one cycle. It is an assembler convention that expands into two machine instructions, thus taking two clock cycles to execute.\nThis option provides a correct, practical solution that respects all stated constraints.\n**Verdict: Correct.**\n\n**D. Reuse the immediate sign-extension unit (which sign-extends $16$-bit immediate fields from the instruction) to sign-extend the low byte of the register $x$ by steering $x$ into that unit via existing $MUX$es. This executes in one cycle and meets timing because the immediate sign-extension unit is already present and fast.**\n\nThis option proposes using the hardware dedicated to sign-extending immediate values.\n1.  **Feasibility**: In a standard RISC datapath, the immediate sign-extension unit's input is hardwired to the bits of the instruction register (e.g., bits $15:0$). There is no MUX to select a value from the register file as an input to this unit. Adding such a MUX and its control signal would constitute a hardware modification, which may violate the \"using only existing units\" constraint, depending on interpretation.\n2.  **Functionality**: The standard sign-extension unit is designed to extend a $16$-bit value by replicating its most significant bit ($I_{15}$). The `SEXT` instruction needs to extend an $8$-bit value by replicating its sign bit ($x_7$). Simply feeding the low byte of a register into a $16$-bit sign-extender will not work correctly. The unit is hardwired to look at bit $15$ for the sign, not bit $7$. Therefore, the existing unit cannot perform the required operation without being redesigned. This would be a \"new module\" or a modification, violating the problem's constraints.\nThe premise that the existing immediate sign-extender can be \"reused\" for this purpose is fundamentally flawed.\n**Verdict: Incorrect.**\n\n### Conclusion\n\nOption C is the only one that presents a functionally correct and architecturally sound solution that adheres to all the problem's constraints. It correctly identifies that the desired operation cannot be implemented in a single hardware cycle on the specified datapath without modifications, and it accurately describes the standard software-based alternative (pseudo-instruction).", "answer": "$$\\boxed{C}$$", "id": "3677867"}]}