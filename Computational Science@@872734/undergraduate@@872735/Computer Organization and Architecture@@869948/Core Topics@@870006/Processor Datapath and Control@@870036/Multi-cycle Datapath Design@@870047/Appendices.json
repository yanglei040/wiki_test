{"hands_on_practices": [{"introduction": "A primary advantage of the multi-cycle approach is that different instructions can take a different number of clock cycles to complete, allowing for greater overall efficiency. This practice provides a concrete method to quantify this performance. By analyzing a specific instruction mix, you will calculate the total execution time and the average Cycles Per Instruction (CPI), which is a fundamental skill for evaluating and comparing processor designs. [@problem_id:3660301]", "problem": "Consider a classical multi-cycle implementation of the MIPS-like instruction set architecture. The datapath uses a fixed-length clock where each control state occupies exactly one clock cycle. The control states are as follows: Instruction Fetch $S_{\\mathrm{IF}}$, Instruction Decode and Register Fetch $S_{\\mathrm{ID}}$, Execute $S_{\\mathrm{EX}}$, Memory Access (Read) $S_{\\mathrm{MEM,R}}$, Memory Access (Write) $S_{\\mathrm{MEM,W}}$, and Register Write Back $S_{\\mathrm{WB}}$. Each instruction completes before the next begins, and there is no overlap between instructions. The Program Counter (PC) is updated in $S_{\\mathrm{IF}}$ and for branches in $S_{\\mathrm{EX}}$.\n\nFor this micro-benchmark, repeat $N$ times the following instruction pattern: $add$, $lw$, $beq$, $sw$, with $N = 250$. The concrete instructions are:\n$add\\ r_{1}, r_{2}, r_{3}$,\n$lw\\ r_{4}, 0(r_{5})$,\n$beq\\ r_{1}, r_{4}, \\text{Label}$,\n$sw\\ r_{4}, 0(r_{6})$.\n\nAssume the following:\n- The branch $beq$ is always not taken (the comparison yields false), so control flows sequentially through the pattern and the label is never used.\n- For $lw$ and $sw$, the effective address computation is performed in $S_{\\mathrm{EX}}$ by adding the base register and sign-extended immediate.\n- The control state sequences per instruction are determined by the semantics of each instruction and the above datapath, specifically:\n  - $add$: $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}} \\rightarrow S_{\\mathrm{WB}}$,\n  - $lw$: $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}} \\rightarrow S_{\\mathrm{MEM,R}} \\rightarrow S_{\\mathrm{WB}}$,\n  - $beq$: $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}}$,\n  - $sw$: $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}} \\rightarrow S_{\\mathrm{MEM,W}}$.\n- All memory references are aligned and cause no exceptions.\n\nTasks:\n1. Derive, from first principles of multi-cycle execution and the specified state sequences, the total number of clock cycles required to execute the entire micro-benchmark of $N = 250$ repetitions of the $4$-instruction pattern.\n2. Count how many times each control state is visited over the entire run, and use this to determine which states dominate execution in terms of cycle share.\n3. Report the average cycles per instruction (CPI) for the benchmark as a single number. No rounding is required, and no units should be included in the final answer. Express the CPI as a real number.", "solution": "The problem is well-posed, scientifically grounded in the principles of computer architecture, and provides a complete and consistent set of data and assumptions. It is therefore valid and permits a direct analytical solution.\n\nThe analysis proceeds by addressing the three tasks specified: calculating the total number of clock cycles, determining the frequency of each control state, and computing the average cycles per instruction (CPI).\n\n**1. Total Clock Cycles for the Benchmark**\n\nThe micro-benchmark consists of repeating a specific $4$-instruction pattern $N$ times, where $N=250$. The pattern is: $add$, $lw$, $beq$, $sw$. The total number of clock cycles, $C_{total}$, is the number of repetitions multiplied by the number of cycles required to execute one instance of the pattern, $C_{pattern}$.\n\nFirst, we determine the number of clock cycles for each individual instruction based on its given control state sequence. In a multi-cycle datapath, each state corresponds to one clock cycle.\n- The $add$ instruction follows the sequence $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}} \\rightarrow S_{\\mathrm{WB}}$. The number of states is $4$, so the cycles for an $add$ instruction, $C_{add}$, is $4$.\n- The $lw$ instruction follows the sequence $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}} \\rightarrow S_{\\mathrm{MEM,R}} \\rightarrow S_{\\mathrm{WB}}$. The number of states is $5$, so the cycles for a $lw$ instruction, $C_{lw}$, is $5$.\n- The $beq$ instruction, being not taken, follows the sequence $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}}$. The comparison and decision not to branch are completed in the execute state. The number of states is $3$, so the cycles for a non-taken $beq$ instruction, $C_{beq}$, is $3$.\n- The $sw$ instruction follows the sequence $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}} \\rightarrow S_{\\mathrm{MEM,W}}$. The number of states is $4$, so the cycles for a $sw$ instruction, $C_{sw}$, is $4$.\n\nThe total number of cycles for one repetition of the $4$-instruction pattern, $C_{pattern}$, is the sum of the cycles for each instruction in the pattern:\n$$C_{pattern} = C_{add} + C_{lw} + C_{beq} + C_{sw} = 4 + 5 + 3 + 4 = 16$$\nThe benchmark executes this pattern $N = 250$ times. Therefore, the total number of clock cycles for the entire benchmark is:\n$$C_{total} = N \\times C_{pattern} = 250 \\times 16 = 4000$$\n\n**2. Control State Visitation Count**\n\nTo find the number of times each state is visited, we first determine the total number of instructions executed, $I_{total}$. The pattern has $4$ instructions and is repeated $N=250$ times.\n$$I_{total} = N \\times 4 = 250 \\times 4 = 1000$$\nThe number of times each type of instruction is executed is $N=250$.\n- Number of $add$ instructions, $I_{add} = 250$.\n- Number of $lw$ instructions, $I_{lw} = 250$.\n- Number of $beq$ instructions, $I_{beq} = 250$.\n- Number of $sw$ instructions, $I_{sw} = 250$.\n\nNow, we count the total visits for each state by summing its occurrences across all executed instructions.\n- **$S_{\\mathrm{IF}}$ (Instruction Fetch):** Every instruction must be fetched. So, this state is visited once for every instruction.\n  $$N(S_{\\mathrm{IF}}) = I_{total} = 1000$$\n- **$S_{\\mathrm{ID}}$ (Instruction Decode/Register Fetch):** Every instruction is decoded. This state is also visited for every instruction.\n  $$N(S_{\\mathrm{ID}}) = I_{total} = 1000$$\n- **$S_{\\mathrm{EX}}$ (Execute):** All four instruction types in the pattern perform an execution step (ALU operation for $add$, address calculation for $lw$/$sw$, comparison for $beq$).\n  $$N(S_{\\mathrm{EX}}) = I_{total} = 1000$$\n- **$S_{\\mathrm{MEM,R}}$ (Memory Read):** Only the $lw$ instruction performs a memory read.\n  $$N(S_{\\mathrm{MEM,R}}) = I_{lw} = 250$$\n- **$S_{\\mathrm{MEM,W}}$ (Memory Write):** Only the $sw$ instruction performs a memory write.\n  $$N(S_{\\mathrm{MEM,W}}) = I_{sw} = 250$$\n- **$S_{\\mathrm{WB}}$ (Write Back):** Only instructions that write a result to the register file use this state. In this pattern, these are the $add$ and $lw$ instructions.\n  $$N(S_{\\mathrm{WB}}) = I_{add} + I_{lw} = 250 + 250 = 500$$\n\nThe states that dominate execution are those with the highest visitation counts. The states $S_{\\mathrm{IF}}$, $S_{\\mathrm{ID}}$, and $S_{\\mathrm{EX}}$ are each visited $1000$ times, whereas $S_{\\mathrm{WB}}$ is visited $500$ times, and $S_{\\mathrm{MEM,R}}$ and $S_{\\mathrm{MEM,W}}$ are each visited $250$ times. Thus, the fetch, decode, and execute states dominate the execution time, each accounting for $1000/4000 = 25\\%$ of the total cycles.\n\nAs a consistency check, the sum of all state visits must equal the total clock cycles:\n$$N(S_{\\mathrm{IF}}) + N(S_{\\mathrm{ID}}) + N(S_{\\mathrm{EX}}) + N(S_{\\mathrm{MEM,R}}) + N(S_{\\mathrm{MEM,W}}) + N(S_{\\mathrm{WB}})$$\n$$= 1000 + 1000 + 1000 + 250 + 250 + 500 = 4000$$\nThis matches the previously calculated $C_{total}$.\n\n**3. Average Cycles Per Instruction (CPI)**\n\nThe average cycles per instruction (CPI) is a performance metric defined as the total number of clock cycles divided by the total number of instructions executed.\n$$CPI = \\frac{C_{total}}{I_{total}}$$\nUsing the values derived above:\n$$C_{total} = 4000$$\n$$I_{total} = 1000$$\nThe CPI for the benchmark is:\n$$CPI = \\frac{4000}{1000} = 4.0$$\nThis value represents the average number of clock cycles required to execute one instruction in this specific benchmark mix.", "answer": "$$\\boxed{4.0}$$", "id": "3660301"}, {"introduction": "Beyond performance analysis, a critical skill for a computer architect is debugging. Real-world hardware and control logic can contain flaws, and locating them requires a systematic approach. This exercise places you in the role of a debugger, tasking you with diagnosing a fault by examining snapshots of the datapath's internal state. You will learn to trace the flow of incorrect data back to its source—a faulty control signal—sharpening your ability to connect high-level symptoms to low-level errors. [@problem_id:3660319]", "problem": "A multicycle datapath is used to execute load and store instructions, decomposing each instruction into a sequence of micro-states with register transfers and controlled resource usage. The design includes the following architectural registers and components: Program Counter (PC), Instruction Register (IR), Memory Address Register (MAR), Memory Data Register (MDR), register file with outputs $A$ and $B$, Arithmetic Logic Unit (ALU) with an output latch $ALUOut$, and a single internal System Bus (SB) onto which one source is gated per cycle by tri-state drivers. The Memory Address Register (MAR) latches from the System Bus (SB) when $MARWrite$ is asserted. The intended behavior for effective address computation in the load/store path is that the ALU computes $A + \\text{SignExt}(\\text{imm})$, latches the result into $ALUOut$, then the System Bus (SB) is driven by $ALUOut$ and $MAR$ latches this address when $MARWrite$ is asserted. In the instruction fetch state, the System Bus (SB) is driven by $PC$ and $MAR$ latches the instruction address similarly.\n\nControl lines relevant to this fragment include $GatePC$, $GateALUOut$, $GateB$ (each enabling a source to drive the System Bus (SB)), $MARWrite$ (latching $SB$ into $MAR$), $ALUSrcA$ (selecting ALU input $A$ versus $PC$), $ALUSrcB$ (selecting among $B$, constant $4$, sign-extended immediate, or shifted immediate), and $ALUOp$ (choosing the ALU operation). For a load word instruction, the textbook micro-operations are: decode and register fetch ($A \\leftarrow \\text{Reg}[rs]$, $B \\leftarrow \\text{Reg}[rt]$), effective address ($ALUOut \\leftarrow A + \\text{SignExt}(\\text{imm})$, then $MAR \\leftarrow ALUOut$ via the System Bus (SB)), memory read ($MDR \\leftarrow M[MAR]$), and write-back ($\\text{Reg}[rt] \\leftarrow MDR$). For a store word instruction, the effective address and memory write are similar, but the data written is $B$.\n\nConsider the following instrumented execution with per-state snapshots for the sequence: $\\mathrm{lw}\\ r2, 8(r1)$ followed by $\\mathrm{sw}\\ r3, 12(r1)$. Initial conditions are $PC = \\mathrm{0x00400000}$, $\\text{Reg}[r1] = \\mathrm{0x1000}$, $\\text{Reg}[r2] = \\mathrm{0x5555AAAA}$, $\\text{Reg}[r3] = \\mathrm{0xDEADBEEF}$. Memory contents include $M[\\mathrm{0x1008}] = \\mathrm{0xABCD1234}$, $M[\\mathrm{0x100C}] = \\mathrm{0x13579BDF}$, $M[\\mathrm{0x5555AAAA}] = \\mathrm{0xCAFEBABE}$, and $M[\\mathrm{0xDEADBEEF}] = \\mathrm{0x2468ACE0}$.\n\nObserved snapshots for $\\mathrm{lw}\\ r2, 8(r1)$:\n- End of decode: $A = \\mathrm{0x1000}$, $B = \\mathrm{0x5555AAAA}$, $IR$ immediate $= \\mathrm{0x0008}$.\n- End of effective address state: $ALUOut = \\mathrm{0x1008}$, $MAR = \\mathrm{0x5555AAAA}$.\n- End of memory read: $MDR = \\mathrm{0xCAFEBABE}$.\n- End of write-back: $\\text{Reg}[r2] = \\mathrm{0xCAFEBABE}$.\n\nObserved snapshots for $\\mathrm{sw}\\ r3, 12(r1)$:\n- End of decode: $A = \\mathrm{0x1000}$, $B = \\mathrm{0xDEADBEEF}$, $IR$ immediate $= \\mathrm{0x000C}$.\n- End of effective address state: $ALUOut = \\mathrm{0x100C}$, $MAR = \\mathrm{0xDEADBEEF}$.\n- End of memory write: $M[\\mathrm{0xDEADBEEF}] = \\mathrm{0xDEADBEEF}$, while $M[\\mathrm{0x100C}]$ remains $\\mathrm{0x13579BDF}$.\n\nFrom first-principles operation of the multicycle datapath, the fundamental base is:\n- The effective address for load/store is computed by the ALU as $A + \\text{SignExt}(\\text{imm})$ and should be latched into $ALUOut$.\n- The Memory Address Register (MAR) must latch this ALU-produced effective address by sampling the System Bus (SB) when $ALUOut$ is gated onto the System Bus (SB) and $MARWrite$ is asserted.\n- The $B$ register holds the second register file read operand and is not an address source for MAR in the effective address state.\n\nBased on the provided per-state snapshots, select the single most likely faulty control that explains the behavior, and which would be isolated by a debugging plan that compares $ALUOut$, $MAR$, and the System Bus (SB) driver selections in the effective address state:\nA. In the effective address state, $GateB$ is erroneously asserted while $GateALUOut$ is deasserted, so $MAR$ latches $B$ when $MARWrite$ is asserted.\nB. $ALUSrcB$ is misconfigured to select the constant $4$, causing $ALUOut$ to be $A + 4$, which then misleads $MAR$; the snapshots show $MAR$ differs because $ALUOut$ is wrong.\nC. $IRWrite$ was misasserted during instruction fetch, corrupting $IR$ so that decode read the wrong registers; this led $MAR$ to pick up $B$ indirectly.\nD. $PCWrite$ is erroneously asserted during the effective address state, advancing $PC$ and corrupting the address path to $MAR$, which then reflects $B$ instead of the ALU result.", "solution": "To diagnose the fault, we must analyze the execution snapshots provided for both the `lw r2, 8(r1)` and `sw r3, 12(r1)` instructions, comparing the observed behavior to the intended operation of the multicycle datapath during the effective address calculation state.\n\n**Analysis of `lw r2, 8(r1)`**\n-   **Intended Behavior:** In the effective address state, the ALU should compute the address `Reg[r1] + 8 = 0x1000 + 0x8 = 0x1008`. This value should be latched into `ALUOut`. Then, `ALUOut` should be gated onto the System Bus (SB), and the Memory Address Register (MAR) should latch this value, making `MAR = 0x1008`.\n-   **Observed Behavior:** The snapshot shows that `ALUOut` correctly contains `0x1008`. However, `MAR` contains `0x5555AAAA`. This value corresponds to the initial contents of `r2`, which was read into the `B` register output during the decode stage.\n-   **Conclusion:** The ALU is functioning correctly, but the `MAR` is being loaded from the `B` register output instead of the `ALUOut` latch.\n\n**Analysis of `sw r3, 12(r1)`**\n-   **Intended Behavior:** The ALU should compute `Reg[r1] + 12 = 0x1000 + 0xC = 0x100C`. This value should be loaded into `MAR`. The subsequent memory write should be to address `0x100C`.\n-   **Observed Behavior:** The snapshot shows `ALUOut` is `0x100C`, but `MAR` is `0xDEADBEEF`. This value corresponds to the contents of `r3`, which was read into the `B` register output. Consequently, the memory write occurs to the wrong address (`M[0xDEADBEEF] = 0xDEADBEEF`).\n-   **Conclusion:** The fault is consistent across both instructions. The `MAR` is incorrectly sourcing its data from the `B` register.\n\n**Fault Diagnosis**\nThe transfer of data to `MAR` occurs via the System Bus (SB). The source driving the bus is selected by gating control signals. The intended source is `ALUOut` (enabled by `GateALUOut`), but the observed source is the `B` register output (which would be enabled by a `GateB` signal). Since `MAR` is being written, `MARWrite` must be asserted correctly. Therefore, the single point of failure is that in the effective address state, the control logic is erroneously asserting `GateB` instead of `GateALUOut`.\n\n**Evaluation of Options**\n-   **A. In the effective address state, $GateB$ is erroneously asserted while $GateALUOut$ is deasserted, so $MAR$ latches $B$ when $MARWrite$ is asserted.** This precisely matches our diagnosis.\n-   **B. $ALUSrcB$ is misconfigured...** This is incorrect. The snapshots show that `ALUOut` has the correct value, so the ALU inputs and operation are correct.\n-   **C. $IRWrite$ was misasserted...** This is incorrect. The decode stage snapshots show that the correct register values were read, meaning the `IR` was not corrupt.\n-   **D. $PCWrite$ is erroneously asserted...** This is incorrect. A fault with `PCWrite` would affect the Program Counter and does not explain how the value from the `B` register would be routed to the `MAR`.\n\nThe most likely faulty control is described in option A.", "answer": "$$\\boxed{A}$$", "id": "3660319"}, {"introduction": "Some of the most difficult bugs to diagnose are not simple data misrouting but subtle errors in arithmetic logic and its interaction with control signals across states. This advanced practice explores such a scenario, where an incorrect sequence of shifting and sign-extending an immediate value leads to a critical failure in branch address calculation. Solving this problem requires a deep and precise understanding of how data is transformed at each stage of the datapath, honing your skills for tackling complex, real-world design challenges. [@problem_id:3660294]", "problem": "A multi-cycle centralized-control datapath for a subset of the Microprocessor without Interlocked Pipeline Stages (MIPS) architecture is used to execute branch-immediate instructions. The datapath includes a Program Counter (PC), an Instruction Register (IR), a Register File (RF), an Arithmetic Logic Unit (ALU), a sign-extension unit mapping $16$-bit two’s-complement fields to $32$ bits, and a Shift-Left-by-Two unit used for branch offsets. Control signals drive multiplexers for the ALU inputs: $ALUSrcA \\in \\{0,1\\}$ selects between $PC$ and the $A$ register; $ALUSrcB \\in \\{0,1,2,3\\}$ selects between the $B$ register, constant $4$, the sign-extended immediate, or the sign-extended immediate shifted left by two. The controller also asserts $PCWrite$, $PCWriteCond$, and $PCSource$ to update $PC$ with either $ALU$ or $ALUOut$. A Boolean control $ExtSign$ enables sign-extension where applicable. The Instruction Register holds fields $IR[31:26]$ (opcode), $IR[25:21]$ ($rs$), $IR[20:16]$ ($rt$), and $IR[15:0]$ (immediate).\n\nFundamental definitions:\n- Two’s-complement sign-extension from $n$ bits to $m$ bits replicates the sign bit: for an $n$-bit value $x$ with most-significant bit $x_{n-1}$, the extended value is $x$ with bits $[m-1:n]$ filled with $x_{n-1}$.\n- The effective branch target for branch-equal (BEQ) is computed conceptually as $PC_{next} = PC + 4 + (\\text{sign-extended } IR[15:0]) \\ll 2$. In the multi-cycle datapath, $PC$ is incremented by $4$ during instruction fetch, so the branch adder in the execute cycle adds $(\\text{sign-extended } IR[15:0]) \\ll 2$ to the already incremented $PC$.\n\nConsider the following specific execution of a BEQ instruction with $IR[15:0] = 0xC000$ (interpreted as a $16$-bit two’s-complement value), $rs = rt$, and initial $PC = 0x00400000$. The controller sequences are:\n- Fetch state $S_0$: $IorD = 0$, memory read, $IRWrite = 1$, $ALUSrcA = 0$, $ALUSrcB = 1$ to form $PC + 4$ in $ALU$, $PCSource = 0$ selects $ALU$, $PCWrite = 1$, advancing $PC$ to $PC + 4 = 0x00400004$.\n- Decode state $S_1$: the RF is read, the sign-extension unit is enabled with $ExtSign = 1$ to produce a $32$-bit $SignImm = \\text{SignExt}_{16 \\rightarrow 32}(IR[15:0])$, and the Shift-Left-by-Two unit forms $ShiftImm = SignImm \\ll 2$.\n- Execute state $S_2$ for BEQ: the controller asserts $ALUSrcA = 0$ to select $PC$, $ALUSrcB = 3$ to select the shifted immediate path, $ALUOp = add$, $PCSource = 0$ to route the $ALU$ sum to $PC$ if the branch is taken, and $PCWriteCond = 1$. Due to a wiring mistake, the selected path for $ALUSrcB = 3$ is implemented as $\\text{SignExt}_{18 \\rightarrow 32}(IR[15:0] \\ll 2)$ gated by $ExtSign$, rather than $\\left(\\text{SignExt}_{16 \\rightarrow 32}(IR[15:0])\\right) \\ll 2$. Moreover, $ExtSign$ remains asserted in $S_2$, so sign-extension is effectively applied twice: once in $S_1$ to $16$ bits and again in $S_2$ to the $18$-bit shifted quantity.\n\nAssume the branch comparison is true and taken. Determine the incorrect $PC$ update that results from the described control signaling, and choose the option that correctly identifies the precise state-signal cause of the error and proposes a fix that restores correct immediate arithmetic for branches and other immediate operations without breaking zero-extended immediates (e.g., AND immediate, OR immediate).\n\nOptions:\n- A. The error is caused by asserting $ExtSign = 1$ in both $S_1$ and $S_2$ while the $ALUSrcB = 3$ datapath computes $\\text{SignExt}_{18 \\rightarrow 32}(IR[15:0] \\ll 2)$ in $S_2$, so the branch offset is sign-extended after shifting rather than before. This double extension changes negative offsets to positive for cases like $IR[15:0] = 0xC000$, producing $PC \\leftarrow 0x00400004 + 0x00030000 = 0x00430004$ instead of $PC \\leftarrow 0x00400004 + 0xFFFF0000 = 0x003F0004$. Fix by deasserting $ExtSign$ in $S_2$ and feeding the ALU with $\\left(\\text{SignExt}_{16 \\rightarrow 32}(IR[15:0])\\right) \\ll 2$ computed once, or equivalently by restructuring the $ALUSrcB = 3$ path to shift after the single sign-extension performed in $S_1$.\n- B. The error arises because $ZeroExt = 1$ in $S_1$, zero-extending $IR[15:0]$ instead of sign-extending it, so negative offsets are treated as positive. Fix by hardwiring $ExtSign = 1$ for all immediates, including logical immediates.\n- C. The error is caused by $PCSource$ selecting the wrong input ($PC + 4$) in $S_2$. Fix by setting $PCSource$ to select $ALUOut$ and delaying $PCWrite$ to $S_3$.\n- D. The error is caused by $ALUSrcA = 1$ in $S_2$, which selects the $A$ register rather than $PC$, so the ALU adds the shifted immediate to a register value. Fix by setting $ALUSrcA = 0$ and leaving other signals unchanged.", "solution": "To solve this problem, we must first calculate the correct branch target address according to the MIPS specification. Then, we will calculate the incorrect target address that results from the described hardware and control fault. By comparing the two, we can identify the precise nature of the error and evaluate the given options.\n\n**1. Correct Branch Target Address Calculation**\n\nThe MIPS `beq` instruction uses a 16-bit signed immediate word offset. This offset must be sign-extended to 32 bits and then multiplied by 4 (shifted left by 2) to get the byte offset.\n- **Immediate:** $IR[15:0] = 0xC000$. As a 16-bit two's-complement number, its sign bit is 1, so it is negative.\n- **Sign-Extension:** Sign-extending $0xC000$ to 32 bits yields $0xFFFFC000$.\n- **Byte Offset:** Shifting this value left by 2 gives the byte offset: $0xFFFFC000 \\ll 2 = 0xFFFF0000$.\n- **Base PC:** During the fetch state ($S_0$), the PC was already incremented to point to the next sequential instruction: $PC = 0x00400000 + 4 = 0x00400004$.\n- **Correct Target Address:** The branch target is the sum of the updated PC and the byte offset:\n  $$PC_{correct} = 0x00400004 + 0xFFFF0000 = 0x003F0004$$\n\n**2. Faulty Branch Target Address Calculation**\n\nThe problem describes a wiring mistake where the branch offset calculation is implemented as $\\text{SignExt}_{18 \\rightarrow 32}(IR[15:0] \\ll 2)$. This means the 16-bit immediate is first shifted left by 2, and the resulting 18-bit value is then sign-extended.\n- **Shift Operation:** The 16-bit value $0xC000$ is shifted left by 2. This produces the 18-bit value $0x30000$, which is $011000000000000000_2$.\n- **Faulty Sign-Extension:** The sign bit of this 18-bit intermediate value is its most significant bit ($bit_{17}$), which is $0$. When this value is sign-extended to 32 bits, the upper 14 bits are filled with zeros.\n- **Faulty Offset:** The resulting 32-bit offset is $0x00030000$.\n- **Incorrect Target Address:** The ALU adds the faulty offset to the updated PC:\n  $$PC_{incorrect} = 0x00400004 + 0x00030000 = 0x00430004$$\nThe error converts a large negative branch offset into a large positive one because the sign extension is performed *after* the shift, using the wrong sign bit.\n\n**3. Evaluation of Options**\n\n-   **A:** This option correctly identifies the error as sign-extending *after* shifting, and it accurately calculates both the faulty result ($0x00430004$) and the correct result ($0x003F0004$). The proposed fix of restructuring the datapath to perform the operations in the correct order (extend, then shift) is sound. This is the correct diagnosis.\n-   **B:** This option incorrectly claims the value was zero-extended. The problem states sign-extension was used, albeit on the wrong intermediate value. The proposed fix is also incorrect as it would break logical immediates.\n-   **C:** This option blames the $PCSource$ signal, but selecting the ALU output is the correct action for a branch. The error is in the ALU *operand*, not the selection of its result.\n-   **D:** This option claims the wrong ALU input A was selected ($ALUSrcA$), but the problem states the controller correctly selected the PC ($ALUSrcA=0$).\n\nTherefore, option A provides the only accurate description of the fault and its consequences.", "answer": "$$\\boxed{A}$$", "id": "3660294"}]}