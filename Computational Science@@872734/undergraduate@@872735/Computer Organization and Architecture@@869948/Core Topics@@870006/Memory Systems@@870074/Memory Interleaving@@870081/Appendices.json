{"hands_on_practices": [{"introduction": "Understanding memory interleaving begins with the fundamental skill of mapping a physical memory address to its corresponding bank. This exercise provides a concrete scenario where you must first perform a simple address translation to find the physical address, a common step in modern computer systems. You will then apply the low-order interleaving rule to pinpoint exactly which memory bank services the request, solidifying your grasp of this core mechanism [@problem_id:1941843].", "problem": "A 32-bit computer system implements a simplified memory management unit (MMU) based on segmentation. In this scheme, a logical address is composed of a segment number and an offset. The physical address is computed by adding the offset to the base address of the specified segment. The system's main memory is constructed using a 4-way low-order interleaving architecture, where the memory banks are indexed as 0, 1, 2, and 3. For any given physical address `P`, the servicing memory bank `B` is determined by the formula `B = P mod 4`.\n\nThe segment table for the system is partially defined as follows:\n- Segment 0 Base Address: `$2C00A000_{16}$`\n- Segment 1 Base Address: `$A1B2C000_{16}$`\n- Segment 2 Base Address: `$F01D3000_{16}$`\n\nA process requires access to data located at the logical address corresponding to segment number 1 with an offset of `$0000F7A6_{16}$`.\n\nDetermine the index of the memory bank that will service this request. Provide your answer as a single integer.", "solution": "A logical address in this segmented scheme translates to a physical address by adding the offset to the base of the selected segment. Therefore, for segment number 1 with base $A1B2C000_{16}$ and offset $0000F7A6_{16}$, the physical address $P$ is\n$$\nP = A1B2C000_{16} + 0000F7A6_{16}.\n$$\nAdd using 16-bit parts to show carry explicitly:\n$$\n\\text{low }16\\text{-bit: } C000_{16} + F7A6_{16} = 1B7A6_{16} \\Rightarrow \\text{low }16\\text{-bit of }P = B7A6_{16},\\; \\text{carry } c=1,\n$$\n$$\n\\text{high }16\\text{-bit: } A1B2_{16} + 0000_{16} + c = A1B3_{16}.\n$$\nThus,\n$$\nP = A1B3B7A6_{16}.\n$$\nWith 4-way low-order interleaving, the servicing bank index is given by $B = P \\bmod 4$. Since modulo $4$ depends only on the last two bits (equivalently, the last hexadecimal digit), and the last hex digit of $P$ is $6$, we have\n$$\nB = 6 \\bmod 4 = 2.\n$$\nTherefore, the memory bank index is $2$.", "answer": "$$\\boxed{2}$$", "id": "1941843"}, {"introduction": "Having grasped the mapping mechanism, we now turn to the 'why' of memory interleaving: performance. The ultimate goal is to increase memory bandwidth by allowing multiple banks to service requests in parallel. This problem challenges you to think like a system architect by modeling the relationship between the number of banks, the service time of each bank, and the maximum sustainable request rate, revealing the fundamental trade-offs in memory system design [@problem_id:3657527].", "problem": "A shared main memory is organized as $N$ identical banks using perfect low-order interleaving. Each bank has a fixed service time of $t_b$ processor cycles from request issue to the instant it is ready to accept a new request for that bank. Assume the following fundamental facts and conditions:\n- In steady state, the maximum completion rate of an isolated server equals the reciprocal of its deterministic service time, so a single bank can complete at most $1/t_b$ requests per cycle.\n- Perfect low-order interleaving uniformly distributes consecutive memory block addresses across the $N$ banks, allowing the memory controller to schedule one new request per cycle as long as it targets a different bank than those that are still busy.\n- There are no additional bottlenecks: the interconnect and controller can issue up to $1$ request each cycle provided an eligible bank exists, there are no bank conflicts beyond the per-bank service time, and there are no extra turnaround or bus penalties.\n\nYou wish to sustain a steady request arrival rate of $r$ requests per cycle with no unbounded queue growth under these conditions. Let $t_b = 4$ cycles per bank. Determine, as a closed-form expression in terms of $r$, the minimal integer number of banks $N$ required to sustain the rate $r$ under perfect interleaving and the assumptions above. Your final answer must be a single analytic expression. Do not include units. If any rounding is needed, ensure the result reflects the minimal integer that satisfies the requirement.", "solution": "The problem asks for the minimal integer number of memory banks, $N$, required to sustain a steady request arrival rate of $r$ requests per cycle, given a fixed bank service time of $t_b = 4$ cycles.\n\nThe analysis begins with the fundamental condition for system stability: to prevent unbounded queue growth, the maximum sustainable service rate of the memory system, which we denote as its throughput $T$, must be greater than or equal to the arrival rate $r$.\n$$\nT \\ge r\n$$\n\nNext, we establish a model for the system's maximum throughput, $T$. The throughput is constrained by two primary factors as described in the problem statement:\n1.  **The Memory Controller Bottleneck**: The problem states that the memory controller can issue at most $1$ request per cycle. This imposes an upper bound on the system's throughput, regardless of the number of banks or their speed.\n    $$\n    T \\le 1 \\text{ request/cycle}\n    $$\n    This also implies that for the problem to be solvable, the target arrival rate $r$ cannot exceed this limit, so we must have $r \\le 1$.\n\n2.  **The Aggregate Bank Bandwidth**: The memory system consists of $N$ identical banks. Each bank has a service time of $t_b$ cycles. As stated, the maximum completion rate of a single bank is the reciprocal of its service time, which is $1/t_b$ requests per cycle. With $N$ banks operating in parallel, and assuming perfect interleaving allows for their independent operation, the total theoretical maximum bandwidth they can provide is the sum of their individual maximum rates.\n    $$\n    T \\le N \\times \\frac{1}{t_b} = \\frac{N}{t_b}\n    $$\n\nThe actual maximum throughput of the system, $T_{max}$, is the minimum of these two limiting factors.\n$$\nT_{max} = \\min\\left(1, \\frac{N}{t_b}\\right)\n$$\n\nNow, we apply the stability condition, $T_{max} \\ge r$.\n$$\n\\min\\left(1, \\frac{N}{t_b}\\right) \\ge r\n$$\nThis inequality must hold true. It decomposes into two separate conditions:\n1.  $1 \\ge r$, which is the constraint on the input rate mentioned earlier.\n2.  $\\frac{N}{t_b} \\ge r$.\n\nThe second condition gives us the relationship between the number of banks $N$ and the rate $r$ that we need to solve for.\n$$\n\\frac{N}{t_b} \\ge r\n$$\nMultiplying both sides by $t_b$ (a positive quantity), we get the minimum requirement for $N$.\n$$\nN \\ge r \\cdot t_b\n$$\n\nThe problem provides the specific value for the bank service time, $t_b = 4$ cycles. Substituting this value into the inequality:\n$$\nN \\ge r \\cdot 4\n$$\n$$\nN \\ge 4r\n$$\n\nThe problem asks for the minimal **integer** number of banks, $N$, that satisfies this condition. For a given value of $r$, the smallest integer $N$ that is greater than or equal to the real number $4r$ is, by definition, the ceiling of $4r$.\nTherefore, the minimal required number of banks is:\n$$\nN_{min} = \\lceil 4r \\rceil\n$$\nThis expression provides the minimal integer $N$ for any valid sustained request rate $r$ (where $0  r \\le 1$). For instance, if $r=0.5$, $N_{min}=\\lceil 4 \\times 0.5 \\rceil = \\lceil 2 \\rceil = 2$. If $r=1$, $N_{min}=\\lceil 4 \\times 1 \\rceil = \\lceil 4 \\rceil = 4$. This is consistent with the classic result that the number of banks must at least equal the bank latency in cycles to hide the latency completely and achieve a throughput of $1$ request per cycle. The formula correctly generalizes this for rates less than $1$.", "answer": "$$\n\\boxed{\\lceil 4r \\rceil}\n$$", "id": "3657527"}, {"introduction": "Achieving the theoretical bandwidth of an interleaved memory system in practice depends critically on the memory access pattern. This final practice delves into a sophisticated optimization problem common in vector processing and high-performance computing. You will analyze how strided memory accesses interact with bank mapping and determine a stride that guarantees zero bank conflicts, thereby maximizing memory parallelism and fully exploiting the interleaved architecture [@problem_id:3632697].", "problem": "A Central Processing Unit (CPU) executes a vector $LOAD$ that fetches elements from a one-dimensional array stored in $n$-way interleaved main memory. The memory system is organized as follows.\n\n- There are $n$ independent memory banks arranged for cyclic interleaving of consecutive words, where $n = 12$.\n- The interleaving unit is one word of size $w$ bytes, where $w = 8$.\n- By definition of cyclic interleaving of consecutive words across $n$ banks, the word at byte address $A$ is placed in bank $0$, bank $1$, â€¦, bank $n-1$, and then wraps around, repeating this pattern.\n- The vector $LOAD$ accesses elements with a stride of $s$ words, starting at a base address $A_0$ that is aligned to the word size $w$.\n- The CPU issues $W$ memory requests per cycle for the $LOAD$, where $W = 4$.\n- Each memory bank can accept at most one request per cycle, and after accepting a request, the bank remains busy for $t_b$ cycles (including the arrival cycle), where $t_b = 3$. During its busy period, a bank cannot accept another request.\n\nStarting from the definition of cyclic interleaving of words across banks and the meaning of stride addressing, first derive the address-to-bank mapping function $b(A)$ in terms of $A$, $w$, and $n$. Then, using only reasoning from these base definitions and standard properties of modular arithmetic, determine the smallest positive integer stride $s  1$ (measured in words) that guarantees zero bank conflicts for this vector $LOAD$ regardless of the base address $A_0$. Zero bank conflicts means that within any window of $t_b$ consecutive cycles, none of the $W \\cdot t_b$ simultaneously or recently issued requests target the same memory bank.\n\nExpress the final answer as an integer. No rounding is required.", "solution": "The problem asks for two results: first, the derivation of the address-to-bank mapping function, and second, the determination of the smallest positive integer stride $s  1$ that guarantees zero bank conflicts for a specific vector load operation on an interleaved memory system.\n\nFirst, let us formalize the givens:\n- Number of memory banks: $n = 12$.\n- Word size: $w = 8$ bytes.\n- Interleaving scheme: cyclic interleaving of consecutive words.\n- Number of memory requests issued per cycle: $W = 4$.\n- Bank busy time: $t_b = 3$ cycles.\n- Stride of vector access: $s$ words, where $s$ is an integer and $s  1$.\n- Base address $A_0$ is word-aligned.\n\nPart 1: Derivation of the Address-to-Bank Mapping Function $b(A)$\n\nThe memory is interleaved by words. The byte address $A$ of a memory location must first be converted to a word index. Since the word size is $w$ bytes and addressing is word-aligned, any valid byte address $A$ for the start of a word is a multiple of $w$. The word index, which we denote as $i$, corresponding to a byte address $A$ is given by the integer division:\n$$ i = \\frac{A}{w} $$\nThe problem states that the memory uses cyclic interleaving of consecutive words across $n$ banks. This means that word with index $i=0$ is stored in bank $0$, word with index $i=1$ is in bank $1$, ..., word with index $i=n-1$ is in bank $n-1$. The pattern then repeats, so word with index $i=n$ is in bank $0$, and so on. This mapping is described by the modulo operation. The bank number $b(i)$ for a word with index $i$ is:\n$$ b(i) = i \\pmod{n} $$\nTo find the mapping function $b(A)$ in terms of the byte address $A$, we substitute the expression for the word index $i$ into the bank mapping function:\n$$ b(A) = \\left(\\frac{A}{w}\\right) \\pmod{n} $$\nThis is the required address-to-bank mapping function.\n\nPart 2: Determination of the Smallest Stride $s  1$ for Zero Bank Conflicts\n\nThe vector $LOAD$ operation accesses elements with a stride of $s$ words. The CPU issues $W=4$ requests per cycle. This implies a pipelined or parallel access pattern where the requests issued in a single cycle correspond to $W$ vector elements separated by the stride $s$. For example, in the first cycle (cycle $0$), requests are made for words at indices $i_0, i_0+s, i_0+2s, \\dots, i_0+(W-1)s$, where $i_0 = A_0/w$ is the word index corresponding to the base address $A_0$. In cycle $1$, requests are made for words at indices $i_0+Ws, \\dots, i_0+(2W-1)s$, and so on.\n\nThe condition for \"zero bank conflicts\" is stated as: \"within any window of $t_b$ consecutive cycles, none of the $W \\cdot t_b$ simultaneously or recently issued requests target the same memory bank.\"\nLet's analyze the requests made in a window of $t_b$ cycles, for instance, from cycle $0$ to cycle $t_b-1$.\n- At cycle $0$, requests are for words with indices $i_0+k \\cdot s$ for $k \\in \\{0, 1, \\dots, W-1\\}$.\n- At cycle $1$, requests are for words with indices $i_0+k \\cdot s$ for $k \\in \\{W, W+1, \\dots, 2W-1\\}$.\n- ...\n- At cycle $t_b-1$, requests are for words with indices $i_0+k \\cdot s$ for $k \\in \\{(t_b-1)W, \\dots, t_b W-1\\}$.\n\nThe total number of requests in this window is $W \\cdot t_b$. The indices of the words accessed over these $t_b$ cycles form a continuous sequence with respect to the access pattern:\n$$ i_k' = i_0 + k \\cdot s \\quad \\text{for } k = 0, 1, 2, \\dots, W \\cdot t_b - 1 $$\nThe bank number for each of these requests is given by $b(i_k') = i_k' \\pmod n$.\n$$ b_k = (i_0 + k \\cdot s) \\pmod n \\quad \\text{for } k = 0, 1, 2, \\dots, W \\cdot t_b - 1 $$\nThe condition for zero bank conflicts means that all these $W \\cdot t_b$ bank numbers, $\\{b_0, b_1, \\dots, b_{Wt_b-1}\\}$, must be distinct.\n\nLet's substitute the given values: $n = 12$, $W = 4$, and $t_b = 3$.\nThe number of requests in the window is $W \\cdot t_b = 4 \\times 3 = 12$.\nSo, we require the $12$ bank numbers $b_k$ for $k = 0, 1, \\dots, 11$ to be distinct.\nThe bank numbers are given by the sequence:\n$$ (i_0 \\pmod{12}), ((i_0+s) \\pmod{12}), ((i_0+2s) \\pmod{12}), \\dots, ((i_0+11s) \\pmod{12}) $$\nThe total number of available banks is $n=12$. Since we need to access $12$ distinct banks, the set of accessed banks must be the complete set of all available banks, which is $\\{0, 1, 2, \\dots, 11\\}$.\n\nThe problem requires this condition to hold regardless of the base address $A_0$, which means it must hold for any starting word index $i_0$.\nWe are looking for a condition on the stride $s$ such that the set of residues $\\{ (i_0 + k \\cdot s) \\pmod{12} \\mid k = 0, 1, \\dots, 11 \\}$ is equal to the set of all residues modulo $12$, i.e., $\\{0, 1, \\dots, 11\\}$, for any integer $i_0$.\n\nThis is a standard result from modular arithmetic. An arithmetic progression of length $m$ with common difference $d$, i.e., $\\{a, a+d, a+2d, \\dots, a+(m-1)d\\}$, covers all residues modulo $m$ if and only if the common difference $d$ is coprime to the modulus $m$. That is, $\\gcd(d, m) = 1$. The starting value $a$ does not affect whether the full set of residues is generated.\n\nIn our problem, the starting value is $a=i_0$, the common difference is $d=s$, and the modulus is $m=n=12$.\nTherefore, the condition for guaranteed zero bank conflicts, regardless of the starting address, is:\n$$ \\gcd(s, n) = 1 $$\nSubstituting $n=12$, the condition becomes:\n$$ \\gcd(s, 12) = 1 $$\nWe are asked to find the smallest positive integer stride $s  1$ that satisfies this condition. We need to find the smallest integer $s  1$ that is coprime to $12$. The prime factorization of $12$ is $2^2 \\cdot 3$. An integer is coprime to $12$ if it is not divisible by $2$ and not divisible by $3$. Let's test integers $s  1$:\n- For $s=2$: $\\gcd(2, 12) = 2 \\neq 1$. Not valid.\n- For $s=3$: $\\gcd(3, 12) = 3 \\neq 1$. Not valid.\n- For $s=4$: $\\gcd(4, 12) = 4 \\neq 1$. Not valid.\n- For $s=5$: $5$ is a prime number and does not divide $12$. So, $\\gcd(5, 12) = 1$. This is a valid stride.\n\nSince we are looking for the smallest integer $s  1$, and we have found that $s=2, 3, 4$ are not valid, $s=5$ is the smallest integer greater than $1$ that satisfies the condition.", "answer": "$$\\boxed{5}$$", "id": "3632697"}]}