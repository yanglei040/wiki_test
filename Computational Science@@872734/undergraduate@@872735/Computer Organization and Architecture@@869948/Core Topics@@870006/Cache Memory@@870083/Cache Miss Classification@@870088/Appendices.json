{"hands_on_practices": [{"introduction": "To truly master the classification of cache misses, it is essential to understand the pure, unadulterated form of a conflict miss. This exercise constructs a synthetic memory trace designed specifically to induce 'cache thrashing'—a worst-case scenario where a set is bombarded with more data blocks than it can hold. By analyzing this carefully crafted pattern [@problem_id:3625442], you will derive a general formula for conflict misses and see precisely why they are distinct from capacity misses, building a foundational understanding of how set-associativity limits performance.", "problem": "Consider a set-associative cache in a computer system with the following parameters: associativity $A$ (number of lines per set), number of sets $S$ with $S \\geq 2$, and cache line size $L$ bytes, where $L$ is a positive power of $2$. The cache uses Least Recently Used (LRU) replacement and is initially empty (cold start). Addresses are mapped to sets by computing the block address $b = \\left\\lfloor \\frac{\\text{address}}{L} \\right\\rfloor$ and then the set index $s = b \\bmod S$. The tag is the remaining higher-order bits beyond the set index.\n\nLet $a_{0}$ be a base address chosen such that $a_{0}$ is aligned to a cache line boundary, that is, $a_{0} = q L$ for an integer $q$. Define a sequence of $A+1$ distinct addresses\n$$a_{j} = a_{0} + j \\cdot S \\cdot L \\quad \\text{for } j \\in \\{0, 1, \\dots, A\\},$$\nand consider the synthetic memory reference trace that repeatedly cycles through these $A+1$ addresses in fixed order:\n$$(a_{0}, a_{1}, \\dots, a_{A}) \\quad \\text{repeated for } N \\text{ full cycles},$$\nfor a total of $T = N \\cdot (A+1)$ references.\n\nUsing the fundamental cache mapping and miss-type definitions (compulsory, capacity, conflict), analyze this trace under LRU replacement. In particular, justify from first principles why the misses that occur after the first time each distinct block is referenced are not capacity misses, and deduce the exact count of conflict misses over the entire trace as a closed-form analytic expression in terms of $A$ and $N$. Your final answer must be a single expression in $A$ and $N$; no rounding is required.", "solution": "The problem requires an analysis of cache misses for a specific memory reference trace on a set-associative cache. The analysis must classify misses as compulsory, capacity, or conflict, provide a justification for why certain misses are not capacity misses, and derive a closed-form expression for the total number of conflict misses. The analysis proceeds in three steps: first, determining how the specified addresses map to cache sets; second, analyzing the evolution of the cache state over the trace; and third, applying the formal definitions of miss types to quantify the conflict misses.\n\n**Step 1: Address-to-Set Mapping**\n\nThe cache is defined by its associativity $A$, number of sets $S$, and line size $L$. The mapping of a memory address to a cache set is a two-step process. First, the address is converted to a block address $b$, and then the block address is mapped to a set index $s$.\n\nThe block address is given by $b = \\lfloor \\frac{\\text{address}}{L} \\rfloor$.\nThe set index is given by $s = b \\bmod S$.\n\nThe memory trace consists of a sequence of $A+1$ distinct addresses, defined as $a_{j} = a_{0} + j \\cdot S \\cdot L$ for $j \\in \\{0, 1, \\dots, A\\}$. The base address $a_0$ is aligned to a cache line boundary, meaning $a_{0} = qL$ for some integer $q$.\n\nLet us compute the block address $b_j$ corresponding to the address $a_j$:\n$$b_j = \\left\\lfloor \\frac{a_j}{L} \\right\\rfloor = \\left\\lfloor \\frac{a_0 + j \\cdot S \\cdot L}{L} \\right\\rfloor = \\left\\lfloor \\frac{qL + jSL}{L} \\right\\rfloor = \\lfloor q + jS \\rfloor$$\nSince $q$, $j$, and $S$ are integers, the floor operation is trivial:\n$$b_j = q + jS$$\n\nNext, let us compute the set index $s_j$ to which block $b_j$ maps:\n$$s_j = b_j \\bmod S = (q + jS) \\bmod S$$\nUsing the properties of modular arithmetic, specifically $(x + yz) \\bmod z = x \\bmod z$, we find:\n$$s_j = q \\bmod S$$\nThis result is independent of the index $j$. It demonstrates that all $A+1$ distinct blocks, $b_0, b_1, \\dots, b_A$, referenced in the trace map to the exact same cache set, indexed by $s = q \\bmod S$. The cache set has an associativity of $A$, meaning it contains $A$ lines or ways. The trace attempts to access $A+1$ distinct blocks that all compete for the $A$ available lines within this single set.\n\n**Step 2: Trace Analysis and Cache State Evolution**\n\nThe trace consists of $N$ full cycles of the sequence $(a_{0}, a_{1}, \\dots, a_{A})$. The cache is initially empty (cold start).\n\n**First Cycle ($1^{st}$ repetition):**\nThe first cycle consists of the accesses $a_0, a_1, \\dots, a_A$.\n- **Access to $a_0$:** The cache is empty. Block $b_0$ is not in the cache, resulting in a miss. This is the first access to this block, so it is classified as a **compulsory miss**. Block $b_0$ is loaded into the target set.\n- **Access to $a_1$:** Block $b_1$ is not in the cache, resulting in a miss. This is the first access to $b_1$, so it is a **compulsory miss**. Block $b_1$ is loaded into the same set.\n- ...\n- **Access to $a_A$:** This is the $(A+1)$-th access in the cycle. By the time $a_{A-1}$ is accessed, blocks $b_0, b_1, \\dots, b_{A-1}$ occupy all $A$ lines of the target set. The access to $a_A$ is the first access to block $b_A$, so it is a **compulsory miss**. Since the set is full, the LRU replacement policy requires evicting the least recently used block. In the sequence of accesses $(a_0, a_1, \\dots, a_{A-1})$, the least recently used block is $b_0$. Thus, $b_0$ is evicted to make room for $b_A$.\n\nIn this first cycle, there are $A+1$ accesses. Each is the first reference to a unique block, resulting in $A+1$ compulsory misses. At the end of the first cycle, the target cache set contains the blocks $\\{b_1, b_2, \\dots, b_A\\}$.\n\n**Subsequent Cycles ($2^{nd}$ to $N^{th}$ repetition):**\nLet's analyze the second cycle. The state of the target set holds $\\{b_1, b_2, \\dots, b_A\\}$, with $b_1$ being the LRU block and $b_A$ being the most recently used (MRU).\n- **Access to $a_0$:** Block $b_0$ is not in the set (it was evicted by $b_A$). This is a miss. As $b_0$ has been accessed before, this is not a compulsory miss. The LRU block, $b_1$, is evicted and $b_0$ is loaded, becoming the MRU block. The set now contains $\\{b_2, b_3, \\dots, b_A, b_0\\}$.\n- **Access to $a_1$:** Block $b_1$ is not in the set (it was just evicted by $b_0$). This is a miss. The new LRU block, $b_2$, is evicted and $b_1$ is loaded. The set now contains $\\{b_3, \\dots, b_A, b_0, b_1\\}$.\nThis pattern, known as thrashing, continues. Each access in the sequence $(a_0, a_1, \\dots, a_A)$ results in a miss, evicting the block that will be needed shortly thereafter. Specifically, the access to $a_j$ for $j \\in \\{0, \\dots, A-1\\}$ evicts block $b_{j+1}$, and the access to $a_A$ evicts block $b_0$. Consequently, every one of the $A+1$ accesses in the second cycle is a miss.\nThis same thrashing behavior repeats for every subsequent cycle, from the $2^{nd}$ to the $N^{th}$. Thus, in each of these $N-1$ cycles, there are exactly $A+1$ misses.\n\n**Step 3: Miss Classification and Final Count**\n\nThe misses occurring in cycles $2$ through $N$ are not compulsory. They must be classified as either capacity or conflict misses.\n\nA **capacity miss** is a miss that would still occur in a fully associative cache of the same total size, given the same LRU replacement policy. A **conflict miss** is a miss that is not compulsory and would have been a hit in a fully associative cache of the same size. Conflict misses arise from blocks mapping to the same set and evicting each other, even when there is empty space in other sets.\n\nLet's determine if capacity misses are possible.\nThe total number of lines (capacity) in the cache is $C = S \\cdot A$.\nThe memory trace accesses a working set of $A+1$ unique blocks, namely $\\{b_0, b_1, \\dots, b_A\\}$.\nFor a capacity miss to occur, the size of this working set must exceed the total cache capacity, i.e., $A+1 > C$.\nWe are given that $S \\ge 2$ and $A$ is the associativity (a positive integer, so $A \\ge 1$).\nTherefore, the cache capacity is $C = S \\cdot A \\ge 2A$.\nWe need to compare the working set size, $A+1$, with the minimum capacity, $2A$.\n- If $A=1$, then $A+1=2$ and $2A=2$, so $A+1=2A$.\n- If $A > 1$, then $A > 1$, which implies $2A > A+1$.\nIn all valid cases ($A\\ge 1$), we have $A+1 \\le 2A$.\nCombining these inequalities, we get $A+1 \\le 2A \\le S \\cdot A = C$.\nThe size of the working set of blocks ($A+1$) is less than or equal to the total capacity of the cache ($C$). A fully associative cache of size $C$ could hold all $A+1$ blocks simultaneously. After the initial $A+1$ compulsory misses in the first cycle, all subsequent accesses in a fully associative cache would be hits.\nSince the misses in cycles $2$ through $N$ would be hits in a fully associative cache of the same size, they are, by definition, **not capacity misses**.\n\nTherefore, all misses that occur after the first cycle must be **conflict misses**.\n\nNow we can calculate the total count of conflict misses over the entire trace.\n- **First cycle:** There are $0$ conflict misses. All $A+1$ misses are compulsory.\n- **Cycles $2$ through $N$:** There are $N-1$ such cycles. In each of these cycles, there are $A+1$ conflict misses.\n- **Total conflict misses** = (Number of subsequent cycles) $\\times$ (Conflict misses per cycle)\n$$ \\text{Total conflict misses} = (N-1)(A+1) $$\n\nThis is the final closed-form expression for the total number of conflict misses over the entire trace of $T = N(A+1)$ references.", "answer": "$$\\boxed{(N-1)(A+1)}$$", "id": "3625442"}, {"introduction": "Building on the general principle of cache thrashing, this practice provides a concrete numerical example to make the theory tangible. We will trace the behavior of a 2-way set-associative cache when it encounters three competing memory blocks, a direct instance of the $A+1$ block problem. By working through the LRU replacement policy step-by-step [@problem_id:3625340], you will not only quantify the resulting conflict misses but also discover the minimum hardware associativity required to eliminate them entirely, demonstrating a key architectural trade-off.", "problem": "A physically indexed, physically tagged level-one data cache has $S$ sets, block size $B$ bytes, and associativity $A$ ways, with Least Recently Used (LRU) replacement. The cache is initially empty. Consider a microbenchmark that, for $T$ iterations, performs the following $3$ loads in order each iteration: a load from address $o$, then from address $o + S \\cdot B$, then from address $o + 2 S \\cdot B$. Assume $o$ is a nonnegative integer multiple of $B$ so that each of these addresses refers to the start of a distinct block. There are no other memory references, no prefetching, and ignore Translation Lookaside Buffer (TLB) effects. The total cache capacity is $C = S \\cdot A \\cdot B$ bytes.\n\nUsing the fundamental definition of set indexing in a set-associative cache and the standard miss taxonomy—where a compulsory miss is the first-ever reference to a block, a capacity miss is a miss that would also occur in a fully associative cache of the same total capacity $C$ with LRU, and a conflict miss is any miss that is neither compulsory nor capacity—answer the following in order to reason about the miss behavior of this microbenchmark:\n\n(1) Determine whether the three addresses $o$, $o + S \\cdot B$, and $o + 2 S \\cdot B$ map to the same cache set, and justify your conclusion from first principles.\n\n(2) For $A = 2$ and $T = 10^{4}$ iterations, starting from an empty cache, derive the total number of conflict misses over the entire run. Classify all misses precisely according to the standard miss taxonomy.\n\n(3) Varying $A$ while keeping $S$ and $B$ fixed, determine the smallest associativity $A_{\\min}$ that eliminates all conflict misses for this microbenchmark after the initial compulsory misses, and justify your answer based on the replacement dynamics under LRU.\n\nProvide all reasoning steps. For your final numeric answer, report only the value of $A_{\\min}$ as a single number with no units.", "solution": "The posed problem is a well-defined exercise in computer architecture, specifically concerning the analysis of cache performance. It is scientifically grounded in the established principles of cache memory organization, operation, and miss classification. The problem statement is self-contained, objective, and internally consistent, providing all necessary parameters and definitions ($S$, $A$, $B$, $T$, the access pattern, and the miss taxonomy) to derive a unique solution. Therefore, the problem is deemed valid and we may proceed with a formal solution.\n\nThe solution requires addressing three distinct parts. We will proceed in order.\n\n(1) Determine if the three addresses map to the same cache set.\n\nThe set index for a memory address is determined from its block address. For a physically indexed cache with a block size of $B$ bytes and $S$ sets, the set index $i$ for a physical address $\\alpha$ is given by the formula:\n$$\ni = \\left\\lfloor \\frac{\\alpha}{B} \\right\\rfloor \\pmod S\n$$\nwhere $\\lfloor \\frac{\\alpha}{B} \\rfloor$ is the block address. We are given that the base address $o$ is a nonnegative integer multiple of the block size $B$. This allows us to write $o = k \\cdot B$ for some nonnegative integer $k$.\n\nLet us calculate the set index for each of the three addresses in the access pattern.\n\nAddress 1: $\\alpha_1 = o$.\nThe block address is $\\lfloor \\frac{o}{B} \\rfloor = \\lfloor \\frac{k \\cdot B}{B} \\rfloor = k$.\nThe set index is $i_1 = k \\pmod S$.\n\nAddress 2: $\\alpha_2 = o + S \\cdot B$.\nThe block address is $\\lfloor \\frac{o + S \\cdot B}{B} \\rfloor = \\lfloor \\frac{k \\cdot B + S \\cdot B}{B} \\rfloor = \\lfloor k + S \\rfloor = k + S$.\nThe set index is $i_2 = (k + S) \\pmod S$. Using the properties of modular arithmetic, $(a+b) \\pmod n = ((a \\pmod n) + (b \\pmod n)) \\pmod n$, we find:\n$$\ni_2 = (k \\pmod S + S \\pmod S) \\pmod S = (k \\pmod S + 0) \\pmod S = k \\pmod S\n$$\n\nAddress 3: $\\alpha_3 = o + 2 S \\cdot B$.\nThe block address is $\\lfloor \\frac{o + 2 S \\cdot B}{B} \\rfloor = \\lfloor \\frac{k \\cdot B + 2 S \\cdot B}{B} \\rfloor = \\lfloor k + 2S \\rfloor = k + 2S$.\nThe set index is $i_3 = (k + 2S) \\pmod S$. Applying the same modular arithmetic property:\n$$\ni_3 = (k \\pmod S + 2S \\pmod S) \\pmod S = (k \\pmod S + 0) \\pmod S = k \\pmod S\n$$\nSince $i_1 = i_2 = i_3 = k \\pmod S$, all three addresses map to the exact same cache set. Let's denote the three distinct blocks corresponding to these addresses as $BLK_0$, $BLK_1$, and $BLK_2$.\n\n(2) For $A = 2$ and $T = 10^{4}$, derive the total number of conflict misses.\n\nThe cache is initially empty. We trace the accesses for the parameter $A=2$. From part (1), we know all $3$ blocks ($BLK_0, BLK_1, BLK_2$) compete for the same $2$-way set. The replacement policy is LRU.\n\nIteration $1$ (for $t=0$):\n- Load from address $o$ ($BLK_0$): **Miss**. This is the first reference to $BLK_0$. The set is empty. $BLK_0$ is loaded. Set state: $\\{BLK_0\\}$. This is a **compulsory miss**.\n- Load from address $o + S \\cdot B$ ($BLK_1$): **Miss**. This is the first reference to $BLK_1$. There is one empty way in the set. $BLK_1$ is loaded. Set state: $\\{BLK_0, BLK_1\\}$. LRU order: $BLK_0$ is LRU, $BLK_1$ is MRU. This is a **compulsory miss**.\n- Load from address $o + 2 S \\cdot B$ ($BLK_2$): **Miss**. This is the first reference to $BLK_2$. The set is full. The LRU block, $BLK_0$, is evicted. $BLK_2$ is loaded. Set state: $\\{BLK_1, BLK_2\\}$. LRU order: $BLK_1$ is LRU, $BLK_2$ is MRU. This is a **compulsory miss**.\n\nAt the end of the first iteration, there are $3$ misses, all of which are compulsory.\n\nIteration $2$ (for $t=1$):\nThe set contains $\\{BLK_1, BLK_2\\}$, with $BLK_1$ being LRU.\n- Load from address $o$ ($BLK_0$): **Miss**. $BLK_0$ is not in the set. The LRU block, $BLK_1$, is evicted. $BLK_0$ is loaded. Set state: $\\{BLK_2, BLK_0\\}$. LRU order: $BLK_2$ is LRU, $BLK_0$ is MRU.\n- Load from address $o + S \\cdot B$ ($BLK_1$): **Miss**. $BLK_1$ is not in the set. The LRU block, $BLK_2$, is evicted. $BLK_1$ is loaded. Set state: $\\{BLK_0, BLK_1\\}$. LRU order: $BLK_0$ is LRU, $BLK_1$ is MRU.\n- Load from address $o + 2 S \\cdot B$ ($BLK_2$): **Miss**. $BLK_2$ is not in the set. The LRU block, $BLK_0$, is evicted. $BLK_2$ is loaded. Set state: $\\{BLK_1, BLK_2\\}$. LRU order: $BLK_1$ is LRU, $BLK_2$ is MRU.\n\nThe state of the set at the end of iteration $2$ is identical to the state at the end of iteration $1$. Thus, the pattern of $3$ misses per iteration will repeat for all subsequent iterations from $t=1$ to $t=T-1$.\n\nNow, we must classify these misses. They are not compulsory, as all blocks were accessed in the first iteration. To distinguish between capacity and conflict misses, we analyze a fully associative cache of the same capacity $C = S \\cdot A \\cdot B = 2SB$. The number of blocks this cache can hold is $C/B = 2S$. The working set of our microbenchmark consists of only $3$ unique blocks. Assuming $S \\ge 2$, which is typical for a set-associative cache, the capacity in blocks is $2S \\ge 4$. Since the working set size ($3$ blocks) is less than the cache capacity ($2S$ blocks), a fully associative cache would hold all $3$ blocks after the initial compulsory misses. Therefore, there would be no further misses in the fully associative cache.\nThe misses we observe in iterations $2$ through $T$ in the $2$-way set-associative cache are not compulsory and would not occur in the equivalent fully associative cache. By definition, these are **conflict misses**.\n\nThe total number of conflict misses is the number of misses per iteration (after the first) multiplied by the number of such iterations.\n- Number of conflict misses per iteration (for $t \\ge 1$): $3$.\n- Number of iterations with conflict misses: $T - 1 = 10^4 - 1 = 9999$.\n- Total conflict misses = $3 \\times (T - 1) = 3 \\times 9999 = 29997$.\n(Note: If $S=1$, the capacity is $2$ blocks. The working set of $3$ blocks would not fit, and all non-compulsory misses would be capacity misses. However, the structure of the problem, particularly asking for $A_{\\min}$ to eliminate conflict misses, implies a scenario where the working set fits in the cache but is limited by associativity, i.e., $3 \\le C/B$, making the assumption $S \\ge 2$ implicit.)\n\n(3) Determine the smallest associativity $A_{\\min}$ that eliminates all conflict misses.\n\nConflict misses occur because the number of active blocks that map to a single set exceeds the set's associativity $A$. In this microbenchmark, we have established that exactly $3$ unique blocks ($BLK_0$, $BLK_1$, $BLK_2$) map to the same set and are accessed repeatedly.\n\nTo eliminate all conflict misses after the initial compulsory phase, the cache set must be large enough to hold all these competing blocks simultaneously. Since there are $3$ such blocks, the associativity $A$ must be at least $3$.\nLet's verify this for $A=3$:\n- Iteration $1$: The first access to each of $BLK_0$, $BLK_1$, and $BLK_2$ results in a compulsory miss. At the end of the iteration, the set holds all three blocks: $\\{BLK_0, BLK_1, BLK_2\\}$.\n- Iteration $2$ and onwards: The access pattern is load $BLK_0$, load $BLK_1$, load $BLK_2$. Since all three blocks are already resident in the set (which has a capacity of $3$), each of these loads will result in a **hit**. The LRU state will be updated on each hit, but no blocks will be evicted.\n\nThus, with an associativity of $A=3$, the only misses that occur are the $3$ initial compulsory misses. All conflict misses are eliminated. Any associativity lower than $3$ (i.e., $A=1$ or $A=2$) would be insufficient to hold all $3$ blocks, leading to evictions and subsequent conflict misses, as demonstrated in part (2).\nTherefore, the smallest associativity that eliminates all conflict misses is $A_{\\min} = 3$.", "answer": "$$\n\\boxed{3}\n$$", "id": "3625340"}, {"introduction": "The abstract principles of conflict misses have profound consequences for real-world software performance, especially in scientific computing. This final exercise demonstrates how a seemingly innocuous matrix operation—accessing two columns—can lead to pathological cache behavior. By analyzing the memory layout of a row-major matrix [@problem_id:3625437], you will discover how a specific access stride can cause a huge number of data blocks to map to a single cache set, creating the exact thrashing condition studied previously [@problem_id:3625442] [@problem_id:3625340] and proving that understanding cache architecture is critical for writing high-performance code.", "problem": "Consider a Central Processing Unit (CPU) with a level-one data cache whose parameters are: total capacity $128\\ \\mathrm{KiB}$, $2$-way set associativity, and cache line size $64\\ \\mathrm{B}$. Assume the cache uses the standard set-indexing rule that the cache set index is the block number modulo the number of sets, where the block number is the integer part of the address divided by the cache line size. The matrix $A$ is of dimensions $N \\times M$ with $N = 512$ and $M = 8192$, stored in row-major order, and each element of $A$ is a double-precision floating-point value of size $8\\ \\mathrm{B}$. The base address of $A$ is $A_0$, which is aligned to a $64\\ \\mathrm{B}$ boundary.\n\nA kernel performs the following access pattern twice back-to-back: for each row index $i$ from $0$ to $N-1$, it reads $A[i,0]$ and $A[i,k]$, where $k$ is a positive integer. Assume there are no other memory accesses in between these two passes and no prefetching. You may assume a deterministic replacement policy such as Least Recently Used (LRU) or any other commonly used policy; the conclusions asked below should not depend on the specific policy beyond the associativity limitation.\n\nStarting from the definitions of cache block number, set index, and the standard classification of cache misses into compulsory, capacity, and conflict, derive the condition on $k$ for which, for every row $i$, the two elements $A[i,0]$ and $A[i,k]$ map to the same cache set. Use this condition to choose the smallest positive integer $k$ that satisfies it. The rationale in your derivation must explicitly use the facts that $M$ is a multiple of $8$ and that $A_0$ is aligned to $64\\ \\mathrm{B}$.\n\nAdditionally, explain why under this choice of $k$ the misses observed in the second pass are classified as conflict misses even though the total unique data footprint of the two columns accessed, measured in cache lines, would fit in the cache capacity. You do not need to compute a miss count; the classification reasoning must start from the foundational definitions.\n\nWhat is the smallest positive integer $k$ that ensures $A[i,0]$ and $A[i,k]$ reside in the same cache set for all $i$? Provide the value of $k$ as an exact integer. No rounding is needed.", "solution": "The problem requires finding a specific column index step $k$ that causes a particular cache mapping behavior and then classifying the resulting cache misses. The solution proceeds in three stages: first, calculating the relevant cache architectural parameters; second, deriving the condition on $k$ and finding its smallest positive integer value; and third, analyzing the cache misses based on standard definitions.\n\nFirst, we must determine the key parameters of the cache architecture from the givens.\nThe cache capacity is $C = 128 \\text{ KiB} = 128 \\times 2^{10} \\text{ B} = 2^7 \\times 2^{10} \\text{ B} = 2^{17} \\text{ B}$.\nThe cache line size (or block size) is $L = 64 \\text{ B} = 2^6 \\text{ B}$.\nThe associativity is $W = 2$-way.\nThe total number of cache lines is $N_{lines} = \\frac{C}{L} = \\frac{2^{17}}{2^6} = 2^{11} = 2048$.\nThe number of sets in the cache is $S = \\frac{N_{lines}}{W} = \\frac{2048}{2} = 1024 = 2^{10}$.\n\nThe mapping of a memory address to a cache set is determined by its block number. The block number is defined as $\\text{BlockNumber} = \\lfloor \\frac{\\text{Address}}{L} \\rfloor$. The set index is then given by $\\text{SetIndex} = \\text{BlockNumber} \\pmod S$.\n\nNext, we formalize the memory addresses of the accessed elements. The matrix $A$ has dimensions $N \\times M$ where $N=512$ and $M=8192$. It is stored in row-major order, and each element has a size of $E = 8 \\text{ B}$. The address of an element $A[i,j]$ is given by the formula:\n$$ \\text{Addr}(A[i,j]) = A_0 + (i \\cdot M + j) \\cdot E $$\nwhere $A_0$ is the base address of the matrix.\n\nThe problem requires that for any row $i$, the elements $A[i,0]$ and $A[i,k]$ map to the same cache set. This means their block numbers must be congruent modulo the number of sets, $S$.\nLet $B(i,j)$ be the block number for the address of $A[i,j]$. The condition is:\n$$ B(i,0) \\pmod S = B(i,k) \\pmod S \\quad \\forall i \\in [0, N-1] $$\nThis is equivalent to stating that the difference in their block numbers must be a multiple of $S$:\n$$ (B(i,k) - B(i,0)) \\pmod S = 0 $$\nLet's compute the block numbers.\n$B(i,0) = \\left\\lfloor \\frac{\\text{Addr}(A[i,0])}{L} \\right\\rfloor = \\left\\lfloor \\frac{A_0 + i \\cdot M \\cdot E}{L} \\right\\rfloor$\n$B(i,k) = \\left\\lfloor \\frac{\\text{Addr}(A[i,k])}{L} \\right\\rfloor = \\left\\lfloor \\frac{A_0 + (i \\cdot M + k) \\cdot E}{L} \\right\\rfloor = \\left\\lfloor \\frac{A_0 + i \\cdot M \\cdot E + k \\cdot E}{L} \\right\\rfloor$\n\nThe problem states that the base address $A_0$ is aligned to a $64 \\text{ B}$ boundary, which means $A_0$ is a multiple of $L=64$. Let $A_0 = q_0 L$ for some integer $q_0$.\nWe also must check the size of a matrix row in bytes: $M \\cdot E = 8192 \\cdot 8 = 2^{13} \\cdot 2^3 = 2^{16} \\text{ B}$. Since $L=64=2^6 \\text{ B}$, the size of a row is an integer multiple of the line size: $\\frac{M \\cdot E}{L} = \\frac{2^{16}}{2^6} = 2^{10} = 1024$. This means that the starting address of every row, $\\text{Addr}(A[i,0]) = A_0 + i \\cdot M \\cdot E$, is a multiple of $L$. This fact is a direct consequence of both the $A_0$ alignment and the matrix dimensions. The fact that $M$ is a multiple of 8 implies that the number of elements per cache line, $L/E = 64/8 = 8$, perfectly divides the number of columns $M=8192$, resulting in a row spanning exactly $8192/8 = 1024$ cache lines.\n\nSince $\\frac{A_0 + i \\cdot M \\cdot E}{L}$ is an integer, the floor function for $B(i,0)$ can be removed:\n$$ B(i,0) = \\frac{A_0}{L} + i \\cdot \\frac{M \\cdot E}{L} $$\nFor $B(i,k)$, we can use the property $\\lfloor x+n \\rfloor = \\lfloor x \\rfloor + n$ for integer $n$:\n$$ B(i,k) = \\left\\lfloor \\left(\\frac{A_0}{L} + i \\cdot \\frac{M \\cdot E}{L}\\right) + \\frac{k \\cdot E}{L} \\right\\rfloor = B(i,0) + \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor $$\nThe difference in block numbers is therefore:\n$$ B(i,k) - B(i,0) = \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor $$\nThis difference is independent of the row index $i$, so the condition will hold for all $i$ if it holds for one. The condition $(B(i,k) - B(i,0)) \\pmod S = 0$ becomes:\n$$ \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor \\pmod S = 0 $$\nThis means $\\lfloor \\frac{k \\cdot E}{L} \\rfloor$ must be an integer multiple of $S$. Let this be $m \\cdot S$ for some integer $m$. To find the smallest positive integer $k$, we should choose the smallest positive integer multiple, which is for $m=1$.\n$$ \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor = S $$\nSubstituting the values $E=8$, $L=64$, and $S=1024$:\n$$ \\left\\lfloor \\frac{k \\cdot 8}{64} \\right\\rfloor = 1024 \\implies \\left\\lfloor \\frac{k}{8} \\right\\rfloor = 1024 $$\nFrom the definition of the floor function, this inequality holds:\n$$ 1024 \\le \\frac{k}{8}  1025 $$\nMultiplying by $8$:\n$$ 8192 \\le k  8200 $$\nThe smallest positive integer $k$ that satisfies this condition is $k=8192$.\n\nFinally, we must explain why misses in the second pass, for this choice of $k=8192$, are classified as conflict misses.\nThe access pattern involves two columns of the matrix, column $0$ and column $k=8192$. The number of rows is $N=512$. Thus, the program accesses $A[i,0]$ and $A[i,k]$ for $i \\in [0, 511]$.\nThe set of unique cache blocks accessed are those containing $A[i,0]$ and $A[i,k]$ for all $i$. The address difference between $A[i,0]$ and $A[i,k]$ is $k \\cdot E = 8192 \\cdot 8 = 65536$ bytes, which is $65536/64=1024$ cache blocks. So $A[i,0]$ and $A[i,k]$ are in different blocks. The total number of unique blocks accessed is $2 \\times N = 2 \\times 512 = 1024$.\nThe memory footprint of this working set is $1024 \\text{ blocks} \\times 64 \\frac{\\text{B}}{\\text{block}} = 65536 \\text{ B} = 64 \\text{ KiB}$.\nThe total cache capacity is $128 \\text{ KiB}$. Since the working set size ($64 \\text{ KiB}$) is smaller than the cache capacity, the misses observed in the second pass cannot be capacity misses. A capacity miss, by definition, is one that would still occur in a fully associative cache of the same capacity. In such a cache, all $1024$ blocks would fit, so the second pass would experience no misses.\n\nLet's analyze the set mapping. The set index for the block containing $A[i,j]$ is $I(i,j) = B(i,j) \\pmod S$.\nThe set index for $A[i,0]$ is:\n$$ I(i,0) = \\left(\\frac{A_0}{L} + i \\cdot \\frac{M \\cdot E}{L}\\right) \\pmod S $$\nSubstituting $\\frac{M \\cdot E}{L} = 1024 = S$:\n$$ I(i,0) = \\left(\\frac{A_0}{L} + i \\cdot S\\right) \\pmod S = \\frac{A_0}{L} \\pmod S $$\nThe set index for $A[i,k]$ is:\n$$ I(i,k) = \\left(B(i,0) + \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor \\right) \\pmod S = \\left(B(i,0) + S\\right) \\pmod S = B(i,0) \\pmod S = I(i,0) $$\nCrucially, not only do $A[i,0]$ and $A[i,k]$ map to the same set for a given $i$, but all accessed blocks, for all $i \\in [0, 511]$, map to the very same set, $s_{conflict} = \\frac{A_0}{L} \\pmod S$.\nThe cache is $2$-way set associative ($W=2$), meaning this set $s_{conflict}$ can hold only $2$ blocks at a time. However, the program attempts to access $1024$ distinct blocks that all map to this one set.\nDuring the first pass, as the loop iterates, it brings new pairs of blocks ($b(i,0), b(i,k)$) into set $s_{conflict}$, causing the blocks from previous iterations to be evicted. For example, when accessing $A[1,0]$ and $A[1,k]$, the blocks for $A[0,0]$ and $A[0,k]$ are evicted (assuming an LRU-like policy). At the end of the first pass, only the blocks for the last iteration, $b(511,0)$ and $b(511,k)$, remain in the cache. The first-pass misses are all compulsory misses, as each of the $1024$ blocks is accessed for the first time.\n\nIn the second pass, the access sequence is repeated. When $A[0,0]$ is accessed again, its block is not in the cache because it was evicted during the first pass. This results in a miss. This miss is not compulsory because the block has been accessed before. It is not a capacity miss because the entire working set fits in the cache. Therefore, by definition, it must be a conflict miss. This miss occurs because a large number of blocks from the working set are competing for a limited number of slots ($2$) in a single cache set, a direct consequence of the pathological mapping created by our choice of $k$. This reasoning applies to every access in the second pass, all of which will be conflict misses.", "answer": "$$\\boxed{8192}$$", "id": "3625437"}]}