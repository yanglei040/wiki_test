{"hands_on_practices": [{"introduction": "To begin our exploration of integer overflow, we start with a concept familiar from mathematics: the factorial. This exercise [@problem_id:3651585] uses the rapidly growing factorial function, $n!$, to provide a tangible demonstration of how quickly the limits of a fixed-width integer can be reached. By determining the largest integer $n$ whose factorial can fit into a standard $32$-bit signed integer, you will gain a concrete appreciation for the finite nature of computer arithmetic and the inevitability of overflow with escalating values.", "problem": "A software routine in a systems programming course is implemented to compute the factorial $n!$ using a $32$-bit signed integer type under two's complement representation. In two's complement, a signed $w$-bit integer ranges from $-2^{w-1}$ to $2^{w-1}-1$. The routine accumulates the product sequentially as $1 \\cdot 2 \\cdot 3 \\cdots n$, stored in a single $32$-bit signed integer variable, and the hardware raises an overflow condition if the magnitude of the true mathematical result exceeds the representable range.\n\nStarting from the formal definition of factorial $n!$ for $n \\in \\mathbb{N}$ and the representable range of $32$-bit signed two's complement integers, reason from first principles to determine the largest integer $n$ such that computing $n!$ in this type does not overflow. Your derivation must justify why any larger $n$ necessarily causes overflow, without relying on unproven shortcut formulas.\n\nAdditionally, explain, grounded in fundamental properties of monotonic functions and transformations that preserve order, how one could design a mathematically principled pre-check to detect imminent overflow before performing the multiplication for large $n$, and briefly note when switching to arbitrary-precision (big integer) arithmetic becomes necessary in this context. Do not provide code; focus on the reasoning and mathematical justification.\n\nReport only the maximal $n$ as your final answer. No rounding is required, and no units are involved.", "solution": "The problem requires determining the largest integer $n$ for which its factorial, $n!$, can be stored in a $32$-bit signed integer variable using two's complement representation without causing an overflow.\n\nFirst, we establish the range of representable values. The problem states that for a $w$-bit signed integer in two's complement, the range is $[ -2^{w-1}, 2^{w-1}-1 ]$. For this problem, the width $w$ is $32$. Therefore, the range of a $32$-bit signed integer is $[ -2^{32-1}, 2^{32-1}-1 ]$, which simplifies to $[ -2^{31}, 2^{31}-1 ]$.\n\nThe maximum positive integer that can be represented, let's call it $V_{max}$, is $2^{31}-1$. To find its numerical value, we can compute $2^{31}$:\n$$ 2^{31} = 2 \\cdot 2^{30} = 2 \\cdot (2^{10})^{3} = 2 \\cdot (1024)^{3} = 2 \\cdot 1,073,741,824 = 2,147,483,648 $$\nThus, the maximum value is $V_{max} = 2,147,483,648 - 1 = 2,147,483,647$.\n\nThe factorial function, $n!$, is defined for a non-negative integer $n$ as the product of all positive integers up to $n$:\n$$ n! = \\prod_{k=1}^{n} k $$\nFor any $n \\ge 0$, the value of $n!$ is non-negative. Therefore, to avoid overflow, the computed value of $n!$ must not exceed $V_{max}$. The condition is $n! \\le 2^{31}-1$.\n\nWe will now compute the values of $n!$ for increasing $n$, starting from $n=1$, and compare them to $V_{max}$.\n$1! = 1$\n$2! = 2$\n$3! = 6$\n$4! = 24$\n$5! = 120$\n$6! = 720$\n$7! = 5,040$\n$8! = 40,320$\n$9! = 362,880$\n$10! = 3,628,800$\n$11! = 10! \\cdot 11 = 3,628,800 \\cdot 11 = 39,916,800$\n$12! = 11! \\cdot 12 = 39,916,800 \\cdot 12 = 479,001,600$\n\nWe check if $12!$ is within the representable range:\n$479,001,600 \\le 2,147,483,647$. This inequality is true. Therefore, $12!$ can be correctly computed and stored.\n\nNext, we compute the value for $n=13$:\n$13! = 12! \\cdot 13 = 479,001,600 \\cdot 13 = 6,227,020,800$\n\nWe check if $13!$ is within the representable range:\n$6,227,020,800 \\le 2,147,483,647$. This inequality is false. Thus, computing $13!$ results in a value that is too large to be stored, causing an overflow.\n\nTo justify that $n=12$ is the maximal such integer, we must demonstrate that for any integer $m > 12$, $m!$ also causes an overflow. This relies on the monotonic property of the factorial function. The function $f(n) = n!$ is strictly monotonically increasing for $n \\ge 1$. This can be shown by considering the ratio of successive terms: for $n \\ge 1$, $(n+1)! = (n+1) \\cdot n!$. Since $n+1 > 1$, it follows that $(n+1)! > n!$.\nBecause the factorial function is strictly increasing, and we have established that $13! > V_{max}$, it must be that for any integer $m > 13$, $m! = m \\cdot (m-1) \\cdots 14 \\cdot 13! > 13!$. Since $13!$ already exceeds $V_{max}$, any factorial $m!$ for $m \\ge 13$ will also exceed $V_{max}$.\nTherefore, the largest integer $n$ for which $n!$ can be computed without overflow in a $32$-bit signed integer is $12$.\n\nRegarding the design of a pre-check to detect imminent overflow, let's consider the iterative computation of $n!$. At step $k$ (for $k$ from $2$ to $n$), we compute a new product by multiplying the previous product, $(k-1)!$, by $k$. Let $P_{k-1} = (k-1)!$. Before computing $P_k = P_{k-1} \\cdot k$, we must check if this operation will overflow. An overflow will occur if $P_{k-1} \\cdot k > V_{max}$.\nPerforming the multiplication to check this condition is self-defeating, as the multiplication itself is the operation we want to avoid if it overflows. Instead, we can rearrange the inequality. The function $g(x) = x/k$ for a positive integer $k$ is a strictly increasing function, meaning it is an order-preserving transformation. Applying this transformation to the inequality does not change its direction. Therefore, for $k>0$, the condition $P_{k-1} \\cdot k > V_{max}$ is mathematically equivalent to $P_{k-1} > V_{max}/k$.\nThis check is computationally safe. At the beginning of step $k$, the value $P_{k-1}$ is known to be valid and stored correctly. The check involves a division (which for integers can be performed as integer division) and a comparison, both of which are safe operations. If the check $P_{k-1} > V_{max}/k$ is true, an overflow is imminent, and the multiplication should not be performed.\n\nFinally, arbitrary-precision (big integer) arithmetic becomes necessary when the problem domain requires exact integer calculations for numbers whose magnitudes exceed the limits of fixed-size hardware integer types. The factorial function $n!$ grows superexponentially. As shown, $13!$ overflows a $32$-bit integer. Similarly, one can show that $21!$ overflows a $64$-bit signed integer (whose maximum value is $2^{63}-1 \\approx 9.22 \\times 10^{18}$). For applications in fields like cryptography, number theory, or symbolic computation that require exact factorials of larger numbers (e.g., $100!$), fixed-precision arithmetic is fundamentally inadequate. Such applications must use software libraries that represent numbers using dynamic data structures (like arrays of digits) and provide algorithms to perform arithmetic operations on them, with the number's size being limited only by available memory rather than a fixed bit-width.", "answer": "$$ \\boxed{12} $$", "id": "3651585"}, {"introduction": "Having seen a concrete example of overflow, we now move to build a complete theoretical framework for signed addition. This practice [@problem_id:3651541] challenges you to think like a processor designer and systematically map out every possible outcome of adding two $n$-bit signed numbers. By categorizing the results based on the signs of the operands and the state of the overflow flag, you will discover the fundamental rules that govern two's complement arithmetic and understand precisely when and why overflow does—and does not—occur.", "problem": "A processor implements integer addition $ADD$ on $n$-bit operands in two’s complement representation, with $n \\ge 3$. The arithmetic logic unit sets the overflow flag $V$ according to standard two’s complement rules, and the sign bit $s(x)$ of any value $x$ is its most significant bit. Consider constructing a black-box verification test set for $ADD$ whose adequacy criterion is to exercise every distinct qualitative sign/overflow outcome that can arise from adding two $n$-bit integers. Formalize this using equivalence classes: say two ordered operand pairs $(a,b)$ and $(a',b')$ are equivalent if the tuple $(s(a), s(b), s(a+b), V)$ produced by $ADD$ is identical for both pairs. Starting only from core definitions of two’s complement integer ranges and the overflow condition for $ADD$, derive the minimal number of test cases required, as a function of $n$, to cover all equivalence classes under this criterion. Provide the final answer as a single closed-form expression in $n$. No rounding is required.", "solution": "The problem requires determining the number of distinct equivalence classes for the addition of two $n$-bit two's complement integers, $a$ and $b$, where $n \\ge 3$. An equivalence class is uniquely defined by the tuple of outcomes $(s(a), s(b), s(a+b), V)$, where $s(x)$ is the sign bit of $x$ and $V$ is the overflow flag. The number of such classes is the minimal number of test cases needed to satisfy the specified adequacy criterion.\n\nThe sign bit $s(x)$ can be $0$ (for $x \\ge 0$) or $1$ (for $x  0$). The overflow flag $V$ can be $0$ (no overflow) or $1$ (overflow). There are naively $2^4 = 16$ possible tuples for $(s(a), s(b), s(a+b), V)$. However, the rules of two's complement arithmetic impose constraints that make some of these tuples impossible. We will analyze these constraints systematically.\n\nThe range of an $n$-bit two's complement integer is $[-2^{n-1}, 2^{n-1}-1]$. The constraint $n \\ge 3$ ensures that this range includes multiple distinct positive and negative integers, which is sufficient to explore all fundamental arithmetic behaviors.\n\nA crucial rule in two's complement addition is that overflow cannot occur when adding two numbers with opposite signs.\nLet $s(a)=0$ and $s(b)=1$. This implies that $a$ is in the range $[0, 2^{n-1}-1]$ and $b$ is in the range $[-2^{n-1}, -1]$.\nThe mathematical sum $S = a+b$ is therefore bounded by:\n$$0 + (-2^{n-1}) \\le a+b \\le (2^{n-1}-1) + (-1)$$\n$$-2^{n-1} \\le S \\le 2^{n-1}-2$$\nThe entire range of the sum $S$ is within the representable range of an $n$-bit two's complement integer, $[-2^{n-1}, 2^{n-1}-1]$. Since the true sum is always representable, no overflow can occur. Thus, if $s(a) \\neq s(b)$, the overflow flag $V$ must be $0$.\nThis constraint eliminates all tuples where $s(a) \\neq s(b)$ and $V=1$. These are the four tuples:\n$(0, 1, 0, 1)$, $(0, 1, 1, 1)$, $(1, 0, 0, 1)$, and $(1, 0, 1, 1)$.\nThis reduces the number of possible unique tuples from $16$ to $12$.\n\nWe now proceed with a case-by-case analysis based on the signs of the operands.\n\nCase 1: $s(a)=0$ and $s(b)=0$ (Addition of two non-negative numbers).\nThe mathematical sum $a+b$ is non-negative.\nSubcase 1.1: No overflow ($V=0$). This occurs when $a+b \\le 2^{n-1}-1$. Since there is no overflow, the computed result is correct, so its sign must be non-negative. Therefore, $s(a+b)=0$. This gives the tuple $(0, 0, 0, 0)$. This case is possible for any $n \\ge 3$ (e.g., $a=1, b=1$). The tuple $(0, 0, 1, 0)$ is impossible because a correct sum of two non-negatives cannot be negative.\nSubcase 1.2: Overflow ($V=1$). This occurs when $a+b > 2^{n-1}-1$. The hardware sum wraps around into the negative range, so the resulting sign bit will be $1$. Therefore, $s(a+b)=1$. This gives the tuple $(0, 0, 1, 1)$. This case is possible for any $n \\ge 3$ (e.g., $a=2^{n-1}-1, b=1$). The tuple $(0, 0, 0, 1)$ is impossible because overflow from adding two positives must yield a result with a sign bit of $1$.\n\nCase 2: $s(a)=1$ and $s(b)=1$ (Addition of two negative numbers).\nThe mathematical sum $a+b$ is negative.\nSubcase 2.1: No overflow ($V=0$). This occurs when $a+b \\ge -2^{n-1}$. The computed result is correct, so its sign must be negative. Therefore, $s(a+b)=1$. This gives the tuple $(1, 1, 1, 0)$. This case is possible for any $n \\ge 3$ (e.g., $a=-1, b=-1$). The tuple $(1, 1, 0, 0)$ is impossible.\nSubcase 2.2: Overflow ($V=1$). This occurs when $a+b  -2^{n-1}$. The hardware sum wraps around into the positive range, so the resulting sign bit will be $0$. Therefore, $s(a+b)=0$. This gives the tuple $(1, 1, 0, 1)$. This case is possible for any $n \\ge 3$ (e.g., $a=-2^{n-1}, b=-1$). The tuple $(1, 1, 1, 1)$ is impossible.\n\nCase 3: $s(a)=0$ and $s(b)=1$ (Addition of a non-negative and a negative number).\nAs established, $V$ must be $0$. The sign of the result depends on the relative magnitudes of $a$ and $b$.\nSubcase 3.1: The sum is non-negative ($a+b \\ge 0$). This implies $s(a+b)=0$. This gives the tuple $(0, 1, 0, 0)$. This case is possible for any $n \\ge 3$ (e.g., $a=2, b=-1$).\nSubcase 3.2: The sum is negative ($a+b  0$). This implies $s(a+b)=1$. This gives the tuple $(0, 1, 1, 0)$. This case is possible for any $n \\ge 3$ (e.g., $a=1, b=-2$).\n\nCase 4: $s(a)=1$ and $s(b)=0$.\nThis case is symmetric to Case 3. $V$ must be $0$.\nSubcase 4.1: The sum is non-negative ($a+b \\ge 0$), leading to $s(a+b)=0$. This gives the tuple $(1, 0, 0, 0)$. This case is possible for any $n \\ge 3$ (e.g., $a=-1, b=2$).\nSubcase 4.2: The sum is negative ($a+b  0$), leading to $s(a+b)=1$. This gives the tuple $(1, 0, 1, 0)$. This case is possible for any $n \\ge 3$ (e.g., $a=-2, b=1$).\n\nIn summary, the complete set of distinct, possible tuples is:\n1. $(0, 0, 0, 0)$\n2. $(0, 0, 1, 1)$\n3. $(1, 1, 1, 0)$\n4. $(1, 1, 0, 1)$\n5. $(0, 1, 0, 0)$\n6. $(0, 1, 1, 0)$\n7. $(1, 0, 0, 0)$\n8. $(1, 0, 1, 0)$\n\nThere are $8$ such tuples. Each of these represents a distinct equivalence class. We have demonstrated that for any $n \\ge 3$, it is possible to find operands $a$ and $b$ that produce each of these $8$ outcomes. Therefore, the number of equivalence classes, and thus the minimal number of test cases required, is a constant for all $n \\ge 3$. The expression for the number of test cases as a function of $n$ is thus a constant.", "answer": "$$\\boxed{8}$$", "id": "3651541"}, {"introduction": "Our final practice bridges the crucial gap between the predictable rules of hardware and the often-surprising realities of high-level programming. While the processor performs two's complement arithmetic with well-defined wraparound behavior, languages like C declare signed integer overflow as \"undefined behavior\"—a significant source of bugs and security flaws. This exercise [@problem_id:3651582] tasks you with safely modeling and comparing the machine-level result against the true mathematical result, providing a clear view of how overflow manifests and why understanding it is critical for writing robust and secure software.", "problem": "You are tasked to write a complete, runnable program that, without ever invoking undefined behavior, analyzes the difference between signed-overflow behavior assumed by compilers in the C programming language and the actual modulo arithmetic performed by typical two’s complement hardware. Your program must compute, for a given set of integer arithmetic test cases, four quantities per case that allow a clear attribution of the distinction between signed overflow, unsigned wraparound, and the behavior of hardware status flags.\n\nUse the following fundamental base:\n- Two’s complement representation of signed $w$-bit integers maps unsigned values $u \\in [0,2^w-1]$ to signed values $s \\in [-2^{w-1},2^{w-1}-1]$ by $s = u$ if $u  2^{w-1}$ and $s = u - 2^w$ otherwise.\n- For machine-level unsigned arithmetic on $w$-bit words, addition and multiplication are performed modulo $2^w$.\n- For signed arithmetic in two’s complement on $w$-bit words, the mathematically correct sum or product may exceed the representable signed range $[-2^{w-1},2^{w-1}-1]$. The hardware’s modulo result still exists, but the signed interpretation of that result does not equal the true mathematical value outside the representable range. The conceptual signed overflow event corresponds to the true mathematical value lying outside $[-2^{w-1},2^{w-1}-1]$.\n- At the machine level, unsigned addition produces a carry-out if the true unsigned sum is at least $2^w$. For multiplication, the upper $w$ bits of the $2w$-bit product are non-zero if and only if the true unsigned product is at least $2^w$.\n\nWork with a fixed width of $w=32$ bits. You must not rely on C’s native signed overflow, which is undefined behavior. Instead, derive all results from the above principles by emulating $32$-bit arithmetic using a wider exact domain and explicit modulo $2^{32}$ mapping.\n\nFor each test case, you are given:\n- An operation selector in $\\{ \\text{add}, \\text{mul} \\}$.\n- Two signed operands $a,b \\in [-2^{31},2^{31}-1]$ that are to be interpreted as $32$-bit two’s complement integers.\n\nFor each test case, compute and output the following four values, in this exact order:\n1) The two’s complement wraparound result: the signed interpretation of the lower $32$ bits of the true unsigned $32$-bit modulo result (addition modulo $2^{32}$ or multiplication modulo $2^{32}$).\n2) The saturating result: the true mathematical result clamped to the interval $[-2^{31},2^{31}-1]$.\n3) The signed-overflow indicator: $1$ if the true mathematical result is outside $[-2^{31},2^{31}-1]$, else $0$.\n4) The unsigned-overflow indicator:\n   - For addition: the carry-out bit viewed as an integer in $\\{0,1\\}$.\n   - For multiplication: whether the upper $32$ bits of the $64$-bit product are non-zero, as an integer in $\\{0,1\\}$.\n\nDerive these values from first principles using only the definitions above. In particular, avoid any reliance on implementation-defined widths of C’s native types. Instead, emulate $32$-bit arithmetic by working in a strictly larger exact integer space and applying explicit modulo $2^{32}$ masking and two’s complement mapping.\n\nTest suite:\n- Addition cases:\n  1) add with $a=1000$, $b=2000$.\n  2) add with $a=2147483647$, $b=1$.\n  3) add with $a=-2147483648$, $b=-1$.\n  4) add with $a=1073741824$, $b=1073741824$.\n  5) add with $a=-2147483648$, $b=2147483647$.\n- Multiplication cases:\n  6) mul with $a=46340$, $b=46340$.\n  7) mul with $a=46341$, $b=46341$.\n  8) mul with $a=2147483647$, $b=2$.\n  9) mul with $a=-2147483648$, $b=2$.\n  10) mul with $a=-2147483648$, $b=-1$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order implied by the test suite above, with four integers per test case listed consecutively. Therefore, the line must contain exactly $40$ integers. No other output is permitted. There are no physical units in this problem. Angles are not applicable. Express all indicator values as plain integers $0$ or $1$.", "solution": "The problem requires an analysis of $32$-bit integer arithmetic, specifically distinguishing between the true mathematical result of an operation and the result produced by hardware implementing two's complement arithmetic with wraparound behavior. A critical constraint is to avoid invoking undefined behavior in C, which occurs upon signed integer overflow. The solution must be derived from the first principles of two's complement arithmetic provided in the problem statement.\n\nThe core strategy is to perform all calculations in a wider integer type that can represent all intermediate and final results without overflow. Given the task operates on $w=32$-bit integers, the standard C `long long` and `unsigned long long` types, which are guaranteed by the C23 standard to be at least $64$ bits wide, serve as a suitable \"wider exact domain\".\n\nLet the two signed $32$-bit input operands be $a$ and $b$, where $a, b \\in [-2^{31}, 2^{31}-1]$.\n\nFirst, we must determine the unsigned $32$-bit integer representations (i.e., the bit patterns) of $a$ and $b$, which we shall denote as $u_a$ and $u_b$. The problem defines the mapping from an unsigned value $u$ to a signed value $s$. We require the inverse mapping. A signed integer $s$ in two's complement corresponds to an unsigned integer $u$ such that $u \\equiv s \\pmod{2^w}$. For $w=32$:\n- If $s \\ge 0$, then $u = s$.\n- If $s  0$, then $u = s + 2^{32}$.\nIn C, this conversion for a signed value `s_val` can be emulated by casting it to an `unsigned long long` and applying a $32$-bit mask: `(unsigned long long)s_val  0xFFFFFFFFULL`. This yields the unsigned values $u_a$ and $u_b$, which are the operands for the underlying machine-level unsigned arithmetic.\n\nWith $a$, $b$, $u_a$, and $u_b$ established, we can compute the quantities required for the four outputs.\n\n1.  **True Mathematical Result ($T$)**: This is the result of the operation as performed in pure mathematics, without the constraints of a fixed bit width. We compute this using $64$-bit signed integers to ensure the result is exact, even if it exceeds the $32$-bit range.\n    $$ T_{add} = (\\text{long long})a + (\\text{long long})b $$\n    $$ T_{mul} = (\\text{long long})a \\times (\\text{long long})b $$\n\n2.  **True Unsigned Result ($U_{64}$)**: This is the result of applying the operation to the unsigned representations $u_a$ and $u_b$. For multiplication, this requires a $2w = 64$-bit result to be exact.\n    $$ U_{64, add} = (\\text{unsigned long long})u_a + (\\text{unsigned long long})u_b $$\n    $$ U_{64, mul} = (\\text{unsigned long long})u_a \\times (\\text{unsigned long long})u_b $$\n\nFrom these two exact results, $T$ and $U_{64}$, we can derive the four specified output values. Let $S_{min} = -2^{31}$ and $S_{max} = 2^{31}-1$.\n\n**Output 1: Two's Complement Wraparound Result**\nThis is the signed interpretation of the lower $32$ bits of the true unsigned result. The machine-level result of a $w$-bit operation is $U_{64} \\pmod {2^w}$. Let this $32$-bit unsigned pattern be $u_{res} = U_{64} \\pmod {2^{32}}$. We apply the two's complement interpretation rule provided in the problem:\n- If $u_{res}  2^{31}$, the signed result is $u_{res}$.\n- If $u_{res} \\ge 2^{31}$, the signed result is $u_{res} - 2^{32}$.\n\n**Output 2: Saturating Result**\nThis is the true mathematical result $T$ clamped to the representable signed $32$-bit range $[S_{min}, S_{max}]$.\n$$ \\text{Saturating Result} = \\begin{cases} S_{max}  \\text{if } T > S_{max} \\\\ S_{min}  \\text{if } T  S_{min} \\\\ T  \\text{otherwise} \\end{cases} $$\n\n**Output 3: Signed-Overflow Indicator**\nThis indicator is $1$ if the true mathematical result $T$ falls outside the representable signed $32$-bit range, and $0$ otherwise.\n$$ \\text{Signed-Overflow} = (T  S_{min} \\lor T > S_{max}) ? 1 : 0 $$\n\n**Output 4: Unsigned-Overflow Indicator**\nThis indicator's definition depends on the operation.\n- For addition, it is $1$ if the true unsigned sum $U_{64, add}$ is greater than or equal to $2^{32}$, which corresponds to a carry-out from the most significant bit.\n  $$ \\text{Unsigned-Overflow}_{add} = (U_{64, add} \\ge 2^{32}) ? 1 : 0 $$\n- For multiplication, it is $1$ if the upper $32$ bits of the $64$-bit product $U_{64, mul}$ are non-zero. This is equivalent to the product being greater than or equal to $2^{32}$.\n  $$ \\text{Unsigned-Overflow}_{mul} = (U_{64, mul} \\gg 32 \\neq 0) ? 1 : 0 $$\n\nThis systematic approach, using a wider data type to emulate the arithmetic and then applying the specified definitions, correctly computes all required values without any reliance on implementation-defined or undefined behavior. The logic is implemented for each test case to generate the final output.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// Note: The problem statement allows for complex.h, threads.h, and stdatomic.h\n// but they are not necessary for this solution.\n\n// Using `long long` and `unsigned long long` which are standard C types\n// guaranteed by C99/C23 to be at least 64-bit wide. This allows emulating 32-bit\n// arithmetic without overflow in the host machine, as required by the problem.\n\ntypedef enum {\n    OP_ADD,\n    OP_MUL\n} Operation;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    Operation op;\n    long long a;\n    long long b;\n} TestCase;\n\n// This function implements the logic derived from first principles to analyze\n// 32-bit integer arithmetic for a given test case.\nvoid analyze_arithmetic(const TestCase* test, long long* results_out) {\n    // Define fundamental constants for 32-bit arithmetic using 64-bit types\n    // to prevent overflow in the analysis harness itself.\n    const long long S_MIN_32 = -2147483648LL;\n    const long long S_MAX_32 = 2147483647LL;\n    const unsigned long long U_MASK_32 = 0xFFFFFFFFULL;\n    const unsigned long long TWO_POW_31 = 2147483648ULL; // 1ULL  31\n    const unsigned long long TWO_POW_32 = 4294967296ULL; // 1ULL  32\n\n    // Step 1: Convert signed 32-bit operands `a` and `b` to their\n    //         corresponding 32-bit unsigned bit patterns. These patterns\n    //         are stored in 64-bit unsigned variables.\n    unsigned long long u_a = (unsigned long long)test-a  U_MASK_32;\n    unsigned long long u_b = (unsigned long long)test-b  U_MASK_32;\n\n    // Step 2: Calculate the \"true mathematical result\" using 64-bit signed\n    //         arithmetic to prevent intermediate overflow.\n    long long true_result;\n    if (test-op == OP_ADD) {\n        true_result = test-a + test-b;\n    } else { // OP_MUL\n        true_result = test-a * test-b;\n    }\n\n    // Step 3: Perform the underlying unsigned arithmetic. The result is stored\n    //         in a 64-bit unsigned type to capture the full product for multiplication\n    //         and the potential carry-out for addition.\n    unsigned long long u_result_64;\n    if (test-op == OP_ADD) {\n        u_result_64 = u_a + u_b;\n    } else { // OP_MUL\n        u_result_64 = u_a * u_b;\n    }\n    \n    // The bit pattern of the machine-level result is the lower 32 bits.\n    unsigned long long u_result_32_pattern = u_result_64  U_MASK_32;\n\n    // Step 4: Calculate the four required output values based on the definitions.\n\n    // 1) Two's complement wraparound result:\n    // Convert the 32-bit unsigned result pattern back to a signed value\n    // according to the two's complement definition provided.\n    long long wrapped_result;\n    if (u_result_32_pattern  TWO_POW_31) {\n        wrapped_result = (long long)u_result_32_pattern;\n    } else {\n        wrapped_result = (long long)u_result_32_pattern - (long long)TWO_POW_32;\n    }\n\n    // 2) Saturating result:\n    // Clamp the true mathematical result to the 32-bit signed range [-2^31, 2^31-1].\n    long long saturated_result;\n    if (true_result  S_MAX_32) {\n        saturated_result = S_MAX_32;\n    } else if (true_result  S_MIN_32) {\n        saturated_result = S_MIN_32;\n    } else {\n        saturated_result = true_result;\n    }\n\n    // 3) Signed-overflow indicator:\n    // This is 1 if the true result is outside the signed 32-bit range.\n    long long signed_overflow = (true_result  S_MAX_32 || true_result  S_MIN_32) ? 1 : 0;\n\n    // 4) Unsigned-overflow indicator:\n    // The definition depends on the operation.\n    long long unsigned_overflow;\n    if (test-op == OP_ADD) {\n        // For addition, this is 1 if the true unsigned sum is = 2^32 (carry-out).\n        unsigned_overflow = (u_result_64 = TWO_POW_32) ? 1 : 0;\n    } else { // OP_MUL\n        // For multiplication, this is 1 if the upper 32 bits of the 64-bit product are non-zero.\n        unsigned_overflow = (u_result_64  32) != 0 ? 1 : 0;\n    }\n    \n    results_out[0] = wrapped_result;\n    results_out[1] = saturated_result;\n    results_out[2] = signed_overflow;\n    results_out[3] = unsigned_overflow;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {OP_ADD, 1000, 2000},\n        {OP_ADD, 2147483647, 1},\n        {OP_ADD, -2147483648LL, -1},\n        {OP_ADD, 1073741824, 1073741824},\n        {OP_ADD, -2147483648LL, 2147483647},\n        {OP_MUL, 46340, 46340},\n        {OP_MUL, 46341, 46341},\n        {OP_MUL, 2147483647, 2},\n        {OP_MUL, -2147483648LL, 2},\n        {OP_MUL, -2147483648LL, -1},\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    long long all_results[num_cases * 4];\n\n    for (int i = 0; i  num_cases; ++i) {\n        analyze_arithmetic(test_cases[i], all_results[i * 4]);\n    }\n\n    printf(\"[\");\n    for (int i = 0; i  num_cases * 4; ++i) {\n        printf(\"%lld\", all_results[i]);\n        if (i  num_cases * 4 - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3651582"}]}