{"hands_on_practices": [{"introduction": "The fundamental challenge in designing a fast adder is managing the propagation of carry signals. This first exercise [@problem_id:3626965] offers an intuitive way to understand the carry recurrence relation by modeling it with a common digital component: the 2:1 multiplexer. By analyzing this model, you will see how a simple, chained structure naturally emerges, highlighting the sequential delay that limits the speed of basic adders and motivating the need for the parallel \"lookahead\" approach.", "problem": "A four-bit carry-lookahead adder is constructed to add two unsigned binary operands with bit positions $i \\in \\{0,1,2,3\\}$. For each bit position $i$, the bit-level propagate and generate signals are defined by $p_i = a_i \\oplus b_i$ and $g_i = a_i b_i$, respectively, where $\\oplus$ is exclusive-or and adjacency denotes logical and. Let $C_0$ denote the carry-in to bit position $0$, and let $C_4$ denote the carry-out of the most significant bit position.\n\nYou are asked to model the computation of $C_4$ using a tree of $2{:}1$ multiplexers, where for each bit position $i$, the multiplexer uses $p_i$ as its select input and uses the pair $(g_i, C_i)$ as its data inputs, in the order $\\text{data0} = g_i$ and $\\text{data1} = C_i$. Starting only from the definitions of $p_i$ and $g_i$, and from the meaning of carry generation and carry propagation, derive the nested multiplexer expression for $C_4$ and justify its correctness by logical equivalence.\n\nThen, analyze timing under the following technology assumptions, where all gates are idealized with a single propagation delay independent of input slews and output loads, and interconnect delays are negligible:\n- Each $2{:}1$ multiplexer has propagation delay $t_{\\text{MUX}} = 0.09 \\text{ ns}$.\n- Each two-input and gate has propagation delay $t_{\\land} = 0.03 \\text{ ns}$.\n- Each two-input or gate has propagation delay $t_{\\lor} = 0.04 \\text{ ns}$.\n\nFor the multiplexer-tree realization, assume $C_4$ is formed by cascading four $2{:}1$ multiplexers, one per bit position. For a comparison logic-gate realization of $C_4$, consider the canonical sum-of-products form built from the signals $p_3, p_2, p_1, p_0, g_3, g_2, g_1, g_0$, and $C_0$. Implement each product term as a right-associative chain of two-input and gates, and combine the five product terms using a balanced tree of two-input or gates. Under these assumptions:\n- Determine the worst-case path delay $D_{\\text{MUX}}$ from $\\{p_i, g_i, C_0\\}$ to $C_4$ through the multiplexer tree.\n- Determine the worst-case path delay $D_{\\text{LOGIC}}$ from $\\{p_i, g_i, C_0\\}$ to $C_4$ through the logic-gate realization.\n\nFinally, compute the ratio $R = D_{\\text{MUX}} / D_{\\text{LOGIC}}$. Express your final ratio as an exact number with no units. No rounding is required.", "solution": "` tags, and the final numerical answer inside `<final_answer>` tags, boxed using LaTeX. All mathematical notation must use LaTeX.\n\nThis structured approach ensures all constraints and requirements of the prompt are met accurately and logically.\n\n---\nThe problem statement has been validated as scientifically grounded, well-posed, and objective. It provides a clear, self-contained set of definitions and constraints within the established principles of digital logic design and computer architecture. All necessary data are provided. No flaws are identified.\n\nDerivation of the multiplexer expression for $C_4$:\nThe carry-out of a single bit-slice $i$ in an adder, $C_{i+1}$, is generated if the inputs $a_i$ and $b_i$ are both $1$, or if a carry $C_i$ is propagated. A carry is generated if $a_i=1$ and $b_i=1$. A carry is propagated if exactly one of $a_i$ or $b_i$ is $1$. Using the problem's definitions, the generate signal is $g_i = a_i b_i$ and the propagate signal is $p_i = a_i \\oplus b_i$. The carry recurrence relation is therefore:\n$$C_{i+1} = g_i \\lor p_i C_i$$\n\nThe problem specifies a $2{:}1$ multiplexer for each stage $i$ with select input $S=p_i$, data input $D_0=g_i$, and data input $D_1=C_i$. The output of such a multiplexer is given by the Boolean function:\n$$Y_i = \\overline{S} D_0 \\lor S D_1 = \\overline{p_i} g_i \\lor p_i C_i$$\nTo justify that this multiplexer correctly computes the next carry, i.e., $Y_i = C_{i+1}$, we must show that $\\overline{p_i} g_i \\lor p_i C_i$ is logically equivalent to $g_i \\lor p_i C_i$. This equivalence holds if and only if $p_i g_i = 0$. Let us prove this from the definitions of $p_i$ and $g_i$:\n$$p_i g_i = (a_i \\oplus b_i)(a_i b_i) = (a_i \\overline{b_i} \\lor \\overline{a_i} b_i)(a_i b_i)$$\nUsing the distributive property:\n$$p_i g_i = (a_i \\overline{b_i})(a_i b_i) \\lor (\\overline{a_i} b_i)(a_i b_i) = (a_i \\cdot a_i \\cdot \\overline{b_i} \\cdot b_i) \\lor (\\overline{a_i} \\cdot a_i \\cdot b_i \\cdot b_i)$$\nSince $x \\cdot \\overline{x} = 0$ and $x \\cdot x = x$, we have:\n$$p_i g_i = (a_i \\cdot 0) \\lor (0 \\cdot b_i) = 0 \\lor 0 = 0$$\nSince $p_i g_i=0$, we can expand the carry recurrence $g_i \\lor p_i C_i$ as follows:\n$$g_i \\lor p_i C_i = g_i \\cdot 1 \\lor p_i C_i = g_i (p_i \\lor \\overline{p_i}) \\lor p_i C_i = g_i p_i \\lor g_i \\overline{p_i} \\lor p_i C_i = 0 \\lor g_i \\overline{p_i} \\lor p_i C_i = \\overline{p_i} g_i \\lor p_i C_i$$\nThis proves that the output of the specified multiplexer is indeed $C_{i+1}$. We can thus write $C_{i+1} = \\text{MUX}(p_i, g_i, C_i)$, where $\\text{MUX}$ denotes the multiplexer function.\n\nFor a $4$-bit adder, we can unroll this recurrence starting from $C_0$:\n$C_1 = \\text{MUX}(p_0, g_0, C_0)$\n$C_2 = \\text{MUX}(p_1, g_1, C_1)$\n$C_3 = \\text{MUX}(p_2, g_2, C_2)$\n$C_4 = \\text{MUX}(p_3, g_3, C_3)$\n\nSubstituting these into one another gives the nested multiplexer expression for $C_4$:\n$$C_4 = \\text{MUX}(p_3, g_3, \\text{MUX}(p_2, g_2, \\text{MUX}(p_1, g_1, \\text{MUX}(p_0, g_0, C_0))))$$\nThis nested form shows how the carry calculation for each bit depends on the result of the previous bit, forming a chain.\n\nTiming analysis of the multiplexer tree ($D_{\\text{MUX}}$):\nThe problem states that $C_4$ is formed by cascading four $2{:}1$ multiplexers. This corresponds to the nested structure derived above. The worst-case path delay occurs for the signal that must travel through the entire chain. This is the path for the initial carry-in, $C_0$, to propagate to the final carry-out, $C_4$. This path traverses all four multiplexers serially:\n$C_0 \\rightarrow \\text{MUX}_0 \\rightarrow C_1 \\rightarrow \\text{MUX}_1 \\rightarrow C_2 \\rightarrow \\text{MUX}_2 \\rightarrow C_3 \\rightarrow \\text{MUX}_3 \\rightarrow C_4$.\nThe total delay is the sum of the propagation delays of the four multiplexers.\n$$D_{\\text{MUX}} = 4 \\times t_{\\text{MUX}} = 4 \\times 0.09 \\text{ ns} = 0.36 \\text{ ns}$$\n\nTiming analysis of the logic-gate realization ($D_{\\text{LOGIC}}$):\nFirst, we write the canonical sum-of-products (SoP) expression for $C_4$ by expanding the logical recurrence $C_{i+1} = g_i \\lor p_i C_i$:\n$C_1 = g_0 \\lor p_0 C_0$\n$C_2 = g_1 \\lor p_1 C_1 = g_1 \\lor p_1(g_0 \\lor p_0 C_0) = g_1 \\lor p_1 g_0 \\lor p_1 p_0 C_0$\n$C_3 = g_2 \\lor p_2 C_2 = g_2 \\lor p_2(g_1 \\lor p_1 g_0 \\lor p_1 p_0 C_0) = g_2 \\lor p_2 g_1 \\lor p_2 p_1 g_0 \\lor p_2 p_1 p_0 C_0$\n$C_4 = g_3 \\lor p_3 C_3 = g_3 \\lor p_3(g_2 \\lor p_2 g_1 \\lor p_2 p_1 g_0 \\lor p_2 p_1 p_0 C_0)$\n$$C_4 = g_3 \\lor p_3 g_2 \\lor p_3 p_2 g_1 \\lor p_3 p_2 p_1 g_0 \\lor p_3 p_2 p_1 p_0 C_0$$\nThis is a two-level logic structure (AND-OR). The total delay is the sum of the delay through the AND stage and the delay through the OR stage.\n\nAND stage: The product terms are implemented as right-associative chains of two-input AND gates. The term with the most inputs determines the worst-case delay of this stage. The term $p_3 p_2 p_1 p_0 C_0$ has $5$ inputs. A chain of two-input AND gates to compute this requires $5-1=4$ gates in series. The delay of the AND stage is:\n$$D_{\\text{AND}} = 4 \\times t_{\\land} = 4 \\times 0.03 \\text{ ns} = 0.12 \\text{ ns}$$\n\nOR stage: We are combining $5$ product terms using a balanced tree of two-input OR gates. The depth of a balanced binary tree with $N$ leaves is $\\lceil \\log_2 N \\rceil$. For $N=5$, the depth is $\\lceil \\log_2 5 \\rceil = \\lceil 2.321... \\rceil = 3$. The delay of the OR stage is:\n$$D_{\\text{OR}} = 3 \\times t_{\\lor} = 3 \\times 0.04 \\text{ ns} = 0.12 \\text{ ns}$$\n\nThe worst-case total delay $D_{\\text{LOGIC}}$ is the sum of the maximum delay of the AND stage and the delay of the OR tree, as the OR tree can only begin its final computation after the slowest product term is available.\n$$D_{\\text{LOGIC}} = D_{\\text{AND}} + D_{\\text{OR}} = 0.12 \\text{ ns} + 0.12 \\text{ ns} = 0.24 \\text{ ns}$$\n\nFinal ratio calculation:\nThe ratio $R$ is the delay of the multiplexer implementation divided by the delay of the logic-gate implementation.\n$$R = \\frac{D_{\\text{MUX}}}{D_{\\text{LOGIC}}} = \\frac{0.36 \\text{ ns}}{0.24 \\text{ ns}} = \\frac{36}{24} = \\frac{3}{2} = 1.5$$\nThe ratio is an exact dimensionless number.", "answer": "$$\\boxed{1.5}$$", "id": "3626965"}, {"introduction": "Having established the need for a parallel carry computation, we now explore how to build this \"lookahead\" logic efficiently. This practice [@problem_id:3626898] introduces the critical concepts of group generate and propagate signals, which allow us to determine carries over blocks of bits simultaneously. You will investigate how real-world hardware constraints, specifically the maximum number of inputs a gate can have (fan-in), force us to organize this lookahead logic into a hierarchical, tree-like structure, a cornerstone of modern high-speed adder design.", "problem": "A Carry-Lookahead Adder (CLA) constructs group carry signals to accelerate addition by exploiting single-bit generate and propagate signals. Let the single-bit generate and propagate signals be denoted by $G_i$ and $P_i$, respectively, and let the carry recursion be given by the fundamental relation $C_{i+1} = G_i \\lor \\left(P_i \\land C_i\\right)$. Define the group generate signal $G_{0,k}$ to be the signal that, independent of the incoming carry $C_0$, indicates that the bit positions $0$ through $k$ collectively generate a carry into position $k+1$.\n\nStarting strictly from the carry recursion $C_{i+1} = G_i \\lor \\left(P_i \\land C_i\\right)$ and the definition of $G_{0,k}$ as the $C_0$-independent contribution to $C_{k+1}$ from bits $0$ through $k$, derive the explicit sum-of-products form for $G_{0,k}$ in terms of $\\{G_t,P_t\\}$ for $t \\in \\{0,1,\\dots,k\\}$. Assume an implementation in Complementary Metal–Oxide–Semiconductor (CMOS) technology, with standard cells that include an OR gate whose maximum static fan-in is $4$. Further assume that all product terms required for $G_{0,k}$ are computed in parallel by separate AND networks, and that the only constraint considered for combining these product terms is the $4$-input limit on OR gates.\n\nUnder these assumptions:\n- Determine the largest integer $k$ such that $G_{0,k}$ can be implemented using a single OR stage with no OR decomposition, i.e., with one OR gate receiving all required product terms directly.\n- For general $k$, propose a decomposition that minimizes the number of additional OR levels by organizing the OR gates into a balanced $4$-ary tree, and derive the minimal number of OR levels needed to combine all product terms.\n\nExpress your final answer as a pair $\\left(k_{\\max}, L_{\\min}(k)\\right)$, where $k_{\\max}$ is the largest $k$ implementable in one OR stage, and $L_{\\min}(k)$ is the minimal number of OR levels in the balanced $4$-ary OR tree needed to realize $G_{0,k}$. No rounding is required. Provide your answer as a single analytical expression.", "solution": "The problem is valid as it is scientifically grounded in the principles of digital logic design, specifically carry-lookahead adders, and is well-posed with clear, objective constraints. We will proceed with the solution.\n\nThe fundamental carry recursion for an $n$-bit adder is given by:\n$$C_{i+1} = G_i \\lor (P_i \\land C_i)$$\nwhere $G_i$ is the generate signal for bit $i$, $P_i$ is the propagate signal for bit $i$, and $C_i$ is the carry-in to bit $i$. This relation is valid for $i \\in \\{0, 1, \\dots, n-1\\}$.\n\nThe first step is to derive the explicit sum-of-products form for the group generate signal $G_{0,k}$. The problem defines $G_{0,k}$ as the component of the carry-out signal from bit $k$, $C_{k+1}$, that is independent of the initial carry-in $C_0$. To find this, we must express $C_{k+1}$ in terms of $C_0$ and the single-bit signals $\\{G_t, P_t\\}$ for $t \\in \\{0, 1, \\dots, k\\}$. We achieve this by repeatedly substituting the carry recursion relation.\n\nLet's expand the expression for carry signals starting from $C_1$:\nFor $i=0$:\n$$C_1 = G_0 \\lor (P_0 \\land C_0)$$\n\nFor $i=1$:\n$$C_2 = G_1 \\lor (P_1 \\land C_1)$$\nSubstituting the expression for $C_1$:\n$$C_2 = G_1 \\lor (P_1 \\land (G_0 \\lor (P_0 \\land C_0)))$$\nUsing the distributive law of Boolean algebra, $A \\land (B \\lor C) = (A \\land B) \\lor (A \\land C)$:\n$$C_2 = G_1 \\lor (P_1 \\land G_0) \\lor (P_1 \\land P_0 \\land C_0)$$\n\nFor $i=2$:\n$$C_3 = G_2 \\lor (P_2 \\land C_2)$$\nSubstituting the expression for $C_2$:\n$$C_3 = G_2 \\lor (P_2 \\land (G_1 \\lor (P_1 \\land G_0) \\lor (P_1 \\land P_0 \\land C_0)))$$\n$$C_3 = G_2 \\lor (P_2 \\land G_1) \\lor (P_2 \\land P_1 \\land G_0) \\lor (P_2 \\land P_1 \\land P_0 \\land C_0)$$\n\nObserving the pattern, we can assert the general form for $C_{k+1}$ by induction. The expression for $C_{k+1}$ is a disjunction (OR) of terms. One set of terms involves only $G_i$ and $P_i$ signals, and a final term involves $C_0$.\nThe general expression for $C_{k+1}$ is:\n$$C_{k+1} = \\left( G_k \\lor (P_k \\land G_{k-1}) \\lor \\dots \\lor (P_k \\land \\dots \\land P_1 \\land G_0) \\right) \\lor \\left( (P_k \\land \\dots \\land P_0) \\land C_0 \\right)$$\nThis can be written more compactly using disjunction ($\\bigvee$) and conjunction ($\\bigwedge$) operators:\n$$C_{k+1} = \\left( \\bigvee_{j=0}^{k} \\left( G_j \\land \\left( \\bigwedge_{i=j+1}^{k} P_i \\right) \\right) \\right) \\lor \\left( \\left( \\bigwedge_{i=0}^{k} P_i \\right) \\land C_0 \\right)$$\nThe problem defines the group generate signal $G_{0,k}$ as the contribution to $C_{k+1}$ that is independent of $C_0$. From the expression above, this is the first major disjunct:\n$$G_{0,k} = \\bigvee_{j=0}^{k} \\left( G_j \\land \\left( \\bigwedge_{i=j+1}^{k} P_i \\right) \\right)$$\nExpanding this out, we get the sum-of-products form:\n$$G_{0,k} = G_k \\lor (P_k \\land G_{k-1}) \\lor (P_k \\land P_{k-1} \\land G_{k-2}) \\lor \\dots \\lor (P_k \\land P_{k-1} \\land \\dots \\land P_1 \\land G_0)$$\nThe terms in this disjunction are the product terms that must be computed by AND networks and then combined by OR gates. The number of these product terms, which corresponds to the number of inputs to the OR network, is determined by the range of the index $j$ in the compact notation, which is from $0$ to $k$. Thus, there are $k-0+1 = k+1$ product terms.\n\nNow, we can address the two parts of the problem.\n\n1.  **Determine the largest integer $k$ ($k_{\\max}$) for which $G_{0,k}$ is implementable in a single OR stage.**\nA single OR stage is specified to be a single OR gate. The problem states a constraint on the maximum static fan-in of this gate, which is $4$. This means the gate can accept a maximum of $4$ inputs.\nThe number of inputs to the OR gate for implementing $G_{0,k}$ is the number of product terms, which we found to be $k+1$.\nTo use a single OR gate, the number of terms must be less than or equal to the maximum fan-in:\n$$k+1 \\leq 4$$\n$$k \\leq 3$$\nThe largest integer $k$ that satisfies this condition is $3$. Therefore, $k_{\\max} = 3$.\nFor $k=3$, the expression is $G_{0,3} = G_3 \\lor (P_3 \\land G_2) \\lor (P_3 \\land P_2 \\land G_1) \\lor (P_3 \\land P_2 \\land P_1 \\land G_0)$, which has exactly $4$ terms and can be implemented with a single $4$-input OR gate.\n\n2.  **For a general $k$, derive the minimal number of OR levels $L_{\\min}(k)$.**\nFor a general $k$, we need to combine $N = k+1$ product terms. The problem specifies that this is to be done using a balanced $4$-ary tree of OR gates, where each OR gate has a fan-in of at most $F=4$. We need to find the minimal number of levels (the depth) of this tree.\n\nLet $L$ be the number of levels in the OR gate tree. A single OR gate constitutes $L=1$ level.\nA tree of logic gates with $L$ levels and a uniform fan-in of $F$ can combine at most $F^L$ inputs.\nIn our case, $F=4$ and the number of inputs is $N=k+1$. We need to find the smallest integer $L$ that can accommodate all $N$ inputs. This is given by the inequality:\n$$F^L \\geq N$$\n$$4^L \\geq k+1$$\nTo solve for $L$, we take the logarithm base $4$ of both sides:\n$$\\log_4(4^L) \\geq \\log_4(k+1)$$\n$$L \\geq \\log_4(k+1)$$\nSince the number of levels $L$ must be an integer, we must take the ceiling of the right-hand side to find the minimal integer $L$ that satisfies the inequality.\n$$L_{\\min}(k) = \\lceil \\log_4(k+1) \\rceil$$\nThis formula represents the depth of a balanced $4$-ary tree required to compute the disjunction of $k+1$ terms. For example, if $k=15$, we have $N=16$ terms. $L_{\\min}(15) = \\lceil \\log_4(16) \\rceil = \\lceil 2 \\rceil = 2$. This requires a two-level OR tree. If $k=3$, we have $N=4$ terms. $L_{\\min}(3) = \\lceil \\log_4(4) \\rceil = \\lceil 1 \\rceil = 1$, which is consistent with our result for $k_{\\max}$. If $k=0$, there is $N=1$ term, $G_0$. $L_{\\min}(0) = \\lceil \\log_4(1) \\rceil = \\lceil 0 \\rceil = 0$, correctly indicating no OR gates are needed.\n\nThe final answer is the pair $(k_{\\max}, L_{\\min}(k))$.\n$k_{\\max} = 3$\n$L_{\\min}(k) = \\lceil \\log_4(k+1) \\rceil$\n\nThe final answer is the pair $(3, \\lceil \\log_4(k+1) \\rceil)$.", "answer": "$$\\boxed{\\begin{pmatrix} 3 & \\lceil \\log_4(k+1) \\rceil \\end{pmatrix}}$$", "id": "3626898"}, {"introduction": "This final practice [@problem_id:3626979] synthesizes the principles of carry logic and parallel computation by guiding you through the analysis of a complete 8-bit carry-lookahead adder. You will derive the full Boolean expression for the final carry-out, a classic result that demonstrates the power of the lookahead technique. Furthermore, you will analyze the implementation of this expression using two different logic gate libraries, providing concrete insight into how technology choices affect the circuit's depth and ultimate performance.", "problem": "Consider an $8$-bit adder that uses the carry-lookahead principle. For each bit position $i \\in \\{0,1,\\dots,7\\}$, let the bit-wise generate and propagate signals be defined by $g_i = a_i b_i$ and $p_i = a_i \\oplus b_i$, where $a_i$ and $b_i$ are the operand bits and $\\oplus$ denotes exclusive-or. The carry recurrence is $c_{i+1} = g_i \\vee (p_i \\wedge c_i)$ with the initial carry-in $c_0$ given. Your task is to compute the lookahead carry-out $c_8$ and to analyze its implementation depth under two gate libraries.\n\nAssume the following gate libraries and implementation rules:\n\n- Gate library $\\mathcal{A}$: Use only AND-OR-Invert (AOI) gates and inverters. The AOI gates available are AOI$_{21}$ and AOI$_{22}$, with functions\n  $y = \\overline{(a_1 \\wedge a_2) \\vee b}$ and $y = \\overline{(a_1 \\wedge a_2) \\vee (b_1 \\wedge b_2)}$.\n  You may assume any unused inputs are tied to logical constants as needed. Each AOI gate counts as one stage, and each inverter counts as one stage. All multi-input operations must be implemented by composing two-input gates into balanced binary trees. When you need an AND of two signals using AOI gates, implement it as AOI$_{21}$ (to obtain a NAND) followed by an inverter.\n\n- Gate library $\\mathcal{N}$: Use only two-input NAND, two-input NOR, and inverters. Each gate counts as one stage. All multi-input operations must be implemented by composing two-input gates into balanced binary trees.\n\nFor both libraries, enforce a fan-in of two for all AND and OR compositions. You will implement the canonical lookahead form of $c_8$ as an OR-of-products over the $p_i$, $g_i$, and $c_0$ signals, where each product may be a chain of propagates multiplying a single generate or the initial carry $c_0$.\n\nTasks:\n\n1. Starting only from the recurrence $c_{i+1} = g_i \\vee (p_i \\wedge c_i)$ and the definitions of $g_i$ and $p_i$, derive a closed-form symbolic expression for $c_8$ as a disjunction of conjunctions involving $\\{p_i\\}$, $\\{g_i\\}$, and $c_0$. Express your result entirely in terms of these signals without introducing any new operators.\n\n2. Under gate library $\\mathcal{A}$, implement the derived $c_8$ using a balanced tree of AOI gates for the final OR-of-products. For the propagate-chain products, construct each multi-input AND using two-input AOI$_{21}$ plus inverters arranged in a balanced binary tree. Count the minimum number of gate stages on the longest logical path from $\\{p_i,g_i,c_0\\}$ to $c_8$.\n\n3. Under gate library $\\mathcal{N}$, implement the same $c_8$ by computing each product term using two-input NAND plus inverter for AND, and combine the products using a balanced NOR tree to realize the multi-input OR, followed by a final inverter if necessary to obtain a non-inverted $c_8$. Count the minimum number of gate stages on the longest logical path from $\\{p_i,g_i,c_0\\}$ to $c_8$.\n\nProvide your final answer as a single object containing: the symbolic expression for $c_8$, the stage count under library $\\mathcal{A}$, and the stage count under library $\\mathcal{N}$. No rounding is required and no physical units are involved. Express the final answer exactly as an analytic expression or integers where appropriate.", "solution": "The problem statement has been validated and is deemed valid. It is a scientifically grounded, well-posed, and objective problem in digital logic design. All necessary information and constraints are provided, and there are no internal contradictions.\n\nThe problem requires the derivation and implementation analysis of the carry-out signal $c_8$ for an $8$-bit carry-lookahead adder.\n\n### Task 1: Derivation of the Expression for $c_8$\n\nThe carry recurrence relation is given as $c_{i+1} = g_i \\vee (p_i \\wedge c_i)$, where $g_i = a_i b_i$ is the generate signal and $p_i = a_i \\oplus b_i$ is the propagate signal for bit position $i$. The initial carry-in is $c_0$. We are tasked with finding the expression for the final carry-out, $c_8$.\n\nWe can derive the expression for $c_8$ by recursively expanding the recurrence relation, starting from $c_1$ and observing the emerging pattern.\n$c_1 = g_0 \\vee (p_0 \\wedge c_0)$\n$c_2 = g_1 \\vee (p_1 \\wedge c_1) = g_1 \\vee (p_1 \\wedge (g_0 \\vee (p_0 \\wedge c_0))) = g_1 \\vee (p_1 \\wedge g_0) \\vee (p_1 \\wedge p_0 \\wedge c_0)$\n$c_3 = g_2 \\vee (p_2 \\wedge c_2) = g_2 \\vee (p_2 \\wedge (g_1 \\vee (p_1 \\wedge g_0) \\vee (p_1 \\wedge p_0 \\wedge c_0)))$\n$c_3 = g_2 \\vee (p_2 \\wedge g_1) \\vee (p_2 \\wedge p_1 \\wedge g_0) \\vee (p_2 \\wedge p_1 \\wedge p_0 \\wedge c_0)$\n\nThe general form for $c_{i+1}$ is a disjunction (OR) of terms, where each term represents a condition for generating a carry. A carry is generated at stage $i$ (term $g_i$), or generated at a previous stage $k < i$ and propagated through all subsequent stages up to $i-1$ (term $p_i \\wedge p_{i-1} \\wedge \\dots \\wedge p_{k+1} \\wedge g_k$). The initial carry $c_0$ can also be propagated.\n\nApplying this pattern for $c_8$ (i.e., for $i=7$ in $c_{i+1}$), we get an expression with $9$ product terms:\n$c_8 = g_7 \\vee (p_7 \\wedge g_6) \\vee (p_7 \\wedge p_6 \\wedge g_5) \\vee (p_7 \\wedge p_6 \\wedge p_5 \\wedge g_4) \\vee (p_7 \\wedge p_6 \\wedge p_5 \\wedge p_4 \\wedge g_3) \\vee (p_7 \\wedge p_6 \\wedge p_5 \\wedge p_4 \\wedge p_3 \\wedge g_2) \\vee (p_7 \\wedge p_6 \\wedge p_5 \\wedge p_4 \\wedge p_3 \\wedge p_2 \\wedge g_1) \\vee (p_7 \\wedge p_6 \\wedge \\dots \\wedge p_1 \\wedge g_0) \\vee (p_7 \\wedge p_6 \\wedge \\dots \\wedge p_0 \\wedge c_0)$.\n\nThis is the required closed-form symbolic expression for $c_8$ as a disjunction of conjunctions (OR-of-products). Let us denote the $k$-th product term (from right to left, starting at $k=0$) by $T_k$. For $k \\in \\{0, \\dots, 7\\}$, the term involving $g_k$ has $8-k$ inputs. The term involving $c_0$ has $9$ inputs. The term $g_7$ has $1$ input.\nThe product terms are:\n\\begin{itemize}\n    \\item $T_8 = g_7$ ($1$ input)\n    \\item $T_7 = p_7 \\wedge g_6$ ($2$ inputs)\n    \\item $T_6 = p_7 \\wedge p_6 \\wedge g_5$ ($3$ inputs)\n    \\item $T_5 = p_7 \\wedge p_6 \\wedge p_5 \\wedge g_4$ ($4$ inputs)\n    \\item $T_4 = p_7 \\wedge p_6 \\wedge p_5 \\wedge p_4 \\wedge g_3$ ($5$ inputs)\n    \\item $T_3 = p_7 \\wedge p_6 \\wedge p_5 \\wedge p_4 \\wedge p_3 \\wedge g_2$ ($6$ inputs)\n    \\item $T_2 = p_7 \\wedge p_6 \\wedge p_5 \\wedge p_4 \\wedge p_3 \\wedge p_2 \\wedge g_1$ ($7$ inputs)\n    \\item $T_1 = p_7 \\wedge p_6 \\wedge \\dots \\wedge p_1 \\wedge g_0$ ($8$ inputs)\n    \\item $T_0 = p_7 \\wedge p_6 \\wedge \\dots \\wedge p_0 \\wedge c_0$ ($9$ inputs)\n\\end{itemize}\n$c_8 = T_8 \\vee T_7 \\vee T_6 \\vee T_5 \\vee T_4 \\vee T_3 \\vee T_2 \\vee T_1 \\vee T_0$.\n\n### Task 2: Implementation Analysis under Gate Library $\\mathcal{A}$\n\nLibrary $\\mathcal{A}$ consists of AOI$_{21}$ gates ($y = \\overline{(a_1 \\wedge a_2) \\vee b}$), AOI$_{22}$ gates, and inverters. Each gate contributes one stage to the path delay. We must find the minimum number of stages to implement $c_8$. The expression for $c_8$ is a sum-of-products, which can be efficiently implemented using a two-level NAND-NAND logic structure, based on De Morgan's laws: $c_8 = \\bigvee T_k = \\overline{\\bigwedge \\overline{T_k}}$.\n\n1.  **First Logic Level (Product Terms):** We need to compute the negation of each product term, $\\overline{T_k}$. This is equivalent to creating multi-input NAND gates.\n    -   A $2$-input NAND gate can be realized with a single AOI$_{21}$ gate by setting the $b$ input to logical $0$: $y = \\overline{(a_1 \\wedge a_2) \\vee 0} = \\overline{a_1 \\wedge a_2}$. This costs $1$ stage.\n    -   A multi-input NAND gate with $N$ inputs can be constructed as a balanced binary tree of $2$-input NAND gates. The depth of this tree, and thus the number of stages, is $\\lceil \\log_2(N) \\rceil$.\n    -   The product terms $T_k$ have varying numbers of inputs, from $1$ to $9$. The critical path is determined by the term with the most inputs, which is $T_0$ with $9$ inputs.\n    -   The delay to compute $\\overline{T_0}$ (a $9$-input NAND) is $\\lceil \\log_2(9) \\rceil = \\lceil 3.17 \\rceil = 4$ stages. All other $\\overline{T_k}$ signals will be available at or before this time.\n\n2.  **Second Logic Level (Final Disjunction):** We combine the $9$ intermediate signals ($\\overline{T_8}, \\dots, \\overline{T_0}$) using another multi-input NAND gate.\n    -   The function to implement is $c_8 = \\overline{\\overline{T_8} \\wedge \\overline{T_7} \\wedge \\dots \\wedge \\overline{T_0}}$. This is a $9$-input NAND operation on the signals from the first level.\n    -   Using a balanced tree of $2$-input NAND gates (implemented with AOI$_{21}$), the delay for this second level is also $\\lceil \\log_2(9) \\rceil = 4$ stages.\n\nThe total minimum number of stages is the sum of the delays of the two levels.\nTotal Stages ($\\mathcal{A}$) = (Delay of first NAND level) + (Delay of second NAND level) = $4 + 4 = 8$.\n\n### Task 3: Implementation Analysis under Gate Library $\\mathcal{N}$\n\nLibrary $\\mathcal{N}$ provides $2$-input NAND, $2$-input NOR, and inverters, each costing one stage. The problem prescribes a specific implementation methodology for the OR-of-products expression of $c_8$.\n\n1.  **First Logic Level (Product Terms):** The problem states to compute each product term using a structure of \"$two-input NAND plus inverter for AND$\".\n    -   A $2$-input AND gate, $x \\wedge y$, is implemented as $\\overline{\\overline{x \\wedge y}}$, which is a $2$-input NAND gate followed by an inverter. The delay is $1 (\\text{NAND}) + 1 (\\text{INV}) = 2$ stages.\n    -   A multi-input AND gate with $N$ inputs is constructed as a balanced binary tree of these $2$-input AND modules.\n    -   The depth of the tree is $\\lceil \\log_2(N) \\rceil$ levels of $2$-input ANDs.\n    -   The total delay for an $N$-input AND is $2 \\times \\lceil \\log_2(N) \\rceil$ stages.\n    -   The longest product term is $T_0$ with $9$ inputs. The delay to compute $T_0$ is $2 \\times \\lceil \\log_2(9) \\rceil = 2 \\times 4 = 8$ stages. After $8$ stages, all product terms $T_k$ are available.\n\n2.  **Second Logic Level (Final Disjunction):** The problem states to \"combine the products using a balanced NOR tree to realize the multi-input OR, followed by a final inverter if necessary\".\n    -   We need to compute the $9$-input OR of the product terms: $c_8 = T_8 \\vee T_7 \\vee \\dots \\vee T_0$.\n    -   A balanced tree of $2$-input NOR gates for $9$ inputs has a depth of $\\lceil \\log_2(9) \\rceil = 4$ stages. Each NOR gate costs $1$ stage. The output of this NOR tree is $\\overline{c_8}$.\n    -   To obtain the final non-inverted result $c_8$, a final inverter is required: $c_8 = \\overline{\\overline{c_8}}$. This inverter adds $1$ stage.\n    -   The total delay for the $9$-input OR stage is $4 (\\text{NOR tree}) + 1 (\\text{inverter}) = 5$ stages.\n\nThe total number of stages for this prescribed implementation is the sum of the delays for the two levels.\nTotal Stages ($\\mathcal{N}$) = (Delay of AND level) + (Delay of OR level) = $8 + 5 = 13$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\begin{gathered}\ng_7 \\vee (p_7 \\wedge g_6) \\vee (p_7 \\wedge p_6 \\wedge g_5) \\vee (p_7 \\wedge p_6 \\wedge p_5 \\wedge g_4) \\\\\n\\vee (p_7 \\wedge p_6 \\wedge p_5 \\wedge p_4 \\wedge g_3) \\vee (p_7 \\wedge p_6 \\wedge p_5 \\wedge p_4 \\wedge p_3 \\wedge g_2) \\\\\n\\vee (p_7 \\wedge p_6 \\wedge p_5 \\wedge p_4 \\wedge p_3 \\wedge p_2 \\wedge g_1) \\\\\n\\vee (p_7 \\wedge p_6 \\wedge p_5 \\wedge p_4 \\wedge p_3 \\wedge p_2 \\wedge p_1 \\wedge g_0) \\\\\n\\vee (p_7 \\wedge p_6 \\wedge p_5 \\wedge p_4 \\wedge p_3 \\wedge p_2 \\wedge p_1 \\wedge p_0 \\wedge c_0)\n\\end{gathered}\n& 8 & 13\n\\end{pmatrix}\n}\n$$", "id": "3626979"}]}