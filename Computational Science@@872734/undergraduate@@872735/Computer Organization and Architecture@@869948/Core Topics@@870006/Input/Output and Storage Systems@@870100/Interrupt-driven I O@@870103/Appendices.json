{"hands_on_practices": [{"introduction": "In interrupt-driven systems, especially those with real-time requirements, performance is not just about speed but about predictability. An Interrupt Service Routine (ISR) must not only execute its task but also adhere to strict timing constraints to ensure the system remains stable and responsive. This practice challenges you to balance two critical, and often competing, requirements: a long-term CPU utilization budget and a hard real-time deadline for each interrupt. By working through this scenario [@problem_id:3653028], you will develop the essential skill of translating high-level system specifications into concrete computational budgets, quantifying the maximum workload an ISR can handle without violating its timing contracts.", "problem": "A microcontroller performs interrupt-driven input/output for a periodic sensor. The Central Processing Unit (CPU) clock is $100\\,\\mathrm{MHz}$. A hardware timer triggers a sensor sampling Interrupt Service Routine (ISR) at a frequency of $1\\,\\mathrm{kHz}$, yielding a period of $1\\,\\mathrm{ms}$ between interrupts. The system imposes two constraints:\n- A long-term CPU time budget: over any interval, at most a fraction $B$ of total CPU time may be consumed by the sensor ISR (including its fixed entry/exit overhead). Here, $B = 0.18$.\n- A hard real-time deadline: each ISR invocation must complete by the end of its $1\\,\\mathrm{ms}$ period, even in the worst case when interrupts are temporarily disabled elsewhere in the system for up to $120\\,\\mu\\mathrm{s}$.\n\nAssume a fixed per-interrupt overhead of $800$ cycles for interrupt entry/exit and mandatory register save/restore, which must be counted against the ISR’s time usage. All remaining cycles within the ISR are available for the application’s sensor-processing computation.\n\nStarting only from core definitions of CPU utilization (fraction of CPU time over an interval), deadline feasibility (completing execution by the end of the period under worst-case latency), and the relationship between time and cycles via the CPU frequency, determine the maximum number of cycles per interrupt, $C_{\\max}$, that can be spent in the ISR’s computation body (excluding the fixed $800$-cycle overhead), while satisfying both the budget and the deadline constraints.\n\nExpress the final allowable computation per interrupt $C_{\\max}$ in cycles. Report an exact integer number of cycles in your answer. Do not include any units in your final answer.", "solution": "The problem requires finding the maximum number of computation cycles, denoted as $C_{\\max}$, for an Interrupt Service Routine (ISR) that satisfies two constraints: a long-term CPU utilization budget and a hard real-time deadline. We begin by formally defining the system parameters and constraints.\n\nThe given parameters are:\n- CPU clock frequency: $f_{CPU} = 100\\,\\mathrm{MHz} = 100 \\times 10^6\\,\\mathrm{Hz}$\n- Interrupt frequency: $f_{ISR} = 1\\,\\mathrm{kHz} = 1 \\times 10^3\\,\\mathrm{Hz}$\n- CPU time budget fraction: $B = 0.18$\n- Worst-case interrupt latency: $T_{latency} = 120\\,\\mu\\mathrm{s} = 120 \\times 10^{-6}\\,\\mathrm{s}$\n- Fixed ISR overhead: $C_{overhead} = 800$ cycles\n\nFrom the interrupt frequency, we can determine the period between interrupts:\n$$ T_{ISR} = \\frac{1}{f_{ISR}} = \\frac{1}{1 \\times 10^3\\,\\mathrm{Hz}} = 10^{-3}\\,\\mathrm{s} = 1\\,\\mathrm{ms} $$\n\nLet $C_{comp}$ be the number of cycles available for the application's computation within the ISR. The total number of cycles consumed by a single ISR invocation is the sum of the overhead and the computation cycles:\n$$ C_{total} = C_{overhead} + C_{comp} $$\n\nThe total execution time for one ISR invocation is related to the total cycles by the CPU frequency:\n$$ T_{exec} = \\frac{C_{total}}{f_{CPU}} = \\frac{C_{overhead} + C_{comp}}{f_{CPU}} $$\n\nWe will now analyze each of the two constraints to find the maximum allowable value for $C_{comp}$. The final answer, $C_{\\max}$, will be the most restrictive of these two limits.\n\nConstraint 1: Long-Term CPU Time Budget\nThe long-term CPU utilization by the ISR must not exceed the budget fraction $B$. CPU utilization, $U$, is the fraction of time the CPU is busy executing the ISR. Over one period $T_{ISR}$, this is the ratio of the ISR's execution time $T_{exec}$ to the period $T_{ISR}$.\n$$ U = \\frac{T_{exec}}{T_{ISR}} \\le B $$\n\nSubstituting the expressions for $T_{exec}$ and $T_{ISR}$:\n$$ \\frac{\\left(\\frac{C_{overhead} + C_{comp}}{f_{CPU}}\\right)}{\\left(\\frac{1}{f_{ISR}}\\right)} \\le B $$\n$$ \\frac{(C_{overhead} + C_{comp}) \\cdot f_{ISR}}{f_{CPU}} \\le B $$\n\nWe solve this inequality for the maximum $C_{comp}$ permitted by the budget, which we'll call $C_{comp, budget}$.\n$$ C_{overhead} + C_{comp, budget} \\le \\frac{B \\cdot f_{CPU}}{f_{ISR}} $$\n$$ C_{comp, budget} \\le \\frac{B \\cdot f_{CPU}}{f_{ISR}} - C_{overhead} $$\n\nSubstituting the given numerical values:\n$$ C_{comp, budget} \\le \\frac{0.18 \\cdot (100 \\times 10^6\\,\\mathrm{Hz})}{1 \\times 10^3\\,\\mathrm{Hz}} - 800 $$\n$$ C_{comp, budget} \\le \\frac{18 \\times 10^6}{1 \\times 10^3} - 800 $$\n$$ C_{comp, budget} \\le 18000 - 800 $$\n$$ C_{comp, budget} \\le 17200\\,\\text{cycles} $$\n\nConstraint 2: Hard Real-Time Deadline\nThe deadline requires each ISR invocation to complete before the next interrupt occurs, i.e., within the period $T_{ISR}$. This must hold even in the worst-case scenario where the start of the ISR is delayed by the maximum interrupt latency, $T_{latency}$.\n\nThe time available for the ISR to execute, measured from the moment it actually starts, is the period duration minus the latency:\n$$ T_{available} = T_{ISR} - T_{latency} $$\n\nThe total execution time of the ISR, $T_{exec}$, must be less than or equal to this available time:\n$$ T_{exec} \\le T_{available} $$\n$$ \\frac{C_{overhead} + C_{comp}}{f_{CPU}} \\le T_{ISR} - T_{latency} $$\n\nWe solve this inequality for the maximum $C_{comp}$ permitted by the deadline, which we'll call $C_{comp, deadline}$.\n$$ C_{overhead} + C_{comp, deadline} \\le (T_{ISR} - T_{latency}) \\cdot f_{CPU} $$\n$$ C_{comp, deadline} \\le (T_{ISR} - T_{latency}) \\cdot f_{CPU} - C_{overhead} $$\n\nSubstituting the given numerical values:\n$$ T_{ISR} - T_{latency} = (1 \\times 10^{-3}\\,\\mathrm{s}) - (120 \\times 10^{-6}\\,\\mathrm{s}) = (1000 \\times 10^{-6}\\,\\mathrm{s}) - (120 \\times 10^{-6}\\,\\mathrm{s}) = 880 \\times 10^{-6}\\,\\mathrm{s} $$\nNow, we can find the cycle limit:\n$$ C_{comp, deadline} \\le (880 \\times 10^{-6}\\,\\mathrm{s}) \\cdot (100 \\times 10^6\\,\\mathrm{Hz}) - 800 $$\n$$ C_{comp, deadline} \\le (880 \\times 100) - 800 $$\n$$ C_{comp, deadline} \\le 88000 - 800 $$\n$$ C_{comp, deadline} \\le 87200\\,\\text{cycles} $$\n\nFinal Determination\nThe number of computation cycles $C_{comp}$ must satisfy both constraints simultaneously. Therefore, the maximum allowable number of cycles, $C_{\\max}$, is the minimum of the limits derived from each constraint.\n$$ C_{\\max} = \\min(C_{comp, budget}, C_{comp, deadline}) $$\n$$ C_{\\max} = \\min(17200, 87200) $$\n$$ C_{\\max} = 17200 $$\n\nThus, the maximum number of cycles that can be spent in the ISR's computation body while satisfying both the budget and deadline constraints is $17200$. The budget constraint is the more restrictive one in this system.", "answer": "$$\\boxed{17200}$$", "id": "3653028"}, {"introduction": "While performance is crucial, correctness is paramount. A fast ISR that loses data or deadlocks the system is worse than a slow one. This exercise [@problem_id:3653019] moves beyond simple timing to address the complexities of interfacing with real-world hardware, which often includes tricky features like memory-mapped I/O (MMIO) with read side effects, level-triggered interrupts, and relaxed memory ordering rules. Your task is to reason from first principles to design an ISR that guarantees 'exactly-once' event processing, a fundamental requirement for data integrity. This practice will solidify your understanding of how to write robust driver code that correctly manages hardware state and prevents subtle race conditions.", "problem": "A computer system uses Interrupt Service Routine (ISR) dispatch to process events from a peripheral that exposes Memory-Mapped Input/Output (MMIO) registers. The peripheral implements the following memory-mapped registers with scientifically realistic behavior:\n\n- A data register at address $A_D$ that returns the next event payload on each MMIO read and has a read side effect: each read consumes exactly one event and decrements a pending count $N$ by $1$. If $N=0$, a read of $A_D$ is architecturally undefined and must be avoided.\n- A status register at address $A_S$ whose bit $RDY$ is set if and only if $N>0$; reading $A_S$ has no side effects.\n- An interrupt mask register at address $A_M$ where writing the value $1$ masks the device’s interrupt and writing the value $0$ unmasks it.\n- An End-of-Interrupt register at address $A_E$ where writing the value $1$ sends End-of-Interrupt (EOI) to the interrupt controller.\n\nThe device raises a level-triggered interrupt line while $RDY=1$. The Central Processing Unit (CPU) runs a single-producer/single-consumer driver where the ISR is the producer that enqueues payloads into a ring buffer $Q$ with head index $h$ and tail index $t$, and a user thread is the consumer. The publish step is defined as writing the payload into $Q[h]$ followed by an atomic increment of $h$ with release semantics.\n\nThe architecture’s memory model is relaxed: without explicit barriers, normal memory operations and MMIO operations may be reordered. A barrier $B()$ is available that guarantees all prior MMIO reads complete before any subsequent normal memory stores become visible to other cores or threads. The atomic increment of $h$ has release semantics on normal memory, but does not imply ordering with respect to MMIO without an explicit $B()$.\n\nExactly-once consumption is defined as a one-to-one mapping over time between device events and software enqueues: for every device event that contributes $+1$ to $N$ at time $t$, the ISR eventually enqueues exactly one corresponding payload into $Q$ and publishes it once, with no duplicates and no losses, even if events arrive while the ISR executes.\n\nYou are to reason from first principles about interrupts, MMIO, read side effects, level-triggering, and memory ordering. Consider the following candidate ISRs, expressed as ordered steps, and choose the design that guarantees exactly-once consumption and avoids races, reentrancy hazards, and ordering violations.\n\nOption A:\n- Write $1$ to $A_M$ to mask the device interrupt.\n- While $\\text{mmio\\_read}(A_S)$ indicates $RDY=1$:\n  - Let $d \\leftarrow \\text{mmio\\_read}(A_D)$.\n  - Call $B()$.\n  - Write $d$ into $Q[h]$.\n  - Atomically increment $h$ with release semantics.\n- Write $1$ to $A_E$ to send EOI.\n- Write $0$ to $A_M$ to unmask the device interrupt.\n\nOption B:\n- Write $1$ to $A_E$ to send EOI immediately.\n- Do not mask the device; loop while $\\text{mmio\\_read}(A_S)$ indicates $RDY=1$:\n  - Let $d \\leftarrow \\text{mmio\\_read}(A_D)$.\n  - Write $d$ into $Q[h]$.\n  - Atomically increment $h$ with release semantics.\n  - Call $B()$.\n- Leave the device unmasked throughout.\n\nOption C:\n- Write $1$ to $A_M$ to mask the device interrupt.\n- Read $\\text{mmio\\_read}(A_S)$ once; if $RDY=1$:\n  - Let $d \\leftarrow \\text{mmio\\_read}(A_D)$.\n  - Write $d$ into $Q[h]$.\n  - Atomically increment $h$ with release semantics.\n- Write $1$ to $A_E$ to send EOI.\n- Write $0$ to $A_M$ to unmask the device interrupt.\n\nOption D:\n- Write $1$ to $A_M$ to mask the device interrupt.\n- Read a ready count approximation $c$ from $\\text{mmio\\_read}(A_S)$ (assume $c$ reflects the number of pending events at that instant).\n- For $i$ from $1$ to $c$:\n  - Let $d \\leftarrow \\text{mmio\\_read}(A_D)$.\n  - Write $d$ into $Q[h]$.\n  - Atomically increment $h$ with release semantics.\n- Call $B()$ once after the loop.\n- Write $1$ to $A_E$ to send EOI.\n- Write $0$ to $A_M$ to unmask the device interrupt.\n\nWhich option ensures exactly-once consumption under the stated assumptions and prevents races and ordering violations? Select the single best answer.\n\nA. Option A\nB. Option B\nC. Option C\nD. Option D", "solution": "To select the correct Interrupt Service Routine (ISR) design, we must analyze the system's constraints and evaluate how each option addresses them. The goal is to achieve 'exactly-once' event consumption without data loss, duplication, or system instability.\n\n### Analysis of Core Requirements\n\n1.  **Level-Triggered Interrupt Handling**: The interrupt line remains asserted as long as the device's $RDY$ bit is set ($N>0$). If the ISR sends an End-of-Interrupt (EOI) to the controller while $RDY$ is still set, the CPU will immediately re-trigger the same interrupt, potentially leading to a live-lock or \"interrupt storm\" that starves all other processing. Therefore, a correct ISR must ensure the $RDY$ condition is cleared (by processing all pending events) *before* sending the EOI.\n\n2.  **MMIO Read Side Effects**: Reading the data register $A_D$ is a destructive operation that consumes an event. This read must only be performed after confirming that an event is actually available (i.e., after checking that $A_S$ shows $RDY=1$). Reading $A_D$ when $N=0$ is undefined and must be avoided.\n\n3.  **Event Arrival During ISR**: New events can arrive while the ISR is executing. A correct ISR must not assume only one event is pending. It must be prepared to handle multiple events that were pending upon entry as well as any new events that arrive during its execution. This necessitates a loop that continues processing as long as the device reports it is ready.\n\n4.  **Relaxed Memory Ordering**: The problem states that MMIO reads and normal memory stores can be reordered. To ensure data integrity, the payload $d$ read from the device's register $A_D$ must be available before the CPU attempts to write it into the shared buffer $Q$. The provided barrier $B()$ guarantees this ordering. The correct sequence inside the processing loop must be: `mmio_read(A_D)` -> `B()` -> `write to Q`.\n\n5.  **Reentrancy/Concurrency**: The safest way to handle the level-triggered interrupt and prevent the ISR from re-entering itself (which could corrupt state) is to mask the interrupt source at the device level (via $A_M$) upon entering the ISR and unmask it just before exiting.\n\n### Evaluation of Candidate Options\n\n*   **Option A**:\n    - **Masking**: Correctly masks the device interrupt at the beginning (`Write 1 to A_M`) and unmasks it at the end. This prevents reentrancy and gives the ISR full control over processing.\n    - **Looping**: Uses a `while` loop that checks $RDY$ on each iteration. This correctly processes all pending events and any new ones that arrive during execution, ensuring the $RDY$ condition is cleared before the ISR exits.\n    - **Ordering**: Inside the loop, it correctly orders the operations: MMIO read, then the barrier $B()$, then the write to the queue, and finally the atomic update to the head pointer. This guarantees that the consumer thread will not see the updated pointer until the data is safely in the queue.\n    - **EOI**: Sends the EOI *after* the loop has completed, which is the correct point for a level-triggered interrupt.\n    - **Verdict**: **Correct**. This design is robust and correctly addresses all system constraints.\n\n*   **Option B**:\n    - **EOI**: Sends the EOI immediately. This is critically flawed for a level-triggered interrupt and will likely cause an interrupt storm.\n    - **Ordering**: The barrier `B()` is misplaced after the head pointer update, which is too late to guarantee ordering between the MMIO read and the data write to the queue.\n    - **Verdict**: **Incorrect**. The immediate EOI is a fatal error.\n\n*   **Option C**:\n    - **Looping**: Fails to use a loop. It checks the status only once. If multiple events are pending or a new event arrives, they will be missed in this ISR invocation. This will leave the $RDY$ condition set, and an interrupt storm will likely occur after the EOI is sent.\n    - **Verdict**: **Incorrect**. It cannot guarantee processing of all events.\n\n*   **Option D**:\n    - **Looping**: Reads an event count $c$ once. This creates a race condition. If new events arrive after $c$ is read, they will not be processed, leaving $RDY$ asserted and leading to a likely interrupt storm.\n    - **Ordering**: Calls the barrier `B()` only once after the entire loop. This is incorrect. The barrier must be inside the loop to enforce ordering for *each* read/write pair.\n    - **Verdict**: **Incorrect**. It has a race condition and improper barrier usage.\n\n### Conclusion\nBased on the analysis, Option A is the only design that correctly and robustly handles all the specified hardware behaviors and system constraints, guaranteeing exactly-once event processing.", "answer": "$$\\boxed{A}$$", "id": "3653019"}, {"introduction": "A well-designed system must be resilient, capable of detecting and recovering from faults. Even a perfectly coded ISR can be susceptible to failure due to unforeseen hardware states or transient errors. This final practice [@problem_id:3652973] introduces a critical mechanism for system-level reliability: the watchdog timer (WDT). You will learn how to perform a worst-case timing analysis to set a WDT timeout that is sensitive enough to catch a true ISR lockup but robust enough to avoid false alarms during periods of maximum system load. This exercise extends your focus from the correctness of a single component to the fault tolerance of the entire system, a crucial consideration in building dependable computing devices.", "problem": "An embedded controller uses interrupt-driven input/output, where a hardware sensor generates periodic interrupts that are serviced by an Interrupt Service Routine (ISR). A Watchdog Timer (WDT) must be periodically serviced (\"kicked\") to indicate liveness; if the WDT is not serviced within a timeout, it triggers a non-maskable event. The current design services the WDT at the end of each successful ISR execution. You are asked to choose a WDT timeout and a safe recovery path to catch ISR lockups without false positives.\n\nThe system exhibits the following well-tested behavioral bounds during normal operation:\n- The sensor generates interrupts with nominal period $T_{irq} = 4.8\\,\\mathrm{ms}$ and positive jitter up to $\\Delta = 0.4\\,\\mathrm{ms}$, so the longest inter-arrival under normal conditions is $T_{irq}^{\\max} = T_{irq} + \\Delta$.\n- Global interrupts may be masked during atomic critical sections for up to $B = 12\\,\\mathrm{ms}$.\n- After interrupts are unmasked, higher-priority activity can delay ISR dispatch by up to $P = 3.0\\,\\mathrm{ms}$, and the dispatcher overhead contributes $S = 0.2\\,\\mathrm{ms}$.\n- The ISR worst-case execution time is $W = 1.1\\,\\mathrm{ms}$.\n- The system timer resolution is $R_t = 0.1\\,\\mathrm{ms}$ and should be included as slack when reasoning about time intervals.\n\nSafety and availability requirements specify that any ISR lockup must be detected and addressed within $T_{\\text{detect}}^{\\max} = 25\\,\\mathrm{ms}$, and recovery must avoid a full system reset, quiesce the device to prevent further data corruption, preserve diagnostic logs, and re-establish normal interrupt-driven operation. Assume the Watchdog Timer can be configured to raise a Non-Maskable Interrupt (NMI) on its first timeout rather than performing an immediate system reset.\n\nFrom first principles, the WDT timeout $T_{wd}$ must be strictly greater than the longest interval between successive WDT services that can occur under non-fault conditions, and less than or equal to $T_{\\text{detect}}^{\\max}$. Which option best meets these constraints?\n\nA. Set $T_{wd} = 8\\,\\mathrm{ms}$; on timeout, immediately reset the entire system.\n\nB. Set $T_{wd} = 15\\,\\mathrm{ms}$; on timeout, simply re-enable global interrupts and return from the fault handler to continue normal operation.\n\nC. Set $T_{wd} = 22\\,\\mathrm{ms}$; on timeout, raise a Non-Maskable Interrupt (NMI) that invokes a fault handler which logs the fault, flushes outbound I/O queues, halts any Direct Memory Access (DMA) engines and places the device into a documented quiescent state, performs a targeted soft reset of only the I/O subsystem, reinstalls and re-enables the ISR, issues a memory barrier before resuming, and then returns to normal operation.\n\nD. Set $T_{wd} = 30\\,\\mathrm{ms}$; on timeout, mask interrupts, spin-wait for the device to clear its status, and then unmask interrupts.", "solution": "The solution requires determining a valid range for the Watchdog Timer (WDT) timeout, $T_{wd}$, and selecting the option with a timeout in that range and a correct recovery procedure.\n\n### Step 1: Determine the valid range for the WDT timeout, $T_{wd}$\n\nThe WDT timeout must satisfy two conditions:\n1.  It must be strictly greater than the longest possible interval between two consecutive WDT services under normal (non-fault) conditions to avoid false positives.\n2.  It must be less than or equal to the maximum allowed fault detection time, $T_{\\text{detect}}^{\\max}$.\n\n**Lower Bound for $T_{wd}$**:\nThe WDT is serviced at the completion of each ISR. We need to find the maximum possible time between the completion of one ISR ($ISR_n$) and the completion of the next ($ISR_{n+1}$). This worst-case interval, $T_{interval}^{\\max}$, occurs when the time between interrupt arrivals is maximized, the response time for the first ISR is minimized, and the response time for the second ISR is maximized.\n\nThe interval between completions $C_n$ and $C_{n+1}$ can be expressed as:\n$$ T_{interval} = (A_{n+1} - A_n) + (C_{n+1} - A_{n+1}) - (C_n - A_n) $$\nwhere $A_k$ is the arrival time of interrupt $k$ and $C_k$ is its completion time. To maximize this interval:\n- Maximize the inter-arrival time $(A_{n+1} - A_n)$: $T_{irq}^{\\max} = T_{irq} + \\Delta = 4.8\\,\\mathrm{ms} + 0.4\\,\\mathrm{ms} = 5.2\\,\\mathrm{ms}$.\n- Maximize the response time for $ISR_{n+1}$, $(C_{n+1} - A_{n+1})$: This is the sum of maximum latency and worst-case execution time.\n  $T_{resp}^{\\max} = B + P + S + W = 12\\,\\mathrm{ms} + 3.0\\,\\mathrm{ms} + 0.2\\,\\mathrm{ms} + 1.1\\,\\mathrm{ms} = 16.3\\,\\mathrm{ms}$.\n- Minimize the response time for $ISR_n$, $(C_n - A_n)$: This is the sum of minimum latency and best-case execution time. The minimum latency is just the dispatcher overhead $S$. Assuming best-case execution time is negligible ($W_{min} \\approx 0$), $T_{resp}^{\\min} \\approx S = 0.2\\,\\mathrm{ms}$.\n\nCombining these worst-case values:\n$$ T_{interval}^{\\max} = T_{irq}^{\\max} + T_{resp}^{\\max} - T_{resp}^{\\min} $$\n$$ T_{interval}^{\\max} = 5.2\\,\\mathrm{ms} + 16.3\\,\\mathrm{ms} - 0.2\\,\\mathrm{ms} = 21.3\\,\\mathrm{ms} $$\n\nTo ensure the timeout is never shorter than this interval due to timer quantization, we add the timer resolution slack, $R_t$.\n$$ T_{wd} > T_{interval}^{\\max} + R_t = 21.3\\,\\mathrm{ms} + 0.1\\,\\mathrm{ms} = 21.4\\,\\mathrm{ms} $$\n\n**Upper Bound for $T_{wd}$**:\nThe problem states that a lockup must be detected within $25\\,\\mathrm{ms}$.\n$$ T_{wd} \\le T_{\\text{detect}}^{\\max} = 25\\,\\mathrm{ms} $$\n\n**Valid Range for $T_{wd}$**:\nCombining the bounds, the WDT timeout must be in the range $(21.4\\,\\mathrm{ms}, 25\\,\\mathrm{ms}]$.\n\n### Step 2: Evaluate the Options\n\n- **A. Set $T_{wd} = 8\\,\\mathrm{ms}$; on timeout, immediately reset the entire system.**\n  - **Timeout**: $8\\,\\mathrm{ms}$ is not in the valid range. It is far too short and will cause false timeouts during normal operation.\n  - **Recovery**: A full system reset violates the requirement to \"avoid a full system reset\" and preserve logs.\n\n- **B. Set $T_{wd} = 15\\,\\mathrm{ms}$; on timeout, simply re-enable global interrupts and return.**\n  - **Timeout**: $15\\,\\mathrm{ms}$ is not in the valid range. It is too short.\n  - **Recovery**: This path is unsafe. If the ISR is genuinely locked in a loop, returning from the NMI will resume the locked code, leading to another immediate WDT event. It does not fix the root cause.\n\n- **C. Set $T_{wd} = 22\\,\\mathrm{ms}$; on timeout, raise an NMI...**\n  - **Timeout**: $22\\,\\mathrm{ms}$ is within the valid range ($21.4\\,\\mathrm{ms}  22\\,\\mathrm{ms} \\le 25\\,\\mathrm{ms}$).\n  - **Recovery**: This recovery path is comprehensive and correct. It uses an NMI for a high-priority fault response. It correctly logs data, quiesces the hardware to prevent corruption, avoids a full reset, and performs a targeted soft reset to re-establish operation, meeting all specified recovery requirements.\n\n- **D. Set $T_{wd} = 30\\,\\mathrm{ms}$; on timeout, mask interrupts, spin-wait...**\n  - **Timeout**: $30\\,\\mathrm{ms}$ is not in the valid range. It exceeds the maximum detection time of $25\\,\\mathrm{ms}$.\n  - **Recovery**: This path is dangerous. Spin-waiting inside an NMI handler would effectively freeze the system.\n\n### Conclusion\nOption C is the only choice that provides a WDT timeout within the correctly calculated safe range and implements a robust recovery procedure that meets all of the system's safety and availability requirements.", "answer": "$$\\boxed{C}$$", "id": "3652973"}]}