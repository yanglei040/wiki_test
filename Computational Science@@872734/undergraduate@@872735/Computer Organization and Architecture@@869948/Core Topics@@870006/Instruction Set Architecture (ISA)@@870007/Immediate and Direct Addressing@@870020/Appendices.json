{"hands_on_practices": [{"introduction": "Immediate addressing is efficient, but the fixed size of the immediate field imposes fundamental limits on the constants you can generate. This exercise challenges you to explore these boundaries on a hypothetical processor with a small, $8$-bit immediate field. By analyzing how different instructions with sign extension and zero extension can be combined, you will discover the precise range of synthesizable constants and identify which values absolutely require loading from memory via direct addressing [@problem_id:3648996].", "problem": "A simplified load and arithmetic subset of a hypothetical reduced instruction set computer uses two operand-specifying mechanisms: immediate addressing and direct addressing. The machine has general-purpose registers of width $w=32$ bits, two’s complement integer arithmetic, and the following instructions that accept an immediate field of width $k=8$ bits embedded in the instruction word.\n\nDefinitions and semantics:\n- Immediate addressing: the operand is the constant encoded in the instruction. The instruction $\\mathrm{MOVI}\\;r_d,\\; \\mathrm{imm}\\_8$ writes into register $r_d$ the two’s complement sign-extension of the $k=8$ bit field $\\mathrm{imm}\\_8$ to $w=32$ bits. The instruction $\\mathrm{ORI}\\;r_d,\\; \\mathrm{imm}\\_8$ computes the bitwise $\\mathrm{OR}$ of $r_d$ with the zero-extension of the $k=8$ bit field $\\mathrm{imm}\\_8$ to $w=32$ bits, affecting only the low $8$ bits of $r_d$ and leaving higher bits unchanged. No other immediate-bearing instruction is available.\n- Direct addressing: the operand is located in memory at an absolute address encoded in the instruction. The instruction $\\mathrm{LDRI}\\;r_d,\\; \\mathrm{addr}\\_{16}$ loads the $w=32$ bit word stored at absolute memory address $\\mathrm{addr}\\_{16}$ into $r_d$. Assume a read-only constant pool is available in memory so any $w=32$ bit constant can be placed there and fetched via direct addressing when needed.\n\nYou are to decide, for the concrete set of target constants\n$$S=\\{-200,\\,-129,\\,-128,\\,-1,\\,0,\\,42,\\,100,\\,127,\\,128,\\,200,\\,255,\\,256,\\,300\\},$$\nwhich constants must be loaded via direct addressing (i.e., cannot be placed in a register using only immediate addressing in a single instruction, nor via any finite sequence of the given immediate-bearing instructions that does not access memory). In addition to the classification over $S$, your answer must correctly state the general pattern of what is and is not synthesizable with the given $k=8$ immediate field, and list sound workarounds that avoid direct addressing when possible.\n\nWhich option is correct?\n\nA. The only constants directly representable by a single immediate are those $c$ with $c\\in[-128,127]$; beyond that, a two-instruction workaround covers exactly $c\\in[128,255]$ via $\\mathrm{MOVI}\\;r_d,\\,0$ followed by $\\mathrm{ORI}\\;r_d,\\,c$, because zero-extension and bitwise $\\mathrm{OR}$ from zero can produce any nonnegative $c$ whose $8$ low bits equal $c$. All other $c$ require direct addressing. Therefore, over $S$, exactly $\\{-200,\\,-129,\\,256,\\,300\\}$ must be loaded via direct addressing.\n\nB. Any $32$-bit constant $c$ with $c\\in[0,65535]$ can be built without memory by a two-instruction sequence that uses zero-extension, so none of $\\{128,\\,200,\\,255\\}$ requires direct addressing, but $c\\in\\{-200,\\,-129,\\,-128,\\,-1\\}$ must be fetched from memory because negative constants cannot be built from zero with bitwise operations. Therefore, over $S$, exactly $\\{-200,\\,-129,\\,-128,\\,-1\\}$ require direct addressing; all others do not.\n\nC. Because repeated use of $\\mathrm{ORI}$ can progressively set higher-order bytes to any desired pattern, every constant in $S$ can be synthesized without memory; no direct addressing is necessary if one allows enough immediate $\\mathrm{ORI}$ operations.\n\nD. Since the immediate is only $k=8$ bits wide, any constant with magnitude exceeding $255$ must be loaded from memory, but any constant with magnitude at most $255$ (including all negatives with $|c|\\le 255$) is directly representable in one instruction due to sign extension. Therefore, over $S$, exactly $\\{256,\\,300\\}$ require direct addressing; all others do not.", "solution": "### Step 1: Extract Givens\nThe problem statement provides the following definitions and constraints for a hypothetical reduced instruction set computer:\n-   Register width: $w=32$ bits.\n-   Integer representation: Two's complement.\n-   Immediate field width: $k=8$ bits.\n-   Instruction $\\mathrm{MOVI}\\;r_d,\\; \\mathrm{imm}\\_8$: Writes the $w=32$ bit two's complement sign-extension of the $k=8$ bit immediate field $\\mathrm{imm}\\_8$ into register $r_d$.\n-   Instruction $\\mathrm{ORI}\\;r_d,\\; \\mathrm{imm}\\_8$: Computes the bitwise $\\mathrm{OR}$ of the value in register $r_d$ with the $w=32$ bit zero-extension of the $k=8$ bit immediate field $\\mathrm{imm}\\_8$. The result is written back to $r_d$. The problem statement clarifies that this affects only the low $8$ bits of $r_d$, which is a direct consequence of OR-ing with a zero-extended $8$-bit value.\n-   No other immediate-bearing instructions exist.\n-   Instruction $\\mathrm{LDRI}\\;r_d,\\; \\mathrm{addr}\\_{16}$: Loads a $w=32$ bit word from a memory address into $r_d$.\n-   A constant pool in read-only memory is available for loading any $32$-bit constant via $\\mathrm{LDRI}$.\n-   The set of target constants is $S=\\{-200,\\,-129,\\,-128,\\,-1,\\,0,\\,42,\\,100,\\,127,\\,128,\\,200,\\,255,\\,256,\\,300\\}$.\n-   The task is to identify which constants in $S$ cannot be generated in a register using a finite sequence of only $\\mathrm{MOVI}$ and $\\mathrm{ORI}$ instructions, thus requiring a load from memory (direct addressing).\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is scientifically grounded in the principles of computer organization and architecture. The concepts of instruction sets, addressing modes (immediate, direct), data representation (two's complement), and bitwise operations (sign extension, zero extension, bitwise OR) are standard. The instructions, though simplified, are well-defined and plausible for a hypothetical machine. The semantics are stated precisely. The term \"affecting only the low $8$ bits\" for the $\\mathrm{ORI}$ instruction is a direct and correct description of the effect of performing a bitwise OR with a zero-extended $8$-bit value, and is therefore redundant but not contradictory. The problem is self-contained, objective, and well-posed, admitting a unique, derivable solution. No flaws are identified.\n\n### Step 3: Verdict and Action\nThe problem is valid. The solution will now be derived.\n\n### Derivation of the Solution\n\nLet us determine the set of all $32$-bit integer constants that can be synthesized using only the $\\mathrm{MOVI}$ and $\\mathrm{ORI}$ instructions. A constant is synthesizable if it can be the final value in a register after a sequence of these instructions.\n\n1.  **Analysis of the $\\mathrm{MOVI}$ instruction:**\n    The instruction $\\mathrm{MOVI}\\;r_d,\\; \\mathrm{imm}\\_8$ takes an $8$-bit two's complement immediate value and sign-extends it to $32$ bits.\n    An $8$-bit two's complement integer has a range from $-2^{8-1}$ to $2^{8-1}-1$, which is $[-128, 127]$.\n    -   If $\\mathrm{imm}\\_8 \\in [0, 127]$, its sign bit (the $8^{th}$ bit) is $0$. Sign extension fills the upper $24$ bits of $r_d$ with $0$s. The value in $r_d$ will be equal to $\\mathrm{imm}\\_8$.\n    -   If $\\mathrm{imm}\\_8 \\in [-128, -1]$, its sign bit is $1$. Sign extension fills the upper $24$ bits of $r_d$ with $1$s. The value in $r_d$ is the corresponding $32$-bit negative number.\n    Therefore, a single $\\mathrm{MOVI}$ instruction can generate any integer constant $c$ such that $c \\in [-128, 127]$.\n\n2.  **Analysis of the $\\mathrm{ORI}$ instruction:**\n    The instruction $\\mathrm{ORI}\\;r_d,\\; \\mathrm{imm}\\_8$ computes $r_d \\leftarrow r_d \\lor \\mathrm{ZEXT}_{32}(\\mathrm{imm}\\_8)$. The \"field\" $\\mathrm{imm}\\_8$ being zero-extended implies it is treated as an $8$-bit unsigned value, which can represent any integer from $0$ to $255$. $\\mathrm{ZEXT}_{32}(\\mathrm{imm}\\_8)$ results in a $32$-bit value where the upper $24$ bits are all $0$s and the lower $8$ bits correspond to $\\mathrm{imm}\\_8$.\n\n3.  **Analysis of instruction sequences:**\n    Any sequence of synthesization must start with a $\\mathrm{MOVI}$ to load an initial value, followed by any number of $\\mathrm{ORI}$ instructions. Due to the associative and idempotent properties of the bitwise OR operation, any sequence of $\\mathrm{ORI}$s is equivalent to a single $\\mathrm{ORI}$ with an immediate value whose bits are the union of the bits of all the original immediates.\n    Let a synthesizable constant be $C$. It must be of the form:\n    $$C = \\mathrm{SEXT}_{32}(\\mathrm{imm}\\_A) \\lor \\mathrm{ZEXT}_{32}(\\mathrm{imm}\\_B)$$\n    where $\\mathrm{imm}\\_A$ is an $8$-bit two's complement value (from $\\mathrm{MOVI}$) and $\\mathrm{imm}\\_B$ is an effective $8$-bit unsigned value (from one or more $\\mathrm{ORI}$s, $0 \\le \\mathrm{imm}\\_B \\le 255$).\n\n    We analyze two cases based on the sign of $\\mathrm{imm}\\_A$.\n\n    **Case 1: Synthesizing non-negative constants.**\n    To synthesize a non-negative constant, the upper bits must not be all $1$s. This requires the initial $\\mathrm{MOVI}$ to use a non-negative immediate, $\\mathrm{imm}\\_A \\in [0, 127]$.\n    -   $\\mathrm{SEXT}_{32}(\\mathrm{imm}\\_A)$ for $\\mathrm{imm}\\_A \\ge 0$ is the same as $\\mathrm{ZEXT}_{32}(\\mathrm{imm}\\_A)$. The value in the register, $S_A$, is in the range $[0, 127]$. Its upper $24$ bits are $0$.\n    -   The subsequent $\\mathrm{ORI}$ operation computes $S_A \\lor \\mathrm{ZEXT}_{32}(\\mathrm{imm}\\_B)$. The value $\\mathrm{ZEXT}_{32}(\\mathrm{imm}\\_B)$ also has its upper $24$ bits as $0$.\n    -   The result will therefore have its upper $24$ bits as $0$. This means the resulting constant $C$ must be non-negative and less than $2^8=256$. Actually, less than $2^8 + 2^8 - 1$... wait, the ORI is only on the low 8 bits. The upper 24 bits are 0. So the resulting number is constrained to the range $[0, 2^8-1]$? Not quite. The value is $S_A \\lor V_B$ where $S_A \\in [0, 127]$ and $V_B \\in [0, 255]$. The result is in $[0, 255]$.\n    -   Can we form any integer $c \\in [0, 255]$?\n        -   For $c \\in [0, 127]$, we can use a single instruction: $\\mathrm{MOVI}\\;r_d,\\; c$.\n        -   For $c \\in [128, 255]$, we can use a two-instruction sequence:\n            1.  $\\mathrm{MOVI}\\;r_d,\\;0$. This sets $r_d$ to $0$.\n            2.  $\\mathrm{ORI}\\;r_d,\\;c$. This computes $r_d \\leftarrow 0 \\lor c$, which results in $c$. This is possible since $c$ is a valid $8$-bit unsigned immediate for $\\mathrm{ORI}$.\n    -   Thus, the entire range of integers $[0, 255]$ is synthesizable.\n\n    **Case 2: Synthesizing negative constants.**\n    To synthesize a negative constant, the upper bits must be $1$s. This requires the initial $\\mathrm{MOVI}$ to use a negative immediate, $\\mathrm{imm}\\_A \\in [-128, -1]$.\n    -   $\\mathrm{SEXT}_{32}(\\mathrm{imm}\\_A)$ results in a value $S_A$ whose upper $24$ bits are all $1$s. Let the $8$-bit pattern for $\\mathrm{imm}\\_A$ be $P_A$. $S_A$ is $\\mathrm{0xFFFFFF}P_A$. As $\\mathrm{imm}\\_A$ is negative, the most significant bit of $P_A$ is $1$. So $P_A \\in [\\mathrm{0x80}, \\mathrm{0xFF}]$.\n    -   The subsequent $\\mathrm{ORI}$ operation computes $S_A \\lor \\mathrm{ZEXT}_{32}(\\mathrm{imm}\\_B)$. Let the $8$-bit pattern of $\\mathrm{imm}\\_B$ be $P_B$. The computed value is $C = (\\mathrm{0xFFFFFF}P_A) \\lor (\\mathrm{0x000000}P_B) = \\mathrm{0xFFFFFF}(P_A \\lor P_B)$.\n    -   Since the most significant bit of $P_A$ is $1$, the most significant bit of the resulting byte, $P_A \\lor P_B$, must also be $1$.\n    -   This means the low byte of any synthesizable negative constant must have its most significant bit set. Such bytes are in the range $[\\mathrm{0x80}, \\mathrm{0xFF}]$.\n    -   A $32$-bit number of the form $\\mathrm{0xFFFFFF}Z$ where $Z \\in [\\mathrm{0x80}, \\mathrm{0xFF}]$ represents an integer in the range $[-128, -1]$.\n    -   Therefore, any synthesizable negative number must lie in the range $[-128, -1]$. This entire range can be generated by the single instruction $\\mathrm{MOVI}$ alone. The $\\mathrm{ORI}$ instruction does not extend the range of synthesizable negative numbers.\n\n4.  **Conclusion on Synthesizable Constants:**\n    The set of all integers synthesizable by the given instructions is the union of the ranges from Case 1 and Case 2:\n    $$ \\{\\text{Synthesizable Integers}\\} = [-128, -1] \\cup [0, 255] $$\n    This union forms the continuous set of all integers $c$ such that $-128 \\le c \\le 255$.\n    Any integer constant outside this range $[-128, 255]$ cannot be synthesized and must be loaded from memory using the $\\mathrm{LDRI}$ instruction.\n\n5.  **Classification of Constants in Set $S$:**\n    We now test each constant in $S$ against the synthesizable range $[-128, 255]$.\n    -   $-200$: Not in $[-128, 255]$. Must be loaded.\n    -   $-129$: Not in $[-128, 255]$. Must be loaded.\n    -   $-128$: In $[-128, 255]$. Synthesizable.\n    -   $-1$: In $[-128, 255]$. Synthesizable.\n    -   $0$: In $[-128, 255]$. Synthesizable.\n    -   $42$: In $[-128, 255]$. Synthesizable.\n    -   $100$: In $[-128, 255]$. Synthesizable.\n    -   $127$: In $[-128, 255]$. Synthesizable.\n    -   $128$: In $[-128, 255]$. Synthesizable.\n    -   $200$: In $[-128, 255]$. Synthesizable.\n    -   $255$: In $[-128, 255]$. Synthesizable.\n    -   $256$: Not in $[-128, 255]$. Must be loaded.\n    -   $300$: Not in $[-128, 255]$. Must be loaded.\n\n    The set of constants from $S$ that must be loaded via direct addressing is $\\{-200, -129, 256, 300\\}$.\n\n### Option-by-Option Analysis\n\n**A. The only constants directly representable by a single immediate are those $c$ with $c\\in[-128,127]$; beyond that, a two-instruction workaround covers exactly $c\\in[128,255]$ via $\\mathrm{MOVI}\\;r_d,\\,0$ followed by $\\mathrm{ORI}\\;r_d,\\,c$, because zero-extension and bitwise $\\mathrm{OR}$ from zero can produce any nonnegative $c$ whose $8$ low bits equal $c$. All other $c$ require direct addressing. Therefore, over $S$, exactly $\\{-200,\\,-129,\\,256,\\,300\\}$ must be loaded via direct addressing.**\n\n-   **Analysis:** The reasoning establishes that constants in $[-128, 127]$ can be made in one instruction, and constants in $[128, 255]$ can be made in two. The union of these sets is the integer range $[-128, 255]$. The claim \"All other c require direct addressing\" correctly identifies this as the complete set of synthesizable integers. The application of this rule to the set $S$ yields the list $\\{-200, -129, 256, 300\\}$, which matches our derivation. The phrase \"whose 8 low bits equal c\" is a slightly imprecise way of saying \"for $c \\in [0,255]$\", but the context makes the meaning clear. The entire statement is consistent and correct.\n-   **Verdict:** **Correct**.\n\n**B. Any $32$-bit constant $c$ with $c\\in[0,65535]$ can be built without memory by a two-instruction sequence that uses zero-extension, so none of $\\{128,\\,200,\\,255\\}$ requires direct addressing, but $c\\in\\{-200,\\,-129,\\,-128,\\,-1\\}$ must be fetched from memory because negative constants cannot be built from zero with bitwise operations. Therefore, over $S$, exactly $\\{-200,\\,-129,\\,-128,\\,-1\\}$ require direct addressing; all others do not.**\n\n-   **Analysis:** The claim that any constant in $[0, 65535]$ can be built is false. The $\\mathrm{ORI}$ instruction only affects the lowest $8$ bits, so it is impossible to set bits in the range $[15:8]$ to generate a number like $256$ ($0x100$). The claim that $\\{-128, -1\\}$ must be fetched from memory is also false, as they are directly creatable with $\\mathrm{MOVI}$. The final list of constants to be loaded is incorrect.\n-   **Verdict:** **Incorrect**.\n\n**C. Because repeated use of $\\mathrm{ORI}$ can progressively set higher-order bytes to any desired pattern, every constant in $S$ can be synthesized without memory; no direct addressing is necessary if one allows enough immediate $\\mathrm{ORI}$ operations.**\n\n-   **Analysis:** This statement is based on a false premise. The $\\mathrm{ORI}$ instruction is defined to use a zero-extended $8$-bit immediate. This means the value being OR-ed with the register is of the form $\\mathrm{0x000000XX}$. Such an operation can never set any bits in the higher-order bytes (bits $31$ through $8$). Therefore, it is impossible to \"progressively set higher-order bytes\". Consequently, not all constants can be synthesized.\n-   **Verdict:** **Incorrect**.\n\n**D. Since the immediate is only $k=8$ bits wide, any constant with magnitude exceeding $255$ must be loaded from memory, but any constant with magnitude at most $255$ (including all negatives with $|c|\\le 255$) is directly representable in one instruction due to sign extension. Therefore, over $S$, exactly $\\{256,\\,300\\}$ require direct addressing; all others do not.**\n\n-   **Analysis:** The claim that \"any constant with magnitude at most $255$ ... is directly representable in one instruction\" is false. \"Directly representable in one instruction\" refers to the $\\mathrm{MOVI}$ instruction, which can only produce constants in $[-128, 127]$. Constants like $200$ (magnitude $200 \\le 255$) require two instructions. More importantly, the claim that any constant with magnitude at most $255$ is synthesizable is false. For example, $c = -200$ has $|c|=200 \\le 255$, but as we derived, it is not synthesizable. The final list of constants to be loaded, $\\{256, 300\\}$, is incomplete as it omits $-200$ and $-129$.\n-   **Verdict:** **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "3648996"}, {"introduction": "Beyond theoretical limits, the choice between addressing modes has tangible effects on performance and code size. This practice provides a quantitative comparison by analyzing a simple array-summing loop implemented in two ways: one using an immediate value for the loop increment, and the other fetching the same value from memory. By calculating the total cycle counts and code footprints for both variants, you will gain a concrete appreciation for the efficiency that immediate addressing offers [@problem_id:3648974].", "problem": "Consider a toy load-store instruction set architecture with $32$-bit words and $32$-bit addresses. The processor executes instructions sequentially without overlap; each instruction completes before the next begins. All data loads hit in the Level-1 (L1) data cache. The following foundational definitions apply:\n- Immediate addressing mode: an instruction encodes a constant operand within the instruction word; using an immediate operand does not perform a data memory read.\n- Direct addressing mode: an instruction encodes an absolute data memory address within the instruction word; using a direct memory operand performs a data memory read from the encoded address.\n- Register-indirect with scaled index addressing: a load computes an effective address by adding a base register and a scaled index (here, scaled by the element size).\n\nAssume the following well-tested facts for this toy architecture:\n- Integer register-to-register addition takes $1$ cycle and occupies $4$ bytes of code.\n- Integer addition with an immediate operand (e.g., increment by a constant) takes $1$ cycle and occupies $4$ bytes of code.\n- Move immediate to register (e.g., initialize a register to a constant) takes $1$ cycle and occupies $4$ bytes of code.\n- Load from memory using register-indirect with scaled index (e.g., loading an array element) takes $3$ cycles and occupies $4$ bytes of code.\n- Load from memory using direct addressing (absolute address encoded in the instruction) takes $3$ cycles and occupies $8$ bytes of code (to hold the $32$-bit address).\n- Conditional branch with an integrated comparison between two registers takes $1$ cycle and occupies $4$ bytes of code. The branch is executed once per loop iteration in the program below, and branch prediction is perfect (no extra penalty).\n\nYou are given a program to sum an array of $N$ contiguous $32$-bit integers located at a base address in a register $r_{\\mathrm{base}}$. Two variants differ only in how the loop step size is handled:\n\nVariant I (Immediate step): the loop index $r_{i}$ is incremented by the immediate constant $1$ each iteration.\n- Pre-loop initialization:\n  - Set $r_{i} \\leftarrow 0$ using a move immediate.\n  - Set $r_{\\mathrm{sum}} \\leftarrow 0$ using a move immediate.\n  - Set $r_{N} \\leftarrow N$ using a move immediate.\n- Loop body per iteration:\n  - Load element into $r_{t}$ using register-indirect with scaled index: $[r_{\\mathrm{base}} + r_{i} \\times 4]$.\n  - Add $r_{\\mathrm{sum}} \\leftarrow r_{\\mathrm{sum}} + r_{t}$.\n  - Increment index by immediate: $r_{i} \\leftarrow r_{i} + 1$.\n  - Conditional branch: continue if $r_{i} < r_{N}$.\n\nVariant II (Direct addressing step): the loop index $r_{i}$ is incremented each iteration by a step value fetched from memory via direct addressing, from a fixed absolute address $\\alpha$ that holds the constant $1$.\n- Pre-loop initialization: identical to Variant I.\n- Loop body per iteration:\n  - Load element into $r_{t}$ using register-indirect with scaled index: $[r_{\\mathrm{base}} + r_{i} \\times 4]$.\n  - Load step into $r_{\\mathrm{step}}$ from absolute address $\\alpha$ using direct addressing.\n  - Add $r_{i} \\leftarrow r_{i} + r_{\\mathrm{step}}$.\n  - Add $r_{\\mathrm{sum}} \\leftarrow r_{\\mathrm{sum}} + r_{t}$.\n  - Conditional branch: continue if $r_{i} < r_{N}$.\n\nUsing only the definitions above and the given timing and code-size facts, derive, as functions of $N$, the total cycle counts $C_{\\mathrm{I}}(N)$ and $C_{\\mathrm{II}}(N)$, and the static code footprints $\\mathrm{size}_{\\mathrm{I}}$ and $\\mathrm{size}_{\\mathrm{II}}$. Then compute:\n- The speedup factor of Variant I over Variant II, defined as $S(N) = \\dfrac{C_{\\mathrm{II}}(N)}{C_{\\mathrm{I}}(N)}$.\n- The static code size ratio, defined as $R = \\dfrac{\\mathrm{size}_{\\mathrm{I}}}{\\mathrm{size}_{\\mathrm{II}}}$.\n\nExpress your final answer as a row matrix containing $S(N)$ and $R$. No rounding is required, and you should give exact closed-form expressions. Units are not to be included in the final answer.", "solution": "The derivation relies on the core definitions of addressing modes and the well-tested timing and size facts given. Immediate operands do not incur data memory reads, whereas direct addressing embeds an absolute address in the instruction, which still performs a data memory read. Loads are $3$ cycles in this toy model and occupy either $4$ or $8$ bytes depending on the addressing mode. Arithmetic and branch instructions are $1$ cycle and $4$ bytes.\n\nWe proceed by enumerating the instructions executed and summing their cycles and sizes.\n\nFor Variant I (Immediate step):\n\nPre-loop initialization consists of three move-immediate instructions:\n- Set $r_{i} \\leftarrow 0$: $1$ cycle, $4$ bytes.\n- Set $r_{\\mathrm{sum}} \\leftarrow 0$: $1$ cycle, $4$ bytes.\n- Set $r_{N} \\leftarrow N$: $1$ cycle, $4$ bytes.\n\nTherefore, the pre-loop cycle count is\n$$\nC_{\\mathrm{I,init}} = 1 + 1 + 1 = 3,\n$$\nand the pre-loop code size is\n$$\n\\mathrm{size}_{\\mathrm{I,init}} = 4 + 4 + 4 = 12.\n$$\n\nEach loop iteration performs:\n- Load element via register-indirect with scaled index: $3$ cycles, $4$ bytes.\n- Add $r_{\\mathrm{sum}} \\leftarrow r_{\\mathrm{sum}} + r_{t}$: $1$ cycle, $4$ bytes.\n- Add immediate increment $r_{i} \\leftarrow r_{i} + 1$: $1$ cycle, $4$ bytes.\n- Conditional branch: $1$ cycle, $4$ bytes.\n\nThus, the per-iteration cycles are\n$$\nC_{\\mathrm{I,iter}} = 3 + 1 + 1 + 1 = 6,\n$$\nand the loop body code footprint (static) is\n$$\n\\mathrm{size}_{\\mathrm{I,loop}} = 4 + 4 + 4 + 4 = 16.\n$$\n\nBecause there are $N$ iterations and the branch executes once per iteration, the total cycles and static code size for Variant I are\n$$\nC_{\\mathrm{I}}(N) = C_{\\mathrm{I,init}} + N \\cdot C_{\\mathrm{I,iter}} = 3 + 6N,\n$$\n$$\n\\mathrm{size}_{\\mathrm{I}} = \\mathrm{size}_{\\mathrm{I,init}} + \\mathrm{size}_{\\mathrm{I,loop}} = 12 + 16 = 28.\n$$\n\nFor Variant II (Direct addressing step):\n\nPre-loop initialization is identical to Variant I, giving\n$$\nC_{\\mathrm{II,init}} = 3, \\quad \\mathrm{size}_{\\mathrm{II,init}} = 12.\n$$\n\nEach loop iteration performs:\n- Load element via register-indirect with scaled index: $3$ cycles, $4$ bytes.\n- Load step via direct addressing from absolute address $\\alpha$: $3$ cycles, $8$ bytes.\n- Add $r_{i} \\leftarrow r_{i} + r_{\\mathrm{step}}$: $1$ cycle, $4$ bytes.\n- Add $r_{\\mathrm{sum}} \\leftarrow r_{\\mathrm{sum}} + r_{t}$: $1$ cycle, $4$ bytes.\n- Conditional branch: $1$ cycle, $4$ bytes.\n\nThus, the per-iteration cycles are\n$$\nC_{\\mathrm{II,iter}} = 3 + 3 + 1 + 1 + 1 = 9,\n$$\nand the loop body code footprint (static) is\n$$\n\\mathrm{size}_{\\mathrm{II,loop}} = 4 + 8 + 4 + 4 + 4 = 24.\n$$\n\nTherefore, the total cycles and static code size for Variant II are\n$$\nC_{\\mathrm{II}}(N) = C_{\\mathrm{II,init}} + N \\cdot C_{\\mathrm{II,iter}} = 3 + 9N,\n$$\n$$\n\\mathrm{size}_{\\mathrm{II}} = \\mathrm{size}_{\\mathrm{II,init}} + \\mathrm{size}_{\\mathrm{II,loop}} = 12 + 24 = 36.\n$$\n\nNow compute the requested comparisons.\n\nThe speedup factor of Variant I over Variant II is defined as\n$$\nS(N) = \\frac{C_{\\mathrm{II}}(N)}{C_{\\mathrm{I}}(N)} = \\frac{3 + 9N}{3 + 6N} = \\frac{3(1 + 3N)}{3(1 + 2N)} = \\frac{1 + 3N}{1 + 2N}.\n$$\n\nThe static code size ratio is\n$$\nR = \\frac{\\mathrm{size}_{\\mathrm{I}}}{\\mathrm{size}_{\\mathrm{II}}} = \\frac{28}{36} = \\frac{7}{9}.\n$$\n\nThese are exact, closed-form expressions in terms of $N$ (for $S(N)$) and constants (for $R$).", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1+3N}{1+2N} & \\frac{7}{9}\\end{pmatrix}}$$", "id": "3648974"}, {"introduction": "What happens when a needed constant is far too large for a single immediate instruction? This practice explores a common solution: synthesizing the constant from smaller, 12-bit pieces using a sequence of shift and add instructions. You will then compare the deterministic latency of this multi-instruction synthesis against the expected latency of a single direct memory load, which is subject to the probabilistic nature of the cache hierarchy [@problem_id:3649029]. This reveals a more nuanced performance trade-off, where the 'faster' method depends critically on memory system performance.", "problem": "A Central Processing Unit (CPU) implements two relevant addressing mechanisms: immediate addressing and direct addressing. Immediate addressing encodes a constant directly in the instruction’s immediate field, while direct addressing encodes a memory address from which the constant is fetched. Consider the task of producing a specific $64$-bit constant $K$ in a general-purpose register on a CPU with the following instruction set and timing model:\n\n- The instruction set provides three relevant operations, each retiring in $1$ cycle and producing a result that subsequent dependent instructions can consume only in the next cycle:\n    - $ \\mathrm{LOAD\\_IMM12}(r, u) $ writes the unsigned $12$-bit immediate $u \\in [0, 2^{12}-1]$ into register $r$.\n    - $ \\mathrm{SLL12}(r) $ shifts register $r$ left logically by $12$ bits.\n    - $ \\mathrm{ADD\\_IMM12}(r, u) $ adds the unsigned $12$-bit immediate $u \\in [0, 2^{12}-1]$ to register $r$.\n  Assume true data dependencies force strict serialization of these operations; there is no overlap across the sequence that builds $K$.\n\n- Direct addressing uses $ \\mathrm{LD\\_DIRECT}(r, A) $, which loads the $64$-bit word at absolute address $A$ into register $r$. Its latency, measured from issue to data available in $r$ (including address generation and write-back), depends on the cache/memory level hit:\n    - Level-$1$ (L1) cache hit latency $=4$ cycles with probability $P_{\\mathrm{L1}}=0.93$.\n    - Level-$2$ (L2) cache hit latency $=12$ cycles with probability $P_{\\mathrm{L2}}=0.05$.\n    - Level-$3$ (L3) cache hit latency $=36$ cycles with probability $P_{\\mathrm{L3}}=0.015$.\n    - Main memory latency $=200$ cycles with probability $P_{\\mathrm{Mem}}=0.005$.\n  The probabilities satisfy $P_{\\mathrm{L1}}+P_{\\mathrm{L2}}+P_{\\mathrm{L3}}+P_{\\mathrm{Mem}}=1$.\n\nThe CPU runs at frequency $f = 3.0 \\times 10^{9} \\, \\mathrm{Hz}$.\n\nYou are given the constant\n$$K = \\mathrm{0xABCDEF123456789}.$$\n\n- Using only $ \\mathrm{LOAD\\_IMM12} $, $ \\mathrm{SLL12} $, and $ \\mathrm{ADD\\_IMM12} $, design from first principles a method to synthesize $K$ in a register by combining $12$-bit immediates with shift-left-by-$12$ operations. Your design must explain how to decompose $K$ and how to sequence the operations, with a clear argument for minimality of the instruction count under the stated constraints.\n- Determine the minimal number of cycles required to produce $K$ using immediate addressing on this CPU.\n- Compute the expected number of cycles to produce $K$ using direct addressing on this CPU.\n- Finally, compute the latency difference in nanoseconds between the immediate-addressing synthesis and the direct-addressing load, defined as\n$$\\Delta T = T_{\\mathrm{imm}} - T_{\\mathrm{direct}},$$\nwhere $T_{\\mathrm{imm}}$ and $T_{\\mathrm{direct}}$ are the respective latencies in nanoseconds. Round your final $\\Delta T$ to four significant figures and express it in nanoseconds.", "solution": "The problem statement is evaluated to be valid. It is scientifically grounded in the principles of computer organization and architecture, describing a plausible, simplified model of a CPU's instruction set, addressing modes, and memory hierarchy. The problem is well-posed, with all necessary data and constraints provided to derive a unique solution for the required performance metrics. The definitions and values are internally consistent and objective.\n\nThe task is to analyze two methods for loading a constant into a register and compare their latencies.\n\nFirst, we address the synthesis of the constant $K$ using immediate addressing. The problem specifies a $64$-bit constant $K = \\mathrm{0xABCDEF123456789}$. The hexadecimal representation `ABCDEF123456789` consists of 15 digits. Since each hexadecimal digit corresponds to $4$ bits, this constant is $15 \\times 4 = 60$ bits long. When loaded into a $64$-bit register, it is represented as a $64$-bit number with the upper $4$ bits being zero: $K = \\mathrm{0x0ABCDEF123456789}$.\n\nThe available instructions, $\\mathrm{LOAD\\_IMM12}$, $\\mathrm{ADD\\_IMM12}$, and $\\mathrm{SLL12}$, operate on $12$-bit immediates and shift by $12$ bits. This suggests a natural decomposition of the $60$-bit constant into $12$-bit chunks. A $12$-bit chunk corresponds to $3$ hexadecimal digits. We decompose $K$ into five $12$-bit chunks, from most significant ($k_4$) to least significant ($k_0$):\n$K = \\mathrm{0xABC\\ DEF\\ 123\\ 456\\ 789}$\nThe chunks are:\n- $k_4 = \\mathrm{0xABC}$\n- $k_3 = \\mathrm{0xDEF}$\n- $k_2 = \\mathrm{0x123}$\n- $k_1 = \\mathrm{0x456}$\n- $k_0 = \\mathrm{0x789}$\n\nThe value of $K$ can be expressed as a polynomial in base $2^{12}$:\n$$K = k_4 \\cdot (2^{12})^4 + k_3 \\cdot (2^{12})^3 + k_2 \\cdot (2^{12})^2 + k_1 \\cdot (2^{12})^1 + k_0 \\cdot (2^{12})^0$$\nThis structure can be synthesized efficiently using Horner's method:\n$$K = ((((k_4 \\cdot 2^{12} + k_3) \\cdot 2^{12} + k_2) \\cdot 2^{12} + k_1) \\cdot 2^{12} + k_0)$$\nThis corresponds to the following sequence of operations in a register $r$:\n1. Initialize $r$ with the most significant chunk $k_4$.\n2. Shift $r$ left by $12$ bits (multiply by $2^{12}$).\n3. Add the next chunk $k_3$.\n4. Repeat steps 2 and 3 for the remaining chunks $k_2$, $k_1$, and $k_0$.\n\nThe specific instruction sequence to generate $K$ in a register, say $r0$, is:\n1. $\\mathrm{LOAD\\_IMM12}(r0, \\mathrm{0xABC})$\n2. $\\mathrm{SLL12}(r0)$\n3. $\\mathrm{ADD\\_IMM12}(r0, \\mathrm{0xDEF})$\n4. $\\mathrm{SLL12}(r0)$\n5. $\\mathrm{ADD\\_IMM12}(r0, \\mathrm{0x123})$\n6. $\\mathrm{SLL12}(r0)$\n7. $\\mathrm{ADD\\_IMM12}(r0, \\mathrm{0x456})$\n8. $\\mathrm{SLL12}(r0)$\n9. $\\mathrm{ADD\\_IMM12}(r0, \\mathrm{0x789})$\n\nThis sequence consists of $1$ $\\mathrm{LOAD\\_IMM12}$ instruction, $4$ $\\mathrm{SLL12}$ instructions, and $4$ $\\mathrm{ADD\\_IMM12}$ instructions, for a total of $9$ instructions. This sequence is minimal. To construct the $60$-bit constant, we must specify its five non-zero $12$-bit chunks. This requires at least $5$ instructions that provide immediate values ($\\mathrm{LOAD\\_IMM12}$ or $\\mathrm{ADD\\_IMM12}$). To place these five chunks in their correct bit positions, which are separated by $12$ bits each, we require $4$ relative shifts of $12$ bits. Thus, a minimum of $5 + 4 = 9$ instructions are necessary. The proposed sequence meets this lower bound.\n\nNext, we determine the number of cycles for this immediate addressing method, $C_{\\mathrm{imm}}$. The problem states that each instruction takes $1$ cycle and there are true data dependencies between every consecutive instruction in the sequence. This forces strict serialization. The total number of cycles is therefore the total number of instructions in the chain.\n$$C_{\\mathrm{imm}} = 9 \\text{ cycles}$$\n\nNow, we compute the expected number of cycles for the direct addressing method, $E[C_{\\mathrm{direct}}]$. This method uses a single instruction, $\\mathrm{LD\\_DIRECT}$, whose latency depends on the memory hierarchy. The expected latency is the sum of the possible latencies weighted by their probabilities:\n$$E[C_{\\mathrm{direct}}] = C_{\\mathrm{L1}}P_{\\mathrm{L1}} + C_{\\mathrm{L2}}P_{\\mathrm{L2}} + C_{\\mathrm{L3}}P_{\\mathrm{L3}} + C_{\\mathrm{Mem}}P_{\\mathrm{Mem}}$$\nSubstituting the given values:\n$$E[C_{\\mathrm{direct}}] = (4 \\cdot 0.93) + (12 \\cdot 0.05) + (36 \\cdot 0.015) + (200 \\cdot 0.005)$$\n$$E[C_{\\mathrm{direct}}] = 3.72 + 0.60 + 0.54 + 1.00 = 5.86 \\text{ cycles}$$\n\nFinally, we compute the latency difference $\\Delta T = T_{\\mathrm{imm}} - T_{\\mathrm{direct}}$ in nanoseconds. First, we find the CPU's clock period, $T_{\\mathrm{cycle}}$, from its frequency $f = 3.0 \\times 10^9 \\, \\mathrm{Hz}$:\n$$T_{\\mathrm{cycle}} = \\frac{1}{f} = \\frac{1}{3.0 \\times 10^{9} \\, \\mathrm{Hz}} = \\frac{1}{3} \\times 10^{-9} \\, \\mathrm{s} = \\frac{1}{3} \\, \\mathrm{ns}$$\nThe total latency for each method is its cycle count multiplied by the clock period. For the direct addressing method, we use the expected cycle count.\n$$T_{\\mathrm{imm}} = C_{\\mathrm{imm}} \\cdot T_{\\mathrm{cycle}} = 9 \\cdot \\frac{1}{3} \\, \\mathrm{ns} = 3 \\, \\mathrm{ns}$$\n$$T_{\\mathrm{direct}} = E[C_{\\mathrm{direct}}] \\cdot T_{\\mathrm{cycle}} = 5.86 \\cdot \\frac{1}{3} \\, \\mathrm{ns} \\approx 1.9533... \\, \\mathrm{ns}$$\nThe latency difference is:\n$$\\Delta T = T_{\\mathrm{imm}} - T_{\\mathrm{direct}} = 3 \\, \\mathrm{ns} - \\frac{5.86}{3} \\, \\mathrm{ns} = \\frac{9 - 5.86}{3} \\, \\mathrm{ns} = \\frac{3.14}{3} \\, \\mathrm{ns}$$\n$$\\Delta T \\approx 1.04666... \\, \\mathrm{ns}$$\nRounding to four significant figures as required, we get:\n$$\\Delta T \\approx 1.047 \\, \\mathrm{ns}$$", "answer": "$$\\boxed{1.047}$$", "id": "3649029"}]}