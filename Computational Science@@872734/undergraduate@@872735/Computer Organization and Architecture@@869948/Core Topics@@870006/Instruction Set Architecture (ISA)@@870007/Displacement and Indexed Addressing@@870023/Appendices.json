{"hands_on_practices": [{"introduction": "Understanding displacement and indexed addressing begins with appreciating the interplay between its components. An effective address is not just a fixed calculation, but a flexible one where changes in the index register can be balanced by adjustments to the displacement. This exercise reveals the fundamental algebraic relationship between these parts, a principle that compilers use to efficiently access consecutive elements in data structures like arrays. [@problem_id:3636086]", "problem": "An Instruction Set Architecture (ISA) with displacement and indexed addressing computes an effective address for a memory operand according to the definition that the effective address equals the sum of the base register contents, an index register scaled by an element-size-dependent factor, and an immediate displacement. Formally, for a memory operand referencing an array of fixed-size elements, the effective address is given by the sum of $R_b$, $R_i$ scaled by the element size factor $S$, and a displacement $d$, where $R_b$ denotes the base register value, $R_i$ denotes the index register value, $S$ denotes the scale factor determined by the element size in bytes, and $d$ denotes the displacement in bytes. Consider an array of $32$-bit integers, so the scale factor is $S = 4$. Two different address expressions target the same location in this array but use different index and displacement values: the first uses index register $R_i$ and displacement $d_1$, and the second uses index register $R_i + 1$ and displacement $d_2$, both with the same base register $R_b$. Using only the fundamental definition of effective address stated above and the concept that aliasing occurs when two expressions compute the same effective address, derive the necessary and sufficient condition on the displacements that makes these two different address expressions alias for arbitrary $R_b$ and $R_i$ when $S = 4$, and compute the value of $d_2 - d_1$ in bytes. Report only the value of $d_2 - d_1$ as your final answer, as an integer number of bytes.", "solution": "The problem statement is evaluated as valid and well-posed. It is scientifically grounded in the principles of computer organization and architecture, specifically concerning memory addressing modes. All necessary data and conditions are provided to derive a unique and meaningful solution.\n\nThe problem defines the effective address ($EA$) for a memory operand using displacement and indexed addressing as the sum of a base register value ($R_b$), an index register value ($R_i$) scaled by an element size factor ($S$), and a displacement ($d$). The formula is:\n$$ EA = R_b + S \\cdot R_i + d $$\nThe problem specifies that the memory operands are $32$-bit integers. Since there are $8$ bits in a byte, a $32$-bit integer occupies $\\frac{32}{8} = 4$ bytes. The scale factor $S$ is determined by the element size in bytes, so for this case, $S = 4$.\n\nWe are given two different address expressions that alias, meaning they compute the same effective address. Let us denote the effective addresses of the first and second expressions as $EA_1$ and $EA_2$, respectively.\n\nFor the first address expression:\nThe index register value is specified as $R_i$.\nThe displacement is $d_1$.\nThe base register is $R_b$ and the scale factor is $S=4$.\nThus, the first effective address, $EA_1$, is given by:\n$$ EA_1 = R_b + 4 \\cdot R_i + d_1 $$\n\nFor the second address expression:\nThe index register value is specified as $R_i + 1$. This is interpreted as the value of the index register $R_i$ incremented by $1$.\nThe displacement is $d_2$.\nThe base register is the same, $R_b$, and the scale factor is also $S=4$.\nThus, the second effective address, $EA_2$, is given by:\n$$ EA_2 = R_b + 4 \\cdot (R_i + 1) + d_2 $$\n\nThe condition of aliasing requires that these two expressions yield the same address:\n$$ EA_1 = EA_2 $$\nSubstituting the expressions for $EA_1$ and $EA_2$:\n$$ R_b + 4 R_i + d_1 = R_b + 4(R_i + 1) + d_2 $$\n\nThe problem states that this condition must hold for arbitrary values of the base register, $R_b$, and the index register, $R_i$. We can simplify the equation to find the relationship between $d_1$ and $d_2$ that satisfies this requirement.\n\nFirst, distribute the scale factor $4$ on the right side of the equation:\n$$ R_b + 4 R_i + d_1 = R_b + 4 R_i + 4 \\cdot 1 + d_2 $$\n$$ R_b + 4 R_i + d_1 = R_b + 4 R_i + 4 + d_2 $$\n\nThe term $R_b$ appears on both sides and can be cancelled by subtracting $R_b$ from both sides. This is consistent with the condition holding for any arbitrary $R_b$.\n$$ 4 R_i + d_1 = 4 R_i + 4 + d_2 $$\n\nSimilarly, the term $4 R_i$ appears on both sides. Subtracting $4 R_i$ from both sides demonstrates that the condition holds for any arbitrary $R_i$.\n$$ d_1 = 4 + d_2 $$\n\nThis equation, $d_1 = 4 + d_2$, is the necessary and sufficient condition on the displacements $d_1$ and $d_2$ for the two address expressions to alias, independent of the values in $R_b$ and $R_i$.\n\nThe problem asks for the value of $d_2 - d_1$. We can rearrange the derived condition to solve for this difference.\nStarting from $d_1 = 4 + d_2$, we subtract $d_1$ and $4$ from both sides:\n$$ d_1 - d_1 - 4 = 4 - 4 + d_2 - d_1 $$\n$$ -4 = d_2 - d_1 $$\n\nThus, the value of $d_2 - d_1$ is $-4$. The displacements are given in bytes, so the result is $-4$ bytes. This result is logical: incrementing the array index by $1$ moves the address forward by $S = 4$ bytes; to maintain the same final address, the displacement must be decreased by $4$ bytes, meaning $d_2 = d_1 - 4$.", "answer": "$$ \\boxed{-4} $$", "id": "3636086"}, {"introduction": "Why do modern processors feature complex addressing modes instead of relying on simpler ones? This practice directly addresses this question by simulating a scaled-indexed load on a hypothetical machine that only supports simple displacement addressing. By constructing the necessary sequence of basic ALU instructions and calculating the additional execution time, you will uncover the significant performance benefits—in terms of both instruction count and processor cycles—that dedicated hardware provides. [@problem_id:3636068]", "problem": "Consider a load that conceptually requires an effective address (EA) formed by a base register and a scaled index with a displacement in a machine that only implements displacement addressing. The fundamental definition of displacement addressing is that the effective address is computed as $EA = R_{b} + d$, where $R_{b}$ is any general-purpose register and $d$ is a sign-extended immediate displacement. Scaled indexed addressing of the form $EA = R_{b} + R_{i} \\cdot 8 + d$ is not directly supported by hardware on this machine. You must rely on integer operations provided by the Arithmetic Logic Unit (ALU) and the displacement addressing mode to achieve the same effect.\n\nAssume the following well-tested, standard execution-time model and instruction repertoire:\n- The machine can issue one instruction per cycle in program order, and there are no hazards or overlaps; total cycles for a sequence equal the sum of the cycles for each instruction.\n- The ALU supports register-to-register move (`MOV`), addition (`ADD`), and logical shift left by an immediate count (`SHL`). Each of these ALU instructions completes in $1$ cycle.\n- The load instruction `LD Rx, [R + d]` uses displacement addressing ($EA = R + d$) and completes in $4$ cycles, which include address generation and memory access.\n- If scaled indexed addressing were available in hardware, the corresponding single-instruction load `LD Rx, [Rb + Ri * 8 + d]` would also complete in $4$ cycles.\n\nYou are given that register $R_{i}$ must not be modified by the sequence (its value must be preserved), and that a single scratch register $R_{t}$ is available and initially holds an unspecified value. Devise a minimal instruction sequence that uses only `MOV`, `SHL`, `ADD`, and `LD` to perform the equivalent of `LD Rx, [Rb + Ri * 8 + d]` without destroying $R_{i}$. Then, compute the number of extra cycles required by your sequence relative to the hypothetical single-instruction scaled indexed load. Express your final answer as a single integer number of cycles. No rounding is needed, and no units should be included with the final answer.", "solution": "The problem is first subjected to a validation process.\n\n### Step 1: Extract Givens\n- **Target Operation**: Load using an effective address (EA) defined as $EA = R_{b} + R_{i} \\cdot 8 + d$.\n- **Hardware Addressing Mode**: Displacement addressing only, $EA = R_{\\text{base}} + d$, where $R_{\\text{base}}$ is a general-purpose register and $d$ is a sign-extended immediate displacement.\n- **Unsupported Addressing Mode**: Scaled indexed addressing, $EA = R_{b} + R_{i} \\cdot 8 + d$, is not directly supported.\n- **Execution Model**: Single-issue, in-order execution with no hazards. Total cycles are the sum of individual instruction cycles.\n- **Instruction Set and Latencies**:\n  - `MOV` (register-to-register): $1$ cycle.\n  - `ADD` (register-to-register): $1$ cycle.\n  - `SHL` (logical shift left by immediate): $1$ cycle.\n  - `LD Rx, [R + d]` (load using displacement addressing): $4$ cycles.\n- **Hypothetical Instruction Latency**: A hypothetical `LD Rx, [Rb + Ri * 8 + d]` instruction would take $4$ cycles.\n- **Constraints**:\n  1. The value in register $R_{i}$ must be preserved.\n  2. A single scratch register, $R_{t}$, is available.\n  3. The solution must use only the provided instructions: `MOV`, `SHL`, `ADD`, and `LD`.\n- **Objective**:\n  1. Formulate a minimal instruction sequence to perform the equivalent of the target load operation.\n  2. Calculate the number of extra cycles this sequence requires compared to the hypothetical single-instruction implementation.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed against the validation criteria.\n- **Scientifically Grounded**: The problem is a classic exercise in computer organization and architecture, dealing with instruction set architectures (ISAs), addressing modes, and performance analysis (cycle counting). The concepts are fundamental to the field. The simplified execution model (no hazards) is a standard pedagogical simplification.\n- **Well-Posed**: The goal is clearly defined, the available resources (`MOV`, `ADD`, `SHL`, `LD`, one scratch register) are explicitly listed, and the constraints (preserving $R_{i}$) are unambiguous. The objective metric (extra cycles) is precisely stated. A minimal sequence can be logically derived, leading to a unique solution.\n- **Objective**: The problem is stated using standard, objective terminology from computer architecture. No subjective or ambiguous language is used.\n- **Flaw Analysis**: The problem statement is free from scientific unsoundness, incompleteness, contradictions, and other flaws listed in the validation criteria. It presents a solvable, self-contained scenario that is directly relevant to the topic of computer architecture.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be constructed.\n\n### Solution Derivation\n\nThe goal is to perform a load from the effective address $EA = R_{b} + R_{i} \\cdot 8 + d$. The hardware's native load instruction, `LD Rx, [R + d]`, can only compute an effective address by adding the contents of a single register $R$ and an immediate displacement $d$.\n\nTo implement the target addressing mode, we must first compute the portion of the address that the hardware cannot, which is the sum of the base and the scaled index, $R_{b} + R_{i} \\cdot 8$. This computed value must then be placed into a register, which will serve as the base register for the final `LD` instruction. The problem provides a scratch register, $R_{t}$, for this purpose.\n\nThe calculation must be performed in a sequence of steps using the available ALU instructions, while respecting the constraint that register $R_{i}$ must not be modified.\n\n1.  **Preserve Register $R_{i}$**: Since the value of $R_{i}$ is needed for the calculation but the register itself must not be altered, we must first copy its contents to the scratch register $R_{t}$.\n    - Instruction: `MOV Rt, Ri`\n    - This operation requires $1$ cycle. After this, $R_{t}$ holds the initial value of $R_{i}$.\n\n2.  **Calculate the Scaled Index**: The term $R_{i} \\cdot 8$ must be computed. Multiplication by $8$, which is equal to $2^3$, is equivalent to a logical left shift by $3$ bit positions. We perform this operation on $R_{t}$, which currently holds the value of $R_{i}$.\n    - Instruction: `SHL Rt, 3`\n    - This operation requires $1$ cycle. After this, $R_{t}$ contains the value $(R_{i} \\cdot 8)$.\n\n3.  **Add the Base Register**: The contents of the base register, $R_{b}$, must be added to the scaled index.\n    - Instruction: `ADD Rt, Rb`\n    - This operation requires $1$ cycle. After this, $R_{t}$ contains the value $(R_{b} + R_{i} \\cdot 8)$.\n\n4.  **Perform the Load**: Now, the register $R_{t}$ holds the base-plus-scaled-index portion of the address. We can use $R_{t}$ as the base register in the native displacement-mode load instruction. The hardware will compute the final effective address as $EA = R_{t} + d$, which resolves to $(R_{b} + R_{i} \\cdot 8) + d$, exactly the target address.\n    - Instruction: `LD Rx, [Rt + d]`\n    - This operation requires $4$ cycles.\n\nThe resulting minimal instruction sequence is:\n- `MOV Rt, Ri`\n- `SHL Rt, 3`\n- `ADD Rt, Rb`\n- `LD Rx, [Rt + d]`\n\nThis sequence is minimal because each of the first three instructions is necessary to compute the required address component $(R_{b} + R_{i} \\cdot 8)$ in $R_{t}$ without violating the preservation constraint on $R_{i}$, and the final `LD` instruction is necessary to perform the memory access.\n\nThe total number of cycles, $C_{\\text{sequence}}$, for this synthesized operation is the sum of the cycles for each instruction in the sequence:\n$$C_{\\text{sequence}} = C_{\\text{MOV}} + C_{\\text{SHL}} + C_{\\text{ADD}} + C_{\\text{LD}}$$\n$$C_{\\text{sequence}} = 1 + 1 + 1 + 4 = 7 \\text{ cycles}$$\n\nThe problem states that the hypothetical single instruction for scaled indexed addressing, if it existed, would complete in $C_{\\text{hypothetical}} = 4$ cycles.\n\nThe number of extra cycles required by the synthesized instruction sequence is the difference between the two cycle counts:\n$$\\text{Extra Cycles} = C_{\\text{sequence}} - C_{\\text{hypothetical}}$$\n$$\\text{Extra Cycles} = 7 - 4 = 3$$\n\nTherefore, the synthesized approach requires $3$ additional cycles compared to a hypothetical hardware implementation.", "answer": "$$\n\\boxed{3}\n$$", "id": "3636068"}, {"introduction": "Calculating a memory address correctly is critical, but it's equally important that the address respects the architectural constraints of the memory system. This practice explores the vital concept of memory alignment, a common source of performance bottlenecks. You will analyze a series of load operations to identify which ones generate misaligned addresses and quantify the severe performance penalty that results from triggering operating system alignment traps, connecting abstract address calculation to tangible system behavior. [@problem_id:3636147]", "problem": "A load/store unit in a $64$-bit Central Processing Unit (CPU) implements displacement and indexed addressing. For a word access, the unit computes the effective address (EA) by first forming a base-index sum $s$ from a base register $b$ and an index register $i$ multiplied by a scale factor $\\sigma$, then adding a displacement $d$. Concretely, the unit computes $$EA = s + d,$$ where $$s = b + \\sigma \\cdot i.$$ In this machine, a word is $2$ bytes, and the memory system requires word accesses to be aligned to $2$-byte boundaries, meaning an access is aligned if and only if $$EA \\bmod 2 = 0.$$\n\nConsider a loop of $14$ word loads using this addressing mode with a fixed base-index sum $s$ and a varying displacement $d$ per iteration. The base-index sum is given to be $$s = 16384,$$ which is even. The displacement sequence per iteration is $$D = \\{1, 4, 5, 8, 11, 14, 15, 18, 21, 22, 25, 30, 31, 34\\}.$$\n\nThe CPU uses an alignment trap model: when a word access is misaligned, an alignment trap is triggered and handled by the Operating System (OS). The alignment trap introduces the following cycle costs:\n- trap entry cost $t_{e} = 20$ cycles,\n- handler emulation cost $t_{h} = 12$ cycles,\n- trap exit cost $t_{x} = 10$ cycles,\n- pipeline refill cost $t_{p} = 6$ cycles.\n\nBy contrast, an aligned word load completes in $c_{a} = 3$ cycles and does not incur any trap costs. For this problem, define the penalty of a misaligned access to be the additional cycles beyond the aligned case attributable to the trap, namely $$P = t_{e} + t_{h} + t_{x} + t_{p}.$$\n\nAssuming no other stalls or hazards, determine the total penalty, in cycles, incurred by the $14$ loads in the sequence. Express your final result as an exact integer count of cycles; no rounding is required. Also, briefly justify, using the parity of $s$ and $d$ and the alignment rule, why the misaligned effective address condition arises for word accesses when $d$ is odd and $s$ is even.", "solution": "The problem is assessed to be valid as it is scientifically grounded in the principles of computer architecture, well-posed with sufficient and consistent data, and objective in its language. We can proceed with a formal solution.\n\nThe problem asks for two things: first, to justify the condition under which a memory access becomes misaligned, and second, to calculate the total penalty in cycles for a given sequence of memory loads.\n\nFirst, let's address the justification for misalignment. In this architecture, a word is $2$ bytes. Memory accesses for words must be aligned to $2$-byte boundaries. This means the effective address ($EA$) of the access must be a multiple of $2$. Mathematically, this condition is expressed as:\n$$EA \\bmod 2 = 0$$\nAn access is misaligned if this condition is not met, i.e., $EA \\bmod 2 \\neq 0$, which for integers is equivalent to $EA \\bmod 2 = 1$. This means a misaligned effective address must be an odd number.\n\nThe effective address is computed as $EA = s + d$, where $s$ is the base-index sum and $d$ is the displacement. We are given that $s = 16384$. To determine the parity of $s$, we can check if it is divisible by $2$. Since $16384 = 2 \\times 8192$, $s$ is an even number.\n\nWe can now analyze the parity of $EA$ using modular arithmetic. The parity of a sum is determined by the parity of its operands.\nLet's consider the equation for $EA$ modulo $2$:\n$$EA \\pmod 2 = (s + d) \\pmod 2$$\nUsing the properties of modular arithmetic, this can be written as:\n$$EA \\pmod 2 = (s \\pmod 2 + d \\pmod 2) \\pmod 2$$\nSince $s$ is even, $s \\pmod 2 = 0$. Substituting this into the equation gives:\n$$EA \\pmod 2 = (0 + d \\pmod 2) \\pmod 2 = d \\pmod 2$$\nThis result shows that the parity of the effective address $EA$ is identical to the parity of the displacement $d$. Therefore, an access is misaligned ($EA$ is odd, so $EA \\pmod 2 = 1$) if and only if the displacement $d$ is also odd ($d \\pmod 2 = 1$). This completes the requested justification.\n\nNext, we calculate the total penalty incurred by the sequence of $14$ loads.\nThe penalty for a single misaligned access, $P$, is defined as the sum of the cycle costs associated with an alignment trap:\n$$P = t_{e} + t_{h} + t_{x} + t_{p}$$\nSubstituting the given values:\n$t_{e} = 20$ cycles\n$t_{h} = 12$ cycles\n$t_{x} = 10$ cycles\n$t_{p} = 6$ cycles\n$$P = 20 + 12 + 10 + 6 = 48 \\text{ cycles}$$\nThis is the penalty for each misaligned access. Aligned accesses incur no such penalty.\n\nNow, we must determine how many of the $14$ load operations are misaligned. Based on our earlier analysis, an access is misaligned if its corresponding displacement $d$ is an odd number. The sequence of displacements is given as:\n$$D = \\{1, 4, 5, 8, 11, 14, 15, 18, 21, 22, 25, 30, 31, 34\\}$$\nWe identify the odd numbers in this sequence:\n- $1$ (odd)\n- $4$ (even)\n- $5$ (odd)\n- $8$ (even)\n- $11$ (odd)\n- $14$ (even)\n- $15$ (odd)\n- $18$ (even)\n- $21$ (odd)\n- $22$ (even)\n- $25$ (odd)\n- $30$ (even)\n- $31$ (odd)\n- $34$ (even)\n\nThe set of odd displacements is $\\{1, 5, 11, 15, 21, 25, 31\\}$. By counting the elements in this set, we find the total number of misaligned accesses, $N_{\\text{misaligned}}$.\n$$N_{\\text{misaligned}} = 7$$\nThe total penalty is the product of the number of misaligned accesses and the penalty per access.\n$$\\text{Total Penalty} = N_{\\text{misaligned}} \\times P$$\nSubstituting the values we found:\n$$\\text{Total Penalty} = 7 \\times 48$$\nPerforming the multiplication:\n$$7 \\times 48 = 7 \\times (40 + 8) = 280 + 56 = 336$$\nThus, the total penalty incurred by the sequence of $14$ loads is $336$ cycles.", "answer": "$$\\boxed{336}$$", "id": "3636147"}]}