{"hands_on_practices": [{"introduction": "To begin our hands-on exploration, we first tackle the most fundamental data hazard: the Read-After-Write (RAW) dependency. This exercise places you in the role of a microarchitect designing a classic five-stage pipeline. By calculating the performance penalty (stall cycles) with and without data forwarding, you will gain a concrete understanding of why forwarding is not just an optimization, but an essential feature for modern processors [@problem_id:3632040]. This practice establishes the core problem that all subsequent techniques aim to solve or mitigate.", "problem": "An in-order pipeline with five stages is to be considered: Instruction Fetch (IF), Instruction Decode and register read (ID), Execute (EX), Memory Access (MEM), and Write Back (WB). The machine fetches and issues at most one instruction per clock cycle and uses centralized hazard detection. For this pipeline, assume the following foundational behavior:\n- Each stage takes exactly one clock cycle.\n- All instruction state updates proceed in program order.\n- The register file is multiported so that two operands may be read in the Instruction Decode stage and one result may be written in the Write Back stage without structural conflicts.\n- A register write in the Write Back stage completes before any register read in the Instruction Decode stage in the same clock cycle.\n- There are no cache or memory stalls, and the Memory Access stage for arithmetic and logic instructions simply passes through without delay.\n- Consider two scenarios: one without any result forwarding, and one with full forwarding of arithmetic and logic results from the end of Execute and from Memory Access to the beginning of Execute of a dependent instruction in a subsequent cycle.\n\nUse the core definitions of data hazards in pipelined execution: a Read After Write (RAW) hazard occurs when an instruction requires an operand that is produced by a prior instruction and that operand is not yet available at the point of consumption. A Write After Read (WAR) hazard and a Write After Write (WAW) hazard do not arise in this in-order pipeline for arithmetic and logic instructions under the above assumptions.\n\nConsider the instruction sequence:\n- $I_{1}: \\mathrm{ADD}\\ R_{1}, R_{2}, R_{3}$, which writes its result to $R_{1}$.\n- $I_{2}: \\mathrm{SUB}\\ R_{4}, R_{1}, R_{5}$, which reads $R_{1}$ as a source.\n\nStarting from these principles and assumptions, and reasoning from the timing of when producer results become available and when consumer operands are needed in an in-order pipeline, determine the minimal number of stall cycles that the hazard detection unit must insert to preserve correctness for the single RAW dependence $R_{1}$ between $I_{1}$ and $I_{2}$:\n- First, under full forwarding of arithmetic and logic results as described above.\n- Second, with no forwarding at all.\n\nReport your final answer as a pair $\\left(x, y\\right)$ in units of cycles, where $x$ is the RAW stall count with forwarding and $y$ is the RAW stall count without forwarding. No rounding is required.", "solution": "The problem has been validated and is determined to be a well-posed, scientifically grounded problem in computer architecture. It provides a complete and consistent set of assumptions for analyzing data hazards in a classic five-stage pipeline.\n\nThe problem asks for the minimal number of stall cycles required to resolve a Read After Write (RAW) data hazard between two instructions, under two different hardware scenarios: with full forwarding and with no forwarding. The pipeline has five stages: Instruction Fetch ($\\mathrm{IF}$), Instruction Decode and register read ($\\mathrm{ID}$), Execute ($\\mathrm{EX}$), Memory Access ($\\mathrm{MEM}$), and Write Back ($\\mathrm{WB}$). Each stage requires one clock cycle.\n\nThe instruction sequence under consideration is:\n- $I_{1}: \\mathrm{ADD}\\ R_{1}, R_{2}, R_{3}$\n- $I_{2}: \\mathrm{SUB}\\ R_{4}, R_{1}, R_{5}$\n\nHere, instruction $I_1$ is the producer, as it writes its result to register $R_1$. Instruction $I_2$ is the consumer, as it reads register $R_1$ as a source operand. This creates a RAW data dependence from $I_1$ to $I_2$ on register $R_1$.\n\nLet's analyze the progression of these two instructions through the in-order pipeline, assuming $I_1$ is fetched in cycle $1$. Since one instruction is issued per cycle, $I_2$ is fetched in cycle $2$.\n\nA pipeline timing diagram for an unstalled execution would look as follows:\n- Clock Cycle $1$: $I_1$ is in $\\mathrm{IF}$.\n- Clock Cycle $2$: $I_1$ is in $\\mathrm{ID}$, $I_2$ is in $\\mathrm{IF}$.\n- Clock Cycle $3$: $I_1$ is in $\\mathrm{EX}$, $I_2$ is in $\\mathrm{ID}$.\n- Clock Cycle $4$: $I_1$ is in $\\mathrm{MEM}$, $I_2$ is in $\\mathrm{EX}$.\n- Clock Cycle $5$: $I_1$ is in $\\mathrm{WB}$, $I_2$ is in $\\mathrm{MEM}$.\n- Clock Cycle $6$: $I_2$ is in $\\mathrm{WB}$.\n\nThe RAW hazard occurs because $I_2$ needs the value of $R_1$ for its $\\mathrm{EX}$ stage, but in the unstalled sequence, $I_1$ has not yet written this value back to the register file. We must analyze when the value of $R_1$ is produced by $I_1$ and when it is needed by $I_2$ in each scenario.\n\n**Scenario 1: Full Forwarding**\n\nIn this scenario, forwarding paths are available to move a result directly from a later pipeline stage to an earlier one, bypassing the register file. The problem specifies forwarding paths from the end of the $\\mathrm{EX}$ stage and the end of the $\\mathrm{MEM}$ stage to the beginning of the $\\mathrm{EX}$ stage.\n\n1.  **Value Production**: For the arithmetic instruction $I_1$ ($\\mathrm{ADD}$), the result for $R_1$ is calculated in the $\\mathrm{EX}$ stage. This result is available in the $\\mathrm{EX/MEM}$ pipeline register at the end of cycle $3$.\n2.  **Value Consumption**: The consumer instruction $I_2$ ($\\mathrm{SUB}$) requires the value of $R_1$ as an input to its ALU. This value is needed at the beginning of its $\\mathrm{EX}$ stage, which, without stalls, occurs at the start of cycle $4$.\n3.  **Hazard Resolution**: The forwarding logic can take the result of $I_1$ from the $\\mathrm{EX/MEM}$ pipeline register at the end of cycle $3$ and forward it to the input of the ALU for $I_2$ at the beginning of cycle $4$. This is the \"$\\mathrm{EX}$-to-$\\mathrm{EX}$\" forwarding path. The data arrives just in time for $I_2$ to execute without delay.\n\nSince the data is available precisely when it is needed, no stall is required.\nThe number of stall cycles with forwarding, $x$, is $0$.\n\nA pipeline diagram for this scenario:\nClock Cycle | $1$ | $2$ | $3$ | $4$ | $5$ | $6$\n------------|---|---|---|---|---|---\n$I_1$: ADD  | $\\mathrm{IF}$ | $\\mathrm{ID}$ | $\\mathrm{EX}$ | $\\mathrm{MEM}$ | $\\mathrm{WB}$ |\n$I_2$: SUB  | | $\\mathrm{IF}$ | $\\mathrm{ID}$ | $\\mathrm{EX}$ | $\\mathrm{MEM}$ | $\\mathrm{WB}$\n(In cycle $4$, the result from $I_1$'s $\\mathrm{EX}$ stage is forwarded to $I_2$'s $\\mathrm{EX}$ stage.)\n\n**Scenario 2: No Forwarding**\n\nWithout forwarding, a result is only available to subsequent instructions after it has been written to the register file in the producer's $\\mathrm{WB}$ stage.\n\n1.  **Value Production**: Instruction $I_1$ reaches its $\\mathrm{WB}$ stage in cycle $5$. It writes the new value of $R_1$ to the register file during this cycle.\n2.  **Value Consumption**: Instruction $I_2$ needs to read the value of $R_1$. This read operation occurs in its $\\mathrm{ID}$ stage.\n3.  **Hazard Resolution**: The hazard detection unit in the $\\mathrm{ID}$ stage will detect in cycle $3$ that $I_2$ depends on $R_1$, which is being computed by $I_1$. Since there is no forwarding, $I_2$ must be stalled until $I_1$ completes its $\\mathrm{WB}$ stage. The problem specifies that a register write in the $\\mathrm{WB}$ stage completes before a register read in the $\\mathrm{ID}$ stage within the same clock cycle. This is often called a \"split-phase\" or \"write-first\" register file. This rule allows an instruction to read a value in its $\\mathrm{ID}$ stage a in the same clock cycle that a previous instruction writes it in its $\\mathrm{WB}$ stage.\n\n    Therefore, the earliest that $I_2$ can complete its $\\mathrm{ID}$ stage is during cycle $5$, when $I_1$ is in its $\\mathrm{WB}$ stage.\n    - In cycle $3$, $I_2$ is in its $\\mathrm{ID}$ stage and the hazard is detected. It must be stalled.\n    - In cycle $4$, $I_1$ moves to $\\mathrm{MEM}$. $I_2$ is stalled and remains in the $\\mathrm{ID}$ stage. A bubble is inserted into the pipeline where $I_2$'s $\\mathrm{EX}$ stage would have been. This is $1$ stall cycle.\n    - In cycle $5$, $I_1$ moves to $\\mathrm{WB}$. $I_2$ is still stalled in the $\\mathrm{ID}$ stage. During this cycle, $I_1$ writes to $R_1$ and $I_2$ can now correctly read it. Another bubble is inserted into the pipeline. This is a $2$nd stall cycle.\n    - In cycle $6$, $I_2$ can now proceed to its $\\mathrm{EX}$ stage.\n\nThe instruction $I_2$ would normally enter its $\\mathrm{EX}$ stage in cycle $4$. Due to the hazard, it enters its $\\mathrm{EX}$ stage in cycle $6$. The total delay is $6-4=2$ cycles. Thus, $2$ stall cycles are required.\n\nA pipeline diagram for this scenario:\nClock Cycle | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$\n------------|---|---|---|---|---|---|---|---\n$I_1$: ADD  | $\\mathrm{IF}$ | $\\mathrm{ID}$ | $\\mathrm{EX}$ | $\\mathrm{MEM}$ | $\\mathrm{WB}$ | | |\n$I_2$: SUB  | | $\\mathrm{IF}$ | $\\mathrm{ID}$ | stall | stall | $\\mathrm{EX}$ | $\\mathrm{MEM}$ | $\\mathrm{WB}$\n\nThe number of stall cycles without forwarding, $y$, is $2$.\n\nThe final answer is the pair $(x, y)$, representing the stall counts with and without forwarding.\n- Stalls with forwarding, $x = 0$.\n- Stalls without forwarding, $y = 2$.\nThe pair is $(0, 2)$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix} 0 & 2 \\end{pmatrix}\n}\n$$", "id": "3632040"}, {"introduction": "Having established the critical role of forwarding, we now deepen our analysis by considering more realistic processor characteristics. Real instructions don't always complete in a single cycle, and the physical location of bypass paths is a key design decision. This practice challenges you to analyze a pipeline with a multi-cycle execution stage, comparing the effectiveness of forwarding from different points in the pipeline [@problem_id:3632084]. Solving this will illuminate the subtle timing considerations and engineering trade-offs involved in designing an efficient forwarding unit.", "problem": "Consider a single-issue, in-order, five-stage scalar pipeline consisting of Instruction Fetch (IF), Instruction Decode/Register Read (ID), Execute (EX), Memory (MEM), and Writeback (WB). The pipeline operates under the following physically realizable timing semantics:\n- Each stage occupies exactly $1$ full cycle, except that a multi-cycle functional unit occupies a stage for its full latency.\n- Interstage transfers and architectural register writes occur on the clock edge at the end of a cycle.\n- Register file reads occur at the beginning of ID; values written in WB at the end of cycle $t$ become visible to reads starting at the beginning of cycle $t+1$ (there is no half-cycle read-after-write trick).\n- Forwarding (bypass) paths, when present, deliver a producer’s value computed by the end of cycle $t$ to a consumer’s EX inputs at the beginning of cycle $t+1$.\n\nYou are given two consecutive instructions:\n- $I_1$: an arithmetic instruction that writes architectural register $R_1$ and uses a multi-cycle arithmetic unit in EX with latency $3$ cycles, then proceeds through MEM ($1$ cycle, functionally unused) and WB ($1$ cycle).\n- $I_2$: an arithmetic instruction that reads $R_1$ as a source operand.\n\nAssume that without hazards, $I_1$ would be in IF at cycle $1$, ID at cycle $2$, EX at cycles $3$ through $5$, MEM at cycle $6$, and WB at cycle $7$. Assume $I_2$ is the next sequential instruction; absent hazards, it would be in IF at cycle $2$, ID at cycle $3$, EX at cycle $4$, MEM at cycle $5$, and WB at cycle $6$.\n\nUsing only the core definitions of data hazards and pipeline timing, determine the earliest cycle at which $I_2$ can legally enter EX such that its read-after-write dependency on $R_1$ is satisfied in each of the following two microarchitectural configurations:\n- Case A: An EX-stage bypass path exists that forwards $I_1$’s EX result to $I_2$’s EX inputs.\n- Case B: No EX-stage bypass exists, but a WB-stage bypass exists that forwards $I_1$’s WB output to $I_2$’s EX inputs.\n\nYour answer must be the two cycle indices as a row vector $\\left(c_{\\mathrm{EX}}, c_{\\mathrm{WB}}\\right)$, where $c_{\\mathrm{EX}}$ is the earliest EX-entry cycle for Case A, and $c_{\\mathrm{WB}}$ is the earliest EX-entry cycle for Case B. Provide exact integers. No rounding is required. Explain your reasoning starting from the definitions of Read After Write (RAW), Write After Read (WAR), and Write After Write (WAW) hazards and the stated pipeline timing semantics, and show how the presence or absence of each bypass path alters the resolution of the RAW hazard for $I_2$.", "solution": "The problem statement has been validated and is deemed sound, well-posed, and scientifically grounded in the principles of computer organization and architecture. It provides a complete and consistent set of rules for a pipeline model, allowing for a deterministic analysis of data hazards.\n\nThis problem centers on a data dependency known as a Read-After-Write (RAW) hazard. Data hazards are classified into three types based on the ordering of read ($R$) and write ($W$) operations to a shared storage location (e.g., a register) by two instructions, $I_i$ (comes first in program order) and $I_j$ (comes after $I_i$):\n1.  **RAW (Read-After-Write):** $I_j$ tries to read a location before $I_i$ has written to it ($I_i: \\dots \\rightarrow W(x)$, $I_j: \\dots \\rightarrow R(x)$). This is a true data dependency.\n2.  **WAR (Write-After-Read):** $I_j$ tries to write to a location before $I_i$ has read from it ($I_i: \\dots \\rightarrow R(x)$, $I_j: \\dots \\rightarrow W(x)$). This is an anti-dependency.\n3.  **WAW (Write-After-Write):** $I_j$ tries to write to a location before $I_i$ has written to it ($I_i: \\dots \\rightarrow W(x)$, $I_j: \\dots \\rightarrow W(x)$). This is an output dependency.\n\nIn this problem, instruction $I_1$ writes to register $R_1$ and instruction $I_2$ subsequently reads from register $R_1$. This constitutes a classic RAW dependency. A hazard occurs if the pipeline's structure allows $I_2$ to enter its execution phase and read the value of $R_1$ before $I_1$ has completed writing the new value. To ensure correctness, the pipeline must enforce the program-order semantics, meaning $I_2$ must receive the value produced by $I_1$. This is achieved by stalling $I_2$ until the required data becomes available, either through the register file or via a bypass/forwarding path.\n\nFirst, let's establish the timeline for the producer instruction, $I_1$.\n- $I_1$ is in IF during cycle $1$.\n- $I_1$ is in ID during cycle $2$.\n- $I_1$ is in its multi-cycle EX stage during cycles $3$, $4$, and $5$. The arithmetic result is computed and becomes available at the pipeline latch at the end of the final EX cycle, which is the **end of cycle $5$**.\n- $I_1$ is in the MEM stage during cycle $6$. The result from EX is passed through this stage.\n- $I_1$ is in the WB stage during cycle $7$. The result is written back to the architectural register file ($R_1$) at the **end of cycle $7$**.\n\nNext, let's analyze the consumer instruction, $I_2$.\n- $I_2$ is fetched in cycle $2$ (IF stage).\n- $I_2$ enters the ID stage in cycle $3$. In this stage, the control logic detects that $I_2$ needs to read $R_1$, which is the destination register of the preceding instruction $I_1$ that is currently in the pipeline. A RAW hazard is detected.\n- $I_2$ needs the value of $R_1$ at the beginning of its own EX stage. The problem is to find the earliest cycle number at which $I_2$'s EX stage can begin, which requires the value from $I_1$ to be available at its input.\n\nWe will now solve for the two specified microarchitectural configurations.\n\n**Case A: An EX-stage bypass path exists.**\nThis path, often called an EX-to-EX forward, takes the result from the end of a producer's EX stage and routes it to the input of a consumer's EX stage.\n1.  As determined above, the result of $I_1$'s execution is available at the end of its EX stage, which completes at the **end of cycle $5$**.\n2.  The problem states that a forwarded value from the end of cycle $t$ becomes available at the consumer's EX inputs at the beginning of cycle $t+1$. Here, $t=5$.\n3.  Therefore, the value computed by $I_1$ can be forwarded to the inputs of $I_2$'s EX stage at the **beginning of cycle $6$**.\n4.  This means the earliest that $I_2$ can legally enter its EX stage is cycle $6$. To achieve this, the pipeline controller must stall $I_2$ in its ID stage during cycles $3$, $4$, and $5$. At the beginning of cycle $6$, $I_2$ can proceed from ID to EX, receiving the forwarded value just in time for execution.\nThus, the earliest EX-entry cycle for Case A is $c_{\\mathrm{EX}} = 6$.\n\nA pipeline diagram for this case is:\nI1: IF(1) ID(2) EX(3) EX(4) EX(5) MEM(6) WB(7)\nI2:      IF(2) ID(3) stall(4) stall(5) EX(6)  MEM(7) WB(8)\n\n**Case B: No EX-stage bypass exists, but a WB-stage bypass does.**\nIn this configuration, the result from $I_1$ cannot be forwarded directly from the EX stage. The value must propagate further down the pipeline until it reaches a point from which a bypass path is available. The problem specifies this is the WB stage.\n1.  The result computed by $I_1$ at the end of cycle $5$ propagates through the MEM stage (cycle $6$) and arrives at the WB stage at the beginning of cycle $7$.\n2.  The instruction $I_1$ is in its WB stage during cycle $7$. The value is available at this stage for forwarding. Following the timing semantics, the value is available from this stage's output latch at the **end of cycle $7$**.\n3.  Using the specified forwarding rule with $t=7$, the value from $I_1$'s WB stage is delivered to the inputs of $I_2$'s EX stage at the **beginning of cycle $t+1 = 8$**.\n4.  Consequently, the earliest that $I_2$ can legally enter its EX stage is cycle $8$. To achieve this, the pipeline must stall $I_2$ in its ID stage for additional cycles compared to Case A. It will be stalled during a total of $5$ cycles: $3, 4, 5, 6,$ and $7$. At the beginning of cycle $8$, it can proceed to EX.\nThus, the earliest EX-entry cycle for Case B is $c_{\\mathrm{WB}} = 8$.\n\nA pipeline diagram for this case is:\nI1: IF(1) ID(2) EX(3) EX(4) EX(5) MEM(6) WB(7)\nI2:      IF(2) ID(3) stall(4) stall(5) stall(6) stall(7) EX(8) MEM(9) WB(10)\n\nThis is a longer stall than waiting for a MEM-to-EX forward (which would allow EX entry at cycle $7$), and it is also one cycle faster than waiting for the register file write to complete. If there were no WB-to-EX bypass, $I_2$ would have to wait for the value to be written to the register file (end of cycle $7$) and then read it in its own ID stage (requiring ID to happen in cycle $8$ or later), pushing its EX stage to begin no earlier than cycle $9$. The WB-to-EX bypass saves one cycle compared to that scenario.\n\nThe final answer is the row vector of the two cycle indices $(c_{\\mathrm{EX}}, c_{\\mathrm{WB}})$.\n$c_{\\mathrm{EX}} = 6$\n$c_{\\mathrm{WB}} = 8$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6 & 8\n\\end{pmatrix}\n}\n$$", "id": "3632084"}, {"introduction": "Our focus so far has been on true data dependencies (RAW) in in-order pipelines. However, high-performance processors execute instructions out of order to maximize parallelism, which introduces new challenges. This advanced problem explores the interplay between RAW and Write-After-Read (WAR) hazards—a \"name dependency\" that arises in out-of-order execution—and the trade-offs between different writeback policies [@problem_id:3632047]. By analyzing this scenario, you will see how architectural decisions can resolve one type of hazard while potentially worsening another, motivating the need for sophisticated techniques like register renaming.", "problem": "Consider an out-of-order processor that uses scoreboarding (no register renaming) and a centralized architectural register file with one write port and operand forwarding via a broadcast bus. The pipeline stages relevant to this problem are Execute (EX) and Writeback (WB). Under the early writeback policy, a producer instruction writes its result at the end of its EX latency into the register file and onto the broadcast bus. Under the late writeback policy, a producer writes its result one cycle later in a dedicated Writeback (WB) stage. Operand forwarding allows a consumer instruction that has all other operands ready to begin its EX stage in the cycle immediately following the broadcast of its producer’s result; consumers capture the broadcast in the cycle it occurs and become eligible to start Execute (EX) in the next cycle. The scoreboarding mechanism delays any architectural register write if an older instruction has not yet performed its register read for that same architectural destination; such a delay is the mechanism used to avoid Write After Read (WAR) hazards in the absence of register renaming.\n\nThree instructions operate on the same architectural register $R_{A}$:\n- An older instruction $I_{O}$ will read $R_{A}$ during its operand read right before it begins its Execute (EX). Due to independent resource constraints, $I_{O}$ has its read scheduled for cycle $T_{O} = 14$.\n- A younger producer $I_{P}$ writes $R_{A}$. It begins Execute (EX) in cycle $t_{P} = 10$ and has an Execute latency of $L_{P} = 3$ cycles. There are no structural hazards on functional units or the broadcast bus.\n- A younger consumer $I_{C}$ needs the value of $R_{A}$ produced by $I_{P}$ and has all other operands and resources ready starting at cycle $10$. It can be scheduled to begin Execute (EX) as soon as $R_{A}$ is available under the forwarding and broadcast semantics described above.\n\nAssume that under early writeback the intended write time of $I_{P}$ is the end of its Execute (EX) latency, and under late writeback it is exactly one cycle later in Writeback (WB). In both policies, scoreboarding will prevent the actual architectural write from occurring before cycle $T_{O}$, but the intended write time determines both the earliest time the consumer $I_{C}$ can begin Execute (EX) via forwarding and the duration of potential Write After Read (WAR) exposure, defined as the number of cycles between the intended write time of $I_{P}$ and the older read time $T_{O}$ of $I_{O}$.\n\nUsing the core definitions of Read After Write (RAW) and Write After Read (WAR) hazards, and the timing rules given above, compute the ordered pair\n$$\n\\left( \\Delta t_{\\mathrm{RAW}}, \\Delta t_{\\mathrm{WAR}} \\right),\n$$\nwhere $\\Delta t_{\\mathrm{RAW}}$ is the reduction in the earliest possible start cycle of $I_{C}$’s Execute (EX) under early writeback relative to late writeback, and $\\Delta t_{\\mathrm{WAR}}$ is the increase in the duration of potential WAR exposure under early writeback relative to late writeback. Express your final answer as the ordered pair of cycle counts with no units.", "solution": "The problem requires the calculation of an ordered pair $(\\Delta t_{\\mathrm{RAW}}, \\Delta t_{\\mathrm{WAR}})$ that describes the timing differences between an 'early writeback' and a 'late writeback' policy in an out-of-order processor. $\\Delta t_{\\mathrm{RAW}}$ represents the change in the start time of a consumer instruction due to a Read-After-Write (RAW) data dependency, and $\\Delta t_{\\mathrm{WAR}}$ represents the change in the duration of a Write-After-Read (WAR) hazard.\n\nFirst, we establish the baseline timings from the problem statement.\nThe producer instruction, $I_P$, begins its Execute (EX) stage at cycle $t_P = 10$.\nThe execution latency of $I_P$ is $L_P = 3$ cycles.\nTherefore, the EX stage of $I_P$ occupies cycles $10$, $11$, and $12$. The EX stage is completed at the end of cycle $12$.\n\nThe older instruction, $I_O$, performs its register read from the architectural register $R_A$ in cycle $T_O = 14$. This read must complete before $I_P$ is allowed to write to $R_A$, which is the essence of the WAR hazard handled by the scoreboard.\n\nThe consumer instruction, $I_C$, requires the result of $I_P$. Its earliest EX start time depends on when $I_P$'s result is broadcast, as per the forwarding rules.\n\nLet's analyze each policy to determine the key cycle timings.\n\n**1. Late Writeback Policy Analysis**\n\nUnder the late writeback policy, the result of $I_P$ is intended to be written and broadcast one cycle after its EX stage is complete. Let $T_{P, \\text{write, late}}$ be the cycle number of this intended write. Since the EX stage completes at the end of cycle $12$, the write occurs in the subsequent cycle.\n$$\nT_{P, \\text{write, late}} = 12 + 1 = 13\n$$\nThe consumer instruction, $I_C$, can begin its EX stage in the cycle immediately following the broadcast. Let $T_{C, \\text{start, late}}$ be the earliest start cycle for $I_C$ under this policy.\n$$\nT_{C, \\text{start, late}} = T_{P, \\text{write, late}} + 1 = 13 + 1 = 14\n$$\nThe duration of the potential WAR exposure, $W_{\\text{late}}$, is the number of cycles between the intended write time of $I_P$ and the read time of $I_O$.\n$$\nW_{\\text{late}} = T_O - T_{P, \\text{write, late}} = 14 - 13 = 1\n$$\nSo, under late writeback, the WAR hazard is exposed for $1$ cycle. Scoreboarding must stall the write of $I_P$ for this duration.\n\n**2. Early Writeback Policy Analysis**\n\nUnder the early writeback policy, the result is intended to be written and broadcast at the end of the EX latency. This corresponds to the cycle in which the EX stage completes. Let $T_{P, \\text{write, early}}$ be the cycle number of this intended write.\n$$\nT_{P, \\text{write, early}} = 12\n$$\nThe earliest start cycle for $I_C$ under this policy, $T_{C, \\text{start, early}}$, is the cycle following the broadcast.\n$$\nT_{C, \\text{start, early}} = T_{P, \\text{write, early}} + 1 = 12 + 1 = 13\n$$\nThe duration of the potential WAR exposure, $W_{\\text{early}}$, is calculated using the same definition.\n$$\nW_{\\text{early}} = T_O - T_{P, \\text{write, early}} = 14 - 12 = 2\n$$\nUnder early writeback, the WAR hazard is exposed for $2$ cycles.\n\n**3. Calculation of Final Values**\n\nNow we can compute the quantities requested in the problem.\n\n$\\Delta t_{\\mathrm{RAW}}$ is the *reduction* in the earliest possible start cycle of $I_C$'s Execute (EX) under early writeback relative to late writeback.\n$$\n\\Delta t_{\\mathrm{RAW}} = T_{C, \\text{start, late}} - T_{C, \\text{start, early}} = 14 - 13 = 1\n$$\nA positive value indicates a reduction, as requested. Early writeback allows the consumer to start $1$ cycle sooner, resolving the RAW dependency faster.\n\n$\\Delta t_{\\mathrm{WAR}}$ is the *increase* in the duration of potential WAR exposure under early writeback relative to late writeback.\n$$\n\\Delta t_{\\mathrm{WAR}} = W_{\\text{early}} - W_{\\text{late}} = 2 - 1 = 1\n$$\nA positive value indicates an increase. Early writeback exposes the WAR hazard for $1$ additional cycle compared to late writeback.\n\nThis illustrates the fundamental trade-off: an earlier write/broadcast resolves RAW hazards sooner at the cost of increasing the window of exposure for WAR hazards.\n\nThe final answer is the ordered pair $(\\Delta t_{\\mathrm{RAW}}, \\Delta t_{\\mathrm{WAR}})$.\n$$\n(\\Delta t_{\\mathrm{RAW}}, \\Delta t_{\\mathrm{WAR}}) = (1, 1)\n$$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 & 1\n\\end{pmatrix}\n}\n$$", "id": "3632047"}]}