{"hands_on_practices": [{"introduction": "This first practice establishes the fundamental performance impact of a structural hazard. In a simple pipeline, the rate at which instructions can be completed is dictated by its slowest stage, which can lead to a Cycles Per Instruction ($CPI$) greater than the ideal value of $1$. This exercise [@problem_id:3682639] challenges you to calculate the precise $CPI$ when a register file's limited read ports create a bottleneck, demonstrating how a resource constraint directly limits processor throughput.", "problem": "Consider a scalar, five-stage pipeline in a Central Processing Unit (CPU) with the following stages: Instruction Fetch (IF), Instruction Decode and Register Read (ID), Execute (EX), Memory Access (MEM), and Write Back (WB). In the absence of hazards, each stage occupies exactly $1$ clock cycle per instruction, and the pipeline issues at most one instruction per cycle. The register file can service up to $R$ read ports and $W$ write ports per cycle. A triadic instruction requires reading $3$ source registers and writing $1$ destination register. Reads are performed only in the ID stage, and writes are performed only in the WB stage. The register file cannot perform more than $R$ reads or more than $W$ writes in the same cycle, and the ID stage cannot move forward to the EX stage until all required register reads for the instruction have been completed. Hazard resolution is performed solely by stalling: a stage that cannot complete its required work in the current cycle holds its instruction and prevents upstream stages from advancing.\n\nConsider a long steady-state sequence of such triadic instructions with no data dependencies, no control hazards, and no memory operations in the MEM stage, so that the only potential hazards are structural hazards arising from the register file ports. Let $R=2$ and $W=1$. Under optimal scheduling consistent with the given constraints, what is the steady-state average Cycles Per Instruction (CPI) of this pipeline?\n\nExpress your final answer as a single real number. No rounding is necessary.", "solution": "The foundational definitions are as follows. A structural hazard arises when hardware resources required in a given cycle exceed their available capacity. In a pipelined CPU, if a stage cannot complete its required operations due to insufficient resources, that stage must stall, which prevents upstream stages from advancing and can reduce throughput. The average Cycles Per Instruction (CPI) in steady state for a scalar pipeline with balanced stages and no hazards is $1$. If one stage requires more than $1$ cycle per instruction due to resource limits, then that stage becomes the throughput bottleneck: the pipeline cannot issue new instructions faster than that stage can accept them, and the steady-state CPI equals the number of cycles per instruction required by the bottleneck stage.\n\nApply these principles to the given scenario. Each triadic instruction requires $3$ register reads in the Instruction Decode and Register Read (ID) stage and $1$ register write in the Write Back (WB) stage. The register file has $R=2$ read ports and $W=1$ write port. The WB stage for a single-issue pipeline with $W=1$ can handle at most $1$ write per cycle, but since there is only one instruction in WB at a time (single issue), WB is not a bottleneck for this instruction mix. The critical resource is the read ports in ID.\n\nIn the ID stage, at most $R=2$ registers can be read per cycle. A triadic instruction requires $3$ reads, which cannot be completed in a single cycle because $3 > R=2$. Therefore, the ID stage must retain the instruction for multiple cycles. Specifically, in the first ID cycle the instruction can read $2$ operands, and in the second ID cycle it can read the remaining $1$ operand. Thus the ID stage occupancy per instruction is\n$$\n\\left\\lceil \\frac{3}{R} \\right\\rceil = \\left\\lceil \\frac{3}{2} \\right\\rceil = 2 \\text{ cycles}.\n$$\nBecause hazard resolution is performed solely by stalling and the pipeline is single issue, the ID stage holding an instruction for $2$ cycles prevents the next instruction from entering ID until those reads complete. This imposes a $1$-cycle stall per instruction relative to the hazard-free case where ID would complete in $1$ cycle.\n\nWe can make this explicit by outlining the schedule for one instruction, denoted $I_1$:\n- Cycle $1$: $I_1$ in IF.\n- Cycle $2$: $I_1$ in ID (reads $2$ registers).\n- Cycle $3$: $I_1$ in ID (reads $1$ register, completing reads).\n- Cycle $4$: $I_1$ in EX.\n- Cycle $5$: $I_1$ in MEM.\n- Cycle $6$: $I_1$ in WB (performs $1$ write, which is within $W=1$).\n\nFor the next instruction $I_2$, the earliest it can enter ID is after cycle $3$, because the ID stage is occupied by $I_1$ in cycles $2$ and $3$. Therefore, even in steady state with a long sequence of such instructions and no other hazards, the ID stage processes instructions at a rate of $1$ instruction per $2$ cycles. Since all other stages are $1$ cycle, the ID stage is the throughput-limiting bottleneck.\n\nConsequently, the steady-state throughput is $0.5$ instructions per cycle, and the steady-state average Cycles Per Instruction is\n$$\n\\mathrm{CPI} = 2.\n$$\nNo rounding is necessary because this is an exact value derived from the integer resource constraints and stage occupancies.", "answer": "$$\\boxed{2}$$", "id": "3682639"}, {"introduction": "With a foundational understanding of how structural hazards cause stalls, the next critical skill is to correctly identify them, as they can sometimes be mistaken for other types of hazards. This practice [@problem_id:3682664] presents a scenario in a dual-issue processor where two instructions contend for a single Address Generation Unit (AGU), a classic structural hazard. Your task is to explain why this is not a data hazard—despite appearances—and to quantify the resulting performance penalty, sharpening your diagnostic skills.", "problem": "Consider an in-order, dual-issue pipeline executing integer and memory instructions. The machine has the following properties:\n\n- The front end can fetch and decode up to $2$ instructions per cycle and attempts to issue them in program order as a pair.\n- There is one Address Generation Unit (AGU) resource. Any load or store requires the AGU for exactly $1$ cycle when performing effective address computation. The AGU cannot be shared within the same cycle, so at most one memory instruction can use the AGU per cycle.\n- The Arithmetic Logic Unit (ALU) executes integer arithmetic/logical instructions, with at most $1$ ALU instruction per cycle. ALU instructions do not use the AGU.\n- Loads and stores have no cache misses; ignore memory latency beyond the fact that loads and stores each require an AGU-use cycle to compute their effective addresses. The issue logic stalls the second instruction of a pair when a structural conflict is detected, allowing the first to proceed.\n- Hazard detection is standard: a data hazard exists only when there is a true dependence on a value (read-after-write). Reading the same register in two consecutive instructions without an intervening write is not a data hazard.\n\nConstruct an instruction sequence that appears to be a data hazard but is actually a structural hazard due to the shared AGU by using the same base register for two consecutive memory operations. Then, for the specific loop body below, explain the distinction and quantify the stalls caused purely by AGU contention.\n\nLoop body (one iteration), written in a register-transfer style:\n\n- Instruction $1$: load $R4 \\leftarrow \\mathrm{Mem}[R1 + $ $0$ $]$.\n- Instruction $2$: store $\\mathrm{Mem}[R1 + $ $8$ $] \\leftarrow R5$.\n- Instruction $3$: integer add $R6 \\leftarrow R6 + R9$.\n- Instruction $4$: integer subtract $R10 \\leftarrow R11 - R12$.\n\nAssume the front end attempts to issue instructions $1$ and $2$ together in the first cycle of the iteration, and thereafter continues in program order attempting to fill both issue slots each cycle, subject to the resource constraints above.\n\nTasks:\n\n1. Using the fundamental definitions of structural and data hazards, justify why the interaction between instructions $1$ and $2$ is a structural hazard rather than a data hazard.\n2. Determine the number of stall cycles incurred per iteration of the loop solely due to the shared AGU.\n3. For $N = $ $100$ iterations of this loop body, compute the total number of stall cycles caused by the AGU contention. Express your final result as a number of stall cycles. No rounding is required.", "solution": "1.  **Justification of Hazard Type:**\n    A **data hazard** occurs when there is a true data dependency (Read-After-Write, RAW) between instructions. Instruction 1 (`load R4 - ...`) writes to register `R4`. Instruction 2 (`store ... - R5`) does not read `R4`. Both instructions read register `R1`, but this is not a data hazard as there is no intervening write. Therefore, no data hazard exists between them.\n    A **structural hazard** occurs when two instructions require the same hardware resource in the same cycle. Both the `load` and `store` instructions require the Address Generation Unit (AGU) to compute their effective addresses (`R1 + 0` and `R1 + 8`, respectively). Since the processor is dual-issue and attempts to execute them simultaneously, but only has one AGU, they contend for this single resource. This resource conflict is a structural hazard.\n\n2.  **Stall Cycles per Iteration:**\n    The processor attempts to issue instructions in pairs.\n    *   **Pair 1 (`load`, `store`):** Both instructions need the single AGU in the same cycle. A structural hazard occurs. The policy is to issue the first instruction (`load`) and stall the second (`store`). The `store` is then issued in the next cycle. This pair takes 2 cycles to issue instead of an ideal 1 cycle. This results in **1 stall cycle** due to AGU contention.\n    *   **Pair 2 (`add`, `subtract`):** Both instructions need the single ALU. Another structural hazard occurs. This pair also takes 2 cycles to issue, causing 1 stall cycle due to ALU contention.\n\n    The question asks for stalls *solely due to the shared AGU*. This occurs with the first pair, resulting in 1 stall cycle per iteration.\n\n3.  **Total Stall Cycles:**\n    For $N=100$ iterations, the total number of stall cycles due to AGU contention is the number of stalls per iteration multiplied by the number of iterations.\n    Total AGU Stalls = $1 \\text{ stall/iteration} \\times 100 \\text{ iterations} = 100 \\text{ stalls}$.", "answer": "$$\n\\boxed{100}\n$$", "id": "3682664"}, {"introduction": "The ultimate goal of understanding hazards is to mitigate them and improve performance. This final exercise [@problem_id:3682602] moves into the realm of quantitative architectural analysis, where you will evaluate the benefit of adding a hardware resource to alleviate a structural bottleneck. Using a probabilistic model to represent a realistic instruction workload, you will calculate the precise improvement in Cycles-Per-Instruction ($CPI$) gained by adding an extra Address Generation Unit (AGU), providing a concrete example of a design trade-off analysis.", "problem": "A superscalar out-of-order core is designed with a memory subsystem that can experience structural hazards when concurrent memory operations contend for limited resources. A structural hazard is defined as a stall caused by insufficient hardware resources to serve all ready operations at a given time. The memory pipeline has two relevant resources: the Address Generation Unit (AGU) that computes effective addresses, and the Load-Store Unit (LSU) that issues memory accesses to the data cache.\n\nConsider the following microbenchmark-based test scenario to stress AGU demand while observing the impact on the LSU-side structural hazard:\n\n- The core can attempt to issue up to $W=4$ ready micro-operations per cycle.\n- Initially, there is $C=1$ AGU available per cycle and $L=2$ LSU issue slots per cycle.\n- After a microarchitectural change, the number of AGUs is increased to $C^{\\prime}=2$ while the LSU capacity remains $L=2$.\n- At steady state, the number of memory-address-generation demands per cycle, $X$, among the $W=4$ ready micro-operations, follows a Binomial distribution with parameters $W=4$ and $p=\\frac{3}{5}$, where $p$ is the fraction of ready micro-operations that are loads or stores requiring an address computation. All other micro-operations are independent arithmetic operations that are never limited by AGU or LSU resources.\n- Assume perfect branch prediction, no cache misses, and no other hazards. The only source of stalls is structural hazard due to finite AGU/LSU resources. In any cycle when $k$ memory-address-generation demands arrive, at most $\\min(C,L)$ of them can be served; the remainder in that cycle are deferred. Treat each cycle’s deferrals as an immediate throughput reduction for that cycle, without introducing additional limitations elsewhere.\n\nUsing only the definitions above and well-tested properties of the Binomial distribution, derive from first principles the expected cycles-per-instruction (CPI) before and after adding the extra AGU, and then compute the CPI improvement defined as the difference $\\text{CPI}_{\\text{before}}-\\text{CPI}_{\\text{after}}$. Express your final CPI improvement as a single exact fraction. Do not round.", "solution": "The core performance metric, Cycles-Per-Instruction (CPI), is the reciprocal of Instructions-Per-Cycle (IPC). We first calculate the expected IPC for the system before and after the hardware upgrade.\n\nThe total number of micro-operations ready per cycle is $W=4$. The number of these that are memory operations, $X$, follows a Binomial distribution $X \\sim \\text{Binomial}(n=4, p=3/5)$. The remaining $4-X$ are arithmetic operations that are never stalled.\n\nThe number of memory operations that can be served per cycle is limited by the minimum of available AGUs and LSUs. Let this capacity be $K$. The number of memory operations successfully executed is $\\min(X, K)$. The total instructions executed per cycle is $(4-X) + \\min(X, K)$.\n\nThe expected IPC is therefore:\n$$\\text{IPC} = E[4 - X + \\min(X, K)] = 4 - E[X] + E[\\min(X, K)]$$\nWe know $E[X] = n \\cdot p = 4 \\cdot \\frac{3}{5} = \\frac{12}{5}$.\n\nTo find $E[\\min(X, K)]$, we need the probabilities $P(X=k)$ for $k \\in \\{0, 1, 2, 3, 4\\}$, which are derived from the Binomial PMF:\n$P(X=0) = 16/625$, $P(X=1) = 96/625$, $P(X=2) = 216/625$, $P(X=3) = 216/625$, $P(X=4) = 81/625$.\n\n**Case 1: Before Upgrade**\nResources: $C=1$ AGU, $L=2$ LSUs. Service capacity $K_{\\text{before}} = \\min(1, 2) = 1$.\nThe expected number of served memory ops is $E[\\min(X, 1)] = \\sum_{k=0}^4 \\min(k,1)P(X=k) = 1 \\cdot P(X \\ge 1) = 1 - P(X=0) = 1 - 16/625 = 609/625$.\n$$\\text{IPC}_{\\text{before}} = 4 - \\frac{12}{5} + \\frac{609}{625} = \\frac{8}{5} + \\frac{609}{625} = \\frac{1000}{625} + \\frac{609}{625} = \\frac{1609}{625}$$\n$$\\text{CPI}_{\\text{before}} = \\frac{625}{1609}$$\n\n**Case 2: After Upgrade**\nResources: $C'=2$ AGUs, $L=2$ LSUs. Service capacity $K_{\\text{after}} = \\min(2, 2) = 2$.\nThe expected number of served memory ops is $E[\\min(X, 2)] = \\sum_{k=0}^4 \\min(k,2)P(X=k) = 1\\cdot P(X=1) + 2\\cdot(P(X=2)+P(X=3)+P(X=4))$.\n$$E[\\min(X, 2)] = 1 \\cdot \\frac{96}{625} + 2 \\cdot \\left(\\frac{216}{625} + \\frac{216}{625} + \\frac{81}{625}\\right) = \\frac{96}{625} + 2 \\cdot \\frac{513}{625} = \\frac{96+1026}{625} = \\frac{1122}{625}$$\n$$\\text{IPC}_{\\text{after}} = 4 - \\frac{12}{5} + \\frac{1122}{625} = \\frac{8}{5} + \\frac{1122}{625} = \\frac{1000}{625} + \\frac{1122}{625} = \\frac{2122}{625}$$\n$$\\text{CPI}_{\\text{after}} = \\frac{625}{2122}$$\n\n**CPI Improvement**\nThe improvement is the difference:\n$$\\Delta\\text{CPI} = \\text{CPI}_{\\text{before}} - \\text{CPI}_{\\text{after}} = \\frac{625}{1609} - \\frac{625}{2122}$$\n$$= 625 \\left( \\frac{1}{1609} - \\frac{1}{2122} \\right) = 625 \\left( \\frac{2122 - 1609}{1609 \\cdot 2122} \\right)$$\n$$= 625 \\left( \\frac{513}{3414298} \\right) = \\frac{320625}{3414298}$$", "answer": "$$\n\\boxed{\\frac{320625}{3414298}}\n$$", "id": "3682602"}]}