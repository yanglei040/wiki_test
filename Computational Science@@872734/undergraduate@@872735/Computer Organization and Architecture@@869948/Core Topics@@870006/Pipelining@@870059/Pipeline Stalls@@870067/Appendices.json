{"hands_on_practices": [{"introduction": "To begin, let's quantify the impact of a fundamental data hazard: the load-use dependency. This exercise will guide you through calculating the necessary stall cycles, or 'bubbles', for a common instruction sequence, both with and without a forwarding network. By comparing these two scenarios, you'll gain a concrete understanding of why forwarding is a critical optimization in modern pipelines. [@problem_id:3665759]", "problem": "Consider a single-issue, in-order, five-stage pipeline with the following stages: Instruction Fetch (IF), Instruction Decode and register read (ID), Execute (EX), Memory Access (MEM), and Write Back (WB). The pipeline is extended to model a load latency of $L$ cycles by splitting the memory access into $L$ sequential sub-stages $\\mathrm{MEM}_1, \\mathrm{MEM}_2, \\dots, \\mathrm{MEM}_L$, each taking one cycle. Assume the following foundational timing rules:\n- Each pipeline stage takes exactly one cycle.\n- Data produced by a stage becomes available for use (via forwarding, if present) at the beginning of the cycle immediately following the cycle in which it is produced.\n- Without forwarding (also called bypassing), a value written in WB becomes visible to the register file at the beginning of the cycle immediately following the WB cycle; the ID stage reads operands at the beginning of its cycle.\n\nYou are given the following assembly snippet in a generic reduced instruction set architecture, where registers $\\mathrm{t0}$ and $\\mathrm{t1}$ are loaded and then consumed by an add:\n- lw t0, 0(a0)\n- lw t1, 0(a1)\n- add t2, t0, t1\n\nBoth loads are back-to-back and the add depends on both loaded values. Using only the above timing rules and the core definitions of pipeline stages and data hazards, determine the number of bubbles (stall cycles) that must be inserted between the second load and the add so that the addâ€™s Execute (EX) stage begins only when both operands are available, for the case of load latency $L=2$:\n1. With a full bypass (forwarding) network that can forward from the output of $\\mathrm{MEM}_L$ to the input of EX in the next cycle.\n2. Without any bypass network (the add must read its operands from the register file after WB has completed and become visible per the rule above).\n\nReport your final answer as a row matrix with the bubble count for the bypassed case first, followed by the non-bypassed case. No rounding is required and no units are involved.", "solution": "The problem requires the determination of the number of stall cycles (bubbles) needed for a specific sequence of instructions under two different data hazard management schemes: with and without a forwarding network. The analysis will be based on a cycle-by-cycle trace of the instructions through the specified pipeline.\n\nThe pipeline has five nominal stages: Instruction Fetch ($\\mathrm{IF}$), Instruction Decode and register read ($\\mathrm{ID}$), Execute ($\\mathrm{EX}$), Memory Access ($\\mathrm{MEM}$), and Write Back ($\\mathrm{WB}$). The memory access for load instructions is stated to have a latency of $L=2$ cycles, modeled by splitting the $\\mathrm{MEM}$ stage into two sequential sub-stages, $\\mathrm{MEM}_1$ and $\\mathrm{MEM}_2$. Thus, a load instruction passes through the sequence $\\mathrm{IF}, \\mathrm{ID}, \\mathrm{EX}, \\mathrm{MEM}_1, \\mathrm{MEM}_2, \\mathrm{WB}$, taking $6$ cycles. An ALU instruction like `add` follows the standard five-stage path $\\mathrm{IF}, \\mathrm{ID}, \\mathrm{EX}, \\mathrm{MEM}, \\mathrm{WB}$, taking $5$ cycles.\n\nThe instruction sequence is:\n$I_1$: `lw t0, 0(a0)`\n$I_2$: `lw t1, 0(a1)`\n$I_3$: `add t2, t0, t1`\n\nThe `add` instruction ($I_3$) has a Read-After-Write (RAW) data dependency on both load instructions ($I_1$ and $I_2$), as it uses the values loaded into registers $\\mathrm{t0}$ and $\\mathrm{t1}$. Since the instructions are issued in order and $I_2$ is issued after $I_1$, the data from $I_2$ for register $\\mathrm{t1}$ will be available later than the data from $I_1$ for register $\\mathrm{t0}$. Therefore, the critical dependency that determines the required number of stalls is between $I_2$ and $I_3$.\n\nLet us assume instruction $I_1$ enters the $\\mathrm{IF}$ stage at cycle $1$. In a single-issue, in-order pipeline without stalls, $I_2$ will enter $\\mathrm{IF}$ at cycle $2$, and $I_3$ will enter $\\mathrm{IF}$ at cycle $3$.\n\nThe progression of the critical instructions ($I_2$ and $I_3$) without any stalls would be:\n- $I_2$ (`lw t1`): $\\mathrm{IF}(c=2), \\mathrm{ID}(c=3), \\mathrm{EX}(c=4), \\mathrm{MEM}_1(c=5), \\mathrm{MEM}_2(c=6), \\mathrm{WB}(c=7)$\n- $I_3$ (`add`): $\\mathrm{IF}(c=3), \\mathrm{ID}(c=4), \\mathrm{EX}(c=5), \\mathrm{MEM}(c=6), \\mathrm{WB}(c=7)$\n\nHere, `Stage(c=N)` denotes that the instruction is in that stage during cycle $N$.\n\n### Case 1: With Full Bypass (Forwarding) Network\n\nThe problem states that the forwarding network can bypass data from the output of the $\\mathrm{MEM}_L$ stage to the input of the $\\mathrm{EX}$ stage in the next cycle. For $L=2$, this is a path from the output of $\\mathrm{MEM}_2$ to the input of $\\mathrm{EX}$.\n\n1.  **Data Production**: The `lw` instruction $I_2$ retrieves the data from memory at the end of its $\\mathrm{MEM}_2$ stage. According to our timeline, the $\\mathrm{MEM}_2$ stage of $I_2$ occurs in cycle $6$. Thus, the value for register $\\mathrm{t1}$ is produced at the end of cycle $6$.\n2.  **Data Availability (Forwarding)**: The forwarding rule states the data is available for use at the beginning of the cycle immediately following its production. Therefore, the value of $\\mathrm{t1}$ can be forwarded to the $\\mathrm{EX}$ stage of a subsequent instruction starting from the beginning of cycle $7$.\n3.  **Data Consumption**: The `add` instruction $I_3$ requires the value of $\\mathrm{t1}$ as an input for its $\\mathrm{EX}$ stage.\n4.  **Hazard Detection and Stalling**: In the unstalled timeline, $I_3$ is scheduled to enter its $\\mathrm{EX}$ stage at the beginning of cycle $5$. However, the required data ($\\mathrm{t1}$) is not available until the beginning of cycle $7$. To resolve this hazard, the pipeline must stall $I_3$ until its $\\mathrm{EX}$ stage can begin in cycle $7$.\n5.  **Bubble Calculation**: The $\\mathrm{EX}$ stage of $I_3$ must be delayed from its originally scheduled time (cycle $5$) to the time the data is available (cycle $7$). The required delay is $7 - 5 = 2$ cycles. This delay is implemented by inserting $2$ bubbles (or `nop` instructions) into the pipeline between $I_2$ and $I_3$.\n\nTherefore, with the full bypass network, $2$ stall cycles are required.\n\n### Case 2: Without Any Bypass Network\n\nWithout forwarding, an instruction can only consume a value after it has been written to the register file and becomes visible.\n\n1.  **Data Production and Write-Back**: The `lw` instruction $I_2$ completes its $\\mathrm{WB}$ stage at the end of cycle $7$.\n2.  **Data Availability (Register File)**: The problem states that a value written in the $\\mathrm{WB}$ stage becomes visible to the register file at the beginning of the cycle *immediately following* the $\\mathrm{WB}$ cycle. Thus, the value for register $\\mathrm{t1}$ is visible in the register file starting from the beginning of cycle $8$.\n3.  **Data Consumption**: The `add` instruction $I_3$ reads its source operands from the register file during its $\\mathrm{ID}$ stage. The rule specifies that the ID stage reads operands at the beginning of its cycle.\n4.  **Hazard Detection and Stalling**: For $I_3$ to execute correctly, its $\\mathrm{ID}$ stage must occur at or after the cycle when the value of $\\mathrm{t1}$ becomes visible in the register file. This means the $\\mathrm{ID}$ stage of $I_3$ cannot begin before cycle $8$.\n5.  **Bubble Calculation**: In the unstalled timeline, the $\\mathrm{ID}$ stage of $I_3$ is scheduled for cycle $4$. To resolve the hazard, the pipeline must stall $I_3$ until its $\\mathrm{ID}$ stage can begin in cycle $8$. The required delay is $8 - 4 = 4$ cycles. This necessitates the insertion of $4$ bubbles between $I_2$ and $I_3$.\n\nTherefore, without any bypass network, $4$ stall cycles are required.\n\nThe final answer is a row matrix containing the bubble counts for the bypassed and non-bypassed cases, respectively.\n- Bubbles with forwarding: $2$\n- Bubbles without forwarding: $4$", "answer": "$$\n\\boxed{\\begin{pmatrix} 2 & 4 \\end{pmatrix}}\n$$", "id": "3665759"}, {"introduction": "Real-world processors feature functional units with varying execution times, such as for multiplication or division, which complicates hazard detection. This next practice explores a scenario where a standard forwarding mechanism encounters a multi-cycle instruction, leading to incorrect behavior if not properly managed. Your task is to determine the correct number of stalls needed to ensure data integrity, revealing the importance of robust hazard detection logic. [@problem_id:3665810]", "problem": "Consider a classic in-order, single-issue, five-stage pipeline with stages Instruction Fetch (IF), Instruction Decode/Register Read (ID), Execute (EX), Memory Access (MEM), and Write Back (WB). The register file implements the widely used convention that it writes in WB during the first half of a cycle and reads in ID during the second half of the same cycle, allowing a value written in a given cycle to be read in ID of that same cycle without an additional stall. The pipeline includes full forwarding (also called bypassing) from the outputs of EX, MEM, and WB into operands at the start of EX, provided the data is available at that time.\n\nNow consider a multi-cycle functional unit integrated into EX that performs integer multiplication. This integer multiply takes $3$ cycles, denoted $\\text{EX1}$, $\\text{EX2}$, and $\\text{EX3}$, and produces a result only at the end of $\\text{EX3}$. That result is then latched into the EX/MEM pipeline register at the cycle boundary and proceeds to MEM and WB as usual. Assume the forwarding network and hazard detection were designed under the simplifying assumption that integer operations complete in $1$ cycle in EX; consequently, the hazard detection asserts \"forward-from-EX\" for any dependent consumer entering EX in the next cycle, even when the producer is a multi-cycle multiply. This creates a false confidence and attempts to forward too early.\n\nAnalyze the following instruction sequence where $I_1$ produces a value consumed by $I_2$:\n- $I_1$: $\\text{MUL } R_4 \\leftarrow R_2 \\times R_3$ (uses the $3$-cycle multiply unit in EX, result written to $R_4$),\n- $I_2$: $\\text{ADD } R_5 \\leftarrow R_4 + R_6$ (uses a $1$-cycle integer add in EX).\n\nAssume $I_1$ enters IF at cycle $t=1$ and the pipeline issues one instruction per cycle without stalls unless explicitly inserted. The multiply result is not architecturally available until the end of $I_1$'s $\\text{EX3}$ substage and cannot be consumed by another instruction's EX at the beginning of that same cycle.\n\nFrom first principles of pipeline timing, determine the minimal bubble-insertion policy that guarantees correctness (i.e., $I_2$ uses the actual result of $I_1$) while maximizing throughput under the given forwarding and register file timing. Choose the best option:\n\nA. Insert $0$ bubbles; rely on forwarding from $\\text{EX}$ to $\\text{EX}$ to supply $I_2$ in the next cycle.\n\nB. Insert $1$ bubble by stalling $I_2$ in $\\text{ID}$ for $1$ cycle; then rely on forwarding from the producer after $\\text{EX3}$.\n\nC. Insert $2$ bubbles by stalling $I_2$ in $\\text{ID}$ for $2$ cycles; then rely on forwarding from the producer after $\\text{EX3}$.\n\nD. Insert $3$ bubbles by stalling $I_2$ in $\\text{ID}$ until $I_1$ reaches $\\text{WB}$ so that $I_2$ reads $R_4$ from the register file with no forwarding.", "solution": "To determine the minimal number of bubbles, we must trace the pipeline execution and identify the Read-After-Write (RAW) data hazard between the multiply ($I_1$) and the add ($I_2$) instructions.\n\n1.  **Instruction Timeline (No Stalls):**\n    - Let $I_1$ enter the `IF` stage at cycle 1.\n    - $I_1$ (`MUL`): `IF(1)`, `ID(2)`, `EX1(3)`, `EX2(4)`, `EX3(5)`, `MEM(6)`, `WB(7)`\n    - $I_2$ (`ADD`): `IF(2)`, `ID(3)`, `EX(4)`, `MEM(5)`, `WB(6)`\n\n2.  **Hazard Analysis:**\n    - The `ADD` instruction ($I_2$) needs the value of register $R_4$ at the beginning of its `EX` stage, which is cycle 4 in the unstalled timeline.\n    - The `MUL` instruction ($I_1$) produces the result for $R_4$ at the end of its `EX3` stage, which is the end of cycle 5.\n    - The forwarding network makes this result available at the *beginning* of the next cycle, cycle 6, from the `EX/MEM` pipeline register.\n    - Since $I_2$ needs the data at the start of cycle 4 but it is not available until the start of cycle 6, a hazard exists.\n\n3.  **Stall Calculation:**\n    - The `EX` stage of $I_2$ must be delayed until cycle 6 to receive the correct forwarded data.\n    - The required delay is the difference between the data-available time (cycle 6) and the unstalled execution time (cycle 4): $6 - 4 = 2$ cycles.\n    - To implement this delay, the pipeline's hazard detection unit must stall $I_2$ in the `ID` stage for 2 cycles, inserting 2 bubbles into the `EX` stage.\n\n**Evaluation of Options:**\n-   **A (0 bubbles):** Incorrect. $I_2$ would read a stale or intermediate value in cycle 4.\n-   **B (1 bubble):** Incorrect. This would delay $I_2$'s `EX` stage to cycle 5. The data is only ready at the end of cycle 5, not the beginning.\n-   **C (2 bubbles):** Correct. This delays $I_2$'s `EX` stage to cycle 6, when the forwarded result from $I_1$ is available.\n-   **D (3 bubbles):** Incorrect. While this would work, it is not the *minimal* policy. Two bubbles are sufficient with forwarding.\n\nTherefore, the minimal correct policy is to insert 2 bubbles.", "answer": "$$\\boxed{C}$$", "id": "3665810"}, {"introduction": "Beyond data dependencies, pipeline performance is also constrained by control hazards arising from branch instructions. This problem examines the concept of the branch delay slot, an architectural technique to mitigate branch penalties. You will analyze how the placement of a No-Operation ($NOP$) instruction in this slot still results in lost performance, and how the penalty changes depending on when the branch outcome is resolved in the pipeline. [@problem_id:3665821]", "problem": "In a classic in-order, single-issue, $5$-stage pipeline with stages Fetch ($IF$), Decode/Register Read ($ID$), Execute ($EX$), Memory ($MEM$), and Writeback ($WB$), consider conditional branches that use a single architectural delay slot of size $1$ (the instruction immediately following the branch is defined to execute regardless of the branch outcome). Assume full forwarding and standard hazard detection for data hazards. The branch decision and target computation occur at the end of $ID$, and on resolution the fetch redirection can take effect for the next cycle. If the compiler cannot fill the delay slot with a useful instruction due to data dependence constraints, it inserts a No Operation ($NOP$) instruction into the delay slot.\n\nUsing the foundational definitions that a pipeline bubble is a cycle in which an issue slot carries no useful work, and that a delay-slot $NOP$ consumes pipeline resources while producing no architectural state change, determine when a bubble still occurs and how many cycles (if any) are effectively lost. Also consider a variant implementation where the branch resolves at the end of $EX$ instead of $ID$.\n\nSelect all correct statements:\n\nA. With branch resolution at the end of $ID$ and a $NOP$ in the single delay slot, exactly one bubble-cycle occurs regardless of whether the branch is taken or not, because the delay slot is occupied by a $NOP$.\n\nB. With full forwarding and hazard detection, the pipeline can overlap the delay-slot $NOP$ with the next useful instruction, eliminating the bubble in the single-issue $5$-stage pipeline.\n\nC. With branch resolution at the end of $ID$, a bubble occurs only when the branch is taken; if the branch is not taken, there is no bubble because the fall-through instruction proceeds without penalty.\n\nD. In the variant where branch resolution is at the end of $EX$ (not $ID$), a taken branch with a single delay-slot $NOP$ incurs two lost cycles: one for the delay slot and one extra bubble due to flushing the misfetched fall-through instruction beyond the delay slot.\n\nE. With perfect dynamic branch prediction, the single delay-slot $NOP$ no longer causes a bubble, because prediction eliminates control penalties and the $NOP$ is skipped.", "solution": "The problem asks us to identify correct statements about pipeline bubbles caused by a branch with a single delay slot filled with a `NOP` instruction. A \"bubble\" is defined as a cycle without useful work. A `NOP` consumes a pipeline slot but performs no useful work, so its execution constitutes a bubble.\n\n**Analysis of Statement A (Resolution in ID):**\n- A branch delay slot architecture mandates that the instruction following the branch (the `NOP` in this case) is *always* executed.\n- With branch resolution at the end of the `ID` stage, the pipeline knows the correct next instruction to fetch (either the branch target or the fall-through instruction) in the cycle immediately after the `NOP` is fetched.\n- No additional stalls are needed. The pipeline executes: Branch, then `NOP`, then the correct next instruction.\n- The single cycle spent executing the `NOP` is a lost cycle of useful work. This loss occurs regardless of whether the branch is taken or not taken.\n- Therefore, statement A is **correct**.\n\n**Analysis of Statement D (Resolution in EX):**\n- With branch resolution delayed until the end of the `EX` stage, the pipeline must speculatively fetch instructions beyond the delay slot. The default is to fetch from the fall-through path.\n- The pipeline fetches: Branch, then `NOP`, then the fall-through instruction (`I_{fall-through}`).\n- By the time the branch instruction resolves at the end of its `EX` stage, `I_{fall-through}` has already been fetched and is in the `ID` stage.\n- If the branch is taken, the speculation was wrong. `I_{fall-through}` must be flushed from the pipeline. The cycle used to fetch and decode this instruction is wasted. This is one lost cycle (a bubble).\n- The `NOP` in the delay slot is also executed, representing another lost cycle.\n- Thus, for a taken branch, there are two lost cycles in total: one for the `NOP` and one for the flushed instruction.\n- Therefore, statement D is **correct**.\n\n**Analysis of Other Statements:**\n- **B:** A single-issue pipeline cannot execute two instructions (e.g., a `NOP` and a useful instruction) in the same cycle. Incorrect.\n- **C:** The `NOP` is always executed, so a bubble occurs even if the branch is not taken. Incorrect.\n- **E:** Branch prediction mitigates penalties from fetching the wrong path but cannot override the architectural requirement to execute the instruction in the delay slot. The `NOP` will still be executed. Incorrect.\n\nThe correct statements are A and D.", "answer": "$$\\boxed{AD}$$", "id": "3665821"}]}