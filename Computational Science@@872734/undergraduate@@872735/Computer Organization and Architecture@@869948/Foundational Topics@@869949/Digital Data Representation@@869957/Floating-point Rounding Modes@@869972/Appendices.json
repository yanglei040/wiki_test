{"hands_on_practices": [{"introduction": "To build a solid understanding of floating-point arithmetic, we begin with a core principle: rounding is not a linear operation. This exercise uses a simplified model of rounding real numbers to integers to clearly illustrate the 'round-to-nearest, ties-to-even' rule, a cornerstone of the IEEE 754 standard. By examining a case where $R(x+y) \\ne R(x)+R(y)$, you will see firsthand why familiar algebraic properties do not always apply in the world of computer arithmetic.", "problem": "A processor pipeline rounds intermediate results to the target format at stage boundaries using the Institute of Electrical and Electronics Engineers (IEEE) 754 rounding mode called round-to-nearest, ties-to-even. Consider rounding to the set of integers, and let $R:\\mathbb{R}\\to\\mathbb{Z}$ denote this rounding function. The formal basis for this mode is: for any real $x$, $R(x)$ is the integer that minimizes $|x-k|$ over all integers $k$; if there are two minimizers (a tie), the even integer is chosen.\n\nUsing only this definition, evaluate the scalar quantity\n$$D \\equiv R(x)+R(y)-R(x+y)$$\nfor the specific inputs $x=0.5$ and $y=0.5$. Provide the exact value of $D$ as a single real number. Do not round your final result.", "solution": "The problem requires the evaluation of the expression $D \\equiv R(x)+R(y)-R(x+y)$ for specific values of $x$ and $y$, where $R:\\mathbb{R}\\to\\mathbb{Z}$ is the rounding function corresponding to the IEEE 754 \"round-to-nearest, ties-to-even\" mode.\n\nThe definition of the rounding function $R(x)$ is given as follows: for any real number $x$, $R(x)$ is the integer $k$ that minimizes the distance $|x-k|$. If a tie occurs, meaning there are two integers that are equidistant from $x$, the even integer of the two is chosen. A tie occurs if and only if $x$ is a half-integer, i.e., $x$ is of the form $n + 0.5$ for some integer $n$.\n\nThe specific inputs are given as $x=0.5$ and $y=0.5$. We must evaluate each term in the expression for $D$ separately.\n\nFirst, we evaluate $R(x) = R(0.5)$.\nThe input is $x=0.5$. This is a half-integer, as it lies exactly halfway between the integers $0$ and $1$. We calculate the distance to these two nearest integers:\nThe distance to $k=0$ is $|0.5 - 0| = 0.5$.\nThe distance to $k=1$ is $|0.5 - 1| = |-0.5| = 0.5$.\nSince the distances are equal, we have a tie. The two integers that minimize the distance are $0$ and $1$. According to the \"ties-to-even\" rule, we must choose the even integer. Between $0$ and $1$, the integer $0$ is even.\nTherefore, $R(0.5) = 0$.\n\nSecond, we evaluate $R(y) = R(0.5)$.\nSince $y=x=0.5$, the calculation is identical to the one above.\nTherefore, $R(0.5) = 0$.\n\nThird, we evaluate $R(x+y)$.\nFirst, we compute the sum $x+y$:\n$$x+y = 0.5 + 0.5 = 1.0$$\nNow we need to evaluate $R(1.0)$. The input is the integer $1$. We seek the integer $k$ that minimizes the distance $|1.0 - k|$.\nIf we choose $k=1$, the distance is $|1.0 - 1| = 0$.\nFor any other integer $k \\neq 1$, the distance $|1.0 - k|$ will be a positive integer, which is strictly greater than $0$. For example, for $k=0$, the distance is $|1.0 - 0|=1$, and for $k=2$, the distance is $|1.0 - 2|=1$.\nThus, there is a unique integer, $k=1$, that minimizes the distance. There is no tie.\nTherefore, $R(1.0) = 1$.\n\nFinally, we substitute these results into the expression for $D$:\n$$D = R(x) + R(y) - R(x+y)$$\n$$D = R(0.5) + R(0.5) - R(1.0)$$\n$$D = 0 + 0 - 1$$\n$$D = -1$$\n\nThe exact value of the scalar quantity $D$ is $-1$.", "answer": "$$\\boxed{-1}$$", "id": "3642547"}, {"introduction": "Building on the basic properties of rounding, we now apply the four primary IEEE 754 rounding modes to a specific floating-point scenario. This practice involves adding a very small quantity to a number, forcing the result to fall between two representable floating-point values. By determining the outcome for round-to-nearest (RN), round-toward-zero (RZ), round-toward-positive-infinity (RU), and round-toward-negative-infinity (RD), you will gain practical skill in applying the precise definition of each mode.", "problem": "Consider a system that conforms to the Institute of Electrical and Electronics Engineers (IEEE) $754$ standard for floating-point arithmetic, using the single-precision binary format (binary32). A normalized binary32 floating-point number is represented by a sign bit, an exponent field of $8$ bits with bias $127$, and a fraction field of $23$ bits forming the significand of the form $(1.f)$, where $f$ is a $23$-bit fractional binary string. Around values in the interval $[1,2)$, successive representable numbers differ by one unit in the last place of the fraction.\n\nLet $x=1.0$ and $y=2^{-25}$. Assume the exact real-valued sum $x+y$ is computed and then rounded once to the nearest representable binary32 number under each of the four IEEE $754$ rounding modes: round to nearest, ties to even ($\\text{RN}$), round toward zero ($\\text{RZ}$), round toward $+\\infty$ ($\\text{RU}$), and round toward $-\\infty$ ($\\text{RD}$).\n\nUsing only the foundational definitions of binary normalized significands and the semantics of the four rounding modes, determine the rounded results of $x+y$ in binary32 under $\\text{RN}$, $\\text{RZ}$, $\\text{RU}$, and $\\text{RD}$. Express your final answer as a row matrix in the order $\\text{RN}$, $\\text{RZ}$, $\\text{RU}$, $\\text{RD}$. No numerical approximation is required; provide exact values.", "solution": "The problem requires determining the results of rounding the sum of two numbers, $x=1.0$ and $y=2^{-25}$, in the IEEE $754$ single-precision (binary32) format under four specified rounding modes.\n\n### Step 1: Extract Givens\n- System: IEEE $754$ standard, single-precision binary format (binary32).\n- Normalized binary32 number representation:\n  - $1$ sign bit.\n  - $8$-bit exponent field with a bias of $127$.\n  - $23$-bit fraction field, denoted as $f$.\n- Significand form for normalized numbers: $(1.f)_2$.\n- In the interval $[1,2)$, the difference between successive representable numbers is one unit in the last place (ULP) of the fraction.\n- Given values: $x=1.0$ and $y=2^{-25}$.\n- Task: Compute the exact sum $z=x+y$ and round it to the nearest representable binary32 number for each of the four rounding modes:\n  - $\\text{RN}$: round to nearest, ties to even.\n  - $\\text{RZ}$: round toward zero.\n  - $\\text{RU}$: round toward $+\\infty$.\n  - $\\text{RD}$: round toward $-\\infty$.\n- Output format: A row matrix of the four results in the order $\\text{RN}$, $\\text{RZ}$, $\\text{RU}$, $\\text{RD}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, as it is based on the well-defined IEEE $754$ standard for floating-point arithmetic, a fundamental topic in computer architecture and numerical analysis. The language is precise and objective. All necessary information (number format, bias, values, rounding modes) is provided, making the problem well-posed and self-contained. There are no contradictions, ambiguities, or scientifically unsound premises. The problem tests a core concept of floating-point arithmetic and is not trivial.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\n\nThe solution proceeds by first calculating the exact real-valued sum and then determining its relationship to the nearest representable binary32 floating-point numbers.\n\n1.  **Analyze the inputs and their exact sum.**\n    The given values are $x=1.0$ and $y=2^{-25}$.\n    The number $x=1.0$ is an exactly representable number in the binary32 format. Its representation is:\n    - Sign bit: $0$ (positive).\n    - Unbiased exponent: $0$, since $1.0 = (1.0)_2 \\times 2^0$.\n    - Biased exponent: $E = 0 + 127 = 127$.\n    - Fraction: $f = 0$, since the significand is $(1.0)_2$.\n\n    The exact real-valued sum is $z = x+y = 1.0 + 2^{-25}$.\n\n2.  **Identify the bracketing representable numbers.**\n    The value of the sum $z$ lies in the interval $[1,2)$. For any value $v$ in this interval, a normalized binary32 representation is of the form $v = (-1)^S \\times (1.f)_2 \\times 2^0$, where $f$ is the $23$-bit fraction. The unit in the last place (ULP) for this range is the value of the least significant bit of the fraction, which is $2^{-23}$.\n    Successive representable numbers in this range are separated by $2^{-23}$.\n\n    The exact sum is $z = 1.0 + 2^{-25}$. This value is not exactly representable because its fractional part, $2^{-25}$, requires more than $23$ bits of precision after the binary point. We need to find the two representable numbers that bracket $z$.\n\n    Let $N_1$ be the largest representable number less than or equal to $z$. This number is obtained by truncating the binary representation of $z$ to $23$ fractional bits.\n    $z = 1.0 + 2^{-25} = (1.\\underbrace{00\\dots0}_{24}1)_2 \\times 2^0$.\n    Truncating after the $23^{rd}$ fractional bit gives the significand $(1.\\underbrace{00\\dots0}_{23})_2$.\n    Thus, $N_1 = (1.0)_2 \\times 2^0 = 1.0$.\n\n    Let $N_2$ be the smallest representable number greater than or equal to $z$. This is the next representable number after $N_1$.\n    $N_2 = N_1 + \\text{ULP} = 1.0 + 2^{-23}$.\n\n    We can confirm that $N_1  z  N_2$:\n    $1.0  1.0 + 2^{-25}  1.0 + 2^{-23}$ since $0  2^{-25}  2^{-23}$.\n\n3.  **Apply the rounding modes.**\n    The choice of rounding depends on the specific mode and, for $\\text{RN}$, on the position of $z$ relative to the midpoint $M$ of the interval $[N_1, N_2]$.\n    The midpoint is $M = \\frac{N_1 + N_2}{2} = \\frac{1.0 + (1.0 + 2^{-23})}{2} = 1.0 + \\frac{2^{-23}}{2} = 1.0 + 2^{-24}$.\n\n    - **Round to Nearest, ties to even ($\\text{RN}$):**\n      We compare $z$ to the midpoint $M$.\n      $z = 1.0 + 2^{-25}$\n      $M = 1.0 + 2^{-24}$\n      Since $2^{-25}  2^{-24}$, we have $z  M$. This means $z$ is closer to $N_1$ than to $N_2$. There is no tie. The rule requires rounding to the nearest representable number, which is $N_1$.\n      Result for $\\text{RN}$: $1.0$.\n\n    - **Round toward Zero ($\\text{RZ}$):**\n      This mode truncates the value towards $0$. For a positive number such as $z$, this means rounding down to the largest representable number that is less than or equal to $z$. This is $N_1$.\n      Result for $\\text{RZ}$: $1.0$.\n\n    - **Round toward $+\\infty$ ($\\text{RU}$):**\n      This mode rounds the value up to the smallest representable number that is greater than or equal to $z$. Since $z$ is not exactly representable, this is $N_2$.\n      Result for $\\text{RU}$: $1.0 + 2^{-23}$.\n\n    - **Round toward $-\\infty$ ($\\text{RD}$):**\n      This mode rounds the value down to the largest representable number that is less than or equal to $z$. For any number, this corresponds to $N_1$.\n      Result for $\\text{RD}$: $1.0$.\n\n4.  **Final Results.**\n    The rounded results for the sum $x+y$ under the four specified rounding modes are:\n    - $\\text{RN}(x+y) = 1.0$\n    - $\\text{RZ}(x+y) = 1.0$\n    - $\\text{RU}(x+y) = 1.0 + 2^{-23}$\n    - $\\text{RD}(x+y) = 1.0$", "answer": "$$\\boxed{\\begin{pmatrix} 1.0  1.0  1.0 + 2^{-23}  1.0 \\end{pmatrix}}$$", "id": "3642267"}, {"introduction": "The consequences of rounding become most apparent in sequences of operations, where small errors can accumulate or lead to unexpected results. This final practice demonstrates how the algebraic identity $(y+c)-c=y$ breaks down in floating-point arithmetic due to intermediate rounding. You will trace how a specific rounding mode (round-toward-positive-infinity) and a value landing exactly on a midpoint between representable numbers cause the final result to deviate from the original, highlighting a crucial pitfall in numerical programming.", "problem": "A processor implements the Institute of Electrical and Electronics Engineers (IEEE) 754 binary32 (single precision) floating-point format. In binary32, a normalized floating-point number has a significand with $23$ explicitly stored fraction bits and an implicit leading $1$, giving a precision of $p=24$ bits. Arithmetic operations produce a real result that is then rounded according to the currently active rounding mode before being stored back in binary32. The available rounding modes include round-to-nearest ties-to-even, round-toward $+\\infty$, round-toward $-\\infty$, and round-toward $0$. The unit in the last place (ULP) at a given magnitude is the spacing between adjacent representable normalized numbers at that magnitude.\n\nA program first computes and stores the variable $y$ as the binary32 representation of the exact real number $1$, using the round-to-nearest ties-to-even mode. Later, due to a runtime change, the rounding mode is set to round-toward $+\\infty$ for all subsequent floating-point operations. In this changed environment, the program evaluates two consecutive operations in binary32:\n$$\nt \\leftarrow y + 2^{-24}, \\quad x \\leftarrow t - 2^{-24},\n$$\nwhere each operation is rounded according to round-toward $+\\infty$ at binary32 precision before the result is used by the next step. Immediately after computing $x$, the program branches on equality $x==y$.\n\nUsing only the core definitions of IEEE 754 binary floating-point representation, precision $p$, and the semantics of rounding modes, derive the exact value of $x - y$ as a single closed-form expression. Give your final answer as a power of two in exact form. No rounding of the final answer is required.", "solution": "The problem will be solved by a step-by-step analysis of the floating-point operations according to the IEEE 754 standard for binary32 format, with the specified rounding modes.\n\nFirst, we establish the value of the variable $y$. The problem states that $y$ is the binary32 representation of the exact real number $1$. The number $1$ is exactly representable in binary32. Its representation in binary scientific notation is $1.0 \\times 2^0$. For the binary32 format (single precision), the significand has a precision of $p=24$ bits ($1$ implicit leading bit and $23$ explicit fraction bits). The value $1$ is represented with a significand of $(1.00...0)_2$ (with $23$ zeros after the binary point) and an exponent of $0$. Since the value is exact, no rounding is necessary. Therefore, the value of $y$ is precisely:\n$$y = 1$$\n\nNext, the rounding mode is changed to round-toward $+\\infty$. We analyze the first computation:\n$$t \\leftarrow y + 2^{-24}$$\nThe exact real value of the sum is:\n$$R_t = y + 2^{-24} = 1 + 2^{-24}$$\nThis result must be rounded to fit into the binary32 format. A normalized binary32 number in the range $[1, 2)$ has the form $(1.f_{1}f_{2}...f_{23})_2 \\times 2^0$. The smallest increment between two such numbers is determined by the last bit of the fraction, $f_{23}$, which corresponds to a value of $2^{-23}$. This is the unit in the last place (ULP) for numbers in this range.\nLet us identify the two representable binary32 numbers that bracket the exact result $R_t$.\nThe number $1$ is representable: $N_1 = 1 = (1.00...0)_2 \\times 2^0$.\nThe next larger representable number is $N_2 = 1 + 2^{-23} = (1.00...1)_2 \\times 2^0$, where the final fraction bit is $1$.\n\nThe exact result $R_t = 1 + 2^{-24}$ lies between these two representable numbers. We can determine its position relative to them. The midpoint between $N_1$ and $N_2$ is:\n$$\\frac{N_1 + N_2}{2} = \\frac{1 + (1 + 2^{-23})}{2} = \\frac{2 + 2^{-23}}{2} = 1 + 2^{-24}$$\nThus, the exact result $R_t$ is exactly the midpoint between two consecutive representable numbers.\n\nThe active rounding mode is round-toward $+\\infty$. This mode dictates that any result that is not exactly representable must be rounded to the smallest representable number that is greater than or equal to the exact result. Since $R_t = 1 + 2^{-24}$ is not representable, it must be rounded up to the next representable value, which is $N_2$.\nTherefore, the value stored in the variable $t$ is:\n$$t = 1 + 2^{-23}$$\n\nNow, we analyze the second computation:\n$$x \\leftarrow t - 2^{-24}$$\nThe rounding mode is still round-toward $+\\infty$. We first find the exact real value of the difference, using the value of $t$ we just determined:\n$$R_x = t - 2^{-24} = (1 + 2^{-23}) - 2^{-24}$$\nTo simplify this expression, we can write $2^{-23}$ as $2 \\times 2^{-24}$:\n$$R_x = 1 + (2 \\times 2^{-24}) - 2^{-24} = 1 + (2-1) \\times 2^{-24} = 1 + 2^{-24}$$\nThe exact result $R_x$ is identical to the exact result $R_t$ from the previous step. It is the midpoint between the representable numbers $1$ and $1 + 2^{-23}$.\n\nWe must round $R_x$ using the round-toward $+\\infty$ mode. Just as before, the result is rounded up to the smallest representable number that is greater than or equal to $R_x$.\nTherefore, the value stored in the variable $x$ is:\n$$x = 1 + 2^{-23}$$\n\nFinally, the problem asks for the exact value of the difference $x-y$. Using the values we have derived for $x$ and $y$:\n$$x - y = (1 + 2^{-23}) - 1 = 2^{-23}$$\nThis result is derived from the mathematical values of $x$ and $y$, not a floating-point subtraction. The result is an exact power of two.", "answer": "$$\\boxed{2^{-23}}$$", "id": "3642467"}]}