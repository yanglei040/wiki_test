{"hands_on_practices": [{"introduction": "The primary reason the octal system remains relevant in computing is its function as a human-readable shorthand for binary. Since $8 = 2^3$, each octal digit corresponds exactly to a three-bit binary sequence, simplifying the representation of long binary strings. This first exercise [@problem_id:1949113] provides practice in this fundamental conversion, which is the cornerstone for understanding how octal is used in debugging, memory dumps, and legacy system analysis.", "problem": "In many computer systems, particularly those with architectures influenced by legacy hardware like the PDP-8, the octal number system is used as a compact representation of binary data. An engineer is analyzing a data packet from such a system. The packet's checksum value is recorded as the octal number $(705)_8$. To perform a validation check, the engineer needs to convert this checksum into its equivalent 9-bit binary representation.\n\nWhich of the following options represents the correct 9-bit binary equivalent of the octal number $(705)_8$?\n\nA. $110000101$\n\nB. $111000110$\n\nC. $101000111$\n\nD. $111000101$\n\nE. $011100010$", "solution": "An octal digit maps to exactly three binary bits because $8=2^{3}$. To convert $(705)_{8}$ to binary, convert each octal digit to its three-bit binary equivalent:\n- $7=2^{2}+2^{1}+2^{0}\\Rightarrow 111$\n- $0\\Rightarrow 000$\n- $5=2^{2}+2^{0}\\Rightarrow 101$\n\nConcatenating these groups yields the 9-bit binary number $111000101$.\n\nVerification by decimal conversion:\n$$(705)_{8}=7\\cdot 8^{2}+0\\cdot 8^{1}+5\\cdot 8^{0}=7\\cdot 64+5=448+5=453,$$\nand\n$$453=2^{8}+2^{7}+2^{6}+2^{2}+2^{0}\\Rightarrow 111000101,$$\nwhich matches the result above.\n\nTherefore, the correct option is D.", "answer": "$$\\boxed{D}$$", "id": "1949113"}, {"introduction": "Once we understand octal as a number system, we can perform arithmetic operations directly within it, just as we do in decimal. This practice [@problem_id:1949119] focuses on addition, a foundational operation for any computer processor. By working through this simple calculation, you will gain a hands-on feel for base-8 arithmetic, especially the concept of carrying, which works similarly to decimal but with a threshold of 8 instead of 10.", "problem": "In a legacy digital control system, a special-purpose 9-bit register holds a configuration parameter. The value of this register is displayed to an operator on a panel that shows the value in the octal (base-8) number system, as each octal digit conveniently represents three bits. Currently, the display shows the value corresponding to $(377)_8$. A system command is executed that increments the value stored in the register by exactly one. What is the new value shown on the octal display? Provide the answer as an integer in its octal representation, without any base subscript.", "solution": "Each octal digit encodes three bits because $8=2^{3}$, so a $9$-bit register is displayed using three octal digits. The current display is $(377)_{8}$. Incrementing by one in base $8$ proceeds with carry propagation from the least significant digit:\n- $7+1=10_{8}$, so write $0$ and carry $1$.\n- Next digit: $7+\\text{carry }1=10_{8}$, so write $0$ and carry $1$.\n- Most significant digit: $3+\\text{carry }1=4$, so write $4$ with no further carry.\n\nTherefore,\n$$\n(377)_{8}+(1)_{8}=(400)_{8}.\n$$\nThis result remains within the $9$-bit range (the maximum three-digit octal value is $(777)_{8}$), so no overflow occurs. The new octal display is $(400)_{8}$, reported without the base subscript as required.", "answer": "$$\\boxed{400}$$", "id": "1949119"}, {"introduction": "Moving beyond basic arithmetic, this exercise explores how octal notation is applied in the realistic context of a processor's Arithmetic Logic Unit (ALU). Computers handle signed numbers using a system called two’s complement and must operate within fixed-width registers, which can lead to errors like overflow. This problem [@problem_id:3662020] challenges you to perform signed addition and detect overflow, bridging the gap between number representation and the practical constraints of hardware design.", "problem": "A fixed-width two’s complement Arithmetic Logic Unit (ALU) performs signed addition on operands represented in octal, where each octal digit encodes exactly three binary bits. Consider a word size of $n=9$ bits, so that each operand is specified by exactly three octal digits that correspond to the full $9$-bit word, and the most significant bit (MSB) is bit index $n-1=8$. The ALU adds two $9$-bit two’s complement operands modulo $2^{9}$ and separately sets an overflow indicator $O$ whenever the true signed mathematical sum cannot be represented in $9$-bit two’s complement.\n\nStarting only from the core definitions of two’s complement representation and the fixed-width addition semantics (addition modulo $2^{n}$), derive a correct signed overflow detection rule in terms of the $9$-bit addition and the MSB behavior. Then apply your derived rule to the specific octal operands $377_8$ and $401_8$, which are to be interpreted as $9$-bit two’s complement integers, added by the $9$-bit ALU.\n\nReport the overflow flag $O$ as a single number, where $O=1$ denotes overflow and $O=0$ denotes no overflow. Your final answer must be just this number. No rounding is required.", "solution": "In fixed-width two’s complement arithmetic on $n$ bits, each $n$-bit pattern $b_{n-1}b_{n-2}\\dots b_{1}b_{0}$ represents the integer\n$$\nx \\;=\\; -b_{n-1}\\,2^{n-1} \\;+\\; \\sum_{k=0}^{n-2} b_k\\,2^k,\n$$\nand the representable range is\n$$\n-2^{n-1} \\;\\leq\\; x \\;\\leq\\; 2^{n-1}-1.\n$$\nFixed-width addition forms the sum modulo $2^{n}$, potentially discarding any carry out of the MSB. Signed overflow occurs precisely when the true mathematical sum lies outside the representable range.\n\nFrom these definitions, a practical overflow detection rule can be derived by examining the MSB behavior during addition. Let $a$ and $b$ be the $n$-bit two’s complement addends with MSBs $a_{n-1}$ and $b_{n-1}$, and let $s$ be the $n$-bit modulo-$2^n$ sum with MSB $s_{n-1}$. Two equivalent characterizations of overflow follow from the representable range constraint:\n\n1. Same-sign to opposite-sign rule: If $a$ and $b$ have the same sign, i.e., $a_{n-1}=b_{n-1}$, but the sum has the opposite sign, i.e., $s_{n-1}\\neq a_{n-1}$, then the true sum is outside the representable range and overflow occurs. Conversely, if $a$ and $b$ have opposite signs, their magnitudes cannot push the sum outside the range, so no overflow occurs.\n\n2. Carry into and out of the MSB: Let $c_{n-1}$ be the carry into the MSB and $c_n$ be the carry out of the MSB in the $n$-bit addition. Then overflow occurs if and only if $c_{n-1}\\neq c_n$.\n\nBoth rules are consequences of the fixed-width modulo-$2^n$ addition law and the signed range boundary at $\\pm 2^{n-1}$.\n\nWe now apply this to the given operands with $n=9$. Each octal digit maps to three binary bits, so three octal digits encode $9$ bits.\n\nConvert $377_8$ and $401_8$ to binary at $9$ bits:\n- $3_8=011_2$, $7_8=111_2$, so\n$$\n377_8 \\;=\\; 011\\,111\\,111_2.\n$$\nThe MSB is $0$, so this is nonnegative. Its unsigned value is\n$$\n011\\,111\\,111_2 \\;=\\; 2^7+2^6+2^5+2^4+2^3+2^2+2^1+2^0 \\;=\\; 255,\n$$\nhence as a two’s complement integer, $377_8$ represents $+255$.\n\n- $4_8=100_2$, $0_8=000_2$, $1_8=001_2$, so\n$$\n401_8 \\;=\\; 100\\,000\\,001_2.\n$$\nThe MSB is $1$, so this is negative. Its two’s complement value can be found as\n$$\n\\text{value} \\;=\\; 100\\,000\\,001_2 - 2^9 \\;=\\; (256+1) - 512 \\;=\\; -255.\n$$\n\nTherefore, the true mathematical sum is\n$$\n(+255) + (-255) \\;=\\; 0,\n$$\nwhich lies within the $9$-bit two’s complement range $[-256,\\,255]$, so by the range definition, no overflow occurs.\n\nFor completeness, we can verify using the carry-based criterion. Add the lower $8$ bits:\n$$\n0111\\,1111_2 \\;+\\; 0000\\,0001_2 \\;=\\; 0000\\,0000_2 \\quad\\text{with carry into MSB } c_{8}=1.\n$$\nNow add the MSBs with this carry:\n$$\na_8 + b_8 + c_8 \\;=\\; 0 + 1 + 1 \\;=\\; 2 \\;=\\; 0 \\text{ with carry out } c_9=1.\n$$\nThus $c_8=c_9=1$, so $c_8\\neq c_9$ is false, confirming no overflow. Equivalently, the sum bits are all zero, $s_{8}=0$, while $a_{8}=0$ and $b_{8}=1$ have opposite signs, which cannot overflow by the same-sign rule.\n\nHence the overflow flag is $O=0$.", "answer": "$$\\boxed{0}$$", "id": "3662020"}]}