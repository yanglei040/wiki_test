{"hands_on_practices": [{"introduction": "To truly grasp how computers handle real numbers, we must learn to speak their language of bits. This first practice [@problem_id:3642294] is a fundamental exercise in decoding: you will take a raw 32-bit pattern and, by applying the rules of the IEEE 754 standard, translate it back into the exact number it represents. This process demystifies the roles of the sign, biased exponent, and fraction fields, forming the bedrock of your understanding of floating-point arithmetic.", "problem": "A $32$-bit word is stored using the Institute of Electrical and Electronics Engineers (IEEE) $754$ binary32 format. The raw bit pattern, written from most significant bit to least significant bit, is\n$$11000010001010100000000000000000.$$\nUsing only the canonical layout and semantics of IEEE $754$ binary32 as your starting point, decode this word. Derive, from first principles, the field decomposition, the category of the value (normal, subnormal, $0$, $+\\infty$, $-\\infty$, or Not a Number (NaN)), and the exact real number it represents if it is finite. Report the category in your reasoning, but for your final numerical result, express the decoded real value as an exact rational number in lowest terms. Do not round. If the value is non-finite, then your final result should be the appropriate symbolic value $+\\infty$, $-\\infty$, or $\\mathrm{NaN}$.", "solution": "The IEEE $754$ standard for $32$-bit binary floating-point numbers (binary32) defines a specific layout for the bits within a $32$-bit word. The word is partitioned into three fields, read from the most significant bit (MSB) to the least significant bit (LSB):\n1.  Sign ($S$): $1$ bit (bit $31$).\n2.  Exponent ($E$): $8$ bits (bits $30$ through $23$).\n3.  Fraction ($F$): $23$ bits (bits $22$ through $0$).\n\nThe given $32$-bit word is:\n$$\n11000010001010100000000000000000\n$$\nWe partition this bit pattern according to the binary32 format:\n$$\n\\underset{S}{\\underbrace{1}} \\quad \\underset{E}{\\underbrace{10000100}} \\quad \\underset{F}{\\underbrace{01010100000000000000000}}\n$$\nFrom this decomposition, we extract the values for the three fields:\n-   The sign bit $S$ is the MSB, which is $1$.\n-   The exponent field $E$ consists of the $8$ bits `10000100`. We convert this binary integer to its decimal equivalent:\n    $$\n    E = (10000100)_2 = 1 \\cdot 2^7 + 0 \\cdot 2^6 + 0 \\cdot 2^5 + 0 \\cdot 2^4 + 0 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 0 \\cdot 2^0 = 128 + 4 = 132.\n    $$\n-   The fraction field $F$ consists of the remaining $23$ bits: `01010100000000000000000`.\n\nNext, we determine the category of the floating-point number. This is dictated by the value of the exponent field $E$. For the binary32 format, the exponent bias is $B = 2^{8-1} - 1 = 127$. The special values for $E$ are $0$ and $255$.\n-   If $E = 255$, the number is either an infinity or a NaN (Not a Number).\n-   If $E = 0$, the number is either zero or a subnormal number.\n-   If $0 < E < 255$, the number is a normal number.\n\nIn this case, the exponent field value is $E=132$. Since $0 < 132 < 255$, the number is a **normal** number.\n\nFor a normal number, the value $V$ it represents is given by the formula:\n$$\nV = (-1)^S \\times 2^{E-B} \\times M\n$$\nwhere $M$ is the significand, which is constructed from the fraction field $F$ by prepending an implicit leading bit of $1$. That is, $M = (1.F)_2$.\n\nLet us compute the components of this formula.\n-   The sign is determined by $S=1$, so $(-1)^S = (-1)^1 = -1$.\n-   The true exponent is $e = E - B = 132 - 127 = 5$.\n-   The significand $M$ is formed from the fraction field $F = (010101000...)_2$. The trailing zeros do not affect the value.\n    $$\n    M = (1.F)_2 = (1.010101)_2\n    $$\n    We convert this binary representation to a rational number:\n    $$\n    M = 1 \\cdot 2^0 + 0 \\cdot 2^{-1} + 1 \\cdot 2^{-2} + 0 \\cdot 2^{-3} + 1 \\cdot 2^{-4} + 0 \\cdot 2^{-5} + 1 \\cdot 2^{-6}\n    $$\n    $$\n    M = 1 + \\frac{1}{2^2} + \\frac{1}{2^4} + \\frac{1}{2^6} = 1 + \\frac{1}{4} + \\frac{1}{16} + \\frac{1}{64}\n    $$\n    To sum these fractions, we find a common denominator, which is $64$:\n    $$\n    M = \\frac{64}{64} + \\frac{16}{64} + \\frac{4}{64} + \\frac{1}{64} = \\frac{64+16+4+1}{64} = \\frac{85}{64}\n    $$\n\nFinally, we substitute these components back into the formula for $V$:\n$$\nV = (-1) \\times 2^5 \\times \\frac{85}{64}\n$$\nSince $2^5 = 32$, we have:\n$$\nV = -32 \\times \\frac{85}{64} = - \\frac{32 \\times 85}{64}\n$$\nWe can simplify the fraction by canceling the factor of $32$:\n$$\nV = - \\frac{85}{2}\n$$\nThe numbers $85$ and $2$ are coprime ($85 = 5 \\times 17$), so this fraction is in lowest terms. The exact real number represented by the given bit pattern is $-\\frac{85}{2}$.", "answer": "$$\n\\boxed{-\\frac{85}{2}}\n$$", "id": "3642294"}, {"introduction": "While computers can represent a vast range of numbers, their precision is finite, which means not all decimal values can be stored exactly. This exercise [@problem_id:3642283] explores a critical consequence of this limitation by having you trace the subtraction of two very close numbers. You will see firsthand how small, initial representation errors can be amplified into a dramatic loss of significant digits, a phenomenon known as catastrophic cancellation and a crucial lesson for anyone writing numerical software.", "problem": "Consider arithmetic performed in the Institute of Electrical and Electronics Engineers (IEEE $754$) Standard for Floating-Point Arithmetic, specifically the binary$32$ format with one sign bit, eight exponent bits with bias $127$, and $23$ fraction bits with an implicit leading $1$ for normalized numbers. Two decimal inputs $x = 123456.78$ and $y = 123456.77$ are first converted to binary$32$ using round-to-nearest, ties-to-even, then the subtraction $x - y$ is performed with correct rounding to binary$32$ under the same rule. Starting only from the structural definition of binary$32$ and normalization, determine the exact decimal value that the hardware returns for the subtraction.\n\nExpress the final answer as an exact decimal number. No unit is required.", "solution": "The problem requires us to simulate the process of floating-point conversion and subtraction as it would be performed by hardware adhering to the IEEE $754$ binary$32$ standard.\n\n**1. Determine the relevant floating-point precision (ULP)**\n\nFirst, we must determine the magnitude of the input numbers, $x = 123456.78$ and $y = 123456.77$. We can find the bracketing powers of $2$:\n$$2^{16} = 65536$$\n$$2^{17} = 131072$$\nSince $2^{16} < x, y < 2^{17}$, any normalized binary$32$ representation of these numbers will have an unbiased exponent of $E=16$.\nThe value of a normalized number in this format is given by $v = (-1)^s \\times (1.f)_2 \\times 2^E$, where $s$ is the sign bit and $f$ is the $23$-bit fraction. The biased exponent stored in the $8$-bit exponent field is $e = E + 127 = 16 + 127 = 143$.\n\nThe precision of numbers in this range is determined by the value of the least significant bit of the significand. This is known as the Unit in the Last Place (ULP).\n$$\\text{ULP} = 2^E \\times 2^{-23} = 2^{16} \\times 2^{-23} = 2^{-7}$$\nAs a decimal, the ULP is:\n$$\\text{ULP} = \\frac{1}{128} = 0.0078125$$\nEvery real number in the range $[2^{16}, 2^{17})$ is mapped to the nearest multiple of this ULP value.\n\n**2. Convert input `x` to binary32 format**\n\nTo find the binary$32$ representation of $x = 123456.78$, we divide $x$ by the ULP to find which multiple it is closest to.\n$$\\frac{x}{\\text{ULP}} = \\frac{123456.78}{0.0078125} = 123456.78 \\times 128 = 15802467.84$$\nThis number represents the significand scaled by $2^{23}$. According to the \"round-to-nearest, ties-to-even\" rule, we must round this to the nearest integer. Since the fractional part $0.84$ is greater than $0.5$, we round up.\n$$N_x = \\text{round}(15802467.84) = 15802468$$\nThe stored value for $x$, which we call $x_{b32}$, is this integer multiple of the ULP.\n$$x_{b32} = N_x \\times \\text{ULP} = 15802468 \\times 0.0078125 = 123456.78125$$\n\n**3. Convert input `y` to binary32 format**\n\nWe repeat the same process for $y = 123456.77$.\n$$\\frac{y}{\\text{ULP}} = \\frac{123456.77}{0.0078125} = 123456.77 \\times 128 = 15802466.56$$\nThe fractional part $0.56$ is greater than $0.5$, so we round up. Note that this is not a tie, so the \"ties-to-even\" part of the rule is not invoked.\n$$N_y = \\text{round}(15802466.56) = 15802467$$\nThe stored value for $y$, which we call $y_{b32}$, is:\n$$y_{b32} = N_y \\times \\text{ULP} = 15802467 \\times 0.0078125 = 123456.7734375$$\n\n**4. Perform the subtraction and determine the final result**\n\nThe hardware performs the subtraction on the stored representations $x_{b32}$ and $y_{b32}$. The exact result of this subtraction is:\n$$d = x_{b32} - y_{b32} = 123456.78125 - 123456.7734375 = 0.0078125$$\nThe final step is to ensure this result $d$ is correctly stored in a binary$32$ register, which may involve another rounding step. We must check if $d$ is exactly representable.\n$$d = 0.0078125 = \\frac{1}{128} = 2^{-7}$$\nThis value can be written in normalized floating-point form as $1.0_2 \\times 2^{-7}$.\n- The sign is positive ($s=0$).\n- The significand is $1.0_2$, so the fraction part $f$ is all zeros.\n- The unbiased exponent is $E = -7$.\nThis exponent is within the valid range for normalized binary$32$ numbers, which is $[-126, 127]$. Since the value is a power of two, it is exactly representable in binary floating-point format. Therefore, no rounding is required for the final result.\n\nThe value returned by the hardware is the exact result of the subtraction of the stored values.", "answer": "$$\n\\boxed{0.0078125}\n$$", "id": "3642283"}, {"introduction": "The floating-point number system has a special mechanism for handling values that are exceptionally close to zero, known as subnormal numbers. This final practice [@problem_id:3642263] challenges you to explore this \"last frontier\" of floating-point representation. By analyzing a subtraction that results in a tiny value, you will contrast the \"gradual underflow\" approach, which preserves precision, with the faster \"flush-to-zero\" method, revealing important design trade-offs between performance and accuracy.", "problem": "Consider arithmetic compliant with the Institute of Electrical and Electronics Engineers (IEEE) Standard for Floating-Point Arithmetic (IEEE 754) in the binary32 format (single precision), which uses $1$ sign bit, $8$ exponent bits, and $23$ fraction bits with an implicit leading $1$ for normalized numbers. In this format, subnormal (denormal) numbers occur when the exponent field is all zeros; they have no implicit leading $1$, and their spacing is uniform. The smallest positive subnormal magnitude is $2^{-149}$, and the next larger representable (subnormal or normal) value is obtained by adding $2^{-149}$.\n\nA processor supports two underflow handling modes for the operation $x = y - z$ on real operands $y$ and $z$:\n- Gradual underflow: the exact real difference is rounded to the nearest representable binary32 value using round-to-nearest, ties-to-even.\n- Flush-to-zero: any nonzero subnormal result is replaced by $0$, while normal rounding is otherwise used.\n\nAssume $y > z > 0$ are real numbers such that the exact difference is\n$$d = y - z = \\frac{101}{200}\\cdot 2^{-149},$$\nwith $|d| < 2^{-149}$. Define the scalar quantity\n$$R = \\frac{\\text{absolute error under flush-to-zero}}{\\text{absolute error under gradual underflow}},$$\nwhere “absolute error” means the absolute value of the difference between the computed result and the exact real result $d$.\n\nUsing only the foundational properties of IEEE 754 binary32 (format structure, subnormal spacing, and round-to-nearest ties-to-even), determine the exact value of $R$ as a single real number. No unit is required. Do not round; provide your answer in exact form.", "solution": "The objective is to compute the ratio $R = \\frac{E_{flush}}{E_{grad}}$, where $E_{flush}$ and $E_{grad}$ are the absolute errors for the flush-to-zero and gradual underflow modes, respectively. The exact difference is given as $d = \\frac{101}{200} \\cdot 2^{-149}$.\n\nFirst, we analyze the set of representable `binary32` numbers near zero. The subnormal numbers are integer multiples of the smallest positive subnormal value, $s_{min} = 2^{-149}$. The positive representable numbers near zero are $\\{0, 1 \\cdot 2^{-149}, 2 \\cdot 2^{-149}, 3 \\cdot 2^{-149}, \\dots\\}$.\n\nThe exact result is $d = \\frac{101}{200} \\cdot 2^{-149} = 0.505 \\cdot 2^{-149}$. This value is not an integer multiple of $2^{-149}$, so it is not a representable `binary32` number. It must be rounded.\n\n**1. Calculation for Gradual Underflow**\n\nUnder gradual underflow, the exact result $d$ is rounded to the nearest representable number. The rule specified is round-to-nearest, ties-to-even. The value $d$ lies between two consecutive representable numbers: $0$ and $s_{min} = 1 \\cdot 2^{-149}$.\n\nTo determine the nearest representable number, we compare $d$ to the midpoint between $0$ and $s_{min}$.\nThe midpoint $m$ is:\n$$m = \\frac{0 + s_{min}}{2} = \\frac{1}{2} s_{min} = \\frac{1}{2} \\cdot 2^{-149} = 0.5 \\cdot 2^{-149}$$\n\nWe compare $d$ with $m$:\n$$d = 0.505 \\cdot 2^{-149}$$\n$$m = 0.5 \\cdot 2^{-149}$$\nSince $0.505 > 0.5$, we have $d > m$. This means $d$ is closer to $s_{min}$ than it is to $0$. As this is not a tie, the \"ties-to-even\" part of the rule is irrelevant. The result is rounded to the nearest value, which is $s_{min}$.\n\nThe computed result under gradual underflow is $x_{grad}$:\n$$x_{grad} = s_{min} = 2^{-149}$$\n\nThe absolute error under gradual underflow, $E_{grad}$, is the absolute difference between the computed result and the exact result:\n$$E_{grad} = |x_{grad} - d| = |2^{-149} - \\frac{101}{200} \\cdot 2^{-149}|$$\nFactoring out $2^{-149}$:\n$$E_{grad} = |1 - \\frac{101}{200}| \\cdot 2^{-149} = |\\frac{200 - 101}{200}| \\cdot 2^{-149} = \\frac{99}{200} \\cdot 2^{-149}$$\n\n**2. Calculation for Flush-to-Zero**\n\nIn the flush-to-zero mode, any result that would be a nonzero subnormal number is forced to zero. The exact result $d = 0.505 \\cdot 2^{-149}$ is in the subnormal range, as its magnitude is less than the smallest positive normalized number ($2^{-126}$) but greater than zero. In flush-to-zero mode, such a result is replaced by zero.\n\nThe computed result under flush-to-zero is $x_{flush}$:\n$$x_{flush} = 0$$\n\nThe absolute error under flush-to-zero, $E_{flush}$, is:\n$$E_{flush} = |x_{flush} - d| = |0 - \\frac{101}{200} \\cdot 2^{-149}|$$\n$$E_{flush} = \\frac{101}{200} \\cdot 2^{-149}$$\n\n**3. Calculation of the Ratio R**\n\nThe ratio $R$ is defined as the quotient of the two absolute errors:\n$$R = \\frac{E_{flush}}{E_{grad}}$$\nSubstituting the expressions we derived:\n$$R = \\frac{\\frac{101}{200} \\cdot 2^{-149}}{\\frac{99}{200} \\cdot 2^{-149}}$$\nThe common factor of $\\frac{1}{200} \\cdot 2^{-149}$ in the numerator and denominator cancels out.\n$$R = \\frac{101}{99}$$\nThis is the final exact value as requested.", "answer": "$$\\boxed{\\frac{101}{99}}$$", "id": "3642263"}]}