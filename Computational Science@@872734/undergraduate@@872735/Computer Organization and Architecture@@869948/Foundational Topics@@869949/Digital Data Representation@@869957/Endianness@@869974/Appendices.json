{"hands_on_practices": [{"introduction": "Understanding endianness begins with being able to interpret raw memory. This first exercise places you in the role of a systems analyst examining a memory hexdump. By applying the fundamental definitions of little-endian and big-endian storage to a structured data pattern, you will deduce the system's architecture and reconstruct the original data, a core skill in low-level debugging and reverse engineering. [@problem_id:3639638]", "problem": "An array of unsigned 32-bit integers (`uint32_t`) is stored contiguously in memory starting at base address `0x2000`. The hardware endianness is unknown. The elements of the array form an arithmetic progression $\\{a_k\\}$ with $a_k = a_0 + k\\,d$ for $k \\in \\{0,1,2,3,4\\}$, where $a_0$ and $d$ are nonnegative integers, and there is no wraparound within 32 bits on this range. The common difference satisfies $0  d  256$, and there are no carries from lower to higher bytes across these five elements.\n\nYou are given a linear hexdump of the first 20 bytes (five words) at addresses `0x2000` through `0x2013`, listed in order of increasing address. The bytes are:\n`40 30 20 10 50 30 20 10 60 30 20 10 70 30 20 10 80 30 20 10`.\n\nUsing only the core definition of endianness (in little-endian, the least significant byte of a word resides at the lowest address; in big-endian, the most significant byte resides at the lowest address) and the definition of an arithmetic progression, determine the endianness and reconstruct $a_0$ and $d$. Report the common difference $d$ as a base-10 integer. No rounding is required.", "solution": "The problem requires us to determine the endianness of a computer system and find the common difference $d$ of an arithmetic progression stored in memory.\n\nFirst, let's formalize the given information.\nAn array of five 32-bit unsigned integers (`uint32_t`), which we denote as $\\{a_k\\}_{k=0}^4$, is stored in memory starting at address `0x2000`. A memory dump of the first 20 bytes is provided:\n`40 30 20 10 50 30 20 10 60 30 20 10 70 30 20 10 80 30 20 10`.\n\nThe sequence is an arithmetic progression defined by $a_k = a_0 + k\\,d$ for $k \\in \\{0, 1, 2, 3, 4\\}$.\nThe constraints are:\n1. $a_0$ and $d$ are nonnegative integers.\n2. The common difference $d$ satisfies $0  d  256$. In hexadecimal, this is $0  d  \\text{0x100}$.\n3. There are no carries from lower to higher bytes when calculating $a_{k+1} = a_k + d$ for $k \\in \\{0, 1, 2, 3\\}$. Given that $d$ is a single-byte value, this implies that for each step, the addition of $d$ to the least significant byte of $a_k$ does not produce a result greater than or equal to $256$ (i.e., `0x100`).\n\nThe memory dump corresponds to five consecutive 32-bit words. Let's segment the byte stream by word:\n- Word 0 ($a_0$): bytes at `0x2000`-`0x2003` are `40`, `30`, `20`, `10`.\n- Word 1 ($a_1$): bytes at `0x2004`-`0x2007` are `50`, `30`, `20`, `10`.\n- Word 2 ($a_2$): bytes at `0x2008`-`0x200B` are `60`, `30`, `20`, `10`.\n- Word 3 ($a_3$): bytes at `0x200C`-`0x200F` are `70`, `30`, `20`, `10`.\n- Word 4 ($a_4$): bytes at `0x2010`-`0x2013` are `80`, `30`, `20`, `10`.\n\nWe must test two hypotheses for the system's endianness.\n\n**Hypothesis 1: The system is Big-Endian**\nIn a big-endian architecture, the most significant byte (MSB) of a multi-byte word is stored at the lowest memory address. The bytes are stored in order from most significant to least significant.\n\nLet's construct the integer values for $\\{a_k\\}$ under this assumption:\n- $a_0 = \\text{0x40302010}$\n- $a_1 = \\text{0x50302010}$\n- $a_2 = \\text{0x60302010}$\n- $a_3 = \\text{0x70302010}$\n- $a_4 = \\text{0x80302010}$\n\nNow, we check if this sequence forms an arithmetic progression by calculating the difference between consecutive terms.\n$d = a_1 - a_0 = \\text{0x50302010} - \\text{0x40302010} = \\text{0x10000000}$\nLet's verify this common difference for the other elements:\n$a_2 - a_1 = \\text{0x60302010} - \\text{0x50302010} = \\text{0x10000000}$\n$a_3 - a_2 = \\text{0x70302010} - \\text{0x60302010} = \\text{0x10000000}$\n$a_4 - a_3 = \\text{0x80302010} - \\text{0x70302010} = \\text{0x10000000}$\nThe sequence is indeed an arithmetic progression with a common difference $d = \\text{0x10000000}$.\n\nNext, we check this value of $d$ against the problem's constraint $0  d  256$.\nThe value of $d$ in base-10 is $d = 16^7 = 268,435,456$.\nThis value, $268,435,456$, is not in the required range $(0, 256)$.\nTherefore, the big-endian hypothesis is incorrect.\n\n**Hypothesis 2: The system is Little-Endian**\nIn a little-endian architecture, the least significant byte (LSB) of a multi-byte word is stored at the lowest memory address. To form the integer as it is conventionally written (MSB first), the bytes from memory must be read in reverse order.\n\nLet's construct the integer values for $\\{a_k\\}$ under this assumption:\n- For $a_0$, the bytes are `40`, `30`, `20`, `10`. Reversing them gives `10`, `20`, `30`, `40`. So, $a_0 = \\text{0x10203040}$.\n- For $a_1$, the bytes are `50`, `30`, `20`, `10`. Reversing them gives `10`, `20`, `30`, `50`. So, $a_1 = \\text{0x10203050}$.\n- Following this pattern for all words:\n  - $a_0 = \\text{0x10203040}$\n  - $a_1 = \\text{0x10203050}$\n  - $a_2 = \\text{0x10203060}$\n  - $a_3 = \\text{0x10203070}$\n  - $a_4 = \\text{0x10203080}$\n\nNow, we check if this sequence is an arithmetic progression.\n$d = a_1 - a_0 = \\text{0x10203050} - \\text{0x10203040} = \\text{0x10}$\nLet's verify this common difference for the other elements:\n$a_2 - a_1 = \\text{0x10203060} - \\text{0x10203050} = \\text{0x10}$\n$a_3 - a_2 = \\text{0x10203070} - \\text{0x10203060} = \\text{0x10}$\n$a_4 - a_3 = \\text{0x10203080} - \\text{0x10203070} = \\text{0x10}$\nThe sequence is an arithmetic progression with a common difference $d = \\text{0x10}$.\n\nNext, we check this value of $d$ against the problem's constraints.\nFirst, $0  d  256$.\nThe value of $d$ in base-10 is $d = 16^1 = 16$.\nThe condition $0  16  256$ is satisfied.\n\nSecond, we must verify the \"no carries\" constraint. This means adding $d$ does not cause a carry from a lower byte to a higher one.\nLet $a_k = B_{k,3}2^{24} + B_{k,2}2^{16} + B_{k,1}2^8 + B_{k,0}$ be the byte representation of $a_k$.\nThe operation is $a_{k+1} = a_k + d$. Since $d = \\text{0x10}$ is smaller than $\\text{0x100}$ (or $256$), the addition only affects the lowest byte, $B_{k,0}$, unless a carry is generated. The constraint states no carry occurs.\n- For $k=0$: $a_0 = \\text{0x10203040}$. The LSB is $B_{0,0} = \\text{0x40}$.\n  $B_{0,0} + d = \\text{0x40} + \\text{0x10} = \\text{0x50}$. Since $\\text{0x50}  \\text{0x100}$, there is no carry.\n  $a_1 = a_0 + d = \\text{0x10203040} + \\text{0x10} = \\text{0x10203050}$. This matches our value for $a_1$.\n- For $k=1$: $a_1 = \\text{0x10203050}$. The LSB is $B_{1,0} = \\text{0x50}$.\n  $B_{1,0} + d = \\text{0x50} + \\text{0x10} = \\text{0x60}$. Since $\\text{0x60}  \\text{0x100}$, there is no carry.\n  $a_2 = a_1 + d = \\text{0x10203050} + \\text{0x10} = \\text{0x10203060}$. This matches our value for $a_2$.\n- For $k=2$: $a_2 = \\text{0x10203060}$. The LSB is $B_{2,0} = \\text{0x60}$.\n  $B_{2,0} + d = \\text{0x60} + \\text{0x10} = \\text{0x70}$. Since $\\text{0x70}  \\text{0x100}$, there is no carry.\n  $a_3 = a_2 + d = \\text{0x10203060} + \\text{0x10} = \\text{0x10203070}$. This matches our value for $a_3$.\n- For $k=3$: $a_3 = \\text{0x10203070}$. The LSB is $B_{3,0} = \\text{0x70}$.\n  $B_{3,0} + d = \\text{0x70} + \\text{0x10} = \\text{0x80}$. Since $\\text{0x80}  \\text{0x100}$, there is no carry.\n  $a_4 = a_3 + d = \\text{0x10203070} + \\text{0x10} = \\text{0x10203080}$. This matches our value for $a_4$.\n\nAll constraints are satisfied under the little-endian hypothesis.\nThe endianness is little-endian.\nThe initial term of the progression is $a_0 = \\text{0x10203040}$.\nThe common difference is $d = \\text{0x10}$, which is $16$ in base-10.\n\nThe problem asks for the common difference $d$ as a base-10 integer.\n$d = 16$.", "answer": "$$\\boxed{16}$$", "id": "3639638"}, {"introduction": "Endianness issues frequently surface in network programming, where data must be serialized into a standard format. This practice problem simulates a common and subtle bug where redundant byte-swapping occurs, leading to data corruption. By tracing the data transformations through a multi-layer communication pipeline, you will design a diagnostic test to pinpoint this \"double-swap\" error, a vital skill for robust network application development. [@problem_id:3639618]", "problem": "A little-endian host $A$ communicates with a little-endian host $B$ using a Remote Procedure Call (RPC) layer that packs 16-bit fields onto the wire in big-endian order and unpacks by copying the raw bytes from the wire into host memory without performing any conversion. The developer of the application mistakenly applies Host-To-Network-Short (HTONS) on the send side before passing data to the RPC packer and applies Network-To-Host-Short (NTOHS) on the receive side after the RPC has unpacked the bytes. The wire protocol mandates big-endian ordering for all 16-bit fields.\n\nYou are asked to design a debugging approach that uses the probe values $p_{1} = 0x00FF$ and $p_{2} = 0xFF00$ to detect the presence of the double-swap bug described above. Let $V(p)$ denote the 16-bit unsigned integer value ultimately delivered to the application on host $B$ after the entire pipeline consisting of the developer’s conversions and the RPC packer/unpacker executes. Define the diagnostic scalar\n$$\nD \\equiv V(p_{1}) - V(p_{2}),\n$$\ninterpreting both $V(p_{1})$ and $V(p_{2})$ as unsigned 16-bit integers and performing subtraction in standard integer arithmetic on the host (not modulo $2^{16}$).\n\nStarting only from the core definitions of big-endian and little-endian byte ordering and the action of a single-byte swap on a 16-bit value, derive $V(p)$ for this pipeline and compute the diagnostic $D$ numerically for the given probes. Express the final diagnostic $D$ as an unsigned decimal integer. No rounding is required.", "solution": "### Derivation of the Transformation V(p)\n\nLet us define a generic 16-bit unsigned integer $p$ by its most significant byte (MSB), $B_H$, and its least significant byte (LSB), $B_L$. The value of $p$ is given by $p = 256 \\cdot B_H + B_L$. We represent this in hexadecimal as $p = 0x B_H B_L$.\n\nA **big-endian** system stores this value in memory with the MSB at the lower address, followed by the LSB: $[B_H, B_L]$.\nA **little-endian** system stores the LSB at the lower address, followed by the MSB: $[B_L, B_H]$.\n\nThe core operation of `HTONS` and `NTOHS` on a little-endian host is a byte swap. Let's define the swap operator $S(p)$ as:\n$$\nS(p) = S(256 \\cdot B_H + B_L) = 256 \\cdot B_L + B_H\n$$\nIn hexadecimal notation, $S(0x B_H B_L) = 0x B_L B_H$.\n\nWe now trace the value $p$ through the entire pipeline from host A to host B.\n\n1.  **Start at Host A (Little-Endian)**: The application starts with the 16-bit value $p = 0x B_H B_L$.\n\n2.  **Developer's `HTONS` Call**: The developer mistakenly calls `HTONS` on $p$. Since host A is little-endian, `HTONS` performs a byte swap. The value passed to the RPC layer is:\n    $$\n    p' = \\text{HTONS}(p) = S(p) = 0x B_L B_H\n    $$\n\n3.  **RPC Packer on Host A**: The RPC layer receives the value $p' = 0x B_L B_H$. It is tasked with packing this value onto the wire in big-endian order. For the value $p'$, its MSB is $B_L$ and its LSB is $B_H$. Big-endian wire format requires sending the MSB first, then the LSB. Therefore, the byte sequence sent on the wire is:\n    $$\n    \\text{Wire Bytes} = [B_L, B_H]\n    $$\n\n4.  **RPC Unpacker on Host B**: The RPC unpacker receives the byte stream $[B_L, B_H]$. According to the problem, it \"unpacks by copying the raw bytes from the wire into host memory without performing any conversion.\" The byte $B_L$ is written to a memory address $m$, and the byte $B_H$ is written to the next address $m+1$. The memory on host B now contains the byte sequence $[B_L, B_H]$.\n\n5.  **Data Interpretation on Host B (Little-Endian)**: The RPC layer passes the value from this memory location to the application. Since host B is little-endian, its CPU interprets the memory sequence $[B_L, B_H]$ (LSB at lower address, MSB at higher address) as the value:\n    $$\n    p'' = 256 \\cdot B_H + B_L = p\n    $$\n    So, the value received by the developer's application code (before its own `NTOHS` call) is the original value $p$. The combination of the developer's `HTONS` on the send side and the RPC layer's behavior has resulted in transmitting $p$ unchanged to the application layer on host B.\n\n6.  **Developer's `NTOHS` Call**: The application on host B receives the value $p'' = p$ and calls `NTOHS` on it. Since host B is little-endian, `NTOHS` performs a byte swap.\n    $$\n    V(p) = \\text{NTOHS}(p'') = \\text{NTOHS}(p) = S(p)\n    $$\n\nThus, the net effect of the entire pipeline is a single byte swap: $V(p) = S(p) = 0x B_L B_H$.\n\n### Calculation of the Diagnostic Scalar D\n\nNow we apply this transformation to the probe values $p_1$ and $p_2$.\n\nFor $p_{1} = 0x00FF$:\nThe high byte is $B_H = 0x00$ and the low byte is $B_L = 0xFF$.\nThe final value on host B is:\n$$\nV(p_{1}) = S(0x00FF) = 0xFF00\n$$\nAs an unsigned decimal integer, $V(p_{1}) = 255 \\times 256 + 0 = 65280$.\n\nFor $p_{2} = 0xFF00$:\nThe high byte is $B_H = 0xFF$ and the low byte is $B_L = 0x00$.\nThe final value on host B is:\n$$\nV(p_{2}) = S(0xFF00) = 0x00FF\n$$\nAs an unsigned decimal integer, $V(p_{2}) = 0 \\times 256 + 255 = 255$.\n\nFinally, we compute the diagnostic scalar $D$ using standard integer arithmetic:\n$$\nD = V(p_{1}) - V(p_{2}) = 65280 - 255\n$$\n$$\nD = 65025\n$$\nThe value of the diagnostic scalar $D$ is $65025$. This non-zero result successfully detects the presence of the data marshalling anomaly.", "answer": "$$\n\\boxed{65025}\n$$", "id": "3639618"}, {"introduction": "The same sequence of bytes can have entirely different meanings depending on a system's endianness and its interpretation of the data type. This final exercise challenges you to design a minimal set of test vectors to remotely identify a system's configuration from a set of four possibilities, including integer and IEEE-754 floating-point interpretations. This practice sharpens your ability to leverage the unique binary patterns of different data types, a key technique in protocol design and interoperability testing. [@problem_id:3639653]", "problem": "A remote instrument accepts exactly four bytes delivered in ascending memory address order and returns a single decimal value. Internally, the instrument interprets the received 32-bit word under one of four hypotheses: big-endian unsigned integer, little-endian unsigned integer, big-endian Institute of Electrical and Electronics Engineers (IEEE) Standard for Floating-Point Arithmetic (IEEE-754) single-precision floating point, or little-endian IEEE-754 single-precision floating point. The interpretation is fixed but unknown. Measurement constraints are as follows: when the internal interpretation is floating point and the computed value is not a finite real number (for example, $+\\infty$, $-\\infty$, or a Not-a-Number), the instrument returns the decimal number $0$; otherwise it returns the exact decimal value of the interpreted result. When the internal interpretation is integer, the instrument returns the exact unsigned decimal value.\n\nYou must choose test vectors as four-byte sequences whose byte patterns, when assembled into a 32-bit word, make the outputs under the four hypotheses provably distinguishable using only fundamental definitions of endianness and IEEE-754 single-precision encoding. Use the following candidate test vectors:\n- $v_1$: bytes $\\{0x7F,\\,0x80,\\,0x00,\\,0x00\\}$ in ascending address order,\n- $v_2$: bytes $\\{0x00,\\,0x00,\\,0x00,\\,0x01\\}$ in ascending address order.\n\nFundamental bases you may use:\n- Endianness definitions: if bytes $\\{B_0,\\,B_1,\\,B_2,\\,B_3\\}$ are laid out from lowest to highest address, then the big-endian 32-bit word is $X_{\\mathrm{BE}} = B_0 \\cdot 2^{24} + B_1 \\cdot 2^{16} + B_2 \\cdot 2^{8} + B_3$, and the little-endian 32-bit word is $X_{\\mathrm{LE}} = B_0 + B_1 \\cdot 2^{8} + B_2 \\cdot 2^{16} + B_3 \\cdot 2^{24}$.\n- IEEE-754 single-precision layout: given a 32-bit word $X$, the sign bit is $s = (X \\gg 31) \\,\\\\, 1$, the exponent field is $e = (X \\gg 23) \\,\\\\, 0xFF$, and the fraction field is $f = X \\,\\\\, 0x7FFFFF$. The value is\n  - if $e = 255$ and $f = 0$, then $(-1)^s \\cdot \\infty$,\n  - if $e = 0$ and $f \\neq 0$, then $(-1)^s \\cdot 2^{-126} \\cdot \\frac{f}{2^{23}}$ (subnormal),\n  - if $0  e  255$, then $(-1)^s \\cdot 2^{e - 127} \\cdot \\left(1 + \\frac{f}{2^{23}}\\right)$.\n\nDerive from these bases whether $v_1$ alone, $v_2$ alone, or both together are necessary to guarantee that the instrument’s single decimal output uniquely identifies which of the four hypotheses is in effect. Your reasoning must make no use of shortcut tables and must show why the outputs under the four hypotheses are pairwise distinct for the selected test vector(s), taking into account the instrument’s non-finite mapping rule for floating point. Conclude with the minimal number of distinct test vectors from $\\{v_1, v_2\\}$ required to guarantee identification among the four hypotheses. Express your final answer as an integer. No rounding is needed.", "solution": "The task is to determine the minimal number of test vectors from the set $\\{v_1, v_2\\}$ required to uniquely identify which of four hypotheses the instrument uses to interpret a four-byte sequence. The four hypotheses are big-endian unsigned integer (BE_UINT), little-endian unsigned integer (LE_UINT), big-endian IEEE-754 single-precision float (BE_FLOAT), and little-endian IEEE-754 single-precision float (LE_FLOAT). A set of test vectors is sufficient if, for any pair of distinct hypotheses, there is at least one vector in the set that produces a different output for each hypothesis. The minimal number is the size of the smallest such set.\n\nLet the four bytes be $\\{B_0, B_1, B_2, B_3\\}$ in ascending memory address order. The problem defines the big-endian and little-endian 32-bit words as:\n$X_{\\mathrm{BE}} = B_0 \\cdot 2^{24} + B_1 \\cdot 2^{16} + B_2 \\cdot 2^{8} + B_3$\n$X_{\\mathrm{LE}} = B_0 + B_1 \\cdot 2^{8} + B_2 \\cdot 2^{16} + B_3 \\cdot 2^{24}$\n\nWe will analyze each test vector by calculating the instrument's output for all four hypotheses.\n\nAnalysis of Test Vector $v_1 = \\{0x7F, 0x80, 0x00, 0x00\\}$\n\nFor $v_1$, the bytes are $B_0 = 0x7F = 127$, $B_1 = 0x80 = 128$, $B_2 = 0x00 = 0$, and $B_3 = 0x00 = 0$.\n\n1.  **Hypothesis: Big-Endian Unsigned Integer (BE_UINT)**\n    The 32-bit word is $X_{\\mathrm{BE}}$. In hexadecimal, this is formed by concatenating the bytes: $X_{\\mathrm{BE}} = 0x7F800000$.\n    The decimal value is $127 \\cdot 2^{24} + 128 \\cdot 2^{16} + 0 \\cdot 2^8 + 0 \\cdot 2^0 = 2130706432 + 8388608 = 2139095040$.\n    The instrument output is $2139095040$.\n\n2.  **Hypothesis: Little-Endian Unsigned Integer (LE_UINT)**\n    The 32-bit word is $X_{\\mathrm{LE}}$. In hexadecimal, this is formed by concatenating the bytes in reverse order of significance: $X_{\\mathrm{LE}} = 0x0000807F$.\n    The decimal value is $127 \\cdot 2^0 + 128 \\cdot 2^8 + 0 \\cdot 2^{16} + 0 \\cdot 2^{24} = 127 + 32768 = 32895$.\n    The instrument output is $32895$.\n\n3.  **Hypothesis: Big-Endian IEEE-754 Single-Precision Float (BE_FLOAT)**\n    The 32-bit word is $X = X_{\\mathrm{BE}} = 0x7F800000$.\n    The binary representation is `0111 1111 1000 0000 0000 0000 0000 0000`.\n    The sign bit is $s = (X \\gg 31) \\ 1 = 0$.\n    The exponent field is $e = (X \\gg 23) \\ 0xFF$. The bits are `11111111`, so $e = 255$.\n    The fraction field is $f = X \\ 0x7FFFFF$. The bits are all `0`, so $f = 0$.\n    According to the provided rules, for $e = 255$ and $f = 0$, the value is $(-1)^s \\cdot \\infty$. With $s=0$, this is $+\\infty$.\n    The instrument returns $0$ for non-finite values.\n    The instrument output is $0$.\n\n4.  **Hypothesis: Little-Endian IEEE-754 Single-Precision Float (LE_FLOAT)**\n    The 32-bit word is $X = X_{\\mathrm{LE}} = 0x0000807F$.\n    The binary representation is `0000 0000 0000 0000 1000 0000 0111 1111`.\n    The sign bit is $s = (X \\gg 31) \\ 1 = 0$.\n    The exponent field is $e = (X \\gg 23) \\ 0xFF = 0$.\n    The fraction field is $f = X \\ 0x7FFFFF = 0x807F = 32895$.\n    According to the provided rules, for $e=0$ and $f \\neq 0$, this is a subnormal number. The value is $(-1)^s \\cdot 2^{-126} \\cdot \\frac{f}{2^{23}}$.\n    With $s=0$ and $f=32895$, the value is $2^{-126} \\cdot \\frac{32895}{2^{23}} = 2^{-126} \\cdot \\frac{32895}{8388608}$.\n    This value is a finite, positive, non-zero real number.\n    The instrument output is $2^{-126} \\cdot \\frac{32895}{8388608}$.\n\nThe outputs for $v_1$ are:\n-   BE_UINT: $2139095040$\n-   LE_UINT: $32895$\n-   BE_FLOAT: $0$\n-   LE_FLOAT: $2^{-126} \\cdot \\frac{32895}{8388608}$ (a small positive number)\n\nThese four values are all numerically distinct. Therefore, by sending the test vector $v_1$ and observing the single decimal output, one can uniquely determine which of the four hypotheses is correct. This means $v_1$ alone is sufficient. The minimal number of vectors required is therefore at most $1$.\n\nFor completeness, we analyze vector $v_2$.\n\nAnalysis of Test Vector $v_2 = \\{0x00, 0x00, 0x00, 0x01\\}$\n\nFor $v_2$, the bytes are $B_0 = 0x00 = 0$, $B_1 = 0x00 = 0$, $B_2 = 0x00 = 0$, and $B_3 = 0x01 = 1$.\n\n1.  **Hypothesis: Big-Endian Unsigned Integer (BE_UINT)**\n    The 32-bit word is $X_{\\mathrm{BE}} = 0x00000001$.\n    The decimal value is $0 \\cdot 2^{24} + 0 \\cdot 2^{16} + 0 \\cdot 2^8 + 1 \\cdot 2^0 = 1$.\n    The instrument output is $1$.\n\n2.  **Hypothesis: Little-Endian Unsigned Integer (LE_UINT)**\n    The 32-bit word is $X_{\\mathrm{LE}} = 0x01000000$.\n    The decimal value is $0 \\cdot 2^0 + 0 \\cdot 2^8 + 0 \\cdot 2^{16} + 1 \\cdot 2^{24} = 16777216$.\n    The instrument output is $16777216$.\n\n3.  **Hypothesis: Big-Endian IEEE-754 Single-Precision Float (BE_FLOAT)**\n    The 32-bit word is $X = X_{\\mathrm{BE}} = 0x00000001$.\n    The sign bit is $s = 0$.\n    The exponent field is $e = 0$.\n    The fraction field is $f = 1$.\n    For $e=0$ and $f \\neq 0$, the value is subnormal: $(-1)^s \\cdot 2^{-126} \\cdot \\frac{f}{2^{23}} = 2^{-126} \\cdot \\frac{1}{2^{23}} = 2^{-149}$.\n    The instrument output is $2^{-149}$.\n\n4.  **Hypothesis: Little-Endian IEEE-754 Single-Precision Float (LE_FLOAT)**\n    The 32-bit word is $X = X_{\\mathrm{LE}} = 0x01000000$.\n    The binary representation is `0000 0001 0000 0000 0000 0000 0000 0000`.\n    The sign bit is $s = 0$.\n    The exponent field is $e = (X \\gg 23) \\ 0xFF = 2$.\n    The fraction field is $f = X \\ 0x7FFFFF = 0$.\n    For $0  e  255$, the value is normalized: $(-1)^s \\cdot 2^{e-127} \\cdot (1 + \\frac{f}{2^{23}}) = 2^{2-127} \\cdot (1 + 0) = 2^{-125}$.\n    The instrument output is $2^{-125}$.\n\nThe outputs for $v_2$ are:\n-   BE_UINT: $1$\n-   LE_UINT: $16777216$\n-   BE_FLOAT: $2^{-149}$\n-   LE_FLOAT: $2^{-125}$\n\nThese four values ($1$, $16777216$, $2^{-149}$, and $2^{-125}$) are all numerically distinct. Thus, $v_2$ alone is also sufficient to distinguish the four hypotheses.\n\nSince either vector $v_1$ alone or vector $v_2$ alone is sufficient to uniquely identify the instrument's interpretation mode, the minimal number of distinct test vectors required from the set $\\{v_1, v_2\\}$ is $1$.", "answer": "$$\n\\boxed{1}\n$$", "id": "3639653"}]}