{"hands_on_practices": [{"introduction": "Understanding how computers perform arithmetic at the bit level is a cornerstone of computer organization. This exercise demystifies binary multiplication by breaking it down into a sequence of simpler \"shift\" and \"add\" operations, mirroring the fundamental algorithms that hardware multipliers implement. By manually stepping through this process, you will translate a familiar mathematical concept into its low-level computational equivalent and gain insight into the efficiency of hardware design. [@problem_id:1914536]", "problem": "A simplified processor is designed to execute a specific arithmetic operation on two 4-bit unsigned binary inputs, which we will call the multiplicand $A$ and the multiplier $B$. For this task, let the multiplicand be $A = 1101_2$ and the multiplier be $B = 1011_2$. The operation procedure is defined as follows: it computes a series of partial products, one for each bit of the multiplier $B$. The $i$-th partial product (where $i=0$ corresponds to the least significant bit) is equal to the multiplicand $A$ shifted left by $i$ positions if the $i$-th bit of $B$ is a '1', and it is zero if the $i$-th bit of $B$ is a '0'. The final result of the operation is the binary sum of all four partial products. Determine the final 8-bit unsigned binary result of this operation.", "solution": "We are given 4-bit unsigned binary inputs $A=1101_{2}$ and $B=1011_{2}$. Let the bits of $B$ be $b_{0}$ (least significant) through $b_{3}$ (most significant), so $b_{0}=1$, $b_{1}=1$, $b_{2}=0$, and $b_{3}=1$.\n\nBy the stated procedure, the $i$-th partial product is $A$ shifted left by $i$ positions if $b_{i}=1$, and zero otherwise. Left shifting by $i$ positions is equivalent to multiplying by $2^{i}$. Writing each partial product as an 8-bit word for alignment, we obtain:\n$$\nP_{0}=\\begin{cases}\nA\\ll 0,  b_{0}=1\n\\end{cases}\n=1101_{2}=00001101_{2},\n$$\n$$\nP_{1}=\\begin{cases}\nA\\ll 1,  b_{1}=1\n\\end{cases}\n=11010_{2}=00011010_{2},\n$$\n$$\nP_{2}=\\begin{cases}\n0,  b_{2}=0\n\\end{cases}\n=00000000_{2},\n$$\n$$\nP_{3}=\\begin{cases}\nA\\ll 3,  b_{3}=1\n\\end{cases}\n=1101000_{2}=01101000_{2}.\n$$\n\nThe final result is the binary sum of the four partial products:\n$$\nS=P_{0}+P_{1}+P_{2}+P_{3}.\n$$\nCompute sequentially:\n$$\nP_{0}+P_{1}=00001101_{2}+00011010_{2}=00100111_{2},\n$$\n$$\n( P_{0}+P_{1}) + P_{2}=00100111_{2}+00000000_{2}=00100111_{2},\n$$\n$$\n\\bigl(( P_{0}+P_{1}) + P_{2}\\bigr)+P_{3}=00100111_{2}+01101000_{2}=10001111_{2}.\n$$\n\nTherefore, the final 8-bit unsigned binary result is $10001111_{2}$.", "answer": "$$\\boxed{10001111_{2}}$$", "id": "1914536"}, {"introduction": "Beyond standard arithmetic, a deep understanding of binary representation enables highly efficient \"bitwise hacks\" for checking number properties. This practice explores a classic technique to determine if an integer is a power of two using a single bitwise AND operation, and extends this thinking to related properties. Mastering such tricks is not just an academic curiosity; it showcases the power of bit manipulation for writing optimized code and developing an intuitive feel for how data is structured at the lowest level. [@problem_id:3687432]", "problem": "You are given an unsigned integer $x$ represented in a fixed-width $w$-bit machine. Arithmetic on $x$ is performed modulo $2^w$. The bitwise AND operator is denoted by $\\$ and operates bitwise on corresponding positions. A “power of two” is any integer of the form $2^k$ with $k \\ge 0$, but for the purpose of detection we conventionally exclude $x=0$. A “power of two minus one” is any integer of the form $2^k - 1$ with $1 \\le k \\le w$. The Least Significant Bit (LSB) is the bit at position $0$ (the $2^0$ place).\n\nStarting only from the core definitions of unsigned binary representation, bitwise AND, and modulo-$2^w$ arithmetic, determine which of the following predicates are correct characterizations that hold for all $x$ in the $w$-bit unsigned domain. In each option, logical conjunction is written as $\\land$, equality as $=$, and inequality as $\\ne$.\n\nA. The predicate $(x \\ne 0) \\land ((x \\,\\\\, (x-1)) = 0)$ is true if and only if $x$ is a power of two.\n\nB. The predicate $(x \\ne 0) \\land ((x \\,\\\\, (x+1)) = 0)$ is true if and only if $x$ is of the form $2^k - 1$ for some integer $k$ with $1 \\le k \\le w$.\n\nC. The predicate $((x \\,\\\\, (x-1)) = 0)$ correctly detects powers of two for all unsigned $x$, including $x=0$.\n\nD. The predicate $(x \\ne 0) \\land ((x \\,\\\\, (x+1)) = 0)$ incorrectly classifies $x = 2^w - 1$ as not of the form $2^k - 1$ because $(x+1)$ overflows to $0$.\n\nE. The predicate $((x \\,\\\\, (x+1)) = 0)$ correctly detects numbers of the form $2^k - 1$ for all unsigned $x$, provided $k \\ge 0$.\n\nSelect all options that are correct. Be explicit about how the corner cases $x=0$ and $x=1$ behave under these predicates and definitions.", "solution": "Let's analyze the core properties of the bitwise expressions `x  (x-1)` and `x  (x+1)` within the framework of `w`-bit unsigned arithmetic.\n\n**Analysis of `x  (x-1)`:**\nSubtracting 1 from a positive integer `x` flips its least significant '1' bit to a '0' and all '0's to its right to '1's. The bitwise AND of `x` and `x-1` therefore results in `x` with its least significant '1' bit cleared. This expression evaluates to `0` if and only if `x` had at most one '1' bit in its binary representation. This is true for `x=0` and for all numbers that are powers of two (e.g., `1`, `2`, `4`, `8`, ...).\n\n**Analysis of `x  (x+1)`:**\nAdding 1 to an integer `x` flips its least significant '0' bit to a '1' and all '1's to its right to '0's. The expression `x  (x+1) == 0` holds true if and only if `x` is of the form `2^k - 1` (a sequence of `k` ones) for `k >= 0`. For `x=2^k-1`, `x+1` becomes `2^k`, and the two numbers have no overlapping '1' bits, so their AND is `0`. This also holds for the corner case `x = 2^w - 1`, where `x+1` overflows to `0`, making the AND result `0`.\n\nNow, we evaluate each option:\n\n**A. Correct.** The predicate `(x  (x-1)) == 0` identifies `x=0` and all powers of two. The additional condition `x != 0` explicitly excludes `x=0`, leaving exactly the set of powers of two ($2^k$ for $k \\ge 0$). This matches the problem's definition for detection.\n\n**B. Correct.** The predicate `(x  (x+1)) == 0` identifies numbers of the form `2^k - 1` for `k >= 0`. The additional condition `x != 0` excludes `x=0` (the `k=0` case), leaving exactly the set of numbers of the form `2^k - 1` for `1 = k = w`, which matches the problem's definition. The wraparound case for `x=2^w-1` is handled correctly by the logic.\n\n**C. Incorrect.** The predicate `(x  (x-1)) == 0` is true for `x=0`. However, the problem statement specifies that for detection purposes, `x=0` is excluded from the set of powers of two. Therefore, this predicate gives a false positive for `x=0` and is not a correct detector for the specified task.\n\n**D. Incorrect.** Let's test `x = 2^w - 1`. The predicate is `(x != 0)  ((x  (x+1)) == 0)`. Here, `x+1` overflows to `0`. The expression becomes `(2^w-1  0)`, which is `0`. The predicate is true. Thus, it correctly classifies `x=2^w-1` as being of the form `2^k-1` (with `k=w`). The option claims it *incorrectly* classifies it, which is false.\n\n**E. Incorrect.** The predicate `(x  (x+1)) == 0` is true for `x=0` (the `k=0` case). The problem's definition for numbers of the form \"power of two minus one\" requires `1 = k = w`, which excludes `x=0`. This predicate therefore has a false positive at `x=0` relative to the specified detection task.\n\nTherefore, only options A and B are correct characterizations.", "answer": "$$\\boxed{AB}$$", "id": "3687432"}, {"introduction": "The finite nature of machine integers and their wraparound arithmetic can lead to non-intuitive and sometimes dangerous behavior in software. This problem moves from abstract theory to a concrete, practical scenario: a common security vulnerability caused by unsigned integer underflow in array indexing. By analyzing this check-then-use pattern, you will see how a seemingly correct logical guard can fail due to modulo arithmetic, leading to out-of-bounds memory access, and learn why this precise understanding is critical for writing secure and robust programs. [@problem_id:3687423]", "problem": "A computing system represents all integers as unsigned binary integers of fixed width $w$, with the set of representable values $U_{w}=\\{0,1,2,\\dots,2^{w}-1\\}$. Arithmetic on $U_{w}$ is performed modulo $2^{w}$, so that for any $x \\in U_{w}$, the unsigned subtraction $x \\ominus 1$ is defined by $x \\ominus 1 \\equiv x-1 \\pmod{2^{w}}$. The logical semantics of an array of length $L \\in U_{w}$ are that valid indices are exactly the integers $j$ satisfying $0 \\leq j \\leq L-1$, where the interval is empty when $L=0$. Consider a check-then-use pattern that, given an index $i \\in U_{w}$ and a length $L \\in U_{w}$, performs the guard $i  L$, and if the guard holds, computes $j = i \\ominus 1$ and accesses the array at logical index $j$.\n\nStarting only from the definitions above of unsigned representation, modulo arithmetic on $U_{w}$, and logical index validity, do the following:\n- Derive a necessary and sufficient condition on the pair $(i,L) \\in U_{w} \\times U_{w}$ under which the guard $iL$ holds but the subsequent access using $j=i \\ominus 1$ is logically out-of-bounds (that is, $j \\notin \\{0,1,\\dots,L-1\\}$), specifically due to the underflow behavior of unsigned subtraction.\n- Assume $(i,L)$ is drawn uniformly at random from $U_{w} \\times U_{w}$, and consider only those pairs for which the guard $iL$ holds. Compute, as a simplified closed-form expression in terms of $w$, the conditional probability (equivalently, the fraction) that the guard holds yet the computed index $j=i \\ominus 1$ is out-of-bounds for the array of logical length $L$.\n\nYour final answer must be a single closed-form analytic expression in terms of $w$. No numerical approximation or rounding is required or permitted.", "solution": "The problem requires an analysis of a potential security vulnerability arising from unsigned integer arithmetic in a specific code pattern. The system uses unsigned integers of width $w$, represented by the set $U_{w}=\\{0,1,2,\\dots,2^{w}-1\\}$, with arithmetic performed modulo $2^{w}$. The code pattern involves checking a condition $i  L$, where $i, L \\in U_{w}$, and if it holds, accessing an array of logical length $L$ at an index $j = i \\ominus 1$. The subtraction operation $x \\ominus 1$ is defined as $x \\ominus 1 \\equiv x-1 \\pmod{2^{w}}$.\n\nFirst, we must derive the necessary and sufficient condition under which the guard $iL$ holds, but the subsequent array access at index $j$ is logically out-of-bounds. An index $j$ is out-of-bounds for an array of length $L$ if it is not in the set of valid indices $\\{0, 1, \\dots, L-1\\}$. Since the computed index $j$ is the result of a modulo $2^w$ operation, $j$ is always an element of $U_w$, meaning $j \\ge 0$. Therefore, the out-of-bounds condition simplifies to $j \\ge L$.\n\nThe vulnerability thus occurs if and only if the pair $(i, L) \\in U_{w} \\times U_{w}$ satisfies the following two conditions simultaneously:\n1.  The guard holds: $i  L$\n2.  The access is out-of-bounds: $j \\ge L$, where $j = i \\ominus 1$.\n\nTo analyze these conditions, we must formalize the behavior of the unsigned subtraction $j = i \\ominus 1 \\equiv i-1 \\pmod{2^{w}}$. This operation depends on the value of $i$.\n\nCase 1: $i0$.\nIf $i \\in \\{1, 2, \\dots, 2^{w}-1\\}$, then the integer $i-1$ is in the range $[0, 2^{w}-2]$. For any value in this range, the modulo $2^{w}$ operation has no effect, so $j = i-1$. The two conditions for the vulnerability become:\n- $i  L$\n- $i-1 \\ge L$\nThese two inequalities together imply $i-1 \\ge L  i$, which is a contradiction. It is impossible for $i-1$ to be greater than or equal to a number $L$ that is strictly greater than $i$. Thus, the vulnerability cannot occur if $i  0$.\n\nCase 2: $i=0$.\nThis is the integer underflow case. If $i=0$, the expression $i-1$ evaluates to $-1$. The result of the modulo operation is $j = (-1) \\pmod{2^{w}} = 2^{w}-1$. The two conditions for the vulnerability become:\n- $0  L$ (from $i  L$)\n- $2^{w}-1 \\ge L$ (from $j \\ge L$)\nThe second condition, $L \\le 2^{w}-1$, is always satisfied for any $L \\in U_{w}$. Therefore, the two conditions for the vulnerability to occur in this case reduce to only one: $L0$.\nSince $L \\in U_{w}$, the condition $L0$ is equivalent to $L \\in \\{1, 2, \\dots, 2^{w}-1\\}$.\n\nCombining the analysis of both cases, we conclude that the vulnerability occurs if and only if $i=0$ and $L0$. This is the necessary and sufficient condition.\n\nSecond, we must compute the conditional probability that the vulnerability occurs, given that the guard $iL$ holds. We are told to assume $(i,L)$ is drawn uniformly at random from the set of all possible pairs $U_{w} \\times U_{w}$.\nLet $V$ be the event that the vulnerability occurs. As derived, $V = \\{(i,L) \\in U_{w} \\times U_{w} \\mid i=0 \\text{ and } L  0\\}$.\nLet $G$ be the event that the guard holds, $G = \\{(i,L) \\in U_{w} \\times U_{w} \\mid i  L\\}$.\nWe are asked to compute the conditional probability $P(V|G)$.\n\nBy the definition of conditional probability, $P(V|G) = \\frac{P(V \\cap G)}{P(G)}$. Since the sampling space is uniform, this probability is equal to the ratio of the number of outcomes in the events:\n$$P(V|G) = \\frac{|V \\cap G|}{|G|}$$\nLet's analyze the event $V \\cap G$. If the event $V$ occurs, then $i=0$ and $L0$. For any such pair, the guard condition $iL$ (i.e., $0L$) is satisfied. This means that every outcome in $V$ is also in $G$, so $V$ is a subset of $G$. Consequently, $V \\cap G = V$. The expression for the probability simplifies to:\n$$P(V|G) = \\frac{|V|}{|G|}$$\nWe now compute the cardinalities of the sets $V$ and $G$.\nThe set $V$ consists of pairs where $i=0$ and $L$ can be any value from $1$ to $2^{w}-1$. There is $1$ choice for $i$ and $2^{w}-1$ choices for $L$.\n$$|V| = 1 \\times (2^{w}-1) = 2^{w}-1$$\nThe set $G$ consists of all pairs where $i  L$. We can find its size by summing over all possible values of $L$:\n$$|G| = \\sum_{L=0}^{2^{w}-1} |\\{i \\in U_{w} \\mid i  L\\}| = \\sum_{L=0}^{2^{w}-1} L = 0+1+2+\\dots+(2^{w}-1)$$\nThis is the sum of the first $2^{w}-1$ non-negative integers. Using the formula for the sum of an arithmetic series, with $N=2^w-1$:\n$$|G| = \\frac{N(N+1)}{2} = \\frac{(2^{w}-1)(2^{w}-1+1)}{2} = \\frac{(2^{w}-1)2^{w}}{2} = (2^{w}-1)2^{w-1}$$\nNow, we can compute the conditional probability by taking the ratio of $|V|$ and $|G|$:\n$$P(V|G) = \\frac{2^{w}-1}{(2^{w}-1)2^{w-1}}$$\nAssuming the width $w$ is a positive integer, $w \\ge 1$, which implies $2^{w}-1 \\neq 0$. We can safely cancel the $(2^{w}-1)$ term from the numerator and the denominator.\n$$P(V|G) = \\frac{1}{2^{w-1}}$$\nThis is the simplified, closed-form expression for the required conditional probability.", "answer": "$$\\boxed{\\frac{1}{2^{w-1}}}$$", "id": "3687423"}]}