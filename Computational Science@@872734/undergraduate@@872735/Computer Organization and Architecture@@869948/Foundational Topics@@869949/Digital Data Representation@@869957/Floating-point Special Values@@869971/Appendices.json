{"hands_on_practices": [{"introduction": "The best way to truly understand the structure of floating-point numbers is to build a system from the ground up. This practice guides you through the creation of a miniature 8-bit floating-point format, applying the foundational rules of the Institute of Electrical and Electronics Engineers (IEEE) $754$ standard. By exhaustively enumerating and decoding every possible bit pattern, you will gain a concrete intuition for how normalized numbers, subnormals, signed zeros, infinities, and Not a Number (NaN) values are encoded and where they fit within the number space. [@problem_id:2395264]", "problem": "You are to implement a complete enumeration and decoding of a binary floating-point \"toy\" format with a total width of $8$ bits. The layout is: $1$ sign bit, $3$ exponent bits, and $4$ fraction (mantissa) bits. The exponent uses the standard biased representation with bias $b$ defined by $b = 2^{k-1} - 1$ for $k$ exponent bits. The interpretation follows the Institute of Electrical and Electronics Engineers (IEEE) $754$ conventions for normalized numbers, subnormal numbers, signed zeros, infinities, and Not a Number (NaN) payloads, including the use of an implicit leading binary digit equal to $1$ for normalized numbers and no implicit leading digit for subnormal numbers. The exponent field equal to all ones encodes infinities and NaNs depending on whether the fraction is zero or nonzero, respectively. The exponent field equal to all zeros encodes subnormal numbers when the fraction is nonzero and signed zeros when the fraction is zero. The exponent field in between encodes normalized numbers with a biased exponent.\n\nFrom these core definitions, derive the exact decoding for every $8$-bit pattern into one of the following categories: normalized finite number, subnormal finite number, signed zero, infinity, or Not a Number. You must not assume any formula beyond the structural rules stated above; instead, use these definitions to construct the precise numerical value for each representable finite encoding. Your implementation must be general and principled and should not rely on any hard-coded answers.\n\nYour program must:\n- Enumerate all $256$ bit patterns.\n- Decode each pattern into its numerical value under the rules above, producing a real number for finite encodings and the appropriate IEEE $754$ special values for infinities and Not a Number values.\n- Use exhaustive enumeration (not analytical shortcuts) to compute the requested quantities.\n\nUse the following test suite, which probes different aspects of the format (coverage includes happy path, edge cases, and boundary conditions). For the $8$-bit format described, produce the following results in the stated order:\n\n1. The total count of finite encodings (including both $+0$ and $-0$) as an integer.\n2. The total count of Not a Number encodings as an integer.\n3. The total count of infinity encodings as an integer.\n4. The smallest strictly positive subnormal value as a real number.\n5. The smallest strictly positive normalized value as a real number.\n6. The largest finite value as a real number.\n7. The spacing above $1.0$, defined as the difference between $1.0$ and the next larger representable positive finite number, as a real number.\n8. The spacing below $1.0$, defined as the difference between $1.0$ and the next smaller representable positive finite number, as a real number.\n9. The decoded value (as a real number) for the bit pattern $0\\mathrm{b}00110000$.\n10. The decoded value (as a real number) for the bit pattern $0\\mathrm{b}11101111$.\n11. The decoded value (as a real number) for the bit pattern $0\\mathrm{b}00000001$.\n12. A boolean indicating whether the strictly positive finite value set (excluding $0$) is strictly increasing when sorted and has the expected cardinality given the format.\n\nAngle units are not applicable. There are no physical units; all numbers are dimensionless.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, exactly in the order listed above. For example, an output with three results should look like $[r_1,r_2,r_3]$.\n\nConstraints and notes:\n- Treat signed zeros as finite encodings.\n- For normalized numbers, the leading binary digit of the significand is implicitly $1$; for subnormal numbers, there is no implicit leading digit.\n- The exponent bias must be computed from first principles using the definition above, not hard-coded as a literal without justification.\n- Do not require any user input. The program must run as-is and print exactly one line in the specified format.", "solution": "The problem statement is a valid, well-posed exercise in computational physics concerning the principles of floating-point number representation. It provides a complete and consistent set of rules to define a \"toy\" $8$-bit floating-point format based on the IEEE $754$ standard. We will proceed to derive the properties and decode values from first principles.\n\nThe format is defined by a total width of $N=8$ bits, composed of $N_s=1$ sign bit ($s$), $k=3$ exponent bits ($E$), and $m=4$ fraction bits ($F$). The bit pattern is $s E_{k-1}...E_0 F_{m-1}...F_0$.\n\nFirst, we determine the exponent bias, $b$. The formula provided is $b = 2^{k-1} - 1$. With $k=3$ exponent bits, the bias is:\n$$\nb = 2^{3-1} - 1 = 2^2 - 1 = 4 - 1 = 3\n$$\nThe integer value of the exponent field, which we denote $E_{val}$, ranges from $0$ to $2^k-1=7$. The integer value of the fraction field, $F_{val}$, ranges from $0$ to $2^m-1=15$. The numerical value $v$ of a representation is determined by the sign bit $s$, $E_{val}$, and $F_{val}$ according to the following cases.\n\nAn $8$-bit integer $I \\in [0, 255]$ is parsed into its components:\n- Sign bit: $s = \\lfloor I / 2^{k+m} \\rfloor = \\lfloor I / 128 \\rfloor$. The sign multiplier is $(-1)^s$.\n- Exponent field value: $E_{val} = \\lfloor (I \\pmod{128}) / 16 \\rfloor$.\n- Fraction field value: $F_{val} = I \\pmod{16}$.\n\nThe decoding rules are as follows:\n\nCase 1: Special Values ($E_{val} = 2^k - 1 = 7$)\nIf the exponent field is all ones, the representation denotes either infinity or Not a Number (NaN).\n- If $F_{val} = 0$, the value is signed infinity: $v = (-1)^s \\infty$. This gives two representations: $+\\infty$ ($I=0\\text{b}01110000$) and $-\\infty$ ($I=0\\text{b}11110000$).\n- If $F_{val} \\neq 0$, the value is a NaN. There are $2 \\times (2^m - 1) = 2 \\times 15 = 30$ such NaN representations.\n\nCase 2: Subnormal Numbers and Zeros ($E_{val} = 0$)\nIf the exponent field is all zeros, the numbers are either subnormal (denormalized) or zero.\n- The effective exponent is fixed at $e = 1 - b = 1 - 3 = -2$.\n- The significand $M$ has no implicit leading $1$ and is given by $M = F_{val} / 2^m = F_{val} / 16$.\n- If $F_{val} = 0$, then $M=0$, and the value is a signed zero: $v = (-1)^s \\times 0$. This gives $+0$ ($I=0\\text{b}00000000$) and $-0$ ($I=0\\text{b}10000000$).\n- If $F_{val} \\neq 0$, the value is a subnormal number: $v = (-1)^s \\times M \\times 2^e = (-1)^s \\times (F_{val} / 16) \\times 2^{-2}$. There are $2 \\times (2^m-1) = 30$ such representations.\n\nCase 3: Normalized Numbers ($1 \\le E_{val} \\le 6$)\nIf the exponent field is not all zeros and not all ones, the number is normalized.\n- The effective exponent is $e = E_{val} - b = E_{val} - 3$.\n- The significand $M$ has an implicit leading $1$: $M = 1 + F_{val} / 2^m = 1 + F_{val} / 16$.\n- The value is $v = (-1)^s \\times M \\times 2^e = (-1)^s \\times (1 + F_{val}/16) \\times 2^{E_{val}-3}$. There are $2 \\times (2^k-2) \\times 2^m = 2 \\times 6 \\times 16 = 192$ such representations.\n\nBased on this framework, we can now exhaustively enumerate all $256$ bit patterns and compute the required quantities.\n\n1.  Total count of finite encodings: This includes signed zeros, subnormal numbers, and normalized numbers.\n    - Zeros: $2$ representations ($+0, -0$).\n    - Subnormal numbers: $2 \\times (2^m-1) = 2 \\times (16-1) = 30$.\n    - Normalized numbers: $2 \\times (2^k-2) \\times 2^m = 2 \\times (8-2) \\times 16 = 2 \\times 6 \\times 16 = 192$.\n    - Total finite count = $2 + 30 + 192 = 224$.\n\n2.  Total count of Not a Number encodings:\n    - Condition: $E_{val}=7$, $F_{val} \\neq 0$. This applies to both signs.\n    - Total NaN count = $2 \\times (2^m-1) = 2 \\times 15 = 30$.\n\n3.  Total count of infinity encodings:\n    - Condition: $E_{val}=7$, $F_{val} = 0$. This applies to both signs.\n    - Total infinity count = $2$.\n\n4.  Smallest strictly positive subnormal value:\n    - This requires $s=0$, $E_{val}=0$, and the smallest non-zero $F_{val}$, which is $F_{val}=1$.\n    - $v = (+1) \\times (1 / 2^4) \\times 2^{1-b} = (1/16) \\times 2^{-2} = 1/64 = 0.015625$.\n\n5.  Smallest strictly positive normalized value:\n    - This requires $s=0$, the smallest normalized exponent $E_{val}=1$, and the smallest fraction $F_{val}=0$.\n    - $e = E_{val} - b = 1 - 3 = -2$.\n    - $M = 1 + 0/16 = 1$.\n    - $v = (+1) \\times 1 \\times 2^{-2} = 1/4 = 0.25$.\n\n6.  Largest finite value:\n    - This requires $s=0$, the largest normalized exponent $E_{val}=6$, and the largest fraction $F_{val}=15$.\n    - $e = E_{val} - b = 6 - 3 = 3$.\n    - $M = 1 + 15/16 = 31/16$.\n    - $v = (+1) \\times (31/16) \\times 2^3 = (31/16) \\times 8 = 31/2 = 15.5$.\n\n7.  Spacing above $1.0$:\n    - First, we represent $1.0$. We need $v=1.0 = 1.0 \\times 2^0$. This implies $e=0$ and $M=1.0$.\n    - $e = E_{val} - b = 0 \\implies E_{val} = b = 3$.\n    - $M = 1 + F_{val}/16 = 1 \\implies F_{val}=0$.\n    - So, $1.0$ is represented by $s=0, E_{val}=3, F_{val}=0$.\n    - The next larger representable value has the same sign and exponent, but with $F_{val}$ incremented to $1$.\n    - $v_{next} = (+1) \\times (1 + 1/16) \\times 2^{3-3} = 17/16 = 1.0625$.\n    - The spacing is $v_{next} - 1.0 = 1.0625 - 1.0 = 0.0625$.\n\n8.  Spacing below $1.0$:\n    - The value just below $1.0$ corresponds to the bit pattern immediately preceding that of $1.0$.\n    - The pattern for $1.0$ is $0 \\ 011 \\ 0000$. The one before is $0 \\ 010 \\ 1111$.\n    - Decoding $s=0, E_{val}=2, F_{val}=15$:\n    - $e = E_{val} - b = 2 - 3 = -1$.\n    - $M = 1 + 15/16 = 31/16$.\n    - $v_{prev} = (+1) \\times (31/16) \\times 2^{-1} = 31/32 = 0.96875$.\n    - The spacing is $1.0 - v_{prev} = 1.0 - 0.96875 = 0.03125$.\n\n9.  Decoded value for $0\\mathrm{b}00110000$:\n    - This is the pattern $s=0, E_{val}=3, F_{val}=0$, which, as derived above, represents $1.0$.\n\n10. Decoded value for $0\\mathrm{b}11101111$:\n    - $s=1$ (negative).\n    - $E_{val} = 110_2 = 6$. This is a normalized number. $e = 6 - 3 = 3$.\n    - $F_{val} = 1111_2 = 15$.\n    - $M = 1 + 15/16 = 31/16$.\n    - $v = (-1) \\times (31/16) \\times 2^3 = -15.5$. This is the negative of the largest finite value.\n\n11. Decoded value for $0\\mathrm{b}00000001$:\n    - $s=0$ (positive).\n    - $E_{val} = 0$. This is a subnormal number. $e = 1 - b = -2$.\n    - $F_{val} = 1$.\n    - $M = 1/16$.\n    - $v = (+1) \\times (1/16) \\times 2^{-2} = 1/64 = 0.015625$. This is the smallest positive subnormal value.\n\n12. Boolean for properties of the set of strictly positive finite values:\n    - This set comprises all positive subnormal and normalized numbers.\n    - Number of positive subnormals: $2^m-1 = 15$.\n    - Number of positive normalized numbers: $(2^k-2) \\times 2^m = 6 \\times 16 = 96$.\n    - The expected cardinality is $15 + 96 = 111$.\n    - The values are constructed such that they are unique and strictly increasing. For any exponent, increasing the fraction bits increases the value. The largest value for an exponent range $e$ is strictly less than the smallest value for exponent range $e+1$.\n    - Largest subnormal: $(2^m-1)/2^m \\times 2^{1-b} = (15/16) \\times 2^{-2} = 15/64$.\n    - Smallest normalized: $1 \\times 2^{1-b} = 1 \\times 2^{-2} = 1/4 = 16/64$.\n    - Since $15/64  16/64$, there is no overlap. This holds for all exponent transitions. Therefore, the set is strictly increasing and has the expected cardinality. The result is True.\n\nThe implementation will confirm these derivations through exhaustive enumeration.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Enumerates and decodes an 8-bit toy floating-point format to answer specific questions.\n    \"\"\"\n    N_BITS = 8\n    K_BITS = 3  # exponent bits\n    M_BITS = 4  # fraction bits\n\n    # Calculate exponent bias from first principles as required.\n    # b = 2^(k-1) - 1\n    bias = 2**(K_BITS - 1) - 1\n\n    e_max = (1  K_BITS) - 1\n    f_mask = (1  M_BITS) - 1\n\n    finite_vals = []\n    infinities = []\n    nans = []\n    positive_finite_vals = []\n    \n    # A helper function to decode a single integer representation\n    def decode_integer(i):\n        s_val = i  (K_BITS + M_BITS)\n        e_val = (i  M_BITS)  e_max\n        f_val = i  f_mask\n\n        sign = (-1)**s_val\n\n        # Case 1: Exponent is all ones (special values)\n        if e_val == e_max:\n            if f_val == 0:\n                # Infinity\n                return (sign * np.inf, \"inf\")\n            else:\n                # Not a Number (NaN)\n                return (np.nan, \"nan\")\n\n        # Case 2: Exponent is all zeros (subnormals and zero)\n        elif e_val == 0:\n            exponent = 1 - bias\n            # Significand has no implicit leading 1\n            significand = f_val / (2**M_BITS)\n            val = sign * significand * (2**exponent)\n            if f_val == 0:\n                return (val, \"zero\")\n            else:\n                return (val, \"subnormal\")\n\n        # Case 3: Normalized numbers\n        else:\n            exponent = e_val - bias\n            # Significand has an implicit leading 1\n            significand = 1 + f_val / (2**M_BITS)\n            val = sign * significand * (2**exponent)\n            return (val, \"normal\")\n\n    # Enumerate all 2^8 = 256 patterns\n    for i in range(1  N_BITS):\n        value, category = decode_integer(i)\n        \n        if category in [\"zero\", \"subnormal\", \"normal\"]:\n            finite_vals.append(value)\n            if value = 0: # Includes +0.0\n                # The question is about *strictly* positive set, so filter 0 later.\n                positive_finite_vals.append(value)\n        elif category == \"inf\":\n            infinities.append(value)\n        elif category == \"nan\":\n            nans.append(value)\n\n    # 1. Total count of finite encodings (zeros, subnormals, normalized)\n    res1_finite_count = len(finite_vals)\n\n    # 2. Total count of Not a Number encodings\n    res2_nan_count = len(nans)\n\n    # 3. Total count of infinity encodings\n    res3_inf_count = len(infinities)\n    \n    # Filter out zero for strictly positive set\n    strictly_positive_finite_vals = sorted([v for v in positive_finite_vals if v  0])\n\n    # 4. Smallest strictly positive subnormal value\n    subnormals = [v for v in finite_vals if v  0 and abs(v)  (2**(1-bias))]\n    res4_min_pos_subnormal = min(subnormals) if subnormals else 0\n\n    # 5. Smallest strictly positive normalized value\n    normals = [v for v in finite_vals if v  0 and abs(v) = (2**(1-bias))]\n    res5_min_pos_normalized = min(normals) if normals else 0\n\n    # 6. Largest finite value\n    res6_max_finite = max(finite_vals)\n\n    # 7. Spacing above 1.0\n    # 8. Spacing below 1.0\n    try:\n        idx_1 = strictly_positive_finite_vals.index(1.0)\n        res7_spacing_above_1 = strictly_positive_finite_vals[idx_1 + 1] - 1.0\n        res8_spacing_below_1 = 1.0 - strictly_positive_finite_vals[idx_1 - 1]\n    except (ValueError, IndexError):\n        res7_spacing_above_1 = np.nan\n        res8_spacing_below_1 = np.nan\n\n    # 9. Decoded value for 0b00110000\n    res9_decode_1 = decode_integer(0b00110000)[0]\n\n    # 10. Decoded value for 0b11101111\n    res10_decode_2 = decode_integer(0b11101111)[0]\n    \n    # 11. Decoded value for 0b00000001\n    res11_decode_3 = decode_integer(0b00000001)[0]\n\n    # 12. Boolean property of the strictly positive finite value set\n    expected_cardinality = ((1  K_BITS) - 2) * (1  M_BITS) + ((1  M_BITS) - 1)\n    cardinality_ok = len(strictly_positive_finite_vals) == expected_cardinality\n    strictly_increasing = all(\n        strictly_positive_finite_vals[i]  strictly_positive_finite_vals[i+1]\n        for i in range(len(strictly_positive_finite_vals) - 1)\n    )\n    res12_set_property = cardinality_ok and strictly_increasing\n    \n    results = [\n        res1_finite_count,\n        res2_nan_count,\n        res3_inf_count,\n        res4_min_pos_subnormal,\n        res5_min_pos_normalized,\n        res6_max_finite,\n        res7_spacing_above_1,\n        res8_spacing_below_1,\n        res9_decode_1,\n        res10_decode_2,\n        res11_decode_3,\n        res12_set_property\n    ]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2395264"}, {"introduction": "With a solid grasp of how special values are represented, the next step is to understand how they behave in arithmetic. This exercise puts you in the role of a verification engineer creating a testbench for a new processor's floating-point unit. You will analyze the outcomes of classic indeterminate forms, such as $\\infty - \\infty$ and $0/0$, determining the resulting value and the specific exception flags that are raised according to the IEEE $754$ standard. [@problem_id:3641973]", "problem": "A processor core implements the Institute of Electrical and Electronics Engineers (IEEE) 754 Standard for Floating-Point Arithmetic in the binary32 format with the default rounding mode of round-to-nearest, ties-to-even. The architecture exposes the five standard floating-point exception flags: invalid operation, divide-by-zero, overflow, underflow, and inexact. Under IEEE 754 semantics, special values include $+\\infty$, $-\\infty$, $+0$, $-0$, and Not a Number (NaN), with operations defined in terms of extended real arithmetic when mathematically meaningful and otherwise signaling invalid operation while returning a quiet NaN.\n\nYou are tasked with constructing a minimal testbench to validate special-case handling for the following four operations executed in order:\n1. $+\\infty + +\\infty$,\n2. $+\\infty - +\\infty$,\n3. $+\\infty \\times 0$,\n4. $0 / 0$.\n\nAssume that all inputs are non-signaling (that is, none are signaling NaN), so that any NaN produced by these operations is a quiet NaN. For each operation, determine the expected result category (one of $+\\infty$, finite, or quiet NaN) and the set of exception flags that fire, based solely on IEEE 754’s core definitions and well-tested facts about special values.\n\nTo make the testbench self-checking, encode the exception flags for the $i$-th operation as a five-bit vector in the fixed order invalid, divide-by-zero, overflow, underflow, inexact, with bit values $1$ for “flag fires” and $0$ for “flag does not fire.” Map that vector to an integer\n$$c_i \\;=\\; 16 \\cdot I_i \\;+\\; 8 \\cdot D_i \\;+\\; 4 \\cdot O_i \\;+\\; 2 \\cdot U_i \\;+\\; 1 \\cdot X_i,$$\nwhere $I_i$, $D_i$, $O_i$, $U_i$, and $X_i$ are the bits for invalid, divide-by-zero, overflow, underflow, and inexact, respectively, for operation $i$. Finally, compute the aggregate checksum\n$$S \\;=\\; c_1 \\;+\\; 3\\,c_2 \\;+\\; 9\\,c_3 \\;+\\; 27\\,c_4.$$\n\nProvide the expected result category and flags for each operation, and then compute the single real-valued number $S$. No rounding is required for the final value of $S$.", "solution": "The problem requires the analysis of four specific floating-point operations involving special values ($+\\infty$, $0$) as defined by the Institute of Electrical and Electronics Engineers (IEEE) 754 Standard. For each operation, we must determine the resulting value's category and the state of the five standard exception flags. The flags are Invalid Operation ($I$), Divide-by-Zero ($D$), Overflow ($O$), Underflow ($U$), and Inexact ($X$). These flags are then used to compute an integer code $c_i$ for each operation $i$, and finally an aggregate checksum $S$.\n\nThe problem is well-defined and grounded in the established principles of the IEEE 754 standard, a cornerstone of computer organization and architecture. All necessary information is provided, and the objective is clear. We proceed with the analysis of each operation.\n\n**Operation 1: $+\\infty + +\\infty$**\n\nAccording to the IEEE 754 standard, the sum of two infinities with the same sign is that same infinity.\n- **Result Category**: The result is $+\\infty$.\n- **Exception Flags**:\n    - Invalid Operation ($I_1$): This operation is valid and well-defined in extended real arithmetic. The flag is not raised. $I_1 = 0$.\n    - Divide-by-Zero ($D_1$): This is not a division operation. The flag is not raised. $D_1 = 0$.\n    - Overflow ($O_1$): Operations involving infinities as operands that produce an infinite result are considered exact and do not cause overflow. The flag is not raised. $O_1 = 0$.\n    - Underflow ($U_1$): The result is not a tiny subnormal number. The flag is not raised. $U_1 = 0$.\n    - Inexact ($X_1$): The result $+\\infty$ is an exact representation. The flag is not raised. $X_1 = 0$.\n\nThe flag vector is $(0, 0, 0, 0, 0)$. The integer code $c_1$ is calculated as:\n$$c_1 = 16 \\cdot I_1 + 8 \\cdot D_1 + 4 \\cdot O_1 + 2 \\cdot U_1 + 1 \\cdot X_1 = 16 \\cdot 0 + 8 \\cdot 0 + 4 \\cdot 0 + 2 \\cdot 0 + 1 \\cdot 0 = 0$$\n\n**Operation 2: $+\\infty - +\\infty$**\n\nThis operation is equivalent to $+\\infty + (-\\infty)$. This is an indeterminate form.\n- **Result Category**: The IEEE 754 standard defines that the subtraction of two infinities of the same sign is an invalid operation. The result is a quiet Not a Number (qNaN).\n- **Exception Flags**:\n    - Invalid Operation ($I_2$): This operation is explicitly defined as invalid. The flag is raised. $I_2 = 1$.\n    - Divide-by-Zero ($D_2$): Not a division. $D_2 = 0$.\n    - Overflow ($O_2$): No overflow. $O_2 = 0$.\n    - Underflow ($U_2$): No underflow. $U_2 = 0$.\n    - Inexact ($X_2$): The invalid operation exception takes precedence, and no other flags are typically set for this case. The operation doesn't involve rounding in the traditional sense. The flag is not raised. $X_2 = 0$.\n\nThe flag vector is $(1, 0, 0, 0, 0)$. The integer code $c_2$ is:\n$$c_2 = 16 \\cdot 1 + 8 \\cdot 0 + 4 \\cdot 0 + 2 \\cdot 0 + 1 \\cdot 0 = 16$$\n\n**Operation 3: $+\\infty \\times 0$**\n\nThis is an indeterminate form. The standard provides a specific outcome for this case.\n- **Result Category**: The multiplication of infinity by zero is an invalid operation. The result is a quiet NaN. We assume the '0' operand refers to $+0$, but the result would be the same for $-0$.\n- **Exception Flags**:\n    - Invalid Operation ($I_3$): The operation is defined as invalid. The flag is raised. $I_3 = 1$.\n    - Divide-by-Zero ($D_3$): Not a division. $D_3 = 0$.\n    - Overflow ($O_3$): No overflow. $O_3 = 0$.\n    - Underflow ($U_3$): No underflow. $U_3 = 0$.\n    - Inexact ($X_3$): The invalid operation flag is raised, taking precedence. The flag is not raised. $X_3 = 0$.\n\nThe flag vector is $(1, 0, 0, 0, 0)$. The integer code $c_3$ is:\n$$c_3 = 16 \\cdot 1 + 8 \\cdot 0 + 4 \\cdot 0 + 2 \\cdot 0 + 1 \\cdot 0 = 16$$\n\n**Operation 4: $0 / 0$**\n\nThis is the canonical indeterminate form.\n- **Result Category**: The division of zero by zero is an invalid operation. The result is a quiet NaN.\n- **Exception Flags**:\n    - Invalid Operation ($I_4$): The operation is defined as invalid. The flag is raised. $I_4 = 1$.\n    - Divide-by-Zero ($D_4$): The divide-by-zero flag is specifically for division of a finite non-zero number by zero. For $0/0$, the invalid operation exception is raised instead. $D_4 = 0$.\n    - Overflow ($O_4$): No overflow. $O_4 = 0$.\n    - Underflow ($U_4$): No underflow. $U_4 = 0$.\n    - Inexact ($X_4$): The invalid operation flag is raised, taking precedence. The flag is not raised. $X_4 = 0$.\n\nThe flag vector is $(1, 0, 0, 0, 0)$. The integer code $c_4$ is:\n$$c_4 = 16 \\cdot 1 + 8 \\cdot 0 + 4 \\cdot 0 + 2 \\cdot 0 + 1 \\cdot 0 = 16$$\n\n**Aggregate Checksum Calculation**\n\nNow we compute the final checksum $S$ using the provided formula and the calculated values for $c_1, c_2, c_3, c_4$.\n$$S = c_1 + 3\\,c_2 + 9\\,c_3 + 27\\,c_4$$\nSubstituting the values:\n$$S = 0 + 3 \\cdot 16 + 9 \\cdot 16 + 27 \\cdot 16$$\nWe can factor out $16$:\n$$S = (0 + 3 + 9 + 27) \\cdot 16$$\n$$S = 39 \\cdot 16$$\n$$S = 624$$", "answer": "$$\\boxed{624}$$", "id": "3641973"}, {"introduction": "This final practice challenges you to synthesize your knowledge of representation and arithmetic behavior into a clever, practical algorithm. Faced with architectural constraints—no branch unit or dedicated comparator—you will design a 'branchless' method to detect infinities and NaNs. This problem reveals how a deep understanding of the properties of special values, such as the unique result of the operation $x - x$ for non-finite numbers, can lead to highly efficient and innovative solutions in low-level programming. [@problem_id:3642921]", "problem": "Consider a system that implements the Institute of Electrical and Electronics Engineers (IEEE) $754$ single-precision binary floating-point format. A single-precision value $x$ is encoded as a $32$-bit word partitioned into a sign bit $s$, an exponent field $e$ of $8$ bits, and a fraction (mantissa) field $f$ of $23$ bits. For single precision, special values are defined by the following widely accepted facts: an exponent of all ones, i.e., $e = 2^8 - 1$, indicates either Not a Number (NaN) or infinity $\\infty$; specifically, $f = 0$ indicates $\\pm\\infty$, and $f \\neq 0$ indicates NaN. Arithmetic with NaN yields NaN, and $\\infty - \\infty$ yields NaN. For any finite $x$, $x - x$ yields $\\pm 0$ (a signed zero). Subnormal numbers are finite.\n\nYou are given a simple in-order pipeline with the following resources and latencies:\n- One floating-point adder/subtractor pipeline with latency $L_{\\text{fp}} = 3$ cycles and throughput $1$ result per cycle (a new operation can be issued every cycle).\n- One integer Arithmetic Logic Unit (ALU) that supports bitwise operations, shifts, and integer comparisons, each with latency $1$ cycle; single-issue (at most one integer operation can be executed per cycle).\n- A bitcast between floating-point and integer domains, denoted $\\mathrm{bits}(\\cdot)$, which reinterprets the register contents without data movement and is considered $0$ cycles.\n- No branch unit and no floating-point comparator; boolean outputs must be produced by integer bit-probes and logical composition without control-flow branches.\n\nDesign a branchless algorithm that, for an input single-precision $x$, sets two boolean outputs $isNaN$ and $isInf$ to correctly indicate whether $x$ is NaN or infinity, respectively, for all IEEE $754$ single-precision inputs (including $\\pm\\infty$, quiet/signaling NaNs, subnormals, and $\\pm 0$), using only the allowed operations. The algorithm must use subtraction (e.g., $x - x$) and bit probes of fields extracted from the bit patterns. Map your design to the datapath operations and provide the total cycle count until both outputs are valid.\n\nWhich option below both meets the branchless design requirements and is correct for all cases, with a consistent datapath schedule and total cycle count?\n\nA. Issue the floating-point subtract $y = x - x$ at cycle $0$; $y$ is available at cycle $3$. In the integer ALU, precompute from $x$: at cycle $0$ compute $f_{x} = \\text{bits}(x) \\text{  } (2^{23} - 1)$; at cycle $1$ compute $f_{\\text{eq0}} = (f_{x} == 0)$. After $y$ is available, at cycle $3$ compute $t = \\text{bits}(y) \\gg 23$; at cycle $4$ compute $e_{y} = t \\text{  } (2^{8} - 1)$; at cycle $5$ compute $expAllOnes_{y} = (e_{y} == 2^{8} - 1)$; at cycle $6$ compute $f_{y} = \\text{bits}(y) \\text{  } (2^{23} - 1)$; at cycle $7$ compute $fracNonZero_{y} = (f_{y} \\neq 0)$; at cycle $8$ compute $isNaN_{y} = expAllOnes_{y} \\wedge fracNonZero_{y}$; at cycle $9$ compute $isInf = isNaN_{y} \\wedge f_{\\text{eq0}}$; at cycle $10$ compute $f_{\\text{ne0}} = \\neg f_{\\text{eq0}}$; at cycle $11$ compute $isNaN = isNaN_{y} \\wedge f_{\\text{ne0}}$. Total cycles to valid outputs: $12$. This classifies infinity via $f_{x} == 0$ when $y$ indicates NaN, and classifies NaN via $f_{x} \\neq 0$ when $y$ indicates NaN.\n\nB. Issue $y = x - x$ at cycle $0$; $y$ at cycle $3$. In the integer ALU, precompute from $x$: at cycle $0$ compute $f_{x} = \\text{bits}(x) \\text{  } (2^{23} - 1)$; at cycle $1$ compute $f_{\\text{eq}0} = (f_{x} == 0)$. After $y$ is available, detect zero by probing $y$: at cycle $3$ compute $t = \\text{bits}(y) \\gg 23$; at cycle $4$ compute $e_{y} = t \\text{  } (2^{8} - 1)$; at cycle $5$ compute $e_{\\text{eq}0} = (e_{y} == 0)$; at cycle $6$ compute $f_{y} = \\text{bits}(y) \\text{  } (2^{23} - 1)$; at cycle $7$ compute $f_{\\text{eq0}}^{(y)} = (f_{y} == 0)$; at cycle $8$ compute $isZeroY = e_{\\text{eq}0} \\wedge f_{\\text{eq0}}^{(y)}$; at cycle $9$ compute $isInf = isZeroY \\wedge f_{\\text{eq}0}$; at cycle $10$ compute $isNaN = \\neg isInf$. Total cycles: $11$. This uses zero detection on $y$ combined with $f_{x} == 0$ to recognize infinity.\n\nC. Do not use subtraction; directly bit-probe $x$. In the integer ALU: at cycle $0$ compute $t = \\text{bits}(x) \\gg 23$; at cycle $1$ compute $e_{x} = t \\text{  } (2^{8} - 1)$; at cycle $2$ compute $expAllOnes_{x} = (e_{x} == 2^{8} - 1)$; at cycle $3$ compute $f_{x} = \\text{bits}(x) \\text{  } (2^{23} - 1)$; at cycle $4$ compute $f_{\\text{eq}0} = (f_{x} == 0)$; at cycle $5$ compute $isInf = expAllOnes_{x} \\wedge f_{\\text{eq}0}$; at cycle $6$ compute $f_{\\text{ne0}} = (f_{x} \\neq 0)$; at cycle $7$ compute $isNaN = expAllOnes_{x} \\wedge f_{\\text{ne0}}$. Total cycles: $8$.\n\nD. Issue $y = x - x$ at cycle $0$; $y$ at cycle $3$. In the integer ALU, at cycle $3$ compute $t = \\text{bits}(y) \\gg 23$; at cycle $4$ compute $e_{y} = t \\text{  } (2^{8} - 1)$; at cycle $5$ compute $expAllOnes_{y} = (e_{y} == 2^{8} - 1)$; at cycle $6$ compute $f_{y} = \\text{bits}(y) \\text{  } (2^{23} - 1)$; at cycle $7$ compute $f_{\\text{eq0}}^{(y)} = (f_{y} == 0)$; at cycle $8$ compute $isNaN_{y} = expAllOnes_{y} \\wedge \\neg f_{\\text{eq0}}^{(y)}$; at cycle $9$ set $isInf = isNaN_{y}$ and at cycle $10$ set $isNaN = \\neg isInf$. Total cycles: $11$.\n\nSelect the option that yields a branchless, subtraction-based, bit-probe algorithm that correctly distinguishes NaN and $\\infty$ with the stated schedule and cycle count for all IEEE $754$ single-precision inputs.", "solution": "The problem statement has been critically validated and is determined to be valid. It is scientifically grounded in the IEEE $754$ standard, well-posed, objective, and self-contained. The constraints on the datapath are clear and sufficient to design and evaluate the required algorithm.\n\nThe task is to design a branchless algorithm to identify if a single-precision floating-point number $x$ is a Not a Number (NaN) or infinity ($\\infty$) using a specific set of hardware resources, primarily a floating-point subtractor and an integer ALU. The core of the problem lies in distinguishing finite numbers, infinities, and NaNs without dedicated floating-point comparison instructions or conditional branches.\n\nThe fundamental principle of the required subtraction-based algorithm rests on the behavior of the operation $y = x - x$:\n1.  If $x$ is any finite number (normalized, subnormal, or zero), the result of $x - x$ is defined to be $+0$ or $-0$. The bit representation of signed zero has an exponent field of all zeros ($e = 0$) and a fraction field of all zeros ($f = 0$).\n2.  If $x$ is $\\pm\\infty$, the operation is $\\infty - \\infty$, which is an invalid operation that, by the IEEE $754$ standard, must produce a NaN.\n3.  If $x$ is a NaN (either quiet or signaling), any arithmetic operation involving it as an operand, such as $x-x$, results in a NaN.\n\nFrom this, we deduce a crucial separation: the result $y = x - x$ is a NaN if and only if the input $x$ is non-finite (i.e., $\\pm\\infty$ or NaN). If $x$ is finite, $y$ is $\\pm 0$.\n\nTherefore, the first part of the algorithm is to compute $y = x - x$ and then test if $y$ is a NaN. A number is a NaN if its exponent field is all ones ($e = 2^8 - 1 = 255$) and its fraction field is non-zero ($f \\neq 0$). We can construct a boolean flag, let us call it `is_y_a_NaN`, using allowed integer bitwise operations on the bit representation of $y$, $\\mathrm{bits}(y)$.\n`is_y_a_NaN` = `(exponent_of(y) == 255) AND (fraction_of(y) != 0)`.\nThis flag `is_y_a_NaN` will be `true` if $x \\in \\{\\pm\\infty, \\text{NaN}\\}$ and `false` if $x$ is finite.\n\nThis successfully separates finite from non-finite numbers. The second part of the algorithm must distinguish between $\\infty$ and NaN, given that we have already established $x$ is non-finite (i.e., `is_y_a_NaN` is `true`). This distinction can only be made by inspecting the bit pattern of the original input, $x$.\nAccording to the IEEE $754$ standard:\n-   A value is $\\pm\\infty$ if its exponent is all ones ($e=255$) and its fraction is zero ($f=0$).\n-   A value is a NaN if its exponent is all ones ($e=255$) and its fraction is non-zero ($f \\neq 0$).\n\nTherefore, we can check the fraction field of $x$. Let's define a boolean flag `is_x_frac_zero` = `(fraction_of(x) == 0)`.\nCombining these two pieces of information yields the final logic:\n-   `isInf` = `is_y_a_NaN AND is_x_frac_zero`. A number is infinity if it's non-finite and its fraction part is zero.\n-   `isNaN` = `is_y_a_NaN AND (NOT is_x_frac_zero)`. A number is a NaN if it's non-finite and its fraction part is non-zero.\n\nThis logic correctly classifies all possible IEEE $754$ single-precision values. Now, we evaluate each option.\n\n### Option-by-Option Analysis\n\n**A. Issue the floating-point subtract $y = x - x$ at cycle $0$; $y$ is available at cycle $3$. In the integer ALU, precompute from $x$: at cycle $0$ compute $f_{x} = \\text{bits}(x) \\text{  } (2^{23} - 1)$; at cycle $1$ compute $f_{\\text{eq0}} = (f_{x} == 0)$. After $y$ is available, at cycle $3$ compute $t = \\text{bits}(y) \\gg 23$; at cycle $4$ compute $e_{y} = t \\text{  } (2^{8} - 1)$; at cycle $5$ compute $expAllOnes_{y} = (e_{y} == 2^{8} - 1)$; at cycle $6$ compute $f_{y} = \\text{bits}(y) \\text{  } (2^{23} - 1)$; at cycle $7$ compute $fracNonZero_{y} = (f_{y} \\neq 0)$; at cycle $8$ compute $isNaN_{y} = expAllOnes_{y} \\wedge fracNonZero_{y}$; at cycle $9$ compute $isInf = isNaN_{y} \\wedge f_{\\text{eq0}}$; at cycle $10$ compute $f_{\\text{ne0}} = \\neg f_{\\text{eq0}}$; at cycle $11$ compute $isNaN = isNaN_{y} \\wedge f_{\\text{ne0}}$. Total cycles to valid outputs: $12$. This classifies infinity via $f_{x} == 0$ when $y$ indicates NaN, and classifies NaN via $f_{x} \\neq 0$ when $y$ indicates NaN.**\n\n-   **Logic**: The logic implemented here is identical to the correct logic derived above. The flag `isNaN_y` corresponds to our `is_y_a_NaN`. The flag `f_eq0` corresponds to our `is_x_frac_zero`. The final outputs are computed as `isInf = isNaN_y  f_eq0` and `isNaN = isNaN_y  !f_eq0`. This logic is correct for all cases.\n-   **Schedule and Cycle Count**: The floating-point operation `y = x - x` is issued at cycle $0$ and, with a latency of $L_{\\text{fp}} = 3$, its result is available at the beginning of cycle $3$. The integer ALU is single-issue with $1$-cycle latency. Let's verify the provided schedule:\n    -   C0: `fx = ...` (Dep: `x`). OK. Result available at start of C1.\n    -   C1: `f_eq0 = ...` (Dep: `fx`). OK. Result available at start of C2.\n    -   C2: ALU idle.\n    -   C3: `t = ...` (Dep: `y`). OK, `y` is available at C3. Result available at start of C4.\n    -   C4: `ey = ...` (Dep: `t`). OK. Result available at start of C5.\n    -   C5: `expAllOnes_y = ...` (Dep: `ey`). OK. Result available at start of C6.\n    -   C6: `fy = ...` (Dep: `y`). OK. Result available at start of C7.\n    -   C7: `fracNonZero_y = ...` (Dep: `fy`). OK. Result available at start of C8.\n    -   C8: `isNaN_y = ...` (Deps: `expAllOnes_y` available at C6, `fracNonZero_y` available at C8). OK. Result available at start of C9.\n    -   C9: `isInf = ...` (Deps: `isNaN_y` available at C9, `f_eq0` available at C2). OK. `isInf` result available at start of C10.\n    -   C10: `f_ne0 = ...` (Dep: `f_eq0` available at C2). OK. Result available at start of C11.\n    -   C11: `isNaN = ...` (Deps: `isNaN_y` available at C9, `f_ne0` available at C11). OK. `isNaN` result available at start of C12.\nThe schedule respects all data dependencies and hardware constraints. The final output, `isNaN`, is available at the start of cycle $12$. Thus, both outputs are valid after $12$ cycles have elapsed (cycles $0$ through $11$). The total cycle count of $12$ is consistent.\n\n-   **Verdict**: **Correct**.\n\n**B. Issue $y = x - x$... detect zero by probing $y$... `isInf = isZeroY  f_eq0`... `isNaN = !isInf`.**\n\n-   **Logic**: This option computes `isZeroY` to detect if $y$ is zero. This is `true` if $x$ is finite and `false` if $x$ is non-finite. Then it computes `isInf = isZeroY  f_eq0`. Let's test this with a finite number, for example, $x=1.0$. The bit pattern is `0x3F800000`. The fraction field is zero. `x` is finite, so `y=x-x=0`, and `isZeroY` will be `true`. The fraction of $x$ is zero, so `f_eq0` is `true`. The algorithm calculates `isInf = true  true = true`. This is incorrect, as $x=1.0$ is not infinity.\n\n-   **Verdict**: **Incorrect**. The logic is fundamentally flawed.\n\n**C. Do not use subtraction; directly bit-probe $x$. ...Total cycles: $8$.**\n\n-   **Logic**: This approach directly checks the exponent and fraction fields of $x$ to determine if it is `Inf` or `NaN`. The logic `isInf = (e_x == 255)  (f_x == 0)` and `isNaN = (e_x == 255)  (f_x != 0)` is a correct way to identify these special values from their bit patterns.\n-   **Constraint Violation**: The problem statement explicitly requires the algorithm to \"use subtraction (e.g., $x - x$)\". This option violates this constraint.\n\n-   **Verdict**: **Incorrect**. It fails to meet a mandatory design requirement.\n\n**D. Issue $y = x - x$... `isInf = isNaN_y` and ... `isNaN = !isInf`.**\n\n-   **Logic**: This option correctly computes `isNaN_y`, which is `true` if $x$ is $\\infty$ or NaN. However, it then sets `isInf = isNaN_y`. This means it will report `isInf = true` for both infinity and NaN inputs. For an input $x$ that is a NaN, `isNaN_y` will be `true`, causing `isInf` to be incorrectly set to `true`. Furthermore, it computes `isNaN = !isInf`, so for a NaN input, it would report `isNaN = false`.\n\n-   **Verdict**: **Incorrect**. The logic is fundamentally flawed as it cannot distinguish between infinity and NaN.\n\nBased on the analysis, only option A presents a correct algorithm that satisfies all constraints, with a self-consistent schedule and cycle count.", "answer": "$$\\boxed{A}$$", "id": "3642921"}]}