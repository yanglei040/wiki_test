{"hands_on_practices": [{"introduction": "To truly master the hexadecimal system, we must first be able to translate it into the more familiar decimal system. This foundational skill involves understanding the principles of positional notation, where each digit's value is determined by its position and the base of the system. This exercise will guide you through converting a hexadecimal number with a fractional part, reinforcing the core concept of weighted positional values [@problem_id:1941855].", "problem": "In digital systems and computer science, the hexadecimal number system (base-16) is a positional numeral system that represents numbers using a base of 16. It uses sixteen distinct symbols, most often the symbols \"0\"–\"9\" to represent values zero to nine, and \"A\"–\"F\" to represent values ten to fifteen.\n\nConsider the hexadecimal number $A.4C_{16}$. Your task is to convert this number into its equivalent decimal (base-10) representation. Express your final answer as a decimal number.", "solution": "In a base-$b$ positional system, a numeral with integer digits $d_{k}\\dots d_{0}$ and fractional digits $f_{1}f_{2}\\dots$ has value\n$$\n\\sum_{i=0}^{k} d_{i} b^{i} + \\sum_{j=1}^{\\infty} f_{j} b^{-j}.\n$$\nFor hexadecimal, $b=16$. The hexadecimal digits map to decimal values with $A=10$, $C=12$. Thus for $A.4C_{16}$,\n$$\nA.4C_{16} = 10 \\cdot 16^{0} + 4 \\cdot 16^{-1} + 12 \\cdot 16^{-2}.\n$$\nUsing $16^{0}=1$, $16^{-1}=\\frac{1}{16}$, and $16^{-2}=\\frac{1}{256}$, this becomes\n$$\n10 + \\frac{4}{16} + \\frac{12}{256} = 10 + \\frac{1}{4} + \\frac{3}{64}.\n$$\nCombine the fractional terms with common denominator $64$:\n$$\n10 + \\frac{16}{64} + \\frac{3}{64} = 10 + \\frac{19}{64} = \\frac{659}{64}.\n$$\nConverting to a decimal yields\n$$\n\\frac{659}{64} = 10.296875.\n$$\nTherefore, the decimal representation of $A.4C_{16}$ is $10.296875$.", "answer": "$$\\boxed{10.296875}$$", "id": "1941855"}, {"introduction": "Beyond simple representation, hexadecimal is the language of the processor's internal state and arithmetic operations. This practice delves into a critical aspect of CPU arithmetic: detecting overflow in two’s complement addition. By analyzing the signs of the operands and the result in hexadecimal, you will learn to identify when a calculation has exceeded the representable range of the system, a crucial skill for writing reliable low-level code [@problem_id:3647851].", "problem": "In a computer system that uses $n$-bit two’s complement representation for signed integers, the representable range is from $-2^{n-1}$ to $2^{n-1}-1$, the most significant bit (MSB) encodes the sign, and binary addition is performed modulo $2^{n}$ with carries propagated across bit positions. Overflow in signed addition occurs when the true mathematical sum of two representable operands lies outside the representable range, even though the hardware returns the modulo-$2^{n}$ wrap-around result. Using this fundamental base, derive the overflow condition for two’s complement addition in terms of sign-bit behavior and carry propagation, and then test your derivation on the $32$-bit hexadecimal sum $0x7FFFFFFF + 0x00000001 \\rightarrow 0x80000000$. Select all statements that correctly characterize the overflow condition and its manifestation in the given test.\n\nA. In $n$-bit two’s complement addition, overflow occurs if and only if the carry into the most significant bit differs from the carry out of the most significant bit; for the test $0x7FFFFFFF + 0x00000001$, this condition holds and overflow is raised.\n\nB. Overflow occurs whenever there is a carry out of the most significant bit, regardless of the carry into it; for the test $0x7FFFFFFF + 0x00000001$, the carry out of the most significant bit is $1$, so overflow is raised.\n\nC. Overflow occurs only when adding operands of opposite sign; since $0x7FFFFFFF$ and $0x00000001$ are both positive, there is no overflow in the test.\n\nD. In two’s complement, when adding two positive numbers, if the result has a $1$ in the sign bit, overflow occurs because the true sum exceeds $2^{n-1}-1$; in the example, both operands are positive and the result has sign bit $1$, so overflow is raised.\n\nE. The hexadecimal result $0x80000000$ represents $-2^{31}$ in $32$-bit two’s complement; since the true sum $2^{31}-1 + 1$ equals $2^{31}$, which is outside the representable positive range, the hardware wraps modulo $2^{32}$ to $-2^{31}$ and sets overflow; equivalently, overflow is indicated when the result’s sign differs from the operands’ common sign.\n\nF. No overflow occurs because $0x80000000$ is a valid $32$-bit two’s complement encoding, and overflow depends only on whether the returned bit pattern is representable, not on the true sum.", "solution": "To determine which statements are correct, we first analyze the given operation and the fundamental conditions for two's complement overflow.\n\n**Test Case Analysis:**\nThe operation is the addition of two 32-bit signed integers:\n-   Operand A: $0x7FFFFFFF$. This is the largest positive 32-bit integer, with a value of $2^{31} - 1$. Its sign bit is $0$.\n-   Operand B: $0x00000001$. This has a value of $1$. Its sign bit is $0$.\n-   True Mathematical Sum: $(2^{31} - 1) + 1 = 2^{31}$.\n-   Representable Range: For a 32-bit signed integer, the range is $[-2^{31}, 2^{31} - 1]$.\n-   Conclusion: The true sum $2^{31}$ is outside the representable range, so **overflow must occur**.\n-   Hardware Result: The binary addition `0111...1111` + `0000...0001` yields `1000...0000`, which is $0x80000000$. This bit pattern represents $-2^{31}$ in two's complement, which is the most negative number.\n\n**Overflow Detection Rules:**\n1.  **Sign-based rule:** Overflow occurs if and only if the two operands have the same sign, and the result has the opposite sign. In our case, we add two positive numbers and get a negative result. This rule indicates overflow.\n2.  **Carry-based rule:** Overflow occurs if and only if the carry into the most significant bit (MSB) position differs from the carry out of the MSB position ($c_{in} \\neq c_{out}$).\n    -   In our sum, adding the 31 lower bits (all 1s) to 1 produces a carry of 1 into the MSB (bit 31). So, $c_{in} = 1$.\n    -   At the MSB, the addition is `0 + 0 + c_in` = `0 + 0 + 1` = `1`. The sum bit is 1, and the carry out is 0. So, $c_{out} = 0$.\n    -   Since $c_{in} = 1$ and $c_{out} = 0$, they are different. This rule also indicates overflow.\n\n**Evaluating the Options:**\n\n-   **A. Correct.** This statement accurately describes the carry-based overflow detection rule ($c_{in} \\neq c_{out}$). Our analysis confirms that for the given test, $c_{in}=1$ and $c_{out}=0$, so the condition holds and overflow is correctly identified.\n\n-   **B. Incorrect.** This describes the overflow condition for *unsigned* arithmetic. Furthermore, it incorrectly claims the carry-out is 1 for the test case, when it is actually 0.\n\n-   **C. Incorrect.** This is the opposite of the truth. Overflow can *only* occur when adding operands of the *same* sign. It is impossible when signs are different.\n\n-   **D. Correct.** This statement accurately describes a specific case of the sign-based rule: adding two positive numbers and getting a negative result (sign bit of 1) indicates overflow. The example perfectly matches this case.\n\n-   **E. Correct.** This statement provides a complete and accurate summary. It correctly identifies the numerical values of the result ($ -2^{31}$) and the true sum ($2^{31}$), explains that the true sum is out of range, and correctly describes the wrap-around behavior. It also correctly provides the equivalent sign-based overflow condition.\n\n-   **F. Incorrect.** This statement misunderstands the definition of overflow. Overflow is not about whether the resulting bit pattern is valid (it always is), but whether that pattern represents the true mathematical sum. Since the true sum ($2^{31}$) is not representable, and the hardware returns a different value ($-2^{31}$), overflow has occurred.\n\nThe correct statements are A, D, and E.", "answer": "$$\\boxed{ADE}$$", "id": "3647851"}, {"introduction": "Hexadecimal notation shines as a compact and human-readable way to perform precise, bit-level data manipulation. This hands-on problem demonstrates how to use bitwise operations and hexadecimal masks to insert a specific value into a bit field within a 32-bit register. Mastering this technique is essential for tasks ranging from configuring hardware registers to programming device drivers [@problem_id:3647874].", "problem": "In a Central Processing Unit (CPU) data path, mask-based field insertion is routinely used to set specific bit fields in a word while leaving all other bits unchanged. Consider a word-sized register of width $32$ bits, with bit positions numbered from $0$ (least significant bit) to $31$ (most significant bit). Let $x$ denote the content of the register, initially $x = 0x12345678$. The goal is to set bits $8$ through $11$ of $x$ equal to the hexadecimal nibble $0xA$, and to leave all other bits unchanged.\n\nStarting only from the definitions of the bitwise operations bitwise AND ($\\&$), bitwise OR ($|$), bitwise NOT ($\\sim$), and left shift ($<<$), and from the positional meaning of hexadecimal digits over binary (each hexadecimal digit equals four contiguous bits), derive a correct mask-and-insert procedure from first principles that accomplishes the required field insertion. Then apply your derived procedure to the given $x$ to compute the resulting register value.\n\nExpress your final answer as a single hexadecimal integer with the prefix $0x$. No rounding is required.", "solution": "The task is to modify a specific bit field within a $32$-bit register. Let the initial content of the register be denoted by the variable $x$. The goal is to set bits $8$ through $11$ to the hexadecimal value $0xA$, while preserving the state of all other bits. This operation is commonly known as field insertion and can be derived from first principles using bitwise logical operations.\n\nThe procedure consists of two fundamental steps:\n1.  **Clearing the target bit field**: First, we must set the bits in the target field (bits $8$ through $11$) to $0$. This ensures that the subsequent insertion step does not corrupt the final value. This is achieved using a bitwise AND ($&$) operation with a \"clearing mask\".\n2.  **Inserting the new value**: Second, we must place the new value into the now-cleared target field. This is accomplished using a bitwise OR ($|$) operation with an \"insertion value\".\n\nLet's derive the necessary masks and values from the problem statement. The register width is $32$ bits. The target field spans from bit $i=8$ to bit $j=11$. The width of this field is $w = j - i + 1 = 11 - 8 + 1 = 4$ bits. The new value for this field is $v = 0xA$.\n\n**Step 1: Derivation of the Clearing Mask**\n\nTo clear the target field in $x$, we use a clearing mask, let's call it $M_{clear}$. This mask must have $0$s in bit positions $8$ through $11$ and $1$s in all other $28$ positions. Performing $x \\; \\& \\; M_{clear}$ will set the target bits to $0$ while leaving all other bits of $x$ unchanged (since $b \\; \\& \\; 1 = b$ and $b \\; \\& \\; 0 = 0$ for any bit $b$).\n\nWe can construct $M_{clear}$ by first defining a mask that has $1$s only in the target bit field, and then taking its bitwise complement ($\\sim$). Let's call this intermediate mask $M_{field}$. $M_{field}$ has $4$ consecutive $1$s starting at bit position $8$. A block of $w$ ones is represented by the integer $2^w - 1$. For $w=4$, this is $2^4 - 1 = 15$, which is $0xF$ in hexadecimal.\n\nTo position these $1$s at the correct location, we must left-shift ($<<$) this value by the starting bit position, $i=8$.\n$$M_{field} = (0xF) << 8$$\nIn a $32$-bit system, a hexadecimal number is a sequence of $8$ nibbles (4-bit groups). A left shift by $8$ bits corresponds to shifting by two hexadecimal positions.\nThe hexadecimal constant $0xF$ is represented in $32$ bits as $0x0000000F$.\n$$M_{field} = 0x0000000F << 8 = 0x00000F00$$\nThe clearing mask $M_{clear}$ is the bitwise NOT of $M_{field}$:\n$$M_{clear} = \\sim M_{field} = \\sim (0x00000F00)$$\nPerforming the bitwise NOT on this $32$-bit value gives:\n$$M_{clear} = 0xFFFFF0FF$$\nThe operation to clear the field in $x$ is thus $x \\; \\& \\; 0xFFFFF0FF$.\n\n**Step 2: Derivation of the Insertion Value**\n\nThe new value to be inserted is $v = 0xA$. This $4$-bit value must be positioned correctly within the $32$-bit word so that it aligns with the target field (bits $8-11$). This is also achieved with a left shift operation. Let the prepared value be $V_{insert}$.\n$$V_{insert} = v << i = 0xA << 8$$\nThe hexadecimal constant $0xA$ is represented in $32$ bits as $0x0000000A$.\n$$V_{insert} = 0x0000000A << 8 = 0x00000A00$$\nThis value will be combined with the cleared version of $x$ using a bitwise OR operation. Since the target field in the cleared $x$ is all zeros, the OR operation will insert the bits of $V_{insert}$ without affecting any other bits (since $b \\; | \\; 0 = b$ for any bit $b$).\n\n**The Complete Procedure**\n\nCombining the two steps, the final value, $x_{new}$, is calculated as:\n$$x_{new} = (x \\; \\& \\; M_{clear}) \\; | \\; V_{insert}$$\nSubstituting the derived expressions:\n$$x_{new} = (x \\; \\& \\; (\\sim(0xF << 8))) \\; | \\; (0xA << 8)$$\n\n**Application to the Given Data**\n\nNow we apply this procedure to the given initial register content $x = 0x12345678$.\n\nFirst, we clear the target field:\n$$x_{cleared} = x \\; \\& \\; M_{clear} = 0x12345678 \\; \\& \\; 0xFFFFF0FF$$\nThis operation preserves all hexadecimal digits of $x$ where the mask has a digit of $F$, and zeroes out the digit where the mask has a digit of $0$. The mask has a $0$ at the position corresponding to bits $8-11$, which aligns with the digit '$6$' in $0x12345678$.\n$$x_{cleared} = 0x12345078$$\n\nNext, we insert the new value:\n$$x_{new} = x_{cleared} \\; | \\; V_{insert} = 0x12345078 \\; | \\; 0x00000A00$$\nThe OR operation places the value $A$ into the third nibble from the right (bits $8-11$), which was previously cleared to $0$.\n$$x_{new} = 0x12345A78$$\n\nThe resulting register value is $0x12345A78$.", "answer": "$$\\boxed{0x12345A78}$$", "id": "3647874"}]}