{"hands_on_practices": [{"introduction": "Multiplexers, or MUXes, are fundamental components in digital systems, acting like programmable switches. While often implemented using standard AND-OR logic, this exercise explores an alternative design using the unique properties of the XOR gate [@problem_id:3688749]. By transforming the MUX's Boolean expression, you will gain insight into the versatility of XOR and analyze the practical performance trade-offs between different but functionally equivalent circuit implementations.", "problem": "A $2$-to-$1$ Multiplexer (Multiplexer (MUX)) with select input $s$ and data inputs $a$ and $b$ is specified by the Boolean function $z=(s \\land a)\\lor(\\overline{s}\\land b)$. Using only fundamental Boolean algebra and the defining properties of the exclusive OR (exclusive OR (XOR)) operation—commutativity, associativity, identity $x\\oplus 0=x$, and self-inverse $x\\oplus x=0$—derive an equivalent expression for $z$ that employs an XOR-centric structure in which one of the inputs is $b$ and the other is a product of $s$ with an XOR of $a$ and $b$. Then, within a standard cell model that permits only $2$-input gates $\\{\\text{AND}, \\text{OR}, \\text{XOR}\\}$ and the inverter, define the gate depth of a circuit as the maximum number of gate levels on any input-to-output path, counting an inverter as one level. Determine the gate depth for both the sum-of-products implementation and your XOR-centric implementation.\n\nAssume the following propagation delays for $2$-input gates and the inverter: $t_{\\text{AND}}=45\\,\\text{ps}$, $t_{\\text{OR}}=45\\,\\text{ps}$, $t_{\\text{XOR}}=110\\,\\text{ps}$, $t_{\\text{INV}}=20\\,\\text{ps}$. Model the worst-case propagation delay as the sum of delays along the longest logic chain on a critical input-to-output path, and assume inputs change simultaneously.\n\nLet $T_{\\text{SOP}}$ be the worst-case propagation delay of the sum-of-products implementation and $T_{\\text{XOR}}$ be that of the XOR-centric implementation you derived. Compute the scalar difference $\\Delta T = T_{\\text{XOR}} - T_{\\text{SOP}}$ and express your final answer in nanoseconds. Round your answer to three significant figures.", "solution": "We begin from the Boolean definition of the $2$-to-$1$ Multiplexer (MUX) with select input $s$ and data inputs $a$ and $b$:\n$$\nz=(s\\land a)\\lor(\\overline{s}\\land b).\n$$\nWe will derive an equivalent XOR-centric form using fundamental properties of the exclusive OR (XOR). The XOR operation satisfies commutativity and associativity, the identity property $x\\oplus 0=x$, and the self-inverse property $x\\oplus x=0$. Additionally, the MUX semantics are that when $s=0$ the output equals $b$, and when $s=1$ the output equals $a$.\n\nConsider the candidate structure $b\\oplus\\big(s\\cdot(a\\oplus b)\\big)$ and verify equivalence by conditioning on $s$:\n- If $s=0$, then\n$b\\oplus\\big(0\\cdot(a\\oplus b)\\big)=b\\oplus 0=b$,\nwhich matches $z=(0\\land a)\\lor(1\\land b)=b$.\n- If $s=1$, then\n$b\\oplus\\big(1\\cdot(a\\oplus b)\\big)=b\\oplus(a\\oplus b)$.\nBy associativity and commutativity of XOR,\n$(b\\oplus b)\\oplus a=0\\oplus a=a$,\nwhich matches $z=(1\\land a)\\lor(0\\land b)=a$.\n\nSince the two expressions agree for both $s=0$ and $s=1$, they are equivalent for all input combinations. Therefore, the XOR-centric form is\n$$\nz=b\\oplus\\big(s\\cdot(a\\oplus b)\\big).\n$$\n\nNext, we compare gate depth for the sum-of-products (SOP) implementation and the XOR-centric implementation under the given gate set.\n\nFor the SOP implementation $z=(s\\land a)\\lor(\\overline{s}\\land b)$:\n- The path from $s$ to $z$ traverses an inverter to form $\\overline{s}$, then a $2$-input AND, then a $2$-input OR. Counting each gate as one level, this path has depth $3$.\n- The path from $a$ to $z$ goes through an AND then an OR, depth $2$; similarly from $b$ through an AND and an OR, depth $2$.\n- The gate depth of the circuit is the maximum over all input-to-output paths, hence depth $3$.\n\nFor the XOR-centric implementation $z=b\\oplus\\big(s\\cdot(a\\oplus b)\\big)$:\n- The computation of $a\\oplus b$ uses one XOR gate (depth $1$ along $a$ and $b$).\n- Multiplying by $s$ adds one AND gate after the inner XOR, so along $a$ (or $b$) a path becomes XOR then AND, which is depth $2$; along $s$ it is just the AND, depth $1$ so far.\n- The final outer XOR with $b$ adds one more level. The longest chain is along $a$ (or the inner $b$) as inner XOR $\\rightarrow$ AND $\\rightarrow$ outer XOR, for a depth of $3$. The direct $b$ input to the outer XOR only traverses that one XOR, but the overall gate depth is determined by the longest chain, which is $3$.\n\nThus, both implementations have gate depth $3$.\n\nNow we compute worst-case propagation delays using the provided per-gate delays. Let $t_{\\text{AND}}=45\\,\\text{ps}$, $t_{\\text{OR}}=45\\,\\text{ps}$, $t_{\\text{XOR}}=110\\,\\text{ps}$, and $t_{\\text{INV}}=20\\,\\text{ps}$.\n\nFor the SOP implementation, the critical path is from $s$ through the inverter, the AND, and the OR:\n$$\nT_{\\text{SOP}}=t_{\\text{INV}}+t_{\\text{AND}}+t_{\\text{OR}}=20\\,\\text{ps}+45\\,\\text{ps}+45\\,\\text{ps}=110\\,\\text{ps}.\n$$\n\nFor the XOR-centric implementation, the critical path is from $a$ (or the inner $b$) through the inner XOR, the AND with $s$, and then the outer XOR:\n$$\nT_{\\text{XOR}}=t_{\\text{XOR}}+t_{\\text{AND}}+t_{\\text{XOR}}=110\\,\\text{ps}+45\\,\\text{ps}+110\\,\\text{ps}=265\\,\\text{ps}.\n$$\n\nThe difference is\n$$\n\\Delta T=T_{\\text{XOR}}-T_{\\text{SOP}}=265\\,\\text{ps}-110\\,\\text{ps}=155\\,\\text{ps}.\n$$\nConverting picoseconds to nanoseconds, using $1\\,\\text{ns}=1000\\,\\text{ps}$,\n$$\n\\Delta T=\\frac{155}{1000}\\,\\text{ns}=0.155\\,\\text{ns}.\n$$\nRounded to three significant figures, the result remains $0.155\\,\\text{ns}$.\n\nTherefore, the requested numeric answer (in nanoseconds) is $0.155$.", "answer": "$$\\boxed{0.155}$$", "id": "3688749"}, {"introduction": "Parity generation is a classic application of XOR gates, essential for error detection in data transmission and storage. This practice tackles the challenge of computing parity across a wide 64-bit bus, comparing a simple, serial 'ripple' design against a parallel 'tree' structure [@problem_id:3688782]. This comparison highlights a crucial principle in digital design: how circuit topology can dramatically impact performance, trading off circuit complexity for significant gains in speed.", "problem": "A pipeline stage must compute the parity of $64$ independent input bits, where parity is defined as the bitwise exclusive-OR (XOR) of all $64$ inputs. Two alternative combinational topologies are under consideration to implement the parity function using only two-input exclusive-OR (XOR) gates and dedicated two-way fan-out buffers:\n\n- Ripple XOR chain: Connect the $64$ inputs in a linear chain of two-input XOR gates so that the output of one XOR feeds one input of the next XOR, producing the parity at the end of the chain.\n\n- Kogge–Stone–style XOR prefix network: Arrange the $64$ inputs in a full parallel reduction in which each logic level combines disjoint pairs by two-input XOR gates, and each subsequent level combines disjoint pairs of the previous level’s results, continuing until a single parity output remains. This reduction pairs signals at each level, thereby halving the number of signals per level until one remains.\n\nAssume the following delay model, which includes the effect of limited fan-out drive using explicit buffers:\n\n- Each two-input XOR gate has propagation delay $t_{\\text{XOR}} = 80\\,\\text{ps}$ when its output drives exactly one gate input in the next level.\n\n- An explicit two-way fan-out buffer cell is used whenever a node’s output must drive two consumers in the next level. This buffer adds propagation delay $t_{b} = 30\\,\\text{ps}$ on the critical path for that signal. The buffer is idealized to produce two replicas of its input signal and is inserted immediately after the producing gate. Ignore wire delay and assume sizing has been chosen so that $t_{\\text{XOR}}$ is load-independent when the buffer is used to enforce two-way fan-out.\n\n- In the ripple XOR chain, each XOR output drives only one XOR input in the next stage, so no fan-out buffers are needed anywhere on the critical path.\n\n- In the Kogge–Stone–style XOR prefix network, there are $\\lceil \\log_{2}(64) \\rceil$ logic levels of two-input XOR gates along the critical path. Further, at each of the first $\\lceil \\log_{2}(64) \\rceil - 1$ levels, the on-path node’s output must be replicated to supply two consumers in the next level, so exactly one two-way fan-out buffer with delay $t_{b}$ lies on the critical path after each of those levels. The final level’s output directly produces the parity result and does not require replication.\n\nUsing only the definitions of the exclusive-OR (XOR) operation and the concept of critical path delay as the maximum sum of gate delays along any input-to-output path, derive the critical path delay for each topology, then compute the ratio of the ripple-chain critical path delay to the Kogge–Stone–style prefix-network critical path delay. Express the final ratio as an exact value with no units.", "solution": "The parity of $64$ inputs is the associative combination $x_{0} \\oplus x_{1} \\oplus \\cdots \\oplus x_{63}$, where $\\oplus$ denotes exclusive-OR (XOR). Because XOR is associative and commutative, we may realize the function either as a linear chain (ripple) or as a parallel reduction (prefix/tree). The critical path delay is the sum of the delays of all elements traversed by the slowest input-to-output path.\n\nFirst, consider the ripple XOR chain. To XOR $64$ inputs using two-input XOR gates in a linear chain, we need $64 - 1 = 63$ XOR gates in sequence. Each XOR gate output drives only one gate input next, so no fan-out buffers are required on the critical path. With the given delay model, the ripple critical path delay is\n$$\nD_{\\text{ripple}} \\;=\\; 63 \\cdot t_{\\text{XOR}} \\;=\\; 63 \\cdot 80\\,\\text{ps} \\;=\\; 5040\\,\\text{ps}.\n$$\n\nNext, consider the Kogge–Stone–style XOR prefix network. A full parallel reduction that halves the number of signals at each level requires $\\lceil \\log_{2}(64) \\rceil$ levels of two-input XOR gates on the critical path. Since $64 = 2^{6}$, we have\n$$\n\\lceil \\log_{2}(64) \\rceil \\;=\\; 6.\n$$\nThus there are $6$ XOR logic levels along the critical path. By the stated constraint, at each of the first $6 - 1 = 5$ levels, the on-path node’s output must be replicated to drive two consumers at the next level, and so one two-way fan-out buffer of delay $t_{b}$ lies on the critical path after each of those levels. The output of the final (sixth) XOR level produces the parity and is not replicated.\n\nTherefore, the Kogge–Stone–style critical path delay is the sum of $6$ XOR delays and $5$ buffer delays:\n$$\nD_{\\text{KS}} \\;=\\; 6 \\cdot t_{\\text{XOR}} \\;+\\; 5 \\cdot t_{b}\n\\;=\\; 6 \\cdot 80\\,\\text{ps} \\;+\\; 5 \\cdot 30\\,\\text{ps}\n\\;=\\; 480\\,\\text{ps} \\;+\\; 150\\,\\text{ps}\n\\;=\\; 630\\,\\text{ps}.\n$$\n\nFinally, the requested ratio of the ripple-chain critical path delay to the Kogge–Stone–style critical path delay is\n$$\n\\frac{D_{\\text{ripple}}}{D_{\\text{KS}}}\n\\;=\\;\n\\frac{5040\\,\\text{ps}}{630\\,\\text{ps}}\n\\;=\\;\n8.\n$$\nThis ratio is exact and dimensionless, as required.", "answer": "$$\\boxed{8}$$", "id": "3688782"}, {"introduction": "The properties of XOR extend beyond simple combinational logic into clever algorithmic tricks used within processor datapaths. This exercise analyzes the well-known 'XOR swap' algorithm, which swaps the contents of two registers without needing a temporary third register [@problem_id:3688756]. Successfully analyzing this algorithm requires careful reasoning about the step-by-step execution in synchronous hardware, including potential pitfalls like register aliasing and data hazards.", "problem": "A synchronous datapath has a register file of width $n$ with two read ports and one write port, and a functional unit that computes bitwise Exclusive OR (XOR), denoted $\\,\\oplus\\,$. Each micro-operation takes one clock cycle: both source registers are read using their values captured at the beginning of the cycle, and the destination register is written at the end of the same cycle. Let $x$ and $y$ be logical register names that may or may not refer to the same physical register (aliasing). Consider the three-step sequence intended to swap $x$ and $y$:\n$x \\leftarrow x \\oplus y$; $y \\leftarrow x \\oplus y$; $x \\leftarrow x \\oplus y$.\nYour task is to reason from first principles—namely, the bitwise truth table of XOR and synchronous register-read/write semantics—about the correctness and hazards of this sequence in hardware.\n\nSelect all statements that are correct.\n\nA. Under the stated single-issue, one-operation-per-cycle semantics, if $x$ and $y$ are distinct physical registers, the sequence completes a correct swap in $3$ cycles without extra storage. If $x$ and $y$ alias the same physical register, both end with the all-zero value because $x \\oplus x = 0$ bitwise.\n\nB. If the three assignments are placed in one clocked block using non-blocking updates in a Hardware Description Language (HDL), then the swap works for all cases, including when $x$ and $y$ alias, because all right-hand sides use pre-clock values and are applied simultaneously.\n\nC. If control erroneously issues the first two assignments in the same clock cycle so that both right-hand sides read the pre-cycle values of $x$ and $y$ and both writes occur together, the intended flow dependence from the first update of $x$ to the second update of $y$ is violated, constituting a Read-After-Write (RAW) hazard; consequently, the swap fails even when $x$ and $y$ are distinct.\n\nD. When $x$ and $y$ alias, the first assignment effectively feeds the same signal to both inputs of an XOR gate; the gate outputs logic high for equal inputs, so the register is driven to the all-ones value rather than zero.", "solution": "### Derivation from First Principles\nLet the initial values of the registers be $x_{init}$ and $y_{init}$. The analysis will proceed by tracing the state of registers $x$ and $y$ through the three-cycle sequence, based on the synchronous read/write semantics. Let $x_i$ and $y_i$ denote the values of the registers at the *start* of cycle $i$.\n\n**Case 1: $x$ and $y$ are distinct physical registers.**\n- **Initial State (Start of Cycle $1$):**\n  - $x_1 = x_{init}$\n  - $y_1 = y_{init}$\n\n- **Cycle $1$: $x \\leftarrow x \\oplus y$**\n  - Values read at the beginning of the cycle: $x_1$ and $y_1$.\n  - Computation: $x_1 \\oplus y_1 = x_{init} \\oplus y_{init}$.\n  - Value written to $x$ at the end of the cycle.\n  - **State at Start of Cycle $2$:**\n    - $x_2 = x_{init} \\oplus y_{init}$\n    - $y_2 = y_1 = y_{init}$ (since $y$ was not written to).\n\n- **Cycle $2$: $y \\leftarrow x \\oplus y$**\n  - Values read at the beginning of the cycle: $x_2$ and $y_2$.\n  - Computation: $x_2 \\oplus y_2 = (x_{init} \\oplus y_{init}) \\oplus y_{init}$.\n  - Using the properties of XOR ($A \\oplus A = 0$ and $A \\oplus 0 = A$): $(x_{init} \\oplus y_{init}) \\oplus y_{init} = x_{init} \\oplus (y_{init} \\oplus y_{init}) = x_{init} \\oplus 0 = x_{init}$.\n  - Value written to $y$ at the end of the cycle.\n  - **State at Start of Cycle $3$:**\n    - $x_3 = x_2 = x_{init} \\oplus y_{init}$ (since $x$ was not written to).\n    - $y_3 = x_{init}$.\n\n- **Cycle $3$: $x \\leftarrow x \\oplus y$**\n  - Values read at the beginning of the cycle: $x_3$ and $y_3$.\n  - Computation: $x_3 \\oplus y_3 = (x_{init} \\oplus y_{init}) \\oplus x_{init}$.\n  - Using the properties of XOR ($A \\oplus A = 0$ and $0 \\oplus B = B$): $(x_{init} \\oplus y_{init}) \\oplus x_{init} = (x_{init} \\oplus x_{init}) \\oplus y_{init} = 0 \\oplus y_{init} = y_{init}$.\n  - Value written to $x$ at the end of the cycle.\n  - **Final State (End of Cycle $3$):**\n    - Final value of $x$ is $y_{init}$.\n    - Final value of $y$ is $x_{init}$ (from cycle $2$).\n\nThe sequence correctly swaps the contents of $x$ and $y$ in $3$ cycles without requiring a temporary register.\n\n**Case 2: $x$ and $y$ are aliases for the same physical register, say $R$.**\nThe sequence becomes: ($1$) $R \\leftarrow R \\oplus R$; ($2$) $R \\leftarrow R \\oplus R$; ($3$) $R \\leftarrow R \\oplus R$.\n\n- **Initial State (Start of Cycle $1$):**\n  - $R_1 = R_{init}$\n\n- **Cycle $1$: $R \\leftarrow R \\oplus R$**\n  - Values read at the beginning of the cycle: Both read ports fetch $R_1 = R_{init}$.\n  - Computation: $R_1 \\oplus R_1 = R_{init} \\oplus R_{init} = 0$ (all-bits-zero value).\n  - Value written to $R$ at the end of the cycle.\n  - **State at Start of Cycle $2$:**\n    - $R_2 = 0$.\n\n- **Cycle $2$: $R \\leftarrow R \\oplus R$**\n  - Values read: $R_2=0$.\n  - Computation: $0 \\oplus 0 = 0$.\n  - **State at Start of Cycle $3$:**\n    - $R_3 = 0$.\n\n- **Cycle $3$: $R \\leftarrow R \\oplus R$**\n  - Values read: $R_3=0$.\n  - Computation: $0 \\oplus 0 = 0$.\n  - **Final State (End of Cycle $3$):**\n    - The final value in $R$ is $0$.\n\nWhen $x$ and $y$ alias, the register's content is zeroed out.\n\n### Option-by-Option Analysis\n\n**A. Under the stated single-issue, one-operation-per-cycle semantics, if $x$ and $y$ are distinct physical registers, the sequence completes a correct swap in $3$ cycles without extra storage. If $x$ and $y$ alias the same physical register, both end with the all-zero value because $x \\oplus x = 0$ bitwise.**\n- **Analysis:** This statement comprehensively describes the outcomes for both scenarios analyzed above. The derivation for Case 1 demonstrates a correct swap in $3$ cycles without extra registers. The derivation for Case 2 shows that the aliased register's final value becomes the all-zero value, which is a direct consequence of the XOR self-inverse property ($A \\oplus A = 0$). The reasoning provided is precisely correct.\n- **Verdict:** **Correct**.\n\n**B. If the three assignments are placed in one clocked block using non-blocking updates in a Hardware Description Language (HDL), then the swap works for all cases, including when $x$ and $y$ alias, because all right-hand sides use pre-clock values and are applied simultaneously.**\n- **Analysis:** In an HDL like Verilog, non-blocking assignments (`<=`) within a single clocked block (`always @(posedge clk)`) cause all right-hand side (RHS) expressions to be evaluated using the values at the beginning of the clock cycle. The results are then scheduled to update the left-hand side (LHS) variables simultaneously. However, assigning to the same variable ($x$) twice in the same block is illegal in standard HDL syntax and will be flagged as an error by synthesis tools. If we were to ignore this and attempt to interpret the \"simultaneous update\" concept, all three RHS expressions ($x \\oplus y$) would be evaluated using the same pre-clock values of $x$ and $y$. Let these be $x_{pre}$ and $y_{pre}$.\n  - Update for $y$: $y$ would be updated to $x_{pre} \\oplus y_{pre}$.\n  - Update for $x$: $x$ would also be updated to $x_{pre} \\oplus y_{pre}$ (assuming the last assignment to $x$ wins).\n  - The final state would be $x = x_{pre} \\oplus y_{pre}$ and $y = x_{pre} \\oplus y_{pre}$. This is not a swap; both registers get the same value. The original values are lost. The statement's claim that the swap \"works for all cases\" is false.\n- **Verdict:** **Incorrect**.\n\n**C. If control erroneously issues the first two assignments in the same clock cycle so that both right-hand sides read the pre-cycle values of $x$ and $y$ and both writes occur together, the intended flow dependence from the first update of $x$ to the second update of $y$ is violated, constituting a Read-After-Write (RAW) hazard; consequently, the swap fails even when $x$ and $y$ are distinct.**\n- **Analysis:** The correct sequential execution ($x \\leftarrow x \\oplus y$; then $y \\leftarrow x \\oplus y$) has a true data dependence (RAW hazard) on register $x$: the second instruction must read the value of $x$ *after* the first instruction has written to it. If both are issued in the same cycle, the hardware reads the sources for both instructions at the beginning of the cycle.\n  - Let the initial values be $x_0$ and $y_0$.\n  - Instruction $1$ ($x \\leftarrow x \\oplus y$) reads $x_0, y_0$ and computes $x_0 \\oplus y_0$.\n  - Instruction $2$ ($y \\leftarrow x \\oplus y$) reads $x_0, y_0$ and computes $x_0 \\oplus y_0$.\n  The second instruction reads the old value $x_0$ instead of the new value being computed by the first instruction. This is a classic RAW hazard. At the end of the cycle, both $x$ and $y$ would be written with the same value, $x_0 \\oplus y_0$. The swap fails. The statement correctly identifies the RAW hazard and its consequence. Note that this scenario would also create a structural hazard on the single write port, but the logical failure due to the RAW hazard is independent of this and sufficient to invalidate the operation.\n- **Verdict:** **Correct**.\n\n**D. When $x$ and $y$ alias, the first assignment effectively feeds the same signal to both inputs of an XOR gate; the gate outputs logic high for equal inputs, so the register is driven to the all-ones value rather than zero.**\n- **Analysis:** This statement correctly observes that when $x$ and $y$ alias, the operation $x \\leftarrow x \\oplus y$ becomes $x \\leftarrow x \\oplus x$, feeding the same signal to both inputs of the XOR functional unit. However, it incorrectly describes the behavior of an XOR gate. The truth table for XOR is such that it outputs a $0$ for equal inputs ($0 \\oplus 0 = 0$; $1 \\oplus 1 = 0$) and a $1$ for different inputs. A gate that outputs logic high ($1$) for equal inputs is an XNOR (Exclusive NOR) gate. Therefore, $x \\oplus x$ results in a bitwise all-zero value, not an all-ones value.\n- **Verdict:** **Incorrect**.", "answer": "$$\\boxed{AC}$$", "id": "3688756"}]}