{"hands_on_practices": [{"introduction": "The primary performance advantage of the Harvard architecture stems from its ability to fetch instructions and access data simultaneously. This exercise allows you to quantify this parallelism by calculating an 'overlap efficiency' metric [@problem_id:3646906]. By analyzing how bus widths for instruction and data paths affect this efficiency, you will gain a concrete understanding of how architectural balance is key to maximizing throughput.", "problem": "A processor implements a Harvard architecture, meaning the instruction path and data path are physically separated. Specifically, it has an Instruction (I) bus and a Data (D) bus that can operate simultaneously under a common clock. Consider the execution of a single memory-dependent instruction that requires fetching the instruction of size $s_{i}$ bytes over the Instruction (I) bus and, during its execution, performing one data memory transfer of size $s_{d}$ bytes over the Data (D) bus. Assume the following:\n\n- The bus width of the Instruction (I) bus is $B_{i}$ bits, and the bus width of the Data (D) bus is $B_{d}$ bits.\n- Each bus can transfer at most its full width per clock cycle, that is, at most $B$ bits per cycle for a bus of width $B$.\n- Both transfers start at the same clock cycle on their respective buses, and transfers proceed at the maximum allowed per-cycle rate until their respective sizes are fully transferred.\n- Ignore fixed setup latencies, alignment constraints, and any additional pipeline or cache effects; consider only the raw transfer time measured in clock cycles for each bus.\n\nDefine the overlap efficiency as $\\eta = \\dfrac{\\text{parallel cycles}}{\\text{total cycles}}$, where “parallel cycles” is the number of clock cycles in which both the Instruction (I) and Data (D) buses are simultaneously active, and “total cycles” is the total number of clock cycles during which at least one of the two buses is active for this instruction’s memory activity.\n\nStarting from the fundamental definitions above of Harvard architecture concurrency and bus transfer capacity per cycle, derive an analytical expression for $\\eta$ in terms of $B_{i}$, $B_{d}$, $s_{i}$, and $s_{d}$. Then, for a scenario with instruction size $s_{i}=16$ bytes and data transfer size $s_{d}=32$ bytes, compute $\\eta$ for the following three bus width configurations (all widths in bits):\n\n- Case A: $B_{i}=64$, $B_{d}=64$.\n- Case B: $B_{i}=32$, $B_{d}=64$.\n- Case C: $B_{i}=128$, $B_{d}=32$.\n\nExpress the final overlap efficiencies as exact values. The efficiency $\\eta$ is dimensionless; do not include units in your final numerical results. No rounding is required.", "solution": "The problem asks for the overlap efficiency, $\\eta$, of two concurrent bus transfers in a Harvard architecture, defined as the ratio of parallel-active cycles to total-active cycles.\n\nFirst, we determine the number of clock cycles required for each transfer. Memory sizes are in bytes, and bus widths are in bits, with $1$ byte $= 8$ bits.\n\nLet $N_i$ be the number of cycles to fetch the instruction of size $s_i$ bytes over the I-bus with width $B_i$ bits. The total instruction size in bits is $8s_i$. Since a transfer completes in an integer number of clock cycles, we must take the ceiling of the ratio of total bits to bits per cycle.\n$$\nN_i = \\left\\lceil \\frac{8s_i}{B_i} \\right\\rceil\n$$\n\nSimilarly, let $N_d$ be the number of cycles for the data transfer of size $s_d$ bytes over the D-bus with width $B_d$ bits.\n$$\nN_d = \\left\\lceil \\frac{8s_d}{B_d} \\right\\rceil\n$$\n\nBoth transfers start simultaneously. \"Parallel cycles\" is the time both buses are active, which is the duration of the shorter transfer.\n$$\nN_{\\text{parallel}} = \\min(N_i, N_d)\n$$\n\n\"Total cycles\" is the time until the longer transfer completes.\n$$\nN_{\\text{total}} = \\max(N_i, N_d)\n$$\n\nThe overlap efficiency $\\eta$ is the ratio:\n$$\n\\eta = \\frac{N_{\\text{parallel}}}{N_{\\text{total}}} = \\frac{\\min(N_i, N_d)}{\\max(N_i, N_d)}\n$$\n\nSubstituting the expressions for $N_i$ and $N_d$ gives the general analytical expression:\n$$\n\\eta = \\frac{\\min\\left(\\left\\lceil \\frac{8s_i}{B_i} \\right\\rceil, \\left\\lceil \\frac{8s_d}{B_d} \\right\\rceil\\right)}{\\max\\left(\\left\\lceil \\frac{8s_i}{B_i} \\right\\rceil, \\left\\lceil \\frac{8s_d}{B_d} \\right\\rceil\\right)}\n$$\n\nNow, we compute $\\eta$ for the given scenario: $s_i = 16$ bytes (128 bits) and $s_d = 32$ bytes (256 bits).\n\n**Case A: $B_i = 64$ bits, $B_d = 64$ bits.**\n$$\nN_i = \\left\\lceil \\frac{128}{64} \\right\\rceil = 2 \\text{ cycles}\n$$\n$$\nN_d = \\left\\lceil \\frac{256}{64} \\right\\rceil = 4 \\text{ cycles}\n$$\n$$\n\\eta_A = \\frac{\\min(2, 4)}{\\max(2, 4)} = \\frac{2}{4} = \\frac{1}{2}\n$$\n\n**Case B: $B_i = 32$ bits, $B_d = 64$ bits.**\n$$\nN_i = \\left\\lceil \\frac{128}{32} \\right\\rceil = 4 \\text{ cycles}\n$$\n$$\nN_d = \\left\\lceil \\frac{256}{64} \\right\\rceil = 4 \\text{ cycles}\n$$\n$$\n\\eta_B = \\frac{\\min(4, 4)}{\\max(4, 4)} = \\frac{4}{4} = 1\n$$\nThis represents perfectly balanced transfers and maximum efficiency.\n\n**Case C: $B_i = 128$ bits, $B_d = 32$ bits.**\n$$\nN_i = \\left\\lceil \\frac{128}{128} \\right\\rceil = 1 \\text{ cycle}\n$$\n$$\nN_d = \\left\\lceil \\frac{256}{32} \\right\\rceil = 8 \\text{ cycles}\n$$\n$$\n\\eta_C = \\frac{\\min(1, 8)}{\\max(1, 8)} = \\frac{1}{8}\n$$\n\nThe final efficiencies for the three cases are $\\frac{1}{2}$, $1$, and $\\frac{1}{8}$ respectively.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{2} & 1 & \\frac{1}{8}\n\\end{pmatrix}\n}\n$$", "id": "3646906"}, {"introduction": "While the Harvard architecture logically separates instruction and data spaces, practical implementations often map both onto a single physical memory to save cost. This creates a potential security vulnerability: memory aliasing, where an instruction fetch could accidentally read from a data region. This practice challenges you to design a test to detect such aliasing and derive the necessary memory separation to prevent it, highlighting the critical interplay between architectural design and system integrity [@problem_id:3646898].", "problem": "A processor implements a Harvard architecture, meaning the instruction address space and the data address space are logically distinct, each with its own access path. In this system, both the instruction space address $A_{I}$ and the data space address $A_{D}$ are independently mapped into a single on-chip static random-access memory (SRAM) of size $S$ bytes by the rule that the physical address is the residue modulo $S$, that is, the physical address $P$ corresponding to any virtual address $A$ is given by $P = A \\bmod S$. The instruction fetch unit issues fetches aligned to blocks of $B_{I}$ bytes and includes a demand-prefetch mechanism that may fetch up to $F$ bytes ahead of the current program counter in steady-state sequential execution. Assume the instruction set has at least one architecturally illegal encoding, and let $\\gamma$ denote a single-byte pattern that is guaranteed to cause an illegal-instruction trap if it is fetched as the first byte of an instruction. You are given a software-controlled experiment in which you can choose two contiguous regions:\n- a code region beginning at instruction space base $A_{I}$ whose sequential execution touches at most a forward window of $L_{I}$ bytes as a result of block-aligned fetching and prefetching, and\n- a data region beginning at data space base $A_{D}$ of length $L_{D}$ bytes, each byte set to the illegal sentinel $\\gamma$.\n\nPart (a): Design a concrete runtime test that will detect whether any instruction fetch has inadvertently read bytes from the data region as a result of aliasing in the modular physical mapping. Your test must rely only on architecturally visible effects (for example, traps or program-visible data) and must be robust to the fetcher’s prefetch behavior described above. Clearly specify the control flow, what patterns you place in memory, and how the detection criterion distinguishes intended instruction fetches from unintended reads of data bytes.\n\nPart (b): Modeling the two regions as contiguous sets of physical addresses induced by the modular mapping, derive from first principles the minimum required separation $\\Delta A$ between the bases $A_{I}$ and $A_{D}$ in their respective virtual spaces that ensures zero alias risk, in the sense that no physical address touched by instruction fetching in the $L_{I}$-byte window coincides with any physical address in the $L_{D}$-byte data region. Express your answer for $\\Delta A$ as a closed-form analytic expression in terms of $B_{I}$, $F$, $L_{D}$, and $S$, under the assumption that neither the instruction fetch window nor the data region wraps around modulo $S$ on their own and that there is sufficient capacity to place them disjointly on the physical address circle, that is, $L_{I} + L_{D} \\leq S$. Do not state your answer as an inequality; provide a single expression for the minimum separation. If your expression involves a composite function of the given parameters, present it in simplest closed form. The final answer must be an analytic expression in bytes and should be given without units.", "solution": "Part (a): Design of the Runtime Test\n\nThe test aims to confirm if aliasing occurs between the instruction and data address spaces when mapped to the same physical memory. An illegal-instruction trap provides the necessary architecturally visible effect.\n\n1.  **Memory Setup**: Set the base virtual addresses for the code and data regions to be identical, i.e., $A_D = A_I$. Using data store instructions, fill a portion of the data address space, from $A_D$ to $A_D + L_D - 1$ (where $L_D \\ge 1$), with the illegal-instruction sentinel byte $\\gamma$. Due to the mapping $P = A \\pmod S$, this populates the physical memory region starting at $A_I \\pmod S$ with $\\gamma$.\n\n2.  **Test Program**: At instruction address $A_I$, place an instruction that causes an infinite loop at that address (e.g., `JUMP A_I`). This ensures the processor repeatedly attempts to fetch from $A_I$.\n\n3.  **Execution and Detection**: Start program execution by setting the Program Counter to $A_I$.\n    -   The processor's fetch unit will try to read the instruction at virtual address $A_I$.\n    -   This access is mapped to physical address $P = A_I \\pmod S$.\n    -   Because this physical location was filled with $\\gamma$ via a data write, the fetch unit will read $\\gamma$.\n    -   When the instruction decoder receives $\\gamma$, it will identify it as an invalid instruction.\n    -   **Detection Criterion**: The processor will generate an illegal-instruction trap. The occurrence of this trap immediately upon execution confirms that the instruction fetch for $A_I$ was aliased to a physical location populated via the data path.\n\n---\n\nPart (b): Derivation of Minimum Separation $\\Delta A$\n\nThe objective is to find the minimum positive separation $\\Delta A = A_D - A_I$ that ensures the set of physical addresses accessed by instruction fetches, $\\mathcal{P}_I$, is disjoint from the set of physical addresses occupied by the data region, $\\mathcal{P}_D$.\n\n1.  **Characterize the Instruction Fetch Window**: The problem states that instruction fetches are aligned to $B_I$-byte blocks and can prefetch up to $F$ bytes ahead of the program counter (PC), which we assume is at $A_I$. The range of virtual addresses potentially accessed by the instruction fetcher spans from the start of the block containing $A_I$ to the end of the block containing the furthest prefetched address, $A_I+F$.\n    A conservative \"forward window\" starting at $A_I$ that covers all possible future fetches must extend to this highest possible address. The worst-case length of this window, $L_I$, is bounded by $F+B_I$. Therefore, the set of virtual instruction addresses to protect is $V_I = [A_I, A_I + F + B_I - 1]$. The length of this region is $L_I = F+B_I$.\n\n2.  **Formulate the No-Aliasing Condition**: The data region occupies the virtual address set $V_D = [A_D, A_D + L_D - 1]$. For no aliasing to occur, for any $v_I \\in V_I$ and $v_D \\in V_D$, their physical mappings must be different:\n    $$v_I \\not\\equiv v_D \\pmod S$$\n    Substituting $v_I = A_I + k_I$ (with $k_I \\in [0, F+B_I-1]$) and $v_D = A_D + k_D$ (with $k_D \\in [0, L_D-1]$), and using $\\Delta A = A_D - A_I$:\n    $$A_I + k_I \\not\\equiv (A_I + \\Delta A) + k_D \\pmod S$$\n    $$\\Delta A \\not\\equiv k_I - k_D \\pmod S$$\n    This condition must hold for all valid $k_I$ and $k_D$.\n\n3.  **Identify Forbidden Separation Values**: The difference $k_I - k_D$ can take any integer value in the range from $[k_{I,min} - k_{D,max}]$ to $[k_{I,max} - k_{D,min}]$.\n    -   Minimum difference: $0 - (L_D - 1) = -(L_D - 1)$.\n    -   Maximum difference: $(F+B_I-1) - 0 = F+B_I-1$.\n    So, the set of forbidden differences is the integer interval $\\mathcal{Z} = [-(L_D - 1), F + B_I - 1]$. The separation $\\Delta A$ is unsafe if $\\Delta A \\pmod S$ is equal to $z \\pmod S$ for any $z \\in \\mathcal{Z}$.\n\n4.  **Find the Minimum Safe Positive $\\Delta A$**: We need the smallest positive integer $\\Delta A$ that avoids this forbidden set. The positive values in $\\mathcal{Z}$ are $\\{1, 2, \\dots, F+B_I-1\\}$. Therefore, any $\\Delta A$ in this range is unsafe. The smallest positive integer not in this set is $(F+B_I-1) + 1 = F+B_I$.\n\n5.  **Verify Against Wraparound Aliasing**: We must ensure that $\\Delta A = F+B_I$ does not alias with the *negative* part of the forbidden set $\\mathcal{Z}$. An alias would occur if $F+B_I \\equiv z \\pmod S$ for some $z \\in [-(L_D-1), -1]$. This means $F+B_I = z + kS$ for some integer $k \\ge 1$. For $k=1$, this gives $z = F+B_I-S$. We check if this value of $z$ can fall into its allowed range:\n    $$ -(L_D-1) \\le F+B_I-S \\implies S \\le F+B_I+L_D-1 $$\n    However, the problem gives the constraint that there is sufficient capacity, which we derived from the worst-case window size as $L_I+L_D \\le S \\implies (F+B_I) + L_D \\le S$. This directly contradicts the condition required for aliasing. Therefore, aliasing with the negative part of the interval does not occur.\n\nThe minimum required separation is $F+B_I$.", "answer": "$$\n\\boxed{F + B_{I}}\n$$", "id": "3646898"}, {"introduction": "The principles of the Harvard architecture scale up to complex, modern systems like multicore processors. In this scheduling puzzle, tasks are characterized by their distinct instruction and data bandwidth demands—a direct reflection of their interaction with separate I/D pathways [@problem_id:3646991]. Your goal is to allocate these tasks across multiple cores and time slots to optimize a shared resource, demonstrating how architectural properties influence high-level system performance and resource management.", "problem": "A multicore processor uses a Harvard architecture with separate instruction and data pathways per core. Each core has a private instruction Level-1 cache and data Level-1 cache, and all cores share a unified Level-2 (L2) cache. In this workload model, each task is characterized by a constant-rate pair $\\left(I_{bw}, D_{bw}\\right)$ in gigabytes per second (GB/s): $I_{bw}$ is the sustained instruction fetch bandwidth demand into the core’s instruction pathway, and $D_{bw}$ is the sustained data bandwidth demand serviced by the shared Level-2 (L2) cache due to streaming data that do not hit in the Level-1 data cache. Assume that instruction fetches are fully served by the instruction Level-1 cache hierarchy without reaching Level-2 (L2), while all data requests counted in $D_{bw}$ reach Level-2 (L2).\n\nThere are $C=3$ identical cores. Time is divided into exactly $2$ non-overlapping slots. Each task must be scheduled non-preemptively into exactly one slot and run on exactly one core during that slot. At most one task can run on a core in a slot. Each core has per-core pathway limits $I_{\\max}=5$ GB/s on the instruction pathway and $D_{\\max}=8$ GB/s on the data pathway. The chip has a shared instruction fabric limit per slot of $I_{\\text{chip}}=9$ GB/s, i.e., the sum of $I_{bw}$ across all tasks scheduled in a slot cannot exceed $I_{\\text{chip}}$. The shared Level-2 (L2) cache services the aggregate data traffic $D_{bw}$ from all tasks scheduled in a slot, and the slot’s Level-2 (L2) bandwidth consumption is the sum of $D_{bw}$ for tasks in that slot.\n\nYou are given $5$ tasks with demands $(I_{bw}, D_{bw})$ in GB/s:\n- $T_{1}: \\left(4, 6\\right)$\n- $T_{2}: \\left(3, 4\\right)$\n- $T_{3}: \\left(2, 5\\right)$\n- $T_{4}: \\left(4, 3\\right)$\n- $T_{5}: \\left(1, 7\\right)$\n\nAll tasks individually satisfy $I_{bw} \\leq I_{\\max}$ and $D_{bw} \\leq D_{\\max}$, so any single task can run on any core.\n\nUsing only the foundational facts that (i) in a Harvard architecture the instruction and data pathways are independent per core, (ii) chip-level instruction fabric capacity limits the sum of instruction fetch demand per slot, and (iii) the shared Level-2 (L2) bandwidth per slot equals the sum of the scheduled tasks’ $D_{bw}$ in that slot, determine the minimal achievable peak Level-2 (L2) bandwidth across the two slots, subject to the above constraints.\n\nExpress the final answer as an exact integer in GB/s. Do not provide an inequality or an equation; provide the single minimal achievable peak value. No rounding is required; give the exact value.", "solution": "The problem is to partition a set of 5 tasks into two non-overlapping time slots to minimize the peak aggregate L2 data bandwidth, subject to several constraints.\n\n**1. Define the Problem and Constraints:**\n-   **Tasks**: 5 tasks $T_1, \\dots, T_5$ with demands $(I_{bw}, D_{bw})$.\n-   **Slots**: 2 slots. Let the sets of tasks in each slot be $S_1$ and $S_2$.\n-   **Partition**: $S_1 \\cup S_2 = \\{T_1, \\dots, T_5\\}$, $S_1 \\cap S_2 = \\emptyset$.\n-   **Constraints per slot $k \\in \\{1, 2\\}$**:\n    1.  Core limit: $|S_k| \\le 3$ (Number of cores).\n    2.  Instruction fabric limit: $\\sum_{T_i \\in S_k} I_{bw,i} \\le 9$ GB/s.\n-   **Objective**: Minimize $\\max(D_{L2,1}, D_{L2,2})$, where $D_{L2,k} = \\sum_{T_i \\in S_k} D_{bw,i}$.\n\n**2. Analyze the Constraints:**\n-   Total instruction demand: $\\sum I_{bw} = 4+3+2+4+1 = 14$ GB/s.\n-   Total data demand: $\\sum D_{bw} = 6+4+5+3+7 = 25$ GB/s.\n-   Since $\\sum_{i \\in S_1} I_{bw,i} + \\sum_{j \\in S_2} I_{bw,j} = 14$ and both sums must be $\\le 9$, the sum for any slot must also be $\\ge 14-9 = 5$. Thus, for any valid partition, $5 \\le \\sum_{T_i \\in S_k} I_{bw,i} \\le 9$.\n-   With 5 tasks and 3 cores, the only possible partition sizes are $(|S_1|, |S_2|) = (2, 3)$ or $(3, 2)$.\n\n**3. Systematically Evaluate All Partitions:**\nWe can enumerate all possible partitions of size (2, 3) and check their validity and resulting peak bandwidth. There are $\\binom{5}{2} = 10$ such partitions to check. Let $S_1$ be the group of 2 tasks.\n\n| $S_1$             | $I_{S_1}$ | Valid? (5-9) | $D_{S_1}$ | $I_{S_2}$ | Valid? (5-9) | $D_{S_2}$ | Peak D |\n|-------------------|-----------|--------------|-----------|-----------|--------------|-----------|--------|\n| $\\{T_1, T_2\\}$    | 4+3 = 7   | Yes          | 6+4 = 10  | 14-7 = 7  | Yes          | 25-10 = 15| 15     |\n| $\\{T_1, T_3\\}$    | 4+2 = 6   | Yes          | 6+5 = 11  | 14-6 = 8  | Yes          | 25-11 = 14| 14     |\n| $\\{T_1, T_4\\}$    | 4+4 = 8   | Yes          | 6+3 = 9   | 14-8 = 6  | Yes          | 25-9 = 16 | 16     |\n| **$\\{T_1, T_5\\}$**| **4+1 = 5** | **Yes**      | **6+7 = 13**| **14-5 = 9**| **Yes**      | **25-13 = 12**| **13** |\n| $\\{T_2, T_3\\}$    | 3+2 = 5   | Yes          | 4+5 = 9   | 14-5 = 9  | Yes          | 25-9 = 16 | 16     |\n| $\\{T_2, T_4\\}$    | 3+4 = 7   | Yes          | 4+3 = 7   | 14-7 = 7  | Yes          | 25-7 = 18 | 18     |\n| $\\{T_2, T_5\\}$    | 3+1 = 4   | No           | -         | 14-4 = 10 | No           | -         | -      |\n| $\\{T_3, T_4\\}$    | 2+4 = 6   | Yes          | 5+3 = 8   | 14-6 = 8  | Yes          | 25-8 = 17 | 17     |\n| $\\{T_3, T_5\\}$    | 2+1 = 3   | No           | -         | 14-3 = 11 | No           | -         | -      |\n| $\\{T_4, T_5\\}$    | 4+1 = 5   | Yes          | 3+7 = 10  | 14-5 = 9  | Yes          | 25-10 = 15| 15     |\n\n**4. Identify the Minimum Peak Bandwidth:**\nBy examining the \"Peak D\" column for all valid partitions, the minimum value is 13 GB/s. This is achieved with the partition $S_1 = \\{T_1, T_5\\}$ and $S_2 = \\{T_2, T_3, T_4\\}$.\n-   **Slot 1**: Runs $T_1, T_5$. Total $I_{bw} = 5$ GB/s. Total $D_{bw} = 13$ GB/s.\n-   **Slot 2**: Runs $T_2, T_3, T_4$. Total $I_{bw} = 9$ GB/s. Total $D_{bw} = 12$ GB/s.\nThe peak L2 bandwidth across these two slots is $\\max(13, 12) = 13$ GB/s.\n\nTherefore, the minimal achievable peak L2 bandwidth is 13 GB/s.", "answer": "$$\n\\boxed{13}\n$$", "id": "3646991"}]}