{"hands_on_practices": [{"introduction": "Understanding the theory of Finite State Machines is the first step, but a computer architect must be able to translate this theory into practice. This exercise challenges you to analyze a practical implementation of a Mealy FSM written in VHDL, a common Hardware Description Language. By dissecting the code, you will learn to distinguish between the sequential logic of the state register and the combinational logic that determines the next state and output, a fundamental skill for designing and debugging digital systems [@problem_id:1976119].", "problem": "Consider the following VHDL code which describes a synchronous digital circuit with a single bit input `din` and a single bit output `dout`. The circuit is a Mealy-type Finite State Machine (FSM). The FSM is controlled by a clock signal `clk` and can be reset asynchronously via the `reset` signal.\n\n```vhdl\nLIBRARY ieee;\nUSE ieee.std_logic_1164.all;\n\nENTITY sequence_detector IS\n    PORT (\n        clk   : IN  STD_LOGIC;\n        reset : IN  STD_LOGIC;\n        din   : IN  STD_LOGIC;\n        dout  : OUT STD_LOGIC\n    );\nEND ENTITY sequence_detector;\n\nARCHITECTURE behavioral OF sequence_detector IS\n    -- State type declaration\n    TYPE state_type IS (S0, S1);\n    \n    -- State signals\n    SIGNAL current_state, next_state : state_type;\n\nBEGIN\n    -- Process for state register (sequential logic)\n    state_register: PROCESS (clk, reset)\n    BEGIN\n        IF (reset = '1') THEN\n            current_state = S0;\n        ELSIF (rising_edge(clk)) THEN\n            current_state = next_state;\n        END IF;\n    END PROCESS state_register;\n    \n    -- Process for next state logic (combinational logic)\n    next_state_logic: PROCESS (current_state, din)\n    BEGIN\n        CASE current_state IS\n            WHEN S0 =>\n                IF (din = '0') THEN\n                    next_state = S1;\n                ELSE\n                    next_state = S0;\n                END IF;\n                \n            WHEN S1 =>\n                IF (din = '1') THEN\n                    next_state = S0;\n                ELSE\n                    next_state = S1;\n                END IF;\n        END CASE;\n    END PROCESS next_state_logic;\n    \n    -- Output logic (combinational logic for Mealy machine)\n    dout = '1' WHEN (current_state = S1 AND din = '1') ELSE '0';\n\nEND ARCHITECTURE behavioral;\n```\n\nBy analyzing the provided VHDL code, determine the specific behavior of the FSM. Which of the following statements accurately describes the condition that causes the output `dout` to be asserted (i.e., become '1')?\n\nA. `dout` becomes '1' whenever the FSM is in state `S1`, regardless of the input `din`.\n\nB. `dout` becomes '1' when the `reset` signal is asserted.\n\nC. `dout` becomes '1' immediately upon the detection of the input sequence '10'.\n\nD. `dout` becomes '1' immediately upon the detection of the input sequence '01'.\n\nE. `dout` becomes '1' immediately upon the detection of the input sequence '00'.", "solution": "We analyze the FSM by separating the sequential state register, combinational next-state logic, and Mealy output logic.\n\n1.  **State register (sequential logic with asynchronous reset):**\n    If `reset` = '1', then $\\textit{current\\_state} \\leftarrow S_0$.\n    Else on a rising clock edge, $\\textit{current\\_state} \\leftarrow \\textit{next\\_state}$.\n\n2.  **Next-state logic (combinational):**\n    From the code, the next state logic for both current states `S0` and `S1` simplifies to a function of `din` only:\n    $$ \\textit{next\\_state} = \\begin{cases} S_1,  \\text{if } \\textit{din} = '0' \\\\ S_0,  \\text{if } \\textit{din} = '1' \\end{cases} $$\n    Therefore, at clock cycle $n$, the registered state is a function of the input from the previous cycle, $n-1$:\n    $$ \\textit{current\\_state}[n] = \\textit{next\\_state}[n-1] = \\begin{cases} S_1,  \\text{if } \\textit{din}[n-1] = '0' \\\\ S_0,  \\text{if } \\textit{din}[n-1] = '1' \\end{cases} $$\n\n3.  **Output logic (Mealy):**\n    From the code, the output `dout` is asserted if and only if the current state is `S1` and the current input is `1`.\n    $$ \\textit{dout}[n] = 1 \\iff (\\textit{current\\_state}[n] = S_1) \\land (\\textit{din}[n] = '1') $$\n    Substituting the expression for the current state from step 2, this becomes:\n    $$ \\textit{dout}[n] = 1 \\iff (\\textit{din}[n-1] = '0') \\land (\\textit{din}[n] = '1') $$\n    Thus, the output `dout` asserts exactly when the input sequence `01` is detected over two consecutive clock cycles.\n\n4.  **Evaluation of options:**\n    - A is false since `din` must be '1' for the output to be '1'.\n    - B is false since `dout` does not depend on `reset`.\n    - C is false; the condition is for the sequence `01`, not `10`.\n    - D is true: immediate detection of `01` asserts `dout`.\n    - E is false since `din` = '0' always results in `dout` = '0'.\n\nTherefore, the correct choice is D.", "answer": "$$\\boxed{D}$$", "id": "1976119"}, {"introduction": "An FSM on paper operates in a perfect, synchronized world, but real-world circuits must handle asynchronous events that do not align with the system clock. This practice problem explores the dangerous phenomenon of metastability, which can occur when timing specifications, such as a flip-flop's reset recovery time, are violated. Understanding the potential for an FSM to enter an unpredictable state is critical for designing robust systems that can operate reliably in complex environments [@problem_id:1910785].", "problem": "A Finite State Machine (FSM) is designed to control a high-speed data sampling process. The FSM has three states: `IDLE` (state `00`), `SAMPLING` (state `01`), and `PROCESSING` (state `10`). The state transitions are synchronized to the rising edge of a system clock, `clk`. The design incorporates an active-low asynchronous reset input, `areset_n`, which is intended to force the FSM into the `IDLE` state whenever `areset_n` is low, regardless of clock activity.\n\nThe flip-flops used to implement the state register have a specified *reset recovery time*. This is the minimum time that the `areset_n` signal must be stable in its inactive (high) state before the next rising edge of `clk` to ensure predictable behavior.\n\nDuring operation, a transient glitch causes the `areset_n` signal to be asserted (go low) and then de-asserted (go high). The de-assertion of `areset_n` occurs at a moment that violates the reset recovery time specification of the state register's flip-flops. Which of the following statements most accurately describes the potential behavior of the FSM's state immediately following the rising clock edge that occurs during this timing violation?\n\nA. The FSM will reliably transition to the `SAMPLING` state, as that is the intended next state from `IDLE` when a start condition is met.\n\nB. The FSM will reliably remain in the `IDLE` state, as the reset signal was active just prior to the clock edge.\n\nC. The FSM's state register may enter a metastable condition, where its output is temporarily unpredictable, potentially causing the FSM to transition to an invalid or unintended state.\n\nD. The FSM's internal clock-gating logic will be triggered, preventing any state change until the next valid reset pulse.\n\nE. The FSM will suffer permanent physical damage due to the internal contention caused by the timing violation, requiring a power cycle to recover.", "solution": "Let the active-low asynchronous reset be `areset_n` and denote the reset recovery time of the flip-flops by $t_{rec}$. By specification, `areset_n` must be high (inactive) and stable for at least time $t_{rec}$ before the next rising edge of `clk` to guarantee predictable sampling of the state register's data inputs.\n\nLet the de-assertion (low-to-high transition) of `areset_n` occur at time $t_{d}$ and the next rising edge of `clk` occur at time $t_{c}$. The recovery-time requirement is\n$$\nt_{c} - t_{d} \\geq t_{rec}.\n$$\nA violation corresponds to\n$$\nt_{c} - t_{d}  t_{rec}.\n$$\nWhen this inequality holds, the reset signal has not been inactive long enough for the internal nodes of the flip-flops to stabilize before the sampling event at $t_{c}$. This is a timing violation analogous to violating the setup time on a data input: the flip-flop may enter a metastable state. In metastability, the flip-flop output can remain at an indeterminate voltage level for an unbounded time before unpredictably resolving to either a logic '0' or '1'. For a multi-bit state register, different bits may resolve differently, potentially yielding an invalid state encoding (e.g., `11` in this problem) or an unintended but legal state (e.g., `SAMPLING` or `PROCESSING` instead of `IDLE`).\n\nEvaluating the options based on this behavior:\n- Option A is incorrect. Reliability is lost during a timing violation; the transition is not guaranteed.\n- Option B is incorrect. A recovery-time violation specifically means the reset's effect is no longer guaranteed at the clock edge. The state may not remain `IDLE`.\n- Option C correctly describes that the state register may become metastable. This can lead to its outputs being temporarily indeterminate, followed by a resolution to an unpredictable value, which can cause the FSM to transition to an invalid or unintended state.\n- Option D is incorrect. Asynchronous reset logic does not inherently trigger clock gating.\n- Option E is incorrect. Metastability is a transient logical phenomenon related to timing, not an event that causes permanent physical hardware damage.\n\nTherefore, the most accurate description is Option C.", "answer": "$$\\boxed{C}$$", "id": "1910785"}, {"introduction": "A correctly functioning FSM is good, but a provably safe FSM is essential, especially in critical applications. This problem shifts our focus from design to verification, tasking you with analyzing a test scenario for a laser controller that must never fail dangerously. You will trace how a simulator can forcefully inject the FSM into an illegal state to confirm that its safety-recovery mechanism works as intended, a key practice in building fault-tolerant hardware [@problem_id:1966464].", "problem": "You are tasked with verifying the safety features of a Finite State Machine (FSM) that controls the firing sequence of a high-power industrial laser. The system is designed as a Moore FSM with a synchronous active-high reset.\n\n**FSM Specification:**\n-   **Inputs**: `clk`, `reset`, `arm` (1-bit), `fire` (1-bit).\n-   **Output**: `laser_enable` (1-bit).\n-   **State Register**: A 2-bit register named `state_reg`.\n-   **States and Encodings**:\n    -   `S_OFF`: 2'b00 (The designated safe/reset state).\n    -   `S_ARMED`: 2'b01\n    -   `S_FIRING`: 2'b10\n    -   The encoding 2'b11 is an unused, illegal state.\n-   **Output Logic**:\n    -   `laser_enable` is 1 if and only if the FSM is in the `S_FIRING` state. Otherwise, `laser_enable` is 0.\n-   **State Transitions**: Transitions occur on the rising edge of `clk`.\n    1.  If `reset` is high, the next state is `S_OFF`.\n    2.  From `S_OFF`: If `arm` is high, the next state is `S_ARMED`. Otherwise, the state remains `S_OFF`.\n    3.  From `S_ARMED`: If `arm` is low, the next state is `S_OFF` (a safety interlock). If `arm` is high and `fire` is high, the next state is `S_FIRING`. Otherwise, the state remains `S_ARMED`.\n    4.  From `S_FIRING`: The next state is unconditionally `S_OFF` (the laser fires a single-cycle pulse).\n    5.  **Safety Recovery**: If `state_reg` ever holds the illegal value 2'b11, the FSM must transition to `S_OFF` on the next rising clock edge, regardless of the `arm` and `fire` inputs.\n\n**Testbench Scenario:**\nA testbench simulates the FSM with a clock (`clk`) that has a period of 10 ns. The first rising edge of the clock occurs at t = 10 ns. The following stimulus is applied:\n-   From t = 0 ns to t = 15 ns, `reset` is held high. At t = 15 ns, `reset` is de-asserted to 0.\n-   At t = 25 ns, `arm` is asserted high.\n-   At t = 35 ns, `fire` is asserted high. `arm` remains high.\n-   At t = 42 ns, a simulator `force` command is executed, which instantaneously and forcefully sets the value of the `state_reg` to the illegal encoding 2'b11. This command overrides the normal synchronous behavior of the register at that moment.\n-   At t = 45 ns, both `arm` and `fire` are de-asserted to 0.\n\n**Question:**\nBased on the FSM specification and the testbench scenario, determine the sequence of values for the output `laser_enable` at the specific simulation times of t = 41 ns, t = 43 ns, and t = 51 ns.\n\nChoose the correct sequence from the options below.\n\nA. (1, 0, 0)\nB. (1, 1, 0)\nC. (0, 0, 0)\nD. (1, 0, 1)\nE. (1, 1, 1)", "solution": "We trace the state of the Moore FSM. The output `laser_enable` is 1 if and only if the FSM is in state `S_FIRING` (`2'b10`). Otherwise, it is 0. Clock rising edges occur at $t = 10, 20, 30, 40, 50, \\ldots$ ns.\n\n1.  **At $t=10\\,\\text{ns}$:** `reset` is high. The synchronous reset forces the state to `S_OFF` (`2'b00`). For the interval $[10, 20)$, `state_reg` is `S_OFF` and `laser_enable` is 0.\n2.  **At $t=20\\,\\text{ns}$:** `reset` is low and `arm` is low. The FSM is in `S_OFF` and remains in `S_OFF`. For the interval $[20, 30)$, `state_reg` is `S_OFF` and `laser_enable` is 0.\n3.  **At $t=30\\,\\text{ns}$:** `reset` is low and `arm` is high. The FSM transitions from `S_OFF` to `S_ARMED` (`2'b01`). For the interval $[30, 40)$, `state_reg` is `S_ARMED` and `laser_enable` is 0.\n4.  **At $t=40\\,\\text{ns}$:** `reset` is low, `arm` is high, and `fire` is high. The FSM transitions from `S_ARMED` to `S_FIRING` (`2'b10`). For the interval $[40, 42)$, `state_reg` is `S_FIRING` and `laser_enable` is 1.\n\nNow we evaluate the state at the specific times, considering the simulator `force` command.\n\n-   **At $t=41\\,\\text{ns}$:** This time is after the clock edge at $t=40\\,\\text{ns}$ and before the `force` command. The state is `S_FIRING`. Therefore, **`laser_enable` is 1**.\n\n-   **At $t=42\\,\\text{ns}$:** The simulator forcefully sets `state_reg` to the illegal value `2'b11`. Since this is a Moore FSM, the output depends only on the current state. The state is no longer `S_FIRING` (`2'b10`). Therefore, `laser_enable` immediately becomes 0.\n\n-   **At $t=43\\,\\text{ns}$:** This time is after the `force` command. The `state_reg` holds the value `2'b11`. Therefore, **`laser_enable` is 0**.\n\n-   **At $t=50\\,\\text{ns}$:** This is the next rising clock edge. The FSM's current state is the illegal `2'b11`. According to the safety recovery specification, the FSM must transition to `S_OFF`, regardless of other inputs. So, `state_reg` becomes `S_OFF` (`2'b00`).\n\n-   **At $t=51\\,\\text{ns}$:** This is after the clock edge at $t=50\\,\\text{ns}$. The state is `S_OFF`. Therefore, **`laser_enable` is 0**.\n\nThe sequence of values for `laser_enable` at times $t = 41$ ns, $t = 43$ ns, and $t = 51$ ns is (1, 0, 0). This corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1966464"}]}