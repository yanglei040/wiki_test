{"hands_on_practices": [{"introduction": "Understanding a digital component begins with modeling its fundamental behavior. This first practice challenges you to translate the formal state-transition equation of a synchronous parallel-load register into a concrete software simulation. By implementing the register's response to data, clock enable, and reset signals over time, you will gain a hands-on appreciation for the precise, cycle-by-cycle operation that underpins all sequential logic. [@problem_id:3672919]", "problem": "You are to implement a complete, runnable program that simulates the behavior of a bit-width-parameterized parallel-load register with optional synchronous reset and optional clock enable. The register is modeled as $W$ identical positive-edge-triggered data flip-flops arranged in parallel. The simulation must adhere to well-established definitions of synchronous sequential logic: a register state updates only on the active edge of a clock, and a synchronous reset forces the state to a fixed value when asserted during the edge. The program must use a precise pseudo-random stimulus generator to drive the register inputs across clock cycles, with the stimulus generation rules specified below.\n\nFundamental base:\n- A positive-edge-triggered data flip-flop stores an input bit at the clock rising edge. A register is $W$ such flip-flops storing a $W$-bit vector.\n- For a register with synchronous reset and clock enable, the state-transition equation per cycle $t$ is\n$$\nQ_{t+1} = \\begin{cases}\n0, & \\text{if } RST_t = 1, \\\\\nD_t, & \\text{if } RST_t = 0 \\text{ and } CE_t = 1, \\\\\nQ_t, & \\text{if } RST_t = 0 \\text{ and } CE_t = 0,\n\\end{cases}\n$$\nwith initial state $Q_0 = 0$.\n- The input vector $D_t$ is a $W$-bit quantity each cycle, interpreted as an unsigned integer in the range $[0, 2^W - 1]$.\n\nStimulus generation:\n- Use a linear congruential generator (LCG) for $32$-bit pseudo-random numbers:\n$$\nx_{n+1} = (a \\cdot x_n + c) \\bmod 2^{32},\n$$\nwith constants $a = 1664525$ and $c = 1013904223$, and seed $x_0 = S$.\n- For each cycle $t$, generate three successive LCG outputs in order:\n    1. Use the first output to define $D_t$ as $D_t = x \\bmod 2^W$.\n    2. Define the clock enable $CE_t$ according to the mode:\n        - If the clock enable is absent, set $CE_t = 1$ for all cycles.\n        - If the clock enable mode is random, use the next LCG output and set $CE_t = x \\bmod 2$.\n        - If the clock enable is forced low, set $CE_t = 0$ for all cycles.\n        - If the clock enable is forced high, set $CE_t = 1$ for all cycles.\n    3. Define the synchronous reset $RST_t$ according to the mode:\n        - If the reset is absent, set $RST_t = 0$ for all cycles.\n        - If the reset mode is random, use the next LCG output and set $RST_t = 1$ if $(x \\bmod R) = 0$ and $RST_t = 0$ otherwise, where $R$ is a positive integer divisor controlling the frequency of reset assertions.\n        - If the reset mode is a single pulse at cycle $0$, set $RST_t = 1$ for $t = 0$ and $RST_t = 0$ otherwise.\n- The register updates exactly once per cycle using the state-transition equation shown above.\n\nYour task:\n- Implement the simulation engine for the register given the parameters $W$, $N$, $S$, the reset mode, the clock enable mode, and the reset divisor $R$ if applicable.\n- For each test case, run the simulation for exactly $N$ cycles and report the final register value $Q_N$ as a decimal integer.\n\nTest suite to implement and simulate:\n- Case $1$: $W = 8$, $N = 64$, seed $S = 305419896$, reset mode random with divisor $R = 16$, clock enable mode random.\n- Case $2$: $W = 1$, $N = 16$, seed $S = 2779096485$, reset mode absent, clock enable mode random.\n- Case $3$: $W = 16$, $N = 0$, seed $S = 3735929054$, reset mode random with divisor $R = 4$, clock enable mode random.\n- Case $4$: $W = 32$, $N = 50$, seed $S = 3735928559$, reset mode random with divisor $R = 8$, clock enable mode forced high.\n- Case $5$: $W = 12$, $N = 50$, seed $S = 3405691582$, reset mode absent, clock enable mode forced low.\n\nAnswer specification:\n- For each of the above cases, compute and return the final register value $Q_N$ as a decimal integer.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, if there are five results $r_1$ through $r_5$, print exactly \"[r1,r2,r3,r4,r5]\" with no spaces.\n\nThere are no physical units in this problem. All reported values must be integers. Ensure strict reproducibility by using the specified LCG and stimulus generation rules verbatim.", "solution": "The user-provided problem statement has been validated and is determined to be a valid, well-posed problem in computational simulation and digital logic design.\n\nThe problem requires the simulation of a synchronous parallel-load register, a fundamental component in digital systems and computer architecture. The behavior of this register is governed by a state-transition equation, which is provided and forms the core of the simulation logic. The solution involves implementing this logic within a cycle-based simulation framework and driving the register's inputs with a precisely specified pseudo-random stimulus generator.\n\nThe register's state, $Q$, is a $W$-bit vector, which can be represented by an unsigned integer. Its state at the next clock cycle, $Q_{t+1}$, is determined by its current state, $Q_t$, and three control/data inputs at cycle $t$: the data input $D_t$, the clock enable $CE_t$, and the synchronous reset $RST_t$. The state-transition equation is defined as:\n$$\nQ_{t+1} = \\begin{cases}\n0, & \\text{if } RST_t = 1, \\\\\nD_t, & \\text{if } RST_t = 0 \\text{ and } CE_t = 1, \\\\\nQ_t, & \\text{if } RST_t = 0 \\text{ and } CE_t = 0,\n\\end{cases}\n$$\nThis hierarchy of operations is standard for synchronous logic: reset has the highest priority, followed by the load operation (when enabled), and finally the hold operation (when not enabled). The initial state of the register is defined as $Q_0 = 0$. The simulation must run for a specified number of cycles, $N$, starting from cycle $t=0$. The task is to find the final state, $Q_N$.\n\nThe stimuli $D_t$, $CE_t$, and $RST_t$ for each cycle are generated using a Linear Congruential Generator (LCG). The LCG produces a sequence of $32$-bit pseudo-random numbers, $x_n$, according to the recurrence relation:\n$$\nx_{n+1} = (a \\cdot x_n + c) \\pmod{2^{32}}\n$$\nwith given constants $a = 1664525$ and $c = 1013904223$. The sequence is initiated with a seed, $x_0 = S$. To ensure deterministic and reproducible results, the problem specifies that the C language's implicit modular arithmetic for unsigned integers is sufficient for the $\\pmod{2^{32}}$ operation. To guarantee portability across systems where `unsigned long` might be larger than $32$ bits, an explicit bitwise AND with `0xFFFFFFFFUL` is used after each step of the LCG calculation.\n\nFor each cycle $t$, stimuli are generated in a specific order, advancing the LCG state as needed:\n$1$. The data input $D_t$ is derived from the first LCG output of the cycle. It is calculated as $D_t = x \\pmod{2^W}$, which corresponds to taking the $W$ least significant bits of the LCG output. This is implemented using a bitmask: `x & ((1UL << W) - 1)`. A special case for $W=32$ is handled to avoid undefined behavior from bit-shifting.\n$2$. The clock enable $CE_t$ is determined by the specified mode. If the mode is 'random', a new LCG output is generated, and $CE_t$ is set to $x \\pmod 2$. For other modes ('absent', 'forced low', 'forced high'), $CE_t$ is a constant value ($1$ or $0$), and no LCG output is consumed.\n$3$. The synchronous reset $RST_t$ is determined similarly. If the mode is 'random', a new LCG output is generated, and $RST_t$ is asserted if $x \\pmod R = 0$. For 'absent' or 'single pulse' modes, $RST_t$ is determined by fixed rules without consuming an LCG output.\n\nThe implementation encapsulates these principles into a C program. A `struct` named `TestCase` organizes the parameters for each simulation scenario. A function, `simulate_register`, orchestrates the simulation. It initializes the register state $Q$ to $0$ and the LCG state to the seed $S$. It then enters a loop that iterates $N$ times. In each iteration, it generates the stimuli $D_t$, $CE_t$, and $RST_t$ according to the rules and updates the register state $Q$ using the state-transition equation. Edge cases, such as $N=0$ (where the simulation does not run and the final state is the initial state $Q_0 = 0$) and $W=32$, are handled correctly. The final register values for all specified test cases are collected and printed in the required comma-separated format.", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n// #include <complex.h>\n// #include <threads.h>\n// #include <stdatomic.h>\n\n// Enums to represent the categorical modes for reset and clock enable.\ntypedef enum {\n    RESET_ABSENT,\n    RESET_RANDOM,\n    RESET_SINGLE_PULSE\n} ResetMode;\n\ntypedef enum {\n    CE_ABSENT,\n    CE_RANDOM,\n    CE_FORCED_LOW,\n    CE_FORCED_HIGH\n} CEMode;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int W;\n    int N;\n    unsigned long S;\n    ResetMode reset_mode;\n    unsigned long R;\n    CEMode ce_mode;\n} TestCase;\n\n// LCG constants as specified in the problem statement.\nconst unsigned long LCG_A = 1664525UL;\nconst unsigned long LCG_C = 1013904223UL;\n\n// LCG state update function. It updates the state in-place.\n// The arithmetic ensures the state remains a 32-bit value.\nvoid lcg_next(unsigned long *state) {\n    *state = (LCG_A * (*state) + LCG_C) & 0xFFFFFFFFUL;\n}\n\n// The core simulation engine for the parallel-load register.\nunsigned long simulate_register(TestCase params) {\n    unsigned long Q = 0UL; // Initial state Q_0 = 0\n    unsigned long lcg_state = params.S;\n\n    // If N=0, simulation runs for 0 cycles, final state is initial state.\n    if (params.N == 0) {\n        return Q;\n    }\n\n    // Create a mask to extract W bits for the data input D_t.\n    // Handles the W=32 case to avoid shift-by-word-size UB.\n    unsigned long d_mask = (params.W >= 32) ? 0xFFFFFFFFUL : (1UL << params.W) - 1;\n\n    // Loop for N cycles, from t=0 to t=N-1.\n    for (int t = 0; t < params.N; ++t) {\n        // --- Stimulus Generation ---\n        unsigned long D_t;\n        int CE_t;\n        int RST_t;\n\n        // 1. Generate Data Input D_t (always generated)\n        lcg_next(&lcg_state);\n        D_t = lcg_state & d_mask;\n\n        // 2. Generate Clock Enable CE_t based on mode\n        switch (params.ce_mode) {\n            case CE_ABSENT:\n                CE_t = 1;\n                break;\n            case CE_RANDOM:\n                lcg_next(&lcg_state);\n                CE_t = (int)(lcg_state % 2);\n                break;\n            case CE_FORCED_LOW:\n                CE_t = 0;\n                break;\n            case CE_FORCED_HIGH:\n                CE_t = 1;\n                break;\n        }\n\n        // 3. Generate Synchronous Reset RST_t based on mode\n        switch (params.reset_mode) {\n            case RESET_ABSENT:\n                RST_t = 0;\n                break;\n            case RESET_RANDOM:\n                lcg_next(&lcg_state);\n                RST_t = (lcg_state % params.R == 0) ? 1 : 0;\n                break;\n            case RESET_SINGLE_PULSE:\n                RST_t = (t == 0) ? 1 : 0;\n                break;\n        }\n\n        // --- State Transition Q_t -> Q_{t+1} ---\n        if (RST_t == 1) {\n            Q = 0UL;\n        } else if (CE_t == 1) {\n            Q = D_t;\n        } \n        // else: Q_t+1 = Q_t, so Q remains unchanged.\n    }\n\n    // Return the final state Q_N\n    return Q;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    // R is set to 1 for modes where it's not used to avoid division by zero, although it's not accessed.\n    TestCase test_cases[] = {\n        {8, 64, 305419896UL, RESET_RANDOM, 16, CE_RANDOM},\n        {1, 16, 2779096485UL, RESET_ABSENT, 1, CE_RANDOM},\n        {16, 0, 3735929054UL, RESET_RANDOM, 4, CE_RANDOM},\n        {32, 50, 3735928559UL, RESET_RANDOM, 8, CE_FORCED_HIGH},\n        {12, 50, 3405691582UL, RESET_ABSENT, 1, CE_FORCED_LOW}\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    unsigned long results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        results[i] = simulate_register(test_cases[i]);\n    }\n\n    // Print the results in the EXACT required format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"%lu\", results[i]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3672919"}, {"introduction": "Moving from the ideal logical model to physical implementation reveals new challenges. In high-speed circuits, signals rarely arrive at all destinations simultaneously, a phenomenon known as skew. This exercise provides a practical lesson in static timing analysis, where you will calculate the maximum allowable skew in a load-enable signal to ensure a wide register captures data reliably without bit misalignment. It demonstrates how physical constraints like propagation delays and setup times dictate the operational limits of a parallel-load register. [@problem_id:3672933]", "problem": "A wide $N$-bit parallel-load register is implemented using $N$ identical per-bit two-input multiplexers (Multiplexer (MUX)) that select either the recirculated output or the incoming data bus under control of a single synchronous load-enable signal (load-enable (LE)). Each destination bit is captured by a positive-edge triggered D flip-flop (D flip-flop (DFF)) on the rising clock edge. The LE is generated by a synchronous controller register in the same clock domain, and is asserted for exactly one cycle to initiate a parallel load. The data bus is driven by a source register in the same clock domain, possibly through combinational logic. The LE distribution network exhibits bit-to-bit skew, so the arrival time of LE at different MUX select pins differs, which can cause some bits to select the bus later than others and risk bit misalignment at capture.\n\nStart from the fundamental definitions that: (i) the setup time requirement states that the data input to a DFF must be stable at least $t_{setup}$ before the active clock edge, and (ii) the clock-to-$Q$ delay $t_{clk-q}$ of a register is the time from the clock edge to the corresponding change at its output. Assume all timing quantities are positive and additive, and that the LE is asserted for the entire target cycle so that once a MUX select changes to the bus input, it remains stable until capture.\n\nConsider the following quantitatively specified system:\n- The clock period is $T_{clk} = 2.5 \\ \\text{ns}$.\n- The source register driving the data bus has clock-to-$Q$ delay $t_{clk-q}^{(S)} = 0.12 \\ \\text{ns}$, followed by combinational data-path delay $t_{data} = 0.83 \\ \\text{ns}$ into the MUX data input. The MUX data-input to output propagation delay is $t_{md} = 0.07 \\ \\text{ns}$.\n- The destination register has setup time $t_{setup} = 0.08 \\ \\text{ns}$.\n- The controller register generating LE has clock-to-$Q$ delay $t_{clk-q}^{(E)} = 0.10 \\ \\text{ns}$. The MUX select-to-output propagation delay is $t_{ms} = 0.06 \\ \\text{ns}$.\n- The LE distribution skew across the $N$ bits is defined as $\\Delta t$, the maximum difference between latest and earliest LE arrival at the per-bit MUX select inputs. Take the earliest LE arrival as $t_{clk-q}^{(E)}$ for reference.\n\nBit misalignment occurs if, at the rising edge occurring one period after assertion, some bits still have the MUX selecting recirculation or do not meet setup to the bus value, while other bits have selected the bus and meet setup, resulting in a nonuniform capture across bits. Using only the setup time definition and the meaning of propagation delays, derive the condition under which no misalignment occurs and compute the maximum allowable LE skew $\\Delta t_{\\max}$ so that all bits select the bus and meet setup by the capture edge. Express your final answer in nanoseconds and round your answer to three significant figures.", "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- System: $N$-bit parallel-load register with $N$ two-input multiplexers (MUX) and $N$ positive-edge triggered D flip-flops (DFF).\n- Control: A single synchronous load-enable signal (LE) asserted for one clock cycle.\n- Clock Period: $T_{clk} = 2.5 \\ \\text{ns}$.\n- Source Register and Data Path Delays:\n  - Source clock-to-Q delay: $t_{clk-q}^{(S)} = 0.12 \\ \\text{ns}$.\n  - Combinational data-path delay: $t_{data} = 0.83 \\ \\text{ns}$.\n  - MUX data-input to output propagation delay: $t_{md} = 0.07 \\ \\text{ns}$.\n- Destination Register Timing:\n  - Setup time: $t_{setup} = 0.08 \\ \\text{ns}$.\n- Controller Register and LE Path Delays:\n  - Controller clock-to-Q delay: $t_{clk-q}^{(E)} = 0.10 \\ \\text{ns}$.\n  - MUX select-to-output propagation delay: $t_{ms} = 0.06 \\ \\text{ns}$.\n- Skew:\n  - LE distribution skew: $\\Delta t$, the maximum difference between latest and earliest LE arrival times.\n  - Earliest LE arrival time is taken as $t_{clk-q}^{(E)}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is a standard exercise in static timing analysis (STA) for synchronous digital circuits. It uses fundamental concepts like clock period, setup time, clock-to-Q delay, and propagation delay, all of which are cornerstones of digital electronics design. The provided numerical values are physically realistic for modern semiconductor technologies.\n- **Well-Posed**: The problem is well-posed. It provides a complete set of timing parameters and a clear objective: to derive a high-level timing condition and compute the maximum allowable skew, $\\Delta t_{\\max}$, that satisfies this condition. A unique, stable, and meaningful solution can be determined from the given data.\n- **Objective**: The problem is stated in precise, objective, and technical language, free from ambiguity or subjective claims.\n- **Completeness and Consistency**: The problem is self-contained. All necessary variables for the timing analysis are defined and quantified. The definition of skew and the reference for the earliest arrival time are explicitly stated, avoiding ambiguity. There are no contradictions in the provided data.\n- **Realism**: The scenario and parameters are realistic and representative of challenges faced in high-speed digital design.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be provided.\n\n### Solution Derivation\n\nThe primary goal is to ensure that for a parallel load operation, the data at the input of every destination D-flip-flop (DFF) is stable before the required setup time window of the capturing clock edge. This prevents bit misalignment, where some bits capture the new data and others capture the old, recirculated data.\n\nLet us define the timing of events relative to a clock rising edge at time $t=0$, which launches both the new data from the source register and the load-enable (LE) signal from the controller register. The next rising edge, which captures the data in the destination register, occurs at $t = T_{clk}$.\n\nThe setup time requirement for the destination DFFs dictates that their data inputs must be stable with the new value at or before a specific deadline. This deadline is given by:\n$$t_{deadline} = T_{clk} - t_{setup}$$\n\nFor the circuit to function correctly, the actual time at which the DFF input becomes stable with the new data, let's call it $t_{stable}$, must satisfy the condition $t_{stable} \\le t_{deadline}$ for every bit. We must analyze the worst-case scenario, which corresponds to the bit with the latest-arriving LE signal.\n\nThe final stable state at the DFF input depends on two distinct signal paths that converge at the multiplexer (MUX) feeding that DFF: the data path and the control (LE) path.\n\n1.  **Data Path Arrival Time:** This path determines when the new data value becomes available at the DFF input, assuming the MUX is already enabled to select the data bus. The total delay for this path is the sum of the source register's clock-to-Q delay, the subsequent combinational logic delay, and the MUX's data-to-output propagation delay.\n    $$t_{path\\_data} = t_{clk-q}^{(S)} + t_{data} + t_{md}$$\n\n2.  **Control Path Arrival Time:** This path determines when the MUX is switched to select the new data. For the worst-case bit, the LE signal arrives at the MUX select input at the latest possible time. The problem defines the earliest arrival as $t_{clk-q}^{(E)}$ and the skew as $\\Delta t$. Therefore, the latest LE arrival time is $t_{clk-q}^{(E)} + \\Delta t$. After the LE signal arrives at the select pin, there is an additional MUX internal delay, $t_{ms}$, before the output reflects the selected input. The total effective delay for the control path signal to affect the DFF input is:\n    $$t_{path\\_control} = t_{clk-q}^{(E)} + \\Delta t + t_{ms}$$\n\nThe DFF input is stable with the new data value only when both events have effectively completed: the new data has propagated through its path, and the control signal has propagated through its path to switch the MUX. Therefore, the stable time for the worst-case bit is the maximum of these two path delays.\n$$t_{stable} = \\max(t_{path\\_data}, t_{path\\_control})$$\n\nThe condition under which no misalignment occurs is that even for the worst-case (slowest) bit, the setup time is met. This translates to the following inequality:\n$$ \\max(t_{clk-q}^{(S)} + t_{data} + t_{md}, \\ t_{clk-q}^{(E)} + \\Delta t + t_{ms}) \\le T_{clk} - t_{setup} $$\nThis is the general condition for correct operation. To find the maximum allowable skew, $\\Delta t_{\\max}$, we must ensure both paths satisfy the timing constraint. This gives us two separate inequalities:\n1.  $t_{clk-q}^{(S)} + t_{data} + t_{md} \\le T_{clk} - t_{setup}$\n2.  $t_{clk-q}^{(E)} + \\Delta t + t_{ms} \\le T_{clk} - t_{setup}$\n\nWe can now substitute the given numerical values to solve for $\\Delta t_{\\max}$.\nFirst, we calculate the setup deadline:\n$$t_{deadline} = T_{clk} - t_{setup} = 2.5 \\ \\text{ns} - 0.08 \\ \\text{ns} = 2.42 \\ \\text{ns}$$\n\nNext, we evaluate the data path delay from inequality (1) as a sanity check:\n$$t_{path\\_data} = 0.12 \\ \\text{ns} + 0.83 \\ \\text{ns} + 0.07 \\ \\text{ns} = 1.02 \\ \\text{ns}$$\nSince $1.02 \\ \\text{ns} \\le 2.42 \\ \\text{ns}$, the data path timing is met with a significant margin.\n\nNow, we use inequality (2) to find the constraint on $\\Delta t$. The maximum value, $\\Delta t_{\\max}$, is found when the left side is equal to the deadline.\n$$t_{clk-q}^{(E)} + \\Delta t_{\\max} + t_{ms} = T_{clk} - t_{setup}$$\nSolving for $\\Delta t_{\\max}$:\n$$\\Delta t_{\\max} = T_{clk} - t_{setup} - t_{clk-q}^{(E)} - t_{ms}$$\nSubstituting the given values:\n$$\\Delta t_{\\max} = 2.5 \\ \\text{ns} - 0.08 \\ \\text{ns} - 0.10 \\ \\text{ns} - 0.06 \\ \\text{ns}$$\n$$\\Delta t_{\\max} = 2.5 \\ \\text{ns} - (0.08 + 0.10 + 0.06) \\ \\text{ns}$$\n$$\\Delta t_{\\max} = 2.5 \\ \\text{ns} - 0.24 \\ \\text{ns}$$\n$$\\Delta t_{\\max} = 2.26 \\ \\text{ns}$$\n\nThe problem requires the answer to be rounded to three significant figures. The calculated value $2.26$ already has three significant figures. Thus, the maximum allowable LE skew is $2.26 \\ \\text{ns}$.", "answer": "$$\\boxed{2.26}$$", "id": "3672933"}, {"introduction": "With a firm grasp of a register's logical behavior and physical constraints, we can now address a common system-level design pattern. This final practice explores how to load a wide register from a narrower data bus, a frequent necessity in modern computer systems. Your task is to evaluate different architectures to find one that guarantees an \"atomic\" update, ensuring that downstream logic never observes a partially loaded, inconsistent state. This problem highlights the importance of careful buffering and sequencing to maintain data integrity in complex digital systems. [@problem_id:3672912]", "problem": "A synchronous subsystem uses a single global clock of period $T$ to transfer wide data words across pipeline stages. The external register $R_{\\text{out}}$ is $128$-bit wide and is sampled by downstream logic only at the rising edge of the clock. Due to a $64$-bit wide data bus, each $128$-bit word $W$ must be assembled from two $64$-bit beats, denoted $D_0$ and $D_1$, delivered on consecutive cycles. The assembly order is fixed as $W = [D_1 \\parallel D_0]$. The design requirement is that $R_{\\text{out}}$ presents an atomic update to $W$ at a single rising edge after both beats have been received. Atomic means that, for any external observer synchronous to the same clock, the output of $R_{\\text{out}}$ is either the previous $128$-bit value or the fully updated $128$-bit value $W$ on any rising edge; no intermediate or partially updated value may ever be observed. All storage elements obey standard timing: an edge-triggered flip-flop samples its data on the active clock edge when setup and hold constraints are met (setup time $t_s$, hold time $t_h$), and a level-sensitive latch is transparent when its enable is asserted and opaque when deasserted.\n\nYou are asked to choose the architecture that correctly implements a time-multiplexed parallel load of $R_{\\text{out}}$ across $2$ cycles in a way that guarantees atomic external view. Each option below specifies the internal organization and control sequencing. Assume all control signals mentioned are generated synchronously from a Finite-State Machine (FSM) unless stated otherwise, and that data beats $D_0$ and $D_1$ are valid for the entirety of their respective cycles.\n\nWhich option satisfies the atomicity requirement under these synchronous timing rules?\n\nA. Use two $64$-bit level-sensitive latches $L_{\\text{lo}}$ and $L_{\\text{hi}}$ as a shadow buffer. In cycle $n$, assert the enable of $L_{\\text{lo}}$ to capture $D_0$; in cycle $n+1$, assert the enable of $L_{\\text{hi}}$ to capture $D_1$. Feed the concatenated output $[L_{\\text{hi}} \\parallel L_{\\text{lo}}]$ to the $128$-bit edge-triggered register $R_{\\text{out}}$. Generate a synchronous single-cycle commit signal after both halves are captured; this commit asserts the data-load enable of $R_{\\text{out}}$ only at the next rising edge, transferring the entire $128$-bit shadow content into $R_{\\text{out}}$. While the commit is deasserted, $R_{\\text{out}}$ holds its previous value, and the shadow latches can update independently without affecting $R_{\\text{out}}$.\n\nB. Use a single $128$-bit edge-triggered register for $R_{\\text{out}}$ with two independent $64$-bit write-enables. In cycle $n$, assert the lower $64$-bit write-enable to load $D_0$ into the lower half of $R_{\\text{out}}$; in cycle $n+1$, assert the upper $64$-bit write-enable to load $D_1$ into the upper half of $R_{\\text{out}}$. No shadow buffering or commit signal is used; $R_{\\text{out}}$ is updated piecemeal across the two cycles.\n\nC. Use two $64$-bit edge-triggered flip-flop banks $F_{\\text{lo}}$ and $F_{\\text{hi}}$ to capture $D_0$ and $D_1$ in cycles $n$ and $n+1$ respectively. Concatenate $[F_{\\text{hi}} \\parallel F_{\\text{lo}}]$ and feed it into a $128$-bit level-sensitive output latch $L_{\\text{out}}$ whose enable is held asserted continuously. There is no explicit commit; the outputs of $L_{\\text{out}}$ follow the concatenation as soon as either half updates.\n\nD. Use a $128$-bit shadow register $S$ built from edge-triggered flip-flops with independent $64$-bit write-enables to capture $D_0$ and $D_1$ over cycles $n$ and $n+1$. Drive $R_{\\text{out}}$ directly from $S$, and generate an asynchronous gated clock pulse for $R_{\\text{out}}$ as soon as the second beat arrives mid-cycle to force an immediate update. The gated pulse is not aligned to the global clock edge and may occur anywhere within cycle $n+1$.\n\nE. Tri-state the outputs of $R_{\\text{out}}$ for the duration of the $2$-cycle assembly, reconnecting them only after both halves have been loaded. Downstream logic is expected to ignore high-impedance for those cycles and then resume sampling when the outputs become driven again.\n\nSelect the single best option that guarantees an atomic external view for all synchronous observers at rising edges, while maintaining standard setup and hold constraints and without violating synchronous design principles.", "solution": "The user wants me to identify the correct architecture for an atomic parallel load of a wide register from a narrower bus, a common problem in digital systems design. I will first validate the problem statement and then proceed to analyze each option based on fundamental principles of synchronous digital logic.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **System:** A synchronous subsystem.\n- **Clock:** A single global clock with period $T$.\n- **Output Register:** $R_{\\text{out}}$, $128$-bit wide.\n- **Sampling:** Downstream logic samples $R_{\\text{out}}$ exclusively at the rising edge of the clock.\n- **Data Bus:** $64$-bit wide.\n- **Data Word:** A $128$-bit word, $W$.\n- **Data Beats:** Two $64$-bit beats, $D_0$ and $D_1$.\n- **Assembly Order:** $W = [D_1 \\parallel D_0]$, where $D_0$ is delivered in cycle $n$ and $D_1$ is delivered in cycle $n+1$.\n- **Core Requirement:** The update of $R_{\\text{out}}$ must be **atomic**.\n- **Atomicity Definition:** \"for any external observer synchronous to the same clock, the output of $R_{\\text{out}}$ is either the previous $128$-bit value or the fully updated $128$-bit value $W$ on any rising edge; no intermediate or partially updated value may ever be observed.\"\n- **Component Properties:**\n    - Edge-triggered flip-flop: Samples data on the active clock edge, respects setup time $t_s$ and hold time $t_h$.\n    - Level-sensitive latch: Transparent when enable is asserted, opaque (holds data) when deasserted.\n- **Control & Data Validity:** Control signals are synchronous. Data beats $D_0$ and $D_1$ are valid for their entire respective cycles.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is set firmly within the established principles of synchronous digital logic design and computer architecture. The components (registers, latches) and concepts (synchronous clocking, atomicity, bus multiplexing, setup/hold times) are standard and factually sound.\n- **Well-Posed:** The problem provides a clear objective (atomic update), specific constraints (bus width, clocking, number of cycles), and a precise definition of atomicity in the context of synchronous observation. This structure allows for a unique and meaningful solution to be determined.\n- **Objective:** The language used is technical, precise, and free of any subjective or ambiguous terminology.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. It is scientifically sound, well-posed, objective, and complete. It describes a classic and practical digital design challenge. I will proceed with the solution.\n\n### Solution Derivation\n\nThe central requirement is atomicity, as defined for a synchronous observer. The observer samples the output of $R_{\\text{out}}$ only at the rising edge of the global clock. Therefore, to ensure atomicity, the $128$ bits of $R_{\\text{out}}$ must present either the complete old value or the complete new value during the setup-and-hold window around every rising clock edge. An intermediate state, such as $[\\text{old_hi} \\parallel D_0]$ or $[D_1 \\parallel \\text{old_lo}]$, must never be stable and visible at a sampling edge.\n\nThe data arrives in two parts, $D_0$ in cycle $n$ and $D_1$ in cycle $n+1$. Loading these parts directly into $R_{\\text{out}}$ on separate cycles would inherently violate atomicity. For instance, loading $D_0$ at the rising edge of cycle $n+1$ would make the state $[\\text{old_hi} \\parallel D_0]$ visible to the observer, which is an explicit violation.\n\nThe correct design pattern must therefore prevent any partial updates from being visible at the output. This is achieved by using a double-buffering, or shadow register, scheme. A temporary, non-visible storage element (the shadow buffer) is used to assemble the full $128$-bit word $W$ from the incoming beats $D_0$ and $D_1$. Once the full word is assembled and stable in the shadow buffer, it is transferred in its entirety to the visible output register $R_{\\text{out}}$ in a single clock cycle.\n\nFor this transfer to be atomic at the clock edge, the output register $R_{\\text{out}}$ must be composed of edge-triggered flip-flops. An edge-triggered register samples its entire data input at a discrete instant in time (the clock edge) and ignores its input at all other times. By presenting the fully formed $128$-bit word to the input of an edge-triggered $R_{\\text{out}}$ and asserting its load-enable for a single clock cycle, the entire $128$-bit state transitions from the old value to the new value at a single rising edge.\n\nBased on this principle, a valid architecture would be:\n1.  Use temporary storage (a shadow buffer) for the two $64$-bit halves. This storage can be built from latches or flip-flops.\n2.  In cycle $n$, capture $D_0$ into the lower half of the shadow buffer.\n3.  In cycle $n+1$, capture $D_1$ into the upper half of the shadow buffer.\n4.  The output of the shadow buffer, now containing the complete word $[D_1 \\parallel D_0]$, is connected to the data input of the final, visible register $R_{\\text{out}}$.\n5.  $R_{\\text{out}}$ must be an edge-triggered register.\n6.  At the rising edge of cycle $n+2$, a control signal enables the load operation of $R_{\\text{out}}$, transferring the complete $128$-bit word from the shadow buffer in one atomic operation.\n\n### Option-by-Option Analysis\n\n**A. Use two $64$-bit level-sensitive latches $L_{\\text{lo}}$ and $L_{\\text{hi}}$ as a shadow buffer. In cycle $n$, assert the enable of $L_{\\text{lo}}$ to capture $D_0$; in cycle $n+1$, assert the enable of $L_{\\text{hi}}$ to capture $D_1$. Feed the concatenated output $[L_{\\text{hi}} \\parallel L_{\\text{lo}}]$ to the $128$-bit edge-triggered register $R_{\\text{out}}$. Generate a synchronous single-cycle commit signal after both halves are captured; this commit asserts the data-load enable of $R_{\\text{out}}$ only at the next rising edge, transferring the entire $128$-bit shadow content into $R_{\\text{out}}$. While the commit is deasserted, $R_{\\text{out}}$ holds its previous value, and the shadow latches can update independently without affecting $R_{\\text{out}}$.**\n\nThis option describes the exact double-buffering scheme derived above. The shadow buffer consists of latches $L_{\\text{lo}}$ and $L_{\\text{hi}}$. These latches assemble the full $128$-bit word over two cycles. During this assembly, the output register $R_{\\text{out}}$ is holding its previous value because its load-enable (`commit` signal) is deasserted. Once the full word is stable at the input of $R_{\\text{out}}$, the `commit` signal is asserted, causing the edge-triggered $R_{\\text{out}}$ to load all $128$ bits simultaneously at a single rising clock edge. An external observer at any rising edge sees either the old value (before the commit) or the new value (after the commit). This guarantees atomicity. The use of level-sensitive latches for the intermediate buffer is a valid and common design choice.\n\n**Verdict: Correct**\n\n**B. Use a single $128$-bit edge-triggered register for $R_{\\text{out}}$ with two independent $64$-bit write-enables. In cycle $n$, assert the lower $64$-bit write-enable to load $D_0$ into the lower half of $R_{\\text{out}}$; in cycle $n+1$, assert the upper $64$-bit write-enable to load $D_1$ into the upper half of $R_{\\text{out}}$. No shadow buffering or commit signal is used; $R_{\\text{out}}$ is updated piecemeal across the two cycles.**\n\nThis architecture performs a piecemeal update directly on the visible output register $R_{\\text{out}}$. At the rising edge at the start of cycle $n+1$, the lower $64$ bits of $R_{\\text{out}}$ will update to $D_0$, while the upper $64$ bits will still hold their old value. An external observer sampling at this edge will see the state $[\\text{old_hi} \\parallel D_0]$. This is an intermediate, partially updated state, which explicitly violates the problem's definition of atomicity.\n\n**Verdict: Incorrect**\n\n**C. Use two $64$-bit edge-triggered flip-flop banks $F_{\\text{lo}}$ and $F_{\\text{hi}}$ to capture $D_0$ and $D_1$ in cycles $n$ and $n+1$ respectively. Concatenate $[F_{\\text{hi}} \\parallel F_{\\text{lo}}]$ and feed it into a $128$-bit level-sensitive output latch $L_{\\text{out}}$ whose enable is held asserted continuously. There is no explicit commit; the outputs of $L_{\\text{out}}$ follow the concatenation as soon as either half updates.**\n\nA level-sensitive latch ($L_{\\text{out}}$) with its enable held continuously asserted is a transparent latch. It behaves like a buffer, meaning its output simply follows its input. The effective output of this circuit is the direct concatenation of the outputs of the flip-flop banks, $[F_{\\text{hi}} \\parallel F_{\\text{lo}}]$. At the rising edge starting cycle $n+1$, $F_{\\text{lo}}$ updates to $D_0$, while $F_{\\text{hi}}$ still holds its old value. The output presented by the transparent latch becomes $[\\text{old_hi} \\parallel D_0]$. This intermediate state is visible for the entire duration of cycle $n+1$, violating atomicity. The final output stage must be edge-triggered, not a transparent latch, to provide the atomic update.\n\n**Verdict: Incorrect**\n\n**D. Use a $128$-bit shadow register $S$ built from edge-triggered flip-flops with independent $64$-bit write-enables to capture $D_0$ and $D_1$ over cycles $n$ and $n+1$. Drive $R_{\\text{out}}$ directly from $S$, and generate an asynchronous gated clock pulse for $R_{\\text{out}}$ as soon as the second beat arrives mid-cycle to force an immediate update. The gated pulse is not aligned to the global clock edge and may occur anywhere within cycle $n+1$.**\n\nThis option proposes using an asynchronous gated clock. This is a severe violation of synchronous design methodology. Such clocks are highly prone to timing hazards like glitches, clock skew, and race conditions, making it difficult or impossible to reliably meet setup and hold times across the system. The problem explicitly requires a solution that follows \"standard synchronous timing rules\". Using an asynchronous clocking scheme is fundamentally unsafe and incorrect in this context.\n\n**Verdict: Incorrect**\n\n**E. Tri-state the outputs of $R_{\\text{out}}$ for the duration of the $2$-cycle assembly, reconnecting them only after both halves have been loaded. Downstream logic is expected to ignore high-impedance for those cycles and then resume sampling when the outputs become driven again.**\n\nTri-stating the output puts it into a high-impedance (Hi-Z) state. This is not a valid logic level. The atomicity requirement states that the output must be \"either the previous $128$-bit value or the fully updated $128$-bit value\". A high-impedance state is neither. This fails to meet the specified requirement. Furthermore, relying on downstream logic to \"ignore\" an undriven bus is poor design practice, as the bus can float to an indeterminate voltage, potentially causing issues in the downstream logic.\n\n**Verdict: Incorrect**", "answer": "$$\\boxed{A}$$", "id": "3672912"}]}