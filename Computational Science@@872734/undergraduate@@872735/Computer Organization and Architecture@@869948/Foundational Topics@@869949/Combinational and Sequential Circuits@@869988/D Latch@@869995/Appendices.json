{"hands_on_practices": [{"introduction": "To master the design of digital systems, one must first have a deep understanding of its fundamental building blocks. This exercise focuses on the core behavior of a gated D latch, exploring how its output $Q$ responds to changes in the data ($D$) and gate ($G$) inputs. By meticulously tracing the signal over time while accounting for propagation delay, you will gain a practical feel for the essential concepts of transparency and opaqueness that define latch operation [@problem_id:1968088].", "problem": "A gated D latch is a fundamental digital logic circuit with one data input (D), one gate input (G), and one output (Q). The behavior of this latch is defined as follows:\n- When the gate input G is HIGH (logic 1), the latch is in \"transparent\" mode, and the output Q follows the state of the data input D.\n- When the gate input G is LOW (logic 0), the latch is in \"opaque\" mode, and the output Q holds its last value, ignoring any changes at the D input.\n\nConsider a specific implementation of this latch that has a uniform propagation delay, $t_{pd} = 2 \\text{ ns}$. This means that any change at the inputs (D or G) that results in a change at the output Q will see that change reflected at Q only after a delay of $t_{pd}$.\n\nThe inputs D and G are subjected to a sequence of transitions over time, starting from $t=0$. Initially, at $t=0$, the output Q is LOW (logic 0). The state of the D and G inputs is also LOW at $t=0$. The subsequent transitions are as follows:\n\n- At $t=10 \\text{ ns}$, input D transitions from LOW to HIGH.\n- At $t=20 \\text{ ns}$, input G transitions from LOW to HIGH.\n- At $t=35 \\text{ ns}$, input D transitions from HIGH to LOW.\n- At $t=45 \\text{ ns}$, input D transitions from LOW to HIGH.\n- At $t=60 \\text{ ns}$, input G transitions from HIGH to LOW.\n- At $t=70 \\text{ ns}$, input D transitions from HIGH to LOW.\n\nYour task is to analyze the behavior of the output Q over time. Calculate the total amount of time that the output Q is in the HIGH state during the time interval from $t=0 \\text{ ns}$ to $t=90 \\text{ ns}$. Express your final answer in nanoseconds.", "solution": "We model a gated D latch with propagation delay $t_{pd}=2\\ \\text{ns}$. The latch behavior is:\n- If $G=1$, the output follows $D$ after delay $t_{pd}$.\n- If $G=0$, the output holds its last value; changes in $D$ produce no effect.\n- A rising transition of $G$ to $1$ causes $Q$ to take the current value of $D$ after $t_{pd}$.\n- A falling transition of $G$ to $0$ does not change $Q$; it only blocks further propagation from $D$.\n\nInitial conditions at $t=0$: $D=0$, $G=0$, $Q=0$.\n\nProceed through the given input transitions:\n\n1) At $t=10\\ \\text{ns}$, $D:0\\to1$ with $G=0$. Since the latch is opaque, there is no effect on $Q$.\n\n2) At $t=20\\ \\text{ns}$, $G:0\\to1$. The latch becomes transparent; since $D=1$ at $t=20\\ \\text{ns}$, $Q$ will update to $1$ after delay $t_{pd}$:\n$$t=20\\ \\text{ns} \\implies Q \\text{ goes to } 1 \\text{ at } 20+2=22\\ \\text{ns}.$$\nThus $Q:0\\to1$ at $t=22\\ \\text{ns}$.\n\n3) At $t=35\\ \\text{ns}$, $D:1\\to0$ with $G=1$. The output will follow after $t_{pd}$:\n$$t=35\\ \\text{ns} \\implies Q \\text{ goes to } 0 \\text{ at } 35+2=37\\ \\text{ns}.$$\nThus $Q:1\\to0$ at $t=37\\ \\text{ns}$.\n\n4) At $t=45\\ \\text{ns}$, $D:0\\to1$ with $G=1$. The output will follow after $t_{pd}$:\n$$t=45\\ \\text{ns} \\implies Q \\text{ goes to } 1 \\text{ at } 45+2=47\\ \\text{ns}.$$\nThus $Q:0\\to1$ at $t=47\\ \\text{ns}$.\n\n5) At $t=60\\ \\text{ns}$, $G:1\\to0$. Closing the gate does not change $Q$; it simply holds the current value. At this moment $Q=1$, and with $G=0$ thereafter, $Q$ remains $1$.\n\n6) At $t=70\\ \\text{ns}$, $D:1\\to0$ with $G=0$. The latch is opaque, so there is no effect on $Q$.\n\nTherefore, the intervals where $Q=1$ are:\n- From $t=22\\ \\text{ns}$ to $t=37\\ \\text{ns}$, duration $37-22=15\\ \\text{ns}$.\n- From $t=47\\ \\text{ns}$ to $t=90\\ \\text{ns}$, duration $90-47=43\\ \\text{ns}$.\n\nThe total time $Q$ is HIGH between $t=0\\ \\text{ns}$ and $t=90\\ \\text{ns}$ is\n$$15\\ \\text{ns} + 43\\ \\text{ns} = 58\\ \\text{ns}.$$", "answer": "$$\\boxed{58}$$", "id": "1968088"}, {"introduction": "One of the primary reasons for using latches instead of flip-flops in high-performance pipelines is the ability to perform \"time borrowing.\" This powerful technique allows a computationally intensive stage to exceed the nominal clock phase duration by borrowing time from a subsequent, faster stage. This practice challenges you to quantify this advantage by comparing a traditional flip-flop-based design with a latch-based one, calculating the precise amount of additional delay budget gained, and thus providing a concrete understanding of a key optimization in modern processor design [@problem_id:3631751].", "problem": "A synchronous pipeline initially uses positive-edge-triggered D-type flip-flops to separate combinational stages. You are given the following parameters for this baseline design:\n- The clock period is $2.0$ ns.\n- The clock-to-$Q$ delay of the launching flip-flop is $0.10$ ns.\n- The setup time of the capturing flip-flop is $0.05$ ns.\n- The aggregate timing uncertainty (including skew and jitter) to be subtracted from the usable cycle time is $0.08$ ns.\nFor this baseline, the critical path between two flip-flops must meet the corresponding timing requirement.\n\nTo attempt to close timing on an overly long critical path, the boundary is re-architected to use a pair of level-sensitive D latches (a high-phase latch followed by a low-phase latch) clocked by a two-phase, non-overlapping clock derived from the same period. The two-phase clock within one cycle has the following timing:\n- The high-phase latch is transparent for $T_{\\mathrm{H}} = 0.96$ ns beginning at the start of the cycle.\n- There is a non-overlap gap of $g = 0.01$ ns between the end of the high-phase transparency and the beginning of the low-phase transparency.\n- The low-phase latch is transparent for $T_{\\mathrm{L}} = 1.02$ ns.\n- There is a non-overlap gap of $g' = 0.01$ ns before the next cycle begins, so that $T_{\\mathrm{H}} + g + T_{\\mathrm{L}} + g' = 2.0$ ns.\nDevice-level parameters for the latch-based boundary are:\n- The clock-to-$Q$ delay of the launching latch is $0.02$ ns.\n- The setup time of the capturing latch is $0.04$ ns.\n- Worst-case clock uncertainty affecting the useful time window is modeled as a $0.02$ ns late opening of the launching latch and a $0.02$ ns early closing of the capturing latch; subtract both from the usable time budget.\n\nAssume that minimum-delay (hold time) constraints are satisfied and non-limiting, and that the subsequent stage has sufficient slack so that any time borrowed from the low phase is not further constrained. Using only the core definitions of setup time, clock-to-$Q$ delay, and level sensitivity, derive from first principles:\n1) the maximum allowable combinational-path delay under the flip-flop-based boundary,\n2) the maximum allowable combinational-path delay under the latch-based boundary, and\n3) the maximum additional delay budget $\\Delta d$ that the latch-based boundary affords over the flip-flop-based boundary.\n\nExpress your final answer as the single value of $\\Delta d$ in picoseconds, rounded to three significant figures.", "solution": "The problem asks for a comparison of the maximum allowable combinational logic delay between two scenarios: a standard synchronous pipeline using positive-edge-triggered flip-flops, and a re-architected pipeline boundary using a pair of level-sensitive latches with a two-phase clock.\n\n**1. Maximum Allowable Delay for Flip-Flop Boundary ($d_{\\mathrm{comb,ff}}$)**\n\nFor a pipeline stage between two positive-edge-triggered D-type flip-flops (a launching flip-flop FF1 and a capturing flip-flop FF2), the setup time constraint dictates the maximum delay of the combinational logic. The signal launched by FF1 on a clock edge must propagate through the combinational logic and arrive at the input of FF2, where it must be stable for a duration of at least the setup time, $t_{\\mathrm{setup}}$, before the next clock edge arrives at FF2.\n\nThe total clock period is $T_{\\mathrm{clk}}$. The path starts at a clock edge (let's say at $t=0$). The data appears at the output of FF1 after the clock-to-Q delay, $t_{\\mathrm{clk-q}}$. It then traverses the combinational logic, taking a time $d_{\\mathrm{comb,ff}}$. The total time taken is $t_{\\mathrm{clk-q}} + d_{\\mathrm{comb,ff}}$. This signal must arrive at FF2's input no later than $t_{\\mathrm{setup}}$ before the next clock edge at $T_{\\mathrm{clk}}$. Furthermore, any timing uncertainty, $t_{\\mathrm{uncert}}$ (due to clock skew and jitter), reduces the usable portion of the clock cycle.\n\nThe governing timing equation is therefore:\n$$t_{\\mathrm{clk-q}} + d_{\\mathrm{comb,ff}} + t_{\\mathrm{setup}} \\le T_{\\mathrm{clk}} - t_{\\mathrm{uncert}}$$\nSolving for the maximum allowable combinational delay, $d_{\\mathrm{comb,ff,max}}$:\n$$d_{\\mathrm{comb,ff,max}} = T_{\\mathrm{clk}} - t_{\\mathrm{clk-q}} - t_{\\mathrm{setup}} - t_{\\mathrm{uncert}}$$\nSubstituting the given values for the flip-flop based design:\n- Clock period, $T_{\\mathrm{clk}} = 2.0 \\text{ ns}$\n- Clock-to-Q delay, $t_{\\mathrm{clk-q}} = 0.10 \\text{ ns}$\n- Setup time, $t_{\\mathrm{setup}} = 0.05 \\text{ ns}$\n- Aggregate timing uncertainty, $t_{\\mathrm{uncert}} = 0.08 \\text{ ns}$\n\n$$d_{\\mathrm{comb,ff,max}} = 2.0 - 0.10 - 0.05 - 0.08 = 1.77 \\text{ ns}$$\n\n**2. Maximum Allowable Delay for Latch-Based Boundary ($d_{\\mathrm{comb,latch}}$)**\n\nIn the latch-based design, the boundary consists of a high-phase latch (L1) followed by a low-phase latch (L2). This architecture allows for \"time borrowing,\" where a long combinational path can use a time budget that spans across the transparent phases of both latches.\n\nThe critical path for setup time analysis extends from the data input of L1, through L1's internal delay, through the combinational logic, to the data input of L2, where it must meet the setup time requirement before L2 closes.\n\nLet the start of the cycle be $t=0$.\n- L1 (high-phase) is transparent from $t=0$ to $t=T_{\\mathrm{H}} = 0.96 \\text{ ns}$.\n- L2 (low-phase) is transparent from $t=T_{\\mathrm{H}} + g = 0.97 \\text{ ns}$ to $t=T_{\\mathrm{H}} + g + T_{\\mathrm{L}} = 1.99 \\text{ ns}$.\n\nThe total time available for the signal to propagate from the input of L1 to be captured by L2 spans from the beginning of the high phase to the end of the low phase. We must account for all overheads within this window.\n\nLet's establish the worst-case timeline for the setup constraint:\n- The clock signal enabling L1 (the launching latch) may be delayed, causing a late opening. This pushes the launch time forward. The latest launch time for the signal at the output of L1 occurs at $t = t_{\\mathrm{uncert,open}} + t_{\\mathrm{clk-q,latch}}$, assuming data is ready at L1's input at the start of the cycle.\n- The signal then propagates through the combinational logic, taking a time $d_{\\mathrm{comb,latch}}$.\n- The arrival time at the input of L2 is $T_{\\mathrm{arrival}} = t_{\\mathrm{uncert,open}} + t_{\\mathrm{clk-q,latch}} + d_{\\mathrm{comb,latch}}$.\n- The clock signal disabling L2 (the capturing latch) may arrive early, shortening the available time. The effective closing time of L2 is $(T_{\\mathrm{H}} + g + T_{\\mathrm{L}}) - t_{\\mathrm{uncert,close}}$.\n- To satisfy the setup constraint, the signal must be stable at L2's input at least $t_{\\mathrm{setup,latch}}$ before this early closing.\n- The required arrival time is $T_{\\mathrm{required}} = (T_{\\mathrm{H}} + g + T_{\\mathrm{L}}) - t_{\\mathrm{uncert,close}} - t_{\\mathrm{setup,latch}}$.\n\nThe timing constraint is $T_{\\mathrm{arrival}} \\le T_{\\mathrm{required}}$:\n$$t_{\\mathrm{uncert,open}} + t_{\\mathrm{clk-q,latch}} + d_{\\mathrm{comb,latch}} \\le (T_{\\mathrm{H}} + g + T_{\\mathrm{L}}) - t_{\\mathrm{uncert,close}} - t_{\\mathrm{setup,latch}}$$\nSolving for the maximum allowable combinational delay, $d_{\\mathrm{comb,latch,max}}$:\n$$d_{\\mathrm{comb,latch,max}} = (T_{\\mathrm{H}} + g + T_{\\mathrm{L}}) - t_{\\mathrm{clk-q,latch}} - t_{\\mathrm{setup,latch}} - t_{\\mathrm{uncert,open}} - t_{\\mathrm{uncert,close}}$$\nSubstituting the given values for the latch-based design:\n- High-phase transparency, $T_{\\mathrm{H}} = 0.96 \\text{ ns}$\n- Non-overlap gap, $g = 0.01 \\text{ ns}$\n- Low-phase transparency, $T_{\\mathrm{L}} = 1.02 \\text{ ns}$\n- Latch clock-to-Q delay, $t_{\\mathrm{clk-q,latch}} = 0.02 \\text{ ns}$\n- Latch setup time, $t_{\\mathrm{setup,latch}} = 0.04 \\text{ ns}$\n- Late opening uncertainty, $t_{\\mathrm{uncert,open}} = 0.02 \\text{ ns}$\n- Early closing uncertainty, $t_{\\mathrm{uncert,close}} = 0.02 \\text{ ns}$\n\nFirst, calculate the total time window: $T_{\\mathrm{H}} + g + T_{\\mathrm{L}} = 0.96 + 0.01 + 1.02 = 1.99 \\text{ ns}$.\n$$d_{\\mathrm{comb,latch,max}} = 1.99 - 0.02 - 0.04 - 0.02 - 0.02 = 1.89 \\text{ ns}$$\n\n**3. Additional Delay Budget ($\\Delta d$)**\n\nThe additional delay budget afforded by the latch-based boundary is the difference between the maximum allowable delays of the two architectures.\n$$\\Delta d = d_{\\mathrm{comb,latch,max}} - d_{\\mathrm{comb,ff,max}}$$\n$$\\Delta d = 1.89 \\text{ ns} - 1.77 \\text{ ns} = 0.12 \\text{ ns}$$\nThe problem asks for the answer in picoseconds (ps), where $1 \\text{ ns} = 1000 \\text{ ps}$.\n$$\\Delta d = 0.12 \\times 1000 \\text{ ps} = 120 \\text{ ps}$$\nThe final answer is required to be rounded to three significant figures. The calculated value is exactly $120$, which can be expressed as $1.20 \\times 10^2$, having three significant figures.", "answer": "$$\n\\boxed{120}\n$$", "id": "3631751"}, {"introduction": "While latches offer performance benefits, their level-sensitive nature introduces unique design challenges that every hardware designer must learn to identify and prevent. When writing Register Transfer Level (RTL) code, it is easy to unintentionally describe a circuit that holds its state, which synthesis tools will implement as an \"inferred\" latch. This practice delves into the critical real-world problem of how these inferred latches can create hazardous combinational feedback loops when transparent, challenging you to reason about the static analysis techniques required to detect and prevent these subtle but potentially catastrophic design flaws [@problem_id:3631689].", "problem": "Consider a Register Transfer Level (RTL) module that contains combinational logic and a level-sensitive $D$ latch. A level-sensitive $D$ latch with enable $E$ has an input $D$ and an output $Q$, and exhibits the following behavior: when $E=1$, the latch is transparent and the output $Q$ follows $D$ after a finite propagation delay; when $E=0$, the latch holds its previous output value. Let there be signals $x$, $y$, $d$, $q$, and $e$, where $e$ drives the enable $E$ of the latch. Suppose $y$ is computed by a combinational function $f$ such that $y=f(x,q)$, and $d$ is computed by a combinational function $g$ such that $d=g(y)$. The $D$ latch connects $d$ to $q$ with enable $e$, so when $e=1$ the path $y \\rightarrow d \\rightarrow q \\rightarrow y$ is closed through the latch transparency. In a synthesis context, unintended level-sensitive storage can be inferred by the synthesizer when a combinational process does not assign a target signal on all input-conditioned paths, thereby implying a hold of the previous value.\n\nUsing the fundamental definitions that a combinational network computes outputs as functions of current inputs without internal state, that feedback cycles composed only of zero-delay edges form algebraic loops, and that a level-sensitive $D$ latch behaves like a transparent buffer when $E=1$ but as a state-holding element when $E=0$, determine which of the following statements correctly explain the mechanism by which unintentional combinational loops can arise in the presence of a $D$ latch and specify a sound static analysis procedure to detect both inferred latches and potential loops.\n\nChoose all that apply.\n\nA. Build a directed graph $G=(V,\\mathcal{E})$ of signal dependencies where each vertex in $V$ represents a signal and each edge in $\\mathcal{E}$ represents a combinational dependency with label indicating whether it is a combinational edge (zero-delay) or passes through a level-sensitive $D$ latch. Model a latch edge as zero-delay whenever $E=1$ and as breaking the path whenever $E=0$. Compute the strongly connected components (SCCs) of $G$ under the condition $E=1$ and flag any SCC that contains only zero-delay edges as a potential combinational loop. Separately, for each signal $s$ assigned in a combinational process, collect the set of guards $\\{\\gamma_i\\}$ under which $s$ is assigned and check whether $\\bigvee_i \\gamma_i$ is a tautology $\\top$. If $\\bigvee_i \\gamma_i \\neq \\top$, then $s$ is not assigned on some input-conditioned path and an inferred latch is present.\n\nB. Combinational loops in RTL are harmless because synthesis tools automatically insert edge-triggered registers to break such loops; therefore no special detection or modeling of latch transparency is needed.\n\nC. To detect inferred latches, formalize each combinational process as a decision tree over input conditions and, for each target signal $s$, compute the disjunction of assignment-guard predicates $\\bigvee_i \\gamma_i$ across all paths. If the disjunction does not equal $\\top$, there exists an input valuation under which $s$ is not assigned and the implementation will hold the previous value, which is equivalent to a level-sensitive $D$ latch. For loop detection, treat a level-sensitive latch as combinational when $E=1$ and as sequential when $E=0$, and analyze cycles accordingly.\n\nD. Initialize all unassigned signals to $0$ during analysis to eliminate inferred latches and loops; because a default of $0$ breaks feedback dependence on previous values, further analysis of assignment coverage or latch transparency is unnecessary.\n\nE. Detect loops by performing a topological sort on the dependency graph after removing all edges that pass through either an edge-triggered register or a level-sensitive $D$ latch, regardless of the value of $E$. If the sort fails, report a loop; otherwise report no loop. This is sound because any latch is a sequential element that breaks cycles for all $E$.", "solution": "The reasoning proceeds from well-established definitions in digital design and graph theory. A combinational network implements a function $Y=F(X)$ of current inputs $X$ with no internal state; therefore it can be topologically ordered and contains no cycles composed solely of zero-delay edges. A sequential element introduces state and can break cycles. A level-sensitive $D$ latch has two regimes: when $E=1$, it is transparent and behaves as a zero-delay path from $D$ to $Q$ modulo propagation delay, and when $E=0$, it holds $Q$ and thus breaks dependence on the current $D$. In RTL synthesis, an inferred latch arises when a combinational process fails to assign a target signal on some path; the hardware must preserve the previous value, which is equivalent to inserting a level-sensitive latch with $E$ conditioned on the path coverage.\n\nTo analyze loops rigorously, we construct a directed graph $G=(V,\\mathcal{E})$ where each signal is a vertex in $V$. For a combinational assignment $y=f(x,q)$, we include edges $(x \\rightarrow y)$ and $(q \\rightarrow y)$ in $\\mathcal{E}$ as zero-delay edges. For $d=g(y)$, include edge $(y \\rightarrow d)$ as zero-delay. For the $D$ latch from $d$ to $q$ with enable $E$, include an edge $(d \\rightarrow q)$ whose effective delay and existence depend on $E$: when $E=1$, the latch passes $d$ to $q$ and the edge behaves like a zero-delay edge for the purposes of instantaneous dependency; when $E=0$, the edge does not propagate new information and thus does not form part of a combinational path. A combinational loop exists when there is a directed cycle composed of zero-delay edges for some valuation of control signals such that the cycle is closed. Detecting such cycles can be done by computing the strongly connected components (SCCs) under the condition $E=1$; any SCC that includes only zero-delay edges indicates a cycle. Because transparency depends on $E$, the analysis must be conditional: a loop is flagged if there exists an input valuation with $E=1$ that yields a zero-delay cycle.\n\nFor inferred latches, consider a combinational process that assigns a signal $s$ under a set of mutually conditioned guards $\\{\\gamma_i\\}$. If $\\bigvee_i \\gamma_i=\\top$ (the tautology), then $s$ is assigned on all input-conditioned paths and no latch is inferred. If $\\bigvee_i \\gamma_i \\neq \\top$, then there exists an input valuation under which $s$ is not assigned in that clockless process, and $s$ must hold its prior value, which is precisely the behavior of a level-sensitive $D$ latch. This guard coverage check can be formalized by translating guards $\\gamma_i$ to Boolean predicates over the process inputs and evaluating whether their disjunction equals $\\top$; equivalently, testing satisfiability of $\\neg\\bigvee_i \\gamma_i$ identifies a valuation that causes a missing assignment.\n\nWith these principles, we examine each option:\n\nA. This option proposes a graph-based dependency model $G=(V,\\mathcal{E})$ and explicitly treats the latch edge as zero-delay when $E=1$ and as breaking the path when $E=0$. It then computes SCCs under $E=1$ and flags any SCC containing only zero-delay edges as a potential combinational loop. This matches the fundamental definition of a combinational loop as a zero-delay cycle and correctly accounts for latch transparency. The second part proposes the guard-coverage analysis: for each signal $s$ in a combinational process, collect guards $\\{\\gamma_i\\}$ and check whether $\\bigvee_i \\gamma_i=\\top$; otherwise, report an inferred latch. This is a sound static analysis directly aligned with the semantics of RTL synthesis. Verdict: Correct.\n\nB. This option claims that synthesis tools automatically insert edge-triggered registers to break combinational loops, making loops harmless and eliminating the need for detection. This contradicts standard synthesis behavior: tools commonly report combinational loops as errors or warnings, and they do not silently insert edge-triggered registers because that would change functionality by adding state and latency. Moreover, even if a tool attempted mitigation, ignoring latch transparency is unsound. Verdict: Incorrect.\n\nC. This option focuses on inferred latch detection via decision-tree modeling of combinational processes, computing $\\bigvee_i \\gamma_i$ for assignment guards, and reporting a latch if the disjunction is not $\\top$. This is the same guard coverage principle described above and is sound. It also states that, for loop detection, the level-sensitive latch must be treated as combinational when $E=1$ and as sequential when $E=0$, analyzing cycles conditionally. This is consistent with the fundamental behavior of latches and the definition of algebraic loops. Verdict: Correct.\n\nD. This option suggests initializing all unassigned signals to $0$ to eliminate inferred latches and loops. Assigning a default $0$ in analysis does not reflect hardware semantics unless the RTL explicitly assigns $0$ on those paths; otherwise, hardware will hold the previous value, which is a latch. Moreover, setting $0$ in analysis can mask true dependencies and cycles, producing false negatives. It fails to model latch transparency and guard coverage. Verdict: Incorrect.\n\nE. This option removes all latch edges regardless of $E$ to perform a topological sort for loop detection. Treating a level-sensitive latch as always breaking cycles is unsound because when $E=1$ the latch is transparent and can participate in zero-delay cycles, potentially creating combinational loops. Ignoring $E$ loses critical conditional behavior and can miss loops that occur during transparency. Verdict: Incorrect.\n\nTherefore, the correct options are A and C, which together accurately explain the mechanisms and provide sound static analyses for both inferred latches and combinational loops in the presence of level-sensitive $D$ latches.", "answer": "$$\\boxed{AC}$$", "id": "3631689"}]}