{"hands_on_practices": [{"introduction": "Understanding register renaming begins with tracing the core data structures that make it possible. This first practice provides a direct, hands-on look at the rename map table (RMT) and the free list of physical registers. By manually tracking their state as a sequence of instructions is processed, you will see precisely how write-after-read (WAR) and write-after-write (WAW) name dependencies are mechanically eliminated, building a concrete foundation for how modern processors manage data flow [@problem_id:3672363].", "problem": "Consider an out-of-order superscalar processor that uses register renaming with a rename map table (RMT), an Architectural Map Table (AMT), and a free list of physical registers to eliminate name dependencies. There are $4$ architectural registers $\\{R_1, R_2, R_3, R_4\\}$ and a total of $P$ physical registers $\\{p_1, p_2, \\dots, p_P\\}$. Initially, the AMT and RMT are identical and map one-to-one as $R_1 \\mapsto p_1$, $R_2 \\mapsto p_2$, $R_3 \\mapsto p_3$, $R_4 \\mapsto p_4$. The free list initially contains $\\langle p_5, p_6, \\dots, p_P \\rangle$ in that order.\n\nThe processor uses the following renaming and freeing rules derived from the standard definitions of register renaming for precise exceptions:\n- On renaming an instruction that writes an architectural destination register $R_d$, the renamer allocates a fresh physical register $p_{\\text{new}}$ from the head of the free list and updates the RMT entry to $R_d \\mapsto p_{\\text{new}}$. The instruction records the physical register $p_{\\text{old}}$ that was previously mapped to $R_d$ in the RMT at that moment as its prior mapping.\n- Source operands are renamed by reading the current RMT at rename time. Reads use the producer’s physical registers, removing write-after-read (WAR) hazards.\n- At in-order commit of a writing instruction to $R_d$, the AMT is updated to the instruction’s destination physical register, and the recorded prior mapping $p_{\\text{old}}$ for $R_d$ is returned to the free list. No physical register is freed before commit. Commit is strictly in program order.\n- There are no exceptions or squashes in this scenario.\n\nThe following three instructions enter the pipeline and are renamed back-to-back before any instruction commits:\n- $I_1$: $R_1 \\leftarrow R_2 + R_3$\n- $I_2$: $R_2 \\leftarrow R_4$\n- $I_3$: $R_1 \\leftarrow R_1 + 1$\n\nTasks:\n- Trace the RMT and free list after the renaming of each instruction $I_1$, $I_2$, and $I_3$, explaining how WAR and write-after-write (WAW) hazards are eliminated in this sequence by the renaming process. Use the rules above and assume no instruction commits until all three are renamed.\n- Based on the trace and the stated rules, determine the minimum total number of physical registers $P$ required to avoid a rename stall (i.e., to ensure the free list is never empty when a destination allocation is needed) during the renaming of this three-instruction sequence.\n\nProvide your final answer as a single integer for $P$. No rounding is required.", "solution": "Here is a detailed trace of the processor's state to determine the minimum number of physical registers required.\n\n**Initial State:**\n*   Rename Map Table (RMT): $\\{R_1 \\mapsto p_1, R_2 \\mapsto p_2, R_3 \\mapsto p_3, R_4 \\mapsto p_4\\}$\n*   Free List: $\\langle p_5, p_6, p_7, \\dots \\rangle$\n\n**1. Rename $I_1: R_1 \\leftarrow R_2 + R_3$**\n*   **Sources**: The RMT is consulted for sources $R_2$ and $R_3$, yielding physical registers $p_2$ and $p_3$.\n*   **Destination**: For the destination $R_1$, a new physical register, $p_5$, is allocated from the head of the free list.\n*   **Update**: The RMT is updated to map $R_1$ to its new physical location: $R_1 \\mapsto p_5$.\n*   **State After Renaming $I_1$**:\n    *   RMT: $\\{R_1 \\mapsto p_5, R_2 \\mapsto p_2, R_3 \\mapsto p_3, R_4 \\mapsto p_4\\}$\n    *   Free List: $\\langle p_6, p_7, \\dots \\rangle$\n*   The instruction is dispatched as $p_5 \\leftarrow p_2 + p_3$. The ROB entry for $I_1$ records that the previous physical register for $R_1$ was $p_1$.\n\n**2. Rename $I_2: R_2 \\leftarrow R_4$**\n*   **Source**: The RMT lookup for $R_4$ yields $p_4$.\n*   **Destination**: For the destination $R_2$, a new physical register, $p_6$, is allocated.\n*   **Update**: The RMT is updated: $R_2 \\mapsto p_6$.\n*   **State After Renaming $I_2$**:\n    *   RMT: $\\{R_1 \\mapsto p_5, R_2 \\mapsto p_6, R_3 \\mapsto p_3, R_4 \\mapsto p_4\\}$\n    *   Free List: $\\langle p_7, \\dots \\rangle$\n*   **WAR Hazard Elimination**: The Write-After-Read (WAR) hazard between $I_1$ (reading $R_2$) and $I_2$ (writing $R_2$) is eliminated. $I_1$ was renamed to read from the old physical register $p_2$, while $I_2$ will write its result to the new physical register $p_6$. The instructions can execute out of order without conflict.\n\n**3. Rename $I_3: R_1 \\leftarrow R_1 + 1$**\n*   **Source**: The RMT lookup for $R_1$ yields $p_5$ (the destination of $I_1$). This correctly preserves the true Read-After-Write (RAW) dependency between $I_1$ and $I_3$.\n*   **Destination**: For the destination $R_1$, a new physical register, $p_7$, is allocated.\n*   **Update**: The RMT is updated: $R_1 \\mapsto p_7$.\n*   **State After Renaming $I_3$**:\n    *   RMT: $\\{R_1 \\mapsto p_7, R_2 \\mapsto p_6, R_3 \\mapsto p_3, R_4 \\mapsto p_4\\}$\n    *   Free List: $\\langle p_8, \\dots \\rangle$\n*   **WAW Hazard Elimination**: The Write-After-Write (WAW) hazard between $I_1$ (writing $R_1$) and $I_3$ (writing $R_1$) is eliminated. They write to distinct physical registers, $p_5$ and $p_7$, respectively.\n\n**Calculating Minimum $P$:**\nTo rename all three instructions without stalling, the free list must provide a new physical register for each of the three writes. After renaming the three instructions but before any commit, the following physical registers are simultaneously live:\n*   $p_1$: The original mapping for $R_1$. It is held until $I_1$ commits.\n*   $p_2$: The original mapping for $R_2$. It is held until $I_2$ commits.\n*   $p_3$: The mapping for $R_3$.\n*   $p_4$: The mapping for $R_4$.\n*   $p_5$: Allocated as the destination for $I_1$ and is a source for $I_3$. It is held until $I_3$ commits.\n*   $p_6$: Allocated as the destination for $I_2$.\n*   $p_7$: Allocated as the destination for $I_3$.\n\nAll seven physical registers ($p_1$ through $p_7$) are simultaneously in use. The initial architectural state required 4 physical registers. Renaming the three instructions required allocating 3 additional registers from the free list. Thus, the total number of physical registers needed is $4 + 3 = 7$.\nIf $P=7$, the initial free list is $\\langle p_5, p_6, p_7 \\rangle$. Renaming consumes one register at each step, leaving the list empty after the third rename, but no stall occurs. If $P  7$, the free list would be exhausted before all instructions are renamed, causing a stall. Therefore, the minimum required value for $P$ is 7.", "answer": "$$\\boxed{7}$$", "id": "3672363"}, {"introduction": "After seeing *how* register renaming works, the next crucial question is *why* it is so important for performance. This exercise moves from mechanism to impact by analyzing the execution of a simple loop, a common source of instruction-level parallelism. You will calculate the performance with and without register renaming to quantify the speedup, directly connecting the elimination of name dependencies to a tangible increase in processor throughput [@problem_id:3672407].", "problem": "An out-of-order superscalar processor implements register renaming using a Register Alias Table (RAT) that maps architectural registers to physical registers in a large physical register file. Data dependence types are defined as follows: read-after-write (RAW) is a true dependence, write-after-read (WAR) and write-after-write (WAW) are name dependencies. A name dependence constrains issue without register renaming but is eliminated when distinct physical registers are assigned to different dynamic instances of the same architectural register.\n\nConsider the following loop, written in idealized assembly-like pseudocode, where $R1$ is an accumulator (architectural register carrying a true loop-carried dependence), $R2$ is a temporary architectural register reused each iteration, $R3$ is a load destination, and $R5$ is a constant multiplier:\n1. $R3 \\leftarrow \\text{load}(A[i])$\n2. $R1 \\leftarrow R1 + R3$\n3. $R2 \\leftarrow R3 \\times R5$\n4. $R8 \\leftarrow R2 + R9$\n\nAssume:\n- The processor can issue up to $w = 4$ instructions per cycle, with at most $1$ memory operation per cycle, at most $1$ multiply per cycle, and at most $2$ integer arithmetic logic unit (ALU) operations per cycle.\n- Latencies to produce results are: load-to-use $= 3$ cycles, integer add $= 1$ cycle, multiply $= 3$ cycles. The multiplier is fully pipelined (it can accept $1$ new multiply per cycle and produces a result $3$ cycles later). Integer ALU operations are single-cycle and fully bypassed.\n- Perfect branch prediction and perfect caches; no structural or memory aliasing hazards beyond the unit limits above.\n- The physical register file has at least $32$ integer physical registers, sufficient to hold independent physical versions of $R2$ for multiple in-flight iterations.\n- Architectural $R1$ carries a true loop-carried RAW dependence: $R1$ produced in one iteration is consumed by the next iteration’s instruction $2$. Architectural $R2$ is only a temporary within each iteration and is not read by subsequent iterations except as constrained by name dependencies without renaming.\n\nTwo execution modes are considered:\n- Mode N (no renaming of $R2$): the machine enforces WAR and WAW constraints on architectural $R2$, so an iteration’s write to $R2$ cannot be issued before any earlier scheduled read of $R2$ from a previous iteration, and multiple writes to $R2$ must complete in program order.\n- Mode R (register renaming): each iteration’s architectural $R2$ is mapped to an independent physical register $P2_i$, eliminating WAR and WAW on $R2$ across iterations. The true dependence on $R1$ remains.\n\nUnder steady-state conditions, determine the initiation interval (II), defined as the average number of cycles per completed loop iteration in steady state, for Mode N and Mode R, and the corresponding speedup (Mode R relative to Mode N). Choose the correct statement.\n\nA. With register renaming, steady-state initiation interval is $1$ cycle per iteration; without renaming it is $4$ cycles per iteration; speedup is $4\\times$.\n\nB. With register renaming, steady-state initiation interval is $2$ cycles per iteration; without renaming it is $4$ cycles per iteration; speedup is $2\\times$.\n\nC. Register renaming yields no throughput benefit: both modes have steady-state initiation interval $= 1$ cycle per iteration due to the true dependence on $R1$.\n\nD. With register renaming, steady-state initiation interval is $3$ cycles per iteration; without renaming it is $3$ cycles per iteration; speedup is $1\\times$.", "solution": "To determine the steady-state performance, we calculate the initiation interval (II), which is the maximum of the resource-constrained II ($ResII$) and the recurrence-constrained II ($RecII$).\n\n**1. Resource-Constrained Initiation Interval ($ResII$)**\nThe loop body contains 4 instructions: 1 load, 1 multiply, and 2 ALU operations. The machine has 1 memory unit, 1 multiply unit, and 2 ALU units, with an issue width of 4.\n*   Memory constraint: $\\lceil 1 \\text{ load} / 1 \\text{ memory unit} \\rceil = 1$ cycle.\n*   Multiplier constraint: $\\lceil 1 \\text{ multiply} / 1 \\text{ multiply unit} \\rceil = 1$ cycle.\n*   ALU constraint: $\\lceil 2 \\text{ adds} / 2 \\text{ ALU units} \\rceil = 1$ cycle.\n*   Issue width constraint: $\\lceil 4 \\text{ instructions} / 4 \\text{ issue slots} \\rceil = 1$ cycle.\nThe overall resource constraint is $ResII = \\max(1, 1, 1, 1) = 1$ cycle. This means the machine could potentially start a new iteration every cycle if not limited by dependencies.\n\n**2. Mode R: With Register Renaming**\nIn this mode, register renaming eliminates all name dependencies (WAR, WAW). We only need to consider true (RAW) dependencies. The only loop-carried dependence is the RAW dependence on register $R1$.\n*   **Recurrence:** Instruction 2 from iteration $i$, $I2_i: R1 \\leftarrow R1 + R3$, depends on the result of instruction 2 from the previous iteration, $I2_{i-1}$.\n*   **Latency:** The latency of this recurrence path is determined by the latency of the instruction itself, which is the ADD operation. The ADD latency is 1 cycle.\n*   Therefore, the recurrence-constrained interval is $RecII_R = 1$ cycle.\nThe initiation interval for Mode R is $II_R = \\max(ResII, RecII_R) = \\max(1, 1) = 1$ cycle per iteration.\n\n**3. Mode N: No Renaming of $R2$**\nWithout renaming $R2$, name dependencies involving this register create additional loop-carried recurrences that constrain performance.\n*   The RAW recurrence on $R1$ still provides a lower bound of 1 cycle.\n*   A WAW (Write-After-Write) dependence exists on $R2$ between instruction $I3$ of iteration $i$ and iteration $i-1$. This forces a 3-cycle recurrence due to the multiply latency.\n*   More critically, a WAR (Write-After-Read) dependence chain exists across iterations. Let's trace the dependencies involving $R2$:\n    1.  In iteration $i$, instruction $I3_i$ ($R2 \\leftarrow R3 \\times R5$) writes to $R2$.\n    2.  In the same iteration, instruction $I4_i$ ($R8 \\leftarrow R2 + R9$) reads from $R2$. This is a RAW dependency, so $I4_i$ must wait for $I3_i$ to complete (3 cycles).\n    3.  In the next iteration, $i+1$, instruction $I3_{i+1}$ writes to $R2$. This creates a WAR hazard with $I4_i$, which reads the \"old\" value of $R2$. Without renaming, $I3_{i+1}$ cannot issue until after $I4_i$ has read its source operand (i.e., has issued).\n*   This creates a loop-carried recurrence: $I3_i \\xrightarrow{\\text{RAW, 3 cycles}} I4_i \\xrightarrow{\\text{WAR, 1 cycle}} I3_{i+1}$.\n*   The total latency of this recurrence is the time from the issue of $I3_i$ to the earliest possible issue of $I3_{i+1}$. This is the latency of the RAW dependency (3 cycles) plus the latency of the WAR dependency (1 cycle), for a total of 4 cycles.\n*   Thus, the recurrence-constrained interval is $RecII_N = 4$ cycles.\nThe initiation interval for Mode N is $II_N = \\max(ResII, RecII_N) = \\max(1, 4) = 4$ cycles per iteration.\n\n**4. Speedup Calculation**\nThe speedup of Mode R relative to Mode N is the ratio of their execution times, which is the inverse ratio of their initiation intervals.\nSpeedup = $\\frac{II_N}{II_R} = \\frac{4 \\text{ cycles/iteration}}{1 \\text{ cycle/iteration}} = 4\\times$.\n\nThe correct statement is that with renaming, the II is 1 cycle; without renaming, it is 4 cycles; and the speedup is 4x. This corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "3672407"}, {"introduction": "The robustness of a processor's design lies in its ability to maintain correctness even when implementing complex optimizations and handling exceptional events. This final practice explores one such scenario: the interaction between move elimination—a common renaming optimization—and precise exception handling. By analyzing the instruction flow, you will verify how the core principles of decoupling logical from physical registers, combined with in-order retirement, ensure the architectural state remains correct, reinforcing the elegance and power of the register renaming model [@problem_id:3672382].", "problem": "Consider an out-of-order superscalar core that implements register renaming with a Physical Register File (PRF), a Register Alias Table (RAT), a Retirement Register Alias Table (RRAT), and a Reorder Buffer (ROB). The RAT provides the current speculative mapping from architectural registers to physical registers, denoted by the function $M_{RAT}(r)$ for an architectural register $r$. The RRAT holds the last committed architectural state as mappings $M_{RRAT}(r)$, updated strictly in program order at commit. The ROB enforces in-order retirement and records, for each instruction, its destination architectural register, the newly produced physical register (if any), and the previously mapped physical register (to be freed when it becomes dead). Exceptions are reported precisely by committing all older instructions up to the fault and then stopping at the faulting instruction; the machine state presented to the handler corresponds to a sequential execution prefix.\n\nThe renamer performs move elimination: a speculative move $MOV\\ r_d \\leftarrow r_s$ that only copies a value is implemented by setting $M_{RAT}(r_d) \\gets M_{RAT}(r_s)$ without allocating a new physical register, and by increasing the logical lifetime of the source physical register through bookkeeping (for example, reference counting). For any instruction that writes a destination architectural register $r_{dest}$ and produces a new value, the renamer allocates a fresh physical register $p_{new}$ and sets $M_{RAT}(r_{dest}) \\gets p_{new}$, recording the previously mapped physical register $p_{old}$ in the ROB entry so that it may be freed when safe at commit.\n\nAssume the initial committed mappings are $M_{RRAT}(r_s) = p_1$, $M_{RRAT}(r_d) = p_3$, and $M_{RRAT}(r_x) = p_4$, and at rename time the RAT agrees with the RRAT for these registers, so $M_{RAT}(r_s) = p_1$, $M_{RAT}(r_d) = p_3$, and $M_{RAT}(r_x) = p_4$. The following instruction sequence is fetched in program order:\n- $I_1$: $MOV\\ r_d \\leftarrow r_s$ (eligible for move elimination),\n- $I_2$: $ADD\\ r_s \\leftarrow r_s + r_x$ (overwrites $r_s$),\n- $I_3$: $LOAD\\ r_y \\leftarrow [r_{addr}]$ (triggers a fault when executed).\n\nAt rename:\n- For $I_1$, move elimination sets $M_{RAT}(r_d) \\gets M_{RAT}(r_s) = p_1$ and records that the prior mapping of $r_d$ was $p_3$.\n- For $I_2$, a fresh physical register $p_2$ is allocated and $M_{RAT}(r_s) \\gets p_2$, while recording that the prior mapping of $r_s$ was $p_1$.\n- $I_3$ does not change $M_{RAT}$ for any destination before it executes.\n\nSuppose $I_3$ executes speculatively and raises a fault before any of $I_1$, $I_2$, or $I_3$ reaches the head of the ROB to commit. The implementation accumulates the fault but obeys precise exception semantics by committing older instructions up to the fault in program order and then delivering the exception.\n\nWhich option best explains, from first principles of register renaming and in-order retirement, whether move elimination in $I_1$ preserves precise architectural state even though $r_s$ is later overwritten by $I_2$ before commit, and what mechanism ensures this?\n\nA. In-order commit using the Reorder Buffer, together with the Retirement Register Alias Table and physical register lifetime management, preserves precision: $I_1$ will commit first and set $M_{RRAT}(r_d) \\gets p_1$, while $p_1$ is kept live until all older consumers, including the coalesced $r_d$, retire; $I_2$’s remap of $r_s$ to $p_2$ does not affect $I_1$’s architectural effect, and the fault on $I_3$ prevents any younger state from becoming visible.\n\nB. Precision is violated unless $I_1$ performs a real data copy into a new physical register for $r_d$, because overwriting $r_s$ in $I_2$ would otherwise change the value that $r_d$ observes; renaming alone cannot maintain the old value when the source is overwritten.\n\nC. To preserve precision, the processor must stall the renamer and disallow allocating a fresh physical register for $r_s$ in $I_2$ until $I_1$ commits; otherwise, coalescing creates an anti-dependence that cannot be resolved on an exception.\n\nD. On detecting the fault in $I_3$, the processor must roll back all older instructions and re-execute $I_1$ and $I_2$ to reconstruct the precise state, because RRAT checkpoints are insufficient when move elimination is in use.\n\nChoose the single best option.", "solution": "This problem tests the interaction between an advanced renaming optimization (move elimination) and the fundamental requirement for precise exceptions. The key is to trace how the processor's core structures—the RAT, ROB, and RRAT—work together to maintain correctness.\n\n**1. Analysis of Renaming and Dataflow:**\n*   **Initial State:** Architectural register $r_s$ is mapped to physical register $p_1$.\n*   **Rename $I_1: MOV\\ r_d \\leftarrow r_s$**: Move elimination is applied. The speculative rename map (RAT) is updated to point $r_d$ to the same physical register as $r_s$. So, $M_{RAT}(r_d) \\gets p_1$. Now, both $r_s$ and $r_d$ speculatively refer to $p_1$.\n*   **Rename $I_2: ADD\\ r_s \\leftarrow r_s + r_x$**: This instruction reads the \"old\" $r_s$ (which is in $p_1$) and writes a new value to $r_s$. To resolve the Write-After-Read (WAR) hazard on $r_s$ (read by the logical move to $r_d$, now written by $I_2$), the renamer allocates a fresh physical register, $p_2$, for the result. The speculative map is updated: $M_{RAT}(r_s) \\gets p_2$.\n*   **Key Insight:** At this point, the speculative state correctly captures the intended dataflow. The architectural register $r_d$ is set to receive its value from $p_1$ (the original value of $r_s$), while the architectural register $r_s$ is set to receive a new value in $p_2$. The overwrite of $r_s$ is directed to a new physical location, leaving the value in $p_1$ untouched for consumers that were renamed earlier (which now includes $r_d$ due to move elimination).\n\n**2. Exception Handling and In-Order Commit:**\n*   Instruction $I_3$ executes and faults. The principle of precise exceptions requires that all older instructions ($I_1$ and $I_2$) appear to have completed sequentially, while $I_3$ and any younger instructions appear to have never executed.\n*   The Reorder Buffer (ROB) enforces in-order commitment. The processor will retire instructions from the head of the ROB.\n*   **Commit $I_1$**: $I_1$ is at the head of the ROB and is not faulty. It commits by updating the architectural state map (RRAT). The RRAT is updated to $M_{RRAT}(r_d) \\gets p_1$. Architecturally, $r_d$ now correctly holds the original value of $r_s$. The physical register lifetime management system knows $p_1$ holds this architectural state and cannot be freed.\n*   **Commit $I_2$**: $I_2$ is next in the ROB. It commits by updating the RRAT: $M_{RRAT}(r_s) \\gets p_2$. Architecturally, $r_s$ now holds its new, computed value. When $I_2$ commits, the system knows that the *previous* mapping for $r_s$ was $p_1$. Normally, this would be a signal to free $p_1$, but because $I_1$ has already committed and mapped $r_d$ to $p_1$, the lifetime management system correctly keeps $p_1$ alive.\n*   **Handle Fault**: Retirement stops at $I_3$. The architectural state in the RRAT is now exactly as if $I_1$ and $I_2$ had executed sequentially, and the exception handler is invoked.\n\n**Conclusion:**\nThe mechanism works perfectly. The combination of register renaming (to break false dependencies), in-order commit via the ROB (to update architectural state in program order), and robust physical register lifetime management ensures correctness. Option A accurately describes this entire process. Options B, C, and D are based on misunderstandings of how these fundamental mechanisms operate.", "answer": "$$\\boxed{A}$$", "id": "3672382"}]}