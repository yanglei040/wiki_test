{"hands_on_practices": [{"introduction": "A primary advantage of emerging non-volatile memories is their ability to retain data without power, a stark contrast to traditional technologies like Dynamic Random-Access Memory (DRAM). This practice challenges you to quantify the energy cost of volatility by modeling the power required to keep DRAM data alive during a power outage [@problem_id:3638958]. By deriving the battery energy needed for DRAM refresh from fundamental principles, you will gain a concrete appreciation for the \"zero retention energy\" benefit that makes technologies like Phase-Change Memory (PCM) so attractive for building crash-tolerant and energy-efficient systems.", "problem": "A server-class system must be made crash-tolerant by ensuring that the contents of main memory survive a sudden power loss until orderly recovery is possible. Two design options are under discussion: battery-backed Dynamic Random-Access Memory (DRAM) and Phase-Change Memory (PCM). DRAM requires continuous energy to retain data (via refresh), while PCM is non-volatile and requires no energy to passively retain data. Using only fundamental relations between charge, voltage, power, and energy, derive an expression for the battery energy required to retain an arbitrary memory footprint of size $S$ bytes in DRAM for a retention time $t$, and then evaluate it numerically for the specified system.\n\nAssumptions and parameters:\n- The DRAM subsystem operates at supply voltage $V_{\\text{DRAM}}$, and each bit requires periodic refresh with period $T_{\\text{ref}}$. Model the refresh as drawing an effective charge $q_{r}$ from the supply per bit per refresh interval. This lumped parameter $q_{r}$ accounts for sense-amplifier and peripheral switching during a refresh of a stored bit.\n- The DRAM memory controller and retention management logic draw an approximately constant power $P_{\\text{ctl}}$ during the retention interval, independent of $S$.\n- The battery delivers energy to the DRAM load through a regulator of efficiency $\\eta$ (where $0  \\eta \\leq 1$). The battery energy required equals the load energy divided by $\\eta$.\n- Phase-Change Memory (PCM) is assumed to be perfectly non-volatile for the time scales considered, so it requires zero energy for retention; you may use this fact qualitatively in your derivation, but you must compute the battery energy only for the DRAM case.\n- Use the definition that one gigabyte (GB) is $10^{9}$ bytes.\n\nTasks:\n1. Starting from first principles, express the DRAM refresh current in terms of $S$, $q_{r}$, and $T_{\\text{ref}}$. From this, derive the DRAM refresh power and then the total DRAM load power including $P_{\\text{ctl}}$. Finally, derive a closed-form expression for the required battery energy $E_{\\text{battery}}(S,t)$ over time $t$, in terms of $S$, $V_{\\text{DRAM}}$, $q_{r}$, $T_{\\text{ref}}$, $P_{\\text{ctl}}$, and $\\eta$.\n2. Evaluate your expression numerically for\n   - $S = 16 \\times 10^{9}$ bytes,\n   - $t = 2 \\text{ hours}$,\n   - $V_{\\text{DRAM}} = 1.2 \\text{ V}$,\n   - $q_{r} = 4.0 \\times 10^{-13} \\text{ C/bit/refresh}$,\n   - $T_{\\text{ref}} = 64 \\times 10^{-3} \\text{ s}$,\n   - $P_{\\text{ctl}} = 0.20 \\text{ W}$,\n   - $\\eta = 0.90$.\nExpress the final energy in $\\text{kJ}$ and round your answer to four significant figures.\n\nYour final answer must be a single real-valued number corresponding to the required battery energy for the DRAM case under the stated parameters, expressed in $\\text{kJ}$. Do not include any units in the final boxed answer.", "solution": "The problem statement is found to be valid as it is scientifically grounded in fundamental principles of electricity and computer architecture, is well-posed with all necessary parameters defined, and is expressed in objective, formal language. There are no contradictions, ambiguities, or unrealistic assumptions that would invalidate the problem.\n\nThe solution proceeds in two parts as requested: first, the derivation of the symbolic expression for battery energy, and second, its numerical evaluation.\n\nPart 1: Derivation of the Battery Energy Expression $E_{\\text{battery}}(S, t)$.\n\nThe total number of bits, $N_{\\text{bits}}$, in a memory of size $S$ bytes is given by:\n$$N_{\\text{bits}} = 8 S$$\nThis follows from the standard definition of a byte as $8$ bits.\n\nThe problem specifies that each bit draws an effective charge $q_{r}$ during each refresh period $T_{\\text{ref}}$. Therefore, the total charge drawn from the supply to refresh the entire memory array once is:\n$$Q_{\\text{total\\_ref}} = N_{\\text{bits}} \\times q_{r} = 8 S q_{r}$$\n\nElectric current is the rate of flow of charge, $I = \\frac{dQ}{dt}$. For a periodic process, the average current is the total charge transferred per period divided by the period's duration. The average current required for DRAM refresh, $I_{\\text{DRAM\\_ref}}$, is thus:\n$$I_{\\text{DRAM\\_ref}} = \\frac{Q_{\\text{total\\_ref}}}{T_{\\text{ref}}} = \\frac{8 S q_{r}}{T_{\\text{ref}}}$$\n\nElectrical power is the product of voltage and current, $P = V I$. The power consumed by the DRAM cells specifically for refresh operations, $P_{\\text{DRAM\\_ref}}$, is the product of the refresh current and the DRAM supply voltage, $V_{\\text{DRAM}}$:\n$$P_{\\text{DRAM\\_ref}} = V_{\\text{DRAM}} I_{\\text{DRAM\\_ref}} = \\frac{8 S q_{r} V_{\\text{DRAM}}}{T_{\\text{ref}}}$$\n\nThe total power consumed by the load that the battery must support, $P_{\\text{load}}$, is the sum of the DRAM refresh power and the constant power drawn by the memory controller and its associated retention logic, $P_{\\text{ctl}}$.\n$$P_{\\text{load}} = P_{\\text{DRAM\\_ref}} + P_{\\text{ctl}} = \\frac{8 S q_{r} V_{\\text{DRAM}}}{T_{\\text{ref}}} + P_{\\text{ctl}}$$\n\nEnergy is the integral of power over time. As the total load power $P_{\\text{load}}$ is constant during the retention interval $t$, the total energy consumed by the load, $E_{\\text{load}}$, is the product of this power and the time duration:\n$$E_{\\text{load}} = P_{\\text{load}} \\times t = \\left( \\frac{8 S q_{r} V_{\\text{DRAM}}}{T_{\\text{ref}}} + P_{\\text{ctl}} \\right) t$$\n\nThis load is supplied by a battery through a regulator with an efficiency of $\\eta$. The efficiency is the ratio of output power (or energy) to input power (or energy), $\\eta = \\frac{E_{\\text{load}}}{E_{\\text{battery}}}$. Therefore, the energy that must be supplied by the battery, $E_{\\text{battery}}$, is the load energy divided by the efficiency:\n$$E_{\\text{battery}} = \\frac{E_{\\text{load}}}{\\eta}$$\nSubstituting the expression for $E_{\\text{load}}$ gives the final closed-form expression for the required battery energy as a function of memory size $S$ and retention time $t$:\n$$E_{\\text{battery}}(S, t) = \\frac{t}{\\eta} \\left( \\frac{8 S q_{r} V_{\\text{DRAM}}}{T_{\\text{ref}}} + P_{\\text{ctl}} \\right)$$\n\nPart 2: Numerical Evaluation.\n\nWe now substitute the provided numerical values into the derived expression. We must ensure all units are consistent (SI units).\nThe given parameters are:\n$S = 16 \\times 10^{9}$ bytes\n$t = 2 \\text{ hours} = 2 \\times 3600 \\text{ s} = 7200 \\text{ s}$\n$V_{\\text{DRAM}} = 1.2 \\text{ V}$\n$q_{r} = 4.0 \\times 10^{-13} \\text{ C}$ per bit per refresh\n$T_{\\text{ref}} = 64 \\times 10^{-3} \\text{ s}$\n$P_{\\text{ctl}} = 0.20 \\text{ W}$\n$\\eta = 0.90$\n\nFirst, we calculate the DRAM refresh power, $P_{\\text{DRAM\\_ref}}$:\n$$P_{\\text{DRAM\\_ref}} = \\frac{8 \\times (16 \\times 10^{9} \\text{ bytes}) \\times (4.0 \\times 10^{-13} \\text{ C/bit}) \\times (1.2 \\text{ V})}{64 \\times 10^{-3} \\text{ s}}$$\nThe factor of $8$ correctly converts bytes to bits.\n$$P_{\\text{DRAM\\_ref}} = \\frac{(128 \\times 10^{9}) \\times (4.0 \\times 10^{-13}) \\times 1.2}{64 \\times 10^{-3}} \\text{ W}$$\n$$P_{\\text{DRAM\\_ref}} = \\frac{51.2 \\times 10^{-2} \\times 1.2}{64 \\times 10^{-3}} \\text{ W} = \\frac{61.44 \\times 10^{-2}}{64 \\times 10^{-3}} \\text{ W}$$\n$$P_{\\text{DRAM\\_ref}} = 0.96 \\text{ W}$$\n\nNext, we calculate the total load power, $P_{\\text{load}}$:\n$$P_{\\text{load}} = P_{\\text{DRAM\\_ref}} + P_{\\text{ctl}} = 0.96 \\text{ W} + 0.20 \\text{ W} = 1.16 \\text{ W}$$\n\nNow, we can calculate the total required battery energy, $E_{\\text{battery}}$, in Joules:\n$$E_{\\text{battery}} = \\frac{P_{\\text{load}} \\times t}{\\eta} = \\frac{1.16 \\text{ W} \\times 7200 \\text{ s}}{0.90} \\text{ J}$$\n$$E_{\\text{battery}} = \\frac{8352}{0.90} \\text{ J} = 9280 \\text{ J}$$\n\nThe problem requires the final answer in kilojoules (kJ).\n$$E_{\\text{battery}} = 9280 \\text{ J} \\times \\frac{1 \\text{ kJ}}{1000 \\text{ J}} = 9.280 \\text{ kJ}$$\nThis value is already expressed with four significant figures, as requested.", "answer": "$$\\boxed{9.280}$$", "id": "3638958"}, {"introduction": "The physical properties of emerging memories often result in asymmetric performance, where writing data is significantly more expensive in terms of energy and latency than reading it. This exercise explores how this fundamental trade-off should influence software design, specifically the choice of algorithms [@problem_id:3639004]. By comparing the energy consumption of two sorting algorithms based on their total number of write operations, you will see firsthand that algorithmic efficiency is not just about computational steps, but is deeply intertwined with the characteristics of the underlying memory hardware.", "problem": "A system designer is evaluating two in-memory sorting algorithms on Phase-Change Memory (PCM). Phase-Change Memory (PCM) is characterized by a significantly higher energy cost for write operations compared to read operations. Let $n$ denote the number of $64$-bit elements to be sorted. For algorithm $\\mathrm{A}$, the total number of distinct word writes during the sort is modeled as $W_{\\mathrm{A}}(n) = \\frac{n}{2}\\ln(n)$, and for algorithm $\\mathrm{B}$, it is $W_{\\mathrm{B}}(n) = 2n$. Assume that the energy per write of a $64$-bit word in PCM is $E_{\\mathrm{write}} = 3.0 \\times 10^{-9} \\text{ J}$ and the energy per read of a $64$-bit word is $E_{\\mathrm{read}} = 1.5 \\times 10^{-10} \\text{ J}$, with $E_{\\mathrm{write}} \\gg E_{\\mathrm{read}}$. Both algorithms perform a number of reads of the same order as their writes (within a constant factor), but you may neglect the read energy in the first-order energy comparison due to the given inequality.\n\nStarting from the principle that the total energy of a computation is the sum over the energies of its primitive operations, derive a closed-form analytic expression for the energy ratio $\\rho(n) = \\frac{E_{\\mathrm{A}}(n)}{E_{\\mathrm{B}}(n)}$ between algorithms $\\mathrm{A}$ and $\\mathrm{B}$ under the stated approximation. Express your final answer as a simplified expression in terms of $n$. No rounding is required, and the answer should be unitless.", "solution": "The problem statement is first validated for scientific correctness, consistency, and completeness.\n\n**Step 1: Extract Givens**\n- Number of elements to be sorted: $n$ ($64$-bit elements).\n- Write count for algorithm A: $W_{\\mathrm{A}}(n) = \\frac{n}{2}\\ln(n)$.\n- Write count for algorithm B: $W_{\\mathrm{B}}(n) = 2n$.\n- Energy per $64$-bit word write: $E_{\\mathrm{write}} = 3.0 \\times 10^{-9} \\text{ J}$.\n- Energy per $64$-bit word read: $E_{\\mathrm{read}} = 1.5 \\times 10^{-10} \\text{ J}$.\n- Condition: $E_{\\mathrm{write}} \\gg E_{\\mathrm{read}}$.\n- Approximation: Neglect the read energy in the first-order energy comparison.\n- Principle: The total energy of a computation is the sum over the energies of its primitive operations.\n- Goal: Derive a closed-form analytic expression for the energy ratio $\\rho(n) = \\frac{E_{\\mathrm{A}}(n)}{E_{\\mathrm{B}}(n)}$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is evaluated against the validation criteria.\n- **Scientifically Grounded:** The problem is grounded in computer engineering, specifically the analysis of algorithm performance on emerging non-volatile memory technologies like Phase-Change Memory (PCM). The central premise that PCM exhibits high write energy compared to read energy ($E_{\\mathrm{write}} \\gg E_{\\mathrm{read}}$) is a well-established and fundamental characteristic of this technology. The models for write counts, $W_{\\mathrm{A}}(n) \\propto n\\ln(n)$ and $W_{\\mathrm{B}}(n) \\propto n$, correspond to common algorithmic complexity classes. The problem represents a valid, albeit simplified, engineering analysis.\n- **Well-Posed:** The problem is well-posed. It provides all necessary information and a clear objective: to find the energy ratio $\\rho(n)$ under a specified approximation. The inputs are defined, and the path to a unique solution is clear.\n- **Objective:** The problem statement is objective and quantitative, free of subjective or ambiguous language.\n- **Incomplete or Contradictory Setup:** The problem is self-contained. The instruction to neglect read energy is a valid simplifying assumption that makes the problem solvable with the given information. The provided numerical values for $E_{\\mathrm{write}}$ and $E_{\\mathrm{read}}$ are consistent with the qualitative condition $E_{\\mathrm{write}} \\gg E_{\\mathrm{read}}$, since $\\frac{3.0 \\times 10^{-9}}{1.5 \\times 10^{-10}} = 20$. There are no contradictions.\n- **Unrealistic or Infeasible:** The setup is a realistic first-order approximation used in system design and performance modeling. The values and models are not physically impossible.\n- **Ill-Posed or Poorly Structured:** The problem is clearly structured and admits a unique, meaningful solution.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. The solution process will now proceed.\n\nThe total energy consumed by an algorithm is the sum of the energies from all its primitive operations. In this context, the operations are memory reads and writes. The total energy for an algorithm, $E(n)$, can be expressed as:\n$$E(n) = N_{\\mathrm{reads}}(n) \\cdot E_{\\mathrm{read}} + N_{\\mathrm{writes}}(n) \\cdot E_{\\mathrm{write}}$$\nwhere $N_{\\mathrm{reads}}(n)$ and $N_{\\mathrm{writes}}(n)$ are the total number of read and write operations, respectively, for a problem of size $n$.\n\nFor algorithm A, the energy $E_{\\mathrm{A}}(n)$ is:\n$$E_{\\mathrm{A}}(n) = R_{\\mathrm{A}}(n) \\cdot E_{\\mathrm{read}} + W_{\\mathrm{A}}(n) \\cdot E_{\\mathrm{write}}$$\nFor algorithm B, the energy $E_{\\mathrm{B}}(n)$ is:\n$$E_{\\mathrm{B}}(n) = R_{\\mathrm{B}}(n) \\cdot E_{\\mathrm{read}} + W_{\\mathrm{B}}(n) \\cdot E_{\\mathrm{write}}$$\nHere, $R_{\\mathrm{A}}(n)$ and $R_{\\mathrm{B}}(n)$ represent the number of reads for each algorithm.\n\nThe problem states that we can neglect the read energy in a first-order comparison. This is justified by the condition $E_{\\mathrm{write}} \\gg E_{\\mathrm{read}}$. This approximation simplifies the energy equations to:\n$$E_{\\mathrm{A}}(n) \\approx W_{\\mathrm{A}}(n) \\cdot E_{\\mathrm{write}}$$\n$$E_{\\mathrm{B}}(n) \\approx W_{\\mathrm{B}}(n) \\cdot E_{\\mathrm{write}}$$\n\nWe are given the models for the number of writes for each algorithm:\n$$W_{\\mathrm{A}}(n) = \\frac{n}{2}\\ln(n)$$\n$$W_{\\mathrm{B}}(n) = 2n$$\n\nSubstituting these expressions into the approximate energy equations, we get:\n$$E_{\\mathrm{A}}(n) \\approx \\left(\\frac{n}{2}\\ln(n)\\right) E_{\\mathrm{write}}$$\n$$E_{\\mathrm{B}}(n) \\approx (2n) E_{\\mathrm{write}}$$\n\nThe problem asks for the energy ratio $\\rho(n) = \\frac{E_{\\mathrm{A}}(n)}{E_{\\mathrm{B}}(n)}$. Using the approximate energy expressions, we can write the ratio as:\n$$\\rho(n) \\approx \\frac{\\left(\\frac{n}{2}\\ln(n)\\right) E_{\\mathrm{write}}}{(2n) E_{\\mathrm{write}}}$$\n\nWe can simplify this expression. The term $E_{\\mathrm{write}}$ is a common factor in the numerator and the denominator, so it cancels out. This is expected, as the ratio should depend on the algorithmic properties, not the specific energy value of the underlying hardware (as long as the ratio $E_{\\mathrm{write}}/E_{\\mathrm{read}}$ is large).\n$$\\rho(n) = \\frac{\\frac{n}{2}\\ln(n)}{2n}$$\n\nThe variable $n$ also appears in both the numerator and the denominator and can be canceled, provided $n \\neq 0$, which is a safe assumption for a sorting problem.\n$$\\rho(n) = \\frac{\\frac{1}{2}\\ln(n)}{2}$$\n\nFinally, simplifying the fraction gives the closed-form analytic expression for the energy ratio:\n$$\\rho(n) = \\frac{1}{4}\\ln(n)$$\nThis expression represents the ratio of energy consumption of algorithm A to algorithm B as a function of the number of elements $n$, under the specified model and approximation.", "answer": "$$\\boxed{\\frac{1}{4}\\ln(n)}$$", "id": "3639004"}, {"introduction": "While non-volatile memories offer compelling benefits, they also introduce significant design challenges, chief among them being finite write endurance. This limitation means a memory cell can only be reliably programmed a certain number of times before it fails. This practice guides you through the analysis of a crucial system-level technique, wear-leveling, designed to mitigate this problem and enhance device lifetime [@problem_id:3638977]. By calculating the expected lifetime of a PCM line within a wear-leveling ring, you will learn to model and reason about the reliability of systems built from components with inherent physical constraints.", "problem": "A Level-3 (L3) cache is implemented using Phase-Change Memory (PCM). Because PCM cells have finite write endurance, the system employs a hardware wear-leveling ring to host a single logical cache line across multiple physical PCM lines. The ring uses $M$ physical lines and rotates the active host line every rotation period $p$ seconds. When the ring rotates, the current contents of the logical cache line of size $B$ bytes are migrated to the new active physical line using a write granularity of $g$ bytes per programming operation. In addition, each rotation updates mapping metadata on the destination line, incurring $m$ programming operations. While active, the logical cache line receives a stationary write stream at rate $\\lambda$ programming operations per second. Reads do not contribute to wear. Each physical PCM line fails once it accumulates $N_{\\text{end}}$ programming operations.\n\nAssume the ring rotation is perfectly periodic, the workload and rotation are independent and stationary, and that each physical line is active for exactly $p$ seconds once per cycle. Treat each programming operation (including migration and metadata updates) as an equal unit of wear. Under these conditions, determine the expected lifetime of a single physical line, expressed in years.\n\nUse the following parameters:\n- Endurance per physical line $N_{\\text{end}} = 3.0 \\times 10^8$ programming operations.\n- Ring size $M = 64$.\n- Rotation period $p = 1.0$ seconds.\n- Logical line size $B = 64$ bytes.\n- Write granularity $g = 8$ bytes per programming operation.\n- Metadata update cost per rotation $m = 2$ programming operations.\n- Active-line write rate $\\lambda = 50$ programming operations per second.\n\nRound your final answer to four significant figures. Use $365$ days per year, and express the lifetime in years.", "solution": "The problem is scientifically grounded in computer engineering principles for memory reliability and wear management. It is well-posed, providing a clear objective and all necessary parameters. The model of a wear-leveling ring is a standard, albeit simplified, representation of real-world systems. All assumptions are stated, and there are no contradictions. The solution proceeds by first calculating the average wear rate on a single physical line and then using that to determine its total lifetime.\n\n**Step 1: Calculate Total Wear Per Cycle**\nA single physical line endures wear only during its active period, which occurs once per full ring rotation. The total wear accumulated during this active phase, $W_{\\text{line}}$, is the sum of three components:\n1.  **Wear from data migration ($W_{\\text{mig}}$):** When the line becomes active, the logical line's content of size $B$ is written to it. With a write granularity of $g$, the number of programming operations is:\n    $$W_{\\text{mig}} = \\frac{B}{g} = \\frac{64 \\text{ bytes}}{8 \\text{ bytes/op}} = 8 \\text{ operations}$$\n2.  **Wear from metadata update ($W_{\\text{meta}}$):** Each rotation incurs a fixed metadata update cost of $m$ operations.\n    $$W_{\\text{meta}} = m = 2 \\text{ operations}$$\n3.  **Wear from active workload ($W_{\\text{active}}$):** While active for period $p$, the line receives writes at rate $\\lambda$.\n    $$W_{\\text{active}} = \\lambda \\times p = (50 \\text{ ops/s}) \\times (1.0 \\text{ s}) = 50 \\text{ operations}$$\n\nThe total number of programming operations (wear) a single line endures per activation is:\n$$W_{\\text{line}} = W_{\\text{mig}} + W_{\\text{meta}} + W_{\\text{active}} = 8 + 2 + 50 = 60 \\text{ operations}$$\n\n**Step 2: Calculate Average Wear Rate**\nThe wear calculated above occurs once every full ring cycle. The duration of a full cycle, $T_{\\text{cycle}}$, is the time it takes for all $M$ lines to be active once.\n$$T_{\\text{cycle}} = M \\times p = 64 \\times 1.0 \\text{ s} = 64 \\text{ s}$$\n\nThe average wear rate, $R_{\\text{wear}}$, for a single physical line is the total wear it experiences in one cycle divided by the cycle duration.\n$$R_{\\text{wear}} = \\frac{W_{\\text{line}}}{T_{\\text{cycle}}} = \\frac{60 \\text{ operations}}{64 \\text{ s}} = 0.9375 \\text{ operations/s}$$\n\n**Step 3: Calculate Expected Lifetime**\nThe expected lifetime of the line, $L$, is its total endurance, $N_{\\text{end}}$, divided by the average wear rate, $R_{\\text{wear}}$.\n$$L_{\\text{sec}} = \\frac{N_{\\text{end}}}{R_{\\text{wear}}} = \\frac{3.0 \\times 10^8 \\text{ operations}}{0.9375 \\text{ ops/s}} = 3.2 \\times 10^8 \\text{ seconds}$$\n\n**Step 4: Convert to Years**\nTo convert the lifetime from seconds to years, we use the given conversion factor of 365 days per year.\nNumber of seconds in one year = $365 \\text{ days/year} \\times 24 \\text{ hours/day} \\times 3600 \\text{ s/hour} = 31,536,000 \\text{ s/year}$.\n$$L_{\\text{years}} = \\frac{L_{\\text{sec}}}{31,536,000 \\text{ s/year}} = \\frac{3.2 \\times 10^8 \\text{ s}}{31,536,000 \\text{ s/year}} \\approx 10.1471334 \\text{ years}$$\n\n**Step 5: Final Rounding**\nThe problem requires the answer to be rounded to four significant figures.\n$$L_{\\text{years}} \\approx 10.15 \\text{ years}$$\nThe expected lifetime of a single physical line is 10.15 years.", "answer": "$$\\boxed{10.15}$$", "id": "3638977"}]}