{"hands_on_practices": [{"introduction": "At the heart of memory protection lies the hardware, specifically the Memory Management Unit (MMU), which acts as the ultimate gatekeeper for every memory access. This first exercise strips away layers of abstraction to focus on the fundamental logic of the MMU. By simulating how permissions for a single memory page change over time and tracking the resulting faults, you will build a solid, foundational understanding of how the processor enforces the core read ($r$), write ($w$), and execute ($x$) access rights [@problem_id:3658221].", "problem": "A single virtual memory page in a computer system is protected by three permission bits maintained in the page table entry: the read bit $r$, the write bit $w$, and the execute bit $x$. The Memory Management Unit (MMU) enforces these permissions: a memory read is permitted if and only if $r$ is set, a memory write is permitted if and only if $w$ is set, and an instruction fetch (execution) is permitted if and only if $x$ is set. Any attempted operation not permitted by the current permission bits causes a protection exception (fault). Assume that permission changes are atomic and take effect immediately at the indicated times, with no caching delays.\n\nAt times $t_0<t_1<t_2$, the operating system updates the permissions for the page as follows:\n- At time $t_0$: $(r,w,x)$.\n- At time $t_1$: $(r,\\neg w,\\neg x)$.\n- At time $t_2$: $(\\neg r,\\neg w,\\neg x)$.\n\nA process attempts the following batches of operations exactly at each $t_i$:\n- At $t_0$: $A_0=5$ reads, $B_0=9$ writes, $C_0=7$ instruction fetches.\n- At $t_1$: $A_1=11$ reads, $B_1=4$ writes, $C_1=6$ instruction fetches.\n- At $t_2$: $A_2=3$ reads, $B_2=2$ writes, $C_2=1$ instruction fetches.\n\nStarting from the core definitions of permission enforcement described above, construct the permission timeline and, for each $t_i$, map which operation types would raise faults. Then, using that mapping, compute the total number of faults across all three times $t_0$, $t_1$, and $t_2$. Provide the final answer as a single integer. No rounding is required.", "solution": "To find the total number of protection faults, we must analyze the state of the page permissions at each time point and count the number of attempted operations that are not permitted. A fault occurs if an operation is attempted on a page for which the corresponding permission bit is not set.\n\n**Analysis at time $t_0$**:\nThe permissions are set to $(r, w, x)$, meaning read, write, and execute are all permitted.\n- Permissions: $(r=1, w=1, x=1)$.\n- Attempts: 5 reads, 9 writes, 7 executes.\n- Since all permissions are granted, no operation will cause a fault.\n- Faults at $t_0 = 0$ (reads) + $0$ (writes) + $0$ (executes) = $0$.\n\n**Analysis at time $t_1$**:\nThe permissions are updated to $(r, \\neg w, \\neg x)$, meaning only read is permitted.\n- Permissions: $(r=1, w=0, x=0)$.\n- Attempts: 11 reads, 4 writes, 6 executes.\n- The 11 read attempts are permitted.\n- The 4 write attempts are not permitted and will cause 4 faults.\n- The 6 execute attempts are not permitted and will cause 6 faults.\n- Faults at $t_1 = 0$ (reads) + $4$ (writes) + $6$ (executes) = $10$.\n\n**Analysis at time $t_2$**:\nThe permissions are updated to $(\\neg r, \\neg w, \\neg x)$, meaning no operations are permitted.\n- Permissions: $(r=0, w=0, x=0)$.\n- Attempts: 3 reads, 2 writes, 1 execute.\n- All attempted operations are not permitted.\n- The 3 read attempts will cause 3 faults.\n- The 2 write attempts will cause 2 faults.\n- The 1 execute attempt will cause 1 fault.\n- Faults at $t_2 = 3$ (reads) + $2$ (writes) + $1$ (execute) = $6$.\n\n**Total Faults Calculation**:\nThe total number of faults is the sum of the faults from each time point.\nTotal Faults = (Faults at $t_0$) + (Faults at $t_1$) + (Faults at $t_2$)\nTotal Faults = $0 + 10 + 6 = 16$.", "answer": "$$\n\\boxed{16}\n$$", "id": "3658221"}, {"introduction": "While the MMU enforces rules at a low level, the operating system is responsible for managing these permissions to implement broader security policies. This practice elevates the challenge from a single page to a system-wide perspective, where you must manage permissions for multiple processes and pages. You will work with critical security invariants, such as the Write XOR Execute (W^X) policy, and determine the precise sequence of operations needed to grant temporary access without ever violating system integrity [@problem_id:3658191].", "problem": "Consider a system that enforces process-page memory protection via a permission matrix $M \\in \\mathbb{Z}^{n \\times m}$, where entry $M_{ij}$ encodes the access rights of process $i$ to page $j$. Each entry is a bitmask over the set $\\{r,w,x\\}$ with $r \\mapsto 1$, $w \\mapsto 2$, and $x \\mapsto 4$. Rights are combined by bitwise addition, so, for example, $r \\wedge w$ is encoded as $3$ and $r \\wedge x$ as $5$. The matrix is currently\n$$\nM=\n\\begin{pmatrix}\n5 & 1 & 0 \\\\\n1 & 3 & 4 \\\\\n0 & 0 & 0 \\\\\n1 & 1 & 0\n\\end{pmatrix},\n$$\nwith rows indexed by processes $i \\in \\{1,2,3,4\\}$ and columns by pages $j \\in \\{1,2,3\\}$. Two system invariants must hold at all times:\n\n1. Single-writer per page: for every page $j$, \n$$\n\\sum_{i=1}^{n} \\mathbf{1}_{\\{w \\in M_{ij}\\}} \\leq 1,\n$$\nwhere $\\mathbf{1}_{\\{w \\in M_{ij}\\}}$ equals $1$ if $w$ is present in $M_{ij}$ and $0$ otherwise.\n\n2. Write XOR Execute (W^X) policy: if there exists any process $i$ such that $x \\in M_{ij}$ for a page $j$, then for all processes $k$,\n$$\nw \\notin M_{kj}.\n$$\n\nA workflow requires that process $p=3$ obtain $(r,w)$ access on page $q=2$ only for the duration of a transaction. Access rights may be changed by toggling individual permission bits in entries $M_{ij}$; a single bit toggle changes one of $\\{r,w,x\\}$ in a single $M_{ij}$ from present to absent or vice versa. The original matrix must be restored after the transaction completes. Determine the minimal total number of bit toggles required to (i) reach a state in which process $3$ has $(r,w)$ on page $2$ while both invariants hold, and then (ii) restore the matrix to its original state, ensuring both invariants hold at all times during the sequence of changes. Provide the final answer as an integer count of bit toggles. No rounding is required.", "solution": "The goal is to find the minimum number of bit toggles to temporarily grant process 3 $(r,w)$ access to page 2 and then restore the original state, while upholding two system-wide invariants at all times.\n\nFirst, let's decode the initial permission matrix $M$ from its integer representation to sets of permissions $\\{r,w,x\\}$.\n- $r=1, w=2, x=4$.\n- Initial matrix:\n$$\nM = \\begin{pmatrix} 5 & 1 & 0 \\\\ 1 & 3 & 4 \\\\ 0 & 0 & 0 \\\\ 1 & 1 & 0 \\end{pmatrix} \\Rightarrow M_{permissions} = \\begin{pmatrix} \\{r,x\\} & \\{r\\} & \\{\\} \\\\ \\{r\\} & \\{r,w\\} & \\{x\\} \\\\ \\{\\} & \\{\\} & \\{\\} \\\\ \\{r\\} & \\{r\\} & \\{\\} \\end{pmatrix}\n$$\nThe initial state is valid as it satisfies both invariants: Page 2 has only one writer (process 2), and pages with execute permission (pages 1 and 3) have no writers.\n\n**Part 1: Granting Permissions to Process 3**\n\nThe objective is to change $M_{32}$ from $0$ ($\\{\\}$) to $3$ ($\\{r,w\\}$). This requires at least two toggles: turning 'r' ON and 'w' ON for $M_{32}$.\n\nHowever, we must respect the invariants at every step.\n1.  **Invariant 1 (Single-writer)**: Process 2 already has write permission on page 2 ($w \\in M_{22}$). Granting write permission to process 3 would create two writers for page 2, violating the invariant. Therefore, before granting write access to process 3, we must first revoke it from process 2. This requires one toggle: turn 'w' OFF for $M_{22}$ (changing it from $3$ to $1$).\n2.  **Granting Access**: After revoking write access from process 2, it is safe to grant access to process 3. This requires two toggles: turn 'r' ON and 'w' ON for $M_{32}$ (changing it from $0$ to $3$).\n\nA minimal, valid sequence is:\n1.  Toggle 'w' OFF for $M_{22}$ ($3 \\to 1$).\n2.  Toggle 'r' ON for $M_{32}$ ($0 \\to 1$).\n3.  Toggle 'w' ON for $M_{32}$ ($1 \\to 3$).\n\nThis sequence requires a minimum of **3 bit toggles**.\n\n**Part 2: Restoring the Original State**\n\nNow, we must reverse the changes to restore the original matrix. The current state is $M_{22}=1$ and $M_{32}=3$. The target is $M_{22}=3$ and $M_{32}=0$.\n\n1.  **Invariant 1 (Single-writer)**: Process 3 has write permission on page 2. To restore write permission to process 2, we must first revoke it from process 3 to avoid having two writers simultaneously. This requires one toggle: turn 'w' OFF for $M_{32}$ (changing it from $3$ to $1$).\n2.  **Restoring Access**: After revoking write access from process 3, we can restore access for process 2 and complete the reset for process 3.\n    - Toggle 'w' ON for $M_{22}$ (changing it from $1$ to $3$). This is one toggle.\n    - Toggle 'r' OFF for $M_{32}$ (changing it from $1$ to $0$). This is one toggle.\n\nA minimal, valid sequence is:\n1.  Toggle 'w' OFF for $M_{32}$ ($3 \\to 1$).\n2.  Toggle 'w' ON for $M_{22}$ ($1 \\to 3$).\n3.  Toggle 'r' OFF for $M_{32}$ ($1 \\to 0$).\n\nThis restoration requires a minimum of **3 bit toggles**.\n\n**Total Toggles**\n\nThe total number of bit toggles for the entire operation is the sum of the toggles from both parts.\nTotal Toggles = 3 (granting) + 3 (restoring) = 6.", "answer": "$$\\boxed{6}$$", "id": "3658191"}, {"introduction": "Abstract security policies must ultimately contend with the concrete physical structure of memory, which is organized into fixed-size pages. This final exercise bridges the gap between logical rules and their physical implementation, focusing on the crucial concept of page alignment. You will confront a common scenario where code and data segments are not neatly separated on page boundaries and must be re-mapped to enforce strict protection, a process fundamental to modern security features like Data Execution Prevention (DEP) [@problem_id:3658208].", "problem": "A virtual memory subsystem enforces strict separation of instruction and data: no page may simultaneously permit both writing and instruction fetch, and no page may contain both code bytes and data bytes. Each page has size $P = 4$ KiB (that is, $P = 4096$ bytes), and permissions are assigned per page. A process currently has a single contiguous region mapped with permissive rights (read, write, and execute) spanning the half-open interval $\\left[0x00400000, 0x00409000\\right)$ in virtual addresses (measured in bytes). Within this region, the actual code bytes occupy the half-open interval $\\left[0x00400080, 0x00401F20\\right)$ and the actual data bytes occupy the half-open interval $\\left[0x00401F20, 0x00408AB5\\right)$. All addresses are virtual and assumed to be byte-addressable. The subranges outside these code and data intervals but inside the original mapping are unused padding.\n\nTo bring the mapping into compliance with the strict separation policy, the operating system must:\n- Re-map the code onto a set of whole pages that cover all code bytes and no data bytes, granting those pages read and execute permission only.\n- Re-map the data onto a disjoint set of whole pages that cover all data bytes and no code bytes, granting those pages read and write permission with no execute permission.\n- Use the minimal coverage that satisfies the above (that is, no extra pages beyond what is required to cover the original bytes), and preserve the half-open interval convention $\\left[\\text{start}, \\text{end}\\right)$.\n\nCompute the two new half-open virtual address ranges for the code and the data after page-granularity alignment and separation. Express your final answer as four hexadecimal virtual addresses in ascending order $\\left(C_{\\text{start}}, C_{\\text{end}}, D_{\\text{start}}, D_{\\text{end}}\\right)$, where $\\left[C_{\\text{start}}, C_{\\text{end}}\\right)$ is the executable code range and $\\left[D_{\\text{start}}, D_{\\text{end}}\\right)$ is the writable non-executable data range. No rounding is needed beyond page alignment. Provide the addresses in hexadecimal with the $0x$ prefix. All addresses are measured in bytes.", "solution": "The problem requires re-mapping code and data into page-aligned virtual address ranges that satisfy two strict separation policies: 1) pages cannot be simultaneously writable and executable, and 2) a single page cannot contain both code and data bytes.\n\nThe page size is $P = 4096$ bytes, which is $0x1000$ in hexadecimal. All page-aligned memory mappings must therefore start and end at addresses that are multiples of $0x1000$.\n\n**1. Analyzing the Initial Layout and Conflict**\n- Original code bytes: $[0x00400080, 0x00401F20)$.\n- Original data bytes: $[0x00401F20, 0x00408AB5)$.\n\nThe boundary between code and data is at address $0x00401F20$. Let's identify the memory page containing this boundary. The page starts at an address found by zeroing the last 12 bits (3 hex digits): $\\text{page_start}(0x00401F20) = 0x00401000$. This page covers the range $[0x00401000, 0x00402000)$.\n\nThis specific page contains:\n- Code bytes in the interval $[0x00401000, 0x00401F20)$.\n- Data bytes in the interval $[0x00401F20, 0x00402000)$.\n\nSince this single page contains both code and data, the initial layout violates the separation policy. It is impossible to assign a single permission set (either read/execute for code or read/write for data) to this page without breaking the rules. To resolve this, the operating system must \"re-map\" the memory by effectively moving the data segment to start on a new page boundary, creating a clean separation.\n\n**2. Calculating the New Code Range**\nThe new code range must be a set of whole pages that covers all original code bytes.\n- The code starts at address $0x00400080$. The smallest page-aligned range must start at or before this address. The page-aligned start address is $C_{\\text{start}} = \\text{page_align_down}(0x00400080) = 0x00400000$.\n- The original code ends at address $0x00401F20$. The range must extend to the end of the page containing the last byte of code ($0x00401F1F$). This page is $[0x00401000, 0x00402000)$. Thus, the new range must end at the next page boundary. The page-aligned end address is $C_{\\text{end}} = \\text{page_align_up}(0x00401F20) = 0x00402000$.\n- The new code range is $[C_{\\text{start}}, C_{\\text{end}}) = [0x00400000, 0x00402000)$. This region will be mapped with read and execute permissions.\n\n**3. Calculating the New Data Range**\nThe data segment is relocated to start immediately after the new code range to maintain address space contiguity and satisfy the \"minimal coverage\" constraint.\n- The new data start address is $D_{\\text{start}} = C_{\\text{end}} = 0x00402000$. This is already page-aligned.\n- Next, we calculate the size of the original data to determine its new end point.\n  Data size = $0x00408AB5 - 0x00401F20 = 0x6B95$ bytes.\n- The relocated data will occupy the logical interval $[0x00402000, 0x00402000 + 0x6B95) = [0x00402000, 0x00408B95)$.\n- The new data mapping must be a set of whole pages covering this interval. The start is already aligned. The end must be aligned up to the next page boundary.\n- The page-aligned end address is $D_{\\text{end}} = \\text{page_align_up}(0x00408B95) = 0x00409000$.\n- The new data range is $[D_{\\text{start}}, D_{\\text{end}}) = [0x00402000, 0x00409000)$. This region will be mapped with read and write permissions.\n\n**4. Final Answer**\nThe four hexadecimal virtual addresses representing the new code and data ranges are:\n- $C_{\\text{start}} = 0x00400000$\n- $C_{\\text{end}} = 0x00402000$\n- $D_{\\text{start}} = 0x00402000$\n- $D_{\\text{end}} = 0x00409000$\nIn ascending order, the tuple is $(0x00400000, 0x00402000, 0x00402000, 0x00409000)$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0x00400000 & 0x00402000 & 0x00402000 & 0x00409000\n\\end{pmatrix}\n}\n$$", "id": "3658208"}]}