{"hands_on_practices": [{"introduction": "To truly grasp the differences between snooping protocols, there's no substitute for tracing their behavior step-by-step. This first exercise provides a direct, side-by-side comparison of a write-invalidate and a write-update protocol under an identical workload. By meticulously tracking the state of a single cache block across multiple cores, you will build a foundational understanding of how each protocol manages shared data, observing firsthand the distinct patterns of bus traffic and state transitions that each one generates [@problem_id:3678515].", "problem": "Consider a snooping-based multiprocessor with three cores $C_0$, $C_1$, and $C_2$, and a single cache block $X$. All caches are initially in the invalid state $I$ for block $X$. Assume a write-back cache hierarchy and a single shared bus. The system maintains cache coherence via snooping, under either a write-invalidate protocol or a write-update protocol. For each protocol, use the following foundational behavioral definitions and well-tested rules for cache coherence, bus transactions, and state changes:\n\n- Cache state meanings (write-invalidate): modified ($M$), exclusive ($E$), shared ($S$), invalid ($I$), as in the Modified–Exclusive–Shared–Invalid (MESI) protocol. Loads that miss issue $\\mathrm{BusRd}$; stores that require exclusivity issue $\\mathrm{BusRdX}$ or $\\mathrm{BusUpgr}$; an $\\mathrm{E}\\to\\mathrm{M}$ transition on a local store is silent (no bus). A $\\mathrm{BusRd}$ seen by an $\\mathrm{E}$ holder causes $\\mathrm{E}\\to\\mathrm{S}$; a $\\mathrm{BusRd}$ seen by an $\\mathrm{M}$ holder causes data supply and $\\mathrm{M}\\to\\mathrm{S}$. A write from $\\mathrm{S}$ causes invalidations of other sharers (their $\\mathrm{S}\\to\\mathrm{I}$) and the writer transitions $\\mathrm{S}\\to\\mathrm{M}$. A write from $\\mathrm{I}$ issues $\\mathrm{BusRdX}$, obtains $\\mathrm{M}$, and invalidates other copies ($\\mathrm{S}\\to\\mathrm{I}$, if any). There are no bus update events in write-invalidate.\n\n- Cache state meanings (write-update): use Dragon-like states exclusive-clean ($E$), shared-clean ($Sc$), shared-modified ($Sm$), and modified ($M$). Loads that miss issue $\\mathrm{BusRd}$; if no other caches hold $X$, the requester obtains $E$. If another cache holds $X$ in any non-invalid state, the requester obtains $Sc$, and the previous owner transitions according to: $E\\to Sc$, $M\\to Sm$, $Sm$ remains $Sm$. Writes from $E$ transition $E\\to M$ silently (no bus); writes from $Sc$ transition $Sc\\to Sm$ and broadcast a bus update $\\mathrm{BusUpd}$ to all sharers; writes from $Sm$ remain $Sm$ and broadcast $\\mathrm{BusUpd}$. On a write that broadcasts $\\mathrm{BusUpd}$, the writer becomes the owner in $Sm$, and any previous owner in $Sm$ transitions to $Sc$. There are no invalidations in write-update.\n\nFor both protocols, define the event counters over the entire execution for block $X$ across all caches as follows: count the total number of $\\mathrm{S}\\to\\mathrm{I}$ transitions, $\\mathrm{I}\\to\\mathrm{S}$ transitions, $\\mathrm{S}\\to\\mathrm{M}$ transitions, and bus update events $\\mathrm{BusUpd}$. Only count a transition when a cache’s state for $X$ actually changes in that manner; do not count $E\\to M$, $M\\to S$, $E\\to S$, or any other transitions not listed above. A bus update event $\\mathrm{BusUpd}$ is counted each time the write-update protocol broadcasts an update due to a store to a shared block. Under write-invalidate, $\\mathrm{BusUpd}$ events do not occur.\n\nExecute the following synthetic trace of memory operations on block $X$:\n- Step $1$: $C_0$ executes $\\mathrm{Load}\\, X$.\n- Step $2$: $C_1$ executes $\\mathrm{Load}\\, X$.\n- Step $3$: $C_0$ executes $\\mathrm{Store}\\, X$.\n- Step $4$: $C_2$ executes $\\mathrm{Load}\\, X$.\n- Step $5$: $C_1$ executes $\\mathrm{Store}\\, X$.\n- Step $6$: $C_0$ executes $\\mathrm{Load}\\, X$.\n- Step $7$: $C_2$ executes $\\mathrm{Store}\\, X$.\n- Step $8$: $C_1$ executes $\\mathrm{Load}\\, X$.\n\nUsing only the rules stated above, compute the total counts of $\\mathrm{S}\\to\\mathrm{I}$, $\\mathrm{I}\\to\\mathrm{S}$, $\\mathrm{S}\\to\\mathrm{M}$, and $\\mathrm{BusUpd}$ events for the write-invalidate protocol and for the write-update protocol over the entire trace. Express your final answer as a single row matrix\n$$\\begin{pmatrix}\n\\text{WI } \\mathrm{S}\\to\\mathrm{I}  \\text{WI } \\mathrm{I}\\to\\mathrm{S}  \\text{WI } \\mathrm{S}\\to\\mathrm{M}  \\text{WI } \\mathrm{BusUpd}  \\text{WU } \\mathrm{S}\\to\\mathrm{I}  \\text{WU } \\mathrm{I}\\to\\mathrm{S}  \\text{WU } \\mathrm{S}\\to\\mathrm{M}  \\text{WU } \\mathrm{BusUpd}\n\\end{pmatrix}.$$\nNo rounding is required.", "solution": "The problem is validated as being scientifically grounded, well-posed, and objective. It provides a self-contained set of rules for two cache coherence protocols (a write-invalidate MESI-like protocol and a write-update Dragon-like protocol) and a specific sequence of memory operations. The task is to trace the state of a cache block $X$ across three cores ($C_0, C_1, C_2$) and count the occurrences of four specific events: $\\mathrm{S}\\to\\mathrm{I}$ transitions, $\\mathrm{I}\\to\\mathrm{S}$ transitions, $\\mathrm{S}\\to\\mathrm{M}$ transitions, and $\\mathrm{BusUpd}$ events.\n\nThe solution will be derived by meticulously tracing the given sequence of operations for each protocol, tracking the cache states and incrementing event counters according to the provided rules.\n\n**Part 1: Write-Invalidate (WI) Protocol Analysis**\n\nWe trace the state of block $X$ in caches $C_0$, $C_1$, and $C_2$. The states are Modified ($M$), Exclusive ($E$), Shared ($S$), or Invalid ($I$). The initial state for all caches is $(I, I, I)$. The event counters for $(\\mathrm{S}\\to\\mathrm{I}, \\mathrm{I}\\to\\mathrm{S}, \\mathrm{S}\\to\\mathrm{M}, \\mathrm{BusUpd})$ start at $(0, 0, 0, 0)$.\n\n- **Initial State:** Cache states: $(C_0: I, C_1: I, C_2: I)$. Counters: $(0, 0, 0, 0)$.\n\n- **Step 1: $C_0$ executes $\\mathrm{Load}\\, X$.**\n  - $C_0$ misses, issues $\\mathrm{BusRd}$. No other cache has the block. Memory supplies the data.\n  - $C_0$ transitions from $I$ to $E$. No specified counters are affected.\n  - Cache states: $(C_0: E, C_1: I, C_2: I)$. Counters: $(0, 0, 0, 0)$.\n\n- **Step 2: $C_1$ executes $\\mathrm{Load}\\, X$.**\n  - $C_1$ misses, issues $\\mathrm{BusRd}$.\n  - $C_0$ snoops the $\\mathrm{BusRd}$, holds the block in state $E$. $C_0$ supplies the data and transitions $E \\to S$.\n  - $C_1$ receives the data and transitions $I \\to S$.\n  - **Event:** $C_1$ undergoes an $\\mathrm{I}\\to\\mathrm{S}$ transition.\n  - Cache states: $(C_0: S, C_1: S, C_2: I)$. Counters: $(0, 1, 0, 0)$.\n\n- **Step 3: $C_0$ executes $\\mathrm{Store}\\, X$.**\n  - $C_0$ holds the block in state $S$. To write, it must gain exclusive ownership. It issues a bus transaction (e.g., $\\mathrm{BusUpgr}$ or $\\mathrm{BusRdX}$) that invalidates other sharers.\n  - $C_1$ snoops the invalidation signal and transitions $S \\to I$.\n  - $C_0$ performs the write and transitions $S \\to M$.\n  - **Events:** $C_1$: $\\mathrm{S}\\to\\mathrm{I}$; $C_0$: $\\mathrm{S}\\to\\mathrm{M}$.\n  - Cache states: $(C_0: M, C_1: I, C_2: I)$. Counters: $(1, 1, 1, 0)$.\n\n- **Step 4: $C_2$ executes $\\mathrm{Load}\\, X$.**\n  - $C_2$ misses, issues $\\mathrm{BusRd}$.\n  - $C_0$ snoops the $\\mathrm{BusRd}$, holds in state $M$. $C_0$ writes the block back to memory, supplies the data to $C_2$, and transitions $M \\to S$.\n  - $C_2$ receives the data and transitions $I \\to S$.\n  - **Event:** $C_2$: $\\mathrm{I}\\to\\mathrm{S}$.\n  - Cache states: $(C_0: S, C_1: I, C_2: S)$. Counters: $(1, 2, 1, 0)$.\n\n- **Step 5: $C_1$ executes $\\mathrm{Store}\\, X$.**\n  - $C_1$ misses (state is $I$). It issues $\\mathrm{BusRdX}$ to get the block with exclusive ownership.\n  - This transaction invalidates all other copies. Both $C_0$ and $C_2$ snoop $\\mathrm{BusRdX}$ and invalidate their copies, transitioning $S \\to I$.\n  - $C_1$ obtains the block and transitions to state $M$. This $I \\to M$ transition is not counted.\n  - **Events:** $C_0$: $\\mathrm{S}\\to\\mathrm{I}$; $C_2$: $\\mathrm{S}\\to\\mathrm{I}$.\n  - Cache states: $(C_0: I, C_1: M, C_2: I)$. Counters: $(1+2=3, 2, 1, 0)$.\n\n- **Step 6: $C_0$ executes $\\mathrm{Load}\\, X$.**\n  - $C_0$ misses, issues $\\mathrm{BusRd}$.\n  - $C_1$ snoops the $\\mathrm{BusRd}$, holds in state $M$. $C_1$ writes back, supplies data, and transitions $M \\to S$.\n  - $C_0$ receives data and transitions $I \\to S$.\n  - **Event:** $C_0$: $\\mathrm{I}\\to\\mathrm{S}$.\n  - Cache states: $(C_0: S, C_1: S, C_2: I)$. Counters: $(3, 3, 1, 0)$.\n\n- **Step 7: $C_2$ executes $\\mathrm{Store}\\, X$.**\n  - $C_2$ misses (state is $I$). It issues $\\mathrm{BusRdX}$.\n  - $C_0$ and $C_1$ snoop $\\mathrm{BusRdX}$ and invalidate their copies, transitioning $S \\to I$.\n  - $C_2$ obtains the block and transitions to $M$.\n  - **Events:** $C_0$: $\\mathrm{S}\\to\\mathrm{I}$; $C_1$: $\\mathrm{S}\\to\\mathrm{I}$.\n  - Cache states: $(C_0: I, C_1: I, C_2: M)$. Counters: $(3+2=5, 3, 1, 0)$.\n\n- **Step 8: $C_1$ executes $\\mathrm{Load}\\, X$.**\n  - $C_1$ misses, issues $\\mathrm{BusRd}$.\n  - $C_2$ snoops the $\\mathrm{BusRd}$, holds in state $M$. $C_2$ writes back, supplies data, and transitions $M \\to S$.\n  - $C_1$ receives data and transitions $I \\to S$.\n  - **Event:** $C_1$: $\\mathrm{I}\\to\\mathrm{S}$.\n  - Cache states: $(C_0: I, C_1: S, C_2: S)$. Counters: $(5, 4, 1, 0)$.\n\n**Final Counts for Write-Invalidate (WI):**\n- Total $\\mathrm{S}\\to\\mathrm{I}$ transitions: $5$.\n- Total $\\mathrm{I}\\to\\mathrm{S}$ transitions: $4$.\n- Total $\\mathrm{S}\\to\\mathrm{M}$ transitions: $1$.\n- Total $\\mathrm{BusUpd}$ events: $0$.\n\n**Part 2: Write-Update (WU) Protocol Analysis**\n\nWe trace the state of block $X$ using the Dragon-like states: Exclusive-clean ($E$), Shared-clean ($Sc$), Shared-modified ($Sm$), Modified ($M$), and Invalid ($I$). The initial state is $(I, I, I)$. The event counters for $(\\mathrm{S}\\to\\mathrm{I}, \\mathrm{I}\\to\\mathrm{S}, \\mathrm{S}\\to\\mathrm{M}, \\mathrm{BusUpd})$ start at $(0, 0, 0, 0)$. Based on the problem's rules for this protocol:\n- There are no invalidations, so the count for $\\mathrm{S}\\to\\mathrm{I}$ must be $0$.\n- The only transition to state $M$ is from $E$. There is no $Sc \\to M$ or $Sm \\to M$. We interpret 'S' in the counter 'S→M' to mean either $Sc$ or $Sm$, so the count for $\\mathrm{S}\\to\\mathrm{M}$ must be $0$.\n- The transition $I \\to Sc$ is counted as an $\\mathrm{I}\\to\\mathrm{S}$ transition.\n\n- **Initial State:** Cache states: $(C_0: I, C_1: I, C_2: I)$. Counters: $(0, 0, 0, 0)$.\n\n- **Step 1: $C_0$ executes $\\mathrm{Load}\\, X$.**\n  - $C_0$ misses, issues $\\mathrm{BusRd}$. No other cache has the block.\n  - $C_0$ transitions $I \\to E$. No specified counters are affected.\n  - Cache states: $(C_0: E, C_1: I, C_2: I)$. Counters: $(0, 0, 0, 0)$.\n\n- **Step 2: $C_1$ executes $\\mathrm{Load}\\, X$.**\n  - $C_1$ misses, issues $\\mathrm{BusRd}$.\n  - $C_0$ snoops the $\\mathrm{BusRd}$ (state is $E$), supplies the data, and transitions $E \\to Sc$.\n  - $C_1$ receives data and transitions $I \\to Sc$.\n  - **Event:** $C_1$: $\\mathrm{I}\\to\\mathrm{S}$.\n  - Cache states: $(C_0: Sc, C_1: Sc, C_2: I)$. Counters: $(0, 1, 0, 0)$.\n\n- **Step 3: $C_0$ executes $\\mathrm{Store}\\, X$.**\n  - $C_0$ holds in state $Sc$. It transitions $Sc \\to Sm$ and broadcasts a $\\mathrm{BusUpd}$. It is now the owner.\n  - $C_1$ snoops the $\\mathrm{BusUpd}$, updates its data, and its state remains $Sc$.\n  - **Event:** A $\\mathrm{BusUpd}$ occurs.\n  - Cache states: $(C_0: Sm, C_1: Sc, C_2: I)$. Counters: $(0, 1, 0, 1)$.\n\n- **Step 4: $C_2$ executes $\\mathrm{Load}\\, X$.**\n  - $C_2$ misses, issues $\\mathrm{BusRd}$.\n  - There are sharers. $C_0$ (state $Sm$, owner) supplies the data and remains $Sm$. $C_1$ (state $Sc$) does nothing.\n  - $C_2$ receives data and transitions $I \\to Sc$.\n  - **Event:** $C_2$: $\\mathrm{I}\\to\\mathrm{S}$.\n  - Cache states: $(C_0: Sm, C_1: Sc, C_2: Sc)$. Counters: $(0, 2, 0, 1)$.\n\n- **Step 5: $C_1$ executes $\\mathrm{Store}\\, X$.**\n  - $C_1$ holds in state $Sc$. It transitions $Sc \\to Sm$ and broadcasts a $\\mathrm{BusUpd}$. $C_1$ becomes the new owner.\n  - The previous owner, $C_0$ (state $Sm$), snoops the $\\mathrm{BusUpd}$, updates its data, and transitions $Sm \\to Sc$.\n  - $C_2$ (state $Sc$) updates its data and remains $Sc$.\n  - **Event:** A $\\mathrm{BusUpd}$ occurs.\n  - Cache states: $(C_0: Sc, C_1: Sm, C_2: Sc)$. Counters: $(0, 2, 0, 2)$.\n\n- **Step 6: $C_0$ executes $\\mathrm{Load}\\, X$.**\n  - $C_0$ holds in state $Sc$. This is a load hit. No state change or bus transaction.\n  - Cache states: $(C_0: Sc, C_1: Sm, C_2: Sc)$. Counters: $(0, 2, 0, 2)$.\n\n- **Step 7: $C_2$ executes $\\mathrm{Store}\\, X$.**\n  - $C_2$ holds in state $Sc$. It transitions $Sc \\to Sm$ and broadcasts a $\\mathrm{BusUpd}$. $C_2$ becomes the new owner.\n  - The previous owner, $C_1$ (state $Sm$), snoops, updates, and transitions $Sm \\to Sc$.\n  - $C_0$ (state $Sc$) updates and remains $Sc$.\n  - **Event:** A $\\mathrm{BusUpd}$ occurs.\n  - Cache states: $(C_0: Sc, C_1: Sc, C_2: Sm)$. Counters: $(0, 2, 0, 3)$.\n\n- **Step 8: $C_1$ executes $\\mathrm{Load}\\, X$.**\n  - $C_1$ holds in state $Sc$. This is a load hit. No state change.\n  - Cache states: $(C_0: Sc, C_1: Sc, C_2: Sm)$. Counters: $(0, 2, 0, 3)$.\n\n**Final Counts for Write-Update (WU):**\n- Total $\\mathrm{S}\\to\\mathrm{I}$ transitions: $0$.\n- Total $\\mathrm{I}\\to\\mathrm{S}$ transitions: $2$.\n- Total $\\mathrm{S}\\to\\mathrm{M}$ transitions: $0$.\n- Total $\\mathrm{BusUpd}$ events: $3$.\n\n**Summary of Results**\nCombining the results for both protocols into the required matrix format:\n- WI $\\mathrm{S}\\to\\mathrm{I}$: $5$\n- WI $\\mathrm{I}\\to\\mathrm{S}$: $4$\n- WI $\\mathrm{S}\\to\\mathrm{M}$: $1$\n- WI $\\mathrm{BusUpd}$: $0$\n- WU $\\mathrm{S}\\to\\mathrm{I}$: $0$\n- WU $\\mathrm{I}\\to\\mathrm{S}$: $2$\n- WU $\\mathrm{S}\\to\\mathrm{M}$: $0$\n- WU $\\mathrm{BusUpd}$: $3$\n\nThe final answer is the row matrix of these counts in the specified order.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n5  4  1  0  0  2  0  3\n\\end{pmatrix}\n}\n$$", "id": "3678515"}, {"introduction": "Beyond ensuring correctness, a key goal of a coherence protocol is to deliver high performance. This practice moves from the mechanics of state transitions to the tangible impact on latency, exploring how protocol choice affects the time a processor must wait for data. By analyzing a sequence of reads and writes with a simple performance model, you will quantify the stall cycles incurred under both write-invalidate and write-update policies, revealing the performance trade-offs inherent in each approach [@problem_id:3678499].", "problem": "Consider a shared memory multiprocessor with two cores $C_0$ and $C_1$, each having a private, write-back cache. The caches implement a snooping-based coherence protocol over a single shared bus. The coherence state for each cache line follows the Modified-Shared-Invalid (MSI) protocol. Two variants of snooping are possible: write-invalidate and write-update. In write-invalidate, a write to a line in the Shared state triggers the writer to invalidate other shared copies and acquire exclusivity before updating its local copy. In write-update, a write to a line in the Shared state triggers the writer to broadcast the new data to other caches that hold the line so that they update their copies immediately, and the line remains shared.\n\nAssume the following bus and coherence timing parameters are fixed and deterministic:\n- Any bus transaction requires bus arbitration of $1$ cycle.\n- An invalidate or update broadcast takes $1$ cycle to propagate and be applied by snooping caches.\n- On a Bus Read (BusRd) request, if another cache holds the line in Modified state and supplies the data, the data transfer to the requester completes in $2$ cycles. If the line is only in memory or Shared in caches, the memory response would be $3$ cycles, but in the scenario below all data transfers on reads after writes come from the Modified owner, not memory.\n- A local cache hit for a read incurs $0$ cycles of stall beyond the core’s pipeline latency, which we treat as $0$ for this question.\n\nThe shared variable $x$ resides in a single cache line, and the initial memory value is $x=0$. The following time-ordered operations occur:\n- At time $t_0$, $C_0$ executes a read of $x$.\n- At time $t_1$, $C_1$ executes a read of $x$.\n- At time $t_2$, $C_0$ executes a write setting $x \\leftarrow 1$.\n- At time $t_3$ (immediately after the write at $t_2$ completes from the perspective of coherence actions required by the protocol in use), $C_1$ executes a read of $x$.\n- At time $t_4$, $C_1$ executes a write setting $x \\leftarrow 2$.\n- At time $t_5$ (immediately after the write at $t_4$ completes from the perspective of coherence actions required by the protocol in use), $C_0$ executes a read of $x$.\n\nAssume that at $t_0$ and $t_1$, both reads of $x$ bring the line into the Shared state in both caches with value $0$. No other operations occur. Using only the definitions above and the MSI state behavior, reason about the visibility and stalls.\n\nWhich option correctly characterizes the value returned and the stall cycles incurred at $t_3$ and $t_5$ under write-invalidate versus write-update?\n\nA. Under write-update, at $t_3$ $C_1$’s read returns $1$ with $0$ cycles of stall; under write-invalidate, the same read stalls for $3$ cycles and returns $1$. At $t_5$ under write-update, $C_0$’s read returns $2$ with $0$ cycles of stall; under write-invalidate, it stalls for $3$ cycles and returns $2$.\n\nB. Under write-invalidate, both reads at $t_3$ and $t_5$ incur $0$ cycles of stall, because cache-to-cache forwarding does not require bus arbitration; under write-update, both reads stall for $2$ cycles, because updates are not visible until a subsequent read fetches.\n\nC. Under write-update, $C_0$’s write at $t_2$ causes $C_1$ to invalidate its copy, so at $t_3$ $C_1$ must issue a Bus Read and stall for $3$ cycles; under write-invalidate, the write at $t_2$ is broadcast to shared copies, so at $t_3$ $C_1$ reads locally with $0$ cycles of stall.\n\nD. Under write-invalidate, at $t_3$ the read stalls for $3$ cycles and returns $1$, but at $t_5$ the read stalls for only $1$ cycle because the owner $C_1$ can reply immediately; under write-update, both reads stall for $1$ cycle.", "solution": "The problem asks to determine the value returned and stall cycles for two reads in a specific sequence, under both a write-invalidate and a write-update protocol. We will trace the state of the cache line for variable $x$ in caches $C_0$ and $C_1$.\n\n**Initial State:** Per the problem statement, after the reads at $t_0$ and $t_1$, the state is:\n-   $C_0$ Cache: Shared (S), value $0$.\n-   $C_1$ Cache: Shared (S), value $0$.\n\n**Part 1: Write-Invalidate Protocol Analysis**\n\n1.  **Event at $t_2$: $C_0$ writes $x \\leftarrow 1$.**\n    -   $C_0$ holds the line in state S. To write, it must gain exclusive ownership. It issues an invalidate command on the bus.\n    -   $C_1$ snoops the invalidate and transitions its copy from S to Invalid (I).\n    -   $C_0$ transitions its copy from S to Modified (M) and writes the value $1$.\n    -   State after write: $C_0$ has (M, value=1), $C_1$ has (I).\n\n2.  **Event at $t_3$: $C_1$ reads $x$.**\n    -   $C_1$'s copy is Invalid, so this is a cache miss.\n    -   $C_1$ issues a Bus Read (BusRd).\n    -   Stall cycles: $1$ cycle for bus arbitration + $2$ cycles for cache-to-cache data transfer from $C_0$ = $3$ cycles.\n    -   $C_0$ supplies the data (value $1$) and transitions its state from M to S. $C_1$ loads the data and sets its state to S.\n    -   **Result:** The read returns value $1$ and stalls for $3$ cycles.\n\n3.  **Event at $t_4$: $C_1$ writes $x \\leftarrow 2$.**\n    -   This is symmetric to the event at $t_2$. $C_1$ holds the line in state S. It issues an invalidate.\n    -   $C_0$ snoops and transitions its copy from S to I.\n    -   $C_1$ transitions its copy from S to M and writes the value $2$.\n    -   State after write: $C_1$ has (M, value=2), $C_0$ has (I).\n\n4.  **Event at $t_5$: $C_0$ reads $x$.**\n    -   This is symmetric to the event at $t_3$. $C_0$'s copy is Invalid, a cache miss.\n    -   $C_0$ issues a Bus Read (BusRd).\n    -   Stall cycles: $1$ cycle for bus arbitration + $2$ cycles for cache-to-cache data transfer from $C_1$ = $3$ cycles.\n    -   **Result:** The read returns value $2$ and stalls for $3$ cycles.\n\n**Part 2: Write-Update Protocol Analysis**\n\n1.  **Event at $t_2$: $C_0$ writes $x \\leftarrow 1$.**\n    -   $C_0$ holds the line in state S. It broadcasts the new data (value $1$) via a Bus Update transaction.\n    -   $C_1$ snoops the update, captures the new data, and updates its local copy. Its state remains S.\n    -   Both caches now hold the line in state S with value $1$.\n\n2.  **Event at $t_3$: $C_1$ reads $x$.**\n    -   $C_1$ has a valid, up-to-date copy in its cache (S, value=1). This is a local cache hit.\n    -   **Result:** The read returns value $1$ and stalls for $0$ cycles.\n\n3.  **Event at $t_4$: $C_1$ writes $x \\leftarrow 2$.**\n    -   Symmetric to the event at $t_2$. $C_1$ holds the line in S, broadcasts a Bus Update with value $2$.\n    -   $C_0$ snoops and updates its local copy. Both caches now hold the line in state S with value $2$.\n\n4.  **Event at $t_5$: $C_0$ reads $x$.**\n    -   $C_0$ has a valid, up-to-date copy (S, value=2). This is a local cache hit.\n    -   **Result:** The read returns value $2$ and stalls for $0$ cycles.\n\n**Conclusion:**\n\n-   Under **write-invalidate**, both reads at $t_3$ and $t_5$ incur a compulsory miss, requiring a bus transaction that stalls the core for $3$ cycles. They return the correct updated values, $1$ and $2$, respectively.\n-   Under **write-update**, the writes proactively update the other cache, so the subsequent reads at $t_3$ and $t_5$ are local hits, incurring $0$ stall cycles. They return the correct updated values, $1$ and $2$, respectively.\n\nComparing these findings with the given options, option A is the only one that matches this analysis for both protocols and at both time steps.", "answer": "$$\\boxed{A}$$", "id": "3678499"}, {"introduction": "Theoretical models often assume data fits neatly within a single cache line, but real-world programs are not always so tidy. This exercise introduces the practical complication of data misalignment, where a single variable straddles two separate cache lines. You will discover that coherence operates at the granularity of cache lines, not variables, meaning a single logical access can trigger multiple, independent coherence events. Analyzing this scenario will deepen your understanding of how low-level data layout can have a significant and sometimes surprising impact on bus traffic and system performance [@problem_id:3678490].", "problem": "Consider a shared-memory multiprocessor with $3$ cores, denoted $C_0$, $C_1$, and $C_2$. Each core has a private write-back cache that participates in a snooping coherence protocol over a single shared bus. The cache line size is $64$ bytes. A single program variable $v$ of size $24$ bytes is misaligned such that it straddles exactly two adjacent cache lines, $L_0$ and $L_1$: the last $8$ bytes of $L_0$ store the first $8$ bytes of $v$, and the first $16$ bytes of $L_1$ store the remaining $16$ bytes of $v$.\n\nAssume the following initial conditions and hardware behaviors:\n- At time $t=0$, no core holds $L_0$ or $L_1$ in its cache.\n- A read request that requires data not present in a cache line issues a line fill for the needed line. When a read fills a line and no other cache currently holds that line, the line is brought into the requester’s cache. Under a write-invalidate protocol, this line is brought into the Exclusive state; under a write-update protocol, the line is brought into the Shared state.\n- Each store that modifies any bytes within a line operates at line granularity for coherence, meaning a store that touches both $L_0$ and $L_1$ is realized as two separate per-line stores, one to $L_0$ and one to $L_1$.\n- There are no cache evictions during the scenario below.\n\nDefine the two coherence protocol variants to be analyzed:\n- Write-invalidate protocol using the Modified–Exclusive–Shared–Invalid (MESI) state machine. Coherence broadcasts counted are: one for each $\\text{BusRd}$ (read miss line fill), one for each $\\text{BusRdX}$ (read-for-ownership to write a line not present), and one for each $\\text{BusUpgr}$ (upgrade from Shared to Modified to write a line already present). Do not count silent state transitions or writebacks to memory; only count snoop-bus broadcasts that prompt other caches to snoop their tags.\n- Write-update protocol with write-allocate and per-line updates. Coherence broadcasts counted are: one for each $\\text{BusRd}$ (read miss line fill to acquire a Shared copy) and one for each $\\text{BusUpdate}$ (broadcast of new data to other shared copies upon a write). Do not count silent state transitions or writebacks to memory.\n\nNow execute the following sequence of operations on $v$:\n1. Core $C_0$ performs a read of $v$ that touches both $L_0$ and $L_1$.\n2. Core $C_1$ performs two stores: first, it writes $4$ contiguous bytes entirely within the portion of $v$ in $L_0$; second, it writes $8$ contiguous bytes entirely within the portion of $v$ in $L_1$.\n3. Core $C_2$ performs one store of $8$ contiguous bytes entirely within the portion of $v$ in $L_1$.\n4. Core $C_0$ performs a read of $v$ again, touching both $L_0$ and $L_1$.\n5. Core $C_1$ performs one store of $4$ contiguous bytes entirely within the portion of $v$ in $L_0$.\n6. Core $C_2$ performs one store of $4$ contiguous bytes entirely within the portion of $v$ in $L_1$.\n\nUnder the assumptions above, let $M_{\\text{inv}}$ be the total number of snoop-bus broadcasts under the write-invalidate protocol and $M_{\\text{upd}}$ be the total number under the write-update protocol. Compute the single quantity $M_{\\text{upd}} - M_{\\text{inv}}$. Express your final answer as a pure number with no units. If any numerical approximation is needed, round to four significant figures; otherwise give the exact integer value.", "solution": "The problem is well-defined, scientifically grounded in the principles of computer architecture, and provides a complete set of initial conditions, operational sequences, and protocol rules. All necessary information is present to deterministically trace the state of the system and count the specified bus broadcasts for two distinct cache coherence protocols. Therefore, the problem is valid and a solution can be derived.\n\nThe objective is to compute the difference $M_{\\text{upd}} - M_{\\text{inv}}$, where $M_{\\text{inv}}$ is the total number of snoop-bus broadcasts for a write-invalidate (MESI) protocol and $M_{\\text{upd}}$ is the total for a write-update protocol. The analysis requires tracing the state of two cache lines, $L_0$ and $L_1$, across $3$ cores ($C_0$, $C_1$, $C_2$) for a sequence of $6$ operations.\n\nLet the state of the cache lines for the three cores be denoted by a tuple of pairs: $((S_{0,0}, S_{0,1}), (S_{1,0}, S_{1,1}), (S_{2,0}, S_{2,1}))$, where $S_{i,j}$ is the state of line $L_j$ in core $C_i$'s cache. The initial state is Invalid (I) for all lines in all caches: $((I, I), (I, I), (I, I))$.\n\n**Part 1: Analysis of the Write-Invalidate (MESI) Protocol**\n\nWe trace the operations and count the broadcasts ($M_{\\text{inv}}$) based on the MESI states (Modified, Exclusive, Shared, Invalid).\n\nInitial State: $((I, I), (I, I), (I, I))$, $M_{\\text{inv}} = 0$.\n\n1.  **$C_0$ reads $v$ (touching $L_0$ and $L_1$)**: This comprises two read misses.\n    -   $C_0$ reads $L_0$: This is a miss. Since no other cache holds $L_0$, $C_0$ issues a `BusRd` and brings the line into the **Exclusive (E)** state.\n        -   Bus broadcast: $1$ (`BusRd`). $M_{\\text{inv}} \\leftarrow 0 + 1 = 1$.\n    -   $C_0$ reads $L_1$: This is also a miss. Similarly, $C_0$ issues a `BusRd` and brings $L_1$ into the **E** state.\n        -   Bus broadcast: $1$ (`BusRd`). $M_{\\text{inv}} \\leftarrow 1 + 1 = 2$.\n    -   State after op 1: $((E, E), (I, I), (I, I))$. Total broadcasts for this step: $2$.\n\n2.  **$C_1$ writes to $L_0$ and $L_1$**: This comprises two write misses.\n    -   $C_1$ writes to $L_0$: A write miss. $C_1$ issues a `BusRdX` (read-for-ownership). $C_0$ snoops the bus, sees the request for $L_0$ which it holds in state **E**, and invalidates its copy (**E** $\\rightarrow$ **I**). $C_1$ loads the line into the **Modified (M)** state.\n        -   Bus broadcast: $1$ (`BusRdX`). $M_{\\text{inv}} \\leftarrow 2 + 1 = 3$.\n    -   $C_1$ writes to $L_1$: Another write miss. $C_1$ issues a `BusRdX` for $L_1$. $C_0$ invalidates its copy of $L_1$ (**E** $\\rightarrow$ **I**). $C_1$ brings $L_1$ into the **M** state.\n        -   Bus broadcast: $1$ (`BusRdX`). $M_{\\text{inv}} \\leftarrow 3 + 1 = 4$.\n    -   State after op 2: $((I, I), (M, M), (I, I))$. Total broadcasts for this step: $2$.\n\n3.  **$C_2$ writes to $L_1$**: This is a write miss.\n    -   $C_2$ issues a `BusRdX` for $L_1$. $C_1$ snoops the bus, sees it holds $L_1$ in state **M**, flushes the data to memory (or directly to $C_2$), and invalidates its copy (**M** $\\rightarrow$ **I**). $C_2$ loads the line into the **M** state.\n        -   Bus broadcast: $1$ (`BusRdX`). $M_{\\text{inv}} \\leftarrow 4 + 1 = 5$.\n    -   State after op 3: $((I, I), (M, I), (I, M))$. Total broadcasts for this step: $1$.\n\n4.  **$C_0$ reads $v$ (touching $L_0$ and $L_1$)**: Two read misses.\n    -   $C_0$ reads $L_0$: Miss. $C_0$ issues a `BusRd`. $C_1$ snoops, has $L_0$ in state **M**, supplies the data, and transitions its state to **Shared (S)**. $C_0$ loads the line into the **S** state.\n        -   Bus broadcast: $1$ (`BusRd`). $M_{\\text{inv}} \\leftarrow 5 + 1 = 6$.\n    -   $C_0$ reads $L_1$: Miss. $C_0$ issues a `BusRd`. $C_2$ snoops, has $L_1$ in state **M**, supplies the data, and transitions its state to **S**. $C_0$ loads the line into the **S** state.\n        -   Bus broadcast: $1$ (`BusRd`). $M_{\\text{inv}} \\leftarrow 6 + 1 = 7$.\n    -   State after op 4: $((S, S), (S, I), (I, S))$. Total broadcasts for this step: $2$.\n\n5.  **$C_1$ writes to $L_0$**: A write hit, but on a shared line.\n    -   $C_1$ holds $L_0$ in state **S**. To write, it must gain exclusive ownership. It issues a `BusUpgr` transaction. $C_0$ snoops and invalidates its copy of $L_0$ (**S** $\\rightarrow$ **I**). $C_1$ transitions its state from **S** to **M**.\n        -   Bus broadcast: $1$ (`BusUpgr`). $M_{\\text{inv}} \\leftarrow 7 + 1 = 8$.\n    -   State after op 5: $((I, S), (M, I), (I, S))$. Total broadcasts for this step: $1$.\n\n6.  **$C_2$ writes to $L_1$**: A write hit on a shared line.\n    -   $C_2$ holds $L_1$ in state **S**. It issues a `BusUpgr`. $C_0$ snoops and invalidates its copy of $L_1$ (**S** $\\rightarrow$ **I**). $C_2$ transitions its state from **S** to **M**.\n        -   Bus broadcast: $1$ (`BusUpgr`). $M_{\\text{inv}} \\leftarrow 8 + 1 = 9$.\n    -   State after op 6: $((I, I), (M, I), (I, M))$. Total broadcasts for this step: $1$.\n\nThe total number of bus broadcasts for the write-invalidate protocol is $M_{\\text{inv}} = 9$.\n\n**Part 2: Analysis of the Write-Update Protocol**\n\nWe trace the operations and count the broadcasts ($M_{\\text{upd}}$). The states are simplified to Shared (S) and Invalid (I) based on the problem description. A write to a shared line triggers a `BusUpdate`, and all copies remain shared. A write miss triggers a `BusRd` followed by a `BusUpdate`.\n\nInitial State: $((I, I), (I, I), (I, I))$, $M_{\\text{upd}} = 0$.\n\n1.  **$C_0$ reads $v$ (touching $L_0$ and $L_1$)**: Two read misses.\n    -   $C_0$ reads $L_0$: Miss. Since no other cache holds the line, $C_0$ issues a `BusRd` and brings the line into the **Shared (S)** state as per the rules.\n        -   Bus broadcast: $1$ (`BusRd`). $M_{\\text{upd}} \\leftarrow 0 + 1 = 1$.\n    -   $C_0$ reads $L_1$: Miss. $C_0$ issues a `BusRd` and brings $L_1$ into the **S** state.\n        -   Bus broadcast: $1$ (`BusRd`). $M_{\\text{upd}} \\leftarrow 1 + 1 = 2$.\n    -   State after op 1: $((S, S), (I, I), (I, I))$. Total broadcasts for this step: $2$.\n\n2.  **$C_1$ writes to $L_0$ and $L_1$**: Two write misses.\n    -   $C_1$ writes to $L_0$: This is a write miss (\"write-allocate\"). $C_1$ first issues a `BusRd` to fetch the line. $C_0$ has $L_0$ in state **S**. $C_1$ loads the line into state **S**. Then, $C_1$ performs the write, which is now a hit on a shared line, triggering a `BusUpdate`. $C_0$ updates its copy.\n        -   Bus broadcasts: $1$ (`BusRd`) + $1$ (`BusUpdate`). $M_{\\text{upd}} \\leftarrow 2 + 2 = 4$.\n    -   $C_1$ writes to $L_1$: Similarly, $C_1$ issues a `BusRd` for $L_1$, bringing it to state **S**. Then it issues a `BusUpdate` for the write. $C_0$ updates its copy.\n        -   Bus broadcasts: $1$ (`BusRd`) + $1$ (`BusUpdate`). $M_{\\text{upd}} \\leftarrow 4 + 2 = 6$.\n    -   State after op 2: $((S, S), (S, S), (I, I))$. Total broadcasts for this step: $4$.\n\n3.  **$C_2$ writes to $L_1$**: A write miss.\n    -   $C_2$ issues a `BusRd` to get $L_1$. $C_0$ and $C_1$ have it in **S**. $C_2$ loads $L_1$ into state **S**. Then $C_2$ writes, issuing a `BusUpdate`. $C_0$ and $C_1$ update their copies.\n        -   Bus broadcasts: $1$ (`BusRd`) + $1$ (`BusUpdate`). $M_{\\text{upd}} \\leftarrow 6 + 2 = 8$.\n    -   State after op 3: $((S, S), (S, S), (I, S))$. Total broadcasts for this step: $2$.\n\n4.  **$C_0$ reads $v$ (touching $L_0$ and $L_1$)**: Two read hits.\n    -   $C_0$ reads $L_0$: Hit in state **S**. No broadcast.\n    -   $C_0$ reads $L_1$: Hit in state **S**. No broadcast.\n    -   State after op 4: $((S, S), (S, S), (I, S))$. Total broadcasts for this step: $0$.\n\n5.  **$C_1$ writes to $L_0$**: A write hit on a shared line.\n    -   $C_1$ holds $L_0$ in state **S**. It performs the write and issues a `BusUpdate`. $C_0$ updates its copy. Both lines remain in state **S**.\n        -   Bus broadcast: $1$ (`BusUpdate`). $M_{\\text{upd}} \\leftarrow 8 + 1 = 9$.\n    -   State after op 5: $((S, S), (S, S), (I, S))$. Total broadcasts for this step: $1$.\n\n6.  **$C_2$ writes to $L_1$**: A write hit on a shared line.\n    -   $C_2$ holds $L_1$ in state **S**. It performs the write and issues a `BusUpdate`. $C_0$ and $C_1$ update their copies. All three lines remain in state **S**.\n        -   Bus broadcast: $1$ (`BusUpdate`). $M_{\\text{upd}} \\leftarrow 9 + 1 = 10$.\n    -   State after op 6: $((S, S), (S, S), (I, S))$. Total broadcasts for this step: $1$.\n\nThe total number of bus broadcasts for the write-update protocol is $M_{\\text{upd}} = 10$.\n\n**Part 3: Final Calculation**\n\nWe are asked to compute the quantity $M_{\\text{upd}} - M_{\\text{inv}}$.\n-   Total broadcasts for write-invalidate: $M_{\\text{inv}} = 9$.\n-   Total broadcasts for write-update: $M_{\\text{upd}} = 10$.\n\nThe difference is:\n$M_{\\text{upd}} - M_{\\text{inv}} = 10 - 9 = 1$.\nThe final answer is an exact integer value.", "answer": "$$\\boxed{1}$$", "id": "3678490"}]}