{"hands_on_practices": [{"introduction": "A cornerstone of evaluating a pseudo-random number generator (PRNG) is the collision test, which draws a powerful analogy to the classic \"birthday problem.\" This practice challenges you to implement a collision test for a Linear Congruential Generator (LCG), a widely-known class of PRNGs. By binning the generator's output and counting \"collisions\"—instances where multiple outputs fall into the same bin—we can compare the generator's behavior against the statistical predictions for a truly random sequence [@problem_id:2429616]. This exercise provides direct insight into how deviations from expected random behavior can be quantitatively detected.", "problem": "Implement a mathematically specified collision test inspired by the Diehard suite and connect it to the classical birthday problem. Consider a pseudo-random number generator (PRNG) defined by a linear congruential generator (LCG). Let the sequence $\\{x_n\\}_{n \\ge 0}$ be defined over the modulus $2^{32}$ by the recurrence\n$$\nx_{n+1} \\equiv a x_n + c \\pmod{2^{32}},\n$$\nwith multiplier $a = 1664525$, increment $c = 1013904223$, and initial seed $x_0 = s$. For a given positive integer $t$, define the first $t$ outputs as $u_1,u_2,\\dots,u_t$ where $u_n = x_n$ interpreted as an integer in $\\{0,1,\\dots,2^{32}-1\\}$.\n\nFix a positive integer $b$ (the number of bins). Define the bin index sequence $\\{i_n\\}_{n=1}^t$ by\n$$\ni_n \\equiv u_n \\bmod b \\in \\{0,1,\\dots,b-1\\}.\n$$\nLet $c_j$ be the number of indices $n \\in \\{1,\\dots,t\\}$ such that $i_n = j$, for each $j \\in \\{0,1,\\dots,b-1\\}$. Define the number of colliding unordered pairs\n$$\nK \\equiv \\sum_{j=0}^{b-1} \\binom{c_j}{2}.\n$$\n\nUnder the null hypothesis that the bin indices are independent and identically distributed with the uniform distribution on $\\{0,1,\\dots,b-1\\}$, and for large $b$ with $t$ not too large relative to $b$, the distribution of $K$ is well approximated by a Poisson distribution with mean\n$$\n\\lambda \\equiv \\frac{\\binom{t}{2}}{b} = \\frac{t(t-1)}{2b}.\n$$\nFor an observed $K$, define the two-sided $p$-value by\n$$\np \\equiv 2 \\min\\left( \\mathbb{P}(X \\le K),\\ \\mathbb{P}(X \\ge K)\\right),\n$$\nwhere $X \\sim \\mathrm{Poisson}(\\lambda)$ and $\\mathbb{P}(X \\ge K) = 1 - \\mathbb{P}(X \\le K-1)$, with the convention that $\\mathbb{P}(X \\le -1) = 0$.\n\nYour task is to write a complete program that, for each test case below, constructs the specified LCG sequence, maps values into $b$ bins, computes $K$, computes $\\lambda$, and then returns the two-sided $p$-value $p$ as defined above. No external input shall be read by the program.\n\nTest suite:\n- Case $1$: $b = 2^{16}$, $t = 100000$, $s = 123456789$.\n- Case $2$: $b = 10^{6}$, $t = 1000$, $s = 42$.\n- Case $3$: $b = 2^{20}$, $t = 1448$, $s = 987654321$.\n\nThe required program output format is a single line containing the $p$-values for the three cases in order, as a comma-separated list enclosed in square brackets, with each $p$-value rounded to exactly $6$ digits after the decimal point. For example: \"[$0.123456,0.500000,0.987654$]\". All outputs are unitless real numbers in decimal form.", "solution": "The problem statement is subjected to validation.\n\n### Step 1: Extract Givens\n- **Pseudo-Random Number Generator (PRNG)**: Linear Congruential Generator (LCG).\n- **Recurrence Relation**: $x_{n+1} \\equiv a x_n + c \\pmod{2^{32}}$, with integer sequence $\\{x_n\\}_{n \\ge 0}$.\n- **Multiplier**: $a = 1664525$.\n- **Increment**: $c = 1013904223$.\n- **Modulus**: $2^{32}$.\n- **Initial Seed**: $x_0 = s$.\n- **PRNG Outputs**: For a given positive integer $t$, the first $t$ outputs are $u_1, u_2, \\dots, u_t$, where $u_n = x_n$.\n- **Binning**: A positive integer $b$ defines the number of bins.\n- **Bin Index Sequence**: $\\{i_n\\}_{n=1}^t$ is defined by $i_n \\equiv u_n \\bmod b$, with values in $\\{0, 1, \\dots, b-1\\}$.\n- **Bin Counts**: Let $c_j$ be the number of indices $n \\in \\{1, \\dots, t\\}$ such that $i_n = j$, for each $j \\in \\{0, 1, \\dots, b-1\\}$.\n- **Number of Collisions**: $K \\equiv \\sum_{j=0}^{b-1} \\binom{c_j}{2}$.\n- **Null Hypothesis**: The bin indices $\\{i_n\\}$ are independent and identically distributed (i.i.d.) with the uniform distribution on $\\{0, 1, \\dots, b-1\\}$.\n- **Approximation**: Under the null hypothesis, for large $b$ and $t$ not too large relative to $b$, the distribution of $K$ is approximated by a Poisson distribution.\n- **Poisson Mean**: $\\lambda \\equiv \\frac{\\binom{t}{2}}{b} = \\frac{t(t-1)}{2b}$.\n- **Two-Sided $p$-value**: $p \\equiv 2 \\min\\left( \\mathbb{P}(X \\le K),\\ \\mathbb{P}(X \\ge K)\\right)$, where $X \\sim \\mathrm{Poisson}(\\lambda)$.\n- **Probability Calculation**: $\\mathbb{P}(X \\ge K) = 1 - \\mathbb{P}(X \\le K-1)$, with the convention that $\\mathbb{P}(X \\le -1) = 0$.\n- **Test Cases**:\n    - Case $1$: $b = 2^{16}$, $t = 100000$, $s = 123456789$.\n    - Case $2$: $b = 10^{6}$, $t = 1000$, $s = 42$.\n    - Case $3$: $b = 2^{20}$, $t = 1448$, $s = 987654321$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem describes a collision test, a standard statistical method for evaluating the quality of pseudo-random number generators. The LCG is a classical PRNG. The Poisson approximation for the number of collisions in a birthday-problem-like scenario is a well-established result in probability theory. The chosen LCG parameters $a$ and $c$ are known in the literature (e.g., used in Knuth's MMIX). The problem is scientifically sound.\n- **Well-Posedness**: All necessary parameters ($a, c, s, t, b$) and formulas for computation ($K, \\lambda, p$) are explicitly provided. The procedure is deterministic and leads to a unique, computable result for each test case.\n- **Objectivity**: The problem is stated in precise, mathematical terms, free from any subjective or ambiguous language.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically grounded, well-posed, objective, and complete. I will now provide the solution.\n\nThe solution is a systematic implementation of the procedure described in the problem statement. For each test case, specified by the parameters $(s, t, b)$, we perform the following steps.\n\n**1. LCG Sequence Generation**\nFirst, we generate a sequence of $t$ pseudo-random integers. The sequence $\\{x_n\\}_{n \\ge 0}$ is defined by the recurrence relation\n$$x_{n+1} \\equiv (a \\cdot x_n + c) \\pmod{2^{32}}$$\nwith $a = 1664525$, $c = 1013904223$, and the modulus $M = 2^{32}$. The computation is performed using unsigned $32$-bit integer arithmetic, which corresponds to taking the result modulo $2^{32}$. Starting with the given seed $x_0 = s$, we generate the sequence of $t$ values $\\{u_1, u_2, \\dots, u_t\\}$, where $u_n = x_n$ for $n=1, \\dots, t$.\n\n**2. Binning and Collision Counting**\nThe generated integers $\\{u_n\\}_{n=1}^t$ are mapped to a set of $b$ bins. The bin index $i_n$ for each integer $u_n$ is computed as\n$$i_n = u_n \\pmod b$$\nThe result $i_n$ is an integer in the set $\\{0, 1, \\dots, b-1\\}$. We then count the number of times each bin is hit. Let $c_j$ be the count for bin $j$, for $j$ from $0$ to $b-1$. The total number of unordered colliding pairs, $K$, is the sum of collisions within each bin. The number of pairs in a bin with $c_j$ items is $\\binom{c_j}{2}$. Thus, the total number of collisions is\n$$K = \\sum_{j=0}^{b-1} \\binom{c_j}{2} = \\sum_{j=0}^{b-1} \\frac{c_j(c_j-1)}{2}$$\n\n**3. Statistical Evaluation**\nUnder the null hypothesis that the PRNG is ideal, the bin indices $\\{i_n\\}$ are i.i.d. and uniformly distributed. The number of collisions $K$ is then expected to follow a Poisson distribution, $X \\sim \\mathrm{Poisson}(\\lambda)$, with mean $\\lambda$ given by\n$$\\lambda = \\frac{\\binom{t}{2}}{b} = \\frac{t(t-1)}{2b}$$\nThis is the expected number of collisions when $t$ items are thrown randomly into $b$ bins.\n\nTo quantify the deviation of the observed collision count $K$ from its expectation, we calculate a two-sided $p$-value. The $p$-value measures the probability of observing a result at least as extreme as $K$. It is defined as\n$$p = 2 \\min\\left( \\mathbb{P}(X \\le K),\\ \\mathbb{P}(X \\ge K)\\right)$$\nwhere $X \\sim \\mathrm{Poisson}(\\lambda)$. The probabilities are calculated using the Poisson cumulative distribution function (CDF), denoted $F(k; \\lambda) = \\mathbb{P}(X \\le k)$.\nThe two terms are:\n- The left-tail probability: $\\mathbb{P}(X \\le K) = F(K; \\lambda)$.\n- The right-tail probability: $\\mathbb{P}(X \\ge K) = 1 - \\mathbb{P}(X \\le K-1) = 1 - F(K-1; \\lambda)$. This is also directly computable via the survival function (SF), where $\\mathrm{sf}(k; \\lambda) = \\mathbb{P}(X > k)$. Thus, $\\mathbb{P}(X \\ge K) = \\mathrm{sf}(K-1; \\lambda)$.\n\nThe implementation will utilize numerical libraries for these calculations: `numpy` for efficient array manipulation in the generation and binning steps, and `scipy.stats.poisson` to compute the CDF and SF of the Poisson distribution. The final $p$-value for each test case is then formatted as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import poisson\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the p-value for a collision test on an LCG PRNG.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (b, t, s)\n        (2**16, 100000, 123456789),\n        (10**6, 1000, 42),\n        (2**20, 1448, 987654321),\n    ]\n\n    results = []\n    \n    # LCG parameters\n    a = 1664525\n    c = 1013904223\n    # Use a mask for 32-bit unsigned integer arithmetic\n    mod_mask = 0xFFFFFFFF \n\n    for b, t, s in test_cases:\n        # Step 1: LCG Sequence Generation\n        # The sequence is x_1, x_2, ..., x_t\n        # where x_{n+1} = a*x_n + c (mod 2^32) and x_0 = s.\n        x_n = s\n        u_sequence = np.empty(t, dtype=np.uint32)\n        for i in range(t):\n            x_n = (a * x_n + c) & mod_mask\n            u_sequence[i] = x_n\n\n        # Step 2: Binning and Collision Counting\n        # Map generated values to bins\n        i_sequence = u_sequence % b\n        \n        # Count occurrences in each bin\n        # minlength ensures the counts array has size b even if some high-indexed bins are empty.\n        counts = np.bincount(i_sequence, minlength=b)\n        \n        # Calculate the observed number of collisions, K\n        # K = sum over all bins j of C(c_j, 2)\n        # Using np.int64 for K to avoid overflow with large counts\n        K = np.sum(counts.astype(np.int64) * (counts.astype(np.int64) - 1) // 2)\n\n        # Step 3: Statistical Evaluation\n        # Calculate the Poisson mean lambda\n        lambda_val = (t * (t - 1)) / (2 * b)\n        \n        # Calculate the two-sided p-value\n        # P(X <= K)\n        prob_le_K = poisson.cdf(K, lambda_val)\n        \n        # P(X >= K) = 1 - P(X <= K-1)\n        # Using the survival function sf(k) = 1 - cdf(k) is more numerically stable.\n        # P(X >= K) = P(X > K-1) = sf(K-1)\n        prob_ge_K = poisson.sf(K - 1, lambda_val)\n        \n        p_value = 2 * min(prob_le_K, prob_ge_K)\n        \n        results.append(p_value)\n\n    # Format the final output string as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2429616"}, {"introduction": "Beyond uniform distributions, a high-quality random sequence must exhibit independence between its elements. This hands-on practice explores this concept using an autocorrelation test, a fundamental tool for detecting serial dependence in a sequence. You will generate numbers not from a standard PRNG, but from the logistic map, a classic example of a system that can produce chaotic—and seemingly random—behavior [@problem_id:2403579]. This exercise builds a practical bridge between the theory of chaotic dynamics and the statistical validation of pseudo-randomness.", "problem": "Implement a pseudo-random number generator based on the chaotic logistic map and assess the short-lag autocorrelation of its outputs. The logistic map is defined by the recurrence $x_{n+1} = r \\, x_n \\, (1 - x_n)$ for parameter $r$ and state $x_n$ in the interval $(0,1)$. In this task, use $r = 4$, which places the system in a strongly chaotic regime. You must generate sequences from specified initial seeds and then quantify the quality of the generated pseudo-random numbers by computing sample autocorrelations at prescribed lags.\n\nYour program must implement the following steps from first principles:\n\n1. Use the recurrence $x_{n+1} = 4 \\, x_n \\, (1 - x_n)$ to generate a sequence. For a given initial seed $x_0 \\in (0,1)$:\n   - Discard an initial transient (burn-in) of $B$ steps to reduce sensitivity to initial conditions.\n   - Record the next $N$ values as the pseudo-random sequence $\\{x_n\\}_{n=1}^{N}$.\n2. For the recorded sequence $\\{x_n\\}$, form the mean-centered sequence $y_n = x_n - \\bar{x}$, where $\\bar{x}$ is the sample mean of $\\{x_n\\}$. Compute the sample autocorrelation at lag $k$ using the finite-sample estimator\n   $$\\rho(k) = \\frac{\\sum_{n=1}^{N-k} y_n \\, y_{n+k}}{\\sum_{n=1}^{N} y_n^2}.$$\n   If the variance $\\sum_{n=1}^{N} y_n^2$ is zero to numerical tolerance, declare the correlation test to fail for that seed.\n3. A sequence passes the correlation test if and only if the maximum absolute autocorrelation over the specified set of lags is below a threshold,\n   $$\\max_{k \\in \\mathcal{K}} |\\rho(k)| \\le \\tau,$$\n   where the threshold is given by\n   $$\\tau = \\frac{c}{\\sqrt{N}}.$$\n   This choice is motivated by the behavior of sample autocorrelations for weakly dependent or mixing processes, where typical fluctuations scale as $N^{-1/2}$.\n\nUse the following fixed parameters as a built-in test suite:\n- Logistic map parameter: $r = 4$.\n- Burn-in length: $B = 1000$.\n- Recorded length: $N = 100000$.\n- Lags: $\\mathcal{K} = \\{1, 2, 3, 5, 10, 50, 100\\}$.\n- Threshold scaling constant: $c = 3$.\n- Seeds to test (in the given order): $[0.123456789, \\, 0.2, \\, 0.50123456789, \\, 10^{-12}, \\, 0.75]$.\n\nFor each seed, generate the sequence and evaluate whether it passes the correlation test as defined above. The final output for the entire program must be a single line containing a list of boolean values in the same order as the seeds, where each boolean indicates pass (True) or fail (False) for that seed. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[ \\text{True}, \\text{False}, \\text{True} ]$). No physical units are involved. Angles, when used in mathematical functions, must be in radians, but no angle inputs are required here. The outputs must be booleans and must be presented exactly as specified in a single list on a single line.", "solution": "The problem statement is critically validated and found to be valid. It is scientifically grounded in the principles of chaotic dynamics and statistical time series analysis, well-posed with all necessary parameters and definitions provided, and objectively formulated. The task is to implement a well-defined computational algorithm and is feasible.\n\nThe problem requires the implementation of a pseudo-random number generator (PRNG) based on the logistic map, followed by a statistical validation of the generated sequences using an autocorrelation test.\n\nThe fundamental principle is that deterministic dynamical systems exhibiting chaos can produce sequences that appear random and pass certain statistical tests for randomness. The logistic map is defined by the recurrence relation:\n$$\nx_{n+1} = r \\cdot x_n \\cdot (1 - x_n)\n$$\nFor the specified parameter $r=4$, the map is fully chaotic for almost all initial conditions $x_0 \\in (0, 1)$. The long-term behavior of the sequence is governed by a statistical distribution (the invariant measure) and is highly sensitive to initial conditions, which are properties desirable in a PRNG.\n\nThe solution is constructed in three stages as per the problem description.\n\nStep 1: Sequence Generation\nFor each given initial seed $x_0$, a numerical sequence is generated.\nFirst, an initial transient of $B=1000$ iterations is discarded. This \"burn-in\" phase allows the trajectory to settle onto the system's attractor, effectively removing the dependence of the subsequent sequence on the specific choice of $x_0$. Let the initial state be $z_0 = x_0$. The burn-in consists of iterating:\n$$\nz_{i+1} = 4 \\cdot z_i \\cdot (1 - z_i) \\quad \\text{for } i = 0, 1, \\dots, B-1\n$$\nAfter the burn-in, the next $N=100000$ values are generated and stored. This constitutes the pseudo-random sequence $\\{x_n\\}_{n=1}^N$, where $x_n = z_{B+n-1}$.\n\nStep 2: Autocorrelation Computation\nTo assess the quality of the generated sequence, we test for serial correlation. A high-quality random sequence should have values that are independent of preceding values. The sample autocorrelation function measures the linear correlation between elements of the sequence at a given lag $k$.\nFirst, the sequence is mean-centered by computing the sample mean $\\bar{x}$ and creating a new sequence $\\{y_n\\}_{n=1}^N$:\n$$\n\\bar{x} = \\frac{1}{N} \\sum_{n=1}^{N} x_n\n$$\n$$\ny_n = x_n - \\bar{x}\n$$\nThe sample autocorrelation at lag $k$ is then computed using the estimator provided:\n$$\n\\rho(k) = \\frac{\\sum_{n=1}^{N-k} y_n \\cdot y_{n+k}}{\\sum_{n=1}^{N} y_n^2}\n$$\nThe denominator, $\\sum_{n=1}^{N} y_n^2$, is the sum of squared deviations from the mean. If this term is zero (within numerical precision), it indicates the sequence $\\{x_n\\}$ is constant. This can happen if the seed $x_0$ is a fixed point or part of a short periodic cycle of the map. For the seed $x_0=0.75$, $x_{n+1} = 4 \\cdot 0.75 \\cdot (1-0.75) = 0.75$, so the sequence is constant. In such cases, the mean is equal to the constant value, all $y_n$ are zero, and the denominator is zero. The problem explicitly states that a test with zero variance fails.\n\nStep 3: Pass/Fail Evaluation\nThe sequence passes the test if its autocorrelations are small across a specified set of lags, $\\mathcal{K} = \\{1, 2, 3, 5, 10, 50, 100\\}$. The criterion is:\n$$\n\\max_{k \\in \\mathcal{K}} |\\rho(k)| \\le \\tau\n$$\nThe threshold $\\tau$ is defined as:\n$$\n\\tau = \\frac{c}{\\sqrt{N}}\n$$\nWith the given parameters $c=3$ and $N=100000$, the threshold is $\\tau = 3 / \\sqrt{100000} \\approx 0.009487$. This threshold is statistically motivated. For a truly random sequence, sample autocorrelations for large $N$ are approximately normally distributed with mean $0$ and standard deviation $1/\\sqrt{N}$. The threshold $\\tau$ thus defines a confidence interval (approximately a \"3-sigma\" limit), outside of which the observed correlation is deemed statistically significant, implying a failure of the randomness test.\n\nThe algorithm will be implemented for each seed in the provided list. The final result is a list of boolean values, indicating whether each seed generated a sequence that passed (`True`) or failed (`False`) the test.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a pseudo-random number generator based on the chaotic logistic map\n    and assesses the short-lag autocorrelation of its outputs.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    r = 4.0\n    B = 1000\n    N = 100000\n    lags = [1, 2, 3, 5, 10, 50, 100]\n    c = 3.0\n    \n    # Seeds to be tested as per the problem statement.\n    test_cases = [\n        0.123456789,\n        0.2,\n        0.50123456789,\n        1e-12, # Representing 10^{-12}\n        0.75\n    ]\n\n    results = []\n    for seed in test_cases:\n        results.append(run_correlation_test(seed, r, B, N, lags, c))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_correlation_test(x0, r, B, N, lags, c):\n    \"\"\"\n    Generates a sequence from the logistic map and evaluates its autocorrelation properties.\n\n    Args:\n        x0 (float): The initial seed for the logistic map, in (0, 1).\n        r (float): The parameter of the logistic map.\n        B (int): The number of burn-in iterations.\n        N (int): The length of the sequence to record.\n        lags (list[int]): The set of lags k to compute autocorrelation for.\n        c (float): The scaling constant for the significance threshold.\n\n    Returns:\n        bool: True if the sequence passes the correlation test, False otherwise.\n    \"\"\"\n    \n    # --- Step 1: Sequence Generation ---\n    x = float(x0) # Ensure float64 for precision.\n    \n    # Burn-in period to discard initial transient\n    for _ in range(B):\n        x = r * x * (1.0 - x)\n        \n    # Record the sequence after burn-in\n    sequence = np.zeros(N, dtype=np.float64)\n    for i in range(N):\n        x = r * x * (1.0 - x)\n        sequence[i] = x\n\n    # --- Step 2: Autocorrelation Computation ---\n    # Create the mean-centered sequence y_n = x_n - mean(x)\n    mean_x = np.mean(sequence)\n    y = sequence - mean_x\n    \n    # Compute the denominator of the autocorrelation formula\n    # This is equivalent to sum(y_n^2) from n=1 to N\n    sum_y_sq = np.dot(y, y)\n    \n    # If variance is zero to numerical tolerance, the test fails\n    if sum_y_sq < 1e-20:\n        return False\n\n    max_abs_rho = 0.0\n    \n    for k in lags:\n        # Numerator: sum_{n=1 to N-k} y_n * y_{n+k}\n        # Implemented with numpy slicing and dot product for efficiency\n        numerator = np.dot(y[:-k], y[k:])\n        \n        # Sample autocorrelation at lag k\n        rho_k = numerator / sum_y_sq\n        \n        # Track the maximum absolute autocorrelation\n        if abs(rho_k) > max_abs_rho:\n            max_abs_rho = abs(rho_k)\n            \n    # --- Step 3: Pass/Fail Evaluation ---\n    # Compute the threshold for statistical significance\n    threshold = c / np.sqrt(N)\n    \n    # The test passes if the max absolute autocorrelation is below the threshold\n    return max_abs_rho <= threshold\n\n# Execute the main function\nsolve()\n```", "id": "2403579"}, {"introduction": "Can a number be \"perfectly random\" in one sense but completely predictable in another? This practice investigates this question using the Champernowne constant, a number famous for being \"normal\"—meaning it contains all finite digit patterns with their expected asymptotic frequency. You will use its digits as a PRNG and subject it to a battery of statistical tests, including tests for uniformity, serial pairs, and gap distribution [@problem_id:2429698]. This advanced exercise reveals the critical distinction between abstract mathematical properties like normality and the practical requirements of a good PRNG, showing how underlying structure can be exposed by the right statistical tools.", "problem": "You are asked to design and evaluate a deterministic Pseudo-Random Number Generator (PRNG) for digit sequences based on a transcendental, base-$10$ normal number: the Champernowne constant in base $10$, denoted $C_{10}$, defined by concatenating the decimal representations of the positive integers in order to form $C_{10} = 0.123456789101112\\ldots$. The goal is to implement a program that generates digits from this source and applies standard statistical tests of randomness to assess which tests are passed or failed at a fixed significance level. Your implementation must be a complete, runnable program that produces the specified output without any user input.\n\nUse the following fundamental base:\n- Deterministic digit streams derived from mathematically defined constants are computable and reproducible.\n- A number is normal in base $b$ if, in the limit, all digit blocks of any fixed length occur with limiting frequency $b^{-k}$. Normality implies asymptotic uniformity of blocks but not independence in any finite prefix.\n- Good quality pseudo-randomness for independent and identically distributed (i.i.d.) base-$10$ digits would entail both uniform marginal distributions and approximate independence across positions, which can be probed using classical hypothesis tests.\n\nConstruct the PRNG as follows:\n- Implement a generator that produces the first $N$ base-$10$ digits of $C_{10}$ after skipping a given starting index $s \\ge 0$. Concretely, concatenate the strings of the positive integers, and then extract the subsequence of length $N$ starting at digit index $s$ (where the first digit after the decimal point has index $s=0$). Convert these characters to integers in $\\{0,1,\\ldots,9\\}$.\n\nApply the following tests to the generated digit stream $\\{X_i\\}_{i=1}^N$ with $X_i \\in \\{0,1,\\ldots,9\\}$:\n- Uniformity (base-$10$) chi-squared test: Test the null hypothesis that each digit has probability $1/10$. Compute the chi-squared statistic comparing observed counts of digits to the expected count $N/10$ in each of the $10$ categories, and obtain the $p$-value using the chi-squared distribution with $9$ degrees of freedom.\n- Serial pair chi-squared test: Form the $(N-1)$ overlapping adjacent pairs $(X_i, X_{i+1})$, map them to $100$ categories in $\\{00,01,\\ldots,99\\}$, and test against the null hypothesis that all ordered pairs have probability $1/100$. Compute the chi-squared statistic against the expected count $(N-1)/100$ in each of the $100$ categories with $99$ degrees of freedom to obtain the $p$-value.\n- Geometric gap test for a fixed target digit: Fix the target digit $d=0$ and record the gap lengths $G$ defined as the number of nonzero digits between consecutive occurrences of $0$. Under the null hypothesis that digits are i.i.d. with $\\mathbb{P}(X=0) = 1/10$, the distribution of $G$ is geometric with parameter $p=1/10$, i.e., $\\mathbb{P}(G=g) = (1-p)^g p$ for $g \\in \\{0,1,2,\\ldots\\}$. Construct a categorical chi-squared test with categories $g=0,1,\\ldots,g_{\\max}-1$ and a tail category $g \\ge g_{\\max}$, using the exact geometric probabilities and a total of $(\\text{number of observed gaps})$ trials. Use $g_{\\max}=10$, which yields $11$ categories and $10$ degrees of freedom.\n\nFor all tests, use the same significance level $\\alpha = 0.01$. Report a test as “pass” if its $p$-value is greater than or equal to $\\alpha$, and “fail” otherwise.\n\nTest suite and required parameters:\n- Use exactly the following three parameter sets for $(N, s, g_{\\max}, \\alpha)$:\n    - Case $1$: $N=200000$, $s=0$, $g_{\\max}=10$, $\\alpha=0.01$.\n    - Case $2$: $N=200000$, $s=9$, $g_{\\max}=10$, $\\alpha=0.01$.\n    - Case $3$: $N=50000$, $s=0$, $g_{\\max}=10$, $\\alpha=0.01$.\nThese cases cover a general large-sample case, a boundary-shifted large-sample case (starting immediately before the two-digit block begins), and a smaller-sample edge case.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, append in order the following $6$ values:\n    - the uniformity-test $p$-value (a float),\n    - the uniformity-test pass/fail as a boolean,\n    - the serial-pair-test $p$-value (a float),\n    - the serial-pair-test pass/fail as a boolean,\n    - the gap-test $p$-value (a float),\n    - the gap-test pass/fail as a boolean.\nThus the final line must contain $18$ entries corresponding to the three cases, for example:\n\"[p1,True,p2,False,p3,True,p4,True,p5,True,p6,False,p7,True,p8,True,p9,True]\".\nAll numerical quantities must be printed as decimals without a percentage sign. No physical units or angles are involved in this problem.\n\nYour program must be fully self-contained, deterministic, require no user input, and conform to the specified execution environment. The output must be solely the specified single line.", "solution": "The problem as stated is subjected to rigorous validation and is found to be scientifically grounded, well-posed, objective, and computationally feasible. All necessary parameters and definitions for the generation of a digit sequence from the Champernowne constant $C_{10}$ and for the subsequent statistical analysis are provided. The problem is a valid exercise in computational statistics and number theory. We may therefore proceed with a complete solution.\n\nThe objective is to design a pseudo-random number generator (PRNG) that sources its digits from the Champernowne constant $C_{10}$ and to evaluate its quality using a standard suite of statistical tests. We will first describe the method for generating the digit stream and then detail the statistical tests used for its evaluation.\n\n**1. Generation of the Digit Stream**\n\nThe source of randomness is the base-$10$ Champernowne constant, $C_{10}$, which is constructed by concatenating the decimal representations of the positive integers in sequence:\n$$\nC_{10} = 0.123456789101112131415161718192021\\ldots\n$$\nThis number is known to be transcendental and, more importantly for this application, normal in base $10$. Normality in base $b$ implies that any block of $k$ digits appears with a limiting frequency of $b^{-k}$, which is a desirable asymptotic property for a random sequence. However, finite prefixes of this sequence are highly structured and non-random, a fact that the statistical tests are expected to reveal.\n\nThe generation algorithm is as follows:\n- To obtain a sequence of $N$ digits starting at a zero-based index $s$, we must first generate a string representation of $C_{10}$'s fractional part of sufficient length.\n- We achieve this by iteratively concatenating the string forms of the integers $k=1, 2, 3, \\ldots$ until the total length of the resulting string is at least $s+N$.\n- The required sequence of digits is then extracted as the substring of length $N$ starting at index $s$.\n- Finally, each character in this substring is converted into its corresponding integer value in the set $\\{0, 1, \\ldots, 9\\}$, yielding the sequence $\\{X_i\\}_{i=1}^N$ for testing.\n\n**2. Statistical Tests of Randomness**\n\nWe apply three standard hypothesis tests to the generated sequence $\\{X_i\\}_{i=1}^N$. For all tests, the significance level is fixed at $\\alpha = 0.01$. A test is \"passed\" if the calculated $p$-value is greater than or equal to $\\alpha$, and \"failed\" otherwise.\n\n**2.1. Uniformity Chi-Squared Test**\nThis test, also known as a goodness-of-fit test, assesses whether the digits in the sequence are uniformly distributed.\n- **Null Hypothesis ($H_0$)**: Each digit $d \\in \\{0, 1, \\ldots, 9\\}$ occurs with equal probability, $\\mathbb{P}(X_i = d) = 1/10$.\n- **Test Statistic**: The Pearson chi-squared statistic is computed as:\n$$\n\\chi^2 = \\sum_{d=0}^{9} \\frac{(O_d - E_d)^2}{E_d}\n$$\nwhere $O_d$ is the observed count of digit $d$ in the sequence of length $N$, and $E_d = N/10$ is the expected count for each digit under $H_0$.\n- **Distribution**: Under the null hypothesis, this statistic follows a chi-squared distribution with $k-1 = 10-1 = 9$ degrees of freedom. The $p$-value is the probability of observing a statistic at least as extreme as the one computed, i.e., $p = \\mathbb{P}(\\chi^2_9 \\ge \\chi^2_{\\text{obs}})$.\n\n**2.2. Serial Pair Chi-Squared Test**\nThis test checks for independence between adjacent digits by examining the distribution of pairs.\n- **Null Hypothesis ($H_0$)**: All $100$ possible ordered pairs of digits $(d_1, d_2)$ are uniformly distributed, i.e., $\\mathbb{P}((X_i, X_{i+1}) = (d_1, d_2)) = 1/100$.\n- **Test Procedure**: We form the $N-1$ overlapping pairs $(X_1, X_2), (X_2, X_3), \\ldots, (X_{N-1}, X_N)$ from the sequence. These pairs are mapped to $100$ categories (e.g., from $0$ to $99$ via the mapping $(d_1, d_2) \\to 10d_1 + d_2$).\n- **Test Statistic**: The chi-squared statistic is calculated over these $100$ categories:\n$$\n\\chi^2 = \\sum_{j=0}^{99} \\frac{(O_j - E_j)^2}{E_j}\n$$\nwhere $O_j$ is the observed count of the $j$-th pair and $E_j = (N-1)/100$ is the expected count.\n- **Distribution**: Under $H_0$, this statistic follows a chi-squared distribution with $k-1 = 100-1 = 99$ degrees of freedom. The $p$-value is computed accordingly.\n\n**2.3. Geometric Gap Test**\nThis test investigates the lengths of runs of digits that are not equal to a specific target digit. We use the target digit $d=0$.\n- **Null Hypothesis ($H_0$)**: The digits are independent and identically distributed (i.i.d.) with $\\mathbb{P}(X_i=0) = p = 1/10$. This implies that the length $G$ of a \"gap\" (the number of non-zero digits between consecutive zeros) follows a geometric distribution: $\\mathbb{P}(G=g) = (1-p)^g p$ for $g \\in \\{0, 1, 2, \\ldots\\}$.\n- **Test Procedure**: We identify all consecutive occurrences of the digit $0$ and measure the number of non-zero digits between them. These observed gap lengths are categorized into $g_{\\max}+1$ bins: $g=0, 1, \\ldots, g_{\\max}-1$, and a final bin for all gaps of length $g \\ge g_{\\max}$. For this problem, $g_{\\max} = 10$, resulting in $11$ categories.\n- **Test Statistic**: Let $M$ be the total number of observed gaps. The expected probability for a gap length $g$ is $P_g = (0.9)^g(0.1)$, and for the tail category ($g \\ge 10$) it is $$P_{\\ge 10} = \\sum_{j=10}^{\\infty} (0.9)^j(0.1) = (0.9)^{10}.$$ The expected count for each category is $E_g = M \\cdot P_g$. The chi-squared statistic is:\n$$\n\\chi^2 = \\sum_{g=0}^{10} \\frac{(O_g - E_g)^2}{E_g}\n$$\nwhere $O_g$ is the observed count for each category.\n- **Distribution**: Since the parameter $p=1/10$ is specified by the hypothesis and not estimated from the data, the statistic follows a chi-squared distribution with $k-1 = 11-1 = 10$ degrees of freedom.\n\nThe implementation will proceed by first generating the required digit sequences for each of the three test cases, then applying each of the three statistical tests, and finally collating the results into the specified output format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef generate_c10_digits(N, s):\n    \"\"\"\n    Generates N digits of the Champernowne constant C_10 starting from index s.\n    \"\"\"\n    required_length = s + N\n    c10_parts = []\n    current_length = 0\n    i = 1\n    while current_length < required_length:\n        s_i = str(i)\n        c10_parts.append(s_i)\n        current_length += len(s_i)\n        i += 1\n    \n    c10_string = \"\".join(c10_parts)\n    digit_string = c10_string[s:s + N]\n    \n    return np.array([int(d) for d in digit_string], dtype=np.int64)\n\ndef uniformity_test(digits, alpha):\n    \"\"\"\n    Performs a chi-squared test for uniform distribution of base-10 digits.\n    \"\"\"\n    N = len(digits)\n    if N == 0:\n        return 1.0, True # Undefined test, pass by convention\n        \n    observed_counts = np.bincount(digits, minlength=10)\n    expected_count = N / 10.0\n    \n    # Avoid division by zero if N=0 (handled above), but good practice\n    if expected_count == 0:\n        return 1.0, True\n\n    chi2_stat = np.sum((observed_counts - expected_count)**2 / expected_count)\n    df = 9\n    p_value = chi2.sf(chi2_stat, df)\n    \n    return p_value, p_value >= alpha\n\ndef serial_pair_test(digits, alpha):\n    \"\"\"\n    Performs a chi-squared test for uniform distribution of adjacent pairs.\n    \"\"\"\n    N = len(digits)\n    if N < 2:\n        return 1.0, True # Undefined test\n        \n    pairs = digits[:-1] * 10 + digits[1:]\n    num_pairs = N - 1\n    \n    observed_counts = np.bincount(pairs, minlength=100)\n    expected_count = num_pairs / 100.0\n\n    if expected_count == 0:\n        return 1.0, True\n        \n    chi2_stat = np.sum((observed_counts - expected_count)**2 / expected_count)\n    df = 99\n    p_value = chi2.sf(chi2_stat, df)\n    \n    return p_value, p_value >= alpha\n\ndef geometric_gap_test(digits, alpha, g_max):\n    \"\"\"\n    Performs a chi-squared test for the geometric distribution of gaps between zeros.\n    \"\"\"\n    target_digit = 0\n    zero_indices = np.where(digits == target_digit)[0]\n    \n    if len(zero_indices) < 2:\n        return 1.0, True # Undefined test, not enough gaps\n        \n    gaps = np.diff(zero_indices) - 1\n    num_gaps = len(gaps)\n\n    # Bin observed gaps into categories 0, 1, ..., g_max-1 and >=g_max\n    observed_counts = np.zeros(g_max + 1, dtype=np.int64)\n    binned_gaps = np.bincount(gaps)\n    len_binned = len(binned_gaps)\n    \n    limit = min(g_max, len_binned)\n    observed_counts[:limit] = binned_gaps[:limit]\n    if len_binned > g_max:\n        observed_counts[g_max] = np.sum(binned_gaps[g_max:])\n\n    # Calculate expected counts based on geometric distribution\n    p = 0.1  # Probability of target digit\n    q = 1.0 - p\n    \n    expected_probs = np.zeros(g_max + 1)\n    for g in range(g_max):\n        expected_probs[g] = (q**g) * p\n    expected_probs[g_max] = q**g_max # P(G >= g_max)\n    \n    expected_counts = expected_probs * num_gaps\n    \n    # Filter out categories with zero expected counts to avoid division by zero\n    # This shouldn't happen with geometric distribution but is robust practice\n    valid_indices = expected_counts > 0\n    if np.sum(valid_indices) < 2: # Not enough categories for a meaningful test\n         return 1.0, True\n         \n    chi2_stat = np.sum((observed_counts[valid_indices] - expected_counts[valid_indices])**2 / expected_counts[valid_indices])\n    \n    df = g_max  # k-1 = (g_max+1) - 1\n    p_value = chi2.sf(chi2_stat, df)\n    \n    return p_value, p_value >= alpha\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (N, s, g_max, alpha)\n        (200000, 0, 10, 0.01),\n        (200000, 9, 10, 0.01),\n        (50000, 0, 10, 0.01),\n    ]\n\n    results = []\n    for N, s, g_max, alpha in test_cases:\n        digits = generate_c10_digits(N, s)\n        \n        # Uniformity Test\n        p_uniform, pass_uniform = uniformity_test(digits, alpha)\n        results.extend([p_uniform, pass_uniform])\n        \n        # Serial Pair Test\n        p_serial, pass_serial = serial_pair_test(digits, alpha)\n        results.extend([p_serial, pass_serial])\n        \n        # Geometric Gap Test\n        p_gap, pass_gap = geometric_gap_test(digits, alpha, g_max)\n        results.extend([p_gap, pass_gap])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2429698"}]}