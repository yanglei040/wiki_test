{"hands_on_practices": [{"introduction": "In many scientific and engineering applications, linear systems derived from real-world measurements are often ill-conditioned, meaning small errors in the data can lead to large, non-physical errors in the solution. This practice explores Tikhonov regularization, a fundamental technique for stabilizing such problems by introducing a controlled amount of bias. You will investigate the trade-off between fidelity to the original equations, measured by the residual, and the stability of the solution, controlled by the regularization parameter $\\alpha$. [@problem_id:2432713]", "problem": "You are given a family of linear systems of the form $A\\mathbf{x}=\\mathbf{b}$ with matrices $A$ that are nearly singular or rank-deficient. Consider the Tikhonov-regularized problem defined by the objective function\n$$\nJ(\\mathbf{x})=\\lVert A\\mathbf{x}-\\mathbf{b}\\rVert_2^2+\\alpha^2\\lVert \\mathbf{x}\\rVert_2^2,\n$$\nwhere $\\alpha0$ is the regularization parameter. The stationarity condition of this objective yields the regularized normal equations\n$$\n\\left(A^{\\top}A+\\alpha^2 I\\right)\\mathbf{x}=A^{\\top}\\mathbf{b}.\n$$\nYour task is to compute, for each specified test case, the unique Tikhonov solution $\\mathbf{x}_\\alpha$ that satisfies the above system and analyze the residual of the original, unregularized system. For each test case, you must compute the following quantities:\n- The original residual two-norm $r_{\\mathrm{norm}}=\\lVert A\\mathbf{x}_\\alpha-\\mathbf{b}\\rVert_2$.\n- The relative original residual two-norm $r_{\\mathrm{rel}}=\\dfrac{\\lVert A\\mathbf{x}_\\alpha-\\mathbf{b}\\rVert_2}{\\lVert \\mathbf{b}\\rVert_2}$.\n- The two-norm of the regularized normal equation residual $q_{\\mathrm{norm}}=\\left\\lVert\\left(A^{\\top}A+\\alpha^2 I\\right)\\mathbf{x}_\\alpha-A^{\\top}\\mathbf{b}\\right\\rVert_2$.\n\nUse the exact matrices, vectors, and parameters listed below. In each case, $I$ denotes the identity matrix of size matching the number of columns of $A$. All quantities are unitless.\n\nTest suite:\n- Case $1$ (square, nearly singular):\n  - $A_1=\\begin{bmatrix}\n  1  1  1\\\\\n  1  1  1+10^{-8}\\\\\n  1  1+10^{-8}  1\n  \\end{bmatrix}$,\n  $\\mathbf{x}_{\\mathrm{true},1}=\\begin{bmatrix}1\\\\-1\\\\1\\end{bmatrix}$,\n  $\\boldsymbol{\\eta}_1=\\begin{bmatrix}10^{-10}\\\\-10^{-10}\\\\10^{-10}\\end{bmatrix}$,\n  $\\mathbf{b}_1=A_1\\mathbf{x}_{\\mathrm{true},1}+\\boldsymbol{\\eta}_1$,\n  $\\alpha_1=10^{-2}$.\n- Case $2$ (same $A_1$ and $\\mathbf{b}_1$ as Case $1$, weaker regularization):\n  - $\\alpha_2=10^{-6}$.\n- Case $3$ (square, rank-deficient):\n  - $A_3=\\begin{bmatrix}\n  1  2  3\\\\\n  2  4  6\\\\\n  3  6  9\n  \\end{bmatrix}$,\n  $\\mathbf{x}_{\\mathrm{true},3}=\\begin{bmatrix}1\\\\0\\\\0\\end{bmatrix}$,\n  $\\boldsymbol{\\eta}_3=\\begin{bmatrix}10^{-3}\\\\-10^{-3}\\\\2\\cdot 10^{-3}\\end{bmatrix}$,\n  $\\mathbf{b}_3=A_3\\mathbf{x}_{\\mathrm{true},3}+\\boldsymbol{\\eta}_3$,\n  $\\alpha_3=10^{-1}$.\n- Case $4$ (overdetermined, ill-conditioned, Hilbert-type):\n  - $A_4=\\begin{bmatrix}\n  1  \\tfrac{1}{2}  \\tfrac{1}{3}\\\\\n  \\tfrac{1}{2}  \\tfrac{1}{3}  \\tfrac{1}{4}\\\\\n  \\tfrac{1}{3}  \\tfrac{1}{4}  \\tfrac{1}{5}\\\\\n  \\tfrac{1}{4}  \\tfrac{1}{5}  \\tfrac{1}{6}\n  \\end{bmatrix}$,\n  $\\mathbf{x}_{\\mathrm{true},4}=\\begin{bmatrix}1\\\\0\\\\-1\\end{bmatrix}$,\n  $\\boldsymbol{\\eta}_4=\\begin{bmatrix}10^{-6}\\\\-10^{-6}\\\\10^{-6}\\\\-10^{-6}\\end{bmatrix}$,\n  $\\mathbf{b}_4=A_4\\mathbf{x}_{\\mathrm{true},4}+\\boldsymbol{\\eta}_4$,\n  $\\alpha_4=10^{-3}$.\n\nFor each case $k\\in\\{1,2,3,4\\}$, compute $\\mathbf{x}_{\\alpha_k}$ from $\\left(A_k^{\\top}A_k+\\alpha_k^2 I\\right)\\mathbf{x}=A_k^{\\top}\\mathbf{b}_k$ and then compute $r_{\\mathrm{norm}}$, $r_{\\mathrm{rel}}$, and $q_{\\mathrm{norm}}$ defined above.\n\nFinal output format:\n- Your program should produce a single line of output containing a list of length $4$, where the $k$-th element is a list of length $3$ with the values $[r_{\\mathrm{norm}},r_{\\mathrm{rel}},q_{\\mathrm{norm}}]$ for case $k$, in this order. The list must be enclosed in square brackets with comma separators, and contain floating-point numbers. The values may appear in decimal or scientific notation as produced by the programming language. No additional text should be printed.", "solution": "The problem requires the solution of ill-posed linear systems using Tikhonov regularization and the analysis of the resulting residuals. The problem is scientifically sound, well-posed, and all necessary data are provided. We proceed with the solution.\n\nThe fundamental issue with a linear system $A\\mathbf{x}=\\mathbf{b}$ where the matrix $A$ is singular or ill-conditioned (i.e., has a large condition number) is that the solution $\\mathbf{x}$ is extremely sensitive to perturbations in the right-hand side vector $\\mathbf{b}$. Such problems are common in science and engineering, particularly in inverse problems where $\\mathbf{b}$ represents measured data containing noise.\n\nTikhonov regularization addresses this by finding an approximate solution $\\mathbf{x}_\\alpha$ that minimizes a modified objective function:\n$$\nJ(\\mathbf{x})=\\lVert A\\mathbf{x}-\\mathbf{b}\\rVert_2^2+\\alpha^2\\lVert \\mathbf{x}\\rVert_2^2\n$$\nHere, the first term, $\\lVert A\\mathbf{x}-\\mathbf{b}\\rVert_2^2$, is the squared norm of the residual, which measures the fidelity of the solution to the data. The second term, $\\alpha^2\\lVert \\mathbf{x}\\rVert_2^2$, is the regularization term, which penalizes solutions with a large Euclidean norm. The regularization parameter $\\alpha  0$ controls the trade-off: a larger $\\alpha$ emphasizes solution stability (smaller norm) at the cost of data fidelity, while a smaller $\\alpha$ prioritizes fitting the data, which may lead to an unstable solution that heavily incorporates noise.\n\nTo find the vector $\\mathbf{x}_\\alpha$ that minimizes $J(\\mathbf{x})$, we must find where the gradient of $J(\\mathbf{x})$ with respect to $\\mathbf{x}$ is the zero vector. The objective function can be written in matrix form as:\n$$\nJ(\\mathbf{x}) = (A\\mathbf{x}-\\mathbf{b})^{\\top}(A\\mathbf{x}-\\mathbf{b}) + \\alpha^2 \\mathbf{x}^{\\top}\\mathbf{x} = \\mathbf{x}^{\\top}A^{\\top}A\\mathbf{x} - 2\\mathbf{b}^{\\top}A\\mathbf{x} + \\mathbf{b}^{\\top}\\mathbf{b} + \\alpha^2 \\mathbf{x}^{\\top}\\mathbf{x}\n$$\nThe gradient with respect to $\\mathbf{x}$ is:\n$$\n\\nabla_{\\mathbf{x}} J(\\mathbf{x}) = 2A^{\\top}A\\mathbf{x} - 2A^{\\top}\\mathbf{b} + 2\\alpha^2\\mathbf{x}\n$$\nSetting $\\nabla_{\\mathbf{x}} J(\\mathbf{x}) = \\mathbf{0}$ yields the aformentioned regularized normal equations:\n$$\n\\left(A^{\\top}A+\\alpha^2 I\\right)\\mathbf{x}=A^{\\top}\\mathbf{b}\n$$\nThe matrix $A^{\\top}A$ is always positive semi-definite. For any $\\alpha  0$, the matrix $C = A^{\\top}A+\\alpha^2 I$ is positive definite. This is because all its eigenvalues are strictly positive, guaranteeing that it is invertible and that a unique solution $\\mathbf{x}_\\alpha$ exists.\n\nThe computational procedure for each test case is as follows:\n$1$. Construct the matrix $A_k$ and vectors $\\mathbf{x}_{\\mathrm{true},k}$ and $\\boldsymbol{\\eta}_k$ as specified for case $k \\in \\{1, 2, 3, 4\\}$.\n$2$. Calculate the right-hand side vector $\\mathbf{b}_k = A_k\\mathbf{x}_{\\mathrm{true},k} + \\boldsymbol{\\eta}_k$.\n$3$. Form the matrix of the regularized system $C_k = A_k^{\\top}A_k + \\alpha_k^2 I$, where $I$ is the identity matrix with dimensions matching the number of columns of $A_k$.\n$4$. Form the right-hand side of the regularized system $\\mathbf{d}_k = A_k^{\\top}\\mathbf{b}_k$.\n$5$. Solve the well-posed linear system $C_k \\mathbf{x}_{\\alpha_k} = \\mathbf{d}_k$ to find the Tikhonov solution $\\mathbf{x}_{\\alpha_k}$.\n$6$. Compute the required analytical quantities:\n   a. The original residual two-norm: $r_{\\mathrm{norm}} = \\lVert A_k\\mathbf{x}_{\\alpha_k}-\\mathbf{b}_k\\rVert_2$. This measures how well the regularized solution satisfies the original, unregularized system.\n   b. The relative original residual two-norm: $r_{\\mathrm{rel}} = \\frac{\\lVert A_k\\mathbf{x}_{\\alpha_k}-\\mathbf{b}_k\\rVert_2}{\\lVert \\mathbf{b}_k\\rVert_2}$. This normalizes the residual by the magnitude of the data vector.\n   c. The two-norm of the regularized normal equation residual: $q_{\\mathrm{norm}} = \\lVert C_k\\mathbf{x}_{\\alpha_k} - \\mathbf{d}_k\\rVert_2$. This quantity serves as a numerical check on the accuracy of the linear solver used to find $\\mathbf{x}_{\\alpha_k}$. For an exact computation, it would be zero. In floating-point arithmetic, its value should be near machine precision, scaled by the condition number of $C_k$.\n\nThis procedure is implemented for each of the four specified test cases. The matrices $A_1$, $A_3$, and $A_4$ are chosen to be nearly singular, exactly singular (rank-deficient), and ill-conditioned, respectively, representing typical scenarios where regularization is required. The comparison between Case $1$ ($\\alpha_1 = 10^{-2}$) and Case $2$ ($\\alpha_2 = 10^{-6}$) is particularly instructive, as it demonstrates the effect of the regularization parameter's magnitude on the solution and its residuals.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Tikhonov-regularized solutions and associated residuals for a suite of\n    ill-posed linear systems.\n    \"\"\"\n\n    def process_case(A, b, alpha):\n        \"\"\"\n        Solves the Tikhonov regularized system and computes the required norms.\n\n        Args:\n            A (np.ndarray): The system matrix.\n            b (np.ndarray): The right-hand side vector.\n            alpha (float): The regularization parameter.\n\n        Returns:\n            list: A list containing [r_norm, r_rel, q_norm].\n        \"\"\"\n        num_cols = A.shape[1]\n        I = np.identity(num_cols)\n\n        # Form the regularized normal equations: (A.T @ A + alpha^2 * I) @ x = A.T @ b\n        C = A.T @ A + alpha**2 * I\n        d = A.T @ b\n\n        # Solve for the Tikhonov solution x_alpha\n        x_alpha = np.linalg.solve(C, d)\n\n        # 1. Compute the original residual two-norm: r_norm = ||A*x_alpha - b||_2\n        r_norm = np.linalg.norm(A @ x_alpha - b)\n\n        # 2. Compute the relative original residual two-norm: r_rel = ||A*x_alpha - b||_2 / ||b||_2\n        # np.linalg.norm(b) cannot be zero for the given problem settings.\n        r_rel = r_norm / np.linalg.norm(b)\n\n        # 3. Compute the two-norm of the regularized normal equation residual:\n        #    q_norm = ||(A.T*A + alpha^2*I)*x_alpha - A.T*b||_2\n        q_norm = np.linalg.norm(C @ x_alpha - d)\n\n        return [r_norm, r_rel, q_norm]\n\n    # --- Test Case 1 ---\n    eps1 = 1e-8\n    A1 = np.array([\n        [1.0, 1.0, 1.0],\n        [1.0, 1.0, 1.0 + eps1],\n        [1.0, 1.0 + eps1, 1.0]\n    ])\n    x_true1 = np.array([1.0, -1.0, 1.0])\n    eta1 = np.array([1e-10, -1e-10, 1e-10])\n    b1 = A1 @ x_true1 + eta1\n    alpha1 = 1e-2\n\n    # --- Test Case 2 ---\n    # A2 and b2 are the same as A1 and b1\n    alpha2 = 1e-6\n\n    # --- Test Case 3 ---\n    A3 = np.array([\n        [1.0, 2.0, 3.0],\n        [2.0, 4.0, 6.0],\n        [3.0, 6.0, 9.0]\n    ])\n    x_true3 = np.array([1.0, 0.0, 0.0])\n    eta3 = np.array([1e-3, -1e-3, 2e-3])\n    b3 = A3 @ x_true3 + eta3\n    alpha3 = 1e-1\n\n    # --- Test Case 4 ---\n    A4 = np.array([\n        [1.0, 1/2, 1/3],\n        [1/2, 1/3, 1/4],\n        [1/3, 1/4, 1/5],\n        [1/4, 1/5, 1/6]\n    ])\n    x_true4 = np.array([1.0, 0.0, -1.0])\n    eta4 = np.array([1e-6, -1e-6, 1e-6, -1e-6])\n    b4 = A4 @ x_true4 + eta4\n    alpha4 = 1e-3\n\n    test_cases = [\n        (A1, b1, alpha1),\n        (A1, b1, alpha2),\n        (A3, b3, alpha3),\n        (A4, b4, alpha4),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, b, alpha = case\n        result_metrics = process_case(A, b, alpha)\n        results.append(result_metrics)\n\n    # Format the final output as a string representation of a list of lists.\n    # e.g., [[val1, val2, val3],[val4, val5, val6],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2432713"}, {"introduction": "When developing complex simulation software, such as a finite element code, programming errors can be notoriously difficult to locate. This exercise demonstrates how the residual acts as a powerful diagnostic tool for code verification. By deliberately introducing a flaw into a single basis function, you will see how the error creates a distinct, localized signature in the residual field, providing a clear pointer to the source of the problem. [@problem_id:2432735]", "problem": "You are to write a complete, self-contained program that constructs and analyzes a one-dimensional finite element approximation for a prototypical elliptic boundary value problem and quantitatively reveals how a deliberately introduced defect in a single local basis function produces a non-physical pattern in the discrete residual field. Consider the following boundary value problem on the closed interval $[0,1]$:\nFind $u:[0,1] \\rightarrow \\mathbb{R}$ such that $-u''(x)=f(x)$ for $x \\in (0,1)$ and $u(0)=0$, $u(1)=0$, with $f(x)=1$.\n\nLet $N \\in \\mathbb{N}$ denote the number of uniform subintervals of $[0,1]$, with nodes $x_i = i h$, $h = 1/N$, $i=0,1,\\dots,N$. Let $\\{\\varphi_i\\}_{i=0}^N$ denote the standard piecewise-linear Lagrange basis functions associated with these nodes, and let $V_h$ be the associated trial and test space of functions that are continuous on $[0,1]$ and linear on each subinterval, with $u_h(0)=u_h(1)=0$. The standard Galerkin formulation asks for $u_h \\in V_h$ such that for all $v_h \\in V_h$,\n$$\n\\int_{0}^{1} u_h'(x)\\,v_h'(x)\\,dx = \\int_{0}^{1} f(x)\\,v_h(x)\\,dx.\n$$\n\nDefine a defective variant of this discrete problem by introducing a single-element basis-function bug as follows. Choose one element index $e^\\star \\in \\{0,1,\\dots,N-1\\}$. On that element only, namely on the subinterval $[x_{e^\\star}, x_{e^\\star+1}]$, replace the local basis function associated with the left endpoint by its negative: $\\tilde{\\varphi}_{e^\\star}|_{[x_{e^\\star}, x_{e^\\star+1}]} = -\\,\\varphi_{e^\\star}|_{[x_{e^\\star}, x_{e^\\star+1}]}$, while keeping the right local basis function unchanged: $\\tilde{\\varphi}_{e^\\star+1}|_{[x_{e^\\star}, x_{e^\\star+1}]} = \\varphi_{e^\\star+1}|_{[x_{e^\\star}, x_{e^\\star+1}]}$. Use these defective local basis functions for both the trial and test functions on that element. On all other elements, use the standard basis functions. Let $u_h^{\\mathrm{def}}$ denote the unique discrete solution obtained from this defective discrete system with homogeneous Dirichlet boundary conditions.\n\nDefine the true finite element residual vector $r \\in \\mathbb{R}^{N-1}$, indexed by the interior nodes $\\{1,2,\\dots,N-1\\}$, as the exact algebraic residual of the correct (non-defective) discrete operator applied to $u_h^{\\mathrm{def}}$,\n$$\nr_i \\;=\\; \\sum_{j=1}^{N-1} K^{\\mathrm{corr}}_{ij}\\, (u_h^{\\mathrm{def}})_j \\;-\\; F^{\\mathrm{corr}}_i,\\quad i=1,2,\\dots,N-1,\n$$\nwhere $K^{\\mathrm{corr}}$ and $F^{\\mathrm{corr}}$ are the stiffness matrix and load vector arising from the correct (non-defective) standard Galerkin formulation with $f(x)=1$ and homogeneous Dirichlet boundary conditions. The vector $u_h^{\\mathrm{def}}$ is the defective solution restricted to the interior degrees of freedom.\n\nFor a given pair $(N,e^\\star)$, compute the following two scalar diagnostics from $r$:\n1. The infinity norm of the residual,\n$$\n\\|r\\|_{\\infty} \\;=\\; \\max_{1 \\le i \\le N-1} |r_i|.\n$$\n2. The localization ratio\n$$\nL \\;=\\; \\frac{\\sum_{i \\in I_{\\mathrm{def}}} r_i^2}{\\sum_{i=1}^{N-1} r_i^2},\n$$\nwhere $I_{\\mathrm{def}}$ is the set of interior node indices lying on the defective element $[x_{e^\\star},x_{e^\\star+1}]$, that is, $I_{\\mathrm{def}} = \\{i \\in \\{1,\\dots,N-1\\} : i \\in \\{e^\\star, e^\\star+1\\}\\}$. In the special case of “no defect,” define $L=0$ by convention.\n\nTest Suite. Your program must evaluate the four parameter sets:\n- Case $1$: $N=8$, $e^\\star=4$.\n- Case $2$: $N=8$, $e^\\star=1$.\n- Case $3$: $N=32$, $e^\\star=16$.\n- Case $4$: $N=8$, no defect (use the correct basis on all elements).\n\nAnswer Specification. For each case, your program must compute and return the ordered pair $[\\|r\\|_{\\infty}, L]$ as real numbers. The final program output must be a single line containing a list of these four ordered pairs in case order, formatted as a comma-separated list enclosed in square brackets, for example,\n\"[[a,b],[c,d],[e,f],[g,h]]\",\nwhere $a,b,c,d,e,f,g,h$ are the floats for the respective cases. No physical units are involved. Angles do not appear. Percentages do not appear.", "solution": "The problem statement is submitted for validation.\n\nStep 1: Extract Givens\n- Differential Equation: $-u''(x)=f(x)$ for $x \\in (0,1)$.\n- Forcing Function: $f(x)=1$.\n- Boundary Conditions: $u(0)=0$, $u(1)=0$.\n- Discretization: $N$ uniform subintervals on $[0,1]$, nodes $x_i = i h$, $h = 1/N$, for $i=0,1,\\dots,N$.\n- Finite Element Space: $V_h$ is the space of continuous, piecewise-linear functions on $[0,1]$ that are zero at $x=0$ and $x=1$. Basis functions are the standard Lagrange basis functions $\\{\\varphi_i\\}_{i=1}^{N-1}$.\n- Standard Galerkin Formulation: Find $u_h \\in V_h$ such that $\\int_{0}^{1} u_h'(x)\\,v_h'(x)\\,dx = \\int_{0}^{1} f(x)\\,v_h(x)\\,dx$ for all $v_h \\in V_h$.\n- Defective Basis Function Definition: For a chosen element $e^\\star \\in \\{0,1,\\dots,N-1\\}$, on the subinterval $[x_{e^\\star}, x_{e^\\star+1}]$, the local basis function associated with the left endpoint $x_{e^\\star}$ is replaced by its negative: $\\tilde{\\varphi}_{e^\\star}|_{[x_{e^\\star}, x_{e^\\star+1}]} = -\\,\\varphi_{e^\\star}|_{[x_{e^\\star}, x_{e^\\star+1}]}$. The basis function for the right endpoint is unchanged. This defective basis is used for both trial and test functions on this element.\n- Defective Solution: $u_h^{\\mathrm{def}}$ is the solution of the Galerkin system constructed with the defect.\n- Residual Vector Definition: $r_i = \\sum_{j=1}^{N-1} K^{\\mathrm{corr}}_{ij}\\, (u_h^{\\mathrm{def}})_j - F^{\\mathrm{corr}}_i$ for $i=1,2,\\dots,N-1$, where $K^{\\mathrm{corr}}$ and $F^{\\mathrm{corr}}$ are the correct (non-defective) stiffness matrix and load vector, and $(u_h^{\\mathrm{def}})_j$ are the nodal values of the defective solution at the interior nodes.\n- Diagnostic 1: $\\|r\\|_{\\infty} = \\max_{1 \\le i \\le N-1} |r_i|$.\n- Diagnostic 2: $L = \\frac{\\sum_{i \\in I_{\\mathrm{def}}} r_i^2}{\\sum_{i=1}^{N-1} r_i^2}$, where $I_{\\mathrm{def}} = \\{i \\in \\{1,\\dots,N-1\\} : i \\in \\{e^\\star, e^\\star+1\\}\\}$. For the \"no defect\" case, $L=0$.\n- Test Suite:\n  - Case 1: $N=8$, $e^\\star=4$.\n  - Case 2: `N=8`, `e^\\star=1`.\n  - Case 3: `N=32`, `e^\\star=16`.\n  - Case 4: `N=8`, no defect.\n\nStep 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the standard and well-established Finite Element Method for a second-order elliptic boundary value problem (the Poisson equation). The concept of introducing a specific bug in a basis function to study its effect on the residual is a valid and instructive exercise in computational engineering and numerical analysis. It models a plausible programming error.\n- **Well-Posed**: The problem is well-posed. The standard Galerkin formulation for this equation results in a symmetric positive-definite stiffness matrix, guaranteeing a unique solution. The defective local stiffness matrix, upon assembly, results in a global defective stiffness matrix that is non-singular for the given cases, thus ensuring a unique defective solution $u_h^{\\mathrm{def}}$ exists. The residual and subsequent diagnostics are defined by explicit, deterministic formulas. All required information is provided.\n- **Objective**: The problem is formulated in precise mathematical language, free from ambiguity, subjectivity, or opinion.\n\nStep 3: Verdict and Action\nThe problem is valid. A rigorous solution can and must be constructed.\n\nThe task is to implement the finite element method for the given boundary value problem, both in its standard form and with a specified local defect, and then to analyze the resulting error. The analysis hinges on constructing the correct algebraic systems and evaluating the specified diagnostics.\n\nFirst, we establish the standard (correct) finite element formulation. The weak form is given as finding $u_h \\in V_h$ such that $a(u_h, v_h) = l(v_h)$ for all $v_h \\in V_h$, where the bilinear form is $a(u, v) = \\int_{0}^{1} u'(x)v'(x)dx$ and the linear functional is $l(v) = \\int_{0}^{1} f(x)v(x)dx$. The solution is expanded in the basis of interior nodes, $u_h(x) = \\sum_{j=1}^{N-1} U_j \\varphi_j(x)$, where $U_j$ are the unknown nodal values. This leads to the linear system $K^{\\mathrm{corr}} U = F^{\\mathrm{corr}}$, where the entries of the stiffness matrix and load vector are $K^{\\mathrm{corr}}_{ij} = a(\\varphi_j, \\varphi_i)$ and $F^{\\mathrm{corr}}_i = l(\\varphi_i)$.\n\nOn a generic element $[x_k, x_{k+1}]$ of length $h=1/N$, the two local basis functions, denoted $\\psi_1$ and $\\psi_2$, have derivatives $\\psi_1'(x) = -1/h$ and $\\psi_2'(x) = 1/h$. The correct element stiffness matrix $k^{\\mathrm{corr}}$ is:\n$$\nk^{\\mathrm{corr}}_{ij} = \\int_{x_k}^{x_{k+1}} \\psi_i'(x) \\psi_j'(x) dx = \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\nWith $f(x)=1$, the correct element load vector $f^{\\mathrm{corr}}$ is:\n$$\nf^{\\mathrm{corr}}_{i} = \\int_{x_k}^{x_{k+1}} 1 \\cdot \\psi_i(x) dx = \\frac{h}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\n$$\n\nNext, we formulate the defective system. The defect is introduced on a single element $e^\\star$, on the interval $[x_{e^\\star}, x_{e^\\star+1}]$. The local basis function for the left node, $\\varphi_{e^\\star}$, is replaced by its negative. Let us denote the standard local basis functions on this element as $\\psi_1$ (for the left node) and $\\psi_2$ (for the right node). The standard derivatives are $\\psi_1'(x)=-1/h$ and $\\psi_2'(x)=1/h$. The defective basis functions become $\\tilde{\\psi}_1 = -\\psi_1$ and $\\tilde{\\psi}_2 = \\psi_2$. Their derivatives are $\\tilde{\\psi}_1'(x) = -(-1/h) = 1/h$ and $\\tilde{\\psi}_2'(x) = 1/h$.\nThe defective element stiffness matrix $k^{\\mathrm{def}}$ is computed using these modified derivatives:\n$$\nk^{\\mathrm{def}}_{ij} = \\int_{x_{e^\\star}}^{x_{e^\\star+1}} \\tilde{\\psi}_i'(x) \\tilde{\\psi}_j'(x) dx = \\int_{x_{e^\\star}}^{x_{e^\\star+1}} \\frac{1}{h^2} dx = \\frac{1}{h} \\begin{pmatrix} 1  1 \\\\ 1  1 \\end{pmatrix}\n$$\nThe defective element load vector $f^{\\mathrm{def}}$ is computed using the modified basis functions:\n$$\nf^{\\mathrm{def}}_{1} = \\int_{x_{e^\\star}}^{x_{e^\\star+1}} 1 \\cdot \\tilde{\\psi}_1(x) dx = \\int 1 \\cdot (-\\psi_1(x)) dx = -\\frac{h}{2}\n$$\n$$\nf^{\\mathrm{def}}_{2} = \\int_{x_{e^\\star}}^{x_{e^\\star+1}} 1 \\cdot \\tilde{\\psi}_2(x) dx = \\int 1 \\cdot \\psi_2(x) dx = \\frac{h}{2}\n$$\nSo, $f^{\\mathrm{def}} = \\frac{h}{2} \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}$.\n\nTo find the defective solution $u_h^{\\mathrm{def}}$, we assemble the global defective system $K^{\\mathrm{def}}U^{\\mathrm{def}} = F^{\\mathrm{def}}$. This is done by summing the contributions from all elements, using $k^{\\mathrm{corr}}$ and $f^{\\mathrm{corr}}$ for all elements $e \\neq e^\\star$, and using $k^{\\mathrm{def}}$ and $f^{\\mathrm{def}}$ for element $e=e^\\star$. The resulting $(N-1) \\times (N-1)$ linear system is solved for the vector of interior nodal values $U^{\\mathrm{def}}$.\n\nThe core of the analysis is the computation of the true residual vector $r$. It is defined as what remains when the defective solution $U^{\\mathrm{def}}$ is inserted into the *correct* system of equations: $r = K^{\\mathrm{corr}} U^{\\mathrm{def}} - F^{\\mathrm{corr}}$. An important insight is that the residual $r$ will be non-zero only at the nodes belonging to the defective element, i.e., nodes $e^\\star$ and $e^\\star+1$. This is because for any row $i$ not corresponding to these nodes, the $i$-th equation of the defective system is identical to the $i$-th equation of the correct system, and thus $(K^{\\mathrm{corr}}U^{\\mathrm{def}})_i - F^{\\mathrm{corr}}_i = (K^{\\mathrm{def}}U^{\\mathrm{def}})_i - F^{\\mathrm{def}}_i = 0$.\n\nFinally, we compute the two diagnostics from the residual vector $r$.\n$1$. The infinity norm, $\\|r\\|_{\\infty}$, is the maximum absolute value of the components of $r$.\n$2$. The localization ratio, $L$. Given the insight that $r_i$ is non-zero only for $i \\in I_{\\mathrm{def}} = \\{e^\\star, e^\\star+1\\} \\cap \\{1, ..., N-1\\}$, the sum in the numerator of $L$, $\\sum_{i \\in I_{\\mathrm{def}}} r_i^2$, will be equal to the sum in the denominator, $\\sum_{i=1}^{N-1} r_i^2$. Therefore, for any defective case, $L$ must be exactly $1$. For the non-defective case, $U^{\\mathrm{def}}$ is the true solution $U^{\\mathrm{corr}}$, so $r = K^{\\mathrm{corr}}U^{\\mathrm{corr}} - F^{\\mathrm{corr}}$ is theoretically the zero vector. Due to floating-point arithmetic, its norm will be a small number close to machine precision. By the problem's convention, we set $L=0$ for this case.\n\nThe implementation will follow these steps:\n$1$. For each test case $(N, e^\\star)$, define $h=1/N$.\n$2$. Construct and assemble the global defective matrices $K^{\\mathrm{def}}$ and $F^{\\mathrm{def}}$.\n$3$. Solve the system $K^{\\mathrm{def}}U^{\\mathrm{def}} = F^{\\mathrm{def}}$ for $U^{\\mathrm{def}}$.\n$4$. Construct the global correct matrices $K^{\\mathrm{corr}}$ and $F^{\\mathrm{corr}}$.\n$5$. Compute the residual vector $r = K^{\\mathrm{corr}} U^{\\mathrm{def}} - F^{\\mathrm{corr}}$.\n$6$. Compute $\\|r\\|_{\\infty}$ and $L$ from $r$. Special handling for the no-defect case sets $L=0$.\n$7$. Store and format the results as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble(N, h, k_elem, f_elem, apply_bc=True):\n    \"\"\"\n    Assembles the global stiffness matrix and load vector.\n    \n    Args:\n        N (int): Number of subintervals.\n        h (float): Element size.\n        k_elem (np.ndarray): 2x2 element stiffness matrix.\n        f_elem (np.ndarray): 2x1 element load vector.\n        apply_bc (bool): If True, assemble for interior nodes only.\n    \n    Returns:\n        (np.ndarray, np.ndarray): Global stiffness matrix and load vector.\n    \"\"\"\n    if apply_bc:\n        num_dofs = N - 1\n        K = np.zeros((num_dofs, num_dofs))\n        F = np.zeros(num_dofs)\n        \n        for e in range(N):\n            # Global node indices for element e\n            g_idx = [e, e + 1]\n            \n            for i_loc in range(2):\n                for j_loc in range(2):\n                    g_i, g_j = g_idx[i_loc], g_idx[j_loc]\n                    # Check if both nodes are interior\n                    if 1 = g_i = N - 1 and 1 = g_j = N - 1:\n                        # Map global node index to matrix index\n                        m_i, m_j = g_i - 1, g_j - 1\n                        K[m_i, m_j] += k_elem[i_loc, j_loc]\n                \n                # Assemble load vector (once per row)\n                g_i = g_idx[i_loc]\n                if 1 = g_i = N - 1:\n                    m_i = g_i - 1\n                    F[m_i] += f_elem[i_loc]\n    else: # Not used in this problem, but for completeness\n        num_dofs = N + 1\n        K = np.zeros((num_dofs, num_dofs))\n        F = np.zeros(num_dofs)\n        for e in range(N):\n            g_idx = [e, e + 1]\n            K[np.ix_(g_idx, g_idx)] += k_elem\n            F[g_idx] += f_elem\n            \n    return K, F\n\ndef solve_case(N, e_star):\n    \"\"\"\n    Solves one case of the FEM problem with an optional defect.\n\n    Args:\n        N (int): Number of subintervals.\n        e_star (int or None): Index of the defective element. If None, no defect.\n\n    Returns:\n        list: A list containing [||r||_infinity, L].\n    \"\"\"\n    h = 1.0 / N\n    dof = N - 1\n\n    # Define correct element matrices\n    k_corr = (1.0 / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n    f_corr = (h / 2.0) * np.array([1.0, 1.0])\n\n    # Define defective element matrices\n    k_def = (1.0 / h) * np.array([[1.0, 1.0], [1.0, 1.0]])\n    f_def = (h / 2.0) * np.array([-1.0, 1.0])\n\n    # 1. Assemble the defective system (K_def, F_def)\n    K_def_glob = np.zeros((dof, dof))\n    F_def_glob = np.zeros(dof)\n\n    for e in range(N):\n        is_defective_element = (e_star is not None and e == e_star)\n        k_e = k_def if is_defective_element else k_corr\n        f_e = f_def if is_defective_element else f_corr\n        \n        g_nodes = [e, e + 1]\n        for i_loc in range(2):\n            g_i = g_nodes[i_loc]\n            if 1 = g_i = N - 1:\n                m_i = g_i - 1\n                F_def_glob[m_i] += f_e[i_loc]\n                for j_loc in range(2):\n                    g_j = g_nodes[j_loc]\n                    if 1 = g_j = N - 1:\n                        m_j = g_j - 1\n                        K_def_glob[m_i, m_j] += k_e[i_loc, j_loc]\n\n    # 2. Solve for the defective solution U_def\n    U_def = np.linalg.solve(K_def_glob, F_def_glob)\n\n    # 3. Assemble the correct system (K_corr, F_corr)\n    # The correct global matrix is tridiagonal\n    K_corr_glob = np.zeros((dof, dof))\n    F_corr_glob = np.zeros(dof)\n    main_diag = 2.0 / h\n    off_diag = -1.0 / h\n    np.fill_diagonal(K_corr_glob, main_diag)\n    np.fill_diagonal(K_corr_glob[1:], off_diag)\n    np.fill_diagonal(K_corr_glob[:, 1:], off_diag)\n    # The correct load vector is constant h\n    F_corr_glob.fill(h)\n\n    # 4. Compute the residual r = K_corr * U_def - F_corr\n    r = K_corr_glob @ U_def - F_corr_glob\n\n    # 5. Compute diagnostics\n    # ||r||_infinity\n    r_inf_norm = np.linalg.norm(r, ord=np.inf)\n\n    # Localization ratio L\n    if e_star is None:\n        # Per problem specification for \"no defect\" case\n        L = 0.0\n    else:\n        # Identify interior node indices on the defective element\n        # Problem indices are 1-based, numpy are 0-based\n        num_indices = []\n        # Node e_star is interior if 1 = e_star = N-1\n        if 1 = e_star = N - 1:\n            num_indices.append(e_star - 1)\n        # Node e_star+1 is interior if 1 = e_star+1 = N-1\n        if 1 = e_star + 1 = N - 1:\n            num_indices.append(e_star)\n        \n        if not num_indices:\n             # This can happen if defect is on boundary element e.g. e_star=0 with N1\n             # and we only consider node e_star+1.\n            if 1 = e_star+1 = N-1: \n                num_indices.append(e_star)\n            else: # should not be reached with problem constraints\n                L = 0.0\n\n        num_sum_sq = np.sum(r[num_indices]**2)\n        den_sum_sq = np.sum(r**2)\n        \n        if den_sum_sq  1e-15: # Avoid division by zero\n            L = 0.0\n        else:\n            L = num_sum_sq / den_sum_sq\n\n    return [r_inf_norm, L]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'N': 8, 'e_star': 4},         # Case 1\n        {'N': 8, 'e_star': 1},         # Case 2\n        {'N': 32, 'e_star': 16},       # Case 3\n        {'N': 8, 'e_star': None},      # Case 4 (no defect)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case['N'], case['e_star'])\n        results.append(result)\n\n    # Format the final output string exactly as specified\n    formatted_pairs = [f\"[{item[0]},{item[1]}]\" for item in results]\n    final_string = f\"[{','.join(formatted_pairs)}]\"\n    print(final_string)\n\nsolve()\n```", "id": "2432735"}, {"introduction": "Beyond simply identifying errors, residual analysis can provide rigorous, quantitative bounds on the accuracy of a computed result. This advanced practice delves into the realm of computational quantum mechanics, where we often seek the energy levels (eigenvalues) of a system. You will use the residual of an approximate wavefunction for the quantum harmonic oscillator, in conjunction with the Temple-Kato inequality, to calculate a strict upper bound on the error in the ground state energy, showcasing a sophisticated application of verification theory. [@problem_id:2432718]", "problem": "Consider the time-independent Schrödinger equation for the one-dimensional quantum harmonic oscillator in nondimensional units where $\\hbar = 1$, mass $m = 1$, and angular frequency $\\omega = 1$. The Hamiltonian operator is\n$$\nH = -\\frac{1}{2}\\frac{d^{2}}{dx^{2}} + \\frac{1}{2} x^{2}\n$$\nacting on square-integrable functions over $\\mathbb{R}$ with the standard $L^{2}(\\mathbb{R})$ inner product.\n\nA numerical solver proposes the following normalized approximation to the ground-state wavefunction:\n$$\n\\psi(x) = \\left(\\frac{\\beta}{\\pi}\\right)^{1/4} \\exp\\!\\left(-\\frac{\\beta x^{2}}{2}\\right),\n$$\nwith $\\beta = \\frac{5}{4}$. Let $\\tilde{E}$ be the Rayleigh quotient $\\tilde{E} = \\langle \\psi, H \\psi \\rangle$, and define the residual\n$$\nr(x) = H\\psi(x) - \\tilde{E}\\,\\psi(x),\n$$\nwith $L^{2}$-norm $\\|r\\| = \\left(\\int_{-\\infty}^{\\infty} |r(x)|^{2}\\,dx\\right)^{1/2}$.\n\nIt is known that the first excited energy level of this Hamiltonian is exactly $E_{1} = \\frac{3}{2}$. Using residual analysis and the given spectral information to verify the solution and estimate the ground-state energy error, determine a rigorous upper bound for the energy error $\\tilde{E} - E_{0}$ based on $\\|r\\|$ and $E_{1}$.\n\nReport the numerical value of this upper bound as a pure number (nondimensional) rounded to four significant figures. Your final answer must be a single number.", "solution": "The problem statement is subjected to validation and is found to be scientifically grounded, well-posed, and objective. It presents a standard exercise in the verification of numerical solutions to eigenvalue problems in quantum mechanics, specifically using residual analysis. All provided data and definitions are consistent with established principles of quantum mechanics and numerical analysis. The problem is valid. We shall proceed with a rigorous solution.\n\nThe objective is to find a rigorous upper bound for the energy error $\\tilde{E} - E_{0}$, where $E_{0}$ is the true ground-state energy, $\\tilde{E}$ is the Rayleigh quotient of an approximate wavefunction $\\psi(x)$, and $E_{1}$ is the energy of the first excited state. The appropriate theoretical tool for this task is the Temple-Kato inequality, which, under the condition that $\\tilde{E}  E_1$, provides the bound:\n$$\n\\tilde{E} - E_{0} \\le \\frac{\\|r\\|^2}{E_1 - \\tilde{E}}\n$$\nHere, $\\|r\\|$ is the $L^2$-norm of the residual $r(x) = H\\psi(x) - \\tilde{E}\\psi(x)$. The solution methodology is therefore to compute the quantities $\\tilde{E}$ and $\\|r\\|^2$ for the given trial function $\\psi(x)$ and parameter $\\beta$, then substitute them into this inequality.\n\nThe Hamiltonian is $H = -\\frac{1}{2}\\frac{d^2}{dx^2} + \\frac{1}{2}x^2$. The proposed normalized trial wavefunction is $\\psi(x) = C \\exp(-\\frac{\\beta x^2}{2})$ with $C = (\\frac{\\beta}{\\pi})^{1/4}$ and $\\beta = \\frac{5}{4}$.\n\nFirst, we apply the Hamiltonian to the trial wavefunction. We require the second derivative of $\\psi(x)$:\n$$\n\\frac{d\\psi}{dx} = C \\exp\\left(-\\frac{\\beta x^2}{2}\\right) (-\\beta x) = -\\beta x \\psi(x)\n$$\n$$\n\\frac{d^2\\psi}{dx^2} = \\frac{d}{dx}(-\\beta x \\psi(x)) = -\\beta \\psi(x) - \\beta x \\frac{d\\psi}{dx} = -\\beta \\psi(x) - \\beta x(-\\beta x \\psi(x)) = (-\\beta + \\beta^2 x^2)\\psi(x)\n$$\nNow, we apply the Hamiltonian operator $H$:\n$$\nH\\psi(x) = -\\frac{1}{2}\\frac{d^2\\psi}{dx^2} + \\frac{1}{2}x^2\\psi(x) = -\\frac{1}{2}(-\\beta + \\beta^2 x^2)\\psi(x) + \\frac{1}{2}x^2\\psi(x)\n$$\n$$\nH\\psi(x) = \\left(\\frac{\\beta}{2} - \\frac{\\beta^2}{2}x^2 + \\frac{1}{2}x^2\\right)\\psi(x) = \\left(\\frac{\\beta}{2} + \\frac{1-\\beta^2}{2}x^2\\right)\\psi(x)\n$$\nNext, we compute the Rayleigh quotient $\\tilde{E} = \\langle \\psi, H\\psi \\rangle = \\int_{-\\infty}^{\\infty} \\psi^*(x) H\\psi(x) dx$. Since $\\psi(x)$ is real, $\\psi^*(x) = \\psi(x)$.\n$$\n\\tilde{E} = \\int_{-\\infty}^{\\infty} \\psi(x) \\left(\\frac{\\beta}{2} + \\frac{1-\\beta^2}{2}x^2\\right) \\psi(x) dx = \\frac{\\beta}{2} \\int_{-\\infty}^{\\infty} |\\psi(x)|^2 dx + \\frac{1-\\beta^2}{2} \\int_{-\\infty}^{\\infty} x^2 |\\psi(x)|^2 dx\n$$\nThe trial function is normalized, so $\\int_{-\\infty}^{\\infty} |\\psi(x)|^2 dx = 1$. The second integral is the expectation value of $x^2$, denoted $\\langle x^2 \\rangle$. The probability density is $|\\psi(x)|^2 = (\\frac{\\beta}{\\pi})^{1/2} \\exp(-\\beta x^2)$, which is a Gaussian distribution with zero mean and variance $\\sigma^2 = \\frac{1}{2\\beta}$. Thus, $\\langle x^2 \\rangle = \\frac{1}{2\\beta}$.\nSubstituting this into the expression for $\\tilde{E}$:\n$$\n\\tilde{E} = \\frac{\\beta}{2} + \\frac{1-\\beta^2}{2} \\left(\\frac{1}{2\\beta}\\right) = \\frac{2\\beta^2 + 1 - \\beta^2}{4\\beta} = \\frac{\\beta^2+1}{4\\beta}\n$$\nWith the given value $\\beta = \\frac{5}{4}$, we find:\n$$\n\\tilde{E} = \\frac{\\left(\\frac{5}{4}\\right)^2 + 1}{4\\left(\\frac{5}{4}\\right)} = \\frac{\\frac{25}{16} + \\frac{16}{16}}{5} = \\frac{\\frac{41}{16}}{5} = \\frac{41}{80}\n$$\nNow we must compute the squared norm of the residual, $\\|r\\|^2$. The residual is $r(x) = H\\psi(x) - \\tilde{E}\\psi(x)$.\n$$\nr(x) = \\left(\\frac{\\beta}{2} + \\frac{1-\\beta^2}{2}x^2\\right)\\psi(x) - \\left(\\frac{\\beta^2+1}{4\\beta}\\right)\\psi(x)\n$$\n$$\nr(x) = \\left( \\left[\\frac{\\beta}{2} - \\frac{\\beta^2+1}{4\\beta}\\right] + \\frac{1-\\beta^2}{2}x^2 \\right)\\psi(x) = \\left( \\frac{2\\beta^2 - (\\beta^2+1)}{4\\beta} + \\frac{1-\\beta^2}{2}x^2 \\right)\\psi(x)\n$$\n$$\nr(x) = \\left( \\frac{\\beta^2-1}{4\\beta} + \\frac{1-\\beta^2}{2}x^2 \\right)\\psi(x) = \\frac{1-\\beta^2}{2} \\left( x^2 - \\frac{1}{2\\beta} \\right) \\psi(x)\n$$\nThe squared norm is $\\|r\\|^2 = \\int_{-\\infty}^{\\infty} |r(x)|^2 dx$:\n$$\n\\|r\\|^2 = \\left(\\frac{1-\\beta^2}{2}\\right)^2 \\int_{-\\infty}^{\\infty} \\left( x^2 - \\frac{1}{2\\beta} \\right)^2 |\\psi(x)|^2 dx\n$$\nThe integral represents the expectation value $\\langle (x^2 - \\langle x^2 \\rangle)^2 \\rangle$, which is the variance of the variable $x^2$. This is equal to $\\langle x^4 \\rangle - (\\langle x^2 \\rangle)^2$. We already have $\\langle x^2 \\rangle = \\frac{1}{2\\beta}$. We need $\\langle x^4 \\rangle$:\n$$\n\\langle x^4 \\rangle = \\int_{-\\infty}^{\\infty} x^4 |\\psi(x)|^2 dx = \\left(\\frac{\\beta}{\\pi}\\right)^{1/2} \\int_{-\\infty}^{\\infty} x^4 \\exp(-\\beta x^2) dx\n$$\nUsing the standard Gaussian integral result $\\int_{-\\infty}^{\\infty} x^{4} \\exp(-ax^2) dx = \\frac{3}{4a^2}\\sqrt{\\frac{\\pi}{a}}$, with $a=\\beta$, we find $\\langle x^4 \\rangle = \\frac{3}{4\\beta^2}$.\nThe variance of $x^2$ is then:\n$$\n\\langle x^4 \\rangle - (\\langle x^2 \\rangle)^2 = \\frac{3}{4\\beta^2} - \\left(\\frac{1}{2\\beta}\\right)^2 = \\frac{3}{4\\beta^2} - \\frac{1}{4\\beta^2} = \\frac{2}{4\\beta^2} = \\frac{1}{2\\beta^2}\n$$\nSubstituting this back into the expression for $\\|r\\|^2$:\n$$\n\\|r\\|^2 = \\left(\\frac{1-\\beta^2}{2}\\right)^2 \\left(\\frac{1}{2\\beta^2}\\right) = \\frac{(1-\\beta^2)^2}{8\\beta^2}\n$$\nWith $\\beta = \\frac{5}{4}$, we have $\\beta^2 = \\frac{25}{16}$, and $1-\\beta^2 = 1 - \\frac{25}{16} = -\\frac{9}{16}$.\n$$\n\\|r\\|^2 = \\frac{\\left(-\\frac{9}{16}\\right)^2}{8\\left(\\frac{25}{16}\\right)} = \\frac{\\frac{81}{256}}{\\frac{200}{16}} = \\frac{81}{256} \\cdot \\frac{16}{200} = \\frac{81}{16 \\cdot 200} = \\frac{81}{3200}\n$$\nWe now have all components for the Temple-Kato bound. First, we verify the condition $\\tilde{E}  E_1$.\n$\\tilde{E} = \\frac{41}{80} = 0.5125$. The given first excited energy is $E_1 = \\frac{3}{2} = 1.5$. Since $0.5125  1.5$, the inequality is applicable.\nThe upper bound is given by:\n$$\n\\text{Upper Bound} = \\frac{\\|r\\|^2}{E_1 - \\tilde{E}} = \\frac{\\frac{81}{3200}}{\\frac{3}{2} - \\frac{41}{80}} = \\frac{\\frac{81}{3200}}{\\frac{120}{80} - \\frac{41}{80}} = \\frac{\\frac{81}{3200}}{\\frac{79}{80}}\n$$\n$$\n\\text{Upper Bound} = \\frac{81}{3200} \\cdot \\frac{80}{79} = \\frac{81}{40 \\cdot 79} = \\frac{81}{3160}\n$$\nFinally, we compute the numerical value and round to four significant figures as requested:\n$$\n\\frac{81}{3160} \\approx 0.02563291 \\dots\n$$\nRounding to four significant figures gives $0.02563$. This value is the rigorous upper bound for the energy error $\\tilde{E} - E_0$.", "answer": "$$\n\\boxed{0.02563}\n$$", "id": "2432718"}]}