{"hands_on_practices": [{"introduction": "We begin our practical journey with one of the most fundamental tools in digital signal processing: the moving average filter. This exercise challenges you to derive its recursive form, a key optimization for real-time systems, and its transfer function, which unlocks its behavior in the frequency domain. Mastering this filter provides a solid foundation for understanding more complex filter structures and the crucial link between time-domain operations and frequency-domain characteristics [@problem_id:2436705].", "problem": "A causal length-$M$ moving average filter, also known as a rectangular or boxcar smoother, is defined on a discrete-time input $x[n]$ by the output\n$$\ny[n] \\triangleq \\frac{1}{M} \\sum_{k=0}^{M-1} x[n-k],\n$$\nfor an integer $M \\geq 2$. Assume $x[n]=0$ and $y[n]=0$ for all $n  0$. Starting solely from this definition, derive a one-step recursion to compute $y[n]$ using only $y[n-1]$, $x[n]$, and $x[n-M]$. Then, using the definition of the bilateral $z$-transform (ZT), determine the transfer function $H(z) \\triangleq \\frac{Y(z)}{X(z)}$ of this filter in closed form. Express your final answer as a single simplified rational function of $z^{-1}$. No numerical rounding is required, and no physical units are involved. Provide only the final symbolic expression for $H(z)$ as your answer.", "solution": "The problem statement is parsed and validated. It is found to be self-contained, scientifically sound, and well-posed. It presents a standard exercise in digital signal processing theory. We proceed with the derivation.\n\nThe problem requires a two-part derivation based on the definition of a causal length-$M$ moving average filter:\n$$\ny[n] \\triangleq \\frac{1}{M} \\sum_{k=0}^{M-1} x[n-k]\n$$\nwhere $M$ is an integer such that $M \\geq 2$.\n\nFirst, we will derive the one-step recursive formula for $y[n]$.\nThe definition of the output at time step $n$ is given as:\n$$\ny[n] = \\frac{1}{M} \\left( x[n] + x[n-1] + \\dots + x[n-M+1] \\right)\n$$\nWe write the expression for the output at the previous time step, $n-1$:\n$$\ny[n-1] = \\frac{1}{M} \\sum_{k=0}^{M-1} x[n-1-k]\n$$\nExpanding this sum gives:\n$$\ny[n-1] = \\frac{1}{M} \\left( x[n-1] + x[n-2] + \\dots + x[n-1-(M-1)] \\right)\n$$\n$$\ny[n-1] = \\frac{1}{M} \\left( x[n-1] + x[n-2] + \\dots + x[n-M] \\right)\n$$\nTo find a relationship between $y[n]$ and $y[n-1]$, we rearrange the expression for $y[n]$ by isolating the newest sample, $x[n]$:\n$$\nM \\cdot y[n] = x[n] + \\sum_{k=1}^{M-1} x[n-k]\n$$\nNow, we rearrange the expression for $y[n-1]$ to isolate the sum that appears in the equation for $y[n]$. Let us perform a change of index $j = k+1$ in the definition of $y[n-1]$:\n$$\nM \\cdot y[n-1] = \\sum_{k=0}^{M-1} x[n-1-k] = \\sum_{j=1}^{M} x[n-j]\n$$\nThis sum can be written as:\n$$\nM \\cdot y[n-1] = \\left( \\sum_{j=1}^{M-1} x[n-j] \\right) + x[n-M]\n$$\nFrom this, we can express the sum $\\sum_{j=1}^{M-1} x[n-j]$ in terms of $y[n-1]$ and $x[n-M]$:\n$$\n\\sum_{j=1}^{M-1} x[n-j] = M \\cdot y[n-1] - x[n-M]\n$$\nThe summation index is a dummy variable, so $\\sum_{k=1}^{M-1} x[n-k] = \\sum_{j=1}^{M-1} x[n-j]$. We substitute this expression back into the equation for $M \\cdot y[n]$:\n$$\nM \\cdot y[n] = x[n] + (M \\cdot y[n-1] - x[n-M])\n$$\nDividing by $M$ yields the desired one-step recursive formula:\n$$\ny[n] = y[n-1] + \\frac{1}{M} \\left( x[n] - x[n-M] \\right)\n$$\nThis form is computationally efficient as it requires only two additions and one multiplication per output sample, regardless of the filter length $M$.\n\nSecond, we determine the transfer function $H(z) = \\frac{Y(z)}{X(z)}$ using the definition of the bilateral $z$-transform. The transfer function is the $z$-transform of the filter's impulse response, $h[n]$. The impulse response is the output of the filter when the input is the discrete-time unit impulse signal, $x[n] = \\delta[n]$.\nSubstituting $x[n]=\\delta[n]$ into the filter definition gives $h[n]$:\n$$\nh[n] = \\frac{1}{M} \\sum_{k=0}^{M-1} \\delta[n-k]\n$$\nThe term $\\delta[n-k]$ is equal to $1$ only when $n-k=0$, i.e., when $k=n$. It is zero otherwise. The summation is over $k$ from $0$ to $M-1$. Therefore, for a given $n$, the sum is non-zero only if $n$ is in the range $[0, M-1]$. If $n$ is in this range, exactly one term in the sum (where $k=n$) is non-zero and equal to $1$.\nThus, the impulse response is:\n$$\nh[n] = \\begin{cases} \\frac{1}{M}  \\text{for } 0 \\le n \\le M-1 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\nNow, we apply the definition of the bilateral $z$-transform to $h[n]$ to find $H(z)$:\n$$\nH(z) = \\sum_{n=-\\infty}^{\\infty} h[n] z^{-n}\n$$\nSubstituting the expression for $h[n]$ restricts the summation range:\n$$\nH(z) = \\sum_{n=0}^{M-1} \\left(\\frac{1}{M}\\right) z^{-n} = \\frac{1}{M} \\sum_{n=0}^{M-1} z^{-n}\n$$\nThe summation is a finite geometric series of the form $\\sum_{n=0}^{N-1} r^n$, with $N=M$ terms and a common ratio $r = z^{-1}$. The sum of such a series is given by the formula $\\frac{1-r^N}{1-r}$.\nApplying this formula, we get:\n$$\n\\sum_{n=0}^{M-1} (z^{-1})^n = \\frac{1 - (z^{-1})^M}{1 - z^{-1}} = \\frac{1 - z^{-M}}{1 - z^{-1}}\n$$\nSubstituting this result back into the expression for $H(z)$, we obtain the transfer function in its final, simplified form as a rational function of $z^{-1}$:\n$$\nH(z) = \\frac{1}{M} \\frac{1 - z^{-M}}{1 - z^{-1}}\n$$\nThis expression represents the system's behavior in the $z$-domain.", "answer": "$$\n\\boxed{\\frac{1}{M} \\frac{1 - z^{-M}}{1 - z^{-1}}}\n$$", "id": "2436705"}, {"introduction": "With the fundamentals in place, let's apply spectral analysis to a common and intuitive task: cleaning up a noisy audio signal. This practice involves transforming a signal into the frequency domain, identifying and removing unwanted noise components, and transforming it back to produce a cleaner result. This exercise [@problem_id:2383381] demonstrates the power of the Fourier transform as a practical tool for signal separation and enhancement.", "problem": "Let a discrete-time signal be defined on a uniform sampling grid of $N$ samples with sampling frequency $F_s$ (in Hz). The grid is $t_n = \\dfrac{n}{F_s}$ for $n \\in \\{0,1,\\dots,N-1\\}$, with all angles in radians. Consider a clean musical note modeled as a single sinusoid $s_n = \\sin(2\\pi f_0 t_n)$ of unit amplitude and frequency $f_0$ (in Hz). The observed signal is the sum of the clean note and a deterministic additive noise composed of two sinusoids:\n$$\nx_n = s_n + 0.15\\,\\sin(2\\pi \\cdot 1000\\, t_n) + 0.10\\,\\sin(2\\pi \\cdot 3000\\, t_n).\n$$\nFor a sequence $\\{x_n\\}_{n=0}^{N-1}$, define the Discrete Fourier Transform (DFT) and its inverse by\n$$\nX_k = \\sum_{n=0}^{N-1} x_n\\, e^{-i 2\\pi kn/N},\\quad k=0,1,\\dots,N-1,\n$$\n$$\n\\widehat{x}_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k\\, e^{i 2\\pi kn/N},\\quad n=0,1,\\dots,N-1.\n$$\nFor a given threshold fraction $\\tau \\in [0,1]$, define a filtered spectrum by zeroing all coefficients whose magnitude is below $\\tau$ times the maximum spectral magnitude:\n$$\nM = \\max_{0 \\le k \\le N-1} |X_k|,\\qquad\nY_k = \\begin{cases}\nX_k, \\text{if } |X_k| \\ge \\tau M,\\\\\n0, \\text{otherwise.}\n\\end{cases}\n$$\nThe filtered time-domain signal is then given by\n$$\ny_n = \\frac{1}{N} \\sum_{k=0}^{N-1} Y_k\\, e^{i 2\\pi kn/N}.\n$$\nFor each test case, compute the root-mean-square error (RMSE) between the filtered signal and the clean signal,\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y_n - s_n\\right)^2},\n$$\nwhich is dimensionless.\n\nAngle arguments in all trigonometric functions must be in radians. Frequencies are in hertz. No other physical units are required for the outputs.\n\nTest suite:\n- Case $1$: $(F_s, N, f_0, \\tau) = (8192,\\ 1024,\\ 440,\\ 0.25)$.\n- Case $2$: $(F_s, N, f_0, \\tau) = (8192,\\ 1024,\\ 512,\\ 0.90)$.\n- Case $3$: $(F_s, N, f_0, \\tau) = (8192,\\ 1024,\\ 440,\\ 0.00)$.\n- Case $4$: $(F_s, N, f_0, \\tau) = (8192,\\ 1024,\\ 2048,\\ 0.75)$.\n\nYour program must:\n- Construct $s_n$ and $x_n$ exactly as defined above for each test case using the corresponding $F_s$, $N$, and $f_0$.\n- Compute the DFT $X_k$ of $x_n$, apply the spectral threshold rule parameterized by $\\tau$, compute the inverse transform to obtain $y_n$, and then compute the $\\mathrm{RMSE}$ relative to $s_n$.\n\nFinal output format:\n- Produce a single line of output containing the four $\\mathrm{RMSE}$ values corresponding to the cases above, rounded to exactly $6$ decimal places, as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4]$ where each $r_j$ has exactly $6$ digits after the decimal point.", "solution": "The problem requires transforming a noisy sinusoidal signal to the frequency domain, removing small-magnitude spectral components relative to the largest spectral magnitude, and transforming back to time domain to assess denoising performance through the root-mean-square error (RMSE) relative to the clean signal. This directly relies on the definitions of the Discrete Fourier Transform (DFT) and its inverse.\n\nStart from the fundamental definitions. For $N$ time samples $\\{x_n\\}_{n=0}^{N-1}$, the Discrete Fourier Transform (DFT) is\n$$\nX_k = \\sum_{n=0}^{N-1} x_n\\, e^{-i 2\\pi kn/N},\\quad k=0,1,\\dots,N-1,\n$$\nand its inverse is\n$$\n\\widehat{x}_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k\\, e^{i 2\\pi kn/N},\\quad n=0,1,\\dots,N-1.\n$$\nThe DFT is a linear change of basis from the time-domain sequence to its representation as a sum of discrete complex exponentials with frequencies $2\\pi k/N$. For real sequences, spectral components occur in conjugate-symmetric pairs, but the general form above holds in all cases.\n\nSignal model. The clean signal is $s_n = \\sin(2\\pi f_0 t_n)$ with unit amplitude and frequency $f_0$, sampled at $t_n = n/F_s$. The noise is deterministic and defined as the sum of two sinusoids:\n$$\nn_n = 0.15\\,\\sin(2\\pi \\cdot 1000\\, t_n) + 0.10\\,\\sin(2\\pi \\cdot 3000\\, t_n).\n$$\nThe observed signal is $x_n = s_n + n_n$. Because $F_s = 8192$ and $N = 1024$, the frequency resolution is $\\Delta f = F_s/N = 8$. The chosen frequencies $f_0 \\in \\{440, 512, 2048\\}$ and the noise frequencies $1000$ and $3000$ are integer multiples of $\\Delta f$, which ensures that over $N$ samples each sinusoid completes an integer number of periods. This makes the corresponding DFT energy concentrate in exact bins and enforces orthogonality of distinct sinusoids over the finite sequence. In particular, in Case $3$ where $\\tau = 0$, no filtering is performed and the RMSE relative to the clean signal equals the root-mean-square of the noise:\n$$\n\\mathrm{RMSE}_{\\tau=0} = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} n_n^2} = \\sqrt{\\frac{(0.15)^2}{2} + \\frac{(0.10)^2}{2}},\n$$\nsince the sinusoids are orthogonal and the mean of $\\sin^2$ over an integer number of periods is $1/2$.\n\nFiltering rule. Given the spectrum $X_k$, define $M = \\max_k |X_k|$ and threshold by retaining only those spectral coefficients with $|X_k| \\ge \\tau M$. The filtered spectrum is\n$$\nY_k = \\begin{cases}\nX_k, |X_k| \\ge \\tau M,\\\\\n0, \\text{otherwise.}\n\\end{cases}\n$$\nThe filtered time-domain signal is obtained by inverse transformation:\n$$\ny_n = \\frac{1}{N} \\sum_{k=0}^{N-1} Y_k\\, e^{i 2\\pi kn/N}.\n$$\nThe denoising performance is quantified by the root-mean-square error\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} (y_n - s_n)^2}.\n$$\n\nEfficient computation. Direct evaluation of the DFT and its inverse from the definitions costs $\\mathcal{O}(N^2)$. For $N$ that is a power of two, the transform can be evaluated in $\\mathcal{O}(N \\log_2 N)$ by recursively dividing the sum into even and odd-indexed subsequences and combining them with twiddle factors $e^{-i 2\\pi k/N}$. This is the principle of the radix-$2$ divide-and-conquer approach. Let $x^{(e)}_m = x_{2m}$ and $x^{(o)}_m = x_{2m+1}$ for $m=0,\\dots,N/2-1$. Then\n$$\nX_k = E_k + W_N^k O_k,\\quad X_{k+N/2} = E_k - W_N^k O_k,\\quad k=0,\\dots,N/2-1,\n$$\nwhere $E_k$ and $O_k$ are the DFTs of the even and odd subsequences, and $W_N^k = e^{-i 2\\pi k/N}$. The inverse transform can be computed analogously or via conjugation and scaling:\n$$\n\\mathrm{iDFT}(X)_n = \\frac{1}{N} \\overline{\\mathrm{DFT}(\\overline{X})_n}.\n$$\n\nImplementation plan anchored in first principles:\n- For each test case, construct $t_n = n/F_s$, $s_n = \\sin(2\\pi f_0 t_n)$, $x_n = s_n + 0.15\\,\\sin(2\\pi \\cdot 1000\\, t_n) + 0.10\\,\\sin(2\\pi \\cdot 3000\\, t_n)$.\n- Compute $X_k$ using the radix-$2$ divide-and-conquer evaluation of the DFT for $N=1024$.\n- Compute $M = \\max_k |X_k|$ and define $Y_k$ by the threshold rule $|X_k| \\ge \\tau M$.\n- Compute $y_n$ via inverse transform and extract its real part (the imaginary part is numerical roundoff).\n- Compute $\\mathrm{RMSE}$ as defined.\n- Round each $\\mathrm{RMSE}$ to exactly $6$ decimal places and print the four results as a single list $[r_1,r_2,r_3,r_4]$.\n\nThis procedure yields a set of four floating-point values, one for each test case, quantifying how the threshold parameter $\\tau$ and the note frequency $f_0$ affect the denoising quality under the prescribed deterministic noise. The case with $\\tau = 0$ reproduces the unfiltered baseline, while larger $\\tau$ values suppress weaker spectral content and, for these signals with bin-aligned sinusoids, preserve the dominant note components more effectively.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef fft_radix2(x: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute the DFT of a 1-D complex array x using a radix-2 Cooleyâ€“Tukey algorithm.\n    Length of x must be a power of two.\n    \"\"\"\n    x = np.asarray(x, dtype=np.complex128)\n    N = x.shape[0]\n    if N == 1:\n        return x.copy()\n    if N % 2 != 0:\n        raise ValueError(\"Input length must be a power of two for radix-2 FFT.\")\n    # Recursively compute FFT of even and odd indexed elements\n    X_even = fft_radix2(x[::2])\n    X_odd = fft_radix2(x[1::2])\n    # Twiddle factors\n    k = np.arange(N // 2, dtype=np.float64)\n    twiddle = np.exp(-2j * np.pi * k / N)\n    top = X_even + twiddle * X_odd\n    bottom = X_even - twiddle * X_odd\n    return np.concatenate((top, bottom))\n\ndef ifft_radix2(X: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute the inverse DFT using the conjugate trick and the radix-2 FFT.\n    \"\"\"\n    X = np.asarray(X, dtype=np.complex128)\n    N = X.shape[0]\n    # iDFT(x) = conj(DFT(conj(x))) / N\n    return np.conjugate(fft_radix2(np.conjugate(X))) / N\n\ndef is_power_of_two(n: int) - bool:\n    return n  0 and (n  (n - 1)) == 0\n\ndef generate_signals(Fs: int, N: int, f0: float):\n    \"\"\"\n    Generate clean sinusoid s_n and observed x_n = s_n + deterministic noise.\n    Noise frequencies are 1000 Hz and 3000 Hz with amplitudes 0.15 and 0.10, respectively.\n    \"\"\"\n    if not is_power_of_two(N):\n        raise ValueError(\"N must be a power of two.\")\n    t = np.arange(N, dtype=np.float64) / float(Fs)\n    s = np.sin(2.0 * np.pi * f0 * t)\n    noise = 0.15 * np.sin(2.0 * np.pi * 1000.0 * t) + 0.10 * np.sin(2.0 * np.pi * 3000.0 * t)\n    x = s + noise\n    return s, x\n\ndef spectral_threshold_filter(x: np.ndarray, tau: float) - np.ndarray:\n    \"\"\"\n    Apply frequency-domain thresholding: zero coefficients below tau * max |X_k|.\n    Returns the filtered time-domain signal y (real-valued).\n    \"\"\"\n    X = fft_radix2(x.astype(np.complex128))\n    mags = np.abs(X)\n    M = mags.max() if X.size  0 else 0.0\n    threshold = tau * M\n    mask = mags = threshold\n    Y = X * mask\n    y = ifft_radix2(Y)\n    # Numerical residual imaginary part may appear due to finite precision.\n    return np.real(y)\n\ndef rmse(a: np.ndarray, b: np.ndarray) - float:\n    diff = a - b\n    return float(np.sqrt(np.mean(diff * diff)))\n\ndef solve():\n    # Define the test cases from the problem statement: (Fs, N, f0, tau)\n    test_cases = [\n        (8192, 1024, 440.0, 0.25),\n        (8192, 1024, 512.0, 0.90),\n        (8192, 1024, 440.0, 0.00),\n        (8192, 1024, 2048.0, 0.75),\n    ]\n\n    results = []\n    for Fs, N, f0, tau in test_cases:\n        s, x = generate_signals(Fs, N, f0)\n        y = spectral_threshold_filter(x, tau)\n        value = rmse(y, s)\n        results.append(f\"{value:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2383381"}, {"introduction": "While computing the full spectrum is powerful, it is not always the most efficient approach, especially when you are only interested in a single frequency. This exercise introduces a more targeted method for detecting the presence of a specific tone, a technique at the heart of applications like dual-tone multi-frequency (DTMF) decoding in telephony. By calculating the Discrete-Time Fourier Transform (DTFT) at just one frequency point [@problem_id:2436633], you will learn how to build computationally efficient spectral sensors.", "problem": "You are to write a complete, runnable program that, for a given set of discrete-time signals and parameters, decides whether a specified frequency component is present by comparing the squared magnitude of the discrete-time Fourier transform at a single angular frequency to a prescribed threshold. All reasoning must be based on first principles. Frequencies must be expressed in Hz, durations in seconds, and phases in radians. When random noise is involved, it must be zero-mean, white, Gaussian with the specified variance, and generated using a fixed seed $0$ to ensure determinism.\n\nFor each test case, you must:\n1. Synthesize a real-valued discrete-time signal $x[n]$ of length $N$ samples at sampling frequency $f_s$ Hz as the sum of a finite number of real sinusoids with given amplitudes, frequencies, and phases, plus additive noise with the specified variance.\n2. Let the target frequency be $f_t$ Hz and the corresponding angular frequency be $\\omega_t = 2\\pi f_t / f_s$ radians per sample.\n3. Compute the squared magnitude of the discrete-time Fourier transform of $x[n]$ evaluated at $\\omega_t$, namely the squared magnitude of the complex quantity that equals the transform at that single frequency.\n4. Compare this nonnegative real number to the given threshold $\\Theta$. Declare the frequency component present if and only if the computed value is strictly greater than $\\Theta$.\n\nYour program must process all the test cases below and output a single line containing a comma-separated list of boolean values enclosed in square brackets, in the same order as the test cases (for example, $[$True,False,True$]$).\n\nTest suite (all phases are $0$ radians unless otherwise stated):\n- Case A (happy path, exact match, integer cycles): $f_s = 8000$ Hz, $N = 800$, target frequency $f_t = 800$ Hz. Signal components: one cosine with amplitude $0.5$ at frequency $800$ Hz. Noise variance $0$. Threshold $\\Theta = 10000$.\n- Case B (absence case, orthogonal tone, integer cycles): $f_s = 8000$ Hz, $N = 800$, target frequency $f_t = 800$ Hz. Signal components: one cosine with amplitude $0.5$ at frequency $1000$ Hz. Noise variance $0$. Threshold $\\Theta = 10000$.\n- Case C (nearby frequency, short window, no noise): $f_s = 8000$ Hz, $N = 205$, target frequency $f_t = 697$ Hz. Signal components: one cosine with amplitude $0.5$ at frequency $700$ Hz. Noise variance $0$. Threshold $\\Theta = 2700$.\n- Case D (direct current component): $f_s = 4000$ Hz, $N = 400$, target frequency $f_t = 0$ Hz. Signal components: a constant offset of amplitude $0.3$. Noise variance $0$. Threshold $\\Theta = 3600$.\n- Case E (Nyquist frequency component): $f_s = 4000$ Hz, $N = 400$, target frequency $f_t = 2000$ Hz. Signal components: one cosine with amplitude $0.4$ at frequency $2000$ Hz. Noise variance $0$. Threshold $\\Theta = 6400$.\n- Case F (short window with noise, exact match, integer cycles): $f_s = 8000$ Hz, $N = 80$, target frequency $f_t = 1000$ Hz. Signal components: one cosine with amplitude $0.4$ at frequency $1000$ Hz. Noise variance $0.01$. Threshold $\\Theta = 128$.\n\nAngle unit for any phase is radians. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[$True,False,True$]$).", "solution": "This problem requires a decision on the presence of a specific frequency component in a discrete-time signal. The method is based upon a foundational tool of digital signal processing: the Discrete-Time Fourier Transform (DTFT). The procedure is to compute the squared magnitude of the DTFT at a single target frequency and compare this energy value to a given threshold. The problem is well-posed and scientifically sound, permitting a direct analytical and computational solution.\n\nWe begin by establishing the mathematical framework.\n\nA real-valued discrete-time signal, $x[n]$, defined for $n \\in \\{0, 1, \\dots, N-1\\}$, is synthesized as the sum of a deterministic signal, $s[n]$, and an additive noise component, $w[n]$.\n$$x[n] = s[n] + w[n]$$\nThe deterministic part, $s[n]$, is a superposition of $M$ sinusoidal components:\n$$s[n] = \\sum_{k=1}^{M} A_k \\cos(2\\pi \\frac{f_k}{f_s} n + \\phi_k) = \\sum_{k=1}^{M} A_k \\cos(\\omega_k n + \\phi_k)$$\nwhere $A_k$, $f_k$, and $\\phi_k$ are the amplitude, frequency (in Hz), and phase (in radians) of the $k$-th sinusoid, respectively. The sampling frequency is $f_s$ (in Hz), and $\\omega_k = 2\\pi f_k / f_s$ is the angular frequency (in radians per sample).\nThe noise, $w[n]$, is a zero-mean, white, Gaussian process with variance $\\sigma^2$, denoted as $w[n] \\sim \\mathcal{N}(0, \\sigma^2)$.\n\nThe Discrete-Time Fourier Transform of the signal $x[n]$ is a complex-valued function of frequency $\\omega$ given by:\n$$X(e^{j\\omega}) = \\sum_{n=0}^{N-1} x[n] e^{-j\\omega n}$$\nThis transform maps the $N$-point time-domain signal $x[n]$ to its frequency-domain representation. To test for the presence of a frequency component at a target frequency $f_t$ (or angular frequency $\\omega_t = 2\\pi f_t / f_s$), we evaluate the DTFT at $\\omega = \\omega_t$:\n$$X(e^{j\\omega_t}) = \\sum_{n=0}^{N-1} x[n] e^{-j\\omega_t n}$$\nThe squared magnitude of this complex number, $|X(e^{j\\omega_t})|^2$, represents the energy of the signal at the frequency $\\omega_t$. The decision rule is to declare the frequency component present if and only if this value is strictly greater than a specified threshold, $\\Theta$:\n$$\\text{Presence} \\iff |X(e^{j\\omega_t})|^2  \\Theta$$\n\nBy the linearity of the DTFT, we can write:\n$$X(e^{j\\omega_t}) = S(e^{j\\omega_t}) + W(e^{j\\omega_t})$$\nwhere $S(e^{j\\omega_t})$ and $W(e^{j\\omega_t})$ are the DTFTs of the signal and noise components, respectively. Each term can be analyzed. For a single sinusoidal component $s[n] = A \\cos(\\omega_0 n)$, the DTFT is:\n$$S(e^{j\\omega}) = \\frac{A}{2} \\left[ \\sum_{n=0}^{N-1} e^{j(\\omega_0 - \\omega)n} + \\sum_{n=0}^{N-1} e^{-j(\\omega_0 + \\omega)n} \\right]$$\nThe magnitude of this transform is sharply peaked at $\\omega = \\omega_0$ and $\\omega = -\\omega_0$. If the signal frequency $f_0$ and the number of samples $N$ are such that an integer number of cycles fit into the observation window (i.e., $f_0 \\cdot N/f_s = k$ for an integer $k$), then $f_0$ is a \"bin center\" of an $N$-point Discrete Fourier Transform (DFT). In this special case, if we test at $\\omega_t = \\omega_0$ (and $\\omega_0$ is not $0$ or $\\pi$), the magnitude is maximized, and $|S(e^{j\\omega_0})|^2 = (A N/2)^2$. If we test at another bin center $\\omega_t \\neq \\omega_0$, then due to the orthogonality of the DFT basis vectors, $S(e^{j\\omega_t}) = 0$. For frequencies not at bin centers, energy \"leaks\" into adjacent frequencies, a phenomenon known as spectral leakage.\n\nThe noise transform, $W(e^{j\\omega_t}) = \\sum_{n=0}^{N-1} w[n] e^{-j\\omega_t n}$, is a sum of scaled Gaussian random variables. Its expected value is $0$, and for a sufficiently large $N$, its properties are well-understood. However, for a single realization with a fixed seed, it is a deterministic complex number that adds to the signal's transform value.\n\nThe computational procedure for each test case is as follows:\n1. Define the time vector $n = [0, 1, \\dots, N-1]$.\n2. Synthesize the signal $s[n]$ by summing the given sinusoidal components according to their specified parameters.\n3. If the noise variance $\\sigma^2  0$, generate the noise vector $w[n]$ using a random number generator initialized with a seed of $0$. The standard deviation for the generator will be $\\sigma = \\sqrt{\\sigma^2}$.\n4. Form the final signal $x[n] = s[n] + w[n]$.\n5. Compute the target angular frequency $\\omega_t = 2\\pi f_t / f_s$.\n6. Calculate the complex DTFT value $X(e^{j\\omega_t})$ by performing the summation $\\sum_{n=0}^{N-1} x[n] e^{-j\\omega_t n}$.\n7. Compute its squared magnitude, $|X(e^{j\\omega_t})|^2 = (\\text{Re}\\{X(e^{j\\omega_t})\\})^2 + (\\text{Im}\\{X(e^{j\\omega_t})\\})^2$.\n8. Compare the result with the threshold $\\Theta$ to make the final boolean decision.\n\nThis procedure constitutes a complete algorithm for solving the problem. The implementation will follow these steps precisely for each provided test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the frequency component detection problem for a suite of test cases.\n    \"\"\"\n    \n    # Test cases defined as tuples:\n    # (f_s, N, f_t, components, noise_variance, threshold)\n    # where components is a list of (amplitude, frequency, phase) tuples.\n    test_cases = [\n        # Case A: happy path, exact match, integer cycles\n        (8000, 800, 800, [(0.5, 800, 0)], 0, 10000),\n        # Case B: absence case, orthogonal tone, integer cycles\n        (8000, 800, 800, [(0.5, 1000, 0)], 0, 10000),\n        # Case C: nearby frequency, short window, no noise\n        (8000, 205, 697, [(0.5, 700, 0)], 0, 2700),\n        # Case D: direct current component\n        (4000, 400, 0, [(0.3, 0, 0)], 0, 3600),\n        # Case E: Nyquist frequency component\n        (4000, 400, 2000, [(0.4, 2000, 0)], 0, 6400),\n        # Case F: short window with noise, exact match, integer cycles\n        (8000, 80, 1000, [(0.4, 1000, 0)], 0.01, 128)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        f_s, N, f_t, components, noise_var, threshold = case\n        \n        # 1. Synthesize the discrete-time signal x[n]\n        \n        # Time vector from n=0 to N-1\n        n = np.arange(N)\n        \n        # Initialize signal s[n] with zeros\n        s_n = np.zeros(N)\n        \n        # Add sinusoidal components\n        for amp, freq, phase in components:\n            # Angular frequency of the component: omega = 2*pi*f/f_s\n            omega_k = 2 * np.pi * freq / f_s\n            s_n += amp * np.cos(omega_k * n + phase)\n            \n        # Add additive white Gaussian noise (AWGN) if specified\n        if noise_var  0:\n            # Set the seed for reproducibility. It is reset for each case involving noise.\n            np.random.seed(0)\n            std_dev = np.sqrt(noise_var)\n            w_n = np.random.normal(0, std_dev, N)\n            x_n = s_n + w_n\n        else:\n            x_n = s_n\n            \n        # 2. Define the target angular frequency omega_t\n        omega_t = 2 * np.pi * f_t / f_s\n        \n        # 3. Compute the squared magnitude of the DTFT at omega_t\n        \n        # Complex exponential term for the DTFT calculation\n        # exp(-j * omega_t * n)\n        complex_exp = np.exp(-1j * omega_t * n)\n        \n        # DTFT value X(exp(j*omega_t)) = sum(x[n] * exp(-j*omega_t*n))\n        dtft_val = np.sum(x_n * complex_exp)\n        \n        # Squared magnitude\n        squared_magnitude = np.abs(dtft_val)**2\n        \n        # 4. Compare with the threshold and store the boolean result\n        is_present = squared_magnitude  threshold\n        results.append(is_present)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) converts boolean values True/False to strings \"True\"/\"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2436633"}]}