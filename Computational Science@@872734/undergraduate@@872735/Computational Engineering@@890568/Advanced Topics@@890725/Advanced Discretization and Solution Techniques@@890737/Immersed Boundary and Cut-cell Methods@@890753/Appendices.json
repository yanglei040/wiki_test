{"hands_on_practices": [{"introduction": "A key challenge in cut-cell methods is maintaining numerical accuracy at the irregularly shaped cells near the immersed boundary. While a finite-volume scheme might be second-order accurate on a uniform grid, its properties can change dramatically at a cut cell. This foundational exercise guides you through a theoretical analysis to reveal how the discretization error behaves at the interface between a regular cell and a small cut cell, a crucial first step in understanding and mitigating these errors [@problem_id:2401460].", "problem": "Consider the one-dimensional linear advection partial differential equation (PDE) in conservation form, $u_{t} + (a u)_{x} = 0$, with constant advection speed $a > 0$. Let the spatial mesh be predominantly uniform with cell size $h$, except for a single cut cell of length $\\alpha h$ with $\\alpha \\in (0,1)$ located to the right of a regular cell of length $h$. Denote the shared interface (face) between the regular cell and the cut cell by $x_{f}$. Let $\\bar{u}_{L}(t)$ be the exact cell average of $u(x,t)$ over the regular cell immediately to the left of $x_{f}$ (of length $h$), and let $\\bar{u}_{C}(t)$ be the exact cell average over the cut cell to the right of $x_{f}$ (of length $\\alpha h$). Consider the standard first-order upwind finite-volume semi-discretization (Godunov flux with piecewise-constant reconstruction equal to cell averages):\n$$\n\\frac{d \\bar{u}_{C}}{d t} = -\\frac{a}{\\alpha h}\\left(\\bar{u}_{C} - \\bar{u}_{L}\\right),\n$$\nwhich uses the numerical flux $F_{f} = a \\bar{u}_{L}$ at the face $x_{f}$ and $F_{C+1/2} = a \\bar{u}_{C}$ at the right face of the cut cell.\n\nDefine the local spatial truncation error at the cut cell as the residual obtained by inserting the exact solution into the discrete operator and subtracting the exact finite-volume balance, namely\n$$\n\\tau_{C} = \\left[-\\frac{a}{\\alpha h}\\left(u(x_{f}+\\alpha h,t) - u(x_{f},t)\\right)\\right] - \\left[-\\frac{a}{\\alpha h}\\left(\\bar{u}_{C}(t) - \\bar{u}_{L}(t)\\right)\\right].\n$$\nDerive, from first principles using Taylor series and the definition of cell averages, the leading-order term of $\\tau_{C}$ as $h \\to 0$ in terms of $a$, $\\alpha$, and spatial derivatives of $u$ evaluated at the face location $x_{f}$. Express your final answer as a single closed-form analytic expression for the leading-order truncation error term (omit big-$\\mathcal{O}$ notation), in terms of $a$, $\\alpha$, and $u_{x}(x_{f},t)$ only. No numerical approximation is required. The answer must be a single analytic expression without units.", "solution": "The problem requires the derivation of the leading-order term of the local spatial truncation error, $\\tau_C$, for a first-order upwind finite-volume scheme applied to the one-dimensional linear advection equation, $u_t + a u_x = 0$, on a mesh with a cut cell.\n\nFirst, we establish the necessary definitions and relationships. The exact time evolution of the cell average $\\bar{u}_C(t)$ over the cut cell $[x_f, x_f + \\alpha h]$ is found by integrating the PDE $u_t = -a u_x$ over this cell:\n$$\n\\int_{x_f}^{x_f + \\alpha h} u_t(x,t) \\,dx = -a \\int_{x_f}^{x_f + \\alpha h} u_x(x,t) \\,dx\n$$\nUsing the definitions $\\bar{u}_C(t) = \\frac{1}{\\alpha h} \\int_{x_f}^{x_f + \\alpha h} u(x,t) \\,dx$ and the fundamental theorem of calculus, we obtain:\n$$\n\\frac{d}{dt} (\\alpha h \\bar{u}_C(t)) = -a \\left[ u(x_f + \\alpha h, t) - u(x_f, t) \\right]\n$$\nThis gives the exact spatial operator part of the evolution equation for $\\bar{u}_C(t)$:\n$$\n\\left(\\frac{d\\bar{u}_C}{dt}\\right)_{\\text{exact}} = -\\frac{a}{\\alpha h} \\left[ u(x_f + \\alpha h, t) - u(x_f, t) \\right]\n$$\nThe problem provides the semi-discretization used by the numerical scheme:\n$$\n\\left(\\frac{d\\bar{u}_C}{dt}\\right)_{\\text{numerical}} = -\\frac{a}{\\alpha h} \\left( \\bar{u}_C(t) - \\bar{u}_L(t) \\right)\n$$\nThe local spatial truncation error $\\tau_C$ is defined in the problem statement as the difference between the exact spatial operator and the numerical spatial operator, when both are evaluated using the exact solution $u(x,t)$. Note that the problem's definition is $\\tau_C = (\\text{exact}) - (\\text{numerical})$, which is the negative of some conventions. We strictly follow the problem's definition:\n$$\n\\tau_C = \\left[-\\frac{a}{\\alpha h}\\left(u(x_{f}+\\alpha h,t) - u(x_{f},t)\\right)\\right] - \\left[-\\frac{a}{\\alpha h}\\left(\\bar{u}_{C}(t) - \\bar{u}_{L}(t)\\right)\\right]\n$$\nThis can be simplified to:\n$$\n\\tau_C = \\frac{a}{\\alpha h} \\left[ \\left( \\bar{u}_C(t) - \\bar{u}_L(t) \\right) - \\left( u(x_f + \\alpha h, t) - u(x_f, t) \\right) \\right]\n$$\nTo find the leading-order term of $\\tau_C$ as $h \\to 0$, we use Taylor series expansions of the solution $u(x,t)$ around the face location $x=x_f$, keeping time $t$ fixed. Let $u_f = u(x_f, t)$, $u_{x,f} = u_x(x_f, t)$, etc. The expansion is:\n$$\nu(x,t) = u_f + (x-x_f) u_{x,f} + \\frac{(x-x_f)^2}{2} u_{xx,f} + \\mathcal{O}((x-x_f)^3)\n$$\nWe now expand the terms in the expression for $\\tau_C$. First, we expand the exact cell averages $\\bar{u}_L(t)$ and $\\bar{u}_C(t)$.\nThe cell average over the regular cell to the left, $[x_f-h, x_f]$, is:\n$$\n\\bar{u}_L(t) = \\frac{1}{h} \\int_{x_f-h}^{x_f} u(x,t) \\,dx = \\frac{1}{h} \\int_{x_f-h}^{x_f} \\left( u_f + (x-x_f) u_{x,f} + \\frac{(x-x_f)^2}{2} u_{xx,f} + \\dots \\right) dx\n$$\n$$\n\\bar{u}_L(t) = \\frac{1}{h} \\left[ (x-x_f) u_f + \\frac{(x-x_f)^2}{2} u_{x,f} + \\frac{(x-x_f)^3}{6} u_{xx,f} + \\dots \\right]_{x_f-h}^{x_f}\n$$\n$$\n\\bar{u}_L(t) = \\frac{1}{h} \\left[ (0 - (-h))u_f + \\left(0 - \\frac{(-h)^2}{2}\\right)u_{x,f} + \\dots \\right] = u_f - \\frac{h}{2} u_{x,f} + \\mathcal{O}(h^2)\n$$\nThe cell average over the cut cell, $[x_f, x_f+\\alpha h]$, is:\n$$\n\\bar{u}_C(t) = \\frac{1}{\\alpha h} \\int_{x_f}^{x_f+\\alpha h} u(x,t) \\,dx = \\frac{1}{\\alpha h} \\int_{x_f}^{x_f+\\alpha h} \\left( u_f + (x-x_f) u_{x,f} + \\dots \\right) dx\n$$\n$$\n\\bar{u}_C(t) = \\frac{1}{\\alpha h} \\left[ (x-x_f) u_f + \\frac{(x-x_f)^2}{2} u_{x,f} + \\dots \\right]_{x_f}^{x_f+\\alpha h}\n$$\n$$\n\\bar{u}_C(t) = \\frac{1}{\\alpha h} \\left[ (\\alpha h) u_f + \\frac{(\\alpha h)^2}{2} u_{x,f} + \\dots \\right] = u_f + \\frac{\\alpha h}{2} u_{x,f} + \\mathcal{O}(h^2)\n$$\nThe difference of the cell averages is:\n$$\n\\bar{u}_C(t) - \\bar{u}_L(t) = \\left( u_f + \\frac{\\alpha h}{2} u_{x,f} \\right) - \\left( u_f - \\frac{h}{2} u_{x,f} \\right) + \\mathcal{O}(h^2) = \\frac{h}{2}(1+\\alpha) u_{x,f} + \\mathcal{O}(h^2)\n$$\nNext, we expand the term involving point values of the exact solution:\n$$\nu(x_f+\\alpha h, t) - u(x_f, t) = \\left( u_f + (\\alpha h) u_{x,f} + \\mathcal{O}(h^2) \\right) - u_f = \\alpha h \\, u_{x,f} + \\mathcal{O}(h^2)\n$$\nNow, substitute these expansions into the formula for $\\tau_C$:\n$$\n\\tau_C = \\frac{a}{\\alpha h} \\left[ \\left( \\frac{h}{2}(1+\\alpha) u_{x,f} + \\mathcal{O}(h^2) \\right) - \\left( \\alpha h \\, u_{x,f} + \\mathcal{O}(h^2) \\right) \\right]\n$$\n$$\n\\tau_C = \\frac{a}{\\alpha h} \\left[ h u_{x,f} \\left( \\frac{1+\\alpha}{2} - \\alpha \\right) + \\mathcal{O}(h^2) \\right]\n$$\nSimplifying the coefficient of the $h u_{x,f}$ term:\n$$\n\\frac{1+\\alpha}{2} - \\alpha = \\frac{1+\\alpha-2\\alpha}{2} = \\frac{1-\\alpha}{2}\n$$\nSo, the expression for $\\tau_C$ becomes:\n$$\n\\tau_C = \\frac{a}{\\alpha h} \\left[ h \\frac{1-\\alpha}{2} u_{x,f} + \\mathcal{O}(h^2) \\right] = a \\frac{1-\\alpha}{2\\alpha} u_{x,f} + \\mathcal{O}(h)\n$$\nThe leading-order term of the truncation error as $h \\to 0$ is the term that does not vanish with $h$. Since $\\alpha \\in (0,1)$, $\\alpha \\neq 1$, this leading term is non-zero in general. It is of order $\\mathcal{O}(h^0)$, i.e., constant with respect to $h$.\nThis indicates that the scheme is inconsistent (zeroth-order accurate) at the cut cell, a known deficiency of the standard first-order Godunov method when applied naively to irregular meshes.\n\nThe leading-order term is therefore:\n$$\na \\frac{1-\\alpha}{2\\alpha} u_{x}(x_{f},t)\n$$", "answer": "$$\n\\boxed{a \\frac{1-\\alpha}{2\\alpha} u_{x}(x_{f},t)}\n$$", "id": "2401460"}, {"introduction": "Beyond accuracy, the most significant challenge for explicit cut-cell methods is the 'small cell problem,' where tiny cell volumes lead to prohibitively small global time steps for stability. A powerful strategy to overcome this is local time-stepping (LTS), where smaller cells are evolved with smaller time steps than larger ones. This coding practice challenges you to devise an optimal LTS scheme, providing a hands-on understanding of how to maintain stability efficiently in the presence of arbitrarily small cut cells [@problem_id:2401456].", "problem": "Consider the one-dimensional linear advection equation $\\partial_t q + a\\,\\partial_x q = 0$ on a periodic interval discretized by a uniform Cartesian mesh with nominal cell width $h$. An immersed boundary cuts some cells, so that only a fraction $\\alpha_j \\in (0,1]$ of the nominal volume of cell $j$ contains fluid. In one spatial dimension the effective fluid length of a cut cell is $h_j = \\alpha_j h$. Assume a conservative explicit finite-volume update is applied to each cell, and let $\\nu \\in (0,1]$ denote a prescribed Courant number. The base time step for uncut cells is defined by the uniform-cell stability restriction $\\Delta t_{\\text{base}} = \\nu h / |a|$. Local time stepping is introduced by assigning to each cell an integer subcycling factor $r_j \\in \\{1,2,4,8,\\dots\\}$ (a power of two), so that the cell time step is $\\Delta t_j = \\Delta t_{\\text{base}}/r_j$. Stability requires that every cell satisfies the Courant–Friedrichs–Lewy inequality $|a|\\,\\Delta t_j / h_j \\le \\nu$. Let $T_{\\text{end}}$ be a final time such that $N_{\\text{base}} = T_{\\text{end}} / \\Delta t_{\\text{base}}$ is an integer, so each uncut cell executes exactly $N_{\\text{base}}$ base steps.\n\nYour task is to determine, for each test case listed below, a choice of subcycling factors $r_j$ that satisfies the stability inequality and the power-of-two constraint, minimizes the total number of cell updates over $[0,T_{\\text{end}}]$, and to quantify the efficiency of local time stepping relative to a uniform-small-step scheme. Here, a cell update means advancing that cell by its local time step once. For the uniform-small-step scheme, all cells are advanced with $\\Delta t_{\\text{uniform}} = \\Delta t_{\\text{base}} / R_{\\max}$ where $R_{\\max} = \\max_j r_j$.\n\nFor each test case, compute and report:\n- The list of subcycling factors $[r_1,\\dots,r_M]$ (integers).\n- The total number of updates performed by the local scheme $N_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j$ (integer).\n- The total number of updates performed by the uniform-small-step scheme $N_{\\text{uniform}} = N_{\\text{base}}\\,M\\,R_{\\max}$ (integer).\n- The efficiency gain $G = N_{\\text{uniform}}/N_{\\text{local}}$ rounded to six decimal places (float).\n- A boolean indicating whether the stability inequality $|a|\\,\\Delta t_j / h_j \\le \\nu$ holds for all cells under your chosen $r_j$ (boolean).\n\nUse the following test suite. All lengths must be in meters ($\\mathrm{m}$), speeds in meters per second ($\\mathrm{m/s}$), and times in seconds ($\\mathrm{s}$).\n- Test case A (happy path): $h = 1.0\\,\\mathrm{m}$, $a = 1.0\\,\\mathrm{m/s}$, $\\nu = 0.5$, $T_{\\text{end}} = 1.0\\,\\mathrm{s}$, $\\boldsymbol{\\alpha} = [\\,1.0,\\,0.5,\\,0.25,\\,0.125\\,]$.\n- Test case B (all uncut): $h = 0.5\\,\\mathrm{m}$, $a = 2.0\\,\\mathrm{m/s}$, $\\nu = 0.5$, $T_{\\text{end}} = 1.0\\,\\mathrm{s}$, $\\boldsymbol{\\alpha} = [\\,1.0,\\,1.0,\\,1.0\\,]$.\n- Test case C (extreme cut): $h = 1.0\\,\\mathrm{m}$, $a = 2.0\\,\\mathrm{m/s}$, $\\nu = 0.4$, $T_{\\text{end}} = 1.0\\,\\mathrm{s}$, $\\boldsymbol{\\alpha} = [\\,1.0,\\,0.2,\\,0.03\\,]$.\n- Test case D (boundary equality): $h = 2.0\\,\\mathrm{m}$, $a = 1.0\\,\\mathrm{m/s}$, $\\nu = 1.0$, $T_{\\text{end}} = 4.0\\,\\mathrm{s}$, $\\boldsymbol{\\alpha} = [\\,1.0,\\,0.5,\\,0.25,\\,0.125\\,]$.\n\nYour program must produce a single line of output containing the results for the test cases in the same order, aggregated into one outer list. Each test case result must itself be a list with the structure [r_list, N_local, N_uniform, G, stable_flag]. The single line must be a comma-separated list enclosed in square brackets, for example, \"[[...],[...],[...],[...]]\".", "solution": "The problem as stated will first be subjected to a rigorous validation process.\n\n**Step 1: Extracted Givens**\n\nThe fundamental physical model is the one-dimensional linear advection equation: $\\partial_t q + a\\,\\partial_x q = 0$.\nThe problem is discretized on a uniform Cartesian mesh with cell width $h$.\nImmersed boundaries result in cut cells, where cell $j$ has a fluid volume fraction $\\alpha_j \\in (0,1]$ and an effective length $h_j = \\alpha_j h$.\nA conservative explicit finite-volume update is used.\nThe prescribed Courant number is $\\nu \\in (0,1]$.\nThe time step for uncut cells (where $\\alpha_j=1$) is $\\Delta t_{\\text{base}} = \\nu h / |a|$.\nLocal time stepping is employed, with each cell $j$ having a subcycling factor $r_j$ and a local time step $\\Delta t_j = \\Delta t_{\\text{base}}/r_j$.\nThe subcycling factors are constrained to be powers of two: $r_j \\in \\{1, 2, 4, \\dots\\}$.\nThe Courant–Friedrichs–Lewy (CFL) stability condition for each cell is $|a|\\,\\Delta t_j / h_j \\le \\nu$.\nThe simulation runs until a final time $T_{\\text{end}}$. The quantity $N_{\\text{base}} = T_{\\text{end}} / \\Delta t_{\\text{base}}$ is specified to be an integer.\nThe objective is to choose the set of subcycling factors $\\{r_j\\}$ to minimize the total number of cell updates, $N_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j$.\nA reference uniform-small-step scheme is defined with a time step $\\Delta t_{\\text{uniform}} = \\Delta t_{\\text{base}} / R_{\\max}$, where $R_{\\max} = \\max_j r_j$. The total number of updates for this scheme is $N_{\\text{uniform}} = N_{\\text{base}}\\,M\\,R_{\\max}$.\nThe efficiency gain is defined as $G = N_{\\text{uniform}}/N_{\\text{local}}$.\nThe required outputs for each test case are: the list of factors $[r_1,\\dots,r_M]$, the total updates $N_{\\text{local}}$ and $N_{\\text{uniform}}$, the gain $G$, and a boolean stability flag.\nThe test cases provide specific values for $h$, $a$, $\\nu$, $T_{\\text{end}}$, and the vector $\\boldsymbol{\\alpha}$.\n\n**Step 2: Validation of Problem Statement**\n\nThe problem is scientifically grounded, being based on the standard advection equation and the well-established finite-volume method with local time-stepping for handling the small-cell problem in immersed boundary contexts. The CFL condition is a fundamental principle of explicit numerical methods. The problem is well-posed, presenting a constrained optimization problem with a clear objective function (minimizing $N_{\\text{local}}$) and well-defined constraints on the variables ($r_j$). The language is objective and mathematically precise. The setup is self-contained and free of contradictions. The provided data are dimensionally consistent and physically plausible. The problem does not violate any of the specified invalidity criteria.\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed valid. A solution will be formulated.\n\n**Derivation of Optimal Subcycling Factors**\n\nThe objective is to minimize the total number of cell updates over the simulation time $[0, T_{\\text{end}}]$, given by the expression:\n$$\nN_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j\n$$\nSince $N_{\\text{base}}$ is a positive constant for any given test case, minimizing $N_{\\text{local}}$ is equivalent to minimizing the sum of the subcycling factors, $\\sum_{j=1}^M r_j$. As the choice of each $r_j$ is independent of the others, the sum is minimized by selecting the smallest possible valid $r_j$ for each cell $j$.\n\nThe constraints on each $r_j$ are:\n1. $r_j$ must be a power of two, i.e., $r_j = 2^k$ for some non-negative integer $k$.\n2. $r_j$ must satisfy the local CFL stability inequality: $|a|\\,\\Delta t_j / h_j \\le \\nu$.\n\nWe analyze the stability inequality by substituting the definitions of $\\Delta t_j$ and $h_j$:\n$$\n\\frac{|a|}{h_j} \\Delta t_j = \\frac{|a|}{\\alpha_j h} \\left( \\frac{\\Delta t_{\\text{base}}}{r_j} \\right) \\le \\nu\n$$\nNow, substitute the definition of $\\Delta t_{\\text{base}} = \\nu h / |a|$:\n$$\n\\frac{|a|}{\\alpha_j h} \\left( \\frac{1}{r_j} \\frac{\\nu h}{|a|} \\right) \\le \\nu\n$$\nAssuming $a \\ne 0$ and $h, \\nu > 0$, we can simplify the expression:\n$$\n\\frac{1}{\\alpha_j r_j} \\le 1\n$$\nSince $\\alpha_j > 0$ and $r_j$ must be positive, this is equivalent to:\n$$\nr_j \\ge \\frac{1}{\\alpha_j}\n$$\nCombining this with the power-of-two constraint, the optimal subcycling factor $r_j$ for cell $j$ is the smallest integer power of two that is greater than or equal to $1/\\alpha_j$.\n\nThis can be expressed formally. Let the minimum required value be $s_j = 1/\\alpha_j$. We seek the smallest non-negative integer $k$ such that $2^k \\ge s_j$. Taking the base-2 logarithm, we find $k \\ge \\log_2(s_j)$. Since $k$ must be an integer, the smallest such $k$ is $\\lceil \\log_2(s_j) \\rceil$. Therefore, the optimal subcycling factor for cell $j$ is:\n$$\nr_j = 2^{\\lceil \\log_2(1/\\alpha_j) \\rceil}\n$$\nFor uncut cells, $\\alpha_j=1$, which gives $1/\\alpha_j=1$. Since $\\log_2(1)=0$, we have $\\lceil 0 \\rceil = 0$ and $r_j = 2^0 = 1$, which is correct. This corresponds to a cell taking the base time step $\\Delta t_{\\text{base}}$. For cut cells, $\\alpha_j < 1$, which requires $r_j > 1$.\n\n**Calculation of Performance Metrics and Stability Check**\n\nOnce the list of optimal factors $\\boldsymbol{r} = [r_1, \\dots, r_M]$ has been determined for a given test case, the remaining quantities are calculated as follows:\n1. The maximum subcycling factor is $R_{\\max} = \\max_j r_j$.\n2. The number of base steps is $N_{\\text{base}} = T_{\\text{end}} / \\Delta t_{\\text{base}} = T_{\\text{end}} / (\\nu h / |a|)$.\n3. The total number of updates for the local time-stepping scheme is $N_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j$.\n4. The total number of updates for the uniform-small-step scheme is $N_{\\text{uniform}} = N_{\\text{base}} M R_{\\max}$.\n5. The efficiency gain is $G = N_{\\text{uniform}} / N_{\\text{local}}$.\n6. The boolean stability flag is determined by checking the CFL condition $|a|\\,\\Delta t_j / h_j \\le \\nu$ for all cells $j=1,\\dots,M$. By our construction, $r_j \\ge 1/\\alpha_j$, which is equivalent to the CFL condition being satisfied. Therefore, this flag will always be true.\n\nThis algorithm is applied to each test case to produce the required results. The final implementation will perform these calculations and format the output as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the local time stepping optimization problem for a series of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A: h, a, nu, T_end, alpha_list\n        (1.0, 1.0, 0.5, 1.0, [1.0, 0.5, 0.25, 0.125]),\n        # Test Case B\n        (0.5, 2.0, 0.5, 1.0, [1.0, 1.0, 1.0]),\n        # Test Case C\n        (1.0, 2.0, 0.4, 1.0, [1.0, 0.2, 0.03]),\n        # Test Case D\n        (2.0, 1.0, 1.0, 4.0, [1.0, 0.5, 0.25, 0.125]),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        h, a, nu, T_end, alpha_list = case\n        \n        # Determine the optimal subcycling factor r_j for each cell\n        r_list = []\n        for alpha_j in alpha_list:\n            # The stability condition r_j >= 1/alpha_j must be satisfied.\n            # We want the smallest power of two that meets this condition.\n            min_r_val = 1.0 / alpha_j\n            \n            # Efficiently find the smallest power of two >= min_r_val\n            # Can be found with logarithms: r = 2**ceil(log2(min_r_val))\n            # or with a simple loop.\n            r_j = 1\n            while r_j < min_r_val:\n                r_j *= 2\n            r_list.append(int(r_j))\n            \n        # Calculate performance metrics\n        M = len(alpha_list)\n        abs_a = abs(a)\n        \n        # Base time step and number of base steps\n        delta_t_base = nu * h / abs_a\n        N_base = int(round(T_end / delta_t_base))\n\n        # Total updates for local and uniform schemes\n        sum_r = sum(r_list)\n        N_local = N_base * sum_r\n        \n        R_max = max(r_list) if r_list else 1\n        N_uniform = N_base * M * R_max\n        \n        # Efficiency gain\n        G = N_uniform / N_local if N_local > 0 else 0.0\n        G_rounded = round(G, 6)\n        \n        # Verify stability for the chosen r_j\n        stable_flag = True\n        for r_j, alpha_j in zip(r_list, alpha_list):\n            h_j = alpha_j * h\n            delta_t_j = delta_t_base / r_j\n            cfl_val = abs_a * delta_t_j / h_j\n            # Use a small tolerance for floating point comparison\n            if cfl_val > nu + 1e-9:\n                stable_flag = False\n                break\n                \n        # Aggregate results for this case\n        case_result = [r_list, int(N_local), int(N_uniform), G_rounded, stable_flag]\n        all_results.append(case_result)\n\n    # Convert each element of the result lists to a string for join\n    def format_results(results):\n        formatted_list = []\n        for item in results:\n            if isinstance(item, list):\n                formatted_list.append(f\"[{','.join(map(str, item))}]\")\n            elif isinstance(item, float):\n                # Ensure float has required decimal places in string representation\n                formatted_list.append(f\"{item:.6f}\")\n            else:\n                 formatted_list.append(str(item))\n        return f\"[{','.join(formatted_list)}]\"\n\n    # Final print statement in the exact required format.\n    final_output_str = f\"[{','.join(map(format_results, all_results))}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2401456"}, {"introduction": "Immersed boundary and cut-cell methods represent two distinct philosophies for handling complex geometries: 'diffuse' versus 'sharp' interface representations. A critical test of any such method is its ability to accurately compute physical quantities like forces on the boundary. This exercise puts theory into practice by tasking you with implementing and comparing both a classic immersed boundary method and a cut-cell approach to calculate the force on a circular object, highlighting their fundamental differences in accuracy and implementation [@problem_id:2401412].", "problem": "You are given a closed, smooth curve $\\Gamma \\subset \\mathbb{R}^2$ defined as the circle of radius $R$ centered at $(c_x,c_y)$, namely the zero level set of the signed-distance function $\\phi(x,y)=\\sqrt{(x-c_x)^2+(y-c_y)^2}-R$. Define the vector-valued force density on the plane by $\\mathbf{f}(x,y)=\\begin{bmatrix}\\cos(3\\theta(x,y))+\\tfrac{1}{2}\\\\ \\sin(2\\theta(x,y))\\end{bmatrix}$ where $\\theta(x,y)=\\mathrm{atan2}(y-c_y,x-c_x)$ is the polar angle around the center, expressed in radians. The total force is defined by the line integral $\\mathbf{F}=\\int_{\\Gamma}\\mathbf{f}\\,ds$.\n\nYour task is to compute and compare approximations of $\\mathbf{F}$ using two distinct approaches on a uniform Cartesian grid covering the square domain $\\Omega=[-L,L]^2$:\n\n- A diffuse-interface immersed-boundary approximation based on the regularized Dirac delta function. Let the regularized delta be\n$$\n\\delta_\\varepsilon(\\phi)=\n\\begin{cases}\n\\dfrac{1}{2\\varepsilon}\\left(1+\\cos\\left(\\dfrac{\\pi\\phi}{\\varepsilon}\\right)\\right) & |\\phi|\\le \\varepsilon \\\\\n0 & |\\phi|>\\varepsilon\n\\end{cases}\n$$\nand let $|\\nabla \\phi|=1$ for the signed distance $\\phi$. On a uniform grid of $N\\times N$ points with spacing $h=\\dfrac{2L}{N-1}$, approximate\n$$\n\\mathbf{F}_{\\mathrm{IB}}(\\varepsilon,h)\\approx \\iint_{\\Omega}\\mathbf{f}(x,y)\\,\\delta_\\varepsilon(\\phi(x,y))\\,|\\nabla\\phi(x,y)|\\,dx\\,dy\n$$\nby a Riemann sum with cell area $h^2$.\n\n- A sharp-interface cut-cell approximation that replaces $\\Gamma=\\{\\phi=0\\}$ by a polyline obtained by linear interpolation of $\\phi$ on each grid cell whose vertices straddle the zero level set. For each resulting line segment $s$ with length $|s|$ and midpoint $\\mathbf{m}_s$, approximate the line integral by\n$$\n\\mathbf{F}_{\\mathrm{CC}}(h)\\approx \\sum_{s}\\mathbf{f}(\\mathbf{m}_s)\\,|s|.\n$$\n\nUse radians for all angular quantities. For this manufactured test, the exact total force is\n$$\n\\mathbf{F}_{\\mathrm{true}}=\\int_{0}^{2\\pi}\\begin{bmatrix}\\cos(3\\theta)+\\tfrac{1}{2}\\\\ \\sin(2\\theta)\\end{bmatrix}R\\,d\\theta=\\begin{bmatrix}\\pi R\\\\ 0\\end{bmatrix}.\n$$\n\nImplement a program that evaluates the Euclidean-norm errors\n$$\ne_{\\mathrm{IB}}=\\left\\|\\mathbf{F}_{\\mathrm{IB}}(\\varepsilon,h)-\\mathbf{F}_{\\mathrm{true}}\\right\\|_2,\\qquad\ne_{\\mathrm{CC}}=\\left\\|\\mathbf{F}_{\\mathrm{CC}}(h)-\\mathbf{F}_{\\mathrm{true}}\\right\\|_2\n$$\nfor the following test suite of parameter sets, with $\\varepsilon=k_\\varepsilon\\,h$:\n\n- Test $1$: $L=1.2$, $R=0.9$, $N=33$, $(c_x,c_y)=(0.0,0.0)$, $k_\\varepsilon=1.5$.\n- Test $2$: $L=1.2$, $R=0.9$, $N=33$, $(c_x,c_y)=(0.2,-0.15)$, $k_\\varepsilon=0.5$.\n- Test $3$: $L=1.2$, $R=0.9$, $N=65$, $(c_x,c_y)=(0.2,-0.15)$, $k_\\varepsilon=1.5$.\n- Test $4$: $L=1.2$, $R=0.9$, $N=129$, $(c_x,c_y)=(0.37,0.22)$, $k_\\varepsilon=1.5$.\n\nYour program must produce a single line of output containing the $8$ floating-point results as a comma-separated list enclosed in square brackets, in the order $[e_{\\mathrm{IB}}^{(1)},e_{\\mathrm{CC}}^{(1)},e_{\\mathrm{IB}}^{(2)},e_{\\mathrm{CC}}^{(2)},e_{\\mathrm{IB}}^{(3)},e_{\\mathrm{CC}}^{(3)},e_{\\mathrm{IB}}^{(4)},e_{\\mathrm{CC}}^{(4)}]$, where the superscript indicates the test number. Each value must be rounded to $6$ decimal places. No other text should be printed. No physical units are required because all quantities are dimensionless in this setup.", "solution": "The problem requires the computation of a line integral of a vector-valued force density $\\mathbf{f}(x,y)$ over a circle $\\Gamma$. This is to be approximated using two different numerical methods on a uniform Cartesian grid: the diffuse-interface immersed boundary (IB) method and the sharp-interface cut-cell (CC) method. The accuracy of these methods is to be evaluated by comparing their results to the exact analytical solution.\n\nFirst, the necessary parameters for each test case are defined: the domain half-width $L$, circle radius $R$, center coordinates $(c_x, c_y)$, grid size $N \\times N$, and the Dirac delta function width parameter $k_\\varepsilon$. From these, the grid spacing $h = \\frac{2L}{N-1}$ and the delta function support radius $\\varepsilon = k_\\varepsilon h$ are derived. The computational grid consists of points $(x_i, y_j)$ where $x_i = -L + i \\cdot h$ and $y_j = -L + j \\cdot h$ for $i, j \\in \\{0, 1, \\dots, N-1\\}$.\n\nThe exact total force $\\mathbf{F}_{\\mathrm{true}}$ is given by the integral of the force density along the curve parameterized by the polar angle $\\theta$:\n$$\n\\mathbf{F}_{\\mathrm{true}} = \\int_{0}^{2\\pi} \\mathbf{f}(\\theta) R \\, d\\theta = \\int_{0}^{2\\pi} \\begin{bmatrix} \\cos(3\\theta) + \\frac{1}{2} \\\\ \\sin(2\\theta) \\end{bmatrix} R \\, d\\theta = \\begin{bmatrix} \\pi R \\\\ 0 \\end{bmatrix}\n$$\nThis serves as the benchmark against which the numerical approximations are compared.\n\nThe first numerical approach is the **Immersed Boundary (IB) method**. This method represents the singular force concentrated on the curve $\\Gamma$ as a regularized force field spread over a small neighborhood of the curve. This is achieved using a regularized Dirac delta function, $\\delta_\\varepsilon(\\phi)$, where $\\phi$ is the signed distance function to the curve $\\Gamma$. The total force is then approximated by integrating this regularized force field over the entire computational domain $\\Omega$:\n$$\n\\mathbf{F}_{\\mathrm{IB}}(\\varepsilon, h) = \\iint_{\\Omega} \\mathbf{f}(x,y) \\, \\delta_\\varepsilon(\\phi(x,y)) \\, |\\nabla\\phi(x,y)| \\, dx \\, dy\n$$\nGiven that $|\\nabla \\phi| = 1$ for a signed distance function, this simplifies the integral. We discretize this integral as a Riemann sum over the grid cells. For each grid point $(x_i, y_j)$, we evaluate the force density $\\mathbf{f}(x_i, y_j)$, the signed distance $\\phi(x_i, y_j)$, and the delta function $\\delta_\\varepsilon(\\phi(x_i, y_j))$. The total force is then the sum of these contributions scaled by the cell area $h^2$:\n$$\n\\mathbf{F}_{\\mathrm{IB}} \\approx \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\mathbf{f}(x_i, y_j) \\, \\delta_\\varepsilon(\\phi(x_i, y_j)) \\, h^2\n$$\nThe implementation involves computing these quantities on the $N \\times N$ grid and performing the summation.\n\nThe second numerical approach is the **Cut-Cell (CC) method**. This method provides a sharp representation of the geometry by explicitly reconstructing the curve $\\Gamma$ within each grid cell it intersects. The procedure is as follows:\n$1$. Iterate through each grid cell in the domain. A cell is defined by four adjacent grid points.\n$2$. For each cell, determine if it is \"cut\" by the curve $\\Gamma$. This is detected by checking if the signed distance function $\\phi$ changes sign between the cell's vertices. If all vertices have $\\phi$ values of the same sign, the cell is entirely inside or outside the curve and does not contribute to the line integral.\n$3$. If a cell is cut, the intersection points of $\\Gamma$ with the cell's edges are found. This is done by linear interpolation of $\\phi$ along each edge. For an edge connecting vertices $\\mathbf{p}_1$ and $\\mathbf{p}_2$ with signed distance values $\\phi_1$ and $\\phi_2$, the intersection point $\\mathbf{p}_{\\text{int}}$ where $\\phi=0$ is given by:\n$$\n\\mathbf{p}_{\\text{int}} = \\frac{\\phi_2 \\mathbf{p}_1 - \\phi_1 \\mathbf{p}_2}{\\phi_2 - \\phi_1}\n$$\n$4$. For a smooth curve like a circle and a sufficiently fine grid, each cut cell will have exactly two intersection points. These two points define a line segment $s$ which approximates the portion of $\\Gamma$ within that cell.\n$5$. The line integral is then approximated by summing the contributions from all such segments:\n$$\n\\mathbf{F}_{\\mathrm{CC}}(h) \\approx \\sum_{s} \\mathbf{f}(\\mathbf{m}_s) \\, |s|\n$$\nwhere $|s|$ is the length of segment $s$ and $\\mathbf{m}_s$ is its midpoint.\n\nFor each test case, both $\\mathbf{F}_{\\mathrm{IB}}$ and $\\mathbf{F}_{\\mathrm{CC}}$ are computed. The errors are then calculated as the Euclidean norm of the difference between the numerical approximation and the exact force $\\mathbf{F}_{\\mathrm{true}}$:\n$$\ne_{\\mathrm{IB}} = \\left\\|\\mathbf{F}_{\\mathrm{IB}} - \\mathbf{F}_{\\mathrm{true}}\\right\\|_2, \\qquad e_{\\mathrm{CC}} = \\left\\|\\mathbf{F}_{\\mathrm{CC}} - \\mathbf{F}_{\\mathrm{true}}\\right\\|_2\n$$\nThese error values are collected for all specified test cases and presented as the final output. It is noteworthy that in Test $4$, the circle extends slightly beyond the computational domain $\\Omega$. Both numerical methods operate strictly within $\\Omega$, thus they will approximate the integral over the truncated curve $\\Gamma \\cap \\Omega$. The comparison is still made against $\\mathbf{F}_{\\mathrm{true}}$, which is the integral over the full circle $\\Gamma$. This introduces a domain truncation error into the computed error metrics for that specific test case.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares immersed-boundary and cut-cell approximations of a line integral.\n    \"\"\"\n    test_cases = [\n        # (L, R, N, (cx, cy), k_eps)\n        (1.2, 0.9, 33, (0.0, 0.0), 1.5),\n        (1.2, 0.9, 33, (0.2, -0.15), 0.5),\n        (1.2, 0.9, 65, (0.2, -0.15), 1.5),\n        (1.2, 0.9, 129, (0.37, 0.22), 1.5),\n    ]\n\n    results = []\n    for L, R, N, (cx, cy), k_eps in test_cases:\n        h = (2 * L) / (N - 1)\n        eps = k_eps * h\n        \n        # Grid setup\n        x_coords = np.linspace(-L, L, N)\n        y_coords = np.linspace(-L, L, N)\n        xx, yy = np.meshgrid(x_coords, y_coords)\n\n        # Signed distance function\n        phi = np.sqrt((xx - cx)**2 + (yy - cy)**2) - R\n        \n        # Exact force\n        F_true = np.array([np.pi * R, 0.0])\n\n        # --- Immersed Boundary (IB) Calculation ---\n        F_ib = np.zeros(2)\n        \n        # Active region for delta function\n        active_mask = np.abs(phi) <= eps\n\n        phi_active = phi[active_mask]\n        xx_active = xx[active_mask]\n        yy_active = yy[active_mask]\n\n        delta_eps = (1.0 / (2.0 * eps)) * (1.0 + np.cos(np.pi * phi_active / eps))\n        \n        theta_active = np.arctan2(yy_active - cy, xx_active - cx)\n        \n        fx_active = np.cos(3 * theta_active) + 0.5\n        fy_active = np.sin(2 * theta_active)\n\n        F_ib[0] = np.sum(fx_active * delta_eps) * h**2\n        F_ib[1] = np.sum(fy_active * delta_eps) * h**2\n        \n        e_ib = np.linalg.norm(F_ib - F_true)\n        \n        # --- Cut-Cell (CC) Calculation ---\n        F_cc = np.zeros(2)\n        \n        phi_grid = phi\n\n        for j in range(N - 1):\n            for i in range(N - 1):\n                # Vertices (BL, BR, TR, TL) and their phi values\n                points = [\n                    np.array([x_coords[i], y_coords[j]]),\n                    np.array([x_coords[i+1], y_coords[j]]),\n                    np.array([x_coords[i+1], y_coords[j+1]]),\n                    np.array([x_coords[i], y_coords[j+1]])\n                ]\n                phis = [\n                    phi_grid[j, i], \n                    phi_grid[j, i+1], \n                    phi_grid[j+1, i+1], \n                    phi_grid[j+1, i]\n                ]\n\n                # If all phi values have the same sign, cell is not cut\n                if not (np.all(np.array(phis) > 0) or np.all(np.array(phis) < 0)):\n                    intersections = []\n                    for k in range(4):\n                        p1, p2 = points[k], points[(k + 1) % 4]\n                        phi1, phi2 = phis[k], phis[(k + 1) % 4]\n\n                        if phi1 * phi2 < 0:\n                            # Linear interpolation to find the zero-crossing at phi=0\n                            p_int = (p1 * phi2 - p2 * phi1) / (phi2 - phi1)\n                            intersections.append(p_int)\n                    \n                    if len(intersections) == 2:\n                        p_a, p_b = intersections\n                        \n                        # Segment length\n                        length_s = np.linalg.norm(p_a - p_b)\n                        \n                        # Midpoint\n                        m_s = (p_a + p_b) / 2.0\n                        \n                        # Force at midpoint\n                        theta_m = np.arctan2(m_s[1] - cy, m_s[0] - cx)\n                        f_m = np.array([\n                            np.cos(3 * theta_m) + 0.5,\n                            np.sin(2 * theta_m)\n                        ])\n                        \n                        F_cc += f_m * length_s\n\n        e_cc = np.linalg.norm(F_cc - F_true)\n        \n        results.extend([e_ib, e_cc])\n\n    # Format output\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2401412"}]}