{"hands_on_practices": [{"introduction": "A cornerstone of many modern particle methods, such as Smoothed Particle Hydrodynamics (SPH), is the weakly compressible formulation. Instead of enforcing perfect incompressibility, which requires solving a computationally expensive pressure Poisson equation, this approach allows for very small density fluctuations. These fluctuations, in turn, generate a restoring pressure force via an artificial equation of state. This exercise [@problem_id:2413331] lets you explore the fundamental trade-offs of this approach by comparing the pressure field from a weakly compressible model against the exact analytical solution for an incompressible fluid in a simple hydrostatic case. By analyzing the deviation, you will gain a concrete understanding of how the choice of the artificial speed of sound, $c_0$, governs the method's accuracy.", "problem": "You are given a one-dimensional, vertical, static water column modeled as a set of equally spaced particles (a meshless discretization) with free surface at height $z = H$ and bottom at $z = 0$. Gravity acts downward with magnitude $g$. The reference fluid density is $\\rho_0$, and the hydrostatic pressure at the free surface is $p_0$ (atmospheric), which you may take as the zero-gauge pressure, i.e., $p_0 = 0$. You will compare two models for the pressure field approximated at particle locations:\n\n1. An Equation of State (EOS) approach, representative of weakly compressible Smoothed Particle Hydrodynamics (SPH). Use the Tait Equation of State for water:\n$$\np(\\rho) - p_0 = \\frac{\\rho_0 c_0^2}{\\gamma} \\left[ \\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1 \\right],\n$$\nwhere $c_0$ is the artificial speed of sound and $\\gamma$ is the Tait exponent. Under static equilibrium with gravity, the momentum balance reduces to\n$$\n\\frac{dp}{dz} = -\\rho g,\n$$\nand the EOS relates $p$ and $\\rho$. Impose the free surface boundary condition $p(H) = p_0$.\n\n2. A projection-based incompressible solver model, where the density is constant $\\rho = \\rho_0$ and the static equilibrium reduces to\n$$\n\\frac{dp}{dz} = -\\rho_0 g,\n$$\nwith the free surface boundary condition $p(H) = p_0$.\n\nTask:\n- Derive from first principles the analytic expressions needed to evaluate the EOS-compressible hydrostatic pressure $p_{\\mathrm{eos}}(z)$ and the incompressible hydrostatic pressure $p_{\\mathrm{inc}}(z)$ at arbitrary depth $z \\in [0,H]$, given the parameters $(\\rho_0, g, c_0, \\gamma, H)$.\n- Using a particle discretization with $N$ equally spaced particles along the column, evaluate both $p_{\\mathrm{eos}}$ and $p_{\\mathrm{inc}}$ at every particle position $z_i$ for $i = 0, 1, \\dots, N-1$. The particle positions must be $z_i = i \\Delta z$ with $\\Delta z = H/(N-1)$.\n- Compute the maximum absolute pointwise deviation between the two pressure fields across all particles:\n$$\n\\Delta p_{\\max} = \\max_{0 \\le i  N} \\left| p_{\\mathrm{eos}}(z_i) - p_{\\mathrm{inc}}(z_i) \\right|.\n$$\n\nPhysical units:\n- All inputs are given in the International System of Units. Your program must report $\\Delta p_{\\max}$ in Pascals (Pa). Express each result as a decimal rounded to three digits after the decimal point.\n\nTest suite:\nYour program must evaluate the following four test cases and output the four results in a single line, as specified below.\n\n- Case A (happy path): $\\rho_0 = 1000$ kg/m$^3$, $g = 9.81$ m/s$^2$, $H = 1.0$ m, $c_0 = 50.0$ m/s, $\\gamma = 7.0$, $N = 101$.\n- Case B (shallow column boundary case): $\\rho_0 = 1000$ kg/m$^3$, $g = 9.81$ m/s$^2$, $H = 0.1$ m, $c_0 = 50.0$ m/s, $\\gamma = 7.0$, $N = 11$.\n- Case C (soft EOS edge case): $\\rho_0 = 1000$ kg/m$^3$, $g = 9.81$ m/s$^2$, $H = 2.0$ m, $c_0 = 10.0$ m/s, $\\gamma = 7.0$, $N = 201$.\n- Case D (stiff EOS near-incompressible): $\\rho_0 = 1000$ kg/m$^3$, $g = 9.81$ m/s$^2$, $H = 2.0$ m, $c_0 = 1000.0$ m/s, $\\gamma = 7.0$, $N = 51$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the four cases, in the order A, B, C, D, formatted as a comma-separated list enclosed in square brackets, for example:\n\"[x_A,x_B,x_C,x_D]\"\n- Each $x_\\cdot$ is the value of $\\Delta p_{\\max}$ in Pascals, rounded to three digits after the decimal point.\n- The program must be self-contained, must not read any input, and must not perform any file or network I/O.", "solution": "The problem requires the derivation and comparison of two models for hydrostatic pressure in a one-dimensional water column of height $H$. The first model is for an incompressible fluid, and the second is for a weakly compressible fluid described by the Tait Equation of State (EOS). The ultimate goal is to find the maximum absolute pressure deviation between these two models over a set of discretized particle locations.\n\nFirst, we derive the analytical expression for the pressure field $p_{\\mathrm{inc}}(z)$ in the incompressible model. The governing equation for hydrostatic equilibrium is the momentum balance, which simplifies to:\n$$\n\\frac{dp}{dz} = -\\rho g\n$$\nIn the incompressible model, the density is assumed to be constant, $\\rho = \\rho_0$. The equation becomes:\n$$\n\\frac{dp_{\\mathrm{inc}}}{dz} = -\\rho_0 g\n$$\nThis is a simple ordinary differential equation. We integrate with respect to the vertical coordinate $z$:\n$$\n\\int dp_{\\mathrm{inc}} = \\int -\\rho_0 g \\, dz \\implies p_{\\mathrm{inc}}(z) = -\\rho_0 g z + C\n$$\nwhere $C$ is the constant of integration. We determine $C$ by applying the boundary condition at the free surface, $z=H$, where the pressure is given as $p_0=0$.\n$$\np_{\\mathrm{inc}}(H) = -\\rho_0 g H + C = 0 \\implies C = \\rho_0 g H\n$$\nSubstituting the constant back into the pressure expression gives the final form for the incompressible hydrostatic pressure:\n$$\np_{\\mathrm{inc}}(z) = \\rho_0 g H - \\rho_0 g z = \\rho_0 g (H-z)\n$$\nThis is the familiar linear relationship between pressure and depth, where $H-z$ is the depth below the free surface.\n\nNext, we derive the pressure field $p_{\\mathrm{eos}}(z)$ for the weakly compressible model. We have a system of two coupled equations: the hydrostatic balance, where density $\\rho$ is now a function of pressure, and the Tait Equation of State.\n1. Hydrostatic balance: $\\frac{dp}{dz} = -\\rho(p) g$\n2. Tait EOS (with $p_0 = 0$): $p(\\rho) = \\frac{\\rho_0 c_0^2}{\\gamma} \\left[ \\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1 \\right]$\n\nTo solve this system, we first express the density $\\rho$ as a function of pressure $p$ from the EOS:\n$$\n\\frac{p \\gamma}{\\rho_0 c_0^2} = \\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1 \\implies \\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} = 1 + \\frac{p \\gamma}{\\rho_0 c_0^2}\n$$\n$$\n\\rho(p) = \\rho_0 \\left( 1 + \\frac{\\gamma p}{\\rho_0 c_0^2} \\right)^{1/\\gamma}\n$$\nSubstituting this into the hydrostatic balance equation gives a first-order, separable ODE for $p(z)$:\n$$\n\\frac{dp}{dz} = -g \\rho_0 \\left( 1 + \\frac{\\gamma p}{\\rho_0 c_0^2} \\right)^{1/\\gamma}\n$$\nWe separate the variables $p$ and $z$:\n$$\n\\left( 1 + \\frac{\\gamma p}{\\rho_0 c_0^2} \\right)^{-1/\\gamma} dp = -g \\rho_0 dz\n$$\nWe integrate both sides. The integration on the left is from the surface pressure $p(H)=0$ to the pressure $p(z)$ at an arbitrary height $z$. The integration on the right is correspondingly from $H$ to $z$.\n$$\n\\int_{0}^{p(z)} \\left( 1 + \\frac{\\gamma P}{\\rho_0 c_0^2} \\right)^{-1/\\gamma} dP = \\int_{H}^{z} -g \\rho_0 dZ\n$$\nThe right-hand side integrates to:\n$$\n\\int_{H}^{z} -g \\rho_0 dZ = -g \\rho_0 [Z]_{H}^{z} = -g \\rho_0(z - H) = g \\rho_0 (H-z)\n$$\nFor the left-hand side integral, let $u = 1 + \\frac{\\gamma P}{\\rho_0 c_0^2}$, which implies $dP = \\frac{\\rho_0 c_0^2}{\\gamma} du$. The limits of integration for $u$ are $1$ (for $P=0$) and $1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}$ (for $P=p(z)$). The integral becomes:\n$$\n\\int_{1}^{1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}} u^{-1/\\gamma} \\left(\\frac{\\rho_0 c_0^2}{\\gamma}\\right) du = \\frac{\\rho_0 c_0^2}{\\gamma} \\left[ \\frac{u^{1 - 1/\\gamma}}{1 - 1/\\gamma} \\right]_{1}^{1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}}\n$$\n$$\n= \\frac{\\rho_0 c_0^2}{\\gamma} \\frac{\\gamma}{\\gamma-1} \\left[ u^{(\\gamma-1)/\\gamma} \\right]_{1}^{1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}} = \\frac{\\rho_0 c_0^2}{\\gamma-1} \\left[ \\left(1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}\\right)^{(\\gamma-1)/\\gamma} - 1 \\right]\n$$\nEquating the results from both sides gives:\n$$\n\\frac{\\rho_0 c_0^2}{\\gamma-1} \\left[ \\left(1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}\\right)^{(\\gamma-1)/\\gamma} - 1 \\right] = g \\rho_0 (H-z)\n$$\nNow, we solve for $p_{\\mathrm{eos}}(z)$:\n$$\n\\left(1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}\\right)^{(\\gamma-1)/\\gamma} = 1 + \\frac{g(\\gamma-1)(H-z)}{c_0^2}\n$$\n$$\n1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2} = \\left( 1 + \\frac{g(\\gamma-1)(H-z)}{c_0^2} \\right)^{\\gamma/(\\gamma-1)}\n$$\n$$\np_{\\mathrm{eos}}(z) = \\frac{\\rho_0 c_0^2}{\\gamma} \\left\\{ \\left( 1 + \\frac{g(\\gamma-1)(H-z)}{c_0^2} \\right)^{\\gamma/(\\gamma-1)} - 1 \\right\\}\n$$\nThis is the analytical expression for the weakly compressible hydrostatic pressure.\n\nThe task is to find $\\Delta p_{\\max} = \\max_{0 \\le i  N} \\left| p_{\\mathrm{eos}}(z_i) - p_{\\mathrm{inc}}(z_i) \\right|$. A brute-force approach would be to evaluate this at all $N$ particle locations. However, we can analyze the behavior of the deviation function $\\Delta p(z) = p_{\\mathrm{eos}}(z) - p_{\\mathrm{inc}}(z)$. Let us define the depth below the surface as a new variable $X = H-z$. For $z \\in [0, H]$, $X \\in [0, H]$. The pressure expressions become:\n$$\np_{\\mathrm{inc}}(X) = \\rho_0 g X\n$$\n$$\np_{\\mathrm{eos}}(X) = \\frac{\\rho_0 c_0^2}{\\gamma} \\left\\{ \\left( 1 + \\frac{g(\\gamma-1)X}{c_0^2} \\right)^{\\gamma/(\\gamma-1)} - 1 \\right\\}\n$$\nAt $X=0$ (the surface), both pressures are $0$, so the deviation is $0$. Let's examine the derivative of the deviation with respect to $X$.\n$$\n\\frac{dp_{\\mathrm{inc}}}{dX} = \\rho_0 g\n$$\n$$\n\\frac{dp_{\\mathrm{eos}}}{dX} = \\frac{\\rho_0 c_0^2}{\\gamma} \\left[ \\frac{\\gamma}{\\gamma-1} \\left( 1 + \\frac{g(\\gamma-1)X}{c_0^2} \\right)^{\\frac{\\gamma}{\\gamma-1}-1} \\cdot \\frac{g(\\gamma-1)}{c_0^2} \\right] = \\rho_0 g \\left( 1 + \\frac{g(\\gamma-1)X}{c_0^2} \\right)^{1/(\\gamma-1)}\n$$\nGiven that $g$, $\\gamma-1$ (since $\\gamma=7.0$), and $X$ are all positive for any point below the surface, the term in the parenthesis is greater than $1$. As the exponent $1/(\\gamma-1)$ is also positive, we have:\n$$\n\\frac{dp_{\\mathrm{eos}}}{dX} > \\rho_0 g = \\frac{dp_{\\mathrm{inc}}}{dX} \\quad \\text{for } X > 0\n$$\nSince $p_{\\mathrm{eos}}(0) = p_{\\mathrm{inc}}(0) = 0$, and the slope of $p_{\\mathrm{eos}}(X)$ is always greater than the slope of $p_{\\mathrm{inc}}(X)$ for $X>0$, the function $p_{\\mathrm{eos}}(X)$ is always greater than $p_{\\mathrm{inc}}(X)$ and their difference, $\\Delta p(X) = p_{\\mathrm{eos}}(X) - p_{\\mathrm{inc}}(X)$, is a monotonically increasing function of depth $X$.\nTherefore, the maximum deviation must occur at the maximum depth, which is $X=H$, corresponding to the bottom of the column at $z=0$. The discretization is irrelevant for finding the maximum value, as it is guaranteed to be at one of the endpoints of the spatial domain included in the particle set, specifically $z_0=0$.\nThe calculation simplifies to:\n$$\n\\Delta p_{\\max} = |p_{\\mathrm{eos}}(0) - p_{\\mathrm{inc}}(0)|\n$$\nwhere\n$$\np_{\\mathrm{inc}}(0) = \\rho_0 g H\n$$\n$$\np_{\\mathrm{eos}}(0) = \\frac{\\rho_0 c_0^2}{\\gamma} \\left\\{ \\left( 1 + \\frac{g(\\gamma-1)H}{c_0^2} \\right)^{\\gamma/(\\gamma-1)} - 1 \\right\\}\n$$\nThis insight significantly simplifies the numerical implementation, as only a single point needs to be evaluated for each test case.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the maximum absolute pressure deviation between an incompressible\n    and a weakly compressible hydrostatic model for a set of test cases.\n    \"\"\"\n    \n    # Test cases: (rho_0, g, H, c_0, gamma, N)\n    test_cases = [\n        # Case A: Happy path\n        (1000.0, 9.81, 1.0, 50.0, 7.0, 101),\n        # Case B: Shallow column\n        (1000.0, 9.81, 0.1, 50.0, 7.0, 11),\n        # Case C: Soft EOS\n        (1000.0, 9.81, 2.0, 10.0, 7.0, 201),\n        # Case D: Stiff EOS (near-incompressible)\n        (1000.0, 9.81, 2.0, 1000.0, 7.0, 51),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        rho_0, g, H, c_0, gamma, N = case\n        \n        # As derived in the solution, the maximum pressure deviation occurs at the\n        # maximum depth, z=0. We only need to calculate the pressures at this point.\n        z = 0.0\n        \n        # 1. Incompressible pressure at z=0\n        p_inc_at_0 = rho_0 * g * (H - z)\n        \n        # 2. EOS-based pressure at z=0\n        # The term H-z is the depth below the free surface.\n        depth = H - z\n        \n        # The term inside the power function\n        base_term = 1.0 + (g * (gamma - 1.0) * depth) / (c_0**2)\n        \n        # The exponent\n        exponent = gamma / (gamma - 1.0)\n        \n        # Full expression for p_eos at z=0\n        p_eos_at_0 = (rho_0 * c_0**2 / gamma) * (base_term**exponent - 1.0)\n        \n        # 3. Maximum absolute deviation\n        delta_p_max = abs(p_eos_at_0 - p_inc_at_0)\n        \n        # Round to three decimal places and append to results list\n        results.append(f\"{delta_p_max:.3f}\")\n\n    # Format the final output string as per requirements\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2413331"}, {"introduction": "Beyond the physical approximations made in a model, the numerical implementation itself introduces errors. For particle methods, which represent a continuous field with a finite set of moving points, two of the most important error types are numerical dispersion and numerical diffusion. Dispersion causes waves of different wavelengths to travel at incorrect speeds, distorting the solution, while diffusion artificially dampens the amplitudes of features over time. This practice [@problem_id:2413385] guides you through a formal von Neumann stability analysis of a one-dimensional particle advection scheme. You will learn to use Fourier analysis to precisely quantify these errors, a powerful technique essential for evaluating and comparing the performance of different numerical methods.", "problem": "Consider the one-dimensional linear advection equation on a periodic domain,\n$$\\partial_t u(x,t)+c\\,\\partial_x u(x,t)=0,$$\nposed on the interval $[0,L)$ with periodic boundary conditions and constant advection speed $c$. Let $N$ Lagrangian particles be initially placed at positions $x_i=i\\,h$ for $i\\in\\{0,1,\\dots,N-1\\}$, where $h=L/N$, each carrying the scalar value $u_i^0=u_0(x_i)$ of the initial condition\n$$u_0(x)=\\cos(k\\,x),\\quad k=\\frac{2\\pi n}{L},$$\nfor a given integer mode index $n$. Over one time step $\\Delta t$, particle positions update by the exact Lagrangian map\n$$x_i'=(x_i+c\\,\\Delta t)\\bmod L,$$\nwhile their carried values remain unchanged, $u_i'=u_i^0$. To estimate the field back on the original particle locations $\\{x_j\\}_{j=0}^{N-1}$ after this step, define the kernel-smoothed reconstruction\n$$u^{\\mathrm{rec}}(x_j)=\\frac{\\sum_{i=0}^{N-1} u_i'\\,W\\!\\big(d(x_j-x_i')\\big)}{\\sum_{i=0}^{N-1} W\\!\\big(d(x_j-x_i')\\big)},$$\nwhere $W(r)=\\exp\\!\\big(-[r/(\\beta h)]^2\\big)$ is a Gaussian kernel with dimensionless smoothing parameter $\\beta>0$, and $d(r)$ is the unique representative in $(-L/2,L/2]$ of the equivalence class of $r$ modulo $L$, that is,\n$$d(r)=r-mL\\quad\\text{with}\\quad m=\\operatorname{round}\\!\\left(\\frac{r}{L}\\right),\\quad d(r)\\in(-L/2,L/2].$$\nDefine the discrete Fourier coefficient at wavenumber $k$ for a grid-sampled field $v(x_j)$ by\n$$\\hat{v}(k)=\\frac{1}{N}\\sum_{j=0}^{N-1} v(x_j)\\,e^{-i k x_j}.$$\nLet $\\hat{U}_0=\\hat{u}_0(k)$ be the coefficient of the initial field and let $\\hat{U}_1=\\widehat{u^{\\mathrm{rec}}}(k)$ be the coefficient of the reconstructed field after one time step. Define the complex ratio\n$$R=\\frac{\\hat{U}_1}{\\hat{U}_0}.$$\nUsing $R$, define the numerical phase speed\n$$c_{\\mathrm{num}}=-\\frac{\\arg(R)}{k\\,\\Delta t},$$\nand the equivalent diffusion coefficient associated with the amplitude attenuation of the mode,\n$$D_{\\mathrm{eq}}=-\\frac{1}{k^2\\,\\Delta t}\\,\\ln|R|.$$\nThe dispersion error is $c_{\\mathrm{num}}-c$. All quantities are dimensionless, and all angles are in radians. For the following test suite, compute, for each case, the dispersion error and the equivalent diffusion coefficient as defined above, using the same $W(r)$ and $d(r)$ for reconstruction. Aggregate the results in the order specified and produce a single line of output containing all numbers as a comma-separated list enclosed in square brackets.\n\nTest suite:\n- Case A (well-resolved, small displacement): $L=1$, $N=200$, $c=1$, $\\beta=0.6$, $n=3$, $\\Delta t=0.2\\,h$.\n- Case B (near-Nyquist mode, moderate displacement): $L=1$, $N=128$, $c=1$, $\\beta=0.6$, $n=60$, $\\Delta t=0.5\\,h$.\n- Case C (grid-shift displacement): $L=1$, $N=150$, $c=1$, $\\beta=0.6$, $n=10$, $\\Delta t=1.0\\,h$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order:\n$$[\\,(c_{\\mathrm{num}}-c)_{\\mathrm{A}},\\,D_{\\mathrm{eq,A}},\\,(c_{\\mathrm{num}}-c)_{\\mathrm{B}},\\,D_{\\mathrm{eq,B}},\\,(c_{\\mathrm{num}}-c)_{\\mathrm{C}},\\,D_{\\mathrm{eq,C}}\\,].$$", "solution": "The problem requires the calculation of numerical error metrics—specifically dispersion error and equivalent diffusion—for a Lagrangian particle-based method applied to the one-dimensional linear advection equation. A proper scientific analysis of such a numerical scheme does not involve a brute-force, step-by-step simulation. Instead, it demands a more fundamental analysis of the scheme's behavior on Fourier modes, as the linearity of the governing equation and the numerical operators allows for decomposition and superposition.\n\nThe complete numerical method consists of two stages: exact advection of Lagrangian particles followed by a kernel-based reconstruction of the field onto the original grid. This two-stage process can be viewed as a single linear operator $\\mathcal{L}$ that maps the initial grid-sampled field $u^0 = \\{u_j^0\\}_{j=0}^{N-1}$ to the reconstructed field after one time step, $u^1 = \\{u_j^{\\mathrm{rec}}\\}_{j=0}^{N-1}$. That is, $u^1 = \\mathcal{L}(u^0)$.\n\nThe problem is posed with an initial condition $u_0(x) = \\cos(kx)$, where $k = \\frac{2\\pi n}{L}$. On the discrete grid $x_j=j h$, this is $u_j^0 = \\cos(k x_j)$. Using Euler's identity, we can write this as $u_j^0 = \\frac{1}{2}(e^{i k x_j} + e^{-i k x_j})$. The essence of the analysis lies in determining the action of the operator $\\mathcal{L}$ on a single complex Fourier mode, $v_j = e^{i k x_j}$. Due to the spatial uniformity of the grid and the translation-invariant nature of the reconstruction kernel, the operator $\\mathcal{L}$ is a linear time-invariant (LTI) system with respect to spatial position. Therefore, its action on a Fourier mode is simple multiplication by a complex constant, known as the amplification factor or eigenvalue, $R(k)$.\n$$ \\mathcal{L}(\\{e^{i k x_j}\\}) = R(k) \\cdot \\{e^{i k x_j}\\} $$\nThe problem defines the ratio $R = \\hat{U}_1/\\hat{U}_0$, where $\\hat{U}_0$ and $\\hat{U}_1$ are the discrete Fourier coefficients of the initial and reconstructed fields, respectively, at wavenumber $k$. For the initial condition $u_0(x)=\\cos(kx)$, its discrete Fourier transform $\\hat{u}_0(k)$ is non-zero only at wavenumbers $\\pm k$. It can be shown that for $n \\in \\{1, \\dots, N/2 - 1\\}$, $\\hat{U}_0 = \\hat{u}_0(k) = 1/2$. The reconstructed field's Fourier coefficient will be $\\hat{U}_1 = \\hat{u}^{\\mathrm{rec}}(k) = \\frac{1}{2}R(k)$, making the ratio $R = R(k)$. Thus, our task reduces to finding the amplification factor $R(k)$.\n\nLet us derive the expression for $R(k)$. The value carried by the $i$-th particle is $u_i' = u_i^0$. For an input mode $e^{ikx}$, this is $u_i' = e^{ikx_i}$. The particle's new position is $x_i' = (x_i + c\\Delta t) \\bmod L$. We define $\\Delta x = c\\Delta t$.\nThe reconstructed field at a grid point $x_j$ is given by\n$$ u^{\\mathrm{rec}}(x_j) = \\frac{\\sum_{i=0}^{N-1} u_i'\\,W(d(x_j-x_i'))}{\\sum_{i=0}^{N-1} W(d(x_j-x_i'))} $$\nThe denominator is a sum of identical shifted kernels. Since the set of advected particle positions $\\{x_i'\\}$ is just a uniform grid shifted by $\\Delta x$, this sum is independent of the reconstruction point $x_j$. Let us denote this constant denominator by $B$.\n$$ B = \\sum_{i=0}^{N-1} W(d(x_j-x_i')) = \\sum_{m=0}^{N-1} W(d(mh-\\Delta x)) $$\nThe numerator for the input $u_i' = e^{ikx_i}$ is\n$$ \\text{Numerator} = \\sum_{i=0}^{N-1} e^{ikx_i} W(d(x_j - (x_i+\\Delta x))) $$\nExpressing $x_i = x_j - (j-i)h$ and letting $m=j-i \\pmod N$, we have:\n$$ \\text{Numerator} = \\sum_{m=0}^{N-1} e^{ik(x_j - mh)} W(d(mh-\\Delta x)) = e^{ikx_j} \\sum_{m=0}^{N-1} W(d(mh-\\Delta x)) e^{-ikmh} $$\nLet $G = \\sum_{m=0}^{N-1} W(d(mh-\\Delta x)) e^{-ikmh}$.\nThe reconstructed field is $u^{\\mathrm{rec}}(x_j) = \\frac{G}{B} e^{ikx_j}$. The amplification factor is therefore $R(k) = G/B$.\n$$ R = R(k) = \\frac{\\sum_{m=0}^{N-1} W(d(mh-c\\Delta t)) e^{-ikmh}}{\\sum_{m=0}^{N-1} W(d(mh-c\\Delta t))} $$\nThis expression is exact and allows for a direct and efficient computation of $R$.\n\nThe numerical phase speed $c_{\\mathrm{num}}$ and equivalent diffusion $D_{\\mathrm{eq}}$ are defined by relating the numerical amplification factor $R$ to the amplification factor of the analytical advection-diffusion equation, $e^{(-ikc_{\\mathrm{num}} - k^2 D_{\\mathrm{eq}})\\Delta t}$. Equating this with $R = |R|e^{i\\arg(R)}$ gives:\n$$ c_{\\mathrm{num}} = -\\frac{\\arg(R)}{k\\,\\Delta t} \\quad \\text{and} \\quad D_{\\mathrm{eq}} = -\\frac{\\ln|R|}{k^2\\,\\Delta t} $$\nThe dispersion error is then $c_{\\mathrm{num}}-c$.\n\nThe solution is obtained by implementing these formulas for each test case.\nFor each case, we determine the parameters $L, N, c, \\beta, n, \\Delta t$. From these, we calculate $h=L/N$, $k=2\\pi n/L$, and $\\Delta x=c\\Delta t$. We then compute the sums for the numerator $G$ and denominator $B$ over the index $m \\in \\{0, 1, ..., N-1\\}$. The ratio $R=G/B$ provides all necessary information to find the dispersion error and equivalent diffusion. The computation for all test cases proceeds based on this robust analytical framework.", "answer": "```python\n# The final implementation adheres to the specified execution environment.\n# language: Python\n# version: 3.12\n# libraries: numpy==1.23.5, scipy==1.11.4\n\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating dispersion error and equivalent diffusion\n    for a particle-based advection scheme based on an analytical formula\n    for the amplification factor.\n    \"\"\"\n\n    # Test suite as defined in the problem statement.\n    # Each tuple contains: (L, N, c, beta, n, dt_h), where dt_h is Delta t in units of h.\n    test_cases = [\n        # Case A (well-resolved, small displacement)\n        (1.0, 200, 1.0, 0.6, 3, 0.2),\n        # Case B (near-Nyquist mode, moderate displacement)\n        (1.0, 128, 1.0, 0.6, 60, 0.5),\n        # Case C (grid-shift displacement)\n        (1.0, 150, 1.0, 0.6, 10, 1.0),\n    ]\n\n    results = []\n    \n    # Per the problem, round(r/L) is used for the periodic distance function.\n    # numpy.round rounds to the nearest even integer for halves, a standard\n    # and deterministic choice.\n    def periodic_distance(r, L):\n        \"\"\"\n        Calculates the periodic distance representative in (-L/2, L/2].\n        The problem defines this via d(r) = r - m*L where m = round(r/L).\n        \"\"\"\n        return r - L * np.round(r / L)\n\n    def kernel_W(r, beta, h):\n        \"\"\"\n        Gaussian kernel function W(r) = exp(-[r/(beta*h)]^2).\n        \"\"\"\n        arg = r / (beta * h)\n        return np.exp(-arg**2)\n\n    for case in test_cases:\n        L, N, c, beta, n, dt_h = case\n        \n        # Calculate derived parameters for the case.\n        h = L / N\n        dt = dt_h * h\n        k = 2.0 * np.pi * n / L\n        delta_x = c * dt\n        \n        # Array of indices for the summation, m = 0, 1, ..., N-1.\n        m_vals = np.arange(N)\n        \n        # Calculate the arguments for the periodic distance function.\n        r_vals = m_vals * h - delta_x\n        \n        # Apply the periodic distance function to all arguments.\n        d_vals = periodic_distance(r_vals, L)\n        \n        # Evaluate the kernel function for all periodic distances.\n        W_vals = kernel_W(d_vals, beta, h)\n        \n        # The denominator B is the sum of kernel values.\n        B = np.sum(W_vals)\n        \n        # The numerator G is the discrete Fourier-like sum.\n        exp_vals = np.exp(-1j * k * m_vals * h)\n        G = np.sum(W_vals * exp_vals)\n        \n        # R is the complex amplification factor.\n        # Guard against division by zero, though unlikely with a Gaussian kernel.\n        if B == 0:\n            R = 0.0 + 0.0j\n        else:\n            R = G / B\n        \n        # Calculate numerical phase speed and equivalent diffusion.\n        # These definitions are singular if k=0 or dt=0, but test cases avoid this.\n        if k == 0 or dt == 0:\n            c_num = c\n            D_eq = 0.0\n        else:\n            c_num = -np.angle(R) / (k * dt)\n            \n            # Use a tolerance to avoid taking the log of zero.\n            abs_R = np.abs(R)\n            if abs_R > 1e-16:\n                D_eq = -np.log(abs_R) / (k**2 * dt)\n            else:\n                D_eq = np.inf\n        \n        # The dispersion error is the difference between numerical and exact phase speeds.\n        dispersion_error = c_num - c\n        \n        results.append(dispersion_error)\n        results.append(D_eq)\n\n    # Print the final results in the specified single-line format.\n    # Using scientific notation for consistent formatting and precision.\n    print(f\"[{','.join(f'{val:.10e}' for val in results)}]\")\n\nsolve()\n```", "id": "2413385"}, {"introduction": "The power of particle methods lies in their ability to handle complex geometries and large deformations, but this flexibility comes at a computational cost. For a system with $N$ particles, a naive calculation of pairwise interactions would scale as $O(N^2)$, which is prohibitive for large simulations. A critical optimization is the use of neighbor lists to ensure that each particle only interacts with those in its immediate vicinity. This practice [@problem_id:2413353] presents a direct computational experiment to investigate a common performance tuning strategy: updating these neighbor lists only every few timesteps. By implementing this and measuring the resulting trade-off between computational cost and simulation accuracy, you will gain invaluable insight into the practical art of optimizing scientific code.", "problem": "Consider a one-dimensional ensemble of $M$ identical Lagrangian particles on a periodic domain of length $L$, carrying equal mass $m$. Let the initial positions be uniformly spaced as $x_i^0 = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$ with $\\Delta x = L/M$ for $i=0,1,\\dots,M-1$. The particle trajectories are prescribed by the time-dependent map\n$$\nx_i(t) = \\left[x_i^0 + A \\sin\\!\\left(\\tfrac{2\\pi}{L} x_i^0\\right)\\sin(\\omega t)\\right] \\bmod L,\n$$\nso that all quantities are dimensionless. The pairwise distance uses the minimum image convention on $[0,L)$:\n$$\nd(x,y) = \\min\\!\\left(|x-y|,\\, L - |x-y|\\right).\n$$\nDefine the Smoothed Particle Hydrodynamics (SPH) density estimate at time $t$ for particle $i$ by\n$$\n\\rho_i(t) = \\sum_{j=0}^{M-1} m \\, W\\!\\left(d\\!\\left(x_i(t),x_j(t)\\right), h\\right),\n$$\nwhere the one-dimensional cubic spline kernel $W$ with smoothing length $h$ is\n$$\nW(r,h) = \\begin{cases}\n\\dfrac{1}{h}\\left(\\dfrac{2}{3} - q^2 + \\dfrac{1}{2}q^3\\right),  0 \\le q  1, \\\\[8pt]\n\\dfrac{1}{h}\\left(\\dfrac{1}{6}(2 - q)^3\\right),  1 \\le q  2, \\\\[8pt]\n0,  q \\ge 2,\n\\end{cases}\n\\quad \\text{with } q = \\dfrac{r}{h}.\n$$\nConsider discrete times $t_s = s\\,\\Delta t$ for $s=0,1,\\dots,S-1$. A neighbor list at step $s$ is the set, for each $i$, of indices $j$ such that $d\\!\\left(x_i(t_s),x_j(t_s)\\right)  2h$. Suppose that the neighbor list is recomputed only every $N$ steps: at steps $s$ such that $s \\equiv 0 \\pmod N$, construct the neighbor list; at other steps, reuse the most recently constructed neighbor list to evaluate $\\rho_i(t_s)$, while the positions $x_i(t_s)$ continue to evolve according to the prescribed trajectories. The self-contribution $j=i$ must always be included in $\\rho_i(t_s)$.\n\nDefine the accuracy metric for a given stride $N$ as the root-mean-square (RMS) density error over all particles and times relative to the reference case $N=1$:\n$$\nE_N = \\left(\\frac{1}{MS}\\sum_{s=0}^{S-1}\\sum_{i=0}^{M-1}\\left[\\rho_i^{(N)}(t_s)-\\rho_i^{(1)}(t_s)\\right]^2\\right)^{1/2}.\n$$\nDefine a proxy for Central Processing Unit (CPU) time as the total count $C_N$ of pairwise absolute distance evaluations over the entire simulation for stride $N$, where:\n- At each neighbor-list rebuild step, all unordered pairs $\\{i,j\\}$ with $i \\ne j$ are checked once (counted as $\\tfrac{M(M-1)}{2}$ absolute distance computations per rebuild).\n- At every time step, evaluating the density sum using the current neighbor list counts one absolute distance computation per neighbor pair used in the sum (excluding the self-contribution).\n\nAll quantities are dimensionless. Use the following fixed parameters:\n- $L = 1$, $M = 64$, $\\Delta x = L/M$, $m = 1/M$,\n- $h = 0.98\\,\\Delta x$,\n- $A = 0.25\\,\\Delta x$,\n- $\\omega = 2\\pi$,\n- $\\Delta t = 0.01$, $S = 200$.\n\nTest suite (neighbor-list stride values $N$ to evaluate):\n- Case 1: $N = 1$,\n- Case 2: $N = 2$,\n- Case 3: $N = 5$,\n- Case 4: $N = 200$.\n\nFor each case, compute the pair $[E_N, C_N]$, where $E_N$ is a float rounded to six decimal places and $C_N$ is an integer. Your program should produce a single line of output containing the results as a comma-separated list of these pairs, enclosed in square brackets, in the order of the test suite. For example:\n\"[[E_1,C_1],[E_2,C_2],[E_3,C_3],[E_4,C_4]]\"", "solution": "The problem is valid. It presents a well-defined computational experiment in the field of Smoothed Particle Hydrodynamics (SPH), a meshless method used in computational engineering and physics. The problem is scientifically grounded, mathematically consistent, and all parameters and procedures are specified unambiguously. The objective is to analyze the trade-off between computational cost and accuracy when using a common optimization technique: infrequent neighbor list updates.\n\nThe solution is obtained by performing a direct numerical simulation as described. The core of the problem involves implementing the SPH formalism for a one-dimensional system of particles with prescribed trajectories. The main steps of the algorithm are as follows:\n\n1.  **System Initialization**: All physical and numerical parameters are defined as specified: domain length $L$, number of particles $M$, particle mass $m$, smoothing length $h$, trajectory amplitude $A$ and frequency $\\omega$, and time-stepping parameters $\\Delta t$ and $S$. The initial positions of the $M$ particles, $x_i^0$, are set to be uniformly spaced on the periodic domain $[0, L)$.\n\n2.  **Implementation of Core Functions**: Three key functions are required:\n    *   **Particle Trajectory $x_i(t)$**: A function to compute the position of any particle $i$ at any given time $t$ according to the prescribed map:\n        $$x_i(t) = \\left[x_i^0 + A \\sin\\!\\left(\\tfrac{2\\pi}{L} x_i^0\\right)\\sin(\\omega t)\\right] \\bmod L$$\n    *   **Periodic Distance $d(x,y)$**: A function to calculate the pairwise distance between two points on the periodic domain using the minimum image convention:\n        $$d(x,y) = \\min\\!\\left(|x-y|,\\, L - |x-y|\\right)$$\n    *   **SPH Kernel $W(r,h)$**: A function implementing the one-dimensional cubic spline kernel. Its value depends on the normalized distance $q = r/h$:\n        $$W(r,h) = \\begin{cases} \\frac{1}{h}(\\frac{2}{3} - q^2 + \\frac{1}{2}q^3)  0 \\le q  1 \\\\ \\frac{1}{h}(\\frac{1}{6}(2-q)^3)  1 \\le q  2 \\\\ 0  q \\ge 2 \\end{cases}$$\n\n3.  **Simulation over Different Strides $N$**: The main part of the algorithm is a loop over the specified test cases for the neighbor list update stride $N \\in \\{1, 2, 5, 200\\}$. For each $N$, a full simulation of $S$ time steps is performed.\n\n4.  **Time-Stepping Loop**: For a given $N$, the simulation progresses over discrete time steps $t_s = s\\Delta t$ for $s=0, 1, \\dots, S-1$. At each step $s$:\n    *   The positions of all particles, $x_i(t_s)$, are updated.\n    *   A check `if s % N == 0` determines if the neighbor list should be rebuilt.\n    *   **Neighbor List Rebuild**: If a rebuild is necessary, all unique unordered pairs of particles $\\{i,j\\}$ are checked. The distance $d(x_i(t_s), x_j(t_s))$ is computed for each pair. If this distance is less than the kernel support cutoff $2h$, the particles are added to each other's neighbor lists. The computational cost proxy, $C_N$, is incremented by $\\frac{M(M-1)}{2}$ for this N-body check.\n    *   **Density Calculation**: Using the current neighbor list (which may be from a previous step if a rebuild did not occur), the density $\\rho_i^{(N)}(t_s)$ is calculated for each particle. The formula is:\n        $$\\rho_i^{(N)}(t_s) = m W(0, h) + \\sum_{j \\in \\text{neighbors}(i)} m W(d(x_i(t_s), x_j(t_s)), h)$$\n        The self-contribution term $m W(0,h)$ is always included. Note that the distances $d(x_i(t_s), x_j(t_s))$ must be re-evaluated at the current time $t_s$, even if the neighbor list itself is \"stale\".\n    *   **Cost Accumulation**: The cost $C_N$ is further incremented by the number of pairwise distance calculations required for the density sums. As per the problem statement, this is the total number of entries across all neighbor lists used at that time step, which represents the number of ordered pairs $(i,j)$ evaluated in the sums.\n\n5.  **Error Calculation**:\n    *   The simulation with $N=1$ serves as the high-fidelity reference. Its density history, $\\rho_i^{(1)}(t_s)$, is stored. By definition, its error is $E_1=0$.\n    *   For each subsequent simulation with $N  1$, the resulting density history $\\rho_i^{(N)}(t_s)$ is compared to the reference. The root-mean-square error $E_N$ is computed using the provided formula:\n        $$E_N = \\left(\\frac{1}{MS}\\sum_{s=0}^{S-1}\\sum_{i=0}^{M-1}\\left[\\rho_i^{(N)}(t_s)-\\rho_i^{(1)}(t_s)\\right]^2\\right)^{1/2}$$\n\n6.  **Final Output**: For each $N$, the computed pair $[E_N, C_N]$ is stored, with $E_N$ rounded to six decimal places. The final collection of these pairs is formatted into the specified string format.\n\nThe entire procedure is implemented in Python using the `NumPy` library for efficient vectorized operations on particle arrays.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SPH neighbor list accuracy vs. cost problem.\n    \"\"\"\n    # Define fixed parameters\n    L = 1.0\n    M = 64\n    dx = L / M\n    m = 1.0 / M\n    h = 0.98 * dx\n    A = 0.25 * dx\n    omega = 2.0 * np.pi\n    dt = 0.01\n    S = 200\n\n    # Test cases for neighbor-list stride N\n    test_cases = [1, 2, 5, 200]\n\n    # --- Helper Functions ---\n    def min_image_dist(p1, p2, domain_length):\n        \"\"\"\n        Calculates the minimum image distance in a periodic domain.\n        Can handle p1 being a scalar and p2 being a numpy array.\n        \"\"\"\n        delta = np.abs(p1 - p2)\n        return np.minimum(delta, domain_length - delta)\n\n    def kernel_W(r, h_val):\n        \"\"\"\n        Computes the 1D cubic spline kernel value.\n        Handles both scalar and numpy array inputs for r.\n        \"\"\"\n        was_scalar = np.isscalar(r)\n        r = np.atleast_1d(r)\n        \n        q = r / h_val\n        \n        # Branch for 0 = q  1\n        term1 = (1/h_val) * (2/3 - q**2 + 0.5 * q**3)\n        # Branch for 1 = q  2\n        term2 = (1/h_val) * (1/6) * (2 - q)**3\n        \n        w = np.where(q  1, term1, np.where(q  2, term2, 0.0))\n        \n        return w.item() if was_scalar else w\n\n    # --- Simulation Logic ---\n\n    # Initial particle positions\n    x0 = (np.arange(M) + 0.5) * dx\n\n    final_results = []\n    rho_ref_history = None\n    \n    # Pre-calculate self-contribution term for density\n    self_contrib_rho = m * kernel_W(0.0, h)\n\n    for N in test_cases:\n        cost_N = 0\n        rho_N_history = np.zeros((S, M))\n        neighbor_lists = [[] for _ in range(M)]\n\n        for s in range(S):\n            t = s * dt\n            \n            # Calculate current particle positions\n            positions = (x0 + A * np.sin(2 * np.pi / L * x0) * np.sin(omega * t)) % L\n\n            # Rebuild neighbor list if s is a multiple of N\n            if s % N == 0:\n                cost_N += M * (M - 1) // 2\n                neighbor_lists = [[] for _ in range(M)]\n                for i in range(M):\n                    for j in range(i + 1, M):\n                        dist = min_image_dist(positions[i], positions[j], L)\n                        if dist  2 * h:\n                            neighbor_lists[i].append(j)\n                            neighbor_lists[j].append(i)\n\n            # Calculate SPH density for each particle\n            current_densities = np.full(M, self_contrib_rho)\n            density_eval_cost = 0\n            for i in range(M):\n                if not neighbor_lists[i]:\n                    continue\n                \n                # Vectorized calculation for all neighbors of particle i\n                neighbor_indices = np.array(neighbor_lists[i])\n                neighbor_pos = positions[neighbor_indices]\n                \n                distances = min_image_dist(positions[i], neighbor_pos, L)\n                kernel_values = kernel_W(distances, h)\n                \n                current_densities[i] += m * np.sum(kernel_values)\n                density_eval_cost += len(neighbor_indices)\n\n            cost_N += density_eval_cost\n            rho_N_history[s, :] = current_densities\n\n        # Post-simulation processing for this N\n        if N == 1:\n            rho_ref_history = rho_N_history\n            E_N = 0.0\n        else:\n            # Calculate RMS error relative to N=1 case\n            diff_sq = (rho_N_history - rho_ref_history)**2\n            mean_sq_err = np.mean(diff_sq)\n            E_N = np.sqrt(mean_sq_err)\n\n        final_results.append([round(E_N, 6), int(cost_N)])\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join([f'[{e},{c}]' for e, c in final_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2413353"}]}