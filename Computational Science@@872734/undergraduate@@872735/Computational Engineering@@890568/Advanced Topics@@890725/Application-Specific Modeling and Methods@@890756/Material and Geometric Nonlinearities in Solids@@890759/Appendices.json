{"hands_on_practices": [{"introduction": "Many engineering materials, from steel beams to aluminum aircraft parts, exhibit plasticity—a permanent deformation after yielding. Modeling this history-dependent behavior is a cornerstone of computational mechanics. In this exercise [@problem_id:2411414], you will implement the classic 'radial return' algorithm to integrate the plastic constitutive laws for a simple one-dimensional case, providing a hands-on understanding of how stress and internal state variables are updated within a typical finite element simulation.", "problem": "Implement a one-dimensional implicit backward Euler stress update for a rate-independent von Mises plasticity model with isotropic hardening (radial return mapping), suitable for small-strain uniaxial loading. Begin from fundamental laws in solid mechanics. The implementation must update stress and internal variables for a single strain increment using backward Euler time discretization. Your program must be self-contained and compute, for each provided test case, the updated stress, plastic strain, accumulated plastic strain, and the consistent algorithmic tangent modulus.\n\nAssumptions and definitions:\n- Small strain kinematics. The total strain is denoted by $\\,\\varepsilon\\,$, the plastic strain by $\\,\\varepsilon^{p}\\,$, and the accumulated plastic strain by $\\,\\alpha\\,$.\n- Linear elastic constitutive relation in one dimension with Young’s modulus $\\,E\\,$: $\\,\\sigma = E\\left(\\varepsilon - \\varepsilon^{p}\\right)\\,$, where $\\,\\sigma\\,$ is the Cauchy stress.\n- Isotropic hardening with a constant hardening modulus $H \\ge 0$ and initial yield stress $\\sigma_{y0} > 0$. The current yield stress is $\\,\\sigma_{y}(\\alpha) = \\sigma_{y0} + H\\,\\alpha\\,$.\n- Von Mises yield function specialized to one dimension: $\\,f(\\sigma,\\alpha)=|\\sigma|-\\sigma_{y}(\\alpha)\\,$ with admissibility $f \\le 0$.\n- Associative flow with consistency. The plastic flow direction in one dimension is the sign of $\\,\\sigma\\,$.\n\nDiscretization goal:\n- Given the material parameters $\\,E\\,$ (in $\\mathrm{Pa}$), $\\,H\\,$ (in $\\mathrm{Pa}$), and $\\,\\sigma_{y0}\\,$ (in $\\mathrm{Pa}$), and the state at step $\\,n\\,$ consisting of $\\,\\varepsilon^{p}_{n}\\,$ and $\\,\\alpha_{n}\\,$ (both dimensionless), along with the prescribed total strain at step $\\,n+1\\,$, denoted $\\,\\varepsilon_{n+1}\\,$ (dimensionless), use an implicit backward Euler return-mapping scheme to compute the updated values $\\,\\sigma_{n+1}\\,$ (in $\\mathrm{Pa}$), $\\,\\varepsilon^{p}_{n+1}\\,$ (dimensionless), $\\,\\alpha_{n+1}\\,$ (dimensionless), and the consistent algorithmic tangent modulus $\\,E_{\\mathrm{tan},\\,n+1}\\,$ (in $\\mathrm{Pa}$).\n\nNumerical requirements:\n- Your algorithm must implement an elastic trial state and a radial return to the yield surface if the trial state violates admissibility. Use a numerically robust treatment of the yield condition to decide between elastic and plastic response.\n- Angles do not appear; no angle units are needed.\n- All stresses must be expressed in $\\mathrm{Pa}$ and strains are dimensionless.\n\nTest suite:\nFor each test, the input tuple is $\\,\\left(E,\\,H,\\,\\sigma_{y0},\\,\\varepsilon_{n+1},\\,\\varepsilon^{p}_{n},\\,\\alpha_{n}\\right)\\,$. Your program must compute the outputs $\\,\\left[\\sigma_{n+1},\\,\\varepsilon^{p}_{n+1},\\,\\alpha_{n+1},\\,E_{\\mathrm{tan},\\,n+1}\\right]\\,$.\n\nProvide results for the following six test cases:\n1. $\\,\\left( E=210\\times 10^{9}\\,\\mathrm{Pa},\\; H=2\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=400\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=1.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n2. $\\,\\left( E=200\\times 10^{9}\\,\\mathrm{Pa},\\; H=1\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=250\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=1.25\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n3. $\\,\\left( E=200\\times 10^{9}\\,\\mathrm{Pa},\\; H=1\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=250\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=2.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n4. $\\,\\left( E=210\\times 10^{9}\\,\\mathrm{Pa},\\; H=2\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=400\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=3.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=1.0\\times 10^{-3},\\; \\alpha_{n}=1.0\\times 10^{-3} \\right)\\,$\n5. $\\,\\left( E=210\\times 10^{9}\\,\\mathrm{Pa},\\; H=2\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=400\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=-5.0\\times 10^{-4},\\; \\varepsilon^{p}_{n}=1.0\\times 10^{-3},\\; \\alpha_{n}=1.0\\times 10^{-3} \\right)\\,$\n6. $\\,\\left( E=100\\times 10^{9}\\,\\mathrm{Pa},\\; H=0,\\; \\sigma_{y0}=100\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=2.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a list of lists:\n  $\\,\\bigl[\\,[\\sigma_{1},\\,\\varepsilon^{p}_{1},\\,\\alpha_{1},\\,E_{\\mathrm{tan},1}],\\;[\\sigma_{2},\\,\\varepsilon^{p}_{2},\\,\\alpha_{2},\\,E_{\\mathrm{tan},2}],\\;\\dotsc,\\;[\\sigma_{6},\\,\\varepsilon^{p}_{6},\\,\\alpha_{6},\\,E_{\\mathrm{tan},6}]\\,\\bigr]\\,$\n- Each $\\,\\sigma_{i}\\,$ and $\\,E_{\\mathrm{tan},i}\\,$ must be in $\\mathrm{Pa}$, and $\\,\\varepsilon^{p}_{i}\\,$ and $\\,\\alpha_{i}\\,$ must be dimensionless. Do not include any text or units in the output; only the numeric lists must be printed.", "solution": "The problem requires the implementation of an implicit, one-dimensional, rate-independent elastoplasticity model with isotropic hardening. The core of the task is the stress update procedure for a single time increment using the backward Euler method, a technique commonly known as the radial return mapping algorithm.\n\n**$1$. Fundamental Constitutive Equations**\n\nWe begin by stating the governing equations for the one-dimensional model in their continuous, rate-based form.\n\n- **Strain Decomposition**: The total strain, $\\varepsilon$, is additively decomposed into an elastic part, $\\varepsilon^{e}$, and a plastic part, $\\varepsilon^{p}$:\n$$ \\varepsilon = \\varepsilon^{e} + \\varepsilon^{p} $$\nIn rate form:\n$$ \\dot{\\varepsilon} = \\dot{\\varepsilon}^{e} + \\dot{\\varepsilon}^{p} $$\n\n- **Elastic Law**: The stress, $\\sigma$, is related to the elastic strain through a linear-elastic (Hooke's) law with Young's modulus, $E$:\n$$ \\sigma = E \\varepsilon^{e} = E (\\varepsilon - \\varepsilon^{p}) $$\nThe rate form is:\n$$ \\dot{\\sigma} = E \\dot{\\varepsilon}^{e} = E (\\dot{\\varepsilon} - \\dot{\\varepsilon}^{p}) $$\n\n- **Yield Function**: The boundary of the elastic domain is defined by the von Mises yield function, $f$, specialized for one dimension. It depends on the stress, $\\sigma$, and an internal variable, the accumulated plastic strain, $\\alpha$:\n$$ f(\\sigma, \\alpha) = |\\sigma| - \\sigma_{y}(\\alpha) \\le 0 $$\nwhere $\\sigma_{y}(\\alpha)$ is the current yield stress.\n\n- **Isotropic Hardening Law**: The current yield stress, $\\sigma_{y}(\\alpha)$, evolves with the accumulated plastic strain, $\\alpha$, according to a linear isotropic hardening rule:\n$$ \\sigma_{y}(\\alpha) = \\sigma_{y0} + H\\alpha $$\nHere, $\\sigma_{y0}$ is the initial yield stress and $H$ is the constant hardening modulus.\n\n- **Flow Rule and Hardening Evolution**: The plastic flow is associative, meaning the plastic strain rate, $\\dot{\\varepsilon}^{p}$, is normal to the yield surface. The evolution of the internal variables is governed by the plastic multiplier rate, $\\dot{\\gamma}$:\n$$ \\dot{\\varepsilon}^{p} = \\dot{\\gamma} \\frac{\\partial f}{\\partial \\sigma} = \\dot{\\gamma} \\, \\mathrm{sgn}(\\sigma) $$\n$$ \\dot{\\alpha} = \\dot{\\gamma} \\sqrt{\\left(\\frac{\\partial f}{\\partial \\sigma}\\right)^2} = \\dot{\\gamma} |\\mathrm{sgn}(\\sigma)| = \\dot{\\gamma} $$\n\n- **Karush-Kuhn-Tucker (KKT) Loading/Unloading Conditions**: These conditions govern the plastic flow:\n$$ \\dot{\\gamma} \\ge 0, \\quad f(\\sigma, \\alpha) \\le 0, \\quad \\dot{\\gamma} f(\\sigma, \\alpha) = 0 $$\nIf plastic loading occurs ($\\dot{\\gamma} > 0$), the state must remain on the yield surface ($f=0$), which implies the consistency condition $\\dot{f}=0$.\n\n**$2$. Implicit Backward Euler Discretization**\n\nWe integrate the rate equations over a time increment from $t_{n}$ to $t_{n+1}$ using the implicit backward Euler scheme. This means all rate terms are evaluated at the end of the step, $t_{n+1}$. Given the state $(\\varepsilon^{p}_{n}, \\alpha_{n})$ at step $n$ and the total strain $\\varepsilon_{n+1}$ at step $n+1$, we must find $(\\sigma_{n+1}, \\varepsilon^{p}_{n+1}, \\alpha_{n+1})$.\n\nThe discretized evolution equations are:\n$$ \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\varepsilon^{p} = \\varepsilon^{p}_{n} + \\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}) $$\n$$ \\alpha_{n+1} = \\alpha_{n} + \\Delta\\alpha = \\alpha_{n} + \\Delta\\gamma $$\nwhere $\\Delta\\gamma = \\int_{t_n}^{t_{n+1}} \\dot{\\gamma} \\, dt$ is the finite plastic multiplier increment, which must be non-negative, $\\Delta\\gamma \\ge 0$.\n\nThe stress at the end of the step is:\n$$ \\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1}) $$\n\nThe KKT conditions in discrete form become:\n$$ \\Delta\\gamma \\ge 0, \\quad f_{n+1} = |\\sigma_{n+1}| - \\sigma_{y}(\\alpha_{n+1}) \\le 0, \\quad \\Delta\\gamma f_{n+1} = 0 $$\n\n**$3$. The Return-Mapping Algorithm**\n\nThis algorithm provides a robust method to solve the discretized system. It consists of an elastic prediction followed by a plastic correction if the prediction violates the yield condition.\n\n**Step $3.1$: Elastic Predictor**\n\nFirst, we assume the step is purely elastic, which implies $\\Delta\\gamma = 0$. This gives a \"trial\" state.\nThe plastic strain and accumulated plastic strain do not change:\n$$ \\varepsilon^{p, \\mathrm{trial}}_{n+1} = \\varepsilon^{p}_{n} $$\n$$ \\alpha^{\\mathrm{trial}}_{n+1} = \\alpha_{n} $$\nThe trial stress is computed from Hooke's law:\n$$ \\sigma^{\\mathrm{trial}}_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n}) $$\n\n**Step $3.2$: Yield Check**\n\nWe check if this trial state is admissible by evaluating the yield function. The yield stress for this check is based on the state at the beginning of the increment:\n$$ \\sigma_{y,n} = \\sigma_{y0} + H\\alpha_{n} $$\nThe trial yield function value is:\n$$ f^{\\mathrm{trial}}_{n+1} = |\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n} $$\n- If $f^{\\mathrm{trial}}_{n+1} \\le 0$, the elastic assumption is correct. The material response is elastic. The final state is the trial state:\n  $$ \\sigma_{n+1} = \\sigma^{\\mathrm{trial}}_{n+1}, \\quad \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n}, \\quad \\alpha_{n+1} = \\alpha_{n} $$\n- If $f^{\\mathrm{trial}}_{n+1} > 0$, the elastic assumption is violated. Plastic deformation occurs, and a plastic correction is necessary.\n\n**Step $3.3$: Plastic Corrector**\n\nFor a plastic step, we must find $\\Delta\\gamma > 0$ such that the final state $(\\sigma_{n+1}, \\alpha_{n+1})$ lies on the updated yield surface, i.e., $f_{n+1} = 0$.\n$$ |\\sigma_{n+1}| - (\\sigma_{y0} + H\\alpha_{n+1}) = 0 $$\nSubstitute the discretized evolution equations:\n$$ |\\sigma_{n+1}| = \\sigma_{y0} + H(\\alpha_{n} + \\Delta\\gamma) = (\\sigma_{y0} + H\\alpha_{n}) + H\\Delta\\gamma = \\sigma_{y,n} + H\\Delta\\gamma $$\nNow, express $\\sigma_{n+1}$ in terms of the trial stress and $\\Delta\\gamma$:\n$$ \\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1}) = E(\\varepsilon_{n+1} - (\\varepsilon^{p}_{n} + \\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}))) $$\n$$ \\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n}) - E\\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}) = \\sigma^{\\mathrm{trial}}_{n+1} - E\\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}) $$\nA key aspect of this algorithm is that the stress sign does not change during the return, so $\\mathrm{sgn}(\\sigma_{n+1}) = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})$. Taking the absolute value:\n$$ |\\sigma_{n+1}| = |\\sigma^{\\mathrm{trial}}_{n+1}| - E\\Delta\\gamma $$\nThis equation describes the \"return\" of the stress magnitude from the trial value back to the yield surface. Equating the two expressions for $|\\sigma_{n+1}|$:\n$$ |\\sigma^{\\mathrm{trial}}_{n+1}| - E\\Delta\\gamma = \\sigma_{y,n} + H\\Delta\\gamma $$\nSolving for the plastic multiplier increment, $\\Delta\\gamma$:\n$$ |\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n} = (E+H)\\Delta\\gamma $$\n$$ \\Delta\\gamma = \\frac{|\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n}}{E+H} = \\frac{f^{\\mathrm{trial}}_{n+1}}{E+H} $$\nSince we are in the plastic case, $f^{\\mathrm{trial}}_{n+1} > 0$. As $E > 0$ and $H \\ge 0$, we correctly find $\\Delta\\gamma > 0$.\n\nOnce $\\Delta\\gamma$ is known, we update the state variables:\n$$ \\alpha_{n+1} = \\alpha_{n} + \\Delta\\gamma $$\n$$ \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\gamma \\, \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) $$\nThe updated stress $\\sigma_{n+1}$ can be computed by returning from the trial stress or by using the final yield condition. Using the latter is often more robust:\n$$ \\sigma_{n+1} = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) \\times \\sigma_{y}(\\alpha_{n+1}) = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) \\times (\\sigma_{y,n} + H\\Delta\\gamma) $$\n\n**$4$. Consistent Algorithmic Tangent Modulus**\n\nThe consistent algorithmic tangent modulus, $E_{\\mathrm{tan},n+1}$, is defined as the derivative of the final stress with respect to the final total strain, $E_{\\mathrm{tan},n+1} = \\frac{d\\sigma_{n+1}}{d\\varepsilon_{n+1}}$. It is essential for implicit finite element methods.\n\n- **Elastic Case**: If the step is elastic, $\\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})$.\n$$ E_{\\mathrm{tan},n+1} = \\frac{d}{d\\varepsilon_{n+1}} [E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})] = E $$\n\n- **Plastic Case**: If the step is plastic, we differentiate the final stress expression. A convenient form for differentiation is:\n$$ \\sigma_{n+1} = \\frac{\\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})E\\sigma_{y,n} + HE(\\varepsilon_{n+1} - \\varepsilon^{p}_n)}{E+H} $$\nDifferentiating with respect to $\\varepsilon_{n+1}$ (and treating $\\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})$ as constant for an infinitesimal change in $\\varepsilon_{n+1}$):\n$$ E_{\\mathrm{tan},n+1} = \\frac{d\\sigma_{n+1}}{d\\varepsilon_{n+1}} = \\frac{d}{d\\varepsilon_{n+1}} \\left[ \\frac{\\mathrm{const} + HE\\varepsilon_{n+1}}{E+H} \\right] = \\frac{HE}{E+H} $$\nFor perfect plasticity ($H=0$), this correctly gives $E_{\\mathrm{tan},n+1} = 0$.\n\n**$5$. Algorithm Summary for Implementation**\n\nFor each input tuple $(E, H, \\sigma_{y0}, \\varepsilon_{n+1}, \\varepsilon^{p}_{n}, \\alpha_{n})$:\n1.  Calculate trial stress: $\\sigma^{\\mathrm{trial}}_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})$.\n2.  Calculate yield stress based on previous state: $\\sigma_{y,n} = \\sigma_{y0} + H\\alpha_{n}$.\n3.  Evaluate trial yield function: $f^{\\mathrm{trial}}_{n+1} = |\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n}$.\n4.  **If $f^{\\mathrm{trial}}_{n+1} \\le 0$ (Elastic step):**\n    - $\\sigma_{n+1} = \\sigma^{\\mathrm{trial}}_{n+1}$\n    - $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n}$\n    - $\\alpha_{n+1} = \\alpha_{n}$\n    - $E_{\\mathrm{tan},n+1} = E$\n5.  **Else (Plastic step):**\n    - $\\Delta\\gamma = f^{\\mathrm{trial}}_{n+1} / (E+H)$.\n    - $\\alpha_{n+1} = \\alpha_{n} + \\Delta\\gamma$.\n    - $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\gamma \\cdot \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})$.\n    - $\\sigma_{n+1} = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) \\cdot (\\sigma_{y,n} + H\\Delta\\gamma)$.\n    - $E_{\\mathrm{tan},n+1} = (E \\cdot H) / (E+H)$.\n6.  Return the computed values $[\\sigma_{n+1}, \\varepsilon^{p}_{n+1}, \\alpha_{n+1}, E_{\\mathrm{tan},n+1}]$.\n\nThis algorithm is now ready for implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef update_stress(E, H, sig_y0, eps_n1, eps_p_n, alpha_n):\n    \"\"\"\n    Computes the updated stress, plastic strain, accumulated plastic strain,\n    and consistent tangent modulus for a 1D J2 plasticity model with\n    isotropic hardening using an implicit backward Euler return-mapping algorithm.\n\n    Args:\n        E (float): Young's modulus in Pa.\n        H (float): Hardening modulus in Pa.\n        sig_y0 (float): Initial yield stress in Pa.\n        eps_n1 (float): Total strain at step n+1 (dimensionless).\n        eps_p_n (float): Plastic strain at step n (dimensionless).\n        alpha_n (float): Accumulated plastic strain at step n (dimensionless).\n\n    Returns:\n        list: A list containing [sig_n1, eps_p_n1, alpha_n1, E_tan_n1].\n    \"\"\"\n    # Step 1: Elastic predictor (trial state)\n    sig_trial_n1 = E * (eps_n1 - eps_p_n)\n\n    # Step 2: Yield check\n    # Yield stress from the previous converged step n\n    sig_y_n = sig_y0 + H * alpha_n\n    \n    # Evaluate yield function at the trial state\n    f_trial_n1 = np.abs(sig_trial_n1) - sig_y_n\n\n    # Step 3: Determine if the step is elastic or plastic\n    if f_trial_n1 <= 0:\n        # Elastic step\n        sig_n1 = sig_trial_n1\n        eps_p_n1 = eps_p_n\n        alpha_n1 = alpha_n\n        E_tan_n1 = E\n    else:\n        # Plastic step (plastic corrector)\n        \n        # Calculate the plastic multiplier increment\n        # E > 0 and H >= 0, so E + H > 0.\n        delta_gamma = f_trial_n1 / (E + H)\n\n        # Update internal variables\n        alpha_n1 = alpha_n + delta_gamma\n        \n        # The sign of trial stress determines the direction of plastic flow.\n        # If sig_trial_n1 were 0, f_trial_n1 would be = 0, so we would be\n        # in the elastic branch. Thus, sig_trial_n1 is non-zero here.\n        sign_sig_trial = np.sign(sig_trial_n1)\n        \n        eps_p_n1 = eps_p_n + delta_gamma * sign_sig_trial\n\n        # Update stress by returning to the updated yield surface.\n        # This form is numerically stable and directly enforces the yield condition.\n        sig_n1 = sign_sig_trial * (sig_y_n + H * delta_gamma)\n\n        # Calculate the consistent algorithmic tangent modulus for the plastic case\n        E_tan_n1 = (E * H) / (E + H)\n\n    return [sig_n1, eps_p_n1, alpha_n1, E_tan_n1]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (E, H, sigma_y0, epsilon_n+1, epsilon_p_n, alpha_n)\n    test_cases = [\n        (210e9, 2e9, 400e6, 1.0e-3, 0.0, 0.0),\n        (200e9, 1e9, 250e6, 1.25e-3, 0.0, 0.0),\n        (200e9, 1e9, 250e6, 2.0e-3, 0.0, 0.0),\n        (210e9, 2e9, 400e6, 3.0e-3, 1.0e-3, 1.0e-3),\n        (210e9, 2e9, 400e6, -5.0e-4, 1.0e-3, 1.0e-3),\n        (100e9, 0.0, 100e6, 2.0e-3, 0.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current test case\n        E, H, sig_y0, eps_n1, eps_p_n, alpha_n = case\n        \n        # Calculate the updated state\n        result = update_stress(E, H, sig_y0, eps_n1, eps_p_n, alpha_n)\n        results.append(result)\n\n    # Format the output string to be exactly as specified: [[r1,r2,...],[...],...]\n    # without extra spaces.\n    inner_lists = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output_str = f\"[{','.join(inner_lists)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```", "id": "2411414"}, {"introduction": "The stiffness of a structure is not always constant; it can change dramatically depending on the stress it carries, a phenomenon known as geometric nonlinearity. This effect, which governs the buckling of columns and the vibration of taut strings, is captured computationally by the geometric stiffness matrix, $\\mathbf{K}_{\\sigma}$. This practice [@problem_id:2411426] guides you through implementing this crucial matrix for a 2D truss element and using a powerful analytical identity to verify your code, offering deep insight into how axial forces influence structural stability.", "problem": "Implement a complete and runnable program that computes the geometric stiffness matrix $K_{\\sigma}$ for a two-dimensional ($2$D) straight truss element with two nodes undergoing large rotations and small axial strains, and verifies it on a set of prescribed configurations.\n\nThe geometric stiffness matrix $K_{\\sigma}$ is defined as the initial-stress contribution to the consistent tangent stiffness obtained from the principle of virtual work for a straight bar with two translational degrees of freedom (degrees of freedom (DOF)) per node. Let the element connect node $1$ at current position $\\mathbf{x}_1 = (x_1,y_1)$ and node $2$ at current position $\\mathbf{x}_2 = (x_2,y_2)$, with current length $l = \\|\\mathbf{x}_2 - \\mathbf{x}_1\\|$ and current unit tangent $\\mathbf{t} = (\\mathbf{x}_2 - \\mathbf{x}_1)/l$. Let the initial (reference) positions be $\\mathbf{X}_1 = (X_1,Y_1)$ and $\\mathbf{X}_2 = (X_2,Y_2)$ with initial length $L_0 = \\|\\mathbf{X}_2 - \\mathbf{X}_1\\|$. The material is linear elastic with Young’s modulus $E$ and constant cross-sectional area $A$. Assume small axial strain but allow arbitrarily large rigid-body rotation of the chord. The axial force $N$ is to be computed from the axial extension as $N = (EA/L_0)\\,(l - L_0)$ and used in the geometric stiffness. All forces must be expressed in newtons and all lengths in meters.\n\nYour program must:\n- For each test case, compute the axial force $N$ in newtons from the given $E$, $A$, $L_0$, and the current configuration.\n- Construct the geometric stiffness matrix $K_{\\sigma}$ in the global coordinates of size $4\\times 4$ corresponding to the DOF ordering $(x_1,y_1,x_2,y_2)$, expressed in newtons per meter.\n- For verification, compute the Frobenius norm $\\|K_{\\sigma}\\|_F$ and compare it against the scalar $2|N|/l$ (units: newtons per meter). Report, for each test case, the scalar difference $\\Delta = \\|K_{\\sigma}\\|_F - 2|N|/l$ in newtons per meter.\n\nAngles, when specified below, are in radians. All output values must be reported in newtons per meter and rounded to $9$ decimal places.\n\nTest suite (each case is independent):\n- Case A (rigid rotation, zero extension):\n  - $E = 2.10\\times 10^{11}\\,\\mathrm{Pa}$, $A = 3.0\\times 10^{-4}\\,\\mathrm{m}^2$.\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{X}_2 = (1,0)\\,\\mathrm{m}$, so $L_0 = 1.0\\,\\mathrm{m}$.\n  - Current configuration: pure rotation by angle $\\theta = \\pi/3$ about node $1$, that is $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{x}_2 = (L_0\\cos\\theta,\\,L_0\\sin\\theta)\\,\\mathrm{m}$.\n- Case B (pure axial tension, no rotation):\n  - $E = 7.0\\times 10^{10}\\,\\mathrm{Pa}$, $A = 1.2\\times 10^{-4}\\,\\mathrm{m}^2$.\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{X}_2 = (2,0)\\,\\mathrm{m}$, so $L_0 = 2.0\\,\\mathrm{m}$.\n  - Current configuration: $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{x}_2 = (2.02,\\,0)\\,\\mathrm{m}$.\n- Case C (large rotation with compression):\n  - $E = 2.00\\times 10^{11}\\,\\mathrm{Pa}$, $A = 2.5\\times 10^{-4}\\,\\mathrm{m}^2$.\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{X}_2 = (1.5,0)\\,\\mathrm{m}$, so $L_0 = 1.5\\,\\mathrm{m}$.\n  - Current configuration: rotation by $\\theta = 1.74532925199433$ and radial shortening by $\\delta = -0.01\\,\\mathrm{m}$, that is $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$, $\\mathbf{x}_2 = ((L_0+\\delta)\\cos\\theta,\\,(L_0+\\delta)\\sin\\theta)\\,\\mathrm{m}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of cases A, B, C, for example $[\\Delta_A,\\Delta_B,\\Delta_C]$, where each $\\Delta$ is a float in newtons per meter rounded to $9$ decimal places.", "solution": "The analysis of structures undergoing large displacements but small strains requires consideration of geometric nonlinearity. The total tangent stiffness matrix, $\\mathbf{K}_T$, is the sum of the material stiffness matrix, $\\mathbf{K}_m$ (dependent on material properties and geometry), and the geometric stiffness matrix, $\\mathbf{K}_\\sigma$ (dependent on the current stress state).\n$$\n\\mathbf{K}_T = \\mathbf{K}_m + \\mathbf{K}_\\sigma\n$$\nThe problem focuses solely on the computation of $\\mathbf{K}_\\sigma$. This matrix arises from the variation of the internal force vector with respect to geometry changes. For a $2$D truss element subjected to an axial force $N$ (positive for tension, negative for compression), the geometric stiffness matrix in the global coordinate system is given by the well-established formula:\n$$\n\\mathbf{K}_{\\sigma} = \\frac{N}{l}\n\\begin{bmatrix}\n\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}  -(\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}) \\\\\n-(\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t})  \\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}\n\\end{bmatrix}\n$$\nIn this expression, $l$ is the current length of the element, $N$ is the axial force, $\\mathbf{I}$ is the $2 \\times 2$ identity matrix, and $\\mathbf{t}$ is the unit vector along the element's axis in the current configuration, defined as $\\mathbf{t} = (t_x, t_y)^T = \\frac{1}{l}(\\mathbf{x}_2 - \\mathbf{x}_1)$. The symbol $\\otimes$ denotes the tensor product.\n\nThe $2 \\times 2$ submatrix $\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}$ can be expanded. Since $\\mathbf{t}$ is a unit vector, $t_x^2 + t_y^2 = 1$.\n$$\n\\mathbf{t} \\otimes \\mathbf{t} = \\begin{bmatrix} t_x \\\\ t_y \\end{bmatrix} \\begin{bmatrix} t_x  t_y \\end{bmatrix} = \\begin{bmatrix} t_x^2  t_x t_y \\\\ t_x t_y  t_y^2 \\end{bmatrix}\n$$\nTherefore,\n$$\n\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} - \\begin{bmatrix} t_x^2  t_x t_y \\\\ t_x t_y  t_y^2 \\end{bmatrix} = \\begin{bmatrix} 1 - t_x^2  -t_x t_y \\\\ -t_x t_y  1 - t_y^2 \\end{bmatrix} = \\begin{bmatrix} t_y^2  -t_x t_y \\\\ -t_x t_y  t_x^2 \\end{bmatrix}\n$$\nLet us denote this submatrix as $\\mathbf{M}$. Then the full $4 \\times 4$ geometric stiffness matrix, corresponding to the global DOFs $(x_1, y_1, x_2, y_2)$, is:\n$$\n\\mathbf{K}_{\\sigma} = \\frac{N}{l} \\begin{bmatrix} \\mathbf{M}  -\\mathbf{M} \\\\ -\\mathbf{M}  \\mathbf{M} \\end{bmatrix} = \\frac{N}{l}\n\\begin{bmatrix}\nt_y^2  -t_x t_y  -t_y^2  t_x t_y \\\\\n-t_x t_y  t_x^2  t_x t_y  -t_x^2 \\\\\n-t_y^2  t_x t_y  t_y^2  -t_x t_y \\\\\nt_x t_y  -t_x^2  -t_x t_y  t_x^2\n\\end{bmatrix}\n$$\nThe problem requires the calculation of the Frobenius norm of this matrix, $\\|\\mathbf{K}_{\\sigma}\\|_F$. The squared Frobenius norm is the sum of the squares of all its elements.\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F^2 = \\text{tr}(\\mathbf{K}_{\\sigma}^T \\mathbf{K}_{\\sigma}) = \\sum_{i,j} (K_{\\sigma,ij})^2\n$$\nObserving the structure of $\\mathbf{K}_{\\sigma} = \\frac{N}{l} \\begin{bmatrix} \\mathbf{M}  -\\mathbf{M} \\\\ -\\mathbf{M}  \\mathbf{M} \\end{bmatrix}$, its squared Frobenius norm is:\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F^2 = \\left(\\frac{N}{l}\\right)^2 \\left( \\|\\mathbf{M}\\|_F^2 + \\|-\\mathbf{M}\\|_F^2 + \\|-\\mathbf{M}\\|_F^2 + \\|\\mathbf{M}\\|_F^2 \\right) = 4 \\left(\\frac{N}{l}\\right)^2 \\|\\mathbf{M}\\|_F^2\n$$\nLet us compute the squared Frobenius norm of the submatrix $\\mathbf{M}$:\n$$\n\\|\\mathbf{M}\\|_F^2 = (t_y^2)^2 + (-t_x t_y)^2 + (-t_x t_y)^2 + (t_x^2)^2 = t_y^4 + t_x^2 t_y^2 + t_x^2 t_y^2 + t_x^4\n$$\n$$\n\\|\\mathbf{M}\\|_F^2 = t_y^2(t_y^2 + t_x^2) + t_x^2(t_y^2 + t_x^2) = (t_y^2 + t_x^2)(t_x^2 + t_y^2) = (1)(1) = 1\n$$\nThis is because $\\mathbf{t}$ is a unit vector, so $t_x^2+t_y^2=1$.\nSubstituting this result back, we find:\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F^2 = 4 \\left(\\frac{N}{l}\\right)^2 (1) = 4 \\frac{N^2}{l^2}\n$$\nTaking the square root gives the Frobenius norm:\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F = \\sqrt{4 \\frac{N^2}{l^2}} = 2 \\frac{|N|}{l}\n$$\nThe problem asks for the computation of $\\Delta = \\|K_{\\sigma}\\|_F - 2|N|/l$. Based on this analytical derivation, the value of $\\Delta$ must be identically zero for any valid inputs. The computation serves as a numerical verification of this identity, and any non-zero result will be attributable to floating-point representation and arithmetic errors.\n\n### Computational Algorithm\n\nFor each test case, the following procedure is implemented:\n1.  Define the input parameters: $E, A$, initial nodal coordinates $\\mathbf{X}_1, \\mathbf{X}_2$, and current nodal coordinates $\\mathbf{x}_1, \\mathbf{x}_2$.\n2.  Calculate the initial length $L_0 = \\|\\mathbf{X}_2 - \\mathbf{X}_1\\|$.\n3.  Calculate the current length $l = \\|\\mathbf{x}_2 - \\mathbf{x}_1\\|$. If $l=0$, the element has collapsed, and subsequent steps are undefined. The test cases avoid this singularity.\n4.  Calculate the axial force $N = \\frac{EA}{L_0}(l - L_0)$.\n5.  Calculate the components of the current unit tangent vector, $t_x = (x_2 - x_1)/l$ and $t_y = (y_2 - y_1)/l$.\n6.  Construct the $4 \\times 4$ matrix $\\mathbf{K}_{\\sigma}$ using the derived formula.\n7.  Compute the Frobenius norm $\\|\\mathbf{K}_{\\sigma}\\|_F$ using a numerical library function.\n8.  Compute the verification scalar $V = 2|N|/l$.\n9.  Calculate the difference $\\Delta = \\|\\mathbf{K}_{\\sigma}\\|_F - V$.\n10. Store the resulting value of $\\Delta$, which is expected to be numerically close to zero.\n\nThis algorithm is applied to each of the three prescribed test cases. The final output will be a list of the computed $\\Delta$ values, rounded as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_delta(E, A, X1, X2, x1, x2):\n    \"\"\"\n    Computes the geometric stiffness matrix K_sigma and the verification difference Delta.\n\n    Args:\n        E (float): Young's modulus in Pa.\n        A (float): Cross-sectional area in m^2.\n        X1 (np.ndarray): Initial coordinates of node 1 (2-element array) in m.\n        X2 (np.ndarray): Initial coordinates of node 2 (2-element array) in m.\n        x1 (np.ndarray): Current coordinates of node 1 (2-element array) in m.\n        x2 (np.ndarray): Current coordinates of node 2 (2-element array) in m.\n\n    Returns:\n        float: The scalar difference Delta = ||K_sigma||_F - 2*|N|/l in N/m.\n    \"\"\"\n    # Calculate initial length\n    if not isinstance(X1, np.ndarray): X1 = np.array(X1, dtype=float)\n    if not isinstance(X2, np.ndarray): X2 = np.array(X2, dtype=float)\n    L0 = np.linalg.norm(X2 - X1)\n\n    # Calculate current length\n    if not isinstance(x1, np.ndarray): x1 = np.array(x1, dtype=float)\n    if not isinstance(x2, np.ndarray): x2 = np.array(x2, dtype=float)\n    dx = x2 - x1\n    l = np.linalg.norm(dx)\n\n    # Handle the case of zero current length to avoid division by zero\n    if l == 0.0:\n        # If length is zero, N is based on L0, K_sigma would be singular.\n        # As per problem context, this case is not expected.\n        # But for robustness, we can define N and state K_sigma is undefined.\n        # Here we assume it implies zero stiffness contribution.\n        return 0.0\n\n    # Calculate axial force N\n    N = (E * A / L0) * (l - L0)\n\n    # Calculate current unit tangent vector t\n    t = dx / l\n    tx, ty = t[0], t[1]\n\n    # Construct the geometric stiffness matrix K_sigma\n    # Submatrix M = [[ty^2, -tx*ty], [-tx*ty, tx^2]]\n    M = np.array([\n        [ty**2, -tx * ty],\n        [-tx * ty, tx**2]\n    ])\n    \n    # K_sigma = (N / l) * [[M, -M], [-M, M]]\n    K_sigma = (N / l) * np.block([\n        [M, -M],\n        [-M, M]\n    ])\n    \n    # Compute the Frobenius norm of K_sigma\n    norm_K_sigma = np.linalg.norm(K_sigma, 'fro')\n    \n    # Compute the verification scalar 2*|N|/l\n    verification_scalar = 2.0 * abs(N) / l\n    \n    # Compute the difference Delta\n    delta = norm_K_sigma - verification_scalar\n    \n    return delta\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, printing the results in the required format.\n    \"\"\"\n    # Case A: Rigid rotation, zero extension\n    theta_A = np.pi / 3.0\n    L0_A = 1.0\n    case_A = {\n        \"E\": 2.10e11, \"A\": 3.0e-4,\n        \"X1\": (0.0, 0.0), \"X2\": (1.0, 0.0),\n        \"x1\": (0.0, 0.0), \"x2\": (L0_A * np.cos(theta_A), L0_A * np.sin(theta_A))\n    }\n\n    # Case B: Pure axial tension, no rotation\n    case_B = {\n        \"E\": 7.0e10, \"A\": 1.2e-4,\n        \"X1\": (0.0, 0.0), \"X2\": (2.0, 0.0),\n        \"x1\": (0.0, 0.0), \"x2\": (2.02, 0.0)\n    }\n\n    # Case C: Large rotation with compression\n    L0_C = 1.5\n    delta_len_C = -0.01\n    l_C = L0_C + delta_len_C\n    theta_C = 1.74532925199433  # 100 degrees\n    case_C = {\n        \"E\": 2.00e11, \"A\": 2.5e-4,\n        \"X1\": (0.0, 0.0), \"X2\": (1.5, 0.0),\n        \"x1\": (0.0, 0.0), \"x2\": (l_C * np.cos(theta_C), l_C * np.sin(theta_C))\n    }\n\n    test_cases = [case_A, case_B, case_C]\n    \n    results = []\n    for case in test_cases:\n        delta_val = compute_delta(\n            case[\"E\"], case[\"A\"],\n            case[\"X1\"], case[\"X2\"],\n            case[\"x1\"], case[\"x2\"]\n        )\n        results.append(delta_val)\n\n    # Format the final output string as required\n    formatted_results = [f\"{res:.9f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver\nsolve()\n```", "id": "2411426"}, {"introduction": "To accurately predict the behavior of many modern materials like polymers or composites up to failure, we must account for both large deformations and material degradation simultaneously. This exercise [@problem_id:2411469] combines geometric and material nonlinearity by asking you to implement a continuum damage model within a large-strain framework. You will develop an algorithm to track damage evolution in a polymer bar under tension, learning how to manage history-dependent state variables in the presence of significant geometric changes.", "problem": "Consider a slender polymer bar of initial length $L_0$ and constant reference cross-sectional area $A_0$ subjected to uniaxial tension under displacement control. Assume uniform deformation along the bar so that the deformation gradient reduces to a scalar stretch $\\lambda$. Use a one-dimensional hyperelastic-damage model with geometric nonlinearity captured by exact kinematics and material nonlinearity captured by isotropic continuum damage.\n\nThe fundamental bases for this problem are as follows:\n- Kinematics: The stretch is $\\lambda = 1 + u/L_0$, where $u$ is the imposed end displacement in meters (m). The Green–Lagrange strain is $E = \\frac{1}{2}(\\lambda^2 - 1)$.\n- Thermodynamics and constitutive structure: Let the Helmholtz free energy per unit reference volume be $\\psi(E, D) = (1 - D)\\,\\frac{1}{2}\\,E_{\\mathrm{Y}}\\,E^2$, where $E_{\\mathrm{Y}}$ is the Young’s modulus in pascals (Pa) and $D \\in [0,1)$ is a scalar damage variable that reduces the stiffness.\n- Stress measures: The second Piola–Kirchhoff stress is $S = \\partial \\psi / \\partial E$, and the first Piola–Kirchhoff (nominal) stress is $P = \\lambda\\,S$. The axial force is $N = A_0\\,P$, reported in newtons (N).\n- Damage driving variable and history: Tension-only damage is driven by the nonnegative part of the Green–Lagrange strain, $r(E) = \\max(E, 0)$. The history variable $\\kappa$ is the maximum over the load history, updated as $\\kappa_{n+1} = \\max(\\kappa_n, r(E_{n+1}))$, with $\\kappa_0 = 0$.\n- Damage evolution: Use a smooth, thermodynamically admissible softening law with a threshold, given by\n$$\nD(\\kappa) = 1 - \\exp\\!\\Bigg(-\\left(\\frac{\\langle \\kappa - \\kappa_{\\mathrm{th}} \\rangle_+}{\\kappa_f}\\right)^m\\Bigg),\n$$\nwhere $\\kappa_{\\mathrm{th}}  0$ is a threshold Green–Lagrange strain for damage initiation, $\\kappa_f  0$ is a softening scale, $m  0$ is a shape parameter, and $\\langle x \\rangle_+ = \\max(x, 0)$. This law enforces $D = 0$ for $\\kappa \\le \\kappa_{\\mathrm{th}}$ and $D \\to 1$ as $\\kappa \\to \\infty$.\n\nTasks:\n1. Starting from the definitions above, derive explicit expressions for $S(E, D)$, $P(\\lambda, E, D)$, and $N(\\lambda, E, D)$ in terms of the input parameters and state variables. Do not assume any linearized kinematics and do not skip steps in the derivation.\n2. Design an algorithm that, for a prescribed sequence of displacement increments $\\{u_1, u_2, \\ldots, u_K\\}$, updates the history variable $\\kappa$ and the damage $D$ at each step using the definitions given above, and computes the final axial force $N$ and final damage $D$ at the last step. Assume quasi-static loading without inertia and use the exact expressions derived in Task 1.\n3. Implement the algorithm in a program that evaluates the following test suite. All inputs are in coherent International System of Units (SI): $u$ in meters (m), $L_0$ in meters (m), $A_0$ in square meters (m$^2$), $E_{\\mathrm{Y}}$ in pascals (Pa). Report axial force in newtons (N). Angles do not appear in this problem. Express every numerical output as a decimal rounded to six decimal places.\n\nTest Suite:\n- Case A (no damage, small strain): $E_{\\mathrm{Y}} = 2.0 \\times 10^9$ Pa, $A_0 = 1.0 \\times 10^{-4}$ m$^2$, $L_0 = 0.1$ m, $\\kappa_{\\mathrm{th}} = 0.02$, $\\kappa_f = 0.1$, $m = 2.0$, and displacement steps $\\{u_k\\} = \\{0.0001, 0.0002, 0.0003, 0.0005\\}$ m.\n- Case B (monotonic loading into softening): $E_{\\mathrm{Y}} = 2.0 \\times 10^9$ Pa, $A_0 = 1.0 \\times 10^{-4}$ m$^2$, $L_0 = 0.1$ m, $\\kappa_{\\mathrm{th}} = 0.02$, $\\kappa_f = 0.1$, $m = 2.0$, and displacement steps $\\{u_k\\} = \\{0.002, 0.004, 0.006, 0.01\\}$ m.\n- Case C (loading–unloading with retained damage): $E_{\\mathrm{Y}} = 1.0 \\times 10^9$ Pa, $A_0 = 1.0 \\times 10^{-4}$ m$^2$, $L_0 = 0.1$ m, $\\kappa_{\\mathrm{th}} = 0.01$, $\\kappa_f = 0.05$, $m = 1.5$, and displacement steps $\\{u_k\\} = \\{0.004, 0.002\\}$ m.\n- Case D (exactly at damage threshold): $E_{\\mathrm{Y}} = 2.0 \\times 10^9$ Pa, $A_0 = 1.0 \\times 10^{-4}$ m$^2$, $L_0 = 0.1$ m, $\\kappa_{\\mathrm{th}} = 0.02$, $\\kappa_f = 0.1$, $m = 2.0$, and a single displacement step $u_1 = L_0 \\left(\\sqrt{1 + 2 \\kappa_{\\mathrm{th}}} - 1\\right)$ m, which makes the Green–Lagrange strain equal to the threshold.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, return a two-element list with the final axial force in newtons and the final damage as $[N_{\\mathrm{final}}, D_{\\mathrm{final}}]$, both rounded to six decimal places. The overall output must therefore be a list of four lists in the order A, B, C, D, for example, $[[\\dots,\\dots],[\\dots,\\dots],[\\dots,\\dots],[\\dots,\\dots]]$.", "solution": "The solution is structured into three parts as requested: derivation of expressions, design of the computational algorithm, and implementation for the specified test suite.\n\n**Task 1: Derivation of Constitutive Expressions**\n\nThe problem provides the fundamental definitions for the kinematics, thermodynamics, and stress measures for a one-dimensional hyperelastic-damage model. We derive the explicit expressions for the stress and force, starting from the Helmholtz free energy per unit reference volume, $\\psi$. All derivations are performed using the fully nonlinear kinematic relations.\n\nThe Helmholtz free energy is given as:\n$$\n\\psi(E, D) = (1 - D)\\,\\frac{1}{2}\\,E_{\\mathrm{Y}}\\,E^2\n$$\nwhere $E$ is the Green–Lagrange strain, $D$ is the scalar damage variable, and $E_{\\mathrm{Y}}$ is the Young’s modulus.\n\n1.  **Second Piola–Kirchhoff Stress ($S$)**\n    The second Piola–Kirchhoff stress, $S$, is work-conjugate to the Green–Lagrange strain, $E$. It is obtained by differentiating the free energy $\\psi$ with respect to $E$ while holding the internal state variable $D$ constant:\n    $$\n    S = \\frac{\\partial \\psi}{\\partial E}\n    $$\n    Substituting the expression for $\\psi$:\n    $$\n    S = \\frac{\\partial}{\\partial E} \\left[ (1 - D)\\,\\frac{1}{2}\\,E_{\\mathrm{Y}}\\,E^2 \\right]\n    $$\n    The term $(1 - D)\\,\\frac{1}{2}\\,E_{\\mathrm{Y}}$ is treated as a constant during differentiation with respect to $E$:\n    $$\n    S = (1 - D)\\,\\frac{1}{2}\\,E_{\\mathrm{Y}}\\,(2E)\n    $$\n    This simplifies to the final expression for the second Piola–Kirchhoff stress:\n    $$\n    S(E, D) = (1 - D)\\,E_{\\mathrm{Y}}\\,E\n    $$\n    This equation represents a secant stiffness relationship where the effective modulus is reduced by the damage factor $(1 - D)$.\n\n2.  **First Piola–Kirchhoff Stress ($P$)**\n    The first Piola–Kirchhoff stress, also known as the nominal stress, $P$, is related to the second Piola–Kirchhoff stress $S$ through the deformation gradient. In this one-dimensional case, the deformation gradient is the stretch $\\lambda$. The relation is:\n    $$\n    P = \\lambda\\,S\n    $$\n    Substituting the derived expression for $S(E, D)$:\n    $$\n    P(\\lambda, E, D) = \\lambda\\,(1 - D)\\,E_{\\mathrm{Y}}\\,E\n    $$\n    This stress measure is force per unit *reference* area.\n\n3.  **Axial Force ($N$)**\n    The total axial force, $N$, in the bar is the first Piola–Kirchhoff stress $P$ multiplied by the constant reference cross-sectional area, $A_0$:\n    $$\n    N = A_0\\,P\n    $$\n    Substituting the derived expression for $P(\\lambda, E, D)$:\n    $$\n    N(\\lambda, E, D) = A_0\\,\\lambda\\,(1 - D)\\,E_{\\mathrm{Y}}\\,E\n    $$\n    This is the final expression for the axial force. To compute it for a given displacement $u$, one must first calculate the kinematic variables $\\lambda = 1 + u/L_0$ and $E = \\frac{1}{2}(\\lambda^2 - 1)$, and determine the current value of the damage variable $D$.\n\n**Task 2: Algorithm Design**\n\nThe problem requires an algorithm to simulate the response of the bar under a prescribed sequence of total end displacements, $\\{u^{(1)}, u^{(2)}, \\ldots, u^{(K)}\\}$. The material behavior is history-dependent due to the nature of continuum damage, which is governed by the maximum strain ever experienced. The algorithm must therefore proceed incrementally through the displacement sequence, updating state variables at each step.\n\nThe state of the system at any step $k$ is defined by the history variable $\\kappa$ and the resulting damage $D$.\n\n**Algorithm Steps:**\n\n1.  **Initialization:**\n    - Input material parameters: Young's modulus $E_{\\mathrm{Y}}$, damage threshold $\\kappa_{\\mathrm{th}}$, softening scale $\\kappa_f$, and shape parameter $m$.\n    - Input geometric parameters: initial length $L_0$ and reference area $A_0$.\n    - Input the sequence of total displacements to be applied: $\\{u^{(1)}, u^{(2)}, \\ldots, u^{(K)}\\}$.\n    - Initialize the state variables:\n        - History variable (maximum experienced strain): $\\kappa = 0$.\n        - Damage variable: $D = 0$.\n        - Current axial force: $N = 0$.\n\n2.  **Iterative State Update:**\n    For each prescribed displacement $u_{current}$ in the sequence $\\{u^{(1)}, u^{(2)}, \\ldots, u^{(K)}\\}$:\n    a.  **Compute Kinematic Variables:**\n        i.  Calculate the stretch: $\\lambda = 1 + u_{current} / L_0$.\n        ii. Calculate the Green–Lagrange strain: $E = \\frac{1}{2}(\\lambda^2 - 1)$.\n\n    b.  **Update Damage State:**\n        i.  Determine the damage driving variable, which is the non-negative part of the strain: $r = \\max(E, 0)$.\n        ii. Update the history variable $\\kappa$ by taking the maximum of its previous value and the current driver $r$: $\\kappa \\leftarrow \\max(\\kappa, r)$.\n        iii. Compute the current damage $D$ using the updated history variable $\\kappa$ and the given evolution law:\n            $$\n            D = 1 - \\exp\\!\\Bigg(-\\left(\\frac{\\max(\\kappa - \\kappa_{\\mathrm{th}}, 0)}{\\kappa_f}\\right)^m\\Bigg)\n            $$\n            This update ensures that damage is irreversible; it can only grow or remain constant upon unloading.\n\n    c.  **Compute Force:**\n        i.  Using the current values of $E$, $D$, and $\\lambda$, compute the axial force $N$ with the expression derived in Task 1:\n            $$\n            N = A_0\\,\\lambda\\,(1 - D)\\,E_{\\mathrm{Y}}\\,E\n            $$\n\n3.  **Final Result:**\n    - After iterating through all the prescribed displacements, the final values of the axial force $N$ and damage $D$ correspond to the state at the last displacement $u^{(K)}$.\n    - Report these final values, $N_{\\mathrm{final}}$ and $D_{\\mathrm{final}}$.\n\nThis algorithm correctly models the quasi-static, isothermal, and history-dependent response as specified. The use of total displacement values at each step, rather than increments, is confirmed by the \"loading–unloading\" description of Test Case C, which would be impossible to achieve with monotonic increments.\n\n**Task 3: Implementation for Test Suite**\n\nThe algorithm from Task 2 is implemented in a Python program. This program iterates through the four specified test cases, computes the final axial force $N$ and damage $D$ for each, and formats the output as required. The calculations adhere strictly to the derived nonlinear equations.", "answer": "```python\nimport numpy as np\n\ndef compute_final_state(params, u_sequence):\n    \"\"\"\n    Computes the final axial force and damage for a given sequence of displacements.\n\n    Args:\n        params (dict): A dictionary containing material and geometric parameters.\n        u_sequence (list): A list of prescribed total end displacements.\n\n    Returns:\n        tuple: A tuple containing the final axial force (N) and final damage (D).\n    \"\"\"\n    # Unpack parameters\n    E_Y = params['E_Y']\n    A_0 = params['A_0']\n    L_0 = params['L_0']\n    kappa_th = params['kappa_th']\n    kappa_f = params['kappa_f']\n    m = params['m']\n\n    # Initialize state variables\n    kappa = 0.0\n    damage = 0.0\n    force = 0.0\n    \n    if not u_sequence:\n        return 0.0, 0.0\n\n    for u_current in u_sequence:\n        # Step 1: Compute kinematics\n        stretch = 1.0 + u_current / L_0\n        green_lagrange_strain = 0.5 * (stretch**2 - 1.0)\n\n        # Step 2: Update damage state\n        # a. Damage driving variable\n        strain_driver = max(green_lagrange_strain, 0.0)\n        \n        # b. Update history variable\n        kappa = max(kappa, strain_driver)\n        \n        # c. Compute new damage value\n        if kappa  kappa_th:\n            arg = (kappa - kappa_th) / kappa_f\n            damage = 1.0 - np.exp(-(arg**m))\n        else:\n            damage = 0.0\n            \n        # Step 3: Compute stresses and force\n        # Second Piola-Kirchhoff stress\n        S = (1.0 - damage) * E_Y * green_lagrange_strain\n        # First Piola-Kirchhoff stress\n        P = stretch * S\n        # Axial force\n        force = A_0 * P\n\n    return force, damage\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the hyperelastic-damage model.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"params\": {'E_Y': 2.0e9, 'A_0': 1.0e-4, 'L_0': 0.1, 'kappa_th': 0.02, 'kappa_f': 0.1, 'm': 2.0},\n            \"u_sequence\": [0.0001, 0.0002, 0.0003, 0.0005]\n        },\n        {\n            \"name\": \"Case B\",\n            \"params\": {'E_Y': 2.0e9, 'A_0': 1.0e-4, 'L_0': 0.1, 'kappa_th': 0.02, 'kappa_f': 0.1, 'm': 2.0},\n            \"u_sequence\": [0.002, 0.004, 0.006, 0.01]\n        },\n        {\n            \"name\": \"Case C\",\n            \"params\": {'E_Y': 1.0e9, 'A_0': 1.0e-4, 'L_0': 0.1, 'kappa_th': 0.01, 'kappa_f': 0.05, 'm': 1.5},\n            \"u_sequence\": [0.004, 0.002]\n        },\n        {\n            \"name\": \"Case D\",\n            \"params\": {'E_Y': 2.0e9, 'A_0': 1.0e-4, 'L_0': 0.1, 'kappa_th': 0.02, 'kappa_f': 0.1, 'm': 2.0},\n            \"u_sequence\": [] # To be calculated\n        }\n    ]\n\n    # Calculate specific displacement for Case D\n    L0_D = test_cases[3]['params']['L_0']\n    kappa_th_D = test_cases[3]['params']['kappa_th']\n    u1_D = L0_D * (np.sqrt(1.0 + 2.0 * kappa_th_D) - 1.0)\n    test_cases[3]['u_sequence'] = [u1_D]\n\n    # Run all test cases and collect results\n    all_results = []\n    for case in test_cases:\n        N_final, D_final = compute_final_state(case['params'], case['u_sequence'])\n        all_results.append([N_final, D_final])\n\n    # Format the output string as specified\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in all_results]\n    output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(output_string)\n\nsolve()\n```", "id": "2411469"}]}