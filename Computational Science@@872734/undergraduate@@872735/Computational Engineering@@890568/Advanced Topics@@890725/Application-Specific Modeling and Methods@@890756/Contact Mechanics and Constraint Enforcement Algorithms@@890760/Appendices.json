{"hands_on_practices": [{"introduction": "Before tackling complex contact scenarios, we can practice the core idea of constraint enforcement on a simpler system: a motor with torque limits. This exercise [@problem_id:2380886] demonstrates how to calculate an \"ideal\" control action based on a desired outcome and then project it onto the set of physically achievable actions, a fundamental pattern in constraint-based modeling.", "problem": "A single degree of freedom (SDOF) motor-driven revolute joint with rotational inertia $I$ about its axis is actuated by a motor torque and subjected to an external torque. The motor torque is bounded in magnitude by a maximum allowable value $\\tau_{\\max}$ due to actuator limits. The goal is to enforce this bound while driving the joint toward a specified target angular velocity $\\omega^{\\star}$ over a single time step of duration $h$ using a principled constraint enforcement approach. The physical units are as follows: inertia in $\\mathrm{kg \\cdot m^2}$, torque in $\\mathrm{N \\cdot m}$, angular velocity in $\\mathrm{rad/s}$, and time in $\\mathrm{s}$. All angles and angular velocities must be treated in radians and $\\mathrm{rad/s}$, respectively.\n\nBase the derivation on Newton’s second law for rotation and standard time-stepping ideas. Specifically, use the fundamental law $I \\, \\dot{\\omega} = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}$, where $\\tau_{\\mathrm{ext}}$ is the external torque and $\\tau_{\\mathrm{motor}}$ is the motor torque, and a consistent discrete update of angular velocity over one step of duration $h$. Treat the motor action as a constraint-based velocity servo attempting to enforce the velocity-level condition $\\omega_{k+1} \\approx \\omega^{\\star}$ at the end of the step, with the motor torque represented as a decision variable that must obey the box constraint $-\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max}$. Connect this to a physically motivated projection or Lagrange multiplier interpretation, but do not assume any pre-derived servo or projection formulas; instead, derive the appropriate expression for the torque decision that results from the discrete dynamics and the velocity-level target.\n\nImplement a program that, for each provided test case, computes the applied motor torque that respects the bound and the resulting next-step angular velocity $\\omega_{k+1}$ using the discrete dynamics. The final program must output only the resulting next-step angular velocities, one per test case, aggregated as a single list on one line as a comma-separated list enclosed in square brackets. Each result must be rounded to six decimal places and expressed in $\\mathrm{rad/s}$.\n\nTest suite to cover typical, boundary, and edge conditions:\n- Case $1$ (unsaturated servo tracking in the presence of nonzero external torque): $I = 1.5 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.02 \\ \\mathrm{s}$, $\\omega_k = 1.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = 1.02 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 5.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = 0.5 \\ \\mathrm{N \\cdot m}$.\n- Case $2$ (strong positive saturation): $I = 0.5 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.01 \\ \\mathrm{s}$, $\\omega_k = 0.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = 10.00 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 2.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = 0.0 \\ \\mathrm{N \\cdot m}$.\n- Case $3$ (strong negative saturation opposing an external torque): $I = 1.2 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.02 \\ \\mathrm{s}$, $\\omega_k = 5.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = -5.00 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 1.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = 0.2 \\ \\mathrm{N \\cdot m}$.\n- Case $4$ (zero motor capability, external torque only): $I = 1.0 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.05 \\ \\mathrm{s}$, $\\omega_k = 2.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = 0.00 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 0.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = -0.5 \\ \\mathrm{N \\cdot m}$.\n- Case $5$ (boundary equality where the bound is just sufficient): $I = 2.0 \\ \\mathrm{kg \\cdot m^2}$, $h = 0.10 \\ \\mathrm{s}$, $\\omega_k = 1.00 \\ \\mathrm{rad/s}$, $\\omega^{\\star} = 1.50 \\ \\mathrm{rad/s}$, $\\tau_{\\max} = 10.0 \\ \\mathrm{N \\cdot m}$, $\\tau_{\\mathrm{ext}} = 0.0 \\ \\mathrm{N \\cdot m}$.\n\nYour program must:\n- For each case, compute the next-step angular velocity in $\\mathrm{rad/s}$ using a principled constraint enforcement that respects $-\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max}$.\n- Aggregate the five next-step angular velocities into a single list.\n- Print exactly one line containing that list formatted as $[\\text{v}_1,\\text{v}_2,\\text{v}_3,\\text{v}_4,\\text{v}_5]$ with each $\\text{v}_i$ rounded to six decimal places and in $\\mathrm{rad/s}$.", "solution": "The fundamental principle of rotational dynamics, Newton's second law, states that the net torque applied to a body equals its rotational inertia multiplied by its angular acceleration.\n$$ I \\dot{\\omega}(t) = \\tau_{\\text{total}}(t) $$\nThe total torque, $\\tau_{\\text{total}}$, is the sum of the external torque, $\\tau_{\\mathrm{ext}}$, and the control torque from the motor, $\\tau_{\\mathrm{motor}}$.\n$$ I \\dot{\\omega}(t) = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}} $$\nTo formulate a computational algorithm, we must discretize this continuous equation in time. A consistent and simple choice for a forward dynamics simulation is the explicit Euler integration scheme. The time derivative of angular velocity, $\\dot{\\omega}$, is approximated over a finite time step of duration $h$ as:\n$$ \\dot{\\omega} \\approx \\frac{\\omega_{k+1} - \\omega_k}{h} $$\nwhere $\\omega_k$ and $\\omega_{k+1}$ are the angular velocities at the start and end of the time step, respectively. Substituting this into the equation of motion yields the discrete-time dynamics:\n$$ I \\left( \\frac{\\omega_{k+1} - \\omega_k}{h} \\right) = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}} $$\nThe control objective is to select a motor torque, $\\tau_{\\mathrm{motor}}$, such that the resulting velocity, $\\omega_{k+1}$, matches the target velocity, $\\omega^{\\star}$. Let us first determine the ideal, unconstrained torque, denoted $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$, that would perfectly achieve this objective. We set $\\omega_{k+1} = \\omega^{\\star}$ in the discrete dynamics equation:\n$$ I \\left( \\frac{\\omega^{\\star} - \\omega_k}{h} \\right) = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}^{\\text{ideal}} $$\nSolving for this ideal motor torque gives:\n$$ \\tau_{\\mathrm{motor}}^{\\text{ideal}} = \\frac{I}{h}(\\omega^{\\star} - \\omega_k) - \\tau_{\\mathrm{ext}} $$\nThis expression represents the torque required for the system to reach the target angular velocity in a single time step under the explicit Euler discretization.\n\nHowever, the motor is subject to physical limitations, expressed as the box constraint:\n$$ -\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max} $$\nThe ideal torque, $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$, may exceed these limits. The physically correct approach is to apply the maximum possible torque in the direction of the ideal torque if saturation occurs. This corresponds to finding the torque $\\tau_{\\mathrm{motor}}$ within the allowable interval $[-\\tau_{\\max}, \\tau_{\\max}]$ that is closest to $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$. This is a projection of the ideal torque onto the valid set. Mathematically, this operation is a clamping or saturation function:\n$$ \\tau_{\\mathrm{motor}} = \\text{clamp}(\\tau_{\\mathrm{motor}}^{\\text{ideal}}, -\\tau_{\\max}, \\tau_{\\max}) \\equiv \\max(-\\tau_{\\max}, \\min(\\tau_{\\mathrm{motor}}^{\\text{ideal}}, \\tau_{\\max})) $$\nThis formulation is not ad-hoc; it is the correct solution to the constrained optimization problem of minimizing the deviation from the ideal torque, $J(\\tau) = (\\tau - \\tau_{\\mathrm{motor}}^{\\text{ideal}})^2$, subject to the inequality constraints $\\tau \\le \\tau_{\\max}$ and $-\\tau \\le \\tau_{\\max}$. The solution via Karush-Kuhn-Tucker (KKT) conditions confirms that this projection is the optimal choice.\n\nWith the constrained, realizable motor torque $\\tau_{\\mathrm{motor}}$ determined, we can now calculate the actual resulting angular velocity at the next time step, $\\omega_{k+1}$. We rearrange the discrete dynamics equation to solve for $\\omega_{k+1}$:\n$$ \\omega_{k+1} = \\omega_k + \\frac{h}{I} (\\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}) $$\nIf $\\tau_{\\mathrm{motor}} = \\tau_{\\mathrm{motor}}^{\\text{ideal}}$ (i.e., no saturation), substituting this back into the equation correctly yields $\\omega_{k+1} = \\omega^{\\star}$. If saturation occurs, $\\tau_{\\mathrm{motor}}$ will be either $\\tau_{\\max}$ or $-\\tau_{\\max}$, and $\\omega_{k+1}$ will be the velocity achieved under maximum actuator effort.\n\nThe final algorithm is as follows:\n1. For a given set of parameters $\\{I, h, \\omega_k, \\omega^{\\star}, \\tau_{\\max}, \\tau_{\\mathrm{ext}}\\}$, calculate the ideal motor torque $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$.\n2. Apply the saturation constraint to find the actual motor torque $\\tau_{\\mathrm{motor}} = \\text{clamp}(\\tau_{\\mathrm{motor}}^{\\text{ideal}}, -\\tau_{\\max}, \\tau_{\\max})$.\n3. Calculate the new angular velocity $\\omega_{k+1}$ using the constrained torque $\\tau_{\\mathrm{motor}}$.\nThis procedure is applied to each test case to find the corresponding next-step angular velocity.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the next-step angular velocity for a motor-driven revolute joint,\n    enforcing motor torque limits using a principled constraint method.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (I, h, omega_k, omega_star, tau_max, tau_ext)\n    test_cases = [\n        # Case 1: Unsaturated servo tracking\n        (1.5, 0.02, 1.00, 1.02, 5.0, 0.5),\n        # Case 2: Strong positive saturation\n        (0.5, 0.01, 0.00, 10.00, 2.0, 0.0),\n        # Case 3: Strong negative saturation opposing external torque\n        (1.2, 0.02, 5.00, -5.00, 1.0, 0.2),\n        # Case 4: Zero motor capability, external torque only\n        (1.0, 0.05, 2.00, 0.00, 0.0, -0.5),\n        # Case 5: Boundary equality where the bound is just sufficient\n        (2.0, 0.10, 1.00, 1.50, 10.0, 0.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        I, h, omega_k, omega_star, tau_max, tau_ext = case\n\n        # Step 1: Calculate the ideal motor torque to reach omega_star in one step.\n        # This is derived from I * (omega_k+1 - omega_k) / h = tau_ext + tau_motor\n        # by setting omega_k+1 = omega_star and solving for tau_motor.\n        tau_motor_ideal = (I / h) * (omega_star - omega_k) - tau_ext\n        \n        # Step 2: Enforce the motor torque constraint. The applied torque is the\n        # ideal torque projected (clamped) onto the valid interval [-tau_max, tau_max].\n        tau_motor_actual = np.clip(tau_motor_ideal, -tau_max, tau_max)\n        \n        # Step 3: Calculate the actual next-step angular velocity using the\n        # constrained torque and the discrete dynamics equation.\n        # omega_k+1 = omega_k + (h / I) * (tau_ext + tau_motor)\n        omega_next = omega_k + (h / I) * (tau_ext + tau_motor_actual)\n        \n        results.append(omega_next)\n\n    # Format the final output as a single-line, comma-separated list of values\n    # rounded to six decimal places, enclosed in square brackets.\n    # The format string '{r:.6f}' ensures rounding to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2380886"}, {"introduction": "Building on the projection concept, we now apply it to a classic non-smooth dynamics problem: a mass moving within a clearance gap. This practice [@problem_id:2380890] introduces unilateral constraints, which can be active or inactive depending on the system's state, and shows how to handle the resulting impacts using a simple but effective predictor-corrector time-stepping scheme.", "problem": "Consider a one-degree-of-freedom model for the relative displacement in a loose joint with symmetric clearance. Let the scalar coordinate be $x(t)$ in meters, mass be $m$ in kilograms, and an externally applied constant force $F$ in newtons. The joint has a dead-zone clearance of half-width $\\delta$ in meters, meaning no constraint reaction is present while $x(t) \\in [-\\delta,\\delta]$. When the gap to a stop closes, an impact occurs and a reaction impulse enforces non-penetration. Assume frictionless impacts with a normal coefficient of restitution $e \\in [0,1]$.\n\nThe dynamics are governed by Newton's second law with unilateral constraints written via complementarity. Let the upper and lower gaps be $g_u(x) = \\delta - x$ and $g_\\ell(x) = \\delta + x$, and let the corresponding nonnegative Lagrange multipliers (normal reactions) be $\\lambda_u(t) \\ge 0$ and $\\lambda_\\ell(t) \\ge 0$. The equations are\n$$\nm\\,\\ddot{x}(t) = F - \\lambda_u(t) + \\lambda_\\ell(t),\n$$\n$$\ng_u(x(t)) \\ge 0,\\quad \\lambda_u(t) \\ge 0,\\quad g_u(x(t))\\,\\lambda_u(t) = 0,\n$$\n$$\ng_\\ell(x(t)) \\ge 0,\\quad \\lambda_\\ell(t) \\ge 0,\\quad g_\\ell(x(t))\\,\\lambda_\\ell(t) = 0.\n$$\nThus, within the dead-zone $x(t) \\in (-\\delta,\\delta)$ one has $\\lambda_u(t)=\\lambda_\\ell(t)=0$, and no constraint force acts. When a stop is active (gap zero), the normal reaction enforces non-penetration. Across an instantaneous impact at a stop, let $v^{-}$ and $v^{+}$ denote the pre- and post-impact velocities at the contact configuration. The normal impact law is Newton’s law of restitution,\n$$\nv^{+} = -\\,e\\,v^{-},\n$$\napplied when the body is hitting a stop with approaching velocity $v^{-}$ pointing outward along the normal of that stop.\n\nStarting from these principles, derive a first-order time-stepping algorithm that advances the state $(x,v)$ using a fixed time step $\\Delta t$ seconds by:\n- taking a free-flight update with no constraint force over $[t_n,t_{n+1}]$,\n- then enforcing non-penetration at most once per step by projecting the position to the nearest active boundary and correcting the velocity via an impulse consistent with the above impact law if the motion is outward at impact.\n\nYour program must implement the following algorithm in purely mathematical terms:\n- Free-flight semi-implicit update based on Newton's second law $m\\,\\dot{v} = F$ with constant $F$ over the step to obtain a tentative $(x^{\\mathrm{free}},v^{\\mathrm{free}})$.\n- If $x^{\\mathrm{free}} \\in [-\\delta,\\delta]$, accept $(x^{\\mathrm{free}},v^{\\mathrm{free}})$.\n- If $x^{\\mathrm{free}} > \\delta$, set $x^{+} = \\delta$. If $v^{\\mathrm{free}} > 0$, apply the impact law to set $v^{+} = -\\,e\\,v^{\\mathrm{free}}$; otherwise set $v^{+} = v^{\\mathrm{free}}$.\n- If $x^{\\mathrm{free}}  -\\delta$, set $x^{+} = -\\delta$. If $v^{\\mathrm{free}}  0$, apply the impact law to set $v^{+} = -\\,e\\,v^{\\mathrm{free}}$; otherwise set $v^{+} = v^{\\mathrm{free}}$.\n\nUse the following initial condition correction at $t=0$: if $x(0)$ lies outside $[-\\delta,\\delta]$, project it to the nearest boundary and, if the initial velocity is outward relative to that boundary, apply the same impact law immediately.\n\nYour task is to implement this time-stepping scheme and compute the final state $(x(T),v(T))$ for each test case given below. All physical quantities must be in the International System of Units (SI): meters, kilograms, seconds, and newtons. Express angles, if any, in radians. The outputs must be numerical values in meters for positions and meters per second for velocities. Round each numerical output value to $6$ decimal places.\n\nThe fixed parameters common to all tests are:\n- Mass $m = 1.0$ kilograms.\n- Clearance half-width $\\delta = 0.01$ meters.\n- Time step $\\Delta t = 0.0005$ seconds.\n- Final time $T = 0.2$ seconds.\n\nThe test suite consists of four cases that exercise different behaviors:\n- Case A (no contact within horizon): $x(0)=0.0$ meters, $v(0)=0.0$ meters per second, $F=0.2$ newtons, $e=0.6$.\n- Case B (single impact at the upper stop with partial rebound): $x(0)=0.0$ meters, $v(0)=0.0$ meters per second, $F=1.0$ newtons, $e=0.5$.\n- Case C (single impact at the lower stop, elastic): $x(0)=0.0$ meters, $v(0)=0.0$ meters per second, $F=-1.0$ newtons, $e=1.0$.\n- Case D (initial penetration resolved by projection, then rest): $x(0)=0.015$ meters, $v(0)=0.0$ meters per second, $F=0.0$ newtons, $e=0.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of lists, each inner list being the final state $[x(T),v(T)]$ for one case in the order A, B, C, D. The exact required format is:\n\"[ [x_A,v_A],[x_B,v_B],[x_C,v_C],[x_D,v_D] ]\"\nwith each number rounded to $6$ decimal places.", "solution": "The objective is to determine the final state $(x(T), v(T))$ of a one-degree-of-freedom mass-particle system by numerically integrating its equations of motion. The system is subject to a constant external force and unilateral constraints defining a clearance gap.\n\nThe system's dynamics are governed by Newton's second law for the position $x(t)$:\n$$\nm \\ddot{x}(t) = F + F_{\\text{contact}}(t)\n$$\nwhere $m$ is the mass, $F$ is the constant external force, and $F_{\\text{contact}}(t)$ represents the reaction force from the constraints. The constraints are defined by a clearance of half-width $\\delta$, such that the admissible positions are $x(t) \\in [-\\delta, \\delta]$. The contact force is zero when the particle is strictly inside the gap, i.e., $x(t) \\in (-\\delta, \\delta)$. At the boundaries $x=\\delta$ and $x=-\\delta$, contact occurs. The problem models this contact using an instantaneous impact governed by Newton's law of restitution, with a coefficient of restitution $e$.\n\nA numerical solution is constructed using a fixed time-step $\\Delta t$. The state of the system at time $t_n = n \\Delta t$ is given by the pair $(x_n, v_n)$, representing position and velocity. The algorithm to advance the state from $t_n$ to $t_{n+1}$ is a two-step predictor-corrector method.\n\n1.  **Free-Flight Prediction Step**: First, a tentative state $(x^{\\mathrm{free}}, v^{\\mathrm{free}})$ at $t_{n+1}$ is calculated by ignoring the constraints and integrating the motion under the external force $F$ alone. The acceleration is constant, $a = F/m$. A semi-implicit Euler scheme is specified:\n    $$\n    v^{\\mathrm{free}} = v_n + a \\Delta t\n    $$\n    $$\n    x^{\\mathrm{free}} = x_n + v^{\\mathrm{free}} \\Delta t\n    $$\n\n2.  **Constraint Enforcement (Correction) Step**: The predicted position $x^{\\mathrm{free}}$ is checked against the admissible region $[-\\delta, \\delta]$. If the position is outside this region (a state of penetration), it is projected back onto the nearest boundary, and the velocity is corrected to model the impact. The logic is as follows:\n\n    - If $x^{\\mathrm{free}} \\in [-\\delta, \\delta]$ (no penetration): The free-flight prediction is accepted.\n      $$\n      x_{n+1} = x^{\\mathrm{free}}, \\quad v_{n+1} = v^{\\mathrm{free}}\n      $$\n\n    - If $x^{\\mathrm{free}} > \\delta$ (penetration of the upper boundary): The position is projected to $x_{n+1} = \\delta$. The velocity is updated according to the impact law, which applies only if the predicted velocity $v^{\\mathrm{free}}$ corresponds to an approach towards the boundary ($v^{\\mathrm{free}} > 0$).\n      $$\n      x_{n+1} = \\delta, \\quad v_{n+1} = \\begin{cases} -e \\, v^{\\mathrm{free}}  \\text{if } v^{\\mathrm{free}} > 0 \\\\ v^{\\mathrm{free}}  \\text{if } v^{\\mathrm{free}} \\le 0 \\end{cases}\n      $$\n\n    - If $x^{\\mathrm{free}}  -\\delta$ (penetration of the lower boundary): The position is projected to $x_{n+1} = -\\delta$. The velocity is updated, applying the impact law for an approaching velocity ($v^{\\mathrm{free}}  0$).\n      $$\n      x_{n+1} = -\\delta, \\quad v_{n+1} = \\begin{cases} -e \\, v^{\\mathrm{free}}  \\text{if } v^{\\mathrm{free}}  0 \\\\ v^{\\mathrm{free}}  \\text{if } v^{\\mathrm{free}} \\ge 0 \\end{cases}\n      $$\n\n**Initial Condition Correction**: Before the time-stepping loop begins, the initial state $(x(0), v(0))$ is checked. If $x(0)$ is already in a state of penetration, it is immediately corrected using the same projection and impact logic as in the correction step described above.\n\nThis algorithm is implemented and executed for each of the four specified test cases. The simulation runs from $t=0$ to the final time $T=0.2$ seconds, using the fixed parameters: mass $m=1.0$ kg, clearance half-width $\\delta=0.01$ meters, and time step $\\Delta t=0.0005$ seconds. This corresponds to a total of $N = T/\\Delta t = 400$ integration steps. The code provided in the final answer calculates the state $(x(T), v(T))$ for each case, rounds the numerical values to $6$ decimal places, and formats the output as specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a first-order time-stepping algorithm for a 1-DOF system with clearance\n    and computes the final state for several test cases.\n    \"\"\"\n\n    # Fixed physical and simulation parameters\n    m = 1.0  # mass in kg\n    delta = 0.01  # clearance half-width in m\n    dt = 0.0005  # time step in s\n    T = 0.2  # final time in s\n\n    # Test suite: (initial position x0, initial velocity v0, force F, coefficient of restitution e)\n    test_cases = [\n        # Case A: No contact\n        {'x0': 0.0, 'v0': 0.0, 'F': 0.2, 'e': 0.6},\n        # Case B: Single impact, partial rebound\n        {'x0': 0.0, 'v0': 0.0, 'F': 1.0, 'e': 0.5},\n        # Case C: Single impact, elastic\n        {'x0': 0.0, 'v0': 0.0, 'F': -1.0, 'e': 1.0},\n        # Case D: Initial penetration, no force\n        {'x0': 0.015, 'v0': 0.0, 'F': 0.0, 'e': 0.0},\n    ]\n\n    all_final_states = []\n\n    # Calculate the total number of steps\n    num_steps = int(T / dt)\n\n    for case in test_cases:\n        x, v = case['x0'], case['v0']\n        F, e = case['F'], case['e']\n\n        # Step 0: Initial condition correction\n        if x > delta:\n            x = delta\n            # Apply impact law if velocity is outward\n            if v > 0:\n                v = -e * v\n        elif x  -delta:\n            x = -delta\n            # Apply impact law if velocity is outward\n            if v  0:\n                v = -e * v\n        \n        # Calculate constant acceleration\n        accel = F / m\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            # Step 1: Free-flight prediction (semi-implicit Euler)\n            v_free = v + accel * dt\n            x_free = x + v_free * dt\n\n            # Step 2: Constraint enforcement (projection and correction)\n            if x_free > delta:\n                x = delta\n                if v_free > 0:  # Impact condition\n                    v = -e * v_free\n                else:  # Already separating\n                    v = v_free\n            elif x_free  -delta:\n                x = -delta\n                if v_free  0:  # Impact condition\n                    v = -e * v_free\n                else:  # Already separating\n                    v = v_free\n            else:  # No penetration\n                x = x_free\n                v = v_free\n        \n        # Store the final state, rounded to 6 decimal places\n        all_final_states.append([round(x, 6), round(v, 6)])\n\n    # Format the final output string as per the problem specification\n    # e.g., [[x_A,v_A],[x_B,v_B],...] -> \"[[x_A,v_A],[x_B,v_B],...]\"\n    result_strings = [f\"[{state[0]},{state[1]}]\" for state in all_final_states]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2380890"}, {"introduction": "This final practice synthesizes the previous concepts to tackle a true frictional contact problem. You will implement the Projected Gauss-Seidel (PGS) algorithm [@problem_id:2380912], a widely used iterative method for solving the Linear Complementarity Problem (LCP) that governs frictional contact. This exercise will guide you through the process of handling both normal and tangential contact constraints, covering phenomena like sticking, sliding, and separation.", "problem": "You are to implement a Projected Gauss–Seidel (PGS) solver for a single-contact, three-dimensional frictional contact time-stepping problem formulated as a Linear Complementarity Problem (LCP) with Coulomb friction. The physical setting is a rigid block of mass $m$ moving in three-dimensional space under gravity, possibly contacting a horizontal plane whose unit normal is $\\mathbf{n} = [0,1,0]^{\\mathsf{T}}$. The block’s translational motion only is considered (rotations are ignored), and the time-stepping scheme is implicit in contact impulses and explicit in external forces over a time step of duration $h$.\n\nStart from the following fundamental principles and core definitions:\n- Newton’s Second Law in impulse form over a time step: $\\mathbf{M} (\\mathbf{v}^{+} - \\mathbf{v}^{-}) = h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p}$, where $\\mathbf{M}$ is the mass matrix, $\\mathbf{v}^{-}$ and $\\mathbf{v}^{+}$ are pre- and post-step velocities, $\\mathbf{f}_{\\mathrm{ext}}$ is the external force, $\\mathbf{J}$ is the contact Jacobian, and $\\mathbf{p}$ is the contact impulse.\n- Unilateral impenetrability with complementarity at the velocity level: $0 \\le p_{n} \\perp \\gamma_{n}^{+} \\ge 0$, where $p_{n}$ is the normal impulse and $\\gamma_{n}^{+}$ is the post-step normal relative velocity.\n- Coulomb friction model via a friction cone: $\\|\\mathbf{p}_{t}\\| \\le \\mu p_{n}$, with $\\mathbf{p}_{t}$ the tangential impulse and $\\mu$ the coefficient of friction, and the maximum dissipation principle enforcing sticking ($\\gamma_{t}^{+} = \\mathbf{0}$) when interior to the cone and sliding with projection when on the cone’s boundary.\n\nFor a single contact between the block and the plane, define a local contact frame with basis vectors $\\{\\mathbf{n}, \\mathbf{t}_{1}, \\mathbf{t}_{2}\\}$, where $\\mathbf{t}_{1} = [1,0,0]^{\\mathsf{T}}$ and $\\mathbf{t}_{2} = [0,0,1]^{\\mathsf{T}}$. The translational mass matrix is $\\mathbf{M} = m \\mathbf{I}_{3}$. Using impulse–momentum discretization, let $\\mathbf{v}^{+} = \\mathbf{v}^{-} + \\mathbf{M}^{-1} (h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p})$. The relative velocity at the contact in the local frame is $\\boldsymbol{\\gamma}^{+} = \\mathbf{J} \\mathbf{v}^{+}$. Show that, for this setting, the effective Delassus operator (also called the inverse mass at the contact) reduces to $\\mathbf{A} = \\mathbf{J}\\mathbf{M}^{-1}\\mathbf{J}^{\\mathsf{T}} = \\frac{1}{m}\\mathbf{I}_{3}$ and that the PGS iteration can be carried out on the $3 \\times 1$ impulse vector $\\mathbf{p} = [p_{n}, p_{t1}, p_{t2}]^{\\mathsf{T}}$ using:\n- A normal complementarity update: $p_{n} \\leftarrow \\max\\{0, p_{n} - \\gamma_{n} / A_{nn}\\}$,\n- A tangential unconstrained gradient step followed by projection onto the friction disk of radius $\\mu p_{n}$: $\\mathbf{p}_{t} \\leftarrow \\operatorname{Proj}_{\\|\\cdot\\| \\le \\mu p_{n}}(\\mathbf{p}_{t} - \\mathbf{A}_{tt}^{-1}\\boldsymbol{\\gamma}_{t})$,\nwhere $\\boldsymbol{\\gamma} = \\mathbf{A}\\mathbf{p} + \\mathbf{c}$, and $\\mathbf{c}$ aggregates known terms from pre-step velocities and external forces.\n\nUse gravity $\\mathbf{f}_{\\mathrm{ext}} = m \\mathbf{g}$ with $\\mathbf{g} = [0, -g, 0]^{\\mathsf{T}}$ and $g > 0$. The time step is $h > 0$. The local “free” contact velocity vector is $\\mathbf{c} = \\mathbf{J} \\left(\\mathbf{v}^{-} + \\mathbf{M}^{-1} h \\mathbf{f}_{\\mathrm{ext}}\\right)$, which in this setup evaluates to $\\mathbf{c} = [v_{y}^{-} - h g, v_{x}^{-}, v_{z}^{-}]^{\\mathsf{T}}$. After solving for $\\mathbf{p}$ using PGS, compute the post-step velocity\n$$\n\\mathbf{v}^{+} = \\mathbf{v}^{-} + \\mathbf{M}^{-1} h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{M}^{-1}\\mathbf{J}^{\\mathsf{T}}\\mathbf{p} = \\mathbf{v}^{-} + [0, -h g, 0]^{\\mathsf{T}} + \\frac{1}{m}[p_{t1}, p_{n}, p_{t2}]^{\\mathsf{T}}.\n$$\n\nYour task:\n- Implement a basic Projected Gauss–Seidel (PGS) solver for this single-contact problem as a complete program. Use a fixed iteration count (for example, $N_{\\mathrm{iter}} = 50$) and terminate early if the change in $\\mathbf{p}$ is below a small tolerance (for example, $10^{-12}$). Your implementation must be general enough to handle any admissible inputs for $m$, $h$, $g$, $\\mu$, and $\\mathbf{v}^{-}$, though for this problem you will only solve the specified test suite.\n- For each test case below, compute and report four quantities: the post-step normal velocity $v^{+}_{y}$ in $\\mathrm{m/s}$, the post-step tangential speed $\\sqrt{(v^{+}_{x})^{2} + (v^{+}_{z})^{2}}$ in $\\mathrm{m/s}$, the normal impulse $p_{n}$ in $\\mathrm{N\\cdot s}$, and the magnitude of the tangential impulse $\\sqrt{p_{t1}^{2} + p_{t2}^{2}}$ in $\\mathrm{N\\cdot s}$. Express all outputs in the specified units and round each reported number to exactly six decimal places.\n\nAngle units are not applicable. Percentages are not applicable.\n\nTest suite (all quantities in the International System of Units):\n- Case $1$ (sliding): $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.5$, $\\mathbf{v}^{-} = [2.0,-1.0,0.0]^{\\mathsf{T}}$.\n- Case $2$ (sticking): $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 1.0$, $\\mathbf{v}^{-} = [0.05,-0.01,0.0]^{\\mathsf{T}}$.\n- Case $3$ (frictionless): $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.0$, $\\mathbf{v}^{-} = [1.0,-0.2,0.0]^{\\mathsf{T}}$.\n- Case $4$ (separating, no contact): $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.5$, $\\mathbf{v}^{-} = [0.0,0.5,0.0]^{\\mathsf{T}}$.\n- Case $5$ (heavy block, mixed): $m = 1000.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.6$, $\\mathbf{v}^{-} = [3.0,-0.3,4.0]^{\\mathsf{T}}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a list of four rounded floats in the order $[v^{+}_{y}, \\sqrt{(v^{+}_{x})^{2} + (v^{+}_{z})^{2}}, p_{n}, \\sqrt{p_{t1}^{2} + p_{t2}^{2}}]$. For example, an output with two hypothetical results would look like $[[a_{1},b_{1},c_{1},d_{1}],[a_{2},b_{2},c_{2},d_{2}]]$ with each entry rounded to six decimals.", "solution": "The objective is to implement a Projected Gauss-Seidel (PGS) solver for a single-contact frictional problem. The problem is formulated as a Linear Complementarity Problem (LCP) where the unknown is the contact impulse $\\mathbf{p} = [p_n, p_{t1}, p_{t2}]^{\\mathsf{T}}$.\n\nFirst, we define the LCP system. The post-step relative contact velocity $\\boldsymbol{\\gamma}^{+}$ is related to the impulse $\\mathbf{p}$ by the affine relation $\\boldsymbol{\\gamma}^{+} = \\mathbf{A}\\mathbf{p} + \\mathbf{c}$, where $\\mathbf{A}$ is the Delassus operator and $\\mathbf{c}$ is the free-velocity term. The problem states that for this specific system, $\\mathbf{A} = \\frac{1}{m}\\mathbf{I}_3$, a diagonal matrix. The free velocity vector $\\mathbf{c}$ collects all terms independent of the unknown impulse $\\mathbf{p}$ and is given by $\\mathbf{c} = [v_{y}^{-} - h g, v_{x}^{-}, v_{z}^{-}]^{\\mathsf{T}}$. Let us denote the components of $\\mathbf{c}$ as $c_n = v_{y}^{-} - h g$, $c_{t1} = v_{x}^{-}$, and $c_{t2} = v_{z}^{-}$.\n\nThe PGS method is an iterative algorithm that solves the LCP by sequentially updating components of the solution vector $\\mathbf{p}$ and projecting them to satisfy the constraints. We initialize the impulse vector to zero, $\\mathbf{p}^{(0)} = \\mathbf{0}$. For each iteration $k$, we compute a new estimate $\\mathbf{p}^{(k+1)}$ based on $\\mathbf{p}^{(k)}$. The iteration uses a block-wise update strategy for the normal and tangential components.\n\n**1. Normal Impulse Update:**\nThe first step in the PGS sweep updates the normal impulse $p_n$. The complementarity condition for the normal direction is $0 \\le p_n \\perp \\gamma_n \\ge 0$. The PGS update performs a gradient-descent-like step and projects the result onto the feasible set, which for $p_n$ is the non-negative real line.\nThe update rule is $p_n^{(k+1)} = \\max\\{0, p_n^{(k)} - A_{nn}^{-1}\\gamma_n^{(k)}\\}$. The relative velocity $\\gamma_n$ is computed using the most recent impulse values available.\n$$ \\gamma_n = (\\mathbf{A}\\mathbf{p}^{(k)} + \\mathbf{c})_n = A_{nn}p_n^{(k)} + c_n = \\frac{1}{m}p_n^{(k)} + c_n $$\nSubstituting this into the update rule gives:\n$$ p_n^{(k+1)} = \\max\\left\\{0, p_n^{(k)} - \\frac{\\frac{1}{m}p_n^{(k)} + c_n}{1/m}\\right\\} = \\max\\left\\{0, p_n^{(k)} - (p_n^{(k)} + m c_n)\\right\\} = \\max\\{0, -m c_n\\} $$\nThis shows that for this diagonal system, the normal impulse converges to its final value in a single step. However, the implementation follows the iterative form as specified for generality.\n\n**2. Tangential Impulse Update:**\nNext, we update the tangential impulse vector $\\mathbf{p}_t = [p_{t1}, p_{t2}]^{\\mathsf{T}}$. The Coulomb friction law states that the tangential impulse must lie within a disk of radius $R = \\mu p_n$ in the tangential plane: $\\|\\mathbf{p}_t\\| \\le \\mu p_n$. In a Gauss-Seidel fashion, we use the most recently computed normal impulse, $p_n^{(k+1)}$, to define the radius of the friction disk for the current iteration. The update is performed via an unconstrained step followed by a projection onto this disk.\nThe unconstrained update for the tangential block is: $\\mathbf{p}_t^{unc} = \\mathbf{p}_t^{(k)} - \\mathbf{A}_{tt}^{-1}\\boldsymbol{\\gamma}_t^{(k)}$.\nThe tangential relative velocity is $\\boldsymbol{\\gamma}_t^{(k)} = \\mathbf{A}_{tt}\\mathbf{p}_t^{(k)} + \\mathbf{c}_t$. Given $\\mathbf{A}_{tt} = \\frac{1}{m}\\mathbf{I}_2$, its inverse is $\\mathbf{A}_{tt}^{-1} = m\\mathbf{I}_2$.\n$$ \\mathbf{p}_t^{unc} = -m\\mathbf{c}_t $$\nThe final tangential impulse is obtained by projecting $\\mathbf{p}_t^{unc}$ onto the disk of radius $R = \\mu p_n^{(k+1)}$:\n$$ \\mathbf{p}_t^{(k+1)} = \\operatorname{Proj}_{\\|\\cdot\\| \\le R}(\\mathbf{p}_t^{unc}) $$\nThe projection is defined as:\n$$ \\mathbf{p}_t^{(k+1)} = \\begin{cases} \\mathbf{p}_t^{unc}  \\text{if } \\|\\mathbf{p}_t^{unc}\\| \\le R \\\\ R \\frac{\\mathbf{p}_t^{unc}}{\\|\\mathbf{p}_t^{unc}\\|}  \\text{if } \\|\\mathbf{p}_t^{unc}\\| > R \\end{cases} $$\nThis corresponds to sticking if the required frictional impulse is within the cone, and sliding otherwise.\n\nThe iterative process is repeated for a fixed number of iterations, $N_{\\mathrm{iter}}$, or until the change in the impulse vector, measured by the infinity norm $\\|\\mathbf{p}^{(k+1)} - \\mathbf{p}^{(k)}\\|_{\\infty}$, falls below a specified tolerance $\\epsilon$.\n\n**3. Post-processing:**\nAfter the PGS solver converges to the final impulse $\\mathbf{p}$, the post-step velocity $\\mathbf{v}^{+}$ is calculated using the impulse-momentum relation:\n$$ \\mathbf{v}^{+} = \\mathbf{v}^{-} + \\mathbf{M}^{-1} (h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p}) $$\nWith the provided definitions, this becomes:\n$$ \\begin{bmatrix} v_x^{+} \\\\ v_y^{+} \\\\ v_z^{+} \\end{bmatrix} = \\begin{bmatrix} v_x^{-} \\\\ v_y^{-} \\\\ v_z^{-} \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ -h g \\\\ 0 \\end{bmatrix} + \\frac{1}{m} \\begin{bmatrix} p_{t1} \\\\ p_n \\\\ p_{t2} \\end{bmatrix} $$\nFrom this, the required output quantities are computed:\n- Post-step normal velocity: $v_y^{+}$\n- Post-step tangential speed: $\\sqrt{(v_x^{+})^2 + (v_z^{+})^2}$\n- Normal impulse: $p_n$\n- Magnitude of tangential impulse: $\\sqrt{p_{t1}^2 + p_{t2}^2}$\n\nThe implementation will follow this logic for each test case provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified test cases for the frictional contact problem.\n    \"\"\"\n    \n    # Test suite (m, h, g, mu, v_minus)\n    # All quantities are in SI units.\n    test_cases = [\n        (1.0, 0.01, 9.81, 0.5, np.array([2.0, -1.0, 0.0])),  # Case 1 (sliding)\n        (1.0, 0.01, 9.81, 1.0, np.array([0.05, -0.01, 0.0])),  # Case 2 (sticking)\n        (1.0, 0.01, 9.81, 0.0, np.array([1.0, -0.2, 0.0])),    # Case 3 (frictionless)\n        (1.0, 0.01, 9.81, 0.5, np.array([0.0, 0.5, 0.0])),   # Case 4 (separating)\n        (1000.0, 0.01, 9.81, 0.6, np.array([3.0, -0.3, 4.0])),# Case 5 (heavy block, mixed)\n    ]\n\n    results = []\n    for case in test_cases:\n        m, h, g, mu, v_minus = case\n        result = run_pgs_solver(m, h, g, mu, v_minus)\n        # Round each number in the result to 6 decimal places\n        rounded_result = [round(x, 6) for x in result]\n        results.append(rounded_result)\n\n    # Format the final output string as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_pgs_solver(m, h, g, mu, v_minus):\n    \"\"\"\n    Implements the Projected Gauss-Seidel solver for a single-contact LCP.\n\n    Args:\n        m (float): Mass of the block.\n        h (float): Time step duration.\n        g (float): Acceleration due to gravity.\n        mu (float): Coefficient of friction.\n        v_minus (np.ndarray): Pre-step velocity vector [vx, vy, vz].\n\n    Returns:\n        list: A list of four floats:\n              [v_plus_y, tangential_speed_plus, p_n, p_t_magnitude].\n    \"\"\"\n    \n    # Solver parameters\n    N_iter = 50\n    tolerance = 1e-12\n\n    # Pre-computation of the free velocity vector 'c'\n    # c = [v_y^- - h*g, v_x^-, v_z^-]^T\n    c_n = v_minus[1] - h * g\n    c_t = np.array([v_minus[0], v_minus[2]])\n    \n    # Initialize impulse vector p = [p_n, p_t1, p_t2]^T\n    p = np.zeros(3)\n    \n    # Delassus operator is diagonal A = (1/m) * I\n    # inv_A_nn = m, inv_A_tt = m * I_2\n    inv_A_nn = m\n    \n    # PGS iteration loop\n    for _ in range(N_iter):\n        p_old = p.copy()\n        \n        # 1. Normal impulse update (component p_n)\n        # gamma_n = (1/m)*p_n + c_n\n        gamma_n = (1.0 / m) * p[0] + c_n\n        # p_n_new = max(0, p_n - inv_A_nn * gamma_n)\n        p[0] = max(0.0, p[0] - inv_A_nn * gamma_n)\n        \n        # 2. Tangential impulse update (block p_t)\n        # The update is based on the most recent p_n\n        friction_radius = mu * p[0]\n        \n        # Unconstrained tangential impulse: p_t_unc = -inv_A_tt * c_t = -m * c_t\n        p_t_unc = -m * c_t\n        norm_p_t_unc = np.linalg.norm(p_t_unc)\n        \n        # Project onto friction disk\n        if norm_p_t_unc = friction_radius:\n            # Sticking\n            p[1:] = p_t_unc\n        else:\n            # Sliding\n            if norm_p_t_unc > 1e-15: # Avoid division by zero\n                p[1:] = friction_radius * p_t_unc / norm_p_t_unc\n            else:\n                p[1:] = np.zeros(2)\n\n        # 3. Check for convergence\n        # The change is measured using the infinity norm\n        change = np.linalg.norm(p - p_old, np.inf)\n        if change  tolerance:\n            break\n            \n    p_n = p[0]\n    p_t = p[1:]\n    \n    # Post-processing: Compute post-step velocity v_plus\n    # v+ = v- + [0, -hg, 0]^T + (1/m)*[p_t1, p_n, p_t2]^T\n    v_plus = np.zeros(3)\n    v_plus[0] = v_minus[0] + p_t[0] / m\n    v_plus[1] = v_minus[1] - h * g + p_n / m\n    v_plus[2] = v_minus[2] + p_t[1] / m\n    \n    # Calculate required output quantities\n    v_plus_y = v_plus[1]\n    tangential_speed_plus = np.linalg.norm(np.array([v_plus[0], v_plus[2]]))\n    p_t_magnitude = np.linalg.norm(p_t)\n    \n    return [v_plus_y, tangential_speed_plus, p_n, p_t_magnitude]\n\nsolve()\n```", "id": "2380912"}]}