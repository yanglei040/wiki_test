{"hands_on_practices": [{"introduction": "In any computational solid mechanics analysis, the result at a given point is the Cauchy stress tensor, a $3 \\times 3$ matrix $\\boldsymbol{\\sigma}$. To assess whether a material might fail, we must translate this matrix into more physically intuitive quantities. This practice focuses on the fundamental post-processing task of calculating principal stresses and their directions, which represent the maximum and minimum normal stresses at a point and are critical for applying failure criteria. By implementing the eigenvalue decomposition of the stress tensor, you will build a core skill for interpreting the results of any stress analysis simulation [@problem_id:2378068].", "problem": "You are given a set of symmetric Cauchy stress tensors at selected points of a three-dimensional ($3$D) solid component subjected to static loading. Each stress state is represented by a real, symmetric $3\\times 3$ matrix $\\boldsymbol{\\sigma}$ with entries in Pascal (Pa). For each stress tensor, determine the first principal stress direction, defined as the unit vector $\\boldsymbol{v}_{1}\\in\\mathbb{R}^{3}$ associated with the maximum principal stress. The first principal stress direction is the direction $\\boldsymbol{v}_{1}$ for which the traction vector on a plane with unit normal $\\boldsymbol{n}=\\boldsymbol{v}_{1}$ is colinear with $\\boldsymbol{n}$ and the corresponding scalar traction (principal stress) is maximal among all such directions.\n\nAdopt the following convention so that the direction is uniquely reported:\n- Normalize the direction to have unit Euclidean norm.\n- To fix its sign, let $\\tau=10^{-12}$. Find the first component among $(v_{x},v_{y},v_{z})$ whose absolute value exceeds $\\tau$; if that component is negative, multiply the vector by $-1$. If no component exceeds $\\tau$ (which cannot occur for a nonzero unit vector), report $\\left[1,0,0\\right]$.\n\nReport each direction as a list of its Cartesian components $\\left[v_{x},v_{y},v_{z}\\right]$, each rounded to six decimal places. The components are dimensionless.\n\nTest Suite (each tensor is given in Pascal (Pa); entries are exact):\n- Case $1$:\n  $\\boldsymbol{\\sigma}_{1}=\\begin{bmatrix}\n  1.20\\times 10^{8}  3.0\\times 10^{7}  0.0\\\\\n  3.0\\times 10^{7}  8.0\\times 10^{7}  1.0\\times 10^{7}\\\\\n  0.0  1.0\\times 10^{7}  6.0\\times 10^{7}\n  \\end{bmatrix}$\n- Case $2$:\n  $\\boldsymbol{\\sigma}_{2}=\\begin{bmatrix}\n  5.0\\times 10^{7}  0.0  0.0\\\\\n  0.0  2.0\\times 10^{8}  0.0\\\\\n  0.0  0.0  1.0\\times 10^{8}\n  \\end{bmatrix}$\n- Case $3$:\n  $\\boldsymbol{\\sigma}_{3}=\\begin{bmatrix}\n  0.0  5.0\\times 10^{7}  0.0\\\\\n  5.0\\times 10^{7}  0.0  0.0\\\\\n  0.0  0.0  -1.0\\times 10^{7}\n  \\end{bmatrix}$\n- Case $4$:\n  $\\boldsymbol{\\sigma}_{4}=\\begin{bmatrix}\n  1.01\\times 10^{8}  1.0\\times 10^{6}  2.0\\times 10^{6}\\\\\n  1.0\\times 10^{6}  1.00\\times 10^{8}  1.5\\times 10^{6}\\\\\n  2.0\\times 10^{6}  1.5\\times 10^{6}  1.02\\times 10^{8}\n  \\end{bmatrix}$\n- Case $5$:\n  $\\boldsymbol{\\sigma}_{5}=\\begin{bmatrix}\n  -1.00\\times 10^{8}  0.0  0.0\\\\\n  0.0  -5.0\\times 10^{7}  0.0\\\\\n  0.0  0.0  -7.5\\times 10^{7}\n  \\end{bmatrix}$\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is itself a bracketed triple for the corresponding test case, with no spaces. For example, a valid format is $\\left[[0.577350,0.577350,0.577350],[\\dots]\\right]$.", "solution": "The problem as stated is subjected to validation.\n\n**Step 1: Extracted Givens**\n- The problem is set in the context of $3$D solid mechanics.\n- Input consists of a set of symmetric $3 \\times 3$ Cauchy stress tensors, $\\boldsymbol{\\sigma}$, with real entries in units of Pascals (Pa).\n- The task is to find the first principal stress direction, $\\boldsymbol{v}_{1} \\in \\mathbb{R}^{3}$, for each tensor.\n- The first principal stress direction is defined as the unit eigenvector associated with the maximum principal stress.\n- A uniqueness convention is prescribed:\n    1. The vector $\\boldsymbol{v}_{1}$ must be normalized to unit Euclidean norm.\n    2. A sign-fixing rule is given: with a tolerance $\\tau = 10^{-12}$, find the first component of the vector $(v_{x}, v_{y}, v_{z})$ whose absolute value exceeds $\\tau$. If this component is negative, the entire vector must be multiplied by $-1$.\n- The output for each direction is a list of its Cartesian components, $[v_{x}, v_{y}, v_{z}]$, with each component rounded to six decimal places.\n- Five specific stress tensors, $\\boldsymbol{\\sigma}_{1}$ through $\\boldsymbol{\\sigma}_{5}$, are provided as test cases.\n\n**Step 2: Validation of Givens**\nThe problem is evaluated against the validation criteria:\n- **Scientifically Grounded:** The problem is a fundamental exercise in linear elasticity and continuum mechanics. The Cauchy stress tensor, its symmetry, principal stresses, and principal directions are core, well-established concepts. The problem is scientifically sound.\n- **Well-Posed:** For any real symmetric matrix, such as the stress tensor $\\boldsymbol{\\sigma}$, there exist real eigenvalues (principal stresses) and a corresponding set of orthogonal eigenvectors (principal directions). The problem asks for the direction associated with the maximum eigenvalue. Since all provided test cases result in distinct eigenvalues, the principal directions are unique up to sign. The provided sign-fixing convention resolves this ambiguity, making the problem well-posed.\n- **Objective:** The problem is formulated with precise mathematical language and quantitative data. The procedure for determining the final vector is algorithmic and unambiguous. No subjective interpretation is required.\n- **Completeness and Consistency:** All necessary information, including the stress tensors and a clear rule for uniqueness, is provided. The setup is self-contained and free of contradictions. The units (Pa) and magnitudes of stress are physically plausible for engineering materials.\n\n**Step 3: Verdict and Action**\nThe problem is valid as it is scientifically grounded, well-posed, objective, and self-contained. A solution will be provided.\n\nThe task is to find the first principal direction for a given Cauchy stress tensor $\\boldsymbol{\\sigma}$. This is equivalent to finding the eigenvector corresponding to the largest eigenvalue of the matrix $\\boldsymbol{\\sigma}$. The relationship between a principal stress $\\sigma_{p}$ and its corresponding principal direction $\\boldsymbol{v}$ is defined by the eigenvalue problem:\n$$\n\\boldsymbol{\\sigma}\\boldsymbol{v} = \\sigma_{p}\\boldsymbol{v}\n$$\nHere, $\\sigma_{p}$ is an eigenvalue and $\\boldsymbol{v}$ is the corresponding eigenvector of $\\boldsymbol{\\sigma}$. Since the Cauchy stress tensor is, by the principle of conservation of angular momentum, a symmetric matrix ($\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{T}$), the spectral theorem for real symmetric matrices guarantees that it has three real eigenvalues (the principal stresses $\\sigma_{1}, \\sigma_{2}, \\sigma_{3}$) and a set of three mutually orthogonal eigenvectors (the principal directions $\\boldsymbol{v}_{1}, \\boldsymbol{v}_{2}, \\boldsymbol{v}_{3}$).\n\nThe first principal stress is defined as the algebraically largest eigenvalue, typically denoted $\\sigma_{1}$, where $\\sigma_{1} \\ge \\sigma_{2} \\ge \\sigma_{3}$. The corresponding first principal direction is its associated eigenvector, $\\boldsymbol{v}_{1}$.\n\nThe computational procedure to solve this for each given stress tensor is as follows:\nFirst, we solve the eigenvalue problem. This is a standard task in numerical linear algebra. We will employ a robust eigensolver, such as the one available in the `NumPy` library for Python, specifically `numpy.linalg.eigh`. This function is optimized for symmetric (or Hermitian) matrices and has the convenient property of returning the eigenvalues sorted in ascending order. Consequently, the maximum eigenvalue, $\\sigma_{1}$, will be the last element in the returned array of eigenvalues. The corresponding eigenvector, $\\boldsymbol{v}_{1}$, will be the last column in the returned matrix of eigenvectors.\n\nSecond, we must adhere to the problem's uniqueness convention. The `numpy.linalg.eigh` function returns eigenvectors that are already normalized to have a unit Euclidean norm, satisfying the first part of the convention. The second part is a sign-fixing rule. An eigenvector $\\boldsymbol{v}$ is equivalent to $-\\boldsymbol{v}$ as they both define the same direction (eigenspace). To ensure a single representation, we apply the specified procedure. Let the computed unit eigenvector be $\\boldsymbol{v} = [v_{x}, v_{y}, v_{z}]^{T}$, and let the tolerance be $\\tau = 10^{-12}$.\n1. Examine the first component, $v_{x}$. If $|v_{x}| > \\tau$, its sign determines the sign of the entire vector. If $v_{x}  0$, we set the final vector to $-\\boldsymbol{v}$. Otherwise, we use $\\boldsymbol{v}$ as is.\n2. If $|v_{x}| \\le \\tau$, we proceed to examine the second component, $v_{y}$. If $|v_{y}| > \\tau$, its sign determines the orientation. If $v_{y}  0$, we use $-\\boldsymbol{v}$. Otherwise, we use $\\boldsymbol{v}$.\n3. If both $|v_{x}| \\le \\tau$ and $|v_{y}| \\le \\tau$, we examine the third component, $v_{z}$. As the vector has unit norm, $|v_{z}|$ must be greater than $\\tau$. If $v_{z}  0$, we use $-\\boldsymbol{v}$. Otherwise, we use $\\boldsymbol{v}$.\nThis procedure ensures that the reported vector is unique.\n\nFinally, the components of the resulting unique direction vector are rounded to six decimal places, as required. This entire process is systematically applied to each of the five given stress tensors, $\\boldsymbol{\\sigma}_{1}$ through $\\boldsymbol{\\sigma}_{5}$. The results are then aggregated into the specified final output format.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the first principal stress direction for a set of Cauchy stress tensors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each stress tensor is given in units of Pascal (Pa).\n    test_cases = [\n        # Case 1\n        np.array([\n            [1.20e8, 3.0e7, 0.0],\n            [3.0e7, 8.0e7, 1.0e7],\n            [0.0, 1.0e7, 6.0e7]\n        ]),\n        # Case 2\n        np.array([\n            [5.0e7, 0.0, 0.0],\n            [0.0, 2.0e8, 0.0],\n            [0.0, 0.0, 1.0e8]\n        ]),\n        # Case 3\n        np.array([\n            [0.0, 5.0e7, 0.0],\n            [5.0e7, 0.0, 0.0],\n            [0.0, 0.0, -1.0e7]\n        ]),\n        # Case 4\n        np.array([\n            [1.01e8, 1.0e6, 2.0e6],\n            [1.0e6, 1.00e8, 1.5e6],\n            [2.0e6, 1.5e6, 1.02e8]\n        ]),\n        # Case 5\n        np.array([\n            [-1.00e8, 0.0, 0.0],\n            [0.0, -5.0e7, 0.0],\n            [0.0, 0.0, -7.5e7]\n        ])\n    ]\n\n    results = []\n    tau = 1e-12\n\n    for sigma in test_cases:\n        # For a symmetric matrix sigma, np.linalg.eigh returns eigenvalues in\n        # ascending order and the corresponding normalized eigenvectors as columns\n        # of the returned matrix.\n        eigenvalues, eigenvectors = np.linalg.eigh(sigma)\n\n        # The first principal stress is the maximum eigenvalue.\n        # Its direction is the corresponding eigenvector. Due to the ascending sort,\n        # this is the last column of the eigenvectors matrix.\n        v1 = eigenvectors[:, -1]\n\n        # Apply the uniqueness convention to fix the sign of the direction vector.\n        # The eigenvector is already of unit norm.\n        # Find the first component with an absolute value greater than tau.\n        # If this component is negative, flip the sign of the entire vector.\n        for i in range(3):\n            if abs(v1[i]) > tau:\n                if v1[i]  0:\n                    v1 = -v1\n                break\n        \n        # Format the components by rounding to six decimal places,\n        # ensuring trailing zeros are present.\n        v1_formatted = [f\"{comp:.6f}\" for comp in v1]\n\n        # Assemble the formatted vector into a string representation of a list.\n        result_str = f\"[{','.join(v1_formatted)}]\"\n        results.append(result_str)\n\n    # Print the final list of results in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2378068"}, {"introduction": "The finite element method (FEM) relies on the idea of dividing a complex domain into simple building blocks called elements. The accuracy of the entire simulation hinges on the correct behavior of these individual elements. This hands-on practice introduces you to the patch test, a fundamental procedure used to verify the correctness of a finite element formulation. You will implement a test to confirm that your element can exactly reproduce a simple, constant strain state, which is a necessary condition for ensuring the method will converge to the correct answer on more complex problems as the mesh is refined [@problem_id:2378079].", "problem": "You are asked to implement a complete, runnable program that checks whether a custom four-node isoparametric quadrilateral finite element passes the constant-strain patch test in the context of small-strain, linear-elasticity, plane-stress analysis. The program must be self-contained and produce a single line of output for a specified test suite. The purpose is to verify that the element reproduces an affine displacement field and yields constant strains within numerical tolerance.\n\nBegin from first principles suitable for computational solid mechanics:\n- The balance of linear momentum in statics without body forces is $\\,\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}\\,$ in a domain $\\,\\Omega\\,$, with $\\,\\boldsymbol{\\sigma}\\,$ the Cauchy stress tensor. Small-strain kinematics gives the infinitesimal strain tensor $\\,\\boldsymbol{\\varepsilon} = \\frac{1}{2}(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\mathsf{T}})\\,$, where $\\,\\mathbf{u}(\\mathbf{x})\\,$ is the displacement field.\n- For plane stress linear elasticity, the constitutive relation at each point is $\\,\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}\\,$, with $\\,\\mathbf{D}\\,$ the symmetric material matrix defined by Young’s modulus $\\,E\\,$ and Poisson’s ratio $\\,\\nu\\,$.\n- A Galerkin finite element discretization of the weak form leads to the linear system $\\,\\mathbf{K}\\mathbf{d} = \\mathbf{f}\\,$, where $\\,\\mathbf{K} = \\sum_{e} \\int_{A_e} \\mathbf{B}^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}\\,\\mathrm{d}A\\,$, $\\,\\mathbf{d}\\,$ is the vector of nodal displacements, $\\,\\mathbf{f}\\,$ is the external force vector, $\\,A_e\\,$ is the element area, and $\\,\\mathbf{B}\\,$ maps nodal displacements to engineering strains $\\,\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx},\\,\\varepsilon_{yy},\\,\\gamma_{xy}]^{\\mathsf{T}}\\,$ with $\\,\\gamma_{xy} = \\partial u/\\partial y + \\partial v/\\partial x\\,$. The mapping and integrals are to be carried out using isoparametric bilinear shape functions on a bi-unit square with standard two-by-two Gaussian quadrature.\n\nYour program must:\n- Implement a four-node quadrilateral isoparametric element with bilinear interpolation in natural coordinates $\\,(\\xi,\\eta)\\,$ and use $\\,2 \\times 2\\,$ Gaussian quadrature with points at $\\,\\xi,\\eta \\in \\{\\pm 1/\\sqrt{3}\\}\\,$ and unit weights. The Jacobian mapping from $\\,(\\xi,\\eta)\\,$ to physical coordinates $\\, (x,y)\\,$ must be computed per quadrature point to evaluate $\\,\\mathbf{B}\\,$ and $\\,\\det \\mathbf{J}\\,$.\n- Assemble the global stiffness matrix $\\,\\mathbf{K}\\,$ for each test-case mesh and impose Dirichlet boundary conditions by prescribing displacements on the outer boundary of the mesh. No body forces are present, and no Neumann tractions are applied. The program should determine the exterior boundary nodes algorithmically from the mesh connectivity by identifying edges that belong to only one element.\n- Prescribe an affine displacement field on the boundary of the computational domain\n  $$u(x,y) = \\gamma + \\alpha\\,x + \\beta\\,y,\\quad v(x,y) = \\zeta + \\delta\\,x + \\varepsilon\\,y,$$\n  where $\\,u\\,$ and $\\,v\\,$ are the $x$- and $y$-components of displacement, respectively. This field induces a constant strain\n  $$\\varepsilon_{xx} = \\alpha,\\quad \\varepsilon_{yy} = \\varepsilon,\\quad \\gamma_{xy} = \\beta + \\delta.$$\n  Use the constants $\\,\\alpha = 1.0\\times 10^{-3},\\,\\beta = -2.0\\times 10^{-4},\\,\\delta = 3.0\\times 10^{-4},\\,\\varepsilon = 5.0\\times 10^{-4},\\,\\gamma = 2.5\\times 10^{-3},\\,\\zeta = -1.1\\times 10^{-3}\\,$. Coordinates are in meters and displacements must be evaluated in meters.\n- Solve the linear system for free degrees of freedom and compute:\n  1. The maximum absolute nodal displacement error\n     $$e_u = \\max_{i}\\, \\left\\lvert d_i - d_i^{\\text{exact}} \\right\\rvert,$$\n     where $\\,d_i^{\\text{exact}}\\,$ are the exact nodal displacements from the affine field.\n  2. The maximum absolute deviation of computed engineering strains at Gaussian points from the target constant strain\n     $$e_{\\varepsilon} = \\max_{e,\\,g,\\,k} \\left\\lvert \\varepsilon_{k}^{(e,g)} - \\varepsilon_{k}^{\\text{target}} \\right\\rvert,$$\n     with $\\,k \\in \\{xx,yy,xy\\}\\,$, element index $\\,e\\,$, and Gauss point index $\\,g\\,$.\n- Material parameters for all test cases: Young’s modulus $\\,E = 210 \\times 10^{9}\\,$ pascals and Poisson’s ratio $\\,\\nu = 0.30\\,$ (plane stress). Although physical units are specified, the required outputs are dimensionless booleans.\n\nA test case is said to pass the constant-strain patch test if both $\\,e_u \\le 10^{-10}\\,$ and $\\,e_{\\varepsilon} \\le 10^{-10}\\,$.\n\nTest Suite (three meshes; all coordinates in meters; element connectivities use zero-based node indices in counterclockwise order):\n- Case $1$ (single distorted quadrilateral):\n  - Nodes:\n    - $0$: $(0.0,\\,0.0)$\n    - $1$: $(1.2,\\,0.1)$\n    - $2$: $(1.0,\\,1.1)$\n    - $3$: $(0.1,\\,0.9)$\n  - Elements:\n    - $[0,\\,1,\\,2,\\,3]$\n- Case $2$ ($2 \\times 2$ mesh of the unit square):\n  - Nodes:\n    - $0$: $(0.0,\\,0.0)$, $1$: $(0.5,\\,0.0)$, $2$: $(1.0,\\,0.0)$\n    - $3$: $(0.0,\\,0.5)$, $4$: $(0.5,\\,0.5)$, $5$: $(1.0,\\,0.5)$\n    - $6$: $(0.0,\\,1.0)$, $7$: $(0.5,\\,1.0)$, $8$: $(1.0,\\,1.0)$\n  - Elements:\n    - $[0,\\,1,\\,4,\\,3]$, $[1,\\,2,\\,5,\\,4]$, $[3,\\,4,\\,7,\\,6]$, $[4,\\,5,\\,8,\\,7]$\n- Case $3$ (parallelogram split into two quadrilaterals with an interior edge):\n  - Corner points: $\\mathrm{A}=(0.0,\\,0.0)$, $\\mathrm{B}=(2.0,\\,0.3)$, $\\mathrm{C}=(2.2,\\,1.2)$, $\\mathrm{D}=(0.2,\\,0.9)$.\n  - Additional points at mid-edge of $\\mathrm{AB}$ and $\\mathrm{DC}$: $\\mathrm{M}_{\\mathrm{AB}}=(1.0,\\,0.15)$, $\\mathrm{M}_{\\mathrm{DC}}=(1.2,\\,1.05)$.\n  - Nodes:\n    - $0$: $\\mathrm{A}$, $1$: $\\mathrm{M}_{\\mathrm{AB}}$, $2$: $\\mathrm{B}$, $3$: $\\mathrm{D}$, $4$: $\\mathrm{M}_{\\mathrm{DC}}$, $5$: $\\mathrm{C}$\n  - Elements:\n    - $[0,\\,1,\\,4,\\,3]$, $[1,\\,2,\\,5,\\,4]$\n\nYour program must, for each test case, compute the pass or fail boolean and produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, e.g., $[\\,\\text{True},\\text{False},\\text{True}\\,]$. No other output or text is permitted. The booleans reflect, respectively for the three cases, whether both $\\,e_u \\le 10^{-10}\\,$ and $\\,e_{\\varepsilon} \\le 10^{-10}\\,$ hold.\n\nAngle units are not applicable. If physical quantities are printed the units would be SI; however, the required outputs are booleans with no units. Ensure numerical computations are performed in a dimensionally consistent manner using meters for geometry and pascals for material stiffness. The program must be deterministic and not require any user input.", "solution": "The problem presented requires the implementation of a verification procedure known as the constant-strain patch test for a four-node isoparametric quadrilateral finite element. This test is a fundamental benchmark in computational mechanics, designed to ensure that a finite element formulation can exactly reproduce a constant strain state, which is a necessary condition for convergence. The analysis is framed within the context of two-dimensional, small-strain, linear-elastic, plane-stress theory. I will proceed by first outlining the theoretical foundations and then detailing the algorithmic steps required for the implementation.\n\nThe problem statement is scientifically sound and well-posed. It provides all necessary data, including geometric descriptions of three distinct meshes, material properties, a prescribed affine displacement field, and precise criteria for passing the test. It is a standard problem in the validation of finite element codes.\n\n**1. Theoretical Formulation**\n\nThe foundation of the finite element method (FEM) for solid mechanics lies in the discretization of the weak form of the equilibrium equations. For a static problem without body forces, the principle of virtual work states that for any kinematically admissible virtual displacement field $\\,\\delta\\mathbf{u}\\,$, the internal virtual work must equal the external virtual work. In the absence of body forces and surface tractions on the domain boundary, this reduces to:\n$$\n\\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta\\boldsymbol{\\varepsilon} \\, \\mathrm{d}V = 0\n$$\nwhere $\\,\\boldsymbol{\\sigma}\\,$ is the Cauchy stress tensor and $\\,\\delta\\boldsymbol{\\varepsilon}\\,$ is the virtual strain tensor corresponding to $\\,\\delta\\mathbf{u}\\,$.\n\n**1.1. Isoparametric Element Formulation**\n\nWe employ a four-node quadrilateral element. The geometry and displacement field within the element are interpolated from nodal values using the same set of shape functions, hence the term \"isoparametric.\" The element is defined in a bi-unit square parent domain with natural coordinates $\\,(\\xi, \\eta)\\,$, where $\\,\\xi, \\eta \\in [-1, 1]\\,$.\n\nThe bilinear shape functions $\\,N_i(\\xi, \\eta)\\,$ for the four nodes $\\,(i=1, 2, 3, 4)\\,$ are:\n$$\nN_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\quad\\quad N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)\n$$\n$$\nN_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\quad\\quad N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n$$\nThe physical coordinates $\\,(x, y)\\,$ of any point within the element are mapped from the natural coordinates:\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad\\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\nwhere $\\,(x_i, y_i)\\,$ are the coordinates of the element's nodes.\n\nSimilarly, the displacement field $\\,(u, v)\\,$ within the element is interpolated from the nodal displacements $\\,(u_i, v_i)\\,$:\n$$\nu(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_i \\quad\\quad v(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) v_i\n$$\n\n**1.2. Strain-Displacement Relationship**\n\nThe engineering strains $\\,\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\mathsf{T}}\\,$ are defined by spatial derivatives of the displacement field:\n$$\n\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x}, \\quad \\varepsilon_{yy} = \\frac{\\partial v}{\\partial y}, \\quad \\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}\n$$\nTo compute these, we need to relate derivatives with respect to physical coordinates $\\,(x, y)\\,$ to derivatives with respect to natural coordinates $\\,(\\xi, \\eta)\\,$ using the chain rule. This relationship is expressed via the Jacobian matrix $\\,\\mathbf{J}\\,$:\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix} = \n\\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} = \\mathbf{J}\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix}\n$$\nThe components of $\\,\\mathbf{J}\\,$ are found by differentiating the geometry mapping, for example $\\,\\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} x_i\\,$. Inverting $\\,\\mathbf{J}\\,$ yields:\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1}\n\\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix}\n$$\nThe strains can now be expressed in terms of nodal displacements $\\,\\mathbf{d}^e = [u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4]^{\\mathsf{T}}\\,$ via the strain-displacement matrix $\\,\\mathbf{B}\\,$:\n$$\n\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}^e\n$$\nThe matrix $\\,\\mathbf{B}\\,$ is a $\\,3 \\times 8\\,$ matrix composed of four $\\,3 \\times 2\\,$ blocks, $\\,\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4]\\,$, where each block $\\,\\mathbf{B}_i\\,$ is given by:\n$$\n\\mathbf{B}_i = \n\\begin{bmatrix}\n\\frac{\\partial N_i}{\\partial x}  0 \\\\\n0  \\frac{\\partial N_i}{\\partial y} \\\\\n\\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x}\n\\end{bmatrix}\n$$\nThe spatial derivatives of the shape functions, e.g., $\\,\\frac{\\partial N_i}{\\partial x}\\,$, are computed using the inverse Jacobian:\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1}\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix}\n$$\n\n**1.3. Element Stiffness Matrix and System Assembly**\n\nThe element stiffness matrix $\\,\\mathbf{K}^e\\,$ relates nodal forces to nodal displacements for an element. It is derived by substituting the discrete formulations into the weak form integral:\n$$\n\\mathbf{K}^e = \\int_{A_e} \\mathbf{B}^{\\mathsf{T}} \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}A\n$$\nwhere $\\,A_e\\,$ is the element area and $\\,\\mathbf{D}\\,$ is the material constitutive matrix for plane stress:\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2} \n\\begin{bmatrix} \n1  \\nu  0 \\\\ \n\\nu  1  0 \\\\ \n0  0  \\frac{1-\\nu}{2} \n\\end{bmatrix}\n$$\nwith $\\,E\\,$ being Young's modulus and $\\,\\nu\\,$ Poisson's ratio.\nThe integral is evaluated numerically using Gaussian quadrature. Transforming to the parent domain:\n$$\n\\mathbf{K}^e = \\int_{-1}^{1} \\int_{-1}^{1} \\mathbf{B}(\\xi, \\eta)^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\det(\\mathbf{J}(\\xi, \\eta)) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta\n$$\nUsing $\\,2 \\times 2\\,$ Gaussian quadrature, with points at $\\,(\\xi_g, \\eta_g) \\in \\{\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3}\\}\\,$ and unit weights $\\,(w_g = 1)\\,$:\n$$\n\\mathbf{K}^e \\approx \\sum_{g=1}^{4} \\mathbf{B}(\\xi_g, \\eta_g)^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}(\\xi_g, \\eta_g) \\det(\\mathbf{J}(\\xi_g, \\eta_g)) w_g\n$$\nThe global stiffness matrix $\\,\\mathbf{K}\\,$ for the entire mesh is formed by assembling the contributions from each element stiffness matrix $\\,\\mathbf{K}^e\\,$ into the appropriate global degrees of freedom. This results in the linear system $\\,\\mathbf{K}\\mathbf{d} = \\mathbf{f}\\,$.\n\n**2. Patch Test Procedure**\n\nThe patch test verifies if the element can exactly represent a state of constant strain. This is achieved by prescribing a displacement field on the boundary of a \"patch\" of elements that corresponds to a constant strain field. The FEM solution for the interior nodes is then computed and checked against the exact analytical solution.\n\n**2.1. Boundary Conditions and System Solution**\n\nAn affine displacement field is prescribed on the boundary nodes of the mesh:\n$$\nu(x,y) = \\gamma + \\alpha x + \\beta y \\quad\\quad v(x,y) = \\zeta + \\delta x + \\varepsilon y\n$$\nThis field corresponds to a constant engineering strain state:\n$$\n\\varepsilon_{xx}^{\\text{target}} = \\alpha, \\quad \\varepsilon_{yy}^{\\text{target}} = \\varepsilon, \\quad \\gamma_{xy}^{\\text{target}} = \\beta + \\delta\n$$\nThe program must first algorithmically identify the boundary nodes. This is done by iterating through all elements and counting the occurrences of each edge. Edges that belong to only one element are boundary edges, and their constituent nodes are boundary nodes.\n\nThe global system $\\,\\mathbf{K}\\mathbf{d} = \\mathbf{f}\\,$ is partitioned into free and prescribed degrees of freedom (DOFs), denoted by subscripts $\\,f\\,$ and $\\,p\\,$ respectively:\n$$\n\\begin{bmatrix} \\mathbf{K}_{ff}  \\mathbf{K}_{fp} \\\\ \\mathbf{K}_{pf}  \\mathbf{K}_{pp} \\end{bmatrix}\n\\begin{Bmatrix} \\mathbf{d}_f \\\\ \\mathbf{d}_p \\end{Bmatrix} =\n\\begin{Bmatrix} \\mathbf{f}_f \\\\ \\mathbf{f}_p \\end{Bmatrix}\n$$\nThe displacements $\\,\\mathbf{d}_p\\,$ for the boundary nodes are known from the prescribed affine field. Since there are no external nodal forces, the force vector for the free DOFs, $\\,\\mathbf{f}_f\\,$, is zero. The system to be solved for the unknown interior displacements $\\,\\mathbf{d}_f\\,$ is:\n$$\n\\mathbf{K}_{ff} \\mathbf{d}_f = - \\mathbf{K}_{fp} \\mathbf{d}_p\n$$\nThis smaller linear system is solved for $\\,\\mathbf{d}_f\\,$.\n\n**2.2. Error Evaluation**\n\nOnce the displacements $\\,\\mathbf{d}_f\\,$ are computed, the full displacement vector $\\,\\mathbf{d}\\,$ is assembled. Two error metrics are then calculated:\n1.  **Displacement Error $\\,e_u\\,$**: The maximum absolute difference between the computed nodal displacements and the exact analytical displacements from the affine field at all nodes.\n    $$\n    e_u = \\max_{i} \\left\\lvert d_i - d_i^{\\text{exact}} \\right\\rvert\n    $$\n    A correct formulation should reproduce the affine displacement field exactly, so $\\,e_u\\,$ should be on the order of machine precision.\n2.  **Strain Error $\\,e_{\\varepsilon}\\,$**: The maximum absolute difference between the computed strains at each Gauss point of every element and the target constant strains.\n    $$\n    e_{\\varepsilon} = \\max_{e,g,k} \\left\\lvert \\varepsilon_k^{(e,g)} - \\varepsilon_k^{\\text{target}} \\right\\rvert\n    $$\n    Here, $\\,\\varepsilon_k^{(e,g)}\\,$ is the $\\,k$-th component of strain (xx, yy, or xy) at Gauss point $\\,g\\,$ of element $\\,e\\,$, computed using $\\,\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}^e\\,$. This error should also be near zero.\n\nA test case passes if both $\\,e_u\\,$ and $\\,e_{\\varepsilon}\\,$ are below the specified tolerance of $\\,10^{-10}\\,$. This confirms the element's ability to satisfy the patch test. The implementation will now follow this rigorous procedure.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main function to run the patch test for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: single distorted quadrilateral\n        {\n            \"nodes\": np.array([\n                [0.0, 0.0], [1.2, 0.1], [1.0, 1.1], [0.1, 0.9]\n            ]),\n            \"elements\": np.array([[0, 1, 2, 3]])\n        },\n        # Case 2: 2x2 mesh of the unit square\n        {\n            \"nodes\": np.array([\n                [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],\n                [0.0, 0.5], [0.5, 0.5], [1.0, 0.5],\n                [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]\n            ]),\n            \"elements\": np.array([\n                [0, 1, 4, 3], [1, 2, 5, 4],\n                [3, 4, 7, 6], [4, 5, 8, 7]\n            ])\n        },\n        # Case 3: parallelogram split into two quads\n        {\n            \"nodes\": np.array([\n                [0.0, 0.0], [1.0, 0.15], [2.0, 0.3],\n                [0.2, 0.9], [1.2, 1.05], [2.2, 1.2]\n            ]),\n            \"elements\": np.array([\n                [0, 1, 4, 3], [1, 2, 5, 4]\n            ])\n        }\n    ]\n\n    # Material parameters\n    E = 210.0e9  # Pascals\n    nu = 0.30\n\n    # Affine displacement field parameters\n    affine_coeffs = {\n        'alpha': 1.0e-3, 'beta': -2.0e-4, 'gamma': 2.5e-3,\n        'delta': 3.0e-4, 'epsilon': 5.0e-4, 'zeta': -1.1e-3\n    }\n    \n    # Pass/fail tolerance\n    tolerance = 1.0e-10\n\n    results = []\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        elements = case[\"elements\"]\n        passed = run_patch_test(nodes, elements, E, nu, affine_coeffs, tolerance)\n        results.append(passed)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_patch_test(nodes, elements, E, nu, affine_coeffs, tolerance):\n    \"\"\"\n    Performs the patch test for a single mesh configuration.\n    \"\"\"\n    num_nodes = nodes.shape[0]\n    num_dofs = 2 * num_nodes\n    \n    # 1. Material matrix for plane stress\n    D = (E / (1 - nu**2)) * np.array([[1, nu, 0],\n                                     [nu, 1, 0],\n                                     [0, 0, (1 - nu) / 2]])\n    \n    # 2. Gaussian quadrature points and weights (2x2)\n    gp = 1.0 / np.sqrt(3.0)\n    gauss_points = [(-gp, -gp), (gp, -gp), (gp, gp), (-gp, gp)]\n    gauss_weights = [1.0, 1.0, 1.0, 1.0]\n\n    # 3. Assemble global stiffness matrix K\n    K_global = np.zeros((num_dofs, num_dofs))\n    element_gauss_data = [] # To store B matrices and detJ for strain calculations\n\n    for el_nodes_indices in elements:\n        el_nodes_coords = nodes[el_nodes_indices]\n        K_element = np.zeros((8, 8))\n        gauss_data_for_element = []\n\n        for i, (xi, eta) in enumerate(gauss_points):\n            # Shape function derivatives w.r.t. natural coordinates\n            dN_dxi_eta = 0.25 * np.array([\n                [-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)],\n                [-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)]\n            ])\n            \n            # Jacobian matrix\n            J = dN_dxi_eta @ el_nodes_coords\n            detJ = np.linalg.det(J)\n            invJ = np.linalg.inv(J)\n            \n            # Shape function derivatives w.r.t. physical coordinates\n            dN_dxy = invJ @ dN_dxi_eta\n            \n            # Strain-displacement matrix B\n            B = np.zeros((3, 8))\n            for j in range(4):\n                B[0, 2*j] = dN_dxy[0, j]\n                B[1, 2*j+1] = dN_dxy[1, j]\n                B[2, 2*j] = dN_dxy[1, j]\n                B[2, 2*j+1] = dN_dxy[0, j]\n            \n            K_element += B.T @ D @ B * detJ * gauss_weights[i]\n            gauss_data_for_element.append({'B': B, 'detJ': detJ})\n        \n        element_gauss_data.append(gauss_data_for_element)\n\n        # Assemble into global K\n        dof_indices = np.array([[2*i, 2*i+1] for i in el_nodes_indices]).flatten()\n        K_global[np.ix_(dof_indices, dof_indices)] += K_element\n        \n    # 4. Apply boundary conditions\n    boundary_nodes = find_boundary_nodes(elements)\n    prescribed_dofs = []\n    for node_idx in boundary_nodes:\n        prescribed_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n    \n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, prescribed_dofs)\n\n    # 5. Calculate exact displacements and solve system\n    d_exact = calculate_exact_displacements(nodes, affine_coeffs)\n    d_p = d_exact[prescribed_dofs]\n    \n    K_ff = K_global[np.ix_(free_dofs, free_dofs)]\n    K_fp = K_global[np.ix_(free_dofs, prescribed_dofs)]\n\n    F_eff = -K_fp @ d_p\n    d_f = np.linalg.solve(K_ff, F_eff)\n    \n    d_solution = np.zeros(num_dofs)\n    d_solution[prescribed_dofs] = d_p\n    d_solution[free_dofs] = d_f\n\n    # 6. Calculate errors\n    # Displacement error\n    e_u = np.max(np.abs(d_solution - d_exact))\n    \n    # Strain error\n    alpha, beta, delta, epsilon = [affine_coeffs[k] for k in ['alpha', 'beta', 'delta', 'epsilon']]\n    strain_target = np.array([alpha, epsilon, beta + delta])\n    \n    e_strain = 0.0\n    for i, el_nodes_indices in enumerate(elements):\n        el_dof_indices = np.array([[2*j, 2*j+1] for j in el_nodes_indices]).flatten()\n        d_element = d_solution[el_dof_indices]\n        \n        for gauss_data in element_gauss_data[i]:\n            B = gauss_data['B']\n            strain_computed = B @ d_element\n            e_strain = max(e_strain, np.max(np.abs(strain_computed - strain_target)))\n\n    return e_u = tolerance and e_strain = tolerance\n\ndef find_boundary_nodes(elements):\n    \"\"\"\n    Identifies boundary nodes from an element connectivity list.\n    \"\"\"\n    edge_counts = collections.defaultdict(int)\n    for el in elements:\n        for i in range(4):\n            n1 = el[i]\n            n2 = el[(i + 1) % 4]\n            edge = tuple(sorted((n1, n2)))\n            edge_counts[edge] += 1\n            \n    boundary_edges = {edge for edge, count in edge_counts.items() if count == 1}\n    boundary_nodes = set()\n    for edge in boundary_edges:\n        boundary_nodes.update(edge)\n        \n    return boundary_nodes\n\ndef calculate_exact_displacements(nodes, coeffs):\n    \"\"\"\n    Calculates exact nodal displacements from the affine field.\n    \"\"\"\n    num_nodes = nodes.shape[0]\n    d_exact = np.zeros(2 * num_nodes)\n    alpha, beta, gamma = coeffs['alpha'], coeffs['beta'], coeffs['gamma']\n    delta, epsilon, zeta = coeffs['delta'], coeffs['epsilon'], coeffs['zeta']\n    \n    for i in range(num_nodes):\n        x, y = nodes[i, 0], nodes[i, 1]\n        d_exact[2*i] = gamma + alpha * x + beta * y  # u\n        d_exact[2*i+1] = zeta + delta * x + epsilon * y # v\n        \n    return d_exact\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2378079"}, {"introduction": "Once a computational element is verified, the entire numerical model must be validated. This exercise takes you through a complete simulation workflow, from deriving the governing equations to verifying the results. You will implement a finite difference solver for the classic problem of a pressurized thick-walled cylinder (the Lamé problem) and perform a mesh convergence study. By comparing your numerical results against the exact analytical solution, you will learn how to quantify the accuracy of your simulation and understand how discretization error decreases as the mesh becomes finer, a cornerstone of reliable computational analysis [@problem_id:2378059].", "problem": "You are to design and implement a complete, runnable program that performs a mesh convergence study for a linear elasticity boundary value problem that admits a closed-form analytical solution. Use the axisymmetric thick-walled cylinder under pressure (also known as the Lame problem) as the verification problem. The task must be developed from first principles of computational solid mechanics and linear elasticity, and the program must compare the numerical solution to the analytical solution to quantify convergence as the mesh is refined.\n\nThe physical setting is an isotropic, homogeneous, linear elastic, thick-walled cylinder with inner radius $a$, outer radius $b$, unit thickness in the axial direction, and no body forces. The cylinder is subjected to uniform internal pressure $p_i$ at $r=a$ and uniform external pressure $p_o$ at $r=b$. Consider the axisymmetric, plane strain case. The unknown is the radial displacement $u(r)$, where $r$ is the radial coordinate.\n\nStart from the following principles as the base:\n- Balance of linear momentum (equilibrium) in cylindrical coordinates for axisymmetry and no body force: $d\\sigma_r/dr + (\\sigma_r - \\sigma_\\theta)/r = 0$.\n- Kinematic definitions under axisymmetry: $\\varepsilon_r = du/dr$ and $\\varepsilon_\\theta = u/r$.\n- Linear elastic (Hooke’s law) constitutive model for isotropic materials in plane strain with Lamé constants $\\lambda$ and $\\mu$: $\\sigma_r = \\lambda (\\varepsilon_r + \\varepsilon_\\theta + \\varepsilon_z) + 2 \\mu \\varepsilon_r$ and $\\sigma_\\theta = \\lambda (\\varepsilon_r + \\varepsilon_\\theta + \\varepsilon_z) + 2 \\mu \\varepsilon_\\theta$, with $\\varepsilon_z = 0$ in plane strain. The constants are $\\mu = E/[2(1+\\nu)]$ and $\\lambda = E \\nu / [(1+\\nu)(1-2\\nu)]$ where $E$ is Young’s modulus and $\\nu$ is Poisson’s ratio.\n- Natural (traction) boundary conditions: $\\sigma_r(a) = -p_i$ and $\\sigma_r(b) = -p_o$.\n\nTasks to perform:\n1. Derive, from the above principles, the strong form governing ordinary differential equation for $u(r)$ on $r \\in [a,b]$, and the associated boundary conditions expressed in $u$ and $du/dr$.\n2. Derive the analytical solution for the stress field $\\sigma_r(r)$ and $\\sigma_\\theta(r)$ in terms of $a$, $b$, $p_i$, and $p_o$.\n3. Construct a finite difference discretization of the strong form using a uniform radial mesh with $N$ intervals and grid spacing $h = (b-a)/N$. Use a standard second-order central difference scheme for the interior and a second-order one-sided finite difference approximation for $du/dr$ at the boundaries to impose the traction boundary conditions. Assemble and solve the resulting linear system for the nodal displacements $\\{u_i\\}_{i=0}^N$ at nodes $r_i = a + i h$.\n4. From the discrete solution, compute numerical stresses at nodes using $\\sigma_r = (\\lambda + 2\\mu)\\,u' + \\lambda\\,u/r$ and $\\sigma_\\theta = \\lambda\\,u' + (\\lambda + 2\\mu)\\,u/r$, where $u'$ is approximated by consistent second-order finite differences (central in the interior, one-sided at the boundaries).\n5. Compute the relative root-mean-square (RMS) error for the radial stress over all nodes:\n$$\n\\mathrm{err} = \\frac{\\sqrt{\\sum_{i=0}^{N} \\left(\\sigma_{r,i}^{\\mathrm{num}} - \\sigma_{r}(r_i)^{\\mathrm{exact}}\\right)^2}}{\\sqrt{\\sum_{i=0}^{N} \\left(\\sigma_{r}(r_i)^{\\mathrm{exact}}\\right)^2}}.\n$$\nThe error is dimensionless.\n\nYour program must run the following test suite and output the errors for each case in a single line as a comma-separated list enclosed in square brackets:\n- Case $1$ (happy path): $a = 0.5\\,\\mathrm{m}$, $b = 1.0\\,\\mathrm{m}$, $p_i = 1.0\\times 10^{6}\\,\\mathrm{Pa}$, $p_o = 0.0\\,\\mathrm{Pa}$, $E = 2.10\\times 10^{11}\\,\\mathrm{Pa}$, $\\nu = 0.30$, $N = 10$.\n- Case $2$ (refined mesh): same as Case $1$ but $N = 20$.\n- Case $3$ (more refined mesh): same as Case $1$ but $N = 40$.\n- Case $4$ (edge mesh size): same as Case $1$ but $N = 2$.\n- Case $5$ (different geometry and loads): $a = 0.3\\,\\mathrm{m}$, $b = 1.0\\,\\mathrm{m}$, $p_i = 2.0\\times 10^{6}\\,\\mathrm{Pa}$, $p_o = 0.5\\times 10^{6}\\,\\mathrm{Pa}$, $E = 7.0\\times 10^{10}\\,\\mathrm{Pa}$, $\\nu = 0.25$, $N = 40$.\n- Case $6$ (uniform pressure consistency): $a = 0.7\\,\\mathrm{m}$, $b = 1.0\\,\\mathrm{m}$, $p_i = 1.0\\times 10^{5}\\,\\mathrm{Pa}$, $p_o = 1.0\\times 10^{5}\\,\\mathrm{Pa}$, $E = 1.0\\times 10^{11}\\,\\mathrm{Pa}$, $\\nu = 0.33$, $N = 20$.\n\nPhysical units:\n- Radii $a$ and $b$ must be in $\\mathrm{m}$.\n- Pressures $p_i$ and $p_o$ must be in $\\mathrm{Pa}$.\n- Young’s modulus $E$ must be in $\\mathrm{Pa}$.\n- Poisson’s ratio $\\nu$ is dimensionless.\n- Displacement $u$ is in $\\mathrm{m}$.\n- The reported errors are dimensionless floats.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\left[\\mathrm{err}_1,\\mathrm{err}_2,\\dots\\right]$, where each entry is a float corresponding to the error in the order of the above cases.", "solution": "The problem posed is a standard boundary value problem in linear elasticity, specifically the Lamé problem for a thick-walled cylinder under pressure. We will first validate the problem statement, then proceed with the required derivations and numerical implementation plan, as this problem is well-posed and scientifically sound.\n\n**1. Derivation of the Governing Equation (Strong Form)**\n\nThe analysis begins from the fundamental principles of continuum mechanics provided.\nThe balance of linear momentum in axisymmetric cylindrical coordinates with no body forces is given by:\n$$ \\frac{d\\sigma_r}{dr} + \\frac{\\sigma_r - \\sigma_\\theta}{r} = 0 \\quad (1) $$\nThe kinematic relations, which connect strain to displacement, are:\n$$ \\varepsilon_r = \\frac{du}{dr}, \\quad \\varepsilon_\\theta = \\frac{u}{r} \\quad (2) $$\nThe material is isotropic and linear elastic, and the state is plane strain ($\\varepsilon_z = 0$). The constitutive relations (Hooke's law) are:\n$$ \\sigma_r = \\lambda (\\varepsilon_r + \\varepsilon_\\theta) + 2 \\mu \\varepsilon_r \\quad (3a) $$\n$$ \\sigma_\\theta = \\lambda (\\varepsilon_r + \\varepsilon_\\theta) + 2 \\mu \\varepsilon_\\theta \\quad (3b) $$\nwhere $\\lambda$ and $\\mu$ are Lamé's first and second parameters.\n\nFirst, we express the stresses in terms of the radial displacement $u(r)$ by substituting $(2)$ into $(3)$:\n$$ \\sigma_r = \\lambda \\left(\\frac{du}{dr} + \\frac{u}{r}\\right) + 2 \\mu \\frac{du}{dr} = (\\lambda + 2\\mu) \\frac{du}{dr} + \\lambda \\frac{u}{r} \\quad (4a) $$\n$$ \\sigma_\\theta = \\lambda \\left(\\frac{du}{dr} + \\frac{u}{r}\\right) + 2 \\mu \\frac{u}{r} = \\lambda \\frac{du}{dr} + (\\lambda + 2\\mu) \\frac{u}{r} \\quad (4b) $$\nNext, we substitute these stress expressions into the equilibrium equation $(1)$. We require the derivative of $\\sigma_r$:\n$$ \\frac{d\\sigma_r}{dr} = \\frac{d}{dr} \\left( (\\lambda + 2\\mu) \\frac{du}{dr} + \\lambda \\frac{u}{r} \\right) = (\\lambda + 2\\mu) \\frac{d^2u}{dr^2} + \\lambda \\left( \\frac{1}{r}\\frac{du}{dr} - \\frac{u}{r^2} \\right) $$\nAnd the stress difference:\n$$ \\sigma_r - \\sigma_\\theta = \\left( (\\lambda + 2\\mu) \\frac{du}{dr} + \\lambda \\frac{u}{r} \\right) - \\left( \\lambda \\frac{du}{dr} + (\\lambda + 2\\mu) \\frac{u}{r} \\right) = 2\\mu \\left( \\frac{du}{dr} - \\frac{u}{r} \\right) $$\nSubstituting these into the equilibrium equation $(1)$:\n$$ \\left( (\\lambda + 2\\mu) \\frac{d^2u}{dr^2} + \\frac{\\lambda}{r}\\frac{du}{dr} - \\frac{\\lambda u}{r^2} \\right) + \\frac{1}{r} \\left( 2\\mu \\left( \\frac{du}{dr} - \\frac{u}{r} \\right) \\right) = 0 $$\nCombining terms:\n$$ (\\lambda + 2\\mu) \\frac{d^2u}{dr^2} + \\frac{(\\lambda + 2\\mu)}{r}\\frac{du}{dr} - \\frac{(\\lambda + 2\\mu)}{r^2}u = 0 $$\nSince $\\lambda + 2\\mu \\neq 0$ for any physical material, we can divide by this term to obtain the strong form of the governing ordinary differential equation for $u(r)$:\n$$ \\frac{d^2u}{dr^2} + \\frac{1}{r}\\frac{du}{dr} - \\frac{u}{r^2} = 0 \\quad (5) $$\nThis equation is valid on the domain $r \\in [a, b]$. The boundary conditions are given in terms of traction, $\\sigma_r(a) = -p_i$ and $\\sigma_r(b) = -p_o$. Using equation $(4a)$, we express these in terms of $u(r)$ and its derivative:\n$$ (\\lambda + 2\\mu) \\frac{du}{dr}\\bigg|_{r=a} + \\frac{\\lambda}{a} u(a) = -p_i \\quad (6a) $$\n$$ (\\lambda + 2\\mu) \\frac{du}{dr}\\bigg|_{r=b} + \\frac{\\lambda}{b} u(b) = -p_o \\quad (6b) $$\n\n**2. Derivation of the Analytical Solution**\n\nEquation $(5)$ is a Cauchy-Euler equation. The general solution is of the form $u(r) = C_1 r + C_2/r$. To determine the integration constants, one would use the boundary conditions $(6a)$ and $(6b)$. However, it is more straightforward to find the constants for the stress fields directly. The stress fields consistent with this form of displacement must be of the form:\n$$ \\sigma_r(r) = A - \\frac{B}{r^2} \\quad (7a) $$\n$$ \\sigma_\\theta(r) = A + \\frac{B}{r^2} \\quad (7b) $$\nThis form identically satisfies the equilibrium equation $(1)$. The constants $A$ and $B$ are determined by the stress boundary conditions:\n$$ \\sigma_r(a) = A - \\frac{B}{a^2} = -p_i $$\n$$ \\sigma_r(b) = A - \\frac{B}{b^2} = -p_o $$\nThis is a linear system for $A$ and $B$. Subtracting the two equations yields:\n$$ B \\left( \\frac{1}{b^2} - \\frac{1}{a^2} \\right) = -p_i + p_o \\implies B \\left( \\frac{a^2 - b^2}{a^2 b^2} \\right) = p_o - p_i $$\n$$ B = \\frac{(p_i - p_o) a^2 b^2}{b^2 - a^2} $$\nSubstituting $B$ back into the first equation to find $A$:\n$$ A = -p_i + \\frac{B}{a^2} = -p_i + \\frac{(p_i - p_o) b^2}{b^2 - a^2} = \\frac{-p_i (b^2 - a^2) + p_i b^2 - p_o b^2}{b^2 - a^2} = \\frac{p_i a^2 - p_o b^2}{b^2 - a^2} $$\nThus, the exact analytical solution for the radial stress is:\n$$ \\sigma_{r}(r)^{\\mathrm{exact}} = \\frac{p_i a^2 - p_o b^2}{b^2 - a^2} - \\frac{(p_i - p_o) a^2 b^2}{b^2 - a^2} \\frac{1}{r^2} \\quad (8) $$\n\n**3. Finite Difference Method (FDM) Discretization**\n\nWe define a uniform grid on the domain $[a, b]$ with $N$ intervals, such that the grid spacing is $h = (b-a)/N$. The nodes are located at $r_i = a + i h$ for $i = 0, 1, \\dots, N$. We seek the approximate solution $u_i \\approx u(r_i)$ at these $N+1$ nodes.\n\nFor the interior nodes ($i = 1, \\dots, N-1$), we discretize the governing ODE $(5)$ using second-order central difference formulas:\n$$ u'(r_i) \\approx \\frac{u_{i+1} - u_{i-1}}{2h}, \\quad u''(r_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} $$\nSubstituting these into $(5)$ gives:\n$$ \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} + \\frac{1}{r_i}\\frac{u_{i+1} - u_{i-1}}{2h} - \\frac{u_i}{r_i^2} = 0 $$\nMultiplying by $h^2$ and grouping terms by unknown $u_j$:\n$$ \\left(1 - \\frac{h}{2r_i}\\right) u_{i-1} + \\left(-2 - \\frac{h^2}{r_i^2}\\right) u_i + \\left(1 + \\frac{h}{2r_i}\\right) u_{i+1} = 0 \\quad (9) $$\nThis provides $N-1$ linear algebraic equations.\n\nFor the boundary nodes $i=0$ and $i=N$, we discretize the boundary conditions $(6a)$ and $(6b)$. This requires second-order one-sided finite difference approximations for the derivative $du/dr$:\n$$ u'(r_0) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h}, \\quad u'(r_N) \\approx \\frac{3u_N - 4u_{N-1} + u_{N-2}}{2h} $$\nSubstituting these into $(6a)$ and $(6b)$:\nAt $r=a$ ($i=0$):\n$$ (\\lambda + 2\\mu) \\left( \\frac{-3u_0 + 4u_1 - u_2}{2h} \\right) + \\frac{\\lambda}{r_0} u_0 = -p_i \\quad (10a) $$\nAt $r=b$ ($i=N$):\n$$ (\\lambda + 2\\mu) \\left( \\frac{3u_N - 4u_{N-1} + u_{N-2}}{2h} \\right) + \\frac{\\lambda}{r_N} u_N = -p_o \\quad (10b) $$\nEquations $(9)$, $(10a)$, and $(10b)$ form a system of $N+1$ linear equations for the $N+1$ unknowns $\\{u_i\\}_{i=0}^N$. This system, written as $\\mathbf{A} \\mathbf{u} = \\mathbf{f}$, is assembled and solved numerically. The matrix $\\mathbf{A}$ is pentadiagonal.\n\n**4. Numerical Stress Computation and Error Metric**\n\nAfter solving for the nodal displacements $\\mathbf{u}$, the numerical approximation for the radial stress $\\sigma_{r,i}^{\\mathrm{num}}$ at each node $i$ is computed using equation $(4a)$. The derivative $u'(r_i)$ is approximated with consistent second-order schemes: central differences for interior nodes, and one-sided differences at the boundaries, identical to those used for the boundary conditions.\n$$ \\sigma_{r,i}^{\\mathrm{num}} = (\\lambda + 2\\mu) u'_{i} + \\lambda \\frac{u_i}{r_i} $$\nwhere $u'_i$ is the corresponding finite difference approximation of the derivative.\n\nThe relative Root-Mean-Square (RMS) error is then calculated by comparing the numerical stress vector with the exact stress vector evaluated at the nodes:\n$$ \\mathrm{err} = \\frac{\\sqrt{\\sum_{i=0}^{N} \\left(\\sigma_{r,i}^{\\mathrm{num}} - \\sigma_{r}(r_i)^{\\mathrm{exact}}\\right)^2}}{\\sqrt{\\sum_{i=0}^{N} \\left(\\sigma_{r}(r_i)^{\\mathrm{exact}}\\right)^2}} $$\nThis quantifies the accuracy of the numerical simulation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the Lamé problem convergence study.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {'a': 0.5, 'b': 1.0, 'p_i': 1.0e6, 'p_o': 0.0, 'E': 2.10e11, 'nu': 0.30, 'N': 10},\n        # Case 2 (refined mesh)\n        {'a': 0.5, 'b': 1.0, 'p_i': 1.0e6, 'p_o': 0.0, 'E': 2.10e11, 'nu': 0.30, 'N': 20},\n        # Case 3 (more refined mesh)\n        {'a': 0.5, 'b': 1.0, 'p_i': 1.0e6, 'p_o': 0.0, 'E': 2.10e11, 'nu': 0.30, 'N': 40},\n        # Case 4 (edge mesh size)\n        {'a': 0.5, 'b': 1.0, 'p_i': 1.0e6, 'p_o': 0.0, 'E': 2.10e11, 'nu': 0.30, 'N': 2},\n        # Case 5 (different geometry and loads)\n        {'a': 0.3, 'b': 1.0, 'p_i': 2.0e6, 'p_o': 0.5e6, 'E': 7.0e10, 'nu': 0.25, 'N': 40},\n        # Case 6 (uniform pressure consistency)\n        {'a': 0.7, 'b': 1.0, 'p_i': 1.0e5, 'p_o': 1.0e5, 'E': 1.0e11, 'nu': 0.33, 'N': 20},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_error_for_case(**case)\n        results.append(f\"{error:.6g}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef compute_error_for_case(a, b, p_i, p_o, E, nu, N):\n    \"\"\"\n    Solves the Lamé problem for one case and computes the relative RMS error.\n\n    Args:\n        a (float): Inner radius [m].\n        b (float): Outer radius [m].\n        p_i (float): Internal pressure [Pa].\n        p_o (float): External pressure [Pa].\n        E (float): Young's modulus [Pa].\n        nu (float): Poisson's ratio.\n        N (int): Number of intervals in the mesh.\n\n    Returns:\n        float: The relative RMS error for the radial stress.\n    \"\"\"\n    # 1. Calculate constants and set up mesh\n    # Use 'lmbda' for lambda to avoid keyword conflict\n    lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    mu = E / (2 * (1 + nu))\n    h = (b - a) / N\n    r = np.array([a + i * h for i in range(N + 1)])\n\n    # 2. Assemble the linear system A * u = f for N+1 unknowns u_0, ..., u_N\n    num_unknowns = N + 1\n    A = np.zeros((num_unknowns, num_unknowns))\n    f = np.zeros(num_unknowns)\n\n    # Equation for node i=0 (from boundary condition at r=a)\n    # This equation involves u_0, u_1, u_2\n    A[0, 0] = -3 * (lmbda + 2 * mu) / (2 * h) + lmbda / r[0]\n    A[0, 1] = 2 * (lmbda + 2 * mu) / h  # Simplified from 4 * (...) / (2*h)\n    A[0, 2] = -1 * (lmbda + 2 * mu) / (2 * h)\n    f[0] = -p_i\n\n    # Equations for interior nodes i=1 to N-1 (from governing ODE)\n    for i in range(1, N):\n        A[i, i - 1] = 1 - h / (2 * r[i])\n        A[i, i] = -2 - h**2 / r[i]**2\n        A[i, i + 1] = 1 + h / (2 * r[i])\n\n    # Equation for node i=N (from boundary condition at r=b)\n    # This equation involves u_{N-2}, u_{N-1}, u_N\n    A[N, N - 2] = (lmbda + 2 * mu) / (2 * h)\n    A[N, N - 1] = -2 * (lmbda + 2 * mu) / h # Simplified from -4 * (...) / (2*h)\n    A[N, N] = 3 * (lmbda + 2 * mu) / (2 * h) + lmbda / r[N]\n    f[N] = -p_o\n    \n    # 3. Solve for displacement vector u\n    u = np.linalg.solve(A, f)\n\n    # 4. Compute numerical stresses from the displacement solution\n    du_dr_num = np.zeros(num_unknowns)\n    # Derivative at i=0 (second-order forward difference)\n    du_dr_num[0] = (-3 * u[0] + 4 * u[1] - u[2]) / (2 * h)\n    # Derivatives for i=1 to N-1 (second-order central difference)\n    for i in range(1, N):\n        du_dr_num[i] = (u[i + 1] - u[i - 1]) / (2 * h)\n    # Derivative at i=N (second-order backward difference)\n    du_dr_num[N] = (3 * u[N] - 4 * u[N - 1] + u[N - 2]) / (2 * h)\n\n    sigma_r_num = (lmbda + 2 * mu) * du_dr_num + lmbda * u / r\n\n    # 5. Compute analytical stresses at nodes\n    const_A = (p_i * a**2 - p_o * b**2) / (b**2 - a**2)\n    const_B = (p_i - p_o) * a**2 * b**2 / (b**2 - a**2)\n    sigma_r_exact = const_A - const_B / r**2\n\n    # 6. Compute the relative RMS error\n    numerator = np.sqrt(np.sum((sigma_r_num - sigma_r_exact)**2))\n    denominator = np.sqrt(np.sum(sigma_r_exact**2))\n    \n    if abs(denominator)  1e-15:\n        if abs(numerator)  1e-15:\n            return 0.0  # Exact solution found for a zero-norm case if it happens\n        else:\n            return np.inf  # Numerical solution non-zero, but analytical is zero\n    \n    error = numerator / denominator\n    return error\n\nsolve()\n```", "id": "2378059"}]}