{"hands_on_practices": [{"introduction": "The heart of the MAC scheme is the solution of a Poisson equation for pressure, which enforces the incompressibility of the flow. In this hands-on exercise, you will implement a classic iterative solver, the Red-Black Gauss-Seidel method, to solve this equation. Your primary goal is to numerically investigate a crucial aspect of solver performance: its sensitivity to the grid cell aspect ratio, a phenomenon that has significant practical implications for simulations on anisotropic meshes [@problem_id:2438296].", "problem": "You are asked to quantify, by direct numerical experiment, how the grid cell aspect ratio influences the convergence rate of an iterative solver for the pressure Poisson equation on a Marker-And-Cell (MAC) staggered grid. Consider the unit square domain $[0,1]\\times[0,1]$ with pressure unknowns located at cell centers. Let $N_x$ and $N_y$ denote the number of interior pressure unknowns along the $x$- and $y$-directions, respectively. The uniform grid spacings are $\\Delta x = \\dfrac{1}{N_x+1}$ and $\\Delta y = \\dfrac{1}{N_y+1}$, so that the cell aspect ratio is $\\Delta x / \\Delta y = \\dfrac{N_y+1}{N_x+1}$. Impose homogeneous Dirichlet boundary conditions $p=0$ on $\\partial \\Omega$, and solve the discrete Poisson equation\n$$\n\\frac{p_{i+1,j}-2 p_{i,j}+p_{i-1,j}}{(\\Delta x)^2}+\\frac{p_{i,j+1}-2 p_{i,j}+p_{i,j-1}}{(\\Delta y)^2}=f_{i,j},\n$$\nfor all interior indices $(i,j)$, where the source term is sampled from the continuous function $f(x,y)=-2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$ at interior cell-center locations $(x_i,y_j)=(i\\,\\Delta x, j\\,\\Delta y)$ with $i\\in\\{1,\\dots,N_x\\}$ and $j\\in\\{1,\\dots,N_y\\}$. Use the Red-Black Gauss-Seidel (RBGS) iterative method starting from the zero field $p_{i,j}^{(0)}=0$ for all interior $(i,j)$, and enforce $p=0$ at all boundary nodes at every iteration. After each full RBGS sweep (one red update and one black update), compute the discrete residual\n$$\nr_{i,j}=\\frac{p_{i+1,j}-2 p_{i,j}+p_{i-1,j}}{(\\Delta x)^2}+\\frac{p_{i,j+1}-2 p_{i,j}+p_{i,j-1}}{(\\Delta y)^2}-f_{i,j},\n$$\nand the relative residual norm\n$$\n\\mathrm{RelRes}=\\frac{\\left(\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} r_{i,j}^2\\right)^{1/2}}{\\left(\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} f_{i,j}^2\\right)^{1/2}}.\n$$\nTerminate the iteration when $\\mathrm{RelRes}\\le \\varepsilon$ with tolerance $\\varepsilon=10^{-6}$, or when a hard cap of $N_{\\max}=100000$ full sweeps is reached, whichever occurs first. The quantity of interest for each case is the number of full RBGS sweeps required to meet the tolerance.\n\nTest suite: For each of the following parameter pairs $(N_x,N_y)$, run the above experiment and record the required number of sweeps as an integer:\n- Case $1$: $(N_x,N_y)=(32,32)$.\n- Case $2$: $(N_x,N_y)=(48,12)$.\n- Case $3$: $(N_x,N_y)=(12,48)$.\n- Case $4$: $(N_x,N_y)=(8,8)$.\n- Case $5$: $(N_x,N_y)=(64,16)$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the cases above, for example, $\\texttt{[r_1,r_2,r_3,r_4,r_5]}$, where each $r_k$ is the integer number of RBGS sweeps required for Case $k$.", "solution": "The problem presented is a well-posed numerical experiment in computational engineering, requiring the implementation of an iterative solver for the two-dimensional Poisson equation. The problem is scientifically sound, self-contained, and all data and constraints are clearly specified. The stated goal is to quantify the effect of grid cell aspect ratio on the convergence rate of the Red-Black Gauss-Seidel method. We shall proceed with the derivation and implementation of the required algorithm.\n\nThe governing partial differential equation is the Poisson equation on the unit square domain $\\Omega = [0,1]\\times[0,1]$ with homogeneous Dirichlet boundary conditions:\n$$\n\\nabla^2 p = \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} = f(x,y), \\quad \\text{for } (x,y) \\in \\Omega\n$$\n$$\np(x,y) = 0, \\quad \\text{for } (x,y) \\in \\partial\\Omega\n$$\nWe discretize this problem using a finite difference method on a uniform Cartesian grid. The pressure unknowns $p_{i,j}$ are located at cell centers $(x_i, y_j) = (i\\Delta x, j\\Delta y)$, for interior indices $i \\in \\{1, \\dots, N_x\\}$ and $j \\in \\{1, \\dots, N_y\\}$. The grid spacings are $\\Delta x = \\frac{1}{N_x+1}$ and $\\Delta y = \\frac{1}{N_y+1}$. Using a second-order central difference scheme for the second derivatives, we obtain the discrete Poisson equation at each interior node $(i,j)$:\n$$\n\\frac{p_{i+1,j}-2 p_{i,j}+p_{i-1,j}}{(\\Delta x)^2}+\\frac{p_{i,j+1}-2 p_{i,j}+p_{i,j-1}}{(\\Delta y)^2}=f_{i,j}\n$$\nwhere $f_{i,j}$ is the source term $f(x,y)=-2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$ evaluated at $(x_i, y_j)$. The homogeneous boundary conditions imply that $p_{i,j}=0$ if $i=0$, $i=N_x+1$, $j=0$, or $j=N_y+1$.\n\nTo solve this system iteratively, we first rearrange the equation to isolate $p_{i,j}$. This gives the update rule for a point-iterative method.\n$$\np_{i,j} \\left( \\frac{2}{(\\Delta x)^2} + \\frac{2}{(\\Delta y)^2} \\right) = \\frac{p_{i+1,j} + p_{i-1,j}}{(\\Delta x)^2} + \\frac{p_{i,j+1} + p_{i,j-1}}{(\\Delta y)^2} - f_{i,j}\n$$\nLetting $\\alpha_x = 1/(\\Delta x)^2$ and $\\alpha_y = 1/(\\Delta y)^2$, the update rule becomes:\n$$\np_{i,j} = \\frac{ \\alpha_x (p_{i+1,j} + p_{i-1,j}) + \\alpha_y (p_{i,j+1} + p_{i,j-1}) - f_{i,j} }{ 2(\\alpha_x + \\alpha_y) }\n$$\nThe Red-Black Gauss-Seidel (RBGS) method accelerates convergence by partitioning the grid points into two sets, \"red\" and \"black\", similar to a checkerboard. A node $(i,j)$ is designated red if the sum of its indices $i+j$ is even, and black if $i+j$ is odd. The key observation is that the update for any red node depends only on its four neighbors, which are all black. Likewise, the update for any black node depends only on its red neighbors.\n\nA full RBGS sweep proceeds in two stages:\n$1$. **Red Update**: All red nodes are updated simultaneously. The new value for a red node $p_{i,j}$ is computed using the values of its black neighbors from the previous iteration, let's say iteration $k$.\n$$\np_{i,j}^{(k+1/2)} = \\frac{ \\alpha_x (p_{i+1,j}^{(k)} + p_{i-1,j}^{(k)}) + \\alpha_y (p_{i,j+1}^{(k)} + p_{i,j-1}^{(k)}) - f_{i,j} }{ 2(\\alpha_x + \\alpha_y) }, \\quad \\text{for all red } (i,j)\n$$\n$2$. **Black Update**: All black nodes are updated simultaneously. The new value for a black node $p_{i,j}$ is computed using the newly updated values of its red neighbors from the current sweep, $k+1/2$.\n$$\np_{i,j}^{(k+1)} = \\frac{ \\alpha_x (p_{i+1,j}^{(k+1/2)} + p_{i-1,j}^{(k+1/2)}) + \\alpha_y (p_{i,j+1}^{(k+1/2)} + p_{i,j-1}^{(k+1/2)}) - f_{i,j} }{ 2(\\alpha_x + \\alpha_y) }, \\quad \\text{for all black } (i,j)\n$$\nThe result of these two stages is the pressure field at the end of sweep $k+1$, denoted $p^{(k+1)}$.\n\nAfter each full sweep, we must check for convergence. This is done by computing the discrete residual field $r_{i,j}$ for all interior nodes:\n$$\nr_{i,j} = \\alpha_x(p_{i+1,j}-2 p_{i,j}+p_{i-1,j}) + \\alpha_y(p_{i,j+1}-2 p_{i,j}+p_{i,j-1}) - f_{i,j}\n$$\nThe convergence is assessed using the relative residual norm, defined as the ratio of the discrete $L_2$-norm of the residual to the discrete $L_2$-norm of the source term:\n$$\n\\mathrm{RelRes}=\\frac{\\|r\\|_2}{\\|f\\|_2} = \\frac{\\left(\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} r_{i,j}^2\\right)^{1/2}}{\\left(\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} f_{i,j}^2\\right)^{1/2}}\n$$\nThe iterative process is terminated when $\\mathrm{RelRes} \\le \\varepsilon = 10^{-6}$ or when the number of sweeps reaches the maximum limit of $N_{\\max}=100000$. The recorded result is the number of full sweeps performed.\n\nThe numerical experiment procedure for each $(N_x, N_y)$ pair is as follows:\n$1$. Set up a $(N_y+2) \\times (N_x+2)$ grid array for the pressure $p$, initialized to zero. This accommodates the homogeneous Dirichlet boundary conditions, which remain fixed at zero.\n$2$. Compute the grid spacings $\\Delta x$ and $\\Delta y$, and the coefficients $\\alpha_x$, $\\alpha_y$.\n$3$. Construct the source term array $f_{i,j}$ for the interior nodes $i \\in \\{1, \\dots, N_x\\}$, $j \\in \\{1, \\dots, N_y\\}$. Calculate and store its $L_2$-norm, $\\|f\\|_2$.\n$4$. Create boolean masks to identify the red and black interior nodes based on the parity of $i+j$.\n$5$. Begin the main iteration loop, initializing the sweep counter to zero.\n$6$. In each loop:\n    a. Increment the sweep counter.\n    b. Perform the red update for all red interior nodes using vectorized operations on the pressure array.\n    c. Perform the black update for all black interior nodes, using the newly updated red node values.\n    d. Calculate the residual field $r$ over the interior grid.\n    e. Compute the relative residual norm $\\mathrm{RelRes}$.\n    f. If $\\mathrm{RelRes} \\le 10^{-6}$, break the loop.\n$7$. Return the final sweep count. This procedure is repeated for each test case specified in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_rbgs_solver(Nx, Ny):\n    \"\"\"\n    Solves the 2D Poisson equation using Red-Black Gauss-Seidel iteration.\n\n    Args:\n        Nx (int): Number of interior pressure unknowns along x-direction.\n        Ny (int): Number of interior pressure unknowns along y-direction.\n\n    Returns:\n        int: The number of sweeps required to meet the convergence criteria.\n    \"\"\"\n    # Problem parameters\n    epsilon = 1e-6\n    N_max = 100000\n\n    # Grid setup\n    dx = 1.0 / (Nx + 1)\n    dy = 1.0 / (Ny + 1)\n    ax = 1.0 / (dx**2)\n    ay = 1.0 / (dy**2)\n    inv_denom = 1.0 / (2.0 * (ax + ay))\n\n    # Pressure field with boundary layers, initialized to zero\n    # This automatically enforces p=0 boundary conditions.\n    p = np.zeros((Ny + 2, Nx + 2))\n\n    # Source term f\n    # Create coordinate arrays for the full grid (including boundaries)\n    x = np.linspace(0, 1, Nx + 2)\n    y = np.linspace(0, 1, Ny + 2)\n    # The meshgrid is created for the full (Ny+2)x(Nx+2) domain\n    xx, yy = np.meshgrid(x, y) \n\n    f_full = -2.0 * (np.pi**2) * np.sin(np.pi * xx) * np.sin(np.pi * yy)\n    f_interior = f_full[1:-1, 1:-1]\n    norm_f = np.linalg.norm(f_interior)\n    \n    # Pre-compute Red-Black masks for interior points\n    # Index grid for interior points (1 to N, for formula i+j)\n    J, I = np.meshgrid(np.arange(1, Ny + 1), np.arange(1, Nx + 1), indexing='ij')\n    # red_mask: where i+j is even\n    red_mask = (I + J) % 2 == 0\n    # black_mask: where i+j is odd\n    black_mask = ~red_mask\n\n    sweeps = 0\n    for k in range(N_max):\n        sweeps += 1\n\n        # --- Red Update ---\n        # The update for red points depends on their black neighbors.\n        # We can calculate the update for all interior points based on the current\n        # state of p, and then apply it only to the red points.\n        neighbors_sum = (ax * (p[1:-1, 2:] + p[1:-1, :-2]) +\n                         ay * (p[2:, 1:-1] + p[:-2, 1:-1]))\n        p_new_interior = (neighbors_sum - f_interior) * inv_denom\n        p[1:-1, 1:-1][red_mask] = p_new_interior[red_mask]\n\n        # --- Black Update ---\n        # The update for black points depends on their red neighbors, which\n        # have just been updated. Recalculate and apply.\n        neighbors_sum = (ax * (p[1:-1, 2:] + p[1:-1, :-2]) +\n                         ay * (p[2:, 1:-1] + p[:-2, 1:-1]))\n        p_new_interior = (neighbors_sum - f_interior) * inv_denom\n        p[1:-1, 1:-1][black_mask] = p_new_interior[black_mask]\n\n        # --- Convergence Check after a full sweep ---\n        # Calculate the discrete Laplacian of the updated pressure field p\n        laplacian_p = (ax * (p[1:-1, 2:] + p[1:-1, :-2] - 2.0 * p[1:-1, 1:-1]) +\n                       ay * (p[2:, 1:-1] + p[:-2, 1:-1] - 2.0 * p[1:-1, 1:-1]))\n        \n        # Calculate the residual field r = A*p - f\n        r = laplacian_p - f_interior\n        \n        # Calculate the relative residual norm\n        rel_res = np.linalg.norm(r) / norm_f\n        \n        if rel_res <= epsilon:\n            break\n            \n    return sweeps\n\ndef solve():\n    \"\"\"\n    Main function to run the experiment for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 32), # Case 1\n        (48, 12), # Case 2\n        (12, 48), # Case 3\n        (8, 8),   # Case 4\n        (64, 16), # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny = case\n        result = run_rbgs_solver(Nx, Ny)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2438296"}, {"introduction": "While iterative methods are broadly applicable, specialized direct solvers can be far more efficient for certain problem structures. This practice introduces the use of the Fast Fourier Transform (FFT) to solve the pressure Poisson equation on a periodic domain, a common scenario in turbulence and materials science simulations. By diagonalizing the discrete Laplacian operator in Fourier space, you will implement a solution that is not only extremely fast but also accurate to machine precision [@problem_id:2438385].", "problem": "You are asked to derive and implement a solver for the pressure Poisson equation on a Marker and Cell (MAC) grid with periodic boundary conditions in both spatial directions, using the Discrete Fourier Transform (DFT) accelerated by the Fast Fourier Transform (FFT). The goal is to demonstrate a correct and efficient spectral solution that is consistent with a second-order central-difference discretization on a staggered MAC grid. The setting is dimensionless, so no physical units are required. Angles in trigonometric functions must be treated as radians.\n\nStarting point and definitions:\n- Consider a rectangular domain $\\Omega = [0,L_x) \\times [0,L_y)$ discretized into $N_x \\times N_y$ uniformly sized cells with spacings $\\Delta x = L_x / N_x$ and $\\Delta y = L_y / N_y$.\n- In the MAC grid arrangement, the pressure $p$ is stored at cell centers with indices $(i,j)$, where $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$. Let the center coordinates be $x_i = (i + \\tfrac{1}{2}) \\Delta x$ and $y_j = (j + \\tfrac{1}{2}) \\Delta y$.\n- The discrete Laplacian on cell centers is defined by the standard second-order central difference stencil with periodic indexing:\n$$\n(\\nabla_h^2 p)_{i,j} = \\frac{p_{i+1,j} - 2 p_{i,j} + p_{i-1,j}}{\\Delta x^2} + \\frac{p_{i,j+1} - 2 p_{i,j} + p_{i,j-1}}{\\Delta y^2},\n$$\nwhere indices wrap periodically, e.g., $p_{-1,j} \\equiv p_{N_x-1,j}$ and $p_{N_x,j} \\equiv p_{0,j}$, and similarly in the $y$-direction.\n\nTask A (derivation):\n- Starting from the incompressible flow projection idea on a MAC grid and the discrete divergence-free constraint, argue why a cell-centered pressure $p$ should satisfy a discrete Poisson equation of the form\n$$\n\\nabla_h^2 p = f,\n$$\nunder periodic boundary conditions, up to an arbitrary additive constant. Then show that for periodic grids the DFT diagonalizes the discrete Laplacian. Derive the Fourier-space eigenvalues of the discrete Laplacian in terms of $N_x$, $N_y$, $\\Delta x$, $\\Delta y$, and discrete wave indices. Discuss how to handle the zero-wave (mean) mode so that the computed pressure has zero spatial mean.\n\nTask B (implementation):\n- Implement a program that uses the FFT to solve the discrete Poisson equation for several manufactured solutions. For each test, construct a “right-hand side” $f$ by applying the discrete Laplacian defined above to a known cell-centered pressure field $p^{\\mathrm{true}}$. Then recover $p$ by solving in Fourier space and enforce the zero-mean gauge on the recovered solution. Report the maximum absolute gridpoint error between the recovered $p$ and the manufactured $p^{\\mathrm{true}}$ after subtracting their spatial means.\n\nDiscretization and numerical conventions:\n- All trigonometric function arguments are in radians.\n- For each test, define $p^{\\mathrm{true}}(x,y)$ on cell centers and compute $f$ strictly by the discrete operator $(\\nabla_h^2 p)_{i,j}$ given above.\n- Solve $\\nabla_h^2 p = f$ with periodic boundary conditions by diagonalizing with the DFT and using the FFT for efficiency. Explicitly set the zero-wave Fourier coefficient of $p$ to zero to impose the zero-mean gauge.\n\nTest suite:\nImplement the following test cases. For each case, compute a single floating-point number equal to the maximum absolute error between the recovered $p$ and the manufactured $p^{\\mathrm{true}}$ after subtracting their respective spatial means.\n\n- Test $1$ (happy path): $N_x = 32$, $N_y = 24$, $L_x = 1$, $L_y = 1$, and\n$$\np^{\\mathrm{true}}(x,y) = \\sin(2\\pi x) + \\cos(4\\pi y).\n$$\n- Test $2$ (incommensurate domain lengths and wavenumbers): $N_x = 17$, $N_y = 19$, $L_x = 2$, $L_y = 1$, and\n$$\np^{\\mathrm{true}}(x,y) = \\sin\\!\\Big(2\\pi \\cdot 3 \\frac{x}{L_x}\\Big) + \\sin\\!\\Big(2\\pi \\cdot 5 \\frac{y}{L_y}\\Big).\n$$\n- Test $3$ (zero right-hand side): $N_x = 20$, $N_y = 12$, $L_x = 1$, $L_y = 1$, and\n$$\np^{\\mathrm{true}}(x,y) \\equiv 0.\n$$\n- Test $4$ (anisotropic grid and domain): $N_x = 64$, $N_y = 8$, $L_x = 1$, $L_y = 2$, and\n$$\np^{\\mathrm{true}}(x,y) = \\cos\\!\\Big(2\\pi \\cdot 2 \\frac{x}{L_x}\\Big) + \\cos\\!\\Big(2\\pi \\cdot 1 \\frac{y}{L_y}\\Big).\n$$\n\nFinal output format:\n- Your program should produce a single line of output containing the results of the four tests as a comma-separated list enclosed in square brackets, in the order of Tests $1$ through $4$, for example\n$[e_1,e_2,e_3,e_4]$,\nwhere each $e_k$ is a floating-point number.", "solution": "The problem as stated is valid. It is scientifically grounded in the principles of computational fluid dynamics, specifically the projection method for incompressible flows. The mathematical formulation is well-posed, providing a discrete Poisson equation with periodic boundary conditions and a clear gauge condition (zero-mean pressure) to ensure a unique solution. All parameters and numerical methods are specified unambiguously, making the problem self-contained and solvable. It is a standard, objective exercise in numerical methods for partial differential equations.\n\nWe shall proceed with the derivation and solution.\n\nThe pressure Poisson equation is a cornerstone of algorithms for simulating incompressible flows, such as the projection method. In this method, an intermediate, non-solenoidal velocity field is first computed, and then it is projected onto the space of divergence-free vector fields. This projection step requires the solution of a Poisson equation for a scalar field, which is interpreted as the pressure.\n\nThe discrete form of the equation to be solved on a two-dimensional domain $\\Omega = [0,L_x) \\times [0,L_y)$ is\n$$\n\\nabla_h^2 p = f\n$$\nwhere $p$ is the pressure field defined at cell centers $(i,j)$ for $i \\in \\{0, \\dots, N_x-1\\}$ and $j \\in \\{0, \\dots, N_y-1\\}$, and $f$ is a given source term, which represents the divergence of the intermediate velocity field. The grid spacings are $\\Delta x = L_x / N_x$ and $\\Delta y = L_y / N_y$. The discrete Laplacian operator $\\nabla_h^2$ is given by the second-order central difference formula:\n$$\n(\\nabla_h^2 p)_{i,j} = \\frac{p_{i+1,j} - 2 p_{i,j} + p_{i-1,j}}{\\Delta x^2} + \\frac{p_{i,j+1} - 2 p_{i,j} + p_{i,j-1}}{\\Delta y^2}\n$$\nThe domain is periodic in both directions, which implies that all indices are evaluated modulo their respective grid dimensions, e.g., $p_{N_x,j} \\equiv p_{0,j}$ and $p_{-1,j} \\equiv p_{N_x-1,j}$.\n\nA necessary condition for the existence of a solution to this equation on a periodic domain is that the source term $f$ must have a zero mean. We can demonstrate this by summing the equation over all grid cells:\n$$\n\\sum_{j=0}^{N_y-1} \\sum_{i=0}^{N_x-1} (\\nabla_h^2 p)_{i,j} = \\sum_{j=0}^{N_y-1} \\sum_{i=0}^{N_x-1} f_{i,j}\n$$\nLet us examine the sum of the Laplacian term. Due to periodicity, the sums are telescoping and evaluate to zero:\n$$\n\\sum_{i=0}^{N_x-1} (p_{i+1,j} - 2 p_{i,j} + p_{i-1,j}) = (p_{1,j} - p_{0,j}) - (p_{0,j} - p_{N_x-1,j}) + \\dots + (p_{0,j} - p_{N_x-1,j}) - (p_{N_x-1,j} - p_{N_x-2,j}) = 0\n$$\nSince this holds for each component of the Laplacian and for each direction, the total sum is zero.\n$$\n\\sum_{j=0}^{N_y-1} \\sum_{i=0}^{N_x-1} (\\nabla_h^2 p)_{i,j} = 0\n$$\nTherefore, a solution can exist only if the compatibility condition is satisfied:\n$$\n\\sum_{j=0}^{N_y-1} \\sum_{i=0}^{N_x-1} f_{i,j} = 0\n$$\nIn this problem, the right-hand side $f$ is manufactured by applying the discrete Laplacian to a known field $p^{\\mathrm{true}}$, i.e., $f = \\nabla_h^2 p^{\\mathrm{true}}$. This construction inherently satisfies the compatibility condition.\n\nThe solution $p$ is unique only up to an additive constant, because for any constant $C$, $\\nabla_h^2(p+C) = \\nabla_h^2 p$. To obtain a unique solution, we impose a gauge condition. The problem specifies a zero-mean solution, i.e., $\\sum_{j,i} p_{i,j} = 0$.\n\nFor periodic boundary conditions, the discrete Laplacian is a linear, shift-invariant operator. Its eigenfunctions are the complex exponentials of the Discrete Fourier Transform (DFT). The 2D DFT pair for a grid function $q_{i,j}$ is given by:\n$$\n\\hat{q}_{k,l} = \\sum_{j=0}^{N_y-1} \\sum_{i=0}^{N_x-1} q_{i,j} e^{-i 2\\pi (ki/N_x + lj/N_y)} \\quad \\text{(Forward Transform)}\n$$\n$$\nq_{i,j} = \\frac{1}{N_x N_y} \\sum_{l=0}^{N_y-1} \\sum_{k=0}^{N_x-1} \\hat{q}_{k,l} e^{i 2\\pi (ki/N_x + lj/N_y)} \\quad \\text{(Inverse Transform)}\n$$\nwhere $k \\in \\{0, \\dots, N_x-1\\}$ and $l \\in \\{0, \\dots, N_y-1\\}$ are the discrete wavenumber indices. To find the eigenvalues of $\\nabla_h^2$, we apply it to a single Fourier mode, $E_{i,j}^{(k,l)} = e^{i 2\\pi (ki/N_x + lj/N_y)}$:\n$$\n(\\nabla_h^2 E^{(k,l)})_{i,j} = \\frac{E_{i+1,j}^{(k,l)} - 2 E_{i,j}^{(k,l)} + E_{i-1,j}^{(k,l)}}{\\Delta x^2} + \\frac{E_{i,j+1}^{(k,l)} - 2 E_{i,j}^{(k,l)} + E_{i,j-1}^{(k,l)}}{\\Delta y^2}\n$$\nSubstituting the expression for $E_{i,j}^{(k,l)}$:\n$$\n(\\nabla_h^2 E^{(k,l)})_{i,j} = E_{i,j}^{(k,l)} \\left[ \\frac{e^{i 2\\pi k/N_x} - 2 + e^{-i 2\\pi k/N_x}}{\\Delta x^2} + \\frac{e^{i 2\\pi l/N_y} - 2 + e^{-i 2\\pi l/N_y}}{\\Delta y^2} \\right]\n$$\nUsing the identity $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$, this simplifies to:\n$$\n(\\nabla_h^2 E^{(k,l)})_{i,j} = E_{i,j}^{(k,l)} \\left[ \\frac{2\\cos(2\\pi k/N_x) - 2}{\\Delta x^2} + \\frac{2\\cos(2\\pi l/N_y) - 2}{\\Delta y^2} \\right]\n$$\nUsing the half-angle identity $2\\cos(\\theta) - 2 = -4\\sin^2(\\theta/2)$, we arrive at the eigenvalues $\\lambda_{k,l}$ of the discrete Laplacian operator:\n$$\n\\lambda_{k,l} = -\\frac{4}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi k}{N_x}\\right) - \\frac{4}{\\Delta y^2} \\sin^2\\left(\\frac{\\pi l}{N_y}\\right)\n$$\nApplying the forward DFT to the Poisson equation $\\nabla_h^2 p = f$ transforms it into an algebraic equation in Fourier space:\n$$\n\\lambda_{k,l} \\hat{p}_{k,l} = \\hat{f}_{k,l}\n$$\nwhere $\\hat{p}$ and $\\hat{f}$ are the DFTs of $p$ and $f$, respectively. The Fourier coefficients of the solution are then found by division:\n$$\n\\hat{p}_{k,l} = \\frac{\\hat{f}_{k,l}}{\\lambda_{k,l}}\n$$\nWe must consider the case where $(k,l)=(0,0)$, which corresponds to the mean value (DC component) of the fields. For this mode, $\\lambda_{0,0} = 0$. The compatibility condition ensures that $\\hat{f}_{0,0} = \\sum_{i,j} f_{i,j} = 0$, leading to the indeterminate form $0/0$. This indeterminacy reflects the fact that the solution for pressure is unique only up to a constant. The value of $\\hat{p}_{0,0}$ is proportional to the mean of $p$. To enforce the specified gauge condition of zero mean pressure, we explicitly set the DC component of the solution to zero:\n$$\n\\hat{p}_{0,0} = 0\n$$\nFor all other modes $(k,l) \\neq (0,0)$, the eigenvalue $\\lambda_{k,l}$ is strictly negative, so the division is well-defined.\n\nThe overall algorithm is as follows:\n1.  Construct the grid and the true pressure field $p^{\\mathrm{true}}$ at cell centers.\n2.  Compute the right-hand side $f$ by applying the discrete Laplacian $\\nabla_h^2$ to $p^{\\mathrm{true}}$ using periodic shifts.\n3.  Compute the 2D DFT of $f$ to obtain $\\hat{f}_{k,l}$, using a Fast Fourier Transform (FFT) algorithm for efficiency.\n4.  Construct the matrix of eigenvalues $\\lambda_{k,l}$ corresponding to the wavenumber ordering of the FFT routine. Special care must be taken with negative frequencies.\n5.  Calculate the Fourier coefficients of the pressure, $\\hat{p}_{k,l}$, by dividing $\\hat{f}_{k,l}$ by $\\lambda_{k,l}$ for all non-zero modes. Set $\\hat{p}_{0,0}=0$.\n6.  Compute the recovered pressure field $p$ by applying the inverse 2D DFT (iFFT) to $\\hat{p}_{k,l}$. The result will be a real-valued field, up to machine precision.\n7.  To perform the error check, subtract the spatial mean from both the original $p^{\\mathrm{true}}$ and the recovered $p$.\n8.  The error is the maximum absolute difference between these two zero-mean fields over the entire grid. Due to the exact nature of the spectral method for this manufactured problem, the error is expected to be on the order of machine epsilon.", "answer": "```python\nimport numpy as np\n\ndef solve_poisson_fft(Nx, Ny, Lx, Ly, p_true_func):\n    \"\"\"\n    Solves the 2D pressure Poisson equation on a periodic MAC grid using FFT.\n\n    Args:\n        Nx (int): Number of cells in the x-direction.\n        Ny (int): Number of cells in the y-direction.\n        Lx (float): Domain length in the x-direction.\n        Ly (float): Domain length in the y-direction.\n        p_true_func (callable): Function defining the true pressure p_true(x, y).\n\n    Returns:\n        float: The maximum absolute error between the recovered pressure and the\n               true pressure, after both are set to have zero mean.\n    \"\"\"\n    # 1. Grid and true pressure setup\n    dx = Lx / Nx\n    dy = Ly / Ny\n\n    # Create cell-centered coordinates\n    x = (np.arange(Nx) + 0.5) * dx\n    y = (np.arange(Ny) + 0.5) * dy\n    x_grid, y_grid = np.meshgrid(x, y, indexing='xy') # Shape: (Ny, Nx)\n\n    p_true = p_true_func(x_grid, y_grid)\n\n    # 2. Compute the right-hand side f = laplacian(p_true)\n    # np.roll provides periodic boundary conditions\n    p_ip1 = np.roll(p_true, -1, axis=1)\n    p_im1 = np.roll(p_true, 1, axis=1)\n    p_jp1 = np.roll(p_true, -1, axis=0)\n    p_jm1 = np.roll(p_true, 1, axis=0)\n\n    laplacian_p = (p_ip1 - 2 * p_true + p_im1) / (dx**2) + \\\n                  (p_jp1 - 2 * p_true + p_jm1) / (dy**2)\n    f = laplacian_p\n\n    # 3. Forward FFT of the RHS\n    f_hat = np.fft.fft2(f)\n\n    # 4. Construct eigenvalues of the discrete Laplacian in Fourier space\n    # Use np.fft.fftfreq to get frequencies in cycles per grid point,\n    # which simplifies the sin argument.\n    freq_x = np.fft.fftfreq(Nx) # Shape (Nx,)\n    freq_y = np.fft.fftfreq(Ny) # Shape (Ny,)\n\n    # Create 2D frequency grids\n    # Note: meshgrid produces arrays with shape (Ny, Nx)\n    freq_x_grid, freq_y_grid = np.meshgrid(freq_x, freq_y, indexing='xy')\n\n    # Eigenvalues: lambda_kl = -4/dx^2 * sin^2(pi*k/Nx) - 4/dy^2 * sin^2(pi*l/Ny)\n    # With k/Nx = freq_x and l/Ny = freq_y\n    lambda_kl = (-4.0 / (dx**2)) * np.sin(np.pi * freq_x_grid)**2 \\\n              + (-4.0 / (dy**2)) * np.sin(np.pi * freq_y_grid)**2\n\n    # 5. Solve for p_hat in Fourier space\n    # Avoid division by zero for the (0,0) mode\n    # The compatibility condition f_hat[0,0] ~ 0 is met by construction\n    # Make a copy to modify\n    lambda_kl_inv = np.zeros_like(lambda_kl)\n    # Set inverse for all non-zero modes\n    non_zero_modes = lambda_kl != 0\n    lambda_kl_inv[non_zero_modes] = 1.0 / lambda_kl[non_zero_modes]\n    \n    # Calculate p_hat, the zero-mean gauge is naturally enforced\n    # because term for k=l=0 is 0 * 0.\n    p_hat = f_hat * lambda_kl_inv\n    \n    # Explicitly enforce zero-mean gauge by setting DC component to zero,\n    # which is good practice. In this case, it's already zero.\n    p_hat[0, 0] = 0.0\n\n    # 6. Inverse FFT to get recovered pressure\n    p_recovered = np.fft.ifft2(p_hat).real\n\n    # 7. Error calculation\n    # Subtract means to compare on an equal footing\n    p_true_zero_mean = p_true - np.mean(p_true)\n    p_recovered_zero_mean = p_recovered - np.mean(p_recovered)\n\n    # 8. Compute max absolute error\n    max_error = np.max(np.abs(p_true_zero_mean - p_recovered_zero_mean))\n    \n    return max_error\n\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the final results.\n    \"\"\"\n    test_cases = [\n        # Test 1\n        {\n            \"Nx\": 32, \"Ny\": 24, \"Lx\": 1.0, \"Ly\": 1.0,\n            \"p_true_func\": lambda x, y: np.sin(2 * np.pi * x) + np.cos(4 * np.pi * y)\n        },\n        # Test 2\n        {\n            \"Nx\": 17, \"Ny\": 19, \"Lx\": 2.0, \"Ly\": 1.0,\n            \"p_true_func\": lambda x, y: np.sin(2 * np.pi * 3 * x / 2.0) + np.sin(2 * np.pi * 5 * y / 1.0)\n        },\n        # Test 3\n        {\n            \"Nx\": 20, \"Ny\": 12, \"Lx\": 1.0, \"Ly\": 1.0,\n            \"p_true_func\": lambda x, y: np.zeros_like(x)\n        },\n        # Test 4\n        {\n            \"Nx\": 64, \"Ny\": 8, \"Lx\": 1.0, \"Ly\": 2.0,\n            \"p_true_func\": lambda x, y: np.cos(2 * np.pi * 2 * x / 1.0) + np.cos(2 * np.pi * 1 * y / 2.0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_poisson_fft(\n            case[\"Nx\"], case[\"Ny\"], case[\"Lx\"], case[\"Ly\"], case[\"p_true_func\"])\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2438385"}, {"introduction": "Real-world engineering problems rarely feature simple, grid-aligned boundaries. This advanced exercise challenges you to move beyond rectangular domains by implementing an embedded boundary method, often called a \"cut-cell\" technique. You will modify the standard finite-volume stencil to accurately impose Dirichlet boundary conditions on a complex, curved boundary that cuts arbitrarily through the Cartesian grid, a foundational skill for simulating flow around complex objects [@problem_id:2438357].", "problem": "You are to implement a two-dimensional embedded-boundary, cut-cell discretization for a scalar elliptic problem on a Marker-And-Cell (MAC) grid, with the unknown pressure stored at cell centers. The computational domain is the unit square with coordinates $(x,y) \\in [0,1] \\times [0,1]$ and a uniform Cartesian mesh of size $N \\times N$ with spacing $h = 1/N$. The pressure $p$ satisfies the steady Poisson equation with constant diffusion coefficient and a manufactured source in the fluid subdomain $\\Omega_f \\subset [0,1]^2$:\n$$ -\\nabla^2 p = f \\quad \\text{in } \\Omega_f, $$\nwith Dirichlet boundary conditions on both the outer boundary $\\partial [0,1]^2$ and on an internal embedded boundary $\\Gamma \\subset [0,1]^2$ that separates the fluid from the solid region. The embedded boundary is represented by a signed-distance level set $\\phi(x,y)$ such that $\\phi(x,y) \\ge 0$ in the fluid and $\\phi(x,y) < 0$ in the solid, with $\\Gamma = \\{(x,y): \\phi(x,y)=0\\}$. The MAC grid placement is such that pressure is stored at cell centers, while velocities would be stored at faces (you will not need velocities in this problem but should follow the MAC placement for pressure).\n\nYour implementation must start from first principles:\n- Finite-volume control of a cell-centered control volume with area $h^2$ in two dimensions, integrating the divergence form and using the divergence theorem to express fluxes across the four faces.\n- For each of the four coordinate-aligned directions, approximate the face-normal gradient using two-point fluxes between the cell center and either the neighboring fluid-cell center or the intersection point with the Dirichlet boundary where the boundary cuts the face-normal line, at a properly computed distance.\n\nUse the following well-tested base:\n- Manufactured solution $p^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y)$.\n- Source term $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$, since $\\Delta p^\\star = -2\\pi^2 p^\\star$ and thus $-\\nabla^2 p^\\star = 2\\pi^2 p^\\star$.\n- Dirichlet data on both the outer boundary and the embedded boundary equal to the manufactured solution: $p = p^\\star$.\n\nStaggered-grid context and stencil modification near the embedded boundary:\n- Pressure unknowns are stored at cell centers $(x_i,y_j)$ with $x_i = (i+1/2)h$, $y_j = (j+1/2)h$, where $i,j \\in \\{0,1,\\dots,N-1\\}$. Only cells with $\\phi(x_i,y_j) \\ge 0$ are fluid unknowns.\n- For each fluid cell, in the standard interior case with fluid neighbors in all four directions, use the five-point Laplacian stencil derived from the finite-volume flux balance:\n$$ \\frac{4p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1}}{h^2} = f(x_i,y_j). $$\n- For a neighbor in direction $d \\in \\{\\text{east, west, north, south}\\}$ that is outside the computational domain (outer Dirichlet boundary at a distance $\\delta = h/2$ from the cell center along direction $d$), replace the missing neighbor flux by a cut-face contribution that adds to the diagonal and the right-hand side:\n$$ a_{P} \\leftarrow a_{P} + \\frac{1}{h\\,\\delta}, \\quad b \\leftarrow b + \\frac{p_B}{h\\,\\delta}, $$\nwhere $p_B = p^\\star$ evaluated at the boundary point at distance $\\delta$ along direction $d$ from the cell center.\n- For a neighbor in direction $d$ that is a solid cell (i.e., $\\phi$ changes sign across that neighbor center), let $\\phi_P = \\phi(x_i,y_j)$ at the fluid cell center and $\\phi_N = \\phi$ at the neighboring center. Compute the fractional interface location along the center-to-center line as\n$$ \\lambda = \\frac{\\phi_P}{\\phi_P - \\phi_N}, \\quad \\delta = \\lambda\\,h, $$\nwith $\\lambda \\in (0,1)$, so that the interface lies a distance $\\delta$ from the fluid cell center along direction $d$. Approximate the cut-face flux by a two-point flux between the cell center and the Dirichlet boundary at the interface point, adding the same contribution as above with this $\\delta$:\n$$ a_{P} \\leftarrow a_{P} + \\frac{1}{h\\,\\delta}, \\quad b \\leftarrow b + \\frac{p_B}{h\\,\\delta}, $$\nwhere $p_B = p^\\star$ evaluated at the interface point displaced by $\\delta$ along direction $d$ from $(x_i,y_j)$.\n- For a neighbor in direction $d$ that is a fluid cell, use the standard neighbor coupling\n$$ a_{P} \\leftarrow a_{P} + \\frac{1}{h^2}, \\quad a_{N} \\leftarrow a_{N} - \\frac{1}{h^2}. $$\n\nThis yields a modified five-point stencil near cut cells that enforces Dirichlet conditions at the embedded boundary by replacing neighbor couplings with boundary contributions that depend on the distance to the interface. Assemble the linear system $A \\mathbf{p} = \\mathbf{b}$ over all fluid cells and solve for $\\mathbf{p}$. Then, compute the root-mean-square (RMS) error against $p^\\star$ over fluid cell centers:\n$$ \\varepsilon_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{(i,j)\\in \\Omega_f} \\left(p_{i,j} - p^\\star(x_i,y_j)\\right)^2}, $$\nwhere $M$ is the number of fluid cells.\n\nAngle units do not apply. All quantities are dimensionless; report errors as pure numbers.\n\nTest suite. Your program must run the following three test cases and return the three RMS errors as a single list in the order below:\n- Test $1$ (curved boundary, typical case): $N=64$, embedded boundary is a circle with center $(x_c,y_c)=(0.5,0.5)$ and radius $r=0.25$, with $\\phi(x,y) = \\sqrt{(x-x_c)^2+(y-y_c)^2} - r$. The fluid is the exterior of the circle, i.e., $\\phi \\ge 0$.\n- Test $2$ (grid-aligned boundary, reduction to standard stencil): $N=64$, embedded boundary is the vertical line at $x=0.5$, with $\\phi(x,y)=0.5-x$. The fluid is the region $x \\le 0.5$ (i.e., $\\phi \\ge 0$).\n- Test $3$ (small cut-cells near the outer boundary): $N=64$, embedded boundary is a circle with center $(x_c,y_c)=(0.75,0.5)$ and radius $r=0.24$ (so the closest approach to the right wall is $0.01$), with the same sign convention $\\phi \\ge 0$ for the fluid.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each result is the RMS error for the corresponding test in the order listed above.", "solution": "The problem statement is subjected to rigorous validation.\n\nStep 1: Extract Givens.\n- Governing Equation: $-\\nabla^2 p = f$ in the fluid domain $\\Omega_f$.\n- Computational Domain: $[0,1] \\times [0,1]$.\n- Mesh: Uniform $N \\times N$ Cartesian grid, spacing $h = 1/N$.\n- Grid Type: Marker-And-Cell (MAC), with pressure $p$ at cell centers $(x_i,y_j) = ((i+1/2)h, (j+1/2)h)$ for $i,j \\in \\{0, \\dots, N-1\\}$.\n- Fluid/Solid Definition: A level set function $\\phi(x,y)$ defines the domains. $\\Omega_f = \\{(x,y) | \\phi(x,y) \\ge 0\\}$ is the fluid region. $\\phi(x,y) < 0$ is the solid region. The interface is $\\Gamma = \\{(x,y) | \\phi(x,y) = 0\\}$.\n- Manufactured Solution: $p^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y)$.\n- Source Term: $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$.\n- Boundary Conditions: Dirichlet conditions $p = p^\\star(x,y)$ on the outer boundary $\\partial [0,1]^2$ and on the embedded boundary $\\Gamma$.\n- Discretization for Interior Cells: A five-point stencil for the Laplacian: $\\frac{4p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1}}{h^2} = f(x_i,y_j)$.\n- Discretization at Outer Boundary: For a face at distance $\\delta = h/2$ from the cell center, the matrix diagonal $a_P$ and right-hand side $b$ are modified: $a_{P} \\leftarrow a_{P} + \\frac{1}{h\\,\\delta}$ and $b \\leftarrow b + \\frac{p_B}{h\\,\\delta}$, where $p_B$ is $p^\\star$ at the boundary point.\n- Discretization at Embedded Boundary (Cut-Cell): For a fluid cell with center value $\\phi_P$ and a solid neighbor with center value $\\phi_N$, the distance to the interface is $\\delta = \\lambda h$, where $\\lambda = \\frac{\\phi_P}{\\phi_P - \\phi_N}$. The stencil modification is identical in form to the outer boundary case, using this new $\\delta$ and the corresponding boundary value $p_B = p^\\star$ at the interface point.\n- Error Metric: Root-Mean-Square (RMS) error $\\varepsilon_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{(i,j)\\in \\Omega_f} \\left(p_{i,j} - p^\\star(x_i,y_j)\\right)^2}$, where $M$ is the count of fluid cells.\n- Test Cases: Three specific cases are defined by $N$ and the function $\\phi(x,y)$.\n\nStep 2: Validate Using Extracted Givens.\n- **Scientifically Grounded:** The problem describes a standard numerical method (finite volume with cut-cell embedded boundaries) for a canonical elliptic partial differential equation (the Poisson equation). The Method of Manufactured Solutions is a rigorous technique for code verification. The entire problem is firmly rooted in the principles of numerical analysis and computational engineering.\n- **Well-Posed:** The underlying physical problem (Poisson equation with Dirichlet conditions) is well-posed. The described discretization leads to a linear system $A \\mathbf{p} = \\mathbf{b}$ where the matrix $A$ is sparse, symmetric positive-definite (or can be made so), and typically diagonally dominant, ensuring a unique and stable numerical solution exists.\n- **Objective:** The problem is specified with precise mathematical equations, boundary conditions, and numerical parameters. It is free from subjective or ambiguous language.\n\nStep 3: Verdict and Action.\nThe problem is found to be scientifically sound, well-posed, objective, and self-contained. It is a valid problem in computational engineering. I will proceed with a full solution.\n\nThe problem requires the construction of a finite-volume solver for the scalar Poisson equation $-\\nabla^2 p = f$. We begin from the integral form of the equation over a control volume $V_{i,j}$, which is a square cell of area $h^2$ centered at $(x_i, y_j)$. Applying the divergence theorem to the Laplacian term gives:\n$$ -\\int_{V_{i,j}} \\nabla \\cdot (\\nabla p) \\, dV = \\int_{V_{i,j}} f \\, dV $$\n$$ -\\oint_{\\partial V_{i,j}} \\nabla p \\cdot \\mathbf{n} \\, dS = \\int_{V_{i,j}} f \\, dV $$\nIn two dimensions, the control volume is an area and the boundary integral is a line integral over the four faces of the cell (east, west, north, south). Let the side length of the cell be $h$. The equation becomes:\n$$ -\\left[ \\int_{\\text{east}} \\frac{\\partial p}{\\partial x} dy - \\int_{\\text{west}} \\frac{\\partial p}{\\partial x} dy + \\int_{\\text{north}} \\frac{\\partial p}{\\partial y} dx - \\int_{\\text{south}} \\frac{\\partial p}{\\partial y} dx \\right] \\approx f(x_i, y_j) h^2 $$\nApproximating the integrals and gradients, the total flux out of the cell is the sum of fluxes across the four faces. The flux across the east face, for example, is $-h (\\frac{\\partial p}{\\partial x})_e$. The discrete equation for cell $(i,j)$ is a balance of these fluxes:\n$$ -h \\left[ (\\nabla p \\cdot \\mathbf{n})_e + (\\nabla p \\cdot \\mathbf{n})_w + (\\nabla p \\cdot \\mathbf{n})_n + (\\nabla p \\cdot \\mathbf{n})_s \\right] = f_{i,j} h^2 $$\n$$ (\\nabla p \\cdot \\mathbf{n})_e + (\\nabla p \\cdot \\mathbf{n})_w + (\\nabla p \\cdot \\mathbf{n})_n + (\\nabla p \\cdot \\mathbf{n})_s = -f_{i,j} h $$\nWe approximate the normal gradient at each face using a two-point finite difference. The specific approximation depends on whether the neighboring cell is fluid, solid, or outside the domain. Summing all contributions gives a linear equation for $p_{i,j}$.\n\nFor a cell $(i,j)$ where all four neighbors—$(i\\pm1, j)$ and $(i, j\\pm1)$—are also fluid cells, the gradients are approximated using centered differences. For the east face, the gradient is $(\\frac{\\partial p}{\\partial x})_e \\approx \\frac{p_{i+1,j} - p_{i,j}}{h}$. Summing all four flux approximations yields the standard five-point stencil for the negative Laplacian, scaled by $h^2$:\n$$ \\frac{4p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1}}{h^2} = f(x_i,y_j) $$\nThis equation can be rearranged to show contributions to a linear system. For each fluid neighbor, say $(i+1,j)$, the terms are $\\frac{1}{h^2}p_{i,j} - \\frac{1}{h^2}p_{i+1,j}$. This corresponds to adding $\\frac{1}{h^2}$ to the diagonal matrix element for $p_{i,j}$ and $-\\frac{1}{h^2}$ to the off-diagonal element corresponding to the neighbor $p_{i+1,j}$.\n\nWhen a cell face lies on the outer computational boundary (e.g., $x=1$), a Dirichlet condition $p=p_B$ is applied. The face is located at a distance $\\delta = h/2$ from the cell center. The normal gradient is approximated by a one-sided difference: $(\\frac{\\partial p}{\\partial x})_e \\approx \\frac{p_B - p_{i,j}}{\\delta}$. The contribution to the flux balance from this face is $\\frac{p_{i,j} - p_B}{h\\delta}$. This modifies the linear equation for $p_{i,j}$ by adding $\\frac{1}{h\\delta}$ to the diagonal coefficient and adding the known term $\\frac{p_B}{h\\delta}$ to the right-hand side vector.\n\nWhen a fluid cell $(i,j)$ is adjacent to a solid cell, the embedded boundary $\\Gamma$ cuts through the grid. We use the level set function $\\phi$ to locate the interface. Let $\\phi_P = \\phi(x_i, y_j) \\ge 0$ be the value at the fluid cell center and $\\phi_N < 0$ be the value at the solid neighbor's center. Assuming $\\phi$ is a signed distance function, linear interpolation gives the fractional distance to the interface as $\\lambda = \\frac{\\phi_P}{\\phi_P - \\phi_N}$. The actual distance is $\\delta = \\lambda h$. The Dirichlet condition $p=p_B$ is applied at this interpolated point on the boundary. The gradient approximation becomes $\\frac{p_B - p_{i,j}}{\\delta}$, and the flux contribution is $\\frac{p_{i,j} - p_B}{h\\delta}$. This results in a stencil modification identical in form to the outer boundary case: the diagonal element is incremented by $\\frac{1}{h\\delta}$ and the right-hand side is incremented by $\\frac{p_B}{h\\delta}$.\n\nA critical edge case arises if a fluid cell center lies on the boundary, i.e., $\\phi(x_i, y_j)=0$. This leads to $\\lambda=0$ and $\\delta=0$, creating a singularity in the flux term $\\frac{1}{h\\delta}$. This is the \"small cell\" problem. The physically correct and numerically stable approach is to recognize that the pressure at this cell center is known by the Dirichlet condition. Therefore, for such a cell, we discard the flux balance equation and directly enforce $p_{i,j} = p^\\star(x_i, y_j)$. In the linear system $A\\mathbf{p}=\\mathbf{b}$, this is accomplished by setting the corresponding row of $A$ to the identity (1 on the diagonal, 0 elsewhere) and setting the corresponding element of $\\mathbf{b}$ to the known boundary value.\n\nThe overall algorithm is as follows:\n1.  Identify all fluid cells where $\\phi(x_i, y_j) \\ge 0$. Create a mapping from the 2D indices $(i,j)$ of these $M$ cells to a 1D index $k \\in [0, M-1]$.\n2.  Construct the $M \\times M$ sparse matrix $A$ and the $M \\times 1$ vector $\\mathbf{b}$.\n3.  For each fluid cell $(i,j)$, iterate through its four neighbors.\n4.  For each neighbor, apply the appropriate rule: standard five-point coupling for a fluid neighbor, or the boundary flux modification for an outer boundary or a solid (cut-cell) neighbor. Update the coefficients of $A$ and the entries of $\\mathbf{b}$ accordingly. Handle the $\\delta=0$ case by setting the Dirichlet condition directly.\n5.  Solve the resulting sparse linear system $A\\mathbf{p} = \\mathbf{b}$ for the vector of unknown pressures $\\mathbf{p}$.\n6.  Compute the RMS error by comparing the numerical solution $p_{i,j}$ to the exact manufactured solution $p^\\star(x_i, y_j)$ over all fluid cells.\n\nThis procedure is implemented for each of the three test cases specified in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef p_star(x: np.ndarray, y: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the manufactured solution for pressure.\n    All mathematical entities are in LaTeX as required by the role, but not in code comments.\n    p_star(x,y) = sin(pi * x) * sin(pi * y)\n    \"\"\"\n    return np.sin(np.pi * x) * np.sin(np.pi * y)\n\ndef f_source(x: np.ndarray, y: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the source term f(x,y) corresponding to the manufactured solution.\n    -nabla^2 p_star = 2 * pi^2 * sin(pi * x) * sin(pi * y)\n    \"\"\"\n    return 2.0 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n\ndef run_case(N: int, phi_func) -> float:\n    \"\"\"\n    Sets up and solves the Poisson problem for a given test case configuration.\n\n    Args:\n        N: The number of grid cells in each dimension.\n        phi_func: A callable function phi(x,y) that defines the level set.\n\n    Returns:\n        The root-mean-square error of the numerical solution.\n    \"\"\"\n    h = 1.0 / N\n    h2 = h * h\n\n    # Create grid for cell centers\n    i_coords = np.arange(N)\n    j_coords = np.arange(N)\n    x_centers = (i_coords + 0.5) * h\n    y_centers = (j_coords + 0.5) * h\n    xx, yy = np.meshgrid(x_centers, y_centers, indexing='ij')\n\n    # Evaluate level set and identify fluid cells\n    phi_grid = phi_func(xx, yy)\n    is_fluid = phi_grid >= 0\n\n    # Map 2D fluid cell indices to a 1D linear system index\n    fluid_indices = np.where(is_fluid)\n    num_fluid_cells = len(fluid_indices[0])\n    \n    map_ij_to_k = -np.ones((N, N), dtype=int)\n    map_ij_to_k[fluid_indices] = np.arange(num_fluid_cells)\n\n    # Initialize sparse matrix A and vector b\n    A = lil_matrix((num_fluid_cells, num_fluid_cells))\n    b = np.zeros(num_fluid_cells)\n\n    # Iterate over all grid cells to build the linear system\n    for i in range(N):\n        for j in range(N):\n            if not is_fluid[i, j]:\n                continue\n\n            k = map_ij_to_k[i, j]\n            xi, yj = xx[i, j], yy[i, j]\n            \n            # Start with source term on RHS: ... = f_ij\n            b[k] = f_source(xi, yj)\n\n            p_center_phi = phi_grid[i, j]\n\n            # Special case: cell center lies on the boundary (phi_P = 0).\n            # This would lead to delta = 0, causing a singularity.\n            # We enforce the Dirichlet condition directly on this node.\n            if np.isclose(p_center_phi, 0.0):\n                A[k, :] = 0.0\n                A[k, k] = 1.0\n                b[k] = p_star(xi, yj)\n                continue  # Equation for this cell is now fixed.\n\n            # Process 4 neighbors (East, West, North, South)\n            # Tuple format: (di, dj) for index offset\n            neighbors = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n            \n            for di, dj in neighbors:\n                ni, nj = i + di, j + dj\n\n                # Case 1: Outer boundary of the [0,1]x[0,1] domain\n                if not (0 <= ni < N and 0 <= nj < N):\n                    delta = h / 2.0\n                    xb = xi + di * delta\n                    yb = yj + dj * delta\n                    pb = p_star(xb, yb)\n                    \n                    A[k, k] += 1.0 / (h * delta)\n                    b[k] += pb / (h * delta)\n\n                # Case 2 & 3: Internal neighbor (either fluid or solid)\n                else:\n                    # Case 2: Neighbor is a fluid cell\n                    if is_fluid[ni, nj]:\n                        nk = map_ij_to_k[ni, nj]\n                        A[k, k] += 1.0 / h2\n                        A[k, nk] -= 1.0 / h2\n                    \n                    # Case 3: Neighbor is a solid cell (cut-cell)\n                    else:\n                        p_neighbor_phi = phi_grid[ni, nj]\n                        phi_diff = p_center_phi - p_neighbor_phi\n                        \n                        # Since phi_P > 0 and phi_N < 0, phi_diff is safely non-zero.\n                        lambda_frac = p_center_phi / phi_diff\n                        delta = lambda_frac * h\n                        \n                        # Interface point coordinates\n                        xb = xi + di * delta\n                        yb = yj + dj * delta\n                        pb = p_star(xb, yb)\n                        \n                        A[k, k] += 1.0 / (h * delta)\n                        b[k] += pb / (h * delta)\n\n    # Solve the linear system\n    A_csc = csc_matrix(A)\n    p_vec = spsolve(A_csc, b)\n\n    # Calculate RMS error\n    p_solution_grid = np.full((N, N), np.nan)\n    p_solution_grid[fluid_indices] = p_vec\n\n    p_exact_grid = p_star(xx, yy)\n    \n    squared_errors = (p_solution_grid[is_fluid] - p_exact_grid[is_fluid])**2\n    rms_error = np.sqrt(np.mean(squared_errors))\n    \n    return rms_error\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 64,\n            \"phi_func\": lambda x, y: np.sqrt((x - 0.5)**2 + (y - 0.5)**2) - 0.25\n        },\n        {\n            \"N\": 64,\n            \"phi_func\": lambda x, y: 0.5 - x\n        },\n        {\n            \"N\": 64,\n            \"phi_func\": lambda x, y: np.sqrt((x - 0.75)**2 + (y - 0.5)**2) - 0.24\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rms_error = run_case(case[\"N\"], case[\"phi_func\"])\n        results.append(rms_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2438357"}]}