{"hands_on_practices": [{"introduction": "This first exercise grounds our understanding in the fundamental mechanics of Galerkin projection. It is a \"pencil-and-paper\" task that directly connects the continuous operators of a partial differential equation (PDE) to the matrix structure of the resulting ROM. By manually deriving the reduced-order model for the classic 1D advection-diffusion equation [@problem_id:2432108], we will see how the physical processes of advection and diffusion are mathematically transformed into matrices with distinct properties, a crucial insight for analyzing the stability and energy conservation of reduced-order models.", "problem": "Consider the one-dimensional advection-diffusion equation on the spatial interval $x \\in (0,1)$ with homogeneous Dirichlet boundary conditions\n$$\n\\frac{\\partial u}{\\partial t} + a\\,\\frac{\\partial u}{\\partial x} = \\nu\\,\\frac{\\partial^2 u}{\\partial x^2}, \\quad u(0,t)=u(1,t)=0,\n$$\nwhere $a>0$ is the constant advection speed and $\\nu>0$ is the constant kinematic viscosity. Suppose a Proper Orthogonal Decomposition (POD) basis is available and coincides with the first $r$ sine eigenfunctions of the Dirichlet Laplacian, namely\n$$\n\\phi_k(x) = \\sqrt{2}\\,\\sin(k\\pi x), \\quad k=1,\\dots,r,\n$$\nwhich are orthonormal in the $L^2(0,1)$ inner product. Use a standard Galerkin projection onto $\\text{span}\\{\\phi_1,\\dots,\\phi_r\\}$ with the $L^2(0,1)$ inner product to derive the reduced-order model (ROM) for the generalized coordinates $q_k(t)$ defined by the ansatz\n$$\nu(x,t) \\approx \\sum_{k=1}^r q_k(t)\\,\\phi_k(x).\n$$\nIdentify the reduced advection matrix and reduced diffusion matrix by expressing the ROM in the form\n$$\nM\\,\\dot{\\boldsymbol{q}}(t) + a\\,C\\,\\boldsymbol{q}(t) + \\nu\\,K\\,\\boldsymbol{q}(t) = \\boldsymbol{0},\n$$\nwhere $M$ is the reduced mass matrix, $C$ is the reduced advection matrix, and $K$ is the reduced diffusion (stiffness) matrix. Then analyze the energetic roles of $C$ and $K$ in terms of the evolution of the reduced kinetic energy defined by $\\frac{1}{2}\\|\\boldsymbol{q}(t)\\|_2^2$.\n\nFinally, let $r=4$ and define the following dimensionless scalar that quantifies, at the reduced level, the worst-case ratio of advection to diffusion strengths:\n$$\n\\rho_4 \\equiv \\frac{a\\,\\max_{1\\leq i\\neq j\\leq 4} |C_{ij}|}{\\nu\\,\\max_{1\\leq i\\leq 4} K_{ii}}.\n$$\nCompute a closed-form analytical expression for $\\rho_4$ in terms of $a$, $\\nu$, and $\\pi$. Your final answer must be a single expression. No rounding is required, and no units should be included in the final expression.", "solution": "We substitute the ansatz $u(x,t) = \\sum_{k=1}^r q_k(t)\\phi_k(x)$ into the governing PDE:\n$$\n\\frac{\\partial}{\\partial t}\\left(\\sum_{k=1}^r q_k(t)\\phi_k(x)\\right) + a\\,\\frac{\\partial}{\\partial x}\\left(\\sum_{k=1}^r q_k(t)\\phi_k(x)\\right) = \\nu\\,\\frac{\\partial^2}{\\partial x^2}\\left(\\sum_{k=1}^r q_k(t)\\phi_k(x)\\right)\n$$\nBy linearity of the derivatives, this becomes:\n$$\n\\sum_{k=1}^r \\dot{q}_k(t)\\phi_k(x) + a\\sum_{k=1}^r q_k(t)\\frac{d\\phi_k}{dx}(x) - \\nu\\sum_{k=1}^r q_k(t)\\frac{d^2\\phi_k}{dx^2}(x) = 0\n$$\nThe Galerkin projection requires the residual of this equation to be orthogonal to each basis function $\\phi_j(x)$ for $j=1,\\dots,r$. This is expressed using the $L^2(0,1)$ inner product $\\langle \\cdot, \\cdot \\rangle$:\n$$\n\\left\\langle \\sum_{k=1}^r \\dot{q}_k\\phi_k + a\\sum_{k=1}^r q_k\\frac{d\\phi_k}{dx} - \\nu\\sum_{k=1}^r q_k\\frac{d^2\\phi_k}{dx^2}, \\phi_j \\right\\rangle = 0 \\quad \\text{for } j=1,\\dots,r\n$$\nExploiting the linearity of the inner product, we obtain a system of ordinary differential equations:\n$$\n\\sum_{k=1}^r \\langle \\phi_k, \\phi_j \\rangle \\dot{q}_k(t) + a \\sum_{k=1}^r \\left\\langle \\frac{d\\phi_k}{dx}, \\phi_j \\right\\rangle q_k(t) - \\nu \\sum_{k=1}^r \\left\\langle \\frac{d^2\\phi_k}{dx^2}, \\phi_j \\right\\rangle q_k(t) = 0\n$$\nThis system can be written in the matrix form $M\\dot{\\boldsymbol{q}} + aC\\boldsymbol{q} + \\nu K\\boldsymbol{q} = \\boldsymbol{0}$ by defining the matrix entries as follows:\n$M_{jk} = \\langle \\phi_k, \\phi_j \\rangle$\n$C_{jk} = \\left\\langle \\frac{d\\phi_k}{dx}, \\phi_j \\right\\rangle$\n$K_{jk} = -\\left\\langle \\frac{d^2\\phi_k}{dx^2}, \\phi_j \\right\\rangle$\n\nWe now compute the entries for each matrix.\nReduced Mass Matrix $M$: Since the basis $\\{\\phi_k\\}$ is orthonormal, $M_{jk} = \\langle \\phi_k, \\phi_j \\rangle = \\delta_{jk}$, where $\\delta_{jk}$ is the Kronecker delta. Thus, $M$ is the $r \\times r$ identity matrix, $I$.\n\nReduced Stiffness (Diffusion) Matrix $K$: The basis functions are eigenfunctions of the negative Laplacian with Dirichlet boundary conditions. First, we compute the second derivative of $\\phi_k(x)$:\n$$\n\\frac{d^2\\phi_k}{dx^2} = \\frac{d^2}{dx^2}\\left(\\sqrt{2}\\sin(k\\pi x)\\right) = -(k\\pi)^2 \\sqrt{2}\\sin(k\\pi x) = -(k\\pi)^2 \\phi_k(x)\n$$\nSubstituting this into the definition of $K_{jk}$:\n$$\nK_{jk} = -\\langle -(k\\pi)^2\\phi_k, \\phi_j \\rangle = (k\\pi)^2 \\langle \\phi_k, \\phi_j \\rangle = (k\\pi)^2 \\delta_{jk}\n$$\nThe matrix $K$ is therefore a diagonal matrix with entries $K_{kk} = (k\\pi)^2$.\n\nReduced Advection Matrix $C$: The entries are given by the integral:\n$$\nC_{jk} = \\left\\langle \\frac{d\\phi_k}{dx}, \\phi_j \\right\\rangle = \\int_0^1 \\left(\\frac{d}{dx}(\\sqrt{2}\\sin(k\\pi x))\\right)(\\sqrt{2}\\sin(j\\pi x))\\,dx = 2k\\pi \\int_0^1 \\cos(k\\pi x)\\sin(j\\pi x)\\,dx\n$$\nUsing the product-to-sum identity $\\sin(A)\\cos(B) = \\frac{1}{2}(\\sin(A+B)+\\sin(A-B))$, we get:\n$$\nC_{jk} = k\\pi \\int_0^1 \\left( \\sin((j+k)\\pi x) + \\sin((j-k)\\pi x) \\right)\\,dx\n$$\nIf $j=k$, the integrand is $\\sin(2k\\pi x)$, whose integral over $[0,1]$ is $0$. Thus, $C_{kk}=0$. This is consistent with the general property that $C$ is skew-symmetric ($C_{jk} = -C_{kj}$) due to the homogeneous boundary conditions, which can be shown via integration by parts: $C_{jk} = \\int_0^1 \\phi_j \\phi_k' dx = [\\phi_j \\phi_k]_0^1 - \\int_0^1 \\phi_j' \\phi_k dx = 0 - C_{kj}$.\nIf $j \\neq k$:\n$$\nC_{jk} = k\\pi \\left[ -\\frac{\\cos((j+k)\\pi x)}{(j+k)\\pi} - \\frac{\\cos((j-k)\\pi x)}{(j-k)\\pi} \\right]_0^1 = -k \\left( \\frac{(-1)^{j+k}-1}{j+k} + \\frac{(-1)^{j-k}-1}{j-k} \\right)\n$$\nAs $(-1)^{j-k} = (-1)^{j+k}$, we simplify:\n$$\nC_{jk} = -k ((-1)^{j+k}-1) \\left( \\frac{1}{j+k} + \\frac{1}{j-k} \\right) = -k ((-1)^{j+k}-1) \\frac{2j}{j^2-k^2} = \\frac{2jk}{k^2-j^2}((-1)^{j+k}-1)\n$$\nIf $j+k$ is even, $(-1)^{j+k}-1=0$, so $C_{jk}=0$.\nIf $j+k$ is odd, $(-1)^{j+k}-1=-2$, so $C_{jk} = \\frac{2jk}{k^2-j^2}(-2) = \\frac{4jk}{j^2-k^2}$.\n\nEnergetic Analysis of $C$ and $K$\nThe reduced system is $\\dot{\\boldsymbol{q}}(t) + a\\,C\\,\\boldsymbol{q}(t) + \\nu\\,K\\,\\boldsymbol{q}(t) = \\boldsymbol{0}$. The reduced kinetic energy is $E(t) = \\frac{1}{2}\\|\\boldsymbol{q}(t)\\|_2^2 = \\frac{1}{2}\\boldsymbol{q}(t)^T\\boldsymbol{q}(t)$. Its time derivative is:\n$$\n\\frac{dE}{dt} = \\frac{1}{2}(\\dot{\\boldsymbol{q}}^T\\boldsymbol{q} + \\boldsymbol{q}^T\\dot{\\boldsymbol{q}}) = \\boldsymbol{q}^T\\dot{\\boldsymbol{q}}\n$$\nSubstituting $\\dot{\\boldsymbol{q}} = -aC\\boldsymbol{q} - \\nu K\\boldsymbol{q}$:\n$$\n\\frac{dE}{dt} = \\boldsymbol{q}^T(-aC\\boldsymbol{q} - \\nu K\\boldsymbol{q}) = -a\\,\\boldsymbol{q}^T C \\boldsymbol{q} - \\nu\\,\\boldsymbol{q}^T K \\boldsymbol{q}\n$$\n-   Role of $C$: The matrix $C$ is skew-symmetric, i.e., $C^T = -C$. For any vector $\\boldsymbol{q}$, the quadratic form $\\boldsymbol{q}^T C \\boldsymbol{q}$ is always zero. This is because $\\boldsymbol{q}^T C \\boldsymbol{q} = (\\boldsymbol{q}^T C \\boldsymbol{q})^T = \\boldsymbol{q}^T C^T \\boldsymbol{q} = -\\boldsymbol{q}^T C \\boldsymbol{q}$, which implies $2\\boldsymbol{q}^T C \\boldsymbol{q}=0$. Therefore, the advection term $-a\\,\\boldsymbol{q}^T C \\boldsymbol{q}$ does not contribute to the change in energy. The reduced advection operator is energy-conserving.\n-   Role of $K$: The matrix $K$ is diagonal with entries $(k\\pi)^2 > 0$. Thus, $K$ is symmetric and positive definite. The quadratic form is $\\boldsymbol{q}^T K \\boldsymbol{q} = \\sum_{k=1}^r (k\\pi)^2 q_k^2 \\ge 0$. This term is zero only if $\\boldsymbol{q}=\\boldsymbol{0}$. Since $\\nu>0$, the diffusion term $-\\nu\\,\\boldsymbol{q}^T K \\boldsymbol{q}$ is always less than or equal to zero. The reduced diffusion operator is purely dissipative, continuously removing energy from the system unless it is at rest.\n\nComputation of $\\rho_4$\nThe expression to compute is $\\rho_4 = \\frac{a\\,\\max_{1\\leq i\\neq j\\leq 4} |C_{ij}|}{\\nu\\,\\max_{1\\leq i\\leq 4} K_{ii}}$, where $r=4$.\n\nDenominator: The diagonal entries of $K$ are $K_{ii} = (i\\pi)^2$. We need the maximum for $i \\in \\{1,2,3,4\\}$.\n$$\n\\max_{1\\leq i\\leq 4} K_{ii} = \\max\\{(1\\pi)^2, (2\\pi)^2, (3\\pi)^2, (4\\pi)^2\\} = (4\\pi)^2 = 16\\pi^2\n$$\n\nNumerator: We need to find the maximum of $|C_{ij}|$ for $1 \\leq i \\neq j \\leq 4$. We only need to check pairs $(i,j)$ where $i+j$ is odd, and we can assume $i<j$ due to symmetry of the absolute value, $|C_{ij}|=|C_{ji}|$.\nThe non-zero off-diagonal entries are for pairs with opposite parity:\n-   $(i,j)=(1,2)$: $i+j=3$ (odd). $|C_{12}| = \\left|\\frac{4(1)(2)}{1^2-2^2}\\right| = \\left|\\frac{8}{-3}\\right| = \\frac{8}{3}$.\n-   $(i,j)=(1,4)$: $i+j=5$ (odd). $|C_{14}| = \\left|\\frac{4(1)(4)}{1^2-4^2}\\right| = \\left|\\frac{16}{-15}\\right| = \\frac{16}{15}$.\n-   $(i,j)=(2,3)$: $i+j=5$ (odd). $|C_{23}| = \\left|\\frac{4(2)(3)}{2^2-3^2}\\right| = \\left|\\frac{24}{-5}\\right| = \\frac{24}{5}$.\n-   $(i,j)=(3,4)$: $i+j=7$ (odd). $|C_{34}| = \\left|\\frac{4(3)(4)}{3^2-4^2}\\right| = \\left|\\frac{48}{9-16}\\right| = \\left|\\frac{48}{-7}\\right| = \\frac{48}{7}$.\nAll other pairs $(i,j)$ with $i<j$ have $i+j$ even: $(1,3)$, $(2,4)$. Thus $C_{13}=C_{24}=0$.\nWe must find the maximum of $\\{\\frac{8}{3}, \\frac{16}{15}, \\frac{24}{5}, \\frac{48}{7}\\}$.\nConverting to decimals for comparison:\n$\\frac{8}{3} \\approx 2.667$\n$\\frac{16}{15} \\approx 1.067$\n$\\frac{24}{5} = 4.8$\n$\\frac{48}{7} \\approx 6.857$\nThe maximum value is $\\frac{48}{7}$.\n\nFinal Assembly of $\\rho_4$:\nSubstituting the maximum values into the expression for $\\rho_4$:\n$$\n\\rho_4 = \\frac{a \\left( \\frac{48}{7} \\right)}{\\nu (16\\pi^2)} = \\frac{a}{\\nu} \\frac{48}{7 \\cdot 16\\pi^2} = \\frac{a}{\\nu} \\frac{3 \\cdot 16}{7 \\cdot 16\\pi^2} = \\frac{3a}{7\\nu\\pi^2}\n$$", "answer": "$$\n\\boxed{\\frac{3a}{7\\nu\\pi^{2}}}\n$$", "id": "2432108"}, {"introduction": "Building on the analytical foundation, this practice guides you through the complete computational pipeline for creating a ROM. We will tackle a practical 2D heat diffusion problem on a non-trivial L-shaped domain [@problem_id:2432054]. This comprehensive exercise covers every step from the initial setup—discretizing the PDE and simulating the full-order model to generate data—to the core model reduction tasks of extracting a POD basis via SVD and projecting the dynamics to build and evaluate the final ROM.", "problem": "Consider the two-dimensional heat equation on an L-shaped domain. Let the spatial domain be the open unit square with the upper-right quarter removed, namely\n$$\n\\Omega_L = (0,1)\\times(0,1)\\setminus([0.5,1]\\times[0.5,1]).\n$$\nLet $u(x,y,t)$ satisfy the homogeneous Dirichlet initial-boundary value problem\n$$\n\\frac{\\partial u}{\\partial t}(x,y,t) = \\kappa \\,\\Delta u(x,y,t)\\ \\text{for}\\ (x,y)\\in \\Omega_L,\\ t>0,\\quad\nu(x,y,t)=0\\ \\text{for}\\ (x,y)\\in \\partial \\Omega_L,\\ t\\ge 0,\\quad\nu(x,y,0)=u_0(x,y),\n$$\nwith diffusivity $\\kappa = 1$ and initial condition\n$$\nu_0(x,y)=\\exp\\!\\left(-\\frac{(x-0.5)^2+(y-0.5)^2}{\\sigma^2}\\right),\\quad \\sigma=0.12.\n$$\nDiscretize $\\Omega_L$ on a uniform Cartesian grid with $N=41$ points in each spatial direction, uniform spacing $h=1/(N-1)$, and consider the interior grid nodes with indices $i,j\\in\\{1,2,\\dots,N-2\\}$ as unknowns. A node $(x_i,y_j)$ is included in the computational set if and only if it belongs to $\\Omega_L$, i.e., if $\\neg(x_i\\ge 0.5\\ \\wedge\\ y_j\\ge 0.5)$. Use the standard five-point discrete Laplacian with homogeneous Dirichlet conditions enforced by substituting zero for neighbors outside $\\Omega_L$ or on the outer boundary, which yields a symmetric negative semidefinite matrix operator $L\\in\\mathbb{R}^{n\\times n}$ with diagonal entries $-4/h^2$ and off-diagonal entries $1/h^2$ for each existing neighbor in the grid graph, where $n$ is the number of included nodes.\n\nAdvance the semi-discrete system in time using uniform time steps with backward Euler (also called implicit Euler). Let the time step be $\\Delta t=5\\times 10^{-4}$ and the number of time steps be $N_t=240$, so the final time is $T=N_t\\,\\Delta t=0.12$. Collect a sequence of state snapshots at every $s_{\\text{skip}}=6$ steps, producing $m=40$ snapshots that form the snapshot matrix $X\\in\\mathbb{R}^{n\\times m}$.\n\nFrom $X$, define the Proper Orthogonal Decomposition (POD) basis of rank $r$ as the first $r$ left singular vectors of $X$ under the standard Euclidean inner product on $\\mathbb{R}^n$ (which is equivalent to the discrete $L^2$ inner product up to the constant factor $h^2$ on this grid). Let $V_r\\in\\mathbb{R}^{n\\times r}$ denote the matrix of these orthonormal columns. Define the Reduced-Order Model (ROM) obtained by Galerkin projection of the semi-discrete operator onto the POD subspace, with reduced operator\n$$\nA_r = V_r^\\top L V_r\\in\\mathbb{R}^{r\\times r},\n$$\nand reduced state $a(t)\\in\\mathbb{R}^r$ evolving according to $a'(t)=A_r a(t)$ with initial condition $a(0)=V_r^\\top u_0$, advanced in time to $T$ by the same backward Euler scheme and time step used for the full model. Let $u(T)\\in\\mathbb{R}^n$ denote the fully discrete state at time $T$, and $u_r(T)=V_r a(T)$ the ROM reconstruction at time $T$.\n\nFor a given rank $r$, define:\n- The POD energy capture\n$$\nE_r=\\frac{\\sum_{i=1}^{r}\\sigma_i^2}{\\sum_{i=1}^{m}\\sigma_i^2},\n$$\nwhere $\\{\\sigma_i\\}$ are the singular values of $X$ in nonincreasing order.\n- The final-time relative state error\n$$\nR_r=\\frac{\\lVert u(T)-u_r(T)\\rVert_2}{\\lVert u(T)\\rVert_2}.\n$$\n- A corner concentration metric for the leading POD mode $v_1$ that quantifies energy near the re-entrant corner at $(0.5,0.5)$:\n$$\nC_r(\\rho)=\\frac{\\sum_{k: \\sqrt{(x_k-0.5)^2+(y_k-0.5)^2}\\le \\rho} \\left(v_1\\right)_k^2}{\\sum_{k=1}^{n} \\left(v_1\\right)_k^2},\n$$\nwhere $(x_k,y_k)$ are the physical coordinates of the grid node corresponding to the $k$-th degree of freedom. If $r=0$, define $C_0(\\rho)=0$ by convention. If $r$ exceeds the numerical rank of $X$, use all available modes.\n\nTest suite. Use the fixed discretization and time-integration parameters above, and evaluate the triple $(E_r,R_r,C_r(\\rho))$ for the following four cases:\n1. $r=0$, $\\rho=0.10$.\n2. $r=1$, $\\rho=0.08$.\n3. $r=5$, $\\rho=0.12$.\n4. $r=20$, $\\rho=0.15$.\n\nRequired final output format. Your program should produce a single line of output containing the $12$ floating-point results as a flat, comma-separated list enclosed in square brackets, ordered as\n$$\n[E_{r_1},R_{r_1},C_{r_1}(\\rho_1),E_{r_2},R_{r_2},C_{r_2}(\\rho_2),E_{r_3},R_{r_3},C_{r_3}(\\rho_3),E_{r_4},R_{r_4},C_{r_4}(\\rho_4)].\n$$\nEach floating-point value must be rounded to six decimal places. There are no physical units; all quantities are dimensionless. Angles are not used. Percentages must not be used; report $E_r$ and $R_r$ as decimals.", "solution": "The problem requires the construction and evaluation of a Reduced-Order Model (ROM) for the two-dimensional heat equation on a specific L-shaped domain. This will be accomplished through a series of well-defined steps: spatial and temporal discretization to create a Full-Order Model (FOM), simulation of the FOM to generate state data, application of Proper Orthogonal Decomposition (POD) to extract a low-dimensional basis, and finally, Galerkin projection to construct and solve the ROM. The accuracy and properties of the ROM will be quantified using a set of prescribed metrics.\n\nFirst, we address the Full-Order Model (FOM). The governing partial differential equation is the heat equation, $\\frac{\\partial u}{\\partial t} = \\kappa \\Delta u$, on the domain $\\Omega_L = (0,1)\\times(0,1)\\setminus([0.5,1]\\times[0.5,1])$ with diffusivity $\\kappa=1$ and homogeneous Dirichlet boundary conditions. The domain is discretized using a uniform Cartesian grid with $N=41$ points in each direction, resulting in a grid spacing of $h = 1/(N-1) = 1/40$. The degrees of freedom for our model are the values of the temperature $u$ at the interior grid nodes. The L-shape of the domain is realized by excluding all interior nodes $(x_i, y_j)$ for which both $x_i \\geq 0.5$ and $y_j \\geq 0.5$. This results in a total of $n=1121$ interior nodes. We establish a mapping from the two-dimensional grid indices $(i,j)$ of these $n$ nodes to a single one-dimensional index $k \\in \\{0, 1, \\dots, n-1\\}$, which allows us to represent the state of the system as a vector $\\mathbf{u}(t) \\in \\mathbb{R}^n$.\n\nThe spatial operator, the Laplacian $\\Delta$, is discretized using a standard five-point finite difference stencil. This results in a linear system of ordinary differential equations (ODEs), a semi-discretization known as the method of lines: $\\frac{d\\mathbf{u}}{dt} = L\\mathbf{u}(t)$. Here, $L \\in \\mathbb{R}^{n \\times n}$ is the matrix representation of the discrete Laplacian operator. For each node $k$, the corresponding diagonal entry is $L_{kk} = -4/h^2$. For each neighboring node $k'$ that is also within the computational domain, the off-diagonal entry is $L_{k'k} = L_{kk'} = 1/h^2$. Due to the homogeneous Dirichlet boundary conditions, neighbors on the boundary or outside the domain contribute nothing to the equations. The resulting matrix $L$ is symmetric and negative semidefinite, correctly reflecting the properties of the continuous operator.\n\nFor time integration, the backward Euler method is employed. Given a state $\\mathbf{u}_k$ at time $t_k$, the state $\\mathbf{u}_{k+1}$ at time $t_{k+1}=t_k+\\Delta t$ is found by solving the linear system $(\\mathbf{u}_{k+1} - \\mathbf{u}_k)/\\Delta t = L\\mathbf{u}_{k+1}$. Rearranging gives $(I - \\Delta t L)\\mathbf{u}_{k+1} = \\mathbf{u}_k$. The matrix $A_{BE} = I - \\Delta t L$ is sparse, symmetric, and positive-definite, and it remains constant throughout the simulation. We can pre-factorize it (e.g., using an LU or Cholesky decomposition) to efficiently solve for $\\mathbf{u}_{k+1}$ at each time step. The FOM is simulated from $t=0$ to the final time $T=0.12$ using the specified time step $\\Delta t = 5 \\times 10^{-4}$. The initial condition is a Gaussian pulse, $\\mathbf{u}(0) = \\mathbf{u}_0$, evaluated at the grid nodes. During the simulation, we collect snapshots of the state vector every $s_{\\text{skip}}=6$ steps, forming a snapshot matrix $X = [\\mathbf{u}^{(1)}, \\mathbf{u}^{(2)}, \\dots, \\mathbf{u}^{(m)}] \\in \\mathbb{R}^{n \\times m}$, where $m=40$.\n\nNext, we construct the ROM. The foundation of the ROM is the POD basis, which provides an optimal low-rank approximation for the snapshot data. This basis is obtained by computing the Singular Value Decomposition (SVD) of the snapshot matrix, $X = U \\Sigma W^\\top$. The columns of the matrix $U \\in \\mathbb{R}^{n \\times m}$ are the left singular vectors, also known as the POD modes. These modes are orthonormal and ordered by the amount of energy they capture from the snapshots, which is quantified by the corresponding singular values $\\sigma_i$ on the diagonal of $\\Sigma$. The POD basis of rank $r$, denoted $V_r \\in \\mathbb{R}^{n \\times r}$, is formed by taking the first $r$ columns of $U$.\n\nThe ROM is derived using Galerkin projection. We seek an approximate solution of the form $\\mathbf{u}(t) \\approx V_r \\mathbf{a}(t)$, where $\\mathbf{a}(t) \\in \\mathbb{R}^r$ is the vector of reduced coordinates. Substituting this ansatz into the semi-discrete FOM equation gives $V_r \\frac{d\\mathbf{a}}{dt} \\approx L V_r \\mathbf{a}(t)$. To solve for $\\mathbf{a}(t)$, we project this equation onto the subspace spanned by the basis vectors. Since the basis is orthonormal ($V_r^\\top V_r = I_r$), this yields the reduced system of ODEs: $\\frac{d\\mathbf{a}}{dt} = (V_r^\\top L V_r) \\mathbf{a}(t) = A_r \\mathbf{a}(t)$. The reduced operator $A_r \\in \\mathbb{R}^{r \\times r}$ is much smaller than $L$. The initial condition for the ROM is the projection of the full initial condition: $\\mathbf{a}(0) = V_r^\\top \\mathbf{u}_0$. This small $r \\times r$ system is then integrated in time using the same backward Euler scheme to find the reduced state $\\mathbf{a}(T)$ at the final time. The approximate full-state solution is then reconstructed as $\\mathbf{u}_r(T) = V_r \\mathbf{a}(T)$.\n\nFinally, we evaluate the specified metrics for each test case $(r, \\rho)$.\nThe POD energy capture, $E_r = (\\sum_{i=1}^{r} \\sigma_i^2) / (\\sum_{i=1}^{m} \\sigma_i^2)$, measures the fraction of the total variance in the snapshot data captured by the first $r$ modes. For $r=0$, $E_0=0$.\nThe final-time relative state error, $R_r = \\lVert \\mathbf{u}(T) - \\mathbf{u}_r(T) \\rVert_2 / \\lVert \\mathbf{u}(T) \\rVert_2$, quantifies the accuracy of the ROM solution. For $r=0$, the ROM basis is empty, so $\\mathbf{u}_0(T)=\\mathbf{0}$, leading to $R_0 = 1$.\nThe corner concentration metric, $C_r(\\rho) = (\\sum_{k: d_k \\le \\rho} (v_1)_k^2) / (\\sum_{k=1}^{n} (v_1)_k^2)$, where $d_k$ is the distance of node $k$ from the re-entrant corner $(0.5, 0.5)$ and $v_1$ is the leading POD mode. Since $v_1$ is a unit vector, the denominator is unity. By convention, $C_0(\\rho)=0$. For $r>0$, this metric quantifies how much of the \"energy\" of the most dominant dynamic mode is concentrated within a radius $\\rho$ of the domain's corner singularity.\n\nThe implementation will proceed by first setting up the grid and FOM operator $L$. Then, the FOM will be simulated to generate snapshots and the final state $\\mathbf{u}(T)$. SVD of the snapshot matrix will yield the POD modes $U$ and singular values $\\sigma$. For each test case, the corresponding metrics will be computed using these pre-computed quantities and, where necessary, by simulating the appropriate ROM.", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import splu\nfrom scipy.linalg import lu_factor, lu_solve\n\ndef solve():\n    \"\"\"\n    Solves the problem of reduced-order modeling for the 2D heat equation\n    on an L-shaped domain.\n    \"\"\"\n    #\n    # === 1. Problem Parameters and Grid Setup ===\n    #\n    N = 41\n    h = 1.0 / (N - 1)\n    kappa = 1.0\n    sigma_ic = 0.12\n    dt = 5.0e-4\n    Nt = 240\n    T_final = Nt * dt\n    s_skip = 6\n    m = Nt // s_skip\n\n    # Define test cases\n    test_cases = [\n        {'r': 0, 'rho': 0.10},\n        {'r': 1, 'rho': 0.08},\n        {'r': 5, 'rho': 0.12},\n        {'r': 20, 'rho': 0.15},\n    ]\n\n    # Generate grid and identify interior nodes for the L-shaped domain\n    interior_nodes = []\n    node_map = {}\n    \n    # Grid coordinates including boundaries\n    x_coords = np.linspace(0, 1, N)\n    y_coords = np.linspace(0, 1, N)\n\n    # Interior indices are from 1 to N-2\n    for j in range(1, N - 1):\n        for i in range(1, N - 1):\n            x, y = i * h, j * h\n            if not (x >= 0.5 and y >= 0.5):\n                node_idx = len(interior_nodes)\n                interior_nodes.append({'glob_idx': (i, j), 'coords': (x, y)})\n                node_map[(i, j)] = node_idx\n    \n    n = len(interior_nodes) # Number of degrees of freedom\n\n    #\n    # === 2. Full-Order Model (FOM) Assembly ===\n    #\n    L = sparse.lil_matrix((n, n), dtype=np.float64)\n    h2_inv = 1.0 / (h * h)\n    \n    for k, node_info in enumerate(interior_nodes):\n        i, j = node_info['glob_idx']\n        L[k, k] = -4.0 * h2_inv\n        \n        neighbors = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]\n        for neighbor_glob_idx in neighbors:\n            if neighbor_glob_idx in node_map:\n                neighbor_k = node_map[neighbor_glob_idx]\n                L[k, neighbor_k] = 1.0 * h2_inv\n\n    # Convert to CSC format for efficient computations\n    L_csc = L.tocsc()\n\n    #\n    # === 3. FOM Time Integration and Snapshot Collection ===\n    #\n    u0 = np.zeros(n, dtype=np.float64)\n    for k, node_info in enumerate(interior_nodes):\n        x, y = node_info['coords']\n        u0[k] = np.exp(-((x - 0.5)**2 + (y - 0.5)**2) / sigma_ic**2)\n\n    A_BE = sparse.identity(n, format='csc') - dt * kappa * L_csc\n    solver = splu(A_BE)\n\n    snapshots = []\n    u_current = u0.copy()\n    \n    # Store initial state if t=0 snapshots are included (not the case here)\n    # The first snapshot is at t=dt*s_skip\n    \n    for step in range(1, Nt + 1):\n        u_current = solver.solve(u_current)\n        if step % s_skip == 0:\n            snapshots.append(u_current)\n\n    uT_fom = u_current\n    X = np.array(snapshots).T # Shape (n, m)\n\n    #\n    # === 4. POD Basis Computation ===\n    #\n    # full_matrices=False is important for efficiency\n    U, s, _ = np.linalg.svd(X, full_matrices=False)\n    \n    s_sq = s**2\n    total_energy = np.sum(s_sq)\n    \n    #\n    # === 5. ROM Simulation and Metrics Calculation ===\n    #\n    results = []\n\n    # Get coordinate array for C_r calculation\n    node_coordinates = np.array([node['coords'] for node in interior_nodes])\n    distances_from_corner = np.linalg.norm(node_coordinates - np.array([0.5, 0.5]), axis=1)\n    \n    # The leading POD mode v1 is the first column of U\n    v1 = U[:, 0]\n    # Denominator for C_r is norm(v1)^2 which is 1\n    v1_sq = v1**2\n\n    uT_fom_norm = np.linalg.norm(uT_fom)\n\n    for case in test_cases:\n        r, rho = case['r'], case['rho']\n\n        # --- Handle r=0 case ---\n        if r == 0:\n            E_r = 0.0\n            # For r=0, ROM solution u_r(T) is the zero vector.\n            # R_r = ||u(T) - 0|| / ||u(T)|| = 1\n            R_r = 1.0\n            # C_r is defined as 0 for r=0\n            C_r = 0.0\n            results.extend([E_r, R_r, C_r])\n            continue\n            \n        # --- Handle r > 0 cases ---\n        \n        # Metric E_r\n        E_r = np.sum(s_sq[:r]) / total_energy\n        \n        # Metric R_r: Needs ROM simulation\n        Vr = U[:, :r]\n        a0_rom = Vr.T @ u0\n        \n        # Build and simulate ROM\n        # Note: L @ Vr is a dense matrix multiplication\n        Ar = Vr.T @ (L_csc @ Vr)\n        Ar_BE = np.identity(r) - dt * kappa * Ar\n        \n        # Dense LU factorization for the small ROM system\n        lu_r, piv_r = lu_factor(Ar_BE)\n        \n        a_current_rom = a0_rom.copy()\n        for _ in range(Nt):\n            a_current_rom = lu_solve((lu_r, piv_r), a_current_rom)\n        \n        aT_rom = a_current_rom\n        uT_rom = Vr @ aT_rom\n        \n        R_r = np.linalg.norm(uT_fom - uT_rom) / uT_fom_norm\n\n        # Metric C_r\n        # This metric always uses the leading mode v1, irrespective of r > 0\n        indices_in_radius = np.where(distances_from_corner <= rho)[0]\n        C_r = np.sum(v1_sq[indices_in_radius])\n        \n        results.extend([E_r, R_r, C_r])\n\n    #\n    # === 6. Final Output ===\n    #\n    formatted_results = [f\"{x:.6f}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2432054"}, {"introduction": "Reduced-order models are powerful but not infallible, and understanding their limitations is as important as knowing how to build them. This final practice demonstrates a famous and subtle pitfall: a stable full-order system can, under projection, yield an unstable reduced-order model that produces unphysical, diverging solutions. By numerically constructing such a case [@problem_id:2432128], we will investigate the role of operator non-normality and transient growth in this paradoxical behavior, reinforcing the critical need for careful ROM validation.", "problem": "You are asked to implement a complete numerical experiment in reduced-order modeling that demonstrates the following phenomenon: a Proper Orthogonal Decomposition (POD) basis can be excellent for reconstructing training snapshots of a stable full-order linear time-invariant system, yet the Galerkin-projected reduced-order model (ROM) can produce unstable dynamics that blow up when integrated in time.\n\nYour implementation must start from the full-order ordinary differential equation\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b},\n$$\nwhere $\\mathbf{A}\\in\\mathbb{R}^{n\\times n}$ and $\\mathbf{b}\\in\\mathbb{R}^{n}$ are constant, and $\\mathbf{x}(t)\\in\\mathbb{R}^{n}$ is the state. All computations are over the real numbers with the standard Euclidean inner product. You will use $n=2$ throughout.\n\nFundamental definitions and requirements:\n- Proper Orthogonal Decomposition (POD) basis: Given a snapshot matrix\n$$\n\\mathbf{X} = \\begin{bmatrix}\\mathbf{x}(t_1) & \\mathbf{x}(t_2) & \\cdots & \\mathbf{x}(t_m)\\end{bmatrix}\\in\\mathbb{R}^{n\\times m},\n$$\ncompute its singular value decomposition (SVD) $\\mathbf{X}=\\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$. The rank-$r$ POD basis $\\mathbf{Q}\\in\\mathbb{R}^{n\\times r}$ is taken as the first $r$ columns of $\\mathbf{U}$.\n- Galerkin projection: The reduced operator and reduced forcing are\n$$\n\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}\\in\\mathbb{R}^{r\\times r},\\qquad \\mathbf{b}_r=\\mathbf{Q}^\\top\\mathbf{b}\\in\\mathbb{R}^{r}.\n$$\nThe reduced state $\\mathbf{z}(t)\\in\\mathbb{R}^{r}$ evolves as\n$$\n\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r \\mathbf{z} + \\mathbf{b}_r,\\qquad \\mathbf{x}_r(t)=\\mathbf{Q}\\mathbf{z}(t).\n$$\n- Time integration: Use the classical fourth-order Runge–Kutta method with a fixed time step $h>0$ for both the full-order model and the ROM. Set the initial condition to $\\mathbf{x}(0)=\\mathbf{0}$ and $\\mathbf{z}(0)=\\mathbf{Q}^\\top\\mathbf{x}(0)=\\mathbf{0}$.\n- Snapshot collection: Integrate the full-order model over a training horizon $[0,T_{\\text{train}}]$ with a constant time step $h$, sampling the state at every step to form $\\mathbf{X}$.\n- Reconstruction error: Measure the relative POD reconstruction error of the training snapshots as\n$$\n\\varepsilon_{\\text{rec}} = \\frac{\\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F}{\\lVert \\mathbf{X}\\rVert_F},\n$$\nwhere $\\lVert\\cdot\\rVert_F$ denotes the Frobenius norm.\n- Blow-up detection: Evolve both the full-order model and the ROM over a test horizon $[0,T_{\\text{test}}]$ with the same $h$. Declare a solution “blown up” if at any time step the Euclidean norm of the current state exceeds a threshold $M$, or if any component becomes not-a-number or infinite. Use the threshold $M=10^6$.\n\nConstructed forcing to target instability under ROM:\n- For each test, you must construct the constant forcing $\\mathbf{b}$ as follows. Compute the symmetric part $\\mathbf{S}=\\frac{1}{2}(\\mathbf{A}+\\mathbf{A}^\\top)$ and its dominant unit eigenvector $\\mathbf{q}\\in\\mathbb{R}^{n}$ associated with the largest eigenvalue of $\\mathbf{S}$ (break ties arbitrarily but deterministically). Set\n$$\n\\mathbf{b}=-\\mathbf{A}\\mathbf{q}.\n$$\nThis construction ensures that the full-order steady state is $\\mathbf{x}_\\infty = -\\mathbf{A}^{-1}\\mathbf{b}=\\mathbf{q}$. When $\\mathbf{A}$ is highly non-normal and the largest eigenvalue of $\\mathbf{S}$ is positive, the scalar ROM obtained with $r=1$ and $\\mathbf{Q}=\\mathbf{q}$ has reduced dynamics $\\frac{dz}{dt} = a_r z + b_r$ with $a_r=\\mathbf{q}^\\top\\mathbf{A}\\mathbf{q}>0$ and $b_r=-a_r$, which is unstable and diverges from $z(0)=0$.\n\nNumerical specification common to all tests:\n- Use $n=2$.\n- Use $h=10^{-3}$.\n- Use classical fourth-order Runge–Kutta.\n- Use the Euclidean norm for all vector norms.\n- Use $\\mathbf{x}(0)=\\mathbf{0}$.\n\nTest suite:\nImplement the above for the following parameter sets. In each case, define $\\mathbf{A}$, compute $\\mathbf{q}$ and $\\mathbf{b}$ as specified, collect snapshots over $[0,T_{\\text{train}}]$ to form $\\mathbf{Q}$, then form the ROM and run both models over $[0,T_{\\text{test}}]$.\n\n- Test $1$ (highly non-normal, rank-$1$ POD):\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1 & \\alpha \\\\ 0 & -1.0\\end{bmatrix}$ with $\\alpha=50.0$,\n  - $r=1$,\n  - $T_{\\text{train}}=4.0$,\n  - $T_{\\text{test}}=1.0$.\n- Test $2$ (highly non-normal, rank-$2$ POD):\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1 & \\alpha \\\\ 0 & -1.0\\end{bmatrix}$ with $\\alpha=50.0$,\n  - $r=2$,\n  - $T_{\\text{train}}=4.0$,\n  - $T_{\\text{test}}=1.0$.\n- Test $3$ (symmetric negative definite, rank-$1$ POD):\n  - $\\mathbf{A}=\\begin{bmatrix}-1.0 & 0.0 \\\\ 0.0 & -2.0\\end{bmatrix}$,\n  - $r=1$,\n  - $T_{\\text{train}}=4.0$,\n  - $T_{\\text{test}}=1.0$.\n- Test $4$ (more highly non-normal, rank-$1$ POD):\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1 & \\alpha \\\\ 0 & -1.0\\end{bmatrix}$ with $\\alpha=120.0$,\n  - $r=1$,\n  - $T_{\\text{train}}=4.0$,\n  - $T_{\\text{test}}=1.0$.\n\nRequired outputs:\n- For each test, output a list of three entries:\n  - the scalar $\\varepsilon_{\\text{rec}}$ rounded to six decimal places,\n  - a boolean indicating whether the ROM blew up on $[0,T_{\\text{test}}]$,\n  - a boolean indicating whether the full-order model blew up on $[0,T_{\\text{test}}]$.\n- Aggregate the results from all tests into a single line as a comma-separated list enclosed in square brackets, in the same order as the tests. Example format:\n$[\\,[\\varepsilon_{\\text{rec}}^{(1)},\\,\\text{ROM}^{(1)}\\_\\text{blowup},\\,\\text{FOM}^{(1)}\\_\\text{blowup}],\\,[\\varepsilon_{\\text{rec}}^{(2)},\\,\\text{ROM}^{(2)}\\_\\text{blowup},\\,\\text{FOM}^{(2)}\\_\\text{blowup}],\\,\\ldots\\,]$.", "solution": "The user has presented a problem in computational engineering, specifically concerning the stability of reduced-order models (ROMs) derived from Proper Orthogonal Decomposition (POD) and Galerkin projection. The task is to demonstrate via numerical experiment a known failure mode where a ROM can be unstable despite the full-order model (FOM) being stable. This phenomenon is characteristic of systems governed by highly non-normal operators.\n\nThe problem statement has been validated and found to be scientifically sound, well-posed, and complete. All definitions, parameters, and procedures are specified with sufficient clarity to permit a unique and verifiable solution. We will proceed with the analysis and implementation.\n\nThe core of the problem lies in the distinction between the spectrum of a matrix $\\mathbf{A}$ and its numerical range (or field of values), defined as $W(\\mathbf{A}) = \\{\\mathbf{v}^T\\mathbf{A}\\mathbf{v} : \\mathbf{v} \\in \\mathbb{R}^n, \\lVert\\mathbf{v}\\rVert_2 = 1\\}$. For a linear time-invariant system $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x}$, stability is determined by the eigenvalues of $\\mathbf{A}$ (the spectrum, $\\sigma(\\mathbf{A})$). If all eigenvalues have negative real parts, the system is stable, and $\\lVert\\mathbf{x}(t)\\rVert \\to 0$ as $t\\to\\infty$. However, transient growth is possible if $\\mathbf{A}$ is non-normal (i.e., $\\mathbf{A}\\mathbf{A}^\\top \\neq \\mathbf{A}^\\top\\mathbf{A}$). The numerical range provides insight into this transient behavior. The real part of the numerical range is governed by the symmetric part of the matrix, $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$, since $\\text{Re}(\\mathbf{v}^T\\mathbf{A}\\mathbf{v}) = \\mathbf{v}^T\\mathbf{S}\\mathbf{v}$. A positive eigenvalue of $\\mathbf{S}$ implies that the numerical range of $\\mathbf{A}$ extends into the right half-plane, indicating potential for transient energy growth.\n\nA Galerkin projection with a rank-$r$ POD basis $\\mathbf{Q}$ transforms the FOM $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ into the ROM $\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r\\mathbf{z} + \\mathbf{b}_r$, where $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$. The stability of the ROM is determined by the eigenvalues of the reduced matrix $\\mathbf{A}_r$. Crucially, the eigenvalues of $\\mathbf{A}_r$ are contained within the numerical range of $\\mathbf{A}$, but not necessarily within the convex hull of its spectrum. If the numerical range $W(\\mathbf{A})$ crosses into the right half-plane, it is possible to find a projection subspace (basis $\\mathbf{Q}$) such that $\\mathbf{A}_r$ has eigenvalues with positive real parts, rendering the ROM unstable.\n\nThe problem's construction is designed to expose this pathology. The FOM is stable (eigenvalues of $\\mathbf{A}$ are $\\{-0.1, -1.0\\}$). The forcing term $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$ is chosen such that the FOM steady state is $\\mathbf{x}_{\\infty} = \\mathbf{q}$, where $\\mathbf{q}$ is the eigenvector corresponding to the largest eigenvalue of $\\mathbf{S}$. This drives the system dynamics towards the direction of maximum transient growth. The resulting snapshots will be dominated by this direction, causing the primary POD mode (the first column of $\\mathbf{Q}$) to align with $\\mathbf{q}$. For a rank-$1$ ROM ($r=1$), the reduced matrix $\\mathbf{A}_r$ becomes a scalar $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$. If $\\mathbf{Q} \\approx \\mathbf{q}$, then $a_r \\approx \\mathbf{q}^\\top\\mathbf{A}\\mathbf{q} = \\mathbf{q}^\\top\\mathbf{S}\\mathbf{q} = \\lambda_{\\max}(\\mathbf{S})$. For the non-normal matrices in Tests $1$ and $4$, $\\lambda_{\\max}(\\mathbf{S}) > 0$, leading to an unstable ROM.\n\nThe computational procedure for each test case is as follows:\n$1$. Define system parameters: matrix $\\mathbf{A}$, ROM rank $r$, and time horizons $T_{\\text{train}}$ and $T_{\\text{test}}$. The dimension is $n=2$ and the time step is $h=10^{-3}$.\n$2$. Construct the forcing term: Compute the symmetric part $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$. Find its eigenvalues and eigenvectors. Let $\\mathbf{q}$ be the normalized eigenvector corresponding to the largest eigenvalue. Set $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$.\n$3$. Generate training data: Integrate the FOM, $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$, from $\\mathbf{x}(0)=\\mathbf{0}$ over the time interval $[0, T_{\\text{train}}]$ using the classical fourth-order Runge-Kutta method. The states at each time step are collected into the snapshot matrix $\\mathbf{X}$.\n$4$. Compute the POD basis: Perform a singular value decomposition (SVD) on the snapshot matrix, $\\mathbf{X} = \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$. The POD basis $\\mathbf{Q}$ of rank $r$ is formed by the first $r$ columns of $\\mathbf{U}$.\n$5$. Calculate reconstruction error: The relative Frobenius norm error is computed as $\\varepsilon_{\\text{rec}} = \\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F / \\lVert \\mathbf{X}\\rVert_F$.\n$6$. Construct the ROM: The reduced system matrices are $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ and $\\mathbf{b}_r = \\mathbf{Q}^\\top\\mathbf{b}$.\n$7$. Perform time integration for testing: Both the FOM and the ROM are integrated from zero initial conditions ($\\mathbf{x}(0)=\\mathbf{0}$, $\\mathbf{z}(0)=\\mathbf{0}$) over the interval $[0, T_{\\text{test}}]$. During integration, at each step, the Euclidean norm of the state vector is checked against the blow-up threshold $M=10^6$.\n$8$. Record results: The final outputs for the test are the computed $\\varepsilon_{\\text{rec}}$, a boolean indicating if the ROM blew up, and a boolean indicating if the FOM blew up.\n\nExpected outcomes for the tests:\n- **Test 1**: ($\\mathbf{A}$ non-normal, $r=1$): $\\mathbf{A}$ is stable. The construction of $\\mathbf{b}$ and the choice of $r=1$ are designed to produce an unstable ROM. We expect a small $\\varepsilon_{\\text{rec}}$, ROM blow-up, and no FOM blow-up.\n- **Test 2**: ($\\mathbf{A}$ non-normal, $r=2$): Here, $r=n=2$. The POD basis $\\mathbf{Q}$ will be a complete orthonormal basis for $\\mathbb{R}^2$. Thus, $\\mathbf{Q}\\mathbf{Q}^\\top = \\mathbf{I}$, meaning the reconstruction error $\\varepsilon_{\\text{rec}}$ will be zero (or of the order of machine precision). The ROM is dynamically equivalent to the FOM, simply expressed in a different basis. Since the FOM is stable, the ROM will also be stable. We expect $\\varepsilon_{\\text{rec}} \\approx 0$, no ROM blow-up, and no FOM blow-up.\n- **Test 3**: ($\\mathbf{A}$ symmetric, $r=1$): $\\mathbf{A}$ is a normal matrix. Its numerical range is the convex hull of its eigenvalues, which are $\\{-1.0, -2.0\\}$. Thus, the numerical range is the interval $[-2.0, -1.0]$ on the real axis. The reduced operator $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ must be negative. The ROM will be stable. We expect no blow-up for either model.\n- **Test 4**: ($\\mathbf{A}$ more non-normal, $r=1$): Similar to Test $1$, but with a larger off-diagonal term $\\alpha=120.0$. This increases the non-normality, leading to a larger positive eigenvalue for $\\mathbf{S}$. The ROM instability should be even more pronounced. We expect a small $\\varepsilon_{\\text{rec}}$, ROM blow-up, and no FOM blow-up.\n\nThe aforementioned logic will now be implemented.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Implements the full numerical experiment to demonstrate ROM instability\n    for a stable FOM.\n    \"\"\"\n\n    def rk4_step(f, y, h, A, b):\n        \"\"\"A single step of the classical fourth-order Runge-Kutta method.\"\"\"\n        k1 = f(y, A, b)\n        k2 = f(y + h / 2 * k1, A, b)\n        k3 = f(y + h / 2 * k2, A, b)\n        k4 = f(y + h * k3, A, b)\n        return y + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def lti_rhs(y, A, b):\n        \"\"\"RHS of the LTI system dy/dt = Ay + b.\"\"\"\n        return A @ y + b\n\n    def simulate(A, b, y0, T, h, M):\n        \"\"\"\n        Simulates an LTI system and returns snapshots and blow-up status.\n        \"\"\"\n        num_steps = int(T / h)\n        y = y0.copy()\n        snapshots = [y0.copy()]\n        blew_up = False\n        \n        for _ in range(num_steps):\n            y = rk4_step(lti_rhs, y, h, A, b)\n            if np.linalg.norm(y) > M or not np.all(np.isfinite(y)):\n                blew_up = True\n                # Continue collecting snapshots to see the blow-up, if needed for X\n                # But stop checking once blown up.\n                while len(snapshots) < num_steps + 1:\n                    snapshots.append(y.copy()) # Append the diverging state\n                    y = rk4_step(lti_rhs, y, h, A, b) # Could become inf/nan\n                return np.array(snapshots).T, True\n\n            snapshots.append(y.copy())\n            \n        return np.array(snapshots).T, blew_up\n\n    # General parameters\n    n = 2\n    h = 1e-3\n    M = 1e6\n    x0 = np.zeros(n)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        # (A_params, r, T_train, T_test)\n        ({\"alpha\": 50.0}, 1, 4.0, 1.0),\n        ({\"alpha\": 50.0}, 2, 4.0, 1.0),\n        ({\"alpha\": None}, 1, 4.0, 1.0), # Symmetric case\n        ({\"alpha\": 120.0}, 1, 4.0, 1.0),\n    ]\n\n    results = []\n    \n    for i, (params, r, T_train, T_test) in enumerate(test_cases):\n        # 1. Define A\n        if i == 2: # Test 3: Symmetric case\n            A = np.array([[-1.0, 0.0], [0.0, -2.0]])\n        else: # Tests 1, 2, 4: Non-normal case\n            alpha = params[\"alpha\"]\n            A = np.array([[-0.1, alpha], [0.0, -1.0]])\n\n        # 2. Construct b\n        S = 0.5 * (A + A.T)\n        eigvals, eigvecs = eigh(S)\n        q = eigvecs[:, -1] # Dominant eigenvector (eigh sorts eigenvalues)\n        b = -A @ q\n\n        # 3. Generate FOM snapshots for training\n        X, _ = simulate(A, b, x0, T_train, h, M)\n\n        # 4. Compute POD basis Q\n        U, s, _ = np.linalg.svd(X, full_matrices=False)\n        Q = U[:, :r]\n\n        # 5. Calculate reconstruction error\n        # eps_rec = norm(X - Q @ Q.T @ X) / norm(X)\n        # Using singular values is more direct: sqrt(sum(s_i^2 for i>r)) / sqrt(sum(s_i^2))\n        if X.shape[1]>1:\n         norm_X_sq = np.sum(s**2)\n         if norm_X_sq > 0:\n            norm_err_sq = np.sum(s[r:]**2)\n            eps_rec = np.sqrt(norm_err_sq / norm_X_sq)\n         else:\n            eps_rec = 0.0\n        else:\n            eps_rec = 0.0\n\n\n        # 6. Form the ROM\n        Ar = Q.T @ A @ Q\n        br = Q.T @ b\n        z0 = np.zeros(r)\n\n        # 7. Simulate FOM and ROM for testing, check blow-up\n        _, fom_blew_up = simulate(A, b, x0, T_test, h, M)\n        _, rom_blew_up = simulate(Ar, br, z0, T_test, h, M)\n\n        # 8. Record results\n        results.append([round(eps_rec, 6), rom_blew_up, fom_blew_up])\n\n    # Final print statement in the exact required format.\n    # Convert bools to lowercase 'true'/'false' for JS-like format\n    formatted_results = []\n    for res in results:\n        eps_str = f\"{res[0]:.6f}\"\n        rom_bool_str = str(res[1]).lower()\n        fom_bool_str = str(res[2]).lower()\n        formatted_results.append(f\"[{eps_str},{rom_bool_str},{fom_bool_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2432128"}]}