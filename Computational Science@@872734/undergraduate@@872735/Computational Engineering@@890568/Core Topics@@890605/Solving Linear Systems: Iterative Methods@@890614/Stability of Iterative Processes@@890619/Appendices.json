{"hands_on_practices": [{"introduction": "Many complex systems in science and engineering are modeled by ordinary differential equations, which we often solve on a computer using iterative numerical methods. This practice demonstrates a crucial pitfall of a simple method, the Forward Euler scheme: conditional stability, where the choice of the iteration step size, $h$, is paramount for obtaining a physically meaningful result. By simulating a classic predator-prey model, you will see firsthand how an overly large $h$ can cause the process to become unstable, leading to the nonsensical outcome of negative populations [@problem_id:2437681].", "problem": "Consider the classical predator-prey dynamics modeled by the Lotkaâ€“Volterra ordinary differential equations (ODE): \n$$\n\\begin{aligned}\n\\frac{dx}{dt} &= a\\,x - b\\,x\\,y,\\\\\n\\frac{dy}{dt} &= -c\\,y + d\\,x\\,y,\n\\end{aligned}\n$$\nwhere $x$ denotes the prey population, $y$ denotes the predator population, and $a,b,c,d$ are strictly positive real parameters. Define the Forward Euler iterative process with time step $h>0$ over a time horizon $T>0$ by the recurrence\n$$\n\\begin{aligned}\nx_{n+1} &= x_n + h\\left(a\\,x_n - b\\,x_n\\,y_n\\right) = x_n\\left(1 + h(a - b\\,y_n)\\right),\\\\\ny_{n+1} &= y_n + h\\left(-c\\,y_n + d\\,x_n\\,y_n\\right) = y_n\\left(1 + h(-c + d\\,x_n)\\right),\n\\end{aligned}\n$$\nfor integer indices $n=0,1,\\dots,N-1$ with $N=T/h$ assumed to be an integer, and initial conditions $x_0>0$, $y_0>0$. In this discrete-time setting, negative values for $x_n$ or $y_n$ represent physically impossible negative populations and are interpreted as numerical instability caused by an excessively large time step $h$.\n\nFor each test case below, simulate the Forward Euler recurrence from $n=0$ to $n=N$, inclusive of both endpoints, using the specified parameters and initial conditions. For each simulation, determine:\n- a boolean flag indicating whether any strictly negative population was encountered at any iterate (i.e., whether there exists an index $n$ such that $x_n<0$ or $y_n<0$),\n- the minimum value of $\\{x_n\\}_{n=0}^N$,\n- the minimum value of $\\{y_n\\}_{n=0}^N$.\n\nReport the minimum values rounded to six decimal places using standard rounding rules. No physical units are involved in this task. Angles are not involved. All outputs are unitless real numbers.\n\nUse the same parameter values $a=1$, $b=0.5$, $c=1$, $d=0.5$ for all cases. The test suite consists of four cases designed to probe a typical well-resolved scenario, a boundary condition, and unstable regimes:\n\n- Case $1$ (small step, well-resolved): $x_0=10$, $y_0=5$, $h=0.01$, $T=0.01$.\n- Case $2$ (boundary for prey update factor, first step to zero): $x_0=8$, $y_0=12$, $h=0.2$, $T=0.2$.\n- Case $3$ (large step yielding negative prey immediately): $x_0=8$, $y_0=30$, $h=0.2$, $T=0.2$.\n- Case $4$ (very large step yielding negative predator, and also negative prey): $x_0=0.5$, $y_0=10$, $h=2.0$, $T=2.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result is a list with three entries in the order [negativity_flag, min_x, min_y]. For example, a valid output format with four cases is \n$$\n[\\,[\\text{True},-1.234000,0.500000],[\\text{False},0.000000,2.000000],[\\text{False},1.000000,1.000000],[\\text{True},-0.100000,-0.200000]\\,].\n$$", "solution": "The problem statement has been subjected to rigorous validation and is found to be valid. It is a well-posed problem in computational mathematics, specifically the application of a numerical method to a system of ordinary differential equations. All parameters, initial conditions, and procedural steps are defined unambiguously. The problem is scientifically grounded, objective, and self-contained.\n\nThe task is to simulate the Lotka-Volterra predator-prey model using the Forward Euler method. The continuous model is given by the system of ordinary differential equations:\n$$\n\\begin{aligned}\n\\frac{dx}{dt} &= a\\,x - b\\,x\\,y \\\\\n\\frac{dy}{dt} &= -c\\,y + d\\,x\\,y\n\\end{aligned}\n$$\nwhere $x(t)$ is the prey population, $y(t)$ is the predator population, and $a, b, c, d$ are positive real parameters.\n\nThe Forward Euler method discretizes this system with a time step $h > 0$. The populations at time step $n+1$ are computed from the populations at time step $n$ using the following recurrence relations:\n$$\n\\begin{aligned}\nx_{n+1} &= x_n + h(a\\,x_n - b\\,x_n\\,y_n) = x_n\\left(1 + h(a - b\\,y_n)\\right) \\\\\ny_{n+1} &= y_n + h(-c\\,y_n + d\\,x_n\\,y_n) = y_n\\left(1 + h(-c + d\\,x_n)\\right)\n\\end{aligned}\n$$\nThe simulation runs from an initial state $(x_0, y_0)$ for $n=0, 1, \\dots, N-1$, where $N=T/h$ is the total number of steps to reach the time horizon $T$. The populations must remain non-negative, $x_n \\ge 0$ and $y_n \\ge 0$, for all $n$, to be physically meaningful.\n\nNumerical instability, manifesting as negative populations, occurs if the time step $h$ is too large. Given $x_n > 0$ and $y_n > 0$, the conditions to ensure $x_{n+1} \\ge 0$ and $y_{n+1} \\ge 0$ are:\n$$\n\\begin{aligned}\n1 + h(a - b\\,y_n) \\ge 0 \\\\\n1 + h(-c + d\\,x_n) \\ge 0\n\\end{aligned}\n$$\nIf $a - b\\,y_n < 0$, the first condition imposes a stability constraint on the time step: $h \\le \\frac{1}{b\\,y_n - a}$. Similarly, if $-c + d\\,x_n < 0$, the second condition imposes $h \\le \\frac{1}{c - d\\,x_n}$. If these conditions are violated, the Forward Euler scheme may produce unphysical negative results.\n\nThe algorithm for each test case is as follows:\n1. Set the constant parameters: $a=1$, $b=0.5$, $c=1$, $d=0.5$.\n2. For a given case with initial conditions $(x_0, y_0)$ and time parameters $(h, T)$, calculate the number of steps $N = T/h$. For all provided cases, $N=1$.\n3. Generate the population sequences $\\{x_n\\}_{n=0}^N$ and $\\{y_n\\}_{n=0}^N$. Since $N=1$, we compute only $(x_1, y_1)$ from $(x_0, y_0)$.\n4. Analyze the full sequence of iterates $\\{x_0, x_1\\}$ and $\\{y_0, y_1\\}$.\n5. Determine if any value is strictly negative, i.e., $x_1<0$ or $y_1<0$. This sets the boolean flag.\n6. Find the minimum values $\\min\\{x_0, x_1\\}$ and $\\min\\{y_0, y_1\\}$.\n7. Report the results, with minimum values rounded to six decimal places.\n\nLet us carry out the calculations for each case.\n\nCase 1: $x_0=10$, $y_0=5$, $h=0.01$, $T=0.01$. Here $N=1$.\n$x_1 = 10 \\left( 1 + 0.01(1 - 0.5 \\times 5) \\right) = 10 \\left( 1 + 0.01(-1.5) \\right) = 10(0.985) = 9.85$.\n$y_1 = 5 \\left( 1 + 0.01(-1 + 0.5 \\times 10) \\right) = 5 \\left( 1 + 0.01(4) \\right) = 5(1.04) = 5.2$.\nThe sequences are $x = \\{10, 9.85\\}$ and $y = \\{5, 5.2\\}$.\n- Negativity flag: No negative values. `False`.\n- Minimum $x$: $\\min\\{10, 9.85\\} = 9.85$.\n- Minimum $y$: $\\min\\{5, 5.2\\} = 5$.\nResult: $[\\text{False}, 9.850000, 5.000000]$.\n\nCase 2: $x_0=8$, $y_0=12$, $h=0.2$, $T=0.2$. Here $N=1$.\n$x_1 = 8 \\left( 1 + 0.2(1 - 0.5 \\times 12) \\right) = 8 \\left( 1 + 0.2(-5) \\right) = 8(1-1) = 0$.\n$y_1 = 12 \\left( 1 + 0.2(-1 + 0.5 \\times 8) \\right) = 12 \\left( 1 + 0.2(3) \\right) = 12(1.6) = 19.2$.\nThe sequences are $x = \\{8, 0\\}$ and $y = \\{12, 19.2\\}$.\n- Negativity flag: No strictly negative values. `False`.\n- Minimum $x$: $\\min\\{8, 0\\} = 0$.\n- Minimum $y$: $\\min\\{12, 19.2\\} = 12$.\nResult: $[\\text{False}, 0.000000, 12.000000]$.\n\nCase 3: $x_0=8$, $y_0=30$, $h=0.2$, $T=0.2$. Here $N=1$.\n$x_1 = 8 \\left( 1 + 0.2(1 - 0.5 \\times 30) \\right) = 8 \\left( 1 + 0.2(-14) \\right) = 8(1 - 2.8) = 8(-1.8) = -14.4$.\n$y_1 = 30 \\left( 1 + 0.2(-1 + 0.5 \\times 8) \\right) = 30 \\left( 1 + 0.2(3) \\right) = 30(1.6) = 48$.\nThe sequences are $x = \\{8, -14.4\\}$ and $y = \\{30, 48\\}$.\n- Negativity flag: $x_1 = -14.4 < 0$. `True`.\n- Minimum $x$: $\\min\\{8, -14.4\\} = -14.4$.\n- Minimum $y$: $\\min\\{30, 48\\} = 30$.\nResult: $[\\text{True}, -14.400000, 30.000000]$.\n\nCase 4: $x_0=0.5$, $y_0=10$, $h=2.0$, $T=2.0$. Here $N=1$.\n$x_1 = 0.5 \\left( 1 + 2.0(1 - 0.5 \\times 10) \\right) = 0.5 \\left( 1 + 2.0(-4) \\right) = 0.5(1 - 8) = 0.5(-7) = -3.5$.\n$y_1 = 10 \\left( 1 + 2.0(-1 + 0.5 \\times 0.5) \\right) = 10 \\left( 1 + 2.0(-0.75) \\right) = 10(1 - 1.5) = 10(-0.5) = -5$.\nThe sequences are $x = \\{0.5, -3.5\\}$ and $y = \\{10, -5\\}$.\n- Negativity flag: $x_1 = -3.5 < 0$ and $y_1 = -5 < 0$. `True`.\n- Minimum $x$: $\\min\\{0.5, -3.5\\} = -3.5$.\n- Minimum $y$: $\\min\\{10, -5\\} = -5$.\nResult: $[\\text{True}, -3.500000, -5.000000]$.\n\nThe implementation will now follow this precise logic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates the Lotka-Volterra equations using the Forward Euler method for\n    a given set of test cases and analyzes the stability and population minima.\n    \"\"\"\n    # Define the Lotka-Volterra parameters, constant for all cases.\n    a = 1.0\n    b = 0.5\n    c = 1.0\n    d = 0.5\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (x0, y0, h, T)\n    test_cases = [\n        (10.0, 5.0, 0.01, 0.01),  # Case 1\n        (8.0, 12.0, 0.2, 0.2),    # Case 2\n        (8.0, 30.0, 0.2, 0.2),    # Case 3\n        (0.5, 10.0, 2.0, 2.0),    # Case 4\n    ]\n\n    all_results = []\n    for case in test_cases:\n        x0, y0, h, T = case\n        \n        # Calculate the number of steps. The problem statement guarantees this is an integer.\n        N = int(T / h)\n        \n        # Initialize lists to store the history of populations, including initial values.\n        x_history = [x0]\n        y_history = [y0]\n        \n        # Set current population values.\n        x_n, y_n = x0, y0\n        \n        # Perform the Forward Euler iteration.\n        for _ in range(N):\n            # Calculate the next population values based on the recurrence relations.\n            x_n_plus_1 = x_n * (1 + h * (a - b * y_n))\n            y_n_plus_1 = y_n * (1 + h * (-c + d * x_n))\n            \n            # Append new values to history.\n            x_history.append(x_n_plus_1)\n            y_history.append(y_n_plus_1)\n            \n            # Update current values for the next iteration.\n            x_n, y_n = x_n_plus_1, y_n_plus_1\n            \n        # Analyze the results for the current case.\n        min_x = np.min(x_history)\n        min_y = np.min(y_history)\n        \n        # Check for strictly negative populations.\n        negativity_flag = (min_x < 0) or (min_y < 0)\n        \n        # Store the results for this case.\n        all_results.append([negativity_flag, min_x, min_y])\n\n    # Format the final output string according to the specified format.\n    # [ [flag,min_x,min_y],[flag,min_x,min_y],... ]\n    # with floats formatted to 6 decimal places and no spaces.\n    result_strings = []\n    for res in all_results:\n        flag, mx, my = res\n        # Apply standard rounding to 6 decimal places, then format.\n        mx_fmt = f\"{round(mx, 6):.6f}\"\n        my_fmt = f\"{round(my, 6):.6f}\"\n        # The boolean needs to be capitalized, which str() does by default.\n        result_strings.append(f\"[{str(flag)},{mx_fmt},{my_fmt}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2437681"}, {"introduction": "For linear iterative processes, the condition that the spectral radius of the iteration matrix is less than one, $\\rho(M) \\lt 1$, is the definitive guide to long-term stability. However, this asymptotic guarantee can be misleading in practice, as it says nothing about short-term behavior. This exercise reveals the counter-intuitive phenomenon of transient growth, where a system guaranteed to converge can experience a significant, temporary amplification of its state. You will simulate a system whose dynamics initially appear to diverge before the guaranteed decay takes over, a critical behavior to understand in fields like fluid dynamics and control systems [@problem_id:2437705].", "problem": "You are given a family of discrete-time linear iterative processes on the two-dimensional real vector space defined by the recurrence\n$$\n\\mathbf{x}_{k+1} = M \\,\\mathbf{x}_{k},\n$$\nwhere\n$$\nM = \\begin{bmatrix}\nr & L\\\\\n0 & r\n\\end{bmatrix},\n$$\nwith parameters $r \\in (0,1)$ and $L \\ge 0$, and an initial state $\\mathbf{x}_0 \\in \\mathbb{R}^2$. For each process, define the Euclidean norm sequence\n$$\nn_k = \\|\\mathbf{x}_k\\|_2\n$$\nfor integer iterates $k \\ge 0$. Convergence is understood as $\\lim_{k \\to \\infty} \\mathbf{x}_k = \\mathbf{0}$, and in computation is detected when $n_k \\le \\text{tol}$ for a prescribed tolerance $\\text{tol} > 0$.\n\nYour task is to write a complete, runnable program that, for each specified parameter set, simulates the recurrence and reports quantitative indicators of its stability and transient behavior. For each parameter set, your program must compute the following quantities:\n\n- A boolean value $B$ indicating whether the norm is strictly increasing for the first $N_{\\mathrm{inc}}$ steps, that is, whether the property $n_k > n_{k-1}$ holds for all integers $k$ with $1 \\le k \\le N_{\\mathrm{inc}}$. If the process reaches the convergence threshold before $N_{\\mathrm{inc}}$ steps, then treat this property as false.\n- An integer $k_{\\mathrm{conv}}$, the smallest integer $k \\ge 0$ such that $n_k \\le \\text{tol}$. If such an integer does not exist within the prescribed iteration budget, report $k_{\\mathrm{conv}} = -1$.\n- An integer $k_{\\mathrm{peak}}$ at which the maximum norm\n$$\nn_{\\max} = \\max \\{ n_k : 0 \\le k \\le k_{\\mathrm{end}} \\}\n$$\nis attained, where $k_{\\mathrm{end}} = k_{\\mathrm{conv}}$ if $k_{\\mathrm{conv}} \\ne -1$, and $k_{\\mathrm{end}} = K_{\\max}$ otherwise, with $K_{\\max}$ the maximum number of iterations allowed. If there are multiple indices attaining the maximum, report the smallest such index.\n- A floating-point number $n_{\\max}$ as defined above.\n\nYour program must use the following test suite of parameter sets. In each case, the iteration must start from\n$$\n\\mathbf{x}_0 = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix},\n$$\nand the Euclidean norm is used. The convergence tolerance is $\\text{tol} = 10^{-6}$ (dimensionless), and the angle unit is not applicable. For each test case, simulate up to a maximum of $K_{\\max}$ iterations as specified.\n\nTest Suite:\n- Case $1$: $r = 0.99$, $L = 100.0$, $N_{\\mathrm{inc}} = 100$, $K_{\\max} = 10000$.\n- Case $2$: $r = 0.99$, $L = 0.0$, $N_{\\mathrm{inc}} = 100$, $K_{\\max} = 10000$.\n- Case $3$: $r = 0.995$, $L = 100.0$, $N_{\\mathrm{inc}} = 100$, $K_{\\max} = 20000$.\n- Case $4$: $r = 0.9$, $L = 1000.0$, $N_{\\mathrm{inc}} = 100$, $K_{\\max} = 2000$.\n\nFinal output format:\nYour program should produce a single line of output containing the results for the test cases, in order, as a comma-separated list enclosed in square brackets, where each test case result is itself a list in the format\n$$\n[B, k_{\\mathrm{conv}}, k_{\\mathrm{peak}}, n_{\\max}],\n$$\nwith $B$ a boolean, $k_{\\mathrm{conv}}$ and $k_{\\mathrm{peak}}$ integers, and $n_{\\max}$ a floating-point number. For example, an output for two cases could look like\n$$\n[[\\text{True}, 1234, 100, 3.14159],[\\text{False}, -1, 57, 2.71828]].\n$$", "solution": "The problem as stated is valid. It is a well-posed, self-contained, and scientifically grounded exercise in the analysis of linear discrete-time systems, a fundamental topic in computational engineering and applied mathematics. All parameters and conditions are specified with sufficient precision to allow for a unique and verifiable solution.\n\nThe problem investigates the stability and transient behavior of the iterative process $\\mathbf{x}_{k+1} = M \\mathbf{x}_{k}$, where the matrix $M$ is given by\n$$\nM = \\begin{bmatrix}\nr & L\\\\\n0 & r\n\\end{bmatrix}.\n$$\nThis matrix has a repeated eigenvalue $\\lambda = r$. Since the problem specifies $r \\in (0,1)$, the spectral radius of the matrix is $\\rho(M) = r < 1$. This condition guarantees that the system is asymptotically stable, meaning $\\lim_{k \\to \\infty} M^k = \\mathbf{0}$ and consequently $\\lim_{k \\to \\infty} \\mathbf{x}_k = \\mathbf{0}$ for any initial state $\\mathbf{x}_0$.\n\nHowever, for $L > 0$, the matrix $M$ is not normal, as $MM^T \\neq M^T M$. A key property of non-normal systems is their capacity for transient growth, where the norm of the state vector, $n_k = \\|\\mathbf{x}_k\\|_2$, can increase for a period before the eventual asymptotic decay takes effect. This phenomenon is critical in many engineering applications where temporary large excursions can lead to system failure, even if the system is theoretically stable.\n\nTo analyze this behavior, we can derive a closed-form expression for $\\mathbf{x}_k$. The matrix $M$ can be decomposed as $M = rI + N$, where $I$ is the $2 \\times 2$ identity matrix and $N$ is a nilpotent matrix:\n$$\nN = \\begin{bmatrix}\n0 & L\\\\\n0 & 0\n\\end{bmatrix}, \\quad N^2 = \\mathbf{0}.\n$$\nUsing the binomial theorem, we find the $k$-th power of $M$:\n$$\nM^k = (rI + N)^k = \\binom{k}{0} (rI)^k N^0 + \\binom{k}{1} (rI)^{k-1} N^1 + \\dots = r^k I + k r^{k-1} N.\n$$\nExplicitly, this is:\n$$\nM^k = \\begin{bmatrix}\nr^k & k r^{k-1} L \\\\\n0 & r^k\n\\end{bmatrix}.\n$$\nFor the initial state $\\mathbf{x}_0 = [1.0, 1.0]^T$, the state vector at iterate $k$ is:\n$$\n\\mathbf{x}_k = M^k \\mathbf{x}_0 = \\begin{bmatrix}\nr^k & k r^{k-1} L \\\\\n0 & r^k\n\\end{bmatrix}\n\\begin{bmatrix}\n1.0 \\\\\n1.0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nr^k + k r^{k-1} L \\\\\nr^k\n\\end{bmatrix}.\n$$\nThe squared Euclidean norm, $n_k^2 = \\|\\mathbf{x}_k\\|_2^2$, is therefore:\n$$\nn_k^2 = (r^k + k r^{k-1} L)^2 + (r^k)^2 = r^{2k} \\left( \\left(1 + \\frac{kL}{r}\\right)^2 + 1 \\right).\n$$\nThis expression demonstrates the competition between the polynomial growth term, which is dominated by $(kL/r)^2$, and the exponential decay term $r^{2k}$. For $L>0$ and $r$ close to $1$, the polynomial term can cause $n_k$ to increase initially, creating the transient growth.\n\nWhile this analytical form provides a complete theoretical understanding, the problem requires a direct numerical simulation to find the specified quantitative indicators. The following algorithm is implemented to solve the problem for each test case.\n\n**Algorithm:**\nFor a given set of parameters $(r, L, N_{\\mathrm{inc}}, K_{\\max})$, tolerance $\\text{tol}$, and initial state $\\mathbf{x}_0$:\n\n1.  **Initialization**:\n    - Set the iteration counter $k = 0$.\n    - Initialize the state vector $\\mathbf{x} \\leftarrow \\mathbf{x}_0$.\n    - Compute the initial norm $n_0 = \\|\\mathbf{x}\\|_2$.\n    - Initialize a list of norms, `norm_history`, with $n_0$.\n    - Initialize maximum norm $n_{\\max} \\leftarrow n_0$ and peak index $k_{\\mathrm{peak}} \\leftarrow 0$.\n    - Initialize convergence index $k_{\\mathrm{conv}} \\leftarrow -1$.\n    - Initialize a boolean flag `is_strictly_increasing` to `True`. This flag tracks if $n_k > n_{k-1}$ for $1 \\le k \\le N_{\\mathrm{inc}}$.\n\n2.  **Iteration**: Loop for $k$ from $1$ to $K_{\\max}$:\n    a. Update the state: $\\mathbf{x} \\leftarrow M \\mathbf{x}$.\n    b. Compute the new norm $n_k = \\|\\mathbf{x}\\|_2$ and record it.\n    c. Check for strict increase: If $k \\le N_{\\mathrm{inc}}$ and $n_k \\le n_{k-1}$, set `is_strictly_increasing` to `False`.\n    d. Update peak values: If $n_k > n_{\\max}$, update $n_{\\max} \\leftarrow n_k$ and $k_{\\mathrm{peak}} \\leftarrow k$.\n    e. Check for convergence: If $n_k \\le \\text{tol}$, set $k_{\\mathrm{conv}} \\leftarrow k$ and terminate the loop.\n\n3.  **Finalization**: After the loop completes (either by convergence or by reaching $K_{\\max}$):\n    a. Determine the boolean value $B$. According to the problem, $B$ is false if the norm is not strictly increasing over the first $N_{\\mathrm{inc}}$ steps OR if the process converges at or before step $N_{\\mathrm{inc}}$. This is computed as $B = \\text{is\\_strictly\\_increasing} \\land (k_{\\mathrm{conv}} = -1 \\lor k_{\\mathrm{conv}} > N_{\\mathrm{inc}})$. This correctly implements the problem directive.\n    b. The values $k_{\\mathrm{conv}}$, $k_{\\mathrm{peak}}$, and $n_{\\max}$ are taken from the values recorded during the simulation.\n\nThis direct simulation robustly calculates the required quantities for each test case. The final output is an aggregation of the results from for all specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(r, L, N_inc, K_max, x0, tol):\n    \"\"\"\n    Simulates the linear iterative process and computes stability indicators.\n\n    Args:\n        r (float): Parameter r of the matrix M.\n        L (float): Parameter L of the matrix M.\n        N_inc (int): Number of initial steps to check for norm increase.\n        K_max (int): Maximum number of iterations.\n        x0 (np.ndarray): Initial state vector.\n        tol (float): Convergence tolerance.\n\n    Returns:\n        list: A list containing [B, k_conv, k_peak, n_max].\n    \"\"\"\n    M = np.array([[r, L], [0, r]], dtype=np.float64)\n    x = np.array(x0, dtype=np.float64)\n\n    n_k = np.linalg.norm(x)\n    \n    # Store history of norms to check for increase\n    norm_history = [n_k]\n    \n    n_max = n_k\n    k_peak = 0\n    k_conv = -1\n    \n    is_strictly_increasing = True\n\n    for k in range(1, K_max + 1):\n        x = M @ x\n        n_k = np.linalg.norm(x)\n        norm_history.append(n_k)\n\n        # Check for strict increase property up to N_inc steps\n        if k <= N_inc:\n            if n_k <= norm_history[k - 1]:\n                is_strictly_increasing = False\n        \n        # Update peak norm and its index\n        if n_k > n_max:\n            n_max = n_k\n            k_peak = k\n        \n        # Check for convergence\n        if n_k <= tol:\n            k_conv = k\n            break\n\n    # Determine the final boolean value B\n    # B is True iff the norm is strictly increasing for the first N_inc steps\n    # AND the process does not converge within N_inc steps.\n    converged_early = (k_conv != -1 and k_conv <= N_inc)\n    B = is_strictly_increasing and not converged_early\n\n    return [B, k_conv, k_peak, n_max]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Common parameters for all test cases\n    x0 = [1.0, 1.0]\n    tol = 1e-6\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1: r, L, N_inc, K_max\n        (0.99, 100.0, 100, 10000),\n        # Case 2\n        (0.99, 0.0, 100, 10000),\n        # Case 3\n        (0.995, 100.0, 100, 20000),\n        # Case 4\n        (0.9, 1000.0, 100, 2000),\n    ]\n\n    results = []\n    for case in test_cases:\n        r, L, N_inc, K_max = case\n        result = run_simulation(r, L, N_inc, K_max, x0, tol)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list in Python matches the desired format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2437705"}, {"introduction": "The dynamics of iterative processes extend far beyond simple convergence, encompassing stable cycles, period-doubling, and chaos. To navigate this complex landscape, we need tools that can quantitatively characterize the behavior. This practice introduces the Largest Lyapunov Exponent (LLE), $\\lambda$, a powerful metric that measures the average exponential rate of separation of nearby trajectories. By implementing a numerical estimation of the LLE for the famous logistic map, you will learn to distinguish between stable attractors ($\\lambda \\le 0$) and the sensitive dependence on initial conditions that defines chaos ($\\lambda \\gt 0$) [@problem_id:2437680].", "problem": "Consider the one-dimensional iterative map defined by the logistic mapping $$x_{n+1} = f_r(x_n) = r\\,x_n\\,(1 - x_n),$$ where $r \\in (0,4]$ is a real parameter and $x_n \\in [0,1]$ for all integer iterates $n \\ge 0$. Let the Largest Lyapunov Exponent (LLE) be defined from first principles as the asymptotic exponential rate of separation of infinitesimally close trajectories. Specifically, given two initial conditions $x_0$ and $x_0 + \\delta x_0$ with $|\\delta x_0|$ sufficiently small, the LLE $\\lambda$ for a fixed $r$ is defined by $$\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\ln \\left( \\frac{|\\delta x_n|}{|\\delta x_0|} \\right),$$ where $\\delta x_n$ denotes the perturbation after $n$ iterations under the same map parameter $r$. Your task is to numerically estimate $\\lambda$ for specified values of $r$ and then use the value of $\\lambda$ to classify the long-term dynamics into one of three categories: stable fixed point, periodic orbit of period at least two, or chaotic.\n\nUse the following precise parameterization for all computations:\n- Initial condition: $x_0 = 0.123456789$.\n- Total number of iterations: $N = 100000$.\n- Transient iterations to discard before any estimation or classification: $T = 1000$.\n- For the purpose of classification, use the following tolerance on the LLE: $\\tau = 10^{-3}$.\n- For distinguishing a stable fixed point from a periodic orbit when $\\lambda \\le \\tau$, base the decision on the asymptotic behavior of the orbit: examine the last $W = 2048$ iterates of $x_n$ after discarding the transient and define two values $x_i$ and $x_j$ within this window to be equivalent if $|x_i - x_j| \\le \\delta$ with $\\delta = 10^{-6}$. If the equivalence classes in this window collapse to a single class, declare a stable fixed point; if there are at least two equivalence classes, declare a periodic orbit of period at least two. If $|\\lambda| \\le \\tau$, for the purpose of this problem, treat the dynamics as periodic in the above sense.\n- Classification coding: output $0$ for a stable fixed point, $1$ for a periodic orbit of period at least two, and $2$ for chaotic dynamics.\n\nTest suite:\n- Case $1$: $r = 2.8$.\n- Case $2$: $r = 3.2$.\n- Case $3$: $r = 3.5$.\n- Case $4$: $r = 3.58$.\n- Case $5$: $r = 3.9$.\n\nRequired outputs:\n- For each test case, return a two-element list containing: the estimated LLE $\\lambda$ rounded to six decimal places, and the classification code (as defined above).\n- Your program should produce a single line of output containing the results for the test cases, in order, aggregated as a comma-separated list enclosed in square brackets, where each element is the two-element list for a test case. For example: $[\\,[\\lambda_1, c_1],[\\lambda_2, c_2],\\dots]$, with each $\\lambda_k$ a float rounded to six decimals and each $c_k$ an integer in $\\{0,1,2\\}$. No spaces should appear in the output string.\n\nNo physical units or angle units are involved in this problem. All numerical values must be dimensionless. Your implementation must be self-contained and must not require any external input. The final output format must exactly follow the specification above on a single line.", "solution": "The problem statement has been rigorously validated and is found to be scientifically grounded, well-posed, and objective. It presents a standard computational task from the field of dynamical systems theory, specifically the numerical characterization of the logistic map, which is a canonical model for studying chaos. All parameters, definitions, and conditions required for a unique, verifiable solution are provided without ambiguity or contradiction. Therefore, I shall proceed with a complete solution.\n\nThe problem requires the numerical estimation of the Largest Lyapunov Exponent (LLE), denoted by $\\lambda$, for the one-dimensional logistic map, and the subsequent classification of the system's long-term dynamics. The logistic map is defined by the iterative equation:\n$$x_{n+1} = f_r(x_n) = r\\,x_n\\,(1 - x_n)$$\nwhere $r \\in (0,4]$ is the control parameter and the state $x_n$ is confined to the interval $[0,1]$.\n\nThe LLE quantifies the average exponential rate of divergence or convergence of nearby trajectories in the phase space. The problem provides the fundamental definition:\n$$\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\ln \\left( \\frac{|\\delta x_n|}{|\\delta x_0|} \\right)$$\nwhere $\\delta x_n$ is the separation between two initially close trajectories after $n$ iterations. For a one-dimensional map $x_{n+1} = f(x_n)$, the separation evolves according to $\\delta x_{n+1} \\approx f'(x_n) \\delta x_n$ for an infinitesimal perturbation $\\delta x_n$. Iterating this relationship gives $\\delta x_n \\approx \\delta x_0 \\prod_{i=0}^{n-1} f'(x_i)$. Substituting this into the definition of $\\lambda$ yields a more practical formula for computation:\n$$ \\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{i=0}^{n-1} \\ln |f'(x_i)| $$\nThis result demonstrates that the LLE is the long-term average of the logarithm of the absolute value of the map's derivative evaluated along a typical trajectory. For the logistic map, the derivative is:\n$$f'_r(x) = \\frac{d}{dx} (r x - r x^2) = r - 2rx = r(1 - 2x)$$\nThus, the expression for the LLE becomes:\n$$ \\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{i=0}^{n-1} \\ln |r(1 - 2x_i)| $$\n\nFor numerical estimation, the limit is replaced by an average over a large number of iterations $N$, after discarding an initial transient phase of $T$ iterations to ensure the trajectory has settled onto its attractor. The numerical approximation is therefore:\n$$ \\lambda \\approx \\frac{1}{N-T} \\sum_{i=T}^{N-1} \\ln |r(1 - 2x_i)| $$\n\nThe classification of the dynamics is based on the value of this estimated $\\lambda$:\n1.  If $\\lambda > \\tau$, where $\\tau = 10^{-3}$ is a small positive tolerance, it signifies exponential divergence of nearby trajectories. This sensitive dependence on initial conditions is the hallmark of chaos. The dynamics are classified as chaotic (code $2$).\n2.  If $\\lambda \\le \\tau$, the trajectories do not diverge exponentially, indicating regular, non-chaotic behavior. This includes stable fixed points and periodic orbits. A further test is required to distinguish between these cases.\n    - To differentiate, we analyze the structure of the attractor itself. We examine the last $W = 2048$ points of the computed trajectory, $\\{x_{N-W}, \\dots, x_{N-1}\\}$.\n    - We group these points into equivalence classes. Two points, $x_i$ and $x_j$, are considered equivalent if their absolute difference is less than or equal to a small tolerance, $|x_i - x_j| \\le \\delta$, where $\\delta = 10^{-6}$.\n    - If all points in this window fall into a single equivalence class, the attractor is a single point, and the dynamics are classified as a stable fixed point (code $0$).\n    - If the points form two or more distinct equivalence classes, the attractor is a multi-point periodic orbit, and the dynamics are classified as periodic with a period of at least two (code $1$).\n\nThe computational procedure for each given value of $r$ is as follows:\n1.  Initialize the system at $x_0 = 0.123456789$.\n2.  Iterate the map for $N = 100000$ steps.\n3.  For iterations $n$ from $T = 1000$ to $N-1$, calculate and sum the values of $\\ln|r(1 - 2x_n)|$. At the same time, store the trajectory points $x_n$.\n4.  Calculate $\\lambda$ by dividing the sum by the number of terms, $N-T$.\n5.  Apply the classification rules based on $\\lambda$ and, if necessary, the analysis of the last $W=2048$ points of the stored trajectory.\n6.  Store the resulting pair $[\\lambda, \\text{code}]$, with $\\lambda$ rounded to six decimal places, and repeat for all test cases.\n\nThis rigorous, step-by-step process ensures a correct and reproducible solution consistent with the principles of nonlinear dynamics.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the logistic map problem by calculating the Largest Lyapunov Exponent (LLE)\n    and classifying the dynamics for a given set of parameters.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        2.8,\n        3.2,\n        3.5,\n        3.58,\n        3.9,\n    ]\n\n    # Global parameters for the simulation\n    x0 = 0.123456789\n    N = 100000\n    T = 1000\n    tau = 1e-3\n    W = 2048\n    delta = 1e-6\n    \n    results = []\n    \n    for r in test_cases:\n        lambda_val, code = compute_and_classify(r, x0, N, T, W, tau, delta)\n        results.append([lambda_val, code])\n\n    # Format the final output string precisely as required:\n    # \"[[l1,c1],[l2,c2],...]\" with no spaces.\n    string_parts = []\n    for lambda_val, code in results:\n        # Round lambda to 6 decimal places for printing.\n        # The f-string format specifier handles rounding correctly.\n        formatted_lambda = f\"{lambda_val:.6f}\"\n        string_parts.append(f\"[{formatted_lambda},{code}]\")\n    \n    final_output_string = f\"[{','.join(string_parts)}]\"\n\n    print(final_output_string)\n\ndef compute_and_classify(r, x0, N, T, W, tau, delta):\n    \"\"\"\n    Computes the LLE and classifies the dynamics for a single parameter r.\n\n    Args:\n        r (float): The parameter of the logistic map.\n        x0 (float): The initial condition.\n        N (int): Total number of iterations.\n        T (int): Number of transient iterations to discard.\n        W (int): Window size for orbit analysis.\n        tau (float): Tolerance for LLE-based chaos classification.\n        delta (float): Tolerance for orbit point equivalence.\n\n    Returns:\n        tuple[float, int]: A tuple containing the estimated LLE and the classification code.\n    \"\"\"\n    x = x0\n    log_df_sum = 0.0\n    trajectory_post_transient = []\n\n    # Iterate the map\n    for n in range(N):\n        # Discard transient iterations for LLE and orbit analysis\n        if n >= T:\n            # The derivative is f'(x) = r * (1 - 2*x)\n            # We need log|f'(x)|\n            # Using numpy for safe log/abs operations\n            df = r * (1.0 - 2.0 * x)\n            log_df_sum += np.log(np.abs(df))\n            \n            # Store the last W points of the post-transient trajectory\n            if n >= N - W:\n                trajectory_post_transient.append(x)\n\n        # Apply the logistic map for the next iteration\n        x = r * x * (1.0 - x)\n\n    # Calculate the Largest Lyapunov Exponent (LLE)\n    num_post_transient_steps = N - T\n    lle = log_df_sum / num_post_transient_steps\n    \n    # Classify the dynamics\n    if lle > tau:\n        # Chaotic dynamics\n        code = 2\n    else:\n        # Non-chaotic dynamics: stable fixed point or periodic orbit\n        # We use the last W points saved in trajectory_post_transient\n        \n        # This list will store representatives of each equivalence class\n        unique_points = []\n        \n        for p in trajectory_post_transient:\n            is_new = True\n            for u in unique_points:\n                # Check if p is close to an existing representative\n                if np.abs(p - u) <= delta:\n                    is_new = False\n                    break\n            if is_new:\n                unique_points.append(p)\n        \n        num_classes = len(unique_points)\n        \n        if num_classes == 1:\n            # Stable fixed point\n            code = 0\n        else:\n            # Periodic orbit of period >= 2\n            code = 1\n            \n    return lle, code\n\nsolve()\n```", "id": "2437680"}]}