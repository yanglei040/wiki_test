{"hands_on_practices": [{"introduction": "The primary power of finite difference methods lies in their ability to transform complex differential equations into systems of linear algebraic equations, which are readily solvable by computers. This foundational exercise guides you through this crucial process for a second-order boundary value problem, demonstrating how to discretize both first and second derivatives to set up the numerical scheme. [@problem_id:2157255]", "problem": "Consider the two-point boundary value problem defined by the ordinary differential equation $y'' - 3y' + 2y = 0$ on a given interval. To solve this problem numerically, the domain is discretized into a set of nodes $x_i$ with a uniform step size $h$. Let $y_i$ represent the numerical approximation of the solution $y(x_i)$ at node $x_i$.\n\nBy applying second-order centered finite difference approximations for both the first and second derivatives at an interior node $x_i$, a linear algebraic equation is formed relating $y_i$ to its immediate neighbors, $y_{i-1}$ and $y_{i+1}$.\n\nDerive this relationship and express $y_i$ as a function of $y_{i-1}$, $y_{i+1}$, and the step size $h$. Your final expression must be a single fraction with the simplest possible integer or polynomial coefficients.", "solution": "We start from the differential equation $y'' - 3y' + 2y = 0$ and apply centered second-order finite differences at an interior node $x_{i}$ with uniform step size $h$. The standard approximations are\n$$\ny''(x_{i}) \\approx \\frac{y_{i+1} - 2y_{i} + y_{i-1}}{h^{2}}, \n\\qquad\ny'(x_{i}) \\approx \\frac{y_{i+1} - y_{i-1}}{2h}.\n$$\nSubstituting these into the equation at $x_{i}$ gives\n$$\n\\frac{y_{i+1} - 2y_{i} + y_{i-1}}{h^{2}} - 3\\frac{y_{i+1} - y_{i-1}}{2h} + 2y_{i} = 0.\n$$\nMultiply through by $2h^{2}$ to clear denominators:\n$$\n2(y_{i+1} - 2y_{i} + y_{i-1}) - 3h(y_{i+1} - y_{i-1}) + 4h^{2}y_{i} = 0.\n$$\nCollect like terms:\n$$\n(2 - 3h)y_{i+1} + 4(h^{2} - 1)y_{i} + (2 + 3h)y_{i-1} = 0.\n$$\nSolve for $y_{i}$:\n$$\n4(h^{2} - 1)y_{i} = -(2 - 3h)y_{i+1} - (2 + 3h)y_{i-1},\n$$\nwhich can be written as\n$$\ny_{i} = \\frac{(2 - 3h)y_{i+1} + (2 + 3h)y_{i-1}}{4(1 - h^{2})}.\n$$\nThis expresses $y_{i}$ as a single fraction in terms of $y_{i-1}$, $y_{i+1}$, and $h$ with polynomial coefficients.", "answer": "$$\\boxed{\\frac{(2 - 3h)\\,y_{i+1} + (2 + 3h)\\,y_{i-1}}{4\\,(1 - h^{2})}}$$", "id": "2157255"}, {"introduction": "While finite differences provide an approximation, understanding the source and behavior of the error is paramount for judging a method's reliability. This exercise presents a fascinating scenario where the numerical solution is not just an approximation but is *exactly* correct. By investigating why this occurs, you will gain a much deeper intuition for the local truncation error and its dependence on the smoothness of the underlying solution. [@problem_id:2391599]", "problem": "Consider the boundary value problem (BVP) $-u''(x)=1$ on $x\\in(0,1)$ with $u(0)=0$ and $u(1)=0$. Let $x_i=i\\,h$ for $i=0,1,\\dots,N+1$ with $h=1/(N+1)$, and consider the standard second-order central difference discretization on the uniform grid: for each interior index $i=1,2,\\dots,N$, enforce\n$$-\\frac{u_{i+1}-2u_i+u_{i-1}}{h^2}=1,$$\ntogether with $u_0=0$ and $u_{N+1}=0$. It is observed that, for every $N\\ge 1$, the numerical solution $\\{u_i\\}_{i=0}^{N+1}$ exactly equals the values of the continuous solution $u(x)$ evaluated at the grid nodes $\\{x_i\\}_{i=0}^{N+1}$.\n\nWhich option best explains, from first principles and in terms of the local truncation error of the stencil, why this exactness at the nodes occurs?\n\nA. The local truncation error of the central difference approximation to $u''(x)$ at $x_i$ involves the fourth derivative $u^{(4)}(x)$ multiplied by $h^2$, so for the quadratic exact solution of the BVP one has $u^{(4)}(x)\\equiv 0$ and the truncation error vanishes at every interior node, making the discrete equations hold exactly for $u(x_i)$.\n\nB. The method is exact here because round-off errors cancel due to the symmetry of the stencil for any $h$, so the computed solution coincides with the exact nodal values.\n\nC. The central difference formula equals the true second derivative for any smooth function due to its symmetric two-sided form, hence the discrete equations always match the differential equation pointwise.\n\nD. Since the source term is the constant $1$ and the boundary conditions are homogeneous, the maximum principle guarantees that any consistent finite difference method produces zero global error, regardless of the grid.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- The boundary value problem (BVP) is defined by the differential equation $-u''(x)=1$ on the domain $x \\in (0,1)$.\n- The boundary conditions are $u(0)=0$ and $u(1)=0$.\n- The domain is discretized using a uniform grid $x_i=i\\,h$ for $i=0,1,\\dots,N+1$, with step size $h=1/(N+1)$.\n- The finite difference approximation for the BVP at interior nodes $i=1,2,\\dots,N$ is given by $-\\frac{u_{i+1}-2u_i+u_{i-1}}{h^2}=1$.\n- The discrete boundary conditions are $u_0=0$ and $u_{N+1}=0$.\n- An observation is provided: the numerical solution $\\{u_i\\}_{i=0}^{N+1}$ exactly matches the values of the continuous solution $u(x)$ at the grid nodes, i.e., $u_i = u(x_i)$ for all $i$.\n- The task is to explain this exactness based on the local truncation error of the numerical method.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, concerning a standard topic in numerical analysis for differential equations. It is well-posed, as the BVP has a unique solution and the resulting linear system from the finite difference method is non-singular. The problem statement is objective and internally consistent.\n\nTo verify the central claim, we first find the exact solution $u(x)$.\nIntegrating $-u''(x)=1$ once gives $u'(x) = -x + C_1$.\nIntegrating a second time gives $u(x) = -\\frac{1}{2}x^2 + C_1x + C_2$.\nApplying the boundary conditions:\n$u(0)=0 \\implies -\\frac{1}{2}(0)^2 + C_1(0) + C_2 = 0 \\implies C_2=0$.\n$u(1)=0 \\implies -\\frac{1}{2}(1)^2 + C_1(1) = 0 \\implies C_1 = \\frac{1}{2}$.\nThe exact solution is $u(x) = \\frac{1}{2}x - \\frac{1}{2}x^2 = \\frac{1}{2}x(1-x)$.\nThis is a quadratic polynomial.\n\nThe local truncation error, $\\tau_i$, of the finite difference scheme is the residual obtained when the exact solution $u(x)$ is substituted into the discrete equation. The discrete model is $L_h u_i = f_i$, where $L_h u_i = -\\frac{u_{i+1}-2u_i+u_{i-1}}{h^2}$ and $f_i=1$. The continuous model is $L u = f$, where $L u = -u''$ and $f(x)=1$.\nThe local truncation error is $\\tau_i = L_h u(x_i) - f(x_i)$.\n$$ \\tau_i = -\\frac{u(x_{i+1}) - 2u(x_i) + u(x_{i-1})}{h^2} - (-1) $$\nWe use Taylor series expansions of $u(x)$ around $x_i$:\n$u(x_{i+1}) = u(x_i+h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2!} u''(x_i) + \\frac{h^3}{3!} u'''(x_i) + \\frac{h^4}{4!} u^{(4)}(x_i) + O(h^5)$.\n$u(x_{i-1}) = u(x_i-h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2!} u''(x_i) - \\frac{h^3}{3!} u'''(x_i) + \\frac{h^4}{4!} u^{(4)}(x_i) - O(h^5)$.\nSumming these two expansions yields:\n$u(x_{i+1}) + u(x_{i-1}) = 2u(x_i) + h^2 u''(x_i) + \\frac{h^4}{12} u^{(4)}(x_i) + O(h^6)$.\nRearranging this gives the standard expression for the central difference approximation of the second derivative:\n$$ \\frac{u(x_{i+1}) - 2u(x_i) + u(x_{i-1})}{h^2} = u''(x_i) + \\frac{h^2}{12}u^{(4)}(x_i) + O(h^4) $$\nSubstituting this into the expression for $\\tau_i$:\n$$ \\tau_i = -\\left( u''(x_i) + \\frac{h^2}{12}u^{(4)}(x_i) + O(h^4) \\right) - (-1) $$\nFrom the original differential equation, we have $u''(x) = -1$ for all $x$, including $x=x_i$.\n$$ \\tau_i = -(-1 + \\frac{h^2}{12}u^{(4)}(x_i) + O(h^4) ) + 1 = 1 - \\frac{h^2}{12}u^{(4)}(x_i) - O(h^4) - 1 = -\\frac{h^2}{12}u^{(4)}(x_i) - O(h^4) $$\nThis confirms that the method is second-order accurate in general. However, for the specific solution $u(x) = \\frac{1}{2}x - \\frac{1}{2}x^2$, we calculate the derivatives:\n$u'(x) = \\frac{1}{2} - x$\n$u''(x) = -1$\n$u'''(x) = 0$\n$u^{(4)}(x) = 0$\nSince the fourth derivative (and all higher derivatives) of $u(x)$ is identically zero, the expression for the local truncation error becomes $\\tau_i = 0$ for all interior nodes $i=1,\\dots,N$.\nThe global error $e_i = u(x_i) - u_i$ satisfies the system of linear equations $A \\mathbf{e} = \\boldsymbol{\\tau}$, where $\\mathbf{e}$ is the vector of nodal errors and $\\boldsymbol{\\tau}$ is the vector of truncation errors. Since $\\boldsymbol{\\tau} = \\mathbf{0}$ and the matrix $A$ for this problem is invertible, the unique solution is $\\mathbf{e} = \\mathbf{0}$. This means $e_i = 0$ for all $i$, so $u_i = u(x_i)$. The observation is thus mathematically verified.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. A complete solution will now be derived.\n\nThe core of the explanation lies in the analysis of the local truncation error for the given problem. As derived above, the local truncation error $\\tau_i$ for the central difference approximation of $-u''(x)=1$ is given by $\\tau_i = -\\frac{h^2}{12}u^{(4)}(x_i) - O(h^4)$. The exact solution to the BVP is the quadratic polynomial $u(x) = \\frac{1}{2}x(1-x)$. For this function, the fourth derivative $u^{(4)}(x)$ is identically zero for all $x$. Consequently, the entire Taylor series for the truncation error vanishes, meaning $\\tau_i = 0$ for all interior grid points $x_i$. When the local truncation error is zero at every node, the exact solution of the continuous problem satisfies the discrete equations perfectly. Since the discrete system has a unique solution, the numerical solution must be identical to the exact solution evaluated at the grid nodes.\n\nNow, we evaluate each provided option based on this reasoning.\n\n**A. The local truncation error of the central difference approximation to $u''(x)$ at $x_i$ involves the fourth derivative $u^{(4)}(x)$ multiplied by $h^2$, so for the quadratic exact solution of the BVP one has $u^{(4)}(x)\\equiv 0$ and the truncation error vanishes at every interior node, making the discrete equations hold exactly for $u(x_i)$.**\nThis statement is entirely consistent with our derivation. It correctly identifies that the leading term of the local truncation error depends on $u^{(4)}(x)$. It correctly states that for the quadratic solution of this specific BVP, $u^{(4)}(x)$ is identically zero. It correctly concludes that this causes the truncation error to vanish and, as a result, the discrete equations are satisfied exactly by the nodal values of the continuous solution. This provides a complete and accurate explanation from first principles.\nVerdict: **Correct**.\n\n**B. The method is exact here because round-off errors cancel due to the symmetry of the stencil for any $h$, so the computed solution coincides with the exact nodal values.**\nThis option is fundamentally flawed. It confuses discretization error (or truncation error), which is a mathematical property of the approximation method, with round-off error, which is an artifact of finite-precision computer arithmetic. The exactness of the solution at the nodes, as discussed in the problem, is a mathematical fact that holds even in exact arithmetic. While stencil symmetry can have implications for error cancellation, it does not imply that round-off errors will cancel out in general, nor is round-off error the reason for the exactness of the discretization.\nVerdict: **Incorrect**.\n\n**C. The central difference formula equals the true second derivative for any smooth function due to its symmetric two-sided form, hence the discrete equations always match the differential equation pointwise.**\nThis option makes a false claim. The central difference formula $\\frac{u(x_{i+1})-2u(x_i)+u(x_{i-1})}{h^2}$ is an *approximation* to $u''(x_i)$, not an identity for \"any smooth function\". The error in this approximation is, as shown in the derivation, $\\frac{h^2}{12}u^{(4)}(x_i) + O(h^4)$. This error is non-zero for most smooth functions (e.g., $u(x)=\\sin(x)$). The formula is only exact for polynomials of degree less than four. The conclusion that the discrete and continuous equations always match is therefore false.\nVerdict: **Incorrect**.\n\n**D. Since the source term is the constant $1$ and the boundary conditions are homogeneous, the maximum principle guarantees that any consistent finite difference method produces zero global error, regardless of the grid.**\nThis option misuses the maximum principle and draws an incorrect conclusion. The discrete maximum principle is a tool for proving stability and obtaining error bounds (e.g., showing that the global error is bounded by the maximum of the local truncation error). It does *not* guarantee zero global error. The claim that \"any consistent finite difference method\" would be exact is also false. For example, a different but still consistent scheme might not be exact. The specific properties of the source term and boundary conditions are not sufficient; the crucial fact is that they lead to a polynomial solution of a degree for which the chosen finite difference stencil happens to be exact.\nVerdict: **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "2391599"}, {"introduction": "Real-world simulations often require finer resolution in certain areas to capture complex phenomena, making non-uniform grids a practical necessity. This practice moves beyond uniform spacing, challenging you to derive the second-order accurate finite difference approximation for $u_{xx}$ on an arbitrary grid. You will then implement and computationally verify your formula, bridging the gap between theoretical derivation and practical, hands-on coding. [@problem_id:2391620]", "problem": "Consider the one-dimensional heat partial differential equation (PDE) $u_t = \\alpha u_{xx}$ on the spatial interval $x \\in [0,1]$ with homogeneous Dirichlet boundary conditions $u(0,t)=0$ and $u(1,t)=0$ for all $t \\ge 0$. Let the spatial grid be non-uniform, with nodes $x_0=0 < x_1 < \\cdots < x_{N} < x_{N+1}=1$, where $N \\ge 1$ is the number of interior nodes. Denote the nodal values by $u_i(t) \\approx u(x_i,t)$. Your tasks are:\n- Derive, from first principles, a second-order accurate finite difference approximation for the second derivative $u_{xx}$ at each interior node $x_i$ using only the neighbor values $u_{i-1}(t)$, $u_i(t)$, and $u_{i+1}(t)$, where $i \\in \\{1,2,\\dots,N\\}$.\n- Implement the resulting discrete operator that maps nodal values $\\{u_j\\}_{j=0}^{N+1}$ to approximations of $\\{u_{xx}(x_i)\\}_{i=1}^{N}$ at the interior nodes.\n- To quantitatively verify the second-order spatial accuracy of your discretization, for each specified test case below, evaluate the operator on the smooth function $u(x) = \\sin(k \\pi x)$ and compare against the exact second derivative $u''(x) = - (k \\pi)^2 \\sin(k \\pi x)$ at the interior nodes. Compute the root-mean-square (RMS) error defined as\n$$\nE_{\\mathrm{RMS}} \\;=\\; \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left( D^{(2)}u(x_i) \\;-\\; u''(x_i) \\right)^2 } \\, ,\n$$\nwhere $D^{(2)}u(x_i)$ denotes your discrete approximation of $u_{xx}(x_i)$.\n\nNo time integration is required in this task; focus exclusively on the accurate spatial discretization of $u_{xx}$ on non-uniform grids.\n\nUse the following grid-generation rules. Let $\\xi_i = \\dfrac{i}{N+1}$ for $i \\in \\{0,1,\\dots,N+1\\}$, and define the physical nodes $\\{x_i\\}$ by a mapping $x(\\xi)$:\n- Uniform: $x_i = \\xi_i$.\n- Cosine-clustered: $x_i = \\dfrac{1 - \\cos(\\pi \\xi_i)}{2}$.\n- Power-law: $x_i = \\xi_i^{p}$ with a given power $p > 0$.\n\nUse the test suite below. For each case, evaluate $u(x) = \\sin(k \\pi x)$ on the nodes, apply your finite difference operator to compute $D^{(2)}u(x_i)$ at the interior nodes, and report the RMS error $E_{\\mathrm{RMS}}$ as a floating-point number:\n- Case $1$: $N = 80$, cosine-clustered grid, $k = 1$.\n- Case $2$: $N = 80$, power-law grid with $p = 3$, $k = 2$.\n- Case $3$: $N = 10$, uniform grid, $k = 3$.\n- Case $4$: $N = 2$, power-law grid with $p = 2$, $k = 1$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of the four RMS errors in the order of Cases $1$ through $4$, enclosed in square brackets, with each value rounded to $10$ decimal places in scientific notation (for example, $[1.2345678901e-04,2.3456789012e-05,3.4567890123e-06,4.5678901234e-07]$).", "solution": "The problem statement submitted for analysis is rigorously formulated, self-contained, and scientifically sound. It presents a standard task in computational engineering: the discretization of a differential operator on a non-uniform grid and the quantitative verification of its accuracy. All provided information is consistent and sufficient for a unique solution. The problem is valid.\n\nThe central task is to derive a finite difference approximation for the second derivative, $u_{xx}$, at an interior node $x_i$ of a one-dimensional non-uniform grid. The stencil is restricted to the node itself and its immediate neighbors, $x_{i-1}$ and $x_{i+1}$. The approximation must be second-order accurate. Let the nodal spacing be non-uniform, denoted by $h_i = x_i - x_{i-1}$ and $h_{i+1} = x_{i+1} - x_i$.\n\nThe derivation proceeds from first principles using Taylor series expansions. We expand the function $u(x)$ around the point $x_i$. The values at the neighboring points, $u(x_{i-1})$ and $u(x_{i+1})$, are thus:\n$$\nu(x_{i-1}) = u(x_i - h_i) = u(x_i) - h_i u'(x_i) + \\frac{h_i^2}{2} u''(x_i) - \\frac{h_i^3}{6} u'''(x_i) + \\frac{h_i^4}{24} u^{(4)}(x_i) - \\dots\n$$\n$$\nu(x_{i+1}) = u(x_i + h_{i+1}) = u(x_i) + h_{i+1} u'(x_i) + \\frac{h_{i+1}^2}{2} u''(x_i) + \\frac{h_{i+1}^3}{6} u'''(x_i) + \\frac{h_{i+1}^4}{24} u^{(4)}(x_i) + \\dots\n$$\nFor conciseness, we adopt the notation $u_j = u(x_j)$, $u'_i = u'(x_i)$, and so on.\n\nWe seek a linear combination of the three nodal values, $D^{(2)}u_i = a u_{i-1} + b u_i + c u_{i+1}$, that approximates $u''(x_i)$. Substituting the Taylor series expansions into this form gives:\n$$\nD^{(2)}u_i = a\\left(u_i - h_i u'_i + \\frac{h_i^2}{2}u''_i - \\dots\\right) + b u_i + c\\left(u_i + h_{i+1}u'_i + \\frac{h_{i+1}^2}{2}u''_i + \\dots\\right)\n$$\nCollecting terms by the order of derivatives of $u$ at $x_i$:\n$$\nD^{(2)}u_i = (a+b+c)u_i + (-ah_i + ch_{i+1})u'_i + \\left(a\\frac{h_i^2}{2} + c\\frac{h_{i+1}^2}{2}\\right)u''_i + \\left(-a\\frac{h_i^3}{6} + c\\frac{h_{i+1}^3}{6}\\right)u'''_i + \\dots\n$$\nTo ensure that $D^{(2)}u_i$ is a consistent approximation of $u''_i$, we must match the coefficients of the derivatives to those of $u''_i$ (which are $0$ for $u_i$ and $u'_i$, and $1$ for $u''_i$). This yields a system of three linear equations for the three unknown coefficients $a, b, c$:\n$1.$ Coefficient of $u_i$: $a+b+c = 0$\n$2.$ Coefficient of $u'_i$: $-ah_i + ch_{i+1} = 0$\n$3.$ Coefficient of $u''_i$: $a\\frac{h_i^2}{2} + c\\frac{h_{i+1}^2}{2} = 1$\n\nFrom equation $(2)$, we find $c = a \\frac{h_i}{h_{i+1}}$. Substituting this into equation $(3)$:\n$$\na\\frac{h_i^2}{2} + \\left(a \\frac{h_i}{h_{i+1}}\\right)\\frac{h_{i+1}^2}{2} = 1 \\implies a\\left(\\frac{h_i^2}{2} + \\frac{h_i h_{i+1}}{2}\\right) = 1\n$$\nSolving for $a$ gives:\n$$\na = \\frac{2}{h_i^2 + h_i h_{i+1}} = \\frac{2}{h_i(h_i + h_{i+1})}\n$$\nThe coefficient $c$ is then:\n$$\nc = \\frac{2}{h_i(h_i + h_{i+1})} \\cdot \\frac{h_i}{h_{i+1}} = \\frac{2}{h_{i+1}(h_i + h_{i+1})}\n$$\nFinally, from equation $(1)$, we find $b$:\n$$\nb = -a - c = -\\frac{2}{h_i(h_i + h_{i+1})} - \\frac{2}{h_{i+1}(h_i + h_{i+1})} = -\\frac{2(h_{i+1} + h_i)}{h_i h_{i+1}(h_i + h_{i+1})} = -\\frac{2}{h_i h_{i+1}}\n$$\nThe resulting finite difference operator is:\n$$\nD^{(2)}u_i = \\frac{2}{h_i(h_i+h_{i+1})} u_{i-1} - \\frac{2}{h_i h_{i+1}} u_i + \\frac{2}{h_{i+1}(h_i+h_{i+1})} u_{i+1}\n$$\nThis can be rewritten in a more intuitive form, which represents a difference of first-derivative approximations:\n$$\nD^{(2)}u_i = \\frac{2}{h_i+h_{i+1}} \\left( \\frac{u_{i+1}-u_i}{h_{i+1}} - \\frac{u_i-u_{i-1}}{h_i} \\right)\n$$\nThe truncation error $\\tau_i$ is found by examining the next term in the Taylor series, which is the coefficient of $u'''_i$:\n$$\n\\tau_i = \\left(-a\\frac{h_i^3}{6} + c\\frac{h_{i+1}^3}{6}\\right)u'''_i + O(h^2) = \\left(-\\frac{2}{h_i(h_i+h_{i+1})}\\frac{h_i^3}{6} + \\frac{2}{h_{i+1}(h_i+h_{i+1})}\\frac{h_{i+1}^3}{6}\\right)u'''_i + \\dots\n$$\n$$\n\\tau_i = \\frac{1}{3(h_i+h_{i+1})} (-h_i^2 + h_{i+1}^2) u'''_i + \\dots = \\frac{h_{i+1}-h_i}{3}u'''_i + O(h^2)\n$$\nAt first glance, the leading error term is $O(h_{i+1}-h_i)$, which suggests the scheme is only first-order accurate on a general non-uniform grid. However, the problem specifies grid generation via a smooth mapping $x(\\xi)$ from a uniform computational grid $\\xi_i = i/(N+1)$. Let $\\Delta\\xi = 1/(N+1)$ be the uniform spacing in $\\xi$. The physical grid spacing is $h_i = x(\\xi_i) - x(\\xi_{i-1}) \\approx x'(\\xi_{i-1/2})\\Delta\\xi$. The difference in adjacent spacings is then:\n$$\nh_{i+1} - h_i \\approx (x'(\\xi_{i+1/2}) - x'(\\xi_{i-1/2}))\\Delta\\xi \\approx x''(\\xi_i)(\\Delta\\xi)^2\n$$\nSince $\\Delta\\xi$ is the characteristic grid size, $h_{i+1}-h_i$ is of order $(\\Delta\\xi)^2$. Consequently, the leading error term $\\frac{h_{i+1}-h_i}{3}u'''_i$ is second-order in $\\Delta\\xi$, and the scheme is indeed second-order accurate for grids generated by a sufficiently smooth transformation, as required.\n\nFor numerical verification, we compute the Root-Mean-Square (RMS) error. For each test case, we first generate the physical grid $\\{x_i\\}$ according to the specified rule. Then, we evaluate the function $u(x_i) = \\sin(k \\pi x_i)$ at all nodes. The exact second derivative, $u''(x_i) = -(k\\pi)^2 \\sin(k \\pi x_i)$, is evaluated at the $N$ interior nodes. The discrete operator $D^{(2)}$ is applied to the nodal values $\\{u_i\\}$ to obtain an approximation for the second derivative at the interior nodes. The RMS error is then calculated as:\n$$\nE_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left( D^{(2)}u(x_i) - u''(x_i) \\right)^2 }\n$$\nThe successful execution of this procedure for the specified test cases will validate both the derived formula and the analysis of its accuracy.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of deriving and testing a finite difference scheme\n    for the second derivative on non-uniform grids.\n    \"\"\"\n\n    test_cases = [\n        {'N': 80, 'grid_type': 'cosine', 'k': 1, 'p': None},\n        {'N': 80, 'grid_type': 'power', 'k': 2, 'p': 3.0},\n        {'N': 10, 'grid_type': 'uniform', 'k': 3, 'p': None},\n        {'N': 2, 'grid_type': 'power', 'k': 1, 'p': 2.0},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        grid_type = case['grid_type']\n        k = case['k']\n        p = case['p']\n\n        # Step 1: Generate the grid\n        num_points = N + 2\n        xi = np.linspace(0.0, 1.0, num_points)\n        \n        if grid_type == 'uniform':\n            x = xi\n        elif grid_type == 'cosine':\n            x = (1.0 - np.cos(np.pi * xi)) / 2.0\n        elif grid_type == 'power':\n            x = xi**p\n        else:\n            raise ValueError(\"Invalid grid type specified.\")\n\n        # Step 2: Evaluate the function and its exact second derivative\n        u_vals = np.sin(k * np.pi * x)\n        \n        # Exact second derivative at interior nodes\n        x_interior = x[1:-1]\n        u_xx_exact = -(k * np.pi)**2 * np.sin(k * np.pi * x_interior)\n\n        # Step 3: Apply the finite difference operator at interior nodes\n        u_xx_approx = np.zeros(N)\n        for i in range(1, N + 1):\n            h_left = x[i] - x[i-1]\n            h_right = x[i+1] - x[i]\n            \n            u_i_minus_1 = u_vals[i-1]\n            u_i = u_vals[i]\n            u_i_plus_1 = u_vals[i+1]\n            \n            # Derived finite difference formula for non-uniform grid\n            # D^2 u_i = 2/(h_i+h_{i+1}) * ( (u_{i+1}-u_i)/h_{i+1} - (u_i-u_{i-1})/h_i )\n            term1 = (u_i_plus_1 - u_i) / h_right\n            term2 = (u_i - u_i_minus_1) / h_left\n            \n            approx = (2.0 / (h_left + h_right)) * (term1 - term2)\n            u_xx_approx[i-1] = approx\n\n        # Step 4: Compute the RMS error\n        error = u_xx_approx - u_xx_exact\n        rms_error = np.sqrt(np.mean(error**2))\n        results.append(rms_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10e}' for r in results)}]\")\n\nsolve()\n```", "id": "2391620"}]}