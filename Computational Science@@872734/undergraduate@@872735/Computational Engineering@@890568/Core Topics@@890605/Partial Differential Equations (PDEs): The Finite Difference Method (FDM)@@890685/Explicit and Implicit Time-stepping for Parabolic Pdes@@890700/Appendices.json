{"hands_on_practices": [{"introduction": "The best way to understand a numerical method is to implement it. This first practice problem guides you through building a simulator for one-dimensional heat transfer using the Forward-Time Centered-Space (FTCS) explicit scheme. By discretizing the heat equation and writing a simple time-stepping loop, you will gain first-hand experience with the mechanics of an explicit solver and learn how to verify your code against an exact analytical solution. [@problem_id:2483476]", "problem": "You are to implement a numerical simulator for one-dimensional transient heat conduction using the explicit Forward Time Centered Space (FTCS) scheme. Begin from the conservation of energy and Fourier’s law of heat conduction, leading to the one-dimensional heat equation for a homogeneous rod with constant thermal diffusivity $\\alpha$, and homogeneous Dirichlet boundary conditions. The rod occupies $x \\in [0,L]$. The boundary temperatures are fixed at $T(0,t)=0$ and $T(L,t)=0$ for all $t \\ge 0$. The initial condition is a single-mode sinusoid $T(x,0) = T_{\\mathrm{amp}} \\sin\\!\\left(\\frac{\\pi x}{L}\\right)$.\n\nYour task is to:\n- Discretize the spatial domain with a uniform grid of $N$ nodes including both boundaries, with spacing $\\Delta x = L/(N-1)$, and discretize time using a constant time step $\\Delta t$. Use the FTCS explicit scheme to update interior nodes while enforcing the boundary conditions at every time step.\n- For each provided test case, choose $\\Delta t$ to satisfy a specified nondimensional ratio $r = \\alpha \\,\\Delta t/\\Delta x^2$. The values of $r$ and all other parameters are given in the test suite below. Assume that $\\Delta t$ is chosen so that $t_{\\mathrm{end}}/\\Delta t$ is an integer. Evolve the solution from $t=0$ to $t=t_{\\mathrm{end}}$.\n- At the specified node index $i_{\\star}$ (with zero-based indexing), compute the numerical temperature $T_{\\mathrm{num}}$ at time $t_{\\mathrm{end}}$ and the analytical temperature $T_{\\mathrm{ana}}$ for the same location and time, and return the absolute error $|T_{\\mathrm{num}} - T_{\\mathrm{ana}}|$ for each test case.\n\nFundamental base to use:\n- Conservation of energy for a differential control volume combined with Fourier’s law leads to the one-dimensional transient heat equation $\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}$ for a homogeneous medium with constant $\\alpha$.\n- The analytical solution for the given initial and boundary conditions is given by separation of variables as a single decaying mode $T(x,t) = T_{\\mathrm{amp}} \\sin\\!\\left(\\frac{\\pi x}{L}\\right) \\exp\\!\\left(-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t\\right)$.\n- The FTCS scheme is the explicit time-stepping method that uses a forward difference in time and a centered second-order difference in space.\n\nAssumptions and requirements:\n- Use zero-based indexing for nodes $i=0,1,\\dots,N-1$, with $x_i = i\\,\\Delta x$.\n- Initialize the numerical solution as $T_i^0 = T_{\\mathrm{amp}} \\sin\\!\\left(\\frac{\\pi x_i}{L}\\right)$ for all nodes, and enforce $T_0^n=0$ and $T_{N-1}^n=0$ for all time steps $n$.\n- For each test case, compute $\\Delta x$, then compute $\\Delta t$ from the given $r$ by $\\Delta t = r\\,\\Delta x^2/\\alpha$, and take exactly $n_{\\mathrm{steps}} = t_{\\mathrm{end}}/\\Delta t$ time steps.\n- Compute the absolute error at the specified node $i_{\\star}$ as a real number.\n\nPhysical units:\n- Express all temperatures in kelvin. The final reported errors must be expressed in kelvin. Times are in seconds, lengths in meters, and thermal diffusivity in $\\mathrm{m^2/s}$.\n\nTest suite:\n- Case $1$: $L=1\\,\\mathrm{m}$, $\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$, $T_{\\mathrm{amp}}=10\\,\\mathrm{K}$, $N=51$, $r=0.4$, $t_{\\mathrm{end}}=160\\,\\mathrm{s}$, $i_{\\star}=25$.\n- Case $2$: $L=1\\,\\mathrm{m}$, $\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$, $T_{\\mathrm{amp}}=10\\,\\mathrm{K}$, $N=41$, $r=0.5$, $t_{\\mathrm{end}}=31.25\\,\\mathrm{s}$, $i_{\\star}=20$.\n- Case $3$: $L=1\\,\\mathrm{m}$, $\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$, $T_{\\mathrm{amp}}=5\\,\\mathrm{K}$, $N=11$, $r=0.2$, $t_{\\mathrm{end}}=200\\,\\mathrm{s}$, $i_{\\star}=5$.\n- Case $4$: $L=1\\,\\mathrm{m}$, $\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$, $T_{\\mathrm{amp}}=10\\,\\mathrm{K}$, $N=101$, $r=0.1$, $t_{\\mathrm{end}}=10\\,\\mathrm{s}$, $i_{\\star}=0$.\n\nNumerical output specification:\n- For each case, compute the scalar absolute error $|T_{\\mathrm{num}} - T_{\\mathrm{ana}}|$ at $t=t_{\\mathrm{end}}$ and node $i_{\\star}$, in kelvin.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $4$ (for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$). Each entry must be a floating-point number representing kelvin.", "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n### Problem Validation\n\n#### Step 1: Extract Givens\n\nThe governing partial differential equation is the one-dimensional heat equation for a homogeneous medium with constant thermal diffusivity $\\alpha$:\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\nThe domain is a rod of length $L$ defined by $x \\in [0, L]$.\n\nBoundary Conditions (BCs): Homogeneous Dirichlet conditions.\n$$\nT(0, t) = 0 \\quad \\text{for all } t \\ge 0\n$$\n$$\nT(L, t) = 0 \\quad \\text{for all } t \\ge 0\n$$\n\nInitial Condition (IC): A single-mode sinusoid.\n$$\nT(x, 0) = T_{\\mathrm{amp}} \\sin\\left(\\frac{\\pi x}{L}\\right)\n$$\n\nAnalytical Solution:\n$$\nT(x, t) = T_{\\mathrm{amp}} \\sin\\left(\\frac{\\pi x}{L}\\right) \\exp\\left(-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t\\right)\n$$\n\nNumerical Scheme: Explicit Forward Time Centered Space (FTCS).\n-   Spatial discretization: Uniform grid with $N$ nodes, spacing $\\Delta x = L/(N-1)$.\n-   Node indexing: $i = 0, 1, \\dots, N-1$, with $x_i = i\\,\\Delta x$.\n-   Time discretization: Constant time step $\\Delta t$.\n-   Nondimensional ratio: $r = \\alpha \\,\\Delta t/\\Delta x^2$.\n-   Time evolution: From $t=0$ to $t=t_{\\mathrm{end}}$. The number of steps $t_{\\mathrm{end}}/\\Delta t$ is an integer.\n-   Initial numerical solution: $T_i^0 = T_{\\mathrm{amp}} \\sin\\left(\\frac{\\pi x_i}{L}\\right)$.\n-   Task: At time $t_{\\mathrm{end}}$, compute the numerical temperature $T_{\\mathrm{num}}$ and analytical temperature $T_{\\mathrm{ana}}$ at node index $i_{\\star}$, and return the absolute error $|T_{\\mathrm{num}} - T_{\\mathrm{ana}}|$.\n\nTest Suite Parameters:\n-   Case $1$: $L=1\\,\\mathrm{m}$, $\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$, $T_{\\mathrm{amp}}=10\\,\\mathrm{K}$, $N=51$, $r=0.4$, $t_{\\mathrm{end}}=160\\,\\mathrm{s}$, $i_{\\star}=25$.\n-   Case $2$: $L=1\\,\\mathrm{m}$, $\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$, $T_{\\mathrm{amp}}=10\\,\\mathrm{K}$, $N=41$, $r=0.5$, $t_{\\mathrm{end}}=31.25\\,\\mathrm{s}$, $i_{\\star}=20$.\n-   Case $3$: $L=1\\,\\mathrm{m}$, $\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$, $T_{\\mathrm{amp}}=5\\,\\mathrm{K}$, $N=11$, $r=0.2$, $t_{\\mathrm{end}}=200\\,\\mathrm{s}$, $i_{\\star}=5$.\n-   Case $4$: $L=1\\,\\mathrm{m}$, $\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$, $T_{\\mathrm{amp}}=10\\,\\mathrm{K}$, $N=101$, $r=0.1$, $t_{\\mathrm{end}}=10\\,\\mathrm{s}$, $i_{\\star}=0$.\n\n#### Step 2: Validate Using Extracted Givens\n\n1.  **Scientifically Grounded**: The problem is based on the authoritative one-dimensional heat equation, a fundamental principle derived from conservation of energy and Fourier's law of conduction. The FTCS method is a standard, well-documented finite difference scheme for parabolic partial differential equations. The analytical solution provided is the correct solution for the given initial and boundary conditions. The problem is scientifically and mathematically sound.\n\n2.  **Well-Posed**: The problem is a well-posed initial-boundary value problem for a parabolic PDE. The stability of the FTCS scheme for the one-dimensional heat equation is governed by the Courant–Friedrichs–Lewy (CFL) condition, which requires the non-dimensional parameter $r = \\alpha \\,\\Delta t/\\Delta x^2$ to satisfy $r \\le 0.5$.\n    -   Case $1$: $r = 0.4 \\le 0.5$. Stable.\n    -   Case $2$: $r = 0.5 \\le 0.5$. Marginally stable, which is a valid condition.\n    -   Case $3$: $r = 0.2 \\le 0.5$. Stable.\n    -   Case $4$: $r = 0.1 \\le 0.5$. Stable.\n    All test cases adhere to the stability criterion, ensuring a meaningful numerical solution.\n\n3.  **Objective**: The problem is stated with unambiguous, objective language, and all parameters are defined with precise numerical values. There are no subjective or opinion-based statements.\n\n4.  **Completeness and Consistency**: The problem provides all necessary information: the governing equation, initial and boundary conditions, discretization method, all physical and numerical parameters for each test case, and a clear definition of the required output. The parameters are self-consistent. For example, in Case $4$, the evaluation node is $i_{\\star}=0$. The boundary condition fixes $T(0,t)=0$, and the analytical solution also yields $T(0,t)=0$. Thus, the expected absolute error is $0$, which is a valid test of boundary condition implementation.\n\n#### Step 3: Verdict and Action\n\nThe problem is **valid**. It is scientifically sound, well-posed, complete, and devoid of ambiguity. A solution will be furnished.\n\n### Solution Derivation and Algorithm\n\nThe governing equation is the one-dimensional heat equation:\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\nWe discretize this equation on a grid where $T_i^n$ denotes the temperature at spatial node $i$ and time step $n$. The spatial coordinates are $x_i = i\\Delta x$ for $i=0, 1, \\dots, N-1$, and time is $t_n = n\\Delta t$.\n\nThe FTCS scheme employs a forward difference for the time derivative and a second-order central difference for the spatial derivative:\n$$\n\\frac{\\partial T}{\\partial t}\\bigg|_{(x_i, t_n)} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t}\n$$\n$$\n\\frac{\\partial^2 T}{\\partial x^2}\\bigg|_{(x_i, t_n)} \\approx \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{\\Delta x^2}\n$$\n\nSubstituting these approximations into the heat equation yields:\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{\\Delta x^2}\n$$\n\nSolving for the temperature at the next time step, $T_i^{n+1}$, gives the explicit update rule:\n$$\nT_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{\\Delta x^2} \\left( T_{i+1}^n - 2T_i^n + T_{i-1}^n \\right)\n$$\n\nIntroducing the non-dimensional diffusion number, $r = \\frac{\\alpha \\Delta t}{\\Delta x^2}$, simplifies the expression:\n$$\nT_i^{n+1} = T_i^n + r \\left( T_{i+1}^n - 2T_i^n + T_{i-1}^n \\right)\n$$\nThis can be rearranged for computational efficiency:\n$$\nT_i^{n+1} = r T_{i-1}^n + (1 - 2r) T_i^n + r T_{i+1}^n\n$$\nThis update rule is applied to all interior nodes, i.e., for $i = 1, 2, \\dots, N-2$. The boundary nodes $i=0$ and $i=N-1$ are held fixed at $0\\,\\mathrm{K}$ for all time steps, as per the Dirichlet boundary conditions.\n\nThe algorithm for each test case is as follows:\n1.  Define the physical and numerical parameters from the test case: $L$, $\\alpha$, $T_{\\mathrm{amp}}$, $N$, $r$, $t_{\\mathrm{end}}$, and $i_{\\star}$.\n2.  Calculate the grid spacing $\\Delta x = L / (N - 1)$ and the time step $\\Delta t = r \\cdot \\Delta x^2 / \\alpha$.\n3.  Calculate the total number of time steps required to reach $t_{\\mathrm{end}}$, which is $n_{\\mathrm{steps}} = \\text{round}(t_{\\mathrm{end}} / \\Delta t)$. The problem statement guarantees this is an integer.\n4.  Create a spatial grid $x_i = i \\Delta x$ for $i=0, \\dots, N-1$.\n5.  Initialize the temperature array $T$ at time $t=0$ using the initial condition: $T_i = T_{\\mathrm{amp}} \\sin(\\pi x_i / L)$ for all $i$.\n6.  Begin the time-stepping loop from $n=0$ to $n_{\\mathrm{steps}}-1$:\n    a. Create a new array, $T_{\\text{new}}$, to store the temperatures at the next time step, $n+1$.\n    b. For each interior node $i$ from $1$ to $N-2$, calculate $T_{\\text{new},i}$ using the FTCS update rule: $T_{\\text{new},i} = r T_{i-1} + (1-2r) T_i + r T_{i+1}$.\n    c. Enforce the boundary conditions: $T_{\\text{new},0} = 0$ and $T_{\\text{new},N-1} = 0$.\n    d. Update the current temperature array for the next iteration: $T \\leftarrow T_{\\text{new}}$.\n7.  After the loop completes, the array $T$ contains the numerical solution at $t = t_{\\mathrm{end}}$. The numerical temperature at the specified node is $T_{\\mathrm{num}} = T_{i_{\\star}}$.\n8.  Calculate the analytical solution at the same position and time. The position is $x_{\\star} = i_{\\star} \\Delta x$.\n    $$\n    T_{\\mathrm{ana}} = T_{\\mathrm{amp}} \\sin\\left(\\frac{\\pi x_{\\star}}{L}\\right) \\exp\\left(-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t_{\\mathrm{end}}\\right)\n    $$\n9.  Compute and record the absolute error, $|T_{\\mathrm{num}} - T_{\\mathrm{ana}}|$.\n\nThis procedure is repeated for all four test cases to generate the final results.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 1D transient heat conduction simulator using the FTCS scheme\n    and computes the error against the analytical solution for given test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'L': 1.0, 'alpha': 1.0e-4, 'T_amp': 10.0, 'N': 51, 'r': 0.4, 't_end': 160.0, 'i_star': 25},\n        # Case 2\n        {'L': 1.0, 'alpha': 1.0e-4, 'T_amp': 10.0, 'N': 41, 'r': 0.5, 't_end': 31.25, 'i_star': 20},\n        # Case 3\n        {'L': 1.0, 'alpha': 1.0e-4, 'T_amp': 5.0, 'N': 11, 'r': 0.2, 't_end': 200.0, 'i_star': 5},\n        # Case 4\n        {'L': 1.0, 'alpha': 1.0e-4, 'T_amp': 10.0, 'N': 101, 'r': 0.1, 't_end': 10.0, 'i_star': 0},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters\n        L = case['L']\n        alpha = case['alpha']\n        T_amp = case['T_amp']\n        N = case['N']\n        r = case['r']\n        t_end = case['t_end']\n        i_star = case['i_star']\n\n        # Discretization parameters\n        dx = L / (N - 1)\n        dt = r * dx**2 / alpha\n        \n        # Ensure n_steps is an integer as per problem statement\n        n_steps = int(round(t_end / dt))\n\n        # Spatial grid\n        x = np.linspace(0, L, N)\n\n        # Initialize temperature array based on the initial condition\n        T = T_amp * np.sin(np.pi * x / L)\n\n        # Time-stepping loop\n        for _ in range(n_steps):\n            # Store the current temperature profile\n            T_old = T.copy()\n            # Update interior nodes using the FTCS formula\n            for i in range(1, N - 1):\n                T[i] = T_old[i] + r * (T_old[i+1] - 2*T_old[i] + T_old[i-1])\n            # The boundary conditions T[0]=0 and T[N-1]=0 are enforced implicitly\n            # by the loop range and because the initial values at boundaries\n            # are already 0 from the sin function. A more robust implementation\n            # would explicitly set them after each update.\n            T[0] = 0.0\n            T[N-1] = 0.0\n\n        # Numerical solution at the specified node and time\n        T_num = T[i_star]\n\n        # Analytical solution at the same position and time\n        x_star = i_star * dx\n        decay_term = -alpha * (np.pi / L)**2 * t_end\n        T_ana = T_amp * np.sin(np.pi * x_star / L) * np.exp(decay_term)\n\n        # Compute the absolute error\n        error = abs(T_num - T_ana)\n        results.append(error)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2483476"}, {"introduction": "Explicit methods are simple, but their Achilles' heel is the stringent stability condition. This exercise explores a \"stiff\" problem involving heat transfer between two materials with vastly different thermal properties. You will analyze how the faster-diffusing material dictates a very small time step for the entire system, leading to prohibitive computational costs and illustrating a key motivation for using implicit schemes. [@problem_id:2390373]", "problem": "Consider one-dimensional heat conduction in a composite rod occupying the interval $[0,L]$, with a material interface at $x=L/2$. Let $T(x,t)$ denote temperature. The governing equation is the linear heat equation with piecewise constant thermal diffusivity $\\alpha(x)$,\n$$\n\\frac{\\partial T}{\\partial t}(x,t) = \\alpha(x)\\,\\frac{\\partial^2 T}{\\partial x^2}(x,t),\\quad x\\in(0,L),\\ t>0,\n$$\nsubject to homogeneous Dirichlet boundary conditions $T(0,t)=0$ and $T(L,t)=0$ for all $t\\ge 0$, and an arbitrary initial condition $T(x,0)=T_0(x)$ that is bounded and compatible with the boundary conditions. The thermal diffusivity is piecewise constant with\n$$\n\\alpha(x)=\\begin{cases}\n\\alpha_1,& 0\\le x < L/2,\\\\\n\\alpha_2,& L/2 \\le x \\le L,\n\\end{cases}\n$$\nand the two materials satisfy a contrast ratio of $1000\\times$ in thermal conductivity while having the same volumetric heat capacity; model this by taking $\\alpha_2 = 1000\\,\\alpha_1$.\n\nDiscretize space using a uniform grid of $N$ points including the endpoints, with spacing $h=L/(N-1)$. Let $M=N-2$ denote the number of interior points. Consider two time discretizations:\n- An explicit forward Euler method applied to the semi-discrete system formed by the second-order centered finite-difference approximation of $\\partial^2 T/\\partial x^2$ on the uniform grid.\n- An implicit backward Euler method applied to the same spatial discretization, leading at each time step to the solution of a symmetric tridiagonal linear system of size $M\\times M$.\n\nFor the explicit method, use the largest time step that guarantees linear stability for the discretization on this uniform grid. For a conservative estimate in the presence of spatially varying $\\alpha(x)$ with piecewise constant values, take\n$$\n\\Delta t_{\\mathrm{exp},\\max} = \\frac{h^2}{2\\,\\max(\\alpha_1,\\alpha_2)}.\n$$\nFor the implicit method, assume unconditional linear stability, and define the computational cost per time step as the number of floating-point additions and multiplications needed to solve the tridiagonal linear system by an optimal direct method. Use the following operation-count model:\n- For the explicit update, count exactly $6$ floating-point operations per interior grid point per time step, so that one explicit step costs $6\\,M$ operations. Neglect all one-time precomputations.\n- For the implicit step, count exactly $8$ floating-point operations per interior grid point per step to solve the tridiagonal system, so that one implicit step costs $8\\,M$ operations. Neglect assembly and any other overhead.\n\nGiven a final simulation time $T_{\\mathrm{final}}$, define the following quantities to be computed for each parameter set:\n1. The maximum stable explicit time step in seconds, $\\Delta t_{\\mathrm{exp},\\max}$, as defined above.\n2. The minimum number of explicit time steps needed to reach $T_{\\mathrm{final}}$ using $\\Delta t_{\\mathrm{exp},\\max}$, namely $N_{\\mathrm{exp}}=\\lceil T_{\\mathrm{final}}/\\Delta t_{\\mathrm{exp},\\max}\\rceil$.\n3. The total explicit cost to reach $T_{\\mathrm{final}}$ using $\\Delta t_{\\mathrm{exp},\\max}$, namely $C_{\\mathrm{exp}}=6\\,M\\,N_{\\mathrm{exp}}$.\n4. The implicit cost per time step, $C_{\\mathrm{imp,step}}=8\\,M$.\n5. The total implicit cost to reach $T_{\\mathrm{final}}$ if the same number of steps as the explicit method is used, $C_{\\mathrm{imp,same}}=8\\,M\\,N_{\\mathrm{exp}}$.\n6. The minimal implicit total cost if the entire interval $[0,T_{\\mathrm{final}}]$ is advanced in a single step, $C_{\\mathrm{imp,min}}=8\\,M$.\n\nAll physical units must be interpreted as follows: length in meters, time in seconds, thermal diffusivity in $\\mathrm{m}^2/\\mathrm{s}$. All costs are pure counts of floating-point additions or multiplications and are unitless integers. All angle quantities are irrelevant to this problem. Any ratio must be reported as a decimal number.\n\nTest Suite. Use the following three parameter sets, each specified as $(L,N,\\alpha_1,\\alpha_2,T_{\\mathrm{final}})$:\n- Test $1$ (two-material contrast case): $(L,N,\\alpha_1,\\alpha_2,T_{\\mathrm{final}}) = (1.0,\\ 1001,\\ 10^{-6},\\ 10^{-3},\\ 0.5)$.\n- Test $2$ (uniform low-diffusivity case): $(L,N,\\alpha_1,\\alpha_2,T_{\\mathrm{final}}) = (1.0,\\ 201,\\ 10^{-6},\\ 10^{-6},\\ 0.1)$.\n- Test $3$ (fine grid with high contrast): $(L,N,\\alpha_1,\\alpha_2,T_{\\mathrm{final}}) = (0.2,\\ 2001,\\ 10^{-5},\\ 10^{-2},\\ 0.01)$.\n\nRequired final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output the list $[\\Delta t_{\\mathrm{exp},\\max}, N_{\\mathrm{exp}}, C_{\\mathrm{exp}}, C_{\\mathrm{imp,step}}, C_{\\mathrm{imp,same}}, C_{\\mathrm{imp,min}}]$ in that order. Aggregate the three test-case lists into a single list, without any spaces, for example, $[[\\cdot],[\\cdot],[\\cdot]]$. All time-step values must be in seconds, and all costs and counts must be integers. No other text should be printed.", "solution": "The problem statement has been subjected to rigorous validation and is determined to be valid. It is a well-posed computational exercise in the numerical analysis of partial differential equations, grounded in established scientific and mathematical principles. All necessary parameters and definitions are provided, and the task is free from ambiguity, contradiction, or factual unsoundness. We may therefore proceed with the solution.\n\nThe problem requires the calculation of several quantities related to the computational cost and stability of explicit and implicit time-stepping schemes for the one-dimensional heat equation with piecewise constant thermal diffusivity. The governing equation is given by\n$$\n\\frac{\\partial T}{\\partial t}(x,t) = \\alpha(x)\\,\\frac{\\partial^2 T}{\\partial x^2}(x,t)\n$$\non a spatial domain $x \\in [0,L]$ with homogeneous Dirichlet boundary conditions. The thermal diffusivity $\\alpha(x)$ is piecewise constant.\n\nThe solution methodology involves a direct application of the formulas provided for each test case, which are specified by the tuple $(L, N, \\alpha_1, \\alpha_2, T_{\\mathrm{final}})$. The computational steps are as follows:\n\n1.  **Discretization Parameters**: The spatial domain of length $L$ is discretized using a uniform grid of $N$ points. The grid spacing, $h$, is the distance between adjacent points and is calculated as $h = L / (N-1)$. The number of interior grid points, $M$, subject to the homogeneous Dirichlet boundary conditions, is $M = N-2$.\n\n2.  **Maximum Explicit Time Step ($\\Delta t_{\\mathrm{exp},\\max}$)**: The forward Euler scheme applied to the centered finite-difference spatial discretization of the heat equation is only conditionally stable. The stability is governed by the Courant-Friedrichs-Lewy (CFL) condition. For the 1D heat equation, this condition is $\\alpha \\Delta t / h^2 \\le 1/2$. In the presence of spatially varying diffusivity, a conservative stability criterion uses the maximum diffusivity value over the domain. Thus, the maximum stable time step is given by the formula:\n    $$\n    \\Delta t_{\\mathrm{exp},\\max} = \\frac{h^2}{2\\,\\max(\\alpha_1, \\alpha_2)}\n    $$\n    This value represents the largest time step for which the explicit numerical solution is guaranteed not to exhibit unbounded growth.\n\n3.  **Number of Explicit Steps ($N_{\\mathrm{exp}}$)**: To simulate up to a final time $T_{\\mathrm{final}}$ using the maximum stable time step, the required number of steps, $N_{\\mathrm{exp}}$, is determined by dividing the total simulation time by the step size and taking the ceiling of the result. This ensures the simulation time reaches or exceeds $T_{\\mathrm{final}}$.\n    $$\n    N_{\\mathrm{exp}} = \\left\\lceil \\frac{T_{\\mathrm{final}}}{\\Delta t_{\\mathrm{exp},\\max}} \\right\\rceil\n    $$\n\n4.  **Total Explicit Cost ($C_{\\mathrm{exp}}$)**: The computational cost is modeled as a count of floating-point operations. Given a cost of $6M$ operations per time step for the explicit method, the total cost to reach $T_{\\mathrm{final}}$ is the product of the per-step cost and the number of steps:\n    $$\n    C_{\\mathrm{exp}} = 6 \\cdot M \\cdot N_{\\mathrm{exp}}\n    $$\n\n5.  **Implicit Method Costs**: The backward Euler method is unconditionally stable, meaning the time step size is not constrained by stability but rather by accuracy considerations.\n    - The cost per step, $C_{\\mathrm{imp,step}}$, is given as $8M$. This reflects the cost of solving the $M \\times M$ symmetric tridiagonal linear system that arises at each implicit step, for instance, using the Thomas algorithm.\n      $$\n      C_{\\mathrm{imp,step}} = 8 \\cdot M\n      $$\n    - To provide a direct comparison with the explicit method, the total cost of the implicit method using the *same number of steps* as the explicit method, $N_{\\mathrm{exp}}$, is calculated as:\n      $$\n      C_{\\mathrm{imp,same}} = 8 \\cdot M \\cdot N_{\\mathrm{exp}}\n      $$\n    - The theoretical minimal cost for the implicit method, $C_{\\mathrm{imp,min}}$, corresponds to advancing the solution from $t=0$ to $t=T_{\\mathrm{final}}$ in a single time step. While this would yield a solution with very large temporal error, it represents the lower bound on computational cost.\n      $$\n      C_{\\mathrm{imp,min}} = 8 \\cdot M\n      $$\n\nThese calculations are performed for each of the three test cases provided in the problem statement. The results are then aggregated and formatted precisely as required.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational engineering problem for three test cases,\n    calculating stability and cost metrics for explicit and implicit schemes\n    for the 1D heat equation.\n    \"\"\"\n    # Test cases defined as (L, N, alpha1, alpha2, T_final)\n    test_cases = [\n        (1.0, 1001, 1e-6, 1e-3, 0.5),\n        (1.0, 201, 1e-6, 1e-6, 0.1),\n        (0.2, 2001, 1e-5, 1e-2, 0.01)\n    ]\n\n    all_results_str = []\n\n    for case in test_cases:\n        L, N, alpha1, alpha2, T_final = case\n\n        # Step 1: Calculate discretization parameters\n        h = L / (N - 1)\n        M = N - 2\n\n        # Step 2: Calculate maximum stable explicit time step\n        max_alpha = max(alpha1, alpha2)\n        dt_exp_max = h**2 / (2 * max_alpha)\n\n        # Step 3: Calculate the minimum number of explicit steps\n        # The result must be an integer. np.ceil returns a float.\n        N_exp = int(np.ceil(T_final / dt_exp_max))\n\n        # Step 4: Calculate total explicit cost\n        C_exp = 6 * M * N_exp\n\n        # Step 5: Calculate implicit method costs\n        C_imp_step = 8 * M\n        C_imp_same = 8 * M * N_exp\n        C_imp_min = 8 * M\n\n        # Assemble the list of results for the current test case\n        case_results = [\n            dt_exp_max,\n            N_exp,\n            C_exp,\n            C_imp_step,\n            C_imp_same,\n            C_imp_min\n        ]\n\n        # Format the list into a string representation with no spaces\n        case_str = f\"[{','.join(map(str, case_results))}]\"\n        all_results_str.append(case_str)\n\n    # Aggregate the string representations of each test case's results\n    # into a final string representing a list of lists, with no spaces.\n    final_output_str = f\"[{','.join(all_results_str)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2390373"}, {"introduction": "The choice between explicit and implicit methods becomes even more complex when considering modern high-performance computing hardware. This final practice moves to a large-scale 2D problem and asks you to model and compare the performance of a GPU-parallelized explicit solver against a CPU-based implicit solver. By analyzing these trade-offs, you will appreciate how algorithm design and hardware architecture are deeply intertwined in real-world computational engineering. [@problem_id:2390421]", "problem": "Consider the two-dimensional heat equation, a canonical parabolic partial differential equation (PDE), on a rectangular domain with homogeneous Dirichlet boundary conditions. Let the domain be $[0,L_x]\\times[0,L_y]$, thermal diffusivity be $\\alpha$ in $\\mathrm{m}^2/\\mathrm{s}$, and the final physical time be $T$ in $\\mathrm{s}$. The field $u(x,y,t)$ satisfies $u_t=\\alpha(u_{xx}+u_{yy})$ with $u=0$ on the boundary for all $t\\in[0,T]$. Discretize the interior using a uniform tensor-product grid with $N_x$ and $N_y$ interior points in the $x$- and $y$-directions, respectively, and second-order central differences for spatial derivatives. The resulting semi-discrete system is advanced in time either by an explicit forward Euler method or by an implicit backward Euler method. You must construct a principled performance model that predicts total wall-clock time for both approaches under specified hardware assumptions, and then compare them.\n\nFundamental base and modeling assumptions:\n- For the explicit forward Euler scheme, the Courant–Friedrichs–Lewy (CFL) stability condition for the five-point stencil applied on a uniform grid with spacings $h_x=L_x/(N_x+1)$ and $h_y=L_y/(N_y+1)$ is\n$$\n\\Delta t_{\\text{CFL}} \\le \\frac{1}{2\\,\\alpha\\left(\\frac{1}{h_x^2}+\\frac{1}{h_y^2}\\right)}.\n$$\nIn practice, use a conservative fraction $\\theta\\in(0,1)$ of this bound: $\\Delta t_{\\text{exp}}=\\theta\\,\\Delta t_{\\text{CFL}}$, and $n_{\\text{exp}}=\\left\\lceil T/\\Delta t_{\\text{exp}}\\right\\rceil$ explicit steps.\n- For the implicit backward Euler scheme, unconditional stability allows larger time steps, but accuracy still constrains the step size. To parameterize acceptable accuracy, assume $\\Delta t_{\\text{imp}} = m\\,\\Delta t_{\\text{exp}}$ for a given multiplier $m\\ge 1$ that is supplied, and $n_{\\text{imp}}=\\left\\lceil T/\\Delta t_{\\text{imp}}\\right\\rceil$ implicit steps. The linear system matrix does not change over time if the time step is fixed, and its factorization can be reused across time steps.\n- For Graphics Processing Unit (GPU) performance of the explicit method, use a roofline model. Assume double precision with a word size of $b=8$ bytes. Model the per-cell, per-step floating-point operation count as $c_{\\text{exp,flop}}$ flops and the per-cell, per-step memory traffic as $c_{\\text{exp,bytes}}$ bytes. With GPU peak floating-point throughput $F_{\\text{GPU}}$ in flops/s and GPU sustainable memory bandwidth $B_{\\text{GPU}}$ in bytes/s, the per-step time is\n$$\nt_{\\text{exp,step}}=\\max\\left(\\frac{N\\,c_{\\text{exp,flop}}}{F_{\\text{GPU}}},\\;\\frac{N\\,c_{\\text{exp,bytes}}}{B_{\\text{GPU}}}\\right),\n$$\nwhere $N=N_x N_y$ is the number of interior unknowns. The total explicit time is $t_{\\text{exp}}=n_{\\text{exp}}\\,t_{\\text{exp,step}}$.\n- For Central Processing Unit (CPU) performance of the implicit method using a sparse direct solver based on Lower–Upper (LU) factorization with a fill-reducing ordering, assume for a two-dimensional five-point stencil on an $N_x\\times N_y$ grid the following well-tested complexity scalings: a one-time factorization cost of\n$$\n\\text{flops}_{\\text{fac}} = C_{\\text{fac}}\\,N^{3/2},\n$$\nand a per right-hand side triangular solve cost of\n$$\n\\text{flops}_{\\text{solve}} = C_{\\text{solve}}\\,N\\,\\log_2 N.\n$$\nWith CPU peak floating-point throughput $F_{\\text{CPU}}$ in flops/s, the total implicit time is\n$$\nt_{\\text{imp}}=\\frac{\\text{flops}_{\\text{fac}}}{F_{\\text{CPU}}}+n_{\\text{imp}}\\,\\frac{\\text{flops}_{\\text{solve}}}{F_{\\text{CPU}}}.\n$$\n\nUse the following fixed modeling constants for all cases to avoid ambiguity in low-level kernel details:\n- $c_{\\text{exp,flop}}=13$,\n- $c_{\\text{exp,bytes}}=6\\,b=48$ bytes,\n- $C_{\\text{fac}}=30$,\n- $C_{\\text{solve}}=10$.\n\nYour task:\n- Implement a program that, for each test case specified below, computes $t_{\\text{exp}}$ and $t_{\\text{imp}}$ in seconds, then outputs the ratio $r=t_{\\text{exp}}/t_{\\text{imp}}$ as a floating-point number. A ratio $r<1$ indicates the GPU-parallelized explicit method is faster; a ratio $r>1$ indicates the CPU-based implicit method is faster.\n- The program must hard-code the test suite, perform all computations using the formulas above, and produce a single line of output containing the list of ratios in the exact order of the test cases.\n- Express all times internally in seconds; the output ratios are dimensionless. Round each ratio to $6$ decimal places in the final output.\n\nTest suite (each bullet is a complete parameter set):\n- Case A (large grid, moderate diffusivity, memory-bound GPU expected): $N_x=2048$, $N_y=2048$, $L_x=1$, $L_y=1$, $\\alpha=1\\times 10^{-4}$, $T=1$, $\\theta=0.9$, $m=10$, $F_{\\text{GPU}}=1\\times 10^{12}$, $B_{\\text{GPU}}=6\\times 10^{11}$, $F_{\\text{CPU}}=2\\times 10^{11}$.\n- Case B (very large grid, higher diffusivity, implicit advantage expected): $N_x=4096$, $N_y=4096$, $L_x=1$, $L_y=1$, $\\alpha=5\\times 10^{-4}$, $T=0.5$, $\\theta=0.9$, $m=100$, $F_{\\text{GPU}}=1\\times 10^{12}$, $B_{\\text{GPU}}=6\\times 10^{11}$, $F_{\\text{CPU}}=2\\times 10^{11}$.\n- Case C (small grid, factorization overhead dominates implicit): $N_x=128$, $N_y=128$, $L_x=1$, $L_y=1$, $\\alpha=1\\times 10^{-4}$, $T=0.1$, $\\theta=0.9$, $m=50$, $F_{\\text{GPU}}=5\\times 10^{11}$, $B_{\\text{GPU}}=2\\times 10^{11}$, $F_{\\text{CPU}}=2\\times 10^{11}$.\n- Case D (compute-bound GPU configuration): $N_x=1024$, $N_y=1024$, $L_x=1$, $L_y=1$, $\\alpha=2\\times 10^{-4}$, $T=0.2$, $\\theta=0.9$, $m=20$, $F_{\\text{GPU}}=8\\times 10^{10}$, $B_{\\text{GPU}}=6\\times 10^{11}$, $F_{\\text{CPU}}=1.5\\times 10^{11}$.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, `[0.123456,1.234567,0.000100,9.876543]`, corresponding to Cases A, B, C, and D in that order.", "solution": "The problem requires the construction and evaluation of a performance model to compare two distinct numerical approaches for solving the two-dimensional heat equation, $u_t = \\alpha(u_{xx} + u_{yy})$, on a rectangular domain $\\Omega = [0, L_x] \\times [0, L_y]$. The first approach is an explicit forward Euler time integration scheme, parallelized on a Graphics Processing Unit (GPU). The second is an implicit backward Euler scheme, solved using a sparse direct solver on a Central Processing Unit (CPU). The total wall-clock time for each method, denoted $t_{\\text{exp}}$ and $t_{\\text{imp}}$ respectively, will be calculated and their ratio $r = t_{\\text{exp}}/t_{\\text{imp}}$ determined for several test cases. All mathematical entities, including numerical values, are rendered in LaTeX as required.\n\nThe spatial domain is discretized using a uniform grid with $N_x$ and $N_y$ interior points in the respective dimensions. The total number of unknowns is $N = N_x N_y$. The grid spacings are $h_x = L_x / (N_x + 1)$ and $h_y = L_y / (N_y + 1)$.\n\nFirst, we analyze the explicit method. The forward Euler scheme is subject to a strict stability constraint. For the five-point finite difference stencil, this Courant–Friedrichs–Lewy (CFL) condition dictates the maximum permissible time step:\n$$\n\\Delta t_{\\text{CFL}} \\le \\frac{1}{2\\,\\alpha\\left(\\frac{1}{h_x^2}+\\frac{1}{h_y^2}\\right)}\n$$\nA conservative time step $\\Delta t_{\\text{exp}} = \\theta\\,\\Delta t_{\\text{CFL}}$ is used, where $\\theta \\in (0,1)$ is a safety factor. To reach the final time $T$, the number of steps required is $n_{\\text{exp}} = \\lceil T/\\Delta t_{\\text{exp}}\\rceil$.\nThe performance of the GPU implementation is governed by a roofline model. The time per step, $t_{\\text{exp,step}}$, is the maximum of the time limited by computation and the time limited by memory bandwidth.\n$$\nt_{\\text{exp,step}} = \\max\\left(t_{\\text{comp}}, t_{\\text{mem}}\\right) = \\max\\left(\\frac{N\\,c_{\\text{exp,flop}}}{F_{\\text{GPU}}}, \\frac{N\\,c_{\\text{exp,bytes}}}{B_{\\text{GPU}}}\\right)\n$$\nHere, $c_{\\text{exp,flop}} = 13$ is the number of floating-point operations per grid point per step, and $c_{\\text{exp,bytes}} = 48$ is the number of bytes transferred per grid point per step. $F_{\\text{GPU}}$ is the peak floating-point throughput and $B_{\\text{GPU}}$ is the sustainable memory bandwidth of the GPU. The total time for the explicit method is the product of the number of steps and the time per step:\n$$\nt_{\\text{exp}} = n_{\\text{exp}} \\cdot t_{\\text{exp,step}}\n$$\n\nNext, we analyze the implicit method. The backward Euler scheme is unconditionally stable, allowing for a larger time step. This time step is parameterized relative to the explicit one: $\\Delta t_{\\text{imp}} = m\\,\\Delta t_{\\text{exp}}$, where $m \\ge 1$. The number of steps is $n_{\\text{imp}} = \\lceil T/\\Delta t_{\\text{imp}}\\rceil$. Each time step requires solving a large, sparse linear system. A sparse direct solver performs a one-time LU factorization of the system matrix followed by a triangular solve for each time step. The computational costs are given by:\n$$\n\\text{flops}_{\\text{fac}} = C_{\\text{fac}}\\,N^{3/2} \\quad \\text{and} \\quad \\text{flops}_{\\text{solve}} = C_{\\text{solve}}\\,N\\,\\log_2 N\n$$\nwith constants $C_{\\text{fac}} = 30$ and $C_{\\text{solve}} = 10$. The total time for the implicit method on a CPU with peak throughput $F_{\\text{CPU}}$ is the sum of the factorization time and the total time for all solves:\n$$\nt_{\\text{imp}} = \\frac{\\text{flops}_{\\text{fac}}}{F_{\\text{CPU}}} + n_{\\text{imp}}\\,\\frac{\\text{flops}_{\\text{solve}}}{F_{\\text{CPU}}}\n$$\n\nWith the models for $t_{\\text{exp}}$ and $t_{\\text{imp}}$ established, we proceed to evaluate the four specified test cases.\n\n**Case A:** $N_x=2048$, $N_y=2048$, $L_x=1$, $L_y=1$, $\\alpha=1 \\times 10^{-4}$, $T=1$, $\\theta=0.9$, $m=10$, $F_{\\text{GPU}}=1 \\times 10^{12}$, $B_{\\text{GPU}}=6 \\times 10^{11}$, $F_{\\text{CPU}}=2 \\times 10^{11}$.\n- Grid: $N = 4194304$, $h_x = h_y = 1/2049$.\n- Explicit: $\\Delta t_{\\text{exp}} \\approx 5.359 \\times 10^{-4}\\,\\text{s}$, $n_{\\text{exp}} = 1866$. The kernel is memory-bound, $t_{\\text{exp,step}} \\approx 3.355 \\times 10^{-4}\\,\\text{s}$. Thus, $t_{\\text{exp}} \\approx 0.626155\\,\\text{s}$.\n- Implicit: $\\Delta t_{\\text{imp}} \\approx 5.359 \\times 10^{-3}\\,\\text{s}$, $n_{\\text{imp}} = 187$. The factorization time is $t_{\\text{fac}} \\approx 1.288490\\,\\text{s}$, and total solve time is $t_{\\text{solves}} \\approx 0.862768\\,\\text{s}$. Thus, $t_{\\text{imp}} \\approx 2.151259\\,\\text{s}$.\n- Ratio: $r = t_{\\text{exp}}/t_{\\text{imp}} \\approx 0.291062$.\n\n**Case B:** $N_x=4096$, $N_y=4096$, $L_x=1$, $L_y=1$, $\\alpha=5 \\times 10^{-4}$, $T=0.5$, $\\theta=0.9$, $m=100$, $F_{\\text{GPU}}=1 \\times 10^{12}$, $B_{\\text{GPU}}=6 \\times 10^{11}$, $F_{\\text{CPU}}=2 \\times 10^{11}$.\n- Grid: $N = 16777216$, $h_x = h_y = 1/4097$.\n- Explicit: $\\Delta t_{\\text{exp}} \\approx 2.681 \\times 10^{-5}\\,\\text{s}$, $n_{\\text{exp}} = 18651$. The kernel is memory-bound, $t_{\\text{exp,step}} \\approx 1.342 \\times 10^{-3}\\,\\text{s}$. Thus, $t_{\\text{exp}} \\approx 25.034000\\,\\text{s}$.\n- Implicit: $\\Delta t_{\\text{imp}} \\approx 2.681 \\times 10^{-3}\\,\\text{s}$, $n_{\\text{imp}} = 187$. The factorization time is $t_{\\text{fac}} \\approx 10.307921\\,\\text{s}$, and total solve time is $t_{\\text{solves}} \\approx 3.764811\\,\\text{s}$. Thus, $t_{\\text{imp}} \\approx 14.072732\\,\\text{s}$.\n- Ratio: $r = t_{\\text{exp}}/t_{\\text{imp}} \\approx 1.779031$.\n\n**Case C:** $N_x=128$, $N_y=128$, $L_x=1$, $L_y=1$, $\\alpha=1 \\times 10^{-4}$, $T=0.1$, $\\theta=0.9$, $m=50$, $F_{\\text{GPU}}=5 \\times 10^{11}$, $B_{\\text{GPU}}=2 \\times 10^{11}$, $F_{\\text{CPU}}=2 \\times 10^{11}$.\n- Grid: $N = 16384$, $h_x = h_y = 1/129$.\n- Explicit: $\\Delta t_{\\text{exp}} \\approx 0.13521\\,\\text{s}$, $n_{\\text{exp}} = 1$. The kernel is memory-bound, $t_{\\text{exp,step}} \\approx 3.932 \\times 10^{-6}\\,\\text{s}$. Thus, $t_{\\text{exp}} \\approx 3.932 \\times 10^{-6}\\,\\text{s}$.\n- Implicit: $\\Delta t_{\\text{imp}} \\approx 6.7605\\,\\text{s}$, $n_{\\text{imp}} = 1$. The factorization time is $t_{\\text{fac}} \\approx 3.146 \\times 10^{-4}\\,\\text{s}$, and total solve time is $t_{\\text{solves}} \\approx 1.147 \\times 10^{-5}\\,\\text{s}$. Thus, $t_{\\text{imp}} \\approx 3.260 \\times 10^{-4}\\,\\text{s}$.\n- Ratio: $r = t_{\\text{exp}}/t_{\\text{imp}} \\approx 0.012060$.\n\n**Case D:** $N_x=1024$, $N_y=1024$, $L_x=1$, $L_y=1$, $\\alpha=2 \\times 10^{-4}$, $T=0.2$, $\\theta=0.9$, $m=20$, $F_{\\text{GPU}}=8 \\times 10^{10}$, $B_{\\text{GPU}}=6 \\times 10^{11}$, $F_{\\text{CPU}}=1.5 \\times 10^{11}$.\n- Grid: $N = 1048576$, $h_x = h_y = 1/1025$.\n- Explicit: $\\Delta t_{\\text{exp}} \\approx 1.071 \\times 10^{-3}\\,\\text{s}$, $n_{\\text{exp}} = 187$. The kernel is compute-bound, $t_{\\text{exp,step}} \\approx 1.704 \\times 10^{-4}\\,\\text{s}$. Thus, $t_{\\text{exp}} \\approx 0.031859\\,\\text{s}$.\n- Implicit: $\\Delta t_{\\text{imp}} \\approx 0.02142\\,\\text{s}$, $n_{\\text{imp}} = 10$. The factorization time is $t_{\\text{fac}} \\approx 0.214748\\,\\text{s}$, and total solve time is $t_{\\text{solves}} \\approx 0.013981\\,\\text{s}$. Thus, $t_{\\text{imp}} \\approx 0.228729\\,\\text{s}$.\n- Ratio: $r = t_{\\text{exp}}/t_{\\text{imp}} \\approx 0.139281$.\n\nThe final calculated ratios are $[0.291062, 1.779031, 0.012060, 0.139281]$.", "answer": "```python\nimport math\n\ndef solve():\n    \"\"\"\n    Computes performance ratios for explicit vs. implicit solvers\n    for the 2D heat equation based on a given performance model.\n    \"\"\"\n\n    # Fixed modeling constants\n    C_EXP_FLOP = 13\n    C_EXP_BYTES = 48  # 6 * b, where b=8 for double precision\n    C_FAC = 30\n    C_SOLVE = 10\n\n    test_cases = [\n        # Case A: large grid, moderate diffusivity, memory-bound GPU expected\n        {\"name\": \"A\", \"Nx\": 2048, \"Ny\": 2048, \"Lx\": 1.0, \"Ly\": 1.0, \n         \"alpha\": 1e-4, \"T\": 1.0, \"theta\": 0.9, \"m\": 10, \n         \"F_GPU\": 1e12, \"B_GPU\": 6e11, \"F_CPU\": 2e11},\n        \n        # Case B: very large grid, higher diffusivity, implicit advantage expected\n        {\"name\": \"B\", \"Nx\": 4096, \"Ny\": 4096, \"Lx\": 1.0, \"Ly\": 1.0, \n         \"alpha\": 5e-4, \"T\": 0.5, \"theta\": 0.9, \"m\": 100, \n         \"F_GPU\": 1e12, \"B_GPU\": 6e11, \"F_CPU\": 2e11},\n\n        # Case C: small grid, factorization overhead dominates implicit\n        {\"name\": \"C\", \"Nx\": 128, \"Ny\": 128, \"Lx\": 1.0, \"Ly\": 1.0, \n         \"alpha\": 1e-4, \"T\": 0.1, \"theta\": 0.9, \"m\": 50, \n         \"F_GPU\": 5e11, \"B_GPU\": 2e11, \"F_CPU\": 2e11},\n\n        # Case D: compute-bound GPU configuration\n        {\"name\": \"D\", \"Nx\": 1024, \"Ny\": 1024, \"Lx\": 1.0, \"Ly\": 1.0, \n         \"alpha\": 2e-4, \"T\": 0.2, \"theta\": 0.9, \"m\": 20, \n         \"F_GPU\": 8e10, \"B_GPU\": 6e11, \"F_CPU\": 1.5e11},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Extract parameters\n        Nx, Ny = case[\"Nx\"], case[\"Ny\"]\n        Lx, Ly = case[\"Lx\"], case[\"Ly\"]\n        alpha, T = case[\"alpha\"], case[\"T\"]\n        theta, m = case[\"theta\"], case[\"m\"]\n        F_GPU, B_GPU, F_CPU = case[\"F_GPU\"], case[\"B_GPU\"], case[\"F_CPU\"]\n\n        # Common grid parameters\n        N = Nx * Ny\n        hx = Lx / (Nx + 1)\n        hy = Ly / (Ny + 1)\n\n        # --- Explicit Method (GPU) ---\n        dt_cfl = 1.0 / (2.0 * alpha * (1.0/hx**2 + 1.0/hy**2))\n        dt_exp = theta * dt_cfl\n        n_exp = math.ceil(T / dt_exp)\n\n        # Roofline model for per-step time\n        t_comp_per_step = (N * C_EXP_FLOP) / F_GPU\n        t_mem_per_step = (N * C_EXP_BYTES) / B_GPU\n        t_exp_step = max(t_comp_per_step, t_mem_per_step)\n        \n        t_exp = n_exp * t_exp_step\n\n        # --- Implicit Method (CPU) ---\n        dt_imp = m * dt_exp\n        n_imp = math.ceil(T / dt_imp)\n\n        # Factorization cost. Since Nx=Ny in all cases, N is a perfect square.\n        # N^(3/2) = (Nx^2)^(3/2) = Nx^3, which avoids floating-point exponentiation.\n        if Nx == Ny:\n            flops_fac = C_FAC * (Nx**3)\n        else: # General case, not present in test suite\n            flops_fac = C_FAC * (N**1.5)\n        \n        t_fac = flops_fac / F_CPU\n        \n        # Solve cost\n        flops_solve = C_SOLVE * N * math.log2(N)\n        t_solves_total = n_imp * (flops_solve / F_CPU)\n        \n        t_imp = t_fac + t_solves_total\n\n        # Ratio of explicit to implicit time\n        ratio = t_exp / t_imp\n        results.append(ratio)\n\n    # Format the final output string with rounding to 6 decimal places.\n    output_str = \",\".join([f\"{r:.6f}\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2390421"}]}