{"hands_on_practices": [{"introduction": "The mathematical description of a structured grid is encoded in its metric tensor and Jacobian, which quantify local distortion in length, angle, and area. This exercise provides direct, hands-on experience in translating these abstract analytical definitions into concrete computational results for several common grid transformations. Mastering this step is fundamental to solving any physical problem on a curvilinear grid, as these metric terms appear in the transformed governing equations. [@problem_id:2436332]", "problem": "You are given smooth, two-dimensional, analytical transformations from a computational coordinate system $(\\xi,\\eta)$ to a physical coordinate system $(x,y)$. Let $\\boldsymbol{r}(\\xi,\\eta) = (x(\\xi,\\eta), y(\\xi,\\eta))$. The covariant base vectors are defined as $\\boldsymbol{r}_{\\xi} = \\dfrac{\\partial \\boldsymbol{r}}{\\partial \\xi}$ and $\\boldsymbol{r}_{\\eta} = \\dfrac{\\partial \\boldsymbol{r}}{\\partial \\eta}$. The covariant metric tensor components are defined by $g_{ij} = \\boldsymbol{r}_{i} \\cdot \\boldsymbol{r}_{j}$ for $i,j \\in \\{\\xi,\\eta\\}$, specifically $g_{\\xi\\xi}$, $g_{\\xi\\eta}$, and $g_{\\eta\\eta}$. The Jacobian determinant is defined by $J = \\det\\left(\\dfrac{\\partial(x,y)}{\\partial(\\xi,\\eta)}\\right)$. All quantities are dimensionless. All angles, when they appear in the transformations, must be treated in radians.\n\nWrite a program that, for each transformation and evaluation point listed below, computes the list $[g_{\\xi\\xi}, g_{\\xi\\eta}, g_{\\eta\\eta}, J]$ and rounds each entry to $8$ decimal places.\n\nThe required test suite is as follows, where every parameter and evaluation coordinate is given explicitly:\n\n- Test case $1$ (affine mapping): $x(\\xi,\\eta) = a\\,\\xi + b\\,\\eta + c$, $y(\\xi,\\eta) = d\\,\\xi + e\\,\\eta + f$, with $(a,b,c,d,e,f) = (\\,2,\\,1,\\,0.5,\\,-1,\\,3,\\,1\\,)$ evaluated at $(\\xi,\\eta) = (\\,0.3,\\,-0.7\\,)$.\n- Test case $2$ (polynomial skew): $x(\\xi,\\eta) = \\xi + \\alpha\\,\\xi\\,\\eta$, $y(\\xi,\\eta) = \\eta + \\beta\\,\\xi^{2}$, with $(\\alpha,\\beta) = (\\,0.4,\\,-0.2\\,)$ evaluated at $(\\xi,\\eta) = (\\,0.5,\\,-1.0\\,)$.\n- Test case $3$ (polar-type mapping): $x(\\xi,\\eta) = r\\cos\\theta$, $y(\\xi,\\eta) = r\\sin\\theta$, where $(\\xi,\\eta) = (r,\\theta)$, evaluated at $(r,\\theta) = (\\,2.0,\\,\\pi/6\\,)$. Angles are in radians.\n- Test case $4$ (trigonometric warp): $x(\\xi,\\eta) = \\xi + A\\sin(\\pi \\xi)\\sin(\\pi \\eta)$, $y(\\xi,\\eta) = \\eta + B\\sin(\\pi \\xi)\\sin(\\pi \\eta)$, with $(A,B) = (\\,0.1,\\,-0.15\\,)$ evaluated at $(\\xi,\\eta) = (\\,0.25,\\,0.75\\,)$.\n\nYour program must output a single line containing a list of lists, where each inner list corresponds to one test case in the order above, and each inner list is $[g_{\\xi\\xi}, g_{\\xi\\eta}, g_{\\eta\\eta}, J]$ with each float rounded to $8$ decimal places. For example, your output should have the form\n$[[v_{11},v_{12},v_{13},v_{14}],[v_{21},v_{22},v_{23},v_{24}],[v_{31},v_{32},v_{33},v_{34}],[v_{41},v_{42},v_{43},v_{44}]]$\nwhere each $v_{ij}$ is a float rounded to $8$ decimal places. No additional text should be printed.", "solution": "The problem as stated is valid. It is a well-posed problem in applied differential geometry, fundamental to the field of computational engineering, specifically for the analysis of structured grids. All definitions, transformations, and parameters are provided, are scientifically sound, and free from ambiguity or contradiction. A unique solution exists for each test case. The solution will proceed by direct calculation based on the provided definitions.\n\nThe transformation from computational coordinates $(\\xi, \\eta)$ to physical coordinates $(x, y)$ is given by $\\boldsymbol{r}(\\xi, \\eta) = (x(\\xi, \\eta), y(\\xi, \\eta))$. The covariant base vectors are $\\boldsymbol{r}_{\\xi} = \\frac{\\partial \\boldsymbol{r}}{\\partial \\xi} = (\\frac{\\partial x}{\\partial \\xi}, \\frac{\\partial y}{\\partial \\xi})$ and $\\boldsymbol{r}_{\\eta} = \\frac{\\partial \\boldsymbol{r}}{\\partial \\eta} = (\\frac{\\partial x}{\\partial \\eta}, \\frac{\\partial y}{\\partial \\eta})$.\n\nFrom these vectors, the components of the covariant metric tensor $g_{ij}$ and the Jacobian determinant $J$ are calculated.\nThe metric tensor components are given by the dot products of the base vectors:\n$$g_{\\xi\\xi} = \\boldsymbol{r}_{\\xi} \\cdot \\boldsymbol{r}_{\\xi} = \\left(\\frac{\\partial x}{\\partial \\xi}\\right)^2 + \\left(\\frac{\\partial y}{\\partial \\xi}\\right)^2$$\n$$g_{\\eta\\eta} = \\boldsymbol{r}_{\\eta} \\cdot \\boldsymbol{r}_{\\eta} = \\left(\\frac{\\partial x}{\\partial \\eta}\\right)^2 + \\left(\\frac{\\partial y}{\\partial \\eta}\\right)^2$$\n$$g_{\\xi\\eta} = \\boldsymbol{r}_{\\xi} \\cdot \\boldsymbol{r}_{\\eta} = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial x}{\\partial \\eta} + \\frac{\\partial y}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta}$$\nThe Jacobian determinant, representing the local ratio of area elements, is given by:\n$$J = \\det\\left(\\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}\\right) = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta} - \\frac{\\partial x}{\\partial \\eta}\\frac{\\partial y}{\\partial \\xi}$$\nWe will now calculate these four quantities for each of the specified test cases.\n\nTest case $1$: Affine mapping\nThe transformation is $x(\\xi,\\eta) = a\\xi + b\\eta + c$ and $y(\\xi,\\eta) = d\\xi + e\\eta + f$, with parameters $(a,b,c,d,e,f) = (2, 1, 0.5, -1, 3, 1)$. The partial derivatives are constants:\n$\\frac{\\partial x}{\\partial \\xi} = a = 2$\n$\\frac{\\partial x}{\\partial \\eta} = b = 1$\n$\\frac{\\partial y}{\\partial \\xi} = d = -1$\n$\\frac{\\partial y}{\\partial \\eta} = e = 3$\nThese values are independent of the evaluation point $(\\xi,\\eta) = (0.3, -0.7)$.\n$g_{\\xi\\xi} = (2)^2 + (-1)^2 = 4 + 1 = 5$\n$g_{\\eta\\eta} = (1)^2 + (3)^2 = 1 + 9 = 10$\n$g_{\\xi\\eta} = (2)(1) + (-1)(3) = 2 - 3 = -1$\n$J = (2)(3) - (1)(-1) = 6 + 1 = 7$\nThe required list is $[5.0, -1.0, 10.0, 7.0]$.\n\nTest case $2$: Polynomial skew\nThe transformation is $x(\\xi,\\eta) = \\xi + \\alpha\\xi\\eta$ and $y(\\xi,\\eta) = \\eta + \\beta\\xi^2$, with parameters $(\\alpha, \\beta) = (0.4, -0.2)$.\nThe partial derivatives are:\n$\\frac{\\partial x}{\\partial \\xi} = 1 + \\alpha\\eta$\n$\\frac{\\partial x}{\\partial \\eta} = \\alpha\\xi$\n$\\frac{\\partial y}{\\partial \\xi} = 2\\beta\\xi$\n$\\frac{\\partial y}{\\partial \\eta} = 1$\nEvaluating at $(\\xi, \\eta) = (0.5, -1.0)$:\n$\\frac{\\partial x}{\\partial \\xi} = 1 + (0.4)(-1.0) = 1 - 0.4 = 0.6$\n$\\frac{\\partial x}{\\partial \\eta} = (0.4)(0.5) = 0.2$\n$\\frac{\\partial y}{\\partial \\xi} = 2(-0.2)(0.5) = -0.2$\n$\\frac{\\partial y}{\\partial \\eta} = 1$\n$g_{\\xi\\xi} = (0.6)^2 + (-0.2)^2 = 0.36 + 0.04 = 0.4$\n$g_{\\eta\\eta} = (0.2)^2 + (1)^2 = 0.04 + 1 = 1.04$\n$g_{\\xi\\eta} = (0.6)(0.2) + (-0.2)(1) = 0.12 - 0.2 = -0.08$\n$J = (0.6)(1) - (0.2)(-0.2) = 0.6 + 0.04 = 0.64$\nThe required list is $[0.4, -0.08, 1.04, 0.64]$.\n\nTest case $3$: Polar-type mapping\nThe transformation is $x(r,\\theta) = r\\cos\\theta$ and $y(r,\\theta) = r\\sin\\theta$, with computational coordinates identified as $(\\xi, \\eta) = (r, \\theta)$.\nThe partial derivatives with respect to $\\xi=r$ and $\\eta=\\theta$ are:\n$\\frac{\\partial x}{\\partial \\xi} = \\cos\\eta$\n$\\frac{\\partial x}{\\partial \\eta} = -\\xi\\sin\\eta$\n$\\frac{\\partial y}{\\partial \\xi} = \\sin\\eta$\n$\\frac{\\partial y}{\\partial \\eta} = \\xi\\cos\\eta$\nEvaluating at $(\\xi, \\eta) = (2.0, \\pi/6)$:\n$\\frac{\\partial x}{\\partial \\xi} = \\cos(\\pi/6) = \\frac{\\sqrt{3}}{2}$\n$\\frac{\\partial x}{\\partial \\eta} = -2\\sin(\\pi/6) = -2(\\frac{1}{2}) = -1$\n$\\frac{\\partial y}{\\partial \\xi} = \\sin(\\pi/6) = \\frac{1}{2}$\n$\\frac{\\partial y}{\\partial \\eta} = 2\\cos(\\pi/6) = 2(\\frac{\\sqrt{3}}{2}) = \\sqrt{3}$\n$g_{\\xi\\xi} = (\\frac{\\sqrt{3}}{2})^2 + (\\frac{1}{2})^2 = \\frac{3}{4} + \\frac{1}{4} = 1$\n$g_{\\eta\\eta} = (-1)^2 + (\\sqrt{3})^2 = 1 + 3 = 4$\n$g_{\\xi\\eta} = (\\frac{\\sqrt{3}}{2})(-1) + (\\frac{1}{2})(\\sqrt{3}) = 0$\n$J = (\\frac{\\sqrt{3}}{2})(\\sqrt{3}) - (-1)(\\frac{1}{2}) = \\frac{3}{2} + \\frac{1}{2} = 2$\nThe required list is $[1.0, 0.0, 4.0, 2.0]$.\n\nTest case $4$: Trigonometric warp\nThe transformation is $x(\\xi,\\eta) = \\xi + A\\sin(\\pi\\xi)\\sin(\\pi\\eta)$ and $y(\\xi,\\eta) = \\eta + B\\sin(\\pi\\xi)\\sin(\\pi\\eta)$, with parameters $(A, B) = (0.1, -0.15)$.\nThe partial derivatives are:\n$\\frac{\\partial x}{\\partial \\xi} = 1 + A\\pi\\cos(\\pi\\xi)\\sin(\\pi\\eta)$\n$\\frac{\\partial x}{\\partial \\eta} = A\\pi\\sin(\\pi\\xi)\\cos(\\pi\\eta)$\n$\\frac{\\partial y}{\\partial \\xi} = B\\pi\\cos(\\pi\\xi)\\sin(\\pi\\eta)$\n$\\frac{\\partial y}{\\partial \\eta} = 1 + B\\pi\\sin(\\pi\\xi)\\cos(\\pi\\eta)$\nEvaluating at $(\\xi, \\eta) = (0.25, 0.75)$:\nWe have $\\pi\\xi = \\pi/4$ and $\\pi\\eta = 3\\pi/4$.\n$\\cos(\\pi/4) = \\frac{\\sqrt{2}}{2}$, $\\sin(\\pi/4) = \\frac{\\sqrt{2}}{2}$, $\\cos(3\\pi/4) = -\\frac{\\sqrt{2}}{2}$, $\\sin(3\\pi/4) = \\frac{\\sqrt{2}}{2}$.\nThus, $\\cos(\\pi\\xi)\\sin(\\pi\\eta) = (\\frac{\\sqrt{2}}{2})(\\frac{\\sqrt{2}}{2}) = 0.5$ and $\\sin(\\pi\\xi)\\cos(\\pi\\eta) = (\\frac{\\sqrt{2}}{2})(-\\frac{\\sqrt{2}}{2}) = -0.5$.\nSubstituting these values:\n$\\frac{\\partial x}{\\partial \\xi} = 1 + (0.1)\\pi(0.5) = 1 + 0.05\\pi$\n$\\frac{\\partial x}{\\partial \\eta} = (0.1)\\pi(-0.5) = -0.05\\pi$\n$\\frac{\\partial y}{\\partial \\xi} = (-0.15)\\pi(0.5) = -0.075\\pi$\n$\\frac{\\partial y}{\\partial \\eta} = 1 + (-0.15)\\pi(-0.5) = 1 + 0.075\\pi$\n$g_{\\xi\\xi} = (1+0.05\\pi)^2 + (-0.075\\pi)^2 = 1 + 0.1\\pi + 0.0025\\pi^2 + 0.005625\\pi^2 = 1 + 0.1\\pi + 0.008125\\pi^2 \\approx 1.39435068$\n$g_{\\eta\\eta} = (-0.05\\pi)^2 + (1+0.075\\pi)^2 = 0.0025\\pi^2 + 1 + 0.15\\pi + 0.005625\\pi^2 = 1 + 0.15\\pi + 0.008125\\pi^2 \\approx 1.55142551$\n$g_{\\xi\\eta} = (1+0.05\\pi)(-0.05\\pi) + (-0.075\\pi)(1+0.075\\pi) = -0.05\\pi - 0.0025\\pi^2 - 0.075\\pi - 0.005625\\pi^2 = -0.125\\pi - 0.008125\\pi^2 \\approx -0.47289237$\n$J = (1+0.05\\pi)(1+0.075\\pi) - (-0.05\\pi)(-0.075\\pi) = 1 + 0.125\\pi + 0.00375\\pi^2 - 0.00375\\pi^2 = 1 + 0.125\\pi \\approx 1.39269908$\nThe required list, rounded to $8$ decimal places, is $[1.39435068, -0.47289237, 1.55142551, 1.39269908]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the metric tensor components and Jacobian for four\n    different coordinate transformations.\n    \"\"\"\n\n    def case1():\n        \"\"\"Affine mapping.\"\"\"\n        a, b, c, d, e, f = 2, 1, 0.5, -1, 3, 1\n        # xi, eta = 0.3, -0.7 # Not needed as derivatives are constant\n        \n        # Partial derivatives\n        x_xi = a\n        x_eta = b\n        y_xi = d\n        y_eta = e\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    def case2():\n        \"\"\"Polynomial skew.\"\"\"\n        alpha, beta = 0.4, -0.2\n        xi, eta = 0.5, -1.0\n        \n        # Partial derivatives\n        x_xi = 1 + alpha * eta\n        x_eta = alpha * xi\n        y_xi = 2 * beta * xi\n        y_eta = 1\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    def case3():\n        \"\"\"Polar-type mapping.\"\"\"\n        xi, eta = 2.0, np.pi / 6.0 # (r, theta)\n        \n        # Partial derivatives\n        x_xi = np.cos(eta)       # dx/dr\n        x_eta = -xi * np.sin(eta) # dx/dtheta\n        y_xi = np.sin(eta)       # dy/dr\n        y_eta = xi * np.cos(eta)  # dy/dtheta\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    def case4():\n        \"\"\"Trigonometric warp.\"\"\"\n        A, B = 0.1, -0.15\n        xi, eta = 0.25, 0.75\n        \n        pi_xi = np.pi * xi\n        pi_eta = np.pi * eta\n        \n        # Common trigonometric terms\n        cos_xi_sin_eta = np.cos(pi_xi) * np.sin(pi_eta)\n        sin_xi_cos_eta = np.sin(pi_xi) * np.cos(pi_eta)\n        \n        # Partial derivatives\n        x_xi = 1 + A * np.pi * cos_xi_sin_eta\n        x_eta = A * np.pi * sin_xi_cos_eta\n        y_xi = B * np.pi * cos_xi_sin_eta\n        y_eta = 1 + B * np.pi * sin_xi_cos_eta\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    results = []\n    case_functions = [case1, case2, case3, case4]\n\n    for func in case_functions:\n        raw_result = func()\n        rounded_result = [round(val, 8) for val in raw_result]\n        results.append(rounded_result)\n    \n    # Generate the output string exactly as specified, without spaces\n    print(repr(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2436332"}, {"introduction": "Coordinate systems often contain singularities, such as the origin in polar coordinates, which demand special attention when discretized. This practice guides you through a practical investigation of how a naive discretization fails near a singularity and how a principled approach, based on the underlying physics, can restore the solution's accuracy. This exercise provides a critical lesson in the interplay between grid structure and numerical fidelity, demonstrating that a well-chosen grid requires a well-designed numerical scheme. [@problem_id:2436320]", "problem": "Consider the axisymmetric Poisson equation in polar coordinates on the closed unit disk. Let $u(r)$ denote a scalar field that depends only on the radius $r \\in [0,1]$. The governing equation is\n$$\n\\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial u}{\\partial r} = f(r),\n$$\nwith the boundary condition $u(1)=0$ and the regularity condition that $u(r)$ remains finite as $r \\to 0$. For this problem, use the exact smooth solution $u_{\\text{exact}}(r) = 1 - r^2$, which implies $f(r) = -4$ for all $r \\in [0,1]$.\n\nYou must investigate how the singularity of the polar mapping at $r=0$ influences a numerical approximation on a structured grid, and demonstrate a mitigation strategy. Proceed as follows, using only the mathematical definitions provided here:\n\n- Construct a uniform structured radial grid with $N$ intervals and spacing $h = 1/N$, with nodal locations $r_i = i h$ for $i=0,1,\\dots,N$.\n- Compute two independent numerical approximations of $u(r)$ on this grid:\n  1. A baseline approximation that treats $r=0$ as an ordinary grid point but imposes the inconsistent boundary value $u(0) = 0$ at the origin and $u(1)=0$ at the outer boundary. This baseline is intentionally inconsistent with the true solution at $r=0$ and serves to quantify how the singular mapping can pollute the discrete solution.\n  2. A mitigated approximation that uses any mathematically justified strategy derived from first principles to correctly remove the effect of the singular mapping at $r=0$ while enforcing $u(1)=0$. Any choice that is consistent with the underlying continuous problem is acceptable, provided it produces a well-posed discrete system.\n\nFor each approximation, quantify the error by the relative area-weighted discrete $L^2$ norm over the disk:\n$$\nE = \\frac{\\left(\\int_0^1 2\\pi r \\left(u_{\\text{num}}(r) - u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}{\\left(\\int_0^1 2\\pi r \\left(u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}.\n$$\nIn your program, approximate these integrals on the grid $\\{r_i\\}_{i=0}^N$ using the composite trapezoidal rule in $r$, that is, with weights $w_0 = w_N = \\tfrac{1}{2}$ and $w_i = 1$ for $i=1,\\dots,N-1$, and spacing $h = 1/N$.\n\nTest Suite:\n- Use $N \\in \\{8,16,32,64\\}$.\n- For each $N$, compute and report two numbers: $E_{\\text{baseline}}(N)$ and $E_{\\text{mitigated}}(N)$ as defined above.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$$\n\\left[E_{\\text{baseline}}(8), E_{\\text{mitigated}}(8), E_{\\text{baseline}}(16), E_{\\text{mitigated}}(16), E_{\\text{baseline}}(32), E_{\\text{mitigated}}(32), E_{\\text{baseline}}(64), E_{\\text{mitigated}}(64)\\right].\n$$\nNo physical units are involved. Angles, where implicitly relevant to polar coordinates, are in radians, but the present problem is purely radial.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- **Governing Equation**: $\\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial u}{\\partial r} = f(r)$ on $r \\in [0,1]$.\n- **Boundary and Regularity Conditions**: $u(1)=0$ and $u(r)$ is finite as $r \\to 0$.\n- **Exact Solution**: $u_{\\text{exact}}(r) = 1 - r^2$.\n- **Source Term**: $f(r) = -4$.\n- **Grid**: Uniform with $N$ intervals, spacing $h = 1/N$, nodes $r_i = i h$ for $i=0,1,\\dots,N$.\n- **Baseline Approximation**: $u(0)=0$, $u(1)=0$, and standard finite differences for $r_i, i \\in \\{1, \\dots, N-1\\}$.\n- **Mitigated Approximation**: Mathematically justified strategy to handle the singularity at $r=0$, with $u(1)=0$.\n- **Error Metric**: Relative area-weighted discrete $L^2$ norm, $E = \\frac{\\left(\\int_0^1 2\\pi r \\left(u_{\\text{num}}(r) - u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}{\\left(\\int_0^1 2\\pi r \\left(u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}$.\n- **Numerical Integration**: Composite trapezoidal rule on $\\{r_i\\}_{i=0}^N$.\n- **Test Suite**: $N \\in \\{8,16,32,64\\}$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, as it concerns the numerical solution of the Poisson equation in polar coordinates, a fundamental problem in engineering and physics. The coordinate singularity at $r=0$ is a classic numerical challenge that requires special treatment, and the problem correctly frames this as a comparative study between a naive and a principled approach. The problem is well-posed; it provides all necessary equations, boundary conditions, and definitions to construct a unique numerical solution for each case. The language is objective and mathematically precise. There are no scientific or logical flaws, contradictions, or ambiguities.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n**Mathematical Formulation and Discretization**\n\nThe governing equation is the axisymmetric Poisson equation in one spatial dimension, the radius $r$:\n$$\n\\frac{d^2 u}{d r^2} + \\frac{1}{r}\\frac{d u}{d r} = f(r)\n$$\nfor $r \\in (0, 1]$, with boundary condition $u(1)=0$ and source term $f(r)=-4$. A uniform grid is defined with $N$ intervals of spacing $h=1/N$, such that the grid nodes are located at $r_i=ih$ for $i=0, 1, \\dots, N$. The numerical solution at these nodes is denoted $u_i \\approx u(r_i)$.\n\nFor an interior node $r_i$ where $i \\in \\{1, \\dots, N-1\\}$, the derivatives are approximated using second-order central finite differences:\n$$\n\\frac{d^2 u}{d r^2}\\bigg|_{r_i} \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n$$\n$$\n\\frac{d u}{d r}\\bigg|_{r_i} \\approx \\frac{u_{i+1} - u_{i-1}}{2h}\n$$\nSubstituting these into the governing equation and using $r_i=ih$ yields the general discrete equation for an interior node:\n$$\n\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} + \\frac{1}{ih} \\left(\\frac{u_{i+1} - u_{i-1}}{2h}\\right) = f_i\n$$\nwhere $f_i = f(r_i) = -4$. This equation can be rearranged into a linear relationship between adjacent nodal values:\n$$\n\\left(1 - \\frac{1}{2i}\\right)u_{i-1} - 2u_i + \\left(1 + \\frac{1}{2i}\\right)u_{i+1} = h^2 f_i\n$$\nThis forms the basis for a system of linear algebraic equations. The treatment of the boundaries at $i=0$ and $i=N$ distinguishes the two required approximation schemes.\n\n**Baseline Approximation**\n\nThis approach imposes the Dirichlet boundary conditions $u_0 = 0$ and $u_N = 0$. The condition $u_0=0$ is inconsistent with the exact solution $u_{\\text{exact}}(0) = 1 - 0^2 = 1$, and is used to demonstrate the effect of incorrect handling of the origin. The unknowns are the nodal values $u_1, u_2, \\dots, u_{N-1}$. A system of $N-1$ linear equations is formed by applying the general discrete equation for each $i \\in \\{1, \\dots, N-1\\}$. This results in an $(N-1) \\times (N-1)$ tridiagonal system of equations $A_{\\text{base}} \\mathbf{u}_{\\text{base}} = \\mathbf{b}_{\\text{base}}$, which can be solved for the vector of unknowns $\\mathbf{u}_{\\text{base}} = [u_1, \\dots, u_{N-1}]^T$.\n\n**Mitigated Approximation**\n\nA correct formulation must properly handle the singular term $\\frac{1}{r}\\frac{du}{dr}$ at $r=0$. From the regularity condition, the solution $u(r)$ must be smooth on the disk. For an axisymmetric function, this implies that the first derivative must vanish at the origin due to symmetry: $\\frac{du}{dr}|_{r=0} = 0$. Applying L'Hôpital's rule to the singular term gives:\n$$\n\\lim_{r\\to 0} \\frac{1}{r}\\frac{du}{dr} = \\lim_{r\\to 0} \\frac{\\frac{d^2u}{dr^2}}{\\frac{d}{dr}(r)} = \\frac{d^2u}{dr^2}\\bigg|_{r=0}\n$$\nTherefore, at $r=0$, the governing equation takes the non-singular form:\n$$\n2 \\frac{d^2u}{dr^2}\\bigg|_{r=0} = f(0)\n$$\nTo discretize this equation at $r_0=0$, we use a second-order central difference for the second derivative. By axisymmetry, the solution profile is even, so $u(-r) = u(r)$, which implies $u(r_{-1}) = u(-h) = u(h) = u_1$. The finite difference approximation at $r_0=0$ is:\n$$\n\\frac{d^2u}{dr^2}\\bigg|_{r_0} \\approx \\frac{u_1 - 2u_0 + u_{-1}}{h^2} = \\frac{u_1 - 2u_0 + u_1}{h^2} = \\frac{2u_1 - 2u_0}{h^2}\n$$\nSubstituting this into the specialized governing equation at $r=0$ yields the discrete equation for the center node $u_0$:\n$$\n2 \\left( \\frac{2u_1 - 2u_0}{h^2} \\right) = f_0 \\quad \\implies \\quad -4u_0 + 4u_1 = h^2f_0\n$$\nThe system of equations for the mitigated case consists of this equation at $i=0$ and the general finite difference equations for $i = 1, \\dots, N-1$. Together with the boundary condition $u_N=0$, this forms a well-posed $N \\times N$ system of equations $A_{\\text{mit}} \\mathbf{u}_{\\text{mit}} = \\mathbf{b}_{\\text{mit}}$ for the unknowns $\\mathbf{u}_{\\text{mit}} = [u_0, \\dots, u_{N-1}]^T$.\n\n**Error Quantification**\n\nThe error is quantified by the relative area-weighted $L^2$ norm. The factor of $2\\pi$ for the area element $2\\pi r \\, dr$ cancels from the numerator and denominator:\n$$\nE = \\frac{\\left(\\int_0^1 r \\left(u_{\\text{num}}(r) - u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}{\\left(\\int_0^1 r \\left(u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}\n$$\nThe integrals are approximated numerically using the composite trapezoidal rule. For an integrand $g(r)$, the integral is $\\int_0^1 g(r) \\, dr \\approx h \\sum_{i=0}^N w_i g(r_i)$, with weights $w_0=w_N=1/2$ and $w_i=1$ for $i \\in \\{1,\\dots,N-1\\}$. For the numerator, the integrand is $g_{\\text{num}}(r) = r(u_{\\text{num}}(r)-u_{\\text{exact}}(r))^2$. For the denominator, it is $g_{\\text{den}}(r) = r(u_{\\text{exact}}(r))^2$. Both integrands are zero at $r=0$ (due to the factor of $r$) and at $r=1$ (since $u_{\\text{num}}(1)=u_{\\text{exact}}(1)=0$). The numerical solution is obtained for each $N \\in \\{8,16,32,64\\}$, and the corresponding errors $E_{\\text{baseline}}(N)$ and $E_{\\text{mitigated}}(N)$ are computed.", "answer": "```python\nimport numpy as np\n\ndef calculate_error(u_num, u_exact, r):\n    \"\"\"\n    Calculates the relative area-weighted discrete L2 norm.\n    The area element is 2*pi*r*dr, but 2*pi cancels.\n    \"\"\"\n    # Numerator integrand: r * (u_num - u_exact)^2\n    error_sq = (u_num - u_exact)**2\n    integrand_num = r * error_sq\n    \n    # Denominator integrand: r * (u_exact)^2\n    u_exact_sq = u_exact**2\n    integrand_den = r * u_exact_sq\n    \n    # Integrate using the composite trapezoidal rule provided by numpy.\n    # np.trapz(y, x) computes the integral of y(x) dx.\n    integral_num = np.trapz(integrand_num, r)\n    integral_den = np.trapz(integrand_den, r)\n    \n    if integral_den == 0:\n        # This case is unlikely with the given exact solution.\n        return np.inf\n\n    # The error E is the square root of the ratio of the integrals.\n    E = np.sqrt(integral_num / integral_den)\n    return E\n\ndef solve():\n    \"\"\"\n    Solves the axisymmetric Poisson equation using two different treatments\n    of the singularity at r=0 and computes the error for each case.\n    \"\"\"\n    test_cases = [8, 16, 32, 64]\n    results = []\n\n    for N in test_cases:\n        h = 1.0 / N\n        # Grid points r_i = i*h for i = 0, ..., N\n        r = np.linspace(0.0, 1.0, N + 1)\n        # Exact solution u(r) = 1 - r^2\n        u_exact = 1.0 - r**2\n        # Source term f(r) = -4\n        f = -4.0\n\n        # --- Baseline Approximation ---\n        # Solves for unknowns u_1, ..., u_{N-1}. Size (N-1)x(N-1).\n        # Boundary conditions: u_0 = 0, u_N = 0.\n        size_base = N - 1\n        if size_base > 0:\n            # Main diagonal of the matrix A\n            diag_main = -2.0 * np.ones(size_base)\n\n            # Sub-diagonal terms: (1 - 1/(2*i)) for u_{i-1}\n            # Matrix index k = i - 1. So i = k + 1.\n            i_sub = np.arange(2, N) # i goes from 2 to N-1\n            diag_sub = 1.0 - 1.0 / (2.0 * i_sub)\n\n            # Super-diagonal terms: (1 + 1/(2*i)) for u_{i+1}\n            # Matrix index k = i - 1. So i = k + 1.\n            i_sup = np.arange(1, N - 1) # i goes from 1 to N-2\n            diag_sup = 1.0 + 1.0 / (2.0 * i_sup)\n            \n            A_base = np.diag(diag_main) + np.diag(diag_sub, k=-1) + np.diag(diag_sup, k=1)\n            b_base = np.full(size_base, f * h**2)\n\n            u_sol_base = np.linalg.solve(A_base, b_base)\n\n            # Construct full solution vector [u_0, ..., u_N]\n            u_num_base = np.zeros(N + 1)\n            u_num_base[1:N] = u_sol_base # u_num_base at 0 and N remain 0\n        else: # Case N=1\n             u_num_base = np.zeros(N + 1)\n        \n        error_base = calculate_error(u_num_base, u_exact, r)\n        results.append(error_base)\n\n        # --- Mitigated Approximation ---\n        # Solves for unknowns u_0, ..., u_{N-1}. Size NxN.\n        # Boundary conditions: Special equation at r=0, and u_N = 0.\n        size_mit = N\n        A_mit = np.zeros((size_mit, size_mit))\n        b_mit = np.full(size_mit, f * h**2)\n\n        # Row 0: Equation at r=0 is -4*u_0 + 4*u_1 = f*h^2\n        A_mit[0, 0] = -4.0\n        if size_mit > 1:\n            A_mit[0, 1] = 4.0\n\n        # Rows 1 to N-1 (grid indices i=1 to N-1)\n        for i in range(1, size_mit): # i is both matrix row and grid index\n            # Main diagonal term\n            A_mit[i, i] = -2.0\n            # Sub-diagonal term: (1 - 1/(2i)) for u_{i-1}\n            A_mit[i, i - 1] = 1.0 - 1.0 / (2.0 * i)\n            # Super-diagonal term: (1 + 1/(2i)) for u_{i+1}\n            if i  size_mit - 1:\n                A_mit[i, i + 1] = 1.0 + 1.0 / (2.0 * i)\n\n        u_sol_mit = np.linalg.solve(A_mit, b_mit)\n\n        # Construct full solution vector [u_0, ..., u_N]\n        u_num_mit = np.zeros(N + 1)\n        u_num_mit[0:N] = u_sol_mit # u_num_mit at N remains 0\n\n        error_mit = calculate_error(u_num_mit, u_exact, r)\n        results.append(error_mit)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.10f}' for res in results)}]\")\n\nsolve()\n```", "id": "2436320"}, {"introduction": "The geometry of a grid has profound implications for the stability and efficiency of time-dependent simulations, a phenomenon known as numerical stiffness. This advanced practice explores how the convergence of grid lines near the poles of a sphere drastically restricts the stable time step for explicit methods. By analyzing the spectrum of the discretized operator, you will quantify this stiffness and gain insight into a central challenge of global-scale modeling. [@problem_id:2436359]", "problem": "You are tasked with constructing a structured latitude–longitude grid on a spherical band and discretizing a partial differential equation (PDE) in conservative form to analyze numerical stiffness arising near the poles. Consider the linear diffusion equation (heat equation) on the unit sphere:\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\,\\Delta_S u,\n$$\nwhere $u = u(\\phi,\\lambda,t)$, $\\kappa  0$ is a constant diffusion coefficient, $\\phi \\in [-\\phi_{\\max}, \\phi_{\\max}]$ is latitude (radians), and $\\lambda \\in [0,2\\pi)$ is longitude (radians). The Laplace–Beltrami operator on the unit sphere in latitude–longitude coordinates is\n$$\n\\Delta_S u = \\frac{1}{\\cos \\phi}\\,\\frac{\\partial}{\\partial \\phi}\\!\\left(\\cos \\phi \\,\\frac{\\partial u}{\\partial \\phi}\\right) + \\frac{1}{\\cos^2 \\phi}\\,\\frac{\\partial^2 u}{\\partial \\lambda^2}.\n$$\nAngles must be treated in radians throughout.\n\nYour tasks:\n\n1) Starting from the definition of the Laplace–Beltrami operator and the metric of the unit sphere, derive a second-order accurate, centered finite difference discretization in conservative flux form on a uniform latitude–longitude grid over the spherical band $\\phi \\in [-\\phi_{\\max}, \\phi_{\\max}]$, $\\lambda \\in [0,2\\pi)$. Do not include the polar caps; that is, enforce $\\phi_{\\max}  \\frac{\\pi}{2}$ so that $\\cos \\phi$ remains strictly positive on the computational domain.\n\n2) Use periodic boundary conditions in longitude and zero normal flux at the artificial boundaries $\\phi = \\pm \\phi_{\\max}$. The zero normal flux condition means that the meridional flux through the boundaries vanishes, which is consistent with a band cut from the sphere.\n\n3) Assemble the discrete spatial operator as a matrix acting on the vectorized grid function values. Your construction must respect the metric factors exactly as implied by the continuous operator. To enable robust and accurate spectral characterization, structure your derivation so that the assembled matrix is diagonally similar to a real symmetric matrix.\n\n4) For explicit (forward) Euler time stepping applied to the semidiscrete system $\\frac{d\\mathbf{u}}{dt} = \\kappa A \\mathbf{u}$, determine the largest stable time step $\\Delta t_{\\max}$ implied by the spectrum of $\\kappa A$. Use the standard linear stability requirement for explicit Euler applied to a linear system with real, nonpositive eigenvalues.\n\n5) Investigate numerical stiffness arising from the pole singularities by quantifying how $\\Delta t_{\\max}$ changes as the grid approaches the poles (i.e., as $\\phi_{\\max} \\to \\frac{\\pi}{2}$) and as the longitude resolution increases. Use the discrete operator to compute the spectral radius needed for the time step restriction.\n\nConstruct a program that, for each of the following test cases, builds the discrete operator and returns the corresponding largest stable explicit Euler time step $\\Delta t_{\\max}$ as a floating-point number:\n\n- Case $1$: $N_\\phi = 24$, $N_\\lambda = 48$, $\\phi_{\\max} = \\frac{\\pi}{2} - 0.2$, $\\kappa = 1$.\n- Case $2$: $N_\\phi = 24$, $N_\\lambda = 96$, $\\phi_{\\max} = \\frac{\\pi}{2} - 0.02$, $\\kappa = 1$.\n- Case $3$: $N_\\phi = 24$, $N_\\lambda = 48$, $\\phi_{\\max} = \\frac{\\pi}{4}$, $\\kappa = 1$.\n- Case $4$: $N_\\phi = 24$, $N_\\lambda = 96$, $\\phi_{\\max} = \\frac{\\pi}{2} - 0.2$, $\\kappa = 1$.\n\nHere $N_\\phi$ and $N_\\lambda$ denote the number of uniformly spaced grid points in latitude and longitude, respectively. The uniform spacings are $\\Delta \\phi = \\frac{2\\phi_{\\max}}{N_\\phi - 1}$ and $\\Delta \\lambda = \\frac{2\\pi}{N_\\lambda}$.\n\nThe final program must compute, for each case, the largest admissible explicit Euler time step $\\Delta t_{\\max}$ implied by the spectrum of the assembled operator. All angles are in radians. No physical units other than radians are involved.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Each result must be a floating-point number. The program must be self-contained and require no input. The four outputs must correspond, in order, to Cases $1$ through $4$.", "solution": "The problem requires the derivation of a stable numerical scheme for the linear diffusion equation on a spherical band, followed by a quantitative analysis of its numerical stiffness. The analysis will proceed through a rigorous discretization of the governing partial differential equation, assembly of the discrete operator, and spectral analysis to determine the stability limit for an explicit time-integration scheme.\n\nThe governing equation is the heat equation on a unit sphere, given by\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\,\\Delta_S u\n$$\nwhere $u(\\phi, \\lambda, t)$ is the quantity of interest (e.g., temperature), $\\kappa  0$ is the diffusion coefficient, $\\phi$ is latitude, $\\lambda$ is longitude, and $\\Delta_S$ is the Laplace-Beltrami operator:\n$$\n\\Delta_S u = \\frac{1}{\\cos \\phi}\\,\\frac{\\partial}{\\partial \\phi}\\!\\left(\\cos \\phi \\,\\frac{\\partial u}{\\partial \\phi}\\right) + \\frac{1}{\\cos^2 \\phi}\\,\\frac{\\partial^2 u}{\\partial \\lambda^2}.\n$$\nThe computational domain is a spherical band defined by $\\phi \\in [-\\phi_{\\max}, \\phi_{\\max}]$ with $\\phi_{\\max}  \\pi/2$, and $\\lambda \\in [0, 2\\pi)$.\n\nA uniform grid is defined with $N_\\phi$ points in latitude and $N_\\lambda$ points in longitude. The grid points are $(\\phi_j, \\lambda_k)$ for $j=0, \\dots, N_\\phi-1$ and $k=0, \\dots, N_\\lambda-1$. The grid spacings are uniform: $\\Delta \\phi = \\frac{2\\phi_{\\max}}{N_\\phi - 1}$ and $\\Delta \\lambda = \\frac{2\\pi}{N_\\lambda}$. The latitude coordinates are $\\phi_j = -\\phi_{\\max} + j\\Delta\\phi$.\n\nThe spatial operator is discretized using second-order centered finite differences. Let $u_{j,k} \\approx u(\\phi_j, \\lambda_k)$.\nThe zonal (longitudinal) term is discretized as:\n$$\n\\left. \\frac{1}{\\cos^2 \\phi}\\,\\frac{\\partial^2 u}{\\partial \\lambda^2} \\right|_{j,k} \\approx \\frac{1}{\\cos^2 \\phi_j} \\frac{u_{j, k+1} - 2u_{j,k} + u_{j, k-1}}{\\Delta\\lambda^2}.\n$$\nPeriodicity in longitude implies $u_{j, N_\\lambda} = u_{j,0}$ and $u_{j, -1} = u_{j, N_\\lambda-1}$.\n\nThe meridional (latitudinal) term, which is in conservative form, is discretized by defining the meridional flux at the midpoints between grid lines (cell faces), $\\phi_{j\\pm1/2} = \\phi_j \\pm \\Delta\\phi/2$. The flux is $F_\\phi = \\cos\\phi \\, \\frac{\\partial u}{\\partial \\phi}$.\n$$\n\\left. F_\\phi \\right|_{\\phi_{j+1/2}} \\approx \\cos(\\phi_{j+1/2}) \\frac{u_{j+1,k} - u_{j,k}}{\\Delta\\phi}\n$$\nThe divergence of the flux at grid point $\\phi_j$ is then approximated by a centered difference of the face fluxes:\n$$\n\\left. \\frac{1}{\\cos \\phi} \\frac{\\partial F_\\phi}{\\partial \\phi} \\right|_{j,k} \\approx \\frac{1}{\\cos \\phi_j} \\frac{F_{\\phi, j+1/2} - F_{\\phi, j-1/2}}{\\Delta\\phi}\n$$\n$$\n= \\frac{1}{\\cos \\phi_j \\Delta\\phi^2} \\left( \\cos(\\phi_{j+1/2})(u_{j+1,k} - u_{j,k}) - \\cos(\\phi_{j-1/2})(u_{j,k} - u_{j-1,k}) \\right).\n$$\nThis expression is valid for interior points $j = 1, \\dots, N_\\phi-2$.\n\nThe boundary conditions are zero normal flux at $\\phi = \\pm\\phi_{\\max}$. The meridional flux $F_\\phi$ must vanish at these boundaries. Since $\\phi_{\\max}  \\pi/2$, $\\cos(\\pm\\phi_{\\max}) \\neq 0$, so the condition simplifies to $\\frac{\\partial u}{\\partial \\phi} = 0$ at $\\phi = \\pm\\phi_{\\max}$.\nAt the lower boundary $\\phi_0 = -\\phi_{\\max}$, the incoming flux $F_{\\phi, -1/2}$ is zero. The discretization at $j=0$ becomes:\n$$\n\\left. \\Delta_S u \\right|_{0,k} \\approx \\frac{1}{\\cos \\phi_0 \\Delta\\phi^2} \\left( \\cos(\\phi_{1/2})(u_{1,k} - u_{0,k}) \\right) + \\frac{u_{0,k+1} - 2u_{0,k} + u_{0,k-1}}{\\cos^2 \\phi_0 \\Delta\\lambda^2}.\n$$\nAt the upper boundary $\\phi_{N_\\phi-1} = \\phi_{\\max}$, the outgoing flux $F_{\\phi, N_\\phi-1/2}$ is zero. The discretization at $j=N_\\phi-1$ becomes:\n$$\n\\left. \\Delta_S u \\right|_{N_\\phi-1,k} \\approx \\frac{1}{\\cos \\phi_{N_\\phi-1} \\Delta\\phi^2} \\left( -\\cos(\\phi_{N_\\phi-3/2})(u_{N_\\phi-1,k} - u_{N_\\phi-2,k}) \\right) + \\frac{u_{N_\\phi-1,k+1} - 2u_{N_\\phi-1,k} + u_{N_\\phi-1,k-1}}{\\cos^2 \\phi_{N_\\phi-1} \\Delta\\lambda^2}.\n$$\nThe semidiscrete system of ordinary differential equations is $\\frac{d\\mathbf{u}}{dt} = \\kappa A \\mathbf{u}$, where $\\mathbf{u}$ is the vector of all grid point values $u_{j,k}$ and $A$ is the matrix representation of the discrete Laplace-Beltrami operator. The entries of $A$ are determined by the stencils derived above. The size of matrix $A$ is $(N_\\phi N_\\lambda) \\times (N_\\phi N_\\lambda)$.\n\nThe problem requires that $A$ be diagonally similar to a real symmetric matrix. The continuous operator $\\Delta_S$ is self-adjoint with respect to the inner product containing the surface area element, $\\langle f, g \\rangle = \\iint f g \\cos\\phi \\,d\\phi\\,d\\lambda$. The discrete analogue of this property is that the matrix $D A$ should be symmetric, where $D$ is a diagonal matrix with entries $d_{j,k} = \\cos \\phi_j$. Let us verify this. Multiplying the $j$-th row of equations by $\\cos\\phi_j$, the meridional part becomes:\n$$\n\\frac{1}{\\Delta\\phi^2} \\left( \\cos(\\phi_{j+1/2}) u_{j+1,k} - (\\cos(\\phi_{j+1/2}) + \\cos(\\phi_{j-1/2})) u_{j,k} + \\cos(\\phi_{j-1/2}) u_{j-1,k} \\right).\n$$\nThis corresponds to a symmetric tridiagonal matrix for a fixed longitude $k$. The zonal part becomes:\n$$\n\\frac{1}{\\cos \\phi_j \\Delta\\lambda^2} (u_{j, k+1} - 2u_{j,k} + u_{j, k-1}).\n$$\nThe operator consisting of both terms, when assembled into the full matrix $M = D A$, is symmetric. Since $D$ is diagonal with positive entries $\\cos \\phi_j > 0$ for $|\\phi_j|  \\pi/2$, $A$ is similar to the symmetric matrix $D^{1/2} A D^{-1/2} = D^{-1/2} M D^{-1/2}$. This guarantees that the eigenvalues of $A$ are real. Furthermore, the operator $A$ represents diffusion, so its eigenvalues $\\lambda_i$ are non-positive, i.e., $\\lambda_i \\le 0$.\n\nFor numerical stability of the explicit (Forward) Euler scheme, $\\mathbf{u}^{n+1} = (I + \\Delta t \\kappa A)\\mathbf{u}^n$, the amplification factor for each eigenmode must have a magnitude no greater than $1$. For real, non-positive eigenvalues $\\kappa \\lambda_i$, the condition is $|1 + \\Delta t \\kappa \\lambda_i| \\le 1$. This implies $-2 \\le \\Delta t \\kappa \\lambda_i \\le 0$. Since $\\Delta t, \\kappa > 0$ and $\\lambda_i \\le 0$, this simplifies to $\\Delta t \\kappa \\lambda_{\\min} \\ge -2$, where $\\lambda_{\\min}$ is the minimum (most negative) eigenvalue of $A$. The largest stable time step is therefore\n$$\n\\Delta t_{\\max} = \\frac{-2}{\\kappa \\lambda_{\\min}(A)}.\n$$\nThe numerical stiffness arises from the $1/\\cos^2\\phi$ factor in the zonal term. As $\\phi_{\\max} \\to \\pi/2$, the grid lines of longitude converge. For a fixed $\\Delta\\lambda$, the physical distance between grid points in the zonal direction becomes very small, $\\cos\\phi_j \\Delta\\lambda$. The stability limit on $\\Delta t$ is controlled by the square of the smallest grid spacing in the domain, leading to $\\Delta t_{\\max} \\propto (\\cos\\phi_{\\max} \\Delta\\lambda)^2$. Consequently, for grids extending close to the poles or with high zonal resolution ($N_\\lambda$), $\\Delta t_{\\max}$ becomes prohibitively small, a classic symptom of numerical stiffness.\n\nThe final step is to computationally implement this procedure: assemble matrix $A$, find its minimum eigenvalue, and calculate $\\Delta t_{\\max}$ for the given test cases.", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef construct_operator_and_solve(N_phi, N_lambda, phi_max, kappa):\n    \"\"\"\n    Constructs the discrete operator for the heat equation on a spherical band\n    and computes the maximum stable time step for the explicit Euler method.\n    \"\"\"\n    # 1. Define grid parameters\n    phi = np.linspace(-phi_max, phi_max, N_phi, dtype=np.float64)\n    # Ensure robust calculation of delta_phi, especially if N_phi=1\n    if N_phi > 1:\n        delta_phi = (2.0 * phi_max) / (N_phi - 1)\n    else:\n        delta_phi = 1.0 # arbitrary, will not be used\n    delta_lambda = (2.0 * np.pi) / N_lambda\n\n    # 2. Assemble the discrete operator matrix A\n    N_total = N_phi * N_lambda\n    A = np.zeros((N_total, N_total), dtype=np.float64)\n\n    for j in range(N_phi):  # Latitude index from 0 to N_phi-1\n        # Precompute latitude-dependent coefficients\n        cos_phi_j = np.cos(phi[j])\n        lambda_coeff = 1.0 / (cos_phi_j**2 * delta_lambda**2)\n\n        for k in range(N_lambda):  # Longitude index from 0 to N_lambda-1\n            row_idx = j * N_lambda + k\n\n            # Zonal (longitude) part of the operator (periodic)\n            col_idx_km1 = j * N_lambda + (k - 1 + N_lambda) % N_lambda\n            col_idx_kp1 = j * N_lambda + (k + 1) % N_lambda\n            A[row_idx, col_idx_km1] += lambda_coeff\n            A[row_idx, col_idx_kp1] += lambda_coeff\n            A[row_idx, row_idx] -= 2.0 * lambda_coeff\n\n            # Meridional (latitude) part of the operator\n            if N_phi > 1:\n                phi_coeff_denom = cos_phi_j * delta_phi**2\n\n                if j == 0:  # Lower boundary (j=0), zero flux\n                    phi_j_plus_half = phi[j] + delta_phi / 2.0\n                    c_j_plus_half = np.cos(phi_j_plus_half)\n                    \n                    col_idx_jp1 = (j + 1) * N_lambda + k\n                    A[row_idx, col_idx_jp1] += c_j_plus_half / phi_coeff_denom\n                    A[row_idx, row_idx] -= c_j_plus_half / phi_coeff_denom\n\n                elif j == N_phi - 1:  # Upper boundary (j=N_phi-1), zero flux\n                    phi_j_minus_half = phi[j] - delta_phi / 2.0\n                    c_j_minus_half = np.cos(phi_j_minus_half)\n                    \n                    col_idx_jm1 = (j - 1) * N_lambda + k\n                    A[row_idx, col_idx_jm1] += c_j_minus_half / phi_coeff_denom\n                    A[row_idx, row_idx] -= c_j_minus_half / phi_coeff_denom\n\n                else:  # Interior points\n                    phi_j_plus_half = phi[j] + delta_phi / 2.0\n                    c_j_plus_half = np.cos(phi_j_plus_half)\n                    phi_j_minus_half = phi[j] - delta_phi / 2.0\n                    c_j_minus_half = np.cos(phi_j_minus_half)\n\n                    col_idx_jm1 = (j - 1) * N_lambda + k\n                    col_idx_jp1 = (j + 1) * N_lambda + k\n                    A[row_idx, col_idx_jm1] += c_j_minus_half / phi_coeff_denom\n                    A[row_idx, col_idx_jp1] += c_j_plus_half / phi_coeff_denom\n                    A[row_idx, row_idx] -= (c_j_plus_half + c_j_minus_half) / phi_coeff_denom\n\n    # 3. Compute eigenvalues and the minimum eigenvalue\n    # The matrix A is diagonally similar to a symmetric matrix, so eigenvalues are real.\n    eigenvalues = scipy.linalg.eigvals(A)\n    # Due to floating point arithmetic, small imaginary parts might appear.\n    lambda_min = np.min(np.real(eigenvalues))\n\n    # 4. Calculate the maximum stable time step\n    # The PDE system is du/dt = kappa * A * u. Eigenvalues of (kappa*A) are kappa*lambda_i.\n    # The stability condition is dt = -2 / (kappa * lambda_min).\n    if lambda_min >= 0:\n        # This case should not happen for a diffusion operator with at least 2 points.\n        # It implies the only eigenvalue is 0, e.g., for a 1-point grid.\n        # A matrix of zeros leads to lambda_min = 0, so dt_max would be infinite.\n        if N_total = 1:\n            return np.inf\n        else: # Should not happen, implies error in matrix construction\n            raise ValueError(\"Minimum eigenvalue is non-negative, invalid for diffusion.\")\n\n    dt_max = -2.0 / (kappa * lambda_min)\n    return dt_max\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (N_phi, N_lambda, phi_max, kappa)\n        (24, 48, np.pi / 2.0 - 0.2, 1.0),\n        (24, 96, np.pi / 2.0 - 0.02, 1.0),\n        (24, 48, np.pi / 4.0, 1.0),\n        (24, 96, np.pi / 2.0 - 0.2, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        dt_max = construct_operator_and_solve(*case)\n        results.append(dt_max)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2436359"}]}