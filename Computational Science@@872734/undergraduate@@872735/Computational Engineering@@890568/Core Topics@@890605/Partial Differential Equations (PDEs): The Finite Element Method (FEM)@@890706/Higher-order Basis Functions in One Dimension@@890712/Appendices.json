{"hands_on_practices": [{"introduction": "Theory becomes much clearer with practice. Our first exercise demonstrates the primary advantage of higher-order basis functions: their ability to represent complex solution profiles with remarkable accuracy. We will apply a single quadratic finite element to model the parabolic velocity profile of Poiseuille flow, a fundamental problem in fluid mechanics, and see how it can capture the exact analytical solution. [@problem_id:2399658]", "problem": "Consider steady, fully developed planar Poiseuille flow along the $x$-direction between two parallel plates located at $y=0$ and $y=H$. Let the constant pressure gradient be $g \\equiv -\\mathrm{d}p/\\mathrm{d}x > 0$ and the dynamic viscosity be $\\mu > 0$. The axial velocity $u(y)$ satisfies the one-dimensional boundary value problem\n$$-\\mu \\, u''(y) = g \\quad \\text{for } y \\in (0,H), \\qquad u(0)=0, \\quad u(H)=0.$$\nUsing the standard Galerkin finite element method (FEM) with a single quadratic element of polynomial degree $p=2$ spanning the interval $[0,H]$, employ Lagrange basis functions associated with the nodes at $y=0$, $y=H/2$, and $y=H$. Enforce the essential boundary conditions strongly at the boundary nodes.\n\nDetermine the $3$-component vector of nodal values $\\big(u(0),\\,u(H/2),\\,u(H)\\big)$ produced by this discretization. Report your final answer as a dimensionless $1 \\times 3$ row vector obtained by dividing each component by $(g H^{2}/\\mu)$. No numerical rounding is required, and no units should be included in the reported vector.", "solution": "The problem is first subjected to validation.\n\n**Step 1: Extract Givens**\n- Governing Equation: $-\\mu \\, u''(y) = g$ for $y \\in (0,H)$.\n- Constants: $g \\equiv -\\mathrm{d}p/\\mathrm{d}x > 0$ and $\\mu > 0$.\n- Boundary Conditions: $u(0)=0$, $u(H)=0$.\n- Method: Standard Galerkin finite element method (FEM).\n- Discretization: One quadratic element ($p=2$) over the domain $[0,H]$.\n- Nodal Coordinates: $y=0$, $y=H/2$, $y=H$.\n- Basis Functions: Lagrange basis functions associated with the nodes.\n- Boundary Condition Enforcement: Strong enforcement at boundary nodes.\n- Required Output: The dimensionless $1 \\times 3$ row vector of nodal values $\\big(u(0), u(H/2), u(H)\\big)$ after division by $(g H^{2}/\\mu)$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem describes planar Poiseuille flow, a fundamental concept in fluid dynamics. The governing equation is a valid simplification of the Navier-Stokes equations for this flow regime. The problem is scientifically sound.\n- **Well-Posed:** The problem is a one-dimensional, second-order elliptic boundary value problem with Dirichlet boundary conditions. A unique and stable solution is guaranteed to exist. The FEM formulation is also standard and well-posed.\n- **Objective:** The problem is stated using precise mathematical and physical terminology, free of any subjectivity or ambiguity.\n- **Completeness and Consistency:** The problem provides all necessary information (governing equation, domain, boundary conditions, and discretization details) and contains no internal contradictions.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is a well-defined problem in computational engineering that is scientifically grounded, well-posed, and complete. A rigorous solution can be derived.\n\nThe weak form of the boundary value problem is derived by multiplying the governing equation by a test function $v(y)$ from a suitable space and integrating over the domain $\\Omega = (0,H)$.\n$$\n\\int_{0}^{H} -\\mu u''(y) v(y) \\, dy = \\int_{0}^{H} g v(y) \\, dy\n$$\nApplying integration by parts to the left-hand side yields:\n$$\n\\int_{0}^{H} \\mu u'(y) v'(y) \\, dy - \\big[ \\mu u'(y) v(y) \\big]_{0}^{H} = \\int_{0}^{H} g v(y) \\, dy\n$$\nThe test function $v(y)$ must belong to the space of functions for which the integral is defined and which satisfy the homogeneous essential boundary conditions, i.e., $v(0)=0$ and $v(H)=0$. Therefore, the boundary term $\\big[ \\mu u'(y) v(y) \\big]_{0}^{H}$ vanishes. The weak formulation is: find $u(y)$ satisfying the essential boundary conditions such that\n$$\n\\int_{0}^{H} \\mu u'(y) v'(y) \\, dy = \\int_{0}^{H} g v(y) \\, dy\n$$\nfor all admissible test functions $v(y)$.\n\nIn the finite element method, the unknown function $u(y)$ is approximated by a linear combination of basis functions, $u_h(y) = \\sum_{j=1}^{3} U_j N_j(y)$, where $U_j$ are the unknown nodal values and $N_j(y)$ are the basis functions. The problem specifies a single quadratic element with nodes at $y_1=0$, $y_2=H/2$, and $y_3=H$. The corresponding Lagrange basis functions, which satisfy $N_j(y_i) = \\delta_{ij}$, are:\n$$\nN_1(y) = \\frac{(y - H/2)(y - H)}{(0 - H/2)(0 - H)} = \\frac{2}{H^2} \\left(y^2 - \\frac{3}{2}Hy + \\frac{H^2}{2}\\right)\n$$\n$$\nN_2(y) = \\frac{(y - 0)(y - H)}{(H/2 - 0)(H/2 - H)} = -\\frac{4}{H^2} (y^2 - Hy)\n$$\n$$\nN_3(y) = \\frac{(y - 0)(y - H/2)}{(H - 0)(H - H/2)} = \\frac{2}{H^2} \\left(y^2 - \\frac{1}{2}Hy\\right)\n$$\nThe problem states that the essential boundary conditions $u(0)=0$ and $u(H)=0$ are enforced strongly. This means the nodal values at the boundaries are fixed: $U_1 = u(0) = 0$ and $U_3 = u(H) = 0$. The approximation for the velocity field simplifies to $u_h(y) = U_2 N_2(y)$, as the terms with $N_1(y)$ and $N_3(y)$ are zero.\n\nIn the Galerkin method, the test functions are chosen from the same set as the basis functions. For the single unknown $U_2$, we need only one equation, which is obtained by choosing the test function $v(y) = N_2(y)$. This is the only basis function that is non-zero at the interior node and zero at the boundaries. Substituting $u_h(y)$ and $v(y)=N_2(y)$ into the weak form gives:\n$$\n\\int_{0}^{H} \\mu (U_2 N_2'(y)) (N_2'(y)) \\, dy = \\int_{0}^{H} g N_2(y) \\, dy\n$$\nThis is a single linear equation for the unknown $U_2$:\n$$\n\\left( \\mu \\int_{0}^{H} (N_2'(y))^2 \\, dy \\right) U_2 = g \\int_{0}^{H} N_2(y) \\, dy\n$$\nWe must compute the two integrals. First, the derivative of $N_2(y)$:\n$$\nN_2'(y) = \\frac{d}{dy}\\left(-\\frac{4y^2}{H^2} + \\frac{4y}{H}\\right) = -\\frac{8y}{H^2} + \\frac{4}{H}\n$$\nThe integral on the left-hand side is:\n$$\n\\int_{0}^{H} (N_2'(y))^2 \\, dy = \\int_{0}^{H} \\left(\\frac{4}{H} - \\frac{8y}{H^2}\\right)^2 \\, dy = \\int_{0}^{H} \\left(\\frac{16}{H^2} - \\frac{64y}{H^3} + \\frac{64y^2}{H^4}\\right) \\, dy\n$$\n$$\n= \\left[ \\frac{16y}{H^2} - \\frac{32y^2}{H^3} + \\frac{64y^3}{3H^4} \\right]_{0}^{H} = \\frac{16}{H} - \\frac{32}{H} + \\frac{64}{3H} = \\left(16 - 32 + \\frac{64}{3}\\right)\\frac{1}{H} = \\left(-16 + \\frac{64}{3}\\right)\\frac{1}{H} = \\frac{-48+64}{3H} = \\frac{16}{3H}\n$$\nThe integral on the right-hand side is:\n$$\n\\int_{0}^{H} N_2(y) \\, dy = \\int_{0}^{H} \\left(-\\frac{4y^2}{H^2} + \\frac{4y}{H}\\right) \\, dy = \\left[ -\\frac{4y^3}{3H^2} + \\frac{2y^2}{H} \\right]_{0}^{H} = -\\frac{4H}{3} + 2H = \\frac{2H}{3}\n$$\nSubstituting these results back into the equation for $U_2$:\n$$\n\\left( \\mu \\frac{16}{3H} \\right) U_2 = g \\frac{2H}{3}\n$$\nSolving for $U_2$:\n$$\nU_2 = \\frac{g \\cdot 2H/3}{\\mu \\cdot 16/(3H)} = \\frac{2gH}{3} \\cdot \\frac{3H}{16\\mu} = \\frac{6gH^2}{48\\mu} = \\frac{1}{8} \\frac{gH^2}{\\mu}\n$$\nThe vector of nodal values is $\\big(U_1, U_2, U_3\\big) = \\left(0, \\frac{1}{8}\\frac{gH^2}{\\mu}, 0\\right)$.\nTo obtain the required dimensionless vector, each component is divided by the scaling factor $(gH^2/\\mu)$:\n$$\n\\left( \\frac{0}{gH^2/\\mu}, \\frac{\\frac{1}{8}gH^2/\\mu}{gH^2/\\mu}, \\frac{0}{gH^2/\\mu} \\right) = \\left(0, \\frac{1}{8}, 0\\right)\n$$\nThis result is exact because the analytical solution to this problem, $u(y) = \\frac{g}{2\\mu}(Hy - y^2)$, is a quadratic polynomial, which can be represented exactly by the quadratic basis functions used in the discretization.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & \\frac{1}{8} & 0\n\\end{pmatrix}\n}\n$$", "id": "2399658"}, {"introduction": "Implementing higher-order methods, such as the Finite Element Method from our previous example, requires the numerical evaluation of integrals. This practice explores a critical pitfall in that process: aliasing error from under-integration. By attempting to integrate the square of a Legendre polynomial with an insufficient number of quadrature points, you will directly observe how numerical inaccuracies can arise and corrupt the results. [@problem_id:2399644]", "problem": "You are to investigate aliasing error arising from under-integration when using higher-order basis functions in one dimension. Consider the Legendre polynomial of degree $p$, denoted $P_{p}(x)$, on the interval $[-1,1]$, where $P_{0}(x)=1$ and $P_{p}(x)$ satisfies the standard three-term recurrence for Legendre polynomials. The inner product is the standard $L^{2}$ inner product on $[-1,1]$ with weight $1$. The polynomial $P_{p}(x)$ is of degree $p$. Gaussian Quadrature (GQ) with $n$ Gauss-Legendre points on $[-1,1]$ is exact for all polynomials up to and including degree $2n-1$.\n\nYour task is to write a program that:\n- Computes the exact value of the integral $\\int_{-1}^{1} \\left(P_{p}(x)\\right)^{2}\\,dx$ by analytical reasoning based on the orthogonality and normalization of $P_{p}(x)$.\n- Approximates the same integral using $n$-point Gauss-Legendre quadrature on $[-1,1]$.\n- Quantifies the absolute aliasing error as the absolute difference between the quadrature approximation and the exact value.\n\nFundamental base for derivation:\n- Legendre polynomials $\\{P_{k}(x)\\}_{k\\ge 0}$ form an orthogonal basis on $[-1,1]$ with respect to the weight $1$.\n- $n$-point Gauss-Legendre quadrature is exact for all polynomials of degree at most $2n-1$.\n\nImplement the algorithm in a single, self-contained program. For the analytical value, do not use any numerical integration; use only properties following from orthogonality and normalization of $P_{p}(x)$ as the basis in $L^{2}([-1,1])$.\n\nTest suite:\n- Use the following $(p,n)$ pairs to exercise general, exact, and under-integrated (aliasing) scenarios: $(p,n)\\in\\{(0,1),(1,1),(1,2),(3,3),(3,4),(5,5),(5,6),(10,5),(10,11)\\}$.\n- For each pair $(p,n)$, compute the absolute error $E(p,n)=\\left|\\;\\text{GQ}_{n}\\left[\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx\\right]-\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx\\;\\right|$.\n- Report each $E(p,n)$ as a floating-point number rounded to $12$ decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., [$r_{1}$,$r_{2}$,$r_{3}$]), ordered in the same order as the test suite above.\n- No additional text should be printed.\n\nAngle units are not applicable. No physical units are involved. The program must not require any user input or external files and must run deterministically in a standard environment.", "solution": "We begin from first principles appropriate to higher-order basis functions in one dimension, specifically Legendre polynomials and Gaussian Quadrature (GQ). The Legendre polynomials $\\{P_{p}(x)\\}_{p\\ge 0}$ form a complete orthogonal basis for square-integrable functions on $[-1,1]$ with respect to the weight function $w(x)=1$. Orthogonality means that for integers $p\\neq q$,\n$$\n\\int_{-1}^{1} P_{p}(x)\\,P_{q}(x)\\,dx=0.\n$$\nMoreover, $P_{p}(x)$ is a degree-$p$ polynomial normalized by the convention $P_{0}(x)=1$ and $P_{p}(1)=1$. The exact squared $L^{2}$ norm of $P_{p}$ on $[-1,1]$ is given by the well-tested and standard identity\n$$\n\\int_{-1}^{1} \\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{2}{2p+1}.\n$$\nOne can justify this normalization constant from the Rodrigues formula and integration by parts. The Rodrigues formula states\n$$\nP_{p}(x)=\\frac{1}{2^{p}p!}\\frac{d^{p}}{dx^{p}}\\left(x^{2}-1\\right)^{p}.\n$$\nThen\n$$\n\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{1}{(2^{p}p!)^{2}}\\int_{-1}^{1}\\left[\\frac{d^{p}}{dx^{p}}\\left(x^{2}-1\\right)^{p}\\right]P_{p}(x)\\,dx.\n$$\nIntegrating by parts $p$ times moves derivatives from $\\left(x^{2}-1\\right)^{p}$ onto $P_{p}(x)$, with zero boundary contributions because $\\left(x^{2}-1\\right)^{p}$ has zeros of order $p$ at $x=\\pm 1$. This yields\n$$\n\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{1}{(2^{p}p!)^{2}}\\int_{-1}^{1}\\left(x^{2}-1\\right)^{p}\\frac{d^{p}}{dx^{p}}P_{p}(x)\\,dx.\n$$\nSince $P_{p}(x)$ is a degree-$p$ polynomial with leading coefficient $\\frac{1}{2^{p}}\\binom{2p}{p}$, its $p$-th derivative is the constant\n$$\n\\frac{d^{p}}{dx^{p}}P_{p}(x)=p!\\cdot\\frac{1}{2^{p}}\\binom{2p}{p}=\\frac{(2p)!}{2^{p}p!}.\n$$\nTherefore,\n$$\n\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{1}{(2^{p}p!)^{2}}\\cdot\\frac{(2p)!}{2^{p}p!}\\int_{-1}^{1}\\left(x^{2}-1\\right)^{p}\\,dx.\n$$\nUsing the evenness of the integrand, the Beta function identity, or direct evaluation, one arrives at the closed form\n$$\n\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{2}{2p+1}.\n$$\nThis exact value will serve as the analytical baseline.\n\nNext, consider $n$-point Gauss-Legendre quadrature on $[-1,1]$. A fundamental property of Gauss-Legendre quadrature is exactness for polynomials of degree at most $2n-1$. The function $f(x)=\\left(P_{p}(x)\\right)^{2}$ is a polynomial of degree $2p$. Consequently:\n- If $2p\\le 2n-1$, that is $n\\ge p+1$, the quadrature is exact for $f$ and the numerical integral equals the analytical value $\\frac{2}{2p+1}$ up to roundoff errors.\n- If $2p>2n-1$, that is $n\\le p$, the quadrature under-integrates $f$. In this under-integrated regime, high-degree components of $f$ cannot be exactly represented by the quadrature rule and effectively alias into lower-degree modes in the discrete sense. This is the aliasing error: the quadrature returns the exact integral of the best approximation of $f$ within polynomials of degree at most $2n-1$, not the true integral of $f$.\n\nAlgorithmic plan:\n- For given integers $p$ and $n$, define $f(x)=\\left(P_{p}(x)\\right)^{2}$.\n- Compute the exact value $I_{\\text{exact}}(p)=\\frac{2}{2p+1}$.\n- Compute the $n$-point Gauss-Legendre quadrature nodes $\\{x_{i}\\}_{i=1}^{n}$ and weights $\\{w_{i}\\}_{i=1}^{n}$ on $[-1,1]$. Evaluate\n$$\nI_{\\text{GQ}}(p,n)=\\sum_{i=1}^{n}w_{i}\\,f(x_{i}).\n$$\n- Report the absolute error $E(p,n)=\\left|I_{\\text{GQ}}(p,n)-I_{\\text{exact}}(p)\\right|$.\n\nImplementation details:\n- Evaluate $P_{p}(x)$ using a stable basis evaluation routine for Legendre polynomials; in code, one can use a basis representation and evaluation function for $P_{p}(x)$.\n- Obtain Gauss-Legendre nodes and weights programmatically.\n- For the test suite $(p,n)\\in\\{(0,1),(1,1),(1,2),(3,3),(3,4),(5,5),(5,6),(10,5),(10,11)\\}$, compute $E(p,n)$ and print them in order, each rounded to $12$ decimal places, as a single bracketed, comma-separated list.\n\nExpected qualitative behavior:\n- Cases with $n\\ge p+1$ should yield errors near machine precision, which round to approximately $0$ when rounded to $12$ decimal places.\n- Cases with $n\\le p$ exhibit nonzero aliasing errors because $2p>2n-1$.\n\nThis approach directly connects the higher-order basis function $P_{p}(x)$, the degree-of-exactness property of Gaussian Quadrature, and the manifestation of aliasing error when the quadrature order is insufficient to integrate the squared basis function exactly.", "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss, legval\n\ndef legendre_P(p, x):\n    \"\"\"\n    Evaluate the Legendre polynomial P_p(x) at x using numpy's Legendre basis.\n    \"\"\"\n    # Coefficients in the Legendre basis: c[k] corresponds to P_k(x).\n    c = np.zeros(p + 1, dtype=float)\n    c[p] = 1.0\n    return legval(x, c)\n\ndef exact_integral_Pp_squared(p):\n    \"\"\"\n    Exact value of the integral of (P_p(x))^2 over [-1,1]:\n        ∫_{-1}^{1} (P_p(x))^2 dx = 2 / (2p + 1)\n    \"\"\"\n    return 2.0 / (2 * p + 1)\n\ndef gauss_legendre_integral_Pp_squared(p, n):\n    \"\"\"\n    Compute the n-point Gauss-Legendre quadrature of (P_p(x))^2 over [-1,1].\n    \"\"\"\n    x, w = leggauss(n)\n    P_vals = legendre_P(p, x)\n    f_vals = P_vals * P_vals\n    return np.dot(w, f_vals)\n\ndef solve():\n    # Define the test cases (p, n) as specified in the problem statement.\n    test_cases = [\n        (0, 1),\n        (1, 1),\n        (1, 2),\n        (3, 3),\n        (3, 4),\n        (5, 5),\n        (5, 6),\n        (10, 5),\n        (10, 11),\n    ]\n\n    results = []\n    for p, n in test_cases:\n        I_exact = exact_integral_Pp_squared(p)\n        I_quad = gauss_legendre_integral_Pp_squared(p, n)\n        err = abs(I_quad - I_exact)\n        # Round to 12 decimal places as required\n        results.append(f\"{err:.12f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2399644"}, {"introduction": "While higher-order polynomials excel at approximating smooth functions, they can struggle with sharp gradients or discontinuities. This exercise confronts that limitation by tasking you with approximating a simple step function using an $L^2$ projection onto a Legendre polynomial basis. You will quantify the resulting \"overshoot\" near the jump—a classic example of the Gibbs phenomenon—and see how it behaves as the polynomial degree increases. [@problem_id:2399650]", "problem": "You will write a complete, runnable program that constructs the square-integrable (Lebesgue $L^2$) orthogonal projection of a discontinuous function onto a one-dimensional polynomial subspace and then quantifies the resulting Gibbs-like overshoot near the discontinuity as a function of the polynomial degree. Work on the reference interval $[-1,1]$. Consider the step function $f:[-1,1]\\to\\mathbb{R}$ defined by $f(x)=0$ for $x<0$ and $f(x)=1$ for $x\\ge 0$. For a given nonnegative integer degree $p$, define the polynomial subspace $\\mathcal{P}_p$ as the set of all real polynomials of degree at most $p$. Using the weight function equal to $1$ on $[-1,1]$, define the $L^2$ projection $u_p\\in \\mathcal{P}_p$ of $f$ as the unique element that minimizes the $L^2$ error $\\|f-u\\|_{L^2([-1,1])}$ over all $u\\in\\mathcal{P}_p$. Represent $u_p$ in the modal basis of Legendre polynomials $\\{P_n\\}_{n=0}^p$ on $[-1,1]$, which are orthogonal with respect to the $L^2$ inner product with unit weight. Starting only from the orthogonality of the Legendre polynomials and the definition of the $L^2$ projection, derive the coefficients of $u_p$ in this basis. Do not use any pre-derived projection formulas; the derivation must follow from the orthogonality relations and the definition of projection. Then, evaluate $u_p$ on a uniform grid to measure the Gibbs-like overshoot near the jump at $x=0$. For a fixed window half-width $w=0.2$, define the right-neighborhood $\\Omega_R=(0,w]$ and the left-neighborhood $\\Omega_L=[-w,0)$. On a uniform grid of $M=20001$ points covering $[-w,w]$, compute the overshoot magnitude\n$$\n\\Gamma_p=\\max\\left\\{\\max_{x\\in\\Omega_R}\\left(u_p(x)-1\\right),\\ \\max_{x\\in\\Omega_L}\\left(-u_p(x)\\right),\\ 0\\right\\}.\n$$\nYour program must carry out the following steps for each degree $p$ in a specified test suite: construct $u_p$ via $L^2$ projection onto $\\mathcal{P}_p$ in the Legendre basis, evaluate $u_p$ on the specified grid, and compute $\\Gamma_p$ as defined above. Use the following test suite of polynomial degrees: $\\{0,1,3,5,10,20\\}$. All computations are dimensionless; no physical units are involved. The final output format must be a single line containing a Python list of floating-point values $[\\Gamma_{p_1},\\Gamma_{p_2},\\dots]$ corresponding to the degrees in the order $[0,1,3,5,10,20]$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4,r_5,r_6]$). The result for each $p$ must be a float. Ensure scientific realism by adhering to the exact definitions above, and design your computation to be numerically stable and reproducible with the specified grid parameters $w=0.2$ and $M=20001$ points. The algorithm must be derivable from the orthogonality of Legendre polynomials and the definition of $L^2$ projection without introducing any external shortcut formulas in the problem statement.", "solution": "The problem requires the construction and analysis of the $L^2$ orthogonal projection of a discontinuous function onto a space of one-dimensional polynomials. The objective is to quantify the Gibbs phenomenon, specifically the overshoot near the discontinuity at $x=0$, as a function of the polynomial degree $p$.\n\nThe function to be approximated is the step function $f:[-1,1] \\to \\mathbb{R}$ defined as\n$$\nf(x) = \\begin{cases} 0 & \\text{if } x < 0 \\\\ 1 & \\text{if } x \\ge 0 \\end{cases}\n$$\nWe seek its $L^2$ projection, denoted $u_p$, onto the subspace $\\mathcal{P}_p$ of polynomials of degree at most $p$. The space $\\mathcal{P}_p$ is a subspace of the Hilbert space $L^2([-1, 1])$ equipped with the inner product $(g, h) = \\int_{-1}^{1} g(x)h(x)dx$ and norm $\\|g\\|_{L^2} = \\sqrt{(g, g)}$. By definition, the projection $u_p \\in \\mathcal{P}_p$ is the unique element that minimizes the error norm $\\|f-u_p\\|_{L^2}$ over all possible choices of $u_p \\in \\mathcal{P}_p$.\n\nA fundamental property of the $L^2$ projection is that the error vector, $f-u_p$, is orthogonal to the subspace $\\mathcal{P}_p$. This is known as the Galerkin orthogonality condition:\n$$\n(f - u_p, v) = 0, \\quad \\forall v \\in \\mathcal{P}_p.\n$$\nWe represent the approximation $u_p(x)$ in the basis of Legendre polynomials, $\\{P_n(x)\\}_{n=0}^p$, which are orthogonal on the interval $[-1, 1]$ with a weight function of $1$. The expansion is\n$$\nu_p(x) = \\sum_{n=0}^{p} \\hat{f}_n P_n(x),\n$$\nwhere the coefficients $\\{\\hat{f}_n\\}_{n=0}^p$ are to be determined. Since the Legendre polynomials $\\{P_k(x)\\}_{k=0}^p$ form a basis for $\\mathcal{P}_p$, the Galerkin condition is satisfied if and only if the error is orthogonal to each basis function:\n$$\n(f - u_p, P_k) = 0, \\quad \\text{for } k=0, 1, \\dots, p.\n$$\nSubstituting the expansion of $u_p$ into this equation, we have:\n$$\n\\left(f - \\sum_{n=0}^{p} \\hat{f}_n P_n, P_k\\right) = 0.\n$$\nBy the linearity of the inner product:\n$$\n(f, P_k) - \\sum_{n=0}^{p} \\hat{f}_n (P_n, P_k) = 0.\n$$\nWe now invoke the orthogonality relation for Legendre polynomials:\n$$\n(P_n, P_k) = \\int_{-1}^{1} P_n(x) P_k(x) dx = \\frac{2}{2n+1}\\delta_{nk},\n$$\nwhere $\\delta_{nk}$ is the Kronecker delta. The sum collapses, as only the term with $n=k$ is non-zero:\n$$\n(f, P_k) - \\hat{f}_k (P_k, P_k) = 0 \\implies (f, P_k) - \\hat{f}_k \\frac{2}{2k+1} = 0.\n$$\nSolving for the coefficient $\\hat{f}_k$ yields the general formula for the projection coefficients:\n$$\n\\hat{f}_k = \\frac{2k+1}{2} (f, P_k) = \\frac{2k+1}{2} \\int_{-1}^{1} f(x)P_k(x) dx.\n$$\nThis derivation proceeds directly from the definition of the $L^2$ projection and the orthogonality of the basis, as required by the problem statement.\n\nNext, we compute the coefficients for the specified step function $f(x)$. The integral becomes:\n$$\n\\int_{-1}^{1} f(x)P_k(x) dx = \\int_{-1}^{0} (0) \\cdot P_k(x) dx + \\int_{0}^{1} (1) \\cdot P_k(x) dx = \\int_{0}^{1} P_k(x) dx.\n$$\nThus, the coefficients are given by $\\hat{f}_k = \\frac{2k+1}{2} \\int_{0}^{1} P_k(x) dx$. To evaluate this integral, we use the identity for Legendre polynomials valid for $k \\ge 1$: $(2k+1)P_k(x) = P'_{k+1}(x) - P'_{k-1}(x)$. Integrating from $0$ to $1$:\n$$\n\\int_{0}^{1} (2k+1)P_k(x) dx = \\left[ P_{k+1}(x) - P_{k-1}(x) \\right]_0^1.\n$$\n$$\n(2k+1)\\int_{0}^{1} P_k(x) dx = (P_{k+1}(1) - P_{k-1}(1)) - (P_{k+1}(0) - P_{k-1}(0)).\n$$\nUsing the property $P_n(1) = 1$ for all $n \\ge 0$, the first term vanishes: $1-1=0$. This gives, for $k \\ge 1$:\n$$\n\\int_{0}^{1} P_k(x) dx = \\frac{P_{k-1}(0) - P_{k+1}(0)}{2k+1}.\n$$\nSubstituting this back into the formula for $\\hat{f}_k$:\n$$\n\\hat{f}_k = \\frac{2k+1}{2} \\left(\\frac{P_{k-1}(0) - P_{k+1}(0)}{2k+1}\\right) = \\frac{P_{k-1}(0) - P_{k+1}(0)}{2}, \\quad \\text{for } k \\ge 1.\n$$\nFor the base case $k=0$, we compute directly:\n$$\n\\hat{f}_0 = \\frac{2(0)+1}{2} \\int_{0}^{1} P_0(x) dx = \\frac{1}{2} \\int_{0}^{1} 1 dx = \\frac{1}{2}.\n$$\nWe also know that $P_n(0) = 0$ for all odd $n$. Consequently, for an even index $k \\ge 2$, both $k-1$ and $k+1$ are odd, which means $P_{k-1}(0)=0$ and $P_{k+1}(0)=0$. Therefore, $\\hat{f}_k = 0$ for all even $k \\ge 2$.\nIn summary, the coefficients are:\n$$\n\\hat{f}_k = \\begin{cases} 1/2 & \\text{if } k = 0 \\\\ 0 & \\text{if } k \\ge 2 \\text{ is even} \\\\ \\frac{P_{k-1}(0) - P_{k+1}(0)}{2} & \\text{if } k \\text{ is odd} \\end{cases}\n$$\nWith these coefficients, the polynomial approximation $u_p(x)$ is fully defined for any degree $p$.\n\nThe final step is to quantify the overshoot magnitude $\\Gamma_p$ for the given degrees $p \\in \\{0, 1, 3, 5, 10, 20\\}$. A uniform grid of $M=20001$ points is generated over the interval $[-w, w]$ where $w=0.2$. The approximation $u_p(x)$ is evaluated at each point on this grid. The overshoot is then computed according to the formula:\n$$\n\\Gamma_p=\\max\\left\\{\\max_{x\\in\\Omega_R}\\left(u_p(x)-1\\right),\\ \\max_{x\\in\\Omega_L}\\left(-u_p(x)\\right),\\ 0\\right\\},\n$$\nwhere $\\Omega_R=(0, w]$ and $\\Omega_L=[-w, 0)$. The algorithm implemented in the final answer calculates these coefficients, constructs $u_p(x)$ for each specified degree, evaluates it on the grid, and computes $\\Gamma_p$ by finding the maximum deviations in the left and right neighborhoods of the discontinuity. The inclusion of $0$ in the outer $\\max$ function ensures that in cases of undershoot (or no overshoot), the reported value is $0$.", "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre\nfrom numpy.polynomial.legendre import Legendre\n\ndef solve():\n    \"\"\"\n    Computes the Gibbs-like overshoot for the L2 projection of a step function\n    onto polynomial subspaces of varying degrees.\n    \"\"\"\n    # Define the test cases (polynomial degrees) from the problem statement.\n    test_cases = [0, 1, 3, 5, 10, 20]\n\n    # Grid parameters for overshoot evaluation\n    w = 0.2\n    M = 20001\n    \n    # Generate the grid on which the approximation is evaluated.\n    x_grid = np.linspace(-w, w, M)\n    results = []\n\n    for p in test_cases:\n        # Step 1: Compute coefficients of the L2 projection in the Legendre basis.\n        # This implementation follows the derivation from first principles.\n        coeffs = np.zeros(p + 1)\n        \n        # Coefficient for k=0 is always 0.5 for this step function.\n        coeffs[0] = 0.5\n        \n        # Coefficients for k > 0.\n        if p > 0:\n            for k in range(1, p + 1):\n                if k % 2 == 1:  # k is odd\n                    # Formula from derivation: f_hat_k = (P_{k-1}(0) - P_{k+1}(0)) / 2\n                    p_km1_at_0 = eval_legendre(k - 1, 0)\n                    p_kp1_at_0 = eval_legendre(k + 1, 0)\n                    coeffs[k] = (p_km1_at_0 - p_kp1_at_0) / 2.0\n                else:  # k is even and k >= 2. The coefficient is 0.\n                    coeffs[k] = 0.0\n        \n        # Step 2: Construct the polynomial approximation u_p(x) using the coefficients.\n        # The Legendre class from numpy.polynomial creates a callable polynomial object.\n        u_p = Legendre(coeffs, domain=[-1, 1])\n        \n        # Step 3: Evaluate u_p on the specified grid near the discontinuity.\n        u_p_vals = u_p(x_grid)\n        \n        # Step 4: Compute the overshoot magnitude Gamma_p.\n        # The problem defines Omega_R = (0, w] and Omega_L = [-w, 0).\n        # Using boolean masks correctly partitions the grid according to these definitions.\n        \n        # Right-neighborhood Omega_R = (0, w]\n        mask_R = x_grid > 0\n        u_p_R = u_p_vals[mask_R]\n        \n        if u_p_R.size > 0:\n            overshoot_R = np.max(u_p_R - 1.0)\n        else:\n            # This case would occur if the grid had no points > 0.\n            overshoot_R = -np.inf\n\n        # Left-neighborhood Omega_L = [-w, 0)\n        mask_L = x_grid  0\n        u_p_L = u_p_vals[mask_L]\n        \n        if u_p_L.size > 0:\n            overshoot_L = np.max(-u_p_L)\n        else:\n            # This case would occur if the grid had no points  0.\n            overshoot_L = -np.inf\n        \n        # Gamma_p is the maximum of the right overshoot, left overshoot, and zero.\n        # The max with zero ensures no negative value is reported (i.e., accounts for undershoot).\n        gamma_p = np.max([overshoot_R, overshoot_L, 0.0])\n        results.append(gamma_p)\n\n    # Final print statement must be in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2399650"}]}