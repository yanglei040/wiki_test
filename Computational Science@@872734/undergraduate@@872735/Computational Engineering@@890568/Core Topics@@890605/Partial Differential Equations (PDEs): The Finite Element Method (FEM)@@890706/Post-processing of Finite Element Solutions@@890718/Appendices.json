{"hands_on_practices": [{"introduction": "Before trusting complex results from a simulation, it is essential to perform sanity checks. A powerful verification step is to confirm that the numerical solution respects fundamental physical laws, such as the conservation of energy. In this practice, you will use the results of a heat transfer analysis to calculate heat fluxes and verify the local energy balance at an internal node, a crucial skill for building confidence in your finite element solutions [@problem_id:2426726].", "problem": "Consider steady, one-dimensional heat conduction along a composite bar aligned with the $x$-axis, composed of two linear finite elements with nodes at positions $x_0=0$ m, $x_1=0.3$ m, and $x_2=0.5$ m. The cross-sectional area is constant, $A=0.01$ m$^2$. The thermal conductivity is piecewise constant: $k_1=48$ W m$^{-1}$ K$^{-1}$ on the interval $[x_0,x_1]$ and $k_2=32$ W m$^{-1}$ K$^{-1}$ on $[x_1,x_2]$. There is no internal heat generation anywhere in the bar and no concentrated source or sink at the internal node at $x_1$. A finite element analysis has produced the following nodal temperatures: $T_0=120$ K at $x_0$, $T_1=100$ K at $x_1$, and $T_2=80$ K at $x_2$.\n\nDefine the net heat rate into node $x_1$ as the algebraic sum of the heat rate entering from the left element and the heat rate entering from the right element (with positive sign convention taken as heat entering the node). Using only first principles, determine the net heat rate into node $x_1$ based on the given nodal temperatures and material data. Express your final answer in watts (W) and round to four significant figures.", "solution": "The fundamental principle governing one-dimensional, steady-state heat conduction is Fourier's Law, which states that the heat rate, $q$, is proportional to the area, $A$, and the temperature gradient, $\\frac{dT}{dx}$. The expression is:\n$$q = -kA \\frac{dT}{dx}$$\nFor a linear finite element, the temperature varies linearly between the nodes. Therefore, the temperature gradient within an element is constant and can be approximated as the difference in nodal temperatures divided by the element length.\n\nWe must calculate the net heat rate into node $x_1$. This is the sum of the heat rate entering from the left element (element $1$) and the heat rate entering from the right element (element $2$).\n\nFirst, consider the heat rate entering node $x_1$ from element $1$, which spans the interval $[x_0, x_1]$. Let us denote this heat rate as $q_{1 \\to 1}$. This is the heat flow in the positive $x$-direction evaluated at $x = x_1$. The length of element $1$ is $L_1 = x_1 - x_0 = 0.3 - 0 = 0.3$ m. The temperature gradient in this element is:\n$$\\left(\\frac{dT}{dx}\\right)_1 = \\frac{T_1 - T_0}{L_1} = \\frac{100 \\text{ K} - 120 \\text{ K}}{0.3 \\text{ m}} = \\frac{-20}{0.3} \\text{ K/m}$$\nThe heat rate flowing through element $1$ in the positive $x$-direction is constant and is given by Fourier's law:\n$$q_{1 \\to 1} = -k_1 A \\left(\\frac{dT}{dx}\\right)_1 = -k_1 A \\frac{T_1 - T_0}{L_1}$$\nSubstituting the given values:\n$$q_{1 \\to 1} = -(48 \\text{ W m}^{-1} \\text{K}^{-1})(0.01 \\text{ m}^2) \\frac{100 \\text{ K} - 120 \\text{ K}}{0.3 \\text{ m}} = -0.48 \\left(\\frac{-20}{0.3}\\right) \\text{ W} = 32 \\text{ W}$$\nSince $q_{1 \\to 1}$ is positive, this represents heat flowing in the positive $x$-direction, thus entering node $x_1$ from the left.\n\nNext, consider the heat rate entering node $x_1$ from element $2$, which spans the interval $[x_1, x_2]$. Let us denote this heat rate as $q_{2 \\to 1}$. The length of element $2$ is $L_2 = x_2 - x_1 = 0.5 - 0.3 = 0.2$ m. The temperature gradient in this element is:\n$$\\left(\\frac{dT}{dx}\\right)_2 = \\frac{T_2 - T_1}{L_2} = \\frac{80 \\text{ K} - 100 \\text{ K}}{0.2 \\text{ m}} = \\frac{-20}{0.2} \\text{ K/m} = -100 \\text{ K/m}$$\nThe heat rate flowing through element $2$ in the positive $x$-direction, let's call it $q_2$, is:\n$$q_2 = -k_2 A \\left(\\frac{dT}{dx}\\right)_2 = -k_2 A \\frac{T_2 - T_1}{L_2}$$\nThis quantity, $q_2$, represents the heat leaving node $x_1$ and flowing into element $2$. According to the specified sign convention, the heat rate entering node $x_1$ from element $2$ is the negative of $q_2$.\n$$q_{2 \\to 1} = -q_2 = - \\left( -k_2 A \\frac{T_2 - T_1}{L_2} \\right) = k_2 A \\frac{T_2 - T_1}{L_2}$$\nSubstituting the given values:\n$$q_{2 \\to 1} = (32 \\text{ W m}^{-1} \\text{K}^{-1})(0.01 \\text{ m}^2) \\frac{80 \\text{ K} - 100 \\text{ K}}{0.2 \\text{ m}} = 0.32 \\left(\\frac{-20}{0.2}\\right) \\text{ W} = -32 \\text{ W}$$\nThe negative sign indicates that heat is flowing out of node $x_1$ into element $2$. This is consistent with the temperatures, as heat flows from the hotter node $T_1 = 100$ K to the colder node $T_2 = 80$ K.\n\nThe net heat rate into node $x_1$, denoted $Q_{net,1}$, is the algebraic sum of the heat rates entering the node from each element:\n$$Q_{net,1} = q_{1 \\to 1} + q_{2 \\to 1}$$\n$$Q_{net,1} = 32 \\text{ W} + (-32 \\text{ W}) = 0 \\text{ W}$$\nThis result is expected. For a steady-state problem with no internal heat generation and no concentrated sources or sinks at an internal node, the principle of conservation of energy dictates that the net heat flow into that node must be zero. The given nodal temperatures are the exact solution to the finite element equations, which enforce this energy balance at each internal node.\n\nThe problem requires the answer to be rounded to four significant figures. Since the result is exactly zero, it should be expressed in a format that reflects this precision.\n$$Q_{net,1} = 0.0000 \\text{ W}$$", "answer": "$$\\boxed{0.0000}$$", "id": "2426726"}, {"introduction": "Derived quantities in finite element analysis, like stress or strain, are typically calculated within elements and are inherently discontinuous across element boundaries. To generate smooth contour plots or perform further calculations, these discontinuous fields are often averaged to the nodes. This exercise guides you through the implementation of a tributary area-weighted averaging scheme, a common and intuitive method for smoothing element-based data for visualization and interpretation [@problem_id:2426709].", "problem": "A finite element computation on a two-dimensional domain produces element-centered scalar values. For each element $e$, a single scalar value $q_e$ (for example, an average element stress or energy density) is given. Consider linear triangular elements with three nodes and axis-aligned rectangular quadrilateral elements with four nodes. Define the tributary area $A_{e,i}$ contributed by element $e$ to node $i$ as the integral of the element’s scalar shape function associated with node $i$ over the element. For the element types considered, this tributary area equals the element area divided by the number of element nodes. The nodal averaged scalar $q_i$ at node $i$ shall be defined as the weighted average of all connected element values using tributary areas as weights:\n$$\nq_i \\;=\\; \\frac{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}\\, q_e}{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}},\n$$\nwhere $\\mathcal{E}(i)$ is the set of elements that contain node $i$. For a linear triangle with area $A_e$, $A_{e,i} = A_e/3$. For an axis-aligned rectangle with area $A_e$, $A_{e,i} = A_e/4$.\n\nLet the area $A_e$ of a triangle with vertices $(x_1,y_1)$, $(x_2,y_2)$, $(x_3,y_3)$ be computed by\n$$\nA_e \\;=\\; \\frac{1}{2}\\,\\left|\\,x_1\\,(y_2 - y_3) + x_2\\,(y_3 - y_1) + x_3\\,(y_1 - y_2)\\,\\right|.\n$$\nLet the area $A_e$ of a rectangle with vertices $(x_1,y_1)$, $(x_2,y_2)$, $(x_3,y_3)$, $(x_4,y_4)$ (listed in counterclockwise or clockwise order) be computed by the polygon formula\n$$\nA_e \\;=\\; \\frac{1}{2}\\,\\left|\\,\\sum_{k=1}^{4} x_k\\,y_{k+1} - y_k\\,x_{k+1}\\,\\right|, \\quad \\text{with } (x_{5},y_{5}) \\equiv (x_1,y_1).\n$$\nAssume all rectangles in the tests are axis-aligned.\n\nGiven the following test suite of independent meshes, each with node coordinates, element connectivity, element-centered scalars, and a specified node of interest, compute the nodal averaged scalar at the specified node for each mesh. Use zero-based indexing for node indices in the element connectivity.\n\nTest case $1$ (mixed rectangle and triangle, shared node):\n- Nodes:\n  - Node $0$: $(0,0)$\n  - Node $1$: $(2,0)$\n  - Node $2$: $(2,1)$\n  - Node $3$: $(0,1)$\n  - Node $4$: $(3,0)$\n  - Node $5$: $(3,1)$\n- Elements:\n  - Element $0$: type quad4, connectivity $[0,1,2,3]$, $q_{0} = 10$\n  - Element $1$: type tri3, connectivity $[2,4,5]$, $q_{1} = 4$\n- Node of interest: $2$\n\nTest case $2$ (single triangle incident to the node of interest):\n- Nodes:\n  - Node $0$: $(0,0)$\n  - Node $1$: $(1,0)$\n  - Node $2$: $(0,2)$\n- Elements:\n  - Element $0$: type tri3, connectivity $[0,1,2]$, $q_{0} = 7$\n- Node of interest: $0$\n\nTest case $3$ (two triangles forming a square, equal areas, different element values):\n- Nodes:\n  - Node $0$: $(0,0)$\n  - Node $1$: $(1,0)$\n  - Node $2$: $(1,1)$\n  - Node $3$: $(0,1)$\n- Elements:\n  - Element $0$: type tri3, connectivity $[0,1,2]$, $q_{0} = 9$\n  - Element $1$: type tri3, connectivity $[0,2,3]$, $q_{1} = 3$\n- Node of interest: $2$\n\nTest case $4$ (single rectangle incident to the node of interest):\n- Nodes:\n  - Node $0$: $(0,0)$\n  - Node $1$: $(3,0)$\n  - Node $2$: $(3,2)$\n  - Node $3$: $(0,2)$\n- Elements:\n  - Element $0$: type quad4, connectivity $[0,1,2,3]$, $q_{0} = 5$\n- Node of interest: $1$\n\nYour program must implement the nodal averaging scheme exactly as defined, use the area formulas above, and compute the value $q_i$ at the specified node for each test case in order. The final output must be a single line containing a bracketed, comma-separated list of floating-point numbers, each printed with exactly six digits after the decimal point, corresponding to test cases $1$ through $4$ in order. For example, your program should print a line of the form\n$[v_1,v_2,v_3,v_4]$\nwith each $v_k$ formatted to exactly six digits after the decimal point. No additional text should be printed.", "solution": "The core task is to compute a nodal scalar value, $q_i$, at a specific node $i$ by performing a weighted average of scalar values, $q_e$, from all elements connected to that node. The formula is given as:\n$$\nq_i \\;=\\; \\frac{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}\\, q_e}{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}}\n$$\nHere, $\\mathcal{E}(i)$ is the set of elements connected to node $i$, and $A_{e,i}$ is the tributary area of element $e$ to node $i$. This tributary area is defined as the element's area, $A_e$, divided by its number of nodes, $n_e$. For a linear triangle (`tri3`), $n_e=3$. For an axis-aligned quadrilateral (`quad4`), $n_e=4$.\n\nThe area $A_e$ for any polygon with vertices $(x_1, y_1), (x_2, y_2), \\dots, (x_N, y_N)$ listed in sequence is computed using the Shoelace formula:\n$$\nA_e = \\frac{1}{2} \\left| \\sum_{k=1}^{N} (x_k y_{k+1} - x_{k+1} y_k) \\right|, \\quad \\text{with } (x_{N+1}, y_{N+1}) \\equiv (x_1, y_1)\n$$\nThis formula is applicable to both the triangular and rectangular elements specified.\n\nThe procedure is as follows for each test case:\n1.  Identify the node of interest, $i$.\n2.  Identify the set of connecting elements, $\\mathcal{E}(i)$.\n3.  For each element $e \\in \\mathcal{E}(i)$:\n    a. Determine its vertices and calculate its area, $A_e$.\n    b. Determine its number of nodes, $n_e$.\n    c. Calculate the tributary area, $A_{e,i} = A_e / n_e$.\n    d. Calculate the element's contribution to the numerator, $A_{e,i} q_e$, and the denominator, $A_{e,i}$.\n4.  Sum the contributions from all connected elements to find the total numerator and denominator.\n5.  Calculate the final nodal value, $q_i$.\n\nWe now apply this procedure to each test case.\n\n**Test Case 1**\nNode of interest: $i=2$.\nThe set of elements containing node $2$ is $\\mathcal{E}(2) = \\{0, 1\\}$.\n\nElement $0$ (type `quad4`, $n_0 = 4$, $q_0 = 10$):\n- Vertices: $(0,0), (2,0), (2,1), (0,1)$.\n- Area: $A_0 = | (0 \\cdot 0 - 2 \\cdot 0) + (2 \\cdot 1 - 2 \\cdot 0) + (2 \\cdot 1 - 0 \\cdot 1) + (0 \\cdot 0 - 0 \\cdot 0) | / 2 = |2 + 2| / 2 = 2.0$.\n- Tributary area: $A_{0,2} = A_0 / n_0 = 2.0 / 4 = 0.5$.\n- Numerator contribution: $A_{0,2} q_0 = 0.5 \\times 10 = 5.0$.\n- Denominator contribution: $A_{0,2} = 0.5$.\n\nElement $1$ (type `tri3`, $n_1 = 3$, $q_1 = 4$):\n- Vertices: $(2,1), (3,0), (3,1)$.\n- Area: $A_1 = | (2 \\cdot 0 - 3 \\cdot 1) + (3 \\cdot 1 - 3 \\cdot 0) + (3 \\cdot 1 - 2 \\cdot 1) | / 2 = |-3 + 3 + 1| / 2 = 0.5$.\n- Tributary area: $A_{1,2} = A_1 / n_1 = 0.5 / 3 = 1/6$.\n- Numerator contribution: $A_{1,2} q_1 = (1/6) \\times 4 = 4/6 = 2/3$.\n- Denominator contribution: $A_{1,2} = 1/6$.\n\nNodal average at node $2$:\n- $\\sum A_{e,2} q_e = 5.0 + 2/3 = 15/3 + 2/3 = 17/3$.\n- $\\sum A_{e,2} = 0.5 + 1/6 = 3/6 + 1/6 = 4/6 = 2/3$.\n- $q_2 = (17/3) / (2/3) = 17/2 = 8.5$.\n\n**Test Case 2**\nNode of interest: $i=0$.\nThe set of elements containing node $0$ is $\\mathcal{E}(0) = \\{0\\}$.\nSince only one element is connected to the node of interest, the weighted average simplifies to the element's value itself: $q_0 = q_e = 7$.\nCalculation to confirm:\n- Element $0$ (type `tri3`, $n_0 = 3$, $q_0 = 7$):\n- Vertices: $(0,0), (1,0), (0,2)$.\n- Area: $A_0 = |(0 \\cdot 0 - 1 \\cdot 0) + (1 \\cdot 2 - 0 \\cdot 0) + (0 \\cdot 0 - 0 \\cdot 2)| / 2 = |2| / 2 = 1.0$.\n- Tributary area: $A_{0,0} = A_0 / n_0 = 1.0 / 3 = 1/3$.\n- $q_0 = (A_{0,0} q_0) / A_{0,0} = q_0 = 7.0$.\n\n**Test Case 3**\nNode of interest: $i=2$.\nThe set of elements containing node $2$ is $\\mathcal{E}(2) = \\{0, 1\\}$.\n\nElement $0$ (type `tri3`, $n_0 = 3$, $q_0 = 9$):\n- Vertices: $(0,0), (1,0), (1,1)$.\n- Area: $A_0 = |(0 \\cdot 0 - 1 \\cdot 0) + (1 \\cdot 1 - 1 \\cdot 0) + (1 \\cdot 0 - 0 \\cdot 1)| / 2 = |1| / 2 = 0.5$.\n- Tributary area: $A_{0,2} = A_0 / 3 = 0.5 / 3 = 1/6$.\n- Numerator contribution: $A_{0,2} q_0 = (1/6) \\times 9 = 9/6 = 1.5$.\n- Denominator contribution: $A_{0,2} = 1/6$.\n\nElement $1$ (type `tri3`, $n_1 = 3$, $q_1 = 3$):\n- Vertices: $(0,0), (1,1), (0,1)$.\n- Area: $A_1 = |(0 \\cdot 1 - 1 \\cdot 0) + (1 \\cdot 1 - 0 \\cdot 1) + (0 \\cdot 0 - 0 \\cdot 0)| / 2 = |1| / 2 = 0.5$.\n- Tributary area: $A_{1,2} = A_1 / 3 = 0.5 / 3 = 1/6$.\n- Numerator contribution: $A_{1,2} q_1 = (1/6) \\times 3 = 3/6 = 0.5$.\n- Denominator contribution: $A_{1,2} = 1/6$.\n\nNodal average at node $2$:\n- $\\sum A_{e,2} q_e = 1.5 + 0.5 = 2.0$.\n- $\\sum A_{e,2} = 1/6 + 1/6 = 2/6 = 1/3$.\n- $q_2 = 2.0 / (1/3) = 6.0$.\nSince the tributary areas are equal ($A_{0,2} = A_{1,2}$), the result is the arithmetic mean of the element values: $(9+3)/2 = 6.0$.\n\n**Test Case 4**\nNode of interest: $i=1$.\nThe set of elements containing node $1$ is $\\mathcal{E}(1) = \\{0\\}$.\nAs in case $2$, the nodal value is simply the element value: $q_1 = q_e = 5$.\nCalculation to confirm:\n- Element $0$ (type `quad4`, $n_0 = 4$, $q_0 = 5$):\n- Vertices: $(0,0), (3,0), (3,2), (0,2)$.\n- Area: $A_0 = |(0 \\cdot 0 - 3 \\cdot 0) + (3 \\cdot 2 - 3 \\cdot 0) + (3 \\cdot 2 - 0 \\cdot 2) + (0 \\cdot 0 - 0 \\cdot 0)| / 2 = |6 + 6| / 2 = 6.0$.\n- Tributary area: $A_{0,1} = A_0 / n_0 = 6.0 / 4 = 1.5$.\n- $q_1 = (A_{0,1} q_0) / A_{0,1} = q_0 = 5.0$.\n\nThe final computed values are: $8.5$, $7.0$, $6.0$, and $5.0$. These must be formatted to six decimal places for output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required for this problem.\n\ndef get_polygon_area(vertices):\n    \"\"\"\n    Calculates the area of a polygon given its vertices using the Shoelace formula.\n    Args:\n        vertices (list of tuples): A list of (x, y) coordinates for the polygon's vertices,\n                                   ordered sequentially (clockwise or counter-clockwise).\n    Returns:\n        float: The area of the polygon.\n    \"\"\"\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    return abs(area) / 2.0\n\ndef solve():\n    \"\"\"\n    Solves the nodal averaging problem for a predefined suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        ({0: (0.0, 0.0), 1: (2.0, 0.0), 2: (2.0, 1.0), 3: (0.0, 1.0), 4: (3.0, 0.0), 5: (3.0, 1.0)},\n         [{\"type\": \"quad4\", \"conn\": [0, 1, 2, 3], \"q\": 10.0},\n          {\"type\": \"tri3\", \"conn\": [2, 4, 5], \"q\": 4.0}],\n         2),\n        # Test Case 2\n        ({0: (0.0, 0.0), 1: (1.0, 0.0), 2: (0.0, 2.0)},\n         [{\"type\": \"tri3\", \"conn\": [0, 1, 2], \"q\": 7.0}],\n         0),\n        # Test Case 3\n        ({0: (0.0, 0.0), 1: (1.0, 0.0), 2: (1.0, 1.0), 3: (0.0, 1.0)},\n         [{\"type\": \"tri3\", \"conn\": [0, 1, 2], \"q\": 9.0},\n          {\"type\": \"tri3\", \"conn\": [0, 2, 3], \"q\": 3.0}],\n         2),\n        # Test Case 4\n        ({0: (0.0, 0.0), 1: (3.0, 0.0), 2: (3.0, 2.0), 3: (0.0, 2.0)},\n         [{\"type\": \"quad4\", \"conn\": [0, 1, 2, 3], \"q\": 5.0}],\n         1),\n    ]\n\n    results = []\n    for case in test_cases:\n        node_coords, elements, node_idx = case\n\n        numerator = 0.0\n        denominator = 0.0\n        \n        # Find all elements connected to the node of interest and compute their contributions.\n        for elem in elements:\n            if node_idx in elem[\"conn\"]:\n                q_e = elem[\"q\"]\n                conn = elem[\"conn\"]\n                \n                # Get the coordinates of the element's vertices.\n                vertices = [node_coords[node_id] for node_id in conn]\n                \n                # Calculate the element area using the general polygon area formula.\n                A_e = get_polygon_area(vertices)\n                \n                # The number of nodes determines the denominator for the tributary area.\n                n_nodes = len(conn)\n                A_ei = A_e / n_nodes\n                \n                # Accumulate the weighted sum for the numerator and the sum of weights for the denominator.\n                numerator += A_ei * q_e\n                denominator += A_ei\n\n        # The problem statement guarantees the node of interest is part of at least\n        # one element, so the denominator will not be zero.\n        q_i = numerator / denominator\n        results.append(q_i)\n\n    # Format the final output as a bracketed, comma-separated list of floating-point numbers\n    # with exactly six digits after the decimal point.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2426709"}, {"introduction": "A critical question in any simulation is, \"How accurate is the result?\" A posteriori error estimators provide a quantitative answer by analyzing the computed solution itself. This advanced practice introduces the classic Zienkiewicz-Zhu (ZZ) error estimator, where a \"recovered,\" more accurate gradient field is constructed to estimate the error in the original FEM solution [@problem_id:2426760]. Implementing this technique provides deep insight into assessing solution quality and is a cornerstone of adaptive mesh refinement.", "problem": "Given a two-dimensional steady heat conduction problem with scalar, isotropic, and constant thermal conductivity $k$ on a patch of three linear triangular finite elements, consider the Finite Element Method (FEM) temperature approximation $u_h$ that is continuous and piecewise linear over the triangulation. For each triangle $\\Omega_e$ with vertex indices $(i,j,\\ell)$, let the constant elementwise gradient be $\\nabla u_h|_{\\Omega_e}$, and let the Zienkiewicz–Zhu (ZZ) recovered gradient field $\\widehat{\\nabla u}$ be the continuous, piecewise-linear vector field obtained by linearly interpolating nodal recovered gradients. At each node $n$ belonging to the patch, the nodal recovered gradient is defined by the area-weighted average of the constant gradients of all elements in the patch that are incident to that node:\n$$\n\\widehat{\\nabla u}^{(n)} \\;=\\; \\frac{\\sum\\limits_{e \\ni n} A_e\\,\\nabla u_h|_{\\Omega_e}}{\\sum\\limits_{e \\ni n} A_e},\n$$\nwhere $A_e$ is the area of element $\\Omega_e$. Within an element $\\Omega_e$ with local nodes $(i,j,\\ell)$ and linear shape functions $(N_i,N_j,N_\\ell)$, the recovered gradient field is\n$$\n\\widehat{\\nabla u}(x,y)\\Big|_{\\Omega_e} \\;=\\; N_i(x,y)\\,\\widehat{\\nabla u}^{(i)} \\;+\\; N_j(x,y)\\,\\widehat{\\nabla u}^{(j)} \\;+\\; N_\\ell(x,y)\\,\\widehat{\\nabla u}^{(\\ell)}.\n$$\nDefine the ZZ energy-norm error of the patch by\n$$\n\\left\\|e\\right\\|_{ZZ} \\;=\\; \\left(\\sum_{e=1}^{3} \\int_{\\Omega_e} k\\,\\big\\|\\widehat{\\nabla u}(x,y)-\\nabla u_h|_{\\Omega_e}\\big\\|_2^2\\,\\mathrm{d}\\Omega \\right)^{1/2}.\n$$\n\nAll quantities in this problem are nondimensional. Your task is to compute $\\left\\|e\\right\\|_{ZZ}$ for each of the following three test cases. In every case, the finite element mesh is a patch of three triangles that share the central node with index $0$ and have element connectivity $\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$. The FEM nodal temperature values $u_h$ are to be taken as the exact pointwise values of the given analytic field $u(x,y)$ at the mesh nodes.\n\nFor each test, use the specified nodal coordinates, thermal conductivity $k$, and analytic temperature field $u(x,y)$:\n- Test $1$ (exactly linear field; expected zero error in exact arithmetic):\n  - Nodes: $0:(0.0,\\,0.0)$, $1:(1.0,\\,0.0)$, $2:(-0.2,\\,1.1)$, $3:(-0.8,\\,-0.4)$.\n  - Connectivity: $\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$.\n  - Conductivity: $k=1.0$.\n  - Field: $u(x,y)=2x - y$.\n- Test $2$ (nonlinear field on a moderately shaped patch):\n  - Nodes: $0:(0.1,\\,0.2)$, $1:(0.9,\\,0.1)$, $2:(0.0,\\,1.0)$, $3:(-0.8,\\,0.2)$.\n  - Connectivity: $\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$.\n  - Conductivity: $k=2.0$.\n  - Field: $u(x,y)=x^2 + y$.\n- Test $3$ (nonlinear field including a slender triangle):\n  - Nodes: $0:(0.0,\\,0.0)$, $1:(0.001,\\,0.0)$, $2:(0.002,\\,0.05)$, $3:(-0.8,\\,0.001)$.\n  - Connectivity: $\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$.\n  - Conductivity: $k=0.5$.\n  - Field: $u(x,y)=\\sin(x)+0.5\\,y$.\n\nRequired conventions and definitions:\n- For a triangle with vertex coordinates $(x_i,y_i)$, $(x_j,y_j)$, $(x_\\ell,y_\\ell)$, let the signed doubled area be\n$$\n2A_{\\mathrm{sign}} \\;=\\; (x_j-x_i)(y_\\ell-y_i) - (x_\\ell-x_i)(y_j-y_i),\n$$\nand the (positive) area be $A \\,=\\, |A_{\\mathrm{sign}}|$.\n- For linear shape functions, the constant element gradient of $u_h$ in triangle $\\Omega_e$ is\n$$\n\\nabla u_h\\Big|_{\\Omega_e}\n= \\frac{1}{2A_{\\mathrm{sign}}}\n\\begin{bmatrix}\n(y_j-y_\\ell) & (y_\\ell-y_i) & (y_i-y_j) \\\\\n(x_\\ell-x_j) & (x_i-x_\\ell) & (x_j-x_i)\n\\end{bmatrix}\n\\begin{bmatrix}\nu_i\\\\ u_j\\\\ u_\\ell\n\\end{bmatrix}.\n$$\n\nYour program must compute, for each test case, the scalar $\\left\\|e\\right\\|_{ZZ}$ as defined above, using exact arithmetic for the elementwise integrals implied by the definition. Aggregate the three results into a single line of output as a comma-separated list enclosed in square brackets, with each value rounded to exactly six digits after the decimal point. For example, an output with placeholder values would look like $[0.000000,0.123456,0.654321]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3]$).", "solution": "The objective is to compute the Zienkiewicz-Zhu energy-norm error, $\\left\\|e\\right\\|_{ZZ}$, for a patch of three linear triangular elements for three distinct test cases. The total squared error is the summation of contributions from each element $\\Omega_e$:\n$$\n\\left\\|e\\right\\|_{ZZ}^2 \\;=\\; \\sum_{e=1}^{3} \\left\\|e\\right\\|_{ZZ,e}^2 \\;=\\; \\sum_{e=1}^{3} \\int_{\\Omega_e} k\\,\\big\\|\\widehat{\\nabla u}(x,y)-\\nabla u_h|_{\\Omega_e}\\big\\|_2^2\\,\\mathrm{d}\\Omega\n$$\nThe calculation proceeds through a sequence of logical steps.\n\n**Step 1: Nodal Temperature Evaluation**\nThe finite element approximation $u_h$ is continuous and piecewise linear. The problem dictates that the nodal values of the temperature field, $u_i$, are determined by sampling the given exact analytical field $u(x,y)$ at the coordinates of each mesh node $n_i=(x_i, y_i)$.\n$$\nu_i = u(x_i, y_i)\n$$\nThis is performed for all four nodes in the patch: $n_0, n_1, n_2, n_3$.\n\n**Step 2: Computation of Constant Element-wise Gradients**\nWithin each linear triangular element $\\Omega_e$, the gradient of the finite element solution, $\\nabla u_h|_{\\Omega_e}$, is a constant vector. For an element with vertices $(i,j,\\ell)$ having coordinates $(x_i,y_i)$, $(x_j,y_j)$, $(x_\\ell,y_\\ell)$ and nodal temperatures $(u_i,u_j,u_\\ell)$, this gradient vector $\\mathbf{g}_e = \\nabla u_h|_{\\Omega_e}$ is calculated using the provided formula:\n$$\n\\mathbf{g}_e = \\nabla u_h\\Big|_{\\Omega_e}\n= \\frac{1}{2A_{e,\\mathrm{sign}}}\n\\begin{bmatrix}\ny_j-y_\\ell & y_\\ell-y_i & y_i-y_j\\\\\nx_\\ell-x_j & x_i-x_\\ell & x_j-x_i\n\\end{bmatrix}\n\\begin{bmatrix}\nu_i\\\\ u_j\\\\ u_\\ell\n\\end{bmatrix}\n$$\nwhere $2A_{e,\\mathrm{sign}} = (x_j-x_i)(y_\\ell-y_i) - (x_\\ell-x_i)(y_j-y_i)$ is the signed doubled area of the element. This calculation is repeated for each of the three elements in the patch, yielding gradient vectors $\\mathbf{g}_1, \\mathbf{g}_2, \\mathbf{g}_3$. The (positive) area of each element is $A_e = \\frac{1}{2}|2A_{e,\\mathrm{sign}}|$.\n\n**Step 3: Computation of Nodal Recovered Gradients**\nThe Zienkiewicz-Zhu procedure constructs a continuous, improved gradient field, $\\widehat{\\nabla u}$, by first computing averaged gradients at the mesh nodes. The recovered gradient at a node $n$, denoted $\\widehat{\\nabla u}^{(n)}$ or $\\mathbf{G}_n$, is the area-weighted average of the constant gradients of all elements incident to that node:\n$$\n\\mathbf{G}_n = \\widehat{\\nabla u}^{(n)} \\;=\\; \\frac{\\sum\\limits_{e \\ni n} A_e\\,\\mathbf{g}_e}{\\sum\\limits_{e \\ni n} A_e}\n$$\nThis calculation is performed for each of the four nodes. For instance, the central node $n_0$ is shared by all three elements, so its recovered gradient is:\n$$\n\\mathbf{G}_0 \\;=\\; \\frac{A_1\\,\\mathbf{g}_1 + A_2\\,\\mathbf{g}_2 + A_3\\,\\mathbf{g}_3}{A_1+A_2+A_3}\n$$\nAn exterior node, such as $n_1$, is shared only by elements $1$ and $3$, so its recovered gradient is:\n$$\n\\mathbf{G}_1 \\;=\\; \\frac{A_1\\,\\mathbf{g}_1 + A_3\\,\\mathbf{g}_3}{A_1+A_3}\n$$\nThe recovered gradients $\\mathbf{G}_0, \\mathbf{G}_1, \\mathbf{G}_2, \\mathbf{G}_3$ are computed accordingly.\n\n**Step 4: Evaluation of the Element Error Integral**\nThe core of the task is to evaluate the integral for each element's contribution to the total error. Let $\\boldsymbol{\\delta}(x,y) = \\widehat{\\nabla u}(x,y)-\\nabla u_h|_{\\Omega_e}$. Within an element $\\Omega_e$ with nodes $(i,j,\\ell)$, this difference field is linear, as both $\\widehat{\\nabla u}$ and $u_h$ are piecewise linear. It can be expressed using the element shape functions $(N_i, N_j, N_\\ell)$:\n$$\n\\boldsymbol{\\delta}(x,y) = N_i(x,y)\\,\\boldsymbol{\\delta}_i + N_j(x,y)\\,\\boldsymbol{\\delta}_j + N_\\ell(x,y)\\,\\boldsymbol{\\delta}_\\ell\n$$\nwhere $\\boldsymbol{\\delta}_n = \\mathbf{G}_n - \\mathbf{g}_e$ is the difference vector at node $n$. The integral for element $e$ is:\n$$\n\\left\\|e\\right\\|_{ZZ,e}^2 \\;=\\; k \\int_{\\Omega_e} \\left\\| \\boldsymbol{\\delta}(x,y) \\right\\|_2^2 \\,\\mathrm{d}\\Omega = k \\int_{\\Omega_e} \\left( \\delta_x(x,y)^2 + \\delta_y(x,y)^2 \\right) \\,\\mathrm{d}\\Omega\n$$\nThe integral of the square of a linear scalar field $f(x,y) = N_i f_i + N_j f_j + N_\\ell f_\\ell$ over a triangular element has an exact analytical solution:\n$$\n\\int_{\\Omega_e} f(x,y)^2 \\,\\mathrm{d}\\Omega = \\frac{A_e}{12}(2f_i^2+2f_j^2+2f_\\ell^2 + 2f_if_j + 2f_if_\\ell + 2f_jf_\\ell) = \\mathbf{f}^T \\mathbf{M} \\mathbf{f}\n$$\nwhere $\\mathbf{f} = [f_i, f_j, f_\\ell]^T$ is the vector of nodal values and $\\mathbf{M}$ is the element mass matrix for linear triangles:\n$$\n\\mathbf{M} = \\frac{A_e}{12}\n\\begin{pmatrix}\n2 & 1 & 1 \\\\\n1 & 2 & 1 \\\\\n1 & 1 & 2\n\\end{pmatrix}\n$$\nApplying this to both components of $\\boldsymbol{\\delta}(x,y)$, we get:\n$$\n\\left\\|e\\right\\|_{ZZ,e}^2 = k \\left( \\boldsymbol{\\delta}_x^T \\mathbf{M} \\boldsymbol{\\delta}_x + \\boldsymbol{\\delta}_y^T \\mathbf{M} \\boldsymbol{\\delta}_y \\right)\n$$\nwhere $\\boldsymbol{\\delta}_x = [\\delta_{ix}, \\delta_{jx}, \\delta_{\\ell x}]^T$ and $\\boldsymbol{\\delta}_y = [\\delta_{iy}, \\delta_{jy}, \\delta_{\\ell y}]^T$ are the vectors of nodal difference components. This exact formula is used for the computation.\n\n**Step 5: Aggregation and Final Result**\nThe total squared error is the sum of the element-wise squared errors calculated in the previous step.\n$$\n\\left\\|e\\right\\|_{ZZ}^2 = \\sum_{e=1}^{3} \\left\\|e\\right\\|_{ZZ,e}^2\n$$\nThe final ZZ error norm is the square root of this sum:\n$$\n\\left\\|e\\right\\|_{ZZ} = \\sqrt{\\left\\|e\\right\\|_{ZZ}^2}\n$$\nThis complete procedure is implemented programmatically and applied to each of the three test cases to obtain the required numerical results.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Zienkiewicz-Zhu energy-norm error for three test cases\n    of a 2D steady heat conduction problem on a 3-element patch.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": {0: (0.0, 0.0), 1: (1.0, 0.0), 2: (-0.2, 1.1), 3: (-0.8, -0.4)},\n            \"k\": 1.0,\n            \"u_func\": lambda x, y: 2.0 * x - y\n        },\n        {\n            \"nodes\": {0: (0.1, 0.2), 1: (0.9, 0.1), 2: (0.0, 1.0), 3: (-0.8, 0.2)},\n            \"k\": 2.0,\n            \"u_func\": lambda x, y: x**2 + y\n        },\n        {\n            \"nodes\": {0: (0.0, 0.0), 1: (0.001, 0.0), 2: (0.002, 0.05), 3: (-0.8, 0.001)},\n            \"k\": 0.5,\n            \"u_func\": lambda x, y: np.sin(x) + 0.5 * y\n        }\n    ]\n    \n    # Mesh connectivity is the same for all test cases.\n    connectivity = [(0, 1, 2), (0, 2, 3), (0, 3, 1)]\n    \n    results = []\n\n    for case in test_cases:\n        nodes_coords = case[\"nodes\"]\n        k = case[\"k\"]\n        u_func = case[\"u_func\"]\n        \n        # Step 1: Compute nodal temperatures from the analytical field.\n        nodal_temps = {n: u_func(x, y) for n, (x, y) in nodes_coords.items()}\n\n        elem_data = {}\n        # Step 2: Compute constant element gradients and areas for all elements.\n        for elem_idx, elem_nodes in enumerate(connectivity):\n            n_i, n_j, n_l = elem_nodes\n            (xi, yi), (xj, yj), (xl, yl) = nodes_coords[n_i], nodes_coords[n_j], nodes_coords[n_l]\n\n            # Calculate signed doubled area and positive area.\n            two_A_sign = (xj - xi) * (yl - yi) - (xl - xi) * (yj - yi)\n            area = 0.5 * abs(two_A_sign)\n\n            # Assemble the B matrix for gradient calculation.\n            B_matrix = np.array([\n                [yj - yl, yl - yi, yi - yj],\n                [xl - xj, xi - xl, xj - xi]\n            ])\n            \n            # Vector of nodal temperatures for the element.\n            u_vec = np.array([nodal_temps[n_i], nodal_temps[n_j], nodal_temps[n_l]])\n            \n            # Calculate the constant element gradient.\n            grad_e = (1.0 / two_A_sign) * (B_matrix @ u_vec)\n            \n            elem_data[elem_idx] = {\"nodes\": elem_nodes, \"area\": area, \"grad\": grad_e}\n\n        # Step 3: Compute nodal recovered gradients.\n        # First, map each node to its incident elements.\n        node_to_elems = {n: [] for n in nodes_coords}\n        for elem_idx, elem_nodes in enumerate(connectivity):\n            for node_idx in elem_nodes:\n                node_to_elems[node_idx].append(elem_idx)\n        \n        nodal_recovered_grads = {}\n        for n in nodes_coords:\n            incident_elems = node_to_elems[n]\n            \n            # Perform area-weighted averaging.\n            sum_A_grad = np.zeros(2)\n            sum_A = 0.0\n            for elem_idx in incident_elems:\n                sum_A_grad += elem_data[elem_idx][\"area\"] * elem_data[elem_idx][\"grad\"]\n                sum_A += elem_data[elem_idx][\"area\"]\n            \n            nodal_recovered_grads[n] = sum_A_grad / sum_A\n\n        # Step 4 & 5: Compute element error integrals and aggregate.\n        total_E_squared = 0.0\n        for i in range(len(connectivity)):\n            data = elem_data[i]\n            n_i, n_j, n_l = data[\"nodes\"]\n            area = data[\"area\"]\n            g_e = data[\"grad\"]\n            \n            # Get the nodal recovered gradients for the current element's nodes.\n            G_i = nodal_recovered_grads[n_i]\n            G_j = nodal_recovered_grads[n_j]\n            G_l = nodal_recovered_grads[n_l]\n            \n            # Compute the difference between recovered gradient and FEM gradient at each node.\n            delta_i = G_i - g_e\n            delta_j = G_j - g_e\n            delta_l = G_l - g_e\n            \n            # Assemble vectors of x and y components of the differences.\n            delta_x = np.array([delta_i[0], delta_j[0], delta_l[0]])\n            delta_y = np.array([delta_i[1], delta_j[1], delta_l[1]])\n            \n            # Define the element mass matrix for a linear triangle.\n            M = (area / 12.0) * np.array([\n                [2.0, 1.0, 1.0],\n                [1.0, 2.0, 1.0],\n                [1.0, 1.0, 2.0]\n            ])\n            \n            # Evaluate the integral of the squared error field using the mass matrix.\n            integral_x_sq = delta_x.T @ M @ delta_x\n            integral_y_sq = delta_y.T @ M @ delta_y\n            \n            # The squared error energy for the element.\n            E_e_squared = k * (integral_x_sq + integral_y_sq)\n            total_E_squared += E_e_squared\n            \n        # Final ZZ error norm is the square root of the total squared error energy.\n        zz_error = np.sqrt(total_E_squared)\n        results.append(f\"{zz_error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2426760"}]}