{"hands_on_practices": [{"introduction": "Theoretical concepts like stability are often best understood when seen in action. This first hands-on exercise provides a concrete, computational demonstration of the stability differences between explicit and implicit methods when faced with a stiff system. By pitting the conditionally stable Forward Euler method against the A-stable Backward Euler method [@problem_id:2372859], you will witness firsthand how an explicit method can fail spectacularly, while an implicit method remains robust even with a surprisingly large time step.", "problem": "Consider the linear autonomous system of Ordinary Differential Equations (ODE) given by $\\dot{x}(t)=A\\,x(t)$, where $A\\in\\mathbb{R}^{2\\times 2}$ is constant and $x(t)\\in\\mathbb{R}^{2}$. Two one-step methods are to be used for time advancement. The explicit method is defined by $x_{n+1}=x_{n}+h\\,A\\,x_{n}$ with stepsize $h0$. The implicit method is defined by $x_{n+1}=x_{n}+H\\,A\\,x_{n+1}$ with stepsize $H0$, equivalently written as $x_{n+1}=(I-H\\,A)^{-1}x_{n}$ whenever the inverse exists.\n\nYour task is to write a complete program that, for each test case specified below, performs the following for the given $2\\times 2$ matrix $A$, initial vector $x_{0}$, and small stepsize $h$:\n\n1. Compute the explicit iteration for $N_{\\mathrm{FE}}$ steps with stepsize $h$ using the update $x_{n+1}=x_{n}+h\\,A\\,x_{n}$, starting from $x_{0}$, to obtain $x_{\\mathrm{FE,final}}$.\n2. Define the large stepsize $H=1000\\,h$. Compute the implicit iteration for $N_{\\mathrm{BE}}$ steps with stepsize $H$ using the update $x_{n+1}=(I-H\\,A)^{-1}x_{n}$, starting from $x_{0}$, to obtain $x_{\\mathrm{BE,final}}$.\n3. Let $\\lVert\\cdot\\rVert$ denote the Euclidean norm on $\\mathbb{R}^{2}$. Define that the explicit method “explodes” if $\\lVert x_{\\mathrm{FE,final}}\\rVert10\\,\\lVert x_{0}\\rVert$, and that the implicit method is “damped” if $\\lVert x_{\\mathrm{BE,final}}\\rVert\\lVert x_{0}\\rVert$. For each case, output a boolean that is true if and only if both conditions hold.\n\nUse the following test suite:\n\n- Case $\\mathbf{1}$ (happy path, diagonal stiff system):\n  - $A=\\begin{bmatrix}-10\\\\0-1000\\end{bmatrix}$,\n  - $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$,\n  - $h=0.003$,\n  - $H=1000\\,h=3$,\n  - $N_{\\mathrm{FE}}=12$,\n  - $N_{\\mathrm{BE}}=3$.\n- Case $\\mathbf{2}$ (boundary condition near explicit stability edge):\n  - $A=\\begin{bmatrix}-10\\\\0-1000\\end{bmatrix}$,\n  - $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$,\n  - $h=0.002$,\n  - $H=1000\\,h=2$,\n  - $N_{\\mathrm{FE}}=12$,\n  - $N_{\\mathrm{BE}}=3$.\n- Case $\\mathbf{3}$ (coupled stiff system):\n  - $A=\\begin{bmatrix}-1100\\\\0-1000\\end{bmatrix}$,\n  - $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$,\n  - $h=0.003$,\n  - $H=1000\\,h=3$,\n  - $N_{\\mathrm{FE}}=12$,\n  - $N_{\\mathrm{BE}}=3$.\n\nFinal Output Format: Your program should produce a single line of output containing the boolean results for the three cases, in order, as a comma-separated list enclosed in square brackets (for example, $[{\\rm True},{\\rm False},{\\rm True}]$). No additional text should be printed.", "solution": "The problem as stated requires an analysis of two numerical methods for solving a linear system of ordinary differential equations, $\\dot{x}(t) = A x(t)$. This is a standard problem in the field of computational engineering and numerical analysis. I shall first validate the problem statement.\n\n### Step 1: Extract Givens\n\nThe givens are:\n- The system of ODEs: $\\dot{x}(t)=A\\,x(t)$, where $A\\in\\mathbb{R}^{2\\times 2}$ and $x(t)\\in\\mathbb{R}^{2}$.\n- The explicit method (Forward Euler): $x_{n+1}=x_{n}+h\\,A\\,x_{n} = (I + hA)x_n$, with stepsize $h0$.\n- The implicit method (Backward Euler): $x_{n+1}=x_{n}+H\\,A\\,x_{n+1}$, equivalent to $x_{n+1}=(I-H\\,A)^{-1}x_{n}$, with stepsize $H0$.\n- A large stepsize is defined as $H=1000\\,h$.\n- A condition for the explicit method to \"explode\" is defined as $\\lVert x_{\\mathrm{FE,final}}\\rVert10\\,\\lVert x_{0}\\rVert$, where $\\lVert\\cdot\\rVert$ is the Euclidean norm.\n- A condition for the implicit method to be \"damped\" is defined as $\\lVert x_{\\mathrm{BE,final}}\\rVert\\lVert x_{0}\\rVert$.\n- The final boolean output for each case is true if and only if the \"explodes\" condition and the \"damped\" condition both hold.\n\nTest cases are provided as follows:\n- **Case 1**: $A=\\begin{bmatrix}-10\\\\0-1000\\end{bmatrix}$, $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$, $h=0.003$, $H=3$, $N_{\\mathrm{FE}}=12$, $N_{\\mathrm{BE}}=3$.\n- **Case 2**: $A=\\begin{bmatrix}-10\\\\0-1000\\end{bmatrix}$, $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$, $h=0.002$, $H=2$, $N_{\\mathrm{FE}}=12$, $N_{\\mathrm{BE}}=3$.\n- **Case 3**: $A=\\begin{bmatrix}-1100\\\\0-1000\\end{bmatrix}$, $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$, $h=0.003$, $H=3$, $N_{\\mathrm{FE}}=12$, $N_{\\mathrm{BE}}=3$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is scientifically grounded, objective, and well-posed.\n- **Scientifically Grounded**: The problem addresses the fundamental concept of numerical stability for stiff ordinary differential equations, comparing the conditionally stable Forward Euler method with the A-stable Backward Euler method. These are classic topics in numerical analysis.\n- **Well-Posed**: All parameters ($A$, $x_0$, $h$, $H$, $N_{\\mathrm{FE}}$, $N_{\\mathrm{BE}}$) are precisely defined for each test case. The criteria for \"explodes\" and \"damped\" are unambiguous. A unique result exists for each case. The matrix $(I-HA)$ is invertible for all provided cases, as the eigenvalues of $HA$ do not equal $1$.\n- **Objective**: The problem is stated in an objective mathematical language, free of any subjective interpretation.\n\n### Step 3: Verdict and Action\n\nThe problem is valid. I will proceed with a full solution.\n\nThe core of this problem lies in the concept of numerical stability for stiff systems. A system $\\dot{x}=Ax$ is considered stiff if the matrix $A$ has eigenvalues with real parts that are all non-positive and differ by several orders of magnitude. The stability of a numerical method is determined by its amplification factor, $G$, which governs the propagation of the numerical solution: $x_{n+1} = G x_n$. For the solution to remain bounded, the spectral radius of the amplification factor, $\\rho(G)$, must satisfy $\\rho(G) \\le 1$.\n\nFor the explicit Forward Euler method, the amplification matrix is $G_{\\mathrm{FE}} = I + hA$. The stability condition is $\\rho(I+hA) \\le 1$, which translates to $|1+h\\lambda_i| \\le 1$ for all eigenvalues $\\lambda_i$ of $A$. This defines a stability region in the complex plane for the product $h\\lambda$. For stable systems (where $\\mathrm{Re}(\\lambda_i) \\le 0$), this method is only conditionally stable; it requires the stepsize $h$ to be sufficiently small, typically constrained by the eigenvalue with the largest magnitude.\n\nFor the implicit Backward Euler method, the amplification matrix is $G_{\\mathrm{BE}} = (I - HA)^{-1}$. The stability condition is $\\rho((I-HA)^{-1}) \\le 1$, which translates to $|(1-H\\lambda_i)^{-1}| \\le 1$ for all eigenvalues $\\lambda_i$ of $A$. This condition is satisfied for any $H  0$ as long as $\\mathrm{Re}(\\lambda_i) \\leq 0$. This property is known as A-stability, making the method unconditionally stable for stiff systems. It allows for much larger stepsizes $H$ without numerical instability, which is computationally advantageous.\n\nNow, we analyze each case.\n\n**Case 1**: $A=\\begin{bmatrix}-10\\\\0-1000\\end{bmatrix}$. The eigenvalues are $\\lambda_1 = -1$ and $\\lambda_2 = -1000$. The stepsize is $h=0.003$.\n- **Forward Euler**: We check the stability condition $|1+h\\lambda_i| \\le 1$.\n  - For $\\lambda_1 = -1$: $|1 + (0.003)(-1)| = |0.997| = 0.997 \\le 1$. This component is stable.\n  - For $\\lambda_2 = -1000$: $|1 + (0.003)(-1000)| = |1 - 3| = |-2| = 2  1$. This component is unstable.\n  The numerical solution will grow exponentially due to the unstable mode, and we expect the \"explodes\" condition to be met after $N_{\\mathrm{FE}}=12$ steps.\n- **Backward Euler**: The stepsize is $H=3$. The method is A-stable. The amplification factors for the eigenmodes are:\n  - For $\\lambda_1 = -1$: $|(1 - (3)(-1))^{-1}| = |1/4| = 0.25  1$. This component is strongly damped.\n  - For $\\lambda_2 = -1000$: $|(1 - (3)(-1000))^{-1}| = |1/3001| \\approx 3.33 \\times 10^{-4}  1$. This component is very strongly damped.\n  The norm of the solution vector will decrease. Thus, we expect the \"damped\" condition to be met.\n- **Verdict**: Both conditions are expected to be true. The result for Case 1 is `True`.\n\n**Case 2**: $A=\\begin{bmatrix}-10\\\\0-1000\\end{bmatrix}$. The eigenvalues are $\\lambda_1 = -1$ and $\\lambda_2 = -1000$. The stepsize is $h=0.002$.\n- **Forward Euler**: We check the stability condition $|1+h\\lambda_i| \\le 1$.\n  - For $\\lambda_1 = -1$: $|1 + (0.002)(-1)| = |0.998| = 0.998 \\le 1$. This component is stable.\n  - For $\\lambda_2 = -1000$: $|1 + (0.002)(-1000)| = |1 - 2| = |-1| = 1 \\le 1$. This component is on the boundary of the stability region.\n  The norm of the solution will not grow exponentially. The second component of the solution will oscillate with constant amplitude, while the first decays. The total norm is not expected to grow by a factor of $10$. The \"explodes\" condition will be false.\n- **Backward Euler**: The stepsize is $H=2$. The method is A-stable.\n  - Amplification for $\\lambda_1 = -1$: $|(1 - (2)(-1))^{-1}| = |1/3|  1$.\n  - Amplification for $\\lambda_2 = -1000$: $|(1 - (2)(-1000))^{-1}| = |1/2001|  1$.\n  The solution will be damped.\n- **Verdict**: The \"explodes\" condition is false, so the combined condition is false. The result for Case 2 is `False`.\n\n**Case 3**: $A=\\begin{bmatrix}-1100\\\\0-1000\\end{bmatrix}$. This is an upper triangular matrix, so its eigenvalues are its diagonal entries: $\\lambda_1 = -1$ and $\\lambda_2 = -1000$. The stepsize is $h=0.003$.\n- **Forward Euler**: The stability analysis depends only on the eigenvalues, which are identical to Case 1. With $h=0.003$, the eigenvalue $\\lambda_2 = -1000$ yields $|1 + (0.003)(-1000)| = 2  1$, so the method is unstable. The coupling term $A_{12}=100$ will transfer energy from the unstable mode to the stable one, but the overall solution will be dominated by the exponential growth of the unstable eigen-component. The \"explodes\" condition is expected to be met.\n- **Backward Euler**: The stepsize is $H=3$. The method is A-stable, irrespective of the coupling. The amplification factors are determined by the eigenvalues and are identical to those in Case 1. The solution will be \"damped\".\n- **Verdict**: Both conditions are expected to be true. The result for Case 3 is `True`.\n\nIn summary, the theoretical analysis predicts the results to be `True`, `False`, and `True` for the three cases, respectively. The following program will perform the direct numerical simulation to verify this conclusion.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given problem by simulating two numerical methods for a system of ODEs\n    and checking for specific stability-related conditions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.array([[-1, 0], [0, -1000]]),\n            \"x0\": np.array([1, 1]),\n            \"h\": 0.003,\n            \"N_FE\": 12,\n            \"N_BE\": 3\n        },\n        {\n            \"A\": np.array([[-1, 0], [0, -1000]]),\n            \"x0\": np.array([1, 1]),\n            \"h\": 0.002,\n            \"N_FE\": 12,\n            \"N_BE\": 3\n        },\n        {\n            \"A\": np.array([[-1, 100], [0, -1000]]),\n            \"x0\": np.array([1, 1]),\n            \"h\": 0.003,\n            \"N_FE\": 12,\n            \"N_BE\": 3\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        x0 = case[\"x0\"].astype(float)\n        h = case[\"h\"]\n        N_FE = case[\"N_FE\"]\n        N_BE = case[\"N_BE\"]\n        \n        # The large stepsize H is defined as 1000*h\n        H = 1000 * h\n\n        # Calculate initial norm\n        norm_x0 = np.linalg.norm(x0)\n\n        # 1. Explicit method (Forward Euler) simulation\n        x_fe = x0.copy()\n        for _ in range(N_FE):\n            x_fe = x_fe + h * (A @ x_fe)\n        \n        norm_fe_final = np.linalg.norm(x_fe)\n        explodes = norm_fe_final  10 * norm_x0\n\n        # 2. Implicit method (Backward Euler) simulation\n        x_be = x0.copy()\n        # Pre-compute the inverse of (I - H*A)\n        # I is the 2x2 identity matrix\n        I = np.identity(2)\n        inv_mat_be = np.linalg.inv(I - H * A)\n        \n        for _ in range(N_BE):\n            x_be = inv_mat_be @ x_be\n        \n        norm_be_final = np.linalg.norm(x_be)\n        damped = norm_be_final  norm_x0\n        \n        # 3. Check if both conditions hold\n        results.append(explodes and damped)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2372859"}, {"introduction": "The superior stability of the Backward Euler method comes from its implicit formulation, which presents a new computational challenge: solving an algebraic equation at each time step. This practice delves into the practical mechanics of implementing an implicit solver using a simple fixed-point iteration. By deriving the convergence condition for this iteration [@problem_id:2372866], you will uncover that the time step $h$ must be chosen not only for accuracy but also to ensure the iterative solver itself converges, adding a crucial layer of understanding to the costs and benefits of implicit schemes.", "problem": "Consider the backward Euler time discretization of the autonomous ordinary differential equation (ODE) $\\frac{dy}{dt} = f(y)$, where $f:\\mathbb{R}\\to\\mathbb{R}$ is assumed to be Lipschitz continuous with Lipschitz constant $L0$ on a closed, convex set that contains all iterates under consideration. A single backward Euler step from a known state $y_n$ with timestep $h0$ requires solving the implicit equation\n$$\ny_{n+1} = y_n + h\\, f\\!\\left(y_{n+1}\\right).\n$$\nSuppose this implicit equation is solved by the simple fixed-point iteration\n$$\nz^{(k+1)} = y_n + h\\, f\\!\\left(z^{(k)}\\right), \\quad k=0,1,2,\\dots,\n$$\ninitialized with an arbitrary $z^{(0)}$ in the same set.\n\nDetermine the largest allowable timestep $h_{\\max}$, expressed as a function of $L$, that guarantees convergence of this fixed-point iteration for any initial iterate $z^{(0)}$ chosen in the set. Provide your final answer as a single closed-form expression in terms of $L$ only. Do not include units, and do not report an inequality or an equation.", "solution": "The fixed-point iteration can be written as $z^{(k+1)} = G\\!\\left(z^{(k)}\\right)$, where the iteration map $G$ is defined by\n$$\nG(z) \\equiv y_n + h\\, f(z).\n$$\nTo guarantee convergence for any initial iterate in the set, it is sufficient that $G$ be a contraction on the set. By the definition of a contraction mapping, $G$ must satisfy\n$$\n|G(u)-G(v)| \\leq q\\, |u-v| \\quad \\text{for all } u,v \\text{ in the set, with } q \\in [0,1).\n$$\nUsing the Lipschitz continuity of $f$ with constant $L$, we estimate the Lipschitz constant of $G$:\n$$\n|G(u)-G(v)| = |y_n + h f(u) - (y_n + h f(v))| = h\\, |f(u)-f(v)| \\leq h\\, L\\, |u-v|.\n$$\nThus, $G$ is a contraction provided that its Lipschitz factor $h\\,L$ satisfies\n$$\nh\\,L  1.\n$$\nThis strict inequality characterizes the timesteps $h$ for which the iteration converges for any initial iterate in the set. The largest allowable timestep in the sense of the supremum over all admissible $h$ is therefore the boundary value at which the contraction constant would equal $1$, namely\n$$\nh_{\\max} = \\frac{1}{L}.\n$$\nNote that at $h = \\frac{1}{L}$ the map is no longer a strict contraction (its Lipschitz factor equals $1$), so the guarantee of convergence requires $h  \\frac{1}{L}$. However, the requested largest allowable timestep as a function of $L$ (the supremum of such $h$) is $h_{\\max} = \\frac{1}{L}$.", "answer": "$$\\boxed{\\frac{1}{L}}$$", "id": "2372866"}, {"introduction": "Having established the impressive stability of the Backward Euler method, it is crucial to confront a common and potentially dangerous misconception: that a stable solution is automatically an accurate one. This final exercise highlights the critical distinction between numerical stability and accuracy. By applying the Backward Euler method with a large time step to a simple decay problem [@problem_id:2372906], you will quantify the resulting error and learn that while the solution remains bounded, its deviation from the true solution can be significant, reinforcing the principle that step size selection is always a careful balance between stability, accuracy, and computational cost.", "problem": "Consider a two-isotope, uncoupled radioactive decay model described by the ordinary differential equation (ODE) system\n$$\n\\frac{dc_f}{dt} = -\\lambda_f\\,c_f,\\qquad \\frac{dc_s}{dt} = -\\lambda_s\\,c_s,\n$$\nwith initial conditions\n$$\nc_f(0)=c_{f,0},\\qquad c_s(0)=c_{s,0},\n$$\nwhere $c_f$ and $c_s$ denote the concentrations of a fast- and a slow-decaying isotope, respectively, and $\\lambda_f$ and $\\lambda_s$ are positive decay rates with $\\lambda_f  \\lambda_s$. The exact solution for each isotope is\n$$\nc_f(t)=c_{f,0}\\,e^{-\\lambda_f t},\\qquad c_s(t)=c_{s,0}\\,e^{-\\lambda_s t}.\n$$\nYou are to approximate the solution using the Backward Euler method (BE) with a constant timestep $h$ from $t=0$ to a final time $t=T$, assuming $T/h$ is an integer so that a whole number of steps $N=T/h$ are taken. All quantities are nondimensional; do not append units to any numerical value.\n\nFor each test case, compute the following two quantities for the slow isotope component:\n1. A stability indicator $s$ for the single-step map applied to the slow component, defined as $s=1$ if the magnitude of the per-step amplification factor is less than or equal to $1$, and $s=0$ otherwise.\n2. The absolute error $E=\\lvert c_s^{\\text{BE}}(T)-c_s^{\\text{exact}}(T)\\rvert$ at time $T$.\n\nUse the following test suite of parameter sets $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)$:\n- Test A: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(10, 0.1, 1, 1, 1, 5)$.\n- Test B: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(50, 0.2, 2, 2, 10, 50)$.\n- Test C: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(1, 0.01, 3, 1, 100, 100)$.\n- Test D: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(5, 10^{-6}, 1, 1.5, 10^6, 10^6)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a two-element list $[s,E]$, where $s$ is an integer and $E$ is a float. The overall output format must be\n$$\n[\\,[s_A,E_A],[s_B,E_B],[s_C,E_C],[s_D,E_D]\\,],\n$$\nwith the test cases ordered as A, B, C, D, respectively, and with no additional spaces or text. For example, an output with placeholder values would look like\n$$\n[[1,0.0],[1,0.0],[1,0.0],[1,0.0]].\n$$", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- **Governing Equations**: A system of two uncoupled ordinary differential equations (ODEs) for radioactive decay:\n$$\n\\frac{dc_f}{dt} = -\\lambda_f\\,c_f,\\qquad \\frac{dc_s}{dt} = -\\lambda_s\\,c_s\n$$\n- **Initial Conditions**: $c_f(0)=c_{f,0}$ and $c_s(0)=c_{s,0}$.\n- **Parameters**: $c_f$ and $c_s$ are concentrations. $\\lambda_f$ and $\\lambda_s$ are positive decay rates, with $\\lambda_f  \\lambda_s$.\n- **Exact Solution**: $c_f(t)=c_{f,0}\\,e^{-\\lambda_f t}$ and $c_s(t)=c_{s,0}\\,e^{-\\lambda_s t}$.\n- **Numerical Method**: Backward Euler (BE) method with a constant timestep $h$ from $t=0$ to $t=T$. $N=T/h$ is an integer.\n- **Quantities to Compute**: For the slow isotope component ($c_s$):\n    1. Stability indicator $s$: $s=1$ if the magnitude of the per-step amplification factor is less than or equal to $1$; $s=0$ otherwise.\n    2. Absolute error $E=\\lvert c_s^{\\text{BE}}(T)-c_s^{\\text{exact}}(T)\\rvert$ at the final time $T$.\n- **Test Cases**:\n    - Test A: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(10, 0.1, 1, 1, 1, 5)$\n    - Test B: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(50, 0.2, 2, 2, 10, 50)$\n    - Test C: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(1, 0.01, 3, 1, 100, 100)$\n    - Test D: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(5, 10^{-6}, 1, 1.5, 10^6, 10^6)$\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, modeling a standard physical process (radioactive decay) with a canonical numerical method (Backward Euler). It is well-posed, objective, and self-contained. All necessary data are provided, and there are no internal contradictions. For each test case, the ratio $T/h$ is an integer as stated. The problem formulation is a standard exercise in numerical analysis for ODEs. The presence of parameters for the fast-decaying isotope ($c_f$, $\\lambda_f$) is noted, but since the ODE system is uncoupled, these parameters are irrelevant to the requested computations for the slow-decaying isotope ($c_s$). This does not constitute a flaw but rather tests the correct interpretation of the system.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be provided.\n\nThe problem requires the analysis of the slow-decaying isotope's concentration, $c_s$, governed by the ODE:\n$$\n\\frac{dc_s}{dt} = -\\lambda_s c_s\n$$\nwith the initial condition $c_s(0) = c_{s,0}$. The parameters related to the fast-decaying isotope, $c_f$, are irrelevant for this task because the two ODEs are uncoupled.\n\nWe will apply the Backward Euler method. Let $c_s^n$ be the numerical approximation of $c_s(t_n)$ at time $t_n = n h$, where $h$ is the timestep. The Backward Euler discretization of the ODE is:\n$$\n\\frac{c_s^{n+1} - c_s^n}{h} = -\\lambda_s c_s^{n+1}\n$$\nTo find the update rule, we solve for $c_s^{n+1}$:\n$$\nc_s^{n+1}(1 + h\\lambda_s) = c_s^n\n$$\n$$\nc_s^{n+1} = \\left(\\frac{1}{1 + h\\lambda_s}\\right) c_s^n\n$$\nThis equation defines the single-step map from one time level to the next.\n\n**1. Stability Indicator $s$**\nThe per-step amplification factor, $g$, is the term that multiplies the solution at the previous step to obtain the solution at the current step:\n$$\ng = \\frac{1}{1 + h\\lambda_s}\n$$\nThe stability of the method depends on the magnitude of this factor, $|g|$. The problem states that the stability indicator $s$ is $1$ if $|g| \\le 1$ and $0$ otherwise.\nFrom the problem givens, the decay rate $\\lambda_s$ is positive, and the timestep $h$ is also positive. Thus, their product $h\\lambda_s$ is strictly positive. This implies:\n$$\n1 + h\\lambda_s  1\n$$\n$$\n0  \\frac{1}{1 + h\\lambda_s}  1\n$$\nTherefore, the amplification factor $g$ satisfies $0  g  1$, which means its magnitude $|g|$ is always less than $1$, regardless of the choice of $h  0$ and $\\lambda_s  0$. This is the well-known property of A-stability for the Backward Euler method applied to this class of problems. Consequently, for all specified test cases, the stability condition is met, and the stability indicator $s$ will be $1$.\n\n**2. Absolute Error $E$**\nTo find the numerical solution at the final time $T$, we apply the single-step map $N$ times, where $N=T/h$. Starting from the initial condition $c_s^0 = c_{s,0}$, we obtain a geometric progression:\n$$\nc_s^N = g^N c_s^0 = \\left(\\frac{1}{1 + h\\lambda_s}\\right)^N c_{s,0}\n$$\nSo, the numerical solution at $t=T$ is:\n$$\nc_s^{\\text{BE}}(T) = c_{s,0} \\left(\\frac{1}{1 + h\\lambda_s}\\right)^{T/h}\n$$\nThe exact solution at $t=T$ is given as:\n$$\nc_s^{\\text{exact}}(T) = c_{s,0} e^{-\\lambda_s T}\n$$\nThe absolute error $E$ is the magnitude of the difference between the numerical and exact solutions at $t=T$:\n$$\nE = \\lvert c_s^{\\text{BE}}(T) - c_s^{\\text{exact}}(T) \\rvert = \\left| c_{s,0} \\left(\\frac{1}{1 + h\\lambda_s}\\right)^{T/h} - c_{s,0} e^{-\\lambda_s T} \\right|\n$$\nSince $c_{s,0}$ is given as positive for all test cases, we can write:\n$$\nE = c_{s,0} \\left| \\left(\\frac{1}{1 + h\\lambda_s}\\right)^{T/h} - e^{-\\lambda_s T} \\right|\n$$\nThese formulae are implemented for each test case to compute the required pairs $[s, E]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes stability indicator and absolute error for a radioactive decay\n    model using the Backward Euler method for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (lambda_f, lambda_s, c_f0, c_s0, h, T)\n    test_cases = [\n        (10.0, 0.1, 1.0, 1.0, 1.0, 5.0),          # Test A\n        (50.0, 0.2, 2.0, 2.0, 10.0, 50.0),         # Test B\n        (1.0, 0.01, 3.0, 1.0, 100.0, 100.0),       # Test C\n        (5.0, 1e-6, 1.0, 1.5, 1e6, 1e6),           # Test D\n    ]\n\n    # Store formatted results for each test case\n    formatted_results = []\n    \n    for case in test_cases:\n        # Unpack parameters. The fast-decaying isotope parameters (lambda_f, c_f0)\n        # are not used as the system is uncoupled.\n        _lambda_f, lambda_s, _c_f0, c_s0, h, T = case\n\n        # 1. Compute the stability indicator s\n        # The amplification factor for Backward Euler on dc/dt = -lambda*c is g = 1 / (1 + h*lambda).\n        # Since lambda_s  0 and h  0, g is always between 0 and 1.\n        # Thus, the method is unconditionally stable, and s=1 for all cases.\n        amplification_factor = 1.0 / (1.0 + h * lambda_s)\n        s = 1 if np.abs(amplification_factor) = 1.0 else 0\n\n        # 2. Compute the absolute error E at time T\n        \n        # The problem statement guarantees N = T/h is an integer.\n        N = int(round(T / h))\n\n        # Numerical solution using Backward Euler after N steps\n        c_s_be = c_s0 * (amplification_factor ** N)\n\n        # Exact solution at time T\n        c_s_exact = c_s0 * np.exp(-lambda_s * T)\n\n        # Absolute error\n        error_E = np.abs(c_s_be - c_s_exact)\n        \n        # Format the result pair as a string \"[s,E]\"\n        formatted_results.append(f\"[{s},{error_E}]\")\n\n    # Final print statement in the exact required format.\n    # e.g., [[s_A,E_A],[s_B,E_B],...]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2372906"}]}