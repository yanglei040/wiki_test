{"hands_on_practices": [{"introduction": "A deep understanding of an algorithm comes from being able to predict its behavior and also reason backward from its effects. This first exercise challenges you to act as a detective. Given the exact sequence of swaps performed during a max-heap sift-down, your task is to deduce the relative order of the initial values involved by combining the rules of the algorithm with the heap's structural properties. [@problem_id:3239390]", "problem": "Consider a binary max-heap stored in an array $A[1..n]$ with $n \\ge 15$, using the usual array-to-tree mapping where the parent of index $i$ is $\\lfloor i/2 \\rfloor$, and the children of index $i$ are $2i$ and $2i+1$ whenever these indices are within $[1..n]$. By the max-heap property, for every internal node $i$ that has children, $A[i] \\ge A[2i]$ and $A[i] \\ge A[2i+1]$. A standard sift-down (also called heapify-down) at a starting index $s$ repeatedly compares $A[s]$ with its children, selects the larger child $c \\in \\{2s, 2s+1\\}$, and if $A[s]  A[c]$, it swaps the entries at indices $s$ and $c$, then continues the process from index $c$; otherwise it stops.\n\nSuppose we initiate a sift-down at the root, that is $s = 1$, in a configuration where the max-heap property may be violated only at index $1$ (for example, after placing a new key at $A[1]$ while all other positions still satisfy the max-heap property). The sift-down performs exactly the following sequence of swaps (written as ordered pairs of indices): $(1,3)$, $(3,7)$, $(7,15)$, and then terminates.\n\nBased solely on this swap sequence and the governing definitions above, which of the following statements about the initial values $A[1]$, $A[3]$, $A[7]$, and $A[15]$ must be true?\n\nA. $A[3] \\ge A[7] \\ge A[15] \\ge A[1]$\n\nB. $A[1] \\ge A[3] \\ge A[7] \\ge A[15]$\n\nC. $A[3] \\le A[7] \\le A[15] \\le A[1]$\n\nD. $A[3] \\ge A[1] \\ge A[7] \\ge A[15]$", "solution": "Let $A[k]$ denote the initial value of the element at index $k$ in the array, before the sift-down operation commences. We can deduce the relationships between the values by combining two sources of information: the initial state of the heap and the mechanics of the sift-down process.\n\n### Analysis of the Initial Heap State\nThe problem states that the max-heap property may be violated *only* at the root (index $1$). This means that for any node $i > 1$ with children, its subtree is a valid max-heap. We can apply this to the nodes along the swap path:\n\n1.  **Subtree at index $3$**: The children of node $3$ are nodes $6$ and $7$. Since the subtree rooted at $3$ is a valid max-heap, it must be that $A[3] \\ge A[7]$.\n2.  **Subtree at index $7$**: The children of node $7$ are nodes $14$ and $15$. Since the subtree rooted at $7$ is a valid max-heap, it must be that $A[7] \\ge A[15]$.\n\nCombining these two inequalities, we establish the first part of the relationship:\n$$A[3] \\ge A[7] \\ge A[15]$$\n\n### Analysis of the Sift-Down Swaps\nThe sift-down algorithm swaps a parent with its largest child only if the child's value is strictly greater than the parent's. Let $v_1 = A[1]$ be the value that is being sifted down.\n\n1.  **First swap $(1, 3)$**: At index $1$, the value $v_1$ is compared with its children $A[2]$ and $A[3]$. A swap with index $3$ occurs. This implies that $A[3]$ is the larger child and $A[1]  A[3]$. After this swap, $v_1$ is now at index $3$.\n2.  **Second swap $(3, 7)$**: The process continues from index $3$, where the value is now $v_1$. It is compared with its children $A[6]$ and $A[7]$. A swap with index $7$ occurs. This implies $A[7]$ is the larger child and $v_1  A[7]$, or $A[1]  A[7]$. After this swap, $v_1$ is now at index $7$.\n3.  **Third swap $(7, 15)$**: The process continues from index $7$, where the value is now $v_1$. It is compared with its children $A[14]$ and $A[15]$. A swap with index $15$ occurs. This implies $A[15]$ is the larger child and $v_1  A[15]$, or $A[1]  A[15]$.\n\nThe crucial deduction comes from this final swap: we must have $A[15] > A[1]$.\n\n### Synthesizing the Results\nWe combine the relationship from the initial heap state with the inequality from the final swap:\n- From the heap state: $A[3] \\ge A[7] \\ge A[15]$\n- From the final swap: $A[15] > A[1]$\n\nPutting these together gives the complete necessary relationship:\n$$A[3] \\ge A[7] \\ge A[15] > A[1]$$\n\nSince $x > y$ implies $x \\ge y$, the statement $A[3] \\ge A[7] \\ge A[15] \\ge A[1]$ must be true.\n\n### Evaluating the Options\n- **A. $A[3] \\ge A[7] \\ge A[15] \\ge A[1]$**: This matches our derived conclusion perfectly. **Correct**.\n- **B. $A[1] \\ge A[3] \\ge A[7] \\ge A[15]$**: This is contradicted by $A[1]  A[3]$. **Incorrect**.\n- **C. $A[3] \\le A[7] \\le A[15] \\le A[1]$**: This is contradicted by $A[3] \\ge A[7]$ and $A[1]  A[15]$. **Incorrect**.\n- **D. $A[3] \\ge A[1] \\ge A[7] \\ge A[15]$**: This is contradicted by $A[1]  A[7]$. **Incorrect**.", "answer": "$$\n\\boxed{A}\n$$", "id": "3239390"}, {"introduction": "Why is the standard sift-down algorithm for a min-heap designed to always swap with the *smaller* child? This practice explores that very question by presenting a plausible but buggy alternative that swaps with the *larger* child. Your challenge is to identify scenarios where this buggy logic fails, revealing the subtle but crucial invariant that the correct algorithm maintains. [@problem_id:3239430]", "problem": "A binary min-heap is a complete binary tree represented in an array $a[1..n]$ with the property that for every index $i$ with children, $a[i] \\leq a[2i]$ and $a[i] \\leq a[2i+1]$. The standard sift-down operation, when invoked at a node $i$ holding a key $x$ that may violate the min-heap property, repeatedly swaps $x$ downward with the smaller of its two children until the property is restored along the path.\n\nConsider a buggy variant of sift-down that instead chooses the larger child at each step (breaking ties deterministically in favor of the right child), and only swaps when the larger child is strictly smaller than the current key. That is, at a node $i$ with children $2i$ and $2i+1$, if $a[2i] \\leq a[2i+1]$ the algorithm compares $a[2i+1]$ (the larger child) to $a[i]$; if $a[2i]  a[2i+1]$ the algorithm compares $a[2i]$ (the larger child) to $a[i]$. When the larger child is strictly less than $a[i]$, the algorithm swaps $a[i]$ with that larger child and continues at the child’s index; otherwise, it stops.\n\nStarting from the root at index $1$, suppose the array below encodes the heap in breadth-first order (one-based indexing). In each option, $a[1]$ is the current key $x$ to sift down, and all subtrees initially satisfy the min-heap property relative to their own roots before the buggy procedure begins. For each option, decide whether the buggy sift-down “appears to work” at the root (that is, after the first action, the local relation between the root and its two children is not violating the min-heap property) but then fails to maintain the min-heap property at a deeper level because of the choice to compare and swap with the larger child.\n\nSelect all options for which this phenomenon occurs.\n\nA. $a = \\langle 9, 4, 4, 12, 13, 10, 8 \\rangle$.\n\nB. $a = \\langle 9, 4, 4, 12, 13, 20, 21 \\rangle$.\n\nC. $a = \\langle 9, 4, 7, 12, 13, 20, 21 \\rangle$.\n\nD. $a = \\langle 5, 5, 5, 12, 13, 20, 21 \\rangle$.\n\nE. $a = \\langle 14, 10, 10, 16, 17, 11, 15 \\rangle$.", "solution": "We analyze the behavior of the buggy sift-down algorithm on each provided array. The core flaw of the buggy algorithm is that it only compares the parent with the *larger* of its two children. If the parent is smaller than the larger child but larger than the smaller child, the algorithm will incorrectly stop, leaving a violation of the min-heap property. The question asks for cases where the initial swap at the root seems correct, but this flaw manifests at a deeper level.\n\n**Option A: $a = \\langle 9, 4, 4, 12, 13, 10, 8 \\rangle$**\n1.  **Root (index 1)**: $a[1] = 9$, children are $a[2] = 4$ and $a[3] = 4$. They are equal, so the tie-breaking rule selects the right child, $a[3]$, as the \"larger\" one. Since $a[3] = 4  9$, a swap occurs.\n2.  **After swap**: The array becomes $\\langle 4, 4, 9, 12, 13, 10, 8 \\rangle$. The root $a[1]=4$ now satisfies the min-heap property with its children $a[2]=4$ and $a[3]=9$. It \"appears to work\" at the root.\n3.  **Continue at index 3**: The sift-down continues from index $3$, where the value is now $9$. The children are $a[6]=10$ and $a[7]=8$. The larger child is $a[6]=10$.\n4.  **Buggy check**: The algorithm compares $9$ with the larger child, $10$. Since $10 \\not 9$, the algorithm stops.\n5.  **Result**: The heap is left with $a[3]=9$ as the parent of $a[7]=8$. This violates the min-heap property ($9 \\not\\leq 8$). This is a deeper failure. **Verdict: Correct.**\n\n**Option B: $a = \\langle 9, 4, 4, 12, 13, 20, 21 \\rangle$**\n1.  **Root (index 1)**: Same as option A, a swap occurs between $a[1]$ and $a[3]$. The root appears fixed.\n2.  **Continue at index 3**: The value is $9$. Children are $a[6]=20$ and $a[7]=21$. The larger child is $a[7]=21$.\n3.  **Buggy check**: The algorithm compares $9$ with $21$. Since $21 \\not 9$, it stops.\n4.  **Result**: The node $a[3]=9$ is a valid parent for children $20$ and $21$. The heap property is satisfied everywhere. **Verdict: Incorrect.**\n\n**Option C: $a = \\langle 9, 4, 7, 12, 13, 20, 21 \\rangle$**\n1.  **Root (index 1)**: $a[1]=9$, children are $a[2]=4$ and $a[3]=7$. The larger child is $a[3]=7$. Since $7  9$, a swap occurs.\n2.  **After swap**: The array becomes $\\langle 7, 4, 9, \\dots \\rangle$. The new root is $a[1]=7$, but its left child is $a[2]=4$. This immediately violates the min-heap property ($7 \\not\\leq 4$).\n3.  **Result**: The procedure fails to \"appear to work\" even at the root level. **Verdict: Incorrect.**\n\n**Option D: $a = \\langle 5, 5, 5, 12, 13, 20, 21 \\rangle$**\n1.  **Root (index 1)**: $a[1]=5$, children are $a[2]=5$ and $a[3]=5$. The \"larger\" child (by tie-break) is $a[3]=5$.\n2.  **Buggy check**: The algorithm compares $5$ with $5$. Since $5 \\not 5$, it stops immediately.\n3.  **Result**: No swap occurs, and the heap is already valid. **Verdict: Incorrect.**\n\n**Option E: $a = \\langle 14, 10, 10, 16, 17, 11, 15 \\rangle$**\n1.  **Root (index 1)**: $a[1]=14$, children are $a[2]=10$ and $a[3]=10$. By tie-breaking, the \"larger\" child is $a[3]=10$. Since $10  14$, a swap occurs.\n2.  **After swap**: The array becomes $\\langle 10, 10, 14, \\dots \\rangle$. The root $a[1]=10$ is a valid parent for children $a[2]=10$ and $a[3]=14$. It \"appears to work.\"\n3.  **Continue at index 3**: The value is $14$. Children are $a[6]=11$ and $a[7]=15$. The larger child is $a[7]=15$.\n4.  **Buggy check**: The algorithm compares $14$ with $15$. Since $15 \\not 14$, it stops.\n5.  **Result**: The heap is left with $a[3]=14$ as the parent of $a[6]=11$. This violates the min-heap property ($14 \\not\\leq 11$). This is a deeper failure. **Verdict: Correct.**\n\nTherefore, options A and E are the only ones that exhibit the specified phenomenon.", "answer": "$$\\boxed{AE}$$", "id": "3239430"}, {"introduction": "The final practice moves from analysis to creation, a core activity in computer science. Here, you will implement a novel variant of the sift-down operation that uses a two-level lookahead to potentially reduce swaps by making larger jumps down the heap. By implementing both the standard and the enhanced algorithm, you will gain hands-on experience in algorithmic design, implementation, and empirical performance comparison. [@problem_id:3239394]", "problem": "You are given the canonical definition of a Binary Heap (BH), represented as an array where each node at index $i$ has children at indices $2i+1$ and $2i+2$, and the heap property for a maximum heap (max-heap) requires that for every index $i$ with children $c$, the inequality $A[i] \\ge A[c]$ holds. A standard sift-down operation on a max-heap proceeds by repeatedly comparing the current node $i$ with its largest child and swapping if the child's value exceeds the current node's value, then continuing from the child's index. This procedure is used by Floyd's heap construction to build a heap, starting from the last internal node and applying sift-down for each node up to the root.\n\nConsider a variation called sift-down with a lookahead of $2$ levels (denoted LA2). At a node $i$, LA2 inspects both children and up to four grandchildren (those that exist in the array) of $i$. A swap with a grandchild at index $j$ must preserve the heap property at the intermediate parent $p = \\left\\lfloor \\frac{j - 1}{2} \\right\\rfloor$. To ensure this, define a grandchild index $j$ as safe if $A[p] \\ge A[i]$. The LA2 rule at index $i$ is:\n- Let $c_{\\max}$ be the index of the largest child among $\\{2i+1, 2i+2\\}$ that exist.\n- Let $G$ be the set of safe grandchildren of $i$ (among $\\{2(2i+1)+1, 2(2i+1)+2, 2(2i+2)+1, 2(2i+2)+2\\}$ that exist and satisfy $A[p] \\ge A[i]$).\n- If $G$ is nonempty, let $g_{\\max}$ be the index in $G$ with maximum value $A[g_{\\max}]$.\n- If $A[g_{\\max}]  A[i]$ and $A[g_{\\max}] \\ge A[c_{\\max}]$, perform a single swap of $A[i]$ and $A[g_{\\max}]$ and continue sifting-down from index $g_{\\max}$. Otherwise, if $A[c_{\\max}]  A[i]$, perform a single swap of $A[i]$ and $A[c_{\\max}]$ and continue from index $c_{\\max}$. If neither condition holds, stop at $i$.\n\nThis LA2 rule is designed to allow a $2$-level descent in a single swap when it is safe to do so, preserving the heap property at the intermediate parent, and falling back to the standard $1$-level swap otherwise. The total cost we measure is the number of pairwise swaps of array elements.\n\nTask:\n1. Implement two heap construction procedures for a max-heap on an input array $A$:\n   - Standard Floyd heapify using the standard sift-down.\n   - LA2 heapify using the LA2 sift-down rule described above.\n2. For each test case array $A$, compute the integer difference $D = S_{\\text{std}} - S_{\\text{LA2}}$, where $S_{\\text{std}}$ is the total number of swaps performed during standard heap construction and $S_{\\text{LA2}}$ is the total number of swaps performed during LA2 heap construction. A positive $D$ indicates a reduction of swaps by LA2 relative to the standard method.\n3. Your program must output the list of differences for the specified test suite on a single line in the exact format specified below.\n\nUse the following test suite, each given as a list of integers:\n- Test $1$: $[3,1,6,5,2,4]$.\n- Test $2$: $[1,2,3,4,5,6,7,8]$.\n- Test $3$: $[9,7,8,5,6,4,3]$.\n- Test $4$: $[10,3,9,2,1,8,4,7,6]$.\n- Test $5$: $[5,5,5,5,5,5,5,5]$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[D_1,D_2,D_3,D_4,D_5]$, corresponding to the five tests in order. No additional text should be printed.", "solution": "### Method Explanation\n\nTo solve this problem, we need to implement two versions of Floyd's heap construction algorithm for a max-heap, one using a standard `sift-down` procedure and another using the specified `LA2 sift-down` with a two-level lookahead. For each algorithm, we will count the total number of swaps performed.\n\n**Floyd's Heap Construction:**\nBoth implementations will follow the structure of Floyd's algorithm. We iterate backward from the last internal node of the array (at index `floor(n/2) - 1`) up to the root (index `0`). For each node, we call the respective `sift-down` procedure to enforce the max-heap property on the subtree rooted at that node. The total swap count is the sum of swaps from each `sift-down` call.\n\n**1. Standard Sift-Down (`sift_down_std`):**\nThis is the classic procedure. For a given node:\n- Find the largest element among the node and its immediate children.\n- If the largest element is one of the children, swap it with the current node.\n- Repeat this process, moving down the tree from the position of the swapped child, until the node is no longer smaller than its children or it becomes a leaf.\n- A counter is incremented for each swap.\n\n**2. Lookahead-2 Sift-Down (`sift_down_la2`):**\nThis procedure enhances the standard sift-down with a lookahead. For a given node `i`:\n- First, identify the largest child, `c_max`.\n- Then, identify the set of \"safe\" grandchildren. A grandchild `j` is safe if its direct parent `p` has a value greater than or equal to the value at node `i`. This `A[p] >= A[i]` check is crucial because it ensures that swapping `A[i]` with `A[j]` will not violate the max-heap property at node `p`.\n- From the set of safe grandchildren, find the one with the maximum value, `g_max`.\n- The decision rule is then applied:\n    a. If `g_max` exists and its value is greater than both the current node's value and the largest child's value, swap the current node with `g_max`. This performs a 2-level jump.\n    b. If the 2-level jump condition is not met, fall back to the standard procedure: if `c_max`'s value is greater than the current node's value, swap with `c_max`.\n    c. If neither swap condition is met, stop.\n- The process repeats from the new position of the sifted-down element, and swaps are counted.\n\nFinally, for each test case, we run both heap construction algorithms on separate copies of the input array, calculate the total swaps $S_{\\text{std}}$ and $S_{\\text{LA2}}$, and compute the difference $D = S_{\\text{std}} - S_{\\text{LA2}}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares standard vs. LA2 heap construction algorithms.\n    \"\"\"\n\n    def _left(i):\n        return 2 * i + 1\n\n    def _right(i):\n        return 2 * i + 2\n\n    def _parent(i):\n        return (i - 1) // 2\n\n    def _sift_down_std(arr, start_node, n):\n        \"\"\"Performs standard sift-down and returns the number of swaps.\"\"\"\n        swaps = 0\n        root = start_node\n        while True:\n            swap_target = root\n            l = _left(root)\n            r = _right(root)\n\n            # Find the largest among root, left child, and right child\n            if l  n and arr[l] > arr[swap_target]:\n                swap_target = l\n            if r  n and arr[r] > arr[swap_target]:\n                swap_target = r\n\n            if swap_target == root:\n                break\n            else:\n                arr[root], arr[swap_target] = arr[swap_target], arr[root]\n                swaps += 1\n                root = swap_target\n        return swaps\n\n    def _heapify_std(arr):\n        \"\"\"Builds a max-heap using standard sift-down and counts swaps.\"\"\"\n        n = len(arr)\n        total_swaps = 0\n        start_idx = (n // 2) - 1\n        for i in range(start_idx, -1, -1):\n            total_swaps += _sift_down_std(arr, i, n)\n        return total_swaps\n\n    def _sift_down_la2(arr, start_node, n):\n        \"\"\"Performs sift-down with a 2-level lookahead and returns swaps.\"\"\"\n        swaps = 0\n        root = start_node\n        while True:\n            current_val = arr[root]\n            \n            # 1. Find the largest child, c_max\n            l, r = _left(root), _right(root)\n            c_max_idx = -1\n            c_max_val = -float('inf')\n            \n            if l  n:\n                c_max_idx = l\n                c_max_val = arr[l]\n            if r  n and arr[r] > c_max_val:\n                c_max_idx = r\n                c_max_val = arr[r]\n\n            # 2. Find the best safe grandchild, g_max\n            g_max_idx = -1\n            g_max_val = -float('inf')\n            \n            potential_grandchildren = []\n            if l  n:\n                potential_grandchildren.extend([_left(l), _right(l)])\n            if r  n:\n                potential_grandchildren.extend([_left(r), _right(r)])\n\n            for j in potential_grandchildren:\n                if j  n:\n                    p = _parent(j)\n                    # Check safety condition\n                    if arr[p] >= current_val:\n                        if arr[j] > g_max_val:\n                            g_max_idx = j\n                            g_max_val = arr[j]\n            \n            # 3. Apply the LA2 decision rule\n            swap_target = -1\n            # Check grandchild swap condition\n            if g_max_idx != -1 and g_max_val > current_val and \\\n               (c_max_idx == -1 or g_max_val >= c_max_val):\n                swap_target = g_max_idx\n            # Fallback to child swap condition\n            elif c_max_idx != -1 and c_max_val > current_val:\n                swap_target = c_max_idx\n            \n            # 4. Perform swap or terminate\n            if swap_target != -1:\n                arr[root], arr[swap_target] = arr[swap_target], arr[root]\n                swaps += 1\n                root = swap_target\n            else:\n                break\n        return swaps\n\n\n    def _heapify_la2(arr):\n        \"\"\"Builds a max-heap using LA2 sift-down and counts swaps.\"\"\"\n        n = len(arr)\n        total_swaps = 0\n        start_idx = (n // 2) - 1\n        for i in range(start_idx, -1, -1):\n            total_swaps += _sift_down_la2(arr, i, n)\n        return total_swaps\n\n    test_cases = [\n        [3, 1, 6, 5, 2, 4],\n        [1, 2, 3, 4, 5, 6, 7, 8],\n        [9, 7, 8, 5, 6, 4, 3],\n        [10, 3, 9, 2, 1, 8, 4, 7, 6],\n        [5, 5, 5, 5, 5, 5, 5, 5]\n    ]\n\n    results = []\n    for case in test_cases:\n        arr_std = np.array(case)\n        arr_la2 = np.array(case)\n\n        s_std = _heapify_std(arr_std)\n        s_la2 = _heapify_la2(arr_la2)\n\n        difference = s_std - s_la2\n        results.append(difference)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3239394"}]}