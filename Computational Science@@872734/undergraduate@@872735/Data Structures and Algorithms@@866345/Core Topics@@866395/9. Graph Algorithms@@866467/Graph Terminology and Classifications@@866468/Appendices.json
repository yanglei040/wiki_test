{"hands_on_practices": [{"introduction": "A core skill in graph theory is understanding how a graph's classification imposes fundamental limits on its properties. This exercise invites you to explore the structural constraints of bipartite graphs. By reasoning from the definition of a bipartite partition, you will determine the maximum possible number of edges in a graph with 10 vertices, a classic problem that illuminates the relationship between a graph's structure and its density. [@problem_id:3237256]", "problem": "A simple graph is a graph with no loops and no parallel edges. A bipartite graph is a graph whose vertex set can be partitioned into two disjoint independent sets so that every edge joins a vertex in one part to a vertex in the other part. Consider simple graphs on $n=10$ vertices. Using only the defining property of bipartite graphs that all edges cross between the two independent parts, determine the maximum number of edges $m_{\\max}(10)$ that any simple bipartite graph on $10$ vertices can have by reasoning from first principles. Based on your derivation, decide whether a simple graph with $10$ vertices and $20$ edges can be bipartite, but report only the value of $m_{\\max}(10)$ as your final answer. Express your final answer as an exact integer.", "solution": "The problem requires determining the maximum number of edges a simple bipartite graph with $n=10$ vertices can have, using only first principles.\n\nLet $G=(V, E)$ be a simple graph with a set of vertices $V$ and a set of edges $E$. The number of vertices is given as $|V| = n = 10$.\n\nThe defining property of a bipartite graph is that its vertex set $V$ can be partitioned into two disjoint and non-empty independent sets, which we will call $V_1$ and $V_2$. This partition must satisfy the following conditions:\n$1.$ $V_1 \\cup V_2 = V$\n$2.$ $V_1 \\cap V_2 = \\emptyset$\n$3.$ For any edge $(u, v) \\in E$, one vertex must be in $V_1$ and the other in $V_2$. This means there are no edges connecting two vertices within $V_1$, nor any edges connecting two vertices within $V_2$.\n\nLet the number of vertices in the set $V_1$ be $k$. Since the total number of vertices is $n=10$, the number of vertices in the set $V_2$ must be $|V_2| = n - k = 10 - k$. As the partitions are non-empty, $k$ must be an integer such that $1 \\le k \\le 9$. The case where $k=0$ or $k=10$ would imply one of the sets is empty, resulting in a graph with no edges, which we can exclude when seeking a maximum.\n\nTo find the maximum number of edges, $m_{\\max}$, we consider a graph where every possible edge that respects the bipartite property exists. The graph is simple, meaning there are no multiple edges between the same pair of vertices. Therefore, for a given partition $(V_1, V_2)$, the maximum number of edges is achieved when every vertex in $V_1$ is connected to every vertex in $V_2$.\n\nThe number of such edges, let us denote it by $m(k)$, is the product of the number of vertices in each partition set:\n$$m(k) = |V_1| \\times |V_2| = k \\times (10 - k)$$\n\nOur goal is to find the maximum value of the function $m(k) = 10k - k^2$ for integer values of $k$ in the range $1 \\le k \\le 9$.\n\nThis function $m(k)$ is a quadratic function of $k$ representing a downward-opening parabola. The maximum value of this continuous function occurs at its vertex. The coordinate of the vertex for a parabola of the form $ax^2 + bx + c$ is at $x = -\\frac{b}{2a}$. For $m(k) = -k^2 + 10k$, we have $a = -1$ and $b = 10$. The vertex is at:\n$$k = -\\frac{10}{2(-1)} = 5$$\n\nSince $k=5$ is an integer and falls within our allowed range for $k$, the maximum number of edges will occur when the vertices are partitioned into two sets of size $k=5$ and $10-k=5$.\n\nLet's evaluate $m(k)$ for this value of $k$:\n$$m_{\\max}(10) = m(5) = 5 \\times (10 - 5) = 5 \\times 5 = 25$$\n\nThis corresponds to the complete bipartite graph $K_{5,5}$. We can verify that this is indeed the maximum by evaluating the function at other possible integer values of $k$:\n- If $k=1$ (or $k=9$), $m(1) = 1 \\times 9 = 9$ edges.\n- If $k=2$ (or $k=8$), $m(2) = 2 \\times 8 = 16$ edges.\n- If $k=3$ (or $k=7$), $m(3) = 3 \\times 7 = 21$ edges.\n- If $k=4$ (or $k=6$), $m(4) = 4 \\times 6 = 24$ edges.\n- If $k=5$, $m(5) = 5 \\times 5 = 25$ edges.\n\nThe maximum value is clearly $25$. Thus, the maximum number of edges any simple bipartite graph on $10$ vertices can have is $m_{\\max}(10) = 25$.\n\nThe problem also asks to decide whether a simple graph with $10$ vertices and $20$ edges can be bipartite. Since the maximum possible number of edges is $25$, and $20  25$, it is certainly possible for such a graph to be bipartite. For example, one could construct a complete bipartite graph $K_{4,6}$, which has $4 \\times 6 = 24$ edges, and then remove any $4$ edges. The resulting graph would have $20$ edges and remain bipartite. Alternatively, one could take the maximal graph $K_{5,5}$ and remove $5$ edges. In either case, a simple bipartite graph on $10$ vertices with $20$ edges can exist.\n\nThe final answer to be reported is only the value of $m_{\\max}(10)$.", "answer": "$$\\boxed{25}$$", "id": "3237256"}, {"introduction": "Building on the properties of specific graph classes, we can often predict complex behaviors like traversability. This practice asks you to analyze the complete bipartite graph, $K_{n,m}$, a fundamental structure in its own right. By combining the definition of $K_{n,m}$ with the classic theorem for the existence of an Eulerian circuit, you will derive the precise conditions on $n$ and $m$ that guarantee such a traversal is possible, a perfect example of synthesizing multiple graph concepts. [@problem_id:3237299]", "problem": "You are working with finite, simple, undirected graphs. Let $K_{n,m}$ denote the complete bipartite graph with bipartition classes of sizes $n$ and $m$, where $n,m \\in \\mathbb{Z}_{\\ge 1}$. Using only standard definitions concerning bipartite graphs, vertex degrees, graph connectivity, and the characterization for the existence of an Eulerian circuit in finite undirected graphs, determine which statement precisely characterizes all $(n,m)$ for which $K_{n,m}$ has an Eulerian circuit.\n\nChoose the single best option.\n\nA. $K_{n,m}$ has an Eulerian circuit exactly when both $n$ and $m$ are even integers (with $n,m \\ge 1$).\n\nB. $K_{n,m}$ has an Eulerian circuit exactly when both $n$ and $m$ are odd and $n=m$.\n\nC. $K_{n,m}$ has an Eulerian circuit exactly when one of $n$ or $m$ is even and the other is odd.\n\nD. $K_{n,m}$ has an Eulerian circuit exactly when $n+m$ is even (with $n,m \\ge 1$).\n\nE. $K_{n,m}$ has an Eulerian circuit exactly when $n=m$ and $n \\ge 2$.", "solution": "The problem statement is to determine the precise conditions on the integers $n$ and $m$ for which the complete bipartite graph $K_{n,m}$ has an Eulerian circuit.\n\n### Step 1: Extract Givens\n- The graphs under consideration are finite, simple, and undirected.\n- $K_{n,m}$ denotes the complete bipartite graph with bipartition classes of sizes $n$ and $m$.\n- The sizes of the partition classes are $n,m \\in \\mathbb{Z}_{\\ge 1}$, which means $n \\ge 1$ and $m \\ge 1$.\n- The task is to find a characterization for the existence of an Eulerian circuit in $K_{n,m}$.\n- The derivation must be based on standard definitions of bipartite graphs, vertex degrees, graph connectivity, and the characterization of Eulerian circuits.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is a standard exercise in introductory graph theory.\n- **Scientifically Grounded:** The concepts of complete bipartite graphs ($K_{n,m}$) and Eulerian circuits are fundamental and rigorously defined within the mathematical field of graph theory. The problem is based on established mathematical principles.\n- **Well-Posed:** The problem asks for a precise characterization, which is a necessary and sufficient condition. All terms are standard and clearly defined, and the constraints ($n, m \\ge 1$) are explicit. A unique, meaningful solution exists and can be derived from the given principles.\n- **Objective:** The language is formal and mathematical, free of ambiguity or subjective claims.\n\nThe problem statement is valid as it is self-contained, consistent, and grounded in established mathematical theory.\n\n### Step 3: Derivation of the Solution\n\nAccording to a fundamental theorem in graph theory, a finite undirected graph $G$ has an Eulerian circuit if and only if it satisfies two conditions:\n1.  $G$ is connected (except possibly for isolated vertices, though a graph with an edge-traversing circuit cannot have isolated vertices unconnected to the main component).\n2.  Every vertex in $G$ has an even degree.\n\nWe will now apply these two conditions to the complete bipartite graph $K_{n,m}$.\n\n**1. Connectivity of $K_{n,m}$**\n\nLet the vertex set of $K_{n,m}$ be $V = U \\cup W$, where $U$ and $W$ are the disjoint partition sets with $|U| = n$ and $|W| = m$. The problem states that $n \\ge 1$ and $m \\ge 1$.\n\n-   Let $v_1, v_2$ be any two vertices in $V$.\n    -   If $v_1 \\in U$ and $v_2 \\in W$, then by the definition of a complete bipartite graph, the edge $\\{v_1, v_2\\}$ exists. Thus, they are connected by a path of length $1$.\n    -   If $v_1, v_2$ are both in $U$ (which requires $n \\ge 2$), since $m \\ge 1$, there exists at least one vertex $w \\in W$. The path $v_1 - w - v_2$ connects $v_1$ and $v_2$.\n    -   If $v_1, v_2$ are both in $W$ (which requires $m \\ge 2$), since $n \\ge 1$, there exists at least one vertex $u \\in U$. The path $v_1 - u - v_2$ connects $v_1$ and $v_2$.\n\nSince any pair of vertices is connected by a path, the graph $K_{n,m}$ is connected for all $n, m \\ge 1$. The first condition for an Eulerian circuit is therefore always met.\n\n**2. Vertex Degrees in $K_{n,m}$**\n\nNow we examine the degrees of the vertices.\n-   Consider any vertex $u \\in U$. By definition of $K_{n,m}$, this vertex is connected to every vertex in $W$, and to no vertex in $U$. Since $|W| = m$, the degree of any vertex $u \\in U$ is $\\text{deg}(u) = m$.\n-   Similarly, consider any vertex $w \\in W$. This vertex is connected to every vertex in $U$, and to no vertex in $W$. Since $|U| = n$, the degree of any vertex $w \\in W$ is $\\text{deg}(w) = n$.\n\nFor $K_{n,m}$ to have an Eulerian circuit, every vertex must have an even degree. This implies:\n-   The degree of all vertices in $U$ must be even. Thus, $m$ must be an even integer.\n-   The degree of all vertices in $W$ must be even. Thus, $n$ must be an even integer.\n\nCombining these, a complete bipartite graph $K_{n,m}$ (with $n, m \\ge 1$) has an Eulerian circuit if and only if both $n$ and $m$ are even integers.\n\n### Evaluation of Options\n\nNow, we evaluate each of the given options against our derived condition.\n\n**A. $K_{n,m}$ has an Eulerian circuit exactly when both $n$ and $m$ are even integers (with $n,m \\ge 1$).**\nThis statement perfectly matches our derived necessary and sufficient condition. The parenthetical remark \"with $n,m \\ge 1$\" is consistent with the problem's setup.\n**Verdict: Correct.**\n\n**B. $K_{n,m}$ has an Eulerian circuit exactly when both $n$ and $m$ are odd and $n=m$.**\nIf $n$ and $m$ are both odd, then the degree of every vertex in the partition of size $n$ is $m$ (odd), and the degree of every vertex in the partition of size $m$ is $n$ (odd). Since all vertices have odd degrees, the condition that all vertices must have even degrees is violated. Therefore, no Eulerian circuit exists.\n**Verdict: Incorrect.**\n\n**C. $K_{n,m}$ has an Eulerian circuit exactly when one of $n$ or $m$ is even and the other is odd.**\nSuppose $n$ is even and $m$ is odd, without loss of generality. The $n$ vertices in the partition of size $n$ each have degree $m$ (odd). The $m$ vertices in the partition of size $m$ each have degree $n$ (even). Since there exist vertices of odd degree (specifically, all $n$ vertices in one partition), the graph does not have an Eulerian circuit. (It would have an Eulerian path if and only if there are exactly two vertices of odd degree, which would require $n=2$.)\n**Verdict: Incorrect.**\n\n**D. $K_{n,m}$ has an Eulerian circuit exactly when $n+m$ is even (with $n,m \\ge 1$).**\nThe sum $n+m$ is even if and only if $n$ and $m$ have the same parity. This means either both are even or both are odd.\n-   If both $n$ and $m$ are even, an Eulerian circuit exists.\n-   If both $n$ and $m$ are odd, as shown in the analysis of option B, no Eulerian circuit exists.\nSince this condition includes a case where no Eulerian circuit exists, it is not a sufficient condition. Therefore, it is not an exact characterization.\n**Verdict: Incorrect.**\n\n**E. $K_{n,m}$ has an Eulerian circuit exactly when $n=m$ and $n \\ge 2$.**\nThis condition is neither necessary nor sufficient.\n-   Not sufficient: consider $n=m=3$. Here, $n$ and $m$ are both odd, so all vertices have degree $3$. No Eulerian circuit exists. This provides a counterexample.\n-   Not necessary: consider $K_{2,4}$. Here $n=2$ and $m=4$. Both are even, so an Eulerian circuit exists. However, $n \\ne m$. This provides a counterexample.\n**Verdict: Incorrect.**\n\nBased on the analysis, only option A provides the correct characterization.", "answer": "$$\\boxed{A}$$", "id": "3237299"}, {"introduction": "The ultimate test of understanding is the ability to apply theoretical knowledge to build practical tools. This final practice bridges the gap between abstract graph concepts and efficient algorithm design. You are tasked with implementing a system to detect cycles in a dynamic graph, a common problem in network analysis and data processing. [@problem_id:3237184] The solution hinges on a clever application of connectivity principles, solidifying your understanding by turning theory into a working program.", "problem": "You are given an undirected graph $G = (V, E)$ with a finite set of vertices $V$ labeled as the integer range $\\{0, 1, \\dots, n-1\\}$, and an initially specified set of edges $E$ that may be empty. The graph evolves by proposed additions of edges of the form $(u, v)$, where $u, v \\in V$. Your task is to design and implement a complete program that maintains a data structure grounded in graph properties to efficiently report, for each proposed edge addition, whether adding the edge $(u, v)$ would create a cycle in the current undirected graph.\n\nThe foundational base you must rely on is the following collection of definitions and facts:\n- A simple path in an undirected graph is a sequence of distinct vertices $(x_0, x_1, \\dots, x_k)$ such that for every index $i$ with $0 \\le i  k$, the pair $(x_i, x_{i+1})$ is an edge in the graph.\n- A cycle in an undirected graph is a path $(x_0, x_1, \\dots, x_{k-1}, x_0)$ with $k \\ge 3$ whose vertices $x_0, x_1, \\dots, x_{k-1}$ are distinct except that the first and last vertices coincide; by convention, adding a self-loop $(u, u)$ is considered to create a cycle immediately.\n- A connected component is a maximal set of vertices where each pair of vertices in the set is connected by some path.\n- A tree is a connected undirected acyclic graph, and a forest is a disjoint union of trees.\n\nYour program must implement a data structure that can determine, for each proposed edge $(u, v)$, whether adding $(u, v)$ would create a cycle. The decision must be made based strictly on graph-theoretic properties of connectivity as the graph evolves with accepted additions. The program must assume that each proposed edge is undirected. If adding $(u, v)$ would create a cycle, the program must output the boolean value $\\texttt{True}$ for that proposal; otherwise, the program must output $\\texttt{False}$ and incorporate $(u, v)$ into the data structure going forward. Self-loops $(u, u)$ always yield $\\texttt{True}$.\n\nYour program must use the following test suite, where each test case consists of $(n, E_{\\text{init}}, E_{\\text{add}})$:\n- Test case A (general case):\n  - $n = 5$\n  - $E_{\\text{init}} = \\emptyset$\n  - $E_{\\text{add}} = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]$\n- Test case B (merging components then closing a cycle):\n  - $n = 4$\n  - $E_{\\text{init}} = [(0, 1), (2, 3)]$\n  - $E_{\\text{add}} = [(1, 2), (0, 2), (1, 3)]$\n- Test case C (self-loop and repeated connection):\n  - $n = 3$\n  - $E_{\\text{init}} = \\emptyset$\n  - $E_{\\text{add}} = [(0, 0), (1, 2), (2, 1)]$\n- Test case D (single vertex boundary):\n  - $n = 1$\n  - $E_{\\text{init}} = \\emptyset$\n  - $E_{\\text{add}} = [(0, 0), (0, 0)]$\n\nFor each test case, your program must output a list of booleans in the order of $E_{\\text{add}}$, where each boolean indicates whether the corresponding proposed edge addition would create a cycle at the time of the proposal. Your program should produce a single line of output containing the results aggregated across all provided test cases into a single comma-separated list enclosed in square brackets, with each test caseâ€™s list enclosed in its own square brackets and no spaces. For example, an aggregate of two test cases with results $\\texttt{[True,False]}$ and $\\texttt{[False]}$ must be printed exactly as $\\texttt{[[True,False],[False]]}$.\n\nAll answers are pure booleans, and no physical units are involved. Angles and percentages do not appear in this problem. The program must be a complete, runnable program and must not read input from standard input or from files; it must run as-is and print the specified single-line output.", "solution": "The problem asks for an efficient method to detect if adding a new edge to an undirected graph creates a cycle. This can be solved by leveraging the fundamental properties of graph connectivity.\n\n**Theoretical Basis:**\nThe core graph-theoretic principle is: In an undirected graph, adding an edge $(u, v)$ creates a cycle if and only if there is already a path between vertices $u$ and $v$. This is equivalent to stating that vertices $u$ and $v$ belong to the same connected component. If they are in different components, the new edge $(u, v)$ simply serves as a bridge to merge these two previously separate components into a single larger one, without forming any cycle.\n\n**Algorithmic Strategy:**\nTo implement this logic efficiently, we need a data structure that can:\n1.  Maintain a collection of disjoint sets, where each set represents the vertices of a connected component.\n2.  Quickly determine which component (set) a vertex belongs to.\n3.  Quickly merge two components (sets) when a new edge connects them.\n\nThe **Disjoint Set Union (DSU)** data structure, also known as Union-Find, is perfectly designed for this task.\n\n**Implementation with Union-Find:**\n1.  **Initialization**: We start by creating a DSU structure for the $n$ vertices. Each vertex is initially in its own component, so we have $n$ disjoint sets.\n2.  **Processing Initial Edges**: For each edge $(u, v)$ in the initial set $E_{init}$, we perform a `union(u, v)` operation. This merges the components containing $u$ and $v$, correctly reflecting the graph's initial connectivity structure.\n3.  **Processing Proposed Edges**: For each proposed new edge $(u, v)$:\n    *   A special case is a **self-loop** $(u, u)$. By definition, this immediately creates a cycle. So, we report `True`.\n    *   For a standard edge $(u, v)$ with $u \\neq v$, we use the `find` operation to determine the representatives (or roots) of the components containing $u$ and $v$.\n    *   **Cycle Detection**: If `find(u)` is equal to `find(v)`, it means both vertices are already in the same connected component. Adding an edge between them would create a new path within that component, thus forming a cycle. In this case, we report `True`.\n    *   **No Cycle**: If `find(u)` is not equal to `find(v)`, the vertices are in different components. Adding the edge will not create a cycle. In this case, we report `False` and then update our data structure by performing a `union(u, v)` operation to reflect that the edge has been added and the two components are now merged.\n\nThis approach provides an efficient way to check for cycles in near-constant amortized time for each edge addition, making it highly suitable for dynamic graph analysis. The provided Python code implements this exact logic using a Union-Find class with path compression and union by rank optimizations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass UnionFind:\n    \"\"\"\n    An implementation of the Union-Find (Disjoint Set Union) data structure.\n\n    This data structure keeps track of a set of elements partitioned into a\n    number of disjoint (non-overlapping) subsets. It provides two main\n    operations: find, which determines which subset an element is in, and\n    union, which joins two subsets into a single subset.\n\n    This implementation uses two standard optimizations for near-constant time\n    amortized performance:\n    1. Union by Rank: When merging two sets, the root of the shorter tree\n       is made a child of the root of the taller tree. This keeps the trees\n       from becoming too deep.\n    2. Path Compression: During a find operation, the path from the element\n       to the root is flattened, making future finds faster.\n    \"\"\"\n    def __init__(self, n):\n        \"\"\"\n        Initializes the Union-Find structure for n elements.\n        Each element from 0 to n-1 starts in its own set.\n        \n        Args:\n            n (int): The number of elements.\n        \"\"\"\n        # parent[i] stores the parent of element i.\n        self.parent = np.arange(n)\n        # rank[i] stores the height of the tree rooted at i.\n        self.rank = np.zeros(n, dtype=int)\n\n    def find(self, i):\n        \"\"\"\n        Finds the representative (root) of the set containing element i.\n        Implements path compression.\n        \n        Args:\n            i (int): The element to find.\n        \n        Returns:\n            int: The representative of the set.\n        \"\"\"\n        if self.parent[i] == i:\n            return i\n        # Path compression: set the parent of i directly to the root.\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        \"\"\"\n        Merges the sets containing elements i and j.\n        Implements union by rank.\n        \n        Args:\n            i (int): The first element.\n            j (int): The second element.\n        \"\"\"\n        root_i = self.find(i)\n        root_j = self.find(j)\n        \n        if root_i != root_j:\n            # Union by rank\n            if self.rank[root_i]  self.rank[root_j]:\n                self.parent[root_i] = root_j\n            elif self.rank[root_i] > self.rank[root_j]:\n                self.parent[root_j] = root_i\n            else:\n                self.parent[root_j] = root_i\n                self.rank[root_i] += 1\n\n\ndef solve():\n    \"\"\"\n    Solves the cycle detection problem for a series of test cases.\n    For each test case, it processes initial and proposed edge additions,\n    reporting for each proposed edge whether its addition would create a cycle.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A (general case)\n        (5, [], [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]),\n        # Test case B (merging components then closing a cycle)\n        (4, [(0, 1), (2, 3)], [(1, 2), (0, 2), (1, 3)]),\n        # Test case C (self-loop and repeated connection)\n        (3, [], [(0, 0), (1, 2), (2, 1)]),\n        # Test case D (single vertex boundary)\n        (1, [], [(0, 0), (0, 0)]),\n    ]\n\n    all_results = []\n    \n    for n, E_init, E_add in test_cases:\n        # Initialize Union-Find data structure for n vertices.\n        uf = UnionFind(n)\n        \n        # Process the initial set of edges to establish the starting graph state.\n        for u, v in E_init:\n            uf.union(u, v)\n        \n        case_results = []\n        # Process each proposed edge addition.\n        for u, v in E_add:\n            # According to the problem, a self-loop (u, u) always creates a cycle.\n            if u == v:\n                case_results.append(True)\n                # The state of the graph does not change for a rejected edge.\n                continue\n\n            # Check if u and v are already in the same connected component.\n            # If find(u) == find(v), they are, and adding edge (u, v) creates a cycle.\n            if uf.find(u) == uf.find(v):\n                case_results.append(True)\n            else:\n                # If they are in different components, adding the edge does not create a cycle.\n                case_results.append(False)\n                # The edge is added to the graph, so we merge the components.\n                uf.union(u, v)\n        \n        all_results.append(case_results)\n\n    # Format the final output string as specified.\n    # e.g., [[False,False,True],[False,True]]\n    output_str = f\"[{','.join([str(res).replace(' ', '') for res in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3237184"}]}