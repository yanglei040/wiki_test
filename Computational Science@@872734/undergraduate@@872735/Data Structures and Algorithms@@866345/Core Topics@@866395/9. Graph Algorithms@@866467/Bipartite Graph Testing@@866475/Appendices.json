{"hands_on_practices": [{"introduction": "Mastering a new concept begins with applying its fundamental algorithm. This first practice challenges you to implement the standard breadth-first search (BFS) based 2-coloring test for bipartiteness. By constructing and analyzing hypercube graphs, which are inherently bipartite, you'll gain hands-on experience with both graph generation and the core logic for detecting odd cycles introduced by extra edges [@problem_id:3216705].", "problem": "Consider an undirected graph $G = (V, E)$ defined as follows. For a given integer $n \\geq 0$, the vertex set $V$ consists of all binary strings of length $n$, that is $V = \\{0,1\\}^n$. Two vertices $x, y \\in V$ are connected by an edge if and only if their Hamming distance is exactly $1$, meaning they differ in exactly one bit position. This graph is the standard $n$-dimensional hypercube. In addition, an optional finite set of undirected edges $E^{+} \\subseteq V \\times V$ may be added to the hypercube. Every added undirected edge $(u,v) \\in E^{+}$ must satisfy $u \\neq v$ and $u, v \\in \\{0,1\\}^n$.\n\nYour task is to write a complete program that constructs $G$ for each specified $n$ and optional $E^{+}$, and then determines whether $G$ is bipartite. Your program must test bipartiteness using a general-purpose algorithm that attempts to assign two colors to the vertices so that every edge has endpoints of opposite colors, and should work for any undirected graph without assuming special symmetry or properties of the hypercube. The graph representation in the program may label each vertex by the integer in the range $\\{0,1,\\dots,2^n - 1\\}$ corresponding to its binary string, and edges should be constructed by flipping one bit for the hypercube adjacency and then adding any specified $(u,v) \\in E^{+}$.\n\nFoundational definitions to use:\n- A graph $G$ is bipartite if there exists a partition of the vertices into two disjoint sets $A$ and $B$ such that every edge has one endpoint in $A$ and the other in $B$.\n- Equivalently, a graph is bipartite if it admits a $2$-coloring of its vertices so that adjacent vertices have distinct colors.\n\nYou must implement an algorithm derived from these definitions, for example a traversal-based $2$-coloring procedure, and apply it to each test case.\n\nTest suite specification:\nCompute and report bipartiteness for the following parameter sets, in the given order. For each case, $E^{+}$ is listed as a set of integer pairs, where integers are in $\\{0,1,\\dots,2^n - 1\\}$.\n\n- Case $1$: $n = 0$, $E^{+} = \\varnothing$.\n- Case $2$: $n = 1$, $E^{+} = \\varnothing$.\n- Case $3$: $n = 2$, $E^{+} = \\varnothing$.\n- Case $4$: $n = 3$, $E^{+} = \\varnothing$.\n- Case $5$: $n = 6$, $E^{+} = \\{(0, 63)\\}$, where $63 = 2^6 - 1$.\n- Case $6$: $n = 5$, $E^{+} = \\{(0, 31)\\}$, where $31 = 2^5 - 1$.\n- Case $7$: $n = 10$, $E^{+} = \\varnothing$.\n- Case $8$: $n = 4$, $E^{+} = \\{(0, 15)\\}$, where $15 = 2^4 - 1$.\n\nAnswer specification:\n- For each case, output a boolean indicating whether the resulting graph $G$ is bipartite.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite above, for example $[{\\tt True},{\\tt False},\\dots]$.\n- No physical units, angle units, or percentages are involved in this problem.\n\nThe program must be self-contained and require no input. It must construct each graph according to the description, run the bipartiteness test, and print the results in the exact format specified.", "solution": "The problem is valid. It is a well-posed, scientifically grounded problem in the field of graph theory and algorithms. All terms are clearly defined, and the test cases are specific and computationally feasible.\n\nThe core of this problem is to determine if a given graph $G=(V, E)$ is bipartite. A graph is bipartite if and only if it contains no cycles of odd length. A standard and general algorithm to test for bipartiteness is to attempt a $2$-coloring of the graph's vertices using a graph traversal method, such as Breadth-First Search (BFS) or Depth-First Search (DFS).\n\nThe algorithm proceeds as follows:\n1.  Represent the graph, for which we use an adjacency list. The number of vertices is $N=2^n$. The vertices are labeled by integers from $0$ to $2^n - 1$.\n2.  Create a `colors` array of size $N$, initialized with a sentinel value (e.g., $-1$) to indicate that no vertex has been colored yet.\n3.  Iterate through each vertex $v \\in V$. If vertex $v$ has not yet been colored, it means we have found a new, undiscovered connected component of the graph. We begin a traversal (e.g., BFS) from this vertex.\n    a. Assign a starting color, say $0$, to the source vertex $v$ and add it to a queue for the BFS.\n    b. While the queue is not empty, dequeue a vertex $u$.\n    c. For each neighbor $w$ of $u$:\n        i. If $w$ is uncolored (i.e., `colors[w]` is $-1$), it means we are visiting it for the first time in this traversal. We assign it the color opposite to $u$'s color, i.e., $1 - \\text{colors}[u]$, and enqueue $w$.\n        ii. If $w$ has already been colored, a potential conflict arises. If `colors[w]` is the same as `colors[u]`, it implies that there is an edge between two vertices of the same color. This situation can only occur if the graph contains an odd-length cycle. The path from the component's starting vertex to $u$ and to $w$ must have path lengths of the same parity for them to receive the same color, and the edge $(u,w)$ closes a cycle. The length of this cycle is $(\\text{dist}(s,u) + \\text{dist}(s,w) + 1)$, which must be odd. Therefore, the graph is not bipartite, and the algorithm can terminate immediately, returning `False`.\n4.  If the algorithm completes the iteration through all vertices and their components without finding any same-color adjacent vertices, it means a valid $2$-coloring has been found. The graph is bipartite, and the algorithm returns `True`.\n\nThe graph for each test case is an $n$-dimensional hypercube potentially augmented with additional edges from a set $E^+$. The vertices of the hypercube are the binary strings of length $n$, which we map to integers from $0$ to $2^n-1$. An edge exists between two vertices in the base hypercube if their binary representations differ in exactly one position. This is equivalent to their integer representations $u$ and $v$ satisfying $v = u \\oplus (1 \\ll i)$ for some bit position $i \\in \\{0, 1, \\dots, n-1\\}$, where $\\oplus$ is the bitwise XOR operator and $\\ll$ is the left bit-shift operator.\n\nAll hypercubes are inherently bipartite. The vertices can be partitioned based on the parity of the number of $1$s in their binary representation (the population count). An edge in a hypercube always connects a vertex with an even population count to one with an odd population count. Adding an extra edge $(u,v) \\in E^+$ may violate this property. If both $u$ and $v$ have population counts of the same parity, they would belong to the same set in the original bipartition. Adding an edge between them creates an odd-length cycle, rendering the graph non-bipartite. The parity of the population counts of $u$ and $v$ are the same if and only if the Hamming distance between them, $d(u,v) = \\text{popcount}(u \\oplus v)$, is an even number.\n\nFor the given test cases:\n- Cases $1, 2, 3, 4, 7$: $E^+ = \\varnothing$. The graphs are pure hypercubes of dimension $n=0, 1, 2, 3, 10$ respectively. All are bipartite. Result: `True`.\n- Case $5$: $n=6, E^+=\\{(0, 63)\\}$. The vertex $u=0$ has binary representation `000000`, with $\\text{popcount}(0)=0$ (even). The vertex $v=63$ is $2^6-1$, binary `111111`, with $\\text{popcount}(63)=6$ (even). Since both vertices have popcounts of the same parity, adding an edge between them creates an odd cycle. Result: `False`.\n- Case $6$: $n=5, E^+=\\{(0, 31)\\}$. The vertex $u=0$ has $\\text{popcount}(0)=0$ (even). The vertex $v=31$ is $2^5-1$, binary `11111`, with $\\text{popcount}(31)=5$ (odd). The vertices have popcounts of different parity, so adding an edge between them preserves bipartiteness. Result: `True`.\n- Case $8$: $n=4, E^+=\\{(0, 15)\\}$. The vertex $u=0$ has $\\text{popcount}(0)=0$ (even). The vertex $v=15$ is $2^4-1$, binary `1111`, with $\\text{popcount}(15)=4$ (even). The vertices have popcounts of the same parity. The graph is not bipartite. Result: `False`.\n\nThe implementation will construct the graph for each case and apply the general BFS-based $2$-coloring algorithm as required, without using the popcount shortcut.", "answer": "```python\nimport numpy as np\nimport collections\n\ndef is_bipartite(n, extra_edges):\n    \"\"\"\n    Determines if a graph is bipartite using a BFS-based 2-coloring algorithm.\n\n    The graph is an n-hypercube with optional additional edges.\n    \n    Args:\n        n (int): The dimension of the hypercube. Vertices are 0 to 2**n - 1.\n        extra_edges (set): A set of tuples representing additional undirected edges.\n\n    Returns:\n        bool: True if the graph is bipartite, False otherwise.\n    \"\"\"\n    if n < 0:\n        return True # Or raise error, but per problem n>=0\n    \n    num_vertices = 1 << n # This is 2**n\n    \n    if num_vertices == 0:\n        return True # No vertices\n        \n    adj = collections.defaultdict(list)\n\n    # Build adjacency list for the n-hypercube\n    for u in range(num_vertices):\n        for i in range(n):\n            v = u ^ (1 << i)\n            # This check is not strictly necessary as v will be in range\n            # but is good practice if u was not guaranteed to be in range.\n            if v < num_vertices:\n                adj[u].append(v)\n    \n    # Add the extra edges\n    for u, v in extra_edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # colors array: -1 for uncolored, 0 for color A, 1 for color B\n    colors = np.full(num_vertices, -1, dtype=np.int8)\n\n    # Iterate through all vertices to handle disconnected components\n    for start_node in range(num_vertices):\n        if colors[start_node] == -1:\n            # Start BFS for this component\n            colors[start_node] = 0\n            queue = collections.deque([start_node])\n            \n            while queue:\n                u = queue.popleft()\n                \n                for v in adj[u]:\n                    if colors[v] == -1:\n                        # Color the neighbor with the opposite color\n                        colors[v] = 1 - colors[u]\n                        queue.append(v)\n                    elif colors[v] == colors[u]:\n                        # An edge connects two vertices of the same color,\n                        # hence an odd cycle exists.\n                        return False\n                        \n    # If all components are successfully 2-colored, the graph is bipartite.\n    return True\n\ndef solve():\n    \"\"\"\n    Runs the bipartiteness test on the specified suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'n': 0, 'E_plus': set()},\n        # Case 2\n        {'n': 1, 'E_plus': set()},\n        # Case 3\n        {'n': 2, 'E_plus': set()},\n        # Case 4\n        {'n': 3, 'E_plus': set()},\n        # Case 5\n        {'n': 6, 'E_plus': {(0, 63)}},\n        # Case 6\n        {'n': 5, 'E_plus': {(0, 31)}},\n        # Case 7\n        {'n': 10, 'E_plus': set()},\n        # Case 8\n        {'n': 4, 'E_plus': {(0, 15)}},\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case['n']\n        extra_edges = case['E_plus']\n        result = is_bipartite(n, extra_edges)\n        results.append(result)\n    \n    # Format the final output string exactly as specified.\n    # The boolean values True/False must be capitalized.\n    output_str = f\"[{','.join(str(r) for r in results)}]\"\n    print(output_str)\n\nsolve()\n\n```", "id": "3216705"}, {"introduction": "Effective problem-solving often involves moving beyond general-purpose tools to exploit a problem's unique structure for a more efficient solution. This exercise asks you to consider a special case: a graph formed by a tree plus a single extra edge. Instead of applying a full 2-coloring test, you will derive a more direct, linear-time algorithm by analyzing the single cycle created in this specific graph structure [@problem_id:3216784].", "problem": "Let an undirected, simple, connected graph $G=(V,E)$ be obtained by taking a tree $T$ on $|V|=n$ vertices (so $|E(T)|=n-1$) and adding exactly $1$ extra edge between two distinct, non-adjacent vertices of $T$. Such a graph has exactly $1$ simple cycle. A graph is called bipartite if its vertex set can be partitioned into two disjoint parts $A$ and $B$ such that every edge has one endpoint in $A$ and the other endpoint in $B$. You are to design and implement a linear-time algorithm, expressed and justified from first principles, to decide whether $G$ is bipartite. The algorithm must not rely on any shortcut formulas presented in this problem statement and must be derived from foundational definitions and well-tested facts.\n\nFundamental base requirements:\n- Use only the core definitions of graphs, trees, paths, and cycles, and the well-tested fact that a graph is bipartite if and only if it contains no odd-length cycle.\n- The design must start from these bases, explain why they imply the desired test for $G$ (a tree plus $1$ extra edge), and show how to implement the decision in time $O(n)$.\n\nProgram specification:\n- Vertices are labeled by integers $0,1,2,\\dots,n-1$.\n- Each test case is specified by:\n  - An integer $n$ (number of vertices).\n  - A list of $n-1$ undirected tree edges forming $T$.\n  - A single undirected extra edge $(u,v)$ whose endpoints are distinct and non-adjacent in $T$.\n- Your program must implement a linear-time algorithm that, for each test case, returns a boolean indicating whether the resulting graph $G$ is bipartite.\n\nTest suite:\nProvide the results for the following test cases (all edges are undirected):\n- Test case $1$: $n=3$, tree edges $\\{(0,1),(1,2)\\}$, extra edge $(0,2)$.\n- Test case $2$: $n=4$, tree edges $\\{(0,1),(1,2),(2,3)\\}$, extra edge $(0,3)$.\n- Test case $3$: $n=5$, tree edges $\\{(0,1),(0,2),(0,3),(0,4)\\}$, extra edge $(1,2)$.\n- Test case $4$: $n=6$, tree edges $\\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$, extra edge $(1,4)$.\n- Test case $5$: $n=7$, tree edges $\\{(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)\\}$, extra edge $(3,2)$.\n- Test case $6$: $n=8$, tree edges $\\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7)\\}$, extra edge $(2,6)$.\n\nOutput format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3]$), where each $r_i$ is the boolean result for test case $i$ in the order given above.\n\nThere are no physical quantities involved, so no units are required. Angles do not appear, so no angle units are required. Percentages do not appear, so there is no special instruction for percentage formatting.", "solution": "The validity of the problem statement is established. It is a well-posed problem in algorithmic graph theory, grounded in standard definitions and theorems, and free of any scientific or logical flaws.\n\nThe solution is derived from first principles, beginning with the fundamental characterization of bipartite graphs.\n\n**1. Foundational Principle of Bipartite Graphs**\n\nA cornerstone theorem in graph theory states that an undirected graph is bipartite if and only if it contains no simple cycles of odd length. A graph is bipartite if its vertices can be partitioned into two disjoint sets, say $A$ and $B$, such that every edge connects a vertex in $A$ to one in $B$. If a cycle has an odd number of vertices, say $v_1, v_2, \\dots, v_k, v_1$ with $k$ being odd, any attempt to $2$-color it will fail. If $v_1$ is in set $A$, then $v_2$ must be in $B$, $v_3$ in $A$, and so on. For any vertex $v_i$, its color will be determined by the parity of its index $i$. The vertex $v_k$ will have the same color as $v_1$ if $k-1$ is even, which is true if $k$ is odd. However, the edge $(v_k, v_1)$ connects them, creating a conflict. Conversely, if a graph has no odd cycles, a $2$-coloring can always be found.\n\n**2. Structural Analysis of the Graph $G$**\n\nThe problem specifies that the graph $G=(V,E)$ is constructed by taking a tree $T$ on $n$ vertices and adding a single extra edge $(u,v)$ between two distinct, non-adjacent vertices of $T$. We analyze the cyclic structure that results from this construction.\n\n- A tree is, by definition, a connected graph that contains no cycles.\n- A fundamental property of a tree is that for any two vertices, say $u$ and $v$, there exists a unique simple path between them. Let us denote this path in $T$ as $P_{uv}$.\n- The graph $G$ is formed by the union of the tree $T$ and the edge $(u,v)$. The edge set of $G$ is $E(G) = E(T) \\cup \\{(u,v)\\}$.\n- The addition of the edge $(u,v)$ creates a cycle $C$ composed of the path $P_{uv}$ and the edge $(u,v)$ itself.\n- This cycle $C$ is the *only* simple cycle in $G$. To see why, assume there exists another simple cycle $C'$. If $C'$ does not use the edge $(u,v)$, then all its edges must belong to the tree $T$. This would imply that $T$ contains a cycle, which contradicts the definition of a tree. Therefore, any cycle in $G$ must involve the edge $(u,v)$. Since $P_{uv}$ is the unique path between $u$ and $v$ in $T$, any cycle containing $(u,v)$ must be formed by traversing $P_{uv}$ and then returning via the edge $(u,v)$. Thus, $C$ is the unique simple cycle in $G$.\n\n**3. Derivation of a Specific Test for Bipartiteness**\n\nCombining the foundational principle with the structural analysis of $G$, we can formulate a direct test for bipartiteness.\n\n- According to the principle, $G$ is bipartite if and only if it has no odd-length cycles.\n- Since we have established that $G$ has exactly one simple cycle, $C$, the condition for bipartiteness simplifies: $G$ is bipartite if and only if the length of this unique cycle $C$ is even.\n\n**4. Calculation of the Cycle Length**\n\nThe length of a cycle, denoted $|C|$, is the number of edges it contains. The cycle $C$ is formed by the edges of the path $P_{uv}$ and the single edge $(u,v)$. Therefore, its length is:\n$$|C| = |P_{uv}| + 1$$\nHere, $|P_{uv}|$ is the number of edges on the unique path between $u$ and $v$ in the tree $T$. This is, by definition, the distance between $u$ and $v$ in $T$, denoted $\\text{dist}_T(u,v)$.\nSo, the cycle length is:\n$$|C| = \\text{dist}_T(u,v) + 1$$\nThe condition that $G$ is bipartite is that $|C|$ must be even. This implies that $\\text{dist}_T(u,v) + 1$ must be even, which is true if and only if $\\text{dist}_T(u,v)$ is odd.\n\n**5. The Linear-Time Algorithm**\n\nThe problem is now reduced to computing the distance between vertices $u$ and $v$ in the tree $T$ and checking if this distance is odd. This can be accomplished efficiently in linear time.\n\n- **Algorithm**:\n    1.  Construct an adjacency list representation of the tree $T$ from the given $n-1$ edges. This requires iterating through the edges once and takes $O(n)$ time.\n    2.  Perform a Breadth-First Search (BFS) starting from vertex $u$ to find the distance to all other vertices in the tree. We use a queue and a distance array, `distances`, of size $n$, initialized with a value (e.g., $-1$) indicating that vertices have not yet been visited.\n    3.  Initialize the queue with $u$ and set `distances[u] = 0`.\n    4.  While the queue is not empty, dequeue a vertex, say `curr`. For each neighbor `next` of `curr`, if `distances[next]` is $-1$, update it to `distances[curr] + 1` and enqueue `next`.\n    5.  The BFS explores each vertex and edge of the tree exactly once. When the algorithm finishes (or, as an optimization, as soon as `v` is reached), the value `distances[v]` will hold $\\text{dist}_T(u,v)$.\n    6.  The final step is to check if `distances[v]` is odd. If it is, the graph $G$ is bipartite; otherwise, it is not.\n\n- **Complexity Analysis**:\n    - The adjacency list construction is $O(n)$.\n    - The BFS on a tree (a connected graph with $n$ vertices and $n-1$ edges) has a time complexity of $O(|V|+|E(T)|) = O(n + (n-1)) = O(n)$.\n    - The final check is an $O(1)$ operation.\n    - Thus, the entire algorithm runs in $O(n)$, satisfying the problem's linear-time requirement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport collections\n\ndef is_bipartite_for_tree_plus_one_edge(n, tree_edges, extra_edge):\n    \"\"\"\n    Determines if a graph formed by a tree plus one edge is bipartite.\n\n    The method is based on the principle that a graph is bipartite if and only if\n    it contains no odd-length cycles. The given graph structure has exactly one\n    cycle, formed by the extra edge (u, v) and the unique path between u and v\n    in the tree. The graph is bipartite if and only if this cycle has an even\n    length.\n\n    Cycle length = dist_T(u, v) + 1.\n    For the cycle length to be even, dist_T(u, v) must be odd.\n\n    This function calculates the distance between u and v in the tree using BFS\n    and checks if it is odd.\n\n    Args:\n        n (int): The number of vertices.\n        tree_edges (list of tuple): A list of n-1 edges forming the tree.\n        extra_edge (tuple): The single edge added to the tree.\n\n    Returns:\n        bool: True if the graph is bipartite, False otherwise.\n    \"\"\"\n    u, v = extra_edge\n\n    # Step 1: Build the adjacency list for the tree T.\n    # Complexity: O(n) as there are n-1 edges.\n    adj = [[] for _ in range(n)]\n    for a, b in tree_edges:\n        adj[a].append(b)\n        adj[b].append(a)\n\n    # Step 2: Use Breadth-First Search (BFS) to find the distance from u to v.\n    # Complexity: O(n) for a tree with n vertices.\n    queue = collections.deque([u])\n    # distances array tracks distance from u and also serves as a visited set.\n    distances = [-1] * n\n    distances[u] = 0\n\n    while queue:\n        current_node = queue.popleft()\n\n        # If we have reached the target vertex v, we have found the distance.\n        if current_node == v:\n            break\n\n        for neighbor in adj[current_node]:\n            # If the neighbor has not been visited yet\n            if distances[neighbor] == -1:\n                distances[neighbor] = distances[current_node] + 1\n                queue.append(neighbor)\n    \n    # Step 3: Check the parity of the distance.\n    # The graph is bipartite iff the unique cycle is of even length.\n    # Cycle length = dist(u,v) + 1.\n    # Length is even iff dist(u,v) is odd.\n    distance_uv = distances[v]\n    \n    # This case should not be reached for a valid connected tree input.\n    if distance_uv == -1:\n        return False\n\n    return distance_uv % 2 == 1\n\ndef solve():\n    \"\"\"\n    Runs the algorithm on the predefined test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: n=3, tree edges {(0,1),(1,2)}, extra edge (0,2).\n        # Path 0-1-2. dist(0,2) = 2. Cycle length = 3 (odd). Not bipartite.\n        (3, [(0, 1), (1, 2)], (0, 2)),\n        # Test case 2: n=4, tree edges {(0,1),(1,2),(2,3)}, extra edge (0,3).\n        # Path 0-1-2-3. dist(0,3) = 3. Cycle length = 4 (even). Bipartite.\n        (4, [(0, 1), (1, 2), (2, 3)], (0, 3)),\n        # Test case 3: n=5, tree edges {(0,1),(0,2),(0,3),(0,4)}, extra edge (1,2).\n        # Path 1-0-2. dist(1,2) = 2. Cycle length = 3 (odd). Not bipartite.\n        (5, [(0, 1), (0, 2), (0, 3), (0, 4)], (1, 2)),\n        # Test case 4: n=6, tree edges {(0,1),(1,2),(2,3),(3,4),(4,5)}, extra edge (1,4).\n        # Path 1-2-3-4. dist(1,4) = 3. Cycle length = 4 (even). Bipartite.\n        (6, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)], (1, 4)),\n        # Test case 5: n=7, tree edges {(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)}, extra edge (3,2).\n        # Path 3-1-0-2. dist(3,2) = 3. Cycle length = 4 (even). Bipartite.\n        (7, [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)], (3, 2)),\n        # Test case 6: n=8, tree edges {(0,1),..,(6,7)}, extra edge (2,6).\n        # Path 2-3-4-5-6. dist(2,6) = 4. Cycle length = 5 (odd). Not bipartite.\n        (8, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)], (2, 6)),\n    ]\n\n    results = []\n    for n, tree_edges, extra_edge in test_cases:\n        result = is_bipartite_for_tree_plus_one_edge(n, tree_edges, extra_edge)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216784"}, {"introduction": "Many real-world systems are dynamic, with connections forming over time. This advanced practice introduces the online version of bipartite testing, where you must check for bipartiteness as edges are added one by one. You will implement an augmented Disjoint Set Union (DSU) data structure, a powerful tool for efficiently tracking component connectivity and color constraints to pinpoint the exact moment an odd cycle is formed [@problem_id:3216756].", "problem": "Consider an undirected simple graph $G = (V,E)$ with vertex set $V$ and edge set $E$. Edges are added one at a time in a fixed sequence, producing a nested family of graphs $G_1, G_2, \\ldots, G_m$, where $G_t$ denotes the graph after the first $t$ edges have been added. A graph is called bipartite if there exists a partition $V = X \\cup Y$ with $X \\cap Y = \\varnothing$ such that every edge has one endpoint in $X$ and the other in $Y$. It is a well-tested fact that an undirected graph is bipartite if and only if it contains no cycle of odd length.\n\nStarting only from the core definitions above, design a program that, for each of the specified test cases, reports the earliest index $t$ in $\\{1,2,\\ldots,m\\}$ such that $G_t$ is not bipartite. If the graph remains bipartite after all $m$ edges have been added, report $0$. A self-loop, that is, an edge of the form $(u,u)$ for some $u \\in V$, immediately causes the graph to be non-bipartite because a single vertex cannot be placed in both parts of the partition simultaneously.\n\nAll graphs in the test suite are undirected, edges may repeat, and vertices are labeled by consecutive integers starting at $1$. An added edge $(u,v)$ is interpreted as placing a constraint that the labels of $u$ and $v$ must be assigned opposite colors in any valid two-coloring of the connected component containing them.\n\nThe test suite consists of the following parameter sets. Each test case is given by a vertex count $n$ and an edge sequence of length $m$, written as ordered pairs $(u,v)$ with $u,v \\in \\{1,2,\\ldots,n\\}$, processed in the order listed.\n\n- Test case $1$: $n = 6$, edges $\\big((1,2),(2,3),(3,4),(4,5),(5,6),(6,1),(1,3)\\big)$.\n- Test case $2$: $n = 5$, edges $\\big((1,2),(2,3),(3,4),(4,5)\\big)$.\n- Test case $3$: $n = 3$, edges $\\big((1,2),(2,2),(2,3)\\big)$.\n- Test case $4$: $n = 4$, edges $\\big((1,2),(2,3),(3,1),(4,1)\\big)$.\n- Test case $5$: $n = 4$, edges $\\big((1,2),(2,3),(1,2),(3,4),(4,1),(2,4)\\big)$.\n- Test case $6$: $n = 3$, edges $\\big(\\ \\big)$ (i.e., no edges).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, in the same order as the test suite (for example, $[r_1,r_2,\\ldots,r_6]$ where each $r_i$ is an integer as specified above).", "solution": "The problem requires the design of an algorithm to determine the earliest point in a sequence of edge additions at which a graph ceases to be bipartite. A graph $G=(V,E)$ is defined as bipartite if its vertex set $V$ can be partitioned into two disjoint sets, $X$ and $Y$, such that every edge in $E$ connects a vertex in $X$ to one in $Y$. The problem statement correctly provides the fundamental theorem: a graph is bipartite if and only if it contains no cycles of odd length. We process a sequence of $m$ edges, creating a series of graphs $G_1, G_2, \\ldots, G_m$, where $G_t$ is the graph with the first $t$ edges. We seek the smallest $t \\in \\{1, 2, \\ldots, m\\}$ for which $G_t$ is not bipartite. If all graphs in the sequence are bipartite, the result is $0$.\n\nThe core of the problem is to efficiently detect the formation of the first odd-length cycle. An edge $(u,v)$ added to an already bipartite graph $G$ will render the new graph non-bipartite if and only if this new edge closes a cycle of odd length. This occurs if and only if vertices $u$ and $v$ are already in the same connected component and the path between them in $G$ has an even length. The addition of the edge $(u,v)$ creates a cycle whose length is the even path length plus $1$, which is odd.\n\nFrom a two-coloring perspective, this means that vertices $u$ and $v$ were required to have the same color in any valid two-coloring of their connected component *before* the edge $(u,v)$ was added. The new edge imposes the constraint that they must have different colors, creating a contradiction.\n\nThis dynamic connectivity and relative coloring problem is elegantly solved using an augmented Disjoint Set Union (DSU) data structure. A standard DSU tracks the connected components of a graph. We augment it to additionally track the parity of the \"distance\" (path length) between nodes within a component, which corresponds to their color relationship in a two-coloring.\n\nOur DSU structure will consist of two primary arrays for a graph with $n$ vertices labeled $1$ through $n$:\n$1$. `parent`: An array of size $n+1$, where `parent[i]` stores the parent of node $i$ in its component's tree representation.\n$2$. `parity`: An array of size $n+1$, where `parity[i]` stores the parity (either $0$ or $1$) of the path length between node $i$ and its parent, `parent[i]`. `parity[i] = 1` implies that $i$ and `parent[i]` must have different colors, while `parity[i] = 0` implies they must have the same color. An edge naturally corresponds to a path of length $1$, so its endpoints have different colors.\n\nThe DSU operations are modified as follows:\n\n**`find(i)` Operation**: This operation finds the representative (root) of the component containing vertex $i$. It implements path compression to maintain efficiency. As the path is compressed (i.e., `parent[i]` is set to the component's root), the `parity[i]` value must be updated to store the parity of the path length from $i$ to the root. If the original path from $i$ to the root was $i \\to p_1 \\to p_2 \\to \\dots \\to \\text{root}$, the new `parity[i]` becomes the XOR sum $(\\text{parity}_{\\text{old}}[i] \\oplus \\text{parity}_{\\text{old}}[p_1] \\oplus \\dots) \\pmod 2$. A recursive implementation handles this naturally. The `find(i)` operation returns a tuple containing the root of the component and the calculated parity of the path from $i$ to that root.\n\n**`union(u, v)` Operation**: This operation processes the addition of a new edge $(u,v)$ and determines if it violates the bipartite property.\n$1$. First, we invoke `find(u)` and `find(v)` to get their respective roots and parities relative to those roots: $(\\text{root}_u, \\text{parity}_u)$ and $(\\text{root}_v, \\text{parity}_v)$.\n$2$. **Case A: Different Components ($\\text{root}_u \\neq \\text{root}_v$)**. The edge connects two previously separate components. This cannot create a cycle, so the graph remains bipartite. We merge the components, for instance, by setting `parent[root_v] = root_u`. We must then establish the parity relationship for this new link. The path from $\\text{root}_v$ to $\\text{root}_u$ now effectively traverses $\\text{root}_v \\leftarrow \\dots \\leftarrow v - u \\rightarrow \\dots \\rightarrow \\text{root}_u$. The parity of the path length from $\\text{root}_v$ to $\\text{root}_u$ is the XOR sum of the parities of the three segments: path from $v$ to $\\text{root}_v$ ($\\text{parity}_v$), edge $(u,v)$ (parity $1$), and path from $u$ to $\\text{root}_u$ ($\\text{parity}_u$). Thus, we set `parity[root_v] = parity_u \\oplus parity_v \\oplus 1$.\n$3$. **Case B: Same Component ($\\text{root}_u = \\text{root}_v$)**. The edge is being added within an existing component. This will create a cycle. The path between $u$ and $v$ within the DSU tree structure has a length parity of $\\text{parity}_u \\oplus \\text{parity}_v$. Adding the edge $(u,v)$ (length $1$) creates a cycle of length parity $(\\text{parity}_u \\oplus \\text{parity}_v \\oplus 1) \\pmod 2$. The cycle is odd if and only if $\\text{parity}_u \\oplus \\text{parity}_v = 0$, which simplifies to $\\text{parity}_u = \\text{parity}_v$. This condition means that in the existing component's two-coloring, $u$ and $v$ were forced to have the same color. Adding an edge between them creates an unresolvable conflict. The graph is no longer bipartite.\n\nA special case is a self-loop, $(u,u)$, which is a cycle of length $1$. This is an odd cycle, so any graph containing a self-loop is not bipartite.\n\nThe final algorithm proceeds as follows: For each test case with $n$ vertices and a sequence of $m$ edges, we initialize the DSU structure for $n$ vertices. We then iterate through the edges from $t=1$ to $m$. For each edge $(u,v)$ at index $t$:\n- If $u=v$, we have a self-loop. The graph becomes non-bipartite. We report $t$ and terminate for this case.\n- Otherwise, we perform the `union(u, v)` operation. If it returns `False` (indicating a conflict), we report $t$ and terminate.\n- If the loop completes without any conflicts, all graphs $G_1, \\dots, G_m$ are bipartite. We report $0$.", "answer": "```python\nimport numpy as np\n\n# Although numpy is available, it is not used in this solution.\n# The solution uses only standard Python libraries.\n\nclass BipartiteDSU:\n    \"\"\"\n    An augmented Disjoint Set Union (DSU) data structure to track graph\n    bipartiteness. It checks for odd cycles as edges are added.\n    \"\"\"\n    def __init__(self, n):\n        \"\"\"\n        Initializes the DSU for n vertices (labeled 1 to n).\n        \n        Args:\n            n (int): The number of vertices.\n        \"\"\"\n        # Vertices are 1-indexed, so arrays are of size n+1.\n        self.parent = list(range(n + 1))\n        # self.parity[i] stores the parity of path length from node i to its parent.\n        # This is equivalent to color difference: 0 for same color, 1 for different.\n        self.parity = [0] * (n + 1)\n\n    def find(self, i):\n        \"\"\"\n        Finds the root of the set containing i and computes the parity of the\n        path from i to the root. Implements path compression.\n\n        Args:\n            i (int): The vertex to find.\n\n        Returns:\n            tuple[int, int]: A tuple (root, parity) where root is the\n                             representative of the set and parity is the path\n                             parity from i to the root.\n        \"\"\"\n        if self.parent[i] == i:\n            return i, 0\n        \n        # Recurse to find the root and the parity from parent[i] to the root.\n        root, parent_parity = self.find(self.parent[i])\n        \n        # Path Compression: Set the parent of i directly to the root.\n        self.parent[i] = root\n        \n        # Update Parity: The new parity of i is the XOR sum of its old\n        # parity (relative to its old parent) and its old parent's parity\n        # (relative to the root).\n        self.parity[i] ^= parent_parity\n        \n        return self.parent[i], self.parity[i]\n\n    def union(self, u, v):\n        \"\"\"\n        Processes the addition of an edge (u, v) and checks for conflicts\n        with the bipartite property.\n\n        Args:\n            u (int): The first vertex of the edge.\n            v (int): The second vertex of the edge.\n\n        Returns:\n            bool: True if the graph remains bipartite after adding the edge,\n                  False if an odd cycle is created.\n        \"\"\"\n        root_u, parity_u = self.find(u)\n        root_v, parity_v = self.find(v)\n\n        if root_u != root_v:\n            # The vertices are in different components. Merging them will not\n            # create a cycle, so the graph remains bipartite.\n            self.parent[root_v] = root_u\n            \n            # The new parity for root_v is determined by the path from root_v to\n            # root_u, which goes through v and u.\n            # Path: root_v <-- v -- u --> root_u\n            # Parity(root_v -> root_u) = Parity(v->root_v) ^ Parity(u->v) ^ Parity(u->root_u)\n            self.parity[root_v] = parity_u ^ parity_v ^ 1\n            return True\n        else:\n            # The vertices are already in the same component. Adding an edge\n            # will create a cycle. The graph becomes non-bipartite if this\n            # cycle is of odd length. This occurs if u and v have the same\n            # parity relative to their common root.\n            if parity_u == parity_v:\n                return False  # Conflict: odd cycle detected.\n            return True # Consistent edge, no new information.\n\ndef solve():\n    \"\"\"\n    Main function to run the bipartite test on all specified test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (6, [(1,2),(2,3),(3,4),(4,5),(5,6),(6,1),(1,3)]),\n        # Test case 2\n        (5, [(1,2),(2,3),(3,4),(4,5)]),\n        # Test case 3\n        (3, [(1,2),(2,2),(2,3)]),\n        # Test case 4\n        (4, [(1,2),(2,3),(3,1),(4,1)]),\n        # Test case 5\n        (4, [(1,2),(2,3),(1,2),(3,4),(4,1),(2,4)]),\n        # Test case 6\n        (3, []),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        dsu = BipartiteDSU(n)\n        result_t = 0\n        for i, edge in enumerate(edges):\n            t = i + 1\n            u, v = edge\n\n            # A self-loop is an odd cycle of length 1.\n            if u == v:\n                result_t = t\n                break\n\n            if not dsu.union(u, v):\n                # union returns False if a conflict (odd cycle) is found.\n                result_t = t\n                break\n        \n        results.append(result_t)\n\n    # Format the final output string as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216756"}]}