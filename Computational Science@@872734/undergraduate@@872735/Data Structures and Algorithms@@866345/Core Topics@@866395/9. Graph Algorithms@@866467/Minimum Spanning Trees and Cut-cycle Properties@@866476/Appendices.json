{"hands_on_practices": [{"introduction": "Understanding the properties of a Minimum Spanning Tree (MST) goes beyond just finding one. This exercise explores the stability of an MST by asking a critical question: how much can the weight of an existing tree edge increase before it gets forced out? To solve this, you will apply the fundamental **cut property** to identify the \"breaking point\" where the edge is no longer the cheapest option for connecting two parts of the graph [@problem_id:3253184]. This practice reinforces why an MST is \"minimal\" by testing the limits of its constituent edges.", "problem": "Consider a connected, undirected, weighted graph $G=(V,E)$ with vertex set $V=\\{1,2,3,4,5,6\\}$. The edge weights are given by the function $w:E\\to\\mathbb{R}_{\\ge 0}$ on the following edges:\n- $w(\\{1,2\\})=2$, $w(\\{2,3\\})=3$, $w(\\{3,4\\})=4$, $w(\\{4,5\\})=5$, $w(\\{5,6\\})=6$,\n- $w(\\{1,3\\})=7$, $w(\\{2,4\\})=8$, $w(\\{3,5\\})=9$, $w(\\{4,6\\})=10$, $w(\\{1,4\\})=11$, $w(\\{2,5\\})=12$, $w(\\{3,6\\})=13$.\n\nLet $T$ be the Minimum Spanning Tree (MST) comprising the edges $\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\},\\{5,6\\}\\}$. Let $e=\\{3,4\\}\\in T$ be the tree edge with weight $w(e)=4$.\n\nStarting only from the core definitions of spanning trees and the cut-cycle properties of MSTs, determine the largest real number $\\Delta\\ge 0$ such that increasing the weight of $e$ to $w(e)+\\Delta$ leaves $T$ as an MST of $G$. Express your final answer as a single real number. No rounding is required.", "solution": "The solution relies on the **Cut Property** of Minimum Spanning Trees. An MST $T$ remains an MST after increasing the weight of one of its edges, $e$, as long as $e$ continues to be a \"light edge\" for the cut it defines.\n\nRemoving the edge $e=\\{3,4\\}$ from the given MST, $T = \\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\},\\{5,6\\}\\}$, partitions the vertices into two sets, defining a cut $(S_1, S_2)$.\n-   The vertices connected to vertex 3 in $T \\setminus \\{e\\}$ form the set $S_1 = \\{1, 2, 3\\}$.\n-   The vertices connected to vertex 4 in $T \\setminus \\{e\\}$ form the set $S_2 = \\{4, 5, 6\\}$.\n\nWe identify all edges in the original graph $G$ that cross this cut $(S_1, S_2)$ and their weights:\n-   $w(\\{3,4\\})=4$ (the edge $e$)\n-   $w(\\{2,4\\})=8$\n-   $w(\\{3,5\\})=9$\n-   $w(\\{1,4\\})=11$\n-   $w(\\{2,5\\})=12$\n-   $w(\\{3,6\\})=13$\n\nFor $T$ to be an MST, its edge $\\{3,4\\}$ must be a minimum-weight edge crossing this cut. With its original weight of 4, it is.\nNow, let the weight of $e=\\{3,4\\}$ be increased to $w'(e) = 4 + \\Delta$. For $T$ to remain an MST, $w'(e)$ must still be less than or equal to the weight of any *other* edge crossing the cut. The minimum weight among these other crossing edges is:\n$$ \\min \\{8, 9, 11, 12, 13\\} = 8 $$\nThis corresponds to the edge $\\{2,4\\}$.\n\nTherefore, the condition for $T$ to remain an MST is:\n$$ 4 + \\Delta \\le 8 $$\nSolving for $\\Delta$ gives:\n$$ \\Delta \\le 4 $$\nThe largest value for $\\Delta \\ge 0$ is $4$. If $\\Delta > 4$, the edge $\\{2,4\\}$ would be strictly lighter than $\\{3,4\\}$. In that case, one could form a new spanning tree $T' = (T \\setminus \\{\\{3,4\\}\\}) \\cup \\{\\{2,4\\}\\}$ with a total weight strictly less than that of $T$, meaning $T$ would no longer be an MST. If $\\Delta = 4$, the weight of $\\{3,4\\}$ becomes 8, which is still a minimum weight for an edge crossing the cut, so $T$ remains an MST.\n\nThe largest value for $\\Delta$ is $4$.", "answer": "$$\\boxed{4}$$", "id": "3253184"}, {"introduction": "While the previous practice tested an edge *inside* the MST, this problem looks from the outside in. Imagine a potential new connection—a non-tree edge—whose cost is dropping. At what point does it become efficient enough to be included in an optimal network design? This exercise requires you to use the **cycle property** to determine the precise threshold at which this non-tree edge should be swapped in, creating a new MST [@problem_id:3253209]. This simulates a common scenario in network optimization where new, cheaper technology becomes available.", "problem": "Consider a connected, undirected, weighted graph $G = (V, E)$ with $V = \\{1, 2, 3, 4, 5, 6, 7, 8\\}$. The graph $G$ has a specified Minimum Spanning Tree (MST) $T$, where $T$ consists of the following $7$ edges with their weights: $(1,2)$ of weight $1$, $(2,3)$ of weight $3$, $(3,4)$ of weight $2$, $(4,5)$ of weight $6$, $(5,6)$ of weight $4$, $(6,7)$ of weight $5$, and $(7,8)$ of weight $7$. In addition to the edges of $T$, the graph contains non-tree edges $(1,3)$ of weight $8$, $(2,5)$ of weight $9$, $(4,6)$ of weight $10$, $(1,8)$ of weight $11$, and a particular non-tree edge $e = (2,7)$ whose current weight is $w = 9$. Assume all weights are nonnegative, and $T$ is a Minimum Spanning Tree (MST) of $G$.\n\nYou are allowed to continuously decrease only the weight $w$ of the non-tree edge $e = (2,7)$, while keeping all other edge weights fixed. Using only the foundational definitions of a Minimum Spanning Tree (MST), the cut property, and the cycle property for weighted graphs, determine the exact threshold value $w^{\\star}$ such that for any $w$ with $w < w^{\\star}$, the edge $e$ must appear in some MST of $G$ after appropriate replacement of a single tree edge to maintain a spanning tree. In your derivation, identify which specific edge of $T$ is replaced when $w$ decreases below $w^{\\star}$, and justify why this occurs from first principles.\n\nYour final answer should be the single numerical value of $w^{\\star}$. No rounding is required.", "solution": "The solution is based on the **cycle property** of Minimum Spanning Trees (MSTs). This property states that for any cycle in a graph, the strictly heaviest edge in that cycle cannot be part of any MST.\n\nWe are asked to find the threshold weight $w^{\\star}$ for a non-tree edge $e = (2,7)$ below which it will be included in an MST. Adding the edge $e$ to the given MST, $T$, creates a unique cycle. This cycle consists of $e$ and the path in $T$ that connects vertices 2 and 7.\n\nFirst, we identify this path, $P_{2,7}$, in the MST $T$:\n$P_{2,7} = (2-3-4-5-6-7)$.\nThe edges and their weights on this path are:\n- $(2,3)$: weight $3$\n- $(3,4)$: weight $2$\n- $(4,5)$: weight $6$\n- $(5,6)$: weight $4$\n- $(6,7)$: weight $5$\n\nThe cycle created by adding $e=(2,7)$ consists of these five edges plus $e$ itself.\nTo create a new spanning tree with a lower total weight, we can swap $e$ with an edge on the path $P_{2,7}$. To get the greatest possible weight reduction, we should remove the heaviest edge from the path. The weights on the path are $\\{3, 2, 6, 4, 5\\}$. The maximum weight is $6$, which corresponds to the edge $e_{max} = (4,5)$.\n\nIf the weight of our new edge, $w(e)$, is strictly less than the weight of $e_{max}$, i.e., $w(e) < w(e_{max})$, then we can form a new spanning tree $T' = (T \\setminus \\{e_{max}\\}) \\cup \\{e\\}$ with a total weight of $W(T') = W(T) - w(e_{max}) + w(e) < W(T)$. This means the original tree $T$ is no longer an MST. The new edge $e$ will be part of the new MST.\n\nThe threshold value is therefore the weight of the heaviest edge on the cycle path:\n$$ w^{\\star} = w(e_{max}) = w((4,5)) = 6 $$\nIf the weight $w$ of edge $(2,7)$ is decreased to be less than $6$, it becomes strictly lighter than edge $(4,5)$. The cycle property then implies that $(4,5)$ cannot be in the new MST, and an exchange with $(2,7)$ produces a better spanning tree.\n\nTherefore, for any $w < 6$, the edge $e$ will be part of a new MST formed by replacing the edge $(4,5)$. The threshold is $w^{\\star}=6$.", "answer": "$$\\boxed{6}$$", "id": "3253209"}, {"introduction": "Moving from analysis to design, this final practice challenges you to build an algorithm that finds not just the best solution, but also the \"next best\" one. Finding the second-best MST is a classic problem that has applications in providing network redundancy and evaluating the robustness of a solution. You will synthesize the logic from the previous exercises, particularly the cycle property and edge-swapping, to systematically search for the spanning tree with the smallest weight strictly greater than the MST's weight [@problem_id:3253223]. This moves you from reasoning about a single edge to designing a complete optimization algorithm.", "problem": "Given a connected, undirected, weighted graph $G = (V, E)$ with $|V| = n$ vertices labeled from $0$ to $n-1$ and $|E| = m$ edges, design an algorithm to compute the weight of the \"second-best\" Minimum Spanning Tree (MST), defined as the smallest total weight among all spanning trees that is strictly greater than the weight of a minimum spanning tree. If there is no spanning tree whose total weight is strictly greater than the weight of a minimum spanning tree, the algorithm should return $-1$. All edge weights are nonnegative integers. The algorithm must be derived from first principles using fundamental definitions and well-tested facts of graph theory, specifically the cut property and the cycle property for spanning trees.\n\nThe fundamental base you must use includes:\n- The definition of a spanning tree, a cycle, and a cut in a graph.\n- The definition of the Minimum Spanning Tree (MST) as a spanning tree with minimum total edge weight.\n- The cut property: for any cut in the graph, the lightest edge that crosses the cut is always included in some MST.\n- The cycle property: for any cycle in the graph, the heaviest edge on that cycle is excluded from every MST.\n\nYour program must implement an algorithm that:\n- Computes an MST of $G$ (you may assume without proof that algorithms like Kruskal's algorithm produce a valid MST when applied correctly).\n- Determines the weight of the second-best MST by logically reasoning about how replacing edges in an MST using non-tree edges affects total weight, relying on the cut and cycle properties rather than shortcut formulas.\n\nInput is embedded in the program as a test suite of graphs. For each graph, the output must be a single integer: the weight of the second-best MST, or $-1$ if no spanning tree has strictly greater total weight than the MSTs. No physical units or angles are involved.\n\nTest suite:\n- Test case $1$ (general connected graph with a unique MST):\n  - $n = 6$\n  - $E = \\{(0,1,4), (0,2,3), (1,2,1), (1,3,2), (2,3,4), (3,4,2), (4,5,6), (3,5,5), (2,5,7), (0,5,10)\\}$\n- Test case $2$ (graph with multiple MSTs of equal weight, requiring strict increase for the second-best):\n  - $n = 4$\n  - $E = \\{(0,1,1), (1,2,1), (2,3,1), (3,0,1), (0,2,2), (1,3,2)\\}$\n- Test case $3$ (small graph where the second-best MST differs by a single edge substitution):\n  - $n = 3$\n  - $E = \\{(0,1,1), (1,2,1), (0,2,2)\\}$\n- Test case $4$ (graph where all spanning trees have the same total weight, so there is no strictly greater spanning tree):\n  - $n = 3$\n  - $E = \\{(0,1,5), (1,2,5), (0,2,5)\\}$\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, for example, $[a,b,c,d]$, where $a$, $b$, $c$, and $d$ are integers corresponding to the test cases above, in order.\n\nYour implementation must be self-contained and produce deterministic results for the given test suite. The answers for all test cases are integers. No percentages or angle units are required.", "solution": "The problem asks for the weight of the second-best minimum spanning tree of a given connected, undirected, weighted graph $G = (V, E)$. The second-best spanning tree is defined as the spanning tree with the smallest total weight that is strictly greater than the weight of a minimum spanning tree (MST). Let the weight of an MST be denoted by $W_{MST}$. We seek to find $\\min \\{ W(T) \\mid T \\text{ is a spanning tree of } G \\text{ and } W(T) > W_{MST} \\}$. If no such tree exists, the value is $-1$.\n\nThe solution is derived from the fundamental properties of spanning trees and their relationship with cycles and cuts. A key insight is that any spanning tree can be transformed into any other spanning tree through a sequence of single-edge swap operations. A single-edge swap involves adding a non-tree edge and removing a tree edge from the cycle that is formed.\n\nLet $T_{MST}$ be a minimum spanning tree of $G$. Any other spanning tree $T'$ must contain at least one edge not present in $T_{MST}$. Consider a spanning tree $T'$ that differs from $T_{MST}$ by a single edge swap. Such a tree is formed by selecting an edge $e_{in} = (u,v)$ that is not in $T_{MST}$ and adding it to $T_{MST}$. The addition of $e_{in}$ to $T_{MST}$ creates a unique cycle, $C$. This cycle $C$ consists of $e_{in}$ and the unique path $P_{uv}$ between vertices $u$ and $v$ within $T_{MST}$. To restore the tree property (i.e., to have exactly $|V|-1 = n-1$ edges and no cycles), an edge $e_{out}$ must be removed from $C$. Since $e_{in}$ must be in our new tree, $e_{out}$ must be an edge on the path $P_{uv}$. The resulting set of edges, $T' = (T_{MST} \\setminus \\{e_{out}\\}) \\cup \\{e_{in}\\}$, is a new spanning tree.\n\nThe weight of this new spanning tree $T'$ is given by $W(T') = W(T_{MST}) - w(e_{out}) + w(e_{in})$. We are looking for the minimum $W(T')$ such that $W(T') > W(T_{MST})$, which is equivalent to finding the minimum positive weight difference, $\\Delta W = w(e_{in}) - w(e_{out})$.\n\nThe cycle property of MSTs is crucial here. It states that for any cycle in the graph, the edge with the greatest weight cannot be part of any MST. A direct consequence for our construction is that for the cycle $C = P_{uv} \\cup \\{e_{in}\\}$, the weight of the non-MST edge $e_{in}$ must be greater than or equal to the weight of any edge on the path $P_{uv}$. That is, $w(e_{in}) \\ge w(e)$ for all $e \\in P_{uv}$. If there were an edge $e' \\in P_{uv}$ with $w(e') > w(e_{in})$, then we could form a tree $(T_{MST} \\setminus \\{e'\\}) \\cup \\{e_{in}\\}$ with a weight smaller than $W(T_{MST})$, which contradicts the definition of $T_{MST}$ being an MST. Therefore, the weight difference $\\Delta W = w(e_{in}) - w(e_{out})$ is always non-negative.\n\nTo find the second-best MST, we seek to find the smallest possible increase in weight over $W_{MST}$. This suggests that we should consider all possible single-edge swaps that produce a tree with weight strictly greater than $W_{MST}$, and take the minimum among them. For a fixed choice of incoming edge $e_{in}$, the weight increase $w(e_{in}) - w(e_{out})$ is minimized when $w(e_{out})$ is maximized. Thus, for each non-MST edge $e_{in}$, we should choose to remove the heaviest edge, $e_{out}$, from the path $P_{uv}$ in $T_{MST}$. This gives the best possible candidate tree for that particular choice of $e_{in}$.\n\nThis leads to a complete algorithm:\n$1$. Compute an MST of the graph $G$, let it be $T_{MST}$, and its total weight, $W_{MST}$. Kruskal's algorithm is suitable for this. This process naturally partitions the edge set $E$ into MST edges and non-MST edges.\n\n$2$. Initialize a variable for the second-best weight, $W_{2nd}$, to a value representing infinity (e.g., $\\infty$).\n\n$3$. For each edge $e_{in} = (u, v)$ with weight $w_{in}$ that is not in $T_{MST}$:\n    a. Identify the unique path, $P_{uv}$, in $T_{MST}$ connecting vertices $u$ and $v$.\n    b. Find the edge $e_{out}$ on this path $P_{uv}$ that has the maximum weight, $w_{out}$. This can be done using a graph traversal like Breadth-First Search (BFS) or Depth-First Search (DFS) on the tree $T_{MST}$.\n    c. Calculate the weight of the new spanning tree formed by this swap: $W' = W_{MST} - w_{out} + w_{in}$.\n    d. We are only interested in spanning trees with weights strictly greater than $W_{MST}$. Therefore, if $w_{in} > w_{out}$ (which implies $W' > W_{MST}$), then $W'$ is a valid candidate for the second-best MST weight. We update our minimum found so far: $W_{2nd} = \\min(W_{2nd}, W')$. The case $w_{in} = w_{out}$ corresponds to finding another MST of the same weight, which is not what we seek.\n\n$4$. After iterating through all non-MST edges, if $W_{2nd}$ is still $\\infty$, it means no spanning tree with a strictly greater weight could be formed. In this case, the answer is $-1$. Otherwise, the answer is $W_{2nd}$.\n\nThis algorithm is guaranteed to find the second-best MST. While we only consider trees that are a single swap away from one particular MST, it can be shown that the true second-best MST will be found among these candidates. Any spanning tree can be reached from any other via a sequence of swaps. The path of swaps from an MST to the second-best MST must contain a first step that increases the weight, and the minimal such increase across all possible first steps will identify the second-best MST.\n\nFor implementation, Kruskal's algorithm can be implemented using a Disjoint Set Union (DSU) data structure. To find the heaviest edge on the path in the MST for each non-MST edge, a simple traversal (like BFS) from one endpoint to the other, keeping track of parent pointers to reconstruct the path, is sufficient for the given problem constraints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the weight of the second-best MST for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (6, [(0,1,4), (0,2,3), (1,2,1), (1,3,2), (2,3,4), (3,4,2), (4,5,6), (3,5,5), (2,5,7), (0,5,10)]),\n        # Test case 2\n        (4, [(0,1,1), (1,2,1), (2,3,1), (3,0,1), (0,2,2), (1,3,2)]),\n        # Test case 3\n        (3, [(0,1,1), (1,2,1), (0,2,2)]),\n        # Test case 4\n        (3, [(0,1,5), (1,2,5), (0,2,5)]),\n    ]\n\n    results = []\n\n    for n, edges in test_cases:\n        # Step 1: Find an MST using Kruskal's algorithm\n        # A Disjoint Set Union (DSU) data structure for tracking connected components.\n        parent = list(range(n))\n        def find_set(v):\n            if v == parent[v]:\n                return v\n            parent[v] = find_set(parent[v])\n            return parent[v]\n\n        def union_sets(a, b):\n            a = find_set(a)\n            b = find_set(b)\n            if a != b:\n                parent[b] = a\n                return True\n            return False\n\n        # Sort edges by weight\n        edges.sort(key=lambda item: item[2])\n\n        mst_weight = 0\n        mst_edges = []\n        non_mst_edges = []\n\n        for u, v, w in edges:\n            if union_sets(u, v):\n                mst_weight += w\n                mst_edges.append((u, v, w))\n            else:\n                non_mst_edges.append((u, v, w))\n\n        # Check if graph was connected (MST should have n-1 edges)\n        # This is guaranteed by the problem statement, but good practice.\n        if len(mst_edges) != n - 1 and n > 0:\n            # This case corresponds to a disconnected graph.\n            # The problem assumes connected graphs.\n            # Handle as per problem spec for no second-best MST.\n            results.append(-1)\n            continue\n\n        # Step 2: Build adjacency list for the MST for traversal\n        mst_adj = [[] for _ in range(n)]\n        for u, v, w in mst_edges:\n            mst_adj[u].append((v, w))\n            mst_adj[v].append((u, w))\n\n        # Step 3: Iterate through non-MST edges to find the second-best MST weight\n        second_best_weight = float('inf')\n\n        for u_in, v_in, w_in in non_mst_edges:\n            # Find the heaviest edge on the path between u_in and v_in in the MST\n            # We can use BFS to find the path and track max edge weight.\n            # Using parent tracking in BFS is efficient.\n            parent_map = {u_in: (None, 0)} # node -> (parent, weight_to_parent)\n            queue = [u_in]\n            \n            head = 0\n            path_found = False\n            while head  len(queue):\n                curr = queue[head]\n                head += 1\n                if curr == v_in:\n                    path_found = True\n                    break\n                for neighbor, weight in mst_adj[curr]:\n                    if neighbor not in parent_map:\n                        parent_map[neighbor] = (curr, weight)\n                        queue.append(neighbor)\n            \n            if not path_found: continue\n\n            max_weight_on_path = 0\n            curr_node = v_in\n            while curr_node != u_in and curr_node is not None:\n                p_node, p_weight = parent_map[curr_node]\n                if p_weight > max_weight_on_path:\n                    max_weight_on_path = p_weight\n                curr_node = p_node\n            \n            w_out = max_weight_on_path\n            \n            # We must have a strictly greater weight for the new tree\n            if w_in > w_out:\n                candidate_weight = mst_weight - w_out + w_in\n                if candidate_weight  second_best_weight:\n                    second_best_weight = candidate_weight\n\n        if second_best_weight == float('inf'):\n            results.append(-1)\n        else:\n            results.append(int(second_best_weight))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3253223"}]}