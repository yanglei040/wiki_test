{"hands_on_practices": [{"introduction": "Before we begin searching for negative cycles, it's valuable to understand their theoretical limits. This foundational exercise challenges you to think from first principles about the structure of a graph to determine the most negative possible weight a simple cycle can have. Completing this thought experiment [@problem_id:3213912] will build your intuition for the properties of cycles and the scale of values we are dealing with.", "problem": "Consider a directed graph $G=(V,E)$ with $|V|=V$ and integer edge weights. Each edge weight $w(e)$ satisfies the bound $-W \\leq w(e) \\leq W$, where $W$ is a positive integer. A simple cycle is a closed walk that starts and ends at the same vertex and visits each vertex on the cycle exactly once; its length is the number of edges on the cycle and is at least $2$. The weight of a cycle is the sum of the weights of its edges.\n\nUsing only the core definitions of cycle weight and simple cycles, and without relying on any specialized theorems beyond these definitions, determine the smallest (most negative) possible total weight of a simple cycle that can occur in any directed graph on $V$ vertices subject to the above weight bounds. Your answer must be an exact analytic expression in terms of $V$ and $W$.\n\nNo rounding is required. Do not include any units.", "solution": "The problem has been validated and is determined to be a valid, well-posed problem in graph theory.\n\nThe objective is to find the smallest (most negative) possible total weight of a simple cycle in any directed graph $G=(V, E)$ on $|V|=V$ vertices, where edge weights $w(e)$ are integers satisfying $-W \\leq w(e) \\leq W$ for a positive integer $W$.\n\nLet $C$ be an arbitrary simple cycle within such a graph. Let the sequence of vertices in the cycle be $v_1, v_2, \\dots, v_k, v_1$. The length of this cycle, which is the number of its edges, is $k$. The problem statement specifies that a simple cycle has a length of at least $2$, so $k \\ge 2$.\n\nBy the definition of a simple cycle, it visits each vertex on the cycle exactly once, with the exception that it starts and ends at the same vertex. This means that the vertices $v_1, v_2, \\dots, v_k$ must all be distinct. A cycle of length $k$ therefore involves $k$ distinct vertices.\n\nThe total number of vertices in the graph is given as $V$. Since the vertices of a simple cycle must be distinct and are drawn from the set of vertices of the graph, the number of vertices in the cycle, $k$, cannot exceed the total number of vertices available in the graph. Therefore, the length $k$ of any simple cycle is bounded by the total number of vertices $V$:\n$$k \\le V$$\nCombining with the given condition on cycle length, we have $2 \\le k \\le V$. This implies that the problem implicitly assumes $V \\ge 2$, as a simple cycle of length at least $2$ cannot exist in a graph with a single vertex.\n\nThe weight of the cycle $C$, denoted $w(C)$, is the sum of the weights of the edges that form the cycle:\n$$w(C) = \\sum_{e \\in C} w(e)$$\nTo find the smallest possible value of $w(C)$, we must consider the bounds on the individual edge weights $w(e)$. The problem states that for any edge $e$, its weight satisfies $-W \\leq w(e) \\leq W$. The lowest possible value for any single edge weight is therefore $-W$.\n\nTo establish a lower bound for the weight of our cycle $C$ of length $k$, we can replace each edge weight in the sum with this minimum possible value:\n$$w(C) = \\sum_{e \\in C} w(e) \\ge \\sum_{e \\in C} (-W)$$\nSince there are $k$ edges in the cycle $C$, the sum on the right-hand side evaluates to $k \\times (-W)$.\n$$w(C) \\ge -kW$$\nThis inequality shows that the weight of any simple cycle of length $k$ is at least $-kW$. We are interested in the smallest possible weight over all possible simple cycles in all possible graphs. This corresponds to the minimum possible value of the expression $-kW$.\n\nSince $W$ is a positive integer, the expression $-kW$ becomes more negative (i.e., smaller) as $k$ increases. To minimize $-kW$, we must therefore maximize the cycle length $k$. As established earlier, the maximum possible length of a simple cycle in a graph with $V$ vertices is $k=V$.\n\nSubstituting the maximum value of $k$ into our inequality, we find a global lower bound for the weight of any simple cycle in any valid graph:\n$$w(C) \\ge -kW \\ge -VW$$\nThis shows that no simple cycle in any graph satisfying the given conditions can have a weight less than $-VW$.\n\nThe final step is to demonstrate that this lower bound is achievable. To do this, we must construct a specific graph and a simple cycle within it that has a weight of exactly $-VW$.\nConsider a graph with $V$ vertices, which we label $v_1, v_2, \\dots, v_V$.\nWe define a set of $V$ edges to form a Hamiltonian cycle:\n$$E' = \\{ (v_1, v_2), (v_2, v_3), \\dots, (v_{V-1}, v_V), (v_V, v_1) \\}$$\nLet the graph $G$ contain these edges. We assign to each edge $e \\in E'$ the minimum possible weight, $w(e) = -W$. These weights are integers and fall within the required range $[-W, W]$ since $W$ is a positive integer. We can let all other possible edges in the graph have weight $0$, for instance.\n\nThe cycle formed by the edges in $E'$ is a simple cycle of length $V$. It is a closed walk, and all its $V$ vertices are distinct. The total weight of this cycle is the sum of the weights of its $V$ edges:\n$$w(C_{\\text{construct}}) = \\sum_{i=1}^{V} (-W) = V \\times (-W) = -VW$$\nWe have successfully constructed a graph containing a simple cycle with weight $-VW$. Since we previously proved that $-VW$ is a lower bound for the weight of any simple cycle, and we have now shown that this weight is attainable, we conclude that the smallest possible total weight of a simple cycle is $-VW$.", "answer": "$$ \\boxed{-VW} $$", "id": "3213912"}, {"introduction": "General detection of a negative cycle is useful, but sometimes we need to answer a more targeted question: is a specific connection, represented by a designated edge, part of a problematic loop? This practice [@problem_id:3213972] demonstrates a clever problem-solving technique where the search for a specific cycle is transformed into a more familiar shortest path problem, showcasing the versatility of the Bellman–Ford algorithm.", "problem": "You are given a directed, weighted graph specified by a finite vertex set and a finite edge set. Each edge has an integer weight. A cycle is a closed walk that starts and ends at the same vertex. The total weight of a cycle is the sum of the weights of its constituent edges. A cycle is called negative if its total weight is strictly less than $0$. You are also given a designated directed edge $(u,v)$ inside the graph. Your task is to design and implement a program that, using first principles of shortest-path definitions and the Bellman–Ford algorithm, determines whether there exists a negative cycle that passes through the designated edge $(u,v)$. If such a cycle exists, the program must return one explicit instance of it as a list of vertex indices in order, starting at $u$, immediately traversing the designated edge to $v$, and then continuing until returning to $u$. If no such cycle exists, return the empty list for that test case.\n\nFundamental base and definitions to use:\n- A directed weighted graph is a tuple $(V,E,w)$, where $V$ is a finite set of vertices indexed by integers, $E \\subseteq V \\times V$ is the set of directed edges, and $w: E \\to \\mathbb{Z}$ assigns an integer weight to each edge.\n- For a path $P = (x_0, x_1, \\ldots, x_k)$ where $(x_i, x_{i+1}) \\in E$ for all $i \\in \\{0,\\ldots,k-1\\}$, the path weight is $\\sum_{i=0}^{k-1} w(x_i, x_{i+1})$.\n- For an edge $(u,v) \\in E$, and any path $Q$ from $v$ to $u$, the closed walk that traverses $(u,v)$ followed by $Q$ is a cycle. If there are no negative cycles that make shortest-path values ill-defined along the path to $u$, then a negative cycle passing through $(u,v)$ exists if and only if there exists a path $Q$ from $v$ to $u$ whose weight is strictly less than $-w(u,v)$, since the cycle’s total weight is $w(u,v) + \\text{weight}(Q)$.\n\nYour program must:\n- Operate purely at the level of mathematical and algorithmic logic. No physical units are involved.\n- For each test case, determine whether a negative cycle that includes the designated edge $(u,v)$ exists under the graph’s structure. If it exists, return one cycle as a list of integers representing vertex indices in order, starting at $u$, then $v$, and ending at $u$ to close the cycle. If it does not exist, return the empty list.\n- Apply the Bellman–Ford algorithm from $v$ to compute shortest-path estimates to $u$ and use predecessor information to reconstruct a path from $v$ back to $u$ when applicable. Combine this path with the designated edge $(u,v)$ to produce the cycle and verify its negativity by the fundamental definition. Avoid relying on any shortcut formulas beyond the fundamental definitions and widely accepted algorithmic facts.\n\nTest suite:\nFor each test case below, vertices are indexed by nonnegative integers, edges are given as triples $(a,b,w)$ with $a,b \\in V$ and weight $w \\in \\mathbb{Z}$, and the designated edge is $(u,v)$. The graphs are small and chosen to cover different facets: a clear negative cycle through the designated edge, absence of such a cycle, zero-weight cycle boundary, edge not present, multi-component graphs with unrelated negative cycles, and missing return path.\n\n- Test case $1$ (happy path, negative cycle exists through the designated edge):\n  - Number of vertices: $4$.\n  - Edges: $(1,2,-1)$, $(2,3,1)$, $(3,1,-1)$, $(0,1,4)$, $(0,2,2)$.\n  - Designated edge: $(1,2)$.\n  - There is a cycle $1 \\to 2 \\to 3 \\to 1$ with total weight $-1 + 1 + (-1) = -1$.\n\n- Test case $2$ (path exists but the resulting cycle is not negative):\n  - Number of vertices: $3$.\n  - Edges: $(0,1,2)$, $(1,2,1)$, $(2,0,0)$.\n  - Designated edge: $(0,1)$.\n  - The path from $1$ to $0$ has weight $1 + 0 = 1$, so the cycle weight is $2 + 1 = 3$, which is not negative.\n\n- Test case $3$ (designated edge not present):\n  - Number of vertices: $4$.\n  - Edges: $(0,1,1)$, $(1,2,1)$, $(2,0,1)$.\n  - Designated edge: $(3,2)$.\n  - Since $(3,2)$ is not in $E$, no cycle can pass through it.\n\n- Test case $4$ (zero-weight cycle boundary case):\n  - Number of vertices: $6$.\n  - Edges: $(4,5,-2)$, $(5,4,2)$, $(0,1,3)$, $(1,2,3)$, $(2,3,3)$, $(3,0,-1)$.\n  - Designated edge: $(4,5)$.\n  - The cycle $4 \\to 5 \\to 4$ has total weight $-2 + 2 = 0$, which is not negative.\n\n- Test case $5$ (negative cycle exists elsewhere but not through the designated edge):\n  - Number of vertices: $6$.\n  - Edges: $(0,3,0)$, $(3,4,1)$, $(4,0,0)$, $(1,2,-3)$, $(2,1,-3)$.\n  - Designated edge: $(0,3)$.\n  - There is a negative cycle between $1$ and $2$, but it is in a different component and does not imply a negative cycle through $(0,3)$.\n\n- Test case $6$ (designated edge present but no return path to close a cycle):\n  - Number of vertices: $2$.\n  - Edges: $(0,1,-1)$.\n  - Designated edge: $(0,1)$.\n  - There is no path from $1$ back to $0$, so no cycle exists.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is either the empty list (written as $[]$) or a list of integers denoting the vertex sequence of one found negative cycle that passes through $(u,v)$. There must be no spaces in the printed output. For example, the format must look like $[[1,2,3,1],[],\\ldots]$ with commas separating test case results and no spaces anywhere in the string.", "solution": "The problem requires us to determine if a directed, weighted graph $(V,E,w)$ contains a negative-weight cycle that passes through a designated edge $(u,v) \\in E$. If such a cycle exists, we must provide one instance of it.\n\nThe fundamental principle for identifying such a cycle is rooted in the definition of cycle weight. A cycle passing through the edge $(u,v)$ is formed by the traversal of $(u,v)$ followed by a path $P$ from vertex $v$ back to vertex $u$. The total weight of this cycle, $W_{cycle}$, is the sum of the weight of the edge $(u,v)$, denoted $w(u,v)$, and the weight of the path $P$, denoted $W(P_{v \\to u})$.\n$$W_{cycle} = w(u,v) + W(P_{v \\to u})$$\nThe cycle is negative if and only if its total weight is strictly less than zero.\n$$w(u,v) + W(P_{v \\to u})  0$$\nThis inequality can be rearranged to provide a condition on the path weight:\n$$W(P_{v \\to u})  -w(u,v)$$\nTo determine if such a path exists, we must find the path from $v$ to $u$ with the minimum possible weight. This is, by definition, the shortest path from $v$ to $u$. Let the weight of this shortest path be $\\delta(v,u)$. If $\\delta(v,u)  -w(u,v)$, then a negative cycle through $(u,v)$ is guaranteed to exist, formed by the edge $(u,v)$ and this shortest path. If even the shortest path does not satisfy this condition, no other path will, and thus no such negative cycle exists.\n\nThe problem statement includes a critical specification: \"if there are no negative cycles that make shortest-path values ill-defined along the path to $u$\". This implies that we can assume the shortest path weight $\\delta(v,u)$ is a finite value, rather than $-\\infty$, which would be the case if a negative-weight cycle were part of the shortest path from $v$ to $u$. This simplification allows for a direct application of a standard shortest-path algorithm.\n\nThe Bellman–Ford algorithm is the appropriate tool for this task, as it correctly computes single-source shortest paths in graphs that may contain negative-weight edges. We will execute the Bellman–Ford algorithm with vertex $v$ as the source to find the shortest path to all other vertices, including $u$.\n\nThe algorithmic procedure is as follows:\n\n1.  **Initial Validation**: First, we verify that the designated edge $(u,v)$ exists in the graph's edge set $E$. If it does not, no cycle can pass through it, and the process terminates for that test case. Let its weight be $w_{uv}$.\n\n2.  **Bellman–Ford Execution**: We initialize a distance array, $d$, of size $|V|$, with $d[v] = 0$ and $d[i] = \\infty$ for all other vertices $i \\in V$. A predecessor array, $p$, is also initialized to track the path. The core of the Bellman–Ford algorithm consists of relaxing every edge in the graph. This relaxation step is repeated $|V|-1$ times. For each edge $(x,y)$ with weight $w_{xy}$, the relaxation operation is: if $d[x] + w_{xy}  d[y]$, update $d[y]$ to $d[x] + w_{xy}$ and set $p[y] = x$. After $|V|-1$ iterations, $d[u]$ will hold the weight of the shortest path from $v$ to $u$, $\\delta(v,u)$, given the problem's simplifying assumption.\n\n3.  **Path and Cycle Existence Check**:\n    - If, after the algorithm completes, $d[u]$ remains $\\infty$, it signifies that there is no path from $v$ to $u$. Consequently, no cycle can be formed, and we conclude no such negative cycle exists.\n    - If a path exists (i.e., $d[u]$ is finite), we check the negativity condition: $d[u] + w_{uv}  0$. If this condition is not met, the cycle formed by the shortest path is not negative, and no other path from $v$ to $u$ can form a lighter cycle.\n\n4.  **Cycle Reconstruction**: If the negativity condition $d[u] + w_{uv}  0$ is satisfied, a negative cycle has been found. We must reconstruct its vertex sequence. This is done by backtracking from $u$ using the predecessor array $p$. We start with a list containing $u$, and iteratively prepend its predecessor $p[u]$, then $p[p[u]]$, and so on, until we reach $v$. This process yields the vertex list for the shortest path from $v$ to $u$, let's call it `path_v_to_u`. The final output is the ordered list of vertices forming the cycle, which starts at $u$, traverses the edge to $v$, and then follows the reconstructed path back to $u$. This corresponds to concatenating a list containing just $u$ with `path_v_to_u`, i.e., `[u] + path_v_to_u`. For a path $v \\to x_1 \\to \\dots \\to u$, the reconstructed path list is $[v, x_1, \\dots, u]$, and the final cycle list is $[u, v, x_1, \\dots, u]$.\n\nThis systematic approach, founded on the first principles of shortest paths and implemented with the Bellman–Ford algorithm, correctly solves the problem as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_negative_cycle_through_edge(num_vertices, edges, u, v):\n    \"\"\"\n    Determines if a negative cycle exists through a designated edge (u, v)\n    using the Bellman-Ford algorithm.\n\n    Args:\n        num_vertices (int): The number of vertices in the graph.\n        edges (list of tuples): The list of edges, each as (source, dest, weight).\n        u (int): The starting vertex of the designated edge.\n        v (int): The ending vertex of the designated edge.\n\n    Returns:\n        list: A list of vertex indices representing the negative cycle, starting and\n              ending at u. Returns an empty list if no such cycle exists.\n    \"\"\"\n    w_uv = None\n    edge_map = {(src, dst): weight for src, dst, weight in edges}\n    \n    if (u, v) not in edge_map:\n        return []\n    w_uv = edge_map[(u, v)]\n\n    # Step 2: Bellman-Ford from source v\n    dist = [np.inf] * num_vertices\n    pred = [None] * num_vertices\n    dist[v] = 0\n\n    for _ in range(num_vertices - 1):\n        for x, y, weight in edges:\n            if dist[x] != np.inf and dist[x] + weight  dist[y]:\n                dist[y] = dist[x] + weight\n                pred[y] = x\n\n    # Step 3: Path and Cycle Existence Check\n    if dist[u] == np.inf:\n        return []\n\n    if dist[u] + w_uv >= 0:\n        return []\n\n    # Step 4: Cycle Reconstruction\n    path_vu = []\n    curr = u\n    while True:\n        path_vu.insert(0, curr)\n        if curr == v:\n            break\n        curr = pred[curr]\n        # This safeguard is for unexpected graph structures, though not expected\n        # in this problem's context. If pred[curr] is None before reaching v,\n        # it means there's no path, which contradicts dist[u] being finite.\n        if curr is None and path_vu[0] != v:\n            return [] # Should not happen under normal BF operation\n\n    # The problem asks for the cycle starting at u, traversing (u,v), and returning to u.\n    # The sequence is u, followed by the path from v to u.\n    # Our reconstructed `path_vu` is the sequence of vertices from v to u.\n    # For example, for a path v -> x -> u, path_vu is [v, x, u].\n    # Cycle sequence u -> v -> x -> u is represented as [u, v, x, u].\n    # This is [u] + path_vu.\n    cycle = [u] + path_vu\n    \n    return cycle\n    \ndef solve():\n    \"\"\"\n    Defines the test cases from the problem statement and runs the solver.\n    \"\"\"\n    test_cases = [\n        {\n            \"num_vertices\": 4,\n            \"edges\": [(1, 2, -1), (2, 3, 1), (3, 1, -1), (0, 1, 4), (0, 2, 2)],\n            \"u\": 1, \"v\": 2,\n        },\n        {\n            \"num_vertices\": 3,\n            \"edges\": [(0, 1, 2), (1, 2, 1), (2, 0, 0)],\n            \"u\": 0, \"v\": 1,\n        },\n        {\n            \"num_vertices\": 4,\n            \"edges\": [(0, 1, 1), (1, 2, 1), (2, 0, 1)],\n            \"u\": 3, \"v\": 2,\n        },\n        {\n            \"num_vertices\": 6,\n            \"edges\": [(4, 5, -2), (5, 4, 2), (0, 1, 3), (1, 2, 3), (2, 3, 3), (3, 0, -1)],\n            \"u\": 4, \"v\": 5,\n        },\n        {\n            \"num_vertices\": 6,\n            \"edges\": [(0, 3, 0), (3, 4, 1), (4, 0, 0), (1, 2, -3), (2, 1, -3)],\n            \"u\": 0, \"v\": 3,\n        },\n        {\n            \"num_vertices\": 2,\n            \"edges\": [(0, 1, -1)],\n            \"u\": 0, \"v\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_negative_cycle_through_edge(\n            case[\"num_vertices\"], case[\"edges\"], case[\"u\"], case[\"v\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    result_strs = []\n    for r in results:\n        if r:\n            result_strs.append(f\"[{','.join(map(str, r))}]\")\n        else:\n            result_strs.append(\"[]\")\n    \n    print(f\"[{','.join(result_strs)}]\")\n\nsolve()\n```", "id": "3213972"}, {"introduction": "This practice addresses the most critical and general challenge when dealing with negative weights: the presence of a negative cycle reachable from the source can make the notion of a shortest path meaningless. You will implement a robust algorithm [@problem_id:3214050] that not only detects such cycles but also quarantines their influence. This ensures that you can confidently find a well-defined shortest path to a target, provided it remains \"safe\" from the cycle's effects.", "problem": "You are given a finite directed weighted graph $G=(V,E)$ with real-valued edge weights $w:E\\to\\mathbb{R}$. A path from a source vertex $s\\in V$ to a target vertex $t\\in V$ is a sequence of vertices $\\left[v_0,v_1,\\dots,v_k\\right]$ with $v_0=s$, $v_k=t$, and $\\left(v_i,v_{i+1}\\right)\\in E$ for all $i\\in\\{0,1,\\dots,k-1\\}$. The weight of a path is the sum of its edge weights, that is, $\\sum_{i=0}^{k-1} w\\!\\left(v_i,v_{i+1}\\right)$. A cycle is a path with $v_0=v_k$ and $k\\geq 1$. A negative cycle is a cycle whose total weight is strictly less than $0$. In the Single Source Shortest Path (SSSP) problem, the goal is to find a path from $s$ to $t$ with minimum total weight among all $s$ to $t$ paths.\n\nYour task is to write a complete program that, for each provided test case, computes a shortest path from $s$ to $t$ that is guaranteed not to be part of any negative cycle, even if such cycles exist elsewhere in the graph. The program must implement logic that ensures the returned path uses only vertices that are not affected by any negative cycle reachable from $s$. If the target vertex $t$ is unreachable from $s$, or $t$ is reachable from any vertex that lies on or is reachable from a negative cycle that is itself reachable from $s$, then there is no well-defined finite shortest path, and you must return an empty list.\n\nFundamental base and definitions you must adhere to:\n- The directed weighted graph $G=(V,E)$ has vertex set $V$ and edge set $E\\subseteq V\\times V$, with each edge $\\left(u,v\\right)\\in E$ assigned a weight $w\\!\\left(u,v\\right)\\in\\mathbb{R}$.\n- The weight of any path $\\left[v_0,\\dots,v_k\\right]$ is $\\sum_{i=0}^{k-1} w\\!\\left(v_i,v_{i+1}\\right)$.\n- A negative cycle is any cycle $\\left[v_0,\\dots,v_k\\right]$ with $v_0=v_k$ and $\\sum_{i=0}^{k-1} w\\!\\left(v_i,v_{i+1}\\right)0$.\n- It is a well-tested fact that if there is a negative cycle reachable from $s$ that can reach $t$, then no finite minimum exists for the $s$ to $t$ path weight; moreover, after performing $|V|-1$ rounds of relaxation in the Bellman–Ford algorithm, the presence of any edge $\\left(u,v\\right)\\in E$ for which the distance estimate $d[u]+w\\!\\left(u,v\\right)$ is still less than $d[v]$ implies the existence of a negative cycle reachable from $s$, and any vertex reachable from such a witness of further relaxation is affected by that negative cycle.\n\nOutput requirements:\n- For each test case, return the path as a list of integers denoting the vertex sequence from $s$ to $t$. If no well-defined finite shortest path exists (either because $t$ is unreachable from $s$ or because $t$ is affected by a negative cycle reachable from $s$), return an empty list $\\left[\\right]$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$), where each $\\text{result}_i$ is itself a list (e.g., $\\left[0,1,2\\right]$) or an empty list $\\left[\\right]$.\n\nTest suite:\nUse exactly the following test cases, each specified by a tuple $\\left(n,E,s,t\\right)$ where $n=|V|$ is the number of vertices labeled as integers $\\{0,1,\\dots,n-1\\}$, $E$ is a list of directed edges with weights given as triples $\\left(u,v,w\\right)$, and $s,t$ are the source and target vertices.\n\n- Test case $1$ (happy path with an unreachable negative cycle elsewhere):\n  - $n=5$\n  - $E=\\left[\\left(0,1,3\\right),\\left(1,2,-2\\right),\\left(0,2,5\\right),\\left(3,4,-1\\right),\\left(4,3,-1\\right)\\right]$\n  - $s=0$\n  - $t=2$\n  - Expected behavior: The negative cycle on vertices $\\left\\{3,4\\right\\}$ is unreachable from $s$, so the shortest path is well-defined.\n\n- Test case $2$ (negative cycle reachable from $s$ that can reach $t$):\n  - $n=4$\n  - $E=\\left[\\left(0,1,1\\right),\\left(1,2,1\\right),\\left(2,1,-3\\right),\\left(2,3,2\\right)\\right]$\n  - $s=0$\n  - $t=3$\n  - Expected behavior: There exists a negative cycle reachable from $s$ that can reach $t$, so no finite shortest path exists; return $\\left[\\right]$.\n\n- Test case $3$ (negative cycle reachable from $s$ but cannot reach $t$, with an unaffected path to $t$):\n  - $n=6$\n  - $E=\\left[\\left(0,1,2\\right),\\left(1,2,2\\right),\\left(2,1,-5\\right),\\left(0,3,1\\right),\\left(3,4,1\\right),\\left(4,5,1\\right)\\right]$\n  - $s=0$\n  - $t=5$\n  - Expected behavior: The negative cycle on vertices $\\left\\{1,2\\right\\}$ is reachable from $s$ but cannot reach $t$, so the shortest path to $t$ is well-defined and must avoid affected vertices.\n\n- Test case $4$ (target unreachable):\n  - $n=3$\n  - $E=\\left[\\left(0,1,1\\right)\\right]$\n  - $s=0$\n  - $t=2$\n  - Expected behavior: Vertex $t$ is unreachable from $s$; return $\\left[\\right]$.\n\n- Test case $5$ (boundary case $s=t$ with no negative influence on $s$):\n  - $n=3$\n  - $E=\\left[\\left(0,2,4\\right)\\right]$\n  - $s=1$\n  - $t=1$\n  - Expected behavior: The shortest path from $s$ to itself is the trivial path $\\left[1\\right]$ since $s$ is not affected by any negative cycle.\n\nYour program must use these test cases and output one line containing the list of results in the exact format described above.", "solution": "The given problem asks for the computation of a shortest path from a source vertex $s$ to a target vertex $t$ in a directed, weighted graph $G=(V,E)$ where edge weights can be negative. The crucial constraint is that the path must be well-defined, meaning it must not be possible to decrease its weight indefinitely by traversing a negative cycle. Specifically, if the target $t$ is unreachable, or if its shortest path is influenced by a negative cycle reachable from $s$, no such path exists.\n\nThe presence of negative edge weights suggests the use of the Bellman–Ford algorithm, which is designed for the Single-Source Shortest Path (SSSP) problem in such graphs. The standard Bellman–Ford algorithm can also detect if there is a negative cycle reachable from the source $s$. Our task requires an extension of this capability to identify all vertices whose shortest path calculations are \"corrupted\" by such cycles and to ensure our path to $t$ avoids them.\n\nThe core principle of the Bellman–Ford algorithm is iterative relaxation. It initializes the distance to the source $d[s]$ as $0$ and all other distances $d[v]$ to infinity. It then repeatedly relaxes all edges in the graph. For an edge $(u,v)$ with weight $w(u,v)$, relaxation is the process of checking if the path to $v$ can be shortened by going through $u$, i.e., if $d[u] + w(u,v)  d[v]$. If so, $d[v]$ is updated to $d[u] + w(u,v)$, and the predecessor of $v$ on this path, $p[v]$, is set to $u$.\n\nIn a graph with $|V|$ vertices, any simple path (a path without repeated vertices) can have at most $|V|-1$ edges. The Bellman–Ford algorithm guarantees that after $|V|-1$ iterations of relaxing all edges, the calculated distances $d[v]$ are the shortest path weights from $s$ to all other vertices $v$, provided there are no negative cycles reachable from $s$.\n\nThe problem hinges on correctly handling negative cycles. A key property of the Bellman–Ford algorithm, as stated in the problem description, is that if after $|V|-1$ iterations, a further relaxation is possible for any edge $(u,v)$, it signals the existence of a negative-weight cycle reachable from $s$. Any vertex $v$ whose distance estimate $d[v]$ is lowered during a conceptual $|V|$-th iteration is on a path from $s$ that contains a negative cycle. The shortest path to such a vertex is undefined (it can be made arbitrarily small by repeatedly traversing the cycle).\n\nFurthermore, any vertex reachable from a vertex affected by a negative cycle is also considered affected, as paths to it could be routed through the corrupted vertex, making their shortest path weights also undefined.\n\nThis leads to the following comprehensive algorithm:\n\n1.  **Initialization**: For a graph with $n=|V|$ vertices, create a distance array $d$ of size $n$ and initialize $d[s] = 0$ and $d[v] = \\infty$ for all $v \\neq s$. Create a predecessor array $p$ of size $n$, initialized to a sentinel value (e.g., $-1$) indicating no predecessor.\n\n2.  **Bellman–Ford Relaxations**: Perform $n-1$ iterations. In each iteration, loop through every edge $(u,v) \\in E$ with weight $w(u,v)$ and perform the relaxation step: if $d[u] \\neq \\infty$ and $d[u] + w(u,v)  d[v]$, update $d[v] = d[u] + w(u,v)$ and $p[v] = u$.\n\n3.  **Identification of Affected Vertices**:\n    a.  Identify vertices directly affected by negative cycles. We can do this by performing one more round of relaxation checks (the $n$-th round). Create a queue, `affected_queue`, and for each edge $(u,v) \\in E$, if $d[u] + w(u,v)  d[v]$, it means $v$ is on a path from $s$ that involves a negative cycle. Add $v$ to `affected_queue`. To avoid duplicates and for efficient lookup, a set `all_affected` is also populated with these initial vertices.\n    b.  Propagate the \"affected\" status. Any vertex reachable from an affected vertex is also affected. Perform a graph traversal (e.g., Breadth-First Search or Depth-First Search) starting from all vertices in `affected_queue`. For this, an adjacency list representation of the graph is useful. During the traversal, add all newly discovered reachable vertices to the `all_affected` set.\n\n4.  **Path Determination and Reconstruction**:\n    a.  First, check if the target vertex $t$ is reachable at all. If $d[t] = \\infty$ after the Bellman–Ford phase, no path exists from $s$ to $t$. The result is an empty list.\n    b.  Next, check if $t$ is affected by a negative cycle. If $t$ is in the `all_affected` set, no well-defined finite shortest path exists. The result is an empty list.\n    c.  If $t$ is reachable and not affected, a valid shortest path exists. This path can be reconstructed by starting from $t$ and iteratively moving to its predecessor using the array $p$ until $s$ is reached. The sequence of vertices visited, when reversed, gives the shortest path from $s$ to $t$. If $s=t$, the path is simply $[s]$.\n\nThis algorithm correctly finds a safe shortest path by first running the Bellman–Ford algorithm to compute path weights and predecessors, then systematically identifying and quarantining all vertices whose shortest path distances are compromised by negative cycles, and finally checking the target vertex against these conditions before reconstructing the path.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the provided test cases for the secure shortest path problem.\n    \"\"\"\n    test_cases = [\n        # Test case 1: Happy path with an unreachable negative cycle\n        {\n            \"n\": 5,\n            \"E\": [(0, 1, 3), (1, 2, -2), (0, 2, 5), (3, 4, -1), (4, 3, -1)],\n            \"s\": 0,\n            \"t\": 2,\n        },\n        # Test case 2: Negative cycle reachable from s that can reach t\n        {\n            \"n\": 4,\n            \"E\": [(0, 1, 1), (1, 2, 1), (2, 1, -3), (2, 3, 2)],\n            \"s\": 0,\n            \"t\": 3,\n        },\n        # Test case 3: Negative cycle reachable from s but cannot reach t\n        {\n            \"n\": 6,\n            \"E\": [(0, 1, 2), (1, 2, 2), (2, 1, -5), (0, 3, 1), (3, 4, 1), (4, 5, 1)],\n            \"s\": 0,\n            \"t\": 5,\n        },\n        # Test case 4: Target unreachable\n        {\n            \"n\": 3,\n            \"E\": [(0, 1, 1)],\n            \"s\": 0,\n            \"t\": 2,\n        },\n        # Test case 5: Boundary case s=t\n        {\n            \"n\": 3,\n            \"E\": [(0, 2, 4)],\n            \"s\": 1,\n            \"t\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_shortest_safe_path(case[\"n\"], case[\"E\"], case[\"s\"], case[\"t\"])\n        results.append(result)\n\n    # Format the final output string to be space-free as per the implicit format.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f'[{\",\".join(formatted_results)}]')\n\n\ndef find_shortest_safe_path(n, E, s, t):\n    \"\"\"\n    Finds a shortest path from s to t that is not affected by any negative cycle.\n\n    Args:\n        n (int): The number of vertices, labeled 0 to n-1.\n        E (list): A list of edges, where each edge is a tuple (u, v, w).\n        s (int): The source vertex.\n        t (int): The target vertex.\n\n    Returns:\n        list: A list of integers representing the path from s to t, or an empty list\n              if no such path exists.\n    \"\"\"\n    # Step 1: Initialization\n    distances = np.full(n, np.inf)\n    predecessors = np.full(n, -1, dtype=int)\n    distances[s] = 0\n\n    # Step 2: Bellman-Ford relaxations for n-1 iterations\n    for _ in range(n - 1):\n        for u, v, w in E:\n            if distances[u] != np.inf and distances[u] + w  distances[v]:\n                distances[v] = distances[u] + w\n                predecessors[v] = u\n\n    # Step 3: Identification of affected vertices\n    # a. Identify vertices directly updated in the n-th relaxation round\n    initially_affected = set()\n    for u, v, w in E:\n        if distances[u] != np.inf and distances[u] + w  distances[v]:\n            initially_affected.add(v)\n\n    # b. Propagate the \"affected\" status via BFS\n    if not initially_affected:\n        all_affected = set()\n    else:\n        # Build adjacency list for traversal\n        adj = [[] for _ in range(n)]\n        for u, v, _ in E:\n            adj[u].append(v)\n            \n        all_affected = set(initially_affected)\n        queue = list(initially_affected)\n        \n        while queue:\n            curr = queue.pop(0)\n            for neighbor in adj[curr]:\n                if neighbor not in all_affected:\n                    all_affected.add(neighbor)\n                    queue.append(neighbor)\n\n    # Step 4: Path Determination and Reconstruction\n    # Case a: Target is unreachable\n    if distances[t] == np.inf:\n        return []\n\n    # Case b: Target is affected by a negative cycle\n    if t in all_affected:\n        return []\n\n    # Case c: A valid, safe shortest path exists\n    path = []\n    curr = t\n    while curr != -1:\n        path.append(curr)\n        if curr == s:\n            break\n        curr = predecessors[curr]\n    \n    path.reverse()\n    \n    if path and path[0] == s:\n        return path\n    else:\n        # This case should not be reached if distances[t] is finite\n        # and predecessors are correctly maintained, but serves as a safeguard.\n        return []\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3214050"}]}