{"hands_on_practices": [{"introduction": "Understanding the connectivity of a graph is fundamental, but real-world networks are often dynamic. This practice challenges you to analyze a graph's resilience by computing the number of connected components after certain vertices are removed [@problem_id:3223832]. By working with the induced subgraph $G[V \\setminus S]$, you will master the application of graph traversal algorithms to scenarios modeling network failures or targeted removals.", "problem": "Consider an undirected simple graph $G = (V, E)$, where $V = \\{0, 1, \\dots, n-1\\}$ and $E \\subseteq \\{\\{u, v\\} \\mid u \\in V, v \\in V, u \\neq v\\}$. For a subset of vertices $S \\subseteq V$, define the induced subgraph $G[V \\setminus S]$ to have vertex set $V \\setminus S$ and edge set $\\{\\{u, v\\} \\in E \\mid u \\notin S, v \\notin S\\}$. Two vertices $u, v \\in V \\setminus S$ are said to be connected in $G[V \\setminus S]$ if there exists a path (a sequence of vertices with successive pairs adjacent) entirely within $V \\setminus S$ that starts at $u$ and ends at $v$. A connected component of $G[V \\setminus S]$ is a maximal subset $C \\subseteq V \\setminus S$ such that every pair of vertices in $C$ is connected in $G[V \\setminus S]$. A single isolated vertex (with no incident edges in $G[V \\setminus S]$) counts as a connected component.\n\nStarting only from these definitions, write a program that, for each specified test case below, computes the number of connected components in the induced subgraph after removing the given set $S$.\n\nThe graph is always finite, undirected, and simple (no self-loops or parallel edges). Vertices are labeled by integers from $0$ to $n-1$. Edges are given as unordered pairs $(u, v)$ with $u \\neq v$.\n\nTest suite (each case is given by the tuple $(n, E, S)$):\n- Case $1$: $n = 9$, $E = \\{(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (5, 6), (6, 4), (7, 8)\\}$, $S = \\{2, 5\\}$.\n- Case $2$: $n = 5$, $E = \\{(0, 1), (1, 2)\\}$, $S = \\varnothing$.\n- Case $3$: $n = 4$, $E = \\{(0, 1), (2, 3)\\}$, $S = \\{0, 1, 2, 3\\}$.\n- Case $4$: $n = 6$, $E = \\varnothing$, $S = \\{1, 3\\}$.\n- Case $5$: $n = 7$, $E = \\{(0, 1), (1, 2), (2, 3), (3, 0), (3, 4), (4, 5)\\}$, $S = \\{1\\}$.\n- Case $6$: $n = 7$, $E = \\{(0, 1), (0, 2), (0, 3), (3, 4), (3, 5), (5, 6)\\}$, $S = \\{0, 3\\}$.\n\nYour program should produce a single line of output containing the results for the six cases as a comma-separated list enclosed in square brackets (for example, $[r_1, r_2, \\dots, r_6]$), where each $r_i$ is the integer number of connected components for case $i$ in the order listed above.", "solution": "The problem requires us to determine the number of connected components in an induced subgraph $G[V \\setminus S]$ for several given graphs $G=(V, E)$ and vertex subsets $S$.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Graph Type: Undirected, simple graph $G = (V, E)$.\n- Vertex Set: $V = \\{0, 1, \\dots, n-1\\}$.\n- Edge Set: $E \\subseteq \\{\\{u, v\\} \\mid u \\in V, v \\in V, u \\neq v\\}$.\n- Removed Vertices: A subset $S \\subseteq V$.\n- Induced Subgraph: $G[V \\setminus S]$ has vertex set $V' = V \\setminus S$ and edge set $E' = \\{\\{u, v\\} \\in E \\mid u \\notin S, v \\notin S\\}$.\n- Connectivity: Two vertices $u, v \\in V'$ are connected in $G[V \\setminus S]$ if a path exists between them using only vertices in $V'$ and edges in $E'$.\n- Connected Component: A maximal subset of vertices in $V'$ that are mutually connected. An isolated vertex in $G[V \\setminus S]$ constitutes a component of size $1$.\n- Objective: Compute the number of connected components in $G[V \\setminus S]$ for each of the six provided test cases.\n- Test Cases:\n    1. $n=9$, $E = \\{(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (5, 6), (6, 4), (7, 8)\\}$, $S = \\{2, 5\\}$.\n    2. $n=5$, $E = \\{(0, 1), (1, 2)\\}$, $S = \\varnothing$.\n    3. $n=4$, $E = \\{(0, 1), (2, 3)\\}$, $S = \\{0, 1, 2, 3\\}$.\n    4. $n=6$, $E = \\varnothing$, $S = \\{1, 3\\}$.\n    5. $n=7$, $E = \\{(0, 1), (1, 2), (2, 3), (3, 0), (3, 4), (4, 5)\\}$, $S = \\{1\\}$.\n    6. $n=7$, $E = \\{(0, 1), (0, 2), (0, 3), (3, 4), (3, 5), (5, 6)\\}$, $S = \\{0, 3\\}$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded in the well-defined mathematical field of graph theory. The definitions of an undirected graph, induced subgraph, and connected components are standard and unambiguous. All necessary data ($n$, $E$, $S$) for each case are provided, making the problem self-contained and complete. The problem is well-posed, as for any finite graph, the number of connected components is a unique, determinable integer. The problem statement is objective and free of any factual errors, logical contradictions, or ill-posed structures.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. A solution will be developed.\n\n### Principle-Based Solution\n\nThe fundamental principle for counting connected components in a graph is to systematically explore its vertices. Each time a traversal must be initiated from a previously unvisited vertex, a new connected component has been discovered. A graph traversal algorithm, such as Depth-First Search (DFS) or Breadth-First Search (BFS), can be employed for this purpose.\n\nLet the induced subgraph be denoted by $G' = G[V \\setminus S]$, with vertex set $V' = V \\setminus S$ and edge set $E' = \\{\\{u, v\\} \\in E \\mid u, v \\in V'\\}$. The algorithm proceeds as follows:\n\n1.  **Construct the Induced Subgraph $G'$**:\n    First, we must explicitly represent the graph on which we will operate. The set of vertices $V'$ is obtained by taking the set difference $V \\setminus S = \\{v \\in V \\mid v \\notin S\\}$. The edge set $E'$ is constructed by filtering the original edge set $E$, retaining only those edges whose endpoints are both in $V'$. An adjacency list is an efficient data structure for this representation, where each vertex $v \\in V'$ is mapped to a list of its adjacent vertices in $G'$.\n\n2.  **Initialize State**:\n    We require a counter for the number of components, let's call it $c_{count}$, initialized to $0$. We also need a mechanism to track visited vertices to ensure each vertex is processed only once. A set data structure, let's call it $V_{visited}$, is suitable for this, initialized to be empty.\n\n3.  **Iterate and Traverse**:\n    The core of the algorithm is a loop over all vertices in the induced subgraph's vertex set, $V'$. For each vertex $v \\in V'$:\n    - If $v$ has already been visited (i.e., $v \\in V_{visited}$), we do nothing and proceed to the next vertex.\n    - If $v$ has not been visited (i.e., $v \\notin V_{visited}$), it signifies the discovery of a new, unexplored connected component. We then:\n        a. Increment the component counter: $c_{count} \\leftarrow c_{count} + 1$.\n        b. Initiate a graph traversal (e.g., DFS) starting from $v$. This traversal will explore all vertices reachable from $v$ in $G'$.\n        c. During the traversal, every vertex encountered is marked as visited by adding it to the set $V_{visited}$.\n\n4.  **Graph Traversal (Depth-First Search)**:\n    A standard iterative DFS can be implemented using a stack.\n    - To traverse a component starting from vertex $v_{start}$:\n        a. Initialize a stack and push $v_{start}$ onto it.\n        b. While the stack is not empty:\n            i. Pop a vertex, say $u$, from the stack.\n            ii. If $u$ is not in $V_{visited}$, mark it as visited ($V_{visited} \\leftarrow V_{visited} \\cup \\{u\\}$).\n            iii. For each neighbor $w$ of $u$ in the adjacency list of $G'$, if $w$ is not in $V_{visited}$, push $w$ onto the stack.\n\nAfter iterating through all vertices in $V'$, the final value of $c_{count}$ is the total number of connected components in $G'$.\n\nLet us apply this procedure to Case $1$:\n- $n=9$, $V=\\{0, ..., 8\\}$, $S=\\{2, 5\\}$.\n- $V' = V \\setminus S = \\{0, 1, 3, 4, 6, 7, 8\\}$.\n- Edges $(u,v) \\in E$ with $u,v \\in V'$ are: $(0,1)$, $(4,6)$, $(7,8)$.\n- Adjacency List for $G'$: $\\{0:[1], 1:[0], 3:[], 4:[6], 6:[4], 7:[8], 8:[7]\\}$.\n- Algorithm Execution:\n    - Initialize $c_{count} = 0$, $V_{visited} = \\varnothing$.\n    - Pick vertex $0 \\in V'$. It is not visited.\n        - $c_{count} \\leftarrow 1$.\n        - Start traversal from $0$. It will visit vertices $\\{0, 1\\}$. Now $V_{visited} = \\{0, 1\\}$.\n    - Pick vertex $3 \\in V'$. It is not visited.\n        - $c_{count} \\leftarrow 2$.\n        - Start traversal from $3$. It will visit only $\\{3\\}$. Now $V_{visited} = \\{0, 1, 3\\}$.\n    - Pick vertex $4 \\in V'$. It is not visited.\n        - $c_{count} \\leftarrow 3$.\n        - Start traversal from $4$. It will visit vertices $\\{4, 6\\}$. Now $V_{visited} = \\{0, 1, 3, 4, 6\\}$.\n    - Pick vertex $7 \\in V'$. It is not visited.\n        - $c_{count} \\leftarrow 4$.\n        - Start traversal from $7$. It will visit vertices $\\{7, 8\\}$. Now $V_{visited} = \\{0, 1, 3, 4, 6, 7, 8\\}$.\n    - All vertices in $V'$ are now in $V_{visited}$. The loop terminates.\n- The result for Case $1$ is $4$. This logic is applied to all test cases. For Case $3$, $V'$ is empty, so the number of components is correctly identified as $0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the number of connected components for a series of graph test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (n, E, S)\n    # n: number of vertices\n    # E: set of edges as tuples\n    # S: set of vertices to remove\n    test_cases = [\n        (9, {(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (5, 6), (6, 4), (7, 8)}, {2, 5}),\n        (5, {(0, 1), (1, 2)}, set()),\n        (4, {(0, 1), (2, 3)}, {0, 1, 2, 3}),\n        (6, set(), {1, 3}),\n        (7, {(0, 1), (1, 2), (2, 3), (3, 0), (3, 4), (4, 5)}, {1}),\n        (7, {(0, 1), (0, 2), (0, 3), (3, 4), (3, 5), (5, 6)}, {0, 3}),\n    ]\n\n    results = []\n    for n, E, S in test_cases:\n        # Step 1: Determine the set of vertices in the induced subgraph G[V \\ S].\n        active_vertices = {i for i in range(n)} - S\n\n        # If there are no vertices in the induced subgraph, there are 0 components.\n        if not active_vertices:\n            results.append(0)\n            continue\n\n        # Step 2: Build the adjacency list for the induced subgraph.\n        # An adjacency list is a dictionary mapping each vertex to a list of its neighbors.\n        adj = {v: [] for v in active_vertices}\n        for u, v in E:\n            # An edge is part of the induced subgraph only if both its endpoints are.\n            if u in active_vertices and v in active_vertices:\n                adj[u].append(v)\n                adj[v].append(u)\n\n        # Step 3: Count connected components using a graph traversal algorithm.\n        visited = set()\n        num_components = 0\n\n        # Iterate through each vertex of the induced subgraph.\n        for vertex in active_vertices:\n            # If a vertex hasn't been visited, it belongs to a new component.\n            if vertex not in visited:\n                num_components += 1\n                # Start a traversal (iterative DFS) to find all vertices in this component.\n                stack = [vertex]\n                while stack:\n                    current_node = stack.pop()\n                    if current_node not in visited:\n                        visited.add(current_node)\n                        for neighbor in adj[current_node]:\n                            if neighbor not in visited:\n                                stack.append(neighbor)\n        \n        results.append(num_components)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3223832"}, {"introduction": "Beyond just counting components, it is often crucial to understand their intrinsic properties. This exercise introduces bipartiteness, a key structural characteristic of graphs with applications ranging from scheduling to resource allocation [@problem_id:3223897]. You will learn to adapt a standard graph traversal to perform a 'two-coloring' test, elegantly determining whether each component contains an odd-length cycle.", "problem": "You are given the fundamental definitions for an undirected simple graph and its connected structure. An undirected simple graph $G=(V,E)$ has a finite vertex set $V$ with $\\lvert V\\rvert = n$ where vertices are labeled by integers from $0$ to $n-1$, and an edge set $E \\subseteq \\{\\{u,v\\} \\mid u,v \\in V, u \\neq v\\}$, where each edge is an unordered pair with no duplicate edges and no self-loops. A connected component is a maximal subset $C \\subseteq V$ such that for any two vertices $u,v \\in C$ there exists a path in $G$ between $u$ and $v$. A subgraph is bipartite if there exists a partition of its vertex set into two disjoint subsets $(X,Y)$ such that every edge has one endpoint in $X$ and the other endpoint in $Y$. An odd cycle is a cycle of length $2k+1$ for some integer $k \\ge 0$.\n\nTask: For each graph in the test suite below, determine for each connected component two boolean values in the order $[b,o]$, where $b$ is $\\text{True}$ if and only if the connected component is bipartite (in the sense of a two-set partition of its vertices with all edges crossing the partition), and $o$ is $\\text{True}$ if and only if the connected component contains a cycle of odd length. If a graph has no connected components (for instance, when $n=0$), the result for that graph is the empty list $[]$. Components in the output must be ordered by increasing minimum vertex label within each component, which is achieved by scanning vertices in increasing order $0,1,\\dots,n-1$ and starting a new component when encountering an unvisited vertex.\n\nYour program must be a complete, runnable program that produces a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each element is the per-graph list of component results. The output format must be exactly one line of the form $[r_1,r_2,\\dots,r_T]$, where $T$ is the number of test cases and each $r_i$ is itself a list of lists of booleans with no extraneous whitespace (for example, $[[\\text{True},\\text{False}],[\\text{False},\\text{True}]]$). No physical units are involved in this problem.\n\nTest suite:\n- Test case $1$: $n=0$, $E=\\emptyset$.\n- Test case $2$: $n=1$, $E=\\emptyset$.\n- Test case $3$: $n=2$, $E=\\{(0,1)\\}$.\n- Test case $4$: $n=3$, $E=\\{(0,1),(1,2),(2,0)\\}$.\n- Test case $5$: $n=4$, $E=\\{(0,1),(1,2),(2,3),(3,0)\\}$.\n- Test case $6$: $n=7$, $E=\\{(0,1),(1,2),(3,4),(4,5),(5,3)\\}$, with vertex $6$ isolated.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5,r_6]$), where each $r_i$ is the list of $[\\text{bipartite},\\text{odd\\_cycle}]$ pairs for the components of test case $i$ in the specified order.", "solution": "We begin from the core definitions in graph theory. An undirected simple graph $G=(V,E)$ has vertices $V$ and edges $E$ that connect unordered pairs of distinct vertices. A connected component is a maximal subset of vertices in which any two vertices are connected by some path. A subgraph is bipartite if there exists a partition of its vertex set into $(X,Y)$ with $X \\cap Y = \\emptyset$ such that each edge has endpoints in different parts. A cycle is a closed walk with no repeated vertices except the starting and ending vertex; an odd cycle has length $2k+1$ for some integer $k \\ge 0$.\n\nThe key well-tested fact is the characterization: an undirected graph is bipartite if and only if it has no odd cycle. We will derive why this holds and how it guides an algorithm.\n\nWhy bipartiteness excludes odd cycles: Suppose a graph is bipartite with partition $(X,Y)$. Consider any cycle; edges alternate between the sets because every edge goes across the partition. Starting from a vertex in $X$, the next vertex is in $Y$, the next in $X$, and so on. Returning to the start requires an even number of steps because after an odd number of steps we would be in $Y$, not in $X$, so any cycle must have even length. Therefore, no odd cycle can exist in a bipartite graph.\n\nConversely, why an odd cycle implies non-bipartiteness: Suppose the graph has an odd cycle $v_0,v_1,\\dots,v_{2k},v_0$. Any attempt to partition vertices into two sets where adjacent vertices are in different sets will fail because as we alternate assignments around the cycle, we require $v_0$ to be in both sets simultaneously when we return after an odd number of edges, which is impossible. Therefore, the presence of an odd cycle precludes bipartiteness.\n\nAlgorithmic design from first principles:\n- To analyze connected components, we need to process the graph one component at a time. A standard approach built on paths and adjacency is to explore the graph using Breadth-First Search (BFS) or Depth-First Search (DFS). Breadth-First Search (BFS) visits vertices in expanding layers via a queue, and Depth-First Search (DFS) explores as deeply as possible via recursion or a stack.\n- To test bipartiteness, we can formalize the partition as a two-coloring function $c: V \\to \\{0,1\\}$ such that for each edge $(u,v) \\in E$, $c(u) \\neq c(v)$. We attempt to assign colors while exploring a connected component:\n  1. Initialize all vertices with color $-1$ meaning uncolored.\n  2. For each unvisited vertex $s$ in increasing label order, start a new component and assign $c(s)=0$.\n  3. Traverse the component via BFS. For each edge $(u,v)$ encountered:\n     - If $c(v)=-1$, assign $c(v)=1-c(u)$ and continue.\n     - If $c(v)=c(u)$, we detect a conflict. This conflict implies an odd cycle exists. To see why, consider the BFS tree paths from the start vertex to $u$ and to $v$. Since $c(u)=c(v)$, the lengths of these paths have the same parity (both even or both odd). Adding the edge $(u,v)$ closes a cycle whose length is the sum of the two path lengths plus $1$, resulting in an odd number. Therefore, the component contains an odd cycle and cannot be bipartite.\n  4. If the traversal finishes without conflicts, we have constructed a valid two-coloring, so the component is bipartite and has no odd cycle.\n- This algorithm runs in $O(\\lvert V\\rvert + \\lvert E\\rvert)$ time for each graph because each vertex and edge is processed a constant number of times.\n\nDeterministic component ordering is ensured by scanning vertices in increasing order $0,1,\\dots,n-1$ and starting a new exploration whenever we encounter a vertex not yet visited; this first encounter for each component is its minimum-labeled vertex.\n\nApplying the algorithm to the test suite:\n- Test case $1$: $n=0$, $E=\\emptyset$. There are no vertices, hence no components. Output $[]$.\n- Test case $2$: $n=1$, $E=\\emptyset$. One isolated vertex forms a single component. It is bipartite (assign color $0$) and has no cycle, thus $[\\text{True},\\text{False}]$.\n- Test case $3$: $n=2$, $E=\\{(0,1)\\}$. A single edge connects two vertices; assign colors $0$ and $1$. No conflict, bipartite, no odd cycle: $[\\text{True},\\text{False}]$.\n- Test case $4$: $n=3$, $E=\\{(0,1),(1,2),(2,0)\\}$. This is a $3$-cycle. Attempted two-coloring fails because adjacent vertices force the third edge to connect vertices with equal color, detecting an odd cycle: $[\\text{False},\\text{True}]$.\n- Test case $5$: $n=4$, $E=\\{(0,1),(1,2),(2,3),(3,0)\\}$. This is a $4$-cycle, which is bipartite (colors alternate around the cycle). No odd cycle: $[\\text{True},\\text{False}]$.\n- Test case $6$: $n=7$, $E=\\{(0,1),(1,2),(3,4),(4,5),(5,3)\\}$ with vertex $6$ isolated. There are three components:\n  - Component with vertices $\\{0,1,2\\}$ is a path, bipartite: $[\\text{True},\\text{False}]$.\n  - Component with vertices $\\{3,4,5\\}$ is a $3$-cycle, not bipartite and contains an odd cycle: $[\\text{False},\\text{True}]$.\n  - Component $\\{6\\}$ is an isolated vertex, bipartite: $[\\text{True},\\text{False}]$.\n  Ordered by increasing minimum label, the component results are $[[\\text{True},\\text{False}],[\\text{False},\\text{True}],[\\text{True},\\text{False}]]$.\n\nThe program will implement the BFS-based two-coloring for each connected component, collect the booleans per component in the specified order, and print a single line aggregating all test case results as $[r_1,r_2,r_3,r_4,r_5,r_6]$ with no extraneous whitespace.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef analyze_components(n: int, edges: List[Tuple[int, int]]) -> List[List[bool]]:\n    \"\"\"\n    For an undirected simple graph with n vertices labeled 0..n-1 and a list of edges,\n    return a list of [is_bipartite, has_odd_cycle] for each connected component.\n    Components are ordered by increasing minimum vertex label, achieved by scanning\n    vertices from 0 to n-1 and starting a new component when encountering an unvisited vertex.\n    \"\"\"\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        if u == v:\n            # Self-loop immediately implies odd cycle and non-bipartite in its component.\n            # Add the edge to adjacency for completeness.\n            adj[u].append(v)\n            adj[v].append(u)\n        else:\n            adj[u].append(v)\n            adj[v].append(u)\n\n    color = [-1] * n  # -1 uncolored, 0 and 1 are the two colors\n    visited = [False] * n\n    results = []\n\n    for start in range(n):\n        if visited[start]:\n            continue\n        # Start a new component at 'start'\n        comp_has_odd_cycle = False\n        queue = deque()\n        queue.append(start)\n        color[start] = 0\n        visited[start] = True\n\n        # BFS over the component\n        while queue:\n            u = queue.popleft()\n            cu = color[u]\n            for v in adj[u]:\n                cv = color[v]\n                if cv == -1:\n                    color[v] = 1 - cu\n                    visited[v] = True\n                    queue.append(v)\n                else:\n                    # If neighbor has same color, we detected an odd cycle\n                    if cv == cu:\n                        comp_has_odd_cycle = True\n            # Continue to process all edges to mark entire component visited\n\n        # After finishing BFS from 'start', we may still have unvisited vertices\n        # in the same component if there were disconnected due to empty adjacency\n        # (isolated vertex is already visited because we enqueued 'start').\n        # For completeness, ensure all vertices reachable from 'start' are marked visited.\n        # The BFS loop already guarantees that.\n\n        # The component is bipartite iff no odd cycle was detected.\n        comp_is_bipartite = (not comp_has_odd_cycle)\n        results.append([comp_is_bipartite, comp_has_odd_cycle])\n\n        # There might be other vertices in this component not reached if the graph\n        # had multiple disconnected subgraphs, but BFS ensures reachability within the component.\n\n    return results\n\ndef format_case_result(case_result: List[List[bool]]) -> str:\n    \"\"\"\n    Format a single test case's result (list of [bipartite, odd_cycle] pairs) without spaces.\n    \"\"\"\n    parts = []\n    for pair in case_result:\n        b_str = \"True\" if pair[0] else \"False\"\n        o_str = \"True\" if pair[1] else \"False\"\n        parts.append(f\"[{b_str},{o_str}]\")\n    return f\"[{','.join(parts)}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Empty graph\n        (0, []),\n        # Test case 2: Single isolated vertex\n        (1, []),\n        # Test case 3: Single edge, bipartite\n        (2, [(0, 1)]),\n        # Test case 4: Triangle (3-cycle), odd cycle present\n        (3, [(0, 1), (1, 2), (2, 0)]),\n        # Test case 5: Square (4-cycle), bipartite\n        (4, [(0, 1), (1, 2), (2, 3), (3, 0)]),\n        # Test case 6: Multiple components: path {0-1-2}, triangle {3-4-5}, isolated {6}\n        (7, [(0, 1), (1, 2), (3, 4), (4, 5), (5, 3)]),\n    ]\n\n    # Compute results for all test cases\n    all_results = []\n    for n, edges in test_cases:\n        case_result = analyze_components(n, edges)\n        # Note: analyze_components returns one entry per component discovered in ascending start vertex order.\n        # For graphs with multiple components, this will naturally be ordered by the minimum vertex label in each component.\n        all_results.append(format_case_result(case_result))\n\n    # Final print statement in the exact required format (single line, no spaces inside list representations).\n    print(f\"[{','.join(all_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3223897"}, {"introduction": "Identifying connected components is often the first step in a larger network optimization task. This problem situates you as a network designer tasked with connecting a fragmented system at the lowest possible cost [@problem_id:3223947]. It requires you to synthesize component analysis with optimization principles, developing a strategy to bridge the gaps in a network with minimum expense.", "problem": "You are given a finite, undirected, weighted graph with vertex set $V=\\{0,1,\\dots,n-1\\}$ and an edge set $E\\subseteq \\{\\{u,v\\}\\mid u\\neq v,\\,u,v\\in V\\}$ together with a nonnegative weight function on edges $w_E:\\,E\\to \\mathbb{R}_{\\ge 0}$. The edge weights $w_E$ are used only to define a realistic weighted graph instance; they do not contribute to the cost you must compute. The graph may be disconnected, forming several connected components. You are also given a nonnegative node-price function $p:\\,V\\to \\mathbb{R}_{\\ge 0}$. You are allowed to add any new undirected edge $\\{u,v\\}$ not already in $E$ between distinct vertices $u$ and $v$, and the cost you pay to add such an edge is $p(u)+p(v)$. Existing edges in $E$ are already present at no additional cost.\n\nTask. Starting only from the fundamental definitions of connected components in undirected graphs and the requirement that any two different components must be joined by at least one new edge to make the overall graph connected, derive an algorithm that computes the minimum total cost to add edges so that the entire graph becomes a single connected component. If the graph is already connected, the cost is $0$. All quantities must be treated as exact real numbers; there are no physical units to report. You must reason from first principles: define connected components precisely, characterize how a single new edge can merge two components, and determine how to combine such merges to achieve global connectivity with minimal total cost. Avoid any use of unproven shortcut formulas.\n\nPrecise input model for each test case. A test case is a triple $(n,E,p)$ where:\n1) $n$ is an integer with $n\\ge 1$ giving the number of vertices labeled $0$ through $n-1$;\n2) $E$ is a list of triples $(u,v,w)$ where $u$ and $v$ are integers with $0\\le u,v  n$, $u\\neq v$, and $w\\in \\mathbb{R}_{\\ge 0}$; each triple denotes an undirected edge between $u$ and $v$ with existing weight $w$ (which does not directly affect the cost you must compute);\n3) $p$ is a list of length $n$ whose $i$-th entry $p[i]$ equals $p(i)\\in \\mathbb{R}_{\\ge 0}$.\n\nYour program must compute, for each test case, a single number equal to the minimal additional cost required to add edges so that the entire graph becomes connected, under the rule that adding a new edge $\\{u,v\\}$ costs $p(u)+p(v)$. If the graph is already connected, the cost must be $0$.\n\nTest suite. Use the following five test cases exactly and in this order:\n1) $n=6$, $E=\\{(0,1,4),(1,2,3),(3,4,2)\\}$, $p=[4,2,7,1,3,5]$.\n2) $n=4$, $E=\\{(0,1,5),(1,2,2),(2,3,1)\\}$, $p=[10,10,10,10]$.\n3) $n=2$, $E=\\{\\}$, $p=[7,3]$.\n4) $n=7$, $E=\\{(0,1,5),(3,4,1),(5,6,8)\\}$, $p=[8,6,5,9,2,4,7]$.\n5) $n=1$, $E=\\{\\}$, $p=[5]$.\n\nOutput specification. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, if the results of the five test cases were $a_1,a_2,a_3,a_4,a_5$, then you must print exactly the string \"[a_1,a_2,a_3,a_4,a_5]\" on one line with no spaces.\n\nNotes.\n1) You must treat edges as undirected. If $(u,v,w)\\in E$, then $(v,u,w)$ is implicitly also in $E$.\n2) Your algorithm should not assume any special structure beyond what is specified. It must be correct for any nonnegative node prices and any undirected graph structure.\n3) The answer for each test case is a single integer in these specific instances, but the general algorithm must handle real-valued $p(i)$ if present in other inputs.", "solution": "The objective is to find the minimum cost to make a given graph $G=(V, E)$ connected by adding new edges. The cost of adding an edge $\\{u, v\\}$ is defined as $p(u) + p(v)$. We are required to derive the solution from first principles.\n\n**1. Connected Components and the Goal**\n\nAn undirected graph is *connected* if there is a path between any two of its vertices. The relation \"is connected to\" is an equivalence relation on the vertex set $V$. The equivalence classes of this relation are called the *connected components* of the graph. Let the initial graph have $k$ connected components, denoted $C_1, C_2, \\dots, C_k$. To make the entire graph connected, we must add edges such that all vertices belong to a single component.\n\nIf $k=1$, the graph is already connected, and by definition, the cost is $0$.\n\nIf $k > 1$, we must add edges to merge these $k$ components into one. Adding an edge $\\{u, v\\}$ where $u \\in C_i$ and $v \\in C_j$ with $i \\neq j$ merges components $C_i$ and $C_j$ into a single larger component. Adding an edge within a component does not reduce the number of components. To connect a graph of $k$ components, we must add at least $k-1$ edges, forming a spanning tree structure on the components themselves. Our goal is to select these $k-1$ edges to minimize the total cost.\n\n**2. Optimal Connection Strategy**\n\nLet's model the problem on the components. Consider a \"super-graph\" where each vertex represents a connected component $C_i$. We wish to find a minimum spanning tree (MST) in this super-graph. The weight of an edge between two super-vertices $C_i$ and $C_j$ is the minimum possible cost to connect them with a single new edge.\n\nThe cost to connect component $C_i$ to component $C_j$ is given by:\n$$ \\min_{u \\in C_i, v \\in C_j} \\{p(u) + p(v)\\} $$\nSince the terms $p(u)$ and $p(v)$ are independent, this minimum is achieved by choosing the vertex with the minimum price in each component.\n$$ (\\min_{u \\in C_i} p(u)) + (\\min_{v \\in C_j} p(v)) $$\nLet us define $w_i = \\min_{u \\in C_i} p(u)$ as the minimum node price within component $C_i$. The cost to connect $C_i$ and $C_j$ is thus $w_i + w_j$.\n\nWe now need to find an MST on a complete graph of $k$ vertices (representing the components), where the edge weight between vertex $i$ and vertex $j$ is $w_i + w_j$. Let the chosen spanning tree have edge set $T_{comp}$. The total cost is:\n$$ \\text{Cost} = \\sum_{\\{i, j\\} \\in T_{comp}} (w_i + w_j) $$\nThis sum can be rewritten in terms of the degrees of the vertices in the component spanning tree. If $d(i)$ is the degree of component $C_i$ in the tree $T_{comp}$, then its minimum price $w_i$ is included in the sum $d(i)$ times.\n$$ \\text{Cost} = \\sum_{i=1}^{k} d(i) w_i $$\nFor any tree with $k$ vertices, we know that $d(i) \\ge 1$ and $\\sum_{i=1}^{k} d(i) = 2(k-1)$. To minimize the total cost, which is a weighted sum of degrees, we should assign the largest degrees to the vertices with the smallest weights (prices) $w_i$. This is a direct application of the rearrangement inequality.\n\nThe highest possible degree in a tree on $k$ vertices is $k-1$, which occurs in a star graph. A star graph has one central vertex of degree $k-1$ and $k-1$ leaf vertices of degree $1$. To minimize the cost, we should choose the component with the globally minimum price as the central \"anchor\" component. Let the component prices be sorted as $w_{(1)} \\le w_{(2)} \\le \\dots \\le w_{(k)}$. We choose the component corresponding to $w_{(1)}$ as the center. Its degree in the spanning tree will be $d((1)) = k-1$. All other components $C_{(j)}$ for $j \\in \\{2, \\dots, k\\}$ will have degree $d((j)) = 1$. This strategy connects every other component directly to the single \"cheapest\" anchor component.\n\n**3. Cost Formula Derivation**\n\nThe total cost for this optimal star-graph strategy is the sum of the costs of the $k-1$ edges connecting each non-anchor component to the anchor component:\n$$ \\text{Cost} = \\sum_{j=2}^{k} (w_{(1)} + w_{(j)}) $$\nThis can be expanded and simplified:\n$$ \\text{Cost} = (k-1) w_{(1)} + \\sum_{j=2}^{k} w_{(j)} $$\nLet $S = \\sum_{j=1}^{k} w_{(j)}$ be the sum of all component-minimum prices. We can write $\\sum_{j=2}^{k} w_{(j)} = S - w_{(1)}$. Substituting this into the cost expression:\n$$ \\text{Cost} = (k-1) w_{(1)} + (S - w_{(1)}) = k w_{(1)} - w_{(1)} + S - w_{(1)} = S + (k-2) w_{(1)} $$\nSo, the minimum cost is the sum of the minimum prices of all components, plus $(k-2)$ times the globally smallest of these minimum prices. This formula holds for $k \\ge 2$. For $k=2$, the cost is $S + (0)w_{(1)} = S = w_{(1)} + w_{(2)}$, which is correct. For $k=1$, the cost is $0$.\n\n**4. Final Algorithm**\n\nThe complete algorithm is as follows:\n1.  Given the graph parameters $(n, E, p)$, construct an adjacency list representation of the graph.\n2.  Identify the connected components of the graph. This can be done using a graph traversal algorithm like Breadth-First Search (BFS) or Depth-First Search (DFS). Maintain a `visited` array to keep track of discovered vertices.\n3.  During the traversal for each component, find the minimum node price among all vertices in that component. Store these minimum prices in a list, `component_min_prices`.\n4.  Let $k$ be the number of connected components found (i.e., the length of `component_min_prices`).\n5.  If $k \\le 1$, the graph is already connected or trivial. The cost is $0$.\n6.  If $k > 1$, calculate the total minimum cost using the derived formula:\n    a. Calculate $S$, the sum of all values in `component_min_prices`.\n    b. Find $w_{\\min\\_global}$, the minimum value in `component_min_prices`.\n    c. The total cost is $S + (k-2) \\times w_{\\min\\_global}$.\n7.  Return the calculated cost.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for a predefined suite of test cases.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        (6, [(0, 1, 4), (1, 2, 3), (3, 4, 2)], [4, 2, 7, 1, 3, 5]),\n        (4, [(0, 1, 5), (1, 2, 2), (2, 3, 1)], [10, 10, 10, 10]),\n        (2, [], [7, 3]),\n        (7, [(0, 1, 5), (3, 4, 1), (5, 6, 8)], [8, 6, 5, 9, 2, 4, 7]),\n        (1, [], [5])\n    ]\n\n    results = []\n    for n, E, p in test_cases:\n        cost = compute_min_cost(n, E, p)\n        # The problem statement implies integer results for these specific test cases.\n        results.append(int(cost))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_min_cost(n, edges, prices):\n    \"\"\"\n    Computes the minimum cost to make a graph connected.\n\n    The algorithm proceeds as follows:\n    1. Identify all connected components of the graph.\n    2. For each component, find the minimum node price among its vertices.\n    3. If there is only one component (or fewer), the graph is already connected; cost is 0.\n    4. If there are k  1 components, the minimum cost is achieved by connecting all other\n       k-1 components to the one \"anchor\" component that contains the node with the\n       globally minimum price.\n    5. The total cost is derived as S + (k-2)*w_min_global, where S is the sum of\n       all component-minimum prices and w_min_global is the smallest of these prices.\n    \"\"\"\n    if n = 1:\n        return 0\n\n    # Adjacency list representation of the graph\n    adj = [[] for _ in range(n)]\n    for u, v, _ in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * n\n    component_min_prices = []\n\n    for i in range(n):\n        if not visited[i]:\n            # A new component is found, start a traversal (DFS)\n            min_price_in_component = float('inf')\n            \n            stack = [i]\n            visited[i] = True\n            \n            while stack:\n                u = stack.pop()\n                min_price_in_component = min(min_price_in_component, prices[u])\n                \n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        stack.append(v)\n            \n            component_min_prices.append(min_price_in_component)\n\n    k = len(component_min_prices)\n    \n    if k = 1:\n        return 0\n    else:\n        # Sum of the minimum node prices from each component\n        sum_of_min_prices = sum(component_min_prices)\n        \n        # Globally minimum price among all component minimums\n        global_min_price = min(component_min_prices)\n        \n        # Derived formula for the total minimum cost\n        total_cost = sum_of_min_prices + (k - 2) * global_min_price\n        return total_cost\n\n# Execute the solution\nsolve()\n\n```", "id": "3223947"}]}