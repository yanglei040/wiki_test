{"hands_on_practices": [{"introduction": "Understanding AVL trees begins with mastering the mechanics of how balance is maintained. This practice provides a hands-on walkthrough of the insertion process, requiring you to calculate balance factors at each step for a carefully chosen sequence of keys. By manually tracing these changes, you will see precisely how and why a specific imbalance, like a Right–Left ($RL$) rotation, is triggered, solidifying your grasp of the core rebalancing logic [@problem_id:3210713].", "problem": "You will use the core definitions of Adelson–Velsky and Landis (AVL) trees to analyze how rotations are triggered and how balance factors evolve during binary search tree insertions. Let the height of an empty child be defined as $-1$, the height of a node be $1 + \\max\\{\\text{height of left child}, \\text{height of right child}\\}$, and the balance factor of a node $v$ be $\\operatorname{bf}(v) = \\text{height(left}(v)) - \\text{height(right}(v))$. An AVL tree is balanced if every node has balance factor in $\\{-1, 0, 1\\}$. Upon insertion, a node $z$ triggers:\n- a Left–Left ($LL$) rotation if $\\operatorname{bf}(z) = +2$ and the insertion occurred in the left subtree of $z$'s left child,\n- a Right–Right ($RR$) rotation if $\\operatorname{bf}(z) = -2$ and the insertion occurred in the right subtree of $z$'s right child,\n- a Left–Right ($LR$) rotation if $\\operatorname{bf}(z) = +2$ and the left child of $z$ has $\\operatorname{bf} = -1$ (fix is a left rotation on the left child, then a right rotation on $z$),\n- a Right–Left ($RL$) rotation if $\\operatorname{bf}(z) = -2$ and the right child of $z$ has $\\operatorname{bf} = +1$ (fix is a right rotation on the right child, then a left rotation on $z$).\n\nConsider inserting the keys $\\{1,2,3,4,5,6,7\\}$ into an initially empty binary search tree in the specific order $\\langle 4, 6, 5, 2, 1, 3, 7 \\rangle$. This order forces a Right–Left ($RL$) rotation at node $4$ at the moment just after inserting key $5$ and before any rebalancing is performed at that step.\n\nFor step $t \\in \\{1,2,\\dots,7\\}$, let $V_t$ denote the set of nodes present immediately after the $t$-th insertion and before any rebalancing at that step, and let $\\operatorname{bf}_t^{-}(v)$ denote the balance factor of a node $v \\in V_t$ in that pre-rebalancing tree. Define the cumulative imbalance magnitude\n$$\nS \\;=\\; \\sum_{t=1}^{7} \\;\\sum_{v \\in V_t} \\left|\\operatorname{bf}_t^{-}(v)\\right|.\n$$\n\nTasks:\n- Using only the fundamental definitions above, argue why the given insertion order forces an $RL$ rotation at node $4$ at the moment just after inserting key $5$.\n- Compute $\\operatorname{bf}_t^{-}(v)$ for every $v \\in V_t$ at each step $t$ and identify all rotation triggers at their first unbalanced ancestors.\n- Evaluate the exact value of $S$.\n\nYour final answer must be the exact value of $S$ (a single integer). No rounding is required.", "solution": "The problem is valid as it is self-contained, scientifically grounded in the theory of AVL trees, and well-posed. The definitions, insertion sequence, and the quantity to be computed are all specified unambiguously, ensuring a unique and meaningful solution exists.\n\nThe solution proceeds in two parts. First, we will demonstrate why an RL rotation is forced at node $4$ after inserting key $5$. Second, we will trace the insertion of each of the $7$ keys, calculating the set of pre-rebalancing balance factors $\\operatorname{bf}_t^{-}(v)$ at each step $t$ and summing their absolute magnitudes to find the total cumulative imbalance $S$.\n\n### Argument for Right-Left (RL) Rotation\n\nWe begin with an empty tree.\n1.  Insert $4$: The tree is a single node, $4$. $h(4)=0$, $\\operatorname{bf}(4)=0$.\n2.  Insert $6$: Since $6 > 4$, $6$ becomes the right child of $4$. The tree is $4 \\rightarrow (\\text{right}) \\ 6$.\n    - $h(6) = 1 + \\max(-1, -1) = 0$.\n    - $h(4) = 1 + \\max(h(\\text{left}), h(6)) = 1 + \\max(-1, 0) = 1$.\n    - $\\operatorname{bf}(4) = h(\\text{left}) - h(6) = -1 - 0 = -1$. The tree is balanced.\n\n3.  Insert $5$: Since $5 > 4$, we go right to node $6$. Since $5 < 6$, we go left. $5$ is inserted as the left child of $6$. The structure before any rebalancing is $4 \\rightarrow (\\text{right}) \\ 6 \\rightarrow (\\text{left}) \\ 5$. Let's analyze the state just after this insertion, denoted by $t=3$.\n    - Let $v_4, v_5, v_6$ be the nodes with keys $4, 5, 6$.\n    - The height of the new leaf node is $h(v_5) = 0$. Its balance factor is $\\operatorname{bf}_3^{-}(v_5) = 0 - 0 = 0$.\n    - The height of its parent is $h(v_6) = 1 + \\max(h(v_5), h(\\text{empty})) = 1+\\max(0, -1) = 1$.\n    - The balance factor of $v_6$ is $\\operatorname{bf}_3^{-}(v_6) = h(v_5) - h(\\text{empty}) = 0 - (-1) = +1$.\n    - The height of the root node is $h(v_4) = 1 + \\max(h(\\text{empty}), h(v_6)) = 1+\\max(-1, 1) = 2$.\n    - The balance factor of $v_4$ is $\\operatorname{bf}_3^{-}(v_4) = h(\\text{empty}) - h(v_6) = -1 - 1 = -2$.\n\nThe first node, tracing up from the insertion point ($v_5$), with a balance factor outside the set $\\{-1, 0, 1\\}$ is $z=v_4$. Its balance factor is $\\operatorname{bf}_3^{-}(v_4) = -2$. The problem defines an RL rotation trigger for a node $z$ as: \"$\\operatorname{bf}(z) = -2$ and the right child of $z$ has $\\operatorname{bf} = +1$\". Here, $z=v_4$, its right child is $v_6$, and we have calculated $\\operatorname{bf}_3^{-}(v_6) = +1$.\nBoth conditions are met. Thus, the insertion of key $5$ forces an RL rotation at node $4$.\n\n### Step-by-Step Calculation of $S$\n\nWe now compute $S = \\sum_{t=1}^{7} \\sum_{v \\in V_t} |\\operatorname{bf}_t^{-}(v)|$. For each step $t$, we show the tree state before rebalancing, calculate the balance factors, sum their absolute values, and describe the rebalancing operation.\n\n**Step $t=1$: Insert $4$**\n-   Pre-rebalancing tree: A single node $4$.\n-   $V_1 = \\{4\\}$.\n-   $\\operatorname{bf}_1^{-}(4) = 0$.\n-   $\\sum_{v \\in V_1} |\\operatorname{bf}_1^{-}(v)| = |0| = 0$.\n-   Tree is balanced.\n\n**Step $t=2$: Insert $6$**\n-   Pre-rebalancing tree: $4 \\rightarrow (\\text{right}) \\ 6$.\n-   $V_2 = \\{4, 6\\}$.\n-   $\\operatorname{bf}_2^{-}(6) = 0$.\n-   $\\operatorname{bf}_2^{-}(4) = h(\\text{left}) - h(\\text{right}) = -1 - 0 = -1$.\n-   $\\sum_{v \\in V_2} |\\operatorname{bf}_2^{-}(v)| = |-1| + |0| = 1$.\n-   Tree is balanced.\n\n**Step $t=3$: Insert $5$**\n-   Pre-rebalancing tree: $4 \\rightarrow (\\text{right}) \\ 6 \\rightarrow (\\text{left}) \\ 5$.\n-   $V_3 = \\{4, 5, 6\\}$.\n-   $\\operatorname{bf}_3^{-}(5) = 0$.\n-   $\\operatorname{bf}_3^{-}(6) = h(5) - h(\\text{empty}) = 0 - (-1) = 1$.\n-   $\\operatorname{bf}_3^{-}(4) = h(\\text{empty}) - h(6) = -1 - 1 = -2$.\n-   $\\sum_{v \\in V_3} |\\operatorname{bf}_3^{-}(v)| = |-2| + |0| + |1| = 3$.\n-   Rotation: Node $4$ is unbalanced ($\\operatorname{bf}=-2$) with right child's $\\operatorname{bf}=+1$. An **RL rotation** is performed at node $4$. The tree becomes rooted at $5$, with left child $4$ and right child $6$.\n\n**Step $t=4$: Insert $2$**\n-   Tree after rebalancing from $t=3$: $5 \\rightarrow (\\text{left}) \\ 4, (\\text{right}) \\ 6$.\n-   Pre-rebalancing tree for $t=4$: $5 \\rightarrow (\\text{left}) \\ (4 \\rightarrow (\\text{left}) \\ 2), (\\text{right}) \\ 6$.\n-   $V_4 = \\{2, 4, 5, 6\\}$.\n-   $\\operatorname{bf}_4^{-}(2)=0$, $\\operatorname{bf}_4^{-}(6)=0$.\n-   $\\operatorname{bf}_4^{-}(4) = h(2) - h(\\text{empty}) = 0 - (-1) = 1$.\n-   $\\operatorname{bf}_4^{-}(5) = h(4) - h(6) = 1 - 0 = 1$.\n-   $\\sum_{v \\in V_4} |\\operatorname{bf}_4^{-}(v)| = |0| + |1| + |1| + |0| = 2$.\n-   Tree is balanced.\n\n**Step $t=5$: Insert $1$**\n-   Tree from $t=4$: $5 \\rightarrow \\big( (\\text{left}) \\ 4 \\rightarrow(\\text{left}) \\ 2 \\big), (\\text{right}) \\ 6$.\n-   Pre-rebalancing tree for $t=5$: $5 \\rightarrow \\big( (\\text{left}) \\ 4 \\rightarrow(\\text{left}) \\ (2 \\rightarrow \\text{left} \\ 1) \\big), (\\text{right}) \\ 6$.\n-   $V_5 = \\{1, 2, 4, 5, 6\\}$.\n-   $\\operatorname{bf}_5^{-}(1)=0$, $\\operatorname{bf}_5^{-}(6)=0$.\n-   $\\operatorname{bf}_5^{-}(2) = h(1) - h(\\text{empty}) = 0 - (-1) = 1$.\n-   $h(2)=1$, so $\\operatorname{bf}_5^{-}(4) = h(2) - h(\\text{empty}) = 1 - (-1) = 2$.\n-   $h(4)=2$, so $\\operatorname{bf}_5^{-}(5) = h(4) - h(6) = 2 - 0 = 2$.\n-   $\\sum_{v \\in V_5} |\\operatorname{bf}_5^{-}(v)| = |0| + |1| + |2| + |2| + |0| = 5$.\n-   Rotation: Node $4$ is the first unbalanced node ($\\operatorname{bf}=+2$). Insertion was in the left subtree of its left child. An **LL rotation** (a single right rotation) is performed at node $4$. The subtree rooted at $4$ becomes rooted at $2$, with left child $1$ and right child $4$. This fixes the balance for all ancestors, including node $5$.\n\n**Step $t=6$: Insert $3$**\n-   Tree after rebalancing from $t=5$: $5 \\rightarrow \\big( (\\text{left}) \\ (2 \\rightarrow (\\text{left}) \\ 1, (\\text{right}) \\ 4) \\big), (\\text{right}) \\ 6$.\n-   Pre-rebalancing tree for $t=6$: Insertion of $3$ ($3<5, 3>2, 3<4$) is as left child of $4$.\n-   $V_6 = \\{1, 2, 3, 4, 5, 6\\}$.\n-   $\\operatorname{bf}_6^{-}(1)=0$, $\\operatorname{bf}_6^{-}(3)=0$, $\\operatorname{bf}_6^{-}(6)=0$.\n-   $\\operatorname{bf}_6^{-}(4) = h(3) - h(\\text{empty}) = 0 - (-1) = 1$.\n-   $h(4)=1, h(1)=0$, so $\\operatorname{bf}_6^{-}(2) = h(1) - h(4) = 0 - 1 = -1$.\n-   $h(2)=2, h(6)=0$, so $\\operatorname{bf}_6^{-}(5) = h(2) - h(6) = 2 - 0 = 2$.\n-   $\\sum_{v \\in V_6} |\\operatorname{bf}_6^{-}(v)| = |0| + |-1| + |0| + |1| + |2| + |0| = 4$.\n-   Rotation: Node $5$ is unbalanced ($\\operatorname{bf}=+2$) and its left child ($2$) has $\\operatorname{bf}=-1$. An **LR rotation** is performed at node $5$. The final tree is rooted at $4$.\n\n**Step $t=7$: Insert $7$**\n-   Tree after rebalancing from $t=6$: rooted at $4$, left child $2$ (with children $1,3$), right child $5$ (with right child $6$).\n-   Pre-rebalancing tree for $t=7$: $7$ is inserted as right child of $6$.\n-   $V_7 = \\{1, 2, 3, 4, 5, 6, 7\\}$.\n-   $\\operatorname{bf}_7^{-}(1)=0, \\operatorname{bf}_7^{-}(3)=0, \\operatorname{bf}_7^{-}(7)=0$.\n-   $\\operatorname{bf}_7^{-}(2) = h(1) - h(3) = 0 - 0 = 0$.\n-   $\\operatorname{bf}_7^{-}(6) = h(\\text{empty}) - h(7) = -1 - 0 = -1$.\n-   $h(2)=1$. $h(6)=1$, so $\\operatorname{bf}_7^{-}(5) = h(\\text{empty}) - h(6) = -1 - 1 = -2$.\n-   $h(5)=2$, so $\\operatorname{bf}_7^{-}(4) = h(2) - h(5) = 1 - 2 = -1$.\n-   $\\sum_{v \\in V_7} |\\operatorname{bf}_7^{-}(v)| = |0| + |0| + |0| + |-1| + |-2| + |-1| + |0| = 4$.\n-   Rotation: Node $5$ is unbalanced ($\\operatorname{bf}=-2$). Insertion was in right subtree of right child. An **RR rotation** (a single left rotation) is performed at node $5$.\n\n**Final Calculation of S**\nThe total cumulative imbalance magnitude $S$ is the sum of the per-step sums:\n$$\nS = \\sum_{t=1}^{7} \\sum_{v \\in V_t} |\\operatorname{bf}_t^{-}(v)| = 0 + 1 + 3 + 2 + 5 + 4 + 4\n$$\n$$\nS = 19\n$$", "answer": "$$\\boxed{19}$$", "id": "3210713"}, {"introduction": "After mastering the mechanics of single rotations, we can analyze broader patterns that emerge during the construction of an AVL tree. This exercise challenges you to consider the special case of inserting keys in strictly increasing order, a scenario that consistently creates imbalance on the right spine of the tree. By analyzing when rotations occur versus when they don't, you can derive a predictive, closed-form expression for the total number of rotations required, revealing a beautiful connection between tree height, the number of nodes, and powers of two [@problem_id:3211028].", "problem": "Consider the insertion of strictly increasing keys $1, 2, 3, \\ldots, n$ into an Adelson-Velsky and Landis (AVL) tree. An AVL tree is a self-balancing binary search tree in which, for every node, the balance factor defined as $h_{\\text{left}} - h_{\\text{right}}$ (where $h_{\\text{left}}$ and $h_{\\text{right}}$ are the heights of the left and right subtrees, respectively) must remain in $\\{-1, 0, 1\\}$. During insertion, if the balance factor magnitude exceeds $1$ for some ancestor of the inserted key, the tree is rebalanced using rotations. A single rotation counts as $1$ rotation; a double rotation counts as $2$ rotations.\n\nStarting from the empty tree, insert the keys in the order $1, 2, \\ldots, n$ using the standard AVL insertion algorithm that rebalances at the first encountered unbalanced ancestor on the path back to the root. Assume the conventional definition of height where a leaf has height $0$ and an empty subtree has height $-1$.\n\nDerive, from first principles and core definitions of binary search trees and AVL balance factors, a closed-form expression in terms of $n$ for the total number of rotations performed by the AVL tree during the entire build process. Your final answer must be a single analytic expression in $n$ with no hidden constants or asymptotic notation. No rounding is required, and no physical units are involved.", "solution": "The user wants me to act as a meticulous and exacting professor in the STEM fields. I need to first validate the problem statement and then, if it is valid, provide a complete, reasoned solution. All mathematical entities must be in LaTeX.\n\n### Step 1: Problem Validation\n\nI will begin by dissecting the problem statement to validate its integrity.\n\n**Extraction of Givens:**\n- **Input Data**: Keys are inserted in the strictly increasing order $1, 2, 3, \\ldots, n$.\n- **Data Structure**: An Adelson-Velsky and Landis (AVL) tree.\n- **Initial State**: The process starts with an empty tree.\n- **Balance Factor Definition**: The balance factor of a node is defined as $BF = h_{\\text{left}} - h_{\\text{right}}$, where $h_{\\text{left}}$ and $h_{\\text{right}}$ are the heights of the left and right subtrees, respectively.\n- **AVL Invariant**: The balance factor for every node must be in the set $\\{-1, 0, 1\\}$.\n- **Rebalancing Algorithm**: Rebalancing occurs at the first unbalanced ancestor encountered on the path from the inserted node back to the root.\n- **Height Convention**: The height of a leaf node is $0$, and the height of an empty subtree is $-1$. This implies a recursive height definition for a non-null node $u$ as $h(u) = 1 + \\max(h(u_{\\text{left}}), h(u_{\\text{right}}))$.\n- **Rotation Cost**: A single rotation contributes $1$ to the total count, and a double rotation contributes $2$.\n- **Objective**: Derive a closed-form analytic expression for the total number of rotations performed during the insertion of all $n$ keys.\n\n**Validation using Extracted Givens:**\n1.  **Scientific Grounding**: The problem is situated entirely within the formal domain of computer science, specifically data structures and algorithms. All terms such as AVL tree, balance factor, and rotations are standard and well-defined. Thus, the problem is scientifically grounded.\n2.  **Well-Posedness**: The initial state (empty tree), the sequence of operations (insertion of $1, \\ldots, n$), and the rebalancing algorithm are all deterministic. The definitions of height and rotation cost are unambiguous. This ensures that for any given $n$, the process is unique and leads to a single, well-defined total number of rotations. The problem is well-posed.\n3.  **Objectivity**: The problem is stated in precise, technical language, free from any subjective or ambiguous terminology.\n4.  **Completeness and Consistency**: The provided information is self-contained and sufficient for a rigorous derivation. The height convention is standard and internally consistent. There are no contradictions in the setup.\n\n**Verdict:**\nThe problem statement is **valid**. It is a standard, well-posed problem in algorithm analysis. I will now proceed to derive the solution.\n\n### Step 2: Solution Derivation\n\nLet $R(n)$ denote the total number of rotations after inserting the keys $1, 2, \\ldots, n$ into an initially empty AVL tree. We are asked to find a closed-form expression for $R(n)$.\n\n**Analysis of the Insertion Pattern**\nThe keys are inserted in strictly increasing order. This means that for any key $k \\in \\{1, \\ldots, n\\}$, it is greater than all keys already present in the tree. Consequently, the insertion of key $k$ always occurs in the rightmost position of the tree, as the right child of the node containing key $k-1$. This insertion path is always along the \"right spine\" of the tree.\n\n**Condition for Rotation**\nA rebalancing rotation is triggered upon inserting key $k$ if and only if this insertion causes an ancestor node $u$ to violate the AVL invariant, i.e., its balance factor falls outside the range $\\{-1, 0, 1\\}$.\nLet's analyze the balance factor of a node $u$ on the right spine of the tree $T_{k-1}$ (the tree after inserting keys $1, \\ldots, k-1$). Due to the strictly increasing insertion order, the right subtree of any such node $u$ is always at least as high as its left subtree. Therefore, the balance factor of $u$, $BF(u) = h_{\\text{left}}(u) - h_{\\text{right}}(u)$, can only be $0$ or $-1$.\n\nWhen key $k$ is inserted, the height of the right subtree of every node $u$ on the right spine increases by exactly $1$. The height of the left subtree remains unchanged. The new balance factor becomes $BF_{\\text{new}}(u) = h_{\\text{left}}(u) - (h_{\\text{right}}(u) + 1) = BF_{\\text{old}}(u) - 1$.\n- If $BF_{\\text{old}}(u) = 0$, then $BF_{\\text{new}}(u) = -1$. The AVL property is maintained.\n- If $BF_{\\text{old}}(u) = -1$, then $BF_{\\text{new}}(u) = -2$. The AVL property is violated, and a rotation is required.\n\nThus, a rotation is triggered by inserting key $k$ if and only if there is at least one node on the right spine of $T_{k-1}$ with a balance factor of $-1$.\n\nFurthermore, since the new node $k$ is inserted into the right subtree of the right child of the pivot node (the first unbalanced ancestor), this is a classic \"Right-Right\" case. Such an imbalance is corrected with a single left rotation. A double rotation (which costs $2$) corresponds to a \"Right-Left\" or \"Left-Right\" case, neither of which can occur under this insertion pattern. Therefore, each rebalancing event contributes exactly $1$ to the total rotation count.\n\nThe total number of rotations $R(n)$ is simply the number of insertion steps $k \\in \\{1, \\ldots, n\\}$ that trigger a rebalancing.\n\n**Rotations and Tree Height**\nA key property of an AVL rotation is that it restores the height of the rebalanced subtree to its height before the insertion that caused the imbalance. This means if the insertion of key $k$ triggers a rotation, the height of the entire tree, $H(T_k)$, will be the same as the height of the tree before insertion, $H(T_{k-1})$.\n$$H(T_k) = H(T_{k-1}) \\quad (\\text{if a rotation occurs})$$\nConversely, if no rotation is triggered by inserting key $k$, it must be that all nodes on the right spine of $T_{k-1}$ had a balance factor of $0$. After insertion, their balance factors all become $-1$, and the height of every node on the right spine, including the root, increases by $1$.\n$$H(T_k) = H(T_{k-1}) + 1 \\quad (\\text{if no rotation occurs})$$\nA tree where all nodes on its right spine have a balance factor of $0$ is a perfect binary tree. No rotation occurs at step $k$ if and only if the tree $T_{k-1}$ (containing $k-1$ nodes) is a perfect binary tree. A perfect binary tree is one that is full at every level, and thus has $2^j-1$ nodes for some number of levels $j$. Thus, no rotation happens if $k-1 = 2^j - 1$ for some integer $j \\ge 1$, which simplifies to $k = 2^j$.\n\nLet $r(k)$ be the number of rotations when inserting key $k$.\n- $r(k) = 0$ if $k$ is a power of $2$ (i.e., $k = 2^j$ for some integer $j \\ge 0$).\n- $r(k) = 1$ if $k$ is not a power of $2$.\n\nThis logic also covers the initial cases:\n- For $k=1$, we insert $1$ into an empty tree. No rotation occurs. $r(1)=0$. $1$ is $2^0$.\n- For $k=2$, we insert $2$. The tree becomes a root with a right child. No rotation occurs. $r(2)=0$. $2$ is $2^1$.\n\n**Derivation of the Closed-Form Expression**\nThe total number of rotations, $R(n)$, is the sum of rotations for each step from $k=1$ to $n$:\n$$R(n) = \\sum_{k=1}^{n} r(k)$$\nBased on our finding, this sum is equal to the number of integers in the set $\\{1, 2, \\ldots, n\\}$ that are not powers of $2$.\n$$R(n) = (\\text{Total numbers from } 1 \\text{ to } n) - (\\text{Number of powers of } 2 \\text{ in } \\{1, \\ldots, n\\})$$\nThe total number of integers from $1$ to $n$ is $n$.\nWe need to find the number of integers $k$ such that $k = 2^j$ and $1 \\le k \\le n$ for some integer $j \\ge 0$.\nTaking the base-$2$ logarithm, we get:\n$$j \\le \\log_2(n)$$\nSince $j$ must be a non-negative integer, the possible values for $j$ are $0, 1, 2, \\ldots, \\lfloor \\log_2 n \\rfloor$.\nThe number of such values of $j$ is $(\\lfloor \\log_2 n \\rfloor - 0) + 1 = \\lfloor \\log_2 n \\rfloor + 1$.\nSo, there are $\\lfloor \\log_2 n \\rfloor + 1$ powers of two between $1$ and $n$, inclusive.\n\nSubstituting this back into the expression for $R(n)$:\n$$R(n) = n - (\\lfloor \\log_2 n \\rfloor + 1)$$\n$$R(n) = n - \\lfloor \\log_2 n \\rfloor - 1$$\nThis is the final closed-form expression for the total number of rotations.", "answer": "$$\\boxed{n - \\lfloor \\log_{2}(n) \\rfloor - 1}$$", "id": "3211028"}, {"introduction": "While insertion is a common focus, understanding the impact of deletion is equally crucial for mastering dynamic data structures like AVL trees. This practice flips the usual question: instead of fixing an imbalance, you are tasked with identifying which key deletions *avoid* creating an imbalance altogether. This coding challenge requires you to simulate the standard BST deletion process and verify the post-operation state of the tree, honing your skills in both algorithmic implementation and the subtle logic of AVL maintenance [@problem_id:3211065].", "problem": "You are given several valid Adelson-Velsky and Landis (AVL) trees. An Adelson-Velsky and Landis (AVL) tree is a binary search tree in which, for every node $v$, the balance factor $\\beta(v)$ satisfies $|\\beta(v)| \\leq 1$, where $\\beta(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$ and $h(\\cdot)$ denotes the height of a subtree. The height function $h(T)$ is defined recursively by $h(\\varnothing) = -1$ and $h(T) = 1 + \\max\\{h(T_{\\text{left}}), h(T_{\\text{right}})\\}$ for a non-empty subtree $T$. A leaf node therefore has height $0$. A binary search tree satisfies the invariant that for each node with key $k$, all keys in the left subtree are strictly less than $k$, and all keys in the right subtree are strictly greater than $k$.\n\nA rotation is a local restructuring operation (single or double rotation) that restores the invariant $|\\beta(v)| \\leq 1$ at an unbalanced node produced by updates. In an Adelson-Velsky and Landis (AVL) tree, rotations are needed after an update if and only if there exists a node $v$ with $|\\beta(v)| = 2$.\n\nDeletion from a binary search tree proceeds by the following well-tested rule set: given a key $x$,\n- if the node with key $x$ has no child, remove it;\n- if it has one child, replace it by its child;\n- if it has two children, replace its key with its in-order successor’s key (the minimum key in its right subtree) and then delete that successor node from the right subtree.\n\nStarting from the above fundamental definitions, your task is to identify, for each provided valid Adelson-Velsky and Landis (AVL) tree, a key whose deletion (using the standard binary search tree deletion described above) will not require any rotations anywhere in the tree. Equivalently, after performing the deletion, the resulting tree must still satisfy $|\\beta(v)| \\leq 1$ for every node $v$. If multiple keys satisfy this property, you must select the smallest such key. If no such key exists, output $-1$.\n\nTest Suite:\nEach tree is specified by an insertion sequence of distinct integer keys. Build the tree by inserting the keys in the given order using standard Adelson-Velsky and Landis (AVL) tree insertion, which maintains $|\\beta(v)| \\leq 1$ via rotations as needed during insertion. Use the following insertion sequences (each number is an integer key, presented in the given order; all numbers are to be interpreted as pure integers without any units):\n- Case $1$: $[10, 5, 15, 3, 7, 13, 17]$\n- Case $2$: $[8, 4, 12, 2, 6, 10, 14, 1, 3]$\n- Case $3$: $[50, 25, 75, 10, 37, 62, 87, 5, 12, 31, 43, 57, 68, 81, 93]$\n- Case $4$: $[30, 20, 40, 10, 25, 35, 50, 27, 26]$\n- Case $5$: $[1, 2, 3, 4, 5, 6]$\n\nYour program must:\n- Construct each Adelson-Velsky and Landis (AVL) tree by inserting the sequence in the given order.\n- For each constructed tree, consider deletion of every existing key $x$ via the standard binary search tree deletion operation described earlier. For each deletion, determine if the post-deletion tree remains an Adelson-Velsky and Landis (AVL) tree (i.e., $|\\beta(v)| \\leq 1$ for all nodes $v$). Collect all such keys $x$ whose deletion does not require any rotations, and choose the smallest. If the collection is empty, return $-1$ for that case.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for all five cases as a comma-separated list enclosed in square brackets, for example, $[r_1, r_2, r_3, r_4, r_5]$, where each $r_i$ is the selected integer key for Case $i$ or $-1$ if no such key exists. No angles or physical units appear in this problem, and all reported values are pure integers.", "solution": "The problem requires us to identify, for a given set of Adelson-Velsky and Landis (AVL) trees, the smallest key whose deletion, using a standard binary search tree (BST) deletion algorithm, does not necessitate any rebalancing rotations. An AVL tree is balanced if for every node $v$, its balance factor $\\beta(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$ satisfies $|\\beta(v)| \\leq 1$. A rotation is required if an update (like deletion) causes any node to have a balance factor of $|\\beta(v)| = 2$. Therefore, the task is to find the smallest key whose deletion leaves the tree in a state where $|\\beta(v)| \\leq 1$ for all nodes $v$.\n\nThe solution follows a multi-step, systematic approach for each test case.\n\n**1. AVL Tree Construction**\nFirst, we must construct the initial valid AVL trees from the provided insertion sequences. This requires a robust implementation of an AVL tree data structure.\n\n-   **Node Structure**: Each node in the tree stores its `key`, pointers to its `left` and `right` children, and its `height`. The height of a leaf is $0$, and the height of a `None` (empty) subtree is $-1$. The height of an internal node is $1 + \\max(\\text{height of left child, height of right child})$.\n\n-   **Insertion Algorithm**: For each key in a given sequence, we perform an AVL insertion. This starts with a standard BST insertion, which places the new key at a leaf position. Then, as the recursion unwinds back to the root, we update the height of each node along the insertion path. After each height update, we calculate the node's balance factor. If a node becomes unbalanced ($|\\beta(v)| = 2$), we perform the appropriate single or double rotation to restore the AVL property. The four imbalance cases are:\n    1.  **Left-Left Case**: A single right rotation.\n    2.  **Left-Right Case**: A left rotation on the left child, followed by a right rotation on the current node.\n    3.  **Right-Right Case**: A single left rotation.\n    4.  **Right-Left Case**: A right rotation on the right child, followed by a left rotation on the current node.\n\nBy applying this procedure for each key in the input sequence, we construct the required initial AVL tree for each test case.\n\n**2. Simulation of Deletion and Validation**\nThe core of the problem is to check the outcome of deleting each key. The process must be a simulation because we are not actually changing the tree permanently, but rather testing a hypothetical scenario for each key.\n\n-   **Systematic Iteration**: We first obtain a sorted list of all keys present in the constructed AVL tree. An in-order traversal of a BST (and thus an AVL tree) naturally yields the keys in ascending order. We then iterate through these keys. The first key that satisfies the condition will be the smallest one, fulfilling the problem's requirement.\n\n-   **Deletion Simulation**: For each key $x$ to be tested:\n    1.  **Create a Copy**: To avoid altering the original tree, which is needed for subsequent tests, we create a deep copy of the entire tree structure.\n    2.  **Perform BST Deletion**: On this copy, we execute the BST deletion algorithm as specified in the problem statement, but crucially, *without* the rebalancing (rotation) step. The algorithm is as follows:\n        -   If the node to be deleted has **no children**, it is simply removed.\n        -   If it has **one child**, the node is replaced by its child.\n        -   If it has **two children**, its key is replaced by the key of its in-order successor (the smallest key in its right subtree). Then, the successor node is recursively deleted from the right subtree.\n    3.  **Update Heights**: During the recursive deletion process, the heights of all nodes on the path from the deleted node back to the root are updated.\n\n-   **Validation Check**: After the structural change from the deletion and the subsequent height updates, we must verify if the resulting tree remains a valid AVL tree.\n    1.  **Traverse the Tree**: We perform a full traversal (e.g., pre-order or post-order) of the modified tree copy.\n    2.  **Check Balance Factors**: For each node $v$ in the tree, we compute its balance factor $\\beta(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$.\n    3.  **Condition Check**: If we find any node where $|\\beta(v)| > 1$, it means that rotations would have been necessary to restore balance. Therefore, the deletion of key $x$ is not a valid solution.\n    4.  **Successful Candidate**: If the traversal completes and all nodes satisfy $|\\beta(v)| \\leq 1$, then deleting key $x$ does not require any rotations. It is a valid candidate.\n\n**3. Determining the Final Answer**\n-   For each test case, we iterate through the sorted keys. The first key found to be a valid candidate is, by definition, the smallest such key. We record this key as the result for the case and proceed to the next test case.\n-   If we iterate through all keys in the tree and none of them result in a balanced tree upon deletion, it means no such key exists. In this situation, the answer for the test case is $-1$.\n\nThis comprehensive procedure of construction, simulation, and validation is applied to each of the five test cases to generate the final list of results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport copy\nimport sys\n\n# Increase recursion limit for deep trees during validation.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"A node in the AVL tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 0  # Height of a leaf node is 0\n\nclass AVLTree:\n    \"\"\"AVL tree implementation with methods for insertion, deletion, and validation.\"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def _height(self, node):\n        return node.height if node else -1 # Height of an empty subtree is -1\n\n    def _get_balance(self, node):\n        if not node:\n            return 0\n        return self._height(node.left) - self._height(node.right)\n\n    def _right_rotate(self, z):\n        y = z.left\n        T3 = y.right\n        y.right = z\n        z.left = T3\n        z.height = 1 + max(self._height(z.left), self._height(z.right))\n        y.height = 1 + max(self._height(y.left), self._height(y.right))\n        return y\n\n    def _left_rotate(self, y):\n        z = y.right\n        T2 = z.left\n        z.left = y\n        y.right = T2\n        y.height = 1 + max(self._height(y.left), self._height(y.right))\n        z.height = 1 + max(self._height(z.left), self._height(z.right))\n        return z\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n\n    def _insert(self, root, key):\n        if not root:\n            return Node(key)\n        elif key < root.key:\n            root.left = self._insert(root.left, key)\n        else:\n            root.right = self._insert(root.right, key)\n\n        root.height = 1 + max(self._height(root.left), self._height(root.right))\n        balance = self._get_balance(root)\n\n        # Rebalance if necessary\n        # Case 1: Left Left\n        if balance > 1 and key < root.left.key:\n            return self._right_rotate(root)\n        # Case 2: Right Right\n        if balance < -1 and key > root.right.key:\n            return self._left_rotate(root)\n        # Case 3: Left Right\n        if balance > 1 and key > root.left.key:\n            root.left = self._left_rotate(root.left)\n            return self._right_rotate(root)\n        # Case 4: Right Left\n        if balance < -1 and key < root.right.key:\n            root.right = self._right_rotate(root.right)\n            return self._left_rotate(root)\n        \n        return root\n\n    def _get_min_value_node(self, root):\n        current = root\n        while current.left is not None:\n            current = current.left\n        return current\n\n    def bst_delete(self, key):\n        \"\"\"Performs BST deletion without rebalancing, only height updates.\"\"\"\n        self.root = self._bst_delete(self.root, key)\n    \n    def _bst_delete(self, root, key):\n        if not root:\n            return root\n\n        if key < root.key:\n            root.left = self._bst_delete(root.left, key)\n        elif key > root.key:\n            root.right = self._bst_delete(root.right, key)\n        else: # Node to be deleted is found\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n            \n            # Node with two children\n            temp = self._get_min_value_node(root.right)\n            root.key = temp.key\n            root.right = self._bst_delete(root.right, temp.key)\n\n        if not root: # In case the tree becomes empty\n            return root\n\n        root.height = 1 + max(self._height(root.left), self._height(root.right))\n        return root\n\n    def is_balanced(self):\n        \"\"\"Checks if the entire tree satisfies the AVL property.\"\"\"\n        return self._is_balanced_recursive(self.root)\n\n    def _is_balanced_recursive(self, root):\n        if not root:\n            return True\n        \n        balance = self._get_balance(root)\n        if abs(balance) > 1:\n            return False\n            \n        return self._is_balanced_recursive(root.left) and \\\n               self._is_balanced_recursive(root.right)\n\n    def get_all_keys(self):\n        \"\"\"Returns a sorted list of all keys in the tree.\"\"\"\n        keys = []\n        self._inorder_traversal(self.root, keys)\n        return keys\n\n    def _inorder_traversal(self, root, keys_list):\n        if root:\n            self._inorder_traversal(root.left, keys_list)\n            keys_list.append(root.key)\n            self._inorder_traversal(root.right, keys_list)\n            \ndef solve():\n    \"\"\"Main function to solve the problem for all test cases.\"\"\"\n    test_cases = [\n        [10, 5, 15, 3, 7, 13, 17],\n        [8, 4, 12, 2, 6, 10, 14, 1, 3],\n        [50, 25, 75, 10, 37, 62, 87, 5, 12, 31, 43, 57, 68, 81, 93],\n        [30, 20, 40, 10, 25, 35, 50, 27, 26],\n        [1, 2, 3, 4, 5, 6]\n    ]\n\n    final_results = []\n    for insertion_sequence in test_cases:\n        # 1. Build the initial AVL tree for the current case.\n        avl_tree = AVLTree()\n        for key in insertion_sequence:\n            avl_tree.insert(key)\n        \n        # 2. Get a sorted list of all keys in the tree.\n        all_keys = avl_tree.get_all_keys()\n        \n        # 3. Find the smallest key whose deletion doesn't require rotation.\n        result_for_case = -1\n        for key_to_delete in all_keys:\n            # a. Create a deep copy to simulate deletion on.\n            tree_copy = copy.deepcopy(avl_tree)\n            \n            # b. Perform standard BST deletion (without rebalancing).\n            tree_copy.bst_delete(key_to_delete)\n            \n            # c. Check if the resulting tree is still balanced.\n            if tree_copy.is_balanced():\n                result_for_case = key_to_delete\n                break  # Found the smallest key, move to the next test case.\n        \n        final_results.append(result_for_case)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "3211065"}]}