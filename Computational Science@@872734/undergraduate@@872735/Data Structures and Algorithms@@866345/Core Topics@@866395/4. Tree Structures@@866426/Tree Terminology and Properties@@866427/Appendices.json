{"hands_on_practices": [{"introduction": "The shape of a binary tree can vary dramatically, from perfectly balanced to long and stringy. This exercise challenges you to explore the structural limits of a binary tree by considering its vertical dimension. By determining the maximum number of distinct depths possible for a given number of nodes, you will gain a deeper intuition for how tree structures can be stretched to their extremes and the relationship between node count and tree height [@problem_id:3280887].", "problem": "Let $T$ be a rooted binary tree, defined as a connected acyclic graph with a distinguished root in which every node has at most two children. The depth of a node is the number of edges on the unique simple path from the root to that node; in particular, the root has depth $0$. For a given $N \\in \\mathbb{N}$, consider the class of all such trees with exactly $N$ nodes. Among all trees in this class, determine the maximum possible cardinality of the set of distinct node depths that occur in the tree, expressed as a function of $N$. Your answer must be a single closed-form expression in terms of $N$. No rounding is required.", "solution": "The user wants to find the maximum possible number of distinct node depths in a rooted binary tree with $N$ nodes.\n\nFirst, the problem statement is validated.\n\n### Step 1: Extract Givens\n- $T$ is a rooted binary tree, defined as a connected acyclic graph with a distinguished root in which every node has at most two children.\n- The depth of a node is the number of edges on the unique simple path from the root to that node.\n- The root has depth $0$.\n- The tree has exactly $N$ nodes, where $N \\in \\mathbb{N}$.\n- The goal is to determine the maximum possible cardinality of the set of distinct node depths that occur in the tree.\n- The answer must be a single closed-form expression in $N$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is scientifically sound and well-posed. It uses standard, rigorously defined concepts from graph theory and computer science (data structures). The term \"rooted binary tree\", \"depth\", and \"cardinality\" are unambiguous. The problem is self-contained, providing all necessary definitions and constraints. It asks for the maximum of a well-defined quantity over a well-defined set of objects. There are no contradictions, factual errors, or subjective elements. The problem is therefore deemed **valid**.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n### Solution\nLet $T$ be a rooted binary tree with a set of nodes $V$, such that the total number of nodes is $|V| = N$.\nFor any node $v \\in V$, its depth, denoted $d(v)$, is the number of edges on the path from the root to $v$. The root itself has a depth of $d(\\text{root}) = 0$.\n\nThe set of all depths that occur among the nodes of $T$ is given by:\n$$S_T = \\{ d(v) \\mid v \\in V \\}$$\nThe problem asks for the maximum possible value of the cardinality of this set, $|S_T|$, over all possible rooted binary trees with $N$ nodes. Let us denote this maximum value by $M(N)$.\n\nLet $m = |S_T|$ be the cardinality of the set of distinct depths for a given tree $T$. Let the distinct depths be $k_1, k_2, \\ldots, k_m$.\nFor each distinct depth $k_j \\in S_T$, there must exist at least one node $v_j \\in V$ such that $d(v_j) = k_j$.\nSince a node can have only one depth, the nodes corresponding to these distinct depths must themselves be distinct. That is, if $k_i \\neq k_j$, then $v_i \\neq v_j$.\nTherefore, the number of distinct depths, $m$, cannot be greater than the total number of nodes, $N$. This establishes an upper bound on the cardinality of the set of depths:\n$$|S_T| \\le N$$\nThis inequality must hold for any rooted binary tree with $N$ nodes. Consequently, the maximum possible cardinality must also satisfy this bound:\n$$M(N) = \\max_{T:|V|=N} |S_T| \\le N$$\n\nTo determine if this upper bound can be achieved, we must demonstrate that for any positive integer $N$, there exists a rooted binary tree with $N$ nodes that has exactly $N$ distinct depths.\n\nConsider the construction of a specific type of binary tree, often called a degenerate or skewed tree, which resembles a path. Let the nodes be labeled $v_0, v_1, \\ldots, v_{N-1}$.\n- Let $v_0$ be the root of the tree.\n- For each integer $i$ from $0$ to $N-2$, let $v_{i+1}$ be a child of $v_i$. For definiteness, we can specify that $v_{i+1}$ is the left child of $v_i$, and the right child pointer is null.\n- The node $v_{N-1}$ is a leaf, having no children.\n\nThis construction defines a valid rooted binary tree. It is a connected, acyclic graph with a root ($v_0$), and every node has at most two children (in this case, nodes $v_0, \\ldots, v_{N-2}$ have one child, and node $v_{N-1}$ has zero children).\n\nNow, let's determine the depths of the nodes in this specific tree, which we will call $T_{path}$.\n- The depth of the root, $v_0$, is by definition $d(v_0) = 0$.\n- The node $v_1$ is a child of the root, so its depth is $d(v_1) = d(v_0) + 1 = 1$.\n- The node $v_2$ is a child of $v_1$, so its depth is $d(v_2) = d(v_1) + 1 = 2$.\n- Following this pattern, we can establish by induction that the depth of node $v_i$ is $d(v_i) = i$ for all $i \\in \\{0, 1, \\ldots, N-1\\}$.\n\nThe set of depths of all nodes in $T_{path}$ is $\\{d(v_0), d(v_1), \\ldots, d(v_{N-1})\\} = \\{0, 1, 2, \\ldots, N-1\\}$.\nThe set of distinct depths is therefore $S_{T_{path}} = \\{0, 1, 2, \\ldots, N-1\\}$.\nThe cardinality of this set is $|S_{T_{path}}| = N$.\n\nWe have shown two things:\n1.  For any binary tree with $N$ nodes, the number of distinct depths is at most $N$.\n2.  There exists a binary tree with $N$ nodes (the path-like tree) for which the number of distinct depths is exactly $N$.\n\nCombining these two facts, we conclude that the maximum possible cardinality of the set of distinct node depths is $N$.", "answer": "$$\\boxed{N}$$", "id": "3280887"}, {"introduction": "Beyond simple counts of nodes and edges, trees are governed by more subtle mathematical laws. This practice problem introduces a powerful, non-obvious property that constrains the possible arrangements of leaves in any binary tree. By testing whether a given set of leaf depths is valid, you will apply a fundamental inequality that connects data structures to information theory, revealing the elegant mathematical rules that underpin tree structures [@problem_id:3280782].", "problem": "A rooted binary tree is a finite, ordered tree in which each node has at most two children. A leaf is a node with outdegree $0$, and the depth of a node is the number of edges on the unique path from the root to that node. Consider the multiset of depths of all leaves in a finite rooted binary tree. Which of the following multisets could be the full set of leaf depths of some valid rooted binary tree? Choose all that apply.\n\nA. $\\{1,1,2,3\\}$\n\nB. $\\{2,2,3,3,3\\}$\n\nC. $\\{0,2,3\\}$\n\nD. $\\{1,3,4,4,5,5,5\\}$\n\nE. $\\{2,2,2,2\\}$\n\nProvide justification grounded in the core definitions above and general, widely accepted properties of binary trees, without assuming special restrictions such as every internal node having exactly two children.", "solution": "The problem asks to determine which of the given multisets of numbers can represent the depths of all leaves in a finite rooted binary tree. A rooted binary tree allows nodes to have $0$, $1$, or $2$ children.\n\nA fundamental property connects the depths of the leaves of any such tree. Let $D$ be the multiset of the depths of all leaves in a finite rooted binary tree. This multiset $D = \\{d_1, d_2, \\ldots, d_k\\}$ is valid if and only if it satisfies two conditions:\n1.  If $0 \\in D$, then $D$ must be $\\{0\\}$. A leaf at depth $0$ implies the root node is a leaf. If the root is a leaf, it has no children, and the tree consists of only this single node. Consequently, there can be no other leaves at other depths.\n2.  The sum of the quantities $2^{-d}$ for each depth $d$ in the multiset must be less than or equal to $1$. This is a form of the Kraft's inequality for prefix codes, where leaf depths correspond to codeword lengths.\n    $$ \\sum_{i=1}^{k} 2^{-d_i} \\le 1 $$\n\nLet us provide a brief justification for this inequality. We can construct any binary tree by starting with a single node (the root) and repeatedly applying an expansion operation.\n- **Base Case:** The simplest tree is a single node, which is the root. This node is also a leaf at depth $d=0$. The sum is $2^{-0} = 1$. The inequality $1 \\le 1$ holds.\n- **Inductive Step:** Assume we have a valid binary tree for which the sum is $S = \\sum_{l \\in \\text{leaves}} 2^{-d(l)} \\le 1$. We can expand the tree by picking a leaf $l_0$ at depth $d_0$ and making it an internal node.\n    - If we give $l_0$ one child, this new child becomes a leaf at depth $d_0+1$. The original leaf $l_0$ is removed from the set of leaves. The new sum $S'$ is:\n      $$ S' = S - 2^{-d_0} + 2^{-(d_0+1)} = S - 2^{-d_0} + \\frac{1}{2} 2^{-d_0} = S - \\frac{1}{2} 2^{-d_0} $$\n      Since $S \\le 1$, the new sum $S'$ is also less than or equal to $1$.\n    - If we give $l_0$ two children, these two new children become leaves, both at depth $d_0+1$. The original leaf $l_0$ is removed. The new sum $S'$ is:\n      $$ S' = S - 2^{-d_0} + 2^{-(d_0+1)} + 2^{-(d_0+1)} = S - 2^{-d_0} + 2 \\cdot \\left(\\frac{1}{2} 2^{-d_0}\\right) = S $$\n      The sum remains unchanged.\n\nSince we start with a sum of $1$ and the operations either preserve the sum or decrease it, the sum for any finite rooted binary tree must be less than or equal to $1$. The converse, that any multiset of depths satisfying the inequality corresponds to a valid tree, is also true and can be shown by a constructive algorithm.\n\nWe will now evaluate each option based on this principle.\n\n**A. $\\{1,1,2,3\\}$**\nThe multiset of depths is $D = \\{1,1,2,3\\}$. We calculate the sum:\n$$ S = 2^{-1} + 2^{-1} + 2^{-2} + 2^{-3} = \\frac{1}{2} + \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} $$\n$$ S = 1 + \\frac{1}{4} + \\frac{1}{8} = \\frac{8}{8} + \\frac{2}{8} + \\frac{1}{8} = \\frac{11}{8} $$\nSince $S = \\frac{11}{8} > 1$, the inequality is violated.\nVerdict: **Incorrect**.\n\n**B. $\\{2,2,3,3,3\\}$**\nThe multiset of depths is $D = \\{2,2,3,3,3\\}$. We calculate the sum:\n$$ S = 2^{-2} + 2^{-2} + 2^{-3} + 2^{-3} + 2^{-3} = 2 \\cdot 2^{-2} + 3 \\cdot 2^{-3} $$\n$$ S = 2 \\cdot \\frac{1}{4} + 3 \\cdot \\frac{1}{8} = \\frac{1}{2} + \\frac{3}{8} = \\frac{4}{8} + \\frac{3}{8} = \\frac{7}{8} $$\nSince $S = \\frac{7}{8} \\le 1$, the inequality holds. Such a tree can be constructed.\nVerdict: **Correct**.\n\n**C. $\\{0,2,3\\}$**\nThe multiset of depths $D = \\{0,2,3\\}$ contains the depth $0$. A leaf at depth $0$ implies the root is a leaf. If the root is a leaf, it has an outdegree of $0$ and cannot have any children. Therefore, the tree consists of a single node. The set of all leaf depths in such a tree would be just $\\{0\\}$. The presence of other leaf depths, $2$ and $3$, creates a contradiction.\nVerdict: **Incorrect**.\n\n**D. $\\{1,3,4,4,5,5,5\\}$**\nThe multiset of depths is $D = \\{1,3,4,4,5,5,5\\}$. We calculate the sum:\n$$ S = 2^{-1} + 2^{-3} + 2 \\cdot 2^{-4} + 3 \\cdot 2^{-5} $$\n$$ S = \\frac{1}{2} + \\frac{1}{8} + 2 \\cdot \\frac{1}{16} + 3 \\cdot \\frac{1}{32} = \\frac{1}{2} + \\frac{1}{8} + \\frac{1}{8} + \\frac{3}{32} $$\n$$ S = \\frac{1}{2} + \\frac{2}{8} + \\frac{3}{32} = \\frac{1}{2} + \\frac{1}{4} + \\frac{3}{32} $$\nTo sum these fractions, we use a common denominator of $32$:\n$$ S = \\frac{16}{32} + \\frac{8}{32} + \\frac{3}{32} = \\frac{16+8+3}{32} = \\frac{27}{32} $$\nSince $S = \\frac{27}{32} \\le 1$, the inequality holds. Such a tree can be constructed.\nVerdict: **Correct**.\n\n**E. $\\{2,2,2,2\\}$**\nThe multiset of depths is $D = \\{2,2,2,2\\}$. We calculate the sum:\n$$ S = 2^{-2} + 2^{-2} + 2^{-2} + 2^{-2} = 4 \\cdot 2^{-2} = 4 \\cdot \\frac{1}{4} = 1 $$\nSince $S = 1 \\le 1$, the inequality holds. A simple example of such a tree is a perfect binary tree of height $2$, which has $4$ leaves, all at depth $2$.\nVerdict: **Correct**.", "answer": "$$\\boxed{BDE}$$", "id": "3280782"}, {"introduction": "A tree's structure can be \"flattened\" into a linear sequence through traversals like pre-order, in-order, or post-order. But can we reverse the process? This algorithmic challenge asks you to reconstruct a tree's parent-child relationships using its post-order traversal and the depth of each node, a task central to fields like compiler design and data serialization. This exercise synthesizes your understanding of traversals and node properties into a practical reconstruction algorithm [@problem_id:3280807].", "problem": "You are given the post-order traversal of a rooted ordered tree and, for each node in the traversal sequence, its depth measured as the number of edges from the root. Using only the foundational definitions of a rooted tree, post-order traversal, and node depth, design an algorithm that reconstructs the parent of each node in the given traversal order. A rooted ordered tree is defined as a connected acyclic graph with a designated root such that each nodeâ€™s children are ordered. A post-order traversal is defined recursively: for a node, visit all of its children in order using post-order, and then visit the node itself. The depth of a node is defined as the number of edges on the unique simple path from the root to that node. Your program must validate the consistency of the given sequences with the definitions and return the parent array if valid, or an empty list if invalid.\n\nInput model for each test case:\n- A sequence of node identifiers $S$ given in post-order. Identifiers are arbitrary but, for the purposes of output representation, nodes are indexed by their position in $S$, that is, indices $0$ through $n-1$, where $n$ is the number of nodes.\n- A sequence of nonnegative integer depths $D$ of the same length as $S$, where $D[j]$ is the depth of $S[j]$.\n\nOutput specification:\n- For each test case, return a list $P$ of length $n$ where $P[j]$ equals the index of the parent of the node $S[j]$ within the traversal order, or $-1$ if $S[j]$ is the root.\n- If the input sequence does not represent a valid rooted ordered tree consistent with the given post-order and depth constraints, output the empty list $[]$ for that test case.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result is itself a comma-separated list enclosed in square brackets, with no spaces. For example, the output format must look like $[[p\\_0,p\\_1,\\dots,p\\_{n-1}],[q\\_0,q\\_1,\\dots],[\\dots]]$ on one line.\n\nScientific realism and fundamental base:\n- Use only the core definitions stated above and deduce the algorithmic properties needed to reconstruct the tree. Do not rely on unproven shortcut formulas.\n\nTest suite:\n- Case $1$ (general branching): $S=[0,1,2,3,4,5,6]$, $D=[2,2,1,2,2,1,0]$.\n- Case $2$ (single node): $S=[0]$, $D=[0]$.\n- Case $3$ (deep chain): $S=[0,1,2,3]$, $D=[3,2,1,0]$.\n- Case $4$ (invalid; no root at the end): $S=[0,1]$, $D=[1,1]$.\n\nYour program must process exactly these four cases internally and produce the final single-line output in the format described above.", "solution": "The user-provided problem is assessed as valid.\n\n### Step 1: Extract Givens\n- **Input Data**:\n    - A sequence of node identifiers $S$ in post-order traversal. Nodes are indexed by their position in $S$, from $0$ to $n-1$, where $n$ is the number of nodes.\n    - A sequence of non-negative integer depths $D$ of the same length as $S$, where $D[j]$ corresponds to the depth of the node at index $j$ in $S$.\n- **Required Output**:\n    - A list $P$ of length $n$, where $P[j]$ is the index of the parent of the node at index $j$. The parent of the root is $-1$.\n    - An empty list $[]$ if the input sequences $S$ and $D$ are inconsistent or do not represent a valid rooted ordered tree.\n- **Core Definitions**:\n    - **Rooted Ordered Tree**: A connected acyclic graph with a designated root, where each node's children are ordered.\n    - **Post-order Traversal**: For any node, recursively visit all its children's subtrees in their specified order, and finally visit the node itself.\n    - **Node Depth**: The number of edges on the unique simple path from the root to the node. The root's depth is $0$.\n- **Test Suite**:\n    - Case $1$: $S=[0,1,2,3,4,5,6]$, $D=[2,2,1,2,2,1,0]$.\n    - Case $2$: $S=[0]$, $D=[0]$.\n    - Case $3$: $S=[0,1,2,3]$, $D=[3,2,1,0]$.\n    - Case $4$: $S=[0,1]$, $D=[1,1]$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to a rigorous validation process.\n\n- **Scientific Grounding**: The problem is fundamentally based on established, formal definitions from graph theory and data structures, specifically concerning rooted ordered trees, post-order traversals, and node depths. These concepts are mathematically precise and form a sound basis for an algorithmic problem.\n- **Well-Posedness**: The problem is well-posed. The combination of a post-order traversal sequence and the depth of each node provides sufficient constraints to uniquely determine the parent-child relationships in the tree, if such a tree exists. The task is to deduce this structure and validate its existence.\n- **Objectivity**: The problem is stated in objective, formal language, free from ambiguity or subjective interpretation.\n- **Completeness and Consistency**: The problem provides all necessary definitions and constraints. A key property deducible from the definitions is that the root of any subtree is the last node visited in the post-order traversal of that subtree. Therefore, the root of the entire tree must be the last element of the sequence $S$, and its depth must be $0$. Let's test this against the provided cases:\n    - Case $1$: The last node index is $6$. $D[6] = 0$. Consistent.\n    - Case $2$: The last node index is $0$. $D[0] = 0$. Consistent.\n    - Case $3$: The last node index is $3$. $D[3] = 0$. Consistent.\n    - Case $4$: The last node index is $1$. $D[1] = 1$. This violates the definition, as the root must have depth $0$. The problem correctly identifies this case as invalid.\nThe problem is self-contained and internally consistent.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-defined algorithmic challenge grounded in the fundamental principles of data structures. The solution process may proceed.\n\n### Principle-Based Solution\nThe solution is derived by reasoning from the foundational definitions of post-order traversal and node depth.\n\nA post-order traversal sequence has the defining property that a parent node is always visited immediately after the traversals of all its children's subtrees are completed. This implies that for any node $v$, its parent $p$ must appear later in the post-order sequence. Consequently, if the nodes are indexed $0, 1, \\dots, n-1$ according to their appearance in the traversal $S$, the parent of the node at index $j$ must be a node at some index $k > j$.\n\nFurthermore, the depth definition dictates that for any node $v$ with parent $p$, their depths are related by $depth(v) = depth(p) + 1$.\n\nCombining these two properties provides a powerful method for reconstruction. If we process the traversal sequence $S$ in reverse order (from index $j = n-1$ down to $0$), we are effectively moving from parents to their descendants. At any point in this reverse scan, for a node at index $j$ with depth $D[j] = d$, its parent must be a node at some index $k > j$ with depth $D[k] = d-1$. The key insight is identifying which node at index $k$ is the correct parent.\n\nDue to the nested structure of subtrees in a post-order traversal, the correct parent for the node at index $j$ is the *most recently encountered* node to its right (i.e., at an index $k>j$) that has a depth of $d-1$. This \"most recent\" node represents the root of the smallest enclosing subtree at the parent's depth level.\n\nThis leads to the following algorithm:\n\n$1$. **Validation**: First, we perform initial consistency checks.\n    - The sequence must not be empty. Let $n$ be the number of nodes. If $n=0$, it is invalid under the problem's implicit assumption of at least one node.\n    - The last node in the traversal, $S[n-1]$, must be the root. Therefore, its depth $D[n-1]$ must be exactly $0$.\n    - All other nodes must be non-root nodes, so their depths $D[j]$ for $j < n-1$ must be greater than $0$.\n\n$2$. **Reconstruction**: We iterate from right to left, from $j = n-1$ down to $0$. We use a map, let's call it `last_at_depth`, to store the index of the most recently seen node for each depth level.\n    - Initialize an integer array $P$ of size $n$ with default values of $-1$.\n    - Initialize the map `last_at_depth`.\n    - Begin the loop for $j$ from $n-1$ down to $0$:\n        a. Let the current node's depth be $d = D[j]$.\n        b. If $d > 0$, the node must have a parent. The parent's depth must be $d-1$. We look for `last_at_depth[d-1]`.\n            i. If a parent at depth $d-1$ has not been seen yet (i.e., `d-1` is not a key in `last_at_depth`), the depth sequence is inconsistent with a valid tree structure. The input is invalid.\n            ii. Otherwise, the parent is the node at index `last_at_depth[d-1]`. We set $P[j] = \\text{last\\_at\\_depth}[d-1]$.\n        c. If $d=0$ (which should only be true for $j=n-1$), the node is the root and its parent remains $-1$.\n        d. Finally, we update the map with the current node's information: `last_at_depth[d] = j$. This establishes the current node as the potential parent for subsequent (leftward) nodes that are its children.\n\nIf the algorithm completes without finding any inconsistencies, the array $P$ holds the unique parent structure of the tree.\n\nLet us trace Case 1: $S=[0,1,2,3,4,5,6]$, $D=[2,2,1,2,2,1,0]$.\n- $n=7$. $D[6]=0$, which is valid for the root.\n- Initialize $P = [-1, -1, -1, -1, -1, -1, -1]$ and `last_at_depth = {}`.\n\n- $j=6$: Node index $6$, depth $D[6]=0$. This is the root. $P[6]$ remains $-1$. Update `last_at_depth[0] = 6$.\n- $j=5$: Node index $5$, depth $D[5]=1$. Parent must have depth $0$. Find `last_at_depth[0]`, which is $6$. Set $P[5] = 6$. Update `last_at_depth[1] = 5$.\n- $j=4$: Node index $4$, depth $D[4]=2$. Parent must have depth $1$. Find `last_at_depth[1]`, which is $5$. Set $P[4] = 5$. Update `last_at_depth[2] = 4$.\n- $j=3$: Node index $3$, depth $D[3]=2$. Parent must have depth $1$. Find `last_at_depth[1]`, which is $5$. Set $P[3] = 5$. Update `last_at_depth[2] = 3$.\n- $j=2$: Node index $2$, depth $D[2]=1$. Parent must have depth $0$. Find `last_at_depth[0]`, which is $6$. Set $P[2] = 6$. Update `last_at_depth[1] = 2$.\n- $j=1$: Node index $1$, depth $D[1]=2$. Parent must have depth $1$. Find `last_at_depth[1]`, which is $2$. Set $P[1] = 2$. Update `last_at_depth[2] = 1$.\n- $j=0$: Node index $0$, depth $D[0]=2$. Parent must have depth $1$. Find `last_at_depth[1]`, which is $2$. Set $P[0] = 2$. Update `last_at_depth[2] = 0$.\n\nThe final parent array is $P = [2, 2, 6, 5, 5, 6, -1]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef reconstruct_parent_array(S, D):\n    \"\"\"\n    Reconstructs the parent array of a rooted ordered tree from its post-order\n    traversal and node depths.\n\n    Args:\n        S (list): A sequence of node identifiers in post-order. For this problem,\n                  it's assumed to be [0, 1, ..., n-1].\n        D (list): A sequence of non-negative integer depths corresponding to S.\n\n    Returns:\n        list: A list P where P[j] is the parent index of node S[j], or -1 for the root.\n              Returns an empty list if the input is invalid.\n    \"\"\"\n    n = len(S)\n    if n == 0:\n        return []\n\n    # Validation: The last node in a post-order traversal must be the root,\n    # and the root's depth must be 0.\n    if D[n - 1] != 0:\n        return []\n\n    if n == 1:\n        return [-1]\n\n    # The parent array P, initialized with -1 for all nodes.\n    # P[j] will store the index of the parent of the node at index j.\n    P = np.full(n, -1, dtype=int)\n\n    # This dictionary maps a depth level to the index of the most recently\n    # seen node at that depth.\n    last_node_at_depth = {0: n - 1}\n\n    # Iterate from the second-to-last node down to the first.\n    for j in range(n - 2, -1, -1):\n        depth = D[j]\n        \n        # Validation: All non-root nodes must have a depth greater than 0.\n        if depth <= 0:\n            return []\n\n        parent_depth = depth - 1\n        \n        # Validation: A parent must exist at the required depth. If not, the\n        # depth sequence is inconsistent with a valid tree structure.\n        if parent_depth not in last_node_at_depth:\n            return []\n\n        parent_idx = last_node_at_depth[parent_depth]\n        P[j] = parent_idx\n        \n        # Record the current node as the most recently seen at its depth.\n        last_node_at_depth[depth] = j\n\n    return P.tolist()\n\n\ndef solve():\n    \"\"\"\n    Defines the test cases from the problem, solves them, and prints the\n    final output in the exact specified format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general branching)\n        (list(range(7)), [2, 2, 1, 2, 2, 1, 0]),\n        # Case 2 (single node)\n        (list(range(1)), [0]),\n        # Case 3 (deep chain)\n        (list(range(4)), [3, 2, 1, 0]),\n        # Case 4 (invalid; no root at the end)\n        (list(range(2)), [1, 1]),\n    ]\n\n    results = []\n    for s, d in test_cases:\n        result = reconstruct_parent_array(s, d)\n        results.append(result)\n\n    # Format the results into the required single-line string format.\n    # Example: [[-1],[1,2,3,-1]]\n    output_parts = []\n    for res in results:\n        if not res:\n            output_parts.append(\"[]\")\n        else:\n            output_parts.append(f\"[{','.join(map(str, res))}]\")\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n\n```", "id": "3280807"}]}