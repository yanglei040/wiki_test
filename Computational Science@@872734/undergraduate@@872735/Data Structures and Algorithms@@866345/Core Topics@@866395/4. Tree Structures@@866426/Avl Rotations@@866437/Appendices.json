{"hands_on_practices": [{"introduction": "To build a strong foundation, we begin by exploring the conditions that trigger AVL rotations in the simplest non-trivial case. This exercise asks you to consider all possible ways to insert just three keys into an empty tree. By analyzing how the insertion order affects the tree's structure and balance factors, you will derive the fundamental principle that governs when a rotation is necessary versus when the tree remains naturally balanced [@problem_id:3210827].", "problem": "Consider an empty Adelson-Velsky and Landis (AVL) tree, which is a binary search tree that maintains the invariant that for every node $v$, the absolute difference between the heights of its left and right subtrees is at most $1$. A rotation (single or double) is performed immediately after an insertion if some node’s balance factor, defined as the height of the left subtree minus the height of the right subtree, becomes $2$ or $-2$. Let the three distinct keys be real numbers $a$, $b$, and $c$ satisfying $a<b<c$. You insert the keys into the initially empty tree in some order, using standard binary search tree insertion with AVL rebalancing.\n\nTask:\n- Starting from these fundamental definitions, derive a necessary and sufficient characterization of those insertion orders of length $3$ that cause no rotations at any step of the insertion process.\n- Then, among all $3!$ insertion orders of $\\{a,b,c\\}$, compute the exact fraction (as a reduced rational number) of orders that produce no rotations.\n\nGive your final answer as a single reduced fraction. No rounding is required.", "solution": "The problem asks for a necessary and sufficient characterization of insertion orders of three distinct keys $\\{a, b, c\\}$ with $a<b<c$ into an initially empty AVL tree that do not cause any rotations, and for the fraction of such orders among all possible $3!$ permutations.\n\nLet the three distinct keys be denoted by the set $K = \\{a, b, c\\}$, where their values are ordered as $a < b < c$. The total number of possible insertion orders (permutations) is $3! = 6$. We must analyze the state of the AVL tree after each of the three insertions for every possible order.\n\nA rotation is triggered if and only if an insertion causes the balance factor of any node to become $2$ or $-2$. The balance factor of a node $v$, denoted $BF(v)$, is defined as the height of its left subtree minus the height of its right subtree, $BF(v) = H(L_v) - H(R_v)$. We adopt the standard definition for the height of a subtree: the height of an empty tree is $-1$, and the height of a non-empty node is $1 + \\max(H(L_v), H(R_v))$. A leaf node has height $0$.\n\nLet an arbitrary insertion order be $(k_1, k_2, k_3)$, where $\\{k_1, k_2, k_3\\} = \\{a, b, c\\}$.\n\nStep 1: Insertion of $k_1$.\nThe tree consists of a single node, the root $k_1$. Its height is $0$, and its balance factor is $H(\\text{null}) - H(\\text{null}) = -1 - (-1) = 0$. No rotation is possible.\n\nStep 2: Insertion of $k_2$.\nThe key $k_2$ is inserted as either the left or right child of $k_1$, according to the binary search tree property. The tree now consists of two nodes. The root $k_1$ has one child, and its other child pointer is null.\n- If $k_2 < k_1$, the tree is $k_2 \\leftarrow k_1$. $BF(k_1) = H(k_2) - H(\\text{null}) = 0 - (-1) = 1$.\n- If $k_2 > k_1$, the tree is $k_1 \\to k_2$. $BF(k_1) = H(\\text{null}) - H(k_2) = -1 - 0 = -1$.\nIn both scenarios, the absolute value of the balance factor of the root is $1$. All balance factors are within the allowed range $[-1, 1]$, so no rotation is triggered after the second insertion. The height of the tree is $1$.\n\nStep 3: Insertion of $k_3$.\nThis is the critical step where an imbalance can occur. An imbalance happens if the insertion of $k_3$ causes the height of a subtree to increase such that an ancestor's balance factor becomes $\\pm 2$. This occurs at the first ancestor (closest to the new leaf) whose balance factor was $\\pm 1$ and the insertion occurs in the taller subtree. In our case, the root $k_1$ has a balance factor of $\\pm 1$. An imbalance will occur if $k_3$ is inserted into the non-empty subtree of $k_1$, as this will increase its height from $0$ to $1$.\n\nWe derive the characterization by considering which of the keys $\\{a, b, c\\}$ is chosen as the first key, $k_1$.\n\nCase 1: The first key inserted is an extremum ($k_1 = a$ or $k_1 = c$).\nLet's assume $k_1=a$ (the minimum key). The remaining keys to be inserted are $b$ and $c$, both of which are greater than $a$.\n- After inserting $k_1=a$, the tree is $(a)$.\n- The second key, $k_2$ (either $b$ or $c$), is greater than $a$ and becomes the right child of $a$. The tree is $a \\to k_2$, and $BF(a) = -1$.\n- The third key, $k_3$ (the remaining key, also greater than $a$), will be inserted into the right subtree of $a$. This insertion increases the height of the right subtree of $a$ from $H(k_2)=0$ to $1$.\n- The new balance factor of $a$ will be $BF(a) = H(L_a) - H(R_a) = H(\\text{null}) - (1 + \\max(H(L_{k_2}), H(R_{k_2}))) = -1 - 1 = -2$.\n- This imbalance at the root node $a$ necessitates a rotation. This is true for both insertion orders starting with $a$: $(a, b, c)$ and $(a, c, b)$.\n\nSymmetrically, let's assume $k_1=c$ (the maximum key). The remaining keys are $a$ and $b$, both smaller than $c$.\n- After inserting $k_1=c$, the tree is $(c)$.\n- The second key, $k_2$ (either $a$ or $b$), is smaller than $c$ and becomes the left child of $c$. The tree is $k_2 \\leftarrow c$, and $BF(c) = 1$.\n- The third key, $k_3$ (the remaining key, also smaller than $c$), will be inserted into the left subtree of $c$. This increases the height of the left subtree of $c$ from $H(k_2)=0$ to $1$.\n- The new balance factor of $c$ will be $BF(c) = H(L_c) - H(R_c) = 1 - (-1) = 2$.\n- This imbalance at the root node $c$ necessitates a rotation. This is true for both insertion orders starting with $c$: $(c, a, b)$ and $(c, b, a)$.\n\nTherefore, if the first key inserted is an extremum (the smallest, $a$, or the largest, $c$), a rotation is unavoidable.\n\nCase 2: The first key inserted is the median ($k_1=b$).\n- After inserting $k_1=b$, the tree is $(b)$. $BF(b)=0$.\n- The second key, $k_2$, is either $a$ or $c$.\n    - If $k_2=a$, since $a<b$, the tree becomes $a \\leftarrow b$. $BF(b)=1$.\n    - If $k_2=c$, since $c>b$, the tree becomes $b \\to c$. $BF(b)=-1$.\n- The third key, $k_3$, is the remaining extremum.\n    - If the tree is $a \\leftarrow b$, we insert $k_3=c$. Since $c>b$, it becomes the right child of $b$. The final tree structure is $a \\leftarrow b \\to c$.\n    - If the tree is $b \\to c$, we insert $k_3=a$. Since $a<b$, it becomes the left child of $b$. The final tree structure is also $a \\leftarrow b \\to c$.\n- In both subcases, the final tree has $b$ as the root with left child $a$ and right child $c$. Let's check the balance factors in the final tree.\n    - $BF(a) = 0$ and $BF(c) = 0$ as they are leaves.\n    - $BF(b) = H(a) - H(c) = 0 - 0 = 0$.\n- At no point during the insertion process does any node's balance factor become $\\pm 2$. Thus, no rotations are performed. This is true for both insertion orders starting with $b$: $(b, a, c)$ and $(b, c, a)$.\n\nNecessary and Sufficient Characterization:\nFrom the analysis of all cases, an insertion order of the three keys $\\{a, b, c\\}$ with $a<b<c$ results in no rotations if and only if the first key inserted is the median key, $b$.\n\nComputing the Fraction:\nThe total number of possible insertion orders is the number of permutations of the three keys, which is $3! = 3 \\times 2 \\times 1 = 6$.\nThe orders are:\n1. $(a, b, c)$ - Rotation\n2. $(a, c, b)$ - Rotation\n3. $(b, a, c)$ - No Rotation\n4. $(b, c, a)$ - No Rotation\n5. $(c, a, b)$ - Rotation\n6. $(c, b, a)$ - Rotation\n\nThe number of insertion orders that cause no rotations is the number of permutations that start with the key $b$. Once $b$ is chosen as the first element, the remaining two keys, $a$ and $c$, can be arranged in $2! = 2$ ways. These two orders are $(b, a, c)$ and $(b, c, a)$.\n\nThe number of favorable outcomes is $2$.\nThe total number of possible outcomes is $6$.\nThe fraction of orders that produce no rotations is therefore $\\frac{2}{6}$.\nReducing this fraction to its simplest form gives $\\frac{1}{3}$.", "answer": "$$\\boxed{\\frac{1}{3}}$$", "id": "3210827"}, {"introduction": "Having explored how to avoid rotations, we now dive into the mechanics of how they are performed. This practice guides you through a specific sequence of insertions designed to trigger various types of rotations, including the more complex double rotations [@problem_id:3210713]. By manually tracking the balance factor of every node at each step, you will gain a concrete, procedural understanding of how the AVL algorithm identifies an imbalance and precisely which rotation is needed to restore the tree's height-balance invariant.", "problem": "You will use the core definitions of Adelson–Velsky and Landis (AVL) trees to analyze how rotations are triggered and how balance factors evolve during binary search tree insertions. Let the height of an empty child be defined as $-1$, the height of a node be $1 + \\max\\{\\text{height of left child}, \\text{height of right child}\\}$, and the balance factor of a node $v$ be $\\operatorname{bf}(v) = \\text{height(left}(v)) - \\text{height(right}(v))$. An AVL tree is balanced if every node has balance factor in $\\{-1, 0, 1\\}$. Upon insertion, a node $z$ triggers:\n- a Left–Left ($LL$) rotation if $\\operatorname{bf}(z) = +2$ and the insertion occurred in the left subtree of $z$'s left child,\n- a Right–Right ($RR$) rotation if $\\operatorname{bf}(z) = -2$ and the insertion occurred in the right subtree of $z$'s right child,\n- a Left–Right ($LR$) rotation if $\\operatorname{bf}(z) = +2$ and the left child of $z$ has $\\operatorname{bf} = -1$ (fix is a left rotation on the left child, then a right rotation on $z$),\n- a Right–Left ($RL$) rotation if $\\operatorname{bf}(z) = -2$ and the right child of $z$ has $\\operatorname{bf} = +1$ (fix is a right rotation on the right child, then a left rotation on $z$).\n\nConsider inserting the keys $\\{1,2,3,4,5,6,7\\}$ into an initially empty binary search tree in the specific order $\\langle 4, 6, 5, 2, 1, 3, 7 \\rangle$. This order forces a Right–Left ($RL$) rotation at node $4$ at the moment just after inserting key $5$ and before any rebalancing is performed at that step.\n\nFor step $t \\in \\{1,2,\\dots,7\\}$, let $V_t$ denote the set of nodes present immediately after the $t$-th insertion and before any rebalancing at that step, and let $\\operatorname{bf}_t^{-}(v)$ denote the balance factor of a node $v \\in V_t$ in that pre-rebalancing tree. Define the cumulative imbalance magnitude\n$$\nS \\;=\\; \\sum_{t=1}^{7} \\;\\sum_{v \\in V_t} \\left|\\operatorname{bf}_t^{-}(v)\\right|.\n$$\n\nTasks:\n- Using only the fundamental definitions above, argue why the given insertion order forces an $RL$ rotation at node $4$ at the moment just after inserting key $5$.\n- Compute $\\operatorname{bf}_t^{-}(v)$ for every $v \\in V_t$ at each step $t$ and identify all rotation triggers at their first unbalanced ancestors.\n- Evaluate the exact value of $S$.\n\nYour final answer must be the exact value of $S$ (a single integer). No rounding is required.", "solution": "The problem is valid as it is self-contained, scientifically grounded in the theory of AVL trees, and well-posed. The definitions, insertion sequence, and the quantity to be computed are all specified unambiguously, ensuring a unique and meaningful solution exists.\n\nThe solution proceeds in two parts. First, we will demonstrate why an RL rotation is forced at node $4$ after inserting key $5$. Second, we will trace the insertion of each of the $7$ keys, calculating the set of pre-rebalancing balance factors $\\operatorname{bf}_t^{-}(v)$ at each step $t$ and summing their absolute magnitudes to find the total cumulative imbalance $S$.\n\n### Argument for Right-Left (RL) Rotation\n\nWe begin with an empty tree.\n1.  Insert $4$: The tree is a single node, $4$. $h(4)=0$, $\\operatorname{bf}(4)=0$.\n2.  Insert $6$: Since $6 > 4$, $6$ becomes the right child of $4$. The tree is $4 \\rightarrow (\\text{right}) \\ 6$.\n    - $h(6) = 1 + \\max(-1, -1) = 0$.\n    - $h(4) = 1 + \\max(h(\\text{left}), h(6)) = 1 + \\max(-1, 0) = 1$.\n    - $\\operatorname{bf}(4) = h(\\text{left}) - h(6) = -1 - 0 = -1$. The tree is balanced.\n\n3.  Insert $5$: Since $5 > 4$, we go right to node $6$. Since $5 < 6$, we go left. $5$ is inserted as the left child of $6$. The structure before any rebalancing is $4 \\rightarrow (\\text{right}) \\ 6 \\rightarrow (\\text{left}) \\ 5$. Let's analyze the state just after this insertion, denoted by $t=3$.\n    - Let $v_4, v_5, v_6$ be the nodes with keys $4, 5, 6$.\n    - The height of the new leaf node is $h(v_5) = 0$. Its balance factor is $\\operatorname{bf}_3^{-}(v_5) = 0 - 0 = 0$.\n    - The height of its parent is $h(v_6) = 1 + \\max(h(v_5), h(\\text{empty})) = 1+\\max(0, -1) = 1$.\n    - The balance factor of $v_6$ is $\\operatorname{bf}_3^{-}(v_6) = h(v_5) - h(\\text{empty}) = 0 - (-1) = +1$.\n    - The height of the root node is $h(v_4) = 1 + \\max(h(\\text{empty}), h(v_6)) = 1+\\max(-1, 1) = 2$.\n    - The balance factor of $v_4$ is $\\operatorname{bf}_3^{-}(v_4) = h(\\text{empty}) - h(v_6) = -1 - 1 = -2$.\n\nThe first node, tracing up from the insertion point ($v_5$), with a balance factor outside the set $\\{-1, 0, 1\\}$ is $z=v_4$. Its balance factor is $\\operatorname{bf}_3^{-}(v_4) = -2$. The problem defines an RL rotation trigger for a node $z$ as: \"$\\operatorname{bf}(z) = -2$ and the right child of $z$ has $\\operatorname{bf} = +1$\". Here, $z=v_4$, its right child is $v_6$, and we have calculated $\\operatorname{bf}_3^{-}(v_6) = +1$.\nBoth conditions are met. Thus, the insertion of key $5$ forces an RL rotation at node $4$.\n\n### Step-by-Step Calculation of $S$\n\nWe now compute $S = \\sum_{t=1}^{7} \\sum_{v \\in V_t} |\\operatorname{bf}_t^{-}(v)|$. For each step $t$, we show the tree state before rebalancing, calculate the balance factors, sum their absolute values, and describe the rebalancing operation.\n\n**Step $t=1$: Insert $4$**\n-   Pre-rebalancing tree: A single node $4$.\n-   $V_1 = \\{4\\}$.\n-   $\\operatorname{bf}_1^{-}(4) = 0$.\n-   $\\sum_{v \\in V_1} |\\operatorname{bf}_1^{-}(v)| = |0| = 0$.\n-   Tree is balanced.\n\n**Step $t=2$: Insert $6$**\n-   Pre-rebalancing tree: $4 \\rightarrow (\\text{right}) \\ 6$.\n-   $V_2 = \\{4, 6\\}$.\n-   $\\operatorname{bf}_2^{-}(6) = 0$.\n-   $\\operatorname{bf}_2^{-}(4) = h(\\text{left}) - h(\\text{right}) = -1 - 0 = -1$.\n-   $\\sum_{v \\in V_2} |\\operatorname{bf}_2^{-}(v)| = |-1| + |0| = 1$.\n-   Tree is balanced.\n\n**Step $t=3$: Insert $5$**\n-   Pre-rebalancing tree: $4 \\rightarrow (\\text{right}) \\ 6 \\rightarrow (\\text{left}) \\ 5$.\n-   $V_3 = \\{4, 5, 6\\}$.\n-   $\\operatorname{bf}_3^{-}(5) = 0$.\n-   $\\operatorname{bf}_3^{-}(6) = h(5) - h(\\text{empty}) = 0 - (-1) = 1$.\n-   $\\operatorname{bf}_3^{-}(4) = h(\\text{empty}) - h(6) = -1 - 1 = -2$.\n-   $\\sum_{v \\in V_3} |\\operatorname{bf}_3^{-}(v)| = |-2| + |0| + |1| = 3$.\n-   Rotation: Node $4$ is unbalanced ($\\operatorname{bf}=-2$) with right child's $\\operatorname{bf}=+1$. An **RL rotation** is performed at node $4$. The tree becomes rooted at $5$, with left child $4$ and right child $6$.\n\n**Step $t=4$: Insert $2$**\n-   Tree after rebalancing from $t=3$: $5 \\rightarrow (\\text{left}) \\ 4, (\\text{right}) \\ 6$.\n-   Pre-rebalancing tree for $t=4$: $5 \\rightarrow (\\text{left}) \\ (4 \\rightarrow (\\text{left}) \\ 2), (\\text{right}) \\ 6$.\n-   $V_4 = \\{2, 4, 5, 6\\}$.\n-   $\\operatorname{bf}_4^{-}(2)=0$, $\\operatorname{bf}_4^{-}(6)=0$.\n-   $\\operatorname{bf}_4^{-}(4) = h(2) - h(\\text{empty}) = 0 - (-1) = 1$.\n-   $\\operatorname{bf}_4^{-}(5) = h(4) - h(6) = 1 - 0 = 1$.\n-   $\\sum_{v \\in V_4} |\\operatorname{bf}_4^{-}(v)| = |0| + |1| + |1| + |0| = 2$.\n-   Tree is balanced.\n\n**Step $t=5$: Insert $1$**\n-   Tree from $t=4$: $5 \\rightarrow \\big( (\\text{left}) \\ 4 \\rightarrow(\\text{left}) \\ 2 \\big), (\\text{right}) \\ 6$.\n-   Pre-rebalancing tree for $t=5$: $5 \\rightarrow \\big( (\\text{left}) \\ 4 \\rightarrow(\\text{left}) \\ (2 \\rightarrow \\text{left} \\ 1) \\big), (\\text{right}) \\ 6$.\n-   $V_5 = \\{1, 2, 4, 5, 6\\}$.\n-   $\\operatorname{bf}_5^{-}(1)=0$, $\\operatorname{bf}_5^{-}(6)=0$.\n-   $\\operatorname{bf}_5^{-}(2) = h(1) - h(\\text{empty}) = 0 - (-1) = 1$.\n-   $h(2)=1$, so $\\operatorname{bf}_5^{-}(4) = h(2) - h(\\text{empty}) = 1 - (-1) = 2$.\n-   $h(4)=2$, so $\\operatorname{bf}_5^{-}(5) = h(4) - h(6) = 2 - 0 = 2$.\n-   $\\sum_{v \\in V_5} |\\operatorname{bf}_5^{-}(v)| = |0| + |1| + |2| + |2| + |0| = 5$.\n-   Rotation: Node $4$ is the first unbalanced node ($\\operatorname{bf}=+2$). Insertion was in the left subtree of its left child. An **LL rotation** (a single right rotation) is performed at node $4$. The subtree rooted at $4$ becomes rooted at $2$, with left child $1$ and right child $4$. This fixes the balance for all ancestors, including node $5$.\n\n**Step $t=6$: Insert $3$**\n-   Tree after rebalancing from $t=5$: $5 \\rightarrow \\big( (\\text{left}) \\ (2 \\rightarrow (\\text{left}) \\ 1, (\\text{right}) \\ 4) \\big), (\\text{right}) \\ 6$.\n-   Pre-rebalancing tree for $t=6$: Insertion of $3$ ($3<5, 3>2, 3<4$) is as left child of $4$.\n-   $V_6 = \\{1, 2, 3, 4, 5, 6\\}$.\n-   $\\operatorname{bf}_6^{-}(1)=0$, $\\operatorname{bf}_6^{-}(3)=0$, $\\operatorname{bf}_6^{-}(6)=0$.\n-   $\\operatorname{bf}_6^{-}(4) = h(3) - h(\\text{empty}) = 0 - (-1) = 1$.\n-   $h(4)=1, h(1)=0$, so $\\operatorname{bf}_6^{-}(2) = h(1) - h(4) = 0 - 1 = -1$.\n-   $h(2)=2, h(6)=0$, so $\\operatorname{bf}_6^{-}(5) = h(2) - h(6) = 2 - 0 = 2$.\n-   $\\sum_{v \\in V_6} |\\operatorname{bf}_6^{-}(v)| = |0| + |-1| + |0| + |1| + |2| + |0| = 4$.\n-   Rotation: Node $5$ is unbalanced ($\\operatorname{bf}=+2$) and its left child ($2$) has $\\operatorname{bf}=-1$. An **LR rotation** is performed at node $5$. The final tree is rooted at $4$.\n\n**Step $t=7$: Insert $7$**\n-   Tree after rebalancing from $t=6$: rooted at $4$, left child $2$ (with children $1,3$), right child $5$ (with right child $6$).\n-   Pre-rebalancing tree for $t=7$: $7$ is inserted as right child of $6$.\n-   $V_7 = \\{1, 2, 3, 4, 5, 6, 7\\}$.\n-   $\\operatorname{bf}_7^{-}(1)=0, \\operatorname{bf}_7^{-}(3)=0, \\operatorname{bf}_7^{-}(7)=0$.\n-   $\\operatorname{bf}_7^{-}(2) = h(1) - h(3) = 0 - 0 = 0$.\n-   $\\operatorname{bf}_7^{-}(6) = h(\\text{empty}) - h(7) = -1 - 0 = -1$.\n-   $h(2)=1$. $h(6)=1$, so $\\operatorname{bf}_7^{-}(5) = h(\\text{empty}) - h(6) = -1 - 1 = -2$.\n-   $h(5)=2$, so $\\operatorname{bf}_7^{-}(4) = h(2) - h(5) = 1 - 2 = -1$.\n-   $\\sum_{v \\in V_7} |\\operatorname{bf}_7^{-}(v)| = |0| + |0| + |0| + |-1| + |-2| + |-1| + |0| = 4$.\n-   Rotation: Node $5$ is unbalanced ($\\operatorname{bf}=-2$). Insertion was in right subtree of right child. An **RR rotation** (a single left rotation) is performed at node $5$.\n\n**Final Calculation of S**\nThe total cumulative imbalance magnitude $S$ is the sum of the per-step sums:\n$$\nS = \\sum_{t=1}^{7} \\sum_{v \\in V_t} |\\operatorname{bf}_t^{-}(v)| = 0 + 1 + 3 + 2 + 5 + 4 + 4\n$$\n$$\nS = 19\n$$", "answer": "$$\\boxed{19}$$", "id": "3210713"}, {"introduction": "The final practice moves from analysis to synthesis, challenging you to implement the rebalancing logic yourself. Instead of treating single and double rotations as separate cases, this problem introduces a more elegant and unified approach: the tri-node restructure [@problem_id:3210793]. By implementing this powerful abstraction, you will see how all four imbalance scenarios can be resolved with a single, generalized algorithm, solidifying your understanding of the core principles that preserve the AVL tree's structure.", "problem": "Implement a self-balancing Binary Search Tree using the Adelson-Velsky and Landis (AVL) rotations with a single, unified tri-node restructuring logic that handles all four imbalance configurations in one block without separating single and double rotations. Begin from the following foundational base. A Binary Search Tree is a binary tree where for every node $v$ with key $k_v$, all keys in its left subtree are strictly less than $k_v$ and all keys in its right subtree are strictly greater than $k_v$. The height function $h(v)$ for a node $v$ is defined recursively as $h(v) = -1$ if $v$ is null, and $h(v) = 1 + \\max(h(v_{\\text{left}}), h(v_{\\text{right}}))$ otherwise. The balance factor $bf(v)$ is defined as $bf(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$. An AVL tree maintains $|bf(v)| \\le 1$ for every node $v$; upon insertion, if a node $a$ becomes imbalanced with $|bf(a)| \\ge 2$ (this is the minimal threshold at which a single local restructure can restore balance), rebalancing must be performed. Your program must implement AVL insertion using the Binary Search Tree insertion rule followed by height updates and a single unified restructuring step when needed as follows: let $a$ be the first ancestor on the insertion path where $|bf(a)| \\ge 2$, let $b$ be the taller child of $a$ (when $h(b_{\\text{left}}) = h(b_{\\text{right}})$, choose $b = a_{\\text{left}}$ if $h(a_{\\text{left}}) \\ge h(a_{\\text{right}})$, otherwise choose $b = a_{\\text{right}}$), and let $c$ be the taller child of $b$ with tie-breaking to the left when $h(c_{\\text{left}}) = h(c_{\\text{right}})$. Restore balance by a tri-node restructure that promotes the median of the keys among $\\{a, b, c\\}$ to the local root and reattaches the four subtrees to preserve the Binary Search Tree order and AVL height invariant. The rotation logic must be expressed as a single unified block that covers all four configurations ($LL$, $RR$, $LR$, $RL$) without explicitly distinguishing between single and double rotations. Duplicates should be ignored (the tree stores unique keys).\n\nYour program must apply insertion to each test case below and produce, for each case, the pre-order traversal of the final tree as a list of integers. The test suite is:\n1. Empty sequence: $[]$ (boundary condition)\n2. Left-Left imbalance: $[30, 20, 10]$\n3. Right-Right imbalance: $[10, 20, 30]$\n4. Left-Right imbalance: $[30, 10, 20]$\n5. Right-Left imbalance: $[10, 30, 20]$\n6. Multiple rebalances: $[10, 20, 30, 40, 50, 25]$\n7. Duplicates only: $[10, 10, 10]$ (boundary condition)\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in which each element corresponds to the pre-order traversal list for one test case, with no spaces anywhere in the entire line. For example, if there were three test cases yielding lists $[a_1, a_2]$, $[b_1]$, and $[]$, the program should print the single line $[[a_1,a_2],[b_1],[]]$.", "solution": "The problem requires the implementation of an Adelson-Velsky and Landis (AVL) tree, a self-balancing binary search tree. The key constraint is to use a single, unified tri-node restructuring logic for all four imbalance cases ($LL$, $RR$, $LR$, $RL$) that arise during insertion.\n\nFirst, we define the structure of a tree node. Each `Node` object must store a key, references to its left and right children, and its height within the tree. The height of a node is essential for determining the balance factor. The height $h(v)$ of a node $v$ is defined as $-1$ if $v$ is a null reference (leaf's child) and $1 + \\max(h(v_{\\text{left}}), h(v_{\\text{right}}))$ otherwise. A leaf node has height 0.\n\nThe insertion process begins as a standard binary search tree insertion. A new key is placed in a new leaf node, maintaining the BST property: for any node with key $k_v$, all keys in its left subtree are strictly less than $k_v$, and all keys in its right subtree are strictly greater. The problem specifies that duplicate keys are to be ignored.\n\nFollowing the insertion, we traverse back up the tree from the new leaf node to the root. At each node along this path, we perform two actions:\n$1$. Update the node's height. Since a new node has been added to one of its subtrees, its height may have increased.\n$2$. Check for imbalance. The balance factor $bf(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$ is calculated. The AVL property mandates that for every node $v$, $|bf(v)| \\le 1$. An insertion may violate this property.\n\nIf we find a node $a$ for which $|bf(a)| \\ge 2$, a restructuring is required. The problem states this must be done at the first such ancestor $a$ on the insertion path. This is the deepest node that has become imbalanced. A recursive implementation of insertion naturally handles this, as the check and restructure are performed on the return path of the recursion.\n\nThe core of the solution is the unified tri-node restructuring logic. This process is triggered at the imbalanced node $a$ and involves its child $b$ and grandchild $c$, which are identified as follows:\n- $a$: The first ancestor on the insertion path with $|bf(a)| \\ge 2$.\n- $b$: The taller child of $a$. Since $|bf(a)| \\ge 2$, one child is strictly taller than the other, making this choice unambiguous. If $bf(a) > 1$, $b = a_{\\text{left}}$; if $bf(a) < -1$, $b = a_{\\text{right}}$.\n- $c$: The taller child of $b$. The problem specifies a tie-break: if $h(b_{\\text{left}}) = h(b_{\\text{right}})$, the left child is chosen. Thus, if $h(b_{\\text{left}}) \\ge h(b_{\\text{right}})$, $c = b_{\\text{left}}$; otherwise, $c = b_{\\text{right}}$.\n\nThese three nodes, $\\{a, b, c\\}$, along with their four subtrees that are not themselves part of $\\{a, b, c\\}$, form the local substructure to be reconfigured. The unified restructuring does not depend on the specific case ($LL, RR, LR, RL$), but rather on the sorted order of the keys of $a$, $b$, and $c$.\n\nLet the nodes $\\{a, b, c\\}$ sorted by their keys be $\\{z, y, x\\}$, where $k_z < k_y < k_x$. The tri-node restructuring promotes the median-key node, $y$, to be the new local root. Node $z$ becomes the left child of $y$, and node $x$ becomes the right child of $y$. This configuration inherently preserves the binary search tree property for the three nodes.\n\nThe final step is to reattach the four original subtrees, which we can denote as $T_0, T_1, T_2, T_3$. These subtrees correspond to four key ranges: keys less than $k_z$, keys between $k_z$ and $k_y$, keys between $k_y$ and $k_x$, and keys greater than $k_x$. We can identify which of the four original subtrees corresponds to each range by examining the key of its root node relative to $k_z, k_y, k_x$. The reattachment is then performed according to the BST property:\n- $z_{\\text{left}} \\leftarrow T_0$ (keys $< k_z$)\n- $z_{\\text{right}} \\leftarrow T_1$ (keys $> k_z$ and $< k_y$)\n- $x_{\\text{left}} \\leftarrow T_2$ (keys $> k_y$ and $< k_x$)\n- $x_{\\text{right}} \\leftarrow T_3$ (keys $> k_x$)\n\nAfter re-linking the nodes and subtrees, the heights of $z$, $x$, and finally $y$ must be recomputed in that order to reflect the new structure. The node $y$, being the new root of the restructured subtree, is returned to the parent in the recursive insertion call, completing the rebalancing.\n\nThis entire restructuring process constitutes a single block of logic. It correctly handles all four imbalance configurations by abstracting the rotation into a general operation of re-sorting three nodes and their four associated subtrees, thus fulfilling the problem's primary constraint.\n\nFinally, to produce the required output, a pre-order traversal is implemented. This traversal visits the current node, then its left subtree, then its right subtree, collecting the keys in a list. This is performed for each test case provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\n\n# It's good practice to increase recursion limit for recursive data structures.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"Node class for the AVL tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 0  # Height of a leaf node is 0\n\nclass AVLTree:\n    \"\"\"AVL tree implementation with a unified tri-node restructuring logic.\"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def get_height(self, node):\n        \"\"\"Returns the height of a node, -1 for None.\"\"\"\n        if not node:\n            return -1\n        return node.height\n\n    def get_balance(self, node):\n        \"\"\"Returns the balance factor of a node.\"\"\"\n        if not node:\n            return 0\n        return self.get_height(node.left) - self.get_height(node.right)\n\n    def insert(self, key):\n        \"\"\"Public method to insert a key into the tree.\"\"\"\n        self.root = self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper function for insertion.\"\"\"\n        # 1. Standard BST insertion\n        if not node:\n            return Node(key)\n        elif key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n            node.right = self._insert(node.right, key)\n        else:\n            return node  # Duplicates are ignored\n\n        # 2. Update height of the ancestor node\n        node.height = 1 + max(self.get_height(node.left), self.get_height(node.right))\n\n        # 3. Get the balance factor\n        balance = self.get_balance(node)\n\n        # 4. If the node becomes unbalanced, then trigger restructuring\n        if abs(balance) > 1:\n            return self._restructure(node)\n\n        return node\n\n    def _restructure(self, a):\n        \"\"\"Performs a unified tri-node restructuring.\"\"\"\n        # Identify nodes b and c as per the problem description\n        if self.get_balance(a) > 1:\n            b = a.left\n        else: # balance < -1\n            b = a.right\n\n        if self.get_height(b.left) >= self.get_height(b.right):\n            c = b.left\n        else:\n            c = b.right\n\n        # Sort nodes a, b, c by key to find the median\n        nodes_p = [a, b, c]\n        z, y, x = sorted(nodes_p, key=lambda n: n.key)\n\n        # Identify the four subtrees T0, T1, T2, T3\n        T0, T1, T2, T3 = None, None, None, None\n        \n        # Collect all children of a, b, c\n        all_children = []\n        for v in nodes_p:\n            all_children.append(v.left)\n            all_children.append(v.right)\n            \n        # The four subtrees are the children that are not a, b, or c themselves\n        for t in all_children:\n            if t not in nodes_p:\n                if t is None:\n                    continue\n                # Assign subtrees to T0-T3 based on their key range\n                if t.key < z.key:\n                    T0 = t\n                elif z.key < t.key < y.key:\n                    T1 = t\n                elif y.key < t.key < x.key:\n                    T2 = t\n                else: # t.key > x.key\n                    T3 = t\n\n        # Perform the restructuring\n        # The median node y becomes the new root of this local subtree\n        y.left = z\n        y.right = x\n        \n        # Re-attach the four subtrees\n        z.left = T0\n        z.right = T1\n        x.left = T2\n        x.right = T3\n\n        # Update heights of the modified nodes, from bottom-up\n        z.height = 1 + max(self.get_height(z.left), self.get_height(z.right))\n        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))\n        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))\n        \n        # Return the new root of the balanced subtree\n        return y\n\n    def preorder(self):\n        \"\"\"Returns the pre-order traversal of the tree.\"\"\"\n        result = []\n        self._preorder_recursive(self.root, result)\n        return result\n\n    def _preorder_recursive(self, node, result):\n        if node:\n            result.append(node.key)\n            self._preorder_recursive(node.left, result)\n            self._preorder_recursive(node.right, result)\n\ndef solve():\n    test_cases = [\n        [],\n        [30, 20, 10],\n        [10, 20, 30],\n        [30, 10, 20],\n        [10, 30, 20],\n        [10, 20, 30, 40, 50, 25],\n        [10, 10, 10],\n    ]\n\n    results = []\n    for keys in test_cases:\n        tree = AVLTree()\n        for key in keys:\n            tree.insert(key)\n        results.append(tree.preorder())\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join(str(r).replace(' ', '') for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3210793"}]}