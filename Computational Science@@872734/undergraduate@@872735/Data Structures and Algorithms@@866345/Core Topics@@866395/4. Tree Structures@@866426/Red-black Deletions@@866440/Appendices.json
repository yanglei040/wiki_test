{"hands_on_practices": [{"introduction": "Mastering the theory of red-black tree deletions is one thing, but true understanding comes from practice. The fix-up algorithm, which can seem daunting, often resolves in simple ways. This first exercise explores a common and straightforward scenario where deleting a black node is made simple because its replacement is a red node. This practice demonstrates how the \"extra black\" property is absorbed in a single step, restoring the tree's balance with just one color change and no rotations [@problem_id:3265805].", "problem": "Consider a Red-Black Tree (RBT) that stores distinct integer keys and uses the canonical deletion algorithm that removes a node by splicing out its in-order successor when the node has two children, followed by the standard fix-up based solely on the RBT axioms. All missing children are the sentinel leaf $\\mathsf{NIL}$, which is colored black.\n\nYou are given the following RBT, where the root is the node $x$ with key $20$ and color black. The left subtree of $x$ is as follows:\n- Node with key $10$ colored black, whose left child is key $5$ colored black (both of whose children are $\\mathsf{NIL}$) and whose right child is key $15$ colored black (both of whose children are $\\mathsf{NIL}$).\n\nThe right subtree of $x$ is as follows:\n- Node with key $30$ colored black, whose left child is key $25$ colored black and whose right child is key $35$ colored black.\n- The node with key $25$ has left child $\\mathsf{NIL}$ and right child key $27$ colored red (both of whose children are $\\mathsf{NIL}$).\n- The node with key $35$ has left child $\\mathsf{NIL}$ and right child key $37$ colored red (both of whose children are $\\mathsf{NIL}$).\n\nAssume this tree satisfies all Red-Black Tree axioms. Now delete the node $x$ (key $20$) using the canonical Red-Black Tree deletion procedure described above. In particular, when a node has two children, its in-order successor $y$ is spliced out and moved to the deleted node’s position, and fix-up is performed only if the deleted physical node had black color. This scenario is constructed so that the in-order successor of $x$ is a strict grandchild of $x$, and moving it to $x$’s position causes that grandchild to become the new parent of $x$’s former children.\n\nLet $R$ be the total number of rotations (left or right) executed by the deletion and all subsequent fix-up steps, and let $K$ be the total number of recolor operations that actually change a node’s color bit during the deletion and all subsequent fix-up steps. Define $C = R + K$.\n\nCompute $C$. Your answer must be a single real-valued number. If you need to round, round to four significant figures; however, in this instance no rounding is necessary.", "solution": "The problem will be solved by first validating its premises and then executing the canonical Red-Black Tree (RBT) deletion algorithm as specified.\n\n### Problem Validation\n\nThe problem asks to compute the number of rotations and color changes during the deletion of a node from a given RBT.\n\nThe initial state of the tree is described as follows:\n- Root `x`: key $20$, color black.\n- Left subtree of `x`: Node with key $10$ (black), whose left child is key $5$ (black) and right child is key $15$ (black).\n- Right subtree of `x`: Node with key $30$ (black), whose left child is key $25$ (black) and right child is key $35$ (black). The node with key $25$ has a right child with key $27$ (red). The node with key $35$ has a right child with key $37$ (red). All other children are the sentinel $\\mathsf{NIL}$ node, colored black.\n\nBefore proceeding, we must verify that this initial configuration is a valid RBT. The RBT axioms are:\n1.  Every node is either red or black. (Satisfied by description).\n2.  The root is black. (Node $20$ is black, satisfied).\n3.  Every leaf ($\\mathsf{NIL}$) is black. (Satisfied by description).\n4.  If a node is red, then both its children are black. The red nodes are $27$ and $37$. Their children are all $\\mathsf{NIL}$ (black), so this is satisfied.\n5.  For each node, all simple paths from the node to descendant leaves contain the same number of black nodes (the black-height). The black-height of a node is the number of black nodes on any simple path from the node (but not including it) to a descendant leaf. Let's verify this for the root (key 20): The path to the leftmost leaf is $20 \\to 10(\\text{B}) \\to 5(\\text{B}) \\to \\mathsf{NIL}$. The black nodes on this path, excluding the root, are nodes 10 and 5, so the black-height is 2. Let's check another path: $20 \\to 30(\\text{B}) \\to 25(\\text{B}) \\to 27(\\text{R}) \\to \\mathsf{NIL}$. The black nodes are 30 and 25, so the black-height is also 2. Checking all paths confirms a uniform black-height of 2. The property holds.\n\nThe initial tree is a valid RBT. The problem specifies using the \"canonical deletion algorithm\", but includes a description that is potentially contradictory: \"...moving it [the successor] to x's position causes that grandchild to become the new parent of x's former children.\" The canonical algorithm involves copying the successor's *data* into the node to be deleted and then splicing out the successor node from its original position. The successor *node* itself does not move to the deleted node's position. We will adhere to the \"canonical\" instruction and treat the subsequent sentence as an imprecise description of the process. The problem is thus deemed valid and solvable under this interpretation.\n\n### Deletion Procedure\n\nLet the node to be deleted be $z$. Here, $z$ is the node with key $20$.\nThe initial tree is:\n$$\n\\begin{array}{c}\n20(\\text{B}) \\\\\n/ \\quad \\setminus \\\\\n10(\\text{B}) \\quad 30(\\text{B}) \\\\\n/ \\quad \\setminus \\quad / \\quad \\setminus \\\\\n5(\\text{B}) \\quad 15(\\text{B}) \\quad 25(\\text{B}) \\quad 35(\\text{B}) \\\\\n\\qquad \\qquad \\qquad \\setminus \\qquad \\setminus \\\\\n\\qquad \\qquad \\qquad 27(\\text{R}) \\quad 37(\\text{R})\n\\end{array}\n$$\n\n1.  **Identify Node for Splicing:** Since node $z$ (key $20$) has two children, we must find its in-order successor, let's call it $y$. The successor is the node with the minimum key in $z$'s right subtree. The right subtree is rooted at $30$. The minimum key is found by following left child pointers from $30$, which leads to the node with key $25$. Thus, $y$ is the node with key $25$.\n\n2.  **Transplant Data:** The canonical algorithm copies the key and satellite data of the successor $y$ into the node $z$. The color of $z$ is not changed.\n    - `` `z.key = y.key` `` $\\implies$ The node with original key $20$ now has key $25$. It remains black.\n\n3.  **Physical Deletion:** The node that is physically removed (spliced out) from the tree is the successor node, $y$ (the original node with key $25$). Let's track the properties of this node $y$:\n    - `y.key` is $25$.\n    - `y.color` is black.\n    - Node $y$ has a right child, let's call it `` `x_fixup` ``, which is the node with key $27$ and color red. `y` has no left child ($\\mathsf{NIL}$).\n\n4.  **Splicing:** Node $y$ is removed by linking its parent (node $30$) to its child (`` `x_fixup` ``, node $27$). Since $y$ was the left child of $30$, the node $27$ becomes the new left child of the node $30$.\n\nThe tree structure immediately after the splice, but before the fix-up procedure, is:\n$$\n\\begin{array}{c}\n25(\\text{B}) \\\\\n/ \\quad \\setminus \\\\\n10(\\text{B}) \\quad 30(\\text{B}) \\\\\n/ \\quad \\setminus \\quad / \\quad \\setminus \\\\\n5(\\text{B}) \\quad 15(\\text{B}) \\quad 27(\\text{R}) \\quad 35(\\text{B}) \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad \\setminus \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad 37(\\text{R})\n\\end{array}\n$$\n\n### Fix-Up Procedure\n\nThe physically removed node $y$ (original key $25$) was black. This violates RBT property 5 (black-height) for any path that passed through the removed node. Therefore, a fix-up procedure must be called. The procedure (`` `RB-DELETE-FIXUP` ``) is invoked on the node that replaced $y$, which is `` `x_fixup` `` (the node with key $27$).\n\nThe core idea of the fix-up is that the position of `` `x_fixup` `` now has an \"extra black\". The standard procedure handles this based on the color of `` `x_fixup` ``.\n\n- The node `` `x_fixup` `` (key $27$) is **red**.\n- The standard fix-up algorithm (e.g., from CLRS) first checks if the node `` `x_fixup` `` itself is red. If it is, the fix-up is simple: the node can absorb the \"extra black\" by being colored black.\n- The main loop of the fix-up procedure has the condition `` `while x_fixup != root and x_fixup.color == BLACK` ``.\n- In our case, `x_fixup.color` is red. The condition is false, and the `while` loop is not entered at all.\n- Consequently, no rotations are performed. The number of rotations, $R$, is $0$.\n- After the loop, the algorithm executes the final step: `x_fixup.color = BLACK`. The node with key $27$, which was red, is now colored black. This is a change of color.\n\n### Counting Operations\n\n- **Rotations ($R$):** The fix-up `while` loop was not entered. No rotations were performed.\n  $$ R = 0 $$\n- **Color Changes ($K$):** The color of the node with key $27$ was changed from red to black. This is the only operation that changes a node's color bit.\n  $$ K = 1 $$\n\nThe final valid RBT is:\n$$\n\\begin{array}{c}\n25(\\text{B}) \\\\\n/ \\quad \\setminus \\\\\n10(\\text{B}) \\quad 30(\\text{B}) \\\\\n/ \\quad \\setminus \\quad / \\quad \\setminus \\\\\n5(\\text{B}) \\quad 15(\\text{B}) \\quad 27(\\text{B}) \\quad 35(\\text{B}) \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad \\setminus \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad 37(\\text{R})\n\\end{array}\n$$\nAll RBT properties are satisfied in this final tree.\n\n### Final Calculation\n\nThe problem asks for $C = R + K$.\n$$ C = 0 + 1 = 1 $$", "answer": "$$\\boxed{1}$$", "id": "3265805"}, {"introduction": "Building on the previous exercise, we now tackle a more involved case that requires the fix-up algorithm to perform several steps. In this problem, the deletion of the tree's median key initiates a fix-up where the \"extra black\" must be propagated up the tree to a parent node. This exercise provides critical practice with the iterative cases of the deletion algorithm, reinforcing how the black-height property is systematically restored when the initial fix is not immediately resolved [@problem_id:3265764].", "problem": "You are given a concrete red-black binary search tree whose keys are distinct integers. All external leaves (sentinels $\\mathsf{NIL}$) are black. The tree satisfies the red-black properties: the root is black, every red node has black children, and every path from a node to any descendant $\\mathsf{NIL}$ has the same number of black nodes. The tree is specified as follows (each node is annotated with its color in parentheses):\n\n- Root: $15$ (black)\n  - Left child: $9$ (black)\n    - Left child: $5$ (red)\n      - Left child: $3$ (black)\n      - Right child: $7$ (black)\n    - Right child: $12$ (red)\n      - Left child: $11$ (black)\n      - Right child: $13$ (black)\n  - Right child: $21$ (black)\n    - Left child: $18$ (red)\n      - Left child: $17$ (black)\n      - Right child: $19$ (black)\n    - Right child: $25$ (red)\n      - Left child: $23$ (black)\n      - Right child: $27$ (black)\n\nTasks:\n- Using only the foundational definitions of red-black trees (binary search tree ordering, red-black coloring properties, and the standard red-black deletion procedure including successor replacement, rotations, and recolorings), first identify the median key of the set of stored keys and then delete this median from the tree using the standard red-black deletion algorithm (as presented in canonical sources such as Cormen–Leiserson–Rivest–Stein).\n- After all necessary structural changes and fix-up operations (rotations and recolorings) are performed to restore the red-black properties, determine the key stored at the root of the resulting red-black tree.\n\nAnswer format:\n- Provide only the final root key as a single exact integer. No rounding is required. Do not include any units or additional text.", "solution": "The problem requires us to perform a deletion operation on a given red-black tree and determine the key of the new root node. The process involves first identifying the median of all keys in the tree, then deleting the node with that key using the standard red-black tree deletion algorithm, and finally reporting the key at the root of the modified tree.\n\nFirst, we validate the provided tree structure to ensure it conforms to the properties of a red-black tree and a binary search tree.\nThe keys are: $3, 5, 7, 9, 11, 12, 13, 15, 17, 18, 19, 21, 23, 25, 27$.\nThe structure is given as:\n- Root: $15$ (black)\n  - Left child: $9$ (black)\n    - Left child: $5$ (red) -> children $3$ (black), $7$ (black)\n    - Right child: $12$ (red) -> children $11$ (black), $13$ (black)\n  - Right child: $21$ (black)\n    - Left child: $18$ (red) -> children $17$ (black), $19$ (black)\n    - Right child: $25$ (red) -> children $23$ (black), $27$ (black)\nThe binary search tree property holds for all nodes. The root is black. All red nodes ($5, 12, 18, 25$) have black children. The black-height (number of black nodes on any simple path from a node, not including the node itself, to a descendant leaf) is uniform. For the root $15$, the black-height is $2$ for all paths (e.g., path through $3$: $9(\\text{B}) \\rightarrow 5(\\text{R}) \\rightarrow 3(\\text{B}) \\rightarrow \\mathsf{NIL}$, black nodes are $9, 3$). The given tree is a valid red-black tree.\n\nThe first task is to identify the median key. The set of keys, sorted in ascending order, is:\n$$S = \\{3, 5, 7, 9, 11, 12, 13, 15, 17, 18, 19, 21, 23, 25, 27\\}$$\nThe number of keys is $|S| = 15$. For a set with an odd number of elements, the median is the element at position $\\frac{n+1}{2}$. Here, it is the $\\frac{15+1}{2} = 8$-th element.\nCounting through the sorted set, the 8th key is $15$. Therefore, we must delete the node with key $15$.\n\nThe node to be deleted, let's call it $z$, is the root of the tree. Node $z$ has two children (nodes $9$ and $21$). The standard binary search tree deletion procedure for a node with two children requires replacing it with its in-order successor, and then deleting the successor node from its original position.\nThe in-order successor of a node is the node with the smallest key in its right subtree. The right subtree of node $15$ is rooted at node $21$. To find the minimum key in this subtree, we follow the left-child pointers starting from node $21$: $21 \\rightarrow 18 \\rightarrow 17$. The in-order successor is the node with key $17$. Let's call this successor node $y$.\n\nThe deletion algorithm proceeds as follows:\n1.  The key of the successor node $y$ (which is $17$) is copied into the node $z$ (the root). The root node's key is now $17$, but its color remains black.\n2.  The problem is now reduced to deleting the original successor node $y$ (the node with key $17$) from the tree.\n\nLet's examine the node $y$ to be physically removed. Its key is $17$, its color is black, and its parent is node $18$. Node $17$ has no children (both its children are $\\mathsf{NIL}$ leaves).\nWhen we remove node $y$, we replace it with one of its children. We can choose its right child, which is a $\\mathsf{NIL}$ node. Let's call this replacement node $x$. So, $x$ is a $\\mathsf{NIL}$ node.\nThe original color of the deleted node $y$ was black. Removing a black node from the tree disrupts the red-black property that all paths from a node to its descendant leaves must have the same number of black nodes (property 5). To restore this property, we must run the `RB-DELETE-FIXUP` procedure on the node $x$. Node $x$ is considered to carry an \"extra black\".\n\nThe `RB-DELETE-FIXUP` procedure for $x$ is as follows. Initially, $x$ is the $\\mathsf{NIL}$ node that replaced node $17$. The parent of $x$, denoted $p(x)$, is node $18$. Since $x$ is not the root and is \"doubly black\", we enter a loop.\n\n**Iteration 1:**\n-   $x$ is the left child of its parent, $p(x) = 18$.\n-   We identify the sibling of $x$, denoted $w$. $w$ is the right child of node $18$, which is the node with key $19$.\n-   The original color of $w$ (node $19$) is black. This corresponds to Case 2, 3, or 4 of the CLRS deletion algorithm.\n-   We check the colors of $w$'s children. Both children of node $19$ are $\\mathsf{NIL}$ leaves, which are black.\n-   This situation matches **Case 2**: The sibling $w$ is black, and both of $w$'s children are black.\n-   The actions for Case 2 are:\n    1.  Recolor $w$ to red. So, node $19$ becomes red.\n    2.  Move the \"extra black\" up the tree by setting $x = p(x)$. So, $x$ now points to node $18$.\n-   The loop condition (`x` is not root and is \"doubly black\") is now re-evaluated for the new $x$ (node $18$). The original color of node $18$ was red. When the \"extra black\" moves to a red node, the loop terminates. The red-and-black node simply becomes black, absorbing the extra blackness and restoring the black-height property for all paths passing through it.\n\n-   The `RB-DELETE-FIXUP` procedure has a final step after the loop: it sets the color of the current node $x$ to black. In our case, the loop terminated with $x$ pointing to node $18$. Therefore, node $18$, which was originally red, is recolored to black.\n\nLet's summarize the changes to the tree:\n1.  The key of the root node is changed from $15$ to $17$. Its color remains black.\n2.  The node with key $17$ is physically removed.\n3.  The node with key $19$ is recolored from black to red.\n4.  The node with key $18$ is recolored from red to black.\nNo rotations were performed.\n\nThe final state of the tree structure is:\n- Root: $17$ (black)\n  - Left child: $9$ (black)\n    - Left child: $5$ (red)\n    - Right child: $12$ (red)\n  - Right child: $21$ (black)\n    - Left child: $18$ (black)\n      - Right child: $19$ (red)\n    - Right child: $25$ (red)\n\nAll red-black properties are satisfied in the new tree. The root is black. Every red node ($5, 12, 19, 25$) has black children. The black-height from the root is still $2$ for all paths.\n\nThe problem asks for the key stored at the root of the resulting red-black tree. After the deletion and fix-up operations, the root node contains the key of the successor of the original median, which is $17$.", "answer": "$$\\boxed{17}$$", "id": "3265764"}, {"introduction": "The final practice shifts our perspective from executing the algorithm to analyzing its fundamental behavior. Instead of performing a deletion, you are challenged to identify which nodes in a tree could be deleted without triggering any rebalancing operations (rotations or color changes) at all. This exercise deepens your understanding of *why* the fix-up procedure is necessary by forcing you to define the exact conditions under which it can be avoided, promoting a more profound grasp of red-black tree mechanics and efficiency [@problem_id:3265780].", "problem": "You are given a pointer-based red-black tree with $n$ internal nodes, using the standard model with a single sentinel $\\mathsf{NIL}$ leaf that is shared and treated as a black leaf child of every missing subtree. Every internal node stores a key, pointers to left and right children, and a color bit in $\\{\\text{red},\\text{black}\\}$. The red-black tree satisfies the standard five properties: the root is black, all $\\mathsf{NIL}$ leaves are black, every red node has only black children, and all root-to-$\\mathsf{NIL}$ paths have equal black-height. Consider the standard deletion algorithm that, when deleting a node $x$, uses the usual in-order successor reduction to a case where at most one non-$\\mathsf{NIL}$ child is removed, and then potentially performs a fix-up consisting of rotations and recolorings to restore the red-black properties.\n\nDefine a node $x$ to be zero-fix-up deletable if, when the standard deletion algorithm is applied to delete $x$, the algorithm performs zero rotations and zero color changes. Pointer reassignments needed to splice out $x$ do not count as rotations or color changes.\n\nDesign an algorithm that, given the root of the red-black tree and without any preprocessed or augmented metadata, either returns a pointer to a zero-fix-up deletable node (if one exists) or correctly reports that none exists. Your algorithm may inspect node fields (color and child pointers) and traverse pointers arbitrarily. The unit-cost model is used where each field read or pointer traversal costs $1$, and arithmetic on loop counters is free. Derive, from first principles and from the defining properties of red-black trees and the standard deletion algorithm, an asymptotically tight bound for the worst-case running time of the best possible algorithm for this task as a function of $n$.\n\nExpress your final answer as a single asymptotic expression in standard Big-Theta notation in terms of $n$. No rounding is needed.", "solution": "The problem asks for an algorithm to find a \"zero-fix-up deletable\" node in a given red-black tree and to determine the asymptotically tight worst-case complexity of the best possible such algorithm.\n\n### Step 1: Characterizing Zero-Fix-Up Deletable Nodes\n\nFirst, we must precisely characterize what makes a node \"zero-fix-up deletable\". This is defined as a node whose deletion via the standard algorithm involves zero rotations and zero color changes.\n\nThe standard deletion algorithm for a node $x$ proceeds in two stages:\n1.  **Splicing**: A node $y$ is physically removed (spliced out) from the tree structure. If the node to be deleted, $x$, has two non-$\\mathsf{NIL}$ children, the algorithm finds its in-order successor, copies the successor's data into $x$, and then deletes the successor node. The successor, by definition, has no left child. Thus, the problem is reduced to deleting a node $y$ that has at most one non-$\\mathsf{NIL}$ child. If $x$ already has at most one non-$\\mathsf{NIL}$ child, then $y$ is $x$ itself.\n2.  **Fix-up**: After $y$ is spliced out, its child (which can be $\\mathsf{NIL}$) takes its place. The fix-up procedure (a series of rotations and recolorings) is invoked if and only if the spliced-out node $y$ was black.\n\nThe removal of a black node $y$ violates the red-black property that all paths from a given node to its descendant leaves contain the same number of black nodes (property 4). Specifically, any path that passed through $y$ now has one fewer black node. The fix-up procedure is designed to restore this property. Crucially, if the spliced-out node $y$ is red, no red-black properties are violated:\n-   Property 1 (root is black): A red node cannot be the root.\n-   Property 2 ($\\mathsf{NIL}$ is black): Unaffected.\n-   Property 3 (red nodes have black children): The parent of the red node $y$ must be black. The child replacing $y$ is also black (since a red node's children must be black), preserving this property for the parent of $y$.\n-   Property 4 (black-height): Removing a red node does not alter the number of black nodes on any path.\n\nTherefore, the fix-up procedure is skipped entirely, meaning zero rotations and zero color changes occur, if and only if the physically spliced-out node $y$ is red.\n\nLet's define a \"removable red node\" as a red node that has at most one non-$\\mathsf{NIL}$ child. This is precisely the condition for a node to be red and to be the one physically spliced out.\n\nCombining these observations, a node $x$ is zero-fix-up deletable if and only if one of the following two conditions holds:\n1.  $x$ has at most one non-$\\mathsf{NIL}$ child, and $x$ is red. (In this case, $y=x$.)\n2.  $x$ has two non-$\\mathsf{NIL}$ children, and its in-order successor, $y$, is red. (The successor $y$ is guaranteed to have no left child, so it has at most one non-$\\mathsf{NIL}$ child.)\n\nIn both cases, the search for a zero-fix-up deletable node $x$ reduces to finding a node $x$ that is either itself a removable red node or whose in-order successor is a removable red node.\n\n### Step 2: Designing an Optimal Algorithm (Upper Bound)\n\nThe task is to find a node $x$ that fulfills the derived conditions. A naive approach would be to iterate through all $n$ nodes, and for each node $x$, check if it's zero-fix-up deletable. Checking if $x$ itself is a removable red node takes $O(1)$ time. However, if $x$ has two children, we must find its successor, which can take $O(\\log n)$ time in a red-black tree (by traversing the left spine of the right subtree). This leads to an overall worst-case complexity of $O(n \\log n)$.\n\nWe can devise a more efficient algorithm that runs in linear time. The key is to use a single pass, for instance a post-order traversal, and augment the recursive calls to return necessary information to the parent. Let the recursive function for a subtree rooted at node `curr` return a tuple containing:\n1.  A pointer to a zero-fix-up deletable node if one is found within the subtree.\n2.  A pointer to the node with the minimum key in the subtree.\n3.  A pointer to the node with the maximum key in the subtree.\n\nThe algorithm proceeds as follows:\n`function find_zfd_postorder(curr)`:\n-   **Base Case**: If `curr` is $\\mathsf{NIL}$, return `(null, null, null)`.\n-   **Recursive Step**:\n    1.  Recursively call on the left child: `(zfd_l, min_l, max_l) = find_zfd_postorder(curr.left)`.\n    2.  If `zfd_l` is not `null`, a node has been found. Immediately return `(zfd_l, null, null)` to propagate the result upwards.\n    3.  Recursively call on the right child: `(zfd_r, min_r, max_r) = find_zfd_postorder(curr.right)`.\n    4.  If `zfd_r` is not `null`, return `(zfd_r, null, null)`.\n-   **Process `curr`**:\n    1.  **Check Condition 1**: Is `curr` a removable red node? Check if `curr.color == red` and (`curr.left == NIL` or `curr.right == NIL`). If true, a ZFD node is found. Return `(curr, null, null)`.\n    2.  **Check Condition 2**: Is the successor of `curr` a removable red node?\n        -   The successor of `curr` exists only if `curr.right` is not $\\mathsf{NIL}$.\n        -   The successor is the minimum node in the right subtree, which is `min_r`, returned by the recursive call.\n        -   A successor `min_r` is guaranteed to have `min_r.left == NIL`. So, to be a removable red node, it simply needs to be red (`min_r.color == red`).\n        -   If `curr.right != NIL` and `min_r.color == red`, then `curr` is a ZFD node. Return `(curr, null, null)`.\n-   **Return Information**: If no ZFD node is found at or below `curr`, compute the minimum and maximum of the subtree rooted at `curr` and return them.\n    -   `my_min = (curr.left != NIL) ? min_l : curr`\n    -   `my_max = (curr.right != NIL) ? max_r : curr`\n    -   Return `(null, my_min, my_max)`.\n\nThis algorithm visits each of the $n$ nodes exactly once. The work done at each node (after its children are processed) consists of a constant number of comparisons and pointer manipulations. Thus, the total running time is $O(n)$. This establishes an upper bound on the complexity.\n\n### Step 3: Deriving the Lower Bound\n\nTo establish a tight bound, we must show that no algorithm can perform asymptotically better than the one described. We argue for a lower bound of $\\Omega(n)$.\n\nThe problem is fundamentally a search problem. To determine if a ZFD node exists, an algorithm must gather information about the colors and links of the nodes. The property of being \"zero-fix-up deletable\" is a local or semi-local structural property that is not correlated with the keys stored in the nodes. Therefore, an algorithm cannot use the binary search tree property to \"home in\" on a ZFD node without inspecting the local neighborhood.\n\nConsider an adversary argument. Suppose an algorithm $\\mathcal{A}$ claims to solve the problem by inspecting only $o(n)$ nodes. This means $\\mathcal{A}$ leaves a linear number of nodes, $\\Theta(n)$, uninspected.\nThe adversary can present two different, valid red-black trees, $T_1$ and $T_2$, which are identical on all the nodes that $\\mathcal{A}$ inspects.\n-   $T_1$ is constructed to have no zero-fix-up deletable nodes. For instance, a sufficiently large perfect binary tree where all nodes are black is a valid red-black tree with no ZFD nodes (as any deletion removes a black node, triggering fix-up).\n-   $T_2$ is constructed to be identical to $T_1$ on the inspected nodes, but contains a single ZFD node located at one of the uninspected positions. While the rigid properties of red-black trees make it non-trivial to construct such a $T_2$ from $T_1$ by a simple local change, it is possible to construct pairs of valid trees with this property.\n\nSince algorithm $\\mathcal{A}$ cannot distinguish between $T_1$ and $T_2$ based on the $o(n)$ nodes it probes, it must give the same answer for both. If it reports \"none exist,\" it is wrong for $T_2$. If it reports a ZFD node, it is wrong for $T_1$ (since it cannot have found a ZFD node among the nodes it inspected).\n\nTherefore, any correct deterministic algorithm must, in the worst case, inspect $\\Omega(n)$ nodes to distinguish a tree with no ZFD nodes from a tree with a single, adversarially placed ZFD node. This establishes a lower bound of $\\Omega(n)$ on the number of required operations.\n\n### Step 4: Conclusion\n\nThe upper bound for solving the problem is $O(n)$, established by the augmented post-order traversal algorithm. The lower bound is $\\Omega(n)$, as any algorithm must be prepared to inspect a constant fraction of the nodes in the worst case. Since the upper and lower bounds match, the asymptotically tight bound for the worst-case running time of the best possible algorithm is $\\Theta(n)$.", "answer": "$$\\boxed{\\Theta(n)}$$", "id": "3265780"}]}