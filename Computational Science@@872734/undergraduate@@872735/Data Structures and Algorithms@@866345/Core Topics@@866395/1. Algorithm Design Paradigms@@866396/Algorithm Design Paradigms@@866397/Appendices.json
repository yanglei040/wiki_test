{"hands_on_practices": [{"introduction": "This first practice explores the Divide and Conquer paradigm through a problem that is more subtle than simple sorting. You will count the number of \"inversions\" in a sequence, which is a measure of how unsorted it is. This exercise demonstrates the power of the \"combine\" step in a Divide and Conquer algorithm, showing that it can be used not just to merge results, but to compute valuable information along the way [@problem_id:3205394].", "problem": "You are given the task of designing and implementing a divide and conquer algorithm to compute the number of inversions in a finite sequence of distinct integers. An inversion is defined as a pair of indices $(i,j)$ such that $ij$ and $A[i]A[j]$. You must implement an algorithm whose worst-case running time is $O(n \\log n)$, where $n$ denotes the length of the input sequence.\n\nDefinitions and assumptions:\n- A sequence $A$ of length $n$ is a permutation if it contains $n$ distinct integers (not necessarily the integers from $1$ to $n$).\n- The inversion count of $A$ is the number of index pairs $(i,j)$ with $ij$ and $A[i]A[j]$.\n\nYour program must:\n- Implement a divide and conquer algorithm to compute the inversion count, using only comparisons of integers and basic arithmetic. Naive quadratic-time enumeration of all pairs is not allowed.\n- Use the following fixed test suite, which is a list of $7$ sequences, each represented as a Python-style list. For the purposes of this problem, treat these lists as the entire input to your program, and do not read any external input.\n    1. $[]$\n    2. $[1]$\n    3. $[1,2,3,4,5]$\n    4. $[5,4,3,2,1]$\n    5. $[2,3,8,6,1]$\n    6. $[1,3,5,2,4,6]$\n    7. $[10,3,7,4,9,1,8,2,5,6]$\n\nOutput specification:\n- For each of the $7$ sequences above, compute its inversion count as a nonnegative integer.\n- Your program should produce a single line of output containing the $7$ results as a comma-separated list enclosed in square brackets, with no spaces. For example, if the results for the $7$ cases were $r_1,r_2,\\dots,r_7$, the output should be exactly $[r_1,r_2,\\dots,r_7]$ on one line.\n\nNotes:\n- There are no physical or angular units involved, and no percentages are required. All outputs are integers.\n- The algorithm design paradigm to use is Divide and Conquer, and the time complexity target is $O(n\\log n)$.", "solution": "We begin with core definitions from discrete mathematics and algorithm analysis. Let a sequence $A$ of length $n$ be a list of $n$ distinct integers. An inversion is a pair of indices $(i,j)$ with $ij$ and $A[i]A[j]$. The inversion count is the cardinality of the set $\\{(i,j)\\mid 1\\le ij\\le n,\\ A[i]A[j]\\}$.\n\nWe seek an algorithm in the Divide and Conquer paradigm with worst-case time $O(n \\log n)$. The fundamental base we rely on is:\n- The divide and conquer methodology: solve a problem of size $n$ by dividing it into subproblems of size approximately $n/2$, solving these recursively, and combining their solutions in $O(n)$ time.\n- The Master Theorem for recurrences of the form $T(n)=a\\,T(n/b)+f(n)$, which yields $T(n)=O(n \\log n)$ when $a=2$, $b=2$, and $f(n)=\\Theta(n)$.\n\nDesign:\n1. Divide step: Split $A$ into two halves, $L$ (left) and $R$ (right), of sizes $\\lfloor n/2\\rfloor$ and $\\lceil n/2\\rceil$.\n2. Conquer step: Recursively compute the inversion counts of $L$ and $R$, denoted $I_L$ and $I_R$, respectively, and also produce the sorted versions of $L$ and $R$. Because the integers are distinct, sorting defines a strict total order.\n3. Combine step: Merge the two sorted halves into a single sorted sequence while counting cross inversions $I_C$, which are inversions $(i,j)$ with $i$ in the left half and $j$ in the right half. During a standard stable merge, maintain indices $p$ into $L$ and $q$ into $R$. When $L[p]\\le R[q]$, we append $L[p]$ and increment $p$. When $L[p]R[q]$, we append $R[q]$ and increment $q$, and we add $(|L|-p)$ to the inversion count, since $R[q]$ is smaller than all remaining elements $L[p],L[p+1],\\dots,L[|L|-1]$, each contributing one cross inversion.\n\nCorrectness:\nWe prove by induction on $n$ that the algorithm returns the exact inversion count and a sorted sequence.\n- Base cases: For $n=0$ and $n=1$, there are no inversions, so the count is $0$, and the sequence is trivially sorted. The algorithm returns $0$ and the original sequence, which is correct.\n- Inductive step: Assume correctness for all sequences of length less than $n$. Consider a sequence $A$ of length $n$. After dividing into $L$ and $R$, by the inductive hypothesis, the recursive calls correctly return $I_L$ and the sorted $L$, and $I_R$ and the sorted $R$. Every inversion in $A$ is either entirely within $L$, entirely within $R$, or a cross inversion with the first index in $L$ and the second in $R$. The merge procedure counts exactly the cross inversions: whenever an element from $R$ precedes remaining elements in $L$ in the merged order, it contributes exactly one inversion against each such remaining element, and when an element from $L$ precedes an element from $R$, no new cross inversion is formed. Therefore, the total inversion count is $I_L+I_R+I_C$, which the algorithm computes. The merge also produces the correctly sorted sequence from the two sorted halves. Thus, the algorithm is correct.\n\nComplexity:\nLet $T(n)$ denote the running time on length $n$. The recurrence satisfies\n$$\nT(n)=\n\\begin{cases}\n\\Theta(1),  \\text{if } n\\le 1,\\\\\n2\\,T(n/2)+\\Theta(n),  \\text{if } n1,\n\\end{cases}\n$$\nsince we make two recursive calls on halves and perform a linear-time merge. By the Master Theorem with $a=2$, $b=2$, and $f(n)=\\Theta(n)$, we obtain $T(n)=\\Theta(n\\log n)$. Therefore, the algorithm runs in $O(n\\log n)$ time.\n\nApplication to the test suite:\nWe apply the algorithm to the $7$ sequences specified. For each sequence, the algorithm outputs an integer inversion count. The final output must be a single line in the format $[r_1,r_2,\\dots,r_7]$ with no spaces, where $r_k$ is the inversion count for the $k$-th test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count_inversions(arr):\n    # Returns (sorted_arr, inversion_count)\n    def sort_count(a):\n        n = len(a)\n        if n = 1:\n            return a[:], 0\n        mid = n // 2\n        left_sorted, left_inv = sort_count(a[:mid])\n        right_sorted, right_inv = sort_count(a[mid:])\n        merged = []\n        i = j = 0\n        cross_inv = 0\n        len_left = len(left_sorted)\n        len_right = len(right_sorted)\n        # Merge with inversion counting\n        while i  len_left and j  len_right:\n            if left_sorted[i] = right_sorted[j]:\n                merged.append(left_sorted[i])\n                i += 1\n            else:\n                merged.append(right_sorted[j])\n                # All remaining items in left_sorted form inversions with right_sorted[j]\n                cross_inv += (len_left - i)\n                j += 1\n        if i  len_left:\n            merged.extend(left_sorted[i:])\n        if j  len_right:\n            merged.extend(right_sorted[j:])\n        return merged, left_inv + right_inv + cross_inv\n\n    _, inv = sort_count(arr)\n    return inv\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],  # 1: empty\n        [1],  # 2: single element\n        [1,2,3,4,5],  # 3: already sorted\n        [5,4,3,2,1],  # 4: reverse sorted\n        [2,3,8,6,1],  # 5: mixed distinct integers\n        [1,3,5,2,4,6],  # 6: interleaved\n        [10,3,7,4,9,1,8,2,5,6],  # 7: length 10 permutation\n    ]\n\n    results = []\n    for case in test_cases:\n        result = count_inversions(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3205394"}, {"introduction": "Next, we transition to Dynamic Programming (DP), a powerful technique for solving problems with optimal substructure and overlapping subproblems. This exercise asks you to find the minimum cost path through a grid, a classic problem that serves as an excellent introduction to DP thinking. By defining the state as the minimum cost to reach a cell $(i,j)$, you will see how DP builds a complete solution from the bottom up by iteratively solving simpler subproblems [@problem_id:3205401].", "problem": "Consider an $(n+1) \\times (m+1)$ grid with integer coordinates, where each cell $(i,j)$ for $0 \\le i \\le n$ and $0 \\le j \\le m$ has an associated nonnegative or negative entry cost given by a function $c(i,j)$. A path starts by entering cell $(0,0)$ and ends upon entering cell $(n,m)$. At each step, the path may only move to a cell with either $(i+1,j)$ or $(i,j+1)$, ensuring that movement is monotone nondecreasing in both indices. The total cost of a path is defined to be the sum of the costs of all entered cells along the path, including the starting cell and the ending cell. Your task is to formulate a dynamic programming algorithm that computes the minimum possible total cost to reach $(n,m)$ from $(0,0)$ under these rules, and then implement a program that applies this algorithm to the specified test suite.\n\nThe design must be grounded in fundamental principles of algorithm design for directed acyclic graphs, specifically the notion of optimal substructure and overlapping subproblems based on the structure of the grid and allowed moves. The grid with allowed right and down moves forms a directed acyclic graph, and the path cost is additive. No heuristic shortcuts are permitted; the method must be derived from principled reasoning about subproblems.\n\nThere are no physical units involved. All outputs in the test suite must be recorded as integers.\n\nUse the following test suite, where each case is specified by $(n,m)$ and the cost function $c(i,j)$:\n\n- Test case $1$: $n=2$, $m=3$, with $c(i,j)=i^2+2j+1$ for all $i,j$ in range.\n- Test case $2$: $n=0$, $m=0$, with $c(i,j)=5$ for all $i,j$ in range.\n- Test case $3$: $n=3$, $m=3$, with $c(i,j)=1$ for all $i,j$ except $c(1,1)=1000$ and $c(2,2)=1000$.\n- Test case $4$: $n=5$, $m=0$, with $c(i,j)=i$ for all $i,j$ in range.\n- Test case $5$: $n=3$, $m=5$, with $c(i,j)=(-1)^{i+j}$ for all $i,j$ in range.\n\nYour program should compute the minimum total cost for each test case and produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[x_1,x_2,x_3,x_4,x_5]$), where $x_k$ is the minimum total cost for test case $k$.", "solution": "The problem is well-posed and scientifically grounded in the principles of algorithm design for directed acyclic graphs. It is a classic minimum cost path problem on a grid, which can be solved efficiently using dynamic programming.\n\nThe problem can be modeled as finding a minimum weight path in a directed acyclic graph (DAG). The cells of the $(n+1) \\times (m+1)$ grid represent the vertices $(i,j)$ of the graph, for $0 \\le i \\le n$ and $0 \\le j \\le m$. The allowed movements, from a cell $(i,j)$ to either $(i+1,j)$ or $(i,j+1)$, define the directed edges of the graph. Specifically, for each cell $(i,j)$, there exists a directed edge to $(i+1,j)$ if $i  n$, and a directed edge to $(i,j+1)$ if $j  m$. Since movements are always to cells with a greater or equal index in both coordinates (monotonically non-decreasing), no cycles can be formed, confirming the graph is a DAG. The cost $c(i,j)$ of entering a cell can be treated as the weight associated with each vertex. The total cost of a path is the sum of the weights of all vertices along it.\n\nThis problem structure exhibits two key properties that make it suitable for dynamic programming:\n$1$. **Optimal Substructure**: A minimum cost path from the start cell $(0,0)$ to any cell $(i,j)$ must be formed by extending a minimum cost path from one of its immediate predecessors, either $(i-1,j)$ or $(i,j-1)$.\n$2$. **Overlapping Subproblems**: The minimum cost to reach a particular cell $(i,j)$ is referenced multiple times when computing the minimum costs for subsequent cells, specifically $(i+1,j)$ and $(i,j+1)$.\n\nWe define a subproblem as computing the minimum cost to reach an arbitrary cell $(i,j)$ from the starting cell $(0,0)$. Let $DP(i,j)$ denote this minimum cost. Our ultimate goal is to find $DP(n,m)$.\n\nThe recurrence relation for $DP(i,j)$ is derived as follows:\n\n**Base Case**: The path to the starting cell $(0,0)$ involves only that cell. Therefore, the minimum cost to reach $(0,0)$ is simply its own cost.\n$$DP(0,0) = c(0,0)$$\n\n**Recursive Step**: For any other cell $(i,j)$, a path must arrive from one of its valid predecessors.\n- For cells in the top row where $i=0$ and $j0$, the only valid predecessor is $(0,j-1)$. The minimum cost path to $(0,j)$ is the minimum cost path to $(0,j-1)$ followed by a move to $(0,j)$. Thus:\n$$DP(0,j) = DP(0,j-1) + c(0,j) \\quad \\text{for } j  0$$\n- For cells in the first column where $i0$ and $j=0$, the only valid predecessor is $(i-1,0)$. Similarly:\n$$DP(i,0) = DP(i-1,0) + c(i,0) \\quad \\text{for } i  0$$\n- For any other cell $(i,j)$ where $i0$ and $j0$, the path must come from either $(i-1,j)$ (a move down) or $(i,j-1)$ (a move right). According to the principle of optimality, we must choose the predecessor with the minimum path cost. The total cost to reach $(i,j)$ is its own cost plus the minimum of the costs to reach its predecessors:\n$$DP(i,j) = c(i,j) + \\min(DP(i-1,j), DP(i,j-1)) \\quad \\text{for } i0, j0$$\n\nWe can compute the values of $DP(i,j)$ iteratively in a bottom-up manner. We create an $(n+1) \\times (m+1)$ table to store the $DP$ values. The computation proceeds as follows:\n$1$. Initialize $DP(0,0)$ using the base case.\n$2$. Fill the first row ($i=0$) of the table using the recurrence for $DP(0,j)$.\n$3$. Fill the first column ($j=0$) of the table using the recurrence for $DP(i,0)$.\n$4$. Fill the rest of the table for $i$ from $1$ to $n$ and $j$ from $1$ to $m$, using the general recurrence for $DP(i,j)$. Each $DP(i,j)$ depends only on values that have already been computed (i.e., $DP(i-1,j)$ and $DP(i,j-1)$).\n\nThe final answer to the problem is the value stored in the table at the destination cell, $DP(n,m)$. The time complexity of this algorithm is $O(nm)$ because each cell in the $(n+1) \\times (m+1)$ table is visited exactly once. The space complexity is also $O(nm)$ to store the DP table.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef min_cost_path(n: int, m: int, cost_func) - int:\n    \"\"\"\n    Computes the minimum cost path on a grid using dynamic programming.\n\n    Args:\n        n: The maximum row index (grid is (n+1) x (m+1)).\n        m: The maximum column index.\n        cost_func: A function c(i, j) that returns the cost of cell (i, j).\n\n    Returns:\n        The minimum cost to travel from (0,0) to (n,m).\n    \"\"\"\n    # Grid dimensions are (n+1) x (m+1)\n    rows, cols = n + 1, m + 1\n\n    # Create the cost matrix C using the provided cost function.\n    # np.vectorize is used to apply the element-wise function over the indices.\n    indices = np.indices((rows, cols))\n    C = np.vectorize(cost_func)(indices[0], indices[1])\n\n    # DP table to store the minimum cost to reach cell (i, j)\n    DP = np.zeros((rows, cols), dtype=int)\n\n    # Base case: cost to reach (0,0) is just its own cost\n    DP[0, 0] = C[0, 0]\n\n    # Fill the first row (can only come from the left)\n    for j in range(1, cols):\n        DP[0, j] = C[0, j] + DP[0, j - 1]\n\n    # Fill the first column (can only come from above)\n    for i in range(1, rows):\n        DP[i, 0] = C[i, 0] + DP[i - 1, 0]\n    \n    # Fill the rest of the DP table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            DP[i, j] = C[i, j] + min(DP[i - 1, j], DP[i, j - 1])\n\n    # The result is the minimum cost to reach the bottom-right cell\n    return DP[n, m]\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        {'n': 2, 'm': 3, 'cost_func': lambda i, j: i**2 + 2*j + 1},\n        {'n': 0, 'm': 0, 'cost_func': lambda i, j: 5},\n        {'n': 3, 'm': 3, 'cost_func': lambda i, j: 1000 if (i, j) in [(1, 1), (2, 2)] else 1},\n        {'n': 5, 'm': 0, 'cost_func': lambda i, j: i},\n        {'n': 3, 'm': 5, 'cost_func': lambda i, j: (-1)**(i + j)},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = min_cost_path(case['n'], case['m'], case['cost_func'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3205401"}, {"introduction": "Our final practice tackles a famous NP-hard problem, the Traveling Salesperson Problem (TSP), using an advanced DP technique known as bitmasking. While TSP is intractable for large inputs, this exercise shows how DP can find an exact solution for small instances in exponential time, specifically $O(n^2 2^n)$. This problem will challenge you to think about the DP state in a new way, using an integer's bits to represent a subset of visited cities, a crucial technique for solving complex combinatorial optimization problems [@problem_id:3205307].", "problem": "Design and implement a program that solves the Traveling Salesperson Problem (TSP) for small instances using a dynamic programming approach with bitmasking, and then derive its worst-case time and space complexity from first principles. The problem is defined as follows: given a complete directed or undirected weighted graph on $n$ cities labeled $\\{0,1,\\ldots,n-1\\}$ with nonnegative integer edge weights, find the minimum-cost Hamiltonian cycle that starts at city $0$, visits each city exactly once, and returns to city $0$. Assume $n \\leq 20$ and that all diagonal entries are $0$; if the graph is undirected, weights are symmetric. Your task is to do the following.\n\n- Implement a dynamic programming algorithm grounded in the principle of optimality and a compact bitmask representation of subsets to compute the exact minimum tour cost for each provided instance. Use exact integer arithmetic.\n- Justify your algorithmic design using the base concepts of subproblem decomposition and the dynamic programming principle of optimality, not by relying on pre-memorized formulas. You must also derive and prove the worst-case time and space complexity in terms of $n$ using counting arguments over subsets and transitions.\n- For each test instance below, compute the minimum tour cost starting and ending at city $0$. All edge weights are integers, and all outputs for the test cases are integers.\n\nUse the following test suite. Each adjacency matrix is given explicitly as an array of arrays, with entry at row $i$ and column $j$ equal to the cost of travel from city $i$ to city $j$.\n\n- Test case A: $n = 1$\n  - Matrix: $[[0]]$.\n- Test case B: $n = 2$\n  - Matrix: $[[0, 3],[4, 0]]$.\n- Test case C: $n = 4$\n  - Matrix:\n    $[\n      [0, 10, 15, 20],\n      [10, 0, 35, 25],\n      [15, 35, 0, 30],\n      [20, 25, 30, 0]\n    ]$.\n- Test case D: $n = 5$ (asymmetric directed)\n  - Matrix:\n    $[\n      [0, 5, 1, 5, 5],\n      [1, 0, 7, 8, 7],\n      [5, 5, 0, 1, 5],\n      [5, 7, 9, 0, 1],\n      [5, 1, 5, 1, 0]\n    ]$.\n  The deliberately cheap cycle is $0 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 1 \\rightarrow 0$ with cost $5$ (each edge on this cycle has cost $1$, all other off-diagonal edges in the first row are $5$; other rows are chosen to keep all entries nonnegative integers).\n- Test case E: $n = 10$ (symmetric undirected)\n  - Matrix:\n    $[\n      [0, 8, 12, 3, 20, 15, 9, 10, 19, 7],\n      [8, 0, 13, 6, 5, 12, 14, 9, 3, 16],\n      [12, 13, 0, 9, 13, 7, 6, 12, 11, 4],\n      [3, 6, 9, 0, 4, 8, 16, 7, 5, 14],\n      [20, 5, 13, 4, 0, 2, 12, 6, 15, 9],\n      [15, 12, 7, 8, 2, 0, 3, 17, 10, 11],\n      [9, 14, 6, 16, 12, 3, 0, 1, 13, 2],\n      [10, 9, 12, 7, 6, 17, 1, 0, 4, 8],\n      [19, 3, 11, 5, 15, 10, 13, 4, 0, 6],\n      [7, 16, 4, 14, 9, 11, 2, 8, 6, 0]\n    ]$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases A through E. For example, for generic results $r_A$, $r_B$, $r_C$, $r_D$, and $r_E$, the output must be\n$[r_A,r_B,r_C,r_D,r_E]$\nwith no additional whitespace or text.\n\nNotes and clarifications.\n- Use the standard model of computation in which bitwise operations on fixed-width integers are considered constant time.\n- Angles and physical units are not involved in this problem.\n- The answers for each test case are integers.", "solution": "The problem statement is evaluated to be valid. It is a well-posed, scientifically grounded problem in the field of algorithm design, specifically concerning an exact solution to the Traveling Salesperson Problem (TSP). The problem is self-contained, providing all necessary data, definitions, and constraints. The specified method—dynamic programming with bitmasking—is a standard and correct approach for solving TSP for small instances. The constraints ($n \\leq 20$) are consistent with the known exponential complexity of this exact algorithm.\n\n**1. Algorithmic Design: Dynamic Programming with the Principle of Optimality**\n\nThe Traveling Salesperson Problem (TSP) seeks the minimum-cost Hamiltonian cycle in a weighted graph. We are tasked to find such a cycle starting and ending at a specific city, labeled $0$. The core of the dynamic programming solution lies in defining a subproblem that can be built upon to solve larger problems, a property known as optimal substructure.\n\nLet the set of all cities be $V = \\{0, 1, \\ldots, n-1\\}$. A tour is a permutation of these cities. We fix the starting city as $0$. A path starting at city $0$ and visiting a set of cities $S \\subseteq V$ is a sequence of distinct cities $(c_0, c_1, \\ldots, c_k)$ where $c_0=0$ and $\\{c_0, \\ldots, c_k\\} = S$.\n\n**Subproblem Definition:**\nLet $dp(S, j)$ be the minimum cost of a path that starts at city $0$, visits every city in the set $S \\subseteq V$ exactly once, and ends at city $j \\in S$. The start city $0$ must be in $S$.\n\n**Principle of Optimality and Recurrence Relation:**\nThe principle of optimality states that an optimal solution to a problem contains optimal solutions to its subproblems. Consider an optimal path for the state $(S, j)$, where $|S|  1$. This path must have arrived at city $j$ from some other city $k$ in the set $S \\setminus \\{j\\}$. For the overall path to be optimal, the subpath from city $0$ to city $k$ visiting all cities in $S \\setminus \\{j\\}$ must also be optimal. This is precisely the subproblem $dp(S \\setminus \\{j\\}, k)$. The cost of extending this optimal subpath to city $j$ is $dp(S \\setminus \\{j\\}, k) + \\text{cost}(k, j)$, where $\\text{cost}(k, j)$ is the weight of the edge from $k$ to $j$. To find the minimum cost for state $(S, j)$, we must consider all possible predecessor cities $k$. This leads to the recurrence relation:\n\n$$\ndp(S, j) = \\min_{k \\in S \\setminus \\{j\\}} \\{ dp(S \\setminus \\{j\\}, k) + \\text{cost}(k, j) \\}\n$$\n\n**Base Case:**\nThe smallest subproblem is the path that starts at city $0$ and ends at city $0$, having visited only the set $\\{0\\}$. The cost of this trivial path is $0$.\n$$\ndp(\\{0\\}, 0) = 0\n$$\nFor any other city $j \\neq 0$, $dp(\\{0\\}, j)$ is undefined, as a path containing only city $0$ cannot end at $j$. We can represent this with an initial value of infinity.\n\n**Implementation with Bitmasking:**\nThe set of visited cities $S$ can be efficiently represented by an integer bitmask of length $n$. A mask is an integer where the $i$-th bit is set to $1$ if city $i \\in S$, and $0$ otherwise.\n- The set $S$ is represented by an integer `mask`.\n- The condition $j \\in S$ is checked with the bitwise operation `(mask  j)  1 == 1`.\n- The set $S \\setminus \\{j\\}$ is represented by `mask ^ (1  j)`.\n\nThe DP state becomes $dp[\\text{mask}][j]$. We can compute the values for $dp[\\text{mask}][j]$ by iterating through masks in increasing order of size (number of set bits), or more simply, just by increasing numerical order of the mask itself. Since a subproblem's mask, `prev_mask`, is always numerically smaller than the current problem's `mask`, its value will have been computed already.\n\nThe algorithm proceeds as follows:\n1. Initialize a $2^n \\times n$ table, $dp$, with infinity, representing costs.\n2. Set the base case: $dp[1][0] = 0$. (The mask for $\\{0\\}$ is $2^0 = 1$).\n3. Iterate through `mask` from $2$ to $2^n - 1$. For each `mask`, iterate through all possible ending cities `j` from $0$ to $n-1$.\n4. If city `j` is in the set represented by `mask`, find the optimal subpath. Let `prev_mask = mask ^ (1  j)`. Iterate through all possible previous cities `k` from $0$ to $n-1$.\n5. If city `k` is in the set represented by `prev_mask`, apply the recurrence: $dp[\\text{mask}][j] = \\min(dp[\\text{mask}][j], dp[\\text{prev_mask}][k] + \\text{cost}[k][j])$.\n\n**Final Solution:**\nAfter the DP table is fully populated, the entry $dp[(1 \\ll n) - 1][j]$ contains the cost of the minimum path from city $0$ to city $j$ that visits all $n$ cities. The final step is to complete the cycle by returning from city $j$ to city $0$. We must check all possible endpoints $j \\in \\{1, \\ldots, n-1\\}$ and find the one that yields the minimum total tour cost.\n$$\n\\text{Minimum Tour Cost} = \\min_{j \\in \\{1, \\ldots, n-1\\}} \\{ dp[(1 \\ll n) - 1][j] + \\text{cost}(j, 0) \\}\n$$\nFor the edge case $n=1$, the tour is trivially $0 \\to 0$ with cost $0$.\n\n**2. Complexity Analysis**\n\n**Space Complexity:**\nThe dominant data structure is the DP table, which stores the costs for all subproblems. The table has one dimension for the `mask` and another for the endpoint city `j`.\n- The number of possible masks is $2^n$.\n- The number of possible endpoint cities is $n$.\nTherefore, the total number of states (and entries in the DP table) is $n \\cdot 2^n$. Assuming each entry requires constant storage, the space complexity is $O(n \\cdot 2^n)$.\n\n**Time Complexity:**\nThe running time is determined by the number of operations required to fill the DP table. This is equivalent to the sum of costs to compute each state transition. The computation for a state $dp[\\text{mask}][j]$ involves iterating through all possible predecessors $k$.\nThe total number of elementary computations is proportional to:\n$$\n\\sum_{\\text{mask}=1}^{2^n-1} \\sum_{j=0}^{n-1} \\sum_{k=0}^{n-1} \\text{work}(mask, j, k)\n$$\nwhere `work` is $O(1)$ if $j$ is in `mask` and $k$ is in `mask` without $j$. This can be analyzed more precisely by grouping states by the size of the set of visited cities, $s = |\\text{S}|$.\n\nLet $s$ be the number of set bits in a mask. The number of masks of size $s$ is given by the binomial coefficient $\\binom{n}{s}$. For each such mask, we can choose any of the $s$ cities as the endpoint $j$. For each choice of `mask` and $j$, we iterate over all $s-1$ possible predecessor cities $k \\in S \\setminus \\{j\\}$.\n\nThe total number of inner loop executions is thus:\n$$\n\\text{Time} \\propto \\sum_{s=1}^{n} \\left( \\binom{n}{s} \\cdot s \\cdot (s-1) \\right)\n$$\nWe use the combinatorial identity $\\binom{n}{s} s = n \\binom{n-1}{s-1}$ and $\\binom{n-1}{s-1} (s-1) = (n-1) \\binom{n-2}{s-2}$:\n$$\n\\sum_{s=2}^{n} \\binom{n}{s} s(s-1) = \\sum_{s=2}^{n} n \\binom{n-1}{s-1} (s-1) = n \\sum_{s=2}^{n} (n-1) \\binom{n-2}{s-2}\n$$\nLet $p = s-2$. The sum becomes:\n$$\nn(n-1) \\sum_{p=0}^{n-2} \\binom{n-2}{p}\n$$\nBy the binomial theorem, $\\sum_{p=0}^{m} \\binom{m}{p} = 2^m$. Here, $m=n-2$.\n$$\nn(n-1) \\cdot 2^{n-2}\n$$\nThis expression demonstrates that the time complexity is dominated by terms proportional to $n^2 2^n$. The final step of calculating the tour cost takes $O(n)$ time, which is negligible. Therefore, the worst-case time complexity of the algorithm is $O(n^2 \\cdot 2^n)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tsp(cost_matrix: np.ndarray) - int:\n    \"\"\"\n    Solves the Traveling Salesperson Problem using dynamic programming with bitmasking.\n\n    Args:\n        cost_matrix: An n x n numpy array representing the cost of travel between cities.\n\n    Returns:\n        The minimum cost of a Hamiltonian cycle starting and ending at city 0.\n    \"\"\"\n    n = cost_matrix.shape[0]\n\n    # Handle the trivial case where n=1. The tour is 0 - 0 with cost 0.\n    if n = 1:\n        return 0\n\n    # DP table: dp[mask][j] stores the minimum cost of a path from city 0\n    # to city j, visiting the set of cities represented by 'mask'.\n    # Mask is an integer where the i-th bit is 1 if city i has been visited.\n    dp = np.full((1  n, n), float('inf'))\n\n    # Base case: The path from city 0 to city 0, visiting only {0}, has cost 0.\n    # The mask for {0} is 1 (binary ...001).\n    dp[1, 0] = 0\n\n    # Iterate through all subsets (masks) of cities, from size 2 up to n.\n    # The mask must contain the starting city 0, so bit 0 must be set.\n    for mask in range(3, 1  n, 2):  # iterate over odd masks  1\n        # 'j' is the current endpoint of the path. It cannot be the start city 0\n        # as we are building paths originating from 0.\n        for j in range(1, n):\n            # Check if city 'j' is in the current subset 'mask'.\n            if (mask  j)  1:\n                # 'prev_mask' represents the subset of cities visited before reaching 'j'.\n                prev_mask = mask ^ (1  j)\n                \n                # 'k' is the city visited just before 'j'. It can be any city in 'prev_mask'.\n                for k in range(n):\n                    if (prev_mask  k)  1:\n                        # If a path to k exists, update the path to j.\n                        if dp[prev_mask, k] != float('inf'):\n                            dp[mask, j] = min(dp[mask, j], dp[prev_mask, k] + cost_matrix[k, j])\n\n    # After filling the DP table, find the minimum total tour cost.\n    # A full tour visits all cities, so the mask is (1n) - 1.\n    final_mask = (1  n) - 1\n    min_tour_cost = float('inf')\n\n    # The tour ends by returning from the last city 'j' to the starting city 0.\n    for j in range(1, n):\n        # Check if a path exists that visits all cities and ends at 'j'.\n        if dp[final_mask, j] != float('inf'):\n            tour_cost = dp[final_mask, j] + cost_matrix[j, 0]\n            min_tour_cost = min(min_tour_cost, tour_cost)\n\n    return int(min_tour_cost)\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the TSP solution for each,\n    then prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Test case A: n = 1\n        np.array([[0]]),\n        \n        # Test case B: n = 2\n        np.array([[0, 3], [4, 0]]),\n        \n        # Test case C: n = 4\n        np.array([\n            [0, 10, 15, 20],\n            [10, 0, 35, 25],\n            [15, 35, 0, 30],\n            [20, 25, 30, 0]\n        ]),\n        \n        # Test case D: n = 5\n        np.array([\n            [0, 5, 1, 5, 5],\n            [1, 0, 7, 8, 7],\n            [5, 5, 0, 1, 5],\n            [5, 7, 9, 0, 1],\n            [5, 1, 5, 1, 0]\n        ]),\n        \n        # Test case E: n = 10\n        np.array([\n            [0, 8, 12, 3, 20, 15, 9, 10, 19, 7],\n            [8, 0, 13, 6, 5, 12, 14, 9, 3, 16],\n            [12, 13, 0, 9, 13, 7, 6, 12, 11, 4],\n            [3, 6, 9, 0, 4, 8, 16, 7, 5, 14],\n            [20, 5, 13, 4, 0, 2, 12, 6, 15, 9],\n            [15, 12, 7, 8, 2, 0, 3, 17, 10, 11],\n            [9, 14, 6, 16, 12, 3, 0, 1, 13, 2],\n            [10, 9, 12, 7, 6, 17, 1, 0, 4, 8],\n            [19, 3, 11, 5, 15, 10, 13, 4, 0, 6],\n            [7, 16, 4, 14, 9, 11, 2, 8, 6, 0]\n        ])\n    ]\n\n    results = []\n    for cost_matrix in test_cases:\n        result = solve_tsp(cost_matrix)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3205307"}]}