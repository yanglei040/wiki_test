{"hands_on_practices": [{"introduction": "The divide-and-conquer paradigm is not just for sorting; its true power lies in its structure, which can be adapted to solve a variety of complex problems. This exercise demonstrates how the classic Merge Sort algorithm can be elegantly augmented to count the number of \"inversions\" in an arrayâ€”a measure of how unsorted it is. By embedding the counting logic within the `merge` step, you can solve this problem far more efficiently than with a brute-force approach, showcasing the paradigm's ability to solve counting problems alongside sorting. [@problem_id:3228600]", "problem": "Consider an integer array $A$ of length $n$ whose elements are drawn from a known, but large, integer range $[\\alpha,\\beta]$. An inversion in $A$ is a pair of indices $(i,j)$ with $0 \\leq i < j < n$ such that $A[i] > A[j]$. Using the divide-and-conquer paradigm, design and implement a program that, for each array in the test suite specified below, counts the total number of inversions. The algorithm must rely only on comparison-based operations, must correctly handle duplicate values (equal values must not be counted as inversions), and must not allocate memory proportional to the range size $(\\beta - \\alpha + 1)$.\n\nFundamental base for reasoning: use core definitions and principles of divide-and-conquer in data structures and algorithms, including the notion of splitting into subproblems, recursively solving subproblems, and combining their solutions. The derivation should start from these principles and from the definition of an inversion as given above.\n\nTest suite:\n- $A_1 = [2,4,1,3,5]$, with $n = 5$ and elements in $[\\alpha,\\beta] = [-10^{12},10^{12}]$.\n- $A_2 = [1,2,3,4,5,6]$, with $n = 6$ and elements in $[\\alpha,\\beta] = [-10^{12},10^{12}]$.\n- $A_3 = [5,4,3,2,1]$, with $n = 5$ and elements in $[\\alpha,\\beta] = [-10^{12},10^{12}]$.\n- $A_4 = [10^{12},10^{12},-10^{12},0,10^{12}]$, with $n = 5$ and elements in $[\\alpha,\\beta] = [-10^{12},10^{12}]$.\n- $A_5 = []$, with $n = 0$ and elements in $[\\alpha,\\beta] = [-10^{12},10^{12}]$.\n- $A_6 = [42]$, with $n = 1$ and elements in $[\\alpha,\\beta] = [-10^{12},10^{12}]$.\n- $A_7 = [7,7,7]$, with $n = 3$ and elements in $[\\alpha,\\beta] = [-10^{12},10^{12}]$.\n- $A_8 = [3,3,2,2,1]$, with $n = 5$ and elements in $[\\alpha,\\beta] = [-10^{12},10^{12}]$.\n\nRequired final output format: your program should produce a single line of output containing the inversion counts for $A_1$ through $A_8$ as a comma-separated list enclosed in square brackets, in the order given above, for example $[x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8]$, where each $x_i$ is an integer.", "solution": "The user-provided problem is assessed as valid and will be solved.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **Objective**: Count the total number of inversions in an integer array $A$ of length $n$.\n- **Definition of Inversion**: A pair of indices $(i, j)$ such that $0 \\leq i < j < n$ and $A[i] > A[j]$.\n- **Data Range**: Array elements are drawn from a known integer range $[\\alpha, \\beta]$, which is large.\n- **Paradigm Constraint**: The solution must use the divide-and-conquer paradigm.\n- **Operational Constraint**: The algorithm must rely only on comparison-based operations.\n- **Constraint on Duplicates**: Equal values, i.e., $A[i] = A[j]$, must not be counted as inversions.\n- **Memory Constraint**: The algorithm must not allocate memory proportional to the range size $(\\beta - \\alpha + 1)$.\n- **Test Suite**:\n    - $A_1 = [2,4,1,3,5]$, $n = 5$, $[\\alpha,\\beta] = [-10^{12},10^{12}]$\n    - $A_2 = [1,2,3,4,5,6]$, $n = 6$, $[\\alpha,\\beta] = [-10^{12},10^{12}]$\n    - $A_3 = [5,4,3,2,1]$, $n = 5$, $[\\alpha,\\beta] = [-10^{12},10^{12}]$\n    - $A_4 = [10^{12},10^{12},-10^{12},0,10^{12}]$, $n = 5$, $[\\alpha,\\beta] = [-10^{12},10^{12}]$\n    - $A_5 = []$, $n = 0$, $[\\alpha,\\beta] = [-10^{12},10^{12}]$\n    - $A_6 = [42]$, $n = 1$, $[\\alpha,\\beta] = [-10^{12},10^{12}]$\n    - $A_7 = [7,7,7]$, $n = 3$, $[\\alpha,\\beta] = [-10^{12},10^{12}]$\n    - $A_8 = [3,3,2,2,1]$, $n = 5$, $[\\alpha,\\beta] = [-10^{12},10^{12}]$\n- **Output Format**: A single line string `[x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8]`.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is evaluated against the specified criteria:\n- **Scientifically Grounded & Objective**: The problem of counting inversions is a standard, well-defined problem in the field of algorithms and data structures. The definition is precise and mathematical. This satisfies the grounding and objectivity criteria.\n- **Well-Posed**: A unique, integer-valued solution exists for any given finite array. The constraints guide the choice of algorithm but do not make the problem unsolvable.\n- **Consistency**: The constraints are self-consistent and logical. Specifically, the large value range $[\\alpha, \\beta]$ combined with the constraint on memory allocation effectively rules out solutions based on counting sort or frequency arrays (which would require memory proportional to $\\beta - \\alpha$), thereby reinforcing the requirement for a comparison-based approach like the one derived from the divide-and-conquer paradigm.\n- **Relevance**: The problem is directly relevant to the topic of *divide and conquer*.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. It is a well-posed, scientifically-grounded problem with clear, consistent constraints that squarely falls within the domain of algorithm design using the divide-and-conquer paradigm. A complete solution will be provided.\n\n### Principle-Based Solution Derivation\n\nThe problem requires counting inversions in an array $A$ of length $n$ using the divide-and-conquer paradigm. An inversion is defined as a pair of indices $(i, j)$ where $i < j$ and $A[i] > A[j]$.\n\n**1. Divide-and-Conquer Strategy**\n\nThe divide-and-conquer approach involves three steps:\n- **Divide**: Split the problem into smaller, similar subproblems. We divide the array $A$ of size $n$ into two subarrays, a left half $L$ and a right half $R$, each of approximate size $n/2$.\n- **Conquer**: Solve the subproblems recursively. We recursively count the inversions within $L$ and $R$. Let these counts be $I_L$ and $I_R$, respectively.\n- **Combine**: Combine the solutions of the subproblems to get the solution for the original problem.\n\nThe total number of inversions in $A$ is the sum of three distinct types of inversions:\n1. Inversions entirely within the left subarray $L$ (counted by $I_L$).\n2. Inversions entirely within the right subarray $R$ (counted by $I_R$).\n3. Inversions with one element in $L$ and the other in $R$. These are \"split inversions\". Let this count be $I_S$.\n\nThe total inversion count is $I_{total} = I_L + I_R + I_S$. The recursive calls handle the first two components. The primary challenge is to efficiently compute $I_S$ in the combine step.\n\n**2. The Combine Step: Counting Split Inversions**\n\nA split inversion is a pair $(a, b)$ where $a \\in L$, $b \\in R$, and $a > b$. A naive approach of comparing every element of $L$ with every element of $R$ would take $O(n^2)$ time for the combine step, leading to a recurrence $T(n) = 2T(n/2) + O(n^2)$, which solves to $T(n) = O(n^2)$. This is no better than a brute-force check of all pairs in the original array.\n\nTo achieve a more efficient solution, we can leverage the structure of the Merge Sort algorithm. The key insight is that if the left subarray $L$ and the right subarray $R$ are already sorted, we can count the split inversions in linear time, i.e., $O(n)$, while simultaneously merging them into a single sorted array.\n\nLet's modify the recursive function to not only return the inversion count but also the sorted version of the subarray it processed. The combine step then becomes a \"merge-and-count\" procedure.\n\n**3. The Merge-and-Count Algorithm**\n\nSuppose we have the sorted left subarray $L'$ and the sorted right subarray $R'$. We use two pointers, $i$ for $L'$ and $j$ for $R'$, both initialized to $0$, and an auxiliary array `merged_array` to store the result. We iterate while both pointers are within their respective array bounds:\n\n- **Compare $L'[i]$ and $R'[j]$**:\n    - If $L'[i] \\le R'[j]$: This means $L'[i]$ is smaller than or equal to the current element $R'[j]$ and, by extension (since $R'$ is sorted), all subsequent elements in $R'$. Thus, $L'[i]$ does not form a split inversion with any remaining element of $R'$. We append $L'[i]$ to `merged_array` and increment $i$.\n    - If $L'[i] > R'[j]$: This is the crucial case. Since $L'[i] > R'[j]$, and $L'$ is also sorted, every element in $L'$ from index $i$ onwards (i.e., $L'[i], L'[i+1], \\dots$) must also be greater than $R'[j]$. The number of such elements is equal to the number of elements remaining in $L'$, which is $(|L'| - i)$. We have discovered $(|L'| - i)$ new split inversions. We add this number to our running count for $I_S$, append $R'[j]$ to `merged_array`, and increment $j$.\n\nAfter one of the subarrays is exhausted, we append the remaining elements of the other subarray to `merged_array`. This process correctly counts all split inversions and produces a single sorted array in $O(n)$ time.\n\n**4. Recurrence Relation and Complexity Analysis**\n\nThe algorithm can be described by the following recurrence relation for its time complexity, $T(n)$:\n$$T(n) = 2T(n/2) + O(n)$$\nwhere $2T(n/2)$ represents the two recursive calls on subarrays of size $n/2$, and $O(n)$ represents the linear time taken by the merge-and-count step.\n\nAccording to the Master Theorem (Case $2$, where $a=2, b=2,$ and $f(n) = \\Theta(n^{\\log_b a}) = \\Theta(n^{\\log_2 2}) = \\Theta(n)$), this recurrence solves to:\n$$T(n) = O(n \\log n)$$\n\nThe space complexity is determined by the auxiliary array required for the merge step, which is of size $n$. Thus, the space complexity is $O(n)$. This satisfies the constraint that memory allocation must not be proportional to the element value range $(\\beta - \\alpha + 1)$.\n\nThe base case for the recursion is an array of size $0$ or $1$, which by definition has $0$ inversions. The algorithm is comparison-based and correctly handles duplicates by using the strict inequality $A[i] > A[j]$ for inversions, which is implemented as $L'[i] > R'[j]$ in the logic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the inversion counting problem for the given test suite.\n    \"\"\"\n\n    def count_inversions(arr):\n        \"\"\"\n        Main function to initiate the inversion counting process.\n        It uses a recursive helper function that implements the merge-sort-based algorithm.\n        \"\"\"\n        if not arr or len(arr) < 2:\n            return 0\n        \n        # The recursive function returns a tuple: (sorted_array, inversion_count)\n        _, total_inversions = _merge_sort_and_count(arr)\n        return total_inversions\n\n    def _merge_sort_and_count(arr):\n        \"\"\"\n        Recursively sorts the array and counts inversions using the divide-and-conquer strategy.\n        \n        Returns:\n            A tuple containing the sorted version of `arr` and the number of inversions.\n        \"\"\"\n        n = len(arr)\n        if n < 2:\n            # Base case: an array with 0 or 1 element has 0 inversions and is already sorted.\n            return arr, 0\n\n        # 1. Divide\n        mid = n // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        # 2. Conquer: Recursively sort and count inversions in both halves.\n        sorted_left, left_inversions = _merge_sort_and_count(left_half)\n        sorted_right, right_inversions = _merge_sort_and_count(right_half)\n\n        # 3. Combine: Merge the sorted halves and count split inversions.\n        merged_array = []\n        split_inversions = 0\n        i, j = 0, 0\n        len_left, len_right = len(sorted_left), len(sorted_right)\n\n        while i < len_left and j < len_right:\n            # The core logic for merging and counting split inversions.\n            if sorted_left[i] <= sorted_right[j]:\n                # No inversion here. Append the smaller element from the left.\n                merged_array.append(sorted_left[i])\n                i += 1\n            else:\n                # An inversion is found. The element from the right is smaller.\n                merged_array.append(sorted_right[j])\n                j += 1\n                # All remaining elements in sorted_left are also > sorted_right[j]\n                # The number of such elements is len_left - i.\n                split_inversions += (len_left - i)\n        \n        # Append any remaining elements from either half.\n        merged_array.extend(sorted_left[i:])\n        merged_array.extend(sorted_right[j:])\n\n        total_inversions = left_inversions + right_inversions + split_inversions\n        \n        return merged_array, total_inversions\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [2, 4, 1, 3, 5],\n        [1, 2, 3, 4, 5, 6],\n        [5, 4, 3, 2, 1],\n        [10**12, 10**12, -10**12, 0, 10**12],\n        [],\n        [42],\n        [7, 7, 7],\n        [3, 3, 2, 2, 1],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = count_inversions(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3228600"}, {"introduction": "Divide and conquer is the fundamental principle behind efficient searching algorithms like binary search. This practice challenges you to apply that same principle to a more complex search scenario: finding the peak element in a bitonic array. Here, instead of comparing to a target value, you will use the local slope of the array to intelligently discard half of the search space in each step, honing your ability to identify the key property that enables logarithmic time complexity. [@problem_id:3228689]", "problem": "You are given a finite sequence (array) of pairwise distinct integers that is strictly increasing up to a unique maximum and then strictly decreasing. Such an array is called bitonic. Formally, an array $A$ of length $n$ with $n \\ge 3$ is bitonic if there exists an index $k$ with $0 < k < n-1$ such that $A[0] < A[1] < \\cdots < A[k-1] < A[k]$ and $A[k] > A[k+1] > \\cdots > A[n-1]$. The index $k$ is the peak index. All indices are $0$-based. You must design and implement a divide and conquer (D&C) algorithm that returns the peak index $i$ in time $O(\\log n)$ using only comparisons between array elements and index arithmetic.\n\nYour derivation should start from fundamental bases appropriate to algorithms on sequences: (i) the total order property of integers under the usual comparison operators, (ii) the definition of a bitonic sequence as strictly increasing followed by strictly decreasing, and (iii) the paradigm of divide and conquer as recursively solving a problem by partitioning it into subproblems of smaller size until a base case is reached. Do not rely on any specialized shortcut formulas; rather, reason from these bases to obtain a correct and efficient algorithm.\n\nYour program must compute the peak index for each of the following test arrays. The arrays are guaranteed to be bitonic and to contain pairwise distinct integers.\n\n- Test $1$: $[1,3,8,12,4,2]$\n- Test $2$: $[2,5,1]$\n- Test $3$: $[10,22,35,40,90,80,20,5,3,1]$\n- Test $4$: $[-9,-4,-2,-3,-8]$\n- Test $5$: $[0,9,7,5,2]$\n- Test $6$: $[1,2,3,4,5,7,6]$\n\nFor each test, the required answer is the peak index $i$ (an integer). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[i_1,i_2,\\dots,i_6]$) in the same order as the tests above. There are no physical units or angles involved in this problem; all answers are pure integers. The time complexity requirement is $O(\\log n)$ per test case, and your algorithm must be based on divide and conquer.", "solution": "The user has provided a well-defined computational problem.\n\n### Step 1: Extract Givens\n- **Input**: A finite sequence, represented as an array $A$, of pairwise distinct integers.\n- **Array Property**: The array $A$ is bitonic.\n- **Definition of Bitonic**: For an array $A$ of length $n$, where $n \\ge 3$, there exists a unique peak index $k$ such that $0 < k < n-1$, with the properties:\n    - $A[0] < A[1] < \\cdots < A[k-1] < A[k]$ (strictly increasing segment)\n    - $A[k] > A[k+1] > \\cdots > A[n-1]$ (strictly decreasing segment)\n- **Objective**: Design and implement a divide and conquer (D&C) algorithm to find the peak index $k$.\n- **Performance Requirement**: The algorithm must have a time complexity of $O(\\log n)$.\n- **Allowed Operations**: The algorithm may only use comparisons between array elements and index arithmetic.\n- **Derivation Constraint**: The solution must be derived from fundamental principles: (i) the total order property of integers, (ii) the definition of a bitonic sequence, and (iii) the divide and conquer paradigm.\n- **Test Data**: Six guaranteed bitonic arrays are provided for testing.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is rooted in the mathematical field of algorithm design and analysis. The concepts of arrays, integer ordering, time complexity, and divide and conquer are rigorously defined within computer science. The problem is factually sound.\n- **Well-Posedness**: The problem states that the input array is always bitonic and has a *unique* maximum. This ensures that a single, well-defined peak index exists for every valid input, making the problem well-posed. The constraints on complexity and methodology guide the solution design but do not make it unsolvable.\n- **Objectivity**: The problem is stated using precise, unambiguous terminology such as \"strictly increasing,\" \"pairwise distinct,\" and \"unique maximum.\" There are no subjective or opinion-based elements.\n- **Flaw Check**:\n    1.  **Scientific/Factual Unsoundness**: None. The problem adheres to established principles of mathematics and computer science.\n    2.  **Non-Formalizable/Irrelevant**: None. The problem is a classic example within the specified topic of *divide and conquer*.\n    3.  **Incomplete/Contradictory Setup**: None. The problem provides all necessary definitions and constraints. The condition $0 < k < n-1$ for the peak index is consistent with the provided test cases.\n    4.  **Unrealistic/Infeasible**: Not applicable. The problem is abstract and does not involve physical quantities.\n    5.  **Ill-Posed/Poorly Structured**: None. A unique solution is guaranteed to exist.\n    6.  **Pseudo-Profound/Trivial**: None. Designing an $O(\\log n)$ algorithm for this non-standard search problem requires non-trivial application of the divide and conquer principle.\n    7.  **Outside Scientific Verifiability**: None. The correctness and efficiency of the resulting algorithm can be formally proven.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be derived and presented.\n\n### Algorithmic Derivation and Solution\n\nThe objective is to find the unique peak index $k$ in a bitonic array $A$ of length $n$ in $O(\\log n)$ time. This time complexity requirement strongly suggests a strategy that recursively or iteratively halves the search space, which is the central idea of the divide and conquer paradigm.\n\n**1. Foundational Principles**\n\n- **Total Order of Integers**: The elements of the array are integers, which are totally ordered. For any two distinct elements $A[i]$ and $A[j]$, we can definitively determine if $A[i] < A[j]$ or $A[i] > A[j]$. This allows for comparison-based decisions.\n- **Bitonic Property**: The structure of the array is fundamental to the algorithm. For any index $i$ in the range $0 \\le i < n-1$, we can determine if we are on the increasing or decreasing part of the sequence by comparing $A[i]$ and $A[i+1]$.\n    - If $A[i] < A[i+1]$, the segment at $i$ is increasing.\n    - If $A[i] > A[i+1]$, the segment at $i$ is decreasing.\n    The peak $k$ is the unique index satisfying $A[k-1] < A[k]$ and $A[k] > A[k+1]$.\n- **Divide and Conquer (D&C)**: The D&C strategy consists of three steps:\n    - **Divide**: Divide the problem into smaller subproblems. For an array, this typically involves selecting a pivot or middle element and partitioning the array's index range.\n    - **Conquer**: Solve the subproblems recursively. If the subproblems are small enough (base case), solve them directly.\n    - **Combine**: The combination step is often trivial in search-related D&C problems, as the solution to one of the subproblems is the solution to the overall problem.\n\n**2. Algorithm Design**\n\nLet our search space be the index range $[l, r]$, initially $[0, n-1]$. The D&C strategy involves probing an index within this range to decide which sub-range must contain the peak. A natural choice for the probe is the middle index, $m = l + \\lfloor (r - l) / 2 \\rfloor$.\n\nBy examining the value $A[m]$ relative to its neighbors, we can reduce the search space. The problem guarantees $n \\ge 3$ and $0 < k < n-1$, meaning the peak is never at the first or last position. This simplifies the logic, as we can always access a neighbor to determine the slope. The most efficient approach requires only one comparison per step. Let's compare $A[m]$ with its right neighbor, $A[m+1]$. Note that the index $m+1$ is always valid within the loop because the loop condition $l < r$ ensures $m < r$. If $r$ is at most $n-1$, then $m+1$ is also at most $n-1$.\n\nWe have two mutually exclusive cases, since all elements are distinct:\n\n- **Case 1: $A[m] < A[m+1]$**\n  This condition signifies that we are on the strictly increasing slope of the bitonic array. The peak element, which is the maximum, cannot be $A[m]$ or any element to its left, as $A[m+1]$ is greater. Therefore, the peak must lie in the index range to the right of $m$. We can confidently discard the left half of the search space, including $m$, and continue our search in the new range $[m+1, r]$. This is achieved by setting $l = m+1$.\n\n- **Case 2: $A[m] > A[m+1]$**\n  This condition signifies that we are either at the peak itself or on the strictly decreasing slope of the array. In either scenario, the peak must be at index $m$ or an index to its left. It cannot be to the right of $m$, because the sequence from $m$ is decreasing, and the bitonic property precludes a second peak. We can therefore discard the right half of the search space (all indices greater than $m$) and continue our search in the new range $[l, m]$. This is achieved by setting $r = m$.\n\n**3. The Algorithm**\n\nThis logic leads to an iterative algorithm resembling a binary search:\n1. Initialize the search space with $l = 0$ and $r = n-1$.\n2. Loop while $l < r$. This condition ensures the search space contains at least two elements.\n3. In each iteration, calculate the middle index: $m = l + \\lfloor (r - l) / 2 \\rfloor$.\n4. Compare $A[m]$ with $A[m+1]$:\n   - If $A[m] < A[m+1]$, update the lower bound: $l = m+1$.\n   - If $A[m] > A[m+1]$, update the upper bound: $r = m$.\n5. The loop terminates when $l=r$. At this point, the search space has been narrowed down to a single index. This single index, $l$ (or $r$), is the peak index $k$. The loop invariant is that the peak is always contained within the current $[l, r]$ range.\n\n**4. Complexity Analysis**\n\n- **Time Complexity**: In each step of the while loop, the size of the search range, $r-l$, is reduced by approximately half. This process is identical to that of a binary search. The number of iterations is therefore proportional to $\\log_2 n$. Since each iteration performs a constant number of operations (a calculation, a comparison, and an assignment), the total time complexity is $O(\\log n)$.\n- **Space Complexity**: The iterative algorithm uses a constant amount of extra space for the variables $l$, $r$, and $m$. Thus, the space complexity is $O(1)$.\n\nThis derivation directly from first principles fulfills all requirements of the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_peak_index(arr: np.ndarray) -> int:\n    \"\"\"\n    Finds the peak index in a bitonic array using a divide and conquer approach.\n\n    Args:\n        arr: A numpy array of pairwise distinct integers that is guaranteed to be bitonic.\n             A bitonic array is strictly increasing and then strictly decreasing.\n             The array length is guaranteed to be >= 3.\n             The peak is guaranteed not to be at the first or last position.\n\n    Returns:\n        The index of the peak element.\n    \"\"\"\n    n = arr.shape[0]\n    # Initialize the search space to the entire array.\n    # The problem guarantees the peak is not at index 0 or n-1, but the general\n    # binary search formulation handles this correctly.\n    low, high = 0, n - 1\n\n    # The loop continues as long as the search space has more than one element.\n    # The loop invariant is that the peak is always within the [low, high] range.\n    while low < high:\n        # Calculate the middle index, avoiding potential overflow for very large arrays.\n        mid = low + (high - low) // 2\n        \n        # Compare the middle element with its right neighbor to determine if we\n        # are on the increasing or decreasing slope of the bitonic array.\n        if arr[mid] < arr[mid + 1]:\n            # We are on the increasing part. The peak must be to the right of mid.\n            # Discard the left half of the search space, including mid.\n            low = mid + 1\n        else:\n            # We are on the decreasing part (or at the peak itself).\n            # The peak must be at mid or to its left.\n            # Discard the right half of the search space.\n            # Note: We keep `mid` in the search space as it could be the peak.\n            high = mid\n            \n    # When the loop terminates, low == high, and this single index is the peak.\n    return low\n\ndef solve():\n    \"\"\"\n    Processes the test cases provided in the problem statement and prints the results.\n    \"\"\"\n    test_cases = [\n        np.array([1, 3, 8, 12, 4, 2]),\n        np.array([2, 5, 1]),\n        np.array([10, 22, 35, 40, 90, 80, 20, 5, 3, 1]),\n        np.array([-9, -4, -2, -3, -8]),\n        np.array([0, 9, 7, 5, 2]),\n        np.array([1, 2, 3, 4, 5, 7, 6]),\n    ]\n\n    results = []\n    for case in test_cases:\n        peak_index = find_peak_index(case)\n        results.append(peak_index)\n\n    # The final print statement must produce only the specified single-line format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3228689"}, {"introduction": "This final exercise elevates the divide-and-conquer search strategy to a more abstract level, tackling the problem of finding the $k$-th smallest element in the union of two sorted arrays. The key insight is not to partition the arrays themselves, but to partition the rank $k$ and use pivot comparisons to discard a block of elements guaranteed not to contain the final answer. Mastering this problem demonstrates a sophisticated command of the divide-and-conquer paradigm, essential for solving complex data selection tasks efficiently. [@problem_id:3228718]", "problem": "You are given two finite sequences of integers $A$ and $B$ that are individually sorted in non-decreasing order under the standard total order $\\leq$ on the integers. Consider the multiset union of these two sequences, denoted as $U = A \\uplus B$, where multiplicities are preserved (for example, if an element appears $p$ times in $A$ and $q$ times in $B$, it appears $p+q$ times in $U$). For a given positive integer $k$, the task is to determine the $k$-th smallest element of $U$, where the indexing is $1$-based.\n\nThe foundational base for this problem comprises the following core definitions:\n- A total order on a set $S$ is a binary relation $\\leq$ that is reflexive, antisymmetric, transitive, and total. For the integers, the usual $\\leq$ relation holds.\n- A sequence $(x_1, x_2, \\dots, x_n)$ is sorted in non-decreasing order if for all indices $i$ and $j$ with $1 \\leq i < j \\leq n$, we have $x_i \\leq x_j$.\n- The multiset union $A \\uplus B$ of sequences $A$ and $B$ contains every element from $A$ and $B$ with multiplicity equal to the sum of their occurrences in $A$ and $B$.\n\nDesign and implement a program that, without merging $A$ and $B$ into a single array and without scanning linearly across all elements, uses a divide-and-conquer strategy to find the $k$-th smallest element of $U$. The algorithm must be based on recursive or iterative partitioning and comparisons that discard portions of $A$ or $B$ in a manner justified by the ordering properties of sorted sequences. Your method should achieve worst-case time complexity $O(\\log(|A|+|B|))$ and use $O(1)$ additional space.\n\nIf $k < 1$ or $k > |A| + |B|$, where $|A|$ and $|B|$ denote the lengths of $A$ and $B$, respectively, your program must return $-1$ for that test case.\n\nYour program must not read any input. Instead, it must compute results for the following test suite of parameter values and produce a single line of output aggregating all results in order:\n\n- Test case $1$: $A = [1,3,5,7]$, $B = [2,4,6,8,10]$, $k = 5$.\n- Test case $2$: $A = [1,1,1]$, $B = [1,1]$, $k = 4$.\n- Test case $3$: $A = []$, $B = [3,4,5]$, $k = 2$.\n- Test case $4$: $A = [-5,-2,0,3]$, $B = []$, $k = 3$.\n- Test case $5$: $A = [0,2]$, $B = [1,3,5]$, $k = 5$.\n- Test case $6$: $A = [2]$, $B = [-1,0,1]$, $k = 1$.\n- Test case $7$: $A = [1,2]$, $B = [3]$, $k = 10$.\n- Test case $8$: $A = [1000000000]$, $B = [-1000000000,0]$, $k = 2$.\n- Test case $9$: $A = [-2,-2,-1]$, $B = [-2,-1,0]$, $k = 4$.\n\nFinal output format requirement: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases (for example, $[r_1,r_2,\\dots,r_9]$), where each $r_i$ is an integer result for test case $i$.", "solution": "The problem asks for the $k$-th smallest element in the multiset union of two sorted integer sequences, $A$ and $B$, using a divide-and-conquer strategy. The required time complexity is $O(\\log(m+n))$, where $m=|A|$ and $n=|B|$, and space complexity is $O(1)$ (additional space).\n\nFirst, we address the preliminary validation. The problem statement is well-posed, scientifically grounded in the principles of algorithm design, and free of ambiguity or contradiction. It represents a classic computer science problem, often referred to as finding the $k$-th element in two sorted arrays. The constraints on complexity and methodology are stringent but achievable. The problem is therefore deemed valid.\n\nThe core principle of the solution is to iteratively eliminate a fraction of the elements from consideration, with the certainty that the desired $k$-th element does not lie within the discarded portion. This is the essence of a divide-and-conquer approach. A linear scan or a full merge of the arrays would result in a time complexity of $O(|A|+|B|)$ or $O(k)$, which is too slow. An $O(\\log(m+n))$ solution is achieved by a process akin to binary search on the ranks or indices.\n\nLet the lengths of the sequences be $m = |A|$ and $n = |B|$. We are searching for the $k$-th element. The search space effectively consists of the prefixes $A[0 \\dots k-1]$ and $B[0 \\dots k-1]$, as any element beyond these prefixes cannot be the $k$-th smallest unless one of the arrays is exhausted early.\n\nThe algorithm can be implemented iteratively to achieve $O(1)$ space complexity. We maintain pointers, `a_start` and `b_start`, which denote the beginning of the currently considered sub-sequences of $A$ and $B$. Initially, `a_start` = $0$ and `b_start` = $0$. The value of $k$ is updated in each step to reflect the new rank we are seeking in the reduced search space.\n\nThe main loop proceeds as follows:\n\n1.  **Handle Base Cases**:\n    - If one of the sequences is exhausted (e.g., `a_start` $\\ge m$), the $k$-th element must be in the remaining part of the other sequence. The answer is the $(k-1)$-th element (using $0$-based indexing) of the non-empty sequence's current view. For instance, if $A$ is exhausted, the result is $B[\\text{b\\_start} + k - 1]$.\n    - If $k=1$, the problem reduces to finding the minimum of the first elements of the current views of $A$ and $B$, which is $\\min(A[\\text{a\\_start}], B[\\text{b\\_start}])$.\n\n2.  **Divide Step**: The goal is to discard a block of elements. We partition the target rank $k$ into two parts, $i$ and $j$, such that $i+j=k$. A robust choice is to aim for $i \\approx \\lfloor k/2 \\rfloor$ and $j \\approx \\lceil k/2 \\rceil$. We will compare the elements $A[\\text{a\\_start} + i - 1]$ and $B[\\text{b\\_start} + j - 1]$. These are the potential pivots that are roughly $i$ and $j$ elements into their respective current sub-sequences.\n\n3.  **Conquer Step**:\n    - Let's define the number of elements to consider from each array. To simplify the logic and avoid numerous edge cases, we can operate on the smaller of the two current sub-sequences. Let's say the current view of $A$, with length $m_{\\text{curr}} = m - \\text{a\\_start}$, is smaller than or equal to the current view of $B$, with length $n_{\\text{curr}} = n - \\text{b\\_start}$.\n    - We partition $k$ by choosing $i = \\min(m_{\\text{curr}}, \\lfloor k/2 \\rfloor)$ elements from $A$'s prefix and $j = k-i$ elements from $B$'s prefix.\n    - We then compare the pivot elements $p_A = A[\\text{a\\_start} + i - 1]$ and $p_B = B[\\text{b\\_start} + j - 1]$.\n    - **If $p_A \\leq p_B$**: This implies that all elements in $A[\\text{a\\_start} \\dots \\text{a\\_start} + i - 1]$ are smaller than or equal to $p_A$, which is smaller than or equal to $p_B$. The rank of $p_A$ in the combined sorted sequence is at most $((\\text{a\\_start}+i) + (\\text{b\\_start}+j-1)) - (\\text{a\\_start}+\\text{b\\_start}) = i+j-1=k-1$. Thus, none of the first $i$ elements of $A$'s current view can be the $k$-th smallest element. We can safely discard this block of $i$ elements. We update `a_start` by adding $i$ to it and reduce $k$ by $i$. The problem is now to find the $(k-i)$-th element in the new, smaller search space.\n    - **If $p_A > p_B$**: By symmetric reasoning, the element $p_B$ has a rank of at most $((\\text{a\\_start}+i-1) + (\\text{b\\_start}+j)) - (\\text{a\\_start}+\\text{b\\_start}) = i+j-1=k-1$. Therefore, the first $j$ elements of $B$'s current view, $B[\\text{b\\_start} \\dots \\text{b\\_start} + j - 1]$, can be discarded. We update `b_start` by adding $j$ to it and reduce $k$ by $j$.\n\n4.  **Loop Termination**: The loop continues. In each step, we discard a block of elements from the beginning of either A or B. This process is guaranteed to terminate and resembles a binary search on the solution space, leading to a logarithmic time complexity of $O(\\log m + \\log n)$. The process terminates when one of the base cases is met.\n\nAn initial check for the validity of $k$ (i.e., $1 \\leq k \\leq m+n$) is performed, returning $-1$ if $k$ is out of bounds, as specified. This iterative divide-and-conquer algorithm meets all problem requirements.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_kth(A, B, k_orig):\n    \"\"\"\n    Finds the k-th smallest element in the union of two sorted numpy arrays.\n\n    The algorithm uses a divide-and-conquer strategy with O(log(m) + log(n)) time\n    complexity and O(1) extra space.\n    \"\"\"\n    m, n = len(A), len(B)\n    \n    # Validate k. 1-based indexing for k.\n    if k_orig < 1 or k_orig > m + n:\n        return -1\n\n    # Pointers to the start of the current considered slice of arrays\n    a_start, b_start = 0, 0\n    k = k_orig\n\n    while True:\n        m_curr = m - a_start\n        n_curr = n - b_start\n\n        # Base case: one of the arrays is exhausted\n        if m_curr == 0:\n            return B[b_start + k - 1]\n        if n_curr == 0:\n            return A[a_start + k - 1]\n\n        # Base case: k=1, find the minimum of the first elements\n        if k == 1:\n            return min(A[a_start], B[b_start])\n\n        # Divide step: Partition k.\n        # Ensure that the logic is applied to the shorter of the two current subarrays\n        # to guarantee the correctness of indices.\n        if m_curr <= n_curr:\n            # Number of elements to consider from A's prefix\n            i = min(m_curr, k // 2)\n            # Ensure progress when k is small (e.g., k=2 or k=3)\n            # k=1 is a base case, so k//2 is 0 only if k=1, which we don't reach here.\n            # minimum i is 1 for k >= 2.\n            if i == 0: i = 1\n            \n            # Number of elements to consider from B's prefix\n            j = k - i\n\n            # Compare pivot elements\n            if A[a_start + i - 1] <= B[b_start + j - 1]:\n                # Discard the first i elements of A's current view\n                a_start += i\n                k -= i\n            else:\n                # Discard the first j elements of B's current view\n                b_start += j\n                k -= j\n        else: # n_curr < m_curr\n            # Symmetric logic, operating on B as the shorter array\n            j = min(n_curr, k // 2)\n            if j == 0: j = 1\n            i = k - j\n            \n            if B[b_start + j - 1] < A[a_start + i - 1]:\n                # Discard B's prefix\n                b_start += j\n                k -= j\n            else:\n                # Discard A's prefix\n                a_start += i\n                k -= i\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([1, 3, 5, 7]), np.array([2, 4, 6, 8, 10]), 5),\n        (np.array([1, 1, 1]), np.array([1, 1]), 4),\n        (np.array([], dtype=int), np.array([3, 4, 5]), 2),\n        (np.array([-5, -2, 0, 3]), np.array([], dtype=int), 3),\n        (np.array([0, 2]), np.array([1, 3, 5]), 5),\n        (np.array([2]), np.array([-1, 0, 1]), 1),\n        (np.array([1, 2]), np.array([3]), 10),\n        (np.array([1000000000]), np.array([-1000000000, 0]), 2),\n        (np.array([-2, -2, -1]), np.array([-2, -1, 0]), 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, B, k = case\n        result = find_kth(A, B, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3228718"}]}