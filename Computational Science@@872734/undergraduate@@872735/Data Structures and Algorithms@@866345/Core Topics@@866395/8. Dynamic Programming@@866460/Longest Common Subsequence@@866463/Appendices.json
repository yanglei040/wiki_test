{"hands_on_practices": [{"introduction": "Dynamic programming is powerful because its core logic can be adapted to solve a wide range of related problems. This first exercise [@problem_id:3247627] challenges you to modify the standard Longest Common Subsequence algorithm to handle a hybrid constraint: finding the longest string that is a subsequence of one string and a contiguous substring of another. This practice is invaluable for learning how to adjust DP recurrence relations to fit new and specific requirements, a fundamental skill in algorithmic problem-solving.", "problem": "You are given two finite strings over the deoxyribonucleic acid (DNA) alphabet $\\{\\texttt{A}, \\texttt{C}, \\texttt{G}, \\texttt{T}\\}$. Let $\\texttt{A}$ denote the string $A = \\texttt{ACGTACGTA}$ and $\\texttt{B}$ denote the string $B = \\texttt{TACGATACGTAA}$. A string $S$ is a subsequence of a string $X$ if $S$ can be obtained by deleting zero or more characters from $X$ without reordering the remaining characters. A string $S$ is a contiguous substring of a string $Y$ if $S$ consists of a sequence of consecutive characters in $Y$.\n\nUsing only these definitions and the principle of optimal substructure from dynamic programming, derive from first principles a correct method to compute the exact length $L$ of the longest string that is simultaneously a subsequence of $A$ and a contiguous substring of $B$. Then compute $L$ for the given $A$ and $B$. Report only the numerical value of $L$. No rounding is required.", "solution": "To solve this problem, we must find the length of the longest string $S$ that is a subsequence of string $A$ and a contiguous substring of string $B$. A brute-force approach of checking every substring of $B$ to see if it is a subsequence of $A$ would be inefficient. A more effective method uses dynamic programming.\n\nLet $A$ be a string of length $m$ and $B$ be a string of length $n$. We can define a DP state $dp[i][j]$ to represent the length of the longest string that is a subsequence of the prefix $A[1..i]$ and is also a **suffix** of the prefix $B[1..j]$. The \"suffix\" constraint correctly models the \"contiguous\" requirement for string $B$, as any contiguous substring must be a suffix of some prefix of $B$.\n\nThe recurrence relation for $dp[i][j]$ is derived by considering the characters $A[i]$ and $B[j]$:\n\n1.  **Case 1: $A[i] = B[j]$**. If the characters match, they can extend a common string. This string would be formed by appending the character $A[i]$ to the longest string that is a subsequence of $A[1..i-1]$ and a suffix of $B[1..j-1]$. The length is therefore one greater than the solution to this subproblem.\n    $dp[i][j] = 1 + dp[i-1][j-1]$\n\n2.  **Case 2: $A[i] \\neq B[j]$**. If the characters do not match, then $A[i]$ cannot be used to match the final character $B[j]$ of the suffix. However, a string that is a suffix of $B[1..j]$ might still be a subsequence of the shorter prefix $A[1..i-1]$. Thus, we take the result from that subproblem.\n    $dp[i][j] = dp[i-1][j]$\n\nThe base cases for the recurrence are when either prefix is empty:\n$dp[i][0] = 0$ for all $0 \\le i \\le m$.\n$dp[0][j] = 0$ for all $0 \\le j \\le n$.\n\nWe can build an $(m+1) \\times (n+1)$ table to compute the values of $dp[i][j]$. After filling the table, the entry $dp[m][j]$ gives the length of the longest string that is a subsequence of the entire string $A$ and a suffix of $B[1..j]$. Since the desired contiguous substring of $B$ can end at any position $j$, the final answer $L$ is the maximum value found in the last row of the DP table.\n$$L = \\max_{1 \\le j \\le n} dp[m][j]$$\n\nApplying this algorithm to the given strings $A = \\texttt{ACGTACGTA}$ and $B = \\texttt{TACGATACGTAA}$ results in a DP table where the maximum value in the final row is $7$. This corresponds to the string $\\texttt{ATACGTA}$, which is a contiguous substring of $B$ (from index 5 to 11) and is also a subsequence of $A$ ($\\underline{A}\\text{CG}\\underline{T}\\underline{A}\\underline{C}\\underline{G}\\underline{T}\\underline{A}$).", "answer": "$$\n\\boxed{7}\n$$", "id": "3247627"}, {"introduction": "Once we can determine the length of an optimal solution, the next step is often to construct the solution itself. This problem [@problem_id:3247478] takes that a step further by asking for a very specific LCS: the one that comes first in lexicographical order. Solving this requires a two-phase approach: first, using dynamic programming to understand the solution space, and second, applying a greedy strategy to construct the final string. This exercise demonstrates how to build concrete solutions from DP tables while satisfying additional optimization criteria.", "problem": "Consider two finite strings over a fixed ordered alphabet. Let the alphabet be the lowercase English letters in their usual order, and define lexicographic order in the customary way induced by this alphabet. A subsequence of a string is any sequence obtained by deleting zero or more characters without reordering the remaining characters. A common subsequence of two strings is a subsequence that appears in both. The Longest Common Subsequence (LCS) is any common subsequence of maximum possible length.\n\nStarting from the fundamental definitions above, design an algorithm that, given two input strings $A$ and $B$, computes the lexicographically smallest Longest Common Subsequence (LCS) of $A$ and $B$. Your derivation must begin from first principles (definitions of subsequence, common subsequence, and lexicographic order) and must justify the correctness of the algorithm without appealing to shortcut formulas. Also justify the time complexity of your algorithm in terms of $|A|$, $|B|$, and the alphabet size.\n\nThen, apply your algorithm to the specific inputs $A = \\text{\"banana\"}$ and $B = \\text{\"ananas\"}$ to obtain the lexicographically smallest LCS string $S$. Finally, define the numerical encoding\n$$\nH(S) = \\sum_{i=1}^{|S|} \\text{code}(S_i)\\cdot 31^{|S|-i},\n$$\nwhere $\\text{code}(\\text{'a'}) = 1, \\text{code}(\\text{'b'}) = 2, \\ldots, \\text{code}(\\text{'z'}) = 26$ and $S_i$ denotes the $i$-th character of $S$. Compute $H(S)$ exactly. Express the final answer as an exact integer with no rounding.", "solution": "Let the two input strings be $A$ and $B$, with lengths $m = |A|$ and $n = |B|$. The alphabet is denoted by $\\Sigma$, with size $\\sigma$.\n\nA subsequence of a string $X$ is formed by deleting zero or more characters from $X$. For instance, \"ana\" is a subsequence of \"banana\". A common subsequence of $A$ and $B$ is a string that is a subsequence of both $A$ and $B$. The Longest Common Subsequence (LCS) is a common subsequence with the maximum possible length.\n\nTo find the lexicographically smallest LCS, a greedy approach that constructs the result string from left to right is appropriate. At each step, we must select the smallest possible character that can begin a valid LCS of the remaining portions of the strings.\n\nTo support this greedy strategy, we require a way to know the length of the LCS for any pair of suffixes of $A$ and $B$. We define a two-dimensional array, $L$, where $L[i][j]$ stores the length of the LCS of the suffixes $A[i..m-1]$ and $B[j..n-1]$. We use $0$-based indexing for strings and the DP table. The table dimensions will be $(m+1) \\times (n+1)$.\n\nThe values in $L[i][j]$ are computed using dynamic programming, based on the following recurrence relation:\n$$\nL[i][j] =\n\\begin{cases}\n  0  \\text{if } i=m \\text{ or } j=n \\\\\n  1 + L[i+1][j+1]  \\text{if } A[i] = B[j] \\\\\n  \\max(L[i+1][j], L[i][j+1])  \\text{if } A[i] \\neq B[j]\n\\end{cases}\n$$\nThe table is filled by iterating $i$ from $m$ down to $0$ and $j$ from $n$ down to $0$. The length of the LCS of the full strings $A$ and $B$ is then $L[0][0]$.\n\nWith the $L$ table pre-computed, we can construct the lexicographically smallest LCS, let's call it $S$. We initialize $S$ to the empty string, and set current pointers in $A$ and $B$ to $i=0$ and $j=0$. We iterate to build $S$ character by character.\n\nAt each step of the construction, we are at indices $(i, j)$ in strings $A$ and $B$. We need to find the next character of $S$. The total length of the LCS of the remaining suffixes $A[i..m-1]$ and $B[j..n-1]$ is $L[i][j]$. We iterate through each character $c$ in the alphabet $\\Sigma$ in lexicographical order (from 'a' to 'z'). For each $c$, we find its first occurrence in $A$ at or after index $i$ (say, at index $i'$) and in $B$ at or after index $j$ (say, at index $j'$).\n\nIf we choose this character $c$ as the next character of our LCS, we are committing to using $A[i']$ and $B[j']$. The length of the common subsequence we can form from this point is $1$ (for character $c$) plus the length of the LCS of the remaining suffixes, $A[i'+1..m-1]$ and $B[j'+1..n-1]$, which is given by $L[i'+1][j'+1]$.\n\nTo ensure we are on the path to a valid LCS of maximal length, we must only select a character $c$ if it leads to a total length of $L[i][j]$. That is, the character $c$ (found at $i'$ and $j'$) is a valid choice if and only if:\n$$L[i][j] = 1 + L[i'+1][j'+1]$$\nSince we iterate through $c \\in \\Sigma$ in increasing lexicographical order, the first character $c$ that satisfies this condition is guaranteed to be the lexicographically smallest possible character at this position of an LCS.\n\nOnce such a character $c$ is found, we append it to $S$, and update our positions in $A$ and $B$ to $i=i'+1$ and $j=j'+1$. We repeat this process until the length of the remaining LCS becomes $0$ (i.e., $L[i][j]=0$).\n\nThe overall algorithm is:\n1.  Initialize an $(m+1) \\times (n+1)$ table $L$.\n2.  Fill $L$ using the DP recurrence for LCS of suffixes. $i$ from $m$ down to $0$, $j$ from $n$ down to $0$.\n3.  Initialize $S = \\text{\"\"}$, $i=0$, $j=0$.\n4.  While $L[i][j]  0$:\n    a. For each character $c$ from 'a' to 'z':\n        i.  Find the smallest index $i' \\ge i$ such that $A[i'] = c$.\n        ii. Find the smallest index $j' \\ge j$ such that $B[j'] = c$.\n        iii. If both $i'$ and $j'$ exist, check if $L[i][j] = 1 + L[i'+1][j'+1]$.\n        iv. If the condition holds, append $c$ to $S$, update $i=i'+1$, $j=j'+1$, and break the inner loop (over characters) to proceed to the next character of $S$.\n5.  Return $S$.\n\nThe correctness of this algorithm stems from the fact that the pre-computed $L$ table allows the greedy construction to make locally optimal choices (the smallest character) that are guaranteed to be part of a globally optimal solution (an LCS). The time complexity is dominated by the DP table computation and pre-computation of next character occurrences, resulting in $O(m \\cdot n + (m+n)\\sigma)$. For a fixed alphabet size $\\sigma=26$, this is $O(m \\cdot n)$.\n\nApplying this algorithm to $A = \\text{\"banana\"}$ and $B = \\text{\"ananas\"}$, we first compute the LCS length table for all suffixes. The length of the LCS for the full strings is $L[0][0]=5$. The construction proceeds as follows:\n- We seek the first character. Iterating from 'a', we find that 'a' is a valid choice. We append 'a' to our result $S$ and advance our pointers in $A$ and $B$.\n- For the second character, we test 'a' again but find it doesn't lead to an LCS of the required remaining length. We test 'b', 'c', ..., until we find 'n' is a valid choice. We append 'n' to $S$.\n- This process is repeated. At each step, we choose the alphabetically first character that keeps us on a path to a full-length LCS.\n- Following this procedure, the constructed string is $S = \\text{\"anana\"}$.\n\nThe final step is to compute the hash $H(S)$ for $S = \\text{\"anana\"}$.\n$H(S) = \\text{code}(\\text{'a'}) \\cdot 31^4 + \\text{code}(\\text{'n'}) \\cdot 31^3 + \\text{code}(\\text{'a'}) \\cdot 31^2 + \\text{code}(\\text{'n'}) \\cdot 31^1 + \\text{code}(\\text{'a'}) \\cdot 31^0$\nUsing the codes $\\text{code}(\\text{'a'}) = 1$ and $\\text{code}(\\text{'n'}) = 14$:\n$H(S) = 1 \\cdot (923521) + 14 \\cdot (29791) + 1 \\cdot (961) + 14 \\cdot (31) + 1 \\cdot (1)$\n$H(S) = 923521 + 417074 + 961 + 434 + 1$\n$H(S) = 1341991$", "answer": "$$\\boxed{1341991}$$", "id": "3247478"}, {"introduction": "In many real-world scenarios, there can be multiple, equally valid optimal solutions. This advanced exercise [@problem_id:3247580] moves beyond finding just one LCS to an even more challenging task: counting every distinct LCS that exists. This requires a sophisticated extension of the standard DP approach, forcing you to carefully consider how different solution paths might generate the same subsequence. Mastering this technique is key to tackling complex combinatorial enumeration and optimization problems where understanding the full diversity of optimal solutions is critical.", "problem": "You are given two finite strings over a fixed alphabet. A subsequence of a string is obtained by deleting zero or more symbols without changing the relative order of the remaining symbols. The Longest Common Subsequence (LCS) of two strings is any subsequence of maximum possible length that appears as a subsequence of both strings. Starting strictly from the definitions of subsequence and the optimal substructure property that arises from considering prefixes of the input strings, derive a dynamic programming procedure that counts the number of distinct LCSs of two strings. Your derivation must define a recurrence over prefixes, justify base cases, and argue why your count does not overcount identical subsequences that can be realized via different alignments.\n\nAfter deriving your method, apply it to the concrete strings\n- $A = \\text{BACBCA}$ of length $6$,\n- $B = \\text{ABCABA}$ of length $6$,\nand compute the number of distinct LCSs of $A$ and $B$. Report only the final count as an exact integer. No rounding is required. The final answer must be a single real-valued number.", "solution": "The problem asks for a dynamic programming procedure to count the number of distinct Longest Common Subsequences (LCSs) of two strings, $A$ and $B$. Let their lengths be $m$ and $n$.\n\nThe derivation requires two DP stages. First, we compute the length of the LCS for all pairs of prefixes. Second, we use this information to count the distinct LCSs.\n\nLet $L(i,j)$ be the length of the LCS of prefixes $A[1..i]$ and $B[1..j]$. This is computed using the standard LCS recurrence:\n$$ L(i,j) = \\begin{cases} 1 + L(i-1, j-1)  \\text{if } A[i]=B[j] \\\\ \\max(L(i-1,j), L(i,j-1))  \\text{if } A[i] \\neq B[j] \\end{cases} $$\nwith base cases $L(i,0) = L(0,j) = 0$.\n\nNext, let $C(i,j)$ be the number of distinct LCSs of $A[1..i]$ and $B[1..j]$. We derive a recurrence for $C(i,j)$ using the pre-computed $L$ table.\nThe base cases are $C(i,0) = 1$ and $C(0,j) = 1$ for all $i,j$, as the empty string is the only LCS with an empty string.\n\nFor $i, j > 0$:\n1.  **If $A[i] = B[j]$**: The LCSs of $(A_i, B_j)$ are formed by appending $A[i]$ to each LCS of $(A_{i-1}, B_{j-1})$. Any LCS from subproblems $(A_{i-1}, B_j)$ or $(A_i, B_{j-1})$ would be strictly shorter. Thus, the number of distinct LCSs is simply inherited from the subproblem $(A_{i-1}, B_{j-1})$.\n    $C(i,j) = C(i-1, j-1)$\n\n2.  **If $A[i] \\neq B[j]$**: The LCSs for $(A_i, B_j)$ are the union of LCSs from subproblems $(A_{i-1}, B_j)$ and $(A_i, B_{j-1})$. The length of these LCSs is $L(i,j) = \\max(L(i-1,j), L(i,j-1))$.\n    - If $L(i-1,j) > L(i,j-1)$, all LCSs come from $(A_{i-1}, B_j)$. So, $C(i,j) = C(i-1,j)$.\n    - If $L(i,j-1) > L(i-1,j)$, all LCSs come from $(A_i, B_{j-1})$. So, $C(i,j) = C(i,j-1)$.\n    - If $L(i-1,j) = L(i,j-1)$, LCSs can come from both subproblems. We must sum their counts, but subtract the count of any LCSs they have in common to avoid overcounting. The set of common LCSs is the set of LCSs of $(A_{i-1}, B_{j-1})$.\n        - If the LCSs from $(A_{i-1}, B_{j-1})$ are shorter than the LCSs from $(A_i, B_j)$, i.e., $L(i-1,j-1)  L(i,j)$, the intersection is empty. The counts are simply added: $C(i,j) = C(i-1,j) + C(i,j-1)$.\n        - If the LCSs from $(A_{i-1}, B_{j-1})$ have the same length, i.e., $L(i-1,j-1) = L(i,j)$, then the LCSs of $(A_{i-1}, B_{j-1})$ are exactly the intersection. We use the Principle of Inclusion-Exclusion: $C(i,j) = C(i-1,j) + C(i,j-1) - C(i-1,j-1)$.\n\nApplying this method to $A = \\text{BACBCA}$ and $B = \\text{ABCABA}$:\n\nFirst, the $L(i,j)$ table is computed:\n$$\nL = \\begin{pmatrix}\n  \\text{ }  \\text{A}  \\text{B}  \\text{C}  \\text{A}  \\text{B}  \\text{A} \\\\\n\\text{ }  0  0  0  0  0  0  0 \\\\\n\\text{B}  0  0  1  1  1  1  1 \\\\\n\\text{A}  0  1  1  1  2  2  2 \\\\\n\\text{C}  0  1  1  2  2  2  2 \\\\\n\\text{B}  0  1  2  2  2  3  3 \\\\\n\\text{C}  0  1  2  3  3  3  3 \\\\\n\\text{A}  0  1  2  3  4  4  4\n\\end{pmatrix}\n$$\nThe length of the LCS is $L(6,6)=4$.\n\nNext, the $C(i,j)$ table is computed using the recurrence and the $L$ table:\n$$\nC = \\begin{pmatrix}\n  \\text{ }  \\text{A}  \\text{B}  \\text{C}  \\text{A}  \\text{B}  \\text{A} \\\\\n\\text{ }  1  1  1  1  1  1  1 \\\\\n\\text{B}  1  1  1  1  1  1  1 \\\\\n\\text{A}  1  1  1  1  2  2  2 \\\\\n\\text{C}  1  1  1  2  2  2  2 \\\\\n\\text{B}  1  1  2  2  2  3  3 \\\\\n\\text{C}  1  1  2  3  3  3  3 \\\\\n\\text{A}  1  2  2  3  3  3  4\n\\end{pmatrix}\n$$\nFor example, to compute $C(6,6)$: since $A[6]=B[6]=\\text{'A'}$, $C(6,6) = C(5,5)$.\nTo compute $C(5,5)$: $A[5]=\\text{'C'} \\neq B[5]=\\text{'B'}$. From the $L$ table, $L(4,5)=3$ and $L(5,4)=3$. Lengths are equal. Also, $L(4,4)=2$, which is less than $L(5,5)=3$. Thus, $C(5,5)=C(4,5) + C(5,4)$.\nThe computation continues until the base cases.\nThe final value in the table is $C(6,6) = 4$.\n\nThere are 4 distinct Longest Common Subsequences: `BABA`, `ACBA`, `BCBA`, and `ABCA`.", "answer": "$$\\boxed{4}$$", "id": "3247580"}]}