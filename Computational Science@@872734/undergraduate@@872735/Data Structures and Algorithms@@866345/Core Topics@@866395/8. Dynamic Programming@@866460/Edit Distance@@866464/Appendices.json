{"hands_on_practices": [{"introduction": "Let's begin by exploring a simplified version of edit distance. This first exercise restricts our toolkit to only substitutions, which helps clarify the unique roles that insertions and deletions play in the more general Levenshtein distance. By calculating this restricted distance, you'll gain a foundational understanding of what is commonly known as the Hamming distance, a fundamental concept in coding theory. [@problem_id:3230949]", "problem": "Consider two strings $S$ and $T$ over a finite alphabet. The classical edit distance (Levenshtein distance) is defined as the minimum total cost to transform one string into another using the operations substitution, insertion, and deletion, each assigned a nonnegative cost. In this problem, assume insertion and deletion are disallowed, and substitution is the only permitted operation. Each exact character match has cost $0$, and each substitution has cost $1$. Under these restrictions, both input strings must have equal length.\n\nLet $S$ be the $24$-character string obtained by repeating the pattern $\\text{\"abcd\"}$ exactly $6$ times, and let $T$ be the $24$-character string obtained by repeating the pattern $\\text{\"abce\"}$ exactly $6$ times. Explicitly,\n$S = \\text{\"abcdabcdabcdabcdabcdabcd\"}$ and $T = \\text{\"abceabceabceabceabceabce\"}$.\nCompute the restricted edit distance between $S$ and $T$ under the above operation model. Your final answer must be a single integer, and no rounding is required.", "solution": "The problem asks for the computation of a restricted edit distance between two strings, $S$ and $T$. I will first validate the problem statement.\n\n### Step 1: Extract Givens\n- The allowed operation is substitution only. Insertions and deletions are disallowed.\n- The cost of an exact character match is $0$.\n- The cost of a substitution (mismatch) is $1$.\n- A constraint is that the input strings must have equal length.\n- String $S$ has length $24$ and is formed by repeating the pattern $\\text{\"abcd\"}$ exactly $6$ times. So, $S = \\text{\"abcdabcdabcdabcdabcdabcd\"}$.\n- String $T$ has length $24$ and is formed by repeating the pattern $\\text{\"abce\"}$ exactly $6$ times. So, $T = \\text{\"abceabceabceabceabceabce\"}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, being a specific instance of a string metric problem common in computer science and discrete mathematics. The defined \"restricted edit distance\" is well-known as the Hamming distance, which is defined for strings of equal length. The problem is well-posed: the strings are explicitly defined, their lengths are equal ($24$), satisfying the stated constraint, and the cost function is unambiguous. All necessary information is provided and is internally consistent. The problem is objective and formalizable. Therefore, the problem is deemed valid.\n\n### Solution\nLet the two strings be $S$ and $T$, each of length $N$. Let $S = s_1s_2...s_N$ and $T = t_1t_2...t_N$, where $s_i$ and $t_i$ are the characters at the $i$-th position of $S$ and $T$, respectively.\n\nThe problem defines a restricted edit distance where only substitution is a permissible operation. The cost of transforming $S$ to $T$ is the sum of the costs of the operations at each position. Since only substitution is allowed, we compare the characters at each position $i$ from $1$ to $N$. The cost function for a single position $i$, let's call it $c_i$, is given as:\n$c_i = 0$ if $s_i = t_i$ (a match)\n$c_i = 1$ if $s_i \\neq t_i$ (a substitution)\n\nThe total restricted edit distance, which we denote by $D(S, T)$, is the sum of these costs over all positions. This is formally equivalent to the Hamming distance.\n$$D(S, T) = \\sum_{i=1}^{N} c_i$$\n\nIn this problem, the strings are $S = \\text{\"abcdabcdabcdabcdabcdabcd\"}$ and $T = \\text{\"abceabceabceabceabceabce\"}$.\nThe length of both strings is $N=24$.\n\nString $S$ is constructed by the $6$-fold repetition of the base pattern $P_S = \\text{\"abcd\"}$.\nString $T$ is constructed by the $6$-fold repetition of the base pattern $P_T = \\text{\"abce\"}$.\n\nThe length of each pattern is $ L=4$. The total length is $N = 6 \\times L = 6 \\times 4 = 24$.\n\nBecause of the repetitive structure of the strings, the total distance $D(S, T)$ can be calculated by first finding the distance between the base patterns, $D(P_S, P_T)$, and then multiplying by the number of repetitions, which is $6$.\n\nLet's compute the distance $D(P_S, P_T)$ for the patterns $P_S = \\text{\"abcd\"}$ and $P_T = \\text{\"abce\"}$. We compare them character by character:\n- Position $1$: 'a' vs 'a'. The characters match, so the cost is $0$.\n- Position $2$: 'b' vs 'b'. The characters match, so the cost is $0$.\n- Position $3$: 'c' vs 'c'. The characters match, so the cost is $0$.\n- Position $4$: 'd' vs 'e'. The characters do not match, so the cost is $1$.\n\nThe distance for one pattern block is the sum of these costs:\n$$D(P_S, P_T) = 0 + 0 + 0 + 1 = 1$$\n\nThe total distance $D(S, T)$ is the sum of the distances of the $6$ corresponding blocks. Since each block is identical, the total distance is $6$ times the distance of a single block.\n$$D(S, T) = 6 \\times D(P_S, P_T)$$\n$$D(S, T) = 6 \\times 1 = 6$$\n\nAlternatively, we can write out the full sum. Let $S_k$ and $T_k$ be the $k$-th blocks of the strings, for $k \\in \\{1, 2, 3, 4, 5, 6\\}$. Then $S = S_1 S_2 S_3 S_4 S_5 S_6$ and $T = T_1 T_2 T_3 T_4 T_5 T_6$.\nSince $S_k = P_S$ and $T_k = P_T$ for all $k$, the total distance is:\n$$D(S, T) = \\sum_{k=1}^{6} D(S_k, T_k) = \\sum_{k=1}^{6} D(P_S, P_T) = \\sum_{k=1}^{6} 1 = 6$$\n\nThe restricted edit distance between $S$ and $T$ is the total number of positions at which the characters differ. In each of the $6$ blocks of length $4$, only the last character is different. Therefore, there are a total of $6$ mismatches. Since each mismatch contributes a cost of $1$, the total cost is $6$.", "answer": "$$\n\\boxed{6}\n$$", "id": "3230949"}, {"introduction": "Now, let's apply the core principles of edit distance in a more creative context. Instead of transforming one string into another, this problem challenges you to transform a single string into its closest 'palindromic' version. This exercise demonstrates the flexibility of dynamic programming and how its logic can be adapted to solve problems involving structural properties like symmetry. [@problem_id:3230960]", "problem": "Let $S$ be the string $S=\\text{\"abracad\"}$ with length $n=7$. A palindrome is a string $P$ such that $P$ is identical to its reversal, i.e., $P=P^{\\text{rev}}$. Consider the standard Levenshtein edit operations with unit cost $1$ per operation: single-character insertion, single-character deletion, and single-character substitution. Starting from the foundational definitions of these edit operations and the structural property of palindromes, derive a method from first principles to determine the minimum number of edits required to transform $S$ into any palindrome. Compute this minimum number of edits exactly. The final answer must be a single real-valued number. No rounding is required.", "solution": "The user wants me to find the minimum number of edit operations (insertion, deletion, substitution, all with unit cost) to transform a given string into a palindrome.\n\n### Step 1: Extract Givens\n- The string is $S = \\text{\"abracad\"}$.\n- The length of the string is $n=7$.\n- A palindrome is a string $P$ that is identical to its reversal, $P = P^{\\text{rev}}$.\n- The allowed edit operations are single-character insertion, deletion, and substitution.\n- Each operation has a cost of $1$.\n- The objective is to find the minimum total cost to transform $S$ into any palindrome.\n\n### Step 2: Validate Using Extracted Givens\nThe problem presented is a classic problem in the field of algorithms and data structures, specifically concerning string manipulation and dynamic programming.\n- **Scientifically Grounded (Critical)**: The problem is based on well-defined mathematical and computer science concepts: strings, palindromes, and Levenshtein edit distance. The concepts are sound and rigorously defined.\n- **Well-Posed**: The problem is well-posed. It asks for a minimum value over a defined set of operations, which guarantees that a unique, stable, and meaningful numerical solution exists.\n- **Objective (Critical)**: The problem is stated in precise, objective language, free of ambiguity or subjective claims.\n\nThe problem does not exhibit any of the invalidity flaws:\n1.  It does not violate any scientific or mathematical principles.\n2.  It is a formalizable problem directly related to edit distance.\n3.  The setup is complete and consistent.\n4.  The conditions are purely computational, not physical, and are thus feasible.\n5.  It is well-structured and admits a unique solution.\n6.  It is a standard, non-trivial problem requiring a specific algorithmic approach.\n7.  The result is verifiable.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with a full derivation and solution.\n\n### Derivation of Method\nLet the given string be $S$ of length $n$. We wish to find the minimum number of edits (insertions, deletions, or substitutions) to transform $S$ into a palindrome. Let this minimum number of edits for a generic substring $S[i \\dots j]$ be denoted by the function $D(i, j)$. Our goal is to compute $D(0, n-1)$.\n\nWe can establish a recurrence relation for $D(i, j)$ by considering the characters at the ends of the substring, $S[i]$ and $S[j]$.\n\n**Base Cases:**\n- For a substring of length $1$, $S[i \\dots i]$, it is already a palindrome. Thus, no edits are needed. $D(i, i) = 0$.\n- For a substring of length $0$ (e.g., when $j  i$), it is also trivially a palindrome. The cost is $0$.\n\n**Recursive Step:**\nConsider the substring $S[i \\dots j]$ where $i  j$.\n1.  **Case 1: The outermost characters match, $S[i] = S[j]$.**\n    If the characters at the ends of the substring match, they already satisfy the palindrome property with respect to each other. We do not need to edit them. The problem reduces to making the inner substring $S[i+1 \\dots j-1]$ a palindrome. Therefore, the minimum number of edits is the same as the number of edits required for the inner substring.\n    $$D(i, j) = D(i+1, j-1) \\quad \\text{if } S[i] = S[j]$$\n\n2.  **Case 2: The outermost characters do not match, $S[i] \\neq S[j]$.**\n    Since $S[i]$ and $S[j]$ do not match, we must perform at least one edit operation to resolve this mismatch. We have three fundamental choices, analogous to the Levenshtein distance operations:\n    a. **Substitution:** We can change one of the characters to match the other. For instance, we could substitute $S[i]$ with a character equal to $S[j]$, or substitute $S[j]$ with a character equal to $S[i]$. In either case, this costs $1$ edit. After this operation, the ends match, and we are left with the subproblem of making the inner string $S[i+1 \\dots j-1]$ a palindrome. The total cost for this choice is $1 + D(i+1, j-1)$.\n    b. **Deletion/Insertion (on the left):** We can delete the character $S[i]$. This costs $1$ edit. We are then left with the subproblem of making the remaining substring $S[i+1 \\dots j]$ a palindrome. The total cost is $1 + D(i+1, j)$. This operation is equivalent in outcome to transforming $S[i \\dots j-1]$ into a palindrome and then inserting a character at the beginning to match $S[j]$.\n    c. **Deletion/Insertion (on the right):** Symmetrically, we can delete the character $S[j]$. This costs $1$ edit. We are left with the subproblem of making $S[i \\dots j-1]$ a palindrome. The total cost is $1 + D(i, j-1)$.\n\n    Since we want the minimum number of edits, we must choose the operation that results in the minimum total cost.\n    $$D(i, j) = 1 + \\min \\left( D(i+1, j), D(i, j-1), D(i+1, j-1) \\right) \\quad \\text{if } S[i] \\neq S[j]$$\n    \nAn alternative way to frame this problem is to note that making $S$ a palindrome is equivalent to finding the minimum edit distance between $S$ and its reverse, $S^{\\text{rev}}$. Let $S = \\text{\"abracad\"}$ and $S^{\\text{rev}} = \\text{\"dacabra\"}$. The number of edits to transform $S$ into a palindrome is half the edit distance between $S$ and $S^{\\text{rev}}$, because each edit (insertion, deletion, substitution) on $S$ to make it more like $S^{\\text{rev}}$ fixes a symmetrical problem. For example, changing $S[0]$ ('a') to 'd' costs one edit and moves it towards matching $S^{\\text{rev}}[0]$. This is not quite right. The number of edits to make $S$ a palindrome is exactly the Levenshtein distance between $S$ and $S^{\\text{rev}}$, but calculated on a specific DP table. Let's stick to the first derivation, which is more direct and less prone to off-by-one errors.\n\n### Computation\nWe apply this method to the string $S = \\text{\"abracad\"}$ ($n=7$, indices $0$ to $6$). Let `dp[i][j]` be the table storing $D(i, j)$.\n\n**Length $L=1$:**\n`dp[i][i] = 0` for all $i \\in \\{0, \\dots, 6\\}$.\n\n**Length $L=2$:**\n- `dp[0][1]` (\"ab\"): $S[0] \\neq S[1] \\implies 1 + \\min(dp[1][1], dp[0][0], dp[1][0]) = 1 + \\min(0, 0, 0) = 1$.\n- By the same logic, for all substrings of length $2$ with non-matching characters:\n  `dp[1][2]`(\"br\") $= 1$, `dp[2][3]`(\"ra\") $= 1$, `dp[3][4]`(\"ac\") $= 1$, `dp[4][5]`(\"ca\") $= 1$, `dp[5][6]`(\"ad\") $= 1$.\n\n**Length $L=3$:**\n- `dp[0][2]` (\"abr\"): $S[0] \\neq S[2] \\implies 1 + \\min(dp[1][2], dp[0][1], dp[1][1]) = 1 + \\min(1, 1, 0) = 1$.\n- `dp[1][3]` (\"bra\"): $S[1] \\neq S[3] \\implies 1 + \\min(dp[2][3], dp[1][2], dp[2][2]) = 1 + \\min(1, 1, 0) = 1$.\n- `dp[2][4]` (\"rac\"): $S[2] \\neq S[4] \\implies 1 + \\min(dp[3][4], dp[2][3], dp[3][3]) = 1 + \\min(1, 1, 0) = 1$.\n- `dp[3][5]` (\"aca\"): $S[3] = S[5] \\implies dp[4][4] = 0$.\n- `dp[4][6]` (\"cad\"): $S[4] \\neq S[6] \\implies 1 + \\min(dp[5][6], dp[4][5], dp[5][5]) = 1 + \\min(1, 1, 0) = 1$.\n\n**Length $L=4$:**\n- `dp[0][3]` (\"abra\"): $S[0] = S[3] \\implies dp[1][2] = 1$.\n- `dp[1][4]` (\"brac\"): $S[1] \\neq S[4] \\implies 1 + \\min(dp[2][4], dp[1][3], dp[2][3]) = 1 + \\min(1, 1, 1) = 2$.\n- `dp[2][5]` (\"raca\"): $S[2] \\neq S[5] \\implies 1 + \\min(dp[3][5], dp[2][4], dp[3][4]) = 1 + \\min(0, 1, 1) = 1$.\n- `dp[3][6]` (\"acad\"): $S[3] \\neq S[6] \\implies 1 + \\min(dp[4][6], dp[3][5], dp[4][5]) = 1 + \\min(1, 0, 1) = 1$.\n\n**Length $L=5$:**\n- `dp[0][4]` (\"abrac\"): $S[0] \\neq S[4] \\implies 1 + \\min(dp[1][4], dp[0][3], dp[1][3]) = 1 + \\min(2, 1, 1) = 2$.\n- `dp[1][5]` (\"braca\"): $S[1] \\neq S[5] \\implies 1 + \\min(dp[2][5], dp[1][4], dp[2][4]) = 1 + \\min(1, 2, 1) = 2$.\n- `dp[2][6]` (\"racad\"): $S[2] \\neq S[6] \\implies 1 + \\min(dp[3][6], dp[2][5], dp[3][5]) = 1 + \\min(1, 1, 0) = 1$.\n\n**Length $L=6$:**\n- `dp[0][5]` (\"abraca\"): $S[0] = S[5] \\implies dp[1][4] = 2$.\n- `dp[1][6]` (\"bracad\"): $S[1] \\neq S[6] \\implies 1 + \\min(dp[2][6], dp[1][5], dp[2][5]) = 1 + \\min(1, 2, 1) = 2$.\n\n**Length $L=7$:**\n- `dp[0][6]` (\"abracad\"): $S[0] \\neq S[6] \\implies 1 + \\min(dp[1][6], dp[0][5], dp[1][5]) = 1 + \\min(2, 2, 2) = 3$.\n\nThe minimum number of edits required to transform the string $S=\\text{\"abracad\"}$ into a palindrome is given by `dp[0][6]`, which is $3$.\n\nAs an example, one possible sequence of 3 edits is:\n1.  Change $S[1]$ ('b') to 'd'.\n2.  Change $S[2]$ ('r') to 'c'.\nThe original string is \"abracad\". We are targeting a palindrome.\nA possible target: \"adacada\". Edits: change 'b' to 'd' (1), change 'r' to 'c' (2). The string is now \"adacad\". This is not a palindrome.\nAnother example: $S=\\text{\"abracad\"}$. Change $S[1]$ ('b') to 'a', string becomes \"aaracad\". Change $S[2]$ ('r') to 'c', string becomes \"aacacad\". Change $S[6]$ ('d') to 'a', string becomes \"aacacaa\", which is a palindrome. Total edits: 3. This matches the computed result.", "answer": "$$\\boxed{3}$$", "id": "3230960"}, {"introduction": "Our final practice takes edit distance from a theoretical calculation to a practical, high-performance application. You'll tackle the problem of efficient spell-checking by implementing a BK-Tree, a specialized data structure that leverages a key mathematical property of Levenshtein distance—the triangle inequality—to rapidly find close matches in a dictionary. This exercise bridges the gap between the algorithm and its use in real-world systems. [@problem_id:3216177]", "problem": "You are to design and implement a complete program that builds and queries a Burkhard–Keller Tree (BK-Tree) for approximate string matching using the Levenshtein distance. A BK-Tree is a rooted tree where each edge is labeled by a nonnegative integer distance, and each node stores a single element from the domain; it supports efficient range queries under a metric. In this problem, the domain is the set of finite strings over a fixed alphabet, and the metric is the Levenshtein distance. The goal is to derive the pruning rule from first principles and implement the resulting search.\n\nFundamental base and definitions:\n- A metric space is a pair $(X, d)$ where $X$ is a set and $d: X \\times X \\to \\mathbb{R}_{\\ge 0}$ satisfies nonnegativity, identity of indiscernibles, symmetry, and the triangle inequality. The triangle inequality states: for all $x, y, z \\in X$, $d(x, z) \\le d(x, y) + d(y, z)$.\n- The Levenshtein distance $D(s, t)$ between strings $s$ and $t$ is the minimum number of single-character insertions, deletions, and substitutions required to transform $s$ into $t$. It is a well-known fact that $D$ is a metric, i.e., $D$ satisfies the metric axioms stated above.\n- A Burkhard–Keller Tree (BK-Tree) organizes elements by placing, for each node storing an element $u$, a child at edge label $\\ell \\in \\mathbb{Z}_{\\ge 0}$ if there exists an element $v$ such that $D(u, v) = \\ell$. During insertion, starting at the root, an element $v$ is routed to a child whose edge label equals $D(u, v)$; if that child does not exist, a new node is created at that edge.\n\nTask:\n- Derive, from the triangle inequality and the definition of a range query, the necessary condition on child edge labels that allows pruning of the search space when querying for all elements $v$ with $D(q, v) \\le k$ from a given query string $q$ and radius $k \\in \\mathbb{Z}_{\\ge 0}$. The problem statement does not provide the explicit inequality; the derivation must begin from the metric axioms and yield a usable pruning criterion for BK-Tree search.\n- Implement a Levenshtein distance function $D(s, t)$ using dynamic programming.\n- Build a BK-Tree from an ordered dictionary of words, assigning each word an index equal to its position in the given list (starting at $0$). Each BK-Tree node should store the word and its index. Insertion should follow the BK-Tree rule using $D$.\n- Implement a range query that, given $(q, k)$, returns the sorted list of indices $i$ such that $D(q, W[i]) \\le k$, where $W$ is the dictionary list.\n\nTest suite and parameters:\n- Use the following dictionary $W$ (each word is assigned the index equal to its position in the list): index $0$: \"book\"; index $1$: \"books\"; index $2$: \"boo\"; index $3$: \"boon\"; index $4$: \"boom\"; index $5$: \"bone\"; index $6$: \"cook\"; index $7$: \"cool\"; index $8$: \"school\"; index $9$: \"fool\"; index $10$: \"boar\"; index $11$: \"board\"; index $12$: \"bored\"; index $13$: \"bond\"; index $14$: \"band\"; index $15$: \"ban\"; index $16$: \"an\"; index $17$: \"a\"; index $18$: \"bo\"; index $19$: \"hook\"; index $20$: \"brook\".\n- Run the range query for the following $(q, k)$ pairs:\n  - $(\\text{\"boon\"}, k = 1)$\n  - $(\\text{\"book\"}, k = 0)$\n  - $(\\text{\"\"}, k = 2)$ where the empty string is allowed\n  - $(\\text{\"scholl\"}, k = 1)$\n  - $(\\text{\"xyz\"}, k = 10)$\n- For each test case, the required answer is the sorted list of indices of matching dictionary entries. Each individual test case result must be a list of integers.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a bracketed, comma-separated list of integers. For example, a valid output format is $[[i_1,i_2],[j_1,j_2,j_3],\\dots]$ with no spaces.", "solution": "The problem requires the derivation of the search pruning rule for a Burkhard–Keller Tree (BK-Tree) from first principles and the implementation of a complete program to build and query such a tree for approximate string matching. The matching is based on the Levenshtein distance, $D$, and the query seeks all strings $v$ in a dictionary $W$ such that their distance to a query string $q$ is within a given radius $k$, i.e., $D(q, v) \\le k$.\n\nThe foundation of the BK-Tree's efficiency is that the elements it stores belong to a metric space $(X, d)$. A metric space is a set $X$ equipped with a distance function $d: X \\times X \\to \\mathbb{R}_{\\ge 0}$ satisfying four axioms:\n$1$. Non-negativity: $d(x, y) \\ge 0$\n$2$. Identity of indiscernibles: $d(x, y) = 0 \\iff x = y$\n$3$. Symmetry: $d(x, y) = d(y, x)$\n$4$. The triangle inequality: $d(x, z) \\le d(x, y) + d(y, z)$\n\nIn this problem, the set $X$ is the set of finite strings, and the distance function $d$ is the Levenshtein distance $D$. It is a given fact that $(X, D)$ is a metric space. The pruning rule for the search algorithm is a direct consequence of the triangle inequality.\n\nDerivation of the Pruning Rule:\nLet $q$ be the query string and $k$ be the search radius. The goal is to find all strings $v$ in the tree such that $D(q, v) \\le k$. The search algorithm traverses the tree, and at each node, it must decide which of its child subtrees, if any, could possibly contain a match.\n\nConsider the state of the search at an arbitrary node in the tree. Let this node contain the string $u$. The algorithm has already computed the distance $d_u = D(q, u)$ between the query string $q$ and the node's string $u$. Now, consider a child of $u$. The edge leading to this child is labeled with an integer distance $\\ell$. By the construction of the BK-Tree, any string $v$ located in the subtree rooted at this child must satisfy the condition $D(u, v) = \\ell$.\n\nTo determine if this subtree needs to be explored, we apply the triangle inequality to the three strings: the query $q$, the current node's string $u$, and a potential match $v$ in the child subtree.\n\nFrom the triangle inequality, we have two key relations:\n$1$. $D(q, u) \\le D(q, v) + D(v, u)$. By symmetry, $D(v, u) = D(u, v)$, so we can write $D(q, u) \\le D(q, v) + D(u, v)$. Rearranging gives:\n$$D(q, u) - D(u, v) \\le D(q, v)$$\n\n$2$. $D(u, v) \\le D(u, q) + D(q, v)$. By symmetry, $D(u, q) = D(q, u)$, so $D(u, v) \\le D(q, u) + D(q, v)$. Rearranging gives:\n$$D(u, v) - D(q, u) \\le D(q, v)$$\n\nThese two inequalities can be combined into a single, more compact form, often called the reverse triangle inequality:\n$$|D(q, u) - D(u, v)| \\le D(q, v)$$\n\nWe are searching for strings $v$ that satisfy the primary query condition $D(q, v) \\le k$. If a string $v$ in the child subtree is a valid match, then combining the reverse triangle inequality with the query condition yields:\n$$|D(q, u) - D(u, v)| \\le D(q, v) \\le k$$\n\nThis implies a necessary condition that must hold for any potential match $v$ to exist in the child subtree:\n$$|D(q, u) - D(u, v)| \\le k$$\n\nLet us substitute the known values: $d_u = D(q, u)$ is the distance computed at the current node, and $\\ell = D(u, v)$ is the label of the edge leading to the child subtree. The necessary condition for exploring the child subtree becomes:\n$$|d_u - \\ell| \\le k$$\n\nThis inequality is the pruning rule. It states that we only need to traverse to children along edges with labels $\\ell$ that are \"close\" to the distance $d_u$ from the query to the current node. Expanding the absolute value gives the range of edge labels to check:\n$$-k \\le d_u - \\ell \\le k$$\nWhich is equivalent to:\n$$d_u - k \\le \\ell \\le d_u + k$$\n\nTherefore, the search algorithm proceeds as follows:\n$1$. Start at the root of the BK-Tree.\n$2$. At a given node containing string $u$:\n   a. Compute the distance $d_u = D(q, u)$.\n   b. If $d_u \\le k$, the string $u$ is a match. Add its index to the result set.\n   c. Iterate through all children of $u$. For each child connected by an edge with label $\\ell$, check if $d_u - k \\le \\ell \\le d_u + k$.\n   d. If the condition is met, recursively apply the search procedure to that child node. Otherwise, prune that entire branch of the tree from the search.\n\nThis derived rule allows the algorithm to avoid computing Levenshtein distances for a large fraction of the strings in the dictionary, making it significantly more efficient than a linear scan.\n\nThe implementation will consist of three main components:\n$1$. A function to compute the Levenshtein distance $D(s, t)$ using a standard dynamic programming approach with a cost matrix.\n$2$. A class-based representation of the BK-Tree, with a `Node` structure to hold a word, its index, and a dictionary of its children, and a `BKTree` class to manage insertion and querying.\n$3$. A query method that implements the recursive search using the derived pruning rule $|d_u - \\ell| \\le k$.\n\nThe final program will build the tree from the provided dictionary and then execute the specified queries, collecting and formatting the results as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# This version is corrected to produce the right output and uses pure Python.\nimport collections\n\ndef levenshtein_distance(s1: str, s2: str) -> int:\n    \"\"\"\n    Calculates the Levenshtein distance between two strings using the\n    space-optimized dynamic programming algorithm.\n    \"\"\"\n    if len(s1)  len(s2):\n        return levenshtein_distance(s2, s1)\n\n    if len(s2) == 0:\n        return len(s1)\n\n    previous_row = range(len(s2) + 1)\n    for i, c1 in enumerate(s1):\n        current_row = [i + 1]\n        for j, c2 in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    \n    return previous_row[-1]\n\nclass BKNode:\n    \"\"\"A node in the Burkhard-Keller Tree.\"\"\"\n    def __init__(self, word: str, index: int):\n        self.word = word\n        self.index = index\n        self.children = {}  # dict mapping distance to child BKNode\n\nclass BKTree:\n    \"\"\"A Burkhard-Keller Tree for approximate string matching.\"\"\"\n    def __init__(self, distance_func):\n        self.root = None\n        self.distance = distance_func\n\n    def add(self, word: str, index: int):\n        \"\"\"Adds a word with its index to the tree.\"\"\"\n        if self.root is None:\n            self.root = BKNode(word, index)\n            return\n\n        current_node = self.root\n        while True:\n            dist = self.distance(current_node.word, word)\n            if dist in current_node.children:\n                current_node = current_node.children[dist]\n            else:\n                current_node.children[dist] = BKNode(word, index)\n                break\n\n    def query(self, query_word: str, k: int) -> list[int]:\n        \"\"\"\n        Finds all words in the tree within a distance k of the query_word.\n        Returns a sorted list of indices.\n        \"\"\"\n        if self.root is None:\n            return []\n            \n        matches = []\n        # Use a deque for an efficient iterative traversal (BFS-like)\n        candidates = collections.deque([self.root])\n\n        while candidates:\n            node = candidates.popleft()\n            dist_to_node = self.distance(query_word, node.word)\n\n            if dist_to_node = k:\n                matches.append(node.index)\n\n            # Pruning rule based on the triangle inequality\n            low = dist_to_node - k\n            high = dist_to_node + k\n\n            for dist, child in node.children.items():\n                if low = dist = high:\n                    candidates.append(child)\n        \n        matches.sort()\n        return matches\n\ndef solve():\n    # Define the dictionary and test cases from the problem statement.\n    dictionary = [\n        \"book\", \"books\", \"boo\", \"boon\", \"boom\", \"bone\", \"cook\", \"cool\",\n        \"school\", \"fool\", \"boar\", \"board\", \"bored\", \"bond\", \"band\", \"ban\",\n        \"an\", \"a\", \"bo\", \"hook\", \"brook\"\n    ]\n    \n    test_cases = [\n        (\"boon\", 1),\n        (\"book\", 0),\n        (\"\", 2),\n        (\"scholl\", 1),\n        (\"xyz\", 10)\n    ]\n\n    # Build the BK-Tree\n    bktree = BKTree(levenshtein_distance)\n    for i, word in enumerate(dictionary):\n        bktree.add(word, i)\n        \n    all_results = []\n    for q, k in test_cases:\n        result = bktree.query(q, k)\n        all_results.append(result)\n\n    # Format the output exactly as specified: [[i1,i2],[j1],...] with no spaces\n    case_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3216177"}]}