{"hands_on_practices": [{"introduction": "Beyond a simple, finite sequence, data can be organized in many ways. This first practice challenges you to adapt the linear search algorithm for a circular array, a structure where the end connects back to the beginning. The key to solving this is to use modular arithmetic to redefine the \"next\" element, ensuring your search is both complete and correct, regardless of the starting point. This exercise reinforces that linear search is fundamentally about systematic traversal, a concept that applies to many data structures.", "problem": "Consider a circular array of integers with size $n$, where $n \\ge 1$, represented as a sequence $A[0],A[1],\\dots,A[n-1]$. A circular array means that valid positions are the integers $0,1,\\dots,n-1$ and movement \"past\" $n-1$ continues at position $0$. You are given a starting position $s$ with $0 \\le s \\le n-1$ and a target value $x$. Design and implement a linear search variant that examines the array one element at a time, following a well-defined traversal order in the circular array, that satisfies all of the following constraints: it always terminates, it never examines any position more than once, it returns an index $i$ such that $A[i]=x$ if such an index exists, and it returns $-1$ otherwise. Your algorithm must not modify $A$, must not reorder $A$, and must only perform a sequential scan; do not use any auxiliary search structures. The primary efficiency goal is to minimize the number of element examinations, with the worst-case number of examinations being exactly $n$ and the best case being strictly less than $n$ whenever the target is found before all positions are examined. The fundamental base for your design must be the definition of linear search as a sequential examination and the properties of modular arithmetic for index arithmetic on circular structures. The traversal order must be a function of $s$ and $n$ and must be well-defined using only forward movement around the circle.\n\nYour program must be self-contained and use no external input. For each test case below, the program should produce the search result as an integer, with the final output being a single line containing the results for all test cases as a comma-separated list enclosed in square brackets (for example, \"[1,-1,4]\").\n\nUse the following test suite, which covers typical scenarios, wrap-around behavior, absence of the target, boundary conditions, and duplicates. Each test case is a triple $(A,x,s)$, where $A$ is the array, $x$ is the target, and $s$ is the starting position:\n- Test case $1$: $A=[4,7,1,9,3]$, $x=9$, $s=1$.\n- Test case $2$: $A=[5,2,8,6]$, $x=2$, $s=3$.\n- Test case $3$: $A=[10,20,30]$, $x=15$, $s=2$.\n- Test case $4$: $A=[42]$, $x=42$, $s=0$.\n- Test case $5$: $A=[7,7,7,7]$, $x=7$, $s=2$.\n- Test case $6$: $A=[3,1,4,1,5]$, $x=1$, $s=0$.\n- Test case $7$: $A=[2,3,5,7,11]$, $x=2$, $s=4$.\n\nYour program should produce a single line of output containing the results in the exact format \"[r1,r2,r3,r4,r5,r6,r7]\", where each $r_k$ is an integer result for test case $k$ according to the rules described above. There are no physical units, no angles, and no percentages involved in this problem; all values are integers and must be treated purely as mathematical and logical entities.", "solution": "The problem requires the design of a linear search algorithm for a circular array. The search must begin at a specified starting index $s$ and proceed sequentially, examining each element exactly once in the worst case. The solution must be grounded in the principles of linear search and modular arithmetic.\n\nFirst, a validation of the problem statement is performed.\n\n**Step 1: Extracted Givens**\n-   An array of integers, $A$, of size $n$, where $n \\ge 1$.\n-   The array is circular, meaning indices are in the set $\\{0, 1, \\dots, n-1\\}$, and movement past $n-1$ wraps around to $0$.\n-   A starting position $s$, where $0 \\le s \\le n-1$.\n-   A target integer value, $x$.\n-   The algorithm must be a linear search variant that examines elements one at a time.\n-   The traversal order must be well-defined, starting at $s$ and using only forward movement.\n-   The algorithm must always terminate.\n-   No position may be examined more than once.\n-   The algorithm must return an index $i$ such that $A[i]=x$ if one exists; otherwise, it must return $-1$.\n-   The algorithm must not modify or reorder the array $A$.\n-   No auxiliary search structures are to be used.\n-   The worst-case number of element examinations must be exactly $n$.\n-   The best-case number of examinations must be strictly less than $n$ if the target is found before all positions are inspected.\n-   The design must be based on linear search principles and modular arithmetic.\n-   Test cases are provided:\n    1.  $A=[4,7,1,9,3]$, $x=9$, $s=1$.\n    2.  $A=[5,2,8,6]$, $x=2$, $s=3$.\n    3.  $A=[10,20,30]$, $x=15$, $s=2$.\n    4.  $A=[42]$, $x=42$, $s=0$.\n    5.  $A=[7,7,7,7]$, $x=7$, $s=2$.\n    6.  $A=[3,1,4,1,5]$, $x=1$, $s=0$.\n    7.  $A=[2,3,5,7,11]$, $x=2$, $s=4$.\n\n**Step 2: Validation Using Extracted Givens**\nThe problem is evaluated against the specified criteria:\n-   **Scientifically Grounded**: The problem is well-founded in computer science and mathematics, specifically concerning algorithms on data structures (arrays) and number theory (modular arithmetic). It is a standard, formalizable problem.\n-   **Well-Posed**: The problem is clearly defined with unambiguous constraints. The objective (find an element or determine its absence) is precise, and the conditions on the search process (starting point, traversal order, termination) are sufficient to define a unique algorithmic strategy.\n-   **Objective**: The problem is stated in precise, formal language, free of subjectivity or ambiguity.\n-   **No Flaws**: The problem does not violate any of the invalidity criteria. It is consistent, complete, and solvable. The constraints are mutually compatible and lead to a logical solution.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. A solution will be developed.\n\n**Principle-Based Solution**\nThe core of the problem is to define a traversal sequence that starts at index $s$ and visits every index in a circular array of size $n$ exactly once. The requirement for \"forward movement around the circle\" combined with the constraints of linear search naturally leads to a solution based on modular arithmetic.\n\nLet the array be $A$ of size $n$. The indices are $\\{0, 1, \\dots, n-1\\}$. We are given a starting index $s$. The search will proceed by checking elements at indices $s$, $s+1$, $s+2$, and so on. To handle the circular \"wrap-around\" behavior, the modulo operator is employed.\n\nThe algorithm can be structured as a loop that iterates $n$ times. A loop counter, let's call it $i$, will run from $0$ to $n-1$. This counter represents the number of elements examined so far, or equivalently, the offset from the starting position $s$.\n\nFor each value of the offset $i \\in \\{0, 1, \\dots, n-1\\}$, the actual index in the array $A$ to be examined, let's call it $j$, is calculated as:\n$$\nj = (s + i) \\pmod n\n$$\nThis formula ensures a sequential forward scan starting from $s$:\n-   When $i=0$, the index is $j = (s+0) \\pmod n = s$. The first element checked is $A[s]$.\n-   When $i=1$, the index is $j = (s+1) \\pmod n$.\n-   This continues until $i=n-1$, corresponding to index $j = (s+n-1) \\pmod n$.\n\nThe set of indices $\\{ (s+i) \\pmod n \\mid i \\in \\{0, 1, \\dots, n-1\\} \\}$ is precisely the set $\\{0, 1, \\dots, n-1\\}$. This is a fundamental property of modular arithmetic: adding a complete residue system (in this case, $\\{0, 1, \\dots, n-1\\}$) to a constant $s$ and taking the result modulo $n$ produces another complete residue system. Therefore, this traversal guarantees that every element of the array is visited exactly once.\n\nThe algorithm proceeds as follows:\n1.  Initialize a loop that iterates $n$ times, with an iteration variable $i$ from $0$ to $n-1$.\n2.  Inside the loop, compute the current index to check: $j = (s + i) \\pmod n$.\n3.  Compare the element at this index, $A[j]$, with the target value $x$.\n4.  If $A[j] = x$, the target has been found. The algorithm must terminate immediately and return the index $j$. This fulfills the requirement for early termination and a best-case performance of fewer than $n$ comparisons.\n5.  If the loop completes without finding the target value $x$ after checking all $n$ positions, it implies that $x$ is not present in the array. In this case, the algorithm returns $-1$. This fulfills the worst-case requirement of exactly $n$ comparisons.\n\nThis design satisfies all problem constraints: it is a sequential scan, it uses modular arithmetic, it starts at $s$, it visits each element once, it terminates, and it returns the correct result without modifying the array or using auxiliary data structures for searching.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the circular array linear search problem for a predefined suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (numpy array A, target x, start_index s)\n    test_cases = [\n        (np.array([4, 7, 1, 9, 3]), 9, 1),\n        (np.array([5, 2, 8, 6]), 2, 3),\n        (np.array([10, 20, 30]), 15, 2),\n        (np.array([42]), 42, 0),\n        (np.array([7, 7, 7, 7]), 7, 2),\n        (np.array([3, 1, 4, 1, 5]), 1, 0),\n        (np.array([2, 3, 5, 7, 11]), 2, 4),\n    ]\n\n    results = []\n\n    def circular_linear_search(arr, target, start_pos):\n        \"\"\"\n        Performs a linear search on a circular array.\n\n        Args:\n            arr (np.ndarray): The circular array of integers.\n            target (int): The value to search for.\n            start_pos (int): The starting index for the search.\n\n        Returns:\n            int: The index of the first occurrence of the target found during the traversal,\n                 or -1 if the target is not in the array.\n        \"\"\"\n        n = len(arr)\n        if n == 0:\n            return -1\n\n        # The loop iterates n times to ensure every element is checked once in the worst case.\n        # The variable 'i' represents the number of steps taken from the starting position.\n        for i in range(n):\n            # Calculate the current index to check using modular arithmetic.\n            # This handles the \"wrap-around\" behavior of the circular array.\n            current_index = (start_pos + i) % n\n            \n            if arr[current_index] == target:\n                # If the target is found, return its index immediately.\n                return current_index\n        \n        # If the loop completes, the target was not found in the array.\n        return -1\n\n    for A, x, s in test_cases:\n        result = circular_linear_search(A, x, s)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244873"}, {"introduction": "In many practical applications, we search not for an exact match but for the \"best\" or \"closest\" one. This exercise reframes linear search as an optimization problem: finding the element in a data stream that is closest to a target value, all while using only constant, $\\mathcal{O}(1)$, additional memory. This problem introduces the crucial algorithmic pattern of tracking the \"best-so-far\" candidate, a technique essential for processing large datasets and streams where storing all the data is not feasible [@problem_id:3244875].", "problem": "You are given multiple finite data streams, each modeled as a finite sequence of real numbers $x_0, x_1, \\dots, x_{n-1}$ and a target real value $v$. You must design and implement a linear search that scans each stream exactly once in the forward direction, uses only $\\mathcal{O}(1)$ additional memory, and returns the zero-based index $i^\\*$ such that the absolute difference $\\lvert x_{i^\\*} - v \\rvert$ is minimized over all elements of the stream. In the case of a tie (that is, when multiple indices attain the same minimum absolute difference), you must return the smallest such index. If a stream is empty (that is, $n = 0$), return $-1$.\n\nYour design must start from basic principles:\n- A linear search is defined as examining elements in order $x_0, x_1, \\dots, x_{n-1}$ without revisiting earlier elements, maintaining only a constant number of scalar variables beyond the input itself.\n- For any finite set of real numbers, a minimum exists. For a finite nonempty sequence, the index that minimizes a real-valued criterion can be defined as the argument of the minimum (the arg minimum), and a deterministic tie-breaking rule such as the smallest index yields a unique answer.\n- The absolute value function $\\lvert \\cdot \\rvert$ induces a total preorder on $\\mathbb{R}$ relative to $v$ via the map $x \\mapsto \\lvert x - v \\rvert$.\n\nYour program must implement the linear search according to these principles, with the following precise rules:\n- Indexing is zero-based; valid indices are in $\\{0, 1, \\dots, n-1\\}$ for $n \\ge 1$.\n- Return $-1$ if $n = 0$.\n- Use only $\\mathcal{O}(1)$ additional memory: you may maintain a constant set of scalars such as the current best index and current best absolute difference. You must not allocate memory proportional to $n$ for auxiliary storage.\n- You may terminate early if you discover an element $x_i$ with $\\lvert x_i - v \\rvert = 0$, since no smaller absolute difference exists.\n\nTest suite:\nApply your program to the following test cases. Each test case is a pair $(\\text{stream}, v)$, where the stream is listed explicitly and $v$ is a real number. For readability, each stream is written in literal list notation, but your algorithm must conceptually process it as a forward-only data stream.\n\n- Test A: stream $[3, 10, 9, 2, 5]$, target $v = 7$.\n- Test B: stream $[7, 8, 7, 6]$, target $v = 7$.\n- Test C: stream $[]$, target $v = 7$.\n- Test D: stream $[1.5]$, target $v = 2.7$.\n- Test E: stream $[4, 10]$, target $v = 7$.\n- Test F: stream $[-5, -2, -1, -3]$, target $v = -2.4$.\n- Test G: stream $[10^{12}, -10^{12}, 3, 10^{12} - 1]$, target $v = 0$.\n- Test H: stream $[1.0, 1.2, 1.4, 1.6]$, target $v = 1.5$.\n- Test I: stream $[5, 5, 5]$, target $v = 4.9$.\n\nFinal output format:\nYour program should produce a single line of output containing the indices returned for Test A through Test I, in that order, as a comma-separated list enclosed in square brackets, for example, $[a,b,c,d,e,f,g,h,i]$ where each of $a$ through $i$ is an integer. No other text should be printed.", "solution": "The user has provided a problem statement that requires the design and implementation of a linear search algorithm. The validation process will now be executed.\n\n### Step 1: Extract Givens\n\n- **Data Model**: A finite sequence of real numbers $x_0, x_1, \\dots, x_{n-1}$, representing a data stream, and a target real value $v$.\n- **Objective**: Find the zero-based index $i^*$ that minimizes the absolute difference $\\lvert x_{i^*} - v \\rvert$.\n- **Constraint 1 (Linear Scan)**: The algorithm must scan the stream exactly once in the forward direction ($x_0, x_1, \\dots, x_{n-1}$) without revisiting elements.\n- **Constraint 2 (Memory)**: The algorithm must use only $\\mathcal{O}(1)$ additional memory, meaning a constant number of scalar variables.\n- **Constraint 3 (Tie-Breaking)**: In case of a tie, where multiple indices yield the same minimum absolute difference, the smallest such index must be returned.\n- **Constraint 4 (Empty Stream)**: If the stream is empty ($n=0$), the algorithm must return $-1$.\n- **Constraint 5 (Indexing)**: Indexing is zero-based, with valid indices in the set $\\{0, 1, \\dots, n-1\\}$ for a stream of length $n \\ge 1$.\n- **Optimization (Early Termination)**: The algorithm may terminate early if an element $x_i$ is found such that $\\lvert x_i - v \\rvert = 0$.\n- **Foundational Principles**:\n    - A linear search examines elements sequentially.\n    - For any finite set of real numbers, a minimum exists. The argument of the minimum (arg min) can be uniquely determined with a tie-breaking rule.\n    - The function $x \\mapsto \\lvert x - v \\rvert$ defines a total preorder on $\\mathbb{R}$.\n- **Test Cases**:\n    - A: stream $[3, 10, 9, 2, 5]$, target $v = 7$.\n    - B: stream $[7, 8, 7, 6]$, target $v = 7$.\n    - C: stream $[]$, target $v = 7$.\n    - D: stream $[1.5]$, target $v = 2.7$.\n    - E: stream $[4, 10]$, target $v = 7$.\n    - F: stream $[-5, -2, -1, -3]$, target $v = -2.4$.\n    - G: stream $[10^{12}, -10^{12}, 3, 10^{12} - 1]$, target $v = 0$.\n    - H: stream $[1.0, 1.2, 1.4, 1.6]$, target $v = 1.5$.\n    - I: stream $[5, 5, 5]$, target $v = 4.9$.\n- **Output Format**: A single line containing a comma-separated list of integer results enclosed in square brackets.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is scrutinized against the validation criteria.\n\n- **Scientifically Grounded**: The problem is fundamentally sound. It is rooted in basic principles of real analysis (absolute value, minimization) and computer science (algorithmic analysis, linear search, time and space complexity). All principles cited are correct.\n- **Well-Posed**: The problem is well-posed. The objective is clearly stated: find the arg min of $\\lvert x_i - v \\rvert$ over the indices $i$. The constraints are explicit. The domain (finite sequences of real numbers) is specified. The provided tie-breaking rule (smallest index) and the handling of the empty stream case ensure that a unique, stable, and meaningful solution exists for any valid input.\n- **Objective**: The problem is expressed in precise, unambiguous mathematical and algorithmic language, free from subjective interpretation.\n\nThe problem exhibits none of the invalidating flaws:\n1.  **Scientific or Factual Unsoundness**: None.\n2.  **Non-Formalizable or Irrelevant**: The problem is directly relevant to linear search and is fully formalizable.\n3.  **Incomplete or Contradictory Setup**: The problem is self-contained and all constraints are consistent.\n4.  **Unrealistic or Infeasible**: The conditions are standard for algorithmic problems and computationally feasible.\n5.  **Ill-Posed or Poorly Structured**: The problem is well-posed.\n6.  **Pseudo-Profound, Trivial, or Tautological**: The problem is a standard, fundamental exercise in algorithm design, not a trivial or contrived puzzle.\n7.  **Outside Scientific Verifiability**: The results are mathematically verifiable for any given input.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. A solution will be developed and presented.\n\n### Solution\n\nThe task is to find the index $i^*$ of an element $x_{i^*}$ in a sequence $X = (x_0, x_1, \\dots, x_{n-1})$ that minimizes the function $f(x_i) = \\lvert x_i - v \\rvert$. We are constrained to a single forward pass and $\\mathcal{O}(1)$ memory.\n\n**Principle-Based Design**\n\nThe design follows from the properties of a linear search over a sequence to find an extremum. The core idea is to maintain the state of the \"best-so-far\" solution while iterating.\n\n1.  **State Variables**: To satisfy the $\\mathcal{O}(1)$ memory constraint, we need a constant number of variables to track the state. The necessary state includes:\n    - The index of the best element found so far, which we will call $i_{best}$.\n    - The minimum absolute difference corresponding to that element, which we will call $\\delta_{min}$.\n\n2.  **Initialization**:\n    - First, we must handle the edge case of an empty stream ($n=0$). As per the problem's rules, the function must return $-1$.\n    - For a non-empty stream ($n \\ge 1$), we can initialize our state using the first element, $x_0$. This is a valid starting point for comparison. We set $i_{best} \\leftarrow 0$ and $\\delta_{min} \\leftarrow \\lvert x_0 - v \\rvert$.\n\n3.  **Iterative Improvement**:\n    - We perform a single forward pass through the rest of the stream, for indices $i$ from $1$ to $n-1$.\n    - In each iteration $i$, we compute the current absolute difference, $\\delta_i = \\lvert x_i - v \\rvert$.\n    - We then compare $\\delta_i$ with the stored minimum difference, $\\delta_{min}$.\n    - If $\\delta_i  \\delta_{min}$, we have found a strictly better element. We update our state: $\\delta_{min} \\leftarrow \\delta_i$ and $i_{best} \\leftarrow i$.\n    - If $\\delta_i \\ge \\delta_{min}$, we do nothing. This implicitly handles the tie-breaking rule: if $\\delta_i = \\delta_{min}$, we keep the current $i_{best}$ because it is smaller than the current index $i$, thus satisfying the requirement to return the smallest index in case of a tie.\n\n4.  **Early Termination Optimization**:\n    - The minimum possible value for the non-negative function $\\lvert \\cdot \\rvert$ is $0$.\n    - During the iteration, if at any point we find an element $x_i$ such that $\\delta_i = \\lvert x_i - v \\rvert = 0$, we have found the global minimum. No subsequent element can yield a smaller difference.\n    - Therefore, we can immediately update $i_{best} \\leftarrow i$ and terminate the search, returning $i_{best}$. This optimization is valid and can improve performance on certain inputs. Our initialization step itself might find a perfect match at index $0$. We can check if $\\delta_{min} = 0$ after initialization and return $0$ immediately. Similarly, inside the loop, if we find $\\delta_i = 0$, we can return $i$ immediately.\n\n5.  **Finalization**:\n    - After the loop has completed (either by reaching the end of the stream or by early termination), the value stored in $i_{best}$ is the guaranteed solution according to the problem's specification.\n\n**Algorithmic Summary**\n\nLet the input stream be $X$ of length $n$ and the target be $v$.\n\n1.  If $n = 0$, return $-1$.\n2.  Initialize $i_{best} \\leftarrow 0$.\n3.  Initialize $\\delta_{min} \\leftarrow \\lvert X[0] - v \\rvert$.\n4.  If $\\delta_{min} = 0$, return $i_{best}$.\n5.  For $i$ from $1$ to $n-1$:\n    a. Calculate $\\delta_i \\leftarrow \\lvert X[i] - v \\rvert$.\n    b. If $\\delta_i  \\delta_{min}$:\n        i.  Update $\\delta_{min} \\leftarrow \\delta_i$.\n        ii. Update $i_{best} \\leftarrow i$.\n        iii. If $\\delta_{min} = 0$, break from the loop.\n6.  Return $i_{best}$.\n\nThis algorithm correctly implements a linear search that adheres to all specified constraints: single forward pass, $\\mathcal{O}(1)$ memory usage, correct tie-breaking, handling of the empty case, and an optional early termination.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear search problem for a predefined test suite.\n    \"\"\"\n\n    def linear_search_closest(stream, v):\n        \"\"\"\n        Finds the index i* of the element in the stream that minimizes |x_i* - v|.\n\n        Args:\n            stream (list[float]): A finite sequence of real numbers.\n            v (float): The target real value.\n\n        Returns:\n            int: The zero-based index of the element closest to v.\n                 Returns -1 if the stream is empty. In case of a tie,\n                 the smallest index is returned.\n        \"\"\"\n        # Constraint 4: Handle the empty stream case.\n        if not stream:\n            return -1\n\n        # Initialization using the first element (index 0).\n        # i_best holds the index of the best element found so far.\n        # delta_min holds the minimum absolute difference found so far.\n        best_index = 0\n        min_diff = abs(stream[0] - v)\n\n        # Optimization: If the first element is a perfect match, we can return immediately.\n        if min_diff == 0:\n            return best_index\n\n        # Constraint 1: Linear scan from the second element to the end.\n        for i in range(1, len(stream)):\n            current_diff = abs(stream[i] - v)\n\n            # Compare current difference with the minimum found so far.\n            if current_diff  min_diff:\n                # A new minimum is found. Update state.\n                min_diff = current_diff\n                best_index = i\n                \n                # Optimization: Early termination if a perfect match is found.\n                if min_diff == 0:\n                    break\n        \n        # The loop naturally handles the tie-breaking rule (Constraint 3):\n        # If current_diff == min_diff, we do not update best_index,\n        # thus preserving the smaller, earlier index.\n        \n        # The memory usage is O(1) as we only use a few scalar variables\n        # (best_index, min_diff, i, current_diff) irrespective of stream size.\n\n        return best_index\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A\n        ([3, 10, 9, 2, 5], 7),\n        # Test B\n        ([7, 8, 7, 6], 7),\n        # Test C\n        ([], 7),\n        # Test D\n        ([1.5], 2.7),\n        # Test E\n        ([4, 10], 7),\n        # Test F\n        ([-5, -2, -1, -3], -2.4),\n        # Test G\n        ([10**12, -10**12, 3, 10**12 - 1], 0),\n        # Test H\n        ([1.0, 1.2, 1.4, 1.6], 1.5),\n        # Test I\n        ([5, 5, 5], 4.9)\n    ]\n\n    results = []\n    for stream, v in test_cases:\n        result = linear_search_closest(stream, v)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244875"}, {"introduction": "A critical skill in algorithm design is knowing when a simple approach is not enough. While a nested linear search can find a common element between two arrays, its $O(n \\cdot m)$ complexity is often too slow. This problem guides you to devise a much more efficient, linear-time solution by trading space for time, using a hash-based data structure to eliminate the inner search loop [@problem_id:3245002]. This practice demonstrates how linear search, when combined with appropriate data structures, serves as a component in powerful and optimized algorithms.", "problem": "You are given two finite arrays of integers, denoted $A$ and $B$. Let $|A| = n$ and $|B| = m$, where $n$ and $m$ are nonnegative integers. A fundamental operation in data structures and algorithms is sequential or linear search, which, given a target value $x$ and an array, examines the array elements in order, performing equality comparisons, until it either finds $x$ or concludes that $x$ is absent. Another fundamental operation is membership testing in a hash-based set, which is widely observed to run in expected constant time per query under the uniform hashing assumption. Your task is to design a program that finds the first common element between $A$ and $B$, where “first” is defined with respect to the left-to-right ordering of $A$.\n\nFormally, let $A = [a_0,a_1,\\dots,a_{n-1}]$ and $B = [b_0,b_1,\\dots,b_{m-1}]$. Define the output triple to be $[v,i,j]$, where $v$ is the earliest value in $A$ (smallest $i$ such that $a_i$ appears in $B$) that is also present in $B$, $i$ is the index of $v$ in $A$, and $j$ is the leftmost index in $B$ where $v$ appears. If there is no such value, the program should output the sentinel $[-1,-1,-1]$. The naive approach performs nested linear searches: for each $a_i$ in $A$, linearly search $B$ for $a_i$; if found, report $a_i$ and indices $i$ and $j$, otherwise continue. A better approach is to build a hash set populated with elements of $B$ and separately remember the first occurrence index in $B$ for each value, then linearly scan $A$ once, testing membership in the set.\n\nStarting from the core definitions of linear search and the widely accepted uniform hashing assumption for hash sets, propose, justify, and implement the hash-set-based approach. Your program must be self-contained (no input), use the test suite below, and produce a single line of output with the results aggregated across all test cases.\n\nTest suite (arrays are shown explicitly):\n- Case $1$ (happy path): $A = [3,5,7,9]$, $B = [10,11,5,12]$.\n- Case $2$ (no common element): $A = [1,2,3]$, $B = [4,5]$.\n- Case $3$ (first element common): $A = [8,1]$, $B = [8]$.\n- Case $4$ (duplicates in both arrays): $A = [4,4,4]$, $B = [0,4,4]$.\n- Case $5$ (empty first array): $A = []$, $B = [1,2]$.\n- Case $6$ (empty second array): $A = [1,2]$, $B = []$.\n- Case $7$ (negative numbers and zero): $A = [-5,-1,0,2]$, $B = [3,-1,4]$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each per-case result must be a list of three integers $[v,i,j]$. For example, if there were only two cases, an acceptable output would be $[[5,1,2],[-1,-1,-1]]$. For this problem, the output must aggregate all seven cases in order as a single list, for example $[[\\dots],[\\dots],\\dots]$.\n\nConstraints and assumptions:\n- Use the Random Access Machine (RAM) model with unit-cost arithmetic and comparisons.\n- If no common element exists, output $[-1,-1,-1]$ as specified; the sentinel $-1$ must be an integer.\n- Elements are standard machine integers that fit in Python’s integer type; no physical units apply.", "solution": "The problem statement is formally valid. It is scientifically grounded in the principles of algorithm design and complexity analysis, is well-posed with unambiguous definitions and constraints, and is expressed in objective, formal language. There are no contradictions, missing information, or violations of scientific or mathematical principles. We may, therefore, proceed with a solution.\n\nThe objective is to find the first common element between two integer arrays, $A = [a_0, a_1, \\dots, a_{n-1}]$ of length $n$ and $B = [b_0, b_1, \\dots, b_{m-1}]$ of length $m$. The term \"first\" is defined with respect to the ordering of array $A$; that is, we seek the element $a_i$ with the minimum index $i$ that is also present in array $B$. The required output is a triple $[v, i, j]$, where $v = a_i$, $i$ is the index of $v$ in $A$, and $j$ is the index of the *first* occurrence of $v$ in $B$ (i.e., the smallest $j$ such that $b_j = v$). If no common element exists, the specified sentinel output is $[-1, -1, -1]$.\n\nA naive approach, as alluded to in the problem description, involves nested loops. We would iterate through each element $a_i$ in $A$ (from $i=0$ to $n-1$), and for each $a_i$, we would perform a second, inner linear search through all elements of $B$ (from $j=0$ to $m-1$) to check for equality. The first time we find a match, i.e., $a_i = b_j$, we have found our solution. The outer loop runs up to $n$ times, and the inner loop runs up to $m$ times for each outer iteration. Under the Random Access Machine (RAM) model with unit-cost comparisons, this results in a worst-case time complexity of $O(n \\cdot m)$. This quadratic complexity is inefficient for large arrays.\n\nA more efficient algorithm can be designed by leveraging a hash-based data structure to optimize the search process, trading space for time. The problem suggests using a hash set, but to fulfill the requirement of returning the *leftmost* index $j$ from array $B$, a hash map (or dictionary) is the more appropriate tool. The strategy is divided into two phases: a pre-processing phase on array $B$ and a search phase on array $A$.\n\n**Phase 1: Pre-processing Array $B$**\n\nThe goal of this phase is to construct a data structure that allows for near-instantaneous lookup of any value from $B$, along with its first occurrence index. A hash map is ideal for this. We can map each unique value present in $B$ to its first corresponding index.\n\nThe procedure is as follows:\n1.  Initialize an empty hash map, which we shall call $\\text{value\\_to\\_index\\_map}$.\n2.  Iterate through array $B$ from index $j = 0$ to $m-1$.\n3.  For each element $b_j$, check if the value $b_j$ is already a key in $\\text{value\\_to\\_index\\_map}$.\n4.  If $b_j$ is *not* in the map, it signifies that this is the first time we have encountered this value. We add $b_j$ to the map as a key, with its current index $j$ as the associated value.\n5.  If $b_j$ is already in the map, we do nothing, thereby preserving the index of its first occurrence.\n\nAfter this single pass through $B$, $\\text{value\\_to\\_index\\_map}$ contains all unique elements of $B$ as keys, and their corresponding values are their leftmost indices in $B$. Under the uniform hashing assumption, each insertion into a hash map takes expected constant time, or $O(1)$. Therefore, the total time complexity for this phase is $O(m)$. The space required is proportional to the number of unique elements in $B$, which is at most $m$, so the space complexity is $O(\\min(m, U))$ where $U$ is the number of unique elements in $B$.\n\n**Phase 2: Searching in Array $A$**\n\nWith the pre-processing complete, we can now efficiently find the first common element.\n\nThe procedure is as follows:\n1.  Iterate through array $A$ from index $i = 0$ to $n-1$.\n2.  For each element $a_i$, perform a lookup for the key $a_i$ in $\\text{value\\_to\\_index\\_map}$.\n3.  Because we are iterating through $A$ in sequential order, the very first $a_i$ that we find as a key in the map is, by definition, the first common element.\n4.  Upon finding such an $a_i$, we have our solution: the value is $v = a_i$, its index in $A$ is $i$, and its leftmost index in $B$ is retrieved from the map as $j = \\text{value\\_to\\_index\\_map}[a_i]$. We then return the triple $[v, i, j]$ and terminate the algorithm.\n\nIf the loop completes without finding any element of $A$ in the map, it implies that there are no common elements between the two arrays. In this scenario, we return the sentinel value $[-1, -1, -1]$ as required.\n\nThe time complexity of this phase is dominated by the loop through $A$. Each lookup in the hash map takes expected $O(1)$ time. In the worst case (no common elements or the common element is at the end of $A$), we iterate through all $n$ elements. Thus, the time complexity for this phase is $O(n)$.\n\n**Overall Complexity and Justification**\n\nThe total time complexity of the hash-map-based approach is the sum of the complexities of the two phases: $O(m) + O(n) = O(n+m)$. This linear time complexity is asymptotically optimal, as any algorithm must examine every element of both arrays in the worst case to guarantee a correct result. The space complexity is $O(\\min(m, U))$ for the hash map. This approach is markedly superior to the naive $O(n \\cdot m)$ method, especially for large inputs. The implementation correctly handles edge cases such as empty arrays ($n=0$ or $m=0$) and duplicate elements within arrays, adhering strictly to the problem definition.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for a predefined test suite and prints the aggregated result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        ([3, 5, 7, 9], [10, 11, 5, 12]),\n        # Case 2 (no common element)\n        ([1, 2, 3], [4, 5]),\n        # Case 3 (first element common)\n        ([8, 1], [8]),\n        # Case 4 (duplicates in both arrays)\n        ([4, 4, 4], [0, 4, 4]),\n        # Case 5 (empty first array)\n        ([], [1, 2]),\n        # Case 6 (empty second array)\n        ([1, 2], []),\n        # Case 7 (negative numbers and zero)\n        ([-5, -1, 0, 2], [3, -1, 4]),\n    ]\n\n    all_results_str = []\n    for a, b in test_cases:\n        result = find_first_common_element(a, b)\n        # Format the result list as a string \"[v,i,j]\" without spaces\n        v, i, j = result\n        all_results_str.append(f\"[{v},{i},{j}]\")\n\n    # Final print statement in the exact required format: [[...],[...],...]\n    print(f\"[{','.join(all_results_str)}]\")\n\ndef find_first_common_element(A, B):\n    \"\"\"\n    Finds the first common element between arrays A and B.\n\n    The function finds the element `v` that appears earliest in `A` and is also\n    present in `B`. It returns a list `[v, i, j]`, where `i` is the index of `v`\n    in `A` and `j` is the index of the first occurrence of `v` in `B`.\n\n    If no common element exists, it returns [-1, -1, -1].\n\n    Args:\n        A (list[int]): The first array.\n        B (list[int]): The second array.\n\n    Returns:\n        list[int]: A list containing the value, index in A, and index in B,\n                   or [-1, -1, -1] if no common element is found.\n    \"\"\"\n    # Phase 1: Pre-process array B to create a hash map of values\n    # to their first-seen (leftmost) index.\n    b_value_to_index_map = {}\n    for j, val in enumerate(B):\n        if val not in b_value_to_index_map:\n            b_value_to_index_map[val] = j\n\n    # Phase 2: Iterate through array A and check for membership in the map.\n    # The first element found is the answer due to the left-to-right scan of A.\n    for i, val in enumerate(A):\n        if val in b_value_to_index_map:\n            j_in_b = b_value_to_index_map[val]\n            return [val, i, j_in_b]\n\n    # If the loop completes, no common element was found.\n    return [-1, -1, -1]\n\n# Execute the solution.\nsolve()\n```", "id": "3245002"}]}