{"hands_on_practices": [{"introduction": "To truly master an algorithm, we must understand its performance at the extremes. This exercise challenges you to quantify the \"distance\" between the best-case and worst-case scenarios for Optimized Bubble Sort. By determining the minimum number of pairwise swaps needed to transform a perfectly sorted array into a reverse-sorted one, you will engage with the fundamental permutation structure that underpins the sorting process [@problem_id:3257618].", "problem": "Consider an array of $n$ distinct keys to be sorted in nondecreasing order using the optimized variant of Bubble Sort, which proceeds in passes from left to right comparing adjacent pairs and swapping them whenever they are out of order, and which terminates early immediately after any pass in which no swaps occur. The best-case input is defined to be any input for which the algorithm terminates after the first pass. The worst-case input is defined to be any input for which the algorithm performs the maximal number of passes with swaps occurring during each pass until the array becomes sorted.\n\nA single \"pairwise swap\" operation is defined here as exchanging the elements at any two distinct indices $i$ and $j$ in the array in one operation (not restricted to adjacent elements). Starting from a best-case input, determine the minimum number of such pairwise swap operations required to obtain a worst-case input for the optimized Bubble Sort. Express your answer as a closed-form analytic expression in $n$. No rounding is required, and no physical units are involved.", "solution": "The problem is well-posed and scientifically grounded within the domain of algorithm analysis and discrete mathematics. All terms are either standard or explicitly defined, and the premises are self-contained and consistent. The problem is therefore deemed valid and a solution can be derived.\n\nFirst, we must precisely characterize the best-case and worst-case inputs for the optimized Bubble Sort algorithm as described. The array consists of $n$ distinct keys to be sorted in nondecreasing order.\n\nA best-case input is defined as one for which the algorithm terminates after the first pass. This occurs if and only if the first pass involves zero swaps. For this to happen, every adjacent pair of elements must already be in nondecreasing order. Since all keys are distinct, this means the array must be strictly sorted in increasing order. Let the set of distinct keys be $\\{k_1, k_2, \\dots, k_n\\}$ where $k_1  k_2  \\dots  k_n$. The best-case input is the array $A_{\\text{best}} = [k_1, k_2, \\dots, k_n]$.\n\nA worst-case input is defined as one for which the algorithm performs the maximal number of passes with swaps occurring during each pass. In each pass of Bubble Sort, the largest element not yet in its final sorted position is \"bubbled\" towards its correct location. After $p$ passes, the largest $p$ elements of the array are guaranteed to be in their final sorted positions. The maximum number of passes that can involve swaps is $n-1$, after which the entire array is sorted. To ensure swaps occur in every one of these $n-1$ passes, we must maximize the disorder. This is achieved when the array is sorted in reverse (decreasing) order. In this configuration, every adjacent pair is out of order, guaranteeing a maximum number of swaps in the first pass. The largest element, $k_n$, starts at the first position and requires $n-1$ adjacent swaps to move to the last position. After this pass, the second-largest element, $k_{n-1}$, is in the first position of the remaining unsorted subarray, and so on. Swaps will occur in passes $1, 2, \\dots, n-1$. The $n$-th pass will find the array sorted and perform no swaps, causing termination. Thus, the worst-case input is the array sorted in reverse order: $A_{\\text{worst}} = [k_n, k_{n-1}, \\dots, k_1]$.\n\nThe problem asks for the minimum number of \"pairwise swaps\" (exchanging elements at any two distinct indices $i$ and $j$) to transform $A_{\\text{best}}$ into $A_{\\text{worst}}$. Without loss of generality, we can represent the distinct keys by the integers $\\{1, 2, \\dots, n\\}$.\nThe starting array (best-case) is $A_{\\text{best}} = [1, 2, \\dots, n]$.\nThe target array (worst-case) is $A_{\\text{worst}} = [n, n-1, \\dots, 1]$.\n\nThis transformation corresponds to a permutation $\\pi$ of the elements $\\{1, 2, \\dots, n\\}$. The element at position $i$ in $A_{\\text{best}}$ is $i$. This element moves to position $n-i+1$ in $A_{\\text{worst}}$. Therefore, the permutation can be defined as $\\pi(i) = n-i+1$ for $i \\in \\{1, 2, \\dots, n\\}$.\n\nThe minimum number of swaps (which are transpositions in permutation theory) required to generate a permutation $\\sigma$ on $n$ elements is given by the formula $n - c(\\sigma)$, where $c(\\sigma)$ is the number of disjoint cycles in the cycle decomposition of $\\sigma$. Our task is to find the number of disjoint cycles for our permutation $\\pi(i) = n-i+1$.\n\nLet's analyze the structure of the cycles. A cycle is formed by repeatedly applying $\\pi$.\nConsider an element $i$: $\\pi(i) = n-i+1$.\nApplying $\\pi$ again: $\\pi(\\pi(i)) = \\pi(n-i+1) = n - (n-i+1) + 1 = n - n + i - 1 + 1 = i$.\nSince $\\pi(\\pi(i)) = i$ for all $i$, the permutation is an involution. This means all its disjoint cycles have a length of either $1$ (fixed points) or $2$ (transpositions).\n\nA cycle is of the form $(i, \\pi(i)) = (i, n-i+1)$.\nAn element $i$ is a fixed point (a cycle of length $1$) if $i = \\pi(i)$, which means $i = n-i+1$. This simplifies to $2i = n+1$, or $i = \\frac{n+1}{2}$.\nAn element $i$ is part of a 2-cycle if $i \\neq \\pi(i)$, i.e., $i \\neq \\frac{n+1}{2}$.\n\nWe analyze the number of cycles, $c(\\pi)$, by considering the parity of $n$.\n\nCase 1: $n$ is even.\nLet $n = 2k$ for some positive integer $k$. The condition for a fixed point is $i = \\frac{2k+1}{2} = k + \\frac{1}{2}$. Since $i$ must be an integer, there are no fixed points. All elements are part of 2-cycles of the form $(i, 2k-i+1)$.\nThe pairs are:\n$(1, 2k)$\n$(2, 2k-1)$\n$\\dots$\n$(k, k+1)$\nThere are $k$ such disjoint 2-cycles. Thus, the total number of cycles is $c(\\pi) = k = \\frac{n}{2}$.\n\nCase 2: $n$ is odd.\nLet $n = 2k+1$ for some non-negative integer $k$. The condition for a fixed point is $i = \\frac{(2k+1)+1}{2} = \\frac{2k+2}{2} = k+1$. So, the element $k+1$ is a fixed point, forming a 1-cycle $(k+1)$.\nThe remaining $n-1 = 2k$ elements form $k$ disjoint 2-cycles:\n$(1, 2k+1)$\n$(2, 2k)$\n$\\dots$\n$(k, k+2)$\nThe total number of cycles is the sum of the 2-cycles and the 1-cycle: $c(\\pi) = k + 1$. Since $k = \\frac{n-1}{2}$, we have $c(\\pi) = \\frac{n-1}{2} + 1 = \\frac{n+1}{2}$.\n\nWe can unify the expression for $c(\\pi)$ using the ceiling function: $c(\\pi) = \\lceil \\frac{n}{2} \\rceil$.\nIf $n=2k$, $c(\\pi) = \\lceil \\frac{2k}{2} \\rceil = k = \\frac{n}{2}$. Correct.\nIf $n=2k+1$, $c(\\pi) = \\lceil \\frac{2k+1}{2} \\rceil = \\lceil k + \\frac{1}{2} \\rceil = k+1 = \\frac{n+1}{2}$. Correct.\n\nThe minimum number of pairwise swaps, $S_n$, is $n - c(\\pi)$.\n$S_n = n - \\lceil \\frac{n}{2} \\rceil$\n\nLet's evaluate this expression for the two cases:\nCase 1: $n$ is even ($n=2k$).\n$S_n = n - \\frac{n}{2} = \\frac{n}{2}$.\n\nCase 2: $n$ is odd ($n=2k+1$).\n$S_n = n - \\frac{n+1}{2} = \\frac{2n - (n+1)}{2} = \\frac{n-1}{2}$.\n\nThese two results can be expressed by a single closed-form expression using the floor function: $S_n = \\lfloor \\frac{n}{2} \\rfloor$.\nIf $n=2k$, $\\lfloor \\frac{2k}{2} \\rfloor = \\lfloor k \\rfloor = k = \\frac{n}{2}$. Correct.\nIf $n=2k+1$, $\\lfloor \\frac{2k+1}{2} \\rfloor = \\lfloor k + \\frac{1}{2} \\rfloor = k = \\frac{n-1}{2}$. Correct.\n\nTherefore, the minimum number of pairwise swaps required to transform a sorted array into a reverse-sorted array is $\\lfloor \\frac{n}{2} \\rfloor$.", "answer": "$$\\boxed{\\left\\lfloor \\frac{n}{2} \\right\\rfloor}$$", "id": "3257618"}, {"introduction": "Sorting algorithms typically assume a transitive \"less than\" relationship: if $A  B$ and $B  C$, then $A  C$. This thought-provoking problem breaks that rule by applying bubble sort to the non-transitive logic of Rock-Paper-Scissors ($R \\prec P \\prec S \\prec R$). By tracing the algorithm's behavior in this cyclical system, you will gain a deeper appreciation for the assumptions that govern sorting and discover how algorithms can find stable states even in unconventional contexts [@problem_id:3257569].", "problem": "Consider the set $\\{R,P,S\\}$ representing the moves in Rock-Paper-Scissors (RPS), with a binary relation $\\prec$ defined on distinct elements by $R \\prec P$, $P \\prec S$, and $S \\prec R$, and extended with $x \\not\\prec x$ for any $x \\in \\{R,P,S\\}$. This relation is non-transitive because $R \\prec P$ and $P \\prec S$ do not imply $R \\prec S$ (indeed $S \\prec R$ holds). A comparison function for sorting is given by testing $x \\prec y$ (interpreted as “$x$ should come before $y$”); the sorting goal is that for an array $A$ of length $n$, adjacent positions satisfy $A[i] \\prec A[i+1]$ or $A[i] = A[i+1]$ for all indices $i \\in \\{1,\\dots,n-1\\}$.\n\nAn implementation of optimized bubble sort is used, defined as the classical adjacent-swap bubble sort with two common optimizations: (i) an “early exit” flag that terminates the algorithm after any pass with zero swaps, and (ii) shrinking the inner-loop boundary on each pass to the index of the last swap. Assume all elements of the array are distinct and belong to $\\{R,P,S\\}$, and the comparator implements the above $\\prec$.\n\nWhich of the following statements are correct about the behavior of optimized bubble sort on all $3! = 6$ initial permutations of $\\{R,P,S\\}$ under this non-transitive comparator?\n\nA. For any initial permutation of $\\{R,P,S\\}$, optimized bubble sort terminates and the final array is one of exactly $\\langle R,P,S\\rangle$, $\\langle P,S,R\\rangle$, or $\\langle S,R,P\\rangle$ (each satisfies $A[1] \\prec A[2]$ and $A[2] \\prec A[3]$).\n\nB. There exists an initial permutation for which optimized bubble sort fails to terminate (the outer loop never observes a pass with zero swaps).\n\nC. The final permutation produced by optimized bubble sort is a total order extending $\\prec$ (it is consistent with all pairwise relations induced by $\\prec$) on $\\{R,P,S\\}$.\n\nD. Shrinking the inner-loop boundary to the last swap index affects only the number of comparisons performed per pass and does not change which of the three possible final permutations is reached; the early exit optimization likewise does not affect which final permutation is reached.\n\nE. It is possible for the early exit optimization to terminate after a pass with zero swaps even though a subsequent pass would perform at least one swap, i.e., the algorithm can terminate prematurely with adjacent violations still present somewhere in the array.", "solution": "The user wants a critical analysis of an optimized bubble sort algorithm operating on permutations of `{R, P, S}` with a non-transitive comparator.\n\n### Step 1: Extract Givens\n- **Set of elements**: $\\{R, P, S\\}$ representing Rock, Paper, Scissors.\n- **Binary relation $\\prec$**: Defined on distinct elements as $R \\prec P$, $P \\prec S$, and $S \\prec R$. For any element $x$, $x \\not\\prec x$.\n- **Non-transitivity**: The relation is non-transitive, e.g., $R \\prec P$ and $P \\prec S$ holds, but $R \\prec S$ does not; instead, $S \\prec R$.\n- **Comparison function**: Implements $x \\prec y$, interpreted as \"$x$ should come before $y$\". This means in a standard sorting context where $A[i] > A[i+1]$ triggers a swap, the equivalent condition here is that $A[i]$ should not come before $A[i+1]$. Therefore, a swap is triggered if `not (A[i] \\prec A[i+1])`. For distinct elements, this is equivalent to swapping if $A[i+1] \\prec A[i]$.\n- **Sorting goal**: For a final array $A$ of length $n$, adjacent elements must satisfy $A[i] \\prec A[i+1]$ or $A[i] = A[i+1]$ for all $i \\in \\{1, \\dots, n-1\\}$. As the input elements are distinct, this simplifies to $A[i] \\prec A[i+1]$ for all adjacent pairs.\n- **Algorithm**: Optimized bubble sort, with two specific optimizations:\n    1.  **Early exit**: The algorithm terminates after any pass that results in zero swaps.\n    2.  **Shrinking boundary**: The inner-loop's upper bound for the next pass is reduced to the index of the last swap from the current pass.\n- **Input**: All $3! = 6$ permutations of the distinct elements $\\{R, P, S\\}$. The array length is $n=3$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is well-grounded in the principles of algorithm analysis and discrete mathematics (partially ordered and non-transitive relations). The concepts of bubble sort, its optimizations, and non-transitive relations are standard and well-defined. The problem is a valid theoretical exercise.\n- **Well-Posed**: The algorithm is deterministic. The set of inputs is finite and small ($6$ permutations). The behavior of the algorithm for each input can be uniquely determined by tracing its execution. The question asks for an analysis of this behavior, which is a well-posed problem.\n- **Objective**: The problem is stated using precise, objective, and formal language. The relation $\\prec$, the algorithm's optimizations, and the sorting goal are all defined unambiguously.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. I will proceed with the derivation and analysis.\n\n### Derivation and Solution\nThe core of the bubble sort algorithm involves passes of adjacent comparisons and swaps. The condition for swapping $A[i]$ and $A[i+1]$ is $A[i+1] \\prec A[i]$. The relation is defined as the cycle $R \\prec P \\prec S \\prec R$.\n\nThe algorithm terminates when a pass completes with zero swaps. This occurs if and only if the array $A$ satisfies `not (A[i+1] \\prec A[i])` for all compared adjacent pairs. For distinct elements, this means $A[i] \\prec A[i+1]$ for those pairs. The shrinking boundary optimization restricts the range of these comparisons in subsequent passes. An array is \"sorted\" according to the problem's goal if $A[0] \\prec A[1]$ and $A[1] \\prec A[2]$ (using $0$-based indexing for an array of length $3$).\n\nThe possible \"sorted\" arrays are:\n1.  $\\langle R, P, S \\rangle$, since $R \\prec P$ and $P \\prec S$.\n2.  $\\langle P, S, R \\rangle$, since $P \\prec S$ and $S \\prec R$.\n3.  $\\langle S, R, P \\rangle$, since $S \\prec R$ and $R \\prec P$.\n\nThese three are the only permutations that satisfy the sorting goal.\n\nThe canonical implementation for this optimized bubble sort is as follows (using $0$-based indexing and `n` as the exclusive upper bound for the inner loop):\n`bound = n`\n`do {`\n  `last_swap_index = -1`\n  `for i = 0 to bound - 2 {`\n    `if A[i+1] \\prec A[i] {`\n      `swap(A[i], A[i+1])`\n      `last_swap_index = i`\n    `}`\n  `}`\n  `bound = last_swap_index + 1`\n`} while (last_swap_index != -1)`\n\nLet's trace the algorithm on all $3! = 6$ permutations of $\\{R,P,S\\}$.\n\n1.  **Initial: $\\langle R, P, S \\rangle$**\n    - Pass 1:\n        - `i=0`: Compare $(R, P)$. Is $P \\prec R$? No. No swap.\n        - `i=1`: Compare $(P, S)$. Is $S \\prec P$? No. No swap.\n    - `last_swap_index` remains $-1$. The `do-while` loop terminates.\n    - **Final state: $\\langle R, P, S \\rangle$**. This is a sorted state.\n\n2.  **Initial: $\\langle P, S, R \\rangle$**\n    - Pass 1:\n        - `i=0`: Compare $(P, S)$. Is $S \\prec P$? No. No swap.\n        - `i=1`: Compare $(S, R)$. Is $R \\prec S$? No. No swap.\n    - `last_swap_index` remains $-1$. Loop terminates.\n    - **Final state: $\\langle P, S, R \\rangle$**. This is a sorted state.\n\n3.  **Initial: $\\langle S, R, P \\rangle$**\n    - Pass 1:\n        - `i=0`: Compare $(S, R)$. Is $R \\prec S$? No. No swap.\n        - `i=1`: Compare $(R, P)$. Is $P \\prec R$? No. No swap.\n    - `last_swap_index` remains $-1$. Loop terminates.\n    - **Final state: $\\langle S, R, P \\rangle$**. This is a sorted state.\n\n4.  **Initial: $\\langle P, R, S \\rangle$**\n    - Pass 1:\n        - `i=0`: Compare $(P, R)$. Is $R \\prec P$? Yes. Swap. Array becomes $\\langle R, P, S \\rangle$. `last_swap_index` becomes $0$.\n        - `i=1`: Compare $(P, S)$. Is $S \\prec P$? No. No swap.\n    - `bound` for next pass becomes $0 + 1 = 1$.\n    - Pass 2: The loop `for i = 0 to 1-2` (i.e., `0 to -1`) does not execute. `last_swap_index` remains $-1$. Loop terminates.\n    - **Final state: $\\langle R, P, S \\rangle$**. This is a sorted state.\n\n5.  **Initial: $\\langle R, S, P \\rangle$**\n    - Pass 1:\n        - `i=0`: Compare $(R, S)$. Is $S \\prec R$? Yes. Swap. Array becomes $\\langle S, R, P \\rangle$. `last_swap_index` becomes $0$.\n        - `i=1`: Compare $(R, P)$. Is $P \\prec R$? No. No swap.\n    - `bound` becomes $1$.\n    - Pass 2: The loop does not execute. `last_swap_index` is $-1$. Loop terminates.\n    - **Final state: $\\langle S, R, P \\rangle$**. This is a sorted state.\n\n6.  **Initial: $\\langle S, P, R \\rangle$**\n    - Pass 1:\n        - `i=0`: Compare $(S, P)$. Is $P \\prec S$? Yes. Swap. Array becomes $\\langle P, S, R \\rangle$. `last_swap_index` becomes $0$.\n        - `i=1`: Compare $(S, R)$. Is $R \\prec S$? No. No swap.\n    - `bound` becomes $1$.\n    - Pass 2: The loop does not execute. `last_swap_index` is $-1$. Loop terminates.\n    - **Final state: $\\langle P, S, R \\rangle$**. This is a sorted state.\n\nThe exhaustive trace demonstrates that for every initial permutation, the algorithm terminates and produces one of the three \"sorted\" arrays.\n\n### Option-by-Option Analysis\n\n**A. For any initial permutation of $\\{R,P,S\\}$, optimized bubble sort terminates and the final array is one of exactly $\\langle R,P,S\\rangle$, $\\langle P,S,R\\rangle$, or $\\langle S,R,P\\rangle$ (each satisfies $A[1] \\prec A[2]$ and $A[2] \\prec A[3]$).**\nThe exhaustive trace of all $6$ permutations above confirms this statement. The algorithm always terminates, and the final state is always one of the three specified arrays which satisfy the sorting goal. (Note: The problem uses $1$-based indexing $A[1], A[2], A[3]$, which corresponds to my $0$-based $A[0], A[1], A[2]$).\n**Verdict: Correct.**\n\n**B. There exists an initial permutation for which optimized bubble sort fails to terminate (the outer loop never observes a pass with zero swaps).**\nThe `bound` variable in the optimized algorithm is a non-increasing integer. If swaps occur, `bound = last_swap_index + 1`. Since `last_swap_index` is at most $bound - 2$, the new `bound` is at most $bound - 1$. Thus, `bound` is a strictly decreasing sequence of positive integers as long as swaps are made. Such a sequence must eventually reach a value ($0$ or $1$) for which the inner loop no longer runs, leading to termination. Therefore, the algorithm always terminates. Our trace also confirms termination for all inputs.\n**Verdict: Incorrect.**\n\n**C. The final permutation produced by optimized bubble sort is a total order extending $\\prec$ (it is consistent with all pairwise relations induced by $\\prec$) on $\\{R,P,S\\}$.**\nA total order must be transitive. The relation $\\prec$ is non-transitive and cyclic: $R \\prec P$, $P \\prec S$, and $S \\prec R$. If a total order $\\leq$ were to extend $\\prec$, we would have $R \\leq P$, $P \\leq S$, and $S \\leq R$. By transitivity, $R \\leq P$ and $P \\leq S$ implies $R \\leq S$. Combining with $S \\leq R$, we get $R = S$, but the elements are distinct. This is a contradiction. Therefore, no total order can extend $\\prec$. The statement is based on a false premise.\n**Verdict: Incorrect.**\n\n**D. Shrinking the inner-loop boundary to the last swap index affects only the number of comparisons performed per pass and does not change which of the three possible final permutations is reached; the early exit optimization likewise does not affect which final permutation is reached.**\nLet's analyze the effect of removing optimizations. For an unsorted input like $\\langle P, R, S \\rangle$, the first pass of bubble sort (regardless of optimization) performs a swap at index $0$, resulting in $\\langle R, P, S \\rangle$. This state is sorted. A non-optimized bubble sort would continue for a fixed number of passes, but since the array is already sorted, no further swaps would occur. An early-exit version would perform one more pass to confirm it's sorted and then terminate. The fully optimized version terminates even faster. In all cases for $n=3$, the crucial swaps occur in the first pass, and the resulting state is one of the three sorted ones. Subsequent passes or comparisons (which are pruned by optimizations) do not alter this outcome. The statement is correct for the specific problem context ($n=3$ permutations of $\\{R,P,S\\}$).\n**Verdict: Correct.**\n\n**E. It is possible for the early exit optimization to terminate after a pass with zero swaps even though a subsequent pass would perform at least one swap, i.e., the algorithm can terminate prematurely with adjacent violations still present somewhere in the array.**\nThe \"early exit\" triggers upon a pass with zero swaps. A zero-swap pass over a range of indices is definitive proof that for all pairs $(A[i], A[i+1])$ in that range, the condition $A[i+1] \\prec A[i]$ is false. This means the array segment is locally sorted. Running another pass over the same data will yield the same result: zero swaps. The termination condition of bubble sort—the absence of adjacent swappable pairs—is precisely the definition of the sorted state. Therefore, it cannot terminate \"prematurely\" with violations present in the scanned area. The shrinking boundary ensures that the unscanned tail is already stable from prior passes, a property that holds even in this non-transitive case for $n=3$.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{AD}$$", "id": "3257569"}, {"introduction": "This practice frames algorithm analysis as a form of \"digital forensics.\" Instead of running the sort forward, you are given the final sorted output and a complete record of every adjacent swap performed. Your task is to reverse the process and reconstruct the original, unsorted array. This hands-on coding challenge reinforces the idea that sorting is a sequence of invertible operations and provides a powerful mental model for how data transforms through an algorithm [@problem_id:3257578].", "problem": "You are given the chronological record of adjacent swaps performed by an optimized bubble sort on an unknown array of integers, together with the final sorted output of that array. The optimized bubble sort variant reduces the comparison boundary after each pass because the largest element in the remaining unsorted prefix is moved to the end, and it terminates early if a pass performs zero swaps. Each recorded swap is the index $i$ of the adjacent pair $\\left(A[i], A[i+1]\\right)$ that was swapped at that moment. Indices are $0$-based. All values are integers and may include duplicates. Your task is to reconstruct the original array before sorting.\n\nFundamental base definitions to use:\n- Bubble sort, in ascending order, repeatedly compares adjacent pairs $\\left(A[i], A[i+1]\\right)$ and swaps them when $A[i] > A[i+1]$. After each full pass, the algorithm reduces the effective range by one because the largest remaining element has reached its final position. The optimized variant terminates when a pass completes with zero swaps.\n- An adjacent swap at index $i$ is the function $t_i$ that exchanges the elements at positions $i$ and $i+1$.\n- The chronological swap record $S = \\left[i_0, i_1, \\dots, i_{k-1}\\right]$ corresponds to composing adjacent transpositions on the evolving array. If $A_0$ denotes the unknown original array and $B$ denotes the final sorted array, then there exists a permutation $P$ such that $B = P\\left(A_0\\right)$, where $P$ is the composition of the adjacent transpositions induced by the swap record. The inverse permutation $P^{-1}$ recovers $A_0$ from $B$.\n\nYour program must implement an algorithm that, given:\n- the array length $n$,\n- the final sorted array $B$,\n- and the chronological list of swap indices $S$ produced by an optimized bubble sort,\n\nreturns the original array $A_0$ that, when sorted by the optimized bubble sort, would yield exactly the swap record $S$ and the final sorted array $B$.\n\nUse purely mathematical and logical reasoning to design your algorithm from the above base definitions. Do not rely on any shortcut formulas; derive the reconstruction process from first principles about permutations and adjacent transpositions.\n\nTest suite and required output:\n- Apply your algorithm to the following five test cases. Each test case provides $\\left(n, B, S\\right)$ and expects the reconstructed original array $A_0$ as the result.\n    1. $n = 5$, $B = \\left[1,2,4,5,8\\right]$, $S = \\left[0,1,2,1\\right]$.\n    2. $n = 4$, $B = \\left[1,2,3,4\\right]$, $S = \\left[\\right]$.\n    3. $n = 5$, $B = \\left[1,2,3,4,5\\right]$, $S = \\left[0,1,2,3,0,1,2,0,1,0\\right]$.\n    4. $n = 4$, $B = \\left[1,1,2,3\\right]$, $S = \\left[0,1,2,1\\right]$.\n    5. $n = 1$, $B = \\left[42\\right]$, $S = \\left[\\right]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the reconstructed arrays for the five test cases as a comma-separated list enclosed in square brackets, with each array printed in bracketed, comma-separated form and no spaces. For example, the output should look like $\\left[\\left[a_{0,0},a_{0,1},\\dots\\right],\\left[a_{1,0},a_{1,1},\\dots\\right],\\dots\\right]$.", "solution": "The problem requires the reconstruction of an original integer array, denoted as $A_0$, from which a final sorted array $B$ and a chronological record of swap indices $S$ were produced by an optimized bubble sort algorithm. The core of the task is to reverse the sorting process to recover the initial state $A_0$. This can be accomplished by applying the inverse of the permutation defined by the swap record to the final array $B$.\n\nLet us formalize the process based on the provided definitions. The original array is $A_0$. The sorting process involves a sequence of $k$ adjacent swaps, where $k$ is the total number of swaps recorded in $S = [i_0, i_1, \\dots, i_{k-1}]$. Let $t_i$ represent the adjacent transposition operator that swaps the elements at indices $i$ and $i+1$ in an array.\n\nThe sorting process transforms the array step-by-step. Let $A^{(j)}$ be the state of the array after the $j$-th swap (using $1$-based indexing for the sequence of swaps for clarity in derivation, so $j$ from $1$ to $k$).\nThe initial state is $A^{(0)} = A_0$.\nThe state after the first swap (at index $i_0$) is $A^{(1)} = t_{i_0}(A^{(0)})$.\nThe state after the second swap (at index $i_1$) is $A^{(2)} = t_{i_1}(A^{(1)})$.\nThis continues for all $k$ swaps. The final sorted array $B$ is the state after the last swap:\n$$B = A^{(k)} = t_{i_{k-1}}(A^{(k-1)})$$\nBy repeatedly substituting the expressions for the previous states, we can express $B$ as a composition of all transposition operators applied to the original array $A_0$:\n$$B = t_{i_{k-1}}(t_{i_{k-2}}(\\dots(t_{i_0}(A_0))\\dots))$$\nIn the language of function composition, this is written as:\n$$B = (t_{i_{k-1}} \\circ t_{i_{k-2}} \\circ \\dots \\circ t_{i_0})(A_0)$$\nLet us define the total permutation $P$ produced by the entire sorting process as this composition of transpositions:\n$$P = t_{i_{k-1}} \\circ t_{i_{k-2}} \\circ \\dots \\circ t_{i_0}$$\nThe relationship between the original array $A_0$ and the final array $B$ is thus $B = P(A_0)$.\n\nOur goal is to find $A_0$. To do this, we must apply the inverse permutation $P^{-1}$ to both sides of the equation:\n$$P^{-1}(B) = P^{-1}(P(A_0))$$\n$$P^{-1}(B) = (P^{-1} \\circ P)(A_0)$$\nSince $P^{-1} \\circ P$ is the identity permutation, we get:\n$$A_0 = P^{-1}(B)$$\nNow, we must find the inverse permutation $P^{-1}$. The inverse of a composition of operators $(g \\circ f)^{-1}$ is $f^{-1} \\circ g^{-1}$. Applying this rule to $P$:\n$$P^{-1} = (t_{i_{k-1}} \\circ t_{i_{k-2}} \\circ \\dots \\circ t_{i_0})^{-1} = t_{i_0}^{-1} \\circ t_{i_1}^{-1} \\circ \\dots \\circ t_{i_{k-1}}^{-1}$$\nAn adjacent transposition $t_i$ is an operation that swaps two elements. Applying the same swap twice restores the elements to their original positions. Therefore, any adjacent transposition is its own inverse: $t_i \\circ t_i = \\text{identity}$, which implies $t_i^{-1} = t_i$.\n\nSubstituting $t_i^{-1} = t_i$ into the expression for $P^{-1}$, we obtain:\n$$P^{-1} = t_{i_0} \\circ t_{i_1} \\circ \\dots \\circ t_{i_{k-1}}$$\nFinally, we can express the reconstruction of $A_0$ as:\n$$A_0 = (t_{i_0} \\circ t_{i_1} \\circ \\dots \\circ t_{i_{k-1}})(B)$$\nThis composition dictates that to obtain $A_0$, we must start with the final array $B$ and apply the transpositions in the order $t_{i_{k-1}}$, then $t_{i_{k-2}}$, and so on, ending with $t_{i_0}$. This is equivalent to iterating through the given swap record $S = [i_0, i_1, \\dots, i_{k-1}]$ in reverse chronological order and applying each swap.\n\nThe algorithm for reconstructing $A_0$ is as follows:\n$1$. Create a mutable copy of the final sorted array $B$. Let this be `current_array`.\n$2$. Iterate through the list of swap indices $S$ from the last index $k-1$ down to the first index $0$.\n$3$. For each swap index $i_j$ encountered in this reverse iteration, perform an adjacent swap on `current_array` at index $i_j$. That is, exchange the elements `current_array`$[i_j]$ and `current_array`$[i_j+1]$.\n$4$. After the loop completes, `current_array` will hold the state of the original array, $A_0$.\n\nThis algorithm is derived entirely from the first principles of permutations and their inverses, as required. It correctly reverses the recorded transformation to recover the initial state.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the array reconstruction problem for a given suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (n, B, S)\n    # n: integer, length of the array\n    # B: list, the final sorted array\n    # S: list, the chronological list of swap indices\n    test_cases = [\n        (5, [1, 2, 4, 5, 8], [0, 1, 2, 1]),\n        (4, [1, 2, 3, 4], []),\n        (5, [1, 2, 3, 4, 5], [0, 1, 2, 3, 0, 1, 2, 0, 1, 0]),\n        (4, [1, 1, 2, 3], [0, 1, 2, 1]),\n        (1, [42], [])\n    ]\n\n    def reconstruct_array(n, B, S):\n        \"\"\"\n        Reconstructs the original array A0 from the final sorted array B and\n        the chronological swap record S.\n\n        Args:\n            n (int): The length of the array.\n            B (list): The final sorted array.\n            S (list): The chronological list of swap indices.\n\n        Returns:\n            list: The reconstructed original array A0.\n        \"\"\"\n        # Start with the final sorted array. Use a numpy array for mutability and\n        # to adhere to the specified environment.\n        current_array = np.array(B)\n\n        # To find the original array, we must reverse the sorting process.\n        # This is achieved by applying the swaps in the reverse chronological order\n        # to the final sorted array. The inverse of a swap is the swap itself.\n        for swap_index in reversed(S):\n            # temp = current_array[swap_index]\n            # current_array[swap_index] = current_array[swap_index + 1]\n            # current_array[swap_index + 1] = temp\n            \n            # A more Pythonic way to swap elements\n            current_array[swap_index], current_array[swap_index + 1] = \\\n                current_array[swap_index + 1], current_array[swap_index]\n\n        return current_array.tolist()\n\n    results = []\n    for case in test_cases:\n        n, B, S = case\n        original_array = reconstruct_array(n, B, S)\n        results.append(original_array)\n\n    # Format the results into the exact single-line string specified.\n    # e.g., [[a,b,c],[d,e],...]\n    formatted_results = []\n    for r in results:\n        formatted_results.append(f\"[{','.join(map(str, r))}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3257578"}]}