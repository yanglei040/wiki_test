{"hands_on_practices": [{"introduction": "To solidify our understanding, let's begin with a foundational task: removing specific elements from an array. This exercise directly contrasts the simplicity of an out-of-place approach, which creates a new array, with the space efficiency of an in-place algorithm that compacts the array by shifting elements. By precisely counting the number of write operations for each method, you will gain a tangible sense of the performance trade-offs involved [@problem_id:3241063].", "problem": "Design and analyze two algorithms that remove all elements equal to a given value $x$ from an array while preserving the original relative order of the remaining elements. Use the following foundational base: the definition of an in-place algorithm as one that uses $O(1)$ additional space beyond the input data structure, the concept of stability in algorithms as the preservation of the original order of equal elements, and a simple operation model where a \"write\" is any assignment that stores a value into an array cell. The goal is to define a precise write-count metric and compare an in-place stable compaction algorithm against an out-of-place stable filter.\n\nRequirements:\n- Implement an in-place stable compaction algorithm that uses two indices to move kept elements leftward. The algorithm must operate with $O(1)$ additional memory and must not allocate auxiliary arrays proportional to the input length. A write should be counted if and only if it stores a value into a destination array cell whose index differs from the source index, thereby excluding redundant self-assignments. Do not count any writes to cells beyond the compacted prefix, and do not count any memory deallocation or resizing.\n- Implement an out-of-place stable filter that constructs a new array by appending each element that is not equal to $x$. Count one write for each append operation into the new array. Ignore any writes to the original array.\n\nLet $n$ denote the array length, let $m$ denote the number of elements equal to $x$, and let $f$ denote the fraction of matches so that $f = m/n$. Let $k = n - m$ denote the number of retained elements. The in-place algorithm must retain stability. The out-of-place algorithm must retain stability. Both algorithms must be evaluated by the number of writes under the defined rules.\n\nTest suite:\n- Case A: $n = 10$, $f = 0.3$, array $A = \\{\\,$ $1$, $2$, $0$, $3$, $4$, $0$, $5$, $0$, $6$, $7$ $\\}$ with $x = 0$.\n- Case B: $n = 10$, $f = 0.0$, array $B = \\{\\,$ $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$, $9$, $10$ $\\}$ with $x = 0$.\n- Case C: $n = 8$, $f = 1.0$, array $C = \\{\\,$ $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$ $\\}$ with $x = 0$.\n- Case D: $n = 12$, $f = 0.5$, array $D = \\{\\,$ $0$, $0$, $0$, $0$, $0$, $0$, $1$, $2$, $3$, $4$, $5$, $6$ $\\}$ with $x = 0$.\n- Case E: $n = 12$, $f = 0.25$, array $E = \\{\\,$ $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$, $9$, $0$, $0$, $0$ $\\}$ with $x = 0$.\n\nYour program must compute, for each case, a two-element list containing the write counts $[W_{\\text{in}}, W_{\\text{out}}]$, where $W_{\\text{in}}$ is the write count of the in-place algorithm and $W_{\\text{out}}$ is the write count of the out-of-place algorithm. The final output format must be a single line containing a comma-separated list of these two-element lists, enclosed in square brackets. For example, the format is $[\\,[a_1, b_1], [a_2, b_2]\\,]$ where $a_i$ and $b_i$ are integers.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each per-case result formatted as a two-element list $[W_{\\text{in}},W_{\\text{out}}]$ (e.g., $[[5,7],[0,10],[0,0]]$).", "solution": "The problem requires a comparative analysis of two stable algorithms for removing all occurrences of a value $x$ from an array. The comparison is based on a precisely defined write-count metric for an in-place compaction algorithm and an out-of-place filtering algorithm.\n\nLet $n$ be the length of the input array, $m$ be the count of elements equal to $x$, and $k = n - m$ be the count of elements to be retained.\n\n### Algorithm 1: Out-of-Place Stable Filter\n\nThis algorithm constructs a new array to store the result. It iterates through the input array, and for each element not equal to $x$, it appends that element to the new array.\n\n**Stability:** This approach is inherently stable. Elements are read from the source array in their original order, and those that are kept are written to the destination array in the same sequence, preserving their initial relative ordering.\n\n**Space Complexity:** The algorithm requires a new array to store the $k$ retained elements. Therefore, its auxiliary space complexity is $O(k)$, which can be up to $O(n)$ in the case where $m=0$. This is, by definition, an out-of-place algorithm.\n\n**Write Count ($W_{\\text{out}}$):** The problem defines the write count for this algorithm as one write for each append operation to the new array. Since exactly $k = n - m$ elements are retained and appended, the total number of writes is precisely $k$.\n$$W_{\\text{out}} = k = n - m$$\n\n### Algorithm 2: In-Place Stable Compaction\n\nThis algorithm modifies the array in-place, using $O(1)$ additional space. It employs a two-index strategy. A \"read\" index, let's call it $i$, scans the entire array from index $0$ to $n-1$. A \"write\" index, let's call it $j$, tracks the next available position for a retained element.\n\nThe process is as follows:\n1.  Initialize the write index $j = 0$.\n2.  Iterate with the read index $i$ from $0$ to $n-1$.\n3.  If the element at $A[i]$ is not equal to $x$, it must be kept.\n4.  This element is placed at position $A[j]$. According to the problem's rule, a write is counted only if the source and destination indices differ, i.e., if $i \\neq j$.\n5.  After placing a kept element at $A[j]$, the write index $j$ is incremented.\n\n**Stability:** This algorithm is stable. Let $A[p]$ and $A[q]$ be two elements to be kept, with original indices $p  q$. The read index $i$ will encounter $A[p]$ before $A[q]$. Let's say $A[p]$ is written to $A[j_1]$. The write index is then incremented. When the read index later encounters $A[q]$, it will be written to $A[j_2]$, where $j_2 > j_1$. Thus, the original relative order is preserved.\n\n**Write Count ($W_{\\text{in}}$):** A write is counted for a kept element at index $i$ only if $i \\neq j$. The indices $i$ and $j$ start at $0$ and increment together as long as every element encountered is kept. The first time an element to be removed (a value of $x$) is found at index $i_{rem}$, the read index $i$ increments, but the write index $j$ does not. From this point forward, for any subsequent element at index $i > i_{rem}$ that is kept, it will hold that $i > j$. Consequently, every kept element that appears *after the first occurrence of x* will be moved from a position $i$ to a new position $j  i$, necessitating a write. Any kept element appearing before the first $x$ will have $i=j$, resulting in no write.\n\nTherefore, $W_{\\text{in}}$ is the number of retained elements that are located at or after the index of the first occurrence of $x$ in the array. If no elements equal to $x$ exist, $W_{\\text{in}} = 0$.\n\n### Application to Test Cases\n\nWe apply these derived counting rules to each test case.\n\n**Case A:** $A = \\{1, 2, 0, 3, 4, 0, 5, 0, 6, 7\\}, x = 0$.\n-   $n = 10, m = 3$, so $k = n - m = 7$.\n-   $W_{\\text{out}} = k = 7$.\n-   The first occurrence of $x=0$ is at index $2$. The retained elements appearing at or after index $2$ are $3, 4, 5, 6, 7$. There are $5$ such elements.\n-   $W_{\\text{in}} = 5$.\n-   Result: `[5, 7]`\n\n**Case B:** $B = \\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\\}, x = 0$.\n-   $n = 10, m = 0$, so $k = n - m = 10$.\n-   $W_{\\text{out}} = k = 10$.\n-   The value $x=0$ does not appear in the array. For the in-place algorithm, the condition $i \\neq j$ will never be true.\n-   $W_{\\text{in}} = 0$.\n-   Result: `[0, 10]`\n\n**Case C:** $C = \\{0, 0, 0, 0, 0, 0, 0, 0\\}, x = 0$.\n-   $n = 8, m = 8$, so $k = n - m = 0$.\n-   $W_{\\text{out}} = k = 0$.\n-   There are no elements to retain. The inner loop condition for the in-place algorithm is never met.\n-   $W_{\\text{in}} = 0$.\n-   Result: `[0, 0]`\n\n**Case D:** $D = \\{0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6\\}, x = 0$.\n-   $n = 12, m = 6$, so $k = n - m = 6$.\n-   $W_{\\text{out}} = k = 6$.\n-   The first occurrence of $x=0$ is at index $0$. All $6$ retained elements (`$1, 2, 3, 4, 5, 6$`) appear after this index.\n-   $W_{\\text{in}} = 6$.\n-   Result: `[6, 6]`\n\n**Case E:** $E = \\{1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0\\}, x = 0$.\n-   $n = 12, m = 3$, so $k = n - m = 9$.\n-   $W_{\\text{out}} = k = 9$.\n-   The first occurrence of $x=0$ is at index $9$. There are no retained elements at or after this index.\n-   $W_{\\text{in}} = 0$.\n-   Result: `[0, 9]`", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_inplace_writes(arr: np.ndarray, x: int) - int:\n    \"\"\"\n    Calculates the number of writes for the in-place stable compaction algorithm.\n\n    A write is counted if a kept element is moved to a new position,\n    i.e., its source index `i` is not equal to its destination index `j`.\n    This happens for every kept element that appears after the first\n    occurrence of the value `x`.\n    \"\"\"\n    writes = 0\n    write_idx = 0\n    for read_idx in range(len(arr)):\n        if arr[read_idx] != x:\n            if read_idx != write_idx:\n                writes += 1\n            write_idx += 1\n    return writes\n\ndef calculate_outofplace_writes(arr: np.ndarray, x: int) - int:\n    \"\"\"\n    Calculates the number of writes for the out-of-place stable filter.\n\n    A write is counted for each element appended to the new array.\n    This is equal to the number of elements that are not equal to `x`.\n    \"\"\"\n    # Number of elements to keep is n - m, where m is count of x.\n    n = len(arr)\n    m = np.count_nonzero(arr == x)\n    k = n - m\n    return k\n\ndef solve():\n    \"\"\"\n    Executes the analysis for all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        (np.array([1, 2, 0, 3, 4, 0, 5, 0, 6, 7]), 0),  # Case A\n        (np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), 0), # Case B\n        (np.array([0, 0, 0, 0, 0, 0, 0, 0]), 0),       # Case C\n        (np.array([0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6]), 0), # Case D\n        (np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0]), 0)  # Case E\n    ]\n\n    results = []\n    for arr, x in test_cases:\n        w_in = calculate_inplace_writes(arr, x)\n        w_out = calculate_outofplace_writes(arr, x)\n        results.append(f\"[{w_in},{w_out}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3241063"}, {"introduction": "Now let's explore a scenario where the choice between in-place and out-of-place dictates the entire algorithmic strategy and impacts crucial properties like element order. In this practice, you will tackle the common problem of list deduplication, contrasting a straightforward out-of-place hash-based method with an in-place sort-and-sweep approach. This exercise reveals a deeper layer of trade-offs, where saving space with an in-place algorithm may come at the cost of altering the data's original relative ordering [@problem_id:3241056].", "problem": "You are asked to formalize and quantify the trade-offs between an out-of-place list deduplication algorithm that uses an auxiliary set and an in-place algorithm that first sorts and then sweeps with two pointers. Work in a model where a list of integers is represented in random-access memory, and where you can apply a total order and equality relation on the integers.\n\nStarting from the core definitions:\n- An algorithm is called in-place if it uses at most a constant number of extra element-sized memory locations beyond its input, independent of the input size. An algorithm is called out-of-place if its extra memory usage grows with the input size.\n- A deduplication algorithm is a procedure that transforms a list so that each distinct value appears exactly once in the result.\n\nYour task is to implement and analyze two deduplication strategies on identical inputs:\n\n1. The out-of-place strategy. It iterates from left to right, tracks previously seen values in an auxiliary set, and writes each first occurrence into a new list. This preserves the first-occurrence order.\n\n2. The in-place strategy. It first sorts the array using an in-place comparison sort that relies only on the total order of integers and uses at most a constant number of extra element-sized memory locations. Then it performs a linear two-pointer sweep to compact the sorted array in place so that each distinct value appears exactly once at the front segment.\n\nYou must quantify the following, defined precisely in terms of the primitive operations and memory model:\n\n- A comparison is any invocation of the integer total order or equality relation on two elements originally drawn from the input list. Count each such use as one comparison. For the out-of-place strategy using a hash set, do not count hashing or hash table probes as comparisons; count zero comparisons for it under this definition.\n\n- A write is any assignment of an input element’s value into a position either of the original list or of an auxiliary list newly allocated by the algorithm. A swap of two elements counts as two writes because it assigns two positions. Appending a value to a newly allocated list counts as one write.\n\n- Extra space is the maximum number of element-sized slots allocated beyond the input array during the algorithm’s execution, measured in units of elements and ignoring constant factors such as a fixed number of scalar variables. For the out-of-place algorithm, model the auxiliary set as storing exactly one element slot per distinct input value and the produced unique list as also storing exactly one element slot per distinct input value, for a total of $2u$, where $u$ is the number of distinct elements in the input. For the in-place algorithm, treat extra space as $0$ because the sort is in-place and the two-pointer sweep uses only a constant number of index variables.\n\nCorrectness requirements:\n- Let $n$ be the input size and $u$ be the number of distinct values in the input. The out-of-place algorithm must return a list of length $u$, preserving the order of first occurrences. The in-place algorithm must transform the input so that the first $u$ positions contain exactly the distinct values, in some order that may differ from the original due to sorting. For verification, it suffices that the set of values in the out-of-place result equals the set of values in the first $u$ positions of the in-place result and that both have length $u$.\n\nDesign constraints:\n- The in-place sorting subroutine must be a genuine in-place comparison sort. You must not use any external memory beyond a constant number of element-sized temporaries; for instance, an in-place heapsort is acceptable. The two-pointer sweep then runs in linear time.\n\nTest suite to execute:\n- Use the following input lists of integers:\n  - Case A: $[3,1,2,3,2,4,5,1,3]$\n  - Case B: $[]$\n  - Case C: $[5,4,3,2,1]$\n  - Case D: $[7,7,7,7]$\n  - Case E: $[0,-1,-1,2,-3,2,0,0,-3,5]$\n  - Case F: $[1,1,2,2,3,3,3,4]$\n  - Case G: $[9,8,8,7,6,6,6,5,5,4,3,3,2,1,1]$\n\nRequired outputs per test case:\n- For each case, produce a list of eight values:\n  - $L_{\\mathrm{out}}$: the length of the out-of-place unique list (an integer).\n  - $L_{\\mathrm{in}}$: the in-place unique prefix length after the sort and sweep (an integer).\n  - $E$: a boolean that is true if and only if the set of values in both results are equal and $L_{\\mathrm{out}} = L_{\\mathrm{in}}$.\n  - $S_{\\mathrm{out}}$: extra space in element units for the out-of-place algorithm, modeled as $2L_{\\mathrm{out}}$ (an integer).\n  - $S_{\\mathrm{in}}$: extra space in element units for the in-place algorithm, modeled as $0$ (an integer).\n  - $W_{\\mathrm{out}}$: total writes for the out-of-place algorithm (an integer).\n  - $W_{\\mathrm{in}}$: total writes for the in-place algorithm, including both sorting swaps and in-place compaction writes (an integer).\n  - $C_{\\mathrm{in}}$: total comparisons for the in-place algorithm, including sorting comparisons and equality checks in the sweep (an integer). For the out-of-place algorithm, treat the comparison count as $0$ under the stated model.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the eight-value list for one test case in the order A through G. For example, the outermost structure must look like $[[\\dots],[\\dots],\\dots]$ with no spaces inserted by the program. The values inside must be booleans and integers as specified. No other text should be printed.", "solution": "We proceed from first principles by grounding correctness and resource usage in core definitions of in-place algorithms, out-of-place algorithms, total order relations, and element-sized memory slots.\n\nCorrectness of out-of-place deduplication with an auxiliary set follows from the fundamental property of sets: a set contains no duplicates and supports insertion tests. Iterating left-to-right across an input of length $n$ and maintaining a set of seen values ensures that each distinct value is appended exactly once, and the first time it is encountered. Therefore the output length equals the number of distinct input values $u$, and the output preserves first-occurrence order. Under our operation model, we treat hashing and hash table probing as outside of “comparison” because they do not invoke the integer total order or equality on two input elements; thus the out-of-place comparison count is $0$. Each time we append a new unique item, we perform exactly one write to the auxiliary list, so $W_{\\mathrm{out}} = u$. By the extra space model specified, the set stores one slot per distinct element and the unique list stores one slot per distinct element, so the extra space is $S_{\\mathrm{out}} = 2u$ element slots.\n\nFor the in-place strategy, we rely on two ingredients.\n\nFirst, an in-place comparison sort such as heapsort uses only the input array and a constant number of temporaries. Heapsort constructs a binary heap in-place, then repeatedly swaps the first element into its final position and restores the heap property. The algorithm invokes the total order on input elements to drive heap comparisons, and uses swaps that write two array positions per swap. This satisfies the in-place definition because no additional array proportional to $n$ is allocated, so the extra space is $S_{\\mathrm{in}} = 0$. Its time overhead is superlinear, but our focus here is to quantify concrete operation counts $C_{\\mathrm{in}}$ (number of comparisons between two input elements) and $W_{\\mathrm{in}}$ (number of writes of input elements into array positions), which our implementation tallies exactly for the provided inputs. The construction of the heap from the array and the subsequent down-heap operations are sequences of pairwise comparisons and swaps; each swap writes two array slots, and each heap order check uses the total order comparison on two input elements, contributing to $C_{\\mathrm{in}}$.\n\nSecond, after sorting, a two-pointer sweep compacts equal runs to a unique prefix. Because the array is sorted, all duplicates are in contiguous runs. We maintain a write index that points to the last unique position and a read index that scans forward. For each new value that is not equal to the last written unique value, we advance the write index and assign the current read element into the new write position. Each step uses exactly one equality comparison between two input elements. This yields exactly the first $u$ positions containing one copy of each distinct value and preserves no particular original order, which is acceptable here. The sweep contributes its own counts to $C_{\\mathrm{in}}$ and $W_{\\mathrm{in}}$, but uses only a constant number of scalars, so contributes no additional element-sized extra space under our model.\n\nEquivalence of results is established as follows. The out-of-place method yields exactly the set of distinct values present in the input. The in-place method sorts and then writes exactly one representative of each run of equal values at the prefix of the array, which yields exactly the same set of distinct values. Let $L_{\\mathrm{out}}$ denote the length returned by the out-of-place method and $L_{\\mathrm{in}}$ denote the prefix length returned by the in-place method. By the above reasoning both equal $u$. Therefore $E$ is true precisely when these lengths match and their sets of values are equal. Our program checks this condition by comparing the sets and the lengths.\n\nTrade-offs follow directly from these definitions. The out-of-place method uses expected linear time in $n$ on a typical hash table model and uses $S_{\\mathrm{out}} = 2u$ extra element slots, and its write count equals $u$. The in-place method uses $S_{\\mathrm{in}} = 0$ extra element slots at the cost of superlinear sorting work, giving concrete counts $C_{\\mathrm{in}}$ and $W_{\\mathrm{in}}$ that reflect both heap maintenance and compaction. The two-pointer sweep itself is linear with one comparison per scanned position and at most $u-1$ compaction writes when new runs start.\n\nTo ensure a measurable and testable outcome, the program instantiates the specified test suite and reports for each case the tuple\n$[L_{\\mathrm{out}}, L_{\\mathrm{in}}, E, S_{\\mathrm{out}}, S_{\\mathrm{in}}, W_{\\mathrm{out}}, W_{\\mathrm{in}}, C_{\\mathrm{in}}]$,\nas a list of booleans and integers, aggregated into a single outer list printed on one line as required. This output allows direct observation of the central trade-off: reducing extra space from $2u$ to $0$ by paying additional comparisons and writes due to sorting.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np  # Allowed library; not strictly needed but permitted.\n\nfrom typing import List, Tuple\n\nclass Counters:\n    def __init__(self):\n        self.comparisons = 0  # Count of element-to-element comparisons (order or equality)\n        self.writes = 0       # Count of element writes (assignments into array slots)\n\ndef heapsort_in_place(arr: List[int], ctr: Counters) - None:\n    \"\"\"\n    In-place heapsort on arr, updating counters:\n    - comparisons: number of element-to-element comparisons\n    - writes: number of element assignments into array slots\n    Each swap counts as two writes.\n    \"\"\"\n    n = len(arr)\n\n    def sift_down(start: int, end: int):\n        i = start\n        while True:\n            left = 2 * i + 1\n            right = left + 1\n            largest = i\n            if left  end:\n                ctr.comparisons += 1\n                if arr[left]  arr[largest]:\n                    largest = left\n            if right  end:\n                ctr.comparisons += 1\n                if arr[right]  arr[largest]:\n                    largest = right\n            if largest != i:\n                # swap arr[i] and arr[largest]\n                arr[i], arr[largest] = arr[largest], arr[i]\n                ctr.writes += 2\n                i = largest\n            else:\n                break\n\n    # Build max heap\n    # Start from the last parent node and sift down\n    for i in range(n // 2 - 1, -1, -1):\n        sift_down(i, n)\n\n    # Extract elements from heap one by one\n    for end in range(n - 1, 0, -1):\n        # Move current max to the end (swap root with end)\n        arr[0], arr[end] = arr[end], arr[0]\n        ctr.writes += 2\n        sift_down(0, end)\n\ndef dedup_out_of_place_preserve_order(arr: List[int]) - Tuple[List[int], int]:\n    \"\"\"\n    Out-of-place deduplication using an auxiliary set to preserve first occurrence order.\n    Returns (unique_list, writes), where writes is the number of appends performed.\n    By problem's comparison model, comparisons are treated as 0 for this algorithm.\n    \"\"\"\n    seen = set()\n    unique = []\n    writes = 0\n    for x in arr:\n        if x not in seen:\n            seen.add(x)\n            unique.append(x)\n            writes += 1\n    return unique, writes\n\ndef dedup_sorted_two_pointer_in_place(arr: List[int], ctr: Counters) - int:\n    \"\"\"\n    Given arr already sorted in-place, perform two-pointer sweep to compact unique values\n    into the prefix of the array. Updates counters:\n    - comparisons: equality checks between adjacent run endpoints\n    - writes: assignments when moving a newly found unique to the next write position\n    Returns the length of the unique prefix.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n    write_idx = 0\n    for read_idx in range(1, n):\n        ctr.comparisons += 1  # equality check\n        if arr[read_idx] != arr[write_idx]:\n            write_idx += 1\n            if write_idx != read_idx:\n                arr[write_idx] = arr[read_idx]\n                ctr.writes += 1\n    return write_idx + 1\n\ndef analyze_case(arr: List[int]) - List:\n    # Out-of-place analysis\n    out_unique, out_writes = dedup_out_of_place_preserve_order(arr)\n    L_out = len(out_unique)\n    S_out = 2 * L_out  # per model: set + unique list, one slot each per distinct element\n\n    # In-place analysis (we operate on a copy to avoid mutating the original test case)\n    in_arr = list(arr)\n    in_ctr = Counters()\n    heapsort_in_place(in_arr, in_ctr)\n    L_in = dedup_sorted_two_pointer_in_place(in_arr, in_ctr)\n    # In-place extra space per model: 0\n    S_in = 0\n\n    # Equivalence: same length and same set of distinct values\n    unique_in_place_set = set(in_arr[:L_in])\n    out_unique_set = set(out_unique)\n    equivalent = (L_out == L_in) and (unique_in_place_set == out_unique_set)\n\n    result = [\n        L_out,\n        L_in,\n        equivalent,\n        S_out,\n        S_in,\n        out_writes,\n        in_ctr.writes,\n        in_ctr.comparisons,\n    ]\n    return result\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [3,1,2,3,2,4,5,1,3],                   # Case A\n        [],                                     # Case B\n        [5,4,3,2,1],                            # Case C\n        [7,7,7,7],                              # Case D\n        [0,-1,-1,2,-3,2,0,0,-3,5],              # Case E\n        [1,1,2,2,3,3,3,4],                      # Case F\n        [9,8,8,7,6,6,6,5,5,4,3,3,2,1,1],        # Case G\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format: single line, no spaces.\n    # Convert booleans to lowercase 'true'/'false' or keep Python's True/False?\n    # The problem statement allows booleans; Python prints True/False without quotes.\n    # We must ensure no spaces: we'll build the string manually.\n    def format_value(v):\n        if isinstance(v, bool):\n            return \"True\" if v else \"False\"\n        else:\n            return str(v)\n\n    def format_list(lst):\n        return \"[\" + \",\".join(format_value(x) for x in lst) + \"]\"\n\n    output = \"[\" + \",\".join(format_list(r) for r in results) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3241056"}, {"introduction": "This final practice challenges you to apply in-place principles to a more complex, pointer-based data structure, moving beyond simple arrays. You will convert a Binary Search Tree into a sorted Doubly Linked List without allocating any new nodes, a classic problem that epitomizes space-efficient data structure manipulation. Successfully solving this requires a deep understanding of what $O(1)$ auxiliary space truly means, forcing you to cleverly reuse the tree's existing pointers to build the new structure [@problem_id:3241084].", "problem": "You must write a complete program that, for a fixed test suite of binary search trees, converts each tree into a sorted doubly linked list by reusing the tree node pointers only (no new nodes allocated), and reports quantifiable checks. The goal is to demonstrate an in-place algorithm and distinguish it from an out-of-place approach via verifiable criteria.\n\nDefinitions and fundamental base:\n- A Binary Search Tree (BST) is a binary tree that satisfies, for every node with key $x$, the keys in its left subtree are strictly less than $x$, and the keys in its right subtree are strictly greater than $x$.\n- A Doubly Linked List (DLL) is a linked structure where each node has a pointer to its predecessor and to its successor. In this task, reuse the node’s left pointer as the predecessor pointer and the node’s right pointer as the successor pointer in the final list.\n- An algorithm is in-place if it transforms the data structure using $O(1)$ additional space beyond a constant number of pointer variables and does not allocate new nodes. An out-of-place transformation would allocate new nodes to build the target structure and thus does not reuse the original nodes.\n\nYou must derive from first principles:\n- Use the BST property and the well-tested fact that an in-order traversal of a BST visits nodes in non-decreasing key order (strictly increasing here due to distinct keys). Combine this with the logical constraint that in-place means reusing existing node pointers to form the DLL without allocating new nodes.\n- Design an algorithm that visits nodes in sorted order and, during the visit, rewires pointers so that the visited nodes become part of a DLL in that sorted order. The algorithm must adhere to $O(1)$ auxiliary space usage (not counting the input itself) and must not allocate any new list nodes.\n- Provide reasoning that the produced DLL is correct (sorted from head to tail), bidirectionally consistent (each successor’s predecessor is the current node and vice versa), and in-place (the set of node identities before and after the transformation is the same).\n\nProgram requirements:\n1. Represent tree nodes with integer keys. Build each BST by inserting the keys of a given sequence into an initially empty BST using the standard BST insertion rule (strict inequality as above), so the shape is determined by insertion order. All keys are distinct.\n2. Convert each BST to a DLL in-place by rewiring the nodes’ existing left and right pointers to serve as predecessor and successor pointers, respectively.\n3. For each test case, compute:\n   - The list of keys obtained by traversing the resulting DLL from head to tail.\n   - A boolean asserting bidirectional integrity: the reverse traversal from tail to head yields exactly the reverse of the forward sequence, the head’s predecessor pointer is null, and the tail’s successor pointer is null.\n   - A boolean asserting in-placeness: if $S_{\\text{before}}$ is the set of node identities (memory identities) reachable in the tree prior to conversion, and $S_{\\text{after}}$ is the set of node identities reachable via the DLL after conversion (from head to tail), then $S_{\\text{before}} = S_{\\text{after}}$.\n4. No new nodes may be allocated during conversion; only pointer rewiring is permitted. Auxiliary variables are permitted, but the total auxiliary space must remain $O(1)$.\n\nTest suite:\n- Case $1$: empty tree built from the insertion sequence $\\langle \\rangle$.\n- Case $2$: single-node tree built from $\\langle 7 \\rangle$.\n- Case $3$: balanced-shape insertion order $\\langle 4,2,6,1,3,5,7 \\rangle$.\n- Case $4$: right-skewed insertion order $\\langle 1,2,3,4,5 \\rangle$.\n- Case $5$: left-skewed insertion order $\\langle 5,4,3,2,1 \\rangle$.\n- Case $6$: mixed insertion order $\\langle 10,5,1,7,40,30,50 \\rangle$.\n\nOutput format:\n- Your program should produce a single line of output containing a list of results, one per test case, in the following exact format. For each case, output a triple consisting of:\n  1. The forward DLL keys as a list of integers.\n  2. The bidirectional integrity boolean as defined above.\n  3. The in-placeness boolean as defined above.\n- Concretely, your program must print a single line:\n  \"[[forward1,bidir1,inplace1],[forward2,bidir2,inplace2],...,[forward6,bidir6,inplace6]]\"\nwhere $forwardi$ is the list of integers for case $i$, and $bidiri$, $inplacei$ are booleans.\n\nConstraints and notes:\n- Let $n$ denote the number of nodes. The target in-place conversion algorithm must run in $O(n)$ time and $O(1)$ auxiliary space. Do not allocate any new node for the DLL; reuse the original nodes and their pointers.\n- Angles or physical units are not part of this problem.\n- The test suite covers the empty structure, trivial singleton, balanced and skewed trees, and a mixed-shape tree, probing both correctness and the in-place property.\n\nYour program must be self-contained, require no input, and print exactly one line in the specified format.", "solution": "The problem requires the conversion of a Binary Search Tree (BST) into a sorted Doubly Linked List (DLL) in-place. The core challenge lies in satisfying the in-place constraint, which is rigorously defined as using $O(1)$ auxiliary space. This constraint invalidates naive recursive solutions, which would consume $O(h)$ space on the call stack, where $h$ is the height of the tree. For a skewed tree, this becomes $O(n)$, where $n$ is the number of nodes, violating the stated constraint.\n\n### Principle-Based Design of an $O(1)$ Space Algorithm\n\nThe fundamental property of a BST is that an in-order traversal visits its nodes in non-decreasing order of their keys. Since the problem specifies distinct keys, the order is strictly increasing. Our goal is to transform the tree into a DLL that reflects this sorted order. The algorithm must therefore perform an in-order traversal and, during this traversal, re-wire the `left` and `right` pointers of the tree nodes to function as `predecessor` and `successor` pointers in the DLL.\n\nTo achieve an in-order traversal with $O(1)$ auxiliary space, we must avoid both explicit stacks and recursion. The canonical algorithm for this is the **Morris In-order Traversal**. This algorithm uses the tree's own pointers to create temporary \"threads\" that allow the traversal to navigate back up the tree without a stack. We will adapt this traversal mechanism to perform the required pointer re-wiring for the DLL conversion.\n\nThe algorithm maintains a pointer to the current node being processed, let's call it `current`, initialized to the `root` of the tree. It also uses a pointer, `prev`, to keep track of the last node added to the DLL, which represents the tail of the list being constructed. The head of the final list is captured by a `head` pointer when the first node is visited.\n\nThe traversal proceeds as follows:\n\n1.  Initialize `head = None`, `prev = None`, and `current = root`.\n\n2.  Loop as long as `current` is not `None`:\n    a.  **If `current` has no left child:** This means `current` is the next node in the in-order sequence. We \"visit\" it.\n        i.  If `prev` exists, we form the doubly-linked connection: `prev.right = current` and `current.left = prev`.\n        ii. If `prev` is `None`, it implies `current` is the first node in the traversal (the smallest element), so we set `head = current`.\n        iii. We update `prev = current` to mark it as the new tail of our list.\n        iv. We move to the next node in the in-order sequence, which is the original right child of `current`: `current = current.right`.\n\n    b.  **If `current` has a left child:** We cannot visit `current` yet. We must first traverse its entire left subtree. To return to `current` after the left subtree is processed, we establish a temporary thread.\n        i.  Find the in-order predecessor of `current`. This is the rightmost node in its left subtree. Let's call it `predecessor`. We find it by starting at `current.left` and repeatedly moving to the right child until we can go no further.\n        ii. **If the thread does not exist** (i.e., `predecessor.right` is `None`):\n            - We create the thread: `predecessor.right = current`.\n            - We then proceed to traverse the left subtree: `current = current.left`.\n        iii. **If the thread already exists** (i.e., `predecessor.right == current`): This indicates that we have completed the traversal of the left subtree and have returned to `current` via the thread.\n            - First, we must remove the temporary thread to restore the integrity of the predecessor's right pointer before it is repurposed. Since the predecessor is the rightmost node of a subtree, its original right child is always `None`, so we set `predecessor.right = None`.\n            - Now, we can \"visit\" `current`. At this point, the node `prev` (the tail of the DLL) is precisely the `predecessor` we just came from. We link them: `prev.right = current` and `current.left = prev`.\n            - We update `prev = current`.\n            - Finally, we move on to traverse the original right subtree of `current`: `current = current.right`.\n\nThis process continues until all nodes have been visited and linked. The `head` pointer will point to the beginning of the sorted DLL.\n\n### Verification of Properties\n\n-   **Correctness (Sorted Order):** The algorithm is a direct adaptation of Morris In-order Traversal, which is proven to visit nodes in sorted order. Since we link nodes in the order they are visited, the resulting DLL is guaranteed to be sorted by key.\n\n-   **Bidirectional Integrity:** For each node `current` visited, it is linked to the `prev` node, which was the immediately preceding node in the sorted sequence. The links `prev.right = current` and `current.left = prev` are set explicitly, ensuring bidirectional consistency. The head of the list (the very first `prev`) will have no predecessor, so its `left` pointer remains `None`. The tail of the list (the final `prev`) will have no successor, and its `right` pointer remains `None` after its processing step.\n\n-   **In-Placeness ($O(1)$ Space):** The algorithm uses a fixed, constant number of auxiliary pointer variables (`head`, `prev`, `current`, `predecessor`). It does not use a recursion stack or any other data structure whose size depends on the input tree's size or shape. All pointer manipulations re-use the existing `left` and `right` fields of the original tree nodes. No new nodes are allocated. Therefore, the algorithm strictly adheres to the $O(1)$ auxiliary space complexity requirement.\n\n-   **Time Complexity ($O(n)$):** Although the inner loop to find the predecessor seems to add complexity, a careful analysis of Morris Traversal shows that each edge in the tree is traversed a constant number of times (at most twice in each direction). Thus, the total time complexity is linear, $O(n)$, which is optimal as every node must be visited.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines the test suite, runs the conversion and validation,\n    and prints the formatted output.\n    \"\"\"\n\n    class Node:\n        \"\"\"\n        Represents a node in the Binary Search Tree.\n        The left and right pointers will be reused for the Doubly Linked List.\n        \"\"\"\n        def __init__(self, key):\n            self.key = key\n            self.left = None\n            self.right = None\n\n        def __repr__(self):\n            # For debugging purposes\n            return f\"Node({self.key})\"\n\n    def build_bst(keys):\n        \"\"\"Builds a BST from a sequence of keys using standard insertion.\"\"\"\n        def insert(root, key):\n            if not root:\n                return Node(key)\n            if key  root.key:\n                root.left = insert(root.left, key)\n            else:  # key  root.key, as keys are distinct\n                root.right = insert(root.right, key)\n            return root\n\n        root = None\n        for key in keys:\n            root = insert(root, key)\n        return root\n\n    def get_node_identities(root):\n        \"\"\"Returns the set of memory addresses of all nodes in the tree.\"\"\"\n        if not root:\n            return set()\n        \n        identities = set()\n        queue = [root]\n        visited = {id(root)}\n        \n        while queue:\n            node = queue.pop(0)\n            identities.add(id(node))\n            if node.left and id(node.left) not in visited:\n                visited.add(id(node.left))\n                queue.append(node.left)\n            if node.right and id(node.right) not in visited:\n                visited.add(id(node.right))\n                queue.append(node.right)\n        return identities\n\n    def bst_to_dll_inplace(root):\n        \"\"\"\n        Converts a BST to a sorted DLL in-place using an O(1) space algorithm\n        based on Morris In-order Traversal.\n        Returns the head of the DLL.\n        \"\"\"\n        head = None\n        prev = None\n        current = root\n\n        while current:\n            if not current.left:\n                # Visit current node\n                if not head:\n                    head = current\n                if prev:\n                    prev.right = current\n                    current.left = prev\n                prev = current\n                \n                # Move to the next node in the in-order traversal\n                current = current.right\n            else:\n                # Find in-order predecessor\n                predecessor = current.left\n                while predecessor.right and predecessor.right != current:\n                    predecessor = predecessor.right\n\n                if not predecessor.right:\n                    # Create temporary thread\n                    predecessor.right = current\n                    current = current.left\n                else: # predecessor.right == current (thread exists)\n                    # Break the thread\n                    predecessor.right = None\n                    \n                    # Visit current node (it comes after its predecessor)\n                    if prev: # prev is the predecessor\n                        prev.right = current\n                        current.left = prev\n                    \n                    prev = current\n                    \n                    # Move to the original right subtree\n                    current = current.right\n        return head\n\n    def run_test_case(insertion_sequence):\n        \"\"\"\n        Runs one full test case: builds BST, gets identities, converts, and verifies.\n        \"\"\"\n        # 1. Build BST and get pre-conversion state\n        root = build_bst(insertion_sequence)\n        s_before = get_node_identities(root)\n\n        # 2. Perform in-place conversion\n        head = bst_to_dll_inplace(root)\n\n        # 3. Perform verification checks on the resulting DLL\n        \n        # 3a. In-placeness check\n        s_after = set()\n        curr = head\n        while curr:\n            s_after.add(id(curr))\n            curr = curr.right\n        is_inplace = (s_before == s_after)\n        \n        # 3b. Forward traversal and find tail\n        forward_keys = []\n        tail = None\n        curr = head\n        while curr:\n            forward_keys.append(curr.key)\n            if not curr.right:\n                tail = curr\n            curr = curr.right\n            \n        # 3c. Bidirectional integrity check\n        is_bidir_correct = True\n        \n        # Check null termination\n        if (head and head.left is not None) or (tail and tail.right is not None):\n            is_bidir_correct = False\n        \n        # Check reverse traversal\n        if is_bidir_correct:\n            backward_keys = []\n            curr = tail\n            while curr:\n                backward_keys.append(curr.key)\n                curr = curr.left\n            \n            # For empty list, backward_keys[::-1] is still []\n            if forward_keys != backward_keys[::-1]:\n                is_bidir_correct = False\n        \n        return [forward_keys, is_bidir_correct, is_inplace]\n\n    # Fixed test suite as per the problem statement\n    test_cases = [\n        [],                            # Case 1: empty tree\n        [7],                           # Case 2: single-node tree\n        [4, 2, 6, 1, 3, 5, 7],         # Case 3: balanced-shape\n        [1, 2, 3, 4, 5],               # Case 4: right-skewed\n        [5, 4, 3, 2, 1],               # Case 5: left-skewed\n        [10, 5, 1, 7, 40, 30, 50],     # Case 6: mixed\n    ]\n\n    results = []\n    for case_keys in test_cases:\n        results.append(run_test_case(case_keys))\n\n    # Format the final output string manually to match the exact requirement\n    # \"[[forward1,bidir1,inplace1],[forward2,bidir2,inplace2],...]\"\n    # This avoids ambiguity with spaces from standard str() or repr()\n    result_strings = []\n    for fwd_keys, bidir, inplace in results:\n        fwd_str = '[' + ','.join(map(str, fwd_keys)) + ']'\n        result_strings.append(f\"[{fwd_str},{str(bidir)},{str(inplace)}]\")\n    \n    final_output = '[' + ','.join(result_strings) + ']'\n    print(final_output)\n\nsolve()\n```", "id": "3241084"}]}