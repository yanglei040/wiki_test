{"hands_on_practices": [{"introduction": "Standard binary search is remarkably efficient, but it relies on a critical precondition: a monotonically sorted array. This first exercise challenges you to adapt this powerful tool to a scenario where that precondition is subtly broken. By developing a search strategy for a rotated sorted array, you will learn to reason about local properties and invariants to preserve the logarithmic efficiency of binary search even when global order is absent [@problem_id:3268840].", "problem": "You are given a finite sequence of integers that was originally a strictly increasing array $A$ of length $n$ with $n \\geq 1$, subsequently transformed into a new array $B$ by a cyclic right shift of an unknown amount $k$, where $k \\in \\{0,1,\\dots,n-1\\}$. Formally, for every index $i \\in \\{0,1,\\dots,n-1\\}$, the transformation satisfies\n$$\nB[i] = A\\big((i - k) \\bmod n\\big).\n$$\nAll elements in $A$ are distinct, and $A$ is sorted in strictly ascending order, that is, for all indices $i$ with $0 \\leq i  n-1$ we have $A[i]  A[i+1]$. You must design an algorithm, grounded in first principles of comparison-based searching, that determines the index of a target value $x$ in $B$, if it exists, without reconstructing $A$ or $k$ and without resorting $B$. Your algorithm must run in worst-case time of order of growth $O(\\log n)$.\n\nFundamental base for reasoning:\n- The domain is the set of integers with the usual total order $\\leq$.\n- Binary search operates on a predicate that is monotonic over a totally ordered sequence, enabling bisection to eliminate half the search interval at each step.\n- A cyclic right shift of a strictly increasing array partitions the resulting array $B$ into two contiguous segments, each of which is strictly increasing, separated at a pivot index where the smallest element of $B$ resides.\n\nYour program must implement this search for multiple independent test cases. For each test case, you will be provided with an array $B$ and a target $x$, and you must return the zero-based index of $x$ in $B$ if present, or $-1$ if $x$ does not occur in $B$. The result for each test case must be an integer. You must not assume or compute the shift amount $k$ explicitly.\n\nTest suite:\n- Case $1$: $B = [7,9,11,1,3,5]$, $x = 3$.\n- Case $2$: $B = [1,2,3,4,5,6]$, $x = 6$.\n- Case $3$: $B = [42]$, $x = 7$.\n- Case $4$: $B = [30,40,50,5,10,20]$, $x = 5$.\n- Case $5$: $B = [12,-10,-5,0,5]$, $x = 12$.\n- Case $6$: $B = [4,5,6,7,0,1,2]$, $x = 0$.\n- Case $7$: $B = [4,5,6,7,0,1,2]$, $x = 3$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases. For example, if the results for three cases were $r_1$, $r_2$, and $r_3$, the output line would be $[r_1,r_2,r_3]$.", "solution": "The problem is assessed to be **valid**. It is self-contained, scientifically grounded in the principles of algorithm design, and well-posed. The problem asks for the design of an efficient search algorithm for a specific data structure—a cyclically shifted sorted array—which is a well-established problem in computer science. The constraints and objectives are clear and logically consistent.\n\nThe task is to find a target value $x$ in a cyclically shifted, strictly increasing array $B$ of length $n$ in $O(\\log n)$ time. The array $B$ is formed by a cyclic right shift of some unknown amount $k \\in \\{0, 1, \\dots, n-1\\}$ on a strictly increasing array $A$. This structure implies that $B$ consists of two contiguous segments, each of which is sorted in strictly increasing order. The junction of these two segments, often called the pivot, is where the maximum element of the original array $A$ is followed by its minimum element.\n\nA standard binary search algorithm cannot be directly applied because the entire array $B$ is not monotonically increasing. However, the core principle of binary search—eliminating half of the search space at each step—can be adapted. The key is to identify, in each step, a segment of the array that *is* guaranteed to be sorted and then determine if the target value $x$ could lie within that segment.\n\nLet the search space be defined by the indices $[low, high]$, initialized to $[0, n-1]$. In each iteration of our algorithm, we perform the following steps:\n\n1.  Calculate the middle index: $mid = low + \\lfloor(high - low) / 2\\rfloor$.\n2.  Compare the element at the middle index, $B[mid]$, with the target $x$. If $B[mid] = x$, the target is found, and its index $mid$ is returned.\n3.  If $B[mid] \\ne x$, we must decide which half of the current search space, $[low, mid-1]$ or $[mid+1, high]$, to explore next. This decision is based on identifying the sorted sub-segment. We compare $B[mid]$ with an endpoint of the current search interval, for instance, $B[low]$.\n\n    -   **Case A: $B[low] \\le B[mid]$.** This condition implies that the subarray from index $low$ to $mid$ is sorted in strictly increasing order. The pivot, if it exists within the $[low, high]$ range, must be in the right half, i.e., in $[mid+1, high]$.\n        -   We can now determine if the target $x$ belongs to this sorted left half. If $B[low] \\le x  B[mid]$, then $x$ must reside in the interval $[low, mid-1]$. We therefore update the search space by setting $high = mid - 1$.\n        -   Otherwise, $x$ must be in the right half, $[mid+1, high]$. We update the search space by setting $low = mid + 1$.\n\n    -   **Case B: $B[low]  B[mid]$.** This condition implies that the pivot lies within the subarray from index $low$ to $mid$. Consequently, the right subarray from index $mid+1$ to $high$ must be a single, contiguous sorted block.\n        -   We determine if the target $x$ belongs to this sorted right half. If $B[mid]  x \\le B[high]$, then $x$ must reside in the interval $[mid+1, high]$. We update the search space by setting $low = mid + 1$.\n        -   Otherwise, $x$ must be in the left half, $[low, mid-1]$. We update the search space by setting $high = mid - 1$.\n\n4.  The loop continues as long as $low \\le high$. If the loop terminates (i.e., $low  high$), it means the target $x$ was not found in the array $B$. In this case, the algorithm returns $-1$.\n\nThis modified binary search algorithm halves the search space in each iteration, regardless of which case is met. The number of comparisons is logarithmic with respect to the size of the array, $n$. Therefore, the algorithm achieves the required worst-case time complexity of $O(\\log n)$ without reconstructing the original array $A$, determining the shift $k$, or re-sorting $B$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on the provided test suite.\n    \"\"\"\n\n    def search_in_rotated_array(B, x):\n        \"\"\"\n        Performs a modified binary search to find a target x in a cyclically\n        shifted sorted array B.\n\n        Args:\n            B (np.ndarray): The cyclically shifted sorted array of integers.\n            x (int): The target value to search for.\n\n        Returns:\n            int: The zero-based index of x if found, otherwise -1.\n        \"\"\"\n        low = 0\n        high = len(B) - 1\n\n        while low = high:\n            mid = low + (high - low) // 2\n\n            if B[mid] == x:\n                return mid\n\n            # Case A: The left half of the search space [low...mid] is sorted.\n            # This is identified by B[low] = B[mid].\n            if B[low] = B[mid]:\n                # Check if the target is within the range of the sorted left half.\n                if B[low] = x  B[mid]:\n                    high = mid - 1\n                else:\n                    # Target must be in the right half.\n                    low = mid + 1\n            # Case B: The right half of the search space [mid+1...high] is sorted.\n            # This is implied if the left half is not sorted.\n            else:\n                # Check if the target is within the range of the sorted right half.\n                if B[mid]  x = B[high]:\n                    low = mid + 1\n                else:\n                    # Target must be in the left half.\n                    high = mid - 1\n        \n        # Target was not found in the array.\n        return -1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([7, 9, 11, 1, 3, 5]), 3),  # Case 1\n        (np.array([1, 2, 3, 4, 5, 6]), 6),  # Case 2\n        (np.array([42]), 7),                # Case 3\n        (np.array([30, 40, 50, 5, 10, 20]), 5), # Case 4\n        (np.array([12, -10, -5, 0, 5]), 12),    # Case 5\n        (np.array([4, 5, 6, 7, 0, 1, 2]), 0),  # Case 6\n        (np.array([4, 5, 6, 7, 0, 1, 2]), 3)   # Case 7\n    ]\n\n    results = []\n    for B, x in test_cases:\n        result = search_in_rotated_array(B, x)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3268840"}, {"introduction": "Building on the theme of adapting to non-standard structures, this practice introduces the bitonic array—one that increases and then decreases. A direct binary search is not applicable, but an efficient solution can be found through problem decomposition. The key is to first locate the 'peak' of the array and then apply tailored binary searches to the two resulting monotonic segments, demonstrating a powerful divide-and-conquer approach [@problem_id:3268712].", "problem": "You are given the fundamental definitions of a totally ordered array and strictly monotonic sequences. An array $A$ of length $n$ is said to be bitonic if there exists a unique index $p$ with $0  p  n - 1$ such that $A[0]  A[1]  \\dots  A[p]$ and $A[p]  A[p+1]  \\dots  A[n-1]$. Given a bitonic array $A$ and a target value $x$, the task is to design a search strategy from first principles that uses only comparisons and exploits the structural properties of the bitonic array to locate an index $i$ such that $A[i] = x$ if such an index exists, or report that no such index exists. The strategy must be derived using the properties of strictly increasing and strictly decreasing sequences and the total order relation, and it must have time complexity $\\mathcal{O}(\\log n)$ on arrays that satisfy the bitonic definition.\n\nYour program must implement the search strategy and apply it to the following test suite. All arrays below are bitonic with strictly increasing and strictly decreasing segments, and all indices are $0$-based. For each pair $(A_j, x_j)$, return an integer index $i_j$ such that $A_j[i_j] = x_j$ if it exists, and return $-1$ if it does not.\n\nTest suite:\n- Case $1$: $A_1 = [\\,1,3,7,12,14,13,9,5,2\\,]$, $x_1 = 9$.\n- Case $2$: $A_2 = [\\,2,4,8,15,14,10,3\\,]$, $x_2 = 15$.\n- Case $3$: $A_3 = [\\,1,2,3,4,3,1\\,]$, $x_3 = 10$.\n- Case $4$: $A_4 = [\\,1,5,9,11,10,4,2\\,]$, $x_4 = 1$.\n- Case $5$: $A_5 = [\\,0,2,5,7,6,3,1\\,]$, $x_5 = 1$.\n- Case $6$: $A_6 = [\\,1,3,2\\,]$, $x_6 = 2$.\n- Case $7$: $A_7 = [\\,1,4,9,12,11,7,3\\,]$, $x_7 = 4$.\n- Case $8$: $A_8 = [\\,3,8,12,11,10,6,5\\,]$, $x_8 = 6$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\,\\text{result}_1,\\text{result}_2,\\dots\\,]$). Each result must be an integer index or $-1$ if not found. The output must exactly aggregate the answers to the eight cases in the order they are stated.", "solution": "The user-provided problem statement has been validated and is determined to be a well-posed, scientifically grounded, and formally structured algorithmic challenge. It is free of contradictions, ambiguities, and factual inaccuracies. The task is to devise an efficient search algorithm for a bitonic array, adhering to specified complexity constraints and deriving the solution from first principles.\n\n### Principle-Based Derivation of the Search Strategy\n\nThe problem requires designing a search algorithm for a bitonic array $A$ of length $n$ to find a target value $x$. A bitonic array is defined by a unique index $p \\in (0, n-1)$ such that the subarray $A[0 \\dots p]$ is strictly increasing and the subarray $A[p \\dots n-1]$ is strictly decreasing. This structure is the key to an efficient search. The fundamental principle for searching in ordered data is binary search, which operates in $\\mathcal{O}(\\log n)$ time. A standard binary search, however, requires a single, uniform monotonic sequence. The bitonic array violates this condition due to the presence of the peak $A[p]$.\n\nOur strategy is to decompose the problem into manageable subproblems where standard search principles can be applied. The decomposition hinges on locating the peak element, which partitions the array into two distinct, purely monotonic sequences.\n\nThe overall strategy comprises three main steps:\n1.  Locate the peak element $A[p]$, which is the maximum value in the array.\n2.  Search for the target $x$ in the strictly increasing subarray $A[0 \\dots p]$.\n3.  If not found, search for the target $x$ in the strictly decreasing subarray $A[p \\dots n-1]$.\n\nEach step must be executed in logarithmic time to satisfy the overall complexity requirement of $\\mathcal{O}(\\log n)$.\n\n#### Step 1: Finding the Bitonic Peak\n\nThe peak index $p$ is the index of the maximum element in the array. We can find this index efficiently using a modified binary search algorithm. The search exploits the local property of the slope around any given element. For any index $m$ such that $0  m  n-1$:\n- If $A[m-1]  A[m]  A[m+1]$, the index $m$ lies on the increasing segment. The peak must be to the right of $m$.\n- If $A[m-1]  A[m]  A[m+1]$, the index $m$ lies on the decreasing segment. The peak must be to the left of $m$.\n- If $A[m-1]  A[m]$ and $A[m]  A[m+1]$, then $m$ is the peak index $p$.\n\nThis allows us to discard half of the search space in each step. Let the search interval be $[l, h]$. We compute a midpoint $m = l + \\lfloor(h-l)/2\\rfloor$. By comparing $A[m]$ and its neighbor $A[m+1]$, we decide where to continue the search:\n- If $A[m]  A[m+1]$, we are on the increasing slope, so the peak must lie in the interval $[m+1, h]$.\n- If $A[m]  A[m+1]$, we are at the peak or on the decreasing slope, so the peak must lie in the interval $[l, m]$.\n\nThis process is repeated until the search interval $[l, h]$ converges to a single element, i.e., $l=h$. This final index is the peak index $p$. This search has a time complexity of $\\mathcal{O}(\\log n)$.\n\n#### Step 2: Binary Search on the Increasing Subarray\n\nOnce the peak index $p$ is known, we have a strictly increasing subarray $A[0 \\dots p]$. This subarray is totally ordered by the relation $\\le$. We can apply a standard binary search algorithm to find $x$ in this segment.\n\nThe binary search algorithm on $A[0 \\dots p-1]$ operates as follows:\n- Let the search interval be $[l, h]$, initialized to $[0, p-1]$.\n- While $l \\le h$:\n    - Compute the midpoint $m = l + \\lfloor(h-l)/2\\rfloor$.\n    - If $A[m] = x$, the element is found at index $m$.\n    - If $A[m]  x$, the target must be in the right half of the interval, so we set $l = m+1$.\n    - If $A[m]  x$, the target must be in the left half of the interval, so we set $h = m-1$.\nIf the loop completes without finding $x$, the element is not in this segment. This search has a time complexity of $\\mathcal{O}(\\log p)$, which is bounded by $\\mathcal{O}(\\log n)$. We also must check if $A[p]=x$.\n\n#### Step 3: Binary Search on the Decreasing Subarray\n\nIf $x$ is not found in the increasing part, we search the strictly decreasing subarray $A[p+1 \\dots n-1]$. This subarray is totally ordered by the relation $\\ge$. A binary search can be adapted for this descending order.\n\nThe binary search algorithm on $A[p+1 \\dots n-1]$ operates as follows:\n- Let the search interval be $[l, h]$, initialized to $[p+1, n-1]$.\n- While $l \\le h$:\n    - Compute the midpoint $m = l + \\lfloor(h-l)/2\\rfloor$.\n    - If $A[m] = x$, the element is found at index $m$.\n    - If $A[m]  x$, because the array is decreasing, the target (a larger value) must be in the left half. We set $h = m-1$.\n    - If $A[m]  x$, the target (a smaller value) must be in the right half. We set $l = m+1$.\nIf the loop completes, $x$ is not in this segment. This search has a complexity of $\\mathcal{O}(\\log(n-p-1))$, bounded by $\\mathcal{O}(\\log n)$.\n\n#### Synthesis of the Complete Algorithm\n\nThe complete algorithm integrates these three steps:\n\n1.  Given bitonic array $A$ and target $x$. Handle edge cases where the array has fewer than $3$ elements.\n2.  Call the peak-finding algorithm to get the index $p$. This takes $\\mathcal{O}(\\log n)$ time.\n3.  If $A[p] = x$, return $p$.\n4.  If $x  A[p]$, $x$ cannot exist in the array, as $A[p]$ is the maximum. Return $-1$.\n5.  Execute the ascending binary search on the interval $[0, p-1]$. If $x$ is found at index $i$, return $i$. This takes $\\mathcal{O}(\\log n)$ time.\n6.  If not found, execute the descending binary search on the interval $[p+1, n-1]$. If $x$ is found at index $j$, return $j$. Otherwise, return $-1$. This also takes $\\mathcal{O}(\\log n)$ time.\n\nThe total time complexity is the sum of the complexities of these steps, which is $\\mathcal{O}(\\log n) + \\mathcal{O}(\\log n) + \\mathcal{O}(\\log n) = \\mathcal{O}(\\log n)$. This meets the problem's requirement and is derived from the fundamental properties of ordered sets and the specific structure of a bitonic array.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bitonic array search problem for a given test suite.\n    \"\"\"\n\n    def find_peak(arr):\n        \"\"\"\n        Finds the peak element in a bitonic array in O(log n) time.\n        The array must be bitonic as per the problem definition (n >= 3).\n        \"\"\"\n        n = len(arr)\n        low, high = 0, n - 1\n        while low  high:\n            mid = low + (high - low) // 2\n            # Compare mid with its right neighbor to determine the slope\n            if arr[mid]  arr[mid + 1]:\n                # We are on the increasing part, so the peak is to the right\n                low = mid + 1\n            else:\n                # We are at the peak or on the decreasing part, peak is to the left or at mid\n                high = mid\n        # When low == high, we have found the peak\n        return low\n\n    def binary_search_ascending(arr, low, high, x):\n        \"\"\"\n        Performs binary search on a strictly increasing subarray.\n        \"\"\"\n        while low = high:\n            mid = low + (high - low) // 2\n            if arr[mid] == x:\n                return mid\n            elif arr[mid]  x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1\n\n    def binary_search_descending(arr, low, high, x):\n        \"\"\"\n        Performs binary search on a strictly decreasing subarray.\n        \"\"\"\n        while low = high:\n            mid = low + (high - low) // 2\n            if arr[mid] == x:\n                return mid\n            elif arr[mid]  x:\n                # Since the array is descending, larger values are to the left\n                high = mid - 1\n            else:\n                # Smaller values are to the right\n                low = mid + 1\n        return -1\n\n    def search_bitonic(arr, x):\n        \"\"\"\n        Main function to search for an element in a bitonic array.\n        \"\"\"\n        n = len(arr)\n        if n == 0:\n            return -1\n        \n        # The problem definition implies n >= 3, so peak is not at 0 or n-1.\n        # This implementation of find_peak is robust for n >= 1.\n        peak_index = find_peak(arr)\n\n        # Check if the peak element is the target\n        if arr[peak_index] == x:\n            return peak_index\n        \n        # If target is greater than the peak, it cannot be in the array\n        if arr[peak_index]  x:\n            return -1\n\n        # Search in the increasing part (left of the peak)\n        result = binary_search_ascending(arr, 0, peak_index - 1, x)\n        if result != -1:\n            return result\n\n        # If not found, search in the decreasing part (right of the peak)\n        result = binary_search_descending(arr, peak_index + 1, n - 1, x)\n        return result\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([1, 3, 7, 12, 14, 13, 9, 5, 2]), 9),\n        (np.array([2, 4, 8, 15, 14, 10, 3]), 15),\n        (np.array([1, 2, 3, 4, 3, 1]), 10),\n        (np.array([1, 5, 9, 11, 10, 4, 2]), 1),\n        (np.array([0, 2, 5, 7, 6, 3, 1]), 1),\n        (np.array([1, 3, 2]), 2),\n        (np.array([1, 4, 9, 12, 11, 7, 3]), 4),\n        (np.array([3, 8, 12, 11, 10, 6, 5]), 6),\n    ]\n\n    results = []\n    for arr, x in test_cases:\n        result = search_bitonic(arr, x)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3268712"}, {"introduction": "Searching isn't confined to one-dimensional arrays. This final exercise expands our thinking into two dimensions with a matrix sorted along both its rows and columns. While simply applying 1D binary search to each row is a valid approach, a more elegant and often faster strategy exists. This practice guides you to discover the 'staircase search', an algorithm that cleverly eliminates an entire row or column at each step by starting from a corner [@problem_id:3268809].", "problem": "You are given a matrix $\\mathbf{A} \\in \\mathbb{Z}^{N \\times M}$ with the property that every row is strictly increasing from left to right and every column is strictly increasing from top to bottom. Formally, for all indices $i$ and $j$ with $0 \\le i  N$ and $0 \\le j  M$, it holds that $\\mathbf{A}[i][j]  \\mathbf{A}[i][j+1]$ whenever $j+1  M$ and $\\mathbf{A}[i][j]  \\mathbf{A}[i+1][j]$ whenever $i+1  N$. The total order on $\\mathbb{Z}$ is assumed as the foundational base, and all comparisons use the standard integer relations.\n\nYour task is to implement and compare multiple searching strategies to locate a target value $x \\in \\mathbb{Z}$ within such a matrix. The strategies must be implemented following first principles of searching:\n\n- Strategy $1$: Naive linear scan. Iterate entries in row-major order and test equality $\\mathbf{A}[i][j] = x$ for each position until found or until all entries have been examined.\n\n- Strategy $2$: Row-wise binary search with bounding checks. For each row $i$, first check whether $x$ lies within the closed interval defined by the first and last element of the row, i.e., test $x  \\mathbf{A}[i][0]$ and $x  \\mathbf{A}[i][M-1]$ to decide if the row can be skipped. If it cannot be skipped, perform binary search over that row to attempt to find $x$.\n\n- Strategy $3$: Monotone staircase search from the top-right corner. Initialize $(i,j) = (0, M-1)$ and repeatedly compare $\\mathbf{A}[i][j]$ to $x$. If $\\mathbf{A}[i][j] = x$ then the search terminates successfully. If $\\mathbf{A}[i][j]  x$ then increment $i$ (move down). If $\\mathbf{A}[i][j]  x$ then decrement $j$ (move left). Continue while $0 \\le i  N$ and $0 \\le j  M$.\n\nDefine the basic operation cost model precisely as follows. A single comparison is one evaluation of a relational operator between a matrix entry and the target, using one of $$, $$, or $=$. Your program must count and report the exact number of such comparisons performed by each strategy on each test case. For the naive linear scan, count one comparison per visited entry for testing equality. For the row-wise binary search, count comparisons for the bounding checks in each considered row and for each step of binary search, counting separately the equality check and the $$ test when they are both performed. For the staircase search, count the equality test and, when not equal, the subsequent $$ or $$ test used to decide the direction of movement.\n\nIndexing must be zero-based: report positions as $[i,j]$ with $i \\in \\{0,\\dots,N-1\\}$ and $j \\in \\{0,\\dots,M-1\\}$. If the target is not present in the matrix, report $[-1,-1]$.\n\nTest Suite. Use exactly the following set of matrices and targets to validate different facets of the solution. Each case specifies $(\\mathbf{A}, x)$:\n\n- Case $1$ (general case): \n$$\n\\mathbf{A} = \\begin{bmatrix}\n  1  4  7  11  15 \\\\\n  2  5  8  12  19 \\\\\n  3  6  9  16  22 \\\\\n  10  13  14  17  24\n\\end{bmatrix}\n$$, $x = 14$.\n\n- Case $2$ (not found, value between existing entries): \n$$\n\\mathbf{A} = \\begin{bmatrix}\n  1  4  7  11  15 \\\\\n  2  5  8  12  19 \\\\\n  3  6  9  16  22 \\\\\n  10  13  14  17  24\n\\end{bmatrix}\n$$, $x = 20$.\n\n- Case $3$ (boundary minimal matrix):\n$$\n\\mathbf{A} = \\begin{bmatrix} 5 \\end{bmatrix}\n$$, $x = 5$.\n\n- Case $4$ (rectangular tall matrix, negative and positive values):\n$$\n\\mathbf{A} = \\begin{bmatrix}\n  -10  -3  0 \\\\\n  -9  -2  1 \\\\\n  -5  2  3 \\\\\n  4  6  8 \\\\\n  7  9  11\n\\end{bmatrix}\n$$, $x = -2$.\n\n- Case $5$ (target at top-right corner):\n$$\n\\mathbf{A} = \\begin{bmatrix}\n  1  2  3 \\\\\n  4  5  6\n\\end{bmatrix}\n$$, $x = 3$.\n\n- Case $6$ (target at bottom-left corner):\n$$\n\\mathbf{A} = \\begin{bmatrix}\n  2  5  9  12 \\\\\n  3  8  10  15 \\\\\n  6  11  13  20\n\\end{bmatrix}\n$$, $x = 6$.\n\nRequired final output format. For each test case, produce a list $[i, j, c_{\\text{naive}}, c_{\\text{rowbin}}, c_{\\text{stair}}]$, where $[i,j]$ is the located position from Strategy $3$ (the staircase search), or $[-1,-1]$ if not found, $c_{\\text{naive}}$ is the number of comparisons performed by Strategy $1$, $c_{\\text{rowbin}}$ is the number of comparisons performed by Strategy $2$, and $c_{\\text{stair}}$ is the number of comparisons performed by Strategy $3$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets; that is, a list of per-case results in the form $[[\\cdot],[\\cdot],...]$ with no spaces.\n\nAll numeric answers must be integers. Angles and physical units are not applicable in this problem; no unit conversions are required.", "solution": "The posed problem requires the implementation and comparative analysis of three distinct algorithms for searching a target value $x$ in an $N \\times M$ integer matrix $\\mathbf{A}$. The matrix is endowed with a special structure: its rows and columns are strictly increasing. This property is formally stated as $\\mathbf{A}[i][j]  \\mathbf{A}[i][j+1]$ for all $i \\in \\{0, \\dots, N-1\\}$ and $j \\in \\{0, \\dots, M-2\\}$, and $\\mathbf{A}[i][j]  \\mathbf{A}[i+1][j]$ for all $j \\in \\{0, \\dots, M-1\\}$ and $i \\in \\{0, \\dots, N-1\\}$. We will analyze each strategy from first principles, focusing on the number of comparisons between a matrix entry and the target $x$ as the primary cost metric.\n\n### Strategy 1: Naive Linear Scan\n\nThis is the most straightforward approach. The algorithm iterates through each entry of the matrix $\\mathbf{A}$ in a predetermined order, typically row-major, and compares it to the target value $x$. The search terminates as soon as a match is found. If the entire matrix is traversed without finding $x$, the search concludes unsuccessfully.\n\nLet the dimensions of the matrix be $N \\times M$. The algorithm proceeds as follows:\nFor $i$ from $0$ to $N-1$:\n  For $j$ from $0$ to $M-1$:\n    Compare $\\mathbf{A}[i][j]$ with $x$.\n    If $\\mathbf{A}[i][j] = x$, a match is found at position $[i, j]$. Terminate.\n\nThe cost model specifies one comparison for each equality test. In the worst-case scenario (the target is the last element or not present), this strategy will perform $N \\times M$ comparisons. The time complexity is therefore $O(N \\cdot M)$. This strategy makes no use of the sorted nature of the rows and columns.\n\n### Strategy 2: Row-wise Binary Search\n\nThis strategy leverages the fact that each row of the matrix is a sorted array. It iterates through each row and, for each one, decides if a search is warranted. A row can be skipped if the target value $x$ is outside the range of values in that row. The range of row $i$ is the closed interval $[\\mathbf{A}[i][0], \\mathbf{A}[i][M-1]]$. The algorithm first performs a bounding check: if $x  \\mathbf{A}[i][0]$ or $x  \\mathbf{A}[i][M-1]$, the row cannot contain $x$ and is skipped. According to the specified cost model, this check involves one comparison ($x  \\mathbf{A}[i][0]$). If that is false, a second comparison ($x  \\mathbf{A}[i][M-1]$) is made. Thus, the bounding check costs either 1 or 2 comparisons per row.\n\nIf the bounding check indicates that $x$ could be in the current row, a standard binary search is performed on that row. In a binary search step on a sub-array from index `low` to `high`, we compute `mid` and compare $\\mathbf{A}[i][\\text{mid}]$ to $x$. If they are equal, the search is successful. This costs $1$ comparison. If not equal, another comparison determines if $\\mathbf{A}[i][\\text{mid}]$ is less than or greater than $x$, narrowing the search space to the left or right half. This step costs $2$ comparisons in total.\n\nThe worst-case complexity for a binary search on a single row of length $M$ is $O(\\log M)$. Since this might be done for all $N$ rows, the total complexity of this strategy is $O(N \\log M)$. This is a significant improvement over the naive scan, especially for large $M$.\n\n### Strategy 3: Monotone Staircase Search\n\nThis is the most sophisticated of the three strategies, as it simultaneously utilizes both the row and column sorted properties. The search begins at a specific corner of the matrix. A common and efficient choice is the top-right corner, $(i, j) = (0, M-1)$. Let the value at the current position be $v = \\mathbf{A}[i][j]$.\n\nThe search proceeds iteratively based on comparisons with the target $x$:\n1. If $v = x$, the target is found. The search terminates. This step costs $1$ comparison.\n2. If $v  x$, it implies that all elements in the current column $j$ at or below row $i$ must also be greater than $x$ (due to the column-sorted property, $\\mathbf{A}[k][j] \\ge \\mathbf{A}[i][j]  x$ for $k  i$). Therefore, the entire column $j$ can be eliminated from the search space. The algorithm moves to the left by decrementing $j$. This step costs $2$ comparisons (one for equality, one for direction).\n3. If $v  x$, it implies that all elements in the current row $i$ to the left of column $j$ must also be less than $x$ (due to the row-sorted property, $\\mathbf{A}[i][k] \\le \\mathbf{A}[i][j]  x$ for $k  j$). Therefore, the entire row $i$ can be eliminated. The algorithm moves down by incrementing $i$. This step also costs $2$ comparisons.\n\nThe search continues as long as the indices $(i, j)$ are within the matrix bounds ($0 \\le i  N$ and $0 \\le j  M$). At each step, the algorithm eliminates either a row or a column. In the worst case, the path of the search will traverse from the top-right corner to the bottom-left corner, involving at most $N-1$ downward moves and $M-1$ leftward moves. The total number of steps is therefore at most $(N-1) + (M-1) + 1 = N+M-1$. The time complexity is $O(N+M)$, which is generally superior to $O(N \\log M)$ unless $M$ is exponentially larger than $N$.\n\nThis \"staircase\" path effectively prunes the search space by a row or a column at each step, leading to its efficiency. The position returned is that found by this method, as stipulated.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef naive_scan(A, x):\n    \"\"\"\n    Performs a naive linear scan to find x in A.\n    Returns: (position, comparisons)\n    \"\"\"\n    comparisons = 0\n    if A.size == 0:\n        return [-1, -1], 0\n    N, M = A.shape\n    for i in range(N):\n        for j in range(M):\n            comparisons += 1\n            if A[i, j] == x:\n                return [i, j], comparisons\n    return [-1, -1], comparisons\n\ndef row_wise_binary_search(A, x):\n    \"\"\"\n    Performs a row-wise binary search to find x in A.\n    Returns: (position, comparisons)\n    \"\"\"\n    comparisons = 0\n    if A.size == 0:\n        return [-1, -1], 0\n    N, M = A.shape\n    if M == 0:\n        return [-1, -1], 0\n        \n    for i in range(N):\n        # Bounding checks\n        comparisons += 1\n        if x  A[i, 0]:\n            continue\n        \n        # This check is only performed if the first one fails\n        comparisons += 1\n        if x > A[i, M - 1]:\n            continue\n\n        # Binary search on the row\n        low, high = 0, M - 1\n        while low = high:\n            mid = low + (high - low) // 2\n            \n            comparisons += 1\n            if A[i, mid] == x:\n                return [i, mid], comparisons\n            \n            # Second comparison for direction\n            comparisons += 1\n            if A[i, mid]  x:\n                low = mid + 1\n            else:\n                high = mid - 1\n                \n    return [-1, -1], comparisons\n\ndef staircase_search(A, x):\n    \"\"\"\n    Performs a monotone staircase search to find x in A.\n    Returns: (position, comparisons)\n    \"\"\"\n    comparisons = 0\n    if A.size == 0:\n        return [-1, -1], 0\n    N, M = A.shape\n    if M == 0:\n        return [-1, -1], 0\n\n    i, j = 0, M - 1\n    while i  N and j >= 0:\n        comparisons += 1\n        if A[i, j] == x:\n            return [i, j], comparisons\n        \n        # Second comparison for direction\n        comparisons += 1\n        if A[i, j] > x:\n            j -= 1\n        else: # A[i, j]  x\n            i += 1\n            \n    return [-1, -1], comparisons\n\ndef solve():\n    test_cases = [\n        (np.array([\n            [1, 4, 7, 11, 15],\n            [2, 5, 8, 12, 19],\n            [3, 6, 9, 16, 22],\n            [10, 13, 14, 17, 24]\n        ]), 14),\n        (np.array([\n            [1, 4, 7, 11, 15],\n            [2, 5, 8, 12, 19],\n            [3, 6, 9, 16, 22],\n            [10, 13, 14, 17, 24]\n        ]), 20),\n        (np.array([[5]]), 5),\n        (np.array([\n            [-10, -3, 0],\n            [-9, -2, 1],\n            [-5, 2, 3],\n            [4, 6, 8],\n            [7, 9, 11]\n        ]), -2),\n        (np.array([\n            [1, 2, 3],\n            [4, 5, 6]\n        ]), 3),\n        (np.array([\n            [2, 5, 9, 12],\n            [3, 8, 10, 15],\n            [6, 11, 13, 20]\n        ]), 6),\n    ]\n\n    results = []\n    for A, x in test_cases:\n        pos_naive, c_naive = naive_scan(A, x)\n        pos_rowbin, c_rowbin = row_wise_binary_search(A, x)\n        pos_stair, c_stair = staircase_search(A, x)\n        \n        result_list = [*pos_stair, c_naive, c_rowbin, c_stair]\n        results.append(result_list)\n        \n    def format_result(res):\n        return f\"[{','.join(map(str, res))}]\"\n\n    print(f\"[{','.join(map(format_result, results))}]\")\n\nsolve()\n```", "id": "3268809"}]}