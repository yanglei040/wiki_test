{"hands_on_practices": [{"introduction": "Interpolation search is celebrated for its remarkable $O(\\log \\log n)$ average-case performance, but this efficiency hinges on the assumption that the data is uniformly distributed. This first exercise challenges that assumption by applying the algorithm to data with a non-linear, quadratic distribution. By meticulously tracing the probe calculations step-by-step, you will gain a concrete intuition for how the search behaves when its ideal conditions are not met and see how the probe estimate adapts to the data's curvature [@problem_id:3241452].", "problem": "Consider a sorted array $A$ of length $n$ with entries defined by $A[i] = i^{2}$ for all integer indices $i \\in \\{0, 1, \\dots, n-1\\}$. Let $n = 1001$. You will perform interpolation search for the key $x = 900^{2}$ using the following algorithmic specification.\n\nInitialize $low = 0$ and $high = n - 1$. While $low \\leq high$, compute the probe index\n$$\np = low + \\left\\lfloor \\frac{x - A[low]}{A[high] - A[low]} \\cdot (high - low) \\right\\rfloor,\n$$\nwith the convention that if $A[low] = A[high]$ then $p = low$. After computing $p$, access $A[p]$ and compare to $x$:\n- If $A[p] = x$, the search succeeds and terminates.\n- If $A[p]  x$, set $low = p + 1$ and continue.\n- If $A[p]  x$, set $high = p - 1$ and continue.\n\nDefine a single \"probe\" as one loop iteration in which the index $p$ is computed and the array value $A[p]$ is accessed exactly once. Do not count any other operations as probes. Starting from the specified initial conditions, determine the exact number of probes that this interpolation search performs before it successfully finds $x$ in $A$. The final answer must be a single integer value. No rounding is needed.", "solution": "The foundational principle is the definition of interpolation search on a sorted array, which uses linear interpolation between the endpoints to estimate the likely position of the target key. Concretely, at any iteration with current bounds $low$ and $high$, the probe index $p$ is defined by\n$$\np = low + \\left\\lfloor \\frac{x - A[low]}{A[high] - A[low]} \\cdot (high - low) \\right\\rfloor,\n$$\nand the update rules follow from the comparison of $A[p]$ with $x$.\n\nIn our instance, the array satisfies $A[i] = i^{2}$ for all $i$, so at any iteration with bounds $low = L$ and $high = H$, the formula simplifies algebraically. Write $x = k^{2}$ with $k = 900$. Then\n$$\n\\frac{x - A[L]}{A[H] - A[L]} \\cdot (H - L)\n= \\frac{k^{2} - L^{2}}{H^{2} - L^{2}} \\cdot (H - L)\n= \\frac{(k - L)(k + L)}{(H - L)(H + L)} \\cdot (H - L)\n= \\frac{(k - L)(k + L)}{H + L}.\n$$\nTherefore,\n$$\np = L + \\left\\lfloor \\frac{(k - L)(k + L)}{H + L} \\right\\rfloor.\n$$\n\nWe now execute the search step by step, counting each computed $p$ and single access to $A[p]$ as exactly one probe.\n\nInitial conditions are $n = 1001$, so $low = 0$, $high = 1000$, and $x = 900^{2} = 810000$.\n\n- Probe $1$: $L = 0$, $H = 1000$, $k = 900$.\n  Compute\n  $$\n  p = 0 + \\left\\lfloor \\frac{(900 - 0)(900 + 0)}{1000 + 0} \\right\\rfloor\n    = \\left\\lfloor \\frac{810000}{1000} \\right\\rfloor\n    = 810.\n  $$\n  Access $A[810] = 810^{2} = 656100$. Since $656100  810000$, set $low = p + 1 = 811$ and keep $high = 1000$.\n\n- Probe $2$: $L = 811$, $H = 1000$, $k = 900$.\n  Compute\n  $$\n  p = 811 + \\left\\lfloor \\frac{(900 - 811)(900 + 811)}{1000 + 811} \\right\\rfloor\n    = 811 + \\left\\lfloor \\frac{89 \\cdot 1711}{1811} \\right\\rfloor.\n  $$\n  Calculate $89 \\cdot 1711 = 152279$. Then $\\left\\lfloor \\frac{152279}{1811} \\right\\rfloor = 84$ because $1811 \\cdot 84 = 152124$ and $1811 \\cdot 85 = 153935  152279$. Hence $p = 811 + 84 = 895$.\n  Access $A[895] = 895^{2} = 801025$. Since $801025  810000$, set $low = p + 1 = 896$ and keep $high = 1000$.\n\n- Probe $3$: $L = 896$, $H = 1000$, $k = 900$.\n  Compute\n  $$\n  p = 896 + \\left\\lfloor \\frac{(900 - 896)(900 + 896)}{1000 + 896} \\right\\rfloor\n    = 896 + \\left\\lfloor \\frac{4 \\cdot 1796}{1896} \\right\\rfloor\n    = 896 + \\left\\lfloor \\frac{7184}{1896} \\right\\rfloor.\n  $$\n  Since $1896 \\cdot 3 = 5688$ and $1896 \\cdot 4 = 7584  7184$, we have $\\left\\lfloor \\frac{7184}{1896} \\right\\rfloor = 3$, so $p = 896 + 3 = 899$.\n  Access $A[899] = 899^{2} = 808201$. Since $808201  810000$, set $low = p + 1 = 900$ and keep $high = 1000$.\n\n- Probe $4$: $L = 900$, $H = 1000$, $k = 900$.\n  Compute\n  $$\n  p = 900 + \\left\\lfloor \\frac{(900 - 900)(900 + 900)}{1000 + 900} \\right\\rfloor\n    = 900 + \\left\\lfloor \\frac{0 \\cdot 1800}{1900} \\right\\rfloor\n    = 900.\n  $$\n  Access $A[900] = 900^{2} = 810000$. Since $A[900] = x$, the search succeeds and terminates.\n\nWe performed exactly $4$ probes before finding the key. No additional operations are counted as probes by the problemâ€™s definition. Therefore, the exact number of probes is $4$.", "answer": "$$\\boxed{4}$$", "id": "3241452"}, {"introduction": "After observing how interpolation search performs on a given non-uniform dataset, we can deepen our understanding by exploring its absolute limits. This practice is a thought experiment in adversarial thinking: can you design a dataset that makes the algorithm's first guess maximally wrong? By reverse-engineering the interpolation formula, you will construct a specific array and key that deliberately mislead the search, revealing the consequences of violating its core assumption of data linearity in the most dramatic way possible [@problem_id:3241327].", "problem": "Consider a strictly increasing, sorted array of distinct real numbers $A[1], A[2], \\ldots, A[n]$ with $n \\geq 3$. Interpolation search estimates the location of a query key $x$ by linearly interpolating the position of $x$ between the endpoints $A[1]$ and $A[n]$, and then rounding to an integer index. Using only the principle of linear interpolation between two endpoints on a sorted table, derive the expression for the first probe index $p$ of interpolation search when the search interval is the full array $[1, n]$.\n\nThen, design a concrete family of arrays $A$ (parameterized if necessary) and specify a particular choice of $x$ such that the first probe $p$ is provably the worst possible next choice in the sense that it lands on the index farthest from the true index $k$ where $A[k] = x$. Your construction must satisfy $A[1] = 0$, $A[n] = 1$, and $A[i] \\in (0, 1)$ for all $i \\in \\{2, \\ldots, n-1\\}$, with $A[1]  A[2]  \\cdots  A[n]$. Justify rigorously that under these constraints the first probe $p$ produced by interpolation from the endpoints is the farthest possible index from $k$.\n\nFinally, as a function of $n$, compute the exact maximal possible absolute index error $|p - k|$ achievable in this scenario. Express your final answer as a closed-form analytic expression. No rounding is required.", "solution": "The principle of interpolation search is to model the data as lying on a straight line. Given a sorted array $A$ indexed from 1 to $n$, we consider the points $(1, A[1])$ and $(n, A[n])$ in the (index, value) plane. The equation of the line passing through these two points is $V(i) = A[1] + \\frac{A[n] - A[1]}{n - 1}(i - 1)$. To find the estimated index for a given value $x$, we set $V(i) = x$ and solve for $i$. The integer probe index $p$ is obtained by taking the floor of the continuous estimate:\n$$ p = 1 + \\left\\lfloor (n - 1) \\frac{x - A[1]}{A[n] - A[1]} \\right\\rfloor $$\nGiven the constraints $A[1] = 0$ and $A[n] = 1$, the formula simplifies to:\n$$ p = 1 + \\lfloor (n - 1)x \\rfloor $$\nWe are searching for a value $x$ that exists in the array, so $x = A[k]$ for some index $k \\in \\{1, \\ldots, n\\}$. The probe index is thus:\n$$ p = 1 + \\lfloor (n - 1)A[k] \\rfloor $$\nOur objective is to construct an array $A$ and choose a $k$ to maximize the absolute index error, $|p - k| = |(1 + \\lfloor (n - 1)A[k] \\rfloor) - k|$. The value of $p$ depends only on $n$ and $A[k]$. Since we can always construct a valid strictly increasing array for any choice of $k \\in \\{2, \\ldots, n-1\\}$ and any value $v \\in (0, 1)$ such that $A[k]=v$, we can analyze the error by manipulating $k$ and $A[k]$.\n\nTo maximize $|p - k|$, we must make $p$ and $k$ as far apart as possible. This suggests choosing one to be near its minimum value and the other near its maximum. The index $k$ can range from $2$ to $n-1$. The probe $p$ can range from $1$ to $n-1$.\n\n**Case 1: Large `k`, small `p`.**\nLet us choose $k$ to be its maximum possible value in the search range, $k = n-1$. To maximize the error $|p - (n-1)|$, we should make $p$ as small as possible, which is $p=1$. To have $p = 1$, we need $\\lfloor (n-1)A[n-1] \\rfloor = 0$. This inequality holds if $0 \\le (n-1)A[n-1]  1$, which simplifies to $0 \\le A[n-1]  \\frac{1}{n-1}$. Since $A$ must be strictly increasing and $A[1]=0$, we can choose any $A[n-1]$ in the interval $(0, \\frac{1}{n-1})$. Let's search for $x = A[n-1]$. The true index is $k=n-1$. The probe index is $p=1$. The absolute error is $|p - k| = |1 - (n-1)| = n-2$.\n\n**Case 2: Small `k`, large `p`.**\nLet us choose $k$ to be its minimum possible value, $k = 2$. To maximize the error $|p - 2|$, we should make $p$ as large as possible. The maximum possible value for $p$ is $n-1$, which requires $\\lfloor (n-1)A[2] \\rfloor = n-2$. This holds if $n-2 \\le (n-1)A[2]  n-1$, which means $\\frac{n-2}{n-1} \\le A[2]  1$. This is a valid range for $A[2]$. Let's search for $x = A[2]$. The true index is $k=2$. The probe index is $p=n-1$. The absolute error is $|p - k| = |(n-1) - 2| = n-3$.\n\nComparing the two cases, the maximum error is $n-2$ (since $n \\ge 3$ implies $n-2 \\ge n-3$).\n\nTo demonstrate this worst case, we construct a specific array. Let $n \\ge 3$. Define $A$ as:\n- $A[1] = 0$\n- $A[n] = 1$\n- $A[n-1] = \\frac{1}{2(n-1)}$. This satisfies $0  A[n-1]  \\frac{1}{n-1}$.\n- For $i \\in \\{2, \\ldots, n-2\\}$, define $A[i]$ by linear spacing: $A[i] = \\frac{i-1}{n-2} A[n-1]$. This construction is valid as it creates a strictly increasing sequence.\n\nNow, let the search key be $x = A[n-1] = \\frac{1}{2(n-1)}$. The true index is $k = n-1$.\nThe probe index is calculated as:\n$$ p = 1 + \\left\\lfloor (n-1)x \\right\\rfloor = 1 + \\left\\lfloor (n-1) \\cdot \\frac{1}{2(n-1)} \\right\\rfloor = 1 + \\left\\lfloor \\frac{1}{2} \\right\\rfloor = 1 + 0 = 1 $$\nThe probe lands on index $1$. The absolute index error is $|p - k| = |1 - (n-1)| = n-2$. This construction shows that an error of $n-2$ is achievable and our analysis showed it is the maximal possible error. The maximal possible absolute index error is $n-2$.", "answer": "$$\\boxed{n-2}$$", "id": "3241327"}, {"introduction": "Understanding an algorithm's weaknesses is the first step toward building more robust systems. The previous exercises highlight that while interpolation search can be fast, it is not always reliable. This final practice moves from analysis to engineering, tasking you with designing a \"smart\" algorithm that gets the best of both worlds. You will create a hybrid search that begins with interpolation but intelligently monitors its own progress, dynamically switching to the guaranteed performance of binary search when it detects that the data distribution is unfavorable, resulting in a practical and resilient solution [@problem_id:3241345].", "problem": "You are to design and implement a self-tuning search algorithm over a sorted array that begins with interpolation-based probing and dynamically switches to binary search when its observed progress is consistently poor. The algorithm must operate on an array of real or integer values that is sorted in nondecreasing order and must return an index where a given target value occurs, or $-1$ if the target is not present. The program must be self-contained and must run without any input.\n\nThe design must be driven from fundamental definitions and well-tested facts:\n\n1. A sorted array $A$ of length $n$ satisfies $A[i] \\le A[j]$ for all $0 \\le i \\le j \\le n-1$.\n2. Binary search maintains an invariant subrange $[l,r]$ and, on each probe, reduces the remaining range length $L_t = r - l + 1$ by a factor of at most approximately $1/2$.\n3. Interpolation-based probing relies on a linear model assumption about the monotone mapping $x \\mapsto A[x]$ over indices, which is reasonable when the values are approximately uniformly distributed over the index range. It maintains the invariant $A[l] \\le \\text{key} \\le A[r]$ and chooses a probe position within $[l,r]$ by estimating where the key falls relative to $A[l]$ and $A[r]$.\n\nThe algorithm must monitor its own progress quantitatively. Define the range length at time $t$ as $L_t = r_t - l_t + 1$. After each interpolation probe and the corresponding update to $[l_{t+1}, r_{t+1}]$, define the fractional range reduction\n$$\n\\rho_t = \\frac{L_t - L_{t+1}}{L_t}.\n$$\nUse a fixed window size $w$ and a threshold $\\tau$, and compute the moving average of the last $w$ observed $\\rho_t$ values. If the moving average falls below $\\tau$ (indicating consistently poor reduction per probe), immediately switch to binary search for the remainder of the search range.\n\nAlgorithmic requirements and edge-case handling:\n\n- The algorithm must maintain the invariant subrange $[l,r]$ and count a probe each time it reads and compares $A[i]$ at a chosen index $i$ to guide the search. Accessing $A[l]$ and $A[r]$ to compute an estimate does not itself count as a probe unless a comparison with the target is performed at those indices.\n- If at any point the denominator $A[r] - A[l]$ becomes $0$ within the invariant subrange, the array values are constant over $[l,r]$. In this case, switch directly to binary search in $[l,r]$ to avoid undefined interpolation and continue probing until termination.\n- If the target key is outside the current invariant bounds (that is, $\\text{key}  A[l]$ or $\\text{key}  A[r]$), terminate and return $-1$ with zero probes added for that case.\n- When the target occurs multiple times, returning any valid index within its occurrence range is acceptable.\n- The program must report, for each test case, three outputs: the found index $i$ (or $-1$ if not found), the total number of probes $p$, and a boolean $b$ indicating whether binary search was used at any point ($\\text{True}$ if switched or directly used, $\\text{False}$ otherwise).\n\nTest suite and parameters:\n\nUse the same threshold and window across all cases: $\\tau = 0.3$ and $w = 4$. For each case, define the sorted array $A$ and the target key as follows.\n\n- Case $1$ (uniform distribution, happy path): $A = \\{0,1,2,\\dots,999\\}$ and $\\text{key} = 750$.\n- Case $2$ (nonlinear spacing, skewed mapping): $A = \\{i^3 : i \\in \\{0,1,2,\\dots,199\\}\\}$ and $\\text{key} = 729$.\n- Case $3$ (heavy duplicates causing local flat regions): $A$ contains $1000$ copies of $5$ followed by the sequence $\\{6,7,\\dots,105\\}$, and $\\text{key} = 5$.\n- Case $4$ (target absent boundary condition): $A = \\{0,1,2,\\dots,9999\\}$ and $\\text{key} = 10001$.\n- Case $5$ (extremely skewed growth, approximate exponential): $A = \\{\\lfloor 10^{i/100} \\rfloor : i \\in \\{0,1,2,\\dots,1000\\}\\}$ and $\\text{key}$ equals the element at index $800$ of $A$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this top-level list corresponds to one test case and must itself be a three-item list in the order $[i,p,b]$, where $i$ is the integer index or $-1$, $p$ is the integer number of probes counted as defined above, and $b$ is a boolean indicating whether binary search was used. For example, the printed line must look like\n$[[i_1,p_1,b_1],[i_2,p_2,b_2],[i_3,p_3,b_3],[i_4,p_4,b_5]]$.", "solution": "The problem requires the design and implementation of a hybrid search algorithm for sorted arrays. This algorithm initiates a search using interpolation-based probing and autonomously switches to binary search if its observed performance is substandard. The solution must be grounded in the fundamental principles of these search algorithms and adhere to specific implementation requirements.\n\n### Principles and Algorithmic Design\n\nA sorted array $A$ of length $n$ exhibits a monotonic non-decreasing relationship between indices and values, i.e., $A[i] \\le A[j]$ for all $0 \\le i  j \\le n-1$. This property is the foundation for search algorithms more efficient than linear scanning.\n\n#### Binary Search\nBinary search is a robust algorithm that guarantees a logarithmic time complexity, $O(\\log n)$. It operates on a search sub-range $[l, r]$ and probes the middle element $A[\\text{mid}]$, where $\\text{mid} = l + \\lfloor(r-l)/2\\rfloor$. Based on the comparison between $A[\\text{mid}]$ and the target key, it halves the search space in each step. The range length $L_t = r_t - l_t + 1$ is reduced such that $L_{t+1} \\approx L_t/2$. Its performance is independent of the value distribution within the array.\n\n#### Interpolation Search\nInterpolation search leverages the values of the elements at the boundaries of the search range $[l, r]$ to estimate the position of the target key. It assumes an approximately linear mapping from indices to values. The probe position, `pos`, is calculated via linear interpolation:\n$$\n\\text{pos} = l + \\left\\lfloor \\frac{(\\text{key} - A[l])(r-l)}{A[r] - A[l]} \\right\\rfloor\n$$\nFor uniformly distributed data, interpolation search exhibits an average time complexity of $O(\\log \\log n)$, which is asymptotically faster than binary search. However, its performance degrades significantly for non-uniformly distributed data (e.g., exponential or clustered values), with a worst-case complexity of $O(n)$.\n\n#### Hybrid Algorithm with Self-Tuning\nThe proposed algorithm seeks to combine the strengths of both methods: the potential high speed of interpolation search and the guaranteed performance of binary search. It does so by quantitatively monitoring its own progress and switching strategies when interpolation proves ineffective.\n\n**Performance Monitoring:**\nThe progress of the search is measured by the fractional range reduction, $\\rho_t$, after each probe at step $t$. Given the range length $L_t = r_t - l_t + 1$ before a probe and $L_{t+1}$ after, the reduction is:\n$$\n\\rho_t = \\frac{L_t - L_{t+1}}{L_t} = 1 - \\frac{L_{t+1}}{L_t}\n$$\nA value of $\\rho_t$ close to $1$ indicates a very effective probe, while a value near $0$ signifies minimal progress. For binary search, $\\rho_t \\approx 0.5$.\n\n**Switching Logic:**\nTo avoid prematurely switching due to a single unlucky probe, the algorithm computes a simple moving average of the last $w$ observed $\\rho_t$ values. If this average falls below a predefined threshold $\\tau$, it indicates a consistent pattern of poor performance. At this point, the algorithm concludes that the linear model assumed by interpolation search is invalid for the given data distribution and switches to the more robust binary search for the remainder of the search in the current sub-range $[l, r]$.\n\n### Implementation Details and Edge-Case Handling\n\nThe algorithm is implemented as a state machine with two modes: `'interpolation'` and `'binary'`.\n\n1.  **Initialization**: The search range is initialized to the entire array, $[0, n-1]$. An initial check is performed to see if the target `key` is outside the array's value range, i.e., `key  A[0]` or `key > A[n-1]`. If so, the search terminates immediately, returning an index of $-1$ with zero probes, as the key cannot be present.\n\n2.  **Main Loop**: The search proceeds as long as the range is valid ($l \\le r$).\n\n3.  **Interpolation Mode**:\n    *   **Denominator Check**: A critical edge case for the interpolation formula is when $A[r] = A[l]$. This indicates all elements in the current sub-range $[l, r]$ are identical. Attempting to interpolate would cause a division by zero. As per the problem specification, if this occurs, the algorithm switches to binary search. This is because if `key` equals this constant value, binary search can efficiently find an index; if not, it will correctly determine its absence.\n    *   **Probe Calculation**: The `pos` index is calculated. Care must be taken to ensure the calculation is performed using integer arithmetic or correctly cast to an integer index.\n    *   **Probe and Update**: The element $A[\\text{pos}]$ is compared to the `key`, a probe is counted, and the range $[l, r]$ is narrowed.\n    *   **Performance Update**: After updating `l` or `r`, the new $\\rho_t$ is calculated and added to a list (or deque) of recent reductions.\n    *   **Switch Condition Check**: If the reductions list has at least $w$ elements, their average is computed. If it is less than $\\tau$, the mode is switched to `'binary'`, and a boolean flag `used_binary` is set to `True`.\n\n4.  **Binary Search Mode**:\n    *   Once the algorithm enters this mode, it remains in it until termination.\n    *   The standard binary search procedure is followed: calculate `mid`, probe $A[\\text{mid}]$, and narrow the range $[l, r]$. Each probe is counted.\n\n5.  **Termination**: If the loop finishes without finding the key ($l > r$), the key is not in the array, and an index of $-1$ is returned. If the key is found at any point, its index is returned immediately. The final return value aggregates the found index, the total number of probes, and the boolean flag indicating if binary search was ever employed.\n\nThis design provides a robust and adaptive search mechanism that performs well across a variety of data distributions, fulfilling all requirements of the problem statement. The following code implements this logic for the specified test suite.", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Designs and executes the self-tuning hybrid search algorithm\n    on a predefined test suite.\n    \"\"\"\n\n    def hybrid_search(A, key: int, tau: float, w: int):\n        \"\"\"\n        Performs a hybrid interpolation-binary search.\n\n        Args:\n            A: Sorted array-like object of numbers.\n            key: The target value to search for.\n            tau: The performance threshold for switching to binary search.\n            w: The window size for the moving average of range reduction.\n\n        Returns:\n            A list containing [found_index, num_probes, used_binary_search].\n        \"\"\"\n        n = len(A)\n        if n == 0:\n            return [-1, 0, False]\n            \n        l, r = 0, n - 1\n\n        probes = 0\n        used_binary = False\n        mode = 'interpolation'\n        reductions = deque(maxlen=w)\n\n        # Initial bounds check as per problem statement\n        if key  A[l] or key > A[r]:\n            return [-1, 0, False]\n\n        while l = r:\n            if mode == 'binary':\n                if not used_binary:\n                    used_binary = True\n                \n                mid = l + (r - l) // 2\n                probes += 1\n                \n                if A[mid] == key:\n                    return [mid, probes, used_binary]\n                elif A[mid]  key:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            else:  # mode == 'interpolation'\n                if key  A[l] or key > A[r]:\n                    break\n\n                if A[r] == A[l]:\n                    if A[l] == key:\n                        mode = 'binary'\n                        continue\n                    else:\n                        break\n                \n                old_l, old_r = l, r\n                \n                # Use floating point for calculation to avoid overflow with large numbers\n                # and maintain precision. Python's default integers handle arbitrary size,\n                # but this is safer and mirrors behavior in other languages.\n                pos_float = float(l) + (float(r - l) / float(A[r] - A[l])) * float(key - A[l])\n                pos = int(pos_float)\n                pos = max(l, min(pos, r))\n\n                probes += 1\n                \n                if A[pos] == key:\n                    return [pos, probes, used_binary]\n                elif A[pos]  key:\n                    l = pos + 1\n                else:\n                    r = pos - 1\n                \n                L_t = old_r - old_l + 1\n                L_t1 = (r - l + 1) if l = r else 0\n                \n                if L_t > 0:\n                    rho_t = (L_t - L_t1) / L_t\n                    reductions.append(rho_t)\n                \n                if len(reductions) == w:\n                    avg_rho = sum(reductions) / w\n                    if avg_rho  tau:\n                        mode = 'binary'\n                        used_binary = True\n\n        return [-1, probes, used_binary]\n\n    # --- Test Suite Definition ---\n    tau = 0.3\n    w = 4\n\n    test_cases = []\n\n    # Case 1: Uniform distribution\n    A1 = list(range(1000))\n    key1 = 750\n    test_cases.append((A1, key1))\n\n    # Case 2: Nonlinear spacing (cubic)\n    A2 = [i**3 for i in range(200)]\n    key2 = 729\n    test_cases.append((A2, key2))\n\n    # Case 3: Heavy duplicates\n    A3 = [5] * 1000 + list(range(6, 106))\n    key3 = 5\n    test_cases.append((A3, key3))\n\n    # Case 4: Target absent boundary condition\n    A4 = list(range(10000))\n    key4 = 10001\n    test_cases.append((A4, key4))\n    \n    # Case 5: Extremely skewed growth (exponential-like)\n    A5 = [int(10**(i/100)) for i in range(1001)]\n    key5 = A5[800]\n    test_cases.append((A5, key5))\n    \n    results = []\n    for A, key in test_cases:\n        result = hybrid_search(A, key, tau, w)\n        # Convert boolean to Python's True/False string representation for output\n        result[2] = bool(result[2])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3241345"}]}