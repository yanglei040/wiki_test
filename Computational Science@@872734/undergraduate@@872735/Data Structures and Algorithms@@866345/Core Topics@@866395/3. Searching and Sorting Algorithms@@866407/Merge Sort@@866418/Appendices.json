{"hands_on_practices": [{"introduction": "The heart of the merge sort algorithm is its `merge` procedure, which efficiently combines two already-sorted sequences. This first exercise isolates that core mechanism with a clever twist: you are asked to merge one list sorted in ascending order and another in descending order ([@problem_id:3252316]). Tackling this challenge requires a focused application of the two-pointer technique and solidifies your understanding of how the merge step preserves order.", "problem": "You are given two finite sequences of integers, denoted by $A$ and $B$, where $A$ is sorted in nondecreasing order and $B$ is sorted in nonincreasing order. Let $n = |A|$ and $m = |B|$. Your task is to design and implement a program that merges these two sequences into a single nondecreasing sequence using a comparison-based approach, while optimizing the number of element-to-element comparisons. The program must not physically reverse $B$ or create an auxiliary copy of $B$; aside from the output array, it must use only constant additional memory.\n\nFundamental base to use: comparison-based models of computation, definitions of total order, and the well-established merge operation from divide-and-conquer sorting. You may assume the standard algebraic decision-tree model where the only way to compare keys is by pairwise comparisons, and the cost we measure is the count of such comparisons. Your derivation must start from these fundamentals.\n\nDefine the following deterministic tie-breaking rule to make the result unique:\n- When comparing equal keys across $A$ and $B$ (that is, when $A[i] = B[j]$ under whatever indices are currently considered), place the key from $A$ first.\n- When multiple equal keys remain in $B$, preserve the order those keys would appear if $B$ were read from right to left (that is, in nondecreasing order). This rule corresponds to treating $B$ through a logical ascending view without physically reversing it.\n\nRequirements:\n- Correctness: The output sequence must be the sorted merge of $A$ and $B$ in nondecreasing order, respecting the above tie-breaking.\n- Optimality target: Minimize the number of key comparisons under the comparison-counting cost model in the worst case, and justify why your algorithm achieves the optimal worst-case number of comparisons among all algorithms that do not assume more structure than the given monotonicity of $A$ and $B$.\n- Space: Use $O(1)$ auxiliary space beyond the space used to store the output.\n- Time: Achieve time complexity $O(n + m)$.\n\nYour program must, for each test case specified below, produce two outputs:\n- The merged nondecreasing list of integers.\n- The total number of element-to-element comparisons performed to produce that merged list.\n\nTest suite to implement and evaluate:\n- Case $1$: $A = [1, 4, 6, 9]$, $B = [10, 7, 5, 2]$.\n- Case $2$: $A = []$, $B = [5, 3, 1]$.\n- Case $3$: $A = [-2, 0, 3]$, $B = []$.\n- Case $4$: $A = [1, 2, 2, 3]$, $B = [4, 3, 2, 2, 1]$.\n- Case $5$: $A = [-10, -5, 0, 5]$, $B = [8, 4, -1, -6, -9]$.\n- Case $6$: $A = [2]$, $B = [3]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result itself must be a list whose first element is the merged list of integers and its second element is the integer number of comparisons, for example,\n  $[[\\text{merged}_{1}, \\text{comparisons}_{1}], [\\text{merged}_{2}, \\text{comparisons}_{2}], \\ldots]$.\n- Concretely, your program must print exactly one line to standard output of the form $[r_1,r_2,r_3,r_4,r_5,r_6]$, where each $r_k$ is a two-element list as described above.", "solution": "The problem statement is analyzed and determined to be valid. It is a well-posed, scientifically grounded problem within the domain of algorithms and data structures, with no contradictions or ambiguities.\n\n### Principle-Based Design and Justification\n\nThe core of the problem is to merge two sequences, $A$ and $B$, of lengths $n = |A|$ and $m = |B|$ respectively, into a single nondecreasing sequence. The sequence $A$ is sorted in nondecreasing order ($A[0] \\le A[1] \\le \\dots \\le A[n-1]$), while $B$ is sorted in nonincreasing order ($B[0] \\ge B[1] \\ge \\dots \\ge B[m-1]$). The constraints are to use $O(1)$ auxiliary space (beyond the output array), achieve $O(n + m)$ time complexity, and minimize the worst-case number of element-to-element comparisons.\n\nThe fundamental principle is that of the standard merge algorithm used in merge sort. A standard merge operates on two sequences sorted in the same direction. The given problem presents a variation where the sequences are sorted in opposite directions.\n\nThe key insight is that a sequence sorted nonincreasingly is equivalent to a sequence sorted nondecreasingly if read in reverse. The problem explicitly forbids physically reversing or creating a copy of sequence $B$. However, we can achieve the same logical effect by iterating through $B$ using a pointer that moves from its last element to its first, i.e., from index $m-1$ down to $0$. This approach respects the space constraint.\n\nWe can thus design an algorithm using a two-pointer technique:\n1.  Initialize a pointer $i$ to $0$ for sequence $A$. This pointer will traverse $A$ from left to right.\n2.  Initialize a pointer $j$ to $m-1$ for sequence $B$. This pointer will traverse $B$ from right to left.\n3.  Initialize a pointer $k$ to $0$ for the output array, let's call it $C$, of size $n+m$.\n4.  Initialize a counter for comparisons, `comparisons`, to $0$.\n\nThe main merge process proceeds in a loop that continues as long as there are elements to consider in both sequences (i.e., while $i < n$ and $j \\ge 0$):\n- Increment the `comparisons` counter as we are about to perform one element-to-element comparison.\n- Compare the elements $A[i]$ and $B[j]$.\n- To construct a nondecreasing output sequence, we must always choose the smaller of the two candidate elements.\n- The problem specifies a tie-breaking rule: if $A[i] = B[j]$, the element from $A$ must be placed first. This is correctly implemented by the condition $A[i] \\le B[j]$.\n- If $A[i] \\le B[j]$, the element $A[i]$ is the smaller or equal element (respecting the tie-breaker). We copy $A[i]$ to $C[k]$, then advance the pointers $i$ and $k$.\n- Otherwise ($A[i] > B[j]$), the element $B[j]$ is strictly smaller. We copy $B[j]$ to $C[k]$, then decrement pointer $j$ (to move to the next smallest element in $B$) and increment $k$.\n\nOnce the main loop terminates, one of the sequences has been fully consumed. The remaining elements in the other sequence are all greater than or equal to any element already placed in $C$. They can be copied directly to the end of $C$ without any further comparisons.\n- If pointer $i$ has not reached the end of $A$ ($i < n$), the remaining elements $A[i \\dots n-1]$ are copied to $C$.\n- If pointer $j$ has not reached the beginning of $B$ ($j \\ge 0$), the remaining elements $B[j \\dots 0]$ are copied to $C$.\n\nThis algorithm correctly merges the two sequences while adhering to the specified constraints.\n- **Time Complexity**: Each comparison results in one element being placed in the output array $C$. The subsequent copy operations also place one element per step. In total, every element from $A$ and $B$ is processed once, leading to a time complexity of $O(n+m)$.\n- **Space Complexity**: The algorithm uses a few pointers ($i, j, k$) and a counter. This constitutes constant, $O(1)$, auxiliary space, as the space for the output array $C$ is not counted against this limit. The constraint of not reversing or copying $B$ is met.\n\n### Optimality of Comparison Count\n\nThe problem requires minimizing the worst-case number of comparisons. For merging two sorted lists of lengths $n$ and $m$ (where $n, m \\ge 1$), it is a well-established result from the study of comparison-based algorithms that any algorithm must perform at least $n+m-1$ comparisons in the worst case. This can be proven via an adversary argument. The adversary can construct inputs that force the algorithm to make choices that reveal the minimum amount of information, thus maximizing the total number of comparisons needed to fully determine the sorted order. Such a worst-case scenario occurs when the elements of the two lists are perfectly interleaved, forcing a comparison for each of the first $n+m-1$ elements to decide its position. The position of the final, largest element is then known without a comparison.\n\nOur proposed algorithm's number of comparisons is determined by the main loop. In each iteration of this loop, exactly one comparison is performed, and one element is placed in the output array. The loop continues until one list is exhausted. In the worst case, the loop runs until $n+m-1$ elements have been placed, at which point one list will have a single element remaining and the other will be empty. This requires exactly $n+m-1$ comparisons. The last element is then copied without comparison.\n\nTherefore, the algorithm performs at most $n+m-1$ comparisons (for $n,m \\ge 1$). Since this matches the theoretical lower bound, the algorithm is optimal with respect to the number of worst-case comparisons. For cases where $n=0$ or $m=0$, the merge is trivial, requiring $0$ comparisons, which our algorithm correctly performs.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the merge problem for a suite of test cases and prints the results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'A': [1, 4, 6, 9], 'B': [10, 7, 5, 2]},\n        # Case 2\n        {'A': [], 'B': [5, 3, 1]},\n        # Case 3\n        {'A': [-2, 0, 3], 'B': []},\n        # Case 4\n        {'A': [1, 2, 2, 3], 'B': [4, 3, 2, 2, 1]},\n        # Case 5\n        {'A': [-10, -5, 0, 5], 'B': [8, 4, -1, -6, -9]},\n        # Case 6\n        {'A': [2], 'B': [3]},\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case['A']\n        B = case['B']\n        merged_list, comparisons = merge_with_optimal_comparisons(A, B)\n        results.append([merged_list, comparisons])\n\n    # Final print statement in the exact required format.\n    # The default str() representation of lists is used, which includes spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef merge_with_optimal_comparisons(A, B):\n    \"\"\"\n    Merges a non-decreasing sequence A and a non-increasing sequence B\n    into a single non-decreasing sequence.\n\n    Args:\n        A (list[int]): A sequence of integers sorted in nondecreasing order.\n        B (list[int]): A sequence of integers sorted in nonincreasing order.\n\n    Returns:\n        tuple[list[int], int]: A tuple containing the merged nondecreasing list\n                               and the total number of element-to-element\n                               comparisons performed.\n    \"\"\"\n    n = len(A)\n    m = len(B)\n    \n    # The output array is permitted per the problem statement.\n    merged_list = [0] * (n + m)\n    comparisons = 0\n    \n    i = 0      # Pointer for A, traversing from left to right (0 to n-1)\n    j = m - 1  # Pointer for B, traversing from right to left (m-1 to 0)\n    k = 0      # Pointer for the output merged_list\n    \n    # Main merge loop, continues as long as both lists have elements.\n    while i < n and j >= 0:\n        comparisons += 1\n        # The core comparison. A is non-decreasing, and B viewed backwards\n        # is also non-decreasing. We take the smaller of the two candidates.\n        # Tie-breaking rule: if A[i] == B[j], the element from A is placed first.\n        # This is correctly handled by the condition A[i] <= B[j].\n        if A[i] <= B[j]:\n            merged_list[k] = A[i]\n            i += 1\n        else:\n            merged_list[k] = B[j]\n            j -= 1\n        k += 1\n        \n    # After the main loop, one of the lists is exhausted.\n    # Copy the remaining elements from the other list. No more comparisons are needed.\n    \n    # If any elements remain in A, copy them.\n    while i < n:\n        merged_list[k] = A[i]\n        i += 1\n        k += 1\n        \n    # If any elements remain in B, copy them.\n    # The pointer j is decremented, correctly copying B's elements\n    # in their logical nondecreasing order (right-to-left).\n    while j >= 0:\n        merged_list[k] = B[j]\n        j -= 1\n        k += 1\n        \n    return merged_list, int(comparisons)\n\n# Entry point for execution.\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3252316"}, {"introduction": "With a solid grasp of the merge operation, we can now build the complete recursive algorithm. This practice moves beyond simple arrays and challenges you to implement merge sort on a singly linked list, with the added constraint that the original list's nodes are immutable ([@problem_id:3252314]). This problem forces you to think from first principles about how to divide and conquer a data structure that lacks random access, reinforcing the fundamental logic of merge sort.", "problem": "You are given the task of designing and implementing a stable comparison-based sorting algorithm over a singly linked list subject to immutability constraints on the original nodes. The foundational base for your reasoning must start from the definitions of a singly linked list and the divide-and-conquer paradigm: a singly linked list is a sequence of nodes, each containing a value and a pointer to the next node, and divide-and-conquer partitions the input into subproblems, solves each recursively, and merges the results. You must not rely on any pre-provided algorithmic shortcuts; derive the approach from these foundations. The specific constraint is that the original nodes' next pointers cannot be modified; a sorted output must be constructed as a new singly linked list whose nodes are newly allocated. The algorithm must be stable, meaning that if two elements have equal keys, their relative order in the output must match their relative order in the input. Your program must produce quantifiable outputs for a test suite that covers general cases, boundary conditions, and edge cases.\n\nRequirements:\n1. Data model and constraints:\n   - The input is a singly linked list of nodes, each node containing an integer key and optionally a symbolic tag.\n   - The original list's next pointers must be treated as immutable. You may only create new nodes; you may read the original nodes but must not modify any original next pointers.\n   - The output must be a new singly linked list containing the same keys, sorted in non-decreasing order, with stability preserved.\n2. Algorithmic design task:\n   - Implement a stable mergesort over a singly linked list that constructs a sorted copy without modifying the original nodes. The merge operation must be designed to preserve stability by resolving equal keys according to their original left-to-right precedence.\n   - Establish the method for dividing the list into two halves without altering original pointers (for example by advancing a pointer by a computed midpoint), and argue correctness and complexity from first principles.\n3. Complexity and correctness expectations:\n   - The algorithm should run in time $\\mathcal{O}(n \\log n)$ where $n$ is the number of nodes in the input list and use $\\mathcal{O}(n)$ additional memory for the newly allocated nodes plus $\\mathcal{O}(\\log n)$ stack frames due to recursion. Derive these bounds from the divide-and-conquer structure and properties of singly linked lists without relying on memorized formulas.\n4. Test suite and outputs:\n   - Apply your implementation to the following test suite of inputs. Each test case specifies a sequence of keys; where tags are present, they are secondary labels not used in comparisons, intended to verify stability.\n     - Test case $1$ (general case): keys $[4,1,3,9,7,0,2,5,8,6]$.\n     - Test case $2$ (boundary: empty list): keys $[]$.\n     - Test case $3$ (boundary: single element): keys $[42]$.\n     - Test case $4$ (duplicates): keys $[5,3,3,5,2,2,1,1]$.\n     - Test case $5$ (already sorted): keys $[1,2,3,4,5]$.\n     - Test case $6$ (negative and mixed): keys $[-3,-1,-7,0,2]$.\n     - Test case $7$ (stability verification with tags): pairs $[(2,a),(1,x),(2,b),(1,y),(2,c)]$, where keys are the first components and tags $a,x,b,y,c$ are symbolic labels. Sort by keys only, and verify the stability of the output by checking that within each equal-key group, the tags appear in the same order as in the original input.\n   - For test cases $1$ through $6$, output the sorted keys as a list of integers. For test case $7$, output a boolean asserting whether stability holds (true if and only if the tag order within equal-key groups is preserved).\n5. Final output format:\n   - Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $\\left[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_7\\right]$. Each $\\text{result}_i$ must be either a list of integers or a boolean, exactly in the order of the test cases above. No additional text or lines should be printed.\n\nNo physical units, angle units, or percentages are involved in this problem; only pure integer keys and boolean outputs are required.", "solution": "The problem statement requires the design and implementation of a stable, comparison-based sorting algorithm for a singly linked list. The core constraints are that the original list's nodes are immutable (their `next` pointers cannot be changed), and the sorted output must be a newly constructed linked list. The solution must be derived from the first principles of the divide-and-conquer paradigm.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n\n*   **Input Data Structure**: A singly linked list where each node contains an integer `key` and an optional symbolic `tag`.\n*   **Immutability Constraint**: The `next` pointers of the nodes in the original input list must not be modified.\n*   **Output Data Structure**: A new singly linked list, with newly allocated nodes, containing the same data as the input, sorted in non-decreasing order of keys.\n*   **Algorithm Requirement**: A stable mergesort derived from the divide-and-conquer paradigm.\n*   **Stability Requirement**: If two elements have equal keys, their relative order in the sorted output must be identical to their relative order in the input.\n*   **Complexity Requirements**:\n    *   Time: $\\mathcal{O}(n \\log n)$.\n    *   Space: $\\mathcal{O}(n)$ for new nodes and $\\mathcal{O}(\\log n)$ for the recursion stack. These bounds must be derived.\n*   **Test Cases**:\n    1.  Keys: $\\left[4,1,3,9,7,0,2,5,8,6\\right]$\n    2.  Keys: $\\left[\\,\\right]$\n    3.  Keys: $\\left[42\\right]$\n    4.  Keys: $\\left[5,3,3,5,2,2,1,1\\right]$\n    5.  Keys: $\\left[1,2,3,4,5\\right]$\n    6.  Keys: $\\left[-3,-1,-7,0,2\\right]$\n    7.  Key-Tag Pairs: $\\left[(2,a),(1,x),(2,b),(1,y),(2,c)\\right]$\n*   **Output Format**: A single line containing a comma-separated list of results (sorted integer lists for cases $1$-$6$, a boolean for case $7$) enclosed in square brackets.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is valid.\n*   **Scientifically Grounded**: The problem is a classic exercise in computer science, focusing on the well-established topics of linked lists, sorting algorithms (specifically mergesort), and algorithmic complexity.\n*   **Well-Posed**: The objectives, constraints, and required output are specified with precision. The combination of a singly linked list, an immutability constraint, and the stability requirement defines a non-trivial but solvable problem with a unique, correct output for any given input.\n*   **Objective**: The problem is stated using formal, unambiguous language.\n\nThe problem does not violate any of the invalidity criteria. It is a complete, consistent, and formalizable problem within the domain of algorithms.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A solution will be provided.\n\n### **Principle-Based Solution**\n\n#### **1. Foundational Principles**\n\nA **singly linked list** is a linear data structure composed of a sequence of nodes. Each node stores a payload (in this case, a key and an optional tag) and a single reference, or pointer, to the subsequent node. The list is accessed via a reference to its first node, the `head`. The final node's pointer is `null`, signifying the end of the list.\n\nThe **divide-and-conquer** paradigm is an algorithmic strategy with three phases:\n1.  **Divide**: The problem is partitioned into smaller, independent subproblems of the same type.\n2.  **Conquer**: The subproblems are solved, typically through recursive application of the same algorithm. If a subproblem is small enough (the base case), it is solved directly.\n3.  **Combine**: The solutions to the subproblems are merged to construct the solution for the original problem.\n\nWe will apply this paradigm to sort a singly linked list of length $n$.\n\n#### **2. Algorithmic Design: Immutable Mergesort for Linked Lists**\n\n**Base Case (Conquer)**\nThe simplest cases for sorting are an empty list or a list with a single element. Both are, by definition, already sorted.\n- If the list has length $n=0$ (is empty), the sorted version is also an empty list.\n- If the list has length $n=1$, the sorted version is a new list containing a single, newly allocated node with the same value.\n\n**Divide Step**\nThe core of the divide step is to split the list of length $n$ into two sublists of approximately equal size, $\\lfloor n/2 \\rfloor$ and $\\lceil n/2 \\rceil$. In an array, this is an $O(1)$ operation via index calculation. For a singly linked list, we must traverse the list to find the midpoint. To do this without modifying the original list's pointers, we first find the total length $n$ of the list. The midpoint is at index $m = \\lfloor n/2 \\rfloor$. The first sublist is the sequence of nodes from the `head` up to length $m$. The second sublist begins at the node at index $m$ and continues to the end of the original list, having length $n - m$.\n\nTo implement this, our recursive sorting function will accept a starting node and the length of the list segment to be sorted.\n1.  Calculate the midpoint index: $m = \\lfloor \\text{length}/2 \\rfloor$.\n2.  Find the head of the right sublist by starting at the current head and advancing its pointer $m$ times.\n3.  The left sublist is defined by the original head and length $m$.\n4.  The right sublist is defined by the new head found in step 2 and length $\\text{length} - m$.\n\nThis division process requires a traversal of $O(m) = O(n)$ steps to find the head of the second sublist.\n\n**Recursive Calls (Conquer)**\nWith the list conceptually divided, we recursively call the sort function on both sublists:\n- `sorted_left = mergesort(head_left, m)`\n- `sorted_right = mergesort(head_right, \\text{length} - m)`\n\nEach recursive call returns a new, sorted linked list.\n\n**Combine Step (Merge)**\nThis step takes two sorted linked lists, `sorted_left` and `sorted_right`, and merges them into a single, newly constructed, sorted linked list. This merge operation is the origin of the algorithm's stability and its name.\n\n1.  Create a `dummy_head` for the new list. This simplifies the logic by providing a fixed entry point, avoiding special handling for the first node insertion. A `tail` pointer will track the last node of the new list, initially pointing to `dummy_head`.\n2.  Iterate while both `sorted_left` and `sorted_right` are non-empty. In each iteration, compare the keys of the current head nodes of the two lists.\n3.  **Stability**: To ensure stability, if `sorted_left.key \\le sorted_right.key`, we must select the node from `sorted_left`. This rule guarantees that for elements with equal keys, the one that appeared first in the original input (and thus in the left sublist) is placed first in the output.\n    - If `sorted_left.key \\le sorted_right.key`: Create a new node with the data from `sorted_left`, append it to `tail.next`, and advance the `sorted_left` pointer.\n    - Otherwise: Create a new node with the data from `sorted_right`, append it to `tail.next`, and advance the `sorted_right` pointer.\n4.  Update `tail` to point to the newly created node.\n5.  After the loop terminates, one of the lists will be exhausted. The other may still contain elements. The remaining (already sorted) portion must be appended to the new list. This is done by iterating through the remaining nodes and creating a new copy of each to append to `tail`.\n6.  The final sorted list is `dummy_head.next`.\n\nThis merge process examines each of the $n$ elements once, creating a new node for each, resulting in an $O(n)$ time and space complexity for the combine step.\n\n#### **3. Complexity and Correctness Analysis**\n\n**Time Complexity**\nLet $T(n)$ represent the time taken to sort a list of length $n$.\n- **Divide**: Finding the midpoint takes $O(n)$ time.\n- **Conquer**: Two recursive calls are made on subproblems of size $n/2$ (approximately), costing $2T(n/2)$.\n- **Combine**: Merging the two sorted sublists takes $O(n)$ time.\n\nThe recurrence relation is: $T(n) = 2T(n/2) + O(n)$. The base case is $T(1) = O(1)$.\nThis is the classic mergesort recurrence. We can analyze it via a recursion tree:\n- **Level 0**: One problem of size $n$. Cost of divide/combine: $c \\cdot n$.\n- **Level 1**: Two subproblems, each of size $n/2$. Total cost: $2 \\cdot c \\cdot (n/2) = c \\cdot n$.\n- **Level k**: $2^k$ subproblems, each of size $n/2^k$. Total cost: $2^k \\cdot c \\cdot (n/2^k) = c \\cdot n$.\nThe recursion stops when the problem size is $1$, which occurs at level $k$ where $n/2^k = 1$, or $k = \\log_2 n$.\nThe total time is the sum of costs at all levels: $(\\text{number of levels}) \\times (\\text{cost per level}) = (\\log_2 n) \\times (c \\cdot n)$.\nThus, the time complexity is $O(n \\log n)$.\n\n**Space Complexity**\n- **Output List**: The problem specification mandates the creation of a new sorted list. This requires allocating $n$ new nodes, leading to $O(n)$ space complexity. This is an inherent requirement of the problem, not an auxiliary cost.\n- **Recursion Stack**: The maximum depth of the recursion tree is $\\log_2 n$. Each recursive call consumes a constant amount of space on the call stack for its parameters and local variables. Therefore, the auxiliary space used by the recursion stack is $O(\\log n)$.\n\nTotal space complexity is $O(n)$ (for the output) + $O(\\log n)$ (for the stack), which is dominated by the linear term, thus $O(n)$. The problem statement correctly asks for these two components to be identified separately.\n\n**Stability Analysis**\nStability is guaranteed by the `merge` function. When merging two lists, if two keys are equal, `key1 == key2`, our rule `key1 <= key2` ensures the element from the left sublist (`list1`) is chosen. Since the divide phase preserves the relative order of elements within the sublists, this choice consistently places elements that were originally on the left before elements that were originally on the right, maintaining their initial relative ordering throughout the sort. This property holds true at every merge step, thereby ensuring the final sorted list is stable. The test case with tags is specifically designed to verify this property.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Data model for the singly linked list\nclass Node:\n    \"\"\"A node in a singly linked list.\"\"\"\n    def __init__(self, key, tag=None, next_node=None):\n        self.key = key\n        self.tag = tag\n        self.next = next_node\n\n    def __repr__(self):\n        if self.tag is not None:\n            return f\"Node(key={self.key}, tag={self.tag})\"\n        return f\"Node(key={self.key})\"\n\n# Helper functions for list manipulation\ndef create_linked_list(data):\n    \"\"\"Creates a singly linked list from an iterable of keys or (key, tag) tuples.\"\"\"\n    dummy = Node(0)\n    current = dummy\n    for item in data:\n        if isinstance(item, tuple):\n            key, tag = item\n            current.next = Node(key, tag)\n        else:\n            current.next = Node(item)\n        current = current.next\n    return dummy.next\n\ndef linked_list_to_list(head):\n    \"\"\"Converts a singly linked list back to a Python list of keys.\"\"\"\n    result = []\n    current = head\n    while current:\n        result.append(current.key)\n        current = current.next\n    return result\n\ndef check_stability(original_data, sorted_head):\n    \"\"\"\n    Verifies the stability of the sort.\n    - True if for every key, the tags in the sorted output appear in the\n      same relative order as in the original input.\n    - False otherwise.\n    \"\"\"\n    if not original_data:\n        return True\n\n    original_tags_by_key = {}\n    for key, tag in original_data:\n        if key not in original_tags_by_key:\n            original_tags_by_key[key] = []\n        original_tags_by_key[key].append(tag)\n    \n    sorted_tags_by_key = {}\n    current = sorted_head\n    while current:\n        key, tag = current.key, current.tag\n        if key not in sorted_tags_by_key:\n            sorted_tags_by_key[key] = []\n        sorted_tags_by_key[key].append(tag)\n        current = current.next\n\n    for key in original_tags_by_key:\n        if key not in sorted_tags_by_key:\n            # This case shouldn't happen in a correct sort\n            return False \n        if original_tags_by_key[key] != sorted_tags_by_key[key]:\n            return False\n            \n    return True\n\n# Core Mergesort Algorithm\ndef _merge(left, right):\n    \"\"\"\n    Merges two sorted linked lists into a new sorted list, maintaining stability.\n    \"\"\"\n    dummy_head = Node(None)\n    tail = dummy_head\n    \n    p1, p2 = left, right\n    \n    while p1 is not None and p2 is not None:\n        # The <= condition is crucial for stability\n        if p1.key <= p2.key:\n            tail.next = Node(p1.key, p1.tag)\n            p1 = p1.next\n        else:\n            tail.next = Node(p2.key, p2.tag)\n            p2 = p2.next\n        tail = tail.next\n        \n    # Append remaining nodes from either list (one of them must be exhausted)\n    # New nodes must be created to respect the immutability of the sub-lists.\n    remaining = p1 if p1 is not None else p2\n    while remaining is not None:\n        tail.next = Node(remaining.key, remaining.tag)\n        tail = tail.next\n        remaining = remaining.next\n\n    return dummy_head.next\n\ndef _mergesort_recursive(head, length):\n    \"\"\"\n    Recursively divides the list and merges the sorted halves.\n    \"\"\"\n    # Base case: A list of length 0 or 1 is already sorted.\n    if length <= 1:\n        if head is None:\n            return None\n        # Return a new list of one element\n        return Node(head.key, head.tag)\n\n    # Divide: Find the midpoint and split the list conceptually.\n    mid = length // 2\n    \n    # Traverse to the head of the right sublist\n    mid_node = head\n    for _ in range(mid):\n        mid_node = mid_node.next\n\n    # Conquer: Recursively sort both halves.\n    # The first half is from `head` with length `mid`.\n    # The second half is from `mid_node` with length `length - mid`.\n    left_sorted_head = _mergesort_recursive(head, mid)\n    right_sorted_head = _mergesort_recursive(mid_node, length - mid)\n    \n    # Combine: Merge the two sorted halves.\n    return _merge(left_sorted_head, right_sorted_head)\n\ndef mergesort(head):\n    \"\"\"\n    Public entry point for the mergesort algorithm.\n    \"\"\"\n    # First, determine the length of the list.\n    length = 0\n    current = head\n    while current:\n        length += 1\n        current = current.next\n    \n    return _mergesort_recursive(head, length)\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'keys': [4,1,3,9,7,0,2,5,8,6], 'type': 'sort'},\n        {'keys': [], 'type': 'sort'},\n        {'keys': [42], 'type': 'sort'},\n        {'keys': [5,3,3,5,2,2,1,1], 'type': 'sort'},\n        {'keys': [1,2,3,4,5], 'type': 'sort'},\n        {'keys': [-3,-1,-7,0,2], 'type': 'sort'},\n        {'keys': [(2,'a'),(1,'x'),(2,'b'),(1,'y'),(2,'c')], 'type': 'stability'},\n    ]\n\n    results = []\n    for case in test_cases:\n        input_data = case['keys']\n        head = create_linked_list(input_data)\n        \n        sorted_head = mergesort(head)\n        \n        if case['type'] == 'sort':\n            result = linked_list_to_list(sorted_head)\n            # Use repr to get the list format with brackets\n            results.append(repr(result))\n        elif case['type'] == 'stability':\n            is_stable = check_stability(input_data, sorted_head)\n            # Python booleans 'True'/'False' need to be lowercase 'true'/'false'\n            # as per problem's implied JSON-like format\n            results.append(str(is_stable).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3252314"}, {"introduction": "Merge sort is more than just a sorting algorithm; it is a powerful template for a wide range of divide-and-conquer problems. This final practice demonstrates this versatility by tasking you with modifying the merge step to count \"significant inversions\"â€”pairs of elements $(A[i], A[j])$ where $i \\lt j$ and $A[i] > 2 \\cdot A[j]$ ([@problem_id:3252453]). By leveraging the sorted nature of the subarrays during the merge phase, you can solve this seemingly complex counting problem with surprising efficiency.", "problem": "You are given an array $A$ of length $n$ over a totally ordered domain of integers, where the total order $\\le$ satisfies transitivity, antisymmetry, and totality. The fundamental base is the definition of Divide and Conquer (D&C): decomposing a problem on a set of size $n$ into subproblems on smaller subsets, solving them independently, and combining solutions using the established invariants of the problem (here, the invariant is that after the combination step, the array is sorted). Your task is to implement a D&C merge sort variant that, during its merge step, counts the number of cross-subarray index pairs $(i,j)$ with $0 \\le i < j < n$ such that $A[i] > 2 \\cdot A[j]$. The resulting algorithm must return two outputs for each input array: the sorted version of the array and the total count of such pairs across the entire array. The expected computational complexity is $\\mathcal{O}(n \\log n)$ time and $\\mathcal{O}(n)$ auxiliary space, derived from the standard properties of merge sort.\n\nRequirements:\n- Use the definitions of arrays, total order, and the D&C merge sort structure as the fundamental base. At the combination step, only elements from the left subarray and the right subarray are compared or merged.\n- Count only pairs $(i,j)$ that respect the array index order $i < j$, and where $i$ belongs to the left subarray and $j$ belongs to the right subarray at the merge step; aggregating these across all recursion levels yields the total number of pairs with $A[i] > 2 \\cdot A[j]$ for the original array.\n- Produce, for each test case, a two-element list: the sorted array and the integer count of pairs.\n\nTest suite:\n- Case $1$: $A = []$.\n- Case $2$: $A = [5]$.\n- Case $3$: $A = [1,3,2,3,1]$.\n- Case $4$: $A = [10,9,8,7,6,5,4,3,2,1]$.\n- Case $5$: $A = [-5,-4,-2,-1]$.\n- Case $6$: $A = [0,0,0,0]$.\n- Case $7$: $A = [2,4,3,5,1,-2,8,16]$.\n- Case $8$: $A = [2147483647,-2147483648]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each item must be itself a two-element list of the form $[\\text{sorted\\_array}, \\text{count}]$. For example, a valid output with two cases would look like $[[[1,2,3],2],[[1],0]]$. Your program must not read any input and must use the arrays above as the built-in test suite.", "solution": "The problem requires the implementation of a divide-and-conquer algorithm, specifically a variant of merge sort, to count the number of pairs of indices $(i, j)$ in an array $A$ of length $n$ such that $i < j$ and $A[i] > 2 \\cdot A[j]$. The algorithm must also return the sorted version of the array. The stipulated computational complexity is $\\mathcal{O}(n \\log n)$ for time and $\\mathcal{O}(n)$ for auxiliary space.\n\nThe foundation of the solution lies in the Divide and Conquer (D&C) paradigm. A problem on a set of size $n$ is recursively broken down into smaller, independent subproblems. The solutions to these subproblems are then combined to form the solution to the original problem. For the task of counting pairs, this principle can be formalized as follows:\n\nLet $C(A)$ be the count of pairs in array $A$ satisfying the given condition. When we split $A$ at its midpoint, $m = \\lfloor n/2 \\rfloor$, into a left subarray $A_{left} = A[0 \\dots m-1]$ and a right subarray $A_{right} = A[m \\dots n-1]$, any pair $(i,j)$ with $i < j$ must fall into one of three disjoint categories:\n1. Both indices $i$ and $j$ are in the left subarray.\n2. Both indices $i$ and $j$ are in the right subarray.\n3. Index $i$ is in the left subarray, and index $j$ is in the right subarray.\n\nThis decomposition gives the recurrence relation for the total count:\n$$ C(A) = C(A_{left}) + C(A_{right}) + C_{cross}(A_{left}, A_{right}) $$\nwhere $C_{cross}$ represents the count of pairs with one element from each subarray. This structure is naturally suited for a merge sort-based algorithm. The recursive calls on the subarrays handle the first two terms, and the $C_{cross}$ term is computed during the merge step.\n\nThe algorithm is a recursive function, let's call it `Solve(A)`, which returns a tuple containing the sorted version of $A$ and the desired count of pairs.\n\n**Base Case:**\nIf the array $A$ has a length of $n \\le 1$, it is by definition sorted, and there can be no pairs $(i,j)$ with $i < j$. Thus, the function returns $(A, 0)$.\n\n**Recursive Step:**\nFor an array $A$ of length $n > 1$, the function performs the following steps:\n1.  **Divide:** The array $A$ is split into two halves: $A_{left} = A[0 \\dots m-1]$ and $A_{right} = A[m \\dots n-1]$, where $m = \\lfloor n/2 \\rfloor$.\n2.  **Conquer:** The function is called recursively on each half:\n    - $(S_{left}, count_{left}) = \\text{Solve}(A_{left})$\n    - $(S_{right}, count_{right}) = \\text{Solve}(A_{right})$\n    Here, $S_{left}$ and $S_{right}$ are the sorted versions of the respective subarrays, and $count_{left}$ and $count_{right}$ are the counts of pairs fully contained within them.\n3.  **Combine:** This step involves two sub-tasks: merging the sorted subarrays $S_{left}$ and $S_{right}$ into a single sorted array $S_{merged}$, and counting the cross-subarray pairs, $count_{cross}$. The total count for the current level is $count_{left} + count_{right} + count_{cross}$.\n\n**The Core: Merge and Count Cross-Pairs**\nThe critical part of the algorithm is the combine step, which must operate in linear time, i.e., $O(|S_{left}| + |S_{right}|)$, to preserve the overall $O(n \\log n)$ time complexity.\n\n**Counting Cross-Pairs:**\nWe are given two sorted arrays, $S_{left}$ and $S_{right}$. We need to count the number of pairs of elements $(u,v)$ where $u \\in S_{left}$ and $v \\in S_{right}$ such that $u > 2v$. The elements $u$ and $v$ correspond to original array values $A[i]$ and $A[j]$ where $i$ was in the left partition and $j$ in the right, so $i<j$ is guaranteed.\nSince both arrays are sorted, we can find this count efficiently using a two-pointer approach. We use one pointer, $i$, to iterate through $S_{left}$ and another pointer, $j$, for $S_{right}$.\nFor each element $S_{left}[i]$, we need to find how many elements in $S_{right}$ satisfy the condition. We advance pointer $j$ as long as $S_{left}[i] > 2 \\cdot S_{right}[j]$. Because both arrays are sorted in non-decreasing order, for the next element $S_{left}[i+1]$, we do not need to reset $j$ to $0$. We can resume the search from its current position. This ensures that the two pointers $i$ and $j$ only traverse their respective arrays once, leading to a linear time complexity of $O(|S_{left}| + |S_{right}|)$.\n\nThe procedure is as follows:\nInitialize $count_{cross} = 0$ and $j = 0$.\nFor $i$ from $0$ to $|S_{left}|-1$:\n  While $j < |S_{right}|$ and $S_{left}[i] > 2 \\cdot S_{right}[j]$:\n    $j \\leftarrow j + 1$\n  $count_{cross} \\leftarrow count_{cross} + j$\n\n**Merging:**\nAfter counting, the two sorted subarrays $S_{left}$ and $S_{right}$ are merged into a single sorted array $S_{merged}$ using the standard linear-time merge algorithm. This maintains the sorted invariant required for the next level of recursion up the call stack.\n\n**Complexity Analysis:**\n-   **Time Complexity:** The time complexity is described by the recurrence relation $T(n) = 2T(n/2) + \\Theta(n)$, where the $\\Theta(n)$ term arises from the linear-time partition and combine (counting and merging) steps. According to the Master Theorem, this recurrence resolves to $T(n) = O(n \\log n)$.\n-   **Space Complexity:** The algorithm requires auxiliary space to hold the sorted subarrays during the merge process. At each level of the recursion, the total space required for merging across all subproblems is $O(n)$. The recursion depth is $O(\\log n)$. As the space used at one level can be released before proceeding to the next, the peak auxiliary space required is $O(n)$.\n\nThis algorithm correctly computes both the sorted array and the specified count, adhering to the principles of Divide and Conquer and meeting the required complexity bounds.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for a predefined test suite and prints the-\n    results in the specified format.\n    \"\"\"\n    \n    test_cases = [\n        [],\n        [5],\n        [1, 3, 2, 3, 1],\n        [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],\n        [-5, -4, -2, -1],\n        [0, 0, 0, 0],\n        [2, 4, 3, 5, 1, -2, 8, 16],\n        [2147483647, -2147483648],\n    ]\n\n    def _merge_sort_and_count(arr):\n        \"\"\"\n        Recursively sorts an array and counts pairs (i, j) with i < j\n        and arr[i] > 2 * arr[j].\n\n        Args:\n            arr (list): The input list of integers.\n\n        Returns:\n            tuple: A tuple containing the sorted list and the integer count.\n        \"\"\"\n        n = len(arr)\n        if n <= 1:\n            return list(arr), 0\n\n        mid = n // 2\n        \n        # Conquer: Recursively solve for subarrays\n        sorted_left, count_left = _merge_sort_and_count(arr[:mid])\n        sorted_right, count_right = _merge_sort_and_count(arr[mid:])\n        \n        # Combine Step Part 1: Count cross-subarray pairs\n        # This must be done on the sorted subarrays to achieve O(n) complexity for this step.\n        count_cross = 0\n        j = 0\n        for i in range(len(sorted_left)):\n            while j < len(sorted_right) and sorted_left[i] > 2 * sorted_right[j]:\n                j += 1\n            count_cross += j\n            \n        # Combine Step Part 2: Merge the sorted subarrays\n        merged_array = []\n        i, j = 0, 0\n        while i < len(sorted_left) and j < len(sorted_right):\n            if sorted_left[i] <= sorted_right[j]:\n                merged_array.append(sorted_left[i])\n                i += 1\n            else:\n                merged_array.append(sorted_right[j])\n                j += 1\n        \n        # Append any remaining elements\n        merged_array.extend(sorted_left[i:])\n        merged_array.extend(sorted_right[j:])\n        \n        total_count = count_left + count_right + count_cross\n        \n        return merged_array, total_count\n\n    results = []\n    for case in test_cases:\n        result_array, result_count = _merge_sort_and_count(case)\n        results.append([result_array, result_count])\n\n    # Format the final output string precisely as required, without extra spaces.\n    result_strings = []\n    for res_arr, res_count in results:\n        arr_str = f\"[{','.join(map(str, res_arr))}]\"\n        result_strings.append(f\"[{arr_str},{res_count}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3252453"}]}