{"hands_on_practices": [{"introduction": "In the idealized world of theoretical geometry, algorithms operate on real numbers with infinite precision. This exercise forces us to confront the practical realities of computation, where numbers are represented with finite precision. We will investigate how floating-point arithmetic can lead to catastrophic failures in even the most fundamental geometric predicate—the orientation test—which determines whether a sequence of points makes a left, right, or straight turn. This hands-on thought experiment [@problem_id:3223470] is crucial for developing robust software, as it teaches you to anticipate and diagnose failures that arise not from faulty logic, but from the very nature of computer arithmetic.", "problem": "A central primitive used by the classic Andrew monotone chain algorithm for computing the convex hull in the Euclidean plane is the orientation predicate. For points $P=(x_{1},y_{1})$, $Q=(x_{2},y_{2})$, and $R=(x_{3},y_{3})$, the algorithm uses the sign of\n$$\n(x_{2}-x_{1})(y_{3}-y_{1})-(y_{2}-y_{1})(x_{3}-x_{1})\n$$\nto decide whether to keep or discard the most recently added point on the current hull. The algorithm assumes that orientation signs are computed correctly; with limited floating-point precision, these signs can be misclassified.\n\nAssume input coordinates are stored in Institute of Electrical and Electronics Engineers (IEEE) $754$ single-precision floating-point before any computation, and all subsequent arithmetic is performed in single precision. Model rounding to nearest representable number with unit roundoff $u=2^{-24}$, and recall that for normalized single-precision numbers with exponent $e$, the spacing between adjacent representable values (the unit in the last place, abbreviated as ulp) is $2^{e-23}$.\n\nConsider the following candidate point sets. In each set, let $M$ be as specified, and the four points are listed in the order they would naturally be fed to the algorithm after sorting by increasing $x$-coordinate and breaking ties by increasing $y$-coordinate. The true convex hull for each set, in exact arithmetic, is the four vertices of an axis-aligned square.\n\nWhich of the following point sets, when processed by the monotone chain algorithm under the stated single-precision model, can cause the algorithm to fail by omitting at least one true extreme vertex due to misclassification of the orientation predicate? Select all that apply.\n\nA. $M=2^{27}$. Points:\n$P=(M,M)$, $Q=(M+1,M)$, $R=(M,M+1)$, $S=(M+1,M+1)$.\n\nB. $M=2^{27}$. Points:\n$P=(M,M)$, $Q=(M+32,M)$, $R=(M,M+32)$, $S=(M+32,M+32)$.\n\nC. $M=2^{20}$. Points:\n$P=(M,M)$, $Q=(M+1,M)$, $R=(M,M+1)$, $S=(M+1,M+1)$.\n\nD. $M=2^{27}$. Points:\n$P=(M,M)$, $Q=(M+16,M)$, $R=(M+16,M+16)$, $S=(M,M+16)$.\n\nJustify your choice based on first principles, starting from the definitions of convex hull and orientation, the floating-point spacing model, and the algorithm’s rule that any non-left turn (orientation less than or equal to zero) triggers the removal of the most recent point from the working hull.", "solution": "The core of the problem lies in analyzing how single-precision floating-point arithmetic affects the computation of the orientation predicate. An error can arise from two main sources: input quantization and arithmetic error during calculation. The Andrew's monotone chain algorithm builds the convex hull by processing points sorted by x-coordinate. A failure occurs if an orientation test gives the wrong sign, causing a true hull vertex to be discarded.\n\nLet's analyze the single-precision floating-point model. The spacing between representable numbers (unit in the last place, or ulp) near a number $X = c \\cdot 2^e$ is $\\text{ulp}(X) = 2^{e-23}$. A number $X+d$ will be rounded to $X$ if $|d|  \\text{ulp}(X)/2$.\n\n**A. $M=2^{27}$. Points correspond to a square of side length $k=1$.**\n- **Input Quantization**: For $M = 2^{27}$, the exponent is $e=27$. The ulp is $\\text{ulp}(M) = 2^{27-23} = 2^4 = 16$.\n- The value to be added to $M$ is $1$. Since $|1|  \\text{ulp}(M)/2 = 8$, the number $M+1$ cannot be distinguished from $M$ in single precision. When rounding to the nearest representable number, `fl(M+1)` will be `M`.\n- Consequently, all four distinct vertices of the square—$(M, M), (M+1, M), (M, M+1), (M+1, M+1)$—are quantized to the same single point $(M, M)$ when stored in single-precision floats.\n- The algorithm will therefore be fed four identical points. The computed convex hull will be just that single point, failing to include three of the true vertices. Thus, this case causes a failure.\n\n**B. $M=2^{27}$. Points correspond to a square of side length $k=32$.**\n- **Input Quantization**: $M=2^{27}$ and $\\text{ulp}(M) = 16$. The increment is $k=32$. Since $32$ is an integer multiple of the ulp ($32 = 2 \\times 16$), the value $M+32$ is exactly representable in single precision. No input quantization error occurs.\n- **Arithmetic Error**: The algorithm will test orientations. For example, when building the lower hull, it might test the orientation of $( (M,M), (M,M+32), (M+32,M) )$. The exact orientation is $-(32^2) = -1024$. All intermediate subtractions (e.g., $(M+32)-M$) are exact due to Sterbenz's Lemma or because the numbers are adjacent representable floats. The products and final subtraction are also exact for these integer values. The computed orientation is correctly negative. No failure occurs.\n\n**C. $M=2^{20}$. Points correspond to a square of side length $k=1$.**\n- **Input Quantization**: For $M = 2^{20}$, the exponent is $e=20$. The ulp is $\\text{ulp}(M) = 2^{20-23} = 2^{-3} = 0.125$.\n- The increment is $k=1$. Since $1$ is much larger than $\\text{ulp}(M)/2 = 0.0625$, the value $M+1$ is exactly representable. No input quantization error occurs.\n- **Arithmetic Error**: Similar to case B, all intermediate and final calculations for the orientation test are exact. The computed orientation is correctly negative ($-1^2 = -1$). No failure occurs.\n\n**D. $M=2^{27}$. Points correspond to a square of side length $k=16$.**\n- **Input Quantization**: $M=2^{27}$ and $\\text{ulp}(M) = 16$. The increment is $k=16$. Since $k$ is exactly equal to the ulp, $M+16$ is the next representable single-precision number after $M$. It is stored exactly. No input quantization error occurs.\n- **Arithmetic Error**: The subtraction $(M+16)-M$ is exact. All subsequent calculations are also exact, yielding a correctly negative orientation of $-(16^2) = -256$. No failure occurs.\n\nIn summary, only option A leads to failure, and it does so at the very first step of representing the input coordinates due to catastrophic loss of precision. The small side length of the square is completely lost relative to the large magnitude of its coordinates.", "answer": "$$\\boxed{A}$$", "id": "3223470"}, {"introduction": "After grappling with the limits of numerical precision, we now turn to a powerful algorithmic paradigm for solving geometric problems: the plane sweep. This exercise [@problem_id:3223497] asks you to compute the area of the union of multiple rectangles, a classic problem with applications in fields like computer-aided design and geographic information systems. You will learn to transform a static two-dimensional problem into a dynamic one-dimensional one by sweeping a line across the plane, using a data structure to efficiently track the state of intersections along the sweep-line. This practice is essential for mastering a technique that is central to solving a wide array of problems in computational geometry.", "problem": "You are given a finite collection of axis-aligned rectangles in the Euclidean plane. Each rectangle is specified by four integers $(x_1, y_1, x_2, y_2)$ with $x_1 \\le x_2$ and $y_1 \\le y_2$, representing the lower-left corner $(x_1, y_1)$ and the upper-right corner $(x_2, y_2)$. A rectangle with $x_1 = x_2$ or $y_1 = y_2$ has zero area and does not contribute to the union area. The task is to compute the area of the union of these rectangles efficiently, using a plane sweep algorithm grounded in first principles from computational geometry.\n\nFundamental base and requirements:\n- The area of a union of sets in the plane is the two-dimensional Lebesgue measure of the union. For axis-aligned rectangles, the union area is finite and well-defined under the usual Euclidean metric.\n- Rectangles are closed sets, but the union area is invariant under any choice of closed, open, or half-open boundary conventions for axis-aligned rectangles, provided all rectangles use the same convention, because boundaries have measure zero.\n- A valid approach is to conceptually sweep a vertical line across the $x$-axis, maintaining the total length of the union of the currently active $y$-intervals. The area accumulated between two successive $x$-positions equals the horizontal distance times the covered $y$-length over that slab.\n\nYour program must implement an efficient plane sweep along the $x$-axis and maintain the union length of $y$-intervals using an appropriate data structure such as a Segment Tree (ST) with coordinate compression. The asymptotic time complexity target is $O(n \\log n)$ for $n$ rectangles. You must handle duplicates, nested rectangles, disjoint rectangles, touching edges, zero-area rectangles, negative coordinates, and large coordinate values without overflow beyond typical $64$-bit integer ranges.\n\nTest suite:\nCompute the union area for each of the following independent test cases. In each test case, the input is a list of rectangles given as $(x_1,y_1,x_2,y_2)$ quadruples.\n\n- Test case $1$: $\\big((0,0,3,2),(2,1,5,4),(1,3,4,5)\\big)$\n- Test case $2$: $\\big((0,0,2,1),(2,0,4,1)\\big)$\n- Test case $3$: $\\big((0,0,10,10),(2,2,8,8)\\big)$\n- Test case $4$: $\\big((0,0,1,1),(3,3,4,5)\\big)$\n- Test case $5$: $\\big((0,0,2,2),(1,1,1,5),(2,2,5,2)\\big)$\n- Test case $6$: $\\big((-3,-1,-1,2),(-2,1,1,3)\\big)$\n- Test case $7$: $\\big((0,0,100000000,1),(50000000,0,150000000,1)\\big)$\n- Test case $8$: $\\big((0,0,3,1),(0,1,3,2),(0,2,3,3),(1,-1,2,4)\\big)$\n\nOutput specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The $i$-th entry is the union area for test case $i$, expressed as an integer. For example, the format must be exactly like $\\texttt{[a_1,a_2,\\dots,a_8]}$, where $a_i$ denotes the computed area for test case $i$.", "solution": "The problem asks for the area of the union of several axis-aligned rectangles. A brute-force approach of creating a high-resolution grid and marking filled cells is too slow and memory-intensive, especially with large coordinates. The standard efficient solution is the plane sweep algorithm, which has a time complexity of $O(n \\log n)$ for $n$ rectangles.\n\n**1. Plane Sweep Principle:**\nWe sweep a vertical line (the sweep-line) from left to right across the plane. The area is accumulated during the sweep. The total area can be seen as a sum of areas of thin vertical strips. The area of a strip between two consecutive x-coordinates, $x_{prev}$ and $x_{curr}$, is $(x_{curr} - x_{prev}) \\times L$, where $L$ is the total length of the vertical segments on the sweep-line that are covered by rectangles. This length $L$ only changes at the x-coordinates corresponding to the left and right edges of the rectangles.\n\n**2. Events:**\nThe x-coordinates where the covered length $L$ might change are our \"events\". For each rectangle $(x_1, y_1, x_2, y_2)$, we create two events:\n- An \"enter\" event at $x_1$, corresponding to the left edge. This event adds the vertical interval $[y_1, y_2]$ to our set of active intervals.\n- A \"leave\" event at $x_2$, corresponding to the right edge. This event removes the interval $[y_1, y_2]$.\nWe collect all such events from all rectangles and sort them by their x-coordinate.\n\n**3. Data Structure for Active Intervals:**\nBetween two consecutive events, the set of active vertical intervals is constant. We need a data structure that can efficiently perform two operations:\n- Add/remove a vertical interval $[y_1, y_2]$.\n- Query the total length of the union of all currently active intervals.\n\nA Segment Tree is perfectly suited for this. We first perform coordinate compression on all unique y-coordinates from the input rectangles. This gives us a set of elementary y-intervals. The segment tree is built on these elementary intervals. Each node in the segment tree represents a range of these elementary y-intervals. In each node, we store a `count` (how many active rectangles cover this node's entire range) and a `length` (the length of the union of intervals within this node's range).\n\n- When an \"enter\" event for $[y_1, y_2]$ occurs, we increment the `count` for all nodes in the segment tree corresponding to the elementary intervals between $y_1$ and $y_2$.\n- When a \"leave\" event occurs, we decrement the `count`.\n- The total covered length $L$ on the sweep-line is simply the `length` value stored at the root of the segment tree. If a node's `count` is positive, its `length` is the full length of the y-range it represents. If its `count` is zero, its `length` is the sum of the lengths of its children.\n\n**4. Algorithm Execution:**\n1. Create a list of all vertical edges (events) from the rectangles.\n2. Create a sorted list of all unique y-coordinates and map them to indices for coordinate compression.\n3. Build a segment tree over the compressed y-intervals.\n4. Sort the events by x-coordinate.\n5. Initialize `total_area = 0` and `last_x = events[0].x`.\n6. Iterate through the sorted events:\n   - Let the current event be at `current_x`.\n   - Calculate the area of the strip: `area_strip = (current_x - last_x) * L`, where `L` is the covered length from the segment tree's root.\n   - Add this area to `total_area`.\n   - Update the segment tree based on the current event (add or remove its y-interval).\n   - Update `last_x = current_x`.\n\nThis process correctly calculates the total area by summing the areas of the vertical slabs between event points. The test cases are solved by applying this algorithm. For example, in Test Case 1, the sweep-line moves from x=0 to x=5, and the segment tree tracks the changing union of y-intervals [0,2], [1,4], and [3,5] as they enter and leave the active set. The large coordinates in Test Case 7 are handled naturally, as the area calculation uses differences between coordinates, and the final area can be stored in a 64-bit integer or Python's arbitrary-precision integer type.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the union area of rectangles problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        [(0, 0, 3, 2), (2, 1, 5, 4), (1, 3, 4, 5)],\n        # Test case 2\n        [(0, 0, 2, 1), (2, 0, 4, 1)],\n        # Test case 3\n        [(0, 0, 10, 10), (2, 2, 8, 8)],\n        # Test case 4\n        [(0, 0, 1, 1), (3, 3, 4, 5)],\n        # Test case 5\n        [(0, 0, 2, 2), (1, 1, 1, 5), (2, 2, 5, 2)],\n        # Test case 6\n        [(-3, -1, -1, 2), (-2, 1, 1, 3)],\n        # Test case 7\n        [(0, 0, 100000000, 1), (50000000, 0, 150000000, 1)],\n        # Test case 8\n        [(0, 0, 3, 1), (0, 1, 3, 2), (0, 2, 3, 3), (1, -1, 2, 4)],\n    ]\n\n    results = []\n    for rectangles in test_cases:\n        area = calculate_union_area(rectangles)\n        results.append(area)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_union_area(rectangles):\n    \"\"\"\n    Calculates the area of the union of a list of axis-aligned rectangles.\n    \n    This function implements a plane sweep algorithm with a segment tree.\n    \"\"\"\n    events = []\n    y_coords = set()\n\n    for x1, y1, x2, y2 in rectangles:\n        # Per the problem statement, zero-area rectangles do not contribute.\n        if x1  x2 and y1  y2:\n            events.append((x1, y1, y2, 1))  # 1 for enter\n            events.append((x2, y1, y2, -1)) # -1 for leave\n            y_coords.add(y1)\n            y_coords.add(y2)\n\n    if not events:\n        return 0\n\n    # Sort events by x-coordinate\n    events.sort()\n\n    # Coordinate compression for y-coordinates\n    all_y = sorted(list(y_coords))\n    y_map = {y: i for i, y in enumerate(all_y)}\n    \n    num_y_intervals = len(all_y) - 1\n    if num_y_intervals = 0:\n        return 0\n\n    # Segment tree represented by numpy arrays.\n    # The size 4 * num_y_intervals is a safe upper bound for a segment tree.\n    counts = np.zeros(4 * num_y_intervals, dtype=int)\n    lengths = np.zeros(4 * num_y_intervals, dtype=np.int64)\n\n\n    def update_segment_tree(node_idx, node_start, node_end, update_start, update_end, value):\n        \"\"\"Recursively update the segment tree.\"\"\"\n        # The range this node represents is [node_start, node_end].\n        # The range to update is [update_start, update_end].\n\n        # If the update range is outside the node's range, do nothing.\n        if update_start > node_end or update_end  node_start:\n            return\n\n        # If the node's range is completely within the update range.\n        if update_start = node_start and node_end = update_end:\n            counts[node_idx] += value\n        # Otherwise, recurse on children.\n        else:\n            mid = (node_start + node_end) // 2\n            left_child_idx = 2 * node_idx + 1\n            right_child_idx = 2 * node_idx + 2\n            update_segment_tree(left_child_idx, node_start, mid, update_start, update_end, value)\n            update_segment_tree(right_child_idx, mid + 1, node_end, update_start, update_end, value)\n        \n        # After updating counts, recalculate the covered length for this node.\n        if counts[node_idx] > 0:\n            # This node's entire y-interval range is covered.\n            lengths[node_idx] = all_y[node_end + 1] - all_y[node_start]\n        elif node_start == node_end:\n            # Leaf node with count 0 has 0 covered length.\n            lengths[node_idx] = 0\n        else:\n            # Internal node with count 0: covered length is sum of children's.\n            left_child_idx = 2 * node_idx + 1\n            right_child_idx = 2 * node_idx + 2\n            lengths[node_idx] = lengths[left_child_idx] + lengths[right_child_idx]\n\n\n    total_area = 0\n    last_x = events[0][0]\n\n    for event in events:\n        current_x, y1, y2, type_val = event\n        \n        # Calculate the area of the slab between last_x and current_x\n        dx = current_x - last_x\n        if dx > 0:\n            covered_length = lengths[0]  # Root of the segment tree\n            total_area += covered_length * dx\n        \n        # Process the current event by updating the segment tree\n        y1_idx = y_map[y1]\n        y2_idx = y_map[y2]\n\n        # The update is for the range of intervals [y1_idx, y2_idx - 1]\n        if y1_idx  y2_idx:\n            update_segment_tree(0, 0, num_y_intervals - 1, y1_idx, y2_idx - 1, type_val)\n\n        last_x = current_x\n        \n    return total_area\n\n# Execute the solution\nsolve()\n\n```", "id": "3223497"}, {"introduction": "This practice introduces one of the most fundamental and beautiful structures in computational geometry: the Voronoi diagram. A Voronoi diagram partitions a plane into regions based on the closest point in a given set of sites. To make the concept clear and accessible, this exercise [@problem_id:3223457] asks you to construct a Voronoi diagram on a discrete grid using the Manhattan ($L_1$) distance, a common metric in grid-based environments like city blocks or circuit boards. By building this structure from first principles, you will gain a solid intuition for how proximity partitions space, a concept with profound implications in fields ranging from biology to robotics.", "problem": "You are given a finite set of sites in the plane, each with integer coordinates, and a rectangular domain with integer endpoints. For a given Manhattan (also called $L_1$) distance, the restricted Voronoi cell of a site is the subset of the domain consisting of all points that are closer to that site than to any other site, with ties handled deterministically. Your task is to compute, for several test cases, the discrete $L_1$ Voronoi diagram restricted to the integer lattice points of the rectangular domain and report the number of lattice points assigned to each site.\n\nDefinitions and assumptions:\n- The Manhattan distance between two points $(x,y)$ and $(a,b)$ is $d_1\\big((x,y),(a,b)\\big) = |x-a| + |y-b|$.\n- Given a set of sites $S = \\{p_1, p_2, \\dots, p_k\\}$, where $p_i = (x_i, y_i)$, and a rectangular domain $R = [x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$, the discrete restricted Voronoi cell of $p_i$ is\n$$\nV_R(p_i) = \\left\\{(x,y) \\in \\mathbb{Z}^2 : x_{\\min} \\le x \\le x_{\\max},\\ y_{\\min} \\le y \\le y_{\\max},\\ d_1\\big((x,y),p_i\\big) \\le d_1\\big((x,y),p_j\\big)\\ \\text{for all}\\ j \\in \\{1,\\dots,k\\}\\right\\}.\n$$\n- Ties are broken by the smallest site index: if $(x,y)$ yields $d_1\\big((x,y),p_i\\big) = d_1\\big((x,y),p_j\\big)$ for multiple $i$, then $(x,y)$ is assigned to the site with the smallest index among those minimizers.\n- All coordinates are integers; there are no physical units involved.\n\nYour program must implement the following from first principles:\n- For each test case, iterate over all integer lattice points in $R$ and assign each point to exactly one site according to the Manhattan distance rule and the tie-breaking rule.\n- For each test case, output a list of integers of length $k$, where the $i$-th integer is the number of lattice points assigned to site $p_i$.\n\nTest suite (each case consists of a domain and a list of sites in the specified order):\n- Case $1$: $R = [0,8] \\times [0,8]$, $S = \\{(1,1),(6,2),(5,7)\\}$.\n- Case $2$: $R = [0,6] \\times [0,6]$, $S = \\{(2,2),(4,4),(6,2)\\}$.\n- Case $3$: $R = [0,6] \\times [0,6]$, $S = \\{(3,3)\\}$.\n- Case $4$: $R = [0,5] \\times [0,5]$, $S = \\{(-1,2),(7,2),(2,-1),(2,7)\\}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The top-level list has one inner list per test case, in the same order as above, and each inner list contains the site counts in the order the sites are given for that case. For example, a valid output string with two cases would look like $[[a_1,a_2],[b_1,b_2,b_3]]$ with no spaces.\n- There must be no additional text printed.\n\nConstraints and expectations:\n- Use the fundamental definitions of distance and Voronoi cells to justify your approach. Avoid shortcut formulas or relying on external specialized computational geometry routines.\n- Your algorithm must operate on the integer lattice points within the given rectangle and abide by the deterministic tie-breaking rule.\n- The answer for each test case is a list of integers. The aggregated single-line output is a list of these lists.", "solution": "The problem requires a direct implementation of the definition for a discrete, restricted Voronoi diagram using the Manhattan ($L_1$) distance. The core principle is to partition the integer lattice points within the given rectangular domain $R$ based on proximity to a set of sites $S$. The problem is well-defined because the domain is a finite set of points, the distance metric is specified, and the tie-breaking rule is deterministic, ensuring every point is assigned to exactly one site.\n\nThe most straightforward algorithm, which directly follows from the definition, is as follows:\n1.  For each test case, initialize a list of counters, one for each site, to zero. These will store the area (number of points) of each Voronoi cell.\n2.  Iterate through every integer point $(x,y)$ within the specified rectangular domain $R$.\n3.  For each point $(x,y)$, calculate its Manhattan distance to every site in the set $S$.\n4.  Find the minimum of these calculated distances.\n5.  Identify the site (or sites) that achieve this minimum distance.\n6.  Apply the tie-breaking rule: if multiple sites are at the same minimum distance, choose the one that appears earliest in the input list of sites (i.e., the one with the smallest index).\n7.  Increment the counter corresponding to this \"winning\" site.\n8.  After iterating through all points in the domain, the list of counters will contain the final area for each site's Voronoi cell.\n\nThis brute-force enumeration is computationally simple and directly mirrors the mathematical definition. For a more efficient implementation, especially in a language with strong support for array operations like Python with NumPy, this process can be vectorized. One can construct a grid of coordinates for the entire domain and then compute a distance matrix for each site across the entire grid simultaneously. Stacking these distance matrices allows for finding the index of the minimum distance for all grid points in a single `argmin` operation, which naturally implements the specified tie-breaking rule. The final counts can then be obtained by counting the occurrences of each site index in the resulting assignment matrix.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the number of lattice points in a restricted discrete L1 Voronoi diagram\n    for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (domain, list_of_sites)\n    # Domain is a tuple: (x_min, x_max, y_min, y_max)\n    # Sites are given as a list of (x, y) tuples.\n    test_cases = [\n        # Case 1\n        (((0, 8), (0, 8)), [(1, 1), (6, 2), (5, 7)]),\n        # Case 2\n        (((0, 6), (0, 6)), [(2, 2), (4, 4), (6, 2)]),\n        # Case 3\n        (((0, 6), (0, 6)), [(3, 3)]),\n        # Case 4\n        (((0, 5), (0, 5)), [(-1, 2), (7, 2), (2, -1), (2, 7)]),\n    ]\n\n    all_results = []\n    for domain_spec, sites_list in test_cases:\n        (x_min, x_max), (y_min, y_max) = domain_spec\n        sites = np.array(sites_list, dtype=np.int32)\n        num_sites = len(sites)\n\n        # Create the integer lattice grid for the domain\n        x_range = np.arange(x_min, x_max + 1)\n        y_range = np.arange(y_min, y_max + 1)\n        grid_x, grid_y = np.meshgrid(x_range, y_range)\n\n        # A list to hold the distance matrix for each site\n        all_dists = []\n\n        # For each site, calculate the L1 distance to every point in the grid\n        for site in sites:\n            site_x, site_y = site\n            dist_matrix = np.abs(grid_x - site_x) + np.abs(grid_y - site_y)\n            all_dists.append(dist_matrix)\n\n        # Stack the distance matrices into a 3D array (num_sites, height, width)\n        dist_stack = np.stack(all_dists, axis=0)\n\n        # Find the index of the site with the minimum distance for each grid point.\n        # np.argmin naturally handles the tie-breaking rule by returning the\n        # index of the first occurrence of the minimum value.\n        assignments = np.argmin(dist_stack, axis=0)\n\n        # Count the number of points assigned to each site.\n        # .flatten() turns the 2D assignment matrix into a 1D array.\n        # minlength ensures that even sites with 0 points are included in the count.\n        counts = np.bincount(assignments.flatten(), minlength=num_sites)\n        \n        all_results.append(counts.tolist())\n\n    # Final print statement in the exact required format: [[...],[...]]\n    # str() on a list adds spaces, so we remove them.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3223457"}]}