{"hands_on_practices": [{"introduction": "Many geometric algorithms, including the classic Graham Scan, rely on sorting points by their angle around a central pivot. A naive approach using trigonometric functions like `arctan` is often slow and susceptible to floating-point precision errors. This exercise guides you through implementing a robust and efficient angle comparison function using only integer arithmetic, a cornerstone of reliable computational geometry. By mastering the use of the cross product to determine orientation, you will build a foundational skill for developing correct and high-performance geometric software. [@problem_id:3224274]", "problem": "You are given finite sets of points in the two-dimensional plane, each set represented by integer coordinate pairs. The goal is to implement the angle-sorting step used by the Graham Scan convex hull algorithm for each set, subject to strict constraints: Do not use any trigonometric functions, do not use any floating-point division, and rely only on integer arithmetic and cross products to compare angles. The sorting must be defined with respect to a pivot point chosen deterministically from the set. The final program must produce a single line of output encoding the sorted orders for all provided test cases.\n\nFundamental base definitions to use:\n- A point is a pair of integers $(x, y)$ representing a location on the plane.\n- Given points $\\mathbf{a} = (x_a, y_a)$ and $\\mathbf{b} = (x_b, y_b)$, and a pivot $\\mathbf{p} = (x_p, y_p)$, define translated vectors $\\mathbf{u} = \\mathbf{a} - \\mathbf{p} = (x_a - x_p, y_a - y_p)$ and $\\mathbf{v} = \\mathbf{b} - \\mathbf{p} = (x_b - x_p, y_b - y_p)$.\n- The cross product (signed area of the parallelogram spanned by $\\mathbf{u}$ and $\\mathbf{v}$) is given by $\\mathbf{u} \\times \\mathbf{v} = (x_a - x_p)(y_b - y_p) - (y_a - y_p)(x_b - x_p)$, which is an integer when coordinates are integers.\n- The Euclidean distance squared from $\\mathbf{p}$ to $\\mathbf{a}$ is $d^2(\\mathbf{p}, \\mathbf{a}) = (x_a - x_p)^2 + (y_a - y_p)^2$, which is an integer when coordinates are integers.\n\nRequired angle-sorting behavior:\n- Choose the pivot $\\mathbf{p}$ as the point with minimal $y$-coordinate; in case of ties, choose among those the one with minimal $x$-coordinate.\n- Exclude the pivot from the sorting.\n- Sort all remaining points by their polar angle around $\\mathbf{p}$ in counterclockwise order starting from the positive $x$-axis. For two points $\\mathbf{a}$ and $\\mathbf{b}$, this ordering must be determined entirely using integer comparisons and the cross product $\\mathbf{u} \\times \\mathbf{v}$ of their translated vectors $\\mathbf{u}$ and $\\mathbf{v}$ relative to $\\mathbf{p}$. You must determine which vector lies earlier by angle using only:\n  - The half-plane classification relative to the positive $x$-axis: a vector $\\mathbf{w} = (x_w, y_w)$ lies in the upper half-plane if $y_w  0$ or ($y_w = 0$ and $x_w  0$), otherwise it lies in the lower half-plane.\n  - The sign of the cross product $\\mathbf{u} \\times \\mathbf{v}$. If the two vectors lie in the same half-plane and $\\mathbf{u} \\times \\mathbf{v}  0$, then $\\mathbf{u}$ has smaller angle than $\\mathbf{v}$; if $\\mathbf{u} \\times \\mathbf{v}  0$, then $\\mathbf{v}$ has smaller angle than $\\mathbf{u}$.\n- In case of colinearity relative to $\\mathbf{p}$, where $\\mathbf{u} \\times \\mathbf{v} = 0$, break ties by increasing Euclidean distance squared $d^2(\\mathbf{p}, \\cdot)$, placing the nearer point first.\n\nIndices and output:\n- Index points in each input set from $0$ to $n-1$ in the given order.\n- For each test case, output the list of indices of points sorted by the rule above, excluding the pivot’s index.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each per-case result itself being a comma-separated list enclosed in square brackets. For example, the final output format must be like $[[i_{0,0},i_{0,1},\\dots],[i_{1,0},i_{1,1},\\dots],\\dots]$, with no spaces.\n\nTest suite:\n- Test case $1$: Points $[(0,0),(2,1),(1,2),(-1,1),(-2,0),(-1,-1),(1,-2),(2,-1),(0,2),(0,-2)]$.\n- Test case $2$: Points $[(-3,0),(-1,0),(0,0),(2,0),(5,0)]$.\n- Test case $3$: Points $[(1,1),(2,2),(2,2),(3,3),(0,0)]$.\n- Test case $4$: Points $[(4,0),(0,4),(-4,0),(0,-4),(1,-3),(2,-2),(-2,-2),(-1,-3),(3,3),(-3,3)]$.\n\nAnswer specification:\n- For each test case, produce a list of integers corresponding to the indices sorted by the required angle order with respect to its pivot.\n- The final answer must be a program that prints the single line described above and performs only integer computations without any trigonometric functions or floating-point division.", "solution": "The user-provided problem is a well-posed task in computational geometry, specifically related to the sorting phase of the Graham Scan algorithm for finding a convex hull. The problem is algorithmically sound, self-contained, and provides all necessary definitions and constraints for a unique solution. The core challenge is to sort a set of points by their polar angle with respect to a pivot, using only integer arithmetic. This is accomplished by leveraging the geometric properties of the cross product and squared Euclidean distance, thereby avoiding the use of trigonometric functions and floating-point computations.\n\nThe solution proceeds in a sequence of logical steps for each given test case:\n\n**1. Pivot Point Identification**\n\nFirst, a pivot point $\\mathbf{p}$ must be deterministically selected from the input set of points. The problem specifies a clear rule: the pivot is the point with the minimum $y$-coordinate. In the event of a tie, the point among those with the minimum $x$-coordinate is chosen. If a set of points is denoted by $S = \\{\\mathbf{p}_0, \\mathbf{p}_1, \\dots, \\mathbf{p}_{n-1}\\}$, where each $\\mathbf{p}_i = (x_i, y_i)$, the pivot $\\mathbf{p} = (x_p, y_p)$ is the point such that for any other point $\\mathbf{p}_j = (x_j, y_j)$ in $S$, either $y_p  y_j$ or ($y_p = y_j$ and $x_p  x_j$). This guarantees a unique pivot for any non-empty set of points. The pivot itself is excluded from the sorting process.\n\n**2. The Comparison Function for Sorting**\n\nThe fundamental task is to establish a total ordering on the remaining points based on their polar angle relative to the pivot $\\mathbf{p}$. This requires a comparison function that, for any two points $\\mathbf{a}$ and $\\mathbf{b}$, determines which one has a smaller polar angle in a counter-clockwise direction starting from the ray parallel to the positive $x$-axis originating from $\\mathbf{p}$. This comparison is implemented using exclusively integer arithmetic.\n\nLet $\\mathbf{a} = (x_a, y_a)$ and $\\mathbf{b} = (x_b, y_b)$ be two points to compare, and let the pivot be $\\mathbf{p} = (x_p, y_p)$. We define their corresponding translated vectors as $\\mathbf{u} = \\mathbf{a} - \\mathbf{p} = (x_a - x_p, y_a - y_p) = (u_x, u_y)$ and $\\mathbf{v} = \\mathbf{b} - \\mathbf{p} = (x_b - x_p, y_b - y_p) = (v_x, v_y)$. The comparison logic is as follows:\n\n**2.1. Half-Plane Classification**\nThe plane is divided into two half-planes relative to the pivot $\\mathbf{p}$ to handle angles spanning across $\\pi$ radians (or $180^\\circ$). The \"upper\" half-plane contains vectors whose angles are in the range $[0, \\pi)$, and the \"lower\" half-plane contains those with angles in $[\\pi, 2\\pi)$.\nA vector $\\mathbf{w} = (w_x, w_y)$ is in the upper half-plane if $w_y  0$, or if $w_y = 0$ and $w_x  0$. The condition $w_x \\ge 0$ is specified, but since the pivot is excluded from sorting, the translated vector $\\mathbf{w}$ cannot be the zero vector $(0,0)$, so for $w_y=0$, $w_x$ must be non-zero.\n- If vector $\\mathbf{u}$ is in the upper half-plane and $\\mathbf{v}$ is in the lower, $\\mathbf{u}$ has a smaller polar angle.\n- If vector $\\mathbf{v}$ is in the upper half-plane and $\\mathbf{u}$ is in the lower, $\\mathbf{v}$ has a smaller polar angle.\n\n**2.2. Cross Product for Angle Comparison**\nIf both vectors $\\mathbf{u}$ and $\\mathbf{v}$ lie in the same half-plane, their relative angular order is determined by the sign of their $2$D cross product. The cross product is defined as $\\mathbf{u} \\times \\mathbf{v} = u_x v_y - u_y v_x$.\n- If $\\mathbf{u} \\times \\mathbf{v}  0$, the turn from $\\mathbf{u}$ to $\\mathbf{v}$ is counter-clockwise, meaning the angle of $\\mathbf{u}$ is smaller than the angle of $\\mathbf{v}$.\n- If $\\mathbf{u} \\times \\mathbf{v}  0$, the turn is clockwise, meaning the angle of $\\mathbf{v}$ is smaller than the angle of $\\mathbf{u}$.\n\n**2.3. Tie-Breaking for Colinear Points**\nIf the cross product $\\mathbf{u} \\times \\mathbf{v} = 0$, the points $\\mathbf{a}$ and $\\mathbf{b}$ are colinear with the pivot $\\mathbf{p}$. The tie is broken by sorting based on their distance from the pivot. To avoid using square roots and floating-point numbers, we compare their squared Euclidean distances.\nThe squared distance from $\\mathbf{p}$ to $\\mathbf{a}$ is $d^2(\\mathbf{p}, \\mathbf{a}) = u_x^2 + u_y^2$.\n- If $d^2(\\mathbf{p}, \\mathbf{a})  d^2(\\mathbf{p}, \\mathbf{b})$, point $\\mathbf{a}$ is closer and thus comes first in the sorted order.\n- If $d^2(\\mathbf{p}, \\mathbf{a})  d^2(\\mathbf{p}, \\mathbf{b})$, point $\\mathbf{b}$ is closer and comes first.\nIf the squared distances are also equal (and the points are colinear), the points are identical. Their relative order is maintained as per the stability of the sorting algorithm.\n\n**3. Algorithmic Implementation**\n\nThe overall algorithm for each test case is:\n1.  Enumerate the input points with their original indices from $0$ to $n-1$.\n2.  Find the pivot $\\mathbf{p}$ and its index.\n3.  Create a list of all other points, each stored as a tuple containing the point's coordinates and its original index.\n4.  Sort this list using a standard sorting algorithm. The sorting key must be a custom comparison function that rigorously implements the logic described in step $2$. In Python, this is conveniently done using `functools.cmp_to_key`.\n5.  After sorting, extract the original indices from the sorted list of points.\n6.  Collect the resulting list of indices for each test case and format them into the specified single-line string output.\n\nThis procedure yields a correctly sorted list of point indices according to the specified rules, fulfilling all requirements of the problem statement.", "answer": "```python\nimport sys\nfrom functools import cmp_to_key\n\ndef solve():\n    \"\"\"\n    Solves the angle-sorting problem for the given test cases using only\n    integer arithmetic as specified.\n    \"\"\"\n    test_cases = [\n        [(0,0),(2,1),(1,2),(-1,1),(-2,0),(-1,-1),(1,-2),(2,-1),(0,2),(0,-2)],\n        [(-3,0),(-1,0),(0,0),(2,0),(5,0)],\n        [(1,1),(2,2),(2,2),(3,3),(0,0)],\n        [(4,0),(0,4),(-4,0),(0,-4),(1,-3),(2,-2),(-2,-2),(-1,-3),(3,3),(-3,3)],\n    ]\n\n    all_results = []\n\n    for points in test_cases:\n        # 1. Find the pivot point (min y, then min x).\n        min_y = sys.maxsize\n        min_x_at_min_y = sys.maxsize\n        pivot_idx = -1\n        \n        for i, (x, y) in enumerate(points):\n            if y  min_y:\n                min_y = y\n                min_x_at_min_y = x\n                pivot_idx = i\n            elif y == min_y:\n                if x  min_x_at_min_y:\n                    min_x_at_min_y = x\n                    pivot_idx = i\n        \n        pivot_point = points[pivot_idx]\n\n        # 2. Collect points to be sorted (all except the pivot)\n        # along with their original indices.\n        points_to_sort = []\n        for i, p in enumerate(points):\n            if i != pivot_idx:\n                points_to_sort.append((p, i))\n\n        # 3. Define the comparison function based on the problem rules.\n        def compare_points(item1, item2):\n            \"\"\"\n            Compares two points based on their polar angle relative to the pivot.\n            Returns -1 if item1  item2, 1 if item1 > item2, 0 if equal.\n            \"\"\"\n            p1 = item1[0]\n            p2 = item2[0]\n\n            # Translate points to vectors relative to the pivot\n            u_x, u_y = p1[0] - pivot_point[0], p1[1] - pivot_point[1]\n            v_x, v_y = p2[0] - pivot_point[0], p2[1] - pivot_point[1]\n\n            # Half-plane classification\n            is_upper_u = (u_y > 0) or (u_y == 0 and u_x > 0)\n            is_upper_v = (v_y > 0) or (v_y == 0 and v_x > 0)\n\n            if is_upper_u != is_upper_v:\n                return -1 if is_upper_u else 1\n\n            # Both in the same half-plane, use cross product\n            cross_product = u_x * v_y - u_y * v_x\n            if cross_product != 0:\n                return -1 if cross_product > 0 else 1\n\n            # Collinear, use squared Euclidean distance for tie-breaking\n            dist_sq_u = u_x**2 + u_y**2\n            dist_sq_v = v_x**2 + v_y**2\n            \n            if dist_sq_u  dist_sq_v:\n                return -1\n            elif dist_sq_u > dist_sq_v:\n                return 1\n            \n            return 0\n\n\n        # 4. Sort the points using the custom comparator.\n        points_to_sort.sort(key=cmp_to_key(compare_points))\n\n        # 5. Extract the original indices of the sorted points.\n        sorted_indices = [item[1] for item in points_to_sort]\n        all_results.append(sorted_indices)\n\n    # 6. Format the final output string.\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, r))}]' for r in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3224274"}, {"introduction": "With a solid understanding of geometric predicates, you are ready to construct a complete convex hull algorithm from first principles. This practice focuses on implementing the Monotone Chain algorithm (also known as Andrew's algorithm), an elegant and efficient method that cleverly avoids angular computations entirely. You will begin by sorting the points lexicographically and then construct the upper and lower chains of the hull in two distinct passes, using the orientation test at each step to maintain the convexity invariant. This hands-on implementation will deepen your problem-solving skills by requiring you to translate geometric theory into robust code that correctly handles edge cases like collinear points. [@problem_id:3205841]", "problem": "You are to design, specify, and implement, in code, a function that computes the convex hull of a finite set of two-dimensional points using the Monotone Chain algorithm. The foundational base for your reasoning must begin with the following: the definition of convexity in the plane $\\mathbb{R}^2$, the definition of the convex hull of a finite set as the smallest convex set containing it, the notion of a lexicographic order on pairs $(x,y)$, and the concept of orientation of triples of points as a criterion for maintaining convexity during incremental construction. Do not use any shortcut formulas or pre-given algorithmic templates; instead, derive the algorithmic steps you will specify from these fundamental definitions and facts. Your specification must be a clear pseudo-code function with a precise contract and must be implementable directly.\n\nGiven a finite set $P \\subset \\mathbb{R}^2$ with integer coordinates, define a pseudo-code function that, for input $P$, returns the vertices of the convex hull polygon ordered counterclockwise, starting from the lexicographically smallest point (ordered first by $x$ and then by $y$), with duplicate points removed and with strictly interior collinear points excluded from the returned vertex list. The returned polygon must not repeat the first vertex at the end. If the input has fewer than $2$ distinct points, return the input set of distinct points ordered lexicographically. If all points are collinear, return only the two extreme endpoints in lexicographic order.\n\nYour final program should implement your pseudo-code and run against the following explicit test suite of point sets. Each test case is a list of points written as ordered pairs, and each coordinate pair is provided in mathematical notation. The angle unit is not applicable in this problem. There are no physical units. The required output type for each test case is a list of lists of integers.\n\nTest suite:\n- Test case $1$ (general case with interior points): $[(0,0),(2,0),(2,2),(0,2),(1,1)]$\n- Test case $2$ (empty set): $[]$\n- Test case $3$ (single point): $[(5,5)]$\n- Test case $4$ (collinear points with duplicates): $[(0,0),(1,1),(2,2),(3,3),(1,1),(2,2)]$\n- Test case $5$ (all points on the boundary with boundary collinear points included): $[(0,0),(3,0),(3,3),(0,3),(1,0),(2,0),(3,1),(3,2),(2,3),(1,3),(0,2),(0,1)]$\n- Test case $6$ (two identical points): $[(7,7),(7,7)]$\n- Test case $7$ (diamond with interior points and negative coordinates): $[(-2,0),(0,2),(2,0),(0,-2),(-1,0),(0,1),(1,0),(0,-1)]$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be the convex hull of the corresponding input, represented as a list of points, where each point is a two-integer list $[x,y]$, and the hull is ordered counterclockwise starting from the lexicographically smallest vertex. For example, an output for three cases might look like $[[x_1,y_1],[x_2,y_2]],[[u_1,v_1],[u_2,v_2],[u_3,v_3]],[]$ aggregated as a single list: $[[[x_1,y_1],[x_2,y_2]],[[u_1,v_1],[u_2,v_2],[u_3,v_3]],[]]$.\n- Your program must be completely self-contained and must not read any input; it must use the test suite above exactly as provided.", "solution": "The user requires the design and implementation of the Monotone Chain algorithm for computing the convex hull of a set of 2D points. The derivation must be based on first principles: convexity, the definition of a convex hull, lexicographic ordering, and the orientation of point triples.\n\n### Step 1: Problem Validation\n\n**1.1. Extract Givens**\n\n*   **Input**: A finite set of two-dimensional points $P \\subset \\mathbb{R}^2$ with integer coordinates.\n*   **Algorithm**: Monotone Chain.\n*   **Fundamental Concepts**:\n    *   Definition of convexity in $\\mathbb{R}^2$.\n    *   Definition of the convex hull of a finite set.\n    *   Lexicographic order on pairs $(x,y)$.\n    *   Orientation of triples of points.\n*   **Output Constraints**:\n    *   Return a list of vertices of the convex hull polygon.\n    *   The vertices must be ordered counter-clockwise.\n    *   The ordering must start from the lexicographically smallest point.\n    *   Duplicate input points must be removed.\n    *   Strictly interior collinear points on an edge must be excluded.\n    *   The returned polygon must not repeat the start vertex at the end.\n*   **Edge Cases**:\n    *   If there are fewer than $2$ distinct points, return the distinct points ordered lexicographically.\n    *   If all points are collinear, return only the two extreme endpoints in lexicographic order.\n*   **Test Suite**: Seven specific test cases are provided.\n*   **Final Output Format**: A single line representing a list of the results for the test suite, where each result is a list of points (each point being a two-integer list).\n\n**1.2. Validate Using Extracted Givens**\n\n*   **Scientifically Grounded**: The problem is a standard, well-established problem in computational geometry. All concepts (convex hull, Monotone Chain algorithm, lexicographic order, orientation test) are fundamental and mathematically sound.\n*   **Well-Posed**: The problem is well-posed. The input is defined, the desired output is precisely specified, and the constraints (ordering, handling of collinear points) are clear. A unique solution exists for any given finite set of points.\n*   **Objective**: The problem is stated in precise, objective mathematical language. There are no subjective or ambiguous terms.\n*   **Completeness**: The problem provides all necessary information, including the algorithm to be used, foundational principles for derivation, and a comprehensive test suite. The constraints, such as how to handle collinear points and small inputs, are explicitly defined, removing ambiguity.\n\n**1.3. Verdict and Action**\n\nThe problem is deemed **valid**. It is a formal, self-contained, and well-posed problem from the field of data structures and algorithms. I will proceed with a principled derivation and solution.\n\n### Step 2: Principled Derivation and Algorithm Specification\n\n**2.1. Foundational Principles**\n\n1.  **Convexity**: A set $S \\subset \\mathbb{R}^2$ is convex if for any two points $p_1, p_2 \\in S$, the line segment connecting them is entirely contained within $S$.\n2.  **Convex Hull**: The convex hull of a finite set of points $P$, denoted $CH(P)$, is the smallest convex set that contains all points in $P$. For a finite set, $CH(P)$ is a convex polygon whose vertices are a subset of $P$.\n3.  **Lexicographic Order**: For two points $p_1 = (x_1, y_1)$ and $p_2 = (x_2, y_2)$, we say $p_1$ is lexicographically smaller than $p_2$, denoted $p_1  p_2$, if and only if $(x_1  x_2)$ or $(x_1 = x_2 \\text{ and } y_1  y_2)$. This total ordering allows us to uniquely sort all points. The lexicographically smallest and largest points are guaranteed to be vertices of the convex hull.\n4.  **Orientation Test**: The orientation of an ordered triple of points $(p_1, p_2, p_3)$ determines whether the path from $p_1$ to $p_2$ to $p_3$ constitutes a \"left turn\" (counter-clockwise, CCW), a \"right turn\" (clockwise, CW), or if the points are collinear. This can be computed using the 2D cross product of the vectors $\\vec{p_1p_2}$ and $\\vec{p_1p_3}$. Let $p_1=(x_1,y_1)$, $p_2=(x_2,y_2)$, and $p_3=(x_3,y_3)$. The orientation value $O$ is:\n    $$O(p_1, p_2, p_3) = (x_2 - x_1)(y_3 - y_1) - (y_2 - y_1)(x_3 - x_1)$$\n    *   $O  0$: Counter-clockwise (left turn).\n    *   $O  0$: Clockwise (right turn).\n    *   $O = 0$: Collinear.\n\n**2.2. Derivation of the Monotone Chain Algorithm**\n\nThe core idea of the Monotone Chain algorithm is to construct the convex hull by building its upper and lower boundaries (chains) separately.\n\n1.  **Sorting**: The first step is to sort the set of unique points $P$ lexicographically. This arranges the points from left to right, breaking ties by moving from bottom to top. Let the sorted points be $p_1, p_2, \\ldots, p_n$. The points $p_1$ and $p_n$ are the absolute \"leftmost\" and \"rightmost\" points and must be on the hull.\n\n2.  **Hull Construction**: The convex hull is a polygon whose vertices are ordered counter-clockwise. As we traverse the perimeter of a convex polygon in CCW order, every turn we make at a vertex must be a \"left turn\". This is the key insight for building the hull.\n\n3.  **Lower and Upper Hulls**: We can decompose the CCW path of the hull into two sections:\n    *   The **lower hull**, which is the path from $p_1$ to $p_n$ along the \"bottom\" of the point set.\n    *   The **upper hull**, which is the path from $p_n$ back to $p_1$ along the \"top\" of the point set.\n\n4.  **Incremental Construction**: We will use a stack-based approach to build each hull. We iterate through the sorted points and maintain a list (the \"chain\") of points that currently form a convex path. When considering a new point, we check if adding it maintains convexity.\n    *   Let the current chain be a list of points, and we are considering adding a new point $p_i$. Let the last two points on the chain be $p_{last-1}$ and $p_{last}$. The triple $(p_{last-1}, p_{last}, p_i)$ must form a left turn to maintain the CCW convexity of the overall polygon.\n    *   If the orientation $O(p_{last-1}, p_{last}, p_i)$ is a right turn ($O  0$), it means the point $p_{last}$ creates a concavity and cannot be on the hull. Thus, we must pop $p_{last}$ from our chain and repeat the check.\n    *   If the orientation is collinear ($O = 0$), the point $p_{last}$ is a \"strictly interior collinear point\" on the segment from $p_{last-1}$ to $p_i$. The problem specifies that such points must be excluded. Therefore, we also pop $p_{last}$ in this case.\n    *   The condition to pop the last point from the chain is thus $O(p_{last-1}, p_{last}, p_i) \\leq 0$. We continue popping until this condition is false or the chain has fewer than two points. Then, we add the new point $p_i$ to the chain.\n\n5.  **Building Both Hulls**:\n    *   To build the **lower hull**, we iterate through the sorted points from $p_1$ to $p_n$, applying the logic above. This produces the lower chain of the hull, ordered from left to right.\n    *   To build the **upper hull**, we can apply the exact same logic but iterate through the points in reverse order, from $p_n$ down to $p_1$. This produces the upper chain, ordered from right to left.\n\n6.  **Combining Hulls**: The final convex hull is the concatenation of the lower and upper hulls. The lower hull contains vertices from $p_1$ to $p_n$. The upper hull contains vertices from $p_n$ back to $p_1$. To avoid duplicating the endpoints $p_1$ and $p_n$, we concatenate the lower hull (excluding its last point, $p_n$) and the upper hull (excluding its last point, $p_1$).\n\n**2.3. Pseudo-code**\n\n`FUNCTION MonotoneChain(Points):`\n    `// Input: A list of 2D points, P.`\n    `// Output: A list of points forming the convex hull, ordered CCW.`\n\n    `// Step 0: Preprocessing and edge cases`\n    `1. unique_points = Remove duplicate points from Points.`\n    `2. n = number of unique_points.`\n    `3. IF n  3:`\n    `4.   Sort unique_points lexicographically.`\n    `5.   RETURN unique_points.`\n    `6. Sort unique_points lexicographically. Let them be p_1, p_2, ..., p_n.`\n\n    `// Helper function for orientation`\n    `FUNCTION orientation(p1, p2, p3):`\n    `  RETURN (p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x)`\n\n    `// Step 1: Build the lower hull`\n    `7. lower_hull = []`\n    `8. FOR each point p_i in p_1, ..., p_n:`\n    `9.   WHILE length of lower_hull = 2 AND orientation(lower_hull[-2], lower_hull[-1], p_i) = 0:`\n    `10.    Pop last point from lower_hull.`\n    `11.  Push p_i onto lower_hull.`\n\n    `// Step 2: Build the upper hull`\n    `12. upper_hull = []`\n    `13. FOR each point p_i in p_n, ..., p_1 (reverse order):`\n    `14.  WHILE length of upper_hull = 2 AND orientation(upper_hull[-2], upper_hull[-1], p_i) = 0:`\n    `15.    Pop last point from upper_hull.`\n    `16.  Push p_i onto upper_hull.`\n\n    `// Step 3: Combine hulls`\n    `17. // Remove the last point of each hull because they are the same as`\n    `    // the first point of the other hull.`\n    `18. hull = lower_hull[:-1] + upper_hull[:-1]`\n    `19. RETURN hull`", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Computes the convex hull for a predefined suite of test cases\n    and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general case with interior points)\n        [(0,0), (2,0), (2,2), (0,2), (1,1)],\n        # Test case 2 (empty set)\n        [],\n        # Test case 3 (single point)\n        [(5,5)],\n        # Test case 4 (collinear points with duplicates)\n        [(0,0), (1,1), (2,2), (3,3), (1,1), (2,2)],\n        # Test case 5 (all points on the boundary with boundary collinear points included)\n        [(0,0), (3,0), (3,3), (0,3), (1,0), (2,0), (3,1), (3,2), (2,3), (1,3), (0,2), (0,1)],\n        # Test case 6 (two identical points)\n        [(7,7), (7,7)],\n        # Test case 7 (diamond with interior points and negative coordinates)\n        [(-2,0), (0,2), (2,0), (0,-2), (-1,0), (0,1), (1,0), (0,-1)]\n    ]\n\n    results = []\n    for case in test_cases:\n        hull = compute_convex_hull(case)\n        results.append(hull)\n\n    # Convert results to the required string representation for the final output.\n    # The format is a list of lists, e.g., [[[x1,y1],[x2,y2]], [[u1,v1]], ...].\n    # Build the string manually to avoid spaces.\n    \n    result_strings = []\n    for hull in results:\n        point_strings = [f\"[{p[0]},{p[1]}]\" for p in hull]\n        result_strings.append(f\"[{','.join(point_strings)}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\n\ndef compute_convex_hull(points):\n    \"\"\"\n    Computes the convex hull of a set of 2D points using the Monotone Chain algorithm.\n\n    Args:\n        points: A list of (x, y) tuples representing the points.\n\n    Returns:\n        A list of [x, y] lists representing the vertices of the convex hull,\n        ordered counter-clockwise starting from the lexicographically smallest point.\n    \"\"\"\n    # Step 0: Preprocessing and edge cases\n    # Use a set of tuples to efficiently remove duplicate points, then sort.\n    unique_points = sorted(list(set(points)))\n    n = len(unique_points)\n    \n    # If there are fewer than 3 points, they form the \"hull\" themselves.\n    if n  3:\n        # Convert tuples to lists as per output format\n        return [list(p) for p in unique_points]\n\n    # Helper function for orientation based on 2D cross product.\n    # O > 0: counter-clockwise (left turn)\n    # O  0: clockwise (right turn)\n    # O = 0: collinear\n    def orientation(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    # Step 1: Build the lower hull\n    lower_hull = []\n    for p in unique_points:\n        # Pop from the hull if the new point creates a right turn or is collinear.\n        # This maintains a strictly counter-clockwise (left-turning) chain.\n        while len(lower_hull) >= 2 and orientation(lower_hull[-2], lower_hull[-1], p) = 0:\n            lower_hull.pop()\n        lower_hull.append(p)\n\n    # Step 2: Build the upper hull\n    upper_hull = []\n    for p in reversed(unique_points):\n        # The logic is identical for the upper hull, iterating in reverse.\n        while len(upper_hull) >= 2 and orientation(upper_hull[-2], upper_hull[-1], p) = 0:\n            upper_hull.pop()\n        upper_hull.append(p)\n\n    # Step 3: Combine hulls\n    # The final hull is the lower hull followed by the upper hull.\n    # The first and last points of each hull are the same (the lexicographically\n    # smallest and largest points), so we exclude them from the concatenation\n    # to avoid duplicates.\n    full_hull_tuples = lower_hull[:-1] + upper_hull[:-1]\n    \n    # Convert tuples to lists for the final output format.\n    return [list(p) for p in full_hull_tuples]\n\nsolve()\n```", "id": "3205841"}, {"introduction": "The efficiency of general convex hull algorithms is typically limited by a sorting step, resulting in an $O(n \\log n)$ time complexity. However, what if our input points already possess some structure, such as forming the vertices of a simple, non-self-intersecting polygon? This advanced practice explores how to leverage this property to achieve a faster, linear-time solution. You will adapt the core ideas of incremental construction to devise an algorithm that finds the convex hull of a simple polygon in $O(n)$ time, demonstrating a key principle in algorithm design: exploiting input structure can lead to significant asymptotic improvements. [@problem_id:3224335]", "problem": "You are given the vertex sequence of a simple polygon in two-dimensional Euclidean space. A simple polygon is defined as a closed chain of $n$ distinct points $(x_i,y_i)$, $i \\in \\{0,1,\\dots,n-1\\}$, connected in order by straight line segments, such that only adjacent segments meet and the chain does not self-intersect. The convex hull of a finite set of points is defined as the smallest convex set that contains all the points; equivalently, it is the set of all convex combinations of the points.\n\nStarting from the foundational base that the orientation of three points can be determined by the sign of the two-dimensional cross product, where for points $o=(x_o,y_o)$, $a=(x_a,y_a)$, and $b=(x_b,y_b)$ the oriented area (signed cross product) is\n$$\n\\text{cross}(o,a,b) = (x_a - x_o)(y_b - y_o) - (y_a - y_o)(x_b - x_o),\n$$\nand the basic fact that a convex polygon is characterized by all consecutive edge directions turning the same way (for counterclockwise traversal, each turn is a left turn), derive and implement an adaptation of the Graham Scan algorithm that exploits the given polygonal vertex order to compute the convex hull in $O(n)$ time without any sorting. Your adaptation must be principled: it must maintain an explicit stack (or deque) of hull vertices and apply the orientation test to enforce the convexity invariant, removing vertices that would create a right turn or a straightening that lies interior to the current hull. The algorithm must handle both counterclockwise and clockwise input orders and must treat collinearity consistently so that interior collinear vertices on a hull edge are excluded while extreme collinear vertices are retained.\n\nYour program must:\n- Accept no input and operate on the fixed internal test suite provided below.\n- For each test case, compute the convex hull of the given simple polygon in $O(n)$ time using the above principles.\n- Return the hull vertices in counterclockwise order, starting from the lexicographically smallest vertex (ordered by $x$ then $y$). If the computed hull is clockwise, reverse it to make it counterclockwise.\n- Exclude interior collinear points on hull edges but include extreme endpoints.\n\nAngle units are not used, so none are required. No physical units are involved. The test suite is as follows, each polygon given as an ordered list of integer coordinates $(x,y)$:\n- Test case $1$ (convex square, counterclockwise): $[(0,0),(3,0),(3,3),(0,3)]$.\n- Test case $2$ (concave pentagon with an inward dent, counterclockwise): $[(0,0),(4,0),(4,4),(2,1),(0,4)]$.\n- Test case $3$ (convex pentagon with three collinear vertices along one edge, counterclockwise): $[(0,0),(2,0),(4,0),(4,3),(0,3)]$.\n- Test case $4$ (triangle, clockwise): $[(1,1),(3,4),(5,1)]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result is the hull of the corresponding test case, represented as a list of coordinate pairs with no spaces, in counterclockwise order starting from the lexicographically smallest vertex. For example, the output format is\n$[result_1,result_2,result_3,result_4]$,\nwhere each $result_i$ is a list like $[[x_0,y_0],[x_1,y_1],\\dots]$.", "solution": "We begin from core definitions and facts in computational geometry. The convex hull of a finite set of points in the plane is the unique minimal convex polygon that contains all points. A polygonal chain is simple when only consecutive edges meet and there are no self-intersections. The orientation of three points is determined by the sign of the cross product\n$$\n\\text{cross}(o,a,b) = (x_a - x_o)(y_b - y_o) - (y_a - y_o)(x_b - x_o),\n$$\nwhich yields $0$ for a left turn, $0$ for a right turn, and $=0$ for collinearity. This orientation test is the fundamental local predicate enabling incremental convex hull maintenance: if we maintain an ordered sequence of vertices and ensure that each step yields a left turn, we preserve convexity for counterclockwise traversal.\n\nThe classical Graham Scan algorithm sorts points by polar angle around an anchor point, then scans with a stack, popping points that would create a right turn. Sorting dominates its time complexity at $O(n \\log n)$. However, if the input is a simple polygon given in vertex order along its boundary (either clockwise or counterclockwise), we can leverage this existing order and avoid sorting. A well-tested principle is that the convex hull of a simple polyline can be computed in linear time by maintaining a deque of candidate hull vertices and applying the orientation test on the current extremal edges. This is an adaptation of the Graham Scan stack discipline to an already-ordered sequence: instead of sorting by angle, we trust the boundary order and only enforce convexity by ejecting vertices that do not maintain the hull’s support lines. This yields $O(n)$ time because each vertex is inserted once and possibly removed a constant number of times.\n\nDesigning the algorithm:\n- Let the input polygon be the ordered list $p_0, p_1, \\dots, p_{n-1}$, with indices modulo $n$. We first ensure that we start with a noncollinear triplet to initialize the deque invariant. If the initial three points are collinear, we rotate the starting index until we find three consecutive vertices $p_t, p_{t+1}, p_{t+2}$ such that $\\text{cross}(p_t,p_{t+1},p_{t+2}) \\neq 0$. This rotation preserves polygon adjacency and costs $O(n)$ in the worst case, but it is linear and done once.\n- Initialize a double-ended queue (deque) with these three points in an order that makes the current hull counterclockwise: if $\\text{cross}(p_t,p_{t+1},p_{t+2})  0$, push $[p_{t+2}, p_t, p_{t+1}, p_{t+2}]$ so that both ends repeat the last point; if the orientation is negative, swap $p_t$ and $p_{t+1}$ in this initialization to keep the invariant consistent. This ensures the deque’s first and last directed edges are the current supporting lines.\n- For each subsequent vertex $p_i$ in the rotated sequence:\n  1. If $p_i$ is strictly to the left of both the first edge $(D_0 \\to D_1)$ and the last edge $(D_{m-2} \\to D_{m-1})$ of the deque $D$, then $p_i$ lies inside the current convex hull, and we can skip it without changing $D$. Formally, if $\\text{cross}(D_0,D_1,p_i)  0$ and $\\text{cross}(D_{m-2},D_{m-1},p_i)  0$, we continue. In the presence of collinearity, a point on an edge (zero cross product) should not be considered strictly left; thus it triggers updates only when it extends the hull.\n  2. Otherwise, we must expand the hull to contain $p_i$. We pop from the right while $p_i$ is not strictly to the left of the last edge, i.e., while $\\text{cross}(D_{m-2},D_{m-1},p_i) \\le 0$, then append $p_i$ to the right. Similarly, we pop from the left while $p_i$ is not strictly to the left of the first edge, i.e., while $\\text{cross}(D_0,D_1,p_i) \\le 0$, then prepend $p_i$ to the left. These adjustments restore the convexity invariant: all turns along the deque boundary become left turns, and interior collinear points are expunged because they do not satisfy strict left-turn tests and are removed by popping.\n- At the end of the scan, the deque holds the convex hull vertices with a duplicated endpoint at both ends for symmetry in the invariant. We remove the duplicate and obtain the hull in boundary order.\n- To canonicalize the output, we compute the signed area of the hull sequence,\n$$\nA = \\frac{1}{2}\\sum_{i=0}^{k-1} (x_i y_{i+1} - x_{i+1} y_i),\n$$\nwith indices modulo $k$. If $A  0$, the vertices are clockwise; we reverse them to obtain counterclockwise order. Finally, we rotate the sequence so it starts at the lexicographically smallest vertex $(x,y)$ to provide a deterministic output.\n\nCorrectness derives from two facts: (i) the deque invariant enforces that the maintained polygon is convex because all local turns are left turns and the boundary is simple; (ii) every time a new point lies outside the current hull, we adjust the support edges by popping until the new hull includes the point with strictly left turns. No point that lies inside the current hull should be added because it cannot be an extreme point of the final convex hull. Collinearity is handled by strict inequalities: points interior to an edge (zero cross product) are not strictly left and will be removed or skipped unless they extend the hull, in which case popping removes interior points and retains the extreme endpoints.\n\nComplexity analysis: Each point is considered once. In the worst case, it may cause popping from either end of the deque; however, each point can be popped at most once after it is pushed, so the total number of deque operations is linear in $n$. Initialization and canonicalization are also linear. Therefore, the overall time complexity is $O(n)$, and the space complexity is $O(n)$.\n\nApplying this to the test suite:\n- Test case $1$ is a convex square; the hull equals the input polygon, ordered counterclockwise, starting at $(0,0)$.\n- Test case $2$ is a concave pentagon; the concave vertex $(2,1)$ lies inside the final hull, which is the rectangle with corners $(0,0)$, $(4,0)$, $(4,4)$, $(0,4)$.\n- Test case $3$ contains three collinear vertices along the bottom edge; the algorithm excludes the interior collinear point $(2,0)$ and retains only the extreme endpoints $(0,0)$ and $(4,0)$ along that edge, plus the top edge endpoints $(4,3)$ and $(0,3)$.\n- Test case $4$ is a triangle provided in clockwise order; the algorithm returns the same triangle reversed to counterclockwise order and canonicalized to start at the lexicographically smallest vertex.\n\nThe final program implements this adaptation, produces the convex hulls for all test polygons, and prints a single line containing the list of hulls, each as a list of coordinate pairs without spaces, in counterclockwise order starting at the lexicographically smallest vertex.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nfrom collections import deque\n\ndef cross(o, a, b):\n    # 2D cross product (signed area * 2)\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef polygon_area2(poly):\n    # Returns twice the signed area\n    s = 0\n    n = len(poly)\n    for i in range(n):\n        x1, y1 = poly[i]\n        x2, y2 = poly[(i + 1) % n]\n        s += x1 * y2 - x2 * y1\n    return s\n\ndef rotate_to_noncollinear(points):\n    n = len(points)\n    if n  3:\n        return points[:]\n    for t in range(n):\n        o = points[t]\n        a = points[(t + 1) % n]\n        b = points[(t + 2) % n]\n        if cross(o, a, b) != 0:\n            # rotate list to start at t\n            return points[t:] + points[:t]\n    # Degenerate: all collinear; return as-is\n    return points[:]\n\ndef melkman_simple_polygon(points):\n    # Adaptation of Graham scan for ordered simple polygon using Melkman deque method.\n    n = len(points)\n    if n == 0:\n        return []\n    if n == 1:\n        return [points[0]]\n    if n == 2:\n        # Hull is the two points; canonicalization later will handle orientation\n        return [points[0], points[1]]\n\n    pts = rotate_to_noncollinear(points)\n    n = len(pts)\n\n    # Find first noncollinear triple for robust init\n    # After rotate_to_noncollinear, the first triple is noncollinear\n    p0, p1, p2 = pts[0], pts[1], pts[2]\n    D = deque()\n    if cross(p0, p1, p2) > 0:\n        # Counterclockwise\n        D.append(p2)\n        D.append(p0)\n        D.append(p1)\n        D.append(p2)\n    else:\n        # Clockwise\n        D.append(p2)\n        D.append(p1)\n        D.append(p0)\n        D.append(p2)\n\n    for i in range(3, n):\n        pi = pts[i]\n        # If inside (strictly left of both ends), skip\n        if cross(D[0], D[1], pi) > 0 and cross(D[-2], D[-1], pi) > 0:\n            continue\n        # Fix right end\n        while cross(D[-2], D[-1], pi) = 0:\n            D.pop()\n        D.append(pi)\n        # Fix left end\n        while cross(D[0], D[1], pi) = 0:\n            D.popleft()\n        D.appendleft(pi)\n\n    # Remove duplicated last point\n    hull = list(D)[:-1]\n    # Canonicalize to CCW and lexicographically smallest start\n    if len(hull) >= 3:\n        area2 = polygon_area2(hull)\n        if area2  0:\n            hull.reverse()\n    # Rotate to lexicographically smallest vertex\n    if hull:\n        min_idx = min(range(len(hull)), key=lambda i: (hull[i][0], hull[i][1]))\n        hull = hull[min_idx:] + hull[:min_idx]\n    return hull\n\ndef serialize_no_spaces(obj):\n    # Serialize nested lists/tuples of numbers into a compact string without spaces\n    if isinstance(obj, list):\n        return '[' + ','.join(serialize_no_spaces(x) for x in obj) + ']'\n    else:\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: convex square, counterclockwise\n        [(0,0),(3,0),(3,3),(0,3)],\n        # Test case 2: concave pentagon with a dent, counterclockwise\n        [(0,0),(4,0),(4,4),(2,1),(0,4)],\n        # Test case 3: convex pentagon with three collinear points along one edge, counterclockwise\n        [(0,0),(2,0),(4,0),(4,3),(0,3)],\n        # Test case 4: triangle, clockwise\n        [(1,1),(3,4),(5,1)],\n    ]\n\n    results = []\n    for pts in test_cases:\n        hull = melkman_simple_polygon(pts)\n        # Ensure integer coordinates in output\n        hull_out = [[int(x), int(y)] for (x, y) in hull]\n        results.append(hull_out)\n\n    # Final print statement in the exact required format (no spaces).\n    print(serialize_no_spaces(results))\n\nsolve()\n```", "id": "3224335"}]}