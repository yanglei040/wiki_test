{"hands_on_practices": [{"introduction": "This first practice is your gateway to mastering bipartite matching. Using the classic scenario of assigning spies to secrets, you will implement the powerful Hopcroft-Karp algorithm from the ground up [@problem_id:3250161]. This exercise is essential for translating the theoretical concepts of augmenting paths and level graphs into a concrete, efficient program.", "problem": "You are given a family of bipartite graphs representing which agents can take which tasks. In the specific narrative, a set of spies must acquire a set of secrets. Each spy can attempt to acquire only one secret, and each secret can be acquired by at most one spy. There is an edge between a spy and a secret if that spy has the capability to acquire that secret. Formally, consider a bipartite graph $G = (U,V,E)$, where $U$ is the set of spies, $V$ is the set of secrets, and $E \\subseteq U \\times V$ is the set of possible acquisitions. A matching $M \\subseteq E$ is a set of pairwise non-incident edges, and its cardinality is $|M|$. The maximum bipartite matching problem is to find a matching of largest possible cardinality.\n\nThe fundamental base you should use is the following set of core definitions and facts from graph theory and the theory of algorithms:\n- A bipartite graph $G = (U,V,E)$ has vertex sets $U$ and $V$ with $U \\cap V = \\varnothing$ and edges only between $U$ and $V$.\n- A matching $M$ is a subset of edges such that no two edges share an endpoint.\n- An augmenting path with respect to a matching $M$ is a simple path that starts and ends at unmatched vertices such that edges along the path alternate between not in $M$ and in $M$. If an augmenting path exists, augmenting along it strictly increases $|M|$.\n\nYour task is to write a complete program that, for each test case, computes the maximum number of secrets that can be stolen simultaneously, which equals the size of a maximum matching. The program should implement an algorithm grounded in the concept of augmenting paths and level graphs that is suitable for efficiently finding a maximum matching in bipartite graphs.\n\nFor each test case below, the spies are indexed as integers in the range $[0, n-1]$, the secrets are indexed as integers in the range $[0, m-1]$, and the set $E$ is given as a set of ordered pairs $(u,v)$ with $u \\in U$ and $v \\in V$. If duplicate ordered pairs appear, their effect is identical to a single edge, and they should be treated as a single connection.\n\nThe required final output format is a single line containing a comma-separated list of integers enclosed in square brackets, in the order of the test cases, where each integer is the size of the maximum matching for the corresponding test case. For example, a valid output could look like $[3,0,4]$.\n\nThere are no physical units, angles, or percentages involved in this problem. All outputs must be integers.\n\nTest Suite:\n- Test Case $1$ (general case): $n = 5$, $m = 6$, $E = \\{(0,0),(0,1),(1,0),(1,2),(1,3),(2,1),(2,3),(3,2),(3,4),(4,4),(4,5)\\}$.\n- Test Case $2$ (boundary with no edges): $n = 3$, $m = 4$, $E = \\varnothing$.\n- Test Case $3$ (perfect matching exists): $n = 4$, $m = 4$, $E = \\{(0,0),(1,1),(2,2),(3,3)\\}$.\n- Test Case $4$ (imbalanced graph with limited secrets): $n = 3$, $m = 5$, $E = \\{(0,0),(0,1),(1,0),(1,1),(2,0),(2,1)\\}$.\n- Test Case $5$ (disjoint components and duplicate edges): $n = 6$, $m = 6$, $E = \\{(0,0),(0,0),(0,1),(1,1),(2,2),(2,3),(3,2),(4,3),(4,4),(5,5)\\}$.\n- Test Case $6$ (chain-like structure that enables multiple shortest augmenting paths): $n = 7$, $m = 7$, $E = \\{(0,0),(0,1),(1,1),(1,2),(2,2),(2,3),(3,3),(3,4),(4,4),(4,5),(5,5),(5,6),(6,0),(6,6)\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases. For instance, the output should look exactly like $[r_1,r_2,r_3,r_4,r_5,r_6]$, where each $r_i$ is the maximum matching size for Test Case $i$.", "solution": "We begin from the standard graph-theoretic foundation: for a bipartite graph $G = (U,V,E)$, a matching $M \\subseteq E$ is a set of edges with no shared endpoints, and an augmenting path with respect to $M$ is a simple path that starts and ends at unmatched vertices such that edges on the path alternate between not in $M$ and in $M$. A classical and well-tested fact is that if an augmenting path exists with respect to a matching $M$, then augmenting along it strictly increases the cardinality of the matching, and conversely, a matching is maximum if and only if there is no augmenting path.\n\nTo compute a maximum matching efficiently, one can find multiple vertex-disjoint shortest augmenting paths per iteration rather than a single path at a time. The Hopcroft–Karp algorithm exploits this insight by building a layered graph using Breadth-First Search (BFS, Breadth-First Search) from all currently unmatched vertices in $U$ simultaneously, discovering the shortest distance to unmatched vertices in $V$, and then performing Depth-First Search (DFS, Depth-First Search) restricted to the discovered BFS layers to find a maximal set of vertex-disjoint shortest augmenting paths. Each augmentation increases the matching size, and the BFS ensures that the length of subsequent augmenting paths strictly increases in phases, yielding a worst-case time complexity of $O(|E| \\sqrt{|U| + |V|})$.\n\nAlgorithmic design in detail:\n1. Represent the bipartite graph by an adjacency list for vertices in $U$: for each $u \\in U$, maintain the set of neighbors $N(u) \\subseteq V$ deduplicated from the input pairs.\n2. Maintain two pairing arrays: $\\mathrm{pairU}[u]$ giving the secret in $V$ matched to $u$ or $-1$ if unmatched, and $\\mathrm{pairV}[v]$ giving the spy in $U$ matched to $v$ or $-1$ if unmatched.\n3. Perform a BFS phase:\n   - Initialize a distance array $\\mathrm{dist}[u]$ to $\\infty$ for all $u \\in U$.\n   - For each free (unmatched) $u \\in U$, set $\\mathrm{dist}[u] = 0$ and enqueue $u$.\n   - For each dequeued $u$, for every neighbor $v \\in N(u)$:\n     - If $v$ is matched to some $u' = \\mathrm{pairV}[v]$ and $\\mathrm{dist}[u']$ is $\\infty$, then set $\\mathrm{dist}[u'] = \\mathrm{dist}[u] + 1$ and enqueue $u'$.\n     - If $v$ is free (i.e., $\\mathrm{pairV}[v] = -1$), record that at least one shortest augmenting path exists in this BFS layering.\n   - The BFS phase returns a boolean indicating whether any free vertex in $V$ was reached from the layer graph, which implies the existence of at least one augmenting path.\n4. Perform a DFS phase for each free $u \\in U$ to find and commit augmenting paths while respecting the BFS layers:\n   - For a given $u$, explore neighbors $v \\in N(u)$. If $v$ is free, immediately match $u$ to $v$.\n   - Otherwise, let $u' = \\mathrm{pairV}[v]$; if $\\mathrm{dist}[u'] = \\mathrm{dist}[u] + 1$, recursively attempt to augment through $u'$. If successful, rematch $u$ to $v$ and return success.\n   - If no neighbor leads to augmentation, set $\\mathrm{dist}[u] = \\infty$ to prune future DFS attempts in this phase.\n5. Repeat BFS and DFS phases until BFS indicates no augmenting paths remain. The number of successful augmentations is the maximum matching cardinality.\n\nCorrectness rests on two pillars: first, augmenting along disjoint shortest augmenting paths cannot interfere adversely with each other, since each path is vertex-disjoint and flips the matched status along alternating edges; second, the BFS layering ensures that all augmenting paths found in a phase are shortest, and that after augmentation the shortest possible augmenting path length strictly increases, limiting the number of phases to $O(\\sqrt{|U| + |V|})$.\n\nWe now reason about the test suite results:\n- Test Case $1$: $n = 5$, $m = 6$, $E = \\{(0,0),(0,1),(1,0),(1,2),(1,3),(2,1),(2,3),(3,2),(3,4),(4,4),(4,5)\\}$. One valid maximum matching is $\\{(0,1),(1,3),(2,0),(3,2),(4,4)\\}$, which has size $5$, so the result is $5$.\n- Test Case $2$: $n = 3$, $m = 4$, $E = \\varnothing$. There are no edges, hence no matching edges exist, and the maximum matching size is $0$.\n- Test Case $3$: $n = 4$, $m = 4$, $E = \\{(0,0),(1,1),(2,2),(3,3)\\}$. The set $\\{(0,0),(1,1),(2,2),(3,3)\\}$ is a perfect matching of size $4$, thus the result is $4$.\n- Test Case $4$: $n = 3$, $m = 5$, $E = \\{(0,0),(0,1),(1,0),(1,1),(2,0),(2,1)\\}$. Only secrets $0$ and $1$ are available to all spies; at most two spies can be matched, so the maximum matching size is $2$.\n- Test Case $5$: $n = 6$, $m = 6$, $E = \\{(0,0),(0,0),(0,1),(1,1),(2,2),(2,3),(3,2),(4,3),(4,4),(5,5)\\}$. Despite the duplicate $(0,0)$, deduplication yields effective edges. A maximum matching is $\\{(0,0),(1,1),(2,3),(3,2),(4,4),(5,5)\\}$ of size $6$, hence the result is $6$.\n- Test Case $6$: $n = 7$, $m = 7$, $E = \\{(0,0),(0,1),(1,1),(1,2),(2,2),(2,3),(3,3),(3,4),(4,4),(4,5),(5,5),(5,6),(6,0),(6,6)\\}$. A perfect matching exists, for instance $\\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,0)\\}$ yielding size $7$, so the result is $7$.\n\nTherefore, in order, the outputs for the six test cases are $[5,0,4,2,6,7]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef hopcroft_karp_max_matching(n_left, n_right, edges):\n    \"\"\"\n    Compute maximum bipartite matching using the Hopcroft–Karp algorithm.\n\n    n_left: number of vertices on the left side U (spies), indexed 0..n_left-1\n    n_right: number of vertices on the right side V (secrets), indexed 0..n_right-1\n    edges: list of (u, v) pairs where u in U, v in V\n\n    Returns: size of maximum matching (integer)\n    \"\"\"\n    # Build deduplicated adjacency list for U\n    adj = [set() for _ in range(n_left)]\n    for u, v in edges:\n        if 0 = u  n_left and 0 = v  n_right:\n            adj[u].add(v)\n        else:\n            # Ignore any out-of-range edges; not expected in given test suite\n            pass\n    adj = [sorted(list(neis)) for neis in adj]\n\n    # Pairing arrays: -1 means free/unmatched\n    pairU = [-1] * n_left\n    pairV = [-1] * n_right\n    dist = [0] * n_left\n    INF = 10**9\n\n    def bfs():\n        \"\"\"\n        BFS builds layers from all free U vertices.\n        Returns True if there exists at least one augmenting path.\n        \"\"\"\n        q = deque()\n        for u in range(n_left):\n            if pairU[u] == -1:\n                dist[u] = 0\n                q.append(u)\n            else:\n                dist[u] = INF\n\n        found_free_v = False\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                pu = pairV[v]\n                if pu != -1:\n                    if dist[pu] == INF:\n                        dist[pu] = dist[u] + 1\n                        q.append(pu)\n                else:\n                    # Reached a free vertex on V; indicates an augmenting path exists\n                    found_free_v = True\n        return found_free_v\n\n    def dfs(u):\n        \"\"\"\n        DFS restricted to BFS layers to find and commit augmenting paths.\n        \"\"\"\n        for v in adj[u]:\n            pu = pairV[v]\n            # If v is free, we can match u->v\n            if pu == -1:\n                pairU[u] = v\n                pairV[v] = u\n                return True\n            # Otherwise try to advance on layer graph\n            if dist[pu] == dist[u] + 1 and dfs(pu):\n                pairU[u] = v\n                pairV[v] = u\n                return True\n        # Prune: no augmenting path from u in this phase\n        dist[u] = INF\n        return False\n\n    matching = 0\n    while bfs():\n        for u in range(n_left):\n            if pairU[u] == -1:\n                if dfs(u):\n                    matching += 1\n    return matching\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is (n_left, n_right, edges)\n    test_cases = [\n        # Test Case 1\n        (5, 6, [(0,0),(0,1),(1,0),(1,2),(1,3),(2,1),(2,3),(3,2),(3,4),(4,4),(4,5)]),\n        # Test Case 2\n        (3, 4, []),\n        # Test Case 3\n        (4, 4, [(0,0),(1,1),(2,2),(3,3)]),\n        # Test Case 4\n        (3, 5, [(0,0),(0,1),(1,0),(1,1),(2,0),(2,1)]),\n        # Test Case 5 (includes duplicate edge (0,0))\n        (6, 6, [(0,0),(0,0),(0,1),(1,1),(2,2),(2,3),(3,2),(4,3),(4,4),(5,5)]),\n        # Test Case 6\n        (7, 7, [(0,0),(0,1),(1,1),(1,2),(2,2),(2,3),(3,3),(3,4),(4,4),(4,5),(5,5),(5,6),(6,0),(6,6)]),\n    ]\n\n    results = []\n    for n_left, n_right, edges in test_cases:\n        result = hopcroft_karp_max_matching(n_left, n_right, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3250161"}, {"introduction": "Beyond simply finding the size of a maximum matching, we can use its structure to uncover other fundamental properties of a graph. This exercise challenges you to apply Kőnig's theorem, which reveals a beautiful duality between matchings and vertex covers [@problem_id:3250194]. By building upon your matching algorithm, you will learn a constructive method to find a minimum vertex cover, solidifying your understanding of this key theoretical link.", "problem": "You are given the task of constructing, for each of several bipartite graphs, a minimum vertex cover from a maximum matching, using an efficient method grounded in core graph-theoretic principles. A bipartite graph is a graph $G = (V, E)$ with a partition $V = L \\cup R$ where every edge $e \\in E$ has one endpoint in $L$ and the other in $R$. A matching $M \\subseteq E$ is a set of pairwise vertex-disjoint edges. The size of a matching is the number of edges it contains. A vertex cover $C \\subseteq V$ is a set of vertices that intersects every edge in $E$. The goal is to compute a minimum vertex cover $C$ of smallest possible size. A fundamental fact (Kőnig's theorem) asserts that for any bipartite graph, the maximum matching size equals the minimum vertex cover size; that is, if $M$ is a maximum matching and $C$ is a minimum vertex cover, then $|M| = |C|$.\n\nYour program must, for each provided bipartite graph:\n- Compute a maximum matching using an efficient algorithm whose time complexity is asymptotically no worse than $O(|E| \\sqrt{|V|})$ on each instance.\n- From the computed maximum matching, construct a corresponding minimum vertex cover $C$ and report its size.\n- Ensure the reported size equals the size of the computed maximum matching.\n\nDefinitions to be used as the foundational base:\n- A path in $G$ is a sequence of vertices with consecutive vertices connected by an edge. An augmenting path with respect to a matching $M$ is a path that starts and ends at unmatched vertices and alternates between edges not in $M$ and edges in $M$.\n- By Berge's theorem, a matching is maximum if and only if there is no augmenting path with respect to it.\n- The Hopcroft–Karp algorithm is an efficient algorithm for maximum bipartite matching that repeatedly finds a maximal set of vertex-disjoint shortest augmenting paths using Breadth-First Search (BFS) and Depth-First Search (DFS), where Breadth-First Search (BFS) is a level-by-level traversal and Depth-First Search (DFS) explores along paths.\n\nInput model for each test case:\n- The bipartite graph is specified by three parameters: the number of left vertices $n_L$, the number of right vertices $n_R$, and the edge list $E \\subseteq \\{0, 1, \\dots, n_L - 1\\} \\times \\{0, 1, \\dots, n_R - 1\\}$.\n- Vertices on the left are labeled by integers $0$ through $n_L - 1$ and on the right by integers $0$ through $n_R - 1$.\n\nTest suite to be hardcoded inside your program:\n- Case $1$ (general happy path): $n_L = 3$, $n_R = 3$, edges $E = [ (0,0), (0,1), (1,1), (2,1), (2,2) ]$.\n- Case $2$ (empty graph boundary): $n_L = 2$, $n_R = 3$, edges $E = [\\,]$.\n- Case $3$ (star-shaped, many-to-one): $n_L = 3$, $n_R = 1$, edges $E = [ (0,0), (1,0), (2,0) ]$.\n- Case $4$ (multiple components, non-perfect): $n_L = 4$, $n_R = 4$, edges $E = [ (0,0), (0,1), (1,1), (2,2), (3,2) ]$.\n- Case $5$ (right-limited capacity): $n_L = 4$, $n_R = 3$, edges $E = [ (0,0), (0,1), (1,1), (1,2), (2,2), (3,2) ]$.\n\nProgram requirements:\n- Implement the Hopcroft–Karp algorithm to compute a maximum matching for each case, ensuring the asymptotic bound $O(|E| \\sqrt{|V|})$.\n- Derive a minimum vertex cover from the computed matching by traversing alternating paths starting from unmatched vertices on the left side using only non-matching edges from $L$ to $R$ and only matching edges from $R$ back to $L$, and then forming the cover $C = \\left( L \\setminus T_L \\right) \\cup \\left( R \\cap T_R \\right)$, where $T_L$ and $T_R$ are, respectively, the sets of reachable left and right vertices in this alternating traversal.\n- For each test case, output a single integer equal to $|C|$, the size of the minimum vertex cover (which must equal the size of the maximum matching by Kőnig's theorem).\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases: for example, the format is $[r_1, r_2, r_3, r_4, r_5]$, where each $r_i$ is the integer size of the computed minimum vertex cover for case $i$.", "solution": "The problem is valid as it is well-posed, self-contained, and grounded in the established principles of graph theory, specifically concerning maximum bipartite matching and minimum vertex covers. It requests the implementation of the Hopcroft–Karp algorithm and the subsequent construction of a minimum vertex cover, a standard and formalizable task in algorithmics.\n\nThe solution is divided into two main parts. First, we compute the maximum matching for a given bipartite graph $G = (V, E)$ with partition $V = L \\cup R$ using the Hopcroft–Karp algorithm. Second, we use the computed maximum matching $M$ to construct a minimum vertex cover $C$ based on the constructive proof of Kőnig's theorem.\n\n**Part 1: The Hopcroft–Karp Algorithm for Maximum Bipartite Matching**\n\nThe Hopcroft–Karp algorithm finds a maximum matching in a bipartite graph with a time complexity of $O(|E| \\sqrt{|V|})$. The algorithm works iteratively. Starting with an empty matching $M$, it repeatedly finds a maximal set of vertex-disjoint shortest augmenting paths and uses them to increase the size of $M$. An augmenting path is a path that alternates between edges not in $M$ and edges in $M$, starting from an unmatched vertex in $L$ and ending at an unmatched vertex in $R$. By Berge's theorem, a matching is maximum if and only if no augmenting path exists with respect to it.\n\nEach iteration of the Hopcroft–Karp algorithm consists of two phases:\n\n1.  **Breadth-First Search (BFS):**\n    A layered graph is constructed using a BFS starting simultaneously from all unmatched vertices in the left partition, $L$. The traversal alternates between partitions: from a vertex $u \\in L$ to a vertex $v \\in R$ via an edge not in the current matching $M$, and from a vertex $v \\in R$ back to a vertex $u' \\in L$ via an edge in $M$. The BFS calculates the length of the shortest augmenting paths. It partitions the vertices into levels, where `dist[u]` for a vertex $u \\in L$ is its level in the layered graph. The BFS phase terminates once it reaches one or more unmatched vertices in $R$. If no unmatched vertex in $R$ is reachable, no augmenting paths exist, and the algorithm terminates, as the current matching $M$ is maximum.\n\n2.  **Depth-First Search (DFS):**\n    A DFS is performed from each unmatched vertex in $L$ to find vertex-disjoint augmenting paths of the shortest length determined by the BFS. The DFS only traverses from a vertex $u$ to a vertex $w$ if $w$ is in the next level of the layered graph, i.e., $\\text{dist}[w] = \\text{dist}[u] + 1$. When a DFS path reaches an unmatched vertex in $R$, an augmenting path has been found. The matching $M$ is updated by taking the symmetric difference of $M$ and the path, which effectively swaps the matched and unmatched edges along the path and increases $|M|$ by $1$. The DFS continues to find other vertex-disjoint augmenting paths from the remaining unmatched vertices in $L$.\n\nThis cycle of BFS followed by DFS is repeated. The length of the shortest augmenting paths is proven to strictly increase with each iteration. This property guarantees that the algorithm performs at most $O(\\sqrt{|V|})$ iterations, leading to the total time complexity of $O(|E|\\sqrt{|V|})$.\n\n**Part 2: Constructing a Minimum Vertex Cover from a Maximum Matching**\n\nKőnig's theorem states that in any bipartite graph, the number of edges in a maximum matching equals the number of vertices in a minimum vertex cover. We use the constructive proof of this theorem to find a minimum vertex cover $C$ from the maximum matching $M$ computed by the Hopcroft–Karp algorithm.\n\nThe construction proceeds as follows:\n\n1.  Let $U_L$ be the set of all unmatched vertices in the left partition $L$.\n2.  Perform a graph traversal (e.g., using DFS or BFS) starting from all vertices in $U_L$. This traversal explores alternating paths:\n    - From a vertex $u \\in L$, traverse to a vertex $v \\in R$ if the edge $(u,v)$ is **not** in the matching $M$.\n    - From a vertex $v \\in R$, traverse to a vertex $u' \\in L$ if the edge $(v,u')$ is **in** the matching $M$.\n3.  Let $T$ be the set of all vertices visited during this traversal. We can partition $T$ into $T_L = T \\cap L$ and $T_R = T \\cap R$.\n4.  The minimum vertex cover $C$ is then defined as the set of vertices $C = (L \\setminus T_L) \\cup T_R$.\n\nTo confirm the validity of this construction, we consider two properties: that $C$ is a vertex cover and that its size is equal to $|M|$.\n\n- **$C$ is a vertex cover:** Consider an arbitrary edge $(u, v) \\in E$, with $u \\in L$ and $v \\in R$.\n    - If the edge $(u, v)$ is in the matching $M$: If $u \\in T_L$, then its matched partner $v$ must have been reached from $u$ via a non-matching edge, which is a contradiction. Therefore, $u$ cannot be in $T_L$. This implies $u \\in (L \\setminus T_L)$, so $u \\in C$, and the edge is covered.\n    - If the edge $(u, v)$ is not in the matching $M$: If $u \\in T_L$, then $v$ is reachable from $u$ via the non-matching edge $(u, v)$. Thus, $v \\in T_R$, so $v \\in C$, and the edge is covered. If $u \\notin T_L$, then $u \\in (L \\setminus T_L)$, so $u \\in C$, and the edge is covered.\n    In all cases, every edge is covered.\n\n- **$|C| = |M|$**: The vertices in $C$ are composed of the \"unreachable\" left vertices $(L \\setminus T_L)$ and the \"reachable\" right vertices $(T_R)$. It can be shown that the matching $M$ establishes a bijection between the set of vertices $T_R$ and the set of matched vertices in $T_L$, and also between the set $(L \\setminus T_L)$ and the set of matched vertices in $(R \\setminus T_R)$. Consequently, the set $C$ consists of exactly one vertex from each edge in the matching $M$. Therefore, $|C| = |M|$. By Kőnig's theorem, since $M$ is a maximum matching, $C$ must be a minimum vertex cover.\n\nThe implementation will apply these two parts to each test case provided. For each graph specified by $n_L$, $n_R$, and an edge list $E$, we first run the Hopcroft–Karp algorithm to find $|M|$ and store the matching pairs. Then, we execute the alternating path traversal to find the sets $T_L$ and $T_R$ and compute the size of the resulting vertex cover $C$, which will be our final result for that case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\nclass HopcroftKarp:\n    \"\"\"\n    Implementation of the Hopcroft-Karp algorithm for maximum bipartite matching\n    and construction of a minimum vertex cover.\n    \"\"\"\n    def __init__(self, nL, nR, edges):\n        \"\"\"\n        Initializes the bipartite graph.\n        - nL: Number of vertices in the left partition (U)\n        - nR: Number of vertices in the right partition (V)\n        - edges: A list of tuples (u, v) representing edges\n        \"\"\"\n        self.nL = nL\n        self.nR = nR\n        # Adjacency list for left vertices\n        self.adj = [[] for _ in range(nL)]\n        for u, v in edges:\n            self.adj[u].append(v)\n        \n        # Matching pairs for left (L) and right (R) partitions\n        self.pairL = np.full(nL, -1, dtype=int)\n        self.pairR = np.full(nR, -1, dtype=int)\n        \n        # Distance array for BFS, only for left vertices\n        self.dist = np.full(nL, -1, dtype=int)\n        \n        # Store computed matching for vertex cover construction\n        self.max_matching_size = 0\n\n    def _bfs(self):\n        \"\"\"\n        Performs BFS to find layers in the graph and check for augmenting paths.\n        \"\"\"\n        queue = deque()\n        self.dist.fill(-1) # Reset distances for left vertices\n        \n        # Start BFS from all unmatched vertices in L\n        for u in range(self.nL):\n            if self.pairL[u] == -1:\n                queue.append(u)\n                self.dist[u] = 0\n        \n        found_path = False\n        while queue:\n            u = queue.popleft()\n            for v in self.adj[u]:\n                # u_matched is the vertex in L matched with v\n                u_matched = self.pairR[v]\n                if u_matched == -1:\n                    # Found an augmenting path to an unmatched right vertex\n                    found_path = True\n                # If u_matched has not been visited yet (dist is -1)\n                elif self.dist[u_matched] == -1:\n                    # This is part of an alternating path\n                    self.dist[u_matched] = self.dist[u] + 1\n                    queue.append(u_matched)\n        return found_path\n\n    def _dfs(self, u):\n        \"\"\"\n        Performs DFS to find an augmenting path from vertex u.\n        \"\"\"\n        for v in self.adj[u]:\n            u_matched = self.pairR[v]\n            # If v is free or we can find an augmenting path from its partner u_matched\n            if u_matched == -1 or (self.dist[u_matched] == self.dist[u] + 1 and self._dfs(u_matched)):\n                self.pairL[u] = v\n                self.pairR[v] = u\n                return True\n        # Mark u as visited in this DFS phase to ensure paths are vertex-disjoint\n        self.dist[u] = -1 \n        return False\n\n    def find_max_matching(self):\n        \"\"\"\n        Computes the maximum matching size using the Hopcroft-Karp algorithm.\n        \"\"\"\n        matching_size = 0\n        # Continue as long as augmenting paths are found by BFS\n        while self._bfs():\n            for u in range(self.nL):\n                if self.pairL[u] == -1:\n                    if self._dfs(u):\n                        matching_size += 1\n        self.max_matching_size = matching_size\n        return matching_size\n\n    def find_min_vertex_cover(self):\n        \"\"\"\n        Constructs a minimum vertex cover from the computed maximum matching.\n        This must be called after find_max_matching().\n        \"\"\"\n        # Find unmatched vertices in the left partition\n        unmatched_L = {u for u in range(self.nL) if self.pairL[u] == -1}\n\n        # Sets of reachable vertices from unmatched_L via alternating paths\n        reachable_L = set(unmatched_L)\n        reachable_R = set()\n        \n        q = deque(list(unmatched_L))\n        visited_in_traversal = set(unmatched_L)\n\n        while q:\n            u = q.popleft() # A reachable vertex from L\n            # Traverse non-matching edges from L to R\n            for v in self.adj[u]:\n                if self.pairL[u] != v and v not in reachable_R:\n                    reachable_R.add(v)\n                    # Traverse matching edge from R to L\n                    u_matched = self.pairR[v]\n                    if u_matched != -1 and u_matched not in reachable_L:\n                        reachable_L.add(u_matched)\n                        q.append(u_matched)\n\n        # The minimum vertex cover C = (L \\ T_L) U T_R\n        # where T_L = reachable_L and T_R = reachable_R\n        unreachable_L = set(range(self.nL)) - reachable_L\n        min_cover = unreachable_L | reachable_R\n        \n        return len(min_cover)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: general happy path\n        {'n_L': 3, 'n_R': 3, 'edges': [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]},\n        # Case 2: empty graph boundary\n        {'n_L': 2, 'n_R': 3, 'edges': []},\n        # Case 3: star-shaped, many-to-one\n        {'n_L': 3, 'n_R': 1, 'edges': [(0, 0), (1, 0), (2, 0)]},\n        # Case 4: multiple components, non-perfect\n        {'n_L': 4, 'n_R': 4, 'edges': [(0, 0), (0, 1), (1, 1), (2, 2), (3, 2)]},\n        # Case 5: right-limited capacity\n        {'n_L': 4, 'n_R': 3, 'edges': [(0, 0), (0, 1), (1, 1), (1, 2), (2, 2), (3, 2)]},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Initialize the HopcroftKarp instance for the current graph.\n        solver = HopcroftKarp(case['n_L'], case['n_R'], case['edges'])\n        \n        # First, compute the maximum matching. This populates the pair arrays.\n        max_matching_size = solver.find_max_matching()\n        \n        # Second, construct the minimum vertex cover from the matching.\n        min_vertex_cover_size = solver.find_min_vertex_cover()\n        \n        # By Kőnig's theorem, these sizes must be equal.\n        # assert max_matching_size == min_vertex_cover_size\n        \n        results.append(min_vertex_cover_size)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3250194"}, {"introduction": "Having found a perfect matching, a more subtle question emerges: is this the only possible solution? This advanced practice moves beyond existence to the question of uniqueness [@problem_id:3250170]. You will develop an algorithm to detect the presence of alternating cycles, the key structure that determines whether other perfect matchings exist, thereby deepening your expertise in the fine-grained properties of matchings.", "problem": "You are given a finite bipartite graph specified by two disjoint vertex sets $U$ and $V$ and an edge set $E \\subseteq U \\times V$. A matching is a subset of edges $M \\subseteq E$ such that no two edges in $M$ share an endpoint. A perfect matching is a matching that saturates every vertex in $U \\cup V$. A bipartite graph has a unique perfect matching if and only if it has exactly one perfect matching.\n\nYour task is to devise and implement an algorithm, grounded in the core definitions of matchings and augmenting paths, to decide whether a given bipartite graph has a unique perfect matching. The algorithm must:\n- Compute a maximum matching using an asymptotically optimal method for bipartite graphs in terms of the number of vertices and edges.\n- Decide whether a perfect matching exists, and if so, whether it is unique, based solely on structural properties implied by the core definitions, not by relying on repeated maximum-matching computations on modified graphs.\n\nYour program must solve the following fixed test suite of bipartite graphs. Each test case is fully specified as a triple $(|U|, |V|, E)$, with $U = \\{0,1,\\dots,|U|-1\\}$ and $V = \\{0,1,\\dots,|V|-1\\}$, and edges given as ordered pairs $(u,v)$ with $u \\in U$ and $v \\in V$. All indices are zero-based. There are no physical units involved.\n\nTest suite:\n- Case $1$: $(|U|, |V|, E) = (2, 2, \\{(0,0), (1,1), (0,1)\\})$. This graph has two vertices per side and three edges.\n- Case $2$: $(|U|, |V|, E) = (2, 2, \\{(0,0), (0,1), (1,0), (1,1)\\})$. This is the complete bipartite graph $K_{2,2}$.\n- Case $3$: $(|U|, |V|, E) = (3, 3, \\{(0,0), (1,0), (2,1)\\})$. This graph does not admit a perfect matching.\n- Case $4$: $(|U|, |V|, E) = (4, 4, \\{(0,0), (0,1), (0,2), (0,3), (1,1), (1,2), (1,3), (2,2), (2,3), (3,3)\\})$. This is a nested-neighborhood (chain) bipartite graph.\n- Case $5$: $(|U|, |V|, E) = (3, 3, \\{(0,0), (1,0), (1,1), (2,1), (2,2), (0,2)\\})$. This graph contains an even cycle covering all vertices.\n\nFor each test case, your program must output a boolean: $True$ if and only if the graph has a unique perfect matching, and $False$ otherwise. The final output must be a single line containing the results for the cases in order as a comma-separated list enclosed in square brackets, for example $[True,False,True,False,True]$.\n\nConstraints and expectations:\n- The algorithm must start from the foundational definitions of matchings and augmenting paths and use a provably efficient maximum matching procedure for bipartite graphs with time complexity $O(|E|\\sqrt{|U|+|V|})$, where $|E|$ is the number of edges.\n- If a perfect matching exists, the algorithm must determine its uniqueness using only structural implications of the definitions (for example, properties of alternating walks) and must run in time $O(|U|+|V|+|E|)$ in this uniqueness-checking phase.\n- If $|U| \\neq |V|$, then a perfect matching cannot exist; in such cases, the answer must be $False$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[result_1,result_2,result_3,result_4,result_5]$), where each $result_i$ is either $True$ or $False$ corresponding to case $i$.", "solution": "The problem asks for an algorithm to determine if a given bipartite graph possesses a unique perfect matching. The solution must be grounded in fundamental principles of matching theory and employ efficient algorithms.\n\nA perfect matching in a bipartite graph $G = (U \\cup V, E)$ is a subset of edges $M \\subseteq E$ that covers every vertex in the graph exactly once. A necessary condition for a perfect matching to exist is that the two vertex partitions must be of equal size, i.e., $|U| = |V|$. If $|U| \\neq |V|$, no perfect matching can exist, and by extension, no unique perfect matching can exist. Let $n = |U| = |V|$. A perfect matching, if one exists, will have a size of $n$.\n\nThe overall strategy is a two-phase process:\n1.  Determine if a perfect matching exists by computing a maximum matching.\n2.  If a perfect matching is found, determine if it is unique by searching for specific structural features in the graph.\n\n**Step 1: Existence of a Perfect Matching**\n\nTo determine if a perfect matching exists, we first find the size of a maximum matching, which is a matching with the largest possible number of edges. If the size of this maximum matching is equal to $n$, then a perfect matching exists. Otherwise, no perfect matching exists.\n\nThe most efficient known algorithm for finding a maximum matching in a bipartite graph is the Hopcroft-Karp algorithm. This algorithm is based on a fundamental result in matching theory, Berge's theorem, which states that a matching $M$ is maximum if and only if there is no $M$-augmenting path. An $M$-augmenting path is a path whose edges alternate between being outside and inside the matching $M$, and whose endpoints are unmatched vertices.\n\nThe Hopcroft-Karp algorithm operates in phases. In each phase, it finds a maximal set of vertex-disjoint shortest augmenting paths. This is achieved by:\n- A Breadth-First Search (BFS) starting from all unmatched vertices in $U$ to build a layered graph. This identifies the length of the shortest augmenting paths.\n- A Depth-First Search (DFS) on this layered graph to find all paths in the maximal set and augment the matching along them.\n\nThe number of phases is proven to be at most $O(\\sqrt{|U \\cup V|})$. Each phase takes $O(|E|)$ time, leading to a total time complexity of $O(|E|\\sqrt{|U \\cup V|})$, which satisfies the problem's requirement.\n\nIf the Hopcroft-Karp algorithm returns a matching $M$ of size $|M|  n$, we conclude that no perfect matching exists, and the answer is $False$.\n\n**Step 2: Uniqueness of the Perfect Matching**\n\nIf a perfect matching $M$ of size $n$ is found, we must then determine if it is the only one. Suppose another distinct perfect matching, $M'$, exists. Let us consider the symmetric difference of these two matchings, denoted by $M \\oplus M' = (M \\setminus M') \\cup (M' \\setminus M)$.\n\nThe subgraph formed by the edges in $M \\oplus M'$ has a specific structure. Since every vertex is an endpoint of exactly one edge in $M$ and exactly one edge in $M'$, every vertex in the subgraph $(U \\cup V, M \\oplus M')$ must have a degree of $2$. A graph in which every vertex has degree $2$ is a disjoint union of cycles. Furthermore, because the edges come from the symmetric difference of two matchings, the edges in each cycle must alternate between being in $M$ and being in $M'$. Such a cycle is called an **$M$-alternating cycle**.\n\nThis leads to the central theorem for uniqueness: A perfect matching $M$ is unique if and only if there are no $M$-alternating cycles in the graph $G$.\n\nThe existence of an $M$-alternating cycle implies the existence of another perfect matching. If we have an $M$-alternating cycle, we can swap the matching and non-matching edges along this cycle to produce a new set of edges $M' = M \\oplus C$, which is also a perfect matching. Conversely, if two perfect matchings $M$ and $M'$ exist, their symmetric difference $M \\oplus M'$ necessarily forms one or more disjoint $M$-alternating cycles.\n\nTherefore, the problem of checking uniqueness reduces to searching for an $M$-alternating cycle with respect to the perfect matching $M$ found in Step 1. This can be done efficiently by constructing a directed graph $D_M$ from $G$ and $M$:\n- The vertex set of $D_M$ is $U \\cup V$.\n- For each edge $(u, v) \\in E$ that is **not** in the matching $M$ (i.e., $(u, v) \\in E \\setminus M$), we add a directed edge from $u$ to $v$.\n- For each edge $(u, v) \\in E$ that **is** in the matching $M$ (i.e., $(u, v) \\in M$), we add a directed edge from $v$ to $u$.\n\nAn $M$-alternating cycle in the undirected graph $G$, such as $u_0 - v_0 - u_1 - v_1 - \\dots - u_k - v_k - u_0$, where $(u_i,v_i) \\notin M$ and $(u_{i+1},v_i) \\in M$, corresponds precisely to a directed cycle $u_0 \\to v_0 \\to u_1 \\to v_1 \\to \\dots \\to u_k \\to v_k \\to u_0$ in the directed graph $D_M$.\n\nWe can detect a cycle in the directed graph $D_M$ using a standard Depth-First Search (DFS). During the traversal, we maintain the state of each vertex: unvisited (white), currently in the recursion stack (gray), or completely visited (black). If the DFS from a vertex encounters a gray vertex, a back edge has been found, which indicates a cycle.\n\nThis cycle detection algorithm runs in time linear in the size of the directed graph, which is $O(|U|+|V| + |E|)$, satisfying the problem's efficiency constraint for the uniqueness-checking phase.\n\nIf a cycle is detected in $D_M$, the perfect matching $M$ is not unique. If the DFS completes without finding any cycles, no $M$-alternating cycles exist, and the perfect matching $M$ is unique.\n\n**Summary of the Algorithm:**\n1.  Given a bipartite graph $G=(U \\cup V, E)$, check if $|U| = |V|$. If not, return $False$. Let $n = |U|$.\n2.  Use the Hopcroft-Karp algorithm to compute a maximum matching $M$.\n3.  Check if $|M| = n$. If not, return $False$.\n4.  Construct the directed graph $D_M$ as described above.\n5.  Perform a DFS-based cycle detection on $D_M$.\n6.  If a cycle is found, return $False$ (not unique).\n7.  If no cycle is found, return $True$ (unique).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the unique perfect matching problem for a fixed test suite.\n    \"\"\"\n    \n    # Each test case is a tuple: (size_U, size_V, list_of_edges)\n    test_cases = [\n        (2, 2, [(0, 0), (1, 1), (0, 1)]),\n        (2, 2, [(0, 0), (0, 1), (1, 0), (1, 1)]),\n        (3, 3, [(0, 0), (1, 0), (2, 1)]),\n        (4, 4, [(0, 0), (0, 1), (0, 2), (0, 3), (1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]),\n        (3, 3, [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2), (0, 2)])\n    ]\n\n    results = []\n    for u_size, v_size, edges in test_cases:\n        results.append(has_unique_perfect_matching(u_size, v_size, edges))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef has_unique_perfect_matching(u_size, v_size, edges):\n    \"\"\"\n    Determines if a bipartite graph has a unique perfect matching.\n    \n    Args:\n        u_size (int): Number of vertices in partition U.\n        v_size (int): Number of vertices in partition V.\n        edges (list of tuples): The edge set E.\n\n    Returns:\n        bool: True if a unique perfect matching exists, False otherwise.\n    \"\"\"\n    if u_size != v_size:\n        return False\n    \n    if u_size == 0:\n        return True # An empty graph has a unique perfect matching (the empty set).\n\n    n = u_size\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n    \n    # Step 1  2: Find a maximum matching using Hopcroft-Karp\n    hk = HopcroftKarp(n, n, adj)\n    matching_size, match_u, match_v = hk.get_max_matching()\n\n    # Step 3: Check if the matching is perfect\n    if matching_size  n:\n        return False\n\n    # Step 4: Check for uniqueness by searching for M-alternating cycles\n    # Build the directed graph D_M\n    # Vertices u in U are 0..n-1. Vertices v in V are n..n+n-1.\n    total_vertices = 2 * n\n    directed_adj = [[] for _ in range(total_vertices)]\n    \n    for u in range(n):\n        for v in adj[u]:\n            if match_u[u] == v:\n                # Edge is in the matching M: add directed edge v -> u\n                directed_adj[n + v].append(u)\n            else:\n                # Edge is not in M: add directed edge u -> v\n                directed_adj[u].append(n + v)\n\n    # Step 5: Perform DFS-based cycle detection on D_M\n    # 0: white (unvisited), 1: gray (visiting), 2: black (visited)\n    visited = np.zeros(total_vertices, dtype=int)\n    \n    for i in range(total_vertices):\n        if visited[i] == 0:\n            recursion_stack = np.zeros(total_vertices, dtype=bool)\n            if dfs_cycle_check(i, directed_adj, visited, recursion_stack):\n                return False # Cycle found, not unique\n\n    return True # No cycles found, unique\n\ndef dfs_cycle_check(v, adj, visited, recursion_stack):\n    \"\"\"\n    Helper DFS function to detect cycles in a directed graph.\n    \"\"\"\n    visited[v] = 1\n    recursion_stack[v] = True\n    \n    for neighbor in adj[v]:\n        if visited[neighbor] == 0:\n            if dfs_cycle_check(neighbor, adj, visited, recursion_stack):\n                return True\n        elif recursion_stack[neighbor]: # Back edge found\n            return True\n            \n    recursion_stack[v] = False\n    return False\n\nclass HopcroftKarp:\n    \"\"\"Implementation of the Hopcroft-Karp algorithm.\"\"\"\n    \n    def __init__(self, u_size, v_size, adj):\n        self.u_size = u_size\n        self.v_size = v_size\n        self.adj = adj\n        self.NIL = -1\n        self.match_u = np.full(u_size, self.NIL, dtype=int)\n        self.match_v = np.full(v_size, self.NIL, dtype=int)\n        self.dist = np.full(u_size, -1, dtype=int)\n\n    def bfs(self):\n        \"\"\"\n        Builds layers of augmenting paths.\n        Returns True if an augmenting path is found, False otherwise.\n        \"\"\"\n        self.dist.fill(-1)\n        queue = []\n        for u in range(self.u_size):\n            if self.match_u[u] == self.NIL:\n                self.dist[u] = 0\n                queue.append(u)\n        \n        path_found = False\n        head = 0\n        while head  len(queue):\n            u = queue[head]\n            head += 1\n            for v in self.adj[u]:\n                matched_u = self.match_v[v]\n                if matched_u == self.NIL:\n                    path_found = True\n                elif self.dist[matched_u] == -1:\n                    self.dist[matched_u] = self.dist[u] + 1\n                    queue.append(matched_u)\n        return path_found\n\n    def dfs(self, u, ptr):\n        \"\"\"\n        Finds an augmenting path starting from u.\n        \"\"\"\n        for i in range(ptr[u], len(self.adj[u])):\n            ptr[u] = i + 1\n            v = self.adj[u][i]\n            matched_u = self.match_v[v]\n            if matched_u == self.NIL or \\\n               (self.dist[matched_u] == self.dist[u] + 1 and self.dfs(matched_u, ptr)):\n                self.match_u[u] = v\n                self.match_v[v] = u\n                return True\n        return False\n\n    def get_max_matching(self):\n        \"\"\"\n        Computes the maximum matching.\n        \n        Returns:\n            A tuple (matching_size, match_u, match_v).\n        \"\"\"\n        matching_size = 0\n        while self.bfs():\n            ptr = np.zeros(self.u_size, dtype=int)\n            for u in range(self.u_size):\n                if self.match_u[u] == self.NIL:\n                    if self.dfs(u, ptr):\n                        matching_size += 1\n        return matching_size, self.match_u, self.match_v\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3250170"}]}