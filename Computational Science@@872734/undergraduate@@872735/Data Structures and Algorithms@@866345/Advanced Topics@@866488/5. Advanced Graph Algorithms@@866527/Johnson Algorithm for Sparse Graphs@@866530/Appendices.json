{"hands_on_practices": [{"introduction": "The ingenuity of Johnson's algorithm lies in its reweighting scheme, a clever transformation that eliminates negative edge weights. This first exercise invites you to delve into the core mechanics of this process by proving a fundamental property of the reweighted graph. By deriving the tightest possible upper bound for a new edge weight, you will connect the local change at an edge to the global structure of the graph, solidifying your understanding of how potentials work [@problem_id:3242440].", "problem": "Consider a directed graph $G=(V,E)$ with a weight function $w:E \\to \\mathbb{R}$ and assume $G$ has no negative-weight cycles. For the purpose of computing all-pairs shortest paths on sparse graphs, Johnson’s algorithm adds a new source vertex $s'$ and zero-weight edges $(s',v)$ for each $v \\in V$, then runs the Bellman–Ford algorithm from $s'$ to compute a potential function $h:V \\to \\mathbb{R}$ where $h(v)$ equals the shortest-path distance from $s'$ to $v$ in the augmented graph $G'$. The algorithm then reweights every edge $(u,v) \\in E$ to $w'(u,v)$ using the potential function. Let $d(x,y)$ denote the shortest-path distance between $x$ and $y$ in the original graph $G$ (with weight function $w$), which is well-defined because $G$ has no negative-weight cycles.\n\nStarting from fundamental definitions of shortest-path distance and path concatenation, derive the tightest possible upper bound on the reweighted edge weight $w'(u,v)$ for an arbitrary edge $(u,v) \\in E$, expressed solely in terms of $w(u,v)$ and quantities determined by the original graph $G$ prior to augmentation and reweighting. Your final answer must be a single closed-form analytical expression. No rounding is required.", "solution": "The problem statement is critically validated and is found to be self-contained, scientifically grounded in the theory of algorithms, and well-posed. It is free from any of the flaws listed in the validation criteria. Therefore, a formal solution is derived below.\n\nLet $G=(V,E)$ be a directed graph with a real-valued weight function $w:E \\to \\mathbb{R}$ and no negative-weight cycles. Let $(u,v)$ be an arbitrary edge in $E$. The problem asks for the tightest possible upper bound on the reweighted edge weight $w'(u,v)$ as defined in Johnson's algorithm.\n\nThe reweighting process in Johnson's algorithm depends on a potential function $h:V \\to \\mathbb{R}$. The reweighted edge weight $w'(u,v)$ for an edge $(u,v) \\in E$ is defined as:\n$$w'(u,v) = w(u,v) + h(u) - h(v)$$\n\nThe potential $h(v)$ for each vertex $v \\in V$ is computed by introducing a new vertex $s'$ to form an augmented graph $G'$. In $G'$, for every vertex $v \\in V$, a new edge $(s',v)$ is added with weight $w(s',v)=0$. The potential $h(v)$ is then defined as the shortest-path distance from $s'$ to $v$ in this augmented graph $G'$. We denote the shortest-path distance from a vertex $x$ to a vertex $y$ in the original graph $G$ as $d(x,y)$. Since $G$ has no negative-weight cycles, $d(x,y)$ is well-defined for all $x,y \\in V$.\n\nA path from $s'$ to $v$ in $G'$ must begin with an edge of the form $(s',x)$ for some $x \\in V$, followed by a path from $x$ to $v$ using only edges from the original graph $G$. The weight of such a path is $w(s',x) + \\text{weight}(\\text{path } x \\to v) = 0 + \\text{weight}(\\text{path } x \\to v)$. To find the shortest-path distance from $s'$ to $v$, we must find the path of minimum weight among all possible choices for the first vertex $x$. The subpath from $x$ to $v$ must itself be a shortest path in $G$. Thus, the potential $h(v)$ can be expressed in terms of shortest-path distances in the original graph $G$:\n$$h(v) = \\delta_{G'}(s',v) = \\min_{x \\in V} \\{d(x,v)\\}$$\nNote that since there are no negative-weight cycles in $G$, $d(x,x)=0$ for any $x \\in V$. Therefore, $h(v) = \\min_{x \\in V} \\{d(x,v)\\} \\le d(v,v) = 0$, so $h(v) \\le 0$ for all $v \\in V$.\n\nOur goal is to find an upper bound for $w'(u,v) = w(u,v) + h(u) - h(v)$. This is equivalent to finding an upper bound for the term $h(u) - h(v)$.\n\nBy the definition of shortest paths in $G$, the triangle inequality holds. For any three vertices $x, v, u \\in V$, the shortest path from $x$ to $u$ cannot be longer than the path that goes from $x$ to $v$ along a shortest path and then from $v$ to $u$ along a shortest path. This gives the inequality:\n$$d(x,u) \\le d(x,v) + d(v,u)$$\nIf there is no path from $v$ to $u$, then $d(v,u) = \\infty$, and the inequality holds trivially.\n\nThis inequality is valid for any choice of vertex $x \\in V$. Since it holds for all $x$, it must also hold for the minimum taken over all $x \\in V$.\n$$\\min_{x \\in V} \\{d(x,u)\\} \\le \\min_{x \\in V} \\{d(x,v) + d(v,u)\\}$$\nThe term $d(v,u)$ is a fixed value with respect to the minimization over $x$. Therefore, it can be factored out of the minimization on the right-hand side:\n$$\\min_{x \\in V} \\{d(x,u)\\} \\le \\left(\\min_{x \\in V} \\{d(x,v)\\}\\right) + d(v,u)$$\nSubstituting the definition of the potential function $h$, we get:\n$$h(u) \\le h(v) + d(v,u)$$\nRearranging this inequality provides an upper bound for the difference $h(u) - h(v)$:\n$$h(u) - h(v) \\le d(v,u)$$\nNow, we substitute this result back into the expression for the reweighted edge $(u,v)$:\n$$w'(u,v) = w(u,v) + h(u) - h(v) \\le w(u,v) + d(v,u)$$\nThis gives an upper bound on $w'(u,v)$ expressed entirely in terms of quantities from the original graph $G$: the weight of the edge itself, $w(u,v)$, and the shortest-path distance from $v$ back to $u$, $d(v,u)$.\n\nTo show this is the tightest possible upper bound, we must demonstrate that this bound can be achieved for some graph $G$ and some edge $(u,v) \\in E$. Equality holds if and only if $h(u)-h(v) = d(v,u)$.\n\nConsider a graph $G=(V,E)$ with $V=\\{u, v, z\\}$ and edge set $E = \\{(u,v), (v,u), (z,v)\\}$. Let the weights be defined as $w(u,v) = 10$, $w(v,u) = 2$, and $w(z,v)=-5$.\nThe graph has no negative-weight cycles, as the only cycle $u \\to v \\to u$ has a weight of $w(u,v)+w(v,u) = 10+2=12 > 0$.\n\nLet's compute the necessary shortest-path distances $d(x,y)$ in $G$:\n$d(v,u) = w(v,u) = 2$.\n$d(z,v) = w(z,v) = -5$.\n$d(z,u)$ is the shortest path from $z$ to $u$. The path $z \\to v \\to u$ has weight $w(z,v)+w(v,u) = -5+2=-3$. This is the only path, so $d(z,u)=-3$.\n\nNow we compute the potentials $h(u)$ and $h(v)$:\n$h(u) = \\min\\{d(u,u), d(v,u), d(z,u)\\} = \\min\\{0, 2, -3\\} = -3$.\n$h(v) = \\min\\{d(u,v), d(v,v), d(z,v)\\} = \\min\\{10, 0, -5\\} = -5$.\n\nUsing these potentials, we find the reweighted edge weight $w'(u,v)$:\n$w'(u,v) = w(u,v) + h(u) - h(v) = 10 + (-3) - (-5) = 10 - 3 + 5 = 12$.\n\nNow, let's evaluate the derived upper bound for this specific edge:\n$w(u,v) + d(v,u) = 10 + 2 = 12$.\n\nSince $w'(u,v) = 12$ and the upper bound evaluates to $12$, the bound is achieved. This demonstrates that the bound $w(u,v) + d(v,u)$ is indeed the tightest possible upper bound.", "answer": "$$\\boxed{w(u,v) + d(v,u)}$$", "id": "3242440"}, {"introduction": "Complex algorithms often rely on a chain of invariants, where the output of one stage guarantees the correct operation of the next. What happens when this chain is broken? This problem presents a hypothetical scenario where the Bellman-Ford stage of Johnson's algorithm is cut short, leading to flawed potentials. By quantifying the resulting error, you will appreciate why each step is critical and how failures can cascade, offering a practical lesson in algorithmic robustness [@problem_id:3242397].", "problem": "Consider a directed graph $G = (V,E)$ with $V = \\{v_{1}, v_{2}, v_{3}\\}$ and edge-weight function $w : E \\to \\mathbb{R}$ given by the edges $(v_{1}, v_{2})$ with weight $w(v_{1}, v_{2}) = 1$, $(v_{1}, v_{3})$ with weight $w(v_{1}, v_{3}) = 0$, and $(v_{2}, v_{3})$ with weight $w(v_{2}, v_{3}) = -2$. There are no other edges. Assume there are no negative-weight cycles in $G$.\n\nJohnson’s algorithm augments $G$ with a super-source $s'$ and edges $(s', v)$ of weight $0$ for every $v \\in V$, then runs the Bellman–Ford algorithm from $s'$ to obtain a vertex potential function and uses those potentials to reweight edges, after which Dijkstra’s algorithm is run from each source to produce all-pairs shortest path distances that are finally mapped back to the original weights.\n\nIn this problem, the Bellman–Ford step is terminated early after exactly one relaxation iteration, producing an approximate potential function $\\tilde{h}$, and the algorithm proceeds to reweight and run Dijkstra’s algorithm as usual to produce reported distances for all ordered pairs $(u,v) \\in V \\times V$ under the original weights.\n\nUsing only the definitions of shortest path distance, the property that after $k$ relaxation iterations Bellman–Ford yields correct distances for all paths with at most $k$ edges from the source, and the requirement of Dijkstra’s algorithm that edge weights be nonnegative, determine the maximum absolute error over all ordered pairs $(u,v) \\in V \\times V$ between the distances reported by this early-terminated Johnson’s algorithm and the true shortest path distances in $G$. Express your final answer as a single real number. No rounding is required.", "solution": "The problem statement is validated as being scientifically grounded, well-posed, and objective. It provides a complete and consistent description of a directed graph and a modified version of Johnson's algorithm. The task is to analyze the consequences of this modification, which is a formalizable problem in the domain of algorithms. There are no contradictions, ambiguities, or factual unsoundness. We may proceed with the solution.\n\nThe solution involves three main parts:\n1.  Calculating the true all-pairs shortest path distances in the given graph $G$.\n2.  Simulating the described early-terminated Johnson's algorithm to find the reported all-pairs shortest path distances.\n3.  Comparing the true and reported distances to find the maximum absolute error.\n\n**Part 1: True Shortest Path Distances**\n\nThe graph is $G=(V, E)$ with $V = \\{v_1, v_2, v_3\\}$ and edges with weights $w(v_1, v_2) = 1$, $w(v_1, v_3) = 0$, and $w(v_2, v_3) = -2$. The graph is a Directed Acyclic Graph (DAG), so shortest paths are well-defined. We denote the true shortest path distance from vertex $u$ to vertex $v$ as $\\delta(u,v)$.\n\n-   Paths from $v_1$:\n    -   To $v_1$: The shortest path is of length $0$. $\\delta(v_1, v_1) = 0$.\n    -   To $v_2$: The only path is $v_1 \\to v_2$. $\\delta(v_1, v_2) = w(v_1, v_2) = 1$.\n    -   To $v_3$: There are two paths: $v_1 \\to v_3$ with weight $0$, and $v_1 \\to v_2 \\to v_3$ with weight $w(v_1, v_2) + w(v_2, v_3) = 1 + (-2) = -1$. The shortest path has weight $-1$. So, $\\delta(v_1, v_3) = -1$.\n-   Paths from $v_2$:\n    -   To $v_2$: The shortest path is of length $0$. $\\delta(v_2, v_2) = 0$.\n    -   To $v_3$: The only path is $v_2 \\to v_3$. $\\delta(v_2, v_3) = w(v_2, v_3) = -2$.\n    -   To $v_1$: There is no path. $\\delta(v_2, v_1) = \\infty$.\n-   Paths from $v_3$:\n    -   To $v_3$: The shortest path is of length $0$. $\\delta(v_3, v_3) = 0$.\n    -   To $v_1$ and $v_2$: There are no paths. $\\delta(v_3, v_1) = \\infty$ and $\\delta(v_3, v_2) = \\infty$.\n\nThe matrix of true shortest path distances is:\n$$ \\delta = \\begin{pmatrix} \\delta(v_1, v_1) & \\delta(v_1, v_2) & \\delta(v_1, v_3) \\\\ \\delta(v_2, v_1) & \\delta(v_2, v_2) & \\delta(v_2, v_3) \\\\ \\delta(v_3, v_1) & \\delta(v_3, v_2) & \\delta(v_3, v_3) \\end{pmatrix} = \\begin{pmatrix} 0 & 1 & -1 \\\\ \\infty & 0 & -2 \\\\ \\infty & \\infty & 0 \\end{pmatrix} $$\n\n**Part 2: Modified Johnson's Algorithm Simulation**\n\nWe follow the steps described in the problem.\n\n**Step A: Augment Graph and Run Partial Bellman-Ford**\nThe graph $G$ is augmented with a new source vertex $s'$ and zero-weight edges $(s', v_i)$ for each $v_i \\in V$. The Bellman-Ford algorithm is run from $s'$ for exactly one relaxation iteration.\n\nThe potential $\\tilde{h}(v)$ for a vertex $v$ is the shortest path distance from $s'$ to $v$ using at most one edge. The initial distances from $s'$ are $\\tilde{h}(s') = 0$ and $\\tilde{h}(v_i) = \\infty$ for $i \\in \\{1, 2, 3\\}$.\nAfter one relaxation across the edges from $s'$:\n-   $\\tilde{h}(v_1) = \\min(\\infty, \\tilde{h}(s') + w(s', v_1)) = \\min(\\infty, 0 + 0) = 0$.\n-   $\\tilde{h}(v_2) = \\min(\\infty, \\tilde{h}(s') + w(s', v_2)) = \\min(\\infty, 0 + 0) = 0$.\n-   $\\tilde{h}(v_3) = \\min(\\infty, \\tilde{h}(s') + w(s', v_3)) = \\min(\\infty, 0 + 0) = 0$.\n\nThe resulting approximate potential function is $\\tilde{h}(v_1) = 0$, $\\tilde{h}(v_2) = 0$, and $\\tilde{h}(v_3) = 0$.\n\n**Step B: Reweight Edges**\nThe new edge weights $\\tilde{w}(u,v)$ are calculated using the formula $\\tilde{w}(u,v) = w(u,v) + \\tilde{h}(u) - \\tilde{h}(v)$.\nSince $\\tilde{h}(u) = \\tilde{h}(v) = 0$ for all $u,v \\in V$, the reweighted edges are identical to the original weights: $\\tilde{w}(u,v) = w(u,v)$.\nThe reweighted graph has edges $(\\tilde{w}(v_1, v_2) = 1)$, $(\\tilde{w}(v_1, v_3) = 0)$, and $(\\tilde{w}(v_2, v_3) = -2)$.\n\n**Step C: Run Dijkstra's Algorithm**\nDijkstra's algorithm is run from each vertex $u \\in V$ on the reweighted graph. Crucially, the reweighted graph contains a negative edge, $\\tilde{w}(v_2, v_3) = -2$. Dijkstra's algorithm is not guaranteed to produce correct shortest-path distances in the presence of negative-weight edges. We simulate its standard behavior. Let $\\tilde{\\delta}_{\\tilde{w}}(u,v)$ be the distance from $u$ to $v$ reported by Dijkstra's on this graph.\n\n-   **From $v_1$**:\n    1.  Initialize distances: $d(v_1)=0, d(v_2)=\\infty, d(v_3)=\\infty$. Priority Queue (PQ): $\\{(v_1, 0)\\}$.\n    2.  Extract $v_1$ (cost $0$). Relax its edges:\n        -   $(v_1, v_2)$: Updates $d(v_2)=1$. Add $(v_2, 1)$ to PQ.\n        -   $(v_1, v_3)$: Updates $d(v_3)=0$. Add $(v_3, 0)$ to PQ.\n    3.  PQ is now $\\{(v_3, 0), (v_2, 1)\\}$. Extract $v_3$ (cost $0$). Mark $v_3$ as visited. No outgoing edges.\n    4.  PQ is now $\\{(v_2, 1)\\}$. Extract $v_2$ (cost $1$). Mark $v_2$ as visited. Relax its edge $(v_2, v_3)$ with weight $-2$. The path through $v_2$ to $v_3$ has cost $d(v_2) + \\tilde{w}(v_2, v_3) = 1 + (-2) = -1$. However, since $v_3$ is already marked as visited, a standard Dijkstra's implementation does not update its distance.\n    5.  Algorithm terminates. The reported distances from $v_1$ are $\\tilde{\\delta}_{\\tilde{w}}(v_1, v_1) = 0$, $\\tilde{\\delta}_{\\tilde{w}}(v_1, v_2) = 1$, and $\\tilde{\\delta}_{\\tilde{w}}(v_1, v_3) = 0$. This is incorrect; the true shortest path from $v_1$ to $v_3$ in this graph has weight $-1$.\n\n-   **From $v_2$**:\n    1.  Initialize $d(v_2)=0$. PQ: $\\{(v_2, 0)\\}$.\n    2.  Extract $v_2$. Relax $(v_2, v_3)$: updates $d(v_3)=-2$. Add $(v_3, -2)$ to PQ.\n    3.  Extract $v_3$. No outgoing edges.\n    4.  Algorithm terminates. Reported distances: $\\tilde{\\delta}_{\\tilde{w}}(v_2, v_2)=0, \\tilde{\\delta}_{\\tilde{w}}(v_2, v_3)=-2$. These are correct for this subgraph.\n\n-   **From $v_3$**: No outgoing edges. Reported distances: $\\tilde{\\delta}_{\\tilde{w}}(v_3, v_3)=0$.\n\nThe matrix of distances found by Dijkstra's algorithm is:\n$$ \\tilde{\\delta}_{\\tilde{w}} = \\begin{pmatrix} 0 & 1 & 0 \\\\ \\infty & 0 & -2 \\\\ \\infty & \\infty & 0 \\end{pmatrix} $$\n\n**Step D: Convert Distances Back**\nThe final reported distances $\\tilde{\\delta}(u,v)$ are computed as $\\tilde{\\delta}(u,v) = \\tilde{\\delta}_{\\tilde{w}}(u,v) - \\tilde{h}(u) + \\tilde{h}(v)$.\nSince all $\\tilde{h}(v_i) = 0$, we have $\\tilde{\\delta}(u,v) = \\tilde{\\delta}_{\\tilde{w}}(u,v)$.\nSo, the final reported distance matrix is:\n$$ \\tilde{\\delta} = \\begin{pmatrix} 0 & 1 & 0 \\\\ \\infty & 0 & -2 \\\\ \\infty & \\infty & 0 \\end{pmatrix} $$\n\n**Part 3: Maximum Absolute Error**\n\nWe compute the element-wise absolute difference between the reported distances $\\tilde{\\delta}$ and the true distances $\\delta$.\n$$ |\\tilde{\\delta} - \\delta| = \\left| \\begin{pmatrix} 0 & 1 & 0 \\\\ \\infty & 0 & -2 \\\\ \\infty & \\infty & 0 \\end{pmatrix} - \\begin{pmatrix} 0 & 1 & -1 \\\\ \\infty & 0 & -2 \\\\ \\infty & \\infty & 0 \\end{pmatrix} \\right| $$\nThe only entry where the finite distances differ is for the pair $(v_1, v_3)$.\n-   Error for $(v_1, v_3)$: $|\\tilde{\\delta}(v_1, v_3) - \\delta(v_1, v_3)| = |0 - (-1)| = 1$.\n-   For all other pairs $(u,v)$ with finite distances, the error is $0$.\n-   For pairs with infinite distances, the error is considered $0$.\n\nThe matrix of absolute errors is:\n$$ |\\tilde{\\delta} - \\delta| = \\begin{pmatrix} 0 & 0 & 1 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} $$\nThe maximum value in this matrix is $1$.\nTherefore, the maximum absolute error over all ordered pairs $(u,v) \\in V \\times V$ is $1$.", "answer": "$$ \\boxed{1} $$", "id": "3242397"}, {"introduction": "Theory and analysis pave the way for practical application. This final challenge moves from thought experiments to tangible code, asking you to implement Johnson's algorithm in its entirety. You will orchestrate the Bellman-Ford preprocessing, the reweighting step, and the multiple runs of Dijkstra's algorithm. More than just computing distances, you will also generate a predecessor matrix to reconstruct the shortest paths, turning an abstract algorithm into a powerful tool for graph analysis [@problem_id:3242404].", "problem": "You are given a directed, weighted graph $G = (V,E)$ with vertices indexed $V = \\{0,1,\\dots,n-1\\}$ and real-valued edge weights. A path $P = (v_0,v_1,\\dots,v_k)$ has weight defined by the sum of its edge weights, namely $$W(P) = \\sum_{i=0}^{k-1} w(v_i,v_{i+1}).$$ The shortest-path distance from a source $s$ to a vertex $t$ is defined as $$d(s,t) = \\min_{P \\in \\mathcal{P}(s,t)} W(P),$$ where $\\mathcal{P}(s,t)$ is the set of all directed paths from $s$ to $t$. If no path exists, $d(s,t)$ is defined to be $+\\infty$.\n\nThe goal is to implement a version of Johnson’s algorithm for sparse graphs that produces two artifacts:\n- An all-pairs distance matrix $D$ such that $D[s][t] = d(s,t)$ for all $s,t \\in V$.\n- A compact all-pairs shortest-path representation via a predecessor matrix $P$ such that $P[s][t]$ is the index of the predecessor of vertex $t$ on one of the shortest paths from $s$ to $t$ in the original graph $G$. If $t=s$ or $t$ is unreachable from $s$, then $P[s][t] = -1$.\n\nYou must base your approach on fundamental definitions of shortest paths, the correctness of reweighting under potential functions, and well-established algorithms for Single-Source Shortest Path (SSSP) such as the Bellman–Ford algorithm and Dijkstra’s algorithm. You must detect the presence of any negative-weight cycle in the graph. If a negative-weight cycle is detected, Johnson’s algorithm is invalid for the graph; in that case, define the output for the graph as follows: the boolean flag is `false` and both the flattened distance matrix and the flattened predecessor matrix are empty lists.\n\nYour program must be a complete, runnable implementation that, for each provided test case, returns three items:\n- A boolean $b$ that is `true` if no negative-weight cycle is detected and `false` otherwise.\n- A flattened list of the all-pairs distances, ordered by sources first and then targets, that is, $(D[0][0],D[0][1],\\dots,D[0][n-1],D[1][0],\\dots,D[n-1][n-1])$.\n- A flattened list of the all-pairs predecessors, ordered in the same way, that is, $(P[0][0],P[0][1],\\dots,P[0][n-1],P[1][0],\\dots,P[n-1][n-1])$.\n\nIf a vertex $t$ is unreachable from source $s$ then $D[s][t]$ must be $+\\infty$; express this in your output using the programming language’s floating-point representation of positive infinity. For any $t$ such that $t=s$ or $t$ is unreachable from $s$, set $P[s][t] = -1$.\n\nTest Suite:\nUse the following graphs as test cases. Each test case is described by the number of vertices $n$ and a list of directed edges $(u,v,w)$ with $u,v \\in \\{0,1,\\dots,n-1\\}$ and weight $w$.\n\n- Test case $1$ (happy path, sparse, negative edges but no negative cycle): $n = 5$ with edges\n  $(0,1,-2)$, $(1,2,3)$, $(0,3,4)$, $(3,4,1)$, $(4,2,-1)$, $(1,4,2)$.\n- Test case $2$ (boundary: no edges): $n = 4$ with edges\n  (none).\n- Test case $3$ (edge case: single-vertex graph): $n = 1$ with edges\n  (none).\n- Test case $4$ (negative cycle present): $n = 3$ with edges\n  $(0,1,1)$, $(1,2,-2)$, $(2,0,0)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element in this list corresponds to one test case and must itself be a three-element list $[b,\\text{distances\\_flat},\\text{predecessors\\_flat}]$, where $b$ is a boolean, $\\text{distances\\_flat}$ is the flattened list of distances, and $\\text{predecessors\\_flat}$ is the flattened list of predecessors. For example, the printed output should look like \n$[[b_1,[d_{1,0},d_{1,1},\\dots],[p_{1,0},p_{1,1},\\dots]],[b_2,[\\dots],[\\dots]],\\dots]$.\n\nYour implementation must not read any input and must run as-is to produce the specified output for the provided test suite.", "solution": "The problem requires the computation of all-pairs shortest paths in a directed, weighted graph $G=(V, E)$. The presence of real-valued edge weights, including potentially negative ones, necessitates a careful choice of algorithm. Running Dijkstra's algorithm from each vertex is invalid, as its correctness relies on non-negative edge weights. Executing the Bellman-Ford algorithm from each vertex is a valid but inefficient approach, with a time complexity of $O(|V|^2|E|)$, which is prohibitive for large graphs. Johnson's algorithm presents an elegant and more efficient method, particularly for sparse graphs, by reweighting the edges to eliminate negative weights, thereby permitting the use of the faster Dijkstra's algorithm.\n\nThe core principle of Johnson's algorithm is based on a potential function $h: V \\to \\mathbb{R}$. For each edge $(u, v) \\in E$ with original weight $w(u, v)$, we define a new, reweighted edge weight $w_h(u, v)$ as:\n$$w_h(u, v) = w(u, v) + h(u) - h(v)$$\n\nThis reweighting scheme has a remarkable property: it preserves the shortest paths. Consider any path $P = (v_0, v_1, \\dots, v_k)$ from a source $s=v_0$ to a target $t=v_k$. The weight of this path in the reweighted graph, $W_h(P)$, is:\n$$W_h(P) = \\sum_{i=0}^{k-1} w_h(v_i, v_{i+1}) = \\sum_{i=0}^{k-1} (w(v_i, v_{i+1}) + h(v_i) - h(v_{i+1}))$$\nThis sum telescopes, yielding:\n$$W_h(P) = \\left(\\sum_{i=0}^{k-1} w(v_i, v_{i+1})\\right) + h(v_0) - h(v_k) = W(P) + h(s) - h(t)$$\nSince $h(s)$ and $h(t)$ are constant for any path from $s$ to $t$, a path has the minimum original weight $W(P)$ if and only if it has the minimum reweighted weight $W_h(P)$. Thus, shortest paths are invariant under this transformation.\n\nThe challenge is to find a potential function $h$ such that all reweighted edges are non-negative, i.e., $w_h(u, v) \\ge 0$ for all $(u, v) \\in E$. This condition is equivalent to:\n$$w(u, v) + h(u) - h(v) \\ge 0 \\implies h(v) \\le h(u) + w(u, v)$$\nThis inequality is the triangle inequality, which is fundamental to shortest path algorithms. This suggests that the potentials $h(v)$ can be defined as shortest path distances from some source vertex.\n\nTo construct such a potential function, we augment the original graph $G$ to create a new graph $G' = (V', E')$. We add a new source vertex $s'$, not in $V$, to form $V' = V \\cup \\{s'\\}$. We then add zero-weight directed edges from $s'$ to every vertex $v \\in V$, creating $E' = E \\cup \\{(s', v) \\mid v \\in V, w(s', v) = 0\\}$.\n\nWe then use the Bellman-Ford algorithm to compute the shortest path distances from $s'$ to all other vertices in $G'$. Let us define our potential function $h(v)$ as the shortest path distance from $s'$ to $v$ in $G'$, i.e., $h(v) = d_{G'}(s', v)$. By the triangle inequality property of shortest paths, for any edge $(u,v) \\in E \\subset E'$, we must have $d_{G'}(s', v) \\le d_{G'}(s', u) + w(u, v)$, which is precisely $h(v) \\le h(u) + w(u, v)$. This guarantees that our chosen potentials will result in non-negative reweighted edges $w_h(u,v) \\ge 0$.\n\nThe Bellman-Ford algorithm also serves a crucial secondary purpose: detecting negative-weight cycles. If the graph $G$ contains a negative-weight cycle, then $G'$ will also contain one. Bellman-Ford can detect such a cycle; if after $|V'|-1$ relaxation passes, a distance can still be reduced, a negative-weight cycle accessible from the source exists. As $s'$ connects to all original vertices, any negative cycle in $G$ is reachable. If such a cycle is detected, Johnson's algorithm cannot proceed, and we must report this failure.\n\nIf no negative-weight cycles are found, the algorithm proceeds as follows:\n1.  **Augmentation:** Construct the graph $G'$ by adding a new source vertex $s'$ and zero-weight edges $(s', v)$ for all $v \\in V$.\n2.  **Reweighting Potential Calculation:** Run the Bellman-Ford algorithm on $G'$ with source $s'$. If it detects a negative-weight cycle, terminate and report the invalidity of the graph. Otherwise, set the potential of each vertex $v \\in V$ to $h(v) = d_{G'}(s', v)$.\n3.  **Graph Reweighting:** Compute the non-negative weights $w_h(u, v) = w(u, v) + h(u) - h(v)$ for all edges in the original graph $G$.\n4.  **All-Pairs Shortest Paths via Dijkstra:** For each vertex $u \\in V$, run Dijkstra's algorithm on the reweighted graph, starting from source $u$, to find the shortest path distances $d_h(u, v)$ and predecessors for all $v \\in V$.\n5.  **Distance Conversion:** The final shortest path distances in the original graph are recovered using the inverse transformation: $d(u, v) = d_h(u, v) - h(u) + h(v)$. If $d_h(u,v)$ is infinity, $d(u,v)$ is also infinity. The predecessor matrix requires no transformation as the shortest path structure is preserved.\n\nThe overall time complexity is dominated by the Bellman-Ford step, $O(|V||E'|) = O(|V|(|V|+|E|)) = O(|V||E|)$ (since $|E| \\ge |V|-1$ in a connected graph), and $|V|$ runs of Dijkstra's algorithm. With a binary heap implementation of Dijkstra's, this step takes $O(|V|(|E|+|V|\\log|V|))$. For sparse graphs where $|E|$ is close to $|V|$, the complexity is approximately $O(|V|^2 \\log|V|)$, a significant improvement over $|V|$ runs of Bellman-Ford.\n\nThe implementation will construct the distance matrix $D$ where $D[s][t] = d(s, t)$ and the predecessor matrix $P$ where $P[s][t]$ is the predecessor of $t$ on a shortest path from $s$. Per the problem, $D[s][t] = \\infty$ if $t$ is unreachable from $s$, and $P[s][t] = -1$ if $t=s$ or $t$ is unreachable from $s$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run Johnson's algorithm on them.\n    Produces the final formatted output.\n    \"\"\"\n    \n    # Test Suite\n    test_cases = [\n        # Test case 1 (happy path, sparse, negative edges but no negative cycle)\n        {\n            \"n\": 5,\n            \"edges\": [(0, 1, -2), (1, 2, 3), (0, 3, 4), (3, 4, 1), (4, 2, -1), (1, 4, 2)]\n        },\n        # Test case 2 (boundary: no edges)\n        {\n            \"n\": 4,\n            \"edges\": []\n        },\n        # Test case 3 (edge case: single-vertex graph)\n        {\n            \"n\": 1,\n            \"edges\": []\n        },\n        # Test case 4 (negative cycle present)\n        {\n            \"n\": 3,\n            \"edges\": [(0, 1, 1), (1, 2, -2), (2, 0, 0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        edges = case[\"edges\"]\n        has_neg_cycle, dist_matrix, pred_matrix = johnson_algorithm(n, edges)\n        \n        if has_neg_cycle:\n            results.append([False, [], []])\n        else:\n            dist_flat = dist_matrix.flatten().tolist()\n            pred_flat = pred_matrix.flatten().tolist()\n            # The string conversion will handle `inf` correctly for the output format.\n            results.append([True, dist_flat, pred_flat])\n\n    # Final print statement in the exact required format.\n    # Replace single quotes with double quotes for valid JSON-like output if needed,\n    # but str() on list is sufficient for the format requested.\n    # Convert Python boolean `True`/`False` to lowercase string 'true'/'false' as per convention\n    final_output_str = str(results).replace(\"'\", '\"').replace('True', 'true').replace('False', 'false')\n    # The prompt example shows True/False with caps, let's stick to Python's default str() output\n    print(f\"[{','.join(map(str, results))}]\".replace(\"'\", \"\"))\n\n\ndef johnson_algorithm(n, edges):\n    \"\"\"\n    Implements Johnson's algorithm for all-pairs shortest paths.\n    \n    Args:\n        n (int): The number of vertices.\n        edges (list): A list of tuples (u, v, w) representing directed edges.\n        \n    Returns:\n        A tuple (has_neg_cycle, dist_matrix, pred_matrix).\n        - has_neg_cycle (bool): True if a negative-weight cycle is detected.\n        - dist_matrix (np.array): The n x n all-pairs shortest path distance matrix.\n        - pred_matrix (np.array): The n x n predecessor matrix.\n    \"\"\"\n    if n == 0:\n        return False, np.array([]), np.array([])\n\n    # Step 1: Form the augmented graph G'\n    augmented_edges = list(edges)\n    num_vertices_augmented = n + 1\n    new_source = n\n    for i in range(n):\n        augmented_edges.append((new_source, i, 0))\n\n    # Step 2: Run Bellman-Ford from the new source\n    dist_h = np.full(num_vertices_augmented, float('inf'))\n    dist_h[new_source] = 0\n\n    for _ in range(num_vertices_augmented - 1):\n        for u, v, w in augmented_edges:\n            if dist_h[u] != float('inf') and dist_h[u] + w < dist_h[v]:\n                dist_h[v] = dist_h[u] + w\n\n    # Check for negative-weight cycles\n    for u, v, w in augmented_edges:\n        if dist_h[u] != float('inf') and dist_h[u] + w < dist_h[v]:\n            return True, None, None\n            \n    h = dist_h[:n]\n\n    # Step 3: Reweight the original graph\n    adj_list_reweighted = [[] for _ in range(n)]\n    for u, v, w in edges:\n        w_h = w + h[u] - h[v]\n        adj_list_reweighted[u].append((v, w_h))\n\n    # Step 4  5: Run Dijkstra from each vertex and compute final results\n    all_pairs_dist = np.full((n, n), float('inf'))\n    all_pairs_pred = np.full((n, n), -1, dtype=int)\n\n    for s in range(n):\n        # Run Dijkstra on the reweighted graph\n        dist_reweighted, pred_reweighted = dijkstra(n, adj_list_reweighted, s)\n        \n        # Convert distances back to original weights and store results\n        all_pairs_dist[s, s] = 0\n        for t in range(n):\n            if dist_reweighted[t] != float('inf'):\n                all_pairs_dist[s, t] = dist_reweighted[t] - h[s] + h[t]\n            all_pairs_pred[s, t] = pred_reweighted[t]\n\n    return False, all_pairs_dist, all_pairs_pred\n\n\ndef dijkstra(n, adj, start_node):\n    \"\"\"\n    Dijkstra's algorithm for SSSP on a weighted graph with non-negative weights.\n    \n    Args:\n        n (int): Number of vertices.\n        adj (list): Adjacency list representation of the graph.\n        start_node (int): The source vertex.\n        \n    Returns:\n        A tuple (dist, pred):\n        - dist (np.array): Shortest path distances from the start node.\n        - pred (np.array): Predecessor array for reconstructing paths.\n    \"\"\"\n    dist = np.full(n, float('inf'))\n    pred = np.full(n, -1, dtype=int)\n    dist[start_node] = 0\n    pq = [(0, start_node)]  # (distance, vertex)\n\n    while pq:\n        d, u = heapq.heappop(pq)\n        \n        if d  dist[u]:\n            continue\n\n        for v, weight in adj[u]:\n            if dist[u] + weight  dist[v]:\n                dist[v] = dist[u] + weight\n                pred[v] = u\n                heapq.heappush(pq, (dist[v], v))\n    \n    return dist, pred\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3242404"}]}