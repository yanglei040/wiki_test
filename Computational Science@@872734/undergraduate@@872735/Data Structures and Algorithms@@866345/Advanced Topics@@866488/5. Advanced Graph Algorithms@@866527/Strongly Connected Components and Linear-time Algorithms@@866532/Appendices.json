{"hands_on_practices": [{"introduction": "The best way to truly understand a fundamental algorithm is to build it from the ground up. This practice challenges you to implement a complete, linear-time algorithm for finding Strongly Connected Components (SCCs), providing not just the code but also a rigorous proof of its correctness and a complexity analysis [@problem_id:3205772]. Engaging with this exercise will solidify your grasp of Depth-First Search and its powerful applications in graph traversal.", "problem": "Design and specify a complete algorithm to compute all Strongly Connected Components (SCCs) of a directed graph, and prove its correctness from first principles of graph reachability and Depth-First Search (DFS). You must implement the algorithm as a runnable program that outputs canonicalized SCCs for a fixed set of test graphs. Your algorithm must be either Kosaraju’s algorithm or Tarjan’s algorithm; you must make one precise choice and present a full pseudo-code specification for it.\n\nFoundational base and definitions to be used as the starting point:\n- A directed graph is an ordered pair $G=(V,E)$ where $V$ is a finite set of vertices labeled by consecutive integers $0,\\dots,n-1$ for some integer $n \\ge 0$, and $E \\subseteq V \\times V$ is a set of directed edges.\n- For $u,v \\in V$, there is a path from $u$ to $v$ if there exists a sequence of vertices $u=x_0,x_1,\\dots,x_k=v$ with $k \\ge 0$ and $(x_i,x_{i+1}) \\in E$ for all $i \\in \\{0,\\dots,k-1\\}$.\n- A subset $C \\subseteq V$ is a strongly connected component if for all $u,v \\in C$ there is a path from $u$ to $v$ and a path from $v$ to $u$, and $C$ is maximal with respect to set inclusion under this property.\n- Depth-First Search (DFS) explores paths by recursively visiting unvisited out-neighbors, and every edge $(u,v)$ is either a tree edge, back edge, forward edge, or cross edge under the standard DFS classification. The DFS finishing time of a vertex is the time it is fully explored and added to a finishing-order stack. The transpose graph $G^T=(V,E^T)$ has $E^T=\\{(v,u)\\mid (u,v)\\in E\\}$.\n- The condensation (component) graph of $G$ contracts each strongly connected component to a single vertex, yielding a Directed Acyclic Graph (DAG).\n\nYour tasks:\n1. Choose one of Kosaraju’s algorithm or Tarjan’s algorithm and provide precise, language-agnostic pseudo-code that takes as input a directed graph $G=(V,E)$ given as an adjacency list $Adj[0..n-1]$, where $Adj[u]$ enumerates all $v$ such that $(u,v)\\in E$. All intermediate variables, function names, and numbers must be written using LaTeX notation.\n2. Derive the algorithm’s correctness from first principles. Start from the above foundational definitions and well-tested facts about DFS and transpose graphs, and explain why the algorithm partitions $V$ into SCCs. Your reasoning must not rely on any unproven shortcut statements and must articulate the invariants that guarantee correctness.\n3. Analyze the running time in terms of $n=|V|$ and $m=|E|$, and state space usage.\n4. Canonicalization requirement for deterministic output: For every SCC $C$, output its vertices sorted in ascending order. For the collection of all SCCs, output the list sorted in lexicographic order of these sorted vertex lists. For the empty graph with $n=0$, the output is the empty list.\n5. Implementation requirement: Implement your chosen algorithm as a complete program that takes no input and instead runs on the following fixed test suite (graphs are given by $n$ and an adjacency list). Vertices are labeled $0$ through $n-1$.\n- Test $1$: $n=8$, edges $\\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,3),(6,7)\\}$. Adjacency list: $Adj = [[1],[2],[0,3],[4],[5],[3],[7],[]]$.\n- Test $2$: $n=0$, edges $\\emptyset$. Adjacency list: $Adj = []$.\n- Test $3$: $n=1$, edges $\\emptyset$. Adjacency list: $Adj = [[]]$.\n- Test $4$: $n=1$, edges $\\{(0,0)\\}$. Adjacency list: $Adj = [[0]]$.\n- Test $5$: $n=5$, edges $\\{(0,1),(1,2),(2,3),(3,4),(4,0),(0,2),(1,3),(2,4),(3,0),(4,1)\\}$. Adjacency list: $Adj = [[1,2],[2,3],[3,4],[4,0],[0,1]]$.\n- Test $6$: $n=6$, edges $\\{(0,1),(1,2),(3,4),(4,5)\\}$. Adjacency list: $Adj = [[1],[2],[],[4],[5],[]]$.\n\nFinal output format:\n- Your program must produce exactly one line to standard output. The line must be a single bracketed list of the results for Tests $1$ through $6$, in order. Each result is itself a list of lists of integers, canonicalized as specified. The entire line must be a single string of the form $[r_1,r_2,r_3,r_4,r_5,r_6]$, where each $r_i$ is the canonicalized list of SCCs for Test $i$. No explanatory text may be printed.\n- Answers are pure lists of integers; there are no physical units or angle units involved.", "solution": "The problem of computing Strongly Connected Components (SCCs) of a directed graph is a fundamental task in graph theory and computer science. The problem statement is valid, as it is based on standard, well-defined mathematical concepts, is self-contained, and poses a well-posed question with objective criteria for the solution. I will select Kosaraju's algorithm for its conceptual clarity, which relies on two sequential applications of Depth-First Search (DFS).\n\nKosaraju's algorithm operates in three main stages:\n1.  Perform a DFS traversal on the input graph $G=(V,E)$ to determine the finishing times of all vertices. The vertices are stored in a data structure (e.g., a stack or list) in the order they finish.\n2.  Compute the transpose graph $G^T=(V,E^T)$, where $E^T = \\{ (v,u) \\mid (u,v) \\in E \\}$.\n3.  Perform a second DFS traversal on the transpose graph $G^T$. The main loop of this DFS considers vertices in decreasing order of their finishing times as computed in the first stage. Each tree in the resulting DFS forest corresponds to a distinct Strongly Connected Component.\n\nI will now provide the formal pseudo-code, derive its correctness from first principles, and analyze its complexity.\n\n**1. Pseudo-code for Kosaraju's Algorithm**\n\nLet the input graph be $G=(V,E)$ with $|V|=n$ and $|E|=m$, represented by an adjacency list $Adj$.\n\n`Global Variables:`\n- $visited$: A boolean array of size $n$, initialized to $\\text{false}$.\n- $F$: A list or stack to store vertices in finishing order.\n\n`Procedure $\\text{KOSARAJU}(G=(V,E))$`:\n1. For each vertex $u \\in V$:\n2.     $visited[u] \\leftarrow \\text{false}$\n3. $F \\leftarrow \\text{empty list}$\n4. For each vertex $u \\in V$:\n5.     If not $visited[u]$:\n6.         $\\text{DFS\\_PASS1}(G, u)$\n7. Compute $G^T$ from $G$.\n8. For each vertex $u \\in V$:\n9.     $visited[u] \\leftarrow \\text{false}$\n10. $SCCs \\leftarrow \\text{empty list of lists}$\n11. While $F$ is not empty:\n12.     $u \\leftarrow \\text{pop}(F)$ (get vertex with latest finishing time)\n13.     If not $visited[u]$:\n14.         $component \\leftarrow \\text{empty list}$\n15.         $\\text{DFS\\_PASS2}(G^T, u, component)$\n16.         Append $component$ to $SCCs$.\n17. Return $SCCs$.\n\n`Procedure $\\text{DFS\\_PASS1}(G, u)$`:\n1. $visited[u] \\leftarrow \\text{true}$\n2. For each neighbor $v$ of $u$ in $G$:\n3.     If not $visited[v]$:\n4.         $\\text{DFS\\_PASS1}(G, v)$\n5. Push $u$ onto the front of list $F$.\n\n`Procedure $\\text{DFS\\_PASS2}(G^T, u, component)$`:\n1. $visited[u] \\leftarrow \\text{true}$\n2. Add $u$ to $component$.\n3. For each neighbor $v$ of $u$ in $G^T$:\n4.     If not $visited[v]$:\n5.         $\\text{DFS\\_PASS2}(G^T, v, component)$\n\n**2. Proof of Correctness**\n\nThe correctness of Kosaraju's algorithm hinges on a fundamental property of the condensation graph and DFS finishing times. The condensation graph, $G^{SCC}$, is formed by contracting each SCC of $G$ into a single super-vertex. An edge exists from super-vertex $S_i$ to $S_j$ in $G^{SCC}$ if there is an edge in $G$ from some vertex $u \\in C_i$ to some vertex $v \\in C_j$, where $C_i$ and $C_j$ are the SCCs corresponding to $S_i$ and $S_j$. By definition of SCCs, $G^{SCC}$ is a Directed Acyclic Graph (DAG).\n\nLet $\\text{f}(u)$ denote the finishing time of vertex $u$ in the first DFS pass on $G$. Let $\\text{f}_{\\max}(C) = \\max_{u \\in C} \\{\\text{f}(u)\\}$ for any SCC $C \\subseteq V$.\n\n**Core Lemma:** If $C_1$ and $C_2$ are two distinct SCCs in $G$ and there exists an edge $(u,v) \\in E$ with $u \\in C_1$ and $v \\in C_2$, then $\\text{f}_{\\max}(C_1) > \\text{f}_{\\max}(C_2)$.\n\n**Proof of Lemma:**\nWe consider two cases for the first DFS pass on $G$.\n- **Case 1:** The DFS first visits a vertex in $C_2$ before visiting any vertex in $C_1$. Let $x \\in C_2$ be the first vertex visited in $C_2$. The DFS traversal starting from $x$ will explore all vertices reachable from $x$. Since all vertices in $C_2$ are mutually reachable, they will all be visited as part of the DFS tree rooted at $x$ (or one of its descendants within $C_2$). Because there is no path from any vertex in $C_2$ back to any vertex in $C_1$ (otherwise they would be part of the same SCC), the DFS from $x$ will not visit any vertex in $C_1$. Therefore, all vertices in $C_2$ will be explored and will finish before the traversal of the subtree containing them finishes. Specifically, all vertices in $C_2$ finish before $x$ finishes. Since no vertex in $C_1$ has been visited yet, all vertices in $C_1$ will start and finish after all vertices in $C_2$ have finished. Thus, $\\text{f}_{\\max}(C_1) > \\text{f}_{\\max}(C_2)$.\n- **Case 2:** The DFS first visits a vertex in $C_1$ before visiting any vertex in $C_2$. Let $x \\in C_1$ be the first vertex visited in $C_1$. The DFS from $x$ will explore all vertices reachable from $x$. This includes all vertices in $C_1$ (by definition of SCC) and, due to the edge $(u, v)$ and paths within $C_1$, all vertices in $C_2$. Therefore, the entire component $C_2$ will be contained within the DFS subtree rooted at $x$. In a DFS, any vertex in a subtree finishes before the root of that subtree finishes. Thus, all vertices in $C_2$ will have finishing times less than $\\text{f}(x)$. Since $x \\in C_1$, we have $\\text{f}_{\\max}(C_2)  \\text{f}(x) \\le \\text{f}_{\\max}(C_1)$.\n\nIn both cases, the lemma holds.\n\n**Main Argument:**\nThe second phase of the algorithm performs a DFS on the transpose graph $G^T$, processing vertices in decreasing order of their finishing time $\\text{f}(u)$ from the first pass.\n\nLet $s$ be the vertex with the highest finishing time in all of $V$. Let $C_s$ be the SCC containing $s$. According to the Core Lemma, if there were an edge in $G$ from another SCC, say $C'$, to $C_s$, then it would imply $\\text{f}_{\\max}(C') > \\text{f}_{\\max}(C_s)$. But $s$ has the maximum finishing time overall, so $\\text{f}_{\\max}(C_s)$ must be the maximum over all SCCs. This is a contradiction. Therefore, there can be no edges in $G$ from any other SCC to $C_s$. This means $C_s$ is a \"sink component\" in the condensation graph $G^{SCC}$.\n\nIn the transpose graph $G^T$, all edges between components are reversed. An edge $(u,v)$ in $G$ with $u \\in C_i, v \\in C_j$ becomes $(v,u)$ in $G^T$. Thus, a sink component in $G^{SCC}$ becomes a \"source component\" in the condensation graph of $G^T$. There are no edges in $G^T$ from any other SCC *to* $C_s$.\n\nWhen the second DFS begins on $G^T$ with the vertex $s$, it can reach all other vertices in $C_s$ because they are mutually reachable in $G$ and thus also in $G^T$. However, it cannot reach any vertex outside of $C_s$, because this would imply an edge in $G^T$ from a vertex in $C_s$ to a vertex in another component, which we have just shown is impossible. Therefore, the first DFS tree found in the second pass consists of exactly the vertices of the SCC $C_s$.\n\nAfter this first SCC is identified, its vertices are marked as visited. The algorithm then picks the unvisited vertex with the highest remaining finishing time. This vertex belongs to an SCC which is a sink component in the subgraph of $G$ induced by the remaining unvisited vertices. The same argument applies recursively. This process continues, correctly partitioning the entire vertex set $V$ into its Strongly Connected Components. Each call to $\\text{DFS\\_PASS2}$ from the main loop of $\\text{KOSARAJU}$ identifies exactly one SCC.\n\n**3. Complexity Analysis**\n\n- **Time Complexity:**\n    1. The first DFS pass ($\\text{DFS\\_PASS1}$) visits each vertex and each edge of $G$ exactly once. Its running time is $O(n+m)$.\n    2. The computation of the transpose graph $G^T$ requires iterating through all edges of $G$, taking $O(m)$ time to build the new adjacency list, or $O(n+m)$ to initialize and build it.\n    3. The second DFS pass ($\\text{DFS\\_PASS2}$) visits each vertex and each edge of $G^T$ exactly once. The number of vertices is $n$ and edges is $m$. Its running time is $O(n+m)$.\n    The total time complexity is the sum of these steps, which is $O(n+m) + O(n+m) + O(n+m) = O(n+m)$.\n\n- **Space Complexity:**\n    1. Storing the graph $G$ and its transpose $G^T$ as adjacency lists requires $O(n+m)$ space.\n    2. The $visited$ array requires $O(n)$ space.\n    3. The list $F$ to store finishing order requires $O(n)$ space.\n    4. The recursion stack for the DFS procedures can go up to depth $n$ in the worst case (e.g., a path graph), requiring $O(n)$ space.\n    The total space complexity is dominated by the storage of the graphs, resulting in $O(n+m)$.\n\n**4. Canonicalization**\n\nThe specified canonicalization requires two levels of sorting.\n1.  For each identified SCC, the list of its vertex indices must be sorted in ascending order.\n2.  The final list of all SCCs must be sorted lexicographically. This means, for two SCCs represented as sorted lists $C_1$ and $C_2$, $C_1$ comes before $C_2$ if $C_1$ is lexicographically smaller than $C_2$.\n\nThese sorting steps are applied after the core algorithm has identified the components. The complexity of sorting is not dominant. If there are $k$ SCCs, with $|C_i|$ being the size of the $i$-th component, sorting all of them takes $\\sum_{i=1}^{k} O(|C_i| \\log |C_i|)$, which is bounded by $O(n \\log n)$. Sorting the final list of $k$ components is negligible in comparison. The overall $O(n+m)$ complexity remains dominant for typical graphs.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\nimport numpy as np\n\n# It is good practice to increase the recursion limit for deep graphs in Python DFS.\n# The test cases here are small, but this makes the implementation robust.\nsys.setrecursionlimit(200000)\n\ndef solve():\n    \"\"\"\n    Main function to run Kosaraju's algorithm on a fixed set of test cases\n    and print the results in the specified canonical format.\n    \"\"\"\n\n    # Test cases defined as tuples of (n, adjacency_list)\n    test_cases = [\n        # Test 1: Two SCCs {0,1,2} and {3,4,5}, and two trivial ones {6}, {7}\n        (8, [[1], [2], [0, 3], [4], [5], [3], [7], []]),\n        # Test 2: Empty graph\n        (0, []),\n        # Test 3: Single vertex, no edges\n        (1, [[]]),\n        # Test 4: Single vertex, self-loop\n        (1, [[0]]),\n        # Test 5: Fully connected component\n        (5, [[1, 2], [2, 3], [3, 4], [4, 0], [0, 1]]),\n        # Test 6: Two disjoint paths, all vertices are trivial SCCs\n        (6, [[1], [2], [], [4], [5], []]),\n    ]\n    \n    final_results = []\n\n    for n, adj in test_cases:\n        if n == 0:\n            final_results.append(\"[]\")\n            continue\n\n        # --- Kosaraju's Algorithm ---\n        \n        # Step 1: First DFS pass on G to compute finishing order\n        visited = [False] * n\n        finish_stack = []\n        \n        def dfs1(u):\n            visited[u] = True\n            for v in adj[u]:\n                if not visited[v]:\n                    dfs1(v)\n            finish_stack.append(u)\n\n        for i in range(n):\n            if not visited[i]:\n                dfs1(i)\n        \n        # Step 2: Compute the transpose graph G^T\n        adj_t = [[] for _ in range(n)]\n        for u in range(n):\n            for v in adj[u]:\n                adj_t[v].append(u)\n\n        # Step 3: Second DFS pass on G^T in decreasing order of finishing times\n        visited = [False] * n\n        sccs = []\n        \n        def dfs2(u, current_scc):\n            visited[u] = True\n            current_scc.append(u)\n            for v in adj_t[u]:\n                if not visited[v]:\n                    dfs2(v, current_scc)\n\n        while finish_stack:\n            u = finish_stack.pop()\n            if not visited[u]:\n                current_scc = []\n                dfs2(u, current_scc)\n                # Canonicalization Step 1: Sort vertices within the SCC\n                current_scc.sort()\n                sccs.append(current_scc)\n        \n        # Canonicalization Step 2: Sort the list of SCCs lexicographically\n        sccs.sort()\n        \n        # Format the result for this test case as a string\n        case_result_str = str(sccs).replace(\" \", \"\")\n        final_results.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "3205772"}, {"introduction": "Beyond implementation, a deep understanding of SCCs comes from reasoning about their essential structure. This problem asks you to move from analysis to design, tasking you with constructing a graph that meets specific SCC criteria with the minimum possible number of edges [@problem_id:3276714]. This exercise will sharpen your intuition about how cycles create strong connectivity and how components remain distinct.", "problem": "Let $V$ be an even positive integer with $V \\geq 2$. Consider a finite simple directed graph $G=(\\mathcal{V},\\mathcal{E})$ with $|\\mathcal{V}|=V$, where there are no parallel edges and no self-loops. The graph is required to have exactly $V/2$ strongly connected components (SCC), each of size $2$.\n\nUsing only the core definition of a strongly connected component in a directed graph—namely, a subset of vertices $C \\subseteq \\mathcal{V}$ such that for every pair $u,v \\in C$ there exists a directed path from $u$ to $v$ and from $v$ to $u$—determine the minimal possible value of $|\\mathcal{E}|$ as a closed-form expression in $V$. Your reasoning must justify both a construction that achieves this bound and a proof that no graph satisfying the requirements can use fewer edges. You may assume algorithms such as Kosaraju's algorithm and Tarjan's algorithm for computing SCCs run in linear time $O(|\\mathcal{V}|+|\\mathcal{E}|)$, but do not use any properties of these algorithms beyond the fundamental SCC definition in your derivation.\n\nProvide your final answer as a single analytic expression in $V$. No rounding is required.", "solution": "The problem requires finding the minimal possible number of edges, $|\\mathcal{E}|$, for a simple directed graph $G=(\\mathcal{V},\\mathcal{E})$ with $|\\mathcal{V}|=V$ vertices, given that $V$ is an even positive integer ($V \\geq 2$) and the graph has exactly $V/2$ strongly connected components (SCCs), each of size $2$. The derivation must rely solely on the fundamental definition of an SCC.\n\nLet the set of vertices be $\\mathcal{V}$. The conditions state that the vertices of $G$ are partitioned into $V/2$ disjoint subsets $C_1, C_2, \\dots, C_{V/2}$, which constitute the SCCs of the graph. Each of these components has size $|C_i| = 2$.\nLet $\\mathcal{E}$ be the set of edges in the graph. We can partition the edge set $\\mathcal{E}$ into two disjoint subsets:\n1.  $\\mathcal{E}_{intra}$: The set of edges where both endpoints are in the same SCC.\n2.  $\\mathcal{E}_{inter}$: The set of edges where the endpoints are in different SCCs.\n\nThe total number of edges is $|\\mathcal{E}| = |\\mathcal{E}_{intra}| + |\\mathcal{E}_{inter}|$. To minimize $|\\mathcal{E}|$, we must find the minimum possible values for $|\\mathcal{E}_{intra}|$ and $|\\mathcal{E}_{inter}|$.\n\nFirst, let us determine the minimum number of edges required within a single SCC. Consider an arbitrary SCC, $C_k$, where $|C_k|=2$. Let the two vertices in this component be $u$ and $v$, so $C_k = \\{u, v\\}$.\nThe definition of a strongly connected component requires that for every pair of vertices in the component, there exists a directed path from the first to the second and vice versa.\nApplying this to $C_k$:\n- There must be a path from $u$ to $v$.\n- There must be a path from $v$ to $u$.\n\nSince the graph is simple, there are no self-loops (e.g., $(u,u)$) and no parallel edges. The paths between $u$ and $v$ can only involve vertices from $\\mathcal{V}$. However, for $C_k$ to be an SCC, the paths establishing its strong connectivity must exist within the subgraph induced by $C_k$ if we are to consider this as a minimal unit. More formally, if we consider any path from $u$ to $v$ that involves a vertex $w \\notin C_k$, then for $C_k$ to remain a distinct SCC, there cannot be a path from $w$ back to $u$ or $v$, which complicates the structure. The most direct way to satisfy the definition is with edges entirely within $\\{u,v\\}$.\n\nTo have a path from $u$ to $v$ using only the vertices $\\{u,v\\}$, the shortest and only possible simple path is the single edge $(u,v)$.\nSimilarly, to have a path from $v$ to $u$ using only the vertices $\\{u,v\\}$, the shortest path is the edge $(v,u)$.\nTherefore, to make the set $\\{u,v\\}$ strongly connected, we need at least these two edges: $(u,v)$ and $(v,u)$. With only one edge, say $(u,v)$, there would be no path from $v$ to $u$. Thus, a minimum of $2$ edges are necessary for each SCC of size $2$.\n\nThere are $V/2$ such disjoint SCCs. Each requires a minimum of $2$ edges contained within it. The total minimum number of edges in $\\mathcal{E}_{intra}$ is the sum of the minimums for each component:\n$$|\\mathcal{E}_{intra}|_{min} = \\sum_{i=1}^{V/2} 2 = \\frac{V}{2} \\times 2 = V$$\n\nNext, let us consider the set of inter-component edges, $\\mathcal{E}_{inter}$. These are the edges that connect a vertex in one SCC, $C_i$, to a vertex in a different SCC, $C_j$ (where $i \\neq j$).\nA fundamental property of SCCs is that the \"component graph\", where each node represents an SCC of $G$, must be a Directed Acyclic Graph (DAG). If there were a cycle in the component graph (e.g., a path from $C_i$ to $C_j$ and another path from $C_j$ back to $C_i$), then all vertices in both $C_i$ and $C_j$ would be mutually reachable. This would merge them into a single, larger SCC, which contradicts the problem statement that $C_i$ and $C_j$ are distinct SCCs.\nThe number of edges $|\\mathcal{E}_{inter}|$ must be non-negative, i.e., $|\\mathcal{E}_{inter}| \\geq 0$. To minimize the total number of edges $|\\mathcal{E}|$, we must choose the minimal possible value for $|\\mathcal{E}_{inter}|$, which is $0$. If $|\\mathcal{E}_{inter}| = 0$, there are no edges between any of the SCCs. In this case, the component graph has no edges, which is trivially a DAG. This choice does not violate any conditions of the problem.\n\nCombining these findings, the minimum possible value for the total number of edges is:\n$$|\\mathcal{E}|_{min} = |\\mathcal{E}_{intra}|_{min} + |\\mathcal{E}_{inter}|_{min} = V + 0 = V$$\nThis establishes a lower bound of $V$ for $|\\mathcal{E}|$.\n\nTo complete the proof, we must show that this lower bound is achievable by constructing a graph that satisfies all the given conditions and has exactly $V$ edges.\nLet the set of vertices be $\\mathcal{V} = \\{v_1, v_2, \\dots, v_V\\}$.\nWe partition $\\mathcal{V}$ into $V/2$ pairs: $C_i = \\{v_{2i-1}, v_{2i}\\}$ for $i=1, 2, \\dots, V/2$.\nWe define the edge set $\\mathcal{E}$ as follows: for each pair $C_i$, we add the edges $(v_{2i-1}, v_{2i})$ and $(v_{2i}, v_{2i-1})$.\nThe complete edge set is $\\mathcal{E} = \\bigcup_{i=1}^{V/2} \\{ (v_{2i-1}, v_{2i}), (v_{2i}, v_{2i-1}) \\}$.\nThe total number of edges in this constructed graph is $|\\mathcal{E}| = \\sum_{i=1}^{V/2} 2 = V$.\n\nNow, we verify that this graph meets the problem's criteria:\n1.  The graph has $V$ vertices and is simple (no self-loops or parallel edges by construction).\n2.  For any set $C_i$, the vertices $v_{2i-1}$ and $v_{2i}$ are mutually reachable via the edges constructed within the set. Thus, each $C_i$ is a strongly connected set.\n3.  There are no edges between any two distinct sets $C_i$ and $C_j$ (where $i \\neq j$). Therefore, a vertex in $C_i$ cannot reach a vertex in $C_j$. This ensures that no SCC can be larger than one of the sets $C_i$.\n4.  From points 2 and 3, the maximal strongly connected subsets of vertices are precisely the sets $C_1, C_2, \\dots, C_{V/2}$.\n5.  Therefore, the graph has exactly $V/2$ SCCs, and each has size $2$.\n\nThe construction is valid and has $|\\mathcal{E}| = V$. Since we have proven a lower bound of $V$ and demonstrated a construction that achieves this bound, the minimal possible value for $|\\mathcal{E}|$ is $V$.", "answer": "$$\\boxed{V}$$", "id": "3276714"}, {"introduction": "Finding SCCs is often a means to an end, enabling a higher-level analysis of a graph's structure. This practice introduces the concept of the condensation graph, where each SCC is a single node, to solve a common reachability problem [@problem_id:3276548]. By identifying the \"source\" SCCs, you will learn how to determine the minimal set of starting points from which every node in a complex network can be reached.", "problem": "You are given several finite directed graphs. For each graph, determine the minimum number of strongly connected components (SCCs) that must be chosen such that, when considered as vertices in the component graph (also called the condensation), every SCC in the graph is reachable from at least one of the chosen SCCs. Your program must compute this minimum for each test case and output all results in a single line as specified below.\n\nFundamental base and definitions to use:\n- A directed graph is a pair $G = (V, E)$ where $V$ is a finite set of vertices and $E \\subseteq V \\times V$ is a set of directed edges.\n- A directed path in $G$ is a sequence of vertices $(v_0, v_1, \\dots, v_k)$ such that $(v_i, v_{i+1}) \\in E$ for all $i \\in \\{0, 1, \\dots, k-1\\}$.\n- Vertex $u \\in V$ reaches vertex $v \\in V$ if there exists a directed path from $u$ to $v$.\n- Two vertices $u, v \\in V$ are strongly connected if $u$ reaches $v$ and $v$ reaches $u$. This relation partitions $V$ into equivalence classes called strongly connected components (SCCs).\n- The component graph (condensation) $G^{\\ast} = (V^{\\ast}, E^{\\ast})$ is defined as follows: each vertex in $V^{\\ast}$ corresponds to one SCC of $G$, and there is a directed edge $(C_i, C_j) \\in E^{\\ast}$ between two distinct SCCs $C_i, C_j \\in V^{\\ast}$ if there exists at least one edge in $E$ from a vertex in $C_i$ to a vertex in $C_j$. It is a well-known fact that $G^{\\ast}$ is a directed acyclic graph.\n- A source SCC is an SCC in $G^{\\ast}$ with in-degree $0$.\n\nTask:\n- For each input graph, compute the minimum number of SCCs required so that every SCC in the component graph $G^{\\ast}$ is reachable from at least one of the chosen SCCs. The minimum is equal to the number of source SCCs in $G^{\\ast}$.\n\nAlgorithmic requirements:\n- Your method must run in time linear in the size of the graph, that is, in $O(|V| + |E|)$ time for each graph.\n\nGraph specification:\n- Each test case specifies a directed graph with vertices labeled by consecutive integers starting at $0$ (zero-based indexing).\n- Each test case is given by $(n, E)$ where $n$ is the number of vertices and $E$ is the list of directed edges as ordered pairs $(u, v)$ with $u, v \\in \\{0, 1, \\dots, n-1\\}$.\n\nTest suite to implement and solve:\n- Test case $1$: $n = 8$, $E = \\{(0,1),(1,2),(2,0),(0,3),(0,4),(3,4),(4,5),(5,4),(6,0)\\}$. Vertex $7$ has no outgoing edges and no incoming edges.\n- Test case $2$: $n = 4$, $E = \\{(0,1),(1,2),(2,3),(3,0)\\}$.\n- Test case $3$: $n = 5$, $E = \\{\\}$.\n- Test case $4$: $n = 6$, $E = \\{(0,2),(1,2),(3,4),(4,5)\\}$.\n- Test case $5$: $n = 0$, $E = \\{\\}$.\n\nAnswer type:\n- For each test case, output a single integer equal to the minimum number of source SCCs in the component graph, as defined above.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, [$r_1$,$r_2$,$r_3$,$\\dots$], where $r_i$ is the integer answer for test case $i$. There must be no spaces in the output line.", "solution": "The problem asks for the minimum number of Strongly Connected Components (SCCs) that need to be chosen so that all SCCs in a given directed graph $G = (V, E)$ are reachable from this chosen set. The reachability is considered in the context of the component graph, or condensation, $G^{\\ast}$.\n\nFirst, let's establish the theoretical foundation. The component graph $G^{\\ast}$ is formed by contracting each SCC of $G$ into a single vertex. An edge exists from a component-vertex $C_i$ to another component-vertex $C_j$ if there is an edge in the original graph $G$ from any vertex in SCC $C_i$ to any vertex in SCC $C_j$. A fundamental property of this construction is that $G^{\\ast}$ is always a Directed Acyclic Graph (DAG). If there were a cycle in $G^{\\ast}$, say $C_1 \\to C_2 \\to \\dots \\to C_k \\to C_1$, it would imply that any vertex in $C_1$ can reach any vertex in $C_k$, and any vertex in $C_k$ can reach any vertex in $C_1$. This would mean all vertices in $C_1, \\dots, C_k$ are mutually reachable, and thus they would all belong to the same single SCC, contradicting the assumption that they are distinct components.\n\nThe problem is now transformed into an equivalent problem on the DAG $G^{\\ast}$: find the minimum number of vertices in $G^{\\ast}$ from which all other vertices are reachable. In any DAG, the set of vertices with an in-degree of $0$ (called source vertices) forms a unique, minimal set from which all other vertices can be reached. Any vertex that is not a source must have an incoming edge, and by tracing these edges backward, we must eventually arrive at a source vertex, as there are no cycles. Therefore, to ensure all vertices are reachable, we must select, at a minimum, all the source vertices. The problem is thus reduced to counting the number of source SCCs, which are the SCCs with an in-degree of $0$ in $G^{\\ast}$.\n\nTo accomplish this task in the required $O(|V| + |E|)$ time, we employ a three-step, linear-time algorithm:\n\n1.  **Decomposition into SCCs:** We use Kosaraju's algorithm to partition the vertices of $G$ into SCCs. This algorithm has a time complexity of $O(|V| + |E|)$.\n    -   **Step 1a:** Perform a Depth-First Search (DFS) on the graph $G$. As each vertex finishes (all its descendants are visited), push it onto a stack. This results in a stack of vertices ordered by decreasing finishing time.\n    -   **Step 1b:** Compute the transpose graph $G^T$, where each edge $(u, v) \\in E$ is reversed to $(v, u) \\in E^T$. This can be done in $O(|V| + |E|)$ time.\n    -   **Step 1c:** Process the vertices from the stack. Pop a vertex $u$. If $u$ has not yet been assigned to an SCC, start a second DFS from $u$ on the transpose graph $G^T$. All vertices reachable from $u$ in $G^T$ form a single SCC. We assign a unique component ID to all these vertices and mark them as visited. We repeat this until the stack is empty. This process identifies all SCCs and assigns each vertex $v \\in V$ a component ID, say `scc_id[v]`.\n\n2.  **Identify Inter-SCC Edges:** We now conceptually build the condensation graph $G^{\\ast}$ to find the source components. We do not need to construct $G^{\\ast}$ explicitly. Instead, we can directly compute the in-degrees of its vertices (the SCCs). We initialize an array `scc_in_degree` of size equal to the number of SCCs, with all entries set to $0$. We then iterate through every edge $(u, v) \\in E$ of the original graph $G$. For each edge, we compare the component IDs of its endpoints: `scc_id[u]` and `scc_id[v]`. If `scc_id[u]` is different from `scc_id[v]`, it signifies an edge in $G^{\\ast}$ from the SCC containing $u$ to the SCC containing $v$. Consequently, we increment the in-degree of the destination component: `scc_in_degree[scc_id[v]]++`. This step takes $O(|E|)$ time.\n\n3.  **Count Source SCCs:** After iterating through all edges, the `scc_in_degree` array holds the in-degree for each SCC. The final step is to count the number of entries in this array that are equal to $0$. This count is the number of source SCCs, which is the required minimum. This takes $O(|V|)$ time, as the number of SCCs is at most $|V|$.\n\nThe total time complexity is the sum of the complexities of these steps, which is $O(|V| + |E|) + O(|E|) + O(|V|) = O(|V| + |E|)$, satisfying the problem's constraint. Special cases, such as an empty graph ($n=0$), result in $0$ SCCs. A graph with no edges ($E=\\emptyset$) results in $n$ SCCs, each being a source.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases.\n    The main logic for each test case is encapsulated in the `calculate_sources` function.\n    \"\"\"\n\n    # Set a higher recursion limit for deep graphs, although not strictly necessary for these test cases.\n    sys.setrecursionlimit(200000)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        (8, [(0, 1), (1, 2), (2, 0), (0, 3), (0, 4), (3, 4), (4, 5), (5, 4), (6, 0)]),\n        (4, [(0, 1), (1, 2), (2, 3), (3, 0)]),\n        (5, []),\n        (6, [(0, 2), (1, 2), (3, 4), (4, 5)]),\n        (0, [])\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = calculate_sources(n, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_sources(n, edges):\n    \"\"\"\n    Calculates the number of source SCCs for a single graph.\n    This function implements Kosaraju's algorithm to find SCCs,\n    then counts the in-degrees of each SCC in the condensation graph.\n    \"\"\"\n    if n == 0:\n        return 0\n\n    adj = [[] for _ in range(n)]\n    adj_t = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj_t[v].append(u)\n\n    # Step 1 of Kosaraju's algorithm: DFS on G to get post-order\n    visited = np.full(n, False, dtype=bool)\n    stack = []\n    def dfs1(u):\n        visited[u] = True\n        for v in adj[u]:\n            if not visited[v]:\n                dfs1(v)\n        stack.append(u)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs1(i)\n\n    # Step 2 of Kosaraju's algorithm: DFS on G_T to find SCCs\n    scc_id = np.full(n, -1, dtype=int)\n    scc_count = 0\n    def dfs2(u, current_scc_id):\n        scc_id[u] = current_scc_id\n        for v in adj_t[u]:\n            if scc_id[v] == -1:\n                dfs2(v, current_scc_id)\n\n    while stack:\n        u = stack.pop()\n        if scc_id[u] == -1:\n            dfs2(u, scc_count)\n            scc_count += 1\n    \n    if scc_count == 0:\n        return 0\n\n    # Step 3: Count in-degrees of SCCs in the condensation graph\n    scc_in_degree = np.zeros(scc_count, dtype=int)\n    for u, v in edges:\n        if scc_id[u] != scc_id[v]:\n            scc_in_degree[scc_id[v]] += 1\n\n    # The number of source SCCs is the number of SCCs with in-degree 0\n    source_sccs = np.sum(scc_in_degree == 0)\n    \n    return source_sccs\n\nsolve()\n```", "id": "3276548"}]}