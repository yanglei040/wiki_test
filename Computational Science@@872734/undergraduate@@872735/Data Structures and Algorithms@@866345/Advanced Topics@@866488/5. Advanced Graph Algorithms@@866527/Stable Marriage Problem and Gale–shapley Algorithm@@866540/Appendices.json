{"hands_on_practices": [{"introduction": "The Gale-Shapley algorithm guarantees a stable matching, but what if you are given a matching from another source, or want to evaluate a matching proposed in a real-world negotiation? This practice goes to the heart of stability by asking you to build a verifier. By implementing an efficient algorithm to count the number of blocking pairs, you will not only learn to check for stability but also to quantify how unstable a given matching truly is ([@problem_id:3274083]).", "problem": "You are given the classical Stable Marriage Problem (SMP), which consists of two disjoint sets of equal size, a set of men and a set of women. Let the number of men be $n$, the number of women be $n$, and let the men be indexed by $\\{0,1,\\dots,n-1\\}$ and the women be indexed by $\\{0,1,\\dots,n-1\\}$. Each man provides a strict total order (no ties) over all women, and each woman provides a strict total order (no ties) over all men. A perfect matching is a bijection $\\mu$ that pairs each man $m$ with exactly one woman $\\mu(m)$ and each woman $w$ with exactly one man $\\mu^{-1}(w)$.\n\nA pair $(m,w)$ is a blocking pair for a matching $\\mu$ if man $m$ and woman $w$ are not matched to each other in $\\mu$, and both $m$ and $w$ strictly prefer each other to their assigned partners under $\\mu$. A matching is stable if and only if there are no blocking pairs.\n\nStarting from the fundamental definitions above, devise an algorithm that, given:\n- a complete strict preference profile for all men and all women, and\n- a perfect matching $\\mu$,\n\ncomputes the exact number of blocking pairs by using rank matrices. Your algorithm must run in time $O(n^2)$ after the preferences and the matching are provided. The rank matrix for men, denoted $R^{M}$, is defined by $R^{M}[m][w] = r$ if woman $w$ is ranked at position $r$ in man $m$'s preference list (with lower values indicating stronger preference). Similarly, the rank matrix for women, denoted $R^{W}$, is defined by $R^{W}[w][m] = r$ if man $m$ is ranked at position $r$ in woman $w$'s preference list (with lower values indicating stronger preference).\n\nYour task is to implement this algorithm and then use it to measure a matching’s closeness to stability by the following normalized instability index:\n$$\nI(\\mu) = \n\\begin{cases}\n\\frac{B(\\mu)}{n^2 - n}, & \\text{if } n^2 - n \\neq 0 \\\\\n0, & \\text{if } n^2 - n = 0\n\\end{cases}\n$$\nwhere $B(\\mu)$ is the number of blocking pairs for $\\mu$. The denominator $n^2 - n$ is the total number of cross pairs $(m,w)$ that are not matched together in a perfect matching. The normalized instability index $I(\\mu)$ takes values in $[0,1]$.\n\nImplement a program that, for each test case below, returns a two-element list $[B(\\mu), I(\\mu)]$ where $B(\\mu)$ is an integer and $I(\\mu)$ is a real number rounded to three decimal places.\n\nTest suite to cover a range of cases:\n- Case A (boundary size): $n=1$.\n  - Men’s preferences: $[[0]]$.\n  - Women’s preferences: $[[0]]$.\n  - Matching: $[0]$.\n- Case B (stable matching, no blocking pairs): $n=3$.\n  - Men’s preferences: $[[0,1,2],[1,2,0],[2,0,1]]$.\n  - Women’s preferences: $[[0,1,2],[1,2,0],[2,0,1]]$.\n  - Matching: $[0,1,2]$.\n- Case C (some blocking pairs): $n=3$.\n  - Men’s preferences: $[[1,0,2],[0,1,2],[0,1,2]]$.\n  - Women’s preferences: $[[1,0,2],[0,1,2],[0,1,2]]$.\n  - Matching: $[0,1,2]$.\n- Case D (many blocking pairs relative to size): $n=4$.\n  - Men’s preferences: $[[0,1,2,3],[0,1,2,3],[0,1,2,3],[0,1,2,3]]$.\n  - Women’s preferences: $[[0,1,2,3],[0,1,2,3],[0,1,2,3],[0,1,2,3]]$.\n  - Matching: $[3,2,1,0]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the two-element list for the corresponding test case, in the same order as listed above. For example, the output must have the form\n\"[[B_A,I_A],[B_B,I_B],[B_C,I_C],[B_D,I_D]]\"\nwith $I_A,I_B,I_C,I_D$ each rounded to three decimal places.", "solution": "The problem is valid. It is a well-defined algorithmic task from the field of discrete mathematics and computer science, specifically concerning the analysis of matchings in the context of the Stable Marriage Problem. All inputs, definitions, and constraints are clear, consistent, and scientifically sound.\n\nThe problem requires us to devise an algorithm to count the number of blocking pairs for a given perfect matching $\\mu$ in a stable marriage instance of size $n$. The algorithm must operate within a time complexity of $O(n^2)$. Subsequently, this count is used to compute a normalized instability index $I(\\mu)$.\n\nA blocking pair for a perfect matching $\\mu$ is a pair $(m, w)$ consisting of a man $m$ and a woman $w$ who are not matched to each other, but who both strictly prefer each other to their partners under $\\mu$. Formally, $(m, w)$ is a blocking pair if and only if three conditions are met:\n1.  Man $m$ and woman $w$ are not matched: $\\mu(m) \\neq w$.\n2.  Man $m$ prefers woman $w$ over his assigned partner $\\mu(m)$.\n3.  Woman $w$ prefers man $m$ over her assigned partner $\\mu^{-1}(w)$.\n\nA naive approach would be to iterate through all $n^2 - n$ pairs $(m, w)$ not in the matching $\\mu$ and, for each pair, check the two preference conditions. Verifying a preference by searching through an individual's preference list of length $n$ would take $O(n)$ time. This leads to an overall time complexity of $O(n^3)$, which is inefficient and does not meet the specified $O(n^2)$ constraint.\n\nTo achieve the required $O(n^2)$ complexity, we must perform preference checks in constant, $O(1)$, time. As suggested, this can be achieved by preprocessing the preference lists into rank matrices. We define two rank matrices, one for men ($R^M$) and one for women ($R^W$).\n\nThe men's rank matrix, $R^M$, is an $n \\times n$ matrix where the entry $R^M[m][w]$ stores the rank of woman $w$ in man $m$'s preference list. A lower rank value signifies a higher preference. For instance, if man $m$'s most preferred woman is $w_i$, then $R^M[m][w_i] = 0$. This matrix can be constructed in $O(n^2)$ time by iterating through each man's preference list. For each man $m$ from $0$ to $n-1$, we iterate through his preference list: if woman $w$ is at position (rank) $r$ in the list, we set $R^M[m][w] = r$.\n\nSimilarly, the women's rank matrix, $R^W$, is an $n \\times n$ matrix where $R^W[w][m]$ stores the rank of man $m$ in woman $w$'s preference list. This matrix can also be constructed in $O(n^2)$ time.\n\nWith these rank matrices, the preference conditions for a blocking pair $(m, w)$ can be checked in $O(1)$ time:\n- Man $m$ prefers $w$ over $\\mu(m)$ if and only if $R^M[m][w] < R^M[m][\\mu(m)]$.\n- Woman $w$ prefers $m$ over $\\mu^{-1}(w)$ if and only if $R^W[w][m] < R^W[w][\\mu^{-1}(w)]$.\n\nThe complete $O(n^2)$ algorithm is as follows:\n\n1.  **Preprocessing (Time: $O(n^2)$):**\n    a. Given the men's preference lists, construct the men's rank matrix $R^M$. This takes $O(n^2)$ time.\n    b. Given the women's preference lists, construct the women's rank matrix $R^W$. This also takes $O(n^2)$ time.\n    c. Given the matching $\\mu$ (an array where `matching[m]` $= \\mu(m)$), construct the inverse matching $\\mu^{-1}$ (an array where `inverse_matching[w]` $= \\mu^{-1}(w)$). This takes $O(n)$ time.\n\n2.  **Blocking Pair Count (Time: $O(n^2)$):**\n    a. Initialize a counter for the number of blocking pairs, $B(\\mu)$, to $0$.\n    b. Iterate through every possible pair of a man $m$ (from $0$ to $n-1$) and a woman $w$ (from $0$ to $n-1$).\n    c. For each pair $(m, w)$, first check if they are already matched, i.e., if $w = \\mu(m)$. If they are, this pair cannot be a blocking pair, so we continue to the next pair.\n    d. If they are not matched, check the two preference conditions using the rank matrices:\n        i.  $R^M[m][w] < R^M[m][\\mu(m)]$\n        ii. $R^W[w][m] < R^W[w][\\mu^{-1}(w)]$\n    e. If both conditions are true, the pair $(m, w)$ is a blocking pair. Increment the counter $B(\\mu)$.\n\n3.  **Instability Index Calculation (Time: $O(1)$):**\n    a. After iterating through all $n^2$ pairs, the counter $B(\\mu)$ will hold the total number of blocking pairs.\n    b. The normalized instability index $I(\\mu)$ is then calculated according to the formula:\n    $$\n    I(\\mu) = \n    \\begin{cases}\n    \\frac{B(\\mu)}{n^2 - n}, & \\text{if } n^2 - n \\neq 0 \\\\\n    0, & \\text{if } n^2 - n = 0\n    \\end{cases}\n    $$\n    The case $n^2-n=0$ occurs only for $n=0$ or $n=1$. For $n=1$, there are no non-matched pairs, so $B(\\mu)$ is necessarily $0$, and $I(\\mu)$ is defined to be $0$. For $n>1$, the denominator is non-zero. This index $I(\\mu)$ represents the fraction of non-matched pairs that are unstable.\n\nThe total time complexity of this algorithm is the sum of the complexities of its steps: $O(n^2)$ for preprocessing and $O(n^2)$ for counting, yielding an overall complexity of $O(n^2)$, which satisfies the problem's constraint.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_instability(n, men_prefs, women_prefs, matching):\n    \"\"\"\n    Computes the number of blocking pairs and the instability index for a given matching.\n\n    Args:\n        n (int): The number of men and women.\n        men_prefs (list of list of int): Men's preference lists.\n        women_prefs (list of list of int): Women's preference lists.\n        matching (list of int): The matching to analyze, where matching[m] = w.\n\n    Returns:\n        tuple: A tuple (B, I) where B is the number of blocking pairs and I is the\n               normalized instability index.\n    \"\"\"\n    if n <= 1:\n        # For n=1, there are no non-matched pairs, so B=0.\n        # The problem defines I=0 for this case.\n        return 0, 0.0\n\n    # Step 1: Preprocessing\n    # a. Construct men's rank matrix R_M\n    # R_M[m][w] = rank of woman w in man m's preference list\n    R_M = np.zeros((n, n), dtype=int)\n    for m in range(n):\n        for rank, w in enumerate(men_prefs[m]):\n            R_M[m, w] = rank\n\n    # b. Construct women's rank matrix R_W\n    # R_W[w][m] = rank of man m in woman w's preference list\n    R_W = np.zeros((n, n), dtype=int)\n    for w in range(n):\n        for rank, m in enumerate(women_prefs[w]):\n            R_W[w, m] = rank\n\n    # c. Construct the inverse matching\n    inverse_matching = np.zeros(n, dtype=int)\n    for m, w in enumerate(matching):\n        inverse_matching[w] = m\n    \n    # Pre-fetch the ranks of the current partners for faster lookups\n    # Although not strictly necessary for complexity, it can clarify the loop\n    man_partner_ranks = np.zeros(n, dtype=int)\n    for m in range(n):\n        man_partner_ranks[m] = R_M[m, matching[m]]\n        \n    woman_partner_ranks = np.zeros(n, dtype=int)\n    for w in range(n):\n        woman_partner_ranks[w] = R_W[w, inverse_matching[w]]\n\n    # Step 2: Blocking Pair Count\n    blocking_pairs_count = 0\n    for m in range(n):\n        for w in range(n):\n            # A pair cannot block itself\n            if matching[m] == w:\n                continue\n\n            # Check if (m, w) is a blocking pair\n            # Condition 1: m prefers w to his current partner\n            m_prefers_w = R_M[m, w] < man_partner_ranks[m]\n            \n            # Condition 2: w prefers m to her current partner\n            w_prefers_m = R_W[w, m] < woman_partner_ranks[w]\n\n            if m_prefers_w and w_prefers_m:\n                blocking_pairs_count += 1\n    \n    B = blocking_pairs_count\n    \n    # Step 3: Instability Index Calculation\n    # Denominator is the total number of non-matched pairs\n    denominator = n**2 - n\n    I = B / denominator if denominator != 0 else 0.0\n\n    return B, I\n\ndef solve():\n    \"\"\"\n    Defines the test cases and runs the instability calculation for each,\n    then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        # Case A (boundary size): n=1\n        {\n            \"n\": 1,\n            \"men_prefs\": [[0]],\n            \"women_prefs\": [[0]],\n            \"matching\": [0]\n        },\n        # Case B (stable matching, no blocking pairs): n=3\n        {\n            \"n\": 3,\n            \"men_prefs\": [[0, 1, 2], [1, 2, 0], [2, 0, 1]],\n            \"women_prefs\": [[0, 1, 2], [1, 2, 0], [2, 0, 1]],\n            \"matching\": [0, 1, 2]\n        },\n        # Case C (some blocking pairs): n=3\n        {\n            \"n\": 3,\n            \"men_prefs\": [[1, 0, 2], [0, 1, 2], [0, 1, 2]],\n            \"women_prefs\": [[1, 0, 2], [0, 1, 2], [0, 1, 2]],\n            \"matching\": [0, 1, 2]\n        },\n        # Case D (many blocking pairs relative to size): n=4\n        {\n            \"n\": 4,\n            \"men_prefs\": [[0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3]],\n            \"women_prefs\": [[0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3]],\n            \"matching\": [3, 2, 1, 0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        B, I = calculate_instability(case[\"n\"], case[\"men_prefs\"], case[\"women_prefs\"], case[\"matching\"])\n        # Round the instability index to three decimal places\n        I_rounded = round(I, 3)\n        results.append([B, I_rounded])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3274083"}, {"introduction": "Real-world matching markets rarely fit the perfect, unconstrained model of the classic Stable Marriage Problem. This exercise challenges you to adapt the Gale-Shapley algorithm to handle more realistic scenarios involving incomplete preference lists and \"forbidden pairs,\" where certain matches are disallowed regardless of preference. This skill of modifying a core algorithm to fit specific constraints is a fundamental aspect of practical algorithm design ([@problem_id:3274062]).", "problem": "Consider the Stable Marriage Problem (SMP) with incomplete lists and forbidden pairs. Let there be two disjoint sets of agents, a proposing side $U$ and a receiving side $V$, where $|U| = |V| = n$ for some integer $n \\geq 1$. Each agent $u \\in U$ has a strict preference order over a subset of agents in $V$, and each agent $v \\in V$ has a strict preference order over a subset of agents in $U$. A pair $(u,v)$ is acceptable if and only if both $u$ lists $v$ and $v$ lists $u$. Additionally, a subset $F \\subseteq U \\times V$ of pairs are declared forbidden, meaning any pair $(u,v) \\in F$ can never be matched, even if $(u,v)$ is acceptable according to the agents’ lists.\n\nA matching $M \\subseteq U \\times V$ is a set of disjoint pairs (no agent appears in more than one pair). Unmatched agents are permitted. For acceptability, a pair $(u,v)$ belongs to $M$ only if $(u,v)$ is acceptable and $(u,v) \\notin F$. A pair $(u,v)$ not in $M$ is a blocking pair if $(u,v)$ is acceptable, $(u,v) \\notin F$, agent $u$ strictly prefers $v$ to $u$’s current partner in $M$ (or being unmatched), and agent $v$ strictly prefers $u$ to $v$’s current partner in $M$ (or being unmatched). A matching is stable if it has no blocking pair.\n\nStarting from the core definitions of stability, acceptability, and strict preferences, and using the Gale–Shapley algorithm (GSA) as the fundamental procedure, adapt the algorithm so that proposals never occur to forbidden or unacceptable partners. Your algorithm must handle potentially incomplete preference lists on both sides and the forbidden set $F$. The program must:\n- Construct an $U$-proposing Gale–Shapley procedure that ignores forbidden and unacceptable pairs.\n- Produce a stable matching $M$ (possibly incomplete).\n- Verify stability by counting the number of blocking pairs using the formal definition above.\n- Analyze the existence of a stable perfect matching (one that matches all agents on both sides): return a boolean indicating whether the adapted Gale–Shapley procedure results in a perfect matching. This condition is necessary and sufficient for the existence of a stable perfect matching in SMP with incomplete lists and no ties.\n\nFor each test case, your program must return a list $[s, p, b, u, M]$, where:\n- $s$ is a boolean indicating whether the algorithm produced a stable matching (this should be true if and only if $b = 0$),\n- $p$ is a boolean indicating whether the matching is perfect (all $n$ agents in $U$ are matched),\n- $b$ is the integer number of blocking pairs,\n- $u$ is the integer number of unmatched agents in $U$,\n- $M$ is a list of matched pairs, encoded as a list of lists $[[u_1, v_1], [u_2, v_2], \\dots]$, with each $u_i$ and $v_i$ written as integers.\n\nImplement your solution and compute outputs for the following test suite. In each case, $n$ is specified, as well as preference lists and forbidden pairs. All integers in the lists denote agent indices.\n\n- Test Case $1$ (happy path, perfect matching exists):\n  - $n = 3$\n  - $P_U = \\{0 : [0,1,2],\\ 1 : [1,2,0],\\ 2 : [2,1,0]\\}$\n  - $P_V = \\{0 : [1,0,2],\\ 1 : [0,1,2],\\ 2 : [2,1,0]\\}$\n  - $F = \\{(0,2)\\}$\n\n- Test Case $2$ (no forbidden pairs, standard SMP):\n  - $n = 3$\n  - $P_U = \\{0 : [1,0,2],\\ 1 : [1,2,0],\\ 2 : [0,2,1]\\}$\n  - $P_V = \\{0 : [2,0,1],\\ 1 : [0,1,2],\\ 2 : [1,2,0]\\}$\n  - $F = \\{\\}$\n\n- Test Case $3$ (one agent with an empty acceptable list due to forbidden pairs, no perfect matching):\n  - $n = 4$\n  - $P_U = \\{0 : [0,1,2,3],\\ 1 : [1,0,2,3],\\ 2 : [2,3,1,0],\\ 3 : [3,2,1,0]\\}$\n  - $P_V = \\{0 : [1,0,2,3],\\ 1 : [0,1,2,3],\\ 2 : [2,3,1,0],\\ 3 : [3,2,1,0]\\}$\n  - $F = \\{(3,0),(3,1),(3,2),(3,3)\\}$\n\n- Test Case $4$ (competition for a single receiver with heavily restricted alternatives, no perfect matching):\n  - $n = 4$\n  - $P_U = \\{0 : [0],\\ 1 : [0],\\ 2 : [1,2,3],\\ 3 : [3,2,1]\\}$\n  - $P_V = \\{0 : [1,0,2,3],\\ 1 : [2,3,1,0],\\ 2 : [2,3,1,0],\\ 3 : [3,2,1,0]\\}$\n  - $F = \\{(1,1),(1,2),(1,3)\\}$\n\n- Test Case $5$ (boundary, minimal size with one proposer having no acceptable partners):\n  - $n = 2$\n  - $P_U = \\{0 : [0],\\ 1 : [1,0]\\}$\n  - $P_V = \\{0 : [1,0],\\ 1 : [1,0]\\}$\n  - $F = \\{(0,0)\\}$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[result_1,result_2,\\dots,result_k]$), where each $result_i$ corresponds to one test case and is formatted exactly as $[s,p,b,u,M]$ described above. The program must be self-contained, require no input, and use the specified runtime environment. All returned values must be from the set of basic types: boolean, integer, float, or lists of these types. No strings are permitted in the encoded matching $M$.", "solution": "The problem requires an adaptation of the Gale-Shapley algorithm (GSA) to solve the Stable Marriage Problem with Incomplete Lists and Forbidden Pairs. The solution must handle these constraints, produce a stable matching, and verify its properties. The core principles guiding this solution are the formal definitions of acceptability, forbidden pairs, and stability.\n\nThe overall approach is structured into three main phases:\n$1$. **Preprocessing**: We first construct effective preference lists for the proposing agents ($U$). A pair $(u,v)$ is a valid candidate for matching only if it is both *acceptable* (i.e., $u$ is on $v$'s preference list and $v$ is on $u$'s list) and *not forbidden* (i.e., $(u,v) \\notin F$). By filtering each proposer's preference list to include only such valid partners at the outset, we ensure that the subsequent algorithm only considers pairs that are eligible to be part of a stable matching. This transforms the problem into an equivalent instance of the Stable Marriage Problem with Incomplete Lists (SMPI), for which the GSA is a standard solution method.\n\n$2$. **Execution (Adapted Gale-Shapley Algorithm)**: The U-proposing GSA is then executed using these preprocessed, effective preference lists.\n    - A queue of \"free\" agents from set $U$ is initialized.\n    - While the queue is not empty, a free agent $u$ is dequeued and proposes to the highest-ranked agent $v$ on their effective list to whom they have not yet proposed.\n    - The receiving agent $v$ assesses the proposal. If $v$ is currently unmatched, they tentatively accept. If $v$ is already matched with an agent $u'$, they compare $u$ and $u'$ based on their original, complete preference list. If $v$ prefers $u$ to $u'$, they break the engagement with $u'$ (who becomes free again) and tentatively accept the proposal from $u$. Otherwise, $v$ rejects $u$, and $u$ remains free to propose to the next agent on their list.\n    - An agent $u$ who exhausts their effective preference list (which could be empty from the start) will remain permanently unmatched.\n    - The algorithm terminates when the queue of free agents is empty. The set of tentative engagements at this point constitutes the final, stable matching. The GSA for SMPI guarantees that this process terminates and produces a U-optimal stable matching, meaning no agent in $U$ can do better in any other stable matching.\n\n$3$. **Verification and Analysis**: After obtaining a matching $M$, a rigorous verification process is conducted to confirm its properties as required by the problem statement.\n    - **Stability Check**: The number of blocking pairs is counted. A pair $(u,v) \\notin M$ is a blocking pair if: ($a$) it is acceptable, ($b$) it is not forbidden, ($c$) $u$ prefers $v$ to their partner in $M$ (or to being unmatched), and ($d$) $v$ prefers $u$ to their partner in $M$ (or to being unmatched). This check is performed exhaustively over all pairs in $(U \\times V) \\setminus M$. For a correctly implemented GSA, this count must be $0$. The stability boolean $s$ is true if and only if this count is $0$.\n    - **Perfection and Unmatched Agents**: The matching is perfect if every agent in $U$ is matched. The boolean $p$ is set accordingly, and the number of unmatched agents in $U$, denoted by $u$, is calculated as $n - |M|$.\n    - **Final Output Assembly**: The results are compiled into the specified list format: $[s, p, b, u, M]$.\n\nThis principled design ensures correctness by first simplifying the problem constraints and then applying a proven algorithm, followed by a formal verification of the result against the initial, complex set of rules.\n\nTo implement this, preference rankings are pre-calculated for efficient lookups. For an agent $w$ and a potential partner $z$, $rank(w, z)$ is the position of $z$ on $w$'s preference list. A rank of infinity (e.g., a number larger than any possible rank) is assigned if $z$ is not on $w$'s list. This allows for simple numerical comparisons when an agent evaluates a new proposal against their current partner.\n\nFor the blocking pair check, for a given pair $(u, v) \\notin M$:\n- $u$ prefers $v$ if $rank(u, v) < rank(u, \\text{current partner of } u)$. If $u$ is unmatched, their current partner's rank is considered infinite, so any valid proposal is preferred.\n- A symmetric logic applies to $v$'s preference.\n- All four conditions for a blocking pair must be met simultaneously for the count to be incremented.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of Stable Marriage Problems with Incomplete Lists and Forbidden Pairs.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"n\": 3,\n            \"P_U\": {0: [0, 1, 2], 1: [1, 2, 0], 2: [2, 1, 0]},\n            \"P_V\": {0: [1, 0, 2], 1: [0, 1, 2], 2: [2, 1, 0]},\n            \"F\": [[0, 2]]\n        },\n        {\n            \"n\": 3,\n            \"P_U\": {0: [1, 0, 2], 1: [1, 2, 0], 2: [0, 2, 1]},\n            \"P_V\": {0: [2, 0, 1], 1: [0, 1, 2], 2: [1, 2, 0]},\n            \"F\": []\n        },\n        {\n            \"n\": 4,\n            \"P_U\": {0: [0, 1, 2, 3], 1: [1, 0, 2, 3], 2: [2, 3, 1, 0], 3: [3, 2, 1, 0]},\n            \"P_V\": {0: [1, 0, 2, 3], 1: [0, 1, 2, 3], 2: [2, 3, 1, 0], 3: [3, 2, 1, 0]},\n            \"F\": [[3, 0], [3, 1], [3, 2], [3, 3]]\n        },\n        {\n            \"n\": 4,\n            \"P_U\": {0: [0], 1: [0], 2: [1, 2, 3], 3: [3, 2, 1]},\n            \"P_V\": {0: [1, 0, 2, 3], 1: [2, 3, 1, 0], 2: [2, 3, 1, 0], 3: [3, 2, 1, 0]},\n            \"F\": [[1, 1], [1, 2], [1, 3]]\n        },\n        {\n            \"n\": 2,\n            \"P_U\": {0: [0], 1: [1, 0]},\n            \"P_V\": {0: [1, 0], 1: [1, 0]},\n            \"F\": [[0, 0]]\n        },\n    ]\n\n    def format_result(res):\n        \"\"\"Formats a single result list into the required string representation.\"\"\"\n        s, p, b, u, M = res\n        s_str = 'true' if s else 'false'\n        p_str = 'true' if p else 'false'\n        m_str_parts = [f\"[{pair[0]},{pair[1]}]\" for pair in M]\n        m_str = f\"[{','.join(m_str_parts)}]\"\n        return f\"[{s_str},{p_str},{b},{u},{m_str}]\"\n\n    def run_smp_case(n, P_U, P_V, F):\n        \"\"\"Processes a single test case of the stable marriage problem.\"\"\"\n        F_set = {tuple(p) for p in F}\n\n        # 1. Preprocessing: Create effective preference lists for U\n        cleaned_U_prefs = {u: [] for u in range(n)}\n        for u in range(n):\n            if u in P_U:\n                for v in P_U[u]:\n                    is_acceptable = v in P_V and u in P_V.get(v, [])\n                    is_not_forbidden = (u, v) not in F_set\n                    if is_acceptable and is_not_forbidden:\n                        cleaned_U_prefs[u].append(v)\n        \n        # Pre-calculate V's rankings for efficient lookups\n        v_rankings = np.full((n, n), n, dtype=int)\n        for v in range(n):\n            if v in P_V:\n                for rank, u in enumerate(P_V[v]):\n                    v_rankings[v, u] = rank\n\n        # 2. Execution: U-proposing Gale-Shapley Algorithm\n        free_men = list(range(n))\n        u_proposal_idx = np.zeros(n, dtype=int)\n        v_partners = np.full(n, -1, dtype=int)\n\n        while free_men:\n            u = free_men.pop(0)\n            u_prefs = cleaned_U_prefs[u]\n            \n            if u_proposal_idx[u] < len(u_prefs):\n                v = u_prefs[u_proposal_idx[u]]\n                u_proposal_idx[u] += 1\n                \n                current_partner = v_partners[v]\n                if current_partner == -1:\n                    v_partners[v] = u\n                else:\n                    if v_rankings[v, u] < v_rankings[v, current_partner]:\n                        v_partners[v] = u\n                        free_men.append(current_partner)\n                    else:\n                        free_men.append(u)\n            # If u has exhausted their list, they remain unmatched.\n        \n        # 3. Verification and Analysis\n        \n        # Construct final matching M and related stats\n        M_dict = {v_partners[v]: v for v in range(n) if v_partners[v] != -1}\n        M_list = sorted(list(M_dict.items()))\n        \n        u_unmatched_count = n - len(M_list)\n        p_is_perfect = (len(M_list) == n)\n\n        # Count blocking pairs\n        u_rankings = np.full((n, n), n, dtype=int)\n        for u in range(n):\n            if u in P_U:\n                for rank, v in enumerate(P_U[u]):\n                    u_rankings[u, v] = rank\n\n        b_blocking_pairs_count = 0\n        for u in range(n):\n            u_current_partner = M_dict.get(u, -1)\n            u_current_rank = n if u_current_partner == -1 else u_rankings[u, u_current_partner]\n\n            if u not in P_U: continue\n\n            for v in P_U[u]:\n                if u_current_partner == v: continue # Not an outside pair\n\n                # Check if (u,v) is a blocking pair\n                is_acceptable = v in P_V and u in P_V.get(v, [])\n                is_not_forbidden = (u,v) not in F_set\n                \n                if is_acceptable and is_not_forbidden:\n                    u_prefers = u_rankings[u, v] < u_current_rank\n                    \n                    if u_prefers:\n                        v_current_partner = v_partners[v]\n                        v_current_rank = n if v_current_partner == -1 else v_rankings[v, v_current_partner]\n                        v_prefers = v_rankings[v, u] < v_current_rank\n                        \n                        if v_prefers:\n                            b_blocking_pairs_count += 1\n        \n        s_is_stable = b_blocking_pairs_count == 0\n        \n        return [s_is_stable, p_is_perfect, b_blocking_pairs_count, u_unmatched_count, M_list]\n\n    results = [run_smp_case(**case) for case in test_cases]\n    results_as_strings = [format_result(r) for r in results]\n    \n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "3274062"}, {"introduction": "The assumption of strict preferences is a major simplification that makes the analysis of the Gale-Shapley algorithm straightforward. What happens when agents are indifferent between certain choices? This advanced practice explores the Stable Marriage Problem with ties, requiring you to implement a random tie-breaking mechanism and analyze the probabilistic outcome, a move from a deterministic solution to calculating an expected value ([@problem_id:3273994]).", "problem": "You are given the task of modifying the classical Stable Marriage Problem (SMP) to handle ties (indifference) in preference lists by applying a random tie-breaking rule, then analyzing the expected outcome for a single designated agent. Work in a setting with $n$ men and $n$ women, where preferences may contain ties. Each agent’s preference is a sequence of tiers: tier $1$ is most preferred, tier $2$ is second most preferred, and so on; within a tier the agent is indifferent among all candidates.\n\nFundamental base:\n- A matching is a bijection between the set of men and the set of women.\n- A matching is stable if there is no blocking pair $\\left(m,w\\right)$ such that $m$ prefers $w$ to his current partner and $w$ prefers $m$ to her current partner.\n- The Gale–Shapley algorithm (GS) with men proposing, when run on strict preference lists, always terminates with the man-optimal stable matching.\n\nRandom tie-breaking rule:\n- For each agent independently, and for each tie tier independently, break ties by drawing a uniformly random permutation of the agents within that tier. The relative order across tiers remains unchanged. This produces a strict total order for each agent.\n- After tie-breaking, run the men-proposing Gale–Shapley algorithm on the resulting strict preferences.\n\nQuantity to analyze:\n- Fix a designated man with index $i$ (where agents are indexed $0,1,\\dots,n-1$). For each complete tie-breaking outcome, the GS output is a perfect matching. Map the designated man’s matched partner to a tier index using his original tied preferences: if the matched woman lies in tier $t$, record the numeric tier $t$ (with tier $1$ being the best).\n- Define the expected tier of the designated man as the average of this recorded tier over the uniform distribution over all tie-breaking outcomes.\n\nComputational task:\n- For each test case, compute the exact expected tier of the designated man by enumerating all possible tie-breaking outcomes as the Cartesian product over independent permutations of all ties (across all agents and all their tie tiers). For each outcome:\n  1. Convert preferences with ties to strict preferences using the outcome’s permutations.\n  2. Run the men-proposing Gale–Shapley algorithm to obtain the matching.\n  3. Record the designated man’s tier index from his original tied preferences.\n- Average these recorded tier indices over all outcomes to obtain the expected tier. Report the result as a floating-point number rounded to $6$ decimal places.\n\nRepresentation of preferences with ties:\n- Each man’s preference is given as a list of tiers, where each tier is a list of woman indices. Likewise for each woman’s preference. For example, the tied preference list $[[0,1],[2]]$ for a man means the set $\\{0,1\\}$ is tier $1$ (indifferent between women $0$ and $1$) and $\\{2\\}$ is tier $2$.\n\nAssumptions:\n- All preference lists are complete: for every man, the tiers cover all women exactly once; for every woman, the tiers cover all men exactly once.\n- Agents are indexed from $0$ to $n-1$ on each side.\n- Gale–Shapley uses men proposing.\n\nTest suite:\n- You must compute the expected tier for the designated man in the following $4$ test cases. In all cases, $n=3$ except the last, where $n=2$. Each test case is specified by the men’s tiered preferences, the women’s tiered preferences, and the designated man index.\n\n- Test case $1$ (general small ties on both sides):\n  - Men:\n    - $M_0$: $[[0,1],[2]]$\n    - $M_1$: $[[1],[0],[2]]$\n    - $M_2$: $[[1],[2],[0]]$\n  - Women:\n    - $W_0$: $[[0,1],[2]]$\n    - $W_1$: $[[2],[1],[0]]$\n    - $W_2$: $[[0],[1],[2]]$\n  - Designated man: $0$\n\n- Test case $2$ (no ties; boundary determinism):\n  - Men:\n    - $M_0$: $[[0],[1],[2]]$\n    - $M_1$: $[[1],[0],[2]]$\n    - $M_2$: $[[1],[2],[0]]$\n  - Women:\n    - $W_0$: $[[1],[0],[2]]$\n    - $W_1$: $[[0],[1],[2]]$\n    - $W_2$: $[[0],[1],[2]]$\n  - Designated man: $1$\n\n- Test case $3$ (ties only on the receiving side; women have ties, men strict):\n  - Men:\n    - $M_0$: $[[0],[1],[2]]$\n    - $M_1$: $[[1],[0],[2]]$\n    - $M_2$: $[[1],[2],[0]]$\n  - Women:\n    - $W_0$: $[[0,1],[2]]$\n    - $W_1$: $[[1,2],[0]]$\n    - $W_2$: $[[0],[1],[2]]$\n  - Designated man: $0$\n\n- Test case $4$ (all ties on both sides; $n=2$; edge uniformity):\n  - Men:\n    - $M_0$: $[[0,1]]$\n    - $M_1$: $[[0,1]]$\n  - Women:\n    - $W_0$: $[[0,1]]$\n    - $W_1$: $[[0,1]]$\n  - Designated man: $0$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The $k$-th number must be the expected tier for test case $k$, each rounded to $6$ decimal places, e.g., $[1.234000,2.000000,1.750000,1.000000]$.", "solution": "The problem is assessed to be valid. It is a well-posed computational task rooted in the established theory of stable matching algorithms and discrete probability. The problem statement is self-contained, mathematically consistent, and provides all necessary data and definitions for a unique solution to be computed. The computational method prescribed, enumeration of all tie-breaking possibilities, is feasible for the small problem sizes specified in the test suite.\n\nThe methodology to solve this problem involves computing the expected tier for a designated man, which is defined as the average of his resulting partner's tier over all possible random resolutions of ties in the preference lists. The process for a single test case is as follows.\n\nLet the set of men be $M = \\{M_0, M_1, \\dots, M_{n-1}\\}$ and the set of women be $W = \\{W_0, W_1, \\dots, W_{n-1}\\}$, where $n$ is the number of men and women. The preferences of each agent $a \\in M \\cup W$ are given as a list of tiers, $P_a = (T_{a,1}, T_{a,2}, \\dots)$, where $T_{a,j}$ is a set of agents in the other group. The agent $a$ is indifferent between all agents in a given tier $T_{a,j}$, and prefers any agent in tier $T_{a,j}$ to any agent in tier $T_{a,k}$ if and only if $j < k$.\n\nThe random tie-breaking rule states that for each tier $T_{a,j}$ with size $|T_{a,j}| > 1$, the tie is broken by replacing $T_{a,j}$ with a linear ordering chosen uniformly at random from the $|T_{a,j}|!$ possible permutations of the agents in that tier. These choices are made independently for all agents and all of their respective tiers.\n\nAn outcome $\\omega$ is a complete specification of one such tie-breaking for all ties across all agents. The set of all possible outcomes is denoted $\\Omega$. The total number of unique outcomes is the product of the factorials of the sizes of all tied tiers:\n$$ |\\Omega| = \\prod_{a \\in M \\cup W} \\prod_{j \\text{ s.t. } |T_{a,j}|>1} |T_{a,j}|! $$\n\nFor each outcome $\\omega \\in \\Omega$, we can construct a set of strict preference lists $P'(\\omega)$ for all agents. With these strict preferences, the men-proposing Gale-Shapley algorithm, denoted $\\text{GS}$, is guaranteed to produce a unique stable matching, which we denote $\\mu_{\\omega}$.\n\nLet the designated man be $M_i$. In the matching $\\mu_{\\omega}$, he is paired with some woman $w^* = \\mu_{\\omega}(M_i)$. We then refer to $M_i$'s original tied preference list, $P_{M_i}$, to find the tier containing $w^*$. If $w^* \\in T_{M_i,t}$, we record this tier index, $t$. Let us denote this function as $\\text{Tier}(M_i, \\mu_{\\omega}) = t$.\n\nThe expected tier for man $M_i$ is the arithmetic mean of these tier indices over all possible outcomes:\n$$ \\mathbb{E}[\\text{tier}(M_i)] = \\frac{1}{|\\Omega|} \\sum_{\\omega \\in \\Omega} \\text{Tier}(M_i, \\mu_{\\omega}) $$\n\nThe computational procedure is a direct implementation of this formula:\n\n1.  **Identify Ties and Permutations**: For each test case, we first parse the preference lists of all men and women to find all tiers with size greater than $1$. For each such tier, we generate the set of all possible permutations.\n\n2.  **Enumerate Outcomes**: We construct the Cartesian product of all sets of permutations generated in the previous step. Each element of this product corresponds to one complete tie-breaking outcome $\\omega$.\n\n3.  **Iterate and Compute**: We loop through each outcome $\\omega$ in the Cartesian product. For each $\\omega$:\n    a. We construct the full set of strict preference lists, $P'(\\omega)$, for all $n$ men and $n$ women by replacing each tied tier with the specific permutation designated by $\\omega$.\n    b. We execute the men-proposing Gale-Shapley algorithm using these strict preferences $P'(\\omega)$. The algorithm proceeds as follows:\n        i. Initialize all men as free.\n        ii. While there exists a free man $m$, he proposes to the next woman $w$ on his preference list $P'_m(\\omega)$ whom he has not yet proposed to.\n        iii. If $w$ is free, she accepts and becomes engaged to $m$.\n        iv. If $w$ is already engaged to a man $m'$, she compares $m$ and $m'$ using her preference list $P'_w(\\omega)$. If she prefers $m$ to $m'$, she breaks her engagement with $m'$ (making $m'$ free) and accepts $m$. Otherwise, she rejects $m$.\n        v. The algorithm terminates when no man is free. The resulting set of engagements is the stable matching $\\mu_{\\omega}$. For efficient implementation, each woman's preference list is converted into a rank mapping to allow for constant-time comparisons.\n    c. We identify the partner of the designated man $M_i$. Let this be $w^* = \\mu_{\\omega}(M_i)$.\n    d. We determine the tier index of $w^*$ in $M_i$'s original, untied preferences. This index is added to a running sum.\n\n4.  **Calculate Average**: After iterating through all outcomes, the total sum of the recorded tier indices is divided by the total number of outcomes, $|\\Omega|$, to get the final expected tier. This value is then rounded to the required number of decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import permutations, product\n\ndef run_gale_shapley(n, men_prefs, women_prefs):\n    \"\"\"\n    Executes the men-proposing Gale-Shapley algorithm.\n\n    Args:\n        n (int): The number of men/women.\n        men_prefs (list of list of int): Strict preference lists for men.\n        women_prefs (list of list of int): Strict preference lists for women.\n\n    Returns:\n        list of int: A list where the i-th element is the partner of man i.\n    \"\"\"\n    # Create rank maps for women for O(1) preference lookups.\n    # women_ranks[w][m] gives the rank of man m in woman w's preference list.\n    women_ranks = [[0] * n for _ in range(n)]\n    for w in range(n):\n        for rank, m in enumerate(women_prefs[w]):\n            women_ranks[w][m] = rank\n\n    # woman_partner[w] is the man currently engaged to woman w, -1 if free.\n    woman_partner = [-1] * n\n    # man_partner[m] is the woman currently engaged to man m, -1 if free.\n    man_partner = [-1] * n\n    # next_proposal[m] is the index of the next woman man m will propose to.\n    next_proposal = [0] * n\n\n    # Initially, all men are free.\n    free_men_q = list(range(n))\n\n    while free_men_q:\n        m = free_men_q.pop(0)\n        \n        # Man m proposes to the next woman on his list.\n        w = men_prefs[m][next_proposal[m]]\n        next_proposal[m] += 1\n\n        if woman_partner[w] == -1:\n            # Woman w is free, she accepts.\n            woman_partner[w] = m\n            man_partner[m] = w\n        else:\n            # Woman w is engaged, she compares her current partner with the new suitor.\n            current_partner = woman_partner[w]\n            if women_ranks[w][m] < women_ranks[w][current_partner]:\n                # She prefers the new man m.\n                woman_partner[w] = m\n                man_partner[m] = w\n                \n                # Her old partner becomes free.\n                man_partner[current_partner] = -1\n                free_men_q.append(current_partner)\n            else:\n                # She rejects m, m remains free and will propose to the next on his list.\n                free_men_q.append(m)\n    \n    return man_partner\n\ndef solve_case(n, men_tiered_prefs, women_tiered_prefs, designated_man_idx):\n    \"\"\"\n    Calculates the expected tier for a designated man for a single test case.\n    \"\"\"\n    # 1. Identify all ties and generate the set of permutations for each.\n    # tie_permutations_list will be a list of lists of tuples, e.g., [[(0,1), (1,0)], [(0,1), (1,0)]]\n    tie_permutations_list = []\n    \n    def find_ties(agent_prefs_list):\n        for agent_prefs in agent_prefs_list:\n            for tier in agent_prefs:\n                if len(tier) > 1:\n                    tie_permutations_list.append(list(permutations(tier)))\n\n    find_ties(men_tiered_prefs)\n    find_ties(women_tiered_prefs)\n\n    # 2. Prepare for iteration by creating a tier lookup map for the designated man.\n    # This maps each woman to her tier index (1-based) in the original preferences.\n    designated_man_tier_map = {}\n    for tier_idx, tier in enumerate(men_tiered_prefs[designated_man_idx]):\n        for woman in tier:\n            designated_man_tier_map[woman] = tier_idx + 1\n\n    total_tier_sum = 0\n    num_outcomes = 0\n\n    # Handle the case where there are no ties.\n    if not tie_permutations_list:\n        outcomes_iterator = [()]\n    else:\n        outcomes_iterator = product(*tie_permutations_list)\n\n    # 3. Iterate through all possible tie-breaking outcomes.\n    for outcome_permutations in outcomes_iterator:\n        num_outcomes += 1\n        perm_iterator = iter(outcome_permutations)\n\n        # 3a. For each outcome, build strict preference lists.\n        def build_strict_list(tiered_prefs):\n            strict_list = []\n            for tier in tiered_prefs:\n                if len(tier) > 1:\n                    strict_list.extend(next(perm_iterator))\n                else:\n                    strict_list.extend(tier)\n            return strict_list\n        \n        strict_men_prefs = [build_strict_list(p) for p in men_tiered_prefs]\n        strict_women_prefs = [build_strict_list(p) for p in women_tiered_prefs]\n        \n        # 3b. Run Gale-Shapley algorithm.\n        matching = run_gale_shapley(n, strict_men_prefs, strict_women_prefs)\n        \n        # 3c/d. Find designated man's partner, look up tier, and add to sum.\n        partner = matching[designated_man_idx]\n        tier = designated_man_tier_map[partner]\n        total_tier_sum += tier\n\n    # 4. Calculate the expected tier.\n    return total_tier_sum / num_outcomes\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"n\": 3,\n            \"men_prefs\": [[[0, 1], [2]], [[1], [0], [2]], [[1], [2], [0]]],\n            \"women_prefs\": [[[0, 1], [2]], [[2], [1], [0]], [[0], [1], [2]]],\n            \"designated_man\": 0,\n        },\n        # Test case 2\n        {\n            \"n\": 3,\n            \"men_prefs\": [[[0], [1], [2]], [[1], [0], [2]], [[1], [2], [0]]],\n            \"women_prefs\": [[[1], [0], [2]], [[0], [1], [2]], [[0], [1], [2]]],\n            \"designated_man\": 1,\n        },\n        # Test case 3\n        {\n            \"n\": 3,\n            \"men_prefs\": [[[0], [1], [2]], [[1], [0], [2]], [[1], [2], [0]]],\n            \"women_prefs\": [[[0, 1], [2]], [[1, 2], [0]], [[0], [1], [2]]],\n            \"designated_man\": 0,\n        },\n        # Test case 4\n        {\n            \"n\": 2,\n            \"men_prefs\": [[[0, 1]], [[0, 1]]],\n            \"women_prefs\": [[[0, 1]], [[0, 1]]],\n            \"designated_man\": 0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        expected_tier = solve_case(\n            case[\"n\"], case[\"men_prefs\"], case[\"women_prefs\"], case[\"designated_man\"]\n        )\n        results.append(f\"{expected_tier:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3273994"}]}