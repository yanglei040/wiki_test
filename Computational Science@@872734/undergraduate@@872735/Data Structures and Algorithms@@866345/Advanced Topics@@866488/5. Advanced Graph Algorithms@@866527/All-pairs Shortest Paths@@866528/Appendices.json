{"hands_on_practices": [{"introduction": "To truly understand an algorithm, there is no substitute for walking through its execution step-by-step. This first exercise invites you to do just that with the Floyd-Warshall algorithm. By manually applying the update rule, you will build a concrete intuition for how the algorithm systematically considers each vertex as a potential intermediate point to improve path estimates, revealing the core of its dynamic programming approach [@problem_id:1504965].", "problem": "Consider a weighted directed graph with 4 vertices, labeled 1, 2, 3, and 4. The costs of the direct paths between any two vertices are given by an initial distance matrix $D^{(0)}$. In this matrix, the element $D^{(0)}_{ij}$ represents the weight of the directed edge from vertex $i$ to vertex $j$. If no direct edge exists from $i$ to $j$, the weight is considered infinite ($\\infty$). The self-distance $D^{(0)}_{ii}$ is 0 for all vertices.\n\nThe initial distance matrix $D^{(0)}$ is given as:\n$$ D^{(0)} = \\begin{pmatrix} 0  4  \\infty  7 \\\\ \\infty  0  1  \\infty \\\\ 6  \\infty  0  2 \\\\ 3  -2  \\infty  0 \\end{pmatrix} $$\n\nThe Floyd-Warshall algorithm computes the all-pairs shortest paths by iteratively updating this matrix. In the $k$-th iteration (for $k=1, 2, \\dots, 4$), the algorithm considers paths that use vertex $k$ as an intermediate vertex to potentially find a shorter path between any two vertices $i$ and $j$.\n\nStarting with the given matrix $D^{(0)}$, perform the first two iterations of the Floyd-Warshall algorithm to compute the matrices $D^{(1)}$ (using $k=1$) and $D^{(2)}$ (using $k=2$). Your task is to determine the final state of the distance matrix after the second iteration, $D^{(2)}$.", "solution": "We use the Floyd-Warshall update rule: for each iteration $k$ and for all $i,j$,\n$$\nD^{(k)}_{ij}=\\min\\left(D^{(k-1)}_{ij},\\,D^{(k-1)}_{ik}+D^{(k-1)}_{kj}\\right).\n$$\nGiven\n$$\nD^{(0)}=\\begin{pmatrix}\n0  4  \\infty  7\\\\\n\\infty  0  1  \\infty\\\\\n6  \\infty  0  2\\\\\n3  -2  \\infty  0\n\\end{pmatrix},\n$$\nwe perform the first iteration with $k=1$, using $D^{(1)}_{ij}=\\min\\left(D^{(0)}_{ij},\\,D^{(0)}_{i1}+D^{(0)}_{1j}\\right)$.\n\nFor $i=1$:\n- $j=1$: $\\min(0,\\,0+0)=0$.\n- $j=2$: $\\min(4,\\,0+4)=4$.\n- $j=3$: $\\min(\\infty,\\,0+\\infty)=\\infty$.\n- $j=4$: $\\min(7,\\,0+7)=7$.\n\nFor $i=2$ (since $D^{(0)}_{21}=\\infty$, all via $1$ are $\\infty$):\n- $j=1$: $\\min(\\infty,\\,\\infty)=\\infty$.\n- $j=2$: $\\min(0,\\,\\infty)=0$.\n- $j=3$: $\\min(1,\\,\\infty)=1$.\n- $j=4$: $\\min(\\infty,\\,\\infty)=\\infty$.\n\nFor $i=3$ (with $D^{(0)}_{31}=6$):\n- $j=1$: $\\min(6,\\,6+0)=6$.\n- $j=2$: $\\min(\\infty,\\,6+4)=10$.\n- $j=3$: $\\min(0,\\,6+\\infty)=0$.\n- $j=4$: $\\min(2,\\,6+7)=2$.\n\nFor $i=4$ (with $D^{(0)}_{41}=3$):\n- $j=1$: $\\min(3,\\,3+0)=3$.\n- $j=2$: $\\min(-2,\\,3+4)=-2$.\n- $j=3$: $\\min(\\infty,\\,3+\\infty)=\\infty$.\n- $j=4$: $\\min(0,\\,3+7)=0$.\n\nThus\n$$\nD^{(1)}=\\begin{pmatrix}\n0  4  \\infty  7\\\\\n\\infty  0  1  \\infty\\\\\n6  10  0  2\\\\\n3  -2  \\infty  0\n\\end{pmatrix}.\n$$\n\nNext, perform the second iteration with $k=2$, using $D^{(2)}_{ij}=\\min\\left(D^{(1)}_{ij},\\,D^{(1)}_{i2}+D^{(1)}_{2j}\\right)$.\n\nFor $i=1$ (with $D^{(1)}_{12}=4$):\n- $j=1$: $\\min(0,\\,4+\\infty)=0$.\n- $j=2$: $\\min(4,\\,4+0)=4$.\n- $j=3$: $\\min(\\infty,\\,4+1)=5$.\n- $j=4$: $\\min(7,\\,4+\\infty)=7$.\n\nFor $i=2$ (with $D^{(1)}_{22}=0$):\n- $j=1$: $\\min(\\infty,\\,0+\\infty)=\\infty$.\n- $j=2$: $\\min(0,\\,0+0)=0$.\n- $j=3$: $\\min(1,\\,0+1)=1$.\n- $j=4$: $\\min(\\infty,\\,0+\\infty)=\\infty$.\n\nFor $i=3$ (with $D^{(1)}_{32}=10$):\n- $j=1$: $\\min(6,\\,10+\\infty)=6$.\n- $j=2$: $\\min(10,\\,10+0)=10$.\n- $j=3$: $\\min(0,\\,10+1)=0$.\n- $j=4$: $\\min(2,\\,10+\\infty)=2$.\n\nFor $i=4$ (with $D^{(1)}_{42}=-2$):\n- $j=1$: $\\min(3,\\, -2+\\infty)=3$.\n- $j=2$: $\\min(-2,\\, -2+0)=-2$.\n- $j=3$: $\\min(\\infty,\\, -2+1)=-1$.\n- $j=4$: $\\min(0,\\, -2+\\infty)=0$.\n\nTherefore, the matrix after the second iteration is\n$$\nD^{(2)}=\\begin{pmatrix}\n0  4  5  7\\\\\n\\infty  0  1  \\infty\\\\\n6  10  0  2\\\\\n3  -2  -1  0\n\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0  4  5  7 \\\\ \\infty  0  1  \\infty \\\\ 6  10  0  2 \\\\ 3  -2  -1  0\\end{pmatrix}}$$", "id": "1504965"}, {"introduction": "The correctness of many algorithms depends on a precise sequence of operations. This practice moves beyond rote execution to explore the 'why' behind the Floyd-Warshall algorithm's structure. By analyzing a common but incorrect modification to its loop ordering, you will uncover the critical importance of the dynamic programming invariant, which ensures that subproblems are solved before their solutions are needed to solve larger problems [@problem_id:1504971].", "problem": "The Floyd-Warshall algorithm is a classic dynamic programming method for finding the shortest paths between all pairs of vertices in a weighted, directed graph. The standard implementation uses three nested loops, where `k` represents the intermediate vertex being considered, while `i` and `j` represent the source and destination vertices of a path, respectively.\n\nThe standard pseudocode is as follows, assuming the `dist[i][j]` matrix is initialized to the direct edge weight if an edge `(i, j)` exists, `0` if `i = j`, and infinity otherwise. The number of vertices is `n`.\n\n**Standard-FW(dist, n):**\n```\nfor k from 1 to n:\n  for i from 1 to n:\n    for j from 1 to n:\n      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n```\n\nA student, reasoning that the order of iteration might not matter, proposes an alternative implementation where the loop order is changed to `i-j-k`:\n\n**Flawed-FW(dist, n):**\n```\nfor i from 1 to n:\n  for j from 1 to n:\n    for k from 1 to n:\n      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n```\n\nWhile `Flawed-FW` may produce the correct shortest paths for certain simple graphs, it is fundamentally incorrect and will fail in the general case. Which of the following statements best explains the primary logical flaw that can cause `Flawed-FW` to calculate incorrect shortest path lengths?\n\nA. The algorithm fails because the innermost loop over `k` does not consider all possible intermediate vertices for a given path from `i` to `j`.\n\nB. The algorithm is guaranteed to fail only if the graph contains a negative-weight cycle.\n\nC. The algorithm only works correctly for Directed Acyclic Graphs (DAGs), and fails for any graph with cycles.\n\nD. When calculating the path from `i` to `j`, the value `dist[k][j]` used in the relaxation step is not guaranteed to be the shortest path from `k` to `j`, as the main loop may not have processed `k` as a source vertex yet.\n\nE. The algorithm is logically correct but computationally less efficient than the standard `k-i-j` implementation, leading to incorrect results due to practical time limits.", "solution": "Let $G=(V,E)$ be a directed graph with weight function $w:V\\times V\\to \\mathbb{R}$, and let $n=|V|$. Define $D^{(k)}[i][j]$ to be the length of the shortest $i\\to j$ path whose intermediate vertices lie in the set $\\{1,2,\\dots,k\\}$. The dynamic programming recurrence is\n$$\nD^{(k)}[i][j] \\;=\\; \\min\\!\\big(D^{(k-1)}[i][j],\\; D^{(k-1)}[i][k] + D^{(k-1)}[k][j]\\big).\n$$\nThe standard Floyd–Warshall algorithm maintains the invariant that, at the start of the outer loop iteration for a fixed $k$, the working matrix $dist$ equals $D^{(k-1)}$. During that iteration, for all pairs $(i,j)$, it performs\n$$\ndist[i][j] \\leftarrow \\min\\!\\big(dist[i][j],\\; dist[i][k]+dist[k][j]\\big),\n$$\nwhich exactly implements the recurrence with all right-hand side terms taken from $D^{(k-1)}$. The correctness relies on the fact that, with $k$ fixed as the outer loop variable, the values $dist[i][k]$ and $dist[k][j]$ used in the update are already the shortest-path lengths allowing only intermediates in $\\{1,\\dots,k-1\\}$.\n\nIn the proposed $i$-$j$-$k$ loop order, when computing a fixed pair $(i,j)$ and iterating $k$ in the innermost loop, the update\n$$\ndist[i][j] \\leftarrow \\min\\!\\big(dist[i][j],\\; dist[i][k]+dist[k][j]\\big)\n$$\nrequires that $dist[i][k]$ and $dist[k][j]$ reflect $D^{(k-1)}$. However, this requirement is not satisfied: the value $dist[k][j]$ at that moment depends on whether the outer loop has reached $i=k$. Specifically, $dist[k][j]$ is only fully updated (as a source $k$) when the outer loop index $i$ equals $k$. If the current $i$ is less than $k$, then $dist[k][j]$ may not yet incorporate all intermediates in $\\{1,\\dots,k-1\\}$; it may be a larger, outdated value. Consequently, the relaxation for $(i,j)$ can miss a shorter route through $k$ because it uses a non-final $dist[k][j]$. After $i$ advances and eventually reaches $k$, $dist[k][j]$ may improve, but the algorithm does not retroactively revisit the earlier $(i,j)$ pairs to exploit this improvement. This violates the subproblem dependency ordering required by the recurrence.\n\nTherefore, the primary logical flaw is that, when calculating the path from $i$ to $j$ in the $i$-$j$-$k$ ordering, the term $dist[k][j]$ used in the relaxation is not guaranteed to equal the appropriate shortest path from $k$ to $j$ (with intermediates restricted as required), because the algorithm may not yet have processed $k$ as a source. This is exactly described by option D.\n\nBriefly, the other options are not the root cause:\n- A is false because all $k$ are iterated; the issue is the correctness of the values used, not coverage of $k$.\n- B is false because the flaw occurs even without negative cycles; both versions fail with negative cycles, but this is not the distinguishing cause.\n- C is false because correctness does not hinge on acyclicity; the standard algorithm works on general graphs without negative cycles.\n- E is false because the issue is logical correctness (ordering/invariants), not efficiency or time limits.\n\nHence the correct choice is D.", "answer": "$$\\boxed{D}$$", "id": "1504971"}, {"introduction": "Standard algorithms provide powerful tools, but real-world scenarios often come with extra twists. This advanced problem challenges you to adapt the principles of shortest path finding to a new set of rules involving a budget on \"toll roads.\" The key to solving this is not to invent a new algorithm from scratch, but to cleverly model the problem by expanding the state space, a fundamental and widely applicable technique in algorithm design that transforms a constrained problem into a standard one on a larger, conceptual graph [@problem_id:3206273].", "problem": "Consider a directed, weighted graph $G = (V,E)$ where $V = \\{0,1,\\dots,n-1\\}$ for some integer $n \\geq 1$, and $E \\subseteq V \\times V$ is a set of directed edges. Each directed edge $(u,v) \\in E$ has an associated nonnegative real weight $w(u,v) \\geq 0$ and a binary attribute $\\tau(u,v) \\in \\{0,1\\}$ indicating whether the edge is a toll segment ($\\tau(u,v) = 1$) or a non-toll segment ($\\tau(u,v) = 0$). For any ordered pair of vertices $(u,v) \\in V \\times V$, a path $\\pi$ from $u$ to $v$ is a sequence of vertices $(u = x_0, x_1, \\dots, x_m = v)$ such that $(x_i, x_{i+1}) \\in E$ for all integers $i$ satisfying $0 \\leq i  m$. The length of path $\\pi$ is defined as the sum of weights $\\sum_{i=0}^{m-1} w(x_i, x_{i+1})$, and the toll count of path $\\pi$ is defined as $\\sum_{i=0}^{m-1} \\tau(x_i, x_{i+1})$. For a given nonnegative integer $k$, define the constrained all-pairs shortest-path distance $d_k(u,v)$ to be the infimum of the lengths of all paths from $u$ to $v$ whose toll count is at most $k$. If no such path exists, define $d_k(u,v) = +\\infty$.\n\nYour task is to write a complete, runnable program that computes, for each provided test case, the matrix of constrained all-pairs shortest-path distances $D_k \\in \\mathbb{R}^{n \\times n}$ where the entry at row $i$ and column $j$ equals $d_k(i,j)$. The computation must be derived from fundamental principles, starting from the definition of paths and the principle of optimality, and must handle directed graphs, nonnegative edge weights, and the toll constraint. In the output, represent $+\\infty$ using the floating-point infinity of the programming language's standard numerical type.\n\nUse the following test suite, where each test case specifies $(n, E, k)$ with explicit edges. Each edge is given as a quadruple $(u,v,w,\\tau)$, where $u$ and $v$ are integers in $\\{0,1,\\dots,n-1\\}$, $w$ is a nonnegative real weight, and $\\tau \\in \\{0,1\\}$ indicates whether the edge is a toll segment. All numbers that appear are exact and unitless.\n\nTest case $1$ (general case, mixed tolls, moderate constraint):\n- $n = 4$\n- $E = \\{(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)\\}$\n- $k = 1$\n\nTest case $2$ (boundary case, no tolls allowed):\n- $n = 4$\n- $E = \\{(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)\\}$\n- $k = 0$\n\nTest case $3$ (all edges are toll segments, limited toll budget, directed reachability edge cases):\n- $n = 3$\n- $E = \\{(0,1,5,1), (1,2,5,1), (0,2,20,1)\\}$\n- $k = 1$\n\nTest case $4$ (directed cycles with mixed tolls, larger constraint):\n- $n = 5$\n- $E = \\{(0,1,1,0), (1,2,1,1), (2,4,1,0), (0,3,10,0), (3,2,1,1), (1,3,2,0), (3,4,2,0), (4,1,1,1), (4,0,5,0)\\}$\n- $k = 3$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the $n \\times n$ distance matrix $D_k$ for the corresponding test case represented as a list of lists of floating-point numbers, with $+\\infty$ represented by the language’s floating-point infinity. For example, the output format should be of the form $[M_1,M_2,M_3,M_4]$, where each $M_t$ is the matrix for test case $t$.", "solution": "The core task is to compute the constrained all-pairs shortest-path distance $d_k(u,v)$ for a directed graph $G=(V,E)$ with $V=\\{0,1,\\dots,n-1\\}$. This distance is the infimum of lengths of all paths from vertex $u$ to vertex $v$ having a total toll count of at most $k$. The toll count of a path is the sum of binary toll attributes $\\tau$ over its edges, and the length is the sum of non-negative weights $w$.\n\nThis problem can be solved by transforming it into a standard shortest path problem on an augmented graph, a technique directly rooted in the principle of optimality. The state of a path must not only encode the current vertex but also the resources consumed—in this case, the number of toll segments used.\n\nLet us define an augmented graph $G'=(V', E')$.\nThe set of vertices $V'$ is the Cartesian product of the original vertex set $V$ and the set of possible toll counts $\\{0, 1, \\dots, k\\}$.\n$$V' = V \\times \\{0, 1, \\dots, k\\}$$\nA vertex $(v,t) \\in V'$ represents the state of reaching vertex $v \\in V$ having traversed a path with a total toll count of exactly $t$. The size of $V'$ is $n \\cdot (k+1)$.\n\nThe set of edges $E'$ is constructed from the edges in $E$. For each edge $(u,v) \\in E$ with weight $w(u,v)$ and toll attribute $\\tau(u,v)$, we define a set of corresponding edges in $G'$. An edge from $u$ to $v$ in $G$ allows a transition from a state at $u$ to a state at $v$. Specifically, if we are at vertex $u$ with $t$ tolls used, traversing the edge $(u,v)$ leads us to vertex $v$ with a new toll count of $t + \\tau(u,v)$. This transition is valid only if the new toll count does not exceed the budget $k$.\nFormally, for each edge $(u,v) \\in E$ and for each integer $t \\in \\{0, 1, \\dots, k\\}$:\nIf $t + \\tau(u,v) \\le k$, we add a directed edge in $E'$ from vertex $(u,t)$ to vertex $(v, t + \\tau(u,v))$ with weight $w(u,v)$.\n$$E' = \\{ ((u,t), (v, t+\\tau(u,v))) \\mid (u,v) \\in E, t \\in \\{0,\\dots,k\\}, t+\\tau(u,v) \\le k \\}$$\nThe weight of the edge $((u,t), (v, t+\\tau(u,v)))$ in $G'$ is defined to be $w(u,v)$.\n\nSince all original edge weights $w(u,v)$ are non-negative, all edge weights in $G'$ are also non-negative. This is a crucial property, as it allows for the application of efficient shortest path algorithms like Dijkstra's. The graph $G'$ is a directed graph, and it can contain cycles if the original graph $G$ contains cycles. However, any cycle in $G'$ formed by edges corresponding to toll edges from $G$ would involve an increase in the toll-count component of the vertex, while a cycle of non-toll edges would leave the toll-count component unchanged. Thus, the state space exploration is guaranteed to terminate.\n\nThe problem asks for $d_k(u,v)$, the shortest path from $u$ to $v$ using *at most* $k$ tolls. A path from $u$ in $G$ begins with $0$ tolls used. In the augmented graph $G'$, this corresponds to starting at vertex $(u,0)$. A path to $v$ in $G$ with at most $k$ tolls corresponds to a path in $G'$ from $(u,0)$ to any of the vertices $(v,t')$ where $t' \\in \\{0, 1, \\dots, k\\}$. The length of the shortest such path is the minimum of the distances from $(u,0)$ to each of these possible destination vertices.\nLet $\\text{dist}_{G'}((a, t_a), (b, t_b))$ be the shortest path distance in $G'$. Then, the constrained distance $d_k(u,v)$ is given by:\n$$d_k(u,v) = \\min_{0 \\le t' \\le k} \\left\\{ \\text{dist}_{G'}((u,0), (v,t')) \\right\\}$$\nTo compute the all-pairs matrix $D_k$, we must find these values for all pairs $(u,v) \\in V \\times V$. This can be achieved by running a single-source shortest path (SSSP) algorithm on $G'$ from each source vertex of the form $(u,0)$ for all $u \\in V$.\n\nThe overall algorithmic procedure is as follows:\n$1$. Initialize an $n \\times n$ result matrix $D_k$ with $+\\infty$ for all entries, and $0$ on the diagonal.\n$2$. For each starting vertex $s \\in \\{0, 1, \\dots, n-1\\}$:\n    a. We need to find the shortest path distances from $(s,0)$ to all other vertices $(v,t)$ in $G'$. We can use Dijkstra's algorithm for this.\n    b. Initialize a distance array $\\delta_s$ of size $n \\times (k+1)$ to $+\\infty$, representing the shortest known distances from $(s,0)$. Set $\\delta_s(s,0) = 0$.\n    c. Use a priority queue for Dijkstra's algorithm, storing tuples of (distance, vertex, tolls). Initially, it contains $(0, s, 0)$.\n    d. While the priority queue is not empty, extract the state $(d, u_{curr}, t_{curr})$ with the minimum distance $d$. If $d  \\delta_s(u_{curr}, t_{curr})$, this is a stale entry, so skip it.\n    e. For each outgoing edge $(u_{curr}, v_{next}) \\in E$ with weight $w$ and toll $\\tau$:\n        i. Calculate the new toll count $t_{next} = t_{curr} + \\tau$.\n        ii. If $t_{next} \\le k$:\n            - If $\\delta_s(u_{curr}, t_{curr}) + w  \\delta_s(v_{next}, t_{next})$, update the distance: $\\delta_s(v_{next}, t_{next}) = \\delta_s(u_{curr}, t_{curr}) + w$.\n            - Add $( \\delta_s(v_{next}, t_{next}), v_{next}, t_{next} )$ to the priority queue.\n    f. After Dijkstra's algorithm terminates, the array $\\delta_s$ contains the shortest path distances from $(s,0)$ to all reachable $(v,t)$ states.\n    g. For each destination vertex $v \\in \\{0, 1, \\dots, n-1\\}$, compute the entry for the final result matrix:\n       $$(D_k)_{sv} = \\min_{0 \\le t' \\le k} \\delta_s(v, t')$$\n$3$. After iterating through all starting vertices $s \\in V$, the matrix $D_k$ will be completely populated with the constrained all-pairs shortest-path distances.\n\nThis method is a direct application of the principle of optimality on the expanded state space and correctly solves the given problem.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    \n    # Test case 1 (general case, mixed tolls, moderate constraint):\n    # n = 4, k = 1\n    # E = {(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)}\n    test_case_1 = {\n        \"n\": 4,\n        \"k\": 1,\n        \"edges\": [(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)]\n    }\n\n    # Test case 2 (boundary case, no tolls allowed):\n    # n = 4, k = 0\n    # E = {(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)}\n    test_case_2 = {\n        \"n\": 4,\n        \"k\": 0,\n        \"edges\": [(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)]\n    }\n\n    # Test case 3 (all edges are toll segments, limited toll budget, directed reachability edge cases):\n    # n = 3, k = 1\n    # E = {(0,1,5,1), (1,2,5,1), (0,2,20,1)}\n    test_case_3 = {\n        \"n\": 3,\n        \"k\": 1,\n        \"edges\": [(0,1,5,1), (1,2,5,1), (0,2,20,1)]\n    }\n\n    # Test case 4 (directed cycles with mixed tolls, larger constraint):\n    # n = 5, k = 3\n    # E = {(0,1,1,0), (1,2,1,1), (2,4,1,0), (0,3,10,0), (3,2,1,1), (1,3,2,0), (3,4,2,0), (4,1,1,1), (4,0,5,0)}\n    test_case_4 = {\n        \"n\": 5,\n        \"k\": 3,\n        \"edges\": [(0,1,1,0), (1,2,1,1), (2,4,1,0), (0,3,10,0), (3,2,1,1), (1,3,2,0), (3,4,2,0), (4,1,1,1), (4,0,5,0)]\n    }\n\n    test_cases = [test_case_1, test_case_2, test_case_3, test_case_4]\n    results = []\n\n    for case in test_cases:\n        n = case[\"n\"]\n        k = case[\"k\"]\n        edges = case[\"edges\"]\n        \n        # Adjacency list representation of the graph\n        adj = [[] for _ in range(n)]\n        for u, v, w, tau in edges:\n            adj[u].append((v, w, tau))\n\n        # The final n x n distance matrix for this test case\n        result_matrix = np.full((n, n), np.inf)\n\n        for start_node in range(n):\n            # dists[v][t]: shortest distance to vertex v using exactly t tolls\n            dists = np.full((n, k + 1), np.inf)\n            \n            # Priority queue for Dijkstra's algorithm\n            # (distance, vertex, tolls_used)\n            pq = [(0, start_node, 0)]\n            dists[start_node][0] = 0\n\n            while pq:\n                d, u, t = heapq.heappop(pq)\n\n                # If we found a shorter path already, skip\n                if d  dists[u][t]:\n                    continue\n\n                # Explore neighbors in the original graph\n                for v, w, tau in adj[u]:\n                    new_t = t + tau\n                    if new_t = k:\n                        if dists[u][t] + w  dists[v][new_t]:\n                            dists[v][new_t] = dists[u][t] + w\n                            heapq.heappush(pq, (dists[v][new_t], v, new_t))\n            \n            # For the current start_node, find the shortest path to all other nodes\n            # by taking the minimum over all possible toll counts up to k.\n            for end_node in range(n):\n                min_dist = np.min(dists[end_node, :])\n                result_matrix[start_node, end_node] = min_dist\n\n        results.append(result_matrix.tolist())\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists containing np.inf is 'inf'\n    # which is the standard representation for float('inf').\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3206273"}]}