{"hands_on_practices": [{"introduction": "This first practice is a classic puzzle that beautifully demonstrates the power and elegance of the bitwise XOR operation. By leveraging the self-inverse property of XOR ($x \\oplus x = 0$), you will develop a highly efficient algorithm to find a unique element in an array. This exercise is fundamental for appreciating how bitwise properties can lead to surprisingly simple solutions for seemingly complex data-sifting problems. [@problem_id:3275306]", "problem": "You are given a static array, that is, a contiguous block of memory with a fixed length, in which every element appears exactly twice except for one element that appears exactly once. The goal is to identify that single element using only bitwise exclusive-or operations. A static array supports constant-time random access, and its logical model is that the elements occupy consecutive indices starting at $0$ and ending at $n-1$, where $n$ denotes the number of elements.\n\nStart from the following fundamental base for discrete binary operations and static arrays:\n- A static array $A$ of length $n$ is a sequence $(A[0], A[1], \\dots, A[n-1])$ stored contiguously, and its size $n$ does not change.\n- Bitwise exclusive-or (denoted $\\oplus$) is a binary operation on integers defined bitwise on their two's complement representation, with the well-tested algebraic facts: $a \\oplus a = 0$, $a \\oplus 0 = a$, commutativity $a \\oplus b = b \\oplus a$, and associativity $(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$.\n\nDerive, from these principles without relying on any shortcut formulas, an algorithm that computes the single element that appears once. Your algorithm must:\n- Read a static array $A$ and produce an integer.\n- Use only the bitwise exclusive-or operation $\\oplus$ to combine array elements; do not use any hashing, sorting, or auxiliary data structures beyond $O(1)$ additional memory.\n- Run in time $O(n)$ and space $O(1)$.\n\nNo physical units, angles, or percentages are involved in this problem.\n\nFor testability, apply your algorithm to the following test suite of static arrays, each satisfying the condition that every element except one appears exactly twice:\n- Test $1$: the array $[\\,2,\\,1,\\,4,\\,5,\\,2,\\,4,\\,1\\,]$.\n- Test $2$: the array $[\\,42\\,]$.\n- Test $3$: the array $[\\,{-7},\\,{-7},\\,0,\\,0,\\,{-3}\\,]$.\n- Test $4$: the array $[\\,2147483647,\\,99,\\,2147483647\\,]$.\n- Test $5$: the array $[\\,8,\\,9,\\,9,\\,10,\\,10,\\,11,\\,11,\\,12,\\,12,\\,8,\\,13\\,]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Concretely, if the results for Tests $1$ through $5$ are $r_1, r_2, r_3, r_4, r_5$ respectively, print the line\n$[r_1,r_2,r_3,r_4,r_5]$.", "solution": "The problem has been validated and is determined to be sound. It is scientifically grounded, well-posed, and objective. The problem is a formalizable exercise in algorithm design based on the mathematical properties of bitwise operations. All necessary information is provided, and the constraints are consistent and clear.\n\nThe objective is to devise an algorithm to identify the unique element in a static array $A$ of length $n$, where all other elements appear exactly twice. The algorithm is constrained to use only the bitwise exclusive-or (XOR) operation, denoted by $\\oplus$, for combining elements. It must operate in $O(n)$ time and $O(1)$ space.\n\nThe derivation of the algorithm proceeds from the fundamental algebraic properties of the XOR operation provided in the problem statement:\n1.  Self-inverse property: $a \\oplus a = 0$ for any integer $a$.\n2.  Identity element: $a \\oplus 0 = a$ for any integer $a$.\n3.  Commutativity: $a \\oplus b = b \\oplus a$ for any integers $a, b$.\n4.  Associativity: $(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$ for any integers $a, b, c$.\n\nConsider the result $R$ obtained by applying the XOR operation across all elements of the array $A$:\n$$ R = A[0] \\oplus A[1] \\oplus \\dots \\oplus A[n-1] = \\bigoplus_{i=0}^{n-1} A[i] $$\nThe problem states that the array consists of a multiset of numbers where each element appears twice, except for one unique element. Let the set of distinct elements that appear twice be $\\{v_1, v_2, \\dots, v_k\\}$, and let the unique element be $u$. The array $A$ is therefore a permutation of the multiset $\\{v_1, v_1, v_2, v_2, \\dots, v_k, v_k, u\\}$.\n\nDue to the commutative and associative properties of XOR, the order of operations in the total XOR-sum does not affect the final result. We can re-group the elements of the array to pair identical values:\n$$ R = (v_1 \\oplus v_1) \\oplus (v_2 \\oplus v_2) \\oplus \\dots \\oplus (v_k \\oplus v_k) \\oplus u $$\nApplying the self-inverse property, $a \\oplus a = 0$, to each pair:\n$$ v_i \\oplus v_i = 0 \\quad \\text{for } i = 1, \\dots, k $$\nSubstituting this result into the expression for $R$:\n$$ R = 0 \\oplus 0 \\oplus \\dots \\oplus 0 \\oplus u $$\nThe XOR-sum of any number of $0$s is $0$. Therefore, the expression simplifies to:\n$$ R = 0 \\oplus u $$\nFinally, applying the identity property, $a \\oplus 0 = a$:\n$$ R = u $$\nThis derivation rigorously demonstrates that the XOR-sum of all elements in the array is precisely equal to the unique element, $u$.\n\nThis leads to the following algorithm:\n1.  Initialize an accumulator variable to $0$, which is the identity element for the XOR operation.\n2.  Iterate through the array $A$ from index $i=0$ to $n-1$.\n3.  For each element $A[i]$, update the accumulator by computing `accumulator = accumulator` $\\oplus$ `A[i]`.\n4.  After the iteration is complete, the final value of the accumulator is the unique element.\n\nThis algorithm accesses each of the $n$ elements once, performing a constant-time XOR operation for each. Thus, its time complexity is $O(n)$. The algorithm requires only a single variable for the accumulator, so its space complexity is $O(1)$. These complexities satisfy the problem's requirements.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies an algorithm to find the single unique element in arrays\n    where all other elements appear twice, using only bitwise XOR operations.\n    \"\"\"\n\n    def find_unique_element(arr: np.ndarray) - np.int64:\n        \"\"\"\n        Computes the unique element in an array by XORing all its elements.\n\n        This method is based on the algebraic properties of XOR:\n        1. a ^ a = 0 (self-inverse)\n        2. a ^ 0 = a (identity)\n        3. a ^ b = b ^ a (commutativity)\n        4. (a ^ b) ^ c = a ^ (b ^ c) (associativity)\n\n        The XOR sum of all elements simplifies to the unique element because all\n        paired elements cancel each other out (e.g., v1^v1^v2^v2^u = 0^0^u = u).\n\n        Args:\n            arr: A NumPy array of integers where one element appears once\n                 and all others appear twice.\n\n        Returns:\n            The integer that appears exactly once in the array.\n        \"\"\"\n        # The identity element for the XOR operation is 0.\n        # We use a fixed-size integer type consistent with a static array model.\n        accumulator = np.int64(0)\n        \n        # Iterate through all elements of the array.\n        for element in arr:\n            # Update the accumulator by XORing it with the current element.\n            accumulator ^= element\n            \n        return accumulator\n\n    # Define the test cases from the problem statement.\n    # The arrays are defined with a 64-bit integer type to accommodate the\n    # full range of values including negatives and large numbers.\n    test_cases = [\n        np.array([2, 1, 4, 5, 2, 4, 1], dtype=np.int64),\n        np.array([42], dtype=np.int64),\n        np.array([-7, -7, 0, 0, -3], dtype=np.int64),\n        np.array([2147483647, 99, 2147483647], dtype=np.int64),\n        np.array([8, 9, 9, 10, 10, 11, 11, 12, 12, 8, 13], dtype=np.int64),\n    ]\n\n    results = []\n    for case in test_cases:\n        # For each test case, apply the derived algorithm.\n        unique_element = find_unique_element(case)\n        results.append(unique_element)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3275306"}, {"introduction": "Moving beyond a single operation, this next challenge requires you to reason about the binary structure of integers and the constraints imposed by bitwise AND. The task is to find a number that satisfies specific magnitude and bitwise conditions relative to a given integer $N$. This practice sharpens your ability to think about numbers at the bit level, connecting their binary representation to their mathematical properties. [@problem_id:3217636]", "problem": "Consider a non-negative $64$-bit unsigned integer $N$ written in base-$2$ as a finite binary word. The bitwise AND of two non-negative integers $x$ and $y$, denoted $x \\,\\\\, y$, is defined bitwise: if $x$ has binary digits $\\{x_i\\}_{i \\geq 0}$ and $y$ has binary digits $\\{y_i\\}_{i \\geq 0}$, then the $i$-th bit of $x \\,\\\\, y$ is $x_i y_i$, where juxtaposition denotes the ordinary product of $0$ and $1$. A binary word is ordered by its Most Significant Bit (MSB): if the highest non-zero bit of $x$ occurs at position $k$ (with the Least Significant Bit (LSB) at position $0$), then $x \\in [2^{k}, 2^{k+1}-1]$ in base-$10$.\n\nGiven $N = 987654321$, determine the smallest unsigned integer $M$ satisfying $M > N$ and $N \\,\\\\, M = 0$. Express your final answer as a base-$10$ integer.", "solution": "The problem requires finding the smallest integer $M$ that satisfies two conditions relative to a given integer $N$: (1) $M > N$ and (2) $N \\ \\ \\ M = 0$.\n\nLet's analyze these conditions based on the binary representations of $N$ and $M$.\nThe condition $N \\ \\ \\ M = 0$ implies that for any bit position $i$, if the $i$-th bit of $N$ is 1, then the $i$-th bit of $M$ must be 0. This is because the bitwise AND operation results in a 1 at a given position only if both operands have a 1 at that position.\n\nLet $k = \\lfloor \\log_2 N \\rfloor$ be the index of the most significant bit (MSB) of $N$. This means the $k$-th bit of $N$ is 1, and all bits at positions higher than $k$ are 0. From the condition $N \\ \\ \\ M = 0$, it follows that the $k$-th bit of $M$ must be 0.\n\nNow, consider the condition $M > N$. For $M$ to be larger than $N$, $M$ must have a set bit (a 1) at a more significant position than $N$ does.\nIf the MSB of $M$ were at any position $j \\le k$, then $M$ would be smaller than $N$. Specifically, any such $M$ would be bounded by $M  2^{k+1}$. Because the $k$-th bit of $M$ must be 0, the largest possible value for such an $M$ would be less than $2^k$, which is less than or equal to $N$. This contradicts $M > N$.\nTherefore, the MSB of $M$ must be at an index $j > k$.\n\nTo find the smallest possible integer $M$ that satisfies this, we must choose the smallest possible index for its MSB. The smallest integer index greater than $k$ is $k+1$. The smallest possible integer $M$ with an MSB at position $k+1$ is $M = 2^{k+1}$. This candidate for $M$ has only one bit set: the bit at position $k+1$.\n\nLet's verify if $M = 2^{k+1}$ satisfies both conditions:\n1.  **$M > N$**: By the definition of $k$ as the MSB index of $N$, we have $2^k \\le N  2^{k+1}$. Our candidate is $M = 2^{k+1}$, so the condition $M > N$ is satisfied.\n2.  **$N \\ \\ \\ M = 0$**: The candidate $M = 2^{k+1}$ has only the $(k+1)$-th bit set. By definition of $k$, the $(k+1)$-th bit of $N$ is 0. Therefore, the bitwise AND of $N$ and $M$ will be zero at all bit positions, satisfying the condition.\n\nSince any valid solution must have an MSB at an index of at least $k+1$ (and thus be at least $2^{k+1}$), our candidate $M = 2^{k+1}$ is indeed the smallest possible integer satisfying the conditions.\n\nThe final step is to calculate this value for $N = 987654321$.\nFirst, we find $k = \\lfloor \\log_2 N \\rfloor$. We can do this by finding the powers of 2 that bound $N$:\n$2^{29} = 536,870,912$\n$2^{30} = 1,073,741,824$\nSince $2^{29}  987654321  2^{30}$, the MSB of $N$ is at index $k=29$.\n\nThe smallest integer $M$ is therefore $2^{k+1} = 2^{29+1} = 2^{30}$.\n$$ M = 2^{30} = 1073741824 $$", "answer": "$$\\boxed{1073741824}$$", "id": "3217636"}, {"introduction": "Our final practice presents a significant generalization of the first, elevating a clever trick into a robust, general-purpose algorithm. Here, you will design a method to find a unique element in a more complex scenario by combining bit-by-bit analysis with modular arithmetic. This advanced exercise showcases how fundamental bitwise concepts can be scaled to solve sophisticated counting problems with remarkable efficiency. [@problem_id:3217582]", "problem": "You are asked to design and implement an algorithm grounded in bitwise operations to recover a single integer that has a different multiplicity than all others in a multiset. Let there be an integer array containing signed $64$-bit integers where every distinct integer appears exactly $k$ times, except one integer that appears exactly $p$ times, with $1 \\le p  k$. The goal is to compute this unique integer in time linear in the number of elements and constant auxiliary space with respect to the input size, based on first principles of binary representation and modular arithmetic, without relying on hashing or sorting. All integers in the input are guaranteed to fit within the signed $64$-bit range, that is, within $\\left[-2^{63},2^{63}-1\\right]$.\n\nFundamental base to use:\n- The binary representation of integers and bitwise operations, including bitwise AND, bitwise OR, and bit shifts, on fixed-width words of $64$ bits, with signed values encoded using two’s complement.\n- Modular arithmetic over a modulus $k$, in particular the distributivity of modular reduction across sums.\n- The semantics of bits in two’s complement, including the Most Significant Bit (MSB) at position $63$ indicating sign, and the Least Significant Bit (LSB) at position $0$.\n\nYour program must compute the unique integer for each of the following test cases, each specified as a triple $\\left(\\text{array},k,p\\right)$:\n- Test case $1$: $\\left(\\left[2,2,2,7,-1,-1,-1,42,42,42\\right],3,1\\right)$\n- Test case $2$: $\\left(\\left[13,13,0,0,0,0,0,-4,-4,-4,-4,-4,22,22,22,22,22\\right],5,2\\right)$\n- Test case $3$: $\\left(\\left[0,0,0,5,5,5,5,-7,-7,-7,-7\\right],4,3\\right)$\n- Test case $4$: $\\left(\\left[-15,-15,-15,-15,-15,-15,1,1,1,1,1,1,1,3,3,3,3,3,3,3\\right],7,6\\right)$\n- Test case $5$: $\\left(\\left[-8,-8,17,17,1152921504606847099\\right],2,1\\right)$ where $1152921504606847099=2^{60}+123$.\n- Test case $6$: $\\left(\\left[-4611686018427387897,-4611686018427387897,9,9,9,0,0,0\\right],3,2\\right)$ where $-4611686018427387897=-2^{62}+7$.\n\nYour algorithm must not assume any property beyond the stated multiplicities and the fixed-word two’s complement model, and it must reconstruct the answer by reasoning on the bit-level structure and modular properties. The final output for the entire test suite must be an integer list corresponding to the unique number for each test case, produced on a single line, as a comma-separated list enclosed in square brackets. For example, the output format must be $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\ldots\\right]$. No physical units, angles, or percentages appear in this problem; all outputs are plain integers.", "solution": "The problem statement is rigorously validated and found to be self-contained, scientifically grounded, well-posed, and objective. It is a formal problem in algorithm design based on fundamental principles of computer science and mathematics.\n\nThe core principle for solving this problem is to reconstruct the unique integer bit by bit. This can be achieved by analyzing the sum of bits at each position across all numbers in the array, using the properties of modular arithmetic. The integers are signed $64$-bit values, which means we must consider a bit width of $W=64$. The problem's constraints on time ($O(N)$, where $N$ is the number of elements) and space ($O(1)$) preclude sorting or using an auxiliary data structure like a hash map.\n\nLet the input array be denoted by $A$. The array contains a multiset of integers where every distinct number appears $k$ times, except for a single unique integer, let's call it $x$, which appears $p$ times, with $1 \\le p  k$. Let the set of other distinct integers be $\\{y_1, y_2, \\ldots, y_m\\}$.\n\nConsider a single bit position $j$, where $j$ ranges from $0$ (the Least Significant Bit, LSB) to $63$ (the Most Significant Bit, MSB). Let $b_j(n) \\in \\{0, 1\\}$ be the value of the $j$-th bit of an integer $n$. The algorithm's foundation is to compute the sum of the $j$-th bits for all numbers in the array $A$. Let this sum be $S_j$:\n$$ S_j = \\sum_{n \\in A} b_j(n) $$\nThis sum can be partitioned based on the multiplicities of the numbers. The unique number $x$ contributes $p \\cdot b_j(x)$ to this sum, and each of the other numbers $y_i$ contributes $k \\cdot b_j(y_i)$. Thus, the total sum can be expressed as:\n$$ S_j = p \\cdot b_j(x) + \\sum_{i=1}^{m} k \\cdot b_j(y_i) = p \\cdot b_j(x) + k \\sum_{i=1}^{m} b_j(y_i) $$\nThe second term, $k \\sum_{i=1}^{m} b_j(y_i)$, is by definition an integer multiple of $k$. Let $N_j = \\sum_{i=1}^{m} b_j(y_i)$, which is simply the count of \"non-unique\" numbers that have the $j$-th bit set. The equation becomes:\n$$ S_j = p \\cdot b_j(x) + k \\cdot N_j $$\nNow, we apply modular arithmetic with modulus $k$. Taking the equation modulo $k$:\n$$ S_j \\pmod k = (p \\cdot b_j(x) + k \\cdot N_j) \\pmod k $$\nUsing the property of modular addition, $(a+b) \\pmod k = ((a \\pmod k) + (b \\pmod k)) \\pmod k$:\n$$ S_j \\pmod k = (p \\cdot b_j(x) \\pmod k + k \\cdot N_j \\pmod k) \\pmod k $$\nSince $k \\cdot N_j \\pmod k = 0$, the equation simplifies to:\n$$ S_j \\pmod k = (p \\cdot b_j(x)) \\pmod k $$\nWe must determine the value of $b_j(x)$, which can only be $0$ or $1$.\nCase 1: The $j$-th bit of the unique number $x$ is $0$, i.e., $b_j(x) = 0$.\nIn this case, the equation becomes $S_j \\pmod k = (p \\cdot 0) \\pmod k = 0$.\nCase 2: The $j$-th bit of the unique number $x$ is $1$, i.e., $b_j(x) = 1$.\nIn this case, the equation becomes $S_j \\pmod k = (p \\cdot 1) \\pmod k = p \\pmod k$.\nGiven the problem constraint $1 \\le p  k$, we know that $p$ is not a multiple of $k$, and specifically $p \\pmod k = p$. Therefore, if $b_j(x)=1$, then $S_j \\pmod k = p$, which is non-zero.\n\nCombining these two cases gives a clear decision rule:\n- If $S_j \\pmod k = 0$, then $b_j(x)$ must be $0$.\n- If $S_j \\pmod k \\neq 0$, then $b_j(x)$ must be $1$.\n\nThis logic allows us to determine each bit of the unique number $x$ independently. The algorithm proceeds as follows:\n1. Initialize a $64$-bit result integer, `result`, to $0$.\n2. Iterate for each bit position $j$ from $0$ to $63$.\n3. For each $j$, compute the sum of the $j$-th bits of all numbers in the input array, $S_j$.\n4. Evaluate $S_j \\pmod k$.\n5. If the result is non-zero, it signifies that the $j$-th bit of the unique number $x$ is $1$. In this case, set the $j$-th bit of `result` using a bitwise OR operation with a mask: `result |= (1  j)`.\n\nThis procedure holds for signed integers in two's complement representation. The bitwise logic operates on the binary representation of the numbers, and the counting property is independent of whether a bit is part of a positive or negative number's representation. When a number is negative, its two's complement representation is used. Summing the bits at each position correctly accounts for the contribution from all numbers, positive or negative. After iterating through all $64$ bits, the `result` variable will hold the complete $64$-bit two's complement representation of the unique number $x$.\n\nThe implementation must carefully handle $64$-bit signed integers. Since standard Python integers have arbitrary precision, we will use `numpy.int64` and `numpy.uint64` to enforce the fixed-width semantics specified in the problem, particularly for bitwise operations like shifting and masking, ensuring that sign extension and bit patterns are handled correctly.\nFor each number `num` from the input and for each bit position `j`, we extract its $j$-th bit. This is reliably done by casting `num` to an unsigned $64$-bit integer, `numpy.uint64(num)`, and then using bitwise operations. This prevents sign extension issues with right shifts on negative numbers. The final accumulated bit pattern, stored in a `numpy.uint64` variable, is cast back to `numpy.int64` to yield the final signed integer result.\n\nThe time complexity is determined by two nested loops. The outer loop runs a constant $64$ times. The inner loop iterates over the $N$ elements of the input array. This gives a total time complexity of $O(64 \\cdot N)$, which is $O(N)$. The space complexity is $O(1)$ as we only use a few variables of fixed size (e.g., for the bit sum and the result) regardless of the input size $N$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_unique_integer(arr, k, p):\n    \"\"\"\n    Finds the integer that appears p times in an array where all other\n    distinct integers appear k times.\n\n    The algorithm reconstructs the unique integer bit by bit. For each bit\n    position j from 0 to 63, it sums the j-th bits of all numbers in the\n    array. Let this sum be S_j. The sum of bits from numbers that appear k\n    times will be a multiple of k. Thus, S_j mod k will reveal the j-th\n    bit of the unique number.\n\n    Specifically, S_j = (p * b_j(x)) + (k * M), where b_j(x) is the j-th\n    bit of the unique number x, and M is an integer.\n    So, S_j mod k = (p * b_j(x)) mod k.\n    Since 1 = p  k, p is not a multiple of k.\n    - If b_j(x) = 0, then S_j mod k = 0.\n    - If b_j(x) = 1, then S_j mod k = p != 0.\n    Thus, a non-zero remainder implies the j-th bit of x is 1.\n\n    Args:\n        arr (list): A list of integers.\n        k (int): The multiplicity of the non-unique numbers.\n        p (int): The multiplicity of the unique number.\n\n    Returns:\n        numpy.int64: The integer with unique multiplicity.\n    \"\"\"\n    \n    # The result is built up as an unsigned 64-bit integer to correctly handle\n    # bitwise operations on all 64 bits, including the sign bit.\n    result_unsigned = np.uint64(0)\n    \n    # Iterate over each of the 64 bit positions\n    for j in range(64):\n        bit_sum = 0\n        \n        # Create a mask to isolate the j-th bit. Must be uint64 to avoid overflow warnings\n        # for j=63, as 1  63 would be negative in signed int64.\n        bit_mask = np.uint64(1)  np.uint64(j)\n        \n        for num_py in arr:\n            # Cast the Python int to a numpy 64-bit signed integer to work with\n            # a fixed-width two's complement representation.\n            num_np = np.int64(num_py)\n            \n            # To check the j-th bit correctly for both positive and negative numbers,\n            # we cast the number's bit pattern to its unsigned equivalent.\n            # This ensures that bitwise operations (like ) treat all bits,\n            # including the MSB (sign bit), uniformly as data.\n            if (np.uint64(num_np)  bit_mask):\n                bit_sum += 1\n        \n        # If the sum of bits at this position is not a multiple of k,\n        # it means the unique number has a '1' at this bit position.\n        if bit_sum % k != 0:\n            # Set the corresponding bit in our result.\n            result_unsigned |= bit_mask\n            \n    # Cast the final unsigned bit pattern back to a signed 64-bit integer.\n    # This correctly reinterprets the two's complement representation.\n    return np.int64(result_unsigned)\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the solver for each, printing the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([2,2,2,7,-1,-1,-1,42,42,42], 3, 1),\n        ([13,13,0,0,0,0,0,-4,-4,-4,-4,-4,22,22,22,22,22], 5, 2),\n        ([0,0,0,5,5,5,5,-7,-7,-7,-7], 4, 3),\n        ([-15,-15,-15,-15,-15,-15,1,1,1,1,1,1,1,3,3,3,3,3,3,3], 7, 6),\n        ([-8,-8,17,17,1152921504606847099], 2, 1),\n        ([-4611686018427387897,-4611686018427387897,9,9,9,0,0,0], 3, 2),\n    ]\n\n    results = []\n    for arr, k, p in test_cases:\n        # The parameter 'p' is not strictly necessary for this implementation\n        # but is passed for completeness according to the problem statement.\n        result = find_unique_integer(arr, k, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3217582"}]}