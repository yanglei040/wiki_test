{"hands_on_practices": [{"introduction": "This first practice builds your intuition by focusing on the fundamental \"per-bit\" nature of mask operations. You will explore a combinatorial problem that requires partitioning the set bits of a given mask $M$ into two disjoint submasks, $A$ and $B$. By determining the number of ways to perform this partition ([@problem_id:3217117]), you will strengthen your understanding of how bitwise logic directly maps to set operations, a cornerstone of effective bitmasking.", "problem": "You are given a nonnegative integer mask $M$. Interpret a mask as the set of positions of its $1$-bits in the standard binary representation, so that a submask of $M$ is any nonnegative integer whose $1$-bits form a subset of those of $M$. Two masks $A$ and $B$ are considered as an ordered pair $(A,B)$. Using only fundamental definitions of set operations and bitwise masking, determine the exact number of ordered pairs $(A,B)$ of submasks of $M$ such that the set of $1$-bit positions of $A$ and $B$ satisfy $A \\cap B = \\emptyset$ and $A \\cup B = M$. For concreteness, let $M$ be the integer whose base-$16$ (hexadecimal) numeral is $\\mathrm{1F3A7C}$. Give your final answer as an exact integer with no rounding.", "solution": "The problem asks for the number of ordered pairs of nonnegative integers $(A,B)$ that are submasks of a given mask $M$, and satisfy the conditions $A \\cap B = \\emptyset$ and $A \\cup B = M$. The problem states that these masks should be interpreted as the sets of positions of their $1$-bits.\n\nLet $S_M$ be the set of bit positions where the binary representation of $M$ has a $1$. The condition that $A$ and $B$ are submasks of $M$ is equivalent to stating that their corresponding sets of $1$-bit positions, $S_A$ and $S_B$, are subsets of $S_M$. That is, $S_A \\subseteq S_M$ and $S_B \\subseteq S_M$.\n\nThe conditions given in the problem are:\n$1$. $A \\cap B = \\emptyset$: This means the set of $1$-bit positions of $A$ and the set of $1$-bit positions of $B$ are disjoint. In set notation, this is $S_A \\cap S_B = \\emptyset$. In terms of bitwise operations on the integers themselves, this is equivalent to $(A \\text{ AND } B) = 0$.\n$2$. $A \\cup B = M$: This means the union of the sets of $1$-bit positions of $A$ and $B$ is equal to the set of $1$-bit positions of $M$. In set notation, this is $S_A \\cup S_B = S_M$. In terms of bitwise operations, this is equivalent to $(A \\text{ OR } B) = M$.\n\nThe two set-theoretic conditions, $S_A \\cup S_B = S_M$ and $S_A \\cap S_B = \\emptyset$, together imply that the sets $S_A$ and $S_B$ form a partition of the set $S_M$. Our task is to count the number of such ordered pairs of sets $(S_A, S_B)$.\n\nLet us analyze the constraints on a per-bit basis. Consider the $i$-th bit position for an arbitrary integer $i \\ge 0$.\n\nCase 1: The $i$-th bit of $M$ is $0$.\nSince $A$ and $B$ must be submasks of $M$, their $i$-th bits must also be $0$. This is because $S_A \\subseteq S_M$ and $S_B \\subseteq S_M$, so if $i \\notin S_M$, it follows that $i \\notin S_A$ and $i \\notin S_B$. The conditions are satisfied for this bit position: the $i$-th bit of $(A \\text{ OR } B)$ is $0 \\text{ OR } 0 = 0$, matching $M$, and the $i$-th bit of $(A \\text{ AND } B)$ is $0 \\text{ AND } 0 = 0$, consistent with the empty intersection. For any such bit position, there is only one possible choice for the corresponding bits in $A$ and $B$ (they must both be $0$).\n\nCase 2: The $i$-th bit of $M$ is $1$.\nThis means $i \\in S_M$.\nThe condition $S_A \\cup S_B = S_M$ implies that for this position $i$, we must have $i \\in S_A$ or $i \\in S_B$.\nThe condition $S_A \\cap S_B = \\emptyset$ implies that $i$ cannot be in both $S_A$ and $S_B$.\nCombining these two requirements, for each bit position $i$ where $M$ has a $1$, exactly one of $A$ or $B$ must have a $1$ at that position. This gives two possibilities for each such bit:\na) The $i$-th bit of $A$ is $1$ and the $i$-th bit of $B$ is $0$.\nb) The $i$-th bit of $A$ is $0$ and the $i$-th bit of $B$ is $1$.\n\nSince the choice for each bit position is independent of the choices for all other bit positions, the total number of ordered pairs $(A,B)$ can be found by multiplying the number of choices for each bit.\nLet $N$ be the number of $1$-bits in the binary representation of $M$. This is also known as the population count or Hamming weight of $M$. For each of the $N$ bit positions where $M$ has a $1$, there are $2$ possible ways to assign that bit to either $A$ or $B$. For all other bit positions, where $M$ has a $0$, there is only $1$ choice (both $A$ and $B$ must have a $0$).\n\nTherefore, the total number of ordered pairs $(A,B)$ is $2^N$.\n\nThe problem provides a specific value for $M$ in hexadecimal: $M = \\mathrm{1F3A7C}_{16}$. We must find the number of $1$-bits, $N$, in its binary representation. We convert each hexadecimal digit to its $4$-bit binary equivalent:\n- $1_{16} = 0001_2$ (contains $1$ one)\n- $F_{16} = 1111_2$ (contains $4$ ones)\n- $3_{16} = 0011_2$ (contains $2$ ones)\n- $A_{16} = 1010_2$ (contains $2$ ones)\n- $7_{16} = 0111_2$ (contains $3$ ones)\n- $C_{16} = 1100_2$ (contains $2$ ones)\n\nThe binary representation of $M$ is $0001\\ 1111\\ 0011\\ 1010\\ 0111\\ 1100_2$.\nThe total number of $1$-bits, $N$, is the sum of the $1$-bits from each hexadecimal digit:\n$N = 1 + 4 + 2 + 2 + 3 + 2 = 14$.\n\nThe total number of ordered pairs $(A,B)$ is $2^N = 2^{14}$.\nWe calculate this value:\n$2^{10} = 1024$\n$2^{14} = 2^4 \\times 2^{10} = 16 \\times 1024$\n$16 \\times 1024 = 16 \\times (1000 + 24) = 16000 + 16 \\times 24 = 16000 + 384 = 16384$.\n\nThus, there are exactly $16384$ such ordered pairs $(A,B)$.", "answer": "$$\\boxed{16384}$$", "id": "3217117"}, {"introduction": "Building on the concept of masks as sets, this exercise introduces relationships between masks within a collection. You are asked to identify \"un-dominated\" masks, which translates to finding the maximal elements within a set under the submask partial order ([@problem_id:3217113]). This practice moves from pure counting to algorithmic thinking, challenging you to implement efficient checks for superset relationships using bitwise OR operations.", "problem": "Consider finite sets of non-negative integers interpreted as bit masks. For a non-negative integer mask $M$, define the associated bit-set as $S(M) = \\{ i \\in \\mathbb{Z}_{\\ge 0} \\mid \\text{the bit at position } i \\text{ in } M \\text{ is } 1 \\}$. Under this representation, the bitwise logical disjunction (bitwise OR) $A \\, | \\, B$ corresponds to the set-theoretic union $S(A) \\cup S(B)$. A mask $A$ is said to dominate a mask $B$ if and only if $(A \\, | \\, B) = A$ and $A \\ne B$. A mask is called un-dominated if no other distinct mask in the same set dominates it. You are to count the number of un-dominated masks in each provided set.\n\nFundamental base: use the standard properties of bitwise operations on non-negative integers, specifically that the bitwise logical disjunction $|$ on integers corresponds to the union of their bit positions and that equality of integers corresponds to equality of their bit sets. No additional assumptions beyond these are required.\n\nTask: For each test set, determine the count of masks that are un-dominated according to the definition above. The answer for each test case is an integer.\n\nTest suite:\n- Test case $1$: $S_1 = \\{0, 1, 2, 3\\}$.\n- Test case $2$: $S_2 = \\{1, 2, 4, 8\\}$.\n- Test case $3$: $S_3 = \\{6, 5, 3, 4, 2, 1\\}$.\n- Test case $4$: $S_4 = \\{0\\}$.\n- Test case $5$: $S_5 = \\{2^{30}, 2^{30} + 2^{5}, 2^{29}, 0\\}$.\n\nOutput specification: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $1$ through $5$ (e.g., $[r_1,r_2,r_3,r_4,r_5]$). Each $r_i$ is the count of un-dominated masks for $S_i$.\n\nNo physical units or angle units are involved. Express all numerical answers as integers.", "solution": "We begin from the fundamental properties of bitwise operations on non-negative integers. For any non-negative integer masks $A$ and $B$, consider their bit-set representations $S(A)$ and $S(B)$ where $S(M)$ lists the indices of bits that are $1$ in $M$. The bitwise logical disjunction $A \\, | \\, B$ has the property that its bit-set is precisely $S(A) \\cup S(B)$. Therefore, the equation $(A \\, | \\, B) = A$ holds if and only if $S(B) \\subseteq S(A)$, because the union of $S(B)$ with $S(A)$ does not add any new bit positions beyond those already present in $S(A)$. The additional condition $A \\ne B$ ensures that $S(B) \\subset S(A)$ is strict.\n\nFrom this, domination can be restated purely as a property of set inclusion: a mask $A$ dominates a mask $B$ if and only if $S(B) \\subset S(A)$. A mask is un-dominated if and only if there is no other distinct mask with a strictly larger bit-set containing its bit-set. Thus, the un-dominated masks are exactly the maximal elements with respect to the partial order defined by set inclusion on bit positions.\n\nAlgorithmic design:\n- Given a finite set of masks $\\{m_1, m_2, \\dots, m_n\\}$, we can determine whether a mask $m_i$ is dominated by checking the existence of any other mask $m_j$ such that $m_j \\ne m_i$ and $(m_j \\, | \\, m_i) = m_j$. If such a mask exists, then $m_i$ is dominated; otherwise, it is un-dominated.\n- A direct algorithm evaluates, for each $m_i$, all other $m_j$ and tests the condition $(m_j \\, | \\, m_i) = m_j$ with $m_j \\ne m_i$. This requires $O(n^2)$ bitwise operations in the worst case, which is acceptable for modest $n$ and is sufficient for the provided test suite.\n- One can further reason that sorting by the number of set bits (sometimes referred to as the population count) in descending order allows early elimination of potential dominators, because only masks with at least as many set bits as $m_i$ can dominate $m_i$. However, for clarity and determinism, we use the straightforward quadratic approach.\n\nCorrectness derived from the base:\n- If $(m_j \\, | \\, m_i) = m_j$ and $m_j \\ne m_i$, then $S(m_i) \\subset S(m_j)$, so $m_j$ dominates $m_i$ by the definition.\n- If there is no such $m_j$ for a mask $m_i$, then $S(m_i)$ is maximal under inclusion, hence $m_i$ is un-dominated.\n- Counting all masks $m_i$ without a dominator yields the number of un-dominated masks.\n\nCompute the answers for the test suite:\n\n- For $S_1 = \\{0, 1, 2, 3\\}$: The mask $3$ has bit-set $S(3) = \\{0,1\\}$ and strictly contains $S(1) = \\{0\\}$, $S(2) = \\{1\\}$, and $S(0) = \\varnothing$. Therefore, $3$ dominates $1$, $2$, and $0$. No mask dominates $3$. The count of un-dominated masks is $1$.\n\n- For $S_2 = \\{1, 2, 4, 8\\}$: The sets are $S(1) = \\{0\\}$, $S(2) = \\{1\\}$, $S(4) = \\{2\\}$, $S(8) = \\{3\\}$. None of these sets is a strict subset of another, so no mask dominates any other. The count is $4$.\n\n- For $S_3 = \\{6, 5, 3, 4, 2, 1\\}$: The sets are $S(6) = \\{1,2\\}$, $S(5) = \\{0,2\\}$, $S(3) = \\{0,1\\}$, $S(4) = \\{2\\}$, $S(2) = \\{1\\}$, $S(1) = \\{0\\}$. Masks $4$, $2$, and $1$ are strictly contained in $S(6)$, $S(5)$, or $S(3)$ (for example, $(6 \\, | \\, 4) = 6$, $(6 \\, | \\, 2) = 6$, $(5 \\, | \\, 1) = 5$), so they are dominated. None of $6$, $5$, or $3$ strictly contains another among these three; therefore they are all un-dominated. The count is $3$.\n\n- For $S_4 = \\{0\\}$: There is only one mask, so there is no distinct mask to dominate it. The count is $1$.\n\n- For $S_5 = \\{2^{30}, 2^{30} + 2^{5}, 2^{29}, 0\\}$: The sets are $S(2^{30}) = \\{30\\}$, $S(2^{30} + 2^{5}) = \\{5,30\\}$, $S(2^{29}) = \\{29\\}$, $S(0) = \\varnothing$. The mask $2^{30} + 2^{5}$ strictly contains $S(2^{30})$, so it dominates $2^{30}$. Any non-zero mask dominates $0$. The mask $2^{29}$ is not strictly contained in any other mask here. Therefore, the un-dominated masks are $2^{30} + 2^{5}$ and $2^{29}$, yielding a count of $2$.\n\nThus, the program should output the single line $[1,4,3,1,2]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count_undominated(masks):\n    \"\"\"\n    Count masks that are not dominated by any other distinct mask in the list.\n    A dominates B if (A | B) == A and A != B.\n    \"\"\"\n    n = len(masks)\n    undominated_count = 0\n    for i in range(n):\n        m = masks[i]\n        dominated = False\n        for j in range(n):\n            if i == j:\n                continue\n            a = masks[j]\n            # Check domination: a != m and (a | m) == a\n            if a != m and (a | m) == a:\n                dominated = True\n                break\n        if not dominated:\n            undominated_count += 1\n    return undominated_count\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [0, 1, 2, 3],                                  # S1\n        [1, 2, 4, 8],                                  # S2\n        [6, 5, 3, 4, 2, 1],                            # S3\n        [0],                                           # S4\n        [2**30, 2**30 + 2**5, 2**29, 0],               # S5\n    ]\n\n    results = []\n    for masks in test_cases:\n        result = count_undominated(masks)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3217113"}, {"introduction": "This final practice demonstrates a powerful application of bitmasking in solving dynamic problems. Here, masks represent states in a puzzle, and bitwise XOR operations define the transitions between them, effectively creating a state-space graph ([@problem_id:3217223]). By finding the shortest sequence of operations, you will apply your knowledge of bitwise logic in tandem with a fundamental graph traversal algorithm, showcasing how bitmasks provide a compact and efficient way to navigate and solve complex state-based challenges.", "problem": "You are given an initial bit mask $m$, a target bit mask $g$, and a finite list of toggle masks $t_i$ for $i \\in \\{1,2,\\dots,k\\}$. A toggle operation applies the bitwise exclusive OR (XOR) to the current mask: if the current mask is $x$, applying toggle $t_i$ transforms it to $x \\oplus t_i$. All masks are constrained to a fixed bit-width $B$, meaning only the lowest $B$ bits are considered and all operations are within the set $\\{0,1,\\dots,2^B-1\\}$.\n\nConstruct a program that determines the minimum number of toggle operations needed to transform $m$ into $g$, or returns $-1$ if $g$ is not reachable from $m$ under any sequence of toggles. Your program must produce a single line of output as a comma-separated list enclosed in square brackets, aggregating the results for the given test suite.\n\nThe reasoning must start from fundamental definitions and facts:\n- The bitwise exclusive OR (XOR), written as $\\oplus$, is defined bitwise using addition modulo $2$ without carry. For any bit masks $a$ and $b$ of width $B$, $a \\oplus b$ is the mask whose bits are $(a_j + b_j) \\bmod 2$ for bit positions $j \\in \\{0,1,\\dots,B-1\\}$.\n- XOR obeys the algebraic properties: $a \\oplus a = 0$, $a \\oplus 0 = a$, commutativity $a \\oplus b = b \\oplus a$, and associativity $(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$. Every element is its own inverse under $\\oplus$.\n- Breadth-First Search (BFS) on an unweighted graph explores vertices in nondecreasing order of path length and therefore finds a shortest path from a source to any reachable vertex.\n\nModel the reachable masks as vertices of an unweighted directed graph with vertex set $V = \\{0,1,\\dots,2^B-1\\}$. There is an edge from $x$ to $y$ if and only if there exists some toggle $t_i$ such that $y = x \\oplus t_i$. Starting at vertex $m$, the problem asks for the shortest path length to vertex $g$ in this graph. If $g$ is not reachable from $m$, the answer is $-1$.\n\nInput protocol is fixed by the test suite below; your program must not read any external input. The final output format must be a single line containing a list of integers representing the minimum number of toggles for each test case, written exactly as $[r_1,r_2,\\dots,r_n]$ with no spaces.\n\nTest suite (each case is a quadruple $(B,m,g,\\{t_i\\})$):\n- Case $1$: $B = 8$, $m = 26$, $g = 229$, $\\{t_i\\} = [160,39,255,91]$.\n- Case $2$: $B = 8$, $m = 123$, $g = 123$, $\\{t_i\\} = [5,7,200]$.\n- Case $3$: $B = 8$, $m = 0$, $g = 4$, $\\{t_i\\} = [1,2]$.\n- Case $4$: $B = 8$, $m = 42$, $g = 40$, $\\{t_i\\} = [0,5,5,7]$.\n- Case $5$: $B = 4$, $m = 0$, $g = 11$, $\\{t_i\\} = [1,2,4,8]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3,r_4,r_5]$. The expected outputs are integers; for unreachable targets, output $-1$.", "solution": "The problem as stated is valid. It is scientifically grounded in the mathematics of finite fields and graph theory, well-posed with a clear objective, and free from ambiguity or contradiction. All necessary information is provided in the test suite. We may therefore proceed with a solution.\n\nThe problem asks for the minimum number of toggle operations to transform an initial bit mask $m$ into a target bit mask $g$. This is a classic shortest path problem on an unweighted graph. The solution can be systematically derived by first formalizing the problem in terms of a graph-theoretic model and then applying a suitable search algorithm.\n\nFirst, let us define the structure of the state space. The set of all possible bit masks of a fixed width $B$ constitutes the vertex set $V$ of a graph, where $V = \\{0, 1, \\dots, 2^B - 1\\}$. An operation consists of applying a toggle mask $t_i$ from a given list $\\{t_1, t_2, \\dots, t_k\\}$. The effect of a toggle is defined by the bitwise exclusive OR (XOR) operation, denoted by $\\oplus$. If the current mask is $x$, applying the toggle $t_i$ results in a new mask $x' = x \\oplus t_i$.\n\nThis transformation defines the edges of our graph. An edge exists between two vertices (masks) $u$ and $v$ if there is a toggle $t_i$ such that $v = u \\oplus t_i$. The XOR operation is its own inverse, meaning $(u \\oplus t_i) \\oplus t_i = u \\oplus (t_i \\oplus t_i) = u \\oplus 0 = u$. This implies that if there is an edge from $u$ to $v$, there is also an edge from $v$ to $u$. Therefore, the graph is undirected. Each edge represents a single toggle operation, so the graph is unweighted. The problem is thus equivalent to finding the length of the shortest path from the starting vertex $m$ to the target vertex $g$.\n\nThe most appropriate algorithm for finding the shortest path in an unweighted graph is the Breadth-First Search (BFS). BFS systematically explores the graph layer by layer, guaranteeing that it discovers a path to any reachable vertex with the minimum number of edges.\n\nAn alternative perspective illuminates the underlying algebraic structure. A sequence of $L$ toggle operations $t_{i_1}, t_{i_2}, \\dots, t_{i_L}$ transforms $m$ to $g$ as follows:\n$$ g = m \\oplus t_{i_1} \\oplus t_{i_2} \\oplus \\dots \\oplus t_{i_L} $$\nBy the associativity and commutativity of XOR, we can rearrange this expression. XORing both sides with $m$ yields:\n$$ m \\oplus g = (m \\oplus m) \\oplus (t_{i_1} \\oplus t_{i_2} \\oplus \\dots \\oplus t_{i_L}) $$\nLet $D = m \\oplus g$ be the \"difference mask\". The problem is equivalent to finding the smallest number of toggle masks from the set $\\{t_i\\}$ that XOR to $D$.\n$$ D = t_{i_1} \\oplus t_{i_2} \\oplus \\dots \\oplus t_{i_L} $$\nThis reframes the problem as finding the shortest path from the zero mask, $0$, to the mask $D$. This is a problem in a vector space over the field of two elements, $\\mathbb{F}_2$. While this view is conceptually elegant, the BFS algorithm remains the practical method for a solution, whether starting from $m$ to find $g$ or from $0$ to find $D$. We will adhere to the direct formulation of searching from $m$ to $g$.\n\nThe BFS algorithm proceeds as follows:\n$1.$ Initialize a queue for managing vertices to visit. The queue will store tuples of the form $(mask, distance)$. Add the starting state $(m, 0)$ to the queue.\n$2.$ Initialize a set or boolean array, `visited`, to keep track of masks that have already been enqueued. This is crucial to prevent cycles and redundant computations. Add $m$ to the `visited` set.\n$3.$ If $m=g$, the distance is $0$. This trivial case is handled by the initial state.\n$4.$ Loop while the queue is not empty:\n    a. Dequeue the current state, `(current_mask, current_dist)`.\n    b. For each unique toggle mask $t_j$ in the provided list:\n        i. Compute the `next_mask` as `current_mask ^ t_j`.\n        ii. If `next_mask` is the target $g$, the shortest path has been found. Its length is `current_dist + 1`. The algorithm can terminate and return this value.\n        iii. If `next_mask` has not yet been visited, add it to the `visited` set and enqueue it with the new distance: `(next_mask, current_dist + 1)`.\n$5.$ If the queue becomes empty and the target $g$ has not been found, it means $g$ is not in the same connected component of the graph as $m$. Thus, $g$ is unreachable. In this case, the function should return $-1$.\n\nDuplicate toggles in the input list $\\{t_i\\}$ do not add new transitions and can be filtered into a unique set. A toggle of $0$ is also a valid operation, corresponding to a self-loop ($x \\oplus 0 = x$), which is correctly handled by the `visited` set.\n\nThis BFS-based approach provides a complete and correct algorithm for solving the stated problem for any given parameters $B$, $m$, $g$, and $\\{t_i\\}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef find_min_toggles(B, m, g, toggles):\n    \"\"\"\n    Determines the minimum number of toggle operations to transform mask m into g.\n\n    This function models the problem as a shortest path search on an unweighted graph\n    of possible bit masks. Vertices are the masks, and an edge exists between two masks\n    if one can be transformed into the other by a single toggle operation (XOR).\n    Breadth-First Search (BFS) is used to find the shortest path from m to g.\n\n    Args:\n        B (int): The bit-width of the masks. All masks are in the range [0, 2**B - 1].\n        m (int): The initial bit mask.\n        g (int): The target bit mask.\n        toggles (list[int]): A list of toggle masks.\n\n    Returns:\n        int: The minimum number of operations, or -1 if g is unreachable from m.\n    \"\"\"\n    # If the start and target masks are the same, 0 operations are needed.\n    if m == g:\n        return 0\n\n    # Use a set of unique toggles to avoid redundant computations.\n    # A toggle of 0 results in a self-loop (x -> x ^ 0 = x) and does not help\n    # reach new states, so it can be safely ignored.\n    unique_toggles = {t for t in toggles if t != 0}\n\n    # The queue for BFS stores tuples of (mask, distance_from_m).\n    # Initialize with the starting mask and a distance of 0.\n    queue = collections.deque([(m, 0)])\n\n    # A set to keep track of visited masks to avoid cycles and redundant exploration.\n    visited = {m}\n\n    # Perform the BFS.\n    while queue:\n        current_mask, dist = queue.popleft()\n\n        # Explore all possible next states from the current mask.\n        for t in unique_toggles:\n            next_mask = current_mask ^ t\n\n            # If the next mask is the target, we have found the shortest path.\n            if next_mask == g:\n                return dist + 1\n\n            # If the next mask has not been visited, add it to the queue and visited set.\n            if next_mask not in visited:\n                visited.add(next_mask)\n                queue.append((next_mask, dist + 1))\n\n    # If the queue is exhausted and the target was not found, it is unreachable.\n    return -1\n\ndef solve():\n    \"\"\"\n    Solves the problem for the suite of test cases provided in the prompt.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: B=8, m=26, g=229, {t_i}=[160,39,255,91]\n        (8, 26, 229, [160, 39, 255, 91]),\n        # Case 2: B=8, m=123, g=123, {t_i}=[5,7,200]\n        (8, 123, 123, [5, 7, 200]),\n        # Case 3: B=8, m=0, g=4, {t_i}=[1,2]\n        (8, 0, 4, [1, 2]),\n        # Case 4: B=8, m=42, g=40, {t_i}=[0,5,5,7]\n        (8, 42, 40, [0, 5, 5, 7]),\n        # Case 5: B=4, m=0, g=11, {t_i}=[1,2,4,8]\n        (4, 0, 11, [1, 2, 4, 8]),\n    ]\n\n    results = []\n    for B, m, g, toggles in test_cases:\n        result = find_min_toggles(B, m, g, toggles)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3217223"}]}