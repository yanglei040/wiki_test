{"hands_on_practices": [{"introduction": "A cornerstone of randomized quicksort's power is its robust performance regardless of the input's initial structure. Unlike deterministic variants that can suffer from worst-case behavior on sorted or nearly sorted data, the randomized approach guarantees excellent average-case efficiency. This practice challenges you to prove this fundamental property by analyzing an \"almost sorted\" array, demonstrating that the expected number of comparisons depends only on the array's size, not its initial permutation @problem_id:3263621.", "problem": "Consider an array of $n$ distinct keys drawn from a totally ordered set. Construct an \"almost sorted\" input as follows: begin with the keys in increasing order and then relocate exactly $k$ distinct keys to arbitrary positions, producing an array in which exactly $k$ keys are not in their final sorted ranks. Run the classic randomized quicksort that, at each recursive call on a subarray, selects the pivot uniformly at random from that subarray and partitions by comparing every other element in the subarray once against the pivot.\n\nLet $C_{n,k}$ denote the total number of key-to-key comparisons performed by this randomized quicksort on such an input. Take the expectation with respect to the algorithm’s internal randomness only; the particular locations of the $k$ misplaced elements are fixed but otherwise arbitrary. Derive, from first principles, a closed-form expression for $\\mathbb{E}[C_{n,k}]$ as a function of $n$ and $k$. Express your final answer in terms of the $n$th harmonic number $H_n$, where $H_n = \\sum_{i=1}^{n} \\frac{1}{i}$.\n\nYour answer must be a single analytic expression. Do not provide inequalities or asymptotic notation, and do not include any units. If simplification is performed, keep $H_n$ symbolic and exact.", "solution": "The user-provided problem has been validated and is deemed **valid**. It is a well-posed problem in the analysis of algorithms that tests a fundamental property of randomized quicksort. The introduction of the parameter $k$ for an \"almost sorted\" array serves to test the understanding that the expected number of comparisons in randomized quicksort is independent of the initial permutation of the input elements, as the expectation is taken over the algorithm's internal random choices.\n\nWe proceed to derive the expected number of comparisons, $\\mathbb{E}[C_{n,k}]$, from first principles.\n\nLet the set of $n$ distinct keys be denoted by their sorted order as $\\{z_1, z_2, \\dots, z_n\\}$, where $z_1  z_2  \\dots  z_n$. The total number of key-to-key comparisons, $C_{n,k}$, can be expressed as a sum of indicator random variables:\n$$C_{n,k} = \\sum_{1 \\le i  j \\le n} X_{ij}$$\nwhere $X_{ij}$ is an indicator random variable such that $X_{ij} = 1$ if key $z_i$ and key $z_j$ are compared at some point during the execution of the algorithm, and $X_{ij} = 0$ otherwise.\n\nBy the linearity of expectation, the expected total number of comparisons is the sum of the expected values of these indicator variables:\n$$\\mathbb{E}[C_{n,k}] = \\mathbb{E}\\left[\\sum_{1 \\le i  j \\le n} X_{ij}\\right] = \\sum_{1 \\le i  j \\le n} \\mathbb{E}[X_{ij}]$$\nThe expectation of an indicator random variable is the probability of the event it indicates. Therefore, $\\mathbb{E}[X_{ij}] = P(X_{ij} = 1)$, which is the probability that keys $z_i$ and $z_j$ are compared.\n\nTo determine this probability, we analyze the conditions under which a comparison between $z_i$ and $z_j$ occurs. Consider the set of keys $S_{ij} = \\{z_i, z_{i+1}, \\dots, z_j\\}$. The size of this set is $|S_{ij}| = j - i + 1$.\nTwo keys $z_i$ and $z_j$ are compared if and only if the very first pivot selected by the algorithm from the set $S_{ij}$ is either $z_i$ or $z_j$.\nTo see why, consider two cases for the first pivot $p$ selected from $S_{ij}$:\n1.  If the pivot $p$ is such that $z_i  p  z_j$, then $z_i$ will be placed in the \"less than $p$\" partition, and $z_j$ will be placed in the \"greater than $p$\" partition. They will reside in different subarrays for all subsequent recursive calls and will never be compared to each other.\n2.  If the pivot $p$ is $z_i$ or $z_j$, then $z_i$ and $z_j$ are compared during the partitioning step (as every other element in the subarray is compared to the pivot).\n\nThe randomized quicksort algorithm selects a pivot uniformly at random from the elements of the current subarray. At the moment the first pivot is chosen from the set $S_{ij}$, all elements of $S_{ij}$ are present in the same subarray. Therefore, any element in $S_{ij}$ has an equal probability of being the first pivot chosen from that set. This probability is $\\frac{1}{|S_{ij}|} = \\frac{1}{j-i+1}$.\n\nThis crucial observation is independent of the initial physical arrangement of the keys in the input array. The probability calculation depends only on the relative ranks of the keys. The specific permutation of the input, described by the parameter $k$, has no bearing on this probability. The \"averaging\" is done over the algorithm's random choices, not over a distribution of inputs.\n\nThe event \"$z_i$ and $z_j$ are compared\" corresponds to the first pivot from $S_{ij}$ being either $z_i$ or $z_j$. Since these are two distinct outcomes, each with probability $\\frac{1}{j-i+1}$, the total probability is:\n$$P(X_{ij} = 1) = \\frac{2}{j-i+1}$$\nSince this probability is independent of the input permutation, the expected number of comparisons $\\mathbb{E}[C_{n,k}]$ is independent of $k$. We can denote it as $\\mathbb{E}[C_n]$. We now compute the sum:\n$$\\mathbb{E}[C_n] = \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{2}{j-i+1}$$\nWe can re-index the summation. Let's fix $i$ and introduce a new index $d = j-i$. As $j$ ranges from $i+1$ to $n$, $d$ ranges from $1$ to $n-i$.\n$$\\mathbb{E}[C_n] = 2 \\sum_{i=1}^{n-1} \\sum_{d=1}^{n-i} \\frac{1}{d+1}$$\nNext, we swap the order of summation. The summation region is defined by $1 \\le i \\le n-1$ and $1 \\le d \\le n-i$. This is equivalent to $1 \\le d \\le n-1$ and $1 \\le i \\le n-d$.\n$$\\mathbb{E}[C_n] = 2 \\sum_{d=1}^{n-1} \\sum_{i=1}^{n-d} \\frac{1}{d+1}$$\nThe inner sum is over $i$, and the term $\\frac{1}{d+1}$ is constant with respect to $i$. The sum $\\sum_{i=1}^{n-d} 1$ evaluates to $n-d$.\n$$\\mathbb{E}[C_n] = 2 \\sum_{d=1}^{n-1} \\frac{n-d}{d+1}$$\nTo evaluate this sum, we perform an algebraic manipulation on the term inside:\n$$\\frac{n-d}{d+1} = \\frac{(n+1) - (d+1)}{d+1} = \\frac{n+1}{d+1} - 1$$\nSubstituting this back into the expression for the expectation:\n$$\\mathbb{E}[C_n] = 2 \\sum_{d=1}^{n-1} \\left(\\frac{n+1}{d+1} - 1\\right)$$\nUsing the linearity of summation:\n$$\\mathbb{E}[C_n] = 2 \\left( \\sum_{d=1}^{n-1} \\frac{n+1}{d+1} - \\sum_{d=1}^{n-1} 1 \\right) = 2 \\left( (n+1) \\sum_{d=1}^{n-1} \\frac{1}{d+1} - (n-1) \\right)$$\nThe first sum can be related to the harmonic numbers, $H_n = \\sum_{i=1}^{n} \\frac{1}{i}$. Let $m = d+1$. As $d$ goes from $1$ to $n-1$, $m$ goes from $2$ to $n$.\n$$\\sum_{d=1}^{n-1} \\frac{1}{d+1} = \\sum_{m=2}^{n} \\frac{1}{m} = \\left(\\sum_{m=1}^{n} \\frac{1}{m}\\right) - \\frac{1}{1} = H_n - 1$$\nSubstituting this result back into our expression for $\\mathbb{E}[C_n]$:\n$$\\mathbb{E}[C_n] = 2 \\left( (n+1)(H_n - 1) - (n-1) \\right)$$\nExpanding and simplifying the terms inside the parentheses:\n$$\\mathbb{E}[C_n] = 2 \\left( (n+1)H_n - (n+1) - (n-1) \\right)$$\n$$\\mathbb{E}[C_n] = 2 \\left( (n+1)H_n - n - 1 - n + 1 \\right)$$\n$$\\mathbb{E}[C_n] = 2 \\left( (n+1)H_n - 2n \\right)$$\nThis gives the final closed-form expression:\n$$\\mathbb{E}[C_{n,k}] = 2(n+1)H_n - 4n$$\nThis result is the well-known expected number of comparisons for randomized quicksort on any array of $n$ distinct elements, confirming that the structure of the initial permutation does not affect the outcome.", "answer": "$$\\boxed{2(n+1)H_n - 4n}$$", "id": "3263621"}, {"introduction": "While randomized quicksort is efficient in general, its performance can be further optimized for inputs containing many duplicate keys, a common scenario in real-world data. Standard two-way partitioning can be inefficient in this case, creating unbalanced subproblems. This exercise asks you to compare the standard approach with a three-way (or \"Dutch National Flag\") partitioning scheme, quantitatively analyzing how a refined partitioning strategy can significantly reduce the number of comparisons by handling duplicate elements more effectively @problem_id:3263576.", "problem": "You are given an array of $n$ Boolean keys containing exactly $k$ occurrences of the key value $1$ and $n-k$ occurrences of the key value $0$, where $1 \\le k \\le n-1$. The array is in an arbitrary order. Consider two variants of randomized quicksort applied to this array:\n\n- Variant A (standard $2$-way partitioning): Each recursive call chooses a pivot uniformly at random from the subarray, and partitions the subarray into the two groups “less than pivot” and “greater than or equal to pivot,” then recurses on both groups.\n- Variant B (Dutch National Flag style $3$-way partitioning): Each recursive call chooses a pivot uniformly at random from the subarray, and partitions the subarray into the three groups “less than pivot,” “equal to pivot,” and “greater than pivot,” then recurses only on the “less than” and “greater than” groups.\n\nIn both variants, measure cost as the total number of key comparisons against the pivot across the entire execution. Use a trichotomic comparator that, in a single comparison of an element with the pivot, determines whether it is less than, equal to, or greater than the pivot; thus, partitioning a subarray of size $m$ performs exactly $m-1$ key comparisons. The only source of randomness is the uniformly random choice of the pivot at each recursive call.\n\nDerive from first principles closed-form expressions, as functions of $n$ and $k$, for the expected total number of key comparisons performed by Variant A and by Variant B on this input model. Express your final answer as two explicit formulas in terms of $n$ and $k$. No rounding is required. Provide your two formulas in a single row vector in the order [Variant A, Variant B].", "solution": "The problem asks for the expected total number of key comparisons for two variants of randomized quicksort on an array of $n$ Boolean keys, consisting of $n-k$ zeros and $k$ ones, where $1 \\le k \\le n-1$. The cost of partitioning a subarray of size $m$ is given as $m-1$ comparisons.\n\nWe can solve this problem by using the method of indicator random variables. The total number of comparisons, $C$, is the sum of comparisons over all distinct pairs of elements in the array. Let $S$ be the set of $n$ keys. The total expected number of comparisons is given by:\n$$ E[C] = \\sum_{\\{u, v\\} \\subseteq S, u \\neq v} P(u \\text{ and } v \\text{ are compared}) $$\nBy linearity of expectation, we can calculate the expected number of comparisons by summing the probabilities that any two elements are compared. The array contains two distinct key values, $0$ and $1$. We can therefore classify the pairs of elements $\\{u, v\\}$ into three types:\n1.  Both keys are $0$. The number of such pairs is $\\binom{n-k}{2}$.\n2.  Both keys are $1$. The number of such pairs is $\\binom{k}{2}$.\n3.  One key is $0$ and the other is $1$. The number of such pairs is $(n-k)k$.\n\nWe will now analyze the probability of comparison for each pair type under each quicksort variant. A comparison between two elements $u$ and $v$ occurs if one of them is chosen as a pivot while the other is still in the same subarray. They are separated, and thus will never be compared, if a pivot $p$ is chosen that places them into different recursive subproblems.\n\n### Variant A: Standard 2-way Partitioning\n\nIn this variant, a subarray is partitioned into two groups: \"less than pivot\" ($p$) and \"greater than or equal to pivot\" ($\\ge p$). The pivot itself is removed, and recursion proceeds on both groups.\n\n1.  **Pair of two zeros $(\\{z_1, z_2\\})$**: Let the chosen pivot be $p$.\n    -   If $p=0$, both $z_1$ and $z_2$ are greater than or equal to the pivot, so they both go into the second partition. They are not separated.\n    -   If $p=1$, both $z_1$ and $z_2$ are less than the pivot, so they both go into the first partition. They are not separated.\n    Since no pivot value can separate two zeros, they will always remain in the same subproblem. Eventually, one of them must be chosen as a pivot while the other is in the same subarray, at which point they will be compared. Therefore, any two zeros are compared with probability $1$.\n    The expected number of comparisons for these pairs is $\\binom{n-k}{2} \\times 1 = \\frac{(n-k)(n-k-1)}{2}$.\n\n2.  **Pair of two ones $(\\{o_1, o_2\\})$**:\n    -   If $p=0$, both $o_1$ and $o_2$ are greater than or equal to the pivot. They are not separated.\n    -   If $p=1$, both $o_1$ and $o_2$ are greater than or equal to the pivot. They are not separated.\n    Similar to the case of two zeros, two ones are never separated. Thus, they are compared with probability $1$.\n    The expected number of comparisons for these pairs is $\\binom{k}{2} \\times 1 = \\frac{k(k-1)}{2}$.\n\n3.  **Pair of a zero and a one $(\\{z, o\\})$**:\n    -   If a pivot $p=0$ is chosen, both $z$ and $o$ are $\\ge p$. They remain in the same partition.\n    -   If a pivot $p=1$ is chosen, $z$ goes to the $p$ partition and $o$ goes to the $\\ge p$ partition. They are separated.\n    The pair $\\{z, o\\}$ is compared if and only if either $z$ or $o$ is chosen as pivot before any other element with value $1$ is chosen as pivot from a subproblem containing them. Let $S_1$ be the set of all $k$ ones. The set of \"relevant\" elements for the fate of the pair $\\{z, o\\}$ is the set $R = \\{z\\} \\cup S_1$, which has size $k+1$. Any pivot chosen from outside this set is a zero, which does not separate $z$ and $o$. The pair is compared if the first pivot chosen from the set $R$ is either $z$ or $o$. If any other element from $R$ (which must be a one, say $o'$) is chosen first, $z$ and $o$ are separated without being compared. Since the pivot is chosen uniformly at random, any element in $R$ is equally likely to be the first one chosen from $R$.\n    The probability of comparison is $P(z \\text{ or } o \\text{ is chosen first from } R) = \\frac{2}{|R|} = \\frac{2}{k+1}$.\n    The expected number of comparisons for these pairs is $(n-k)k \\times \\frac{2}{k+1}$.\n\nSumming the expected comparisons for all pair types, we get the total expected number of comparisons for Variant A:\n$$ E_A(n, k) = \\frac{(n-k)(n-k-1)}{2} + \\frac{k(k-1)}{2} + \\frac{2k(n-k)}{k+1} $$\n\n### Variant B: 3-way Partitioning (Dutch National Flag)\n\nIn this variant, a subarray is partitioned into three groups: \"less than pivot\" ($p$), \"equal to pivot\" ($=p$), and \"greater than pivot\" ($p$). Recursion proceeds only on the \"less than\" and \"greater than\" groups. Elements equal to the pivot are eliminated from further consideration.\n\n1.  **Pair of two zeros $(\\{z_1, z_2\\})$**:\n    -   If a pivot $p=1$ is chosen, both zeros go into the $p$ partition. They are not separated.\n    -   If a pivot $p=0$ is chosen, and this pivot is an element other than $z_1$ or $z_2$, then both $z_1$ and $z_2$ go into the $=p$ partition. They are eliminated and never compared.\n    -   If the pivot is $z_1$ or $z_2$, they are compared.\n    So, $z_1$ and $z_2$ are compared if and only if one of them is chosen as a pivot before any other zero is chosen as a pivot from a subproblem containing them. Let $S_0$ be the set of all $n-k$ zeros. The choice of a one as a pivot does not separate them. Thus, we only need to consider the first pivot chosen from the set $S_0$. The probability that this pivot is from the set $\\{z_1, z_2\\}$ is $\\frac{2}{|S_0|} = \\frac{2}{n-k}$ (for $n-k \\ge 2$).\n    The expected number of comparisons is $\\binom{n-k}{2} \\times \\frac{2}{n-k} = \\frac{(n-k)(n-k-1)}{2} \\times \\frac{2}{n-k} = n-k-1$. This holds for $n-k \\ge 2$. If $n-k2$, the number of pairs is $0$.\n\n2.  **Pair of two ones $(\\{o_1, o_2\\})$**: The logic is symmetric to the case of two zeros. They are compared if and only if one of them is chosen as pivot before any other one. The probability of comparison is $\\frac{2}{k}$ (for $k \\ge 2$).\n    The expected number of comparisons is $\\binom{k}{2} \\times \\frac{2}{k} = k-1$. This holds for $k \\ge 2$. If $k2$, the number of pairs is $0$.\n\n3.  **Pair of a zero and a one $(\\{z, o\\})$**:\n    -   If a pivot $p=z$ or $p=o$ is chosen, they are compared.\n    -   If any other pivot $p \\neq z, o$ is chosen, they are separated. If $p$ is a zero, $p=z'$, then $z$ goes to the $=p$ partition and $o$ goes to the $p$ partition. If $p$ is a one, $p=o'$, then $z$ goes to the $p$ partition and $o$ goes to the $=p$ partition. In either case, they are separated without comparison.\n    Therefore, $z$ and $o$ are compared if and only if either $z$ or $o$ is the first pivot chosen from the set of all $n$ elements.\n    The probability of this is $P(\\text{pivot is } z) + P(\\text{pivot is } o) = \\frac{1}{n} + \\frac{1}{n} = \\frac{2}{n}$.\n    The expected number of comparisons for these pairs is $(n-k)k \\times \\frac{2}{n}$.\n\nSumming the expected comparisons for Variant B ($1 \\le k \\le n-1$, which implies $n-k \\ge 1, k \\ge 1$):\n$$ E_B(n, k) = (n-k-1) + (k-1) + \\frac{2k(n-k)}{n} = n-2 + \\frac{2k(n-k)}{n} $$\n(Note that if $n-k=1$, $n-k-1=0$, and if $k=1$, $k-1=0$, which is consistent with there being no pairs.)\n\nThe final expressions for the expected number of comparisons are:\nFor Variant A:\n$$E_A(n, k) = \\frac{(n-k)(n-k-1)}{2} + \\frac{k(k-1)}{2} + \\frac{2k(n-k)}{k+1}$$\nFor Variant B:\n$$E_B(n, k) = n-2 + \\frac{2k(n-k)}{n}$$", "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{(n-k)(n-k-1)}{2} + \\frac{k(k-1)}{2} + \\frac{2k(n-k)}{k+1}  n-2 + \\frac{2k(n-k)}{n} \\end{pmatrix} } $$", "id": "3263576"}, {"introduction": "The theoretical elegance of quicksort depends entirely on a correctly implemented partition subroutine. A subtle bug in the partitioning logic can lead to disastrous consequences, affecting not only efficiency but correctness itself. This practical exercise puts you in the role of a debugger, asking you to analyze a faulty implementation of the Lomuto partition scheme. By tracing its behavior and predicting the impact on complexity and output, you will gain a deeper appreciation for the invariants that a partition function must uphold @problem_id:3263703.", "problem": "You are given the task of rigorously analyzing the behavior of a randomized quicksort implementation when the Lomuto partition scheme is implemented with an incorrect pointer movement rule. The fundamental base for this analysis is the standard definition of randomized quicksort and the concept of counting key comparisons as a proxy for running time:\n- Randomized quicksort on an array $A$ of size $n$ selects a pivot index uniformly at random from the current subarray, partitions $A$ into elements less than the pivot and elements greater than or equal to the pivot, recursively sorts the left and right subarrays, and terminates when subarray size is less than or equal to $1$.\n- The running time is measured by the total number of key comparisons between array elements and the pivot, aggregated over all partition calls in the recursion tree.\n- The expectation is taken with respect to the randomness in pivot selection.\n\nIn the standard Lomuto partition, for a subarray $A[\\ell..r]$, one chooses a pivot uniformly at random from $\\{\\ell, \\ell+1, \\dots, r\\}$, swaps it into position $r$, initializes an index $i \\leftarrow \\ell$, scans an index $j$ from $\\ell$ to $r-1$, swaps $A[i]$ and $A[j]$ whenever $A[j]$ is less than the pivot and then increments $i$, and finally swaps $A[i]$ with the pivot at $A[r]$ to place the pivot at its final position.\n\nIn this problem, you must analyze a faulty variant of Lomuto partition in which the index $i$ is incorrectly incremented on every iteration of the scan, irrespective of whether $A[j]$ is less than the pivot. Concretely, the faulty partition on subarray $A[\\ell..r]$ does the following:\n- Selects a pivot index uniformly at random from $\\{\\ell, \\ell+1, \\dots, r\\}$ and swaps the pivot into position $r$.\n- Initializes $i \\leftarrow \\ell$.\n- For each $j$ from $\\ell$ to $r-1$:\n  - Performs one comparison of $A[j]$ with the pivot value.\n  - If $A[j]$ is less than the pivot, swaps $A[i]$ and $A[j]$, then sets $i \\leftarrow i+1$.\n  - Otherwise, still sets $i \\leftarrow i+1$ (this is the incorrect step).\n- After the loop, swaps $A[i]$ with $A[r]$ and returns $i$ as the partition index.\n\nYour tasks are:\n- Implement randomized quicksort that uses the above faulty partition procedure and choose the pivot uniformly at random at each call.\n- Instrument the algorithm to measure two quantities per full quicksort call on an input array $A$:\n  1. The total number of key comparisons $C(A)$, defined as the sum over all partition calls of the number of comparisons between $A[j]$ and the pivot value during that call.\n  2. The maximum recursion depth $D(A)$, defined as the maximum number of simultaneous function activations on the call stack observed during execution, counting even the base-case activations on subarrays of size $1$ as depth $1$.\n- Also determine whether the output array is sorted in nondecreasing order.\n\nFrom this, infer and justify the expected outcome and the asymptotic complexity of the randomized quicksort when the faulty partition is used, starting only from the definitions above and standard properties of summations and recursion. Do not assume any specialized formulas that directly shortcut the derivation.\n\nYour program must compute the following for each of the provided test cases:\n- A boolean indicating whether the returned array is sorted in nondecreasing order.\n- The integer $C(A)$.\n- The integer $D(A)$.\n\nUse the following test suite. Each test case is specified as a pair consisting of an initial array and a seed for a pseudorandom number generator that is used to select the random pivots:\n- Test case $1$: array $[\\,3,1,4,1,5,9,2,6\\,]$, seed $42$.\n- Test case $2$: array $[\\,1,2,3,4,5,6,7,8\\,]$, seed $0$.\n- Test case $3$: array $[\\,8,7,6,5,4,3,2,1\\,]$, seed $123$.\n- Test case $4$: array $[\\,5,5,5,5,5\\,]$, seed $2024$.\n- Test case $5$: array $[\\,2\\,]$, seed $8$.\n\nOutput format:\n- Your program should produce a single line of output containing a list of results, one per test case, in the same order as above.\n- Each result must be a list of the form $[\\,\\text{is\\_sorted}, C(A), D(A)\\,]$, where $\\text{is\\_sorted}$ is either True or False, and $C(A)$ and $D(A)$ are integers.\n- The overall output must be a single line: a comma-separated list of these per-test-case lists, enclosed in square brackets. For example: $[\\,[\\text{True},10,4],[\\text{False},6,3]\\,]$.\n\nNo external input must be read; all data must be embedded in the program. There are no physical units, angles, or percentages involved in this task; all outputs are booleans and integers.", "solution": "The problem statement has been validated and is deemed sound. It presents a well-defined algorithmic analysis task within the domain of computer science, based on formal definitions and objective criteria. The problem is self-contained, consistent, and scientifically grounded. We may proceed with the solution.\n\nThe task is to analyze a randomized quicksort algorithm that employs a faulty variant of the Lomuto partition scheme. The analysis requires deriving the total number of key comparisons $C(A)$, the maximum recursion depth $D(A)$, and whether the algorithm correctly sorts the array.\n\nLet us begin with a formal analysis of the faulty partition procedure for a subarray $A[\\ell..r]$ of size $n = r - \\ell + 1$.\n\n1.  **Analysis of the Faulty Partition Logic**\n\nThe faulty partition procedure is defined as follows:\n- A pivot is chosen uniformly at random from $A[\\ell..r]$ and swapped into $A[r]$.\n- An index $i$ is initialized to $\\ell$.\n- A loop iterates with index $j$ from $\\ell$ to $r-1$. The number of iterations is $(r-1) - \\ell + 1 = r-\\ell = n-1$.\n- Inside the loop, a comparison between $A[j]$ and the pivot is performed.\n- Crucially, the index $i$ is incremented in *every* iteration, regardless of the comparison's outcome.\n- After the loop completes, $A[i]$ is swapped with the pivot at $A[r]$, and $i$ is returned.\n\nLet us trace the value of the index $i$. It starts at $i \\leftarrow \\ell$ and is incremented $n-1$ times. Therefore, upon loop termination, the final value of $i$ is $\\ell + (n-1) = \\ell + (r-\\ell) = r$.\n\nThe two swap operations must be carefully examined:\n- The conditional swap inside the loop is `swap(A[i], A[j])`. At the beginning of the $k$-th iteration (for $k = 0, \\dots, n-2$), the value of $j$ is $\\ell+k$ and the value of $i$ is also $\\ell+k$. Thus, the swap is `swap(A[\\ell+k], A[\\ell+k])`, which is a no-operation. The relative order of elements in $A[\\ell..r-1]$ is not changed by this loop.\n- The final swap is `swap(A[i], A[r])`. Since the final value of $i$ is $r$, this becomes `swap(A[r], A[r])`, which is also a no-operation.\n\nThe net effect of one call to this faulty partition on $A[\\ell..r]$ is:\n- A randomly selected element from $A[\\ell..r]$ is moved to position $A[r]$.\n- The relative order of the other $n-1$ elements is preserved.\n- The function returns the partition index $q=r$.\n\n2.  **Analysis of the Recursive Structure and Complexity**\n\nThe general recursive step of quicksort is to partition $A[\\ell..r]$ into $A[\\ell..q-1]$ and $A[q+1..r]$. With the faulty partition always returning $q=r$, the recursive calls become:\n- `quicksort(A, \\ell, r-1)`\n- `quicksort(A, r+1, r)`\n\nThe second call, `quicksort(A, r+1, r)`, is on an empty range of indices since its start boundary is greater than its end boundary. It terminates immediately.\nThe recursion is therefore linear: a call on a subarray of size $n$ leads to a single recursive call on a subarray of size $n-1$. This is the maximally unbalanced partition possible, characteristic of quicksort's worst-case performance.\n\n- **Total Comparisons $C(A)$**: A partition call on a subarray of size $k  1$ performs exactly $k-1$ comparisons (one for each $j$ from $\\ell$ to $r-1$). For an initial array of size $n$, the algorithm generates a sequence of partition calls on subarrays of size $n, n-1, n-2, \\dots, 2$. The call on a subarray of size $1$ is a base case and performs $0$ comparisons.\nThe total number of comparisons is the sum over the sizes of the subarrays processed:\n$$ C(A) = \\sum_{k=2}^{n} (k-1) = \\sum_{j=1}^{n-1} j = \\frac{(n-1)n}{2} $$\nThis is an arithmetic series sum. The number of comparisons is therefore $\\Theta(n^2)$ and is determined solely by the initial array size $n$, independent of the pivot choices or initial data order.\n\n- **Maximum Recursion Depth $D(A)$**: The recursion proceeds as `Q(n) - Q(n-1) - ... - Q(2) - Q(1)`. This forms a linear chain of recursive calls. If the initial call `Q(n)` is at depth $1$, the next call `Q(n-1)` is at depth $2$, and so on. The final base case call on a subarray of size $1$, `Q(1)`, occurs at depth $n$. Thus, the maximum recursion depth is:\n$$ D(A) = n $$\n\n- **Correctness (`is_sorted`)**: The algorithm's behavior on an array $A$ of size $n$ can be described as follows:\n  1. The call `quicksort(A, 0, n-1)` picks a random element from $A[0..n-1]$ and swaps it into position $A[n-1]$. It then recurses on `quicksort(A, 0, n-2)`.\n  2. The call `quicksort(A, 0, n-2)` picks a random element from the current $A[0..n-2]$ and swaps it into position $A[n-2]$, then recurses.\n  3. This process continues until the subarray is of size $1$.\n\nThis procedure, which iterates $k$ from $n-1$ down to $1$ and swaps a random element from the prefix $A[0..k]$ into position $A[k]$, is a well-known algorithm: the Fisher-Yates shuffle. The algorithm does not sort the array; it produces a random permutation of the initial array.\nTherefore, the final array will not be sorted in non-decreasing order, except in two specific scenarios:\n  a) The input array consists of identical elements (e.g., $[5,5,5]$), where any permutation is sorted.\n  b) The random permutation generated happens to be the sorted one, an event with probability $1/k!$ for an array with $k$ distinct elements, which is negligible for non-trivial inputs.\n\nIn summary, the faulty quicksort is not a sorting algorithm but a shuffling algorithm with a deterministic quadratic running time in terms of comparisons and linear space complexity in terms of recursion depth. The program below implements this algorithm and its instrumentation to verify these findings against the provided test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _faulty_partition(arr, l, r, state, rng):\n    \"\"\"\n    Implements the faulty Lomuto partition scheme.\n    - Increments index `i` on every iteration.\n    - Returns the partition index.\n    \"\"\"\n    # Select a pivot index uniformly at random and swap the pivot to the end.\n    pivot_idx = rng.integers(low=l, high=r, endpoint=True)\n    arr[pivot_idx], arr[r] = arr[r], arr[pivot_idx]\n    pivot_value = arr[r]\n    \n    i = l\n    # Loop from l to r-1.\n    for j in range(l, r):\n        # Perform one comparison between an element and the pivot.\n        state['comparisons'] += 1\n        \n        # If A[j] is less than the pivot, swap A[i] and A[j].\n        if arr[j]  pivot_value:\n            arr[i], arr[j] = arr[j], arr[i]\n        \n        # The incorrect step: increment i on every iteration.\n        i += 1\n        \n    # After the loop, swap the pivot (at A[r]) into its final position A[i].\n    arr[i], arr[r] = arr[r], arr[i]\n    \n    return i\n\ndef _quicksort_recursive(arr, l, r, state, depth, rng):\n    \"\"\"\n    The recursive helper for the faulty randomized quicksort.\n    - Tracks comparisons and recursion depth.\n    \"\"\"\n    # Update the maximum observed depth.\n    state['max_depth'] = max(state['max_depth'], depth)\n    \n    # Base case: if the subarray has 0 or 1 elements, terminate.\n    if l = r:\n        return\n        \n    # Partition the array and get the pivot's final index.\n    q = _faulty_partition(arr, l, r, state, rng)\n    \n    # Recursively sort the two subarrays.\n    _quicksort_recursive(arr, l, q - 1, state, depth + 1, rng)\n    _quicksort_recursive(arr, q + 1, r, state, depth + 1, rng)\n\n\ndef run_faulty_quicksort(arr_initial, seed):\n    \"\"\"\n    This function orchestrates the execution of the faulty quicksort for a single test case.\n    It initializes state, runs the algorithm, and returns the measured results.\n    \"\"\"\n    arr = list(arr_initial) # Create a mutable copy.\n    rng = np.random.default_rng(seed)\n    n = len(arr)\n    \n    # State dictionary to hold metrics. Passed by reference to recursive calls.\n    state = {'comparisons': 0, 'max_depth': 0}\n    \n    if n  0:\n        # Initial call to the recursive quicksort function. Depth starts at 1.\n        _quicksort_recursive(arr, 0, n - 1, state, 1, rng)\n    # For n=0, max_depth will remain 0.\n    \n    # Check if the resulting array is sorted in nondecreasing order.\n    is_sorted = all(arr[i] = arr[i+1] for i in range(n - 1))\n    \n    return [is_sorted, state['comparisons'], state['max_depth']]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([3, 1, 4, 1, 5, 9, 2, 6], 42),\n        ([1, 2, 3, 4, 5, 6, 7, 8], 0),\n        ([8, 7, 6, 5, 4, 3, 2, 1], 123),\n        ([5, 5, 5, 5, 5], 2024),\n        ([2], 8),\n    ]\n\n    results = []\n    for arr, seed in test_cases:\n        result = run_faulty_quicksort(arr, seed)\n        results.append(result)\n\n    # Format the results into the exact string required by the problem statement.\n    # e.g., [[True,10,5],[False,28,8]]\n    # str(list) adds spaces, so we format it manually.\n    result_strings = []\n    for r in results:\n        # str(True) - \"True\", str(False) - \"False\"\n        result_strings.append(f\"[{r[0]},{r[1]},{r[2]}]\")\n        \n    final_output = f\"[[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3263703"}]}