{"hands_on_practices": [{"introduction": "This first practice is foundational, introducing the core \"Next Greater Element\" (NGE) and \"Previous Greater Element\" (PGE) patterns that are canonical applications of the monotonic stack. By implementing separate computations for NGE (requiring a right-to-left traversal) and PGE (requiring a left-to-right traversal), you will master the fundamental mechanics of this data structure [@problem_id:3254179]. This exercise solidifies the core logic of maintaining a monotonic invariant to efficiently find relational elements in a sequence.", "problem": "You must write a complete program that, for each element of an integer array, computes the product of its Next Greater Element and its Previous Greater Element, using only the definitions given below and fundamental properties of arrays, integer order, and stacks. No input is read; instead, the program must internally evaluate a fixed test suite of arrays specified in this statement and produce a single aggregated output as described.\n\nDefinitions to be used as the fundamental base:\n- Let $A$ be an array of integers of length $n$. Indices are $0$-based, that is, the valid indices are $0, 1, \\dots, n-1$.\n- For each index $i$ with $0 \\le i \\le n-1$, define the Next Greater Element $\\mathrm{NGE}(i)$ as follows. If there exists an index $j$ with $j  i$ and $A[j]  A[i]$, let $\\mathrm{NGE}(i) = A[j^{\\ast}]$ where $j^{\\ast}$ is the smallest index greater than $i$ such that $A[j^{\\ast}]  A[i]$. If no such $j$ exists, define $\\mathrm{NGE}(i) = -1$.\n- For each index $i$ with $0 \\le i \\le n-1$, define the Previous Greater Element $\\mathrm{PGE}(i)$ as follows. If there exists an index $k$ with $k  i$ and $A[k]  A[i]$, let $\\mathrm{PGE}(i) = A[k^{\\ast}]$ where $k^{\\ast}$ is the largest index less than $i$ such that $A[k^{\\ast}]  A[i]$. If no such $k$ exists, define $\\mathrm{PGE}(i) = -1$.\n- For each index $i$ with $0 \\le i \\le n-1$, define the product $P[i] = \\mathrm{NGE}(i) \\times \\mathrm{PGE}(i)$.\n\nYour task is to compute, for each provided test array $A$, the list $P$ of length $n$ containing these products, in the order of indices from $0$ to $n-1$.\n\nScientific realism and constraints:\n- Arrays may contain any integers (including negative values), duplicates, and may be of length $0$ or greater.\n- The strict inequality $$ governs the definitions of \"greater,\" so equal values do not count as greater.\n- If an array has length $0$, it yields an empty list as output for that case.\n\nTest suite to be evaluated by your program:\n- Case $1$: $A = [\\,5, 1, 3, 2, 4\\,]$.\n- Case $2$: $A = [\\,1, 2, 3, 4\\,]$.\n- Case $3$: $A = [\\,4, 3, 2, 1\\,]$.\n- Case $4$: $A = [\\,2, 2, 2\\,]$.\n- Case $5$: $A = [\\,7\\,]$.\n- Case $6$: $A = [\\,\\,]$ (the empty array).\n\nRequired final output format:\n- Your program should produce a single line of output containing the results for all cases as a single list, where each element is itself the list $P$ for that case, in the same order as the cases above.\n- The line must be a comma-separated list enclosed in square brackets, with no spaces anywhere, including within inner lists. For example, if there were two cases with results $[\\,x_1, x_2\\,]$ and $[\\,y_1\\,]$, the output format would be exactly \"[[x_1,x_2],[y_1]]\" with each $x_1, x_2, y_1$ replaced by their integer values and no spaces at all.\n\nThe answer for each case is a list of integers. The program must be correct for the provided test suite and should be designed using principles appropriate to advanced undergraduate study of data structures and algorithms, such as exploiting order properties and stack behavior, rather than ad hoc enumeration.", "solution": "The problem statement has been validated and is deemed valid. It is self-contained, mathematically well-posed, and free of contradictions or ambiguities. The definitions for Next Greater Element ($\\mathrm{NGE}$) and Previous Greater Element ($\\mathrm{PGE}$) are precise, ensuring a unique solution exists for any given integer array. The problem is a standard exercise in algorithm design, suitable for analysis with data structures.\n\nA complete, reasoned solution is provided below.\n\nThe problem requires us to compute, for each element $A[i]$ in a given array $A$ of length $n$, the product $P[i] = \\mathrm{NGE}(i) \\times \\mathrm{PGE}(i)$. The Next Greater Element, $\\mathrm{NGE}(i)$, is the first element to the right of $A[i]$ that is strictly greater than $A[i]$. The Previous Greater Element, $\\mathrm{PGE}(i)$, is the first element to the left of $A[i]$ that is strictly greater than $A[i]$. If no such element exists, the respective value is defined as $-1$.\n\nA straightforward, yet inefficient, approach would be to iterate through the array for each element. To find $\\mathrm{NGE}(i)$, one would scan all elements $A[j]$ with $j > i$. To find $\\mathrm{PGE}(i)$, one would scan all elements $A[k]$ with $k  i$. This method involves nested loops, resulting in a time complexity of $O(n^2)$ for an array of length $n$. For large arrays, this approach is computationally expensive. The problem hints at a more sophisticated method, and a linear-time $O(n)$ solution can be achieved using a monotonic stack.\n\nThe principle behind the monotonic stack is to maintain a data structure (a stack) where the elements are always in a specific sorted order (either increasing or decreasing). This structure allows for the efficient determination of the next or previous greater/smaller elements for all elements in a single pass.\n\nThe overall algorithm consists of three main steps:\n1. Compute the $\\mathrm{NGE}$ for every element in the array $A$.\n2. Compute the $\\mathrm{PGE}$ for every element in the array $A$.\n3. Compute the final product array $P$ from the results of the previous two steps.\n\n**1. Computing the Next Greater Element ($\\mathrm{NGE}$)**\n\nTo compute the $\\mathrm{NGE}$ for all elements, we can iterate through the array $A$ from right to left (from index $i = n-1$ down to $0$) and use a stack to store values of elements encountered so far. The stack will maintain a strictly decreasing order of elements from bottom to top.\n\nThe algorithm is as follows:\n- Initialize an empty stack, $s$, and a result array, `nge_arr`, of size $n$, with all values initialized to $-1$.\n- For each index $i$ from $n-1$ down to $0$:\n    a. While the stack $s$ is not empty and the element at the top of the stack is less than or equal to $A[i]$ (i.e., $s.\\mathrm{top}() \\le A[i]$), pop elements from the stack. Any such popped element, say $A[k]$ where $k>i$, cannot be the $\\mathrm{NGE}$ for $A[i]$ or any element to the left of $A[i]$ because $A[i]$ itself is closer and greater.\n    b. After the while loop, if the stack is not empty, its top element is the first element to the right of $A[i]$ that is greater than $A[i]$. We set $nge\\_arr[i] = s.\\mathrm{top}()$.\n    c. If the stack is empty, no greater element was found to the right, so $nge\\_arr[i]$ remains $-1$.\n    d. Push the current element $A[i]$ onto the stack. This operation preserves the monotonic (strictly decreasing) property of the stack.\n\nEach element of $A$ is pushed onto and popped from the stack at most once. Therefore, this pass has a time complexity of $O(n)$.\n\n**2. Computing the Previous Greater Element ($\\mathrm{PGE}$)**\n\nThe logic for computing the $\\mathrm{PGE}$ is symmetric to the $\\mathrm{NGE}$ computation. We iterate through the array $A$ from left to right (from index $i = 0$ to $n-1$) and use a similar monotonic stack.\n\nThe algorithm is as follows:\n- Initialize an empty stack, $s$, and a result array, `pge_arr`, of size $n$, with all values initialized to $-1$.\n- For each index $i$ from $0$ to $n-1$:\n    a. While the stack $s$ is not empty and the element at the top of the stack is less than or equal to $A[i]$ (i.e., $s.\\mathrm{top}() \\le A[i]$), pop elements from the stack. The reasoning is analogous to the $\\mathrm{NGE}$ case: these popped elements cannot be the $\\mathrm{PGE}$ for the current element or any subsequent elements.\n    b. If the stack is not empty after the loop, its top element is the nearest greater element to the left of $A[i]$. We set $pge\\_arr[i] = s.\\mathrm{top}()$.\n    c. If the stack is empty, no greater element exists to the left, so $pge\\_arr[i]$ remains $-1$.\n    d. Push the current element $A[i]$ onto the stack.\n\nThis pass also has a time complexity of $O(n)$.\n\n**3. Final Product Calculation**\n\nAfter computing the `nge_arr` and `pge_arr` arrays, the final product array $P$ is obtained by an element-wise multiplication: for each index $i$ from $0$ to $n-1$, calculate $P[i] = nge\\_arr[i] \\times pge\\_arr[i]$. This final step also takes $O(n)$ time.\n\nThe total time complexity of this approach is $O(n) + O(n) + O(n) = O(n)$, and the space complexity is $O(n)$ to store the stack and the result arrays. This design is efficient and directly utilizes the structural properties of the problem as intended. For an empty input array, the result is an empty list as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_products(A: list[int]) - list[int]:\n    \"\"\"\n    Computes the product of the Next Greater Element and Previous Greater Element\n    for each element in an array using a monotonic stack approach.\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return []\n\n    # Initialize result arrays for NGE and PGE with -1.\n    # We use numpy for efficient array operations as permitted.\n    nge_arr = np.full(n, -1, dtype=np.int64)\n    pge_arr = np.full(n, -1, dtype=np.int64)\n\n    # 1. Compute Next Greater Element (NGE) for each element.\n    # We iterate from right-to-left. The stack stores elements from the right\n    # that are candidates for being an NGE.\n    stack = []\n    for i in range(n - 1, -1, -1):\n        # Pop elements from the stack that are less than or equal to the current element.\n        # They cannot be the NGE for A[i] or any elements to the left of A[i].\n        while stack and stack[-1] = A[i]:\n            stack.pop()\n        \n        # If the stack is not empty, the top element is the NGE.\n        if stack:\n            nge_arr[i] = stack[-1]\n        \n        # Push the current element onto the stack for subsequent elements to the left.\n        stack.append(A[i])\n\n    # 2. Compute Previous Greater Element (PGE) for each element.\n    # We iterate from left-to-right. The logic is symmetric to the NGE computation.\n    stack = []\n    for i in range(n):\n        # Pop elements from the stack that are less than or equal to the current element.\n        while stack and stack[-1] = A[i]:\n            stack.pop()\n        \n        # If the stack is not empty, the top element is the PGE.\n        if stack:\n            pge_arr[i] = stack[-1]\n            \n        # Push the current element onto the stack for subsequent elements to the right.\n        stack.append(A[i])\n\n    # 3. Compute the element-wise product of NGE and PGE arrays.\n    products = np.multiply(nge_arr, pge_arr)\n    \n    # Return the result as a standard Python list of integers.\n    return products.tolist()\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the computation for each case,\n    and prints the aggregated results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [5, 1, 3, 2, 4],  # Case 1\n        [1, 2, 3, 4],      # Case 2\n        [4, 3, 2, 1],      # Case 3\n        [2, 2, 2],         # Case 4\n        [7],               # Case 5\n        [],                # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_products(case)\n        results.append(result)\n\n    # Format the final output string as a list of lists with no spaces.\n    # E.g., [[r1_1,r1_2],[r2_1],[],...]\n    string_parts = []\n    for res_list in results:\n        # Format each inner list as \"[el1,el2,...]\"\n        string_parts.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    # Join the inner list strings and wrap with outer brackets.\n    final_output = f\"[{','.join(string_parts)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3254179"}, {"introduction": "Building upon the basic patterns, this exercise challenges you to synthesize results from two distinct monotonic stack passes to solve a more nuanced problem. To find the single *closest* greater element, you must first identify candidates on both the left and the right, and then apply an additional layer of logic to compare their distances [@problem_id:3254259]. This practice demonstrates how to compose fundamental algorithmic building blocks to tackle more complex queries that involve multiple constraints.", "problem": "You are given an array $A$ of length $n$ over a totally ordered domain (for example, the integers with the usual order). For each index $i$ with $0 \\le i  n$, define the target index $j$ to be the index that minimizes the absolute index distance $|i - j|$ subject to the strict inequality $A[j]  A[i]$. If no such index $j$ exists, return $-1$ for that position. In the case of a tie, that is, when there exist indices $j_\\ell$ and $j_r$ with $j_\\ell  i  j_r$, $A[j_\\ell]  A[i]$, $A[j_r]  A[i]$, and $|i - j_\\ell| = |j_r - i|$, choose the smaller index (the one on the left), namely $j_\\ell$.\n\nYour task is to implement a program that, for a given array $A$, computes a list $B$ of length $n$ where $B[i]$ is the chosen index $j$ as defined above, or $-1$ if no such index exists.\n\nDesign your solution from first principles using only fundamental definitions of arrays and stacks, and the well-tested fact that a stack data structure supports operations of push and pop in last-in-first-out order. Do not assume or quote any pre-derived specialized formulas for nearest-greater queries; instead justify the data-structural invariants that lead to a linear-time method.\n\nTest suite and required output:\n- Use the following arrays as test cases:\n    1. $[2,1,3,2,4]$\n    2. $[1,2,3,4]$\n    3. $[4,3,2,1]$\n    4. $[2,2,2,2]$\n    5. $[5,1,5,1,5]$\n    6. $[2,1,1,3]$\n    7. $[7]$\n- For each test case, compute the corresponding list $B$ of indices as integers. The final program output must aggregate the results of all test cases into a single line containing a comma-separated list of the per-test-case results, each result itself being a list of integers, and the entire aggregate enclosed in square brackets. For example, if there were three test cases with results $R_1$, $R_2$, and $R_3$, the output format would be $[R_1,R_2,R_3]$, where each $R_k$ is printed as a list in the form $[\\dots]$ without spaces.", "solution": "The problem is valid as it is self-contained, mathematically well-posed, and grounded in the principles of computer science and discrete mathematics. It presents a clear, objective algorithmic challenge without any scientific inconsistencies or ambiguities.\n\nThe task is to find, for each element $A[i]$ in an array $A$ of length $n$, the index $j$ of an element $A[j]$ that is strictly greater than $A[i]$ and is closest to $i$ in terms of index distance, $|i - j|$. A specific tie-breaking rule favors the smaller index (the one to the left) when two such elements exist at equal distances.\n\nA direct, brute-force approach would be, for each index $i$ from $0$ to $n-1$, to search outwards from $i$ in both directions, left and right, to find the first index $j$ satisfying $A[j]  A[i]$. This would involve, for each $i$, a search of up to $O(n)$ other indices, leading to an overall time complexity of $O(n^2)$. We can design a more efficient solution with a linear time complexity, $O(n)$, by leveraging a stack data structure.\n\nThe core idea is to decompose the problem into two independent subproblems:\n$1$. For each index $i$, find the \"Nearest Greater to the Left\", which we denote as $j_\\ell(i)$. This is the index $k  i$ that is closest to $i$ (i.e., maximal $k$) such that $A[k]  A[i]$. If no such index exists, we define $j_\\ell(i) = -1$.\n$2$. For each index $i$, find the \"Nearest Greater to the Right\", which we denote as $j_r(i)$. This is the index $k  i$ that is closest to $i$ (i.e., minimal $k$) such that $A[k]  A[i]$. If no such index exists, we define $j_r(i) = -1$.\n\nOnce we have computed the arrays $J_\\ell = [j_\\ell(0), j_\\ell(1), \\dots, j_\\ell(n-1)]$ and $J_r = [j_r(0), j_r(1), \\dots, j_r(n-1)]$, we can determine the final result $B[i]$ for each index $i$ by comparing the candidates $j_\\ell(i)$ and $j_r(i)$:\n- If both $j_\\ell(i)$ and $j_r(i)$ are $-1$, no such greater element exists, so $B[i] = -1$.\n- If only one of them exists (is not $-1$), that one is the answer. For instance, if $j_\\ell(i) \\ne -1$ and $j_r(i) = -1$, then $B[i] = j_\\ell(i)$.\n- If both exist, we compare the distances. The distance to the left is $d_\\ell = i - j_\\ell(i)$ and to the right is $d_r = j_r(i) - i$. According to the problem's tie-breaking rule, if $d_\\ell \\le d_r$, we choose the left index. Thus, $B[i] = j_\\ell(i)$ if $i - j_\\ell(i) \\le j_r(i) - i$, and $B[i] = j_r(i)$ otherwise.\n\nThe main challenge is to compute $J_\\ell$ and $J_r$ in linear time. We can achieve this using a monotonic stack. Let us derive the algorithm for computing $J_\\ell$ from first principles. The logic for $J_r$ is symmetric.\n\nTo compute $J_\\ell$, we iterate through the array $A$ from left to right, from $i=0$ to $n-1$. We use a stack, `st`, to store indices of the elements we have processed. The crucial step is to maintain a specific invariant on this stack.\n\n**Invariant**: The stack `st` will contain a sequence of indices $p_1, p_2, \\dots, p_k$ (from bottom to top) such that their corresponding values in the array $A$ are strictly decreasing: $A[p_1] > A[p_2] > \\dots > A[p_k]$. This is known as a monotonically decreasing stack.\n\n**Algorithm for finding Nearest Greater to the Left ($J_\\ell$):**\nWe initialize an empty stack `st` and a result array $J_\\ell$ of size $n$ filled with $-1$. We then iterate with index $i$ from $0$ to $n-1$:\n$1$. For the current element $A[i]$, we look at the index $p$ at the top of the stack.\n$2$. While the stack is not empty and the element at the top index is less than or equal to the current element ($A[st.\\text{top}()] \\le A[i]$), we pop from the stack. The reason this is correct is that if $A[st.\\text{top}()] \\le A[i]$, then the index $st.\\text{top}()$ can never be the \"Nearest Greater to the Left\" for any future element $A[k]$ with $k>i$, because $i$ is a closer index to $k$ and $A[i]$ is at least as great a value, making $st.\\text{top}()$ a suboptimal candidate.\n$3$. After the popping loop, the stack is either empty or its top element is an index $p$ where $A[p] > A[i]$. Because we popped all indices of smaller or equal elements that were to the right of $p$, this index $p$ is the nearest one to the left of $i$ with a value strictly greater than $A[i]$. Thus, we set $j_\\ell(i) = st.\\text{top}()$. If the stack becomes empty, it means no element to the left is greater than $A[i]$, and $j_\\ell(i)$ remains $-1$.\n$4$. Finally, we push the current index $i$ onto the stack. This operation preserves the monotonically decreasing invariant, as all elements with values less than or equal to $A[i]$ have been removed.\n\nThis process visits each element of the array once. Each index is pushed onto the stack exactly once and popped at most once. Therefore, the time complexity for computing the entire $J_\\ell$ array is $O(n)$.\n\nThe computation of the $J_r$ array follows a symmetric logic. We can iterate through the array $A$ from right to left, from $i=n-1$ down to $0$, applying the same monotonic stack principle.\n\nThe complete algorithm is as follows:\n$1$. Compute the $J_\\ell$ array in $O(n)$ time using a left-to-right pass and a monotonic stack.\n$2$. Compute the $J_r$ array in $O(n)$ time using a right-to-left pass and a monotonic stack.\n$3$. Combine the results into the final array $B$ in $O(n)$ time by iterating from $i=0$ to $n-1$ and applying the distance comparison and tie-breaking logic.\n\nThe total time complexity is $O(n) + O(n) + O(n) = O(n)$, and the space complexity is $O(n)$ to store the stack and the intermediate arrays $J_\\ell$ and $J_r$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nearest greater element problem for a list of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [2, 1, 3, 2, 4],\n        [1, 2, 3, 4],\n        [4, 3, 2, 1],\n        [2, 2, 2, 2],\n        [5, 1, 5, 1, 5],\n        [2, 1, 1, 3],\n        [7]\n    ]\n\n    results = []\n    for a in test_cases:\n        n = len(a)\n        if n == 0:\n            results.append([])\n            continue\n\n        # 1. Compute Nearest Greater to the Left (ngl)\n        # We iterate from left to right. The stack stores indices of elements\n        # in a monotonically decreasing value order.\n        ngl = [-1] * n\n        stack = []\n        for i in range(n):\n            # While stack is not empty and the element at the index on top of the stack\n            # is less than or equal to the current element, pop.\n            while stack and a[stack[-1]] = a[i]:\n                stack.pop()\n            # If the stack is not empty after popping, the top element is the NGL.\n            if stack:\n                ngl[i] = stack[-1]\n            # Push the current index onto the stack.\n            stack.append(i)\n\n        # 2. Compute Nearest Greater to the Right (ngr)\n        # We iterate from right to left. The logic is symmetric to NGL.\n        ngr = [-1] * n\n        stack = []\n        for i in range(n - 1, -1, -1):\n            # Pop elements from stack that are less than or equal to current element.\n            while stack and a[stack[-1]] = a[i]:\n                stack.pop()\n            # If stack is not empty, its top is the NGR.\n            if stack:\n                ngr[i] = stack[-1]\n            # Push current index.\n            stack.append(i)\n\n        # 3. Combine ngl and ngr to find the final result\n        result = [-1] * n\n        for i in range(n):\n            j_left, j_right = ngl[i], ngr[i]\n\n            # Case 1: No greater element exists\n            if j_left == -1 and j_right == -1:\n                result[i] = -1\n            # Case 2: Only greater element is to the right\n            elif j_left == -1:\n                result[i] = j_right\n            # Case 3: Only greater element is to the left\n            elif j_right == -1:\n                result[i] = j_left\n            # Case 4: Greater elements exist on both sides\n            else:\n                dist_left = i - j_left\n                dist_right = j_right - i\n                # Tie-breaking rule: choose left if distances are equal or left is closer.\n                if dist_left = dist_right:\n                    result[i] = j_left\n                else:\n                    result[i] = j_right\n        \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Each result list is formatted as a string \"[i1,i2,...]\"\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3254259"}, {"introduction": "Moving from pure implementation to algorithmic analysis, this practice asks you to trace the internal state of the monotonic stack across several archetypal inputs. By predicting the stack's depth evolution for strictly increasing, decreasing, and uniform sequences, you will develop a much deeper intuition for the algorithm's runtime behavior and memory footprint [@problem_id:3254304]. This skill is essential for understanding performance characteristics and reasoning about an algorithm's efficiency in different scenarios.", "problem": "Consider the standard left-to-right algorithm for computing the Next Greater Element (NGE) to the right for each position in an array $A[1..n]$. The algorithm maintains a stack of indices and processes elements in order of increasing index. On each iteration $i$, it performs the following steps: while the stack is non-empty and $A[\\text{top}]  A[i]$, it pops the stack, assigning $A[i]$ as the NGE for each popped index; then it pushes $i$ onto the stack. This invariant implies that, after each push, the sequence of values $A$ at the indices in the stack is monotonically non-increasing. The stack depth at step $i$ is defined as the size of the stack after finishing the processing of element $A[i]$ (including any pops and the subsequent push of $i$).\n\nDesign a test suite that exercises boundary behaviors using the following concrete arrays (each array is to be processed independently by the algorithm described above):\n\n- Strictly increasing: $A^{(1)} = [1,2,3,4,5]$ with $n=5$.\n- Strictly decreasing: $A^{(2)} = [5,4,3,2,1]$ with $n=5$.\n- All equal: $A^{(3)} = [3,3,3,3,3]$ with $n=5$.\n- Alternating peaks and valleys: $A^{(4)} = [3,1,4,2,5,3]$ with $n=6$.\n\nWhich option correctly predicts, for each array $A^{(k)}$, both the per-iteration stack depth sequence (a list of depths after processing each element in order) and the maximum stack depth encountered during the entire run?\n\nA. \n- For $A^{(1)}$: depth sequence $[1,1,1,1,1]$, maximum depth $1$.\n- For $A^{(2)}$: depth sequence $[1,2,3,4,5]$, maximum depth $5$.\n- For $A^{(3)}$: depth sequence $[1,2,3,4,5]$, maximum depth $5$.\n- For $A^{(4)}$: depth sequence $[1,2,1,2,1,2]$, maximum depth $2$.\n\nB.\n- For $A^{(1)}$: depth sequence $[1,2,3,4,5]$, maximum depth $5$.\n- For $A^{(2)}$: depth sequence $[1,1,1,1,1]$, maximum depth $1$.\n- For $A^{(3)}$: depth sequence $[1,1,1,1,1]$, maximum depth $1$.\n- For $A^{(4)}$: depth sequence $[1,2,3,2,3,2]$, maximum depth $3$.\n\nC.\n- For $A^{(1)}$: depth sequence $[1,1,1,1,1]$, maximum depth $1$.\n- For $A^{(2)}$: depth sequence $[1,2,3,4,5]$, maximum depth $5$.\n- For $A^{(3)}$: depth sequence $[1,1,1,1,1]$, maximum depth $1$.\n- For $A^{(4)}$: depth sequence $[1,2,1,2,1,2]$, maximum depth $2$.\n\nD.\n- For $A^{(1)}$: depth sequence $[1,1,1,1,1]$, maximum depth $1$.\n- For $A^{(2)}$: depth sequence $[1,2,3,3,3]$, maximum depth $3$.\n- For $A^{(3)}$: depth sequence $[1,2,3,4,5]$, maximum depth $5$.\n- For $A^{(4d)}$: depth sequence $[1,2,1,1,2,1]$, maximum depth $2$.", "solution": "The problem asks us to trace the stack depth at each step of a specific Next Greater Element (NGE) algorithm and determine the maximum depth for several input arrays. The algorithm is a left-to-right pass that maintains a stack of indices whose corresponding values in array $A$ are in monotonically non-increasing order. The popping condition is `A[stack.top()]  A[i]`. We will trace each case step-by-step. The \"depth\" is the stack size after processing element $A[i]$ and pushing index $i$.\n\n**1. Strictly Increasing: $A^{(1)} = [1,2,3,4,5]$**\n-   **i=0, A[0]=1**: Stack is empty. Push 0. Stack: `[0]`. Depth: 1.\n-   **i=1, A[1]=2**: `A[0]  A[1]` (1  2). Pop 0. Stack: `[]`. Push 1. Stack: `[1]`. Depth: 1.\n-   **i=2, A[2]=3**: `A[1]  A[2]` (2  3). Pop 1. Stack: `[]`. Push 2. Stack: `[2]`. Depth: 1.\n-   **i=3, A[3]=4**: `A[2]  A[3]` (3  4). Pop 2. Stack: `[]`. Push 3. Stack: `[3]`. Depth: 1.\n-   **i=4, A[4]=5**: `A[3]  A[4]` (4  5). Pop 3. Stack: `[]`. Push 4. Stack: `[4]`. Depth: 1.\n-   **Depth Sequence**: `[1, 1, 1, 1, 1]`. **Maximum Depth**: 1.\n\n**2. Strictly Decreasing: $A^{(2)} = [5,4,3,2,1]$**\n-   **i=0, A[0]=5**: Stack is empty. Push 0. Stack: `[0]`. Depth: 1.\n-   **i=1, A[1]=4**: `A[0] > A[1]` (5  4). No pop. Push 1. Stack: `[0, 1]`. Depth: 2.\n-   **i=2, A[2]=3**: `A[1] > A[2]` (4  3). No pop. Push 2. Stack: `[0, 1, 2]`. Depth: 3.\n-   **i=3, A[3]=2**: `A[2] > A[3]` (3  2). No pop. Push 3. Stack: `[0, 1, 2, 3]`. Depth: 4.\n-   **i=4, A[4]=1**: `A[3] > A[4]` (2  1). No pop. Push 4. Stack: `[0, 1, 2, 3, 4]`. Depth: 5.\n-   **Depth Sequence**: `[1, 2, 3, 4, 5]`. **Maximum Depth**: 5.\n\n**3. All Equal: $A^{(3)} = [3,3,3,3,3]$**\n-   The pop condition is `A[top]  A[i]`. Since `A[top]` will always be equal to `A[i]`, the condition is never met and no pops occur.\n-   **i=0, A[0]=3**: Push 0. Stack: `[0]`. Depth: 1.\n-   **i=1, A[1]=3**: `A[0] == A[1]`. No pop. Push 1. Stack: `[0, 1]`. Depth: 2.\n-   **i=2, A[2]=3**: `A[1] == A[2]`. No pop. Push 2. Stack: `[0, 1, 2]`. Depth: 3.\n-   **i=3, A[3]=3**: `A[2] == A[3]`. No pop. Push 3. Stack: `[0, 1, 2, 3]`. Depth: 4.\n-   **i=4, A[4]=3**: `A[3] == A[4]`. No pop. Push 4. Stack: `[0, 1, 2, 3, 4]`. Depth: 5.\n-   **Depth Sequence**: `[1, 2, 3, 4, 5]`. **Maximum Depth**: 5.\n\n**4. Alternating: $A^{(4)} = [3,1,4,2,5,3]$**\n-   **i=0, A[0]=3**: Push 0. Stack: `[0]`. Depth: 1.\n-   **i=1, A[1]=1**: `A[0] > A[1]` (3  1). No pop. Push 1. Stack: `[0, 1]`. Depth: 2.\n-   **i=2, A[2]=4**: `A[1]  A[2]` (1  4), pop 1. `A[0]  A[2]` (3  4), pop 0. Stack is empty. Push 2. Stack: `[2]`. Depth: 1.\n-   **i=3, A[3]=2**: `A[2] > A[3]` (4  2). No pop. Push 3. Stack: `[2, 3]`. Depth: 2.\n-   **i=4, A[4]=5**: `A[3]  A[4]` (2  5), pop 3. `A[2]  A[4]` (4  5), pop 2. Stack is empty. Push 4. Stack: `[4]`. Depth: 1.\n-   **i=5, A[5]=3**: `A[4] > A[5]` (5  3). No pop. Push 5. Stack: `[4, 5]`. Depth: 2.\n-   **Depth Sequence**: `[1, 2, 1, 2, 1, 2]`. **Maximum Depth**: 2.\n\n**Conclusion**\nThe results of our analysis are:\n- $A^{(1)}$: sequence `[1,1,1,1,1]`, max depth `1`.\n- $A^{(2)}$: sequence `[1,2,3,4,5]`, max depth `5`.\n- $A^{(3)}$: sequence `[1,2,3,4,5]`, max depth `5`.\n- $A^{(4)}$: sequence `[1,2,1,2,1,2]`, max depth `2`.\n\nComparing these results to the given options, only Option A matches all four cases.\n- **Option A**: Correctly lists all sequences and maximum depths.\n- **Option B**: Incorrectly analyzes $A^{(2)}$ and $A^{(3)}$.\n- **Option C**: Incorrectly analyzes $A^{(3)}$.\n- **Option D**: Incorrectly analyzes $A^{(2)}$ and contains a typo in the sequence.\n\nTherefore, Option A is the correct answer.", "answer": "$$\n\\boxed{A}\n$$", "id": "3254304"}]}