{"hands_on_practices": [{"introduction": "This exercise introduces the \"Next Greater Element\" problem, a canonical application of the monotonic stack. By processing an array in a single pass, we can efficiently find the first element to the right that is greater than the current one, a pattern that appears in problems ranging from signal processing to data analysis [@problem_id:3253806]. This practice builds the fundamental skill of maintaining a monotonic set of candidates to avoid redundant comparisons, forming the basis for solving more complex challenges.", "problem": "Consider an array of heights $A$ of length $n$ indexed from $0$ to $n-1$. For each position $i$, define its visibility index $V[i]$ to be the smallest index $j$ such that $j gt; i$ and $A[j] gt; A[i]$. If no such index exists, set $V[i] = -1$. The goal is to compute the full visibility array $V$ for given inputs.\n\nFundamental base for reasoning:\n- A double-ended queue (deque) supports insertion and deletion at both ends in $O(1)$ time under standard amortized cost assumptions.\n- A monotonic queue is a double-ended queue whose stored keys maintain a monotonic property (for example, strictly decreasing from front to back).\n- The comparison model uses the binary relation $gt;$ defined on numerical values, which is transitive and antisymmetric when applied to distinct numbers.\n\nTask:\n- Design a program that, for each provided test case array $A$, computes the corresponding visibility array $V$ according to the definition above, using principled reasoning rooted in the fundamental base.\n\nConventions:\n- Use zero-based indexing.\n- Equality does not count as taller; only strict inequality $A[j] gt; A[i]$ is considered.\n- If no taller element exists to the right of position $i$, set $V[i] = -1$.\n\nTest suite:\nCompute the visibility arrays for the following arrays:\n- Case $1$: $A_1 = [3,1,4,2,5]$.\n- Case $2$: $A_2 = [1,2,3,4,5]$.\n- Case $3$: $A_3 = [5,4,3,2,1]$.\n- Case $4$: $A_4 = [2,2,1,2,2,3,1]$.\n- Case $5$: $A_5 = [-1,-2,-3,0,-1]$.\n- Case $6$: $A_6 = [10]$.\n- Case $7$: $A_7 = []$.\n\nAnswer specification:\n- For each case, the answer is a list of integers representing $V$.\n- Your program should produce a single line of output containing all case results aggregated as a comma-separated list enclosed in square brackets, with no spaces. Each case result should itself be represented as a list using zero-based indices. For example, if there were two cases whose results were $[1,2]$ and $[-1,3]$, the output format would be $[[1,2],[-1,3]]$.", "solution": "The problem as stated is subjected to validation.\n\n### Step 1: Extract Givens\n-   An input array of heights $A$ of length $n$, indexed from $0$ to $n-1$.\n-   A visibility index $V[i]$ is defined for each position $i$ as the smallest index $j$ such that $j  i$ and $A[j]  A[i]$.\n-   If no such index $j$ exists, $V[i]$ is defined to be $-1$.\n-   The objective is to compute the full visibility array $V$.\n-   The fundamental base for reasoning includes the properties of double-ended queues (deques), specifically their $O(1)$ amortized cost for terminal operations, and the concept of a monotonic queue.\n-   Conventions: zero-based indexing is used; visibility requires strict inequality ($A[j]  A[i]$); and $V[i] = -1$ is the default for no visible element.\n-   Test suite: $A_1 = [3,1,4,2,5]$, $A_2 = [1,2,3,4,5]$, $A_3 = [5,4,3,2,1]$, $A_4 = [2,2,1,2,2,3,1]$, $A_5 = [-1,-2,-3,0,-1]$, $A_6 = [10]$, $A_7 = []$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria.\n\n-   **Scientifically Grounded:** The problem is a well-established algorithmic challenge in computer science, commonly known as the \"Next Greater Element\" problem. It is founded on the mathematical principles of array manipulation and ordered sets, and its efficient solution relies on the theory of data structures. It is free of any scientific or factual unsoundness.\n-   **Well-Posed:** The definition of the visibility array $V$ is precise and unambiguous. For any given input array $A$, each element $V[i]$ is uniquely determined by the rules provided ($V[i]$ is the smallest $j  i$ with $A[j]  A[i]$, or $-1$). This ensures a unique solution exists for any valid input.\n-   **Objective:** The problem is stated using clear, formal, and objective language (e.g., \"smallest index $j$\", \"strictly inequality $A[j]  A[i]$\"). It is devoid of subjective or vague terminology.\n-   **Completeness:** The problem is self-contained. All necessary definitions, conditions, and edge case behaviors (e.g., no taller element, empty array) are specified.\n-   **Relevance:** The problem is directly relevant to the topic of monotonic queues and their application in algorithm design, as mentioned in the fundamental base.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. It is a well-posed, scientifically grounded, and objective algorithmic task. We may proceed with a reasoned solution.\n\n### Algorithmic Solution\nThe objective is to compute, for each element $A[i]$, the index of the first element to its right that is strictly taller.\n\nA naive approach would be to iterate through the array for each element. For each index $i$ from $0$ to $n-2$, a second loop would search from index $j = i+1$ to $n-1$. The first $j$ found where $A[j]  A[i]$ would be recorded as $V[i]$. If the inner loop completes without finding such a $j$, $V[i]$ is set to $-1$. This nested loop structure results in a time complexity of $O(n^2)$, which is inefficient for large arrays.\n\nTo achieve a more efficient solution, we must avoid redundant comparisons. The problem's structure—finding the \"next\" element with a certain property—is a classic indicator for a single-pass algorithm using a stack-like data structure. By processing the array in a single direction, we can maintain a set of candidates for future \"next greater element\" queries. The most effective strategy here is to iterate through the array from right to left.\n\nLet us define a monotonic stack. In this context, a monotonic stack will be a data structure (implemented using a deque or a list) that stores indices from the array $A$ such that the corresponding values $A[\\text{index}]$ are monotonically ordered.\n\nThe algorithm proceeds as follows:\n1.  Initialize an output array $V$ of size $n$, with all elements set to $-1$. This handles the default case where no greater element is found.\n2.  Initialize an empty stack, $S$. This stack will store the *indices* of elements that are candidates for being the \"next greater element\" for elements to their left.\n3.  Iterate through the input array $A$ from right to left, i.e., for $i = n-1, n-2, \\dots, 0$.\n4.  For each index $i$, we perform the following steps:\n    a.  Examine the index, let's call it $k$, at the top of the stack $S$. While the stack is not empty and the element at index $k$ is less than or equal to the current element $A[i]$ (i.e., $A[k] \\le A[i]$), pop $k$ from the stack. The principle behind this is that the current element $A[i]$ \"blocks\" the view of $A[k]$ for any element to the left of $i$. Any element $A[p]$ with $p  i$ that is shorter than $A[k]$ would also be shorter than $A[i]$. Since $i$ is closer to $p$ than $k$ is, $A[i]$ would be a better candidate for $A[p]$'s next greater element, making $A[k]$ redundant. This step ensures that the stack $S$ maintains a monotonically increasing sequence of values from top to bottom (i.e., $A[S_{\\text{top}}]  A[S_{\\text{top}-1}]  \\dots$).\n    b.  After the popping procedure, if the stack $S$ is not empty, the index $k$ currently at the top of the stack is the first index to the right of $i$ corresponding to a value $A[k]$ that is strictly greater than $A[i]$. We therefore set $V[i] = k$.\n    c.  If the stack $S$ is empty, it signifies that no element to the right of $i$ is greater than $A[i]$. $V[i]$ remains $-1$, its initialized value.\n    d.  Finally, push the current index $i$ onto the stack. This makes $A[i]$ a candidate \"next greater element\" for all remaining elements to its left.\n\nThis single pass through the array, with each index being pushed and popped from the stack at most once, yields a total time complexity of $O(n)$. The space complexity is also $O(n)$ in the worst case (e.g., a strictly decreasing array), where the stack may hold all $n$ indices simultaneously.\n\nLet's trace this algorithm with test case $A_1 = [3,1,4,2,5]$.\n- Initialize $V = [-1, -1, -1, -1, -1]$ and stack $S = []$.\n- $i=4$: $A[4]=5$. Stack is empty. $V[4]$ remains $-1$. Push $4$ onto $S$. $S=[4]$.\n- $i=3$: $A[3]=2$. Top of $S$ is $4$. $A[4]=5  A[3]=2$. Stop popping. $V[3]$ becomes $4$. Push $3$ onto $S$. $S=[4, 3]$.\n- $i=2$: $A[2]=4$. Top of $S$ is $3$. $A[3]=2 \\le A[2]=4$. Pop $3$. $S=[4]$. Top of $S$ is now $4$. $A[4]=5  A[2]=4$. Stop popping. $V[2]$ becomes $4$. Push $2$ onto $S$. $S=[4, 2]$.\n- $i=1$: $A[1]=1$. Top of $S$ is $2$. $A[2]=4  A[1]=1$. Stop popping. $V[1]$ becomes $2$. Push $1$ onto $S$. $S=[4, 2, 1]$.\n- $i=0$: $A[0]=3$. Top of $S$ is $1$. $A[1]=1 \\le A[0]=3$. Pop $1$. $S=[4, 2]$. Top of $S$ is now $2$. $A[2]=4  A[0]=3$. Stop popping. $V[0]$ becomes $2$. Push $0$ onto $S$. $S=[4, 2, 0]$.\nThe final result is $V=[2, 2, 4, 4, -1]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Computes the visibility array for a suite of test cases.\n    The visibility index V[i] is the smallest index j  i such that A[j]  A[i].\n    If no such index exists, V[i] = -1.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [3, 1, 4, 2, 5],            # Case 1\n        [1, 2, 3, 4, 5],            # Case 2\n        [5, 4, 3, 2, 1],            # Case 3\n        [2, 2, 1, 2, 2, 3, 1],      # Case 4\n        [-1, -2, -3, 0, -1],        # Case 5\n        [10],                       # Case 6\n        [],                         # Case 7\n    ]\n\n    results = []\n    for A in test_cases:\n        n = len(A)\n        if n == 0:\n            results.append([])\n            continue\n\n        # Initialize the result array V with -1.\n        # numpy.full is efficient for this initialization.\n        V = np.full(n, -1, dtype=int)\n\n        # The monotonic stack will store indices. A deque is used for O(1)\n        # append and pop operations from the right end.\n        stack = deque()\n\n        # Iterate from right to left through the array.\n        for i in range(n - 1, -1, -1):\n            # Maintain the monotonic property of the stack.\n            # While the stack is not empty and the element at the index on top \n            # of the stack is less than or equal to the current element, pop.\n            # These popped elements are \"blocked\" by the current element A[i]\n            # and cannot be the \"next greater element\" for anything to the left.\n            while stack and A[stack[-1]] = A[i]:\n                stack.pop()\n            \n            # If the stack is not empty after popping, the index at the top\n            # is the first greater element to the right of i.\n            if stack:\n                V[i] = stack[-1]\n\n            # Push the current index onto the stack to make it a candidate for\n            # elements to its left.\n            stack.append(i)\n        \n        results.append(V.tolist())\n\n    # Format the final output string as specified, removing all spaces.\n    # The str() representation of a list includes spaces, which must be removed.\n    output_str = f\"[{','.join(map(str, results))}]\".replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3253806"}, {"introduction": "This practice builds directly on the \"Next Greater Element\" concept by asking for the nearest greater element on *both* the left and right sides. It demonstrates the symmetry and versatility of the monotonic stack algorithm, showing how the same core logic can be applied in different directions to solve related problems [@problem_id:3253891]. By performing two passes—one forwards and one backwards—you will solidify your understanding of how this data structure efficiently processes neighborhood-based queries.", "problem": "You are given a sequence of integers $A = [a_0, a_1, \\dots, a_{n-1}]$ of length $n$, using $0$-based indexing. For each position $i$ with $0 \\le i  n$, define two quantities: the nearest strictly greater element to the left and the nearest strictly greater element to the right. More precisely, the nearest strictly greater element to the left of position $i$ is the index $j$ with $0 \\le j  i$ such that $a_j  a_i$ and $i - j$ is minimized; if no such $j$ exists, the output for position $i$ on the left side is $-1$. Similarly, the nearest strictly greater element to the right of position $i$ is the index $k$ with $i  k \\le n-1$ such that $a_k  a_i$ and $k - i$ is minimized; if no such $k$ exists, the output for position $i$ on the right side is $-1$. Your task is to write a complete, runnable program that, for each array in the test suite below, computes two lists: the list of all left-side nearest strictly greater indices for all positions $i$, and the list of all right-side nearest strictly greater indices for all positions $i$.\n\nFundamental base: Use the core definition of a Double-Ended Queue (deque), which is a sequence supporting insertion and removal at both ends while maintaining order, and leverage standard invariants of a monotonic data structure that preserves either non-increasing or non-decreasing order under push and pop operations. From these definitions, derive an algorithm that runs in time $\\mathcal{O}(n)$ for each array without providing any shortcut formulas.\n\nTest suite to evaluate your program:\n- Case $1$: $A_1 = [3,7,1,7,8,4]$\n- Case $2$: $A_2 = [1,2,3,4]$\n- Case $3$: $A_3 = [9,7,5,3,1]$\n- Case $4$: $A_4 = [5,5,5,5]$\n- Case $5$: $A_5 = [10]$\n- Case $6$: $A_6 = [2,1,2,1,2]$\n\nOutput specification:\n- For each case $A_t$, output a pair of lists $[L_t, R_t]$ where $L_t$ contains the indices of the nearest strictly greater elements to the left for all positions $i$, and $R_t$ contains the indices of the nearest strictly greater elements to the right for all positions $i$. If no strictly greater element exists on a side for position $i$, use $-1$ at that position in the corresponding list.\n- Your program should produce a single line of output containing the results for the six cases as a comma-separated list enclosed in square brackets and without spaces. For example, a valid format is $[[L_1,R_1],[L_2,R_2],\\dots,[L_6,R_6]]$.\n\nAll answers are index lists of integers. There are no physical or angle units involved, and no percentages. Ensure that the algorithmic design is universally applicable and logically derived from the monotonic data structure invariants and definitions.", "solution": "The problem is assessed to be valid. It is a well-defined, self-contained, and objective algorithmic task grounded in the principles of computer science. It is free from scientific unsoundness, ambiguity, and contradictions.\n\nThe task is to find the nearest strictly greater element for each element in a sequence $A = [a_0, a_1, \\dots, a_{n-1}]$, both to its left and to its right. We are required to derive an algorithm with a time complexity of $\\mathcal{O}(n)$ based on the fundamental properties of a Double-Ended Queue (deque) and monotonic data structures.\n\nLet us first formalize the two subproblems:\n1.  **Nearest Greater to the Left (NGL)**: For each index $i \\in [0, n-1]$, find an index $j$ such that $j  i$, $a_j  a_i$, and the distance $i-j$ is minimized. If no such $j$ exists, the result is $-1$.\n2.  **Nearest Greater to the Right (NGR)**: For each index $i \\in [0, n-1]$, find an index $k$ such that $k  i$, $a_k  a_i$, and the distance $k-i$ is minimized. If no such $k$ exists, the result is $-1$.\n\nThese two problems are symmetric. We can derive a solution for NGL and then apply the same logic in reverse to solve NGR.\n\n### Derivation of the NGL Algorithm\n\nA naive approach for finding the NGL for each element $a_i$ would be to scan all elements to its left, from $j=i-1$ down to $0$. The first $j$ for which $a_j  a_i$ is the answer. This requires a nested loop structure, resulting in a worst-case time complexity of $\\mathcal{O}(n^2)$, for instance, when the input array is sorted in increasing order. This is inefficient and does not meet the problem's performance requirement.\n\nTo achieve an $\\mathcal{O}(n)$ solution, we must process the array in a single pass. Let us iterate through the array from left to right, from $i=0$ to $n-1$. At each step $i$, we need to efficiently find the NGL for $a_i$ among the elements $[a_0, a_1, \\dots, a_{i-1}]$.\n\nConsider the set of elements to the left of $a_i$. Not all of them are viable candidates to be the NGL for future elements. Suppose we have two indices $p$ and $q$ such that $p  q  i$. If $a_p \\le a_q$, then for any future element $a_k$ (where $k  i$), $a_p$ can never be its NGL. This is because if $a_p$ were a potential candidate (i.e., $a_p  a_k$), then $a_q$ must also be a candidate ($a_q \\ge a_p  a_k$), and since $q$ is closer to $k$ than $p$ is, $a_q$ would be chosen over $a_p$. Therefore, $a_p$ is \"obstructed\" by $a_q$ and can be discarded from our set of potential NGL candidates.\n\nThis observation leads to a crucial invariant: the set of indices corresponding to useful NGL candidates, when read from left to right, must correspond to a strictly decreasing sequence of values. Let these candidate indices be stored in a sequence $s = [j_1, j_2, \\dots, j_m]$ where $j_1  j_2  \\dots  j_m  i$. For this set to be useful, it must satisfy $a_{j_1}  a_{j_2}  \\dots  a_{j_m}$. This is the defining property of a **monotonically decreasing stack**.\n\nA deque, used as a stack, is the ideal data structure to maintain this sequence of candidate indices. When we process a new element $a_i$, we perform the following steps:\n\n1.  **Maintain the Monotonic Invariant**: We look at the index $j$ at the top of the stack. If $a_j \\le a_i$, then $a_j$ cannot be the NGL for $a_i$ (as it's not strictly greater), nor can it be the NGL for any future element, because $a_i$ is closer and at least as large. Thus, we can pop $j$ from the stack. We repeat this process until the stack is empty or the element at the top is strictly greater than $a_i$.\n\n2.  **Find the NGL**: After step 1, the stack's state is resolved.\n    *   If the stack is now empty, it means no element to the left of $a_i$ is strictly greater than it. The NGL for $a_i$ is $-1$.\n    *   If the stack is not empty, the index $j$ at the top is the first one to the left of $i$ such that $a_j  a_i$. Since we process indices in increasing order, this $j$ is guaranteed to be the nearest one. So, the NGL for $a_i$ is the index at the top of the stack.\n\n3.  **Add the Current Element**: We push the current index $i$ onto the stack. This makes $a_i$ a candidate for being the NGL for subsequent elements. The invariant is maintained because any smaller elements to its left have already been removed.\n\nEach index is pushed onto the stack exactly once and popped at most once. Therefore, the total number of stack operations is proportional to $n$, leading to an amortized time complexity of $\\mathcal{O}(n)$ for the entire pass.\n\n### Derivation of the NGR Algorithm\n\nThe NGR problem is a mirror image of the NGL problem. We can find the NGR for all elements by applying the exact same monotonic stack logic, but by iterating through the array from right to left (i.e., from $i=n-1$ down to $0$). The logic remains identical: for each $a_i$, we pop from the stack all indices corresponding to values less than or equal to $a_i$. The element remaining at the top of the stack, if any, is the NGR.\n\n### The Complete Algorithm\n\nThe final algorithm consists of two independent passes over the input array, each taking $\\mathcal{O}(n)$ time.\n\n**Pass 1: Nearest Greater to the Left (NGL)**\n1.  Initialize an empty deque/stack, `s`, to store indices.\n2.  Initialize a result array, $L$, of size $n$.\n3.  Iterate with index $i$ from $0$ to $n-1$:\n    a. While `s` is not empty and $a_{s.\\text{top()}} \\le a_i$, pop from `s`.\n    b. Set $L[i] = s.\\text{top()}$ if `s` is not empty, otherwise set $L[i] = -1$.\n    c. Push $i$ onto `s`.\n\n**Pass 2: Nearest Greater to the Right (NGR)**\n1.  Clear the deque/stack `s`.\n2.  Initialize a result array, $R$, of size $n$.\n3.  Iterate with index $i$ from $n-1$ down to $0$:\n    a. While `s` is not empty and $a_{s.\\text{top()}} \\le a_i$, pop from `s`.\n    b. Set $R[i] = s.\\text{top()}$ if `s` is not empty, otherwise set $R[i] = -1$.\n    c. Push $i$ onto `s`.\n\nThe pair of lists $[L, R]$ is the solution for the input array $A$. The total time complexity is $\\mathcal{O}(n) + \\mathcal{O}(n) = \\mathcal{O}(n)$, and the space complexity is $\\mathcal{O}(n)$ for the stack and result arrays. This design is universally applicable and derived directly from the invariant of a monotonic data structure.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nearest strictly greater element problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        [3, 7, 1, 7, 8, 4],       # Case 1\n        [1, 2, 3, 4],             # Case 2\n        [9, 7, 5, 3, 1],          # Case 3\n        [5, 5, 5, 5],             # Case 4\n        [10],                     # Case 5\n        [2, 1, 2, 1, 2],          # Case 6\n    ]\n\n    def compute_nearest_greater_elements(arr):\n        \"\"\"\n        Computes the nearest strictly greater element to the left (NGL) and right (NGR)\n        for each element in the input array using a monotonic stack.\n\n        The algorithm performs two passes, one left-to-right for NGL and one\n        right-to-left for NGR. Each pass has an O(n) time complexity.\n\n        Args:\n            arr (list): The input list of integers.\n\n        Returns:\n            list: A pair of lists, [left_results, right_results], where\n                  left_results contains NGL indices and right_results contains\n                  NGR indices.\n        \"\"\"\n        n = len(arr)\n        if n == 0:\n            return [[], []]\n\n        # Initialize result arrays with -1\n        left_greater = np.full(n, -1, dtype=int)\n        right_greater = np.full(n, -1, dtype=int)\n\n        # Using a standard list as a stack to store indices\n        stack = []\n\n        # Pass 1: Left-to-Right for Nearest Greater to the Left (NGL)\n        for i in range(n):\n            # While stack is not empty and the element at the index on top of the stack\n            # is less than or equal to the current element, pop from the stack.\n            # This maintains the monotonic (strictly decreasing) property of the\n            # values corresponding to the indices in the stack.\n            while stack and arr[stack[-1]] = arr[i]:\n                stack.pop()\n            \n            # If the stack is not empty after popping, the index at the top is the NGL.\n            if stack:\n                left_greater[i] = stack[-1]\n            \n            # Push the current index onto the stack for future comparisons.\n            stack.append(i)\n\n        # Clear the stack for the second pass\n        stack.clear()\n\n        # Pass 2: Right-to-Left for Nearest Greater to the Right (NGR)\n        # The logic is symmetric to the first pass.\n        for i in range(n - 1, -1, -1):\n            while stack and arr[stack[-1]] = arr[i]:\n                stack.pop()\n            \n            if stack:\n                right_greater[i] = stack[-1]\n            \n            stack.append(i)\n            \n        return [left_greater.tolist(), right_greater.tolist()]\n\n    all_results_str = []\n    for case_array in test_cases:\n        # Compute the result pair [L, R]\n        result_pair = compute_nearest_greater_elements(case_array)\n        \n        # Manually format the output strings to avoid spaces, as per the specification.\n        # Format the list of left indices, e.g., \"[-1,-1,1,-1,-1,4]\"\n        left_str = f\"[{','.join(map(str, result_pair[0]))}]\"\n        # Format the list of right indices, e.g., \"[1,4,3,4,-1,-1]\"\n        right_str = f\"[{','.join(map(str, result_pair[1]))}]\"\n        \n        # Combine into the final string for one case, e.g., \"[[-1,-1,1,-1,-1,4],[1,4,3,4,-1,-1]]\"\n        pair_str = f\"[{left_str},{right_str}]\"\n        all_results_str.append(pair_str)\n\n    # Join all case results into a single line, e.g., \"[[...],[...],...]\"\n    final_output = f\"[{','.join(all_results_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3253891"}, {"introduction": "This final exercise challenges you to apply the monotonic stack in a more creative context: calculating the sum of maximums over all contiguous subarrays. Instead of a direct query, the monotonic stack is used as a powerful subroutine to solve a combinatorial counting problem by reframing the sum around the contributions of individual elements [@problem_id:3253905]. This problem illustrates how to break down a complex aggregate calculation into simpler parts, a common and powerful algorithmic technique.", "problem": "You are given an integer array $A$ of length $n$, which may contain negative values. For every contiguous subarray $B$ of $A$, let $\\max(B)$ denote the maximum element of $B$. Your task is to compute the sum of $\\max(B)$ over all non-empty contiguous subarrays $B$ of $A$. If $A$ is empty, the sum is defined to be $0$.\n\nFundamental base for reasoning and derivation:\n- Definition of a contiguous subarray: a sequence $A[\\ell], A[\\ell+1], \\dots, A[r]$ for integers $\\ell$ and $r$ satisfying $0 \\le \\ell \\le r  n$.\n- Definition of maximum: for any finite set of integers $S$, the value $\\max(S)$ is the unique element $m \\in S$ such that $m \\ge s$ for all $s \\in S$.\n- Well-tested facts about double-ended queues: a double-ended queue (also called a deque) supports insertion and deletion at both ends. A monotonic deque maintains an order invariant (non-increasing or non-decreasing) of the values associated with its stored indices, and under standard push-pop rules, each index is inserted and removed at most once, yielding amortized $\\mathcal{O}(1)$ time per operation and total $\\mathcal{O}(n)$ time over $n$ operations.\n- Counting principle: if disjoint groups partition a finite set, then the total size of the set equals the sum of the sizes of the groups.\n\nYour program must implement an algorithm grounded in these base definitions and facts, not relying on any provided shortcut formulas, to derive an $\\mathcal{O}(n)$ method using a monotonic deque to aggregate the contributions of each element of $A$ to the overall sum.\n\nInput and output are fixed by the test suite below. No physical units or angles are involved.\n\nTest suite:\nEvaluate the described sum for each of the following arrays $A$:\n- Test $1$: $[3,1,2,4]$\n- Test $2$: $[2,2,2]$\n- Test $3$: $[5,4,3,2,1]$\n- Test $4$: $[-1,0,-3,2]$\n- Test $5$: $[]$\n- Test $6$: $[7]$\n\nFinal output format:\nYour program should produce a single line of output containing the results for Tests $1$ through $6$ in order, as a comma-separated list enclosed in square brackets, with no spaces. For example, an output with three results should look like \"[r1,r2,r3]\".", "solution": "The objective is to calculate the sum of the maximum elements over all non-empty contiguous subarrays of a given integer array $A$. Let this sum be denoted by $S$. The problem is formally stated as:\n$$ S = \\sum_{\\ell=0}^{n-1} \\sum_{r=\\ell}^{n-1} \\max(A[\\ell \\dots r]) $$\nwhere $A[\\ell \\dots r]$ represents the contiguous subarray from index $\\ell$ to $r$, and $n$ is the length of $A$.\n\nA direct computation based on this formula would involve iterating through all $\\mathcal{O}(n^2)$ contiguous subarrays, finding the maximum of each (which can take up to $\\mathcal{O}(n)$ time), leading to an overall time complexity of $\\mathcal{O}(n^3)$, or $\\mathcal{O}(n^2)$ with optimization. This is inefficient for large $n$. The requirement for an $\\mathcal{O}(n)$ solution suggests a different approach.\n\nWe can reframe the problem by applying the counting principle. Instead of summing over subarrays, we can sum over the elements of $A$, calculating the contribution of each element to the total sum. The contribution of an element $A[i]$ is $A[i]$ multiplied by the number of contiguous subarrays for which $A[i]$ is the maximum element.\n$$ S = \\sum_{i=0}^{n-1} A[i] \\cdot (\\text{count of subarrays where } A[i] \\text{ is the maximum}) $$\n\nA crucial aspect is to handle cases where multiple elements in a subarray share the same maximum value. To ensure that each subarray's maximum is counted exactly once, we need a consistent tie-breaking rule. A standard convention is to designate the *first* occurrence of the maximum value within a subarray as its \"official\" maximum.\nTherefore, for an element $A[i]$ to be the designated maximum of a subarray $A[\\ell \\dots r]$ (where $\\ell \\le i \\le r$), two conditions must be met:\n1.  For all other elements $A[k]$ in the subarray (i.e., $k \\in [\\ell, r]$), $A[k] \\le A[i]$.\n2.  For all elements $A[k]$ to the left of $A[i]$ within the subarray (i.e., $k \\in [\\ell, i-1]$), the inequality must be strict: $A[k]  A[i]$.\n\nTo count the number of such subarrays for a fixed index $i$, we need to find the valid range for the start index $\\ell$ and the end index $r$.\nThe condition $A[k]  A[i]$ for all $k \\in [\\ell, i-1]$ implies that the subarray cannot extend to the left to include any element $A[j]$ with $j  i$ and $A[j] \\ge A[i]$. Let $p_i$ be the index of the nearest element to the left of $i$ such that $A[p_i] \\ge A[i]$. This is the \"Previous Greater or Equal\" element. If no such element exists, we define $p_i = -1$. The start index $\\ell$ must be greater than $p_i$, so $\\ell \\in [p_i+1, i]$. The number of choices for $\\ell$ is $i - (p_i+1) + 1 = i - p_i$.\n\nThe condition $A[k] \\le A[i]$ for all $k \\in [i+1, r]$ implies that the subarray cannot extend to the right to include any element $A[j]$ with $j  i$ and $A[j]  A[i]$. Let $q_i$ be the index of the nearest element to the right of $i$ such that $A[q_i]  A[i]$. This is the \"Next Strictly Greater\" element. If no such element exists, we define $q_i = n$. The end index $r$ must be less than $q_i$, so $r \\in [i, q_i-1]$. The number of choices for $r$ is $(q_i-1) - i + 1 = q_i - i$.\n\nThe total number of subarrays for which $A[i]$ is the designated maximum is the product of the number of choices for $\\ell$ and $r$, which is $(i - p_i) \\cdot (q_i - i)$. The contribution of $A[i]$ to the total sum is $A[i] \\cdot (i - p_i) \\cdot (q_i - i)$. The total sum is:\n$$ S = \\sum_{i=0}^{n-1} A[i] \\cdot (i - p_i) \\cdot (q_i - i) $$\n\nThe remaining task is to compute the arrays of indices $p$ (PGE) and $q$ (NSG) in linear time. This is a classic application of a monotonic deque (or stack).\n\n**1. Computing Previous Greater or Equal (PGE) indices ($p_i$):**\nWe iterate from $i=0$ to $n-1$ and use a stack that stores indices of elements in monotonically decreasing order of their values.\nLet `stack` be a deque used as a stack. For each index $i$:\n- While `stack` is not empty and $A[\\text{stack.top()}]  A[i]$, pop from the stack. The popped elements are smaller than $A[i]$ and to its left, so they cannot be the PGE for $A[i]$ or any subsequent element.\n- After the loop, if the `stack` is empty, no element to the left is greater than or equal to $A[i]$, so $p_i = -1$.\n- Otherwise, `stack.top()` holds the index of the nearest element to the left that is greater than or equal to $A[i]$, so $p_i = \\text{stack.top()}$.\n- Push $i$ onto the `stack`. This maintains the monotonic property.\n\n**2. Computing Next Strictly Greater (NSG) indices ($q_i$):**\nA similar monotonic stack approach can be used. An elegant method is to recognize that the NSG for an array $A$ is related to the Previous Strictly Greater (PSG) for the reversed array $A^R$.\nLet $A^R$ be the reversed array, where $A^R[j] = A[n-1-j]$. We compute the PSG for every element of $A^R$.\nThe PSG algorithm is analogous to the PGE one:\n- Let `stack` be a deque. For each index $j=0, \\dots, n-1$ of $A^R$:\n- While `stack` is not empty and $A^R[\\text{stack.top()}] \\le A^R[j]$, pop from the stack.\n- The PSG index for $A^R[j]$ is `stack.top()` if the stack is not empty, or $-1$ otherwise.\n- Push $j$ onto `stack`.\n\nLet `psg_R` be the array of PSG indices for $A^R$. The NSG index $q_i$ for an element $A[i]$ can be found by mapping indices. The element $A[i]$ corresponds to $A^R[n-1-i]$. Its PSG is at some index $j' = \\text{psg\\_R}[n-1-i]$ in $A^R$. The corresponding index in the original array $A$ is $n-1-j'$. If no PSG exists (i.e., $j' = -1$), then no NSG exists for $A[i]$, so $q_i = n$. Thus, $q_i = n-1-\\text{psg\\_R}[n-1-i]$ if $\\text{psg\\_R}[n-1-i] \\ne -1$, and $q_i = n$ otherwise.\n\nBoth passes take $\\mathcal{O}(n)$ time as each index is pushed and popped at most once. The final summation is also $\\mathcal{O}(n)$. The total time complexity is $\\mathcal{O}(n)$, and space complexity is $\\mathcal{O}(n)$ for the helper arrays and the stack.\n\nFor an empty array $A$, $n=0$, the sum is defined to be $0$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the sum of maximums over all contiguous subarrays for multiple test cases.\n    \"\"\"\n\n    def calculate_sum_of_subarray_maxes(A: list[int]) - int:\n        \"\"\"\n        Computes the sum of max(B) for all contiguous subarrays B of A in O(n) time.\n        \"\"\"\n        n = len(A)\n        if n == 0:\n            return 0\n\n        # 1. Compute `left`: Previous Greater or Equal (PGE)\n        # `left[i]` stores the index of the nearest element to the left of `i`\n        # which is greater than or equal to A[i].\n        left = np.full(n, -1, dtype=np.int64)\n        stack = []  # A list used as a stack, stores indices\n        for i in range(n):\n            # This tie-breaking rule (A[stack[-1]]  A[i]) ensures that for A[i] to be a\n            # designated max, everything to its left must be strictly smaller.\n            # So, we're looking for the previous GREATER OR EQUAL element.\n            while stack and A[stack[-1]]  A[i]:\n                stack.pop()\n            if stack:\n                # With the '' rule, what remains on top is >= A[i].\n                # A better rule for PGE is A[stack[-1]] = A[i] and using that to find \n                # previous strictly greater, then handling ties.\n                # However, this current method finds Previous Greater or Equal by a different tie break.\n                # Let's use the standard formulation for clarity and correctness.\n                # PGE: pop while stack and A[stack[-1]]  A[i] is NOT what we want for this tie-break.\n                # Let's adjust for the problem's tie-break rule: left boundary is strict smaller,\n                # right boundary is smaller or equal.\n                # We need Previous GREATER OR EQUAL (for left boundary) and Next GREATER (for right boundary).\n                pass # The code below is a clearer implementation.\n\n        # Correct implementation based on the solution text:\n        # Left boundary: find p_i = Previous Greater or Equal.\n        stack_pge = []\n        for i in range(n):\n            while stack_pge and A[stack_pge[-1]]  A[i]:\n                stack_pge.pop()\n            if stack_pge:\n                left[i] = stack_pge[-1]\n            stack_pge.append(i)\n\n        # Right boundary: find q_i = Next Strictly Greater.\n        right = np.full(n, n, dtype=np.int64)\n        stack_nsg = []\n        for i in range(n - 1, -1, -1):\n            while stack_nsg and A[stack_nsg[-1]] = A[i]:\n                stack_nsg.pop()\n            if stack_nsg:\n                right[i] = stack_nsg[-1]\n            stack_nsg.append(i)\n            \n        # 3. Calculate the total sum based on contributions\n        # The contribution of A[i] is A[i] * (number of subarrays where A[i] is the first max).\n        # Number of such subarrays is (i - left[i]) * (right[i] - i).\n        # Where left[i] is PGE and right[i] is NSG.\n        total_sum = 0\n        for i in range(n):\n            # i - p_i\n            left_count = i - left[i]\n            # q_i - i\n            right_count = right[i] - i\n            count = left_count * right_count\n            total_sum += A[i] * count\n            \n        return total_sum\n\n    test_cases = [\n        [3, 1, 2, 4],      # Test 1\n        [2, 2, 2],         # Test 2\n        [5, 4, 3, 2, 1],   # Test 3\n        [-1, 0, -3, 2],    # Test 4\n        [],                # Test 5\n        [7]                # Test 6\n    ]\n\n    # Re-implementing the core logic without the confusing comments from the original code.\n    def calculate_sum_of_subarray_maxes_clean(A: list[int]) -> int:\n        n = len(A)\n        if n == 0:\n            return 0\n        \n        # p_i: index of previous element >= A[i]\n        prev_greater_equal = np.full(n, -1, dtype=np.int64)\n        stack = []\n        for i in range(n):\n            while stack and A[stack[-1]]  A[i]:\n                stack.pop()\n            if stack:\n                prev_greater_equal[i] = stack[-1]\n            stack.append(i)\n\n        # q_i: index of next element > A[i]\n        next_greater = np.full(n, n, dtype=np.int64)\n        stack = []\n        for i in range(n - 1, -1, -1):\n            while stack and A[stack[-1]] = A[i]:\n                stack.pop()\n            if stack:\n                next_greater[i] = stack[-1]\n            stack.append(i)\n\n        total_sum = 0\n        for i in range(n):\n            left_dist = i - prev_greater_equal[i]\n            right_dist = next_greater[i] - i\n            total_sum += A[i] * left_dist * right_dist\n        \n        return total_sum\n\n    results = []\n    for A in test_cases:\n        result = calculate_sum_of_subarray_maxes_clean(A)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3253905"}]}