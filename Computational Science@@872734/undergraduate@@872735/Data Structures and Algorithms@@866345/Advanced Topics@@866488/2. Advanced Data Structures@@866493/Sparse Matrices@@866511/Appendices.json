{"hands_on_practices": [{"introduction": "The Compressed Sparse Row (CSR) format is optimized for row-based operations, but many real-world tasks require column-wise data. This first exercise [@problem_id:3273095] challenges you to compute column sums efficiently. The key is to realize that you can achieve this with a single pass over the non-zero values, bypassing the row-centric structure and instead using an accumulator array to build the column sums directly.", "problem": "You are given a sparse matrix represented in Compressed Sparse Row (CSR) format. The CSR representation consists of three arrays and a shape: a pointer array $p$ of length $m+1$, a column-index array $j$ of length $\\mathrm{nnz}$, a data array $x$ of length $\\mathrm{nnz}$, and a shape $(m,n)$ specifying the number of rows and columns. The CSR representation encodes a matrix $A \\in \\mathbb{R}^{m \\times n}$ as follows: for each row index $r \\in \\{0,1,\\dots,m-1\\}$, the nonzero entries in row $r$ are stored at positions $k \\in \\{p_r, p_r+1, \\dots, p_{r+1}-1\\}$; for each such $k$, the column index is $j_k \\in \\{0,1,\\dots,n-1\\}$ and the value is $x_k \\in \\mathbb{R}$, contributing to the matrix entry $A_{r,j_k} = x_k$. The array $p$ satisfies $p_0 = 0$ and $p_m = \\mathrm{nnz}$, and is monotonically nondecreasing. Multiple entries sharing the same row and column index are permitted and are interpreted as summing their values into that matrix entry.\n\nYour task is to devise an algorithm to compute the vector of column sums $s \\in \\mathbb{R}^n$ defined by\n$$\ns_c = \\sum_{r=0}^{m-1} A_{r,c} \\quad \\text{for all } c \\in \\{0,1,\\dots,n-1\\},\n$$\nunder the following constraints:\n- Perform a single pass over the stored nonzero data (that is, each stored entry $(j_k, x_k)$ is examined exactly once). Initializing any auxiliary arrays is permitted but must not involve scanning the nonzero data more than once.\n- Do not perform an explicit transposition of the matrix representation.\n- Assume that the CSR input is valid: all indices satisfy $0 \\le j_k  n$, the pointer array $p$ is of length $m+1$ with $p_0 = 0$ and $p_m = \\mathrm{nnz}$, and $p$ is monotonically nondecreasing.\n\nStarting from the core definition of CSR and the definition of column sums, reason from first principles to design a correct and efficient algorithm that meets the given constraints. Then implement the algorithm as a complete, runnable program that applies it to the following test suite. For each test case, the matrix is given by $(m,n)$, the pointer array $p$, the index array $j$, and the data array $x$.\n\nTest Suite:\n- Test case $1$ (general case with duplicates and empty rows): $(m,n) = (4,5)$, $p = (\\,0,\\,2,\\,5,\\,5,\\,7\\,)$, $j = (\\,0,\\,3,\\,2,\\,2,\\,4,\\,1,\\,4\\,)$, $x = (\\,2.0,\\,-1.0,\\,5.0,\\,-2.0,\\,3.0,\\,7.5,\\,1.5\\,)$.\n- Test case $2$ (empty matrix): $(m,n) = (3,4)$, $p = (\\,0,\\,0,\\,0,\\,0\\,)$, $j = (\\,)$, $x = (\\,)$.\n- Test case $3$ (wide matrix with entries in the last column): $(m,n) = (2,6)$, $p = (\\,0,\\,1,\\,3\\,)$, $j = (\\,5,\\,0,\\,5\\,)$, $x = (\\,10.0,\\,-1.0,\\,1.0\\,)$.\n- Test case $4$ (tall matrix with explicit zeros and negatives): $(m,n) = (5,3)$, $p = (\\,0,\\,1,\\,3,\\,3,\\,6,\\,7\\,)$, $j = (\\,1,\\,0,\\,2,\\,0,\\,1,\\,2,\\,1\\,)$, $x = (\\,0.0,\\,4.0,\\,-4.0,\\,1.5,\\,1.5,\\,1.5,\\,-3.0\\,)$.\n- Test case $5$ (unsorted column indices): $(m,n) = (3,4)$, $p = (\\,0,\\,2,\\,3,\\,6\\,)$, $j = (\\,3,\\,1,\\,2,\\,1,\\,3,\\,0\\,)$, $x = (\\,2.0,\\,2.0,\\,5.0,\\,-1.0,\\,3.0,\\,4.0\\,)$.\n- Test case $6$ (heavy duplicates in a single row): $(m,n) = (3,3)$, $p = (\\,0,\\,3,\\,4,\\,4\\,)$, $j = (\\,0,\\,0,\\,0,\\,1\\,)$, $x = (\\,1.0,\\,2.0,\\,3.0,\\,7.0\\,)$.\n\nOutput Specification:\n- For each test case, compute the column sums vector $s \\in \\mathbb{R}^n$.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each individual result is itself a comma-separated list enclosed in square brackets. For example, the output format is\n$$\n\\text{[}[\\,\\text{result\\_1}\\,],[\\,\\text{result\\_2}\\,],\\dots\\text{]},\n$$\nwith no spaces anywhere in the output. Each numeric entry should be printed in standard decimal notation. There are no physical units or angles involved in this problem.\n\nThe design of your algorithm and its implementation should reflect reasoning from first principles based on the definitions above, without relying on shortcut formulas or hints, and must be scientifically realistic and self-consistent.", "solution": "### Step 1: Extract Givens\n\nThe problem provides the following information and constraints:\n- A sparse matrix $A \\in \\mathbb{R}^{m \\times n}$ is represented in Compressed Sparse Row (CSR) format.\n- The CSR representation consists of:\n    - A pointer array $p$ of length $m+1$.\n    - A column-index array $j$ of length $\\mathrm{nnz}$ (number of nonzero entries).\n    - A data array $x$ of length $\\mathrm{nnz}$.\n    - The matrix shape $(m, n)$.\n- The encoding rule is: for each row index $r \\in \\{0, 1, \\dots, m-1\\}$, the nonzero entries are stored at positions $k \\in \\{p_r, p_r+1, \\dots, p_{r+1}-1\\}$. For each such $k$, the column index is $j_k \\in \\{0, 1, \\dots, n-1\\}$ and the value is $x_k \\in \\mathbb{R}$, corresponding to a matrix entry $A_{r, j_k} = x_k$.\n- The pointer array $p$ satisfies $p_0 = 0$, $p_m = \\mathrm{nnz}$, and is monotonically nondecreasing.\n- Multiple stored entries for the same row and column index are permitted and their values are summed.\n- The task is to compute the vector of column sums $s \\in \\mathbb{R}^n$, defined by $s_c = \\sum_{r=0}^{m-1} A_{r,c}$ for all columns $c \\in \\{0, 1, \\dots, n-1\\}$.\n- The following constraints must be adhered to:\n    1.  Perform a single pass over the stored nonzero data.\n    2.  Do not perform an explicit transposition of the matrix representation.\n    3.  Initialization of auxiliary arrays is permitted.\n    4.  The provided CSR input is assumed to be valid.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is subjected to validation against the specified criteria.\n- **Scientifically Grounded**: The problem is rooted in numerical linear algebra and computer science. The Compressed Sparse Row (CSR) format is a standard, widely-used data structure for representing sparse matrices. The concept of column sums is a fundamental matrix operation. All definitions and concepts are mathematically sound and factually correct.\n- **Well-Posed**: The problem is well-posed. The input is a valid CSR matrix representation, and the desired output is the vector of column sums. The definition of the column sum is unambiguous. For any given valid input, a unique, stable, and meaningful solution vector $s$ exists. The constraints on the algorithm are specific and achievable.\n- **Objective**: The problem is formulated with precise, objective mathematical language. It is free of ambiguity, subjective claims, or opinion-based statements. The test cases provide concrete, verifiable data.\n\n### Step 3: Verdict and Action\n\nThe problem is valid as it is scientifically grounded, well-posed, and objective. There are no contradictions, missing information, or unsound premises. The task is a formalizable and relevant algorithmic challenge. Therefore, a solution will be developed.\n\n### Algorithmic Solution from First Principles\n\nThe objective is to compute the column sum vector $s \\in \\mathbb{R}^n$, where the $c$-th component is defined as:\n$$\ns_c = \\sum_{r=0}^{m-1} A_{r,c} \\quad \\text{for } c \\in \\{0, 1, \\dots, n-1\\}\n$$\nThis definition inconveniently requires summing over rows to find elements of a specific column. The CSR format stores elements grouped by row, making a direct application of this formula inefficient as it would require searching for column $c$ in each row's data.\n\nLet us re-examine the summation. The sum for a given column $c$ is the total of all values in that column. The matrix $A$ is the sum of its nonzero entries plus zero entries. The sum $s_c$ is therefore simply the sum of all nonzero entries that reside in column $c$, regardless of their row.\n\nThe CSR format provides all stored (nominally nonzero) entries in the data array $x$ of length $\\mathrm{nnz}$, with their corresponding column indices in the array $j$. The full set of stored entries can be thought of as a list of pairs $(j_k, x_k)$ for $k \\in \\{0, 1, \\dots, \\mathrm{nnz}-1\\}$. The pointer array $p$ provides the row grouping, but for a column-wise sum, this grouping is irrelevant. The problem boils down to aggregating the values in $x$ based on their corresponding column index in $j$.\n\nThe definition of $s_c$ can be reformulated as a sum over the indices of the stored entries. Let $\\mathcal{K} = \\{0, 1, \\dots, \\mathrm{nnz}-1\\}$ be the set of indices into the $j$ and $x$ arrays. Then, the sum for column $c$ is:\n$$\ns_c = \\sum_{k \\in \\mathcal{K} \\text{ such that } j_k = c} x_k\n$$\nThis revised formulation is independent of the row structure and provides a direct path to an efficient algorithm that respects the given constraints.\n\n1.  **Initialization**: The problem permits the initialization of auxiliary arrays. We need to compute $n$ separate sums, one for each column. This naturally suggests an auxiliary array, which will become our result vector $s$, of size $n$. We initialize this array with all zeros.\n    $$\n    s = [0.0, 0.0, \\dots, 0.0] \\in \\mathbb{R}^n\n    $$\n    This step does not involve scanning the nonzero data. The value of $n$ is given as part of the matrix shape $(m, n)$.\n\n2.  **Single Pass Accumulation**: The problem requires a single pass over the stored nonzero data. The arrays $j$ and $x$ represent this data exhaustively. We can iterate through these arrays from index $k=0$ to $k=\\mathrm{nnz}-1$. For each index $k$:\n    - We retrieve the column index $c = j_k$.\n    - We retrieve the value $v = x_k$.\n    - This value $v$ contributes to the total sum for column $c$. We update the corresponding entry in our accumulator array: $s_c \\leftarrow s_c + v$.\n\n3.  **Finalization**: After the loop completes, every stored nonzero value $x_k$ will have been added to the sum for its corresponding column $j_k$. The array $s$ will hold the final, complete column sums.\n\nThis algorithm satisfies all constraints:\n- It performs exactly one pass over the $j$ and $x$ arrays, which represent the stored nonzero data.\n- It does not perform any matrix transposition; it works directly with the given CSR index and data arrays.\n- It uses a single auxiliary array for accumulation, which is explicitly permitted.\n- The algorithm correctly handles duplicate entries (e.g., if multiple $k$ values correspond to the same $(r, c)$ pair) because addition is associative and commutative. It also correctly handles unsorted column indices within rows, as the order of processing entries does not affect the final sum for each column.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the column sums of sparse matrices given in CSR format\n    for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"m\": 4, \"n\": 5,\n            \"p\": np.array([0, 2, 5, 5, 7]),\n            \"j\": np.array([0, 3, 2, 2, 4, 1, 4]),\n            \"x\": np.array([2.0, -1.0, 5.0, -2.0, 3.0, 7.5, 1.5])\n        },\n        {\n            \"m\": 3, \"n\": 4,\n            \"p\": np.array([0, 0, 0, 0]),\n            \"j\": np.array([]),\n            \"x\": np.array([])\n        },\n        {\n            \"m\": 2, \"n\": 6,\n            \"p\": np.array([0, 1, 3]),\n            \"j\": np.array([5, 0, 5]),\n            \"x\": np.array([10.0, -1.0, 1.0])\n        },\n        {\n            \"m\": 5, \"n\": 3,\n            \"p\": np.array([0, 1, 3, 3, 6, 7]),\n            \"j\": np.array([1, 0, 2, 0, 1, 2, 1]),\n            \"x\": np.array([0.0, 4.0, -4.0, 1.5, 1.5, 1.5, -3.0])\n        },\n        {\n            \"m\": 3, \"n\": 4,\n            \"p\": np.array([0, 2, 3, 6]),\n            \"j\": np.array([3, 1, 2, 1, 3, 0]),\n            \"x\": np.array([2.0, 2.0, 5.0, -1.0, 3.0, 4.0])\n        },\n        {\n            \"m\": 3, \"n\": 3,\n            \"p\": np.array([0, 3, 4, 4]),\n            \"j\": np.array([0, 0, 0, 1]),\n            \"x\": np.array([1.0, 2.0, 3.0, 7.0])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        j_indices = case[\"j\"]\n        x_values = case[\"x\"]\n        \n        # 1. Initialize an auxiliary array `s` of size `n` with zeros.\n        #    This array will accumulate the sums for each column.\n        s = np.zeros(n, dtype=np.float64)\n        \n        # 2. Perform a single pass over the stored nonzero data.\n        #    The arrays `j_indices` and `x_values` contain all stored entries.\n        #    `nnz` is the length of these arrays.\n        nnz = len(j_indices)\n        for k in range(nnz):\n            # For each entry, get its column index and value.\n            col_idx = j_indices[k]\n            value = x_values[k]\n            \n            # Add the value to the accumulator for the corresponding column.\n            s[col_idx] += value\n            \n        results.append(s.tolist())\n\n    # Format the final output string as specified in the problem.\n    # e.g., [[result_1],[result_2],...] with no spaces.\n    results_str_list = []\n    for res in results:\n        # Convert each number in the result list to its string representation.\n        # The default float-to-string conversion is sufficient.\n        res_str = [str(val) for val in res]\n        # Join the numbers with a comma and enclose in brackets.\n        results_str_list.append(f\"[{','.join(res_str)}]\")\n    \n    # Join all test case results with a comma and enclose in brackets.\n    final_output = f\"[{','.join(results_str_list)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3273095"}, {"introduction": "Sparse Matrix-Vector multiplication (SpMV) is a cornerstone of scientific computing, forming the core of many iterative solvers and simulations. This practice [@problem_id:3272985] explores the case where both the matrix and the vector are sparse. Your task is to develop an efficient algorithm that avoids densifying the inputs, which will lead you to discover the importance of preprocessing the sparse vector into a fast-lookup data structure.", "problem": "Design and implement a complete, runnable program that computes the sparse matrix-vector product $y = A x$ where the matrix $A$ is stored in Compressed Sparse Row (CSR) format and the vector $x$ is stored as a list of index-value pairs (a sparse representation). The program must use only the nonzero entries of both $A$ and $x$ and must not densify either input. The algorithm design must start from the core definition of matrix-vector multiplication and from the data-structural definition of CSR. The program must handle duplicate column indices in a row of $A$ and duplicate indices in $x$ by accumulating contributions correctly.\n\nThe fundamental base is the linear algebraic definition of matrix-vector multiplication and the CSR representation:\n- For a matrix $A \\in \\mathbb{R}^{m \\times n}$ and a vector $x \\in \\mathbb{R}^{n}$, the product $y \\in \\mathbb{R}^{m}$ is defined by $y_i = \\sum_{j=0}^{n-1} A_{ij} x_j$ for each row index $i \\in \\{0, 1, \\dots, m-1\\}$.\n- In Compressed Sparse Row (CSR) format, $A$ is represented by three arrays: a row pointer array $rp$ of length $m+1$, a column index array $ci$ of length $\\mathrm{nnz}(A)$, and a value array $v$ of length $\\mathrm{nnz}(A)$. For a row index $i$, the nonzero entries of that row are stored in contiguous positions $k \\in \\{rp[i], rp[i]+1, \\dots, rp[i+1]-1\\}$, with column indices $ci[k]$ and corresponding values $v[k]$. It is assumed that within each row the column indices are nondecreasing.\n- A sparse vector $x$ is represented by a pair of arrays: index array $xi$ of length $\\mathrm{nnz}(x)$ and value array $xv$ of length $\\mathrm{nnz}(x)$, which together encode $x_{xi[t]} = xv[t]$ for $t \\in \\{0, 1, \\dots, \\mathrm{nnz}(x)-1\\}$ and $x_j = 0$ for any $j$ not present in $xi$. Indices in $xi$ may repeat and must be summed to form the effective value $x_j$.\n\nYour program must implement the computation of $y$ using only the nonzero entries of $A$ and $x$ as described. The output for each test case must be the dense vector $y$ represented as a list of integers. All indices are zero-based. Values in the inputs and outputs are pure numbers without physical units.\n\nTest suite specification. Implement your program to compute results for the following test suite, which exercises general and edge conditions. Each test case is specified by $(m, n, rp, ci, v, xi, xv)$, where $m$ and $n$ are dimensions, $rp$ is the CSR row pointer array, $ci$ is the CSR column index array, $v$ is the CSR value array, $xi$ is the sparse vector index array, and $xv$ is the sparse vector value array:\n\n- Test case $1$ (general case with empty row and duplicate column in a row):\n  - $m = 4$, $n = 5$,\n  - $rp = \\left[0, 2, 5, 5, 8\\right]$,\n  - $ci = \\left[0, 3, 1, 2, 4, 0, 2, 2\\right]$,\n  - $v = \\left[2, 1, 3, -1, 2, 5, 4, -4\\right]$,\n  - $xi = \\left[0, 2, 4\\right]$,\n  - $xv = \\left[1, -2, 3\\right]$.\n  - The expected output is a list $y$ of length $m$ with integer entries.\n\n- Test case $2$ (boundary case with empty vector $x$):\n  - $m = 3$, $n = 3$,\n  - $rp = \\left[0, 1, 3, 3\\right]$,\n  - $ci = \\left[0, 1, 2\\right]$,\n  - $v = \\left[7, -1, 4\\right]$,\n  - $xi = \\left[\\right]$,\n  - $xv = \\left[\\right]$.\n  - The expected output is a list $y$ of length $m$ equal to $\\left[0, 0, 0\\right]$.\n\n- Test case $3$ (boundary case $1 \\times 1$):\n  - $m = 1$, $n = 1$,\n  - $rp = \\left[0, 1\\right]$,\n  - $ci = \\left[0\\right]$,\n  - $v = \\left[9\\right]$,\n  - $xi = \\left[0\\right]$,\n  - $xv = \\left[-3\\right]$.\n  - The expected output is a list $y$ of length $m$ equal to $\\left[-27\\right]$.\n\n- Test case $4$ (non-overlapping indices except scattered matches):\n  - $m = 3$, $n = 5$,\n  - $rp = \\left[0, 2, 4, 5\\right]$,\n  - $ci = \\left[1, 4, 0, 3, 2\\right]$,\n  - $v = \\left[10, 2, 5, 7, 1\\right]$,\n  - $xi = \\left[0, 2\\right]$,\n  - $xv = \\left[4, -1\\right]$.\n  - The expected output is a list $y$ of length $m$ with integer entries.\n\n- Test case $5$ (duplicates in both $A$ and $x$):\n  - $m = 5$, $n = 6$,\n  - $rp = \\left[0, 2, 2, 3, 6, 8\\right]$,\n  - $ci = \\left[0, 5, 5, 1, 1, 4, 2, 3\\right]$,\n  - $v = \\left[1, 1, 2, 3, -3, 6, -2, 4\\right]$,\n  - $xi = \\left[1, 2, 1, 5\\right]$,\n  - $xv = \\left[10, 7, -10, 1\\right]$.\n  - The expected output is a list $y$ of length $m$ with integer entries.\n\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each item is the list representation of the output vector for that test case, with no spaces inside lists. For example, for three test cases with outputs $\\left[a_1, a_2\\right]$, $\\left[b_1, b_2, b_3\\right]$, and $\\left[c_1\\right]$, the single line must be exactly $\\left[\\left[a_1,a_2\\right],\\left[b_1,b_2,b_3\\right],\\left[c_1\\right]\\right]$.\n\nThe answer for each test case must be a list of integers.", "solution": "The problem requires the design and implementation of an algorithm to compute the matrix-vector product $y = Ax$, where the matrix $A$ is given in Compressed Sparse Row (CSR) format and the vector $x$ is represented sparsely as a list of index-value pairs. The core constraints are that the computation must be performed efficiently by utilizing only the non-zero entries of both $A$ and $x$, without converting them to dense representations, and that duplicate indices in both inputs must be handled by accumulation.\n\nThe foundation of the algorithm is the mathematical definition of the matrix-vector product. For a matrix $A \\in \\mathbb{R}^{m \\times n}$ and a vector $x \\in \\mathbb{R}^{n}$, the resulting vector $y \\in \\mathbb{R}^{m}$ is defined component-wise for each row index $i \\in \\{0, 1, \\dots, m-1\\}$ as:\n$$y_i = \\sum_{j=0}^{n-1} A_{ij} x_j$$\nIn a sparse context, most terms $A_{ij}$ and $x_j$ are zero. An efficient algorithm must avoid these trivial multiplications. The sum can be restricted to indices $j$ for which $A_{ij} \\neq 0$:\n$$y_i = \\sum_{j \\mid A_{ij} \\neq 0} A_{ij} x_j$$\nTo evaluate this efficiently, for each non-zero entry $A_{ij}$, we need to quickly access the corresponding value $x_j$. The provided sparse representation of $x$ is not ideal for direct lookups. Therefore, a two-stage algorithm is appropriate: first, preprocessing the vector $x$ into an efficient lookup structure, and second, iterating through the non-zero entries of $A$ to compute the components of $y$.\n\n**Step 1: Preprocessing the Sparse Vector $x$**\nThe input vector $x$ is described by an index array $xi$ and a value array $xv$. Critically, indices in $xi$ may be repeated, and their corresponding values in $xv$ must be summed to obtain the total value for that component of $x$. For instance, if $xi = [1, 2, 1]$ and $xv = [10, 7, -10]$, the effective value of $x_1$ is $10 + (-10) = 0$.\n\nTo facilitate fast lookups of $x_j$ values, we convert the $(xi, xv)$ pair representation into a hash map (or dictionary in Python). Let's call this map $x_{map}$. The keys of $x_{map}$ will be the column indices $j$ where $x_j \\neq 0$, and the values will be the corresponding non-zero values of $x$.\n\nThe process is as follows:\n1. Initialize an empty hash map, $x_{map}$.\n2. Iterate through the sparse vector representation from $t=0$ to $\\mathrm{nnz}(x)-1$. For each pair $(xi[t], xv[t])$:\n   - If the index $xi[t]$ is already a key in $x_{map}$, add $xv[t]$ to its current value.\n   - If $xi[t]$ is not in $x_{map}$, insert it as a new key with value $xv[t]$.\nAfter this process, $x_{map}$ contains all the non-zero entries of the vector $x$, with duplicate indices properly summed. Accessing any $x_j$ is now an average-case constant-time operation: if $j$ is in $x_{map}$, its value is $x_{map}[j]$; otherwise, its value is $0$. This avoids densifying $x$ into an array of size $n$, adhering to the problem constraints.\n\n**Step 2: Sparse Matrix-Vector Product Computation**\nWith the preprocessed $x_{map}$, we can now compute the product $y = Ax$. The result vector $y$ is dense, of size $m$, so we initialize it as an array of zeros, $y = [0, 0, \\dots, 0]$.\n\nThe matrix $A$ is given in CSR format by three arrays: the row pointer $rp$ (length $m+1$), the column indices $ci$ (length $\\mathrm{nnz}(A)$), and the values $v$ (length $\\mathrm{nnz}(A)$). The $rp$ array defines the slice of $ci$ and $v$ that corresponds to each row. Specifically, the non-zero entries for row $i$ are stored from index $rp[i]$ up to, but not including, index $rp[i+1]$ in the $ci$ and $v$ arrays.\n\nThe algorithm proceeds row by row:\n1. Iterate through each row index $i$ from $0$ to $m-1$.\n2. For each row $i$, determine the range of indices in $ci$ and $v$ that correspond to its non-zero entries. This range is $[rp[i], rp[i+1]-1]$.\n3. Initialize a running sum for the current row's output, $y_i^{sum} = 0$.\n4. Iterate with an index $k$ from $rp[i]$ to $rp[i+1]-1$. In each iteration:\n   a. Retrieve the column index $j = ci[k]$ and the matrix value $A_{ij} = v[k]$.\n   b. Look up the value of $x_j$ from the preprocessed $x_{map}$. If the key $j$ exists in $x_{map}$, let $x_j = x_{map}[j]$. Otherwise, $x_j = 0$.\n   c. If $x_j$ is non-zero, calculate the product $A_{ij} \\times x_j$ and add it to the running sum: $y_i^{sum} = y_i^{sum} + v[k] \\times x_j$. If $x_j$ is zero, this step is skipped, naturally avoiding unnecessary computation.\n5. After the loop over $k$ completes, the accumulated sum $y_i^{sum}$ is the final value for $y_i$. Store this value in the output vector: $y[i] = y_i^{sum}$.\n\nThis procedure correctly handles duplicate column indices within a row of $A$ (e.g., if $ci[k_1] = ci[k_2] = j$ for a given row). The loop over $k$ will simply process both entries, and their respective contributions, $v[k_1] \\times x_j$ and $v[k_2] \\times x_j$, will be correctly added to the sum for $y_i$.\n\nUpon completion of the loop over all rows $i$, the vector $y$ will contain the full result of the sparse matrix-vector product. The final values are cast to integers as required by the problem specification.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sparse matrix-vector multiplication problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (general case with empty row and duplicate column in a row)\n        (4, 5, [0, 2, 5, 5, 8], [0, 3, 1, 2, 4, 0, 2, 2], [2, 1, 3, -1, 2, 5, 4, -4], [0, 2, 4], [1, -2, 3]),\n        \n        # Test case 2 (boundary case with empty vector x)\n        (3, 3, [0, 1, 3, 3], [0, 1, 2], [7, -1, 4], [], []),\n        \n        # Test case 3 (boundary case 1x1)\n        (1, 1, [0, 1], [0], [9], [0], [-3]),\n        \n        # Test case 4 (non-overlapping indices except scattered matches)\n        (3, 5, [0, 2, 4, 5], [1, 4, 0, 3, 2], [10, 2, 5, 7, 1], [0, 2], [4, -1]),\n\n        # Test case 5 (duplicates in both A and x)\n        (5, 6, [0, 2, 2, 3, 6, 8], [0, 5, 5, 1, 1, 4, 2, 3], [1, 1, 2, 3, -3, 6, -2, 4], [1, 2, 1, 5], [10, 7, -10, 1])\n    ]\n\n    def compute_spmv(m, n, rp, ci, v, xi, xv):\n        \"\"\"\n        Computes the sparse matrix-vector product y = Ax.\n        A is in CSR format (rp, ci, v).\n        x is sparse (xi, xv).\n\n        Args:\n            m (int): Number of rows in A.\n            n (int): Number of columns in A.\n            rp (list): Row pointer array for A (CSR).\n            ci (list): Column index array for A (CSR).\n            v (list): Value array for A (CSR).\n            xi (list): Index array for sparse vector x.\n            xv (list): Value array for sparse vector x.\n\n        Returns:\n            list: The resulting dense vector y as a list of integers.\n        \"\"\"\n        # Step 1: Preprocess the sparse vector x into a hash map for efficient lookup.\n        # This handles duplicate indices in x by accumulating their values.\n        x_map = {}\n        for idx, val in zip(xi, xv):\n            x_map[idx] = x_map.get(idx, 0) + val\n\n        # Initialize the dense output vector y with zeros.\n        y = [0] * m\n\n        # Step 2: Compute the matrix-vector product.\n        # Iterate through each row of the matrix A.\n        for i in range(m):\n            # The sum for the current row y_i.\n            row_sum = 0\n            \n            # The non-zero elements for row i are located in the range [rp[i], rp[i+1]-1]\n            # of the ci and v arrays.\n            start_idx = rp[i]\n            end_idx = rp[i+1]\n            \n            for k in range(start_idx, end_idx):\n                # Get column index j and value A_ij from CSR arrays.\n                j = ci[k]\n                A_ij = v[k]\n                \n                # Get value of x_j from the preprocessed map. Defaults to 0 if not found.\n                x_j = x_map.get(j, 0)\n                \n                # Add the product to the row's sum.\n                # This naturally handles duplicate column indices in A's rows.\n                row_sum += A_ij * x_j\n            \n            # Store the final integer result for y_i.\n            y[i] = int(row_sum)\n            \n        return y\n\n    all_results = []\n    for case in test_cases:\n        m, n, rp, ci, v, xi, xv = case\n        result_vector = compute_spmv(m, n, rp, ci, v, xi, xv)\n        all_results.append(result_vector)\n\n    # Format the output string exactly as specified: [[a,b],[c,d,e],...]\n    # No spaces within the inner lists.\n    result_strings = []\n    for res in all_results:\n        # Format each inner list as '[i1,i2,...]'\n        formatted_list = '[' + ','.join(map(str, res)) + ']'\n        result_strings.append(formatted_list)\n    \n    # Join all formatted lists into a single string '[...],[...],...'\n    final_output = '[' + ','.join(result_strings) + ']'\n    \n    print(final_output)\n\nsolve()\n```", "id": "3272985"}, {"introduction": "We conclude with a more advanced matrix-matrix operation, computing $C = AB^T$ where both matrices are in CSR format. The elegant solution to this problem [@problem_id:3273053] avoids costly explicit transposition by recognizing that the result can be computed as a series of dot products between the rows of $A$ and $B$. This exercise will guide you through implementing a classic two-pointer algorithm to efficiently find the intersection of non-zero elements, a fundamental pattern in sparse computing.", "problem": "You are given two sparse matrices stored in Compressed Sparse Row (CSR) format. The CSR format for a matrix with $m$ rows and $n$ columns consists of three arrays: $row\\_ptr$ of length $m+1$, $col\\_idx$ of length equal to the number of nonzero entries, and $data$ of the same length as $col\\_idx$. For each row index $i$ with $0 \\le i lt; m$, the nonzero entries in row $i$ occupy the slice $col\\_idx[row\\_ptr[i]:row\\_ptr[i+1]]$, with corresponding values in $data[row\\_ptr[i]:row\\_ptr[i+1]]$. Within each row, the column indices are sorted in strictly increasing order. All values are real numbers, and for this problem they are integers.\n\nYour task is to implement a program that computes the product $C = A B^T$ for given pairs of matrices $A$ and $B$, where both $A$ and $B$ are stored in CSR format. The matrix $A$ has shape $m \\times n$ and the matrix $B$ has shape $p \\times n$, so $B^T$ has shape $n \\times p$ and $C$ has shape $m \\times p$. You must compute $C$ by iterating through the rows of $A$ and the rows of $B$ simultaneously, without explicitly forming $B^T$ and without converting $B$ to a column-oriented structure. For each pair of rows, compute the dot product by merging their sorted column index lists to find their intersection.\n\nFundamental base: Use the definition of matrix multiplication and transposition. For all $i$ and $j$, the entry $C_{i,j}$ satisfies\n$$\nC_{i,j} = \\sum_{k=0}^{n-1} A_{i,k}\\, (B^T)_{k,j} = \\sum_{k=0}^{n-1} A_{i,k}\\, B_{j,k},\n$$\nthat is, $C_{i,j}$ equals the dot product between row $i$ of $A$ and row $j$ of $B$.\n\nRequirements:\n- Do not form $B^T$ explicitly and do not convert $B$ to a column-oriented format.\n- For each pair of rows $(i,j)$, compute the dot product by a two-pointer merge over the sorted column index lists of row $i$ in $A$ and row $j$ in $B$, accumulating products where the column indices match.\n- Exclude zero entries from the output representation of $C$.\n\nOutput specification:\n- For each test case, output the nonzero entries of $C$ as a list of triplets $[i,j,v]$, where $i$ is the row index, $j$ is the column index, and $v$ is the value (an integer). Triplets must be listed in ascending lexicographic order by $i$, then by $j$.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, with no whitespace. For example, if there are three test cases with results $R_1$, $R_2$, and $R_3$, then the output must be $[R_1,R_2,R_3]$, where each $R_t$ is itself a list of triplets as described.\n\nTest suite:\n- Test case $1$ (general case):\n  - $A$: shape $m \\times n$ with $m=3$, $n=5$,\n    - $row\\_ptr = [0,2,4,6]$,\n    - $col\\_idx = [0,3,1,2,2,4]$,\n    - $data = [1,2,3,4,5,6]$.\n  - $B$: shape $p \\times n$ with $p=2$, $n=5$,\n    - $row\\_ptr = [0,3,6]$,\n    - $col\\_idx = [0,2,3,1,3,4]$,\n    - $data = [7,8,9,10,11,12]$.\n- Test case $2$ (all-zero $A$):\n  - $A$: shape $m \\times n$ with $m=2$, $n=4$,\n    - $row\\_ptr = [0,0,0]$,\n    - $col\\_idx = []$,\n    - $data = []$.\n  - $B$: shape $p \\times n$ with $p=3$, $n=4$,\n    - $row\\_ptr = [0,1,2,4]$,\n    - $col\\_idx = [1,2,0,3]$,\n    - $data = [1,2,3,4]$.\n- Test case $3$ (all-zero $B$):\n  - $A$: shape $m \\times n$ with $m=2$, $n=5$,\n    - $row\\_ptr = [0,2,3]$,\n    - $col\\_idx = [0,2,1]$,\n    - $data = [2,3,4]$.\n  - $B$: shape $p \\times n$ with $p=4$, $n=5$,\n    - $row\\_ptr = [0,0,0,0,0]$,\n    - $col\\_idx = []$,\n    - $data = []$.\n- Test case $4$ (single-row overlap and disjointness):\n  - $A$: shape $m \\times n$ with $m=1$, $n=3$,\n    - $row\\_ptr = [0,1]$,\n    - $col\\_idx = [1]$,\n    - $data = [5]$.\n  - $B$: shape $p \\times n$ with $p=2$, $n=3$,\n    - $row\\_ptr = [0,1,2]$,\n    - $col\\_idx = [1,2]$,\n    - $data = [6,7]$.\n- Test case $5$ (mixture of empty and nonempty rows):\n  - $A$: shape $m \\times n$ with $m=3$, $n=6$,\n    - $row\\_ptr = [0,0,3,5]$,\n    - $col\\_idx = [1,3,5,0,3]$,\n    - $data = [2,1,4,3,2]$.\n  - $B$: shape $p \\times n$ with $p=4$, $n=6$,\n    - $row\\_ptr = [0,2,4,5,5]$,\n    - $col\\_idx = [0,2,1,5,3]$,\n    - $data = [1,5,2,3,4]$.\n\nYour program must hard-code the above test suite and compute the corresponding results. The final output format must be exactly a single line containing a bracketed, comma-separated list of the results for the test cases, with no whitespace, where each result is a list of $[i,j,v]$ triplets as specified.", "solution": "The user-provided problem is assessed as valid. It is a well-posed, scientifically grounded problem in the domain of computational linear algebra and data structures, with a clear objective and sufficient data.\n\n### Principle-Based Solution Design\n\nThe problem requires the computation of the matrix product $C = A B^T$, where $A$ and $B$ are sparse matrices stored in the Compressed Sparse Row (CSR) format. The matrix $A$ has dimensions $m \\times n$ and $B$ has dimensions $p \\times n$. Consequently, the transpose $B^T$ has dimensions $n \\times p$, and the resulting matrix $C$ has dimensions $m \\times p$.\n\nThe fundamental definition of the element $C_{i,j}$ (at row $i$ and column $j$) of the product matrix $C$ is given by the dot product of the $i$-th row of $A$ and the $j$-th column of $B^T$.\n$$\nC_{i,j} = (\\text{row } i \\text{ of } A) \\cdot (\\text{column } j \\text{ of } B^T)\n$$\nA crucial observation is that the $j$-th column of $B^T$ is identical to the $j$-th row of $B$. Therefore, the expression for $C_{i,j}$ can be rewritten as the dot product of the $i$-th row of $A$ and the $j$-th row of $B$:\n$$\nC_{i,j} = \\sum_{k=0}^{n-1} A_{i,k} \\cdot (B^T)_{k,j} = \\sum_{k=0}^{n-1} A_{i,k} \\cdot B_{j,k}\n$$\nThis formulation allows us to compute each element of $C$ by directly using the rows of $A$ and $B$ as provided in their CSR format, without needing to explicitly construct $B^T$ or convert $B$ to a column-oriented format like Compressed Sparse Column (CSC), thus satisfying a key constraint of the problem.\n\nThe CSR format for a matrix consists of three arrays: $row\\_ptr$, $col\\_idx$, and $data$.\n-   The $row\\_ptr$ array, of length $m+1$, indicates the start and end of each row's data in the other two arrays. The nonzero elements of row $i$ are located from index $row\\_ptr[i]$ (inclusive) to $row\\_ptr[i+1]$ (exclusive).\n-   The $col\\_idx$ array stores the column indices of the nonzero elements.\n-   The $data$ array stores the corresponding values of the nonzero elements.\nA critical property of the CSR format given in the problem is that for any given row, the column indices in $col\\_idx$ are sorted in strictly increasing order.\n\nOur algorithm will compute the matrix $C$ by iterating through each of its potential nonzero entries. This involves a nested loop structure: an outer loop for the row index $i$ of $C$ (from $0$ to $m-1$), and an inner loop for the column index $j$ of $C$ (from $0$ to $p-1$).\n\nFor each pair of indices $(i, j)$, we compute $C_{i,j}$ by taking the dot product of row $i$ of $A$ and row $j$ of $B$. Since these rows are sparse, the sum $\\sum_{k=0}^{n-1} A_{i,k} B_{j,k}$ will have nonzero terms only for column indices $k$ where both $A_{i,k}$ and $B_{j,k}$ are nonzero. This is equivalent to finding the intersection of the sets of column indices of nonzero elements for the two rows.\n\nGiven that the column indices for each row are sorted, we can find this intersection and compute the dot product efficiently using a **two-pointer merge algorithm**.\nLet's denote the sparse representation of row $i$ of $A$ as $(A\\_cols_i, A\\_vals_i)$ and row $j$ of $B$ as $(B\\_cols_j, B\\_vals_j)$.\n\nThe two-pointer algorithm proceeds as follows:\n1.  Initialize two pointers, $ptr_A$ for $A\\_cols_i$ and $ptr_B$ for $B\\_cols_j$, both starting at the beginning of their respective slices.\n2.  Initialize a variable $dot\\_product$ to $0$.\n3.  Iterate while both pointers are within the bounds of their respective index lists:\n    -   If $A\\_cols_i[ptr_A] = B\\_cols_j[ptr_B]$: A common column index $k$ has been found. The product of the corresponding values is added to the total: $dot\\_product += A\\_vals_i[ptr_A] \\times B\\_vals_j[ptr_B]$. Both pointers are advanced to consider the next elements.\n    -   If $A\\_cols_i[ptr_A]  B\\_cols_j[ptr_B]$: The column index in $A$'s row is smaller. It cannot match the current or any subsequent column index in $B$'s row (due to sorted order). Thus, we advance $ptr_A$.\n    -   If $A\\_cols_i[ptr_A]  B\\_cols_j[ptr_B]$: The column index in $B$'s row is smaller. By symmetric reasoning, we advance $ptr_B$.\n4.  The loop terminates when one of the pointers goes past the end of its list. The final value of $dot\\_product$ is $C_{i,j}$.\n\nAfter computing the dot product for a given $(i, j)$, if the result is nonzero, the triplet $[i, j, dot\\_product]$ is recorded. Since the loops iterate through $i$ from $0$ to $m-1$ and $j$ from $0$ to $p-1$, the resulting list of triplets will be naturally sorted in lexicographic order as required. The final output is then formatted according to the specifications.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_ab_transpose(A_csr, B_csr, m, p):\n    \"\"\"\n    Computes the product C = A * B^T for sparse matrices A and B in CSR format.\n    \n    Args:\n        A_csr (tuple): CSR representation of A (row_ptr, col_idx, data).\n        B_csr (tuple): CSR representation of B (row_ptr, col_idx, data).\n        m (int): Number of rows in A.\n        p (int): Number of rows in B.\n\n    Returns:\n        list: A list of triplets [i, j, v] for the nonzero entries of C.\n    \"\"\"\n    A_row_ptr, A_col_idx, A_data = A_csr\n    B_row_ptr, B_col_idx, B_data = B_csr\n    \n    result_triplets = []\n\n    for i in range(m):\n        for j in range(p):\n            dot_product = 0\n            \n            ptr_A = A_row_ptr[i]\n            end_A = A_row_ptr[i+1]\n            \n            ptr_B = B_row_ptr[j]\n            end_B = B_row_ptr[j+1]\n            \n            # Two-pointer merge to compute dot product of A's row i and B's row j\n            while ptr_A  end_A and ptr_B  end_B:\n                col_A = A_col_idx[ptr_A]\n                col_B = B_col_idx[ptr_B]\n                \n                if col_A == col_B:\n                    # Common column index found, multiply values\n                    dot_product += A_data[ptr_A] * B_data[ptr_B]\n                    ptr_A += 1\n                    ptr_B += 1\n                elif col_A  col_B:\n                    ptr_A += 1\n                else:  # col_A  col_B\n                    ptr_B += 1\n            \n            # If the dot product is non-zero, add it to the result list\n            if dot_product != 0:\n                result_triplets.append([i, j, int(dot_product)])\n                \n    return result_triplets\n\ndef solve():\n    \"\"\"\n    Runs the defined test suite for sparse matrix multiplication C = A * B^T.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general case)\n        {\n            \"A\": {\"m\": 3, \"n\": 5, \"csr\": ([0, 2, 4, 6], [0, 3, 1, 2, 2, 4], [1, 2, 3, 4, 5, 6])},\n            \"B\": {\"p\": 2, \"n\": 5, \"csr\": ([0, 3, 6], [0, 2, 3, 1, 3, 4], [7, 8, 9, 10, 11, 12])}\n        },\n        # Test case 2 (all-zero A)\n        {\n            \"A\": {\"m\": 2, \"n\": 4, \"csr\": ([0, 0, 0], [], [])},\n            \"B\": {\"p\": 3, \"n\": 4, \"csr\": ([0, 1, 2, 4], [1, 2, 0, 3], [1, 2, 3, 4])}\n        },\n        # Test case 3 (all-zero B)\n        {\n            \"A\": {\"m\": 2, \"n\": 5, \"csr\": ([0, 2, 3], [0, 2, 1], [2, 3, 4])},\n            \"B\": {\"p\": 4, \"n\": 5, \"csr\": ([0, 0, 0, 0, 0], [], [])}\n        },\n        # Test case 4 (single-row overlap and disjointness)\n        {\n            \"A\": {\"m\": 1, \"n\": 3, \"csr\": ([0, 1], [1], [5])},\n            \"B\": {\"p\": 2, \"n\": 3, \"csr\": ([0, 1, 2], [1, 2], [6, 7])}\n        },\n        # Test case 5 (mixture of empty and nonempty rows)\n        {\n            \"A\": {\"m\": 3, \"n\": 6, \"csr\": ([0, 0, 3, 5], [1, 3, 5, 0, 3], [2, 1, 4, 3, 2])},\n            \"B\": {\"p\": 4, \"n\": 6, \"csr\": ([0, 2, 4, 5, 5], [0, 2, 1, 5, 3], [1, 5, 2, 3, 4])}\n        }\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        m = case[\"A\"][\"m\"]\n        p = case[\"B\"][\"p\"]\n        \n        # Convert lists to numpy arrays for potential minor performance gains if needed\n        # and to match the style of other problems, though not strictly necessary here.\n        A_csr = (np.array(case[\"A\"][\"csr\"][0]), np.array(case[\"A\"][\"csr\"][1]), np.array(case[\"A\"][\"csr\"][2]))\n        B_csr = (np.array(case[\"B\"][\"csr\"][0]), np.array(case[\"B\"][\"csr\"][1]), np.array(case[\"B\"][\"csr\"][2]))\n        \n        result = compute_ab_transpose(A_csr, B_csr, m, p)\n        \n        # Format the list of triplets into a string with no whitespace\n        results_as_strings.append(str(result).replace(\" \", \"\"))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n\n```", "id": "3273053"}]}