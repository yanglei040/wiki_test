{"hands_on_practices": [{"introduction": "Mastering the $d$-ary heap begins with a solid understanding of its fundamental structure: the heap property. This exercise [@problem_id:3225698] challenges you to formalize this understanding into an efficient algorithm. By analyzing different approaches, you will sharpen your grasp of the crucial parent-child index arithmetic in the array-based representation, a foundational skill for any heap-related implementation.", "problem": "You are given an array $A$ of length $n$ (using $0$-based indexing) and an integer branching factor $d \\ge 2$. In the standard array representation of a complete $d$-ary tree, a $d$-ary max-heap is defined by the property that the key at each node is greater than or equal to the keys at each of its children. The task is to decide, in $O(n)$ time, whether $A$ encodes a valid $d$-ary max-heap under this representation.\n\nFrom first principles, use the following foundational facts:\n- A complete $d$-ary tree can be represented in an array by listing nodes in level order, so that parent-child relationships are determined solely by index arithmetic.\n- The heap property is local: each parent must satisfy the ordering constraint relative to its children.\n- Counting arguments over the tree structure (such as the number of edges and the number of internal nodes) can be used to derive tight bounds on the number of comparisons required.\n\nWhich option correctly specifies an algorithm that verifies the heap property for all applicable parent-child pairs and runs in $O(n)$ time, given $A$ and $d$?\n\nA. Iterate $i$ from $0$ to $\\left\\lfloor \\dfrac{n - 2}{d} \\right\\rfloor$. For each $i$, iterate $j$ from $d i + 1$ up to $\\min(d i + d, n - 1)$. If $A[i] < A[j]$ for any such $j$, return $\\text{false}$; otherwise continue. If all checks pass, return $\\text{true}$. Time complexity: $O(n)$.\n\nB. For every internal node $i$, compute the maximum value in its entire subtree and verify $A[i] \\ge \\max\\{A[j] : j \\text{ in the subtree rooted at } i\\}$. If any check fails, return $\\text{false}$; otherwise return $\\text{true}$. Time complexity: $O(n)$, because each subtree is scanned once per parent.\n\nC. Iterate $j$ from $1$ to $n - 1$ and check $A\\!\\left[\\left\\lceil \\dfrac{j}{d} \\right\\rceil\\right] \\ge A[j]$ for every $j$. If any check fails, return $\\text{false}$; otherwise return $\\text{true}$. Time complexity: $O(n)$.\n\nD. Iterate $i$ from $0$ to $\\left\\lfloor \\dfrac{n}{d} \\right\\rfloor$. For each $i$, iterate $j$ from $d i$ up to $\\min(d i + d - 1, n - 1)$ and check $A[i] \\ge A[j]$. If any check fails, return $\\text{false}$; otherwise return $\\text{true}$. Time complexity: $O(n)$.", "solution": "The problem asks for an algorithm that runs in $O(n)$ time to determine if a given array $A$ of length $n$ represents a valid $d$-ary max-heap, using $0$-based indexing.\n\n### Step 1: Extract Givens\n-   An array $A$ of length $n$.\n-   $0$-based indexing is used for the array.\n-   An integer branching factor $d \\ge 2$.\n-   The array represents a complete $d$-ary tree.\n-   A $d$-ary max-heap property: The key at each node is greater than or equal to the keys at each of its children.\n-   The algorithm must run in $O(n)$ time.\n\n### Step 2: Validate Problem Statement\nThe problem statement is well-defined and grounded in standard computer science principles regarding data structures. A complete $d$-ary tree's array representation is a standard concept where nodes are stored level-by-level. The relationships between parent and child indices can be mathematically derived. The task is to verify the local heap property for all parent-child pairs. This is a clear, objective, and solvable problem. The time complexity constraint of $O(n)$ is a key part of the question. The problem is valid.\n\n### Step 3: Derivation from First Principles\n\nTo verify that the array $A$ represents a valid $d$-ary max-heap, we must check that for every parent node $i$, the condition $A[i] \\ge A[j]$ holds for all of its children $j$.\n\nFirst, we must establish the index mapping between parents and children for a $0$-based array representation of a complete $d$-ary tree.\n- The root of the tree is at index $0$.\n- The children of the node at index $0$ are at indices $1, 2, \\dots, d$.\n- The children of the node at index $1$ are at indices $d+1, \\dots, 2d$.\n- In general, for a node at index $i$, its children are located at indices from $d \\cdot i + 1$ to $d \\cdot i + d$.\n\nConversely, for a node at index $j$ (where $j > 0$), its parent is located at index $p$. The children of $p$ are $d \\cdot p + 1, \\dots, d \\cdot p + d$. The index $j$ must fall in this range. Thus, $d \\cdot p + 1 \\le j \\le d \\cdot p + d$. This implies $d \\cdot p \\le j - 1  d \\cdot p + d$. Dividing by $d$ gives $p \\le \\frac{j-1}{d}  p+1$. Therefore, the parent index is $p = \\left\\lfloor \\frac{j-1}{d} \\right\\rfloor$.\n\nTo verify the heap property, we must check $A[\\text{parent}] \\ge A[\\text{child}]$ for all child nodes. This is equivalent to checking $A[\\text{parent}] \\ge A[\\text{child}]$ for all parent nodes and all of their respective children. Let's pursue the latter approach, as it is presented in most of the options.\n\nThe algorithm must iterate through all nodes that are parents. A node $i$ is a parent if its first child, at index $d \\cdot i + 1$, is within the array bounds. That is, $d \\cdot i + 1  n$.\n$d \\cdot i  n - 1$\n$i  \\frac{n-1}{d}$\nSince $i$ must be an integer, the largest possible index for a parent node is $\\left\\lfloor \\frac{n-2}{d} \\right\\rfloor$. Let's verify this. The last element in the array is at index $n-1$. Its parent is at index $\\left\\lfloor \\frac{(n-1)-1}{d} \\right\\rfloor = \\left\\lfloor \\frac{n-2}{d} \\right\\rfloor$. Any node at an index greater than this cannot be a parent to any node within the array. Thus, we only need to check nodes $i$ in the range $0 \\le i \\le \\left\\lfloor \\frac{n-2}{d} \\right\\rfloor$.\n\nFor each parent node $i$, we must check it against all its children. The children of $i$ are at indices $j$ from $d \\cdot i + 1$ to $d \\cdot i + d$. However, not all these children might exist if the tree is not full. The array has length $n$, so indices only go up to $n-1$. Therefore, for each parent $i$, we must iterate through its children $j$ such that $d \\cdot i + 1 \\le j \\le d \\cdot i + d$ and $j  n$. This inner loop for children $j$ can be written as iterating from $d \\cdot i + 1$ up to $\\min(d \\cdot i + d, n-1)$.\n\nThe resulting algorithm is as follows:\n1.  Iterate with index $i$ from $0$ to $\\left\\lfloor \\frac{n-2}{d} \\right\\rfloor$.\n2.  For each $i$, iterate with index $j$ from $d \\cdot i + 1$ to $\\min(d \\cdot i + d, n-1)$.\n3.  In the inner loop, check if $A[i]  A[j]$. If this condition is true, the max-heap property is violated, and the algorithm can terminate and return `false`.\n4.  If the loops complete without finding any violation, the array is a valid max-heap, and the algorithm returns `true`.\n\nLet's analyze the time complexity. The total number of comparisons performed is equal to the number of parent-child relationships (edges) in the tree structure represented by the first $n$ nodes. A tree with $n$ nodes has $n-1$ edges. Each non-root node (indices $1$ to $n-1$) has exactly one parent. The algorithm performs exactly one comparison for each of these $n-1$ nodes against its parent. Therefore, the total number of comparisons is $n-1$. The overall time complexity is $O(n)$.\n\nNow we evaluate the given options.\n\n### Option-by-Option Analysis\n\nA. Iterate $i$ from $0$ to $\\left\\lfloor \\dfrac{n - 2}{d} \\right\\rfloor$. For each $i$, iterate $j$ from $d i + 1$ up to $\\min(d i + d, n - 1)$. If $A[i]  A[j]$ for any such $j$, return $\\text{false}$; otherwise continue. If all checks pass, return $\\text{true}$. Time complexity: $O(n)$.\n-   **Parent Loop:** The range for $i$, from $0$ to $\\left\\lfloor \\frac{n-2}{d} \\right\\rfloor$, correctly identifies all parent nodes in the heap.\n-   **Child Loop:** The range for $j$, from $d i + 1$ to $\\min(d i + d, n-1)$, correctly identifies all children of node $i$ that exist within the array of size $n$. Let's ensure the upper bound $\\min(di+d, n-1)$ is correct for an inclusive loop. The children's indices are up to $di+d$. The array indices are up to $n-1$. If $di+d > n-1$, the last potential child is outside the array. So the last actual child index is $n-1$. If $di+d \\le n-1$, the last child is at $di+d$. So the last index to check is $\\min(di+d, n-1)$. Wait, the children are `di+1, ..., di+d`. The maximum index is `di+d`. If `di+d  n`, we check up to `di+d`. If `di+d >= n`, we check up to `n-1`. The upper bound of the loop should be inclusive, so it should run up to `min(di+d, n-1)`. No, `min(di+d, n)-1`... Let's re-verify. Let's say loop is `for j in range(start, end)`. The range is `min d*i+d` (children of i) and `n` (array size). So `j` goes from `d*i+1` up to, but not including, `min(d*i+d+1, n)`. Or an inclusive loop up to `min(d*i+d, n-1)`. Let's test `n=10, d=3`. `i=2`. Children are `7,8,9`. Array indices `0..9`. `d*i+1=7`. `min(d*i+d, n-1) = min(9,9) = 9$. The loop `j` from 7 to 9 is correct. Let's test `n=9, d=3`. `i=2`. Children are `7,8`. Array indices `0..8`. `d*i+1=7`. `min(d*i+d, n-1) = min(9,8)=8`. Loop `j` from `7` to `8` is correct. The loop bounds are correct.\n-   **Condition:** $A[i]  A[j]$ correctly checks for a violation of the max-heap property.\n-   **Complexity:** The analysis shows the algorithm performs $n-1$ comparisons, so the time complexity is indeed $O(n)$.\n-   **Verdict:** **Correct**.\n\nB. For every internal node $i$, compute the maximum value in its entire subtree and verify $A[i] \\ge \\max\\{A[j] : j \\text{ in the subtree rooted at } i\\}$. If any check fails, return $\\text{false}$; otherwise return $\\text{true}$. Time complexity: $O(n)$, because each subtree is scanned once per parent.\n-   **Algorithm Logic:** Verifying that a parent is greater than or equal to all nodes in its subtree is a valid, albeit stronger, way to confirm the heap property. If the local property holds, this global property holds by transitivity.\n-   **Complexity Analysis:** The justification for the $O(n)$ complexity is flawed. To check the root node ($i=0$), one must scan its entire subtree, which comprises all $n$ nodes (or $n-1$ other nodes). This takes $O(n)$ time. To check a node at level $1$, one must scan its subtree, which has size approximately $n/d$. There are $d$ such nodes, contributing $d \\times O(n/d) = O(n)$ to the total work for that level. Since there are about $\\log_d n$ levels of internal nodes, the total complexity is roughly $\\sum_{k=0}^{\\log_d n} O(n) = O(n \\log_d n)$. A node at depth $k$ is part of $k+1$ subtrees (its own and those of its ancestors). The total work is $\\sum_{j=0}^{n-1} (\\text{depth of } j)$, which is known to be $O(n \\log n)$ for a complete tree. The claim of $O(n)$ is false.\n-   **Verdict:** **Incorrect**. The algorithm works, but the time complexity is $O(n \\log n)$, not $O(n)$ as claimed.\n\nC. Iterate $j$ from $1$ to $n - 1$ and check $A\\!\\left[\\left\\lceil \\dfrac{j}{d} \\right\\rceil\\right] \\ge A[j]$ for every $j$. If any check fails, return $\\text{false}$; otherwise return $\\text{true}$. Time complexity: $O(n)$.\n-   **Algorithm Logic:** This approach iterates through each child and checks it against its parent. This is a valid strategy. The time complexity is clearly $O(n)$ as the loop runs $n-1$ times with $O(1)$ work inside.\n-   **Parent Formula:** The critical element is the formula for the parent's index: $\\left\\lceil \\frac{j}{d} \\right\\rceil$. This formula is for a $1$-based indexing scheme. For the problem's specified $0$-based indexing, the parent of node $j$ is $\\left\\lfloor \\frac{j-1}{d} \\right\\rfloor$. Let's test the given formula with $d=2$ and $j=2$ (the second child of the root). The correct parent index is $0$. The formula gives $\\lceil \\frac{2}{2} \\rceil = 1$. This is incorrect. The algorithm will compare nodes that are not in a parent-child relationship.\n-   **Verdict:** **Incorrect**. The formula used to find the parent index is wrong for $0$-based indexing.\n\nD. Iterate $i$ from $0$ to $\\left\\lfloor \\dfrac{n}{d} \\right\\rfloor$. For each $i$, iterate $j$ from $d i$ up to $\\min(d i + d - 1, n - 1)$ and check $A[i] \\ge A[j]$. If any check fails, return $\\text{false}$; otherwise return $\\text{true}$. Time complexity: $O(n)$.\n-   **Parent Loop:** The upper bound for parent `i` is given as $\\left\\lfloor \\frac{n}{d} \\right\\rfloor$. This is not the same as the correct bound of $\\left\\lfloor \\frac{n-2}{d} \\right\\rfloor$. While it will cover all parents, it might include some non-parent nodes depending on the values of $n$ and $d$.\n-   **Child Loop:** The starting index for children $j$ is given as $di$. The first child of node $i$ is at index $di+1$. The index $di$ is another node altogether (often a \"cousin\" or \"uncle\" in the tree). For $i>0$, the node $di$ is the last child of node $i-1$. The algorithm would erroneously check if $A[i] \\ge A[di]$, which is not a requirement of the heap property. For example, if $d=2$, $A = [100, 20, 90, \\dots]$. Heap property for root is satisfied ($100 \\ge 20, 100 \\ge 90$). Node $i=1$ (value $20$) has children starting at index $2(1)+1=3$. The algorithm would check $A[1] \\ge A[2]$, which is $20 \\ge 90$, and falsely report a violation.\n-   **Verdict:** **Incorrect**. The algorithm checks incorrect pairs of nodes because the inner loop for children starts at the wrong index.\n\nBased on the analysis, only option A correctly describes a valid algorithm with the proper time complexity.", "answer": "$$\\boxed{A}$$", "id": "3225698"}, {"introduction": "Moving from theory to practice is a critical step in becoming a proficient programmer. This hands-on coding challenge [@problem_id:3225715] asks you to implement the verification logic you explored previously. Your task is to write a program that can determine, for a given array, all possible arities $d$ for which it forms a valid max-heap, reinforcing your understanding of how the heap's structure is a function of both the data and the branching factor.", "problem": "You are given several finite sequences of distinct integers. Each sequence represents a permutation and is to be interpreted as the level-order serialization of a rooted tree for a $d$-ary heap, where $d$ is an integer with $d > 1$. A $d$-ary heap is a rooted tree in which each node has at most $d$ children, and the max-heap property requires that for every node, its key is greater than or equal to the keys of all of its children. We work with the standard array representation of a $d$-ary heap using $0$-based indexing: for a node at index $i$, its children occupy indices from $d i + 1$ up to $d i + d$, as long as these indices are within the bounds of the array.\n\nStarting from the foundational definitions of rooted trees, level-order serialization, and the max-heap property, determine, for each given sequence $A$ of length $n$, the set of all integers $d$ such that $2 \\le d \\le n$ and interpreting $A$ as a $d$-ary heap in level-order satisfies the max-heap property throughout the entire tree. The interpretation must use the parent-child relation defined by indices: for each index $i$ with $0 \\le i \\le n-1$, the children indices are $j \\in \\{d i + 1, d i + 2, \\dots, d i + d\\}$ with $j  n$, and the max-heap property requires $A[i] \\ge A[j]$ for all such $j$.\n\nYour program must process the following test suite of sequences, each of which is a permutation of $\\{1,2,\\dots,n\\}$ for its respective $n$:\n\n- Test case 1: $[1, 2, 3, 4, 5, 6, 7]$\n- Test case 2: $[7, 6, 5, 4, 3, 2, 1]$\n- Test case 3: $[9, 1, 8, 7, 2, 3, 4, 5, 6]$\n- Test case 4: $[9, 7, 8, 3, 5, 6, 2, 1, 4]$\n- Test case 5: $[2, 1]$\n- Test case 6: $[8, 5, 7, 4, 6, 3, 2, 1]$\n\nFor each test case, you must return the list of all integers $d$ with $2 \\le d \\le n$ such that the sequence is a valid max $d$-ary heap under the array-to-tree interpretation described above. If no such $d$ exists, return the empty list.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a list of integers without spaces, in ascending order for each test case (e.g., `[[2,3],[],[5]]`). Concretely, the printed format must be a single line like `[[2,3],[],[5]]` for three test cases.\n\nNo physical units or angle units apply. All answers are integer lists as specified. The input is fixed; do not read from standard input.", "solution": "The problem requires us to determine, for a given sequence of integers $A$ of length $n$, the set of all integers $d$ within the range $2 \\le d \\le n$ for which $A$ constitutes a valid max $d$-ary heap. The validation must adhere to the specific parent-child indexing relationship provided.\n\nLet us begin from first principles. A sequence $A$ is interpreted as the level-order serialization of a rooted tree. In the standard array representation of a $d$-ary heap with $0$-based indexing, a node at index $i$ has its children located at indices $di+1, di+2, \\dots, di+d$. A child at index $j$ is part of the tree structure only if its index is within the bounds of the array, i.e., $j  n$.\n\nThe max-heap property dictates that for any node in the tree, its key must be greater than or equal to the keys of all its children. Translating this to the array representation, for any parent node at index $i$, and for any of its children at a valid index $j$, the condition $A[i] \\ge A[j]$ must be satisfied.\n\nTo solve the problem, we must construct an algorithm that verifies this property for a given sequence $A$ and a given arity $d$. A systematic approach is to iterate through all nodes that could be parents and check the heap property against all their existing children.\n\nFirst, we must identify which nodes in the array can be parents. A node at index $i$ is a parent if it has at least one child within the array bounds. The index of the first child of node $i$ is $di+1$. For this child to exist, we require $di+1  n$. This inequality can be rearranged to $di  n-1$, which implies $i  (n-1)/d$. Since indices must be integers, the largest possible index for a parent node is $\\lfloor (n-2)/d \\rfloor$. Therefore, we only need to check the heap property for nodes with indices $i$ in the range $0 \\le i \\le \\lfloor (n-2)/d \\rfloor$. Nodes with indices greater than this are guaranteed to be leaves, as their first potential child would lie at or beyond index $n$.\n\nThis leads to a direct verification algorithm, let us call it `is_valid_heap(A, d)`. This function will iterate through all potential parent indices $i$ from $0$ to $\\lfloor (n-2)/d \\rfloor$. For each parent $i$, it will then iterate through its potential children. The indices of the children of node $i$ are given by $j = di+k$ for $k=1, 2, \\dots, d$. For each potential child index $j$, we first check if it is within the array bounds ($j  n$). If it is, we then verify the max-heap condition: $A[i] \\ge A[j]$. If at any point we find a pair $(i, j)$ such that $A[i]  A[j]$, the max-heap property is violated, and the sequence $A$ is not a valid max $d$-ary heap. In this case, our function can immediately return `False`. If the loops complete without finding any such violation, it means the property holds for all parent-child pairs, and the function correctly returns `True`. If the array has length $n \\le 1$, it is trivially a valid heap for any $d$, as there are no parent-child relationships to check.\n\nThe main problem is to find all valid values of $d$ for each given sequence $A$. We can achieve this by iterating through every integer $d$ in the specified range, $2 \\le d \\le n$. For each $d$, we invoke our verification function `is_valid_heap(A, d)`. If it returns `True`, we add $d$ to a list of valid arities for sequence $A$. After checking all possible values of $d$, this list will contain the complete solution for that sequence.\n\nThis procedure is repeated for each test case sequence provided in the problem statement. The final output is an aggregation of these results into a single formatted list.\n\nThe overall algorithm is as follows:\n1. For each input sequence $A$:\n2. Let $n$ be the length of $A$.\n3. Initialize an empty list, `valid_ds`, to store the valid arities.\n4. For each integer $d$ from $2$ to $n$ (inclusive):\n5.  a. Assume $A$ is a valid max $d$-ary heap (set a flag, e.g., `is_heap = True`).\n6.  b. Iterate through each potential parent index $i$ from $0$ to $\\lfloor (n-2)/d \\rfloor$.\n7.  c. For each parent $i$, iterate through its child indices $j = di+k$ where $k=1, 2, \\dots, d$.\n8.  d. If a child index $j$ is out of bounds ($j \\ge n$), we can break the inner loop over $k$ since subsequent child indices will also be out of bounds.\n9.  e. If $j  n$ and $A[i]  A[j]$, the heap property is violated. Set `is_heap = False` and break from all loops for the current $d$.\n10. f. After checking all parents for the current $d$, if `is_heap` is still `True`, append $d$ to `valid_ds`.\n11. After iterating through all $d$, the list `valid_ds` contains the result for sequence $A$.\n12. Collect the `valid_ds` lists from all test cases and format them according to the output specification.\nThis method is exhaustive and guarantees correctness by directly checking the definition of a max $d$-ary heap for every possibility.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the d-ary heap problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        [1, 2, 3, 4, 5, 6, 7],\n        [7, 6, 5, 4, 3, 2, 1],\n        [9, 1, 8, 7, 2, 3, 4, 5, 6],\n        [9, 7, 8, 3, 5, 6, 2, 1, 4],\n        [2, 1],\n        [8, 5, 7, 4, 6, 3, 2, 1],\n    ]\n\n    def is_d_ary_max_heap(A, d):\n        \"\"\"\n        Checks if a sequence A represents a valid max d-ary heap.\n\n        Args:\n            A (list): The sequence of integers.\n            d (int): The arity to check.\n\n        Returns:\n            bool: True if A is a valid max d-ary heap, False otherwise.\n        \"\"\"\n        n = len(A)\n        if n = 1:\n            return True\n\n        # The last parent node is at index floor((n-2)/d).\n        # We need to iterate i from 0 up to and including this index.\n        # The range is thus 0 to floor((n-2)/d) + 1.\n        num_parents = (n - 2) // d + 1\n\n        for i in range(num_parents):\n            parent_val = A[i]\n            \n            # Iterate through children\n            for k in range(1, d + 1):\n                child_idx = d * i + k\n                \n                if child_idx  n:\n                    child_val = A[child_idx]\n                    if parent_val  child_val:\n                        return False\n                else:\n                    # Since child indices are consecutive, if one is out of bounds,\n                    # the rest will be too. We can break the inner loop.\n                    break\n        \n        return True\n\n    all_results = []\n    for A in test_cases:\n        n = len(A)\n        valid_ds = []\n        # Per the problem, d must be an integer with d > 1.\n        # The search space is given as 2 = d = n.\n        if n > 1:\n            for d in range(2, n + 1):\n                if is_d_ary_max_heap(A, d):\n                    valid_ds.append(d)\n        all_results.append(valid_ds)\n\n    # Format the output string exactly as required, without spaces.\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3225715"}, {"introduction": "The true power of the $d$-ary heap lies in its flexibility, but this raises a critical engineering question: what is the optimal branching factor $d$? This final practice [@problem_id:3225717] dives into performance analysis, asking you to model the costs of heap operations. By finding the $d$ that minimizes cost for a given workload, you will gain insight into the fundamental trade-off between reducing heap height and increasing the work done at each node, a key concept in algorithm design.", "problem": "You are to design and implement a complete, runnable program that, given a set of machine-specific cost parameters and workload weights, selects the arity $d$ of a $d$-ary heap that minimizes a worst-case, primitive-operation cost model. The goal is to emulate an empirical study in a controlled, reproducible way by using a principled cost model that abstracts the effects of the Central Processing Unit (CPU), cache hierarchy, and Random Access Memory (RAM) bandwidth into primitive operation costs. Your program must not perform any timing measurements; instead, it must use a derived analytic model grounded in standard definitions to compute the minimizing $d$.\n\nFundamental base to use:\n- A $d$-ary heap is a complete tree stored in an array in level order. The height is the smallest integer $L$ such that a tree with branching factor $d$ and height $L$ can hold at least $n$ nodes. Equivalently, $L$ is the minimal integer satisfying $d^{L} \\ge n$, which implies $L = \\lceil \\log_{d} n \\rceil$ for $n \\ge 1$.\n- The parent of a node at index $i$ (using zero-based indexing) is at index $\\left\\lfloor \\dfrac{i-1}{d} \\right\\rfloor$, and its children are at indices $d\\cdot i + j$ for $j \\in \\{1,2,\\dots,d\\}$ when those indices exist within the array.\n- Operation semantics for the standard priority queue built from a $d$-ary min-heap:\n  - Decrease-key and insert both potentially move a key upward by repeatedly comparing with its parent and swapping until the heap property is restored. In the worst case, the number of upward moves equals the height $L$.\n  - Extract-min removes the root, swaps in a last element, and then restores the heap by repeatedly selecting the smallest child among up to $d$ children and swapping downward until the heap property is restored. In the worst case, the number of downward moves equals the height $L$.\n\nCost model to use:\n- Count only two primitive costs:\n  - $c_{c}$: the cost per key comparison.\n  - $c_{s}$: the cost per swap of two keys (treat a swap as a single primitive with this cost; internal assignments and memory traffic are abstracted into $c_{s}$).\n- Worst-case primitive counts per operation, justified by the operation semantics:\n  - Insert and decrease-key: at most $L$ levels traversed upward, performing at most $L$ comparisons and $L$ swaps.\n  - Extract-min: one fixed swap to remove the root and place the last element at the root, plus at most $L$ levels traversed downward. At each level, selecting the smallest child among up to $d$ children performs at most $d-1$ comparisons, followed by one swap to move the hole downward.\n- Workload model:\n  - Let $w_{\\mathrm{ex}}$, $w_{\\mathrm{in}}$, and $w_{\\mathrm{dec}}$ be nonnegative weights indicating the relative frequency of extract-min, insert, and decrease-key respectively. You may assume $w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}} > 0$.\n  - The worst-case weighted cost per operation for a given $d$ is the weighted sum of the corresponding primitive counts times primitive costs.\n\nTasks:\n- Using only the fundamental base above and worst-case reasoning, derive an expression for the worst-case weighted cost per operation as a function of $d$, $n$, $c_{c}$, $c_{s}$, $w_{\\mathrm{ex}}$, $w_{\\mathrm{in}}$, and $w_{\\mathrm{dec}}$. The derivation must proceed from the stated semantics. Do not assume any average-case behavior.\n- Implement a program that:\n  - For each test case, considers all integer $d$ in the inclusive range $[2, d_{\\max}]$.\n  - Computes the heap height $L(d,n) = \\lceil \\log_{d} n \\rceil$ with the convention that $L(d,1) = 0$.\n  - Computes the worst-case weighted cost for that $d$ using your derived counts and the provided primitive costs and weights.\n  - Selects the $d$ that minimizes this cost. In case of a tie, choose the smallest $d$.\n  - Outputs the selected $d$ for each test case.\n- Output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").\n\nTest suite:\n- Each test case is a tuple $(n, w_{\\mathrm{ex}}, w_{\\mathrm{in}}, w_{\\mathrm{dec}}, c_{c}, c_{s}, d_{\\max})$ with the following specific values. All numbers are exact and unitless.\n  - Case 1: $(n=1,\\, w_{\\mathrm{ex}}=1.0,\\, w_{\\mathrm{in}}=0.0,\\, w_{\\mathrm{dec}}=0.0,\\, c_{c}=5.0,\\, c_{s}=10.0,\\, d_{\\max}=16)$\n  - Case 2: $(n=1000000,\\, w_{\\mathrm{ex}}=0.6,\\, w_{\\mathrm{in}}=0.3,\\, w_{\\mathrm{dec}}=0.1,\\, c_{c}=3.0,\\, c_{s}=8.0,\\, d_{\\max}=32)$\n  - Case 3: $(n=1000000,\\, w_{\\mathrm{ex}}=0.8,\\, w_{\\mathrm{in}}=0.1,\\, w_{\\mathrm{dec}}=0.1,\\, c_{c}=50.0,\\, c_{s}=5.0,\\, d_{\\max}=16)$\n  - Case 4: $(n=5000000,\\, w_{\\mathrm{ex}}=0.2,\\, w_{\\mathrm{in}}=0.6,\\, w_{\\mathrm{dec}}=0.2,\\, c_{c}=2.0,\\, c_{s}=40.0,\\, d_{\\max}=64)$\n  - Case 5: $(n=1000,\\, w_{\\mathrm{ex}}=1.0,\\, w_{\\mathrm{in}}=0.0,\\, w_{\\mathrm{dec}}=0.0,\\, c_{c}=1.0,\\, c_{s}=1.0,\\, d_{\\max}=2)$\n\nAnswer specification:\n- Your program must compute the minimizing $d$ for each of the five cases above and print them in order as a single line in the exact specified format.", "solution": "The user has requested the design of a program to find the optimal arity $d$ for a $d$-ary heap that minimizes a worst-case operational cost model. The process begins with a formal validation of the problem statement, followed by the derivation of the cost function and its implementation.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n*   **Heap Structure**: A $d$-ary heap is a complete tree stored in an array.\n*   **Heap Height ($L$)**: $L = \\lceil \\log_{d} n \\rceil$ for $n \\ge 1$. A special convention is given: $L(d, 1) = 0$.\n*   **Parent/Child Indices (0-based)**: Parent of node $i$ is $\\lfloor(i-1)/d\\rfloor$. Children are $d \\cdot i + j$ for $j \\in \\{1, 2, \\dots, d\\}$.\n*   **Operation Semantics (Worst-Case)**:\n    *   `insert` / `decrease-key`: $L$ comparisons and $L$ swaps.\n    *   `extract-min`: $1$ fixed swap, plus $L$ downward steps. Each downward step involves at most $d-1$ comparisons and $1$ swap.\n*   **Cost Primitives**:\n    *   $c_c$: cost per key comparison.\n    *   $c_s$: cost per key swap.\n*   **Workload Model**:\n    *   $w_{\\mathrm{ex}}$, $w_{\\mathrm{in}}$, $w_{\\mathrm{dec}}$: nonnegative weights for `extract-min`, `insert`, and `decrease-key` operations, with $w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}} > 0$.\n*   **Objective**: For each test case, find the integer $d \\in [2, d_{\\max}]$ that minimizes the worst-case weighted cost. Ties are broken by choosing the smallest $d$.\n*   **Test Suite**: Five test cases are provided with specific values for $(n, w_{\\mathrm{ex}}, w_{\\mathrm{in}}, w_{\\mathrm{dec}}, c_{c}, c_{s}, d_{\\max})$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement is analyzed against the validation criteria.\n\n*   **Scientifically Grounded**: The problem is based on the standard and well-established data structure of a $d$-ary heap. The cost model is a common and valid abstraction used in algorithm analysis to model performance without direct machine timing. It is scientifically and algorithmically sound.\n*   **Well-Posed**: The problem is clearly defined. The objective is to find the minimum of a function over a finite, discrete domain of integers $d \\in [2, d_{\\max}]$. A minimum is guaranteed to exist. The tie-breaking rule (select the smallest $d$) ensures a unique solution.\n*   **Objective**: The language is precise and mathematical. All parameters and constraints are defined quantitatively.\n*   **Completeness and Consistency**: The problem provides all necessary data and definitions to derive the cost function and perform the required search. The convention for $n=1$ is explicitly stated, avoiding ambiguity. There are no contradictions.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is self-contained, scientifically grounded, well-posed, and all necessary information for its resolution is provided. The solution process may proceed.\n\n### Derivation of the Worst-Case Weighted Cost Function\n\nThe objective is to derive the total worst-case weighted cost per operation, denoted $C(d)$, as a function of the arity $d$ and the given parameters. This derivation follows directly from the primitive operation costs specified in the problem statement.\n\n1.  **Heap Height**: The height of the heap for $n$ elements and arity $d$ is given by $L(d, n) = \\lceil \\log_{d} n \\rceil$. For the special case $n=1$, $L(d, 1) = \\lceil \\log_{d} 1 \\rceil = \\lceil 0 \\rceil = 0$, which aligns with the provided convention.\n\n2.  **Cost of Individual Operations**: We determine the worst-case cost for each operation type by summing the costs of its constituent primitive operations (comparisons and swaps).\n\n    *   **Insert and Decrease-Key**: The problem states that in the worst case, an element moves up the entire height of the tree. This involves $L(d, n)$ levels. At each level, one comparison with the parent and one swap occurs.\n        The cost for an `insert` operation, $C_{\\mathrm{in}}(d)$, is:\n        $$C_{\\mathrm{in}}(d) = L(d, n) \\cdot c_c + L(d, n) \\cdot c_s = L(d, n) (c_c + c_s)$$\n        Similarly, the cost for a `decrease-key` operation, $C_{\\mathrm{dec}}(d)$, is:\n        $$C_{\\mathrm{dec}}(d) = L(d, n) \\cdot c_c + L(d, n) \\cdot c_s = L(d, n) (c_c + c_s)$$\n\n    *   **Extract-Min**: This operation consists of two phases. First, the root is replaced by the last element in the heap, costing one swap. Second, the new root element \"sifts down\" to restore the heap property. This downward traversal covers at most $L(d, n)$ levels. At each level, the element is compared with its up to $d$ children to find the minimum, which requires at most $d-1$ comparisons. Then, a single swap is performed with the minimum child.\n        The cost for an `extract-min` operation, $C_{\\mathrm{ex}}(d)$, is the sum of the initial swap and the sift-down process:\n        $$C_{\\mathrm{ex}}(d) = (1 \\cdot c_s) + L(d, n) \\cdot ((d-1) \\cdot c_c + 1 \\cdot c_s)$$\n        $$C_{\\mathrm{ex}}(d) = c_s + L(d, n) ((d-1)c_c + c_s)$$\n\n3.  **Total Weighted Cost Function**: The total worst-case weighted cost, $C(d)$, is the sum of the costs of each operation multiplied by their respective weights.\n    $$C(d) = w_{\\mathrm{ex}} \\cdot C_{\\mathrm{ex}}(d) + w_{\\mathrm{in}} \\cdot C_{\\mathrm{in}}(d) + w_{\\mathrm{dec}} \\cdot C_{\\mathrm{dec}}(d)$$\n    Substituting the expressions derived above:\n    $$ C(d) = w_{\\mathrm{ex}} \\left(c_s + L(d, n) ((d-1)c_c + c_s)\\right) + w_{\\mathrm{in}} \\left(L(d, n) (c_c + c_s)\\right) + w_{\\mathrm{dec}} \\left(L(d, n) (c_c + c_s)\\right) $$\n    We can factor out $L(d, n)$ to simplify the expression:\n    $$ C(d) = w_{\\mathrm{ex}} c_s + L(d, n) \\left[ w_{\\mathrm{ex}} ((d-1)c_c + c_s) + (w_{\\mathrm{in}} + w_{\\mathrm{dec}})(c_c + c_s) \\right] $$\n    Let's expand and group terms by $c_c$ and $c_s$ inside the brackets:\n    $$ \\left[ w_{\\mathrm{ex}}(d-1)c_c + w_{\\mathrm{ex}}c_s + (w_{\\mathrm{in}} + w_{\\mathrm{dec}})c_c + (w_{\\mathrm{in}} + w_{\\mathrm{dec}})c_s \\right] $$\n    $$ = c_c \\left( w_{\\mathrm{ex}}(d-1) + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) + c_s \\left( w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) $$\n    This yields the final analytic expression for the total worst-case weighted cost:\n    $$ C(d) = w_{\\mathrm{ex}} c_s + \\lceil \\log_{d} n \\rceil \\left[ c_c \\left( w_{\\mathrm{ex}}(d-1) + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) + c_s \\left( w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) \\right] $$\n    This function will be evaluated for each integer $d$ in the range $[2, d_{\\max}]$ to find the value of $d$ that minimizes $C(d)$. The `ceil` of the logarithm, $\\lceil \\log_{d} n \\rceil$, can be computed as `ceil(log(n) / log(d))` using any convenient logarithm base (e.g., natural logarithm).\n\n### Minimization Procedure\n\nFor each test case, we will iterate through all possible integer values of $d$ from $2$ to $d_{\\max}$, inclusive. In each iteration, we calculate the cost $C(d)$ using the derived formula. We maintain a record of the minimum cost found so far and the corresponding value of $d$. If a newly computed cost for a given $d$ is strictly less than the current minimum, we update the minimum cost and the optimal $d$. This process inherently respects the tie-breaking rule of choosing the smallest $d$, as smaller values of $d$ are evaluated first.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal arity 'd' for a d-ary heap for a given set of\n    test cases based on a worst-case operational cost model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (n, w_ex, w_in, w_dec, c_c, c_s, d_max)\n    test_cases = [\n        (1, 1.0, 0.0, 0.0, 5.0, 10.0, 16),\n        (1000000, 0.6, 0.3, 0.1, 3.0, 8.0, 32),\n        (1000000, 0.8, 0.1, 0.1, 50.0, 5.0, 16),\n        (5000000, 0.2, 0.6, 0.2, 2.0, 40.0, 64),\n        (1000, 1.0, 0.0, 0.0, 1.0, 1.0, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, w_ex, w_in, w_dec, c_c, c_s, d_max = case\n\n        min_cost = float('inf')\n        best_d = -1\n\n        # Iterate through all possible arities d from 2 to d_max (inclusive).\n        for d in range(2, d_max + 1):\n            # Calculate heap height L(d, n).\n            # L = ceil(log_d(n)).\n            # Per problem spec, L(d, 1) is 0.\n            if n = 1:\n                L = 0\n            else:\n                # Use numpy for safe floating point logarithm calculation.\n                # np.ceil returns a float, so cast to int.\n                L = int(np.ceil(np.log(n) / np.log(d)))\n\n            # From the derivation, the total weighted cost C(d) is:\n            # C(d) = w_ex * c_s + L * [c_c * (w_ex * (d-1) + w_in + w_dec) + c_s * (w_ex + w_in + w_dec)]\n\n            # Pre-calculate terms for clarity.\n            total_weight = w_ex + w_in + w_dec\n            comparison_workload = w_ex * (d - 1) + w_in + w_dec\n            \n            # Cost from comparisons and swaps during sift-up/sift-down.\n            variable_cost_per_level = c_c * comparison_workload + c_s * total_weight\n            \n            # Total cost is the fixed cost of extract-min plus the height-dependent costs.\n            cost = w_ex * c_s + L * variable_cost_per_level\n\n            # Check if this d yields a new minimum cost.\n            # The problem asks to choose the smallest d in case of a tie.\n            # By using '' and iterating d in increasing order, the first d\n            # that achieves the minimum cost will be selected, fulfilling the tie-breaker rule.\n            if cost  min_cost:\n                min_cost = cost\n                best_d = d\n        \n        results.append(best_d)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3225717"}]}