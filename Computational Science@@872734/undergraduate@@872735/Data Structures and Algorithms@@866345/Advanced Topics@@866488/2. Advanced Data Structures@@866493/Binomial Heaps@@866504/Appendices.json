{"hands_on_practices": [{"introduction": "The defining characteristic of a binomial heap is its elegant connection to the binary number system. The structure of a heap with $N$ nodes is directly determined by the binary representation of $N$, where each '1' bit corresponds to a binomial tree of a specific order in the heap's root list. This exercise challenges you to apply this fundamental principle to a combinatorial problem, reinforcing your understanding of how a heap's composition is a blueprint of its size [@problem_id:3216510].", "problem": "A binomial heap is a forest of binomial trees, where each binomial tree $B_{i}$ has $2^{i}$ nodes and the forest contains at most one tree of each order $i$. Consider building a binomial heap by inserting $N$ distinct keys one-by-one using the standard binomial-heap insertion that consolidates trees of equal order via linking, and assume no deletions or key decreases occur. Fix an integer $k \\geq 3$ and consider all integers $N$ satisfying $1 \\leq N \\leq 2^{k} - 1$. Determine, as a function of $k$, the number of such $N$ for which, after these $N$ insertions, the binomial heap has exactly $3$ trees in its root list. Express your final answer as a closed-form analytic expression in $k$.", "solution": "## Problem Validation\n\n### Step 1: Extract Givens\n- **Data Structure:** A binomial heap is a forest of binomial trees.\n- **Binomial Tree Property:** A tree of order $i$, denoted $B_i$, has $2^i$ nodes.\n- **Heap Structure Property:** A binomial heap contains at most one tree of each order $i$.\n- **Operation:** The heap is built by inserting $N$ distinct keys one by one.\n- **Insertion Method:** The standard method of consolidating trees of equal order via linking is used.\n- **Constraints on Operations:** No deletions or `decrease-key` operations occur.\n- **Parameter:** An integer $k \\geq 3$ is fixed.\n- **Range of $N$:** The number of nodes $N$ is an integer satisfying $1 \\leq N \\leq 2^k - 1$.\n- **Target Condition:** The resulting binomial heap must have exactly $3$ trees in its root list.\n- **Objective:** Determine the number of integers $N$ in the specified range that satisfy the target condition, expressed as a closed-form analytic function of $k$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is evaluated against the validation criteria:\n\n1.  **Scientifically Grounded:** The problem is based on the standard and well-established theory of binomial heaps, a fundamental data structure in computer science and algorithms. The properties described (e.g., a tree $B_i$ having $2^i$ nodes, the structure of the heap for $N$ items) are text-book definitions.\n2.  **Well-Posed:** The problem provides all necessary information. The definitions are clear, the range for $N$ is precisely defined by $k$, and the condition to be met (exactly $3$ trees) is unambiguous. The problem asks for a count, which implies a unique numerical answer exists as a function of $k$.\n3.  **Objective:** The language is formal and objective. There are no subjective or opinion-based statements.\n4.  **No Flaws:**\n    - It does not violate scientific principles.\n    - It is a formal problem in the field of data structures and algorithms, specifically related to binomial heaps.\n    - The setup is complete and consistent. The constraint $k \\geq 3$ is crucial and is provided.\n    - The conditions are not unrealistic or infeasible within the theoretical context of the data structure.\n    - The problem is well-structured and leads to a unique, meaningful solution.\n    - The problem is not trivial; it requires understanding the core properties of the binomial heap structure.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-defined combinatorial problem concerning the properties of binomial heaps. A full solution will be provided.\n\n## Solution\n\nThe structure of a binomial heap containing $N$ nodes is uniquely determined by the binary representation of the integer $N$. Specifically, a binomial heap with $N$ nodes contains a binomial tree of order $i$, denoted $B_i$, if and only if the $i$-th bit in the binary representation of $N$ is a $1$. Let the binary representation of $N$ be $(c_{m} c_{m-1} \\dots c_1 c_0)_2$, where $c_i \\in \\{0, 1\\}$. Then, the number of nodes is $N = \\sum_{i=0}^{m} c_i 2^i$. The heap will consist of the set of trees $\\{B_i \\mid c_i = 1\\}$.\n\nThe number of trees in the root list of the binomial heap is therefore equal to the number of binomial trees in the forest. This, in turn, is equal to the number of $1$s in the binary representation of $N$. This quantity is also known as the population count or Hamming weight of $N$.\n\nThe problem asks for the number of integers $N$ such that a heap of $N$ items has exactly $3$ trees. This is equivalent to finding the number of integers $N$ whose binary representation contains exactly three $1$s.\n\nThe problem specifies the range of $N$ to be $1 \\leq N \\leq 2^k - 1$ for a fixed integer $k \\geq 3$.\nThe number $2^k - 1$ is represented in binary as a string of $k$ consecutive $1$s. Any integer $N$ in the range $1 \\leq N \\leq 2^k - 1$ can be represented using at most $k$ bits (from bit position $0$ to bit position $k-1$). We can think of the binary representation of any such $N$ as a binary string of length $k$, potentially with leading zeros. For example, if $k=5$, the number $N=7$ is $(111)_2$, which can be written as the $5$-bit string $(00111)_2$.\n\nThe problem is thus transformed into the following combinatorial question: How many integers $N$ in the range $1 \\leq N \\leq 2^k - 1$ have a binary representation with exactly three $1$s?\n\nThis is equivalent to counting the number of binary strings of length $k$ that contain exactly three $1$s. The positions of these $k$ bits correspond to the orders of the binomial trees, i.e., positions $0, 1, \\dots, k-1$. To form a number with three $1$s in its binary representation, we must choose exactly $3$ positions out of the $k$ available bit positions to place the $1$s. The remaining $k-3$ positions will be filled with $0$s.\n\nThe number of ways to choose $3$ distinct positions from a set of $k$ is given by the binomial coefficient \"k choose 3\", written as $\\binom{k}{3}$.\n\nEach such choice corresponds to a unique integer $N < 2^k$. Since we are choosing three $1$s, the resulting number $N$ will be the sum of three distinct powers of $2$. The smallest possible such number occurs when we choose the lowest three bit positions ($0$, $1$, and $2$), which gives $N = 2^0 + 2^1 + 2^2 = 1 + 2 + 4 = 7$. Since the problem states $k \\geq 3$, the smallest possible value of $N$ is always $7$, which satisfies the condition $N \\geq 1$. Therefore, all such combinations result in a valid $N$ within the specified range.\n\nThe number of such integers $N$ is:\n$$ \\binom{k}{3} $$\nTo express this as a closed-form analytic expression in $k$, we expand the binomial coefficient:\n$$ \\binom{k}{3} = \\frac{k!}{3!(k-3)!} = \\frac{k(k-1)(k-2)(k-3)!}{(3 \\cdot 2 \\cdot 1)(k-3)!} $$\nFor $k \\geq 3$, the $(k-3)!$ terms cancel, leaving:\n$$ \\frac{k(k-1)(k-2)}{6} $$\nThis expression gives the number of integers $N$ in the range $1 \\leq N \\leq 2^k-1$ for which a binomial heap of size $N$ has exactly $3$ trees.", "answer": "$$\\boxed{\\frac{k(k-1)(k-2)}{6}}$$", "id": "3216510"}, {"introduction": "Beyond understanding its static structure, the real power of a data structure lies in how we can operate on it efficiently. This next practice moves from structure to algorithm, asking you to devise a fast method for finding the second-smallest element in the heap in $O(\\log n)$ time. To solve this, you must carefully reason about the min-heap property, considering candidates both within the minimum element's own tree and across the other trees in the forest [@problem_id:3216453].", "problem": "An indexed priority queue is implemented as a binomial heap with the heap-order property on keys (a node’s key is greater than or equal to its parent’s key). Let the binomial heap contain $n$ elements, maintain a direct pointer to the minimum root, and support the usual operations, but you are not allowed to modify the data structure during the query.\n\nFrom the foundational definitions: a binomial heap is a forest of binomial trees $\\{B_k\\}$ where each $B_k$ has $2^k$ nodes and the degree of its root is $k$. The forest contains at most one tree of each order, so the number of roots is at most $\\lfloor \\log_2 n \\rfloor + 1$. In every binomial tree with heap-order, the root key is the smallest in its tree, and within the minimum root’s tree, the minimum excluding the root must be among the root’s children, because all descendants of any child have keys greater than or equal to that child.\n\nChoose the option that both correctly identifies where the second-smallest element must reside and achieves worst-case $O(\\log n)$ time without modifying the heap:\n\nA. Examine only the children of the minimum root and return the smallest among them; this works because the second-smallest must be in the minimum root’s children, and the root degree is at most $O(\\log n)$.\n\nB. Examine only the roots other than the minimum root and return the smallest among them; this works because any node in a tree is greater than or equal to its root, and there are $O(\\log n)$ roots.\n\nC. Build a temporary binary heap on the $n-1$ elements excluding the minimum, then extract its minimum to obtain the second-smallest; this works and costs $O(n)$ to build and $O(\\log n)$ to extract.\n\nD. Examine the union of the children of the minimum root and all other roots, and return the smallest among this set; this works because any element outside the minimum root is at least its tree’s root, and any element inside the minimum root’s tree (excluding the root) is at least its corresponding child; the set size is $O(\\log n)$.\n\nE. Perform one delete-min to make the second-smallest become the new minimum, then record it and restore the original heap by reinserting the removed subtrees; this works and costs $O(\\log n)$ for delete-min plus additional reinsertion.", "solution": "The problem statement has been validated and found to be well-posed, scientifically sound, and internally consistent. It describes a standard computer science problem concerning binomial heaps. The provided definitions and constraints are standard and unambiguous.\n\nThe task is to find the second-smallest element in a binomial heap of $n$ elements, implemented as a min-heap, in worst-case $O(\\log n)$ time without modifying the data structure.\n\nLet the binomial heap be $H$. It is a forest of binomial trees satisfying the min-heap property. The problem states that we have a direct pointer to the root with the overall minimum key. Let this root be $r_{\\min}$ and its key be $k_{\\min}$. By definition, $k_{\\min}$ is the smallest key in the entire heap $H$.\n\nThe second-smallest element in the heap must have a key greater than $k_{\\min}$. To find this element, we must identify all potential candidates whose keys could be the second-smallest. The set of all nodes in the heap can be partitioned into two disjoint sets:\n1. The binomial tree $T_{\\min}$ containing the minimum root $r_{\\min}$.\n2. The set of all other binomial trees in the forest, $\\{T_1, T_2, \\dots, T_m\\}$.\n\nThe second-smallest element must be the element with the minimum key in the set of all nodes excluding $r_{\\min}$. We can find the minimum of this set by finding the minimum candidate from each partition and then comparing them.\n\nCandidate set from the tree $T_{\\min}$:\nThe nodes in $T_{\\min}$ (excluding the root $r_{\\min}$) are the descendants of $r_{\\min}$. Let $c_1, c_2, \\dots, c_d$ be the children of $r_{\\min}$, where $d$ is the degree of $r_{\\min}$. Due to the min-heap property, for any node $x$, its key is greater than or equal to its parent's key. This implies two things:\n- For any child $c_i$ of $r_{\\min}$, $key(c_i) \\ge key(r_{\\min})$.\n- For any node $x$ in the subtree rooted at a child $c_i$, $key(x) \\ge key(c_i)$.\nTherefore, the minimum key among all descendants of $r_{\\min}$ must belong to one of its direct children. The first set of candidates for the second-smallest key is the set of keys of the children of $r_{\\min}$.\n\nCandidate set from the other trees $\\{T_1, T_2, \\dots, T_m\\}$:\nLet the roots of these other trees be $r_1, r_2, \\dots, r_m$. For any tree $T_j$ in this set, the min-heap property guarantees that its root $r_j$ holds the minimum key within that entire tree. Thus, the smallest key in the union of all these other trees is simply the minimum of the keys of their roots, $\\min\\{key(r_1), key(r_2), \\dots, key(r_m)\\}$. The second set of candidates for the second-smallest key is the set of keys of the roots of all other binomial trees in the heap's root list.\n\nCombining these findings, the second-smallest element in the entire heap must be the minimum of the union of these two candidate sets: the children of the minimum root $r_{\\min}$ and the set of all other roots in the heap's root list.\n\nLet's analyze the time complexity of this approach.\nA binomial heap with $n$ elements consists of at most $\\lfloor \\log_2 n \\rfloor + 1$ binomial trees. This is $O(\\log n)$. So, the total number of roots in the root list is $O(\\log n)$. The number of \"other roots\" is therefore also $O(\\log n)$.\nThe degree of a root in a binomial heap of $n$ elements is at most $\\lfloor \\log_2 n \\rfloor$. Thus, the number of children of the minimum root $r_{\\min}$ is $O(\\log n)$.\nThe total number of candidates to examine is the sum of the number of children of $r_{\\min}$ and the number of other roots, which is $O(\\log n) + O(\\log n) = O(\\log n)$.\nFinding the minimum element in a set of size $O(\\log n)$ requires $O(\\log n)$ comparisons. This approach does not alter the heap structure, satisfying the problem's constraint.\n\nNow, we evaluate each option:\n\nA. Examine only the children of the minimum root and return the smallest among them; this works because the second-smallest must be in the minimum root’s children, and the root degree is at most $O(\\log n)$.\nThis is incorrect. This approach fails to consider that the second-smallest element could be the root of another binomial tree in the forest. For instance, in a heap with two trees, one rooted at $1$ (with child $10$) and another rooted at $2$, the second-smallest element is $2$, which is not a child of the minimum root, $1$.\n\nB. Examine only the roots other than the minimum root and return the smallest among them; this works because any node in a tree is greater than or equal to its root, and there are $O(\\log n)$ roots.\nThis is incorrect. This approach fails to consider that the second-smallest element could be a child of the minimum root. For instance, in a heap with only one tree, rooted at $1$ with child $2$, there are no other roots. The second-smallest element is $2$, a child of the minimum root.\n\nC. Build a temporary binary heap on the $n-1$ elements excluding the minimum, then extract its minimum to obtain the second-smallest; this works and costs $O(n)$ to build and $O(\\log n)$ to extract.\nThis is incorrect. While this algorithm would correctly identify the second-smallest element, its time complexity is dominated by the construction of the temporary heap, which requires iterating over $n-1$ elements and takes $O(n)$ time. The problem requires a worst-case time complexity of $O(\\log n)$.\n\nD. Examine the union of the children of the minimum root and all other roots, and return the smallest among this set; this works because any element outside the minimum root is at least its tree’s root, and any element inside the minimum root’s tree (excluding the root) is at least its corresponding child; the set size is $O(\\log n)$.\nThis is correct. As derived above, the set of candidates for the second-smallest element is precisely the union of the children of the minimum root and all other roots in the root list. The size of this set is $O(\\log n)$, and finding the minimum takes $O(\\log n)$ time. This procedure does not modify the heap. The justification provided in the option is also sound.\n\nE. Perform one delete-min to make the second-smallest become the new minimum, then record it and restore the original heap by reinserting the removed subtrees; this works and costs $O(\\log n)$ for delete-min plus additional reinsertion.\nThis is incorrect. The problem statement includes the explicit constraint: \"you are not allowed to modify the data structure during the query.\" The `delete-min` operation fundamentally modifies the structure of the heap. Even if the heap could be restored later, the query itself involves a modification, violating the problem's core constraint.", "answer": "$$\\boxed{D}$$", "id": "3216453"}, {"introduction": "An abstract data structure's theoretical guarantees only hold if its concrete implementation is correct. When representing a binomial heap with pointers, it is possible to introduce structural flaws, such as cycles, that violate its core acyclic nature. This final practice provides a hands-on coding challenge to apply graph traversal algorithms to verify the structural integrity of a supposed binomial heap, a crucial skill in robust software development [@problem_id:3216483].", "problem": "You are given a pointer-based representation of a data structure that is intended to be a binomial heap. A binomial heap is a forest of binomial trees where each tree is structurally defined as follows: a binomial tree of order $0$ (denoted $B_0$) is a single node; for any integer $k \\ge 1$, a binomial tree of order $k$ (denoted $B_k$) is formed by linking exactly one binomial tree $B_{k-1}$ as a child to the root of another binomial tree $B_{k-1}$. In a typical pointer-based representation, each node has a key, a degree, a parent pointer, a single pointer to its leftmost child, and a pointer to its next sibling on the same level. The root list of the heap is a singly linked list via sibling pointers. In a valid binomial heap, when considering only the directed edges induced by child and sibling pointers, the structure must be acyclic, because each component is a tree and the root list is a simple linked list.\n\nStarting from the fundamental graph-theoretic fact that a tree is an acyclic connected graph and that detecting a cycle in a directed graph can be accomplished by exploring reachable vertices and identifying back edges, devise a programmatic method to determine whether the given pointer-based structure contains any cycle reachable by following only child and sibling pointers. Parent pointers are not to be traversed for cycle detection, since traversing parent pointers in addition to child pointers would inherently form a cycle in any valid tree.\n\nYour task is to implement a complete program that:\n- Constructs a small suite of test heaps in memory, each defined precisely below.\n- Detects whether a cycle exists when traversing only child and sibling pointers from the head of the root list.\n- Produces a single line of output containing the boolean results for each test case in order, as a comma-separated list enclosed in square brackets, using lowercase literals `true` and `false`.\n\nUse the following test suite, where each node name denotes a distinct node, and all unspecified pointers are $None$:\n\n- Test case $1$ (valid structure, no cycle): Define nodes $r_1, r_2, r_3, a, b, c$ with the following pointers. Root list: $r_1.\\text{sibling} = r_2$, $r_2.\\text{sibling} = r_3$, $r_3.\\text{sibling} = None$. Children: $r_2.\\text{child} = a$ with $a.\\text{sibling} = None$; $r_3.\\text{child} = b$ with $b.\\text{sibling} = c$ and $c.\\text{sibling} = None$. Parent pointers: $a.\\text{parent} = r_2$, $b.\\text{parent} = r_3$, $c.\\text{parent} = r_3$.\n- Test case $2$ (cycle among root siblings): Define nodes $u, v$. Root list cycle: $u.\\text{sibling} = v$, $v.\\text{sibling} = u$.\n- Test case $3$ (cycle via child self-loop): Define node $x$ with $x.\\text{child} = x$.\n- Test case $4$ (cycle via sibling self-loop): Define node $y$ with $y.\\text{sibling} = y$.\n- Test case $5$ (cycle across two trees): Define nodes $p, q, m, n$. Root list: $p.\\text{sibling} = q$, $q.\\text{sibling} = None$. Children creating a cycle across trees: $p.\\text{child} = m$, $m.\\text{sibling} = q$, $q.\\text{child} = n$, $n.\\text{sibling} = p$.\n- Test case $6$ (empty heap): Head of the root list is $None$.\n- Test case $7$ (single node heap): Define node $z$ with no child and no sibling.\n\nThe required final output format is a single line:\n- A comma-separated list enclosed in square brackets, with each entry being `true` if a cycle is detected or `false` otherwise.\n- For example, the output should look like `[true,false,...]` without any spaces.\n\nYour program should construct these exact structures and output a single line in the specified format for the test cases in the given order.", "solution": "The problem requires a method to verify the structural integrity of a pointer-based data structure intended to be a binomial heap. Specifically, we must detect if any cycles exist when the structure is viewed as a directed graph where edges are defined exclusively by `child` and `sibling` pointers. Traversing `parent` pointers is correctly forbidden, as doing so in conjunction with `child` pointers would trivially create cycles in any valid tree structure.\n\nThe fundamental principle for this task comes from graph theory. A valid binomial heap is a forest of binomial trees, and a tree is, by definition, an acyclic connected graph. The collection of nodes and the specified pointers (`child` and `sibling`) form a directed graph. A cycle in this graph represents a structural flaw. Our goal is to determine if such a cycle exists that is reachable from the head of the heap's root list.\n\nA standard and robust algorithm for cycle detection in a directed graph is the Depth-First Search (DFS). The core idea of using DFS for this purpose is to keep track of the state of each node during the traversal. We can classify each node into one of three states:\n$1$. Unvisited: The node has not been encountered yet.\n$2$. Visiting: The node is currently in the recursion stack of the DFS traversal. We have started exploring from this node but have not yet finished exploring all of its descendants.\n$3$. Visited: The node and all of its descendants have been fully explored.\n\nA cycle is detected if and only if the DFS encounters a node that is currently in the `Visiting` state. Such an edge, leading from a node to one of its ancestors in the DFS tree, is known as a back edge.\n\nThe algorithm can be implemented with a recursive helper function, which we can call `_has_cycle_util`. This function will take the current node and two sets, `visiting` and `visited`, to maintain the states corresponding to the `Visiting` and `Visited` classifications.\n\nThe overall procedure is as follows:\n- Define a recursive function, `_has_cycle_util(node, visiting, visited)`.\n- The `visiting` set will store nodes currently in the recursion stack (the gray set).\n- The `visited` set will store nodes that have been completely explored (the black set).\n- The base cases for the recursion handle the termination conditions:\n    a. If `node` is `None`, no path can continue from here, so no cycle is found along this path. Return `false`.\n    - b. If `node` is already in the `visiting` set, we have found a back edge. This conclusively proves a cycle exists. Return `true`.\n    - c. If `node` is already in the `visited` set, this subgraph has already been explored and was found to be acyclic. We can prune the search here to avoid redundant work and return `false`.\n- If none of the base cases are met, we proceed with the traversal for the current `node`:\n    a. Add the `node` to the `visiting` set to mark it as part of the current traversal path.\n    b. Recursively call `_has_cycle_util` for each of the node's relevant neighbors. In this problem, the neighbors are the nodes pointed to by the `child` and `sibling` pointers.\n    c. If the recursive call for `node.child` returns `true`, a cycle was found downstream. We immediately propagate this result by returning `true`.\n    d. Similarly, if the recursive call for `node.sibling` returns `true`, a cycle was found, and we return `true`.\n- If the recursive calls for all neighbors complete without finding a cycle, it signifies that the subgraph reachable from the current `node` is acyclic. We then perform two actions:\n    a. Remove the `node` from the `visiting` set, as it is no longer on the active recursion path.\n    b. Add the `node` to the `visited` set to mark it and its entire reachable subgraph as fully explored and acyclic.\n    c. Return `false`.\n\nThe main function, `detect_cycle`, will initialize the empty `visiting` and `visited` sets and start the process by making an initial call to `_has_cycle_util` with the head of the root list. Since the entire structure described in any test case is reachable from its head via a combination of `sibling` (for the root list) and `child` (for subtrees) pointers, a single initial traversal is sufficient to explore the entire relevant graph. An empty heap (where the head is `None`) is a special case that is correctly handled by the recursion's base case, resulting in a `false` return value. This algorithm correctly identifies all specified cycle types, from self-loops to complex cycles spanning multiple trees.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    A node in the binomial heap structure. For this problem, only child and\n    sibling pointers are relevant for the cycle detection logic.\n    \"\"\"\n    def __init__(self, name: str):\n        self.name = name\n        self.child = None\n        self.sibling = None\n        # The following attributes are part of a full binomial heap node\n        # but are not used in the cycle detection logic itself.\n        # self.key = None\n        # self.degree = 0\n        # self.parent = None\n\n    def __repr__(self):\n        return f\"Node({self.name})\"\n\ndef _has_cycle_util(node: Node | None, visiting: set, visited: set) -> bool:\n    \"\"\"\n    Recursive helper for DFS-based cycle detection.\n\n    Args:\n        node: The current node to visit.\n        visiting: A set of nodes currently in the recursion stack (gray set).\n        visited: A set of nodes that have been fully explored (black set).\n    \n    Returns:\n        True if a cycle is detected, False otherwise.\n    \"\"\"\n    if node is None:\n        return False\n\n    if node in visiting:\n        # A back edge is found, indicating a cycle.\n        return True\n\n    if node in visited:\n        # This node and its descendants have been checked and are acyclic.\n        return False\n\n    # Mark the current node as being visited.\n    visiting.add(node)\n\n    # Recurse on neighbors (child and sibling).\n    if _has_cycle_util(node.child, visiting, visited):\n        return True\n    \n    if _has_cycle_util(node.sibling, visiting, visited):\n        return True\n\n    # Remove node from the recursion stack and mark as fully visited.\n    visiting.remove(node)\n    visited.add(node)\n\n    return False\n\ndef detect_cycle(head: Node | None) -> bool:\n    \"\"\"\n    Detects if a cycle exists in the structure reachable from the head node,\n    traversing only child and sibling pointers.\n    \"\"\"\n    visiting = set()\n    visited = set()\n    return _has_cycle_util(head, visiting, visited)\n\ndef solve():\n    \"\"\"\n    Constructs all test cases, runs cycle detection on each, and prints\n    the results in the specified format.\n    \"\"\"\n    # --- Test Case Construction ---\n    \n    # Test case 1 (valid structure, no cycle)\n    r1, r2, r3 = Node('r1'), Node('r2'), Node('r3')\n    a, b, c = Node('a'), Node('b'), Node('c')\n    r1.sibling = r2\n    r2.sibling = r3\n    r2.child = a\n    r3.child = b\n    b.sibling = c\n    head1 = r1\n\n    # Test case 2 (cycle among root siblings)\n    u, v = Node('u'), Node('v')\n    u.sibling = v\n    v.sibling = u\n    head2 = u\n\n    # Test case 3 (cycle via child self-loop)\n    x = Node('x')\n    x.child = x\n    head3 = x\n\n    # Test case 4 (cycle via sibling self-loop)\n    y = Node('y')\n    y.sibling = y\n    head4 = y\n\n    # Test case 5 (cycle across two trees)\n    p, q, m, n = Node('p'), Node('q'), Node('m'), Node('n')\n    p.sibling = q\n    p.child = m\n    m.sibling = q\n    q.child = n\n    n.sibling = p\n    head5 = p\n\n    # Test case 6 (empty heap)\n    head6 = None\n\n    # Test case 7 (single node heap)\n    z = Node('z')\n    head7 = z\n\n    test_heads = [head1, head2, head3, head4, head5, head6, head7]\n    \n    results = []\n    for head in test_heads:\n        has_cycle = detect_cycle(head)\n        results.append(str(has_cycle).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3216483"}]}