{"hands_on_practices": [{"introduction": "Before writing or debugging code for a complex data structure like a Fibonacci heap, it is critical to know what \"correct\" means. This exercise challenges you to think like a test engineer and define the essential structural properties that a valid heap must always maintain. By selecting the correct set of invariants, you are building a powerful diagnostic tool for verifying an implementation's integrity ([@problem_id:3234539]).", "problem": "You are debugging an implementation of a Fibonacci heap for a min-heap. After a long randomized test, you observe symptoms such as an occasional failure of decrease-key to adjust the reported minimum, sporadic cycles when traversing the root list, and occasional mismatches between a node’s reported degree and the number of children encountered by walking its child list. You decide to write an invariant checker that runs after each operation and flags structural inconsistencies. Using only fundamental definitions and well-tested facts about Fibonacci heaps, which set of assertions is most appropriate to include in order to expose common structural errors without overconstraining valid states?\n\nChoose the best option.\n\nA. Assert all of the following:\n- Heap order: for every non-root node $x$ with parent $p(x)$, $key(p(x)) \\le key(x)$.\n- Root list structure: the root list is a circular doubly linked list with pointer consistency, i.e., for every root $r$, $r.\\mathrm{left}.\\mathrm{right} = r$ and $r.\\mathrm{right}.\\mathrm{left} = r$, and each root has $r.\\mathrm{parent} = \\mathrm{null}$.\n- Minimum pointer: $H.\\mathrm{min}$ points to a root whose key equals $\\min\\{key(r) : r \\text{ is a root}\\}$.\n- Degree consistency: for every node $x$, the stored degree $deg(x)$ equals the number of children reachable by one pass around $x$’s child circular list; each child $c$ in that list satisfies $c.\\mathrm{parent} = x$.\n- Mark consistency: all roots are unmarked; if a node is marked, then it is not a root and has $x.\\mathrm{parent} \\ne \\mathrm{null}$.\n- Post-consolidation uniqueness: immediately after each `extract-min`, the degrees of all roots are pairwise distinct.\n\nB. Assert all of the following:\n- The number of roots is exactly $\\lfloor \\log_{\\varphi} n \\rfloor$, where $\\varphi = \\frac{1+\\sqrt{5}}{2}$ and $n$ is the number of nodes.\n- The minimum pointer $H.\\mathrm{min}$ is the globally smallest key among all nodes in the heap (not only among roots).\n- Child lists may be singly linked as long as traversal reaches all children.\n- Roots may be marked, since marking only indicates that a node has lost a child at some point.\n\nC. Assert all of the following:\n- Heap order is strict: for every non-root node $x$ with parent $p(x)$, $key(p(x)) < key(x)$.\n- Degree is the total number of descendants: for every node $x$, $deg(x)$ equals the number of nodes in the subtree rooted at $x$ minus $1$.\n- Degree uniqueness holds across the entire heap at all times: no two nodes (root or non-root) share the same $deg(\\cdot)$ value.\n- Children need not maintain a parent pointer if they can be reached from the root list by pointer chasing.\n\nD. Assert all of the following:\n- The potential function value $\\Phi = T + 2M$, where $T$ is the number of roots and $M$ is the number of marked nodes, never increases across any operation.\n- The minimum pointer $H.\\mathrm{min}$ may temporarily be incorrect after decrease-key but must be corrected only after `extract-min`.\n- Consolidation may delay pairing roots of equal degree until after $k$ `extract-min` operations for some fixed $k > 1$.\n- The parent pointer can be omitted unless a node is marked; in that case, it must point to a valid parent.", "solution": "## PROBLEM VALIDATION\n\n### Step 1: Extract Givens\n- **Data Structure:** A min-heap implemented as a Fibonacci heap.\n- **Context:** An implementation is being debugged via a randomized test.\n- **Observed Symptoms:**\n    1. Occasional failure of `decrease-key` to adjust the reported minimum.\n    2. Sporadic cycles when traversing the root list.\n    3. Occasional mismatches between a node’s reported degree and the number of children encountered by walking its child list.\n- **Task:** Define a set of assertions for an invariant checker that runs after each operation.\n- **Objective:** The assertions must expose common structural errors without overconstraining valid states, using only fundamental definitions and well-tested facts about Fibonacci heaps.\n- **Question:** Which of the provided sets of assertions is the most appropriate?\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is valid.\n- **Scientifically Grounded:** The problem is set in the context of data structures and algorithms, a formal branch of computer science. Fibonacci heaps are a well-defined mathematical construct with established properties (invariants). The described symptoms are plausible bugs that arise from incorrect implementation of the heap's operations. The task of creating an invariant checker is a standard and rigorous method for debugging complex data structures.\n- **Well-Posed:** The problem asks for the \"most appropriate\" set of assertions to achieve a clearly defined goal: exposing specific types of errors while not ruling out valid intermediate states of the heap. This structure allows for a single best answer to be determined by comparing the given options against the established theory of Fibonacci heaps.\n- **Objective:** The problem is described using precise, technical language specific to the field. The symptoms are concrete and measurable, and the desired properties of the assertions are objective criteria (exposing errors, not overconstraining).\n\n### Step 3: Verdict and Action\nThe problem is valid. The analysis will proceed to derive the solution.\n\n## SOLUTION DERIVATION\n\nThe goal is to identify the set of assertions that correctly captures the structural invariants of a Fibonacci heap for a min-heap. Such a set should be sufficient to detect the described implementation bugs. We will evaluate each option based on the canonical definition of a Fibonacci heap.\n\nA Fibonacci heap $H$ is a collection of trees satisfying the min-heap property. The structural invariants that must hold true between public operations are:\n\n1.  **Min-Heap Order:** For every node $x$ with a parent $p(x)$, the inequality $key(p(x)) \\le key(x)$ must hold.\n2.  **Root List:** The roots of the trees are all linked together in a circular, doubly linked list. The parent of every root is $\\mathrm{null}$.\n3.  **Minimum Pointer:** A pointer $H.\\mathrm{min}$ must point to the root node with the minimum key value.\n4.  **Node Fields:** Each node $x$ maintains its degree $deg(x)$ (number of children), a child pointer, parent pointer, and a boolean mark.\n5.  **Child Lists:** The children of each node $x$ are also linked in a circular, doubly linked list. The parent pointer of each child must point back to $x$.\n6.  **Marking Rule:** A non-root node $x$ is marked if it has lost a child since $x$ was last made a child of its current parent. All roots are unmarked.\n\nThe described bugs correspond to violations of these invariants:\n- Failure of `decrease-key` to update the minimum violates invariant #3.\n- Cycles in the root list violate invariant #2.\n- Mismatched degree and child count violate invariants #4 and #5.\n\nNow, we evaluate each option.\n\n### Option-by-Option Analysis\n\n**A. Assert all of the following:**\n1.  **Heap order: for every non-root node $x$ with parent $p(x)$, $key(p(x)) \\le key(x)$.** This is the fundamental min-heap property and a core invariant. **This assertion is correct.**\n2.  **Root list structure: the root list is a circular doubly linked list with pointer consistency, i.e., for every root $r$, $r.\\mathrm{left}.\\mathrm{right} = r$ and $r.\\mathrm{right}.\\mathrm{left} = r$, and each root has $r.\\mathrm{parent} = \\mathrm{null}$.** This correctly defines the root list's structure and pointer integrity. Checking this would detect the \"sporadic cycles\" bug. **This assertion is correct.**\n3.  **Minimum pointer: $H.\\mathrm{min}$ points to a root whose key equals $\\min\\{key(r) : r \\text{ is a root}\\}$.** This is the definition of the minimum pointer's role, ensuring $O(1)$ `find-min` operations. It would detect the bug where `decrease-key` fails to update the minimum. **This assertion is correct.**\n4.  **Degree consistency: for every node $x$, the stored degree $deg(x)$ equals the number of children reachable by one pass around $x$’s child circular list; each child $c$ in that list satisfies $c.\\mathrm{parent} = x$.** This check directly addresses the bug concerning degree mismatches and also verifies the integrity of child-parent links, which is crucial for `cut` operations. **This assertion is correct.**\n5.  **Mark consistency: all roots are unmarked; if a node is marked, then it is not a root and has $x.\\mathrm{parent} \\ne \\mathrm{null}$.** This correctly states the marking rule. Roots are by definition unmarked (they are cleared of their mark when they become a root). **This assertion is correct.**\n6.  **Post-consolidation uniqueness: immediately after each `extract-min`, the degrees of all roots are pairwise distinct.** This is a correct statement about the state of a Fibonacci heap *immediately after* the consolidation step of a `extract-min` operation. While it is not a global invariant that holds after *every* operation (e.g., `insert` can create a root with a degree already present), it is a critical post-condition for `extract-min`. An invariant checker could use this assertion conditionally. In the context of creating a comprehensive suite of checks to debug an implementation, this is a very appropriate and useful assertion.\n\nThis set of assertions is composed entirely of correct properties of a Fibonacci heap. The first five are global invariants, and the sixth is a critical post-condition of a major operation. Together, they are highly effective at exposing the described structural errors.\n**Verdict: Correct.**\n\n**B. Assert all of the following:**\n1.  **The number of roots is exactly $\\lfloor \\log_{\\varphi} n \\rfloor$, where $\\varphi = \\frac{1+\\sqrt{5}}{2}$ and $n$ is the number of nodes.** This is incorrect. The number of roots is not fixed. It can be as high as $n$. The bound $O(\\log n)$ applies to the maximum *degree* of any node in the heap, not the number of roots.\n2.  **The minimum pointer $H.\\mathrm{min}$ is the globally smallest key among all nodes in the heap (not only among roots).** While this statement is a true consequence of the min-heap property (the minimum must reside at a root), the primary, directly checkable invariant is that $H.\\mathrm{min}$ points to the minimum *among the roots*. Formulating it this way is less direct than the assertion in Option A.\n3.  **Child lists may be singly linked as long as traversal reaches all children.** This is incorrect. The child lists must be doubly linked to support efficient cutting of a node from its siblings, which is required for the $O(1)$ amortized time of `decrease-key`.\n4.  **Roots may be marked, since marking only indicates that a node has lost a child at some point.** This is incorrect. By definition, a node is unmarked when it becomes a root.\nThis set contains multiple fundamental errors.\n**Verdict: Incorrect.**\n\n**C. Assert all of the following:**\n1.  **Heap order is strict: for every non-root node $x$ with parent $p(x)$, $key(p(x)) < key(x)$.** This is an overconstraint. Fibonacci heaps can store elements with duplicate keys, so the heap property is non-strict ($ \\le $).\n2.  **Degree is the total number of descendants: for every node $x$, $deg(x)$ equals the number of nodes in the subtree rooted at $x$ minus $1$.** This is incorrect. The degree of a node is the number of its direct children, not all of its descendants.\n3.  **Degree uniqueness holds across the entire heap at all times: no two nodes (root or non-root) share the same $deg(\\cdot)$ value.** This is incorrect. Uniqueness of degrees is not guaranteed, not even for roots except immediately after consolidation.\n4.  **Children need not maintain a parent pointer if they can be reached from the root list by pointer chasing.** This is incorrect. The parent pointer is essential for the `cut` and `cascading-cut` procedures in the `decrease-key` operation, which require moving up the tree from a node.\nThis set contains multiple fundamental errors.\n**Verdict: Incorrect.**\n\n**D. Assert all of the following:**\n1.  **The potential function value $\\Phi = T + 2M$, where $T$ is the number of roots and $M$ is the number of marked nodes, never increases across any operation.** This is incorrect. The potential function is a tool for amortized analysis; it is not an invariant and can increase during certain operations (e.g., `insert` increases $T$). The amortized cost, not the potential itself, is what is bounded.\n2.  **The minimum pointer $H.\\mathrm{min}$ may temporarily be incorrect after decrease-key but must be corrected only after `extract-min`.** This is incorrect. The `decrease-key` operation is responsible for updating $H.\\mathrm{min}$ if the key of the new minimum root is less than the current minimum. Allowing it to be incorrect would violate the semantics of the `find-min` operation. The problem's description of this behavior is a *symptom of a bug*, not a permissible state.\n3.  **Consolidation may delay pairing roots of equal degree until after $k$ `extract-min` operations for some fixed $k > 1$.** This describes a modification to the standard algorithm, not a property of the fundamental definition of a Fibonacci heap. The standard algorithm consolidates during every `extract-min`.\n4.  **The parent pointer can be omitted unless a node is marked; in that case, it must point to a valid parent.** This is incorrect. The `cascading-cut` procedure moves up from a node to its parent, which may be unmarked initially. Therefore, all non-root nodes must have a parent pointer.\nThis set contains multiple fundamental errors.\n**Verdict: Incorrect.**\n\n### Conclusion\nOption A provides a set of assertions that are all correct statements about a Fibonacci heap's structure and properties. The first five are general invariants, and the sixth is a specific post-condition for `extract-min`. This set is perfectly tailored to detect the specific bugs mentioned in the problem statement without being overly restrictive (as the one specific post-condition is correctly qualified). Options B, C, and D all contain multiple statements that are fundamentally incorrect characterizations of a Fibonacci heap. Therefore, Option A is unequivocally the most appropriate set of assertions.", "answer": "$$\\boxed{A}$$", "id": "3234539"}, {"introduction": "With a clear understanding of the core invariants, you can now apply them in a practical debugging scenario. This problem asks you to intentionally create a buggy `decrease-key` operation and then write test sequences that expose the specific invariant violations. This practice hones your ability to link operational failures to their root cause in the data structure's state, a crucial skill for any programmer working with complex systems ([@problem_id:3234524]).", "problem": "Consider a Fibonacci heap, which is a collection of trees satisfying the heap-order property. The heap-order property states that for every node $u$ with key $k(u)$ and every child $v$ of $u$ with key $k(v)$, the relation $k(u) \\leq k(v)$ holds. A standard Fibonacci heap maintains a pointer $min(H)$ to the root with the smallest key among all roots in the heap $H$. The fundamental base for this exercise is the core definition of the heap-order property and the invariant that the minimum element of the heap must be a root, which follows from the heap-order property.\n\nImplement two versions of a Fibonacci heap:\n- A correct version that adheres to the usual definitions and invariants.\n- A faulty version whose `decrease-key` operation sets a node’s key to the new value but does not perform any cuts (even when the new key violates the heap-order property by becoming strictly smaller than its parent’s key) and does not update the global minimum pointer $min(H)$ after the decrease. This faulty behavior must be implemented intentionally.\n\nYou must validate the following invariants on a heap $H$:\n- Heap-order invariant: for every edge $(u,v)$ with $v$ a child of $u$, $k(u) \\leq k(v)$.\n- Minimum-pointer invariant: $min(H)$ points to a root whose key equals the minimum key across all nodes in $H$.\n\nDesign a test suite consisting of three operation sequences. For each sequence, apply it to both the correct and the faulty heap and produce a boolean indicating whether the sequence reveals the bug by violating at least one of the invariants on the faulty heap, while the correct heap maintains all invariants. The sequences are:\n\n- Sequence $S_1$ (general case revealing heap-order violation):\n  1. Insert keys $20$, $7$, $25$, $17$, $26$, $18$ into an initially empty heap $H$.\n  2. Perform `extract-min` once.\n  3. Choose any non-root node $x$ (a node with $parent(x) \\neq \\varnothing$). Let $p$ be its parent and $k(p)$ its key. Perform `decrease-key`($x, k(p) - 5$).\n\n- Sequence $S_2$ (root decrease revealing minimum-pointer violation):\n  1. Insert keys $30$, $10$, $40$ into an initially empty heap $H$.\n  2. Let $r$ be the root whose current key is $30$. Perform `decrease-key`($r, 5$).\n\n- Sequence $S_3$ (boundary case preserving invariants):\n  1. Insert keys $50$, $60$, $70$, $80$ into an initially empty heap $H$.\n  2. Perform `extract-min` once.\n  3. Choose any non-root node $x$ with parent $p$. Perform `decrease-key`($x, k(p)$).\n\nFor each sequence $S_i$, your program must compute a boolean result that is $true$ if and only if the faulty heap violates at least one of the stated invariants and the correct heap does not, and $false$ otherwise. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, `[true,false,true]`.\n\nAll numeric values given in this problem are dimensionless integers; no physical units are involved. Angles are not applicable. Percentages are not applicable.\n\nYour solution must be a complete, runnable program that constructs both the correct and faulty heaps, executes the specified sequences, checks the invariants, and outputs the aggregated boolean results for the three test cases in the exact format described.", "solution": "The user-provided problem statement has been analyzed and validated. It is scientifically grounded in the established principles of data structures and algorithms, specifically concerning Fibonacci heaps. The problem is well-posed, objective, and contains a complete, consistent set of specifications for implementation and testing. No flaws related to scientific soundness, formalizability, completeness, feasibility, or structure were identified. Therefore, the problem is deemed **valid**.\n\nA complete solution follows, designed according to the problem's requirements. This involves the implementation of a `Node` class, a `BaseFibHeap` class containing shared functionality, and two subclasses: `CorrectFibHeap` and `FaultyFibHeap`, which differ in their `decrease_key` method. Invariant-checking methods are included to validate heap properties post-operation. Finally, three test sequences are executed on both heap variants to determine if the faulty implementation's bugs are revealed.\n\n### Data Structures\n\nA `Node` class is defined to represent an element in the heap. Each node stores its `key`, pointers `parent`, `child`, `left`, and `right` for structuring the trees and lists. It also maintains its `degree` (number of children) and a boolean `mark` for the `decrease_key` operation. An `initial_key` attribute is added to uniquely identify nodes for retrieval, as required by the test sequences.\n\nThe `BaseFibHeap` class encapsulates the common logic for both heap implementations. This includes `insert`, `extract_min`, and the `consolidate` helper function, which are identical for both versions. It also contains methods to verify the two critical invariants:\n1.  **Heap-order Invariant**: `_check_heap_order` traverses all nodes to ensure that for every node `u` and its child `v`, $k(u) \\leq k(v)$.\n2.  **Minimum-pointer Invariant**: `_check_min_pointer` verifies that the `min_node` pointer references a root node whose key is the minimum among all keys in the heap.\n\n### Heap Implementations\n\n1.  **`CorrectFibHeap`**: This class implements the standard Fibonacci heap algorithms. Its `decrease_key` method correctly handles violations of the heap-order property by performing `cut` and `cascading_cut` operations, and it updates the heap's minimum pointer if a new minimum is created.\n\n2.  **`FaultyFibHeap`**: This class inherits from `BaseFibHeap` but overrides `decrease_key` with the intentionally buggy behavior specified in the problem. This version simply changes the node's key and performs no subsequent structural adjustments (no cuts) or updates to the minimum pointer.\n\n### Test Sequences and Analysis\n\nThe solution proceeds by defining a function for each of the three test sequences ($S_1$, $S_2$, $S_3$). Each function instantiates a `CorrectFibHeap` and a `FaultyFibHeap`, applies the specified sequence of operations, and then evaluates the invariants on both heaps. A sequence is considered to have revealed the bug if the correct heap remains valid while the faulty heap becomes invalid.\n\n-   **Sequence $S_1$ (Heap-order violation)**: After insertions and one `extract_min`, a non-root node's key is decreased to a value less than its parent's key.\n    -   **Correct Heap**: The `decrease_key` operation triggers a `cut`, moving the node to the root list to restore the heap-order property. The minimum pointer is updated to this new, smaller root. All invariants are maintained.\n    -   **Faulty Heap**: The key is decreased, but no cut occurs. This creates an edge $(p, x)$ where $k(p) > k(x)$, violating the heap-order invariant. The minimum pointer is not updated, also violating the minimum-pointer invariant.\n    -   **Result**: The bug is revealed. The outcome is `true`.\n\n-   **Sequence $S_2$ (Minimum-pointer violation)**: A root node's key is decreased to a value smaller than the current minimum.\n    -   **Correct Heap**: Since the node is a root, no cut is necessary. The minimum pointer is updated to this node. All invariants are maintained.\n    -   **Faulty Heap**: The key is decreased, but the minimum pointer is not updated. The pointer continues to reference a node that is no longer the minimum, violating the minimum-pointer invariant.\n    -   **Result**: The bug is revealed. The outcome is `true`.\n\n-   **Sequence $S_3$ (Boundary case)**: A non-root node's key is decreased to a value equal to its parent's key.\n    -   **Correct Heap**: The new key is not strictly less than the parent's key ($k(p) \\leq k(x)$ holds as $k(p) = k(x)$), so no cut is required. The minimum is not changed. All invariants are maintained.\n    -   **Faulty Heap**: The key is decreased. Since this change does not violate the heap-order property and does not create a new overall minimum, both invariants remain intact by coincidence.\n    -   **Result**: The bug is not revealed because the faulty heap remains valid. The outcome is `false`.\n\nThe final program collates these boolean results into the required output format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Note: numpy is imported to adhere to the specified environment but is not used.\nimport math\n\nclass Node:\n    \"\"\"Represents a node in the Fibonacci heap.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.initial_key = key  # For stable node lookup\n        self.degree = 0\n        self.parent = None\n        self.child = None\n        self.left = self\n        self.right = self\n        self.mark = False\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\nclass BaseFibHeap:\n    \"\"\"Base class with common Fibonacci heap functionality.\"\"\"\n    def __init__(self):\n        self.min_node = None\n        self.num_nodes = 0\n        self.nodes_by_initial_key = {}\n\n    def insert(self, key):\n        \"\"\"Inserts a new key into the heap.\"\"\"\n        node = Node(key)\n        self.nodes_by_initial_key[key] = node\n        self._add_to_root_list(node)\n        if self.min_node is None or node.key < self.min_node.key:\n            self.min_node = node\n        self.num_nodes += 1\n        return node\n    \n    def _add_to_root_list(self, node):\n        \"\"\"Adds a node to the circular doubly-linked root list.\"\"\"\n        if self.min_node is None:\n            self.min_node = node\n        else:\n            node.right = self.min_node.right\n            node.left = self.min_node\n            self.min_node.right.left = node\n            self.min_node.right = node\n\n    def _remove_from_list(self, node):\n        \"\"\"Removes a node from a circular doubly-linked list.\"\"\"\n        node.left.right = node.right\n        node.right.left = node.left\n\n    def extract_min(self):\n        \"\"\"Extracts the node with the minimum key.\"\"\"\n        z = self.min_node\n        if z is not None:\n            if z.child is not None:\n                child = z.child\n                while True:\n                    next_child = child.right\n                    child.parent = None\n                    self._add_to_root_list(child)\n                    if next_child == z.child:\n                        break\n                    child = next_child\n            \n            self._remove_from_list(z)\n\n            if z == z.right:\n                self.min_node = None\n            else:\n                self.min_node = z.right\n                self.consolidate()\n            self.num_nodes -= 1\n        return z\n\n    def consolidate(self):\n        \"\"\"Consolidates the root list to reduce the number of trees.\"\"\"\n        degree_table = {}\n        roots = []\n        if self.min_node is None:\n            return\n            \n        curr = self.min_node\n        while True:\n            roots.append(curr)\n            if curr.right == self.min_node:\n                break\n            curr = curr.right\n\n        for w in roots:\n            x = w\n            d = x.degree\n            while d in degree_table:\n                y = degree_table[d]\n                if x.key > y.key:\n                    x, y = y, x\n                self._link(y, x)\n                del degree_table[d]\n                d += 1\n            degree_table[d] = x\n\n        self.min_node = None\n        for d in degree_table:\n            node = degree_table[d]\n            node.left = node\n            node.right = node\n            self._add_to_root_list(node)\n            if self.min_node is None or node.key < self.min_node.key:\n                self.min_node = node\n\n    def _link(self, y, x):\n        \"\"\"Links tree rooted at y to tree rooted at x.\"\"\"\n        self._remove_from_list(y)\n        y.parent = x\n        if x.child is None:\n            x.child = y\n            y.right = y\n            y.left = y\n        else:\n            y.left = x.child\n            y.right = x.child.right\n            x.child.right.left = y\n            x.child.right = y\n        x.degree += 1\n        y.mark = False\n\n    def _iter_nodes(self):\n        \"\"\"Generator to iterate over all nodes in the heap.\"\"\"\n        if not self.min_node:\n            return\n        \n        q = []\n        visited = set()\n\n        curr = self.min_node\n        while True:\n            q.append(curr)\n            if curr.right == self.min_node:\n                break\n            curr = curr.right\n            \n        while q:\n            node = q.pop(0)\n            if node in visited: continue\n            visited.add(node)\n            yield node\n            if node.child:\n                child = node.child\n                while True:\n                    q.append(child)\n                    if child.right == node.child:\n                        break\n                    child = child.right\n\n    def check_invariants(self):\n        \"\"\"Checks both heap invariants.\"\"\"\n        return self._check_heap_order() and self._check_min_pointer()\n\n    def _check_heap_order(self):\n        \"\"\"Checks if k(parent) <= k(child) for all nodes.\"\"\"\n        for node in self._iter_nodes():\n            if node.child:\n                child = node.child\n                while True:\n                    if node.key > child.key:\n                        return False\n                    if child.parent != node:\n                        return False # Parent pointer check\n                    if child.right == node.child:\n                        break\n                    child = child.right\n        return True\n\n    def _check_min_pointer(self):\n        \"\"\"Checks if min_node points to a root with the minimum key.\"\"\"\n        if self.num_nodes == 0:\n            return self.min_node is None\n        \n        if self.min_node is None:\n            return False\n            \n        if self.min_node.parent is not None:\n            return False # Min node must be a root\n\n        actual_min_key = float('inf')\n        for node in self._iter_nodes():\n            actual_min_key = min(actual_min_key, node.key)\n\n        return self.min_node.key == actual_min_key\n    \n    def get_any_non_root(self):\n        for node in self._iter_nodes():\n            if node.parent is not None:\n                return node\n        return None\n\nclass CorrectFibHeap(BaseFibHeap):\n    \"\"\"A correct implementation of a Fibonacci heap.\"\"\"\n    def decrease_key(self, x, k):\n        if k > x.key:\n            raise ValueError(\"New key is greater than current key\")\n        x.key = k\n        p = x.parent\n        if p is not None and x.key < p.key:\n            self._cut(x, p)\n            self._cascading_cut(p)\n        if x.key < self.min_node.key:\n            self.min_node = x\n\n    def _cut(self, x, p):\n        self._remove_from_list(x)\n        if x.right == x:\n            p.child = None\n        else:\n            p.child = x.right\n        p.degree -= 1\n        self._add_to_root_list(x)\n        x.parent = None\n        x.mark = False\n\n    def _cascading_cut(self, p):\n        pp = p.parent\n        if pp is not None:\n            if not p.mark:\n                p.mark = True\n            else:\n                self._cut(p, pp)\n                self._cascading_cut(pp)\n\nclass FaultyFibHeap(BaseFibHeap):\n    \"\"\"A faulty implementation of a Fibonacci heap for testing.\"\"\"\n    def decrease_key(self, x, k):\n        if k > x.key:\n            raise ValueError(\"New key is greater than current key\")\n        x.key = k\n        # Intentionally does not perform cuts or update min_node\n\ndef run_sequence(sequence_id):\n    \"\"\"Runs a test sequence on both correct and faulty heaps.\"\"\"\n    correct_heap = CorrectFibHeap()\n    faulty_heap = FaultyFibHeap()\n\n    if sequence_id == 1:\n        keys_to_insert = [20, 7, 25, 17, 26, 18]\n        for key in keys_to_insert:\n            correct_heap.insert(key)\n            faulty_heap.insert(key)\n        \n        correct_heap.extract_min()\n        faulty_heap.extract_min()\n        \n        node_c = correct_heap.get_any_non_root()\n        node_f = faulty_heap.nodes_by_initial_key[node_c.initial_key]\n        \n        parent_key = node_c.parent.key\n        new_key = parent_key - 5\n        \n        correct_heap.decrease_key(node_c, new_key)\n        faulty_heap.decrease_key(node_f, new_key)\n\n    elif sequence_id == 2:\n        keys_to_insert = [30, 10, 40]\n        for key in keys_to_insert:\n            correct_heap.insert(key)\n            faulty_heap.insert(key)\n        \n        node_c = correct_heap.nodes_by_initial_key[30]\n        node_f = faulty_heap.nodes_by_initial_key[30]\n        \n        correct_heap.decrease_key(node_c, 5)\n        faulty_heap.decrease_key(node_f, 5)\n\n    elif sequence_id == 3:\n        keys_to_insert = [50, 60, 70, 80]\n        for key in keys_to_insert:\n            correct_heap.insert(key)\n            faulty_heap.insert(key)\n        \n        correct_heap.extract_min()\n        faulty_heap.extract_min()\n\n        node_c = correct_heap.get_any_non_root()\n        node_f = faulty_heap.nodes_by_initial_key[node_c.initial_key]\n\n        new_key = node_c.parent.key\n\n        correct_heap.decrease_key(node_c, new_key)\n        faulty_heap.decrease_key(node_f, new_key)\n        \n    correct_valid = correct_heap.check_invariants()\n    faulty_valid = faulty_heap.check_invariants()\n\n    return correct_valid and not faulty_valid\n\ndef solve():\n    \"\"\"\n    Main function to execute the test sequences and print results.\n    \"\"\"\n    results = [\n        run_sequence(1),\n        run_sequence(2),\n        run_sequence(3)\n    ]\n    \n    # Format the final output as a comma-separated list of lowercase booleans\n    # e.g., [true,false,true]\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```", "id": "3234524"}, {"introduction": "Mastery of a data structure involves not just implementing its standard operations but also extending its capabilities. This exercise requires you to design and implement a `split` operation, which partitions a heap into two new heaps based on a key value. This task tests your ability to use the fundamental, trusted operations as building blocks to construct a more complex and useful algorithm ([@problem_id:3234478]).", "problem": "Design and implement a complete, runnable program that realizes a split operation on a Fibonacci heap (FH). A Fibonacci heap is a collection of heap-ordered trees that supports a set of operations with low amortized time. The fundamental base for the design must be the heap-order property: for every parent node with key value $k_p$ and any of its child nodes with key value $k_c$, the relation $k_p \\le k_c$ holds. The heap is represented as a circular, doubly linked list of roots, each root being the entry point to one heap-ordered tree. The key structural invariants to preserve in any algorithm are: the heap-order property, the circular doubly linked list structure among roots, correct parent-child relationships, and a pointer to a minimum-key root in the heap.\n\nYour task is to:\n- Derive, from the heap-order property, a correct algorithm to split a given Fibonacci heap $H$ into two Fibonacci heaps ($H_{\\le}$, $H_{>}$) according to a threshold $x \\in \\mathbb{Z}$, such that $H_{\\le}$ contains exactly the elements of $H$ whose keys $k$ satisfy $k \\le x$, and $H_{>}$ contains exactly the elements whose keys $k$ satisfy $k > x$.\n- Implement the algorithm in a program that constructs Fibonacci heaps from given sequences of integer keys, optionally performs a specified number of minimum extractions to create nontrivial tree structures, and then applies the split to produce ($H_{\\le}$, $H_{>}$).\n- For each test case, compute and return quantifiable results that allow automatic verification:\n  - $c_{\\le}$: the count of keys in $H_{\\le}$ (an integer).\n  - $c_{>}$: the count of keys in $H_{>}$ (an integer).\n  - $s_{\\le}$: the sum of keys in $H_{\\le}$ (an integer).\n  - $s_{>}$: the sum of keys in $H_{>}$ (an integer).\n  - $m_{\\le}$: the minimum key in $H_{\\le}$, or $-1$ if $H_{\\le}$ is empty (an integer).\n  - $m_{>}$: the minimum key in $H_{>}$, or $-1$ if $H_{>}$ is empty (an integer).\n  - $v$: a boolean flag that is true if and only if all the following hold:\n    - Every key in $H_{\\le}$ satisfies $k \\le x$, and every key in $H_{>}$ satisfies $k > x$.\n    - The multiset union of keys in $H_{\\le}$ and $H_{>}$ equals the original multiset of keys in $H$.\n    - Both $H_{\\le}$ and $H_{>}$ satisfy the heap-order property and have correct minimum pointers (if nonempty), i.e., the stored minimum equals the smallest key present.\n\nProgram requirements:\n- Represent Fibonacci heaps with explicit nodes having fields for key, degree, mark, parent, one child pointer, and left and right sibling pointers forming circular doubly linked lists.\n- Use only logically sound, standard operations derived from the definition: insertion, union (meld), and `extract-min` with consolidation by repeated linking of equal-degree trees.\n- The split algorithm must be derived from the heap-order property, and may be implemented by traversing all nodes of $H$ exactly once and inserting each key into the appropriate target heap. Insertion into a Fibonacci heap runs in amortized $O(1)$ time; traversal visits each node a constant number of times, so the total amortized time is $O(n)$ where $n$ is the number of nodes.\n\nTest suite and construction protocol:\n- For each test case, the heap $H$ is constructed by inserting keys in the given sequence. Then, perform exactly $e$ `extract-min` operations (if $H$ becomes empty before $e$ extractions, ignore further extractions). Finally, execute split at threshold $x$.\n- Use the following test suite, where each test case is a triple `$(\\langle k_1, k_2, \\dots, k_m \\rangle, x, e)`:\n  - Test $1$: $\\left(\\langle 7, 3, 18, 39, 52, 41, 17, 30, 24, 26, 46 \\rangle, x = 30, e = 1\\right)$.\n  - Test $2$: $\\left(\\langle 1, 2, 2, 2, 3 \\rangle, x = 3, e = 0\\right)$.\n  - Test $3$: $\\left(\\langle 10, 11, 12 \\rangle, x = 5, e = 0\\right)$.\n  - Test $4$: $\\left(\\langle -5, -1, 0, 0, 6, 6, 7 \\rangle, x = 0, e = 2\\right)$.\n  - Test $5$: $\\left(\\langle \\rangle, x = 0, e = 0\\right)$ (empty heap).\n  - Test $6$: $\\left(\\langle 5, 5, 5 \\rangle, x = 5, e = 1\\right)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the per-test-case list `[$c_{\\le}, c_{>}, s_{\\le}, s_{>}, m_{\\le}, m_{>}, v]`. For example, a line of the form `[[...],[...],...]`.\n- No input is read from standard input. All computations are determined by the compiled-in test suite.\n- There are no physical units or angles involved; all keys and outputs are unitless integers or booleans.", "solution": "The problem requires the design and implementation of a `split` operation for a Fibonacci heap. A given Fibonacci heap $H$ is to be partitioned into two new Fibonacci heaps, $H_{\\le}$ and $H_{>}$, based on a specified integer threshold $x$. $H_{\\le}$ must contain all elements from $H$ with keys $k \\le x$, and $H_{>}$ must contain all elements with keys $k > x$. The algorithm must be derived from the fundamental heap-order property, and the solution must include a complete, runnable program that implements the heap, the split operation, and computes several verification metrics for a given test suite.\n\nA Fibonacci heap is a specific implementation of a priority queue that consists of a collection of heap-ordered trees. The roots of these trees are maintained in a circular, doubly linked list. The defining characteristic is the **heap-order property**: for any node $p$ with key $k_p$ and any of its children $c$ with key $k_c$, the inequality $k_p \\le k_c$ must hold. This property implies that keys along any path from a root to a leaf are non-decreasing. The heap maintains a pointer, `min_node`, to the root with the minimum key, allowing for $O(1)$ access to the minimum element. The primary operations are insertion, finding the minimum, extracting the minimum, decreasing a key, and merging (union). The efficiency of a Fibonacci heap stems from its \"lazy\" nature, where structural work is deferred until an `extract-min` operation is performed.\n\nThe task is to design a `split(H, x)` algorithm. To partition the set of keys in $H$, every key must be inspected to determine if it is less than or equal to $x$ or greater than $x$. Therefore, a complete traversal of all nodes in the heap $H$ is necessary, which takes $O(n)$ time where $n$ is the number of nodes in $H$. Let a node in this traversal be denoted by $u$.\n\nThe core of the derivation relates to the heap-order property. The resulting structures, $H_{\\le}$ and $H_{>}$, must themselves be valid Fibonacci heaps, which means they must satisfy all structural invariants, chief among them being the heap-order property. A robust and straightforward method to guarantee this is to construct $H_{\\le}$ and $H_{>}$ from the ground up using a sequence of valid heap operations.\n\nThe proposed algorithm is as follows:\n1. Initialize two new, empty Fibonacci heaps, $H_{\\le}$ and $H_{>}$.\n2. Traverse every node $u$ in the original heap $H$. This can be accomplished with a breadth-first or depth-first search starting from the roots in the root list.\n3. For each node $u$ with key $k$, compare $k$ with the threshold $x$.\n   - If $k \\le x$, insert the key $k$ into $H_{\\le}$ using its standard `insert` operation.\n   - If $k > x$, insert the key $k$ into $H_{>}$ using its `insert` operation.\n4. After all nodes from $H$ have been processed, the heaps $H_{\\le}$ and $H_{>}$ contain the partitioned key sets and are, by construction, valid Fibonacci heaps.\n\nThis algorithm's correctness is directly \"derived from the heap-order property\" because the `insert` operation is fundamentally designed to preserve this property. By building the new heaps exclusively through `insert`, we ensure that the resulting structures are valid. While more complex in-place algorithms involving cutting subtrees and restructuring could be conceived, they offer no asymptotic time complexity advantage for this partitioning task and introduce significant opportunities for error. The traversal and re-insertion method leverages the proven correctness of the fundamental `insert` operation, which runs in $O(1)$ amortized time. Since the traversal visits each of the $n$ nodes once, the total amortized time complexity of the split operation is $O(n)$.\n\nThe implementation requires a complete Fibonacci heap data structure. A `Node` class encapsulates the fields: `key`, `degree` (number of children), `mark` (for `decrease-key` operations, though not central to this problem), `parent`, `child`, `left`, and `right` sibling pointers. The `FibonacciHeap` class manages the collection of nodes, maintaining a pointer to the minimum-key root `min_node` and a count of total nodes `num_nodes`. The key operations to implement are:\n- `insert(key)`: Creates a new single-node tree and adds it to the root list in $O(1)$ time.\n- `extract_min()`: Removes the minimum node, promotes its children to the root list, and calls `consolidate()` to restructure the heap. This is the most complex operation.\n- `consolidate()`: Merges trees in the root list so that no two trees have the same degree. This is achieved by iteratively linking trees of equal degree. It ensures the logarithmic bound on the maximum degree of any node.\n- `get_all_nodes()`: A traversal function to visit every node in the heap, necessary for both the `split` operation and for verification.\n- `split(x)`: Implements the traversal and re-insertion algorithm described above.\n\nFinally, for each test case, the program constructs a heap, performs a specified number of `extract-min` operations, and then executes the `split`. The results are verified by:\n1. Traversing the final heaps $H_{\\le}$ and $H_{>}$ to gather their keys.\n2. Computing the required metrics: counts ($c_{\\le}, c_{>}$), sums ($s_{\\le}, s_{>}$), and minima ($m_{\\le}, m_{>}$).\n3. Performing a series of checks for the boolean flag $v$:\n   - **Partitioning correctness**: Every key in $H_{\\le}$ must be $\\le x$, and every key in $H_{>}$ must be $> x$.\n   - **Key conservation**: The multiset union of keys in $H_{\\le}$ and $H_{>}$ must be identical to the multiset of keys in the original heap $H$ just before the split.\n   - **Heap validity**: Both $H_{\\le}$ and $H_{>}$ must be structurally valid Fibonacci heaps, which is verified by checking the heap-order property for all parent-child pairs and confirming that the `min_node` pointer is correct.\nThe collection of these metrics provides a comprehensive and automatically verifiable assessment of the algorithm's correctness.", "answer": "```python\nimport numpy as np\n\n# A meticulous and complete implementation of a Fibonacci Heap.\nclass FibonacciHeap:\n    \"\"\"\n    Implements a Fibonacci Heap data structure supporting insert, extract-min,\n    and a custom split operation.\n    \"\"\"\n    class Node:\n        \"\"\"Represents a node in the heap.\"\"\"\n        def __init__(self, key):\n            self.key = key\n            self.degree = 0\n            self.parent = None\n            self.child = None\n            self.left = self\n            self.right = self\n            self.mark = False\n\n    def __init__(self):\n        \"\"\"Initializes an empty Fibonacci Heap.\"\"\"\n        self.min_node = None\n        self.num_nodes = 0\n\n    def is_empty(self):\n        \"\"\"Returns True if the heap is empty, False otherwise.\"\"\"\n        return self.min_node is None\n\n    def insert(self, key):\n        \"\"\"Inserts a new key into the heap.\"\"\"\n        node = self.Node(key)\n        if self.min_node is None:\n            self.min_node = node\n        else:\n            # Add node to the root list\n            node.right = self.min_node.right\n            node.left = self.min_node\n            self.min_node.right.left = node\n            self.min_node.right = node\n            if key < self.min_node.key:\n                self.min_node = node\n        self.num_nodes += 1\n        return node\n\n    def get_min(self):\n        \"\"\"Returns the minimum key in the heap.\"\"\"\n        return self.min_node.key if self.min_node is not None else None\n\n    def _link(self, y, x):\n        \"\"\"Makes node y a child of node x.\"\"\"\n        # Remove y from root list\n        y.left.right = y.right\n        y.right.left = y.left\n        \n        # Make y a child of x\n        y.parent = x\n        if x.child is None:\n            x.child = y\n            y.right = y\n            y.left = y\n        else:\n            y.left = x.child\n            y.right = x.child.right\n            x.child.right.left = y\n            x.child.right = y\n        x.degree += 1\n        y.mark = False\n\n    def _consolidate(self):\n        \"\"\"Consolidates the root list to enforce the property of unique degrees.\"\"\"\n        if self.num_nodes <= 1:\n            return\n        \n        # The max degree is bounded by log_phi(n)\n        max_degree = int(np.floor(np.log(self.num_nodes) / np.log((1 + np.sqrt(5)) / 2))) + 2\n        A = [None] * max_degree\n        \n        roots = []\n        curr = self.min_node\n        start = self.min_node\n        if curr is None: return\n        while True:\n            roots.append(curr)\n            curr = curr.right\n            if curr == start:\n                break\n        \n        for root in roots:\n            x = root\n            d = x.degree\n            while A[d] is not None:\n                y = A[d]\n                if x.key > y.key:\n                    x, y = y, x\n                self._link(y, x)\n                A[d] = None\n                d += 1\n            A[d] = x\n\n        self.min_node = None\n        for node in A:\n            if node is not None:\n                if self.min_node is None:\n                    self.min_node = node\n                    node.left = node.right = node\n                else:\n                    node.left = self.min_node\n                    node.right = self.min_node.right\n                    self.min_node.right.left = node\n                    self.min_node.right = node\n                    if node.key < self.min_node.key:\n                        self.min_node = node\n\n    def extract_min(self):\n        \"\"\"Extracts the minimum node from the heap.\"\"\"\n        z = self.min_node\n        if z is not None:\n            # Add children to the root list\n            if z.child is not None:\n                child = z.child\n                while True:\n                    next_child = child.right\n                    child.parent = None\n                    # Add child to root list next to z\n                    child.left = z\n                    child.right = z.right\n                    z.right.left = child\n                    z.right = child\n                    if next_child == z.child:\n                        break\n                    child = next_child\n\n            # Remove z from the root list\n            z.left.right = z.right\n            z.right.left = z.left\n\n            if z == z.right:\n                self.min_node = None\n            else:\n                self.min_node = z.right\n                self._consolidate()\n            \n            self.num_nodes -= 1\n        return z\n\n    def get_all_nodes(self):\n        \"\"\"Returns a list of all nodes in the heap via a traversal.\"\"\"\n        if self.is_empty():\n            return []\n        \n        all_nodes = []\n        queue = []\n        visited_roots = set()\n\n        # Add all roots to the queue to start traversal\n        start_node = self.min_node\n        curr = start_node\n        while True:\n            if curr in visited_roots: break\n            visited_roots.add(curr)\n            queue.append(curr)\n            curr = curr.right\n            if curr == start_node: break\n        \n        head = 0\n        while head < len(queue):\n            node = queue[head]\n            head += 1\n            all_nodes.append(node)\n            \n            if node.child is not None:\n                child_start = node.child\n                curr_child = child_start\n                while True:\n                    queue.append(curr_child)\n                    curr_child = curr_child.right\n                    if curr_child == child_start: break\n        \n        return all_nodes\n\n    def split(self, x):\n        \"\"\"Splits the heap into two heaps based on threshold x.\"\"\"\n        nodes = self.get_all_nodes()\n        h_le = FibonacciHeap()\n        h_gt = FibonacciHeap()\n        for node in nodes:\n            if node.key <= x:\n                h_le.insert(node.key)\n            else:\n                h_gt.insert(node.key)\n        return h_le, h_gt\n\n    def is_valid(self):\n        \"\"\"Verifies the heap-order property and the min_node pointer.\"\"\"\n        if self.min_node is None:\n            return self.num_nodes == 0\n        \n        all_nodes = self.get_all_nodes()\n        if len(all_nodes) != self.num_nodes:\n            return False\n\n        if not all_nodes:\n            return self.num_nodes == 0\n\n        actual_min_key = float('inf')\n        for node in all_nodes:\n            actual_min_key = min(actual_min_key, node.key)\n            if node.parent is None: # It's a root\n                pass # No parent to check against\n            \n            if node.child is not None:\n                child_start = node.child\n                curr_child = child_start\n                while True:\n                    if curr_child.key < node.key: return False # Heap-order violation\n                    if curr_child.parent != node: return False # Parent pointer mismatch\n                    curr_child = curr_child.right\n                    if curr_child == child_start: break\n        \n        return self.min_node.key == actual_min_key\n\ndef solve():\n    \"\"\"\n    Runs the test suite for the Fibonacci heap split operation and prints results.\n    \"\"\"\n    test_cases = [\n        (tuple([7, 3, 18, 39, 52, 41, 17, 30, 24, 26, 46]), 30, 1),\n        (tuple([1, 2, 2, 2, 3]), 3, 0),\n        (tuple([10, 11, 12]), 5, 0),\n        (tuple([-5, -1, 0, 0, 6, 6, 7]), 0, 2),\n        (tuple([]), 0, 0),\n        (tuple([5, 5, 5]), 5, 1)\n    ]\n\n    final_results = []\n    for keys, x, e in test_cases:\n        h = FibonacciHeap()\n        for k in keys:\n            h.insert(k)\n\n        for _ in range(e):\n            if h.is_empty():\n                break\n            h.extract_min()\n\n        original_keys_after_extraction = sorted([node.key for node in h.get_all_nodes()])\n\n        h_le, h_gt = h.split(x)\n\n        keys_le = [node.key for node in h_le.get_all_nodes()]\n        keys_gt = [node.key for node in h_gt.get_all_nodes()]\n\n        c_le = len(keys_le)\n        c_gt = len(keys_gt)\n        s_le = sum(keys_le) if c_le > 0 else 0\n        s_gt = sum(keys_gt) if c_gt > 0 else 0\n        m_le = h_le.get_min() if c_le > 0 else -1\n        m_gt = h_gt.get_min() if c_gt > 0 else -1\n\n        v = True\n        # 1. Partition correctness\n        if not all(k = x for k in keys_le): v = False\n        if not all(k > x for k in keys_gt): v = False\n        # 2. Key conservation\n        if sorted(keys_le + keys_gt) != original_keys_after_extraction: v = False\n        # 3. Heap validity\n        if not h_le.is_valid(): v = False\n        if not h_gt.is_valid(): v = False\n\n        final_results.append([c_le, c_gt, s_le, s_gt, m_le, m_gt, v])\n\n    # Convert boolean v to lowercase string for final output\n    formatted_results = []\n    for res in final_results:\n        res[-1] = str(res[-1]).lower()\n        formatted_results.append(f'[{\",\".join(map(str, res))}]')\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3234478"}]}