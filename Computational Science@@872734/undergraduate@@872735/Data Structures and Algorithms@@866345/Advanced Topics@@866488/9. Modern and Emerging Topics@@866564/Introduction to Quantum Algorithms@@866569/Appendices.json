{"hands_on_practices": [{"introduction": "Before diving into quantum algorithms, it is crucial to understand why we cannot simply simulate them on classical computers for large systems. This exercise provides a direct, hands-on calculation to confront the exponential resources required to store the state of even a modest number of qubits [@problem_id:3242197]. By determining the exact memory cost as a function of the number of qubits $n$, you will gain a tangible appreciation for the sheer scale of the quantum state space and the fundamental challenge that motivates the entire field of quantum computing.", "problem": "Consider simulating a pure state of an $n$-qubit register on a classical computer. A pure state is a unit vector in a complex Hilbert space of dimension $2^{n}$, and in the computational basis it can be written as a column vector of $2^{n}$ complex probability amplitudes. To store this state vector exactly on a classical machine, you record each complex amplitude as two real-valued floating-point numbers of $b$ bytes each. Assume double precision, so $b = 8$.\n\nYou are given a machine with Random Access Memory (RAM) capacity $M = 256 \\times 2^{30}$ bytes (that is, $256$ gibibytes expressed in bytes). Ignore any additional overhead and assume the memory can be entirely devoted to storing the state vector.\n\nStarting only from the definition that the state space dimension is $2^{n}$ for $n$ qubits and that each complex amplitude consists of two real numbers, derive:\n\n- An expression, as a function of $n$, for the total number of real-valued floating-point numbers required to store the full state vector.\n- The maximum integer number of qubits $n$ such that the exact state vector fits in the given RAM.\n\nProvide your final answer as a row matrix, with the first entry being the expression for the number of floating-point numbers as a function of $n$, and the second entry being the maximum $n$ that fits under the memory constraint. No rounding is needed.", "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded, well-posed, objective, and contains all necessary information to derive a unique solution.\n\nThe problem asks for two quantities: first, an expression for the total number of real-valued floating-point numbers needed to store the state vector of an $n$-qubit system, and second, the maximum integer number of qubits, $n$, that can be simulated given a specific memory capacity.\n\nLet's begin by deriving the expression for the number of floating-point numbers.\nA pure quantum state of an $n$-qubit register is described by a state vector $|\\psi\\rangle$ in a complex Hilbert space $\\mathcal{H}$. The dimension of this space, $D$, is given by $D = 2^n$. This is because each of the $n$ qubits has a $2$-dimensional state space, and the state space of the composite system is the tensor product of the individual spaces, so the dimension is $2 \\times 2 \\times \\dots \\times 2$ ($n$ times), which equals $2^n$.\n\nIn the computational basis, the state vector $|\\psi\\rangle$ is represented as a linear combination of the $2^n$ basis vectors:\n$$|\\psi\\rangle = \\sum_{k=0}^{2^n - 1} c_k |k\\rangle$$\nwhere the coefficients $c_k$ are complex numbers known as probability amplitudes. The state is fully specified by the set of these $2^n$ complex amplitudes.\n\nTo store this state vector on a classical computer, we must store each of these $2^n$ complex numbers. A complex number $c_k$ can be written as $c_k = a_k + i b_k$, where $a_k$ and $b_k$ are real numbers representing the real and imaginary parts, respectively. The problem states that each complex amplitude is stored as two real-valued floating-point numbers.\n\nLet $N_{fp}(n)$ be the total number of real-valued floating-point numbers required. This is the product of the number of complex amplitudes and the number of real numbers required per complex amplitude.\n$$N_{fp}(n) = (\\text{Number of complex amplitudes}) \\times (\\text{Real numbers per complex amplitude})$$\nThe number of complex amplitudes is the dimension of the state space, which is $2^n$. The number of real numbers per complex amplitude is given as $2$.\nTherefore, the expression for the total number of floating-point numbers as a function of $n$ is:\n$$N_{fp}(n) = 2^n \\times 2 = 2^{n+1}$$\n\nNext, we determine the maximum integer number of qubits, $n_{max}$, that can be stored in the given RAM.\nThe total memory size required to store the state vector, let's call it $S(n)$, is the total number of floating-point numbers multiplied by the memory size of each number.\nThe problem specifies that each floating-point number is of size $b=8$ bytes (double precision).\nSo, the total memory required in bytes is:\n$$S(n) = N_{fp}(n) \\times b = 2^{n+1} \\times 8$$\nSince $8 = 2^3$, we can express $S(n)$ as a single power of $2$:\n$$S(n) = 2^{n+1} \\times 2^3 = 2^{n+4} \\text{ bytes}$$\nThe available RAM capacity is given as $M = 256 \\times 2^{30}$ bytes. We need to express $M$ as a power of $2$ for easier comparison. The number $256$ is $2^8$.\n$$M = 256 \\times 2^{30} = 2^8 \\times 2^{30} = 2^{38} \\text{ bytes}$$\nTo find the maximum number of qubits $n$, we must find the largest integer $n$ for which the required memory $S(n)$ does not exceed the available memory $M$. This can be expressed as the inequality:\n$$S(n) \\le M$$\nSubstituting the expressions for $S(n)$ and $M$:\n$$2^{n+4} \\le 2^{38}$$\nSince the base of the exponential function, $2$, is greater than $1$, the inequality holds for the exponents as well:\n$$n+4 \\le 38$$\nSolving for $n$:\n$$n \\le 38 - 4$$\n$$n \\le 34$$\nSince $n$ must be an integer, the maximum number of qubits that can be simulated under the given memory constraint is $n_{max} = 34$.\n\nThe two results are:\n1. The expression for the number of floating-point numbers is $2^{n+1}$.\n2. The maximum integer number of qubits is $34$.", "answer": "$$\\boxed{\\begin{pmatrix} 2^{n+1} & 34 \\end{pmatrix}}$$", "id": "3242197"}, {"introduction": "Now that we appreciate the cost of classical simulation, let's build a simulator ourselves to understand the mechanics from the ground up. This practice guides you through implementing a state-vector simulator, turning the abstract rules of quantum mechanics into concrete code [@problem_id:3242157]. By applying gates as matrix operations on a state vector, you will directly manipulate qubits and witness how phenomena like superposition and entanglement are created step by step.", "problem": "Design and implement a classical state-vector simulator for a quantum circuit on exactly $3$ qubits using explicit matrix-vector multiplication on the complex state vector. The computational basis is $\\{|000\\rangle, |001\\rangle, \\ldots, |111\\rangle\\}$, and a pure state on $n$ qubits is represented as a complex vector in $\\mathbb{C}^{2^n}$ with $\\ell_2$-norm equal to $1$. A single-qubit gate acting on qubit index $t$ (where the least significant bit is qubit index $0$) is represented by a $2\\times 2$ unitary matrix $U$ extended to the whole register by the Kronecker product with identities, and applied to the state by a matrix-vector product. A two-qubit controlled-NOT gate (control $c$, target $t$) permutes amplitudes as a linear operation that can also be realized by appropriate index swaps.\n\nFundamental base to use:\n- The state-update rule is linear: if a gate with matrix $G$ acts on the register, then the new state is $G\\psi$, where $\\psi\\in\\mathbb{C}^{2^n}$ is the current state.\n- The computational basis state $|q_{n-1}\\ldots q_1 q_0\\rangle$ corresponds to the integer index $\\sum_{k=0}^{n-1} q_k 2^k$ in little-endian order, where $q_k\\in\\{0,1\\}$.\n- Single-qubit gates act locally as $2\\times 2$ matrix-vector multiplications over disjoint pairs of amplitudes that differ only in the target qubit.\n\nYour tasks:\n1. Implement a simulator that:\n   - Initializes the state to $|000\\rangle$.\n   - Applies a sequence of gates specified as a circuit description. The supported gates are the Hadamard gate $H=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 & 1\\\\ 1 & -1\\end{pmatrix}$ on a specified qubit, the Pauli $X$ gate $X=\\begin{pmatrix}0 & 1\\\\ 1 & 0\\end{pmatrix}$ on a specified qubit, and the controlled-NOT gate on specified control and target qubits $(\\mathrm{CNOT}(c\\to t))$.\n   - Uses explicit matrix-vector multiplication semantics for single-qubit gates by updating each affected two-amplitude pair $\\begin{pmatrix}\\alpha\\\\ \\beta\\end{pmatrix}\\mapsto U\\begin{pmatrix}\\alpha\\\\ \\beta\\end{pmatrix}$.\n   - For $\\mathrm{CNOT}(c\\to t)$, updates amplitudes by swapping those basis indices where the control bit is $1$ and the target bit is $0$ with their counterparts where the target bit is $1$.\n2. Count primitive arithmetic operations performed by your implementation under the following uniform cost model:\n   - For each application of a single-qubit gate on $n$ qubits, count $4\\cdot 2^{n-1}$ complex multiplications and $2\\cdot 2^{n-1}$ complex additions.\n   - For each application of a controlled-NOT on $n$ qubits, count $3\\cdot 2^{n-2}$ scalar assignments due to swaps. Treat each swap as $3$ assignments.\n   - Report these counts accumulated over the whole circuit.\n3. For each test case below, compute the probability of measuring the basis state $|111\\rangle$ from the final state, which is the squared magnitude of the amplitude at index $7$ (in little-endian indexing as specified above).\n\nTest suite:\n- Case A (edge case, empty circuit): $n=3$, circuit depth $d=0$, no gates. Query probability of $|111\\rangle$.\n- Case B (uniform superposition): $n=3$, apply $H$ on qubits $0$, $1$, and $2$ in that order. Query probability of $|111\\rangle$.\n- Case C (entangling to a Greenberger–Horne–Zeilinger state): $n=3$, apply $H$ on qubit $0$, then $\\mathrm{CNOT}(0\\to 1)$, then $\\mathrm{CNOT}(1\\to 2)$. Query probability of $|111\\rangle$.\n- Case D (cancellation by involution): $n=3$, apply $X$ on qubit $2$ twice. Query probability of $|111\\rangle$.\n\nAnswer specification and final output format:\n- For each test case, your program must produce a list with six entries in this exact order:\n  - The probability of $|111\\rangle$ as a real number.\n  - The total number of complex multiplications counted.\n  - The total number of complex additions counted.\n  - The total number of scalar assignments due to swaps counted.\n  - The number of qubits $n$ used.\n  - The circuit depth $d$ (the number of gates in the circuit).\n- Aggregate the four per-case lists into a single list. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, in the shape $[\\text{caseA},\\text{caseB},\\text{caseC},\\text{caseD}]$, where each case is itself a list as defined above.\n\nYour analysis goal:\n- From first principles, derive the asymptotic runtime as a function of the number of qubits $n$ and the circuit depth $d$ under the stated cost model, without assuming any outcome. Interpret the per-case counts to justify an exponential dependence in $n$ and linear dependence in $d$ for circuits composed of $O(1)$-qubit gates. Do not provide shortcut formulas in the problem statement; show your reasoning in the solution. No physical units or angles are involved. All angles, if any, would be in radians, but none are used here.", "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded in the principles of quantum computation, well-posed with a clear objective and sufficient data, and free from ambiguity or contradiction. We may proceed with the solution.\n\nThe task is to design a classical state-vector simulator for a $3$-qubit quantum system and analyze its performance for specific circuits. The simulation proceeds by explicitly updating a complex vector representing the quantum state.\n\nA pure quantum state of $n$ qubits is represented by a state vector $\\psi$ in a complex Hilbert space of dimension $2^n$, i.e., $\\psi \\in \\mathbb{C}^{2^n}$. The vector is normalized such that its $\\ell_2$-norm is $1$, $\\|\\psi\\|_2 = 1$. The computational basis states are denoted by $|q_{n-1} \\ldots q_1 q_0 \\rangle$, where each $q_k \\in \\{0, 1\\}$. The problem specifies a little-endian mapping from these basis states to the indices of the state vector $\\psi$. The basis state $|q_{n-1} \\ldots q_1 q_0 \\rangle$ corresponds to the integer index $i = \\sum_{k=0}^{n-1} q_k 2^k$. For our case of $n=3$, the state vector $\\psi$ has $2^3 = 8$ complex components, indexed from $0$ to $7$. The basis state $|q_2 q_1 q_0 \\rangle$ maps to index $i = 4q_2 + 2q_1 + q_0$. The initial state is specified as $|000\\rangle$, which corresponds to index $0$. The initial state vector is therefore $\\psi_{initial} = [1, 0, 0, 0, 0, 0, 0, 0]^T$.\n\nThe evolution of the state under a quantum gate with matrix representation $G$ is given by the matrix-vector product $\\psi' = G\\psi$. For an $n$-qubit system, $G$ is a $2^n \\times 2^n$ unitary matrix. We implement the gate applications as specified.\n\nThe cost of simulation is measured by counting primitive arithmetic operations according to the provided uniform cost model:\n- For a single-qubit gate on $n$ qubits: $4 \\cdot 2^{n-1}$ complex multiplications and $2 \\cdot 2^{n-1}$ complex additions.\n- For a $\\mathrm{CNOT}$ gate on $n$ qubits: $3 \\cdot 2^{n-2}$ scalar assignments.\n\nThe probability of measuring a specific basis state, e.g., $|111\\rangle$ (which corresponds to index $i=7$), is given by the squared magnitude of the corresponding amplitude in the final state vector: $P(|111\\rangle) = |\\psi_{final}[7]|^2$.\n\n**Single-Qubit Gate Application**\nA single-qubit gate with matrix $U = \\begin{pmatrix} U_{00} & U_{01} \\\\ U_{10} & U_{11} \\end{pmatrix}$ acting on qubit $t$ is represented by the $2^n \\times 2^n$ matrix $G = I^{\\otimes(n-1-t)} \\otimes U \\otimes I^{\\otimes t}$. Applying this large matrix directly is inefficient. Instead, we use the specified local update rule. The gate only affects pairs of amplitudes corresponding to basis states that differ only in qubit $t$.\nFor each integer index $i$ from $0$ to $2^n-1$ where the $t$-th bit is $0$, we find its paired index $j = i + 2^t$, where the $t$-th bit is $1$. The amplitudes at these indices, $\\psi_i$ and $\\psi_j$, are updated according to the $2 \\times 2$ matrix $U$:\n$$\n\\begin{pmatrix} \\psi'_i \\\\ \\psi'_j \\end{pmatrix} = \\begin{pmatrix} U_{00} & U_{01} \\\\ U_{10} & U_{11} \\end{pmatrix} \\begin{pmatrix} \\psi_i \\\\ \\psi_j \\end{pmatrix} = \\begin{pmatrix} U_{00}\\psi_i + U_{01}\\psi_j \\\\ U_{10}\\psi_i + U_{11}\\psi_j \\end{pmatrix}\n$$\nThere are $2^{n-1}$ such pairs of indices. The update for each pair requires $4$ complex multiplications and $2$ complex additions. This gives a total of $4 \\cdot 2^{n-1}$ complex multiplications and $2 \\cdot 2^{n-1}$ complex additions per single-qubit gate application, perfectly matching the specified cost model. For $n=3$, this is $4 \\cdot 2^2 = 16$ multiplications and $2 \\cdot 2^2 = 8$ additions.\n\nThe specific single-qubit gates are the Hadamard gate $H = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & 1 \\\\ 1 & -1 \\end{pmatrix}$ and the Pauli-X gate $X = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}$.\n\n**Controlled-NOT (CNOT) Gate Application**\nThe $\\mathrm{CNOT}(c \\to t)$ gate flips the target qubit $t$ if and only if the control qubit $c$ is $1$. In the computational basis, this translates to a permutation: $\\mathrm{CNOT} |\\dots q_c \\dots q_t \\dots \\rangle = |\\dots q_c \\dots (q_t \\oplus q_c) \\dots \\rangle$. This only has an effect when $q_c=1$. Therefore, the operation swaps the amplitudes of basis states $|\\dots 1_c \\dots 0_t \\dots \\rangle$ and $|\\dots 1_c \\dots 1_t \\dots \\rangle$.\nIn terms of state vector indices, we must identify all indices $i$ that have the $c$-th bit set to $1$ and the $t$-th bit set to $0$. For each such $i$, the corresponding index $j$ is $i + 2^t$. The simulation then swaps the amplitudes $\\psi_i$ and $\\psi_j$. The number of such pairs to swap is the number of ways to choose the remaining $n-2$ bits, which is $2^{n-2}$. For $n=3$, this is $2^{3-2}=2$ pairs.\nThe cost model specifies that a swap requires $3$ scalar assignments. Thus, a $\\mathrm{CNOT}$ gate costs $3 \\cdot 2^{n-2}$ assignments. For $n=3$, this is $3 \\cdot 2^1 = 6$ assignments.\n\n**Asymptotic Runtime Analysis**\nThe state vector has a size of $N=2^n$. The cost of applying a single-qubit gate is $O(2^n)$. The cost of applying a two-qubit $\\mathrm{CNOT}$ gate is also $O(2^n)$. In general, simulating any gate acting on a constant number of qubits, $k$, requires updating tuples of $2^k$ amplitudes, across $2^{n-k}$ such tuples, leading to a computational cost of $O(2^n)$.\nFor a circuit with depth $d$ (here interpreted as total number of gates), the total simulation cost is the sum of costs for each gate. This results in a total runtime of $O(d \\cdot 2^n)$. This confirms the expected exponential dependence on the number of qubits $n$ and linear dependence on the circuit depth $d$.\n\n**Test Case Analysis**\n\n**Case A: Empty Circuit**\n- Circuit: None. $n=3$, $d=0$.\n- Initial state: $\\psi = |000\\rangle = [1, 0, 0, 0, 0, 0, 0, 0]^T$.\n- Final state: Unchanged, $\\psi_{final} = [1, 0, 0, 0, 0, 0, 0, 0]^T$.\n- Probability of $|111\\rangle$: $P(|111\\rangle) = |\\psi_{final}[7]|^2 = |0|^2 = 0$.\n- Operation Counts: No gates are applied.\n  - Complex multiplications: $0$.\n  - Complex additions: $0$.\n  - Swap assignments: $0$.\n- Result: $[0.0, 0, 0, 0, 3, 0]$.\n\n**Case B: Uniform Superposition**\n- Circuit: $H$ on qubit $0$, then $H$ on qubit $1$, then $H$ on qubit $2$. $n=3$, $d=3$.\n- State evolution:\n  - $\\psi_0 = |000\\rangle$.\n  - $\\psi_1 = H_0 \\psi_0 = \\frac{1}{\\sqrt{2}}(|000\\rangle + |001\\rangle)$.\n  - $\\psi_2 = H_1 \\psi_1 = \\frac{1}{2}(|000\\rangle + |001\\rangle + |010\\rangle + |011\\rangle)$.\n  - $\\psi_{final} = H_2 \\psi_2 = \\frac{1}{2\\sqrt{2}} \\sum_{i=0}^{7} |i\\rangle$.\n- In the final state, all amplitudes are $\\frac{1}{\\sqrt{8}}$.\n- Probability of $|111\\rangle$: $P(|111\\rangle) = |\\psi_{final}[7]|^2 = |\\frac{1}{\\sqrt{8}}|^2 = \\frac{1}{8} = 0.125$.\n- Operation Counts: $3$ single-qubit gates are applied.\n  - Cost per gate: $16$ mults, $8$ adds.\n  - Total mults: $3 \\times 16 = 48$.\n  - Total adds: $3 \\times 8 = 24$.\n  - Total swaps: $0$.\n- Result: $[0.125, 48, 24, 0, 3, 3]$.\n\n**Case C: GHZ State Preparation**\n- Circuit: $H$ on qubit $0$, then $\\mathrm{CNOT}(0 \\to 1)$, then $\\mathrm{CNOT}(1 \\to 2)$. $n=3$, $d=3$.\n- State evolution:\n  - $\\psi_0 = |000\\rangle$.\n  - $\\psi_1 = H_0 \\psi_0 = \\frac{1}{\\sqrt{2}}(|000\\rangle + |001\\rangle)$.\n  - $\\psi_2 = \\mathrm{CNOT}(0 \\to 1) \\psi_1 = \\frac{1}{\\sqrt{2}}(|000\\rangle + |011\\rangle)$. This is because the $|001\\rangle$ component has control bit $0$ equal to $1$, so the target bit $1$ is flipped.\n  - $\\psi_{final} = \\mathrm{CNOT}(1 \\to 2) \\psi_2 = \\frac{1}{\\sqrt{2}}(|000\\rangle + |111\\rangle)$. The $|000\\rangle$ component is unchanged (control bit $1$ is $0$). The $|011\\rangle$ component has control bit $1$ equal to $1$, so target bit $2$ is flipped ($|011\\rangle \\to |111\\rangle$).\n- The final state vector has non-zero amplitudes $\\psi_{final}[0] = \\frac{1}{\\sqrt{2}}$ and $\\psi_{final}[7] = \\frac{1}{\\sqrt{2}}$.\n- Probability of $|111\\rangle$: $P(|111\\rangle) = |\\psi_{final}[7]|^2 = |\\frac{1}{\\sqrt{2}}|^2 = \\frac{1}{2} = 0.5$.\n- Operation Counts: $1$ single-qubit gate and $2$ $\\mathrm{CNOT}$ gates.\n  - $H(0)$: $16$ mults, $8$ adds.\n  - $\\mathrm{CNOT}(0 \\to 1)$: $6$ swap assignments.\n  - $\\mathrm{CNOT}(1 \\to 2)$: $6$ swap assignments.\n  - Total mults: $16$.\n  - Total adds: $8$.\n  - Total swaps: $6 + 6 = 12$.\n- Result: $[0.5, 16, 8, 12, 3, 3]$.\n\n**Case D: Involution**\n- Circuit: $X$ on qubit $2$, then $X$ on qubit $2$. $n=3$, $d=2$.\n- State evolution: Since $X^2=I$ (the identity matrix), applying the gate twice is equivalent to doing nothing.\n  - $\\psi_0 = |000\\rangle$.\n  - $\\psi_1 = X_2 \\psi_0 = |100\\rangle$.\n  - $\\psi_{final} = X_2 \\psi_1 = X_2 |100\\rangle = |000\\rangle$.\n- The final state is the initial state $|000\\rangle$.\n- Probability of $|111\\rangle$: $P(|111\\rangle) = |\\psi_{final}[7]|^2 = |0|^2 = 0$.\n- Operation Counts: $2$ single-qubit gates are applied.\n  - Cost per gate: $16$ mults, $8$ adds.\n  - Total mults: $2 \\times 16 = 32$.\n  - Total adds: $2 \\times 8 = 16$.\n  - Total swaps: $0$.\n- Result: $[0.0, 32, 16, 0, 3, 2]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass QuantumCircuitSimulator:\n    \"\"\"\n    A classical state-vector simulator for a multi-qubit quantum circuit.\n    \"\"\"\n    def __init__(self, n: int):\n        \"\"\"\n        Initializes the simulator for n qubits in the |0...0> state.\n        \n        Args:\n            n (int): The number of qubits.\n        \"\"\"\n        if not isinstance(n, int) or n <= 0:\n            raise ValueError(\"Number of qubits n must be a positive integer.\")\n        self.n = n\n        self.num_states = 1 << n  # This is 2**n\n        \n        # State vector, initialized to |0...0>\n        self.state_vector = np.zeros(self.num_states, dtype=np.complex128)\n        self.state_vector[0] = 1.0\n\n        # Operation counters\n        self.op_counts = {\n            'complex_mult': 0,\n            'complex_add': 0,\n            'swap_assign': 0\n        }\n\n    def _apply_single_qubit_gate(self, U: np.ndarray, target_qubit: int):\n        \"\"\"\n        Applies a single-qubit gate U to the target qubit.\n        \n        Args:\n            U (np.ndarray): A 2x2 unitary matrix.\n            target_qubit (int): The index of the qubit to act on.\n        \"\"\"\n        U = U.flatten() # U00, U01, U10, U11\n        \n        for i in range(self.num_states):\n            # Check if the target bit is 0\n            if (i >> target_qubit) & 1 == 0:\n                j = i | (1 << target_qubit) # Index with target bit flipped to 1\n                \n                psi_i = self.state_vector[i]\n                psi_j = self.state_vector[j]\n                \n                # U is flattened: U[0]=U00, U[1]=U01, U[2]=U10, U[3]=U11\n                self.state_vector[i] = U[0] * psi_i + U[1] * psi_j\n                self.state_vector[j] = U[2] * psi_i + U[3] * psi_j\n        \n        # Update counts based on the problem's cost model\n        self.op_counts['complex_mult'] += 4 * (1 << (self.n - 1))\n        self.op_counts['complex_add'] += 2 * (1 << (self.n - 1))\n\n    def _apply_cnot_gate(self, control_qubit: int, target_qubit: int):\n        \"\"\"\n        Applies a CNOT gate.\n        \n        Args:\n            control_qubit (int): The index of the control qubit.\n            target_qubit (int): The index of the target qubit.\n        \"\"\"\n        for i in range(self.num_states):\n            # Check if control bit is 1 and target bit is 0\n            is_control_one = ((i >> control_qubit) & 1) == 1\n            is_target_zero = ((i >> target_qubit) & 1) == 0\n\n            if is_control_one and is_target_zero:\n                j = i | (1 << target_qubit) # Index with target bit flipped\n                # Swap amplitudes; temp var for swap\n                temp = self.state_vector[i]\n                self.state_vector[i] = self.state_vector[j]\n                self.state_vector[j] = temp\n        \n        # Update counts based on the problem's cost model\n        # For n qubits, there are 2^(n-2) pairs to swap.\n        # Each swap is 3 assignments.\n        if self.n >= 2:\n            self.op_counts['swap_assign'] += 3 * (1 << (self.n - 2))\n\n    def h(self, target_qubit: int):\n        \"\"\"Applies a Hadamard gate.\"\"\"\n        H = (1 / np.sqrt(2)) * np.array([[1, 1], [1, -1]], dtype=np.complex128)\n        self._apply_single_qubit_gate(H, target_qubit)\n\n    def x(self, target_qubit: int):\n        \"\"\"Applies a Pauli-X gate.\"\"\"\n        X = np.array([[0, 1], [1, 0]], dtype=np.complex128)\n        self._apply_single_qubit_gate(X, target_qubit)\n\n    def cnot(self, control_qubit: int, target_qubit: int):\n        \"\"\"Applies a CNOT gate.\"\"\"\n        self._apply_cnot_gate(control_qubit, target_qubit)\n\n    def get_prob(self, index: int) -> float:\n        \"\"\"Returns the probability of measuring the state at a given index.\"\"\"\n        amplitude = self.state_vector[index]\n        return np.abs(amplitude)**2\n\n    def get_result(self, prob_index: int, circuit_depth: int) -> list:\n        \"\"\"Formats the result for a given test case.\"\"\"\n        prob = self.get_prob(prob_index)\n        return [\n            prob,\n            self.op_counts['complex_mult'],\n            self.op_counts['complex_add'],\n            self.op_counts['swap_assign'],\n            self.n,\n            circuit_depth\n        ]\n\ndef format_list(data: list) -> str:\n    \"\"\"Formats a list into a string without spaces, e.g., [1,2,3].\"\"\"\n    return f\"[{','.join(map(str, data))}]\"\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all test cases and prints the final result.\n    \"\"\"\n    n_qubits = 3\n    prob_idx_111 = 7  # Index for |111> is 4*1 + 2*1 + 1*1 = 7\n\n    all_results = []\n\n    # Case A: Empty circuit\n    sim_a = QuantumCircuitSimulator(n_qubits)\n    depth_a = 0\n    all_results.append(sim_a.get_result(prob_idx_111, depth_a))\n\n    # Case B: Uniform superposition\n    sim_b = QuantumCircuitSimulator(n_qubits)\n    sim_b.h(0)\n    sim_b.h(1)\n    sim_b.h(2)\n    depth_b = 3\n    all_results.append(sim_b.get_result(prob_idx_111, depth_b))\n\n    # Case C: GHZ state\n    sim_c = QuantumCircuitSimulator(n_qubits)\n    sim_c.h(0)\n    sim_c.cnot(0, 1)\n    sim_c.cnot(1, 2)\n    depth_c = 3\n    all_results.append(sim_c.get_result(prob_idx_111, depth_c))\n\n    # Case D: Involution\n    sim_d = QuantumCircuitSimulator(n_qubits)\n    sim_d.x(2)\n    sim_d.x(2)\n    depth_d = 2\n    all_results.append(sim_d.get_result(prob_idx_111, depth_d))\n\n    # Format the final list of lists into a single string.\n    # The default str(list) adds spaces, which might not be desired.\n    # We follow the f-string template from the problem, which produces spaces.\n    results_str = ','.join([str(res) for res in all_results])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{results_str}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3242157"}, {"introduction": "Beyond basic gate operations, many quantum algorithms leverage unique dynamic processes that have no direct classical analog. This practice invites you to simulate and compare a classical random walk with its quantum counterpart, the Discrete-Time Quantum Walk (DTQW), on a cycle graph [@problem_id:3242062]. By tracking how the probability distribution spreads over time, you will observe the stark difference between classical diffusion and the faster, \"ballistic\" spreading in the quantum case, a direct result of constructive and destructive interference.", "problem": "You are to implement a simulation that compares the evolution over discrete time of the probability distributions generated by a classical random walk and a discrete-time quantum walk (DTQW) on the same cycle graph. The setting is purely mathematical and algorithmic, relying on core definitions from graph theory, probability, and quantum mechanics. The cycle graph of size $N$ has vertex set $\\{0,1,\\dots,N-1\\}$ and edges between $x$ and $(x\\pm 1) \\bmod N$. The classical random walk is a Markov chain with transition rule on the cycle that moves to either neighbor with equal probability. The discrete-time quantum walk uses a coin space of dimension $2$ and a shift operator that moves left or right according to the coin state.\n\nFundamental base and definitions to be used:\n- Let $N \\in \\mathbb{N}$ denote the number of vertices of the cycle graph, and let $x \\in \\{0,1,\\dots,N-1\\}$ denote a vertex index. Let the starting vertex be $x_0 \\in \\{0,1,\\dots,N-1\\}$.\n- The classical random walk distribution at time $t$, denoted $p^{\\mathrm{c}}_t(x)$ for $t \\in \\{0,1,\\dots,T\\}$, obeys the update rule $p^{\\mathrm{c}}_{t+1}(x)=\\frac{1}{2}\\,p^{\\mathrm{c}}_{t}((x-1)\\bmod N)+\\frac{1}{2}\\,p^{\\mathrm{c}}_{t}((x+1)\\bmod N)$ with initial condition $p^{\\mathrm{c}}_0(x)=1$ if $x=x_0$ and $0$ otherwise. This is a well-tested formula for the evolution of a symmetric random walk on a cycle.\n- The discrete-time quantum walk state lives in the Hilbert space $\\mathcal{H}_\\mathrm{coin}\\otimes\\mathcal{H}_\\mathrm{pos}$ where $\\mathcal{H}_\\mathrm{coin}$ is a two-dimensional complex vector space spanned by $\\{|0\\rangle,|1\\rangle\\}$ and $\\mathcal{H}_\\mathrm{pos}$ is an $N$-dimensional complex vector space spanned by $\\{|x\\rangle: x\\in\\{0,1,\\dots,N-1\\}\\}$. The coin operator $C$ is the Hadamard operator $H=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 & 1\\\\ 1 & -1\\end{pmatrix}$ acting on $\\mathcal{H}_\\mathrm{coin}$. The conditional shift operator $S$ acts by $S\\,|0\\rangle\\otimes|x\\rangle=|0\\rangle\\otimes|x-1 \\bmod N\\rangle$ and $S\\,|1\\rangle\\otimes|x\\rangle=|1\\rangle\\otimes|x+1 \\bmod N\\rangle$. One step of the quantum walk is the unitary $U=S\\,(H\\otimes I_N)$, where $I_N$ is the $N\\times N$ identity on $\\mathcal{H}_\\mathrm{pos}$. Let the initial state be $|\\psi_0\\rangle=\\left(\\frac{|0\\rangle + i\\,|1\\rangle}{\\sqrt{2}}\\right)\\otimes|x_0\\rangle$. The state evolves by $|\\psi_{t+1}\\rangle=U\\,|\\psi_t\\rangle$. The position probability distribution at time $t$ is $p^{\\mathrm{q}}_t(x)=\\sum_{c\\in\\{0,1\\}}|\\langle c|\\otimes\\langle x|\\psi_t\\rangle|^2$, per the Born rule.\n- Define the cycle geodesic distance from $x_0$ to $x$ as $d(x_0,x)=\\min\\left(\\left[(x-x_0)\\bmod N\\right],\\,N-\\left[(x-x_0)\\bmod N\\right]\\right)$. This counts the minimum number of steps along the cycle.\n- Define the root-mean-square displacement at time $t$ for a distribution $p_t$ as $\\mathrm{RMSD}(t)=\\sqrt{\\sum_{x=0}^{N-1}p_t(x)\\,d(x_0,x)^2}$.\n- To aggregate the comparison over time, compute the time-averaged difference in root-mean-square displacement between the quantum and classical walks over times $t\\in\\{0,1,\\dots,T\\}$, namely\n$$\n\\Delta(N,T,x_0)=\\frac{1}{T+1}\\sum_{t=0}^{T}\\left(\\mathrm{RMSD}^{\\mathrm{q}}(t)-\\mathrm{RMSD}^{\\mathrm{c}}(t)\\right),\n$$\nwhere $\\mathrm{RMSD}^{\\mathrm{q}}(t)$ and $\\mathrm{RMSD}^{\\mathrm{c}}(t)$ are computed from $p^{\\mathrm{q}}_t(x)$ and $p^{\\mathrm{c}}_t(x)$ respectively.\n\nYour task is to write a complete, runnable program that:\n- Constructs the unitary $U$ and simulates $|\\psi_t\\rangle$ for $t\\in\\{0,1,\\dots,T\\}$ from the specified initial state.\n- Simulates the classical distribution $p^{\\mathrm{c}}_t(x)$ for $t\\in\\{0,1,\\dots,T\\}$ from the specified initial condition.\n- Computes $p^{\\mathrm{q}}_t(x)$ and $p^{\\mathrm{c}}_t(x)$ at each time $t$, evaluates $\\mathrm{RMSD}^{\\mathrm{q}}(t)$ and $\\mathrm{RMSD}^{\\mathrm{c}}(t)$, and returns $\\Delta(N,T,x_0)$ rounded to six decimal places for each test case defined below.\n\nTest suite:\n- Case $1$: $(N,T,x_0)=(32,12,0)$, general happy path with sufficiently large cycle to observe ballistic versus diffusive spreading without immediate wrap-around.\n- Case $2$: $(N,T,x_0)=(6,0,0)$, boundary condition in time where only the initial distributions matter.\n- Case $3$: $(N,T,x_0)=(4,2,0)$, small cycle where wrap-around and interference effects are significant.\n- Case $4$: $(N,T,x_0)=(50,20,17)$, larger cycle with a nonzero starting vertex index to demonstrate translation invariance.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite above. For example, in the schematic format $[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4]$, where each $\\Delta_k$ is the rounded float for Case $k$ as defined.", "solution": "The user's request is to implement a comparative simulation of a classical random walk and a discrete-time quantum walk (DTQW) on a cycle graph. The problem is validated as sound, well-posed, and scientifically grounded in the principles of Markov chains and quantum mechanics.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n\n- **Graph:** Cycle graph with $N$ vertices, labeled $\\{0, 1, \\dots, N-1\\}$. Edges exist between $x$ and $(x \\pm 1) \\pmod N$.\n- **Parameters:** Number of vertices $N$, total time steps $T$, starting vertex $x_0$.\n- **Classical Random Walk (CRW):**\n    - Probability distribution at time $t$: $p^{\\mathrm{c}}_t(x)$.\n    - Initial condition: $p^{\\mathrm{c}}_0(x) = \\delta_{x, x_0}$, where $\\delta$ is the Kronecker delta.\n    - Update rule: $p^{\\mathrm{c}}_{t+1}(x) = \\frac{1}{2} p^{\\mathrm{c}}_t((x-1) \\pmod N) + \\frac{1}{2} p^{\\mathrm{c}}_t((x+1) \\pmod N)$.\n- **Discrete-Time Quantum Walk (DTQW):**\n    - Hilbert Space: $\\mathcal{H} = \\mathcal{H}_{\\mathrm{coin}} \\otimes \\mathcal{H}_{\\mathrm{pos}}$, with $\\mathrm{dim}(\\mathcal{H}_{\\mathrm{coin}}) = 2$ and $\\mathrm{dim}(\\mathcal{H}_{\\mathrm{pos}}) = N$.\n    - Basis states: Coin space $\\{|0\\rangle, |1\\rangle\\}$, Position space $\\{|x\\rangle\\}_{x=0}^{N-1}$.\n    - Coin Operator: Hadamard operator $H = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & 1 \\\\ 1 & -1 \\end{pmatrix}$.\n    - Conditional Shift Operator: $S(|0\\rangle \\otimes |x\\rangle) = |0\\rangle \\otimes |(x-1) \\pmod N\\rangle$ and $S(|1\\rangle \\otimes |x\\rangle) = |1\\rangle \\otimes |(x+1) \\pmod N\\rangle$.\n    - Walk Operator (one step): $U = S(H \\otimes I_N)$.\n    - Initial state: $|\\psi_0\\rangle = \\left(\\frac{|0\\rangle + i|1\\rangle}{\\sqrt{2}}\\right) \\otimes |x_0\\rangle$.\n    - State evolution: $|\\psi_{t+1}\\rangle = U|\\psi_t\\rangle$.\n    - Probability distribution: $p^{\\mathrm{q}}_t(x) = \\sum_{c \\in \\{0,1\\}} |\\langle c| \\otimes \\langle x | \\psi_t \\rangle|^2$.\n- **Metrics:**\n    - Geodesic distance: $d(x_0, x) = \\min([(x-x_0) \\pmod N], N - [(x-x_0) \\pmod N])$.\n    - Root-Mean-Square Displacement (RMSD): $\\mathrm{RMSD}(t) = \\sqrt{\\sum_{x=0}^{N-1} p_t(x) d(x_0, x)^2}$.\n    - Target quantity: $\\Delta(N, T, x_0) = \\frac{1}{T+1} \\sum_{t=0}^{T} (\\mathrm{RMSD}^{\\mathrm{q}}(t) - \\mathrm{RMSD}^{\\mathrm{c}}(t))$.\n- **Test Suite:**\n    - Case 1: $(N, T, x_0) = (32, 12, 0)$\n    - Case 2: $(N, T, x_0) = (6, 0, 0)$\n    - Case 3: $(N, T, x_0) = (4, 2, 0)$\n    - Case 4: $(N, T, x_0) = (50, 20, 17)$\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is a standard, formal computational task based on established models in theoretical physics and computer science.\n- **Scientifically Grounded:** The definitions for the classical random walk (a symmetric Markov chain on a cycle) and the discrete-time quantum walk (using a Hadamard coin) are canonical in their respective fields. All mathematical formulations are correct.\n- **Well-Posed:** The problem provides all necessary initial conditions, evolution rules, and a precisely defined target quantity. For any given valid input tuple $(N, T, x_0)$, the simulation is deterministic and yields a unique, meaningful result.\n- **Objective:** The problem is stated in precise, mathematical language, free from ambiguity or subjective interpretation.\n- The problem passes all checks for validity. It is not unsound, incomplete, ill-posed, or trivial.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. A reasoned solution will be developed.\n\n### **Methodology and Implementation**\n\nThe core of the task is to simulate the time evolution of two systems—one classical, one quantum—and compare their statistical properties. This will be implemented programmatically using NumPy for efficient vectorized computation.\n\n**1. Common Setup**\n\nFor each test case $(N, T, x_0)$, we first compute the squared geodesic distances from the starting vertex $x_0$ to all other vertices $x$ on the cycle. An array of vertices is created as $v = \\{0, 1, \\dots, N-1\\}$. The distance $d(x_0, x)$ is calculated for each $x \\in v$, squared, and stored in an array, $d^2$, for repeated use in the RMSD calculations.\nLet $v$ be an array of vertex indices from $0$ to $N-1$.\nThe distances modulo $N$ are calculated as $\\delta_x = (v - x_0) \\pmod N$.\nThe geodesic distances are $d_x = \\min(\\delta_x, N - \\delta_x)$.\nThe squared distances are $d^2_x = d_x^2$.\n\n**2. Classical Random Walk Simulation**\n\nThe classical probability distribution $p^{\\mathrm{c}}_t$ is represented by a 1D NumPy array of size $N$.\n- **Initialization ($t=0$):** The distribution is a delta function at the start vertex. $p^{\\mathrm{c}}_0$ is an array of zeros, with the element at index $x_0$ set to $1.0$.\n- **Time Evolution ($t \\to t+1$):** The update rule $p^{\\mathrm{c}}_{t+1}(x) = \\frac{1}{2}p^{\\mathrm{c}}_{t}((x-1)\\pmod N)+\\frac{1}{2}p^{\\mathrm{c}}_{t}((x+1)\\pmod N)$ describes a convolution. This can be efficiently implemented using array shifts. If $p^{\\mathrm{c}}_t$ is the array for the distribution at time $t$, then the array for time $t+1$ is given by $p^{\\mathrm{c}}_{t+1} = 0.5 \\times (\\mathrm{roll}(p^{\\mathrm{c}}_t, 1) + \\mathrm{roll}(p^{\\mathrm{c}}_t, -1))$, where $\\mathrm{roll}(A, k)$ shifts the elements of array $A$ by $k$ positions cyclically.\n- **Simulation Loop:** We iterate from $t=0$ to $T$. In each step, we first calculate $\\mathrm{RMSD}^{\\mathrm{c}}(t) = \\sqrt{\\sum_x p^{\\mathrm{c}}_t(x) d^2_x}$, then we update the distribution $p^{\\mathrm{c}}_t$ to $p^{\\mathrm{c}}_{t+1}$.\n\n**3. Discrete-Time Quantum Walk Simulation**\n\nThe quantum state $|\\psi_t\\rangle \\in \\mathcal{H}_{\\mathrm{coin}} \\otimes \\mathcal{H}_{\\mathrm{pos}}$ is represented by a 1D complex NumPy array of size $2N$. We adopt a convenient indexing scheme where indices $0, \\dots, N-1$ correspond to the state $|0\\rangle \\otimes |x\\rangle$ for $x=0, \\dots, N-1$, and indices $N, \\dots, 2N-1$ correspond to $|1\\rangle \\otimes |x\\rangle$. The state vector can thus be conceptually split into two sub-vectors of size $N$: $|\\psi\\rangle_0$ (for coin state $|0\\rangle$) and $|\\psi\\rangle_1$ (for coin state $|1\\rangle$).\n- **Initialization ($t=0$):** The initial state is $|\\psi_0\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle \\otimes |x_0\\rangle + i|1\\rangle \\otimes |x_0\\rangle)$. The corresponding state vector is initialized to zeros, except for the element at index $x_0$ which is set to $1/\\sqrt{2}$, and the element at index $N+x_0$ which is set to $i/\\sqrt{2}$.\n- **Time Evolution ($t \\to t+1$):** A single step is the application of the unitary operator $U=S(H \\otimes I_N)$. This is performed in two sub-steps without constructing the full $2N \\times 2N$ matrices.\n    1.  **Coin Operator $(H \\otimes I_N)$:** Applying this to the state $|\\psi\\rangle = (|\\psi\\rangle_0, |\\psi\\rangle_1)$ yields a new state $|\\psi'\\rangle = (|\\psi'\\rangle_0, |\\psi'\\rangle_1)$, where $|\\psi'\\rangle_0 = \\frac{1}{\\sqrt{2}}(|\\psi\\rangle_0 + |\\psi\\rangle_1)$ and $|\\psi'\\rangle_1 = \\frac{1}{\\sqrt{2}}(|\\psi\\rangle_0 - |\\psi\\rangle_1)$.\n    2.  **Shift Operator $(S)$:** This operator acts on $|\\psi'\\rangle$. The sub-vector for coin state $|0\\rangle$ is shifted left (negative direction), and the sub-vector for coin state $|1\\rangle$ is shifted right (positive direction). The next state is $|\\psi_{t+1}\\rangle_0 = \\mathrm{roll}(|\\psi'\\rangle_0, -1)$ and $|\\psi_{t+1}\\rangle_1 = \\mathrm{roll}(|\\psi'\\rangle_1, 1)$.\n- **Simulation Loop:** We iterate from $t=0$ to $T$. In each step, we first calculate the position probability distribution $p^{\\mathrm{q}}_t(x) = |(|\\psi_t\\rangle_0)_x|^2 + |(|\\psi_t\\rangle_1)_x|^2$. From this, we compute $\\mathrm{RMSD}^{\\mathrm{q}}(t) = \\sqrt{\\sum_x p^{\\mathrm{q}}_t(x) d^2_x}$. Then we evolve the state $|\\psi_t\\rangle$ to $|\\psi_{t+1}\\rangle$.\n\n**4. Final Calculation**\n\nAfter running both simulations for $t \\in \\{0, \\dots, T\\}$, we will have collected two lists of values: $\\{\\mathrm{RMSD}^{\\mathrm{c}}(t)\\}_{t=0}^T$ and $\\{\\mathrm{RMSD}^{\\mathrm{q}}(t)\\}_{t=0}^T$. The final quantity, $\\Delta(N, T, x_0)$, is computed as the mean of the element-wise differences between these two lists.\n\nThis procedure is systematically applied to each test case specified in the problem statement. The results are then formatted as requested.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_delta(N, T, x_0):\n    \"\"\"\n    Simulates classical and quantum walks on a cycle graph and calculates the\n    time-averaged difference in their root-mean-square displacements.\n\n    Args:\n        N (int): The number of vertices in the cycle graph.\n        T (int): The number of time steps for the simulation.\n        x_0 (int): The starting vertex index.\n\n    Returns:\n        float: The calculated value of Delta(N, T, x_0), rounded to 6 decimal places.\n    \"\"\"\n    # 1. Common setup: Pre-calculate squared geodesic distances\n    positions = np.arange(N, dtype=np.float64)\n    # Distances from x_0, considering the cycle's wrap-around\n    d_mod = (positions - x_0) % N\n    distances = np.minimum(d_mod, N - d_mod)\n    distances_sq = distances**2\n\n    # Lists to store RMSD values for each time step\n    rmsd_c_t = np.zeros(T + 1, dtype=np.float64)\n    rmsd_q_t = np.zeros(T + 1, dtype=np.float64)\n\n    # --- 2. Classical Random Walk Simulation ---\n    # Initial probability distribution p_c at t=0\n    p_c = np.zeros(N, dtype=np.float64)\n    p_c[x_0] = 1.0\n\n    for t in range(T + 1):\n        # Calculate RMSD for the current classical distribution\n        rmsd_c_t[t] = np.sqrt(np.sum(p_c * distances_sq))\n        \n        # Evolve the classical distribution for the next step (if not the last step)\n        if t < T:\n            # p_{t+1}(x) = 0.5 * p_t(x-1) + 0.5 * p_t(x+1)\n            # np.roll(p_c, 1) shifts right, getting p_t(x-1) at index x\n            # np.roll(p_c, -1) shifts left, getting p_t(x+1) at index x\n            p_c = 0.5 * (np.roll(p_c, 1) + np.roll(p_c, -1))\n\n    # --- 3. Discrete-Time Quantum Walk Simulation ---\n    # State psi is a 2N-dimensional complex vector.\n    # Indices 0 to N-1 for coin state |0>\n    # Indices N to 2N-1 for coin state |1>\n    psi = np.zeros(2 * N, dtype=np.complex128)\n    \n    # Initial state: (1/sqrt(2)) * (|0> + i|1>) @ |x_0>\n    sqrt2_inv = 1.0 / np.sqrt(2.0)\n    psi[x_0] = sqrt2_inv\n    psi[N + x_0] = 1j * sqrt2_inv\n\n    for t in range(T + 1):\n        # Calculate position probability distribution p_q from the quantum state\n        # p_q(x) = |<0,x|psi>|^2 + |<1,x|psi>|^2\n        psi_0_part = psi[:N]\n        psi_1_part = psi[N:]\n        p_q = np.abs(psi_0_part)**2 + np.abs(psi_1_part)**2\n\n        # Calculate RMSD for the current quantum distribution\n        rmsd_q_t[t] = np.sqrt(np.sum(p_q * distances_sq))\n\n        # Evolve the quantum state using U = S(H @ I)\n        if t < T:\n            # a. Apply Coin operator (Hadamard)\n            psi_prime_0 = sqrt2_inv * (psi_0_part + psi_1_part)\n            psi_prime_1 = sqrt2_inv * (psi_0_part - psi_1_part)\n\n            # b. Apply Shift operator\n            # S|0>|x> -> |0>|x-1>, a left shift for the |0> component\n            # S|1>|x> -> |1>|x+1>, a right shift for the |1> component\n            psi[:N] = np.roll(psi_prime_0, -1)\n            psi[N:] = np.roll(psi_prime_1, 1)\n            \n    # --- 4. Final Calculation ---\n    # Calculate the time-averaged difference of RMSDs\n    delta = np.mean(rmsd_q_t - rmsd_c_t)\n\n    return round(delta, 6)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, T, x_0)\n        (32, 12, 0),   # Case 1\n        (6, 0, 0),     # Case 2\n        (4, 2, 0),     # Case 3\n        (50, 20, 17),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        N, T, x_0 = case\n        result = calculate_delta(N, T, x_0)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3242062"}]}