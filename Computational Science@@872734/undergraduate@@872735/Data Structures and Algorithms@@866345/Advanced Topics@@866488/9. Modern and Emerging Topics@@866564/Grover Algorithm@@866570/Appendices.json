{"hands_on_practices": [{"introduction": "Grover's algorithm relies on a special subroutine called an oracle, which uniquely identifies the items being searched for. This first practice demystifies the \"black box\" nature of the oracle by challenging you to represent it in several concrete mathematical forms. Understanding these different representations—from abstract operators to realizable quantum circuits—is a crucial first step toward implementing the algorithm [@problem_id:1426367].", "problem": "In the theory of quantum computation, Grover's algorithm provides a significant speedup for searching an unstructured database. A key component of the algorithm is a \"black-box\" operator called an oracle, $U_f$, which identifies the desired item(s).\n\nConsider a 3-qubit quantum register. The state of this system can be described as a vector in an 8-dimensional complex Hilbert space spanned by the computational basis states $\\{|000\\rangle, |001\\rangle, |010\\rangle, |011\\rangle, |100\\rangle, |101\\rangle, |110\\rangle, |111\\rangle\\}$, ordered according to their binary-to-integer value.\n\nThe oracle operator $U_f$ acts on a basis state $|x\\rangle$ according to the rule $U_f|x\\rangle = (-1)^{f(x)}|x\\rangle$, where $f(x)$ is a Boolean function such that $f(x)=1$ if $|x\\rangle$ is the marked state we are searching for, and $f(x)=0$ otherwise.\n\nFor this problem, we are searching for a single marked item, which is the state $|\\omega\\rangle = |101\\rangle$.\n\nWhich of the following expressions correctly represent the oracle operator $U_f$ for this specific search problem? Select all that apply.\n\nIn the options below:\n- $I$ denotes the $8 \\times 8$ identity matrix.\n- $X_k$ denotes the Pauli-X operator acting on the $k$-th qubit, where qubits are indexed from left to right as 0, 1, 2. For instance, $X_1$ is shorthand for the operator $I_0 \\otimes X_1 \\otimes I_2$.\n- $Z_k$ denotes the Pauli-Z operator acting on the $k$-th qubit.\n- $CCZ$ denotes the controlled-controlled-Z gate, which flips the sign of the basis state $|111\\rangle$ and leaves all other computational basis states unchanged.\n\nA. $I - 2 |101\\rangle\\langle 101|$\n\nB. $I - |101\\rangle\\langle 101|$\n\nC. $Z_0 \\otimes Z_2$\n\nD. $X_1 \\cdot CCZ \\cdot X_1$\n\nE. The $8 \\times 8$ diagonal matrix `diag(1, 1, 1, 1, 1, -1, 1, 1)`", "solution": "The oracle for a single marked state $|\\omega\\rangle=|101\\rangle$ is defined by $U_{f}|x\\rangle=(-1)^{f(x)}|x\\rangle$, where $f(x)=1$ if and only if $|x\\rangle=|101\\rangle$, and $f(x)=0$ otherwise. Therefore, $U_{f}$ flips the sign of $|101\\rangle$ and leaves all other computational basis states unchanged.\n\nOption A: Consider the operator $U=I-2|101\\rangle\\langle 101|$. For any state $|\\psi\\rangle=\\alpha|101\\rangle+|\\psi_{\\perp}\\rangle$ with $\\langle 101|\\psi_{\\perp}\\rangle=0$, we have\n$$\nU|\\psi\\rangle=(I-2|101\\rangle\\langle 101|)(\\alpha|101\\rangle+|\\psi_{\\perp}\\rangle)=\\alpha|101\\rangle-2\\alpha|101\\rangle+|\\psi_{\\perp}\\rangle=-\\alpha|101\\rangle+|\\psi_{\\perp}\\rangle.\n$$\nThus, $U|101\\rangle=-|101\\rangle$ and $U|x\\rangle=|x\\rangle$ for all $|x\\rangle\\neq|101\\rangle$, which matches the required action. Hence A is correct.\n\nOption B: Consider $U=I-|101\\rangle\\langle 101|$. Acting on $|101\\rangle$ gives\n$$\nU|101\\rangle=(I-|101\\rangle\\langle 101|)|101\\rangle=|101\\rangle-|101\\rangle=0,\n$$\nwhich is not unitary and does not implement a phase flip. Hence B is incorrect.\n\nOption C: The operator $Z_{0}\\otimes Z_{2}$ acts on a basis state $|q_{0}q_{1}q_{2}\\rangle$ by the phase $(-1)^{q_{0}}(-1)^{q_{2}}=(-1)^{q_{0}+q_{2}}$. Evaluating on $|101\\rangle$ gives $(-1)^{1+1}=(-1)^{2}=1$, so $|101\\rangle$ is not phase-flipped, while states where $q_0+q_2$ is odd are flipped. This does not match the oracle. Hence C is incorrect.\n\nOption D: Let $U=X_{1}\\cdot CCZ\\cdot X_{1}$. The $CCZ$ applies a $-1$ phase only to $|111\\rangle$. Conjugation by $X_{1}$ maps $|q_{0}q_{1}q_{2}\\rangle$ to $|q_{0},q_{1}\\oplus 1,q_{2}\\rangle$ before $CCZ$, so a $-1$ is applied exactly when $q_{0}=1$, $q_{1}\\oplus 1=1$, and $q_{2}=1$, i.e., when $(q_{0},q_{1},q_{2})=(1,0,1)$. The final $X_{1}$ restores the middle qubit. Thus $U$ flips the sign of $|101\\rangle$ and leaves all other computational basis states unchanged. Hence D is correct.\n\nOption E: With the computational basis ordered as $|000\\rangle,|001\\rangle,|010\\rangle,|011\\rangle,|100\\rangle,|101\\rangle,|110\\rangle,|111\\rangle$, the diagonal matrix\n$$\n\\mathrm{diag}(1,1,1,1,1,-1,1,1)\n$$\nimplements a phase flip of $-1$ only on $|101\\rangle$ (the 6th basis state, index 5) and $+1$ on all others, exactly matching the oracle. Hence E is correct.\n\nSince $I-2|101\\rangle\\langle 101|$ acts as the reflection that flips the sign of $|101\\rangle$ only, and the given diagonal matrix applies the corresponding phase pattern, and $X_{1}\\cdot CCZ\\cdot X_{1}$ implements the same phase flip via conjugation, the correct options are A, D, and E.", "answer": "$$\\boxed{ADE}$$", "id": "1426367"}, {"introduction": "The efficiency of Grover's algorithm is rooted in a clever geometric rotation in a high-dimensional vector space. This exercise explores a fascinating special case where the initial state and the target state are perfectly aligned for a single rotation to guarantee a successful search. By working through this problem [@problem_id:1426374], you will gain a deeper intuition for the algorithm's rotational dynamics and see why the number of iterations is not just an arbitrary choice, but a critical parameter for success.", "problem": "A quantum computing researcher is tasked with searching a large, unstructured database containing a total of $N$ items. The goal is to identify items that possess a specific property, which we will call \"marked\" items. The researcher uses Grover's quantum search algorithm for this task.\n\nIt is known from the database's specification that the number of marked items, $M$, is exactly one-quarter of the total number of items, i.e., $M = N/4$. The algorithm begins with the system in an equal superposition of all possible states. A single Grover iteration then applies a specific unitary transformation to the state of the system.\n\nAssuming the quantum computer operates without any errors, determine the smallest non-negative integer number of Grover iterations, $k_{opt}$, required to maximize the probability of measuring a marked item upon measurement. Additionally, calculate this maximum success probability, $P_{max}$.\n\nProvide your answer as a pair of numbers for $(k_{opt}, P_{max})$.", "solution": "Let $N$ be the total number of database items and $M$ the number of marked items. In Grover’s algorithm, the dynamics are confined to the two-dimensional subspace spanned by the uniform superpositions over marked and unmarked states. Denote the equal superposition over all items by $|s\\rangle$ and parameterize its overlap with the marked subspace by an angle $\\theta$ defined through\n$$\n\\sin^{2}(\\theta)=\\frac{M}{N}.\n$$\nA single Grover iteration effects a rotation by angle $2\\theta$ in this plane toward the marked subspace. After $k$ Grover iterations, the state has overlap with the marked subspace whose amplitude is\n$$\n\\sin\\big((2k+1)\\theta\\big),\n$$\nso the success probability after $k$ iterations is\n$$\nP_{k}=\\sin^{2}\\big((2k+1)\\theta\\big).\n$$\nGiven $M=\\frac{N}{4}$, we have\n$$\n\\sin^{2}(\\theta)=\\frac{1}{4}\\quad\\Rightarrow\\quad \\sin(\\theta)=\\frac{1}{2}\\quad\\Rightarrow\\quad \\theta=\\arcsin\\!\\left(\\frac{1}{2}\\right)=\\frac{\\pi}{6}.\n$$\nTherefore,\n$$\nP_{k}=\\sin^{2}\\!\\left((2k+1)\\frac{\\pi}{6}\\right).\n$$\nTo maximize $P_{k}$ over non-negative integers $k$, note that $\\sin^{2}(x)$ attains its maximum value $1$ when $x=\\frac{\\pi}{2}+m\\pi$ for integer $m$. The smallest non-negative $k$ satisfying\n$$\n(2k+1)\\frac{\\pi}{6}=\\frac{\\pi}{2}\n$$\nis obtained by solving $2k+1=3$, which gives $k=1$. Substituting back yields\n$$\nP_{\\max}=\\sin^{2}\\!\\left(\\frac{\\pi}{2}\\right)=1.\n$$\nHence the smallest non-negative integer number of Grover iterations that maximizes the success probability is $k_{\\text{opt}}=1$, and the maximum success probability is $P_{\\max}=1$.", "answer": "$$\\boxed{(1, 1)}$$", "id": "1426374"}, {"introduction": "While Grover's algorithm offers a remarkable speedup, it is essential to understand its proper domain of application. This final practice asks you to think critically about a problem's structure and decide when a classical algorithm might actually be superior. This exercise [@problem_id:3237894] reinforces the key idea that Grover's advantage lies in unstructured search, teaching the vital skill of selecting the most efficient tool for the task at hand.", "problem": "You are given several search tasks defined on different data access models. Each task specifies a database structure and the allowed primitive query. A single primitive query counts as one unit of cost regardless of classical or quantum computation, and non-query computation is free. Quantum access is via an oracle compatible with Grover’s algorithm that, when applicable, flips the phase of basis states corresponding to marked items according to a Boolean predicate. Classical access is via comparison and inspection primitives as specified by each task. Choose all tasks that most clearly exemplify a situation where a classical comparison-based algorithm such as binary search yields strictly better asymptotic query complexity than Grover’s algorithm.\n\nA. Database: a sorted array of $N$ distinct keys in ascending order. Task: given a query key $x$, find the index $i$ such that the array element $a_i$ equals $x$ if it exists. Classical access: a comparison primitive that, on input an index $i$, returns one of $\\{\\text{less}, \\text{equal}, \\text{greater}\\}$ indicating whether $x$ is less than, equal to, or greater than $a_i$. Quantum access: an oracle that, on input $i$, marks $i$ if and only if $a_i = x$.\n\nB. Database: an unsorted list of $N$ items. Task: find any item satisfying a given predicate $P$ that is available as a Boolean function. Classical access: inspect an item to evaluate $P$. Quantum access: an oracle that marks exactly those indices $i$ for which $P$ holds on the $i$-th item.\n\nC. Database: a hash table with $N$ buckets storing keys uniformly at random. Task: given a hash value $h$, find some stored key whose hash equals $h$. Classical access: compute the hash of a probed key and compare it to $h$; bucket order is arbitrary. Quantum access: an oracle that marks indices of keys whose hash equals $h$.\n\nD. Database: a rotated sorted array of $N$ distinct keys, i.e., an array obtained by taking a strictly increasing array and rotating it by an unknown pivot so that the array remains piecewise increasing with a single breakpoint. Task: find the minimum element. Classical access: a comparison primitive that, on input indices $i$ and $j$, returns whether $a_i < a_j$. Quantum access: an oracle that marks an index $i$ if and only if $a_i$ is the unique minimum.", "solution": "The core of the problem is to compare the query complexity of classical search algorithms against Grover's quantum search algorithm for different tasks.\n\n**Grover's Algorithm**: For a search space of size $N$ containing $M$ \"marked\" or \"solution\" items, Grover's algorithm can find one such item with high probability using an expected number of queries of $O(\\sqrt{N/M})$. In the common case of searching for a single, unique item ($M=1$), the query complexity is $O(\\sqrt{N})$. Grover's algorithm is provably optimal for unstructured search, meaning no algorithm (classical or quantum) can solve this problem with fewer than $\\Omega(\\sqrt{N})$ queries.\n\n**Classical Algorithms**: The efficiency of classical algorithms heavily depends on the structure of the data.\n- For an **unstructured** database of size $N$, any classical algorithm must, in the worst case, inspect a linear number of items to find a solution or prove none exists. The query complexity is $O(N)$.\n- For a **structured** database, such as a sorted array, classical algorithms can exploit this structure. For example, binary search can find an element in a sorted array with only $O(\\log N)$ comparisons.\n\nThe problem asks for cases where the classical algorithm is strictly superior, i.e., $T_C(N) = o(T_Q(N))$. This situation arises when the problem possesses a structure that a classical algorithm can exploit to achieve a query complexity better than $O(\\sqrt{N})$.\n\n### Option-by-Option Analysis\n\n**A. Database: a sorted array of $N$ distinct keys...**\n\n- **Classical Analysis**: The database is a sorted array. The allowed classical primitive is a three-way comparison at a given index. This is the exact setup for **binary search**. Binary search halves the search interval with each query. Therefore, the number of queries required to find the element $x$ (or determine its absence) is $O(\\log_2 N)$, which we write as $O(\\log N)$.\n- **Quantum Analysis**: The quantum access is an oracle that marks the index $i$ where $a_i = x$. Since the keys are distinct, there is at most one marked item ($M \\le 1$). Finding this single marked item in a search space of size $N$ is a canonical application of Grover's algorithm, which requires $O(\\sqrt{N})$ queries.\n- **Comparison**: We compare the classical complexity $T_C(N) = O(\\log N)$ with the quantum complexity $T_Q(N) = O(\\sqrt{N})$. Since $\\lim_{N \\to \\infty} \\frac{\\log N}{\\sqrt{N}} = 0$, we have $\\log N = o(\\sqrt{N})$. The classical comparison-based algorithm (binary search) is strictly better than Grover's algorithm.\n- **Verdict**: **Correct**. This task exemplifies the specified situation.\n\n**B. Database: an unsorted list of $N$ items...**\n\n- **Classical Analysis**: The database is an unsorted list. There is no structure to exploit. The only way to find an item satisfying predicate $P$ is to perform a **linear scan**, inspecting items one by one. In the worst-case scenario (the only satisfying item is the last one, or no item satisfies $P$), the algorithm must perform $N$ queries. The complexity is $O(N)$.\n- **Quantum Analysis**: The quantum access is an oracle for an unstructured search. Assuming there are $M \\ge 1$ solutions, Grover's algorithm finds one in $O(\\sqrt{N/M})$ queries. In the typical case of searching for a single item ($M=1$), the complexity is $O(\\sqrt{N})$.\n- **Comparison**: We compare $T_C(N) = O(N)$ with $T_Q(N) = O(\\sqrt{N})$. Since $\\sqrt{N} = o(N)$, the quantum algorithm is strictly better than the classical one.\n- **Verdict**: **Incorrect**. This is the canonical example where Grover's algorithm provides a quadratic speedup over the best possible classical algorithm.\n\n**C. Database: a hash table with $N$ buckets...**\n\n- **Classical Analysis**: The task is a reverse lookup: given a hash value $h$, find a key that produces it. The classical access primitive is to \"compute the hash of a probed key\". The problem states that the \"bucket order is arbitrary\", which means we cannot use the hash value $h$ to directly index into a specific bucket. The structure of the hash table cannot be used for this specific task. The problem reduces to an unstructured search over the set of all stored keys. Assuming the number of keys is proportional to the number of buckets $N$, a classical linear scan is required, yielding a query complexity of $O(N)$.\n- **Quantum Analysis**: The quantum oracle marks keys whose hash is $h$. This is another instance of unstructured search. For a total of $\\approx N$ keys, the complexity is $O(\\sqrt{N/M})$, where $M$ is the number of keys with hash $h$. For $M=1$, this is $O(\\sqrt{N})$.\n- **Comparison**: As in option B, we compare $T_C(N) = O(N)$ with $T_Q(N) = O(\\sqrt{N})$. The quantum algorithm is strictly better.\n- **Verdict**: **Incorrect**. This is another unstructured search task where Grover's algorithm is superior.\n\n**D. Database: a rotated sorted array of $N$ distinct keys...**\n\n- **Classical Analysis**: The database is a sorted array that has been rotated. This structure, while broken at one point, can still be exploited. The task is to find the minimum element, which is located at the \"pivot\" or \"breakpoint\" where the rotation occurred. A **modified binary search** can find this pivot. By comparing the middle element with the start and end elements of the current search interval, one can determine whether the pivot lies in the left or right half, thus halving the search space in each step. This comparison-based algorithm has a query complexity of $O(\\log N)$.\n- **Quantum Analysis**: The quantum oracle marks the index of the unique minimum element. This sets up a search for a single marked item in a search space of size $N$. Applying Grover's algorithm yields a query complexity of $O(\\sqrt{N})$.\n- **Comparison**: We compare the classical complexity $T_C(N) = O(\\log N)$ with the quantum complexity $T_Q(N) = O(\\sqrt{N})$. Similar to case A, $\\log N = o(\\sqrt{N})$. The classical comparison-based algorithm is strictly better.\n- **Verdict**: **Correct**. This task provides another example where exploiting problem structure allows a classical algorithm to outperform Grover's search.", "answer": "$$\\boxed{AD}$$", "id": "3237894"}]}