{"hands_on_practices": [{"introduction": "This first exercise is fundamental. It challenges you to master the core mechanics of in-place pointer manipulation by reversing a specific segment of a singly linked list. Mastering this skill is essential, as it forms the building block for a wide array of more complex list algorithms and data structure transformations. [@problem_id:3267063]", "problem": "You are given a singly linked list, modeled as an Abstract Data Type (ADT), where each node contains a value and a pointer to the next node. The fundamental base for this problem is the definition of a singly linked list: a sequence of nodes where each node contains a datum and a pointer to its successor. The core operations available are pointer reassignment and traversal, which are constant-time per node. The objective is to design an algorithm based purely on pointer manipulations to reverse a contiguous sublist between positions $m$ and $n$ (inclusive), using $1$-based indexing.\n\nFormally, for a list of length $L$, positions $m$ and $n$ must satisfy $1 \\leq m \\leq n \\leq L$ for a valid reversal. If the input violates this (i.e., $m < 1$, $n > L$, or $m > n$), the output must be the original list unchanged. Edge cases where $m = 1$ and $n = L$ must be handled correctly, reversing from the head and, respectively, up to the tail of the list. The algorithm must operate in time $O(L)$ and use $O(1)$ auxiliary space, modifying the list in place without allocating any new nodes.\n\nYour task is to implement this algorithm and apply it to the following test suite. Each test case is a triplet $(A, m, n)$, where $A$ is the input list of integers, $m$ is the starting position, and $n$ is the ending position of the sublist to reverse. Use $1$-based indexing for positions.\n\nTest suite:\n- Case $1$: $A = [1,2,3,4,5,6,7]$, $m = 3$, $n = 5$.\n- Case $2$: $A = [10,20,30,40]$, $m = 1$, $n = 3$.\n- Case $3$: $A = [5,6,7,8]$, $m = 3$, $n = 4$.\n- Case $4$: $A = [9,8,7]$, $m = 2$, $n = 2$.\n- Case $5$: $A = [1,2,3]$, $m = 1$, $n = 3$.\n- Case $6$: $A = [1,2,3]$, $m = 0$, $n = 2$.\n- Case $7$: $A = [1,2]$, $m = 1$, $n = 3$.\n- Case $8$: $A = []$, $m = 1$, $n = 1$.\n\nFor each case, the output must be the resulting list after applying the described reversal rule. The final output format must be a single line containing the results of the eight cases aggregated as a comma-separated list of lists enclosed in square brackets, with no whitespace characters anywhere in the line. For example, the final output must look like $[[a_1],[a_2],\\dots,[a_8]]$ where each $[a_i]$ is the resulting list for case $i$ expressed using integers. The answers for all cases are lists of integers.", "solution": "The problem of reversing a contiguous sublist within a singly linked list is a well-defined exercise in pointer manipulation, a fundamental concept in data structures. The solution must adhere to strict performance constraints, namely an in-place modification with $O(1)$ auxiliary space and a time complexity of $O(L)$, where $L$ is the length of the list.\n\n### Problem Validation\nA rigorous validation confirms the problem statement is sound and solvable.\n\n**1. Extracted Givens:**\n- **Data Structure:** Singly linked list.\n- **Objective:** Reverse the sublist from position $m$ to position $n$ ($1$-based indexing).\n- **Constraints:** The operation is valid only if $1 \\leq m \\leq n \\leq L$, where $L$ is the list length. If this condition is violated, the original list must be returned.\n- **Performance:** Time complexity $O(L)$, space complexity $O(1)$. No new nodes may be allocated.\n- **Test Suite:** Eight test cases are provided, covering standard operations, edge cases ($m=n$, full list reversal), and invalid inputs ($m<1$, $n>L$, empty list).\n\n**2. Validation Verdict:**\nThe problem is **valid**. It is scientifically grounded in the established principles of computer science, specifically data structures and algorithms. It is well-posed, with all necessary conditions, constraints, and definitions provided for a unique and meaningful solution. The language is objective and formal. The problem poses a non-trivial algorithmic challenge that is a standard topic in the field, satisfying all criteria for a valid problem statement.\n\n### Algorithmic Solution\nThe algorithm proceeds in three main phases: validation and localization, in-place reversal, and reconnection. A dummy head node is employed to simplify pointer logic, particularly for the edge case where the reversal starts at the head of the list ($m=1$).\n\n**Phase 1: Validation and Localization**\n\n1.  **List Length Calculation:** First, we determine the length of the list, $L$, by traversing it from the head to the tail. This takes $O(L)$ time.\n2.  **Input Validation:** We check if the given positions $m$ and $n$ satisfy the condition $1 \\leq m \\leq n \\leq L$. If they do not, as stipulated, the algorithm terminates and returns the original, unmodified list head. This step correctly handles invalid inputs such as those in cases $6$, $7$, and $8$. Special cases like an empty list ($L=0$) or a single-element reversal ($m=n$) are naturally handled by this logic. If $m=n$, the sublist to be reversed has a length of $1$, and the reversal loop will correctly perform no changes.\n\n3.  **Localization of the Sublist:** To modify the list, we must identify the precise connection points.\n    - A `dummy` node is created, such that `dummy.next` points to the original head of the list. This simplifies handling the $m=1$ case, as the pointer to be modified (`dummy.next`) is never the head itself.\n    - We traverse $m-1$ steps from the `dummy` node to locate the node immediately preceding the sublist to be reversed. This node is designated `pre_m`. Its `next` pointer, currently pointing to the node at position $m$, will need to be rewired.\n    - The node at position $m$, which is `pre_m.next`, is the starting point of the sublist to be reversed. Let's call this `start_of_reversal`. After reversal, this node will become the tail of the reversed sublist.\n\n**Phase 2: In-place Sublist Reversal**\n\nThe core of the algorithm is the reversal of the sublist of length $n-m+1$. This is accomplished using an iterative approach with three pointers, conventionally named `prev`, `curr`, and `next_node`.\n\n1.  **Initialization:** The reversal process is initiated on the sublist starting at `start_of_reversal`. We initialize a `prev` pointer to `None` and a `curr` pointer to `start_of_reversal`.\n2.  **Iteration:** We iterate $n-m+1$ times. In each iteration:\n    a. The `next_node` pointer temporarily stores the reference to the next node in the original sequence (`curr.next`).\n    b. The `next` pointer of the `curr` node is reversed to point to `prev`.\n    c. The `prev` pointer is advanced to `curr`.\n    d. The `curr` pointer is advanced to `next_node`.\n\nAfter $n-m+1$ iterations, `prev` will point to the node that was originally at position $n$ (the new head of the reversed sublist), and `curr` will point to the node that was originally at position $n+1$ (the start of the remainder of the list).\n\n**Phase 3: Reconnection**\n\nThe final step is to reconnect the reversed sublist into the main list by manipulating the pointers identified in Phase $1$.\n\n1.  **Connecting the First Part:** The `next` pointer of `pre_m` (the node before the sublist) is updated to point to `prev` (the new head of the reversed sublist).\n2.  **Connecting the Second Part:** The `next` pointer of `start_of_reversal` (which is now the tail of the reversed sublist) is updated to point to `curr` (the node that follows the sublist).\n\nWith these two reconnections, the structural integrity of the linked list is restored, now containing the reversed sublist. The head of the potentially modified list is `dummy.next`, which is returned as the final result. The entire process uses a constant number of auxiliary pointer variables, thus achieving $O(1)$ space complexity, and involves a constant number of traversals of the list or its parts, resulting in an overall $O(L)$ time complexity.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ListNode:\n    \"\"\"\n    Definition for a singly-linked list node.\n    \"\"\"\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef create_linked_list(items):\n    \"\"\"\n    Helper function to create a singly linked list from a list of items.\n    \"\"\"\n    if not items:\n        return None\n    head = ListNode(items[0])\n    current = head\n    for item in items[1:]:\n        current.next = ListNode(item)\n        current = current.next\n    return head\n\ndef linked_list_to_list(head):\n    \"\"\"\n    Helper function to convert a singly linked list back to a Python list.\n    \"\"\"\n    items = []\n    current = head\n    while current:\n        items.append(current.val)\n        current = current.next\n    return items\n\ndef reverse_sublist(head, m, n):\n    \"\"\"\n    Reverses a sublist of a singly linked list from position m to n.\n    1-based indexing is used.\n    \"\"\"\n    # Phase 1: Validation and Localization\n    if not head:\n        return None\n\n    # Calculate length L\n    length = 0\n    curr = head\n    while curr:\n        length += 1\n        curr = curr.next\n\n    # Validate m and n against list properties\n    if not (1 <= m <= n <= length):\n        return head\n    \n    # Trivial case: no reversal needed\n    if m == n:\n        return head\n\n    # Use a dummy node to simplify edge cases (m=1)\n    dummy = ListNode(0, head)\n    \n    # Traverse to the node before the reversal segment\n    pre_m = dummy\n    for _ in range(m - 1):\n        pre_m = pre_m.next\n    \n    # Identify the start of the reversal segment\n    start_of_reversal = pre_m.next\n\n    # Phase 2: In-place Sublist Reversal\n    prev = None\n    curr = start_of_reversal\n    num_reversals = n - m + 1\n    \n    for _ in range(num_reversals):\n        next_node = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_node\n\n    # Phase 3: Reconnection\n    # prev is now the new head of the reversed sublist\n    # curr is the node that was originally at position n+1\n    # start_of_reversal is the original node m, now the tail of the reversed sublist\n    \n    pre_m.next = prev\n    start_of_reversal.next = curr\n    \n    return dummy.next\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and generate the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([1,2,3,4,5,6,7], 3, 5),\n        ([10,20,30,40], 1, 3),\n        ([5,6,7,8], 3, 4),\n        ([9,8,7], 2, 2),\n        ([1,2,3], 1, 3),\n        ([1,2,3], 0, 2),\n        ([1,2], 1, 3),\n        ([], 1, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        list_data, m, n = case\n        head = create_linked_list(list_data)\n        \n        # Apply the reversal algorithm\n        result_head = reverse_sublist(head, m, n)\n        \n        # Convert the resulting linked list back to a Python list\n        result_list = linked_list_to_list(result_head)\n        results.append(result_list)\n\n    # Format the final output as a comma-separated list of lists, with no whitespace.\n    result_strings = [str(res).replace(' ', '') for res in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3267063"}, {"introduction": "Building upon the foundational skill of sublist reversal, this practice requires you to apply that technique iteratively. You'll reverse a linked list in contiguous blocks of a given size $k$, which involves not only performing the reversal on each block but also carefully managing the connections between these processed segments. This exercise teaches you how to compose a larger algorithm from a fundamental subroutine and handle boundary conditions, such as the final, potentially smaller, group of nodes. [@problem_id:3255702]", "problem": "You are given the abstract data type of a singly linked list, where each node contains a value and a reference to the next node. A node has two fields: a value field and a next-pointer field. Formally, a singly linked list is a finite sequence of nodes $\\langle v_1, v_2, \\dots, v_n \\rangle$ such that for each node $v_i$ with $i \\in \\{1, \\dots, n-1\\}$ there exists a reference from $v_i$ to $v_{i+1}$, and the last node $v_n$ has a null next-pointer. The head of the list is $v_1$ if $n \\geq 1$, otherwise the list is empty.\n\nDesign and implement an in-place algorithm that, given the head of a singly linked list and an integer $k$ with $k \\geq 1$, reverses the nodes of the list in contiguous groups of size $k$. If the final group contains fewer than $k$ nodes, that final group must remain in its original order. The algorithm must use only constant extra auxiliary space (a constant number of node references) and must not allocate or deallocate any nodes. The value fields of nodes must remain unchanged; only next-pointers may be reassigned.\n\nYour derivation must start from the fundamental definitions of singly linked lists and pointer references and proceed by constructing a correct and efficient pointer redirection strategy governed by a loop invariant. Do not assume any pre-existing specialized algorithm beyond these core definitions. You must justify correctness by clearly identifying the invariant(s) you maintain and the conditions under which a group can be reversed. You must analyze the time complexity as a function of the input length $n$ and the parameter $k$, using the standard asymptotic notation $\\mathcal{O}(\\cdot)$.\n\nImplement a complete program that:\n- Builds singly linked lists from arrays of integers.\n- Applies the group-reversal operation for each test case below.\n- Converts the resulting linked lists back to arrays of integers.\n\nInput is not read from standard input; instead, your program must internally construct the following test suite and apply the operation to each case. For each pair, the first component is the input sequence and the second is the integer $k$:\n- Case $1$: input `[1,2,3,4,5,6,7,8]`, $k = 3$.\n- Case $2$: input `[1,2,3,4,5]`, $k = 2$.\n- Case $3$: input `[1,2,3,4,5]`, $k = 5$.\n- Case $4$: input `[1,2,3]`, $k = 4$.\n- Case $5$: input `[]` (the empty list), $k = 3$.\n- Case $6$: input `[10]`, $k = 1$.\n- Case $7$: input `[1,1,1,1]`, $k = 2$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a bracketed, comma-separated list of integers without spaces. For example, the overall format must be of the form \"[[result_case_1],[result_case_2],...,[result_case_m]]\" with no whitespace characters. The final outputs for each case must be lists of integers as specified above. No physical units or angle units are involved in this problem. The only numerical outputs are integer arrays representing node values extracted in order from the transformed lists.", "solution": "### Solution Derivation and Analysis\n\n#### Formal Problem Definition\nThe problem requires an in-place algorithm to reverse a singly linked list in contiguous groups of size $k$. A key constraint is that if the final segment of the list contains fewer than $k$ nodes, it must remain in its original order. The algorithm must operate with $O(1)$ auxiliary space and $O(n)$ time complexity.\n\n#### Algorithmic Strategy\nThe problem can be solved by iterating through the linked list and processing it in segments. The core of the algorithm involves:\n1.  Identifying the start and end of a $k$-sized group.\n2.  Reversing this group in-place.\n3.  Connecting the now-reversed group back to the main list.\n4.  Advancing to the start of the next group.\n\nTo handle the connection logic cleanly, especially for the first group which has no preceding segment, a `dummy` head node is introduced. `dummy.next` is set to point to the original head of the list. This ensures that the node preceding any group (even the first) is well-defined, simplifying pointer updates.\n\n#### Algorithm Steps and Invariant\nWe use a pointer `group_prev` to track the last node of the previously processed (and correctly linked) segment. Initially, `group_prev` points to the `dummy` node.\n\nThe main loop is governed by the following invariant:\n> At the start of each iteration, all nodes preceding `group_prev.next` have been correctly processed into reversed $k$-groups, and `group_prev` is the tail of this processed section.\n\nThe loop proceeds by maintaining this invariant:\n\n1.  **Probe for a Full Group**: Before any reversal, we must ensure a full group of $k$ nodes exists starting from the current position. A `probe` pointer is advanced $k$ steps from `group_prev`. If `probe` reaches `null` at any point, it signifies that the remaining segment has fewer than $k$ nodes. The loop then terminates. Since this final, smaller segment must remain unaltered and is already correctly linked from `group_prev`, the algorithm concludes correctly.\n\n2.  **Reverse the Group**: If a full group is confirmed, we identify its start (`group_head = group_prev.next`) and perform a standard in-place reversal on the $k$ nodes of the group. This sub-reversal is done using the canonical three-pointer technique (`prev`, `curr`, `next_node`) and takes $k$ steps. After this sub-operation, the pointer `prev` holds the new head of the reversed group (the original $k$-th node), and `group_head` (the original first node) is now the tail of this reversed group.\n\n3.  **Reconnect the List**: With the group reversed, we must reconnect it to the surrounding list.\n    - The `next` pointer of `group_prev` is updated to point to the new head of the reversed group (`prev`). This links the previous segment to our newly reversed one.\n    - The `next` pointer of the new tail (`group_head`) is set to point to the start of the next un-processed segment.\n\n4.  **Advance for Next Iteration**: To prepare for the next iteration, the `group_prev` pointer is advanced to become the tail of the segment just processed, which is `group_head`. This restores the loop invariant for the next cycle.\n\n#### Complexity Analysis\n-   **Time Complexity**: The algorithm involves a main traversal. For each group of $k$ nodes, it performs a check ($k$ steps) and a reversal ($k$ steps). As there are approximately $n/k$ such groups for a list of length $n$, the total time is proportional to $(n/k) \\times (k+k) = 2n$. Therefore, the overall time complexity is $O(n)$.\n-   **Space Complexity**: The algorithm uses a fixed, small number of pointer variables (`dummy`, `group_prev`, `probe`, `prev`, `curr`, `next_node`) regardless of the list size $n$. This constitutes constant auxiliary space, so the space complexity is $O(1)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ListNode:\n    \"\"\"\n    Definition for a singly-linked list node.\n    \"\"\"\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_list(values):\n    \"\"\"\n    Builds a singly linked list from a list of values.\n    \"\"\"\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for val in values[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef to_list(head):\n    \"\"\"\n    Converts a singly linked list to a list of values.\n    \"\"\"\n    values = []\n    current = head\n    while current:\n        values.append(current.val)\n        current = current.next\n    return values\n\ndef reverse_k_group(head, k):\n    \"\"\"\n    Reverses a linked list in k-sized groups.\n    \"\"\"\n    if not head or k == 1:\n        return head\n\n    # A dummy node simplifies handling the head of the list,\n    # especially for the first group's reversal.\n    dummy = ListNode(0)\n    dummy.next = head\n    \n    # group_prev is the last node of the previously processed segment.\n    # Initially, it's the dummy node.\n    group_prev = dummy\n    \n    while True:\n        # STEP 1: Check if a full group of k nodes exists.\n        # We use a probe pointer to look ahead k nodes without\n        # modifying the list structure yet.\n        probe = group_prev\n        for _ in range(k):\n            probe = probe.next\n            if not probe:\n                # Less than k nodes remain, so terminate. The rest of the\n                # list stays in its original order, which is already the case.\n                return dummy.next\n        \n        # At this point, we have confirmed a group of k nodes exists.\n        # group_head is the first node of the current group to be reversed.\n        group_head = group_prev.next\n        \n        # STEP 2: Reverse the group of k nodes.\n        # This is a standard iterative sublist reversal.\n        # prev will become the new head of the reversed group.\n        # curr will traverse the k nodes.\n        prev = None\n        curr = group_head\n        for _ in range(k):\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        \n        # After reversal:\n        # - group_prev is the tail of the previous block.\n        # - group_head is now the tail of the current reversed block.\n        # - prev is the head of the current reversed block.\n        # - curr points to the head of the next block.\n\n        # STEP 3: Reconnect the reversed group to the list.\n        # The tail of the previous block must point to the new head of this block.\n        group_prev.next = prev\n        # The new tail of this block must point to the start of the next block.\n        group_head.next = curr\n        \n        # STEP 4: Update group_prev for the next iteration.\n        # It's now the last node of the segment we just processed.\n        group_prev = group_head\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([1, 2, 3, 4, 5, 6, 7, 8], 3),\n        ([1, 2, 3, 4, 5], 2),\n        ([1, 2, 3, 4, 5], 5),\n        ([1, 2, 3], 4),\n        ([], 3),\n        ([10], 1),\n        ([1, 1, 1, 1], 2),\n    ]\n\n    results = []\n    for values, k in test_cases:\n        # Build the linked list from the input array.\n        head = build_list(values)\n        \n        # Apply the group-reversal operation.\n        new_head = reverse_k_group(head, k)\n        \n        # Convert the resulting linked list back to an array.\n        result_list = to_list(new_head)\n        results.append(result_list)\n\n    # Format the final output string as per the problem specification.\n    # e.g., [[3,2,1,6,5,4,7,8],[2,1,4,3,5],...]\n    output_str = '[' + ','.join([str(r).replace(' ', '') for r in results]) + ']'\n    \n    print(output_str)\n\nsolve()\n```", "id": "3255702"}, {"introduction": "This final practice expands our scope to a different data structure, the Doubly Linked List (DLL), and introduces a clever two-pass algorithmic pattern. Instead of reversing characters, you'll reverse the order of entire words within a sentence, which requires adapting your pointer manipulation skills to handle both `next` and `prev` pointers. The prescribed approach—reversing the entire list, then reversing each word back—is an elegant technique that demonstrates how a complex transformation can be achieved by composing simpler reversal operations. [@problem_id:3266919]", "problem": "You are given a Doubly Linked List (DLL) of characters representing a finite sentence over the Unicode Basic Latin character set. Each node stores a single character, and for each node $x$ with predecessor $x.\\mathrm{prev}$ and successor $x.\\mathrm{next}$, the DLL invariant is that $(x.\\mathrm{prev} \\neq \\varnothing) \\Rightarrow (x.\\mathrm{prev}.\\mathrm{next} = x)$ and $(x.\\mathrm{next} \\neq \\varnothing) \\Rightarrow (x.\\mathrm{next}.\\mathrm{prev} = x)$. The sentence is defined as a finite sequence $S$ of characters, encoded as a DLL with head $h$ and tail $t$, where the node order corresponds exactly to the sentence order.\n\nDefine a \"word\" as any maximal contiguous run of non-space characters and a \"space-run\" as any maximal contiguous run of the single space character. Formally, let $S$ be partitioned into alternating runs $R_1, R_2, \\dots, R_k$ where each $R_i$ is either a word (all characters $\\neq$ the space character) or a space-run (all characters $=$ the space character). Runs are maximal, so concatenating all runs in order reproduces the original sentence. Characters such as commas or letters are treated simply as non-space characters and thus are part of word runs. The problem requires reversing the order of word runs while preserving the internal character order of each word run, and preserving the internal character order of each space-run. Equivalently, reverse the sequence of maximal runs $R_1, \\dots, R_k$ to $R_k, \\dots, R_1$ while not reversing the characters within any run.\n\nStarting from the core definitions of a Doubly Linked List and the pointer swap operation, derive an algorithm that transforms the given DLL in-place, using at most $O(1)$ auxiliary space and $O(n)$ time where $n$ is the number of nodes. Your algorithm must not construct auxiliary arrays of characters or words; it must operate by manipulating the $\\mathrm{prev}$ and $\\mathrm{next}$ pointers of existing nodes. You are required to:\n- Reverse the entire DLL by a single pass of pointer swaps, thereby reversing the global sequence of nodes.\n- Then, identify each maximal word run in the reversed DLL and reverse the pointers within that run to restore the internal character order of the word. Space-runs should not be altered beyond their implicit relocation by the global reversal.\n\nFor testing, your program must be self-contained (no input) and apply the transformation to the following test suite of sentences as DLLs:\n- $S_1$: \"the sky is blue\"\n- $S_2$: \"  hello   world  \"\n- $S_3$: \"\" (the empty string)\n- $S_4$: \"     \" (five spaces)\n- $S_5$: \"solitary\"\n- $S_6$: \"mix  of   words and  spaces\"\n\nFor each test sentence, your program must output the resulting sentence as a list of Unicode code points (integers) of the characters in the transformed DLL. The final output format must be a single line containing a bracketed, comma-separated list of these per-test-case lists, with no spaces. For example, your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[[a11,a12,...],[b11,b12,...],...]\"), where each inner list corresponds to a test case and each element is an integer code point. No other text should be printed.", "solution": "## Problem Validation\n\n### Step 1: Extract Givens\n\n1.  **Data Structure**: A Doubly Linked List (DLL) of characters from the Unicode Basic Latin character set.\n2.  **Node Definition**: Each node $x$ has attributes $x.\\mathrm{char}$, $x.\\mathrm{prev}$, and $x.\\mathrm{next}$.\n3.  **DLL Invariant**: For any node $x$, if $x.\\mathrm{prev}$ is not null ($\\varnothing$), then $x.\\mathrm{prev}.\\mathrm{next} = x$. If $x.\\mathrm{next}$ is not null ($\\varnothing$), then $x.\\mathrm{next}.\\mathrm{prev} = x$.\n4.  **Sentence Representation**: A finite sequence of characters $S$ is encoded as a DLL where node order matches sentence order.\n5.  **Run Definitions**:\n    *   A \"word\" is a maximal contiguous run of non-space characters.\n    *   A \"space-run\" is a maximal contiguous run of the single space character.\n    *   The sentence $S$ is a partition into alternating runs $R_1, R_2, \\dots, R_k$.\n6.  **Task**: Reverse the order of the runs $R_1, \\dots, R_k$ to become $R_k, \\dots, R_1$. The internal character order within each run must be preserved.\n7.  **Constraints**:\n    *   The transformation must be \"in-place\".\n    *   Auxiliary space complexity must be at most $O(1)$.\n    *   Time complexity must be $O(n)$, where $n$ is the number of nodes.\n    *   The algorithm must not construct auxiliary arrays of characters or words.\n8.  **Prescribed Algorithm**:\n    *   First, reverse the entire DLL via a single pass of pointer swaps.\n    *   Second, identify each maximal word run in the now-globally-reversed DLL and reverse the pointers within that run to restore its original character order.\n9.  **Test Cases**:\n    *   $S_1$: \"the sky is blue\"\n    *   $S_2$: \"  hello   world  \"\n    *   $S_3$: \"\" (the empty string)\n    *   $S_4$: \"     \" (five spaces)\n    *   $S_5$: \"solitary\"\n    *   $S_6$: \"mix  of   words and  spaces\"\n10. **Output Format**: For each test case, produce a list of Unicode code points (integers). The final output must be a single line: a bracketed, comma-separated list of these lists. Example: `[[a11,a12,...],[b11,b12,...],...]`.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is evaluated against the validation criteria:\n\n*   **Scientifically Grounded**: The problem is rooted in the field of computer science, specifically data structures and algorithms. It uses formal, standard definitions for a Doubly Linked List and its operations. All concepts are logically and mathematically sound.\n*   **Well-Posed**: The problem is well-posed. The input is clearly defined (a DLL representing a sentence). The desired output is unambiguously specified (a DLL representing the sentence with words reversed). The constraints on time and space complexity, along with the in-place manipulation requirement, define a precise algorithmic challenge for which a unique and meaningful solution exists.\n*   **Objective**: The problem is stated in precise, objective language. Terms like \"maximal contiguous run\" are formally defined. The constraints and required output format are quantitative and unambiguous.\n\nThe problem does not exhibit any of the invalidating flaws:\n1.  **Scientific or Factual Unsoundness**: None. The problem adheres to the principles of data structure manipulation.\n2.  **Non-Formalizable or Irrelevant**: The problem is formal and directly relevant to the topic of linked list manipulation.\n3.  **Incomplete or Contradictory Setup**: The problem is self-contained and provides all necessary definitions and constraints. The prescribed two-step algorithm is consistent with achieving the final goal.\n4.  **Unrealistic or Infeasible**: The constraints are standard for this type of algorithmic problem and are entirely feasible.\n5.  **Ill-Posed or Poorly Structured**: The problem is well-structured and leads to a unique, stable solution.\n6.  **Pseudo-Profound, Trivial, or Tautological**: The problem is a non-trivial exercise in pointer manipulation, requiring careful implementation to satisfy the in-place and complexity constraints.\n7.  **Outside Scientific Verifiability**: The correctness of the resulting algorithm can be formally proven and empirically verified with the given test cases.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be provided.\n\n## Algorithm Derivation and Solution\n\nThe problem requires an in-place reversal of words within a sentence represented by a Doubly Linked List (DLL), with strict time complexity of $O(n)$ and space complexity of $O(1)$, where $n$ is the number of characters (nodes). The solution follows the two-pass approach mandated by the problem statement.\n\n### Data Structure\n\nA node in the DLL is defined by three fields: `char` for the character, `prev` for the pointer to the preceding node, and `next` for the pointer to the succeeding node. The list is demarcated by a `head` pointer to the first node and null pointers at the ends (the `head`'s `prev` is `null`, and the tail's `next` is `null`).\n\n### Pass 1: Global Reversal of the DLL\n\nThe first step is to reverse the entire DLL. This operation swaps the head and tail of the list and reverses the order of all nodes. For a sentence like \"the sky is blue\", the result of this pass will be a DLL representing \"eulb si yks eht\".\n\nThis reversal can be accomplished in a single pass over the list. We iterate through the list using a `current` pointer, starting from the `head`. For each node visited, we swap its `prev` and `next` pointers. A temporary variable is not strictly needed if the language supports tuple assignment (e.g., `current.prev, current.next = current.next, current.prev`). After swapping, the original `next` pointer is now in the `current.prev` field, so we advance our `current` pointer by assigning it the value of `current.prev`.\n\nThe loop proceeds as follows:\nLet `current` be the pointer to the node being processed, initialized to `head`.\nLet `new_head` be a pointer, initialized to `null`.\nWhile `current` is not `null`:\n1.  Store `current` in `new_head`, as the last node visited will be the new head of the reversed list.\n2.  Let `original_next = current.next`.\n3.  Swap the pointers: `current.next = current.prev` and `current.prev = original_next`.\n4.  Advance to the next node in the original sequence: `current = original_next`.\n\nA more compact way to write steps $2-4$ is:\n1.  Let `temp = current.prev`.\n2.  `current.prev = current.next`.\n3.  `current.next = temp`.\n4.  `current = current.prev` (since `current.prev` now holds the original `next` pointer).\n\nAfter this pass, which visits each of the $n$ nodes once, the DLL is globally reversed. This pass takes $O(n)$ time and uses $O(1)$ auxiliary space for pointers like `current` and `new_head`. The original tail node is now the head of the list.\n\n### Pass 2: Reversal of Individual Word Runs\n\nThe second step corrects the internal order of each word. After Pass $1$, the sentence \"the sky is blue\" has become \"eulb si yks eht\". The words are in the desired final order, but each word is internally reversed. We must now iterate through this new list and reverse each word-run back to its original spelling.\n\nWe traverse the globally-reversed list with a pointer, say `current`, starting from the new `head`.\n1.  We seek the beginning of a word, which is a node whose character is not a space.\n2.  When a word-start is found (let's call it `word_start`), we scan forward from this node to find the end of the word-run. The end, `word_end`, is the last consecutive node with a non-space character.\n3.  We now have a sub-list segment from `word_start` to `word_end` that needs to be reversed in-place. We must also keep track of the nodes immediately preceding this segment (`before_word = word_start.prev`) and succeeding it (`after_word = word_end.next`) to correctly re-link the reversed segment into the main list.\n4.  The reversal of the sub-list `[word_start, ..., word_end]` is performed similarly to the global reversal. We iterate from `word_start` to `word_end`, swapping the `prev` and `next` pointers of each node in the segment.\n5.  After the pointers within the segment are swapped, the roles of `word_start` and `word_end` are effectively exchanged. The original `word_end` is the new beginning of the segment, and the original `word_start` is the new end. We must carefully reconnect the segment to the rest of the list:\n    *   The `next` pointer of `before_word` (if it exists) must now point to the new start of the segment (the original `word_end`).\n    *   The `prev` pointer of the new start of the segment must point to `before_word`.\n    *   The `prev` pointer of `after_word` (if it exists) must now point to the new end of the segment (the original `word_start`).\n    *   The `next` pointer of the new end of the segment must point to `after_word`.\n    *   If `before_word` was `null`, it means the word was at the beginning of the list. In this case, the `head` of the entire list must be updated to point to the new start of the segment (the original `word_end`).\n6.  After a word is reversed and re-linked, our main traversal continues from `after_word`. If the `current` node is a space, we simply advance to the next node.\n\nThis second pass also visits each node a constant number of times (once for scanning, and once more if it's part of a word being reversed). Therefore, it also has a time complexity of $O(n)$ and a space complexity of $O(1)$. The total complexity remains $O(n)$ time and $O(1)$ space, satisfying all problem constraints. This two-pass pointer manipulation algorithm correctly transforms the sentence in-place.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in a Doubly Linked List.\n    \"\"\"\n    def __init__(self, char: str):\n        self.char = char\n        self.prev = None\n        self.next = None\n\ndef string_to_dll(s: str) -> Node | None:\n    \"\"\"\n    Builds a Doubly Linked List from a string.\n    Returns the head of the list.\n    \"\"\"\n    if not s:\n        return None\n    \n    head = Node(s[0])\n    current = head\n    for char in s[1:]:\n        new_node = Node(char)\n        current.next = new_node\n        new_node.prev = current\n        current = new_node\n    return head\n\ndef dll_to_ord_list(head: Node | None) -> list[int]:\n    \"\"\"\n    Converts a Doubly Linked List back to a list of Unicode code points.\n    \"\"\"\n    ords = []\n    current = head\n    while current:\n        ords.append(ord(current.char))\n        current = current.next\n    return ords\n\ndef reverse_words_in_dll(head: Node | None) -> Node | None:\n    \"\"\"\n    Reverses the words in a sentence represented by a DLL, in-place.\n    \"\"\"\n    if not head or not head.next:\n        return head\n\n    # --- Pass 1: Reverse the entire DLL ---\n    # This pass reverses the order of all characters.\n    # e.g., \"the sky\" -> \"yks eht\"\n    current = head\n    new_head = None\n    while current:\n        new_head = current  # The last non-null node visited will be the new head.\n        # Swap prev and next pointers\n        temp_prev = current.prev\n        current.prev = current.next\n        current.next = temp_prev\n        # Move to the next node in the original list\n        current = current.prev\n\n    head = new_head\n\n    # --- Pass 2: Reverse each word run ---\n    # This pass corrects the order of characters within each word.\n    # e.g., \"yks eht\" -> \"sky the\"\n    current = head\n    while current:\n        if current.char != ' ':\n            # Found the start of a reversed word.\n            word_start = current\n            \n            # Find the end of this word run.\n            runner = word_start\n            while runner.next and runner.next.char != ' ':\n                runner = runner.next\n            word_end = runner\n            \n            # Store the nodes connecting this segment to the rest of the list.\n            before_word = word_start.prev\n            after_word = word_end.next\n            \n            # Reverse the pointers within the word sublist [word_start...word_end].\n            p = word_start\n            while True:\n                # This loop correctly reverses a segment of a DLL.\n                temp_next = p.next\n                p.next, p.prev = p.prev, p.next\n                if p == word_end:\n                    break\n                p = temp_next\n\n            # Relink the reversed word segment back into the main list.\n            # The original word_end is now the start of the segment.\n            word_end.prev = before_word\n            if before_word:\n                before_word.next = word_end\n            else:\n                # If there was no node before, this word is at the start of the list.\n                head = word_end\n            \n            # The original word_start is now the end of the segment.\n            word_start.next = after_word\n            if after_word:\n                after_word.prev = word_start\n            \n            # Continue scanning from the node after the processed word.\n            current = after_word\n        else:\n            # It's a space, just move to the next node.\n            current = current.next\n            \n    return head\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        \"the sky is blue\",\n        \"  hello   world  \",\n        \"\",\n        \"     \",\n        \"solitary\",\n        \"mix  of   words and  spaces\",\n    ]\n\n    results_as_strings = []\n    for s in test_cases:\n        # 1. Convert the input string to a DLL.\n        head_node = string_to_dll(s)\n        \n        # 2. Apply the in-place word reversal algorithm.\n        transformed_head = reverse_words_in_dll(head_node)\n        \n        # 3. Convert the resulting DLL to the required list of code points.\n        result_ords = dll_to_ord_list(transformed_head)\n        \n        # 4. Format the list of integers as a string \"[i1,i2,...]\".\n        results_as_strings.append(f\"[{','.join(map(str, result_ords))}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "3266919"}]}