{"hands_on_practices": [{"introduction": "We begin with a task that builds upon a fundamental algorithm: merging two sorted lists. Applying this to circular linked lists ([@problem_id:3220711]) introduces the challenge of managing the cyclic structure without a defined end. This practice is excellent for learning a common and powerful strategy: temporarily transforming a circular structure into a linear one to apply a known algorithm, and then carefully restoring its original properties.", "problem": "You are given two sorted circular singly linked lists whose nodes contain integer keys. A circular singly linked list is defined as a sequence of nodes where each node has a single pointer to the next node, and the last node points back to the initial node, forming a cycle. A sorted circular singly linked list is one for which there exists a designated starting node, called the head, such that traversing exactly the number of nodes in the list from this head yields a non-decreasing sequence of keys. The goal is to merge the two input lists into a single sorted circular singly linked list by reusing existing nodes and rewiring pointers only. The merging must be achieved in time $O(n+m)$, where $n$ and $m$ are the lengths of the two input lists, and in $O(1)$ additional space for nodes. You may use auxiliary variables and constant extra pointers, but you must not allocate, delete, or copy any nodes.\n\nBase definitions to use:\n- A singly linked list node consists of a key from the set of integers and a single pointer to the next node. A circular singly linked list is characterized by the invariant that the last node’s next pointer references the head.\n- A sequence is sorted in non-decreasing order if for every adjacent pair of keys $x_i$ and $x_{i+1}$, we have $x_i \\le x_{i+1}$.\n\nTasks:\n1. Construct a method from first principles that deterministically produces a correct merged circular list using only pointer rewiring and comparisons of integer keys, starting from the definitions above. You must argue correctness based on the invariants of sortedness and circularity and achieve time $O(n+m)$.\n2. Implement this method in a complete runnable program that:\n   - Internally builds circular lists from given finite sequences of integers (each sequence representing the traversal order from the head for exactly the list length).\n   - Merges the two circular lists into one sorted circular list.\n   - Produces a canonical linear representation of the merged circular list as output by choosing the head of the merged list as the smallest key and traversing exactly $n+m$ steps. If both input lists are empty, the merged list is empty, and the output for that case is the empty list.\n\nTest suite:\nFor each test case below, the program must:\n- Build two circular lists from the provided sequences $A$ and $B$.\n- Merge them into a single sorted circular list in time $O(n+m)$.\n- Output a list representing the merged traversal of exactly $|A|+|B|$ steps starting at the smallest key in the merged list.\n\nThe test cases are:\n- Case $1$: $A=\\langle 1,4,7 \\rangle$, $B=\\langle 2,3,9,10 \\rangle$.\n- Case $2$: $A=\\langle \\rangle$, $B=\\langle 5,6 \\rangle$.\n- Case $3$: $A=\\langle \\rangle$, $B=\\langle \\rangle$.\n- Case $4$: $A=\\langle 1,1,2 \\rangle$, $B=\\langle 1,2,2,3 \\rangle$.\n- Case $5$: $A=\\langle 5 \\rangle$, $B=\\langle 4 \\rangle$.\n- Case $6$: $A=\\langle -3,-1,2 \\rangle$, $B=\\langle -2,0,1,3 \\rangle$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[result_1,result_2,...]`). Each $result_i$ must be a Python list of integers representing the merged traversal for the corresponding test case.", "solution": "The problem requires the merging of two sorted circular singly linked lists, denoted as $A$ and $B$ with lengths $n$ and $m$ respectively, into a single sorted circular singly linked list. The constraints are that the merge must be performed in-place by rewiring pointers, with a time complexity of $O(n+m)$ and a space complexity of $O(1)$ regarding node allocation.\n\nFirst, we establish the validity of the problem statement.\n\n### Step 1: Extract Givens\n- **Input Data**: Two sorted circular singly linked lists. Let their heads be $H_A$ and $H_B$.\n- **Node Definition**: A node contains an integer key and a single `next` pointer.\n- **Circular List Definition**: The last node in a traversal sequence points back to the head node.\n- **Sorted Circular List Definition**: There exists a head node from which a traversal of the list's length produces a non-decreasing sequence of keys. The input sequences for each test case represent this traversal from the designated head.\n- **Goal**: Merge the two lists into a single sorted circular singly linked list.\n- **Constraints**:\n    - The merge must be in-place (reusing existing nodes).\n    - Time complexity must be $O(n+m)$.\n    - Auxiliary space for new nodes must be $O(1)$, though constant extra pointers are permitted.\n- **Output Specification**: The merged list must be represented as a linear sequence of keys, generated by traversing the list starting from the node with the smallest key. For two empty lists, the output is an empty list.\n- **Test Cases**:\n    - Case $1$: $A=\\langle 1,4,7 \\rangle$, $B=\\langle 2,3,9,10 \\rangle$.\n    - Case $2$: $A=\\langle \\rangle$, $B=\\langle 5,6 \\rangle$.\n    - Case $3$: $A=\\langle \\rangle$, $B=\\langle \\rangle$.\n    - Case $4$: $A=\\langle 1,1,2 \\rangle$, $B=\\langle 1,2,2,3 \\rangle$.\n    - Case $5$: $A=\\langle 5 \\rangle$, $B=\\langle 4 \\rangle$.\n    - Case $6$: $A=\\langle -3,-1,2 \\rangle$, $B=\\langle -2,0,1,3 \\rangle$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is well-defined and grounded in the standard computer science topic of data structures and algorithms.\n- **Scientifically Grounded**: The concepts of circular linked lists, sortedness, and in-place merging are established and formal topics. There are no scientific or factual violations.\n- **Well-Posed**: The problem is clearly specified. The definition of a \"sorted circular list\" is unambiguous for the given inputs. The canonical output format, starting from the minimum key, ensures a unique solution representation.\n- **Completeness and Consistency**: All necessary definitions and constraints (time, space, in-place operation) are provided. Edge cases, such as empty lists, are explicitly mentioned. The problem is self-contained and free of contradictions.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. We proceed to construct the solution.\n\n### Principle-Based Design of the Merging Algorithm\n\nThe core principle is to reduce the problem of merging two sorted circular lists to the well-understood problem of merging two sorted linear lists. This can be achieved by temporarily breaking the circularity, performing a standard linear merge, and then restoring circularity in the final merged list.\n\n**Step $1$: Handle Edge Cases**\nThe simplest cases involve one or both lists being empty.\n- If list $A$ is empty (i.e., its head pointer $H_A$ is null), the result of the merge is simply list $B$.\n- If list $B$ is empty (i.e., its head pointer $H_B$ is null), the result is list $A$.\n- If both are empty, the result is an empty list (a null pointer).\n\n**Step $2$: Linearize the Circular Lists**\nTo perform a linear merge, we must first treat the circular lists as linear. A sorted circular list with head $H$ and length $N > 0$ has a unique tail node $T$ such that traversing $N-1$ steps from $H$ reaches $T$, and $T.\\text{next} = H$.\n1.  Identify the tail node of list $A$, denoted $T_A$. This is found by starting at $H_A$ and traversing until a node `curr` is found such that `curr.next` equals $H_A$. This operation takes $O(n)$ time. For a list with a single node, the head is also the tail.\n2.  Similarly, identify the tail node of list $B$, denoted $T_B$, in $O(m)$ time.\n3.  Break the circular links by setting $T_A.\\text{next} = \\text{null}$ and $T_B.\\text{next} = \\text{null}$. We now have two standard sorted linear linked lists, starting at $H_A$ and $H_B$.\n\n**Step $3$: Perform In-Place Linear Merge**\nWe merge the two linear lists into a single sorted linear list. A robust method uses a dummy head node to simplify the initialization of the merged list.\n1.  Create a temporary dummy node, `dummy_head`. Create a pointer `current_tail` and initialize it to `dummy_head`. This `current_tail` pointer will track the end of the newly formed list.\n2.  Initialize two pointers, $p_A = H_A$ and $p_B = H_B$, to traverse the lists.\n3.  Iterate while both $p_A$ and $p_B$ are not null. In each iteration, compare the keys at $p_A$ and $p_B$.\n    - If $p_A.\\text{key} \\le p_B.\\text{key}$, append $p_A$ to the merged list by setting `current_tail.next = p_A`, and advance $p_A$ to its next node.\n    - Otherwise, append $p_B$ by setting `current_tail.next = p_B`, and advance $p_B$.\n    - In either case, advance `current_tail` to the node just appended (`current_tail = current_tail.next`).\n4.  After the loop terminates, one of the lists will be exhausted (its pointer will be null). The other list may still contain remaining nodes. Append the entire remaining portion of the non-exhausted list to the end of the merged list. If $p_A$ is not null, `current_tail.next = p_A`. Otherwise, `current_tail.next = p_B`.\n\nThe head of the fully merged linear list is `dummy_head.next`. Based on the problem's definition of a sorted circular list, the given heads $H_A$ and $H_B$ are the minimum elements of their respective lists. The linear merge process begins by selecting the smaller of $H_A$ and $H_B$, ensuring the head of the merged list is the global minimum element.\n\n**Step $4$: Restore Circularity**\nAfter the linear merge, we have a single sorted linear list. The final step is to make it circular.\n1.  The head of the merged list, `merged_head`, is `dummy_head.next`.\n2.  The tail of the merged list is the tail of whichever original list had its remainder appended last. If list $A$ was exhausted first, the remainder of $B$ was appended, and the new tail is the original $T_B$. If $B$ was exhausted first, the new tail is $T_A$. If both lists were exhausted simultaneously, the new tail is the final value of `current_tail` from the loop. A simple way to identify the tail is to recognize that we stored $T_A$ and $T_B$. The pointer to the list segment that was appended (`p_A` or `p_b` after the loop) determines the final tail.\n3.  Set the `next` pointer of this new tail node to point to `merged_head`.\n\n**Complexity Analysis**\n- **Time Complexity**: Finding tails takes $O(n) + O(m)$. The linear merge involves a single pass through all nodes, taking $O(n+m)$. All other operations (pointer assignments) take $O(1)$ time. The total time complexity is $O(n+m)$.\n- **Space Complexity**: The algorithm uses a constant number of auxiliary pointers ($H_A, T_A, H_B, T_B, p_A, p_B, \\text{dummy\\_head}, \\text{current\\_tail}$). No new nodes are allocated besides the single `dummy_head`. Thus, the auxiliary space complexity is $O(1)$, satisfying the problem's constraints.\n\nThis procedure correctly and efficiently merges the two lists while adhering to all specified constraints. The resulting list is sorted and circular, with its head being the node with the minimum key, ready for the canonical output traversal.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    A node in a singly linked list.\n    It holds an integer key and a pointer to the next node.\n    \"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.next = None\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\ndef build_circular_list(sequence):\n    \"\"\"\n    Builds a sorted circular singly linked list from a sequence of integers.\n    The sequence is assumed to be sorted and represents the traversal from the head.\n    \"\"\"\n    if not sequence:\n        return None\n\n    head = Node(sequence[0])\n    current = head\n    for i in range(1, len(sequence)):\n        current.next = Node(sequence[i])\n        current = current.next\n    \n    # Make it circular\n    current.next = head\n    return head\n\ndef traverse_and_format(head):\n    \"\"\"\n    Traverses a circular linked list starting from the head and returns the keys as a list.\n    \"\"\"\n    if not head:\n        return []\n\n    result = []\n    current = head\n    # Use a do-while loop emulation\n    result.append(current.key)\n    current = current.next\n    while current != head:\n        result.append(current.key)\n        current = current.next\n    \n    return result\n\ndef merge_sorted_circular_lists(head_a, head_b):\n    \"\"\"\n    Merges two sorted circular singly linked lists into one.\n\n    The method follows these steps:\n    1. Handles edge cases where one or both lists are empty.\n    2. Finds the tail of each list to facilitate breaking the circular structure.\n    3. Breaks the circles, turning them into two sorted linear lists.\n    4. Performs an in-place merge of the two linear lists.\n    5. Restores the circular structure on the final merged list.\n    \"\"\"\n    # 1. Handle edge cases\n    if not head_a:\n        return head_b\n    if not head_b:\n        return head_a\n\n    # 2. Find the tails of both lists\n    tail_a = head_a\n    while tail_a.next != head_a:\n        tail_a = tail_a.next\n    \n    tail_b = head_b\n    while tail_b.next != head_b:\n        tail_b = tail_b.next\n\n    # 3. Temporarily break the circles to form linear lists\n    tail_a.next = None\n    tail_b.next = None\n\n    # 4. Perform in-place linear merge using a dummy head\n    p_a, p_b = head_a, head_b\n    dummy_head = Node(None)  # A temporary node\n    current_tail = dummy_head\n\n    while p_a and p_b:\n        if p_a.key = p_b.key:\n            current_tail.next = p_a\n            p_a = p_a.next\n        else:\n            current_tail.next = p_b\n            p_b = p_b.next\n        current_tail = current_tail.next\n\n    # Append the remaining list\n    # The new overall tail will be the tail of the list that is appended.\n    new_tail = None\n    if p_a:\n        current_tail.next = p_a\n        new_tail = tail_a\n    else: # p_b must exist or be None\n        current_tail.next = p_b\n        new_tail = tail_b\n\n    merged_head = dummy_head.next\n    \n    # If merged list is empty (should not happen if inputs are valid), return None\n    if not merged_head:\n        return None\n\n    # 5. Restore circularity\n    # If both lists had elements, new_tail is correctly set.\n    # If one of the original lists was empty (handled at start), this code is not reached.\n    # If both input lists had equal length and merge ended perfectly,\n    # current_tail is the true tail. new_tail was set to tail_b by default.\n    final_tail = current_tail\n    while final_tail.next:\n        final_tail = final_tail.next\n    \n    final_tail.next = merged_head\n    \n    return merged_head\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        ([1, 4, 7], [2, 3, 9, 10]),\n        # Case 2\n        ([], [5, 6]),\n        # Case 3\n        ([], []),\n        # Case 4\n        ([1, 1, 2], [1, 2, 2, 3]),\n        # Case 5\n        ([5], [4]),\n        # Case 6\n        ([-3, -1, 2], [-2, 0, 1, 3]),\n    ]\n\n    results = []\n    for case_a, case_b in test_cases:\n        head_a = build_circular_list(case_a)\n        head_b = build_circular_list(case_b)\n\n        merged_head = merge_sorted_circular_lists(head_a, head_b)\n        \n        # The problem requires traversal starting from the smallest key.\n        # The merge logic ensures merged_head is the node with the minimum key\n        # because the input heads are the minimums of their respective lists.\n        result_list = traverse_and_format(merged_head)\n        results.append(result_list)\n\n    # Format the final output as a string representing a list of lists.\n    # Python's default str() for a list already uses brackets and commas, so this is simple.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3220711"}, {"introduction": "Next, we tackle a problem where we lack a designated \"head\" node, making simple linearization impossible. The task of splitting a circular list into two equal halves ([@problem_id:3220641]) requires a more subtle approach to determine the list's properties and identify the precise split point. This exercise introduces the classic and powerful \"tortoise and hare\" algorithm, which uses slow and fast pointers to elegantly solve problems involving cycles in $O(n)$ time and $O(1)$ space.", "problem": "You are given a circular singly linked list. A circular singly linked list is a sequence of nodes, each with a pointer to the next node, such that the last node’s next pointer points back to the first node. You are provided only a pointer to one arbitrary node, denoted by $p$, and not to any designated \"head\" node. The goal is to devise an algorithm that splits the list into two equal-sized circular lists when the number of nodes $n$ is even, and to detect and report that an equal split is impossible when $n$ is odd.\n\nFundamental base and assumptions:\n- A circular singly linked list with $n$ nodes admits a unique cycle of length $n$.\n- A pointer that advances by $s$ nodes on a cycle of length $n$ reaches a position determined by $s \\bmod n$ steps from its starting position.\n- When using two pointers, one advancing by $1$ node per iteration (the \"slow\" pointer) and one advancing by $2$ nodes per iteration (the \"fast\" pointer), after $k$ iterations the slow pointer has advanced $k$ steps and the fast pointer has advanced $2k$ steps.\n\nTask:\n- Starting from $p$, determine whether the list has even length $n$. If so, locate the node $q$ that is exactly $n/2$ steps ahead of $p$ along the cycle.\n- Rewire the next pointers to form two disjoint circular lists of equal size. The first list must contain $p$, and the second list must contain $q$. If $n$ is odd, output that an equal split cannot be performed.\n- The splitting algorithm must rely solely on pointer manipulations in the linked structure derived from $p$, without using auxiliary arrays to store the entire sequence during the splitting step.\n\nInput specification for testing (embedded in the program):\n- The program will internally construct circular singly linked lists from the following test suite of parameter values. Each test case is specified by a pair containing a sequence of node values and a zero-based index $i$ indicating which node’s pointer will be provided as the arbitrary pointer $p$.\n- Test Suite:\n    1. Values $\\{10,20,30,40,50,60,70,80\\}$ and index $i=3$.\n    2. Values $\\{1,2\\}$ and index $i=1$.\n    3. Values $\\{5,5,5,5,5,5\\}$ and index $i=4$.\n    4. Values $\\{1,2,3,4,5\\}$ and index $i=2$.\n    5. Values $\\{0,-1,-2,-3\\}$ and index $i=0$.\n\nOutput specification:\n- For each test case with even $n$, output a list containing two lists:\n    - The first inner list is the sequence of values encountered by traversing the first resulting circular list starting at $p$ and returning to $p$ after exactly $n/2$ steps.\n    - The second inner list is the sequence of values encountered by traversing the second resulting circular list starting at $q$ and returning to $q$ after exactly $n/2$ steps.\n- For each test case with odd $n$, output the integer $-1$.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is either $-1$ or a pair of lists as specified above (for example, `[[a_1,a_2,...],[b_1,b_2,...]]`).\n\nCorrectness criteria to be demonstrated in your solution:\n- Justify how the slow-fast pointer technique detects parity of $n$ and identifies the split point $q$ without needing a head pointer.\n- Explain why rewiring via local pointer changes yields two disjoint cycles of equal length when $n$ is even.\n- Provide asymptotic time complexity in Big O notation (Big-O), and space complexity.\n\nThe program must implement this logic and produce the exact aggregated output for the provided test suite. No physical units, angle units, or percentage units are involved in this problem.", "solution": "The user-provided problem statement is formally analyzed and validated.\n\n### Step 1: Extract Givens\n- **Data Structure**: A circular singly linked list with an unknown number of nodes, $n$.\n- **Input**: A single pointer, $p$, to an arbitrary node in the list.\n- **Objective**:\n    1. Determine if the list length $n$ is even or odd.\n    2. If $n$ is even, split the list into two disjoint circular lists of equal size, $n/2$. The first list must contain $p$, and the second must contain the node $q$, which is $n/2$ steps away from $p$.\n    3. If $n$ is odd, report that an equal split is impossible.\n- **Constraints**: The algorithm must operate \"in-place\" using only pointer manipulation, without auxiliary data structures like arrays to store node sequences during the split.\n- **Fundamental Assumptions**:\n    - A circular list of $n$ nodes forms a single cycle of length $n$.\n    - Pointer advancement by $s$ steps on a cycle of length $n$ reaches a position determined by $s \\pmod n$.\n    - A slow pointer (advancing $1$ step per iteration) and a fast pointer (advancing $2$ steps per iteration) after $k$ iterations have moved $k$ and $2k$ steps, respectively.\n- **Output Specification**: For an even $n$, output a list containing two lists of node values, corresponding to the two new cycles starting at $p$ and $q$. For an odd $n$, output the integer $-1$.\n- **Correctness Criteria**: The solution must justify the parity detection method, the correctness of the splitting procedure, and provide an analysis of time and space complexity.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to a rigorous validation process.\n- **Scientific Grounding**: The problem is set within the formal domain of data structures and algorithms, a core area of computer science. It relies on well-established concepts such as linked lists, pointer arithmetic, and the \"tortoise and hare\" (slow-fast pointer) algorithm. All premises are factually and logically sound.\n- **Well-Posedness**: The problem is well-posed. The input, objective, and constraints are specified with mathematical precision. The desired output is unambiguously defined for both even and odd length cases, ensuring a unique and meaningful solution can be derived.\n- **Objectivity**: The problem is stated in objective, formal language, devoid of any subjective or ambiguous terminology.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. It is self-contained, logically consistent, and grounded in established principles of computer science. A complete solution is therefore warranted.\n\n### Algorithm Design and Justification\n\nThe solution is a three-part process: ($1$) determining the parity of the list length $n$ and simultaneously finding the split point $q$; ($2$) rewiring the pointers to form two separate lists; and ($3$) analyzing the algorithm's performance.\n\n**Part 1: Parity Detection and Split Point Identification**\n\nThe core of this step is the slow-fast pointer technique. We initialize two pointers, `slow` and `fast`, to the given starting node $p$.\n- `slow_ptr` = $p$\n- `fast_ptr` = $p$\n\nWe then iterate, advancing the pointers at different speeds until a termination condition is met. In each iteration $k \\ge 1$:\n- `slow_ptr` advances by $1$ step: `slow_ptr = slow_ptr.next`.\n- `fast_ptr` advances by $2$ steps: `fast_ptr = fast_ptr.next.next`.\n\nAfter $k$ iterations, `slow_ptr` has moved $k$ steps from $p$, and `fast_ptr` has moved $2k$ steps from $p$. The key insight lies in when the `fast_ptr` first returns to the starting node $p$.\n\n**Justification**:\n- **Case 1: $n$ is even.** Let $n = 2m$ for some integer $m \\ge 1$. The `fast_ptr` returns to $p$ when its total displacement, $2k$, is a multiple of $n=2m$. The smallest positive $k$ for which this occurs is $k=m$. At this exact moment:\n    - `fast_ptr` is at position $(2m) \\pmod{2m} = 0$ relative to $p$. Thus, `fast_ptr == p`.\n    - `slow_ptr` is at position $k=m=n/2$ relative to $p$. This is precisely the definition of the desired split node, $q$.\n    - In this case, the condition `fast_ptr.next == p` will never be met before `fast_ptr == p`, because that would imply $2k+1$ is a multiple of $n=2m$, which is impossible as an odd number cannot be a multiple of an even number.\n\n- **Case 2: $n$ is odd.** Let $n = 2m+1$ for some integer $m \\ge 1$.\n    - For `fast_ptr` to be at $p$, $2k$ must be a multiple of $n=2m+1$. Since $\\gcd(2, 2m+1) = 1$, this requires $k$ to be a multiple of $n$. The first time this happens is at $k=n$ steps.\n    - Consider the condition `fast_ptr.next == p`. This means `fast_ptr` is at the node just before $p$, which is at position $n-1$ or $-1$ relative to $p$. This occurs when $2k \\equiv n-1 \\pmod n$. For $n=2m+1$, this is $2k \\equiv 2m \\pmod{2m+1}$. If we choose $k=m$, we have $2m \\equiv 2m \\pmod{2m+1}$, which is true. This condition is met at $k=m=(n-1)/2$ steps.\n    - Since $k=(n-1)/2$ is smaller than $k=n$, the condition `fast_ptr.next == p` will be met first for an odd-length list.\n\nTherefore, the algorithm is as follows:\n$1$. Initialize `slow` and `fast` pointers to $p$.\n$2$. Loop, advancing `slow` by $1$ and `fast` by $2$ in each step.\n$3$. If `fast == p`, the list has an even length. The `slow` pointer now points to $q$. Proceed to Part 2.\n$4$. If `fast.next == p`, the list has an odd length. An equal split is impossible. Terminate and report.\n\n**Part 2: List Splitting for Even $n$**\n\nIf the list length $n$ is even, Part $1$ provides us with pointer $p$ and pointer $q$ (which is the final position of `slow_ptr`). The node $q$ is exactly $n/2$ steps from $p$. The original list structure is a single cycle:\n$p \\rightarrow \\dots \\rightarrow p_{\\text{end}} \\rightarrow q \\rightarrow \\dots \\rightarrow q_{\\text{end}} \\rightarrow p$\n\nTo create two disjoint cycles of length $n/2$, we must identify the nodes $p_{\\text{end}}$ and $q_{\\text{end}}$ and remap their `next` pointers.\n- $p_{\\text{end}}$ is the predecessor of $q$.\n- $q_{\\text{end}}$ is the predecessor of $p$.\n\nThese predecessors are found by simple traversals:\n- To find $p_{\\text{end}}$: Start a temporary pointer at $p$ and advance it until its `next` pointer is $q$. This takes $n/2 - 1$ steps.\n- To find $q_{\\text{end}}$: Start a temporary pointer at $q$ and advance it until its `next` pointer is $p$. This also takes $n/2 - 1$ steps.\n\nOnce $p_{\\text{end}}$ and $q_{\\text{end}}$ are located, the rewiring is trivial:\n$1$. `p_end.next = p`\n$2$. `q_end.next = q`\n\nThis redirects the end of the first chain back to its start ($p$) and the end of the second chain back to its start ($q$), creating two independent circular lists:\n- Cycle 1: $p \\rightarrow \\dots \\rightarrow p_{\\text{end}} \\rightarrow p$\n- Cycle 2: $q \\rightarrow \\dots \\rightarrow q_{\\text{end}} \\rightarrow q$\n\nBoth cycles have a length of $n/2$, as required. This procedure relies only on local pointer manipulations and respects the problem's constraints.\n\n**Part 3: Complexity Analysis**\n\n- **Time Complexity**: The algorithm's runtime is dominated by pointer traversals.\n    - Parity detection (Part 1): The loop runs for approximately $n/2$ iterations. In each iteration, we perform a constant number of operations ($3$ pointer advances). This is $O(n)$.\n    - Finding predecessors (Part 2, for even $n$): Finding $p_{\\text{end}}$ takes $n/2 - 1$ steps. Finding $q_{\\text{end}}$ takes $n/2 - 1$ steps. This is also $O(n)$.\n    - The overall time complexity is $O(n) + O(n) = O(n)$.\n\n- **Space Complexity**: The algorithm uses a fixed number of pointers (`p`, `q`, `slow`, `fast`, and temporary pointers for traversal) regardless of the size of the list. No auxiliary data structures that scale with $n$ are used.\n    - The space complexity is constant, or $O(1)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"A node in a circular singly linked list.\"\"\"\n    def __init__(self, value, next_node=None):\n        self.value = value\n        self.next = next_node\n\n    def __repr__(self):\n        return f\"Node({self.value})\"\n\ndef build_circular_linked_list(values, start_index):\n    \"\"\"Constructs a circular linked list from a sequence of values.\"\"\"\n    if not values:\n        return None\n    \n    n = len(values)\n    nodes = [Node(val) for val in values]\n    \n    for i in range(n):\n        nodes[i].next = nodes[(i + 1) % n]\n        \n    return nodes[start_index]\n\ndef traverse_and_collect(start_node):\n    \"\"\"Traverses a circular list from a start node and collects values.\"\"\"\n    if not start_node:\n        return []\n    \n    path = []\n    current = start_node\n    while True:\n        path.append(current.value)\n        current = current.next\n        if current == start_node:\n            break\n    return path\n\ndef split_circular_list(p):\n    \"\"\"\n    Splits a circular linked list into two halves if its length is even.\n    \n    Args:\n        p: A pointer to an arbitrary node in the circular linked list.\n\n    Returns:\n        A list of two lists of node values for the new cycles if n is even.\n        -1 if n is odd.\n    \"\"\"\n    if not p or p.next == p:\n        # A list with 0 or 1 node cannot be split into two non-empty lists.\n        # The problem implies n >= 2 for a split. Odd length -> impossible.\n        return -1\n        \n    slow = p\n    fast = p\n    \n    while True:\n        slow = slow.next\n        \n        # Fast pointer must be able to advance twice\n        if not fast.next or not fast.next.next:\n            # This case should not be reached in a proper circular list > 1 node\n            return -1 \n        fast = fast.next.next\n        \n        # Condition for odd length list\n        if fast.next == p:\n            return -1\n        \n        # Condition for even length list\n        if fast == p:\n            q = slow\n            break\n            \n    # At this point, n is even and q is the node at distance n/2 from p.\n    # Now we need to find the predecessors of p and q to rewire the list.\n    \n    # Find p_end (predecessor of q)\n    p_end = p\n    while p_end.next != q:\n        p_end = p_end.next\n        \n    # Find q_end (predecessor of p)\n    q_end = q\n    while q_end.next != p:\n        q_end = q_end.next\n        \n    # Rewire the pointers to form two separate cycles\n    p_end.next = p\n    q_end.next = q\n    \n    # Collect the values from the two new lists\n    list1_values = traverse_and_collect(p)\n    list2_values = traverse_and_collect(q)\n    \n    return [list1_values, list2_values]\n    \ndef solve():\n    \"\"\"\n    Defines test cases and runs the splitting algorithm on each,\n    producing the final formatted output.\n    \"\"\"\n    test_suite = [\n        ({'values': [10, 20, 30, 40, 50, 60, 70, 80], 'index': 3}),\n        ({'values': [1, 2], 'index': 1}),\n        ({'values': [5, 5, 5, 5, 5, 5], 'index': 4}),\n        ({'values': [1, 2, 3, 4, 5], 'index': 2}),\n        ({'values': [0, -1, -2, -3], 'index': 0}),\n    ]\n\n    results = []\n    for case in test_suite:\n        p = build_circular_linked_list(case['values'], case['index'])\n        result = split_circular_list(p)\n        \n        if result == -1:\n            results.append(str(-1))\n        else:\n            list1, list2 = result\n            l1_str = f\"[{','.join(map(str, list1))}]\"\n            l2_str = f\"[{','.join(map(str, list2))}]\"\n            results.append(f\"[{l1_str},{l2_str}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3220641"}, {"introduction": "Our final practice presents a significant algorithmic challenge: sorting a circular linked list in $O(n \\log n)$ time using only $O(1)$ auxiliary space ([@problem_id:3220604]). This constraint rules out simple recursive solutions and requires implementing an iterative, bottom-up merge sort. This capstone problem synthesizes concepts of list traversal, splitting, and merging, demanding a deep understanding of pointer manipulation to re-architect the list in place.", "problem": "You are given the task of designing and implementing an algorithm that, given a circular singly linked list whose nodes each contain a single integer key, rearranges the node pointers to produce a nondecreasing order when traversed for exactly $n$ steps starting at the head, where $n$ is the number of nodes in the list. The algorithm must run in $O(n \\log n)$ time using only $O(1)$ extra space and must not allocate auxiliary arrays, use recursion, or create more than a constant number of additional nodes or pointers. The circular singly linked list is defined as a sequence of nodes where each node has a pointer to its successor and the last node points back to the first node.\n\nFundamental base and definitions:\n- A singly linked list is a sequence of nodes where each node has a single pointer to the next node and a stored key. A circular singly linked list is a singly linked list in which the last node points to the first node, forming a cycle. The number of nodes is denoted by $n$.\n- The allowed operations are comparisons of integer keys, reading and writing of pointers, and re-linking of node pointers. The stored keys may include any integers, including negative values and duplicates. No external memory beyond $O(1)$ extra space is permitted; specifically, you may use a constant number of temporary pointers and optional constant-size helper nodes, but you must not allocate arrays or use recursion whose stack depth depends on $n$.\n\nYour objective:\n- Derive from first principles a method to sort a circular singly linked list in nondecreasing order in $O(n \\log n)$ time with only $O(1)$ extra space. Base your derivation solely on the core definitions of linked lists and the invariants of comparison-based merging, without shortcuts.\n- Implement this method as a complete, runnable program that constructs several test circular linked lists, sorts them in-place, and outputs their sorted content as lists of integers.\n\nTest suite:\nProvide and process the following test cases, each represented as an array of integers to be embedded into the program and converted to a circular singly linked list before sorting:\n1. Empty list: $[\\ ]$ with $n = 0$.\n2. Single element: $[7]$ with $n = 1$.\n3. Already sorted: $[1,2,3,4,5]$ with $n = 5$.\n4. Reverse order: $[5,4,3,2,1]$ with $n = 5$.\n5. Duplicates: $[3,1,2,3,2,1]$ with $n = 6$.\n6. Rotated nondecreasing circular list: $[4,5,1,2,3]$ with $n = 5$.\n7. Mixed with negatives: $[-2,-1,-3,0,2]$ with $n = 5$.\n8. All equal: $[2,2,2,2]$ with $n = 4$.\n\nOutput specification:\n- For each test case, after sorting, extract exactly $n$ values by traversing from the head for $n$ steps in the resulting circular list, producing a nondecreasing array representation.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[r_1,r_2,r_3,...]`), where each $r_i$ is the list of integers for test case $i$ in nondecreasing order. No other text should be printed.", "solution": "The problem statement submitted for consideration is valid. It presents a well-defined, scientifically grounded problem in the domain of data structures and algorithms. The objective is to design and implement an in-place sorting algorithm for a circular singly linked list with a time complexity of $O(n \\log n)$ and a space complexity of $O(1)$, where $n$ is the number of nodes. The constraints are stringent but not contradictory, and they define a classic, non-trivial algorithmic challenge. The problem is formalizable and its solution is verifiable. We may, therefore, proceed with its derivation and solution.\n\nThe derivation proceeds from first principles, analyzing the constraints to select and adapt a suitable sorting algorithm.\n\n**1. Algorithmic Choice: Merge Sort**\n\nThe constraints of $O(n \\log n)$ time complexity and a linked list data structure strongly suggest **Merge Sort**. Let us analyze the alternatives:\n- Comparison-based sorting algorithms with $O(n^2)$ worst-case time complexity, such as **Insertion Sort** or **Selection Sort**, are too slow to meet the $O(n \\log n)$ requirement.\n- **Quick Sort**, while having an average time complexity of $O(n \\log n)$, is ill-suited for linked lists. Its efficiency relies on a partition step that requires efficient access to elements relative to a pivot. In an array, this is achieved through swapping elements from both ends, a random-access operation. In a linked list, this would require complex pointer manipulations or backward traversal, which is not supported in a singly linked list, thereby degrading performance and complicating the implementation. Furthermore, its worst-case time complexity remains $O(n^2)$.\n- **Heap Sort** requires a heap data structure, which is most efficiently implemented using an array to allow for $O(1)$ calculation of parent and child indices. Emulating a heap on a linked list is inefficient and would not yield the desired time complexity.\n\n**Merge Sort** is the natural choice. It operates by recursively dividing the list into halves and merging the sorted halves. This sequential access pattern is perfectly compatible with the structure of a linked list. Standard Merge Sort achieves $O(n \\log n)$ time complexity. However, the standard implementation is recursive, which consumes $O(\\log n)$ space on the call stack for a list of size $n$. This violates the strict $O(1)$ space constraint.\n\n**2. Adhering to Space Constraint: Iterative Bottom-Up Merge Sort**\n\nTo satisfy the $O(1)$ space constraint, we must employ an **iterative, bottom-up** version of Merge Sort. This approach eliminates recursion by starting with the smallest possible sorted sublists and systematically merging them into progressively larger sorted sublists.\n\nThe algorithm proceeds in passes. In the first pass, we consider individual nodes as sorted sublists of size $k=1$. We merge adjacent pairs of these sublists to form sorted sublists of size $2$. In the second pass, we set $k=2$ and merge adjacent sorted sublists of size $2$ to form sorted sublists of size $4$. This process continues, doubling the sublist size $k$ in each pass ($k = 1, 2, 4, 8, \\dots$), until the entire list is a single sorted sequence. Since $k$ doubles in each pass, there will be a total of $\\lceil \\log_2 n \\rceil$ passes, leading to the overall $O(n \\log n)$ time complexity.\n\n**3. Overall Algorithm Structure**\n\nThe complete algorithm involves three main stages:\n\n**Stage 1: Pre-processing (Linearization)**\nThe input is a circular singly linked list. This structure is inconvenient for the splitting and merging logic, as it lacks a defined beginning and end. The first step is to convert it into a standard linear linked list.\n- We traverse the list starting from an arbitrary `head` node to find the last node (the one whose `next` pointer points back to the `head`).\n- During this traversal, we count the number of nodes, $n$.\n- We then set the `next` pointer of the last node to `None`, effectively breaking the circle and creating a linear list of length $n$. This stage takes $O(n)$ time.\n\n**Stage 2: Iterative Merging**\nThis is the core of the sorting algorithm. It consists of a loop that iterates through merge passes with increasing sublist size $k$.\n- The outer loop runs for $k = 1, 2, 4, \\dots$ as long as $k  n$.\n- Inside this loop, a single \"merge pass\" is performed. A pass iterates through the current list, repeatedly taking two adjacent sublists of size $k$, merging them into a sorted sublist of size $2k$, and linking this merged sublist into a new, partially-sorted list.\n- To manage the pointers with $O(1)$ extra space, we maintain a pointer to the head of the unprocessed portion of the list and a pointer to the tail of the new list being constructed.\n- For each merge operation within a pass:\n    1.  Split off the first sublist of size up to $k$.\n    2.  Split off the second sublist of size up to $k$.\n    3.  Call a `merge` function on these two sublists.\n    4.  Append the resulting sorted list to the tail of the new list being built.\n    5.  Update the tail pointer and the pointer to the unprocessed portion.\n- After each full pass, the head of the newly constructed list becomes the list to be processed in the next pass with a doubled value of $k$.\n\n**The `merge(list1, list2)` function:**\nThis helper function is the heart of the comparison-based sorting. It takes the heads of two sorted linked lists, `list1` and `list2`, as input. It creates a new sorted list containing all nodes from both input lists by iteratively comparing the keys of the current nodes in `list1` and `list2` and appending the node with the smaller key to the merged list. A temporary dummy head node is used to simplify the logic of building the merged list. The function returns the head of the newly created single sorted list. This operation takes time proportional to the sum of the lengths of the two lists.\n\n**Stage 3: Post-processing (Re-circularization)**\nAfter the final merge pass (when $k \\ge n$), the result is a single, sorted linear linked list. The head of this list is the node containing the minimum key in the entire dataset.\n- To restore the circular structure, we traverse this sorted linear list to find its last node.\n- We then set the `next` pointer of this last node to point back to the head of the list.\n- The head of this new circular list is the final result. This stage takes $O(n)$ time.\n\n**Complexity Analysis**\n- **Time Complexity**: The algorithm has an outer loop that runs $\\log n$ times (as $k$ doubles). The inner `merge_pass` processes each of the $n$ nodes exactly once per pass. Therefore, the total time complexity is $O(n \\log n)$.\n- **Space Complexity**: The algorithm uses a constant number of pointers for traversal and linking (e.g., `head`, `current`, `tail`), regardless of the list size $n$. The helper functions like `merge` may use a temporary dummy node. This constitutes a constant amount of extra space, so the space complexity is $O(1)$.\n\nThis principled derivation results in an algorithm that satisfies all problem constraints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"A node in a singly linked list.\"\"\"\n    def __init__(self, key, next_node=None):\n        self.key = key\n        self.next = next_node\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\ndef build_circular_linked_list(keys):\n    \"\"\"Builds a circular singly linked list from a list of keys.\"\"\"\n    if not keys:\n        return None, 0\n    n = len(keys)\n    head = Node(keys[0])\n    current = head\n    for key in keys[1:]:\n        current.next = Node(key)\n        current = current.next\n    current.next = head  # Make it circular\n    return head, n\n\ndef to_list(head, n):\n    \"\"\"Converts n nodes of a circular linked list to a Python list.\"\"\"\n    if not head:\n        return []\n    result = []\n    current = head\n    for _ in range(n):\n        if current is None: # Should not happen for a circular list of size n > 0\n            break\n        result.append(current.key)\n        current = current.next\n    return result\n\ndef merge(list1, list2):\n    \"\"\"Merges two sorted linked lists into one.\"\"\"\n    dummy = Node(0)\n    tail = dummy\n    while list1 and list2:\n        if list1.key = list2.key:\n            tail.next = list1\n            list1 = list1.next\n        else:\n            tail.next = list2\n            list2 = list2.next\n        tail = tail.next\n    tail.next = list1 if list1 else list2\n    return dummy.next\n\ndef sort_circular_list(head, n):\n    \"\"\"\n    Sorts a circular singly linked list in-place using iterative merge sort.\n    Time complexity: O(n log n)\n    Space complexity: O(1)\n    \"\"\"\n    # 1. Handle edge cases where the list is already sorted.\n    if n = 1:\n        return head\n\n    # 2. Convert circular list to a linear list.\n    # The last node is found by traversing n-1 steps.\n    current = head\n    for _ in range(n - 1):\n        current = current.next\n    current.next = None  # Break the circle. `head` is the start of the linear list.\n\n    list_head = head\n    k = 1\n    while k  n:\n        # Each pass merges sublists of size k.\n        dummy_head = Node(0)\n        current_tail = dummy_head\n        current_head = list_head\n\n        while current_head:\n            # a. Split off list1 of size k\n            list1 = current_head\n            temp = list1\n            for _ in range(k - 1):\n                if not temp: break\n                temp = temp.next\n            \n            if not temp:  # list1 is shorter than k\n                current_head = None\n            else:\n                current_head = temp.next\n                temp.next = None  # Cut list1\n\n            # b. Split off list2 of size k, if it exists\n            list2 = current_head\n            if not list2:\n                current_tail.next = list1\n                break  # This pass is done\n\n            temp = list2\n            for _ in range(k - 1):\n                if not temp: break\n                temp = temp.next\n\n            if not temp:  # list2 is shorter than k\n                current_head = None\n            else:\n                current_head = temp.next\n                temp.next = None  # Cut list2\n\n            # c. Merge list1 and list2 and append to the result\n            merged = merge(list1, list2)\n            current_tail.next = merged\n            \n            # d. Find the new tail to continue appending\n            while current_tail.next:\n                current_tail = current_tail.next\n\n        list_head = dummy_head.next\n        k *= 2\n\n    # 3. Re-circularize the sorted list\n    new_head = list_head\n    if new_head:\n        last_node = new_head\n        while last_node.next:\n            last_node = last_node.next\n        last_node.next = new_head\n        \n    return new_head\n\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the sorting algorithm, and prints the results.\n    \"\"\"\n    test_cases = [\n        [],\n        [7],\n        [1, 2, 3, 4, 5],\n        [5, 4, 3, 2, 1],\n        [3, 1, 2, 3, 2, 1],\n        [4, 5, 1, 2, 3],\n        [-2, -1, -3, 0, 2],\n        [2, 2, 2, 2],\n    ]\n\n    results = []\n    for case_keys in test_cases:\n        head, n = build_circular_linked_list(case_keys)\n        sorted_head = sort_circular_list(head, n)\n        sorted_list = to_list(sorted_head, n)\n        results.append(str(sorted_list))\n\n    # Final print statement in the exact required format.\n    # The str() on a list gives a string like '[1, 2, 3]'.\n    # Joining these with commas gives '[1, 2, 3],[4, 5, 6]'.\n    # We then wrap the whole thing in one more pair of brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3220604"}]}