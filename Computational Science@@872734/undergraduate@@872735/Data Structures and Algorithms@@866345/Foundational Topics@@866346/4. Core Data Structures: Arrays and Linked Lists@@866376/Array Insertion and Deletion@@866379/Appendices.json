{"hands_on_practices": [{"introduction": "The cost of deleting an element from an array is directly tied to the number of elements that must be shifted to close the gap. This exercise explores the cumulative cost of such operations in a specific, iterative process: repeatedly deleting the median element until the array is empty. By analyzing this scenario from first principles, you will derive a surprisingly elegant closed-form expression for the total number of shifts, providing a solid foundation for understanding the performance implications of array deletions. [@problem_id:3208574]", "problem": "An array stores $n$ distinct keys in strictly increasing order in contiguous memory cells, using $0$-based indexing. Consider the following process: while the array is nonempty, delete the lower median element, defined as the element whose index is $\\left\\lfloor \\frac{m-1}{2} \\right\\rfloor$ when the current array length is $m$, and then shift the elements to the right of the removed element one position to the left to fill the gap. Count only element write operations caused by these left shifts; ignore all comparisons, index arithmetic, and any other operations.\n\nUsing only the fundamental definition that in an array stored in contiguous memory, deleting the element at index $i$ from a length-$m$ array shifts exactly the $m-i-1$ elements at indices $i+1,i+2,\\dots,m-1$ one cell to the left (one write per shifted element), derive from first principles a closed-form expression, as a function of $n$, for the exact total number of element writes performed by the entire process until the array becomes empty.\n\nProvide your final result as a single simplified analytic expression in $n$. No rounding is required.", "solution": "Let $T(n)$ be the total number of element write operations for an initial array of size $n$. The process is iterative: in each step, one element is deleted, and the array size decreases by 1, from $m=n$ down to $m=1$. The total number of writes is the sum of the writes performed at each step.\n\nLet $C(m)$ denote the cost (number of writes) for one step when the current array has length $m$. For an array of length $m$, the element at index $i = \\lfloor \\frac{m-1}{2} \\rfloor$ is deleted. The number of writes is the number of elements to the right of the deleted element, which is $m-i-1$.\nThus, the cost for a single step is:\n$$C(m) = m - i - 1 = m - \\left\\lfloor \\frac{m-1}{2} \\right\\rfloor - 1$$\n\nTo simplify $C(m)$, we analyze it based on the parity of $m$:\n- If $m$ is odd, let $m = 2k+1$. The index is $i = \\lfloor \\frac{(2k+1)-1}{2} \\rfloor = k$. The number of writes is $C(2k+1) = (2k+1) - k - 1 = k$. Since $k = \\frac{m-1}{2}$, for odd $m$, $C(m) = \\frac{m-1}{2}$.\n- If $m$ is even, let $m = 2k$. The index is $i = \\lfloor \\frac{2k-1}{2} \\rfloor = k-1$. The number of writes is $C(2k) = 2k - (k-1) - 1 = k$. Since $k = \\frac{m}{2}$, for even $m$, $C(m) = \\frac{m}{2}$.\n\nThese two cases can be unified. For any $m \\ge 1$, $C(m) = \\lfloor \\frac{m}{2} \\rfloor$.\n\nThe total number of writes, $T(n)$, is the sum of $C(m)$ from $m=1$ to $n$:\n$$T(n) = \\sum_{m=1}^{n} \\left\\lfloor \\frac{m}{2} \\right\\rfloor$$\nWe can evaluate this sum by again considering the parity of the summation limit $n$.\n\nCase 1: $n$ is even.\nLet $n = 2p$. The sum consists of $p$ pairs of terms:\n$$T(2p) = \\sum_{m=1}^{2p} \\left\\lfloor \\frac{m}{2} \\right\\rfloor = \\sum_{k=1}^{p} \\left( \\left\\lfloor \\frac{2k-1}{2} \\right\\rfloor + \\left\\lfloor \\frac{2k}{2} \\right\\rfloor \\right)$$\n$$T(2p) = \\sum_{k=1}^{p} ((k-1) + k) = \\sum_{k=1}^{p} (2k-1) = 2\\sum_{k=1}^{p}k - \\sum_{k=1}^{p}1 = 2 \\frac{p(p+1)}{2} - p = p^2+p-p = p^2$$\nSince $n=2p$, we have $p = \\frac{n}{2}$. Substituting this gives:\n$$T(n) = \\left(\\frac{n}{2}\\right)^2 = \\frac{n^2}{4} \\quad \\text{for even } n$$\n\nCase 2: $n$ is odd.\nLet $n = 2p+1$. The sum is:\n$$T(2p+1) = \\sum_{m=1}^{2p+1} \\left\\lfloor \\frac{m}{2} \\right\\rfloor = T(2p) + \\left\\lfloor \\frac{2p+1}{2} \\right\\rfloor$$\nUsing the result from the even case, $T(2p) = p^2$.\n$$T(2p+1) = p^2 + \\left\\lfloor p + \\frac{1}{2} \\right\\rfloor = p^2 + p = p(p+1)$$\nSince $n=2p+1$, we have $p = \\frac{n-1}{2}$. Substituting this gives:\n$$T(n) = \\left(\\frac{n-1}{2}\\right)\\left(\\frac{n-1}{2} + 1\\right) = \\left(\\frac{n-1}{2}\\right)\\left(\\frac{n+1}{2}\\right) = \\frac{n^2-1}{4} \\quad \\text{for odd } n$$\n\nThese two expressions can be unified into a single closed form using the floor function:\n$$T(n) = \\begin{cases} \\frac{n^2}{4} & \\text{if } n \\text{ is even} \\\\ \\frac{n^2-1}{4} & \\text{if } n \\text{ is odd} \\end{cases} \\implies T(n) = \\left\\lfloor \\frac{n^2}{4} \\right\\rfloor$$\nThus, the exact total number of element writes is $\\lfloor \\frac{n^2}{4} \\rfloor$.", "answer": "$$\\boxed{\\left\\lfloor \\frac{n^2}{4} \\right\\rfloor}$$", "id": "3208574"}, {"introduction": "While the cost of a single deletion depends on its position, the total cost of multiple deletions can also depend on the *order* in which they are performed. This practice challenges you to think strategically by finding the minimum possible cost to delete a specific set of elementsâ€”those at indices that are perfect squares. Deriving the optimal deletion order reveals a key principle in minimizing data movement, a critical skill in performance-oriented programming. [@problem_id:3208390]", "problem": "Consider a contiguous array of length $N$ indexed from $1$ to $N$. You are tasked with deleting, one by one, exactly those entries whose original indices are perfect squares, that is, indices $i$ such that $i = k^{2}$ for some integer $k \\ge 1$. At any point, deleting the element currently at position $j$ requires shifting each element strictly to the right of position $j$ one position to the left, and each individual element shift costs $1$ unit. There is no batching: each deletion is performed as a standalone operation, and its cost is the number of elements shifted during that operation. You may choose the order in which to perform the deletions.\n\nStarting only from the core definition of array deletion as the shifting of all subsequent elements and the fact that each shift costs $1$ unit, derive from first principles the minimum possible total cost (measured in units of element shifts) to complete all deletions. Express your final answer as a single closed-form analytic expression in terms of $N$, using only standard arithmetic operators and, if needed, the floor function. No rounding is required, and the final answer must be a single expression without units.", "solution": "To minimize the total cost, we must determine the optimal order in which to delete the elements. Let the set of original indices to be deleted be $S = \\{k^2 \\mid k \\in \\mathbb{Z}^+, k^2 \\le N\\}$. Let $M = \\lfloor\\sqrt{N}\\rfloor$ be the number of elements to delete. The indices are $s_k = k^2$ for $k=1, \\dots, M$.\n\nThe cost of deleting an element at a current position $j$ in an array of current length $L$ is $L - j$. To minimize the total cost, which is the sum of costs for each deletion, we should perform deletions in an order that keeps the current positions $j$ of the targeted elements as large as possible throughout the process.\n\nConsider two elements to be deleted, at original indices $i_1$ and $i_2$ with $i_1  i_2$.\n- If we delete the element at $i_1$ first, its current position is $j_1 = i_1$. The element at $i_2$ then shifts to position $i_2 - 1$.\n- If we delete the element at $i_2$ first, its current position is $j_2 = i_2$. The element at $i_1$ remains at position $i_1$.\n\nDeleting elements with larger indices first does not change the positions of elements with smaller indices that are yet to be deleted. Conversely, deleting elements with smaller indices first reduces the positions of all subsequent elements to be deleted, thereby increasing the shift cost for those later deletions. Therefore, the optimal strategy is to delete the elements in decreasing order of their original indices. This corresponds to deleting the elements at original indices $M^2, (M-1)^2, \\dots, 1^2$.\n\nLet's calculate the cost for this optimal order. We perform $M$ deletions. Let the $t$-th deletion (for $t=1, \\dots, M$) be the removal of the element originally at index $s_t = (M-t+1)^2$.\nAt the start of the $t$-th deletion, $t-1$ elements have already been removed. The current length of the array is $L_t = N - (t-1)$.\nBecause we are deleting from right to left, none of the elements with original indices smaller than $s_t$ have been deleted yet. Thus, the current position of the element to be deleted is its original index, $j_t = s_t$.\nThe cost of the $t$-th deletion is $C_t = L_t - j_t = (N - t + 1) - s_t$.\nThe total minimum cost is the sum of these costs:\n$$C_{min} = \\sum_{t=1}^{M} C_t = \\sum_{t=1}^{M} \\left[ (N - t + 1) - (M-t+1)^2 \\right]$$\nWe can separate the sums:\n$$C_{min} = \\sum_{t=1}^{M} (N+1) - \\sum_{t=1}^{M} t - \\sum_{t=1}^{M} (M-t+1)^2$$\nLet's evaluate each term:\n- $\\sum_{t=1}^{M} (N+1) = M(N+1)$\n- $\\sum_{t=1}^{M} t = \\frac{M(M+1)}{2}$\n- Let $k = M-t+1$. As $t$ goes from $1$ to $M$, $k$ goes from $M$ to $1$. So, $\\sum_{t=1}^{M} (M-t+1)^2 = \\sum_{k=1}^{M} k^2 = \\frac{M(M+1)(2M+1)}{6}$.\n\nSubstituting these back:\n$$C_{min} = M(N+1) - \\frac{M(M+1)}{2} - \\frac{M(M+1)(2M+1)}{6}$$\nFactoring out $\\frac{M}{6}$:\n$$C_{min} = \\frac{M}{6} [6(N+1) - 3(M+1) - (M+1)(2M+1)]$$\n$$C_{min} = \\frac{M}{6} [6N+6 - 3M-3 - (2M^2+3M+1)]$$\n$$C_{min} = \\frac{M}{6} [6N - 6M - 2M^2 + 2]$$\n$$C_{min} = \\frac{M}{3} (3N - 3M - M^2 + 1)$$\nFinally, substitute back $M = \\lfloor\\sqrt{N}\\rfloor$:\n$$C_{min} = \\frac{\\lfloor\\sqrt{N}\\rfloor}{3} (3N + 1 - 3\\lfloor\\sqrt{N}\\rfloor - (\\lfloor\\sqrt{N}\\rfloor)^2)$$", "answer": "$$\n\\boxed{\\frac{\\lfloor\\sqrt{N}\\rfloor}{3} (3N + 1 - 3\\lfloor\\sqrt{N}\\rfloor - \\lfloor\\sqrt{N}\\rfloor^2)}\n$$", "id": "3208390"}, {"introduction": "When adding multiple elements to a sorted array, we face a fundamental strategic choice: insert them one by one, or batch the operation? This problem delves into this classic trade-off by modeling and comparing the costs of both sequential and batch insertion strategies. By analyzing the costs in terms of both element comparisons ($c_{\\text{cmp}}$) and data movements ($c_{\\text{mov}}$), you will determine the critical threshold where one method becomes more efficient than the other, illustrating how algorithmic choices depend on the underlying hardware costs and the scale of the operation. [@problem_id:3208573]", "problem": "You are given a sorted array of distinct keys of length $N$ and $k$ new keys to insert. The new keys are independent and identically distributed draws from a continuous distribution such that their insertion ranks among the existing $N$ keys are independent and uniformly distributed over the $N+1$ possible slots. Consider two strategies under a cost model with a unit cost $c_{\\mathrm{cmp}}  0$ for each comparison and a unit cost $c_{\\mathrm{mov}}  0$ for moving (writing) a single element position in memory.\n\nStrategy A (one-by-one insertion): Insert each new key sequentially. For each insertion into a sorted array of current length $L$, find the insertion index using binary search and perform the needed right-shifts to make room. Assume binary search uses $\\lceil \\log_{2} L \\rceil$ comparisons. Model the shift as moving each element that lies strictly to the right of the insertion index by one position, and count each such move with cost $c_{\\mathrm{mov}}$.\n\nStrategy B (batch insertion by sort-then-merge): First sort the $k$ new keys using a comparison-based sorting algorithm that uses at most $\\beta k \\log_{2} k$ comparisons for some constant $\\beta \\ge 1$, then merge the two sorted sequences (the original array of length $N$ and the newly sorted keys of length $k$) into a fresh array of length $N+k$ using the classical two-way merge, which performs at most $N+k-1$ comparisons and exactly $N+k$ moves. You may assume no additional overhead costs beyond comparisons and moves as specified.\n\nWork in the asymptotic regime where $1 \\ll k \\ll N$. Starting from first principles and standard definitions in the analysis of algorithms, derive the leading-order expected total costs of both strategies under the uniform rank assumption, identify the smallest $k$ for which the expected cost of Strategy B is no greater than that of Strategy A, and provide the resulting leading-order asymptotic expression for this threshold $k$ in terms of $c_{\\mathrm{cmp}}$ and $c_{\\mathrm{mov}}$. Your final answer must be a single closed-form analytic expression for the leading-order threshold $k$; do not provide an inequality. No rounding is required.", "solution": "We derive the leading-order expected total cost for each strategy in the asymptotic regime $1 \\ll k \\ll N$. The cost is a function of comparisons (cost $c_{\\mathrm{cmp}}$) and moves (cost $c_{\\mathrm{mov}}$).\n\n**Strategy A: One-by-One Insertion**\nFor the $i$-th insertion (where $i \\in \\{1, \\dots, k\\}$), the array has length $L = N+i-1$.\n1.  **Comparison Cost:** Binary search takes $\\lceil \\log_{2} L \\rceil$ comparisons. Since $k \\ll N$, $L \\approx N$, so the cost is approximately $c_{\\mathrm{cmp}} \\log_{2} N$.\n2.  **Movement Cost:** An insertion into a sorted array of length $L$ requires, on average, shifting half the elements. The expected number of moves is $L/2$. The cost is $c_{\\mathrm{mov}} \\frac{L}{2} = c_{\\mathrm{mov}} \\frac{N+i-1}{2}$.\n\nThe total expected cost for Strategy A, $E[C_A]$, is the sum of costs for $k$ insertions:\n$$E[C_A] = \\sum_{i=1}^{k} \\left( c_{\\mathrm{cmp}} \\lceil \\log_{2} (N+i-1) \\rceil + c_{\\mathrm{mov}} \\frac{N+i-1}{2} \\right)$$\nIn the regime $1 \\ll k \\ll N$, the dominant term comes from the movement cost summed over $k$ insertions.\nTotal Movement Cost $\\approx \\sum_{i=1}^{k} c_{\\mathrm{mov}} \\frac{N}{2} = \\frac{c_{\\mathrm{mov}} k N}{2}$.\nThe total comparison cost is $\\approx k c_{\\mathrm{cmp}} \\log_2 N$, which is a lower-order term compared to $kN$.\nThus, the leading-order expected cost of Strategy A is:\n$$E[C_A] \\approx \\frac{c_{\\mathrm{mov}} k N}{2}$$\n\n**Strategy B: Batch Insertion by Sort-Then-Merge**\nThis strategy has two steps: sorting the new keys and merging them with the original array.\n1.  **Sorting Cost:** Sorting $k$ keys has a comparison cost of at most $c_{\\mathrm{cmp}} \\beta k \\log_{2} k$.\n2.  **Merging Cost:** Merging the $N$-element array with the $k$-element sorted list into a new array of size $N+k$ requires at most $N+k-1$ comparisons and exactly $N+k$ moves. The cost is $c_{\\mathrm{cmp}} (N+k-1) + c_{\\mathrm{mov}} (N+k)$.\n\nThe total cost for Strategy B, $C_B$, is bounded by:\n$$C_B \\le c_{\\mathrm{cmp}} (\\beta k \\log_{2} k) + c_{\\mathrm{cmp}} (N+k-1) + c_{\\mathrm{mov}} (N+k)$$\nIn the asymptotic regime $1 \\ll k \\ll N$, the terms proportional to $N$ are dominant. Terms proportional to $k \\log_2 k$ and $k$ are of lower order. The leading-order cost of Strategy B is:\n$$C_B \\approx c_{\\mathrm{cmp}}N + c_{\\mathrm{mov}}N = (c_{\\mathrm{cmp}} + c_{\\mathrm{mov}}) N$$\n\n**Threshold Identification**\nWe find the threshold $k$ where the expected cost of Strategy B becomes no greater than that of Strategy A by setting their leading-order costs equal:\n$$E[C_A] \\approx C_B$$\n$$\\frac{c_{\\mathrm{mov}} k N}{2} \\approx (c_{\\mathrm{cmp}} + c_{\\mathrm{mov}}) N$$\nSince $N \\gg 1$, we can divide by $N$:\n$$\\frac{c_{\\mathrm{mov}} k}{2} = c_{\\mathrm{cmp}} + c_{\\mathrm{mov}}$$\nSolving for $k$:\n$$k = \\frac{2(c_{\\mathrm{cmp}} + c_{\\mathrm{mov}})}{c_{\\mathrm{mov}}}$$\nThis simplifies to the final expression for the threshold $k$.\n$$k = 2\\left(\\frac{c_{\\mathrm{cmp}}}{c_{\\mathrm{mov}}} + 1\\right)$$", "answer": "$$\\boxed{2\\left(\\frac{c_{\\mathrm{cmp}}}{c_{\\mathrm{mov}}} + 1\\right)}$$", "id": "3208573"}]}