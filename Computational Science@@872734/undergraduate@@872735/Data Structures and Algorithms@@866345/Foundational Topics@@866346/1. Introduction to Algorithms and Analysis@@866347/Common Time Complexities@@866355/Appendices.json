{"hands_on_practices": [{"introduction": "A core skill in algorithm analysis is the ability to determine time complexity directly from an algorithm's structure. This exercise challenges you to analyze several distinct computational tasks—from graph traversals to matrix operations—and deduce their performance characteristics from first principles. By counting the fundamental operations, you will practice identifying which algorithmic patterns lead to a specific worst-case running time of $\\Theta(n^3)$, reinforcing the crucial link between design and efficiency.", "problem": "You are tasked with selecting algorithm designs that plausibly and non-trivially realize a worst-case running time of $\\Theta(n^3)$ under the unit-cost Random Access Machine (RAM) model, where each arithmetic operation and random memory access costs $\\Theta(1)$. In each option, the input size parameter $n$ denotes the number of vertices of a graph or the side length of a square matrix, as explicitly stated. Choose all options that achieve worst-case time $\\Theta(n^3)$, and justify your selection by reasoning from operation counts rather than citing pre-memorized results.\n\nOptions:\n\nA. Given an unweighted directed graph on $n$ vertices stored as an $n \\times n$ adjacency matrix, run breadth-first search (BFS) from every vertex to compute all-pairs shortest-path distances. The BFS implementation inspects the full row of the adjacency matrix when exploring each vertex.\n\nB. Given the $n \\times n$ adjacency matrix $A$ of a directed graph, compute the matrix $A^3$ to obtain the number of length-$3$ walks between all ordered pairs of vertices. Implement $A^3$ as two successive naive matrix multiplications: first compute $B \\leftarrow A \\cdot A$, then compute $C \\leftarrow B \\cdot A$.\n\nC. Given an $n \\times n$ grayscale image and a sorted list of $n$ intensity thresholds, for each pixel position $(i,j)$ perform a binary search over the thresholds to find the greatest threshold not exceeding the pixel value. Assume comparisons take $\\Theta(1)$ time and the image is accessed row by row.\n\nD. Given an unweighted undirected dense graph on $n$ vertices with $m = \\Theta(n^2)$ edges, run Dijkstra’s algorithm with a binary heap from every vertex to compute all-pairs shortest-path distances, using the standard adjacency-list representation.", "solution": "The problem asks to identify which of the provided algorithmic descriptions result in a worst-case time complexity of $\\Theta(n^3)$ under the unit-cost RAM model. The parameter $n$ represents the number of vertices in a graph or the side length of a matrix. The analysis must be based on operation counts.\n\nFirst, I will validate the problem statement.\nThe problem is set within the standard domain of algorithm analysis. It provides a clear objective: to determine the time complexity of several well-defined algorithms. The model of computation (unit-cost RAM) and the meaning of the input size parameter $n$ are explicitly stated. Each option describes an algorithm with sufficient detail to perform a complexity analysis. The problem is scientifically grounded, well-posed, objective, and does not suffer from any of the flaws that would render it invalid. Therefore, the problem is valid, and I will proceed with the analysis of each option.\n\nThe target complexity is $\\Theta(n^3)$. I will analyze each option by counting the fundamental operations.\n\n**Option A Analysis:**\nThe algorithm is to compute all-pairs shortest paths on an unweighted directed graph with $n$ vertices by running a breadth-first search (BFS) from every vertex. The graph is represented by an $n \\times n$ adjacency matrix.\n\n1.  **Single BFS Run:**\n    A single BFS explores a graph from a source vertex. In the worst case, it visits all $n$ vertices. The problem specifies that for each vertex $u$ being processed, the implementation \"inspects the full row of the adjacency matrix\". A row in an $n \\times n$ matrix has $n$ elements. To find all neighbors of $u$, we must scan the $u$-th row, which takes $\\Theta(n)$ time. Since BFS processes each vertex in the connected component of the source at most once, and in the worst case all $n$ vertices are visited, the total time for exploring all vertices is $n \\times \\Theta(n) = \\Theta(n^2)$. Other operations in BFS, such as queue manipulations and distance updates, take constant time per vertex or edge and do not dominate this cost. Therefore, one run of BFS with this adjacency matrix implementation has a time complexity of $\\Theta(n^2)$.\n\n2.  **All-Pairs Execution:**\n    The algorithm repeats this BFS procedure from each of the $n$ vertices to find all-pairs shortest paths.\n    The total time complexity is the number of runs multiplied by the cost of a single run.\n    Total time = (Number of vertices) $\\times$ (Time for one BFS) = $n \\times \\Theta(n^2) = \\Theta(n^3)$.\n\nThis worst-case time is realized, for instance, on a strongly connected graph. The running time is $\\Theta(n^3)$.\n\n**Verdict on A: Correct**\n\n**Option B Analysis:**\nThe algorithm is to compute $A^3$ for an $n \\times n$ matrix $A$ by performing two successive naive matrix multiplications: $B \\leftarrow A \\cdot A$ and then $C \\leftarrow B \\cdot A$.\n\n1.  **First Naive Matrix Multiplication ($B \\leftarrow A \\cdot A$):**\n    The naive algorithm computes each element $B_{ij}$ of the resulting $n \\times n$ matrix $B$ using the formula $B_{ij} = \\sum_{k=1}^{n} A_{ik} \\cdot A_{kj}$.\n    For each element $B_{ij}$, this calculation involves $n$ multiplications and $n-1$ additions. Under the unit-cost model, this takes $\\Theta(n)$ time.\n    Since there are $n^2$ elements in the matrix $B$, the total time to compute $B$ is the number of elements multiplied by the time to compute one element.\n    Total time for $B \\leftarrow A \\cdot A$ = $n^2 \\times \\Theta(n) = \\Theta(n^3)$.\n\n2.  **Second Naive Matrix Multiplication ($C \\leftarrow B \\cdot A$):**\n    This step is another multiplication of two $n \\times n$ matrices ($B$ and $A$). The logic and operation count are identical to the first step.\n    Total time for $C \\leftarrow B \\cdot A$ = $\\Theta(n^3)$.\n\n3.  **Total Time:**\n    The total time for the entire process is the sum of the times for the two sequential multiplications.\n    Total time = $\\Theta(n^3) + \\Theta(n^3) = \\Theta(n^3)$.\n\nThe running time is $\\Theta(n^3)$.\n\n**Verdict on B: Correct**\n\n**Option C Analysis:**\nThe algorithm processes an $n \\times n$ grayscale image. For each pixel, it performs a binary search on a sorted list of $n$ intensity thresholds.\n\n1.  **Number of Pixels:**\n    The image is of size $n \\times n$, so there are $n^2$ pixels to process. The algorithm iterates through each of these pixels.\n\n2.  **Operation per Pixel:**\n    For each pixel, the algorithm performs a binary search on a sorted list of size $n$. The time complexity of a single binary search on $n$ elements is $\\Theta(\\log n)$, as it halves the search space in each step. The problem states comparisons take $\\Theta(1)$ time.\n\n3.  **Total Time:**\n    The total time is the number of pixels multiplied by the time spent processing each pixel.\n    Total time = (Number of pixels) $\\times$ (Time for binary search) = $n^2 \\times \\Theta(\\log n) = \\Theta(n^2 \\log n)$.\n\nThis running time is not $\\Theta(n^3)$.\n\n**Verdict on C: Incorrect**\n\n**Option D Analysis:**\nThe algorithm is to compute all-pairs shortest paths on a dense, unweighted, undirected graph by running Dijkstra’s algorithm from every vertex. The graph has $n$ vertices and $m = \\Theta(n^2)$ edges. The implementation uses a binary heap and an adjacency-list representation.\n\n1.  **Single Dijkstra Run:**\n    The time complexity of Dijkstra's algorithm with a binary heap priority queue on a graph with $V$ vertices and $E$ edges is $\\Theta((V+E)\\log V)$.\n    In this problem, $V=n$ and the graph is dense, so $E=m=\\Theta(n^2)$.\n    Substituting these values, the complexity for one run is:\n    $\\Theta((n + n^2)\\log n) = \\Theta(n^2 \\log n)$. This is because $n^2$ dominates $n$.\n\n2.  **All-Pairs Execution:**\n    The algorithm repeats Dijkstra's algorithm from each of the $n$ vertices.\n    The total time complexity is the number of runs multiplied by the cost of a single run.\n    Total time = (Number of vertices) $\\times$ (Time for one Dijkstra run) = $n \\times \\Theta(n^2 \\log n) = \\Theta(n^3 \\log n)$.\n    \n    Note: For an unweighted graph, BFS is asymptotically faster for single-source shortest paths. However, the problem explicitly requires using Dijkstra's algorithm.\n\nThis running time is not $\\Theta(n^3)$.\n\n**Verdict on D: Incorrect**\n\nSummary of results:\n- Option A: $\\Theta(n^3)$\n- Option B: $\\Theta(n^3)$\n- Option C: $\\Theta(n^2 \\log n)$\n- Option D: $\\Theta(n^3 \\log n)$\n\nThe options that plausibly and non-trivially realize a worst-case running time of $\\Theta(n^3)$ are A and B.", "answer": "$$\\boxed{AB}$$", "id": "3221804"}, {"introduction": "Time complexity functions are more than just theoretical labels; they are practical tools for system design and performance engineering. This problem [@problem_id:3221840] grounds abstract analysis in a real-world scenario involving a real-time augmented-reality pipeline. You will use a given quadratic time complexity function, $T(n) = 5n^{2} + 100n$, and specific hardware performance metrics to calculate the maximum problem size the system can handle, demonstrating how complexity analysis directly informs capacity planning.", "problem": "A production augmented-reality pipeline must sustain a frame rate of $60$ frames per second, so the processing budget per frame is $16$ milliseconds. A particular stage uses an algorithm whose exact operation count for input size $n$ is given by $T(n) = 5n^{2} + 100n$ primitive steps under the Random Access Machine (RAM) model. On the target Central Processing Unit (CPU), microbenchmarking shows that the average time per primitive step is $40$ nanoseconds under steady-state load.\n\nAssuming the entire $16$ millisecond budget is available to this algorithm stage, determine the largest integer input size $n$ for which the algorithm completes within the per-frame budget. Express your final answer as an integer with no units.", "solution": "The user wants to find the largest integer input size $n$ for an algorithm, such that its execution time does not exceed a given time budget.\n\n### Step 1: Extract Givens\nThe problem provides the following information:\n- Processing budget per frame, $\\tau_{budget} = 16$ milliseconds.\n- Operation count as a function of input size $n$: $T(n) = 5n^2 + 100n$.\n- Average time per primitive operation: $\\tau_{step} = 40$ nanoseconds.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, using standard concepts from algorithm analysis (operation count, time complexity) and computer architecture (processing time, nanoseconds). The problem is well-posed, as it seeks the largest integer $n$ satisfying a specific inequality, which has a unique solution because the time complexity function is monotonically increasing for $n > 0$. The language is objective and quantitative. No inconsistencies or missing information are present. The problem is therefore deemed valid.\n\n### Step 3: Formulate and Solve the Governing Inequality\nThe total execution time of the algorithm for an input of size $n$, denoted as $\\tau_{exec}(n)$, is the product of the number of operations $T(n)$ and the time per operation $\\tau_{step}$.\n$$\n\\tau_{exec}(n) = T(n) \\cdot \\tau_{step}\n$$\nThe problem requires that this execution time be within the per-frame budget:\n$$\n\\tau_{exec}(n) \\le \\tau_{budget}\n$$\nSubstituting the given expressions for $T(n)$, $\\tau_{step}$, and $\\tau_{budget}$:\n$$\n(5n^2 + 100n) \\cdot \\tau_{step} \\le \\tau_{budget}\n$$\nBefore solving, we must ensure all units are consistent. Let's convert all time units to seconds.\n- $\\tau_{budget} = 16 \\text{ ms} = 16 \\times 10^{-3} \\text{ s}$\n- $\\tau_{step} = 40 \\text{ ns} = 40 \\times 10^{-9} \\text{ s}$\n\nSubstituting these values into the inequality:\n$$\n(5n^2 + 100n) \\cdot (40 \\times 10^{-9}) \\le 16 \\times 10^{-3}\n$$\nTo solve for $n$, we first isolate the polynomial term:\n$$\n5n^2 + 100n \\le \\frac{16 \\times 10^{-3}}{40 \\times 10^{-9}}\n$$\n$$\n5n^2 + 100n \\le \\frac{16}{40} \\times 10^{(-3 - (-9))}\n$$\n$$\n5n^2 + 100n \\le 0.4 \\times 10^6\n$$\n$$\n5n^2 + 100n \\le 400000\n$$\nTo simplify the quadratic inequality, we can divide all terms by $5$:\n$$\nn^2 + 20n \\le 80000\n$$\nThis can be rewritten in standard quadratic form as:\n$$\nn^2 + 20n - 80000 \\le 0\n$$\nTo find the range of $n$ for which this inequality holds, we first find the roots of the corresponding equation $n^2 + 20n - 80000 = 0$ using the quadratic formula, $n = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$, with $a=1$, $b=20$, and $c=-80000$.\n$$\nn = \\frac{-20 \\pm \\sqrt{20^2 - 4(1)(-80000)}}{2(1)}\n$$\n$$\nn = \\frac{-20 \\pm \\sqrt{400 + 320000}}{2}\n$$\n$$\nn = \\frac{-20 \\pm \\sqrt{320400}}{2}\n$$\nThe value of the discriminant is calculated as $\\sqrt{320400} \\approx 566.038867$.\nThe two roots, $n_1$ and $n_2$, are:\n$$\nn_1 = \\frac{-20 + 566.038867}{2} = \\frac{546.038867}{2} \\approx 273.0194\n$$\n$$\nn_2 = \\frac{-20 - 566.038867}{2} = \\frac{-586.038867}{2} \\approx -293.0194\n$$\nThe quadratic function $f(n) = n^2 + 20n - 80000$ represents an upward-opening parabola. Therefore, the inequality $f(n) \\le 0$ is satisfied for values of $n$ between the two roots:\n$$\n-293.0194 \\le n \\le 273.0194\n$$\nSince the input size $n$ must be a non-negative integer, we have the constraint $n \\ge 0$. Combining this with the derived inequality, we get:\n$$\n0 \\le n \\le 273.0194\n$$\nThe largest integer value of $n$ that satisfies this condition is $273$.\n\nTo verify, we can compute the execution time for $n=273$:\n$T(273) = 5(273)^2 + 100(273) = 5(74529) + 27300 = 372645 + 27300 = 399945$ operations.\n$\\tau_{exec}(273) = 399945 \\times (40 \\times 10^{-9} \\text{ s}) = 15997800 \\times 10^{-9} \\text{ s} = 15.9978 \\text{ ms}$. This is less than or equal to the budget of $16 \\text{ ms}$.\n\nFor $n=274$:\n$T(274) = 5(274)^2 + 100(274) = 5(75076) + 27400 = 375380 + 27400 = 402780$ operations.\n$\\tau_{exec}(274) = 402780 \\times (40 \\times 10^{-9} \\text{ s}) = 16111200 \\times 10^{-9} \\text{ s} = 16.1112 \\text{ ms}$. This exceeds the budget of $16 \\text{ ms}$.\n\nThus, the largest integer input size is $273$.", "answer": "$$\\boxed{273}$$", "id": "3221840"}, {"introduction": "Asymptotic notation provides a powerful lens for comparing algorithms, but it focuses on behavior as the input size $n$ approaches infinity, ignoring constants and lower-order terms. In practice, the choice between two algorithms often depends on the expected range of $n$. This exercise [@problem_id:3221856] presents a scenario with two algorithms of differing asymptotic classes, $O(n \\ln n)$ and $O(n^{1.5})$, and asks you to find the precise input size where their actual runtimes are equal. Solving for this \"crossover point\" highlights the importance of detailed analysis for making practical implementation decisions.", "problem": "A research team is comparing two implementations of the same task. One implementation uses a divide-and-conquer strategy with asymptotic growth on the order of Big-O notation (Big-O) class $O(n \\ln n)$, and the other uses a geometry-based batching strategy with asymptotic growth on the order of $O(n^{3/2})$. To make a decision for deployment, they model the full step-count functions, including constants and lower-order terms, as follows:\n- Divide-and-conquer implementation: $T_1(n) = 5\\,n \\ln n + 10\\bigl(1 - \\ln 2\\bigr)\\,n + 11$.\n- Batching implementation: $T_2(n) = 5\\,n^{3/2} + 11$.\n\nHere $n$ denotes input size and $\\ln$ denotes the natural logarithm.\n\nUsing the foundational definition that the exact crossover input size $n_0$ is the positive solution to $T_1(n) = T_2(n)$, determine the exact value of $n_0$ in closed form. Your final answer must be a single exact value. Do not approximate or round.", "solution": "The problem requires finding the exact positive crossover input size, denoted as $n_0$, where the step-count functions of two different algorithm implementations are equal.\n\nThe two step-count functions are given as:\n1. Divide-and-conquer implementation: $T_1(n) = 5\\,n \\ln n + 10\\bigl(1 - \\ln 2\\bigr)\\,n + 11$.\n2. Batching implementation: $T_2(n) = 5\\,n^{3/2} + 11$.\n\nThe crossover point $n_0$ is the positive solution to the equation $T_1(n) = T_2(n)$. We begin by setting up this equality:\n$$5\\,n \\ln n + 10\\bigl(1 - \\ln 2\\bigr)\\,n + 11 = 5\\,n^{3/2} + 11$$\n\nWe can simplify this equation by first subtracting $11$ from both sides:\n$$5\\,n \\ln n + 10\\bigl(1 - \\ln 2\\bigr)\\,n = 5\\,n^{3/2}$$\n\nThe variable $n$ represents the input size, which must be a positive quantity, so we can Cautiously assume $n > 0$. This allows us to divide the entire equation by $5n$ without risk of division by zero:\n$$\\frac{5\\,n \\ln n}{5n} + \\frac{10\\bigl(1 - \\ln 2\\bigr)\\,n}{5n} = \\frac{5\\,n^{3/2}}{5n}$$\n$$\\ln n + 2\\bigl(1 - \\ln 2\\bigr) = n^{3/2 - 1}$$\n$$\\ln n + 2 - 2 \\ln 2 = n^{1/2}$$\n\nTo facilitate solving this transcendental equation, we rearrange the terms to isolate the constant part:\n$$n^{1/2} - \\ln n = 2 - 2 \\ln 2$$\n\nUsing the property of logarithms that $k \\ln x = \\ln(x^k)$, we can write $2 \\ln 2 = \\ln(2^2) = \\ln 4$. The equation becomes:\n$$n^{1/2} - \\ln n = 2 - \\ln 4$$\n\nTo analyze this equation, let us define a function $f(n)$ for $n>0$:\n$$f(n) = n^{1/2} - \\ln n$$\n\nOur goal is to find the value of $n$ for which $f(n) = 2 - \\ln 4$. We can analyze the behavior of $f(n)$ using calculus to find its extrema. First, we compute the derivative of $f(n)$ with respect to $n$:\n$$f'(n) = \\frac{d}{dn} \\left( n^{1/2} - \\ln n \\right) = \\frac{1}{2}n^{-1/2} - \\frac{1}{n} = \\frac{1}{2\\sqrt{n}} - \\frac{1}{n}$$\n\nTo find critical points, we set the first derivative equal to zero:\n$$f'(n) = 0$$\n$$\\frac{1}{2\\sqrt{n}} - \\frac{1}{n} = 0$$\n$$\\frac{1}{2\\sqrt{n}} = \\frac{1}{n}$$\n\nAssuming $n \\neq 0$, we can cross-multiply to get:\n$$n = 2\\sqrt{n}$$\n\nTo solve for $n$, we square both sides of the equation. This is a valid step as $n > 0$ implies $\\sqrt{n}$ is real and positive.\n$$n^2 = (2\\sqrt{n})^2$$\n$$n^2 = 4n$$\n$$n^2 - 4n = 0$$\n$$n(n - 4) = 0$$\n\nThis yields two possible solutions: $n=0$ and $n=4$. Since the domain of our function $f(n)$ is $n>0$ (as $\\ln n$ is undefined for $n \\le 0$), the only critical point in the valid domain is $n=4$.\n\nTo determine the nature of this critical point, we employ the second derivative test. The second derivative of $f(n)$ is:\n$$f''(n) = \\frac{d}{dn} \\left( \\frac{1}{2}n^{-1/2} - n^{-1} \\right) = \\frac{1}{2}\\left(-\\frac{1}{2}\\right)n^{-3/2} - (-1)n^{-2} = -\\frac{1}{4}n^{-3/2} + n^{-2}$$\n\nNow, we evaluate $f''(n)$ at the critical point $n=4$:\n$$f''(4) = -\\frac{1}{4}(4)^{-3/2} + (4)^{-2} = -\\frac{1}{4(\\sqrt{4})^3} + \\frac{1}{16} = -\\frac{1}{4(2)^3} + \\frac{1}{16} = -\\frac{1}{4(8)} + \\frac{1}{16} = -\\frac{1}{32} + \\frac{2}{32} = \\frac{1}{32}$$\n\nSince $f''(4) = \\frac{1}{32} > 0$, the function $f(n)$ has a local minimum at $n=4$. As this is the only critical point in the domain $(0, \\infty)$, this local minimum is also the global minimum of the function.\n\nLet us evaluate the function $f(n)$ at this minimum point $n=4$:\n$$f(4) = (4)^{1/2} - \\ln 4 = 2 - \\ln 4$$\n\nWe observe that the minimum value of the function $f(n)$ is exactly the constant term in our equation $f(n) = 2 - \\ln 4$. This means that the equation is satisfied only at the point where the function reaches its global minimum.\n\nTherefore, the unique positive solution $n_0$ to the equation $T_1(n) = T_2(n)$ is the value of $n$ at which this minimum occurs.\n$$n_0 = 4$$", "answer": "$$\\boxed{4}$$", "id": "3221856"}]}