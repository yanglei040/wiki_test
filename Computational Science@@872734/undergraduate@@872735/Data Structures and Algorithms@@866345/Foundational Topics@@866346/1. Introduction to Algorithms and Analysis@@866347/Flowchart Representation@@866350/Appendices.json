{"hands_on_practices": [{"introduction": "A logically sound flowchart is the cornerstone of any correct algorithm. This first practice focuses on the critical skill of debugging by examining one of the most fundamental algorithms, binary search. You will analyze how seemingly minor \"off-by-one\" errors in a flowchart's logic can lead to critical failures like infinite loops, and you will learn to repair them by enforcing strict progress toward termination [@problem_id:3235351]. This exercise sharpens your attention to detail and reinforces the importance of rigorously testing boundary conditions.", "problem": "A sorted array $A[0], A[1], \\dots, A[n-1]$ is defined by $A[i] = 2i$ for all integers $i$ with $0 \\leq i \\leq n-1$. Consider two binary search flowcharts expressed at the level of decision and assignment primitives (process boxes and decision diamonds), each intended to find a target key $x$ in $A$:\n\nFlowchart $\\mathcal{F}_{\\mathrm{low}}$ (lower-mid, no mid bias):\n- Initialize $L \\leftarrow 0$, $R \\leftarrow n-1$.\n- Loop guard: while $L < R$, do:\n  - Compute $m \\leftarrow \\left\\lfloor \\frac{L+R}{2} \\right\\rfloor$.\n  - Decision: if $A[m] < x$, then assign $L \\leftarrow m$; else assign $R \\leftarrow m$.\n\nFlowchart $\\mathcal{F}_{\\mathrm{up}}$ (upper-mid, mid biased):\n- Initialize $L \\leftarrow 0$, $R \\leftarrow n-1$.\n- Loop guard: while $L < R$, do:\n  - Compute $m \\leftarrow \\left\\lceil \\frac{L+R}{2} \\right\\rceil$.\n  - Decision: if $A[m] > x$, then assign $R \\leftarrow m$; else assign $L \\leftarrow m$.\n\nAssume $x$ is chosen to be an odd integer in the inclusive range $[1, 2n-3]$. Using only fundamental properties of monotone arrays and loop invariants for binary search (namely, that the maintained search interval is bounded by indices $L$ and $R$ and that termination requires strict interval shrinkage at every iteration), perform the following:\n\n1. Determine, as an exact function of $n$, the cardinality of the set of odd $x$ in $[1, 2n-3]$ for which either flowchart will enter an infinite loop due to the off-by-one update rules shown.\n2. Identify the values of $n$ for which such infinite loops can manifest and explain why, giving a reasoning chain from the loop invariant and integer mid computation.\n3. Propose precise flowchart repairs (describe the corrected decision and assignment updates, and any necessary adjustments to the loop guard) that guarantee termination on all inputs $(A, x)$ with $A$ sorted and strictly increasing as defined.\n\nProvide your final answer as a single closed-form analytic expression for the function in item $1$. No rounding is required. Do not include any units.", "solution": "The problem is subjected to validation before proceeding to a solution.\n\n### Step 1: Extract Givens\n- A sorted array $A[0], A[1], \\dots, A[n-1]$ is defined by $A[i] = 2i$ for integers $i$ where $0 \\leq i \\leq n-1$.\n- A target key $x$ is an odd integer in the inclusive range $[1, 2n-3]$.\n- Flowchart $\\mathcal{F}_{\\mathrm{low}}$:\n    - Initialize $L \\leftarrow 0$, $R \\leftarrow n-1$.\n    - Loop guard: `while` $L < R$.\n    - Midpoint: $m \\leftarrow \\left\\lfloor \\frac{L+R}{2} \\right\\rfloor$.\n    - Update: `if` $A[m] < x$, `then` $L \\leftarrow m$, `else` $R \\leftarrow m$.\n- Flowchart $\\mathcal{F}_{\\mathrm{up}}$:\n    - Initialize $L \\leftarrow 0$, $R \\leftarrow n-1$.\n    - Loop guard: `while` $L < R$.\n    - Midpoint: $m \\leftarrow \\left\\lceil \\frac{L+R}{2} \\right\\rceil$.\n    - Update: `if` $A[m] > x$, `then` $R \\leftarrow m$, `else` $L \\leftarrow m$.\n- Tasks:\n    1. Determine the cardinality of the set of odd $x$ in $[1, 2n-3]$ for which either flowchart enters an infinite loop.\n    2. Identify the values of $n$ for which such loops can manifest and explain why.\n    3. Propose precise repairs to the flowcharts to guarantee termination.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is a classic exercise in algorithm analysis, specifically focusing on the correctness and termination of binary search implementations. This is a fundamental topic in computer science. The problem is scientifically sound.\n- **Well-Posed**: The problem is well-defined. The array, the target values, and the two algorithms are specified with mathematical precision. The questions are specific and a unique, derivable solution is expected.\n- **Objective**: The problem is stated in precise, objective language. There are no subjective or ambiguous terms.\n- The problem is free of all listed flaws. It is self-contained, consistent, formalizable, and verifiable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Solution Derivation\n\nThe core of the problem is to analyze the termination condition of the two binary search variants. A `while` loop with guard $L < R$ terminates if and only if the size of the search interval, $R-L$, strictly decreases in every iteration. An infinite loop occurs if the state $(L, R)$ fails to change, which implies that for some state where $L<R$, the update rules result in the new state $(L', R')$ being identical to $(L, R)$. This typically happens when the interval size $R-L$ is small.\n\nLet us analyze the critical case where the search interval has been narrowed to two adjacent indices, i.e., $R = L+1$. The loop guard $L < R$ is still true.\n\n**Analysis of Flowchart $\\mathcal{F}_{\\mathrm{low}}$**\n- When $R = L+1$, the midpoint calculation is $m \\leftarrow \\left\\lfloor \\frac{L+(L+1)}{2} \\right\\rfloor = \\left\\lfloor \\frac{2L+1}{2} \\right\\rfloor = \\left\\lfloor L + \\frac{1}{2} \\right\\rfloor = L$.\n- The decision is based on $A[m] = A[L]$.\n- The update rules are:\n    1. If $A[L] < x$, then $L \\leftarrow m$, which means $L \\leftarrow L$. The value of $R$ is unchanged. The state $(L, R)$ remains $(L, L+1)$. This causes an **infinite loop**.\n    2. If $A[L] \\geq x$, then $R \\leftarrow m$, which means $R \\leftarrow L$. Now $L=R$, and the loop terminates.\n\nThus, $\\mathcal{F}_{\\mathrm{low}}$ enters an infinite loop if and only if it reaches a state where $R=L+1$ and the condition $A[L] < x$ holds.\n\n**Analysis of Flowchart $\\mathcal{F}_{\\mathrm{up}}$**\n- When $R = L+1$, the midpoint calculation is $m \\leftarrow \\left\\lceil \\frac{L+(L+1)}{2} \\right\\rceil = \\left\\lceil \\frac{2L+1}{2} \\right\\rceil = \\left\\lceil L + \\frac{1}{2} \\right\\rceil = L+1$. So, $m=R$.\n- The decision is based on $A[m] = A[R]$.\n- The update rules are:\n    1. If $A[R] > x$, then $R \\leftarrow m$, which means $R \\leftarrow R$. The value of $L$ is unchanged. The state $(L, R)$ remains $(L, L+1)$. This causes an **infinite loop**.\n    2. If $A[R] \\leq x$, then $L \\leftarrow m$, which means $L \\leftarrow R$. Now $L=R$, and the loop terminates.\n\nThus, $\\mathcal{F}_{\\mathrm{up}}$ enters an infinite loop if and only if it reaches a state where $R=L+1$ and the condition $A[R] > x$ holds.\n\n**Application to the Specific Problem**\nThe array is given by $A[i]=2i$, which contains only even integers. The target value $x$ is always an odd integer. This implies that for any index $j$, $A[j] \\neq x$. Consequently, the conditions $A[m] \\geq x$ and $A[m] \\leq x$ are equivalent to $A[m] > x$ and $A[m] < x$, respectively.\n\nThe purpose of a binary search is to narrow the interval `[L, R]` to locate the target. Since $x$ is not in the array, the search will proceed until it \"brackets\" $x$ between two consecutive array elements. That is, the search will naturally converge to a state where for some index $k$, we have $A[k] < x < A[k+1]$, and the search interval becomes $[L, R] = [k, k+1]$. This state satisfies $R=L+1$.\n\nFor any odd $x$ in the given range $[1, 2n-3]$, such an index $k$ exists. For $x=1$, $A[0]=0 < 1 < A[1]=2$, so $k=0$. For $x=2n-3$, $A[n-2]=2(n-2)=2n-4 < 2n-3 < A[n-1]=2n-2$, so $k=n-2$.\n\nLet's evaluate the infinite loop conditions in this converged state where $[L, R] = [k, k+1]$ and $A[k] < x < A[k+1]$:\n- For $\\mathcal{F}_{\\mathrm{low}}$, the infinite loop condition is $A[L] < x$. In our state, this is $A[k] < x$, which is true by construction.\n- For $\\mathcal{F}_{\\mathrm{up}}$, the infinite loop condition is $A[R] > x$. In our state, this is $A[k+1] > x$, which is also true by construction.\n\nThis means that for **any** odd integer $x$ in the specified range, both $\\mathcal{F}_{\\mathrm{low}}$ and $\\mathcal{F}_{\\mathrm{up}}$ will invariably reach a state with $R=L+1$ that satisfies their respective infinite loop conditions. Therefore, both algorithms will fail for all possible values of $x$.\n\n**1. Cardinality of the set of failing $x$**\nWe need to count the number of odd integers in the range $[1, 2n-3]$. These are $1, 3, 5, \\dots, 2n-3$. This is an arithmetic progression with first term $a_1=1$, last term $a_j=2n-3$, and common difference $d=2$. The number of terms $j$ is given by $a_j = a_1 + (j-1)d$.\n$2n-3 = 1 + (j-1)2$\n$2n-4 = (j-1)2$\n$n-2 = j-1$\n$j = n-1$\nThe set of odd integers is $\\{2k-1 \\mid k=1, 2, \\dots, n-1\\}$. The cardinality of this set is $n-1$. Since *either* flowchart failing is the condition, and we have shown that *both* fail for all these $n-1$ values, the cardinality of the set of failing $x$ is $n-1$.\n\n**2. Values of $n$ for which loops manifest**\nThe infinite loop mechanism requires reaching a state where $R=L+1$. This is only possible if the initial interval size is at least $1$, i.e., $R_{init} - L_{init} \\geq 1$.\nGiven $L_{init}=0$ and $R_{init}=n-1$, we require $(n-1) - 0 \\geq 1$, which simplifies to $n \\geq 2$.\nIf $n=1$, the array is $A[0]=0$, $L=0, R=0$. The loop `while L < R` is never entered. The range for $x$ is $[1, 2(1)-3] = [1, -1]$, which is empty. The number of failing $x$ is $0$, which matches our formula $n-1=0$.\nThus, infinite loops can manifest for any integer $n \\geq 2$.\n\n**3. Proposed Flowchart Repairs**\nTermination is guaranteed if the interval $[L, R]$ strictly shrinks in every iteration. The flaw in both original flowcharts is that one of the update branches fails to shrink the interval when $R=L+1$. The repairs must correct this.\n\n**Repair for $\\mathcal{F}_{\\mathrm{low}}$ (lower-mid):**\nThe failing branch is `L <- m` when `m=L`. To ensure shrinkage, `L` must be advanced past `m`.\n- Loop guard: `while` $L < R$. (No change)\n- Midpoint: $m \\leftarrow \\left\\lfloor \\frac{L+R}{2} \\right\\rfloor$. (No change)\n- Corrected Update: `if` $A[m] < x$, `then` $L \\leftarrow m+1$, `else` $R \\leftarrow m$.\nWith this change, if $A[m]<x$, $L$ is guaranteed to increase. If $A[m] \\geq x$, $R$ is guaranteed to decrease (since $L<R$ implies $m < R$). The interval always shrinks.\n\n**Repair for $\\mathcal{F}_{\\mathrm{up}}$ (upper-mid):**\nThe failing branch is `R <- m` when `m=R`. To ensure shrinkage, `R` must retreat past `m`.\n- Loop guard: `while` $L < R$. (No change)\n- Midpoint: $m \\leftarrow \\left\\lceil \\frac{L+R}{2} \\right\\rceil$. (No change)\n- Corrected Update: `if` $A[m] > x$, `then` $R \\leftarrow m-1$, `else` $L \\leftarrow m$.\nWith this change, if $A[m]>x$, $R$ is guaranteed to decrease. If $A[m] \\leq x$, $L$ is guaranteed to increase (since $L<R$ implies $L < m$). The interval always shrinks.\n\nThese minimal changes to the update rules guarantee termination for all sorted input arrays and target keys.\n\nThe question asks for a single closed-form analytic expression for the function in item 1. This is the cardinality of the set of failing $x$, which we determined to be $n-1$.", "answer": "$$\\boxed{n-1}$$", "id": "3235351"}, {"introduction": "Once a flowchart is correct, the next consideration is often efficiency. This exercise introduces the concept of path optimization by framing a flowchart as a system where each operation has an associated \"energy\" cost. Your task is to find the most efficient execution path from start to finish, which provides a hands-on application of classic shortest-path algorithms on a graph [@problem_id:3235343]. This practice demonstrates the powerful technique of modeling a domain-specific problem as a weighted graph to find an optimal solution.", "problem": "You are given a precise representation of a flowchart as a directed graph where each operation node incurs a nonnegative energy cost. Formally, consider a directed graph $G = (V, E)$ with $|V| = n$, where each node $v \\in V$ has an associated cost $c(v) \\in \\mathbb{Z}_{\\ge 0}$. A path is a sequence of nodes $(v_0, v_1, \\dots, v_k)$ such that $(v_i, v_{i+1}) \\in E$ for all $i \\in \\{0,\\dots,k-1\\}$. The total energy consumption of a path is defined as the sum of the costs of all nodes on the path, counted exactly once per visit; that is, the cost of $(v_0, v_1, \\dots, v_k)$ is $\\sum_{i=0}^{k} c(v_i)$. Given a specified start node $s \\in V$ and end node $t \\in V$, your task is to compute the minimum possible total energy consumption among all directed paths from $s$ to $t$. If $t$ is unreachable from $s$, define the answer to be $-1$.\n\nBase definitions you may assume without proof include the standard definitions of directed graphs, paths, and nonnegativity of costs. You must design an algorithm that is correct for any directed graph with nonnegative node costs, including graphs with cycles, and analyze the path cost exactly as the sum of node costs along the path.\n\nYour program must implement this computation and run it on the following fixed test suite. Each test case is given as a tuple $(n, \\text{edges}, \\text{costs}, s, t)$, where:\n- $n$ is the number of nodes, with node identifiers in $\\{0,1,\\dots,n-1\\}$,\n- $\\text{edges}$ is a list of directed edges $(u,v)$,\n- $\\text{costs}$ is a list where $\\text{costs}[v] = c(v)$,\n- $s$ is the start node, and $t$ is the end node.\n\nTest suite:\n1. $(n=\\;6,\\; \\text{edges}=\\{(0,1),(0,2),(1,3),(2,3),(3,4),(4,5),(2,5)\\},\\; \\text{costs}=[4,2,7,1,3,5],\\; s=\\;0,\\; t=\\;5)$.\n2. $(n=\\;5,\\; \\text{edges}=\\{(0,1),(1,2),(2,1),(2,3),(3,4)\\},\\; \\text{costs}=[1,9,2,8,3],\\; s=\\;0,\\; t=\\;4)$.\n3. $(n=\\;4,\\; \\text{edges}=\\{(0,1),(2,3)\\},\\; \\text{costs}=[5,1,1,1],\\; s=\\;0,\\; t=\\;3)$.\n4. $(n=\\;7,\\; \\text{edges}=\\{(0,1),(0,2),(2,3),(1,4),(4,3),(3,5),(5,6),(1,6)\\},\\; \\text{costs}=[0,5,0,4,0,2,1],\\; s=\\;0,\\; t=\\;6)$.\n5. $(n=\\;1,\\; \\text{edges}=\\{\\},\\; \\text{costs}=[42],\\; s=\\;0,\\; t=\\;0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). The results must be integers, where each integer is the minimum total energy for the corresponding test case or $-1$ if there is no path from $s$ to $t$. No input should be read from standard input, and no external files should be used.", "solution": "The problem asks for the minimum total energy consumption for a path from a specified start node $s$ to an end node $t$ in a directed graph $G = (V, E)$. The costs are associated with the nodes, $c(v) \\ge 0$ for each node $v \\in V$. The cost of a path $(v_0, v_1, \\dots, v_k)$ is defined as the sum of the costs of its nodes, $\\sum_{i=0}^{k} c(v_i)$.\n\nThis problem can be modeled as a single-source shortest path problem. Standard shortest path algorithms, such as Dijkstra's algorithm, are defined on graphs with weighted edges. We must therefore translate the given problem with node costs into an equivalent problem with edge weights.\n\nConsider a path $P = (v_0, v_1, \\dots, v_k)$ starting at $v_0 = s$. Its cost is $C(P) = c(v_0) + c(v_1) + \\dots + c(v_k)$. This can be rewritten by separating the cost of the starting node:\n$$C(P) = c(v_0) + \\sum_{i=1}^{k} c(v_i)$$\nThe summation term represents the accumulated cost from traversing the edges $(v_0, v_1), (v_1, v_2), \\dots, (v_{k-1}, v_k)$. For each edge $(u, v)$ in the path, the cost incurred upon arriving at node $v$ is $c(v)$. This suggests we can define a new graph $G' = (V, E)$ where the weight of each edge $(u, v) \\in E$ is equal to the cost of its destination node, i.e., $w(u, v) = c(v)$.\n\nWith this transformation, the cost of the path $P$ becomes:\n$$C(P) = c(s) + \\sum_{i=0}^{k-1} w(v_i, v_{i+1})$$\nwhere the sum is the standard path length in the edge-weighted graph $G'$. The problem is now to find a path from $s$ to $t$ that minimizes this sum, and then add the initial cost $c(s)$.\n\nSince all node costs $c(v)$ are nonnegative, the corresponding edge weights $w(u, v) = c(v)$ are also nonnegative. For finding the shortest path in a graph with nonnegative edge weights, Dijkstra's algorithm is a correct and efficient choice.\n\nWe can adapt Dijkstra's algorithm to compute the total path cost directly. Let $d(v)$ represent the minimum total energy consumption of a path from $s$ to $v$.\n\nThe algorithm proceeds as follows:\n1.  **Initialization**:\n    -   Create a distance array $d$ of size $|V|$, and initialize all entries to infinity, $d(v) = \\infty$ for all $v \\in V$.\n    -   The path from $s$ to itself is just the node $s$, with a cost of $c(s)$. So, we initialize the distance to the start node as $d(s) = c(s)$.\n    -   Create a priority queue and add the starting node with its cost: $(c(s), s)$. The priority queue will store tuples of (cost, node) and prioritize the one with the lowest cost.\n\n2.  **Main Loop**:\n    -   While the priority queue is not empty, extract the entry $(d_u, u)$ with the minimum cost.\n    -   If $d_u > d(u)$, this is an outdated entry from a longer path, so we ignore it and continue.\n    -   If $u = t$, we have found the shortest path to the target node. Because edge weights are nonnegative, the first time we extract the target node, its path cost is guaranteed to be minimal. The algorithm can terminate and return $d(t)$.\n\n3.  **Relaxation**:\n    -   For each neighbor $v$ of the current node $u$, such that $(u, v) \\in E$, calculate the cost of the path to $v$ through $u$. This cost is $d(u) + c(v)$.\n    -   If this new cost is less than the currently known cost $d(v)$, we have found a shorter path to $v$. We update $d(v) = d(u) + c(v)$ and add the new pair $(d(v), v)$ to the priority queue.\n\n4.  **Unreachability**:\n    -   If the main loop completes and the target node $t$ was never reached, its distance $d(t)$ will remain at its initial value of $\\infty$. This indicates that there is no path from $s$ to $t$. In this case, the answer is defined to be $-1$.\n\nThis algorithm correctly finds the minimum energy consumption by mapping the node-cost problem to a standard edge-cost shortest path problem and applying Dijkstra's algorithm. The nonnegativity of costs is crucial for the correctness and efficiency of this approach.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Computes the minimum energy path for a series of test cases.\n    \"\"\"\n    \n    test_cases = [\n        (6, [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (4, 5), (2, 5)], [4, 2, 7, 1, 3, 5], 0, 5),\n        (5, [(0, 1), (1, 2), (2, 1), (2, 3), (3, 4)], [1, 9, 2, 8, 3], 0, 4),\n        (4, [(0, 1), (2, 3)], [5, 1, 1, 1], 0, 3),\n        (7, [(0, 1), (0, 2), (2, 3), (1, 4), (4, 3), (3, 5), (5, 6), (1, 6)], [0, 5, 0, 4, 0, 2, 1], 0, 6),\n        (1, [], [42], 0, 0)\n    ]\n\n    results = []\n    for case in test_cases:\n        n, edges, costs, s, t = case\n        result = _find_min_cost_path(n, edges, costs, s, t)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef _find_min_cost_path(n, edges, costs, s, t):\n    \"\"\"\n    Calculates the minimum cost path from s to t using Dijkstra's algorithm.\n\n    The problem has costs on nodes, which is handled by defining the weight of an\n    edge (u, v) as the cost of the destination node, c(v).\n    \"\"\"\n\n    if n == 0:\n        return -1\n\n    # Build adjacency list representation of the graph.\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n\n    # dist[i] will store the minimum cost to reach node i from s.\n    # Initialize all distances to infinity.\n    dist = np.full(n, np.inf, dtype=np.float64)\n\n    # The cost to reach the start node 's' is its own cost.\n    dist[s] = costs[s]\n\n    # Priority queue for Dijkstra's. Stores tuples of (cost, node).\n    pq = [(costs[s], s)]\n\n    while pq:\n        # Get the node with the smallest distance from the priority queue.\n        d, u = heapq.heappop(pq)\n\n        # If a shorter path to u has already been found, skip.\n        if d > dist[u]:\n            continue\n\n        # If the target node is extracted, its shortest path is found.\n        if u == t:\n            return int(dist[t])\n\n        # Explore neighbors of the current node u.\n        for v in adj[u]:\n            # The cost to reach neighbor v through u is the cost to reach u\n            # plus the cost of node v itself.\n            new_dist = dist[u] + costs[v]\n            \n            # If we found a shorter path to v, update its distance and push to queue.\n            if new_dist  dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(pq, (new_dist, v))\n\n    # If the loop finishes, it means the target node was not reachable from the source.\n    # This is implicitly handled by the `if u == t` check, as t would never be popped.\n    # This part of the code is only reached if t is unreachable.\n    return -1\n\nsolve()\n```", "id": "3235343"}, {"introduction": "Moving beyond the analysis of optimal paths, this final practice challenges you to assess the global structural integrity of a flowchart. You will design an algorithm to detect a particularly dangerous flaw: an infinite loop that is reachable but from which no terminal state can ever be reached. This task requires you to synthesize several fundamental graph traversal techniques to identify these inescapable traps within the flowchart's structure [@problem_id:3235265]. This advanced exercise illustrates how graph theory provides the foundation for building sophisticated automated program analysis and verification tools.", "problem": "You are given a formal representation of a flowchart as a directed graph. The flowchart is represented by a directed graph $G = (V, E)$, where $V = \\{0, 1, \\dots, n-1\\}$ is the set of nodes and $E \\subseteq V \\times V$ is the set of directed edges. Each node represents a step in the flowchart: action, decision, or terminal. A distinguished start node is denoted by $s \\in V$. A set of terminal nodes (nodes that represent halting conditions of the flowchart) is denoted by $T \\subseteq V$. The directed edges are given by an adjacency list where for each $v \\in V$ we have a list of successors $N^+(v) = \\{u \\in V \\mid (v, u) \\in E\\}$.\n\nThe goal is to determine whether the flowchart contains an infinite loop that satisfies all of the following properties:\n- It is reachable from the start node $s$ by a path, that is, there exists a sequence of nodes $s = v_0, v_1, \\dots, v_k$ with $k \\geq 1$ such that $(v_i, v_{i+1}) \\in E$ for all $i \\in \\{0, \\dots, k-1\\}$ and some node in the loop is among $\\{v_0, \\dots, v_k\\}$.\n- It is a genuine loop, meaning it contains a directed cycle. Formally, there exists a nonempty sequence of nodes $w_0, w_1, \\dots, w_m$ with $m \\geq 1$ such that $(w_i, w_{i+1}) \\in E$ for all $i \\in \\{0, \\dots, m-1\\}$ and $w_m = w_0$. Equivalently, it is a strongly connected component (SCC) of $G$ with at least two nodes, or a single node with a self-loop.\n- From any node in this loop, no terminal node is reachable. Formally, for all $u$ in the loop and for all $t \\in T$, there does not exist a path from $u$ to $t$.\n\nFundamental base to start your derivation and algorithm design:\n- Definition of a directed graph $G = (V, E)$ and reachability: node $x \\in V$ can reach node $y \\in V$ if there exists a path from $x$ to $y$.\n- Definition of a strongly connected component (SCC): a maximal subset $S \\subseteq V$ such that for all $x, y \\in S$ there exists a path from $x$ to $y$ and a path from $y$ to $x$.\n- Fact: A directed cycle exists if and only if there is a strongly connected component with at least two nodes, or a single node with an edge to itself.\n\nYour task is to write a program that, given a set of predefined test cases, determines for each case whether such an infinite loop exists and outputs the results.\n\nInput representation for each test case (fixed in the program code, no external input):\n- An integer $n$ representing the number of nodes, labeled $0$ through $n-1$.\n- An adjacency list $A$ of length $n$ where $A[v]$ is the list of successors of node $v$.\n- A start node index $s \\in \\{0, \\dots, n-1\\}$.\n- A set of terminal nodes $T \\subseteq \\{0, \\dots, n-1\\}$.\n\nTest suite to validate different facets of the solution:\n- Case $1$ (reachable cycle without a path to any terminal): $n = 7$, $A = [[1],[2],[3],[1,4],[6],[],[]]$, $s = 0$, $T = \\{5\\}$. Expected output element is a boolean indicating detection of an infinite loop reachable from $s$ and unable to reach any terminal.\n- Case $2$ (cycle with an exit to a terminal): $n = 6$, $A = [[1],[2],[3,4],[1],[5],[]]$, $s = 0$, $T = \\{5\\}$. The cycle can reach a terminal, so the infinite loop condition should not be detected.\n- Case $3$ (acyclic graph): $n = 5$, $A = [[1],[2],[3],[4],[]]$, $s = 0$, $T = \\{4\\}$. No cycles exist.\n- Case $4$ (unreachable cycle from the start node): $n = 7$, $A = [[1],[2],[3],[4],[],[6],[5]]$, $s = 0$, $T = \\{4\\}$. The cycle on nodes $\\{5, 6\\}$ exists but is not reachable from $s$.\n- Case $5$ (self-loop with no path to any terminal): $n = 3$, $A = [[1],[1],[]]$, $s = 0$, $T = \\{2\\}$. Node $1$ has a self-loop and no terminal is reachable from it, and it is reachable from $s$.\n- Case $6$ (start is terminal): $n = 2$, $A = [[1],[]]$, $s = 0$, $T = \\{0\\}$. No infinite loop should be detected.\n- Case $7$ (no terminal nodes): $n = 3$, $A = [[1],[2],[1]]$, $s = 0$, $T = \\emptyset$. Any reachable cycle qualifies because there is no terminal to reach.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[result_1, result_2, \\dots, result_k]$, where each $result_i$ is a boolean ($\\text{True}$ or $\\text{False}$) for the corresponding test case.", "solution": "The problem requires us to determine if a given flowchart, represented as a directed graph $G = (V, E)$, contains a specific type of infinite loop. A valid infinite loop must satisfy a set of three properties simultaneously. Let a cycle be denoted by a set of nodes $C \\subseteq V$ that form a non-trivial strongly connected component (an SCC with $|C|  1$, or an SCC with $|C|=1$ corresponding to a node with a self-loop). The conditions for such a loop to be considered are:\n\n1.  **Reachability**: The loop must be reachable from the designated start node $s \\in V$. This means there must exist a path from $s$ to at least one node $w \\in C$.\n2.  **Cyclicality**: The loop must be a \"genuine loop,\" meaning it corresponds to a non-trivial SCC of the graph $G$.\n3.  **No Escape**: From any node $u \\in C$ within the loop, it must be impossible to reach any terminal node $t \\in T$.\n\nA direct verification of these properties for every possible cycle can be computationally intensive. A more structured, principled approach is to decompose the problem into a sequence of logical steps that progressively filter the graph to isolate the relevant structures. The core strategy is to first identify all nodes from which a terminal state is reachable, prune them from consideration for forming a valid loop, and then search for reachable cycles in the remaining \"safe\" portion of the graph.\n\nThe algorithmic solution is structured into three main phases:\n\n**Phase 1: Identification of Nodes That Can Reach a Terminal Node**\n\nLet $\\mathcal{C}_T$ be the set of all nodes in $V$ from which at least one terminal node in $T$ is reachable. Formally,\n$$ \\mathcal{C}_T = \\{ v \\in V \\mid \\exists t \\in T \\text{ and there exists a path from } v \\text{ to } t \\text{ in } G \\} $$\nTo compute this set efficiently, we can analyze the problem in reverse. A path exists from $v$ to $t$ in $G$ if and only if a path exists from $t$ to $v$ in the transpose graph $G^T$. The transpose graph is defined as $G^T = (V, E^T)$, where $E^T = \\{ (u, v) \\mid (v, u) \\in E \\}$.\n\nThus, we can find all nodes in $\\mathcal{C}_T$ by performing a multi-source graph traversal (such as Breadth-First Search or Depth-First Search) on $G^T$ starting simultaneously from all nodes in the terminal set $T$. The set of all nodes visited during this traversal is precisely $\\mathcal{C}_T$.\n\n**Phase 2: Identification of \"Safe\" Cycles**\n\nA cycle $C$ satisfies the \"no escape\" property if and only if all of its constituent nodes are \"safe,\" meaning none of them can reach a terminal node. Let the set of safe nodes be $V_{\\text{safe}} = V \\setminus \\mathcal{C}_T$. A safe cycle is a cycle where all its nodes belong to $V_{\\text{safe}}$.\n\nTo find all nodes that are part of such safe cycles, we can analyze the subgraph induced by $V_{\\text{safe}}$, denoted as $G_{\\text{safe}} = (V_{\\text{safe}}, E_{\\text{safe}})$, where $E_{\\text{safe}} = \\{ (u, v) \\in E \\mid u \\in V_{\\text{safe}} \\text{ and } v \\in V_{\\text{safe}} \\}$.\n\nWe need to find all non-trivial strongly connected components within $G_{\\text{safe}}$. A standard algorithm for finding all SCCs in a directed graph, such as Tarjan's algorithm or Kosaraju's algorithm, can be applied to $G_{\\text{safe}}$. Let $U_{\\text{safe\\_cycle}}$ be the set of all nodes that belong to a non-trivial SCC of $G_{\\text{safe}}$. A non-trivial SCC is one with more than one node, or a single-node SCC that has a self-loop. The set $U_{\\text{safe\\_cycle}}$ contains all nodes that satisfy conditions $2$ and $3$.\n\n**Phase 3: Verification of Reachability from the Start Node**\n\nThe final step is to determine if any node in a safe cycle is reachable from the start node $s$. This corresponds to checking if any node in $U_{\\text{safe\\_cycle}}$ is reachable from $s$ in the original graph $G$.\n\nThis can be solved by a standard single-source graph traversal (BFS or DFS) on the original graph $G$, starting from node $s$. Let $\\mathcal{R}_s$ be the set of all nodes reachable from $s$. The problem's condition is met if and only if the intersection of the set of nodes reachable from $s$ and the set of nodes in safe cycles is non-empty.\n$$ \\mathcal{R}_s \\cap U_{\\text{safe\\_cycle}} \\neq \\emptyset $$\nDuring the traversal from $s$, if we encounter any node $v$ such that $v \\in U_{\\text{safe\\_cycle}}$, we have found a path from $s$ to a safe cycle. The algorithm can then terminate and report $\\text{True}$. If the traversal completes without finding any such node, no reachable safe cycle exists, and the result is $\\text{False}$.\n\nThis three-phase algorithm correctly and efficiently determines the existence of the specified type of infinite loop by systematically applying fundamental graph-theoretic principles.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\nimport sys\n\n# Increase recursion limit for deep graphs in Tarjan's algorithm\nsys.setrecursionlimit(2000)\n\ndef solve():\n    \"\"\"\n    Solves a series of test cases for detecting a specific type of infinite loop in a flowchart.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (reachable cycle without a path to any terminal)\n        {'n': 7, 'adj': [[1],[2],[3],[1,4],[6],[],[]], 's': 0, 'T': {5}},\n        # Case 2 (cycle with an exit to a terminal)\n        {'n': 6, 'adj': [[1],[2],[3,4],[1],[5],[]], 's': 0, 'T': {5}},\n        # Case 3 (acyclic graph)\n        {'n': 5, 'adj': [[1],[2],[3],[4],[]], 's': 0, 'T': {4}},\n        # Case 4 (unreachable cycle from the start node)\n        {'n': 7, 'adj': [[1],[2],[3],[4],[],[6],[5]], 's': 0, 'T': {4}},\n        # Case 5 (self-loop with no path to any terminal)\n        {'n': 3, 'adj': [[1],[1],[]], 's': 0, 'T': {2}},\n        # Case 6 (start is terminal)\n        {'n': 2, 'adj': [[1],[]], 's': 0, 'T': {0}},\n        # Case 7 (no terminal nodes)\n        {'n': 3, 'adj': [[1],[2],[1]], 's': 0, 'T': set()},\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(has_infinite_loop(case['n'], case['adj'], case['s'], case['T']))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef has_infinite_loop(n, adj, s, T):\n    \"\"\"\n    Determines if a flowchart contains a reachable, non-escapable infinite loop.\n\n    This function implements a three-phase algorithm:\n    1.  Find all nodes that can reach a terminal node.\n    2.  Identify all \"safe\" cycles (cycles whose nodes cannot reach a terminal).\n    3.  Check if any node in a safe cycle is reachable from the start node.\n    \"\"\"\n\n    # Phase 1: Find all nodes that can reach a terminal node.\n    rev_adj = [[] for _ in range(n)]\n    for u in range(n):\n        for v in adj[u]:\n            rev_adj[v].append(u)\n\n    can_reach_terminal = set()\n    q = deque(list(T))\n    can_reach_terminal.update(T)\n\n    while q:\n        u = q.popleft()\n        for v in rev_adj[u]:\n            if v not in can_reach_terminal:\n                can_reach_terminal.add(v)\n                q.append(v)\n                \n    safe_nodes = {i for i in range(n) if i not in can_reach_terminal}\n\n    # Phase 2: Identify all \"safe\" cycles using Tarjan's algorithm.\n    nodes_in_safe_cycle = set()\n    \n    # Tarjan's algorithm state\n    ids = np.full(n, -1, dtype=int)\n    low_link = np.full(n, -1, dtype=int)\n    on_stack = np.full(n, False, dtype=bool)\n    stack = []\n    at_index = 0\n\n    def tarjan_dfs(u):\n        nonlocal at_index\n        stack.append(u)\n        on_stack[u] = True\n        ids[u] = low_link[u] = at_index\n        at_index += 1\n\n        for v in adj[u]:\n            if v not in safe_nodes:\n                continue\n            \n            if ids[v] == -1:\n                tarjan_dfs(v)\n                low_link[u] = min(low_link[u], low_link[v])\n            elif on_stack[v]:\n                low_link[u] = min(low_link[u], ids[v])\n\n        if low_link[u] == ids[u]:\n            scc = []\n            while stack:\n                node = stack.pop()\n                on_stack[node] = False\n                scc.append(node)\n                if node == u:\n                    break\n            \n            # Check for non-trivial SCC\n            if len(scc) > 1:\n                nodes_in_safe_cycle.update(scc)\n            elif len(scc) == 1:\n                node = scc[0]\n                # Check for self-loop\n                if node in adj[node]:\n                    nodes_in_safe_cycle.add(node)\n\n    for i in range(n):\n        if i in safe_nodes and ids[i] == -1:\n            tarjan_dfs(i)\n\n    if not nodes_in_safe_cycle:\n        return False\n\n    # Phase 3: Check if any node in a safe cycle is reachable from the start node s.\n    q_reach = deque([s])\n    visited_reach = {s}\n\n    while q_reach:\n        u = q_reach.popleft()\n        if u in nodes_in_safe_cycle:\n            return True\n        for v in adj[u]:\n            if v not in visited_reach:\n                visited_reach.add(v)\n                q_reach.append(v)\n                \n    return False\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3235265"}]}