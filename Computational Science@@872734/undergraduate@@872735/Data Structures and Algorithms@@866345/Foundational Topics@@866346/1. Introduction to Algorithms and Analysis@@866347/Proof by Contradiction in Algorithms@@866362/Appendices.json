{"hands_on_practices": [{"introduction": "The proof of correctness for the Gale-Shapley algorithm is a perfect illustration of proof by contradiction. To demonstrate its stability, we start by making the opposite assumption: that the algorithm can produce an unstable matching containing a \"rogue couple.\" This exercise challenges you to trace the logical consequences of this assumption and discover how it clashes directly with the step-by-step mechanics of the algorithm itself [@problem_id:3261402].", "problem": "Consider the Stable Marriage Problem (SMP) with a set $M$ of $n$ men and a set $W$ of $n$ women, where each participant has a strict total order preference over the members of the opposite set. The Deferred Acceptance (DA) algorithm of Gale and Shapley in its man-proposing variant operates as follows: while there exists an unmatched man, he proposes to the most-preferred woman on his list to whom he has not yet proposed; each woman holds the most-preferred proposal she has received so far (if any) and rejects all others; the algorithm terminates when all men are matched, producing a matching function $\\mu$ that maps each $m \\in M$ to some $\\mu(m) \\in W$ and each $w \\in W$ to some $\\mu(w) \\in M$.\n\nA matching $\\mu$ is stable if there is no pair $(m,w)$ such that $w \\succ_m \\mu(m)$ and $m \\succ_w \\mu(w)$, where $\\succ_x$ denotes the strict preference relation of participant $x$. Such a pair $(m,w)$ is called a rogue couple or blocking pair.\n\nAssume, for contradiction, that the man-proposing Deferred Acceptance algorithm produces a matching $\\mu$ that contains a rogue couple $(m,w)$. Which statement about the proposals and preferences of $m$ and $w$ must be true and simultaneously contradicts the operation of the algorithm?\n\nA. If $(m,w)$ is rogue in $\\mu$, then $w \\succ_m \\mu(m)$ and $m \\succ_w \\mu(w)$; therefore $m$ must have proposed to $w$ before proposing to $\\mu(m)$, and $w$ must have rejected $m$ only because she was holding a suitor she prefers strictly more than $m$. Because a woman’s held suitor can only improve over time in the Deferred Acceptance algorithm, $\\mu(w)$ must be someone $w$ prefers at least as much as $m$, contradicting $m \\succ_w \\mu(w)$.\n\nB. If $(m,w)$ is rogue, it is possible that $m$ never proposed to $w$ because he was accepted by $\\mu(m)$ earlier, so the algorithm can terminate with a rogue pair without any rejection involving $w$.\n\nC. For $(m,w)$ to be rogue, it suffices that $w \\succ_m \\mu(m)$, regardless of $w$’s preferences, because the man-proposing Deferred Acceptance algorithm favors men.\n\nD. The contradiction arises because women can be forced by the algorithm to discard a better suitor $m$ later in the run and accept a worse final partner $\\mu(w)$ at termination.\n\nE. A rogue pair requires that $m$ and $w$ rank each other last, making them unlikely to propose to each other, which the algorithm cannot detect.", "solution": "The proof proceeds by contradiction.\n**1. Assumption:** Assume the matching $\\mu$ produced by the algorithm is *unstable*. This means there must exist a \"rogue couple\" $(m, w)$ such that:\n- They are not matched: $\\mu(m) \\neq w$.\n- They both prefer each other to their assigned partners: $w \\succ_m \\mu(m)$ and $m \\succ_w \\mu(w)$.\n\n**2. Logical Deduction:** Let's trace the consequences based on the algorithm's rules.\n- **Man $m$'s proposals:** Because man $m$ prefers woman $w$ to his final partner $\\mu(m)$ ($w \\succ_m \\mu(m)$), and men propose in descending order of preference, **$m$ must have proposed to $w$ at some point** during the algorithm. He would not have settled for the lower-ranked $\\mu(m)$ if the higher-ranked $w$ was still on his list.\n- **Woman $w$'s rejection:** Since $m$ and $w$ are not matched in the end, it must be that **$w$ rejected $m$**. According to the algorithm, a woman only rejects a suitor (either immediately or by leaving a provisional match) if she has a proposal from another man, let's call him $m'$, whom she prefers more ($m' \\succ_w m$).\n- **Woman $w$'s final partner:** A crucial invariant of the algorithm is that a woman's sequence of provisional partners only gets better from her perspective. She never discards a preferred suitor for a less-preferred one. Therefore, her final partner, $\\mu(w)$, must be at least as good as any man she was ever provisionally engaged to, including $m'$. This means $\\mu(w)$ is preferred to or is the same as $m'$. Given strict preferences, this implies $\\mu(w) \\succeq_w m'$.\n\n**3. The Contradiction:** By transitivity, we have $\\mu(w) \\succeq_w m'$ and $m' \\succ_w m$. This logically implies that **$w$ prefers her final partner $\\mu(w)$ over $m$** ($\\mu(w) \\succ_w m$). This conclusion directly contradicts the second part of our initial assumption for a rogue couple, which was $m \\succ_w \\mu(w)$.\n\nSince the assumption of a rogue couple leads to a logical impossibility, the assumption must be false. The matching $\\mu$ must be stable.\n\nOption A correctly summarizes this entire chain of reasoning. Option B is false because $m$ must have proposed to $w$. Option C is false because stability requires mutual preference. Option D is false because a woman's partner sequence is always improving. Option E is based on a fabricated condition.", "answer": "$$\\boxed{A}$$", "id": "3261402"}, {"introduction": "Proof by contradiction is a powerful tool not just for correctness, but for establishing computational bounds. In this exercise, you are confronted with a claim that seems too good to be true: a standard binary heap with a worst-case $O(1)$ `decrease-key` operation. By assuming this claim is valid, you can rigorously deduce which fundamental property of the heap must be violated, thereby exposing the inherent complexity of the operation [@problem_id:3261400].", "problem": "A software engineer claims to have implemented a priority queue using a standard binary heap that supports a worst-case $O(1)$ decrease-key operation. The priority queue is a min-heap. The data structure is said to remain a standard binary heap at all times. A standard binary heap is defined by two invariants: (i) the heap-order property, namely for every node $u$ other than the root, $\\text{key}(\\text{parent}(u)) \\le \\text{key}(u)$, and (ii) the completeness (shape) property, namely the underlying binary tree is complete: all levels are fully filled except possibly the last, and the last level is filled from left to right. The number of elements stored is $n$, where $n \\ge 1$.\n\nUsing only the core definitions of these invariants, the fact that the height of a complete binary tree with $n$ nodes is $\\Theta(\\log n)$, and the definition of the decrease-key operation (which lowers a key value of an existing element, without removing or inserting elements), reason by contradiction about the engineer’s claim. Assume operations are performed in the standard comparison model where restoring heap-order may require comparing along ancestor paths.\n\nWhich statement best identifies the specific heap property that must be violated if a worst-case $O(1)$ decrease-key operation is claimed for a data structure that is otherwise a standard binary heap?\n\nA. The heap-order property must be violated, because lowering a key can require moving an element above all of its ancestors, which in a complete binary tree can take $\\Theta(\\log n)$ steps.\n\nB. The completeness (shape) property must be violated, because preserving heap-order after a decrease-key can only be done by breaking the left-to-right fill order in constant time.\n\nC. The comparison-based lower bound for sorting must be violated, because an $O(1)$ decrease-key directly implies sorting in $o(n \\log n)$ time.\n\nD. No property must be violated; $O(1)$ worst-case decrease-key is achievable on a standard binary heap by storing each element’s array index and updating in place without any structural changes.", "solution": "The proof proceeds by contradiction.\n\n**1. Assumption:** Assume the engineer's claim is true: there exists a `decrease-key` operation on a standard binary min-heap that runs in $O(1)$ worst-case time, while always preserving both the heap-order and completeness properties.\n\n**2. Constructing a Worst-Case Scenario:** To test the \"worst-case\" claim, we must construct a scenario that requires the maximum amount of work.\n- Consider a large, perfectly balanced binary heap of height $h$ with $n$ nodes. The height is $h = \\Theta(\\log n)$.\n- Select an element located at a leaf node.\n- Perform the `decrease-key` operation on this leaf, changing its value to be smaller than the value of the current root of the heap.\n\n**3. Logical Deduction (Restoring the Heap Invariant):**\n- After the key is decreased, the **heap-order property** is likely violated. The modified node's key is now smaller than its parent's key, which is not allowed in a min-heap.\n- To restore the heap-order property, the modified element must be moved upwards in the tree. This is done by repeatedly swapping it with its parent as long as its key is smaller than its parent's key (an operation often called \"bubble-up\" or \"sift-up\").\n- In our worst-case scenario, the new key is the smallest in the entire heap. Therefore, the element must bubble up along its entire ancestral path until it becomes the new root.\n- The length of this path from a leaf to the root is the height of the tree, which is $h = \\Theta(\\log n)$. This process requires $\\Theta(\\log n)$ comparisons and potential swaps.\n\n**4. The Contradiction:**\n- The work required to restore the heap-order property in this worst-case scenario is $\\Theta(\\log n)$.\n- However, our initial assumption was that the operation completes in $O(1)$ time. For large $n$, an operation that requires $\\Theta(\\log n)$ steps cannot be completed in $O(1)$ time.\n- This means that if the operation halts in $O(1)$ time, it cannot have completed the necessary bubble-up process. Consequently, the data structure would be left in a state where the **heap-order property is violated**.\n- This contradicts the premise that the data structure remains a standard binary heap *at all times*.\n\nTherefore, the initial claim must be false. A `decrease-key` operation on a standard binary heap has a worst-case time complexity of $\\Omega(\\log n)$.\n\nOption A correctly identifies that the heap-order property must be violated because restoring it can take $\\Theta(\\log n)$ time, which contradicts the $O(1)$ claim.", "answer": "$$\\boxed{A}$$", "id": "3261400"}, {"introduction": "This practice explores one of the most profound results in computer science, the undecidability of the Halting Problem, which is proven using a masterful proof by contradiction. You will construct a paradoxical program that uses a hypothetical \"halting decider\" against itself. Analyzing the behavior of this program reveals a logical impossibility, forcing us to conclude that such a universal decider cannot exist [@problem_id:3261405].", "problem": "Consider the following hypothetical scenario in the theory of computation, grounded in the standard model of a Turing Machine (TM): assume there exists a program (algorithm) $H$ that, given the complete description of any program $P$ (which takes no input), returns $H(P) \\in \\{0,1\\}$ where $H(P) = 1$ if $P$ halts and $H(P) = 0$ if $P$ runs forever. Using $H$, define a program $G$ that, on input $P$, does the following: if $H(P) = 0$ then $G(P)$ halts immediately, and if $H(P) = 1$ then $G(P)$ enters an infinite loop. Now consider running $G$ on its own description, i.e., $G(G)$.\n\nWhich of the following statements best describes the logical consequence of this setup, based on core definitions of decidability and the method of proof by contradiction?\n\nA. $G(G)$ halts; therefore $H(G) = 0$ and the construction is self-consistent.\n\nB. $G(G)$ runs forever; therefore $H(G) = 1$ and the construction is self-consistent.\n\nC. Running $G(G)$ produces a contradiction: whichever value $H(G)$ returns, $G(G)$ behaves oppositely; thus the assumption that such an $H$ exists is false.\n\nD. $G(G)$ is undefined due to self-reference; therefore the halting property cannot be addressed by formal models like a Turing Machine (TM).", "solution": "The proof that the Halting Problem is undecidable is a classic proof by contradiction.\n\n**1. Assumption:** Assume, for the sake of contradiction, that there exists a universal halting decider program, $H$. This program $H$ takes the description of another program $P$ as input and always halts with one of two outputs:\n- $H(P) = 1$ if program $P$ halts when run on its own description.\n- $H(P) = 0$ if program $P$ runs forever when run on its own description.\n\n**2. Constructing an Adversarial Program:** Using our hypothetical decider $H$, we can construct a new, \"contrarian\" program, $G$. The logic of $G$ is designed to do the opposite of what $H$ predicts.\n- Program $G$ takes a program description $P$ as input.\n- It first runs $H(P)$ to get the prediction.\n- If $H(P)$ returns 1 (predicting $P$ will halt), then $G(P)$ deliberately enters an infinite loop.\n- If $H(P)$ returns 0 (predicting $P$ will run forever), then $G(P)$ immediately halts.\n\n**3. The Paradoxical Question:** The construction of $G$ is logically sound, *assuming $H$ exists*. The contradiction arises when we ask: What happens when we run program $G$ on its own description? What is the behavior of $G(G)$?\n\n**4. The Contradiction:** Let's analyze the two possibilities for the output of the internal call to $H(G)$:\n- **Case 1: $H(G)$ returns 1.**\n    - By the definition of $H$, this means $H$ predicts that $G(G)$ will halt.\n    - But by the definition of $G$, if its internal call to $H$ returns 1, its instruction is to enter an infinite loop. So, $G(G)$ runs forever.\n    - This is a contradiction: The prediction is \"halts,\" but the outcome is \"runs forever.\"\n\n- **Case 2: $H(G)$ returns 0.**\n    - By the definition of $H$, this means $H$ predicts that $G(G)$ will run forever.\n    - But by the definition of $G$, if its internal call to $H$ returns 0, its instruction is to halt immediately. So, $G(G)$ halts.\n    - This is also a contradiction: The prediction is \"runs forever,\" but the outcome is \"halts.\"\n\nIn every possible case, $G(G)$ does the exact opposite of what $H$ predicts it will do. This shatters the premise that $H$ is a correct universal decider. Since the construction of $G$ was flawless, the only faulty part of our logic was the initial assumption.\n\nTherefore, the assumption that a halting decider program $H$ can exist is false. The Halting Problem is undecidable.\n\nOption C correctly captures this entire argument: running $G(G)$ creates a paradox where it behaves oppositely to any prediction $H$ can make, thus proving $H$ cannot exist.", "answer": "$$\\boxed{C}$$", "id": "3261405"}]}