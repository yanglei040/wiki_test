{"hands_on_practices": [{"introduction": "Theory is essential, but there is no substitute for building something yourself. This first practice challenges you to implement a complete heap allocator from the ground up, using the foundational first-fit strategy. By managing a free list sorted by memory address, you will gain hands-on experience with the critical operations of block splitting, coalescing, and performance analysis under a precise cost model [@problem_id:3239179].", "problem": "Consider a heap memory allocator whose free list is maintained in strictly increasing address order. You will implement a simulator for this allocator and empirically analyze its performance under a precisely specified unit-cost model. All addresses and sizes are integer units, the heap starts at address $0$, and the capacity is a fixed integer $C$. The free list initially contains one block covering the entire heap. Allocation requests and deallocation requests are processed sequentially.\n\nDefinitions and rules:\n- The heap has capacity $C \\in \\mathbb{N}$ addressable units.\n- A free block is a pair $(a,s)$ with starting address $a \\in \\mathbb{N}$ and size $s \\in \\mathbb{N}$, representing the half-open interval $[a,a+s)$.\n- The free list is a sequence of free blocks sorted by strictly increasing $a$ with no overlap or adjacency among distinct blocks.\n- Allocation request alloc$(x)$ with $x \\in \\mathbb{N}$ uses the first-fit policy: scan the free list in address order to find the first block $(a,s)$ with $s \\ge x$. If found, allocate the lowest addresses, returning an allocated block $[a,a+x)$ and splitting the free block to $(a+x, s-x)$ if $s > x$, or removing it if $s = x$. If no block fits, the allocation fails.\n- Deallocation request free$(i)$ releases the previously returned block for handle $i \\in \\mathbb{N}$ back into the free list. Insertion is performed so that the free list remains sorted by starting address, followed by immediate coalescing with predecessor and/or successor if and only if they are exactly adjacent (that is, $(a_{\\text{pred}}, s_{\\text{pred}})$ where $a_{\\text{pred}} + s_{\\text{pred}} = a_{\\text{new}}$, and similarly for the successor).\n- Each successful allocation is assigned a distinct handle $i \\in \\mathbb{N}$, starting at $i=1$ and increasing by $1$ for each success. Subsequent free$(i)$ refers to this handle. No request will attempt to free a handle that was never successfully allocated.\n\nUnit-cost step model:\n- For alloc$(x)$: each visited free block during the left-to-right scan counts as exactly $1$ step, including the block that satisfies the request or the last examined block in case of failure. Splitting and updates do not add steps.\n- For free$(i)$: each move from a free block to the next while searching for the insertion position counts as exactly $1$ step. Additionally, checking adjacency with the predecessor (if it exists) counts as $1$ step, and checking adjacency with the successor (if it exists) counts as $1$ step. The actual merges do not add steps beyond these adjacency checks.\n\nExternal fragmentation:\n- After all operations of a test case complete, let $F$ be the set of free blocks. Define $T = \\sum_{(a,s) \\in F} s$ and $L = \\max\\{s : (a,s) \\in F\\}$, with the convention $T=0$ implies external fragmentation $0$. Otherwise, the external fragmentation ratio is $1 - \\frac{L}{T}$, a real number in $[0,1]$.\n\nYour task:\n- Implement a complete program that simulates this allocator, processes the specified test suite, and reports quantitative metrics from the unit-cost model.\n\nRequired outputs for each test case:\n- The average number of steps per alloc$(\\cdot)$ request over all allocation attempts (including failed attempts), as a real number.\n- The average number of steps per free$(\\cdot)$ request over all deallocations, as a real number.\n- The final number of free blocks, as an integer.\n- The final external fragmentation ratio, as a real number in $[0,1]$.\n\nRounding and final output format:\n- Round all real numbers to exactly $6$ decimal places using standard rounding to nearest, ties to even are acceptable as in typical floating-point formatting.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the values for all test cases concatenated in order. For example, if a single test produced $4$ values $r_1, r_2, r_3, r_4$, and there are multiple tests, the final output should be of the form $[r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}, r_{2,1}, r_{2,2}, \\dots]$, where commas separate adjacent numbers and there are no spaces.\n\nTest suite:\n- Test $1$ (happy path with splitting and coalescing): capacity $C = 64$, operations in order using the notation alloc$(x)$ and free$(i)$:\n  - alloc$(8)$, alloc$(8)$, alloc$(8)$, free$(2)$, alloc$(4)$, alloc$(4)$, alloc$(16)$, free$(1)$, free$(3)$, free$(4)$.\n- Test $2$ (boundary exact fit): capacity $C = 32$, operations:\n  - alloc$(32)$, free$(1)$.\n- Test $3$ (fragmentation shaping and partial fits): capacity $C = 64$, operations:\n  - alloc$(12)$, alloc$(12)$, alloc$(12)$, alloc$(12)$, free$(2)$, free$(4)$, alloc$(10)$, alloc$(10)$, free$(1)$, free$(3)$, alloc$(24)$.\n- Test $4$ (adverse scan for first-fit): capacity $C = 128$, operations:\n  - alloc$(16)$, alloc$(16)$, alloc$(16)$, alloc$(16)$, alloc$(16)$, alloc$(16)$, free$(2)$, free$(4)$, free$(6)$, alloc$(32)$, free$(1)$, free$(3)$, free$(5)$, free$(7)$.\n- Test $5$ (stochastic workload with a Pseudo-Random Number Generator (PRNG)): capacity $C = 256$. Generate a sequence of $N = 200$ operations using the following rule with seed $S = 123456$:\n  - At each step, choose alloc with probability $p = 0.6$ and free with probability $1-p$. If free is chosen when there are no live handles, force alloc instead.\n  - For alloc, draw a size $x$ uniformly from the integers in $[1,32]$. Attempt alloc$(x)$; if it fails, it still counts as one allocation attempt with its step cost, and no handle is created.\n  - For free, choose one currently live handle uniformly at random and free it.\n  - Use the PRNG only to determine the operation type, the allocation size, and the choice of handle to free. The PRNG must be initialized with the given seed $S$ so results are reproducible.\n\nWhat to implement:\n- A simulator that maintains the free list in address order, supports first-fit alloc, address-ordered insertion with immediate coalescing on free, counts steps according to the unit-cost model, and computes external fragmentation. Apply it to the test suite above and print the final flat list of results in the specified order and rounding.", "solution": "We begin from core definitions of heap allocation and list scanning in a comparison-based, unit-cost model. The heap is a contiguous array of $C$ integer-sized units, initially entirely free as a single block. A free list maintains disjoint free blocks sorted by increasing starting address. The allocator uses first-fit, which is a fundamental approach relying on a sequential scan of the free list to find the first block large enough to satisfy a request.\n\nDesign of data structures:\n- Represent the free list as a sequence of pairs $(a,s)$, strictly ordered by $a$. This ensures that predecessor and successor in the list are exactly the immediate neighbors by address among free blocks.\n- Maintain a dictionary mapping each allocated handle $i$ to its block $(a,s)$ to support free$(i)$.\n\nAllocation algorithm (first-fit) from definitions:\n- To allocate a request of size $x$, scan the free list left to right until encountering the first $(a,s)$ with $s \\ge x$. If such a block exists, return the subinterval $[a,a+x)$ to the client, and update the free block to $(a+x, s-x)$ if $s > x$, or remove it entirely if $s = x$.\n- If no such block exists, the request fails.\n- Under the unit-cost model, each visited block in the scan is counted as exactly $1$ step, including the final visited block whether or not the request succeeds. This follows from the basic cost model of sequential search, where each node visitation is one step.\n\nDeallocation algorithm (address-ordered insertion with coalescing):\n- For free$(i)$, recover $(a,s)$ from the handle and insert it back into the free list at the unique index that preserves address order. Because the list is sorted by $a$, insertion point can be found by a left-to-right scan. Each advance to the next list node contributes $1$ step in the cost model.\n- After insertion, check at most two adjacencies for coalescing:\n  - Check predecessor adjacency: if there is a predecessor $(a_p,s_p)$ and $a_p + s_p = a$, merge to $(a_p, s_p + s)$ by replacing the two blocks with the single merged block. The check itself is counted as one step.\n  - Check successor adjacency: if there is a successor $(a_s,s_s)$ and $a + s = a_s$, merge to $(a, s + s_s)$ similarly. The check is counted as one step. If both predecessor and successor are adjacent, both merges occur, yielding a single combined block.\n- Actual merges do not incur additional steps beyond adjacency checks, reflecting the principle that comparisons and pointer moves dominate in this list-based model.\n\nExternal fragmentation:\n- After completing a test case, compute $T = \\sum_{(a,s) \\in F} s$ and $L = \\max\\{s : (a,s) \\in F\\}$ if $F \\ne \\emptyset$, with the convention that if $T=0$ then the fragmentation is $0$. Otherwise, the external fragmentation ratio is $1 - \\frac{L}{T}$, which lies in $[0,1]$ due to $L \\le T$.\n\nComplexity derivation from first principles:\n- Let $k$ be the current number of free blocks. A sequential scan over the address-ordered list to find the first fit touches up to $k$ blocks in the worst case, so the worst-case cost is $\\Theta(k)$ steps by the unit-cost model. This follows directly from the definition of sequential search: each block visitation contributes exactly one step and up to all $k$ blocks can be examined.\n- For free$(i)$, finding the insertion point in address order is again a sequential search over up to $k$ blocks, so the search cost is $\\Theta(k)$. Coalescing requires at most two adjacency checks (predecessor and successor), contributing at most $2$ additional steps. Therefore, the overall worst-case free cost is $\\Theta(k)$.\n- The address-ordered list allows coalescing in $O(1)$ additional comparisons once the insertion point is known, because adjacency can be determined using only the immediate neighbor blocks as a consequence of the total order by $a$. This eliminates the need to search for potentially adjacent blocks elsewhere.\n\nEmpirical measurement plan and correctness:\n- Implement the allocator and instrumentation that accumulates step counts according to the specified model: for alloc$(\\cdot)$, count one step per visited free block; for free$(\\cdot)$, count steps for each advancement while searching, plus up to two adjacency checks. These definitions are directly applied as the fundamental rules used to implement the counters.\n- For each test case, maintain counters for the number of allocation attempts and deallocations, and the total steps for each. At the end of each test, compute the averages as rational numbers $\\frac{\\text{total steps}}{\\text{count}}$, rounded to $6$ decimals.\n- Compute the final number of free blocks $|F|$ and the external fragmentation ratio $1 - \\frac{L}{T}$.\n\nTest suite coverage rationale:\n- Test $1$ exercises splitting, freeing a middle block, subsequent allocations that partially fill holes, and coalescing when freeing neighboring allocated blocks.\n- Test $2$ checks the boundary case of an exact fit that consumes the entire heap and freeing it back to a single block.\n- Test $3$ constructs fragmentation through partial fits to measure external fragmentation and the impact on first-fit scans.\n- Test $4$ creates alternating allocated and free blocks to force a long scan for a larger request, then frees to test full coalescing back to a single block.\n- Test $5$ uses a reproducible stochastic workload generated by a Pseudo-Random Number Generator (PRNG) with a fixed seed, covering varied interleavings, sizes, successes, and failures to provide an aggregate view of performance.\n\nThe program implements these definitions precisely and outputs, for each test in order, four values: the average steps per allocation attempt, the average steps per deallocation, the final count of free blocks, and the final external fragmentation ratio, all in a single flat list and with real numbers rounded to $6$ decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass AddressOrderedAllocator:\n    def __init__(self, capacity: int):\n        # Free list: list of (start, size), sorted by start address\n        self.free_list = [(0, capacity)] if capacity > 0 else []\n        # Allocated blocks by handle -> (start, size)\n        self.allocated = {}\n        self.next_handle = 1\n\n    def alloc(self, size: int):\n        \"\"\"\n        First-fit allocation from address-ordered free list.\n        Returns (handle or None, steps).\n        Steps: 1 per visited free block.\n        \"\"\"\n        steps = 0\n        if size <= 0:\n            return None, steps  # Ignore nonsensical requests; no steps.\n\n        for idx, (start, fsize) in enumerate(self.free_list):\n            steps += 1  # visiting this free block\n            if fsize >= size:\n                handle = self.next_handle\n                self.next_handle += 1\n                # allocate from the start of this block\n                alloc_start = start\n                alloc_size = size\n                self.allocated[handle] = (alloc_start, alloc_size)\n                # adjust free block\n                if fsize == size:\n                    # remove the block\n                    del self.free_list[idx]\n                else:\n                    # shrink the block at the front\n                    self.free_list[idx] = (start + size, fsize - size)\n                return handle, steps\n\n        # No fitting block found\n        return None, steps\n\n    def free(self, handle: int):\n        \"\"\"\n        Free a previously allocated handle.\n        Returns steps.\n        Steps: 1 per move while finding insertion point,\n               +1 for predecessor-adjacency check (if predecessor exists),\n               +1 for successor-adjacency check (if successor exists).\n        \"\"\"\n        steps = 0\n        if handle not in self.allocated:\n            return steps  # no steps per the model (invalid free won't occur in tests)\n\n        start, size = self.allocated.pop(handle)\n\n        # Find insertion index to keep address order\n        i = 0\n        n = len(self.free_list)\n        # Advance while current free block starts before the new block's start\n        while i < n and self.free_list[i][0] < start:\n            steps += 1  # moving to next free block during search\n            i += 1\n\n        # Insert the new free block at index i\n        self.free_list.insert(i, (start, size))\n        # Coalesce with predecessor if adjacent\n        # Check predecessor adjacency if exists\n        if i - 1 >= 0 and len(self.free_list) >= 2:\n            steps += 1  # predecessor adjacency check\n            pred_start, pred_size = self.free_list[i - 1]\n            cur_start, cur_size = self.free_list[i]\n            if pred_start + pred_size == cur_start:\n                # Merge predecessor and current\n                merged = (pred_start, pred_size + cur_size)\n                # Replace predecessor with merged and remove current\n                self.free_list[i - 1] = merged\n                del self.free_list[i]\n                i = i - 1  # merged block now at i-1\n        else:\n            # If no predecessor, no check cost\n            pass\n\n        # Coalesce with successor if adjacent\n        if i + 1 < len(self.free_list):\n            steps += 1  # successor adjacency check\n            cur_start, cur_size = self.free_list[i]\n            succ_start, succ_size = self.free_list[i + 1]\n            if cur_start + cur_size == succ_start:\n                merged = (cur_start, cur_size + succ_size)\n                self.free_list[i] = merged\n                del self.free_list[i + 1]\n        else:\n            # If no successor, no check cost\n            pass\n\n        return steps\n\n    def external_fragmentation(self):\n        if not self.free_list:\n            return 0.0\n        total = sum(sz for _, sz in self.free_list)\n        if total == 0:\n            return 0.0\n        largest = max(sz for _, sz in self.free_list)\n        return 1.0 - (largest / total)\n\ndef run_scripted_test(capacity, ops):\n    \"\"\"\n    ops: list of tuples, ('A', size) or ('F', handle)\n    Allocation handles start at 1 and increment per successful allocation.\n    \"\"\"\n    alloc = AddressOrderedAllocator(capacity)\n    total_malloc_steps = 0\n    total_free_steps = 0\n    count_mallocs = 0\n    count_frees = 0\n\n    for op in ops:\n        if op[0] == 'A':\n            size = int(op[1])\n            handle, steps = alloc.alloc(size)\n            total_malloc_steps += steps\n            count_mallocs += 1\n            # If allocation succeeded, handle is recorded by allocator internally.\n            # Free operations refer to handle numbers as assigned in order,\n            # so scripted frees must match the created handles.\n        elif op[0] == 'F':\n            handle = int(op[1])\n            steps = alloc.free(handle)\n            total_free_steps += steps\n            count_frees += 1\n        else:\n            raise ValueError(\"Unknown operation\")\n\n    avg_malloc = (total_malloc_steps / count_mallocs) if count_mallocs > 0 else 0.0\n    avg_free = (total_free_steps / count_frees) if count_frees > 0 else 0.0\n    free_blocks = len(alloc.free_list)\n    frag = alloc.external_fragmentation()\n    return avg_malloc, avg_free, free_blocks, frag\n\ndef run_random_test(capacity, n_ops, p_alloc, size_low, size_high, seed):\n    \"\"\"\n    Generate operations using a PRNG with given seed.\n    - At each step: alloc with probability p_alloc, else free.\n    - If free but no live handles, force alloc.\n    - For alloc: size uniform integer in [size_low, size_high].\n    - For free: choose a live handle uniformly at random to free.\n    Count steps per the model for both alloc and free.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    alloc = AddressOrderedAllocator(capacity)\n    total_malloc_steps = 0\n    total_free_steps = 0\n    count_mallocs = 0\n    count_frees = 0\n\n    live_handles = []  # list of currently live handles\n\n    for _ in range(n_ops):\n        do_alloc = bool(rng.random() < p_alloc) or (len(live_handles) == 0)\n        if do_alloc:\n            size = int(rng.integers(size_low, size_high + 1))\n            handle, steps = alloc.alloc(size)\n            total_malloc_steps += steps\n            count_mallocs += 1\n            if handle is not None:\n                live_handles.append(handle)\n        else:\n            # Free: choose uniformly one live handle\n            idx = int(rng.integers(0, len(live_handles)))\n            handle = live_handles.pop(idx)\n            steps = alloc.free(handle)\n            total_free_steps += steps\n            count_frees += 1\n\n    avg_malloc = (total_malloc_steps / count_mallocs) if count_mallocs > 0 else 0.0\n    avg_free = (total_free_steps / count_frees) if count_frees > 0 else 0.0\n    free_blocks = len(alloc.free_list)\n    frag = alloc.external_fragmentation()\n    return avg_malloc, avg_free, free_blocks, frag\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: capacity 64, scripted operations\n        (\"scripted\", {\n            \"capacity\": 64,\n            \"ops\": [\n                ('A', 8), ('A', 8), ('A', 8), ('F', 2),\n                ('A', 4), ('A', 4), ('A', 16), ('F', 1),\n                ('F', 3), ('F', 4),\n            ]\n        }),\n        # Test 2: capacity 32, exact fit\n        (\"scripted\", {\n            \"capacity\": 32,\n            \"ops\": [\n                ('A', 32), ('F', 1),\n            ]\n        }),\n        # Test 3: fragmentation shaping\n        (\"scripted\", {\n            \"capacity\": 64,\n            \"ops\": [\n                ('A', 12), ('A', 12), ('A', 12), ('A', 12),\n                ('F', 2), ('F', 4), ('A', 10), ('A', 10),\n                ('F', 1), ('F', 3), ('A', 24),\n            ]\n        }),\n        # Test 4: adverse scan for first-fit\n        (\"scripted\", {\n            \"capacity\": 128,\n            \"ops\": [\n                ('A', 16), ('A', 16), ('A', 16), ('A', 16), ('A', 16), ('A', 16),\n                ('F', 2), ('F', 4), ('F', 6), ('A', 32),\n                ('F', 1), ('F', 3), ('F', 5), ('F', 7),\n            ]\n        }),\n        # Test 5: stochastic workload\n        (\"random\", {\n            \"capacity\": 256,\n            \"n_ops\": 200,\n            \"p_alloc\": 0.6,\n            \"size_low\": 1,\n            \"size_high\": 32,\n            \"seed\": 123456\n        }),\n    ]\n\n    results = []\n    for kind, params in test_cases:\n        if kind == \"scripted\":\n            avg_malloc, avg_free, free_blocks, frag = run_scripted_test(\n                params[\"capacity\"], params[\"ops\"]\n            )\n        elif kind == \"random\":\n            avg_malloc, avg_free, free_blocks, frag = run_random_test(\n                params[\"capacity\"], params[\"n_ops\"], params[\"p_alloc\"],\n                params[\"size_low\"], params[\"size_high\"], params[\"seed\"]\n            )\n        else:\n            raise ValueError(\"Unknown test kind\")\n\n        # Round real numbers to 6 decimals as strings; integers as-is\n        results.append(f\"{avg_malloc:.6f}\")\n        results.append(f\"{avg_free:.6f}\")\n        results.append(str(int(free_blocks)))\n        results.append(f\"{frag:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3239179"}, {"introduction": "Simple sequential-fit allocators can become slow as the number of free blocks grows. This exercise introduces a more sophisticated and efficient approach: the segregated-fit or 'buddy' system [@problem_id:3239041]. You will implement an allocator that maintains separate free lists for different size classes, using the elegant bitwise logic of the buddy system to perform near-instantaneous splitting and coalescing operations.", "problem": "You are to implement a segregated-fit heap allocator with separate free lists for object sizes that are powers of two. The allocator operates on pages of fixed size and uses the splitting and coalescing principles of the buddy system. The allocator must support allocation and deallocation of objects in a simulated heap and maintain free lists segregated by size class. All sizes are measured in bytes, and all reported quantities must be in bytes unless they are explicitly handles.\n\nFundamental base and core definitions:\n- Memory is modeled as a discrete address space segmented into pages of size $2^{12}$ bytes. Each page is identified by an integer page index and has byte offsets in $\\{0, 1, 2, \\dots, 2^{12}-1\\}$.\n- The allocator maintains disjoint free lists for size classes $C = \\{2^4, 2^5, \\dots, 2^{12}\\}$ bytes. Each free list for class $s \\in C$ contains free blocks of exactly $s$ bytes.\n- Requests are rounded up to the nearest power of two at least $2^4$, that is, given a requested size $n$, the allocator computes $r = 2^{\\lceil \\log_2(\\max(n, 2^4)) \\rceil}$ and enforces $r \\le 2^{12}$. A request $n$ with $n \\le 0$ or $n > 2^{12}$ must fail.\n- Allocation uses segregated-fit with splitting: If a free block of size $r$ exists, allocate it. If not, choose the smallest size $S \\in C$ with $S \\ge r$ for which a free block is available; split it repeatedly into halves until producing one block of size $r$. Specifically, splitting a block of size $S$ at offset $o$ produces two buddy blocks at offsets $o$ and $o + S/2$, each of size $S/2$. Reinsert the unused halves into their corresponding free lists.\n- Deallocation uses buddy coalescing: Given a block of size $s$ at offset $o$, its buddy is at offset $b = o \\oplus s$ (bitwise exclusive-or). If the buddy exists and is free in the same page, remove both from their free lists and combine them into a block of size $2s$ at offset $o' = o \\wedge \\neg s$ (bitwise and with the complement of $s$), then repeat upward until no free buddy exists or the page size $2^{12}$ is reached.\n- Handles: The allocator returns a handle $h = p \\cdot 2^{12} + o$ for a block allocated at page index $p$ and offset $o$. This uniquely identifies the allocation within the simulated heap. A failed allocation returns the sentinel $-1$.\n- Operations: Implement functions $\\mathrm{alloc}(n)$ and $\\mathrm{free}(h)$. The function $\\mathrm{alloc}(n)$ returns a handle $h$ or $-1$. The function $\\mathrm{free}(h)$ returns a boolean indicating success (true) or failure (false), where failure includes invalid handles, double free, or non-existent page references.\n\nScientific realism and constraints:\n- The allocator starts with no pages. It must create a new page (of size $2^{12}$ bytes) when necessary to satisfy allocation requests. Each newly created page contributes a single free block of size $2^{12}$ bytes to the largest free list.\n- The allocator must never allocate more than $2^{12}$ bytes in a single request; there is no mechanism for multi-block contiguous allocations.\n- The free list invariants must be preserved: every free block belongs to exactly one free list for its size class, and no block appears in multiple lists.\n\nTest suite:\nFor each test case, apply the operations specified and compute the required outputs. All sizes are in bytes. The following test cases must be implemented:\n\n- Test case $1$ (happy path, rounding to classes):\n  - Operations: $\\mathrm{alloc}(20)$, $\\mathrm{alloc}(30)$, $\\mathrm{alloc}(100)$, $\\mathrm{alloc}(2000)$.\n  - Output: The list of actual allocated class sizes for each request, i.e., the sizes of the blocks that were assigned for each allocation, in bytes. The expected sizes follow from rounding to powers of two no less than $2^4$.\n\n- Test case $2$ (splitting and full coalescing back to a page):\n  - Operations: $\\mathrm{alloc}(1000)$, $\\mathrm{alloc}(1000)$, then $\\mathrm{free}$ of the first handle, then $\\mathrm{free}$ of the second handle.\n  - Output: The integer count of free blocks of size $2^{12}$ left in the allocator. Given correct buddy coalescing, this should result in a single $2^{12}$-byte free block for the page used.\n\n- Test case $3$ (allocation failure beyond maximum class):\n  - Operations: $\\mathrm{alloc}(5000)$.\n  - Output: A boolean indicating whether the allocation failed (true for failure because $5000 > 2^{12}$).\n\n- Test case $4$ (multi-page creation under many small allocations):\n  - Operations: Perform $260$ allocations of $\\mathrm{alloc}(16)$.\n  - Output: The integer number of pages created by the allocator. Since each page of size $2^{12}$ can be split into $2^{12} / 2^4 = 256$ blocks of $16$ bytes, $260$ allocations force the creation of $2$ pages.\n\n- Test case $5$ (double free detection):\n  - Operations: $h \\leftarrow \\mathrm{alloc}(32)$, then $\\mathrm{free}(h)$, then $\\mathrm{free}(h)$ again.\n  - Output: A boolean indicating whether the second $\\mathrm{free}$ failed (true for failure).\n\n- Test case $6$ (invalid handle free detection):\n  - Operations: $\\mathrm{free}(123456)$ on a fresh allocator.\n  - Output: A boolean indicating whether the $\\mathrm{free}$ failed (true for failure).\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to a test case result in order: $[\\text{result}_1, \\text{result}_2, \\dots, \\text{result}_6]$. Entries may be integers, booleans, or lists of integers, as specified above. There must be no extra text before or after the line.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in the principles of memory management algorithms, specifically the buddy system. The problem is well-posed, with all necessary constants, algorithms, and boundary conditions clearly defined. It is objective and provides a set of formalizable and verifiable test cases.\n\nThe task is to implement a segregated-fit heap allocator based on the buddy system. Memory is managed in pages of size $2^{12}$ bytes. Allocation requests are rounded up to the nearest power of two, from a minimum of $2^4$ bytes to a maximum of $2^{12}$ bytes. The core of the allocator relies on two fundamental operations: splitting larger blocks to satisfy smaller requests and coalescing adjacent free \"buddy\" blocks to form larger blocks, thus mitigating external fragmentation.\n\nA class-based design will be employed to encapsulate the state and logic of the allocator.\n\n**1. Data Structures**\n\nThe allocator's state is managed by three primary data structures:\n\n- **Free Lists (`free_lists`)**: The allocator uses a segregated-fit strategy, which requires separate lists of free blocks for each size class. The size classes are powers of two, $C = \\{2^4, 2^5, \\dots, 2^{12}\\}$. A dictionary is a natural choice to implement this, mapping each size $s \\in C$ to a collection of handles for free blocks of that size. To ensure efficient buddy lookups during coalescing, the collection of handles for each size class will be a set, providing average $O(1)$ time complexity for insertion, deletion, and membership testing. A block is identified by its handle, an integer computed as $h = p \\cdot 2^{12} + o$, where $p$ is the page index and $o$ is the byte offset within the page.\n\n- **Allocated Blocks (`allocated_blocks`)**: A separate dictionary is required to track currently allocated blocks. This structure maps an allocated block's handle $h$ to its size $s$. This is crucial for the `free(h)` operation, which needs to know the size of the block being deallocated to find its buddy. This dictionary also serves as the authoritative record for validating handles and detecting attempts to free an already free block (a double free).\n\n- **Page Management (`next_page_idx`)**: The allocator begins with no memory pages. Pages are created on demand. A simple integer counter, `next_page_idx`, tracks the number of pages created, with the next new page having an index of `next_page_idx`. When a new page is created, `next_page_idx` is incremented, and a single free block of size $2^{12}$ is added to the corresponding free list.\n\n**2. Algorithm Design: Allocation `alloc(n)`**\n\nThe allocation process follows a sequence of well-defined steps:\n\n- **Request Validation and Sizing**: An incoming request for $n$ bytes is first validated. Requests for $n \\le 0$ or $n > 2^{12}$ are invalid and fail immediately. For valid requests, the size is rounded up to the nearest power of two, $r$, that is at least $2^4$. This is computed via the formula $r = 2^{\\lceil \\log_2(\\max(n, 2^4)) \\rceil}$. This can be implemented efficiently using `numpy.log2` and `numpy.ceil`.\n\n- **Block Search**: The allocator searches its `free_lists` for an available block. It starts by checking the free list for the exact required size $r$. If this list is non-empty, a block is taken from it. If not, the search proceeds to the next larger size classes ($2r, 4r, \\dots, 2^{12}$) until a non-empty free list is found.\n\n- **Page Provisioning**: If the search fails to find any free block large enough to satisfy the request (i.e., all free lists are empty or only contain blocks smaller than $r$), the allocator must provision a new page. A new page of size $2^{12}$ is created, and its corresponding block handle (at page `next_page_idx`, offset $0$) is added to the free list for size $2^{12}$. The search for a block to split then resumes, now guaranteed to succeed with this new full-page block.\n\n- **Splitting**: Once a block of size $S \\ge r$ is found and removed from its free list, it is split recursively if $S > r$. Splitting a block of size $S$ at offset $o$ yields two buddy blocks of size $S/2$: one at offset $o$ and its buddy at offset $o + S/2$. The buddy block is immediately added to the free list for size $S/2$. The first block (at offset $o$) is retained and the process repeats, halving its size until a block of the required size $r$ is obtained. This block is then allocated.\n\n- **Finalization**: The handle of the final $r$-sized block is recorded in the `allocated_blocks` map along with its size, and the handle is returned to the caller. A failed allocation returns $-1$.\n\n**3. Algorithm Design: Deallocation `free(h)`**\n\nDeallocation reverses the allocation process through coalescing:\n\n- **Handle Validation**: The first and most critical step is to validate the handle $h$. The function checks if $h$ exists as a key in the `allocated_blocks` map. If not, the handle is invalid (it was never allocated, or it has already been freed). In this case, the operation fails and returns `false`.\n\n- **Buddy Identification and Coalescing**: If the handle is valid, its size $s$ is retrieved. The block is removed from the `allocated_blocks` map. The core coalescing loop begins. For a block of size $s$ at offset $o$ within page $p$, its unique buddy of the same size is located at offset $o \\oplus s$ in the same page. The allocator checks if the buddy's handle exists in the free list for size $s$.\n  - If the buddy is free, it is removed from its free list. The two blocks are merged into a single block of size $2s$. The offset of this new parent block is given by $o' = o \\wedge \\neg s$, which effectively clears the bit corresponding to size $s$, yielding the base address of the aligned $2s$-sized block. The coalescing process is then repeated with this new, larger block.\n  - If the buddy is not free (i.e., it is allocated), coalescing stops.\n\n- **Finalization**: The loop terminates when either a buddy is found to be allocated or the block size reaches the page size $2^{12}$. The final resulting block (which may be the original block or a larger, coalesced one) is added to the appropriate free list. The function returns `true` to indicate success. This systematic coalescing is the buddy system's mechanism for combating external fragmentation by actively reconstructing larger free blocks.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass BuddyAllocator:\n    \"\"\"\n    Implements a segregated-fit heap allocator with a buddy system for splitting and coalescing.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initializes the allocator with no pages.\"\"\"\n        self.PAGE_SIZE = 2**12\n        self.MIN_ALLOC_SIZE = 2**4\n        self.MAX_ALLOC_SIZE = self.PAGE_SIZE\n\n        # Size classes are powers of two from MIN_ALLOC_SIZE to MAX_ALLOC_SIZE.\n        self.size_classes = [2**i for i in range(int(np.log2(self.MIN_ALLOC_SIZE)), int(np.log2(self.MAX_ALLOC_SIZE)) + 1)]\n\n        # Free lists: a dictionary mapping size class to a set of handles of free blocks.\n        self.free_lists = {s: set() for s in self.size_classes}\n\n        # Allocated blocks: a dictionary mapping handle to its size.\n        self.allocated_blocks = {}\n\n        # Page management.\n        self.next_page_idx = 0\n\n    def _get_handle(self, page_idx, offset):\n        \"\"\"Computes a handle from a page index and offset.\"\"\"\n        return page_idx * self.PAGE_SIZE + offset\n\n    def _parse_handle(self, handle):\n        \"\"\"Decomposes a handle into its page index and offset.\"\"\"\n        page_idx = handle // self.PAGE_SIZE\n        offset = handle % self.PAGE_SIZE\n        return page_idx, offset\n\n    def _calculate_rounded_size(self, n):\n        \"\"\"Rounds up a request size to the nearest valid power of two.\"\"\"\n        if not (0 < n <= self.MAX_ALLOC_SIZE):\n            return None\n        \n        req_size = max(n, self.MIN_ALLOC_SIZE)\n        \n        # Use numpy for direct implementation of the formula: 2^ceil(log2(size))\n        power = np.ceil(np.log2(req_size))\n        return 2**int(power)\n\n    def alloc(self, n):\n        \"\"\"Allocates a block of memory of size n.\"\"\"\n        rounded_size = self._calculate_rounded_size(n)\n        if rounded_size is None:\n            return -1\n\n        target_size = rounded_size\n        \n        # Find the smallest available block size that fits the request.\n        alloc_size = -1\n        for s in self.size_classes:\n            if s >= target_size and len(self.free_lists[s]) > 0:\n                alloc_size = s\n                break\n        \n        # If no block is available, create a new page.\n        if alloc_size == -1:\n            page_idx = self.next_page_idx\n            self.next_page_idx += 1\n            \n            new_block_handle = self._get_handle(page_idx, 0)\n            self.free_lists[self.MAX_ALLOC_SIZE].add(new_block_handle)\n            alloc_size = self.MAX_ALLOC_SIZE\n        \n        # Get a block from the selected free list.\n        block_handle = self.free_lists[alloc_size].pop()\n        current_page, current_offset = self._parse_handle(block_handle)\n        \n        # Split the block down to the required size.\n        current_size = alloc_size\n        while current_size > target_size:\n            current_size //= 2\n            buddy_offset = current_offset + current_size\n            buddy_handle = self._get_handle(current_page, buddy_offset)\n            self.free_lists[current_size].add(buddy_handle)\n            \n        # Allocate the final block.\n        final_handle = self._get_handle(current_page, current_offset)\n        self.allocated_blocks[final_handle] = target_size\n        return final_handle\n\n    def free(self, handle):\n        \"\"\"Frees a previously allocated block of memory.\"\"\"\n        # 1. Validate handle against the map of allocated blocks.\n        if handle not in self.allocated_blocks:\n            return False\n            \n        page_idx, offset = self._parse_handle(handle)\n        if page_idx >= self.next_page_idx:\n            return False\n\n        # 2. Retrieve size and remove from allocated map.\n        size = self.allocated_blocks.pop(handle)\n        \n        current_page = page_idx\n        current_offset = offset\n        current_size = size\n\n        # 3. Coalesce with buddy if buddy is free.\n        while current_size < self.MAX_ALLOC_SIZE:\n            buddy_offset = current_offset ^ current_size\n            buddy_handle = self._get_handle(current_page, buddy_offset)\n            \n            if buddy_handle in self.free_lists[current_size]:\n                self.free_lists[current_size].remove(buddy_handle)\n                current_offset = current_offset & (~current_size)\n                current_size *= 2\n            else:\n                break\n        \n        # 4. Add the final (possibly coalesced) block to the free list.\n        final_handle = self._get_handle(current_page, current_offset)\n        self.free_lists[current_size].add(final_handle)\n        \n        return True\n\ndef run_test_case_1():\n    allocator = BuddyAllocator()\n    requests = [20, 30, 100, 2000]\n    allocated_sizes = []\n    for req in requests:\n        handle = allocator.alloc(req)\n        if handle != -1:\n            allocated_sizes.append(allocator.allocated_blocks[handle])\n    return allocated_sizes\n\ndef run_test_case_2():\n    allocator = BuddyAllocator()\n    h1 = allocator.alloc(1000)\n    h2 = allocator.alloc(1000)\n    allocator.free(h1)\n    allocator.free(h2)\n    return len(allocator.free_lists[allocator.MAX_ALLOC_SIZE])\n\ndef run_test_case_3():\n    allocator = BuddyAllocator()\n    handle = allocator.alloc(5000)\n    return handle == -1\n\ndef run_test_case_4():\n    allocator = BuddyAllocator()\n    for _ in range(260):\n        allocator.alloc(16)\n    return allocator.next_page_idx\n\ndef run_test_case_5():\n    allocator = BuddyAllocator()\n    h = allocator.alloc(32)\n    allocator.free(h)\n    second_free_success = allocator.free(h)\n    return not second_free_success\n\ndef run_test_case_6():\n    allocator = BuddyAllocator()\n    free_success = allocator.free(123456)\n    return not free_success\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        run_test_case_1,\n        run_test_case_2,\n        run_test_case_3,\n        run_test_case_4,\n        run_test_case_5,\n        run_test_case_6,\n    ]\n\n    results = [test() for test in test_cases]\n\n    # The problem asks for the standard string representation of Python objects.\n    # str([1, 2]) -> '[1, 2]' (with space)\n    # str(True) -> 'True' (capitalized)\n    # The default behavior of map(str,...) is the most faithful interpretation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3239041"}, {"introduction": "After implementing allocators, let's switch gears to a conceptual challenge that tests your strategic thinking. This problem is a thought experiment about the fundamental power of memory allocation primitives [@problem_id:3239183]. Your task is to determine the absolute minimum number of `malloc` and `free` calls needed to transform a completely empty heap into a highly fragmented state, pushing the concepts of allocation and deallocation to their logical extreme.", "problem": "Consider an idealized dynamic memory allocator over a linear heap of size $H = 2^{20}$ bytes (one mebibyte). The allocator provides two operations, $\\mathtt{malloc}(s)$ and $\\mathtt{free}(p)$, with the following semantics.\n\n1. The operation $\\mathtt{malloc}(s)$ returns a pointer to a contiguous block of exactly $s$ bytes that were previously free. The allocator maintains its metadata in a separate side structure not counted against the $H$ bytes, and has an alignment granularity of $a = 1$ byte, so requests for $s = 1$ byte are placed exactly as single-byte blocks. Allocation may split a free block to satisfy a request but cannot create overlapping allocated blocks.\n\n2. The operation $\\mathtt{free}(p)$ releases the entire block previously returned by $\\mathtt{malloc}$ at address $p$. Partial block frees are disallowed. When freed, adjacent free blocks may coalesce, but no allocation occurs during $\\mathtt{free}$.\n\nInitially, the entire heap is free. You seek to reach a final configuration in which the heap is partitioned into alternating $1$-byte allocated blocks and $1$-byte free blocks across the full $H$ bytes, starting with the first byte allocated. In other words, using zero-based indexing of bytes, the allocated set is $\\{0, 2, 4, \\dots\\}$ and the free set is $\\{1, 3, 5, \\dots\\}$ throughout the heap.\n\nUnder these rules and starting condition, what is the minimum total number of calls (counting both $\\mathtt{malloc}$ and $\\mathtt{free}$) required to reach the described alternating configuration? Express your final answer as an exact integer. No rounding is needed, and no units should be included in your final answer.", "solution": "The problem will be validated according to the specified criteria before a solution is attempted.\n\n### Step 1: Extract Givens\n-   Heap size: $H = 2^{20}$ bytes.\n-   Operation 1: $\\mathtt{malloc}(s)$ allocates a contiguous block of $s$ bytes from a free region.\n-   Operation 2: $\\mathtt{free}(p)$ releases the entire block at address $p$.\n-   Allocator metadata is stored separately and does not consume heap space.\n-   Alignment granularity: $a=1$ byte.\n-   Partial block frees are disallowed.\n-   Allocation can split a free block.\n-   Adjacent free blocks may coalesce upon a $\\mathtt{free}$ operation.\n-   Initial state: The entire heap, from address $0$ to $H-1$, is a single free block.\n-   Target state: The heap is partitioned into alternating $1$-byte allocated and $1$-byte free blocks. The set of allocated byte addresses is $\\{0, 2, 4, \\dots, H-2\\}$ and the set of free byte addresses is $\\{1, 3, 5, \\dots, H-1\\}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded within the domain of computer science, specifically data structures and algorithms concerning memory management. It presents an idealized but logically consistent model. The problem is well-posed, with a clearly defined initial state, a clear target state, and a set of allowed operations. The question asks for a minimum, which is a standard optimization problem. The language is objective and precise. The value $H=2^{20}$ is an even number, so the heap can be perfectly partitioned into $H/2$ allocated blocks and $H/2$ free blocks as described. The problem is self-contained and does not violate any logical or scientific principles. It is not trivial and requires a constructive proof of optimality.\n\n### Step 3: Verdict and Action\nThe problem is deemed valid. A reasoned solution will be provided.\n\n### Solution\nThe objective is to reach a specific final memory configuration using the minimum total number of $\\mathtt{malloc}(s)$ and $\\mathtt{free}(p)$ calls. The final configuration consists of $H/2$ allocated blocks of size $1$ byte at all even addresses, and $H/2$ free blocks of size $1$ byte at all odd addresses.\n\nLet $N_{alloc}$ be the number of allocated blocks and $N_{free}$ be the number of free blocks in the target state. Given the alternating pattern of $1$-byte blocks in a heap of size $H$, we have:\n$$N_{alloc} = \\frac{H}{2}$$\n$$N_{free} = \\frac{H}{2}$$\nIn our case, $H = 2^{20}$, so $N_{alloc} = N_{free} = \\frac{2^{20}}{2} = 2^{19}$.\n\nLet's establish a lower bound on the total number of operations.\nThe final state contains $N_{alloc} = H/2 = 2^{19}$ distinct, non-contiguous allocated blocks. Each call to $\\mathtt{malloc}(s)$ returns a pointer to a single contiguous block of memory. Therefore, to create $N_{alloc}$ separate allocated blocks, we must make at least $N_{alloc}$ calls to $\\mathtt{malloc}$. The $\\mathtt{free}$ operation does not create allocated blocks. Let $M$ be the number of $\\mathtt{malloc}$ calls and $F$ be the number of $\\mathtt{free}$ calls.\nThe number of lasting allocated blocks is at most $M$. Thus, we must have $M \\ge N_{alloc} = H/2$.\nThe total number of calls is $M+F$. Therefore, the minimum possible total number of calls is bounded below by $H/2$:\n$$ \\text{Total Calls} = M + F \\ge M \\ge \\frac{H}{2} $$\nNow, we must determine if it is possible to achieve the target configuration using exactly $H/2$ total calls. This would require $F=0$ and $M=H/2$. We need to demonstrate a sequence of $H/2$ $\\mathtt{malloc}$ calls that results in the desired final state.\n\nConsider the following sequence of $H/2$ operations, all of which are $\\mathtt{malloc}(1)$ calls.\nThe initial state of the heap is a single free block of size $H$, which we can denote as $F(0, H)$.\n\n1.  **Call 1:** $\\mathtt{malloc}(1)$. We request that this allocation be satisfied at address $0$. This is possible as address $0$ is part of the free block $F(0, H)$. The operation splits the initial block.\n    -   An allocated block $A(0, 1)$ is created.\n    -   The remainder of the original free block is $F(1, H-1)$.\n    -   The heap state is: $[A(0,1) | F(1, H-1)]$.\n\n2.  **Call 2:** $\\mathtt{malloc}(1)$. We request this allocation at address $2$. Address $2$ is within the free block $F(1, H-1)$. The rule \"Allocation may split a free block\" allows for this. The allocator carves out the block $A(2, 1)$ from the middle of $F(1, H-1)$.\n    -   An allocated block $A(2, 1)$ is created.\n    -   The free block $F(1, H-1)$ is split into two smaller, non-adjacent free blocks: $F(1, 1)$ and $F(3, H-3)$.\n    -   The heap state is: $[A(0,1) | F(1,1) | A(2,1) | F(3, H-3)]$.\n\nThis process can be continued. For the $k$-th call (where $k=1, \\dots, H/2$), we perform a $\\mathtt{malloc}(1)$ satisfied at address $2(k-1)$. Before the $k$-th call, the heap contains a large free block at its tail, of the form $F(2k-3, H-(2k-3))$. The $k$-th allocation request for $A(2k-2, 1)$ is serviced from this block, splitting it into $F(2k-3, 1)$ and $F(2k-1, H-(2k-1))$.\n\nLet's trace the state up to the final call.\nAfter $k = H/2 - 1$ calls, we have allocated blocks at addresses $0, 2, \\dots, H-4$. This has created the required free blocks at addresses $1, 3, \\dots, H-5$. The state of the heap is:\n$[A(0,1) | F(1,1) | \\dots | A(H-4,1) | F(H-3, 3)]$.\nThe last remaining large free block is $F(H-3, 3)$, covering addresses $H-3, H-2, H-1$.\n\n$(H/2)$-th **Call:** $\\mathtt{malloc}(1)$. We request this allocation at address $H-2$. This address is in the free block $F(H-3, 3)$.\n-   An allocated block $A(H-2, 1)$ is created.\n-   The free block $F(H-3, 3)$ is split, leaving two 1-byte free blocks: $F(H-3, 1)$ and $F(H-1, 1)$.\n\nAfter these $H/2$ calls, the heap is configured as follows:\n-   Allocated blocks: $A(0,1), A(2,1), \\dots, A(H-2,1)$. This is the set of $H/2$ allocated blocks at all even addresses.\n-   Free blocks: $F(1,1), F(3,1), \\dots, F(H-1,1)$. This is the set of $H/2$ free blocks at all odd addresses.\n\nThis configuration is exactly the target state. We have successfully reached it using a sequence of $H/2$ `malloc` calls and zero `free` calls. The total number of calls is $H/2$.\n\nSince the total number of calls must be at least $H/2$, and we have found a valid sequence of $H/2$ calls to achieve the result, the minimum number of calls is exactly $H/2$.\n\nThe heap size is given as $H = 2^{20}$. The minimum number of calls is:\n$$ \\frac{H}{2} = \\frac{2^{20}}{2} = 2^{19} $$\nCalculating this value:\n$$ 2^{19} = 524288 $$\nThis is the minimum total number of calls required.", "answer": "$$\\boxed{524288}$$", "id": "3239183"}]}