{"hands_on_practices": [{"introduction": "At the heart of low-level computing lies the direct manipulation of binary data. This first exercise explores the fundamental connection between arithmetic operations and bitwise shifts. By understanding how to perform multiplication and division by powers of two using only bit shifts, you gain insight into how CPUs perform these calculations with incredible efficiency and build a foundation for many optimization techniques. [@problem_id:3260707]", "problem": "You are given the task of implementing integer multiplication and division by powers of two using only the semantics of bit shift operators as defined on signed integers. The goal is to reason from the positional binary numeral system and the two's complement representation to derive and implement correct operations without relying on explicit multiplication, division, or exponentiation operators.\n\nFundamental base to use:\n- Binary positional numeral system: any nonnegative integer $n$ can be expressed as $n = \\sum_{i=0}^{m} b_i \\cdot 2^i$, where each $b_i \\in \\{0,1\\}$ and $m$ is a nonnegative integer. Negative integers in two's complement representation extend the sign bit indefinitely under arithmetic right shift, preserving algebraic structure.\n- Bit shift operator semantics on signed integers: left shift moves every bit position $i$ to position $i+k$ for a nonnegative integer shift amount $k$, while arithmetic right shift moves every bit position $i$ to $i-k$ and replicates the sign bit for negative values.\n\nTask:\n- Implement two functions over signed mathematical integers:\n  1. $f_{\\text{mul}}(n,k)$ that returns the product $n \\cdot 2^k$ using only the left shift operator semantics.\n  2. $f_{\\text{div\\_floor}}(n,k)$ that returns the floor division result $\\left\\lfloor \\dfrac{n}{2^k} \\right\\rfloor$ using only the arithmetic right shift operator semantics.\n- Constraints:\n  - Inputs $n$ and $k$ are mathematical integers with $k \\ge 0$.\n  - The implementations must not use multiplication, division, or exponentiation operators. Use only bit shift operators to realize the required operations.\n  - Operate over unbounded precision signed integers as mathematical objects; do not assume a fixed word size.\n\nTest suite:\n- Use the following parameter pairs $(n,k)$ to validate the correctness and edge behavior:\n  - $(13, 2)$ meaning $n = 13$, $k = 2$.\n  - $(-13, 2)$ meaning $n = -13$, $k = 2$.\n  - $(0, 5)$ meaning $n = 0$, $k = 5$.\n  - $(1, 0)$ meaning $n = 1$, $k = 0$.\n  - $(-1, 1)$ meaning $n = -1$, $k = 1$.\n  - $(123456789, 3)$ meaning $n = 123456789$, $k = 3$.\n  - $(-1073741824, 5)$ meaning $n = -1073741824$, $k = 5$.\n  - $(7, 63)$ meaning $n = 7$, $k = 63$.\n- For each test case, compute two integers: $f_{\\text{mul}}(n,k)$ and $f_{\\text{div\\_floor}}(n,k)$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a two-element list of integers with no whitespace, in the order of the test suite, for example:\n- The exact format is $[[a_1,b_1],[a_2,b_2],\\dots,[a_8,b_8]]$, where $a_i = f_{\\text{mul}}(n_i,k_i)$ and $b_i = f_{\\text{div\\_floor}}(n_i,k_i)$ for the $i$-th test case.", "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of binary arithmetic and two's complement representation, well-posed with clear objectives and constraints, and formulated with objective, unambiguous language. The task is to derive and implement integer multiplication and division by powers of two using only the semantic equivalents of bit shift operations, starting from first principles.\n\nWe will derive the solutions for the two required functions, $f_{\\text{mul}}(n,k)$ and $f_{\\text{div\\_floor}}(n,k)$, based on the provided fundamental principles.\n\n### Derivation of $f_{\\text{mul}}(n,k) = n \\cdot 2^k$\n\nThe problem is to compute the product of an integer $n$ and a power of two, $2^k$, for $k \\ge 0$, using only left bit shift semantics.\n\nFirst, consider a non-negative integer $n$. According to the binary positional numeral system, $n$ can be expressed as a sum of powers of two:\n$$n = \\sum_{i=0}^{m} b_i \\cdot 2^i$$\nwhere $b_i \\in \\{0, 1\\}$ are the binary digits (bits) of $n$ at positions $i$, and $m$ is the highest power of two needed to represent $n$.\n\nMultiplying $n$ by $2^k$ gives:\n$$n \\cdot 2^k = \\left( \\sum_{i=0}^{m} b_i \\cdot 2^i \\right) \\cdot 2^k$$\nBy the distributive property of multiplication over addition and the law of exponents ($a^x \\cdot a^y = a^{x+y}$), we can rewrite this as:\n$$n \\cdot 2^k = \\sum_{i=0}^{m} (b_i \\cdot 2^i \\cdot 2^k) = \\sum_{i=0}^{m} b_i \\cdot 2^{i+k}$$\nThis resulting sum represents a new integer where each original bit $b_i$ that was at position $i$ (contributing a value of $b_i \\cdot 2^i$) is now at position $i+k$ (contributing a value of $b_i \\cdot 2^{i+k}$). This describes precisely the operation of a logical left shift by $k$ positions. The new low-order bits from position $0$ to $k-1$ are filled with zeros.\n\nFor negative integers, we rely on the two's complement representation. In this system, performing a left bit shift on a signed integer (where newly introduced bits on the right are zeros) is arithmetically equivalent to multiplication by $2^k$, provided no significant bits are lost due to overflow. The problem specifies the use of unbounded precision integers, which corresponds to Python's arbitrary-precision integer type. This abstraction ensures that no overflow occurs. Therefore, the left shift operation remains valid for all integers $n$.\n\nThus, the function $f_{\\text{mul}}(n, k)$ can be implemented using a left bit shift operation, which is denoted by `` in many programming languages, including Python.\n$$f_{\\text{mul}}(n,k) \\equiv n \\ll k$$\n\n### Derivation of $f_{\\text{div\\_floor}}(n,k) = \\lfloor \\frac{n}{2^k} \\rfloor$\n\nThe problem is to compute the floor of the division of an integer $n$ by a power of two, $2^k$, for $k \\ge 0$, using only arithmetic right bit shift semantics.\n\nFirst, consider a non-negative integer $n$, represented as $n = \\sum_{i=0}^{m} b_i \\cdot 2^i$.\nDividing $n$ by $2^k$ gives:\n$$\\frac{n}{2^k} = \\frac{1}{2^k} \\sum_{i=0}^{m} b_i \\cdot 2^i = \\sum_{i=0}^{m} b_i \\cdot 2^{i-k}$$\nWe can split this sum at the index $i=k$:\n$$\\frac{n}{2^k} = \\sum_{i=k}^{m} b_i \\cdot 2^{i-k} + \\sum_{i=0}^{k-1} b_i \\cdot 2^{i-k}$$\nThe first term, $\\sum_{i=k}^{m} b_i \\cdot 2^{i-k}$, is an integer. It corresponds to the binary representation of $n$ shifted right by $k$ positions, with bits from positions $0$ to $k-1$ being discarded.\nThe second term, $\\sum_{i=0}^{k-1} b_i \\cdot 2^{i-k}$, is a sum of non-negative terms. Its value is $0 \\le \\sum_{i=0}^{k-1} b_i \\cdot 2^{i-k}  1$. This term represents the fractional part of the division.\n\nThe floor of a number is the greatest integer less than or equal to that number. Since the second term is a non-negative fraction less than $1$, the floor of the entire expression is simply the integer part:\n$$\\left\\lfloor \\frac{n}{2^k} \\right\\rfloor = \\sum_{i=k}^{m} b_i \\cdot 2^{i-k}$$\nThis operation is precisely an arithmetic right shift. For non-negative numbers, an arithmetic right shift is identical to a logical right shift: bits are shifted to the right by $k$ positions, and the $k$ most significant bits are filled with $0$, which is the sign bit for a non-negative number.\n\nNow, consider a negative integer $n$. The floor division $\\lfloor \\frac{n}{d} \\rfloor$ rounds towards negative infinity. For example, $\\lfloor \\frac{-13}{4} \\rfloor = \\lfloor -3.25 \\rfloor = -4$. This is distinct from truncation (rounding towards zero), which would yield $-3$. The problem explicitly requests floor division, and an arithmetic right shift on a two's complement number is defined to produce this exact result. In an arithmetic right shift, the bits are shifted right, and the vacated high-order bits are filled with copies of the original sign bit. For a negative number, the sign bit is $1$, so the new bits are $1$s. This process correctly preserves the sign and rounds the magnitude towards negative infinity.\n\nPython's right shift operator `` on integers implements an arithmetic right shift. This behavior is guaranteed for both positive and negative integers and directly corresponds to floor division by a power of two.\n\nThus, the function $f_{\\text{div\\_floor}}(n, k)$ can be implemented using an arithmetic right bit shift operation.\n$$f_{\\text{div\\_floor}}(n,k) \\equiv n \\gg k$$\n\nThe implementation will apply these two derived equivalences to the provided test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of implementing multiplication and floor division by powers\n    of two using only bit shift operators, based on first principles of binary\n    arithmetic and two's complement representation.\n    \"\"\"\n    \n    # Define the functions based on the derived principles.\n    # f_mul(n, k) computes n * 2**k using the left shift operator.\n    # The derivation showed that n  k is equivalent to n * 2**k for all integers n\n    # and non-negative integers k, within an unbounded integer model.\n    f_mul = lambda n, k: n  k\n\n    # f_div_floor(n, k) computes floor(n / 2**k) using the arithmetic right shift operator.\n    # The derivation showed that n  k (arithmetic right shift) is equivalent to\n    # floor(n / 2**k) for all integers n and non-negative integers k.\n    f_div_floor = lambda n, k: n  k\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (13, 2),\n        (-13, 2),\n        (0, 5),\n        (1, 0),\n        (-1, 1),\n        (123456789, 3),\n        (-1073741824, 5),\n        (7, 63)\n    ]\n\n    results = []\n    for n, k in test_cases:\n        # Calculate the multiplication and division results for the current case.\n        mul_result = f_mul(n, k)\n        div_result = f_div_floor(n, k)\n        \n        # Append the pair of results to the list.\n        results.append([mul_result, div_result])\n\n    # Format the final output string exactly as specified:\n    # A comma-separated list of two-element lists, with no whitespace.\n    # e.g., [[a_1,b_1],[a_2,b_2],...]\n    output_str = f\"[{','.join(f'[{res[0]},{res[1]}]' for res in results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "3260707"}, {"introduction": "Beyond simple arithmetic, bitwise operations possess elegant algebraic properties that can be harnessed to solve problems in unconventional ways. This practice challenges you to perform one of the most common programming tasks—swapping the values of two variables—but with a twist: you cannot use a temporary variable. The solution lies in the unique properties of the exclusive OR (XOR) operator, providing a classic example of bitwise ingenuity. [@problem_id:3260585]", "problem": "You are to write a complete program that defines and uses a function to swap two primitive integers without using any temporary variable, using only bitwise operations. The goal is to justify from first principles why such a swap is possible and correct. The program must implement the function, run it on the provided test suite, and print the aggregated results in the specified format.\n\nDefinitions to be used as the fundamental base in your reasoning and algorithm design: integers are represented in binary as sequences of bits, and bitwise operations act independently on each bit. Bitwise exclusive OR (XOR) will be denoted by $\\oplus$, bitwise AND will be denoted by $\\land$, and bitwise OR will be denoted by $\\lor$. No other assumptions beyond these representations and operations should be required.\n\nConstraints for the swap function:\n- The function must accept two integers $a$ and $b$ and return the swapped values.\n- The function must not allocate or use any additional temporary variables.\n- The function must use only bitwise operations; no arithmetic operations (such as $+$, $-$, $\\times$, $\\div$), no tuple unpacking, and no library or language-specific swap constructs are permitted within the swap function.\n- The function must execute in time $\\mathcal{O}(1)$ and use space $\\mathcal{O}(1)$.\n\nTest suite to be executed by your program:\n- Case $1$: $a = 3$, $b = 5$.\n- Case $2$: $a = 0$, $b = 0$.\n- Case $3$: $a = 0$, $b = 42$.\n- Case $4$: $a = -7$, $b = 13$.\n- Case $5$: $a = 2^{63} - 1$, $b = -2^{63}$.\n- Case $6$: $a = 123456789$, $b = 987654321$.\n- Case $7$: $a = 1$, $b = 1$.\n\nYour program must apply the swap function to each test case and produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of the list must itself be a two-integer list $[a',b']$ representing the swapped values for the corresponding test case, where $a'$ is the new value of $a$ (formerly $b$) and $b'$ is the new value of $b$ (formerly $a$). For example, the output format should look like $[[b_1,a_1],[b_2,a_2],\\dots]$ with no spaces.", "solution": "The problem is valid. It presents a well-defined task in computational logic which is grounded in the fundamental algebraic properties of bitwise operations. All constraints are consistent and the objective is clear.\n\nThe task is to swap the values of two integer variables, let us call them $a$ and $b$, without using an auxiliary temporary variable. The constraints limit the permissible operations to only bitwise operations. The solution hinges on the properties of the bitwise exclusive OR (XOR) operation, denoted by the symbol $\\oplus$.\n\nThe justification from first principles relies on the algebraic structure that the set of integers forms under the bitwise XOR operation. Since bitwise operations act independently on each bit in the binary representation of the integers, we can analyze the properties at the single-bit level. The set $\\{0, 1\\}$ with the XOR operation forms an abelian group. The key properties are:\n\n1.  **Commutativity**: $x \\oplus y = y \\oplus x$. The order of operands does not matter.\n2.  **Associativity**: $(x \\oplus y) \\oplus z = x \\oplus (y \\oplus z)$. Grouping of operations does not matter.\n3.  **Identity Element**: There exists an identity element, $0$, such that $x \\oplus 0 = x$.\n4.  **Self-Inverse**: Every element is its own inverse, meaning $x \\oplus x = 0$.\n\nThese properties, established for single bits, extend to integers of any bit length because the operations are applied bit-by-bit.\n\nLet the initial values of the variables be $a_0$ and $b_0$. The swap is achieved through a sequence of three assignments using the XOR operation.\n\n**Step 1:** The value of $a$ is updated by XORing it with $b$.\n$$a \\leftarrow a \\oplus b$$\nAfter this step, the variable $a$ holds the value $a_1 = a_0 \\oplus b_0$. The variable $b$ still holds its original value, $b_0$. The state of the variables is now $(a_1, b_0)$.\n\n**Step 2:** The value of $b$ is updated by XORing it with the new value of $a$.\n$$b \\leftarrow a \\oplus b$$\nSubstituting the current values of the variables ($a=a_1$, $b=b_0$), we get:\n$$b \\leftarrow a_1 \\oplus b_0$$\nNow, substitute the expression for $a_1$ from Step 1:\n$$b \\leftarrow (a_0 \\oplus b_0) \\oplus b_0$$\nUsing the associativity property, we can regroup the terms:\n$$b \\leftarrow a_0 \\oplus (b_0 \\oplus b_0)$$\nUsing the self-inverse property ($b_0 \\oplus b_0 = 0$):\n$$b \\leftarrow a_0 \\oplus 0$$\nFinally, using the identity property ($a_0 \\oplus 0 = a_0$):\n$$b \\leftarrow a_0$$\nAfter this step, the variable $b$ correctly holds the original value of $a$, which is $a_0$. The variable $a$ still holds the value $a_1 = a_0 \\oplus b_0$. The state is now $(a_1, a_0)$.\n\n**Step 3:** The value of $a$ is updated one last time by XORing it with the new value of $b$.\n$$a \\leftarrow a \\oplus b$$\nSubstituting the current values ($a=a_1$, $b=a_0$):\n$$a \\leftarrow a_1 \\oplus a_0$$\nNow, substitute the expression for $a_1$ from Step 1:\n$$a \\leftarrow (a_0 \\oplus b_0) \\oplus a_0$$\nUsing the commutativity property to reorder the terms:\n$$a \\leftarrow (b_0 \\oplus a_0) \\oplus a_0$$\nUsing the associativity property to regroup:\n$$a \\leftarrow b_0 \\oplus (a_0 \\oplus a_0)$$\nUsing the self-inverse property ($a_0 \\oplus a_0 = 0$):\n$$a \\leftarrow b_0 \\oplus 0$$\nFinally, using the identity property ($b_0 \\oplus 0 = b_0$):\n$$a \\leftarrow b_0$$\nAfter this final step, the variable $a$ now holds the original value of $b$, which is $b_0$. The variable $b$ continues to hold $a_0$.\n\nThe final state of the variables is $(b_0, a_0)$. The values have been successfully swapped. This algorithm adheres to all stated constraints: it uses no temporary variables, relies exclusively on bitwise operations, and consists of a fixed number of operations, thus having a time complexity of $\\mathcal{O}(1)$ and a space complexity of $\\mathcal{O}(1)$.\n\nThe implementation will define a function that takes two integers and applies this three-step XOR sequence, returning the new values. This function will then be executed for each case in the provided test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of swapping integers using bitwise XOR and\n    prints the results for a given test suite.\n    \"\"\"\n\n    def xor_swap(a, b):\n        \"\"\"\n        Swaps two integers using only bitwise XOR operations.\n\n        This function implements the classic XOR swap algorithm, which swaps the\n        values of two variables without using a temporary variable. The logic\n        relies on the algebraic properties of the XOR operation.\n\n        Args:\n            a: The first integer.\n            b: The second integer.\n\n        Returns:\n            A tuple (a, b) with the swapped values.\n        \"\"\"\n        # Let initial values be a_0 and b_0.\n        # Step 1: a becomes a_0 ^ b_0. b is still b_0.\n        a = a ^ b\n        # Step 2: b becomes (a_0 ^ b_0) ^ b_0 = a_0 ^ (b_0 ^ b_0) = a_0 ^ 0 = a_0.\n        # So b now holds the original value of a.\n        b = a ^ b\n        # Step 3: a becomes (a_0 ^ b_0) ^ a_0 = (a_0 ^ a_0) ^ b_0 = 0 ^ b_0 = b_0.\n        # So a now holds the original value of b.\n        a = a ^ b\n        return a, b\n\n    # Define the test cases from the problem statement.\n    # Python integers have arbitrary precision, which correctly models\n    # the behavior of two's complement arithmetic for bitwise operations\n    # on fixed-width integers, including the large integer case.\n    test_cases = [\n        (3, 5),                       # Case 1\n        (0, 0),                       # Case 2\n        (0, 42),                      # Case 3\n        (-7, 13),                     # Case 4\n        (2**63 - 1, -2**63),          # Case 5\n        (123456789, 987654321),       # Case 6\n        (1, 1),                       # Case 7\n    ]\n\n    results = []\n    for a_val, b_val in test_cases:\n        swapped_a, swapped_b = xor_swap(a_val, b_val)\n        results.append((swapped_a, swapped_b))\n\n    # Format the output exactly as specified: [[b1,a1],[b2,a2],...]\n    # with no spaces.\n    result_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3260585"}, {"introduction": "Writing robust code requires anticipating the limitations of primitive data types, especially the risk of integer overflow in fixed-width arithmetic. This hands-on practice tackles a seemingly simple task—calculating the average of two integers—that is fraught with this hidden danger. You will derive and implement an overflow-safe method using bitwise operations, a crucial skill for developing reliable and correct algorithms in systems programming and competitive coding. [@problem_id:3260606]", "problem": "You are given two signed integers $a$ and $b$ drawn from a fixed-width two's-complement representation used by modern Central Processing Units (CPU). The goal is to compute the arithmetic mean, defined as the real number $(a+b)/2$, and return its integer value rounded down to the nearest integer (that is, the mathematical floor). The computation must be performed in a way that does not risk integer overflow in any intermediate step under fixed-width arithmetic.\n\nDesign and implement a program that:\n- Computes the integer value $\\left\\lfloor (a+b)/2 \\right\\rfloor$ without using any operation that can overflow when applied to valid inputs $a$ and $b$.\n- Treats $a$ and $b$ as signed integers consistent with two's-complement semantics and an arithmetic right shift.\n- Does not rely on arbitrary-precision arithmetic; the approach must be valid in a typical fixed-width environment where $a+b$ may overflow even though the final mean is within range.\n\nYour implementation must be logically derived from core definitions of two's-complement arithmetic and bitwise operations. Do not assume any special properties beyond those definitions.\n\nUse the following test suite of input pairs, each specified as $(a,b)$, and produce their results in the specified output format:\n- $(7, 9)$\n- $(2^{31}-1, 2^{31}-1)$\n- $(-2^{31}, -2^{31})$\n- $(2^{31}-1, -2^{31})$\n- $(-3, 2)$\n- $(-4, 2)$\n- $(0, -1)$\n- $(2^{63}-1, -2^{63})$\n- $(2^{31}-2, -2^{31}+1)$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,\\dots,r_9]$), where each $r_i$ is the integer result $\\left\\lfloor (a_i+b_i)/2 \\right\\rfloor$ corresponding to the $i$-th test case.", "solution": "The user-provided problem has been analyzed and is deemed **valid**. It is scientifically grounded in the principles of computer arithmetic, well-posed with clear constraints, and objectively stated.\n\n### Problem Statement Analysis\n\nThe objective is to compute the floor of the arithmetic mean of two signed integers, $\\lfloor (a+b)/2 \\rfloor$, under the constraint that no intermediate operation may cause an integer overflow. The integers $a$ and $b$ are represented using a fixed-width two's-complement system, which is standard in modern CPUs.\n\nA naive computation, `(a+b)/2`, is impermissible because the intermediate sum $a+b$ can exceed the maximum (or minimum) value representable by the fixed-width integer type, leading to an overflow. For example, in a $32$-bit signed integer system, if $a = 2^{31}-1$ and $b = 2^{31}-1$ (the maximum representable value), their sum $a+b = 2^{32}-2$ would cause an overflow. However, the true mean, $\\lfloor (2^{31}-1 + 2^{31}-1)/2 \\rfloor = 2^{31}-1$, is perfectly representable. The task, therefore, requires deriving an equivalent mathematical formulation that is robust against such overflows.\n\n### Derivation from First Principles\n\nOur goal is to compute $m = \\lfloor \\frac{a+b}{2} \\rfloor$. We will derive a safe method starting from the fundamental definition of integer division.\n\nAccording to the division algorithm, any integer $x$ can be expressed in terms of division by $2$ as:\n$$x = 2 \\cdot \\left\\lfloor \\frac{x}{2} \\right\\rfloor + (x \\pmod 2)$$\nwhere $x \\pmod 2$ is the remainder, which is $0$ if $x$ is even and $1$ if $x$ is odd.\n\nLet us apply this decomposition to both integers $a$ and $b$:\n$$a = 2 \\cdot \\left\\lfloor \\frac{a}{2} \\right\\rfloor + (a \\pmod 2)$$\n$$b = 2 \\cdot \\left\\lfloor \\frac{b}{2} \\right\\rfloor + (b \\pmod 2)$$\n\nSubstituting these expressions into the sum $a+b$ yields:\n$$a+b = \\left(2 \\cdot \\left\\lfloor \\frac{a}{2} \\right\\rfloor + (a \\pmod 2)\\right) + \\left(2 \\cdot \\left\\lfloor \\frac{b}{2} \\right\\rfloor + (b \\pmod 2)\\right)$$\n\nBy regrouping the terms, we get:\n$$a+b = 2 \\cdot \\left(\\left\\lfloor \\frac{a}{2} \\right\\rfloor + \\left\\lfloor \\frac{b}{2} \\right\\rfloor\\right) + \\left((a \\pmod 2) + (b \\pmod 2)\\right)$$\n\nNow, we can compute the mean by dividing by $2$:\n$$\\frac{a+b}{2} = \\left(\\left\\lfloor \\frac{a}{2} \\right\\rfloor + \\left\\lfloor \\frac{b}{2} \\right\\rfloor\\right) + \\frac{(a \\pmod 2) + (b \\pmod 2)}{2}$$\n\nTo find the desired integer value, we apply the floor function to the entire expression:\n$$m = \\left\\lfloor \\left(\\left\\lfloor \\frac{a}{2} \\right\\rfloor + \\left\\lfloor \\frac{b}{2} \\right\\rfloor\\right) + \\frac{(a \\pmod 2) + (b \\pmod 2)}{2} \\right\\rfloor$$\n\nSince $\\lfloor \\frac{a}{2} \\rfloor$ and $\\lfloor \\frac{b}{2} \\rfloor$ are integers, their sum is an integer. A property of the floor function, $\\lfloor k+z \\rfloor = k + \\lfloor z \\rfloor$ for any integer $k$, allows us to factor the integer part out of the main floor operation:\n$$m = \\left\\lfloor \\frac{a}{2} \\right\\rfloor + \\left\\lfloor \\frac{b}{2} \\right\\rfloor + \\left\\lfloor \\frac{(a \\pmod 2) + (b \\pmod 2)}{2} \\right\\rfloor$$\n\n### Mapping to Bitwise Operations\n\nThis mathematical formula must now be translated into operations that are safe in a fixed-width, two's-complement environment. The problem statement specifies that an arithmetic right shift is to be used.\n- The operation $\\lfloor x/2 \\rfloor$ for any signed integer $x$ in a two's-complement system is correctly and efficiently implemented by a single **arithmetic right shift**, denoted as `x  1`. This operation preserves the sign bit, correctly handling both positive and negative numbers.\n- The remainder operation $x \\pmod 2$ can be implemented using a **bitwise AND** with $1$. The expression `x  1` yields $1$ if the least significant bit of $x$ is $1$ (i.e., $x$ is odd) and $0$ otherwise. This holds for both positive and negative numbers in two's-complement.\n\nSubstituting these bitwise operations into our derived formula gives the final computational algorithm:\n$$m = (a \\gg 1) + (b \\gg 1) + (((a \\land 1) + (b \\land 1)) \\gg 1)$$\nwhere $\\gg$ represents the arithmetic right shift and $\\land$ represents the bitwise AND.\n\n### Overflow Safety Analysis\n\nWe must confirm that no intermediate calculation in this final expression can overflow.\n1.  **Shift Operations**: `a  1` and `b  1`. An arithmetic right shift reduces the magnitude of the number (or keeps it the same for $-1$), so it can never overflow.\n2.  **Remainder Calculation**: `a  1` and `b  1`. These operations result in either $0$ or $1$.\n3.  **Sum of Remainders**: `(a  1) + (b  1)`. The maximum value of this sum is $1+1=2$, which will not overflow any standard integer type. The subsequent shift ` 1` is also safe.\n4.  **Final Additions**: The expression sums three terms: `(a  1)`, `(b  1)`, and a value that is either $0$ or $1$. The arithmetic mean of two numbers always lies between them. Therefore, the final result $\\lfloor(a+b)/2\\rfloor$ must be representable within the same fixed-width integer type that holds $a$ and $b$. Our formula is mathematically equivalent to this result. The main sum, `(a  1) + (b  1)`, is numerically very close to the final mean. It cannot overflow because that would imply the final mean itself is out of bounds, which is a contradiction.\n\nTherefore, this method is demonstrably safe from integer overflow for all valid inputs $a$ and $b$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the integer mean of pairs of numbers without intermediate overflow,\n    simulating fixed-width two's complement arithmetic.\n    \"\"\"\n    \n    # Define constants for clarity in the test cases.\n    INT32_MAX = 2**31 - 1\n    INT32_MIN = -2**31\n    INT64_MAX = 2**63 - 1\n    INT64_MIN = -2**63\n\n    # The test suite provided in the problem statement.\n    test_cases = [\n        (7, 9),\n        (INT32_MAX, INT32_MAX),\n        (INT32_MIN, INT32_MIN),\n        (INT32_MAX, INT32_MIN),\n        (-3, 2),\n        (-4, 2),\n        (0, -1),\n        (INT64_MAX, INT64_MIN),\n        (INT32_MAX - 1, INT32_MIN + 1), # Corresponds to (2**31-2, -2**31+1)\n    ]\n\n    results = []\n    for a_val, b_val in test_cases:\n        # To accurately model fixed-width, two's-complement arithmetic as\n        # specified in the problem, we use numpy.int64. This prevents Python's\n        # arbitrary-precision integers from hiding the overflow problem and\n        # ensures that bitwise operations behave as they would on a CPU.\n        a = np.int64(a_val)\n        b = np.int64(b_val)\n\n        # The core logic is derived from the principle of integer division.\n        # The mean floor( (a+b)/2 ) can be expressed as:\n        # floor(a/2) + floor(b/2) + floor( ( (a%2) + (b%2) ) / 2 )\n        #\n        # This is safely implemented using bitwise operations:\n        # - floor(x/2) is equivalent to an arithmetic right shift `x  1`.\n        # - x%2 is equivalent to a bitwise AND with 1, `x  1`.\n        #\n        # The computation avoids overflow because the initial divisions (shifts)\n        # reduce the magnitude of the operands before they are added.\n        \n        # Calculate floor(a/2) and floor(b/2)\n        a_div_2 = a  1\n        b_div_2 = b  1\n\n        # Calculate the sum of the remainders and its floored division by 2\n        remainder_term = ((a  1) + (b  1))  1\n        \n        # The final result is the sum of the parts.\n        result = a_div_2 + b_div_2 + remainder_term\n        \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3260606"}]}