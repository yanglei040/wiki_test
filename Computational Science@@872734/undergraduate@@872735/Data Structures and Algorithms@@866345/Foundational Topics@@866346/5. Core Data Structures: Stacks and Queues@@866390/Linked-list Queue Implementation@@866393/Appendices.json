{"hands_on_practices": [{"introduction": "Beyond the standard operations, a true test of understanding a data structure lies in extending its functionality. This exercise challenges you to implement a `find_and_remove` method for a linked-list queue. Successfully completing this task requires a firm grasp of pointer manipulation in a singly linked list, forcing you to carefully handle critical edge cases such as removing the head, the tail, or the only element in the queue [@problem_id:3246760].", "problem": "You are to implement a first-in-first-out queue using a singly linked list with explicit head and tail pointers. The queue must support three operations defined in pure logical terms: enqueue to append an element, dequeue to remove and return the element at the front, and find_and_remove to remove the first node whose stored value equals a given query value. The foundation you must start from is the core definition of a queue as an abstract data type together with the standard properties of a singly linked list:\n- A queue stores elements such that the element removed by dequeue is always the one that has been in the queue the longest, consistent with the ordering-by-arrival invariant of first-in-first-out.\n- A singly linked list consists of nodes, each node containing a value and a pointer to the next node, with the head pointer referencing the first node and the tail pointer referencing the last node or being null if the list is empty.\n- The canonical enqueue at tail and dequeue at head can be implemented in time complexity $O(1)$ if head and tail pointers are maintained consistently.\n\nYour task:\n- Implement a queue class using a singly linked list, maintaining head and tail pointers. Enqueue must insert at the tail in $O(1)$ time, dequeue must remove from the head in $O(1)$ time and return a distinguished null value if the queue is empty, and find_and_remove must remove the first (i.e., earliest enqueued among equals) occurrence of a given integer if present, scanning from head to tail. The operation find_and_remove must return a boolean indicating whether removal occurred.\n- You must ensure that after every operation, the data structure maintains the invariants that the head points to the first node (or is null if the queue is empty), the tail points to the last node (or is null if empty), and a null tail implies a null head and vice versa. In particular, after removing the head or tail node by find_and_remove, the corresponding pointer must be updated correctly, and the structure must remain a valid singly linked list.\n\nSemantics and constraints:\n- Values stored in the queue are integers. Equality is standard integer equality. The queue must remove only the first matching node for find_and_remove, consistent with the ordering property of a queue. If no matching node exists, find_and_remove must return false and perform no structural change.\n- The distinguished null return of dequeue must be a value that is not an integer in the queue; the natural choice in a language with references is a null reference. You must still ensure the internal structure remains valid after a dequeue of an empty queue.\n\nTest suite:\nYou must implement and run the following fixed test cases exactly, without reading from input. For each test case, apply the listed operations in order. Each operation is one of:\n- `enqueue x`\n- `dequeue`\n- `find_and_remove x`\n\nFor each test case, your program must produce a single result which is a flat list of integers formed as the concatenation of two parts:\n- The final queue contents from head to tail encoded as a list of integers.\n- A separator value `-1` followed by the sequence of binary indicators for the outcomes of each `find_and_remove` in this test case, where `1` means success and `0` means failure.\nThe integer `-1` will not be enqueued in any test case; it is reserved as a separator in the output encoding.\n\nThe five test cases are:\n- Test case $1$ (happy path, middle deletion, non-existent deletion, and multiple dequeues):\n  - enqueue $3$, enqueue $1$, enqueue $4$, enqueue $1$, enqueue $5$, enqueue $9$, `find_and_remove 4`, `find_and_remove 2`, dequeue, dequeue.\n- Test case $2$ (head deletion, tail deletion, and dequeue on empty queue):\n  - enqueue $10$, enqueue $20$, `find_and_remove 10`, `find_and_remove 20`, dequeue.\n- Test case $3$ (tail deletion in a non-trivial queue and further enqueue):\n  - enqueue $7$, enqueue $8$, enqueue $9$, `find_and_remove 9`, enqueue $10$.\n- Test case $4$ (repeated values, removing first occurrence repeatedly until empty, then failure):\n  - enqueue $1$, enqueue $1$, enqueue $1$, `find_and_remove 1`, `find_and_remove 1`, `find_and_remove 1`, `find_and_remove 1`.\n- Test case $5$ (single-element deletion by find_and_remove and later failed deletion):\n  - enqueue $42$, `find_and_remove 42`, enqueue $5$, dequeue, `find_and_remove 5`.\n\nFinal output format:\n- Your program should produce a single line of output containing the five per-test-case results as a comma-separated list enclosed in square brackets, with each per-test-case result itself formatted as a bracketed, comma-separated list of integers without spaces. For example, an output with $3$ test cases would look like `[ [...], [...], [...] ]`, but with no spaces anywhere.\n- Concretely, for this assignment, your program must print a single line of the exact form `[$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]` where each `$r_i$` is the no-space list of integers encoding the result for test case $i$ as described above.\n\nThere are no physical units or angle units in this problem. All answers are pure integers and booleans encoded as integers.\n\nYour program must be self-contained and must not read any input or write any output other than the single specified line.", "solution": "The problem statement has been critically validated and is deemed valid. It presents a well-posed, scientifically grounded problem in the domain of data structures and algorithms. The requirements for implementing a queue with a singly linked list, including the specific operations `enqueue`, `dequeue`, and `find_and_remove`, are clear, consistent, and complete. The test cases and output format are specified with sufficient precision to allow for a unique and verifiable solution.\n\nThe implementation will be based on the fundamental principles of a singly linked list and a first-in-first-out (FIFO) queue. A singly linked list is a linear collection of data elements, called nodes, where each node points to the next node in the sequence. To implement a queue efficiently, we maintain two pointers: a `head` pointer to the first node and a `tail` pointer to the last node.\n\nThe core data structures are a `Node` and the `Queue` itself.\n- A `Node` contains two fields: a `value` (an integer, per the problem) and a `next` pointer, which references the subsequent node or is `null` if it is the last node.\n- The `Queue` class encapsulates the list and maintains three pieces of state: the `head` pointer, the `tail` pointer, and implicitly, the number of elements. The invariant that `head` is `null` if and only if `tail` is `null` must be strictly preserved.\n\nThe three required operations are implemented as follows:\n\n1.  **Enqueue Operation**: The `enqueue(x)` operation adds an element with value `x` to the rear of the queue. This is achieved in constant time, $O(1)$, by manipulating the `tail` pointer.\n    - A new `Node` is created with the value `x`.\n    - If the queue is empty (i.e., `head` is `null`), both `head` and `tail` are set to point to this new node.\n    - If the queue is not empty, the `next` pointer of the current `tail` node is updated to point to the new node, and then the `tail` pointer itself is updated to this new node. This correctly appends the element to the end of the list.\n\n2.  **Dequeue Operation**: The `dequeue()` operation removes and returns the element at the front of the queue. This is achieved in constant time, $O(1)$, by manipulating the `head` pointer.\n    - If the queue is empty (`head` is `null`), a distinguished `null` value is returned, and the structure remains unchanged, as required.\n    - If the queue is not empty, the value of the `head` node is stored for return.\n    - The `head` pointer is advanced to point to the next node in the list (`head = head.next`).\n    - A critical step is to check if the queue has become empty after the removal. If the new `head` is `null`, it implies the last element was just removed, and therefore the `tail` pointer must also be set to `null` to maintain the queue's structural integrity.\n\n3.  **Find and Remove Operation**: The `find_and_remove(x)` operation searches for the first node containing the value `x` and removes it from the queue. This operation requires a traversal and its time complexity is $O(n)$, where $n$ is the number of elements in the queue. It must return `True` on successful removal and `False` otherwise, and correctly update pointers for all cases.\n    - **Case 1: Empty Queue.** If `head` is `null`, the value cannot be found, so the function immediately returns `False`.\n    - **Case 2: The Head Node Matches.** If `head.value` equals `x`, the problem reduces to removing the head element. This can be accomplished simply by calling the existing `dequeue()` method, which correctly handles all pointer updates. The function then returns `True`.\n    - **Case 3: A Non-Head Node Matches.** The list must be traversed. We use two pointers, `previous` and `current`, starting with `previous = head` and `current = head.next`. The loop proceeds as long as `current` is not `null`.\n        - If `current.value` equals `x`, we have found the node to remove. The `next` pointer of the `previous` node is set to bypass the `current` node (`previous.next = current.next`).\n        - A special check is required here: if the node being removed was the `tail` (`current == tail`), then the `tail` pointer must be updated to point to `previous`.\n        - After successfully removing the node, the function returns `True`.\n    - If the traversal completes without finding a matching value, the function returns `False`.\n\nThis design rigorously adheres to the problem specification, ensuring that all invariants are maintained across all operations and that edge cases such as empty queues, single-element queues, and removal of head or tail elements are handled correctly.\n\nThe provided test suite will be executed against this implementation to verify its correctness and produce the specified output format. Each test case will be run on a fresh `Queue` instance. The final result for each test case is constructed by concatenating the list of values remaining in the queue (from head to tail), a separator value of `-1`, and the sequence of boolean outcomes (`1` for `True`, `0` for `False`) from the `find_and_remove` calls.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"A node in a singly linked list.\"\"\"\n    def __init__(self, value, next_node=None):\n        self.value = value\n        self.next = next_node\n\nclass Queue:\n    \"\"\"A FIFO queue implemented using a singly linked list.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes an empty queue.\"\"\"\n        self.head = None\n        self.tail = None\n\n    def enqueue(self, value):\n        \"\"\"Adds an element to the tail of the queue in O(1) time.\"\"\"\n        new_node = Node(value)\n        if self.head is None:\n            self.head = new_node\n            self.tail = new_node\n        else:\n            self.tail.next = new_node\n            self.tail = new_node\n\n    def dequeue(self):\n        \"\"\"Removes and returns the element from the head of the queue in O(1) time.\"\"\"\n        if self.head is None:\n            return None  # Distinguished null value for an empty queue\n        \n        value = self.head.value\n        self.head = self.head.next\n        \n        if self.head is None:\n            self.tail = None  # The queue is now empty\n        \n        return value\n\n    def find_and_remove(self, value):\n        \"\"\"Finds and removes the first occurrence of a value from the queue.\"\"\"\n        if self.head is None:\n            return False\n\n        # Case 1: The head node needs to be removed.\n        if self.head.value == value:\n            self.dequeue()\n            return True\n\n        # Case 2: A non-head node needs to be removed.\n        # We need a previous pointer to re-link the list.\n        prev = self.head\n        current = self.head.next\n        while current is not None:\n            if current.value == value:\n                prev.next = current.next\n                # If the removed node was the tail, update the tail pointer.\n                if current == self.tail:\n                    self.tail = prev\n                return True\n            prev = current\n            current = current.next\n\n        # Case 3: Value not found.\n        return False\n\n    def get_contents(self):\n        \"\"\"Returns the contents of the queue as a list of integers.\"\"\"\n        items = []\n        current = self.head\n        while current is not None:\n            items.append(current.value)\n            current = current.next\n        return items\n\ndef solve():\n    \"\"\"\n    Runs the entire test suite and prints the final result.\n    \"\"\"\n    test_cases = [\n        [\"enqueue 3\", \"enqueue 1\", \"enqueue 4\", \"enqueue 1\", \"enqueue 5\", \"enqueue 9\", \"find_and_remove 4\", \"find_and_remove 2\", \"dequeue\", \"dequeue\"],\n        [\"enqueue 10\", \"enqueue 20\", \"find_and_remove 10\", \"find_and_remove 20\", \"dequeue\"],\n        [\"enqueue 7\", \"enqueue 8\", \"enqueue 9\", \"find_and_remove 9\", \"enqueue 10\"],\n        [\"enqueue 1\", \"enqueue 1\", \"enqueue 1\", \"find_and_remove 1\", \"find_and_remove 1\", \"find_and_remove 1\", \"find_and_remove 1\"],\n        [\"enqueue 42\", \"find_and_remove 42\", \"enqueue 5\", \"dequeue\", \"find_and_remove 5\"]\n    ]\n\n    all_results = []\n\n    for operations in test_cases:\n        q = Queue()\n        find_remove_outcomes = []\n        for op_str in operations:\n            parts = op_str.split()\n            command = parts[0]\n            \n            if command == \"enqueue\":\n                value = int(parts[1])\n                q.enqueue(value)\n            elif command == \"dequeue\":\n                q.dequeue()\n            elif command == \"find_and_remove\":\n                value = int(parts[1])\n                success = q.find_and_remove(value)\n                find_remove_outcomes.append(1 if success else 0)\n\n        final_contents = q.get_contents()\n        result_list = final_contents + [-1] + find_remove_outcomes\n        all_results.append(result_list)\n    \n    # Format the final output string exactly as specified, with no spaces.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3246760"}, {"introduction": "Data structures are most powerful when applied as building blocks within larger algorithms. This practice moves beyond simple implementation to use your linked-list queue to model a complex, real-world scenario: information propagation in a hierarchical organization. You will simulate how requests and directives flow through a tree structure, using queues to manage the processing order and applying a round-robin merging strategy, which is a common pattern in network routers and operating systems [@problem_id:3246732].", "problem": "You are tasked with implementing a First-In First-Out (FIFO) queue using a singly linked list and using it to model request propagation in a hierarchical organization. The hierarchy is a rooted tree where each node represents a position in the chain of command. Your program must simulate two directions of propagation: moving requests upward from leaves to the root, and moving directives downward from the root to the leaves. The solution must rely entirely on the fundamental definitions of linked lists and the invariants of a FIFO queue, and must derive correctness from those bases without shortcut formulas.\n\nFundamental bases:\n- A queue is First-In First-Out (FIFO), meaning elements are removed in the same order they are inserted. A linked-list queue maintains a head pointer and a tail pointer such that enqueueing to the tail and dequeueing from the head both take $O(1)$ time regardless of queue length.\n- A singly linked list consists of nodes, each holding a value and a pointer to the next node. In a linked-list queue, enqueueing appends a new node after the current tail and updates the tail pointer; dequeueing removes the head node and advances the head pointer.\n\nHierarchy model:\n- The organization is modeled as a rooted tree $T$ with nodes labeled by non-negative integers. The root has index $0$. For any node $u$, its children are given by a list of integer indices. Children are processed in increasing index order.\n- Upward propagation: Each leaf node holds an initial FIFO queue of requests (integers). At any internal node $u$, you merge requests from its child queues into a new FIFO queue for $u$ using round-robin across children in increasing index order, taking at most one element from the front of each non-empty child queue in each pass, preserving FIFO order within each child. This merged queue is then propagated upward to the parent. The root's merged queue is dequeued entirely to produce the final processing sequence at the root.\n- Downward propagation: The root holds a FIFO queue of directives (integers). Each internal node $u$ forwards directives from its inbound FIFO queue to its children using round-robin over children in increasing index order: each time $u$ dequeues one directive, it enqueues it to the inbound FIFO queue of the next child in the round-robin order and advances its child pointer. When a directive reaches a leaf, it is considered delivered at that leaf in the moment it is dequeued at the leaf. The sequence of leaf indices at which directives arrive constitutes the downward result.\n\nYour implementation requirements:\n- Implement a singly linked-list queue with operations enqueue, dequeue, peek, and is\\_empty. All operations must maintain the queue invariants and provide $O(1)$ time for enqueue and dequeue.\n- Use this queue implementation to simulate both upward and downward propagation as described. Do not use array-based queue shortcuts for core queue operations.\n\nTest suite:\nProvide results for the following three test cases.\n\nTest case $1$ (upward propagation, general case):\n- Tree adjacency (children lists): node $0$ has children $[1,2]$, node $1$ has children $[3,4]$, node $2$ has children $[5]$, nodes $3,4,5$ are leaves.\n- Leaf request queues: node $3$ has $[101,103]$, node $4$ has $[102]$, node $5$ has $[104,105]$.\n- Expected behavior: node $1$ merges $[3,4]$ round-robin yielding $[101,102,103]$; node $2$ yields $[104,105]$; root merges children $[1,2]$ round-robin yielding final root processing order $[101,104,102,105,103]$.\n\nTest case $2$ (upward propagation, boundary case with an empty queue):\n- Tree adjacency: node $0$ has children $[1,4]$, node $1$ has child $[2]$, node $2$ has child $[3]$, nodes $3$ and $4$ are leaves.\n- Leaf request queues: node $3$ has $[201,202,203]$, node $4$ has $[]$ (empty).\n- Expected behavior: root merges children $[1,4]$ round-robin; since node $4$ is empty, the final root processing order is $[201,202,203]$.\n\nTest case $3$ (downward propagation, general case):\n- Tree adjacency: node $0$ has children $[1,2,3]$, node $1$ has child $[4]$, node $2$ has child $[5]$, node $3$ has child $[6]$, nodes $4,5,6$ are leaves.\n- Root directives queue: $[31,32,33,34,35]$.\n- Forwarding policy: round-robin across children in increasing index order at every internal node.\n- Expected behavior: directives are forwarded so that leaves receive directives in the sequence of leaf indices $[4,5,6,4,5]$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[$result1$,$result2$,$result3$]`), where each `$resulti$` is a list of integers representing the final sequence for that test case. For the specified test suite, the single-line output must be a list of three lists, corresponding to test cases $1$, $2$, and $3$ in order.", "solution": "The problem requires the implementation of a First-In-First-Out (FIFO) queue using a singly linked list and its application to simulate two types of information flow—upward and downward—in a tree-structured hierarchy. The solution's correctness must be derived from the fundamental principles of these data structures.\n\nFirst, we establish the core data structure: a FIFO queue built upon a singly linked list. A singly linked list is a sequence of nodes, where each node contains a data payload and a reference (or pointer) to the next node in the sequence. For our queue, we define a `Node` structure that holds a `value` and a `next` pointer. The `Queue` itself maintains two pointers: `head`, pointing to the first node, and `tail`, pointing to the last node. This two-pointer design is critical for achieving the required time complexity.\n\nThe fundamental queue operations are implemented as follows:\n- **Enqueue**: An element is added to the back of the queue. A new `Node` is created with the given value. This new node is appended after the current `tail` node by setting `tail.next` to the new node. The `tail` pointer is then updated to this new node. If the queue was empty (both `head` and `tail` were `None`), both pointers are set to the new node. This operation only involves a few pointer manipulations, making its time complexity $O(1)$.\n- **Dequeue**: An element is removed from the front of the queue. The value of the `head` node is retrieved. The `head` pointer is then advanced to `head.next`. If this operation empties the queue (the `head` becomes `None`), the `tail` pointer must also be set to `None` to maintain the queue's invariant. This operation is also $O(1)$.\n- **Peek**: This operation returns the value of the `head` node without removing it. It is an $O(1)$ operation.\n- **Is_empty**: This checks if the queue is empty, which is true if `head` is `None`. This is an $O(1)$ check.\n\nThe problem then specifies two propagation models on a rooted tree $T$. The tree is defined by adjacency lists where each node $u$ is associated with a list of its children, sorted by their integer indices.\n\n**Upward Propagation Model:**\nThis model simulates the aggregation of requests from the leaves of the hierarchy up to the root. The process is defined recursively, corresponding to a post-order traversal of the tree.\nFor any node $u$ in the tree $T$:\n1.  **Base Case**: If $u$ is a leaf node, its queue is initialized with the given list of requests.\n2.  **Recursive Step**: If $u$ is an internal node, we first recursively compute the queues for all of its children. Then, we construct the queue for $u$ by merging its children's queues. The merging process is a round-robin procedure performed on the children in their specified increasing index order. In each round, we attempt to dequeue one element from the front of each non-empty child queue and enqueue it into the queue for $u$. This continues until all child queues are empty. This round-robin strategy ensures that elements from different children are interleaved, while the FIFO order of elements originating from the same child is preserved.\n\nThe final result for an upward propagation test case is the sequence of elements obtained by completely dequeueing the queue computed for the root node (node $0$).\n\n**Downward Propagation Model:**\nThis model simulates the distribution of directives from the root down to the leaves. The process is driven by the initial queue of directives at the root. Unlike the upward propagation, directives are processed one by one, with each directive traversing the tree from the root to a leaf before the next directive is processed.\n1.  Each internal node $u$ in the tree must maintain a state to handle the round-robin distribution to its children. This state can be a simple counter, `next_child_ptr`, indicating the index of the child to receive the next directive.\n2.  The simulation begins by dequeueing the first directive from the root's queue.\n3.  For a given directive, a path is traced from the root downwards. At any internal node $v$ on this path, the node consults its `next_child_ptr` to select a child, forwards the directive to that child, and then increments its `next_child_ptr` (with wrap-around) for the next directive it will process.\n4.  This traversal continues until the directive reaches a leaf node. The index of this leaf node is recorded as the directive's arrival destination.\n5.  This entire process is repeated for every directive in the root's initial queue. The final result for a downward propagation test case is the ordered sequence of leaf indices where the directives arrived.\n\nBy implementing the `Queue` class from first principles and then constructing the `solve_upward` and `solve_downward` procedures based on these rigorously defined models, we can simulate the test cases and produce the required results. The provided test cases, including their expected outcomes, serve to confirm the correct interpretation of these models, particularly the subtle mechanics of the downward propagation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A meticulous and exacting implementation of a singly linked-list based queue.\n\nclass Node:\n    \"\"\"\n    A node in a singly linked list.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\nclass Queue:\n    \"\"\"\n    A FIFO queue implemented using a singly linked list.\n    All core operations (enqueue, dequeue) are O(1).\n    \"\"\"\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self._size = 0\n\n    def is_empty(self):\n        \"\"\"Checks if the queue is empty. O(1).\"\"\"\n        return self.head is None\n\n    def enqueue(self, value):\n        \"\"\"Adds an element to the back of the queue. O(1).\"\"\"\n        new_node = Node(value)\n        if self.is_empty():\n            self.head = new_node\n            self.tail = new_node\n        else:\n            self.tail.next = new_node\n            self.tail = new_node\n        self._size += 1\n\n    def dequeue(self):\n        \"\"\"Removes and returns the element from the front of the queue. O(1).\"\"\"\n        if self.is_empty():\n            raise IndexError(\"dequeue from an empty queue\")\n        \n        value = self.head.value\n        self.head = self.head.next\n        if self.head is None:\n            self.tail = None\n        self._size -= 1\n        return value\n\n    def peek(self):\n        \"\"\"Returns the value of the front element without removing it. O(1).\"\"\"\n        if self.is_empty():\n            return None\n        return self.head.value\n\n    def size(self):\n        \"\"\"Returns the number of elements in the queue. O(1).\"\"\"\n        return self._size\n\n    def to_list(self):\n        \"\"\"Drains the queue and returns its elements as a list.\"\"\"\n        result = []\n        while not self.is_empty():\n            result.append(self.dequeue())\n        return result\n\ndef solve_upward(adj, leaf_queues_data):\n    \"\"\"\n    Solves for upward propagation.\n    Uses a post-order traversal (recursive with memoization) to build queues up the tree.\n    \"\"\"\n    memo = {}\n    \n    all_nodes = set(adj.keys())\n    for children in adj.values():\n        all_nodes.update(children)\n    \n    leaves = {node for node in all_nodes if node not in adj or not adj[node]}\n\n    def get_or_compute_queue(node_id):\n        if node_id in memo:\n            return memo[node_id]\n\n        # Base case: Leaf node\n        if node_id in leaves:\n            q = Queue()\n            for item in leaf_queues_data.get(node_id, []):\n                q.enqueue(item)\n            memo[node_id] = q\n            return q\n        \n        # Recursive step: Internal node\n        child_queues = [get_or_compute_queue(child_id) for child_id in adj[node_id]]\n        \n        merged_queue = Queue()\n        \n        # Round-robin merge\n        active_children = True\n        while active_children:\n            active_children = False\n            for child_q in child_queues:\n                if not child_q.is_empty():\n                    merged_queue.enqueue(child_q.dequeue())\n                    active_children = True\n        \n        memo[node_id] = merged_queue\n        return merged_queue\n\n    root_queue = get_or_compute_queue(0)\n    return root_queue.to_list()\n\n\ndef solve_downward(adj, root_directives):\n    \"\"\"\n    Solves for downward propagation.\n    Simulates item by item, with each internal node maintaining round-robin state.\n    \"\"\"\n    leaves = set()\n    all_nodes = set(adj.keys())\n    for children in adj.values():\n        all_nodes.update(children)\n    for node in all_nodes:\n        if node not in adj or not adj[node]:\n            leaves.add(node)\n\n    root_queue = Queue()\n    for directive in root_directives:\n        root_queue.enqueue(directive)\n        \n    # State for round-robin at each internal node\n    rr_state = {node_id: 0 for node_id in adj if adj[node_id]}\n    \n    arrival_sequence = []\n    \n    while not root_queue.is_empty():\n        directive = root_queue.dequeue()\n        current_node = 0\n        \n        while current_node not in leaves:\n            children = adj[current_node]\n            child_ptr = rr_state[current_node]\n            next_node = children[child_ptr]\n            \n            # Update state for next time\n            rr_state[current_node] = (child_ptr + 1) % len(children)\n            \n            current_node = next_node\n            \n        arrival_sequence.append(current_node)\n        \n    return arrival_sequence\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"type\": \"upward\",\n            \"adj\": {0: [1, 2], 1: [3, 4], 2: [5]},\n            \"data\": {3: [101, 103], 4: [102], 5: [104, 105]}\n        },\n        {\n            \"type\": \"upward\",\n            \"adj\": {0: [1, 4], 1: [2], 2: [3]},\n            \"data\": {3: [201, 202, 203], 4: []}\n        },\n        {\n            \"type\": \"downward\",\n            \"adj\": {0: [1, 2, 3], 1: [4], 2: [5], 3: [6]},\n            \"data\": [31, 32, 33, 34, 35]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"type\"] == \"upward\":\n            result = solve_upward(case[\"adj\"], case[\"data\"])\n            results.append(result)\n        elif case[\"type\"] == \"downward\":\n            result = solve_downward(case[\"adj\"], case[\"data\"])\n            results.append(result)\n\n    # Format the final output string to match the required format `[[...],[...]]`\n    # by removing spaces from the default string representation of a list of lists.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3246732"}, {"introduction": "In modern software, many processes run concurrently, and queues are essential for managing communication between them. This advanced practice guides you through building a thread-safe, blocking queue, a cornerstone of the classic producer-consumer problem in concurrent programming. You will use synchronization primitives like locks and condition variables to create a queue where a consumer thread can wait efficiently for an item to become available, a fundamental skill for developing robust multithreaded applications [@problem_id:3246704].", "problem": "You are to design and implement a thread-safe First-In First-Out (FIFO) queue using a singly linked list and a condition variable. The queue must support an operation that blocks the caller until an item becomes available, rather than returning a sentinel such as a null value. The core data structure is a singly linked list with a head pointer and a tail pointer. The correctness of the implementation must follow from core definitions and well-tested facts: the FIFO property dictates that the removal operation returns the oldest element currently stored, mutual exclusion ensures only one thread manipulates the shared state at a time, and condition variable semantics ensure that threads can wait efficiently until a predicate becomes true.\n\nBegin from the following foundations:\n- A queue is a sequence $Q = [x_1, x_2, \\dots, x_k]$ where $x_1$ is the oldest element and $x_k$ is the most recent. Enqueue appends an element to the end, and dequeue removes the element at the front. The queue must preserve the FIFO property.\n- A singly linked list node has a value and a next pointer. The queue maintains two pointers: a head pointer $H$ pointing to the oldest node and a tail pointer $T$ pointing to the newest node. An empty queue is represented by $H = \\varnothing$ and $T = \\varnothing$.\n- Mutual exclusion via a lock ensures that the invariants $H$ and $T$ are updated atomically with respect to other threads.\n- A condition variable supports waiting on a predicate while releasing the associated lock, and upon notification, re-acquires the lock to check the predicate again. The correct pattern uses a loop: while the predicate is false, wait; once the predicate becomes true, proceed. This guards against spurious wake-ups.\n\nYour program must implement the following operations over a linked-list queue:\n- Enqueue: acquires mutual exclusion, appends a new node to the tail in $O(1)$ time, updates $T$ and possibly $H$ if the queue was empty, signals the condition variable to wake one waiting thread.\n- Blocking dequeue: acquires mutual exclusion and, if the queue is empty, waits on the condition variable; when awakened, re-checks emptiness in a loop; once the queue is non-empty, removes the head in $O(1)$ time, updates $H$ and possibly $T$ if the queue becomes empty, and returns the removed value. This operation must never return a sentinel value and must block indefinitely until an item becomes available.\n\nYou must produce results for the following test suite. Each test case specifies parameters controlling the timing of enqueues and the number of producer and consumer threads. Use the monotonic clock and represent all times in seconds.\n\nTest Suite:\n- Case $1$ (happy path blocking): One consumer thread performs a blocking dequeue on an initially empty queue. One producer enqueues a single integer after a delay of $0.08$ seconds. Let $t_{\\text{wait}}$ be the measured time between entering the blocking dequeue and returning with the item. With tolerance $\\tau = 0.01$ seconds, report a boolean indicating whether $t_{\\text{wait}} \\ge 0.08 - 0.01$ and the returned value equals the enqueued value.\n- Case $2$ (FIFO ordering under staggered enqueues): One consumer thread performs three blocking dequeues; a producer enqueues three integers at delays $0.02$, $0.05$, and $0.07$ seconds respectively. Report a boolean indicating whether the consumer observed the sequence equal to the chronological enqueue order.\n- Case $3$ (multiple consumers fairness): Three consumer threads each perform one blocking dequeue; one producer enqueues three distinct integers after a delay of $0.05$ seconds. Report a boolean indicating whether all consumers return exactly one unique integer and the multiset of returned values matches the multiset of enqueued values.\n- Case $4$ (immediate availability): Enqueue one integer before starting a consumer that performs a blocking dequeue. Let $t_{\\text{wait}}$ be measured as in Case $1$. With threshold $\\theta = 0.01$ seconds, report a boolean indicating whether $t_{\\text{wait}}  0.01$.\n- Case $5$ (spurious wake-up guard): One consumer thread performs a blocking dequeue on an empty queue. A separate thread performs a condition variable notification without enqueuing after $0.02$ seconds. Finally, a producer enqueues one integer after an additional $0.03$ seconds. Let $t_{\\text{wait}}$ be measured as in Case $1$. With tolerance $\\tau = 0.01$ seconds, report a boolean indicating whether $t_{\\text{wait}} \\ge (0.02 + 0.03) - 0.01$. This tests that the implementation properly re-checks the predicate and continues to block after a spurious notification.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $5$. Each case’s result must be a boolean. For example: `[True,True,True,True,False]` but using the programming language’s canonical boolean literals. No angle units are used, and all time measurements must be expressed in seconds, rounded implicitly by the language’s default representation. The program must be complete and runnable without any external input or files.", "solution": "The problem statement has been validated and is found to be scientifically grounded, well-posed, and objective. It presents a standard but non-trivial problem in concurrent programming and data structures, providing clear, formalizable requirements and a verifiable test suite. The problem is valid.\n\nThe task is to design and implement a thread-safe, blocking First-In-First-Out (FIFO) queue. The implementation must be based on a singly linked list with head and tail pointers, ensuring $O(1)$ time complexity for both enqueue and dequeue operations. Thread safety will be achieved using a mutual exclusion lock, and the blocking behavior will be managed by a condition variable.\n\nFirst, we define the elemental component of the linked list, the `Node`. Each `Node` contains a `value` and a `next` pointer, which points to the subsequent node in the sequence.\n- `Node.value`: The data element stored in the node.\n- `Node.next`: A reference to the next `Node` in the list, or `None` (representing $\\varnothing$) if it is the last node.\n\nThe `BlockingQueue` class encapsulates the queue's state and logic. Its state is defined by:\n- A head pointer, $H$, which points to the first (oldest) node in the list.\n- A tail pointer, $T$, which points to the last (newest) node in the list.\n- A lock, an instance of `threading.Lock`, for ensuring mutual exclusion.\n- A condition variable, an instance of `threading.Condition`, associated with the lock, to manage threads waiting for items to become available.\n\nThe invariant for an empty queue is $H = \\varnothing$ and $T = \\varnothing$. For a non-empty queue, $H$ points to the start of the list and $T$ to the end.\n\nThe initialization of the `BlockingQueue` sets $H$ and $T$ to `None` and instantiates the lock and the condition variable.\n\nThe `enqueue(item)` operation implements the logic for adding an element to the queue:\n$1$. Acquire the lock to ensure atomic modification of the queue's shared state ($H$ and $T$).\n$2$. Create a new `Node` instance to hold the `item`.\n$3$. Check if the queue is empty by testing if $T$ is `None`.\n    a. If the queue is empty ($T = \\varnothing$), it implies $H$ is also `None`. In this case, both $H$ and $T$ are set to point to the new node. This establishes the queue with a single element.\n    b. If the queue is not empty, the new node is appended to the end of the list. This is achieved by setting the `next` pointer of the current tail node (`T.next`) to the new node. Subsequently, the tail pointer $T$ is updated to point to this new node, which is now the last element.\n$4$. After successfully adding the node and updating the pointers, signal one waiting thread by calling the condition variable's `notify()` method. This is crucial as it informs a potentially blocked consumer thread that the state has changed and an item is now available.\n$5$. Release the lock. The use of a `with` statement handles this automatically.\nThis entire operation has a time complexity of $O(1)$ because it consists of a fixed number of pointer assignments.\n\nThe `blocking_dequeue()` operation implements the logic for removing an element from the queue, blocking if necessary:\n$1$. Acquire the lock to ensure exclusive access to the queue's state.\n$2$. Check the predicate for waiting: whether the queue is empty. The correct and robust way to do this with a condition variable is within a `while` loop: `while self.head is None:`. The condition $H = \\varnothing$ indicates the queue is empty.\n$3$. If the predicate is true (queue is empty), call `self.condition.wait()`. This atomically releases the lock and suspends the current thread's execution until it is notified. Upon waking (due to a `notify()` or `notify_all()` call), the thread re-acquires the lock, and the `while` loop condition is re-evaluated. This loop structure correctly handles spurious wake-ups, where a thread might be awakened even if no item has been enqueued. The thread will simply re-check the condition, find the queue is still empty, and go back to waiting.\n$4$. Once the `while` loop terminates, it is guaranteed that the queue is not empty (i.e., $H \\neq \\varnothing$) and the current thread holds the lock.\n$5$. Retrieve the value from the head node: `value = self.head.value`.\n$6$. Remove the head node from the queue by advancing the head pointer to the next node: `self.head = self.head.next`.\n$7$. A special case must be handled: if the queue becomes empty as a result of the dequeue operation (i.e., the new $H$ is `None`), the tail pointer $T$ must also be set to `None` to maintain the empty-queue invariant ($H=\\varnothing, T=\\varnothing$).\n$8$. Return the retrieved `value`. The lock is released upon exiting the `with` block.\nLike enqueue, this operation has a time complexity of $O(1)$ for the pointer manipulation part, exclusive of any waiting time.\n\nThis design fulfills all requirements of the problem statement. It correctly implements a FIFO queue using a singly linked list with $O(1)$ operations, ensures thread safety through mutual exclusion, and provides a correct, non-sentinel blocking dequeue mechanism guarded against spurious wake-ups. The test suite provided in the problem will be used to verify the correctness of this design when implemented.", "answer": "```python\nimport threading\nimport time\nimport queue\nimport numpy as np\n\n# According to the problem statement, numpy must be imported.\n# It is not used in the core logic but its presence satisfies the constraint.\n\nclass Node:\n    \"\"\"A node in a singly linked list.\"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\nclass BlockingQueue:\n    \"\"\"\n    A thread-safe FIFO queue implemented with a singly linked list,\n    a lock, and a condition variable. Dequeue operations block until an\n    item is available.\n    \"\"\"\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.lock = threading.Lock()\n        self.condition = threading.Condition(self.lock)\n\n    def enqueue(self, item):\n        \"\"\"\n        Adds an item to the tail of the queue in O(1) time.\n        Signals a waiting consumer thread.\n        \"\"\"\n        new_node = Node(item)\n        with self.lock:\n            if self.tail is None:\n                # The queue is empty\n                self.head = new_node\n                self.tail = new_node\n            else:\n                # The queue is not empty\n                self.tail.next = new_node\n                self.tail = new_node\n            \n            # Signal one waiting thread that an item is now available.\n            self.condition.notify()\n\n    def blocking_dequeue(self):\n        \"\"\"\n        Removes and returns an item from the head of the queue in O(1) time.\n        Blocks if the queue is empty until an item becomes available.\n        \"\"\"\n        with self.lock:\n            # The while loop is crucial to guard against spurious wake-ups.\n            while self.head is None:\n                self.condition.wait()\n            \n            # At this point, self.head is guaranteed to be non-None.\n            value = self.head.value\n            self.head = self.head.next\n            \n            if self.head is None:\n                # The queue has become empty.\n                self.tail = None\n            \n            return value\n\ndef solve():\n    \"\"\"\n    Executes the test suite specified in the problem statement to validate\n    the BlockingQueue implementation.\n    \"\"\"\n    results = []\n\n    # Case 1: Happy path blocking\n    q1 = BlockingQueue()\n    consumer_result1 = []\n    def consumer_task_1():\n        start_time = time.monotonic()\n        val = q1.blocking_dequeue()\n        end_time = time.monotonic()\n        wait_time = end_time - start_time\n        consumer_result1.append((val, wait_time))\n    def producer_task_1(delay, value):\n        time.sleep(delay)\n        q1.enqueue(value)\n\n    delay1 = 0.08\n    tolerance1 = 0.01\n    enqueued_value1 = 42\n    \n    c1 = threading.Thread(target=consumer_task_1)\n    p1 = threading.Thread(target=producer_task_1, args=(delay1, enqueued_value1))\n    \n    c1.start()\n    p1.start()\n    c1.join()\n    p1.join()\n    \n    dequeued_value1, wait_time1 = consumer_result1[0]\n    results.append(wait_time1 = (delay1 - tolerance1) and dequeued_value1 == enqueued_value1)\n\n    # Case 2: FIFO ordering under staggered enqueues\n    q2 = BlockingQueue()\n    dequeued_values2 = []\n    def consumer_task_2():\n        for _ in range(3):\n            dequeued_values2.append(q2.blocking_dequeue())\n    def producer_task_2():\n        enqueued_items = [(0.02, 10), (0.05, 20), (0.07, 30)]\n        current_time = 0\n        for delay, value in enqueued_items:\n            time.sleep(delay - current_time)\n            q2.enqueue(value)\n            current_time = delay\n\n    c2 = threading.Thread(target=consumer_task_2)\n    p2 = threading.Thread(target=producer_task_2)\n\n    c2.start()\n    p2.start()\n    c2.join()\n    p2.join()\n    \n    results.append(dequeued_values2 == [10, 20, 30])\n\n    # Case 3: Multiple consumers fairness\n    q3 = BlockingQueue()\n    results_q3 = queue.Queue()\n    enqueued_values3 = {101, 102, 103}\n    def consumer_task_3():\n        results_q3.put(q3.blocking_dequeue())\n    def producer_task_3():\n        time.sleep(0.05)\n        for val in enqueued_values3:\n            q3.enqueue(val)\n\n    consumers3 = [threading.Thread(target=consumer_task_3) for _ in range(3)]\n    producer3 = threading.Thread(target=producer_task_3)\n    \n    for c in consumers3:\n        c.start()\n    producer3.start()\n    \n    for c in consumers3:\n        c.join()\n    producer3.join()\n    \n    dequeued_values3 = set()\n    while not results_q3.empty():\n        dequeued_values3.add(results_q3.get())\n\n    results.append(dequeued_values3 == enqueued_values3)\n\n    # Case 4: Immediate availability\n    q4 = BlockingQueue()\n    consumer_result4 = []\n    q4.enqueue(99) # Enqueue before consumer starts\n    def consumer_task_4():\n        start_time = time.monotonic()\n        val = q4.blocking_dequeue()\n        end_time = time.monotonic()\n        wait_time = end_time - start_time\n        consumer_result4.append((val, wait_time))\n\n    c4 = threading.Thread(target=consumer_task_4)\n    c4.start()\n    c4.join()\n\n    _, wait_time4 = consumer_result4[0]\n    results.append(wait_time4  0.01)\n\n    # Case 5: Spurious wake-up guard\n    q5 = BlockingQueue()\n    consumer_result5 = []\n    def consumer_task_5():\n        start_time = time.monotonic()\n        val = q5.blocking_dequeue()\n        end_time = time.monotonic()\n        wait_time = end_time - start_time\n        consumer_result5.append((val, wait_time))\n\n    def notifier_task_5():\n        time.sleep(0.02)\n        with q5.lock:\n            q5.condition.notify()\n\n    def producer_task_5():\n        time.sleep(0.05)  # 0.02 + 0.03\n        q5.enqueue(55)\n\n    c5 = threading.Thread(target=consumer_task_5)\n    n5 = threading.Thread(target=notifier_task_5)\n    p5 = threading.Thread(target=producer_task_5)\n    \n    c5.start()\n    n5.start()\n    p5.start()\n\n    c5.join()\n    n5.join()\n    p5.join()\n\n    _, wait_time5 = consumer_result5[0]\n    total_producer_delay = 0.05\n    tolerance5 = 0.01\n    results.append(wait_time5 = (total_producer_delay - tolerance5))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results)).lower()}]\")\n\nsolve()\n\n```", "id": "3246704"}]}