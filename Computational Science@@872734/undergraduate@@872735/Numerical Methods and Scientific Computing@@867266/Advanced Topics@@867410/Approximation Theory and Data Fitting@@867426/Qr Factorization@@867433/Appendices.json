{"hands_on_practices": [{"introduction": "The Gram-Schmidt process provides a direct and intuitive algorithm for constructing a QR factorization. This exercise will guide you through the step-by-step procedure of orthogonalizing a set of vectors to produce the orthogonal matrix $Q$ and the corresponding upper triangular matrix $R$. Mastering this foundational technique is essential for understanding how the decomposition works from first principles.", "problem": "Consider the matrix $A$ given by:\n$$A = \\begin{pmatrix} 1  1 \\\\ 2  0 \\\\ 2  -1 \\end{pmatrix}$$\nA QR factorization of $A$ is a decomposition $A = QR$, where $Q$ is a matrix with orthonormal columns and $R$ is an upper triangular matrix. Find the matrix $R$ in the QR factorization of $A$ obtained by applying the Gram-Schmidt process to the columns of $A$, taken in their given order from left to right. The process must be normalized such that the diagonal entries of the matrix $R$ are positive.", "solution": "Let the columns of $A$ be $a_{1}$ and $a_{2}$ with\n$$a_{1}=\\begin{pmatrix}1\\\\2\\\\2\\end{pmatrix}, \\quad a_{2}=\\begin{pmatrix}1\\\\0\\\\-1\\end{pmatrix}.$$\nClassical Gram-Schmidt proceeds as follows.\n\nFirst, compute $r_{11}=\\|a_{1}\\|$ and $q_{1}=a_{1}/r_{11}$:\n$$\\|a_{1}\\|=\\sqrt{1^{2}+2^{2}+2^{2}}=\\sqrt{9}=3,$$\n$$q_{1}=\\frac{1}{3}\\begin{pmatrix}1\\\\2\\\\2\\end{pmatrix}=\\begin{pmatrix}\\frac{1}{3}\\\\\\frac{2}{3}\\\\\\frac{2}{3}\\end{pmatrix}.$$\n\nNext, compute $r_{12}=q_{1}^{T}a_{2}$:\n$$r_{12}=\\begin{pmatrix}\\frac{1}{3}\\frac{2}{3}\\frac{2}{3}\\end{pmatrix}\\begin{pmatrix}1\\\\0\\\\-1\\end{pmatrix}=\\frac{1}{3}-\\frac{2}{3}=-\\frac{1}{3}.$$\n\nForm $u_{2}=a_{2}-r_{12}q_{1}$ and then $r_{22}=\\|u_{2}\\|$:\n$$u_{2}=a_{2}-\\left(-\\frac{1}{3}\\right)q_{1}=a_{2}+\\frac{1}{3}q_{1}=\\begin{pmatrix}1\\\\0\\\\-1\\end{pmatrix}+\\begin{pmatrix}\\frac{1}{9}\\\\\\frac{2}{9}\\\\\\frac{2}{9}\\end{pmatrix}=\\begin{pmatrix}\\frac{10}{9}\\\\\\frac{2}{9}\\\\-\\frac{7}{9}\\end{pmatrix},$$\n$$\\|u_{2}\\|=\\sqrt{\\left(\\frac{10}{9}\\right)^{2}+\\left(\\frac{2}{9}\\right)^{2}+\\left(-\\frac{7}{9}\\right)^{2}}=\\sqrt{\\frac{100+4+49}{81}}=\\sqrt{\\frac{153}{81}}=\\frac{\\sqrt{17}}{3}.$$\n\nWith the convention that diagonal entries are positive, we take\n$$r_{11}=3,\\quad r_{12}=-\\frac{1}{3},\\quad r_{22}=\\frac{\\sqrt{17}}{3}.$$\nTherefore, the upper triangular matrix $R$ is\n$$R=\\begin{pmatrix}3  -\\frac{1}{3}\\\\ 0  \\frac{\\sqrt{17}}{3}\\end{pmatrix}.$$", "answer": "$$\\boxed{\\begin{pmatrix}3  -\\frac{1}{3}\\\\ 0  \\frac{\\sqrt{17}}{3}\\end{pmatrix}}$$", "id": "1385295"}, {"introduction": "Once you understand the mechanics of computing a QR factorization, it is vital to solidify your conceptual grasp of its defining properties. This problem [@problem_id:3264523] presents a thought experiment: what is the QR factorization of a matrix that already consists of orthonormal columns? By working through this special case, you will reinforce your understanding of the roles of the matrices $Q$ and $R$ and the constraints that define them.", "problem": "Consider a real matrix $A \\in \\mathbb{R}^{m \\times n}$ with $m \\geq n$ whose columns $\\{a_{1},\\dots,a_{n}\\}$ are orthonormal, meaning $a_{i}^{\\top} a_{j} = \\delta_{ij}$ for all $i,j \\in \\{1,\\dots,n\\}$, where $\\delta_{ij}$ is the Kronecker delta and $I_{n}$ denotes the $n \\times n$ identity matrix. The orthogonal-triangular (QR) factorization seeks matrices $Q \\in \\mathbb{R}^{m \\times n}$ and $R \\in \\mathbb{R}^{n \\times n}$ such that $A = Q R$, $Q^{\\top} Q = I_{n}$, and $R$ is upper triangular with positive diagonal entries.\n\nStarting from these definitions and the condition $A^{\\top} A = I_{n}$ implied by the orthonormality of the columns of $A$, derive what $Q$ and $R$ must be. Then, compute the exact value of $\\det(R)$. Provide your final answer as a single real number. No rounding is required.", "solution": "The problem is validated as self-contained, scientifically grounded, and well-posed. The provided definitions and conditions are standard in linear algebra and numerical analysis. There are no contradictions, ambiguities, or unsound premises. We may proceed with the solution.\n\nWe are given a real matrix $A \\in \\mathbb{R}^{m \\times n}$ with $m \\geq n$. The columns of $A$, denoted $\\{a_{1}, \\dots, a_{n}\\}$, are orthonormal. This property is defined by the relation $a_{i}^{\\top} a_{j} = \\delta_{ij}$, where $\\delta_{ij}$ is the Kronecker delta. Let's analyze the product $A^{\\top}A$. The entry in the $i$-th row and $j$-th column of $A^{\\top}A$ is the product of the $i$-th row of $A^{\\top}$ and the $j$-th column of $A$. The $i$-th row of $A^{\\top}$ is the transpose of the $i$-th column of $A$, which is $a_{i}^{\\top}$. The $j$-th column of $A$ is $a_{j}$. Therefore, the $(i,j)$-th entry of $A^{\\top}A$ is $a_{i}^{\\top}a_{j}$. From the orthonormality condition, this is equal to $\\delta_{ij}$. This means that the matrix $A^{\\top}A$ is the $n \\times n$ identity matrix, $I_{n}$.\n$$ A^{\\top}A = I_{n} $$\nThe problem concerns the orthogonal-triangular (QR) factorization of $A$, which is given by $A = QR$. The properties of the factors are:\n$1$. $Q$ is a matrix in $\\mathbb{R}^{m \\times n}$ with orthonormal columns, satisfying $Q^{\\top}Q = I_{n}$.\n$2$. $R$ is a matrix in $\\mathbb{R}^{n \\times n}$ which is upper triangular and has positive diagonal entries.\n\nWe can substitute the factorization $A = QR$ into the identity $A^{\\top}A = I_{n}$:\n$$ (QR)^{\\top}(QR) = I_{n} $$\nUsing the property of the transpose of a product, $(XY)^{\\top} = Y^{\\top}X^{\\top}$, we get:\n$$ R^{\\top}Q^{\\top}QR = I_{n} $$\nWe are given that $Q$ has orthonormal columns, which means $Q^{\\top}Q = I_{n}$. Substituting this into the equation yields:\n$$ R^{\\top}I_{n}R = I_{n} $$\n$$ R^{\\top}R = I_{n} $$\nThis equation shows that the matrix $R$ is an orthogonal matrix. We have two key properties for $R$:\n$1$. $R$ is an upper triangular matrix.\n$2$. $R$ is an orthogonal matrix, i.e., $R^{-1} = R^{\\top}$.\n\nLet's combine these properties. The inverse of an upper triangular matrix, $R^{-1}$, must also be an upper triangular matrix. However, from the orthogonality condition, we know that $R^{-1} = R^{\\top}$. The transpose of an upper triangular matrix, $R^{\\top}$, is a lower triangular matrix.\nTherefore, the matrix $R^{-1}$ must be simultaneously upper triangular and lower triangular. The only matrices with this property are diagonal matrices.\nSince $R^{-1}$ is a diagonal matrix, its inverse, $R = (R^{-1})^{-1}$, must also be a diagonal matrix.\nSo, $R$ is a diagonal matrix. Let's write $R$ as $R = \\text{diag}(r_{11}, r_{22}, \\dots, r_{nn})$.\n\nNow, we use the condition $R^{\\top}R = I_{n}$ with $R$ being a diagonal matrix.\n$$ (\\text{diag}(r_{11}, \\dots, r_{nn}))^{\\top} (\\text{diag}(r_{11}, \\dots, r_{nn})) = I_{n} $$\nSince a diagonal matrix is symmetric, its transpose is itself:\n$$ (\\text{diag}(r_{11}, \\dots, r_{nn})) (\\text{diag}(r_{11}, \\dots, r_{nn})) = I_{n} $$\n$$ \\text{diag}(r_{11}^2, r_{22}^2, \\dots, r_{nn}^2) = I_{n} $$\nThis implies that for each diagonal entry $r_{ii}$, we must have $r_{ii}^2 = 1$. This means $r_{ii}$ can be either $1$ or $-1$.\nHowever, the problem statement provides a crucial constraint: the diagonal entries of $R$ must be positive.\nTherefore, we must have $r_{ii} = 1$ for all $i \\in \\{1, \\dots, n\\}$.\nThis uniquely determines the matrix $R$. It must be the $n \\times n$ identity matrix:\n$$ R = I_{n} $$\nNow that we have determined $R$, we can find $Q$ from the factorization equation $A = QR$. Substituting $R = I_{n}$:\n$$ A = Q I_{n} $$\n$$ A = Q $$\nThus, the matrix $Q$ must be the matrix $A$ itself. This is consistent with the properties of $Q$, as we are given that $A \\in \\mathbb{R}^{m \\times n}$ and its columns are orthonormal, which implies $A^{\\top}A = I_{n}$. The derived matrices are $Q = A$ and $R = I_{n}$.\n\nThe final task is to compute the exact value of the determinant of $R$, denoted $\\det(R)$.\nSince we have established that $R = I_{n}$, we need to compute $\\det(I_{n})$. The determinant of the identity matrix of any size is $1$.\n$$ \\det(R) = \\det(I_{n}) = 1 $$\nThe determinant is a single real number as required.", "answer": "$$\\boxed{1}$$", "id": "3264523"}, {"introduction": "The true power of QR factorization lies in its application to solving real-world problems, particularly in the realm of linear least squares. This advanced exercise [@problem_id:3264482] challenges you to fit a circle to a set of data points, a common task in computer graphics and data analysis. You will see how to transform a non-linear geometric problem into a linear system and solve it robustly using QR factorization, which is a numerically stable method for solving such practical problems.", "problem": "Design and implement a complete program that computes the best-fit circle for several sets of two-dimensional data points using the method of linear least squares solved via QR factorization. Your task is to start from first principles: the geometric definition of a circle and the definition of least squares. From these bases, derive a linear system whose solution yields the circle parameters, and then specify how to solve this linear least squares problem using QR factorization without forming the normal equations. Finally, implement the algorithm.\n\nRequirements:\n- Derive a linear least squares formulation for the circle defined by center $\\left(a,b\\right)$ and radius $r$ that best fits given points $\\left(x_i,y_i\\right)$, where $i$ ranges over the available data. You must explain how the formulation arises from the circle equation and the least squares principle.\n- Use QR factorization to solve the resulting linear least squares problem. You must use the factorization $A = QR$, where $Q$ has orthonormal columns and $R$ is upper triangular, and then solve the triangular system to obtain the parameter vector. Do not use the normal equations.\n- The algorithm must be numerically sound and self-contained.\n\nTest suite:\nYou must run your program on the following four test cases. Each test case is a list of points. All coordinates are unitless real numbers.\n- Case $1$ (exact data on a circle): points $\\left(4.75,-2.0\\right)$, $\\left(1.5,1.25\\right)$, $\\left(-1.75,-2.0\\right)$, $\\left(1.5,-5.25\\right)$, $\\left(3.798097038,0.298097038\\right)$.\n- Case $2$ (noisy data near a circle): points $\\left(5.10,-0.05\\right)$, $\\left(0.05,4.92\\right)$, $\\left(-4.93,0.03\\right)$, $\\left(0.02,-5.04\\right)$, $\\left(3.585,3.515\\right)$, $\\left(-3.595,3.545\\right)$, $\\left(-3.515,-3.565\\right)$, $\\left(3.495,-3.515\\right)$.\n- Case $3$ (minimal non-collinear points): points $\\left(2.0,1.0\\right)$, $\\left(4.0,5.0\\right)$, $\\left(-1.0,3.0\\right)$.\n- Case $4$ (nearly collinear points): points $\\left(-1.0,-1.01\\right)$, $\\left(0.0,1.0\\right)$, $\\left(1.0,2.99\\right)$, $\\left(2.0,5.02\\right)$, $\\left(1.5,4.01\\right)$.\n\nProgram output specification:\n- For each test case, compute the best-fit circle parameters and report the center $\\left(a,b\\right)$ and radius $r$ obtained from your QR-based least squares solution.\n- Round each of $a$, $b$, and $r$ to exactly $6$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist of three floats $\\left[a,b,r\\right]$. For example: $\\left[\\left[a_1,b_1,r_1\\right],\\left[a_2,b_2,r_2\\right],\\left[a_3,b_3,r_3\\right],\\left[a_4,b_4,r_4\\right]\\right]$.\n- There are no physical units involved. All outputs are plain real numbers.\n\nYour final answer must be a complete, runnable program that performs the derivation algorithmically and prints the required single-line output in the exact format described above. The only permitted library beyond the Python standard library is Numerical Python (NumPy).", "solution": "The problem requires the design and implementation of an algorithm to find the best-fit circle for a given set of two-dimensional points. The method must be based on a linear least squares formulation, derived from first principles, and solved using QR factorization.\n\n### 1. Derivation of the Linear Least Squares Formulation\n\nThe fundamental geometric entity is a circle in a two-dimensional Cartesian plane. The equation of a circle with center coordinates $(a, b)$ and radius $r$ is given by:\n$$ (x-a)^2 + (y-b)^2 = r^2 $$\nThis equation is non-linear with respect to the parameters $a$ and $b$. To apply linear least squares, we must transform this equation into a form that is linear in a new set of parameters. We can expand the quadratic terms:\n$$ x^2 - 2ax + a^2 + y^2 - 2by + b^2 = r^2 $$\nBy rearranging the terms to separate the unknowns from the data $(x, y)$, we obtain:\n$$ 2ax + 2by + (r^2 - a^2 - b^2) = x^2 + y^2 $$\nTo linearize this relationship, we introduce a new set of parameters, $c_1$, $c_2$, and $c_3$, defined as follows:\n$$ c_1 = 2a $$\n$$ c_2 = 2b $$\n$$ c_3 = r^2 - a^2 - b^2 $$\nSubstituting these into the rearranged circle equation yields a linear relationship between the new parameters and the data:\n$$ c_1 x + c_2 y + c_3 = x^2 + y^2 $$\nThis equation forms the basis of our linear model. For each data point $(x_i, y_i)$, it provides a linear equation in terms of the unknown parameters $c_1$, $c_2$, and $c_3$.\n\n### 2. Formulation as a Linear Least Squares Problem\n\nFor a set of $n$ data points $(x_i, y_i)$ for $i=1, 2, \\dots, n$, we have a system of $n$ linear equations. In general, if the points are noisy or there are more than $3$ points, there will be no single set of parameters $(c_1, c_2, c_3)$ that perfectly satisfies all equations. The problem thus becomes finding the parameters that \"best\" fit the data.\n\nThe principle of least squares dictates that we should minimize the sum of the squared residuals. The residual $e_i$ for the $i$-th point is the difference between the two sides of our derived linear equation:\n$$ e_i = (c_1 x_i + c_2 y_i + c_3) - (x_i^2 + y_i^2) $$\nThe objective is to find the parameter vector $\\mathbf{p} = [c_1, c_2, c_3]^T$ that minimizes the sum of squared residuals, $S$:\n$$ S = \\sum_{i=1}^{n} e_i^2 $$\nThis minimization problem can be expressed in matrix form. We seek to find the vector $\\mathbf{p}$ that minimizes the Euclidean norm of the residual vector $\\mathbf{e} = A\\mathbf{p} - \\mathbf{b}$:\n$$ \\min_{\\mathbf{p}} \\| A\\mathbf{p} - \\mathbf{b} \\|_2^2 $$\nThe matrix $A$ and the vector $\\mathbf{b}$ are constructed from the data points as follows:\n$$\nA = \\begin{pmatrix}\nx_1  y_1  1 \\\\\nx_2  y_2  1 \\\\\n\\vdots  \\vdots  \\vdots \\\\\nx_n  y_n  1\n\\end{pmatrix},\n\\quad \\mathbf{p} = \\begin{pmatrix} c_1 \\\\ c_2 \\\\ c_3 \\end{pmatrix},\n\\quad \\mathbf{b} = \\begin{pmatrix}\nx_1^2 + y_1^2 \\\\\nx_2^2 + y_2^2 \\\\\n\\vdots \\\\\nx_n^2 + y_n^2\n\\end{pmatrix}\n$$\nHere, $A$ is an $n \\times 3$ matrix, $\\mathbf{p}$ is a $3 \\times 1$ vector of unknowns, and $\\mathbf{b}$ is an $n \\times 1$ vector.\n\n### 3. Solution via QR Factorization\n\nThe problem statement mandates solving this linear least squares problem using QR factorization, explicitly avoiding the formation of the normal equations $A^T A \\mathbf{p} = A^T \\mathbf{b}$. This approach is numerically superior, particularly when the matrix $A$ is ill-conditioned, as is the case for nearly collinear points. Forming $A^T A$ squares the condition number of the matrix, potentially leading to a significant loss of precision.\n\nThe algorithm proceeds as follows:\n1.  **Decomposition**: We compute the \"thin\" or \"reduced\" QR factorization of the $n \\times 3$ matrix $A$, such that $A = QR$. In this factorization, $Q$ is an $n \\times 3$ matrix with orthonormal columns ($Q^T Q = I$, where $I$ is the $3 \\times 3$ identity matrix), and $R$ is a $3 \\times 3$ upper triangular matrix.\n\n2.  **System Transformation**: We substitute $A = QR$ into the minimization objective:\n    $$ \\| A\\mathbf{p} - \\mathbf{b} \\|_2^2 = \\| QR\\mathbf{p} - \\mathbf{b} \\|_2^2 $$\n    Since orthogonal transformations preserve the Euclidean norm, we can multiply by $Q^T$ without changing the length:\n    $$ \\| QR\\mathbf{p} - \\mathbf{b} \\|_2^2 = \\| Q^T(QR\\mathbf{p} - \\mathbf{b}) \\|_2^2 = \\| R\\mathbf{p} - Q^T\\mathbf{b} \\|_2^2 $$\n    Minimizing this norm is achieved by solving the linear system:\n    $$ R \\mathbf{p} = Q^T \\mathbf{b} $$\n\n3.  **Solving the System**: The equation $R\\mathbf{p} = Q^T\\mathbf{b}$ represents a square ($3 \\times 3$) linear system. Because $R$ is upper triangular, this system can be efficiently and accurately solved for the parameter vector $\\mathbf{p}$ using back substitution.\n\n### 4. Recovery of Geometric Circle Parameters\n\nOnce the least squares solution $\\mathbf{p} = [c_1, c_2, c_3]^T$ is found, we must convert these intermediate parameters back into the physically meaningful geometric parameters of the circle: center $(a, b)$ and radius $r$. Using the definitions from Step 1:\n-   Center $x$-coordinate: $a = \\frac{c_1}{2}$\n-   Center $y$-coordinate: $b = \\frac{c_2}{2}$\n-   Radius: From $c_3 = r^2 - a^2 - b^2$, we solve for $r$:\n    $$ r^2 = c_3 + a^2 + b^2 $$\n    $$ r = \\sqrt{c_3 + a^2 + b^2} $$\nThe radius $r$ must be a real, positive value, which requires $c_3 + a^2 + b^2 > 0$. This condition holds for any set of non-collinear input points.\n\nThe complete algorithm is thus:\n1.  Given $n$ points $(x_i, y_i)$, construct the $n \\times 3$ matrix $A$ and the $n \\times 1$ vector $\\mathbf{b}$.\n2.  Compute the reduced QR factorization $A=QR$.\n3.  Calculate the vector $\\mathbf{c}' = Q^T\\mathbf{b}$.\n4.  Solve the upper triangular system $R\\mathbf{p} = \\mathbf{c}'$ for $\\mathbf{p} = [c_1, c_2, c_3]^T$.\n5.  Compute the circle parameters: $a = c_1/2$, $b = c_2/2$, and $r = \\sqrt{c_3 + a^2 + b^2}$.\nThis procedure yields the parameters of the circle that best fits the given data in the algebraic least squares sense.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the best-fit circle for several sets of 2D data points using\n    linear least squares solved via QR factorization.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (exact data on a circle)\n        np.array([\n            (4.75, -2.0), (1.5, 1.25), (-1.75, -2.0),\n            (1.5, -5.25), (3.798097038, 0.298097038)\n        ]),\n        # Case 2 (noisy data near a circle)\n        np.array([\n            (5.10, -0.05), (0.05, 4.92), (-4.93, 0.03),\n            (0.02, -5.04), (3.585, 3.515), (-3.595, 3.545),\n            (-3.515, -3.565), (3.495, -3.515)\n        ]),\n        # Case 3 (minimal non-collinear points)\n        np.array([\n            (2.0, 1.0), (4.0, 5.0), (-1.0, 3.0)\n        ]),\n        # Case 4 (nearly collinear points)\n        np.array([\n            (-1.0, -1.01), (0.0, 1.0), (1.0, 2.99),\n            (2.0, 5.02), (1.5, 4.01)\n        ])\n    ]\n\n    results = []\n    for points in test_cases:\n        # Extract x and y coordinates\n        x = points[:, 0]\n        y = points[:, 1]\n\n        # 1. Construct the matrix A and vector b for the linear system A*p = b\n        # The system is derived from c1*x + c2*y + c3 = x^2 + y^2\n        A = np.vstack([x, y, np.ones(len(x))]).T\n        b = x**2 + y**2\n\n        # 2. Compute the reduced QR factorization of A\n        # A = QR, where Q is n x 3 with orthonormal columns and R is 3 x 3 upper triangular\n        Q, R = np.linalg.qr(A)\n\n        # 3. Solve the system R*p = Q.T * b for the parameter vector p = [c1, c2, c3]\n        # This is the solution to the least squares problem min||A*p - b||^2\n        qt_b = Q.T @ b\n        p = np.linalg.solve(R, qt_b)\n        \n        c1, c2, c3 = p[0], p[1], p[2]\n\n        # 4. Recover the geometric circle parameters (a, b, r) from the algebraic parameters\n        # c1 = 2a  => a = c1 / 2\n        # c2 = 2b  => b = c2 / 2\n        # c3 = r^2 - a^2 - b^2 => r = sqrt(c3 + a^2 + b^2)\n        a = c1 / 2.0\n        b = c2 / 2.0\n        r = np.sqrt(c3 + a**2 + b**2)\n\n        # Round the results to 6 decimal places as required\n        a_r = round(a, 6)\n        b_r = round(b, 6)\n        r_r = round(r, 6)\n        \n        results.append([a_r, b_r, r_r])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is converted to a string\n    # and spaces are removed to match the specified format \"[[a1,b1,r1],[a2,b2,r2],...]\".\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3264482"}]}