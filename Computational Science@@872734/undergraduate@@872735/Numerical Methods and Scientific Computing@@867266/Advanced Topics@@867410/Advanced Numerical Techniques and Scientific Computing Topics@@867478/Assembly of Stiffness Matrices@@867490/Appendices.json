{"hands_on_practices": [{"introduction": "The heart of the finite element assembly process is the local-to-global mapping, which dictates how contributions from individual element matrices are summed into the global system. A solid mental model of this process is crucial for both implementing and debugging FEM codes. This thought experiment [@problem_id:3206774] challenges you to predict the consequences of a specific, realistic bug in this mapping, reinforcing your understanding of the deep connection between mesh connectivity and the final matrix structure.", "problem": "Consider the assembly of the global stiffness matrix $K$ for the linear elliptic model problem $-\\nabla \\cdot (\\kappa \\nabla u) = f$ on a bounded domain, using the Finite Element Method (FEM) with conforming elements. The global matrix $K$ is formed by summing contributions of element stiffness matrices $k^{e}$ according to a local-to-global mapping that associates each elementâ€™s local degrees of freedom to global indices. Assume each $k^{e}$ is symmetric positive semidefinite, and no boundary conditions have yet been applied to $K$.\n\nSuppose that, due to a programming bug, the local-to-global mapping routine consistently swaps the two global indices $p$ and $q$ everywhere they occur in the mesh. That is, whenever the correct mapping would return the global index $p$, the buggy version returns $q$, and whenever it would return $q$, it returns $p$. All other indices are returned correctly. How would this bug manifest in the assembled matrix $K$, compared to the correctly assembled matrix $K_{\\mathrm{true}}$?\n\nChoose the best description.\n\nA. $K$ becomes nonsymmetric because only the rows $p$ and $q$ are permuted while the corresponding columns remain unaltered.\n\nB. $K$ equals $P K_{\\mathrm{true}} P^{\\top}$, where $P$ is the permutation matrix that swaps indices $p$ and $q$; thus $K$ remains symmetric, its eigenvalues match those of $K_{\\mathrm{true}}$, and the sparsity pattern is identical except that rows and columns $p$ and $q$ are exchanged.\n\nC. Only the diagonal entries $K_{pp}$ and $K_{qq}$ are swapped; all off-diagonal entries remain the same as in $K_{\\mathrm{true}}$.\n\nD. All entries in row and column $p$ of $K$ become zero, while entries in row and column $q$ are doubled relative to $K_{\\mathrm{true}}$.", "solution": "The user wants me to analyze the effect of a specific programming bug on the assembly of a global stiffness matrix in the Finite Element Method (FEM).\n\n### Step 1: Extract Givens\n- **Problem Type**: Linear elliptic model problem $-\\nabla \\cdot (\\kappa \\nabla u) = f$ on a bounded domain.\n- **Numerical Method**: Finite Element Method (FEM) with conforming elements.\n- **Matrix Assembly**: The global stiffness matrix $K$ is assembled by summing element stiffness matrices $k^{e}$.\n- **Mapping**: A local-to-global mapping associates local degrees of freedom to global indices.\n- **Element Matrices**: Each element stiffness matrix $k^{e}$ is symmetric positive semidefinite.\n- **Boundary Conditions**: No boundary conditions have been applied to the global matrix $K$.\n- **The Bug**: A programming error in the local-to-global mapping routine consistently swaps two global indices, $p$ and $q$.\n- **Bug Behavior**:\n    - If the correct mapping for a local degree of freedom is the global index $p$, the buggy routine returns $q$.\n    - If the correct mapping is $q$, the buggy routine returns $p$.\n    - All other global indices are mapped correctly.\n- **Question**: Describe the relationship between the incorrectly assembled matrix, $K$, and the correctly assembled matrix, $K_{\\mathrm{true}}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is scientifically and mathematically sound. It describes a standard procedure in computational engineering (FEM assembly) and postulates a realistic programming error.\n\n- **Scientific Grounding**: The problem is based on the well-established Finite Element Method for solving partial differential equations. The concepts of element matrices, global matrices, and local-to-global mapping are fundamental to FEM. The assumption that element matrices $k^{e}$ are symmetric and positive semidefinite for the given elliptic problem is correct. The resulting global matrix $K$ (before applying boundary conditions) is also symmetric and positive semidefinite. No scientific principles are violated.\n- **Well-Posed**: The effect of the described algorithmic error is deterministic. Given a correct matrix $K_{\\mathrm{true}}$, the bug produces a unique, well-defined matrix $K$. The question asks for a description of this relationship, which is a well-posed mathematical problem.\n- **Objectivity**: The language is precise and technical. The description of the bug is unambiguous.\n- **Completeness**: The problem provides all necessary information to determine the structure of the resulting matrix $K$ in relation to $K_{\\mathrm{true}}$.\n- **No other flaws detected**: The problem is not trivial, unrealistic, or contradictory.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. The solution process will now proceed.\n\n### Derivation\nThe assembly of the global stiffness matrix $K$ is fundamentally an additive process where entries from local element matrices $k^e$ are added into the appropriate locations in $K$. The location is determined by a local-to-global index mapping function, let's call it $\\text{map}(e, \\alpha)$, which returns the global index for the $\\alpha$-th local degree of freedom of element $e$.\n\nThe entry $(I, J)$ of the correctly assembled global stiffness matrix, $K_{\\mathrm{true}}$, is given by the sum of all contributions from element matrices:\n$$ (K_{\\mathrm{true}})_{IJ} = \\sum_{e} \\sum_{\\alpha, \\beta} (k^e)_{\\alpha\\beta} \\, \\delta_{I, \\text{map}_{\\mathrm{true}}(e, \\alpha)} \\, \\delta_{J, \\text{map}_{\\mathrm{true}}(e, \\beta)} $$\nwhere $(k^e)_{\\alpha\\beta}$ is the entry of the local stiffness matrix for element $e$, $\\text{map}_{\\mathrm{true}}$ is the correct mapping function, and $\\delta_{ij}$ is the Kronecker delta.\n\nSince each $k^e$ is symmetric, i.e., $(k^e)_{\\alpha\\beta} = (k^e)_{\\beta\\alpha}$, the resulting matrix $K_{\\mathrm{true}}$ is also symmetric, i.e., $(K_{\\mathrm{true}})_{IJ} = (K_{\\mathrm{true}})_{JI}$.\n\nThe bug introduces an erroneous mapping function, $\\text{map}_{\\mathrm{bug}}$, which swaps the global indices $p$ and $q$. Let $\\pi$ be the permutation operator that swaps $p$ and $q$ and leaves all other indices unchanged:\n$$ \\pi(i) = \\begin{cases} q & \\text{if } i = p \\\\ p & \\text{if } i = q \\\\ i & \\text{otherwise} \\end{cases} $$\nThe buggy mapping can be expressed as $\\text{map}_{\\mathrm{bug}}(e, \\alpha) = \\pi(\\text{map}_{\\mathrm{true}}(e, \\alpha))$.\n\nThe incorrectly assembled matrix, $K$, is therefore constructed as:\n$$ K_{IJ} = \\sum_{e} \\sum_{\\alpha, \\beta} (k^e)_{\\alpha\\beta} \\, \\delta_{I, \\text{map}_{\\mathrm{bug}}(e, \\alpha)} \\, \\delta_{J, \\text{map}_{\\mathrm{bug}}(e, \\beta)} $$\nSubstituting the expression for the buggy map:\n$$ K_{IJ} = \\sum_{e} \\sum_{\\alpha, \\beta} (k^e)_{\\alpha\\beta} \\, \\delta_{I, \\pi(\\text{map}_{\\mathrm{true}}(e, \\alpha))} \\, \\delta_{J, \\pi(\\text{map}_{\\mathrm{true}}(e, \\beta))} $$\nLet's analyze an arbitrary entry $K_{IJ}$ of the buggy matrix. Let $I' = \\pi^{-1}(I)$ and $J' = \\pi^{-1}(J)$. Since $\\pi$ is its own inverse ($\\pi(\\pi(i)) = i$), we have $\\pi^{-1} = \\pi$. Thus, $I' = \\pi(I)$ and $J' = \\pi(J)$.\nThe Kronecker delta has the property $\\delta_{a, \\pi(b)} = \\delta_{\\pi^{-1}(a), b} = \\delta_{\\pi(a), b}$. Applying this, we get:\n$$ K_{IJ} = \\sum_{e} \\sum_{\\alpha, \\beta} (k^e)_{\\alpha\\beta} \\, \\delta_{\\pi(I), \\text{map}_{\\mathrm{true}}(e, \\alpha)} \\, \\delta_{\\pi(J), \\text{map}_{\\mathrm{true}}(e, \\beta)} $$\nComparing this to the formula for $K_{\\mathrm{true}}$, we see that this is precisely the entry $(\\pi(I), \\pi(J))$ of the true matrix:\n$$ K_{IJ} = (K_{\\mathrm{true}})_{\\pi(I), \\pi(J)} $$\nThis relationship means that the buggy matrix $K$ is obtained from the true matrix $K_{\\mathrm{true}}$ by permuting its rows and columns according to $\\pi$. Specifically, row $i$ of $K$ is row $\\pi(i)$ of $K_{\\mathrm{true}}$, and column $j$ of $K$ is column $\\pi(j)$ of $K_{\\mathrm{true}}$. For example, row $p$ of $K$ is row $q$ of $K_{\\mathrm{true}}$, and column $p$ of $K$ is column $q$ of $K_{\\mathrm{true}}$.\n\nIn matrix notation, this operation corresponds to a similarity transformation. Let $P$ be the permutation matrix associated with $\\pi$. A permutation matrix is orthogonal, so $P^{-1} = P^{\\top}$. The transformation is given by:\n$$ K = P^{\\top} K_{\\mathrm{true}} P $$\nor equivalently (since $P$ for a swap is symmetric, $P=P^\\top$):\n$$ K = P K_{\\mathrm{true}} P $$\nWait, the convention for a similarity transformation that results in $A'_{ij} = A_{\\pi(i)\\pi(j)}$ is $A' = P A P^\\top$, where $P_{ij} = \\delta_{i, \\pi(j)}$. Let's re-verify. Let $K' = P K_{\\mathrm{true}} P^{\\top}$.\n$ (K')_{ij} = \\sum_r \\sum_s P_{ir} (K_{\\mathrm{true}})_{rs} (P^{\\top})_{sj} $.\n$P_{ir} = \\delta_{i, \\pi(r)}$, so $r=\\pi^{-1}(i)$.\n$(P^{\\top})_{sj} = P_{js} = \\delta_{j, \\pi(s)}$, so $s=\\pi^{-1}(j)$.\nThen $(K')_{ij} = (K_{\\mathrm{true}})_{\\pi^{-1}(i), \\pi^{-1}(j)}$.\nMy initial derivation gave $K_{IJ} = (K_{\\mathrm{true}})_{\\pi(I), \\pi(J)}$. Let's re-check the definition of the matrix transformation.\nIf we relabel the basis vectors as $e'_i = e_{\\pi(i)}$, the new matrix representation $A'$ is related to the old one $A$ by $A'_{ij} = A_{\\pi(i),\\pi(j)}$. This corresponds to conjugation $A' = P^{-1}AP$ where $(Pe_i) = e_{\\pi(i)}$.\nLet's stick to the concrete formula $K_{IJ} = (K_{\\mathrm{true}})_{\\pi(I), \\pi(J)}$.\nLet's check the relation $K = P K_{\\mathrm{true}} P^{\\top}$ where $P$ is the permutation matrix that swaps rows/columns $p$ and $q$. This matrix acts on a vector $v$ as $(Pv)_i = v_{\\pi(i)}$.\nThen $(P K_{\\mathrm{true}})_{ij} = (K_{\\mathrm{true}})_{\\pi(i), j}$.\nThen $( (P K_{\\mathrm{true}}) P^{\\top} )_{ij} = \\sum_k (P K_{\\mathrm{true}})_{ik} (P^{\\top})_{kj} = \\sum_k (K_{\\mathrm{true}})_{\\pi(i), k} P_{jk}$. The only non-zero term is when $k=\\pi(j)$, so this is $(K_{\\mathrm{true}})_{\\pi(i), \\pi(j)}$.\nThis confirms that $K_{ij} = (K_{\\mathrm{true}})_{\\pi(i), \\pi(j)}$ is equivalent to $K = P K_{\\mathrm{true}} P^{\\top}$. Note that for a swap permutation, $P=P^\\top$, so this is also $K = P K_{\\mathrm{true}} P$.\n\nProperties of this transformation:\n1.  **Symmetry**: If $K_{\\mathrm{true}}$ is symmetric, then $K_{\\mathrm{true}}^{\\top} = K_{\\mathrm{true}}$. The transformed matrix is $K^{\\top} = (P K_{\\mathrm{true}} P^{\\top})^{\\top} = (P^{\\top})^{\\top} K_{\\mathrm{true}}^{\\top} P^{\\top} = P K_{\\mathrm{true}} P^{\\top} = K$. Thus, $K$ remains symmetric. This makes sense, as the bug is applied symmetrically to both row and column indices during assembly.\n2.  **Eigenvalues**: $K$ and $K_{\\mathrm{true}}$ are related by a similarity transformation, since $P$ is an orthogonal matrix ($P^{\\top} = P^{-1}$). Similarity transformations preserve eigenvalues.\n3.  **Sparsity**: The transformation simply permutes the rows and columns. Row $p$ of $K_{\\mathrm{true}}$ is moved to row $q$ of $K$, row $q$ to row $p$, and similarly for columns. The set of non-zero entries is permuted, but the overall number and pattern (up to this re-indexing) is identical.\n\n### Option-by-Option Analysis\n\n**A. $K$ becomes nonsymmetric because only the rows $p$ and $q$ are permuted while the corresponding columns remain unaltered.**\nThis is incorrect. The local-to-global mapping is used for both the row and column indices of the global matrix entry to which an element contribution is added. A bug in this mapping affects both symmetrically. As derived above, the resulting matrix $K$ is symmetric if $K_{\\mathrm{true}}$ is symmetric. An operation that only permutes rows would result in $K = P K_{\\mathrm{true}}$, which is not in general symmetric.\n**Verdict: Incorrect.**\n\n**B. $K$ equals $P K_{\\mathrm{true}} P^{\\top}$, where $P$ is the permutation matrix that swaps indices $p$ and $q$; thus $K$ remains symmetric, its eigenvalues match those of $K_{\\mathrm{true}}$, and the sparsity pattern is identical except that rows and columns $p$ and $q$ are exchanged.**\nThis statement accurately describes the consequences of the bug. The transformation is a similarity transformation $K = P K_{\\mathrm{true}} P^{\\top}$ (or $P K_{\\mathrm{true}} P$ since $P=P^\\top$ for a swap). As established in the derivation, such a transformation preserves symmetry and eigenvalues. The description of the effect on the matrix (\"sparsity pattern is identical except that rows and columns $p$ and $q$ are exchanged\") is a correct qualitative description of this permutation.\n**Verdict: Correct.**\n\n**C. Only the diagonal entries $K_{pp}$ and $K_{qq}$ are swapped; all off-diagonal entries remain the same as in $K_{\\mathrm{true}}$.**\nThis is incorrect. From the relation $K_{IJ} = (K_{\\mathrm{true}})_{\\pi(I), \\pi(J)}$, we can check various entries:\n- $K_{pp} = (K_{\\mathrm{true}})_{\\pi(p), \\pi(p)} = (K_{\\mathrm{true}})_{qq}$. (Diagonal entry swapped)\n- $K_{qq} = (K_{\\mathrm{true}})_{\\pi(q), \\pi(q)} = (K_{\\mathrm{true}})_{pp}$. (Diagonal entry swapped)\n- For an index $i \\ne p, q$, the entry $K_{pi}$ is given by $K_{pi} = (K_{\\mathrm{true}})_{\\pi(p), \\pi(i)} = (K_{\\mathrm{true}})_{qi}$. This is not, in general, equal to $(K_{\\mathrm{true}})_{pi}$. Thus, off-diagonal entries are also changed. Specifically, the entire row $p$ of $K$ is a permutation of row $q$ of $K_{\\mathrm{true}}$, and vice versa.\n**Verdict: Incorrect.**\n\n**D. All entries in row and column $p$ of $K$ become zero, while entries in row and column $q$ are doubled relative to $K_{\\mathrm{true}}$.**\nThis is physically and algorithmically unfounded. The bug does not eliminate or duplicate contributions; it reroutes them. Any contribution that should have gone to an entry involving index $p$ in $K_{\\mathrm{true}}$ is redirected to an entry involving index $q$ in $K$. Conversely, contributions for index $q$ in $K_{\\mathrm{true}}$ are sent to index $p$ in $K$. No entries become zero or are doubled unless they were already zero or the matrix had a very specific, coincidental structure.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{B}$$", "id": "3206774"}, {"introduction": "Now we transition from conceptual understanding to practical implementation. This exercise [@problem_id:3206698] guides you through building a stiffness matrix for a 1D problem from first principles. By tackling periodic boundary conditions, you will move beyond the simplest cases and learn how to enforce constraints that identify different degrees of freedom, a common requirement in modeling periodic physical systems.", "problem": "Implement from first principles the global assembly of the stiffness matrix for a one-dimensional second-order diffusion operator with periodic boundary conditions, using linear Lagrange basis functions on a given mesh. The goal is to assemble the reduced global stiffness matrix that enforces the periodic identification $u(x_1) = u(x_N)$, where $x_1$ and $x_N$ are the first and last mesh nodes. Work entirely in the setting of the Finite Element Method (FEM), and base your derivation on the standard bilinear form for the diffusion operator. Do not use any pre-derived element matrix formulas; derive everything from the core definitions.\n\nYou are given a mesh of $N$ nodes with coordinates $x_1 < x_2 < \\dots < x_N$, covering an interval $[x_1,x_N]$. Let the diffusion coefficient be the function $a(x) > 0$, which on each element is to be treated as constant and equal to its elementwise prescribed value. The weak form yields the bilinear form\n$$\nB(u,v) = \\int_{x_1}^{x_N} a(x)\\, \\frac{du}{dx}\\, \\frac{dv}{dx}\\, dx.\n$$\nFor assembly with linear Lagrange basis functions $\\{\\phi_i\\}_{i=1}^N$, the stiffness matrix entries are defined by\n$$\nK_{ij} = \\sum_{e=1}^{N-1} \\int_{x_e}^{x_{e+1}} a(x)\\, \\frac{d\\phi_i}{dx}\\, \\frac{d\\phi_j}{dx}\\, dx,\n$$\nwhere $[x_e,x_{e+1}]$ denotes element $e$. On each element, use the standard hat functions restricted to that element, and recall that for linear basis functions the derivatives $\\frac{d\\phi}{dx}$ are constant on the element and vanish outside it. Use only these definitions and elementary calculus to derive the local contributions and assemble the global matrix.\n\nTo enforce the periodic identification $u(x_N)=u(x_1)$, you must eliminate the redundant degree of freedom corresponding to node $N$ by substituting $u_N=u_1$ at the algebraic (bilinear form) level so that the resulting reduced stiffness matrix has size $(N-1)\\times(N-1)$. Concretely, if the fully assembled matrix before elimination is written in block form as\n$$\nK = \\begin{bmatrix}\nA & b \\\\\nb^\\mathsf{T} & c\n\\end{bmatrix},\n$$\nwhere $A \\in \\mathbb{R}^{(N-1)\\times(N-1)}$, $b \\in \\mathbb{R}^{N-1}$, $c \\in \\mathbb{R}$, and the last row and column correspond to node $N$, then the reduced periodic matrix corresponding to the substitution $u_N=u_1$ must be assembled consistently with the energy $u^\\mathsf{T} K u$ under this constraint. Your implementation must carry out this reduction explicitly after assembling $K$.\n\nInput specification for each test case:\n- A list of node positions $\\{x_i\\}_{i=1}^N$ with strictly increasing entries (these are real numbers).\n- Either a single constant coefficient $a$ to be used on every element, or an elementwise list $\\{a_e\\}_{e=1}^{N-1}$ of positive real numbers, where $a_e$ is the constant value of $a(x)$ on element $e$.\n\nOutput specification:\n- For each test case, your program must produce the reduced periodic stiffness matrix of size $(N-1)\\times(N-1)$, flattened in row-major order into a list of floating-point numbers.\n- Round every floating-point number to $10$ decimal places.\n- Aggregate the flattened lists for all test cases into a single line of output containing a comma-separated list of lists enclosed in square brackets, with no spaces. For example, if there are two test cases, the output should look like $[[m_{11},\\dots],[n_{11},\\dots]]$ with all numbers rounded as required.\n\nAngle units do not apply. No physical units are required for this purely mathematical formulation.\n\nTest suite to implement and evaluate:\n- Test 1 (uniform mesh, constant coefficient):\n  - Nodes: $[0.0, 0.25, 0.5, 0.75, 1.0]$.\n  - Coefficient: constant $a=1.0$.\n- Test 2 (nonuniform mesh, elementwise coefficient):\n  - Nodes: $[0.0, 0.1, 0.4, 1.0]$.\n  - Elementwise coefficients: $[2.0, 1.0, 3.0]$.\n- Test 3 (uniform mesh, constant coefficient, small system):\n  - Nodes: $[0.0, 0.5, 1.0]$.\n  - Coefficient: constant $a=2.0$.\n- Test 4 (degenerate edge case under periodic identification):\n  - Nodes: $[0.0, 1.0]$.\n  - Coefficient: constant $a=1.0$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, where each element is itself a comma-separated list enclosed in square brackets representing the flattened reduced stiffness matrix for the corresponding test case. For example: $[[r_{1,1},\\dots,r_{1,M_1}], [r_{2,1},\\dots,r_{2,M_2}], [r_{3,1},\\dots,r_{3,M_3}], [r_{4,1},\\dots,r_{4,M_4}]]$, where $M_k=(N_k-1)^2$ for test case $k$.", "solution": "The problem requires the implementation of an assembly procedure for the reduced global stiffness matrix for a one-dimensional diffusion problem under periodic boundary conditions. The method is the Finite Element Method (FEM) using linear Lagrange basis functions. The solution will be derived from first principles as specified.\n\n### 1. Framework and Bilinear Form\n\nWe are given a one-dimensional domain defined by a mesh of $N$ nodes, $x_1 < x_2 < \\dots < x_N$. The governing physics is a diffusion process, whose weak form is given by the bilinear form $B(u,v)$:\n$$\nB(u,v) = \\int_{x_1}^{x_N} a(x)\\, \\frac{du}{dx}\\, \\frac{dv}{dx}\\, dx\n$$\nHere, $u$ is the trial function and $v$ is the test function. The diffusion coefficient $a(x)$ is positive and assumed to be piecewise constant on each element of the mesh.\n\nIn the FEM, we approximate the solution $u(x)$ as a linear combination of basis functions $\\phi_j(x)$:\n$$\nu(x) \\approx u_h(x) = \\sum_{j=1}^{N} u_j \\phi_j(x)\n$$\nwhere $u_j$ are the unknown nodal values (degrees of freedom) and $\\phi_j(x)$ are the linear Lagrange (hat) basis functions. The hat function $\\phi_j(x)$ is equal to $1$ at node $x_j$ and $0$ at all other nodes $x_k$ ($k \\neq j$).\n\nSubstituting this expansion into the bilinear form with $v = \\phi_i(x)$ for each $i \\in \\{1, \\dots, N\\}$ yields the algebraic system $K\\mathbf{u} = \\mathbf{f}$, where the entries of the global stiffness matrix $K$ are given by:\n$$\nK_{ij} = B(\\phi_j, \\phi_i) = \\int_{x_1}^{x_N} a(x)\\, \\frac{d\\phi_i}{dx}\\, \\frac{d\\phi_j}{dx}\\, dx\n$$\nThe integral can be computed as a sum over the $N-1$ elements of the mesh:\n$$\nK_{ij} = \\sum_{e=1}^{N-1} \\int_{x_e}^{x_{e+1}} a_e\\, \\frac{d\\phi_i}{dx}\\, \\frac{d\\phi_j}{dx}\\, dx\n$$\nwhere $a_e$ is the constant value of $a(x)$ on the element $e = [x_e, x_{e+1}]$.\n\n### 2. Derivation of the Element Stiffness Matrix\n\nThe integral for $K_{ij}$ is non-zero only if the supports of the derivatives of $\\phi_i$ and $\\phi_j$ overlap. For linear hat functions, the support of $\\phi_i$ is $[x_{i-1}, x_{i+1}]$. This means we only need to consider local contributions on each element.\n\nLet's consider a generic element $e$ spanning the interval $[x_e, x_{e+1}]$. The length of this element is $h_e = x_{e+1} - x_e$. On this element, only two global basis functions are non-zero: $\\phi_e(x)$ and $\\phi_{e+1}(x)$. Let's denote their restrictions to element $e$ as local basis functions $\\hat{\\phi}_1^{(e)}(x)$ and $\\hat{\\phi}_2^{(e)}(x)$, respectively.\n$$\n\\hat{\\phi}_1^{(e)}(x) = \\frac{x_{e+1} - x}{x_{e+1} - x_e} \\quad (\\text{corresponds to } \\phi_e)\n$$\n$$\n\\hat{\\phi}_2^{(e)}(x) = \\frac{x - x_e}{x_{e+1} - x_e} \\quad (\\text{corresponds to } \\phi_{e+1})\n$$\nTheir derivatives on this element are constant:\n$$\n\\frac{d\\hat{\\phi}_1^{(e)}}{dx} = -\\frac{1}{h_e} \\quad \\text{and} \\quad \\frac{d\\hat{\\phi}_2^{(e)}}{dx} = \\frac{1}{h_e}\n$$\nThe $2 \\times 2$ element stiffness matrix $K^{(e)}$ for element $e$ has entries $K_{ij}^{(e)} = \\int_{x_e}^{x_{e+1}} a_e \\frac{d\\hat{\\phi}_i^{(e)}}{dx} \\frac{d\\hat{\\phi}_j^{(e)}}{dx} dx$.\n\n- $K_{11}^{(e)} = \\int_{x_e}^{x_{e+1}} a_e \\left(-\\frac{1}{h_e}\\right)\\left(-\\frac{1}{h_e}\\right) dx = \\frac{a_e}{h_e^2} \\int_{x_e}^{x_{e+1}} dx = \\frac{a_e}{h_e^2} (h_e) = \\frac{a_e}{h_e}$.\n- $K_{12}^{(e)} = \\int_{x_e}^{x_{e+1}} a_e \\left(-\\frac{1}{h_e}\\right)\\left(\\frac{1}{h_e}\\right) dx = -\\frac{a_e}{h_e^2} \\int_{x_e}^{x_{e+1}} dx = -\\frac{a_e}{h_e}$.\n- $K_{21}^{(e)} = \\int_{x_e}^{x_{e+1}} a_e \\left(\\frac{1}{h_e}\\right)\\left(-\\frac{1}{h_e}\\right) dx = -\\frac{a_e}{h_e^2} \\int_{x_e}^{x_{e+1}} dx = -\\frac{a_e}{h_e}$.\n- $K_{22}^{(e)} = \\int_{x_e}^{x_{e+1}} a_e \\left(\\frac{1}{h_e}\\right)\\left(\\frac{1}{h_e}\\right) dx = \\frac{a_e}{h_e^2} \\int_{x_e}^{x_{e+1}} dx = \\frac{a_e}{h_e}$.\n\nThus, the element stiffness matrix is:\n$$\nK^{(e)} = \\frac{a_e}{h_e}\n\\begin{bmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{bmatrix}\n$$\n\n### 3. Assembly of the Full Global Stiffness Matrix\n\nThe $N \\times N$ global stiffness matrix $K$ is constructed by initializing it to zero and then summing the contributions from all $N-1$ elements. For an element $e$ connecting nodes $e$ and $e+1$, its local matrix $K^{(e)}$ is added to the corresponding entries in the global matrix.\nLetting $c_e = a_e/h_e$, the contributions are:\n- $K_{e,e} \\leftarrow K_{e,e} + c_e$\n- $K_{e,e+1} \\leftarrow K_{e,e+1} - c_e$\n- $K_{e+1,e} \\leftarrow K_{e+1,e} - c_e$\n- $K_{e+1,e+1} \\leftarrow K_{e+1,e+1} + c_e$\n\nThis process results in a symmetric, tridiagonal matrix $K$ of size $N \\times N$. Its non-zero entries are:\n- $K_{i,i} = c_{i-1} + c_i$ for $i=2, \\dots, N-1$\n- $K_{1,1} = c_1$\n- $K_{N,N} = c_{N-1}$\n- $K_{i,i+1} = K_{i+1,i} = -c_i$ for $i=1, \\dots, N-1$\n\n### 4. Enforcing Periodic Boundary Conditions\n\nThe periodic boundary condition is $u(x_1) = u(x_N)$, which at the algebraic level translates to the constraint $u_1 = u_N$. This means the degree of freedom at node $N$ is not independent; it is identified with the degree of freedom at node $1$. We can therefore eliminate $u_N$ from the system, reducing the number of unknowns from $N$ to $N-1$.\n\nThe problem specifies an algebraic procedure for this reduction. We partition the full stiffness matrix $K$ and the vector of unknowns $\\mathbf{u}$ as follows:\n$$\nK = \\begin{bmatrix}\nA & b \\\\\nb^\\mathsf{T} & c\n\\end{bmatrix}, \\quad\n\\mathbf{u} = \\begin{bmatrix}\n\\mathbf{u}' \\\\\nu_N\n\\end{bmatrix}\n$$\nwhere $A$ is an $(N-1) \\times (N-1)$ matrix, $b$ is a vector of length $N-1$, $c$ is a scalar, and $\\mathbf{u}' = [u_1, u_2, \\dots, u_{N-1}]^\\mathsf{T}$.\n\nThe quadratic form representing the system's energy is $\\frac{1}{2}\\mathbf{u}^\\mathsf{T}K\\mathbf{u}$. Substituting the partitioned forms gives:\n$$\n\\frac{1}{2} \\left( (\\mathbf{u}')^\\mathsf{T}A\\mathbf{u}' + 2(\\mathbf{u}')^\\mathsf{T}b u_N + c u_N^2 \\right)\n$$\nNow, we enforce the constraint $u_N=u_1$. The unknown $u_1$ is the first component of $\\mathbf{u}'$. Using the vector $e_1 = [1, 0, \\dots, 0]^\\mathsf{T} \\in \\mathbb{R}^{N-1}$, we have $u_1 = e_1^\\mathsf{T}\\mathbf{u}'$. Substituting $u_N = e_1^\\mathsf{T}\\mathbf{u}'$ into the energy expression, a new quadratic form $\\frac{1}{2}(\\mathbf{u}')^\\mathsf{T}K_{red}\\mathbf{u}'$ is obtained, where $K_{red}$ is the desired $(N-1)\\times(N-1)$ reduced matrix.\n\nThe terms related to $u_N$ modify the original matrix $A$:\n- The term $2(\\mathbf{u}')^\\mathsf{T}b u_N$ becomes $2(\\mathbf{u}')^\\mathsf{T}b (e_1^\\mathsf{T}\\mathbf{u}') = (\\mathbf{u}')^\\mathsf{T}(b e_1^\\mathsf{T} + e_1 b^\\mathsf{T})\\mathbf{u}'$.\n- The term $c u_N^2$ becomes $c(e_1^\\mathsf{T}\\mathbf{u}')^2 = (\\mathbf{u}')^\\mathsf{T}(c e_1 e_1^\\mathsf{T})\\mathbf{u}'$.\n\nCombining these modifications, the reduced stiffness matrix $K_{red}$ is given by:\n$$\nK_{red} = A + b e_1^\\mathsf{T} + e_1 b^\\mathsf{T} + c e_1 e_1^\\mathsf{T}\n$$\nThis matrix operation translates to the following modifications to the submatrix $A$:\n1. Add the vector $b$ (the first $N-1$ elements of the last column of $K$) to the first column of $A$. So, $(K_{red})_{i,1} = A_{i,1} + b_i = K_{i,1} + K_{i,N}$ for $i=1,\\dots,N-1$.\n2. Add the vector $b^\\mathsf{T}$ (the first $N-1$ elements of the last row of $K$) to the first row of $A$. So, $(K_{red})_{1,j} = A_{1,j} + b_j = K_{1,j} + K_{j,N}$ for $j=1,\\dots,N-1$.\n3. Add the scalar $c$ (the element $K_{N,N}$) to the $(1,1)$ entry.\nSince $K$ is tridiagonal, $b_i = K_{i,N}$ is non-zero only for $i=N-1$. The update simplifies to:\n- $(K_{red})_{1,1}$ becomes $K_{1,1} + K_{N,N}$.\n- $(K_{red})_{1,N-1}$ becomes $K_{1,N-1} + K_{N-1,N}$.\n- $(K_{red})_{N-1,1}$ becomes $K_{N-1,1} + K_{N,N-1}$.\n- All other entries are unchanged from $A$.\n\nThis algebraic procedure is equivalent to assembling the matrix on a periodic domain from the start, where an additional element connects node $N$ to node $1$, thereby validating the prescribed method.\n\nThe implementation will follow this procedure: first, assemble the $N \\times N$ matrix $K$ for a line mesh, then apply the algebraic reduction to obtain the $(N-1) \\times (N-1)$ periodic stiffness matrix $K_{red}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_and_reduce(nodes: list[float], coeffs: list[float] | float) -> list[float]:\n    \"\"\"\n    Assembles the reduced stiffness matrix for a 1D diffusion problem with periodic BCs.\n\n    Args:\n        nodes: A list of N node coordinates, strictly increasing.\n        coeffs: A single coefficient 'a' for all elements, or a list of N-1\n                elementwise coefficients.\n\n    Returns:\n        The (N-1)x(N-1) reduced stiffness matrix, flattened in row-major order\n        and rounded to 10 decimal places.\n    \"\"\"\n    N = len(nodes)\n\n    if N < 2:\n        # A problem with < 2 nodes has no elements and an empty reduced matrix.\n        return []\n\n    num_elements = N - 1\n    element_coeffs = []\n    if isinstance(coeffs, (int, float)):\n        element_coeffs = [float(coeffs)] * num_elements\n    else:\n        element_coeffs = [float(c) for c in coeffs]\n\n    # Step 1: Assemble the full NxN global stiffness matrix (for Neumann BCs)\n    K_full = np.zeros((N, N), dtype=np.float64)\n\n    for e in range(num_elements):\n        # Node indices for element e are e and e+1 (0-based)\n        node_i, node_j = e, e + 1\n        \n        # Calculate element length h_e\n        h_e = nodes[node_j] - nodes[node_i]\n        \n        # Get diffusion coefficient a_e\n        a_e = element_coeffs[e]\n\n        # Calculate the derived constant c_e = a_e / h_e\n        c_e = a_e / h_e\n\n        # The element stiffness matrix is c_e * [[1, -1], [-1, 1]]\n        # Add its contributions to the global matrix\n        K_full[node_i, node_i] += c_e\n        K_full[node_i, node_j] -= c_e\n        K_full[node_j, node_i] -= c_e\n        K_full[node_j, node_j] += c_e\n        \n    # Step 2: Enforce periodic BC u_N = u_1 by algebraic reduction\n    if N == 2:\n        # Special case for N=2 gives a 1x1 reduced matrix.\n        # K_red[0,0] = K_11 + 2*K_12 + K_22\n        k_red_scalar = K_full[0, 0] + 2 * K_full[0, 1] + K_full[1, 1]\n        K_red = np.array([[k_red_scalar]], dtype=np.float64)\n    else:\n        # General case for N > 2\n        # Partition K_full into A, b, c\n        A = K_full[:N-1, :N-1]\n        b = K_full[:N-1, N-1]  # Last column (without corner)\n        c = K_full[N-1, N-1]   # Corner element\n\n        # Start with the upper-left (N-1)x(N-1) block\n        K_red = A.copy()\n        \n        # Apply the reduction formula derived from energy conservation:\n        # K_red = A + b*e1^T + e1*b^T + c*e1*e1^T\n        # This translates to modifying the first row and column of A\n        # and its top-left element.\n        \n        # Add b to the first column of K_red\n        K_red[:, 0] += b\n        # Add b^T to the first row of K_red\n        K_red[0, :] += b\n        # Add c to the top-left element\n        K_red[0, 0] += c\n    \n    # Step 3: Flatten and round the result\n    flattened_matrix = K_red.flatten()\n    rounded_matrix = np.round(flattened_matrix, 10).tolist()\n    \n    return rounded_matrix\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        { \"nodes\": [0.0, 0.25, 0.5, 0.75, 1.0], \"coeffs\": 1.0 },\n        { \"nodes\": [0.0, 0.1, 0.4, 1.0], \"coeffs\": [2.0, 1.0, 3.0] },\n        { \"nodes\": [0.0, 0.5, 1.0], \"coeffs\": 2.0 },\n        { \"nodes\": [0.0, 1.0], \"coeffs\": 1.0 }\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        coeffs = case[\"coeffs\"]\n        \n        # Calculate the flattened reduced matrix for the current case\n        result_list = assemble_and_reduce(nodes, coeffs)\n        \n        # Format the list of numbers into the required string format '[n1,n2,...]'\n        result_str = f\"[{','.join(map(str, result_list))}]\"\n        all_results_str.append(result_str)\n\n    # Final print statement in the exact required format '[[...],[...],...]'\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "3206698"}, {"introduction": "Real-world engineering problems are rarely one-dimensional. This practice [@problem_id:3206634] scales up our assembly procedure to three dimensions, the natural setting for modeling physical objects. You will implement assembly for a tetrahedral mesh, learning how to use affine maps and the Jacobian matrix to handle arbitrarily shaped elements by transforming calculations from a simple reference element.", "problem": "Consider the scalar diffusion Partial Differential Equation (PDE) $- \\nabla \\cdot (\\kappa \\nabla u) = f$ on a polyhedral domain $\\Omega \\subset \\mathbb{R}^3$ with Dirichlet boundary data $u = g$ on $\\partial \\Omega$. Using the standard Galerkin Finite Element Method (FEM) with first-order (piecewise linear) tetrahedral elements, assemble the global stiffness matrix. The assembly must follow from the weak form derived from the PDE, without using any shortcut formulas.\n\nStart from the weak formulation: find $u \\in H^1(\\Omega)$ such that $u = g$ on $\\partial \\Omega$ and\n$$\na(u,v) = \\ell(v) \\quad \\text{for all } v \\in H_0^1(\\Omega),\n$$\nwhere\n$$\na(u,v) = \\int_{\\Omega} \\kappa \\, \\nabla u \\cdot \\nabla v \\, \\mathrm{d}x, \\qquad \\ell(v) = \\int_{\\Omega} f \\, v \\, \\mathrm{d}x.\n$$\nDiscretize with $N$ nodes and $M$ tetrahedra. For each tetrahedron with vertices $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4 \\in \\mathbb{R}^3$, define the affine map from the reference tetrahedron with vertices $(0,0,0)$, $(1,0,0)$, $(0,1,0)$, $(0,0,1)$ via the Jacobian matrix\n$$\nJ = \\begin{bmatrix} \\mathbf{x}_2 - \\mathbf{x}_1 & \\mathbf{x}_3 - \\mathbf{x}_1 & \\mathbf{x}_4 - \\mathbf{x}_1 \\end{bmatrix} \\in \\mathbb{R}^{3 \\times 3}.\n$$\nLet $\\nabla \\hat{N}_1 = (-1,-1,-1)^\\top$, $\\nabla \\hat{N}_2 = (1,0,0)^\\top$, $\\nabla \\hat{N}_3 = (0,1,0)^\\top$, $\\nabla \\hat{N}_4 = (0,0,1)^\\top$ be the gradients of the reference shape functions. The physical gradients are\n$$\n\\nabla N_i = J^{-\\top} \\nabla \\hat{N}_i, \\quad i \\in \\{1,2,3,4\\},\n$$\nand the physical tetrahedron volume is\n$$\n|T| = \\frac{|\\det(J)|}{6}.\n$$\nUsing these, the element stiffness matrix entries are\n$$\nK_e(i,j) = \\kappa_e \\, |T| \\, \\nabla N_i \\cdot \\nabla N_j, \\quad i,j \\in \\{1,2,3,4\\},\n$$\nwhere $\\kappa_e$ is the constant diffusion coefficient on the tetrahedron. Assemble the global stiffness matrix $K \\in \\mathbb{R}^{N \\times N}$ by summing the contributions from all elements according to their connectivity.\n\nTo impose Dirichlet boundary conditions at a set of boundary nodes $G$ with prescribed values $\\{g_k\\}_{k \\in G}$, partition the index set of nodes into free nodes $F$ and boundary nodes $G$, and solve the reduced linear system obtained from the discrete weak form:\n$$\nK_{FF} \\, u_F = b_F - K_{FG} \\, u_G,\n$$\nwhere $b$ is the global load vector with entries $b_i = \\int_{\\Omega} f N_i \\, \\mathrm{d}x$. In this problem, use $f \\equiv 0$, so $b = 0$. The final interior solution on the free nodes is $u_F$, and the complete nodal field is obtained by combining $u_F$ with the prescribed $u_G$.\n\nImplement the described assembly and Dirichlet enforcement and produce specific quantitative outputs for the following test suite. Throughout, use the analytic function $u^\\star(x,y,z) = x + y + z$ to define Dirichlet data $g(\\mathbf{x}) = u^\\star(\\mathbf{x})$ at boundary nodes.\n\nTest suite:\n- Case $A$ (single tetrahedron):\n  - Nodes (indices $0$ to $3$): $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (1,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$.\n  - Elements: one tetrahedron with connectivity $[0,1,2,3]$.\n  - Element diffusion coefficient: $\\kappa = 2$.\n  - Dirichlet boundary nodes: $G = \\{0,1,2,3\\}$ with $u_G = \\{u^\\star(\\mathbf{x}_k)\\}_{k \\in G}$.\n  - Right-hand side: $f \\equiv 0$.\n  - Outputs to compute:\n    1. The Frobenius norm $\\|K\\|_F$ of the assembled global stiffness matrix $K$.\n    2. The maximum absolute error at free nodes, defined as $\\max_{i \\in F} |u_F(i) - u^\\star(\\mathbf{x}_i)|$. If $F$ is empty, define this value to be $0$.\n\n- Case $B$ (a tetrahedron subdivided by one interior node):\n  - Nodes (indices $0$ to $4$): $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (1,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$, $\\mathbf{x}_4 = (0.25,0.25,0.25)$.\n  - Elements: four tetrahedra with connectivity $[4,1,2,3]$, $[4,0,2,3]$, $[4,0,1,3]$, $[4,0,1,2]$.\n  - Element diffusion coefficient: $\\kappa = 1$ for each tetrahedron.\n  - Dirichlet boundary nodes: $G = \\{0,1,2,3\\}$ with $u_G = \\{u^\\star(\\mathbf{x}_k)\\}_{k \\in G}$; the interior node is $4$.\n  - Right-hand side: $f \\equiv 0$.\n  - Outputs to compute:\n    1. The Frobenius norm $\\|K\\|_F$ of the assembled global stiffness matrix $K$.\n    2. The maximum absolute error at the free nodes $F = \\{4\\}$, defined as $|u_F(4) - u^\\star(\\mathbf{x}_4)|$.\n\n- Case $C$ (a near-degenerate sliver tetrahedron):\n  - Nodes (indices $0$ to $3$): $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (10^{-6},0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$.\n  - Elements: one tetrahedron with connectivity $[0,1,2,3]$.\n  - Element diffusion coefficient: $\\kappa = 1$.\n  - Dirichlet boundary nodes: $G = \\{0,1,2,3\\}$ with $u_G = \\{u^\\star(\\mathbf{x}_k)\\}_{k \\in G}$.\n  - Right-hand side: $f \\equiv 0$.\n  - Outputs to compute:\n    1. The Frobenius norm $\\|K\\|_F$ of the assembled global stiffness matrix $K$.\n    2. The maximum absolute error at free nodes; since $F$ is empty, define this value to be $0$.\n\nYour program must implement the finite element assembly for $3$-dimensional tetrahedra as described, construct the global stiffness matrix, enforce Dirichlet boundary conditions via system partitioning, solve for interior nodal values when applicable, and compute for each case the pair of outputs described above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\|K\\|_F^{(A)}, \\mathrm{err}^{(A)}, \\|K\\|_F^{(B)}, \\mathrm{err}^{(B)}, \\|K\\|_F^{(C)}, \\mathrm{err}^{(C)}]$. No physical units are involved; all quantities are dimensionless real numbers. Angles are not used. The outputs are real-valued floats.", "solution": "The problem statement has been meticulously validated and is determined to be valid. It is scientifically grounded in the principles of the Finite Element Method (FEM) for solving partial differential equations, is well-posed with a complete and consistent set of data and definitions, and is expressed in objective, formal language. The provided formulas for the affine mapping, physical gradients, element volume, and element stiffness matrix are standard and correct for first-order (P1) tetrahedral elements. The test cases are well-defined and serve to verify the implementation against a reference element, a mesh with an interior node, and a geometrically degenerate element.\n\nThe task is to implement the assembly of the global stiffness matrix for the scalar diffusion equation, $- \\nabla \\cdot (\\kappa \\nabla u) = f$, discretized using the Finite Element Method with piecewise linear basis functions on a tetrahedral mesh. The assembled matrix is then used to solve for unknown nodal values after enforcing Dirichlet boundary conditions. The specific outputs required are the Frobenius norm of the global stiffness matrix and the maximum error at interior nodes for three distinct test cases.\n\nThe general procedure follows these steps:\n1.  Initialize an $N \\times N$ global stiffness matrix $K$ with all entries set to zero, where $N$ is the total number of nodes in the mesh.\n2.  Iterate through each tetrahedron (element) $T_e$ in the mesh. For each element:\n    a. Identify the global indices of its four vertices, $[n_1, n_2, n_3, n_4]$, from the element connectivity list.\n    b. Retrieve the coordinates of these vertices: $\\mathbf{x}_{n_1}, \\mathbf{x}_{n_2}, \\mathbf{x}_{n_3}, \\mathbf{x}_{n_4}$.\n    c. Form the Jacobian matrix $J_e$ of the affine map from the reference tetrahedron to the physical tetrahedron $T_e$. The problem defines this as $J_e = \\begin{bmatrix} \\mathbf{x}_{n_2} - \\mathbf{x}_{n_1} & \\mathbf{x}_{n_3} - \\mathbf{x}_{n_1} & \\mathbf{x}_{n_4} - \\mathbf{x}_{n_1} \\end{bmatrix}$.\n    d. Calculate the volume of the element, $|T_e| = \\frac{|\\det(J_e)|}{6}$.\n    e. Compute the inverse transpose of the Jacobian, $J_e^{-\\top}$.\n    f. Determine the gradients of the four physical basis functions, $\\nabla N_i$, by transforming the reference gradients, $\\nabla \\hat{N}_i$, using the relation $\\nabla N_i = J_e^{-\\top} \\nabla \\hat{N}_i$. The reference gradients are given as $\\nabla \\hat{N}_1 = (-1,-1,-1)^\\top$, $\\nabla \\hat{N}_2 = (1,0,0)^\\top$, $\\nabla \\hat{N}_3 = (0,1,0)^\\top$, and $\\nabla \\hat{N}_4 = (0,0,1)^\\top$.\n    g. Calculate the $4 \\times 4$ element stiffness matrix $K_e$, whose entries are given by $K_e(i,j) = \\kappa_e |T_e| (\\nabla N_i \\cdot \\nabla N_j)$, where $\\kappa_e$ is the constant diffusion coefficient on element $T_e$. In matrix form, this can be written as $K_e = \\kappa_e |T_e| G_e^\\top G_e$, where $G_e = \\begin{bmatrix} \\nabla N_1 & \\nabla N_2 & \\nabla N_3 & \\nabla N_4 \\end{bmatrix}$ is the $3 \\times 4$ matrix of physical basis function gradients.\n    h. Add the contributions of $K_e$ to the global stiffness matrix $K$. For each entry $K_e(i,j)$, its value is added to the global entry $K(n_i, n_j)$.\n3.  After iterating through all elements, calculate the Frobenius norm of the assembled global matrix $K$, $\\|K\\|_F = \\sqrt{\\sum_{i,j=1}^N |K_{ij}|^2}$.\n4.  To find the solution, partition the nodes into a set of free (interior) nodes $F$ and a set of Dirichlet boundary nodes $G$. The problem uses a source term $f \\equiv 0$, so the load vector is zero. The system to be solved for the free node values $u_F$ is $K_{FF} u_F = -K_{FG} u_G$, where $K_{FF}$ and $K_{FG}$ are submatrices of $K$, and $u_G$ is the vector of prescribed values at the boundary nodes. The prescribed values are derived from the analytic function $u^\\star(x,y,z) = x+y+z$.\n5.  After solving for $u_F$, compute the maximum absolute error at the free nodes: $\\max_{i \\in F} |u_F(i) - u^\\star(\\mathbf{x}_i)|$. If the set $F$ is empty, this error is defined to be $0$.\n\n**Case A: Single Reference Tetrahedron**\n-   Nodes: $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (1,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$. $N=4$.\n-   Connectivity: $[0,1,2,3]$.\n-   The Jacobian matrix is $J = [\\mathbf{x}_1-\\mathbf{x}_0 \\ \\ \\mathbf{x}_2-\\mathbf{x}_0 \\ \\ \\mathbf{x}_3-\\mathbf{x}_0] = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = I_3$.\n-   The element volume is $|T| = |\\det(I_3)|/6 = 1/6$.\n-   The physical gradients are identical to the reference gradients since $J^{-\\top} = I_3$.\n-   The element stiffness matrix is $K_e(i,j) = \\kappa_e |T| (\\nabla \\hat{N}_i \\cdot \\nabla \\hat{N}_j)$. With $\\kappa=2$ and $|T|=1/6$, this is $K_e(i,j) = \\frac{1}{3} (\\nabla \\hat{N}_i \\cdot \\nabla \\hat{N}_j)$.\n-   The matrix of dot products $(\\nabla \\hat{N}_i \\cdot \\nabla \\hat{N}_j)$ is $\\begin{pmatrix} 3 & -1 & -1 & -1 \\\\ -1 & 1 & 0 & 0 \\\\ -1 & 0 & 1 & 0 \\\\ -1 & 0 & 0 & 1 \\end{pmatrix}$.\n-   Thus, $K_e = \\frac{1}{3} \\begin{pmatrix} 3 & -1 & -1 & -1 \\\\ -1 & 1 & 0 & 0 \\\\ -1 & 0 & 1 & 0 \\\\ -1 & 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & -1/3 & -1/3 & -1/3 \\\\ -1/3 & 1/3 & 0 & 0 \\\\ -1/3 & 0 & 1/3 & 0 \\\\ -1/3 & 0 & 0 & 1/3 \\end{pmatrix}$.\n-   Since there is only one element, the global matrix $K$ is equal to $K_e$.\n-   The Frobenius norm is $\\|K\\|_F = \\sqrt{1^2 + 4 \\times (-1/3)^2 + 3 \\times (1/3)^2} = \\sqrt{1 + 4/9 + 3/9} = \\sqrt{16/9} = 4/3$.\n-   All nodes are Dirichlet nodes, so the set of free nodes $F$ is empty. The error is $0$.\n-   Results: $\\|K\\|_F = 4/3 \\approx 1.3333$, error $= 0.0$.\n\n**Case B: Subdivided Tetrahedron**\n-   The domain is the same reference tetrahedron as in Case A, but it is subdivided into four smaller tetrahedra by an interior node $\\mathbf{x}_4 = (0.25, 0.25, 0.25)$.\n-   There are $N=5$ nodes. Node $4$ is the only free node ($F=\\{4\\}$), while nodes $0, 1, 2, 3$ are Dirichlet nodes ($G=\\{0,1,2,3\\}$).\n-   The global stiffness matrix $K$ is a $5 \\times 5$ matrix, assembled from the contributions of the four elements. The calculation of each of the four element stiffness matrices and their summation into $K$ is performed computationally.\n-   The analytic solution for the PDE is $u^\\star(x,y,z) = x+y+z$. Since $u^\\star$ is a linear function, it is perfectly represented by the piecewise linear finite element basis. Therefore, the FEM solution must be exact, meaning the computed value at the interior node $u_4$ must equal the analytic value $u^\\star(\\mathbf{x}_4)$.\n-   $u^\\star(\\mathbf{x}_4) = 0.25 + 0.25 + 0.25 = 0.75$.\n-   The solution for $u_4$ is obtained from the single equation $K_{44}u_4 = -(K_{40}u_0 + K_{41}u_1 + K_{42}u_2 + K_{43}u_3)$. With $u_0=0, u_1=1, u_2=1, u_3=1$, this is $K_{44}u_4 = -(K_{41}+K_{42}+K_{43})$. Due to the barycentric subdivision and mesh symmetry, one can show that $K_{40} = K_{41} = K_{42} = K_{43}$, and also that the row sum is zero ($K_{40}+K_{41}+K_{42}+K_{43}+K_{44}=0$). These properties lead to $u_4 = 0.75$.\n-   Thus, the error is expected to be $0$ (within floating-point precision). The Frobenius norm $\\|K\\|_F$ is computed numerically.\n\n**Case C: Sliver Tetrahedron**\n-   Nodes: $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (\\epsilon,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$, with $\\epsilon=10^{-6}$.\n-   The Jacobian is a diagonal matrix $J = \\text{diag}(\\epsilon, 1, 1)$. Its determinant is $\\det(J) = \\epsilon$.\n-   The element volume is $|T| = |\\det(J)|/6 = \\epsilon/6$.\n-   The inverse transpose is $J^{-\\top} = \\text{diag}(1/\\epsilon, 1, 1)$.\n-   The physical gradients are scaled anisotropically. For instance, $\\nabla N_2 = J^{-\\top}(1,0,0)^\\top = (1/\\epsilon, 0, 0)^\\top$.\n-   With $\\kappa=1$, the element stiffness matrix is $K_e = \\frac{\\epsilon}{6} G_e^\\top G_e$, which evaluates to:\n$$ K = K_e = \\begin{pmatrix} \\frac{1}{6\\epsilon} + \\frac{\\epsilon}{3} & -\\frac{1}{6\\epsilon} & -\\frac{\\epsilon}{6} & -\\frac{\\epsilon}{6} \\\\ -\\frac{1}{6\\epsilon} & \\frac{1}{6\\epsilon} & 0 & 0 \\\\ -\\frac{\\epsilon}{6} & 0 & \\frac{\\epsilon}{6} & 0 \\\\ -\\frac{\\epsilon}{6} & 0 & 0 & \\frac{\\epsilon}{6} \\end{pmatrix} $$\n-   The squared Frobenius norm is $\\|K\\|_F^2 = \\sum_{i,j} K_{ij}^2 = \\frac{1}{9\\epsilon^2} + \\frac{1}{9} + \\frac{2\\epsilon^2}{9} = \\frac{1}{9}(\\frac{1}{\\epsilon^2} + 1 + 2\\epsilon^2)$.\n-   For $\\epsilon=10^{-6}$, $\\|K\\|_F = \\frac{1}{3}\\sqrt{10^{12} + 1 + 2 \\times 10^{-12}} \\approx 10^6/3$.\n-   As in Case A, all nodes are Dirichlet boundary nodes, so $F$ is empty and the error is $0$.\n-   Results: $\\|K\\|_F \\approx 333333.3333$, error $= 0.0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(nodes, elements, kappas, dirichlet_nodes):\n    \"\"\"\n    Assembles the global stiffness matrix and solves the FEM system for a given case.\n\n    Args:\n        nodes (list of tuples): Coordinates of the mesh nodes.\n        elements (list of lists): Connectivity of the mesh elements (tetrahedra).\n        kappas (list of floats): Diffusion coefficient for each element.\n        dirichlet_nodes (set): Set of global indices for nodes with Dirichlet BCs.\n\n    Returns:\n        tuple: A tuple containing (Frobenius norm of K, max absolute error at free nodes).\n    \"\"\"\n    num_nodes = len(nodes)\n    K = np.zeros((num_nodes, num_nodes))\n    node_coords = np.array(nodes)\n\n    # Gradients of the basis functions on the reference tetrahedron\n    grad_N_hat = np.array([\n        [-1, 1, 0, 0],\n        [-1, 0, 1, 0],\n        [-1, 0, 0, 1]\n    ])\n\n    for i, conn in enumerate(elements):\n        # Get element properties\n        kappa_e = kappas[i]\n        \n        # Get coordinates of the element's nodes\n        x0, x1, x2, x3 = node_coords[conn]\n\n        # Form the Jacobian matrix\n        J = np.array([x1 - x0, x2 - x0, x3 - x0]).T\n        \n        if np.linalg.det(J) == 0:\n            # Handle degenerate element if necessary, though not expected in tests\n            continue\n\n        # Compute volume and inverse transpose of Jacobian\n        volume = np.abs(np.linalg.det(J)) / 6.0\n        J_inv_T = np.linalg.inv(J).T\n        \n        # Compute gradients of physical basis functions\n        grad_N_phys = J_inv_T @ grad_N_hat\n        \n        # Compute element stiffness matrix\n        # Ke_ij = kappa * volume * (grad_N_phys_i . grad_N_phys_j)\n        Ke = kappa_e * volume * (grad_N_phys.T @ grad_N_phys)\n\n        # Assemble Ke into the global stiffness matrix K\n        for r_local in range(4):\n            r_global = conn[r_local]\n            for c_local in range(4):\n                c_global = conn[c_local]\n                K[r_global, c_global] += Ke[r_local, c_local]\n    \n    # --- 1. Compute Frobenius norm ---\n    frobenius_norm = np.linalg.norm(K, 'fro')\n\n    # --- 2. Compute solution and error ---\n    all_nodes = set(range(num_nodes))\n    free_nodes = sorted(list(all_nodes - dirichlet_nodes))\n    \n    if not free_nodes:\n        error = 0.0\n    else:\n        # Define the exact solution function\n        def u_star(coord):\n            return sum(coord)\n\n        # Partition the system\n        G = sorted(list(dirichlet_nodes))\n        \n        K_FF = K[np.ix_(free_nodes, free_nodes)]\n        K_FG = K[np.ix_(free_nodes, G)]\n\n        # Get prescribed boundary values from exact solution\n        u_G = np.array([u_star(node_coords[i]) for i in G])\n        \n        # The source term f is zero, so the load vector b is zero\n        # The right-hand side for the reduced system comes from boundary values\n        rhs = -K_FG @ u_G\n        \n        # Solve for the interior nodes\n        u_F = np.linalg.solve(K_FF, rhs)\n\n        # Compute error\n        u_star_F = np.array([u_star(node_coords[i]) for i in free_nodes])\n        error = np.max(np.abs(u_F - u_star_F))\n\n    return frobenius_norm, error\n\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the FEM stiffness matrix assembly problem.\n    \"\"\"\n    test_cases = [\n        # Case A: single tetrahedron\n        {\n            \"nodes\": [(0,0,0), (1,0,0), (0,1,0), (0,0,1)],\n            \"elements\": [[0,1,2,3]],\n            \"kappas\": [2.0],\n            \"dirichlet_nodes\": {0,1,2,3}\n        },\n        # Case B: a tetrahedron subdivided by one interior node\n        {\n            \"nodes\": [(0,0,0), (1,0,0), (0,1,0), (0,0,1), (0.25,0.25,0.25)],\n            \"elements\": [\n                [4,1,2,3], [4,0,2,3], [4,0,1,3], [4,0,1,2]\n            ],\n            \"kappas\": [1.0, 1.0, 1.0, 1.0],\n            \"dirichlet_nodes\": {0,1,2,3}\n        },\n        # Case C: a near-degenerate sliver tetrahedron\n        {\n            \"nodes\": [(0,0,0), (1e-6,0,0), (0,1,0), (0,0,1)],\n            \"elements\": [[0,1,2,3]],\n            \"kappas\": [1.0],\n            \"dirichlet_nodes\": {0,1,2,3}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        norm, err = process_case(**case)\n        results.append(norm)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3206634"}]}