{"hands_on_practices": [{"introduction": "Understanding the limitations of numerical methods is as crucial as learning their implementation. This first practice focuses on numerical diffusion, a key artifact inherent in the simplest finite volume schemes. By implementing a first-order upwind method for the linear advection equation, you will directly observe and quantify how an initially sharp profile smears out over time, and investigate how this effect is controlled by the Courant number, $\\nu$ [@problem_id:2394306].", "problem": "Consider the linear advection equation in one spatial dimension,\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\non a periodic domain of length $L$, that is $x \\in [0,L)$ with periodic boundary conditions. The advection speed $a$ is a positive constant. Starting from the integral conservation law and the definition of finite volume averages on a uniform grid, derive a first-order, explicit, conservative finite volume method that is consistent with the physics of information propagation for $a0$.\n\nYou will investigate numerical diffusion by simulating the advection of a block step function and quantifying the smearing of the interface over time. Use a uniform mesh of $N$ cells with spatial step $\\Delta x = L/N$ and cell centers $x_i = (i+\\tfrac{1}{2})\\Delta x$, for $i=0,1,\\dots,N-1$. Let the initial condition be the block\n$$\nu(x,0) = \\begin{cases}\n1,  x \\in [x_L, x_R),\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\nwith $x_L = 0.2\\,L$ and $x_R = 0.7\\,L$. Evolve the solution using a first-order finite volume scheme with an explicit time step $\\Delta t$ chosen to satisfy a prescribed Courant–Friedrichs–Lewy (CFL) number $\\nu = a\\,\\Delta t/\\Delta x$. Use the same constant $\\nu$ for all time steps of a given simulation. Let the simulation run for a prescribed final time $T$; use an integer number of time steps $n = \\text{round}(T/\\Delta t)$ so that the simulated time is $t_n = n\\,\\Delta t$.\n\nDefine the \"smearing width\" of a descending interface at time $t_n$ as the minimal spatial distance (measured along the periodic domain) from the point where the cell-centered profile crosses the level $\\theta_{\\text{hi}} = 0.9$ downward to the subsequent point where it crosses the level $\\theta_{\\text{lo}} = 0.1$ downward. Compute these crossing points using linear interpolation of the cell-centered values between neighboring cell centers. In the presence of multiple descending interfaces (due to periodicity), compute the smearing width around each descending interface and report the minimal width. Express the width in the same dimensionless length units as $L$.\n\nImplement the simulation and the width measurement in a single program. For each test case below, output the measured smearing width at time $t_n$, rounded to $8$ decimal places.\n\nUse the following test suite, with parameters $(N,\\ \\nu,\\ T,\\ a,\\ L)$:\n- Case $1$: $(200,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$.\n- Case $2$: $(200,\\ 0.9,\\ 0.2,\\ 1.0,\\ 1.0)$.\n- Case $3$: $(200,\\ 0.2,\\ 0.2,\\ 1.0,\\ 1.0)$.\n- Case $4$: $(50,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$.\n- Case $5$: $(200,\\ 1.0,\\ 0.2,\\ 1.0,\\ 1.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, it should look like\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5],\n$$\nwhere each $\\text{result}_k$ is the smearing width for case $k$ rounded to $8$ decimal places. No other output is permitted.", "solution": "We start from the integral conservation form of the advection equation,\n$$\n\\partial_t u(x,t) + \\partial_x f(u) = 0,\\quad f(u) = a u,\\quad a0.\n$$\nLet $\\mathcal{C}_i = [x_{i-\\tfrac{1}{2}}, x_{i+\\tfrac{1}{2}}]$ be a control volume of uniform width $\\Delta x = x_{i+\\tfrac{1}{2}} - x_{i-\\tfrac{1}{2}}$, with cell center $x_i = (i+\\tfrac{1}{2})\\Delta x$ and periodic indexing. Define the cell average\n$$\n\\bar{u}_i(t) = \\frac{1}{\\Delta x}\\int_{\\mathcal{C}_i} u(x,t)\\,dx.\n$$\nIntegrating the conservation law over $\\mathcal{C}_i$ gives\n$$\n\\frac{d}{dt}\\left( \\int_{\\mathcal{C}_i} u(x,t)\\,dx \\right) + \\left[ f(u(x_{i+\\tfrac{1}{2}},t)) - f(u(x_{i-\\tfrac{1}{2}},t)) \\right] = 0,\n$$\nor equivalently,\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x}\\left( f_{i+\\tfrac{1}{2}} - f_{i-\\tfrac{1}{2}} \\right),\n$$\nwhere $f_{i\\pm \\tfrac{1}{2}}$ are the fluxes through the cell faces. A first-order explicit time discretization with time step $\\Delta t$ yields\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left( \\hat{f}_{i+\\tfrac{1}{2}}^n - \\hat{f}_{i-\\tfrac{1}{2}}^n \\right),\n$$\nwith a numerical flux $\\hat{f}_{i+\\tfrac{1}{2}}^n$ consistent with the physics. For linear advection with $a0$, information propagates from left to right, and the exact Riemann solution at each interface depends only on the left state. The Godunov upwind numerical flux is therefore\n$$\n\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n\\quad\\text{for }a0.\n$$\nIntroducing the Courant–Friedrichs–Lewy (CFL) number $\\nu = a\\,\\Delta t/\\Delta x$, the update simplifies to the first-order upwind scheme\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\nu\\left(\\bar{u}_i^n - \\bar{u}_{i-1}^n\\right),\\quad a0,\n$$\nwith periodic indexing on $i$.\n\nTo relate this discrete method to a continuous process and expose numerical diffusion, we perform a modified equation analysis. Denote $\\bar{u}_i^n \\approx u(x_i,t^n)$ with $t^n = n\\Delta t$. A Taylor expansion in time gives\n$$\n\\bar{u}_i^{n+1} - \\bar{u}_i^n = \\Delta t\\,u_t(x_i,t^n) + \\mathcal{O}(\\Delta t^2).\n$$\nA Taylor expansion in space for the backward difference yields\n$$\n\\bar{u}_i^n - \\bar{u}_{i-1}^n = \\Delta x\\,u_x(x_i,t^n) - \\frac{\\Delta x^2}{2}u_{xx}(x_i,t^n) + \\frac{\\Delta x^3}{6}u_{xxx}(x_i,t^n) + \\mathcal{O}(\\Delta x^4).\n$$\nSubstituting into the scheme gives\n$$\n\\Delta t\\,u_t = -\\nu\\left[ \\Delta x\\,u_x - \\frac{\\Delta x^2}{2}u_{xx} + \\frac{\\Delta x^3}{6}u_{xxx} + \\cdots \\right] + \\mathcal{O}(\\Delta t^2).\n$$\nDividing by $\\Delta t$ and recalling $\\nu = a\\Delta t/\\Delta x$,\n$$\nu_t + a\\,u_x = \\frac{a\\,\\Delta x}{2}(1 - \\nu)\\,u_{xx} - \\frac{a\\,\\Delta x^2}{6}\\left(1 - 3\\nu + 2\\nu^2\\right)u_{xxx} + \\cdots.\n$$\nThe leading correction is a diffusion term with an effective (artificial) diffusion coefficient\n$$\nD_{\\text{num}} = \\frac{a\\,\\Delta x}{2}(1 - \\nu).\n$$\nThus for $0\\nu1$, the first-order upwind method introduces numerical diffusion that smears discontinuities over a width that grows like $\\sqrt{D_{\\text{num}}\\,t}$, whereas for $\\nu=1$ the leading diffusive term vanishes and the method reduces to a pure shift operator on the grid.\n\nTo quantify smearing for a step, we define the $10$–$90$ thickness. Consider a descending interface where $u$ drops from values near $1$ to values near $0$. Let $\\theta_{\\text{hi}} = 0.9$ and $\\theta_{\\text{lo}} = 0.1$. On the piecewise-constant cell-centered profile $\\{\\bar{u}_i^n\\}$, we determine the approximate positions where $u=\\theta$ by linear interpolation between neighboring cell centers. Specifically, for a pair of neighboring indices $(i,i+1)$ on a descending front with $\\bar{u}_i^n \\ge \\theta  \\bar{u}_{i+1}^n$,\n$$\nx(\\theta) \\approx x_i + \\Delta x \\frac{\\bar{u}_i^n - \\theta}{\\bar{u}_i^n - \\bar{u}_{i+1}^n}.\n$$\nWe collect all downward $\\theta_{\\text{hi}}$ crossings and all downward $\\theta_{\\text{lo}}$ crossings across the domain (with periodic wrap), and for each $\\theta_{\\text{hi}}$ crossing we determine the distance along the periodic coordinate to the subsequent $\\theta_{\\text{lo}}$ crossing. The minimal such distance, denoted $w_{10\\text{–}90}$, is the measured smearing width. This width is reported in the same length units as $L$.\n\nAlgorithmic design:\n- Spatial discretization: uniform cells, periodic boundary conditions, first-order upwind flux $\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n$ for $a0$.\n- Time stepping: forward Euler with fixed $\\Delta t$ satisfying a prescribed $\\nu = a\\,\\Delta t/\\Delta x$; advance for $n=\\text{round}(T/\\Delta t)$ steps.\n- Initialization: block $u(x,0)=1$ on $[0.2L, 0.7L)$ and $0$ elsewhere on $[0,L)$, sampled at cell centers.\n- Width measurement: compute $w_{10\\text{–}90}$ using linear interpolation of cell-centered values and minimal downstream distance between $\\theta_{\\text{hi}}$ and $\\theta_{\\text{lo}}$ crossings along descending interfaces; use periodic unwrapping to handle interfaces near $x=0$.\n\nQualitative expectations based on $D_{\\text{num}}$: for fixed $a$, $L$, and $T$, finer grids (smaller $\\Delta x$) reduce $D_{\\text{num}}$ and thus reduce smearing; larger $\\nu$ (closer to $1$) also reduces $D_{\\text{num}}$, yielding narrower interfaces; at $\\nu=1$, the leading diffusive term vanishes and the interface is limited essentially to a grid-scale thickness. The program implements the scheme and measurement precisely and outputs, for each specified test case $(N,\\nu,T,a,L)$, the smearing width $w_{10\\text{–}90}(t_n)$ rounded to $8$ decimal places, aggregated as a single list on one line as required.", "answer": "```python\nimport numpy as np\n\ndef upwind_fvm_step(u, nu):\n    \"\"\"\n    First-order upwind finite volume update for a  0:\n    u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n), with periodic indexing.\n    \"\"\"\n    return u - nu * (u - np.roll(u, 1))\n\ndef initialize_block(N, L, xL_frac=0.2, xR_frac=0.7):\n    \"\"\"\n    Initialize u(x,0) = 1 on [x_L, x_R) and 0 elsewhere on [0,L), sampled at cell centers.\n    x_L = xL_frac * L, x_R = xR_frac * L.\n    \"\"\"\n    dx = L / N\n    x = (np.arange(N) + 0.5) * dx\n    xL = xL_frac * L\n    xR = xR_frac * L\n    u0 = np.where((x = xL)  (x  xR), 1.0, 0.0)\n    return x, u0\n\ndef interpolate_crossing_pos(x_i, x_ip1, u_i, u_ip1, theta, L):\n    \"\"\"\n    Linear interpolation between (x_i, u_i) and (x_ip1, u_ip1) to find x where u=theta.\n    The positions x_i and x_ip1 are assumed to be neighbors on a uniform periodic grid.\n    Returns position wrapped into [0, L).\n    \"\"\"\n    # Handle periodic wrap for positions if necessary (assume uniform spacing)\n    # For uniform grid, x_ip1 - x_i = dx and we do not need special position handling for periodicity;\n    # after computing the position, wrap into [0, L).\n    denom = (u_i - u_ip1)\n    if denom == 0.0:\n        return None\n    frac = (u_i - theta) / denom\n    # x along the straight line between centers\n    xi = x_i + (x_ip1 - x_i) * frac\n    # Wrap into [0, L)\n    xi_wrapped = xi % L\n    return xi_wrapped\n\ndef measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1):\n    \"\"\"\n    Measure the 10-90 smearing width on descending interfaces using linear interpolation\n    between neighboring cell centers. Returns the minimal width among all descending interfaces.\n    \"\"\"\n    N = len(u)\n    dx = L / N\n    # Build arrays of theta_hi and theta_lo crossing positions for descending fronts\n    hi_positions = []\n    lo_positions = []\n    for i in range(N):\n        ip1 = (i + 1) % N\n        u_i = u[i]\n        u_ip1 = u[ip1]\n        # Descending segment if u_i  u_ip1 (strict to avoid degenerate flat segments)\n        if u_i  u_ip1:\n            # theta_hi crossing: u_i = theta_hi  u_ip1\n            if (u_i = theta_hi) and (u_ip1  theta_hi):\n                xi = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_hi, L)\n                if xi is not None:\n                    hi_positions.append(xi)\n            # theta_lo crossing: u_i = theta_lo  u_ip1\n            if (u_i = theta_lo) and (u_ip1  theta_lo):\n                xl = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_lo, L)\n                if xl is not None:\n                    lo_positions.append(xl)\n\n    # Sort positions\n    hi_positions = np.sort(np.array(hi_positions, dtype=float)) if len(hi_positions)  0 else np.array([], dtype=float)\n    lo_positions = np.sort(np.array(lo_positions, dtype=float)) if len(lo_positions)  0 else np.array([], dtype=float)\n\n    if hi_positions.size == 0 or lo_positions.size == 0:\n        # No descending interfaces detected; width undefined. Return 0.0 as fallback.\n        return 0.0\n\n    # For each hi crossing, find the next downstream lo crossing (with periodicity)\n    widths = []\n    for h in hi_positions:\n        # Compute downstream distances to all lo positions with periodic wrap\n        dists = []\n        for l in lo_positions:\n            d = l - h\n            if d  0:\n                d += L\n            dists.append(d)\n        if len(dists)  0:\n            widths.append(min(dists))\n    if len(widths) == 0:\n        return 0.0\n    return float(min(widths))\n\ndef simulate_and_measure(N, nu, T, a, L):\n    \"\"\"\n    Run the first-order upwind FVM for linear advection with given parameters and\n    measure the 10-90 smearing width at time ~ T.\n    \"\"\"\n    dx = L / N\n    dt = nu * dx / a\n    # Number of steps to approximate T with fixed dt\n    nsteps = int(np.round(T / dt))\n    # Initialize\n    x, u = initialize_block(N, L, xL_frac=0.2, xR_frac=0.7)\n    # Time-stepping\n    for _ in range(nsteps):\n        u = upwind_fvm_step(u, nu)\n    # Measure width\n    width = measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1)\n    return width\n\ndef solve():\n    # Define the test cases: (N, nu, T, a, L)\n    test_cases = [\n        (200, 0.5, 0.2, 1.0, 1.0),  # Case 1\n        (200, 0.9, 0.2, 1.0, 1.0),  # Case 2\n        (200, 0.2, 0.2, 1.0, 1.0),  # Case 3\n        (50,  0.5, 0.2, 1.0, 1.0),  # Case 4\n        (200, 1.0, 0.2, 1.0, 1.0),  # Case 5\n    ]\n\n    results = []\n    for N, nu, T, a, L in test_cases:\n        width = simulate_and_measure(N, nu, T, a, L)\n        # Round to 8 decimal places as required\n        results.append(width)\n\n    # Final print statement in the exact required format with rounding\n    print(\"[\" + \",\".join(f\"{w:.8f}\" for w in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2394306"}, {"introduction": "After observing the diffusive nature of first-order methods, a natural impulse is to increase the formal order of accuracy. This exercise directly investigates the consequences of this approach by comparing the diffusive first-order scheme with an unlimited second-order method. You will discover that for solutions with sharp features, simply increasing the order can introduce non-physical oscillations, sometimes resulting in a larger overall error [@problem_id:2394314]. This crucial lesson highlights the fundamental trade-off between accuracy and monotonicity that drives the design of advanced numerical methods.", "problem": "You are to compare two conservative finite volume discretizations for the linear advection equation and quantify when a second-order linear reconstruction performs worse than a first-order method due to spurious oscillations near a discontinuity.\n\nConsider the linear advection equation\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\non a periodic domain $[0,1)$ with constant advection speed $a0$. Let a uniform partition into $N$ cells be given by interfaces $x_{i\\pm \\frac{1}{2}}$ with $x_{i+\\frac{1}{2}}-x_{i-\\frac{1}{2}}=\\Delta x$ and cell centers $x_i = \\frac{1}{2}\\left(x_{i-\\frac{1}{2}}+x_{i+\\frac{1}{2}}\\right)$. Let the cell average be\n$$\nu_i^n \\equiv \\frac{1}{\\Delta x}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t^n)\\,dx.\n$$\nThe conservative update is\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right),\n$$\nwhere the upwind numerical flux for $a0$ is $F_{i+\\frac{1}{2}}^n = a\\,u_{i+\\frac{1}{2}}^{-,n}$, with $u_{i+\\frac{1}{2}}^{-,n}$ the left-sided trace at $x_{i+\\frac{1}{2}}$ reconstructed from cell $i$. Assume periodic indexing so that $u_{i+N}^n = u_i^n$ and $u_{i-N}^n = u_i^n$.\n\nYou must implement and compare:\n- A first-order reconstruction (piecewise constant), defined by $u_{i+\\frac{1}{2}}^{-,n} = u_i^n$.\n- A second-order linear reconstruction without any limiter, defined by slopes $s_i^n = \\frac{1}{2}\\left(u_{i+1}^n - u_{i-1}^n\\right)$ and $u_{i+\\frac{1}{2}}^{-,n} = u_i^n + \\frac{1}{2}s_i^n$.\n\nUse a fixed Courant-Friedrichs-Lewy (CFL) number $\\nu \\in (0,1)$ to set the time step via\n$$\n\\Delta t = \\nu \\frac{\\Delta x}{a}.\n$$\nIf the final time $T$ is not an exact multiple of $\\Delta t$, take the last step with a reduced $\\Delta t$ so that the total integration time equals $T$ exactly.\n\nFor each test case below, compute the numerical solution at time $T$ by each method, and then compute the cell-average exact solution at time $T$ given by\n$$\nu(x,T) = u_0\\big((x - a T) \\bmod 1\\big),\n$$\nand its cell averages\n$$\n\\bar{u}_i^{\\text{exact}}(T) = \\frac{1}{\\Delta x}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(y,T)\\,dy.\n$$\nQuantify the error using the discrete $L^1$ norm of cell averages:\n$$\nE_1 = \\Delta x \\sum_{i=0}^{N-1} \\left| u_i(T) - \\bar{u}_i^{\\text{exact}}(T) \\right|.\n$$\n\nUse $a = 1$ and $\\nu = 0.9$ for all cases. The domain is $[0,1)$ with periodic boundary conditions for all cases. The initial conditions $u_0(x)$, the number of cells $N$, and the final time $T$ for the test suite are:\n\n- Test case $1$ (discontinuous top-hat, non-aligned): $N=200$, $T=0.25$, and\n  $$\n  u_0(x) = \\begin{cases}\n  1,  x \\in [0.2, 0.4),\\\\\n  0,  \\text{otherwise,}\n  \\end{cases}\n  $$\n  interpreted on $[0,1)$ periodically.\n\n- Test case $2$ (smooth wave): $N=80$, $T=0.5$, and\n  $$\n  u_0(x) = \\sin(2\\pi x).\n  $$\n\n- Test case $3$ (narrow top-hat tied to grid spacing): $N=80$, $T=0.3$, and\n  $$\n  u_0(x) = \\begin{cases}\n  1,  x \\in [x_0, x_0 + 3\\Delta x),\\\\\n  0,  \\text{otherwise,}\n  \\end{cases}\n  $$\n  with $x_0 = 0.33$ and $\\Delta x = 1/N$; interpret $[x_0, x_0+3\\Delta x)$ modulo $1$.\n\nFor each test case, compute $E_1^{(1)}$ for the first-order method and $E_1^{(2)}$ for the second-order linear reconstruction without any limiter. For each test case, return the integer $1$ if $E_1^{(2)}  E_1^{(1)}$ and the integer $0$ otherwise.\n\nYour program should produce a single line of output containing the three integers for the test cases in order, as a comma-separated list enclosed in square brackets (e.g., $[1,0,1]$). No additional output should be produced.", "solution": "The problem presented requires a comparative analysis of two finite volume method discretizations for the one-dimensional linear advection equation, $\\partial_t u + a\\,\\partial_x u = 0$. The comparison is based on the discrete $L^1$ error norm against the exact solution for both a smooth initial profile and discontinuous initial profiles. The analysis serves to illustrate a fundamental trade-off in numerical methods for conservation laws: the accuracy of high-order schemes on smooth solutions versus their tendency to produce spurious oscillations near discontinuities when not equipped with slope limiters.\n\nFirst, we establish the discrete framework. The spatial domain $[0,1)$ is partitioned into $N$ uniform cells, each of width $\\Delta x = 1/N$. The cell $i$ spans the interval $[x_{i-1/2}, x_{i+1/2}]$, where $x_{i+1/2} = (i+1)\\Delta x$ for $i=-1, \\dots, N-1$. The cell center is $x_i = (i+1/2)\\Delta x$. The cell average of a function $f(x)$ over cell $i$ is denoted $f_i = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} f(x) \\, dx$.\n\nThe finite volume method evolves the cell averages $u_i^n$ at time $t^n$ to $t^{n+1}=t^n+\\Delta t$ via the conservative formula:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2}^n - F_{i-1/2}^n \\right)\n$$\nHere, $F_{i+1/2}^n$ is the numerical flux at the interface $x_{i+1/2}$. For the linear advection equation with speed $a0$, the flux is purely upwind, meaning it depends only on the state to the left of the interface. This gives $F_{i+1/2}^n = a \\cdot u_{i+1/2}^{-,n}$, where $u_{i+1/2}^{-,n}$ is the value of the solution reconstructed at the left-side of the interface $x_{i+1/2}$ from data in cell $i$. The time step $\\Delta t$ is determined by the fixed CFL number $\\nu = a \\Delta t / \\Delta x$, so $\\Delta t = \\nu \\Delta x / a$. The problem specifies $a=1$ and $\\nu=0.9$. The update equation simplifies to:\n$$\nu_i^{n+1} = u_i^n - \\nu \\left( u_{i+1/2}^{-,n} - u_{i-1/2}^{-,n} \\right)\n$$\nPeriodic boundary conditions are imposed, so indices are handled modulo $N$.\n\nWe examine two reconstruction methods for $u_{i+1/2}^{-,n}$:\n\n1.  **First-Order Upwind Method**: This method uses a piecewise constant reconstruction within each cell, $u(x) = u_i^n$ for $x \\in [x_{i-1/2}, x_{i+1/2}]$. The value at the left of the interface $x_{i+1/2}$ is simply the cell average from cell $i$:\n    $$\n    u_{i+1/2}^{-,n} = u_i^n\n    $$\n    Substituting this into the update formula yields the classic first-order upwind scheme:\n    $$\n    u_i^{n+1} = u_i^n - \\nu \\left( u_i^n - u_{i-1}^n \\right)\n    $$\n    This scheme is known to be total variation diminishing (TVD) for $\\nu \\in [0,1]$, which prevents the formation of new oscillations. However, its accuracy is only first-order, leading to significant numerical diffusion, which smears sharp features.\n\n2.  **Second-Order Linear Reconstruction (Unlimited)**: This method uses a piecewise linear reconstruction in each cell, $u(x) = u_i^n + s_i^n(x - x_i)$. The problem defines the reconstruction at the interface based on a specified formula for the slope, which we interpret as a dimensionless slope. The reconstructed value is given as $u_{i+1/2}^{-,n} = u_i^n + \\frac{1}{2}s_i^n$, with $s_i^n = \\frac{1}{2}(u_{i+1}^n - u_{i-1}^n)$. Combining these gives:\n    $$\n    u_{i+1/2}^{-,n} = u_i^n + \\frac{1}{4}\\left( u_{i+1}^n - u_{i-1}^n \\right)\n    $$\n    This reconstruction approximates the point value $u(x_{i+1/2})$ to second-order accuracy in space for smooth solutions. The update formula becomes:\n    $$\n    u_i^{n+1} = u_i^n - \\nu \\left[ \\left( u_i^n + \\frac{1}{4}(u_{i+1}^n - u_{i-1}^n) \\right) - \\left( u_{i-1}^n + \\frac{1}{4}(u_i^n - u_{i-2}^n) \\right) \\right]\n    $$\n    $$\n    u_i^{n+1} = u_i^n - \\nu \\left( \\frac{3}{4}u_i^n - \\frac{5}{4}u_{i-1}^n + \\frac{1}{4}u_{i+1}^n + \\frac{1}{4}u_{i-2}^n \\right)\n    $$\n    This is a linear scheme with a four-point stencil involving cells $i-2, i-1, i, i+1$. While it achieves second-order accuracy on smooth solutions, it is not TVD and is known to be dispersive, producing spurious oscillations (Gibbs phenomenon) near discontinuities. The purpose of the exercise is to quantify when these oscillations lead to a larger error than the diffusive first-order scheme.\n\nTo conduct the analysis, we first compute the initial cell averages $u_i^0$ by integrating the initial condition $u_0(x)$ over each cell.\n- For a top-hat function $u_0(x) = 1$ on an interval $[b_1, b_2)$ and $0$ otherwise, the cell average is $u_i^0 = \\frac{1}{\\Delta x} \\text{length}([x_{i-1/2}, x_{i+1/2}] \\cap [b_1, b_2))$.\n- For the smooth function $u_0(x) = \\sin(2\\pi x)$, the integral can be computed analytically:\n  $$\n  u_i^0 = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} \\sin(2\\pi x) dx = \\frac{\\cos(2\\pi i\\Delta x) - \\cos(2\\pi(i+1)\\Delta x)}{2\\pi\\Delta x} = \\frac{\\sin(\\pi\\Delta x)}{\\pi\\Delta x}\\sin(2\\pi x_i)\n  $$\n\nThe exact solution to the advection equation is $u(x,T) = u_0((x-aT)\\pmod 1)$. The exact cell averages at the final time $T$ are computed by integrating this exact solution over each cell:\n$$\n\\bar{u}_i^{\\text{exact}}(T) = \\frac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} u_0((x-aT)\\pmod 1) \\,dx\n$$\nThis calculation is analogous to finding the initial cell averages, but with the initial profile shifted by $aT$.\n\nThe time integration proceeds for a number of full steps $N_{\\text{steps}} = \\lfloor T/\\Delta t \\rfloor$ using the fixed time step $\\Delta t = \\nu \\Delta x / a$. If there is a remaining time $\\Delta t_{\\text{final}} = T - N_{\\text{steps}}\\Delta t  0$, a final, smaller time step is taken to reach exactly time $T$.\n\nFinally, the error for each method is quantified using the discrete $L^1$ norm:\n$$\nE_1 = \\Delta x \\sum_{i=0}^{N-1} \\left| u_i(T) - \\bar{u}_i^{\\text{exact}}(T) \\right|\n$$\nFor each test case, we compute the error $E_1^{(1)}$ for the first-order method and $E_1^{(2)}$ for the second-order method. We then determine if $E_1^{(2)}  E_1^{(1)}$.\n\n- **Test Case 1 (Discontinuous top-hat)**: The initial condition is discontinuous. The second-order method will produce significant over- and undershoots at the edges of the top-hat. The first-order method will smear the edges. The large, non-decaying oscillations from the second-order scheme are expected to result in a larger $L^1$ error compared to the diffusive but non-oscillatory first-order scheme. Thus, we expect $E_1^{(2)}  E_1^{(1)}$.\n- **Test Case 2 (Smooth wave)**: The initial condition is $C^\\infty$. For such solutions, the second-order method's superior accuracy will be clearly evident. It will approximate the sine wave with much smaller error than the highly diffusive first-order method. We expect $E_1^{(2)}  E_1^{(1)}$.\n- **Test Case 3 (Narrow top-hat)**: This is another discontinuous case, made more challenging by the feature's width being only a few grid cells ($3\\Delta x$). This accentuates the flaw of the unlimited linear reconstruction, as the stencil for the slope calculation spans a significant portion of the feature. We again expect large oscillations and $E_1^{(2)}  E_1^{(1)}$.\n\nThe implementation will proceed by creating a general finite volume solver that can be configured for either method. This solver will be applied to each test case, the errors computed, and the comparison made as required.", "answer": "```python\nimport numpy as np\n\ndef get_box_averages(N, box_start, box_end):\n    \"\"\"\n    Computes cell averages for a function that is 1 on [box_start, box_end)\n    and 0 otherwise, on a periodic domain [0,1).\n    \"\"\"\n    dx = 1.0 / N\n    cell_starts = np.arange(N) * dx\n    cell_ends = (np.arange(N) + 1) * dx\n    u_avg = np.zeros(N)\n\n    # Handle multiple integer wrappings of the interval\n    num_wraps = np.floor(box_end) - np.floor(box_start)\n    s_mod = box_start % 1.0\n    e_mod = box_end % 1.0\n\n    if num_wraps == 0: # Interval does not cross an integer\n        s, e = s_mod, e_mod\n        if e = s: # e.g. [0.2, 0.1) or [0.2, 0.2)\n            return u_avg\n        overlap = np.maximum(0, np.minimum(cell_ends, e) - np.maximum(cell_starts, s))\n        u_avg += overlap\n    else: # Interval crosses at least one integer\n        # Part from start to 1.0\n        overlap1 = np.maximum(0, np.minimum(cell_ends, 1.0) - np.maximum(cell_starts, s_mod))\n        u_avg += overlap1\n        # Part from 0.0 to end\n        overlap2 = np.maximum(0, np.minimum(cell_ends, e_mod) - np.maximum(cell_starts, 0.0))\n        u_avg += overlap2\n        # Full wraps\n        if num_wraps  1:\n            u_avg += (num_wraps - 1) * dx\n\n    return u_avg / dx\n\ndef run_fvm(u_initial, N, T, a, nu_fixed, method):\n    \"\"\"\n    Solves the linear advection equation using the finite volume method.\n    \"\"\"\n    u = u_initial.copy()\n    dx = 1.0 / N\n    \n    dt_fixed = nu_fixed * dx / a\n    if dt_fixed = 0:\n        return u\n        \n    num_steps = int(T / dt_fixed) if T  0 else 0\n    t = 0.0\n\n    # Perform full time steps\n    for _ in range(num_steps):\n        nu = nu_fixed\n        if method == 'first':\n            # First-order upwind\n            u = u - nu * (u - np.roll(u, 1))\n        elif method == 'second':\n            # Second-order unlimited linear reconstruction\n            u_p1 = np.roll(u, -1)\n            u_m1 = np.roll(u, 1)\n            s = 0.5 * (u_p1 - u_m1)\n            u_interface = u + 0.5 * s\n            flux_diff = u_interface - np.roll(u_interface, 1)\n            u = u - nu * flux_diff\n        t += dt_fixed\n    \n    # Perform final, smaller time step if needed\n    dt_final = T - t\n    if dt_final  1e-12:\n        nu_final = a * dt_final / dx\n        if method == 'first':\n            u = u - nu_final * (u - np.roll(u, 1))\n        elif method == 'second':\n            u_p1 = np.roll(u, -1)\n            u_m1 = np.roll(u, 1)\n            s = 0.5 * (u_p1 - u_m1)\n            u_interface = u + 0.5 * s\n            flux_diff = u_interface - np.roll(u_interface, 1)\n            u = u - nu_final * flux_diff\n            \n    return u\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # (N, T, initial_condition_type, params)\n        (200, 0.25, 'top-hat', {'start': 0.2, 'end': 0.4}),\n        (80, 0.5, 'sine-wave', {}),\n        (80, 0.3, 'narrow-top-hat', {'x0': 0.33}),\n    ]\n\n    a = 1.0\n    nu_fixed = 0.9\n    results = []\n\n    for N, T, u0_type, params in test_cases:\n        dx = 1.0 / N\n        x_centers = (np.arange(N) + 0.5) * dx\n\n        # --- Initial Conditions ---\n        if u0_type == 'top-hat':\n            start, end = params['start'], params['end']\n            u_initial = get_box_averages(N, start, end)\n        elif u0_type == 'sine-wave':\n            # Use analytical formula for cell-averaged sine\n            factor = np.sinc(dx) # np.sinc(x) = sin(pi*x)/(pi*x)\n            u_initial = factor * np.sin(2 * np.pi * x_centers)\n        elif u0_type == 'narrow-top-hat':\n            x0 = params['x0']\n            start = x0\n            end = x0 + 3 * dx\n            u_initial = get_box_averages(N, start, end)\n\n        # --- Run Simulations ---\n        u_final_1st = run_fvm(u_initial, N, T, a, nu_fixed, 'first')\n        u_final_2nd = run_fvm(u_initial, N, T, a, nu_fixed, 'second')\n        \n        # --- Exact Solution ---\n        shift = (a * T) % 1.0\n        if u0_type == 'top-hat':\n            start, end = params['start'], params['end']\n            u_exact = get_box_averages(N, start + shift, end + shift)\n        elif u0_type == 'sine-wave':\n            # u(x,T) = sin(2*pi*(x-aT)) = sin(2*pi*x - 2*pi*aT)\n            # For T=0.5, a=1, this is sin(2*pi*x - pi) = -sin(2*pi*x)\n            factor = np.sinc(dx)\n            u_exact = -factor * np.sin(2 * np.pi * x_centers)\n        elif u0_type == 'narrow-top-hat':\n            x0 = params['x0']\n            start = x0\n            end = x0 + 3 * dx\n            u_exact = get_box_averages(N, start + shift, end + shift)\n\n        # --- Compute Errors and Compare ---\n        e1_1st = dx * np.sum(np.abs(u_final_1st - u_exact))\n        e1_2nd = dx * np.sum(np.abs(u_final_2nd - u_exact))\n        \n        results.append(1 if e1_2nd  e1_1st else 0)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2394314"}, {"introduction": "The true power of the Finite Volume Method is most evident when applied to nonlinear conservation laws, which model phenomena like shock waves in fluid dynamics. This practice advances from the linear advection equation to the nonlinear inviscid Burgers' equation, $u_t + \\left(\\frac{1}{2}u^2\\right)_x = 0$. You will implement and compare a simple upwind-type flux against the more sophisticated Harten-Lax-van Leer (HLL) approximate Riemann solver, gaining hands-on experience with how modern schemes are engineered to robustly capture both discontinuous shocks and smooth rarefaction waves [@problem_id:2394328].", "problem": "Implement a one-dimensional finite volume solver for the inviscid Burgers equation using two different numerical fluxes and compare their ability to capture shocks and rarefactions. The starting point is the conservation law and its integral form. Begin from the fundamental conservation statement: for a conserved quantity with density $u(x,t)$ and flux $f(u)$, the local conservation law is $u_t + f(u)_x = 0$. Over a control volume $[x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$, the integral form is $\\frac{d}{dt}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t)\\,dx + \\left.f(u)\\right|_{x_{i+\\frac{1}{2}}} - \\left.f(u)\\right|_{x_{i-\\frac{1}{2}}} = 0$. Discretize this to obtain a first-order finite volume update for cell averages $U_i^n$ at time $t^n$ with time step $\\Delta t$ and cell width $\\Delta x$, using the replacement of physical fluxes at interfaces by numerical fluxes that approximate the solution of a local Riemann problem. No additional formulas are provided in the problem statement; you must derive the discrete update and the numerical fluxes from these principles.\n\nUse the specific conservation law $u_t + \\left(\\frac{1}{2}u^2\\right)_x = 0$, that is, the inviscid Burgers equation with $f(u)=\\frac{1}{2}u^2$. Implement two numerical fluxes at each cell interface based on left and right states $u_L$ and $u_R$:\n- An approximate Riemann solver of Harten–Lax–van Leer (HLL), derived by bounding the signal speeds by the minimal and maximal characteristic speeds and integrating the approximate Riemann fan. For the scalar case, this reduces to a Godunov-type flux when the waves are correctly bounded by the left and right characteristic speeds.\n- A basic upwind flux obtained by linearizing the nonlinear flux locally with a single advection speed computed from the interface states, and applying the donor-cell upwinding rule relative to the sign of that speed.\n\nAlgorithmic requirements:\n- Use a uniform grid with $N$ cells over the domain $[x_L,x_R] = [-1,1]$ with cell centers at $x_i = x_L + \\left(i + \\frac{1}{2}\\right)\\Delta x$ for $i=0,1,\\dots,N-1$, where $\\Delta x = \\frac{x_R - x_L}{N}$.\n- Initialize a Riemann problem with a discontinuity at $x=0$: $u(x,0) = u_L$ for $x  0$ and $u(x,0) = u_R$ for $x \\ge 0$.\n- Advance in time using an explicit forward Euler method for the finite volume update to a final time $T$, enforcing a Courant–Friedrichs–Lewy (CFL) stability condition based on the maximum characteristic speed $|f'(u)| = |u|$ in the domain at each time step. Use $\\Delta t \\le \\nu \\frac{\\Delta x}{\\max_i |u_i|}$, with a chosen CFL number $\\nu$ strictly less than $1$.\n- Apply transmissive (zero-gradient) boundary conditions implemented with one ghost cell on each side by copying the nearest interior value into the corresponding ghost cell at each time step.\n\nReference solution for error evaluation:\n- Derive and use the exact self-similar Riemann solution of the inviscid Burgers equation to compute a reference $u(x_i,T)$ at cell centers. For $u_L  u_R$, the solution is a shock located at speed given by the Rankine–Hugoniot condition. For $u_L  u_R$, the solution is a centered rarefaction fan with linear profile between the left and right characteristic speeds.\n\nTest suite and outputs:\n- Use $N=400$, $\\nu=0.9$, domain $[x_L,x_R]=[-1,1]$, discontinuity at $x=0$, and final time $T=0.3$ for all tests. Define three initial states $(u_L,u_R)$:\n  1. $u_L=2.0$, $u_R=0.0$ (shock-dominant case).\n  2. $u_L=0.0$, $u_R=2.0$ (expanding rarefaction case).\n  3. $u_L=-1.0$, $u_R=1.0$ (transonic rarefaction case).\n- For each test case $k \\in \\{1,2,3\\}$, compute the discrete $L^1$ error for each numerical flux scheme relative to the exact solution:\n  $$E_{\\mathrm{HLL}}^{(k)} = \\Delta x \\sum_{i=0}^{N-1} \\left| U_{i,\\mathrm{HLL}}(T) - u_{\\mathrm{exact}}(x_i,T) \\right|,$$\n  $$E_{\\mathrm{UP}}^{(k)} = \\Delta x \\sum_{i=0}^{N-1} \\left| U_{i,\\mathrm{UP}}(T) - u_{\\mathrm{exact}}(x_i,T) \\right|.$$\n- For each test, also compute an indicator $I^{(k)}$ that is the integer $1$ if $E_{\\mathrm{HLL}}^{(k)}  E_{\\mathrm{UP}}^{(k)}$ and $0$ otherwise.\n\nUnits: All quantities are nondimensional; report dimensionless numbers only.\n\nFinal output format:\n- Your program must produce a single line containing a comma-separated list enclosed in square brackets of the nine results in the order\n  $$\\left[ E_{\\mathrm{HLL}}^{(1)}, E_{\\mathrm{UP}}^{(1)}, I^{(1)}, E_{\\mathrm{HLL}}^{(2)}, E_{\\mathrm{UP}}^{(2)}, I^{(2)}, E_{\\mathrm{HLL}}^{(3)}, E_{\\mathrm{UP}}^{(3)}, I^{(3)} \\right],$$\n  where each error $E_{\\mathrm{HLL}}^{(k)}$ and $E_{\\mathrm{UP}}^{(k)}$ must be rounded to exactly six decimal places, and each indicator $I^{(k)}$ is an integer. For example, the printed string should look like $[\\dots]$ with exactly nine comma-separated entries and no additional text.", "solution": "**1. Finite Volume Discretization**\n\nThe starting point is the integral form of the conservation law for a quantity $u$ over a control volume, or cell, $C_i = [x_{i-1/2}, x_{i+1/2}]$ of width $\\Delta x = x_{i+1/2} - x_{i-1/2}$:\n$$\n\\frac{d}{dt}\\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,dx + f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t)) = 0\n$$\nWe define the cell-average of $u$ over cell $C_i$ as $U_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, t) dx$. Substituting this definition into the integral conservation law yields an exact equation for the evolution of cell averages:\n$$\n\\frac{d}{dt} (\\Delta x U_i(t)) + f_{i+1/2} - f_{i-1/2} = 0\n$$\nwhere $f_{i \\pm 1/2}$ denotes the instantaneous physical flux $f(u)$ at the cell interfaces $x_{i \\pm 1/2}$. Assuming a uniform grid where $\\Delta x$ is constant, this simplifies to:\n$$\n\\frac{dU_i}{dt} = - \\frac{1}{\\Delta x} (f_{i+1/2} - f_{i-1/2})\n$$\nThe core principle of the finite volume method is to replace the unknown point-wise physical fluxes $f_{i \\pm 1/2}$ with numerical fluxes $\\hat{f}_{i \\pm 1/2}$. The numerical flux at the interface between cell $i$ and cell $i+1$, denoted $\\hat{f}_{i+1/2}$, is a function of the cell-averaged states in the adjacent cells, i.e., $\\hat{f}_{i+1/2} = \\hat{f}(U_i, U_{i+1})$. The resulting semi-discrete scheme is:\n$$\n\\frac{dU_i}{dt} = - \\frac{1}{\\Delta x} \\left( \\hat{f}(U_i, U_{i+1}) - \\hat{f}(U_{i-1}, U_i) \\right)\n$$\nTo obtain a fully discrete scheme, we discretize time using the explicit forward Euler method. For a time step $\\Delta t$, the value of the cell average at time step $n+1$ is given in terms of the values at time step $n$:\n$$\n\\frac{U_i^{n+1} - U_i^n}{\\Delta t} = - \\frac{1}{\\Delta x} \\left( \\hat{f}(U_i^n, U_{i+1}^n) - \\hat{f}(U_{i-1}^n, U_i^n) \\right)\n$$\nThis gives the first-order accurate update formula:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( \\hat{f}(U_i^n, U_{i+1}^n) - \\hat{f}(U_{i-1}^n, U_i^n) \\right)\n$$\n\n**2. Numerical Flux Functions**\n\nThe problem specifies the inviscid Burgers' equation, $u_t + \\left(\\frac{1}{2}u^2\\right)_x = 0$. The flux is $f(u) = \\frac{1}{2}u^2$, and its Jacobian, representing the characteristic speed, is $f'(u) = u$. We derive the two required numerical fluxes, $\\hat{f}(u_L, u_R)$, where $u_L$ and $u_R$ are the reconstructed states to the left and right of a cell interface. For our first-order scheme, these are simply the cell averages of the adjacent cells.\n\n**2.1. Basic Upwind Flux**\nThis flux is based on the solution to the linearized advection equation $u_t + a u_x = 0$, where information propagates with speed $a$. For the nonlinear Burgers' equation, we define a single local advection speed $a(u_L, u_R)$ at the interface. A common choice, which corresponds to the Roe average for this equation, is the arithmetic mean:\n$$\na(u_L, u_R) = \\frac{u_L + u_R}{2}\n$$\nThis speed is also the Rankine-Hugoniot shock speed. The upwind flux selects the flux from the \"upstream\" side, determined by the sign of this advection speed:\n$$\n\\hat{f}_{\\text{upwind}}(u_L, u_R) = \\begin{cases} f(u_L)  \\text{if } a(u_L, u_R) \\ge 0 \\\\ f(u_R)  \\text{if } a(u_L, u_R)  0 \\end{cases}\n$$\n\n**2.2. Harten-Lax-van Leer (HLL) Flux**\nThe HLL flux is constructed from an approximate Riemann solver that assumes a two-wave model. It presumes the solution at the interface consists of three constant states ($u_L$, $u^*$, $u_R$) separated by two waves with speeds $S_L$ and $S_R$. These speeds must bound all characteristic speeds of the true Riemann solution. For the scalar Burgers' equation, the true wave speeds are bounded by $\\min(u_L, u_R)$ and $\\max(u_L, u_R)$. We therefore choose these as our signal speed estimates:\n$$\nS_L = \\min(u_L, u_R) \\quad \\text{and} \\quad S_R = \\max(u_L, u_R)\n$$\nBy applying the integral conservation law over a control volume encompassing the wave structure, one derives the HLL flux. The formula depends on the direction of wave propagation relative to the cell interface (where $x/t = 0$):\n- If $S_L \\ge 0$, the entire wave structure propagates to the right. The state at the interface is $u_L$, and the flux is $\\hat{f}_{\\text{HLL}} = f(u_L)$.\n- If $S_R \\le 0$, the entire structure propagates to the left. The state at the interface is $u_R$, and the flux is $\\hat{f}_{\\text{HLL}} = f(u_R)$.\n- If $S_L  0  S_R$, the interface lies within the two waves. The flux is a weighted average that ensures conservation:\n  $$\n  \\hat{f}_{\\text{HLL}}(u_L, u_R) = \\frac{S_R f(u_L) - S_L f(u_R) + S_L S_R (u_R - u_L)}{S_R - S_L}\n  $$\nThis combined formulation provides a robust and conservative numerical flux.\n\n**3. Exact Riemann Solution for the Inviscid Burgers' Equation**\n\nThe exact solution to the Riemann problem for the Burgers' equation is self-similar, depending only on the variable $\\xi = x/t$. The character of the solution is determined by the relation between the initial left and right states, $u_L$ and $u_R$.\n\n- **Shock Wave ($u_L  u_R$)**: A single discontinuity forms and travels with a constant speed $s$ given by the Rankine-Hugoniot condition:\n  $$\n  s = \\frac{f(u_R) - f(u_L)}{u_R - u_L} = \\frac{\\frac{1}{2}u_R^2 - \\frac{1}{2}u_L^2}{u_R - u_L} = \\frac{u_L + u_R}{2}\n  $$\n  The solution is a step function:\n  $$\n  u(x,t) = \\begin{cases} u_L,  \\text{if } x/t  s \\\\ u_R,  \\text{if } x/t  s \\end{cases}\n  $$\n\n- **Rarefaction Wave ($u_L  u_R$)**: The solution is a continuous \"fan\" that connects the left and right states. Within the fan, the solution is given by $u(x,t) = x/t$. The fan spans the region between the characteristic speeds $\\lambda(u_L)=u_L$ and $\\lambda(u_R)=u_R$. The complete solution is:\n  $$\n  u(x,t) = \\begin{cases} u_L,  \\text{if } x/t \\le u_L \\\\ x/t,  \\text{if } u_L  x/t  u_R \\\\ u_R,  \\text{if } x/t \\ge u_R \\end{cases}\n  $$\nThis exact solution will serve as the reference for computing the $L^1$ error of the numerical schemes.\n\n**4. Numerical Algorithm Summary**\n\nThe solver is implemented based on the following specifications:\n- **Domain and Grid**: $[x_L, x_R] = [-1, 1]$ with $N=400$ cells, so $\\Delta x = (1 - (-1))/400 = 0.005$.\n- **State Vector**: A NumPy array of size $N+2$ is used, with indices $1, \\dots, N$ representing the aformentioned cells and indices $0$ and $N+1$ representing the left and right ghost cells, respectively.\n- **Initial Condition**: Cell averages are initialized based on the position of their cell centers relative to the discontinuity at $x=0$.\n- **Boundary Conditions**: Transmissive (zero-gradient) conditions are enforced at each time step by setting the ghost cell values equal to the adjacent interior cell values: $U_0^n = U_1^n$ and $U_{N+1}^n = U_N^n$.\n- **Time Stepping**: The simulation runs from $t=0$ to $T=0.3$. The time step $\\Delta t$ is dynamically calculated at each step to satisfy the Courant-Friedrichs-Lewy (CFL) condition: $\\Delta t = \\nu \\frac{\\Delta x}{\\max_i |U_i^n|}$, with a CFL number $\\nu=0.9$. The final time step is adjusted to end exactly at $T$.\n- **Error Calculation**: For each test case and flux type, the discrete $L^1$ error is computed as $E = \\Delta x \\sum_{i=0}^{N-1} |U_{i,\\text{num}}(T) - u_{\\text{exact}}(x_i,T)|$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n    \n    # --- Problem Parameters ---\n    N = 400\n    x_L, x_R = -1.0, 1.0\n    T_final = 0.3\n    nu = 0.9  # CFL number\n    \n    test_cases = [\n        (2.0, 0.0),  # Case 1: Shock\n        (0.0, 2.0),  # Case 2: Rarefaction\n        (-1.0, 1.0), # Case 3: Transonic Rarefaction\n    ]\n\n    all_results = []\n\n    for k, (u_L, u_R) in enumerate(test_cases):\n        \n        # --- Run simulation with HLL flux ---\n        u_hll = run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, 'hll')\n        \n        # --- Run simulation with Upwind flux ---\n        u_upwind = run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, 'upwind')\n        \n        # --- Compute L1 errors ---\n        dx = (x_R - x_L) / N\n        x_centers = x_L + (np.arange(N) + 0.5) * dx\n\n        # Error for HLL\n        u_exact_vals = exact_solution(x_centers, T_final, u_L, u_R)\n        e_hll = dx * np.sum(np.abs(u_hll - u_exact_vals))\n        \n        # Error for Upwind\n        e_upwind = dx * np.sum(np.abs(u_upwind - u_exact_vals))\n\n        # Indicator\n        indicator = 1 if e_hll  e_upwind else 0\n\n        # Append results for this test case\n        all_results.extend([round(e_hll, 6), round(e_upwind, 6), indicator])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, flux_type):\n    \"\"\"\n    Runs a single 1D FVM simulation for the Burgers equation.\n    \n    Args:\n        N (int): Number of cells.\n        x_L (float): Left boundary of the domain.\n        x_R (float): Right boundary of the domain.\n        T_final (float): Final simulation time.\n        nu (float): CFL number.\n        u_L (float): Initial left state.\n        u_R (float): Initial right state.\n        flux_type (str): 'hll' or 'upwind'.\n        \n    Returns:\n        numpy.ndarray: The solution array u_n at the final time in the physical domain.\n    \"\"\"\n    dx = (x_R - x_L) / N\n    x_centers = x_L + (np.arange(N) + 0.5) * dx\n\n    # Initialize solution array with 1 ghost cell on each side\n    u_n = np.zeros(N + 2)\n    u_n[1:-1] = np.where(x_centers  0, u_L, u_R)\n\n    t = 0.0\n    \n    flux_func = get_flux_function(flux_type)\n\n    while t  T_final:\n        # Apply transmissive (zero-gradient) boundary conditions\n        u_n[0] = u_n[1]\n        u_n[-1] = u_n[-2]\n\n        # Calculate time step based on CFL condition\n        max_abs_u = np.max(np.abs(u_n))\n        if max_abs_u  1e-9:\n            max_abs_u = 1e-9 # Avoid division by zero\n            \n        dt = nu * dx / max_abs_u\n        if t + dt  T_final:\n            dt = T_final - t\n\n        # Calculate fluxes at interfaces\n        # F[j] is the flux at the interface between cell j and j+1 (in the padded array)\n        fluxes = np.zeros(N + 1)\n        for j in range(N + 1):\n            fluxes[j] = flux_func(u_n[j], u_n[j+1])\n        \n        # Update solution using first-order finite volume scheme\n        u_np1 = np.copy(u_n)\n        for i in range(1, N + 1): # Iterate over physical cells\n            u_np1[i] = u_n[i] - (dt / dx) * (fluxes[i] - fluxes[i-1])\n\n        u_n = u_np1\n        t += dt\n\n    return u_n[1:-1] # Return only the physical domain\n\ndef get_flux_function(flux_type):\n    \"\"\"Returns the chosen numerical flux function.\"\"\"\n    if flux_type == 'hll':\n        return hll_flux\n    elif flux_type == 'upwind':\n        return upwind_flux\n    else:\n        raise ValueError(\"Invalid flux type specified.\")\n\ndef flux(u):\n    \"\"\"Physical flux for Burgers' equation.\"\"\"\n    return 0.5 * u**2\n\ndef upwind_flux(u_l, u_r):\n    \"\"\"Computes the basic upwind flux.\"\"\"\n    a = 0.5 * (u_l + u_r) # Roe average speed\n    if a = 0:\n        return flux(u_l)\n    else:\n        return flux(u_r)\n\ndef hll_flux(u_l, u_r):\n    \"\"\"Computes the HLL flux.\"\"\"\n    if np.isclose(u_l, u_r):\n        return flux(u_l)\n        \n    f_l = flux(u_l)\n    f_r = flux(u_r)\n    \n    # Estimate signal speeds\n    s_l = min(u_l, u_r)\n    s_r = max(u_l, u_r)\n    \n    if s_l = 0:\n        return f_l\n    elif s_r = 0:\n        return f_r\n    else: # s_l  0  s_r\n        return (s_r * f_l - s_l * f_r + s_l * s_r * (u_r - u_l)) / (s_r - s_l)\n\ndef exact_solution(x, t, u_l, u_r):\n    \"\"\"Computes the exact Riemann solution for the Burgers equation.\"\"\"\n    if np.isclose(t, 0):\n        return np.where(x  0, u_l, u_r)\n    \n    if u_l  u_r:  # Shock\n        s = 0.5 * (u_l + u_r)\n        return np.where(x / t  s, u_l, u_r)\n    else:  # Rarefaction\n        xi = x / t\n        solution = np.piecewise(xi, [xi = u_l, (xi  u_l)  (xi  u_r), xi = u_r],\n                                [u_l, lambda val: val, u_r])\n        return solution\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2394328"}]}