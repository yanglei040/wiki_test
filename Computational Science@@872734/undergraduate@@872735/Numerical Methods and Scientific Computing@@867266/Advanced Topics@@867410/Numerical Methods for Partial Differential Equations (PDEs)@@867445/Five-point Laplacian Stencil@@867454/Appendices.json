{"hands_on_practices": [{"introduction": "The journey into any numerical method begins with its foundation. This first practice takes you back to first principles, using Taylor series to derive the five-point Laplacian stencil and analyze its truncation error. By implementing a grid refinement study with a known \"manufactured\" solution, you will numerically verify the stencil's second-order accuracy, a cornerstone concept in finite difference analysis [@problem_id:3230823].", "problem": "You are asked to work from first principles to analyze and implement the five-point discrete Laplacian operator for a manufactured solution, and then perform a grid refinement study to confirm second-order convergence. Begin from the definition of the Laplacian and the Taylor series of smooth functions. Do not use any pre-derived discrete formula; instead, derive it using the fundamental base described below.\n\nFundamental base:\n- Definition of the Laplacian: for a sufficiently smooth scalar field $u(x,y)$, the Laplacian is $\\Delta u(x,y) = \\dfrac{\\partial^2 u}{\\partial x^2}(x,y) + \\dfrac{\\partial^2 u}{\\partial y^2}(x,y)$.\n- Taylor series for a smooth function in one variable $x$ about a point $x_0$ is $u(x_0 + h) = u(x_0) + h\\,u_x(x_0) + \\dfrac{h^2}{2}\\,u_{xx}(x_0) + \\dfrac{h^3}{6}\\,u_{xxx}(x_0) + \\dfrac{h^4}{24}\\,u_{xxxx}(x_0) + \\mathcal{O}(h^5)$, and similarly for $u(x_0 - h)$.\n- The central finite difference approximation for a second derivative in one dimension can be derived from the Taylor series expansions above.\n\nTask:\n1. Using the Taylor series expansions around a grid point $(x_i,y_j)$ with spacings $h_x$ in the $x$ direction and $h_y$ in the $y$ direction, derive the five-point discrete Laplacian stencil that approximates $\\Delta u(x_i,y_j)$ by a linear combination of $u(x_{i\\pm 1},y_j)$ and $u(x_i,y_{j\\pm 1})$ and $u(x_i,y_j)$. Your derivation must clearly identify the leading-order truncation error term and show that the local truncation error is of order $\\mathcal{O}(h_x^2 + h_y^2)$ for sufficiently smooth $u$.\n2. Implement a program that, for each manufactured solution $u(x,y)$ and its exact Laplacian $\\Delta u(x,y)$, computes the discrete Laplacian at interior grid points on a rectangular domain using Dirichlet boundary values from the exact $u(x,y)$. Compute the error as the maximum absolute difference between the discrete Laplacian and the exact Laplacian over all interior grid points.\n3. Perform a grid refinement study: for a sequence of meshes where the spacing in each direction is halved successively, compute the errors and the observed convergence orders $p_k = \\log_2\\!\\left(\\dfrac{E(h_k)}{E(h_{k+1})}\\right)$, where $E(h)$ is the chosen error norm and $h$ denotes the grid spacing in the $x$ direction. In anisotropic cases, keep the ratio $h_y/h_x$ constant while refining both $h_x$ and $h_y$ by a factor of $2$.\n4. For trigonometric functions, angles must be interpreted in radians.\n5. Round each observed order $p_k$ to $3$ decimal places.\n\nError norm:\n- Use the maximum norm over interior nodes: $E(h_x,h_y) = \\max_{i,j} \\left| \\Delta_h u(x_i,y_j) - \\Delta u(x_i,y_j) \\right|$, where $\\Delta_h$ is your derived five-point discrete Laplacian and $(x_i,y_j)$ ranges over interior grid points only.\n\nTest suite:\n- Domain for all tests: $[0,1]\\times[0,1]$.\n- Boundary values: use exact $u(x,y)$ on $\\partial([0,1]\\times[0,1])$.\n- For each test case, use successive refinements by halving $h_x$ (and $h_y$ accordingly) to obtain a sequence of $4$ meshes, yielding $3$ observed orders $p_k$.\n\nProvide the following four test cases:\n- Case $1$ (happy path, isotropic):\n  - $u_1(x,y) = \\sin(\\pi x)\\sin(\\pi y)$, with $\\Delta u_1(x,y) = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$.\n  - Initial spacings: $h_x = h_y = 1/8$.\n- Case $2$ (smooth exponential, isotropic):\n  - $u_2(x,y) = e^{x+y}$, with $\\Delta u_2(x,y) = 2 e^{x+y}$.\n  - Initial spacings: $h_x = h_y = 1/8$.\n- Case $3$ (anisotropic grid, fixed ratio $h_y/h_x = 2$):\n  - $u_3(x,y) = \\sin(\\pi x)\\sin(\\pi y)$, with $\\Delta u_3(x,y) = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$.\n  - Initial spacings: $h_x = 1/16$, $h_y = 1/8$.\n- Case $4$ (coarser initial grid, polynomial solution):\n  - $u_4(x,y) = x^4 + y^4$, with $\\Delta u_4(x,y) = 12 x^2 + 12 y^2$.\n  - Initial spacings: $h_x = h_y = 1/4$.\n\nOutput specification:\n- Your program should produce a single line of output containing one top-level list of four sublists, one per test case. Each sublist must contain the three rounded observed orders $p_k$ for successive refinement pairs, formatted as a comma-separated list with no spaces and enclosed in square brackets. The four sublists must be combined as a comma-separated list with no spaces and enclosed in square brackets. For example: $[[2.000,2.000,2.000],[2.000,2.000,2.000],[2.000,2.000,2.000],[2.000,2.000,2.000]]$.", "solution": "The problem is valid as it is scientifically sound, well-posed, and based on established principles of numerical analysis. It requires the derivation of the five-point finite difference stencil for the Laplacian and a numerical verification of its convergence order, which is a standard and well-defined task.\n\n**Part 1: Derivation of the Five-Point Laplacian Stencil and Truncation Error**\n\nWe seek an approximation for the Laplacian operator, $\\Delta u(x,y) = \\dfrac{\\partial^2 u}{\\partial x^2}(x,y) + \\dfrac{\\partial^2 u}{\\partial y^2}(x,y)$, at a grid point $(x_i, y_j)$. We begin by approximating the second partial derivatives $\\dfrac{\\partial^2 u}{\\partial x^2}$ and $\\dfrac{\\partial^2 u}{\\partial y^2}$ using central differences derived from Taylor series expansions.\n\nLet's consider the function $u(x,y)$'s behavior along the line $y=y_j$. The Taylor series for $u(x, y_j)$ expanded around $x=x_i$ with a step size of $h_x$ are given by:\n$$ u(x_i + h_x, y_j) = u(x_i, y_j) + h_x \\frac{\\partial u}{\\partial x}(x_i, y_j) + \\frac{h_x^2}{2} \\frac{\\partial^2 u}{\\partial x^2}(x_i, y_j) + \\frac{h_x^3}{6} \\frac{\\partial^3 u}{\\partial x^3}(x_i, y_j) + \\frac{h_x^4}{24} \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + \\mathcal{O}(h_x^5) $$\n$$ u(x_i - h_x, y_j) = u(x_i, y_j) - h_x \\frac{\\partial u}{\\partial x}(x_i, y_j) + \\frac{h_x^2}{2} \\frac{\\partial^2 u}{\\partial x^2}(x_i, y_j) - \\frac{h_x^3}{6} \\frac{\\partial^3 u}{\\partial x^3}(x_i, y_j) + \\frac{h_x^4}{24} \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + \\mathcal{O}(h_x^5) $$\n\nUsing the compact index notation $u_{i,j} = u(x_i, y_j)$, $u_{i+1, j} = u(x_i+h_x, y_j)$, etc., and adding the two expansions, we eliminate the odd-order derivative terms:\n$$ u_{i+1,j} + u_{i-1,j} = 2u_{i,j} + h_x^2 \\frac{\\partial^2 u}{\\partial x^2}(x_i, y_j) + \\frac{h_x^4}{12} \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + \\mathcal{O}(h_x^6) $$\nNote that the error term becomes $\\mathcal{O}(h_x^6)$ because the $\\mathcal{O}(h_x^5)$ terms from the two series cancel out.\n\nRearranging this equation to solve for the second partial derivative with respect to $x$:\n$$ \\frac{\\partial^2 u}{\\partial x^2}(x_i, y_j) = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} - \\frac{h_x^2}{12} \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + \\mathcal{O}(h_x^4) $$\nThis gives us the central difference approximation for $\\dfrac{\\partial^2 u}{\\partial x^2}$:\n$$ \\delta_{xx}u_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} $$\nThe local truncation error for this approximation is the difference between the exact derivative and its approximation:\n$$ \\tau_{xx} = \\frac{\\partial^2 u}{\\partial x^2}(x_i, y_j) - \\delta_{xx}u_{i,j} = -\\frac{h_x^2}{12} \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + \\mathcal{O}(h_x^4) $$\nThe leading-order term shows that this approximation is second-order accurate in $h_x$.\n\nBy an identical argument for the partial derivative with respect to $y$ with step size $h_y$, we obtain:\n$$ \\frac{\\partial^2 u}{\\partial y^2}(x_i, y_j) = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} - \\frac{h_y^2}{12} \\frac{\\partial^4 u}{\\partial y^4}(x_i, y_j) + \\mathcal{O}(h_y^4) $$\nThe corresponding approximation and truncation error are:\n$$ \\delta_{yy}u_{i,j} = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} $$\n$$ \\tau_{yy} = \\frac{\\partial^2 u}{\\partial y^2}(x_i, y_j) - \\delta_{yy}u_{i,j} = -\\frac{h_y^2}{12} \\frac{\\partial^4 u}{\\partial y^4}(x_i, y_j) + \\mathcal{O}(h_y^4) $$\n\nThe five-point discrete Laplacian, denoted $\\Delta_h u(x_i, y_j)$, is the sum of these two central difference operators:\n$$ \\Delta_h u(x_i, y_j) = \\delta_{xx}u_{i,j} + \\delta_{yy}u_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} $$\nThis can be rewritten as a linear combination of the value at the center point $(i,j)$ and its four nearest neighbors:\n$$ \\Delta_h u_{i,j} = \\frac{1}{h_x^2} u_{i+1,j} + \\frac{1}{h_x^2} u_{i-1,j} + \\frac{1}{h_y^2} u_{i,j+1} + \\frac{1}{h_y^2} u_{i,j-1} - 2\\left(\\frac{1}{h_x^2} + \\frac{1}{h_y^2}\\right)u_{i,j} $$\nThis completes the derivation of the five-point stencil.\n\nThe local truncation error $\\tau$ for the Laplacian approximation is the sum of the truncation errors for the second derivatives:\n$$ \\tau(x_i, y_j) = \\Delta u(x_i, y_j) - \\Delta_h u(x_i, y_j) = \\tau_{xx} + \\tau_{yy} $$\n$$ \\tau(x_i, y_j) = \\left(-\\frac{h_x^2}{12} \\frac{\\partial^4 u}{\\partial x^4} + \\mathcal{O}(h_x^4)\\right) + \\left(-\\frac{h_y^2}{12} \\frac{\\partial^4 u}{\\partial y^4} + \\mathcal{O}(h_y^4)\\right) $$\nAssuming the function $u(x,y)$ is sufficiently smooth (i.e., its fourth partial derivatives are continuous, $u \\in C^4$), the leading-order truncation error is:\n$$ \\tau(x_i,y_j) = -\\frac{1}{12} \\left( h_x^2 \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + h_y^2 \\frac{\\partial^4 u}{\\partial y^4}(x_i, y_j) \\right) + \\text{H.O.T.} $$\nThe order of the local truncation error is therefore $\\mathcal{O}(h_x^2 + h_y^2)$. For an isotropic grid where $h_x = h_y = h$, the error is $\\mathcal{O}(h^2)$.\n\n**Part 2: Grid Refinement and Convergence Order**\n\nThe total error, measured by the maximum norm $E(h_x, h_y) = \\max_{i,j} \\left| \\Delta_h u(x_i,y_j) - \\Delta u(x_i,y_j) \\right|$, is expected to behave proportionally to the local truncation error for stable schemes. Thus, we expect $E \\approx C(h_x^2 + h_y^2)$ for some constant $C$ that depends on the higher derivatives of $u$.\n\nIn our grid refinement study, we successively halve the grid spacings, so $h_k \\to h_{k+1} = h_k/2$. Considering an isotropic grid where $h_x = h_y = h$, we have $E(h) \\approx C h^2$. The error at the next refinement level is $E(h/2) \\approx C (h/2)^2 = (C h^2)/4 = E(h)/4$. The theoretical convergence rate $p$ is calculated as:\n$$ p = \\log_2\\left(\\frac{E(h)}{E(h/2)}\\right) \\approx \\log_2\\left(\\frac{C h^2}{C (h/2)^2}\\right) = \\log_2(4) = 2 $$\nThis confirms the expected second-order convergence of the five-point Laplacian stencil. The same reasoning applies to the anisotropic case where the ratio $h_y/h_x$ is held constant, as the error term $h_x^2 + h_y^2$ will still be proportional to $h_x^2$ (or $h_y^2$), leading to an observed order of $2$. The program will compute this observed order $p_k = \\log_2(E(h_k)/E(h_{k+1}))$ for a sequence of errors $E_k$ corresponding to successively refined meshes. We expect $p_k \\approx 2$ for all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_refinement_study(u_func, lap_u_func, hx_initial, hy_initial):\n    \"\"\"\n    Performs a grid refinement study for a given manufactured solution.\n    Computes errors on 4 successively refined meshes and returns the 3\n    observed convergence orders.\n    \"\"\"\n    errors = []\n    num_meshes = 4\n\n    for k in range(num_meshes):\n        hx = hx_initial / (2**k)\n        hy = hy_initial / (2**k)\n\n        # Determine number of grid points from spacings for the [0,1] domain.\n        # Number of intervals is 1/h. Number of points is num_intervals + 1.\n        # Use rounding to handle potential floating point inaccuracies.\n        nx_intervals = int(round(1.0 / hx))\n        ny_intervals = int(round(1.0 / hy))\n        \n        nx = nx_intervals + 1\n        ny = ny_intervals + 1\n\n        # Create grid coordinates.\n        x = np.linspace(0.0, 1.0, nx)\n        y = np.linspace(0.0, 1.0, ny)\n        \n        # Create 2D grid using 'ij' indexing to align with matrix (row, col) convention.\n        xx, yy = np.meshgrid(x, y, indexing='ij')\n\n        # Evaluate exact solution on the entire grid to get Dirichlet boundary values.\n        U = u_func(xx, yy)\n\n        # Compute the discrete Laplacian on the interior grid points using slicing.\n        # The equation is: (U(i+1,j) - 2U(i,j) + U(i-1,j))/hx^2 + (U(i,j+1) - 2U(i,j) + U(i,j-1))/hy^2\n        # Slices correspond to i from 1 to nx-2 and j from 1 to ny-2.\n        U_center = U[1:-1, 1:-1]\n        term_x = (U[2:, 1:-1] - 2 * U_center + U[:-2, 1:-1]) / (hx**2)\n        term_y = (U[1:-1, 2:] - 2 * U_center + U[1:-1, :-2]) / (hy**2)\n        lap_h_U = term_x + term_y\n\n        # Compute the exact Laplacian on the interior grid points.\n        xx_interior = xx[1:-1, 1:-1]\n        yy_interior = yy[1:-1, 1:-1]\n        lap_U_exact = lap_u_func(xx_interior, yy_interior)\n\n        # Compute the maximum norm of the error over the interior grid.\n        error = np.max(np.abs(lap_h_U - lap_U_exact))\n        errors.append(error)\n\n    # Compute observed orders of convergence, p_k = log2(E_k / E_{k+1}).\n    orders = []\n    for k in range(num_meshes - 1):\n        if errors[k]  0 and errors[k+1]  0:\n            order = np.log2(errors[k] / errors[k+1])\n            orders.append(order)\n        else:\n            # This case (zero error) is not expected with the given functions,\n            # but is included for robustness.\n            orders.append(float('nan')) \n    \n    return orders\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the convergence studies.\n    \"\"\"\n    # Define manufactured solutions and their exact Laplacians.\n    u1 = lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y)\n    lap_u1 = lambda x, y: -2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n    \n    u2 = lambda x, y: np.exp(x + y)\n    lap_u2 = lambda x, y: 2 * np.exp(x + y)\n    \n    u4 = lambda x, y: x**4 + y**4\n    lap_u4 = lambda x, y: 12 * x**2 + 12 * y**2\n\n    # Define the test cases as a list of tuples.\n    # Each tuple: (u_function, laplacian_function, initial_hx, initial_hy)\n    test_cases = [\n        # Case 1: Isotropic grid, trigonometric solution\n        (u1, lap_u1, 1/8, 1/8),\n        # Case 2: Isotropic grid, exponential solution\n        (u2, lap_u2, 1/8, 1/8),\n        # Case 3: Anisotropic grid, trigonometric solution\n        (u1, lap_u1, 1/16, 1/8),\n        # Case 4: Isotropic coarse grid, polynomial solution\n        (u4, lap_u4, 1/4, 1/4),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        u_func, lap_u_func, hx0, hy0 = case\n        orders = run_refinement_study(u_func, lap_u_func, hx0, hy0)\n        # Round orders to 3 decimal places as required.\n        rounded_orders = [round(p, 3) for p in orders]\n        all_results.append(rounded_orders)\n\n    # Format the final output string to match the exact specification.\n    # Example: [[2.000,2.000,2.000],[...]]\n    sublist_strings = []\n    for res in all_results:\n        # Format each number to 3 decimal places to ensure consistent output.\n        formatted_numbers = [f\"{x:.3f}\" for x in res]\n        sublist_strings.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output = f\"[{','.join(sublist_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3230823"}, {"introduction": "While we often talk about a method's 'order of accuracy,' this single number doesn't tell the whole story. This exercise explores the concept of anisotropic error, demonstrating how the five-point stencil's performance depends on the orientation of solution features relative to the grid. By comparing the error for an axis-aligned feature versus a diagonal one, you will gain a more nuanced understanding of the stencil's geometric limitations [@problem_id:2393578].", "problem": "Consider the two-dimensional Poisson equation on the unit square domain, with strong but smooth features whose principal direction is either aligned with the grid axes or diagonally. The mathematical model is the boundary value problem for the scalar field $u(x,y)$ on $[0,1]\\times[0,1]$,\n$$- \\nabla^2 u(x,y) = f(x,y), \\quad (x,y)\\in (0,1)\\times(0,1),$$\nwith Dirichlet boundary condition $u(x,y) = u_{\\text{exact}}(x,y)$ on the boundary $\\partial([0,1]\\times[0,1])$. The Laplacian operator $\\nabla^2$ is defined by $\\nabla^2 u = \\partial^2 u / \\partial x^2 + \\partial^2 u / \\partial y^2$. You must use the standard five-point central-difference finite difference method on a uniform grid to approximate the operator $\\nabla^2$ and solve the resulting linear system for $u(x,y)$ at interior grid points.\n\nUse the method of manufactured solutions to define two exact solutions $u_{\\text{exact}}(x,y)$ whose sharpness is controlled by a width parameter $\\sigma > 0$, and whose directions are:\n- A diagonal ridge aligned with the line $x=y$: \n  $$u_{\\mathrm{diag}}(x,y;\\sigma) = \\exp\\!\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right).$$\n- An axis-aligned ridge along the $x$-axis direction centered at $x=0.5$:\n  $$u_{\\mathrm{axis}}(x,y;\\sigma) = \\exp\\!\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right).$$\n\nFor each manufactured solution, compute its continuous right-hand side $f(x,y)$ by applying the continuous Laplacian $\\nabla^2$ to $u_{\\text{exact}}$ and setting $f(x,y) = -\\nabla^2 u_{\\text{exact}}(x,y)$. For the diagonal ridge, note that $u_{\\mathrm{diag}}(x,y;\\sigma)$ depends on $s=x-y$ only; for a function $g(s)$, use the identities $\\partial^2 g/\\partial x^2 = g''(s)$ and $\\partial^2 g/\\partial y^2 = g''(s)$, which together imply $\\nabla^2 g(s) = 2 g''(s)$. For the axis-aligned ridge, note that $u_{\\mathrm{axis}}(x,y;\\sigma)$ depends only on $x$, so $\\nabla^2 u_{\\mathrm{axis}} = \\partial^2 u_{\\mathrm{axis}}/\\partial x^2$. These operations are all continuous derivatives; do not use discrete approximations to form $f(x,y)$.\n\nDiscretize the domain with a uniform Cartesian grid of $N\\times N$ points with spacing $h = 1/(N-1)$, where $N$ is an odd integer so that the line $y=0.5$ is a grid row. Assemble the standard five-point stencil for the Laplacian on interior points $(i,j)$, enforcing the Dirichlet boundary condition by setting the boundary to the exact manufactured solution. Form and solve the linear system for the interior unknowns using the standard five-point stencil only; do not use any higher-order or nine-point stencils.\n\nAfter computing the numerical solution for both the diagonal and axis-aligned manufactured solutions on the same grid and with the same $\\sigma$, reconstruct the full grid by inserting the exact boundary values. Then, evaluate the following two line-wise maximum absolute errors:\n- The diagonal-line error $E_{\\mathrm{diag}}$: the maximum absolute difference between the numerical and exact solutions along the discrete diagonal grid line $x=y$ (i.e., nodes with indices $i=j$), normalized by the exact maximum amplitude along that line. For $u_{\\mathrm{diag}}$, the exact value along $x=y$ is $1$ for all points on that line.\n- The axis-line error $E_{\\mathrm{axis}}$: the maximum absolute difference between the numerical and exact solutions along the horizontal line $y=0.5$ (i.e., nodes with index $j=(N-1)/2$), normalized by the exact maximum amplitude along that line. For $u_{\\mathrm{axis}}$, the exact peak value along $y=0.5$ occurs at $x=0.5$ and equals $1$.\n\nDefine the failure ratio\n$$R(N,\\sigma) = \\frac{E_{\\mathrm{diag}}}{E_{\\mathrm{axis}}}.$$\nValues $R(N,\\sigma) > 1$ indicate that the five-point stencil exhibits a larger error for the diagonally aligned sharp feature than for the axis-aligned feature, which demonstrates the grid-aligned anisotropy and failure to resolve diagonal sharpness at comparable resolution.\n\nYour program must:\n- Implement the five-point central-difference method to solve the Poisson problem for both $u_{\\mathrm{diag}}$ and $u_{\\mathrm{axis}}$, using the same grid and $\\sigma$.\n- Compute $E_{\\mathrm{diag}}$, $E_{\\mathrm{axis}}$, and $R(N,\\sigma)$ for each test case.\n- Output all ratios as a single list on one line as specified below.\n\nNo physical units are involved. Angles are not used. Express all floating-point outputs in plain decimal notation.\n\nTest suite to evaluate coverage:\n- Case $1$ (under-resolved diagonal feature): $N=33$, $\\sigma=0.02$.\n- Case $2$ (improved resolution): $N=65$, $\\sigma=0.02$.\n- Case $3$ (wider feature on coarse grid): $N=33$, $\\sigma=0.04$.\n\nFinal output format:\n- Your program should produce a single line of output containing the three ratios $R(N,\\sigma)$ corresponding to the cases above, as a comma-separated list enclosed in square brackets and with each value rounded to $6$ decimal places (for example, $[r_1,r_2,r_3]$).", "solution": "The problem presented is a valid and well-posed numerical analysis exercise. It concerns the solution of the two-dimensional Poisson equation using the five-point finite difference method and uses the method of manufactured solutions to analyze the anisotropic error characteristics of the stencil. All required information is provided, the physical and mathematical basis is sound, and the objectives are clear and verifiable.\n\nThe problem is to solve the Poisson equation on a unit square domain $\\Omega = [0,1]\\times[0,1]$:\n$$ - \\nabla^2 u(x,y) = f(x,y), \\quad (x,y) \\in (0,1)\\times(0,1) $$\nwith Dirichlet boundary conditions $u(x,y) = u_{\\text{exact}}(x,y)$ for $(x,y) \\in \\partial\\Omega$. The operator $\\nabla^2$ is the Laplacian, $\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$.\n\nThe method of manufactured solutions is employed. We define two exact solutions, $u_{\\mathrm{diag}}$ and $u_{\\mathrm{axis}}$, and derive the corresponding forcing functions $f(x,y)$ by applying the continuous operator: $f = -\\nabla^2 u_{\\text{exact}}$.\n\nFor the diagonal ridge, $u_{\\mathrm{diag}}(x,y;\\sigma) = \\exp(-\\frac{(x-y)^2}{2\\sigma^2})$. Let $g(s) = \\exp(-s^2/(2\\sigma^2))$ with $s=x-y$. The derivatives are $g'(s) = -\\frac{s}{\\sigma^2}g(s)$ and $g''(s) = (\\frac{s^2}{\\sigma^4} - \\frac{1}{\\sigma^2})g(s)$. Using the identity $\\nabla^2 g(x-y) = 2g''(x-y)$, the forcing function is:\n$$ f_{\\mathrm{diag}}(x,y;\\sigma) = -2 g''(x-y) = -2 \\left(\\frac{(x-y)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right) \\exp\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right) = 2\\left(\\frac{1}{\\sigma^2} - \\frac{(x-y)^2}{\\sigma^4}\\right) \\exp\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right) $$\n\nFor the axis-aligned ridge, $u_{\\mathrm{axis}}(x,y;\\sigma) = \\exp(-\\frac{(x-0.5)^2}{2\\sigma^2})$. This function only depends on $x$. Let $h(x) = \\exp(-(x-0.5)^2/(2\\sigma^2))$. The Laplacian is $\\nabla^2 h(x) = \\frac{d^2h}{dx^2}$. The second derivative is $\\frac{d^2h}{dx^2} = (\\frac{(x-0.5)^2}{\\sigma^4} - \\frac{1}{\\sigma^2})h(x)$. The forcing function is:\n$$ f_{\\mathrm{axis}}(x,y;\\sigma) = -\\frac{d^2u_{\\mathrm{axis}}}{dx^2} = -\\left(\\frac{(x-0.5)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right) \\exp\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right) = \\left(\\frac{1}{\\sigma^2} - \\frac{(x-0.5)^2}{\\sigma^4}\\right) \\exp\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right) $$\n\nThe domain is discretized using a uniform Cartesian grid with $N \\times N$ points, where $N$ is an odd integer. The grid spacing is $h = 1/(N-1)$. Let the grid points be $(x_i, y_j) = (ih, jh)$ for $i,j \\in \\{0, 1, \\dots, N-1\\}$. Let $U_{i,j}$ be the numerical approximation of $u(x_i, y_j)$.\n\nThe standard $5$-point central difference approximation for the negative Laplacian at an interior grid point $(x_i, y_j)$ for $i,j \\in \\{1, \\dots, N-2\\}$ is:\n$$ -\\nabla^2 u(x_i, y_j) \\approx \\frac{-U_{i+1,j} - U_{i-1,j} - U_{i,j+1} - U_{i,j-1} + 4U_{i,j}}{h^2} $$\nSetting this equal to the forcing term $f(x_i, y_j) = f_{i,j}$ gives the discrete equation:\n$$ 4U_{i,j} - U_{i+1,j} - U_{i-1,j} - U_{i,j+1} - U_{i,j-1} = h^2 f_{i,j} $$\nThis system of linear equations must be solved for the $(N-2) \\times (N-2)$ unknown interior values $U_{i,j}$. The values on the boundary (where $i=0$, $i=N-1$, $j=0$, or $j=N-1$) are known from the Dirichlet condition, $U_{i,j} = u_{\\text{exact}}(x_i, y_j)$. These known boundary values are moved to the right-hand side of the equations for interior points adjacent to the boundary.\n\nThis leads to a linear system of the form $A\\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u}$ is a vector of the $(N-2)^2$ unknown interior grid values, $A$ is a sparse, symmetric positive-definite, block-tridiagonal matrix of size $(N-2)^2 \\times (N-2)^2$, and $\\mathbf{b}$ is the right-hand side vector incorporating both the forcing term $f$ and the boundary conditions. The matrix $A$ has $4$ on its main diagonal, and entries of $-1$ corresponding to the four neighbors in the $5$-point stencil. This sparse system is solved numerically.\n\nAfter solving for the interior values, the full numerical solution grid is reconstructed by embedding the interior solution within the known exact boundary values.\n\nThe errors are then evaluated along specific lines. The diagonal-line error $E_{\\mathrm{diag}}$ is computed for the $u_{\\mathrm{diag}}$ case:\n$$ E_{\\mathrm{diag}} = \\frac{\\max_{i \\in \\{0, \\dots, N-1\\}} |U_{i,i} - u_{\\mathrm{diag}}(x_i, x_i)|}{\\max_{i} u_{\\mathrm{diag}}(x_i, x_i)} = \\max_{i} |U_{i,i} - 1| $$\nThe axis-line error $E_{\\mathrm{axis}}$ is computed for the $u_{\\mathrm{axis}}$ case along the line $y=0.5$, which corresponds to grid index $j_{\\text{mid}} = (N-1)/2$:\n$$ E_{\\mathrm{axis}} = \\frac{\\max_{i \\in \\{0, \\dots, N-1\\}} |U_{i,j_{\\text{mid}}} - u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})|}{\\max_{i} u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})} = \\max_{i} |U_{i,j_{\\text{mid}}} - u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})| $$\nIn both cases, the normalizing maximum amplitude of the exact solution along the respective line is $1$.\n\nFinally, the failure ratio $R(N,\\sigma) = E_{\\mathrm{diag}} / E_{\\mathrm{axis}}$ is computed to quantify the stencil's anisotropic error. The provided program implements this entire procedure for each of the specified test cases.", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef u_diag_func(X, Y, sigma):\n    \"\"\"Computes the exact solution for the diagonal ridge case.\"\"\"\n    s_sq = (X - Y)**2\n    sigma_sq = sigma**2\n    return np.exp(-s_sq / (2 * sigma_sq))\n\ndef f_diag_func(X, Y, sigma):\n    \"\"\"Computes the forcing term for the diagonal ridge case.\"\"\"\n    s_sq = (X - Y)**2\n    sigma_sq = sigma**2\n    sigma_4 = sigma**4\n    exp_term = np.exp(-s_sq / (2 * sigma_sq))\n    return 2 * (1 / sigma_sq - s_sq / sigma_4) * exp_term\n\ndef u_axis_func(X, Y, sigma):\n    \"\"\"Computes the exact solution for the axis-aligned ridge case.\"\"\"\n    z_sq = (X - 0.5)**2\n    sigma_sq = sigma**2\n    return np.exp(-z_sq / (2 * sigma_sq))\n\ndef f_axis_func(X, Y, sigma):\n    \"\"\"Computes the forcing term for the axis-aligned ridge case.\"\"\"\n    z_sq = (X - 0.5)**2\n    sigma_sq = sigma**2\n    sigma_4 = sigma**4\n    exp_term = np.exp(-z_sq / (2 * sigma_sq))\n    return (1 / sigma_sq - z_sq / sigma_4) * exp_term\n\ndef solve_poisson(N, sigma, u_exact_func, f_func):\n    \"\"\"\n    Solves the 2D Poisson equation using a 5-point finite difference stencil.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    x = np.linspace(0.0, 1.0, N)\n    y = np.linspace(0.0, 1.0, N)\n    X, Y = np.meshgrid(x, y, indexing='xy')\n\n    # Evaluate exact solution and forcing term on the full grid\n    u_exact = u_exact_func(X, Y, sigma)\n    f = f_func(X, Y, sigma)\n    \n    # Number of interior points in one dimension\n    M = N - 2\n    \n    # Construct the sparse matrix A for the linear system\n    main_diag = np.ones(M) * 4\n    off_diag = np.ones(M - 1) * -1\n    T = sparse.diags([off_diag, main_diag, off_diag], [-1, 0, 1], shape=(M, M), format='csr')\n    I_M = sparse.eye(M, format='csr')\n    A = sparse.kron(I_M, T) + sparse.diags([np.ones(M*(M-1))*-1, np.ones(M*(M-1))*-1], [-M, M], format='csr')\n    A = A.tocsc()\n\n    # Construct the right-hand side vector b\n    b_2d = h**2 * f[1:-1, 1:-1]\n    \n    # Add boundary condition contributions to b\n    # Note: U[j, i] corresponds to u at (x_i, y_j)\n    b_2d[:, 0] += u_exact[1:-1, 0]   # Left boundary (x=0)\n    b_2d[:, -1] += u_exact[1:-1, -1] # Right boundary (x=1)\n    b_2d[0, :] += u_exact[0, 1:-1]   # Bottom boundary (y=0)\n    b_2d[-1, :] += u_exact[-1, 1:-1] # Top boundary (y=1)\n    \n    b = b_2d.flatten(order='F') # Flatten column-major, for (i,j) - k=(i-1)*M+(j-1)\n\n    # Solve the linear system\n    u_vec = spsolve(A, b)\n    \n    # Reshape solution vector to grid and insert into full solution grid\n    U_interior = u_vec.reshape((M, M), order='F')\n    U_numerical = np.copy(u_exact)\n    U_numerical[1:-1, 1:-1] = U_interior\n    \n    return U_numerical, u_exact\n\ndef solve():\n    test_cases = [\n        (33, 0.02),\n        (65, 0.02),\n        (33, 0.04),\n    ]\n\n    results = []\n    for N, sigma in test_cases:\n        # Diagonal case\n        U_diag_numerical, u_exact_diag_grid = solve_poisson(N, sigma, u_diag_func, f_diag_func)\n        diag_numerical = np.diag(U_diag_numerical)\n        diag_exact = np.diag(u_exact_diag_grid)\n        E_diag = np.max(np.abs(diag_numerical - diag_exact))\n\n        # Axis-aligned case\n        U_axis_numerical, u_exact_axis_grid = solve_poisson(N, sigma, u_axis_func, f_axis_func)\n        j_mid = (N - 1) // 2\n        axis_numerical_row = U_axis_numerical[j_mid, :]\n        axis_exact_row = u_exact_axis_grid[j_mid, :]\n        E_axis = np.max(np.abs(axis_numerical_row - axis_exact_row))\n        \n        # Failure ratio\n        R = E_diag / E_axis\n        results.append(R)\n\n    # Format results for printing\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2393578"}, {"introduction": "The theoretical properties of numerical methods often rely on ideal conditions, such as smooth solutions and simple domains. This practice challenges those assumptions by applying the five-point stencil to the Laplace equation on an L-shaped domain, which features a re-entrant corner that induces a singularity in the solution. By observing the degradation of the convergence rate, you will see firsthand how geometric complexities and non-smoothness impact numerical accuracy, motivating the need for more advanced techniques in real-world problems [@problem_id:3230895].", "problem": "Consider the Dirichlet boundary value problem for the Laplace equation on an L-shaped domain. Let the computational box be the square $[-1,1]\\times[-1,1]$ and define the L-shaped domain $\\Omega$ by removing the first quadrant, that is $\\Omega = \\{(x,y)\\in[-1,1]\\times[-1,1] : \\lnot(x>0 \\land y>0)\\}$. The governing equation is the Laplace equation $\\Delta u = 0$ in $\\Omega$, with Dirichlet boundary condition $u = g$ prescribed on $\\partial\\Omega$. The boundary data is chosen by restricting an analytic, harmonic function that exhibits a singular gradient at the re-entrant corner of $\\Omega$. Using polar coordinates $(r,\\theta)$ centered at $(0,0)$ with $\\theta$ measured in radians, define the shifted angle $\\theta' = \\theta - \\frac{\\pi}{2}$, adjusted to the interval $[0,2\\pi)$ by adding $2\\pi$ when necessary. Let the exact harmonic function be\n$$\nu_{\\text{exact}}(r,\\theta) = r^{\\frac{2}{3}} \\sin\\!\\left(\\frac{2}{3}\\,\\theta'\\right),\n$$\nwhich satisfies $\\Delta u_{\\text{exact}}=0$ away from $r=0$ and is compatible with zero boundary values on the two rays forming the re-entrant corner with interior angle $3\\pi/2$. The Dirichlet boundary condition is set as $g = u_{\\text{exact}}$ on the entire boundary $\\partial\\Omega$.\n\nStarting from the Taylor expansion of a sufficiently smooth function on a uniform Cartesian grid, derive the standard $5$-point discrete approximation to the Laplace operator $\\Delta u$ and use it to assemble and solve the discrete Dirichlet problem on the grid restricted to $\\Omega$. The uniform grid spacing is $h = \\frac{1}{m}$, with grid nodes at coordinates $x_i = -1 + i h$ and $y_j = -1 + j h$ for integer indices $i,j \\in \\{0,1,\\dots,2m\\}$. A grid node $(x_i,y_j)$ is in $\\Omega$ if it is not in the removed first quadrant, that is $i \\le m$ or $j \\le m$ (or both). A grid node is a Dirichlet boundary node if it lies on the outer box boundary (any of $i=0$, $i=2m$, $j=0$, $j=2m$) or on one of the interior boundaries aligned with the coordinate axes forming the re-entrant corner (that is $(i=m$ and $j\\ge m)$ or $(j=m$ and $i\\ge m)$). All other nodes in $\\Omega$ are interior unknowns. Angles must be treated in radians.\n\nFor error analysis, let $u_h$ denote the numerical solution interpolated at grid nodes, and measure the error on the set of interior unknowns using the discrete uniform norm\n$$\nE_{\\infty}(h) = \\max_{(x_i,y_j)\\in\\Omega_{\\text{int}}} \\left|u_h(x_i,y_j) - u_{\\text{exact}}(x_i,y_j)\\right|,\n$$\nwhere $\\Omega_{\\text{int}}$ denotes the set of interior unknown grid nodes. Define the observed order of accuracy between two grid spacings $h_1$ and $h_2$ by\n$$\np(h_1\\rightarrow h_2) = \\frac{\\log\\!\\left(E_{\\infty}(h_2)/E_{\\infty}(h_1)\\right)}{\\log\\!\\left(h_2/h_1\\right)}.\n$$\nDue to the singularity at the re-entrant corner, the global convergence rate is expected to be reduced below the nominal second order associated with smooth solutions.\n\nImplement a complete, runnable program that:\n- Constructs the discrete system using the derived $5$-point stencil and imposes Dirichlet boundary conditions from $u_{\\text{exact}}$.\n- Solves the resulting linear system for the interior unknowns.\n- Computes $E_{\\infty}(h)$ for each test grid.\n\nTest suite:\n- Use three grid resolutions with $m\\in\\{4,8,16\\}$, corresponding to $h\\in\\{\\frac{1}{4},\\frac{1}{8},\\frac{1}{16}\\}$.\n- For coverage: $m=4$ is a coarse resolution (edge case near the singular corner), $m=8$ is an intermediate case (happy path), and $m=16$ is a finer resolution.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- The list must contain the following entries in order:\n[$E_{\\infty}\\!\\left(\\tfrac{1}{4}\\right)$, $E_{\\infty}\\!\\left(\\tfrac{1}{8}\\right)$, $E_{\\infty}\\!\\left(\\tfrac{1}{16}\\right)$, $p\\!\\left(\\tfrac{1}{4}\\rightarrow\\tfrac{1}{8}\\right)$, $p\\!\\left(\\tfrac{1}{8}\\rightarrow\\tfrac{1}{16}\\right)$, $\\text{flag}_{4\\rightarrow 8}$, $\\text{flag}_{8\\rightarrow 16}$],\nwhere each $E_{\\infty}(h)$ and $p(\\cdot)$ is a floating-point number, and each $\\text{flag}$ is a boolean equal to $\\text{True}$ if the observed order is strictly less than $2$ and $\\text{False}$ otherwise. Angles used in computing $u_{\\text{exact}}$ must be handled in radians.", "solution": "The user wants to solve the Laplace equation on an L-shaped domain with a singular solution, and analyze the convergence of the 5-point finite difference method.\n\n### Step 1: Derivation of the 5-Point Laplacian Stencil\n\nThe foundation of the finite difference method is the approximation of derivatives using Taylor series expansions of a function at nearby points. Let $u(x,y)$ be a sufficiently smooth function defined on a domain. We consider a uniform Cartesian grid with spacing $h$ in both the $x$ and $y$ directions.\n\nThe Taylor expansion of $u(x,y)$ around a point $(x,y)$ for its neighbors along the x-axis are:\n$$\nu(x+h, y) = u(x,y) + h \\frac{\\partial u}{\\partial x}(x,y) + \\frac{h^2}{2!} \\frac{\\partial^2 u}{\\partial x^2}(x,y) + \\frac{h^3}{3!} \\frac{\\partial^3 u}{\\partial x^3}(x,y) + O(h^4)\n$$\n$$\nu(x-h, y) = u(x,y) - h \\frac{\\partial u}{\\partial x}(x,y) + \\frac{h^2}{2!} \\frac{\\partial^2 u}{\\partial x^2}(x,y) - \\frac{h^3}{3!} \\frac{\\partial^3 u}{\\partial x^3}(x,y) + O(h^4)\n$$\n\nAdding these two equations eliminates the odd-order derivative terms:\n$$\nu(x+h, y) + u(x-h, y) = 2u(x,y) + h^2 \\frac{\\partial^2 u}{\\partial x^2}(x,y) + O(h^4)\n$$\n\nSolving for the second partial derivative with respect to $x$ gives the second-order accurate central difference approximation:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x,y) = \\frac{u(x+h, y) - 2u(x,y) + u(x-h, y)}{h^2} + O(h^2)\n$$\n\nBy an identical argument for the $y$ direction, we obtain:\n$$\n\\frac{\\partial^2 u}{\\partial y^2}(x,y) = \\frac{u(x, y+h) - 2u(x,y) + u(x, y-h)}{h^2} + O(h^2)\n$$\n\nThe Laplace operator $\\Delta u$ is defined as $\\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$. Substituting the central difference approximations, we get:\n$$\n\\Delta u(x,y) \\approx \\frac{u(x+h, y) - 2u(x,y) + u(x-h, y)}{h^2} + \\frac{u(x, y+h) - 2u(x,y) + u(x, y-h)}{h^2}\n$$\n$$\n\\Delta u(x,y) \\approx \\frac{u(x+h, y) + u(x-h, y) + u(x, y+h) + u(x, y-h) - 4u(x,y)}{h^2}\n$$\nThe truncation error of this approximation is $O(h^2)$, assuming sufficient smoothness of $u$.\n\nThe problem is to solve the Laplace equation, $\\Delta u = 0$. Using the discrete approximation, for each interior grid node $(x_i, y_j)$, we have the equation:\n$$\n\\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} = 0\n$$\nwhere $u_{i,j}$ denotes the numerical approximation $u_h(x_i, y_j)$. This simplifies to:\n$$\n4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} = 0\n$$\nThis linear equation relates the value at a node to the values at its four cardinal neighbors, forming the well-known 5-point stencil for the Laplacian.\n\n### Step 2: Assembling and Solving the Discrete System\n\nThe problem is defined on an L-shaped domain $\\Omega$, discretized by a uniform grid. The grid nodes are classified into three types:\n1.  **Interior nodes**: Nodes inside $\\Omega$ where the value of $u$ is unknown.\n2.  **Boundary nodes**: Nodes on the boundary $\\partial\\Omega$ where the value of $u$ is prescribed by the Dirichlet condition $u=g$.\n3.  **Exterior nodes**: Nodes outside the domain $\\Omega$ (in the removed first quadrant), which are not part of the computation.\n\nFor each interior node, we write one instance of the 5-point stencil equation. This results in a system of linear equations, which can be written in matrix form as $A\\mathbf{U} = \\mathbf{b}$, where:\n-   $\\mathbf{U}$ is a vector of the unknown values of $u$ at all interior nodes.\n-   $A$ is the coefficient matrix derived from the stencil.\n-   $\\mathbf{b}$ is the right-hand side vector, which incorporates the known values from the boundary nodes.\n\nLet there be $N_{\\text{int}}$ interior nodes. We map each interior node's 2D grid index $(i,j)$ to a unique 1D index $k \\in \\{0, 1, ..., N_{\\text{int}}-1\\}$. The matrix $A$ will be an $N_{\\text{int}} \\times N_{\\text{int}}$ sparse matrix. For the equation corresponding to the $k$-th interior node (at grid location $(i,j)$):\n-   The diagonal element of the matrix is $A_{k,k} = 4$.\n-   For each neighbor $(i', j')$ of $(i,j)$:\n    -   If the neighbor is also an interior node with 1D index $k'$, the corresponding off-diagonal element is $A_{k, k'} = -1$.\n    -   If the neighbor is a boundary node, its value $u_{i',j'}$ is known from the boundary condition $g(x_{i'}, y_{j'})$. The term $-u_{i',j'}$ is moved to the right side of the equation. So, the value $u_{i',j'}$ is added to the $k$-th element of the vector $\\mathbf{b}$.\n\nAfter assembling the matrix $A$ and vector $\\mathbf{b}$ for all interior nodes, the linear system $A\\mathbf{U} = \\mathbf{b}$ is solved for the vector of unknowns $\\mathbf{U}$. The matrix $A$ is diagonally dominant and non-singular, guaranteeing a unique solution.\n\n### Step 3: Error Analysis\n\nThe analytical solution $u_{\\text{exact}}$ is given in polar coordinates $(r,\\theta)$:\n$$\nu_{\\text{exact}}(r,\\theta) = r^{\\frac{2}{3}} \\sin\\!\\left(\\frac{2}{3}\\,\\theta'\\right)\n$$\nwhere $\\theta' = (\\theta - \\pi/2) \\pmod{2\\pi}$. This function has a singularity at the origin $(r=0)$, where its gradient is unbounded. Standard finite difference theory predicts second-order convergence ($O(h^2)$) for smooth solutions. However, the presence of the singularity at the re-entrant corner reduces the global order of accuracy. The expected order is $\\alpha = 2/3$, corresponding to the exponent of $r$ in the leading singular term of the solution.\n\nThe implementation will carry out the following:\n1.  For each grid resolution $m \\in \\{4, 8, 16\\}$, construct the grid and classify nodes.\n2.  Map interior nodes to indices and determine the size of the linear system, $N_{\\text{int}}$.\n3.  Assemble the $N_{\\text{int}} \\times N_{\\text{int}}$ matrix $A$ and the $N_{\\text{int}}$-dimensional vector $\\mathbf{b}$. Boundary values are calculated using the provided $u_{\\text{exact}}$ function.\n4.  Solve the linear system $A\\mathbf{U} = \\mathbf{b}$ using a direct solver.\n5.  Compute the maximum absolute error $E_{\\infty}(h) = \\max |u_h - u_{\\text{exact}}|$ over all interior nodes.\n6.  Use the computed errors for different $h$ values to calculate the observed order of accuracy, $p$.\n7.  Check if the observed order $p$ is strictly less than $2$.\n\nThis procedure is implemented for the specified test suite to produce the required output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef u_exact_func(x: float, y: float) - float:\n    \"\"\"\n    Computes the value of the exact analytical solution at a point (x, y).\n\n    Args:\n        x: The x-coordinate.\n        y: The y-coordinate.\n\n    Returns:\n        The value of the exact solution u(x, y).\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    if r == 0.0:\n        return 0.0\n    \n    # atan2(y, x) gives angle in (-pi, pi]. We need it in [0, 2pi).\n    theta = np.arctan2(y, x)\n    \n    # Shifted angle theta' = theta - pi/2, adjusted to [0, 2pi)\n    theta_prime = theta - np.pi / 2.0\n    if theta_prime  0:\n        theta_prime += 2 * np.pi\n\n    alpha = 2.0 / 3.0\n    return r**alpha * np.sin(alpha * theta_prime)\n\ndef compute_error_for_m(m: int) - float:\n    \"\"\"\n    Solves the Laplace equation on an L-shaped domain for a given grid parameter m\n    and returns the maximum error on the interior nodes.\n\n    Args:\n        m: The grid resolution parameter.\n\n    Returns:\n        The discrete uniform norm of the error, E_infinity(h).\n    \"\"\"\n    h = 1.0 / m\n    dim = 2 * m + 1\n    \n    # Create coordinate vectors for the grid\n    coords = -1.0 + np.arange(dim) * h\n    \n    # Classify nodes and map interior nodes to a 1D index\n    interior_nodes_map = {}  # (i, j) - k\n    interior_nodes_list = []  # k - (i, j)\n    k = 0\n    \n    # Use boolean arrays for efficient node type checking\n    is_boundary_node = np.zeros((dim, dim), dtype=bool)\n    is_domain_node = np.zeros((dim, dim), dtype=bool)\n\n    for j in range(dim):\n        for i in range(dim):\n            # Node is in the computational domain if not in the removed quadrant.\n            # Removed quadrant is x  0 and y  0, which corresponds to i  m and j  m.\n            if not(i  m and j  m):\n                is_domain_node[i, j] = True\n    \n    for j in range(dim):\n        for i in range(dim):\n            if not is_domain_node[i, j]:\n                continue\n            \n            # A node is boundary if on outer box or on the re-entrant corner boundary\n            if (i == 0 or i == 2*m or j == 0 or j == 2*m or\n                (i == m and j = m) or (j == m and i = m)):\n                is_boundary_node[i, j] = True\n            else:\n                # It's an interior node\n                interior_nodes_map[(i, j)] = k\n                interior_nodes_list.append((i, j))\n                k += 1\n\n    num_interior = len(interior_nodes_list)\n    A = np.zeros((num_interior, num_interior))\n    b = np.zeros(num_interior)\n\n    # Assemble matrix A and vector b\n    for current_k, (i, j) in enumerate(interior_nodes_list):\n        A[current_k, current_k] = 4.0\n        \n        # Consider the four neighbors\n        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\n        for ni, nj in neighbors:\n            if not is_boundary_node[ni, nj]:\n                # Neighbor is an interior node\n                neighbor_k = interior_nodes_map[(ni, nj)]\n                A[current_k, neighbor_k] = -1.0\n            else:\n                # Neighbor is a boundary node, so its value is known\n                x_n, y_n = coords[ni], coords[nj]\n                b[current_k] += u_exact_func(x_n, y_n)\n\n    # Solve the linear system for interior node values\n    if num_interior  0:\n        U_interior_vec = np.linalg.solve(A, b)\n    else:\n        U_interior_vec = np.array([])\n\n    # Calculate the maximum error on the interior nodes\n    max_error = 0.0\n    for k in range(num_interior):\n        i, j = interior_nodes_list[k]\n        x_i, y_j = coords[i], coords[j]\n        \n        numerical_val = U_interior_vec[k]\n        exact_val = u_exact_func(x_i, y_j)\n        \n        error = np.abs(numerical_val - exact_val)\n        if error  max_error:\n            max_error = error\n            \n    return max_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n    test_cases = [4, 8, 16]\n    \n    errors = [compute_error_for_m(m) for m in test_cases]\n    \n    h_values = [1.0/m for m in test_cases]\n\n    # Calculate observed orders of accuracy\n    p1 = np.log(errors[1] / errors[0]) / np.log(h_values[1] / h_values[0])\n    p2 = np.log(errors[2] / errors[1]) / np.log(h_values[2] / h_values[1])\n    \n    # Check if a convergence order is strictly less than 2\n    flag1 = p1  2.0\n    flag2 = p2  2.0\n    \n    results = [\n        errors[0],\n        errors[1],\n        errors[2],\n        p1,\n        p2,\n        flag1,\n        flag2\n    ]\n    \n    # Format the final output string\n    # str() on a boolean produces 'True' or 'False' as required.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3230895"}]}