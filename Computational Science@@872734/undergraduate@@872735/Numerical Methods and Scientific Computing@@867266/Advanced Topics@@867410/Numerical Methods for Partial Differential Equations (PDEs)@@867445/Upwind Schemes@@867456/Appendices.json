{"hands_on_practices": [{"introduction": "The linear advection equation, $\\partial_t u + a \\partial_x u = 0$, is the archetypal model for transport phenomena. This first practice introduces the foundational first-order upwind scheme, a robust and intuitive method for solving this equation numerically. By simulating the movement of a sharp interface (a Heaviside step function), you will directly observe the scheme's behavior, including its stability under the Courant–Friedrichs–Lewy (CFL) condition and its characteristic numerical diffusion, which tends to smear sharp profiles [@problem_id:2448567]. This exercise is essential for building a practical understanding of the trade-offs involved in basic hyperbolic solvers.", "problem": "Consider the one-dimensional linear advection equation for a scalar field $u(x,t)$ with constant advection speed $a$,\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\\quad x \\in [x_{\\min},x_{\\max}],\\ t \\ge 0,\n$$\nwith the initial condition given by the Heaviside step function\n$$\nu(x,0) = H(x - x_0),\\quad H(\\xi) = \\begin{cases}\n1, \\xi \\ge 0,\\\\\n0, \\xi  0.\n\\end{cases}\n$$\nImpose inflow boundary conditions consistent with the far-field states of the initial data: if $a  0$, enforce $u(x_{\\min},t)=0$ for all $t \\ge 0$; if $a  0$, enforce $u(x_{\\max},t)=1$ for all $t \\ge 0$. All quantities are dimensionless.\n\nAdvance the solution in time on a uniform spatial grid of $N$ points in $[x_{\\min},x_{\\max}]$ up to a final time $T$, with a time step $\\Delta t$ chosen to satisfy a specified Courant–Friedrichs–Lewy (CFL) number $C$, where\n$$\nC = \\frac{|a|\\,\\Delta t}{\\Delta x},\\quad \\Delta x = \\frac{x_{\\max} - x_{\\min}}{N-1}.\n$$\nUse a first-order upwind discretization consistent with the sign of $a$. For each test case below, compute the discrete $\\ell^1$ error at time $T$ defined by\n$$\nE_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x,\n$$\nwhere $x_i$ are the grid points, $u_i^{\\text{num}}(T)$ is the numerical solution at time $T$, and the analytical solution is the translated step\n$$\nu^{\\text{exact}}(x,T) = H\\!\\left( x - (x_0 + a\\,T) \\right),\n$$\nwhich is valid for the times and parameters given below because the advected discontinuity remains strictly inside the interval $[x_{\\min},x_{\\max}]$ and does not interact with the boundaries.\n\nTest Suite (each test case is a tuple $(a,x_{\\min},x_{\\max},x_0,N,T,C)$):\n- Test $1$: $(1.0,\\,0.0,\\,1.0,\\,0.25,\\,401,\\,0.2,\\,0.5)$.\n- Test $2$: $(-0.7,\\,0.0,\\,1.0,\\,0.8,\\,401,\\,0.15,\\,0.8)$.\n- Test $3$: $(1.0,\\,0.0,\\,1.0,\\,0.3,\\,201,\\,0.3,\\,1.0)$.\n\nYour program must compute $E_1$ for each test in the order listed and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each number rounded to six decimal places (for example, $[0.123456,0.000000,1.234568]$).", "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It presents a standard task in computational physics: solving the linear advection equation using a first-order upwind scheme and evaluating the numerical error. All parameters and conditions are clearly defined.\n\nThe governing equation is the one-dimensional linear advection equation for a scalar field $u(x,t)$ with a constant advection speed $a$:\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0\n$$\nTo solve this equation numerically, we discretize the spatio-temporal domain. The spatial domain $[x_{\\min}, x_{\\max}]$ is divided into a uniform grid of $N$ points, $x_i = x_{\\min} + i\\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = (x_{\\max} - x_{\\min}) / (N-1)$. Time is advanced in discrete steps, and we denote the numerical approximation of $u(x_i, t^n)$ as $u_i^n$.\n\nThe time derivative $\\partial_t u$ is approximated using a first-order forward difference (Forward Euler method):\n$$\n\\partial_t u(x_i, t^n) \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\nThe first-order upwind scheme approximates the spatial derivative $\\partial_x u$ using a one-sided finite difference. The choice of the one-sided stencil depends on the direction of information propagation, which is given by the sign of the advection speed $a$. This ensures that the numerical method draws information from the \"upwind\" direction, a crucial property for the stability of hyperbolic solvers.\n\nCase 1: $a  0$\nInformation propagates from left to right (in the positive $x$ direction). The spatial derivative at $x_i$ is approximated using a backward difference, which involves the point upwind, $x_{i-1}$:\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n$$\nSubstituting these discrete approximations into the partial differential equation yields the update rule:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = 0\n$$\nSolving for the solution at the next time step, $u_i^{n+1}$:\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n) = u_i^n - C (u_i^n - u_{i-1}^n)\n$$\nwhere $C = \\frac{a \\Delta t}{\\Delta x}$ is the Courant–Friedrichs–Lewy (CFL) number, as $a0$. This scheme is applied for $i=1, \\dots, N-1$.\n\nCase 2: $a  0$\nInformation propagates from right to left (in the negative $x$ direction). The spatial derivative is approximated using a forward difference, involving the upwind point $x_{i+1}$:\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n$$\nThe corresponding update rule is:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_{i+1}^n - u_i^n}{\\Delta x} = 0\n$$\nSolving for $u_i^{n+1}$:\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n) = u_i^n + C (u_{i+1}^n - u_i^n)\n$$\nHere, the CFL number is defined as $C = \\frac{|a| \\Delta t}{\\Delta x} = \\frac{-a \\Delta t}{\\Delta x}$, which means $\\frac{a \\Delta t}{\\Delta x} = -C$. This scheme is applied for $i=0, \\dots, N-2$.\n\nThe stability of this explicit time-stepping scheme is guaranteed if the CFL condition, $C \\le 1$, is met. All test cases provided satisfy this condition.\n\nThe simulation proceeds as follows:\n1.  **Initialization**: For each test case $(a, x_{\\min}, x_{\\max}, x_0, N, T, C)$, the grid spacing $\\Delta x$ and nominal time step $\\Delta t = C \\Delta x / |a|$ are calculated. The solution array $u$ is initialized with the Heaviside function $u(x,0) = H(x - x_0)$.\n2.  **Time Evolution**: A loop advances the solution from $t=0$ to $T$. To ensure the final time $T$ is reached precisely, the time step for each iteration is calculated as $\\Delta t_{\\text{curr}} = \\min(\\Delta t, T - t)$. This handles cases where $T$ is not an integer multiple of $\\Delta t$.\n3.  **Update Step**: Inside the loop, a copy of the solution $u^n$ is made. The new solution $u^{n+1}$ is computed for all interior points using the appropriate upwind formula, with the update coefficient scaled by $\\Delta t_{\\text{curr}}$.\n4.  **Boundary Conditions**: After computing the interior-point updates, the inflow boundary condition is enforced. If $a  0$, the value at the left boundary is set: $u_0^{n+1} = 0$. If $a  0$, the value at the right boundary is set: $u_{N-1}^{n+1} = 1$. The outflow boundary requires no special treatment as it is handled by the one-sided nature of the upwind stencil.\n5.  **Error Calculation**: Once the simulation reaches $t=T$, the final numerical solution $u_i^{\\text{num}}(T)$ is obtained. The analytical solution $u^{\\text{exact}}(x_i,T) = H(x_i - (x_0 + aT))$ is computed on the same grid. The discrete $\\ell^1$ error is then calculated using the formula:\n    $$\n    E_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x\n    $$\nFor the test case where $C=1.0$, the scheme (for $a0$) simplifies to $u_i^{n+1} = u_{i-1}^n$. This corresponds to an exact shift of the discrete data by one grid cell per time step. Since the total time $T$ is chosen such that the total advection distance $aT$ is an integer multiple of $\\Delta x$, the numerical solution on the grid is identical to the exact solution, resulting in zero error. For $C  1$, the scheme introduces numerical diffusion, which smears the sharp step and produces a non-zero error.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation for multiple test cases\n    using a first-order upwind scheme and computes the l1 error.\n    \"\"\"\n    test_cases = [\n        # (a, x_min, x_max, x_0, N, T, C)\n        (1.0, 0.0, 1.0, 0.25, 401, 0.2, 0.5),\n        (-0.7, 0.0, 1.0, 0.8, 401, 0.15, 0.8),\n        (1.0, 0.0, 1.0, 0.3, 201, 0.3, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(*case)\n        # Append result formatted to six decimal places.\n        results.append(f\"{error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(a, x_min, x_max, x_0, N, T, C):\n    \"\"\"\n    Runs a single simulation case for the 1D linear advection equation.\n\n    Args:\n        a (float): Advection speed.\n        x_min (float): Minimum of the spatial domain.\n        x_max (float): Maximum of the spatial domain.\n        x_0 (float): Initial position of the step in the Heaviside function.\n        N (int): Number of grid points.\n        T (float): Final time.\n        C (float): Courant–Friedrichs–Lewy (CFL) number.\n\n    Returns:\n        float: The discrete l1 error at the final time T.\n    \"\"\"\n    # 1. Setup grid and initial condition\n    dx = (x_max - x_min) / (N - 1)\n    x = np.linspace(x_min, x_max, N)\n    # The problem defines H(xi) = 1 for xi = 0. np.heaviside with second arg 1.0 does this.\n    u = np.heaviside(x - x_0, 1.0)\n\n    # 2. Setup time stepping\n    # The advection speed 'a' is non-zero in all test cases.\n    dt_nominal = C * dx / abs(a)\n    \n    # 3. Time integration loop\n    t = 0.0\n    # Use a small tolerance for floating point comparison to ensure loop termination.\n    while t  T:\n        # Determine current time step to not step over T.\n        current_dt = min(dt_nominal, T - t)\n        \n        # Make a copy of the solution at the current time step 'n'.\n        u_n = u.copy()\n        \n        # The update coefficient nu = a * dt / dx\n        nu = a * current_dt / dx\n        \n        if a  0:\n            # FTBS (Forward-Time, Backward-Space) for a  0\n            # u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n)\n            u[1:] = u_n[1:] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_min\n            u[0] = 0.0\n        else: # a  0\n            # FTFS (Forward-Time, Forward-Space) for a  0\n            # u_i^{n+1} = u_i^n - nu * (u_{i+1}^n - u_i^n)\n            u[:-1] = u_n[:-1] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_max\n            u[-1] = 1.0\n            \n        t += current_dt\n\n    # 4. Calculate exact solution at time T\n    x_final_discontinuity = x_0 + a * T\n    u_exact = np.heaviside(x - x_final_discontinuity, 1.0)\n    \n    # 5. Compute the discrete l1 error\n    error = np.sum(np.abs(u - u_exact)) * dx\n    \n    return error\n\nsolve()\n```", "id": "2448567"}, {"introduction": "Real-world flows are rarely uniform; velocity can vary dramatically in space. This exercise elevates the upwind concept from a fixed stencil to a dynamic principle by considering an advection speed $a(x)$ that changes sign within the domain. You will implement a method that locally queries the flow direction at each grid point to ensure the discretization always draws information from the correct \"upwind\" side [@problem_id:3285398]. This practice reinforces the physical reasoning behind upwinding and is a critical step toward modeling more complex systems where flow patterns may include convergence, divergence, and recirculation.", "problem": "Consider the one-dimensional linear advection equation with space-dependent speed,\n$$\nu_t(x,t) + a(x)\\,u_x(x,t) = 0,\\quad x\\in[0,1],\\ t\\ge 0,\n$$\nwhere $u(x,t)$ is a transported scalar field and $a(x)$ is a prescribed, sufficiently smooth speed that may change sign over the spatial domain. For a hyperbolic transport equation, information travels along characteristic curves determined by the sign of $a(x)$, and a stable discretization must use values from the upwind direction. Your task is to implement a first-order explicit upwind finite difference method that switches stencils according to the local sign of $a(x)$, and to quantify properties of this switching and of the resulting discrete solution.\n\nImplement the following design in a single, complete program:\n- Discretize $[0,1]$ using a uniform grid of $N$ points $x_i = i\\,\\Delta x$ for $i=0,1,\\dots,N-1$ with $\\Delta x = 1/(N-1)$.\n- Use a single explicit Euler time stepper with time step $\\Delta t$ satisfying the Courant-Friedrichs-Lewy (CFL) stability condition, specifically\n$$\n\\Delta t = \\lambda\\,\\frac{\\Delta x}{\\max_{0\\le i\\le N-1} |a(x_i)|},\n$$\nwhere $0\\lambda\\le 1$ is the Courant number.\n- At each interior grid point $i=1,2,\\dots,N-2$, approximate $u_x(x_i,t)$ by a one-sided difference taken from the upwind direction, chosen by the sign of $a(x_i)$: use a backward difference if $a(x_i)0$, use a forward difference if $a(x_i)0$, and set the derivative contribution to zero when $a(x_i)=0$ (no transport).\n- Impose Dirichlet boundary values $u(0,t) = u_L$ and $u(1,t) = u_R$ for all $t\\ge 0$. Note that, for a hyperbolic flow, these act as inflow values where characteristic information enters the domain; on outflow boundaries they do not influence interior updates because the upwind stencil does not reference them.\n- Advance the numerical solution for $K$ explicit Euler steps.\n\nFrom first principles, this method must be derived using the causality of the hyperbolic transport equation and the directionality of characteristics implied by the sign of $a(x)$. In particular, the backward difference is consistent with $a(x)0$ because information at $x_i$ arrives from $x_{i-1}$, whereas the forward difference is consistent with $a(x)0$ because information at $x_i$ arrives from $x_{i+1}$.\n\nDefine the following discrete diagnostics to be computed by your program for each test case:\n1. The integer number of interior points $i=1,\\dots,N-2$ where the method uses a backward difference (i.e., points with $a(x_i)0$).\n2. The integer number of interior points $i=1,\\dots,N-2$ where the method uses a forward difference (i.e., points with $a(x_i)0$).\n3. The integer number of sign-change interfaces in the discrete speed field, defined as the count of indices $i=0,\\dots,N-2$ such that $\\operatorname{sign}(a(x_i))\\ne \\operatorname{sign}(a(x_{i+1}))$, with the convention $\\operatorname{sign}(0)=0$.\n4. A boolean indicating whether, after $K$ steps, the discrete solution satisfies a discrete maximum principle relative to the envelope of the initial and boundary data, namely whether\n$$\n\\min_{0\\le i\\le N-1} u^K_i \\ge \\min\\left(\\min_{0\\le i\\le N-1} u^0_i,\\ u_L,\\ u_R\\right)\n\\quad\\text{and}\\quad\n\\max_{0\\le i\\le N-1} u^K_i \\le \\max\\left(\\max_{0\\le i\\le N-1} u^0_i,\\ u_L,\\ u_R\\right),\n$$\nwhere $u^n_i$ denotes the numerical solution at grid point $x_i$ after $n$ time steps.\n\nUse the following test suite of parameter values to exercise different facets of the method:\n- Test case A (general case with a single jump and distinct magnitudes):\n  - $N=51$, $\\lambda=0.9$, $K=25$,\n  - $a(x)=\\begin{cases}1, x0.5\\\\ -0.5, x\\ge 0.5\\end{cases}$,\n  - $u_L=0$, $u_R=1$,\n  - $u_0(x)=\\sin(2\\pi x)$.\n- Test case B (boundary-aligned zero speed, exact sign reversal at a grid point):\n  - $N=51$, $\\lambda=0.9$, $K=30$,\n  - $a(x)=x-0.5$,\n  - $u_L=0.5$, $u_R=-0.5$,\n  - $u_0(x)=1-2|x-0.5|$.\n- Test case C (smooth sign change with rapidly varying transition):\n  - $N=101$, $\\lambda=0.9$, $K=40$,\n  - $a(x)=\\tanh\\big(20(0.7-x)\\big)$,\n  - $u_L=1$, $u_R=-1$,\n  - $u_0(x)=\\cos(4\\pi x)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must itself be a comma-separated list in square brackets in the order described above. For example, the output format must be\n$$\n[\\,[n_{\\text{back}},n_{\\text{fwd}},n_{\\text{sign}},\\text{mp}],\\,[\\dots],\\,[\\dots]\\,],\n$$\nwhere $n_{\\text{back}}$ and $n_{\\text{fwd}}$ are integers, $n_{\\text{sign}}$ is an integer, and $\\text{mp}$ is a boolean.", "solution": "The user-provided problem is assessed to be valid. It is a well-posed, scientifically grounded problem in the field of numerical analysis for partial differential equations, with all necessary components clearly defined.\n\nThe problem requires the implementation of a first-order explicit upwind finite difference method for the one-dimensional linear advection equation with a space-dependent, sign-changing advection speed $a(x)$:\n$$\nu_t(x,t) + a(x)\\,u_x(x,t) = 0\n$$\nThe fundamental principle governing this problem is that of hyperbolic causality. Information for hyperbolic equations, such as the advection equation, propagates along characteristic curves. The trajectory of these curves in the $(x,t)$-plane is defined by the ordinary differential equation $dx/dt = a(x)$. The sign of the speed $a(x)$ dictates the direction of information flow: if $a(x)0$, information travels from left to right, and if $a(x)0$, it travels from right to left. A stable numerical scheme must respect this physical causality by differencing in the \"upwind\" direction—the direction from which information arrives.\n\nThe solution is discretized on a uniform spatial grid of $N$ points, $x_i = i\\,\\Delta x$ for $i=0, 1, \\dots, N-1$, with grid spacing $\\Delta x = 1/(N-1)$. Time is advanced using an explicit Euler method with a time step $\\Delta t$. The semi-discretized equation at grid point $x_i$ is:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a(x_i) (u_x)_i^n = 0\n$$\nwhich gives the update formula $u_i^{n+1} = u_i^n - \\Delta t \\, a(x_i) (u_x)_i^n$.\n\nThe core of the upwind method lies in the approximation of the spatial derivative, $(u_x)_i^n$. The choice of stencil is determined by the local sign of the advection speed $a(x_i)$:\n1.  If $a(x_i)  0$, the flow is from left to right. Information at $x_i$ comes from $x_{i-1}$. The spatial derivative is approximated using a first-order backward difference:\n    $$\n    (u_x)_i^n \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n    $$\n2.  If $a(x_i)  0$, the flow is from right to left. Information at $x_i$ comes from $x_{i+1}$. The spatial derivative is approximated using a first-order forward difference:\n    $$\n    (u_x)_i^n \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n    $$\n3.  If $a(x_i) = 0$, there is no transport at $x_i$. The advection term $a(x_i)u_x$ is zero, and the solution does not change: $u_i^{n+1} = u_i^n$.\n\nCombining these, the full update scheme for interior points $i=1, \\dots, N-2$ is:\n$$\nu_i^{n+1} = \\begin{cases}\nu_i^n - \\frac{a(x_i)\\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n),  \\text{if } a(x_i)  0 \\\\\nu_i^n - \\frac{a(x_i)\\Delta t}{\\Delta x}(u_{i+1}^n - u_i^n),  \\text{if } a(x_i)  0 \\\\\nu_i^n,  \\text{if } a(x_i) = 0\n\\end{cases}\n$$\nThis explicit scheme is stable under the Courant-Friedrichs-Lewy (CFL) condition, which requires the numerical domain of dependence to contain the physical one. This translates to the constraint $|a(x_i)|\\Delta t / \\Delta x \\le 1$ for all $i$. To ensure stability across the entire grid, the time step $\\Delta t$ is chosen based on the maximum speed:\n$$\n\\Delta t = \\lambda \\frac{\\Delta x}{\\max_{i} |a(x_i)|}\n$$\nwhere $\\lambda \\in (0, 1]$ is the Courant number.\n\nThe Dirichlet boundary conditions $u(0,t) = u_L$ and $u(1,t) = u_R$ are enforced by setting $u_0^n = u_L$ and $u_{N-1}^n = u_R$ for all time steps $n$. These values provide the necessary upwind data for interior points adjacent to the boundary when the flow is directed into the domain. For example, at $i=1$, if $a(x_1)0$, the stencil requires $u_0^n = u_L$. Conversely, if the flow is directed out of the domain (e.g., $a(x_1)0$), the boundary value $u_L$ is not used in the update for $u_1^n$, correctly reflecting the physics of outflow.\n\nThe implementation proceeds by first defining the discrete grid and evaluating the speed field $a(x_i)$ and initial condition $u_i^0$ at all grid points. The diagnostic quantities related to the speed field ($n_{\\text{back}}$, $n_{\\text{fwd}}$, $n_{\\text{sign}}$) are computed once. Then, the solution is advanced for $K$ time steps, where each step involves updating all interior points according to the upwind logic described above. After $K$ steps, the final solution $u_i^K$ is used to check the discrete maximum principle. This principle, which states that the scheme does not create new extrema, is a key property of this method and is satisfied if the CFL condition holds. It is verified by comparing the minimum and maximum of the final solution against the envelope of the initial data and boundary values.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, lambda_cfl, K, a_func, u_L, u_R, u0_func):\n    \"\"\"\n    Solves the 1D advection equation with a space-dependent speed\n    using a first-order upwind scheme and computes specified diagnostics.\n    \"\"\"\n    # 1. Grid and Field Setup\n    x = np.linspace(0.0, 1.0, N)\n    dx = 1.0 / (N - 1)\n    \n    a = a_func(x)\n    u = u0_func(x)\n    u_initial = u.copy()\n\n    # 2. Pre-computation of Diagnostics\n    # Number of interior points with backward/forward differences\n    interior_a = a[1:-1]\n    n_back = int(np.sum(interior_a  0))\n    n_fwd = int(np.sum(interior_a  0))\n\n    # Number of sign-change interfaces in the discrete speed field\n    signs = np.sign(a)\n    n_sign = int(np.sum(signs[:-1] != signs[1:]))\n\n    # 3. Time Step Calculation\n    a_max = np.max(np.abs(a))\n    if a_max == 0:\n        # Avoid division by zero if a(x) is identically zero.\n        # dt can be anything, as nothing will change.\n        dt = 1.0\n    else:\n        dt = lambda_cfl * dx / a_max\n\n    # 4. Time-stepping Loop\n    u[0] = u_L\n    u[N - 1] = u_R\n    \n    for _ in range(K):\n        u_old = u.copy()\n        \n        # Vectorized update for interior points, can be slow. A loop is clearer and sufficient for these N.\n        for i in range(1, N - 1):\n            a_i = a[i]\n            if a_i  0:\n                # Backward difference for u_x\n                grad_u = (u_old[i] - u_old[i-1]) / dx\n                u[i] = u_old[i] - dt * a_i * grad_u\n            elif a_i  0:\n                # Forward difference for u_x\n                grad_u = (u_old[i+1] - u_old[i]) / dx\n                u[i] = u_old[i] - dt * a_i * grad_u\n            # If a_i == 0, u[i] remains u_old[i], so no operation needed.\n    \n    # 5. Post-computation of Diagnostics (Maximum Principle)\n    min_bound = min(np.min(u_initial), u_L, u_R)\n    max_bound = max(np.max(u_initial), u_L, u_R)\n    \n    # Use a small tolerance for floating-point comparisons\n    tol = 1e-9\n    mp = bool((np.min(u) = min_bound - tol) and (np.max(u) = max_bound + tol))\n\n    return [n_back, n_fwd, n_sign, mp]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 51, \"lambda_cfl\": 0.9, \"K\": 25,\n            \"a_func\": lambda x: np.where(x  0.5, 1.0, -0.5),\n            \"u_L\": 0.0, \"u_R\": 1.0,\n            \"u0_func\": lambda x: np.sin(2 * np.pi * x)\n        },\n        {\n            \"N\": 51, \"lambda_cfl\": 0.9, \"K\": 30,\n            \"a_func\": lambda x: x - 0.5,\n            \"u_L\": 0.5, \"u_R\": -0.5,\n            \"u0_func\": lambda x: 1.0 - 2.0 * np.abs(x - 0.5)\n        },\n        {\n            \"N\": 101, \"lambda_cfl\": 0.9, \"K\": 40,\n            \"a_func\": lambda x: np.tanh(20 * (0.7 - x)),\n            \"u_L\": 1.0, \"u_R\": -1.0,\n            \"u0_func\": lambda x: np.cos(4 * np.pi * x)\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_simulation(\n            case[\"N\"], case[\"lambda_cfl\"], case[\"K\"],\n            case[\"a_func\"], case[\"u_L\"], case[\"u_R\"], case[\"u0_func\"]\n        )\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    inner_results_str = []\n    for res in all_results:\n        # res is a list like [n_back, n_fwd, n_sign, mp_bool]\n        inner_str = f\"[{res[0]},{res[1]},{res[2]},{str(res[3]).lower()}]\"\n        inner_results_str.append(inner_str)\n    \n    final_output_str = f\"[{','.join(inner_results_str)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3285398"}, {"introduction": "While robust, the first-order upwind scheme suffers from significant numerical diffusion, which limits its accuracy. This advanced practice guides you in overcoming this limitation by constructing a modern, high-resolution finite volume scheme. You will implement a second-order accurate MUSCL (Monotone Upstream-centered Schemes for Conservation Laws) method, which uses a more sophisticated reconstruction of the solution inside each grid cell [@problem_id:3285423]. A key focus will be the implementation of a `minmod` flux limiter, a \"smart\" component that automatically reverts the scheme to a robust first-order method near sharp gradients to prevent spurious oscillations, thus achieving both high accuracy in smooth regions and stability at discontinuities.", "problem": "Consider the scalar conservation law $u_t + f(u)_x = 0$ on the periodic spatial domain $x \\in [0,1]$ with period $1$. Focus on the linear advection case $f(u) = a u$, where $a$ is a constant wave speed. The goal is to construct a second-order Monotone Upstream-centered Schemes for Conservation Laws (MUSCL) finite volume method with a minmod flux limiter and Strong Stability Preserving (SSP) second-order Runge–Kutta time integration, and to demonstrate that the limiter reverts the method to first-order accuracy near discontinuities to prevent spurious oscillations.\n\nStart from the cell averages $u_i(t)$ over cells $I_i = [x_i - \\tfrac{1}{2}\\Delta x, x_i + \\tfrac{1}{2}\\Delta x]$, with uniform spacing $\\Delta x = \\tfrac{1}{N}$ and cell centers $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$, for $i = 0,1,\\dots,N-1$. The finite volume semi-discrete form is\n$$\n\\frac{d u_i}{d t} = -\\frac{F_{i+\\tfrac{1}{2}} - F_{i-\\tfrac{1}{2}}}{\\Delta x},\n$$\nwhere $F_{i+\\tfrac{1}{2}}$ is a consistent numerical flux at the cell interface $x_{i+\\tfrac{1}{2}}$. Use an upwind numerical flux for linear advection:\n$$\nF_{i+\\tfrac{1}{2}} =\n\\begin{cases}\na\\,u_{i+\\tfrac{1}{2}}^{-},  \\text{if } a \\ge 0, \\\\\na\\,u_{i+\\tfrac{1}{2}}^{+},  \\text{if } a  0,\n\\end{cases}\n$$\nwhere $u_{i+\\tfrac{1}{2}}^{-}$ and $u_{i+\\tfrac{1}{2}}^{+}$ are the left and right reconstructed interface states, respectively. Use MUSCL reconstruction with the minmod limiter based on one-sided differences\n$$\ns_i = \\operatorname{minmod}\\left(u_i - u_{i-1}, \\; u_{i+1} - u_i\\right),\n$$\nand\n$$\nu_{i+\\tfrac{1}{2}}^{-} = u_i + \\frac{1}{2} s_i, \\quad\nu_{i+\\tfrac{1}{2}}^{+} = u_{i+1} - \\frac{1}{2} s_{i+1}.\n$$\nThe minmod function is defined by\n$$\n\\operatorname{minmod}(a,b) =\n\\begin{cases}\n\\operatorname{sign}(a)\\,\\min\\left(|a|,|b|\\right),  \\text{if } a\\,b  0, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\nUse periodic boundary conditions, so indices wrap modulo $N$. Advance in time with the Strong Stability Preserving second-order Runge–Kutta (SSP RK2) method, also known as the Shu–Osher scheme:\n$$\n\\begin{aligned}\nu^{(1)} = u^n + \\Delta t\\,L(u^n), \\\\\nu^{(2)} = u^{(1)} + \\Delta t\\,L(u^{(1)}), \\\\\nu^{n+1} = \\frac{1}{2}\\left(u^n + u^{(2)}\\right),\n\\end{aligned}\n$$\nwhere $L(u)$ is the spatial operator defined by $L(u)_i = -\\dfrac{F_{i+\\tfrac{1}{2}}(u) - F_{i-\\tfrac{1}{2}}(u)}{\\Delta x}$ and $\\Delta t$ is chosen by the Courant–Friedrichs–Lewy (CFL) condition $\\Delta t = \\text{CFL} \\cdot \\dfrac{\\Delta x}{|a|}$ with $\\text{CFL} = 0.9$. Integrate to a final time $T$ by taking as many steps of size $\\Delta t$ as needed, using a shorter last step if necessary to end exactly at $t=T$.\n\nImplement this method and apply it to the following test suite. In all cases, use $N=200$, $\\Delta x = \\tfrac{1}{N}$, and the specified $a$, $T$, and initial data $u_0(x)$ sampled at cell centers $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$.\n\n- Test case $1$ (smooth transport): $a=1$, $T=0.2$, $u_0(x) = \\sin(2\\pi x)$. Compute the exact solution $u_{\\text{exact}}(x,T) = \\sin\\left(2\\pi(x - a T)\\right)$ and report the discrete $\\ell^1$ error\n$$\nE_1 = \\sum_{i=0}^{N-1} \\left|u_i(T) - u_{\\text{exact}}(x_i,T)\\right| \\Delta x,\n$$\nas a floating-point number.\n\n- Test case $2$ (discontinuous transport, limiter clipping near edges): $a=1$, $T=0.2$, $u_0(x) = \\begin{cases} 1,  x \\in [0,0.5), \\\\ 0,  x \\in [0.5,1). \\end{cases}$ After evolving to $t=T$, compute the one-sided differences $d_i^- = u_i - u_{i-1}$ and $d_i^+ = u_{i+1} - u_i$. Define a small threshold $\\varepsilon = 10^{-6}$. Count the indices where the minmod limiter is clipped by a sign change, i.e., where $d_i^-\\,d_i^+ \\le 0$ and $\\max\\{|d_i^-|,|d_i^+|\\}  \\varepsilon$. Report the fraction\n$$\nE_2 = \\frac{\\#\\left\\{i : d_i^-\\,d_i^+ \\le 0 \\text{ and } \\max\\{|d_i^-|,|d_i^+|\\}  \\varepsilon \\right\\}}{N}\n$$\nas a floating-point number. This quantifies where the scheme locally reverts to first-order upwind behavior to suppress oscillations.\n\n- Test case $3$ (negative-speed transport, Total Variation Diminishing behavior): $a=-1$, $T=0.2$, $u_0(x)$ as in test case $2$. Compute the total variation $\\operatorname{TV}(u) = \\sum_{i=0}^{N-1} |u_{i+1} - u_i|$ with periodic indexing, both initially and at final time. Report the change\n$$\nE_3 = \\operatorname{TV}(u(T)) - \\operatorname{TV}(u(0)),\n$$\nas a floating-point number. For a Total Variation Diminishing (TVD) scheme, one expects $E_3 \\le 0$ up to small numerical tolerances.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[E_1,E_2,E_3]$.", "solution": "The problem presented is a well-posed and standard exercise in the field of numerical methods for partial differential equations. It requires the implementation of a second-order accurate finite volume scheme for the linear advection equation. All components of the numerical method—the MUSCL reconstruction, the minmod limiter, the upwind flux, and the SSP RK2 time integration—are precisely defined. The parameters and test cases are specified completely, allowing for a unique and verifiable solution. The problem is scientifically sound and algorithmically formalizable. Therefore, a solution is warranted.\n\nThe core of the problem is to solve the scalar linear advection equation, a prototype for hyperbolic conservation laws:\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial (a u)}{\\partial x} = 0,\n$$\non a periodic domain $x \\in [0, 1]$. Here, $u(x,t)$ is the conserved quantity and $a$ is the constant wave speed. We employ a finite volume method, which evolves the cell averages $u_i(t)$ of the solution over discrete grid cells $I_i = [x_i - \\frac{1}{2}\\Delta x, x_i + \\frac{1}{2}\\Delta x]$, where $\\Delta x = 1/N$ is the uniform cell width. The semi-discrete form of the conservation law is:\n$$\n\\frac{d u_i}{dt} = L(u)_i = -\\frac{F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}}{\\Delta x},\n$$\nwhere $L(u)$ represents the spatial discretization operator and $F_{i+\\frac{1}{2}}$ is the numerical flux at the interface between cells $I_i$ and $I_{i+1}$.\n\nTo achieve second-order spatial accuracy, a piece-wise linear reconstruction of the solution within each cell is performed using the Monotone Upstream-centered Schemes for Conservation Laws (MUSCL) approach. For each cell $I_i$, we approximate $u(x,t)$ with a linear function:\n$$\nu(x,t) \\approx u_i(t) + \\frac{s_i}{\\Delta x} (x - x_i),\n$$\nwhere $s_i$ is a carefully chosen, limited slope. This reconstruction provides values for the solution at the left and right sides of each cell interface. Specifically, at the interface $x_{i+\\frac{1}{2}}$, the value reconstructed from the left cell $I_i$ is denoted $u_{i+\\frac{1}{2}}^{-}$ and from the right cell $I_{i+1}$ is denoted $u_{i+\\frac{1}{2}}^{+}$. Evaluating the linear reconstructions at the interface yields:\n$$\nu_{i+\\frac{1}{2}}^{-} = u_i + \\frac{1}{2}s_i, \\quad u_{i+\\frac{1}{2}}^{+} = u_{i+1} - \\frac{1}{2}s_{i+1}.\n$$\nTo prevent spurious oscillations near discontinuities (Gibbs phenomenon), the slopes $s_i$ must be limited. The problem specifies the minmod limiter, which is defined based on the differences between neighboring cell averages:\n$$\ns_i = \\operatorname{minmod}(u_i - u_{i-1}, u_{i+1} - u_i).\n$$\nThe minmod function ensures that the reconstruction is non-oscillatory. It is defined as:\n$$\n\\operatorname{minmod}(a,b) =\n\\begin{cases}\n\\operatorname{sign}(a)\\,\\min(|a|,|b|),  \\text{if } a\\,b  0, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\nIf the forward difference $u_{i+1} - u_i$ and the backward difference $u_i - u_{i-1}$ have the same sign, minmod chooses the one with the smaller magnitude, promoting a conservative slope. If they have different signs, which happens at local extrema, the slope $s_i$ is set to $0$. This locally reduces the scheme to a first-order upwind method, which is robust but diffusive, thereby clipping the incipient oscillation. Periodic boundary conditions are enforced by treating indices cyclically modulo $N$.\n\nThe numerical flux $F_{i+\\frac{1}{2}}$ is determined by an upwind principle, which selects the interface value based on the direction of information propagation, given by the sign of the wave speed $a$. For linear advection, this is:\n$$\nF_{i+\\frac{1}{2}} =\n\\begin{cases}\na\\,u_{i+\\frac{1}{2}}^{-},  \\text{if } a \\ge 0, \\\\\na\\,u_{i+\\frac{1}{2}}^{+},  \\text{if } a  0.\n\\end{cases}\n$$\n\nFor time integration, the problem specifies the second-order Strong Stability Preserving Runge-Kutta (SSP RK2) method, also known as the Shu-Osher scheme. This method is chosen because it preserves the non-oscillatory properties (like being Total Variation Diminishing, TVD) of the spatial discretization under a suitable CFL condition. Given a solution $u^n$ at time $t_n$, the solution $u^{n+1}$ at time $t_{n+1} = t_n + \\Delta t$ is computed via:\n$$\n\\begin{aligned}\nu^{(1)} = u^n + \\Delta t\\,L(u^n), \\\\\nu^{(2)} = u^{(1)} + \\Delta t\\,L(u^{(1)}), \\\\\nu^{n+1} = \\frac{1}{2}(u^n + u^{(2)}).\n\\end{aligned}\n$$\nThe time step $\\Delta t$ is constrained by the Courant-Friedrichs-Lewy (CFL) condition to ensure stability, with $\\Delta t = \\text{CFL} \\cdot \\frac{\\Delta x}{|a|}$ and a given $\\text{CFL}=0.9$. The integration proceeds from $t=0$ to the final time $t=T$, using a smaller final time step if necessary to land exactly at $T$.\n\nThe three test cases are designed to probe different aspects of the scheme's performance:\n1.  **Case 1 (Smooth Solution)**: A smooth sine wave initial condition is used. On a smooth solution, the minmod limiter should be inactive for most cells, allowing the scheme to demonstrate its designed second-order accuracy. The discrete $\\ell^1$ error, $E_1$, quantifies the accuracy.\n2.  **Case 2 (Discontinuous Solution)**: A square wave initial condition introduces sharp discontinuities. The metric $E_2$ quantifies the fraction of cells where the limiter is activated by a sign change in local differences. This demonstrates the scheme's adaptive mechanism, reverting to first-order at discontinuities to maintain stability.\n3.  **Case 3 (TVD Property)**: Using the same discontinuous profile but with a negative wave speed, this case tests the Total Variation Diminishing (TVD) property. For a non-oscillatory scheme, the total variation $\\operatorname{TV}(u) = \\sum_i |u_{i+1} - u_i|$ should not increase in time. The change in total variation, $E_3 = \\operatorname{TV}(u(T)) - \\operatorname{TV}(u(0))$, is expected to be less than or equal to zero, up to minor numerical floating-point inaccuracies.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a second-order MUSCL finite volume scheme for the linear\n    advection equation and runs a suite of tests.\n    \"\"\"\n\n    def minmod(a, b):\n        \"\"\"Vectorized minmod function.\"\"\"\n        ab = a * b\n        s = np.sign(a)\n        return np.where(ab  0, s * np.minimum(np.abs(a), np.abs(b)), 0)\n\n    def l_operator(u, a, dx):\n        \"\"\"\n        Computes the spatial operator L(u), representing the semi-discrete\n        form of the advection equation.\n        \"\"\"\n        # Periodic boundary conditions are handled by np.roll\n        # u_prev[i] = u[i-1], u_next[i] = u[i+1]\n        u_prev = np.roll(u, 1)\n        u_next = np.roll(u, -1)\n\n        # 1. Slope Calculation with minmod limiter\n        diff_bwd = u - u_prev\n        diff_fwd = u_next - u\n        s = minmod(diff_bwd, diff_fwd)\n\n        # 2. Reconstruction at cell interfaces i+1/2\n        # u_minus is the state on the left side of the interface, from cell i\n        # u_plus is the state on the right side of the interface, from cell i+1\n        u_minus = u + 0.5 * s\n        s_next = np.roll(s, -1)\n        u_plus = u_next - 0.5 * s_next\n        \n        # 3. Upwind Flux Calculation\n        if a = 0:\n            flux = a * u_minus\n        else:\n            flux = a * u_plus\n            \n        # 4. Flux differencing\n        # L(u)_i = -(F_{i+1/2} - F_{i-1/2}) / dx\n        flux_prev = np.roll(flux, 1)\n        return -(flux - flux_prev) / dx\n        \n    def time_stepper(u0, a, T, N, dx, cfl):\n        \"\"\"\n        Evolves the solution u from t=0 to t=T using SSP RK2.\n        \"\"\"\n        u = np.copy(u0)\n        t = 0.0\n        # Calculate base time step from CFL condition\n        # Handle a=0 case to avoid division by zero, although not in tests.\n        if abs(a) > 0:\n            dt_base = cfl * dx / abs(a)\n        else:\n            dt_base = float('inf')\n\n        while t  T:\n            # Use a small tolerance for floating point comparison to ensure loop termination\n            if abs(t - T)  1e-12:\n                break\n            \n            dt = min(dt_base, T - t)\n            \n            # SSP RK2 (Shu-Osher)\n            u1 = u + dt * l_operator(u, a, dx)\n            u2 = u1 + dt * l_operator(u1, a, dx)\n            u = 0.5 * (u + u2)\n            \n            t += dt\n            \n        return u\n\n    # General Parameters\n    N = 200\n    DX = 1.0 / N\n    CFL = 0.9\n    X_CELLS = (np.arange(N) + 0.5) * DX\n    \n    results = []\n\n    # --- Test Case 1: Smooth Transport ---\n    a1 = 1.0\n    T1 = 0.2\n    u0_1 = np.sin(2 * np.pi * X_CELLS)\n    u_final_1 = time_stepper(u0_1, a1, T1, N, DX, CFL)\n    u_exact_1 = np.sin(2 * np.pi * (X_CELLS - a1 * T1))\n    e1 = np.sum(np.abs(u_final_1 - u_exact_1)) * DX\n    results.append(e1)\n\n    # --- Test Case 2: Discontinuous Transport ---\n    a2 = 1.0\n    T2 = 0.2\n    u0_2 = np.where(X_CELLS  0.5, 1.0, 0.0)\n    u_final_2 = time_stepper(u0_2, a2, T2, N, DX, CFL)\n    \n    # Calculate one-sided differences\n    d_minus = u_final_2 - np.roll(u_final_2, 1)\n    d_plus = np.roll(u_final_2, -1) - u_final_2\n    \n    # Count where limiter is active due to sign change near edges\n    epsilon = 1e-6\n    cond1 = (d_minus * d_plus) = 0\n    cond2 = np.maximum(np.abs(d_minus), np.abs(d_plus)) > epsilon\n    limiter_activations = np.sum(cond1  cond2)\n    e2 = limiter_activations / N\n    results.append(e2)\n\n    # --- Test Case 3: Negative Speed and TVD ---\n    a3 = -1.0\n    T3 = 0.2\n    u0_3 = np.where(X_CELLS  0.5, 1.0, 0.0)\n    \n    # Initial Total Variation\n    tv0 = np.sum(np.abs(np.roll(u0_3, -1) - u0_3))\n    \n    u_final_3 = time_stepper(u0_3, a3, T3, N, DX, CFL)\n    \n    # Final Total Variation\n    tvT = np.sum(np.abs(np.roll(u_final_3, -1) - u_final_3))\n    \n    e3 = tvT - tv0\n    results.append(e3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3285423"}]}