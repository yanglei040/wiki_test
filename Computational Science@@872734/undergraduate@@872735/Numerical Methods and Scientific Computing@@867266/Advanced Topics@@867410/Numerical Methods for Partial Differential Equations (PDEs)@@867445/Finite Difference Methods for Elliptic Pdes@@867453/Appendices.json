{"hands_on_practices": [{"introduction": "This first practice takes you through the entire workflow of solving a fundamental elliptic PDE. You will start from first principles—Taylor series expansions—to derive the classic five-point stencil for the 2D Poisson equation. This exercise will not only solidify your theoretical understanding but also challenge you to implement an efficient, matrix-free iterative solver to handle the large linear systems that arise. By computing the experimental order of convergence for both smooth and singular solutions, you will gain critical insight into how a solution's regularity impacts the accuracy of numerical methods [@problem_id:3228788].", "problem": "Consider the two-dimensional Poisson equation on the unit square domain $\\Omega = (0,1) \\times (0,1)$ with Dirichlet boundary condition,\n$$\n-\\Delta u(x,y) = f(x,y) \\quad \\text{in } \\Omega, \n\\qquad\nu(x,y) = g(x,y) \\quad \\text{on } \\partial\\Omega.\n$$\nStart from the definition of the Laplace operator in two dimensions and the classical central difference approximation for second derivatives derived from Taylor expansions. Using only these fundamentals, derive the standard five-point finite difference method on a uniform grid of mesh spacing $h = 1/N$ with interior nodes $(x_i,y_j) = (ih,jh)$ for $i,j \\in \\{1,\\dots,N-1\\}$:\n$$\n\\frac{4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2} = f_{i,j},\n$$\nwhere boundary values $u_{i,j}$ on $\\partial\\Omega$ are prescribed by $g(x,y)$. Explain why, under the assumption $u \\in C^4(\\overline{\\Omega})$, the local truncation error is $\\mathcal{O}(h^2)$ and how the discrete maximum principle leads to a global error bound $\\lVert u - u_h \\rVert_\\infty = \\mathcal{O}(h^2)$.\n\nNext, implement a solver for the discrete linear system that arises from this scheme using the Conjugate Gradient iteration applied to the symmetric positive definite matrix associated with the five-point stencil. The solver must be matrix-free: apply the discrete operator to grid functions directly via the stencil, and account for Dirichlet boundary data by adding known boundary contributions to the right-hand side. Use a stopping criterion based on the reduction of the residual norm to a user-specified tolerance relative to the right-hand side norm.\n\nYou will validate error estimates and observed convergence rates for two exact solutions. In each case, set $g(x,y) = u(x,y)$ on $\\partial \\Omega$ and set $f(x,y) = -\\Delta u(x,y)$ in $\\Omega$. For each mesh size, compute the discrete solution $u_h$, embed it into the full grid including boundary nodes, and compute the maximum-norm error\n$$\nE(h) = \\max_{0 \\le i,j \\le N} \\left| u(x_i,y_j) - u_h(x_i,y_j) \\right|.\n$$\nGiven a list of mesh spacings $\\{h_k\\}$ with corresponding errors $\\{E(h_k)\\}$, estimate the Experimental Order of Convergence (EOC) as the least-squares slope $p$ in the relation $\\log E(h) \\approx \\log C + p \\log h$.\n\nUse the following two exact solutions:\n- Smooth solution: $u_s(x,y) = \\sin(\\pi x)\\sin(\\pi y)$, for which $f_s(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$ and $g_s = u_s$.\n- Singular solution: $u_{sg}(x,y) = r^\\alpha$ with $\\alpha = 3/2$ and $r = \\sqrt{x^2 + y^2}$, for which for $r>0$ one has $\\Delta u_{sg}(x,y) = \\alpha^2 r^{\\alpha - 2}$, hence $f_{sg}(x,y) = -\\alpha^2 r^{\\alpha - 2}$ and $g_{sg} = u_{sg}$. Define $f_{sg}(0,0)$ by continuity if needed; note that $(0,0)$ is a boundary point and therefore not an interior node.\n\nDesign a program that performs the following test suite and reports the EOC for each case:\n- Case A (happy path, smooth and well-resolved): use $N \\in \\{8,16,32,64\\}$ with $u_s$.\n- Case B (reduced regularity, singular near a boundary corner): use $N \\in \\{8,16,32,64\\}$ with $u_{sg}$ and $\\alpha = 3/2$.\n- Case C (boundary coarse resolution edge case): use $N \\in \\{4,8,16\\}$ with $u_s$.\n\nYour program must implement the five-point method, the matrix-free Conjugate Gradient solver, the error computation in the maximum norm, and the least-squares EOC estimation. For each case, perform a linear regression of $\\log E(h)$ against $\\log h$ and report the estimated slope $p$.\n\nNo physical units are involved. All angles, where present, are in radians. The final output must be a single line containing a comma-separated list of the three EOC estimates for the cases A, B, and C, rounded to three decimal places and enclosed in square brackets, in the order [A,B,C]. For example, if the three estimated orders are $p_A$, $p_B$, and $p_C$, your program should output a single line of the form\n$[p_A,p_B,p_C]$.", "solution": "The problem is valid as it represents a well-posed, standard exercise in the numerical analysis of partial differential equations, grounded in established mathematical principles. It is self-contained, objective, and its requirements are algorithmically formalizable.\n\nThe task involves deriving the five-point finite difference scheme for the Poisson equation, analyzing its error, and implementing a matrix-free Conjugate Gradient solver to compute the experimental order of convergence (EOC) for two different test cases.\n\n### Part 1: Derivation of the Five-Point Stencil\n\nWe start with the two-dimensional Poisson equation on the unit square $\\Omega = (0,1) \\times (0,1)$:\n$$\n-\\Delta u(x,y) = f(x,y)\n$$\nwhere $\\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$ is the Laplace operator. The domain is discretized using a uniform grid with mesh spacing $h=1/N$ in both directions. The grid points are $(x_i, y_j) = (ih, jh)$ for integers $i,j \\in \\{0, 1, \\dots, N\\}$. We seek an approximation $u_{i,j} \\approx u(x_i, y_j)$.\n\nThe core of the finite difference method is to approximate derivatives using Taylor series expansions. Consider the expansion of a sufficiently smooth function $u(x,y)$ around a point $(x_i, y_j)$:\n$$\nu(x_i \\pm h, y_j) = u(x_i, y_j) \\pm h \\frac{\\partial u}{\\partial x}(x_i, y_j) + \\frac{h^2}{2} \\frac{\\partial^2 u}{\\partial x^2}(x_i, y_j) \\pm \\frac{h^3}{6} \\frac{\\partial^3 u}{\\partial x^3}(x_i, y_j) + \\frac{h^4}{24} \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + \\mathcal{O}(h^5)\n$$\nSumming the expansions for $u(x_i+h, y_j)$ and $u(x_i-h, y_j)$:\n$$\nu(x_{i+1}, y_j) + u(x_{i-1}, y_j) = 2u(x_i, y_j) + h^2 \\frac{\\partial^2 u}{\\partial x^2}(x_i, y_j) + \\frac{h^4}{12} \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + \\mathcal{O}(h^6)\n$$\nRearranging to solve for the second partial derivative with respect to $x$ gives the second-order central difference approximation:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i, y_j) = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} - \\frac{h^2}{12} \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + \\mathcal{O}(h^4)\n$$\nBy an identical argument for the $y$ direction:\n$$\n\\frac{\\partial^2 u}{\\partial y^2}(x_i, y_j) = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} - \\frac{h^2}{12} \\frac{\\partial^4 u}{\\partial y^4}(x_i, y_j) + \\mathcal{O}(h^4)\n$$\nSumming these two expressions provides an approximation for the Laplacian:\n$$\n\\Delta u(x_i, y_j) = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} - \\frac{h^2}{12} \\left( \\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4} \\right)(x_i, y_j) + \\mathcal{O}(h^4)\n$$\nWe define the discrete Laplacian operator, denoted $\\Delta_h$, as:\n$$\n\\Delta_h u_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2}\n$$\nSubstituting this into the Poisson equation, $-\\Delta u(x_i, y_j) = f(x_i, y_j)$, and ignoring the higher-order terms leads to the five-point finite difference scheme for interior nodes $(i,j)$ where $i,j \\in \\{1, \\dots, N-1\\}$:\n$$\n-\\Delta_h u_{i,j} = \\frac{4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2} = f_{i,j}\n$$\nwhere $f_{i,j} = f(x_i, y_j)$. This is the desired formula.\n\n### Part 2: Local Truncation Error and Global Error\n\nThe local truncation error (LTE), $\\tau_{i,j}$, is the residual obtained when the exact solution $u(x,y)$ is inserted into the discrete equation. Let $L_h = -\\Delta_h$. The discrete system is $L_h u_h = f$, where $u_h$ is the numerical solution vector. Applying the operator to the exact solution $u$:\n$$\n\\tau_{i,j} = L_h u(x_i, y_j) - f(x_i, y_j) = L_h u(x_i, y_j) - (-\\Delta u(x_i, y_j))\n$$\nFrom the Taylor expansion analysis above, we have:\n$$\n\\Delta_h u(x_i, y_j) = \\Delta u(x_i, y_j) + \\frac{h^2}{12} \\left( \\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4} \\right)(x_i, y_j) + \\mathcal{O}(h^4)\n$$\nTherefore, the LTE is:\n$$\n\\tau_{i,j} = - \\left( \\Delta u(x_i, y_j) + \\frac{h^2}{12} \\left( \\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4} \\right) + \\mathcal{O}(h^4) \\right) + \\Delta u(x_i, y_j)\n$$\n$$\n\\tau_{i,j} = - \\frac{h^2}{12} \\left( \\frac{\\partial^4 u}{\\partial x^4}(x_i,y_j) + \\frac{\\partial^4 u}{\\partial y^4}(x_i,y_j) \\right) + \\mathcal{O}(h^4)\n$$\nIf the exact solution $u$ is in $C^4(\\overline{\\Omega})$, meaning its fourth-order partial derivatives are continuous and thus bounded on the closed domain $\\Omega$, then there exists a constant $M$ such that $|\\frac{\\partial^4 u}{\\partial x^4}| \\le M$ and $|\\frac{\\partial^4 u}{\\partial y^4}| \\le M$. Consequently, the maximum norm of the LTE is bounded by:\n$$\n\\lVert \\tau \\rVert_\\infty = \\max_{i,j} |\\tau_{i,j}| \\le \\frac{h^2}{12} (M+M) + \\mathcal{O}(h^4) = \\mathcal{O}(h^2)\n$$\nThe scheme is consistent with order $2$.\n\nThe global error is defined as $e_{i,j} = u(x_i, y_j) - u_{h, i,j}$, where $u_h$ is the solution of the discrete system. Applying the discrete operator $L_h$ to the error:\n$$\nL_h e_{i,j} = L_h (u_{i,j} - u_{h, i,j}) = L_h u_{i,j} - L_h u_{h, i,j}\n$$\nBy definition, $L_h u_{h, i,j} = f_{i,j}$ and $L_h u_{i,j} = f_{i,j} + \\tau_{i,j}$. Subtracting these, we obtain the error equation:\n$$\nL_h e_{i,j} = \\tau_{i,j}\n$$\nfor all interior nodes. On the boundary $\\partial\\Omega$, the error is zero, $e_{i,j} = 0$, since both the exact solution and the numerical solution take the prescribed boundary values $g(x,y)$.\n\nThe connection between the LTE and the global error is made through the stability of the discrete operator $L_h$. The operator $L_h$ satisfies a discrete maximum principle (DMP). For an operator like $L_h$, the DMP states that if $L_h v_{i,j} \\ge 0$ at all interior nodes, then the maximum value of $v$ over the entire grid must occur on the boundary. A key consequence of the DMP is the stability of its inverse in the maximum norm. That is, there exists a constant $C > 0$, independent of $h$, such that for any grid function $z$, the solution $v$ to $L_h v = z$ with zero boundary conditions satisfies:\n$$\n\\lVert v \\rVert_\\infty \\le C \\lVert z \\rVert_\\infty\n$$\nThis is expressed as $\\lVert L_h^{-1} \\rVert_\\infty \\le C$. Applying this stability estimate to the error equation $e = L_h^{-1} \\tau$:\n$$\n\\lVert e \\rVert_\\infty = \\lVert L_h^{-1} \\tau \\rVert_\\infty \\le \\lVert L_h^{-1} \\rVert_\\infty \\lVert \\tau \\rVert_\\infty \\le C \\lVert \\tau \\rVert_\\infty\n$$\nSince we have shown that $\\lVert \\tau \\rVert_\\infty = \\mathcal{O}(h^2)$, the global error in the maximum norm is also second-order accurate:\n$$\n\\lVert u - u_h \\rVert_\\infty = \\lVert e \\rVert_\\infty = \\mathcal{O}(h^2)\n$$\nThis establishes that, for a sufficiently smooth solution ($u \\in C^4(\\overline{\\Omega})$), the five-point scheme converges globally at a rate of $2$.\n\n### Part 3: Algorithmic Design\n\nThe implementation will consist of a matrix-free Conjugate Gradient (CG) solver. The linear system $A u_h = b$ must be constructed, where $A$ corresponds to the discrete operator $L_h$ on the $(N-1)^2$ interior nodes.\n\n**System Construction:** The vector $u_h$ contains the unknown values at interior nodes. The matrix $A$ represents the five-point stencil. The right-hand side vector $b$ combines the source term $f(x,y)$ and the contributions from the known Dirichlet boundary values $g(x,y)$. For an interior node $(x_i,y_j)$:\n$$\nb_{i,j} = f(x_i, y_j) + \\frac{1}{h^2} \\left[ \\delta_{i,1}g(x_0,y_j) + \\delta_{i,N-1}g(x_N,y_j) + \\delta_{j,1}g(x_i,y_0) + \\delta_{j,N-1}g(x_i,y_N) \\right]\n$$\nwhere $\\delta_{k,l}$ is the Kronecker delta. This formulation moves all known boundary terms to the right side of the equation.\n\n**Matrix-Free CG:** The CG algorithm iteratively solves a symmetric positive-definite system. The matrix for the five-point stencil has this property. The key operation in CG is the matrix-vector product $A\\vec{p}$. In a matrix-free approach, we do not assemble the $(N-1)^2 \\times (N-1)^2$ matrix $A$. Instead, we implement a function that computes the action of the operator $L_h$ on a grid function $\\vec{p}$ (representing the search direction). This is done by applying the five-point stencil at each interior node.\n\n**EOC Estimation:** The EOC $p$ is estimated from errors $E(h_k)$ at a sequence of mesh sizes $h_k$ via the model $\\log E(h) \\approx \\log C + p \\log h$. This is a linear regression problem for the pairs $(\\log h_k, \\log E_k)$. The slope $p$ is calculated using the standard least-squares formula.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute EOC for all cases.\n    \"\"\"\n\n    # --- Test Case Definitions ---\n\n    # Case 1: Smooth solution u_s(x,y) = sin(pi*x)sin(pi*y)\n    u_s = lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y)\n    f_s = lambda x, y: 2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n    \n    # Case 2: Singular solution u_sg(x,y) = r^(3/2)\n    def u_sg(x, y):\n        r = np.sqrt(x**2 + y**2)\n        # Handle r=0 case to avoid 0**negative power in f_sg\n        return np.power(r, 1.5)\n\n    def f_sg(x, y):\n        # f is evaluated only at interior points, so r > 0.\n        r = np.sqrt(x**2 + y**2)\n        alpha = 1.5\n        return -alpha**2 * np.power(r, alpha - 2)\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case A: Smooth solution, standard refinement\n        {'name': 'A', 'Ns': [8, 16, 32, 64], 'u_func': u_s, 'f_func': f_s},\n        # Case B: Singular solution\n        {'name': 'B', 'Ns': [8, 16, 32, 64], 'u_func': u_sg, 'f_func': f_sg},\n        # Case C: Smooth solution, coarse grids\n        {'name': 'C', 'Ns': [4, 8, 16], 'u_func': u_s, 'f_func': f_s},\n    ]\n\n    eoc_results = []\n\n    for case in test_cases:\n        h_values = []\n        error_values = []\n\n        for N in case['Ns']:\n            h = 1.0 / N\n            u_func = case['u_func']\n            f_func = case['f_func']\n            g_func = u_func # Boundary condition is the exact solution\n\n            # 1. Set up grid and coordinates\n            # Grid for interior points (1..N-1)\n            int_coords = np.linspace(h, 1.0 - h, N - 1)\n            X_int, Y_int = np.meshgrid(int_coords, int_coords, indexing='ij')\n\n            # Full grid for error calculation (0..N)\n            full_coords = np.linspace(0, 1.0, N + 1)\n            X_full, Y_full = np.meshgrid(full_coords, full_coords, indexing='ij')\n\n            # 2. Construct the right-hand side (RHS) vector 'b'\n            b = f_func(X_int, Y_int)\n            h2_inv = 1.0 / (h**2)\n            \n            # Add boundary contributions\n            # j = 1, ..., N-1\n            b[0, :] += h2_inv * g_func(0, int_coords)  # Left boundary i=0\n            b[-1, :] += h2_inv * g_func(1, int_coords) # Right boundary i=N\n            # i = 1, ..., N-1\n            b[:, 0] += h2_inv * g_func(int_coords, 0)  # Bottom boundary j=0\n            b[:, -1] += h2_inv * g_func(int_coords, 1) # Top boundary j=N\n\n            # 3. Solve the linear system using matrix-free Conjugate Gradient\n            u_h_interior = cg_solver(b, h, tol=1e-12)\n\n            # 4. Construct full solution grid and compute error\n            u_h_full = np.zeros((N + 1, N + 1))\n            # Set boundary values\n            u_h_full[0, :] = g_func(0, full_coords)\n            u_h_full[N, :] = g_func(1, full_coords)\n            u_h_full[:, 0] = g_func(full_coords, 0)\n            u_h_full[:, N] = g_func(full_coords, 1)\n            # Fill interior\n            u_h_full[1:N, 1:N] = u_h_interior\n\n            u_exact_full = u_func(X_full, Y_full)\n            \n            error = np.max(np.abs(u_exact_full - u_h_full))\n            \n            h_values.append(h)\n            error_values.append(error)\n\n        # 5. Compute EOC using least-squares fit\n        log_h = np.log(np.array(h_values))\n        log_e = np.log(np.array(error_values))\n        \n        # Fit a line (degree 1 polynomial) to (log_h, log_e)\n        # The slope is the first coefficient returned by polyfit.\n        p_eoc = np.polyfit(log_h, log_e, 1)[0]\n        eoc_results.append(p_eoc)\n    \n    # Final print statement\n    print(f\"[{','.join(f'{p:.3f}' for p in eoc_results)}]\")\n\ndef apply_A_matvec(v, h):\n    \"\"\"\n    Computes the matrix-free matrix-vector product for the 5-point stencil.\n    Assumes zero boundary conditions for the input vector v.\n    \n    Args:\n        v (np.ndarray): A 2D numpy array of size (N-1)x(N-1) representing the vector.\n        h (float): The mesh spacing.\n    \n    Returns:\n        np.ndarray: The result of Av, a 2D array of size (N-1)x(N-1).\n    \"\"\"\n    if v.shape[0] == 0:\n        return np.array([])\n    N_minus_1 = v.shape[0]\n    Av = np.zeros_like(v)\n    h2_inv = 1.0 / (h**2)\n    \n    # Pad with zeros for boundary conditions\n    v_padded = np.pad(v, pad_width=1, mode='constant', constant_values=0)\n    \n    for i in range(N_minus_1):\n        for j in range(N_minus_1):\n            # Convert to padded indices\n            ip, jp = i + 1, j + 1\n            center = v_padded[ip, jp]\n            left = v_padded[ip - 1, jp]\n            right = v_padded[ip + 1, jp]\n            down = v_padded[ip, jp - 1]\n            up = v_padded[ip, jp + 1]\n            \n            Av[i, j] = h2_inv * (4 * center - left - right - down - up)\n            \n    return Av\n\ndef cg_solver(b, h, tol=1e-10, max_iter=1000):\n    \"\"\"\n    Solves Ax=b using matrix-free Conjugate Gradient method.\n    \n    Args:\n        b (np.ndarray): The right-hand side vector as a 2D (N-1)x(N-1) array.\n        h (float): The mesh spacing.\n        tol (float): The relative tolerance for the residual norm.\n        max_iter (int): Maximum number of iterations.\n    \n    Returns:\n        np.ndarray: The solution vector x as a 2D (N-1)x(N-1) array.\n    \"\"\"\n    if b.size == 0:\n        return np.array([])\n    x = np.zeros_like(b)\n    r = b - apply_A_matvec(x, h)\n    p = r.copy()\n    rs_old = np.sum(r**2)\n    \n    b_norm = np.sqrt(np.sum(b**2))\n    if b_norm == 0:\n        return x\n\n    for k in range(max_iter):\n        Ap = apply_A_matvec(p, h)\n        pAp = np.sum(p * Ap)\n\n        if pAp == 0:\n            break\n            \n        alpha = rs_old / pAp\n        x += alpha * p\n        r -= alpha * Ap\n        \n        rs_new = np.sum(r**2)\n        \n        if np.sqrt(rs_new) < tol * b_norm:\n            break\n            \n        p = r + (rs_new / rs_old) * p\n        rs_old = rs_new\n        \n    return x\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3228788"}, {"introduction": "Building upon the constant-coefficient case, this practice explores the more general and physically realistic scenario of a variable diffusion coefficient, often encountered in problems like heat flow through composite materials. You will learn that a naive application of the finite difference formula is inadequate for discontinuous coefficients. Instead, you will derive a more robust scheme based on the principle of flux conservation over a control volume, leading naturally to the use of harmonic averaging at material interfaces to ensure physical consistency [@problem_id:3228831].", "problem": "Implement a complete, runnable program that constructs and solves linear systems arising from a finite difference discretization of the elliptic partial differential equation\n$$\n\\nabla \\cdot \\left(\\kappa(x,y)\\,\\nabla u(x,y)\\right) \\;=\\; f(x,y)\n$$\non the unit square domain $[0,1]\\times[0,1]$ with homogeneous Dirichlet boundary conditions $u(x,y)=0$ on $\\partial\\Omega$. The unknown is the scalar field $u(x,y)$, the diffusion coefficient $\\kappa(x,y)$ is strictly positive and piecewise constant in a checkerboard pattern, and $f(x,y)$ is a given source term. Angles in any trigonometric expressions must be interpreted in radians.\n\nYour implementation must start from fundamental principles and core definitions:\n- The divergence theorem and conservation of flux over a control volume.\n- The definition of the gradient and divergence operators as limits of difference quotients.\n- The requirement of continuity of normal flux across interfaces, which leads to harmonic averaging of coefficients at interfaces for consistent discretization.\n\nFrom these bases, derive a consistent, second-order accurate, five-point finite difference scheme on a uniform Cartesian grid using a flux balance over each interior control volume. The discrete interface conductivity between two neighboring grid points must be the harmonic mean of the $\\kappa$ values at those two points to correctly capture discontinuities and enforce continuity of normal flux.\n\nDiscretization and implementation requirements:\n- Use $M$ interior points in each coordinate direction, so the grid spacing is $h=\\frac{1}{M+1}$ and interior nodes have indices $i=1,\\dots,M$ and $j=1,\\dots,M$ with coordinates $(x_i,y_j)=(ih,jh)$.\n- Impose homogeneous Dirichlet boundary conditions $u=0$ on all boundary nodes corresponding to $i=0, i=M+1, j=0, \\text{ or } j=M+1$.\n- Define the checkerboard diffusion coefficient at all grid nodes (including boundaries) by\n$$\n\\kappa_{i,j} \\;=\\;\n\\begin{cases}\nk_{\\text{low}}, & \\text{if } (i+j+p)\\ \\text{is even} \\\\\nk_{\\text{high}}, & \\text{if } (i+j+p)\\ \\text{is odd}\n\\end{cases}\n$$\nwhere $p\\in\\{0,1\\}$ is a phase that shifts the checkerboard pattern.\n- For each pair of neighboring nodes, use the face conductivity equal to the harmonic mean of the two nodal values. For two positive values $a$ and $b$, the harmonic mean is $\n\\displaystyle H(a,b) = \\frac{2ab}{a+b}.\n$\n- Assemble the linear system corresponding to the discrete balance of fluxes at each interior node in the form\n$\nA\\,\\mathbf{u} = \\mathbf{b},\n$\nwhere $\\mathbf{u}$ stacks the unknowns $u_{i,j}$ at interior nodes in lexicographic order and $\\mathbf{b}$ stacks the source samples $f(x_i,y_j)$. The matrix must encode flux differences with interface conductivities given by the harmonic means. The homogeneous Dirichlet boundary makes all contributions of boundary unknowns vanish because $u=0$ on $\\partial\\Omega$.\n- Solve the resulting linear system using a direct solver.\n- For each test case, report the discrete $L^2$ norm of the interior solution defined by\n$$\n\\|u\\|_{L_h^2} \\;=\\; \\left(h^2 \\sum_{i=1}^{M}\\sum_{j=1}^{M} u_{i,j}^2\\right)^{1/2}.\n$$\n\nTest suite and output:\n- Use the following four test cases. In each case, angles in $f(x,y)$ are in radians.\n    1. $M=16$, $k_{\\text{low}}=1$, $k_{\\text{high}}=5$, $p=0$, and $f(x,y)=\\sin\\!\\left(2\\pi x\\right)\\sin\\!\\left(2\\pi y\\right)$.\n    2. $M=5$, $k_{\\text{low}}=1$, $k_{\\text{high}}=10$, $p=1$, and $f(x,y)=0$ for all $(x,y)$.\n    3. $M=20$, $k_{\\text{low}}=1$, $k_{\\text{high}}=100$, $p=0$, and $f(x,y)=1$ for all $(x,y)$.\n    4. $M=1$, $k_{\\text{low}}=2$, $k_{\\text{high}}=8$, $p=0$, and $f(x,y)=\\cos\\!\\left(\\pi x\\right)\\cos\\!\\left(\\pi y\\right)$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases above. The entry for each test case must be the single float $\\|u\\|_{L_h^2}$ computed for that case. For example, an admissible output format is\n$\n\\big[ r_1,r_2,r_3,r_4 \\big],\n$\nwhere each $r_i$ is a floating-point number.\n\nNo user input is allowed; all data must be hard-coded as specified above, and the program must run to completion using only the provided test suite.", "solution": "The problem is valid. It presents a well-posed, scientifically grounded task within the field of numerical methods for partial differential equations. All necessary data, definitions, and boundary conditions are provided, and there are no internal contradictions or logical flaws.\n\nWe are tasked with solving the elliptic partial differential equation (PDE) with a variable diffusion coefficient $\\kappa(x,y)$:\n$$ \\nabla \\cdot \\left(\\kappa(x,y)\\,\\nabla u(x,y)\\right) = f(x,y) $$\non the unit square domain $\\Omega = [0,1]\\times[0,1]$, subject to homogeneous Dirichlet boundary conditions $u(x,y)=0$ for $(x,y) \\in \\partial\\Omega$.\n\nThe solution will be developed by deriving a finite difference scheme based on the principle of flux conservation over control volumes. We discretize the domain using a uniform Cartesian grid with $M$ interior points in each direction. The grid spacing is $h = \\frac{1}{M+1}$. The grid nodes are located at $(x_i, y_j) = (ih, jh)$ for $i, j \\in \\{0, 1, \\dots, M+1\\}$. The interior nodes correspond to indices $i, j \\in \\{1, \\dots, M\\}$.\n\nThe derivation begins by integrating the PDE over a square control volume $\\Omega_{i,j}$ of side length $h$ centered at each interior node $(x_i, y_j)$. The control volume is defined by $[x_i - h/2, x_i + h/2] \\times [y_j - h/2, y_j + h/2]$.\n$$ \\iint_{\\Omega_{i,j}} \\nabla \\cdot (\\kappa \\nabla u) \\,dA = \\iint_{\\Omega_{i,j}} f(x,y) \\,dA $$\nApplying the divergence theorem to the left-hand side converts the area integral into a line integral over the boundary of the control volume, $\\partial\\Omega_{i,j}$:\n$$ \\oint_{\\partial\\Omega_{i,j}} (\\kappa \\nabla u) \\cdot \\mathbf{n} \\,ds = \\iint_{\\Omega_{i,j}} f(x,y) \\,dA $$\nwhere $\\mathbf{n}$ is the outward unit normal vector to the boundary $\\partial\\Omega_{i,j}$.\n\nThe right-hand side is approximated by assuming $f$ is constant over the small control volume:\n$$ \\iint_{\\Omega_{i,j}} f(x,y) \\,dA \\approx f(x_i, y_j) \\cdot \\text{Area}(\\Omega_{i,j}) = f_{i,j} h^2 $$\n\nThe left-hand side represents the total flux out of the control volume. It is the sum of fluxes across the four faces of the square: east, west, north, and south. Let's denote the flux vector as $\\mathbf{F} = -\\kappa\\nabla u$. The net flux into the control volume is zero in the absence of a source. With a source, the net outward flux balances the integrated source. The outward flux across the east face (at $x=x_i+h/2$) is:\n$$ \\text{Flux}_{\\text{east}} = \\int_{y_j-h/2}^{y_j+h/2} (\\kappa \\frac{\\partial u}{\\partial x})\\Big|_{x=x_{i+1/2}} \\, dy $$\nWe approximate this by evaluating the integrand at the center of the face, $(x_{i+1/2}, y_j)$, and multiplying by the face length $h$:\n$$ \\text{Flux}_{\\text{east}} \\approx h \\cdot \\left(\\kappa \\frac{\\partial u}{\\partial x}\\right)\\Big|_{x_{i+1/2}, y_j} $$\nThe derivative $\\frac{\\partial u}{\\partial x}$ at the face is approximated by a second-order accurate central difference between the adjacent nodes:\n$$ \\frac{\\partial u}{\\partial x}\\Big|_{x_{i+1/2}, y_j} \\approx \\frac{u_{i+1,j} - u_{i,j}}{h} $$\nThe diffusion coefficient $\\kappa$ is discontinuous at interfaces. To maintain consistency and ensure continuity of the normal flux, $\\kappa \\frac{\\partial u}{\\partial n}$, across the interface, the effective conductivity at the interface, $\\kappa_{i+1/2, j}$, must be the harmonic mean of the nodal values $\\kappa_{i,j}$ and $\\kappa_{i+1,j}$:\n$$ \\kappa_{i+1/2, j} = H(\\kappa_{i,j}, \\kappa_{i+1,j}) = \\frac{2\\kappa_{i,j}\\kappa_{i+1,j}}{\\kappa_{i,j}+\\kappa_{i+1,j}} $$\nCombining these approximations, the outward flux through the east face is:\n$$ \\text{Flux}_{\\text{east}} \\approx h \\cdot \\kappa_{i+1/2, j} \\cdot \\frac{u_{i+1,j} - u_{i,j}}{h} = \\kappa_{i+1/2, j} (u_{i+1,j} - u_{i,j}) $$\nSimilarly, the outward flux through the west face (at $x=x_{i-1/2}$, where $\\mathbf{n}=(-1,0)$) is:\n$$ \\text{Flux}_{\\text{west}} = \\int_{y_j-h/2}^{y_j+h/2} (\\kappa \\nabla u \\cdot (-\\mathbf{e}_x))\\Big|_{x=x_{i-1/2}} \\, dy \\approx -h \\cdot \\kappa_{i-1/2, j} \\frac{u_{i,j} - u_{i-1,j}}{h} = -\\kappa_{i-1/2, j} (u_{i,j} - u_{i-1,j}) $$\nThe fluxes across the north and south faces are analogous:\n$$ \\text{Flux}_{\\text{north}} \\approx \\kappa_{i, j+1/2} (u_{i,j+1} - u_{i,j}) $$\n$$ \\text{Flux}_{\\text{south}} \\approx -\\kappa_{i, j-1/2} (u_{i,j} - u_{i,j-1}) $$\nSumming the four outward fluxes and equating to the source term gives the discrete balance equation for node $(i,j)$:\n$$ \\kappa_{i+1/2,j}(u_{i+1,j} - u_{i,j}) - \\kappa_{i-1/2,j}(u_{i,j} - u_{i-1,j}) + \\kappa_{i,j+1/2}(u_{i,j+1} - u_{i,j}) - \\kappa_{i,j-1/2}(u_{i,j} - u_{i,j-1}) = h^2 f_{i,j} $$\nRearranging the terms to group the unknown values $u$ yields the five-point stencil equation:\n$$ \\kappa_{i-1/2,j} u_{i-1,j} + \\kappa_{i+1/2,j} u_{i+1,j} + \\kappa_{i,j-1/2} u_{i,j-1} + \\kappa_{i,j+1/2} u_{i,j+1} - (\\kappa_{i-1/2,j} + \\kappa_{i+1/2,j} + \\kappa_{i,j-1/2} + \\kappa_{i,j+1/2}) u_{i,j} = h^2 f_{i,j} $$\nThis equation holds for each interior node, where $i,j \\in \\{1, \\dots, M\\}$. For nodes adjacent to the boundary, one or more neighboring $u$ values are prescribed by the Dirichlet boundary conditions. Since $u=0$ on $\\partial\\Omega$, any term involving a boundary node (e.g., $u_{0,j}$, $u_{M+1,j}$, $u_{i,0}$, $u_{i,M+1}$) is zero and drops from the equation.\n\nThis set of $M \\times M$ linear equations forms a linear system $A\\mathbf{u} = \\mathbf{b}$. The unknown vector $\\mathbf{u}$ contains the $M^2$ values of $u_{i,j}$ at the interior nodes, stacked in lexicographic order. The mapping from a 2D grid index $(i,j)$ (with $1 \\le i, j \\le M$) to a 1D vector index $k$ (with $0 \\le k \\le M^2-1$) is $k = (j-1)M + (i-1)$. The matrix $A$ is an $M^2 \\times M^2$ sparse matrix containing the coefficients from the stencil, and the vector $\\mathbf{b}$ contains the source terms $b_k = h^2 f_{i,j}$.\n\nThe constructed linear system is solved using a direct solver. The solution vector $\\mathbf{u}$ provides the discrete values of the field $u$ at the interior grid points. Finally, we compute the discrete $L^2$ norm of the solution as specified:\n$$ \\|u\\|_{L_h^2} = \\left(h^2 \\sum_{i=1}^{M}\\sum_{j=1}^{M} u_{i,j}^2\\right)^{1/2} = h \\left(\\sum_{k=0}^{M^2-1} \\mathbf{u}_k^2\\right)^{1/2} = h \\|\\mathbf{u}\\|_2 $$\nwhere $\\|\\mathbf{u}\\|_2$ is the standard Euclidean norm of the solution vector.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and solves linear systems for a 2D elliptic PDE with a\n    piecewise constant coefficient using a finite difference method.\n    \"\"\"\n\n    def solve_pde_case(M, k_low, k_high, p, f_func):\n        \"\"\"\n        Solves a single instance of the PDE problem.\n\n        Args:\n            M (int): Number of interior grid points in each direction.\n            k_low (float): Lower value for the checkerboard coefficient kappa.\n            k_high (float): Higher value for the checkerboard coefficient kappa.\n            p (int): Phase offset for the checkerboard pattern (0 or 1).\n            f_func (callable): The source function f(x, y).\n\n        Returns:\n            float: The discrete L2 norm of the solution.\n        \"\"\"\n        if M == 0:\n            return 0.0\n\n        h = 1.0 / (M + 1)\n        N_unknowns = M * M\n\n        #\n        # 1. Define the diffusion coefficient kappa on the full (M+2)x(M+2) grid\n        #\n        kappa = np.zeros((M + 2, M + 2))\n        for i in range(M + 2):\n            for j in range(M + 2):\n                if (i + j + p) % 2 == 0:\n                    kappa[i, j] = k_low\n                else:\n                    kappa[i, j] = k_high\n        \n        # Helper for harmonic mean\n        def h_mean(a, b):\n            # The problem statement guarantees kappa > 0, so no division by zero.\n            return 2.0 * a * b / (a + b)\n\n        #\n        # 2. Assemble the linear system A*u = b\n        #\n        A = np.zeros((N_unknowns, N_unknowns))\n        b = np.zeros(N_unknowns)\n\n        for j_int in range(1, M + 1):  # 1-based index for interior y-nodes\n            for i_int in range(1, M + 1):  # 1-based index for interior x-nodes\n                \n                # Map 2D grid index (i_int, j_int) to 1D vector index k\n                k = (j_int - 1) * M + (i_int - 1)\n\n                # Set source term in the right-hand side vector b\n                x, y = i_int * h, j_int * h\n                b[k] = h * h * f_func(x, y)\n\n                # Calculate interface conductivities using harmonic mean\n                kappa_center = kappa[i_int, j_int]\n                \n                kappa_W = h_mean(kappa_center, kappa[i_int - 1, j_int]) # West\n                kappa_E = h_mean(kappa_center, kappa[i_int + 1, j_int]) # East\n                kappa_S = h_mean(kappa_center, kappa[i_int, j_int - 1]) # South\n                kappa_N = h_mean(kappa_center, kappa[i_int, j_int + 1]) # North\n\n                # Set matrix A coefficients for the current row k\n                # Diagonal entry\n                A[k, k] = -(kappa_W + kappa_E + kappa_S + kappa_N)\n                \n                # Off-diagonal entries for neighbors\n                # Homogeneous Dirichlet BCs are handled implicitly by only\n                # setting entries for interior neighbors.\n                if i_int > 1:  # West neighbor\n                    A[k, k - 1] = kappa_W\n                if i_int < M:  # East neighbor\n                    A[k, k + 1] = kappa_E\n                if j_int > 1:  # South neighbor\n                    A[k, k - M] = kappa_S\n                if j_int < M:  # North neighbor\n                    A[k, k + M] = kappa_N\n                    \n        #\n        # 3. Solve the linear system for the unknown vector u\n        #\n        u_vec = np.linalg.solve(A, b)\n\n        #\n        # 4. Compute the discrete L2 norm of the solution\n        #\n        # norm = sqrt(h^2 * sum(u_k^2)) = h * sqrt(sum(u_k^2)) = h * linalg.norm(u_vec)\n        norm_L2h = h * np.linalg.norm(u_vec)\n\n        return norm_L2h\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'M': 16, 'k_low': 1, 'k_high': 5, 'p': 0, \n         'f': lambda x, y: np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)},\n        # Case 2\n        {'M': 5, 'k_low': 1, 'k_high': 10, 'p': 1, \n         'f': lambda x, y: 0.0},\n        # Case 3\n        {'M': 20, 'k_low': 1, 'k_high': 100, 'p': 0, \n         'f': lambda x, y: 1.0},\n        # Case 4\n        {'M': 1, 'k_low': 2, 'k_high': 8, 'p': 0, \n         'f': lambda x, y: np.cos(np.pi * x) * np.cos(np.pi * y)},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_pde_case(\n            case['M'], case['k_low'], case['k_high'], case['p'], case['f']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3228831"}, {"introduction": "After learning to discretize and solve the linear systems, how can we obtain more accurate results? This practice introduces Richardson extrapolation, a powerful and general technique for improving solution accuracy. By exploiting the predictable structure of the discretization error, you can combine solutions from a sequence of refined grids to systematically cancel leading error terms. This exercise demonstrates how to achieve a higher order of convergence without developing a more complex discretization scheme, offering a valuable tool for practical scientific computing [@problem_id:3228920].", "problem": "Consider the two-dimensional Poisson Partial Differential Equation (PDE) on the unit square domain with Cartesian coordinates $(x,y) \\in [0,1] \\times [0,1]$,\n$$- \\Delta u(x,y) = f(x,y),$$\nsubject to homogeneous Dirichlet boundary conditions\n$$u(x,y) = 0 \\quad \\text{for} \\quad (x,y) \\in \\partial([0,1] \\times [0,1]).$$\nAssume the exact solution is given by\n$$u(x,y) = \\sin(\\pi x)\\sin(\\pi y),$$\nso that the source term is determined by the identity for the Laplace operator $\\Delta$,\n$$- \\Delta u(x,y) = 2 \\pi^2 \\sin(\\pi x)\\sin(\\pi y).$$\nAll trigonometric angles must be interpreted in radians.\n\nUsing the standard five-point central Finite Difference (FD) scheme for the Laplace operator on a uniform grid of spacing $h$, the discrete operator at an interior grid node $(i,j)$ is constructed from the second-derivative definitions and yields a linear algebraic system that approximates the PDE with a truncation error that is asymptotically proportional to $h^2$ under smoothness assumptions on $u(x,y)$. Let the interior grid size be $n \\times n$, with grid spacing $h = \\frac{1}{n+1}$ and interior indices $i,j \\in \\{1,2,\\dots,n\\}$. Denote by $U_h$ the FD approximation to $u$ evaluated at the geometric center of the domain $(x,y) = (0.5,0.5)$, which corresponds to the interior indices $(i,j) = \\left(\\frac{n+1}{2},\\frac{n+1}{2}\\right)$ when $n$ is odd.\n\nYour task is to:\n- Construct the linear system arising from the five-point FD discretization of $- \\Delta u = f$ with homogeneous Dirichlet boundary conditions $u = 0$ on $\\partial \\Omega$, solve it on three nested uniform grids with spacings $h$, $h/2$, and $h/4$, and extract the three resulting approximations at the center, denoted $U_h$, $U_{h/2}$, and $U_{h/4}$.\n- Apply Richardson extrapolation to the sequence $\\{U_h, U_{h/2}, U_{h/4}\\}$ with refinement ratio $r = 2$ to eliminate the leading $O(h^2)$ truncation error and then eliminate the next $O(h^4)$ term, thereby producing a higher-order accurate approximation at the center. You must derive and implement the algebraic combination that cancels the leading and next-leading error terms based on the asymptotic error expansion and the refinement ratio.\n- Compute the absolute error at the center, defined as $|U_{\\text{extrap}} - u(0.5,0.5)|$, where $U_{\\text{extrap}}$ is your three-level Richardson-extrapolated value and $u(0.5,0.5) = \\sin(\\pi/2)\\sin(\\pi/2) = 1$.\n\nTest suite:\n- The program must run the procedure for three base interior sizes $n_0$ that define the coarse grid. For each $n_0$, construct the three nested grids with interior sizes $n_0$, $2n_0+1$, and $4n_0+3$ (corresponding to spacings $h$, $h/2$, and $h/4$ respectively), and perform the extrapolation as described. Use the following test cases:\n    1. $n_0 = 1$ (edge-case coarse grid, minimal interior),\n    2. $n_0 = 7$ (typical mid-resolution case),\n    3. $n_0 = 15$ (finer coarse grid).\nThese choices ensure that the geometric center $(0.5,0.5)$ coincides with a grid point on each nested grid.\n\nFinal output specification:\n- Your program should produce a single line of output containing the absolute errors of the three-level Richardson-extrapolated center values for the three test cases as a comma-separated list enclosed in square brackets, for example, $$[e_1,e_2,e_3],$$ where each $e_k$ is a floating-point number representing the absolute error for the $k$-th test case.", "solution": "### Problem Validation\n\nThe problem statement is critically examined according to the specified criteria.\n\n#### Step 1: Extract Givens\n\n- **PDE**: The two-dimensional Poisson equation is given as $- \\Delta u(x,y) = f(x,y)$ on the domain $\\Omega = [0,1] \\times [0,1]$.\n- **Boundary Conditions (BCs)**: Homogeneous Dirichlet boundary conditions are specified: $u(x,y) = 0$ for $(x,y) \\in \\partial\\Omega$.\n- **Exact Solution**: The exact solution to the problem is provided as $u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$.\n- **Source Term**: The source term $f(x,y)$ is determined by the exact solution: $f(x,y) = - \\Delta u(x,y) = 2 \\pi^2 \\sin(\\pi x)\\sin(\\pi y)$. All trigonometric functions are in radians.\n- **Discretization Method**: The standard five-point central finite difference (FD) scheme on a uniform grid with spacing $h$ is to be used. The truncation error is stated to be asymptotically proportional to $h^2$.\n- **Grid Definition**: The grid has $n \\times n$ interior nodes. The grid spacing is $h = \\frac{1}{n+1}$, with interior indices $i,j \\in \\{1,2,\\dots,n\\}$.\n- **Quantity of Interest**: The FD approximation $U_h$ at the geometric center of the domain, $(x,y) = (0.5,0.5)$. This corresponds to grid indices $(i,j) = \\left(\\frac{n+1}{2},\\frac{n+1}{2}\\right)$ for odd $n$.\n- **Task**:\n    1.  Solve the FD system on three nested grids with spacings $h$, $h/2$, and $h/4$, yielding approximations $U_h, U_{h/2}, U_{h/4}$ at the center.\n    2.  Apply two-stage Richardson extrapolation to the sequence $\\{U_h, U_{h/2}, U_{h/4}\\}$ to obtain a higher-order approximation $U_{\\text{extrap}}$.\n    3.  Compute the absolute error $|U_{\\text{extrap}} - u(0.5,0.5)|$, where the exact value is $u(0.5,0.5) = 1$.\n- **Test Cases**: The procedure is to be run for three base interior grid sizes $n_0$:\n    1.  $n_0 = 1$: uses grids with $n=1, 3, 7$.\n    2.  $n_0 = 7$: uses grids with $n=7, 15, 31$.\n    3.  $n_0 = 15$: uses grids with $n=15, 31, 63$.\n    The nested grids are defined by $n_0$, $n_1=2n_0+1$, and $n_2=4n_0+3$, which correctly correspond to spacings $h$, $h/2$, and $h/4$.\n\n#### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded**: The problem is a classic exercise in the field of numerical analysis for partial differential equations. The Poisson equation, finite difference methods, and Richardson extrapolation are all standard, well-established topics. The provided exact solution and derived source term are consistent.\n- **Well-Posed**: The Poisson equation with Dirichlet boundary conditions is a well-posed elliptic PDE. Its finite difference discretization results in a non-singular, uniquely solvable linear system. The task is clearly defined and leads to a unique numerical result.\n- **Objective**: The problem is stated using precise mathematical language, with no subjective or ambiguous terminology.\n- **Completeness and Consistency**: All necessary information (the PDE, domain, BCs, discretization scheme, exact solution, and test parameters) is provided. The relationship between the grid size $n$ and the spacing $h$ is consistent across the nested refinements. The choice of odd values for $n$ ensures that the domain center $(0.5,0.5)$ is always a grid point, which is a necessary condition for the task.\n\nThe problem exhibits no scientific flaws, inconsistencies, or ambiguities.\n\n#### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be provided.\n\n### Solution\n\nThe solution is developed by following a systematic procedure encompassing discretization, linear system formulation, and Richardson extrapolation.\n\n#### 1. Finite Difference Discretization\nThe Poisson equation is $-(\\partial^2 u/\\partial x^2 + \\partial^2 u/\\partial y^2) = f(x,y)$. We introduce a uniform grid with $n$ interior points in each direction, such that the grid spacing is $h=1/(n+1)$. The grid points are $(x_i, y_j) = (ih, jh)$ for $i,j = 0, 1, \\dots, n+1$. The interior points correspond to indices $i,j = 1, \\dots, n$.\n\nThe second partial derivatives are approximated using central differences:\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{U_{i+1,j} - 2U_{i,j} + U_{i-1,j}}{h^2} $$\n$$ \\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{U_{i,j+1} - 2U_{i,j} + U_{i,j-1}}{h^2} $$\nwhere $U_{i,j}$ is the numerical approximation to $u(x_i, y_j)$.\n\nSubstituting these into the Poisson equation yields the five-point stencil for the negative Laplacian operator at each interior node $(i,j)$:\n$$ -\\Delta_h U_{i,j} = \\frac{4U_{i,j} - U_{i+1,j} - U_{i-1,j} - U_{i,j+1} - U_{i,j-1}}{h^2} = f(x_i, y_j) $$\nfor $i,j=1, \\dots, n$. The homogeneous Dirichlet boundary conditions imply that $U_{i,j}=0$ if $i$ or $j$ is $0$ or $n+1$.\n\n#### 2. Linear System Formulation\nThe set of $n^2$ linear equations for the unknown interior values $U_{i,j}$ can be written in matrix form as $A\\vec{U} = \\vec{F}$. The vector of unknowns $\\vec{U}$ is an $n^2 \\times 1$ column vector formed by ordering the $U_{i,j}$ values. Using a standard row-wise (or natural) ordering, where the index $j$ varies fastest, the mapping from 2D grid indices $(i,j)$ (with $i,j \\in \\{1,\\dots,n\\}$) to a 1D vector index $k \\in \\{1,\\dots,n^2\\}$ is $k = (i-1)n+j$.\n\nThe matrix $A$ is an $n^2 \\times n^2$ sparse, symmetric, positive-definite, and block-tridiagonal matrix:\n$$ A = \\frac{1}{h^2} \\begin{pmatrix}\nT & -I & & & \\\\\n-I & T & -I & & \\\\\n& \\ddots & \\ddots & \\ddots & \\\\\n& & -I & T & -I \\\\\n& & & -I & T\n\\end{pmatrix} $$\nwhere $I$ is the $n \\times n$ identity matrix and $T$ is the $n \\times n$ tridiagonal matrix:\n$$ T = \\begin{pmatrix}\n4 & -1 & & & \\\\\n-1 & 4 & -1 & & \\\\\n& \\ddots & \\ddots & \\ddots & \\\\\n& & -1 & 4 & -1 \\\\\n& & & -1 & 4\n\\end{pmatrix} $$\nThis structure arises directly from the five-point stencil. The matrix $A$ can be elegantly constructed using the Kronecker product. Let $A_{1D} = T/h^2$ be the matrix representing the 1D negative second derivative. Then the 2D operator matrix is $A = I \\otimes A_{1D} + A_{1D} \\otimes I$.\n\nThe right-hand side vector $\\vec{F}$ is an $n^2 \\times 1$ column vector containing the values of the source term $f(x,y) = 2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$ evaluated at the interior grid points $(x_i, y_j)$, ordered consistently with $\\vec{U}$.\nFor each test case, we construct this system and solve for $\\vec{U}$ using a standard linear solver.\n\n#### 3. Richardson Extrapolation\nThe finite difference scheme has a truncation error that, for a sufficiently smooth solution on a symmetric domain, can be expressed as an asymptotic series in even powers of $h$:\n$$ U_h = u + C_1 h^2 + C_2 h^4 + C_3 h^6 + \\dots $$\nwhere $U_h$ is the numerical approximation at a point, $u$ is the exact solution at that point, and $C_k$ are constants independent of $h$.\n\nWe compute the solution at the domain center for three grids with spacings $h_0$, $h_1=h_0/2$, and $h_2=h_0/4$. Let the corresponding numerical solutions be $A_0, A_1, A_2$.\n$$ A_0 = u + C_1 h_0^2 + C_2 h_0^4 + O(h_0^6) $$\n$$ A_1 = u + C_1 (h_0/2)^2 + C_2 (h_0/2)^4 + O(h_0^6) = u + \\frac{1}{4}C_1 h_0^2 + \\frac{1}{16}C_2 h_0^4 + O(h_0^6) $$\n$$ A_2 = u + C_1 (h_0/4)^2 + C_2 (h_0/4)^4 + O(h_0^6) = u + \\frac{1}{16}C_1 h_0^2 + \\frac{1}{256}C_2 h_0^4 + O(h_0^6) $$\n\n**First Extrapolation (to order $O(h^4)$):**\nWe combine pairs of approximations to eliminate the leading $O(h^2)$ error term. The general formula for a refinement ratio $r$ and error order $p$ is $(r^p A_{fine} - A_{coarse}) / (r^p-1)$. Here, $r=2$ and $p=2$.\nLet $B_0$ be the extrapolated value from $A_0$ and $A_1$:\n$$ B_0 = \\frac{2^2 A_1 - A_0}{2^2 - 1} = \\frac{4A_1 - A_0}{3} = u - \\frac{1}{4}C_2 h_0^4 + O(h_0^6) $$\nLet $B_1$ be the extrapolated value from $A_1$ and $A_2$:\n$$ B_1 = \\frac{2^2 A_2 - A_1}{2^2 - 1} = \\frac{4A_2 - A_1}{3} = u - \\frac{1}{4}C_2 (h_0/2)^4 + O(h_0^6) = u - \\frac{1}{64}C_2 h_0^4 + O(h_0^6) $$\n$B_0$ and $B_1$ are now fourth-order accurate approximations.\n\n**Second Extrapolation (to order $O(h^6)$):**\nWe combine $B_0$ and $B_1$ to eliminate the $O(h^4)$ error term. The leading error is of order $p=4$.\n$$ U_{\\text{extrap}} = \\frac{2^4 B_1 - B_0}{2^4 - 1} = \\frac{16B_1 - B_0}{15} $$\nSubstituting the expressions for $B_0$ and $B_1$:\n$$ U_{\\text{extrap}} = \\frac{1}{15} \\left[ 16\\left(\\frac{4A_2 - A_1}{3}\\right) - \\left(\\frac{4A_1 - A_0}{3}\\right) \\right] $$\n$$ U_{\\text{extrap}} = \\frac{1}{45} \\left[ 16(4A_2 - A_1) - (4A_1 - A_0) \\right] $$\n$$ U_{\\text{extrap}} = \\frac{64A_2 - 16A_1 - 4A_1 + A_0}{45} = \\frac{64A_2 - 20A_1 + A_0}{45} $$\nThis final value $U_{\\text{extrap}}$ has a truncation error of $O(h_0^6)$.\n\n#### 4. Computational Procedure\nThe following algorithm is implemented for each test case $n_0 \\in \\{1, 7, 15\\}$:\n1.  Define the three interior grid sizes: $n_h = n_0$, $n_{h/2} = 2n_0+1$, and $n_{h/4} = 4n_0+3$.\n2.  For each grid size $n \\in \\{n_h, n_{h/2}, n_{h/4}\\}$:\n    a. Calculate the grid spacing $h = 1/(n+1)$.\n    b. Construct the $n^2 \\times n^2$ matrix $A$ and the $n^2 \\times 1$ right-hand side vector $\\vec{F}$.\n    c. Solve the linear system $A\\vec{U} = \\vec{F}$ to obtain the solution vector $\\vec{U}$.\n    d. Extract the solution at the center grid point. For an $n \\times n$ interior grid (using 0-based indexing from $0$ to $n-1$), the center indices are $(i_c,j_c) = ((n-1)/2, (n-1)/2)$. The corresponding 1D index is $k_c = i_c \\cdot n + j_c$. The center value is $U_{i_c,j_c}$.\n3.  Store the three center values as $A_0 = U_h$, $A_1 = U_{h/2}$, and $A_2 = U_{h/4}$.\n4.  Calculate the extrapolated value $U_{\\text{extrap}} = (64A_2 - 20A_1 + A_0) / 45$.\n5.  The exact solution at the center $(0.5,0.5)$ is $u(0.5,0.5) = \\sin(\\pi/2)\\sin(\\pi/2) = 1$.\n6.  Compute the absolute error: $E = |U_{\\text{extrap}} - 1|$.\n7.  Collect the errors for the three values of $n_0$ and present them as a list.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_poisson_center(n):\n    \"\"\"\n    Solves the 2D Poisson equation -Delta u = f on the unit square\n    using a five-point finite difference scheme on an n x n interior grid.\n\n    Args:\n        n (int): The number of interior grid points in one dimension.\n                 n must be odd.\n\n    Returns:\n        float: The numerical solution at the center of the domain (0.5, 0.5).\n    \"\"\"\n    if n % 2 == 0:\n        raise ValueError(\"n must be an odd integer for the center to be a grid point.\")\n\n    h = 1.0 / (n + 1)\n    \n    # Construct the n x n tridiagonal matrix T for the 1D operator.\n    # This corresponds to the stencil [-1, 4, -1].\n    # The problem defines the discrete operator as (4U_ij - U_i-1,j - ...)/h^2\n    # which leads to a matrix A with 4/h^2 on the main diagonal.\n    T = 4 * np.eye(n) - np.eye(n, k=1) - np.eye(n, k=-1)\n    \n    # Construct the n^2 x n^2 matrix A for the 2D operator -Delta_h\n    # using Kronecker products. This forms the block-tridiagonal matrix.\n    # The full matrix is A = (1/h^2) * (I kron T_diag_2 + T_diag_2 kron I)\n    # where T_diag_2 has diag [ -1 2 -1 ].\n    # Our T has diag [-1 4 -1], so we need to adjust.\n    # Let T_std = 2*eye - eye(k=1) - eye(k=-1). Then operator is (I kron T_std + T_std kron I)/h^2\n    # (I kron T_std + T_std kron I) = I kron (T-2I) + (T-2I) kron I\n    # = I kron T - 2(I kron I) + T kron I - 2(I kron I) = I kron T + T kron I - 4I\n    # Our stencil is (4U - ...), which corresponds to A = (1/h^2) * block_tridiag(T, -I).\n    # Let's build A directly.\n    A_mat = np.zeros((n*n, n*n))\n\n    # Diagonal blocks (T)\n    for i in range(n):\n        A_mat[i*n:(i+1)*n, i*n:(i+1)*n] = T\n\n    # Off-diagonal blocks (-I)\n    off_diag_block = -np.eye(n)\n    for i in range(n - 1):\n        A_mat[(i+1)*n:(i+2)*n, i*n:(i+1)*n] = off_diag_block\n        A_mat[i*n:(i+1)*n, (i+1)*n:(i+2)*n] = off_diag_block\n    \n    A_mat /= h**2\n    \n    # Construct the right-hand side vector F\n    # Create grid coordinates for interior points\n    x = np.linspace(h, 1.0 - h, n)\n    y = np.linspace(h, 1.0 - h, n)\n    # Use 'ij' indexing to match row-major flattening\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n    \n    # Evaluate the source function f(x,y)\n    F_grid = 2 * (np.pi**2) * np.sin(np.pi * xx) * np.sin(np.pi * yy)\n    \n    # Flatten grid to a vector, matching the matrix's row-major ordering\n    F_vec = F_grid.flatten()\n    \n    # Solve the linear system A * U = F\n    U_vec = np.linalg.solve(A_mat, F_vec)\n    \n    # Extract the solution at the center\n    # For an n x n grid (0-indexed), the center is at ( (n-1)/2, (n-1)/2 )\n    center_idx_1d = (n - 1) // 2\n    center_k = center_idx_1d * n + center_idx_1d\n    \n    return U_vec[center_k]\n\ndef solve():\n    \"\"\"\n    Main function to run the Richardson extrapolation procedure for the given test cases.\n    \"\"\"\n    # The program must run the procedure for three base interior sizes n0.\n    # The test cases specify these base sizes.\n    test_cases = [1, 7, 15]\n    \n    results = []\n    \n    for n0 in test_cases:\n        # Define the three nested grid sizes\n        n_h = n0\n        n_h_div_2 = 2 * n0 + 1\n        n_h_div_4 = 4 * n0 + 3\n        \n        # Calculate the numerical solution at the center for each grid\n        A0 = solve_poisson_center(n_h)        # Coarsest grid, h\n        A1 = solve_poisson_center(n_h_div_2)  # Medium grid, h/2\n        A2 = solve_poisson_center(n_h_div_4)  # Finest grid, h/4\n        \n        # Apply the three-level Richardson extrapolation formula:\n        # U_extrap = (64 * A2 - 20 * A1 + A0) / 45\n        U_extrap = (64.0 * A2 - 20.0 * A1 + A0) / 45.0\n        \n        # Exact solution at the center (0.5, 0.5)\n        u_exact_center = np.sin(np.pi / 2.0) * np.sin(np.pi / 2.0) # which is 1.0\n        \n        # Compute the absolute error\n        error = np.abs(U_extrap - u_exact_center)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.16e}' for err in results)}]\")\n\nsolve()\n\n```", "id": "3228920"}]}