{"hands_on_practices": [{"introduction": "To begin our hands-on exploration, we'll start with the simplest possible case: the zero matrix. This exercise may seem trivial at first, but it is a powerful tool for clarifying the fundamental properties and constraints of the matrices involved in a Schur decomposition. By analyzing this case, you will gain a solid understanding of the relationship between the matrix $A$, its upper-triangular form $T$, and the unitary matrix $U$, particularly regarding the non-uniqueness of the decomposition [@problem_id:1388388].", "problem": "Recall that the Schur decomposition of an $n \\times n$ complex matrix $A$ states that there exists a unitary matrix $U$ (i.e., a matrix such that $U^*U = I_n$, where $I_n$ is the $n \\times n$ identity matrix and $U^*$ is the conjugate transpose of $U$) and an upper triangular matrix $T$ such that $A = U T U^*$.\n\nLet $O_n$ be the $n \\times n$ zero matrix, with $n \\geq 2$. Consider the Schur decomposition of $O_n$. Which of the following statements about the matrices $U$ and $T$ in the decomposition $O_n = U T U^*$ are true? Select all valid options.\n\nA. The upper triangular matrix $T$ must be the $n \\times n$ zero matrix $O_n$.\n\nB. The unitary matrix $U$ must be the $n \\times n$ identity matrix $I_n$.\n\nC. The unitary matrix $U$ can be any $n \\times n$ unitary matrix.\n\nD. The diagonal entries of the upper triangular matrix $T$ are the eigenvalues of $O_n$.\n\nE. There are infinitely many possible choices for the matrix $U$.", "solution": "We are given the Schur decomposition of the $n \\times n$ zero matrix $O_n$ as $O_n = U T U^*$, where $U$ is a unitary matrix and $T$ is an upper triangular matrix. Our goal is to evaluate the truthfulness of the given statements.\n\nFirst, let's determine the matrix $T$. The definition of the Schur decomposition is $A = U T U^*$. We can rearrange this equation to solve for $T$ by using the property that for a unitary matrix $U$, its inverse is its conjugate transpose, i.e., $U^{-1} = U^*$.\n\nStarting from $O_n = U T U^*$, we left-multiply by $U^*$ and right-multiply by $U$:\n$$U^* O_n U = U^* (U T U^*) U$$\nUsing the associative property of matrix multiplication:\n$$U^* O_n U = (U^* U) T (U^* U)$$\nBy the definition of a unitary matrix, $U^* U = I_n$, where $I_n$ is the $n \\times n$ identity matrix. Substituting this into the equation gives:\n$$U^* O_n U = I_n T I_n$$\n$$U^* O_n U = T$$\nThe product of any matrix with the zero matrix is the zero matrix. Thus, $U^* O_n = O_n$, and subsequently $O_n U = O_n$. This implies:\n$$T = O_n$$\nSo, the upper triangular matrix $T$ must be the $n \\times n$ zero matrix. The zero matrix is indeed upper triangular (as all entries above the main diagonal are zero).\n\nNow, let's evaluate each statement with this finding.\n\n**A. The upper triangular matrix $T$ must be the $n \\times n$ zero matrix $O_n$.**\nAs derived above, $T$ is uniquely determined to be the zero matrix $O_n$. Therefore, this statement is **true**.\n\n**B. The unitary matrix $U$ must be the $n \\times n$ identity matrix $I_n$.**\nLet's substitute $T=O_n$ back into the Schur decomposition equation:\n$$O_n = U O_n U^*$$\nLet's see if this equation constrains $U$. The product of any matrix $U$ with the zero matrix $O_n$ is the zero matrix ($U O_n = O_n$). So the equation becomes:\n$$O_n = O_n U^*$$\nSimilarly, the product of the zero matrix with any matrix $U^*$ is the zero matrix ($O_n U^* = O_n$). The equation simplifies to:\n$$O_n = O_n$$\nThis equation is always true, which means it holds for *any* matrix $U$. The Schur decomposition requires $U$ to be unitary, but places no other restriction on it. Since there exist unitary matrices other than the identity matrix for $n \\ge 2$, the matrix $U$ does not have to be $I_n$. Thus, this statement is **false**.\n\n**C. The unitary matrix $U$ can be any $n \\times n$ unitary matrix.**\nAs shown in the analysis for statement B, the equation $O_n = U O_n U^*$ is satisfied for any choice of $U$. For the equation to represent a Schur decomposition, $U$ must be unitary. Therefore, any $n \\times n$ unitary matrix is a valid choice for $U$ in the Schur decomposition of the zero matrix. This statement is **true**.\n\n**D. The diagonal entries of the upper triangular matrix $T$ are the eigenvalues of $O_n$.**\nA fundamental property of the Schur decomposition $A = UTU^*$ is that the diagonal entries of the upper triangular matrix $T$ are the eigenvalues of the matrix $A$. Let's verify this for our specific case.\nThe eigenvalues of the zero matrix $O_n$ are the roots of its characteristic polynomial, $\\det(O_n - \\lambda I_n) = 0$.\n$$\\det(-\\lambda I_n) = (-\\lambda)^n \\det(I_n) = (-\\lambda)^n = 0$$\nThe only eigenvalue is $\\lambda = 0$, with an algebraic multiplicity of $n$.\nFrom our initial analysis, we found that $T = O_n$. The diagonal entries of the $n \\times n$ zero matrix are all 0.\nThus, the diagonal entries of $T$ are indeed the eigenvalues of $O_n$. This statement is **true**.\n\n**E. There are infinitely many possible choices for the matrix $U$.**\nAs established in the analysis of statement C, any $n \\times n$ unitary matrix is a valid choice for $U$. The set of all $n \\times n$ unitary matrices forms the unitary group $U(n)$. For $n \\ge 2$, this group is a continuous set and is uncountably infinite. For instance, for $n=2$, matrices of the form $\\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix}$ for $\\theta \\in [0, 2\\pi)$ are all distinct unitary matrices. Thus, there are infinitely many possible choices for $U$. This statement is **true**.\n\nIn summary, statements A, C, D, and E are true, while statement B is false.", "answer": "$$\\boxed{ACDE}$$", "id": "1388388"}, {"introduction": "Now that we have explored the conceptual foundations, let's move to a concrete computational problem. This exercise requires you to construct a Schur decomposition for a given $2 \\times 2$ matrix, but with a specific condition: the eigenvalues on the diagonal of the upper-triangular matrix $T$ must appear in ascending order. This practice is valuable because it moves beyond the existence theorem and forces you to engage with the constructive proof of the Schur decomposition, building the unitary matrix $U$ from the ground up to achieve a desired structure [@problem_id:1388423].", "problem": "Consider the real matrix $A$ defined by the components $A_{11}=5$, $A_{12}=-1$, $A_{21}=0$, and $A_{22}=3$. The Schur decomposition theorem states that for any square matrix, there exists a decomposition $A = UTU^*$, where $U$ is a unitary matrix and $T$ is an upper-triangular matrix, and $U^*$ is the conjugate transpose of $U$.\n\nFind the specific upper-triangular matrix $T$ for a Schur decomposition of $A$ that satisfies the condition that the diagonal entries of $T$ appear in strictly ascending order from the top-left to the bottom-right.", "solution": "We are given the real matrix\n$$\nA=\\begin{pmatrix}5  -1 \\\\ 0  3\\end{pmatrix},\n$$\nand by the Schur decomposition theorem there exists a unitary (here, real orthogonal) matrix $U$ and an upper-triangular matrix $T$ such that $A=UTU^{*}$, equivalently $T=U^{*}AU$, with the diagonal entries of $T$ equal to the eigenvalues of $A$. The requirement is that the diagonal entries appear in strictly ascending order from top-left to bottom-right.\n\nFirst, compute the eigenvalues of $A$. Since $A$ is upper triangular, its eigenvalues are its diagonal entries, namely $5$ and $3$. To place them in ascending order on the diagonal of $T$, we need\n$$\n\\operatorname{diag}(T)=(3,5).\n$$\n\nNext, choose $U$ so that the first Schur vector is an eigenvector for the eigenvalue $3$. Solve $(A-3I)v=0$:\n$$\nA-3I=\\begin{pmatrix}2  -1 \\\\ 0  0\\end{pmatrix},\\quad 2x_{1}-x_{2}=0\\ \\Rightarrow\\ x_{2}=2x_{1}.\n$$\nAn eigenvector is $v_{3}=\\begin{pmatrix}1 \\\\ 2\\end{pmatrix}$. Normalize it to get\n$$\nu_{1}=\\frac{1}{\\sqrt{5}}\\begin{pmatrix}1 \\\\ 2\\end{pmatrix}.\n$$\nChoose $u_{2}$ as a unit vector orthogonal to $u_{1}$, for instance\n$$\nu_{2}=\\frac{1}{\\sqrt{5}}\\begin{pmatrix}-2 \\\\ 1\\end{pmatrix}.\n$$\nThen $U=\\begin{pmatrix}u_{1}  u_{2}\\end{pmatrix}$ is orthogonal, so $U^{*}=U^{T}$.\n\nDefine $T=U^{*}AU$. Its entries are $t_{ij}=u_{i}^{*}Au_{j}$. Since $Au_{1}=3u_{1}$, we have\n$$\nt_{11}=u_{1}^{*}Au_{1}=3,\\qquad t_{21}=u_{2}^{*}Au_{1}=u_{2}^{*}(3u_{1})=3\\,u_{2}^{*}u_{1}=0,\n$$\nso $T$ is upper triangular. The trace is preserved under similarity, so\n$$\nt_{11}+t_{22}=\\operatorname{tr}(T)=\\operatorname{tr}(A)=8\\ \\Rightarrow\\ t_{22}=5.\n$$\nIt remains to compute $t_{12}=u_{1}^{*}Au_{2}$. Compute\n$$\nAu_{2}=\\frac{1}{\\sqrt{5}}\\begin{pmatrix}5  -1 \\\\ 0  3\\end{pmatrix}\\begin{pmatrix}-2 \\\\ 1\\end{pmatrix}\n=\\frac{1}{\\sqrt{5}}\\begin{pmatrix}-11 \\\\ 3\\end{pmatrix},\n$$\nhence\n$$\nt_{12}=u_{1}^{*}Au_{2}\n=\\left(\\frac{1}{\\sqrt{5}}\\begin{pmatrix}1  2\\end{pmatrix}\\right)\\left(\\frac{1}{\\sqrt{5}}\\begin{pmatrix}-11 \\\\ 3\\end{pmatrix}\\right)\n=\\frac{1}{5}(-11+6)=-1.\n$$\n\nTherefore, a Schur form with strictly ascending diagonal entries is\n$$\nT=\\begin{pmatrix}3  -1 \\\\ 0  5\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}3  -1 \\\\ 0  5\\end{pmatrix}}$$", "id": "1388423"}, {"introduction": "Our final practice problem bridges the gap between abstract theory and practical scientific computing. While any real matrix has a complex Schur decomposition, in many applications it is highly advantageous to work entirely with real numbers, leading to the Real Schur Decomposition. This advanced exercise guides you through the process of writing an algorithm to convert a given complex Schur form into its real counterpart, a standard procedure in numerical linear algebra libraries. Completing this task will provide insight into how theoretical decompositions are adapted for robust and efficient computation, forming the basis for solving problems in fields like control theory and dynamical systems analysis [@problem_id:3271057].", "problem": "A real square matrix $A \\in \\mathbb{R}^{n \\times n}$ admits a Complex Schur Decomposition, which states there exists a unitary matrix $Q \\in \\mathbb{C}^{n \\times n}$ and an upper triangular matrix $T \\in \\mathbb{C}^{n \\times n}$ such that $A = Q T Q^{*}$, where $Q^{*}$ denotes the conjugate transpose of $Q$. A real square matrix also admits a Real Schur Decomposition, which states there exists an orthogonal matrix $Z \\in \\mathbb{R}^{n \\times n}$ and a quasi-upper triangular matrix $R \\in \\mathbb{R}^{n \\times n}$ (an upper triangular matrix of $1 \\times 1$ and $2 \\times 2$ real blocks on the diagonal, with zeros strictly below the first subdiagonal) such that $A = Z R Z^{\\top}$, where $Z^{\\top}$ denotes the transpose of $Z$. For a real matrix $A$, complex eigenvalues occur in conjugate pairs; consequently, a Complex Schur Form can be transformed into a Real Schur Form by choosing appropriate real bases for the invariant subspaces associated with real eigenvalues (one-dimensional subspaces) and complex conjugate pairs (two-dimensional real invariant subspaces).\n\nStarting from the above foundational facts of linear algebra, write a complete program that implements a function which, given a Complex Schur Form $(Q, T)$ of a real matrix $A$, constructs a corresponding Real Schur Form $(Z, R)$. The function must:\n- Accept $Q \\in \\mathbb{C}^{n \\times n}$ and $T \\in \\mathbb{C}^{n \\times n}$ satisfying $A = Q T Q^{*}$ for some real $A$.\n- Assume the diagonal entries of $T$ are ordered so that complex conjugate eigenvalues appear consecutively (each pair is of the form $\\lambda = \\alpha + i \\beta$ followed by $\\overline{\\lambda} = \\alpha - i \\beta$), and real eigenvalues appear as singletons.\n- Produce $Z \\in \\mathbb{R}^{n \\times n}$ orthogonal and $R \\in \\mathbb{R}^{n \\times n}$ quasi-upper triangular such that $A = Z R Z^{\\top}$.\n\nYour algorithm should be based on the following principle:\n- For a real eigenvalue $\\lambda \\in \\mathbb{R}$, the one-dimensional invariant subspace is spanned by the corresponding Schur vector $q \\in \\mathbb{C}^{n}$; because $A$ is real, this vector can be rephased to be real, and then normalized to yield a real column of $Z$.\n- For a complex conjugate pair $\\lambda = \\alpha + i \\beta$ and $\\overline{\\lambda} = \\alpha - i \\beta$ with $\\beta \\neq 0$, the corresponding two-dimensional invariant subspace can be represented by an orthonormal real basis constructed from the real and imaginary parts of one Schur vector $q \\in \\mathbb{C}^{n}$ associated with $\\lambda$, followed by real orthonormalization (for instance, using a standard Gramâ€“Schmidt process).\n\nTo make the task concrete and testable, your program must construct the Complex Schur Forms $(Q, T)$ for the following test matrices $A$ using the well-known unitary diagonalization property of normal matrices (i.e., for these choices $A = Q \\Lambda Q^{*}$ with $\\Lambda$ diagonal), where the eigenvectors from the standard eigen-decomposition are normalized to form the unitary matrix $Q$ and $T$ is set to the diagonal matrix of eigenvalues in the prescribed order:\n- Test $1$ (two-by-two complex pair): \n$$A_{1} = \\begin{bmatrix} 1  2 \\\\ -2  1 \\end{bmatrix}$$\n- Test $2$ (one real eigenvalue and one complex pair): \n$$A_{2} = \\operatorname{block\\_diag}\\!\\left(\\begin{bmatrix} 2 \\end{bmatrix}, \\begin{bmatrix} 1  3 \\\\ -3  1 \\end{bmatrix}\\right)$$\n- Test $3$ (two complex pairs): \n$$A_{3} = \\operatorname{block\\_diag}\\!\\left(\\begin{bmatrix} 0  2 \\\\ -2  0 \\end{bmatrix}, \\begin{bmatrix} -1  1 \\\\ -1  -1 \\end{bmatrix}\\right)$$\n- Test $4$ (all real eigenvalues, symmetric): \n$$A_{4} = \\begin{bmatrix} 2  1  0 \\\\ 1  3  1 \\\\ 0  1  4 \\end{bmatrix}$$\n\nFor each test matrix $A$, perform the following steps:\n- Compute $(Q, T)$ as described above (unitary eigenvector matrix $Q$ and diagonal $T$ with eigenvalues ordered so that complex conjugate pairs are consecutive and real eigenvalues precede pairs).\n- Convert $(Q, T)$ to $(Z, R)$ as specified.\n- Compute the following four quantitative diagnostics (each a real number):\n    $1.$ Orthogonality error: $\\left\\|Z^{\\top} Z - I\\right\\|_{F}$, where $I$ is the identity matrix and $\\|\\cdot\\|_{F}$ denotes the Frobenius norm.\n    $2.$ Quasi-upper-triangularity error: the Frobenius norm of the entries of $R$ strictly below the first subdiagonal, i.e., $\\left\\| R_{i j} \\right\\|_{F}$ over indices with $i - j  1$.\n    $3.$ Reconstruction error: $\\left\\| A - Z R Z^{\\top} \\right\\|_{F}$.\n    $4.$ Eigenvalue matching error: for the eigenvalues $\\{\\mu_{k}\\}$ of $A$ and $\\{\\nu_{k}\\}$ of $R$, compute $\\max_{k} \\min_{\\ell} \\left| \\mu_{k} - \\nu_{\\ell} \\right|$.\n\nYour program should produce a single line of output containing the a comma-separated list enclosed in square brackets, where each test case contributes a list of four floating-point values in the order given above. For example, the format must be `[ [e11, e12, e13, e14], [e21, e22, e23, e24], [e31, e32, e33, e34], [e41, e42, e43, e44] ]`. No physical units or angle units are involved, and no percentages are required; all answers are real numbers.", "solution": "The user wants to implement a program that converts a Complex Schur Form $(Q, T)$ of a real matrix $A$ into a Real Schur Form $(Z, R)$. The program must be tested on four specific matrices, and for each, a set of four diagnostic errors must be computed and reported.\n\n### Step 1: Theoretical Foundation and Algorithm Design\n\nA real matrix $A \\in \\mathbb{R}^{n \\times n}$ has eigenvalues that are either real or occur in complex conjugate pairs. The Schur decomposition, $A = U S U^*$, where $U$ is unitary and $S$ is upper-triangular, will have the eigenvalues of $A$ on the diagonal of $S$. If $A$ is real, we can find a *real* orthogonal matrix $Z$ such that $A = Z R Z^\\top$, where $R$ is a real quasi-upper-triangular matrix. The diagonal of $R$ consists of $1 \\times 1$ blocks for real eigenvalues and $2 \\times 2$ blocks for complex conjugate pairs.\n\nThe task is to convert a given Complex Schur Form $(Q, T)$ to a Real Schur Form $(Z, R)$. We are given that $A = Q T Q^*$ is real, $Q$ is unitary, $T$ is upper-triangular (and diagonal for the normal test matrices provided), and its diagonal entries are ordered such that real eigenvalues are grouped and complex conjugate pairs are adjacent.\n\nThe conversion algorithm proceeds by iterating through the diagonal of $T$ and applying local unitary transformations to transform the columns of $Q$ into real vectors, which will form the columns of a new real orthogonal matrix $Z$. The same transformations are applied to $T$ to maintain the equality, resulting in the quasi-upper-triangular matrix $R$.\n\nLet $Z_0 = Q$ and $R_0 = T$. We iteratively construct a sequence of unitary matrices $U_k$ to produce $Z_{k+1} = Z_k U_k$ and $R_{k+1} = U_k^* R_k U_k$, such that $Z_k$ progressively becomes real. The final $Z$ will be $Z = Q U_0 U_1 \\dots$ and $R = \\dots U_1^* U_0^* T U_0 U_1 \\dots$.\n\nThe process iterates through the diagonal elements of $T$ (the eigenvalues):\n1.  **Real Eigenvalue**: If $T_{kk} = \\lambda_k \\in \\mathbb{R}$, the corresponding Schur vector $q_k$ (the $k$-th column of $Q$) spans a one-dimensional real-invariant subspace. This implies that $q_k$ can be made real by multiplying it by a suitable phase factor $e^{i\\phi}$. We find a component $q_{jk}$ with the largest magnitude and choose $e^{i\\phi}$ to make this component real. Since $A$ and $\\lambda_k$ are real, $A q_k = \\lambda_k q_k$ implies that if one component of $q_k$ is made real, the entire vector becomes real. This corresponds to a transformation $U_k$ which is the identity matrix except for a phase factor at position $(k, k)$. The updated $Q$ becomes $Q U_k$ and $T$ becomes $U_k^* T U_k$.\n\n2.  **Complex Conjugate Pair**: If $T_{kk} = \\lambda = \\alpha + i\\beta$ (with $\\beta \\neq 0$), then due to the specified ordering, $T_{k+1, k+1} = \\overline{\\lambda} = \\alpha - i\\beta$. The corresponding Schur vectors, $q_k$ and $q_{k+1}$, span a two-dimensional invariant subspace. A real orthonormal basis for this subspace can be constructed. For instance, if we assume $q_{k+1} \\approx \\overline{q_k}$ (which is the case for eigenvectors of a real matrix), we can form two new real, orthonormal vectors: $z_k = \\frac{1}{\\sqrt{2}}(q_k + q_{k+1})$ and $z_{k+1} = \\frac{1}{i\\sqrt{2}}(q_k - q_{k+1})$. This change of basis is accomplished by a $2 \\times 2$ unitary transformation $V = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1  -i \\\\ 1  i \\end{pmatrix}$ applied to columns $k$ and $k+1$ of $Q$. The corresponding similarity transformation on the $2 \\times 2$ diagonal block of $T$ is:\n    $$ V^* \\begin{pmatrix} \\lambda  0 \\\\ 0  \\overline{\\lambda} \\end{pmatrix} V = \\begin{pmatrix} \\alpha  \\beta \\\\ -\\beta  \\alpha \\end{pmatrix} $$\n    This yields the desired $2 \\times 2$ real block in $R$. The full transformation $U_k$ is an identity matrix with this $V$ block at indices $(k,k+1)$.\n\nThis process is applied iteratively until all columns of $Q$ have been processed, resulting in a real orthogonal matrix $Z$ and a real quasi-upper-triangular matrix $R$.\n\n### Step 2: Implementation Strategy\n\nThe program will be structured as follows:\n1.  A main function `solve()` will orchestrate the entire process for the four test cases.\n2.  The test matrices $A_1, A_2, A_3, A_4$ will be defined.\n3.  For each matrix $A$:\n    a.  Compute the eigendecomposition $(V, \\Lambda)$ using `numpy.linalg.eig`.\n    b.  The problem states that for these normal matrices, the Complex Schur form $(Q, T)$ can be taken as the unitary eigenvector matrix and the diagonal eigenvalue matrix. The eigenvalues and eigenvectors are sorted to group real values first, followed by complex conjugate pairs. A custom sorting key ensures that for a pair $\\alpha \\pm i\\beta$, the eigenvalue with the positive imaginary part, $\\alpha+i\\beta$, appears first.\n    c.  The sorted eigenvectors form the columns of the unitary matrix $Q$, and the sorted eigenvalues form the diagonal of the upper-triangular matrix $T$.\n    d.  A function `complex_to_real_schur(Q, T)` is called to perform the conversion based on the algorithm described above. This function iterates through the diagonal of $T$ and applies the appropriate $1 \\times 1$ phase or $2 \\times 2$ block transformations to $Q$ and $T$, yielding $Z$ and $R$.\n    e.  The four specified diagnostic metrics are calculated:\n        i.   **Orthogonality error**: $\\|Z^\\top Z - I\\|_F$ is computed to verify that $Z$ is orthogonal.\n        ii.  **Quasi-upper-triangularity error**: The Frobenius norm of the elements of $R$ strictly below the first subdiagonal ($R_{ij}$ for $i-j  1$) is computed.\n        iii. **Reconstruction error**: $\\|A - Z R Z^\\top\\|_F$ is computed to verify the decomposition.\n        iv.  **Eigenvalue matching error**: The eigenvalues of $A$ and $R$ are computed, and the error $\\max_{k} \\min_{\\ell} |\\mu_k(A) - \\nu_\\ell(R)|$ is calculated.\n4.  The results for all test cases are collected and printed in the specified list-of-lists format.\n\nThis implementation plan is a direct translation of the theoretical principles into a concrete numerical algorithm.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef complex_to_real_schur(Q, T):\n    \"\"\"\n    Converts a Complex Schur form (Q, T) of a real matrix to a Real Schur Form (Z, R).\n    \n    Args:\n        Q (np.ndarray): Unitary matrix from Complex Schur form.\n        T (np.ndarray): Upper-triangular matrix from Complex Schur form.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple (Z, R) representing the Real Schur form,\n                                       where Z is real orthogonal and R is real quasi-upper-triangular.\n    \"\"\"\n    Z = Q.copy().astype(np.complex128)\n    R = T.copy().astype(np.complex128)\n    n = Z.shape[0]\n    k = 0\n    tol = 1e-9\n\n    while k  n:\n        # Check if eigenvalue is complex\n        if abs(np.imag(R[k, k]))  tol:\n            # Complex conjugate pair case. The problem guarantees they are adjacent.\n            if k + 1 = n:\n                # This should not be reached with proper input ordering.\n                k += 1\n                continue\n            \n            # Unitary transformation for a 2x2 block\n            V = (1 / np.sqrt(2)) * np.array([[1, -1j], [1, 1j]], dtype=np.complex128)\n            \n            # Apply transformation to Z: Z_new = Z_old @ U_k\n            Z[:, k:k+2] = Z[:, k:k+2] @ V\n            \n            # Apply similarity transformation to R: R_new = U_k^* @ R_old @ U_k\n            R[:, k:k+2] = R[:, k:k+2] @ V\n            R[k:k+2, :] = V.conj().T @ R[k:k+2, :]\n            \n            k += 2\n        else:\n            # Real eigenvalue case\n            # Re-phase column k of Z to be real.\n            Z_col = Z[:, k]\n            \n            # Only apply correction if there's a significant imaginary part\n            if np.linalg.norm(np.imag(Z_col))  tol:\n                # Find element with largest magnitude to define the phase\n                j = np.argmax(np.abs(Z_col))\n                phase_val = Z_col[j]\n                \n                # Phase correction factor to make Z_col[j] real\n                c = phase_val.conj() / np.abs(phase_val) if np.abs(phase_val)  tol else 1.0\n                \n                # Apply transformation to Z: Z_new = Z_old @ U_k where U_k is diag(1,..,c,..)\n                Z[:, k] *= c\n                \n                # Apply similarity transformation to R: R_new = U_k^* @ R_old @ U_k\n                R[:, k] *= c\n                R[k, :] *= c.conj()\n            \n            k += 1\n\n    # Discard small imaginary parts resulting from floating-point noise\n    Z_real = np.real(Z)\n    R_real = np.real(R)\n\n    return Z_real, R_real\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([[1., 2.], [-2., 1.]]),\n        np.array([[2., 0., 0.], [0., 1., 3.], [0., -3., 1.]]),\n        np.array([[0., 2., 0., 0.], [-2., 0., 0., 0.], [0., 0., -1., 1.], [0., 0., -1., -1.]]),\n        np.array([[2., 1., 0.], [1., 3., 1.], [0., 1., 4.]])\n    ]\n\n    all_results = []\n    tol = 1e-9\n\n    for A in test_cases:\n        n = A.shape[0]\n        \n        # Step 1: Compute eigendecomposition of A. For normal matrices, this is a Schur form.\n        eigvals, eigvecs = np.linalg.eig(A)\n\n        # Step 2: Sort eigenvalues and eigenvectors according to the problem specification.\n        # Real eigenvalues precede complex conjugate pairs.\n        # Pairs are ordered by real part, then |imaginary part|.\n        # Within a pair, the eigenvalue with the positive imaginary part comes first.\n        e_list = sorted(list(zip(eigvals, eigvecs.T)), \n                        key=lambda e: (abs(e[0].imag)  tol, e[0].real, abs(e[0].imag), -e[0].imag))\n\n        # Unpack the sorted list to get the initial Complex Schur form (Q, T)\n        sorted_eigvals, sorted_eigvecs_T = zip(*e_list)\n        Q = np.array(sorted_eigvecs_T, dtype=np.complex128).T\n        T = np.diag(np.array(sorted_eigvals, dtype=np.complex128))\n\n        # Step 3: Convert the Complex Schur form (Q, T) to a Real Schur form (Z, R)\n        Z, R = complex_to_real_schur(Q, T)\n\n        # Step 4: Compute the four quantitative diagnostics.\n        # 1. Orthogonality error of Z\n        ortho_err = np.linalg.norm(Z.T @ Z - np.eye(n), 'fro')\n\n        # 2. Quasi-upper-triangularity error of R (norm of elements below the first subdiagonal)\n        tri_err = np.linalg.norm(np.tril(R, k=-2))\n        \n        # 3. Reconstruction error\n        recon_err = np.linalg.norm(A - Z @ R @ Z.T, 'fro')\n\n        # 4. Eigenvalue matching error between A and R\n        mu = np.linalg.eigvals(A)\n        nu = np.linalg.eigvals(R)\n        \n        # Compute max_k min_l |mu_k - nu_l| using broadcasting\n        dists = np.abs(mu[:, np.newaxis] - nu)\n        min_dists_for_mu = np.min(dists, axis=1)\n        eig_match_err = np.max(min_dists_for_mu)\n        \n        all_results.append([ortho_err, tri_err, recon_err, eig_match_err])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(res) for res in all_results)}]\")\n\nsolve()\n```", "id": "3271057"}]}