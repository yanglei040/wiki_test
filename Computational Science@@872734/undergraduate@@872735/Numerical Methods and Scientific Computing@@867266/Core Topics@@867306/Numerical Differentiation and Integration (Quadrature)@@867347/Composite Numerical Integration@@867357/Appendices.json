{"hands_on_practices": [{"introduction": "Mastering composite integration begins with understanding its behavior on well-behaved functions. This first practice applies the composite Simpson's rule to a smooth integrand, for which the theory promises a high order of convergence. By deriving the theoretical error bound from first principles and comparing it with the actual computed error, you will build a foundational understanding of the method's accuracy and predictability. [@problem_id:3214984]", "problem": "You are to design and implement a complete program to approximate a definite integral using the composite Simpson method and to analyze the error using a rigorous derivative bound. Work in purely mathematical terms. Consider the integral\n$$\nI = \\int_{0}^{1} \\frac{1}{1 + x^2}\\, dx.\n$$\nThe target integrand is the function $f(x) = \\frac{1}{1 + x^2}$ on the closed interval $[0,1]$. The exact value of $I$ can be expressed using the inverse tangent function in radians. Your tasks are:\n- Implement the composite Simpson method for any even integer $n \\ge 2$, understood as constructing, on each successive pair of subintervals of equal width, the unique quadratic interpolant to $f$ at the endpoints and midpoint and then integrating that quadratic exactly over the pair. The method must be applied to partition $[0,1]$ into $n$ subintervals of equal length.\n- Starting from the foundational error representation for interpolatory Newton–Cotes quadrature rules and the fact that Simpson’s rule is exact for all polynomials up to degree $3$, derive a bound of the form\n$$\n|E_n| \\le C \\, h^4 \\, \\max_{x \\in [0,1]} |f^{(4)}(x)|,\n$$\nwhere $E_n$ is the composite Simpson error, $h = \\frac{1}{n}$ is the subinterval width, and $C$ is a constant that depends only on the total interval length. Then compute the explicit numerical constant $C$ and the explicit bound $\\max_{x \\in [0,1]} |f^{(4)}(x)|$ for the given $f$.\n- Verify, by explicit differentiation, a correct and sufficiently tight bound for $|f^{(4)}(x)|$ on $[0,1]$. Use this bound to evaluate the corresponding theoretical error bound for each tested $n$.\n\nYour program must:\n- Use the following test suite of even subinterval counts $n$: $[2, 4, 10, 20, 100]$.\n- For each tested $n$, compute:\n  1. The composite Simpson approximation $S_n$ to $I$.\n  2. The absolute error $|S_n - I_{\\text{exact}}|$, where $I_{\\text{exact}} = \\arctan(1) - \\arctan(0) = \\pi/4$ in radians.\n  3. The theoretical error bound $B_n$ obtained by substituting your explicit bound for $\\max_{x \\in [0,1]} |f^{(4)}(x)|$ into the derived inequality for $|E_n|$.\n  4. A boolean indicator stating whether $|S_n - I_{\\text{exact}}| \\le B_n$ holds.\n- Produce a single line of output containing a list of results, one per test case, where each result is the list\n$$\n[n, \\, S_n, \\, |S_n - I_{\\text{exact}}|, \\, B_n, \\, \\text{ok}],\n$$\nwith $\\text{ok}$ being a boolean that is true if and only if $|S_n - I_{\\text{exact}}| \\le B_n$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[[\\cdot], [\\cdot], \\ldots]$).\n\nAll outputs are unitless real numbers. Angles, if any, must be understood and used in radians. No user input is allowed; the program must be fully self-contained and reproducible as written.", "solution": "The problem is assessed to be valid. It is a well-posed and self-contained exercise in numerical analysis, grounded in established mathematical principles, and free from any scientific or logical flaws.\n\n### Part 1: Composite Simpson's Rule\n\nThe task is to approximate the definite integral $I = \\int_{0}^{1} \\frac{1}{1 + x^2}\\, dx$ using the composite Simpson's method. The function is $f(x) = \\frac{1}{1+x^2}$ on the interval $[a, b] = [0, 1]$. The interval is partitioned into an even number $n$ of subintervals of equal width $h = \\frac{b-a}{n} = \\frac{1}{n}$. The grid points are $x_j = a + jh = \\frac{j}{n}$ for $j=0, 1, \\dots, n$.\n\nThe composite Simpson's rule is derived by applying the basic Simpson's rule to successive pairs of subintervals. The basic rule on an interval $[c, d]$ approximates the integral by integrating a quadratic interpolant at the endpoints and midpoint. The formula for the composite method is:\n$$\nS_n = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{j=1}^{n/2} f(x_{2j-1}) + 2\\sum_{j=1}^{n/2-1} f(x_{2j}) + f(x_n) \\right]\n$$\nThis formula sums the function values at the endpoints, $4$ times the function values at the odd-indexed interior points (midpoints of Simpson's sub-regions), and $2$ times the function values at the even-indexed interior points (shared endpoints of Simpson's sub-regions).\n\n### Part 2: Derivation of the Error Bound\n\nThe error of the basic Simpson's rule over a single interval of width $2h$, say $[c, c+2h]$, is given by:\n$$\nE_{\\text{basic}} = \\int_c^{c+2h} f(x) \\, dx - \\frac{h}{3}[f(c) + 4f(c+h) + f(c+2h)] = -\\frac{h^5}{90} f^{(4)}(\\xi)\n$$\nfor some $\\xi \\in (c, c+2h)$, provided $f$ is four times continuously differentiable.\n\nThe composite rule consists of $n/2$ such applications over intervals $[x_{2j-2}, x_{2j}]$ for $j=1, 2, \\dots, n/2$. The total error $E_n$ is the sum of the errors from these applications:\n$$\nE_n = \\sum_{j=1}^{n/2} \\left( -\\frac{h^5}{90} f^{(4)}(\\xi_j) \\right)\n$$\nwhere each $\\xi_j \\in (x_{2j-2}, x_{2j})$. By the Intermediate Value Theorem for sums, as $f^{(4)}(x)$ is continuous on $[a,b]$, there exists a value $\\mu \\in (a,b)$ such that $\\sum_{j=1}^{n/2} f^{(4)}(\\xi_j) = \\frac{n}{2} f^{(4)}(\\mu)$.\nSubstituting this into the error sum gives:\n$$\nE_n = -\\frac{h^5}{90} \\left( \\frac{n}{2} \\right) f^{(4)}(\\mu) = -\\frac{nh^5}{180} f^{(4)}(\\mu)\n$$\nSince $h = \\frac{b-a}{n}$, we have $n = \\frac{b-a}{h}$. Substituting for $n$:\n$$\nE_n = -\\frac{(b-a)h^4}{180} f^{(4)}(\\mu)\n$$\nThe absolute value of the error, $|E_n|$, is therefore bounded by:\n$$\n|E_n| \\le \\frac{(b-a)h^4}{180} \\max_{x \\in [a,b]} |f^{(4)}(x)|\n$$\nFor the given problem, $a=0$ and $b=1$, so $b-a=1$ and $h = 1/n$. The error bound takes the form required by the problem, $|E_n| \\le C \\, h^4 \\, \\max_{x \\in [0,1]} |f^{(4)}(x)|$, with the constant $C = \\frac{b-a}{180} = \\frac{1}{180}$. The final theoretical error bound formula to be implemented is:\n$$\nB_n = \\frac{1}{180 n^4} \\max_{x \\in [0,1]} |f^{(4)}(x)|\n$$\n\n### Part 3: Bounding the Fourth Derivative\n\nWe need to compute $f^{(4)}(x)$ for $f(x) = (1+x^2)^{-1}$ and find its maximum absolute value on $[0,1]$.\n\nThe first four derivatives are:\n$f'(x) = -2x(1+x^2)^{-2}$\n$f''(x) = (6x^2 - 2)(1+x^2)^{-3}$\n$f'''(x) = (24x - 24x^3)(1+x^2)^{-4} = 24x(1-x^2)(1+x^2)^{-4}$\n$f^{(4)}(x) = (120x^4 - 240x^2 + 24)(1+x^2)^{-5} = 24 \\frac{5x^4 - 10x^2 + 1}{(1+x^2)^5}$\n\nTo find the maximum of $|f^{(4)}(x)|$ on $[0,1]$, we examine the values at the endpoints and at any interior critical points. The critical points of $f^{(4)}(x)$ are the roots of $f^{(5)}(x)$.\n$f^{(5)}(x) = \\frac{d}{dx}f^{(4)}(x) = \\frac{-240x(3x^4 - 10x^2 + 3)}{(1+x^2)^6}$\nSetting $f^{(5)}(x)=0$, we find critical points at $x=0$ and where $3x^4 - 10x^2 + 3 = 0$. Let $u=x^2$, then $3u^2 - 10u + 3=0$, which factors as $(3u-1)(u-3)=0$. The solutions are $u=1/3$ and $u=3$. This corresponds to $x^2=1/3$ and $x^2=3$. The positive roots are $x=1/\\sqrt{3}$ and $x=\\sqrt{3}$.\nThe critical points in the interval $[0,1]$ are $x=0$ and $x=1/\\sqrt{3}$.\n\nWe evaluate $|f^{(4)}(x)|$ at the endpoints $x=0, x=1$ and the critical point $x=1/\\sqrt{3}$:\n- At $x=0$: $|f^{(4)}(0)| = |24 \\frac{1}{1}| = 24$.\n- At $x=1$: $|f^{(4)}(1)| = |24 \\frac{5 - 10 + 1}{(1+1)^5}| = |24 \\frac{-4}{32}| = |-3| = 3$.\n- At $x=1/\\sqrt{3}$: $|f^{(4)}(1/\\sqrt{3})| = |24 \\frac{5(1/9) - 10(1/3) + 1}{(1+1/3)^5}| = |24 \\frac{5/9 - 30/9 + 9/9}{(4/3)^5}| = |24 \\frac{-16/9}{1024/243}| = |-\\frac{81}{8}| = 10.125$.\n\nComparing these values, the maximum absolute value is $24$, which occurs at $x=0$.\nSo, $\\max_{x \\in [0,1]} |f^{(4)}(x)| = 24$.\n\n### Part 4: Final Theoretical Error Bound\n\nSubstituting $M_4 = 24$ into the error bound formula $B_n$:\n$$\nB_n = \\frac{1}{180 n^4} \\times 24 = \\frac{24}{180 n^4} = \\frac{2}{15 n^4}\n$$\nThis is the explicit theoretical error bound used for verification.\n\n### Part 5: Computational Procedure\n\nThe program will execute the following steps for each $n$ in the test suite $[2, 4, 10, 20, 100]$:\n1.  Calculate the composite Simpson's approximation $S_n$ for $I = \\int_0^1 \\frac{1}{1+x^2}dx$.\n2.  Calculate the exact value $I_{\\text{exact}} = \\arctan(1) - \\arctan(0) = \\pi/4$.\n3.  Compute the absolute error $|E_n| = |S_n - I_{\\text{exact}}|$.\n4.  Compute the theoretical error bound $B_n = \\frac{2}{15n^4}$.\n5.  Verify if $|E_n| \\le B_n$.\n6.  Collect these five values ($n, S_n, |E_n|, B_n$, and the boolean verification result) into a list for each $n$, and format the final output as a list of these lists.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical integration problem using composite Simpson's method\n    and verifies the result against a derived theoretical error bound.\n    \"\"\"\n    # Define problem parameters and test cases\n    a = 0.0\n    b = 1.0\n    I_exact = np.pi / 4.0\n    test_cases_n = [2, 4, 10, 20, 100]\n\n    def f(x):\n        \"\"\" The integrand function f(x) = 1/(1+x^2). \"\"\"\n        return 1.0 / (1.0 + x**2)\n\n    def composite_simpson(f_func, a_val, b_val, n_val):\n        \"\"\"\n        Computes the definite integral of f_func from a_val to b_val\n        using the composite Simpson's rule with n_val subintervals.\n        n_val must be an even integer.\n        \"\"\"\n        if n_val % 2 != 0:\n            raise ValueError(\"n must be an even integer.\")\n        \n        h = (b_val - a_val) / n_val\n        x_pts = np.linspace(a_val, b_val, n_val + 1)\n        y_pts = f_func(x_pts)\n        \n        # The formula is (h/3) * [y_0 + 4y_1 + 2y_2 + ... + 4y_{n-1} + y_n]\n        s = y_pts[0] + y_pts[-1]\n        \n        # Sum of odd-indexed terms: 4 * (y_1 + y_3 + ... + y_{n-1})\n        s += 4 * np.sum(y_pts[1:-1:2])\n        \n        # Sum of even-indexed terms: 2 * (y_2 + y_4 + ... + y_{n-2})\n        s += 2 * np.sum(y_pts[2:-1:2])\n        \n        return (h / 3.0) * s\n\n    def theoretical_error_bound(n_val):\n        \"\"\"\n        Calculates the theoretical error bound B_n for the composite Simpson's rule.\n        The formula is B_n = (b-a)^5 / (180 * n^4) * M4 if using n.\n        Or (b-a)h^4/180 * M4.\n        For [0,1] and M4=24, this simplifies to 2 / (15 * n^4).\n        \"\"\"\n        return 2.0 / (15.0 * n_val**4)\n\n    results = []\n    for n in test_cases_n:\n        # 1. Compute composite Simpson approximation S_n\n        Sn = composite_simpson(f, a, b, n)\n        \n        # 2. Compute absolute error\n        abs_error = np.abs(Sn - I_exact)\n        \n        # 3. Compute theoretical error bound B_n\n        Bn = theoretical_error_bound(n)\n        \n        # 4. Verify if the absolute error is within the bound\n        ok = abs_error = Bn\n        \n        # 5. Store the results for this test case\n        results.append([n, Sn, abs_error, Bn, ok])\n\n    # Final print statement in the exact required format.\n    # The default str() for a list includes spaces, which is acceptable unless\n    # specified otherwise. The problem's example [[.], [.]] is ambiguous on this.\n    # Following the prompt's example code structure leads to this format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3214984"}, {"introduction": "Numerical methods often rely on smoothness assumptions that are not always met in practice. This exercise explores the consequences of violating these assumptions by applying standard quadrature rules to a function with a discontinuous derivative. You will observe the degradation of the convergence rate and then implement a domain-splitting strategy, a crucial technique for restoring accuracy when dealing with non-smooth integrands. [@problem_id:3214983]", "problem": "Consider the function $f(x)=\\lvert x-0.5 \\rvert$ on the interval $[0,1]$. The derivative of $f(x)$ has a discontinuity at $x=0.5$, which challenges quadrature rules whose error analyses assume sufficient smoothness. Starting from the foundational definition that numerical quadrature approximates a definite integral by integrating a low-degree polynomial interpolant of the integrand over subintervals, design and implement composite Newton–Cotes quadrature rules and analyze their behavior on this non-smooth function.\n\nYou must implement the following three methods:\n\n1. A composite trapezoidal rule based strictly on integrating the degree-$1$ interpolant (piecewise linear) over $N$ uniform subintervals on $[0,1]$.\n\n2. A composite Simpson rule based on integrating the degree-$2$ interpolant (piecewise quadratic) on a uniform partition of $[0,1]$ into $N$ subintervals, with the requirement that $N$ is even so that the rule is applied in panels of two subintervals.\n\n3. A split-composite Simpson rule that first splits $[0,1]$ at $c=0.5$ into $[0,0.5]$ and $[0.5,1]$, and then applies the composite Simpson rule separately on each subinterval. To ensure validity of Simpson panels, you must assign an even number of subintervals to each half, with the total constrained (when possible) to sum to the original $N$. Specifically:\n   - If $N$ is odd, the split-composite Simpson result is not applicable.\n   - If $N$ is even and divisible by $4$, use $N_{\\text{left}}=N/2$ and $N_{\\text{right}}=N/2$.\n   - If $N$ is even and not divisible by $4$, choose $N_{\\text{left}}=N/2-1$ and $N_{\\text{right}}=N/2+1$.\n   - If either $N_{\\text{left}}$ or $N_{\\text{right}}$ would be nonpositive, the split-composite Simpson result is not applicable.\n\nFor error assessment, derive the exact value of the integral $\\int_{0}^{1} \\lvert x-0.5 \\rvert \\, dx$ using core calculus definitions of the definite integral and properties of absolute value, and use this exact value to compute absolute errors. For any method and any $N$, define the absolute error as\n$$\nE_N = \\left\\lvert Q_N - I \\right\\rvert,\n$$\nwhere $Q_N$ is the numerical quadrature with $N$ subintervals and $I$ is the exact integral.\n\nFor empirical convergence analysis, for each method and for each pair $(N,2N)$, define the empirical order\n$$\np = \\frac{\\log\\left(E_N / E_{2N}\\right)}{\\log(2)}.\n$$\nIf a method is not applicable for a given $N$, or if either $E_N$ or $E_{2N}$ is numerically indistinguishable from $0$ (using a threshold of $10^{-15}$), report the empirical order as the sentinel value $-1.0$.\n\nYour program must compute, for each test case below, a list of nine floating-point numbers in the order:\n- $E_N$ for the composite trapezoidal rule,\n- $E_{2N}$ for the composite trapezoidal rule,\n- $p$ for the composite trapezoidal rule,\n- $E_N$ for the composite Simpson rule on the full interval,\n- $E_{2N}$ for the composite Simpson rule on the full interval,\n- $p$ for the composite Simpson rule on the full interval,\n- $E_N$ for the split-composite Simpson rule,\n- $E_{2N}$ for the split-composite Simpson rule,\n- $p$ for the split-composite Simpson rule.\n\nIf a method is not applicable for a given $N$, use $-1.0$ for the corresponding error or order. Angles do not appear in this problem; therefore, no angle unit specification is needed. There are no physical units involved.\n\nTest Suite:\nCompute the above outputs for the following $(N,2N)$ pairs:\n- $(2,4)$,\n- $(4,8)$,\n- $(6,12)$,\n- $(5,10)$,\n- $(8,16)$.\n\nThese cases cover coarse resolution, instances where $x=0.5$ coincides with Simpson panel boundaries, instances where $x=0.5$ lies inside a Simpson panel, and an odd-$N$ case for which Simpson-based methods at $N$ are not applicable.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list of per-test-case lists, with no spaces, enclosed in square brackets. For example, the final output should look like\n$[ [\\text{nine numbers for case 1}],[\\text{nine numbers for case 2}],\\ldots ]$,\nusing the exact numeric values computed by your program in place of the placeholders.", "solution": "The problem is valid. It presents a well-posed task in numerical analysis, grounded in the established principles of numerical quadrature. The function, interval, methods, and evaluation criteria are all specified with sufficient precision and are scientifically sound. The problem is a classic demonstration of how the smoothness of an integrand affects the convergence rates of numerical integration schemes.\n\n### 1. Exact Integral Calculation\n\nThe exact value of the integral $I = \\int_{0}^{1} \\lvert x-0.5 \\rvert \\, dx$ is required as a reference for error calculations. The absolute value function is defined piecewise. We split the integral at the point where the argument of the absolute value changes sign, which is $x=0.5$.\n\n$$\nI = \\int_{0}^{1} \\lvert x-0.5 \\rvert \\, dx = \\int_{0}^{0.5} -(x-0.5) \\, dx + \\int_{0.5}^{1} (x-0.5) \\, dx\n$$\n\n$$\nI = \\int_{0}^{0.5} (0.5-x) \\, dx + \\int_{0.5}^{1} (x-0.5) \\, dx\n$$\n\nEvaluating the two definite integrals:\n$$\n\\int_{0}^{0.5} (0.5-x) \\, dx = \\left[ 0.5x - \\frac{x^2}{2} \\right]_{0}^{0.5} = \\left( 0.5(0.5) - \\frac{(0.5)^2}{2} \\right) - (0) = 0.25 - \\frac{0.25}{2} = 0.125\n$$\n\n$$\n\\int_{0.5}^{1} (x-0.5) \\, dx = \\left[ \\frac{x^2}{2} - 0.5x \\right]_{0.5}^{1} = \\left( \\frac{1^2}{2} - 0.5(1) \\right) - \\left( \\frac{(0.5)^2}{2} - 0.5(0.5) \\right) = (0.5 - 0.5) - (0.125 - 0.25) = 0 - (-0.125) = 0.125\n$$\n\nThe exact value of the integral is the sum of these two parts:\n$$\nI = 0.125 + 0.125 = 0.25\n$$\nGeometrically, this represents the area of two identical right triangles, each with a base of $0.5$ and a height of $0.5$. The area is $2 \\times \\frac{1}{2} \\times 0.5 \\times 0.5 = 0.25$.\n\n### 2. Numerical Quadrature Methods\n\nLet the interval be $[a, b]$, partitioned into $N$ uniform subintervals of width $h = (b-a)/N$. The nodes are $x_i = a + i h$ for $i=0, 1, \\ldots, N$. The integrand is $f(x) = \\lvert x-0.5 \\rvert$.\n\n#### 2.1. Composite Trapezoidal Rule\nThis rule approximates the integral by summing the areas of trapezoids formed by linear interpolants on each subinterval $[x_i, x_{i+1}]$. The formula is:\n$$\nQ_N^{\\text{trap}} = h \\left( \\frac{f(x_0) + f(x_N)}{2} + \\sum_{i=1}^{N-1} f(x_i) \\right)\n$$\nThe standard error for the trapezoidal rule is of order $O(h^2)$, assuming the integrand is twice continuously differentiable ($f \\in C^2$). Our function $f(x)$ is only in $C^0$, with a jump discontinuity in its first derivative. However, the trapezoidal rule is exact for linear functions. When $N$ is an even integer, one of the grid points $x_{N/2}$ will coincide with the discontinuity at $x=0.5$. Since $f(x)$ is linear on $[0, 0.5]$ and $[0.5, 1]$, and the nodes are symmetric about $x=0.5$, the trapezoidal rule will sum the areas of the piecewise linear segments exactly. Therefore, for any even $N$, the numerical result will be exact, and the error $E_N$ will be $0$. For odd $N$, $x=0.5$ lies within a subinterval, and a non-zero error is expected.\n\n#### 2.2. Composite Simpson's Rule\nThis rule integrates a piecewise quadratic interpolant over pairs of subintervals (panels). It requires an even number of subintervals, $N$. The formula is:\n$$\nQ_N^{\\text{simp}} = \\frac{h}{3} \\left( f(x_0) + 4\\sum_{i=1, i \\text{ odd}}^{N-1} f(x_i) + 2\\sum_{i=2, i \\text{ even}}^{N-2} f(x_i) + f(x_N) \\right)\n$$\nThe standard error is $O(h^4)$, assuming $f \\in C^4$. Since our function is not smooth, this rate is not achieved. Simpson's rule is exact for polynomials up to degree $3$. The critical factor is whether the discontinuity at $x=0.5$ falls at a panel boundary or within a panel. For $N$ subintervals, there are $N/2$ panels $[x_{2k}, x_{2k+2}]$. The discontinuity lies at a panel boundary if $x=0.5$ is a node $x_{2k}$ for some integer $k$. This occurs when $N$ is a multiple of $4$. In such cases, the function is linear within each panel (e.g., on $[0, 0.5]$ and $[0.5, 1]$), and since Simpson's rule is exact for linear functions, the integration on each half is exact, yielding a total error of $0$. If $N$ is even but not a multiple of $4$ (e.g., $N=2, 6, 10, \\dots$), the point $x=0.5$ falls within a panel, and the quadratic interpolant fails to capture the 'kink', leading to a significant error. The convergence rate in this case degrades to $O(h^2)$.\n\n#### 2.3. Split-Composite Simpson's Rule\nThis adaptive strategy explicitly handles the discontinuity. The domain $[0, 1]$ is split into $[0, 0.5]$ and $[0.5, 1]$. The composite Simpson's rule is then applied to each sub-domain separately.\n$$\nQ_N^{\\text{split}} = Q_{N_{\\text{left}}}^{\\text{simp}}(f, [0, 0.5]) + Q_{N_{\\text{right}}}^{\\text{simp}}(f, [0.5, 1])\n$$\nThe total number of intervals $N$ is partitioned into $N_{\\text{left}}$ and $N_{\\text{right}}$ according to the problem's rules, ensuring both are even and positive. Within each sub-domain, $[0, 0.5]$ and $[0.5, 1]$, the function $f(x)$ is a simple linear function. Since Simpson's rule provides exact results for functions up to cubic polynomials, it will be exact for these linear segments. Consequently, whenever this method is applicable, $Q_N^{\\text{split}}$ will equal the exact integral $I$, and the error $E_N$ will be $0$. The method is not applicable for odd $N$ or for $N=2$ (as per the specified partitioning rules, $N_{\\text{left}}$ becomes nonpositive).\n\n### 3. Error and Convergence Analysis\n\nThe absolute error is $E_N = \\lvert Q_N - I \\rvert$. The empirical order of convergence, $p$, is calculated using the errors from two resolutions, $N$ and $2N$:\n$$\np = \\frac{\\log(E_N / E_{2N})}{\\log(2)}\n$$\nThis formula estimates the exponent in the error relation $E_N \\approx C h^p \\propto C (1/N)^p$. If $E_N$ or $E_{2N}$ is numerically zero (below a threshold of $10^{-15}$) or if the method is not applicable for a given $N$, the empirical order $p$ is assigned the sentinel value of $-1.0$.\n\n### 4. Algorithm Implementation\n\nThe solution is implemented in Python.\n1.  Define the function $f(x)$ and the exact integral value $I=0.25$.\n2.  Implement three separate functions: `composite_trapezoidal`, `composite_simpson`, and `split_composite_simpson`. Each function takes the integrand, interval limits, and number of subintervals $N$ as input. They return the numerical integral or a sentinel value (e.g., $-1.0$) if the method's preconditions are not met (e.g., odd $N$ for Simpson's).\n3.  The `split_composite_simpson` function encapsulates the specific logic for partitioning $N$ into $N_{\\text{left}}$ and $N_{\\text{right}}$ and calls the `composite_simpson` function on the two sub-domains.\n4.  A helper function calculates the empirical order $p$, handling the specified conditions for returning the sentinel value $-1.0$.\n5.  The main part of the program iterates through the list of test cases $(N, 2N)$. For each case, it computes the nine required values: $(E_N, E_{2N}, p)$ for each of the three methods.\n6.  Results are stored and formatted into the final string as a list of lists. Errors below the $10^{-15}$ threshold are treated as $0.0$ for reporting but trigger the $p=-1.0$ condition.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical integration problem for f(x) = |x - 0.5| on [0, 1].\n    \"\"\"\n    \n    # Define the function, its exact integral, and the zero threshold.\n    f = lambda x: np.abs(x - 0.5)\n    I_EXACT = 0.25\n    ZERO_THRESHOLD = 1e-15\n\n    def composite_trapezoidal(func, a, b, N):\n        \"\"\"Computes the integral using the composite trapezoidal rule.\"\"\"\n        if N = 0:\n            return np.nan  # Invalid input\n        h = (b - a) / N\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        integral = h * (np.sum(y) - 0.5 * (y[0] + y[-1]))\n        return integral\n\n    def composite_simpson(func, a, b, N):\n        \"\"\"Computes the integral using the composite Simpson's rule.\"\"\"\n        if N = 0 or N % 2 != 0:\n            return -1.0  # Sentinel for non-applicability\n        h = (b - a) / N\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        # Sum of terms with odd indices (y_1, y_3, ...)\n        s1 = np.sum(y[1:-1:2])\n        # Sum of terms with even indices (y_2, y_4, ...)\n        s2 = np.sum(y[2:-2:2])\n        integral = (h / 3.0) * (y[0] + 4.0 * s1 + 2.0 * s2 + y[-1])\n        return integral\n\n    def split_composite_simpson(func, a, b, c, N):\n        \"\"\"Computes the integral using the split-composite Simpson's rule.\"\"\"\n        if N % 2 != 0:\n            return -1.0\n        \n        if N % 4 == 0:\n            N_left = N // 2\n            N_right = N // 2\n        else: # N is even but not divisible by 4\n            N_left = N // 2 - 1\n            N_right = N // 2 + 1\n\n        if N_left = 0 or N_right = 0:\n            return -1.0\n            \n        I_left = composite_simpson(func, a, c, N_left)\n        I_right = composite_simpson(func, c, b, N_right)\n        \n        # This check is redundant given N_left/right logic but kept for robustness\n        if I_left == -1.0 or I_right == -1.0:\n            return -1.0\n            \n        return I_left + I_right\n\n    def calculate_p(E_N, E_2N):\n        \"\"\"Calculates the empirical order of convergence.\"\"\"\n        if E_N == -1.0 or E_2N == -1.0:\n            return -1.0\n        if E_N  ZERO_THRESHOLD or E_2N  ZERO_THRESHOLD:\n            return -1.0\n        return np.log(E_N / E_2N) / np.log(2.0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, 4),\n        (4, 8),\n        (6, 12),\n        (5, 10),\n        (8, 16)\n    ]\n\n    all_results = []\n    for N, N2 in test_cases:\n        case_results = []\n\n        # 1. Composite Trapezoidal Rule\n        Q_trap_N = composite_trapezoidal(f, 0.0, 1.0, N)\n        E_trap_N = np.abs(Q_trap_N - I_EXACT)\n        \n        Q_trap_N2 = composite_trapezoidal(f, 0.0, 1.0, N2)\n        E_trap_N2 = np.abs(Q_trap_N2 - I_EXACT)\n        \n        p_trap = calculate_p(E_trap_N, E_trap_N2)\n        case_results.extend([E_trap_N, E_trap_N2, p_trap])\n\n        # 2. Composite Simpson Rule\n        Q_simp_N = composite_simpson(f, 0.0, 1.0, N)\n        E_simp_N = -1.0 if Q_simp_N == -1.0 else np.abs(Q_simp_N - I_EXACT)\n        \n        Q_simp_N2 = composite_simpson(f, 0.0, 1.0, N2)\n        E_simp_N2 = -1.0 if Q_simp_N2 == -1.0 else np.abs(Q_simp_N2 - I_EXACT)\n        \n        p_simp = calculate_p(E_simp_N, E_simp_N2)\n        case_results.extend([E_simp_N, E_simp_N2, p_simp])\n\n        # 3. Split-Composite Simpson Rule\n        Q_split_N = split_composite_simpson(f, 0.0, 1.0, 0.5, N)\n        E_split_N = -1.0 if Q_split_N == -1.0 else np.abs(Q_split_N - I_EXACT)\n\n        Q_split_N2 = split_composite_simpson(f, 0.0, 1.0, 0.5, N2)\n        E_split_N2 = -1.0 if Q_split_N2 == -1.0 else np.abs(Q_split_N2 - I_EXACT)\n        \n        p_split = calculate_p(E_split_N, E_split_N2)\n        case_results.extend([E_split_N, E_split_N2, p_split])\n        \n        # Clean up near-zero errors for reporting\n        cleaned_results = [val if abs(val)  ZERO_THRESHOLD else 0.0 for val in case_results]\n        # Restore sentinel values\n        for i, val in enumerate(case_results):\n            if val == -1.0:\n                cleaned_results[i] = -1.0\n\n        all_results.append(cleaned_results)\n\n    # Final print statement in the exact required format.\n    formatted_output = '[' + ','.join([f'[{\",\".join(map(str, case))}]' for case in all_results]) + ']'\n    print(formatted_output)\n\nsolve()\n```", "id": "3214983"}, {"introduction": "We now advance to one of the more challenging scenarios in numerical integration: evaluating improper integrals where the integrand is singular at an endpoint. Direct application of standard methods fails here, but this practice introduces a powerful solution through a change of variables. By transforming the singular integral into a regular one, you will learn how to 'tame' the singularity and enable accurate numerical approximation, a key skill for advanced scientific computing. [@problem_id:3214941]", "problem": "Consider the improper integral of a power-law singular integrand on a finite interval, defined by the Riemann integral $$I=\\int_{0}^{1} x^{-0.3}\\,dx.$$ The integrand blows up at the left endpoint, which complicates direct use of composite numerical integration formulas that require evaluation at the endpoints. A change of variables can regularize the endpoint behavior. Let $$x=t^{k},$$ where $k>0$, and apply the chain rule to express the integral over the new variable $t\\in[0,1]$. Determine the transformed integrand in terms of $t$ and $k$, and identify the condition on $k$ under which the transformed integrand is continuous at $t=0$ and finite across the closed interval $[0,1]$.\n\nStarting from the definition of the Riemann integral and the idea of Newton–Cotes formulas constructed by polynomial interpolation, design and implement composite Simpson’s rule to approximate the transformed integral on the $t$-domain. Use a uniform partition of the interval with an even number of subintervals $N$, and step size $h=(b-a)/N$. Ensure the algorithm evaluates the transformed integrand at both endpoints and interior nodes. If the regularity condition for $k$ is not met (so that the transformed integrand diverges at $t=0$), perform truncation by replacing the lower limit $0$ with $a=10^{-8}$ and apply composite Simpson’s rule on $[a,1]$.\n\nUse the Fundamental Theorem of Calculus to obtain the exact analytic value of $I$, and report the absolute error of each numerical approximation against this exact value as the final scalar output for each test case. Angles are not involved, and there are no physical units; report numerical results as decimal floating-point numbers.\n\nYour implementation must produce results for the following test suite, which covers a boundary case (exact regularization threshold), typical regularized cases, and a non-regularized case requiring truncation:\n\n- Test Case 1: $k=\\frac{10}{7}, N=2$.\n- Test Case 2: $k=1.5, N=20$.\n- Test Case 3: $k=2.0, N=20$.\n- Test Case 4: $k=1.2, N=200$. (This case does not meet the regularity condition, so truncation with $a=10^{-8}$ must be used.)\n- Test Case 5: $k=3.0, N=10$.\n\nYour program must compute and print a single line containing a list with the absolute errors for all five test cases, formatted as a comma-separated list enclosed in square brackets, with each number rounded to twelve significant digits. For example, a valid output format is $[e_{1},e_{2},e_{3},e_{4},e_{5}]$, where each $e_{i}$ is a decimal representation of the absolute error for the $i$-th test case.", "solution": "The problem requires the analysis and numerical approximation of the improper integral\n$$I = \\int_{0}^{1} x^{-0.3}\\,dx.$$\nThe analysis involves transforming the integral to a regular form, determining the conditions for this regularization, and implementing a numerical integration scheme (Composite Simpson's Rule) to approximate the integral. The numerical results are to be compared against the exact analytic value.\n\n### Step 1: Analytic Evaluation of the Integral\n\nThe integral is improper because the integrand $f(x) = x^{-0.3}$ has a vertical asymptote at the lower limit of integration, $x=0$. However, since the exponent $-0.3$ is greater than $-1$, the integral is convergent. We can find its exact value using the Fundamental Theorem of Calculus.\n$$I = \\int_{0}^{1} x^{-0.3}\\,dx = \\lim_{a \\to 0^+} \\int_{a}^{1} x^{-0.3}\\,dx$$\nThe antiderivative of $x^{-0.3}$ is $\\frac{x^{-0.3+1}}{-0.3+1} = \\frac{x^{0.7}}{0.7}$.\nEvaluating the definite integral:\n$$I = \\lim_{a \\to 0^+} \\left[ \\frac{x^{0.7}}{0.7} \\right]_{a}^{1} = \\lim_{a \\to 0^+} \\left( \\frac{1^{0.7}}{0.7} - \\frac{a^{0.7}}{0.7} \\right)$$\nSince $0.7 > 0$, $\\lim_{a \\to 0^+} a^{0.7} = 0$. Therefore,\n$$I = \\frac{1}{0.7} - 0 = \\frac{10}{7}.$$\nThe exact analytic value of the integral is $I_{\\text{exact}} = \\frac{10}{7}$.\n\n### Step 2: Change of Variables and Regularization\n\nTo handle the singularity at $x=0$ numerically, we apply the change of variables $x = t^k$ for some $k > 0$.\nThe differential is $dx = k t^{k-1} dt$.\nThe limits of integration for $t$ are found by transforming the limits for $x$:\n- When $x=0$, $t^k=0 \\implies t=0$.\n- When $x=1$, $t^k=1 \\implies t=1$.\nThe integration interval for $t$ remains $[0, 1]$.\n\nSubstituting $x$ and $dx$ into the integral, we obtain the transformed integral in terms of $t$:\n$$I = \\int_{0}^{1} (t^k)^{-0.3} (k t^{k-1}) dt$$\nThe transformed integrand, let's call it $g(t, k)$, is:\n$$g(t, k) = t^{-0.3k} \\cdot k t^{k-1} = k t^{k-1-0.3k} = k t^{0.7k-1}$$\nThe integral is now expressed as:\n$$I = \\int_{0}^{1} k t^{0.7k-1} dt$$\n\n### Step 3: Regularity Condition\n\nThe purpose of the transformation is to obtain an integrand $g(t, k)$ that is continuous and finite over the closed interval $[0, 1]$. The potential issue is at $t=0$. The behavior of $g(t,k)$ as $t \\to 0^+$ depends on the sign of the exponent $p = 0.7k-1$.\n1.  If $p  0$: The term $t^p$ approaches infinity as $t \\to 0^+$. The integrand is singular at $t=0$.\n2.  If $p = 0$: $g(t, k) = k t^0 = k$, which is a constant and thus finite and continuous for all $t$.\n3.  If $p > 0$: The term $t^p$ approaches $0$ as $t \\to 0^+$. The integrand is continuous and its value is $0$ at $t=0$.\n\nFor the transformed integrand to be continuous and finite on the closed interval $[0, 1]$, its exponent must be non-negative. This leads to the regularity condition:\n$$0.7k - 1 \\geq 0$$\n$$0.7k \\geq 1$$\n$$k \\geq \\frac{1}{0.7} \\implies k \\geq \\frac{10}{7}$$\n\nIf this condition is not met (i.e., $k  10/7$), the transformed integrand $g(t, k)$ is still singular at $t=0$, and the problem specifies that the integration domain should be truncated to $[10^{-8}, 1]$.\n\n### Step 4: Numerical Approximation using Composite Simpson's Rule\n\nComposite Simpson's rule is used to approximate the integral $\\int_a^b f(t) dt$. The interval $[a, b]$ is partitioned into an even number of subintervals, $N$, each of width $h = (b-a)/N$. The nodes are $t_i = a + ih$ for $i=0, 1, \\dots, N$. The formula is:\n$$S_N = \\frac{h}{3} \\left[ f(t_0) + 4\\sum_{i=1}^{N/2} f(t_{2i-1}) + 2\\sum_{i=1}^{N/2-1} f(t_{2i}) + f(t_N) \\right]$$\n\nThe algorithm for each test case $(k, N)$ is as follows:\n1.  Set the exact value $I_{\\text{exact}} = 10/7$.\n2.  Define the transformed integrand $g(t, k) = k t^{0.7k-1}$.\n3.  Check the regularity condition.\n    - If $k \\geq 10/7$: The integral is regular. The integration interval is $[a, b] = [0, 1]$. Compute the numerical approximation $I_{\\text{approx}} = S_N$ for $g(t, k)$ over this interval.\n    - If $k  10/7$: The integrand is singular. The integration interval is truncated to $[a, b] = [10^{-8}, 1]$. Compute $I_{\\text{approx}} = S_N$ for $g(t, k)$ over this truncated interval.\n4.  Calculate the absolute error: $E = |I_{\\text{approx}} - I_{\\text{exact}}|$.\n\nThis procedure is applied to each of the five test cases provided. For the case $k=10/7$, the integrand is the constant function $g(t) = 10/7$. Simpson's rule is exact for polynomials of degree up to $3$, so it will be exact for a constant function, yielding an absolute error of $0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical integration problem for a set of test cases.\n    The solution involves a change of variables to regularize a singular integral,\n    followed by approximation using composite Simpson's rule. The absolute error\n    of the approximation is calculated against the exact analytic value.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10.0/7.0, 2),    # Case 1: k at regularization threshold\n        (1.5, 20),        # Case 2: Regularized case\n        (2.0, 20),        # Case 3: Regularized case\n        (1.2, 200),       # Case 4: Non-regularized, requires truncation\n        (3.0, 10),        # Case 5: Regularized case\n    ]\n\n    # The exact value of the integral I = integral(x^-0.3, dx, 0, 1) is 10/7.\n    i_exact = 10.0 / 7.0\n\n    # The critical value of k for regularization.\n    k_critical = 10.0 / 7.0\n\n    results = []\n\n    def composite_simpson(f, a, b, N):\n        \"\"\"\n        Calculates the definite integral of a function f from a to b\n        using composite Simpson's rule with N subintervals.\n        N must be an even integer.\n        \"\"\"\n        if N % 2 != 0:\n            raise ValueError(\"Number of subintervals N must be even.\")\n        \n        h = (b - a) / N\n        t_nodes = np.linspace(a, b, N + 1)\n        y_nodes = f(t_nodes)\n\n        # Simpson's rule formula:\n        # h/3 * [y_0 + 4*y_1 + 2*y_2 + ... + 2*y_{N-2} + 4*y_{N-1} + y_N]\n        integral = (h / 3.0) * (\n            y_nodes[0] + \n            y_nodes[-1] + \n            4.0 * np.sum(y_nodes[1:-1:2]) + \n            2.0 * np.sum(y_nodes[2:-2:2])\n        )\n        return integral\n\n    for k, N in test_cases:\n        # The exponent in the transformed integrand g(t) = k*t^p\n        p = 0.7 * k - 1.0\n\n        # Create the transformed integrand function.\n        # Numpy handles powers of 0 correctly:\n        # 0**p = 0 for p  0\n        # 0**0 = 1\n        # t is never 0 for p  0 due to truncation.\n        g = lambda t: k * t**p\n\n        # Determine integration interval based on regularity condition.\n        if k = k_critical:\n            # Regular case: integrate over [0, 1]\n            a, b = 0.0, 1.0\n        else:\n            # Singular case: integrate over truncated interval [1e-8, 1]\n            a, b = 1e-8, 1.0\n        \n        # Approximate the integral using composite Simpson's rule\n        i_approx = composite_simpson(g, a, b, N)\n        \n        # Calculate the absolute error against the true value of the original integral\n        error = np.abs(i_approx - i_exact)\n        results.append(error)\n\n    # Format the results to 12 significant digits and join them into a string.\n    # The 'g' format specifier handles scientific and fixed-point notation appropriately.\n    formatted_results = [f\"{res:.12g}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3214941"}]}