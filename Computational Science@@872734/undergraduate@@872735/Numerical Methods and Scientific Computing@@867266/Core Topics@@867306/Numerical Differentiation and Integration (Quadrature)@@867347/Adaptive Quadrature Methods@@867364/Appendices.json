{"hands_on_practices": [{"introduction": "The best way to truly grasp a recursive algorithm is to trace its execution by hand. This exercise provides a guided, step-by-step walkthrough of an adaptive quadrature method. By using the simpler trapezoidal rule and a basic polynomial integrand, $f(x)=x^2$, the focus remains squarely on the core logic: recursively subdividing intervals and checking the error against a given tolerance.", "problem": "An adaptive quadrature algorithm refines its calculation mesh to meet a desired error tolerance. Consider the following recursive algorithm designed to approximate the definite integral $I = \\int_a^b f(x) \\,dx$.\n\n**Adaptive Integration Algorithm:**\nThe function `AdaptiveIntegrate`($f, a, b, \\epsilon$) takes a function $f$, an interval $[a, b]$, and a tolerance $\\epsilon$ as input.\n\n1.  Calculate $S_1$, the approximation from the trapezoidal rule using a single interval of width $h_1 = b-a$. The formula is $S_1 = \\frac{h_1}{2}(f(a) + f(b))$.\n2.  Let $c = (a+b)/2$ be the midpoint of the interval. Calculate $S_2$, the approximation from the composite trapezoidal rule using two subintervals $[a, c]$ and $[c, b]$, each of width $h_2 = (b-a)/2$. The formula is $S_2 = \\frac{h_2}{2}(f(a) + f(c)) + \\frac{h_2}{2}(f(c) + f(b))$.\n3.  An estimate for the error in the more accurate approximation $S_2$ is based on the difference between the two approximations. The stopping criterion is $|S_2 - S_1| < 3\\epsilon$.\n4.  If the criterion is met, the procedure for this interval terminates and returns the value of $S_2$.\n5.  If the criterion is not met, the algorithm refines the interval. It recursively calls itself on the two subintervals, halving the tolerance for each. The result for the interval $[a, b]$ is the sum of the results from these two calls:\n    `AdaptiveIntegrate`($f, a, c, \\epsilon/2$) + `AdaptiveIntegrate`($f, c, b, \\epsilon/2$)\n\nYour task is to manually trace this algorithm to find the numerical approximation of the integral\n$$ I = \\int_0^4 x^2 \\,dx $$\nwith an initial tolerance of $\\epsilon = 2$.\n\nCalculate the final numerical approximation for the integral returned by the algorithm. Provide your answer as an exact integer or fraction.", "solution": "We apply the given adaptive trapezoidal algorithm to $f(x)=x^2$ on $[0,4]$ with initial tolerance $\\epsilon=2$. The trapezoidal approximation on an interval $[a,b]$ with one panel is $S_1 = \\frac{h_1}{2}(f(a)+f(b))$ where $h_1 = b-a$. The approximation with two panels is $S_2 = \\frac{h_2}{2}(f(a)+f(c)) + \\frac{h_2}{2}(f(c)+f(b))$, where $c=\\frac{a+b}{2}$ and $h_2 = \\frac{b-a}{2}$. The stopping criterion for an interval is $|S_2 - S_1|  3\\epsilon$. If not met, we recurse on $[a,c]$ and $[c,b]$ with tolerance $\\epsilon/2$ each and sum the returned values.\n\n**Top-level interval $[0,4]$ with $\\epsilon=2$:**\n- Compute $h_1=4$, so $S_1 = \\frac{4}{2}(f(0)+f(4)) = 2(0+16) = 32$.\n- Midpoint $c=2$, $h_2=2$.\n- $S_2 = \\frac{2}{2}(f(0)+f(2)) + \\frac{2}{2}(f(2)+f(4)) = 1(0+4) + 1(4+16) = 4+20 = 24$.\n- Error check: $|S_2 - S_1| = |24-32|=8$. The criterion is $3\\epsilon=3 \\cdot 2=6$. Since $8 \\not 6$, we recurse. The result will be `AdaptiveIntegrate`($f, 0, 2, 1$) + `AdaptiveIntegrate`($f, 2, 4, 1$).\n\n**Subinterval $[0,2]$ with $\\epsilon=1$:**\n- Compute $h_1=2$, so $S_1 = \\frac{2}{2}(f(0)+f(2)) = 1(0+4) = 4$.\n- Midpoint $c=1$, $h_2=1$.\n- $S_2 = \\frac{1}{2}(f(0)+f(1)) + \\frac{1}{2}(f(1)+f(2)) = \\frac{1}{2}(0+1) + \\frac{1}{2}(1+4) = \\frac{1}{2} + \\frac{5}{2} = 3$.\n- Error check: $|S_2 - S_1| = |3-4|=1$. The criterion is $3\\epsilon=3 \\cdot 1=3$. Since $13$, we accept $S_2=3$ for the interval $[0,2]$.\n\n**Subinterval $[2,4]$ with $\\epsilon=1$:**\n- Compute $h_1=2$, so $S_1 = \\frac{2}{2}(f(2)+f(4)) = 1(4+16) = 20$.\n- Midpoint $c=3$, $h_2=1$.\n- $S_2 = \\frac{1}{2}(f(2)+f(3)) + \\frac{1}{2}(f(3)+f(4)) = \\frac{1}{2}(4+9) + \\frac{1}{2}(9+16) = \\frac{13}{2} + \\frac{25}{2} = 19$.\n- Error check: $|S_2 - S_1| = |19-20|=1$. The criterion is $3\\epsilon=3$. Since $13$, we accept $S_2=19$ for the interval $[2,4]$.\n\nFinally, the top-level call returns the sum of the accepted subinterval results:\n$$\n\\text{Result} = 3+19=22.\n$$\nThis is the final numerical approximation returned by the algorithm.", "answer": "$$\\boxed{22}$$", "id": "2153105"}, {"introduction": "Adaptive quadrature methods are powerful, but not infallible, as their \"intelligence\" relies on an error estimator that can sometimes be deceived. This thought experiment challenges you to identify a specific function that \"fools\" the adaptive Simpson's rule, causing it to terminate prematurely with an incorrect answer. Successfully identifying such a case fosters a crucial understanding of the method's underlying assumptions and potential failure modes.", "problem": "An adaptive quadrature algorithm is designed to numerically approximate the definite integral $I = \\int_a^b f(x)\\,dx$ for a continuous function $f(x)$ up to a desired tolerance $\\epsilon  0$. The algorithm, based on Simpson's rule, operates as follows on any given interval $[u, v]$:\n\n1.  Calculate a coarse approximation using Simpson's rule over the entire interval:\n    $$S_1 = \\frac{v-u}{6}\\left(f(u) + 4f\\left(\\frac{u+v}{2}\\right) + f(v)\\right)$$\n2.  Calculate a more refined approximation by summing the Simpson's rule results from the two half-intervals, $[u, w]$ and $[w, v]$, where $w = (u+v)/2$:\n    $$S_2 = \\frac{w-u}{6}\\left(f(u) + 4f\\left(\\frac{u+w}{2}\\right) + f(w)\\right) + \\frac{v-w}{6}\\left(f(w) + 4f\\left(\\frac{w+v}{2}\\right) + f(v)\\right)$$\n3.  Estimate the error of the refined approximation $S_2$ using the formula:\n    $$E = \\frac{1}{15}|S_2 - S_1|$$\n4.  If the estimated error $E$ is less than the tolerance allocated for the interval $[u,v]$, the algorithm terminates for this interval and returns $S_2$ as its value. Otherwise, the algorithm is applied recursively to the sub-intervals $[u, w]$ and $[w, v]$, each with half of the previous tolerance.\n\nConsider the task of evaluating the integral of a function over the interval $[-1, 1]$. Which of the following continuous functions would cause this algorithm to terminate on its very first check (i.e., without any recursion) and return an incorrect value of 0? Assume the initial tolerance $\\epsilon$ is any small positive number.\n\nA. $f(x) = 3x^2 - 1$\n\nB. $f(x) = \\sin(\\pi x)$\n\nC. $f(x) = \\cos\\left(\\frac{\\pi}{2} x\\right)$\n\nD. $f(x) = 16x^6 - 20x^4 + x^2 + 1$\n\nE. $f(x) = x^5 - x^3 + x$", "solution": "For the algorithm to terminate on its very first check for any small positive tolerance $\\epsilon > 0$, the estimated error must be exactly zero on the initial interval. For the interval $[u,v]=[-1,1]$, the midpoint is $w=0$. The two Simpson's rule approximations are:\n$$S_{1}=\\frac{2}{6}\\left(f(-1)+4f(0)+f(1)\\right) = \\frac{1}{3}\\left(f(-1)+4f(0)+f(1)\\right)$$\n$$S_{2}=\\frac{1}{6}\\left(f(-1)+4f\\left(-\\frac{1}{2}\\right)+f(0)\\right)+\\frac{1}{6}\\left(f(0)+4f\\left(\\frac{1}{2}\\right)+f(1)\\right)$$\nThis simplifies to:\n$$S_{2} = \\frac{1}{6}\\left(f(-1)+f(1)+2f(0)+4f\\left(-\\frac{1}{2}\\right)+4f\\left(\\frac{1}{2}\\right)\\right)$$\nThe error estimate is $E=\\frac{1}{15}|S_{2}-S_{1}|$. To terminate for any $\\epsilon>0$, we need $E=0$, which means $S_2 = S_1$. For the algorithm to return the incorrect value $0$, we must also have $S_2=0$ while the true integral $\\int_{-1}^{1}f(x)\\,dx \\neq 0$.\n\nLet's evaluate $S_{1}$ and $S_{2}$ for each option:\n\n**A. $f(x)=3x^2-1$:**\n$f(-1)=2$, $f(0)=-1$, $f(1)=2$, $f(\\pm\\frac{1}{2}) = 3(\\frac{1}{4})-1 = -\\frac{1}{4}$.\n$S_1 = \\frac{1}{3}(2+4(-1)+2)=0$.\n$S_2 = \\frac{1}{6}(2+2+2(-1)+4(-\\frac{1}{4})+4(-\\frac{1}{4})) = \\frac{1}{6}(4-2-1-1)=0$.\nBoth $S_1$ and $S_2$ are 0. The true integral is $\\int_{-1}^{1}(3x^2-1)\\,dx = [x^3-x]_{-1}^{1} = (1-1)-(-1+1) = 0$. The algorithm returns 0, which is correct.\n\n**B. $f(x)=\\sin(\\pi x)$:**\n$f(-1)=0$, $f(0)=0$, $f(1)=0$, $f(-1/2)=-1$, $f(1/2)=1$.\n$S_1 = \\frac{1}{3}(0+0+0)=0$.\n$S_2 = \\frac{1}{6}(0+0+0+4(-1)+4(1))=0$.\nThe true integral $\\int_{-1}^{1}\\sin(\\pi x)\\,dx=0$ (odd function over a symmetric interval). The algorithm returns 0, which is correct.\n\n**C. $f(x)=\\cos(\\frac{\\pi}{2}x)$:**\n$f(-1)=0$, $f(0)=1$, $f(1)=0$, $f(\\pm\\frac{1}{2}) = \\cos(\\pm\\frac{\\pi}{4}) = \\frac{\\sqrt{2}}{2}$.\n$S_1 = \\frac{1}{3}(0+4(1)+0) = \\frac{4}{3}$.\n$S_2 = \\frac{1}{6}(0+0+2(1)+4(\\frac{\\sqrt{2}}{2})+4(\\frac{\\sqrt{2}}{2})) = \\frac{1}{6}(2+4\\sqrt{2}) = \\frac{1+2\\sqrt{2}}{3}$.\nSince $S_1 \\neq S_2$, the algorithm would not terminate immediately (unless the tolerance is very large). It would not return 0.\n\n**D. $f(x)=16x^6 - 20x^4 + x^2 + 1$:**\nThis is an even function. $f(-1)=16-20+1+1=-2$, $f(1)=-2$, $f(0)=1$.\n$f(\\pm\\frac{1}{2}) = 16(\\frac{1}{64}) - 20(\\frac{1}{16}) + \\frac{1}{4} + 1 = \\frac{1}{4} - \\frac{5}{4} + \\frac{1}{4} + 1 = -\\frac{3}{4}+1 = \\frac{1}{4}$.\n$S_1 = \\frac{1}{3}(-2+4(1)-2)=0$.\n$S_2 = \\frac{1}{6}(-2-2+2(1)+4(\\frac{1}{4})+4(\\frac{1}{4})) = \\frac{1}{6}(-4+2+1+1)=0$.\nHere, $S_1=S_2=0$, so the estimated error $E=0$. The algorithm terminates and returns $0$.\nNow we check the true integral:\n$\\int_{-1}^{1}(16x^6-20x^4+x^2+1)\\,dx = 2\\int_{0}^{1}(16x^6-20x^4+x^2+1)\\,dx$\n$= 2[\\frac{16}{7}x^7 - \\frac{20}{5}x^5 + \\frac{1}{3}x^3 + x]_{0}^{1} = 2(\\frac{16}{7}-4+\\frac{1}{3}+1) = 2(\\frac{16}{7}-3+\\frac{1}{3})$\n$= 2(\\frac{48-63+7}{21}) = 2(\\frac{-8}{21}) = -\\frac{16}{21}$.\nThe true integral is not 0. Therefore, the algorithm returns an incorrect value. This is the correct choice.\n\n**E. $f(x)=x^5-x^3+x$:**\nThis is an odd function. $f(-x)=-f(x)$.\nThe sample points are symmetric, so $f(-1)=-f(1)$, $f(-1/2)=-f(1/2)$, and $f(0)=0$.\n$S_1 = \\frac{1}{3}(-f(1)+0+f(1))=0$.\n$S_2 = \\frac{1}{6}(-f(1)+f(1)+0+4(-f(1/2))+4(f(1/2)))=0$.\nThe true integral is $\\int_{-1}^{1}(x^5-x^3+x)\\,dx=0$. The algorithm returns 0, which is correct.\n\nOnly option D meets the requirement: immediate termination with $E=0$, returning an answer of 0, while the true integral is nonzero.", "answer": "$$\\boxed{D}$$", "id": "2153040"}, {"introduction": "From analysis, we move to creation. This practice guides you through implementing an adaptive quadrature algorithm to witness its efficiency firsthand. By applying your code to a function with distinctly different behaviors—a low-frequency wave followed by a high-frequency oscillation—you will quantitatively analyze how the algorithm intelligently concentrates computational effort, providing a tangible demonstration of its adaptive power.", "problem": "Consider the interval $[0,2\\pi]$ and the piecewise-defined function $f(x)$ given by:\n$$ f(x) = \\begin{cases} \\sin(x)  \\text{for } x  \\pi \\\\ \\sin(100x)  \\text{for } x \\ge \\pi \\end{cases} $$\nThe task is to implement an adaptive quadrature method that starts from foundational numerical analysis principles and uses local error control to decide where to subdivide the integration domain. You must construct a program that computes an approximation to the definite integral of $f(x)$ over $[0,2\\pi]$ and quantitatively analyzes how the adaptive procedure allocates nodes in the low-frequency region $[0,\\pi)$ compared to the high-frequency region $[\\pi,2\\pi]$.\n\nStart from the definition of the definite integral and the concept of composite numerical quadrature based on polynomial interpolation. Use a principled local error estimator to drive subdivision, ensuring that the algorithm refines subintervals where the estimated error is large. You must implement an adaptive algorithm based on Simpson-type local approximations that recursively bisects intervals until a specified absolute error tolerance $\\tau$ is met or a maximum recursion depth $D_{\\max}$ is reached. You should not assume any pre-derived shortcut formulas for the target method; instead, derive decisions from the core definitions of numerical integration and local error estimation.\n\nYour program must perform the following for each test input:\n- Compute the numerical approximation $I$ to $\\int_{0}^{2\\pi} f(x)\\,dx$.\n- Track the set of unique abscissas where $f(x)$ is evaluated, and report the counts $n_{\\text{low}}$ and $n_{\\text{high}}$ of unique points used in $[0,\\pi)$ and $[\\pi,2\\pi]$, respectively. Classify $x=\\pi$ as belonging to the high-frequency region.\n- Compute the absolute error $e=|I-I_{\\text{exact}}|$, where $I_{\\text{exact}}$ is the exact value of the integral derived from fundamental properties of trigonometric integrals.\n- Report whether the adaptive method allocated strictly more nodes to the high-frequency region than to the low-frequency region, that is, the boolean value of $n_{\\text{high}} > n_{\\text{low}}$.\n\nTest Suite:\nProvide results for the following parameter sets $(\\tau,D_{\\max})$:\n1. $\\tau=10^{-6}$ and $D_{\\max}=40$ (general case).\n2. $\\tau=10^{-4}$ and $D_{\\max}=20$ (moderate tolerance).\n3. $\\tau=10^{-8}$ and $D_{\\max}=12$ (edge case with tight tolerance but limited recursion depth).\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case must contribute a nested list in the form $[I,e,n_{\\text{low}},n_{\\text{high}},\\text{high\\_more}]$, where $I$ and $e$ are floats, $n_{\\text{low}}$ and $n_{\\text{high}}$ are integers, and $\\text{high\\_more}$ is a boolean. For example, the overall output must look like $[[I_1,e_1,n_{\\text{low},1},n_{\\text{high},1},\\text{high\\_more}_1],[I_2,e_2,n_{\\text{low},2},n_{\\text{high},2},\\text{high\\_more}_2],[I_3,e_3,n_{\\text{low},3},n_{\\text{high},3},\\text{high\\_more}_3]]$. No physical units are involved.", "solution": "The user-provided problem is a well-defined task in numerical analysis. It requires the implementation and analysis of an adaptive quadrature algorithm based on first principles. The problem is scientifically sound, self-contained, and objective. Therefore, it is deemed valid.\n\n### 1. Principle-Based Derivation of the Adaptive Method\n\nThe goal is to approximate the definite integral $I = \\int_a^b f(x) \\, dx$. Adaptive quadrature methods refine the integration domain by subdividing intervals where the approximation error is estimated to be large, thus concentrating computational effort where the function is most difficult to integrate.\n\nWe will base our method on Simpson's rule, which approximates the integrand with a quadratic polynomial.\n\n**Local Approximation using Simpson's Rule**\n\nFor a given interval $[a, b]$, let $c = (a+b)/2$ be the midpoint. The basic Simpson's rule provides an approximation, $S_1$, using three points:\n$$ S_1 = \\frac{b-a}{6} \\left( f(a) + 4f(c) + f(b) \\right) $$\nThe error of this approximation is known to be $E_1 = -\\frac{(b-a)^5}{2880} f^{(4)}(\\xi_1)$ for some $\\xi_1 \\in (a, b)$.\n\nTo estimate this error without knowing $f^{(4)}$, we compute a more accurate approximation, $S_2$, by applying Simpson's rule to the two half-intervals, $[a, c]$ and $[c, b]$. Let $d = (a+c)/2$ and $e = (c+b)/2$ be the new midpoints. The composite Simpson's rule on these two subintervals yields:\n$$ S_2 = \\frac{c-a}{6} \\left( f(a) + 4f(d) + f(c) \\right) + \\frac{b-c}{6} \\left( f(c) + 4f(e) + f(b) \\right) $$\nSince $c-a = b-c = (b-a)/2$, this simplifies to:\n$$ S_2 = \\frac{b-a}{12} \\left( f(a) + 4f(d) + 2f(c) + 4f(e) + f(b) \\right) $$\nThe error of this 5-point approximation, $S_2$, is the sum of the errors on the two subintervals:\n$$ E_2 = -2 \\cdot \\frac{((b-a)/2)^5}{2880} f^{(4)}(\\xi_2) = -\\frac{1}{16} \\frac{(b-a)^5}{2880} f^{(4)}(\\xi_2) $$\nAssuming $f^{(4)}(x)$ is approximately constant over $[a, b]$, we have $E_2 \\approx \\frac{1}{16} E_1$.\n\n**Local Error Estimation**\n\nLet the true value of the integral over $[a, b]$ be $I_{[a,b]}$. We have the following relationships:\n$I_{[a,b]} \\approx S_1 + E_1$\n$I_{[a,b]} \\approx S_2 + E_2 \\approx S_2 + \\frac{1}{16} E_1$\n\nEquating the two expressions for $I_{[a,b]}$:\n$S_1 + E_1 \\approx S_2 + \\frac{1}{16} E_1 \\implies \\frac{15}{16} E_1 \\approx S_2 - S_1 \\implies E_1 \\approx \\frac{16}{15} (S_2 - S_1)$\n\nThe error in our *better* approximation, $S_2$, is what we are truly interested in. This error is $E_2 \\approx \\frac{1}{16} E_1$. Substituting the expression for $E_1$:\n$$ E_2 \\approx \\frac{1}{16} \\left( \\frac{16}{15} (S_2 - S_1) \\right) = \\frac{S_2 - S_1}{15} $$\nThus, the magnitude of the local error can be estimated as $|S_2 - S_1| / 15$.\n\n**Recursive Subdivision Strategy**\n\nThe adaptive algorithm is implemented recursively. For an interval $[a, b]$ and a desired local tolerance $\\tau_{\\text{local}}$:\n1.  Compute the coarse approximation $S_1$ and the fine approximation $S_2$.\n2.  Estimate the error $E_{\\text{local}} = |S_2 - S_1|/15$.\n3.  If $E_{\\text{local}}  \\tau_{\\text{local}}$ or if a maximum recursion depth $D_{\\max}$ has been reached, the subdivision stops. The best estimate for the integral on this interval is returned. This can be the more accurate value $S_2$, or an even better estimate obtained through Richardson extrapolation: $I_{\\text{best}} = S_2 + E_{\\text{local}} = S_2 + (S_2 - S_1)/15$. We will use this improved value.\n4.  If the error is too large, the interval is bisected into $[a, c]$ and $[c, b]$. The algorithm is called recursively on each subinterval. The tolerance is distributed to the subproblems; a common strategy is to assign half of the parent's tolerance to each child, so $\\tau_{\\text{child}} = \\tau_{\\text{local}}/2$.\n\nThe initial call is on the full domain $[0, 2\\pi]$ with the user-specified tolerance $\\tau$ and maximum depth $D_{\\max}$.\n\n### 2. Analysis of the Target Problem\n\n**Function Definition**\n\nThe function to be integrated over $[0, 2\\pi]$ is:\n$$ f(x) = \\begin{cases} \\sin(x)  \\text{for } x  \\pi \\\\ \\sin(100x)  \\text{for } x \\ge \\pi \\end{cases} $$\nThis function has a low-frequency component on $[0, \\pi)$ and a high-frequency component on $[\\pi, 2\\pi]$. The adaptive algorithm is expected to perform many more subdivisions in the high-frequency region to resolve the rapid oscillations of $\\sin(100x)$.\n\n**Exact Integral Calculation**\n\nThe exact value of the integral is required to compute the error.\n$$ I_{\\text{exact}} = \\int_{0}^{2\\pi} f(x) \\, dx = \\int_{0}^{\\pi} \\sin(x) \\, dx + \\int_{\\pi}^{2\\pi} \\sin(100x) \\, dx $$\nThe first part is:\n$$ \\int_{0}^{\\pi} \\sin(x) \\, dx = [-\\cos(x)]_{0}^{\\pi} = (-\\cos(\\pi)) - (-\\cos(0)) = -(-1) - (-1) = 1+1=2 $$\nThe second part is:\n$$ \\int_{\\pi}^{2\\pi} \\sin(100x) \\, dx = \\left[-\\frac{1}{100}\\cos(100x)\\right]_{\\pi}^{2\\pi} = -\\frac{1}{100} (\\cos(200\\pi) - \\cos(100\\pi)) = -\\frac{1}{100} (1 - 1) = 0 $$\nTherefore, the exact value of the integral is $I_{\\text{exact}} = 2 + 0 = 2$.\n\n**Computational Plan**\n\nFor each test case $(\\tau, D_{\\max})$:\n1.  Initialize an empty set to store the unique abscissas (evaluation points).\n2.  Execute the recursive adaptive quadrature algorithm over $[0, 2\\pi]$. The recursive function will populate the set of abscissas.\n3.  The result of the algorithm is the numerical approximation $I$.\n4.  Calculate the absolute error $e = |I - I_{\\text{exact}}|$.\n5.  Iterate through the set of unique abscissas. Count the number of points in $[0, \\pi)$ as $n_{\\text{low}}$ and the number of points in $[\\pi, 2\\pi]$ as $n_{\\text{high}}$ (with $x=\\pi$ classified as high).\n6.  Determine the boolean value of the condition $n_{\\text{high}} > n_{\\text{low}}$.\n7.  Collect these five results: $[I, e, n_{\\text{low}}, n_{\\text{high}}, (n_{\\text{high}} > n_{\\text{low}})]$.\nThe results from all test cases will be compiled into a single list for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the final result.\n    \"\"\"\n\n    # Define the piecewise function f(x)\n    def f(x):\n        \"\"\"\n        The piecewise function to be integrated.\n        f(x) = sin(x) for x  pi\n        f(x) = sin(100x) for x >= pi\n        \"\"\"\n        if isinstance(x, (list, np.ndarray)):\n            # Support for vectorized input, though the algorithm evaluates point-wise\n            return np.where(x  np.pi, np.sin(x), np.sin(100 * x))\n        else:\n            if x  np.pi:\n                return np.sin(x)\n            else:\n                return np.sin(100 * x)\n\n    class AdaptiveQuadrature:\n        \"\"\"\n        A class to encapsulate the adaptive quadrature logic and state.\n        This avoids using global variables for tracking evaluation points.\n        \"\"\"\n        def __init__(self, func, exact_value):\n            self.func = func\n            self.exact_value = exact_value\n            self.points_set = set()\n\n        def _recursive_solver(self, a, b, tol, depth):\n            \"\"\"\n            The recursive core of the adaptive Simpson's method.\n            \"\"\"\n            # 1. Define the 5 points for the two-level Simpson's rule\n            c = (a + b) / 2.0\n            d = (a + c) / 2.0\n            e = (c + b) / 2.0\n\n            # 2. Evaluate the function at the necessary points\n            # To avoid duplicate additions to the set, check first if needed,\n            # but for simplicity, we add all 5 and let the set handle uniqueness.\n            # This is less performant but conceptually clear.\n            fa, fb, fc = self.func(a), self.func(b), self.func(c)\n            fd, fe = self.func(d), self.func(e)\n            \n            # Record all unique evaluation points\n            self.points_set.update([a, b, c, d, e])\n\n            # 3. Compute coarse (S1) and fine (S2) approximations\n            # S1: Simpson's rule on [a, b]\n            s1 = (b - a) * (fa + 4 * fc + fb) / 6.0\n            # S2: Composite Simpson's rule on [a, c] and [c, b]\n            s2 = (b - a) * (fa + 4 * fd + 2 * fc + 4 * fe + fb) / 12.0\n\n            # 4. Estimate the error of the more accurate approximation, S2\n            # The error is estimated as |S2 - S1| / 15\n            error = abs(s2 - s1) / 15.0\n\n            # 5. Check stopping conditions\n            if depth = 0 or error  tol:\n                # Return the best estimate using Richardson extrapolation\n                return s2 + (s2 - s1) / 15.0\n            else:\n                # 6. Recurse on subintervals with scaled tolerance\n                left_integral = self._recursive_solver(a, c, tol / 2.0, depth - 1)\n                right_integral = self._recursive_solver(c, b, tol / 2.0, depth - 1)\n                return left_integral + right_integral\n\n        def compute(self, a, b, tau, d_max):\n            \"\"\"\n            Public method to run the adaptive quadrature for a given problem setup.\n            \"\"\"\n            self.points_set.clear()\n            \n            # Start the recursion\n            integral_approx = self._recursive_solver(a, b, tau, d_max)\n            \n            # Calculate absolute error\n            abs_error = abs(integral_approx - self.exact_value)\n            \n            # Analyze node distribution\n            n_low = 0\n            n_high = 0\n            pi_val = np.pi\n            for p in self.points_set:\n                if p  pi_val:\n                    n_low += 1\n                else:  # p = pi_val\n                    n_high += 1\n            \n            high_more = n_high  n_low\n            \n            return [integral_approx, abs_error, n_low, n_high, high_more]\n\n    # Define the problem's domain and exact integral value\n    a_domain, b_domain = 0, 2 * np.pi\n    i_exact = 2.0\n    \n    # Instantiate the solver\n    solver = AdaptiveQuadrature(func=f, exact_value=i_exact)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (tau, D_max)\n        (1e-6, 40),   # general case\n        (1e-4, 20),   # moderate tolerance\n        (1e-8, 12),   # tight tolerance, limited depth\n    ]\n\n    # Run the solver for each case and collect results\n    results = []\n    for tau, d_max in test_cases:\n        result = solver.compute(a_domain, b_domain, tau, d_max)\n        results.append(result)\n\n    # Format the final output string as required\n    # Custom formatter to handle boolean correctly as lowercased string\n    def format_item(item):\n        if isinstance(item, bool):\n            return str(item).lower()\n        return str(item)\n\n    # Format each inner list\n    formatted_results = []\n    for res_list in results:\n        formatted_list = f\"[{','.join(format_item(item) for item in res_list)}]\"\n        formatted_results.append(formatted_list)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3203443"}]}