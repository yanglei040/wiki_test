{"hands_on_practices": [{"introduction": "A parametric curve describes more than just a geometric shape; it represents a trajectory, encoding position as a function of a parameter, often time. This fundamental exercise clarifies the critical distinction between a path *intersection*, where two paths cross, and a *collision*, where two objects arrive at the same point at the same time. Understanding this difference is essential for modeling any real-world scenario involving moving objects. [@problem_id:2140263]", "problem": "Two autonomous mobile robots, 'Pathfinder' and 'Rover', are programmed to navigate on a large, flat factory floor. Their positions are described by a Cartesian coordinate system where units are in meters.\n\nPathfinder's path, $C_1$, is described by the parametric equations for its position $(x_1, y_1)$ at its internal time $t \\ge 0$ (in seconds):\n$$x_1(t) = 2t+1$$\n$$y_1(t) = t^2 - 2$$\n\nRover's path, $C_2$, is described by the parametric equations for its position $(x_2, y_2)$ at its internal time $s \\ge 0$ (in seconds):\n$$x_2(s) = s-1$$\n$$y_2(s) = s+1$$\n\nThe robots' movements are analyzed for two distinct scenarios: path intersection (do their geometric paths cross?) and collision (are they at the same place at the same time?). A path intersection occurs if there exist time parameters $t$ and $s$ (not necessarily equal) for which the positions are the same. A collision occurs only if their positions are the same for the *same* value of the time parameter, assuming their clocks are synchronized ($t=s$).\n\nBased on your analysis of the robots' paths, which of the following statements is correct?\n\nA. The paths do not intersect.\n\nB. The paths intersect at the point $(3+2\\sqrt{6}, 5+2\\sqrt{6})$, and the robots will collide at this point if their clocks are synchronized.\n\nC. The paths intersect at the point $(3+2\\sqrt{6}, 5+2\\sqrt{6})$, but the robots will not collide even if their clocks are synchronized.\n\nD. The paths intersect at a point other than $(3+2\\sqrt{6}, 5+2\\sqrt{6})$, and the robots will collide at this other point if their clocks are synchronized.\n\nE. The paths intersect at a point other than $(3+2\\sqrt{6}, 5+2\\sqrt{6})$, but the robots will not collide at this other point even if their clocks are synchronized.", "solution": "We are given two parametrically defined paths on the plane. Pathfinder follows $C_{1}$ with $(x_{1}(t), y_{1}(t))$ where $x_{1}(t) = 2t + 1$ and $y_{1}(t) = t^{2} - 2$ for $t \\ge 0$. Rover follows $C_{2}$ with $(x_{2}(s), y_{2}(s))$ where $x_{2}(s) = s - 1$ and $y_{2}(s) = s + 1$ for $s \\ge 0$.\n\nTo determine whether the geometric paths intersect, we must find $t \\ge 0$ and $s \\ge 0$ such that\n$$\nx_{1}(t) = x_{2}(s), \\quad y_{1}(t) = y_{2}(s).\n$$\nEquating the $x$-coordinates gives\n$$\n2t + 1 = s - 1 \\quad \\Rightarrow \\quad s = 2t + 2.\n$$\nEquating the $y$-coordinates gives\n$$\nt^{2} - 2 = s + 1 \\quad \\Rightarrow \\quad s = t^{2} - 3.\n$$\nSetting these expressions for $s$ equal yields\n$$\n2t + 2 = t^{2} - 3 \\quad \\Rightarrow \\quad t^{2} - 2t - 5 = 0.\n$$\nSolving the quadratic equation,\n$$\nt = \\frac{2 \\pm \\sqrt{4 + 20}}{2} = \\frac{2 \\pm \\sqrt{24}}{2} = 1 \\pm \\sqrt{6}.\n$$\nSince $t \\ge 0$, we accept $t = 1 + \\sqrt{6}$ and reject $t = 1 - \\sqrt{6} < 0$. Then\n$$\ns = 2t + 2 = 2(1 + \\sqrt{6}) + 2 = 4 + 2\\sqrt{6} \\ge 0.\n$$\nThe intersection point is computed from either path; using $C_{1}$,\n$$\nx = 2t + 1 = 2(1 + \\sqrt{6}) + 1 = 3 + 2\\sqrt{6}, \\quad y = t^{2} - 2 = (1 + \\sqrt{6})^{2} - 2 = 5 + 2\\sqrt{6}.\n$$\nThus the paths intersect at $(3 + 2\\sqrt{6}, 5 + 2\\sqrt{6})$.\n\nTo determine if they collide with synchronized clocks, we require the same time parameter $t = s$ and the same position:\n$$\n2t + 1 = t - 1, \\quad t^{2} - 2 = t + 1.\n$$\nFrom the first equation,\n$$\n2t + 1 = t - 1 \\quad \\Rightarrow \\quad t = -2,\n$$\nwhich violates $t \\ge 0$. Therefore, no nonnegative $t$ satisfies both coordinate equalities simultaneously, and a collision does not occur under synchronized clocks.\n\nHence, the correct statement is that the paths intersect at $(3 + 2\\sqrt{6}, 5 + 2\\sqrt{6})$, but the robots will not collide even with synchronized clocks.", "answer": "$$\\boxed{C}$$", "id": "2140263"}, {"introduction": "Parametric equations are powerful tools for modeling the motion of objects in complex mechanical systems. This practice challenges you to derive the equations for a hypotrochoid—the elegant curve traced by a point on a circle rolling inside another. You will then use vector calculus to analyze a key geometric property of the resulting path: its curvature, which measures how sharply the curve bends at any given point. [@problem_id:3261316]", "problem": "A circle of radius $r$ rolls without slipping inside a fixed circle of radius $R$. A tracer point is attached at a distance $d$ from the center of the rolling circle. Let $\\theta$ (in radians) denote the polar angle of the center of the rolling circle with respect to the center of the fixed circle, measured from the positive $x$-axis. At $\\theta=0$, the center of the rolling circle lies on the positive $x$-axis and the tracer point lies on the same axis further to the right, so that the initial position of the tracer is at $(R-r+d,\\,0)$. Starting solely from the rolling-without-slipping condition (equality of arc lengths) and the definition of curvature as the magnitude of the rate of change of the unit tangent with respect to arc length, perform the following:\n\n- Derive the parametric equations $x(\\theta)$ and $y(\\theta)$ for the tracer path for the case of rolling inside (a hypotrochoid), expressed in terms of $R$, $r$, $d$, and $\\theta$.\n- Specialize to $R=7$, $r=3$, and $d=1$, and compute the curvature $\\kappa$ of the tracer path at $\\theta=0$.\n\nExpress the final answer as an exact value. No approximation or rounding is required. Angles are in radians.", "solution": "The problem is validated as scientifically grounded, well-posed, objective, and self-contained. It describes the generation of a hypotrochoid curve and asks for its parametric equations and curvature at a specific point, which are standard topics in differential geometry and kinematics. All necessary parameters and initial conditions are provided.\n\n### Part 1: Derivation of the Parametric Equations\n\nLet the fixed circle be centered at the origin $O=(0,0)$ of a Cartesian coordinate system. Its radius is $R$. The rolling circle has radius $r$ and its center is denoted by $C$. It rolls without slipping inside the fixed circle.\n\nThe center $C$ of the rolling circle is always at a distance $R-r$ from the origin $O$. Let $\\theta$ be the polar angle of the position vector $\\vec{OC}$, measured from the positive $x$-axis. The coordinates of the center $C$ are therefore given by:\n$$ \\vec{r}_C(\\theta) = ((R-r)\\cos\\theta, (R-r)\\sin\\theta) $$\n\nA tracer point $P$ is attached to the rolling circle at a distance $d$ from its center $C$. The position vector of the tracer point $P$ is given by $\\vec{r}_P = \\vec{OC} + \\vec{CP}$. We need to determine the vector $\\vec{CP}$ as a function of $\\theta$.\n\nThe \"rolling without slipping\" condition implies that the arc length traversed on the circumference of the fixed circle is equal to the arc length rolled on the circumference of the rolling circle.\nLet the initial point of contact be $K_0$ at $(R,0)$ at $\\theta=0$. As the center $C$ moves such that $\\vec{OC}$ makes an angle $\\theta$ with the $x$-axis, the new point of contact $K$ is on the line segment $OC$ extended to the fixed circle's edge. The arc length on the fixed circle between $K_0$ and $K$ is $s = R\\theta$.\n\nThis arc length must be equal to the arc length on the rolling circle. Let $\\phi$ be the angle of rotation of the rolling circle with respect to its center $C$. This rotation is measured relative to a moving reference frame. Let's analyze the orientation of the vector $\\vec{CP}$.\n\nAt $\\theta=0$, the center $C$ is at $(R-r, 0)$. The tracer point $P$ is at $(R-r+d, 0)$. Thus, at $\\theta=0$, the vector $\\vec{CP}$ is $(d, 0)$, pointing along the positive $x$-axis.\n\nAs the system evolves, the line segment $OC$ rotates by an angle $\\theta$ counter-clockwise. In the absence of rolling, the vector $\\vec{CP}$ would also rotate by $\\theta$. However, the circle also rotates about its own center $C$ due to the rolling condition. The arc length rolled is $s=R\\theta$. This corresponds to a rotation of the rolling circle by an angle $\\phi = \\frac{s}{r} = \\frac{R\\theta}{r}$. As the center $C$ moves counter-clockwise, the rolling circle itself rotates clockwise relative to the line $OC$.\n\nThe initial orientation angle of the vector $\\vec{CP}$ with the $x$-axis is $0$. The rotation of the frame $OC$ adds $\\theta$. The rolling motion subtracts $\\phi$. Therefore, the angle $\\alpha$ of the vector $\\vec{CP}$ with respect to the positive $x$-axis is:\n$$ \\alpha(\\theta) = \\theta - \\phi = \\theta - \\frac{R\\theta}{r} = \\left(1 - \\frac{R}{r}\\right)\\theta = -\\frac{R-r}{r}\\theta $$\nThe vector $\\vec{CP}$ has magnitude $d$ and angle $\\alpha(\\theta)$. Its components are:\n$$ \\vec{CP}(\\theta) = (d\\cos(\\alpha(\\theta)), d\\sin(\\alpha(\\theta))) = \\left(d\\cos\\left(-\\frac{R-r}{r}\\theta\\right), d\\sin\\left(-\\frac{R-r}{r}\\theta\\right)\\right) $$\nUsing the identities $\\cos(-u) = \\cos(u)$ and $\\sin(-u) = -\\sin(u)$, we get:\n$$ \\vec{CP}(\\theta) = \\left(d\\cos\\left(\\frac{R-r}{r}\\theta\\right), -d\\sin\\left(\\frac{R-r}{r}\\theta\\right)\\right) $$\nThe position vector of the tracer point $P$ is the sum of $\\vec{r}_C$ and $\\vec{CP}$:\n$$ \\vec{r}_P(\\theta) = (x(\\theta), y(\\theta)) = ((R-r)\\cos\\theta + d \\cos\\left(\\frac{R-r}{r}\\theta\\right), (R-r)\\sin\\theta - d\\sin\\left(\\frac{R-r}{r}\\theta\\right)) $$\nThe parametric equations are:\n$$ x(\\theta) = (R-r)\\cos\\theta + d \\cos\\left(\\frac{R-r}{r}\\theta\\right) $$\n$$ y(\\theta) = (R-r)\\sin\\theta - d\\sin\\left(\\frac{R-r}{r}\\theta\\right) $$\nAt $\\theta=0$, $x(0) = (R-r)(1) + d(1) = R-r+d$ and $y(0) = (R-r)(0) - d(0) = 0$. This matches the initial condition $(R-r+d, 0)$.\n\n### Part 2: Curvature Calculation\n\nWe are given the specific values $R=7$, $r=3$, and $d=1$.\nThe parametric equations become:\n$$ R-r = 7-3 = 4 $$\n$$ \\frac{R-r}{r} = \\frac{4}{3} $$\n$$ x(\\theta) = 4\\cos\\theta + \\cos\\left(\\frac{4}{3}\\theta\\right) $$\n$$ y(\\theta) = 4\\sin\\theta - \\sin\\left(\\frac{4}{3}\\theta\\right) $$\nThe curvature $\\kappa$ is defined as the magnitude of the rate of change of the unit tangent vector $\\vec{T}$ with respect to arc length $s$, i.e., $\\kappa = \\left|\\frac{d\\vec{T}}{ds}\\right|$.\nUsing the chain rule, $\\frac{d\\vec{T}}{ds} = \\frac{d\\vec{T}/d\\theta}{ds/d\\theta}$. The arc length element is $ds = |\\vec{v}(\\theta)|d\\theta$, where $\\vec{v}(\\theta) = \\frac{d\\vec{r}_P}{d\\theta}$ is the velocity vector. So $\\frac{ds}{d\\theta} = |\\vec{v}(\\theta)|$.\nThe curvature is $\\kappa(\\theta) = \\frac{|d\\vec{T}/d\\theta|}{|\\vec{v}(\\theta)|}$.\nThe unit tangent vector is $\\vec{T} = \\vec{v}/|\\vec{v}|$. Differentiating with respect to $\\theta$ gives $\\frac{d\\vec{T}}{d\\theta} = \\frac{\\vec{a}|\\vec{v}|^2 - \\vec{v}(\\vec{v}\\cdot\\vec{a})}{|\\vec{v}|^3}$, where $\\vec{a}(\\theta)=\\frac{d\\vec{v}}{d\\theta}$ is the acceleration vector.\n\nAt a point where the velocity $\\vec{v}$ and acceleration $\\vec{a}$ are orthogonal (i.e., $\\vec{v} \\cdot \\vec{a} = 0$), the expression simplifies. Let's compute the derivatives at $\\theta=0$.\nFirst derivatives (velocity components):\n$$ x'(\\theta) = -4\\sin\\theta - \\frac{4}{3}\\sin\\left(\\frac{4}{3}\\theta\\right) $$\n$$ y'(\\theta) = 4\\cos\\theta - \\frac{4}{3}\\cos\\left(\\frac{4}{3}\\theta\\right) $$\nAt $\\theta=0$:\n$$ x'(0) = -4\\sin(0) - \\frac{4}{3}\\sin(0) = 0 $$\n$$ y'(0) = 4\\cos(0) - \\frac{4}{3}\\cos(0) = 4 - \\frac{4}{3} = \\frac{8}{3} $$\nSo the velocity vector at $\\theta=0$ is $\\vec{v}(0) = (0, \\frac{8}{3})$.\n\nSecond derivatives (acceleration components):\n$$ x''(\\theta) = -4\\cos\\theta - \\left(\\frac{4}{3}\\right)^2\\cos\\left(\\frac{4}{3}\\theta\\right) = -4\\cos\\theta - \\frac{16}{9}\\cos\\left(\\frac{4}{3}\\theta\\right) $$\n$$ y''(\\theta) = -4\\sin\\theta + \\frac{16}{9}\\sin\\left(\\frac{4}{3}\\theta\\right) $$\nAt $\\theta=0$:\n$$ x''(0) = -4\\cos(0) - \\frac{16}{9}\\cos(0) = -4 - \\frac{16}{9} = -\\frac{36+16}{9} = -\\frac{52}{9} $$\n$$ y''(0) = -4\\sin(0) + \\frac{16}{9}\\sin(0) = 0 $$\nSo the acceleration vector at $\\theta=0$ is $\\vec{a}(0) = (-\\frac{52}{9}, 0)$.\n\nThe dot product $\\vec{v}(0) \\cdot \\vec{a}(0) = (0)(-\\frac{52}{9}) + (\\frac{8}{3})(0) = 0$. The vectors are orthogonal.\nThe tangential component of acceleration, $\\frac{d|\\vec{v}|}{d\\theta} = \\frac{\\vec{v}\\cdot\\vec{a}}{|\\vec{v}|}$, is zero at $\\theta=0$.\nThis simplifies the calculation of $\\frac{d\\vec{T}}{d\\theta}$.\n$$ \\frac{d\\vec{T}}{d\\theta}\\bigg|_{\\theta=0} = \\frac{\\vec{a}(0)|\\vec{v}(0)|^2 - \\vec{v}(0)(0)}{|\\vec{v}(0)|^3} = \\frac{\\vec{a}(0)}{|\\vec{v}(0)|} $$\nThe curvature is then:\n$$ \\kappa(0) = \\frac{|d\\vec{T}/d\\theta|_{\\theta=0}|}{|\\vec{v}(0)|} = \\frac{|\\vec{a}(0)/|\\vec{v}(0)||}{|\\vec{v}(0)|} = \\frac{|\\vec{a}(0)|}{|\\vec{v}(0)|^2} $$\nLet's compute the magnitudes:\n$$ |\\vec{v}(0)| = \\sqrt{0^2 + \\left(\\frac{8}{3}\\right)^2} = \\frac{8}{3} $$\n$$ |\\vec{a}(0)| = \\sqrt{\\left(-\\frac{52}{9}\\right)^2 + 0^2} = \\frac{52}{9} $$\nNow, we compute the curvature $\\kappa(0)$:\n$$ \\kappa(0) = \\frac{|\\vec{a}(0)|}{|\\vec{v}(0)|^2} = \\frac{52/9}{(8/3)^2} = \\frac{52/9}{64/9} = \\frac{52}{64} $$\nTo simplify the fraction, we find the greatest common divisor of $52$ and $64$. Both are divisible by $4$.\n$$ 52 = 4 \\times 13 $$\n$$ 64 = 4 \\times 16 $$\n$$ \\kappa(0) = \\frac{13}{16} $$\nThe curvature of the tracer path at $\\theta=0$ is $\\frac{13}{16}$.\n\nAlternatively, one can use the standard formula for curvature for a parametric curve $(x(\\theta), y(\\theta))$:\n$$ \\kappa(\\theta) = \\frac{|x'(\\theta)y''(\\theta) - y'(\\theta)x''(\\theta)|}{(x'(\\theta)^2 + y'(\\theta)^2)^{3/2}} $$\nAt $\\theta=0$, we have $x'(0)=0$ and $y''(0)=0$.\n$$ \\kappa(0) = \\frac{|0 - y'(0)x''(0)|}{(0^2 + y'(0)^2)^{3/2}} = \\frac{|-y'(0)x''(0)|}{|y'(0)|^3} = \\frac{|x''(0)|}{y'(0)^2} $$\nSubstituting the values we found:\n$$ |x''(0)| = \\left|-\\frac{52}{9}\\right| = \\frac{52}{9} $$\n$$ y'(0)^2 = \\left(\\frac{8}{3}\\right)^2 = \\frac{64}{9} $$\n$$ \\kappa(0) = \\frac{52/9}{64/9} = \\frac{52}{64} = \\frac{13}{16} $$\nThis confirms the result.", "answer": "$$\\boxed{\\frac{13}{16}}$$", "id": "3261316"}, {"introduction": "In scientific computing, the \"best\" algorithm is not always the most obvious one; numerical stability is often more important than superficial simplicity. This problem has you analyze two methods for evaluating Bézier curves, a cornerstone of computer-aided design and graphics. By comparing direct evaluation of Bernstein polynomials with the recursive de Casteljau's algorithm, you will uncover why the latter is superior in practice, offering a crucial lesson in robust algorithm design. [@problem_id:3261315]", "problem": "Consider a Bézier curve of degree $n$ in $\\mathbb{R}^d$ defined by control points $\\{ \\mathbf{p}_k \\}_{k=0}^n$ and the Bernstein basis $\\{ B_k^n(t) \\}_{k=0}^n$ on the parameter interval $[0,1]$, with\n$$\n\\mathbf{C}(t) \\;=\\; \\sum_{k=0}^n \\mathbf{p}_k \\, B_k^n(t), \n\\quad\nB_k^n(t) \\;=\\; \\binom{n}{k} \\, t^k \\, (1-t)^{n-k}.\n$$\nTwo classical evaluation strategies are:\n- Direct Bernstein evaluation: compute all $B_k^n(t)$ and form the weighted sum.\n- De Casteljau’s algorithm: recursively compute affine combinations using $t$ and $(1-t)$ to obtain $\\mathbf{C}(t)$.\n\nAssume arithmetic follows the Institute of Electrical and Electronics Engineers (IEEE) $754$ floating-point standard with rounding to nearest, and adopt the standard model of floating-point error: for any basic operation $\\circ \\in \\{ +, -, \\times, \\div \\}$, \n$$\n\\mathrm{fl}(a \\circ b) \\;=\\; (a \\circ b)\\,(1+\\delta), \n\\quad |\\delta| \\le u,\n$$\nwhere $u$ is the unit roundoff. You may assume $t \\in [0,1]$, $n$ can be moderately large (e.g., $n$ in the tens or low hundreds), and the control points are bounded in norm.\n\nWhich of the following statements about computational cost and numerical stability is/are correct as $n$ increases and for $t$ in $[0,1]$?\n\nA. Computing $B_k^n(t)$ via $\\binom{n}{k} = \\dfrac{n!}{k!\\,(n-k)!}$ with factorials in floating point is significantly more prone to overflow/underflow than de Casteljau’s algorithm for large $n$ and thus is less numerically robust in practice.\n\nB. De Casteljau’s algorithm performs $\\mathcal{O}(n^2)$ floating-point operations and its forward error can be bounded by a constant times $n\\,u$ times a scale set by the control points (e.g., the diameter of their convex hull), uniformly for $t \\in [0,1]$.\n\nC. For $t = \\tfrac{1}{2}$, direct Bernstein evaluation is perfectly stable because $B_k^n(\\tfrac{1}{2})$ are all equal and the summation symmetry forces exact cancellation of rounding errors.\n\nD. When $t$ is very close to $0$ or to $1$, naive direct Bernstein evaluation using powers $t^k$ and $(1-t)^{n-k}$ can suffer significantly larger relative errors than de Casteljau’s algorithm due to amplified relative error in $t$ or $(1-t)$; de Casteljau’s recursive affine combinations keep intermediate values within the convex hull of the control points and mitigate such amplification.\n\nE. For any data and any $t \\in [0,1]$, direct Bernstein evaluation can be made as stable as de Casteljau’s algorithm merely by reordering the final weighted sum from largest to smallest basis values, without changing asymptotic complexity.\n\nSelect all that apply. Provide reasoning grounded in the floating-point model and the definitions above; do not assume any unstated specialized formulas beyond these fundamentals.", "solution": "The problem statement is to be validated before proceeding to a solution.\n\n### Step 1: Extract Givens\n- A Bézier curve of degree $n$ in $\\mathbb{R}^d$ is defined by $\\mathbf{C}(t) \\;=\\; \\sum_{k=0}^n \\mathbf{p}_k \\, B_k^n(t)$.\n- The control points are $\\{ \\mathbf{p}_k \\}_{k=0}^n$.\n- The Bernstein basis polynomials are $B_k^n(t) \\;=\\; \\binom{n}{k} \\, t^k \\, (1-t)^{n-k}$.\n- The parameter interval is $t \\in [0,1]$.\n- Two evaluation strategies are mentioned: direct Bernstein evaluation and de Casteljau's algorithm.\n- The arithmetic standard is IEEE $754$ floating-point with rounding to nearest.\n- The standard model for floating-point error is $\\mathrm{fl}(a \\circ b) \\;=\\; (a \\circ b)\\,(1+\\delta)$, with $|\\delta| \\le u$, where $u$ is the unit roundoff.\n- Assumed conditions: $t \\in [0,1]$, $n$ can be moderately large (tens or low hundreds), and control points norms are bounded.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is analyzed for validity.\n\n- **Scientifically Grounded**: Yes. The definitions of Bézier curves, Bernstein polynomials, de Casteljau's algorithm, and the standard floating-point error model are all cornerstones of computer-aided geometric design (CAGD) and numerical analysis.\n- **Well-Posed**: Yes. The problem asks for an assessment of the correctness of several technical statements regarding the computational properties of standard algorithms. The question is clearly formulated.\n- **Objective**: Yes. The statements concern computational cost and numerical stability, which are objective and quantifiable properties of algorithms that can be analyzed using the principles of numerical analysis.\n- **Incomplete or Contradictory Setup**: No. The problem provides all necessary definitions, context, and assumptions to evaluate the options. The terms \"direct Bernstein evaluation\" and \"de Casteljau's algorithm\" are standard and unambiguous in this context.\n- **Unrealistic or Infeasible**: No. The assumptions are standard for the analysis of these algorithms.\n- **Other Flaws**: The problem is not ill-posed, pseudo-profound, trivial, or unverifiable. It addresses a classic and important topic in scientific computing.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. A detailed analysis of each option may now proceed.\n\n### Analysis of the Options\n\nFirst, let us recall the structure of de Casteljau's algorithm. It is a recursive procedure defined as follows:\nLet $\\mathbf{p}_k^{(0)} = \\mathbf{p}_k$ for $k = 0, \\dots, n$.\nThen, for $r = 1, \\dots, n$ and $k = 0, \\dots, n-r$, compute:\n$$\n\\mathbf{p}_k^{(r)}(t) = (1-t) \\mathbf{p}_k^{(r-1)}(t) + t \\mathbf{p}_{k+1}^{(r-1)}(t)\n$$\nThe final point on the curve is $\\mathbf{C}(t) = \\mathbf{p}_0^{(n)}(t)$. A critical property of this algorithm is that each $\\mathbf{p}_k^{(r)}(t)$ is a convex combination of the original control points and thus lies within their convex hull.\n\nNow we evaluate each statement.\n\n**A. Computing $B_k^n(t)$ via $\\binom{n}{k} = \\dfrac{n!}{k!\\,(n-k)!}$ with factorials in floating point is significantly more prone to overflow/underflow than de Casteljau’s algorithm for large $n$ and thus is less numerically robust in practice.**\n\nThe factorial function $n!$ grows extremely rapidly. For instance, the maximum value for a standard $64$-bit double-precision floating-point number is approximately $1.8 \\times 10^{308}$. The factorial $171!$ already exceeds this value. For a \"moderately large\" degree like $n=200$, the direct computation of $n!$ will result in overflow. Even if the final value of the binomial coefficient $\\binom{n}{k}$ is representable, the intermediate calculation of $n!$ makes this specific approach infeasible.\nIn contrast, de Casteljau's algorithm involves only multiplications by $t \\in [0, 1]$ and $1-t \\in [0, 1]$, and additions. If the control points $\\mathbf{p}_k$ have bounded norms, all intermediate points $\\mathbf{p}_k^{(r)}(t)$ are convex combinations and are therefore also bounded (specifically, their norms are bounded by the maximum norm of the control points). This process has no inherent mechanism that would lead to large intermediate values and cause overflow.\nThus, the method for computing $B_k^n(t)$ specified in the option is indeed highly susceptible to overflow for even moderately large $n$, a problem that de Casteljau's algorithm completely avoids. Note that more stable methods exist to compute $B_k^n(t)$, but the statement correctly criticizes the specific naive method using factorials.\n\nTherefore, this statement is **Correct**.\n\n**B. De Casteljau’s algorithm performs $\\mathcal{O}(n^2)$ floating-point operations and its forward error can be bounded by a constant times $n\\,u$ times a scale set by the control points (e.g., the diameter of their convex hull), uniformly for $t \\in [0,1]$.**\n\nFirst, let's analyze the computational cost. The algorithm consists of $n$ stages (indexed by $r = 1, \\dots, n$). At stage $r$, we compute $n-r+1$ points in $\\mathbb{R}^d$. Each point computation involves two scalar-vector multiplications and one vector addition, totaling $2d$ multiplications and $d$ additions, i.e., $3d$ floating-point operations. The total number of points computed is $\\sum_{r=1}^n (n-r+1) = n + (n-1) + \\dots + 1 = \\frac{n(n+1)}{2}$. Thus, the total complexity is $\\frac{3d n(n+1)}{2}$, which is $\\mathcal{O}(dn^2)$. For a fixed dimension $d$, this is $\\mathcal{O}(n^2)$. So, the cost part of the statement is correct.\n\nNext, the forward error analysis. De Casteljau's algorithm is known for its excellent numerical stability. A standard forward error analysis shows that the norm of the error in the final computed point $\\tilde{\\mathbf{C}}(t)$ is bounded by $\\|\\tilde{\\mathbf{C}}(t) - \\mathbf{C}(t)\\| \\le C \\cdot n \\cdot u \\cdot M$, where $M$ is a bound on the magnitude of the control points (e.g., $\\max_k \\|\\mathbf{p}_k\\|$) and $C$ is a small constant. The key is that the error growth is linear in the degree $n$. Because all intermediate calculations are convex combinations with weights $t \\in [0,1]$ and $1-t \\in [0,1]$, the propagation of error is well-controlled, and this bound holds uniformly for all $t \\in [0,1]$. The statement's characterization of the error bound is consistent with established results in the numerical analysis of CAGD algorithms.\n\nTherefore, this statement is **Correct**.\n\n**C. For $t = \\tfrac{1}{2}$, direct Bernstein evaluation is perfectly stable because $B_k^n(\\tfrac{1}{2})$ are all equal and the summation symmetry forces exact cancellation of rounding errors.**\n\nLet's examine the premise that $B_k^n(\\frac{1}{2})$ are all equal. The basis function is $B_k^n(t) = \\binom{n}{k} t^k (1-t)^{n-k}$. For $t = \\frac{1}{2}$, this becomes:\n$$\nB_k^n\\left(\\frac{1}{2}\\right) = \\binom{n}{k} \\left(\\frac{1}{2}\\right)^k \\left(1-\\frac{1}{2}\\right)^{n-k} = \\binom{n}{k} \\left(\\frac{1}{2}\\right)^n\n$$\nThe value of $B_k^n(\\frac{1}{2})$ depends on the binomial coefficient $\\binom{n}{k}$, which is not constant for $k=0, \\dots, n$. It is symmetric, i.e., $\\binom{n}{k} = \\binom{n}{n-k}$, and has a maximum at $k \\approx n/2$, but the values are not all equal. For example, for $n=2$, we have $B_0^2(\\frac{1}{2}) = \\frac{1}{4}$, $B_1^2(\\frac{1}{2}) = \\frac{2}{4}$, and $B_2^2(\\frac{1}{2}) = \\frac{1}{4}$. Since the premise is false, the conclusion derived from it is unfounded.\nFurthermore, the idea of \"exact cancellation of rounding errors\" in floating-point arithmetic is generally a fallacy. Rounding errors accumulate, and while some cancellation might occur in specific cases, there is no general principle guaranteeing perfect stability or exact cancellation, even in symmetric sums.\n\nTherefore, this statement is **Incorrect**.\n\n**D. When $t$ is very close to $0$ or to $1$, naive direct Bernstein evaluation using powers $t^k$ and $(1-t)^{n-k}$ can suffer significantly larger relative errors than de Casteljau’s algorithm due to amplified relative error in $t$ or $(1-t)$; de Casteljau’s recursive affine combinations keep intermediate values within the convex hull of the control points and mitigate such amplification.**\n\nConsider $t$ being very close to $1$. The quantity $1-t$ is calculated by subtraction. If $t$ is a floating-point number near $1$, say $t=1-\\epsilon$ for some small $\\epsilon$, the computed value $\\mathrm{fl}(1-t)$ can have a very large relative error. For example, if $t$ has some roundoff error $\\delta_t$, so its representation is $\\tilde{t} = t(1+\\delta_t)$, then $\\mathrm{fl}(1-\\tilde{t}) \\approx 1 - t(1+\\delta_t) = (1-t) - t\\delta_t = \\epsilon - t\\delta_t \\approx \\epsilon - \\delta_t$. The relative error is $|(\\epsilon - \\delta_t)/\\epsilon - 1| = |\\delta_t/\\epsilon|$, which can be large if $\\epsilon$ is of the same order of magnitude as the machine precision $u$. This large relative error in $1-t$ gets amplified when raised to powers $(1-t)^{n-k}$. A similar issue occurs for $t \\approx 0$ with the term $1-t$ being near $1$.\nDe Casteljau's algorithm, $\\mathbf{p}_k^{(r)} = (1-t)\\mathbf{p}_k^{(r-1)} + t\\mathbf{p}_{k+1}^{(r-1)}$, is remarkably stable in this situation. Because it is a sequence of affine combinations where intermediate points remain bounded within the convex hull of the current generating points, there is no mechanism for catastrophic error amplification. Its stability is often characterized as being backward stable, meaning the computed result is the exact curve point for a slightly perturbed parameter, $\\mathbf{C}(t+\\Delta t)$, which is a very desirable property, especially when $t$ is near an endpoint. The statement correctly identifies the problem with direct evaluation and the reason for de Casteljau's robustness.\n\nTherefore, this statement is **Correct**.\n\n**E. For any data and any $t \\in [0,1]$, direct Bernstein evaluation can be made as stable as de Casteljau’s algorithm merely by reordering the final weighted sum from largest to smallest basis values, without changing asymptotic complexity.**\n\nIt is a known technique in numerical analysis that summing a set of floating-point numbers from smallest magnitude to largest magnitude can reduce the total accumulated error compared to an arbitrary or largest-to-smallest ordering. However, the statement proposes summing from largest to smallest, which is generally the *worst* strategy for numerical accuracy. But even if we assume the intended strategy (smallest to largest), the claim that this makes the method \"as stable as de Casteljau's algorithm\" is incorrect.\nThe instability of direct evaluation has multiple sources:\n1. Potential overflow/underflow in computing $\\binom{n}{k}$, as noted in A.\n2. Large relative errors in computing basis functions for $t$ near the endpoints, as noted in D.\n3. Potential for catastrophic cancellation in the sum $\\sum \\mathbf{p}_k B_k^n(t)$ if the terms $\\mathbf{p}_k B_k^n(t)$ are large and alternate in sign.\nSimply reordering the summation (which does not change asymptotic complexity) only addresses error accumulation in the final summation step. It does not fix the more fundamental problems of accurately computing the basis functions themselves, nor does it prevent catastrophic cancellation arising from the data $\\{\\mathbf{p}_k\\}$. The stability of de Casteljau's algorithm stems from its geometric structure (repeated convex combinations) which is a much more powerful property than simply reordering a sum.\n\nTherefore, this statement is **Incorrect**.", "answer": "$$\\boxed{ABD}$$", "id": "3261315"}]}