{"hands_on_practices": [{"introduction": "Our first hands-on practice establishes a fundamental baseline for the Finite Difference Method. We will discretize the one-dimensional Poisson equation, $-u''(x)=f(x)$, which serves as a cornerstone for many physical models, and construct the corresponding matrix system. The main objective is to numerically investigate how the condition number of this matrix, a key indicator of numerical stability and sensitivity, scales as the grid becomes finer. This exercise [@problem_id:3228017] provides crucial insight into why solving the discrete system can become more challenging with increased resolution.", "problem": "Consider the Boundary Value Problem (BVP) defined on the closed interval $[0,1]$ with homogeneous Dirichlet boundary conditions, namely $u(0)=0$ and $u(1)=0$, and interior equation $-u''(x)=f(x)$. Using the Finite Difference Method (FDM), discretize the second derivative operator with the standard second-order central difference scheme on a uniform grid. Let $N$ denote the number of interior grid points (unknowns), and let the grid spacing be $h=1/(N+1)$. The discrete linear system can be written in matrix form as $A_N \\mathbf{u}=\\mathbf{b}$, where $A_N$ is the $N \\times N$ tridiagonal matrix with main diagonal entries $2/h^2$ and immediate sub- and super-diagonal entries $-1/h^2$. Your task is to numerically investigate how the $2$-norm condition number of $A_N$ scales with $N$.\n\nUse the mathematical definition of the matrix $2$-norm condition number for a nonsingular matrix $A$, namely $\\kappa_2(A)=\\|A\\|_2\\,\\|A^{-1}\\|_2$, where $\\|A\\|_2$ denotes the matrix norm induced by the vector $2$-norm. Since $A_N$ is symmetric and positive definite, $\\kappa_2(A_N)$ equals the ratio of the largest to the smallest eigenvalue of $A_N$.\n\nImplement a program that, for each specified $N$, constructs $A_N$ exactly as described and computes its $2$-norm condition number by determining the smallest and largest eigenvalues of $A_N$. No physical units or angle units are involved in this computation.\n\nTest Suite:\n- Compute $\\kappa_2(A_N)$ for the following values of $N$: $N=1$, $N=2$, $N=5$, $N=10$, $N=50$, and $N=100$. This set includes a boundary condition case ($N=1$), small problem sizes ($N=2$, $N=5$), a moderate size ($N=10$), and larger sizes ($N=50$, $N=100$) to probe scaling behavior.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list should contain the $6$ floating-point condition numbers corresponding to the test suite values of $N$, in the order $[1,2,5,10,50,100]$, with no additional text. For example, the output should look like $[c_1,c_2,c_3,c_4,c_5,c_6]$, where each $c_i$ is the computed $\\kappa_2(A_N)$ for the corresponding $N$.", "solution": "The problem is valid. It presents a well-posed, scientifically grounded task from the field of numerical analysis. It asks for the computation of the matrix $2$-norm condition number for the finite difference matrix arising from the discretization of the one-dimensional Poisson equation, $-u''(x)=f(x)$, with homogeneous Dirichlet boundary conditions. All definitions and parameters are provided, and the task is computationally feasible and mathematically sound.\n\nThe solution proceeds as follows. First, we formalize the construction of the discrete system. Then, we justify the method for calculating the condition number based on the matrix's eigenvalues. Finally, we describe the algorithm to be implemented.\n\nThe boundary value problem is defined on the interval $[0, 1]$:\n$$\n-u''(x) = f(x), \\quad u(0) = 0, \\quad u(1) = 0\n$$\nWe introduce a uniform grid with $N+2$ points, $x_i = i h$ for $i=0, 1, \\dots, N+1$, where the grid spacing is $h = \\frac{1}{N+1}$. The values $u(x_i)$ are approximated by discrete values $u_i$. The boundary conditions directly give $u_0 = 0$ and $u_{N+1} = 0$. The unknowns are the values at the $N$ interior grid points, $\\mathbf{u} = [u_1, u_2, \\dots, u_N]^T$.\n\nThe second derivative $u''(x)$ at an interior point $x_i$ is approximated using the second-order central difference formula:\n$$\nu''(x_i) \\approx \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} = \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\nSubstituting this into the differential equation gives a system of $N$ linear equations for the $N$ unknowns:\n$$\n-\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = f(x_i), \\quad \\text{for } i=1, \\dots, N\n$$\nAt the boundaries of the interior domain, we use the given conditions.\nFor $i=1$: $-\\frac{u_0 - 2u_1 + u_2}{h^2} = f_1$. Since $u_0=0$, this becomes $\\frac{2u_1 - u_2}{h^2} = f_1$.\nFor $i=N$: $-\\frac{u_{N-1} - 2u_N + u_{N+1}}{h^2} = f_N$. Since $u_{N+1}=0$, this becomes $\\frac{-u_{N-1} + 2u_N}{h^2} = f_N$.\nFor an interior point $i \\in \\{2, \\dots, N-1\\}$: $\\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2} = f_i$.\n\nThis system of equations can be written in matrix form as $A_N \\mathbf{u} = \\mathbf{b}$, where $\\mathbf{b} = [f_1, f_2, \\dots, f_N]^T$ and $A_N$ is the $N \\times N$ matrix:\n$$\nA_N = \\frac{1}{h^2}\n\\begin{pmatrix}\n2  -1  0  \\cdots  0 \\\\\n-1  2  -1  \\cdots  0 \\\\\n0  -1  2  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  -1 \\\\\n0  \\cdots  0  -1  2\n\\end{pmatrix}\n$$\nThis matrix is symmetric and, as can be shown, positive definite.\n\nThe problem requires the computation of the $2$-norm condition number, $\\kappa_2(A_N)$. By definition, for a non-singular matrix $A$, $\\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2$. For a symmetric matrix, the $2$-norm is equal to its spectral radius, which is the maximum of the absolute values of its eigenvalues, $\\rho(A) = \\max_j |\\lambda_j|$. Since $A_N$ is symmetric and positive definite (SPD), its eigenvalues $\\lambda_j$ are all real and positive. Thus, $\\|A_N\\|_2 = \\max_j \\lambda_j = \\lambda_{\\max}(A_N)$.\n\nThe eigenvalues of the inverse matrix $A_N^{-1}$ are the reciprocals of the eigenvalues of $A_N$, i.e., $1/\\lambda_j$. Since $A_N^{-1}$ is also SPD, its $2$-norm is its largest eigenvalue, which is the reciprocal of the smallest eigenvalue of $A_N$.\n$$\n\\|A_N^{-1}\\|_2 = \\max_j \\frac{1}{\\lambda_j} = \\frac{1}{\\min_j \\lambda_j} = \\frac{1}{\\lambda_{\\min}(A_N)}\n$$\nCombining these results gives the formula for the condition number of an SPD matrix:\n$$\n\\kappa_2(A_N) = \\|A_N\\|_2 \\|A_N^{-1}\\|_2 = \\frac{\\lambda_{\\max}(A_N)}{\\lambda_{\\min}(A_N)}\n$$\nThis confirms the method stipulated in the problem statement. The task is therefore to construct the matrix $A_N$ for each given value of $N$, compute its eigenvalues, identify the minimum and maximum eigenvalues, and find their ratio.\n\nThe eigenvalues of this specific matrix are known analytically:\n$$\n\\lambda_k(A_N) = \\frac{2}{h^2}\\left(1 - \\cos\\left(\\frac{k\\pi}{N+1}\\right)\\right) = \\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right), \\quad k=1, 2, \\dots, N\n$$\nThe minimum eigenvalue corresponds to $k=1$, and the maximum to $k=N$.\n$$\n\\lambda_{\\min} = \\frac{4}{h^2}\\sin^2\\left(\\frac{\\pi}{2(N+1)}\\right)\n\\quad \\text{and} \\quad\n\\lambda_{\\max} = \\frac{4}{h^2}\\sin^2\\left(\\frac{N\\pi}{2(N+1)}\\right) = \\frac{4}{h^2}\\cos^2\\left(\\frac{\\pi}{2(N+1)}\\right)\n$$\nThe analytical condition number is therefore:\n$$\n\\kappa_2(A_N) = \\frac{\\cos^2\\left(\\frac{\\pi}{2(N+1)}\\right)}{\\sin^2\\left(\\frac{\\pi}{2(N+1)}\\right)} = \\cot^2\\left(\\frac{\\pi}{2(N+1)}\\right)\n$$\nAs $N \\to \\infty$, $h \\to 0$, and $\\frac{\\pi}{2(N+1)} \\to 0$. Using the small-angle approximation $\\cot(x) \\approx 1/x$, we get $\\kappa_2(A_N) \\approx \\left(\\frac{2(N+1)}{\\pi}\\right)^2 = \\frac{4}{\\pi^2}(N+1)^2$. This shows that the condition number scales as $O(N^2)$, indicating that the linear system becomes increasingly ill-conditioned as the grid is refined. Our numerical implementation will verify this behavior.\n\nThe algorithm to be implemented is:\n1. Iterate through each value of $N$ in the test suite $\\{1, 2, 5, 10, 50, 100\\}$.\n2. For each $N$, calculate the grid spacing $h = 1/(N+1)$.\n3. Construct the $N \\times N$ matrix $A_N$ with diagonal entries $2/h^2$ and off-diagonal entries $-1/h^2$.\n4. Compute the eigenvalues of $A_N$. Since the matrix is symmetric, a specialized and efficient algorithm can be used.\n5. Find the minimum and maximum eigenvalues from the computed spectrum.\n6. Calculate the condition number as the ratio $\\lambda_{\\max} / \\lambda_{\\min}$.\n7. Store the results and format them into the specified output string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the 2-norm condition number for the finite difference matrix A_N\n    for several values of N.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 5, 10, 50, 100]\n\n    results = []\n    for N in test_cases:\n        # Step 1: Calculate grid spacing h.\n        # Ensure floating point division for correctness.\n        h = 1.0 / (N + 1)\n        h_sq = h**2\n\n        # Step 2: Construct the N x N matrix A_N.\n        # The matrix is defined by its diagonals.\n        # Main diagonal entries are 2/h^2.\n        # Sub- and super-diagonal entries are -1/h^2.\n        \n        # A_N is a numpy array of size (N, N) initialized to zeros.\n        A_N = np.zeros((N, N))\n\n        # Populate the diagonals.\n        # For N=1, there are no off-diagonal elements, so handling this case\n        # with np.diag is robust.\n        main_diag_val = 2.0 / h_sq\n        off_diag_val = -1.0 / h_sq\n        \n        # Set main diagonal\n        np.fill_diagonal(A_N, main_diag_val)\n        \n        # Set super-diagonal (k=1) and sub-diagonal (k=-1)\n        if N  1:\n            # Slicing ensures we correctly handle the (N-1) length of off-diagonals.\n            np.fill_diagonal(A_N[0:, 1:], off_diag_val) # Super-diagonal\n            np.fill_diagonal(A_N[1:, 0:], off_diag_val) # Sub-diagonal\n\n        # Step 3: Compute the eigenvalues of A_N.\n        # Since A_N is symmetric, we can use np.linalg.eigvalsh, which is\n        # optimized for Hermitian (or real symmetric) matrices and returns\n        # real eigenvalues in ascending order.\n        eigenvalues = np.linalg.eigvalsh(A_N)\n        \n        # Step 4: Find the minimum and maximum eigenvalues.\n        # For a positive definite matrix, all eigenvalues are positive.\n        # eigvalsh returns them sorted, so the first is min and last is max.\n        lambda_min = eigenvalues[0]\n        lambda_max = eigenvalues[-1]\n        \n        # Step 5: Calculate the 2-norm condition number.\n        # For a symmetric positive definite matrix, kappa_2(A) = lambda_max(A) / lambda_min(A).\n        if lambda_min == 0:\n            # This case should not happen for N=1, but as a safeguard.\n            condition_number = float('inf')\n        else:\n            condition_number = lambda_max / lambda_min\n            \n        results.append(condition_number)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3228017"}, {"introduction": "Building on our understanding of the basic FDM matrix, we now examine the method's accuracy when faced with non-smooth data. This practice [@problem_id:3228101] involves a scenario where the forcing function $f(x)$ has a jump discontinuity, a common feature in models involving abrupt changes in loads or sources. By deriving the exact analytical solution and comparing it to our numerical results, you will explore the local behavior of the error and understand the performance of the finite difference approximation near points where the underlying assumptions of smoothness are violated.", "problem": "Consider the linear boundary value problem (BVP) defined on the interval $[0,1]$ with Dirichlet boundary conditions. Let $u:[0,1]\\to\\mathbb{R}$ satisfy\n$$\nu''(x) = f(x), \\quad x\\in(0,1), \\qquad u(0)=0,\\quad u(1)=0,\n$$\nwhere the forcing function $f(x)$ is a discontinuous step function at the point $x=x_c$ given by\n$$\nf(x) = \\begin{cases}\n1,  0 \\le x  x_c,\\\\\n0,  x_c \\le x \\le 1.\n\\end{cases}\n$$\nUse a uniform mesh with $N$ subintervals, mesh width $h=1/N$, and nodes $x_i = i h$ for $i=0,1,\\dots,N$. Approximate $u(x)$ at the interior nodes $\\{x_i\\}_{i=1}^{N-1}$ by the standard central finite difference discretization of $u''(x)$, that is, construct the tridiagonal linear system obtained by replacing $u''(x_i)$ with\n$$\n\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = f(x_i), \\quad i=1,2,\\dots,N-1,\n$$\nsubject to the boundary conditions $u_0=0$ and $u_N=0$. Solve the resulting linear system to obtain the numerical approximation $\\{u_i\\}_{i=0}^N$.\n\nDefine the exact solution $u(x)$ analytically by solving the BVP and enforcing appropriate continuity conditions at $x=x_c$. Using this exact solution, compute the following error metrics based on the numerical approximation:\n- The infinity norm of the error over interior nodes,\n$$\nE_{\\infty} = \\max_{1\\le i \\le N-1} \\left|u_i - u(x_i)\\right|.\n$$\n- The errors at the grid points immediately to the left and right of the discontinuity. Let $i_L$ and $i_R$ be defined as follows:\n  1. If $x_c$ does not coincide with a grid node, set $i_L = \\lfloor x_c/h \\rfloor$ and $i_R = i_L + 1$, and then clamp to interior indices so that $1 \\le i_L \\le N-2$ and $2 \\le i_R \\le N-1$.\n  2. If $x_c$ coincides with a grid node $x_k$ (that is, $x_k = x_c$ for some integer $k$), set $i_L = \\max(1,k-1)$ and $i_R = \\min(N-1,k+1)$.\nThen compute\n$$\nE_L = \\left|u_{i_L} - u(x_{i_L})\\right|, \\qquad E_R = \\left|u_{i_R} - u(x_{i_R})\\right|.\n$$\n\nYour program must:\n- Assemble and solve the finite difference linear system for each test case specified below.\n- Construct the exact solution $u(x)$ and compute $E_{\\infty}$, $E_L$, and $E_R$ for each test case.\n- Produce a single line of output containing a comma-separated list of results, one per test case, where each result is the list $[E_{\\infty},E_L,E_R]$.\n\nTest suite (each item is a pair $(x_c,N)$):\n1. $(x_c,N) = (0.37,40)$, a general case where the discontinuity lies strictly between grid nodes.\n2. $(x_c,N) = (0.50,50)$, a case where the discontinuity aligns exactly with a grid node.\n3. $(x_c,N) = (0.05,41)$, a case where the discontinuity is near the left boundary and does not align with a grid node.\n4. $(x_c,N) = (1.00,60)$, a case where the discontinuity is at the right boundary.\n5. $(x_c,N) = (0.37,80)$, a refinement of the first case to observe error behavior under mesh refinement.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case contributing one sub-list $[E_{\\infty},E_L,E_R]$. For example, the output should look like\n$$\n[[e_{\\infty}^{(1)},e_L^{(1)},e_R^{(1)}],[e_{\\infty}^{(2)},e_L^{(2)},e_R^{(2)}],\\dots].\n$$", "solution": "The problem requires solving a one-dimensional linear boundary value problem (BVP) with a discontinuous forcing function using the finite difference method, and comparing the numerical solution to the exact analytical solution.\n\n### 1. Analytical Solution\nThe BVP is given by:\n$$\nu''(x) = f(x), \\quad x \\in (0,1)\n$$\nwith Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$. The forcing function $f(x)$ is a step function:\n$$\nf(x) = \\begin{cases}\n1,  0 \\le x  x_c, \\\\\n0,  x_c \\le x \\le 1.\n\\end{cases}\n$$\nWe solve this by integrating $u''(x)$ piecewise on the two subintervals defined by the discontinuity at $x=x_c$.\n\nFor $0 \\le x  x_c$, we have $u''(x) = 1$. Integrating twice with respect to $x$ yields:\n$$\nu'(x) = x + A\n$$\n$$\nu(x) = \\frac{1}{2}x^2 + Ax + B\n$$\nFor $x_c \\le x \\le 1$, we have $u''(x) = 0$. Integrating twice yields:\n$$\nu'(x) = C\n$$\n$$\nu(x) = Cx + D\n$$\nwhere $A$, $B$, $C$, and $D$ are constants of integration. These are determined by the boundary conditions and by enforcing continuity of the solution $u(x)$ and its first derivative $u'(x)$ at $x=x_c$. A physical system corresponding to this equation (e.g., a string under a piecewise constant load) requires that the string itself does not break ($u$ is continuous) and does not have a kink ($u'$ is continuous).\n\n1.  **Boundary condition at $x=0$**: $u(0)=0$. Assuming $x_c0$, we use the first form of the solution:\n    $u(0) = \\frac{1}{2}(0)^2 + A(0) + B = 0 \\implies B=0$.\n\n2.  **Boundary condition at $x=1$**: $u(1)=0$. We use the second form:\n    $u(1) = C(1) + D = 0 \\implies D=-C$.\n\n3.  **Continuity of $u(x)$ at $x=x_c$**: The values from both pieces must match, $u(x_c^-) = u(x_c^+)$.\n    $$\n    \\frac{1}{2}x_c^2 + Ax_c = Cx_c + D\n    $$\n    Substituting $B=0$ and $D=-C$, we get:\n    $$\n    \\frac{1}{2}x_c^2 + Ax_c = C(x_c - 1) \\quad (\\text{Eq. 1})\n    $$\n\n4.  **Continuity of $u'(x)$ at $x=x_c$**: The derivatives must also match, $u'(x_c^-) = u'(x_c^+)$.\n    $$\n    x_c + A = C \\quad (\\text{Eq. 2})\n    $$\n\nWe now solve the system of two linear equations (Eq. 1 and Eq. 2) for $A$ and $C$. From Eq. 2, we have $A = C-x_c$. Substituting this into Eq. 1:\n$$\n\\frac{1}{2}x_c^2 + (C-x_c)x_c = C(x_c - 1)\n$$\n$$\n\\frac{1}{2}x_c^2 + Cx_c - x_c^2 = Cx_c - C\n$$\n$$\n-\\frac{1}{2}x_c^2 = -C \\implies C = \\frac{1}{2}x_c^2\n$$\nNow, we find the other constants:\n$A = C - x_c = \\frac{1}{2}x_c^2 - x_c$\n$D = -C = -\\frac{1}{2}x_c^2$\n\nSubstituting these constants back into the piecewise expressions for $u(x)$, the exact analytical solution is:\n$$\nu(x) = \\begin{cases}\n\\frac{1}{2}x^2 + \\left(\\frac{1}{2}x_c^2 - x_c\\right)x,  0 \\le x  x_c \\\\\n\\frac{1}{2}x_c^2 (x-1),  x_c \\le x \\le 1\n\\end{cases}\n$$\n\n### 2. Finite Difference Method\nWe discretize the domain $[0,1]$ using a uniform mesh with $N$ subintervals of width $h=1/N$. The grid nodes are $x_i = ih$ for $i=0,1,\\dots,N$. Let $u_i$ be the numerical approximation of $u(x_i)$.\n\nThe second derivative $u''(x_i)$ is approximated by a second-order central difference formula:\n$$\nu''(x_i) \\approx \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\nSubstituting this into the BVP at each interior node $x_i$ for $i=1, 2, \\dots, N-1$, we obtain a system of linear equations:\n$$\n\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = f(x_i)\n$$\nThe boundary conditions give $u_0=0$ and $u_N=0$. Rearranging the equations, we get:\n$$\nu_{i-1} - 2u_i + u_{i+1} = h^2 f(x_i), \\quad i=1, 2, \\dots, N-1\n$$\nThis forms a linear system $A \\mathbf{u} = \\mathbf{b}$ for the vector of unknowns $\\mathbf{u} = [u_1, u_2, \\dots, u_{N-1}]^T$. The matrix $A$ is an $(N-1) \\times (N-1)$ tridiagonal matrix:\n$$\nA = \\begin{pmatrix}\n-2  1    \\\\\n1  -2  1   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  1  -2  1 \\\\\n   1  -2\n\\end{pmatrix}\n$$\nThe right-hand side vector $\\mathbf{b}$ has components $b_{i-1} = h^2 f(x_i)$ for $i=1, \\dots, N-1$. The value of $f(x_i)$ is $1$ if $x_i  x_c$ and $0$ if $x_i \\ge x_c$. This system is non-singular and can be solved efficiently, for instance, using a standard linear solver.\n\n### 3. Error Computation\nOnce the numerical solution $\\{u_i\\}_{i=0}^N$ is found, we compute the error by comparing it to the exact solution $\\{u(x_i)\\}_{i=0}^N$.\nThe required error metrics are:\n- The maximum absolute error over the interior nodes:\n  $$\n  E_{\\infty} = \\max_{1\\le i \\le N-1} \\left|u_i - u(x_i)\\right|\n  $$\n- The local errors at grid points bracketing the discontinuity. The indices $i_L$ (left) and $i_R$ (right) are determined as specified:\n  - If $x_c$ does not coincide with a grid node $x_k$, $i_L = \\lfloor x_c/h \\rfloor$ and $i_R = i_L + 1$. The problem statement implies these indices should be within the valid range for interior points near the discontinuity.\n  - If $x_c$ coincides with a grid node $x_k$, $i_L = \\max(1,k-1)$ and $i_R = \\min(N-1,k+1)$.\n  The errors are then computed as:\n  $$\n  E_L = \\left|u_{i_L} - u(x_{i_L})\\right|, \\quad E_R = \\left|u_{i_R} - u(x_{i_R})\\right|\n  $$\nThe Python program below implements this entire process for the given test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(xc, N):\n    \"\"\"\n    Solves the BVP for a given xc and N, and computes error metrics.\n    \"\"\"\n    # 1. Discretization\n    h = 1.0 / N\n    x_nodes = np.linspace(0, 1, N + 1)\n    dim = N - 1\n\n    if dim = 0:\n        return [0.0, 0.0, 0.0]\n\n    # 2. Assemble the finite difference matrix A\n    main_diag = np.full(dim, -2.0)\n    off_diag = np.full(dim - 1, 1.0)\n    A = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n    \n    # 3. Assemble the right-hand side vector b\n    f_int = np.zeros(dim)\n    for i in range(dim):\n        # x_nodes[i + 1] corresponds to the interior node x_{i+1}\n        if x_nodes[i + 1]  xc:\n            f_int[i] = 1.0\n    \n    b = (h**2) * f_int\n    \n    # 4. Solve the linear system for interior nodes\n    u_int = np.linalg.solve(A, b)\n    \n    # 5. Construct full numerical solution vector (including boundaries)\n    u_num = np.concatenate(([0.0], u_int, [0.0]))\n\n    # 6. Compute the exact solution at grid points\n    def exact_u_func(x, xc_val):\n        \"\"\"Computes the exact analytical solution u(x) for a given xc.\"\"\"\n        A_const = 0.5 * xc_val**2 - xc_val\n        C_const = 0.5 * xc_val**2\n        \n        if x  xc_val:\n            return 0.5 * x**2 + A_const * x\n        else:\n            return C_const * (x - 1)\n\n    u_exact_vals = np.array([exact_u_func(xi, xc) for xi in x_nodes])\n\n    # 7. Compute error vector and E_infinity\n    errors = np.abs(u_num - u_exact_vals)\n    E_inf = np.max(errors[1:N])\n    \n    # 8. Determine indices i_L and i_R for local errors\n    is_on_grid = np.isclose(xc / h, np.round(xc / h))\n    \n    if is_on_grid:\n        k = int(np.round(xc / h))\n        i_L = max(1, k - 1)\n        i_R = min(N - 1, k + 1)\n    else:\n        i_L_raw = int(np.floor(xc / h))\n        i_R_raw = i_L_raw + 1\n        \n        # The problem statement's clamping instruction is:\n        # \"...clamp to interior indices so that 1=iL=N-2 and 2=iR=N-1.\"\n        # The following implementation satisfies this constraint and keeps i_R = i_L + 1.\n        if i_L_raw  1:\n            i_L = 1\n            i_R = 2\n        elif i_L_raw = N - 1:\n            i_L = N - 2\n            i_R = N - 1\n        else:\n            i_L = i_L_raw\n            i_R = i_R_raw\n\n    E_L = errors[i_L]\n    E_R = errors[i_R]\n    \n    return [E_inf, E_L, E_R]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.37, 40),\n        (0.50, 50),\n        (0.05, 41),\n        (1.00, 60),\n        (0.37, 80),\n    ]\n\n    results = []\n    for xc, N in test_cases:\n        result = solve_case(xc, N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3228101"}, {"introduction": "Many scientific and engineering problems involve variable physical properties and diverse boundary constraints. This final practice [@problem_id:3228073] extends our skills to a more general and practical class of BVPs, featuring a variable coefficient operator $-\\frac{d}{dx}(p(x)\\frac{du}{dx})$ and mixed boundary conditions, including a Neumann condition that specifies the derivative at the boundary. You will learn to implement a conservative discretization and a second-order accurate formula for the Neumann condition, significantly expanding the range of problems you can solve numerically.", "problem": "Consider the linear second-order ordinary differential equation in divergence (self-adjoint) form\n$$\n-\\,\\frac{d}{dx}\\left(p(x)\\,\\frac{d u}{dx}\\right) + q(x)\\,u(x) = r(x),\n$$\nposed on the closed interval $[a,b]$, where $p(x)$, $q(x)$, and $r(x)$ are given sufficiently smooth functions with $p(x)  0$, and the solution $u(x)$ is subject to mixed boundary conditions:\n$$\nu(a) = \\alpha \\quad \\text{(Dirichlet at } x=a\\text{)}, \\qquad u'(b) = \\beta \\quad \\text{(Neumann at } x=b\\text{)}.\n$$\nYour task is to derive, from first principles, a second-order accurate Finite Difference Method (FDM) discretization on a uniform grid and implement it to solve the boundary value problem. The derivation must start from the core definitions of the first derivative and Taylor series expansions about grid points, and must not assume any pre-known discrete stencil. Specifically:\n- Begin with the definitions of the first derivative and apply Taylor series expansions near grid points to obtain second-order approximations.\n- Use the resulting approximations to discretize the operator $-(p u')'$ consistently at interior grid points. Treat $p(x)$ at half-grid locations so that the discrete operator is conservative.\n- Impose the Dirichlet boundary condition by directly prescribing the value at $x=a$.\n- Impose the Neumann boundary condition at $x=b$ using a second-order one-sided difference formula derived by Taylor series.\n- Assemble and solve the resulting linear system for the nodal values of $u(x)$.\n\nImplementation requirements:\n- Use a uniform grid with $N$ equal subintervals, grid points $x_i = a + i h$ for $i=0,1,\\dots,N$, and grid spacing $h = (b-a)/N$.\n- At each interior grid point, approximate the differential operator using second-order consistent flux differences that depend on $p(x)$ evaluated at half-grid locations.\n- Enforce the Neumann boundary condition at $x=b$ with a second-order one-sided finite difference relation for $u'(b)$.\n\nTest suite:\nFor each test case below, compute the maximum absolute error over all grid points by comparing the numerical solution to the provided exact solution. The final numerical answers are dimensionless real numbers (no physical units). Express each result as a floating-point number rounded to six decimal places.\n\nTest cases:\n1. Conservative diffusion, no reaction:\n   - Domain: $[a,b] = [0,1]$, $N = 50$.\n   - Coefficients: $p(x) = 1$, $q(x) = 0$, $r(x) = \\sin(x)$.\n   - Exact solution: $u(x) = \\sin(x) + x$.\n   - Boundary data: $\\alpha = u(0)$, $\\beta = u'(1)$.\n\n2. Variable diffusivity, no reaction:\n   - Domain: $[a,b] = [0,1]$, $N = 40$.\n   - Coefficients: $p(x) = 1 + x$, $q(x) = 0$, and $r(x)$ chosen so that $u(x) = x^2$ solves the differential equation. Use $r(x) = -\\frac{d}{dx}\\left(p(x)\\,\\frac{d}{dx} x^2\\right) = -(2 + 4x)$.\n   - Exact solution: $u(x) = x^2$.\n   - Boundary data: $\\alpha = u(0)$, $\\beta = u'(1)$.\n\n3. Constant diffusivity with reaction:\n   - Domain: $[a,b] = [0,1]$, $N = 60$.\n   - Coefficients: $p(x) = 1$, $q(x) = 2$, $r(x)$ chosen so that $u(x) = e^x$ solves the differential equation. Use $r(x) = -u''(x) + q(x) u(x) = e^x$.\n   - Exact solution: $u(x) = e^x$.\n   - Boundary data: $\\alpha = u(0)$, $\\beta = u'(1)$.\n\n4. Edge-grid case to test boundary handling:\n   - Domain: $[a,b] = [0,1]$, $N = 2$.\n   - Coefficients: $p(x) = 1$, $q(x) = 0$, $r(x) = \\sin(x)$.\n   - Exact solution: $u(x) = \\sin(x) + x$.\n   - Boundary data: $\\alpha = u(0)$, $\\beta = u'(1)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is the maximum absolute error for the corresponding test case rounded to six decimal places.", "solution": "The user has provided a valid problem statement. I will proceed with the derivation and solution.\n\nWe are tasked with solving the linear second-order ordinary differential equation in self-adjoint form:\n$$\n-\\frac{d}{dx}\\left(p(x)\\frac{du}{dx}\\right) + q(x)u(x) = r(x), \\quad x \\in [a, b]\n$$\nwith mixed boundary conditions: a Dirichlet condition $u(a) = \\alpha$ and a Neumann condition $u'(b) = \\beta$. The functions $p(x)$, $q(x)$, and $r(x)$ are given, with $p(x)  0$. We will derive a second-order accurate finite difference method on a uniform grid and implement it.\n\n**1. Grid and Notation**\n\nWe define a uniform grid on the interval $[a,b]$ with $N$ subintervals. The grid points are $x_i = a + i h$ for $i=0, 1, \\dots, N$, where the grid spacing is $h = (b-a)/N$. The numerical solution at these points will be denoted by $U_i \\approx u(x_i)$. The unknowns to be solved for are $U_1, U_2, \\dots, U_N$, since $U_0 = u(a) = \\alpha$ is given by the Dirichlet boundary condition. This gives a system of $N$ unknowns.\n\n**2. Discretization at Interior Points**\n\nThe differential equation can be written as $-F'(x) + q(x)u(x) = r(x)$, where $F(x) = p(x)u'(x)$ is the flux.\nAt an interior grid point $x_i$ for $i=1, \\dots, N-1$, we approximate the term $-F'(x_i)$ using a second-order central difference centered at $x_i$:\n$$\n-F'(x_i) \\approx -\\frac{F(x_i + h/2) - F(x_i - h/2)}{h}\n$$\nThe half-grid points are denoted as $x_{i \\pm 1/2} = x_i \\pm h/2$. This approximation is $O(h^2)$ accurate.\n\nTo maintain second-order accuracy and the conservative property of the operator, we approximate the flux $F$ at these half-grid points. At $x_{i+1/2}$, we have $F(x_{i+1/2}) = p(x_{i+1/2}) u'(x_{i+1/2})$. We approximate the derivative $u'(x_{i+1/2})$ using a second-order central difference centered at $x_{i+1/2}$:\n$$\nu'(x_{i+1/2}) \\approx \\frac{u(x_{i+1}) - u(x_i)}{h} = \\frac{U_{i+1} - U_i}{h} + O(h^2)\n$$\nLetting $p_{i+1/2} = p(x_{i+1/2})$, the flux approximation is:\n$$\nF_{i+1/2} \\approx p_{i+1/2} \\frac{U_{i+1} - U_i}{h}\n$$\nSimilarly, at $x_{i-1/2}$:\n$$\nF_{i-1/2} \\approx p_{i-1/2} \\frac{U_i - U_{i-1}}{h}\n$$\nSubstituting these flux approximations back into the approximation for $-F'(x_i)$:\n$$\n-\\frac{d}{dx}\\left(p(x)\\frac{du}{dx}\\right)\\bigg|_{x_i} \\approx -\\frac{1}{h} \\left( p_{i+1/2} \\frac{U_{i+1} - U_i}{h} - p_{i-1/2} \\frac{U_i - U_{i-1}}{h} \\right)\n$$\n$$\n= \\frac{1}{h^2} \\left[ -p_{i-1/2} U_{i-1} + (p_{i-1/2} + p_{i+1/2}) U_i - p_{i+1/2} U_{i+1} \\right]\n$$\nThe full discretized equation at an interior point $x_i$ ($i=1, \\dots, N-1$) is:\n$$\n\\frac{1}{h^2} \\left[ -p_{i-1/2} U_{i-1} + (p_{i-1/2} + p_{i+1/2}) U_i - p_{i+1/2} U_{i+1} \\right] + q(x_i) U_i = r(x_i)\n$$\nMultiplying by $h^2$, we obtain the linear equation for row $i$:\n$$\n-p_{i-1/2} U_{i-1} + (p_{i-1/2} + p_{i+1/2} + h^2 q_i) U_i - p_{i+1/2} U_{i+1} = h^2 r_i\n$$\nwhere $q_i=q(x_i)$ and $r_i=r(x_i)$.\n\n**3. Discretization of Boundary Conditions**\n\nThe system requires $N$ equations for the $N$ unknowns $U_1, \\dots, U_N$. We have $N-1$ equations from the interior points. The remaining equation comes from the Neumann boundary condition at $x_N=b$.\n\n**Dirichlet condition at $x_0 = a$:**\nThe value $U_0$ is known: $U_0 = \\alpha$. This value is not an unknown. For the first equation ($i=1$), the term involving $U_0$ is moved to the right-hand side:\n$$\n(p_{1/2} + p_{3/2} + h^2 q_1) U_1 - p_{3/2} U_2 = h^2 r_1 + p_{1/2} U_0 = h^2 r_1 + p_{1/2} \\alpha\n$$\n\n**Neumann condition at $x_N = b$:**\nThe condition is $u'(b) = \\beta$. We are required to use a second-order accurate one-sided difference formula. We derive this by considering Taylor series expansions of $u(x)$ around $x_N$:\n$$\nu(x_{N-1}) = u(x_N - h) = u(x_N) - h u'(x_N) + \\frac{h^2}{2} u''(x_N) - \\frac{h^3}{6} u'''(x_N) + O(h^4)\n$$\n$$\nu(x_{N-2}) = u(x_N - 2h) = u(x_N) - 2h u'(x_N) + \\frac{(2h)^2}{2} u''(x_N) - \\frac{(2h)^3}{6} u'''(x_N) + O(h^4)\n$$\nTo create a formula for $u'(x_N)$ that is $O(h^2)$, we must eliminate the $u''(x_N)$ term. We multiply the first equation by $4$ and subtract the second:\n$$\n4u(x_{N-1}) - u(x_{N-2}) = 3u(x_N) - 2h u'(x_N) + O(h^3)\n$$\nSolving for $u'(x_N)$:\n$$\nu'(x_N) = \\frac{3u(x_N) - 4u(x_{N-1}) + u(x_{N-2})}{2h} + O(h^2)\n$$\nApplying this to our discrete problem at $x_N=b$, we get the final equation:\n$$\n\\frac{3U_N - 4U_{N-1} + U_{N-2}}{2h} = \\beta\n$$\nThis can be written as: $U_{N-2} - 4U_{N-1} + 3U_N = 2h\\beta$. Note that for the special case $N=2$, the point $x_{N-2}$ is $x_0$, so the equation involves the known value $U_0 = \\alpha$: $-4U_1 + 3U_2 = 2h\\beta - U_0 = 2h\\beta - \\alpha$.\n\n**4. Assembling the Linear System**\n\nWe assemble the $N \\times N$ linear system $A \\vec{U} = \\vec{F}$, where the vector of unknowns is $\\vec{U} = [U_1, U_2, \\dots, U_N]^T$. Let the matrix and vector indices be 0-based in correspondence with programming practice, where row/column $k$ corresponds to unknown $U_{k+1}$.\n\nFor $k = 0, \\dots, N-2$ (representing the ODE at grid points $x_{k+1}$):\nThe equation for $x_{j}$ ($j=k+1$) is: $-p_{j-\\frac{1}{2}}U_{j-1} + (p_{j-\\frac{1}{2}}+p_{j+\\frac{1}{2}}+h^2q_j)U_j -p_{j+\\frac{1}{2}}U_{j+1} = h^2r_j$.\n- **Row $k=0$ (for $U_1$):**\n  $A_{0,0} = p_{1/2} + p_{3/2} + h^2 q_1$\n  $A_{0,1} = -p_{3/2}$\n  $F_0 = h^2 r_1 + p_{1/2} \\alpha$\n- **Rows $k=1, \\dots, N-2$ (for $U_2, \\dots, U_{N-1}$):**\n  $j = k+1$. The unknowns are $U_j, U_{j \\pm 1}$, corresponding to `U_vec` indices $k, k \\pm 1$.\n  $A_{k, k-1} = -p_{k+1/2}$\n  $A_{k, k} = p_{k+1/2} + p_{k+3/2} + h^2 q_{k+1}$\n  $A_{k, k+1} = -p_{k+3/2}$\n  $F_k = h^2 r_{k+1}$\n\n- **Row $k=N-1$ (for $U_N$, from Neumann BC):**\n  - If $N \\ge 3$: The equation is $U_{N-2} - 4U_{N-1} + 3U_N = 2h\\beta$. The unknowns involved correspond to `U_vec` indices $N-3, N-2, N-1$.\n    $A_{N-1, N-3} = 1$\n    $A_{N-1, N-2} = -4$\n    $A_{N-1, N-1} = 3$\n    $F_{N-1} = 2h\\beta$\n  - If $N=2$: The equation is $-4U_1 + 3U_2 = 2h\\beta - \\alpha$. The unknowns are $U_1, U_2$, corresponding to `U_vec` indices $0, 1$.\n    $A_{1,0} = -4$\n    $A_{1,1} = 3$\n    $F_1 = 2h\\beta - \\alpha$\n\nThis fully specified linear system can be solved for $\\vec{U}$. The full numerical solution is then given by concatenating the Dirichlet value with the solved unknowns: $[U_0, U_1, \\dots, U_N]$. The maximum absolute error is then computed by comparing this vector with the exact solution evaluated at the grid points.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the solver.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Conservative diffusion, no reaction\",\n            \"a\": 0.0, \"b\": 1.0, \"N\": 50,\n            \"p\": lambda x: 1.0,\n            \"q\": lambda x: 0.0,\n            \"r\": lambda x: np.sin(x),\n            \"u_exact\": lambda x: np.sin(x) + x,\n            \"du_exact\": lambda x: np.cos(x) + 1.0,\n        },\n        {\n            \"name\": \"Variable diffusivity, no reaction\",\n            \"a\": 0.0, \"b\": 1.0, \"N\": 40,\n            \"p\": lambda x: 1.0 + x,\n            \"q\": lambda x: 0.0,\n            \"r\": lambda x: -(2.0 + 4.0 * x),\n            \"u_exact\": lambda x: x**2,\n            \"du_exact\": lambda x: 2.0 * x,\n        },\n        {\n            \"name\": \"Constant diffusivity with reaction\",\n            \"a\": 0.0, \"b\": 1.0, \"N\": 60,\n            \"p\": lambda x: 1.0,\n            \"q\": lambda x: 2.0,\n            \"r\": lambda x: np.exp(x),\n            \"u_exact\": lambda x: np.exp(x),\n            \"du_exact\": lambda x: np.exp(x),\n        },\n        {\n            \"name\": \"Edge-grid case\",\n            \"a\": 0.0, \"b\": 1.0, \"N\": 2,\n            \"p\": lambda x: 1.0,\n            \"q\": lambda x: 0.0,\n            \"r\": lambda x: np.sin(x),\n            \"u_exact\": lambda x: np.sin(x) + x,\n            \"du_exact\": lambda x: np.cos(x) + 1.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha = case[\"u_exact\"](case[\"a\"])\n        beta = case[\"du_exact\"](case[\"b\"])\n\n        U_numerical, x_grid = solve_bvp(\n            p=case[\"p\"], q=case[\"q\"], r=case[\"r\"],\n            a=case[\"a\"], b=case[\"b\"], N=case[\"N\"],\n            alpha=alpha, beta=beta\n        )\n\n        U_exact_vals = case[\"u_exact\"](x_grid)\n        max_abs_error = np.max(np.abs(U_numerical - U_exact_vals))\n        results.append(f\"{max_abs_error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_bvp(p, q, r, a, b, N, alpha, beta):\n    \"\"\"\n    Solves the BVP using the derived finite difference scheme.\n    \n    The system is A * U_vec = F, where U_vec contains the N unknowns U_1, ..., U_N.\n    \"\"\"\n    h = (b - a) / N\n\n    # Grid points\n    x_grid = np.linspace(a, b, N + 1)\n    \n    # Initialize the linear system\n    A = np.zeros((N, N))\n    F = np.zeros(N)\n\n    # The vector of unknowns U_vec corresponds to U_1, ..., U_N\n    # U_vec[k] approximates u(x_{k+1})\n\n    # Equation for U_1 (matrix row 0)\n    # This corresponds to the ODE at x_1\n    p_half = p(x_grid[0] + h/2.0)\n    p_3half = p(x_grid[1] + h/2.0)\n    A[0, 0] = p_half + p_3half + h**2 * q(x_grid[1])\n    if N  1:\n        A[0, 1] = -p_3half\n    F[0] = h**2 * r(x_grid[1]) + p_half * alpha\n\n    # Equations for U_2, ..., U_{N-1} (matrix rows 1 to N-2)\n    # This corresponds to the ODE at x_j where j = 2, ..., N-1\n    for j in range(2, N):\n        k = j - 1 # 0-based index for matrix row\n        \n        p_minus_half = p(x_grid[j] - h/2.0)\n        p_plus_half = p(x_grid[j] + h/2.0)\n        \n        A[k, k - 1] = -p_minus_half\n        A[k, k] = p_minus_half + p_plus_half + h**2 * q(x_grid[j])\n        A[k, k + 1] = -p_plus_half\n        F[k] = h**2 * r(x_grid[j])\n\n    # Equation for U_N (matrix row N-1) from Neumann BC\n    if N = 3:\n        # One-sided 2nd order formula for u'(x_N) uses U_N, U_{N-1}, U_{N-2}\n        # U_N-2 - 4*U_{N-1} + 3*U_N = 2*h*beta\n        A[N - 1, N - 3] = 1.0\n        A[N - 1, N - 2] = -4.0\n        A[N - 1, N - 1] = 3.0\n        F[N - 1] = 2.0 * h * beta\n    elif N == 2:\n        # For N=2, formula uses U_2, U_1, U_0\n        # -4*U_1 + 3*U_2 = 2*h*beta - U_0\n        A[1, 0] = -4.0\n        A[1, 1] = 3.0\n        F[1] = 2.0 * h * beta - alpha\n    elif N == 1:\n        # For N=1, formula is 3*U_1 - 4*U_0 + ... not usable.\n        # But this problem doesn't test N=1. The standard one-sided formula is:\n        # (U_1 - U_0)/h = beta. A[0,0]=1, F[0]=h*beta+alpha.\n        # A simpler handling for N=1: (3U_1 - 4U_0 + U_{-1})/2h = beta\n        # Let's derive a simpler O(h^2) for this case:\n        # u(a) = u(b-h) = u(b)-h*u'(b)+h^2/2 u''(b) + ...\n        # alpha = U_1 - h*beta + h^2/2*... -> U_1 = alpha+h*beta\n        # Use equation at U1: -p0.5*(U0)+ (p0.5+p1.5+h^2q1)U1-p1.5U2 = h^2 r1 --> needs U2\n        # The prompt only requires handling N>=2\n        pass\n\n    # Solve the linear system\n    U_vec = np.linalg.solve(A, F)\n\n    # Combine with Dirichlet BC to form full solution\n    U_solution = np.concatenate(([alpha], U_vec))\n\n    return U_solution, x_grid\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3228073"}]}