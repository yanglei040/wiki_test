{"hands_on_practices": [{"introduction": "Before we can appreciate the full power and elegance of Horner's method, we must first become comfortable with its fundamental mechanics. This first exercise invites you to do just that by manually tracing the algorithm's execution for a simple cubic polynomial. By calculating each intermediate value in the sequence [@problem_id:2177814], you will gain a concrete, step-by-step understanding of how the nested evaluation structure efficiently arrives at the final result.", "problem": "A polynomial of degree $n$ is given by the general form $P(x) = \\sum_{i=0}^{n} a_i x^i = a_n x^n + a_{n-1} x^{n-1} + \\dots + a_1 x + a_0$. A computationally efficient method for evaluating this polynomial at a specific point $x=c$ involves generating a sequence of intermediate values, often referred to as Horner's method. This sequence, denoted by $y_0, y_1, \\dots, y_n$, is constructed using the following recurrence relation:\n- $y_0 = a_n$\n- $y_k = y_{k-1} \\cdot c + a_{n-k}$ for $k = 1, 2, \\dots, n$.\n\nThe final term of this sequence, $y_n$, is the value of the polynomial at $c$, i.e., $y_n = P(c)$.\n\nFor the polynomial $P(x) = 4x^3 - 2x^2 + 5x - 1$, determine the complete sequence of values $(y_0, y_1, y_2, y_3)$ that are generated by this method when evaluating $P(x)$ at the point $x=2$.", "solution": "We are given $P(x) = 4x^{3} - 2x^{2} + 5x - 1$ with degree $n=3$. Thus the coefficients are $a_{3} = 4$, $a_{2} = -2$, $a_{1} = 5$, and $a_{0} = -1$. We evaluate at $c=2$ using Hornerâ€™s recurrence:\n$$\ny_{0} = a_{3} = 4,\n$$\nand for $k=1,2,3$,\n$$\ny_{k} = y_{k-1}\\cdot c + a_{3-k}.\n$$\n\nCompute step by step:\n$$\ny_{1} = y_{0}\\cdot 2 + a_{2} = 4\\cdot 2 + (-2) = 8 - 2 = 6,\n$$\n$$\ny_{2} = y_{1}\\cdot 2 + a_{1} = 6\\cdot 2 + 5 = 12 + 5 = 17,\n$$\n$$\ny_{3} = y_{2}\\cdot 2 + a_{0} = 17\\cdot 2 + (-1) = 34 - 1 = 33.\n$$\n\nTherefore, the sequence is $(y_{0}, y_{1}, y_{2}, y_{3}) = (4, 6, 17, 33)$, and $y_{3} = P(2) = 33$.", "answer": "$$\\boxed{\\begin{pmatrix} 4 & 6 & 17 & 33 \\end{pmatrix}}$$", "id": "2177814"}, {"introduction": "The principle of nested evaluation at the heart of Horner's method is more general than it may first appear. This practice challenges you to extend the concept from a single variable to a bivariate polynomial, $P(x,y)$. By reframing the polynomial and applying the method recursively, you will discover how to build an efficient evaluation algorithm for higher dimensions, a common task in fields like computer graphics and data fitting [@problem_id:3239322].", "problem": "You are given a bivariate polynomial defined by the map from indices to coefficients. Let $P(x,y)$ be the finite sum\n$$\nP(x,y) = \\sum_{i=0}^{m} \\sum_{j=0}^{n} a_{ij} \\, x^{i} y^{j},\n$$\nwhere $a_{ij} \\in \\mathbb{R}$ and $(m,n)$ are nonnegative integers. Starting only from the definition of a polynomial and the principle of repeated factoring to avoid explicit exponentiation, derive an algorithm that evaluates $P(x,y)$ by applying a univariate linear-time scheme to one variable to obtain intermediate coefficients, followed by applying the same scheme to the other variable. Then implement this algorithm as a program that evaluates $P(x,y)$ for several specified inputs.\n\nRequirements and constraints:\n- Base your derivation on the fundamental definition of a polynomial and the idea of grouping like powers to avoid explicit computation of $x^i$ and $y^j$ via repeated multiplication. You must organize the computation by first treating $P(x,y)$ as a sum over one variable with coefficients that are polynomials in the other variable, and then evaluate these polynomials in a sequence that uses only additions and multiplications.\n- Implement a function that accepts a rectangular array of real coefficients $(a_{ij})$ with the convention that the row index $i$ corresponds to the power of $x$ and the column index $j$ corresponds to the power of $y$. This means that the entry at row $i$ and column $j$ equals $a_{ij}$, the coefficient of $x^{i} y^{j}$.\n- Ensure numerical stability by avoiding explicit exponentiation of $x$ or $y$ and using only additions and multiplications in a nested evaluation order.\n- Your implementation must use a nested evaluation order that first evaluates in $y$ for each fixed $i$ to produce intermediate values $b_i(y)$, and then evaluates in $x$ using the $b_i(y)$ as coefficients.\n\nTest suite:\n- Use the following five test cases. For each test case, the coefficient matrix is specified, along with the evaluation point $(x,y)$. Here, matrices are written row by row.\n  - Test case $1$: \n    $A^{(1)} = \\begin{bmatrix} 3 & 4 & 0 \\\\ 2 & 5 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$, $x^{(1)} = 1.5$, $y^{(1)} = -0.75$.\n  - Test case $2$:\n    $A^{(2)} = \\begin{bmatrix} 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$, $x^{(2)} = -2.3$, $y^{(2)} = 4.1$.\n  - Test case $3$:\n    $A^{(3)} = \\begin{bmatrix} 1 & 2 & 3 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$, $x^{(3)} = 0$, $y^{(3)} = 2$.\n  - Test case $4$:\n    $A^{(4)} = \\begin{bmatrix} 1 & -1 \\\\ 2 & 0.5 \\\\ -3 & 4 \\end{bmatrix}$, $x^{(4)} = 2$, $y^{(4)} = 0$.\n  - Test case $5$:\n    $A^{(5)} = \\begin{bmatrix} 0.5 & -1 & 0.25 & -0.125 \\\\ 2 & 0 & -0.5 & 0 \\\\ 0 & 1.5 & 0 & -0.25 \\\\ -1 & 0 & 0 & 0.0625 \\end{bmatrix}$, $x^{(5)} = 0.75$, $y^{(5)} = -1.2$.\n\nInput and output specification:\n- There is no input to read. Hard-code the test suite specified above in your program.\n- Your program must evaluate $P(x,y)$ for each of the above test cases using the nested evaluation order described.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Round each numerical result to $10$ decimal places using standard rounding to nearest, with ties to the nearest even representable decimal if applicable. For example, the format must be $[r_1,r_2,r_3,r_4,r_5]$, where each $r_k$ is rounded to $10$ decimal places.\n- No physical units and no angles are involved in this problem.\n\nDeliverables:\n- Provide a complete, runnable program that implements the described algorithm and prints the results for the test suite in the exact format specified above. The final line printed must be exactly the single list described and must not contain any additional text.", "solution": "The problem requires the derivation and implementation of an efficient algorithm for evaluating a bivariate polynomial, $P(x,y)$, defined as:\n$$\nP(x,y) = \\sum_{i=0}^{m} \\sum_{j=0}^{n} a_{ij} \\, x^{i} y^{j}\n$$\nThe derivation must be based on the principle of repeated factoring, analogous to the univariate Horner's method, to avoid costly and potentially unstable explicit computations of powers $x^i$ and $y^j$. The algorithm must follow a specific nested evaluation order: first with respect to $y$, then with respect to $x$.\n\nLet us begin with the given definition of the polynomial. The core idea is to change the order of summation and group terms. The problem specifies treating $P(x,y)$ as a polynomial in one variable, say $x$, whose coefficients are themselves polynomials in the other variable, $y$. We can rewrite the double summation by factoring out the powers of $x$:\n$$\nP(x,y) = \\sum_{i=0}^{m} \\left( \\sum_{j=0}^{n} a_{ij} y^j \\right) x^i\n$$\nThis expression represents $P(x,y)$ as a polynomial in the variable $x$. Let us define the term in the parenthesis, which is a polynomial in $y$ for a fixed index $i$, as $b_i(y)$:\n$$\nb_i(y) = \\sum_{j=0}^{n} a_{ij} y^j = a_{i0} + a_{i1}y + a_{i2}y^2 + \\dots + a_{in}y^n\n$$\nFor each integer $i$ from $0$ to $m$, $b_i(y)$ is a univariate polynomial in $y$. The coefficients of $b_i(y)$ are given by the $i$-th row of the coefficient matrix $A$, which are $(a_{i0}, a_{i1}, \\dots, a_{in})$.\n\nWith this definition, the original polynomial $P(x,y)$ can be expressed as:\n$$\nP(x,y) = \\sum_{i=0}^{m} b_i(y) x^i = b_0(y) + b_1(y)x^1 + b_2(y)x^2 + \\dots + b_m(y)x^m\n$$\nThis structure suggests a two-stage evaluation process for a given point $(x,y)$.\n\n**Stage 1: Evaluation of Intermediate Coefficients**\n\nFirst, for the given value of $y$, we must compute the numerical values of the coefficients $b_0(y), b_1(y), \\dots, b_m(y)$. Each $b_i(y)$ is a univariate polynomial, which can be evaluated efficiently using the univariate Horner's method. Horner's method (also known as nested multiplication) evaluates a polynomial $Q(z) = c_k z^k + c_{k-1} z^{k-1} + \\dots + c_1 z + c_0$ by factoring it as:\n$$\nQ(z) = c_0 + z(c_1 + z(c_2 + \\dots + z(c_{k-1} + c_k z)\\dots))\n$$\nAlgorithmically, this is computed by initializing a result with the highest-degree coefficient $c_k$ and iterating downwards:\n`result` $\\leftarrow$ $c_k$\nFor $l$ from $k-1$ down to $0$:\n    `result` $\\leftarrow$ `result` $\\times z + c_l$\n\nFor our problem, to evaluate $b_i(y) = \\sum_{j=0}^{n} a_{ij} y^j$, we apply this method with variable $y$ and coefficients $(a_{i0}, a_{i1}, \\dots, a_{in})$. The coefficients of decreasing powers of $y$ are $(a_{in}, a_{i,n-1}, \\dots, a_{i0})$. Let $B_i$ denote the computed numerical value $b_i(y)$. We perform this evaluation for each $i$ from $0$ to $m$, yielding a set of intermediate numerical coefficients $\\{B_0, B_1, \\dots, B_m\\}$.\n\n**Stage 2: Final Polynomial Evaluation**\n\nOnce the intermediate coefficients $B_i = b_i(y)$ are computed, the problem reduces to evaluating a new univariate polynomial in $x$:\n$$\nP(x,y) = \\sum_{i=0}^{m} B_i x^i = B_0 + B_1 x + B_2 x^2 + \\dots + B_m x^m\n$$\nWe again apply Horner's method, this time to the variable $x$ and the just-computed coefficients $\\{B_0, B_1, \\dots, B_m\\}$. The coefficients corresponding to decreasing powers of $x$ are $(B_m, B_{m-1}, \\dots, B_0)$. The evaluation proceeds as:\n`final_result` $\\leftarrow$ $B_m$\nFor $i$ from $m-1$ down to $0$:\n    `final_result` $\\leftarrow$ `final_result` $\\times x + B_i$\n\nThe final value of `final_result` is the value of $P(x,y)$.\n\n**Summary of the Algorithm**\n\nThe complete algorithm, adhering to the specified nested evaluation order, is as follows:\n\n1.  Input: An $(m+1) \\times (n+1)$ coefficient matrix $A$, where $A_{ij} = a_{ij}$, and a point $(x,y)$.\n2.  Initialize an array `B` of size $m+1$ to store the intermediate coefficients.\n3.  For each row index $i$ from $0$ to $m$:\n    a. Extract the $i$-th row of $A$, which contains the coefficients $(a_{i0}, a_{i1}, \\dots, a_{in})$ of the polynomial $b_i(y)$.\n    b. Evaluate $b_i(y)$ at the given $y$ using Horner's method.\n    c. Store the result in `B[i]`.\n4.  The array `B` now holds the numerical coefficients $(B_0, B_1, \\dots, B_m)$ for the polynomial in $x$.\n5.  Evaluate the polynomial $\\sum_{i=0}^{m} B_i x^i$ at the given $x$ using Horner's method.\n6.  The result of this second evaluation is the final value of $P(x,y)$.\n\nThis procedure uses only additions and multiplications in a nested fashion, completely avoiding explicit exponentiation and thus ensuring better numerical stability and efficiency, with a time complexity of $O(mn)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef evaluate_bivariate_poly(A, x, y):\n    \"\"\"\n    Evaluates a bivariate polynomial P(x, y) using a nested Horner's scheme.\n\n    The polynomial is defined as P(x,y) = sum_{i=0 to m} sum_{j=0 to n} a_ij * x^i * y^j.\n    The coefficient a_ij is located at A[i, j].\n\n    The evaluation first computes intermediate coefficients B_i(y) for each power of x,\n    and then evaluates the final polynomial in x with these coefficients.\n\n    Args:\n        A (np.ndarray): A 2D numpy array of shape (m+1, n+1) containing the\n                        coefficients a_ij. A[i, j] is the coefficient of x^i * y^j.\n        x (float): The value of x at which to evaluate the polynomial.\n        y (float): The value of y at which to evaluate the polynomial.\n\n    Returns:\n        float: The value of P(x, y).\n    \"\"\"\n    # The number of rows (m+1) corresponds to the degree of x plus 1.\n    # The number of columns (n+1) corresponds to the degree of y plus 1.\n    m_plus_1, n_plus_1 = A.shape\n\n    # Stage 1: Evaluate intermediate polynomials in y for each row i.\n    # Each row A[i, :] contains the coefficients (a_i0, a_i1, ..., a_in)\n    # for a polynomial in y: b_i(y) = a_i0 + a_i1*y + ... + a_in*y^n.\n    # np.polyval expects coefficients for decreasing powers, so we reverse each row.\n    B = []\n    for i in range(m_plus_1):\n        row_coeffs = A[i, :]\n        # Coefficients for np.polyval: [a_in, a_i(n-1), ..., a_i0]\n        b_i_y = np.polyval(row_coeffs[::-1], y)\n        B.append(b_i_y)\n\n    # Stage 2: Evaluate the final polynomial in x.\n    # The coefficients are the computed B_i values: [B_0, B_1, ..., B_m].\n    # This corresponds to the polynomial P(x,y) = B_0 + B_1*x + ... + B_m*x^m.\n    # np.polyval expects coefficients for decreasing powers of x, so we reverse B.\n    # Coefficients for np.polyval: [B_m, B_(m-1), ..., B_0]\n    final_value = np.polyval(B[::-1], x)\n    \n    return final_value\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the evaluation for each case, and prints\n    the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([[3, 4, 0], [2, 5, 0], [0, 0, 1]], dtype=float), 1.5, -0.75),\n        (np.array([[0, 0, 0], [0, 0, 0]], dtype=float), -2.3, 4.1),\n        (np.array([[1, 2, 3], [0, 0, 0], [0, 0, 0]], dtype=float), 0, 2),\n        (np.array([[1, -1], [2, 0.5], [-3, 4]], dtype=float), 2, 0),\n        (np.array([\n            [0.5, -1, 0.25, -0.125],\n            [2, 0, -0.5, 0],\n            [0, 1.5, 0, -0.25],\n            [-1, 0, 0, 0.0625]\n        ], dtype=float), 0.75, -1.2)\n    ]\n\n    results = []\n    for A, x, y in test_cases:\n        result = evaluate_bivariate_poly(A, x, y)\n        # Round the result to 10 decimal places.\n        rounded_result = round(result, 10)\n        results.append(str(rounded_result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "3239322"}, {"introduction": "An algorithm's efficiency is only one part of its story; its numerical stability is equally critical. This final practice serves as a crucial cautionary tale, exploring a scenario where Horner's method, despite its elegance, suffers from catastrophic cancellation. By analyzing the evaluation of $p_n(x) = (x-1)^n$ [@problem_id:3239339], you will learn to identify conditions that can lead to a severe loss of precision, a vital skill for any serious practitioner of scientific computing.", "problem": "Consider the real polynomial $p_{n}(x) = (x-1)^{n}$ with integer $n \\geq 2$. Suppose $p_{n}(x)$ is represented in the monomial basis, so that $p_{n}(x) = \\sum_{k=0}^{n} a_{k} x^{k}$ with coefficients $a_{k} \\in \\mathbb{R}$ obtained by expanding $(x-1)^{n}$. The polynomial is to be evaluated using Horner's method in a standard floating-point system with base $\\beta$, precision $t$, and unit roundoff $u$, assuming no overflow or underflow and the usual rounding model for each arithmetic operation.\n\nUsing only foundational facts about the binomial theorem, the standard model of floating-point rounding, and the structure of Horner's scheme (one multiplication and one addition per stage), analyze when the evaluation of $p_{n}(x)$ in this monomial representation is most vulnerable to catastrophic cancellation. Concretely, justify why the vulnerability of Horner's method to cancellation in this setting is governed by the ratio of a sum of magnitudes of basis terms to the magnitude of the polynomial value, and determine the real number $x$ at which this ratio becomes infinite for $p_{n}(x) = (x-1)^{n}$. Provide your final answer as a single real number. No rounding is required.", "solution": "The problem asks for an analysis of the vulnerability of Horner's method to catastrophic cancellation when evaluating the polynomial $p_{n}(x) = (x-1)^{n}$ in its monomial basis representation, $p_{n}(x) = \\sum_{k=0}^{n} a_{k} x^{k}$.\n\nFirst, we justify why the vulnerability to cancellation is governed by the specified ratio. Horner's method evaluates $p_n(x)$ using the recurrence:\n$y_n = a_n$\n$y_k = y_{k+1}x + a_k$ for $k = n-1, n-2, \\dots, 0$.\nThe final result is $y_0 = p_n(x)$.\n\nIn a floating-point system, each arithmetic operation introduces a small relative error. Let $\\tilde{y}_k$ denote the computed value of $y_k$. The computation of each step in floating-point arithmetic can be modeled as:\n$\\tilde{y}_k = \\text{fl}(\\tilde{y}_{k+1}x + a_k)$\nUsing the standard model of floating-point arithmetic, where $u$ is the unit roundoff, an operation `op` satisfies $\\text{fl}(c \\text{ op } d) = (c \\text{ op } d)(1+\\delta)$ with $|\\delta| \\leq u$. The recurrence for the computed values is:\n$\\tilde{y}_k = (\\tilde{y}_{k+1}x(1+\\delta_{k,m}) + a_k)(1+\\delta_{k,a})$\nwhere $|\\delta_{k,m}| \\leq u$ and $|\\delta_{k,a}| \\leq u$ are the relative errors from the multiplication and addition at stage $k$.\n\nA forward error analysis yields a bound on the absolute error of the final computed value, $|\\tilde{y}_0 - p_n(x)|$. A well-established result for Horner's method provides the bound:\n$$|\\tilde{y}_0 - p_n(x)| \\leq \\gamma_{2n} \\sum_{k=0}^{n} |a_k| |x|^k$$\nwhere $\\gamma_{m} = \\frac{mu}{1-mu}$, which for small $m u$ is approximately $m u$. The factor of $2n$ arises from the $n$ multiplications and $n$ additions.\n\nCatastrophic cancellation is characterized by a large relative error in the final result. The relative error is given by $\\frac{|\\tilde{y}_0 - p_n(x)|}{|p_n(x)|}$. Using the bound above, we can bound the relative error:\n$$\\frac{|\\tilde{y}_0 - p_n(x)|}{|p_n(x)|} \\leq \\gamma_{2n} \\frac{\\sum_{k=0}^{n} |a_k| |x|^k}{|p_n(x)|}$$\nThis inequality shows that the relative error is amplified by the factor $\\frac{\\sum_{k=0}^{n} |a_k| |x|^k}{|p_n(x)|}$. This ratio is the condition number for the polynomial evaluation with respect to perturbations in the coefficients, and it governs the loss of precision. The numerator, $\\sum_{k=0}^{n} |a_k| |x|^k = \\sum_{k=0}^{n} |a_k x^k|$, is the sum of the magnitudes of the terms in the monomial basis expansion. When this sum is much larger than the magnitude of the final value, $|p_n(x)|$, it signifies that the final result was obtained by the cancellation of large intermediate terms. In such a scenario, the rounding errors, which are proportional to the magnitude of these intermediate terms, do not cancel and can dominate the small final result, leading to a large relative error. This is the definition of catastrophic cancellation. Therefore, the vulnerability of the evaluation is governed by this ratio.\n\nNext, we find the real number $x$ for which this ratio becomes infinite for the polynomial $p_n(x) = (x-1)^n$ with $n \\geq 2$.\nThe monomial expansion of $p_n(x)$ is found using the binomial theorem:\n$$p_n(x) = (x-1)^n = \\sum_{k=0}^{n} \\binom{n}{k} x^k (-1)^{n-k}$$\nThe coefficients are $a_k = \\binom{n}{k}(-1)^{n-k}$.\n\nThe ratio, which we denote by $R(x)$, is:\n$$R(x) = \\frac{\\sum_{k=0}^{n} |a_k| |x|^k}{|p_n(x)|}$$\nLet's analyze the numerator and the denominator separately.\nThe denominator is simply the magnitude of the polynomial:\n$$|p_n(x)| = |(x-1)^n| = |x-1|^n$$\nThe numerator is the sum of the magnitudes of the terms:\n$$\\sum_{k=0}^{n} |a_k| |x|^k = \\sum_{k=0}^{n} \\left|\\binom{n}{k}(-1)^{n-k}\\right| |x|^k = \\sum_{k=0}^{n} \\binom{n}{k} |x|^k$$\nThis sum is the binomial expansion of $(1+|x|)^n$.\n\nSubstituting these into the expression for the ratio $R(x)$:\n$$R(x) = \\frac{(1+|x|)^n}{|x-1|^n} = \\left(\\frac{1+|x|}{|x-1|}\\right)^n$$\nWe are looking for the real number $x$ at which $R(x)$ becomes infinite. This occurs when the denominator of the fraction goes to zero while the numerator remains non-zero.\nThe denominator is $|x-1|^n$. This term is equal to $0$ if and only if $|x-1| = 0$, which implies $x-1 = 0$. Thus, the denominator is zero only at $x=1$.\n\nNow, we must check the value of the numerator at $x=1$. The numerator is $(1+|x|)^n$.\nAt $x=1$, the numerator evaluates to:\n$$(1+|1|)^n = (1+1)^n = 2^n$$\nAccording to the problem statement, $n \\geq 2$. For any such integer $n$, $2^n$ is a positive, non-zero number (specifically, $2^n \\geq 4$).\n\nSince the numerator is non-zero ($2^n$) and the denominator is zero at $x=1$, the ratio $R(x)$ becomes infinite at this point. This corresponds to the case of maximum vulnerability to catastrophic cancellation, where the exact value of the polynomial is $p_n(1) = (1-1)^n = 0$, but the sum of the absolute values of the coefficients is $\\sum_{k=0}^n \\binom{n}{k} = 2^n$, indicating that the evaluation involves summing numbers of significant magnitude to obtain a zero result.\nThe real number at which the ratio becomes infinite is $1$.", "answer": "$$\\boxed{1}$$", "id": "3239339"}]}