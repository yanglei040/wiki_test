{"hands_on_practices": [{"introduction": "We begin by exploring why the specific structure of the velocity Verlet algorithm is so critical for its success in long-term simulations. This exercise [@problem_id:2466845] challenges you to analyze a seemingly plausible but structurally inconsistent integrator, revealing how subtle changes can lead to a dramatic failure in energy conservation. By understanding what goes wrong, you will gain a deeper appreciation for the geometric properties of symplecticity and time-reversibility that underpin the Verlet family's stability.", "problem": "Consider a one-dimensional particle of mass $m$ moving in a smooth, conservative potential $V(x)$ with force $F(x)=-\\frac{dV}{dx}$. The total energy is $H(x,v)=\\frac{1}{2} m v^{2}+V(x)$. In a standard velocity Verlet integrator with time step $\\Delta t$, the updates are made in a symmetric sequence of a half-step velocity update, a full-step position update, and a second half-step velocity update, all using forces consistent with the same potential evaluation at the corresponding positions.\n\nSuppose instead that you implement the following scheme in which the forces used in the position and velocity updates are not used in a symmetric, consistent way:\n- Update the position using the force at the beginning of the step:\n$$x_{n+1}=x_{n}+\\Delta t\\, v_{n}+\\frac{\\Delta t^{2}}{2 m}\\,F(x_{n}).$$\n- Update the velocity using only the force at the end of the step (no half-step splitting):\n$$v_{n+1}=v_{n}+\\frac{\\Delta t}{m}\\,F(x_{n+1}).$$\n\nAssume $V(x)$ is smooth and the step size $\\Delta t$ is chosen small enough that the scheme is numerically stable over many steps for the system under study. Compared to the standard velocity Verlet method, which maintains near-constant energy with bounded oscillations over long times, which statement best describes the long-time behavior of the total energy $H(x,v)$ under the above inconsistent-force update?\n\nA. The total energy remains nearly constant with small, bounded oscillations of order $O(\\Delta t^{2})$ for arbitrarily long simulation times, as in a symplectic, time-reversible scheme.\n\nB. The total energy exhibits a secular drift over long times, typically monotonic on average (either increasing or decreasing depending on the system and $\\Delta t$), because the scheme is neither symplectic nor time-reversible.\n\nC. The total energy is exactly conserved step-by-step for any $\\Delta t$ whenever $F(x)$ is conservative, because the force derives from a potential.\n\nD. The total energy performs an unbiased random walk about the exact value with no systematic drift; its mean stays constant while its variance grows like $O(t)$ solely due to time-discretization noise.", "solution": "The problem statement must be validated before a solution is attempted.\n\n### Step 1: Extract Givens\n- A one-dimensional particle of mass $m$ moves in a smooth, conservative potential $V(x)$.\n- Force: $F(x) = -\\frac{dV}{dx}$.\n- Total energy: $H(x,v)=\\frac{1}{2} m v^{2}+V(x)$.\n- A proposed numerical integration scheme with time step $\\Delta t$:\n  1. Position update: $x_{n+1}=x_{n}+\\Delta t\\, v_{n}+\\frac{\\Delta t^{2}}{2 m}\\,F(x_{n})$.\n  2. Velocity update: $v_{n+1}=v_{n}+\\frac{\\Delta t}{m}\\,F(x_{n+1})$.\n- Assumptions: $V(x)$ is smooth, and $\\Delta t$ is small enough for numerical stability.\n- Question: Describe the long-time behavior of the total energy $H(x,v)$ under this scheme.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem is set in the context of classical mechanics and numerical integration methods (specifically, for molecular dynamics), which is a standard topic in computational physics and chemistry. The equations are well-defined. The problem is scientifically sound.\n- **Well-Posed:** The integration scheme is explicitly defined. The question asks for the long-term behavior of a specific quantity (energy), which can be analyzed using the theory of numerical methods for differential equations. The problem is well-posed.\n- **Objective:** The problem is stated using precise mathematical language, free from subjectivity or ambiguity.\n\n### Step 3: Verdict and Action\nThe problem statement is scientifically sound, well-posed, and objective. It is **valid**. A solution will be derived.\n\nThe core of the problem is to determine the long-term energy conservation properties of the given numerical scheme. The excellent long-term energy stability of methods like the standard velocity Verlet algorithm stems from their geometric properties, namely being **symplectic** and **time-reversible**. We must investigate whether the proposed scheme possesses these properties.\n\nThe mapping from the state at time $t_n$, $(x_n, v_n)$, to the state at time $t_{n+1}$, $(x_{n+1}, v_{n+1})$, is given by:\n$$x_{n+1} = x_n + \\Delta t \\, v_n + \\frac{\\Delta t^2}{2m} F(x_n)$$\n$$v_{n+1} = v_n + \\frac{\\Delta t}{m} F(x_{n+1})$$\n\n**1. Analysis of Time-Reversibility**\nA scheme is time-reversible if, starting from $(x_{n+1}, v_{n+1})$ and evolving backward in time with a step $-\\Delta t$, we recover $(x_n, v_n)$. The backward step equations would be:\n$$x'_{n} = x_{n+1} - \\Delta t\\, v_{n+1} + \\frac{(-\\Delta t)^2}{2m} F(x_{n+1}) = x_{n+1} - \\Delta t\\, v_{n+1} + \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\n$$v'_{n} = v_{n+1} + \\frac{-\\Delta t}{m} F(x'_{n})$$\nWe check if $x'_n = x_n$. Substitute the forward expression for $v_{n+1}$:\n$$x'_{n} = x_{n+1} - \\Delta t \\left( v_n + \\frac{\\Delta t}{m} F(x_{n+1}) \\right) + \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\n$$x'_{n} = x_{n+1} - \\Delta t v_n - \\frac{\\Delta t^2}{m} F(x_{n+1}) + \\frac{\\Delta t^2}{2m} F(x_{n+1}) = x_{n+1} - \\Delta t v_n - \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\nNow substitute the forward expression for $x_{n+1}$:\n$$x'_{n} = \\left( x_n + \\Delta t v_n + \\frac{\\Delta t^2}{2m} F(x_n) \\right) - \\Delta t v_n - \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\n$$x'_{n} = x_n + \\frac{\\Delta t^2}{2m} \\left( F(x_n) - F(x_{n+1}) \\right)$$\nSince $F(x_n) \\neq F(x_{n+1})$ in general, we have $x'_n \\neq x_n$. The scheme is **not time-reversible**.\n\n**2. Analysis of Symplecticity**\nA one-step numerical method for a Hamiltonian system is symplectic if the Jacobian of the map $(x_n, v_n) \\to (x_{n+1}, v_{n+1})$ has a determinant of exactly $1$. The Jacobian matrix is $J = \\begin{pmatrix} \\frac{\\partial x_{n+1}}{\\partial x_n} & \\frac{\\partial x_{n+1}}{\\partial v_n} \\\\ \\frac{\\partial v_{n+1}}{\\partial x_n} & \\frac{\\partial v_{n+1}}{\\partial v_n} \\end{pmatrix}$. Let $F'(x) = dF/dx$.\nThe partial derivatives are:\n$$\\frac{\\partial x_{n+1}}{\\partial x_n} = 1 + \\frac{\\Delta t^2}{2m} F'(x_n)$$\n$$\\frac{\\partial x_{n+1}}{\\partial v_n} = \\Delta t$$\nFor the derivatives of $v_{n+1}$, we must use the chain rule, as $v_{n+1}$ depends on $x_{n+1}$, which in turn depends on $(x_n, v_n)$.\n$$\\frac{\\partial v_{n+1}}{\\partial x_n} = \\frac{\\partial v_{n+1}}{\\partial x_{n+1}} \\frac{\\partial x_{n+1}}{\\partial x_n} = \\left(\\frac{\\Delta t}{m} F'(x_{n+1})\\right) \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right)$$\n$$\\frac{\\partial v_{n+1}}{\\partial v_n} = 1 + \\frac{\\partial v_{n+1}}{\\partial x_{n+1}} \\frac{\\partial x_{n+1}}{\\partial v_n} = 1 + \\left(\\frac{\\Delta t}{m} F'(x_{n+1})\\right) (\\Delta t) = 1 + \\frac{\\Delta t^2}{m} F'(x_{n+1})$$\nThe determinant is:\n$$\\det(J) = \\left(\\frac{\\partial x_{n+1}}{\\partial x_n}\\right)\\left(\\frac{\\partial v_{n+1}}{\\partial v_n}\\right) - \\left(\\frac{\\partial x_{n+1}}{\\partial v_n}\\right)\\left(\\frac{\\partial v_{n+1}}{\\partial x_n}\\right)$$\n$$\\det(J) = \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right)\\left(1 + \\frac{\\Delta t^2}{m} F'(x_{n+1})\\right) - (\\Delta t) \\left[ \\left(\\frac{\\Delta t}{m} F'(x_{n+1})\\right) \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right) \\right]$$\nFactoring out the common term $(1 + \\frac{\\Delta t^2}{2m} F'(x_n))$:\n$$\\det(J) = \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right) \\left[ \\left(1 + \\frac{\\Delta t^2}{m} F'(x_{n+1})\\right) - \\frac{\\Delta t^2}{m} F'(x_{n+1}) \\right]$$\n$$\\det(J) = \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right) [1] = 1 + \\frac{\\Delta t^2}{2m} F'(x_n)$$\nFor the scheme to be symplectic, $\\det(J)$ must be identically $1$. This is only true if $F'(x_n)=0$ (e.g., constant force) or $\\Delta t=0$, neither of which holds in general. Therefore, the scheme is **not symplectic**.\n\n**3. Consequence for Energy Conservation**\nSymplectic, time-reversible integrators like velocity Verlet conserve a \"shadow Hamiltonian\" that is very close to the true Hamiltonian. This property ensures that the total energy error remains bounded over arbitrarily long simulation times, exhibiting small oscillations.\nNon-symplectic integrators, such as the one given, do not conserve a nearby shadow Hamiltonian. The fact that $\\det(J) \\neq 1$ means the algorithm does not preserve phase-space volume. This violation of the geometric structure of Hamiltonian dynamics leads to a systematic, accumulating error in the total energy. This long-term, non-oscillatory trend is known as a **secular drift**. The energy will typically drift monotically away from its initial value. The direction of the drift (increasing or decreasing) depends on the sign of the term $\\frac{\\Delta t^2}{2m}F'(x)$, which in turn depends on the potential. For example, in a simple harmonic oscillator, $V(x) = \\frac{1}{2}kx^2$, so $F(x) = -kx$ and $F'(x) = -k < 0$. In this case, $\\det(J) < 1$, leading to a systematic decrease in energy.\n\nThe conclusion is that the proposed scheme, being neither symplectic nor time-reversible, will exhibit poor long-term energy conservation characterized by a secular drift.\n\n### Option-by-Option Analysis\n\n**A. The total energy remains nearly constant with small, bounded oscillations of order $O(\\Delta t^{2})$ for arbitrarily long simulation times, as in a symplectic, time-reversible scheme.**\nThis describes the behavior of a symplectic integrator like velocity Verlet. As demonstrated above, the given scheme is not symplectic or time-reversible. Thus, it will not exhibit this favorable energy behavior.\nVerdict: **Incorrect**.\n\n**B. The total energy exhibits a secular drift over long times, typically monotonic on average (either increasing or decreasing depending on the system and $\\Delta t$), because the scheme is neither symplectic nor time-reversible.**\nThis statement accurately describes the consequence of a numerical integrator lacking symplecticity and time-reversibility when applied to a conservative system. Our analysis has confirmed that the scheme lacks these properties. Therefore, a secular drift in energy is the expected behavior.\nVerdict: **Correct**.\n\n**C. The total energy is exactly conserved step-by-step for any $\\Delta t$ whenever $F(x)$ is conservative, because the force derives from a potential.**\nThis is fundamentally incorrect. The conservative nature of the force guarantees energy conservation for the *continuous* physical system, not for its discrete numerical approximation. Most numerical integrators, including this one, introduce a discretization error at each step, causing the numerical energy to change. An explicit calculation of the energy change over one step, $\\Delta H = H_{n+1} - H_n$, shows it is non-zero and of order $O(\\Delta t^2)$.\nVerdict: **Incorrect**.\n\n**D. The total energy performs an unbiased random walk about the exact value with no systematic drift; its mean stays constant while its variance grows like $O(t)$ solely due to time-discretization noise.**\nThis is incorrect. The error introduced at each step is not random but systematic. The energy change per step, $\\Delta H_n$, has a non-zero average value for a typical trajectory. The accumulation of these systematic, one-directional errors leads to a secular drift, not an unbiased random walk. The mean of the energy error does not stay constant but drifts over time.\nVerdict: **Incorrect**.", "answer": "$$\\boxed{B}$$", "id": "2466845"}, {"introduction": "Real-world systems often involve non-conservative forces like friction or drag, which cause energy to dissipate. This practice [@problem_id:2466875] explores how to extend the velocity Verlet algorithm to include such forces. You will discover that incorporating dissipation fundamentally alters the algorithm's properties, breaking the time-reversibility and symplecticness that guarantee energy conservation in ideal systems.", "problem": "A single particle of mass $m$ moves in one spatial dimension in a conservative potential $U(x)$ with conservative force $F_{\\mathrm{c}}(x) = -\\,\\partial U/\\partial x$, and is additionally subject to linear viscous drag $F_{\\mathrm{drag}} = -\\,\\gamma v$, where $\\gamma > 0$ and $v = \\dot{x}$. The continuous equations of motion are $m\\,\\dot{v} = F_{\\mathrm{c}}(x) - \\gamma v$ and $\\dot{x} = v$.\n\nStarting from Newton’s second law and the definitions of velocity and acceleration, propose a consistent way to include the drag force into the velocity Verlet scheme by modifying the half-step velocity updates in a time step of size $\\Delta t$ in terms of the available quantities at the beginning and middle of the step. Then, reasoning from these equations and the work–energy relation, determine how this modification affects time-reversibility and the fate of the mechanical energy $E = \\tfrac{1}{2} m v^{2} + U(x)$ of the particle.\n\nSelect the single best statement describing the effect on time-reversibility and energy conservation:\n\nA. The modified algorithm remains exactly time-reversible and conserves the true mechanical energy for any $\\Delta t$, because the drag term is linear and can be absorbed into the half-step velocity updates.\n\nB. Adding linear drag destroys exact time-reversibility and symplecticness; the discrete mechanical energy decreases on average step by step, with a leading-order change per step proportional to $-\\gamma \\Delta t\\, v_{n+1/2}^{2}$, up to truncation error.\n\nC. Time-reversibility is broken, but the method remains symplectic and therefore conserves a shadow Hamiltonian, so the true mechanical energy merely oscillates without drift around a constant value.\n\nD. If the drag term is treated implicitly in the second half-step for the velocity, the method becomes exactly time-reversible and conserves mechanical energy in the deterministic limit.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- Mass of particle: $m$.\n- Spatial dimension: $1$.\n- Position: $x$.\n- Velocity: $v = \\dot{x}$.\n- Conservative potential: $U(x)$.\n- Conservative force: $F_{\\mathrm{c}}(x) = -\\,\\partial U/\\partial x$.\n- Linear viscous drag force: $F_{\\mathrm{drag}} = -\\,\\gamma v$, with $\\gamma > 0$.\n- Equation of motion: $m\\,\\dot{v} = F_{\\mathrm{c}}(x) - \\gamma v$.\n- Mechanical energy: $E = \\tfrac{1}{2} m v^{2} + U(x)$.\n- Task: Propose a modification to the velocity Verlet scheme to include drag by altering the half-step velocity updates.\n- Task: Analyze the effect of this modification on time-reversibility and the mechanical energy $E$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem describes damped harmonic motion in a general potential, a fundamental model in physics (Langevin dynamics without the stochastic term). The equation $m\\ddot{x} + \\gamma\\dot{x} + U'(x) = 0$ is a standard, well-established second-order ordinary differential equation. This is scientifically sound.\n- **Well-Posed:** The problem asks to devise a numerical integration scheme for a well-defined physical system and analyze its properties. The constraints implied by \"modifying the half-step velocity updates\" are specific enough to guide the derivation of a consistent algorithm. The question has a definite, verifiable answer based on the principles of numerical analysis and classical mechanics.\n- **Objective:** The language is formal and quantitative. All terms are defined. There is no subjectivity.\n- **Completeness and Consistency:** All necessary physical parameters and equations are provided. The problem is self-contained and free of contradictions.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be derived.\n\n### Derivation of the Modified Algorithm\n\nThe standard velocity Verlet algorithm for a conservative force $F_{\\mathrm{c}}(x)$ is given by:\n1.  Update velocity by a half-step: $v_{n+1/2} = v_n + \\frac{F_{\\mathrm{c}}(x_n)}{m} \\frac{\\Delta t}{2}$\n2.  Update position by a full step: $x_{n+1} = x_n + v_{n+1/2} \\Delta t$\n3.  Update velocity by the second half-step: $v_{n+1} = v_{n+1/2} + \\frac{F_{\\mathrm{c}}(x_{n+1})}{m} \\frac{\\Delta t}{2}$\n\nThe total equation of motion is $m\\dot{v} = F_{\\mathrm{c}}(x) - \\gamma v$. We must incorporate the drag term, $-\\gamma v$. The problem suggests modifying the velocity half-steps. A consistent, symmetric way to do this is to approximate the integral of the drag force over each half-step using the trapezoidal rule.\n\nFor the first half-step, from $t_n$ to $t_{n+1/2}$:\n$$v_{n+1/2} - v_n = \\int_{t_n}^{t_{n+1/2}} \\left( \\frac{F_{\\mathrm{c}}(x(t))}{m} - \\frac{\\gamma}{m}v(t) \\right) dt$$\nWe approximate this as:\n$$v_{n+1/2} - v_n \\approx \\frac{\\Delta t}{2} \\left( \\frac{F_{\\mathrm{c}}(x_n)}{m} - \\frac{\\gamma}{m} \\frac{v_n + v_{n+1/2}}{2} \\right)$$\nSolving for $v_{n+1/2}$:\n$$\\left(1 + \\frac{\\gamma \\Delta t}{4m} \\right) v_{n+1/2} = \\left(1 - \\frac{\\gamma \\Delta t}{4m} \\right) v_n + \\frac{F_{\\mathrm{c}}(x_n)}{m} \\frac{\\Delta t}{2}$$\n\nSimilarly, for the second half-step, from $t_{n+1/2}$ to $t_{n+1}$:\n$$v_{n+1} - v_{n+1/2} \\approx \\frac{\\Delta t}{2} \\left( \\frac{F_{\\mathrm{c}}(x_{n+1})}{m} - \\frac{\\gamma}{m} \\frac{v_{n+1/2} + v_{n+1}}{2} \\right)$$\nSolving for $v_{n+1}$:\n$$\\left(1 + \\frac{\\gamma \\Delta t}{4m} \\right) v_{n+1} = \\left(1 - \\frac{\\gamma \\Delta t}{4m} \\right) v_{n+1/2} + \\frac{F_{\\mathrm{c}}(x_{n+1})}{m} \\frac{\\Delta t}{2}$$\n\nThis defines a consistent, symmetric algorithm. Let's introduce constants for clarity:\n$$c_1 = \\frac{1 - \\gamma \\Delta t / (4m)}{1 + \\gamma \\Delta t / (4m)}$$\n$$c_2 = \\frac{\\Delta t / (2m)}{1 + \\gamma \\Delta t / (4m)}$$\nThe modified velocity Verlet algorithm is:\n1.  $v_{n+1/2} = c_1 v_n + c_2 F_{\\mathrm{c}}(x_n)$\n2.  $x_{n+1} = x_n + v_{n+1/2} \\Delta t$\n3.  $v_{n+1} = c_1 v_{n+1/2} + c_2 F_{\\mathrm{c}}(x_{n+1})$\n\n### Analysis of Time-Reversibility\n\nA dynamical system is time-reversible if its equations of motion are invariant under the transformation $t \\to -t$, $x \\to x$, and $v \\to -v$.\nThe conservative force $F_{\\mathrm{c}}(x) = -U'(x)$ is invariant under this transformation.\nThe drag force $F_{\\mathrm{drag}} = -\\gamma v$ is not:\n$$-\\gamma v \\xrightarrow{T} -\\gamma(-v) = +\\gamma v$$\nThe transformed equation of motion becomes $m\\,\\dot{v} = F_{\\mathrm{c}}(x) + \\gamma v$, which describes a system with anti-drag that gains energy from its environment. This is a fundamentally different physical system. Since the underlying continuous dynamics are not time-reversible, any consistent numerical integrator that converges to the correct solution as $\\Delta t \\to 0$ cannot be exactly time-reversible for finite $\\Delta t$. The presence of the dissipative drag force irrevocably breaks time-reversibility.\n\nFurthermore, a system governed by Hamiltonian dynamics has a phase-space flow that is symplectic (preserves the symplectic two-form, which implies conservation of phase-space volume). The force $F(x,v) = F_c(x) - \\gamma v$ cannot be derived from a Hamiltonian, as $\\partial F/\\partial x \\neq -\\partial(m\\dot{x})/\\partial p_x$ in general and the flow is contractile ($\\nabla \\cdot (v, F/m) = \\partial_v(F/m) = -\\gamma/m < 0$). Thus, the dynamics are not symplectic.\n\n### Analysis of Energy Conservation\n\nThe rate of change of the mechanical energy $E = \\frac{1}{2}mv^2 + U(x)$ is given by:\n$$\\frac{dE}{dt} = \\frac{d}{dt}\\left(\\frac{1}{2}mv^2\\right) + \\frac{d}{dt}\\left(U(x)\\right) = mv\\frac{dv}{dt} + \\frac{dU}{dx}\\frac{dx}{dt}$$\nUsing $v = dx/dt$, $F_{\\mathrm{c}} = -dU/dx$, and $m\\dot{v} = m(dv/dt) = F_{\\mathrm{c}} - \\gamma v$:\n$$\\frac{dE}{dt} = v(m\\dot{v}) - F_{\\mathrm{c}}v = v(F_{\\mathrm{c}} - \\gamma v) - F_{\\mathrm{c}}v = F_{\\mathrm{c}}v - \\gamma v^2 - F_{\\mathrm{c}}v = -\\gamma v^2$$\nSince $\\gamma > 0$ and $v^2 \\ge 0$, we have $dE/dt \\le 0$. The mechanical energy is continuously dissipated by the drag force, not conserved.\nA consistent numerical integrator must capture this essential physical behavior. Over a time step $\\Delta t$, the change in energy $\\Delta E$ will be approximately:\n$$\\Delta E = E_{n+1} - E_n = \\int_{t_n}^{t_{n+1}} \\frac{dE}{dt} dt = \\int_{t_n}^{t_{n+1}} (-\\gamma v(t)^2) dt$$\nUsing the midpoint rule for the integral, a good approximation is:\n$$\\Delta E \\approx -\\gamma v(t_{n+1/2})^2 \\Delta t = -\\gamma v_{n+1/2}^2 \\Delta t$$\nThe conservative part of the Verlet integrator introduces oscillatory errors in energy of order $\\mathcal{O}(\\Delta t^2)$ or higher, but no systematic drift. The drag term, however, introduces a systematic, non-oscillatory decrease in energy, with the leading-order contribution being proportional to $\\Delta t$. Thus, the discrete mechanical energy will decrease on average with each step.\n\n### Evaluation of Options\n\n**A. The modified algorithm remains exactly time-reversible and conserves the true mechanical energy for any $\\Delta t$, because the drag term is linear and can be absorbed into the half-step velocity updates.**\nThis statement is fundamentally flawed.\n- **Time-reversibility:** The physical system is not time-reversible due to dissipation. A consistent numerical scheme cannot be time-reversible.\n- **Energy Conservation:** The system continuously loses mechanical energy at a rate $-\\gamma v^2$. Exact energy conservation is impossible.\nTherefore, this option is **Incorrect**.\n\n**B. Adding linear drag destroys exact time-reversibility and symplecticness; the discrete mechanical energy decreases on average step by step, with a leading-order change per step proportional to $-\\gamma \\Delta t\\, v_{n+1/2}^{2}$, up to truncation error.**\nThis statement aligns perfectly with our analysis.\n- **Time-reversibility and Symplecticness:** It correctly states that both properties, which characterize Hamiltonian systems, are destroyed by the non-Hamiltonian drag force.\n- **Energy:** It correctly identifies that the mechanical energy decreases on average. The expression $-\\gamma \\Delta t\\, v_{n+1/2}^{2}$ is the correct leading-order approximation for the energy dissipated in one time step. The term \"up to truncation error\" properly accounts for higher-order errors from the discretization.\nTherefore, this option is **Correct**.\n\n**C. Time-reversibility is broken, but the method remains symplectic and therefore conserves a shadow Hamiltonian, so the true mechanical energy merely oscillates without drift around a constant value.**\nThis statement contains multiple errors.\n- **Symplecticness:** It is incorrect to claim the method remains symplectic. The drag force makes the system non-Hamiltonian, and the corresponding phase-space flow is not volume-preserving. A consistent integrator cannot be symplectic.\n- **Shadow Hamiltonian and Energy:** Because the method is not symplectic, it does not conserve a shadow Hamiltonian. The energy does not merely oscillate; it systematically decreases due to dissipation.\nTherefore, this option is **Incorrect**.\n\n**D. If the drag term is treated implicitly in the second half-step for the velocity, the method becomes exactly time-reversible and conserves mechanical energy in the deterministic limit.**\nThis statement is incorrect.\n- **Asymmetric Treatment:** Treating the drag term only in the second half-step would make the algorithm asymmetric, which by itself is sufficient to break time-reversibility.\n- **Physical Laws vs. Numerical Tricks:** No numerical scheme (implicit, explicit, or otherwise) can restore a conservation law or symmetry that is absent in the underlying physical equations of motion it is intended to solve. In the \"deterministic limit\" ($\\Delta t \\to 0$), the numerical solution must converge to the true, dissipative, non-time-reversible dynamics.\nTherefore, this option is **Incorrect**.", "answer": "$$\\boxed{B}$$", "id": "2466875"}, {"introduction": "Moving from simple particle translation to the full 3D rotation of molecules is a major step in building realistic simulations. This advanced practice [@problem_id:2466818] guides you through implementing a Verlet-style integrator for the rotational dynamics of a rigid diatomic molecule using quaternions. This exercise will solidify your understanding of applying Verlet principles to more complex coordinate systems and equations of motion, a cornerstone of modern molecular dynamics.", "problem": "Implement a program that advances the orientation of a rigid diatomic molecule modeled as a linear rigid rotor using a symplectic method from the Verlet family, representing orientation by unit quaternions. The diatomic is modeled as two point masses, with the bond axis fixed in the body frame along the body’s third principal axis. Let the body-frame unit vector of the bond be $\\mathbf{e}_3 = (0,0,1)$, and let the body-to-space orientation be represented by a unit quaternion $q = (q_0,q_1,q_2,q_3)$ in scalar-first convention. The body-frame angular velocity is $\\boldsymbol{\\omega}_{\\mathrm{b}} = (\\omega_1,\\omega_2,\\omega_3)$, constrained at all times to satisfy $\\omega_3 = 0$ (no spin about the bond axis). The space-frame bond direction is $\\mathbf{n}(t) = \\mathcal{R}(q(t))\\,\\mathbf{e}_3$, where $\\mathcal{R}(q)$ is the rotation corresponding to $q$. All quantities must be expressed in the International System of Units (SI).\n\nThe diatomic consists of two point masses $m_1$ and $m_2$ separated by a fixed bond length $L$. The reduced mass is $\\mu = \\dfrac{m_1 m_2}{m_1 + m_2}$, and the nonzero principal moments of inertia are equal and given by $I_\\perp = \\mu L^2$ about any axis perpendicular to the bond axis. The principal moment about the bond axis is zero; consequently, the allowed angular velocity must remain perpendicular to the bond axis, i.e., $\\omega_3 = 0$ for all times. The rotational kinetic energy is\n$$\nK(t) = \\tfrac{1}{2} I_\\perp \\left(\\omega_1(t)^2 + \\omega_2(t)^2\\right).\n$$\n\nIn the presence of a uniform, static electric field $\\mathbf{E}$, suppose the molecule has a permanent electric dipole of magnitude $p$ rigidly aligned with the bond axis, so that the space-frame dipole vector is $\\mathbf{p}(t) = p\\,\\mathbf{n}(t)$. The space-frame torque is then\n$$\n\\boldsymbol{\\tau}_{\\mathrm{s}}(t) = \\mathbf{p}(t) \\times \\mathbf{E} = p\\,\\mathbf{n}(t)\\times \\mathbf{E}.\n$$\nThe corresponding body-frame torque is $\\boldsymbol{\\tau}_{\\mathrm{b}}(t) = \\mathcal{R}(q(t))^\\top \\boldsymbol{\\tau}_{\\mathrm{s}}(t)$. The rotational equations of motion in the body frame are Euler’s equations\n$$\n\\mathbf{I}\\,\\dot{\\boldsymbol{\\omega}}_{\\mathrm{b}} = \\boldsymbol{\\tau}_{\\mathrm{b}} - \\boldsymbol{\\omega}_{\\mathrm{b}} \\times (\\mathbf{I}\\,\\boldsymbol{\\omega}_{\\mathrm{b}}),\n$$\nwith $\\mathbf{I} = \\mathrm{diag}(I_\\perp, I_\\perp, 0)$. Under the constraint $\\omega_3 = 0$ and when the torque has no component along the bond when expressed in the body frame, the third component of the angular acceleration vanishes, and the first two components satisfy\n$$\n\\dot{\\omega}_1 = \\dfrac{\\tau_{\\mathrm{b},1}}{I_\\perp},\\quad \\dot{\\omega}_2 = \\dfrac{\\tau_{\\mathrm{b},2}}{I_\\perp},\\quad \\dot{\\omega}_3 = 0.\n$$\n\nThe quaternion kinematics are given by\n$$\n\\dot{q} = \\tfrac{1}{2} \\, q \\otimes \\omega^\\flat,\n$$\nwhere $\\otimes$ denotes quaternion multiplication and $\\omega^\\flat = (0,\\omega_1,\\omega_2,\\omega_3)$ is the pure-imaginary quaternion associated with the body-frame angular velocity. The orientation quaternion must remain normalized at all times.\n\nYour program must:\n1. Implement a time integrator from the Verlet family for the rotational dynamics using quaternions, advancing $(q,\\boldsymbol{\\omega}_{\\mathrm{b}})$ with a fixed time step $\\Delta t$ over a specified number of steps $N$. The angular velocity must obey $\\omega_3=0$ at all times. The quaternion must be re-normalized to unit length after each update. The torque must be computed from the current orientation using the above expressions.\n2. For cases where $\\mathbf{E} \\neq \\mathbf{0}$ and $p \\neq 0$, treat the potential energy as $U(t) = -\\mathbf{p}(t)\\cdot\\mathbf{E} = -p\\,\\mathbf{n}(t)\\cdot \\mathbf{E}$.\n3. Compute the requested quantitative outputs for each test case below.\n\nUse the following test suite of three parameter sets. For each, initialize the orientation and angular velocity as specified, integrate for the given number of steps and time step, and compute the requested single scalar result.\n\nTest case A (torque-free, energy conservation “happy path”):\n- Parameters: $m_1 = m_2 = 3.0\\times 10^{-26}\\ \\mathrm{kg}$, $L = 1.0\\times 10^{-10}\\ \\mathrm{m}$, $\\mathbf{E} = (0,0,0)\\ \\mathrm{V/m}$, $p = 0\\ \\mathrm{C\\cdot m}$, $\\Delta t = 1.0\\times 10^{-15}\\ \\mathrm{s}$, $N = 2000$.\n- Initial conditions: $q(0) = \\left(\\tfrac{\\sqrt{2}}{2},\\,0,\\,-\\tfrac{\\sqrt{2}}{2},\\,0\\right)$ (so that $\\mathbf{n}(0)$ is along the space-frame $x$-axis), and $\\boldsymbol{\\omega}_{\\mathrm{b}}(0) = (0,\\,1.0\\times 10^{12},\\,0)\\ \\mathrm{rad/s}$.\n- Required output: the relative kinetic energy error at final time,\n$$\n\\varepsilon_K = \\dfrac{K(N\\Delta t) - K(0)}{K(0)},\n$$\nas a dimensionless float.\n\nTest case B (alignment under a field, general behavior):\n- Parameters: $m_1 = m_2 = 3.0\\times 10^{-26}\\ \\mathrm{kg}$, $L = 1.0\\times 10^{-10}\\ \\mathrm{m}$, $\\mathbf{E} = (0,0,1.0\\times 10^{7})\\ \\mathrm{V/m}$, $p = 3.33564\\times 10^{-30}\\ \\mathrm{C\\cdot m}$, $\\Delta t = 1.0\\times 10^{-15}\\ \\mathrm{s}$, $N = 10000$.\n- Initial conditions: $q(0) = \\left(\\tfrac{\\sqrt{2}}{2},\\,0,\\,-\\tfrac{\\sqrt{2}}{2},\\,0\\right)$ and $\\boldsymbol{\\omega}_{\\mathrm{b}}(0) = (0,\\,0,\\,0)\\ \\mathrm{rad/s}$.\n- Required output: the final polar angle in radians between the bond direction and the space-frame $z$-axis,\n$$\n\\theta_{\\mathrm{f}} = \\arccos\\!\\big(n_z(N\\Delta t)\\big),\n$$\nexpressed in radians as a float.\n\nTest case C (boundary condition: larger time step, torque-free, energy conservation under coarser resolution):\n- Parameters: $m_1 = m_2 = 3.0\\times 10^{-26}\\ \\mathrm{kg}$, $L = 1.0\\times 10^{-10}\\ \\mathrm{m}$, $\\mathbf{E} = (0,0,0)\\ \\mathrm{V/m}$, $p = 0\\ \\mathrm{C\\cdot m}$, $\\Delta t = 5.0\\times 10^{-15}\\ \\mathrm{s}$, $N = 400$.\n- Initial conditions: $q(0) = \\left(\\tfrac{\\sqrt{2}}{2},\\,0,\\,-\\tfrac{\\sqrt{2}}{2},\\,0\\right)$ and $\\boldsymbol{\\omega}_{\\mathrm{b}}(0) = (0,\\,1.0\\times 10^{12},\\,0)\\ \\mathrm{rad/s}$.\n- Required output: the relative kinetic energy error $\\varepsilon_K$ as defined above.\n\nFinal output format: Your program should produce a single line of output containing the three results in the order of Test case A, then Test case B, then Test case C, as a comma-separated list enclosed in square brackets. Each float must be rendered in scientific notation with $10$ significant digits. For example, an output with placeholders would look like\n$[a\\_1,a\\_2,a\\_3]$,\nwhere each $a_i$ is formatted like $x.xxxxxxxxx\\times 10^{y}$ (e.g., $1.2345678900\\mathrm{e}{-03}$). No other text should be printed.", "solution": "The problem statement has been rigorously analyzed and is deemed valid. It constitutes a well-posed initial value problem in classical rotational dynamics, is scientifically sound, and provides all necessary data and constraints for a unique solution. All parameters are physically consistent.\n\nThe task is to simulate the rotational dynamics of a linear rigid rotor using a time-reversible, symplectic integrator from the Verlet family. The state of the system is described by its orientation, represented by a unit quaternion $q(t)$, and its angular velocity in the body-fixed frame, $\\boldsymbol{\\omega}_{\\mathrm{b}}(t)$. We will implement a \"velocity Verlet\" algorithm adapted for rotational motion. This class of algorithms is known for excellent long-term energy conservation, which is a critical feature for molecular simulations.\n\nThe state variables at discrete time steps $t_n = n\\Delta t$ are the quaternion $q_n = q(t_n)$ and the body-frame angular velocity $\\boldsymbol{\\omega}_{\\mathrm{b},n} = \\boldsymbol{\\omega}_{\\mathrm{b}}(t_n)$. The body-frame angular acceleration is $\\boldsymbol{\\alpha}_{\\mathrm{b},n} = \\dot{\\boldsymbol{\\omega}}_{\\mathrm{b}}(t_n)$.\n\nThe equations of motion are given as:\n1. Rotational dynamics (Euler's equations, simplified for a linear rotor):\n$$\n\\dot{\\boldsymbol{\\omega}}_{\\mathrm{b}} = \\mathbf{I}^{-1} \\boldsymbol{\\tau}_{\\mathrm{b}}(q) \\equiv \\boldsymbol{\\alpha}_{\\mathrm{b}}(q)\n$$\nwhere $\\mathbf{I} = \\mathrm{diag}(I_\\perp, I_\\perp, 0)$ is the diagonal inertia tensor in the body frame, and the body-frame torque $\\boldsymbol{\\tau}_{\\mathrm{b}}$ depends on the orientation $q$. Specifically, for the components perpendicular to the bond axis, we have $\\dot{\\omega}_1 = \\tau_{\\mathrm{b},1}/I_\\perp$ and $\\dot{\\omega}_2 = \\tau_{\\mathrm{b},2}/I_\\perp$. We enforce the constraint $\\omega_3 = 0$ at all times.\n\n2. Kinematics of orientation:\n$$\n\\dot{q} = \\frac{1}{2} q \\otimes \\omega^\\flat_{\\mathrm{b}}\n$$\nwhere $\\otimes$ denotes quaternion multiplication and $\\omega^\\flat_{\\mathrm{b}} = (0, \\omega_1, \\omega_2, \\omega_3)$ is the pure quaternion representation of the angular velocity vector $\\boldsymbol{\\omega}_{\\mathrm{b}}$.\n\nThe velocity Verlet algorithm proceeds in the following steps to advance the state from time $t_n$ to $t_{n+1} = t_n + \\Delta t$:\n\nStep 1: Half-step update of angular velocity.\nThe angular velocity is advanced by a half time step using the current angular acceleration.\n$$\n\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2} = \\boldsymbol{\\omega}_{\\mathrm{b}, n} + \\boldsymbol{\\alpha}_{\\mathrm{b}, n} \\frac{\\Delta t}{2}\n$$\n\nStep 2: Full-step update of orientation.\nThe orientation quaternion is updated over the full time step $\\Delta t$ using the half-step angular velocity $\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}$. For a constant angular velocity $\\boldsymbol{\\omega}$, the solution to the kinematic equation is $q(t) = q(0) \\otimes \\exp(\\frac{t}{2}\\omega^\\flat)$. We approximate the evolution from $t_n$ to $t_{n+1}$ by assuming the constant angular velocity is $\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}$. The update is performed by multiplication with an incremental rotation quaternion $\\Delta q_n$:\n$$\nq_{n+1} = q_n \\otimes \\Delta q_n\n$$\nThe incremental quaternion $\\Delta q_n$ corresponds to a rotation by an angle $\\theta = ||\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}|| \\Delta t$ around the axis $\\hat{\\mathbf{u}} = \\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2} / ||\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}||$. It is given by:\n$$\n\\Delta q_n = \\left(\\cos\\left(\\frac{\\theta}{2}\\right), \\sin\\left(\\frac{\\theta}{2}\\right)\\hat{\\mathbf{u}}\\right)\n$$\nIf $||\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}||$ is close to zero, this expression is replaced by its Taylor expansion to avoid numerical instability. After the update, $q_{n+1}$ is re-normalized to unity, $q_{n+1} \\leftarrow q_{n+1} / ||q_{n+1}||$, to counteract floating-point error accumulation.\n\nStep 3: Compute new torque and acceleration.\nWith the new orientation $q_{n+1}$, we compute the new physical state.\nFirst, the space-frame bond direction vector $\\mathbf{n}_{n+1}$:\n$$\n\\mathbf{n}_{n+1} = \\mathcal{R}(q_{n+1}) \\mathbf{e}_3\n$$\nwhere $\\mathbf{e}_3 = (0,0,1)$ and $\\mathcal{R}(q)$ is the rotation matrix corresponding to $q=(q_0, q_1, q_2, q_3)$:\n$$\n\\mathcal{R}(q) = \\begin{pmatrix}\n1 - 2(q_2^2 + q_3^2) & 2(q_1 q_2 - q_0 q_3) & 2(q_1 q_3 + q_0 q_2) \\\\\n2(q_1 q_2 + q_0 q_3) & 1 - 2(q_1^2 + q_3^2) & 2(q_2 q_3 - q_0 q_1) \\\\\n2(q_1 q_3 - q_0 q_2) & 2(q_2 q_3 + q_0 q_1) & 1 - 2(q_1^2 + q_2^2)\n\\end{pmatrix}\n$$\nNext, the space-frame torque $\\boldsymbol{\\tau}_{\\mathrm{s}, n+1}$:\n$$\n\\boldsymbol{\\tau}_{\\mathrm{s}, n+1} = p \\, \\mathbf{n}_{n+1} \\times \\mathbf{E}\n$$\nThis is transformed to the body frame:\n$$\n\\boldsymbol{\\tau}_{\\mathrm{b}, n+1} = \\mathcal{R}(q_{n+1})^\\top \\boldsymbol{\\tau}_{\\mathrm{s}, n+1}\n$$\nFinally, the new body-frame angular acceleration $\\boldsymbol{\\alpha}_{\\mathrm{b}, n+1}$:\n$$\n\\alpha_{\\mathrm{b},1,n+1} = \\frac{\\tau_{\\mathrm{b},1,n+1}}{I_\\perp}, \\quad \\alpha_{\\mathrm{b},2,n+1} = \\frac{\\tau_{\\mathrm{b},2,n+1}}{I_\\perp}, \\quad \\alpha_{\\mathrm{b},3,n+1} = 0\n$$\n\nStep 4: Second half-step update of angular velocity.\nThe angular velocity is updated for the remaining half-step using the new acceleration, completing the step from $t_n$ to $t_{n+1}$:\n$$\n\\boldsymbol{\\omega}_{\\mathrm{b}, n+1} = \\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2} + \\boldsymbol{\\alpha}_{\\mathrm{b}, n+1} \\frac{\\Delta t}{2}\n$$\nThe constraint $\\omega_3 = 0$ is enforced at each step.\n\nThis algorithm is implemented for each test case.\nFor cases A and C (torque-free), $\\mathbf{E} = \\mathbf{0}$, which implies the torque $\\boldsymbol{\\tau}$ and angular acceleration $\\boldsymbol{\\alpha}_{\\mathrm{b}}$ are always zero. The algorithm correctly predicts that $\\boldsymbol{\\omega}_{\\mathrm{b}}$ remains constant, leading to perfect conservation of kinetic energy, with any deviation resulting only from floating-point arithmetic limitations. The relative energy error $\\varepsilon_K$ is thus expected to be near machine precision.\n\nFor case B, the non-zero electric field $\\mathbf{E}$ and dipole moment $p$ produce a torque that realigns the molecule. The simulation tracks this motion, and the final polar angle $\\theta_{\\mathrm{f}}$ is computed from the $z$-component of the final bond vector $\\mathbf{n}(N\\Delta t)$, which is given by $n_z = 1 - 2(q_1^2 + q_2^2)$.\nThe required output is $\\theta_{\\mathrm{f}} = \\arccos(n_z)$.\nThe implementation will follow these steps to generate the specified outputs.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a Verlet integrator for rigid diatomic molecule rotation\n    and calculates results for the specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case A\n        {\n            \"m1\": 3.0e-26, \"m2\": 3.0e-26, \"L\": 1.0e-10,\n            \"E\": np.array([0.0, 0.0, 0.0]), \"p\": 0.0,\n            \"dt\": 1.0e-15, \"N\": 2000,\n            \"q0\": np.array([np.sqrt(2)/2, 0.0, -np.sqrt(2)/2, 0.0]),\n            \"omega_b0\": np.array([0.0, 1.0e12, 0.0]),\n            \"output_type\": \"energy_error\"\n        },\n        # Test case B\n        {\n            \"m1\": 3.0e-26, \"m2\": 3.0e-26, \"L\": 1.0e-10,\n            \"E\": np.array([0.0, 0.0, 1.0e7]), \"p\": 3.33564e-30,\n            \"dt\": 1.0e-15, \"N\": 10000,\n            \"q0\": np.array([np.sqrt(2)/2, 0.0, -np.sqrt(2)/2, 0.0]),\n            \"omega_b0\": np.array([0.0, 0.0, 0.0]),\n            \"output_type\": \"final_angle\"\n        },\n        # Test case C\n        {\n            \"m1\": 3.0e-26, \"m2\": 3.0e-26, \"L\": 1.0e-10,\n            \"E\": np.array([0.0, 0.0, 0.0]), \"p\": 0.0,\n            \"dt\": 5.0e-15, \"N\": 400,\n            \"q0\": np.array([np.sqrt(2)/2, 0.0, -np.sqrt(2)/2, 0.0]),\n            \"omega_b0\": np.array([0.0, 1.0e12, 0.0]),\n            \"output_type\": \"energy_error\"\n        }\n    ]\n\n    results = []\n    \n    # Helper functions\n    def q_mult(q1, q2):\n        \"\"\"Quaternion multiplication q1*q2, scalar-first.\"\"\"\n        w1, x1, y1, z1 = q1\n        w2, x2, y2, z2 = q2\n        w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2\n        x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2\n        y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2\n        z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2\n        return np.array([w, x, y, z])\n\n    def q_to_rot_matrix(q):\n        \"\"\"Rotation matrix from scalar-first quaternion.\"\"\"\n        q0, q1, q2, q3 = q\n        # Explicit form to match the one in the explanation\n        R = np.array([\n            [1 - 2*(q2**2 + q3**2), 2*(q1*q2 - q0*q3), 2*(q1*q3 + q0*q2)],\n            [2*(q1*q2 + q0*q3), 1 - 2*(q1**2 + q3**2), 2*(q2*q3 - q0*q1)],\n            [2*(q1*q3 - q0*q2), 2*(q2*q3 + q0*q1), 1 - 2*(q1**2 + q2**2)]\n        ])\n        return R\n\n    for case in test_cases:\n        # Unpack parameters\n        m1, m2, L = case[\"m1\"], case[\"m2\"], case[\"L\"]\n        E, p = case[\"E\"], case[\"p\"]\n        dt, N = case[\"dt\"], case[\"N\"]\n        \n        # Calculate derived constants\n        mu = (m1 * m2) / (m1 + m2)\n        I_perp = mu * L**2\n        inv_I_perp = 1.0 / I_perp if I_perp != 0 else 0.0\n\n        # Initialize state variables\n        q = np.copy(case[\"q0\"])\n        omega_b = np.copy(case[\"omega_b0\"])\n\n        def compute_accel(current_q):\n            if p == 0.0:\n                return np.array([0.0, 0.0, 0.0])\n            \n            # Rotation matrix from quaternion\n            R = q_to_rot_matrix(current_q)\n            \n            # Space-frame bond vector n (third column of R)\n            n_s = R[:, 2]\n            \n            # Space-frame torque\n            tau_s = p * np.cross(n_s, E)\n            \n            # Body-frame torque\n            tau_b = R.T @ tau_s\n            \n            # Body-frame angular acceleration\n            alpha_b = np.zeros(3)\n            alpha_b[0] = tau_b[0] * inv_I_perp\n            alpha_b[1] = tau_b[1] * inv_I_perp\n            return alpha_b\n\n        # Initial kinetic energy for energy error calculation\n        if case[\"output_type\"] == \"energy_error\":\n            K0 = 0.5 * I_perp * (omega_b[0]**2 + omega_b[1]**2)\n\n        # Initial acceleration\n        alpha_b = compute_accel(q)\n\n        # Main integration loop (Velocity Verlet)\n        for _ in range(N):\n            # 1. Half-step velocity update\n            omega_b_half = omega_b + 0.5 * dt * alpha_b\n\n            # 2. Full-step position (orientation) update\n            omega_norm = np.linalg.norm(omega_b_half)\n            if omega_norm > 1e-16: # Avoid division by zero\n                theta = omega_norm * dt\n                axis = omega_b_half / omega_norm\n                \n                delta_q_w = np.cos(theta / 2.0)\n                delta_q_v = np.sin(theta / 2.0) * axis\n                \n                delta_q = np.array([delta_q_w, delta_q_v[0], delta_q_v[1], delta_q_v[2]])\n            else: # Small angle approximation\n                delta_q_v = 0.5 * dt * omega_b_half\n                delta_q_w = np.sqrt(1.0 - np.dot(delta_q_v, delta_q_v))\n                delta_q = np.array([delta_q_w, delta_q_v[0], delta_q_v[1], delta_q_v[2]])\n\n            q = q_mult(q, delta_q)\n            q /= np.linalg.norm(q) # Renormalize\n\n            # 3. Compute new acceleration\n            alpha_b_new = compute_accel(q)\n            \n            # 4. Second half-step velocity update\n            omega_b = omega_b_half + 0.5 * dt * alpha_b_new\n            \n            # Update acceleration for next iteration\n            alpha_b = alpha_b_new\n\n        # Compute required output\n        if case[\"output_type\"] == \"energy_error\":\n            Kf = 0.5 * I_perp * (omega_b[0]**2 + omega_b[1]**2)\n            if K0 == 0.0:\n                result = 0.0 if Kf == 0.0 else np.inf\n            else:\n                result = (Kf - K0) / K0\n        elif case[\"output_type\"] == \"final_angle\":\n            # n_z = 1 - 2*(q1^2 + q2^2)\n            n_z = 1.0 - 2.0 * (q[1]**2 + q[2]**2)\n            # Clip to handle potential floating point errors outside [-1, 1]\n            n_z = np.clip(n_z, -1.0, 1.0)\n            result = np.arccos(n_z)\n            \n        results.append(result)\n\n    # Format and print the final output\n    formatted_results = [f\"{r:.10e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2466818"}]}