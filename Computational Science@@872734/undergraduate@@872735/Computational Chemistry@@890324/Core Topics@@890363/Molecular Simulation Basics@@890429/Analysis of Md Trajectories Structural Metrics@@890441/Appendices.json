{"hands_on_practices": [{"introduction": "Quantifying the similarity between two molecular structures is a cornerstone of trajectory analysis. This practice guides you through the implementation of the Root Mean Square Deviation (RMSD) calculation, a fundamental measure of structural difference, after optimal rigid-body superposition. By building a pairwise dissimilarity matrix for a set of structures, you will develop a core skill and create a foundational tool used in more advanced analyses like conformational clustering.", "problem": "You are given several sets of three-dimensional atomic coordinates representing representative structures sampled from Molecular Dynamics (MD) trajectories. Your task is to compute a pairwise dissimilarity matrix using the Root Mean Square Deviation (RMSD) between structures after optimal superposition, and then to convert this matrix into a heatmap-ready normalized matrix. You must implement the solution as a complete, runnable program.\n\nFundamental base and constraints:\n- Consider a structure to be a set of $N$ points in three-dimensional Euclidean space, represented as an $N \\times 3$ array of real numbers in ångström. The Euclidean norm and inner product in $\\mathbb{R}^3$ must be used. The distance between two points $\\mathbf{x}$ and $\\mathbf{y}$ is $\\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2$.\n- The Root Mean Square Deviation (RMSD) between two structures with the same atom ordering must be computed after removing differences due to rigid-body translation and rotation. Specifically, you must align one structure to the other by the proper rotation (i.e., a rotation matrix with determinant $+1$) that minimizes the sum of squared inter-atomic distances, with translations eliminated by centering both structures at their centroids. Reflection is not allowed. After optimal alignment, RMSD is the square root of the mean of the squared distances between corresponding atoms.\n- The dissimilarity matrix $\\mathbf{D}$ for a set of $M$ structures is defined by $D_{ij}$ being the RMSD between structure $i$ and structure $j$ in ångström, and $D_{ii} = 0$ for all $i$.\n- To obtain a heatmap-ready matrix $\\mathbf{H}$ from $\\mathbf{D}$, perform min-max normalization on the off-diagonal elements: let $d_{\\min}$ be the minimum and $d_{\\max}$ be the maximum of $\\{ D_{ij} : i \\neq j \\}$. For $i \\neq j$, set $H_{ij} = (D_{ij} - d_{\\min}) / (d_{\\max} - d_{\\min})$, and set $H_{ii} = 0$. If there are no off-diagonals (i.e., $M = 1$), or $d_{\\max} = d_{\\min}$, define all off-diagonal $H_{ij}$ to be $0$ to avoid division by zero. The matrix $\\mathbf{H}$ is dimensionless.\n- Angles used for constructing transformations must be in degrees. All coordinates are in ångström, and all RMSD values must be reported in ångström.\n\nTest suite to implement and evaluate:\n- Case $1$ (happy path, tests rotation/translation invariance and non-zero dissimilarity): Use $M = 3$ structures of $N = 4$ atoms each.\n  - Define the reference tetrahedral structure\n    - $\\mathbf{S}_0$ with rows: $(1,1,1)$, $(-1,-1,1)$, $(-1,1,-1)$, $(1,-1,-1)$.\n  - Define $\\mathbf{S}_1$ by rotating $\\mathbf{S}_0$ about the $z$-axis by $90$ degrees (angle unit: degrees), then translating by $(2.0,-3.0,0.5)$ ångström.\n  - Define $\\mathbf{S}_2$ by adding the following deterministic displacements (in ångström) to the rows of $\\mathbf{S}_0$, in order:\n    - $(0.08,-0.02,0.03)$, $(-0.05,0.07,-0.04)$, $(0.02,-0.06,0.05)$, $(-0.03,0.04,-0.07)$.\n- Case $2$ (boundary, tests chirality/no-reflection constraint): Use $M = 3$ structures of $N = 4$ atoms each.\n  - Define $\\mathbf{A}_0$ with rows: $(0.0,0.0,0.0)$, $(1.0,0.2,-0.1)$, $(0.3,1.1,0.4)$, $(-0.2,0.5,1.2)$.\n  - Define $\\mathbf{A}_1$ as the mirror image of $\\mathbf{A}_0$ across the plane $x=0$ (i.e., map $(x,y,z)$ to $(-x,y,z)$), which cannot be superimposed by any proper rotation.\n  - Define $\\mathbf{A}_2 = \\mathbf{A}_0$ (an identical copy) to ensure a near-zero RMSD pair exists in the set.\n- Case $3$ (edge case, tests $M=1$): Use $M = 1$ structure of $N = 3$ atoms:\n  - Define $\\mathbf{B}_0$ with rows: $(0.0,0.0,0.0)$, $(1.0,0.0,0.0)$, $(0.0,1.0,0.0)$.\n\nProgram requirements:\n- For each case, compute the dissimilarity matrix $\\mathbf{D}$ using pairwise optimal superposition and RMSD. Then compute the normalized heatmap matrix $\\mathbf{H}$ as described.\n- For each case, extract the upper-triangular entries of $\\mathbf{D}$ with strict inequality $i < j$ in row-major order as a list of floats, and similarly extract the upper-triangular entries of $\\mathbf{H}$ in the same order.\n- Round all RMSD values to exactly three decimal places (in ångström) and all normalized heatmap values to exactly three decimal places (dimensionless).\n- Final output format: Your program should produce a single line of output containing a list with six elements in the following order:\n  - Case $1$ RMSD upper-triangle list,\n  - Case $1$ heatmap upper-triangle list,\n  - Case $2$ RMSD upper-triangle list,\n  - Case $2$ heatmap upper-triangle list,\n  - Case $3$ RMSD upper-triangle list,\n  - Case $3$ heatmap upper-triangle list.\n- The output must contain no spaces, and every float must have exactly three digits after the decimal point. For example, a syntactic template with placeholders is:\n  - \"[[r1_1,r1_2,...],[h1_1,h1_2,...],[r2_1,...],[h2_1,...],[r3_1,...],[h3_1,...]]\"\n  where each \"r\" is an RMSD value in ångström and each \"h\" is a normalized heatmap value (dimensionless), all rounded to three decimals as specified.\n\nYour implementation must be entirely self-contained. Do not read any input. Use only the specified libraries.\n\nAnswer types and units:\n- The lists contain floats. RMSD entries must be in ångström, rounded to three decimals. Normalized heatmap entries are dimensionless, rounded to three decimals.\n\nThe physics and numerical assumptions are standard and realistic for rigid-body alignment in structural analysis of trajectories. Ensure that the alignment uses a proper rotation (determinant $+1$) and that translations are removed by centering.\n\nYour program will be tested against the three cases exactly as described. The output must follow the exact single-line format stated above.", "solution": "The problem is valid. It presents a clear, self-contained, and scientifically sound computational task standard in structural biology and computational chemistry. I will proceed with a full solution.\n\nThe core of the problem is to compute the Root Mean Square Deviation (RMSD) between pairs of atomic structures after optimal rigid-body superposition. This requires removing transnational and rotational differences. The problem specifies that only proper rotations (determinant $+1$) are allowed, forbidding reflections. This is a crucial physical constraint, as enantiomers (mirror-image molecules) are not interconvertible by rotation.\n\nLet two structures, $\\mathbf{A}$ and $\\mathbf{B}$, be represented by $N \\times 3$ matrices of atomic coordinates, where $N$ is the number of atoms. The rows of the matrices, $\\mathbf{a}_i$ and $\\mathbf{b}_i$ for $i=1, \\dots, N$, are the three-dimensional coordinate vectors for each corresponding atom.\n\nThe RMSD is defined as:\n$$ \\text{RMSD}(\\mathbf{A}, \\mathbf{B}) = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\lVert (\\mathbf{T} + \\mathbf{a}_i \\mathbf{R}^T) - \\mathbf{b}_i \\rVert^2} $$\nwhere we must find the optimal translation vector $\\mathbf{T}$ and rotation matrix $\\mathbf{R}$ that minimize this value.\n\nThe solution procedure, commonly known as the Kabsch algorithm, involves the following steps:\n\n1.  **Remove Translational Difference**: The optimal translation is eliminated by moving the centroid of each structure to the origin. The centroid of a structure $\\mathbf{A}$ is $\\mathbf{c}_A = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{a}_i$. We define the centered coordinate matrices as $\\mathbf{A}' = \\mathbf{A} - \\mathbf{1}\\mathbf{c}_A^T$ and $\\mathbf{B}' = \\mathbf{B} - \\mathbf{1}\\mathbf{c}_B^T$, where $\\mathbf{1}$ is an $N \\times 1$ column vector of ones.\n\n2.  **Find Optimal Rotation**: After centering, the problem reduces to finding the rotation matrix $\\mathbf{R}$ that minimizes the sum of squared distances $\\sum_{i=1}^N \\lVert \\mathbf{a}'_i \\mathbf{R}^T - \\mathbf{b}'_i \\rVert^2$. This is equivalent to maximizing the trace of the matrix product involving a covariance matrix. The covariance matrix $\\mathbf{C}$ is computed as:\n    $$ \\mathbf{C} = (\\mathbf{A}')^T \\mathbf{B}' $$\n    This is a $3 \\times 3$ matrix.\n\n3.  **Singular Value Decomposition (SVD)**: The optimal rotation is found using the Singular Value Decomposition of the covariance matrix $\\mathbf{C}$:\n    $$ \\mathbf{C} = \\mathbf{U} \\mathbf{\\Sigma} \\mathbf{V}^T $$\n    where $\\mathbf{U}$ and $\\mathbf{V}$ are $3 \\times 3$ orthogonal matrices and $\\mathbf{\\Sigma}$ is a $3 \\times 3$ diagonal matrix of singular values. The optimal rotation matrix $\\mathbf{R}$ is given by:\n    $$ \\mathbf{R} = \\mathbf{V} \\mathbf{U}^T $$\n\n4.  **Enforce Proper Rotation**: The matrix $\\mathbf{R}$ computed above could be a proper rotation ($\\det(\\mathbf{R})=+1$) or an improper rotation (a reflection, with $\\det(\\mathbf{R})=-1$). The problem requires a proper rotation. If $\\det(\\mathbf{R}) = -1$, it indicates that one of the structures is a mirror image of the other in its optimal alignment. To obtain the best *proper* rotation, we must \"undo\" the reflection. This is achieved by reflecting the coordinate system along the axis corresponding to the smallest singular value. A practical way to implement this is to check the sign of $\\det(\\mathbf{V}\\mathbf{U}^T)$. If it is negative, we modify $\\mathbf{V}$ by flipping the sign of its third column (or equivalently, the third row of $\\mathbf{V}^T$) before computing $\\mathbf{R}$:\n    $$ \\text{If } \\det(\\mathbf{V}\\mathbf{U}^T) < 0, \\text{ then } \\mathbf{R} = \\mathbf{V} \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & -1 \\end{pmatrix} \\mathbf{U}^T $$\n    This guarantees that $\\det(\\mathbf{R}) = +1$.\n\n5.  **Calculate Final RMSD**: With the optimal proper rotation $\\mathbf{R}$, we rotate structure $\\mathbf{A}'$ and compute the RMSD with respect to $\\mathbf{B}'$. The sum of squared distances $E$ is:\n    $$ E = \\sum_{i=1}^N \\lVert \\mathbf{a}'_i \\mathbf{R}^T - \\mathbf{b}'_i \\rVert^2 $$\n    The RMSD is then:\n    $$ \\text{RMSD} = \\sqrt{\\frac{E}{N}} $$\n\nOnce the pairwise RMSD values are calculated for a set of $M$ structures, they are arranged into an $M \\times M$ dissimilarity matrix $\\mathbf{D}$, where $D_{ij}$ is the RMSD between structure $i$ and structure $j$. By definition, $D_{ii}=0$ and $\\mathbf{D}$ is symmetric ($D_{ij} = D_{ji}$).\n\nFinally, this matrix $\\mathbf{D}$ is normalized to produce a heatmap-ready matrix $\\mathbf{H}$. The off-diagonal elements are normalized using min-max scaling:\n$$ H_{ij} = \\frac{D_{ij} - d_{\\min}}{d_{\\max} - d_{\\min}} \\quad \\text{for } i \\neq j $$\nwhere $d_{\\min}$ and $d_{\\max}$ are the minimum and maximum of the off-diagonal elements $\\{D_{ij} | i \\neq j\\}$. The diagonal elements $H_{ii}$ are set to $0$. Special care is taken for cases where $M=1$ (no off-diagonal elements) or $d_{\\max} = d_{\\min}$, in which cases all off-diagonal $H_{ij}$ are defined as $0$.\n\nThe provided test cases will be solved by implementing this full procedure. For each case, the upper-triangular elements of $\\mathbf{D}$ and $\\mathbf{H}$ are extracted, rounded, and formatted as specified. Case 1 tests standard superposition. Case 2 specifically tests the chirality constraint by including a mirror-image structure. Case 3 tests the edge case of a single structure.", "answer": "```python\nimport numpy as np\n\ndef compute_rmsd(coords1: np.ndarray, coords2: np.ndarray) -> float:\n    \"\"\"\n    Computes the RMSD between two structures after optimal superposition.\n    This implementation uses the Kabsch algorithm.\n    It ensures that the rotation is a proper rotation (determinant +1).\n\n    Args:\n        coords1: An N x 3 numpy array of atomic coordinates.\n        coords2: An N x 3 numpy array of atomic coordinates.\n\n    Returns:\n        The RMSD value in the same units as the input coordinates.\n    \"\"\"\n    if coords1.shape[0] != coords2.shape[0]:\n        raise ValueError(\"Input structures must have the same number of atoms.\")\n    \n    num_atoms = coords1.shape[0]\n    \n    # 1. Center the structures\n    centroid1 = coords1.mean(axis=0)\n    centroid2 = coords2.mean(axis=0)\n    centered1 = coords1 - centroid1\n    centered2 = coords2 - centroid2\n    \n    # 2. Compute the covariance matrix\n    # C = (B')^T * A' in some notations, but here we use A' and B'\n    # The order matters for the U and V matrices. Let's say we rotate centered2 onto centered1.\n    cov_matrix = centered1.T @ centered2\n\n    # 3. Singular Value Decomposition\n    try:\n        U, S, Vt = np.linalg.svd(cov_matrix)\n    except np.linalg.LinAlgError:\n        # This can happen in pathological cases, e.g., all points collinear.\n        # Fallback to a non-SVD calculation if needed, but for these tests it's robust.\n        return np.sqrt(np.sum((centered1 - centered2)**2) / num_atoms)\n\n    # 4. Check for and correct reflection (improper rotation)\n    # This ensures we have a proper rotation (determinant = +1)\n    if np.linalg.det(Vt.T @ U.T)  0:\n        # Flip the sign of the column of V corresponding to the smallest singular value\n        Vt[2, :] *= -1\n    \n    # 5. Compute the optimal rotation matrix\n    rotation_matrix = Vt.T @ U.T\n    \n    # 6. Apply rotation to the second structure and calculate RMSD\n    rotated_centered2 = centered2 @ rotation_matrix.T\n    \n    diff = centered1 - rotated_centered2\n    rmsd = np.sqrt(np.sum(diff * diff) / num_atoms)\n    \n    return rmsd\n\ndef process_structures(structures: list[np.ndarray]) -> tuple[list[float], list[float]]:\n    \"\"\"\n    For a list of M structures, computes the dissimilarity (D) and heatmap (H) matrices.\n\n    Args:\n        structures: A list of M numpy arrays, each N x 3.\n\n    Returns:\n        A tuple containing two lists:\n        1. The upper-triangular elements of D (RMSD values).\n        2. The upper-triangular elements of H (normalized values).\n    \"\"\"\n    M = len(structures)\n    \n    if M = 1:\n        return [], []\n\n    D = np.zeros((M, M))\n    off_diagonal_d = []\n    \n    # Calculate pairwise RMSD matrix D\n    for i in range(M):\n        for j in range(i + 1, M):\n            rmsd = compute_rmsd(structures[i], structures[j])\n            D[i, j] = D[j, i] = rmsd\n            off_diagonal_d.append(rmsd)\n            \n    rmsd_upper_tri = [D[i, j] for i in range(M) for j in range(i + 1, M)]\n\n    if not off_diagonal_d or len(off_diagonal_d)  1:\n        return rmsd_upper_tri, ([0.0] * len(rmsd_upper_tri))\n\n    d_min = min(off_diagonal_d)\n    d_max = max(off_diagonal_d)\n    \n    # Calculate heatmap matrix H\n    H = np.zeros((M, M))\n    heatmap_upper_tri = []\n\n    if abs(d_max - d_min)  1e-9: # Handle d_max == d_min case\n        heatmap_upper_tri = [0.0] * len(rmsd_upper_tri)\n    else:\n        for i in range(M):\n            for j in range(i + 1, M):\n                h_val = (D[i, j] - d_min) / (d_max - d_min)\n                H[i, j] = H[j, i] = h_val\n        heatmap_upper_tri = [H[i, j] for i in range(M) for j in range(i + 1, M)]\n        \n    return rmsd_upper_tri, heatmap_upper_tri\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run computations, and print the final result.\n    \"\"\"\n    # --- Case 1 ---\n    S0 = np.array([\n        [1.0, 1.0, 1.0],\n        [-1.0, -1.0, 1.0],\n        [-1.0, 1.0, -1.0],\n        [1.0, -1.0, -1.0]\n    ])\n    angle_rad = np.deg2rad(90)\n    c, s = np.cos(angle_rad), np.sin(angle_rad)\n    Rz = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n    S1_rotated = S0 @ Rz.T\n    S1 = S1_rotated + np.array([2.0, -3.0, 0.5])\n    \n    displacements = np.array([\n        [0.08, -0.02, 0.03],\n        [-0.05, 0.07, -0.04],\n        [0.02, -0.06, 0.05],\n        [-0.03, 0.04, -0.07]\n    ])\n    S2 = S0 + displacements\n    \n    case1_structures = [S0, S1, S2]\n    \n    # --- Case 2 ---\n    A0 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.0, 0.2, -0.1],\n        [0.3, 1.1, 0.4],\n        [-0.2, 0.5, 1.2]\n    ])\n    A1 = A0.copy()\n    A1[:, 0] *= -1  # Mirror image across x=0 plane\n    A2 = A0.copy()   # Identical structure\n    \n    case2_structures = [A0, A1, A2]\n\n    # --- Case 3 ---\n    B0 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0]\n    ])\n    case3_structures = [B0]\n\n    all_cases = [case1_structures, case2_structures, case3_structures]\n    all_results = []\n    \n    for structures in all_cases:\n        rmsd_list, heatmap_list = process_structures(structures)\n        all_results.append(rmsd_list)\n        all_results.append(heatmap_list)\n        \n    # Format the final output string\n    # E.g., [[val1,val2],[val3,val4],[],[]]\n    output_parts = []\n    for res_list in all_results:\n        formatted_nums = \",\".join([f\"{num:.3f}\" for num in res_list])\n        output_parts.append(f\"[{formatted_nums}]\")\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2449039"}, {"introduction": "Beyond comparing entire structures, it is often crucial to characterize the average local environment and specific intermolecular interactions within a system. This exercise introduces the Radial Distribution Function, $g(r)$, a powerful statistical tool that reveals the structure of liquids and solutions. By implementing the calculation for $g(r)$ and its integral—the coordination number—from discrete trajectory data, you will learn to quantify the local packing and bonding patterns that govern a system's bulk properties.", "problem": "You are given a finite set of trajectory frames from a Molecular Dynamics (MD) simulation of liquid formamide. In each frame, there are two labeled species: carbonyl oxygen atoms (acceptors) and amide hydrogen atoms (donors). The system is enclosed in a cubic periodic simulation box of side length $L$ expressed in nanometers. For a pair of species $A$ (acceptors) and $B$ (donors), the cross radial distribution function (RDF) $g_{AB}(r)$ is defined by the relationship that the probability density of finding a particle of species $B$ in a spherical shell of radius $r$ and thickness $\\mathrm{d}r$ around a particle of species $A$ is $\\rho_B \\, g_{AB}(r)$, where $\\rho_B$ is the number density of species $B$. In the discrete and finite setting, $g_{AB}(r)$ is estimated by counting interspecies pair separations in shells and normalizing by the ideal-gas expectation:\n$$\ng_{AB}(r_j) \\approx \\frac{V}{4\\pi r_j^2 \\Delta r} \\cdot \\frac{1}{F} \\sum_{k=1}^{F} \\frac{1}{N_A^{(k)} N_B^{(k)}} \\, C_j^{(k)},\n$$\nwhere $V=L^3$ is the box volume, $F$ is the number of frames, $N_A^{(k)}$ and $N_B^{(k)}$ are the numbers of $A$ and $B$ particles in frame $k$, $\\Delta r$ is the bin width, $r_j$ is the center of bin $j$, and $C_j^{(k)}$ is the count of $A$–$B$ pairs in frame $k$ whose minimum-image separation lies in bin $j$. Use the minimum image convention for periodic boundary conditions: for a displacement component $\\Delta x$, use $\\Delta x - L \\cdot \\mathrm{round}(\\Delta x / L)$ before computing the Euclidean norm.\n\nA quantitative measure of hydrogen bonding from $g_{AB}(r)$ is the coordination number up to a cutoff $r_c$, defined as\n$$\nn_{AB}(r_c) = \\rho_B \\int_0^{r_c} 4\\pi r^2 g_{AB}(r)\\, \\mathrm{d}r.\n$$\nIn discrete form, with bin centers $r_j$ and width $\\Delta r$, this becomes\n$$\nn_{AB}(r_c) \\approx \\frac{1}{F} \\sum_{k=1}^{F} \\left[ \\rho_B^{(k)} \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\Delta r \\, g_{AB}^{(k)}(r_j) \\right],\n$$\nwhere $\\rho_B^{(k)} = N_B^{(k)}/V$ and $g_{AB}^{(k)}(r_j) = \\dfrac{V}{4\\pi r_j^2 \\Delta r} \\cdot \\dfrac{C_j^{(k)}}{N_A^{(k)} N_B^{(k)}}$. This expression equals the average (over frames) number of $B$ neighbors within $r_c$ per $A$ particle.\n\nAll distances must be computed and reported in nanometers. The coordination number is dimensionless.\n\nYour task is to compute $n_{AB}(r_c)$ for each of the following test cases. For each case, use bin width $\\Delta r = 0.01\\,\\mathrm{nm}$ and consider $r$ from $0$ up to (but not including) $L/2$. Distances must be computed using the minimum image convention under cubic periodic boundary conditions. For each case, the set of frames is explicitly specified; in each frame $k$, the positions of acceptors $A$ and donors $B$ are listed in nanometers. Angles do not appear in this problem. The final outputs must be floats.\n\nTest suite:\n\n- Case $1$:\n  - $L = 2.00\\,\\mathrm{nm}$, $F = 1$ frame.\n  - Frame $1$: Acceptors $A^{(1)} = [ (0.50, 0.50, 0.50) ]\\,\\mathrm{nm}$; Donors $B^{(1)} = [ (0.68, 0.50, 0.50) ]\\,\\mathrm{nm}$.\n  - Cutoff $r_c = 0.30\\,\\mathrm{nm}$.\n\n- Case $2$:\n  - $L = 2.00\\,\\mathrm{nm}$, $F = 1$ frame.\n  - Frame $1$: Acceptors $A^{(1)} = [ (0.20, 0.20, 0.20), (1.80, 1.80, 1.80) ]\\,\\mathrm{nm}$; Donors $B^{(1)} = [ (1.00, 1.00, 1.00), (1.00, 0.90, 1.00) ]\\,\\mathrm{nm}$.\n  - Cutoff $r_c = 0.25\\,\\mathrm{nm}$.\n\n- Case $3$:\n  - $L = 2.00\\,\\mathrm{nm}$, $F = 2$ frames.\n  - Frame $1$: Acceptors $A^{(1)} = [ (1.95, 1.00, 1.00) ]\\,\\mathrm{nm}$; Donors $B^{(1)} = [ (0.05, 1.00, 1.00) ]\\,\\mathrm{nm}$.\n  - Frame $2$: Acceptors $A^{(2)} = [ (1.95, 1.00, 1.00) ]\\,\\mathrm{nm}$; Donors $B^{(2)} = [ (0.60, 1.00, 1.00) ]\\,\\mathrm{nm}$.\n  - Cutoff $r_c = 0.30\\,\\mathrm{nm}$.\n\n- Case $4$:\n  - $L = 2.50\\,\\mathrm{nm}$, $F = 2$ frames.\n  - Frame $1$: Acceptors $A^{(1)} = [ (1.25, 1.25, 1.25), (0.30, 0.30, 0.30) ]\\,\\mathrm{nm}$; Donors $B^{(1)} = [ (1.40, 1.25, 1.25), (1.10, 1.25, 1.25), (2.40, 2.40, 2.40), (0.45, 0.30, 0.30), (0.10, 0.10, 0.10) ]\\,\\mathrm{nm}$.\n  - Frame $2$: Acceptors $A^{(2)} = [ (1.25, 1.25, 1.25), (0.30, 0.30, 0.30) ]\\,\\mathrm{nm}$; Donors $B^{(2)} = [ (1.40, 1.25, 1.25), (2.00, 2.00, 2.00), (0.45, 0.30, 0.30), (0.30, 0.50, 0.30) ]\\,\\mathrm{nm}$.\n  - Cutoff $r_c = 0.30\\,\\mathrm{nm}$.\n\nYour program must, for each case, compute the coordination number $n_{AB}(r_c)$ as defined above and aggregate the results across all cases into a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[x_1,x_2,x_3,x_4]$, where each $x_i$ is the float result for case $i$ with no units.", "solution": "The problem proposed is a well-defined exercise in computational statistical mechanics, specifically the analysis of molecular dynamics simulation trajectories. It is scientifically grounded, internally consistent, and contains all necessary information for a unique solution. The definitions of the radial distribution function, coordination number, and minimum image convention are standard in the field. Therefore, the problem is valid, and we shall proceed with a rigorous solution.\n\nThe central task is to compute the coordination number $n_{AB}(r_c)$ for several test cases. The problem provides a definition for $n_{AB}(r_c)$ as a discrete approximation of an integral expression:\n$$\nn_{AB}(r_c) \\approx \\frac{1}{F} \\sum_{k=1}^{F} \\left[ \\rho_B^{(k)} \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\Delta r \\, g_{AB}^{(k)}(r_j) \\right]\n$$\nHere, $F$ is the number of frames. The term inside the sum over frames can be interpreted as the coordination number for a single frame $k$. Let us analyze this term, $n_{AB}^{(k)}(r_c)$. The problem provides definitions for the per-frame number density of species $B$, $\\rho_B^{(k)}$, and the per-frame radial distribution function, $g_{AB}^{(k)}(r_j)$:\n$$\n\\rho_B^{(k)} = \\frac{N_B^{(k)}}{V}\n$$\n$$\ng_{AB}^{(k)}(r_j) = \\frac{V}{4\\pi r_j^2 \\Delta r} \\cdot \\frac{C_j^{(k)}}{N_A^{(k)} N_B^{(k)}}\n$$\nwhere $V=L^3$ is the volume of the simulation box, $N_A^{(k)}$ and $N_B^{(k)}$ are the number of particles of species $A$ and $B$ in frame $k$, $\\Delta r$ is the histogram bin width, $r_j$ is the center of the $j$-th bin, and $C_j^{(k)}$ is the number of $A-B$ pairs in frame $k$ with a separation distance falling into the $j$-th bin.\n\nSubstituting these definitions into the expression for the single-frame coordination number, we obtain a significant simplification:\n$$\nn_{AB}^{(k)}(r_c) = \\rho_B^{(k)} \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\Delta r \\, g_{AB}^{(k)}(r_j)\n$$\n$$\nn_{AB}^{(k)}(r_c) = \\left( \\frac{N_B^{(k)}}{V} \\right) \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\Delta r \\left( \\frac{V}{4\\pi r_j^2 \\Delta r} \\cdot \\frac{C_j^{(k)}}{N_A^{(k)} N_B^{(k)}} \\right)\n$$\nThe terms $V$, $4\\pi r_j^2$, and $\\Delta r$ cancel out, leading to:\n$$\nn_{AB}^{(k)}(r_c) = \\frac{N_B^{(k)}}{V} \\sum_{j: r_j \\le r_c} V \\frac{C_j^{(k)}}{N_A^{(k)} N_B^{(k)}} = \\frac{1}{N_A^{(k)}} \\sum_{j: r_j \\le r_c} C_j^{(k)}\n$$\nThe summation $\\sum_{j: r_j \\le r_c} C_j^{(k)}$ represents the total count of all pairs separated by a distance $r$ that is less than or equal to the cutoff $r_c$ in frame $k$. Let us denote this total count as $N_{\\text{pairs}}^{(k)}(r \\le r_c)$. The expression for the single-frame coordination number thus becomes:\n$$\nn_{AB}^{(k)}(r_c) = \\frac{N_{\\text{pairs}}^{(k)}(r \\le r_c)}{N_A^{(k)}}\n$$\nThis result has a direct physical interpretation: it is the average number of donor particles ($B$) found within a distance $r_c$ of an acceptor particle ($A$) in frame $k$. Crucially, this simplified formula does not depend on the bin width $\\Delta r$, which obviates the need for explicit histogramming.\n\nThe final coordination number, $n_{AB}(r_c)$, is the average of these single-frame values over all $F$ frames:\n$$\nn_{AB}(r_c) = \\frac{1}{F} \\sum_{k=1}^{F} n_{AB}^{(k)}(r_c) = \\frac{1}{F} \\sum_{k=1}^{F} \\frac{N_{\\text{pairs}}^{(k)}(r \\le r_c)}{N_A^{(k)}}\n$$\nThe computational algorithm is therefore as follows:\n1.  Initialize a list to store the per-frame coordination numbers.\n2.  For each frame $k$ from $1$ to $F$:\n    a. Determine the number of acceptor particles, $N_A^{(k)}$. If $N_A^{(k)} = 0$, the coordination number is trivially $0$.\n    b. Initialize a counter for pairs within the cutoff, $N_{\\text{pairs}}^{(k)}(r \\le r_c) = 0$.\n    c. For each acceptor particle position $\\vec{r}_i \\in A^{(k)}$ and each donor particle position $\\vec{r}_j \\in B^{(k)}$:\n        i.   Calculate the displacement vector $\\Delta\\vec{r} = \\vec{r}_j - \\vec{r}_i$.\n        ii.  Account for periodic boundary conditions using the minimum image convention for each component of the displacement vector, $\\Delta x_m$:\n             $$\n             \\Delta x'_m = \\Delta x_m - L \\cdot \\mathrm{round}(\\Delta x_m / L)\n             $$\n             where $L$ is the side length of the cubic box.\n        iii. Compute the Euclidean distance $d = \\sqrt{(\\Delta x'_1)^2 + (\\Delta x'_2)^2 + (\\Delta x'_3)^2}$.\n        iv.  If $d \\le r_c$, increment the pair counter $N_{\\text{pairs}}^{(k)}(r \\le r_c)$.\n    d. Calculate the per-frame coordination number $n_{AB}^{(k)}(r_c) = N_{\\text{pairs}}^{(k)}(r \\le r_c) / N_A^{(k)}$.\n    e. Add this value to the list of per-frame results.\n3.  The final result for the test case is the arithmetic mean of all stored per-frame coordination numbers.\n\nThis procedure will be applied to each of the four test cases provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the coordination number for several molecular dynamics trajectory test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1\n        {\n            \"L\": 2.00,\n            \"rc\": 0.30,\n            \"frames\": [\n                {\n                    \"A\": np.array([[0.50, 0.50, 0.50]]),\n                    \"B\": np.array([[0.68, 0.50, 0.50]])\n                }\n            ]\n        },\n        # Case 2\n        {\n            \"L\": 2.00,\n            \"rc\": 0.25,\n            \"frames\": [\n                {\n                    \"A\": np.array([[0.20, 0.20, 0.20], [1.80, 1.80, 1.80]]),\n                    \"B\": np.array([[1.00, 1.00, 1.00], [1.00, 0.90, 1.00]])\n                }\n            ]\n        },\n        # Case 3\n        {\n            \"L\": 2.00,\n            \"rc\": 0.30,\n            \"frames\": [\n                {\n                    \"A\": np.array([[1.95, 1.00, 1.00]]),\n                    \"B\": np.array([[0.05, 1.00, 1.00]])\n                },\n                {\n                    \"A\": np.array([[1.95, 1.00, 1.00]]),\n                    \"B\": np.array([[0.60, 1.00, 1.00]])\n                }\n            ]\n        },\n        # Case 4\n        {\n            \"L\": 2.50,\n            \"rc\": 0.30,\n            \"frames\": [\n                {\n                    \"A\": np.array([[1.25, 1.25, 1.25], [0.30, 0.30, 0.30]]),\n                    \"B\": np.array([\n                        [1.40, 1.25, 1.25], [1.10, 1.25, 1.25],\n                        [2.40, 2.40, 2.40], [0.45, 0.30, 0.30],\n                        [0.10, 0.10, 0.10]\n                    ])\n                },\n                {\n                    \"A\": np.array([[1.25, 1.25, 1.25], [0.30, 0.30, 0.30]]),\n                    \"B\": np.array([\n                        [1.40, 1.25, 1.25], [2.00, 2.00, 2.00],\n                        [0.45, 0.30, 0.30], [0.30, 0.50, 0.30]\n                    ])\n                }\n            ]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L = case[\"L\"]\n        rc = case[\"rc\"]\n        frames = case[\"frames\"]\n        \n        frame_coordination_numbers = []\n\n        for frame in frames:\n            acceptor_coords = frame[\"A\"]\n            donor_coords = frame[\"B\"]\n            \n            num_acceptors = acceptor_coords.shape[0]\n            \n            if num_acceptors == 0:\n                frame_coordination_numbers.append(0.0)\n                continue\n\n            pair_count = 0\n            for r_a in acceptor_coords:\n                for r_b in donor_coords:\n                    # Calculate displacement vector\n                    delta_r = r_b - r_a\n                    \n                    # Apply minimum image convention\n                    delta_r_mic = delta_r - L * np.round(delta_r / L)\n                    \n                    # Calculate distance\n                    distance = np.linalg.norm(delta_r_mic)\n                    \n                    # Check if within cutoff\n                    if distance = rc:\n                        pair_count += 1\n            \n            # Calculate coordination number for the frame\n            cn_frame = pair_count / num_acceptors\n            frame_coordination_numbers.append(cn_frame)\n\n        # Average coordination number over all frames for the case\n        mean_cn = np.mean(frame_coordination_numbers)\n        results.append(mean_cn)\n\n    # Print the results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2449053"}, {"introduction": "A molecular dynamics trajectory often captures a molecule transitioning between several distinct conformations, but how can we automatically identify these states from raw coordinate data? This capstone practice shows you how to combine structural metrics to perform higher-level data analysis. You will map each simulation frame to a point in a 2D feature space defined by its RMSD and Radius of Gyration ($R_g$), and then apply a density-based clustering algorithm to this space. This workflow empowers you to move from simple measurements to the automated discovery of meaningful conformational states, a key task in modern computational biology.", "problem": "You are given a conceptual specification for identifying distinct conformational states from a Molecular Dynamics (MD) trajectory by clustering frames in a two-dimensional feature space defined by Root Mean Square Deviation (RMSD) and Radius of Gyration (Rg). Each trajectory frame consists of three-dimensional Cartesian coordinates (in Ångström) of $N$ point masses of equal mass. The goal is to design and implement a principled algorithm that computes the structural metrics from first principles and uses density-based clustering to group frames into conformational states.\n\nStart from the following fundamental base:\n\n- Geometry of rigid bodies in three dimensions and Euclidean distance.\n- The definition of Root Mean Square Deviation (RMSD) as the square root of the mean of squared Euclidean distances between corresponding atoms after optimal rigid alignment.\n- The definition of Radius of Gyration (Rg) as the square root of the mean of squared distances of atoms from the center of mass.\n- The concept of density connectivity in a metric space: two points are considered directly density-reachable if they lie within a prescribed metric radius of each other, and a point is a core point if it has at least a specified minimum number of neighbors within that radius.\n\nTask requirements:\n\n1) For a reference structure with coordinates $P \\in \\mathbb{R}^{N \\times 3}$ and a trajectory frame with coordinates $Q \\in \\mathbb{R}^{N \\times 3}$, define RMSD as the minimized average squared displacement after optimal rigid-body superposition (translation and rotation). Formally, determine the rotation matrix $R \\in \\mathbb{R}^{3 \\times 3}$ and translation vector $t \\in \\mathbb{R}^{3}$ that minimize the sum of squared distances between corresponding atoms, and compute the RMSD of $Q$ with respect to $P$ using the resulting superposition. Express RMSD in Ångström.\n\n2) For each frame $Q$, compute the Radius of Gyration $R_g$ as the square root of the mean of squared distances of its atoms from their center of mass. Express $R_g$ in Ångström.\n\n3) Map each frame to a point in the two-dimensional feature space with coordinates $(\\text{RMSD}, R_g)$. In this plane, use the standard Euclidean metric. Implement a density-based clustering algorithm that:\n   - Uses a neighborhood radius parameter $\\varepsilon$ (in Ångström) and an integer minimum neighbor count $m$.\n   - Defines the neighborhood of a point as all points whose Euclidean distance in the $(\\text{RMSD}, R_g)$ plane is less than or equal to $\\varepsilon$.\n   - Classifies a point as a core point if its neighborhood size (including itself) is at least $m$.\n   - Forms a cluster as the union of all points that are density-connected to at least one core point, where density connectivity is the transitive closure of direct density reachability.\n   - Points that are not assigned to any cluster are labeled as noise and are not counted toward the number of clusters.\n\nTrajectory generation for a reproducible test bed:\n\n- Use $N = 12$ atoms with equal masses.\n- Construct a reference structure $P$ by a three-dimensional random walk with fixed step length $1.5$ Å starting at the origin, then translate to move its center of mass to the origin. Use a fixed random seed of $42$ for all stochastic elements to ensure reproducibility.\n- Generate $60$ frames partitioned as follows:\n  - $24$ “compact” frames: for each frame, apply an arbitrary rotation to $P$ and then add independent and identically distributed Gaussian noise with zero mean and standard deviation $0.05$ Å to each Cartesian coordinate of every atom.\n  - $24$ “extended” frames: for each frame, first isotropically scale $P$ by a factor of $1.6$, then apply an arbitrary rotation, and finally add independent and identically distributed Gaussian noise with zero mean and standard deviation $0.05$ Å to each Cartesian coordinate of every atom.\n  - $12$ “noise” frames: generate independent random-walk structures of $N$ atoms with step length $1.5$ Å, then add independent and identically distributed Gaussian noise with zero mean and standard deviation $0.2$ Å to each Cartesian coordinate of every atom. Do not scale these relative to $P$ before computing metrics.\n- For each frame, compute RMSD with respect to $P$ using optimal superposition, and compute $R_g$ of the frame.\n\nClustering metric and units:\n\n- In the $(\\text{RMSD}, R_g)$ plane, use the Euclidean distance. The parameter $\\varepsilon$ must be in Ångström, and $R_g$ and RMSD must be computed in Ångström. Angles for any rotations that you use internally must be in radians.\n\nTest suite:\n\nRun the clustering algorithm on the same $(\\text{RMSD}, R_g)$ dataset using the following three parameter pairs $(\\varepsilon, m)$:\n\n- Case A (happy path, two well-separated states): $\\varepsilon = 0.8$ Å, $m = 3$.\n- Case B (large neighborhood radius merges states): $\\varepsilon = 5.0$ Å, $m = 3$.\n- Case C (strict core definition yields no clusters): $\\varepsilon = 0.5$ Å, $m = 30$.\n\nRequired program output:\n\n- Your program must produce a single line containing the number of clusters (excluding noise) found for each of the three cases, in order A, B, C, as a comma-separated list enclosed in square brackets. For example, the format must be exactly like $[\\text{result}_A,\\text{result}_B,\\text{result}_C]$ with integers. No other output is permitted.", "solution": "The problem statement is critically validated and is deemed **valid**. It is scientifically grounded, well-posed, objective, and provides a complete, self-contained specification for a computational task in the field of molecular dynamics analysis. All required parameters, algorithms, and data generation procedures are defined with sufficient rigor to permit a unique and reproducible solution.\n\nThe task is to implement a complete workflow for identifying conformational substates from a synthetically generated molecular trajectory. This involves three main stages: first, the computation of two key structural metrics, the Radius of Gyration ($R_g$) and the Root Mean Square Deviation (RMSD), for each frame in the trajectory; second, the mapping of each frame to a point in a two-dimensional feature space defined by these metrics; and third, the application of a density-based clustering algorithm to group these points, thereby identifying the underlying conformational states.\n\n**Part 1: Calculation of Structural Metrics**\n\n**Radius of Gyration ($R_g$):**\nThe Radius of Gyration is a measure of the spatial extent of a set of particles. For a molecule with $N$ atoms of equal mass, each at Cartesian coordinates $Q_i \\in \\mathbb{R}^3$ for $i=1, \\dots, N$, the center of mass $C_Q$ is the geometric centroid:\n$$\nC_Q = \\frac{1}{N} \\sum_{i=1}^{N} Q_i\n$$\nThe Radius of Gyration, $R_g$, is then defined as the root mean square distance of the atoms from their center of mass:\n$$\nR_g = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} ||Q_i - C_Q||^2}\n$$\nA smaller $R_g$ value indicates a more compact structure, while a larger value suggests a more extended or unfolded conformation.\n\n**Root Mean Square Deviation (RMSD):**\nThe RMSD is a measure of the average distance between the atoms of two molecular structures, used to quantify their similarity. To compute a meaningful RMSD between a trajectory frame $Q$ and a reference structure $P$, one must first find the optimal rigid-body transformation (translation and rotation) that minimizes the distances between corresponding atoms. The translational component is eliminated by translating both structures so that their respective centers of mass are at the origin. Let the centered coordinates be $P'$ and $Q'$. The remaining problem is to find the rotation matrix $R \\in SO(3)$ that minimizes the sum of squared distances:\n$$\n\\sum_{i=1}^{N} ||R Q'_i - P'_i||^2\n$$\nThe solution to this minimization problem is well-known and is provided by the Kabsch algorithm. The algorithm proceeds as follows:\n1.  Compute the $3 \\times 3$ covariance matrix $H$ between the two sets of centered coordinates:\n    $$\n    H = (P')^T Q' = \\sum_{i=1}^{N} P'_i (Q'_i)^T\n    $$\n2.  Perform a Singular Value Decomposition (SVD) of the covariance matrix $H$:\n    $$\n    H = U S V^T\n    $$\n    where $U$ and $V$ are $3 \\times 3$ orthogonal matrices.\n3.  The optimal rotation matrix $R$ is calculated as $R = V U^T$. A correction is needed to ensure $R$ is a pure rotation and not a reflection, i.e., $\\det(R) = +1$. If $\\det(R) = -1$, the matrix represents an improper rotation (a reflection). This is corrected by inverting the sign of the column in $V$ corresponding to the smallest singular value. A robust method is to compute $R = V \\text{diag}(1, 1, \\det(V U^T)) U^T$.\n4.  Once the optimal rotation $R$ is found, the RMSD is calculated as the square root of the mean of the squared Euclidean distances between the atoms of the optimally superposed structures:\n    $$\n    \\text{RMSD}(P, Q) = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} ||R Q'_i - P'_i||^2}\n    $$\n    This value will be expressed in Ångström (Å).\n\n**Part 2: Generation of a Synthetic Trajectory and Feature Space**\n\nTo create a reproducible test bed, a synthetic trajectory is generated based on a reference structure $P$.\n1.  **Reference Structure $P$**: A chain of $N=12$ atoms is generated via a 3D random walk starting from the origin. Each step has a fixed length of $1.5$ Å in a random direction. The resulting structure is then centered at the origin. A fixed random seed of $42$ ensures reproducibility.\n2.  **Trajectory Frames**: A total of $60$ frames are generated, partitioned into three groups to simulate distinct conformational behaviors:\n    -   **$24$ Compact Frames**: These are generated by applying a random rotation to the reference structure $P$ and adding a small amount of Gaussian noise (standard deviation $\\sigma = 0.05$ Å) to each coordinate. These frames are structurally very similar to $P$ and are expected to have low $R_g$ and low RMSD values.\n    -   **$24$ Extended Frames**: These are created by first scaling $P$ by a factor of $1.6$, then applying a random rotation and adding Gaussian noise ($\\sigma = 0.05$ Å). The scaling ensures these frames are less compact than $P$, leading to higher $R_g$ values. Because RMSD calculation does not account for scaling, they will also have a significant RMSD with respect to $P$.\n    -   **$12$ Noise Frames**: These are structurally unrelated to $P$. Each is a new, independent random walk structure, with a larger amount of added noise ($\\sigma = 0.2$ Å). These frames are expected to have high and scattered RMSD and $R_g$ values.\n\nEach of the $60$ frames is then transformed into a two-dimensional data point $(\\text{RMSD}, R_g)$, forming the feature space for clustering.\n\n**Part 3: Density-Based Clustering**\n\nThe goal is to identify groups of conformationally similar structures, which should appear as dense clusters in the $(\\text{RMSD}, R_g)$ plane. The problem specifies a density-based clustering algorithm, functionally equivalent to DBSCAN (Density-Based Spatial Clustering of Applications with Noise). The algorithm operates on two parameters: a radius $\\varepsilon$ and a minimum number of neighbors $m$.\n1.  **Core Points**: A point is classified as a core point if its neighborhood (defined by a radius $\\varepsilon$ in the Euclidean metric of the feature space) contains at least $m$ points (including itself).\n2.  **Density-Reachability**: A point $q$ is directly density-reachable from a point $p$ if $q$ is within the $\\varepsilon$-neighborhood of $p$ and $p$ is a core point. Density-connectivity is the transitive closure of this relation.\n3.  **Cluster Formation**: A cluster is a set of points where every point is density-connected to at least one core point. The algorithm starts with an arbitrary unvisited point, checks if it is a core point, and if so, expands a new cluster by finding all points density-reachable from it.\n4.  **Noise**: Points that are not core points and are not density-reachable from any core point are classified as noise. These points do not belong to any cluster.\n\nThe number of clusters found (excluding noise) is the final output. The algorithm is run for three test cases with different $(\\varepsilon, m)$ parameters to probe its sensitivity:\n-   **Case A**: $(\\varepsilon, m) = (0.8, 3)$. This is expected to be a \"happy path\" that correctly identifies the two main clusters (compact and extended).\n-   **Case B**: $(\\varepsilon, m) = (5.0, 3)$. The large $\\varepsilon$ is expected to merge the two clusters into one.\n-   **Case C**: $(\\varepsilon, m) = (0.5, 30)$. The high requirement for $m$ is so strict that no point will qualify as a core point, resulting in zero clusters.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the entire process: data generation,\n    metric calculation, clustering, and final output.\n    \"\"\"\n    \n    # ------------------ Global Parameters ------------------\n    N_ATOMS = 12\n    STEP_LENGTH = 1.5  # Angstrom\n    RANDOM_SEED = 42\n    \n    N_COMPACT = 24\n    N_EXTENDED = 24\n    N_NOISE = 12\n    \n    COMPACT_NOISE_STD = 0.05\n    EXTENDED_NOISE_STD = 0.05\n    EXTENDED_SCALE_FACTOR = 1.6\n    RANDOM_FRAMES_NOISE_STD = 0.2\n    \n    TEST_CASES = [\n        # (epsilon, min_points)\n        (0.8, 3),  # Case A: Happy path\n        (5.0, 3),  # Case B: Merge states\n        (0.5, 30), # Case C: No clusters\n    ]\n\n    # Initialize the random number generator for reproducibility\n    rng = np.random.default_rng(RANDOM_SEED)\n\n    # ------------------ Helper Functions ------------------\n\n    def generate_random_walk(n_atoms, step_length):\n        \"\"\"Generates a 3D random walk structure.\"\"\"\n        coords = np.zeros((n_atoms, 3))\n        for i in range(1, n_atoms):\n            # Generate a random unit vector\n            vec = rng.standard_normal(3)\n            vec /= np.linalg.norm(vec)\n            coords[i] = coords[i-1] + step_length * vec\n        return coords\n\n    def get_centered_coords(coords):\n        \"\"\"Translates coordinates to have their center of mass at the origin.\"\"\"\n        com = np.mean(coords, axis=0)\n        return coords - com\n\n    def compute_rg(coords):\n        \"\"\"Computes the Radius of Gyration.\"\"\"\n        centered_coords = get_centered_coords(coords)\n        squared_dists = np.sum(centered_coords**2, axis=1)\n        return np.sqrt(np.mean(squared_dists))\n\n    def compute_rmsd(ref_coords, coords):\n        \"\"\"Computes the RMSD using the Kabsch algorithm.\"\"\"\n        ref_centered = get_centered_coords(ref_coords)\n        coords_centered = get_centered_coords(coords)\n        \n        # Covariance matrix\n        H = ref_centered.T @ coords_centered\n        \n        # SVD\n        U, _, Vt = np.linalg.svd(H)\n        \n        # Calculate rotation matrix with reflection correction\n        d = np.linalg.det(Vt.T @ U.T)\n        D = np.diag([1, 1, d])\n        R = Vt.T @ D @ U.T\n        \n        # Apply rotation\n        rotated_coords = coords_centered @ R.T\n        \n        # Calculate RMSD\n        diff = ref_centered - rotated_coords\n        return np.sqrt(np.sum(diff**2) / len(coords))\n\n    def dbscan_cluster(features, eps, min_pts):\n        \"\"\"\n        Performs density-based clustering based on problem specification.\n        Labels: 0 (unvisited), -1 (noise), >0 (cluster ID)\n        \"\"\"\n        n_points = features.shape[0]\n        labels = np.zeros(n_points, dtype=int)\n        cluster_id = 0\n        \n        # Pre-compute distance matrix for efficiency\n        dist_matrix = np.linalg.norm(features[:, np.newaxis, :] - features[np.newaxis, :, :], axis=2)\n\n        for i in range(n_points):\n            if labels[i] != 0:  # Already visited\n                continue\n            \n            # Find neighbors\n            neighbors_mask = dist_matrix[i] = eps\n            neighbor_indices = np.where(neighbors_mask)[0]\n\n            if len(neighbor_indices)  min_pts:\n                labels[i] = -1  # Mark as noise\n                continue\n                \n            # Core point found, start a new cluster\n            cluster_id += 1\n            labels[i] = cluster_id\n            \n            # Expand cluster\n            queue = deque(neighbor_indices)\n            while queue:\n                q_idx = queue.popleft()\n                \n                # if point was noise, it's now a border point of this cluster\n                if labels[q_idx] == -1:\n                    labels[q_idx] = cluster_id\n                \n                # if already processed, skip\n                if labels[q_idx] != 0:\n                    continue\n\n                labels[q_idx] = cluster_id\n                \n                # find neighbors of the new point\n                q_neighbors_mask = dist_matrix[q_idx] = eps\n                q_neighbor_indices = np.where(q_neighbors_mask)[0]\n\n                # if it's also a core point, add its neighbors to the queue\n                if len(q_neighbor_indices) >= min_pts:\n                    for nq_idx in q_neighbor_indices:\n                        if labels[nq_idx] == 0 or labels[nq_idx] == -1:\n                             if nq_idx not in queue:\n                                queue.append(nq_idx)\n\n        # Number of clusters is the count of unique positive cluster IDs\n        return len(np.unique(labels[labels > 0]))\n\n    # ------------------ Main Logic ------------------\n\n    # 1. Generate reference structure P\n    ref_structure = generate_random_walk(N_ATOMS, STEP_LENGTH)\n    ref_structure = get_centered_coords(ref_structure)\n\n    # 2. Generate trajectory frames\n    trajectory = []\n    # Compact frames\n    for _ in range(N_COMPACT):\n        rot = Rotation.random(random_state=rng).as_matrix()\n        frame = ref_structure @ rot.T\n        noise = rng.normal(0, COMPACT_NOISE_STD, size=frame.shape)\n        trajectory.append(frame + noise)\n        \n    # Extended frames\n    for _ in range(N_EXTENDED):\n        scaled_frame = ref_structure * EXTENDED_SCALE_FACTOR\n        rot = Rotation.random(random_state=rng).as_matrix()\n        frame = scaled_frame @ rot.T\n        noise = rng.normal(0, EXTENDED_NOISE_STD, size=frame.shape)\n        trajectory.append(frame + noise)\n        \n    # Noise frames\n    for _ in range(N_NOISE):\n        frame = generate_random_walk(N_ATOMS, STEP_LENGTH)\n        noise = rng.normal(0, RANDOM_FRAMES_NOISE_STD, size=frame.shape)\n        trajectory.append(frame + noise)\n\n    # 3. Compute features (RMSD, Rg) for each frame\n    feature_points = []\n    for frame in trajectory:\n        rmsd_val = compute_rmsd(ref_structure, frame)\n        rg_val = compute_rg(frame)\n        feature_points.append([rmsd_val, rg_val])\n    feature_points = np.array(feature_points)\n    \n    # 4. Run clustering for each test case\n    results = []\n    for eps, min_pts in TEST_CASES:\n        num_clusters = dbscan_cluster(feature_points, eps, min_pts)\n        results.append(num_clusters)\n        \n    # 5. Print final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2449058"}]}