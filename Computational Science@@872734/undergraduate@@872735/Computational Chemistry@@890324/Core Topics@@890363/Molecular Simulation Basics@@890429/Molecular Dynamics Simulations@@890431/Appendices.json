{"hands_on_practices": [{"introduction": "Molecular Dynamics simulations frequently use Periodic Boundary Conditions (PBC) to eliminate surface artifacts and approximate an infinite system. A critical component of PBC is the Minimum Image Convention (MIC), the rule for finding the shortest distance between two particles or their periodic images. This practice [@problem_id:2458300] will guide you through implementing this essential algorithm, providing a foundational skill for correctly calculating forces and analyzing distances in any simulation that uses PBC.", "problem": "You are to write a complete, runnable program that demonstrates the effect of the minimum image convention for periodic boundary conditions in molecular dynamics (MD) simulations. The program must compute the Euclidean distance between two particles in an orthorhombic periodic simulation box in two ways: (1) the naive Euclidean distance that ignores periodicity, and (2) the Euclidean distance after applying the minimum image convention. Distances must be expressed in nanometers (nm) and reported rounded to exactly six decimal places.\n\nBackground and fundamental basis: In molecular dynamics (MD) simulations with periodic boundary conditions (PBC), an infinite tiling of the finite simulation box is used to mimic bulk behavior. The physical distance between two particles is interpreted as the minimum distance between one particle and any periodic image of the other. The underlying geometric rule is derived from the definition of Euclidean distance and the translation symmetry of the lattice. For an orthorhombic box with side lengths $L_x$, $L_y$, and $L_z$, the minimum distance is obtained by selecting an integer number of box-length translations along each axis that minimizes the Euclidean norm of the displacement vector. Your program must implement this rule.\n\nYour task:\n- Define a function that, given two $3$-dimensional positions $\\mathbf{r}_i$ and $\\mathbf{r}_j$ in nanometers and box lengths $(L_x,L_y,L_z)$ in nanometers, returns two values:\n  1) the naive Euclidean distance $d_{\\text{naive}} = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert$ in nm,\n  2) the minimum image convention distance $d_{\\text{mic}}$ in nm, obtained by translating the displacement components by integer multiples of $(L_x,L_y,L_z)$ to minimize the norm.\n- Treat the box as orthorhombic and axis-aligned.\n- Positions may lie outside the primary box interval. Your implementation must still correctly compute $d_{\\text{mic}}$ using periodicity.\n- To make your implementation clear, also include within the program a multi-line pseudocode string (not printed) that outlines the minimum image convention logic you implemented.\n\nNumerical and unit requirements:\n- All distances must be in nanometers (nm).\n- Report distances rounded to exactly $6$ decimal places.\n\nTest suite:\nYour program must compute $[d_{\\text{naive}}, d_{\\text{mic}}]$ for each of the following $5$ test cases, in the stated order.\n\n1) Happy path, small separation well within the box:\n- Box: $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.5\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.5\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.7\\,\\text{nm},\\,1.2\\,\\text{nm},\\,1.6\\,\\text{nm}\\,)$\n\n2) Crossing a periodic boundary along one axis:\n- Box: $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.1\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.9\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n\n3) Anisotropic box and wrapping along multiple axes:\n- Box: $(L_x,L_y,L_z) = (\\,2.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,5.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,1.9\\,\\text{nm},\\,0.2\\,\\text{nm},\\,4.8\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.1\\,\\text{nm},\\,3.9\\,\\text{nm},\\,0.3\\,\\text{nm}\\,)$\n\n4) Exactly half-box separation along one axis (tie case):\n- Box: $(L_x,L_y,L_z) = (\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n\n5) Positions outside the primary box interval:\n- Box: $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm}\\,)$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of pairs enclosed in square brackets. Each pair corresponds to one test case in the specified order and must have the form $[d_{\\text{naive}},d_{\\text{mic}}]$, with both values rounded to exactly $6$ decimal places in nanometers. There must be no spaces in the output.\n- For example, the required overall format is like $[[a_1,b_1],[a_2,b_2],\\dots]$ where each $a_k$ and $b_k$ are floats in nanometers with exactly $6$ decimal places.", "solution": "The problem posed is a fundamental exercise in computational statistical mechanics, specifically concerning the implementation of periodic boundary conditions (PBC) in molecular dynamics (MD) simulations. The use of PBC is a standard and necessary technique to approximate the properties of a macroscopic system by simulating a small, finite number of particles. It mitigates the severe surface effects that would otherwise dominate the behavior of a small system. The core of this problem is the correct calculation of inter-particle distances, which is governed by the minimum image convention (MIC).\n\nThe problem is well-posed, scientifically grounded, and provides all necessary data for a unique and verifiable solution. We will proceed with a rigorous derivation and implementation.\n\nLet the orthorhombic simulation box be defined by a set of three orthogonal vectors corresponding to the side lengths, $\\mathbf{L} = (L_x, L_y, L_z)$. The position of two particles, $i$ and $j$, are given by vectors $\\mathbf{r}_i$ and $\\mathbf{r}_j$.\n\nFirst, we define the naive Euclidean distance, $d_{\\text{naive}}$. This is the standard distance in a non-periodic, three-dimensional Euclidean space. It is calculated from the norm of the displacement vector $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$.\n$$\nd_{\\text{naive}} = \\lVert \\Delta\\mathbf{r} \\rVert = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n$$\nwhere $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y, \\Delta z)$. This calculation ignores the periodic nature of the simulation box and treats the system as if it were isolated in a vacuum.\n\nSecond, we address the minimum image convention distance, $d_{\\text{mic}}$. In a periodic system, the simulation box is replicated infinitely in all directions. A particle at position $\\mathbf{r}$ has an infinite lattice of periodic images at positions $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$, where $n_x, n_y, n_z$ are any integers. The physical distance between particle $i$ and particle $j$ is the shortest distance between particle $i$ and *any* of the periodic images of particle $j$.\n\nMathematically, this is expressed as:\n$$\nd_{\\text{mic}} = \\min_{n_x, n_y, n_z \\in \\mathbb{Z}} \\left\\lVert (\\mathbf{r}_j - \\mathbf{r}_i) - (n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}) \\right\\rVert\n$$\nFor an orthorhombic box, the minimization of the norm can be performed independently for each Cartesian component. Let us consider the $x$-component of the displacement vector, $\\Delta x = x_j - x_i$. We must find an integer $n_x$ that minimizes $|\\Delta x - n_x L_x|$. This is achieved when $n_x$ is the integer nearest to the ratio $\\Delta x / L_x$. This is the \"nearest integer function,\" often denoted as $\\text{nint}(s)$ or implemented via `round(s)`.\n\nThe MIC-adjusted displacement component, $\\Delta x'$, is therefore:\n$$\n\\Delta x' = \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right)\n$$\nThis formula correctly \"wraps\" the displacement vector component into the interval $[-L_x/2, L_x/2]$. The same logic applies to the $y$ and $z$ components. The complete MIC-adjusted displacement vector, $\\Delta\\mathbf{r}'$, is then:\n$$\n\\Delta\\mathbf{r}' = \\left( \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right), \\Delta y - L_y \\cdot \\text{round}\\left(\\frac{\\Delta y}{L_y}\\right), \\Delta z - L_z \\cdot \\text{round}\\left(\\frac{\\Delta z}{L_z}\\right) \\right)\n$$\nThis vector operation is robust and correctly handles cases where particle coordinates may lie outside the primary simulation box, as only their relative displacement matters.\n\nThe minimum image distance, $d_{\\text{mic}}$, is the Euclidean norm of this adjusted displacement vector:\n$$\nd_{\\text{mic}} = \\lVert \\Delta\\mathbf{r}' \\rVert = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}\n$$\n\nThe provided test cases will be solved using this established methodology. The implementation will utilize the `numpy` library for efficient vector arithmetic. For each test case, we will compute $d_{\\text{naive}}$ and $d_{\\text{mic}}$ and report the results rounded to precisely $6$ decimal places as specified. The special case of a displacement of exactly half a box length, e.g., $\\Delta x = L_x/2$, is handled by the `round` function, which typically rounds to the nearest even integer (e.g., in `numpy`), but the resulting distance is uniquely $L_x/2$ regardless of the sign choice for the adjusted displacement. For $\\Delta x = L_x/2$, $\\Delta x' = L_x/2 - L_x \\cdot \\text{round}(0.5) = L_x/2 - L_x \\cdot 0 = L_x/2$. The magnitude is unambiguous.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating naive and minimum image convention (MIC)\n    distances for a set of test cases in a molecular dynamics context.\n    \"\"\"\n\n    # Per the problem specification, this multi-line string contains the\n    # pseudocode explaining the implemented MIC logic. It is not printed.\n    # noinspection PyUnusedLocal\n    MIC_PSEUDOCODE = \"\"\"\n    function calculate_minimum_image_distance(r_i, r_j, box_dims):\n        // r_i, r_j: 3D position vectors [x, y, z] of two particles in nm.\n        // box_dims: 3D vector of orthorhombic box lengths [L_x, L_y, L_z] in nm.\n\n        // 1. Calculate the raw displacement vector.\n        //    This is a simple vector subtraction.\n        delta_r = r_j - r_i\n\n        // 2. Apply the minimum image convention to each component of the displacement vector.\n        //    For an orthorhombic box, this can be done independently for each axis.\n        //    The principle is to find the closest periodic image by shifting the displacement\n        //    by an integer number of box lengths. This is mathematically equivalent to\n        //    finding the nearest integer multiple of the box length to subtract.\n        \n        //    Let dr_c be a component of delta_r (e.g., delta_x) and L_c be the\n        //    corresponding box length (e.g., L_x).\n        //    The scaled displacement is s = dr_c / L_c.\n        //    The nearest integer number of box lengths to shift by is n = round(s).\n        //    The MIC-adjusted displacement component is dr'_c = dr_c - n * L_c.\n\n        //    In vector notation, this is:\n        mic_delta_r = delta_r - box_dims * np.round(delta_r / box_dims)\n        \n        // 3. Calculate the Euclidean norm (length) of the MIC-adjusted displacement vector.\n        //    This is the final minimum image distance.\n        distance_mic = sqrt(mic_delta_r[0]^2 + mic_delta_r[1]^2 + mic_delta_r[2]^2)\n        \n        return distance_mic\n    \"\"\"\n\n    def compute_distances(r_i_tuple, r_j_tuple, box_dims_tuple):\n        \"\"\"\n        Calculates naive and MIC distances for a single pair of particles.\n        \n        Args:\n            r_i_tuple (tuple): Position of particle i.\n            r_j_tuple (tuple): Position of particle j.\n            box_dims_tuple (tuple): Orthorhombic box dimensions (Lx, Ly, Lz).\n        \n        Returns:\n            A list containing two floats: [d_naive, d_mic].\n        \"\"\"\n        r_i = np.array(r_i_tuple, dtype=float)\n        r_j = np.array(r_j_tuple, dtype=float)\n        box_dims = np.array(box_dims_tuple, dtype=float)\n\n        # 1. Naive Euclidean distance\n        delta_r_naive = r_j - r_i\n        d_naive = np.linalg.norm(delta_r_naive)\n\n        # 2. Minimum Image Convention (MIC) distance\n        # The logic delta_r - L * round(delta_r / L) correctly finds the\n        # shortest vector in a periodic lattice.\n        delta_r_mic = delta_r_naive - box_dims * np.round(delta_r_naive / box_dims)\n        d_mic = np.linalg.norm(delta_r_mic)\n        \n        return [d_naive, d_mic]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1) Happy path, small separation\n        {'r_i': (0.5, 1.0, 1.5), 'r_j': (0.7, 1.2, 1.6), 'box': (3.0, 3.0, 3.0)},\n        # 2) Crossing a periodic boundary\n        {'r_i': (0.1, 1.0, 1.0), 'r_j': (2.9, 1.0, 1.0), 'box': (3.0, 3.0, 3.0)},\n        # 3) Anisotropic box and multi-axis wrapping\n        {'r_i': (1.9, 0.2, 4.8), 'r_j': (0.1, 3.9, 0.3), 'box': (2.0, 4.0, 5.0)},\n        # 4) Exactly half-box separation\n        {'r_i': (0.0, 0.0, 0.0), 'r_j': (2.0, 0.0, 0.0), 'box': (4.0, 4.0, 4.0)},\n        # 5) Positions outside the primary box\n        {'r_i': (-0.1, -0.1, -0.1), 'r_j': (3.1, 3.1, 3.1), 'box': (3.0, 3.0, 3.0)},\n    ]\n\n    result_strings = []\n    for case in test_cases:\n        d_naive, d_mic = compute_distances(case['r_i'], case['r_j'], case['box'])\n        \n        # Format the numbers to exactly 6 decimal places and create the pair string.\n        # This ensures trailing zeros are included and meets the formatting requirement.\n        result_strings.append(f\"[{d_naive:.6f},{d_mic:.6f}]\")\n\n    # Final print statement in the exact required format: [[a1,b1],[a2,b2],...]\n    # without spaces between elements.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2458300"}, {"introduction": "Molecular Dynamics simulations propagate a system forward in time by numerically integrating Newton's equations of motion. The accuracy and stability of this integration depend critically on the chosen time step, $dt$. This exercise [@problem_id:2458247] demonstrates this fundamental principle by tasking you with finding the stability limit for a simple harmonic oscillator, a model for the fastest vibrations in a molecule. By observing how energy conservation breaks down as $dt$ increases, you will gain hands-on experience with a crucial parameter that every simulation practitioner must master.", "problem": "You are asked to implement a self-contained computational experiment, grounded in first principles, to study the time-step stability of a single one-dimensional harmonic mode that represents a stiff normal mode in a protein in Molecular Dynamics (MD). The system is a particle of mass $m$ confined to a harmonic potential with force constant $k$, evolving under Newton’s second law. Use reduced, dimensionless units throughout; do not attach physical units to any quantity.\n\nThe dynamics are defined by Newton’s second law, $m \\,\\ddot{x}(t) = - k \\, x(t)$, with initial conditions $x(0) = x_0$ and $\\dot{x}(0) = v_0$. The total energy is $E(t) = \\tfrac{1}{2} m \\,\\dot{x}(t)^2 + \\tfrac{1}{2} k \\, x(t)^2$. For a given discrete time step $dt$, simulate the motion for a total simulation time $T$ and monitor $E(t)$ during the trajectory.\n\nDefine an “explosion” for a chosen $dt$ to have occurred if any one of the following three events happens at any simulation step:\n- The computed total energy $E(t)$ becomes not finite (that is, not a real, finite number).\n- The relative energy error exceeds a specified tolerance, that is, $\\lvert E(t) - E(0) \\rvert / E(0)  \\varepsilon$ for any time $t$ up to the end of the simulation.\n- The magnitude of the position exceeds a prescribed bound derived from the initial energy, that is, $\\lvert x(t) \\rvert  B \\, A_0$ for any $t$, where $A_0 = \\sqrt{2 E(0)/k}$.\n\nFor each test case below, you are given the parameter set $(m, k, x_0, v_0, T, \\varepsilon, B)$ and an ordered list of time steps $[dt_1, dt_2, \\dots, dt_n]$. For each test case, simulate the system separately for each $dt_i$ in the given order and identify the smallest $dt_i$ in the list that leads to an explosion by the above definition. If none of the listed $dt_i$ leads to an explosion, return the sentinel value $-1.0$.\n\nUse the following four test cases. All symbols and numbers below are to be interpreted in reduced, dimensionless units.\n\nTest Case 1:\n- Parameters: $m = 1.0$, $k = 1.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 100.0$, $\\varepsilon = 0.20$, $B = 100.0$.\n- Time steps to test (in ascending order): $[0.1, 0.5, 1.5, 1.9, 2.0, 2.1]$.\n\nTest Case 2:\n- Parameters: $m = 1.0$, $k = 16.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 20.0$, $\\varepsilon = 0.10$, $B = 100.0$.\n- Time steps to test (in ascending order): $[0.05, 0.10, 0.30, 0.49, 0.50, 0.51]$.\n\nTest Case 3:\n- Parameters: $m = 2.0$, $k = 0.5$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 50.0$, $\\varepsilon = 0.05$, $B = 1000.0$.\n- Time steps to test (in ascending order): $[0.50, 1.00, 2.00, 3.00, 3.50]$.\n\nTest Case 4:\n- Parameters: $m = 1.0$, $k = 100.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 8.0$, $\\varepsilon = 0.15$, $B = 100.0$.\n- Time steps to test (in ascending order): $[0.02, 0.10, 0.19, 0.20, 0.25]$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be a floating-point number rounded to six decimal places, in the same order as the test cases above. For example, if the results for the four test cases are $r_1$, $r_2$, $r_3$, and $r_4$, your program must print exactly\n\"[r1,r2,r3,r4]\"\nwith each $r_i$ formatted to six decimal places and no additional text.\n\nAngle quantities, if any arise internally, must be treated in radians. All values in this problem are dimensionless by construction, so no physical units are to be displayed in the output.", "solution": "The problem requires a computational experiment to determine the stability limit of a numerical integration scheme for a one-dimensional harmonic oscillator, which serves as a model for a stiff vibrational mode in a molecular dynamics (MD) simulation. The problem is well-posed and scientifically grounded. It constitutes a direct test of numerical integration stability, a fundamental concept in computational science.\n\nThe system is described by the equation of motion for a simple harmonic oscillator:\n$$\nm \\frac{d^2x}{dt^2} = -k x(t)\n$$\nwhere $m$ is the mass, $k$ is the force constant, and $x(t)$ is the position. The angular frequency of this oscillator is $\\omega = \\sqrt{k/m}$. The dynamics are to be propagated from initial conditions $x(0) = x_0$ and $\\dot{x}(0) = v_0$ using a discrete time step $dt$.\n\nThe problem statement does not specify the numerical integration algorithm. For MD simulations of Newtonian mechanics, the Velocity-Verlet algorithm is a standard, widely-used, and robust choice due to its time-reversibility and symplectic nature, which leads to good long-term energy conservation properties. Therefore, the Velocity-Verlet integrator is the appropriate algorithm to implement.\n\nThe Velocity-Verlet algorithm consists of the following steps to advance the system from time $t$ to $t+dt$:\n1.  Compute the half-step velocity:\n    $$\n    v(t + \\tfrac{1}{2}dt) = v(t) + \\tfrac{1}{2} a(t) dt\n    $$\n2.  Update the position to the full new time step:\n    $$\n    x(t + dt) = x(t) + v(t + \\tfrac{1}{2}dt) dt\n    $$\n3.  Compute the acceleration at the new position. The acceleration is derived from the force $F(x) = -kx$, so $a(x) = F(x)/m = -(k/m)x$:\n    $$\n    a(t + dt) = -\\frac{k}{m} x(t + dt)\n    $$\n4.  Compute the full-step velocity at the new time:\n    $$\n    v(t + dt) = v(t + \\tfrac{1}{2}dt) + \\tfrac{1}{2} a(t + dt) dt\n    $$\n\nFor each test case, we are given a set of parameters $(m, k, x_0, v_0, T, \\varepsilon, B)$ and an ordered list of time steps $[dt_1, dt_2, \\dots]$. The task is to find the smallest $dt_i$ from this list for which the simulation becomes unstable or \"explodes.\" The simulation for a given $dt$ runs for a total time $T$, which corresponds to $N_{steps} = \\lfloor T/dt \\rfloor$ integration steps.\n\nBefore the simulation loop begins, we must establish the baseline for the explosion criteria. The initial total energy $E(0)$ is calculated as:\n$$\nE(0) = \\frac{1}{2} m v_0^2 + \\frac{1}{2} k x_0^2\n$$\nThe problem states that for all test cases, $x_0$, $v_0$, $m$, and $k$ are positive, ensuring $E(0)  0$. The characteristic amplitude $A_0$ is then defined as:\n$$\nA_0 = \\sqrt{\\frac{2 E(0)}{k}}\n$$\nThis $A_0$ represents the maximum displacement in the exact analytical solution.\n\nThe simulation proceeds by iterating the Velocity-Verlet algorithm for $N_{steps}$ times. After each step, we obtain the new state $(x(t+dt), v(t+dt))$ and check for the three explosion conditions:\n1.  **Finiteness of Energy**: The total energy at the new step, $E(t+dt) = \\frac{1}{2} m v(t+dt)^2 + \\frac{1}{2} k x(t+dt)^2$, must be a finite real number. Computationally, this is checked by verifying if the value is not `NaN` (Not a Number) or infinite. This condition detects catastrophic numerical overflow.\n2.  **Relative Energy Conservation**: The relative deviation of the current energy from the initial energy must not exceed a tolerance $\\varepsilon$.\n    $$\n    \\frac{\\lvert E(t+dt) - E(0) \\rvert}{E(0)}  \\varepsilon\n    $$\n    This condition detects when the numerical integration error leads to a significant, unphysical drift in the total energy, even if the trajectory has not yet diverged to infinity.\n3.  **Position Bound**: The magnitude of the position must not exceed a large multiple of the characteristic amplitude.\n    $$\n    \\lvert x(t+dt) \\rvert  B \\cdot A_0\n    $$\n    This is another practical check for trajectory divergence, where the particle escapes to unphysically large distances from the potential minimum.\n\nThe overall procedure for each test case is as follows:\nIterate through the provided list of time steps $dt_i$, which are sorted in ascending order. For each $dt_i$:\n- Run a full simulation for time $T$.\n- At every step of the simulation, check the three explosion conditions.\n- If any condition is met at any point during the simulation, the simulation for this $dt_i$ is deemed unstable. This $dt_i$ is the result for the test case, and we proceed to the next test case.\n- If the simulation completes for $T$ without any explosion, this $dt_i$ is considered stable. We then proceed to test the next $dt_i$ in the list.\n\nIf all time steps in the list for a given test case result in stable simulations, the result for that test case is the sentinel value $-1.0$.\n\nThe implementation will consist of a primary function that iterates through the test cases. This function will call a sub-function for each test case, which in turn iterates through the provided $dt$ values and calls a simulation function. The simulation function implements the Velocity-Verlet loop and the stability checks described above. The final output is a list of the smallest exploding $dt$ for each case, or $-1.0$ if none are found.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(m, k, x0, v0, T, epsilon, B, dt) - bool:\n    \"\"\"\n    Runs a simulation of a 1D harmonic oscillator using the Velocity-Verlet algorithm.\n\n    Args:\n        m (float): Mass.\n        k (float): Force constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        T (float): Total simulation time.\n        epsilon (float): Relative energy error tolerance.\n        B (float): Position bound factor.\n        dt (float): Time step.\n\n    Returns:\n        bool: True if an explosion occurs, False otherwise.\n    \"\"\"\n    if dt = 0:\n        return False  # A time step of zero or less is not meaningful.\n\n    num_steps = int(T / dt)\n    \n    # Initial conditions\n    x = float(x0)\n    v = float(v0)\n    \n    # Calculate initial energy and derived bounds for explosion criteria\n    e0 = 0.5 * m * v**2 + 0.5 * k * x**2\n    \n    # The problem constraints ensure e0  0, so no division by zero.\n    a0 = np.sqrt(2 * e0 / k)\n    x_bound = B * a0\n\n    # Initial acceleration\n    a = -(k / m) * x\n    \n    # Main simulation loop\n    for _ in range(num_steps):\n        # Velocity-Verlet integrator\n        # v(t + dt/2)\n        v_half = v + 0.5 * a * dt\n        # x(t + dt)\n        x = x + v_half * dt\n        # a(t + dt)\n        a_new = -(k / m) * x\n        # v(t + dt)\n        v = v_half + 0.5 * a_new * dt\n        \n        # Update acceleration for the next step\n        a = a_new\n        \n        # Calculate current energy at the full step\n        e_current = 0.5 * m * v**2 + 0.5 * k * x**2\n        \n        # --- Check for explosion conditions ---\n        \n        # 1. Non-finite energy (numerical overflow)\n        if not np.isfinite(e_current):\n            return True  # Explosion\n            \n        # 2. Relative energy error exceeds tolerance\n        # In the case e0 is 0, any change would be an infinite relative error.\n        # But for the given test cases, e0 is always positive.\n        if abs(e_current - e0) / e0  epsilon:\n            return True  # Explosion\n        \n        # 3. Position exceeds bound\n        if abs(x)  x_bound:\n            return True  # Explosion\n            \n    return False  # No explosion occurred\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            'params': (1.0, 1.0, 1.0, 1.0, 100.0, 0.20, 100.0),\n            'dts': [0.1, 0.5, 1.5, 1.9, 2.0, 2.1],\n        },\n        {\n            'params': (1.0, 16.0, 1.0, 1.0, 20.0, 0.10, 100.0),\n            'dts': [0.05, 0.10, 0.30, 0.49, 0.50, 0.51],\n        },\n        {\n            'params': (2.0, 0.5, 1.0, 1.0, 50.0, 0.05, 1000.0),\n            'dts': [0.50, 1.00, 2.00, 3.00, 3.50],\n        },\n        {\n            'params': (1.0, 100.0, 1.0, 1.0, 8.0, 0.15, 100.0),\n            'dts': [0.02, 0.10, 0.19, 0.20, 0.25],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, k, x0, v0, T, epsilon, B = case['params']\n        dts = case['dts']\n        \n        explosion_dt = -1.0\n        # The 'dts' lists are sorted, so we find the smallest by breaking on the first hit.\n        for dt in dts:\n            if run_simulation(m, k, x0, v0, T, epsilon, B, dt):\n                explosion_dt = dt\n                break\n        \n        results.append(f\"{explosion_dt:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2458247"}, {"introduction": "The output of a Molecular Dynamics simulation is a trajectory—a 'movie' of atomic motion from which scientific insights must be extracted. A common and vital task is to analyze intermolecular interactions, such as hydrogen bonds, which govern molecular recognition and structure. In this practice [@problem_id:2458278], you will learn to post-process a trajectory by implementing an analysis to detect hydrogen bonds based on geometric criteria and quantify their lifetimes. This exercise bridges the gap between simulation and interpretation, a core skill for deriving meaningful conclusions from computational experiments.", "problem": "You are given simplified molecular trajectory data for specific donor–hydrogen–acceptor triplets representing candidate hydrogen bonds in a protein–ligand complex. For each test case, you are provided the time step $\\Delta t$ in picoseconds, a distance cutoff $r_{\\mathrm{cut}}$ in Angstroms (denoted $\\mathrm{\\AA}$), and an angle cutoff $\\theta_{\\mathrm{cut}}$ in degrees. A hydrogen bond at frame index $i$ is defined to exist if and only if both of the following geometric criteria are satisfied:\n\n1. The hydrogen–acceptor distance satisfies $\\lVert \\mathbf{r}_{\\mathrm{A}}(i) - \\mathbf{r}_{\\mathrm{H}}(i) \\rVert \\le r_{\\mathrm{cut}}$ in $\\mathrm{\\AA}$.\n2. The donor–hydrogen–acceptor angle satisfies $\\angle \\mathrm{D}\\!-\\!\\mathrm{H}\\!-\\!\\mathrm{A}(i) \\ge \\theta_{\\mathrm{cut}}$ in degrees, where $\\angle \\mathrm{D}\\!-\\!\\mathrm{H}\\!-\\!\\mathrm{A}(i)$ is the angle at the hydrogen formed by the vectors $\\mathbf{u}(i) = \\mathbf{r}_{\\mathrm{D}}(i) - \\mathbf{r}_{\\mathrm{H}}(i)$ and $\\mathbf{v}(i) = \\mathbf{r}_{\\mathrm{A}}(i) - \\mathbf{r}_{\\mathrm{H}}(i)$ via\n$$\n\\angle \\mathrm{D}\\!-\\!\\mathrm{H}\\!-\\!\\mathrm{A}(i) = \\cos^{-1}\\!\\left(\\frac{\\mathbf{u}(i)\\cdot \\mathbf{v}(i)}{\\lVert \\mathbf{u}(i)\\rVert\\,\\lVert \\mathbf{v}(i)\\rVert}\\right)\\,.\n$$\n\nFor each test case, consider all provided target triplets (each triplet defines one candidate hydrogen bond tracked across frames). Define a continuous hydrogen-bond event as a maximal contiguous block of frames for which the bond condition is true. Let the duration of an event be the number of frames in the block multiplied by $\\Delta t$ and expressed in picoseconds. Over all triplets in the test case, pool every event from every triplet, and compute:\n\n- The average continuous lifetime in picoseconds, equal to the arithmetic mean of all event durations (define it to be $0$ if there are no events).\n- The longest continuous lifetime in picoseconds (define it to be $0$ if there are no events).\n- The total number of continuous events (an integer).\n- The survival fraction at lag $L=2$ frames, defined as the fraction of events whose continuous duration spans at least $L+1$ frames (that is, events with frame length $\\ge 3$). Express this as a decimal in $[0,1]$ (define it to be $0$ if there are no events).\n\nAngles must be treated in degrees, distances in $\\mathrm{\\AA}$, and lifetimes in picoseconds. Your program must use the following test suite and produce results in the required output format.\n\nTest Suite:\n\nTest case $1$:\n- $\\Delta t = 0.1$ ps, $r_{\\mathrm{cut}} = 2.5$ $\\mathrm{\\AA}$, $\\theta_{\\mathrm{cut}} = 150$ degrees.\n- Two triplets, each tracked for $10$ frames indexed $i = 0,1,\\dots,9$.\n- For both triplets in this test case and at every frame, the donor and hydrogen coordinates are constant: $\\mathbf{r}_{\\mathrm{D}}(i) = (0,0,0)$ $\\mathrm{\\AA}$ and $\\mathbf{r}_{\\mathrm{H}}(i) = (1,0,0)$ $\\mathrm{\\AA}$.\n- Triplet $1$ acceptor coordinates by frame:\n  $(2.0,0,0)$ $\\mathrm{\\AA}$ for $i=0,1,2$; $(5.0,0,0)$ $\\mathrm{\\AA}$ for $i=3$; $(2.2,0,0)$ $\\mathrm{\\AA}$ for $i=4,5,6$; $(5.0,0,0)$ $\\mathrm{\\AA}$ for $i=7,8,9$.\n- Triplet $2$ acceptor coordinates by frame:\n  bonded geometry with $\\mathbf{r}_{\\mathrm{A}}(i) = (2.2,0,0)$ $\\mathrm{\\AA}$ for frames $i \\in \\{0,1,3,6,7,8\\}$, and nonbonded angular geometry with $\\mathbf{r}_{\\mathrm{A}}(i) = (1.6,1.0392304845,0)$ $\\mathrm{\\AA}$ for frames $i \\in \\{2,4,5,9\\}$.\n\nTest case $2$:\n- $\\Delta t = 0.05$ ps, $r_{\\mathrm{cut}} = 2.5$ $\\mathrm{\\AA}$, $\\theta_{\\mathrm{cut}} = 150$ degrees.\n- One triplet, $5$ frames, with $\\mathbf{r}_{\\mathrm{D}}(i) = (0,0,0)$ $\\mathrm{\\AA}$, $\\mathbf{r}_{\\mathrm{H}}(i) = (1,0,0)$ $\\mathrm{\\AA}$, and $\\mathbf{r}_{\\mathrm{A}}(i) = (2.0,0,0)$ $\\mathrm{\\AA}$ for all $i$.\n\nTest case $3$:\n- $\\Delta t = 0.1$ ps, $r_{\\mathrm{cut}} = 2.5$ $\\mathrm{\\AA}$, $\\theta_{\\mathrm{cut}} = 150$ degrees.\n- One triplet, $6$ frames, with $\\mathbf{r}_{\\mathrm{D}}(i) = (0,0,0)$ $\\mathrm{\\AA}$, $\\mathbf{r}_{\\mathrm{H}}(i) = (1,0,0)$ $\\mathrm{\\AA}$, and $\\mathbf{r}_{\\mathrm{A}}(i) = (10.0,0,0)$ $\\mathrm{\\AA}$ for all $i$.\n\nTest case $4$:\n- $\\Delta t = 0.1$ ps, $r_{\\mathrm{cut}} = 2.5$ $\\mathrm{\\AA}$, $\\theta_{\\mathrm{cut}} = 150$ degrees.\n- One triplet, $8$ frames, with $\\mathbf{r}_{\\mathrm{D}}(i) = (0,0,0)$ $\\mathrm{\\AA}$, $\\mathbf{r}_{\\mathrm{H}}(i) = (1,0,0)$ $\\mathrm{\\AA}$, and acceptor coordinates alternating by frame: $\\mathbf{r}_{\\mathrm{A}}(i) = (2.2,0,0)$ $\\mathrm{\\AA}$ for even $i \\in \\{0,2,4,6\\}$ and $\\mathbf{r}_{\\mathrm{A}}(i) = (5.0,0,0)$ $\\mathrm{\\AA}$ for odd $i \\in \\{1,3,5,7\\}$.\n\nAnswer specification and units:\n- Report the average lifetime in picoseconds as a float.\n- Report the longest lifetime in picoseconds as a float.\n- Report the number of events as an integer.\n- Report the survival fraction at lag $L=2$ as a decimal in $[0,1]$ (not a percentage).\n- Your program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, where each element is a list in the order [average_lifetime_ps, longest_lifetime_ps, number_of_events, survival_fraction]. For example: \"[[a1,b1,c1,d1],[a2,b2,c2,d2],[a3,b3,c3,d3],[a4,b4,c4,d4]]\".", "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded in the principles of computational chemistry, specifically the analysis of molecular dynamics trajectories. The problem is well-posed, with all necessary data and definitions provided, ensuring a unique and computable solution. The language is objective and precise, free from ambiguity or contradiction. We may therefore proceed with a formal solution.\n\nThe task is to analyze simplified molecular trajectory data to characterize the dynamics of hydrogen bonds. This involves calculating several statistical metrics: the average continuous lifetime, the longest continuous lifetime, the total number of bonding events, and a survival fraction. The solution requires a systematic, frame-by-frame analysis for each candidate hydrogen bond (triplet), followed by an aggregation of results across all triplets within a given test case.\n\nThe algorithm proceeds as follows:\n\nFirst, for each test case, we initialize a global list to accumulate the durations of all continuous hydrogen-bond events. We then iterate through each donor–hydrogen–acceptor triplet provided.\n\nFor a single triplet, we must first determine, for each frame $i$, whether a hydrogen bond exists. This is done by checking two geometric criteria against the given cutoff values, $r_{\\mathrm{cut}}$ and $\\theta_{\\mathrm{cut}}$.\n\n1.  **Geometric Criteria Evaluation**:\n    For each frame $i$, we are given the coordinates of the donor atom $\\mathbf{r}_{\\mathrm{D}}(i)$, hydrogen atom $\\mathbf{r}_{\\mathrm{H}}(i)$, and acceptor atom $\\mathbf{r}_{\\mathrm{A}}(i)$.\n    \n    a. We define two vectors originating from the hydrogen atom: $\\mathbf{u}(i) = \\mathbf{r}_{\\mathrm{D}}(i) - \\mathbf{r}_{\\mathrm{H}}(i)$ pointing to the donor, and $\\mathbf{v}(i) = \\mathbf{r}_{\\mathrm{A}}(i) - \\mathbf{r}_{\\mathrm{H}}(i)$ pointing to the acceptor.\n    \n    b. The first criterion is the hydrogen–acceptor distance. We calculate the Euclidean norm of vector $\\mathbf{v}(i)$, denoted $d_{\\mathrm{HA}}(i) = \\lVert \\mathbf{v}(i) \\rVert$. A bond is possible only if $d_{\\mathrm{HA}}(i) \\le r_{\\mathrm{cut}}$.\n    \n    c. The second criterion is the donor–hydrogen–acceptor angle, $\\angle \\mathrm{D}\\!-\\!\\mathrm{H}\\!-\\!\\mathrm{A}(i)$. This is the angle between vectors $\\mathbf{u}(i)$ and $\\mathbf{v}(i)$, computed using the dot product formula:\n    $$\n    \\angle \\mathrm{D}\\!-\\!\\mathrm{H}\\!-\\!\\mathrm{A}(i) = \\arccos\\left(\\frac{\\mathbf{u}(i)\\cdot \\mathbf{v}(i)}{\\lVert \\mathbf{u}(i)\\rVert\\,\\lVert \\mathbf{v}(i)\\rVert}\\right)\n    $$\n    The result from the `arccos` function is in radians and must be converted to degrees for comparison with $\\theta_{\\mathrm{cut}}$. The conversion is $\\text{angle}_{\\text{deg}} = \\text{angle}_{\\text{rad}} \\times \\frac{180}{\\pi}$. A bond is possible only if $\\angle \\mathrm{D}\\!-\\!\\mathrm{H}\\!-\\!\\mathrm{A}(i) \\ge \\theta_{\\mathrm{cut}}$.\n\n    A hydrogen bond exists at frame $i$ if and only if both conditions are met. This process generates a boolean time series for each triplet, where each element indicates the presence ($True$) or absence ($False$) of the hydrogen bond at that frame.\n\n2.  **Identification of Continuous Events**:\n    A \"continuous hydrogen-bond event\" is a maximal contiguous block of frames where the bond exists. To find the lengths of these events, we analyze the boolean time series. An effective method is to find the indices where the state changes. By padding the boolean series with $False$ at the beginning and end, we can reliably identify the start and end of each run of $True$ values. The difference between the end and start indices gives the length of each continuous event in frames. For a boolean array `B`, we construct a padded integer array `P`. The start indices of events correspond to positions where `diff(P)` is $1$, and end indices where `diff(P)` is $-1$. The lengths are then calculated from these corresponding indices. The lengths of all such events for the current triplet are added to the global list of event durations for the test case.\n\n3.  **Calculation of Final Metrics**:\n    After processing all triplets in a test case, we have a list of all event lengths, measured in frames. Let this list be $L_{\\text{frames}}$.\n\n    a. **Handle the Null Case**: If no events were found ($L_{\\text{frames}}$ is empty), the average lifetime, longest lifetime, number of events, and survival fraction are all defined to be $0$.\n\n    b. **Convert to Physical Units**: If events exist, we first convert the frame lengths to lifetimes in picoseconds by multiplying each length by the time step, $\\Delta t$. Let this new list be $L_{\\text{ps}}$.\n    \n    c. **Average and Longest Lifetime**: The average continuous lifetime is the arithmetic mean of the values in $L_{\\text{ps}}$. The longest continuous lifetime is the maximum value in $L_{\\text{ps}}$.\n    \n    d. **Total Number of Events**: This is simply the total count of events found, which is the length of the list $L_{\\text{frames}}$.\n    \n    e. **Survival Fraction**: We are asked for the survival fraction at lag $L=2$. This is the fraction of events that persist for at least $L+1 = 3$ frames. We count the number of elements in $L_{\\text{frames}}$ that are greater than or equal to $3$ and divide this count by the total number of events.\n\nThis entire procedure is encapsulated into a function that is applied to each test case defined in the problem statement. The results for each case are collected and formatted into the specified string output. The use of the `numpy` library is essential for efficient and accurate vector algebra.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the hydrogen bond analysis problem for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"dt\": 0.1, \"rcut\": 2.5, \"thcut\": 150.0,\n            \"triplets\": [\n                {\n                    \"rD\": np.array([[0.0, 0.0, 0.0]] * 10),\n                    \"rH\": np.array([[1.0, 0.0, 0.0]] * 10),\n                    \"rA\": np.array([\n                        [2.0, 0.0, 0.0], [2.0, 0.0, 0.0], [2.0, 0.0, 0.0],  # 0,1,2\n                        [5.0, 0.0, 0.0],  # 3\n                        [2.2, 0.0, 0.0], [2.2, 0.0, 0.0], [2.2, 0.0, 0.0],  # 4,5,6\n                        [5.0, 0.0, 0.0], [5.0, 0.0, 0.0], [5.0, 0.0, 0.0]   # 7,8,9\n                    ])\n                },\n                {\n                    \"rD\": np.array([[0.0, 0.0, 0.0]] * 10),\n                    \"rH\": np.array([[1.0, 0.0, 0.0]] * 10),\n                    \"rA\": np.array([\n                        [2.2, 0.0, 0.0],                            # 0\n                        [2.2, 0.0, 0.0],                            # 1\n                        [1.6, 1.0392304845, 0.0],                   # 2\n                        [2.2, 0.0, 0.0],                            # 3\n                        [1.6, 1.0392304845, 0.0],                   # 4\n                        [1.6, 1.0392304845, 0.0],                   # 5\n                        [2.2, 0.0, 0.0],                            # 6\n                        [2.2, 0.0, 0.0],                            # 7\n                        [2.2, 0.0, 0.0],                            # 8\n                        [1.6, 1.0392304845, 0.0]                    # 9\n                    ])\n                }\n            ]\n        },\n        {\n            \"dt\": 0.05, \"rcut\": 2.5, \"thcut\": 150.0,\n            \"triplets\": [\n                {\n                    \"rD\": np.array([[0.0, 0.0, 0.0]] * 5),\n                    \"rH\": np.array([[1.0, 0.0, 0.0]] * 5),\n                    \"rA\": np.array([[2.0, 0.0, 0.0]] * 5)\n                }\n            ]\n        },\n        {\n            \"dt\": 0.1, \"rcut\": 2.5, \"thcut\": 150.0,\n            \"triplets\": [\n                {\n                    \"rD\": np.array([[0.0, 0.0, 0.0]] * 6),\n                    \"rH\": np.array([[1.0, 0.0, 0.0]] * 6),\n                    \"rA\": np.array([[10.0, 0.0, 0.0]] * 6)\n                }\n            ]\n        },\n        {\n            \"dt\": 0.1, \"rcut\": 2.5, \"thcut\": 150.0,\n            \"triplets\": [\n                {\n                    \"rD\": np.array([[0.0, 0.0, 0.0]] * 8),\n                    \"rH\": np.array([[1.0, 0.0, 0.0]] * 8),\n                    \"rA\": np.array([\n                        [2.2, 0.0, 0.0], [5.0, 0.0, 0.0],\n                        [2.2, 0.0, 0.0], [5.0, 0.0, 0.0],\n                        [2.2, 0.0, 0.0], [5.0, 0.0, 0.0],\n                        [2.2, 0.0, 0.0], [5.0, 0.0, 0.0]\n                    ])\n                }\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = analyze_case(case[\"dt\"], case[\"rcut\"], case[\"thcut\"], case[\"triplets\"])\n        all_results.append(result)\n    \n    # Format the final output string exactly as specified.\n    # The map(str, ...) converts each sublist like [0.24, 0.3, 5, 0.6] into its string representation.\n    # The join function then concatenates them with commas.\n    print(f\"[{','.join(map(str, all_results))}]\", end=\"\")\n\n\ndef get_run_lengths(bool_array):\n    \"\"\"\n    Calculates the lengths of contiguous runs of True values in a boolean array.\n    This is a form of run-length encoding.\n    \"\"\"\n    if not np.any(bool_array):\n        return []\n    \n    # Pad the array with False at both ends to ensure runs at the start/end are captured.\n    padded = np.concatenate(([False], bool_array, [False]))\n    \n    # Convert to integer (0 or 1) to use np.diff\n    int_array = padded.astype(int)\n    \n    # Find indices where the sequence changes\n    diffs = np.diff(int_array)\n    \n    # Starts of runs are where the difference is +1 (False - True)\n    starts = np.where(diffs == 1)[0]\n    \n    # Ends of runs are where the difference is -1 (True - False)\n    ends = np.where(diffs == -1)[0]\n    \n    # The length of each run is the difference between its end and start index.\n    lengths = ends - starts\n    return lengths.tolist()\n\ndef analyze_case(dt, rcut, thcut, triplets_data):\n    \"\"\"\n    Analyzes a single test case to compute hydrogen bond statistics.\n    \"\"\"\n    all_event_frame_lengths = []\n\n    for triplet in triplets_data:\n        rD, rH, rA = triplet[\"rD\"], triplet[\"rH\"], triplet[\"rA\"]\n        num_frames = rD.shape[0]\n        \n        is_hbond_series = np.zeros(num_frames, dtype=bool)\n\n        for i in range(num_frames):\n            u = rD[i] - rH[i]  # Vector H - D\n            v = rA[i] - rH[i]  # Vector H - A\n\n            # Check distance criterion\n            dist_ha = np.linalg.norm(v)\n            if dist_ha  rcut:\n                continue\n\n            # Check angle criterion\n            # Handle potential zero-length vectors to avoid division by zero\n            norm_u = np.linalg.norm(u)\n            norm_v = dist_ha # already computed\n            if norm_u == 0 or norm_v == 0:\n                continue\n            \n            cos_theta = np.dot(u, v) / (norm_u * norm_v)\n            # Clip to handle floating point inaccuracies that may push cos_theta outside [-1, 1]\n            cos_theta = np.clip(cos_theta, -1.0, 1.0)\n            \n            angle_rad = np.arccos(cos_theta)\n            angle_deg = np.rad2deg(angle_rad)\n\n            if angle_deg = thcut:\n                is_hbond_series[i] = True\n        \n        event_lengths = get_run_lengths(is_hbond_series)\n        all_event_frame_lengths.extend(event_lengths)\n    \n    # Calculate final metrics\n    num_events = len(all_event_frame_lengths)\n    \n    if num_events == 0:\n        return [0.0, 0.0, 0, 0.0]\n\n    # Convert frame lengths to picoseconds\n    event_durations_ps = np.array(all_event_frame_lengths) * dt\n\n    avg_lifetime = np.mean(event_durations_ps)\n    longest_lifetime = np.max(event_durations_ps)\n\n    # Survival fraction for lag L=2 (duration = L+1=3 frames)\n    surviving_events = np.sum(np.array(all_event_frame_lengths) = 3)\n    survival_fraction = surviving_events / num_events\n\n    return [round(avg_lifetime, 6), round(longest_lifetime, 6), int(num_events), round(survival_fraction, 6)]\n\n# Execute the main function\nsolve()\n```", "id": "2458278"}]}