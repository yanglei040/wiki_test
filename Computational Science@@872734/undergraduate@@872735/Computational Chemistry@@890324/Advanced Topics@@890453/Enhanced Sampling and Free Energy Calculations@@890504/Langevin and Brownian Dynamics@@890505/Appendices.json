{"hands_on_practices": [{"introduction": "A cornerstone of chemical physics is understanding reaction rates. This practice provides a direct, computational approach by modeling a reaction as a particle escaping from a potential well, driven by thermal noise. By simulating this process using overdamped Langevin dynamics, you will compute the Mean First Passage Time (MFPT) and explore its dependence on temperature and barrier height, offering a tangible link between microscopic fluctuations and macroscopic kinetics [@problem_id:2457132].", "problem": "A single particle undergoes isothermal overdamped Langevin dynamics in one dimension inside a quartic potential well with a single barrier separating two minima. You are asked to compute the Mean First Passage Time (MFPT) for the particle to escape from the left well by crossing the barrier top at the origin, and to explore its dependence on barrier height and temperature by direct numerical simulation.\n\nFundamental physical base. Use Newton’s second law reduced to the overdamped limit together with the Fluctuation–Dissipation Theorem (FDT). In the overdamped regime, the position process $x(t)$ satisfies the stochastic differential equation\n$$\n\\gamma \\,\\dot{x}(t) = -\\frac{dU}{dx}(x(t)) + \\sqrt{2\\,\\gamma\\,k_{B}\\,T}\\,\\xi(t),\n$$\nwhere $\\gamma$ is the friction coefficient, $U(x)$ is the potential energy, $k_B$ is the Boltzmann constant, $T$ is the absolute temperature, and $\\xi(t)$ is Gaussian white noise with zero mean and delta correlation.\n\nPotential energy. Let the potential energy be\n$$\nU(x;H,L)= H\\left[\\left(\\frac{x}{L}\\right)^{4}-2\\left(\\frac{x}{L}\\right)^{2}\\right],\n$$\nwith barrier height parameter $H>0$ and length scale $L>0$. This potential has minima near $x=\\pm L$ and a barrier top at $x=0$. The barrier height relative to the well minima is exactly $H$, because $U(0)=0$ and $U(\\pm L)=-H$.\n\nEscape event. The particle starts at $x(0)=-L$ and the escape event is defined as the first time $\\tau$ such that $x(\\tau)\\ge 0$. The Mean First Passage Time (MFPT) is the expectation $\\mathbb{E}[\\tau]$.\n\nDiscretization. Use the Euler–Maruyama time discretization for the overdamped Langevin equation,\n$$\nx_{n+1} = x_{n} + \\frac{\\Delta t}{\\gamma}\\,F(x_{n}) + \\sqrt{\\frac{2\\,k_B\\,T\\,\\Delta t}{\\gamma}}\\,\\eta_{n},\n$$\nwhere $F(x)=-\\frac{dU}{dx}(x)$ is the deterministic force, $\\Delta t$ is the time step, and $\\eta_{n}\\sim \\mathcal{N}(0,1)$ are independent standard normal random variables. The force for the specified potential is\n$$\nF(x)= -\\frac{dU}{dx}(x)= -H\\left[\\frac{4x^{3}}{L^{4}}-\\frac{4x}{L^{2}}\\right] = \\frac{4H}{L^{2}}\\left(x-\\frac{x^{3}}{L^{2}}\\right).\n$$\n\nNumerical experiment design. For each parameter set, simulate $N$ independent trajectories starting at $x_0=-L$ and advance them in time with fixed $\\Delta t$ until each trajectory first satisfies $x\\ge 0$ or a maximum time $t_{\\max}$ is reached. Estimate the MFPT by the sample mean of the recorded first-passage times over the trajectories that escaped. If no trajectory escapes before $t_{\\max}$, return $t_{\\max}$ as a conservative estimate.\n\nPhysical parameters and units. Use the following fixed parameters for all test cases:\n- Boltzmann constant $k_B = 1.380\\,649\\times 10^{-23}\\ \\mathrm{J\\,K^{-1}}$.\n- Friction coefficient $\\gamma = 1.0\\times 10^{-12}\\ \\mathrm{kg\\,s^{-1}}$.\n- Length scale $L=1.0\\times 10^{-9}\\ \\mathrm{m}$.\n- Time step $\\Delta t = 5.0\\times 10^{-14}\\ \\mathrm{s}$.\n- Number of trajectories $N=64$.\n- Maximum simulated time $t_{\\max}=1.0\\times 10^{-7}\\ \\mathrm{s}$.\nAll answers for times must be expressed in seconds ($\\mathrm{s}$).\n\nBarrier height specification. The barrier height $H$ for each test case is specified relative to the thermal energy at a reference temperature $T_{\\mathrm{ref}}=300\\ \\mathrm{K}$ by\n$$\nH = h k_B T_{\\mathrm{ref}},\n$$\nwhere $h$ is a dimensionless multiplier provided per test case.\n\nTest suite. Run the program for the following parameter sets $(h, T)$:\n- Case A (happy path): $(h, T) = (2.0, 300.0\\ \\mathrm{K})$.\n- Case B (higher barrier at same temperature): $(h, T) = (4.0, 300.0\\ \\mathrm{K})$.\n- Case C (same barrier as Case B but higher temperature): $(h, T) = (4.0, 600.0\\ \\mathrm{K})$.\n- Case D (small barrier edge case): $(h, T) = (0.5, 300.0\\ \\mathrm{K})$.\n\nWhat to compute. For each case, compute the estimated MFPT (in $\\mathrm{s}$) as a floating-point number using the described simulation. Use a fixed random seed so that results are reproducible.\n\nFinal output format. Your program should produce a single line of output containing the four MFPT estimates in the order A, B, C, D as a comma-separated list enclosed in square brackets (for example, \"[tA,tB,tC,tD]\"), where each entry is a floating-point number in $\\mathrm{s}$.", "solution": "We begin from first principles appropriate to overdamped stochastic dynamics in computational chemistry. Newton’s second law states that for a particle of mass $m$ in one dimension,\n$$\nm\\,\\ddot{x}(t)= -\\frac{dU}{dx}(x(t)) - \\gamma\\,\\dot{x}(t) + R(t),\n$$\nwhere $-\\frac{dU}{dx}$ is the deterministic conservative force from the potential energy $U(x)$, $-\\gamma \\dot{x}$ is the viscous drag in a continuum solvent, and $R(t)$ is a random force from thermal fluctuations. In the overdamped limit, the inertial term $m\\,\\ddot{x}(t)$ is negligible compared to friction, leading to\n$$\n\\gamma \\,\\dot{x}(t)= -\\frac{dU}{dx}(x(t)) + R(t).\n$$\nThe Fluctuation–Dissipation Theorem (FDT) connects the random force statistics to the friction and temperature, implying that $R(t)$ is a zero-mean Gaussian white noise with autocorrelation $\\langle R(t)R(t')\\rangle = 2\\,\\gamma\\,k_B\\,T\\,\\delta(t-t')$. Writing $R(t)$ as $\\sqrt{2\\,\\gamma\\,k_B\\,T}\\,\\xi(t)$, with $\\xi(t)$ a standard white noise, yields the overdamped Langevin stochastic differential equation\n$$\n\\gamma \\,\\dot{x}(t)= -\\frac{dU}{dx}(x(t)) + \\sqrt{2\\,\\gamma\\,k_B\\,T}\\,\\xi(t).\n$$\n\nTo simulate this stochastic differential equation numerically, we use the Euler–Maruyama method, which discretizes time with a step $\\Delta t$ and updates the position according to\n$$\nx_{n+1} = x_{n} + \\frac{\\Delta t}{\\gamma}\\,F(x_{n}) + \\sqrt{\\frac{2\\,k_B\\,T\\,\\Delta t}{\\gamma}}\\,\\eta_{n},\n$$\nwhere $F(x)=-\\frac{dU}{dx}(x)$ and $\\eta_{n}\\sim \\mathcal{N}(0,1)$ are independent standard normal variables. This integrator is derived by integrating the stochastic differential equation over a small time interval and approximating the drift and diffusion terms to first order in $\\Delta t$.\n\nWe define the potential energy as\n$$\nU(x;H,L)= H\\left[\\left(\\frac{x}{L}\\right)^{4}-2\\left(\\frac{x}{L}\\right)^{2}\\right],\n$$\nwhich has minima at $x=\\pm L$ with value $U(\\pm L)=-H$ and a barrier top at $x=0$ with value $U(0)=0$. Hence, the barrier height relative to the well bottom is exactly $H$. The deterministic force is the negative gradient,\n$$\nF(x)=-\\frac{dU}{dx}(x) = -H\\left[\\frac{4x^{3}}{L^{4}}-\\frac{4x}{L^{2}}\\right] = \\frac{4H}{L^{2}}\\left(x-\\frac{x^{3}}{L^{2}}\\right).\n$$\n\nThe escape event is defined as the first time $\\tau$ when $x(\\tau)\\ge 0$ for a trajectory that starts at $x(0)=-L$. We estimate the Mean First Passage Time (MFPT), $\\mathbb{E}[\\tau]$, by simulating $N$ independent trajectories and computing the sample mean of the first-passage times among those that escape before a cap time $t_{\\max}$. This estimator is unbiased in the limit $N\\to\\infty$ and $\\Delta t\\to 0$.\n\nAlgorithmic design:\n1. Choose physical constants and parameters: Boltzmann constant $k_B = 1.380\\,649\\times 10^{-23}\\ \\mathrm{J\\,K^{-1}}$, friction coefficient $\\gamma = 1.0\\times 10^{-12}\\ \\mathrm{kg\\,s^{-1}}$, length scale $L=1.0\\times 10^{-9}\\ \\mathrm{m}$, time step $\\Delta t = 5.0\\times 10^{-14}\\ \\mathrm{s}$, number of trajectories $N=64$, and maximum simulated time $t_{\\max}=1.0\\times 10^{-7}\\ \\mathrm{s}$. These values render the Euler–Maruyama method stable and yield escape times that are computationally tractable while remaining scientifically plausible for nanoscale systems in a viscous solvent.\n2. For each test case, compute the absolute barrier height\n$$\nH = h\\,k_B\\,T_{\\mathrm{ref}},\\quad T_{\\mathrm{ref}}=300\\ \\mathrm{K},\n$$\nfrom the given dimensionless multiplier $h$ and simulate at the specified temperature $T$.\n3. Initialize $N$ walkers at $x_0=-L$ and $t=0$. For all walkers that have not yet escaped (those with $x0$), update their positions using the Euler–Maruyama step. After each step, record the current time for those walkers that newly satisfy $x\\ge 0$; mark them as escaped and exclude them from further updates.\n4. Continue until all walkers escape or $t\\ge t_{\\max}$. Compute the MFPT as the arithmetic mean of the recorded first-passage times among the escaped walkers. If no walker escapes, return $t_{\\max}$.\n5. Use a fixed random seed to ensure replicability of the results.\n\nRationale and expectations. The Kramers escape-rate theory for overdamped dynamics predicts an approximate mean escape time that scales as\n$$\n\\mathrm{MFPT}\\propto \\frac{\\gamma}{\\sqrt{U''(x_{\\mathrm{m}})\\lvert U''(x_{\\mathrm{b}})\\rvert}} \\exp\\!\\left(\\frac{H}{k_B T}\\right),\n$$\nwhere $x_{\\mathrm{m}}$ is the well minimum and $x_{\\mathrm{b}}$ is the barrier top. For the quartic potential, $U''(\\pm L)=\\frac{8H}{L^{2}}$ and $U''(0)=-\\frac{4H}{L^{2}}$, so the prefactor scales as $\\gamma L^{2}/H$, while the dominant dependence is the exponential in $H/(k_B T)$. Our test suite is designed to verify qualitatively that increasing $H$ at fixed $T$ increases the MFPT, while increasing $T$ at fixed $H$ decreases the MFPT.\n\nNumerical outputs. For the four cases:\n- Case A: $(h, T) = (2.0, 300.0\\ \\mathrm{K})$.\n- Case B: $(h, T) = (4.0, 300.0\\ \\mathrm{K})$.\n- Case C: $(h, T) = (4.0, 600.0\\ \\mathrm{K})$.\n- Case D: $(h, T) = (0.5, 300.0\\ \\mathrm{K})$.\ncompute the MFPT in seconds and output as a single line in the format \"[tA,tB,tC,tD]\". All times must be in $\\mathrm{s}$, and each entry must be a floating-point number.", "answer": "```python\nimport numpy as np\n\ndef simulate_mfpt(h_multiplier, T, rng, params):\n    \"\"\"\n    Simulate MFPT for overdamped Langevin dynamics in a quartic double-well potential.\n    h_multiplier: dimensionless barrier height multiplier relative to k_B*T_ref.\n    T: absolute temperature in K.\n    rng: numpy random Generator for reproducibility.\n    params: dict of physical and numerical parameters.\n    Returns: estimated MFPT (float, seconds).\n    \"\"\"\n    # Unpack parameters\n    kB = params[\"kB\"]             # J/K\n    T_ref = params[\"T_ref\"]       # K\n    gamma = params[\"gamma\"]       # kg/s\n    L = params[\"L\"]               # m\n    dt = params[\"dt\"]             # s\n    N = params[\"N\"]               # number of trajectories\n    t_max = params[\"t_max\"]       # s\n\n    # Potential barrier height H in Joules\n    H = h_multiplier * kB * T_ref\n\n    # Precompute constants\n    inv_L2 = 1.0 / (L * L)\n    inv_L4 = inv_L2 * inv_L2\n    sigma = np.sqrt(2.0 * kB * T * dt / gamma)\n\n    # Initialize positions and status\n    x = np.full(N, -L, dtype=np.float64)\n    escaped = np.zeros(N, dtype=bool)\n    t_escape = np.full(N, np.nan, dtype=np.float64)\n\n    # Time loop\n    t = 0.0\n    max_steps = int(np.ceil(t_max / dt))\n    for _ in range(max_steps):\n        # Identify active walkers\n        active_idx = np.where(~escaped)[0]\n        if active_idx.size == 0:\n            break\n\n        xa = x[active_idx]\n\n        # Compute deterministic force: F = -dU/dx = H*(4x/L^2 - 4 x^3 / L^4)\n        # Derived from U = H[(x/L)^4 - 2(x/L)^2]\n        dUdx = H * (4.0 * xa**3 * inv_L4 - 4.0 * xa * inv_L2)\n        F = -dUdx\n\n        # Stochastic increment\n        noise = sigma * rng.standard_normal(size=xa.shape)\n\n        # Update positions\n        xa_new = xa + (dt / gamma) * F + noise\n        x[active_idx] = xa_new\n\n        # Advance time\n        t += dt\n\n        # Check for escape: crossing x = 0\n        crossed = xa_new = 0.0\n        if np.any(crossed):\n            crossed_idx = active_idx[crossed]\n            escaped[crossed_idx] = True\n            # Record current time as first-passage time\n            t_escape[crossed_idx] = t\n\n    # Compute MFPT: mean over escaped walkers\n    escaped_times = t_escape[~np.isnan(t_escape)]\n    if escaped_times.size == 0:\n        # Fallback if none escaped: return t_max\n        return float(t_max)\n    else:\n        return float(np.mean(escaped_times))\n\n\ndef solve():\n    # Fixed physical and numerical parameters\n    params = {\n        \"kB\": 1.380649e-23,     # Boltzmann constant, J/K\n        \"T_ref\": 300.0,         # reference temperature, K\n        \"gamma\": 1.0e-12,       # friction coefficient, kg/s\n        \"L\": 1.0e-9,            # length scale, m\n        \"dt\": 5.0e-14,          # time step, s\n        \"N\": 64,                # number of trajectories\n        \"t_max\": 1.0e-7,        # maximum time, s\n    }\n\n    # Test cases: (h_multiplier, Temperature K)\n    test_cases = [\n        (2.0, 300.0),  # Case A\n        (4.0, 300.0),  # Case B\n        (4.0, 600.0),  # Case C\n        (0.5, 300.0),  # Case D\n    ]\n\n    # Use fixed seed for reproducibility; vary per case to diversify streams\n    base_seed = 123456\n    results = []\n    for i, (h, T) in enumerate(test_cases):\n        rng = np.random.default_rng(base_seed + i)\n        mfpt = simulate_mfpt(h, T, rng, params)\n        results.append(mfpt)\n\n    # Print results in required single-line format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2457132"}, {"introduction": "The reliability of any molecular simulation hinges on the choice of numerical integrator. This exercise delves into the practical art of integration by challenging you to simulate a particle in a potential with a discontinuous force—a \"cusp\"—using several different algorithms for both overdamped and underdamped dynamics [@problem_id:2457165]. By comparing the accuracy of simple explicit methods to more sophisticated splitting schemes like BAOAB, you will gain crucial insights into numerical stability and the trade-offs involved in choosing an integrator for complex physical systems.", "problem": "Consider a single particle moving in one spatial dimension with a cusp potential. Let the potential be defined by $V(x)=k \\lvert x \\rvert$, where $k>0$ is a constant. The force is the negative gradient (interpreted as a subgradient at the cusp), taken here as $F(x)=-\\frac{dV}{dx}=-k\\,\\mathrm{sign}(x)$, with $\\mathrm{sign}(0)=0$. Work entirely in reduced, dimensionless units with particle mass $m=1$ and Boltzmann constant $k_B=1$. Temperature $T$ is then expressed in the same units as energy.\n\nTwo stochastic dynamics models are to be considered:\n\n- Underdamped Langevin dynamics (with inertia):\n  $$dx_t=v_t\\,dt,$$\n  $$dv_t=\\left(-\\gamma\\,v_t+F(x_t)\\right)\\,dt+\\sqrt{2\\,\\gamma\\,T}\\,dW_t,$$\n  where $\\gamma>0$ is a friction coefficient and $W_t$ is a standard Wiener process.\n\n- Overdamped Brownian dynamics (high-friction limit):\n  $$dx_t=\\mu\\,F(x_t)\\,dt+\\sqrt{2\\,D}\\,dW_t,$$\n  where the mobility is $\\mu=\\frac{1}{\\gamma}$ and the diffusion coefficient is $D=\\mu\\,T=\\frac{T}{\\gamma}$.\n\nFor this potential at thermal equilibrium, the stationary position distribution is the Laplace distribution with density proportional to $\\exp\\!\\left(-\\frac{k\\lvert x\\rvert}{T}\\right)$. Consequently, the exact equilibrium mean absolute position is\n$$\\mathbb{E}\\left[\\lvert X \\rvert\\right]=\\frac{T}{k}.$$\n\nDiscrete-time update rules to be used in the simulations are specified as follows. Let $R_n$ denote independent, identically distributed standard normal random variables (mean $0$, variance $1$).\n\n- Underdamped integrator U1 (explicit Euler–Maruyama for the velocity, explicit position update):\n  $$v_{n+1}=v_n+\\Delta t\\left(-\\gamma\\,v_n+F(x_n)\\right)+\\sqrt{2\\,\\gamma\\,T}\\,\\sqrt{\\Delta t}\\,R_n,$$\n  $$x_{n+1}=x_n+\\Delta t\\,v_n.$$\n\n- Underdamped integrator U2 (a symmetric Strang splitting integrator with an exact Ornstein–Uhlenbeck thermostat step; commonly called BAOAB in the literature):\n  Define $a=\\exp(-\\gamma\\,\\Delta t)$ and $b=\\sqrt{T\\,(1-a^2)}$. Then perform the following sequence at each step:\n  1. Half kick: $v\\leftarrow v+\\frac{\\Delta t}{2}\\,F(x)$.\n  2. Half drift: $x\\leftarrow x+\\frac{\\Delta t}{2}\\,v$.\n  3. Ornstein–Uhlenbeck (thermostat): $v\\leftarrow a\\,v+b\\,R_n$.\n  4. Half drift: $x\\leftarrow x+\\frac{\\Delta t}{2}\\,v$.\n  5. Half kick: $v\\leftarrow v+\\frac{\\Delta t}{2}\\,F(x)$.\n\n- Overdamped integrator O1 (explicit Euler–Maruyama):\n  $$x_{n+1}=x_n+\\mu\\,F(x_n)\\,\\Delta t+\\sqrt{2\\,D\\,\\Delta t}\\,R_n.$$\n\n- Overdamped integrator O2 (implicit Euler for the drift, which for the cusp potential admits a closed-form update). Let $y=x_n+\\sqrt{2\\,D\\,\\Delta t}\\,R_n$ and $a=\\mu\\,k\\,\\Delta t$. Then update\n  $$x_{n+1}=\\mathrm{sign}(y)\\,\\max\\!\\left(\\lvert y\\rvert-a,\\,0\\right).$$\n\nIn all simulations, use initial conditions $x_0=0$ and $v_0=0$ (for underdamped cases), a fixed number of time steps $N$, and a burn-in of $N_{\\mathrm{burn}}$ steps that are discarded from averaging. Use a fixed pseudo-random seed $s$ to initialize the generation of the Gaussian random variables $R_n$ to make the results reproducible. After burn-in, compute the time average of the absolute position,\n$$\\overline{m}=\\frac{1}{N-N_{\\mathrm{burn}}}\\sum_{n=N_{\\mathrm{burn}}+1}^{N} \\lvert x_n\\rvert,$$\nand report the absolute error with respect to the exact value $T/k$,\n$$\\varepsilon=\\left\\lvert \\overline{m}-\\frac{T}{k}\\right\\rvert.$$\n\nTest suite. For each of the following parameter sets, run the corresponding simulation and return the value of $\\varepsilon$ as a floating-point number.\n\n- Test 1 (overdamped, explicit): O1 with $k=1$, $T=1$, $\\gamma=5$, $\\Delta t=0.05$, $N=200000$, $N_{\\mathrm{burn}}=20000$, $s=12345$.\n- Test 2 (overdamped, implicit): O2 with $k=1$, $T=1$, $\\gamma=5$, $\\Delta t=0.05$, $N=200000$, $N_{\\mathrm{burn}}=20000$, $s=12345$.\n- Test 3 (underdamped, explicit): U1 with $k=1$, $T=1$, $\\gamma=1$, $\\Delta t=0.001$, $N=200000$, $N_{\\mathrm{burn}}=20000$, $s=12345$.\n- Test 4 (underdamped, splitting): U2 with $k=1$, $T=1$, $\\gamma=1$, $\\Delta t=0.01$, $N=200000$, $N_{\\mathrm{burn}}=20000$, $s=12345$.\n\nAngle units do not apply. All reported quantities are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$) in the same order as the test cases above.", "solution": "The problem posed is a well-defined computational exercise in the field of statistical mechanics, specifically concerning the numerical integration of stochastic differential equations. All parameters, initial conditions, and numerical schemes are specified unambiguously. The underlying physical model of a particle in a cusp potential under Langevin or Brownian dynamics is scientifically sound, and the theoretical equilibrium expectation value provided, $\\mathbb{E}[\\lvert X \\rvert]=\\frac{T}{k}$, is correct. The problem is therefore valid, and a solution can be constructed.\n\nThe objective is to simulate the trajectory of a single particle in one dimension, governed by a potential $V(x)=k \\lvert x \\rvert$, using four distinct numerical integration schemes. For each scheme, we must compute the time-averaged absolute position, $\\overline{m}$, after an initial burn-in period, and report the absolute error $\\varepsilon=\\left\\lvert \\overline{m}-\\frac{T}{k}\\right\\rvert$ with respect to the exact analytical result. The particle mass $m$, Boltzmann constant $k_B$, and potential constant $k$ are all set to $1$ in dimensionless units, and the temperature is $T=1$. Thus, the exact value for comparison is $\\mathbb{E}[\\lvert X \\rvert]=\\frac{1}{1}=1$.\n\nAll simulations start from the initial state $x_0=0$ and, for underdamped cases, $v_0=0$. A fixed pseudo-random seed $s=12345$ is used to initialize the generator of standard normal random numbers, $R_n$, ensuring reproducibility across all tests. A total of $N=200000$ steps are performed, with the first $N_{\\mathrm{burn}}=20000$ steps discarded to allow the system to equilibrate. The average is computed over the remaining $N-N_{\\mathrm{burn}}=180000$ steps.\n\nThe implementation will consist of four distinct functions, each corresponding to one of the test cases.\n\n**Test 1: Overdamped Euler–Maruyama Integrator (O1)**\nThis test employs the overdamped Brownian dynamics equation:\n$$dx_t=\\mu\\,F(x_t)\\,dt+\\sqrt{2\\,D}\\,dW_t$$\nwhere $\\mu=1/\\gamma$ and $D=T/\\gamma$. The simplest numerical discretization is the explicit Euler–Maruyama scheme, given by:\n$$x_{n+1}=x_n+\\mu\\,F(x_n)\\,\\Delta t+\\sqrt{2\\,D\\,\\Delta t}\\,R_n$$\nFor this test, parameters are $k=1$, $T=1$, $\\gamma=5$, and $\\Delta t=0.05$. This gives $\\mu=1/5=0.2$ and $D=1/5=0.2$. The force is $F(x_n)=-k\\,\\mathrm{sign}(x_n)=-\\mathrm{sign}(x_n)$. The simulation loop will directly implement this update rule for $N$ steps, accumulating $\\lvert x_n \\rvert$ for $n > N_{\\mathrm{burn}}$.\n\n**Test 2: Overdamped Splitting Integrator (O2)**\nThis test uses the same overdamped dynamics but with a more sophisticated integrator. The update is performed in two steps: a stochastic \"kick\" followed by the exact evolution under the deterministic part of the dynamics.\n1. Apply stochastic kick: $y=x_n+\\sqrt{2\\,D\\,\\Delta t}\\,R_n$.\n2. Apply deterministic evolution: The equation $\\dot{x} = \\mu F(x) = -\\mu k\\,\\mathrm{sign}(x)$ is solved exactly for a time $\\Delta t$ starting from $y$. The solution is $x(\\Delta t)=\\mathrm{sign}(y)\\,\\max(\\lvert y\\rvert-\\mu k\\,\\Delta t,\\,0)$.\nThis gives the update rule:\n$$x_{n+1}=\\mathrm{sign}(y)\\,\\max\\!\\left(\\lvert y\\rvert-a,\\,0\\right)$$\nwhere $a=\\mu\\,k\\,\\Delta t$. The parameters are identical to Test 1, allowing for a direct comparison of the integrators' accuracy. This method is typically more stable for potentials with sharp features like the cusp.\n\n**Test 3: Underdamped Euler–Maruyama Integrator (U1)**\nThis test considers the underdamped Langevin dynamics, which includes inertia:\n$$dx_t=v_t\\,dt$$\n$$dv_t=\\left(-\\gamma\\,v_t+F(x_t)\\right)\\,dt+\\sqrt{2\\,\\gamma\\,T}\\,dW_t$$\nThe integrator (U1) is a simple explicit scheme:\n$$v_{n+1}=v_n+\\Delta t\\left(-\\gamma\\,v_n+F(x_n)\\right)+\\sqrt{2\\,\\gamma\\,T}\\,\\sqrt{\\Delta t}\\,R_n$$\n$$x_{n+1}=x_n+\\Delta t\\,v_n$$\nNote that the position is updated using the velocity from the beginning of the timestep, $v_n$. The parameters are $k=1$, $T=1$, $\\gamma=1$, and a small timestep $\\Delta t=0.001$, which is necessary due to the limited stability of this explicit method.\n\n**Test 4: Underdamped Splitting Integrator (U2 / BAOAB)**\nThis test uses a more robust geometric integrator known as BAOAB, which is a symmetric Strang splitting of the Langevin operator. The dynamics are split into three parts: deterministic motion under the force (B), deterministic drift (A), and stochastic velocity update according to the Ornstein–Uhlenbeck process (O). The sequence is BAOAB:\n1. **B (Force):** Update velocity for a half time step: $v\\leftarrow v+\\frac{\\Delta t}{2}\\,F(x)$.\n2. **A (Drift):** Update position for a half time step: $x\\leftarrow x+\\frac{\\Delta t}{2}\\,v$.\n3. **O (Thermostat):** Update velocity exactly for the full time step: $v\\leftarrow a\\,v+b\\,R_n$, with $a=\\exp(-\\gamma\\,\\Delta t)$ and $b=\\sqrt{T\\,(1-a^2)}$.\n4. **A (Drift):** Update position for the second half time step: $x\\leftarrow x+\\frac{\\Delta t}{2}\\,v$.\n5. **B (Force):** Update velocity for the second half time step: $v\\leftarrow v+\\frac{\\Delta t}{2}\\,F(x)$.\nThis symmetric splitting provides better long-term stability and accuracy in preserving the equilibrium distribution, allowing for a larger timestep of $\\Delta t=0.01$ compared to U1.\n\nFor each test, the simulation will be executed, the mean absolute position $\\overline{m}$ calculated, and the absolute error $\\varepsilon$ determined. The four resulting error values will be collected and formatted as requested.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef force(x: float, k: float) - float:\n    \"\"\"Calculates the force F(x) = -k * sign(x).\"\"\"\n    return -k * np.sign(x)\n\ndef run_test1_o1(k: float, T: float, gamma: float, dt: float, N: int, N_burn: int, seed: int) - float:\n    \"\"\"\n    Test 1: Overdamped, explicit Euler-Maruyama integrator (O1).\n    \"\"\"\n    x = 0.0\n    mu = 1.0 / gamma\n    D = T / gamma\n    stochastic_term_coeff = np.sqrt(2 * D * dt)\n    rng = np.random.default_rng(seed)\n    \n    total_abs_x = 0.0\n    \n    for n in range(N):\n        R_n = rng.standard_normal()\n        drift_term = mu * force(x, k) * dt\n        stochastic_term = stochastic_term_coeff * R_n\n        x = x + drift_term + stochastic_term\n        \n        if n = N_burn:\n            total_abs_x += np.abs(x)\n            \n    m_bar = total_abs_x / (N - N_burn)\n    exact_m = T / k\n    error = np.abs(m_bar - exact_m)\n    return error\n\ndef run_test2_o2(k: float, T: float, gamma: float, dt: float, N: int, N_burn: int, seed: int) - float:\n    \"\"\"\n    Test 2: Overdamped, implicit/splitting integrator (O2).\n    \"\"\"\n    x = 0.0\n    mu = 1.0 / gamma\n    D = T / gamma\n    stochastic_term_coeff = np.sqrt(2 * D * dt)\n    a_param = mu * k * dt\n    rng = np.random.default_rng(seed)\n    \n    total_abs_x = 0.0\n    \n    for n in range(N):\n        R_n = rng.standard_normal()\n        y = x + stochastic_term_coeff * R_n\n        x = np.sign(y) * max(np.abs(y) - a_param, 0.0)\n        \n        if n = N_burn:\n            total_abs_x += np.abs(x)\n            \n    m_bar = total_abs_x / (N - N_burn)\n    exact_m = T / k\n    error = np.abs(m_bar - exact_m)\n    return error\n\ndef run_test3_u1(k: float, T: float, gamma: float, dt: float, N: int, N_burn: int, seed: int) - float:\n    \"\"\"\n    Test 3: Underdamped, explicit Euler-Maruyama integrator (U1).\n    \"\"\"\n    x, v = 0.0, 0.0\n    stochastic_term_coeff = np.sqrt(2 * gamma * T * dt)\n    rng = np.random.default_rng(seed)\n    \n    total_abs_x = 0.0\n    \n    for n in range(N):\n        R_n = rng.standard_normal()\n        \n        v_new = v + dt * (-gamma * v + force(x, k)) + stochastic_term_coeff * R_n\n        x_new = x + dt * v\n        \n        x, v = x_new, v_new\n        \n        if n = N_burn:\n            total_abs_x += np.abs(x)\n            \n    m_bar = total_abs_x / (N - N_burn)\n    exact_m = T / k\n    error = np.abs(m_bar - exact_m)\n    return error\n\ndef run_test4_u2(k: float, T: float, gamma: float, dt: float, N: int, N_burn: int, seed: int) - float:\n    \"\"\"\n    Test 4: Underdamped, BAOAB splitting integrator (U2).\n    \"\"\"\n    x, v = 0.0, 0.0\n    a_param = np.exp(-gamma * dt)\n    b_param = np.sqrt(T * (1 - a_param**2))\n    dt_half = dt / 2.0\n    rng = np.random.default_rng(seed)\n    \n    total_abs_x = 0.0\n    \n    for n in range(N):\n        # 1. B (Half kick)\n        v = v + dt_half * force(x, k)\n        \n        # 2. A (Half drift)\n        x = x + dt_half * v\n        \n        # 3. O (Thermostat)\n        R_n = rng.standard_normal()\n        v = a_param * v + b_param * R_n\n        \n        # 4. A (Half drift)\n        x = x + dt_half * v\n        \n        # 5. B (Half kick)\n        v = v + dt_half * force(x, k)\n        \n        if n = N_burn:\n            total_abs_x += np.abs(x)\n            \n    m_bar = total_abs_x / (N - N_burn)\n    exact_m = T / k\n    error = np.abs(m_bar - exact_m)\n    return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: O1\n        {\"func\": run_test1_o1, \"params\": {'k': 1, 'T': 1, 'gamma': 5, 'dt': 0.05, 'N': 200000, 'N_burn': 20000, 'seed': 12345}},\n        # Test 2: O2\n        {\"func\": run_test2_o2, \"params\": {'k': 1, 'T': 1, 'gamma': 5, 'dt': 0.05, 'N': 200000, 'N_burn': 20000, 'seed': 12345}},\n        # Test 3: U1\n        {\"func\": run_test3_u1, \"params\": {'k': 1, 'T': 1, 'gamma': 1, 'dt': 0.001, 'N': 200000, 'N_burn': 20000, 'seed': 12345}},\n        # Test 4: U2\n        {\"func\": run_test4_u2, \"params\": {'k': 1, 'T': 1, 'gamma': 1, 'dt': 0.01, 'N': 200000, 'N_burn': 20000, 'seed': 12345}},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = case[\"func\"](**case[\"params\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2457165"}, {"introduction": "The standard Langevin equation assumes that frictional forces respond instantly to a particle's velocity. This final practice moves beyond that approximation to the more realistic Generalized Langevin Equation (GLE), where friction has \"memory\" of past events. You will derive the evolution equation for the velocity autocorrelation function (VACF) under this more general framework and solve it numerically [@problem_id:2457181]. This advanced exercise provides a powerful demonstration of how non-Markovian dynamics, a key feature of complex liquids, can be modeled and understood.", "problem": "Consider a single particle of mass $m$ in a thermal bath at temperature $T$. Its velocity $v(t)$ obeys the generalized Langevin equation (GLE), which augments Newton's second law with a friction term that has memory and a random force. Let the friction memory kernel be denoted by $\\Gamma(t)$ and the random force by $R(t)$. The Generalized Langevin Equation (GLE) can be written as\n$$\nm\\,\\frac{dv(t)}{dt} \\;=\\; - \\int_{0}^{t} \\Gamma(t-s)\\,v(s)\\,ds \\;+\\; R(t).\n$$\nAssume thermal equilibrium and the Fluctuation–Dissipation Theorem (FDT), namely that the random force is stationary, has zero mean, and satisfies\n$$\n\\langle R(t)\\,R(s)\\rangle \\;=\\; k_B T\\,\\Gamma(|t-s|),\n$$\nwhere $k_B$ is the Boltzmann constant, and $\\langle \\cdot \\rangle$ denotes an equilibrium ensemble average. Define the velocity autocorrelation function (VACF) as\n$$\nC(t)\\;=\\;\\langle v(t)\\,v(0)\\rangle.\n$$\n\nTasks:\n1) Starting from Newton’s second law, the definition of $C(t)$, and the Fluctuation–Dissipation Theorem (FDT), derive a closed evolution equation that $C(t)$ satisfies for $t\\ge 0$ when $R(t)$ and $v(0)$ are uncorrelated for $t>0$. Do not assume any particular form of $\\Gamma(t)$ a priori, and do not rely on any pre-derived shortcut formulas. Your derivation should make explicit why the random force drops out of the equation for $C(t)$ under these conditions.\n\n2) Specialize your result to two physically relevant cases:\n   - The memoryless (Markovian) case, modeled by the limit $\\Gamma(t) = 2m\\gamma\\,\\delta(t)$ with friction coefficient $\\gamma>0$, where $\\delta(t)$ is the Dirac delta distribution. Explain how the short-time behavior of $C(t)$ changes in this case.\n   - A single-exponential memory kernel for $t\\ge 0$,\n     $$\n     \\Gamma(t)\\;=\\;\\frac{m\\gamma}{\\tau}\\,e^{-t/\\tau},\n     $$\n     with correlation (memory) time $\\tau>0$, chosen so that $\\int_{0}^{\\infty}\\Gamma(t)\\,dt = m\\gamma$ is the same total friction as in the Markovian case. Using only fundamental definitions and your evolution equation for $C(t)$, show how the presence of a nonzero $\\tau$ modifies the initial time derivatives of $C(t)$ compared to the Markovian case.\n\n3) Write a complete, runnable program that, using your derived equation(s), computes for each specified test case the following dimensionless diagnostics that quantify the effect of memory on the VACF:\n   - The normalized initial slope,\n     $$\n     \\sigma \\;=\\; -\\frac{1}{\\gamma\\,C(0)}\\,\\left.\\frac{dC(t)}{dt}\\right|_{t=0^+}.\n     $$\n   - The normalized initial curvature,\n     $$\n     \\rho \\;=\\; \\frac{1}{\\gamma^2\\,C(0)}\\,\\left.\\frac{d^2 C(t)}{dt^2}\\right|_{t=0^+}.\n     $$\n   - The normalized correlation at a fixed time $t_\\star$,\n     $$\n     c_\\star \\;=\\; \\frac{C(t_\\star)}{C(0)}.\n     $$\n   Here $C(0)=\\langle v(0)^2\\rangle = k_B T/m$. You must compute $c_\\star$ by numerically integrating the closed $C(t)$-equation implied by your derivation for non-Markovian memory. For the Markovian case you may use the corresponding closed-form solution of your evolution equation.\n\n4) Use the following scientifically realistic parameter sets as the test suite. Use the Boltzmann constant $k_B=1.380649\\times 10^{-23}\\ \\mathrm{J/K}$ and assume the International System of Units (SI) for all inputs. The mass is $m=6.63\\times 10^{-26}\\ \\mathrm{kg}$ (argon-like), and the temperature is $T=300\\ \\mathrm{K}$ for all tests. The common friction scale is $\\gamma=1.0\\times 10^{12}\\ \\mathrm{s}^{-1}$ for all tests. Define the evaluation time as $t_\\star = 2/\\gamma$ (in seconds). The four test cases are:\n   - Test $1$ (Markovian): memoryless friction (the $\\delta$-limit of $\\Gamma$).\n   - Test $2$ (Exponential memory): $\\tau = 2.0\\times 10^{-13}\\ \\mathrm{s}$.\n   - Test $3$ (Exponential memory): $\\tau = 1.0\\times 10^{-12}\\ \\mathrm{s}$.\n   - Test $4$ (Exponential memory): $\\tau = 5.0\\times 10^{-12}\\ \\mathrm{s}$.\n\nNotes and constraints for the implementation:\n- Your numerical method must follow logically from your derivation. For the exponential memory, you may introduce auxiliary variables to eliminate the convolution and integrate an equivalent ordinary differential equation system.\n- All outputs requested in item $3$ are dimensionless; you must therefore not attach any physical unit symbols to the returned values.\n- Your program should produce a single line of output containing all results aggregated for the four test cases in the following order:\n  $$\n  [\\sigma_1,\\rho_1,c_{\\star,1},\\ \\sigma_2,\\rho_2,c_{\\star,2},\\ \\sigma_3,\\rho_3,c_{\\star,3},\\ \\sigma_4,\\rho_4,c_{\\star,4}],\n  $$\n  where the subscript denotes the test number.\n\nYour program must be self-contained and must not require any input. It must compute and print the values in the specified order as a comma-separated list enclosed in square brackets in a single line, for direct automated evaluation. The outputs must be numerical scalars (floating-point values). The design of the test suite probes: a baseline (Markovian) behavior, short-memory behavior ($\\tau \\ll 1/\\gamma$), matched time scales ($\\tau \\approx 1/\\gamma$), and long-memory behavior ($\\tau \\gg 1/\\gamma$).", "solution": "### Derivation and Methodology\n\n#### 1. Derivation of the Evolution Equation for $C(t)$\n\nWe begin with the Generalized Langevin Equation (GLE) for $t>0$:\n$$\nm\\,\\frac{dv(t)}{dt} \\;=\\; - \\int_{0}^{t} \\Gamma(t-s)\\,v(s)\\,ds \\;+\\; R(t)\n$$\nTo derive an equation for the velocity autocorrelation function, $C(t) = \\langle v(t)v(0) \\rangle$, we multiply the GLE by the initial velocity $v(0)$ and take the equilibrium ensemble average, denoted by $\\langle \\cdot \\rangle$.\n$$\n\\left\\langle m\\,\\frac{dv(t)}{dt} \\,v(0) \\right\\rangle \\;=\\; \\left\\langle \\left( - \\int_{0}^{t} \\Gamma(t-s)\\,v(s)\\,ds \\right) v(0) \\right\\rangle \\;+\\; \\langle R(t)\\,v(0) \\rangle\n$$\nWe analyze each term separately for $t>0$. The time derivative on the left-hand side can be moved outside the average for a stationary process, yielding $m\\,\\frac{dC(t)}{dt}$. The average on the right-hand side can be moved inside the integral, giving $- \\int_{0}^{t} \\Gamma(t-s)\\,\\langle v(s)\\,v(0) \\rangle \\,ds = - \\int_{0}^{t} \\Gamma(t-s)\\,C(s)\\,ds$.\n\nThe final term, $\\langle R(t)v(0) \\rangle$, vanishes. This is because the random force $R(t)$ at any time $t>0$ represents thermal fluctuations of the bath occurring after time zero, whereas the initial velocity $v(0)$ is determined by the state of the system at time zero. The model assumes these are uncorrelated. Given that the mean of the random force is zero ($\\langle R(t) \\rangle = 0$), the correlation is $\\langle R(t)v(0) \\rangle = \\langle R(t) \\rangle \\langle v(0) \\rangle = 0$.\n\nCombining the terms, we obtain the closed evolution equation for the VACF for $t>0$:\n$$\nm\\,\\frac{dC(t)}{dt} \\;=\\; - \\int_{0}^{t} \\Gamma(t-s)\\,C(s)\\,ds\n$$\nThis is a Volterra integro-differential equation. The initial condition is given by the equipartition theorem, $\\frac{1}{2}m\\langle v^2 \\rangle = \\frac{1}{2}k_B T$, which implies $C(0) = \\langle v(0)^2 \\rangle = k_B T/m$.\n\n#### 2. Specializations of the Evolution Equation\n\n**Case I: Memoryless (Markovian) Limit**\nWith the kernel $\\Gamma(t) = 2m\\gamma\\,\\delta(t)$, the integral term becomes $-m\\gamma C(t)$. The evolution equation simplifies to a first-order ordinary differential equation (ODE):\n$$\nm\\,\\frac{dC(t)}{dt} = -m\\gamma\\,C(t) \\quad \\implies \\quad \\frac{dC(t)}{dt} = -\\gamma\\,C(t)\n$$\nThe solution is an exponential decay, $C(t) = C(0)\\,e^{-\\gamma t}$. The first derivative at $t=0^+$ is finite and non-zero: $\\left.\\frac{dC(t)}{dt}\\right|_{t=0^+} = -\\gamma\\,C(0)$. This non-differentiability (cusp) at $t=0$ is characteristic of a Markovian process.\n\n**Case II: Exponential Memory Kernel**\nWith the kernel $\\Gamma(t) = \\frac{m\\gamma}{\\tau}\\,e^{-t/\\tau}$ for $t \\ge 0$, the evolution equation for $C(t)$ is:\n$$\n\\frac{dC(t)}{dt} = -\\frac{\\gamma}{\\tau}\\int_{0}^{t} e^{-(t-s)/\\tau}\\,C(s)\\,ds\n$$\nAt $t=0^+$, the integral over an infinitesimal domain is zero, so $\\left.\\frac{dC(t)}{dt}\\right|_{t=0^+} = 0$. This smooth, zero-slope start contrasts with the Markovian case. To find the second derivative, we differentiate the integro-differential equation, which yields a second-order linear homogeneous ODE:\n$$\n\\frac{d^2C}{dt^2} + \\frac{1}{\\tau}\\frac{dC}{dt} + \\frac{\\gamma}{\\tau}C(t) = 0\n$$\nEvaluating this at $t=0^+$ with initial conditions $C(0)$ and $\\dot{C}(0^+) = 0$, we find the initial curvature: $\\left.\\frac{d^2C}{dt^2}\\right|_{t=0^+} = -\\frac{\\gamma}{\\tau}C(0)$. The presence of memory makes the VACF a smooth function at the origin.\n\n#### 3. Calculation of Diagnostics and Numerical Method\n\nThe diagnostics $\\sigma$, $\\rho$, and $c_\\star$ are computed for each case.\n\n**Markovian Case (Analytical):**\n- $\\sigma = -\\frac{1}{\\gamma C(0)} (-\\gamma C(0)) = 1$.\n- $\\rho = \\frac{1}{\\gamma^2 C(0)} (\\gamma^2 C(0)) = 1$.\n- $c_\\star = \\frac{C(t_\\star)}{C(0)} = e^{-\\gamma t_\\star}$. With $t_\\star=2/\\gamma$, this is $c_\\star = e^{-2}$.\n\n**Exponential Memory Case (Analytical and Numerical):**\n- $\\sigma = -\\frac{1}{\\gamma C(0)} (0) = 0$.\n- $\\rho = \\frac{1}{\\gamma^2 C(0)} \\left(-\\frac{\\gamma}{\\tau}C(0)\\right) = -\\frac{1}{\\gamma\\tau}$.\n- To compute $c_\\star = C(t_\\star)/C(0)$, we numerically solve the second-order ODE derived above for the normalized function $c(t)=C(t)/C(0)$, which obeys the same equation:\n$$\n\\frac{d^2c}{dt^2} + \\frac{1}{\\tau}\\frac{d c}{dt} + \\frac{\\gamma}{\\tau}c(t) = 0\n$$\nwith initial conditions $c(0)=1$ and $\\frac{dc}{dt}|_{t=0} = 0$. We convert this to a system of two first-order ODEs by setting $y_1(t) = c(t)$ and $y_2(t) = \\frac{dc(t)}{dt}$. The system is:\n$$\n\\frac{dy_1}{dt} = y_2, \\quad \\frac{dy_2}{dt} = -\\frac{1}{\\tau}y_2 - \\frac{\\gamma}{\\tau}y_1\n$$\nThis system is integrated from $t=0$ to $t=t_\\star$ with initial state $\\mathbf{y}(0) = [1, 0]^T$. The value $y_1(t_\\star)$ is the desired diagnostic $c_\\star$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the Generalized Langevin Equation problem for four test cases.\n    It calculates diagnostics for the velocity autocorrelation function (VACF)\n    for a Markovian case and three non-Markovian cases with exponential memory.\n    \"\"\"\n    # Define physical constants and problem parameters\n    k_B = 1.380649e-23  # Boltzmann constant (J/K)\n    m = 6.63e-26       # Mass of particle (kg)\n    T = 300.0          # Temperature (K)\n    gamma = 1.0e12     # Friction scale (s^-1)\n    \n    # Evaluation time\n    t_star = 2.0 / gamma\n\n    # Define the test cases\n    # Each tuple is (case_name, tau_value_in_seconds)\n    # tau = 0 is a special flag for the Markovian case.\n    test_cases = [\n        (\"Markovian\", 0.0),\n        (\"Exponential Memory 1\", 2.0e-13),\n        (\"Exponential Memory 2\", 1.0e-12),\n        (\"Exponential Memory 3\", 5.0e-12),\n    ]\n\n    results = []\n    \n    # C(0) is not numerically needed for the dimensionless diagnostics,\n    # as it cancels out in all definitions.\n    # C0 = k_B * T / m \n\n    for name, tau in test_cases:\n        if name == \"Markovian\":\n            # Analytical results for the Markovian case, C(t) = C(0) * exp(-gamma*t)\n            # sigma = - (1/(gamma*C(0))) * dC/dt|_{t=0+}\n            # dC/dt = -gamma * C(0) * exp(-gamma*t) - -gamma * C(0) at t=0+\n            sigma = - (1.0 / gamma) * (-gamma)\n            \n            # rho = (1/(gamma^2*C(0))) * d^2C/dt^2|_{t=0+}\n            # d^2C/dt^2 = gamma^2 * C(0) * exp(-gamma*t) - gamma^2 * C(0) at t=0+\n            rho = (1.0 / gamma**2) * (gamma**2)\n\n            # c_star = C(t_star) / C(0)\n            c_star = np.exp(-gamma * t_star)\n\n            results.extend([sigma, rho, c_star])\n            \n        else: # Exponential Memory cases\n            # Analytical results for sigma and rho\n            # sigma = - (1/(gamma*C(0))) * dC/dt|_{t=0+}\n            # dC/dt|_{t=0+} = 0\n            sigma = 0.0\n            \n            # rho = (1/(gamma^2*C(0))) * d^2C/dt^2|_{t=0+}\n            # d^2C/dt^2|_{t=0+} = -(gamma/tau) * C(0)\n            rho = (1.0 / (gamma**2)) * (-gamma / tau)\n\n            # Numerical calculation for c_star\n            # We solve the 2nd order ODE for c(t) = C(t)/C(0):\n            # d^2c/dt^2 + (1/tau)*dc/dt + (gamma/tau)*c = 0\n            # with c(0)=1, dc/dt(0)=0.\n            # System of 1st order ODEs: y[0]=c, y[1]=dc/dt\n            # dy[0]/dt = y[1]\n            # dy[1]/dt = -(1/tau)*y[1] - (gamma/tau)*y[0]\n            \n            def odesystem(t, y, gamma_val, tau_val):\n                c, dc_dt = y\n                d2c_dt2 = -(1.0 / tau_val) * dc_dt - (gamma_val / tau_val) * c\n                return [dc_dt, d2c_dt2]\n\n            # Initial conditions\n            y0 = [1.0, 0.0]\n            \n            # Time span for integration\n            t_span = [0.0, t_star]\n\n            # Solve the ODE system\n            sol = solve_ivp(\n                fun=odesystem,\n                t_span=t_span,\n                y0=y0,\n                args=(gamma, tau),\n                method='RK45',\n                dense_output=False,\n                rtol=1e-8,\n                atol=1e-10\n            )\n            \n            # c_star is the value of c(t) at the end of the integration\n            c_star = sol.y[0, -1]\n\n            results.extend([sigma, rho, c_star])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "2457181"}]}