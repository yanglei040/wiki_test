{"hands_on_practices": [{"introduction": "A crucial verification step for any simulation of a physical system is to check whether it respects fundamental physical principles, such as the dissipation of energy in a closed system. This practice focuses on the one-dimensional heat equation, a classic model for diffusion, where the total energy is expected to decay over time. By implementing a numerical scheme and tracking a discrete version of the system's energy, you will see firsthand how this physical property is linked to the numerical stability of your simulation [@problem_id:3201887].", "problem": "You will implement a numerical verification of a physically motivated property for the one-dimensional heat equation. The fundamental base is the heat equation, which is a linear partial differential equation (PDE) expressing conservation and diffusion of heat. The one-dimensional heat equation with Dirichlet boundary conditions on the spatial interval $[0,1]$ is\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in [0,1], \\ t \\ge 0,\n$$\nwith boundary conditions $u(0,t) = 0$ and $u(1,t) = 0$, where $\\nu > 0$ is the diffusion coefficient. A fundamental and well-tested fact about this PDE is that the squared $L^2$ energy,\n$$\nE(t) = \\int_0^1 u(x,t)^2 \\, dx,\n$$\nis non-increasing in time, reflecting physical dissipation.\n\nYour task is to discretize this PDE and verify whether the discrete energy\n$$\nE_n = \\Delta x \\sum_{i=1}^{N-2} (u_i^n)^2,\n$$\nis monotonic non-increasing over time steps. Use a uniform grid with $N$ points, where $\\Delta x = \\frac{1}{N-1}$, and time step $\\Delta t$. Approximate spatial derivatives by second-order central differences and advance in time using the forward Euler method:\n$$\nu_i^{n+1} = u_i^n + \\alpha\\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right), \\quad i=1,\\dots,N-2,\n$$\nwhere $u_0^n = u_{N-1}^n = 0$ enforce the Dirichlet boundary conditions and $\\alpha = \\nu \\frac{\\Delta t}{\\Delta x^2}$. The discrete energy $E_n$ should be computed at each time step using the interior points $i=1,\\dots,N-2$, with the boundary points set to zero.\n\nImplement a program that, for each provided test case, initializes $u_i^0$ according to the specified initial condition, runs the explicit scheme for $n = 0,1,\\dots,n_{\\text{steps}}$ with $n_{\\text{steps}} = \\left\\lfloor \\frac{T_{\\text{end}}}{\\Delta t} \\right\\rfloor$, and checks whether $E_{n+1} \\le E_n$ for all steps within a small numerical tolerance $\\varepsilon = 10^{-12} \\cdot (1 + E_n)$ to account for floating-point roundoff. The program must return a boolean for each test case indicating whether the energy is monotonic non-increasing for the entire simulation.\n\nInitial conditions are defined as follows for spatial grid points $x_i = i \\Delta x$:\n- \"sine\": $u_i^0 = \\sin(\\pi x_i)$.\n- \"highfreq\": $u_i^0 = \\sin(m \\pi x_i)$ with $m = \\left\\lfloor 0.45\\cdot(N-1) \\right\\rfloor$ and $m \\ge 1$.\n- \"zero\": $u_i^0 = 0$.\n\nThe parameter $\\alpha$ determines the time step via $\\Delta t = \\alpha \\frac{\\Delta x^2}{\\nu}$.\n\nTest Suite:\nProvide a program that evaluates the following test cases, each as a tuple $(N,\\nu,\\alpha,T_{\\text{end}},\\text{initial})$:\n1. $(41, 0.1, 0.4, 0.1, \\text{\"sine\"})$.\n2. $(41, 0.1, 0.5, 0.1, \\text{\"sine\"})$.\n3. $(41, 0.1, 0.6, 0.1, \\text{\"highfreq\"})$.\n4. $(5, 1.0, 0.5, 0.5, \\text{\"sine\"})$.\n5. $(21, 0.5, 0.9, 0.1, \\text{\"zero\"})$.\n\nDesign for coverage:\n- Case 1 is a standard stable configuration expected to exhibit energy decay.\n- Case 2 is a boundary stability case.\n- Case 3 uses a larger $\\alpha$ and a high-frequency initial condition that stresses stability and may violate energy monotonicity.\n- Case 4 uses a coarse grid to exercise boundary and discretization handling.\n- Case 5 has zero initial energy and checks trivial monotonicity under potentially unstable parameters.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\"), where each result is a boolean (\"True\" or \"False\") corresponding to the monotonicity check for the respective test case. No physical units are involved, and the answers are booleans only.", "solution": "The problem requires a numerical verification of the energy dissipation property for a finite difference discretization of the one-dimensional heat equation. The continuous problem is given by the partial differential equation (PDE)\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t)\n$$\non the spatial domain $x \\in [0,1]$ with homogeneous Dirichlet boundary conditions $u(0,t) = u(1,t) = 0$. The diffusion coefficient is $\\nu > 0$. A fundamental property of this system is that the total energy, defined by the squared $L^2$-norm $E(t) = \\int_0^1 u(x,t)^2 \\, dx$, is a non-increasing function of time, i.e., $\\frac{dE}{dt} \\le 0$. This reflects the physical principle of heat dissipation in an isolated system with boundaries held at a constant temperature.\n\nWe are tasked to verify if a specific numerical scheme preserves a discrete analog of this property. The spatial domain $[0,1]$ is discretized using a uniform grid with $N$ points, $x_i = i \\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = \\frac{1}{N-1}$. The solution at grid point $x_i$ and time step $n$ is denoted by $u_i^n \\approx u(x_i, n\\Delta t)$.\n\nThe provided numerical scheme is the Forward Time, Centered Space (FTCS) method. The time derivative is approximated by a forward difference, and the spatial second derivative is approximated by a second-order central difference:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\nu \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{\\Delta x^2}.\n$$\nRearranging this equation gives the explicit update rule for the interior grid points ($i=1, \\dots, N-2$):\n$$\nu_i^{n+1} = u_i^n + \\alpha \\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right),\n$$\nwhere $\\alpha = \\nu \\frac{\\Delta t}{\\Delta x^2}$ is the dimensionless diffusion number. The boundary conditions are enforced by setting $u_0^n = 0$ and $u_{N-1}^n = 0$ for all time steps $n$.\n\nA crucial aspect of this explicit scheme is its conditional stability. A von Neumann stability analysis shows that the scheme is stable if and only if $\\alpha \\le 0.5$. If this condition is violated ($\\alpha > 0.5$), high-frequency components of the numerical solution are amplified at each time step, leading to exponential growth and a complete departure from the true solution.\n\nThe discrete energy is defined as a numerical quadrature of the continuous energy integral:\n$$\nE_n = \\Delta x \\sum_{i=1}^{N-2} (u_i^n)^2.\n$$\nThis corresponds to a trapezoidal rule approximation of $\\int_0^1 u(x,t)^2 dx$, given that the integrand is zero at the boundaries. Our task is to check whether this discrete energy is monotonically non-increasing for each time step of the simulation, i.e., if $E_{n+1} \\le E_n$ for all $n$. Due to floating-point arithmetic, we must check this inequality with a small tolerance: $E_{n+1} \\le E_n + \\varepsilon$, where $\\varepsilon = 10^{-12} (1 + E_n)$. A failure to meet this condition at any step implies that the energy monotonicity is violated for that test case.\n\nThe algorithm to be implemented for each test case $(N,\\nu,\\alpha,T_{\\text{end}},\\text{initial})$ is as follows:\n1.  Calculate discretization parameters: $\\Delta x = \\frac{1}{N-1}$, $\\Delta t = \\alpha \\frac{\\Delta x^2}{\\nu}$, and the number of time steps $n_{\\text{steps}} = \\lfloor \\frac{T_{\\text{end}}}{\\Delta t} \\rfloor$.\n2.  Initialize the solution vector $u^0$ of size $N$ based on the specified initial condition (\"sine\", \"highfreq\", or \"zero\"). The boundary values $u_0^0$ and $u_{N-1}^0$ are set to $0$.\n3.  Calculate the initial energy $E_0$.\n4.  Iterate for $n$ from $0$ to $n_{\\text{steps}}-1$:\n    a. Compute the solution at the next time step, $u^{n+1}$, using the FTCS update rule for all interior points. The boundary values remain zero.\n    b. Calculate the new energy, $E_{n+1}$.\n    c. Check if $E_{n+1} > E_n + \\varepsilon$. If this condition is met, the property is violated. The result for the test case is `False`, and the simulation for this case can be terminated.\n    d. Update the energy for the next comparison: $E_n \\leftarrow E_{n+1}$.\n5.  If the loop completes without any violation, the property holds, and the result is `True`.\n\nThis procedure will be applied to each test case.\n-   Cases 1, 2, and 4 have $\\alpha \\le 0.5$, so the scheme is stable, and energy monotonicity is expected to hold (`True`). Case 2 represents the stability limit $\\alpha=0.5$.\n-   Case 3 has $\\alpha = 0.6 > 0.5$, which is unstable. The \"highfreq\" initial condition will excite the unstable modes, leading to energy growth (`False`).\n-   Case 5 has $\\alpha = 0.9 > 0.5$ (unstable), but the initial condition is identically zero. For a linear scheme, zero initial data yields a zero solution for all time, assuming no round-off error. Thus, $E_n = 0$ for all $n$, and the condition $E_{n+1} \\le E_n$ is trivially satisfied (`True`).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, nu, alpha, T_end, initial_type):\n    \"\"\"\n    Runs a single simulation of the 1D heat equation and checks for energy monotonicity.\n\n    Args:\n        N (int): Number of grid points.\n        nu (float): Diffusion coefficient.\n        alpha (float): Dimensionless diffusion number.\n        T_end (float): Total simulation time.\n        initial_type (str): Type of initial condition (\"sine\", \"highfreq\", \"zero\").\n\n    Returns:\n        bool: True if discrete energy is monotonically non-increasing, False otherwise.\n    \"\"\"\n    # Step 1: Initialize parameters and grid\n    dx = 1.0 / (N - 1)\n    # Avoid division by zero if nu is zero, though problem states nu > 0\n    if nu == 0:\n        # If nu=0, dt is technically infinite unless alpha=0.\n        # This case is not in the test suite but is a safe guard.\n        if alpha == 0:\n            dt = 0  # No time evolution\n        else:\n            return False # Ill-defined problem\n    else:\n        dt = alpha * dx**2 / nu\n\n    if dt == 0:\n        n_steps = 0\n    else:\n        n_steps = int(T_end / dt)\n\n    x = np.linspace(0.0, 1.0, N)\n    u = np.zeros(N, dtype=np.float64)\n\n    # Step 2: Set initial condition\n    if initial_type == \"sine\":\n        u = np.sin(np.pi * x)\n    elif initial_type == \"highfreq\":\n        m = int(0.45 * (N - 1))\n        # Per problem spec, ensure m >= 1\n        if m < 1:\n            m = 1\n        u = np.sin(m * np.pi * x)\n    elif initial_type == \"zero\":\n        # u is already initialized to zeros\n        pass\n    \n    # Enforce boundary conditions, though initializers above already satisfy them\n    u[0] = 0.0\n    u[-1] = 0.0\n\n    # Step 3: Calculate initial energy\n    E_prev = dx * np.sum(u[1:-1]**2)\n    is_monotonic = True\n\n    # Step 4: Time-stepping loop\n    for _ in range(n_steps):\n        # Create a copy to store the new state\n        u_new = u.copy()\n        \n        # Apply FTCS update rule for interior points\n        u_new[1:-1] = u[1:-1] + alpha * (u[2:] - 2 * u[1:-1] + u[:-2])\n        \n        # Update u for the next iteration\n        u = u_new\n\n        # Calculate new energy\n        E_curr = dx * np.sum(u[1:-1]**2)\n\n        # Check for monotonicity violation with tolerance\n        epsilon = 1e-12 * (1.0 + E_prev)\n        if E_curr > E_prev + epsilon:\n            is_monotonic = False\n            break\n\n        # Update previous energy\n        E_prev = E_curr\n\n    return is_monotonic\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (41, 0.1, 0.4, 0.1, \"sine\"),\n        (41, 0.1, 0.5, 0.1, \"sine\"),\n        (41, 0.1, 0.6, 0.1, \"highfreq\"),\n        (5, 1.0, 0.5, 0.5, \"sine\"),\n        (21, 0.5, 0.9, 0.1, \"zero\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3201887"}, {"introduction": "Building on verifying qualitative properties, we now move to the more rigorous task of quantitative verification against an exact analytical solution. This exercise uses the inviscid Burgers' equation, a fundamental model for nonlinear wave propagation and shock formation. You will implement a shock-capturing finite volume scheme and compare your numerical results directly against the exact solution of a Riemann problem, allowing you to measure the error of your simulation and observe its convergence properties [@problem_id:3201943].", "problem": "You are asked to construct a program that verifies the shock-capturing capability of a first-order finite volume scheme for the one-dimensional inviscid Burgers equation, viewed as a nonlinear conservation law, by comparing computed numerical solutions against exact Riemann solutions for step initial data. Your design must proceed from fundamental definitions: conservation form, flux evaluation, Rankine–Hugoniot jump condition, and entropy-admissible self-similar solutions. Do not use any pre-derived formulas beyond those principles. Implement the following, keeping everything dimensionless.\n\nCore model and verification objective:\n- Consider the one-dimensional inviscid Burgers equation in conservation form\n  $$u_t + \\left(f(u)\\right)_x = 0,$$\n  where the flux is given by $$f(u) = \\tfrac{1}{2} u^2.$$\n- Use a Riemann initial condition with a single discontinuity located at a point $$x_0 \\in \\mathbb{R}:$$\n  $$u(x,0) = \\begin{cases}\n  u_L, & x < x_0,\\\\\n  u_R, & x > x_0.\n  \\end{cases}$$\n- For validation, compare the numerical solution to the exact entropy solution of the Riemann problem constructed from the conservation law, the Rankine–Hugoniot condition for shocks, and the self-similar rarefaction solution where appropriate.\n- For verification, quantify the difference using the discrete $$L^1$$ error at a specified final time $$T > 0,$$ and, for shock cases, additionally estimate the shock location numerically and compare to the exact shock position.\n\nNumerical method to implement:\n- Use a first-order explicit finite volume method on a uniform grid with $$N$$ cells over a domain $$[x_{\\min}, x_{\\max}].$$\n- Let $$\\Delta x = (x_{\\max} - x_{\\min}) / N$$ and advance in time with explicit forward Euler using a time step $$\\Delta t$$ satisfying the Courant–Friedrichs–Lewy (CFL) condition:\n  $$\\Delta t \\le \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_i |u_i|},$$\n  where $$u_i$$ are the cell averages. Choose the Courant–Friedrichs–Lewy (CFL) number as specified in the test suite below.\n- Use the Godunov numerical flux for the inviscid Burgers equation at each cell interface to ensure the correct entropy solution is selected. Implement transmissive (outflow) boundary conditions by copying boundary cell values into ghost states at each time step.\n- Stop at time $$T$$, clipping the last step so that the final time is exactly $$T.$$\n\nExact solution and error metrics:\n- Construct the exact Riemann solution at time $$t = T$$ using:\n  - The Rankine–Hugoniot condition for shocks for $$u_L > u_R,$$ with the exact shock located at $$x_s(T)$$.\n  - The self-similar rarefaction fan for $$u_L < u_R,$$ based on characteristics.\n- Compute the discrete $$L^1$$ error:\n  $$E_{L^1} = \\sum_{i=1}^{N} \\left| u_i^{\\text{num}}(T) - u_i^{\\text{exact}}(T) \\right| \\Delta x.$$\n- For shock cases, estimate the numerical shock position $$\\hat{x}_s(T)$$ by locating where the numerical solution crosses the midpoint state $$\\tfrac{u_L + u_R}{2}$$ and linearly interpolating between neighboring cells; if no sign change is detected, fall back to the position of the largest magnitude discrete gradient. Report the absolute position error $$| \\hat{x}_s(T) - x_s(T) |.$$\n\nGrid, domain, and time:\n- Use the spatial domain $$[x_{\\min}, x_{\\max}] = [-1, 1],$$ discontinuity position $$x_0 = 0,$$ and the final time $$T = 0.2.$$\n- Unless explicitly stated by a test case, use $$\\mathrm{CFL} = 0.9.$$\n\nTest suite:\nImplement the five test cases below. Each case defines input parameters and specifies the single scalar result to be reported for that case. All computations are dimensionless.\n\n1. Shock, error at moderate resolution (happy path):\n   - Parameters: $$u_L = 2.0, \\; u_R = 0.0, \\; x_0 = 0.0, \\; N = 200, \\; T = 0.2, \\; \\mathrm{CFL} = 0.9.$$\n   - Output: the $$L^1$$ error $$E_{L^1}$$ as a float.\n\n2. Shock, observed convergence under refinement:\n   - Parameters: same as Case 1 but compute with both $$N = 200$$ and $$N = 400.$$\n   - Output: an integer indicator that equals $$1$$ if the $$L^1$$ error at $$N = 400$$ is strictly smaller than at $$N = 200,$$ and $$0$$ otherwise.\n\n3. Rarefaction, error at moderate resolution:\n   - Parameters: $$u_L = 0.0, \\; u_R = 2.0, \\; x_0 = 0.0, \\; N = 400, \\; T = 0.2, \\; \\mathrm{CFL} = 0.9.$$\n   - Output: the $$L^1$$ error $$E_{L^1}$$ as a float.\n\n4. Constant state preservation (edge case):\n   - Parameters: $$u_L = 1.0, \\; u_R = 1.0, \\; x_0 = 0.0, \\; N = 200, \\; T = 0.2, \\; \\mathrm{CFL} = 0.9.$$\n   - Output: the maximum absolute deviation of the numerical solution from $$1.0$$ at time $$T,$$ reported as a float.\n\n5. Left-moving shock, shock position accuracy:\n   - Parameters: $$u_L = 0.0, \\; u_R = -2.0, \\; x_0 = 0.0, \\; N = 300, \\; T = 0.2, \\; \\mathrm{CFL} = 0.9.$$\n   - Output: the absolute error in the shock position $$| \\hat{x}_s(T) - x_s(T) |,$$ reported as a float.\n\nRequired final output format:\n- Your program must produce a single line containing a Python-style list with exactly five entries corresponding to the five test cases in order.\n- Floats must be rounded to six decimal places and printed in fixed-point notation without scientific notation.\n- The convergence indicator in Case 2 must be printed as an integer $$0$$ or $$1.$$\n- Example format (values shown are placeholders): \"[0.012345,1,0.006789,0.000000,0.004321]\".", "solution": "The user has specified a problem that requires the verification of a first-order finite volume scheme for the one-dimensional inviscid Burgers' equation against its exact Riemann solutions. The task involves implementing the numerical scheme, constructing the exact solutions for both shock and rarefaction cases, and quantifying the error.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n\n*   **Governing Equation**: The one-dimensional inviscid Burgers' equation in conservation form is $u_t + (f(u))_x = 0$, with flux $f(u) = \\frac{1}{2} u^2$.\n*   **Initial Condition**: A Riemann problem with a single discontinuity at $x_0$: $u(x,0) = u_L$ for $x < x_0$ and $u(x,0) = u_R$ for $x > x_0$.\n*   **Numerical Discretization**: A first-order explicit finite volume method on a uniform grid with $N$ cells over the domain $[x_{\\min}, x_{\\max}] = [-1, 1]$. Cell width is $\\Delta x = (x_{\\max} - x_{\\min}) / N$.\n*   **Time Stepping**: Explicit forward Euler with a time step $\\Delta t$ satisfying the Courant–Friedrichs–Lewy (CFL) condition: $\\Delta t \\le \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_i |u_i|}$. The final time step is clipped to end exactly at time $T$.\n*   **Numerical Flux**: The Godunov numerical flux is to be used at cell interfaces.\n*   **Boundary Conditions**: Transmissive (outflow), implemented by copying boundary cell values to ghost cells.\n*   **Domain and Time Parameters**: $[x_{\\min}, x_{\\max}] = [-1, 1]$, $x_0 = 0$, and $T = 0.2$. The default CFL number is $0.9$.\n*   **Exact Solution Construction**: Based on the Rankine–Hugoniot condition for shocks ($u_L > u_R$) and the self-similar rarefaction solution ($u_L < u_R$).\n*   **Error Metrics**:\n    1.  Discrete $L^1$ error: $E_{L^1} = \\sum_{i=1}^{N} \\left| u_i^{\\text{num}}(T) - u_i^{\\text{exact}}(T) \\right| \\Delta x$.\n    2.  Absolute shock position error: $| \\hat{x}_s(T) - x_s(T) |$.\n*   **Numerical Shock Position Estimation**: Find where the numerical solution crosses the value $\\frac{u_L + u_R}{2}$ using linear interpolation. A fallback method is specified: use the position of the largest magnitude discrete gradient.\n*   **Test Suite**: Five specific test cases are provided with parameters $(u_L, u_R, N, \\mathrm{CFL})$ and a defined output for each.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is analyzed against the validation criteria:\n*   **Scientifically Grounded**: The problem is fundamentally sound. It is based on the Burgers' equation, a canonical model in fluid dynamics and the theory of hyperbolic conservation laws. The concepts of Riemann problems, Rankine–Hugoniot conditions, rarefaction waves, finite volume methods, Godunov flux, and the CFL condition are all standard, well-established principles in applied mathematics and computational science.\n*   **Well-Posed**: The problem is well-posed. It provides a complete specification of the mathematical model, initial and boundary conditions, numerical method, and error analysis procedures. All parameters are explicitly defined for each test case, leading to a unique and meaningful computational task.\n*   **Objective**: The problem is stated in precise, objective, and unambiguous terms. The tasks are quantitative and based on formal mathematical and numerical definitions.\n*   **Completeness and Consistency**: The problem statement is self-contained and free of contradictions. It provides all necessary information to implement the simulation and perform the required analysis.\n*   **Feasibility and Realism**: The problem is computationally feasible. The specified grid sizes and final time lead to simulations that can be completed in a very short time on a standard computer. The setup is a classic verification exercise for numerical schemes.\n*   **Other Flaws**: The problem is not metaphorical, trivial, unverifiable, or pseudo-profound. It is a direct and standard exercise in the verification and validation of numerical methods.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. A full solution will be developed.\n\n### **Solution Design and Principles**\n\nThe solution will be constructed based on the fundamental principles of hyperbolic conservation laws and finite volume methods.\n\n**1. The Inviscid Burgers' Equation and Riemann Problem**\n\nThe governing equation is the inviscid Burgers' equation in conservation form:\n$$ \\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x} \\left(\\frac{1}{2} u^2\\right) = 0 $$\nThis equation models the evolution of a quantity $u$ whose flux is $f(u) = \\frac{1}{2} u^2$. The initial condition is a Riemann problem, which consists of two constant states, $u_L$ and $u_R$, separated by a discontinuity at $x_0$.\n\n**2. Exact Solution of the Riemann Problem**\n\nThe exact solution depends on the relationship between $u_L$ and $u_R$. The characteristic speed for this equation is $f'(u) = u$.\n\n*   **Shock Wave ($u_L > u_R$)**: When characteristics from the left and right of the discontinuity collide, a shock forms. The speed of this discontinuity, $s$, is given by the Rankine–Hugoniot jump condition:\n    $$ s = \\frac{f(u_R) - f(u_L)}{u_R - u_L} = \\frac{\\frac{1}{2}u_R^2 - \\frac{1}{2}u_L^2}{u_R - u_L} = \\frac{1}{2}(u_L + u_R) $$\n    The shock propagates with this constant speed. Its position at time $t$ is $x_s(t) = x_0 + s \\cdot t$. The solution is piecewise constant:\n    $$ u(x, t) = \\begin{cases} u_L, & x < x_s(t) \\\\ u_R, & x > x_s(t) \\end{cases} $$\n\n*   **Rarefaction Wave ($u_L < u_R$)**: When characteristics move apart, an expansion or rarefaction fan develops. The solution is continuous and self-similar, depending only on the variable $\\xi = (x - x_0)/t$. The solution is given by:\n    $$ u(x, t) = \\begin{cases} u_L, & \\text{if } (x - x_0)/t \\le u_L \\\\ (x - x_0)/t, & \\text{if } u_L < (x - x_0)/t < u_R \\\\ u_R, & \\text{if } (x - x_0)/t \\ge u_R \\end{cases} $$\n    For $t=0$, this reduces to the initial condition. For $t>0$, the solution smoothly connects $u_L$ and $u_R$ with a linear-in-$x$ profile.\n\n*   **Constant State ($u_L = u_R$)**: The solution remains constant for all time: $u(x,t) = u_L$.\n\n**3. Finite Volume Method**\n\nWe discretize the domain $[x_{\\min}, x_{\\max}]$ into $N$ cells, $C_i = [x_{i-1/2}, x_{i+1/2}]$, each of width $\\Delta x$. We track the cell average of the solution, $u_i(t) \\approx \\frac{1}{\\Delta x} \\int_{C_i} u(x,t) dx$. Integrating the conservation law over cell $C_i$ and using the divergence theorem yields:\n$$ \\frac{d u_i}{d t} + \\frac{1}{\\Delta x} \\left[ f(u(x_{i+1/2}, t)) - f(u(x_{i-1/2}, t)) \\right] = 0 $$\nWe approximate the instantaneous flux at the cell interface $x_{i+1/2}$ with a numerical flux function $F(u_L, u_R)$ that depends on the states in the adjacent cells, $u_i$ and $u_{i+1}$. Using a first-order explicit Euler time integration, we get the update formula:\n$$ u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right) $$\nwhere $u_i^n$ is the approximation at time $t^n$, and $F_{i+1/2} = F(u_i^n, u_{i+1}^n)$.\n\n**4. Godunov Numerical Flux**\n\nThe Godunov flux is derived from the exact solution of the local Riemann problem at each cell interface. For the interface between cell $i$ (state $u_i$) and cell $i+1$ (state $u_{i+1}$), the flux $F(u_i, u_{i+1})$ is the exact flux $f(u(x,t))$ evaluated at the interface location ($x/t=0$ in local coordinates). This calculation yields:\n$$ F_G(u_L, u_R) = \\begin{cases} f(u_L) & \\text{if } u_L > u_R \\text{ and } s \\ge 0 \\\\ f(u_R) & \\text{if } u_L > u_R \\text{ and } s < 0 \\\\ f(u_L) & \\text{if } u_L \\le u_R \\text{ and } u_L \\ge 0 \\\\ f(u_R) & \\text{if } u_L \\le u_R \\text{ and } u_R \\le 0 \\\\ f(0) = 0 & \\text{if } u_L < 0 < u_R \\end{cases} $$\nwhere $s = \\frac{1}{2}(u_L + u_R)$ is the shock speed. This flux scheme is known to be entropy-satisfying, meaning it correctly captures shocks without producing non-physical expansion shocks.\n\n**5. Time Step and Boundary Conditions**\n\nThe explicit scheme is stable under the CFL condition, which limits the time step $\\Delta t$ based on the maximum wave speed in the domain. For Burgers' equation, the wave speed is $|u|$. Thus,\n$$ \\Delta t = \\mathrm{CFL} \\frac{\\Delta x}{\\max_{i} |u_i^n|} $$\nwhere $\\mathrm{CFL} \\in (0, 1]$ is the Courant number. The final time step must be clipped to ensure the simulation stops exactly at $T$. Transmissive (outflow) boundary conditions are implemented by setting the values in ghost cells equal to their adjacent interior cell, e.g., $u_0 = u_1$ and $u_{N+1} = u_N$.\n\n**6. Error Calculation**\n\nTo compute the $L^1$ error, the numerical solution (which represents cell averages) must be compared to the cell averages of the exact solution. For a cell $C_i = [x_{i-1/2}, x_{i+1/2}]$, the exact cell average is:\n$$ u_i^{\\text{exact}}(T) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u_{\\text{exact}}(x, T) dx $$\nThis integral is computed analytically. For a shock, the integrand is piecewise constant. For a rarefaction, it is piecewise linear, involving the integral of $(x-x_0)/T$, which is elementary.\n\nThe numerical shock position $\\hat{x}_s(T)$ is estimated by finding the two adjacent cell centers $x_{c,j}$ and $x_{c,j+1}$ between which the numerical solution crosses the value $u_{mid} = (u_L+u_R)/2$. A linear interpolation is then used to find the position of this crossing. The absolute error is $| \\hat{x}_s(T) - x_s(T) |$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main driver function to execute the verification suite for the \n    finite volume solution of the inviscid Burgers' equation.\n    \"\"\"\n\n    def godunov_flux(u_l, u_r):\n        \"\"\"Computes the Godunov flux for the Burgers' equation f(u) = 0.5*u^2.\"\"\"\n        f_l = 0.5 * u_l**2\n        f_r = 0.5 * u_r**2\n\n        if u_l > u_r:  # Shock\n            s = 0.5 * (u_l + u_r)\n            return f_l if s >= 0 else f_r\n        else:  # Rarefaction or constant state\n            if u_l >= 0:\n                return f_l\n            elif u_r <= 0:\n                return f_r\n            else:  # u_l < 0 < u_r\n                return 0.0\n\n    def get_exact_solution_cell_avg(x_centers, dx, T, u_l, u_r, x0):\n        \"\"\"\n        Computes the cell-averaged exact solution of the Riemann problem\n        for the Burgers' equation at time T.\n        \"\"\"\n        N = len(x_centers)\n        u_exact_avg = np.zeros(N)\n        \n        if T == 0:\n            return np.where(x_centers < x0, u_l, u_r)\n\n        if u_l > u_r:  # Shock wave\n            s = 0.5 * (u_l + u_r)\n            xs = x0 + s * T\n            for i in range(N):\n                xa = x_centers[i] - 0.5 * dx\n                xb = x_centers[i] + 0.5 * dx\n                if xb <= xs:\n                    u_exact_avg[i] = u_l\n                elif xa >= xs:\n                    u_exact_avg[i] = u_r\n                else:\n                    u_exact_avg[i] = (u_l * (xs - xa) + u_r * (xb - xs)) / dx\n        else:  # Rarefaction wave\n            x_fan_l = x0 + u_l * T\n            x_fan_r = x0 + u_r * T\n            \n            # Indefinite integral of (x-x0)/T is F(x)\n            F = lambda x: (0.5 * x**2 - x0 * x) / T\n            \n            for i in range(N):\n                xa = x_centers[i] - 0.5 * dx\n                xb = x_centers[i] + 0.5 * dx\n                \n                # Part 1: Integral over the left constant region\n                len_l = max(0, min(xb, x_fan_l) - xa)\n                integral_l = u_l * len_l\n\n                # Part 2: Integral over the right constant region\n                len_r = max(0, xb - max(xa, x_fan_r))\n                integral_r = u_r * len_r\n\n                # Part 3: Integral over the fan region\n                ix_a = max(xa, x_fan_l)\n                ix_b = min(xb, x_fan_r)\n                if ix_a >= ix_b:\n                    integral_fan = 0.0\n                else:\n                    integral_fan = F(ix_b) - F(ix_a)\n                \n                u_exact_avg[i] = (integral_l + integral_fan + integral_r) / dx\n\n        return u_exact_avg\n\n    def estimate_shock_pos(u_num, x_centers, dx, u_l, u_r):\n        \"\"\"Estimates the numerical shock position.\"\"\"\n        u_mid = 0.5 * (u_l + u_r)\n        \n        # Find where solution crosses the midpoint\n        crossings = np.where(np.diff(np.sign(u_num - u_mid)))[0]\n\n        if len(crossings) > 0:\n            idx = crossings[0]\n            u1, u2 = u_num[idx], u_num[idx+1]\n            x1, x2 = x_centers[idx], x_centers[idx+1]\n            # Linear interpolation\n            if u2 - u1 != 0:\n                pos = x1 + (x2 - x1) * (u_mid - u1) / (u2 - u1)\n                return pos\n        \n        # Fallback: position of largest gradient magnitude\n        gradient_mag = np.abs(np.diff(u_num))\n        idx = np.argmax(gradient_mag)\n        # Position is the interface between cell idx and idx+1\n        pos = x_centers[idx] + 0.5 * dx\n        return pos\n\n    def run_simulation(u_l, u_r, x0, N, T, cfl, x_min=-1.0, x_max=1.0):\n        \"\"\"\n        Runs the first-order finite volume simulation for Burgers' equation.\n        \"\"\"\n        dx = (x_max - x_min) / N\n        x_centers = x_min + (np.arange(N) + 0.5) * dx\n        u = np.where(x_centers < x0, u_l, u_r)\n        \n        t = 0.0\n        while t < T:\n            max_abs_u = np.max(np.abs(u))\n            \n            if max_abs_u == 0:\n                dt = T - t # If u is zero, it stays zero. Fast-forward.\n            else:\n                dt = cfl * dx / max_abs_u\n            \n            dt = min(dt, T - t)\n            \n            # Transmissive (outflow) boundary conditions using padding\n            u_padded = np.pad(u, 1, 'edge')\n            \n            fluxes = np.zeros(N + 1)\n            for i in range(N + 1):\n                fluxes[i] = godunov_flux(u_padded[i], u_padded[i + 1])\n                \n            u = u - (dt / dx) * (fluxes[1:] - fluxes[:-1])\n            t += dt\n            \n        return u, x_centers, dx\n\n    results = []\n    \n    # --- Test Case 1: Shock, L1 error ---\n    params1 = {'u_l': 2.0, 'u_r': 0.0, 'x0': 0.0, 'N': 200, 'T': 0.2, 'cfl': 0.9}\n    u_num, x_centers, dx = run_simulation(**params1)\n    u_exact = get_exact_solution_cell_avg(x_centers, dx, params1['T'], params1['u_l'], params1['u_r'], params1['x0'])\n    l1_error = np.sum(np.abs(u_num - u_exact)) * dx\n    results.append(l1_error)\n    \n    # --- Test Case 2: Shock, convergence ---\n    params2_200 = {'u_l': 2.0, 'u_r': 0.0, 'x0': 0.0, 'N': 200, 'T': 0.2, 'cfl': 0.9}\n    u_num_200, x_200, dx_200 = run_simulation(**params2_200)\n    u_exact_200 = get_exact_solution_cell_avg(x_200, dx_200, params2_200['T'], params2_200['u_l'], params2_200['u_r'], params2_200['x0'])\n    l1_error_200 = np.sum(np.abs(u_num_200 - u_exact_200)) * dx_200\n    \n    params2_400 = {'u_l': 2.0, 'u_r': 0.0, 'x0': 0.0, 'N': 400, 'T': 0.2, 'cfl': 0.9}\n    u_num_400, x_400, dx_400 = run_simulation(**params2_400)\n    u_exact_400 = get_exact_solution_cell_avg(x_400, dx_400, params2_400['T'], params2_400['u_l'], params2_400['u_r'], params2_400['x0'])\n    l1_error_400 = np.sum(np.abs(u_num_400 - u_exact_400)) * dx_400\n    \n    convergence_indicator = 1 if l1_error_400 < l1_error_200 else 0\n    results.append(convergence_indicator)\n\n    # --- Test Case 3: Rarefaction, L1 error ---\n    params3 = {'u_l': 0.0, 'u_r': 2.0, 'x0': 0.0, 'N': 400, 'T': 0.2, 'cfl': 0.9}\n    u_num, x_centers, dx = run_simulation(**params3)\n    u_exact = get_exact_solution_cell_avg(x_centers, dx, params3['T'], params3['u_l'], params3['u_r'], params3['x0'])\n    l1_error = np.sum(np.abs(u_num - u_exact)) * dx\n    results.append(l1_error)\n    \n    # --- Test Case 4: Constant state preservation ---\n    params4 = {'u_l': 1.0, 'u_r': 1.0, 'x0': 0.0, 'N': 200, 'T': 0.2, 'cfl': 0.9}\n    u_num, x_centers, dx = run_simulation(**params4)\n    max_dev = np.max(np.abs(u_num - 1.0))\n    results.append(max_dev)\n    \n    # --- Test Case 5: Left-moving shock, position error ---\n    params5 = {'u_l': 0.0, 'u_r': -2.0, 'x0': 0.0, 'N': 300, 'T': 0.2, 'cfl': 0.9}\n    u_num, x_centers, dx = run_simulation(**params5)\n    \n    # Exact shock position\n    s_exact = 0.5 * (params5['u_l'] + params5['u_r'])\n    x_s_exact = params5['x0'] + s_exact * params5['T']\n    \n    # Numerical shock position\n    x_s_hat = estimate_shock_pos(u_num, x_centers, dx, params5['u_l'], params5['u_r'])\n    \n    pos_error = np.abs(x_s_hat - x_s_exact)\n    results.append(pos_error)\n\n    # Format output\n    formatted_results = []\n    for i, res in enumerate(results):\n        if i == 1: # Case 2 is an integer\n            formatted_results.append(str(int(res)))\n        else:\n            formatted_results.append(f\"{res:.6f}\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3201943"}, {"introduction": "The behavior of a computational model is profoundly influenced by its interaction with the boundaries of the domain. This final practice shifts the focus from the internal numerical scheme to verifying the implementation and physical consequences of boundary conditions. By simulating diffusion with both reflective (zero-flux) and periodic boundaries, you will test whether your model correctly preserves key invariants like mass and symmetry, providing a powerful method for \"stress-testing\" this critical and often error-prone component of a simulation [@problem_id:3201854].", "problem": "You are tasked with performing a verification and validation exercise on a one-dimensional diffusion model by stress-testing boundary conditions and checking whether key physical invariants are preserved. Implement a program that simulates nondimensional one-dimensional diffusion with two boundary condition types and evaluates invariant preservation across a small test suite. All quantities in this problem are nondimensional (unitless).\n\nThe diffusion process is governed by the Partial Differential Equation (PDE) $$\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2},$$ where $u$ is the field, $t$ is time, $x$ is space, and $D$ is the diffusion coefficient. Use the Finite Difference Method (FDM) with a forward Euler time discretization and a centered second difference for the spatial Laplacian on a uniform grid of $N$ points over a domain of length $L$. Let the time step be $\\Delta t$ and the grid spacing be $\\Delta x$. Define $$\\alpha = \\frac{D \\Delta t}{\\Delta x^2}.$$ Employ two boundary condition types:\n- Reflective (Neumann, zero-flux): $\\frac{\\partial u}{\\partial x} = 0$ at the boundaries.\n- Periodic: $u(x + L) = u(x)$.\n\nYour implementation must:\n1. Evolve the field from an initial condition $u^0$ to $u^n$ for a prescribed total time $T$ by repeatedly applying the explicit update. Select the number of steps $n$ as $n = \\lceil T / \\Delta t \\rceil$ and adjust $\\Delta t$ to exactly satisfy $n \\Delta t = T$. For reflective boundaries, use $\\Delta x = L/(N-1)$; for periodic boundaries, use $\\Delta x = L/N$.\n2. For reflective boundaries, enforce the zero-flux boundary condition using a ghost-point strategy that yields an update at the endpoints consistent with zero gradient.\n3. For periodic boundaries, enforce wrap-around indexing.\n\nDefine the following invariants to be checked:\n- Mass conservation (discrete): the quantity $\\sum_{j} u_j \\Delta x$ is unchanged in time.\n- Symmetry preservation: if the initial field is symmetric (palindromic) about the center, then for linear diffusion the symmetry is preserved.\n- For periodic boundary conditions and a cosine initial condition of wavenumber $k$, the mode amplitude must decay according to the discrete eigenvalue of the periodic discrete Laplacian. If the per-step amplification factor is $$g_k = 1 - 4 \\alpha \\sin^2\\left(\\frac{\\pi k}{N}\\right),$$ then after $n$ steps the amplitude ratio must be $g_k^n$.\n\nTest suite:\n- Case 1 (constant field, cross-boundary comparison):\n  - Parameters: $L = 1.0$, $D = 0.1$, $N = 64$, $T = 0.1$, initialize $u_j^0 = 3.0$ for all $j$.\n  - Time step selection: set $\\alpha = 0.45$ for both boundary types; that is, choose $\\Delta t$ so that $\\alpha = 0.45$ under each boundary type’s $\\Delta x$. Run reflective and periodic independently with their respective $\\Delta x$ and $\\Delta t$.\n  - Output three booleans:\n    - Case 1.1: mass is conserved under reflective boundary.\n    - Case 1.2: mass is conserved under periodic boundary.\n    - Case 1.3: the final arrays produced by reflective and periodic runs are equal within a tolerance when starting from the constant field.\n\n- Case 2 (periodic cosine mode, theoretical amplitude decay):\n  - Parameters: $L = 1.0$, $D = 0.2$, $N = 128$, $T = 0.05$, wavenumber $k = 1$, initialize $u_j^0 = \\cos\\left( \\frac{2\\pi k j}{N} \\right)$.\n  - Time step selection: set $\\alpha = 0.10$ (for periodic boundary with $\\Delta x = L/N$), so $\\Delta t$ must satisfy $\\alpha = D \\Delta t / \\Delta x^2$.\n  - Output three booleans:\n    - Case 2.1: mass is conserved under periodic boundary.\n    - Case 2.2: the measured amplitude ratio equals $g_k^n$ within a tolerance.\n    - Case 2.3: mass is conserved under reflective boundary when run on the same initial condition and $T$ but with its own $\\Delta x$ and $\\Delta t$ corresponding to $\\alpha = 0.10$.\n\n- Case 3 (palindromic symmetric shape, symmetry preservation under both boundaries):\n  - Parameters: $L = 1.0$, $D = 0.1$, $N = 129$, $T = 0.05$, initialize $u^0$ as a palindromic triangular bump symmetric about the center (e.g., construct the left half and mirror it to the right half so that $u_j^0 = u_{N-1-j}^0$ exactly).\n  - Time step selection: set $\\alpha = 0.45$ under both boundary types.\n  - Output three booleans:\n    - Case 3.1: mass is conserved under reflective boundary.\n    - Case 3.2: symmetry (palindromic property) is preserved under reflective boundary within a tolerance.\n    - Case 3.3: symmetry is preserved under periodic boundary within a tolerance.\n\n- Case 4 (edge stability at the Courant limit, minimal grid):\n  - Parameters: $L = 1.0$, $D = 0.1$, $N = 3$, initialize $u^0 = [1.0, 0.0, 0.0]$, choose $\\Delta t = \\Delta x^2/(2D)$ to make $\\alpha = 0.5$, and set $T = 5 \\Delta t$.\n  - Boundary: periodic.\n  - Output three booleans:\n    - Case 4.1: mass is conserved.\n    - Case 4.2: all values remain finite (no Not-a-Number or infinity) over the simulation.\n    - Case 4.3: the solution remains within the initial range $[\\min(u^0), \\max(u^0)]$.\n\nTolerance policy:\n- Use an absolute tolerance $\\varepsilon_{\\text{abs}} = 10^{-10}$ and a relative tolerance $\\varepsilon_{\\text{rel}} = 10^{-9}$ when comparing floating-point quantities (e.g., mass and symmetry).\n- For amplitude ratio comparison, use $\\varepsilon_{\\text{rel}} = 10^{-8}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\"). List the booleans for the four cases in the specified order: Case 1.1, Case 1.2, Case 1.3, Case 2.1, Case 2.2, Case 2.3, Case 3.1, Case 3.2, Case 3.3, Case 4.1, Case 4.2, Case 4.3.", "solution": "The problem statement has been analyzed and is determined to be **valid**. It is a well-posed, scientifically sound problem in the field of computational science, focused on the verification and validation of a numerical model.\n\nThe core task is to simulate the one-dimensional diffusion equation,\n$$ \\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} $$\nusing the Finite Difference Method (FDM). We employ the Forward Time, Centered Space (FTCS) scheme on a uniform grid.\n\nLet $u_j^n$ represent the numerical approximation of the field $u(x, t)$ at grid point $x_j = j \\Delta x$ and time $t_n = n \\Delta t$. The FTCS discretization is:\n$$ \\frac{u_j^{n+1} - u_j^n}{\\Delta t} = D \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{\\Delta x^2} $$\nRearranging for the time-marching update rule gives:\n$$ u_j^{n+1} = u_j^n + \\frac{D \\Delta t}{\\Delta x^2} (u_{j+1}^n - 2u_j^n + u_{j-1}^n) $$\nIntroducing the non-dimensional stability parameter $\\alpha = \\frac{D \\Delta t}{\\Delta x^2}$, the update becomes:\n$$ u_j^{n+1} = u_j^n + \\alpha (u_{j+1}^n - 2u_j^n + u_{j-1}^n) $$\nThis equation applies to the interior points of the grid. The boundary points require special handling based on the specified boundary conditions. The grid spacing $\\Delta x$ depends on the boundary condition type and the number of grid points $N$ over a domain of length $L$:\n- For reflective boundaries: $\\Delta x = L/(N-1)$\n- For periodic boundaries: $\\Delta x = L/N$\n\nThe simulation runs for a total time $T$. The time step $\\Delta t$ is initially determined by the desired $\\alpha$ value, $\\Delta t_{\\text{initial}} = \\alpha \\Delta x^2 / D$. The number of steps is then $n = \\lceil T / \\Delta t_{\\text{initial}} \\rceil$. To ensure the simulation ends precisely at $T$, the time step is adjusted to $\\Delta t = T/n$. This can slightly alter the value of $\\alpha$, which must be recalculated for the simulation loop.\n\n**Boundary Condition Implementation**\n\n1.  **Reflective (Neumann) Boundary Conditions**: This condition, $\\frac{\\partial u}{\\partial x} = 0$, implies no flux across the boundaries. We implement this using ghost points.\n    - At the left boundary ($x=0$, index $j=0$): a ghost point $u_{-1}^n$ is introduced. A centered difference for the gradient gives $\\frac{u_1^n - u_{-1}^n}{2 \\Delta x} = 0$, which implies $u_{-1}^n = u_1^n$. Substituting this into the general update rule for $j=0$ yields:\n      $$ u_0^{n+1} = u_0^n + \\alpha(u_1^n - 2u_0^n + u_1^n) = u_0^n + 2\\alpha(u_1^n - u_0^n) $$\n    - At the right boundary ($x=L$, index $j=N-1$): a ghost point $u_{N}^n$ is used. The condition $\\frac{u_{N}^n - u_{N-2}^n}{2 \\Delta x} = 0$ implies $u_{N}^n = u_{N-2}^n$. Substituting into the general update rule for $j=N-1$:\n      $$ u_{N-1}^{n+1} = u_{N-1}^n + \\alpha(u_{N}^n - 2u_{N-1}^n + u_{N-2}^n) = u_{N-1}^n + 2\\alpha(u_{N-2}^n - u_{N-1}^n) $$\n\n2.  **Periodic Boundary Conditions**: This condition, $u(x+L) = u(x)$, means the grid wraps around. The neighbors of point $u_0$ are $u_1$ and $u_{N-1}$, and the neighbors of $u_{N-1}$ are $u_0$ and $u_{N-2}$. The general update rule applies to all points $j \\in \\{0, 1, \\dots, N-1\\}$ by using modular arithmetic for indices (e.g., $(j+1) \\pmod N$ and $(j-1) \\pmod N$). This is efficiently implemented using `numpy.roll`.\n\n**Verification and Validation Checks**\n\nA helper function `is_close(a, b, rtol, atol)` is used to compare floating-point values, implemented as `abs(a - b) <= (atol + rtol * abs(b))`.\n\n- **Mass Conservation**: The total discrete mass is $M = \\Delta x \\sum_{j=0}^{N-1} u_j$. We check if the initial mass $M_0$ and final mass $M_f$ are close, using $\\varepsilon_{\\text{rel}} = 10^{-9}$ and $\\varepsilon_{\\text{abs}} = 10^{-10}$.\n\n- **Symmetry Preservation**: For an initial condition that is palindromic ($u_j^0 = u_{N-1-j}^0$), the final state $u^n$ should also be palindromic. This is checked by comparing the final array `u_final` with its reversed version, `u_final[::-1]`.\n\n- **Amplitude Decay**: For a periodic cosine initial condition $u_j^0 = \\cos\\left( \\frac{2\\pi k j}{N} \\right)$, the theoretical amplification factor for the FTCS scheme is $g_k = 1 - 4 \\alpha \\sin^2\\left(\\frac{\\pi k}{N}\\right)$. After $n$ steps, the final amplitude should be $g_k^n$ times the initial amplitude. The measured final amplitude is taken as $u_0^n$. The initial amplitude is $u_0^0 = 1$. The check compares the measured ratio $u_0^n/u_0^0 = u_0^n$ with the theoretical ratio $g_k^n$ using a relative tolerance $\\varepsilon_{\\text{rel}} = 10^{-8}$.\n\n- **Stability and Range**: For the case with $\\alpha=0.5$, which is at the limit of stability, we verify that the solution remains finite (no `NaN` or `inf` values) and adheres to the maximum principle, meaning the values in $u^n$ stay within the range of the initial values $[\\min(u^0), \\max(u^0)]$.\n\nThe provided Python code implements these principles in a `simulate` function that handles the core FDM logic for both boundary conditions. The `solve` function orchestrates the four test cases as specified, calculates the twelve boolean results, and prints them in the required format.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a verification and validation exercise on a 1D diffusion model.\n    \"\"\"\n    \n    # Tolerance policy\n    ATOL = 1e-10\n    RTOL_MASS_SYM = 1e-9\n    RTOL_AMP = 1e-8\n\n    def simulate(L, D, N, T, u0_in, bc_type, alpha):\n        \"\"\"\n        Simulates the 1D diffusion equation using the FTCS scheme.\n        \"\"\"\n        u0 = u0_in.copy()\n        \n        if bc_type == 'reflective':\n            dx = L / (N - 1)\n        elif bc_type == 'periodic':\n            dx = L / N\n        else:\n            raise ValueError(\"Invalid boundary condition type.\")\n\n        # Determine dt and number of steps\n        if D > 0 and dx > 0:\n            dt_initial = alpha * dx**2 / D\n            if T > 0 and dt_initial > 0:\n                n_steps = int(np.ceil(T / dt_initial))\n            else:\n                n_steps = 1\n            if n_steps == 0:\n                n_steps = 1 # Ensure at least one step if T is very small\n        else: # Handle D=0 or dx=0 cases\n            dt_initial = 0\n            n_steps = 1\n        \n        dt = T / n_steps\n        \n        # Recalculate alpha with the adjusted dt\n        alpha_actual = D * dt / dx**2 if dx > 0 else 0.0\n\n        u = u0.copy()\n        for _ in range(n_steps):\n            u_new = u.copy()\n            if bc_type == 'reflective':\n                # Interior points\n                u_new[1:-1] = u[1:-1] + alpha_actual * (u[2:] - 2 * u[1:-1] + u[:-2])\n                # Boundary points\n                u_new[0] = u[0] + 2 * alpha_actual * (u[1] - u[0])\n                u_new[-1] = u[-1] + 2 * alpha_actual * (u[-2] - u[-1])\n            elif bc_type == 'periodic':\n                u_jp1 = np.roll(u, -1)\n                u_jm1 = np.roll(u, 1)\n                u_new = u + alpha_actual * (u_jp1 - 2 * u + u_jm1)\n            u = u_new\n            \n        return u, dx, dt, n_steps, alpha_actual\n\n    results = []\n\n    # --- Case 1 ---\n    L1, D1, N1, T1, alpha1 = 1.0, 0.1, 64, 0.1, 0.45\n    u0_1 = np.full(N1, 3.0)\n\n    # 1.1: Mass conservation (reflective)\n    u_ref_1, dx_ref_1, _, _, _ = simulate(L1, D1, N1, T1, u0_1, 'reflective', alpha1)\n    mass0_ref_1 = np.sum(u0_1) * dx_ref_1\n    massf_ref_1 = np.sum(u_ref_1) * dx_ref_1\n    results.append(np.isclose(mass0_ref_1, massf_ref_1, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 1.2: Mass conservation (periodic)\n    u_per_1, dx_per_1, _, _, _ = simulate(L1, D1, N1, T1, u0_1, 'periodic', alpha1)\n    mass0_per_1 = np.sum(u0_1) * dx_per_1\n    massf_per_1 = np.sum(u_per_1) * dx_per_1\n    results.append(np.isclose(mass0_per_1, massf_per_1, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 1.3: Final arrays equality\n    results.append(np.allclose(u_ref_1, u_per_1, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # --- Case 2 ---\n    L2, D2, N2, T2, k2, alpha2 = 1.0, 0.2, 128, 0.05, 1, 0.10\n    j2 = np.arange(N2)\n    u0_2 = np.cos(2 * np.pi * k2 * j2 / N2)\n\n    # Periodic run for 2.1 and 2.2\n    u_per_2, dx_per_2, _, n_per_2, alpha_p_act_2 = simulate(L2, D2, N2, T2, u0_2, 'periodic', alpha2)\n\n    # 2.1: Mass conservation (periodic)\n    mass0_per_2 = np.sum(u0_2) * dx_per_2\n    massf_per_2 = np.sum(u_per_2) * dx_per_2\n    results.append(np.isclose(mass0_per_2, massf_per_2, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 2.2: Amplitude decay\n    g_k = 1 - 4 * alpha_p_act_2 * np.sin(np.pi * k2 / N2)**2\n    theo_ratio = g_k**n_per_2\n    meas_ratio = u_per_2[0] / u0_2[0]\n    results.append(np.isclose(meas_ratio, theo_ratio, rtol=RTOL_AMP, atol=ATOL))\n\n    # 2.3: Mass conservation (reflective)\n    u_ref_2, dx_ref_2, _, _, _ = simulate(L2, D2, N2, T2, u0_2, 'reflective', alpha2)\n    mass0_ref_2 = np.sum(u0_2) * dx_ref_2\n    massf_ref_2 = np.sum(u_ref_2) * dx_ref_2\n    results.append(np.isclose(mass0_ref_2, massf_ref_2, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # --- Case 3 ---\n    L3, D3, N3, T3, alpha3 = 1.0, 0.1, 129, 0.05, 0.45\n    mid3 = (N3 - 1) / 2\n    u0_3 = 1.0 - np.abs(np.arange(N3) - mid3) / mid3\n\n    # 3.1: Mass conservation (reflective)\n    u_ref_3, dx_ref_3, _, _, _ = simulate(L3, D3, N3, T3, u0_3, 'reflective', alpha3)\n    mass0_ref_3 = np.sum(u0_3) * dx_ref_3\n    massf_ref_3 = np.sum(u_ref_3) * dx_ref_3\n    results.append(np.isclose(mass0_ref_3, massf_ref_3, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 3.2: Symmetry preservation (reflective)\n    results.append(np.allclose(u_ref_3, u_ref_3[::-1], rtol=RTOL_MASS_SYM, atol=ATOL))\n    \n    # 3.3: Symmetry preservation (periodic)\n    u_per_3, _, _, _, _ = simulate(L3, D3, N3, T3, u0_3, 'periodic', alpha3)\n    results.append(np.allclose(u_per_3, u_per_3[::-1], rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # --- Case 4 ---\n    L4, D4, N4 = 1.0, 0.1, 3\n    u0_4 = np.array([1.0, 0.0, 0.0])\n    alpha4 = 0.5\n    \n    # Override T calculation for this case\n    dx4 = L4 / N4\n    dt4 = alpha4 * dx4**2 / D4\n    T4 = 5 * dt4\n\n    # Run simulation with periodic BC\n    u_final_4, dx_final_4, _, n_steps_4, _ = simulate(L4, D4, N4, T4, u0_4, 'periodic', alpha4)\n    \n    # 4.1: Mass conservation\n    mass0_4 = np.sum(u0_4) * dx_final_4\n    massf_4 = np.sum(u_final_4) * dx_final_4\n    results.append(np.isclose(mass0_4, massf_4, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 4.2: Finiteness\n    results.append(np.all(np.isfinite(u_final_4)))\n    \n    # 4.3: Range preservation (Maximum Principle)\n    min_u0 = np.min(u0_4)\n    max_u0 = np.max(u0_4)\n    range_ok = np.all((u_final_4 >= min_u0 - ATOL) & (u_final_4 <= max_u0 + ATOL))\n    results.append(range_ok)\n\n    # Format output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3201854"}]}