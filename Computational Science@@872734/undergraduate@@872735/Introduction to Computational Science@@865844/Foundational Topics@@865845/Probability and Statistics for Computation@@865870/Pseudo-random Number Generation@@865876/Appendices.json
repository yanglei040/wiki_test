{"hands_on_practices": [{"introduction": "While a good pseudo-random number generator should produce outputs that are statistically uniform, its deterministic nature can hide subtle, non-random patterns. This exercise delves into the famous structural flaw of Linear Congruential Generators (LCGs), where successive values can fall onto predictable lattices. By generating sequences and computing specific metrics, you will learn to uncover how a generator that appears perfectly uniform in one dimension can exhibit clear geometric structure in two dimensions [@problem_id:3264088].", "problem": "Consider sequences produced by deterministic maps on residue classes modulo an integer, and their behavior when normalized to the unit interval. Let $m \\in \\mathbb{N}$, and let $(X_i)_{i \\ge 0}$ be a sequence with $X_i \\in \\{0,1,\\dots,m-1\\}$, together with its normalized form $U_i = X_i / m \\in [0,1)$. The one-dimensional marginal uniformity is defined discretely as visiting each residue exactly once over a full cycle, and the two-dimensional structure is assessed by the geometry of successive pairs $(U_i, U_{i+1})$.\n\nStarting from the foundational definitions of modular arithmetic and bijections of residue classes, design and implement generators that produce sequences with the following properties:\n- A generator whose one-dimensional marginal distribution over $\\{0,1,\\dots,m-1\\}$ is exactly uniform in the sense that over one cycle every residue appears exactly once.\n- A generator whose successive pairs $(X_i, X_{i+1})$ satisfy a linear modular relation, so that the normalization to $(U_i,U_{i+1})$ exhibits an easily detectable geometric structure in two dimensions.\n\nYour program must:\n1. Generate the sequences required by each test case.\n2. Compute the following quantitative metrics for each test case, all based on the normalized pairs $(U_i, U_{i+1})$:\n    - The one-dimensional uniformity ratio defined as $|\\mathrm{VisitedStates}| / m$, where $|\\mathrm{VisitedStates}|$ is the number of distinct values in $\\{X_i\\}$ observed over one detected cycle. This ratio is a real number in $[0,1]$.\n    - The occupancy count of a uniform grid of size $G \\times G$ over $[0,1) \\times [0,1)$, defined as the number of distinct grid cells hit by the set of pairs $(U_i, U_{i+1})$ with cell indices $(\\lfloor G U_i \\rfloor, \\lfloor G U_{i+1} \\rfloor)$. This count is an integer.\n    - The Pearson correlation coefficient between the components of the pair cloud $(U_i,U_{i+1})$, taken over all available pairs. This coefficient is a real number.\n    - The number of distinct bins of the modular difference $(X_{i+1} - X_i) \\bmod m$ under coarse binning of width $m/G$, i.e., the count of distinct values of $\\left\\lfloor \\frac{(X_{i+1} - X_i) \\bmod m}{m/G} \\right\\rfloor$. This count is an integer.\n\nUse only the definitions of modular arithmetic and bijections on residue classes as the fundamental base. Do not rely on any unproven shortcut formulas. You must derive from first principles why the one-dimensional marginal can be exactly uniform and simultaneously why the two-dimensional successive-pair plot can display a visible structure.\n\nImplement the following test suite, which is designed to cover a general case, a boundary case, and comparative cases. For all cases, use $G = 64$:\n- Case A (additive congruential full cycle): modulus $m = 4096$, increment $c = 5$, seed $X_0 = 0$. Generate a sequence by successively adding $c$ modulo $m$ until the state repeats, then stop at the first repeat.\n- Case B (additive congruential short cycle edge case): modulus $m = 4096$, increment $c = 512$, seed $X_0 = 0$. Generate the sequence by successive addition modulo $m$ until the state repeats, then stop.\n- Case C (linear congruential general case): modulus $m = 4096$, multiplier $a = 5$, increment $c = 1$, seed $X_0 = 1$. Generate the sequence by repeated application of a linear map modulo $m$ until the state repeats, then stop.\n- Case D (independent uniform baseline): modulus $m = 4096$, seed $s = 12345$. Generate $m$ independent samples $U_i \\in [0,1)$, set $X_i = \\lfloor m U_i \\rfloor$, and use the first $m$ values without cycle detection.\n\nFor each case, compute the four metrics listed above using all available consecutive pairs $(U_i, U_{i+1})$, where the index $i$ runs over the generated sequence positions for that case and stops before the last element when pairs are not wrapped. Express all quantities as pure numbers without units.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each caseâ€™s result is a four-element list in the order: $[$uniformity ratio$, $occupancy count$, $correlation coefficient$, $difference-bin count$]. For example, the output should look like $[[r_1,o_1,\\rho_1,b_1],[r_2,o_2,\\rho_2,b_2],[r_3,o_3,\\rho_3,b_3],[r_4,o_4,\\rho_4,b_4]]$, with no extra whitespace or text.", "solution": "The problem requires an analysis and implementation of deterministic sequences generated by modular arithmetic, commonly used in pseudo-random number generation. The core of the task is to understand, from first principles, the properties of these sequences, specifically their one-dimensional uniformity and two-dimensional structure.\n\n## Foundational Principles\n\n### Modular Arithmetic and LCGs\nA sequence $(X_i)_{i \\ge 0}$ is generated within the set of residue classes modulo $m$, $\\mathbb{Z}_m = \\{0, 1, \\dots, m-1\\}$. A widely studied class of such generators is the Linear Congruential Generator (LCG), defined by the recurrence relation:\n$$X_{i+1} = (a X_i + c) \\bmod m$$\nwhere $m > 0$ is the modulus, $a$ is the multiplier, $c$ is the increment, and $X_0$ is the seed. When $a=1$, the generator is called an Additive Congruential Generator (ACG). The normalized sequence is given by $U_i = X_i/m \\in [0, 1)$.\n\n### One-Dimensional Uniformity and Periodicity\nA key property of a good generator is a long period. The period is the smallest $p > 0$ such that $X_{i+p} = X_i$ for all $i$. For the generator to be maximally useful, we desire the period to be as large as possible. An LCG has a full period of $m$ if and only if it generates every integer in $\\{0, 1, \\dots, m-1\\}$ exactly once before repeating. This confers perfect one-dimensional marginal uniformity, meaning the uniformity ratio $|\\mathrm{VisitedStates}|/m$ is exactly $1$.\n\nThe conditions for a full period depend on the parameters $a$, $c$, and $m$.\n1.  **For an ACG ($a=1$):** The recurrence is $X_{i+1} = (X_i + c) \\bmod m$. The sequence of states is an arithmetic progression modulo $m$. The sequence has a full period $m$ if and only if the increment $c$ is a generator of the additive group $\\mathbb{Z}_m$, which requires that $c$ is coprime to $m$. That is, $\\gcd(c, m) = 1$. If $\\gcd(c, m) = d > 1$, the period is shortened to $m/d$.\n\n2.  **For an LCG ($a>1$):** When the modulus $m$ is a power of $2$, say $m = 2^k$ for $k \\ge 2$, the celebrated Hull-Dobell Theorem states that the LCG has a full period $m$ if and only if:\n    -   $c$ is odd (i.e., $\\gcd(c, m) = 1$).\n    -   $a \\equiv 1 \\pmod 4$.\n\n### Two-Dimensional Structure\nThe deterministic nature of LCGs imposes a rigid structure on successive pairs $(X_i, X_{i+1})$. Normalizing the LCG recurrence, we get:\n$$m U_{i+1} = (a m U_i + c) \\pmod m$$\nDividing by $m$ gives:\n$$U_{i+1} = (a U_i + c/m) \\pmod 1$$\nThis equation reveals that all successive pairs $(U_i, U_{i+1})$ lie on a finite number of parallel hyperplanes. In two dimensions, these are lines. Specifically, the points fall on the line segments defined by $y = ax + c/m - k$ for integers $k$ such that the line intersects the unit square $[0,1) \\times [0,1)$. This inherent lattice structure is an \"easily detectable geometric structure\" and a well-known weakness of LCGs, which the specified metrics are designed to quantify.\n\n## Analysis of Test Cases\n\nFor all cases, the grid size for occupancy metrics is $G=64$.\n\n**Case A: Additive Congruential, Full Cycle**\n($m=4096$, $c=5$, $X_0=0$, $a=1$)\n-   **Uniformity:** $m=4096=2^{12}$ and $c=5$. Since $5$ is an odd number, it shares no factors with a power of 2, so $\\gcd(5, 4096)=1$. The ACG has a full period of $m=4096$. The sequence visits every state in $\\{0, \\dots, 4095\\}$ exactly once. The uniformity ratio is $4096/4096 = 1.0$.\n-   **Structure:** The pairs $(U_i, U_{i+1})$ satisfy $U_{i+1} = (U_i + 5/4096) \\pmod 1$. The points lie on two parallel lines. A strong positive correlation is expected. The modular difference $(X_{i+1} - X_i) \\bmod m$ is always $5$. This single value falls into bin $\\lfloor 5 / (4096/64) \\rfloor = \\lfloor 5/64 \\rfloor = 0$. Thus, the difference-bin count is $1$.\n\n**Case B: Additive Congruential, Short Cycle**\n($m=4096$, $c=512$, $X_0=0$, $a=1$)\n-   **Uniformity:** Here, $c=512=2^9$. The greatest common divisor is $\\gcd(512, 4096) = 512$. The period is $m/\\gcd(c,m) = 4096/512 = 8$. The sequence only visits $8$ states. The uniformity ratio is $8/4096 = 1/512$.\n-   **Structure:** The $8$ states are all multiples of $512$. The pairs $(U_i, U_{i+1})$ lie on a single line $y=x+1/8$. The correlation will be perfect. The modular difference is always $512$, falling into bin $\\lfloor 512 / 64 \\rfloor = 8$. The difference-bin count is $1$.\n\n**Case C: Linear Congruential, General Case**\n($m=4096$, $a=5$, $c=1$, $X_0=1$)\n-   **Uniformity:** The Hull-Dobell conditions are satisfied: $m=2^{12}$, $c=1$ is odd, and $a=5 \\equiv 1 \\pmod 4$. The LCG has a full period of $m=4096$. The uniformity ratio is $1.0$.\n-   **Structure:** The pairs $(U_i, U_{i+1})$ lie on $a=5$ parallel lines defined by $U_{i+1} = (5 U_i + 1/4096) \\pmod 1$. The modular difference is $(X_{i+1} - X_i) \\bmod m = (4X_i + 1) \\bmod m$. Since $X_i$ sweeps through all residues, and $\\gcd(4, 4096)=4$, the difference takes on $4096/4=1024$ distinct values, all congruent to $1 \\pmod 4$. These values are $\\{1, 5, 9, \\dots\\}$. These $1024$ values are well-distributed over $[0, 4096)$ and will fall into all $G=64$ bins of width $m/G=64$. The difference-bin count will be $64$.\n\n**Case D: Independent Uniform Baseline**\n($m=4096$, $s=12345$)\n-   This case serves as a benchmark for \"good\" randomness, where successive values are independent.\n-   **Uniformity:** $m=4096$ values are drawn. The number of unique states visited relates to the coupon collector's problem. The expected number of unique values is $m(1-(1-1/m)^m) \\approx m(1-1/e) \\approx 0.632m$. So the ratio should be near $0.632$.\n-   **Structure:** With independent pairs $(U_i, U_{i+1})$, the points should be scattered uniformly over the unit square with no discernible linear structure. The Pearson correlation should be close to $0$. The points should occupy many grid cells, with an expected count similar to the uniformity result, approximately $m(1-e^{-1}) \\approx 2588$. The modular differences $(X_{i+1}-X_i)\\bmod m$ will be approximately uniform over $\\{0, \\dots, m-1\\}$. With $4095$ such differences, it is overwhelmingly probable that all $64$ bins will be visited. The difference-bin count should be $64$.\n\n## Quantitative Metrics\nThe problem defines four metrics to be computed:\n1.  **Uniformity Ratio:** $R_U = \\frac{|\\{X_i\\}|}{m}$, where $|\\{X_i\\}|$ is the number of distinct states visited in a cycle.\n2.  **Occupancy Count:** $N_{occ} = |\\{(\\lfloor G U_i \\rfloor, \\lfloor G U_{i+1} \\rfloor)\\}|$, the number of unique cells in a $G \\times G$ grid hit by pairs $(U_i, U_{i+1})$.\n3.  **Pearson Correlation Coefficient:** $\\rho(U_i, U_{i+1}) = \\frac{\\mathrm{Cov}(U_i, U_{i+1})}{\\sigma_{U_i}\\sigma_{U_{i+1}}}$, measuring linear correlation between successive normalized values.\n4.  **Difference-Bin Count:** $N_{db} = |\\{\\lfloor \\frac{(X_{i+1}-X_i)\\bmod m}{m/G} \\rfloor\\}|$, the number of unique coarse bins hit by the modular difference.\n\nThe implementation will now follow these principles to generate the sequences and compute the specified metrics for each case.", "answer": "```python\nimport numpy as np\n\ndef generate_sequence_lcg(m, a, c, x0):\n    \"\"\"\n    Generates a sequence from a Linear Congruential Generator (LCG)\n    X_{i+1} = (a * X_i + c) mod m, until the first state repeats.\n    \"\"\"\n    seq = []\n    # Use a dictionary for fast lookups and to store the first occurrence index.\n    visited = {}\n    x = x0\n    i = 0\n    while x not in visited:\n        visited[x] = i\n        seq.append(x)\n        x = (a * x + c) % m\n        i += 1\n    return np.array(seq, dtype=np.int64)\n\ndef calculate_metrics(X, m, G):\n    \"\"\"\n    Calculates the four specified metrics for a given sequence X.\n    \"\"\"\n    # 1. One-dimensional uniformity ratio\n    # Using np.unique is a robust way to count distinct elements.\n    num_distinct_states = len(np.unique(X))\n    uniformity_ratio = num_distinct_states / m\n\n    if len(X) < 2:\n        # Cannot compute pair-based metrics if sequence length is less than 2.\n        return [uniformity_ratio, 0, 0.0, 0]\n\n    # Create consecutive pairs from the sequence\n    X_i = X[:-1]\n    X_ip1 = X[1:]\n\n    # Normalize pairs to the unit interval [0, 1)\n    U_i = X_i / m\n    U_ip1 = X_ip1 / m\n\n    # 2. Occupancy count of a uniform grid\n    grid_indices = np.floor(np.vstack([U_i * G, U_ip1 * G]).T).astype(np.int32)\n    # Using a set of tuples is an efficient way to count unique 2D integer points.\n    unique_cells = set(map(tuple, grid_indices))\n    occupancy_count = len(unique_cells)\n\n    # 3. Pearson correlation coefficient\n    # Check for constant series to avoid NaN from division by zero in correlation formula.\n    if np.std(U_i) == 0 or np.std(U_ip1) == 0:\n        correlation = 1.0 if np.array_equal(U_i, U_ip1) else 0.0\n    else:\n        correlation = np.corrcoef(U_i, U_ip1)[0, 1]\n\n    # 4. Number of distinct bins of the modular difference\n    # np.mod ensures the result is in [0, m), correctly handling negative differences.\n    diff = np.mod(X_ip1 - X_i, m)\n    bin_width = m / G\n    diff_bins = np.floor(diff / bin_width)\n    diff_bin_count = len(np.unique(diff_bins))\n    \n    return [uniformity_ratio, occupancy_count, correlation, diff_bin_count]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (name, (m, a, c, x0), G) or (name, (m, seed), G)\n    test_cases = [\n        ('A', (4096, 1, 5, 0), 64),\n        ('B', (4096, 1, 512, 0), 64),\n        ('C', (4096, 5, 1, 1), 64),\n        ('D', (4096, 12345), 64)\n    ]\n\n    results = []\n    for case in test_cases:\n        name, params, G = case\n        \n        if name == 'D':\n            m, seed = params\n            # Generate sequence for Case D (independent uniform baseline)\n            rng = np.random.default_rng(seed=seed)\n            U = rng.random(size=m)\n            X = np.floor(m * U).astype(np.int64)\n        else:\n            # Generate sequence for Cases A, B, C (LCGs)\n            m, a, c, x0 = params\n            X = generate_sequence_lcg(m, a, c, x0)\n            \n        metrics = calculate_metrics(X, m, G)\n        results.append(metrics)\n\n    # The final print statement must produce the exact single-line format.\n    # repr() creates a string representation of the list, and replace() removes spaces.\n    print(repr(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3264088"}, {"introduction": "The same deterministic structure that leads to the lattice-like patterns seen in the previous exercise can also be a powerful feature. Because the state of an LCG evolves according to a precise mathematical formula, we can \"jump\" ahead in the sequence by many steps in a single, efficient operation. This practice guides you through deriving and implementing this skip-ahead functionality, a crucial technique for generating independent streams for parallel computations [@problem_id:3179049].", "problem": "You will implement and verify a skip-ahead operation for a linear congruential generator (LCG). An LCG over the integers modulo $m$ is defined by the recurrence $x_{n+1} \\equiv a x_n + c \\pmod m$, where $a$, $c$, $m$ are fixed integers with $m \\geq 2$, and $x_n \\in \\{0,1,\\dots,m-1\\}$. Your task is to derive, implement, and test a procedure that advances the state by $t$ steps in a single operation, starting from the fundamental definition of the LCG and the standard rules of modular arithmetic.\n\nStarting points (fundamental base):\n- Definition of modular arithmetic: for integers $u$, $v$, and $m \\ge 2$, $u \\equiv v \\pmod m$ if and only if $m$ divides $u - v$; addition and multiplication are compatible with the modulus.\n- Finite geometric series identity over the integers: for integer $t \\ge 1$, $\\sum_{k=0}^{t-1} r^k = \\frac{r^t - 1}{r - 1}$ when $r \\ne 1$.\n- Exponentiation by squaring computes $b^e$ with $O(\\log e)$ multiplications.\n- The modular multiplicative inverse of an integer $q$ modulo $m$ exists if and only if $\\gcd(q,m)=1$; it can be computed by the Extended Euclidean Algorithm.\n\nRequirements:\n1) Derive from the recurrence $x_{n+1} \\equiv a x_n + c \\pmod m$ a closed-form expression for $x_{n+t}$ in terms of $x_n$, $a$, $c$, $t$, and $m$. Express the finite sum that appears and explain when division by $a-1$ is valid modulo $m$.\n2) Design an $O(\\log t)$ skip-ahead algorithm that computes $x_{n+t}$ from $x_n$ without iterating $t$ times, using:\n   - exponentiation by squaring for computing $a^t \\bmod m$, and\n   - the Extended Euclidean Algorithm to compute a modular multiplicative inverse when needed.\n   Handle the boundary case $t=0$ correctly.\n3) Verification by numerical experiments: For each test case below, verify the skip-ahead result against a ground truth. The ground truth must be computed by directly iterating the recurrence $t$ times when $t$ is small enough to be computationally reasonable, and by algebraic consistency checks otherwise. Use pure integer arithmetic throughout.\n\nAssumptions:\n- For all test cases, assume $\\gcd(a-1,m)=1$ so that division by $a-1$ modulo $m$ is valid whenever it appears.\n- Angles do not appear. No physical units are involved.\n\nTest suite:\n- Test $1$ (happy path, small modulus): $(m,a,c,x_n,t) = (97, 23, 17, 42, 35)$. Ground truth: iterate the recurrence $t$ times.\n- Test $2$ (large prime modulus, affine case): $(m,a,c,x_n,t) = (2147483647, 48271, 12345, 987654321, 50000)$. Ground truth: iterate the recurrence $t$ times.\n- Test $3$ (multiplicative LCG, large $t$ still feasible): $(m,a,c,x_n,t) = (2147483647, 16807, 0, 1, 80000)$. Ground truth: iterate the recurrence $t$ times.\n- Test $4$ (boundary case $t=0$): $(m,a,c,x_n,t) = (2147483647, 1103515245, 12345, 67890, 0)$. Ground truth: $x_{n+t} = x_n$.\n- Test $5$ (boundary case $t=1$): $(m,a,c,x_n,t) = (65537, 3, 7, 1234, 1)$. Ground truth: one application of $x \\mapsto a x + c \\bmod m$.\n- Test $6$ (composition check without naive iteration): $(m,a,c,x_n,t_1,t_2) = (1000003, 123457, 891, 222, 1234, 5678)$. Verify that applying skip-ahead for $t_1$ followed by skip-ahead for $t_2$ equals skip-ahead for $t_1 + t_2$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets (for example, `[True,False,True]`), corresponding to Tests $1$ through $6$ in order.", "solution": "The problem statement has been subjected to a rigorous validation process and is determined to be valid. It is a well-posed, scientifically grounded problem in computational science with a clear, objective formulation. All necessary data and constraints are provided, and there are no internal contradictions or logical flaws.\n\n**1. Derivation of the Closed-Form Expression for $x_{n+t}$**\n\nThe Linear Congruential Generator (LCG) is defined by the recurrence relation:\n$$x_{k+1} \\equiv a x_k + c \\pmod m$$\nOur goal is to find an expression for $x_{n+t}$ in terms of $x_n$, $a$, $c$, $t$, and $m$. We can derive this by unrolling the recurrence:\n$x_{n+1} \\equiv a x_n + c \\pmod m$\n$x_{n+2} \\equiv a x_{n+1} + c \\equiv a(a x_n + c) + c \\equiv a^2 x_n + ac + c \\pmod m$\n$x_{n+3} \\equiv a x_{n+2} + c \\equiv a(a^2 x_n + ac + c) + c \\equiv a^3 x_n + a^2 c + ac + c \\pmod m$\n\nThis suggests the general form, which can be formally proven by induction on $t$:\n$$x_{n+t} \\equiv a^t x_n + c \\sum_{k=0}^{t-1} a^k \\pmod m$$\nThe sum term is a finite geometric series. For any integer $r \\ne 1$, the identity for such a series is $\\sum_{k=0}^{t-1} r^k = \\frac{r^t - 1}{r - 1}$. Applying this to our expression with $r=a$, we get:\n$$\\sum_{k=0}^{t-1} a^k = \\frac{a^t - 1}{a - 1}$$\nThis identity is valid provided $a \\ne 1$. In modular arithmetic, division by an integer $q$ is permissible if and only if $q$ is coprime to the modulus $m$. In such a case, division by $q$ is equivalent to multiplication by its modular multiplicative inverse, $q^{-1} \\pmod m$, which is an integer $q_{\\text{inv}}$ such that $q \\cdot q_{\\text{inv}} \\equiv 1 \\pmod m$.\n\nThe problem states the assumption that $\\gcd(a-1, m) = 1$. This guarantees that the modular multiplicative inverse of $(a-1)$ modulo $m$ exists and is unique. Let this inverse be denoted by $(a-1)^{-1}$. The geometric sum can thus be computed modulo $m$ as:\n$$\\sum_{k=0}^{t-1} a^k \\equiv (a^t - 1)(a-1)^{-1} \\pmod m$$\nSubstituting this back into the expression for $x_{n+t}$, we arrive at the closed-form solution:\n$$x_{n+t} \\equiv a^t x_n + c \\left( (a^t - 1)(a-1)^{-1} \\right) \\pmod m$$\nThis expression allows us to compute $x_{n+t}$ directly from $x_n$ without performing $t$ individual iterations.\n\n**2. Design of the $O(\\log t)$ Skip-Ahead Algorithm**\n\nThe closed-form expression for $x_{n+t}$ lends itself to an efficient algorithm. The computation can be broken down into steps whose complexity does not scale linearly with $t$.\n\nFirst, we handle the boundary case $t=0$. The formula correctly yields $x_{n+0} \\equiv a^0 x_n + c(a^0-1)(a-1)^{-1} \\equiv 1 \\cdot x_n + c(1-1)(a-1)^{-1} \\equiv x_n \\pmod m$. Thus, for $t=0$, the algorithm simply returns $x_n$.\n\nFor $t > 0$, the algorithm proceeds as follows:\n1.  **Compute $A \\equiv a^t \\pmod m$**: This is a modular exponentiation operation. It can be performed efficiently using the method of exponentiation by squaring (also known as binary exponentiation), which has a time complexity of $O(\\log_2 t)$.\n2.  **Compute $I \\equiv (a-1)^{-1} \\pmod m$**: This is the modular multiplicative inverse of $(a-1)$ with respect to the modulus $m$. It is computed using the Extended Euclidean Algorithm, which finds integers $i$ and $j$ such that $(a-1)i + mj = \\gcd(a-1, m)$. Since we are given $\\gcd(a-1, m) = 1$, we have $(a-1)i + mj = 1$, which implies $(a-1)i \\equiv 1 \\pmod m$. The inverse $I$ is therefore $i \\pmod m$. This computation has a time complexity of $O(\\log m)$.\n3.  **Assemble the final result**: Using the pre-computed values $A$ and $I$, we calculate $x_{n+t}$ using the derived formula. All arithmetic is performed modulo $m$:\n    - Compute the sum part: $S \\equiv c \\cdot (A - 1) \\cdot I \\pmod m$.\n    - Compute the initial state part: $X \\equiv A \\cdot x_n \\pmod m$.\n    - The final state is: $x_{n+t} \\equiv (X + S) \\pmod m$.\n    Each of these steps involves a constant number of modular multiplications and additions.\n\nThe total time complexity of this algorithm is dominated by the modular exponentiation and modular inverse steps, resulting in an overall complexity of $O(\\log t + \\log m)$. This is a significant improvement over the naive iterative approach, which has a complexity of $O(t)$.\n\n**3. Verification by Numerical Experiments**\n\nThe correctness of the skip-ahead algorithm is verified against a set of test cases.\n- For tests with computationally feasible step counts $t$ (Tests 1, 2, 3, 5), the ground truth is established by implementing a simple iterative function that applies the LCG recurrence $x_{k+1} \\equiv (ax_k + c) \\pmod m$ exactly $t$ times. The output of the skip-ahead algorithm is then compared to this ground truth.\n- For the boundary case $t=0$ (Test 4), the ground truth is axiomatically $x_n$. The algorithm's output is checked against this value.\n- For the composition check (Test 6), we verify the algebraic property of the skip-ahead operator, let's call it $S(x, k)$, which advances state $x$ by $k$ steps. The test confirms that applying two sequential skips, $S(S(x_n, t_1), t_2)$, yields the same result as a single combined skip, $S(x_n, t_1 + t_2)$. This demonstrates that the skip operation forms a valid semigroup action, which is a fundamental requirement for its correctness, independent of the ability to compute a ground truth by iteration.\n\nAll calculations are performed using pure integer arithmetic with modulo operations at each step to prevent overflow and maintain correctness, as Python's arbitrary-precision integers support the large numbers involved.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are needed for this problem.\n\ndef solve():\n    \"\"\"\n    Implements and verifies a skip-ahead operation for a linear congruential\n    generator (LCG).\n    \"\"\"\n\n    def lcg_iterate(m: int, a: int, c: int, x_n: int, t: int) -> int:\n        \"\"\"\n        Computes x_{n+t} by iterating the LCG recurrence t times.\n        Serves as the ground truth for verification.\n        \"\"\"\n        x = x_n\n        for _ in range(t):\n            x = (a * x + c) % m\n        return x\n\n    def lcg_skip_ahead(m: int, a: int, c: int, x_n: int, t: int) -> int:\n        \"\"\"\n        Computes x_{n+t} using the O(log t) closed-form formula.\n        x_{n+t} = (a^t * x_n + c * (a^t - 1) * (a - 1)^-1) mod m\n        \"\"\"\n        if t < 0:\n            raise ValueError(\"Step count t cannot be negative.\")\n        if t == 0:\n            return x_n\n\n        # The term (a-1) can be negative. The modulo operation works correctly\n        # with Python's integers.\n        a_minus_1 = a - 1\n        \n        # In Python 3.8+, pow(base, -1, mod) computes the modular\n        # multiplicative inverse using the Extended Euclidean Algorithm.\n        # The problem guarantees gcd(a-1, m) == 1.\n        a_minus_1_inv = pow(a_minus_1, -1, m)\n\n        # A = a^t mod m, calculated efficiently with modular exponentiation.\n        A = pow(a, t, m)\n\n        # Sum of geometric series part: c * (a^t - 1) * (a - 1)^-1 mod m\n        # (A - 1) might be negative, but Python's % handles this as desired\n        # for modular arithmetic (i.e., result has same sign as modulus).\n        sum_term = (A - 1) * a_minus_1_inv % m\n        \n        # Combine the terms according to the derived formula\n        term1 = (A * x_n) % m\n        term2 = (c * sum_term) % m\n        \n        result = (term1 + term2) % m\n        return result\n\n    # Test cases extracted from the problem statement\n    test_cases = [\n        # Test 1: Happy path, small modulus\n        {'m': 97, 'a': 23, 'c': 17, 'x_n': 42, 't': 35, 'type': 'iterate'},\n        # Test 2: Large prime modulus, affine case\n        {'m': 2147483647, 'a': 48271, 'c': 12345, 'x_n': 987654321, 't': 50000, 'type': 'iterate'},\n        # Test 3: Multiplicative LCG, large t still feasible\n        {'m': 2147483647, 'a': 16807, 'c': 0, 'x_n': 1, 't': 80000, 'type': 'iterate'},\n        # Test 4: Boundary case t=0\n        {'m': 2147483647, 'a': 1103515245, 'c': 12345, 'x_n': 67890, 't': 0, 'type': 'identity'},\n        # Test 5: Boundary case t=1\n        {'m': 65537, 'a': 3, 'c': 7, 'x_n': 1234, 't': 1, 'type': 'onestep'},\n        # Test 6: Composition check\n        {'m': 1000003, 'a': 123457, 'c': 891, 'x_n': 222, 't1': 1234, 't2': 5678, 'type': 'composition'}\n    ]\n\n    results = []\n    for case in test_cases:\n        m, a, c, x_n = case['m'], case['a'], case['c'], case['x_n']\n        \n        if case['type'] == 'iterate':\n            t = case['t']\n            skip_result = lcg_skip_ahead(m, a, c, x_n, t)\n            iter_result = lcg_iterate(m, a, c, x_n, t)\n            results.append(skip_result == iter_result)\n            \n        elif case['type'] == 'identity':\n            t = case['t']\n            skip_result = lcg_skip_ahead(m, a, c, x_n, t)\n            # Ground truth for t=0 is x_n\n            results.append(skip_result == x_n)\n\n        elif case['type'] == 'onestep':\n            t = case['t']\n            skip_result = lcg_skip_ahead(m, a, c, x_n, t)\n            # Ground truth for t=1 is one application of the recurrence\n            onestep_result = (a * x_n + c) % m\n            results.append(skip_result == onestep_result)\n\n        elif case['type'] == 'composition':\n            t1, t2 = case['t1'], case['t2']\n            # Verify S(S(x, t1), t2) == S(x, t1 + t2)\n            res_t1 = lcg_skip_ahead(m, a, c, x_n, t1)\n            res_t1_t2 = lcg_skip_ahead(m, a, c, res_t1, t2)\n            res_total_t = lcg_skip_ahead(m, a, c, x_n, t1 + t2)\n            results.append(res_t1_t2 == res_total_t)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3179049"}, {"introduction": "Beyond analyzing a generator's internal structure, we need robust empirical methods to assess the quality of its output. This practice introduces one of the most fundamental tools for this purpose: the Pearson chi-squared ($\\chi^2$) test for uniformity. You will implement this test from first principles, from generating the random sequence to calculating the test statistic and its corresponding $p$-value, providing a deep understanding of how statistical hypothesis testing is applied to validate a random number stream [@problem_id:3264207].", "problem": "You are asked to implement, from first principles, a Pearson chi-squared test for uniformity on the output of a custom Pseudo-Random Number Generator (PRNG). Pseudo-Random Number Generator (PRNG) refers to any deterministic algorithm that produces a sequence intended to mimic independent samples from a target distribution. In this task, the PRNG will be a Linear Congruential Generator (LCG), and the target distribution is the continuous uniform distribution on the interval $\\left[0,1\\right)$.\n\nStarting from core definitions and well-tested facts, implement the following:\n\n- Construct a Linear Congruential Generator (LCG) defined by the update rule on integer state: next state equals current state multiplied by multiplier plus increment, reduced modulo modulus. Map each integer state to a real number in $\\left[0,1\\right)$ by dividing the state by the modulus. Use integer arithmetic for the LCG state updates and produce exactly $n$ samples.\n- Partition $\\left[0,1\\right)$ into $k$ equal-width bins. Based on the samples, compute the observed bin counts. The expected bin count under exact uniformity is the total number of samples divided by the number of bins.\n- Compute the Pearson chi-squared statistic from the observed counts and the expected count. Use the correct number of degrees of freedom for the chi-squared distribution.\n- Compute the $p$-value for the upper tail of the chi-squared distribution using the regularized upper incomplete gamma function. You must implement this evaluation numerically without using black-box statistical testing functions. It is acceptable to use the natural logarithm of the gamma function to improve numerical stability.\n- Decide whether to accept uniformity by comparing the $p$-value to a given significance level $\\alpha$ as a decimal. Accept uniformity when the $p$-value is greater than or equal to $\\alpha$, otherwise reject.\n\nImplementation constraints:\n\n- The program must be a complete, runnable program that uses only the Python standard library and the specified version of the Numerical Python (NumPy) library.\n- The PRNG must be custom-built and not use any external random sources.\n- The computation of the $p$-value must be implemented via a numerically stable evaluation of the regularized upper incomplete gamma function, avoiding any external statistical libraries.\n\nTest suite:\n\nProvide results for the following parameter sets. Each set is a tuple $\\left(m,a,c,s,n,k,\\alpha\\right)$ consisting of the modulus $m$, multiplier $a$, increment $c$, seed $s$, sample size $n$, number of bins $k$, and significance level $\\alpha$.\n\n- Case $1$ (happy path, widely used parameters): $\\left(2^{31}-1,16807,0,1,100000,100,0.01\\right)$.\n- Case $2$ (degenerate generator, constant sequence): $\\left(2^{16},1,0,12345,10000,50,0.01\\right)$.\n- Case $3$ (degenerate seed for multiplicative LCG): $\\left(2^{31}-1,16807,0,0,10000,50,0.01\\right)$.\n- Case $4$ (borderline reliability: small expected count per bin): $\\left(2^{31}-1,16807,0,1,200,50,0.05\\right)$.\n- Case $5$ (very small modulus causing short cycles): $\\left(8,5,0,1,1000,10,0.01\\right)$.\n\nFinal output specification:\n\n- For each case, produce a boolean indicating whether the uniformity hypothesis is accepted at significance level $\\alpha$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, ordered by the cases above. For example: `[result1,result2,result3,result4,result5]` where each result is either `True` or `False`.", "solution": "We construct the solution by integrating definitions and properties that connect the PRNG output to a statistical decision procedure.\n\nFirst, define a Linear Congruential Generator (LCG). Given integers $m$, $a$, $c$, and an initial seed $s$, the LCG state evolves via\n$$\nX_{n+1} = \\left(a X_n + c\\right) \\bmod m,\n$$\nwith $X_0 = s$. Each state $X_n \\in \\{0,1,\\ldots,m-1\\}$ is mapped to a real sample\n$$\nU_n = \\frac{X_n}{m},\n$$\nwhich lies in $\\left[0,1\\right)$.\n\nTo assess uniformity of $\\{U_n\\}$, partition $\\left[0,1\\right)$ into $k$ disjoint intervals (bins) of equal width. Let these bins be\n$$\nB_i = \\left[\\frac{i}{k}, \\frac{i+1}{k}\\right), \\quad i = 0,1,\\ldots,k-1.\n$$\nDefine observed counts $O_i$ by counting the number of samples that fall into $B_i$. Under the exact uniform distribution, the probability of landing in any bin is $1/k$, so the expected count in each bin is\n$$\nE = \\frac{n}{k},\n$$\nwhere $n$ is the total number of samples.\n\nThe Pearson chi-squared statistic for uniformity is\n$$\n\\chi^2 = \\sum_{i=0}^{k-1} \\frac{\\left(O_i - E\\right)^2}{E}.\n$$\nThis statistic, under the null hypothesis of uniformity, is approximately distributed as a chi-squared distribution with\n$$\n\\nu = k - 1\n$$\ndegrees of freedom, provided $n$ is large enough and expected counts are not too small. The chi-squared distribution is a special case of the gamma distribution: if $X \\sim \\chi^2_\\nu$, then $X$ has the gamma distribution with shape parameter $\\nu/2$ and scale parameter $2$. Therefore, the upper-tail $p$-value for an observed value $\\chi^2$ is connected to the regularized upper incomplete gamma function. Specifically,\n$$\np = Q\\left(\\frac{\\nu}{2},\\frac{\\chi^2}{2}\\right),\n$$\nwhere $Q(a,x)$ is the regularized upper incomplete gamma function defined by\n$$\nQ(a,x) = \\frac{\\Gamma(a,x)}{\\Gamma(a)},\n$$\nand $\\Gamma(a,x)$ is the upper incomplete gamma function while $\\Gamma(a)$ is the gamma function.\n\nTo compute $Q(a,x)$ numerically without black-box functions, use two complementary expansions for numerical stability (as in standard numerical analysis references). Let $a>0$ and $x \\ge 0$. Introduce the common prefactor\n$$\n\\mathrm{pref}(a,x) = \\exp\\left(a \\ln x - x - \\ln \\Gamma(a)\\right).\n$$\nThen use:\n- A convergent series for the regularized lower incomplete gamma function $P(a,x)$ when $x < a+1$,\n$$\nP(a,x) = \\mathrm{pref}(a,x) \\sum_{n=0}^{\\infty} \\frac{x^n}{a (a+1) \\cdots (a+n)},\n$$\nimplemented via the recurrence for the series terms, and return $Q(a,x) = 1 - P(a,x)$.\n- A continued fraction for $Q(a,x)$ when $x \\ge a+1$, built on the fraction\n$$\nQ(a,x) = \\mathrm{pref}(a,x) \\cdot \\left[ \\cfrac{1}{x+1-a - \\cfrac{1 \\cdot (1-a)}{x+3-a - \\cfrac{2 \\cdot (2-a)}{x+5-a - \\cdots}}} \\right],\n$$\nwhich is evaluated via stable forward iteration of the continued fraction using standard safeguards (tiny initializations and tolerance for convergence).\n\nGiven the computed $p$-value $p$, apply the decision rule at significance level $\\alpha$:\n$$\n\\text{Accept uniformity} \\quad \\Leftrightarrow \\quad p \\ge \\alpha.\n$$\n\nAlgorithmic design:\n\n- Generate $n$ samples using integer arithmetic in the LCG. Map states to reals in $\\left[0,1\\right)$ by dividing by $m$.\n- Compute bin indices via $b(U_n) = \\min\\left(\\left\\lfloor k U_n \\right\\rfloor, k-1\\right)$ to ensure an index in $\\{0,1,\\ldots,k-1\\}$.\n- Accumulate observed counts $O_i$ via a histogram-like computation.\n- Compute $E = n/k$ and then $\\chi^2$ via the sum of squared normalized deviations.\n- Let $\\nu = k-1$, compute $a = \\nu/2$ and $x = \\chi^2/2$, evaluate $Q(a,x)$ using the split strategy above, and compare $p$ to $\\alpha$.\n\nEdge-case considerations:\n\n- Degenerate generators such as $a=1$, $c=0$ yield a constant sequence, concentrating all mass in a single bin, which produces extremely large $\\chi^2$ and $p \\approx 0$, hence rejection.\n- A multiplicative LCG with seed $s=0$ yields $U_n=0$ for all $n$, again causing rejection.\n- With small $n$ and large $k$, the expected count $E=n/k$ can be small, leading to reduced accuracy of the chi-squared approximation. The algorithm still computes a valid statistic and $p$-value, but the decision should be interpreted with caution in such regimes.\n\nThe program evaluates the five specified cases and outputs a single line consisting of five booleans enclosed in brackets with commas and no spaces, corresponding to acceptance decisions for the cases in order.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef lcg_generate(m: int, a: int, c: int, seed: int, n: int) -> np.ndarray:\n    \"\"\"\n    Generate n samples in [0,1) using a Linear Congruential Generator (LCG):\n    X_{n+1} = (a * X_n + c) mod m, with X_0 = seed.\n    Returns a NumPy array of floats in [0,1).\n    \"\"\"\n    samples = np.empty(n, dtype=np.float64)\n    state = seed % m\n    for i in range(n):\n        # Map current state to [0,1)\n        samples[i] = state / m\n        # Advance state\n        state = (a * state + c) % m\n    return samples\n\ndef chi_square_uniformity(samples: np.ndarray, k: int):\n    \"\"\"\n    Compute Pearson chi-squared statistic for uniformity over k equal bins on [0,1).\n    Returns (chi2_stat, p_value).\n    \"\"\"\n    n = samples.size\n    # Bin indices: floor(k * x), clipped to k-1 to guard against edge\n    bin_indices = np.minimum((samples * k).astype(np.int64), k - 1)\n    counts = np.bincount(bin_indices, minlength=k)\n    expected = n / k\n    # Chi-squared statistic: sum((O_i - E)^2 / E)\n    diffs = counts - expected\n    chi2 = np.sum((diffs * diffs) / expected)\n    # Degrees of freedom\n    v = k - 1\n    # Upper-tail p-value using regularized upper incomplete gamma:\n    # p = Q(v/2, chi2/2)\n    a = 0.5 * v\n    x = 0.5 * chi2\n    p = gammaincc(a, x)\n    return chi2, p\n\ndef gammaincc(a: float, x: float) -> float:\n    \"\"\"\n    Regularized upper incomplete gamma function Q(a, x) = Gamma(a, x) / Gamma(a).\n    Implements the Numerical Recipes-style algorithm with series for P(a, x) when x < a+1,\n    and continued fraction for Q(a, x) when x >= a+1.\n    \"\"\"\n    if a <= 0.0 or x < 0.0:\n        raise ValueError(\"Invalid arguments for gammaincc: require a > 0 and x >= 0.\")\n    if x == 0.0:\n        return 1.0\n    # Common prefactor: exp(a*ln(x) - x - lnGamma(a))\n    ln_gamma_a = math.lgamma(a)\n    lnpref = a * math.log(x) - x - ln_gamma_a\n    pref = math.exp(lnpref)\n    # Switch by x relative to a+1\n    if x < a + 1.0:\n        # Compute P(a, x) via series\n        return 1.0 - _gammainc_lower_reg_series(a, x, pref)\n    else:\n        # Compute Q(a, x) via continued fraction\n        return _gammainc_upper_reg_cf(a, x, pref)\n\ndef _gammainc_lower_reg_series(a: float, x: float, pref: float) -> float:\n    \"\"\"\n    Regularized lower incomplete gamma P(a, x) via series expansion.\n    Returns P(a, x).\n    \"\"\"\n    eps = 1e-14\n    max_iter = 100000\n    sum_term = 1.0 / a\n    term = sum_term\n    ap = a\n    for n in range(1, max_iter + 1):\n        ap += 1.0\n        term *= x / ap\n        sum_term += term\n        if abs(term) < abs(sum_term) * eps:\n            break\n    return pref * sum_term\n\ndef _gammainc_upper_reg_cf(a: float, x: float, pref: float) -> float:\n    \"\"\"\n    Regularized upper incomplete gamma Q(a, x) via continued fraction.\n    Returns Q(a, x).\n    \"\"\"\n    eps = 1e-14\n    max_iter = 100000\n    tiny = 1e-300\n    b = x + 1.0 - a\n    c = 1.0 / tiny\n    d = 1.0 / b\n    h = d\n    for i in range(1, max_iter + 1):\n        an = -i * (i - a)\n        b += 2.0\n        d = 1.0 / (an * d + b)\n        c = b + an / c\n        if c == 0.0:\n            c = tiny\n        del_cf = d * c\n        h *= del_cf\n        if abs(del_cf - 1.0) < eps:\n            break\n    return pref * h\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (m, a, c, seed, n, k, alpha)\n    test_cases = [\n        (2**31 - 1, 16807, 0, 1, 100000, 100, 0.01),   # Case 1: Park-Miller minimal standard\n        (2**16, 1, 0, 12345, 10000, 50, 0.01),         # Case 2: Degenerate generator (constant)\n        (2**31 - 1, 16807, 0, 0, 10000, 50, 0.01),     # Case 3: Seed zero degeneracy\n        (2**31 - 1, 16807, 0, 1, 200, 50, 0.05),       # Case 4: Borderline small expected count\n        (8, 5, 0, 1, 1000, 10, 0.01),                  # Case 5: Very small modulus, short cycle\n    ]\n\n    results = []\n    for case in test_cases:\n        m, a, c, seed, n, k, alpha = case\n        samples = lcg_generate(m, a, c, seed, n)\n        chi2, pval = chi_square_uniformity(samples, k)\n        accept = pval >= alpha\n        results.append(accept)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3264207"}]}