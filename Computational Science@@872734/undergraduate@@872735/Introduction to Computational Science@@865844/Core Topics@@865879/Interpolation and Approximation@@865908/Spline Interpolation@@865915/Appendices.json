{"hands_on_practices": [{"introduction": "The defining feature of a cubic spline is its smoothness, which is achieved by controlling its curvature at the data points, or \"knots\". This curvature is mathematically represented by the second derivative, $S''(x)$. This exercise provides a foundational look into the core calculation of spline interpolation: determining these second derivative values by setting up and solving a system of linear equations derived from continuity conditions. By working through a simple case with three points, you will solve for the curvature at the single interior knot, revealing the fundamental mechanics of the process [@problem_id:2164958].", "problem": "A function $S(x)$ is a natural cubic spline that interpolates a set of data points. By definition, a cubic spline is a piecewise function composed of cubic polynomials, and it is continuous along with its first and second derivatives. A \"natural\" cubic spline has the additional property that its second derivative is zero at the two endpoints of the interval of interpolation.\n\nConsider a natural cubic spline $S(x)$ that passes through the following three data points: $(x_0, y_0) = (0, 0)$, $(x_1, y_1) = (1, 1)$, and $(x_2, y_2) = (2, 0)$.\n\nCalculate the value of the second derivative of the spline at $x=1$, which is denoted by $S''(1)$.", "solution": "Let $x_{0}=0$, $x_{1}=1$, $x_{2}=2$ with $y_{0}=0$, $y_{1}=1$, $y_{2}=0$. For a natural cubic spline, the second derivatives at the knots $M_{i}=S''(x_{i})$ satisfy $M_{0}=0$ and $M_{2}=0$, and the interior equations are\n$$\nh_{i-1}M_{i-1}+2(h_{i-1}+h_{i})M_{i}+h_{i}M_{i+1}\n=6\\left(\\frac{y_{i+1}-y_{i}}{h_{i}}-\\frac{y_{i}-y_{i-1}}{h_{i-1}}\\right),\n$$\nfor $i=1,\\ldots,n-1$, where $h_{i}=x_{i+1}-x_{i}$. Here $h_{0}=x_{1}-x_{0}=1$ and $h_{1}=x_{2}-x_{1}=1$, and there is a single interior equation at $i=1$:\n$$\n1\\cdot M_{0}+2(1+1)M_{1}+1\\cdot M_{2}\n=6\\left(\\frac{y_{2}-y_{1}}{1}-\\frac{y_{1}-y_{0}}{1}\\right).\n$$\nSubstituting $M_{0}=0$, $M_{2}=0$, $y_{2}-y_{1}=0-1=-1$, and $y_{1}-y_{0}=1-0=1$ gives\n$$\n4M_{1}=6(-1-1)=6(-2)=-12,\n$$\nhence\n$$\nM_{1}=-3.\n$$\nTherefore $S''(1)=M_{1}=-3$.", "answer": "$$\\boxed{-3}$$", "id": "2164958"}, {"introduction": "Moving from the core calculation to a complete implementation is a key step in mastering any numerical method. This practice challenges you to build a natural cubic spline interpolator from the ground up. You will translate the theory into practice by constructing the tridiagonal system for the second derivatives and solving it efficiently using the Thomas algorithm, a specialized method for such systems. Completing this exercise [@problem_id:2384309] will give you a robust, hands-on understanding of the entire workflow, from raw data points to a fully functional interpolator.", "problem": "You are given one-dimensional data sampled at strictly increasing nodes. For a set of nodes $x_0 < x_1 < \\dots < x_n$ with corresponding values $y_0, y_1, \\dots, y_n$, consider the unique natural cubic spline $S(x)$ defined by the following properties: on each interval $[x_i, x_{i+1}]$ the function $S(x)$ is a cubic polynomial; the function $S(x)$ satisfies the interpolation conditions $S(x_i) = y_i$ for all $i$ with $0 \\le i \\le n$; the first derivative $S'(x)$ is continuous on $[x_0, x_n]$; the second derivative $S''(x)$ is continuous on $[x_0, x_n]$; and the natural boundary conditions $S''(x_0) = 0$ and $S''(x_n) = 0$ hold. Your task is to write a complete program that, for each test case below, constructs the unique natural cubic spline $S(x)$ for the provided data set and evaluates $S(x)$ at a specified query point $x_q$.\n\nAll inputs in the test suite are explicitly given below. Each test case is independent. In each case, use the provided arrays $x$ and $y$ as the exact data to construct $S(x)$, and then compute the scalar value $S(x_q)$. No external data sources are permitted or needed. All computations are purely numerical and dimensionless; no physical units apply.\n\nTest Suite (each item is a triple $(x, y, x_q)$ to be processed independently, in the given order):\n- Test case $1$: $x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$, $y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$, $x_q = 1.3$.\n- Test case $2$: $x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$, $y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$, $x_q = 0.0$.\n- Test case $3$: $x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$, $y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$, $x_q = 3.0$.\n- Test case $4$: $x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$, $y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$, $x_q = 2.2$.\n- Test case $5$: $x = [\\,-1.0,\\,2.0\\,]$, $y = [\\,-1.0,\\,4.0\\,]$, $x_q = 0.5$.\n\nYour program must compute $S(x_q)$ for each of the above $5$ cases, in order, and produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each number in the output list must be a floating-point value rounded to exactly $8$ decimal places. For example, the required output format is $[r_1,r_2,r_3,r_4,r_5]$ where each $r_i$ is $S(x_q)$ rounded to $8$ decimal places for test case $i$.", "solution": "The goal is to construct the unique natural cubic spline $S(x)$ from the given data $(x_i, y_i)$ with $0 \\le i \\le n$, where $x_0 < x_1 < \\dots < x_n$. By definition, $S(x)$ is piecewise cubic on each interval $[x_i, x_{i+1}]$, interpolates the data $S(x_i) = y_i$, and has continuous first and second derivatives on $[x_0, x_n]$, with the natural boundary conditions $S''(x_0) = 0$ and $S''(x_n) = 0$.\n\nA standard construction proceeds by introducing the unknown vector of second derivatives at the knots, denoted by $M_i = S''(x_i)$ for $0 \\le i \\le n$. The step sizes are $h_i = x_{i+1} - x_i$ for $0 \\le i \\le n-1$. For interior indices $i$ with $1 \\le i \\le n-1$, continuity of $S'(x)$ and $S''(x)$ across the knots leads to a linear system for the interior second derivatives $M_1, M_2, \\dots, M_{n-1}$:\n$$\nh_{i-1} M_{i-1} + 2(h_{i-1} + h_{i}) M_i + h_i M_{i+1} = 6\\left( \\frac{y_{i+1} - y_i}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}} \\right),\n$$\nwith the natural boundary conditions $M_0 = 0$ and $M_n = 0$. For $n = 1$ (i.e., two nodes), there are no interior unknowns and the natural cubic spline reduces exactly to linear interpolation between the two points, which is consistent with $M_0 = 0$ and $M_1 = 0$.\n\nThe coefficient matrix of the system for $(M_1, \\dots, M_{n-1})$ is tridiagonal, with the following entries for $1 \\le i \\le n-1$:\n- Main diagonal: $b_i = 2(h_{i-1} + h_i)$.\n- Subdiagonal: $a_i = h_{i-1}$ for $i \\ge 2$.\n- Superdiagonal: $c_i = h_i$ for $i \\le n-2$.\nThe right-hand side is $d_i = 6\\left( \\frac{y_{i+1} - y_i}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}} \\right)$.\n\nThis linear system is strictly diagonally dominant for strictly increasing $x_i$ with $h_i > 0$, ensuring a unique solution. An efficient and exact method to solve a tridiagonal linear system in $\\mathcal{O}(n)$ time consists of a forward elimination phase that eliminates subdiagonal entries followed by a backward substitution phase to recover the unknowns. Specifically, let the system be expressed in compact notation as\n$$\na_i M_{i-1} + b_i M_i + c_i M_{i+1} = d_i, \\quad \\text{for } i = 1, 2, \\dots, n-1,\n$$\nwith the conventions that $a_1 = 0$ and $c_{n-1} = 0$. The forward elimination step constructs modified diagonals and right-hand side:\nfor $i = 2, 3, \\dots, n-1$,\n$$\nw = \\frac{a_i}{b_{i-1}}, \\quad\nb_i \\leftarrow b_i - w c_{i-1}, \\quad\nd_i \\leftarrow d_i - w d_{i-1}.\n$$\nThe backward substitution then computes\n$$\nM_{n-1} = \\frac{d_{n-1}}{b_{n-1}}, \\quad\nM_i = \\frac{d_i - c_i M_{i+1}}{b_i} \\quad \\text{for } i = n-2, n-3, \\dots, 1.\n$$\nFinally, set $M_0 = 0$ and $M_n = 0$ to obtain the full vector $(M_0, M_1, \\dots, M_n)$.\n\nWith the second derivatives known, the spline on interval $[x_i, x_{i+1}]$ can be evaluated for any $x \\in [x_i, x_{i+1}]$ using the Hermite-like representation\n$$\nS(x) = A y_i + B y_{i+1} + \\frac{h_i^2}{6} \\left[ (A^3 - A) M_i + (B^3 - B) M_{i+1} \\right],\n$$\nwhere $h_i = x_{i+1} - x_i$, $A = \\frac{x_{i+1} - x}{h_i}$, and $B = \\frac{x - x_i}{h_i}$. This representation satisfies $S(x_i) = y_i$, $S(x_{i+1}) = y_{i+1}$, and the continuity conditions by construction. If $n = 1$, then $M_i = 0$ for all indices and the formula reduces to the linear interpolation $S(x) = A y_0 + B y_1$.\n\nTo evaluate $S(x_q)$, determine the interval $[x_i, x_{i+1}]$ such that $x_q \\in [x_i, x_{i+1}]$. If $x_q = x_n$, select the final interval $[x_{n-1}, x_n]$. Compute $A$, $B$, and then $S(x_q)$ via the above formula. Repeating this for each test case produces the required scalar outputs. Each result is finally rounded to exactly $8$ decimal places and emitted in a single bracketed, comma-separated list in the specified order.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef natural_cubic_spline_second_derivatives(x, y):\n    \"\"\"\n    Compute second derivatives M at knots for the natural cubic spline.\n    x: list or array of strictly increasing floats\n    y: list or array of floats of same length as x\n    Returns: list of M values (second derivatives) at each knot.\n    \"\"\"\n    n = len(x) - 1  # number of intervals\n    if n < 1:\n        raise ValueError(\"At least two data points are required.\")\n    if n == 1:\n        # Two nodes: linear interpolation, M = 0 at both ends.\n        return [0.0, 0.0]\n\n    h = [x[i+1] - x[i] for i in range(n)]\n    # Build tridiagonal system for M[1..n-1]\n    m = n - 1  # number of interior unknowns\n    a = [0.0] * m  # sub-diagonal (a[0] unused or zero)\n    b = [0.0] * m  # main diagonal\n    c = [0.0] * m  # super-diagonal (c[m-1] unused or zero)\n    d = [0.0] * m  # right-hand side\n\n    for i in range(m):\n        hi_prev = h[i] if i >= 0 else None\n        hi = h[i+1] if (i + 1) < n else None\n        # Using indices: interior i corresponds to global index i+1\n        if i == 0:\n            a[i] = 0.0\n        else:\n            a[i] = h[i]\n        if i == m - 1:\n            c[i] = 0.0\n        else:\n            c[i] = h[i+1]\n        b[i] = 2.0 * (h[i] + h[i+1])\n\n        # Right-hand side\n        yi_minus = y[i]\n        yi = y[i+1]\n        yi_plus = y[i+2]\n        d[i] = 6.0 * ((yi_plus - yi) / h[i+1] - (yi - yi_minus) / h[i])\n\n    # Thomas algorithm: forward elimination\n    for i in range(1, m):\n        if b[i-1] == 0.0:\n            raise ZeroDivisionError(\"Singular tridiagonal system encountered.\")\n        w = a[i] / b[i-1]\n        b[i] -= w * c[i-1]\n        d[i] -= w * d[i-1]\n\n    # Back substitution\n    M_interior = [0.0] * m\n    M_interior[-1] = d[-1] / b[-1]\n    for i in range(m - 2, -1, -1):\n        M_interior[i] = (d[i] - c[i] * M_interior[i + 1]) / b[i]\n\n    # Assemble full M with natural boundary conditions\n    M = [0.0] + M_interior + [0.0]\n    return M\n\ndef evaluate_natural_cubic_spline(x, y, M, xq):\n    \"\"\"\n    Evaluate the natural cubic spline defined by (x, y, M) at xq.\n    x: list of knots (strictly increasing)\n    y: list of values\n    M: list of second derivatives at knots\n    xq: query point within [x[0], x[-1]]\n    \"\"\"\n    n = len(x) - 1\n    if xq <= x[0]:\n        i = 0\n    elif xq >= x[-1]:\n        i = n - 1\n    else:\n        # Find right interval i such that x[i] <= xq <= x[i+1]\n        # Using binary search\n        left, right = 0, n\n        while left <= right:\n            mid = (left + right) // 2\n            if x[mid] <= xq:\n                left = mid + 1\n            else:\n                right = mid - 1\n        i = max(0, min(right, n - 1))\n\n    h = x[i+1] - x[i]\n    if h == 0.0:\n        raise ZeroDivisionError(\"Zero interval width encountered.\")\n    A = (x[i+1] - xq) / h\n    B = (xq - x[i]) / h\n    # S(x) formula using second derivatives M\n    term = ((A**3 - A) * M[i] + (B**3 - B) * M[i+1]) * (h**2) / 6.0\n    Sx = A * y[i] + B * y[i+1] + term\n    return Sx\n\ndef solve():\n    # Define the test cases from the problem statement.\n    xA = [0.0, 0.5, 1.7, 2.2, 3.0]\n    yA = [0.0, 0.5, 1.8, 2.1, 1.2]\n    test_cases = [\n        (xA, yA, 1.3),\n        (xA, yA, 0.0),\n        (xA, yA, 3.0),\n        (xA, yA, 2.2),\n        ([-1.0, 2.0], [-1.0, 4.0], 0.5),\n    ]\n\n    results = []\n    for x, y, xq in test_cases:\n        # Compute second derivatives for the dataset\n        M = natural_cubic_spline_second_derivatives(x, y)\n        # Evaluate spline at query point\n        val = evaluate_natural_cubic_spline(x, y, M, xq)\n        results.append(val)\n\n    # Final print statement in the exact required format: 8 decimal places, no spaces\n    formatted = \"[\" + \",\".join(f\"{r:.8f}\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2384309"}, {"introduction": "A powerful tool is only useful if you also understand its limitations. While splines excel at interpolating smooth data, they can produce unexpected artifacts, like \"ringing\" or overshooting, when trying to fit data with sharp jumps or discontinuities. This computational exercise [@problem_id:2384322] allows you to investigate this Gibbs-like phenomenon by interpolating a step function. By measuring the ringing amplitude under different conditions, you will gain critical insight into the practical behavior of splines and learn to identify situations where they might not be the ideal choice.", "problem": "Consider the function $f:[-1,1]\\to\\mathbb{R}$ with a single jump discontinuity at $x=0$, defined by\n$$\nf(x)=\\begin{cases}\n0, & \\text{if } x < 0 \\\\\n\\frac{1}{2}, & \\text{if } x = 0 \\\\\n1, & \\text{if } x > 0\n\\end{cases}\n$$\nFor a given integer $M\\geq 3$, let $\\{x_i\\}_{i=0}^{M-1}$ be $M$ equally spaced nodes on $[-1,1]$, with $x_0=-1$, $x_{M-1}=1$, and $x_{i+1}-x_i=\\dfrac{2}{M-1}$ for all $i\\in\\{0,\\dots,M-2\\}$. Let $y_i=f(x_i)$ for each $i$. Define a twice continuously differentiable cubic spline $s(x)$ that interpolates the data $\\{(x_i,y_i)\\}_{i=0}^{M-1}$ and satisfies one of the following boundary conditions:\n- Natural boundary condition: $s''(-1)=0$ and $s''(1)=0$.\n- Clamped boundary condition: $s'(-1)=0$ and $s'(1)=0$.\n- Not-a-knot boundary condition: the third derivative of $s$ is continuous at $x_1$ and $x_{M-2}$.\n\nDefine the ringing amplitude $R$ of the interpolant $s(x)$ on the closed interval $[-1,1]$ as\n$$\nR=\\max\\Big\\{\\sup_{x\\in[-1,1]}\\big(s(x)-1\\big),\\; \\sup_{x\\in[-1,1]}\\big(-s(x)\\big),\\; 0\\Big\\}\n$$\nThis quantity $R$ is the smallest nonnegative real number such that $s(x)\\in[-R,\\,1+R]$ for all $x\\in[-1,1]$.\n\nYour task is to compute $R$ for each of the following test cases. In every case, the domain is $[-1,1]$, the function is the $f$ defined above, and the nodes are equally spaced as specified.\n\nTest Suite:\n1. Case A (happy path, aligned jump): $M=11$ with natural boundary condition.\n2. Case B (misaligned jump): $M=12$ with natural boundary condition.\n3. Case C (boundary-condition variation): $M=11$ with clamped boundary condition.\n4. Case D (boundary-condition variation): $M=11$ with not-a-knot boundary condition.\n5. Case E (coarse discretization): $M=5$ with natural boundary condition.\n\nFor each case, compute the ringing amplitude $R$ as a real number. Your program must produce a single line of output containing the results for Cases A through E, in that order, as a comma-separated list of decimal numbers rounded to six digits after the decimal point, enclosed in square brackets. For example, an output line should have the form\n\"[r_A,r_B,r_C,r_D,r_E]\"\nwith each $r_\\cdot$ being the rounded value of $R$ for the corresponding case, expressed as a real number (no scientific notation).", "solution": "The problem requires the computation of the ringing amplitude, denoted by $R$, for a cubic spline interpolant $s(x)$ of a discontinuous step function $f(x)$ on the interval $[-1, 1]$. The function is defined as\n$$\nf(x)=\\begin{cases}\n0, & \\text{if } x < 0 \\\\\n\\frac{1}{2}, & \\text{if } x = 0 \\\\\n1, & \\text{if } x > 0\n\\end{cases}\n$$\nThe interpolation is performed on a set of $M$ equispaced nodes $\\{x_i\\}_{i=0}^{M-1}$ where $x_0 = -1$ and $x_{M-1} = 1$. The ringing amplitude $R$ measures the maximum deviation of the smooth interpolant $s(x)$ outside the range $[0, 1]$ of the function's plateaus. The definition is given as:\n$$\nR=\\max\\Big\\{\\sup_{x\\in[-1,1]}\\big(s(x)-1\\big),\\; \\sup_{x\\in[-1,1]}\\big(-s(x)\\big),\\; 0\\Big\\}\n$$\nThis problem represents a standard computational exercise in demonstrating the Gibbs phenomenon, which manifests as overshoots and undershoots when a smooth function attempts to approximate a sharp discontinuity.\n\nThe solution for each specified test case follows a systematic, three-step computational procedure.\n\n**Step 1: Data Generation**\nFor a given integer $M \\geq 3$, a set of $M$ equally spaced nodes, $\\{x_i\\}_{i=0}^{M-1}$, is generated on the interval $[-1, 1]$. The position of each node is calculated by the formula $x_i = -1 + i \\cdot \\frac{2}{M-1}$ for $i \\in \\{0, \\dots, M-1\\}$. The corresponding data values $\\{y_i\\}$ are then obtained by sampling the function $f(x)$ at these nodes, such that $y_i = f(x_i)$. Note that if $M$ is odd, the node grid is symmetric and includes $x=0$. If $M$ is even, the grid is asymmetric and the discontinuity at $x=0$ lies between two adjacent nodes.\n\n**Step 2: Cubic Spline Construction**\nA cubic spline interpolant, $s(x)$, is constructed for the data points $\\{(x_i, y_i)\\}_{i=0}^{M-1}$. A spline is a piecewise function consisting of cubic polynomials, one for each subinterval $[x_i, x_{i+1}]$. These polynomial segments are joined in such a way that the resulting function $s(x)$ is twice continuously differentiable (of class $C^2$) over the entire domain $[-1, 1]$.\n\nTo uniquely determine the coefficients of the spline's $M-1$ polynomial pieces, a system of linear equations must be solved. This system is derived from several conditions:\n- Interpolation: $s(x_i) = y_i$ for all $i \\in \\{0, \\dots, M-1\\}$. This provides $M$ constraints.\n- Continuity: At each of the $M-2$ interior nodes, the first and second derivatives of the adjacent polynomial pieces must be equal. This provides $2(M-2)$ constraints.\n\nThese conditions sum to $M + 2(M-2) = 3M - 4$ constraints for the $4(M-1)$ unknown polynomial coefficients. The remaining $2$ degrees of freedom are fixed by imposing two additional boundary conditions at the endpoints $x_0=-1$ and $x_{M-1}=1$. The problem specifies three types of boundary conditions:\n1.  **Natural**: The second derivatives at the boundaries are zero: $s''(-1) = 0$ and $s''(1) = 0$.\n2.  **Clamped**: The first derivatives at the boundaries are zero: $s'(-1) = 0$ and $s'(1) = 0$. This condition is motivated by the fact that the function $f(x)$ is flat far from the discontinuity.\n3.  **Not-a-knot**: The third derivative, $s'''(x)$, is forced to be continuous across the first and last interior nodes ($x_1$ and $x_{M-2}$, respectively).\n\nThis entire construction process is efficiently handled by the `scipy.interpolate.CubicSpline` function, which supports all the required boundary conditions.\n\n**Step 3: Ringing Amplitude Calculation**\nThe calculation of the ringing amplitude $R$ requires finding the global supremum and infimum of the spline $s(x)$ on the closed interval $[-1, 1]$. The extrema of a piecewise polynomial can occur at the nodes $x_i$ or at critical points within the open subintervals $(x_i, x_{i+1})$, where the derivative $s'(x)$ vanishes. A robust numerical method to determine these extrema is to evaluate the spline on a very fine grid of points and find the maximum and minimum of the resulting values. For this purpose, a dense grid of $40001$ points is established over $[-1, 1]$. The spline $s(x)$ is evaluated at each of these points to yield a set of values $\\{y_{fine}\\}$. The supremum and infimum are then approximated by $\\sup s(x) \\approx \\max\\{y_{fine}\\}$ and $\\inf s(x) \\approx \\min\\{y_{fine}\\}$. Finally, the ringing amplitude is computed using the given formula: $R = \\max(\\sup s(x) - 1, -\\inf s(x), 0)$.\n\nThe test suite is structured to analyze the impact of different parameters on the ringing phenomenon:\n- **Cases A ($M=11$) vs. E ($M=5$)**: Compare the effect of discretization density when the jump discontinuity is aligned with a node.\n- **Cases A ($M=11$) vs. B ($M=12$)**: Contrast the behavior for aligned versus misaligned node placement relative to the discontinuity.\n- **Cases A, C, and D ($M=11$)**: Investigate the influence of natural, clamped, and not-a-knot boundary conditions on the same grid.\n\nThe provided Python code implements this methodology for each of the five test cases and formats the results as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Computes the ringing amplitude for cubic spline interpolation of a step function\n    for a suite of test cases.\n    \"\"\"\n\n    def compute_R(M: int, bc_type: str) -> float:\n        \"\"\"\n        Computes the ringing amplitude R for a given M and boundary condition.\n\n        Args:\n            M: The number of equally spaced nodes.\n            bc_type: The boundary condition type for the spline.\n                     Can be 'natural', 'clamped', or 'not-a-knot'.\n\n        Returns:\n            The ringing amplitude R.\n        \"\"\"\n        # Step 1: Generate nodes and data points\n        x_nodes = np.linspace(-1.0, 1.0, M)\n        \n        # Define the function f(x)\n        y_nodes = np.zeros_like(x_nodes)\n        y_nodes[x_nodes > 0] = 1.0\n        # The problem statement defines f(0) = 1/2. This is only relevant if 0 is a node.\n        # This occurs when M is odd.\n        if M % 2 != 0:\n            # np.isclose is more robust for float comparisons\n            y_nodes[np.isclose(x_nodes, 0.0)] = 0.5\n            \n        # Step 2: Construct the cubic spline interpolant\n        # For clamped, scipy's default is zero-derivative, which matches the problem.\n        cs = CubicSpline(x_nodes, y_nodes, bc_type=bc_type, extrapolate=False)\n        \n        # Step 3: Calculate the ringing amplitude R\n        # To find sup(s(x)) and inf(s(x)), we evaluate the spline on a very fine grid.\n        # A grid of 40001 points ensures high accuracy for the extrema.\n        x_fine = np.linspace(-1.0, 1.0, 40001)\n        y_fine = cs(x_fine)\n        \n        s_max = np.max(y_fine)\n        s_min = np.min(y_fine)\n        \n        # R is the smallest non-negative number such that s(x) is in [-R, 1+R].\n        # This is equivalent to R = max(sup(s(x))-1, -inf(s(x)), 0).\n        R = max(s_max - 1.0, -s_min, 0.0)\n        \n        return R\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'M': 11, 'bc_type': 'natural'},      # Case A\n        {'M': 12, 'bc_type': 'natural'},      # Case B\n        {'M': 11, 'bc_type': 'clamped'},      # Case C\n        {'M': 11, 'bc_type': 'not-a-knot'},  # Case D\n        {'M': 5,  'bc_type': 'natural'},      # Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        R_val = compute_R(case['M'], case['bc_type'])\n        # Format the result to six decimal places, as a string.\n        results.append(f\"{R_val:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2384322"}]}