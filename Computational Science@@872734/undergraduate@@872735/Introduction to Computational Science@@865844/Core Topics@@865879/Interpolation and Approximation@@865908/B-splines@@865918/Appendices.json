{"hands_on_practices": [{"introduction": "Transitioning from mathematical theory to practical implementation is a crucial step in mastering any computational tool. This first exercise guides you through building a B-spline curve evaluator from the ground up, based on the fundamental Cox-de Boor recursive formula. By implementing this algorithm and testing it with clamped knot vectors, you will gain hands-on experience and verify one of the most useful properties of B-splines: their ability to interpolate the first and last control points [@problem_id:3207506].", "problem": "You are asked to write a complete, runnable program that constructs and evaluates a Basis spline (B-spline) curve in a way that is guaranteed to interpolate its first and last control points. Your design must begin from the core recursive definition of B-spline basis functions and proceed to an algorithmic implementation that respects numerical stability and correctness.\n\nStart from the following fundamental base: the Cox–de Boor recursive definition of B-spline basis functions. For a given nondecreasing knot vector $\\{t_0, t_1, \\dots, t_m\\}$ and degree $p \\ge 0$, the basis functions $N_{i,p}(u)$ are defined recursively by\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1, & t_i \\le u < t_{i+1} \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\nand for $p \\ge 1$,\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u),\n$$\nwith the convention that terms with zero denominators are treated as zero. The parametric curve is then given by\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i,\n$$\nwhere $\\{\\mathbf{P}_0,\\dots,\\mathbf{P}_n\\}$ are the control points. When the knot vector is clamped (also called open), meaning the first and last knots are each repeated $p+1$ times, the curve is guaranteed to interpolate the first and last control points at the ends of the parametric domain. Your task is to implement an evaluation algorithm that uses these definitions and to demonstrate, through a test suite, that your curve passes exactly through its first and last control points.\n\nRequirements:\n- Implement B-spline curve evaluation based on the above recursive basis definition, using a numerically stable approach appropriate for advanced undergraduate numerical methods. You must ensure endpoint interpolation by using clamped knot vectors with multiplicity $p+1$ at both ends.\n- The domain of evaluation must be $[t_p, t_{m-p}]$. At $u = t_p$ and $u = t_{m-p}$, the curve must return $\\mathbf{P}_0$ and $\\mathbf{P}_n$, respectively.\n- Use Euclidean distance to compare vector equality up to a tolerance of $10^{-9}$, with zero relative tolerance. If the norm difference is less than or equal to $10^{-9}$, treat the values as equal.\n\nTest suite and parameters:\nFor each test case below, evaluate the curve at the left endpoint $u = t_p$ and the right endpoint $u = t_{m-p}$, and check whether these points match the first and last control points within the tolerance. Your program should produce one boolean per test case indicating whether both endpoint checks passed.\n\nLet each control point $\\mathbf{P}_i$ be a coordinate vector in either two dimensions or three dimensions as specified. The knot vectors are either explicitly given or must be constructed as clamped open-uniform knot vectors. An open-uniform clamped knot vector of length $m+1 = n + p + 2$ has the first $p+1$ entries equal to $0$, the last $p+1$ entries equal to $1$, and the interior knots evenly spaced in $(0,1)$.\n\n- Test case 1 (happy path, two dimensions, quadratic clamped open-uniform):\n  - Degree $p = 2$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_4$: $\\{(0,0),(1,2),(2,0.5),(3,3),(4,0)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=4$, $p=2$.\n- Test case 2 (boundary case with minimal interior knots, cubic clamped open-uniform, Bezier-like):\n  - Degree $p = 3$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_3$: $\\{(0,0),(1,2),(3,2),(4,0)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=3$, $p=3$.\n- Test case 3 (non-uniform clamped, two dimensions):\n  - Degree $p = 3$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_6$: $\\{(0,0),(1,1),(2,-1),(3,2),(4,-0.5),(5,1.5),(6,0)\\}$.\n  - Explicit clamped non-uniform knot vector: $\\{0,0,0,0,0.15,0.6,0.85,1,1,1,1\\}$.\n- Test case 4 (edge case, linear clamped open-uniform):\n  - Degree $p = 1$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_2$: $\\{(0,1),(1,0),(2,1.5)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=2$, $p=1$.\n- Test case 5 (three dimensions, cubic clamped open-uniform):\n  - Degree $p = 3$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_5$: $\\{(0,0,0),(1,2,1),(2,-1,2),(3,3,2),(4,0,1),(5,1,0)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=5$, $p=3$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, `[true,false,true]`. Use lowercase Python boolean formatting. The list must contain one boolean per test case, in the order listed above.", "solution": "The problem requires the implementation and verification of B-spline curve evaluation, demonstrating the endpoint interpolation property for clamped knot vectors. The solution is derived directly from the fundamental recursive definition of B-spline basis functions provided in the problem statement.\n\nA B-spline curve $\\mathbf{C}(u)$ of degree $p$ is a parametric curve defined as a weighted sum of $n+1$ control points $\\{\\mathbf{P}_0, \\dots, \\mathbf{P}_n\\}$:\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i\n$$\nThe weights are the B-spline basis functions $N_{i,p}(u)$, which are piecewise polynomials of degree $p$. Their definition depends on a non-decreasing sequence of real numbers $T = \\{t_0, t_1, \\dots, t_m\\}$ called the knot vector, where the relation $m = n+p+1$ must hold. The basis functions are defined by the Cox–de Boor recursion formula.\n\nFor $p=0$:\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1, & \\text{if } t_i \\le u < t_{i+1} \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\nThis definition implies that for any interval of zero length, where $t_i = t_{i+1}$, the basis function $N_{i,0}(u)$ is always $0$. A special consideration is required for the parameter value $u$ at the very end of the domain. If the curve domain is $[t_p, t_{n+1}]$, then for $u = t_{n+1}$, the relevant non-zero degree-$0$ basis function is taken to be $N_{n,0}(t_{n+1})=1$.\n\nFor $p \\ge 1$:\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u)\n$$\nThe problem specifies that if a denominator in this expression is zero, the corresponding term is treated as zero.\n\nThe core of the task is to implement an algorithm for $\\mathbf{C}(u)$ based on these definitions and verify that for a clamped knot vector, $\\mathbf{C}(t_p) = \\mathbf{P}_0$ and $\\mathbf{C}(t_{n+1}) = \\mathbf{P}_n$. A clamped knot vector has its first $p+1$ knots equal and its last $p+1$ knots equal. This structure ensures that $N_{0,p}(t_p)=1$ and $N_{n,p}(t_{n+1})=1$, while all other basis functions $N_{i,p}$ are zero at the respective endpoints, leading to interpolation.\n\nThe overall algorithm proceeds as follows for each test case:\n1.  **Parameter Setup**: The degree $p$ and the set of $n+1$ control points $\\{\\mathbf{P}_i\\}$ are defined.\n2.  **Knot Vector Construction**: The knot vector $T$ is constructed. For cases requiring a clamped open-uniform knot vector, the first $p+1$ knots are set to $0$, the last $p+1$ knots are set to $1$, and the $n-p$ interior knots are spaced uniformly in the interval $(0,1)$. The number of knots is $m+1 = n+p+2$.\n3.  **Curve Evaluation at Endpoints**:\n    *   The curve is evaluated at the left endpoint of its domain, $u_{left} = t_p$.\n    *   The curve is evaluated at the right endpoint of its domain, $u_{right} = t_{n+1}$.\n    *   The evaluation itself, $\\mathbf{C}(u)$, is performed by a function that calculates $\\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i$.\n4.  **Basis Function Calculation**: The value of each basis function $N_{i,p}(u)$ is calculated using a recursive function that directly implements the Cox-de Boor formula. To ensure computational feasibility, this recursive function is memoized (a form of dynamic programming), preventing redundant calculations of the same basis function values. The implementation of the base case $N_{i,0}(u)$ must carefully handle the half-open interval and the special case at the domain's right endpoint.\n5.  **Verification**: The computed point $\\mathbf{C}(u_{left})$ is compared to the first control point $\\mathbf{P}_0$, and $\\mathbf{C}(u_{right})$ is compared to the last control point $\\mathbf{P}_n$. The comparison is done by calculating the Euclidean distance between the vectors. If the distance is within the specified tolerance of $10^{-9}$ for both endpoints, the test case is considered passed.\n\nThe implementation encapsulates these steps. A main function iterates through the test suite, calling helper functions to construct knot vectors and evaluate the B-spline curve. The evaluation function `b_spline_eval` uses a nested helper function `_basis_function` to compute the basis functions recursively. This nested structure allows the recursive function to be clean while having access to the parameter $u$, the knot vector $T$, and the memoization dictionary, avoiding the use of global state. The result of each test case (a boolean value) is collected and printed in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_clamped_uniform_knot_vector(n, p):\n    \"\"\"\n    Constructs a clamped open-uniform knot vector.\n    The domain for the interior knots is (0, 1).\n    \n    Args:\n        n (int): The number of control points minus 1.\n        p (int): The degree of the B-spline.\n        \n    Returns:\n        np.ndarray: The knot vector of length n + p + 2.\n    \"\"\"\n    num_knots = n + p + 2\n    T = np.zeros(num_knots, dtype=float)\n    \n    num_interior_knots = n - p\n    if num_interior_knots > 0:\n      denominator = float(n - p + 1)\n      T[p + 1 : n + 1] = np.arange(1, num_interior_knots + 1) / denominator\n    \n    T[n + 1:] = 1.0\n    return T\n\ndef b_spline_eval(u, p, control_points, T):\n    \"\"\"\n    Evaluates the B-spline curve at a parameter value u using the recursive\n    Cox-de Boor basis function definition with memoization.\n    \n    Args:\n        u (float): The parameter value.\n        p (int): The degree of the B-spline.\n        control_points (np.ndarray): Array of control points.\n        T (np.ndarray): The knot vector.\n        \n    Returns:\n        np.ndarray: The computed point on the curve.\n    \"\"\"\n    n = len(control_points) - 1\n    memo = {}\n\n    def _basis_function(i, deg):\n        \"\"\"\n        Computes the value of the B-spline basis function N_i,deg(u) via\n        a memoized recursion. This is a nested function to capture u, T, n, and memo.\n        \"\"\"\n        if (i, deg) in memo:\n            return memo[(i, deg)]\n\n        if deg == 0:\n            # The curve domain is [t_p, t_{n+1}]. At the right boundary u = t_{n+1},\n            # the convention is that u falls in the last interval [t_n, t_{n+1}],\n            # making N_{n,0}(t_{n+1}) = 1.\n            if u == T[n + 1] and i == n:\n                res = 1.0\n            else:\n                # Standard definition for half-open interval [t_i, t_{i+1}).\n                # This is 0 if t_i == t_{i+1}.\n                res = 1.0 if T[i] = u  T[i + 1] else 0.0\n            memo[(i, deg)] = res\n            return res\n\n        # Recursive step\n        term1 = 0.0\n        den1 = T[i + deg] - T[i]\n        if den1 != 0.0:\n            term1 = ((u - T[i]) / den1) * _basis_function(i, deg - 1)\n\n        term2 = 0.0\n        den2 = T[i + deg + 1] - T[i + 1]\n        if den2 != 0.0:\n            term2 = ((T[i + deg + 1] - u) / den2) * _basis_function(i + 1, deg - 1)\n\n        res = term1 + term2\n        memo[(i, deg)] = res\n        return res\n\n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(n + 1):\n        basis_val = _basis_function(i, p)\n        # Optimization: only add if the basis function is non-zero\n        if basis_val > 1e-12: # Check against small tolerance\n            curve_point += basis_val * control_points[i]\n            \n    return curve_point\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify endpoint interpolation.\n    \"\"\"\n    test_cases = [\n        # Case 1: 2D quadratic\n        {\n            \"p\": 2,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [2, 0.5], [3, 3], [4, 0]\n            ]),\n            \"knot_vector\": None \n        },\n        # Case 2: 2D cubic, Bezier-like\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [3, 2], [4, 0]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 3: 2D cubic, non-uniform knots\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 1], [2, -1], [3, 2], [4, -0.5], [5, 1.5], [6, 0]\n            ]),\n            \"knot_vector\": np.array([0, 0, 0, 0, 0.15, 0.6, 0.85, 1, 1, 1, 1])\n        },\n        # Case 4: 2D linear\n        {\n            \"p\": 1,\n            \"control_points\": np.array([\n                [0, 1], [1, 0], [2, 1.5]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 5: 3D cubic\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0, 0], [1, 2, 1], [2, -1, 2], [3, 3, 2], [4, 0, 1], [5, 1, 0]\n            ]),\n            \"knot_vector\": None\n        }\n    ]\n\n    results = []\n    tolerance = 1e-9\n\n    for case in test_cases:\n        p = case[\"p\"]\n        P = case[\"control_points\"]\n        n = len(P) - 1\n\n        if case[\"knot_vector\"] is None:\n            T = build_clamped_uniform_knot_vector(n, p)\n        else:\n            T = case[\"knot_vector\"]\n        \n        # Endpoints of the parametric domain for a clamped knot vector\n        u_left = T[p]\n        u_right = T[n + 1]\n\n        # Evaluate curve at endpoints\n        C_left = b_spline_eval(u_left, p, P, T)\n        C_right = b_spline_eval(u_right, p, P, T)\n\n        # Verify interpolation\n        dist_left = np.linalg.norm(C_left - P[0])\n        dist_right = np.linalg.norm(C_right - P[-1])\n\n        check_left = dist_left = tolerance\n        check_right = dist_right = tolerance\n        \n        results.append(check_left and check_right)\n\n    # Format output as required\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```", "id": "3207506"}, {"introduction": "Beyond basic evaluation, the true power of B-splines lies in their extensive toolkit for shape control. This practice delves into one of the most important control mechanisms: knot multiplicity. You will write a program to quantitatively investigate how increasing the multiplicity of a knot reduces the curve's continuity, from $C^2$ smooth down to a sharp $C^0$ corner, and how this affects the local shape [@problem_id:3099558]. This exercise provides a concrete understanding of the $C^{p-m}$ continuity rule and demonstrates how knot manipulation is used to create features like creases and flat spots in geometric design.", "problem": "You will investigate how increasing knot multiplicity in a cubic B-spline affects local shape, including possible overshoot relative to a baseline curve and the creation of corners or flat spots. Work entirely in a purely mathematical setting with two-dimensional control points and standard B-spline definitions. Your program must be a complete, runnable implementation that evaluates curves and their derivatives from first principles, and computes quantitative metrics for a small test suite.\n\nFundamental base and definitions:\n- A B-spline curve of degree $p$ with control points $\\{\\mathbf{P}_i\\}_{i=0}^{N-1}$ and nondecreasing knot vector $\\{t_j\\}_{j=0}^{N+p}$ is defined as\n$$\n\\mathbf{C}(t) = \\sum_{i=0}^{N-1} N_{i,p}(t)\\,\\mathbf{P}_i,\n$$\nwhere $N_{i,p}(t)$ are B-spline basis functions defined by the Cox–de Boor recursion:\n$$\nN_{i,0}(t) =\n\\begin{cases}\n1,  t_i \\le t lt t_{i+1},\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\nand for $p \\ge 1$\n$$\nN_{i,p}(t) = \\frac{t - t_i}{t_{i+p} - t_i} N_{i,p-1}(t) + \\frac{t_{i+p+1} - t}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t),\n$$\nwith the convention that terms with zero denominators contribute $0$.\n- The derivative of the curve uses the derivatives of basis functions:\n$$\n\\mathbf{C}'(t) = \\sum_{i=0}^{N-1} \\frac{d N_{i,p}(t)}{dt}\\,\\mathbf{P}_i,\n$$\nwhere\n$$\n\\frac{d N_{i,p}(t)}{dt} = \\frac{p}{t_{i+p} - t_i} N_{i,p-1}(t) - \\frac{p}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t),\n$$\nagain interpreting divisions by zero as contributing $0$.\n- For a knot of multiplicity $m$ in a degree-$p$ B-spline, the curve continuity at that knot is $C^{p-m}$, meaning that the first $p-m$ derivatives are continuous while the $(p-m+1)$-st derivative generally has a jump. In particular, if $m = p+1$, the curve has a break (no positional continuity) at that knot.\n\nScenario and modeling setup:\n- Use degree $p = 3$ (cubic) and $N = 8$ control points in $\\mathbb{R}^2$.\n- Use an open knot vector with repeated endpoints:\n$$\n\\underbrace{0,0,0,0}_{p+1\\text{ times}}, \\text{interior knots}, \\underbrace{1,1,1,1}_{p+1\\text{ times}}.\n$$\n- Let the interior knot location of interest be $u_0 = 0.5$. The total number of interior knot entries is $N - p - 1 = 4$. For a chosen multiplicity $m \\in \\{1,2,3,4\\}$ at $u_0$, construct the interior knot multiset as follows. Include $m$ copies of $u_0$ and use the remaining $4 - m$ entries from the fixed list $\\{0.25,\\,0.33,\\,0.75\\}$, taking the smallest $4-m$ elements from this list and then sorting all interior entries. This produces exactly four interior knot entries for every $m$.\n- Define two scenarios of control points:\n  - Scenario A (hump-like):\n    - $\\mathbf{P}_0=(0.0, 0.0)$,\n    - $\\mathbf{P}_1=(1.0, 1.0)$,\n    - $\\mathbf{P}_2=(2.0, 2.0)$,\n    - $\\mathbf{P}_3=(3.0, 4.0)$,\n    - $\\mathbf{P}_4=(4.0, 2.0)$,\n    - $\\mathbf{P}_5=(5.0, 1.5)$,\n    - $\\mathbf{P}_6=(6.0, 1.2)$,\n    - $\\mathbf{P}_7=(7.0, 1.1)$.\n  - Scenario B (locally flat region):\n    - $\\mathbf{P}_0=(0.0, 0.0)$,\n    - $\\mathbf{P}_1=(1.0, 0.5)$,\n    - $\\mathbf{P}_2=(2.0, 1.0)$,\n    - $\\mathbf{P}_3=(3.0, 1.0)$,\n    - $\\mathbf{P}_4=(4.0, 1.0)$,\n    - $\\mathbf{P}_5=(5.0, 1.0)$,\n    - $\\mathbf{P}_6=(6.0, 1.2)$,\n    - $\\mathbf{P}_7=(7.0, 2.0)$.\n\nQuantities to compute:\n- Define the baseline curve to be the cubic B-spline with multiplicity $m=1$ at $u_0=0.5$, using the interior-knot construction above. Denote this baseline as $\\mathbf{C}_{\\mathrm{base}}(t)$.\n- For each scenario and for each $m \\in \\{1,2,3,4\\}$, construct the corresponding knot vector and compute:\n  1. The maximum absolute deviation from the baseline on a uniform sample of parameter values:\n     $$\n     D_{\\max}(m) = \\max_{t \\in \\mathcal{T}} \\left\\lVert \\mathbf{C}_m(t) - \\mathbf{C}_{\\mathrm{base}}(t) \\right\\rVert_2.\n     $$\n     Use the Euclidean norm. Let the sample $\\mathcal{T}$ be $4001$ equally spaced points in the open interval $(0,1)$, for instance $t_k$ linearly spaced from $10^{-6}$ to $1-10^{-6}$ to avoid evaluating exactly at knots.\n  2. A numerical measure of the slope discontinuity at the interior knot $u_0$:\n     $$\n     J(m) = \\left\\lVert \\mathbf{C}_m'(u_0^+) - \\mathbf{C}_m'(u_0^-) \\right\\rVert_2.\n     $$\n     To evaluate one-sided derivatives without hitting the knot exactly, choose\n     $$\n     \\delta = \\min\\left(0.1\\,(u_0 - u_\\text{L}),\\, 0.1\\,(u_\\text{R} - u_0),\\, 10^{-3}\\right),\n     $$\n     where $u_\\text{L}$ is the largest knot strictly less than $u_0$, and $u_\\text{R}$ is the smallest knot strictly greater than $u_0$ in the constructed knot vector. Then approximate the one-sided derivatives by evaluating $\\mathbf{C}_m'(u_0 - \\delta)$ and $\\mathbf{C}_m'(u_0 + \\delta)$ using the basis-derivative formula above. The Euclidean norm of their difference is $J(m)$.\n\nTest suite and required output:\n- Use both Scenario A and Scenario B control points.\n- For each scenario, evaluate the pair $\\left(D_{\\max}(m), J(m)\\right)$ for $m = 1, 2, 3, 4$.\n- Round each reported floating-point result to six decimal places.\n- Your program should produce a single line of output containing all results for both scenarios as a comma-separated list enclosed in square brackets. The ordering must be:\n  - Scenario A: $D_{\\max}(1)$, $J(1)$, $D_{\\max}(2)$, $J(2)$, $D_{\\max}(3)$, $J(3)$, $D_{\\max}(4)$, $J(4)$,\n  - followed by Scenario B in the same order.\nThat is, the output format is\n$$\n[\\;D_{\\max}^{A}(1),J^{A}(1),D_{\\max}^{A}(2),J^{A}(2),D_{\\max}^{A}(3),J^{A}(3),D_{\\max}^{A}(4),J^{A}(4),D_{\\max}^{B}(1),J^{B}(1),D_{\\max}^{B}(2),J^{B}(2),D_{\\max}^{B}(3),J^{B}(3),D_{\\max}^{B}(4),J^{B}(4)\\;].\n$$\nNo units are required because all quantities are dimensionless.", "solution": "The user has provided a well-defined computational problem concerning the properties of B-spline curves. I will first validate the problem statement and then provide a comprehensive solution based on fundamental principles.\n\n### Problem Validation\n\n1.  **Extraction of Givens**:\n    - **Curve Type**: B-spline curve of degree $p=3$ with $N=8$ control points in $\\mathbb{R}^2$.\n    - **Curve Definition**: $\\mathbf{C}(t) = \\sum_{i=0}^{N-1} N_{i,p}(t)\\,\\mathbf{P}_i$, with basis functions $N_{i,p}(t)$ defined by the Cox–de Boor recursion.\n    - **Curve Derivative**: $\\mathbf{C}'(t) = \\sum_{i=0}^{N-1} \\frac{d N_{i,p}(t)}{dt}\\,\\mathbf{P}_i$, with $\\frac{d N_{i,p}(t)}{dt} = \\frac{p}{t_{i+p} - t_i} N_{i,p-1}(t) - \\frac{p}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t)$.\n    - **Knot Vector**: Open knot vector with $p+1=4$ knots at $0$ and $4$ knots at $1$. It contains $N-p-1=4$ interior knots.\n    - **Interior Knot Construction**: For a multiplicity $m \\in \\{1,2,3,4\\}$ at $u_0 = 0.5$, the four interior knots are formed by $m$ copies of $0.5$ and the $4-m$ smallest values from the set $\\{0.25, 0.33, 0.75\\}$, sorted.\n    - **Control Point Scenarios**: Two sets of control points, Scenario A (hump-like) and Scenario B (locally flat region), are provided.\n    - **Metrics**:\n        1.  $D_{\\max}(m) = \\max_{t \\in \\mathcal{T}} \\left\\lVert \\mathbf{C}_m(t) - \\mathbf{C}_{\\mathrm{base}}(t) \\right\\rVert_2$, where $\\mathbf{C}_{\\mathrm{base}}$ is the curve for $m=1$. Evaluation grid $\\mathcal{T}$ has $4001$ points in $(0,1)$.\n        2.  $J(m) = \\left\\lVert \\mathbf{C}_m'(u_0^+) - \\mathbf{C}_m'(u_0^-) \\right\\rVert_2$, with one-sided derivatives approximated at $u_0 \\pm \\delta$. $\\delta$ is defined as $\\min\\left(0.1\\,(u_0 - u_\\text{L}),\\, 0.1\\,(u_\\text{R} - u_0),\\, 10^{-3}\\right)$.\n    - **Output Format**: A single line containing a comma-separated list of $16$ floating-point values rounded to six decimal places, representing $(D_{\\max}(m), J(m))$ for $m \\in \\{1,2,3,4\\}$ for each of the two scenarios.\n\n2.  **Validation against Criteria**:\n    - **Scientifically Grounded**: The problem is rooted in the standard mathematical theory of B-splines, a core topic in computational science and computer-aided geometric design. All definitions and formulas are correct.\n    - **Well-Posed**: The problem is specified with a high degree of precision. All parameters, data, construction rules, and formulas for the quantities to be computed are explicitly given. The setup is self-contained and sufficient to produce a unique, deterministic solution.\n    - **Objective**: The problem statement is entirely objective, using precise mathematical language and quantitative definitions. There are no subjective or ambiguous elements.\n    - **Other criteria**: The problem is not trivial, as it requires a correct from-first-principles implementation of a non-trivial algorithm. It is not contradictory, unrealistic, or ill-posed.\n\n3.  **Verdict and Action**:\n    The problem statement is **valid**. I will proceed with formulating and implementing a solution.\n\n### Solution Design\n\nThe solution requires implementing B-spline curve evaluation and its derivative from the provided fundamental definitions. A direct recursive implementation of the Cox-de Boor formula is computationally inefficient. A more robust and performant approach, based on algorithms from standard literature (e.g., \"The NURBS Book\" by Piegl and Tiller), will be used. This adheres to the \"from first principles\" requirement as the algorithms are direct implementations of the mathematical definitions.\n\n1.  **Core Algorithms**:\n    - **Knot Span Search**: A function `find_span` will be implemented to efficiently locate the knot interval (span) containing a given parameter value $t$. This is a prerequisite for efficient basis function evaluation and is typically implemented using binary search.\n    - **Basis Function Evaluation**: A function `basis_funs` will implement an iterative, dynamic programming approach (Algorithm A2.2 from The NURBS Book) to calculate the values of all non-zero basis functions of a given degree for a parameter $t$ within its knot span. This is significantly more efficient than a naive recursive approach.\n    - **Curve Evaluation**: The function `evaluate_bspline` will combine `find_span` and `basis_funs` to compute a point on the curve $\\mathbf{C}(t)$. It finds the relevant knot span, computes the non-zero basis functions, and then takes their weighted sum with the corresponding control points.\n    - **Curve Derivative Evaluation**: The function `evaluate_bspline_derivative` will compute $\\mathbf{C}'(t)$ by directly implementing the sum $\\sum_i \\frac{d N_{i,p}(t)}{dt} \\mathbf{P}_i$. The derivatives of the basis functions, $\\frac{d N_{i,p}(t)}{dt}$, will be calculated using the provided formula, which in turn requires basis functions of degree $p-1$. These will be efficiently computed using the same `basis_funs` algorithm.\n\n2.  **Workflow for a Single Case ($m$, Scenario)**:\n    - **Knot Vector Construction**: The full knot vector of length $N+p+1=12$ is constructed by concatenating the starting repeated knots ($p+1$ zeros), the four specified interior knots, and the ending repeated knots ($p+1$ ones).\n    - **Curve Evaluation for $D_{\\max}$**: For each $m$, the curve $\\mathbf{C}_m(t)$ is evaluated at $4001$ sample points in $(0,1)$. For $m=1$, these points define the baseline curve $\\mathbf{C}_{\\mathrm{base}}$. For $m1$, the Euclidean distance to the corresponding baseline points is computed, and the maximum of these distances gives $D_{\\max}(m)$. By definition, $D_{\\max}(1)=0$.\n    - **Derivative Jump Calculation for $J(m)$**: The small offset $\\delta$ is determined according to the problem's rule. The derivative $\\mathbf{C}_m'(t)$ is evaluated at $u_0 - \\delta$ and $u_0 + \\delta$. The Euclidean norm of the difference between these two derivative vectors gives the jump $J(m)$. The continuity properties of B-splines suggest that $J(1)$ and $J(2)$ should be near zero, while $J(3)$ and $J(4)$ may be significantly non-zero, providing a good sanity check for the implementation.\n\n3.  **Overall Structure**:\n    The main program will iterate through the two control point scenarios. Within each scenario, it will iterate through multiplicities $m$ from $1$ to $4$. In each sub-case, it will construct the appropriate knot vector, compute the pair $(D_{\\max}(m), J(m))$, and store the results. Finally, all $16$ scalar results will be formatted into a single string as required.", "answer": "```python\nimport numpy as np\n\ndef find_span(num_cp, degree, t, knots):\n    \"\"\"\n    Finds the knot span index for a given parameter t.\n    num_cp: number of control points (N).\n    degree: degree of the curve (p).\n    t: parameter value.\n    knots: knot vector.\n    Returns the index k such that knots[k] = t  knots[k+1].\n    \"\"\"\n    # For t=1.0, which can occur at the end of the domain for an open knot vector.\n    # The valid parameter range is [knots[p], knots[N]]. For an open knot vector,\n    # this is [0, 1]. The last span index is N-1.\n    if t >= knots[num_cp]:\n        return num_cp - 1\n    \n    # Binary search for the span. The search space is [p, N-1].\n    low = degree\n    high = num_cp\n    \n    while low  high:\n        mid = (low + high) // 2\n        if t  knots[mid]:\n            high = mid\n        else:\n            low = mid + 1\n    return low - 1\n\ndef basis_funs(span, t, degree, knots):\n    \"\"\"\n    Computes the non-zero B-spline basis functions for a given parameter t.\n    (Algorithm A2.2 from The NURBS Book by Piegl and Tiller).\n    span: knot span index.\n    t: parameter value.\n    degree: degree of the curve.\n    knots: knot vector.\n    Returns an array of p+1 basis function values, N_{span-degree, degree}, ..., N_{span, degree}.\n    \"\"\"\n    basis = np.zeros(degree + 1)\n    left = np.zeros(degree + 1)\n    right = np.zeros(degree + 1)\n    \n    basis[0] = 1.0\n    for j in range(1, degree + 1):\n        left[j] = t - knots[span + 1 - j]\n        right[j] = knots[span + j] - t\n        saved = 0.0\n        for r in range(j):\n            den = knots[span + r + 1] - knots[span + r + 1 - j]\n            if den == 0.0:\n                temp = 0.0\n            else:\n                temp = basis[r] / den\n            basis[r] = saved + right[r + 1] * temp\n            saved = left[j - r] * temp\n        basis[j] = saved\n    return basis\n\ndef evaluate_bspline(t, num_cp, degree, knots, control_points):\n    \"\"\"\n    Evaluates a B-spline curve at a given parameter t.\n    \"\"\"\n    if t  knots[degree] or t > knots[num_cp]:\n        if t = knots[degree]: return control_points[0]\n        else: return control_points[-1]\n\n    span = find_span(num_cp, degree, t, knots)\n    basis_values = basis_funs(span, t, degree, knots)\n    \n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(degree + 1):\n        curve_point += basis_values[i] * control_points[span - degree + i]\n    return curve_point\n\ndef evaluate_bspline_derivative(t, num_cp, degree, knots, control_points):\n    \"\"\"\n    Evaluates the derivative of a B-spline curve at a given parameter t.\n    \"\"\"\n    if t  knots[degree] or t > knots[num_cp]:\n        return np.zeros_like(control_points[0], dtype=float)\n\n    span = find_span(num_cp, degree, t, knots)\n    basis_values_p_minus_1 = basis_funs(span, t, degree - 1, knots)\n    \n    deriv_point = np.zeros_like(control_points[0], dtype=float)\n    \n    for i in range(span - degree, span + 1):\n        # Contribution from control point P_i\n        # dN_{i,p}/dt = p/(t_{i+p}-t_i) * N_{i,p-1} - p/(t_{i+p+1}-t_{i+1}) * N_{i+1,p-1}\n        \n        # Term 1: involving N_{i, p-1}\n        num1 = 0.0\n        # The non-zero basis functions of degree p-1 for span k are N_{k-(p-1),p-1} to N_{k,p-1}\n        # In our case, span=span, degree=p-1. So N_{span-(p-1),p-1} to N_{span,p-1}.\n        if (span - (degree - 1)) = i = span:\n            num1 = basis_values_p_minus_1[i - (span - (degree - 1))]\n        \n        den1 = knots[i + degree] - knots[i]\n        term1 = 0.0\n        if den1 != 0.0:\n            term1 = degree * num1 / den1\n\n        # Term 2: involving N_{i+1, p-1}\n        num2 = 0.0\n        if (span - (degree - 1)) = (i + 1) = span:\n            num2 = basis_values_p_minus_1[i + 1 - (span - (degree - 1))]\n\n        den2 = knots[i + degree + 1] - knots[i + 1]\n        term2 = 0.0\n        if den2 != 0.0:\n            term2 = degree * num2 / den2\n        \n        d_basis = term1 - term2\n        deriv_point += d_basis * control_points[i]\n        \n    return deriv_point\n\n\ndef solve():\n    p = 3\n    N = 8\n    u0 = 0.5\n    \n    P_A = np.array([\n        [0.0, 0.0], [1.0, 1.0], [2.0, 2.0], [3.0, 4.0],\n        [4.0, 2.0], [5.0, 1.5], [6.0, 1.2], [7.0, 1.1]\n    ], dtype=float)\n    \n    P_B = np.array([\n        [0.0, 0.0], [1.0, 0.5], [2.0, 1.0], [3.0, 1.0],\n        [4.0, 1.0], [5.0, 1.0], [6.0, 1.2], [7.0, 2.0]\n    ], dtype=float)\n\n    scenarios = [(\"A\", P_A), (\"B\", P_B)]\n    interior_knot_pool = [0.25, 0.33, 0.75]\n    \n    t_samples = np.linspace(1e-6, 1.0 - 1e-6, 4001)\n    \n    all_results = []\n    \n    for _, P in scenarios:\n        C_base_pts = None\n        \n        for m in range(1, 5):\n            # 1. Construct knot vector\n            num_other_knots = 4 - m\n            interior_knots = sorted(interior_knot_pool[:num_other_knots] + [u0] * m)\n            knots = np.concatenate((np.zeros(p + 1, dtype=float), np.array(interior_knots, dtype=float), np.ones(p + 1, dtype=float)))\n\n            # 2. Compute curve points for D_max calculation\n            C_m_pts = np.array([evaluate_bspline(t, N, p, knots, P) for t in t_samples])\n            \n            if m == 1:\n                C_base_pts = C_m_pts\n                D_max = 0.0\n            else:\n                deviations = np.linalg.norm(C_m_pts - C_base_pts, axis=1)\n                D_max = np.max(deviations)\n\n            # 3. Compute slope discontinuity J(m)\n            unique_knots = sorted(list(set(knots)))\n            u_L_idx = np.searchsorted(unique_knots, u0, side='left') - 1\n            u_R_idx = np.searchsorted(unique_knots, u0, side='right')\n            u_L = unique_knots[u_L_idx] if u_L_idx >= 0 else knots[0]\n            u_R = unique_knots[u_R_idx] if u_R_idx  len(unique_knots) else knots[-1]\n            \n            term_L = 0.1 * (u0 - u_L) if u_L  u0 else np.inf\n            term_R = 0.1 * (u_R - u0) if u_R > u0 else np.inf\n            delta = min(term_L, term_R, 1e-3)\n            \n            dC_left = evaluate_bspline_derivative(u0 - delta, N, p, knots, P)\n            dC_right = evaluate_bspline_derivative(u0 + delta, N, p, knots, P)\n            J_m = np.linalg.norm(dC_right - dC_left)\n            \n            all_results.extend([D_max, J_m])\n            \n    print(f\"[{','.join(f'{r:.6f}' for r in all_results)}]\")\n\nsolve()\n```", "id": "3099558"}, {"introduction": "Complex models are rarely created from a single monolithic curve; instead, they are pieced together from multiple segments. Ensuring these segments join smoothly is paramount, and this exercise explores the subtle but critical difference between two types of smoothness: parametric ($C^1$) and geometric ($G^1$) continuity. By analyzing the control point configurations at the junction of two cubic segments, you will discover how to achieve a visually smooth transition ($G^1$) without the restrictive condition of matching derivative vectors exactly ($C^1$), a key principle for flexible and intuitive curve design [@problem_id:3207470].", "problem": "Let two cubic clamped B-spline segments (equivalently, cubic Bézier curves with clamped uniform knots) be joined to form a piecewise parametric curve. Each segment is defined on its own parameter interval $[0,1]$ by four control points in $\\mathbb{R}^2$, denoted by $\\{A_0,A_1,A_2,A_3\\}$ for the first segment and $\\{B_0,B_1,B_2,B_3\\}$ for the second segment. The join point is enforced by setting $A_3=B_0$. Geometric continuity of order $1$ (G$^1$) at the join requires the tangent directions to agree across the join, while parametric continuity of order $1$ (C$^1$) requires the first derivative vectors with respect to the common parameter to be equal across the join. Consider the following four candidate constructions. In all options, the first segment has control points\n$$A_0=(0,0),\\quad A_1=(1,0),\\quad A_2=(2,0),\\quad A_3=(3,0),$$\nand the second segment’s control points are specified as follows:\n- A. $B_0=(3,0),\\quad B_1=(5,0),\\quad B_2=(6,1),\\quad B_3=(7,1)$\n\n- B. $B_0=(3,0),\\quad B_1=(4,0),\\quad B_2=(6,1),\\quad B_3=(7,1)$\n\n- C. $B_0=(3,0),\\quad B_1=(1,0),\\quad B_2=(2,-1),\\quad B_3=(3,-1)$\n\n- D. $B_0=(3,0),\\quad B_1=(5,2),\\quad B_2=(6,2),\\quad B_3=(7,2)$\n\nWhich option constructs two B-spline segments that are G$^1$ but not C$^1$ at their join point $A_3=B_0$? Provide justification based on the fundamental definitions of piecewise polynomial curves and continuity types, without assuming shortcut endpoint derivative formulas.", "solution": "The user's request is to identify which of the four provided options for control points results in a piecewise curve that is G$^1$ (geometrically continuous of order 1) but not C$^1$ (parametrically continuous of order 1) at the join point.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- The curve is composed of two cubic clamped B-spline segments.\n- This is stated to be equivalent to two cubic Bézier curves.\n- Let the first segment be $\\mathbf{S}_1(u)$ for $u \\in [0,1]$ and the second be $\\mathbf{S}_2(v)$ for $v \\in [0,1]$.\n- First segment control points: $\\{A_0, A_1, A_2, A_3\\}$.\n- Second segment control points: $\\{B_0, B_1, B_2, B_3\\}$.\n- Join condition: $A_3 = B_0$.\n- G$^1$ continuity definition: Tangent directions agree at the join.\n- C$^1$ continuity definition: First derivative vectors are equal at the join.\n- First segment control points are fixed: $A_0=(0,0)$, $A_1=(1,0)$, $A_2=(2,0)$, $A_3=(3,0)$.\n- The problem asks to find which of the four options for $\\{B_0,B_1,B_2,B_3\\}$ results in a G$^1$ but not C$^1$ join.\n- The derivation must be based on fundamental definitions, not \"shortcut endpoint derivative formulas\".\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding:** The problem is based on the well-established mathematical theory of Bézier curves and splines, a cornerstone of computer-aided geometric design (CAGD) and numerical analysis. The definitions of G$^1$ and C$^1$ continuity are standard and rigorous. The problem is scientifically sound.\n- **Well-Posedness:** The problem provides all necessary data and definitions to arrive at a unique conclusion for each option. The question is unambiguous and allows for a definitive answer.\n- **Objectivity:** The problem is stated using precise, objective mathematical language.\n- **Verdict:** The problem statement is valid. It is self-contained, factually correct, and well-posed. No flaws are identified.\n\nProceeding to solution derivation.\n\n### Derivation of Continuity Conditions\n\nA cubic Bézier curve defined by four control points $\\{P_0, P_1, P_2, P_3\\}$ over a parameter $t \\in [0,1]$ is given by the Bernstein basis representation:\n$$ \\mathbf{P}(t) = \\sum_{i=0}^{3} B_{i,3}(t) P_i = (1-t)^3 P_0 + 3(1-t)^2 t P_1 + 3(1-t) t^2 P_2 + t^3 P_3 $$\nwhere $B_{i,3}(t) = \\binom{3}{i} (1-t)^{3-i} t^i$ are the Bernstein basis polynomials of degree $3$.\n\nThe derivative of a Bézier curve of degree $n$, $\\mathbf{P}(t) = \\sum_{i=0}^{n} B_{i,n}(t) P_i$, can be expressed as a Bézier curve of degree $n-1$. This is a fundamental property derived from the derivative of the Bernstein basis polynomials, $\\frac{d}{dt} B_{i,n}(t) = n(B_{i-1,n-1}(t) - B_{i,n-1}(t))$. Applying this to the curve definition and re-indexing the summation yields:\n$$ \\mathbf{P}'(t) = n \\sum_{i=0}^{n-1} B_{i,n-1}(t) (P_{i+1} - P_i) $$\nFor our cubic case, $n=3$, the derivative is:\n$$ \\mathbf{P}'(t) = 3 \\sum_{i=0}^{2} B_{i,2}(t) (P_{i+1} - P_i) = 3 \\left[ (1-t)^2 (P_1-P_0) + 2(1-t)t (P_2-P_1) + t^2 (P_3-P_2) \\right] $$\nThis is not a \"shortcut\" but a direct consequence of the mathematical structure of Bézier curves. To find the tangent vectors at the endpoints, we evaluate this expression at $t=0$ and $t=1$.\n\nAt the start point ($t=0$):\nThe Bernstein basis polynomials $B_{i,2}(0)$ are $1$ for $i=0$ and $0$ for $i0$.\n$$ \\mathbf{P}'(0) = 3 \\left[ 1 \\cdot (P_1-P_0) + 0 + 0 \\right] = 3(P_1-P_0) $$\nAt the end point ($t=1$):\nThe Bernstein basis polynomials $B_{i,2}(1)$ are $1$ for $i=2$ and $0$ for $i2$.\n$$ \\mathbf{P}'(1) = 3 \\left[ 0 + 0 + 1 \\cdot (P_3-P_2) \\right] = 3(P_3-P_2) $$\n\nLet the first segment be $\\mathbf{S}_1(u)$ defined by $\\{A_0, A_1, A_2, A_3\\}$, and the second segment be $\\mathbf{S}_2(v)$ defined by $\\{B_0, B_1, B_2, B_3\\}$. The join occurs at the end of the first segment ($\\mathbf{S}_1(1)$) and the beginning of the second ($\\mathbf{S}_2(0)$).\n\n- The tangent vector of the first segment at the join is $\\mathbf{S}_1'(1) = 3(A_3 - A_2)$.\n- The tangent vector of the second segment at the join is $\\mathbf{S}_2'(0) = 3(B_1 - B_0)$.\n\n**Continuity Conditions at the Join:**\n1.  **C$^0$ continuity (positional continuity):** $\\mathbf{S}_1(1) = \\mathbf{S}_2(0)$. Since $\\mathbf{S}_1(1)=A_3$ and $\\mathbf{S}_2(0)=B_0$, this requires $A_3=B_0$. This condition is given as enforced.\n\n2.  **G$^1$ continuity (geometric continuity):** The tangent vectors must be collinear and point in the same direction. This ensures a smooth transition in direction, without a cusp.\n    $$ \\mathbf{S}_1'(1) = k \\cdot \\mathbf{S}_2'(0) \\quad \\text{for some scalar } k  0 $$\n    $$ 3(A_3 - A_2) = k \\cdot 3(B_1 - B_0) \\implies A_3 - A_2 = k(B_1 - B_0) $$\n    Geometrically, this means the three control points $A_2$, $A_3$, and $B_1$ must be collinear, with $A_3$ lying between $A_2$ and $B_1$ (or coincident with one).\n\n3.  **C$^1$ continuity (parametric continuity):** The tangent vectors must be identical.\n    $$ \\mathbf{S}_1'(1) = \\mathbf{S}_2'(0) $$\n    $$ 3(A_3 - A_2) = 3(B_1 - B_0) \\implies A_3 - A_2 = B_1 - B_0 $$\n    This is a special case of G$^1$ where $k=1$.\n\nThe problem asks for an option that is G$^1$ but not C$^1$. This means we must find a case where the vectors $(A_3 - A_2)$ and $(B_1 - B_0)$ are collinear with a positive scaling factor $k \\neq 1$.\n\n**Applying to the Given Data:**\nThe control points for the first segment are $A_2=(2,0)$ and $A_3=(3,0)$.\nThe vector determining the tangent at the end of the first segment is:\n$$ A_3 - A_2 = (3,0) - (2,0) = (1,0) $$\n\nNow we evaluate each option.\n\n### Option-by-Option Analysis\n\n**A. $B_0=(3,0), B_1=(5,0), B_2=(6,1), B_3=(7,1)$**\n- **C$^0$ Check:** $A_3 = (3,0)$ and $B_0 = (3,0)$. The condition $A_3=B_0$ is satisfied.\n- **Continuity Analysis:** We compute the vector $B_1 - B_0$:\n  $$ B_1 - B_0 = (5,0) - (3,0) = (2,0) $$\n  We test the G$^1$ condition: $A_3 - A_2 = k(B_1 - B_0)$.\n  $$ (1,0) = k(2,0) $$\n  This equation is satisfied for $k = 1/2$. Since $k  0$, the G$^1$ condition is met. The three points $A_2=(2,0)$, $A_3=(3,0)$, and $B_1=(5,0)$ are collinear.\n- **C$^1$ Check:** The C$^1$ condition requires $k=1$. Here, $k=1/2$, so the condition is not met. The tangent vectors $\\mathbf{S}_1'(1)=3(1,0)=(3,0)$ and $\\mathbf{S}_2'(0)=3(2,0)=(6,0)$ are not equal.\n- **Verdict:** This option constructs a curve that is G$^1$ but not C$^1$. **Correct.**\n\n**B. $B_0=(3,0), B_1=(4,0), B_2=(6,1), B_3=(7,1)$**\n- **C$^0$ Check:** $A_3 = (3,0)$ and $B_0 = (3,0)$. The condition $A_3=B_0$ is satisfied.\n- **Continuity Analysis:** We compute the vector $B_1 - B_0$:\n  $$ B_1 - B_0 = (4,0) - (3,0) = (1,0) $$\n  We test the G$^1$ condition: $A_3 - A_2 = k(B_1 - B_0)$.\n  $$ (1,0) = k(1,0) $$\n  This equation is satisfied for $k = 1$.\n- **C$^1$ Check:** Since $k=1$, the condition for C$^1$ continuity is met.\n- **Verdict:** This option constructs a curve that is C$^1$ (and therefore G$^1$). **Incorrect.**\n\n**C. $B_0=(3,0), B_1=(1,0), B_2=(2,-1), B_3=(3,-1)$**\n- **C$^0$ Check:** $A_3 = (3,0)$ and $B_0 = (3,0)$. The condition $A_3=B_0$ is satisfied.\n- **Continuity Analysis:** We compute the vector $B_1 - B_0$:\n  $$ B_1 - B_0 = (1,0) - (3,0) = (-2,0) $$\n  We test the G$^1$ condition: $A_3 - A_2 = k(B_1 - B_0)$.\n  $$ (1,0) = k(-2,0) $$\n  This equation is satisfied for $k = -1/2$. Since $k  0$, the tangent vectors point in opposite directions. This creates a cusp at the join point, violating the \"agreed direction\" requirement of G$^1$ continuity.\n- **Verdict:** This option is not G$^1$ continuous. **Incorrect.**\n\n**D. $B_0=(3,0), B_1=(5,2), B_2=(6,2), B_3=(7,2)$**\n- **C$^0$ Check:** $A_3 = (3,0)$ and $B_0 = (3,0)$. The condition $A_3=B_0$ is satisfied.\n- **Continuity Analysis:** We compute the vector $B_1 - B_0$:\n  $$ B_1 - B_0 = (5,2) - (3,0) = (2,2) $$\n  We test the G$^1$ condition: $A_3 - A_2 = k(B_1 - B_0)$.\n  $$ (1,0) = k(2,2) $$\n  There is no scalar $k$ that can satisfy this vector equation, as $k(2,2) = (2k, 2k)$, and the y-component $2k$ cannot be $0$ unless $k=0$, which would make the x-component $0$, not $1$. The vectors $(1,0)$ and $(2,2)$ are not collinear.\n- **Verdict:** This option is not G$^1$ continuous. **Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "3207470"}]}