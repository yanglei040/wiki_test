{"hands_on_practices": [{"introduction": "One of the most powerful applications of polynomial interpolation is creating a continuous model from a set of discrete data points. This exercise [@problem_id:2183531] demonstrates this process in a practical context. Once you construct the interpolating polynomial, you can use it to analyze the underlying system, such as finding its minimum or maximum value, which is a common goal in many scientific and engineering optimization problems.", "problem": "In a numerical modeling experiment, a certain quantity $y$ is found to depend on a variable $x$ according to a quadratic relationship, $y=P(x)$, where $P(x)$ is a polynomial of degree two. To characterize this relationship, three data points are measured: $(0, 5)$, $(2, 3)$, and $(4, 7)$. Assuming these points lie exactly on the curve of the polynomial, determine the minimum value attained by the function $P(x)$.", "solution": "Let $P(x)$ be a quadratic polynomial, written as $P(x)=ax^{2}+bx+c$ with $a\\neq 0$. The given points $(0,5)$, $(2,3)$, and $(4,7)$ lie on its graph, so they satisfy\n$$\nP(0)=5,\\quad P(2)=3,\\quad P(4)=7.\n$$\nFrom $P(0)=5$ we obtain $c=5$.\n\nUsing $P(2)=3$ gives\n$$\n4a+2b+c=3 \\;\\Longrightarrow\\; 4a+2b+5=3 \\;\\Longrightarrow\\; 4a+2b=-2 \\;\\Longrightarrow\\; 2a+b=-1.\n$$\nUsing $P(4)=7$ gives\n$$\n16a+4b+c=7 \\;\\Longrightarrow\\; 16a+4b+5=7 \\;\\Longrightarrow\\; 16a+4b=2 \\;\\Longrightarrow\\; 8a+2b=1.\n$$\nSubtracting $2\\cdot(2a+b=-1)$, i.e., $4a+2b=-2$, from $8a+2b=1$ yields\n$$\n(8a+2b)-(4a+2b)=1-(-2)\\;\\Longrightarrow\\; 4a=3 \\;\\Longrightarrow\\; a=\\frac{3}{4}.\n$$\nSubstituting into $2a+b=-1$ gives\n$$\n2\\cdot \\frac{3}{4}+b=-1 \\;\\Longrightarrow\\; \\frac{3}{2}+b=-1 \\;\\Longrightarrow\\; b=-\\frac{5}{2}.\n$$\nTherefore,\n$$\nP(x)=\\frac{3}{4}x^{2}-\\frac{5}{2}x+5.\n$$\nSince $a=\\frac{3}{4}>0$, the parabola opens upward, so $P(x)$ attains its minimum at the vertex $x^{*}=-\\frac{b}{2a}$. Compute\n$$\nx^{*}=-\\frac{b}{2a}=-\\frac{-\\frac{5}{2}}{2\\cdot \\frac{3}{4}}=\\frac{\\frac{5}{2}}{\\frac{3}{2}}=\\frac{5}{3}.\n$$\nThe minimum value can be computed using the identity $P_{\\min}=c-\\frac{b^{2}}{4a}$ for $a>0$:\n$$\nP_{\\min}=5-\\frac{\\left(-\\frac{5}{2}\\right)^{2}}{4\\cdot \\frac{3}{4}}=5-\\frac{\\frac{25}{4}}{3}=5-\\frac{25}{12}=\\frac{60}{12}-\\frac{25}{12}=\\frac{35}{12}.\n$$\nThus, the minimum value of $P(x)$ is $\\frac{35}{12}$.", "answer": "$$\\boxed{\\frac{35}{12}}$$", "id": "2183531"}, {"introduction": "The Lagrange interpolating polynomial is not just *a* polynomial that fits a set of points; it is the *unique* polynomial of the lowest possible degree that does so. This exercise [@problem_id:2183527] is designed to test your understanding of this fundamental uniqueness property. By recognizing its implication, you can sidestep a significant amount of calculation and arrive at the solution through logical deduction, a skill crucial for efficient problem-solving.", "problem": "A certain physical quantity is known to be described by a polynomial function, $f(x)$. To determine this function, an experiment is conducted, yielding four data points $(x_i, y_i)$:\n- $(x_0, y_0) = (0, 7)$\n- $(x_1, y_1) = (1, 7)$\n- $(x_2, y_2) = (-1, -3)$\n- $(x_3, y_3) = (2, 9)$\n\nLet $P(x)$ be the unique Lagrange interpolating polynomial of degree at most 3 that passes through these four data points. After constructing this polynomial, it is discovered that the true function governing the physical quantity is exactly $f(x) = 2x^3 - 5x^2 + 3x + 7$.\n\nCalculate the value of $P(3)$.", "solution": "We are given four data points and the information that $P(x)$ is the unique polynomial of degree at most $3$ interpolating them. The true governing function is $f(x)=2x^{3}-5x^{2}+3x+7$. By the uniqueness of the Lagrange interpolating polynomial of degree at most $3$, if $f(x)$ passes through the same four points, then $P(x)=f(x)$ for all $x$.\n\nVerify that $f(x_{i})=y_{i}$ for each given point:\n1) At $x_{0}=0$: $f(0)=2\\cdot 0^{3}-5\\cdot 0^{2}+3\\cdot 0+7=7=y_{0}$.\n2) At $x_{1}=1$: $f(1)=2\\cdot 1^{3}-5\\cdot 1^{2}+3\\cdot 1+7=2-5+3+7=7=y_{1}$.\n3) At $x_{2}=-1$: $f(-1)=2\\cdot(-1)^{3}-5\\cdot(-1)^{2}+3\\cdot(-1)+7=-2-5-3+7=-3=y_{2}$.\n4) At $x_{3}=2$: $f(2)=2\\cdot 2^{3}-5\\cdot 2^{2}+3\\cdot 2+7=16-20+6+7=9=y_{3}$.\n\nSince $f(x)$ matches all four data points and is of degree $3$, the uniqueness property implies $P(x)=f(x)$. Therefore,\n$$\nP(3)=f(3)=2\\cdot 3^{3}-5\\cdot 3^{2}+3\\cdot 3+7=54-45+9+7=25.\n$$", "answer": "$$\\boxed{25}$$", "id": "2183527"}, {"introduction": "Moving from theory to practice, this exercise [@problem_id:3150109] challenges you to implement polynomial interpolation in a realistic computational setting. You will tackle a sensor calibration problem, where the choice of interpolation points significantly impacts accuracy, leading to the use of specialized nodes like Chebyshev nodes. This coding practice will build your skills in numerical implementation and error analysis, which are essential for any computational scientist.", "problem": "A calibration engineer models the voltage response of an instrument as a function of electrical current, denoted by the nonlinearity curve $V(I)$. From the foundational definition of polynomial interpolation, for $n$ distinct input currents $I_k$ and measured voltages $V_k$, there is a unique polynomial of degree at most $n-1$ that matches the given pairs at the specified points. Your task is to construct such a polynomial interpolant using nodes that are chosen to reduce large oscillations: use the $n$ Chebyshev nodes of the first kind mapped linearly from the canonical interval $[-1,1]$ to a specified current range $[I_{\\min}, I_{\\max}]$. The interpolant must be built explicitly from first principles of interpolation, ensuring it exactly matches the voltage at the selected nodes, and then be evaluated on a dense uniform grid in the current range to quantify the maximum absolute calibration error. The calibration error is the absolute difference between the true $V(I)$ and the interpolated value, and the quantity to report is the supremum over the grid, approximated numerically. All angles appearing in trigonometric functions must be interpreted in radians. Report all errors in volts, rounded to $8$ decimal places.\n\nImplement a complete, runnable program that:\n- Generates $n$ Chebyshev nodes of the first kind on $[-1,1]$, maps them linearly into $[I_{\\min}, I_{\\max}]$, samples the true $V(I)$ at those mapped nodes, constructs the unique degree-$\\le n-1$ polynomial interpolant that matches those samples, and evaluates the interpolant and the true curve on a uniform grid of $M$ points over $[I_{\\min}, I_{\\max}]$.\n- Computes the maximum absolute calibration error $\\max_{I \\in \\text{grid}} \\left| V(I) - P_n(I) \\right|$ for each test case, where $P_n$ is the polynomial interpolant.\n- Produces a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3]$, where each $r_i$ is the maximum absolute error in volts for the $i$-th test case, rounded to $8$ decimal places. The output must contain no unit symbols and no additional text.\n\nUse the following test suite of four scientifically plausible cases that together exercise a typical scenario, a boundary condition, an edge range including negative currents, and a polynomial exactness check:\n- Case $1$ (happy path): $I_{\\min} = 0$, $I_{\\max} = 10$, $n = 8$, $M = 10001$, and\n  $$V(I) = \\ln(1 + I) + \\frac{0.02 I^3}{1 + I^2} + 0.1 \\sin(I).$$\n- Case $2$ (boundary on $n$): $I_{\\min} = 0$, $I_{\\max} = 10$, $n = 1$, $M = 10001$, and\n  $$V(I) = e^{0.1 I} + 0.5 \\cos(I).$$\n- Case $3$ (range includes negative current): $I_{\\min} = -5$, $I_{\\max} = 5$, $n = 20$, $M = 20001$, and\n  $$V(I) = \\frac{1}{1 + 25 I^2} + 0.2 I.$$\n- Case $4$ (polynomial exactness check): $I_{\\min} = -2$, $I_{\\max} = 2$, $n = 4$, $M = 10001$, and\n  $$V(I) = 0.7 + 1.2 I - 0.5 I^2 + 0.03 I^3.$$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases above, for example $[r_1,r_2,r_3,r_4]$, where each $r_i$ is a floating-point value in volts rounded to $8$ decimal places. Angles in $\\sin(\\cdot)$ and $\\cos(\\cdot)$ are to be interpreted in radians. The numerical values represent volt-level errors; do not include unit symbols in the output.", "solution": "The problem requires the construction of a polynomial interpolant, $P_n(I)$, for a given function representing a voltage response, $V(I)$, over a specified current interval $[I_{\\min}, I_{\\max}]$. The interpolation is to be performed at $n$ distinct points known as Chebyshev nodes. The ultimate objective is to calculate the maximum absolute calibration error, defined as the maximum value of $|V(I) - P_n(I)|$ on a fine, uniform grid of points within the interval. The solution proceeds by defining the nodes, constructing the interpolant, and then evaluating the error.\n\n### Step 1: Chebyshev Node Generation\nThe use of Chebyshev nodes is a standard technique in numerical analysis to minimize the error of polynomial interpolation, particularly to avoid the large oscillations near the ends of the interval that can occur with equally spaced nodes (the Runge phenomenon).\n\nThe $n$ Chebyshev nodes of the first kind, denoted $x_k$, on the canonical interval $[-1, 1]$ are defined as the roots of the $n$-th degree Chebyshev polynomial of the first kind, $T_n(x)$. These roots are given by the formula:\n$$\nx_k = \\cos\\left(\\frac{2k-1}{2n}\\pi\\right), \\quad \\text{for } k = 1, 2, \\ldots, n\n$$\nThese nodes are not uniformly spaced; they are denser near the endpoints of the interval, $-1$ and $1$.\n\nTo use these nodes for interpolation over an arbitrary interval $[I_{\\min}, I_{\\max}]$, we must apply a linear (affine) transformation that maps the canonical interval $[-1, 1]$ to $[I_{\\min}, I_{\\max}]$. A point $x \\in [-1, 1]$ is mapped to a point $I \\in [I_{\\min}, I_{\\max}]$ using the formula:\n$$\nI(x) = \\frac{I_{\\max} - I_{\\min}}{2} x + \\frac{I_{\\max} + I_{\\min}}{2}\n$$\nApplying this mapping to each canonical Chebyshev node $x_k$ yields the set of $n$ interpolation nodes $\\{I_k\\}_{k=1}^n$ in the target current range:\n$$\nI_k = \\frac{I_{\\max} - I_{\\min}}{2} \\cos\\left(\\frac{2k-1}{2n}\\pi\\right) + \\frac{I_{\\max} + I_{\\min}}{2}\n$$\n\n### Step 2: Lagrange Polynomial Interpolation\nGiven the $n$ distinct interpolation nodes $I_k$ and the corresponding measured voltage values $V_k = V(I_k)$, the fundamental theorem of polynomial interpolation guarantees the existence of a unique polynomial $P_n(I)$ of degree at most $n-1$ such that $P_n(I_k) = V_k$ for all $k = 1, \\ldots, n$.\n\nThis unique polynomial can be explicitly constructed using the Lagrange form, which expresses $P_n(I)$ as a linear combination of Lagrange basis polynomials $L_k(I)$:\n$$\nP_n(I) = \\sum_{k=1}^{n} V_k L_k(I)\n$$\nThe basis polynomials are defined as:\n$$\nL_k(I) = \\prod_{\\substack{j=1 \\\\ j \\neq k}}^{n} \\frac{I - I_j}{I_k - I_j}\n$$\nBy construction, each basis polynomial $L_k(I)$ has the property that it is equal to $1$ at node $I_k$ and $0$ at all other nodes $I_j$ (where $j \\neq k$), i.e., $L_k(I_j) = \\delta_{kj}$, where $\\delta_{kj}$ is the Kronecker delta. This property ensures that the interpolating polynomial $P_n(I)$ correctly passes through each data point $(I_k, V_k)$. For efficient and numerically stable computation, this polynomial is best evaluated using its barycentric form, which is an algebraic rearrangement of the Lagrange formula.\n\n### Step 3: Error Evaluation\nThe calibration error at any current $I$ is the absolute difference $|V(I) - P_n(I)|$. To find the maximum error across the entire interval, we evaluate this difference on a dense, uniform grid of $M$ points. This grid, $\\{I'_j\\}_{j=0}^{M-1}$, is defined as:\n$$\nI'_j = I_{\\min} + j \\frac{I_{\\max} - I_{\\min}}{M-1}, \\quad \\text{for } j = 0, 1, \\ldots, M-1\n$$\nThe maximum absolute calibration error, $E_{\\max}$, is then approximated by taking the maximum value over this grid:\n$$\nE_{\\max} = \\max_{j \\in \\{0, \\ldots, M-1\\}} |V(I'_j) - P_n(I'_j)|\n$$\nThis value serves as a numerical approximation to the true supremum norm of the error function, $\\|V - P_n\\|_{\\infty}$.\n\n### Step 4: Analysis of Specific Test Cases\nThe provided test cases are designed to validate the implementation against different conditions:\n- **Case 1 ($n=8$, smooth function):** This represents a typical application where Chebyshev interpolation is expected to provide a good approximation with a small but non-zero error.\n- **Case 2 ($n=1$):** With a single node $I_1 = (I_{\\min} + I_{\\max})/2$, the interpolant is a constant polynomial $P_1(I) = V(I_1)$. Its degree is $0$, satisfying the degree $\\le n-1$ condition.\n- **Case 3 ($n=20$, Runge-like function):** The function $V(I)$ is a variant of the well-known Runge function, which is problematic for interpolation with equidistant nodes. The use of $n=20$ Chebyshev nodes is expected to effectively suppress the oscillations and result in a low error, demonstrating their superiority.\n- **Case 4 ($n=4$, cubic polynomial):** The function $V(I)$ is a polynomial of degree $3$. Since we use $n=4$ nodes, the unique interpolating polynomial of degree at most $n-1=3$ must be identical to $V(I)$ itself. Consequently, the theoretical interpolation error is exactly $0$. The computed result should be a value on the order of machine floating-point precision, which rounds to $0.0$. This case serves as a critical check of the algorithm's correctness.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the maximum absolute error of a polynomial\n    interpolant constructed using Chebyshev nodes.\n    \"\"\"\n\n    # Define the true voltage functions V(I) for each case.\n    v_funcs = [\n        lambda i: np.log(1 + i) + (0.02 * i**3) / (1 + i**2) + 0.1 * np.sin(i),\n        lambda i: np.exp(0.1 * i) + 0.5 * np.cos(i),\n        lambda i: 1 / (1 + 25 * i**2) + 0.2 * i,\n        lambda i: 0.7 + 1.2 * i - 0.5 * i**2 + 0.03 * i**3\n    ]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (I_min, I_max, n, M, v_func)\n        (0.0, 10.0, 8, 10001, v_funcs[0]),\n        # Case 2\n        (0.0, 10.0, 1, 10001, v_funcs[1]),\n        # Case 3\n        (-5.0, 5.0, 20, 20001, v_funcs[2]),\n        # Case 4\n        (-2.0, 2.0, 4, 10001, v_funcs[3])\n    ]\n\n    results = []\n    for case in test_cases:\n        I_min, I_max, n, M, v_func = case\n\n        # Step 1: Generate n Chebyshev nodes of the first kind\n        # Generate canonical nodes on the interval [-1, 1]\n        k = np.arange(1, n + 1)\n        x_cheb = np.cos((2 * k - 1) * np.pi / (2 * n))\n        \n        # Linearly map the canonical nodes to the target interval [I_min, I_max]\n        # These are the interpolation nodes I_k\n        I_nodes = 0.5 * (I_max - I_min) * x_cheb + 0.5 * (I_max + I_min)\n\n        # Step 2: Sample the true function V(I) at the interpolation nodes\n        # These are the corresponding values V_k\n        V_nodes = v_func(I_nodes)\n\n        # Construct the unique polynomial interpolant P_n(I).\n        # We use scipy's BarycentricInterpolator, which is a numerically stable\n        # and efficient implementation of the Lagrange interpolating polynomial.\n        # This adheres to the \"first principles\" requirement as it is a direct\n        # representation of the Lagrange polynomial in its barycentric form.\n        interpolant = BarycentricInterpolator(I_nodes, V_nodes)\n        \n        # Step 3: Evaluate on a dense uniform grid and compute error\n        # Create the uniform evaluation grid of M points\n        I_grid = np.linspace(I_min, I_max, M)\n        \n        # Evaluate the true function V(I) on the grid\n        V_true_on_grid = v_func(I_grid)\n        \n        # Evaluate the interpolating polynomial P_n(I) on the grid\n        V_interp_on_grid = interpolant(I_grid)\n        \n        # Compute the maximum absolute calibration error\n        max_error = np.max(np.abs(V_true_on_grid - V_interp_on_grid))\n        \n        # Store the result, rounded to 8 decimal places\n        results.append(f\"{max_error:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3150109"}]}