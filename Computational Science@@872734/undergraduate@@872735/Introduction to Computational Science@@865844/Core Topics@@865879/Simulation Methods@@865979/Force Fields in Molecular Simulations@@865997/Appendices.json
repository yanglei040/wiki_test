{"hands_on_practices": [{"introduction": "A reliable force field implementation must respect the fundamental symmetries of physical law. This practice guides you through the essential process of verifying that your potential energy $U(\\mathbf{R})$ and force $\\mathbf{F}(\\mathbf{R})$ calculations are invariant under rigid translation, rotation, and the permutation of identical particles. Completing this exercise builds a critical debugging and validation skillset, ensuring your simulation engine is founded on correct physical principles [@problem_id:3131635].", "problem": "A developer is asked to validate a classical molecular force field implementation by constructing computational tests of invariance for the potential energy $U(\\mathbf{R})$ and the force field $\\mathbf{F}(\\mathbf{R}) = -\\nabla_{\\mathbf{R}} U(\\mathbf{R})$ of a system of $N$ identical particles, where $\\mathbf{R} \\in \\mathbb{R}^{N \\times 3}$ collects all particle coordinates in three-dimensional space. The system is modeled by a pairwise interaction that depends only on interparticle distances, which guarantees physical invariance of $U$ and $\\mathbf{F}$ under rigid translations, rigid rotations, and permutations of identical particles. The goal is to produce a runnable program that checks these invariance properties numerically on a defined test suite. All quantities are expressed in reduced Lennard-Jones (LJ) units, with length unit $\\sigma$, energy unit $\\epsilon$, and force unit $\\epsilon/\\sigma$, and angles are to be interpreted in radians.\n\nStarting from fundamental laws and definitions (Newton’s laws, the gradient of a scalar field, and the property that pairwise potentials depend only on interparticle distances), implement a potential energy $U(\\mathbf{R})$ and force field $\\mathbf{F}(\\mathbf{R})$ for $N$ identical particles interacting via a distance-dependent pair potential. Use the well-tested Lennard-Jones pair potential in reduced units: it depends only on distance $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$ between particles $i$ and $j$, with parameters $\\sigma = 1$ and $\\epsilon = 1$. The force must be obtained by applying the definition $\\mathbf{F}(\\mathbf{R}) = -\\nabla_{\\mathbf{R}} U(\\mathbf{R})$ to the pairwise energy function.\n\nDesign and implement numerical tests for the following invariances:\n- Translation invariance: for a translation vector $\\mathbf{t} \\in \\mathbb{R}^3$, $U(\\mathbf{R} + \\mathbf{t})$ equals $U(\\mathbf{R})$ and $\\mathbf{F}(\\mathbf{R} + \\mathbf{t})$ equals $\\mathbf{F}(\\mathbf{R})$.\n- Rotation invariance: for a proper rotation matrix $\\mathbf{Q} \\in \\mathrm{SO}(3)$ (Special Orthogonal Group, satisfying $\\mathbf{Q}^\\top \\mathbf{Q} = \\mathbf{I}$ and $\\det(\\mathbf{Q}) = 1$), $U(\\mathbf{Q}\\mathbf{R})$ equals $U(\\mathbf{R})$ and $\\mathbf{F}(\\mathbf{Q}\\mathbf{R})$ equals $\\mathbf{Q}\\mathbf{F}(\\mathbf{R})$.\n- Permutation invariance: for a permutation $\\pi$ of particle indices, $U(\\pi(\\mathbf{R}))$ equals $U(\\mathbf{R})$ and $\\mathbf{F}(\\pi(\\mathbf{R}))$ equals $\\pi(\\mathbf{F}(\\mathbf{R}))$ under reindexing.\n\nYour program must implement the following fixed test suite of parameter values, covering a general case, symmetry edge cases, and boundary-like configurations. In each case, the translation vector $\\mathbf{t}$, rotation axis $\\hat{\\mathbf{a}}$ (unit vector), rotation angle $\\theta$ (in radians), and permutation $\\pi$ are provided. The LJ parameters are fixed as $\\sigma = 1$ and $\\epsilon = 1$.\n\nTest case #1 (general scalene triangle):\n- $N = 3$,\n- $\\mathbf{R} = \\begin{bmatrix} 0 & 0 & 0 \\\\ 1.05 & 0.2 & -0.1 \\\\ -0.6 & 1.1 & 0.3 \\end{bmatrix}$,\n- $\\mathbf{t} = \\begin{bmatrix} 0.3 \\\\ -0.2 \\\\ 0.1 \\end{bmatrix}$,\n- $\\hat{\\mathbf{a}} = \\begin{bmatrix} 0.2 \\\\ 0.7 \\\\ 0.3 \\end{bmatrix}$ normalized to unit length,\n- $\\theta = 0.75$,\n- $\\pi = [2, 0, 1]$.\n\nTest case #2 (equilateral triangle at the LJ minimum distance):\n- $N = 3$,\n- Let $s = 2^{1/6}$,\n- $\\mathbf{R} = \\begin{bmatrix} 0 & 0 & 0 \\\\ s & 0 & 0 \\\\ s/2 & s\\sqrt{3}/2 & 0 \\end{bmatrix}$,\n- $\\mathbf{t} = \\begin{bmatrix} 1.0 \\\\ -1.0 \\\\ 0.5 \\end{bmatrix}$,\n- $\\hat{\\mathbf{a}} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}$,\n- $\\theta = \\pi/3$,\n- $\\pi = [1, 0, 2]$.\n\nTest case #3 (colinear along $x$-axis):\n- $N = 3$,\n- $\\mathbf{R} = \\begin{bmatrix} 0 & 0 & 0 \\\\ 1.2 & 0 & 0 \\\\ 2.7 & 0 & 0 \\end{bmatrix}$,\n- $\\mathbf{t} = \\begin{bmatrix} 0.5 \\\\ -0.1 \\\\ 0.3 \\end{bmatrix}$,\n- $\\hat{\\mathbf{a}} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}$,\n- $\\theta = \\pi$,\n- $\\pi = [0, 2, 1]$.\n\nTest case #4 (weakly interacting square of side length $5$):\n- $N = 4$,\n- $\\mathbf{R} = \\begin{bmatrix} 0 & 0 & 0 \\\\ 5 & 0 & 0 \\\\ 5 & 5 & 0 \\\\ 0 & 5 & 0 \\end{bmatrix}$,\n- $\\mathbf{t} = \\begin{bmatrix} -3 \\\\ 2 \\\\ 1 \\end{bmatrix}$,\n- $\\hat{\\mathbf{a}} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$ normalized to unit length,\n- $\\theta = 0.1$,\n- $\\pi = [2, 3, 1, 0]$.\n\nNumerical verification criteria must compare scalar energies and vector forces with absolute tolerances:\n- Energy tolerance $\\tau_U = 10^{-10}$,\n- Force tolerance $\\tau_F = 10^{-10}$, applied to the maximum absolute difference across all components.\n\nFor each test case $i$, compute six boolean results in the following order:\n- $T_i^U$: translation invariance of energy,\n- $T_i^{\\mathbf{F}}$: translation invariance of forces,\n- $R_i^U$: rotation invariance of energy,\n- $R_i^{\\mathbf{F}}$: rotation invariance of forces (comparing $\\mathbf{F}(\\mathbf{Q}\\mathbf{R})$ to $\\mathbf{Q}\\mathbf{F}(\\mathbf{R})$),\n- $P_i^U$: permutation invariance of energy,\n- $P_i^{\\mathbf{F}}$: permutation invariance of forces.\n\nYour program should produce a single line of output containing all results for test cases #1 to #4, flattened in order as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\dots]$). Since these are boolean checks, the final values must be the literal boolean values. No external input is allowed, and the program must be self-contained.\n\nAngles must be in radians. No other units need to be output because the program outputs only booleans and uses reduced Lennard-Jones units internally.", "solution": "The problem statement is a valid exercise in computational science, requiring the implementation and verification of fundamental symmetries in a classical molecular force field. It is scientifically grounded, well-posed, objective, and contains all necessary information to produce a unique, verifiable solution.\n\nThe core of the problem is to compute the potential energy $U(\\mathbf{R})$ and the corresponding force field $\\mathbf{F}(\\mathbf{R})$ for a system of $N$ identical particles interacting via a pairwise potential, and then to numerically verify their invariance properties under translation, rotation, and permutation.\n\nThe total potential energy $U(\\mathbf{R})$ of the system is the sum of pair potentials over all unique pairs of particles $(i, j)$:\n$$\nU(\\mathbf{R}) = \\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} u(r_{ij})\n$$\nwhere $\\mathbf{R} \\in \\mathbb{R}^{N \\times 3}$ is the matrix of all particle coordinates $\\mathbf{r}_i$, and $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$ is the scalar distance between particles $i$ and $j$. The problem specifies the Lennard-Jones (LJ) potential in reduced units, where the characteristic energy $\\epsilon=1$ and length $\\sigma=1$. The LJ pair potential $u(r)$ is thus:\n$$\nu(r) = 4 \\left( \\left(\\frac{1}{r}\\right)^{12} - \\left(\\frac{1}{r}\\right)^{6} \\right) = 4(r^{-12} - r^{-6})\n$$\n\nThe force $\\mathbf{F}_k$ acting on a particle $k$ is given by the negative gradient of the total potential energy with respect to its coordinates $\\mathbf{r}_k$:\n$$\n\\mathbf{F}_k(\\mathbf{R}) = -\\nabla_{\\mathbf{r}_k} U(\\mathbf{R}) = -\\nabla_{\\mathbf{r}_k} \\sum_{i<j} u(r_{ij})\n$$\nSince the gradient operator $\\nabla_{\\mathbf{r}_k}$ only acts on terms involving particle $k$, the sum reduces to pairs including $k$:\n$$\n\\mathbf{F}_k(\\mathbf{R}) = - \\sum_{j \\neq k} \\nabla_{\\mathbf{r}_k} u(r_{kj})\n$$\nUsing the chain rule, $\\nabla_{\\mathbf{r}_k} u(r_{kj}) = \\frac{du}{dr_{kj}} \\nabla_{\\mathbf{r}_k} r_{kj}$. The gradient of the distance function is $\\nabla_{\\mathbf{r}_k} r_{kj} = \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}} = \\hat{\\mathbf{r}}_{kj}$, a unit vector pointing from $j$ to $k$. The derivative of the LJ potential is $\\frac{du}{dr} = 4(-12r^{-13} - (-6)r^{-7}) = -24(2r^{-13} - r^{-7})$.\nCombining these gives the force on particle $k$:\n$$\n\\mathbf{F}_k(\\mathbf{R}) = \\sum_{j \\neq k} \\left[ - \\frac{du}{dr_{kj}} \\right] \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}} = \\sum_{j \\neq k} 24(2r_{kj}^{-13} - r_{kj}^{-7}) \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}\n$$\nThis can be computed efficiently by iterating over pairs $(i, j)$ with $i<j$, calculating the force vector $\\mathbf{f}_{ij}$ exerted on $i$ by $j$, and adding $\\mathbf{f}_{ij}$ to $\\mathbf{F}_i$ and $-\\mathbf{f}_{ij}$ to $\\mathbf{F}_j$, in accordance with Newton's third law.\n\nThe numerical tests verify the following invariances within a given tolerance:\n\n1.  **Translation Invariance**: The system is translated by a vector $\\mathbf{t}$. The new coordinates are $\\mathbf{R'} = \\mathbf{R} + \\mathbf{t}$, which means each $\\mathbf{r}_i' = \\mathbf{r}_i + \\mathbf{t}$. The interparticle distance $r_{ij}' = \\|\\mathbf{r}_i' - \\mathbf{r}_j'\\| = \\|(\\mathbf{r}_i + \\mathbf{t}) - (\\mathbf{r}_j + \\mathbf{t})\\| = \\|\\mathbf{r}_i - \\mathbf{r}_j\\| = r_{ij}$ is unchanged.\n    - Energy: Since $U$ depends only on $r_{ij}$, it must be invariant: $U(\\mathbf{R'}) = U(\\mathbf{R})$. We test if $|U(\\mathbf{R'}) - U(\\mathbf{R})| < \\tau_U$.\n    - Force: The force expression depends on $r_{ij}$ and the difference vectors $\\mathbf{r}_i - \\mathbf{r}_j$, which are also translationally invariant. Thus, the force field must be invariant: $\\mathbf{F}(\\mathbf{R'}) = \\mathbf{F}(\\mathbf{R})$. We test if $\\max|\\mathbf{F}(\\mathbf{R'}) - \\mathbf{F}(\\mathbf{R})| < \\tau_F$.\n\n2.  **Rotation Invariance**: The system is rotated by a proper rotation matrix $\\mathbf{Q} \\in \\mathrm{SO}(3)$, constructed from the provided axis $\\hat{\\mathbf{a}}$ and angle $\\theta$ via Rodrigues' rotation formula. The new coordinates are $\\mathbf{R}' = \\mathbf{Q}\\mathbf{R}$, meaning each vector coordinate is transformed as $\\mathbf{r}_i' = \\mathbf{Q}\\mathbf{r}_i$. The interparticle distance is invariant because rotations are isometries: $r_{ij}' = \\|\\mathbf{Q}\\mathbf{r}_i - \\mathbf{Q}\\mathbf{r}_j\\| = \\|\\mathbf{Q}(\\mathbf{r}_i - \\mathbf{r}_j)\\| = \\|\\mathbf{r}_i - \\mathbf{r}_j\\| = r_{ij}$.\n    - Energy: As with translation, the invariance of $r_{ij}$ implies the invariance of energy: $U(\\mathbf{Q}\\mathbf{R}) = U(\\mathbf{R})$. We test if $|U(\\mathbf{Q}\\mathbf{R}) - U(\\mathbf{R})| < \\tau_U$.\n    - Force: The force vector transforms covariantly with the rotation. The gradient operator transforms as $\\nabla_{\\mathbf{r}'} = \\mathbf{Q}\\nabla_{\\mathbf{r}}$, so the force transforms as $\\mathbf{F}_k(\\mathbf{Q}\\mathbf{R}) = -\\nabla_{\\mathbf{r}_k'} U(\\mathbf{Q}\\mathbf{R}) = -(\\mathbf{Q}\\nabla_{\\mathbf{r}_k}) U(\\mathbf{R}) = \\mathbf{Q}(-\\nabla_{\\mathbf{r}_k}U(\\mathbf{R})) = \\mathbf{Q}\\mathbf{F}_k(\\mathbf{R})$. We test the relation $\\mathbf{F}(\\mathbf{Q}\\mathbf{R}) = \\mathbf{Q}\\mathbf{F}(\\mathbf{R})$ by checking if $\\max|\\mathbf{F}(\\mathbf{Q}\\mathbf{R}) - \\mathbf{Q}\\mathbf{F}(\\mathbf{R})| < \\tau_F$.\n\n3.  **Permutation Invariance**: The labels of the identical particles are permuted according to a permutation $\\pi$. The new coordinate matrix $\\mathbf{R}' = \\pi(\\mathbf{R})$ is obtained by reordering the rows of $\\mathbf{R}$ such that the $i$-th row of $\\mathbf{R}'$ is the $\\pi(i)$-th row of $\\mathbf{R}$.\n    - Energy: The total potential energy is a sum over all pairs. Permuting the particle indices merely reorders the terms in this sum, leaving the total value unchanged. Thus, $U(\\pi(\\mathbf{R})) = U(\\mathbf{R})$. We test if $|U(\\pi(\\mathbf{R})) - U(\\mathbf{R})| < \\tau_U$.\n    - Force: The force on the \"new\" particle $i$ (which was the \"old\" particle $\\pi(i)$) is simply the force that was acting on particle $\\pi(i)$ in the original configuration. This means the force vectors are permuted in the same way as the particle coordinates: $\\mathbf{F_i}(\\pi(\\mathbf{R})) = \\mathbf{F_{\\pi(i)}}(\\mathbf{R})$. In matrix form, $\\mathbf{F}(\\pi(\\mathbf{R})) = \\pi(\\mathbf{F}(\\mathbf{R}))$. We test if $\\max|\\mathbf{F}(\\pi(\\mathbf{R})) - \\pi(\\mathbf{F}(\\mathbf{R}))| < \\tau_F$.\n\nThe implementation will proceed by defining functions to calculate $U$ and $\\mathbf{F}$ for a given $\\mathbf{R}$. Then, for each test case, it will compute the baseline values, apply each transformation, recompute the physical quantities, and compare them against the expected transformed values using the specified numerical tolerances $\\tau_U = 10^{-10}$ and $\\tau_F = 10^{-10}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\n\ndef calculate_energy_and_forces(coords: np.ndarray):\n    \"\"\"\n    Calculates the total potential energy and forces for a system of particles\n    interacting via the Lennard-Jones potential in reduced units (sigma=1, epsilon=1).\n\n    Args:\n        coords (np.ndarray): An (N, 3) array of particle coordinates.\n\n    Returns:\n        tuple[float, np.ndarray]: A tuple containing:\n            - The total potential energy (float).\n            - An (N, 3) array of the force on each particle (np.ndarray).\n    \"\"\"\n    n_particles = coords.shape[0]\n    potential_energy = 0.0\n    forces = np.zeros_like(coords)\n\n    for i in range(n_particles):\n        for j in range(i + 1, n_particles):\n            rij_vec = coords[i] - coords[j]\n            rij_sq = np.dot(rij_vec, rij_vec)\n\n            # Avoid division by zero, although test cases do not feature it.\n            if rij_sq == 0.0:\n                continue\n\n            # Calculate pairwise LJ potential and force using squared distances\n            # for efficiency.\n            # In reduced units, sigma = 1 and epsilon = 1.\n            inv_rij_sq = 1.0 / rij_sq\n            inv_rij_6 = inv_rij_sq**3\n            inv_rij_12 = inv_rij_6**2\n\n            # U_pair = 4 * (r^-12 - r^-6)\n            potential_energy += 4.0 * (inv_rij_12 - inv_rij_6)\n\n            # F_vec = -dU/dr * (rij_vec / |rij|)\n            # -dU/dr = 24 * (2*r^-13 - r^-7)\n            # F_vec = 24 * (2*r^-14 - r^-8) * rij_vec\n            # F_vec = (48*r^-14 - 24*r^-8) * rij_vec\n            # F_vec = (48*inv_rij_sq^7 - 24*inv_rij_sq^4) * rij_vec\n            # F_vec = (48*inv_rij_12 - 24*inv_rij_6) * inv_rij_sq * rij_vec\n            force_scalar_over_rij_sq = 24.0 * inv_rij_sq * (2.0 * inv_rij_12 - inv_rij_6)\n            force_vec = force_scalar_over_rij_sq * rij_vec\n\n            forces[i] += force_vec\n            forces[j] -= force_vec\n\n    return potential_energy, forces\n\ndef solve():\n    \"\"\"\n    Main function to run the force field invariance tests.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    s_tc2 = 2**(1/6)\n    test_cases = [\n        {\n            \"N\": 3,\n            \"R\": np.array([[0.0, 0.0, 0.0], [1.05, 0.2, -0.1], [-0.6, 1.1, 0.3]]),\n            \"t\": np.array([0.3, -0.2, 0.1]),\n            \"a_hat\": np.array([0.2, 0.7, 0.3]),\n            \"theta\": 0.75,\n            \"pi\": [2, 0, 1]\n        },\n        {\n            \"N\": 3,\n            \"R\": np.array([[0.0, 0.0, 0.0], [s_tc2, 0.0, 0.0], [s_tc2/2.0, s_tc2*np.sqrt(3)/2.0, 0.0]]),\n            \"t\": np.array([1.0, -1.0, 0.5]),\n            \"a_hat\": np.array([0.0, 0.0, 1.0]),\n            \"theta\": np.pi/3.0,\n            \"pi\": [1, 0, 2]\n        },\n        {\n            \"N\": 3,\n            \"R\": np.array([[0.0, 0.0, 0.0], [1.2, 0.0, 0.0], [2.7, 0.0, 0.0]]),\n            \"t\": np.array([0.5, -0.1, 0.3]),\n            \"a_hat\": np.array([0.0, 0.0, 1.0]),\n            \"theta\": np.pi,\n            \"pi\": [0, 2, 1]\n        },\n        {\n            \"N\": 4,\n            \"R\": np.array([[0.0, 0.0, 0.0], [5.0, 0.0, 0.0], [5.0, 5.0, 0.0], [0.0, 5.0, 0.0]]),\n            \"t\": np.array([-3.0, 2.0, 1.0]),\n            \"a_hat\": np.array([1.0, 1.0, 1.0]),\n            \"theta\": 0.1,\n            \"pi\": [2, 3, 1, 0]\n        }\n    ]\n\n    tol_U = 1e-10\n    tol_F = 1e-10\n    all_results = []\n\n    for case in test_cases:\n        R, t_vec, a_hat, theta, pi = case[\"R\"], case[\"t\"], case[\"a_hat\"], case[\"theta\"], case[\"pi\"]\n\n        # 1. Baseline calculation\n        U_0, F_0 = calculate_energy_and_forces(R)\n\n        # 2. Translation Invariance Test\n        R_trans = R + t_vec  # Broadcasting t_vec to each row of R\n        U_trans, F_trans = calculate_energy_and_forces(R_trans)\n        check_U_trans = np.abs(U_trans - U_0) < tol_U\n        check_F_trans = np.max(np.abs(F_trans - F_0)) < tol_F\n        all_results.extend([check_U_trans, check_F_trans])\n\n        # 3. Rotation Invariance Test\n        a_hat_norm = a_hat / np.linalg.norm(a_hat)\n        rot = Rotation.from_rotvec(theta * a_hat_norm)\n        Q = rot.as_matrix()\n        # Apply rotation to each coordinate vector (row)\n        R_rot = R @ Q.T\n        U_rot, F_rot = calculate_energy_and_forces(R_rot)\n        F_0_rot_expected = F_0 @ Q.T # Covariant transformation of force vectors\n        check_U_rot = np.abs(U_rot - U_0) < tol_U\n        check_F_rot = np.max(np.abs(F_rot - F_0_rot_expected)) < tol_F\n        all_results.extend([check_U_rot, check_F_rot])\n        \n        # 4. Permutation Invariance Test\n        R_perm = R[pi, :] # Permute rows (particles)\n        U_perm, F_perm = calculate_energy_and_forces(R_perm)\n        F_0_perm_expected = F_0[pi, :] # Permute force vectors accordingly\n        check_U_perm = np.abs(U_perm - U_0) < tol_U\n        check_F_perm = np.max(np.abs(F_perm - F_0_perm_expected)) < tol_F\n        all_results.extend([check_U_perm, check_F_perm])\n\n    # Final print statement in the exact required format.\n    # Python's str(True) -> 'True', str(False) -> 'False'\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```", "id": "3131635"}, {"introduction": "While many simulations use established force fields, computational science often involves creating novel models to study specific phenomena. This exercise challenges you to implement a custom three-body potential designed to enforce tetrahedral geometry, a key structural feature of systems like water. By building this coarse-grained model from scratch, you will gain hands-on experience in how force fields can be engineered to capture essential molecular characteristics beyond simple pairwise interactions [@problem_id:3131557].", "problem": "You will implement and analyze a coarse-grained, monatomic model of water that enforces local tetrahedrality through a three-body potential energy. The model excludes explicit two-body terms and focuses exclusively on a three-body contribution that biases the angle formed by two neighbor bonds around each particle toward the tetrahedral angle. Starting from the definition of potential energy and basic geometric relations, derive a simple, smooth, differentiable three-body energy and implement it to compare how structural arrangements and number density influence the energy per particle. All calculations should be performed in reduced units: length is unitless and measured in a reference length $\\sigma$, energy is unitless, mass is unitless, and angles are in radians. Densities must be reported as particles per $\\sigma^{-3}$.\n\nFundamental base to use:\n- Newton’s Second Law: $m \\frac{d^2 \\mathbf{r}}{dt^2} = \\mathbf{F}$, and the definition of conservative force from potential energy $U$: $\\mathbf{F} = -\\nabla U$.\n- The definition of number density: $\\rho = \\frac{N}{V}$ with $N$ particles in volume $V$.\n- The geometric definitions of distances and angles: For particles $i$, $j$, and $k$, let $\\mathbf{r}_{ij}$ be the minimum-image displacement vector under Periodic Boundary Conditions (PBC), $r_{ij} = \\|\\mathbf{r}_{ij}\\|$, and $\\theta_{jik}$ be the angle formed by $\\mathbf{r}_{ij}$ and $\\mathbf{r}_{ik}$ via the dot product relation $\\cos \\theta_{jik} = \\frac{\\mathbf{r}_{ij}\\cdot\\mathbf{r}_{ik}}{r_{ij} r_{ik}}$.\n\nTarget construction and constraints:\n- You must construct a three-body potential energy $U_3$ that sums a central-particle-based angular penalty over unordered neighbor pairs. To avoid double counting, for each central particle index $i$, sum over pairs $j < k$ with $j \\neq i$ and $k \\neq i$.\n- The three-body energy should take the form $U_3 = \\lambda \\sum_i \\sum_{j<k} f(r_{ij}, r_{ik}, \\theta_{jik})$, where $f$ factorizes into a distance weight for each bond and an angular penalty that is minimized at the tetrahedral angle.\n- Distance weights $w(r)$ must be smoothly peaked at a preferred bond length $r_0$, satisfy $w(r) \\rightarrow 0$ as $r \\rightarrow 0$ and as $r \\rightarrow \\infty$, be symmetric around $r_0$, and be continuously differentiable at all $r$.\n- The angular penalty $p(\\theta)$ must be nonnegative, twice continuously differentiable on $\\theta \\in [0,\\pi]$, and achieve its global minimum at the tetrahedral angle $\\theta_0$, where $\\cos \\theta_0 = -\\frac{1}{3}$ (that is, $\\theta_0 = \\arccos\\!\\left(-\\frac{1}{3}\\right)$).\n- Under Periodic Boundary Conditions (PBC), distances must be computed with the minimum-image convention in a rectangular box of side lengths $L_x$, $L_y$, and $L_z$. For a displacement component $\\Delta x = x_j - x_i$, the minimum-image component is $\\Delta x' = \\Delta x - L_x \\cdot \\mathrm{round}\\!\\left(\\frac{\\Delta x}{L_x}\\right)$, and similarly for $y$ and $z$.\n\nSystem construction to test how density and structure affect the three-body energy:\n- Construct three systems:\n  1. A diamond cubic lattice, which is tetrahedrally coordinated. Use the conventional cubic cell with $8$ fractional basis positions within a unit cell: $(0,0,0)$, $(0,\\frac{1}{2},\\frac{1}{2})$, $(\\frac{1}{2},0,\\frac{1}{2})$, $(\\frac{1}{2},\\frac{1}{2},0)$, $(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4})$, $(\\frac{3}{4},\\frac{3}{4},\\frac{1}{4})$, $(\\frac{3}{4},\\frac{1}{4},\\frac{3}{4})$, $(\\frac{1}{4},\\frac{3}{4},\\frac{3}{4})$. Replicate the cell $n_x \\times n_y \\times n_z$ with $(n_x, n_y, n_z) = (2,2,1)$ to obtain $N = 32$ particles. The box dimensions are $(L_x, L_y, L_z) = (n_x a, n_y a, n_z a)$, where $a$ is the lattice constant.\n  2. A simple cubic lattice. Use a one-atom basis per cell and replicate $(n_x, n_y, n_z) = (3,3,3)$ to obtain $N = 27$ particles, with box $(L_x, L_y, L_z) = (n_x a, n_y a, n_z a)$.\n  3. An edge case with $N=2$ particles to test that no triplets implies zero three-body energy. Place particles at fractional positions $(0,0,0)$ and $(\\frac{1}{2},\\frac{3}{10},\\frac{1}{10})$ inside a box of side length $a$, and apply PBC.\n\nParameter selection and test suite:\n- Use $\\lambda = 1.0$ and $r_0 = 1.0$ in reduced units.\n- Choose a smooth, twice differentiable $w(r)$ satisfying the constraints above, and a twice differentiable $p(\\theta)$ satisfying the constraints above, then implement $f(r_{ij}, r_{ik}, \\theta_{jik}) = w(r_{ij}) w(r_{ik}) p(\\theta_{jik})$.\n- Use an angular target $\\theta_0$ such that $\\cos \\theta_0 = -\\frac{1}{3}$ and angles in radians.\n- Adopt the following sets of lattice constants $a$ to scan, producing energies for each $a$ and selecting the $a$ that minimizes the energy per particle:\n  - Diamond cubic case: $a \\in \\{2.2, 2.3094011, 2.4\\}$.\n  - Simple cubic case: $a \\in \\{0.9, 1.0, 1.1\\}$.\n  - Two-particle edge case: $a \\in \\{1.0, 1.2\\}$.\n- Use a single width parameter $\\alpha = 25.0$ for the distance weight function $w(r)$.\n\nComputational tasks you must implement:\n- Build the particle coordinates for each system and $a$ as specified.\n- Under PBC with the minimum-image convention, compute the three-body potential energy $U_3$ and the energy per particle $\\frac{U_3}{N}$ for each $a$.\n- For each system, identify the lattice constant $a$ that minimizes $\\frac{U_3}{N}$ across the provided set, and compute the corresponding number density $\\rho = \\frac{N}{L_x L_y L_z}$.\n\nRequired output:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3]$), where each $result_i$ is the density $\\rho$ (in particles per $\\sigma^{-3}$) corresponding to the minimizing $a$ for the $i$-th system in the order listed above. Express densities as floats in reduced units.\n\nAngle unit requirement:\n- Use radians for all angle computations.\n\nNote on scientific realism:\n- The diamond lattice exhibits local tetrahedral coordination, so an angular penalty minimized at the tetrahedral angle should favor densities where the nearest-neighbor distance is near $r_0$. The simple cubic lattice lacks tetrahedral angles, so energy minimization will depend more on suppressing contributions through the distance weights. The two-particle case serves as a boundary condition where no three-body triplets exist and the energy is identically zero for any $a$.\n\nTest suite summary:\n- Case $1$ (diamond cubic): $N=32$, $(n_x,n_y,n_z)=(2,2,1)$, $a \\in \\{2.2, 2.3094011, 2.4\\}$, $\\lambda=1.0$, $r_0=1.0$, $\\alpha=25.0$.\n- Case $2$ (simple cubic): $N=27$, $(n_x,n_y,n_z)=(3,3,3)$, $a \\in \\{0.9, 1.0, 1.1\\}$, $\\lambda=1.0$, $r_0=1.0$, $\\alpha=25.0$.\n- Case $3$ (two particles): $N=2$, positions $(0,0,0)$ and $(\\frac{1}{2},\\frac{3}{10},\\frac{1}{10})$ scaled by $a$, $a \\in \\{1.0, 1.2\\}$, $\\lambda=1.0$, $r_0=1.0$, $\\alpha=25.0$.\n\nYour program should produce a single line of output containing the densities for cases $1$, $2$, and $3$, in that order, as a comma-separated list enclosed in square brackets.", "solution": "The user-provided problem statement has been analyzed and is deemed valid. It is scientifically grounded, well-posed, and contains sufficient information to construct a unique, verifiable solution. The task is to calculate the three-body potential energy for three different atomic systems at various densities to find the configuration of minimum energy per particle.\n\nThe core of the problem is the three-body potential energy function $U_3$, defined as:\n$$\nU_3 = \\lambda \\sum_i \\sum_{j<k, j \\neq i, k \\neq i} f(r_{ij}, r_{ik}, \\theta_{jik})\n$$\nwhere the sum is over all central particles $i$, and all unique pairs of neighbors $j$ and $k$. The function $f$ is a product of distance-dependent weights and an angular penalty:\n$$\nf(r_{ij}, r_{ik}, \\theta_{jik}) = w(r_{ij}) w(r_{ik}) p(\\theta_{jik})\n$$\nThe parameters are given as $\\lambda=1.0$ and $r_0=1.0$.\n\nFirst, we must define suitable functional forms for the distance weight $w(r)$ and the angular penalty $p(\\theta)$ that satisfy the problem's constraints.\n\nThe distance weight function $w(r)$ must be continuously differentiable, symmetric, and smoothly peaked at a preferred bond length $r_0=1.0$, and decay to $0$ for large distances. A Gaussian function is a natural and standard choice that satisfies these criteria:\n$$\nw(r) = \\exp(-\\alpha (r-r_0)^2)\n$$\nWith the given parameters $\\alpha=25.0$ and $r_0=1.0$, this function is sharply peaked at $r=1.0$ and decays rapidly for distances differing from $1.0$.\n\nThe angular penalty function $p(\\theta)$ must be non-negative, twice continuously differentiable, and have a global minimum at the tetrahedral angle $\\theta_0 = \\arccos(-1/3)$. A simple and common choice, widely used in molecular mechanics force fields, is a harmonic potential in the cosine of the angle:\n$$\np(\\theta) = (\\cos\\theta - \\cos\\theta_0)^2\n$$\nThis function is non-negative, $C^\\infty$, and its minimum value is $0$, which occurs precisely when $\\theta = \\theta_0$. We are given that $\\cos\\theta_0 = -1/3$. The angle $\\theta_{jik}$ formed by the vectors $\\mathbf{r}_{ij}$ and $\\mathbf{r}_{ik}$ is computed using the dot product:\n$$\n\\cos \\theta_{jik} = \\frac{\\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ik}}{r_{ij} r_{ik}}\n$$\nwhere $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$ is the displacement vector and $r_{ij} = \\|\\mathbf{r}_{ij}\\|$ is the distance.\n\nAll calculations are performed under Periodic Boundary Conditions (PBC) in a rectangular simulation box of dimensions $L_x, L_y, L_z$. The displacement vector components must be calculated using the minimum-image convention. For a displacement component $\\Delta x$, the minimum-image component $\\Delta x'$ is given by:\n$$\n\\Delta x' = \\Delta x - L_x \\cdot \\mathrm{round}\\!\\left(\\frac{\\Delta x}{L_x}\\right)\n$$\nand similarly for the $y$ and $z$ components.\n\nThe overall algorithm is as follows:\nFor each of the three specified systems (diamond cubic, simple cubic, two-particle):\n1.  Iterate through the provided set of lattice constants, $\\{a_k\\}$.\n2.  For each $a_k$:\n    a. Construct the particle coordinates based on the system's lattice structure, replication factors $(n_x, n_y, n_z)$, and the lattice constant $a_k$. The total number of particles is $N$.\n    b. Determine the simulation box dimensions: $L_x = n_x a_k$, $L_y = n_y a_k$, $L_z = n_z a_k$.\n    c. Calculate the total three-body energy $U_3$ by implementing the triple summation. The algorithm iterates through each particle $i$ from $0$ to $N-1$, and for each $i$, it iterates through all unique pairs of other particles $(j,k)$ with $j < k$. For each such triplet $(i,j,k)$, the vectors $\\mathbf{r}_{ij}$ and $\\mathbf{r}_{ik}$ are computed using the minimum-image convention. From these vectors, the distances $r_{ij}$, $r_{ik}$ and the angle $\\theta_{jik}$ are found, and the energy contribution $f(r_{ij}, r_{ik}, \\theta_{jik})$ is calculated and added to $U_3$.\n    d. Compute the energy per particle, $U_3/N$.\n3.  After evaluating all $a_k$ for a system, identify the value $a^*$ that results in the minimum energy per particle.\n4.  Calculate the number density $\\rho = N/V$ for the system at this optimal lattice constant $a^*$, where the volume is $V = L_x L_y L_z = (n_x a^*)(n_y a^*)(n_z a^*)$.\n5.  The final output is the list of these optimal densities for the three systems.\n\nSystem-specific details:\n- **Diamond Cubic:** $N=32$ particles are generated by replicating an $8$-atom basis cell $2 \\times 2 \\times 1$ times. The ideal tetrahedral geometry of this lattice is expected to result in a very low energy when the nearest-neighbor distance matches $r_0=1.0$. The nearest-neighbor distance in a diamond lattice is $d = a\\sqrt{3}/4$. Setting $d=r_0=1.0$ gives $a = 4/\\sqrt{3} \\approx 2.3094011$. Since this value is in the test set, it is expected to yield the minimum energy.\n- **Simple Cubic:** $N=27$ particles are generated on a $3 \\times 3 \\times 3$ grid. This lattice has principal bond angles of $90^\\circ$ and $180^\\circ$, neither of which is the tetrahedral angle. The energy will thus be a compromise between minimizing the distance-based weights (by moving away from $r_0$) and incurring the angular penalty.\n- **Two-Particle System:** With $N=2$ particles, no three-body triplets can be formed. Therefore, the three-body energy $U_3$ must be identically zero for all values of the lattice constant $a$. The problem asks for the density corresponding to the minimizing $a$. Since all tested values of $a$ yield the same minimum energy ($0$), we select the first value in the provided list, $a=1.0$, as per convention.\n\nThe implementation will use the `numpy` library for efficient vector and matrix operations, particularly for coordinate generation and the minimum-image calculation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational problem by calculating the density that minimizes\n    three-body potential energy for three different particle systems.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    LAMBDA_ = 1.0\n    R0 = 1.0\n    ALPHA = 25.0\n    COS_THETA0 = -1.0 / 3.0\n\n    # --- Helper Functions ---\n    def pbc_displacement(r1, r2, box_dims):\n        \"\"\"Calculates the minimum image displacement vector from r1 to r2.\"\"\"\n        delta = r2 - r1\n        delta = delta - box_dims * np.round(delta / box_dims)\n        return delta\n\n    def get_energy(coords, box_dims, n_particles):\n        \"\"\"\n        Calculates the total three-body potential energy of the system.\n        \"\"\"\n        if n_particles < 3:\n            return 0.0\n\n        total_energy = 0.0\n        \n        # Sum over central particle i and all unique pairs of neighbors (j, k)\n        for i in range(n_particles):\n            for j in range(n_particles):\n                for k in range(j + 1, n_particles):\n                    if i == j or i == k:\n                        continue\n                    \n                    # Calculate displacement vectors from central particle i\n                    r_ij_vec = pbc_displacement(coords[i], coords[j], box_dims)\n                    r_ik_vec = pbc_displacement(coords[i], coords[k], box_dims)\n\n                    r_ij = np.linalg.norm(r_ij_vec)\n                    r_ik = np.linalg.norm(r_ik_vec)\n\n                    # Avoid division by zero if particles are coincident\n                    if r_ij < 1e-9 or r_ik < 1e-9:\n                        continue\n\n                    # Calculate energy components\n                    w_ij = np.exp(-ALPHA * (r_ij - R0)**2)\n                    w_ik = np.exp(-ALPHA * (r_ik - R0)**2)\n                    \n                    dot_prod = np.dot(r_ij_vec, r_ik_vec)\n                    cos_theta_jik = dot_prod / (r_ij * r_ik)\n                    \n                    # Clip to handle floating point inaccuracies\n                    cos_theta_jik = np.clip(cos_theta_jik, -1.0, 1.0)\n                    \n                    p_theta = (cos_theta_jik - COS_THETA0)**2\n                    \n                    energy_term = LAMBDA_ * w_ij * w_ik * p_theta\n                    total_energy += energy_term\n        \n        return total_energy\n\n    # --- System Coordinate Generation ---\n    def generate_dc_coords(a, nx, ny, nz):\n        \"\"\"Generates coordinates for a diamond cubic lattice.\"\"\"\n        basis_frac = np.array([\n            [0.0, 0.0, 0.0], [0.0, 0.5, 0.5], [0.5, 0.0, 0.5], [0.5, 0.5, 0.0],\n            [0.25, 0.25, 0.25], [0.25, 0.75, 0.75], [0.75, 0.25, 0.75], [0.75, 0.75, 0.25]\n        ])\n        \n        coords = []\n        for i in range(nx):\n            for j in range(ny):\n                for k in range(nz):\n                    lattice_vec = np.array([i, j, k])\n                    for basis_vec in basis_frac:\n                        coords.append((basis_vec + lattice_vec) * a)\n        return np.array(coords)\n\n    def generate_sc_coords(a, nx, ny, nz):\n        \"\"\"Generates coordinates for a simple cubic lattice.\"\"\"\n        coords = []\n        for i in range(nx):\n            for j in range(ny):\n                for k in range(nz):\n                    coords.append(np.array([i, j, k]) * a)\n        return np.array(coords)\n\n    def generate_2p_coords(a, nx, ny, nz):\n        \"\"\"Generates coordinates for the two-particle system.\"\"\"\n        # nx, ny, nz are conceptually 1 for this case\n        frac_coords = np.array([[0.0, 0.0, 0.0], [0.5, 0.3, 0.1]])\n        return frac_coords * a\n\n    # --- Test Suite Configuration ---\n    test_cases = [\n        {\n            \"name\": \"Diamond Cubic\",\n            \"n_particles\": 32, \"nx\": 2, \"ny\": 2, \"nz\": 1,\n            \"a_values\": [2.2, 2.3094011, 2.4],\n            \"coord_generator\": generate_dc_coords\n        },\n        {\n            \"name\": \"Simple Cubic\",\n            \"n_particles\": 27, \"nx\": 3, \"ny\": 3, \"nz\": 3,\n            \"a_values\": [0.9, 1.0, 1.1],\n            \"coord_generator\": generate_sc_coords\n        },\n        {\n            \"name\": \"Two Particles\",\n            \"n_particles\": 2, \"nx\": 1, \"ny\": 1, \"nz\": 1,\n            \"a_values\": [1.0, 1.2],\n            \"coord_generator\": generate_2p_coords\n        }\n    ]\n\n    final_densities = []\n\n    for case in test_cases:\n        min_energy_per_particle = float('inf')\n        min_energy_a = -1.0\n\n        for a in case[\"a_values\"]:\n            nx, ny, nz = case[\"nx\"], case[\"ny\"], case[\"nz\"]\n            n_particles = case[\"n_particles\"]\n            \n            box_dims = np.array([nx * a, ny * a, nz * a])\n            coords = case[\"coord_generator\"](a, nx, ny, nz)\n            \n            total_energy = get_energy(coords, box_dims, n_particles)\n            energy_per_particle = total_energy / n_particles if n_particles > 0 else 0.0\n            \n            if energy_per_particle  min_energy_per_particle:\n                min_energy_per_particle = energy_per_particle\n                min_energy_a = a\n\n        # Calculate density for the lattice constant that minimized energy\n        nx, ny, nz = case[\"nx\"], case[\"ny\"], case[\"nz\"]\n        n_particles = case[\"n_particles\"]\n        volume = (nx * min_energy_a) * (ny * min_energy_a) * (nz * min_energy_a)\n        density = n_particles / volume if volume > 0 else 0.0\n        final_densities.append(density)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_densities))}]\")\n\nsolve()\n```", "id": "3131557"}, {"introduction": "The scientific reach of a molecular simulation is often limited by computational cost. This practice explores the crucial transition from a brute-force, $O(N^2)$ algorithm for calculating interactions to a scalable, $O(N)$ method using linked-cell lists. By analyzing the performance crossover point, you will develop an intuition for algorithmic complexity and understand why efficient neighbor-finding strategies are indispensable for simulating large-scale molecular systems [@problem_id:3131669].", "problem": "You are to study the algorithmic cost of evaluating short-ranged pairwise interactions in a simple molecular simulation by comparing a direct all-pairs method with a linked-cell neighbor enumeration method. The scientific base for this task is that typical molecular mechanics force fields are pairwise additive and truncated at a finite cutoff, so that only particle pairs separated by less than a specified cutoff distance contribute to the energy and forces. You should proceed from the following foundations:\n- Newton’s laws of motion and the definition of pairwise additive potentials imply that the total potential energy is a sum over unordered particle pairs, and by Newton’s third law each pair needs to be considered only once.\n- For short-ranged interactions with a finite cutoff $r_c$, particles beyond $r_c$ do not interact, so it is sufficient to restrict candidate pairs to those that are possibly within the cutoff.\n- The cost of these algorithms is dominated by the number of particle-pair distance comparisons, which is a physically meaningful proxy for the computational effort required to evaluate a short-ranged force field.\n\nYour program must implement both strategies and count how many candidate pair distance comparisons each strategy makes, then determine the smallest system size where the linked-cell method performs fewer comparisons than the all-pairs method, for each specified number density. All calculations are in reduced units: Lennard–Jones (LJ) reduced length $\\sigma$ with $\\sigma = 1$, and a cutoff $r_c = 2.5 \\sigma$. The system is a cubic box with periodic boundary conditions (PBC), uniformly populated with $N$ particles at number density $\\rho$, so the box length is $L = (N/\\rho)^{1/3}$.\n\nDefinitions and requirements:\n- All-pairs baseline:\n  - The all-pairs method is defined as checking every unordered pair exactly once. Its candidate distance comparison count is $C_{\\text{naive}}(N) = N(N-1)/2$.\n- Linked-cell neighbor enumeration:\n  - Use a cubic cell grid with cell edge length equal to the cutoff, that is cell size $= r_c$.\n  - Let $M = \\max(1, \\lfloor L / r_c \\rfloor)$ be the number of cells per spatial dimension, so there are $M^3$ cells in total under PBC. Each particle is assigned to one cell.\n  - The linked-cell method first bins all particles into cells (count this binning step as an additive cost of $N$), then enumerates candidate pairs by considering only pairs of particles that lie in the same cell or in one of the $26$ neighboring cells under PBC. To avoid double counting unordered pairs, use lexicographic ordering on the linearized cell indices: for a cell with linear index $i$, only form cross-cell candidate pairs with neighboring cells whose linear index is strictly greater than $i$. Within a single cell, form unordered pairs once (that is, as combinations with $ji$). The total candidate pair distance comparisons for the linked-cell method is the sum of all within-cell unordered pairs plus these cross-cell products, plus the binning overhead $N$.\n  - Use PBC in the cell indexing by wrapping cell coordinates modulo $M$.\n- Initial conditions:\n  - For each case, generate $N$ particle positions uniformly and independently in $[0, L)$ along each Cartesian axis. Use a fixed seed for reproducibility; you must reseed deterministically for each case so that results are deterministic. For example, you may use a base seed $s = 12345$ and increment it by $1$ for each case in the order specified below.\n\nYour task:\n- For each specified number density $\\rho$, and for each candidate system size $N$ in a given grid, compute:\n  - $C_{\\text{naive}}(N)$,\n  - $C_{\\text{cell}}(N,\\rho)$ as defined above (linked-cell candidate enumeration plus binning overhead),\n  and identify the smallest $N$ in the grid such that $C_{\\text{cell}}(N,\\rho)  C_{\\text{naive}}(N)$.\n- If no such $N$ exists within the grid for a given $\\rho$, report $-1$ for that $\\rho$.\n\nTest suite:\n- Use reduced units with $\\sigma = 1$ and $r_c = 2.5$.\n- Number densities $\\rho$ to test: $\\{0.01, 0.1, 0.8\\}$, in that order.\n- Candidate system sizes $N$ to test (the search grid): $[16, 32, 48, 64, 96, 128, 192, 256, 320, 384, 448, 512]$.\n- Periodic boundary conditions must be enforced in the cell indexing. Angles are not used. No physical unit conversion is required because reduced units are used.\n\nFinal output format:\n- Your program should produce a single line of output containing the crossover $N$ values as a comma-separated list of integers enclosed in square brackets, in the same order as the densities appear in the test suite. For example, the output must look like $[n_1,n_2,n_3]$ where each $n_k$ is an integer crossover $N$ or $-1$ if not found.\n\nYour program must be complete and self-contained, perform the computations as specified, and print exactly one line in the format above. No other output is permitted.", "solution": "The problem requires a comparison of the computational cost of two distinct algorithms for enumerating candidate particle pairs for short-ranged interaction calculations in a molecular simulation. The cost is quantified by the number of distance comparisons, a proxy for the computational work. The two algorithms are a direct all-pairs method and a linked-cell neighbor list method. We are tasked with finding the smallest system size $N$, from a given set of sizes, at which the linked-cell method becomes more efficient than the all-pairs method for several specified number densities $\\rho$.\n\nThe system under consideration is a cubic box of volume $V$ containing $N$ particles at a uniform number density $\\rho = N/V$. The box has side length $L = V^{1/3} = (N/\\rho)^{1/3}$. Periodic boundary conditions (PBC) are applied, meaning the box is effectively replicated infinitely in all three spatial dimensions. Interactions are truncated at a cutoff distance $r_c = 2.5$, where all lengths are in reduced units of $\\sigma=1$.\n\nFirst, we define the cost function for the all-pairs or \"naive\" method. This method considers every unique pair of particles in the system. For a system of $N$ particles, the number of unordered pairs is given by the binomial coefficient $\\binom{N}{2}$. Therefore, the cost of the naive method, $C_{\\text{naive}}$, is:\n$$\nC_{\\text{naive}}(N) = \\frac{N(N-1)}{2}\n$$\nThis cost scales as $O(N^2)$, which becomes computationally prohibitive for large systems.\n\nNext, we define the cost function for the linked-cell method, $C_{\\text{cell}}$. This method aims to reduce the computational complexity by exploiting the short-ranged nature of the interactions. It does so by spatially decomposing the domain.\n1.  The simulation box is divided into a grid of $M^3$ identical cubic cells. The side length of each cell is chosen to be equal to the interaction cutoff, $r_c$. The number of cells along each dimension, $M$, is given by $M = \\max(1, \\lfloor L/r_c \\rfloor)$. The `max(1, ...)` term handles cases where the box length $L$ is smaller than $r_c$, ensuring there is at least one cell.\n2.  Each of the $N$ particles is assigned to one of these $M^3$ cells based on its position. This binning process requires a single pass over all particles, and its computational cost is defined as being an additive term of $N$.\n3.  Candidate pairs are then enumerated by considering only pairs of particles that reside either in the same cell or in adjacent cells. By construction, any two particles separated by a distance greater than $r_c$ cannot be in the same or adjacent cells, thus correctly excluding them from consideration.\nThe total cost, $C_{\\text{cell}}$, is the sum of the binning overhead, the cost of within-cell pair enumeration, and the cost of cross-cell pair enumeration.\n$$\nC_{\\text{cell}}(N, \\rho) = N + \\sum_{k=0}^{M^3-1} \\frac{n_k(n_k-1)}{2} + \\sum_{i=0}^{M^3-1} \\sum_{\\substack{j \\in \\text{neighbors}(i) \\\\ j  i}} n_i n_j\n$$\nwhere $n_k$ is the number of particles in cell $k$. The first term is the binning overhead. The second term is the sum of all unordered pairs within each cell. The third term is the sum of pairs between particles in a cell $i$ and its neighboring cells $j$. To comply with Newton's third law and avoid double counting, each pair of cells $(i, j)$ must be considered only once. The problem specifies a robust method for this: use lexicographic ordering on the linearized cell indices. For each cell $i$, we only form pairs with its neighboring cells $j$ for which the linear index $j$ is strictly greater than $i$. This ensures that the pair $(i, j)$ is counted, but $(j, i)$ is not. Periodic boundary conditions are handled by applying modulo $M$ arithmetic when determining the indices of neighboring cells.\n\nFor each specified density $\\rho \\in \\{0.01, 0.1, 0.8\\}$, the procedure is as follows:\n1.  A deterministic seed, unique to each $\\rho$, is used to initialize the random number generator. The base seed is $12345$, incremented by one for each subsequent density.\n2.  For each candidate system size $N$ in the grid $[16, 32, ..., 512]$, $N$ particle positions are generated uniformly within the box $[0, L)^3$.\n3.  The costs $C_{\\text{naive}}(N)$ and $C_{\\text{cell}}(N, \\rho)$ are computed based on this specific particle configuration.\n4.  The condition $C_{\\text{cell}}(N, \\rho)  C_{\\text{naive}}(N)$ is checked. The smallest value of $N$ from the grid that satisfies this inequality is identified as the crossover point for that density.\n5.  If no $N$ in the grid satisfies the condition, a value of $-1$ is reported for that density.\n\nThe following program systematically implements this procedure. For each $(\\rho, N)$ pair, it simulates the particle binning and calculates the two cost functions as defined, then identifies and reports the crossover points.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the crossover system size N where the linked-cell method becomes\n    more efficient than the all-pairs method for given densities.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_suite = {\n        'rc': 2.5,\n        'densities': [0.01, 0.1, 0.8],\n        'N_grid': [16, 32, 48, 64, 96, 128, 192, 256, 320, 384, 448, 512],\n        'base_seed': 12345,\n    }\n\n    rc = test_suite['rc']\n    densities = test_suite['densities']\n    N_grid = test_suite['N_grid']\n    base_seed = test_suite['base_seed']\n\n    crossover_results = []\n    \n    current_seed = base_seed\n    \n    for rho in densities:\n        crossover_N = -1\n        found_crossover = False\n        \n        for N in N_grid:\n            # Step 1: Calculate system parameters\n            L = (N / rho)**(1.0/3.0)\n            M = max(1, int(np.floor(L / rc)))\n            \n            # Step 2: Generate particle positions deterministically\n            np.random.seed(current_seed)\n            positions = np.random.uniform(0.0, L, size=(N, 3))\n            \n            # Step 3: Bin particles into cells\n            # Calculate 3D cell indices for each particle\n            cell_coords = np.floor(positions / rc).astype(int)\n            # Clip coordinates to be within [0, M-1] just in case of float precision issues at L\n            cell_coords = np.clip(cell_coords, 0, M - 1)\n            \n            # Convert 3D cell coordinates to 1D linear indices\n            linear_indices = cell_coords[:, 0] + cell_coords[:, 1] * M + cell_coords[:, 2] * M * M\n            \n            # Count number of particles in each cell\n            particle_counts = np.bincount(linear_indices, minlength=M**3)\n\n            # Step 4: Calculate C_cell\n            # Cost starts with the N operations for binning particles\n            C_cell = N\n            \n            # Add cost of within-cell pairs: n*(n-1)/2\n            C_cell += np.sum(particle_counts * (particle_counts - 1) // 2)\n\n            # Add cost of cross-cell pairs using the j  i rule\n            for i in range(M**3):\n                n_i = particle_counts[i]\n                if n_i == 0:\n                    continue\n                \n                # De-linearize index i to get its 3D coordinates (ix, iy, iz)\n                iz = i // (M * M)\n                iy = (i % (M * M)) // M\n                ix = i % M\n                \n                # Iterate through the 26 neighbor cell offsets\n                for dz in range(-1, 2):\n                    for dy in range(-1, 2):\n                        for dx in range(-1, 2):\n                            if dx == 0 and dy == 0 and dz == 0:\n                                continue\n\n                            # Apply periodic boundary conditions to get neighbor coordinates\n                            nx = (ix + dx) % M\n                            ny = (iy + dy) % M\n                            nz = (iz + dz) % M\n                            \n                            # Linearize neighbor index j\n                            j = nx + ny * M + nz * M * M\n                            \n                            # Apply the rule to avoid double counting\n                            if j  i:\n                                n_j = particle_counts[j]\n                                C_cell += n_i * n_j\n            \n            # Step 5: Calculate C_naive\n            C_naive = N * (N - 1) // 2\n            \n            # Step 6: Check for crossover\n            if not found_crossover and C_cell  C_naive:\n                crossover_N = N\n                found_crossover = True\n        \n        crossover_results.append(crossover_N)\n        current_seed += 1\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, crossover_results))}]\")\n\nsolve()\n```", "id": "3131669"}]}