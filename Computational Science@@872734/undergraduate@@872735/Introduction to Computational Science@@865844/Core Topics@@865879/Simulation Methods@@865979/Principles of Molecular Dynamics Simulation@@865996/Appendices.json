{"hands_on_practices": [{"introduction": "A cornerstone of any molecular dynamics simulation is the correct calculation of distances between particles within a periodic system. This hands-on practice guides you through the implementation of the Minimum Image Convention (MIC), a universal method applicable even to complex, non-orthogonal (triclinic) simulation cells. Mastering this geometric algorithm [@problem_id:3177576] is the first step toward building a robust simulation engine, ensuring that forces are computed between the closest periodic images of particles.", "problem": "Consider a periodic molecular dynamics simulation cell represented by a cell matrix $\\,\\mathbf{h}\\,$, which maps fractional coordinates $\\,\\mathbf{s}\\in[0,1)^3\\,$ to Cartesian coordinates $\\,\\mathbf{r}=\\mathbf{h}\\,\\mathbf{s}\\,$. Under Periodic Boundary Conditions (PBC), particles are replicated at lattice translations $\\,\\mathbf{h}\\,\\mathbf{n}\\,$ for integer triplets $\\,\\mathbf{n}\\in\\mathbb{Z}^3\\,$. The Minimum Image Convention (MIC) stipulates that when computing pairwise distances, one must choose the lattice translation that yields the shortest Euclidean separation. In a triclinic cell, this can be performed by transforming Cartesian displacements to fractional space using the inverse cell matrix $\\,\\mathbf{h}^{-1}\\,$, centering the fractional displacement into the range $\\,[-\\tfrac{1}{2},\\tfrac{1}{2})\\,$, and transforming back to Cartesian space via $\\,\\mathbf{h}\\,$. Your task is to implement a program that, for multiple test cases, constructs neighbor lists using this MIC and verifies them against specified expected lists.\n\nStarting from the fundamental base:\n- Newton’s Second Law relates forces to particle motion, but here we focus on geometric computation under PBC.\n- The definition of periodicity $\\,\\mathbf{r}\\sim\\mathbf{r}+\\mathbf{h}\\,\\mathbf{n}\\,$ and Euclidean norm $\\,\\|\\cdot\\|\\,$ are the foundational facts.\n- Fractional wrapping to $\\,[-\\tfrac{1}{2},\\tfrac{1}{2})\\,$ is the central operation ensuring minimum image selection.\n\nDefinitions and requirements:\n- A neighbor list for particle $\\,i\\,$ consists of all particle indices $\\,j\\neq i\\,$ such that the MIC distance $\\,d_{ij}\\,$ satisfies $\\,d_{ij}\\le r_c\\,$, where $\\,r_c\\,$ is the cutoff.\n- Distances and positions are in dimensionless reduced units; no physical units are required.\n- Angles are not used; no angle unit is required.\n- For each test case, compute the neighbor list for every particle and compare it to the expected list; the test result is a boolean indicating exact match for all particles.\n\nAlgorithmic outline to be implemented:\n- For each unordered pair $\\,i<j\\,$, compute the Cartesian displacement $\\,\\Delta\\mathbf{r}=\\mathbf{r}_j-\\mathbf{r}_i\\,$.\n- Transform to fractional displacement $\\,\\Delta\\mathbf{s}=\\mathbf{h}^{-1}\\,\\Delta\\mathbf{r}\\,$.\n- Center $\\,\\Delta\\mathbf{s}\\,$ component-wise into $\\,[-\\tfrac{1}{2},\\tfrac{1}{2})\\,$.\n- Transform back $\\,\\Delta\\mathbf{r}_{\\text{MIC}}=\\mathbf{h}\\,\\Delta\\mathbf{s}\\,$ and compute $\\,d_{ij}=\\|\\Delta\\mathbf{r}_{\\text{MIC}}\\|\\,$.\n- If $\\,d_{ij}\\le r_c\\,$, add $\\,j\\,$ to the neighbor list of $\\,i\\,$ and $\\,i\\,$ to the neighbor list of $\\,j\\,$.\n\nTest suite:\n- Test Case $\\,1\\,$ (orthorhombic, boundary wrap along one axis):\n  - Cell matrix $\\,\\mathbf{h}=\\mathrm{diag}(10,10,10)\\,$.\n  - Cartesian positions: $\\,\\mathbf{r}_0=(1,1,1)\\,$, $\\,\\mathbf{r}_1=(9,1,1)\\,$, $\\,\\mathbf{r}_2=(5,5,5)\\,$.\n  - Cutoff $\\,r_c=2.1\\,$.\n  - Expected neighbor lists: particle $\\,0\\to[1]\\,$, particle $\\,1\\to[0]\\,$, particle $\\,2\\to[]\\,$.\n\n- Test Case $\\,2\\,$ (triclinic shear, neighbors via off-diagonal coupling):\n  - Cell matrix columns $\\,\\mathbf{a}=(10,0,0)\\,$, $\\,\\mathbf{b}=(3,10,0)\\,$, $\\,\\mathbf{c}=(0,0,10)\\,$, so\n    $$\\mathbf{h}=\\begin{bmatrix}10&3&0\\\\0&10&0\\\\0&0&10\\end{bmatrix}.$$\n  - Fractional positions: $\\,\\mathbf{s}_0=(0.1,0.1,0.1)\\,$, $\\,\\mathbf{s}_1=(0.9,0.1,0.1)\\,$, $\\,\\mathbf{s}_2=(0.1,0.9,0.1)\\,$, with Cartesian positions $\\,\\mathbf{r}_i=\\mathbf{h}\\,\\mathbf{s}_i\\,$.\n  - Cutoff $\\,r_c=2.1\\,$.\n  - Expected neighbor lists: particle $\\,0\\to[1,2]\\,$, particle $\\,1\\to[0]\\,$, particle $\\,2\\to[0]\\,$.\n\n- Test Case $\\,3\\,$ (exact half-box separation, inclusion at equality):\n  - Cell matrix $\\,\\mathbf{h}=\\mathrm{diag}(10,10,10)\\,$.\n  - Fractional positions: $\\,\\mathbf{s}_3=(0.49,0.5,0.5)\\,$, $\\,\\mathbf{s}_4=(0.99,0.5,0.5)\\,$, with Cartesian positions $\\,\\mathbf{r}_i=\\mathbf{h}\\,\\mathbf{s}_i\\,$.\n  - Cutoff $\\,r_c=5.0\\,$.\n  - Expected neighbor lists: particle $\\,0\\to[1]\\,$, particle $\\,1\\to[0]\\,$.\n\n- Test Case $\\,4\\,$ (stronger shear reduces neighbor connectivity):\n  - Cell matrix columns $\\,\\mathbf{a}=(10,0,0)\\,$, $\\,\\mathbf{b}=(5,10,0)\\,$, $\\,\\mathbf{c}=(0,0,10)\\,$, so\n    $$\\mathbf{h}=\\begin{bmatrix}10&5&0\\\\0&10&0\\\\0&0&10\\end{bmatrix}.$$\n  - Fractional positions: $\\,\\mathbf{s}_0=(0.1,0.1,0.1)\\,$, $\\,\\mathbf{s}_1=(0.9,0.1,0.1)\\,$, $\\,\\mathbf{s}_2=(0.1,0.9,0.1)\\,$, with Cartesian positions $\\,\\mathbf{r}_i=\\mathbf{h}\\,\\mathbf{s}_i\\,$.\n  - Cutoff $\\,r_c=2.1\\,$.\n  - Expected neighbor lists: particle $\\,0\\to[1]\\,$, particle $\\,1\\to[0]\\,$, particle $\\,2\\to[]\\,$.\n\n- Test Case $\\,5\\,$ (triple-axis wrap in an orthorhombic cell):\n  - Cell matrix $\\,\\mathbf{h}=\\mathrm{diag}(10,10,10)\\,$.\n  - Cartesian positions: $\\,\\mathbf{r}_0=(9.7,9.7,9.7)\\,$, $\\,\\mathbf{r}_1=(0.3,0.3,0.3)\\,$.\n  - Cutoff $\\,r_c=1.2\\,$.\n  - Expected neighbor lists: particle $\\,0\\to[1]\\,$, particle $\\,1\\to[0]\\,$.\n\nYour program must:\n- Implement neighbor list construction using the Minimum Image Convention (MIC) as described.\n- For each test case, compare the computed neighbor lists to the expected neighbor lists and record a boolean result that is $\\,\\text{True}\\,$ if and only if all particles’ lists exactly match the expected lists.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $\\,\\texttt{[True,False,True,False,True]}\\,$, one boolean per test case in the order listed above.", "solution": "The problem is valid as it presents a well-defined computational task grounded in the fundamental principles of molecular dynamics simulations, specifically the application of the Minimum Image Convention (MIC) under Periodic Boundary Conditions (PBC) for a general triclinic cell. The provided algorithm is standard, and the test cases are scientifically sound and verifiable. The minor notational inconsistency in Test Case 3's particle indexing is interpreted as a typographical error that does not impede a rigorous solution.\n\nThe solution will be constructed based on the following principles and algorithmic steps.\n\n**Fundamental Principles**\n\n1.  **Periodic Space**: A simulation cell is defined by a $3 \\times 3$ matrix $\\mathbf{h}$, whose columns are the lattice vectors $[\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3]$. The space is periodic, meaning a particle at Cartesian position $\\mathbf{r}$ has periodic images at all locations $\\mathbf{r} + \\mathbf{h}\\mathbf{n}$ for any integer vector $\\mathbf{n} \\in \\mathbb{Z}^3$.\n\n2.  **Fractional Coordinates**: The geometry of the periodic cell is most naturally described using fractional coordinates $\\mathbf{s} \\in [0, 1)^3$. A position $\\mathbf{s}$ is mapped to its Cartesian equivalent $\\mathbf{r}$ via the linear transformation $\\mathbf{r} = \\mathbf{h}\\mathbf{s}$. The inverse transformation is $\\mathbf{s} = \\mathbf{h}^{-1}\\mathbf{r}$.\n\n3.  **Minimum Image Convention (MIC)**: The distance between two particles $i$ and $j$ is the minimum Euclidean distance among all periodic images of one particle relative to the other. This distance is given by $d_{ij} = \\min_{\\mathbf{n} \\in \\mathbb{Z}^3} \\| (\\mathbf{r}_j + \\mathbf{h}\\mathbf{n}) - \\mathbf{r}_i \\|$.\n\n**Algorithmic Implementation**\n\nThe MIC distance is computed efficiently by transforming the displacement vector into fractional coordinates and wrapping it into the central periodic image, which is the Wigner-Seitz cell of the lattice. For a general triclinic cell, this is simplified by wrapping each fractional component into the range $[-\\frac{1}{2}, \\frac{1}{2})$.\n\nThe algorithm proceeds as follows for each pair of particles $(i, j)$:\n\n1.  **Cartesian Displacement**: Compute the \"naive\" displacement vector in Cartesian coordinates, $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$.\n\n2.  **Fractional Displacement**: Convert this displacement to fractional coordinates using the inverse cell matrix: $\\Delta\\mathbf{s} = \\mathbf{h}^{-1}\\Delta\\mathbf{r}$.\n\n3.  **Wrapping**: Center the fractional displacement vector. Each component $\\Delta s_k$ of $\\Delta\\mathbf{s}$ is mapped to the interval $[-\\frac{1}{2}, \\frac{1}{2})$ using the operation $\\Delta s'_k = \\Delta s_k - \\lfloor \\Delta s_k + \\frac{1}{2} \\rfloor$. This wrapping operation correctly selects the nearest periodic image.\n\n4.  **Minimum Image Displacement**: Transform the wrapped fractional displacement $\\Delta\\mathbf{s}'$ back to Cartesian coordinates to obtain the minimum image displacement vector: $\\Delta\\mathbf{r}_{\\text{MIC}} = \\mathbf{h}\\Delta\\mathbf{s}'$.\n\n5.  **Distance Calculation**: The MIC distance is the Euclidean norm $d_{ij} = \\|\\Delta\\mathbf{r}_{\\text{MIC}}\\|$. For efficiency, we compute the squared distance $d_{ij}^2 = \\Delta\\mathbf{r}_{\\text{MIC}} \\cdot \\Delta\\mathbf{r}_{\\text{MIC}}$ and compare it to the squared cutoff distance $r_c^2$.\n\n6.  **Neighbor List Construction**: If $d_{ij}^2 \\le r_c^2$, particle $j$ is added to the neighbor list of particle $i$, and particle $i$ is added to the neighbor list of particle $j$.\n\nThis algorithm will be systematically applied to each test case. The particle positions are first ensured to be in Cartesian coordinates. For test cases where fractional coordinates are given, they are converted using $\\mathbf{r}_i = \\mathbf{h}\\mathbf{s}_i$. The computed neighbor lists for all particles are then compared to the expected lists. The result for a test case is `True` if and only if all computed lists exactly match the expected lists (after ensuring a canonical ordering, such as sorting). The final output aggregates the boolean results from all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the neighbor list construction problem for all specified test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: orthorhombic, boundary wrap along one axis\n        {\n            \"h\": np.diag([10.0, 10.0, 10.0]),\n            \"positions\": np.array([\n                [1.0, 1.0, 1.0], \n                [9.0, 1.0, 1.0], \n                [5.0, 5.0, 5.0]\n            ]),\n            \"pos_type\": 'cartesian',\n            \"rc\": 2.1,\n            \"expected\": {0: [1], 1: [0], 2: []}\n        },\n        # Test Case 2: triclinic shear, neighbors via off-diagonal coupling\n        {\n            \"h\": np.array([\n                [10.0, 3.0, 0.0], \n                [0.0, 10.0, 0.0], \n                [0.0, 0.0, 10.0]\n            ]),\n            \"positions\": np.array([\n                [0.1, 0.1, 0.1], \n                [0.9, 0.1, 0.1], \n                [0.1, 0.9, 0.1]\n            ]),\n            \"pos_type\": 'fractional',\n            \"rc\": 2.1,\n            \"expected\": {0: [1, 2], 1: [0], 2: [0]}\n        },\n        # Test Case 3: exact half-box separation, inclusion at equality\n        {\n            \"h\": np.diag([10.0, 10.0, 10.0]),\n            \"positions\": np.array([\n                [0.49, 0.5, 0.5], \n                [0.99, 0.5, 0.5]\n            ]), # Indices s_3, s_4 are typos for 0, 1\n            \"pos_type\": 'fractional',\n            \"rc\": 5.0,\n            \"expected\": {0: [1], 1: [0]}\n        },\n        # Test Case 4: stronger shear reduces neighbor connectivity\n        {\n            \"h\": np.array([\n                [10.0, 5.0, 0.0], \n                [0.0, 10.0, 0.0], \n                [0.0, 0.0, 10.0]\n            ]),\n            \"positions\": np.array([\n                [0.1, 0.1, 0.1], \n                [0.9, 0.1, 0.1], \n                [0.1, 0.9, 0.1]\n            ]),\n            \"pos_type\": 'fractional',\n            \"rc\": 2.1,\n            \"expected\": {0: [1], 1: [0], 2: []}\n        },\n        # Test Case 5: triple-axis wrap in an orthorhombic cell\n        {\n            \"h\": np.diag([10.0, 10.0, 10.0]),\n            \"positions\": np.array([\n                [9.7, 9.7, 9.7], \n                [0.3, 0.3, 0.3]\n            ]),\n            \"pos_type\": 'cartesian',\n            \"rc\": 1.2,\n            \"expected\": {0: [1], 1: [0]}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        computed_lists = compute_neighbor_lists(\n            case[\"h\"], case[\"positions\"], case[\"rc\"], case[\"pos_type\"]\n        )\n        \n        # Verify the computed lists against the expected lists.\n        # Ensure expected lists are sorted for consistent comparison.\n        expected_lists = {p: sorted(n) for p, n in case[\"expected\"].items()}\n        \n        results.append(computed_lists == expected_lists)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_neighbor_lists(h, positions, rc, pos_type='cartesian'):\n    \"\"\"\n    Computes neighbor lists using the Minimum Image Convention.\n\n    Args:\n        h (np.ndarray): 3x3 cell matrix.\n        positions (np.ndarray): Nx3 array of particle positions.\n        rc (float): Cutoff distance.\n        pos_type (str): 'cartesian' or 'fractional'.\n\n    Returns:\n        dict: A dictionary where keys are particle indices and values are\n              sorted lists of their neighbors.\n    \"\"\"\n    if pos_type == 'fractional':\n        # Convert fractional coordinates to Cartesian\n        cart_pos = positions @ h.T\n    else:\n        cart_pos = positions\n\n    num_particles = cart_pos.shape[0]\n    h_inv = np.linalg.inv(h)\n    rc_sq = rc**2\n\n    neighbor_lists = {i: [] for i in range(num_particles)}\n\n    # Iterate over all unique pairs of particles (i, j) where i  j\n    for i in range(num_particles):\n        for j in range(i + 1, num_particles):\n            # 1. Compute Cartesian displacement\n            delta_r = cart_pos[j] - cart_pos[i]\n\n            # 2. Transform to fractional displacement\n            delta_s = delta_r @ h_inv.T\n            \n            # 3. Center fractional displacement into [-0.5, 0.5)\n            # This is equivalent to delta_s - round(delta_s) for the specified interval.\n            # A more robust implementation handles the 0.5 boundary case correctly.\n            delta_s_wrapped = delta_s - np.floor(delta_s + 0.5)\n\n            # 4. Transform back to Cartesian minimum image vector\n            delta_r_mic = delta_s_wrapped @ h.T\n\n            # 5. Compute squared distance and check against cutoff\n            dist_sq = np.dot(delta_r_mic, delta_r_mic)\n\n            if dist_sq = rc_sq:\n                neighbor_lists[i].append(j)\n                neighbor_lists[j].append(i)\n    \n    # Sort lists for canonical representation\n    for i in range(num_particles):\n        neighbor_lists[i].sort()\n        \n    return neighbor_lists\n\nsolve()\n```", "id": "3177576"}, {"introduction": "While correctly calculating distances is essential, doing so efficiently is paramount for practical simulations. This exercise [@problem_id:3177610] moves from geometry to optimization, tackling the challenge of the neighbor list—a key algorithm for reducing computational cost. You will develop and apply a simplified physical model to determine the optimal frequency for rebuilding neighbor lists, balancing the need for accuracy against the cost of computation.", "problem": "You are tasked with designing a simple, principled optimizer for the neighbor list rebuild period in a molecular dynamics simulation. Use reduced Lennard-Jones units where Boltzmann’s constant is $k_{B}=1$, particle mass is $m$, Lennard-Jones length and energy scales are $\\sigma=1$ and $\\epsilon=1$, respectively, and time is measured in units of $\\sqrt{m \\sigma^{2} / \\epsilon}$. Consider a three-dimensional system with uniform number density $\\rho$ and a spherical cutoff radius $r_{c}$ and neighbor list skin $r_{\\mathrm{skin}}$. Your goal is to compute, for each test case, an optimal integer rebuild period $n_{\\mathrm{steps}}$ that minimizes amortized rebuild cost while keeping an estimate of the average per-particle force error below a specified tolerance.\n\nBase your derivation on the following fundamental laws and well-tested formulas only:\n- Newton’s laws of motion and the definition of velocity as $v = dx/dt$.\n- The root-mean-square (RMS) speed from the equipartition theorem in reduced units, $v_{\\mathrm{rms}} = \\sqrt{3 k_{B} T / m} = \\sqrt{3 T / m}$ for temperature $T$ and mass $m$.\n- For two uncorrelated particles, approximate the RMS relative speed by $v_{\\mathrm{rel,rms}} = \\sqrt{2}\\, v_{\\mathrm{rms}}$.\n- For the Lennard-Jones (LJ) pair potential $U(r) = 4 \\epsilon \\left[ (\\sigma/r)^{12} - (\\sigma/r)^{6} \\right]$, the pair force magnitude at separation $r$ is $|F_{\\mathrm{LJ}}(r)| = \\left| \\frac{dU}{dr} \\right| = \\left| 24 \\epsilon \\left( 2 \\frac{\\sigma^{12}}{r^{13}} - \\frac{\\sigma^{6}}{r^{7}} \\right) \\right|$. In reduced units with $\\epsilon=\\sigma=1$, this simplifies to $|F_{\\mathrm{LJ}}(r)| = \\left| 24 \\left( \\frac{2}{r^{13}} - \\frac{1}{r^{7}} \\right) \\right|$.\n\nUse the following modeling assumptions to link physics to computation in a scientifically plausible way:\n- Over $n$ steps of size $\\Delta t$, approximate the RMS relative displacement by $\\Delta r_{\\mathrm{rel}} \\approx v_{\\mathrm{rel,rms}} \\, n \\, \\Delta t$.\n- A neighbor list with skin $r_{\\mathrm{skin}}$ reduces missed interactions if $\\Delta r_{\\mathrm{rel}} \\le r_{\\mathrm{skin}}$; if $\\Delta r_{\\mathrm{rel}}  r_{\\mathrm{skin}}$, define an excess approach distance $e = \\max(0, \\Delta r_{\\mathrm{rel}} - r_{\\mathrm{skin}})$.\n- For a uniform fluid, the expected number of pairs that can cross into the cutoff sphere during the rebuild period scales with the shell thickness $e$ at the cutoff. Approximate the expected number of missed neighbors per particle by $N_{\\mathrm{miss}} \\approx \\rho \\, 4 \\pi r_{c}^{2} \\, e$.\n- Approximate the average per-particle force error by $E_{f}(n) \\approx N_{\\mathrm{miss}} \\, |F_{\\mathrm{LJ}}(r_{c})| = \\rho \\, 4 \\pi r_{c}^{2} \\, e \\, |F_{\\mathrm{LJ}}(r_{c})|$.\n- Impose the constraint $E_{f}(n) \\le \\varepsilon_{f}$ for a given tolerance $\\varepsilon_{f}$. This gives a permissible excess $e_{\\max} = \\varepsilon_{f} / \\left( \\rho \\, 4 \\pi r_{c}^{2} \\, |F_{\\mathrm{LJ}}(r_{c})| \\right)$, and therefore the bound $\\Delta r_{\\mathrm{rel}} \\le r_{\\mathrm{skin}} + e_{\\max}$.\n- For computational cost, model the amortized rebuild cost per step as $C_{\\mathrm{step}}(n) = C_{\\mathrm{pair}}(\\rho, r_{c}, r_{\\mathrm{skin}}) + C_{\\mathrm{rebuild}}/n$, where $C_{\\mathrm{rebuild}}$ is a positive constant rebuild cost and $C_{\\mathrm{pair}}(\\cdot)$ is independent of $n$. Since $C_{\\mathrm{rebuild}}/n$ is monotonically decreasing in $n$ for fixed parameters, the cost-optimal choice under the force-error constraint is the largest $n$ that satisfies the error bound.\n- Enforce a practical engineering cap $n_{\\mathrm{cap}}$ so that $n_{\\mathrm{steps}} \\le n_{\\mathrm{cap}}$, and also $n_{\\mathrm{steps}} \\ge 1$.\n\nYour program must therefore compute, for each test case, the following:\n- Compute $v_{\\mathrm{rms}} = \\sqrt{3 T / m}$, then $v_{\\mathrm{rel,rms}} = \\sqrt{2} \\, v_{\\mathrm{rms}}$.\n- Compute $|F_{\\mathrm{LJ}}(r_{c})| = \\left| 24 \\left( 2/r_{c}^{13} - 1/r_{c}^{7} \\right) \\right|$ in reduced units.\n- Compute $e_{\\max} = \\varepsilon_{f} / \\left( \\rho \\, 4 \\pi r_{c}^{2} \\, |F_{\\mathrm{LJ}}(r_{c})| \\right)$, with the convention that if $|F_{\\mathrm{LJ}}(r_{c})| = 0$, then $e_{\\max}$ is effectively unbounded.\n- Compute the error-constrained bound $n_{\\max} = \\left\\lfloor \\dfrac{r_{\\mathrm{skin}} + e_{\\max}}{v_{\\mathrm{rel,rms}} \\, \\Delta t} \\right\\rfloor$, with the convention that if $v_{\\mathrm{rel,rms}} \\, \\Delta t = 0$, treat $n_{\\max}$ as unbounded.\n- Output $n_{\\mathrm{steps}} = \\max\\left( 1, \\min\\left( n_{\\max}, n_{\\mathrm{cap}} \\right) \\right)$.\n\nAll quantities in this problem are defined in reduced Lennard-Jones units. The final output is unitless because it is an integer number of steps.\n\nTest suite. For each tuple $(\\rho, T, m, \\Delta t, r_{c}, r_{\\mathrm{skin}}, \\varepsilon_{f}, n_{\\mathrm{cap}})$, compute $n_{\\mathrm{steps}}$:\n- Case $1$: $(\\rho, T, m, \\Delta t, r_{c}, r_{\\mathrm{skin}}, \\varepsilon_{f}, n_{\\mathrm{cap}}) = (\\, 0.8, \\, 1.0, \\, 1.0, \\, 0.005, \\, 2.5, \\, 0.3, \\, 0.05, \\, 100 \\,)$.\n- Case $2$: $(\\, 0.8, \\, 1.0, \\, 1.0, \\, 0.005, \\, 2.5, \\, 0.05, \\, 0.05, \\, 100 \\,)$.\n- Case $3$: $(\\, 0.8, \\, 0.2, \\, 1.0, \\, 0.005, \\, 2.5, \\, 0.3, \\, 0.05, \\, 100 \\,)$.\n- Case $4$: $(\\, 0.8, \\, 1.0, \\, 1.0, \\, 0.005, \\, 2.5, \\, 0.3, \\, 0.0, \\, 100 \\,)$.\n- Case $5$: $(\\, 0.8, \\, 0.05, \\, 1.0, \\, 0.005, \\, 2.5, \\, 0.3, \\, 0.5, \\, 100 \\,)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3}]$). For this problem, output $[n_{1},n_{2},n_{3},n_{4},n_{5}]$ with each $n_{i}$ computed as above.", "solution": "The problem presented is a valid exercise in computational science, specifically in the optimization of molecular dynamics (MD) simulations. It outlines a principled, albeit simplified, model to determine the optimal frequency for rebuilding neighbor lists. The model balances the computational cost of rebuilding against the numerical error incurred by using a stale list. All physical assumptions and mathematical formulas provided are standard or are reasonable approximations within the context of introductory MD. The problem is self-contained, well-posed, and scientifically grounded. We shall now proceed with a systematic derivation of the solution based on the provided framework.\n\nThe objective is to find an optimal integer rebuild period, denoted $n_{\\mathrm{steps}}$, for a neighbor list in a three-dimensional system of particles interacting via a Lennard-Jones potential. The system is characterized by a number density $\\rho$, temperature $T$, and particle mass $m$. The simulation uses a time step $\\Delta t$. The neighbor list is constructed using a cutoff radius $r_c$ and a buffer region or \"skin\" of thickness $r_{\\mathrm{skin}}$. The optimization must satisfy a constraint on the average per-particle force error, which must not exceed a tolerance $\\varepsilon_f$, while also adhering to a maximum practical rebuild period $n_{\\mathrm{cap}}$. All quantities are given in reduced Lennard-Jones units, where the energy scale is $\\epsilon=1$, the length scale is $\\sigma=1$, and Boltzmann’s constant is $k_B=1$.\n\nThe derivation proceeds in three main stages: first, we model the physical process leading to force errors; second, we formalize the error constraint; and third, we solve for the optimal number of steps that satisfies this constraint while minimizing computational cost.\n\n**1. Modeling Particle Displacement and Force Error**\n\nThe primary source of error when using a fixed neighbor list is the motion of particles. A particle initially outside the neighbor list radius, $r_c + r_{\\mathrm{skin}}$, may move to within the interaction cutoff $r_c$ during the $n_{\\mathrm{steps}}$ between rebuilds. Such an event leads to a \"missed\" interaction, resulting in a force calculation error.\n\nTo quantify this, we first estimate the typical speed of particles. From the equipartition theorem in three dimensions, the average kinetic energy per particle is $\\frac{3}{2} k_B T$. In reduced units where the particle mass $m$ and $k_B=1$ are specified, the root-mean-square (RMS) speed $v_{\\mathrm{rms}}$ is:\n$$v_{\\mathrm{rms}} = \\sqrt{\\frac{3 k_B T}{m}} = \\sqrt{\\frac{3T}{m}}$$\nThe rate at which two particles approach or separate is given by their relative velocity. For two particles with uncorrelated velocities drawn from the same distribution, the RMS relative speed can be approximated as:\n$$v_{\\mathrm{rel,rms}} = \\sqrt{2} \\, v_{\\mathrm{rms}} = \\sqrt{2} \\sqrt{\\frac{3T}{m}} = \\sqrt{\\frac{6T}{m}}$$\nOver a period of $n$ steps of duration $\\Delta t$, we use a linear approximation for the RMS relative displacement between a pair of particles:\n$$\\Delta r_{\\mathrm{rel}}(n) \\approx v_{\\mathrm{rel,rms}} \\, n \\, \\Delta t$$\nIf this displacement exceeds the skin thickness, $\\Delta r_{\\mathrm{rel}}  r_{\\mathrm{skin}}$, there is a possibility of a missed interaction. We define the \"excess approach distance\" $e$ as the amount by which the relative displacement encroaches into the region protected by the skin:\n$$e = \\max(0, \\Delta r_{\\mathrm{rel}} - r_{\\mathrm{skin}})$$\n\n**2. Formalizing the Force Error Constraint**\n\nThe average number of missed neighbor interactions per particle, $N_{\\mathrm{miss}}$, can be estimated by considering the number of particles that are expected to enter the interaction sphere of a central particle. These particles originate from a spherical shell of radius $r_c$ and thickness $e$. For a system with uniform number density $\\rho$, the volume of this shell is approximately $4 \\pi r_c^2 e$. Thus, the expected number of missed neighbors is:\n$$N_{\\mathrm{miss}} \\approx \\rho \\, 4 \\pi r_c^2 \\, e$$\nTo estimate the resulting force error, we assume that the missed interaction force for each such pair is approximately equal to the force magnitude at the cutoff distance, $|F_{\\mathrm{LJ}}(r_c)|$. The total average per-particle force error $E_f(n)$ is then the product of the number of missed neighbors and this characteristic force magnitude:\n$$E_f(n) \\approx N_{\\mathrm{miss}} \\, |F_{\\mathrm{LJ}}(r_c)| = (\\rho \\, 4 \\pi r_c^2 \\, e) \\, |F_{\\mathrm{LJ}}(r_c)|$$\nThe Lennard-Jones force magnitude in reduced units ($\\epsilon=1, \\sigma=1$) is given by:\n$$|F_{\\mathrm{LJ}}(r)| = \\left| 24 \\left( \\frac{2}{r^{13}} - \\frac{1}{r^{7}} \\right) \\right|$$\nThe problem imposes the constraint that this estimated error must not exceed a specified tolerance $\\varepsilon_f$:\n$$E_f(n) \\le \\varepsilon_f$$\nSubstituting the expression for $E_f(n)$ and solving for the excess distance $e$ gives the maximum permissible excess approach, $e_{\\max}$:\n$$(\\rho \\, 4 \\pi r_c^2 \\, e_{\\max}) \\, |F_{\\mathrm{LJ}}(r_c)| = \\varepsilon_f \\implies e_{\\max} = \\frac{\\varepsilon_f}{\\rho \\, 4 \\pi r_c^2 \\, |F_{\\mathrm{LJ}}(r_c)|}$$\nIf $|F_{\\mathrm{LJ}}(r_c)| = 0$, the denominator is zero. In this physically specific case (where the cutoff is at the force minimum), the estimated force error is zero regardless of missed neighbors, so $e_{\\max}$ can be considered infinite.\n\n**3. Deriving the Optimal Rebuild Period**\n\nThe constraint on $e \\le e_{\\max}$ implies a constraint on the total relative displacement. From $e = \\Delta r_{\\mathrm{rel}} - r_{\\mathrm{skin}}$, we must have $\\Delta r_{\\mathrm{rel}} - r_{\\mathrm{skin}} \\le e_{\\max}$, which rearranges to:\n$$\\Delta r_{\\mathrm{rel}} \\le r_{\\mathrm{skin}} + e_{\\max}$$\nSubstituting our model for displacement, $\\Delta r_{\\mathrm{rel}} \\approx v_{\\mathrm{rel,rms}} \\, n \\, \\Delta t$, gives the constraint on the number of steps $n$:\n$$v_{\\mathrm{rel,rms}} \\, n \\, \\Delta t \\le r_{\\mathrm{skin}} + e_{\\max}$$\nSolving for $n$ yields the maximum number of steps allowed by the error tolerance:\n$$n \\le \\frac{r_{\\mathrm{skin}} + e_{\\max}}{v_{\\mathrm{rel,rms}} \\, \\Delta t}$$\nSince $n$ must be an integer, the largest integer value satisfying this inequality is found by taking the floor of the right-hand side. We denote this value $n_{\\max}$:\n$$n_{\\max} = \\left\\lfloor \\frac{r_{\\mathrm{skin}} + e_{\\max}}{v_{\\mathrm{rel,rms}} \\, \\Delta t} \\right\\rfloor$$\nIf the denominator $v_{\\mathrm{rel,rms}} \\, \\Delta t = 0$ (e.g., at zero temperature), particles are stationary, so no rebuilds are needed to correct for motion. In this case, $n_{\\max}$ can be considered infinite.\n\nThe computational cost model is given as an amortized cost per step: $C_{\\mathrm{step}}(n) = C_{\\mathrm{pair}} + C_{\\mathrm{rebuild}}/n$. To minimize this cost, we must maximize $n$. Therefore, the optimal choice for $n$ under the error constraint is precisely $n_{\\max}$.\n\nFinally, we must incorporate the practical constraints that the rebuild period must be at least $1$ step and no more than the engineering cap $n_{\\mathrm{cap}}$. Combining these, the final expression for the optimal rebuild period is:\n$$n_{\\mathrm{steps}} = \\max\\left(1, \\min\\left(n_{\\max}, n_{\\mathrm{cap}}\\right)\\right)$$\nThis formula represents the complete algorithm for determining the optimal neighbor list rebuild period according to the specified model. For each test case, we will compute the quantities in the specified order to arrive at the final integer $n_{\\mathrm{steps}}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal neighbor list rebuild period for a series of test cases\n    based on a principled model for molecular dynamics simulations.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (rho, T, m, dt, r_c, r_skin, eps_f, n_cap)\n    test_cases = [\n        (0.8, 1.0, 1.0, 0.005, 2.5, 0.3, 0.05, 100),\n        (0.8, 1.0, 1.0, 0.005, 2.5, 0.05, 0.05, 100),\n        (0.8, 0.2, 1.0, 0.005, 2.5, 0.3, 0.05, 100),\n        (0.8, 1.0, 1.0, 0.005, 2.5, 0.3, 0.0, 100),\n        (0.8, 0.05, 1.0, 0.005, 2.5, 0.3, 0.5, 100),\n    ]\n\n    results = []\n    for case in test_cases:\n        rho, T, m, dt, r_c, r_skin, eps_f, n_cap = case\n\n        # Step 1: Compute v_rms and v_rel_rms\n        # v_rms = sqrt(3 * k_B * T / m). In reduced units, k_B = 1.\n        if T >= 0.0 and m > 0.0:\n            v_rms = np.sqrt(3.0 * T / m)\n        else:\n            v_rms = 0.0\n        \n        # v_rel_rms = sqrt(2) * v_rms\n        v_rel_rms = np.sqrt(2.0) * v_rms\n\n        # Step 2: Compute the LJ force magnitude at the cutoff\n        # |F_LJ(r)| = |24 * (2/r^13 - 1/r^7)| in reduced units\n        if r_c > 0:\n            term13 = 2.0 / (r_c ** 13)\n            term7 = 1.0 / (r_c ** 7)\n            F_lj_rc_mag = np.abs(24.0 * (term13 - term7))\n        else:\n            F_lj_rc_mag = np.inf\n\n        # Step 3: Compute the maximum permissible excess distance, e_max\n        # e_max = eps_f / (rho * 4 * pi * r_c^2 * |F_LJ(r_c)|)\n        denominator_emax = rho * 4.0 * np.pi * (r_c ** 2) * F_lj_rc_mag\n        if denominator_emax > 0:\n            e_max = eps_f / denominator_emax\n        else:\n            # If denominator is zero (due to F_lj=0 or rho=0 or r_c=0), \n            # e_max is effectively unbounded.\n            e_max = np.inf\n\n        # Step 4: Compute the maximum number of steps, n_max\n        # n_max = floor((r_skin + e_max) / (v_rel_rms * dt))\n        denominator_nmax = v_rel_rms * dt\n        if denominator_nmax > 0:\n            n_max_float = (r_skin + e_max) / denominator_nmax\n            # Handle the case where n_max_float could be inf\n            if np.isinf(n_max_float):\n                n_max = np.inf\n            else:\n                 n_max = np.floor(n_max_float)\n        else:\n            # If particles are not moving relative to each other,\n            # n_max is effectively unbounded.\n            n_max = np.inf\n\n        # Step 5: Apply practical constraints to find n_steps\n        # n_steps = max(1, min(n_max, n_cap))\n        # min(n_max, n_cap) will correctly handle n_max = inf\n        n_steps = int(max(1, min(n_max, n_cap)))\n        \n        results.append(n_steps)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3177610"}, {"introduction": "Even with a correctly implemented simulation engine, unphysical results can arise from poor parameter choices. This final practice places you in the role of a computational scientist debugging a faulty simulation where a protein unnaturally unfolds [@problem_id:2417128]. By analyzing the simulation settings, you will learn to diagnose critical errors related to the integration time step and the treatment of long-range electrostatic forces, honing the troubleshooting skills essential for reliable scientific simulation.", "problem": "You are analyzing an all-atom Molecular Dynamics (MD) trajectory of a small soluble protein simulated in explicit water under isothermal–isobaric (NPT) conditions at temperature $298\\ \\mathrm{K}$ and pressure $1\\ \\mathrm{atm}$. The protein spontaneously and irreversibly unfolds within $5\\ \\mathrm{ns}$, which is inconsistent with experimental stability under these conditions. Assume the biomolecular force field parameters are correct. Which simulation settings are the most plausible primary causes of this unphysical unfolding? Select all that apply.\n\nA. An integration time step of $\\Delta t = 2\\ \\mathrm{fs}$ is used without constraining any bonds involving hydrogen atoms.\n\nB. All atoms are coupled to a stochastic Langevin thermostat with a friction coefficient $\\gamma = 1\\ \\mathrm{ps^{-1}}$ at $298\\ \\mathrm{K}$.\n\nC. Long-range electrostatics are treated with Particle Mesh Ewald (PME) using a real-space cutoff of $1.0\\ \\mathrm{nm}$ and sufficient mesh resolution.\n\nD. Electrostatics are truncated at a real-space cutoff of $0.8\\ \\mathrm{nm}$ using a shifting function and no reciprocal-space term (no PME), under periodic boundary conditions.", "solution": "The problem statement will first be subjected to critical validation.\n\n### Step 1: Extract Givens\n- System: All-atom Molecular Dynamics (MD) simulation of a small soluble protein in explicit water.\n- Ensemble: Isothermal–isobaric (NPT).\n- Thermodynamic conditions: Temperature $T = 298\\ \\mathrm{K}$, Pressure $P = 1\\ \\mathrm{atm}$.\n- Observation: The protein spontaneously and irreversibly unfolds within a simulation time of $5\\ \\mathrm{ns}$.\n- Context: This simulated behavior is inconsistent with experimental data, which indicates the protein is stable under these conditions.\n- Assumption: The biomolecular force field parameters are correct.\n- Question: Identify the most plausible primary causes of this unphysical unfolding from a list of simulation settings.\n\n### Step 2: Validate Using Extracted Givens\nThe problem describes a realistic scenario encountered in computational biophysics. A discrepancy between simulation results and experimental facts prompts a critical evaluation of the simulation methodology.\n\n- **Scientifically Grounded:** The problem is firmly rooted in the principles of statistical mechanics and molecular dynamics simulations. All concepts mentioned—NPT ensemble, force fields, integration time steps, thermostats, and electrostatic treatments (PME, truncation)—are standard and central to the field. The observed artifact, unphysical unfolding, is a common consequence of incorrect simulation parameters.\n- **Well-Posed:** The problem is clearly defined. Given the assumption that the force field is accurate, the source of error must lie in the numerical algorithms and parameters used to implement the physical model. The question asks to identify the most likely errors from a given set of options, which is a well-defined task.\n- **Objective:** The statement is objective and quantitative, devoid of subjective or ambiguous language.\n\nThe problem statement is self-consistent and provides all necessary information to proceed with a logical analysis based on established principles of molecular simulation.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. A solution will be derived by analyzing the physical and numerical consequences of each proposed simulation setting.\n\nThe rapid, unphysical unfolding of a protein, assumed to be stable and described by a correct force field, points toward a severe error in the simulation protocol. Such errors typically fall into two categories:\n1.  Numerical instability in the integration of the equations of motion, leading to a catastrophic failure of energy conservation.\n2.  A grossly inaccurate approximation in the force calculation that fundamentally misrepresents the physics governing protein stability.\n\nWe will now evaluate each option against these principles.\n\n**A. An integration time step of $\\Delta t = 2\\ \\mathrm{fs}$ is used without constraining any bonds involving hydrogen atoms.**\n\nThe numerical integration of Newton's equations of motion, for example via the Verlet algorithm, is stable only if the integration time step, $\\Delta t$, is substantially smaller than the period of the fastest motion in the system. The fastest periodic motions in a biomolecule are the vibrations of bonds involving the lightest atom, hydrogen (e.g., C-H, N-H, O-H bonds). These vibrations have periods on the order of $\\tau \\approx 10\\ \\mathrm{fs}$. A stable integration requires $\\Delta t \\ll \\tau$. A common rule of thumb is $\\Delta t \\le \\tau/10$.\nIn this case, a time step of $\\Delta t = 2\\ \\mathrm{fs}$ is approximately $\\tau/5$. This is too large to resolve the hydrogen bond vibrational frequency accurately. The integrator will fail to sample these high-frequency oscillations, leading to resonance and a rapid, unbounded increase in system energy. This numerical artifact, often termed \"blowing up,\" would heat the system uncontrollably and destroy the protein structure. Standard practice for using a $\\Delta t = 2\\ \\mathrm{fs}$ time step mandates constraining the lengths of all bonds involving hydrogen atoms using algorithms such as SHAKE or LINCS, which removes these fast degrees of freedom from the system. Therefore, implementing a $2\\ \\mathrm{fs}$ time step without such constraints is a critical, fundamental error.\n\n**Verdict: Correct.** This is a highly plausible cause for the observed catastrophic unfolding.\n\n**B. All atoms are coupled to a stochastic Langevin thermostat with a friction coefficient $\\gamma = 1\\ \\mathrm{ps^{-1}}$ at $298\\ \\mathrm{K}$.**\n\nThe Langevin thermostat maintains temperature by adding a frictional drag and a stochastic random force to Newton's equations of motion. This is a robust and widely accepted method for temperature control in MD simulations, particularly for mimicking the effects of a solvent. The friction coefficient, $\\gamma$, dictates the strength of the coupling to the thermal bath. A value of $\\gamma = 1\\ \\mathrm{ps^{-1}}$ is a standard, moderate choice for biomolecular simulations. It provides effective temperature control without excessively perturbing the system's dynamics. This setting would not introduce large amounts of energy or cause structural instability. If anything, a much larger $\\gamma$ would overdamp the system, slowing down dynamics, while a much smaller $\\gamma$ might lead to poor temperature control, but neither extreme is likely to cause the rapid unfolding described. The specified parameter is perfectly standard.\n\n**Verdict: Incorrect.** This represents a standard, correct simulation setting and would not cause the artifact.\n\n**C. Long-range electrostatics are treated with Particle Mesh Ewald (PME) using a real-space cutoff of $1.0\\ \\mathrm{nm}$ and sufficient mesh resolution.**\n\nThe Particle Mesh Ewald (PME) method is the de facto standard for accurately calculating long-range electrostatic interactions in periodic systems. It avoids the severe artifacts of simple truncation methods. A real-space cutoff of $1.0\\ \\mathrm{nm}$ ($10\\ \\mathrm{\\AA}$) combined with an appropriately chosen Fourier-space mesh (\"sufficient mesh resolution\") is a robust and highly accurate protocol. Proper treatment of long-range electrostatics is known to be critical for maintaining the stability of biomolecules like proteins. Therefore, using PME correctly should stabilize the protein structure, not cause it to unfold. This option describes a high-quality, state-of-the-art simulation practice.\n\n**Verdict: Incorrect.** This setting promotes physical accuracy and stability, making it the opposite of a plausible cause for unfolding.\n\n**D. Electrostatics are truncated at a real-space cutoff of $0.8\\ \\mathrm{nm}$ using a shifting function and no reciprocal-space term (no PME), under periodic boundary conditions.**\n\nThis option describes a simple cutoff-based truncation scheme for electrostatic interactions. The Coulomb potential is long-ranged, decaying as $1/r$. Simply truncating this interaction at a short distance, such as $0.8\\ \\mathrm{nm}$ ($8\\ \\mathrm{\\AA}$), is a severe physical approximation. While using a shifting function ensures the force goes to zero at the cutoff, avoiding an infinite energy derivative and improving energy conservation, it does not remedy the underlying physical inaccuracy. This abrupt truncation neglects all electrostatic interactions beyond $0.8\\ \\mathrm{nm}$, which are collectively crucial for the structural integrity of a macromolecule. It introduces significant artifacts, such as artificial charge-group polarization at the cutoff sphere, incorrect screening, and can lead to the formation of unnatural salt bridges and the disruption of correct tertiary structure. For a polar, charged system like a protein in water, this method is known to be grossly inadequate and can easily lead to rapid denaturation.\n\n**Verdict: Correct.** This represents a major physical approximation error that is a very plausible cause of unphysical protein unfolding.", "answer": "$$\\boxed{AD}$$", "id": "2417128"}]}