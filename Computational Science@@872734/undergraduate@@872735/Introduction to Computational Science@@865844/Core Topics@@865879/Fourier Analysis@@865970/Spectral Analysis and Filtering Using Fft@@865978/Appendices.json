{"hands_on_practices": [{"introduction": "The Fourier series provides a powerful way to represent functions as a sum of simple sinusoids. However, when approximating functions with sharp jumps or discontinuities, a peculiar and persistent artifact known as the Gibbs phenomenon appears: an overshoot that doesn't diminish even as we add more terms to the series. This practice [@problem_id:3282429] allows you to numerically investigate this phenomenon using the FFT and explore a powerful remedy, spectral filtering, which smooths the Fourier coefficients to dramatically reduce the overshoot.", "problem": "Consider the $2\\pi$-periodic function $f(\\theta)$ defined by $f(\\theta)=1$ for $0 \\le \\theta  \\pi$ and $f(\\theta)=-1$ for $\\pi \\le \\theta  2\\pi$, extended periodically. The task is to analyze the Gibbs phenomenon using Fourier partial sums $S_N(\\theta)$ computed via the Fast Fourier Transform (FFT) algorithm, and to apply a spectral exponential filter to reduce overshoot near the discontinuity. Work entirely in radians.\n\nUse the following fundamental base and constraints:\n\n- The Fourier series of a $2\\pi$-periodic function $f(\\theta)$ is built from complex Fourier coefficients, and the truncated partial sum $S_N(\\theta)$ keeps modes with frequency index magnitude at most $N$.\n- The discrete Fourier transform (DFT) of sampled data provides a consistent numerical approximation to Fourier coefficients on an equispaced grid, and the Fast Fourier Transform (FFT) algorithm computes the DFT in $\\mathcal{O}(M \\log M)$ time for $M$ samples.\n- The spectral exponential filter is defined by multiplying each retained complex Fourier coefficient corresponding to frequency index $k$ (with $1 \\le |k| \\le N$) by the factor $\\exp\\!\\left(-\\alpha \\left(\\frac{|k|}{N}\\right)^{p}\\right)$, and leaving the zero mode unchanged. Use $\\alpha=36$ and $p=8$.\n\nImplement the following steps:\n\n1. Sample $f(\\theta)$ on a uniform grid of $M$ points with $M=4096$, at $\\theta_j = \\frac{2\\pi j}{M}$ for $j=0,1,2,\\dots,M-1$.\n2. Use the Fast Fourier Transform (FFT) to compute the discrete spectrum from the samples. Construct $S_N(\\theta)$ by zeroing out all DFT coefficients except those with indices corresponding to frequency magnitudes $\\le N$ (keep both positive and negative frequencies symmetrically, and include the zero-frequency mode). Reconstruct $S_N(\\theta)$ via the inverse transform on the same grid.\n3. Construct the filtered partial sum $S_N^{\\mathrm{filt}}(\\theta)$ by applying the exponential filter with parameters $\\alpha=36$ and $p=8$ to the retained coefficients before the inverse transform, leaving the zero-frequency mode unchanged.\n4. Quantify, for each $N$, both:\n   - The overshoot amplitude defined as $\\max_{\\theta} S_N(\\theta) - 1$, clipped below by $0$ to ensure the reported amplitude is nonnegative.\n   - The root-mean-square (RMS) error defined as $\\sqrt{\\frac{1}{M}\\sum_{j=0}^{M-1} \\left(S_N(\\theta_j) - f(\\theta_j)\\right)^2}$.\n   Perform the same two measurements for $S_N^{\\mathrm{filt}}(\\theta)$.\n5. Use the test suite $N \\in \\{0,1,8,32,128,512\\}$ and report, for each $N$ in the suite, the unfiltered overshoot amplitude, the filtered overshoot amplitude, the unfiltered RMS error, and the filtered RMS error.\n\nYour program should produce a single line of output containing a comma-separated list of five lists, with no spaces, in the exact order: the list of $N$ values, the list of unfiltered overshoot amplitudes, the list of filtered overshoot amplitudes, the list of unfiltered RMS errors, and the list of filtered RMS errors. For example, the required format is $[[N\\_list],[unfiltered\\_overshoots],[filtered\\_overshoots],[unfiltered\\_rms],[filtered\\_rms]]$, where each bracketed item is a list of numbers. All angles are in radians, and all reported numerical values are unitless floats.", "solution": "The problem requires a numerical investigation of the Gibbs phenomenon for a $2\\pi$-periodic square wave and its mitigation using a spectral exponential filter. The analysis is to be performed using the Fast Fourier Transform (FFT) algorithm to compute truncated Fourier series approximations.\n\nThe function under consideration is a $2\\pi$-periodic square wave defined on the interval $[0, 2\\pi)$ as:\n$$\nf(\\theta) = \\begin{cases}\n    1  \\text{for } 0 \\le \\theta  \\pi \\\\\n    -1  \\text{for } \\pi \\le \\theta  2\\pi\n\\end{cases}\n$$\nThis function has jump discontinuities at $\\theta = n\\pi$ for any integer $n$. When approximated by a truncated Fourier series, these discontinuities lead to the Gibbs phenomenon, characterized by persistent overshoots near the jumps.\n\nThe core of the analysis relies on the discrete Fourier transform (DFT), computed efficiently by the FFT. The procedure is as follows:\n\nFirst, we discretize the domain $[0, 2\\pi)$. The function $f(\\theta)$ is sampled on a uniform grid of $M=4096$ points, given by $\\theta_j = \\frac{2\\pi j}{M}$ for $j=0, 1, \\dots, M-1$. This yields a vector of samples $f_j = f(\\theta_j)$. According to the function's definition, this results in $f_j = 1$ for $j=0, \\dots, M/2-1$ and $f_j = -1$ for $j=M/2, \\dots, M-1$.\n\nSecond, we compute the DFT of the sampled signal $\\{f_j\\}$ to obtain its spectrum $\\{\\hat{f}_k\\}$. The DFT is defined as $\\hat{f}_k = \\sum_{j=0}^{M-1} f_j \\exp(-i 2\\pi jk/M)$. The corresponding integer frequency modes (wavenumbers) $k$ are obtained for the output array of the FFT algorithm. For an input of length $M$, the frequencies correspond to the sequence $k = 0, 1, \\dots, M/2-1, -M/2, \\dots, -1$.\n\nThird, for each truncation parameter $N$ from the test suite $\\{0, 1, 8, 32, 128, 512\\}$, we construct two different approximations to $f(\\theta)$.\n\nThe unfiltered Fourier partial sum, $S_N(\\theta)$, is constructed from a truncated spectrum $\\hat{S}_{N}$. This spectrum is obtained by setting to zero all coefficients $\\hat{f}_k$ for which the absolute frequency index $|k|$ exceeds the truncation limit $N$:\n$$\n\\hat{S}_{N,k} = \\begin{cases}\n    \\hat{f}_k  \\text{if } |k| \\le N \\\\\n    0  \\text{if } |k|  N\n\\end{cases}\n$$\nThe spatial representation $S_N(\\theta_j)$ is then recovered by applying the inverse DFT (IDFT) to the spectral coefficients $\\{\\hat{S}_{N,k}\\}$. The IDFT is given by $S_N(\\theta_j) = \\frac{1}{M} \\sum_{k=0}^{M-1} \\hat{S}_{N,k} \\exp(i 2\\pi jk/M)$.\n\nThe filtered partial sum, $S_N^{\\mathrm{filt}}(\\theta)$, is constructed to reduce the Gibbs oscillations. This is achieved by applying a spectral filter to the truncated spectrum before the inverse transform. The filtered spectrum, $\\hat{S}_{N,k}^{\\mathrm{filt}}$, is defined by multiplying the retained coefficients by a filter factor $\\sigma_k$:\n$$\n\\hat{S}_{N,k}^{\\mathrm{filt}} = \\sigma_k \\hat{S}_{N,k} \\quad \\text{where} \\quad \\sigma_k = \\begin{cases}\n    1  \\text{if } k=0 \\\\\n    \\exp\\!\\left(-\\alpha \\left(\\frac{|k|}{N}\\right)^{p}\\right)  \\text{if } 1 \\le |k| \\le N \\\\\n    1  \\text{if } |k|  N \\text{ (but } \\hat{S}_{N,k}=0 \\text{ anyway)}\n\\end{cases}\n$$\nThe filter parameters are given as $\\alpha=36$ and $p=8$. The spatial representation $S_N^{\\mathrm{filt}}(\\theta_j)$ is then recovered by applying the IDFT to $\\{\\hat{S}_{N,k}^{\\mathrm{filt}}\\}$. For the special case $N=0$, the filtering condition $1 \\le |k| \\le N$ is never met, so no modes are modified by the filter factor.\n\nFourth, we quantify the performance of both approximations. Two metrics are computed for each value of $N$:\n1. The overshoot amplitude, defined as the maximum value of the reconstructed signal minus the true maximum of the function ($1$), clipped below at zero to ensure a non-negative result:\n   $$ \\text{Overshoot} = \\max\\left(0, \\left(\\max_j S(\\theta_j)\\right) - 1\\right) $$\n2. The root-mean-square (RMS) error, which measures the average deviation from the true function across the grid:\n   $$ \\text{RMS Error} = \\sqrt{\\frac{1}{M}\\sum_{j=0}^{M-1} \\left(S(\\theta_j) - f(\\theta_j)\\right)^2} $$\nThese two metrics are calculated for both the unfiltered sum $S_N(\\theta_j)$ and the filtered sum $S_N^{\\mathrm{filt}}(\\theta_j)$.\n\nThe algorithm proceeds by iterating through the specified values of $N$, performing these calculations, and collecting the results for the final formatted output. The data will demonstrate that while the unfiltered sum exhibits a significant and persistent overshoot (the Gibbs phenomenon), the spectral filter effectively suppresses these oscillations, leading to a much smaller overshoot amplitude. This improvement in reducing local error, however, may come at the cost of a slight increase in global error, as measured by the RMS value.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes unfiltered and filtered Fourier partial sums for a square wave\n    to analyze the Gibbs phenomenon and the effect of a spectral filter.\n    \"\"\"\n    # Define the parameters and test cases from the problem statement.\n    M = 4096\n    alpha = 36\n    p = 8\n    test_cases = [0, 1, 8, 32, 128, 512] # These are the values for N\n\n    # --- Main Logic ---\n\n    # Step 1: Sample the function f(theta)\n    # The function is f(theta) = 1 for 0 = theta  pi and f(theta) = -1 for pi = theta  2pi.\n    # On a grid of M points theta_j = 2*pi*j/M, this corresponds to\n    # f_j = 1 for j=0..M/2-1 and f_j = -1 for j=M/2..M-1.\n    f_samples = np.ones(M)\n    f_samples[M // 2:] = -1.0\n\n    # Step 2: Compute the DFT of the sampled signal\n    f_hat = np.fft.fft(f_samples)\n    # Get the corresponding integer frequency modes k for the DFT output array.\n    # np.fft.fftfreq(M) * M gives [0, 1, ..., M/2-1, -M/2, ..., -1]\n    k_freqs = np.fft.fftfreq(M) * M\n\n    # Store results for each N\n    results_unfiltered_overshoot = []\n    results_filtered_overshoot = []\n    results_unfiltered_rms = []\n    results_filtered_rms = []\n\n    for N in test_cases:\n        # Construct unfiltered partial sum S_N by truncating the spectrum\n        S_N_hat = f_hat.copy()\n        # Zero out coefficients for frequencies with magnitude  N\n        S_N_hat[np.abs(k_freqs)  N] = 0.0\n        \n        # Reconstruct S_N via inverse FFT\n        # The result should be real-valued; .real discards negligible imaginary parts from numerical error.\n        S_N = np.fft.ifft(S_N_hat).real\n\n        # Construct filtered partial sum S_N_filt\n        S_N_filt_hat = S_N_hat.copy() # Start with the same truncated spectrum\n        if N  0:\n            # Create a mask for modes to be filtered (1 = |k| = N)\n            filter_mask = (np.abs(k_freqs)  0)  (np.abs(k_freqs) = N)\n            \n            # Get the k values of the modes to be filtered\n            k_vals_to_filter = np.abs(k_freqs[filter_mask])\n            \n            # Calculate the exponential filter factors\n            sigma_k = np.exp(-alpha * (k_vals_to_filter / N)**p)\n            \n            # Apply the filter by element-wise multiplication\n            S_N_filt_hat[filter_mask] *= sigma_k\n        \n        # Reconstruct S_N_filt via inverse FFT\n        S_N_filt = np.fft.ifft(S_N_filt_hat).real\n\n        # Quantify overshoot and RMS error for both cases\n        # For S_N (unfiltered)\n        overshoot_unfiltered = np.maximum(0.0, np.max(S_N) - 1.0)\n        rms_unfiltered = np.sqrt(np.mean((S_N - f_samples)**2))\n        \n        # For S_N_filt (filtered)\n        overshoot_filtered = np.maximum(0.0, np.max(S_N_filt) - 1.0)\n        rms_filtered = np.sqrt(np.mean((S_N_filt - f_samples)**2))\n\n        # Append results to lists\n        results_unfiltered_overshoot.append(overshoot_unfiltered)\n        results_filtered_overshoot.append(overshoot_filtered)\n        results_unfiltered_rms.append(rms_unfiltered)\n        results_filtered_rms.append(rms_filtered)\n\n    # Final print statement in the exact required format.\n    all_results = [\n        test_cases,\n        results_unfiltered_overshoot,\n        results_filtered_overshoot,\n        results_unfiltered_rms,\n        results_filtered_rms\n    ]\n    \n    # Convert each inner list of numbers into a comma-separated string, enclosed in brackets.\n    stringified_lists = [f\"[{','.join(map(str, lst))}]\" for lst in all_results]\n    \n    # Join these stringified lists into the final output format: [[list1],[list2],...]\n    print(f\"[{','.join(stringified_lists)}]\")\n\nsolve()\n```", "id": "3282429"}, {"introduction": "Many real-world signals, from audio to electrical measurements, are corrupted by unwanted harmonic distortion, where integer multiples of a fundamental frequency appear. The Fast Fourier Transform is an exceptional tool for diagnosing and correcting this issue. This exercise [@problem_id:3196001] provides hands-on practice in using the FFT to perform surgical filtering, precisely identifying and removing these harmonic components. You will learn to project a signal onto a subspace of harmonics and analyze the residual, a core skill in signal purification.", "problem": "You will implement harmonic removal and residual analysis using the Fast Fourier Transform (FFT), grounded in the Discrete Fourier Transform (DFT) and orthogonality of complex exponentials. The aim is to project a real-valued discrete-time signal onto the subspace spanned by sinusoidal components at integer harmonics of a specified fundamental frequency, remove those harmonics, reconstruct the time-domain residual, and quantify how much of the residual energy is attributable to nonlinear harmonic generation beyond the removed set.\n\nFundamental base:\n- Let $x[n]$ for $n \\in \\{0,1,\\dots,N-1\\}$ be a real-valued sequence. The Discrete Fourier Transform (DFT) is defined as\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2 \\pi \\frac{k n}{N}}, \\quad k \\in \\{0,1,\\dots,N-1\\}.\n$$\nThe inverse DFT (IDFT) is\n$$\nx[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] e^{j 2 \\pi \\frac{k n}{N}}.\n$$\n- The set $\\{e^{j 2 \\pi \\frac{k n}{N}} : k = 0,1,\\dots,N-1\\}$ forms an orthogonal basis under the inner product $\\langle u, v \\rangle = \\sum_{n=0}^{N-1} u[n] \\overline{v[n]}$. For $k \\neq m$, one has $\\sum_{n=0}^{N-1} e^{j 2 \\pi \\frac{(k-m) n}{N}} = 0$.\n- Projection of $x[n]$ onto the span of the complex exponentials at indices $\\mathcal{K} \\subset \\{0,1,\\dots,N-1\\}$ is achieved by retaining $X[k]$ for $k \\in \\mathcal{K}$ and setting the remaining coefficients to zero, followed by the inverse DFT to obtain the time-domain component.\n\nProblem requirements:\n- You will synthesize signals with a fundamental sinusoid at frequency $f_0$ and amplitude $A_1$, pass them through a static polynomial nonlinearity to generate harmonics, add zero-mean Gaussian noise, and then perform harmonic removal and residual analysis using the FFT.\n- Signal model: sample at rate $f_s$ (in $\\mathrm{Hz}$) for duration $T$ (in $\\mathrm{s}$), with $N = f_s \\cdot T$ samples. Let $t[n] = \\frac{n}{f_s}$ for $n = 0,1,\\dots,N-1$. Define the base sinusoid\n$$\nx_0[n] = A_1 \\sin(2 \\pi f_0 t[n]).\n$$\nPass $x_0[n]$ through a memoryless nonlinearity\n$$\nx_{\\text{nl}}[n] = x_0[n] + \\alpha\\, x_0[n]^2 + \\beta\\, x_0[n]^3,\n$$\nand add independent and identically distributed Gaussian noise $w[n] \\sim \\mathcal{N}(0,\\sigma^2)$ generated with a specified pseudorandom seed to obtain\n$$\ny[n] = x_{\\text{nl}}[n] + w[n].\n$$\n- Harmonic removal by orthogonal projection using the FFT:\n  1. Compute the DFT $Y[k]$ of $y[n]$.\n  2. For a given harmonic count $H \\in \\mathbb{N}$, identify DFT bin indices corresponding to the frequencies $\\{n f_0 : n = 1,2,\\dots,H\\}$ using $k_n = \\left\\lfloor \\frac{n f_0 N}{f_s} + \\tfrac{1}{2} \\right\\rfloor$ (nearest-integer rounding). Include the conjugate-symmetric bins at $N-k_n$ for each $k_n$ strictly between $0$ and $N/2$. Exclude the direct current (DC) bin at $k=0$ and the Nyquist bin at $k=N/2$ (when $N$ is even) from selection.\n  3. Form $Y_{\\text{harm}}[k]$ by retaining $Y[k]$ only at the selected bins $\\{k_n, N-k_n\\}$ and setting all other bins to zero.\n  4. Obtain the time-domain harmonic component via IDFT: $y_{\\text{harm}}[n]$ from $Y_{\\text{harm}}[k]$.\n  5. The time-domain residual is $r[n] = y[n] - y_{\\text{harm}}[n]$.\n- Nonlinear noise contribution analysis:\n  - Compute the residual energy $E_{\\text{tot}} = \\sum_{n=0}^{N-1} r[n]^2$.\n  - To estimate the fraction of residual energy attributable to harmonics beyond the removed set, build a frequency mask that selects three-bin neighborhoods (centered bin and one bin on each side) around the DFT indices corresponding to the frequencies $\\{n f_0 : n = H+1, H+2, \\dots\\}$ that are strictly below the Nyquist frequency $\\frac{f_s}{2}$. For each such center index $k_n = \\left\\lfloor \\frac{n f_0 N}{f_s} + \\tfrac{1}{2} \\right\\rfloor$, include the bins $\\{k_n-1, k_n, k_n+1\\}$ clipped to the valid positive-frequency, non-DC, non-Nyquist range, and also include their conjugate-symmetric counterparts $\\{N-(k_n-1), N-k_n, N-(k_n+1)\\}$ when applicable.\n  - Let $R[k]$ be the DFT of $r[n]$. Define $R_{\\text{hh}}[k]$ by retaining only the bins selected by the high-order harmonic mask and zeroing all others. Invert to time domain to obtain $r_{\\text{hh}}[n]$.\n  - Compute $E_{\\text{hh}} = \\sum_{n=0}^{N-1} r_{\\text{hh}}[n]^2$. The desired scalar metric is the fraction\n$$\n\\phi = \\frac{E_{\\text{hh}}}{E_{\\text{tot}}}.\n$$\nThis is a dimensionless quantity in the interval $[0,1]$.\n\nImplementation constraints:\n- The algorithm must be implemented using a Fast Fourier Transform (FFT) to compute the DFT and its inverse.\n- You must use the Discrete Fourier Transform (DFT) definitions above as the foundational base. No other shortcut formulas for projections are permitted beyond the orthogonality and reconstruction properties of the DFT basis.\n\nTest suite:\nFor each test case, set $A_1 = 1.0$, generate noise with the specified seed, and compute the scalar $\\phi$ as defined above. There are no physical units in the final scalar, and it is dimensionless. The program must process the following four cases:\n\n- Case $1$ (happy path, aligned bins, partial removal):\n  - $f_s = 8192$, $T = 1.0$, $f_0 = 256.0$, $H = 1$, $\\alpha = 0.2$, $\\beta = 0.05$, $\\sigma = 0.01$, seed $= 2021$.\n- Case $2$ (aligned bins, deeper removal):\n  - $f_s = 8192$, $T = 1.0$, $f_0 = 256.0$, $H = 3$, $\\alpha = 0.2$, $\\beta = 0.05$, $\\sigma = 0.01$, seed $= 2021$.\n- Case $3$ (misaligned frequency causing spectral leakage):\n  - $f_s = 8000$, $T = 1.0$, $f_0 = 255.5$, $H = 3$, $\\alpha = 0.2$, $\\beta = 0.05$, $\\sigma = 0.01$, seed $= 7$.\n- Case $4$ (noise-only boundary, aligned bins):\n  - $f_s = 8192$, $T = 0.5$, $f_0 = 300.0$, $H = 2$, $\\alpha = 0.0$, $\\beta = 0.0$, $\\sigma = 0.02$, seed $= 999$.\n\nRequired final output format:\n- Your program must produce a single line containing a Python-style list of the four scalar results $[\\phi_1,\\phi_2,\\phi_3,\\phi_4]$, where each $\\phi_i$ corresponds to the case $i \\in \\{1,2,3,4\\}$. Each value must be rounded to exactly six digits after the decimal point, with no spaces. For example, an acceptable format is $[0.123456,0.234567,0.345678,0.456789]$.", "solution": "The problem is valid as it is scientifically grounded in the principles of digital signal processing, well-posed with a clear algorithmic path to a unique solution, and objective in its formulation. The solution proceeds by implementing the specified steps for signal synthesis, filtering, and analysis.\n\nThe methodological foundation rests on the properties of the Discrete Fourier Transform (DFT). A discrete-time signal $y[n]$ of length $N$ can be represented as a linear combination of $N$ orthogonal complex exponential basis functions $\\{e^{j 2 \\pi \\frac{k n}{N}}\\}_{k=0}^{N-1}$. The DFT coefficients $Y[k]$ are the coordinates of the signal in this basis:\n$$\nY[k] = \\sum_{n=0}^{N-1} y[n] e^{-j 2 \\pi \\frac{k n}{N}}\n$$\nThis is effectively a projection of $y[n]$ onto each basis vector. Due to orthogonality, the signal can be perfectly reconstructed from its coefficients via the Inverse DFT (IDFT):\n$$\ny[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] e^{j 2 \\pi \\frac{k n}{N}}\n$$\n\nThe core of the problem is to perform ideal frequency-domain filtering, which is an orthogonal projection onto a subspace spanned by a chosen subset of the DFT basis vectors. The algorithm proceeds as follows:\n\n1.  **Signal Synthesis**: A signal $y[n]$ is synthesized according to the model provided. A pure sinusoid $x_0[n] = A_1 \\sin(2 \\pi f_0 t[n])$ is passed through a polynomial nonlinearity $x_{\\text{nl}}[n] = x_0[n] + \\alpha\\, x_0[n]^2 + \\beta\\, x_0[n]^3$. Using trigonometric identities, e.g., $\\sin^2(\\theta) = \\frac{1}{2}(1-\\cos(2\\theta))$ and $\\sin^3(\\theta) = \\frac{3}{4}\\sin(\\theta)-\\frac{1}{4}\\sin(3\\theta)$, it can be shown that this nonlinearity generates components at DC ($0$ Hz), the second harmonic ($2 f_0$), and the third harmonic ($3 f_0$), in addition to the fundamental ($f_0$). Finally, zero-mean Gaussian noise $w[n]$ is added, yielding the composite signal $y[n] = x_{\\text{nl}}[n] + w[n]$.\n\n2.  **Harmonic Removal by Projection**: To remove the first $H$ harmonics, we project the signal $y[n]$ onto the subspace spanned by the basis vectors corresponding to these harmonic frequencies.\n    -   First, the DFT $Y[k]$ of the signal $y[n]$ is computed using a Fast Fourier Transform (FFT) algorithm.\n    -   The set of DFT bin indices $\\mathcal{K}_{\\text{harm}}$ corresponding to the harmonic frequencies $\\{f_n = n f_0 : n=1, \\dots, H\\}$ is identified. For each frequency $f_n$, the nearest integer bin index is calculated as $k_n = \\lfloor \\frac{f_n N}{f_s} + \\frac{1}{2} \\rfloor$. Since the input signal $y[n]$ is real, its DFT is conjugate-symmetric, i.e., $Y[k] = \\overline{Y[N-k]}$. To maintain this property in the filtered signal, for each index $k_n$ in the positive frequency range ($1 \\le k_n  N/2$), its symmetric counterpart $N-k_n$ must also be included in $\\mathcal{K}_{\\text{harm}}$.\n    -   A new spectrum $Y_{\\text{harm}}[k]$ is formed by retaining the original coefficients for indices in $\\mathcal{K}_{\\text{harm}}$ and setting all other coefficients to zero: $Y_{\\text{harm}}[k] = Y[k]$ if $k \\in \\mathcal{K}_{\\text{harm}}$ and $0$ otherwise.\n    -   The time-domain residual $r[n]$ is the part of the signal orthogonal to the harmonic subspace. It can be computed directly in the frequency domain by creating a residual spectrum $R[k] = Y[k] - Y_{\\text{harm}}[k]$ and then transforming back to the time domain: $r[n] = \\text{IDFT}(R[k])$.\n\n3.  **Residual Energy Analysis**: The total energy of the residual is calculated as $E_{\\text{tot}} = \\sum_{n=0}^{N-1} r[n]^2$. This residual contains higher-order harmonics (with frequencies greater than $H f_0$), noise, and any energy from the first $H$ harmonics that was not removed due to spectral leakage.\n\n4.  **Quantification of Higher-Order Harmonics**: To estimate the energy contribution from harmonics beyond the removed set, a second projection is performed on the residual.\n    -   The DFT of the residual, $R[k]$, is used.\n    -   A new frequency mask is constructed to select three-bin neighborhoods around the bin indices corresponding to higher-order harmonics $\\{n f_0 : n=H+1, H+2, \\dots\\}$ that lie below the Nyquist frequency $f_s/2$. This creates a set of indices $\\mathcal{K}_{\\text{hh}}$.\n    -   A new spectrum $R_{\\text{hh}}[k]$ is formed by retaining the coefficients of $R[k]$ for indices in $\\mathcal{K}_{\\text{hh}}$ and zeroing others.\n    -   This spectrum is transformed back to the time domain to obtain $r_{\\text{hh}}[n] = \\text{IDFT}(R_{\\text{hh}}[k])$.\n    -   The energy of this component is computed as $E_{\\text{hh}} = \\sum_{n=0}^{N-1} r_{\\text{hh}}[n]^2$.\n    -   The final metric $\\phi = E_{\\text{hh}} / E_{\\text{tot}}$ represents the fraction of the residual's energy that is concentrated in the frequency bands of the next-in-line harmonics. By Parseval's theorem, this energy ratio could also be computed in the frequency domain, but the implementation adheres to the specified time-domain calculation.\n\nThis procedure is systematically applied to each test case, yielding the dimensionless scalar metric $\\phi$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def calculate_phi(fs, T, f0, H, alpha, beta, sigma, seed, A1=1.0):\n        \"\"\"\n        Calculates the scalar metric phi for a single test case.\n        \"\"\"\n        # Step 1: Signal Generation\n        N = int(fs * T)\n        t = np.arange(N) / fs\n        \n        rng = np.random.default_rng(seed)\n        \n        x0_n = A1 * np.sin(2 * np.pi * f0 * t)\n        x_nl_n = x0_n + alpha * x0_n**2 + beta * x0_n**3\n        w_n = rng.normal(loc=0.0, scale=sigma, size=N)\n        y_n = x_nl_n + w_n\n        \n        # Step 2: Harmonic Removal by Orthogonal Projection\n        Y_k = np.fft.fft(y_n)\n        \n        harmonic_indices = set()\n        nyquist_idx = N // 2\n        \n        for n_h in range(1, H + 1):\n            freq = n_h * f0\n            # Implement k_n = floor(v + 0.5) for nearest-integer rounding\n            k = int((freq * N / fs) + 0.5)\n            \n            # Exclude DC (k=0) and Nyquist (k=N/2) bins from selection\n            if 1 = k  nyquist_idx:\n                harmonic_indices.add(k)\n                harmonic_indices.add(N - k)\n\n        # The residual spectrum is formed by zeroing out the harmonic bins.\n        R_k = np.copy(Y_k)\n        for k in harmonic_indices:\n            R_k[k] = 0.0\n            \n        # The time-domain residual is the inverse DFT of the residual spectrum.\n        # .real is taken as the input is real and the filter is symmetric.\n        r_n = np.fft.ifft(R_k).real\n        \n        # Step 3: Nonlinear Noise Contribution Analysis\n        E_tot = np.sum(r_n**2)\n        \n        # DFT of the residual is R_k, which we already have.\n        \n        # Build frequency mask for higher-order harmonics\n        hh_indices = set()\n        nyquist_freq = fs / 2.0\n        n_h = H + 1\n        while True:\n            freq = n_h * f0\n            if freq = nyquist_freq:\n                break\n            \n            k_center = int((freq * N / fs) + 0.5)\n            \n            # Create a 3-bin neighborhood\n            for dk in [-1, 0, 1]:\n                k = k_center + dk\n                # Clip to valid positive-frequency, non-DC, non-Nyquist range\n                if 1 = k  nyquist_idx:\n                    hh_indices.add(k)\n                    # Add conjugate symmetric bin\n                    hh_indices.add(N - k)\n            \n            n_h += 1\n            \n        # Create high-harmonic residual spectrum from the residual's spectrum\n        R_hh_k = np.zeros_like(R_k)\n        for k in hh_indices:\n            R_hh_k[k] = R_k[k]\n            \n        # Reconstruct time-domain high-harmonic residual and compute its energy\n        r_hh_n = np.fft.ifft(R_hh_k).real\n        E_hh = np.sum(r_hh_n**2)\n        \n        # Avoid division by zero, although unlikely with noise\n        if E_tot == 0.0:\n            return 0.0\n        \n        phi = E_hh / E_tot\n        \n        return phi\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, aligned bins, partial removal):\n        {'fs': 8192, 'T': 1.0, 'f0': 256.0, 'H': 1, 'alpha': 0.2, 'beta': 0.05, 'sigma': 0.01, 'seed': 2021},\n        # Case 2 (aligned bins, deeper removal):\n        {'fs': 8192, 'T': 1.0, 'f0': 256.0, 'H': 3, 'alpha': 0.2, 'beta': 0.05, 'sigma': 0.01, 'seed': 2021},\n        # Case 3 (misaligned frequency causing spectral leakage):\n        {'fs': 8000, 'T': 1.0, 'f0': 255.5, 'H': 3, 'alpha': 0.2, 'beta': 0.05, 'sigma': 0.01, 'seed': 7},\n        # Case 4 (noise-only boundary, aligned bins):\n        {'fs': 8192, 'T': 0.5, 'f0': 300.0, 'H': 2, 'alpha': 0.0, 'beta': 0.0, 'sigma': 0.02, 'seed': 999}\n    ]\n\n    results = []\n    for case in test_cases:\n        phi = calculate_phi(**case)\n        results.append(phi)\n    \n    # Format each result to exactly six digits after the decimal point\n    formatted_results = [f\"{res:.6f}\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3196001"}, {"introduction": "What happens when a signal is incomplete? Missing data points are a common challenge in data acquisition, and naively filling them with zeros creates significant artifacts in the frequency domain. This advanced practice [@problem_id:3195883] moves beyond simple filtering to signal reconstruction, introducing an iterative method known as spectral inpainting. You will implement an algorithm that leverages the assumption of sparsity—that the original signal is simple in the frequency domain—to intelligently fill in the gaps, demonstrating a modern approach to signal recovery.", "problem": "You are given the task of analyzing the spectral effects of missing samples in a discrete-time signal, and then mitigating these effects using an inpainting method based on the Fast Fourier Transform (FFT). Work entirely in the discrete-time domain and express all steps using well-defined mathematical constructs. Use the Discrete Fourier Transform (DFT) definition as your fundamental base.\n\nStart from the fundamental definition of the Discrete Fourier Transform (DFT): for a signal $x[n]$ of length $N$, the DFT is\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi k n / N}, \\quad k = 0,1,\\dots,N-1.\n$$\nLet $m[n]$ be a binary sampling mask taking values in $\\{0,1\\}$, where $m[n]=1$ indicates an observed sample and $m[n]=0$ indicates a missing sample. The observed signal is $x_{\\mathrm{mask}}[n] = x[n] \\cdot m[n]$. The convolution property of the DFT implies that multiplication in the time domain corresponds to circular convolution in the frequency domain: if $M[k]$ is the DFT of $m[n]$, then the spectrum of $x_{\\mathrm{mask}}[n]$ is $X_{\\mathrm{mask}}[k] = (X * M)[k]$, which redistributes energy across frequencies, potentially creating spectral artifacts.\n\nDesign and implement a program that, for each test case specified below, performs the following steps:\n\n1. Construct a synthetic real-valued signal $x[n]$ of length $N$ as a sum of cosines with integer-bin frequencies:\n   $$\n   x[n] = \\sum_{i=1}^{K} A_i \\cos\\!\\left( \\frac{2\\pi f_i n}{N} \\right), \\quad n = 0,1,\\dots,N-1,\n   $$\n   where $K$ is the number of tones, $A_i$ are the amplitudes, and $f_i$ are distinct integer frequency bins with $0  f_i  \\frac{N}{2}$.\n\n2. Randomly select a fraction $p_{\\mathrm{miss}}$ of indices to set as missing ($m[n]=0$), using a specified random seed for reproducibility. Form $x_{\\mathrm{mask}}[n]$ by zero-filling the missing samples, i.e., $x_{\\mathrm{mask}}[n] = x[n]$ if $m[n]=1$, and $x_{\\mathrm{mask}}[n]=0$ if $m[n]=0$.\n\n3. Compute the DFT $X_{\\mathrm{mask}}[k]$ of $x_{\\mathrm{mask}}[n]$ using the Fast Fourier Transform (FFT). Define the true spectral support $\\mathcal{S}$ as the set of bins corresponding to the known tone frequencies and their symmetric counterparts for a real signal:\n   $$\n   \\mathcal{S} = \\{ f_1, f_2, \\dots, f_K \\} \\cup \\{ (-f_1) \\bmod N, \\dots, (-f_K) \\bmod N \\}.\n   $$\n   Compute the artifact energy ratio before inpainting as\n   $$\n   r_{\\mathrm{zero}} = \\frac{\\sum_{k \\notin \\mathcal{S}} |X_{\\mathrm{mask}}[k]|^2}{\\sum_{k=0}^{N-1} |X_{\\mathrm{mask}}[k]|^2},\n   $$\n   with the convention that the ratio is $0$ if the denominator is $0$.\n\n4. Perform spectral inpainting via iterative FFT thresholding:\n   - Initialize $y^{(0)}[n] = x_{\\mathrm{mask}}[n]$.\n   - At each iteration $t = 0,1,2,\\dots$:\n     - Compute $Y^{(t)}[k] = \\mathrm{FFT}(y^{(t)}[n])$.\n     - Hard-threshold in the frequency domain by keeping the $K_{\\mathrm{keep}}$ largest-magnitude coefficients and zeroing the rest, producing $\\tilde{Y}^{(t)}[k]$.\n     - Compute the inverse DFT $\\tilde{y}^{(t)}[n] = \\mathrm{IFFT}(\\tilde{Y}^{(t)}[k])$, take the real part, and enforce data consistency on observed samples:\n       $$\n       y^{(t+1)}[n] = \\begin{cases}\n       x[n]  \\text{if } m[n]=1, \\\\\n       \\tilde{y}^{(t)}[n]  \\text{if } m[n]=0.\n       \\end{cases}\n       $$\n     - Stop when the relative change $\\frac{\\|y^{(t+1)} - y^{(t)}\\|_2}{\\|y^{(t)}\\|_2}$ is less than the tolerance $\\varepsilon$, or when the maximum number of iterations $T_{\\max}$ is reached.\n\n5. Compute the DFT $X_{\\mathrm{rec}}[k]$ of the final inpainted signal $y^{(\\ast)}[n]$ and the corresponding artifact energy ratio\n   $$\n   r_{\\mathrm{inpaint}} = \\frac{\\sum_{k \\notin \\mathcal{S}} |X_{\\mathrm{rec}}[k]|^2}{\\sum_{k=0}^{N-1} |X_{\\mathrm{rec}}[k]|^2},\n   $$\n   with the same convention as above. Also compute the normalized reconstruction error\n   $$\n   e = \\frac{\\|y^{(\\ast)} - x\\|_2}{\\|x\\|_2}.\n   $$\n\nYour implementation must use the test suite specified below. For each test case, return a list of three floats $[r_{\\mathrm{zero}}, r_{\\mathrm{inpaint}}, e]$ rounded to $6$ decimal places. The final program output must be a single line containing the results for all test cases as a comma-separated list enclosed in square brackets, where each element is itself the three-float list for the corresponding test case, for example, $[[a_1,b_1,c_1],[a_2,b_2,c_2]]$.\n\nTest Suite:\n- Case $1$ (Happy path): $N=1024$, $K=3$, frequencies $[50, 123, 300]$, amplitudes $[1.0, 0.8, 0.6]$, missing fraction $p_{\\mathrm{miss}}=0.2$, $K_{\\mathrm{keep}}=6$, tolerance $\\varepsilon=10^{-8}$, maximum iterations $T_{\\max}=200$, random seed $1$.\n- Case $2$ (Boundary, no missing samples): $N=1024$, $K=3$, frequencies $[50, 123, 300]$, amplitudes $[1.0, 0.8, 0.6]$, missing fraction $p_{\\mathrm{miss}}=0.0$, $K_{\\mathrm{keep}}=6$, tolerance $\\varepsilon=10^{-8}$, maximum iterations $T_{\\max}=200$, random seed $2$.\n- Case $3$ (Edge, heavy missing): $N=2048$, $K=5$, frequencies $[15, 77, 221, 400, 650]$, amplitudes $[1.0, 0.5, 0.7, 0.9, 0.4]$, missing fraction $p_{\\mathrm{miss}}=0.5$, $K_{\\mathrm{keep}}=10$, tolerance $\\varepsilon=10^{-8}$, maximum iterations $T_{\\max}=300$, random seed $3$.\n- Case $4$ (Edge, single tone and severe missing): $N=512$, $K=1$, frequency $[64]$, amplitude $[1.0]$, missing fraction $p_{\\mathrm{miss}}=0.7$, $K_{\\mathrm{keep}}=2$, tolerance $\\varepsilon=10^{-8}$, maximum iterations $T_{\\max}=300$, random seed $42$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list $[r_{\\mathrm{zero}}, r_{\\mathrm{inpaint}}, e]$ for one test case, with each float rounded to $6$ decimal places, for example:\n$[[0.123456,0.000789,0.012345],[\\dots],[\\dots],[\\dots]]$.", "solution": "The user-provided problem statement has been meticulously validated and is determined to be sound, well-posed, and scientifically grounded. It presents a clear task in computational signal processing, specifically the recovery of a sparse signal from incomplete measurements using an iterative spectral method. All parameters, definitions, and procedures are specified with sufficient rigor to permit a unique and verifiable solution.\n\nThe solution proceeds by implementing the described algorithm. The core of the problem lies in recognizing that a signal composed of a few sinusoids has a sparse representation in the frequency domain. The Discrete Fourier Transform (DFT), efficiently computed via the Fast Fourier Transform (FFT), is the tool to move between the time and frequency domains.\n\nThe initial signal, $x[n]$, is constructed as a sum of $K$ cosine functions whose frequencies $f_i$ are integer multiples of the fundamental frequency $1/N$. This ensures that the signal's energy in the frequency domain is concentrated perfectly at the DFT bins corresponding to $\\pm f_i$. The DFT of this real-valued signal, $X[k]$, will have $2K$ non-zero coefficients due to the conjugate symmetry property $X[k] = X[N-k]^*$. The set of these non-zero frequency bins is denoted by $\\mathcal{S}$.\n\nWhen samples are missing, which is modeled by multiplying the signal $x[n]$ with a binary mask $m[n]$, the resulting signal is $x_{\\mathrm{mask}}[n] = x[n] \\cdot m[n]$. According to the convolution theorem of the DFT, this multiplication in the time domain corresponds to a circular convolution in the frequency domain: $X_{\\mathrm{mask}}[k] = (X * M)[k]$, where $M[k]$ is the DFT of the mask. The spectrum of the mask, $M[k]$, is generally not sparse and has significant energy across all frequencies. The convolution spreads the sparse energy of $X[k]$ across the entire spectrum, creating artifacts. The initial artifact energy ratio, $r_{\\mathrm{zero}}$, quantifies this spectral leakage.\n\nThe core of the solution is the iterative inpainting algorithm, a variant of Iterative Hard Thresholding (IHT). This algorithm leverages the prior knowledge that the original signal is sparse in the frequency domain. The procedure is as follows:\n\n1.  **Initialization**: The algorithm starts with the zero-filled signal, $y^{(0)}[n] = x_{\\mathrm{mask}}[n]$.\n\n2.  **Iteration**: For each step $t$:\n    a.  **Transform to Frequency Domain**: Compute the DFT of the current estimate, $Y^{(t)}[k] = \\mathrm{FFT}(y^{(t)}[n])$. At this stage, $Y^{(t)}[k]$ will generally not be sparse due to the missing data.\n    b.  **Hard Thresholding**: The algorithm enforces the sparsity assumption by keeping only the $K_{\\mathrm{keep}}$ coefficients with the largest magnitudes and setting all others to zero. $K_{\\mathrm{keep}}$ is set to $2K$, the known number of non-zero spectral components in the original signal. This step, $\\tilde{Y}^{(t)}[k] = \\mathrm{Threshold}(Y^{(t)}[k])$, is a projection onto the set of sparse signals in the frequency domain.\n    c.  **Return to Time Domain**: An inverse FFT is applied to the thresholded spectrum, $\\tilde{y}^{(t)}[n] = \\mathrm{IFFT}(\\tilde{Y}^{(t)}[k])$. Since numerical errors might introduce a small imaginary part, we take the real part of the result.\n    d.  **Enforce Data Consistency**: This is a critical step. The solution must be consistent with the known measurements. The values of the next iterate, $y^{(t+1)}[n]$, are updated by re-inserting the original known samples from $x[n]$ where the mask $m[n]$ is $1$. For the missing samples (where $m[n]=0$), we use the values from our sparse estimate $\\tilde{y}^{(t)}[n]$.\n        $$\n        y^{(t+1)}[n] = m[n] \\cdot x[n] + (1 - m[n]) \\cdot \\tilde{y}^{(t)}[n]\n        $$\n\n3.  **Termination**: The process is repeated until the solution stabilizes, measured by the relative change between successive iterates falling below a tolerance $\\varepsilon = 10^{-8}$, or until a maximum number of iterations $T_{\\max}$ is reached.\n\nFinally, the quality of the reconstruction is assessed. The artifact energy ratio after inpainting, $r_{\\mathrm{inpaint}}$, measures how successfully the algorithm has concentrated the spectral energy back into the true support set $\\mathcal{S}$. The normalized reconstruction error, $e$, measures the Euclidean distance between the reconstructed signal $y^{(\\ast)}[n]$ and the original signal $x[n]$, providing a direct measure of time-domain accuracy. The implementation uses `NumPy` for efficient array operations, FFT computations, and linear algebra norms.", "answer": "```python\nimport numpy as np\n\ndef run_case(N, K, freqs, amps, p_miss, K_keep, epsilon, T_max, seed):\n    \"\"\"\n    Runs a single test case for spectral inpainting.\n    \"\"\"\n    # Step 1: Construct the synthetic signal x[n]\n    n_space = np.arange(N)\n    x = np.zeros(N, dtype=np.float64)\n    for i in range(K):\n        x += amps[i] * np.cos(2 * np.pi * freqs[i] * n_space / N)\n\n    # Step 2: Create the masked signal x_mask[n]\n    rng = np.random.default_rng(seed)\n    num_missing = int(np.round(p_miss * N))\n    if num_missing  0:\n        missing_indices = rng.choice(N, size=num_missing, replace=False)\n    else:\n        missing_indices = np.array([], dtype=int)\n        \n    m = np.ones(N)\n    m[missing_indices] = 0\n    x_mask = x * m\n\n    # Step 3: Compute artifact energy ratio before inpainting (r_zero)\n    X_mask = np.fft.fft(x_mask)\n    \n    # Define the true spectral support S\n    S = set(freqs) | set((N - f) % N for f in freqs)\n    \n    is_in_S = np.zeros(N, dtype=bool)\n    is_in_S[list(S)] = True\n    \n    total_energy_mask = np.sum(np.abs(X_mask)**2)\n    if total_energy_mask == 0:\n        r_zero = 0.0\n    else:\n        artifact_energy_mask = np.sum(np.abs(X_mask[~is_in_S])**2)\n        r_zero = artifact_energy_mask / total_energy_mask\n\n    # Step 4: Perform spectral inpainting via iterative FFT thresholding\n    y_current = x_mask.copy()\n    y_rec = y_current\n    \n    for _ in range(T_max):\n        Y_current = np.fft.fft(y_current)\n        \n        # Hard-threshold in the frequency domain\n        largest_indices = np.argsort(np.abs(Y_current))[-K_keep:]\n        Y_tilde = np.zeros_like(Y_current, dtype=complex)\n        Y_tilde[largest_indices] = Y_current[largest_indices]\n        \n        # Inverse transform and take real part\n        y_tilde_real = np.real(np.fft.ifft(Y_tilde))\n        \n        # Create next iterate\n        y_next = y_tilde_real.copy()\n        # Enforce data consistency on observed samples\n        y_next[m == 1] = x[m == 1]\n        \n        # Check for convergence\n        norm_y_current = np.linalg.norm(y_current)\n        if norm_y_current  0:\n            relative_change = np.linalg.norm(y_next - y_current) / norm_y_current\n            if relative_change  epsilon:\n                y_rec = y_next\n                break\n        elif np.linalg.norm(y_next) == 0: # y_current is zero, check if y_next is also zero\n            y_rec = y_next\n            break\n        \n        y_current = y_next\n    else: # Loop finished without break\n        y_rec = y_current\n\n    # Step 5: Compute metrics for the inpainted signal (r_inpaint, e)\n    X_rec = np.fft.fft(y_rec)\n    \n    total_energy_rec = np.sum(np.abs(X_rec)**2)\n    if total_energy_rec == 0:\n        r_inpaint = 0.0\n    else:\n        artifact_energy_rec = np.sum(np.abs(X_rec[~is_in_S])**2)\n        r_inpaint = artifact_energy_rec / total_energy_rec\n        \n    norm_x = np.linalg.norm(x)\n    if norm_x == 0:\n        e = 0.0 if np.linalg.norm(y_rec) == 0 else np.inf\n    else:\n        e = np.linalg.norm(y_rec - x) / norm_x\n        \n    return [r_zero, r_inpaint, e]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 1024, 'K': 3, 'freqs': [50, 123, 300], 'amps': [1.0, 0.8, 0.6], 'p_miss': 0.2, 'K_keep': 6, 'epsilon': 1e-8, 'T_max': 200, 'seed': 1},\n        {'N': 1024, 'K': 3, 'freqs': [50, 123, 300], 'amps': [1.0, 0.8, 0.6], 'p_miss': 0.0, 'K_keep': 6, 'epsilon': 1e-8, 'T_max': 200, 'seed': 2},\n        {'N': 2048, 'K': 5, 'freqs': [15, 77, 221, 400, 650], 'amps': [1.0, 0.5, 0.7, 0.9, 0.4], 'p_miss': 0.5, 'K_keep': 10, 'epsilon': 1e-8, 'T_max': 300, 'seed': 3},\n        {'N': 512, 'K': 1, 'freqs': [64], 'amps': [1.0], 'p_miss': 0.7, 'K_keep': 2, 'epsilon': 1e-8, 'T_max': 300, 'seed': 42},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(\n            N=case['N'],\n            K=case['K'],\n            freqs=case['freqs'],\n            amps=case['amps'],\n            p_miss=case['p_miss'],\n            K_keep=case['K_keep'],\n            epsilon=case['epsilon'],\n            T_max=case['T_max'],\n            seed=case['seed']\n        )\n        results.append(result)\n\n    # Format the final output string as specified.\n    inner_strs = []\n    for res_list in results:\n        formatted_nums = [f'{v:.6f}' for v in res_list]\n        inner_strs.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output = f\"[{','.join(inner_strs)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3195883"}]}