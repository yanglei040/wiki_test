{"hands_on_practices": [{"introduction": "To begin, let's solidify our understanding of the Compressed Sparse Row (CSR) format, one of the most common and efficient ways to store sparse matrices. This first exercise is a foundational 'decoding' task where you will reconstruct a familiar dense matrix from its compressed CSR representation. Mastering this process is the first step toward appreciating how these compact data structures can represent vast matrices with minimal memory. [@problem_id:2204554]", "problem": "In many scientific and engineering applications, matrices are often \"sparse,\" meaning most of their elements are zero. Storing all these zeros is inefficient. The Compressed Sparse Row (CSR) format is a common method for storing sparse matrices by using three one-dimensional arrays.\n\nConsider a sparse matrix $A$ of size $4 \\times 4$. In the CSR format (using 0-based indexing), this matrix is represented by the following three arrays:\n1.  An array `V` containing the non-zero elements of $A$, read row by row, from left to right.\n2.  An array `C` containing the column index for each corresponding element in `V`.\n3.  An array `R` (the row pointer) of size $m+1$ (where $m$ is the number of rows), where the $i$-th element indicates the index in `V` and `C` where the data for the $i$-th row begins. The last element of `R` is the total number of non-zero elements.\n\nThe three arrays for our $4 \\times 4$ matrix $A$ are given as follows:\n- `V = [5.1, -1.2, 2.0, -3.5, 4.0, 9.8]`\n- `C = [1, 3, 0, 2, 3, 0]`\n- `R = [0, 2, 3, 5, 6]`\n\nReconstruct the original dense $4 \\times 4$ matrix $A$. Present your answer as a $4 \\times 4$ matrix.", "solution": "We use the CSR definition with 0-based indexing. For each row index $i \\in \\{0,1,2,3\\}$, the nonzero entries of row $i$ are stored in the segments of `V` and `C` with indices $j$ from $R[i]$ to $R[i+1]-1$, where the column index is $C[j]$ and the value is $V[j]$. The last element $R[4]=6$ equals the total number of nonzeros, which matches $|V|=6$.\n\nRow $0$: indices $j=R[0]\\ldots R[1]-1=0\\ldots 1$.\n- $j=0$: $C[0]=1$, $V[0]=5.1$ gives $A_{0,1}=5.1$.\n- $j=1$: $C[1]=3$, $V[1]=-1.2$ gives $A_{0,3}=-1.2$.\nThus row $0$ is $[0,\\,5.1,\\,0,\\,-1.2]$.\n\nRow $1$: indices $j=R[1]\\ldots R[2]-1=2\\ldots 2$.\n- $j=2$: $C[2]=0$, $V[2]=2.0$ gives $A_{1,0}=2.0$.\nThus row $1$ is $[2.0,\\,0,\\,0,\\,0]$.\n\nRow $2$: indices $j=R[2]\\ldots R[3]-1=3\\ldots 4$.\n- $j=3$: $C[3]=2$, $V[3]=-3.5$ gives $A_{2,2}=-3.5$.\n- $j=4$: $C[4]=3$, $V[4]=4.0$ gives $A_{2,3}=4.0$.\nThus row $2$ is $[0,\\,0,\\,-3.5,\\,4.0]$.\n\nRow $3$: indices $j=R[3]\\ldots R[4]-1=5\\ldots 5$.\n- $j=5$: $C[5]=0$, $V[5]=9.8$ gives $A_{3,0}=9.8$.\nThus row $3$ is $[9.8,\\,0,\\,0,\\,0]$.\n\nTherefore, the reconstructed dense matrix $A$ is\n$$\n\\begin{pmatrix}\n0 & 5.1 & 0 & -1.2 \\\\\n2.0 & 0 & 0 & 0 \\\\\n0 & 0 & -3.5 & 4.0 \\\\\n9.8 & 0 & 0 & 0\n\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0 & 5.1 & 0 & -1.2 \\\\ 2.0 & 0 & 0 & 0 \\\\ 0 & 0 & -3.5 & 4.0 \\\\ 9.8 & 0 & 0 & 0\\end{pmatrix}}$$", "id": "2204554"}, {"introduction": "While CSR is efficient for computations, data is often first generated in a simpler structure like the Coordinate (COO) format, which is essentially a list of non-zero values and their coordinates. This next practice challenges you to perform a critical data transformation: converting from the intuitive COO format to the computationally powerful CSR format. This task demonstrates the algorithmic steps of sorting and indexing that are central to building efficient sparse data structures. [@problem_id:2204580]", "problem": "In scientific computing, sparse matrices, which are matrices populated primarily with zeros, are often stored in specialized formats to save memory and computational time. One such format is the Coordinate (COO) format, which represents a matrix using three arrays: `values` (containing the non-zero elements), `row_indices` (the row index of each non-zero element), and `col_indices` (the column index of each non-zero element).\n\nAnother common and more efficient format for matrix operations is the Compressed Sparse Row (CSR) format. It also uses three arrays:\n1.  `values`: An array of the non-zero values, ordered by row and then by column within each row.\n2.  `col_indices`: An array of the column indices corresponding to the elements in the `values` array.\n3.  `row_pointer`: An array of size `(number of rows + 1)`. The value `row_pointer[i]` indicates the index in the `values` array where the elements for row `i` begin. The last element of `row_pointer` is the total number of non-zero elements.\n\nConsider a 5x5 sparse matrix representing a small network, initially given in COO format. The non-zero elements are provided in an arbitrary order:\n\n`values = [3, 8, 1, 5, 9, 2, 7]`\n`row_indices = [1, 0, 4, 0, 2, 2, 4]`\n`col_indices = [2, 1, 3, 4, 3, 0, 1]`\n\nConvert this matrix representation from COO format to CSR format. Which of the following options correctly represents the resulting `values`, `col_indices`, and `row_pointer` arrays?\n\nA.\n`values = [8, 5, 3, 2, 9, 7, 1]`\n`col_indices = [1, 4, 2, 0, 3, 1, 3]`\n`row_pointer = [0, 2, 1, 2, 0, 2]`\n\nB.\n`values = [3, 8, 1, 5, 9, 2, 7]`\n`col_indices = [2, 1, 3, 4, 3, 0, 1]`\n`row_pointer = [0, 2, 3, 5, 5, 7]`\n\nC.\n`values = [8, 5, 3, 2, 9, 7, 1]`\n`col_indices = [1, 4, 2, 0, 3, 1, 3]`\n`row_pointer = [1, 3, 4, 6, 6, 8]`\n\nD.\n`values = [8, 5, 3, 2, 9, 7, 1]`\n`col_indices = [1, 4, 2, 0, 3, 1, 3]`\n`row_pointer = [0, 2, 3, 5, 5, 7]`", "solution": "We are given a sparse matrix in COO format via three arrays. Define the COO triplets as $(r_{k}, c_{k}, v_{k})$ for each nonzero entry. From the data:\n$$\n\\begin{aligned}\n&v = [3,8,1,5,9,2,7],\\\\\n&r = [1,0,4,0,2,2,4],\\\\\n&c = [2,1,3,4,3,0,1].\n\\end{aligned}\n$$\nThis yields the unordered list of triplets:\n$$\n(1,2;3),\\ (0,1;8),\\ (4,3;1),\\ (0,4;5),\\ (2,3;9),\\ (2,0;2),\\ (4,1;7).\n$$\n\nTo convert to CSR, we sort the entries by row index ascending, and within each row by column index ascending. Grouping by row and sorting within each row:\n- Row $0$: entries $(0,1;8)$ and $(0,4;5)$, already ordered by column $1<4$.\n- Row $1$: entry $(1,2;3)$.\n- Row $2$: entries $(2,0;2)$ and $(2,3;9)$, ordered by column $0<3$.\n- Row $3$: no entries.\n- Row $4$: entries $(4,1;7)$ and $(4,3;1)$, ordered by column $1<3$.\n\nConcatenating by row gives the CSR-ordered arrays:\n$$\n\\text{values} = [8,\\,5,\\,3,\\,2,\\,9,\\,7,\\,1],\n$$\n$$\n\\text{col\\_indices} = [1,\\,4,\\,2,\\,0,\\,3,\\,1,\\,3].\n$$\n\nNext, compute the row pointer array $\\text{row\\_pointer}$ of length $5+1=6$. Count nonzeros per row:\n- Row $0$: $2$,\n- Row $1$: $1$,\n- Row $2$: $2$,\n- Row $3$: $0$,\n- Row $4$: $2$.\n\nTake cumulative sums starting at $0$:\n$$\n\\text{row\\_pointer} = [0,\\ 0+2,\\ 2+1,\\ 3+2,\\ 5+0,\\ 5+2] = [0,\\,2,\\,3,\\,5,\\,5,\\,7].\n$$\n\nComparing with the options, this matches option D exactly.", "answer": "$$\\boxed{D}$$", "id": "2204580"}, {"introduction": "With a solid grasp of CSR, we now address a more strategic question: is it always the most efficient format? This hands-on problem asks you to compare the memory footprint of CSR against another scheme, the Diagonal (DIA) format, for a specific \"arrowhead\" matrix structure. By mathematically modeling the memory costs, you will discover that the optimal storage format is not universal but depends critically on the matrix's specific pattern of non-zero elements. [@problem_id:2204576]", "problem": "In scientific computing, sparse matrices, which are matrices populated primarily with zeros, are often stored in specialized formats to conserve memory. Consider an $N \\times N$ \"arrowhead\" matrix, defined as a matrix where the only non-zero elements are located on the main diagonal, the first row, and the first column.\n\nWe want to compare the memory efficiency of two common storage formats for this matrix: Compressed Sparse Row (CSR) and Diagonal (DIA).\n\nAssume that non-zero values are stored as double-precision floating-point numbers (8 bytes each) and all row/column indices and pointers are stored as integers (4 bytes each).\n\nThe memory requirements for each format are defined as follows:\n\n1.  **Compressed Sparse Row (CSR)**: This format uses three arrays:\n    *   `values`: An array of size `nnz` storing the non-zero values, where `nnz` is the total number of non-zero elements.\n    *   `col_indices`: An array of size `nnz` storing the column index of each non-zero element.\n    *   `row_pointer`: An array of size $N+1$ storing the index into the `values` array that marks the start of each row.\n\n2.  **Diagonal (DIA)**: This format is optimized for matrices with non-zeros along a few diagonals. It uses two arrays:\n    *   `offsets`: An array of size `d` that stores the offset of each diagonal from the main diagonal, where `d` is the number of non-zero diagonals.\n    *   `values`: A dense $N \\times d$ array. Each column of this array stores the elements of one of the non-zero diagonals. If a diagonal has fewer than $N$ elements, the corresponding column in the `values` array is padded with zeros.\n\nDetermine the smallest integer dimension $N \\ge 2$ for which the total memory required by the CSR format is strictly less than the total memory required by the DIA format for storing an arrowhead matrix.", "solution": "An $N \\times N$ arrowhead matrix has non-zero entries on the main diagonal, the first row, and the first column. Counting unique non-zeros:\n- Main diagonal contributes $N$ entries.\n- First row contributes $N-1$ additional entries (excluding the $(0,0)$ overlap).\n- First column contributes $N-1$ additional entries (excluding the $(0,0)$ overlap).\nTherefore, the total number of non-zeros is\n$$\n\\text{nnz} = N + (N - 1) + (N - 1) = 3N - 2.\n$$\n\nFor CSR:\n- The `values` array stores $\\text{nnz}$ doubles: $8(3N - 2)$ bytes.\n- The `col\\_indices` array stores $\\text{nnz}$ integers: $4(3N - 2)$ bytes.\n- The `row\\_pointer` array stores $N+1$ integers: $4(N+1)$ bytes.\nThus the total CSR memory is\n$$\nM_{\\text{CSR}} = 8(3N - 2) + 4(3N - 2) + 4(N+1) = 12(3N - 2) + 4(N+1) = 40N - 20.\n$$\n\nFor DIA:\n- The number of non-zero diagonals equals the number of distinct offsets present among the main diagonal, first row, and first column. The offsets from the first row are $\\{0,1,2,\\ldots,N-1\\}$, and from the first column are $\\{0,-1,-2,\\ldots,-(N-1)\\}$, so the union is $\\{-(N-1),\\ldots,0,\\ldots,(N-1)\\}$, giving\n$$\nd = 2N - 1.\n$$\n- The `offsets` array stores $d$ integers: $4(2N - 1)$ bytes.\n- The `values` array is dense $N \\times d$ doubles: $8N(2N - 1)$ bytes.\nThus the total DIA memory is\n$$\nM_{\\text{DIA}} = 4(2N - 1) + 8N(2N - 1) = (8N + 4)(2N - 1) = 16N^{2} - 4.\n$$\n\nWe seek the smallest integer $N \\geq 2$ such that $M_{\\text{CSR}} < M_{\\text{DIA}}$:\n$$\n40N - 20 < 16N^{2} - 4\n$$\n$$\n\\Longleftrightarrow \\quad 16N^{2} - 40N + 16 > 0\n$$\n$$\n\\Longleftrightarrow \\quad 16(N - 2)\\left(N - \\frac{1}{2}\\right) > 0.\n$$\nThis inequality holds for $N > 2$. At $N = 2$, both formats use the same memory. Therefore, the smallest integer $N \\geq 2$ for which CSR uses strictly less memory than DIA is $N = 3$.", "answer": "$$\\boxed{3}$$", "id": "2204576"}]}