{"hands_on_practices": [{"introduction": "Beyond setting fixed values at boundaries, many physical problems involve conditions on rates or fluxes, such as convective heat transfer. This exercise explores how the Finite Element Method elegantly incorporates these \"natural\" boundary conditions, like the Robin condition, directly into its weak formulation. By implementing a 1D diffusion model [@problem_id:3129727], you will see firsthand how the boundary integral, which arises from integration by parts, is not an inconvenient leftover but a powerful mechanism for modeling physical interactions at the domain's edge.", "problem": "Consider the one-dimensional steady diffusion model on the interval $[0,1]$ with constant conductivity $k$ and a spatially uniform source $f(x)$, governed by the conservation law $-\\dfrac{d}{dx}\\!\\left(k \\dfrac{du}{dx}\\right) = f(x)$. Impose a Dirichlet boundary condition at the left endpoint $x=0$ and a Robin boundary condition (RBC) at the right endpoint $x=1$ that emulates convective cooling, expressed as $k \\nabla u \\cdot n + \\alpha u = g$ with outward normal $n$ at $x=1$. In one dimension with outward normal $n=+1$ at $x=1$, this reduces to $k \\dfrac{du}{dx}(1) + \\alpha u(1) = g$, and for convective cooling to an ambient level $u_{\\infty}$ one commonly sets $g = \\alpha u_{\\infty}$, equivalently $k \\dfrac{du}{dx}(1) + \\alpha \\big(u(1) - u_{\\infty}\\big) = 0$. All quantities are nondimensional.\n\nStarting from the conservation law $-\\dfrac{d}{dx}\\!\\left(k \\dfrac{du}{dx}\\right) = f(x)$ and the boundary conditions, derive the weak formulation by the principle of virtual work: multiply by a suitable test function, integrate over $[0,1]$, and apply integration by parts to expose the boundary integral that represents the Robin boundary condition. Then design a conforming Galerkin finite element method using piecewise linear basis functions on a uniform mesh with $N$ elements, and weakly impose the Robin boundary condition via the boundary integral term. Assemble the global linear system consistent with this weak imposition, enforce the Dirichlet boundary condition at $x=0$, and solve the resulting system to obtain the nodal approximation of $u$.\n\nUse the following fixed parameters for the model:\n- Interval length $L = 1$,\n- Number of uniform elements $N = 40$ (so the mesh size is $h = L/N$),\n- Constant conductivity $k = 2$,\n- Uniform source $f(x) \\equiv 1$,\n- Dirichlet boundary data at $x=0$: $u(0) = U_0$ with $U_0 = 2$,\n- Ambient level $u_{\\infty} = 1$ at $x=1$,\n- Robin coefficient $\\alpha$ varies over a test suite to emulate different convective cooling strengths.\n\nTest suite:\n- Case $1$: $\\alpha = 0.0$ (pure Neumann limit when $g=\\alpha u_{\\infty}=0$),\n- Case $2$: $\\alpha = 0.5$,\n- Case $3$: $\\alpha = 5.0$,\n- Case $4$: $\\alpha = 100.0$ (approaches a Dirichlet-like clamp to the ambient).\n\nFor each case, set $g = \\alpha u_{\\infty}$ and compute the finite element solution. Extract and report the value of the right-endpoint temperature $u(1)$ (which is the nodal value at $x=1$ in the mesh) for each case.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite $\\big[\\alpha=\\text{Case }1, \\alpha=\\text{Case }2, \\alpha=\\text{Case }3, \\alpha=\\text{Case }4\\big]$. For example, an acceptable format is $[u_1,u_2,u_3,u_4]$, where each $u_i$ is the computed right-endpoint value $u(1)$ for the corresponding $\\alpha$ case.\n- All quantities are nondimensional, so no physical units are required in the output.\n- Each reported quantity must be a real number (a float).", "solution": "### 1. Weak Formulation\n\nThe governing partial differential equation (PDE), or strong form, is the one-dimensional steady diffusion equation on the domain $\\Omega = [0,1]$:\n$$-\\dfrac{d}{dx}\\!\\left(k \\dfrac{du}{dx}\\right) = f(x) \\quad \\text{for } x \\in (0,1)$$\nThe boundary conditions are:\n1.  Dirichlet condition at $x=0$: $u(0) = U_0$.\n2.  Robin condition at $x=1$: $k \\dfrac{du}{dx}(1) + \\alpha u(1) = g$.\n\nTo derive the weak formulation, we follow the principle of virtual work. We multiply the PDE by an arbitrary test function $v(x)$ and integrate over the domain $\\Omega$. The test function $v$ belongs to a space of functions where the solution is sought, but with homogeneous essential (Dirichlet) boundary conditions. Here, the space is $V = \\{ v \\in H^1(0,1) \\mid v(0)=0 \\}$, where $H^1(0,1)$ is the Sobolev space of functions with square-integrable first derivatives.\n\n$$-\\int_0^1 \\dfrac{d}{dx}\\!\\left(k \\dfrac{du}{dx}\\right) v(x) \\, dx = \\int_0^1 f(x) v(x) \\, dx$$\n\nWe apply integration by parts to the left-hand side term to reduce the order of the derivative on the trial function $u$ and transfer a derivative to the test function $v$:\n$$\\int_0^1 k \\dfrac{du}{dx} \\dfrac{dv}{dx} \\, dx - \\left[ k \\dfrac{du}{dx} v(x) \\right]_0^1 = \\int_0^1 f(x) v(x) \\, dx$$\n\nNext, we evaluate the boundary term $\\left[ k \\frac{du}{dx} v \\right]_0^1 = k \\frac{du}{dx}(1) v(1) - k \\frac{du}{dx}(0) v(0)$. Because the test function $v$ must satisfy the homogeneous Dirichlet condition $v(0)=0$, the term at $x=0$ vanishes. This leaves:\n$$\\int_0^1 k \\dfrac{du}{dx} \\dfrac{dv}{dx} \\, dx - k \\dfrac{du}{dx}(1) v(1) = \\int_0^1 f(x) v(x) \\, dx$$\n\nThis is where the Robin boundary condition is naturally incorporated. The condition is $k \\frac{du}{dx}(1) = g - \\alpha u(1)$. Substituting this expression for the flux term $k \\frac{du}{dx}(1)$ into our equation, we get:\n$$\\int_0^1 k \\dfrac{du}{dx} \\dfrac{dv}{dx} \\, dx - (g - \\alpha u(1)) v(1) = \\int_0^1 f(x) v(x) \\, dx$$\n\nRearranging the terms to place all expressions involving the unknown solution $u$ on the left-hand side (LHS) and all other terms on the right-hand side (RHS), we arrive at the weak formulation: Find $u(x)$ such that $u(0) = U_0$ and for all test functions $v \\in V$:\n$$\\int_0^1 k \\dfrac{du}{dx} \\dfrac{dv}{dx} \\, dx + \\alpha u(1) v(1) = \\int_0^1 f(x) v(x) \\, dx + g v(1)$$\n\nThis is of the standard form $a(u,v) = L(v)$, where:\n-   The bilinear form is $a(u,v) = \\int_0^1 k u'v' \\, dx + \\alpha u(1)v(1)$.\n-   The linear functional is $L(v) = \\int_0^1 fv \\, dx + gv(1)$.\n\n### 2. Galerkin Finite Element Discretization\n\nWe discretize the domain $[0,1]$ into $N$ uniform elements of length $h = 1/N$. This creates $N+1$ nodes located at $x_i = i h$ for $i=0, 1, \\dots, N$. We approximate the solution $u(x)$ as a linear combination of piecewise linear basis functions $\\phi_j(x)$:\n$$u_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x)$$\nwhere $U_j$ are the unknown nodal values, $U_j \\approx u(x_j)$, and $\\phi_j(x)$ is the \"hat\" function which is equal to $1$ at node $x_j$ and $0$ at all other nodes $x_i$ ($i \\neq j$).\n\nThe Galerkin method uses the basis functions themselves as test functions, i.e., $v(x) = \\phi_i(x)$ for $i=0, 1, \\dots, N$. Substituting the approximation $u_h(x)$ and $v(x) = \\phi_i(x)$ into the weak form gives a system of $N+1$ linear algebraic equations:\n$$\\sum_{j=0}^{N} U_j \\left( \\int_0^1 k \\phi_j'(x) \\phi_i'(x) \\,dx + \\alpha \\phi_j(1) \\phi_i(1) \\right) = \\int_0^1 f(x) \\phi_i(x) \\, dx + g \\phi_i(1)$$\nThis can be written in matrix form as $\\mathbf{K} \\mathbf{U} = \\mathbf{F}$, where $\\mathbf{U} = [U_0, U_1, \\dots, U_N]^T$ is the vector of nodal unknowns. The entries of the global stiffness matrix $\\mathbf{K}$ and force vector $\\mathbf{F}$ are:\n$$K_{ij} = a(\\phi_j, \\phi_i) = \\int_0^1 k \\phi_j' \\phi_i' \\,dx + \\alpha \\phi_j(1) \\phi_i(1)$$\n$$F_i = L(\\phi_i) = \\int_0^1 f \\phi_i \\, dx + g \\phi_i(1)$$\n\n### 3. System Assembly and Boundary Conditions\n\nThe global system is assembled by summing contributions from each element. For a generic element $e$ spanning $[x_{e-1}, x_e]$ with length $h$, the element stiffness matrix $\\mathbf{k}^e$ and force vector $\\mathbf{f}^e$ for constant $k$ and $f$ are:\n$$\\mathbf{k}^e = \\frac{k}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad \\mathbf{f}^e = \\frac{fh}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$$\n\n**Assembly:** The global matrix $\\mathbf{K}$ and vector $\\mathbf{F}$ are initially zero. For each element, $\\mathbf{k}^e$ and $\\mathbf{f}^e$ are added to the corresponding global entries. After assembly, $\\mathbf{K}$ is a tridiagonal matrix, and $\\mathbf{F}$ is formed from the elemental contributions.\n\n**Robin Boundary Condition:** The Robin condition at $x=1$ affects the terms involving $u(1)$ and $v(1)$. Since $\\phi_j(1) = \\delta_{jN}$ and $\\phi_i(1) = \\delta_{iN}$, the boundary term contribution is non-zero only when both $i=N$ and $j=N$.\n-   The term $\\alpha \\phi_j(1) \\phi_i(1)$ adds $\\alpha$ to the matrix entry $K_{N,N}$.\n-   The term $g \\phi_i(1)$ adds $g$ to the vector entry $F_N$.\n-   With $g = \\alpha u_\\infty$, the final system before applying the Dirichlet condition has $K_{N,N} = k/h + \\alpha$ and $F_N = fh/2 + \\alpha u_\\infty$.\n\n**Dirichlet Boundary Condition:** The condition $u(0) = U_0$ fixes the value of $U_0$. This is an essential boundary condition. We enforce it by partitioning the system. The equation for the first node, $U_0$, is removed, and its known value is substituted into the remaining equations. The unknowns are $U_1, \\dots, U_N$. The $i$-th equation (for $i \\in \\{1, \\dots, N\\}$) of the full system is $\\sum_{j=0}^{N} K_{ij} U_j = F_i$. This can be rewritten as:\n$$K_{i0} U_0 + \\sum_{j=1}^{N} K_{ij} U_j = F_i \\implies \\sum_{j=1}^{N} K_{ij} U_j = F_i - K_{i0} U_0$$\nSince basis function $\\phi_0$ only overlaps with $\\phi_1$, the term $K_{i0}$ is non-zero only for $i=1$. Thus, only the first equation of the reduced system (corresponding to node $U_1$) is modified on its right-hand side.\nWe solve the reduced $N \\times N$ system $\\mathbf{A} \\mathbf{U}_{\\text{unknown}} = \\mathbf{b}$, where:\n-   $\\mathbf{U}_{\\text{unknown}} = [U_1, \\dots, U_N]^T$.\n-   $\\mathbf{A}$ is the submatrix of $\\mathbf{K}$ corresponding to indices $1, \\dots, N$.\n-   $\\mathbf{b}$ is the subvector of $\\mathbf{F}$ for indices $1, \\dots, N$, with its first element modified: $b_0 = F_1 - K_{1,0} U_0$.\n\n### 4. Numerical Implementation\nThe provided parameters are $L=1$, $N=40$, $k=2$, $f=1$, $U_0=2$, and $u_\\infty=1$. The mesh size is $h=1/40$. The program will construct the matrices and vectors as described above, solve the linear system for each value of $\\alpha$ in the test suite, and extract the value of the solution at the right endpoint, $U_N = U_{40}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a 1D steady diffusion problem using the Finite Element Method.\n\n    The problem is -d/dx(k * du/dx) = f on [0,1] with u(0)=U0\n    and a Robin condition k*du/dx(1) + alpha*u(1) = g at x=1.\n    \"\"\"\n    #\n    # 1. Define model parameters and test cases\n    #\n    L = 1.0        # Length of the domain\n    N = 40         # Number of elements\n    k = 2.0        # Thermal conductivity\n    f = 1.0        # Uniform source term\n    U0 = 2.0       # Dirichlet BC value at x=0\n    u_inf = 1.0    # Ambient level for Robin BC\n    \n    alpha_cases = [0.0, 0.5, 5.0, 100.0]\n\n    #\n    # 2. Derived parameters for FEM\n    #\n    h = L / N                  # Element size\n    num_nodes = N + 1          # Total number of nodes\n    \n    results = []\n\n    for alpha in alpha_cases:\n        #\n        # 3. Assemble the global stiffness matrix K and force vector F\n        #\n        K = np.zeros((num_nodes, num_nodes))\n        F = np.zeros(num_nodes)\n\n        # Element-level matrices\n        k_e = (k / h) * np.array([[1, -1], [-1, 1]])\n        f_e = (f * h / 2) * np.array([1, 1])\n\n        # Loop over elements to assemble global system\n        for i in range(N):\n            # Global indices for the two nodes of element i\n            node1_idx, node2_idx = i, i + 1\n            \n            # Add element stiffness contribution to global matrix\n            K[node1_idx:node2_idx+1, node1_idx:node2_idx+1] += k_e\n            \n            # Add element force contribution to global vector\n            F[node1_idx:node2_idx+1] += f_e\n\n        #\n        # 4. Apply boundary conditions\n        #\n\n        # 4.1 Apply Robin boundary condition at x=1 (node N)\n        # The weak form naturally adds terms to the last equation.\n        # a(u,v) term: alpha * u(1) * v(1) --> adds alpha to K[N,N]\n        # L(v) term: g * v(1) --> adds g to F[N]\n        g = alpha * u_inf\n        K[N, N] += alpha\n        F[N] += g\n\n        # 4.2 Apply Dirichlet boundary condition at x=0 (node 0)\n        # We partition the system to solve only for the unknown nodal values U_1, ..., U_N.\n        # The system for these N unknowns is A * U_unknown = b.\n        \n        # A is the submatrix of K corresponding to the unknown nodes (1 to N)\n        A = K[1:, 1:]\n        \n        # b is the corresponding subvector of F, modified by the known U0.\n        # The full equation for node 1 is K[1,0]*U0 + K[1,1]*U1 + ... = F[1]\n        # So, the modified RHS for the U1 equation is F[1] - K[1,0]*U0\n        b = F[1:]\n        b[0] -= K[1, 0] * U0\n        \n        #\n        # 5. Solve the linear system\n        #\n        U_unknown = np.linalg.solve(A, b)\n        \n        # The desired result is the value at the right endpoint, u(1),\n        # which corresponds to the last element of the solution vector.\n        u_at_1 = U_unknown[-1]\n        results.append(u_at_1)\n\n    #\n    # 6. Format and print the final output\n    #\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3129727"}, {"introduction": "One of the great strengths of the Finite Element Method is its ability to model complex, multi-material domains, which are ubiquitous in engineering and science. This practice investigates how FEM handles problems with discontinuous material properties, such as a composite rod made of two different metals. You will discover that the integral-based weak formulation naturally enforces the correct physical conditions at material interfaces, and you will quantify the importance of using an integration scheme that is \"aware\" of these jumps to maintain accuracy [@problem_id:3129650].", "problem": "Consider the one-dimensional boundary value problem on the interval $[0,1]$ with heterogeneous material properties described by the partial differential equation $- \\dfrac{d}{dx}\\big(k(x)\\,u'(x)\\big) = f(x)$, subject to Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$. Assume a piecewise-constant conductivity $k(x)$ with a single jump discontinuity at an interface location $\\xi \\in (0,1)$ given by\n$$\nk(x) = \\begin{cases}\nk_1, & x < \\xi,\\\\\nk_2, & x \\ge \\xi,\n\\end{cases}\n$$\nand a constant right-hand side $f(x) = 1$.\n\nStarting from the variational formulation of the problem (i.e., multiply by a test function $v(x)$ and integrate by parts), derive the bilinear form and the linear functional in the weak formulation using the Sobolev space $H_0^1([0,1])$. Use the standard piecewise-linear (hat) functions on a uniform mesh with $N$ elements to construct a Galerkin approximation. In the aligned case where $\\xi$ coincides with a mesh node, the element-wise integral $\\int k(x)\\,dx$ reduces to $k_e\\,h$, where $k_e$ is constant on the element and $h$ is the element length. In the misaligned case where the interface lies strictly inside an element, implement two assembly strategies:\n- An interface-aware strategy that computes the element-wise integral $\\int k(x)\\,dx$ exactly by splitting the element at $x=\\xi$ and summing contributions from the subsegments with $k_1$ and $k_2$.\n- An interface-unaware strategy that approximates the element-wise integral using the midpoint quadrature rule, i.e., $\\int k(x)\\,dx \\approx k(x_m)\\,h$ with $x_m$ the element midpoint, thus not enforcing interface conditions within the element.\n\nFrom fundamental principles, show that interface conditions, namely the continuity of $u(x)$ and the continuity of the flux $k(x)\\,u'(x)$ at $x=\\xi$, emerge naturally from the weak formulation. Using these principles, implement a finite element method (FEM) solver that:\n1. Assembles the global stiffness matrix from the element matrices derived from $\\int k(x)\\,dx$ and the derivatives of the basis functions.\n2. Assembles the global load vector using $\\int f(x)\\,N_i(x)\\,dx$ for each basis function $N_i(x)$.\n3. Enforces Dirichlet boundary conditions at $x=0$ and $x=1$.\n\nFor validation, derive the exact solution $u(x)$ for $f(x)=1$ and piecewise-constant $k(x)$ by solving the ordinary differential equations $u''(x) = -\\dfrac{1}{k_1}$ on $[0,\\xi)$ and $u''(x) = -\\dfrac{1}{k_2}$ on $[\\xi,1]$, applying $u(0)=0$, $u(1)=0$, and the interface conditions $u(\\xi^-)=u(\\xi^+)$ and $k_1\\,u'(\\xi^-)=k_2\\,u'(\\xi^+)$. Use this exact solution to compute the $L^2$-norm of the error between the FEM approximation and the exact solution,\n$$\n\\|u - u_h\\|_{L^2(0,1)} = \\left( \\int_0^1 \\big(u(x) - u_h(x)\\big)^2\\,dx \\right)^{1/2},\n$$\nvia sufficiently accurate numerical quadrature.\n\nYour program must evaluate the $L^2$ error for the following test suite, which explores aligned versus misaligned meshes and interface-aware versus interface-unaware strategies, including an edge case with high contrast in $k(x)$ and a case where the interface is very close to a mesh node:\n- Test $1$: $N=20$, $\\xi=0.5$, $k_1=1$, $k_2=5$, interface-aware assembly $\\text{True}$.\n- Test $2$: $N=20$, $\\xi=0.47$, $k_1=1$, $k_2=5$, interface-aware assembly $\\text{True}$.\n- Test $3$: $N=20$, $\\xi=0.47$, $k_1=1$, $k_2=5$, interface-aware assembly $\\text{False}$.\n- Test $4$: $N=40$, $\\xi=0.3$, $k_1=0.01$, $k_2=100$, interface-aware assembly $\\text{False}$.\n- Test $5$: $N=40$, $\\xi=0.025$, $k_1=2$, $k_2=3$, interface-aware assembly $\\text{True}$.\n\nAll quantities are dimensionless. Your program should produce a single line of output containing the $L^2$-errors for the five test cases as a comma-separated list of floating-point numbers rounded to six decimal places, enclosed in square brackets, i.e., in the format $[e_1,e_2,e_3,e_4,e_5]$ where each $e_i$ is a float.", "solution": "### 1. Weak Formulation\nThe strong form of the boundary value problem is given by:\n$$\n- \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) = f(x), \\quad x \\in (0,1)\n$$\nwith Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$. The solution $u(x)$ and test functions $v(x)$ are sought in the Sobolev space $H_0^1([0,1])$, which consists of functions that are square-integrable, have square-integrable weak derivatives, and satisfy the homogeneous boundary conditions.\n\nTo derive the weak formulation, we multiply the partial differential equation by a test function $v \\in H_0^1([0,1])$ and integrate over the domain $[0,1]$:\n$$\n-\\int_0^1 \\frac{d}{dx}\\left(k(x) u'(x)\\right) v(x) \\, dx = \\int_0^1 f(x) v(x) \\, dx\n$$\nwhere $u'(x) = \\frac{du}{dx}$. We apply integration by parts to the left-hand side:\n$$\n\\int_0^1 k(x) u'(x) v'(x) \\, dx - \\left[ k(x) u'(x) v(x) \\right]_0^1 = \\int_0^1 f(x) v(x) \\, dx\n$$\nSince the test function $v \\in H_0^1([0,1])$, we have $v(0) = v(1) = 0$, which causes the boundary term to vanish. The resulting weak formulation is: Find $u \\in H_0^1([0,1])$ such that\n$$\na(u,v) = L(v) \\quad \\forall v \\in H_0^1([0,1])\n$$\nwhere the bilinear form $a(u,v)$ and the linear functional $L(v)$ are defined as:\n$$\na(u,v) = \\int_0^1 k(x) u'(x) v'(x) \\, dx\n$$\n$$\nL(v) = \\int_0^1 f(x) v(x) \\, dx\n$$\n\n### 2. Interface Conditions\nThe weak formulation naturally incorporates the physical interface conditions. If we assume the solution $u$ is twice differentiable on the subdomains $[0, \\xi)$ and $(\\xi, 1]$, and we integrate by parts over these subdomains separately, we obtain:\n$$\n\\int_0^\\xi k_1 u' v' dx - [k_1 u' v]_0^{\\xi^-} + \\int_\\xi^1 k_2 u' v' dx - [k_2 u' v]_{\\xi^+}^1 = \\int_0^1 f v dx\n$$\nUsing $v(0)=v(1)=0$, this simplifies to:\n$$\n\\int_0^1 k u' v' dx + [k_2 u'(\\xi^+) - k_1 u'(\\xi^-)] v(\\xi) = \\int_0^1 f v dx\n$$\nComparing this with the weak formulation, we see that for the two to be equivalent for every $v \\in H_0^1([0,1])$, the term $[k_2 u'(\\xi^+) - k_1 u'(\\xi^-)] v(\\xi)$ must be zero. Since we can choose a test function $v$ such that $v(\\xi) \\neq 0$, we must have $k_1 u'(\\xi^-) = k_2 u'(\\xi^+)$. This is the continuity of flux condition, which emerges as a natural boundary condition from the weak form. The continuity of the solution $u(\\xi^-) = u(\\xi^+)$ is an essential condition, enforced by seeking a solution $u$ in the space $H^1([0,1])$.\n\n### 3. Finite Element Discretization\nWe discretize the domain $[0,1]$ into $N$ uniform elements of length $h = 1/N$. The nodes are $x_i = i h$ for $i=0, 1, \\dots, N$. The finite element solution $u_h(x)$ is approximated as a linear combination of piecewise-linear basis (hat) functions $N_j(x)$:\n$$\nu_h(x) = \\sum_{j=0}^{N} U_j N_j(x)\n$$\nwhere $U_j$ are the unknown nodal values. The boundary conditions $u(0)=0$ and $u(1)=0$ imply $U_0 = 0$ and $U_N = 0$, so the sum is effectively over the $N-1$ interior nodes.\n\nSubstituting $u_h(x)$ into the weak form and choosing the test functions to be the basis functions themselves ($v(x) = N_i(x)$ for $i=1, \\dots, N-1$), we obtain the Galerkin system of linear equations $K \\mathbf{U} = \\mathbf{F}$:\n$$\n\\sum_{j=1}^{N-1} U_j \\underbrace{\\left( \\int_0^1 k(x) N'_j(x) N'_i(x) \\, dx \\right)}_{K_{ij}} = \\underbrace{\\int_0^1 f(x) N_i(x) \\, dx}_{F_i}\n$$\nwhere $\\mathbf{U}$ is the vector of unknown nodal values $[U_1, \\dots, U_{N-1}]^T$.\n\n### 4. System Assembly\nThe stiffness matrix $K$ and load vector $\\mathbf{F}$ are assembled from element-wise contributions. For an element $e$ spanning $[x_e, x_{e+1}]$, the local basis functions have derivatives $\\pm 1/h$. The $2 \\times 2$ element stiffness matrix $K^e$ is:\n$$\nK^e = \\frac{1}{h^2} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} \\int_{x_e}^{x_{e+1}} k(x) \\, dx\n$$\nThe crucial term is the integral of the conductivity, $I_e = \\int_{x_e}^{x_{e+1}} k(x) \\, dx$.\n- **Interface-aware strategy**: $I_e$ is computed exactly. If the interface $\\xi$ is in $(x_e, x_{e+1})$, the integral is split: $I_e = \\int_{x_e}^{\\xi} k_1 dx + \\int_{\\xi}^{x_{e+1}} k_2 dx = k_1(\\xi-x_e) + k_2(x_{e+1}-\\xi)$. Otherwise, $I_e$ is either $k_1 h$ or $k_2 h$.\n- **Interface-unaware strategy**: $I_e$ is approximated using the midpoint rule: $I_e \\approx k(x_m)h$, where $x_m = (x_e+x_{e+1})/2$. This assigns a single conductivity value to the entire element based on its midpoint, ignoring any sub-element variation.\n\nFor the load vector with $f(x)=1$, the entry for an interior node $i$ is $F_i = \\int_0^1 N_i(x) dx$. The integral of a hat function over its support is its area, which is $\\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times 2h \\times 1 = h$. Thus, $F_i = h$ for all interior nodes.\n\nAfter assembly, the $(N-1) \\times (N-1)$ tridiagonal system $K \\mathbf{U} = \\mathbf{F}$ is solved for the nodal values $\\mathbf{U}$.\n\n### 5. Exact Solution\nFor a piecewise-constant $k(x)$ and constant forcing $f(x)=1$, the ODEs are $u_1''(x) = -1/k_1$ for $x \\in [0, \\xi)$ and $u_2''(x) = -1/k_2$ for $x \\in [\\xi, 1]$. Double integration yields:\n$$\nu_1(x) = -\\frac{x^2}{2k_1} + C_1 x + D_1\n$$\n$$\nu_2(x) = -\\frac{x^2}{2k_2} + C_2 x + D_2\n$$\nApplying the four conditions ($u(0)=0$, $u(1)=0$, $u(\\xi^-)=u(\\xi^+)$, $k_1 u'(\\xi^-)=k_2 u'(\\xi^+)$) allows for the determination of the four constants of integration $C_1, C_2, D_1, D_2$. The solution is:\n$$\nu(x) = \\begin{cases}\n-\\frac{x^2}{2k_1} + C_1 x, & x < \\xi \\\\\n-\\frac{x^2}{2k_2} + C_2 x + D_2, & x \\ge \\xi\n\\end{cases}\n$$\nwith $D_1=0$ and\n$$\nC_1 = \\frac{k_1(1-\\xi^2) + k_2 \\xi^2}{2k_1(k_1(1-\\xi) + k_2 \\xi)}, \\quad C_2 = \\frac{k_1(1-\\xi^2) + k_2 \\xi^2}{2k_2(k_1(1-\\xi) + k_2 \\xi)}, \\quad D_2 = \\frac{(\\xi^2-\\xi)(k_1-k_2)}{2k_2(k_1(1-\\xi) + k_2 \\xi)}\n$$\n\n### 6. Error Computation\nThe accuracy of the FEM solution $u_h(x)$ is measured by the $L^2$-norm of the error, $\\|u - u_h\\|_{L^2(0,1)}$:\n$$\n\\|u - u_h\\|_{L^2(0,1)} = \\left( \\int_0^1 \\big(u(x) - u_h(x)\\big)^2\\,dx \\right)^{1/2}\n$$\nThis integral is computed numerically using a high-order quadrature rule. Here, the trapezoidal rule is applied on a fine grid of $10000$ points to ensure the quadrature error is negligible compared to the FEM discretization error.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # N, xi, k1, k2, is_aware\n        (20, 0.5, 1, 5, True),\n        (20, 0.47, 1, 5, True),\n        (20, 0.47, 1, 5, False),\n        (40, 0.3, 0.01, 100, False),\n        (40, 0.025, 2, 3, True),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_fem_bvp(*case)\n        results.append(error)\n\n    # Format the output as specified\n    formatted_results = [\"{:.6f}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef solve_fem_bvp(N, xi, k1, k2, is_aware):\n    \"\"\"\n    Solves the 1D BVP using FEM for a given set of parameters.\n\n    Args:\n        N (int): Number of elements.\n        xi (float): Interface location.\n        k1 (float): Conductivity for x < xi.\n        k2 (float): Conductivity for x >= xi.\n        is_aware (bool): Flag for interface-aware assembly strategy.\n\n    Returns:\n        float: The L2 norm of the error.\n    \"\"\"\n    h = 1.0 / N\n    nodes = np.linspace(0, 1, N + 1)\n    num_dof = N - 1\n\n    # 1. Assemble Stiffness Matrix K and Load Vector F\n    K = np.zeros((num_dof, num_dof))\n    F = np.full(num_dof, h)\n\n    # Pre-calculate all element integrals of k(x), denoted I_e\n    I_e = np.zeros(N)\n    for e in range(N):\n        x_e = nodes[e]\n        x_e_plus_1 = nodes[e+1]\n\n        if is_aware:\n            # Interface-aware assembly (exact integral)\n            if xi <= x_e:\n                I_e[e] = k2 * h\n            elif xi > x_e_plus_1:\n                I_e[e] = k1 * h\n            else:  # Interface is inside the element\n                I_e[e] = k1 * (xi - x_e) + k2 * (x_e_plus_1 - xi)\n        else:\n            # Interface-unaware assembly (midpoint rule)\n            x_m = (x_e + x_e_plus_1) / 2.0\n            k_mid = k1 if x_m < xi else k2\n            I_e[e] = k_mid * h\n\n    # Assemble K for interior nodes (DoFs 1 to N-1)\n    for i in range(num_dof):  # Matrix index i from 0 to N-2\n        # Diagonal entry K[i, i] corresponds to node i+1\n        # Contribution from element i and element i+1\n        K[i, i] = (I_e[i] + I_e[i+1]) / (h ** 2)\n        # Off-diagonal entries\n        if i > 0:\n            K[i, i - 1] = -I_e[i] / (h ** 2)\n        if i < num_dof - 1:\n            K[i, i + 1] = -I_e[i+1] / (h ** 2)\n\n    # 2. Solve the linear system for interior node values\n    U_interior = np.linalg.solve(K, F)\n\n    # Reconstruct full solution vector including boundary conditions\n    U_full = np.zeros(N + 1)\n    U_full[1:N] = U_interior\n\n    # 3. Calculate L2 error\n    # Define exact solution function\n    def get_exact_solution(xi_p, k1_p, k2_p):\n        A = k1_p * (1 - xi_p) + k2_p * xi_p\n        if np.isclose(A, 0): # Should not happen with positive k values\n            return lambda x: 0.0\n\n        C1_num = k1_p * (1 - xi_p**2) + k2_p * xi_p**2\n        C1 = C1_num / (2 * k1_p * A)\n        C2 = C1_num / (2 * k2_p * A)\n        D2 = ((xi_p**2 - xi_p) * (k1_p - k2_p)) / (2 * k2_p * A)\n\n        def u_exact(x):\n            if x < xi_p:\n                return -x**2 / (2 * k1_p) + C1 * x\n            else:\n                return -x**2 / (2 * k2_p) + C2 * x + D2\n        return u_exact\n\n    u_exact_func = get_exact_solution(xi, k1, k2)\n\n    # Define FEM solution function\n    def u_h(x, nodes_h, U_sol, h_val):\n        if x <= 0.0: return 0.0\n        if x >= 1.0: return 0.0\n        \n        i = int(np.floor(x / h_val))\n        x_i = nodes_h[i]\n        # Linear interpolation within element i\n        val = U_sol[i] * (nodes_h[i+1] - x) / h_val + U_sol[i+1] * (x - x_i) / h_val\n        return val\n\n    # Numerical integration for L2 norm using a fine grid\n    num_quad_points = 10000\n    quad_points = np.linspace(0, 1, num_quad_points + 1)\n    \n    # Vectorized evaluation over the fine grid\n    exact_vals = np.array([u_exact_func(x) for x in quad_points])\n    fem_vals = np.array([u_h(x, nodes, U_full, h) for x in quad_points])\n\n    squared_errors = (exact_vals - fem_vals)**2\n    \n    # Trapezoidal rule for integration\n    integral = np.trapz(squared_errors, quad_points)\n\n    l2_error = np.sqrt(integral)\n    \n    return l2_error\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3129650"}, {"introduction": "Moving from static to dynamic systems is a crucial step in computational modeling. This exercise serves as a gateway to transient analysis by applying FEM to the time-dependent heat equation, demonstrating a powerful strategy known as the method of lines. After performing a spatial discretization to obtain a semi-discrete system of ordinary differential equations of the form $M \\\\dot{u}(t) + K u(t) = f(t)$, you will implement and compare several classic time integration schemes [@problem_id:3129641], gaining critical insight into the trade-offs between accuracy, stability, and computational cost when solving stiff systems.", "problem": "You will write a complete, runnable program that constructs a one-dimensional Finite Element Method (FEM) semi-discrete model of the heat equation and compares three implicit time integrators in terms of accuracy and stiffness handling. The semi-discrete model has the form $M \\, \\dot{u}(t) + K \\, u(t) = f(t)$, where $M$ is the symmetric positive definite mass matrix and $K$ is the symmetric positive semidefinite stiffness matrix arising from a conforming Galerkin discretization with linear basis functions on a uniform mesh of the unit interval with homogeneous Dirichlet boundary conditions.\n\nYour implementation must be derived from the following fundamental base:\n- The strong form of the heat equation in one spatial dimension is $\\partial_t u(x,t) - \\partial_{xx} u(x,t) = s(x,t)$ with appropriate boundary and initial data.\n- The weak form is obtained by multiplying by a test function, integrating by parts in space, and applying the boundary conditions, which leads to a semi-discrete linear system of the form $M \\, \\dot{u}(t) + K \\, u(t) = f(t)$ when the spatial variable is discretized by a conforming Galerkin method using piecewise linear shape functions.\n- Time integrators are constructed by consistent time discretization of $\\dot{u}(t)$ using algebraically stable implicit schemes.\n\nFrom this base, without using any shortcut formulas, derive and then implement the following time integrators applied to the semi-discrete system:\n- Backward Euler (also called implicit Euler).\n- Crank–Nicolson.\n- Backward Differentiation Formula of order $2$ (BDF2), with a consistent one-step implicit start.\n\nYou must ensure scientific realism and correctness at every stage, including the assembly of $M$ and $K$ for the mesh and the handling of homogeneous Dirichlet boundary conditions.\n\nTo make the problem fully testable, use the following test suite and evaluation metrics, all expressed in purely mathematical terms with no physical units:\n\n1) Accuracy tests (temporal convergence at a fixed final time):\n- Let the spatial mesh have $N_\\text{el} = 50$ uniform elements on $[0,1]$, so there are $N = N_\\text{el} - 1$ interior nodes. Assemble the consistent FEM mass matrix $M$ and stiffness matrix $K$ using standard linear basis functions with homogeneous Dirichlet boundary conditions at $x=0$ and $x=1$.\n- Define the semi-discrete initial condition $u(0)$ as a linear combination of the first two generalized eigenvectors of the pencil $(K,M)$ corresponding to the two smallest generalized eigenvalues. Specifically, let $K v_i = \\lambda_i M v_i$ with $v_i^\\top M v_j = \\delta_{ij}$, and define $u(0) = 1 \\cdot v_1 + 0.5 \\cdot v_2$. Set $f(t) \\equiv 0$. The exact semi-discrete solution is then $u_\\text{exact}(t) = \\sum_{i} c_i e^{-\\lambda_i t} v_i$ with coefficients $c_i = v_i^\\top M u(0)$.\n- Choose the final time $T = 0.1$. For each method, compute the numerical solution at $T$ using two time step sizes: $\\Delta t_\\text{coarse} = T/40$ and $\\Delta t_\\text{fine} = T/80$. For each $\\Delta t$, compute the error $e(\\Delta t) = \\| u_\\text{num}(T;\\Delta t) - u_\\text{exact}(T) \\|_M$, where $\\|w\\|_M = \\sqrt{w^\\top M w}$.\n- For each method, estimate the observed temporal order of accuracy by $p = \\dfrac{\\log\\big(e(\\Delta t_\\text{coarse}) / e(\\Delta t_\\text{fine})\\big)}{\\log(2)}$.\n\n2) Stiffness handling test (damping of the stiffest mode at a large time step):\n- Let the spatial mesh have $N_\\text{el} = 200$ uniform elements on $[0,1]$, again with homogeneous Dirichlet boundary conditions, and assemble $M$ and $K$.\n- Compute the largest generalized eigenvalue $\\lambda_{\\max}$ and corresponding $M$-normalized eigenvector $v_{\\max}$ of the pencil $(K,M)$, so that $K v_{\\max} = \\lambda_{\\max} M v_{\\max}$ and $v_{\\max}^\\top M v_{\\max} = 1$.\n- Set $u(0) = v_{\\max}$ and $f(t) \\equiv 0$. Define a large time step $\\Delta t_\\text{stiff} = 50 / \\lambda_{\\max}$ and take a single time step with Backward Euler and with Crank–Nicolson. For Backward Euler and for Crank–Nicolson, compute the one-step amplification factor in the $M$-norm:\n  - $r_\\text{BE} = \\dfrac{\\|u^{1}_\\text{BE}\\|_M}{\\|u^0\\|_M}$,\n  - $r_\\text{CN} = \\dfrac{\\|u^{1}_\\text{CN}\\|_M}{\\|u^0\\|_M}$,\n  where $u^{1}_\\text{method}$ denotes the solution after one time step.\n- For BDF2, use a consistent one-step implicit start: first take one Backward Euler step to obtain $u^{1}$, then take one BDF2 step to obtain $u^{2}$. Define the per-step amplification measured on the BDF2 step by $r_\\text{BDF2} = \\dfrac{\\|u^{2}\\|_M}{\\|u^{1}\\|_M}$.\n- Additionally, detect whether Crank–Nicolson exhibits oscillatory behavior on the stiff mode by checking the sign change of the modal coefficient along $v_{\\max}$: compute $c_0 = v_{\\max}^\\top M u^{0}$ and $c_1 = v_{\\max}^\\top M u^{1}_\\text{CN}$, and set a boolean flag $\\text{osc}_\\text{CN} = \\text{True}$ if $c_0 \\cdot c_1 < 0$, otherwise $\\text{False}$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The aggregated results must be, in order:\n  - The three observed orders $p$ for Backward Euler, Crank–Nicolson, and BDF2 from the accuracy tests, each rounded to three decimals.\n  - The three amplification factors $r_\\text{BE}$, $r_\\text{CN}$, and $r_\\text{BDF2}$ from the stiffness handling test, each rounded to six decimals.\n  - The boolean flag $\\text{osc}_\\text{CN}$.\n- Concretely, the output format is $[p_\\text{BE},p_\\text{CN},p_\\text{BDF2},r_\\text{BE},r_\\text{CN},r_\\text{BDF2},\\text{osc}_\\text{CN}]$.\n\nNotes and constraints:\n- All mathematical quantities are dimensionless; no physical units are to be reported.\n- Angles do not appear; no angle units are needed.\n- Percentages are not used.\n- You must derive each time integrator from first principles based on the semi-discrete system $M \\, \\dot{u} + K \\, u = f$.\n- Use the consistent mass matrix, not a lumped mass approximation.\n- Use homogeneous Dirichlet boundary conditions by eliminating the boundary degrees of freedom.\n\nYour program must strictly adhere to the required final output format and must not read any input. It must be fully self-contained and deterministic for the prescribed test suite.", "solution": "### 1. Spatial Discretization: Finite Element Method\n\nThe problem starts with the strong form of the one-dimensional heat equation on the domain $\\Omega = [0, 1]$ with homogeneous Dirichlet boundary conditions:\n$$\n\\begin{cases}\n\\partial_t u(x,t) - \\partial_{xx} u(x,t) = s(x,t) & \\text{for } x \\in (0,1), t > 0 \\\\\nu(0,t) = 0, \\quad u(1,t) = 0 & \\text{for } t > 0 \\\\\nu(x,0) = u_0(x) & \\text{for } x \\in [0,1]\n\\end{cases}\n$$\nThe weak form is derived by multiplying the partial differential equation by a test function $v(x)$ from a suitable space (here, $H^1_0(0,1)$, the space of functions with square-integrable first derivatives that are zero at the boundaries) and integrating over the domain $\\Omega$:\n$$\n\\int_0^1 v(x) \\partial_t u(x,t) \\,dx - \\int_0^1 v(x) \\partial_{xx} u(x,t) \\,dx = \\int_0^1 v(x) s(x,t) \\,dx\n$$\nApplying integration by parts to the second term and using the homogeneous Dirichlet boundary conditions ($v(0)=v(1)=0$) yields:\n$$\n\\int_0^1 v \\partial_t u \\,dx + \\int_0^1 \\partial_x v \\partial_x u \\,dx = \\int_0^1 v s \\,dx\n$$\nFor the FEM discretization, we divide the interval $[0,1]$ into $N_\\text{el}$ uniform elements of length $h = 1/N_\\text{el}$. This creates $N = N_\\text{el} - 1$ interior nodes. The solution $u(x,t)$ is approximated by a function $u_h(x,t)$ which is a linear combination of piecewise linear basis functions $\\phi_j(x)$, often called \"hat\" functions:\n$$\nu_h(x,t) = \\sum_{j=1}^{N} u_j(t) \\phi_j(x)\n$$\nwhere $u_j(t)$ are the time-dependent nodal values of the solution and $\\phi_j(x)$ is the basis function associated with node $j$ such that $\\phi_j(x_k) = \\delta_{jk}$.\n\nFollowing the Galerkin principle, we choose the test functions to be the basis functions themselves, $v(x) = \\phi_i(x)$ for $i=1, \\dots, N$. Substituting the approximation $u_h$ into the weak form gives a system of ordinary differential equations (ODEs):\n$$\n\\sum_{j=1}^{N} \\left(\\int_0^1 \\phi_i \\phi_j \\,dx\\right) \\dot{u}_j(t) + \\sum_{j=1}^{N} \\left(\\int_0^1 \\phi'_i \\phi'_j \\,dx\\right) u_j(t) = \\int_0^1 \\phi_i s(x,t) \\,dx\n$$\nThis is the semi-discrete system $M \\dot{u}(t) + K u(t) = f(t)$, where $u(t)$ is the vector of nodal values $[u_1(t), ..., u_N(t)]^T$, and the matrices and vector are defined component-wise as:\n- **Mass Matrix**: $M_{ij} = \\int_0^1 \\phi_i(x) \\phi_j(x) \\,dx$\n- **Stiffness Matrix**: $K_{ij} = \\int_0^1 \\phi'_i(x) \\phi'_j(x) \\,dx$\n- **Load Vector**: $f_i(t) = \\int_0^1 \\phi_i(x) s(x,t) \\,dx$\n\nThe integrals for the matrix entries are computed element-wise. For linear basis functions on a uniform mesh of size $h$, the non-zero entries of the resulting tridiagonal matrices are:\n- $M_{ii} = \\int_{x_{i-1}}^{x_{i+1}} \\phi_i^2 \\,dx = \\frac{2h}{3}$\n- $M_{i, i\\pm1} = \\int_{x_{i}}^{x_{i\\pm1}} \\phi_i \\phi_{i\\pm1} \\,dx = \\frac{h}{6}$\n- $K_{ii} = \\int_{x_{i-1}}^{x_{i+1}} (\\phi'_i)^2 \\,dx = \\frac{2}{h}$\n- $K_{i, i\\pm1} = \\int_{x_{i}}^{x_{i\\pm1}} \\phi'_i \\phi'_{i\\pm1} \\,dx = -\\frac{1}{h}$\n\nThe test cases specify $s(x,t)=0$, so the load vector is $f(t) = 0$.\n\n### 2. Temporal Discretization: Implicit Time Integrators\n\nWe solve the homogeneous semi-discrete system $M \\dot{u} + K u = 0$. Let $u^n$ be the numerical approximation of $u(t_n)$ at time $t_n = n \\Delta t$.\n\n**Backward Euler (Implicit Euler)**\nThis first-order method approximates the time derivative at $t_{n+1}$: $\\dot{u}(t_{n+1}) \\approx \\frac{u^{n+1}-u^n}{\\Delta t}$. The system is evaluated at $t_{n+1}$:\n$$\nM \\left(\\frac{u^{n+1} - u^n}{\\Delta t}\\right) + K u^{n+1} = 0 \\implies (M + \\Delta t K) u^{n+1} = M u^n\n$$\nAt each time step, a linear system must be solved for $u^{n+1}$. This method is A-stable and L-stable, providing strong damping for high-frequency (stiff) components.\n\n**Crank-Nicolson**\nThis second-order method is based on the trapezoidal rule. The time derivative is approximated at the midpoint $t_{n+1/2}$, and the term $K u$ is averaged over $t_n$ and $t_{n+1}$:\n$$\nM \\left(\\frac{u^{n+1} - u^n}{\\Delta t}\\right) + K \\left(\\frac{u^n + u^{n+1}}{2}\\right) = 0 \\implies \\left(M + \\frac{\\Delta t}{2} K\\right) u^{n+1} = \\left(M - \\frac{\\Delta t}{2} K\\right) u^n\n$$\nThis method is A-stable but not L-stable. For stiff components, the amplification factor approaches $-1$, leading to persistent, non-decaying oscillations.\n\n**Backward Differentiation Formula of Order 2 (BDF2)**\nThis is a second-order, two-step method. The derivative at $t_{n+1}$ is approximated using values at $t_{n+1}$, $t_n$, and $t_{n-1}$:\n$$\n\\dot{u}(t_{n+1}) \\approx \\frac{3u^{n+1} - 4u^n + u^{n-1}}{2\\Delta t}\n$$\nSubstituting this into the ODE system gives:\n$$\nM \\left(\\frac{3u^{n+1} - 4u^n + u^{n-1}}{2\\Delta t}\\right) + K u^{n+1} = 0 \\implies (3M + 2 \\Delta t K) u^{n+1} = 4M u^n - M u^{n-1}\n$$\nSince it is a two-step method, it requires a startup procedure to compute $u^1$ from $u^0$. As specified, a single step of the first-order Backward Euler method is used for this purpose. BDF2 is stiffly stable and L-stable, making it suitable for stiff problems.\n\n### 3. Numerical Experiments and Implementation\n\nThe provided problem specifies two numerical experiments to evaluate these integrators.\n\n**Accuracy Test**: The temporal order of accuracy is measured by comparing numerical solutions to a known exact semi-discrete solution. The initial condition is a linear combination of the first two generalized eigenvectors of the pencil $(K, M)$, $u(0) = c_1 v_1 + c_2 v_2$. The exact solution to $M\\dot{u} + Ku = 0$ is then $u(t) = c_1 e^{-\\lambda_1 t} v_1 + c_2 e^{-\\lambda_2 t} v_2$. By computing the error for two different time steps, $\\Delta t_\\text{coarse}$ and $\\Delta t_\\text{fine}$, the observed order of accuracy $p$ is estimated as $p = \\log(e_\\text{coarse}/e_\\text{fine}) / \\log(2)$.\n\n**Stiffness Handling Test**: This test assesses the numerical damping of the stiffest mode, which corresponds to the largest generalized eigenvalue $\\lambda_\\text{max}$. Starting with $u(0)=v_\\text{max}$, a single large time step $\\Delta t_\\text{stiff} = 50/\\lambda_\\text{max}$ is taken. The one-step amplification factor $r$ in the $M$-norm is computed, which quantifies the damping. For BDF2, a two-step procedure is followed as defined. The tendency of Crank-Nicolson to produce oscillations is checked by observing the sign of the modal coefficient of the solution.\n\nThe implementation will construct the matrices $M$ and $K$ and then perform these tests. The generalized eigenproblem $K v_i = \\lambda_i M v_i$ is solved using `scipy.linalg.eigh`. The time-stepping schemes involve solving linear systems at each step. For efficiency, the system matrix (e.g., $M + \\Delta t K$) is factorized once using LU decomposition before the time loop.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh, lu_factor, lu_solve\n\ndef solve():\n    \"\"\"\n    Constructs a 1D FEM model for the heat equation and evaluates three implicit time integrators.\n    \"\"\"\n\n    def assemble_matrices(Nel):\n        \"\"\"Assembles the consistent mass (M) and stiffness (K) matrices for 1D FEM.\"\"\"\n        N = Nel - 1\n        h = 1.0 / Nel\n\n        # Mass Matrix M = h/6 * tridiag(1, 4, 1)\n        diag_M = np.full(N, 4.0 * h / 6.0)\n        offdiag_M = np.full(N - 1, 1.0 * h / 6.0)\n        M = np.diag(diag_M) + np.diag(offdiag_M, k=1) + np.diag(offdiag_M, k=-1)\n\n        # Stiffness Matrix K = 1/h * tridiag(-1, 2, -1)\n        diag_K = np.full(N, 2.0 / h)\n        offdiag_K = np.full(N - 1, -1.0 / h)\n        K = np.diag(diag_K) + np.diag(offdiag_K, k=1) + np.diag(offdiag_K, k=-1)\n        \n        return M, K\n\n    def compute_m_norm(vec, M):\n        \"\"\"Computes the M-norm of a vector.\"\"\"\n        return np.sqrt(vec.T @ M @ vec)\n\n    # --- Part 1: Accuracy Test ---\n    def run_accuracy_test():\n        Nel = 50\n        T = 0.1\n        N_steps_coarse = 40\n        N_steps_fine = 80\n        dt_coarse = T / N_steps_coarse\n        dt_fine = T / N_steps_fine\n\n        M, K = assemble_matrices(Nel)\n        \n        # Solve generalized eigenproblem K v = lambda M v\n        # eigh returns M-orthonormal eigenvectors\n        eigenvalues, eigenvectors = eigh(K, M)\n        lambda1, lambda2 = eigenvalues[0:2]\n        v1, v2 = eigenvectors[:, 0], eigenvectors[:, 1]\n        \n        u0 = 1.0 * v1 + 0.5 * v2\n        u_exact_T = np.exp(-lambda1 * T) * v1 + 0.5 * np.exp(-lambda2 * T) * v2\n\n        errors = {}\n        for method in ['BE', 'CN', 'BDF2']:\n            errors[method] = []\n            for dt, num_steps in [(dt_coarse, N_steps_coarse), (dt_fine, N_steps_fine)]:\n                u = np.copy(u0)\n                \n                if method == 'BE':\n                    A_lu = lu_factor(M + dt * K)\n                    for _ in range(num_steps):\n                        rhs = M @ u\n                        u = lu_solve(A_lu, rhs)\n                \n                elif method == 'CN':\n                    A_lu = lu_factor(M + 0.5 * dt * K)\n                    B = M - 0.5 * dt * K\n                    for _ in range(num_steps):\n                        rhs = B @ u\n                        u = lu_solve(A_lu, rhs)\n                \n                elif method == 'BDF2':\n                    # Startup step with Backward Euler\n                    A_be_lu = lu_factor(M + dt * K)\n                    rhs_be = M @ u\n                    u_curr = lu_solve(A_be_lu, rhs_be)\n                    u_prev = np.copy(u0)\n\n                    # BDF2 steps\n                    A_bdf2_lu = lu_factor(3 * M + 2 * dt * K)\n                    for _ in range(1, num_steps):\n                        rhs = 4 * M @ u_curr - M @ u_prev\n                        u_next = lu_solve(A_bdf2_lu, rhs)\n                        u_prev = u_curr\n                        u_curr = u_next\n                    u = u_curr\n\n                error_vec = u - u_exact_T\n                err = np.sqrt(error_vec.T @ M @ error_vec)\n                errors[method].append(err)\n        \n        # Calculate observed order of accuracy p\n        p_be = np.log(errors['BE'][0] / errors['BE'][1]) / np.log(2)\n        p_cn = np.log(errors['CN'][0] / errors['CN'][1]) / np.log(2)\n        p_bdf2 = np.log(errors['BDF2'][0] / errors['BDF2'][1]) / np.log(2)\n\n        return p_be, p_cn, p_bdf2\n\n    # --- Part 2: Stiffness Handling Test ---\n    def run_stiffness_test():\n        Nel = 200\n        M, K = assemble_matrices(Nel)\n        \n        eigenvalues, eigenvectors = eigh(K, M)\n        lambda_max = eigenvalues[-1]\n        v_max = eigenvectors[:, -1]\n        \n        u0 = v_max\n        dt = 50.0 / lambda_max\n\n        norm_u0 = compute_m_norm(u0, M)\n        if not np.isclose(norm_u0, 1.0):\n             # This should not happen with eigh, but good practice to check\n             norm_u0 = 1.0 \n\n        # Backward Euler\n        A_be = M + dt * K\n        rhs_be = M @ u0\n        u1_be = np.linalg.solve(A_be, rhs_be)\n        r_be = compute_m_norm(u1_be, M) / norm_u0\n\n        # Crank-Nicolson\n        A_cn = M + 0.5 * dt * K\n        B_cn = M - 0.5 * dt * K\n        rhs_cn = B_cn @ u0\n        u1_cn = np.linalg.solve(A_cn, rhs_cn)\n        r_cn = compute_m_norm(u1_cn, M) / norm_u0\n        \n        c0 = v_max.T @ M @ u0 # This is v_max.T @ M @ v_max = 1\n        c1 = v_max.T @ M @ u1_cn\n        osc_cn = bool(c0 * c1  0)\n\n        # BDF2\n        # u1 is from the BE startup step\n        u1 = u1_be\n        # Second step is BDF2\n        A_bdf2 = 3 * M + 2 * dt * K\n        rhs_bdf2 = 4 * M @ u1 - M @ u0\n        u2_bdf2 = np.linalg.solve(A_bdf2, rhs_bdf2)\n        \n        r_bdf2 = compute_m_norm(u2_bdf2, M) / compute_m_norm(u1, M)\n\n        return r_be, r_cn, r_bdf2, osc_cn\n\n    # --- Run tests and aggregate results ---\n    p_be, p_cn, p_bdf2 = run_accuracy_test()\n    r_be, r_cn, r_bdf2, osc_cn = run_stiffness_test()\n\n    results = [\n        round(p_be, 3),\n        round(p_cn, 3),\n        round(p_bdf2, 3),\n        round(r_be, 6),\n        round(r_cn, 6),\n        round(r_bdf2, 6),\n        osc_cn\n    ]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3129641"}]}