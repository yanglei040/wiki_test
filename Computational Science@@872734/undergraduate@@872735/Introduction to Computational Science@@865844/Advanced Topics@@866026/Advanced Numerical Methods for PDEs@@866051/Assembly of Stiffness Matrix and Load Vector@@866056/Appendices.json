{"hands_on_practices": [{"introduction": "Before automating the assembly process in a computer program, it is essential to have a solid grasp of the underlying calculations. This practice grounds the abstract theory of the Finite Element Method (FEM) by guiding you through the manual computation of a single entry in an element stiffness matrix. By deriving the value analytically and then verifying it with numerical quadrature, you will build confidence in the core mechanics of coordinate transformation and integration that form the heart of FEM analysis [@problem_id:3098496].", "problem": "Consider the steady diffusion model $-\\nabla \\cdot (A \\nabla u) = f$ on a rectangular domain, and focus on assembling the element stiffness matrix using the Finite Element Method (FEM). For a single $4$-node bilinear quadrilateral element whose physical coordinates are the rectangle with vertices at $(0,0)$, $(2,0)$, $(2,1)$, and $(0,1)$, let the material conductivity tensor be $A = \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix}$. The element mapping from the reference square $[-1,1] \\times [-1,1]$ is given by $x(\\xi,\\eta) = 1 + \\xi$ and $y(\\xi,\\eta) = \\tfrac{1}{2} + \\tfrac{1}{2}\\eta$. The standard bilinear shape functions on the reference square are\n$N_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta)$, $N_2(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1-\\eta)$, $N_3(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1+\\eta)$, and $N_4(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1+\\eta)$.\n\nStarting from the weak form definition of the element stiffness matrix, the $(i,j)$-entry is\n$$K_{e,ij} = \\int_{\\Omega_e} \\nabla N_i(x,y)^{\\top} A \\, \\nabla N_j(x,y) \\, \\mathrm{d}\\Omega,$$\nwhere $\\Omega_e$ is the physical element domain. Using only the core definitions above, do all of the following:\n- Derive analytically the value of the diagonal entry $K_{e,11}$ by mapping the integral to the reference domain and applying the chain rule for gradients.\n- Assemble $K_{e,11}$ numerically using tensor-product Gauss quadrature with $2$ points per direction on the reference square (use the standard abscissae $\\xi, \\eta = \\pm 1/\\sqrt{3}$ and weights $w_{\\xi} = w_{\\eta} = 1$), including the Jacobian determinant factor, and show it matches your analytic result.\n\nReport the single real number $K_{e,11}$. No rounding is required and no units are to be included in the answer.", "solution": "We begin from the weak form definition of the element stiffness matrix entry\n$$K_{e,11} = \\int_{\\Omega_e} \\nabla N_1(x,y)^{\\top} A \\, \\nabla N_1(x,y)\\, \\mathrm{d}\\Omega.$$\nWe will compute $K_{e,11}$ analytically and then by numerical quadrature on the reference square to verify agreement.\n\nAnalytic derivation:\nThe mapping from the reference coordinates $(\\xi,\\eta)$ to the physical coordinates $(x,y)$ is\n$$x(\\xi,\\eta) = 1 + \\xi,\\qquad y(\\xi,\\eta) = \\tfrac{1}{2} + \\tfrac{1}{2}\\eta.$$\nThe Jacobian matrix of this mapping is\n$$J = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & \\tfrac{1}{2} \\end{pmatrix},\\quad \\det(J) = \\tfrac{1}{2}.$$\nThe gradient transformation follows from $\\nabla_{x} N = J^{-T} \\nabla_{\\xi} N$, so\n$$J^{-T} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 2 \\end{pmatrix},\\qquad \\nabla_{x} N_1 = \\begin{pmatrix} \\frac{\\partial N_1}{\\partial x} \\\\ \\frac{\\partial N_1}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 2 \\end{pmatrix} \\begin{pmatrix} \\frac{\\partial N_1}{\\partial \\xi} \\\\ \\frac{\\partial N_1}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} \\frac{\\partial N_1}{\\partial \\xi} \\\\ 2 \\frac{\\partial N_1}{\\partial \\eta} \\end{pmatrix}.$$\nFor the bilinear shape function\n$$N_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta),$$\nthe derivatives are\n$$\\frac{\\partial N_1}{\\partial \\xi} = -\\tfrac{1}{4}(1-\\eta),\\qquad \\frac{\\partial N_1}{\\partial \\eta} = -\\tfrac{1}{4}(1-\\xi).$$\nThus, in physical coordinates,\n$$\\frac{\\partial N_1}{\\partial x} = -\\tfrac{1}{4}(1-\\eta),\\qquad \\frac{\\partial N_1}{\\partial y} = 2\\left(-\\tfrac{1}{4}(1-\\xi)\\right) = -\\tfrac{1}{2}(1-\\xi).$$\nWith $A = \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix}$, the integrand becomes\n$$\\nabla N_1^{\\top} A \\nabla N_1 = 2\\left(\\frac{\\partial N_1}{\\partial x}\\right)^{2} + 1\\left(\\frac{\\partial N_1}{\\partial y}\\right)^{2} = 2\\left(\\tfrac{(1-\\eta)^{2}}{16}\\right) + \\left(\\tfrac{(1-\\xi)^{2}}{4}\\right) = \\tfrac{(1-\\eta)^{2}}{8} + \\tfrac{(1-\\xi)^{2}}{4}.$$\nTransforming the integral to the reference domain yields\n$$K_{e,11} = \\int_{\\Omega_e} \\nabla N_1^{\\top} A \\nabla N_1 \\, \\mathrm{d}\\Omega = \\int_{-1}^{1}\\int_{-1}^{1} \\left(\\tfrac{(1-\\eta)^{2}}{8} + \\tfrac{(1-\\xi)^{2}}{4}\\right) \\det(J)\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta.$$\nSince $\\det(J) = \\tfrac{1}{2}$,\n$$K_{e,11} = \\tfrac{1}{2} \\left[ \\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\eta)^{2}}{8}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta + \\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\xi)^{2}}{4}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta \\right].$$\nSeparate the integrals:\n$$\\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\eta)^{2}}{8}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta = \\tfrac{1}{8}\\left( \\int_{-1}^{1} (1-\\eta)^{2}\\, \\mathrm{d}\\eta \\right)\\left( \\int_{-1}^{1} \\mathrm{d}\\xi \\right),$$\n$$\\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\xi)^{2}}{4}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta = \\tfrac{1}{4}\\left( \\int_{-1}^{1} (1-\\xi)^{2}\\, \\mathrm{d}\\xi \\right)\\left( \\int_{-1}^{1} \\mathrm{d}\\eta \\right).$$\nCompute the $1$-dimensional integrals:\n$$\\int_{-1}^{1} (1-\\eta)^{2}\\, \\mathrm{d}\\eta = \\int_{-1}^{1} (1 - 2\\eta + \\eta^{2})\\, \\mathrm{d}\\eta = \\left[\\eta - \\eta^{2} + \\tfrac{\\eta^{3}}{3}\\right]_{-1}^{1} = \\tfrac{8}{3},$$\n$$\\int_{-1}^{1} \\mathrm{d}\\xi = 2,\\qquad \\int_{-1}^{1} (1-\\xi)^{2}\\, \\mathrm{d}\\xi = \\tfrac{8}{3},\\qquad \\int_{-1}^{1} \\mathrm{d}\\eta = 2.$$\nTherefore,\n$$\\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\eta)^{2}}{8}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta = \\tfrac{1}{8}\\cdot \\tfrac{8}{3}\\cdot 2 = \\tfrac{2}{3},$$\n$$\\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\xi)^{2}}{4}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta = \\tfrac{1}{4}\\cdot \\tfrac{8}{3}\\cdot 2 = \\tfrac{4}{3}.$$\nThen\n$$K_{e,11} = \\tfrac{1}{2}\\left( \\tfrac{2}{3} + \\tfrac{4}{3} \\right) = \\tfrac{1}{2}\\cdot \\tfrac{6}{3} = \\tfrac{1}{2}\\cdot 2 = 1.$$\n\nNumerical quadrature verification:\nUsing $2$-point Gauss quadrature in each direction on $[-1,1]$, with abscissae $\\xi,\\eta = \\pm \\tfrac{1}{\\sqrt{3}}$ and weights $w_{\\xi} = w_{\\eta} = 1$, the tensor-product rule gives\n$$K_{e,11}^{\\text{(quad)}} = \\det(J)\\sum_{k=1}^{2}\\sum_{\\ell=1}^{2} w_{\\xi_k} w_{\\eta_{\\ell}} \\left[ \\tfrac{(1-\\eta_{\\ell})^{2}}{8} + \\tfrac{(1-\\xi_{k})^{2}}{4} \\right].$$\nBecause $w_{\\xi_k} = w_{\\eta_{\\ell}} = 1$, we can separate sums:\n$$\\sum_{\\ell=1}^{2} (1-\\eta_{\\ell})^{2} = \\left(1 - \\tfrac{1}{\\sqrt{3}}\\right)^{2} + \\left(1 + \\tfrac{1}{\\sqrt{3}}\\right)^{2} = \\left(1 - \\tfrac{2}{\\sqrt{3}} + \\tfrac{1}{3}\\right) + \\left(1 + \\tfrac{2}{\\sqrt{3}} + \\tfrac{1}{3}\\right) = 2 + \\tfrac{2}{3} = \\tfrac{8}{3},$$\n$$\\sum_{k=1}^{2} (1-\\xi_{k})^{2} = \\tfrac{8}{3},\\qquad \\sum_{k=1}^{2} 1 = 2,\\qquad \\sum_{\\ell=1}^{2} 1 = 2.$$\nHence,\n$$\\sum_{k,\\ell}\\left[ \\tfrac{(1-\\eta_{\\ell})^{2}}{8} + \\tfrac{(1-\\xi_{k})^{2}}{4} \\right] = \\tfrac{1}{8}\\left(\\tfrac{8}{3}\\right)\\cdot 2 + \\tfrac{1}{4}\\left(\\tfrac{8}{3}\\right)\\cdot 2 = \\tfrac{2}{3} + \\tfrac{4}{3} = 2.$$\nMultiplying by $\\det(J) = \\tfrac{1}{2}$ gives\n$$K_{e,11}^{\\text{(quad)}} = \\tfrac{1}{2}\\cdot 2 = 1.$$\nThus, the numerical assembly using $2\\times 2$ Gauss quadrature exactly matches the analytic value.\n\nTherefore, the requested entry is\n$$K_{e,11} = 1.$$", "answer": "$$\\boxed{1}$$", "id": "3098496"}, {"introduction": "Assembling individual element matrices into a global system is a critical step, but one that is prone to subtle errors related to mesh topology. This exercise explores how a common meshing bug—unintentionally duplicating nodes at a shared physical location—translates into a mathematical property of the global stiffness matrix: singularity. You will learn to use linear algebra as a powerful debugging tool, understanding that a singular, or rank-deficient, matrix can indicate an un-anchored or physically unstable component in your model, thereby ensuring the well-posedness of your simulation [@problem_id:3098508].", "problem": "Consider the one-dimensional steady diffusion problem on the interval $[0,1]$: find $u$ such that\n$$- \\frac{d}{dx}\\left(a \\frac{du}{dx}\\right) = f(x),$$\nwhere $a$ is a positive scalar diffusion coefficient and $f(x)$ is a given source. Use the Galerkin finite element method with continuous, piecewise-linear basis functions on a mesh defined by point coordinates and two-node elements. You will assemble the global stiffness matrix $K$ and load vector $F$ from elemental contributions derived from the weak form. Intentionally introduce a bug into some test meshes by duplicating the Degree of Freedom (DOF) indices at shared physical vertices to create disconnected components. Detect the bug by checking the singularity (rank deficiency) of the assembled $K$ restricted to unknown DOFs after imposing Dirichlet boundary conditions.\n\nStarting from the weak form and the definition of the standard linear \"hat\" basis functions, derive the elemental stiffness matrix and a consistent elemental load rule. Implement an assembly routine that:\n- Builds the global stiffness matrix $K$ and load vector $F$ from all elements.\n- Imposes homogeneous Dirichlet boundary conditions (i.e., $u=0$ on the specified DOFs) by eliminating the corresponding rows and columns in $K$ and entries in $F$.\n- Detects singularity by computing the number of near-zero eigenvalues (the nullity) of the reduced symmetric matrix. A matrix is considered to have a zero eigenvalue if its eigenvalue magnitude is less than a tolerance proportional to the largest eigenvalue.\n\nUse $a=1$ and $f(x)=x$. The geometry is dimensionless, and no physical units are required. The mesh is represented by:\n- A coordinate array of DOF positions $x_i$.\n- An element connectivity list of pairs $(i,j)$, each referring to DOF indices in the coordinate array.\n\nYour program must process the following test suite of meshes and boundary condition sets and output the nullity (an integer count of near-zero eigenvalues) for each case:\n\n- Test case $1$ (happy path, correct assembly):\n  - Coordinates: $[0,\\,0.5,\\,1]$.\n  - Elements: $(0,1)$ and $(1,2)$.\n  - Dirichlet set: $\\{0\\}$.\n  - Expected behavior: the reduced $K$ should be positive definite with nullity $0$.\n\n- Test case $2$ (buggy mesh with duplicated shared vertex, causing an unanchored component):\n  - Coordinates: $[0,\\,0.5,\\,0.5,\\,1]$ (the middle vertex at $x=0.5$ is represented by two distinct DOFs).\n  - Elements: $(0,1)$ and $(2,3)$.\n  - Dirichlet set: $\\{0\\}$.\n  - Expected behavior: the reduced $K$ should be singular with nullity $1$ due to an unanchored disconnected component.\n\n- Test case $3$ (buggy mesh but fully anchored):\n  - Coordinates: $[0,\\,0.5,\\,0.5,\\,1]$.\n  - Elements: $(0,1)$ and $(2,3)$.\n  - Dirichlet set: $\\{0,\\,3\\}$.\n  - Expected behavior: the reduced $K$ should be positive definite with nullity $0$ because all components are anchored by Dirichlet conditions.\n\n- Test case $4$ (buggy mesh with no Dirichlet conditions, multiple floating components):\n  - Coordinates: $[0,\\,0.5,\\,0.5,\\,1]$.\n  - Elements: $(0,1)$ and $(2,3)$.\n  - Dirichlet set: $\\{\\}$.\n  - Expected behavior: the reduced $K$ should be singular with nullity $2$ (one rigid mode per disconnected component).\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the test cases in the order listed above. For example, $[n_1,n_2,n_3,n_4]$, where each $n_k$ is the integer nullity for test case $k$.", "solution": "The task is to perform a numerical analysis on a one-dimensional steady diffusion problem using the Finite Element Method (FEM). We must derive the elemental matrices, implement an assembly procedure, and then use eigenvalue analysis of the assembled stiffness matrix to detect a specific type of mesh bug: disconnected components resulting from duplicated degrees of freedom (DOFs).\n\nThe governing differential equation is the one-dimensional diffusion equation on the interval $[0,1]$:\n$$\n- \\frac{d}{dx}\\left(a \\frac{du}{dx}\\right) = f(x)\n$$\nwhere $u(x)$ is the unknown function, $a$ is the diffusion coefficient (given as $a=1$), and $f(x)$ is the source term (given as $f(x)=x$).\n\n**1. Weak Formulation**\n\nTo derive the weak form, we multiply the governing equation by a suitable test function $v(x)$ and integrate over the domain $\\Omega = [0,1]$.\n$$\n- \\int_{0}^{1} v \\frac{d}{dx}\\left(a \\frac{du}{dx}\\right) dx = \\int_{0}^{1} v f(x) dx\n$$\nApplying integration by parts to the left-hand side term:\n$$\n\\int_{0}^{1} a \\frac{dv}{dx} \\frac{du}{dx} dx - \\left[ v a \\frac{du}{dx} \\right]_{0}^{1} = \\int_{0}^{1} v f(x) dx\n$$\nThe term $\\left[ v a \\frac{du}{dx} \\right]_{0}^{1}$ represents the natural (Neumann) boundary conditions. For the purpose of this problem, where we impose Dirichlet boundary conditions, we select test functions $v(x)$ that are zero at the Dirichlet boundaries. This makes the boundary term vanish.\n\nThe weak form is: find $u \\in V$ such that for all $v \\in \\hat{V}$:\n$$\nB(v, u) = L(v)\n$$\nwhere $V$ is the trial function space and $\\hat{V}$ is the test function space. The bilinear form $B(v, u)$ and the linear functional $L(v)$ are defined as:\n$$\nB(v, u) = \\int_{0}^{1} a \\frac{dv}{dx} \\frac{du}{dx} dx\n$$\n$$\nL(v) = \\int_{0}^{1} v(x) f(x) dx\n$$\n\n**2. Finite Element Discretization**\n\nWe discretize the domain $[0,1]$ into a mesh of elements. The solution $u(x)$ is approximated by a linear combination of piecewise-linear basis functions $\\phi_j(x)$, often called \"hat\" functions:\n$$\nu_h(x) = \\sum_{j=1}^{N_{dof}} U_j \\phi_j(x)\n$$\nHere, $N_{dof}$ is the total number of degrees of freedom (nodes), and $U_j$ are the unknown nodal values of the solution. The basis function $\\phi_j(x)$ has the property that it is equal to $1$ at node $j$ and $0$ at all other nodes.\n\nIn the Galerkin method, the test functions $v(x)$ are chosen from the same space as the basis functions, i.e., $v = \\phi_i(x)$ for $i=1, \\dots, N_{dof}$. Substituting this into the weak form yields a system of linear equations $KU=F$, where:\n- $K_{ij} = B(\\phi_i, \\phi_j) = \\int_{0}^{1} a \\frac{d\\phi_i}{dx} \\frac{d\\phi_j}{dx} dx$ is the global stiffness matrix.\n- $F_i = L(\\phi_i) = \\int_{0}^{1} \\phi_i(x) f(x) dx$ is the global load vector.\n\n**3. Elemental Matrices Derivation**\n\nThe global matrices are assembled from contributions from each element. Let's consider a generic element $e$ connecting node $A$ at coordinate $x_A$ to node $B$ at coordinate $x_B$. The element length is $h_e = x_B - x_A$. Within this element, only two basis functions, $\\phi_A(x)$ and $\\phi_B(x)$, are non-zero.\n\nThe local basis functions on the element are:\n$$\n\\phi_A(x) = \\frac{x_B - x}{h_e} \\quad \\text{and} \\quad \\phi_B(x) = \\frac{x - x_A}{h_e}\n$$\nTheir derivatives are constant over the element:\n$$\n\\frac{d\\phi_A}{dx} = -\\frac{1}{h_e} \\quad \\text{and} \\quad \\frac{d\\phi_B}{dx} = \\frac{1}{h_e}\n$$\n\n**Elemental Stiffness Matrix $k^e$**:\nThe $2 \\times 2$ elemental stiffness matrix $k^e$ has entries $k^e_{ij} = \\int_{x_A}^{x_B} a \\frac{d\\phi_i}{dx} \\frac{d\\phi_j}{dx} dx$. Given $a=1$:\n$$\nk^e_{11} = \\int_{x_A}^{x_B} 1 \\cdot \\left(-\\frac{1}{h_e}\\right) \\left(-\\frac{1}{h_e}\\right) dx = \\frac{1}{h_e^2} \\int_{x_A}^{x_B} dx = \\frac{h_e}{h_e^2} = \\frac{1}{h_e}\n$$\n$$\nk^e_{12} = \\int_{x_A}^{x_B} 1 \\cdot \\left(-\\frac{1}{h_e}\\right) \\left(\\frac{1}{h_e}\\right) dx = -\\frac{1}{h_e^2} \\int_{x_A}^{x_B} dx = -\\frac{1}{h_e}\n$$\nBy symmetry, $k^e_{21} = k^e_{12} = -1/h_e$, and $k^e_{22} = 1/h_e$. Thus, the elemental stiffness matrix is:\n$$\nk^e = \\frac{1}{h_e} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\n\n**Elemental Load Vector $f^e$**:\nThe elemental load vector $f^e$ for a source term $f(x)=x$ has entries $f^e_i = \\int_{x_A}^{x_B} x \\cdot \\phi_i(x) dx$.\n$$\nf^e_1 = \\int_{x_A}^{x_B} x \\left(\\frac{x_B - x}{h_e}\\right) dx = \\frac{1}{h_e} \\left[ x_B \\frac{x^2}{2} - \\frac{x^3}{3} \\right]_{x_A}^{x_B} = \\frac{h_e}{6}(2x_A + x_B)\n$$\n$$\nf^e_2 = \\int_{x_A}^{x_B} x \\left(\\frac{x - x_A}{h_e}\\right) dx = \\frac{1}{h_e} \\left[ \\frac{x^3}{3} - x_A \\frac{x^2}{2} \\right]_{x_A}^{x_B} = \\frac{h_e}{6}(x_A + 2x_B)\n$$\nSo, the consistent elemental load vector for $f(x)=x$ is:\n$$\nf^e = \\frac{h_e}{6} \\begin{pmatrix} 2x_A + x_B \\\\ x_A + 2x_B \\end{pmatrix}\n$$\n\n**4. Assembly and Boundary Conditions**\n\nThe assembly process involves iterating through each element, calculating its $k^e$ and $f^e$, and adding their values to the appropriate locations in the global $K$ and $F$ matrices, mapping local element nodes to global DOF indices.\n\nAfter assembly, homogeneous Dirichlet boundary conditions ($u_k=0$ for DOFs $k$ in a given set) are imposed. For the purpose of analyzing the matrix singularity, we are interested in the system corresponding to the *unknown* DOFs. Let $I$ be the set of indices for unknown DOFs. We form a reduced stiffness matrix, $K_{red}$, by selecting only the rows and columns of $K$ that correspond to the indices in $I$.\n\n**5. Singularity Detection**\n\nThe stiffness matrix $K$ for a diffusion problem without any Dirichlet boundary conditions is always singular (for a connected mesh, its nullity is $1$, corresponding to a constant \"rigid-body\" mode). Applying a Dirichlet condition at one node \"anchors\" the solution and makes the reduced matrix for the remaining unknowns non-singular (positive definite), assuming the mesh is connected.\n\nThe problem introduces a bug where a physically connected mesh is represented by disconnected components in the data structure (e.g., coordinates $[0, 0.5, 0.5, 1]$ and elements $(0,1), (2,3)$). This creates two separate graphs. Each disconnected component that is not anchored by a Dirichlet boundary condition will contribute a rigid-body mode, and thus a zero eigenvalue, to the stiffness matrix. The nullity (the dimension of the null space) of the reduced matrix $K_{red}$ is the number of such unanchored components.\n\nWe can compute the nullity by finding the number of eigenvalues of $K_{red}$ that are numerically zero. Since $K_{red}$ is symmetric and positive semi-definite, its eigenvalues are real and non-negative. We calculate all eigenvalues and count how many have a magnitude smaller than a tolerance, defined as a small fraction of the largest eigenvalue's magnitude (e.g., $|\\lambda_i| < 10^{-12} |\\lambda_{max}|$). This count gives the nullity of $K_{red}$.", "answer": "```python\nimport numpy as np\n\ndef assemble_and_check(coords, elements, dirichlet_dofs):\n    \"\"\"\n    Assembles the stiffness matrix and load vector for a 1D diffusion problem,\n    imposes Dirichlet boundary conditions, and computes the nullity of the\n    reduced stiffness matrix.\n\n    Args:\n        coords (list or np.ndarray): Nodal coordinates.\n        elements (list of tuples): Element connectivity (pairs of DOF indices).\n        dirichlet_dofs (set): Set of DOF indices with Dirichlet boundary conditions.\n\n    Returns:\n        int: The nullity of the reduced stiffness matrix.\n    \"\"\"\n    n_dofs = len(coords)\n    K = np.zeros((n_dofs, n_dofs))\n    # The load vector F is not required for singularity check but is assembled for completeness.\n    F = np.zeros(n_dofs)\n    \n    # Constant diffusion coefficient\n    a = 1.0\n\n    # Assembly loop\n    for elem in elements:\n        dof1, dof2 = elem\n        x1, x2 = coords[dof1], coords[dof2]\n        \n        # Ensure h is positive, although order doesn't matter for stiffness matrix.\n        h = abs(x2 - x1)\n        if h < 1e-15:\n            # Avoid division by zero for zero-length elements, though not in test cases.\n            continue\n            \n        # Elemental stiffness matrix for a=1\n        k_elem = (a / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n        # Elemental load vector for f(x)=x\n        # f_elem = (h/6) * [2*x_A + x_B, x_A + 2*x_B]\n        # Use min/max to ensure x_A < x_B for the formula\n        x_A, x_B = min(x1, x2), max(x1, x2)\n        f_elem_vals = (h / 6.0) * np.array([2 * x_A + x_B, x_A + 2 * x_B])\n        # The order of f_elem must match the dof order in the element tuple\n        if x1 > x2:\n            f_elem = np.array([f_elem_vals[1], f_elem_vals[0]])\n        else:\n            f_elem = f_elem_vals\n        \n        # Add to global matrices\n        ix = np.ix_([dof1, dof2], [dof1, dof2])\n        K[ix] += k_elem\n        F[[dof1, dof2]] += f_elem\n\n    # Identify unknown DOFs\n    all_dofs = set(range(n_dofs))\n    unknown_dofs = sorted(list(all_dofs - set(dirichlet_dofs)))\n\n    if not unknown_dofs:\n        return 0 # No unknown DOFs, reduced matrix is empty, nullity is 0.\n    \n    # Extract reduced stiffness matrix\n    K_reduced = K[np.ix_(unknown_dofs, unknown_dofs)]\n    \n    if K_reduced.shape[0] == 0:\n        return 0\n\n    # Compute eigenvalues of the symmetric reduced matrix\n    eigenvalues = np.linalg.eigh(K_reduced)[0]\n    \n    # Determine the tolerance for a \"zero\" eigenvalue\n    max_eig_abs = np.max(np.abs(eigenvalues)) if eigenvalues.size > 0 else 0.0\n    \n    # If the largest eigenvalue is itself near zero, all are zero.\n    # The tolerance must be absolute in this case.\n    if max_eig_abs < 1e-12:\n        return K_reduced.shape[0]\n\n    # Relative tolerance based on the largest eigenvalue\n    tolerance = max_eig_abs * 1e-12\n    \n    # Count eigenvalues smaller than the tolerance\n    nullity = np.sum(np.abs(eigenvalues) < tolerance)\n    \n    return int(nullity)\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the results.\n    \"\"\"\n    # Test case 1 (happy path, correct assembly)\n    test_case_1 = {\n        \"coords\": [0.0, 0.5, 1.0],\n        \"elements\": [(0, 1), (1, 2)],\n        \"dirichlet_dofs\": {0}\n    }\n\n    # Test case 2 (buggy mesh with duplicated shared vertex, causing an unanchored component)\n    test_case_2 = {\n        \"coords\": [0.0, 0.5, 0.5, 1.0],\n        \"elements\": [(0, 1), (2, 3)],\n        \"dirichlet_dofs\": {0}\n    }\n\n    # Test case 3 (buggy mesh but fully anchored)\n    test_case_3 = {\n        \"coords\": [0.0, 0.5, 0.5, 1.0],\n        \"elements\": [(0, 1), (2, 3)],\n        \"dirichlet_dofs\": {0, 3}\n    }\n\n    # Test case 4 (buggy mesh with no Dirichlet conditions, multiple floating components)\n    test_case_4 = {\n        \"coords\": [0.0, 0.5, 0.5, 1.0],\n        \"elements\": [(0, 1), (2, 3)],\n        \"dirichlet_dofs\": set()\n    }\n    \n    test_cases = [test_case_1, test_case_2, test_case_3, test_case_4]\n    \n    results = []\n    for case in test_cases:\n        nullity = assemble_and_check(\n            case[\"coords\"], case[\"elements\"], case[\"dirichlet_dofs\"]\n        )\n        results.append(nullity)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3098508"}, {"introduction": "For large-scale scientific simulations, constructing a correct stiffness matrix is only half the battle; solving the resulting linear system efficiently is often the main computational bottleneck. The structure of the sparse matrix $K$ dramatically influences the performance of the solvers used to find the solution vector $U$. This practice delves into the crucial topic of computational performance by comparing how different node ordering strategies affect the matrix's bandwidth and the amount of \"fill-in\" during factorization, demonstrating a key technique for optimizing large-scale FEM codes [@problem_id:3098591].", "problem": "Consider the scalar Poisson problem on the unit square with homogeneous Dirichlet boundary conditions: find $u$ such that\n$$\n-\\nabla \\cdot \\left(\\nabla u\\right) = g \\quad \\text{in } \\Omega = [0,1]\\times[0,1], \\qquad u = 0 \\quad \\text{on } \\partial \\Omega,\n$$\nwith $g(x,y) \\equiv 1$. The weak form reads: find $u \\in H_0^1(\\Omega)$ such that for all $v \\in H_0^1(\\Omega)$,\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, \\mathrm{d}\\Omega = \\int_{\\Omega} g \\, v \\, \\mathrm{d}\\Omega.\n$$\nUse continuous, piecewise linear Lagrange basis functions over a triangulation of $\\Omega$ to approximate $u$ by a finite element expansion $u_h(x,y) = \\sum_{i=1}^{N} U_i \\, \\varphi_i(x,y)$, where $N$ is the number of interior nodes (that is, nodes not on $\\partial \\Omega$), and $\\varphi_i$ are the nodal basis functions associated with those interior nodes. The resulting linear system has the form\n$$\nK \\, U = f,\n$$\nwhere the stiffness matrix entries and load vector entries are defined by\n$$\nK_{ij} = \\int_{\\Omega} \\nabla \\varphi_i \\cdot \\nabla \\varphi_j \\, \\mathrm{d}\\Omega, \\qquad f_i = \\int_{\\Omega} g \\, \\varphi_i \\, \\mathrm{d}\\Omega.\n$$\nYou will assemble $K$ and $f$ on nonuniform, structured triangulations generated by mapping a uniform tensor-product grid via power-law coordinate transformations. Specifically, let $N_x$ and $N_y$ be positive integers. Define the grid points $\\{\\xi_i\\}_{i=0}^{N_x}$ by $\\xi_i = i/N_x$ and $\\{\\eta_j\\}_{j=0}^{N_y}$ by $\\eta_j = j/N_y$. For positive real parameters $\\alpha$ and $\\beta$, define the nonuniform node coordinates as\n$$\nx_i = \\xi_i^{\\alpha}, \\quad i = 0,1,\\dots,N_x, \\qquad y_j = \\eta_j^{\\beta}, \\quad j=0,1,\\dots,N_y.\n$$\nForm a triangulation by splitting each quadrilateral cell $\\bigl([x_i,x_{i+1}]\\times[y_j,y_{j+1}]\\bigr)$ into two triangles along the diagonal from $(x_i,y_j)$ to $(x_{i+1},y_{j+1})$. Impose $u=0$ on the boundary by discarding all basis functions whose nodes lie on $\\partial \\Omega$ (that is, retain only the interior nodes), and assemble the reduced system $K \\in \\mathbb{R}^{N \\times N}$ and $f \\in \\mathbb{R}^{N}$ over those interior nodes.\n\nYour task is to:\n- Assemble the global stiffness matrix $K$ and load vector $f$ for the described nonuniform triangulations and source $g(x,y)=1$, using linear triangular finite elements.\n- Compare two node ordering strategies on the interior nodes:\n  1. Natural lexicographic ordering: order nodes by $(i,j)$ with $i$ increasing fastest, that is, index as $i + j (N_x+1)$ before restriction to interior nodes, then restrict.\n  2. Reverse Cuthill–McKee (RCM) ordering: compute the permutation that minimizes the approximate bandwidth on the graph of $K$ and apply it to symmetrically permute $K$.\n- For each ordering, compute the following two quantitative metrics:\n  1. The half-bandwidth of the matrix $A$ defined as $b(A) = \\max\\{ |i-j| : A_{ij} \\neq 0\\}$.\n  2. A fill-in measure during factorization defined by\n     $$\n     F(A) = \\operatorname{nnz}(L) + \\operatorname{nnz}(U) - \\operatorname{nnz}(A),\n     $$\n     where $L$ and $U$ arise from a sparse LU factorization of $A$ with column permutations disabled and diagonal pivoting threshold set to zero, and $\\operatorname{nnz}(\\cdot)$ denotes the number of stored nonzero entries. Use the same factorization settings for all cases so that $F(A)$ is comparable across orderings.\n  \nDesign and implement a complete, runnable program that performs the assembly and the ordering comparison for the following test suite of parameter sets $(N_x,N_y,\\alpha,\\beta)$:\n- Case $1$: $(N_x,N_y,\\alpha,\\beta) = (8,8,2,1)$.\n- Case $2$: $(N_x,N_y,\\alpha,\\beta) = (2,2,1.5,1.2)$.\n- Case $3$: $(N_x,N_y,\\alpha,\\beta) = (12,7,3,0.5)$.\n\nFor each case, produce four integers in the following order:\n- $b(K_{\\text{nat}})$, $F(K_{\\text{nat}})$, $b(K_{\\text{rcm}})$, $F(K_{\\text{rcm}})$,\nwhere $K_{\\text{nat}}$ is the reduced stiffness matrix in natural ordering, and $K_{\\text{rcm}}$ is the same matrix symmetrically permuted by the reverse Cuthill–McKee permutation computed from its sparsity graph.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the results concatenated in the order of the test cases. For example, the output format must be\n$$\n[\\,b_1,F_1,b_1',F_1',b_2,F_2,b_2',F_2',b_3,F_3,b_3',F_3'\\,],\n$$\nwhere $b_k$ and $F_k$ denote the half-bandwidth and fill-in for natural ordering in case $k$, and $b_k'$ and $F_k'$ denote the corresponding quantities for reverse Cuthill–McKee ordering in case $k$. All reported quantities must be integers.", "solution": "The user wants me to solve a self-contained, valid problem about assembling a finite element stiffness matrix and analyzing its sparsity pattern under different node orderings.\n\n### 1. Problem Formulation and Discretization\nThe problem is to find the solution $u$ to the Poisson equation on the unit square $\\Omega = [0,1]\\times[0,1]$:\n$$-\\nabla \\cdot \\left(\\nabla u\\right) = g \\quad \\text{in } \\Omega,$$\nwith a constant source term $g(x,y) = 1$ and homogeneous Dirichlet boundary conditions $u = 0$ on the boundary $\\partial \\Omega$.\n\nThe finite element method (FEM) is employed for discretization. The starting point is the weak form of the problem: find $u \\in H_0^1(\\Omega)$ such that for all test functions $v \\in H_0^1(\\Omega)$,\n$$a(u,v) = L(v) \\quad \\text{where} \\quad a(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, \\mathrm{d}\\Omega \\quad \\text{and} \\quad L(v) = \\int_{\\Omega} g \\, v \\, \\mathrm{d}\\Omega.$$\nThe solution $u$ is approximated by a function $u_h$ from a finite-dimensional space spanned by continuous, piecewise linear Lagrange basis functions $\\{\\varphi_i\\}_{i=1}^N$. The approximation is written as a linear combination $u_h(x,y) = \\sum_{j=1}^{N} U_j \\, \\varphi_j(x,y)$, where $U_j$ are the unknown coefficients (approximations of $u$ at the nodes) and $N$ is the number of degrees of freedom. Due to the homogeneous Dirichlet condition $u=0$ on $\\partial\\Omega$, we only consider basis functions $\\varphi_i$ associated with interior nodes of the mesh.\n\nSubstituting $u_h$ into the weak form and choosing the test functions to be the basis functions themselves ($v = \\varphi_i$), we obtain a linear system of equations $K U = f$, where:\n- $U \\in \\mathbb{R}^N$ is the vector of unknown coefficients.\n- $K \\in \\mathbb{R}^{N \\times N}$ is the stiffness matrix with entries $K_{ij} = a(\\varphi_j, \\varphi_i) = \\int_{\\Omega} \\nabla \\varphi_i \\cdot \\nabla \\varphi_j \\, \\mathrm{d}\\Omega$.\n- $f \\in \\mathbb{R}^N$ is the load vector with entries $f_i = L(\\varphi_i) = \\int_{\\Omega} g \\, \\varphi_i \\, \\mathrm{d}\\Omega$.\n\n### 2. Mesh Generation\nThe domain $\\Omega$ is discretized using a structured but nonuniform triangulation. The mesh nodes $(x_i, y_j)$ are generated by a power-law mapping from a uniform grid in a logical space $(\\xi, \\eta)$:\n- Uniform grid nodes: $\\xi_i = i/N_x$ for $i \\in \\{0, 1, \\dots, N_x\\}$ and $\\eta_j = j/N_y$ for $j \\in \\{0, 1, \\dots, N_y\\}$.\n- Mapped physical nodes: $x_i = \\xi_i^{\\alpha}$ and $y_j = \\eta_j^{\\beta}$ for given positive parameters $\\alpha$ and $\\beta$.\n- The mesh consists of $N_x \\times N_y$ quadrilateral cells of the form $[x_i, x_{i+1}] \\times [y_j, y_{j+1}]$. Each quadrilateral is divided into two triangles by the diagonal connecting node $(x_i, y_j)$ to $(x_{i+1}, y_{j+1})$.\n\n### 3. Element-wise Assembly\nThe global stiffness matrix $K$ is assembled by summing contributions from each triangular element $T_k$ in the mesh. On a single linear triangular element $T$ with vertices $P_1=(x_1, y_1)$, $P_2=(x_2, y_2)$, and $P_3=(x_3, y_3)$, the basis functions $\\varphi_m$ (for $m=1,2,3$) are linear, and their gradients $\\nabla \\varphi_m$ are constant. The element stiffness matrix $K^e \\in \\mathbb{R}^{3 \\times 3}$ for this triangle has entries:\n$$K^e_{mn} = \\int_{T} \\nabla \\varphi_m \\cdot \\nabla \\varphi_n \\, \\mathrm{d}A = (\\nabla \\varphi_m \\cdot \\nabla \\varphi_n) \\cdot \\operatorname{Area}(T).$$\nThe gradients can be computed as:\n$$ \\nabla \\varphi_1 = \\frac{1}{2 A} \\begin{pmatrix} y_2 - y_3 \\\\ x_3 - x_2 \\end{pmatrix}, \\quad \\nabla \\varphi_2 = \\frac{1}{2 A} \\begin{pmatrix} y_3 - y_1 \\\\ x_1 - x_3 \\end{pmatrix}, \\quad \\nabla \\varphi_3 = \\frac{1}{2 A} \\begin{pmatrix} y_1 - y_2 \\\\ x_2 - x_1 \\end{pmatrix}, $$\nwhere $A = \\operatorname{Area}(T)$. These element matrices are then added to the global stiffness matrix according to the global indices of the element's vertices. Since we are only interested in interior degrees of freedom, contributions are only added for vertex pairs that are both interior to the domain $\\Omega$.\n\n### 4. Node Ordering and Sparsity Analysis\nThe structure of the resulting sparse matrix $K$ depends on the ordering of the interior nodes. The total number of interior nodes is $N = (N_x-1)(N_y-1)$.\n1.  **Natural Lexicographic Ordering**: We map the 2D grid of interior nodes $(i,j)$, where $i \\in \\{1, \\dots, N_x-1\\}$ and $j \\in \\{1, \\dots, N_y-1\\}$, to a 1D index $p$. The specified \"i increasing fastest\" order corresponds to the mapping $p = (i-1) + (j-1)(N_x-1)$. This matrix is denoted $K_{\\text{nat}}$.\n2.  **Reverse Cuthill–McKee (RCM) Ordering**: This is an algorithm that computes a permutation $P$ of the matrix rows and columns to reduce its bandwidth. The permuted matrix is $K_{\\text{rcm}} = P K_{\\text{nat}} P^T$.\n\nTwo metrics are used to compare the sparsity patterns of $K_{\\text{nat}}$ and $K_{\\text{rcm}}$:\n1.  **Half-bandwidth**: $b(A) = \\max\\{|i-j| : A_{ij} \\neq 0\\}$. A smaller bandwidth is generally desirable for direct solvers.\n2.  **Fill-in**: $F(A) = \\operatorname{nnz}(L) + \\operatorname{nnz}(U) - \\operatorname{nnz}(A)$. This quantity measures the number of new non-zero entries created during sparse LU factorization ($A \\approx LU$). The factorization is performed with column permutations disabled and a diagonal pivoting threshold of zero, ensuring comparable results.\n\n### 5. Algorithmic Implementation\nThe overall algorithm for each test case $(N_x, N_y, \\alpha, \\beta)$ is as follows:\n1.  Generate the $(N_x+1) \\times (N_y+1)$ grid of node coordinates $(x_i, y_j)$ using the power-law transformation.\n2.  Initialize an empty sparse stiffness matrix $K$ of size $N \\times N$, where $N=(N_x-1)(N_y-1)$.\n3.  Iterate through each quadrilateral cell $(i,j)$ for $i \\in \\{0, \\dots, N_x-1\\}$ and $j \\in \\{0, \\dots, N_y-1\\}$.\n4.  For each of the two triangles within the cell:\n    a. Compute its $3 \\times 3$ element stiffness matrix $K^e$.\n    b. For each pair of vertices, check if they are interior nodes. If so, determine their global indices $p$ and $q$ in the reduced system.\n    c. Add the corresponding entry from $K^e$ to $K_{pq}$.\n5.  The resulting matrix is $K_{\\text{nat}}$. Compute its half-bandwidth $b(K_{\\text{nat}})$ and fill-in $F(K_{\\text{nat}})$.\n6.  Compute the RCM permutation for $K_{\\text{nat}}$ and form the permuted matrix $K_{\\text{rcm}}$.\n7.  Compute the half-bandwidth $b(K_{\\text{rcm}})$ and fill-in $F(K_{\\text{rcm}})$.\n8.  Store the four integer metrics.\n\nThis process is repeated for all test cases, and the results are concatenated into a single list.", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.csgraph import reverse_cuthill_mckee\nfrom scipy.sparse.linalg import splu\n\ndef solve():\n    \"\"\"\n    Assembles the finite element stiffness matrix for a Poisson problem on a\n    nonuniform grid, and analyzes its sparsity under natural and RCM orderings.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, alpha, beta)\n        (8, 8, 2.0, 1.0),\n        (2, 2, 1.5, 1.2),\n        (12, 7, 3.0, 0.5),\n    ]\n\n    all_results = []\n    \n    for case_params in test_cases:\n        Nx, Ny, alpha, beta = case_params\n\n        # 1. Generate node coordinates\n        xi = np.linspace(0, 1, Nx + 1)\n        eta = np.linspace(0, 1, Ny + 1)\n        x_coords_vec = xi**alpha\n        y_coords_vec = eta**beta\n        \n        # All node coordinates, ordered lexicographically with x-index fastest\n        nodes = np.array([[x, y] for y in y_coords_vec for x in x_coords_vec])\n\n        # 2. Setup for assembly based on interior nodes\n        num_interior_nodes_x = Nx - 1\n        num_interior_nodes_y = Ny - 1\n        N_interior = num_interior_nodes_x * num_interior_nodes_y\n\n        if N_interior == 0:\n            all_results.extend([0, 0, 0, 0])\n            continue\n            \n        K = lil_matrix((N_interior, N_interior), dtype=np.float64)\n\n        # Memoization for faster interior index lookup\n        memo_interior_idx = {}\n        def get_interior_idx(i, j):\n            if (i, j) in memo_interior_idx:\n                return memo_interior_idx[(i, j)]\n            \n            if 1 <= i < Nx and 1 <= j < Ny:\n                # Natural lexicographic ordering (i fastest)\n                idx = (i - 1) + (j - 1) * num_interior_nodes_x\n                memo_interior_idx[(i, j)] = idx\n                return idx\n            \n            memo_interior_idx[(i, j)] = None\n            return None\n\n        # 3. Assemble global stiffness matrix K\n        for j_quad in range(Ny):\n            for i_quad in range(Nx):\n                v_indices_global = [\n                    (i_quad, j_quad), (i_quad + 1, j_quad), \n                    (i_quad, j_quad + 1), (i_quad + 1, j_quad + 1)\n                ]\n                \n                # Each quad is split into two triangles by the diagonal from (xi,yj) to (xi+1,yj+1)\n                triangles_v_indices = [\n                    (v_indices_global[0], v_indices_global[1], v_indices_global[3]),\n                    (v_indices_global[0], v_indices_global[3], v_indices_global[2])\n                ]\n\n                for tri_v_indices in triangles_v_indices:\n                    v_coords = np.array([\n                        nodes[idx[0] + idx[1] * (Nx + 1)] for idx in tri_v_indices\n                    ])\n                    \n                    # Compute element stiffness matrix Ke for a linear triangle\n                    area = 0.5 * abs(\n                        (v_coords[1, 0] - v_coords[0, 0]) * (v_coords[2, 1] - v_coords[0, 1]) -\n                        (v_coords[2, 0] - v_coords[0, 0]) * (v_coords[1, 1] - v_coords[0, 1])\n                    )\n                    \n                    if area < 1e-15: continue\n\n                    grad_matrix = np.zeros((3, 2))\n                    grad_matrix[0, 0] = v_coords[1, 1] - v_coords[2, 1]\n                    grad_matrix[0, 1] = v_coords[2, 0] - v_coords[1, 0]\n                    grad_matrix[1, 0] = v_coords[2, 1] - v_coords[0, 1]\n                    grad_matrix[1, 1] = v_coords[0, 0] - v_coords[2, 0]\n                    grad_matrix[2, 0] = v_coords[0, 1] - v_coords[1, 1]\n                    grad_matrix[2, 1] = v_coords[1, 0] - v_coords[0, 0]\n                    grad_matrix /= (2 * area)\n\n                    Ke = area * (grad_matrix @ grad_matrix.T)\n\n                    interior_indices = [get_interior_idx(vi[0], vi[1]) for vi in tri_v_indices]\n\n                    for r_loc in range(3):\n                        r_glob = interior_indices[r_loc]\n                        if r_glob is None: continue\n                        for c_loc in range(3):\n                            c_glob = interior_indices[c_loc]\n                            if c_glob is None: continue\n                            K[r_glob, c_glob] += Ke[r_loc, c_loc]\n\n        K_nat = K.tocsc()\n\n        # 4. Analyze matrices\n        def analyze_matrix(A):\n            if A.shape[0] == 0:\n                return 0, 0\n            \n            A_coo = A.tocoo()\n            if A_coo.nnz == 0:\n                 b = 0\n            else:\n                 b = np.max(np.abs(A_coo.row - A_coo.col))\n            \n            lu = splu(A, permc_spec=\"NATURAL\", diag_pivot_thresh=0.0)\n            fill_in = lu.L.nnz + lu.U.nnz - A.nnz\n            \n            return int(b), int(fill_in)\n            \n        b_nat, F_nat = analyze_matrix(K_nat)\n\n        if N_interior > 1:\n            perm = reverse_cuthill_mckee(K_nat, symmetric_mode=True)\n            K_rcm = K_nat[perm, :][:, perm]\n        else:\n            K_rcm = K_nat\n            \n        b_rcm, F_rcm = analyze_matrix(K_rcm)\n\n        all_results.extend([b_nat, F_nat, b_rcm, F_rcm])\n        \n    # 5. Format and print output\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3098591"}]}