{"hands_on_practices": [{"introduction": "Simulating the time evolution of a quantum system is a cornerstone of computational quantum physics. When a system's Hamiltonian consists of parts that do not commute, we cannot simply exponentiate the total Hamiltonian. This exercise introduces the Trotter-Suzuki decomposition, a powerful technique to approximate the evolution by breaking it into a sequence of smaller, manageable steps ([@problem_id:3181193]). You will implement this method for a particle on a lattice and explore how imperfections, modeled as gate errors, affect a fundamental property of quantum mechanics: the conservation of probability.", "problem": "Consider a one-dimensional lattice with $N$ sites and periodic boundary conditions. The quantum state is represented by a complex vector $\\psi \\in \\mathbb{C}^N$ with components $\\psi(x,t)$, where $x \\in \\{0,1,\\dots,N-1\\}$ indexes lattice sites and $t$ denotes time. The evolution is governed by the time-dependent Schrödinger equation $i \\frac{d}{dt} \\lvert \\psi(t) \\rangle = H \\lvert \\psi(t) \\rangle$, where $H = T + V$ is a Hermitian Hamiltonian consisting of a kinetic (hopping) term $T$ and an on-site potential $V$. The kinetic term is $T = -J \\sum_{x=0}^{N-1} \\left( \\lvert x \\rangle \\langle x+1 \\rvert + \\lvert x+1 \\rangle \\langle x \\rvert \\right)$ with addition modulo $N$, and the potential is $V = \\sum_{x=0}^{N-1} V_x \\lvert x \\rangle \\langle x \\rvert$ with $V_x = V_0 \\cos\\left( \\frac{2\\pi x}{N} \\right)$. The time evolution is approximated by first-order Trotterization: one discrete step of duration $\\Delta t$ applies $U_V = e^{-i V \\Delta t}$ followed by $U_T = e^{-i T \\Delta t}$ to the state. In exact arithmetic with perfect gates, the evolution operator is unitary and the norm $\\sum_x \\lvert \\psi(x,t) \\rvert^2$ is preserved at each step.\n\nTo study the impact of gate imperfections, model finite gate errors by a uniform leakage operator $L(\\delta) = (1-\\delta) I$ with $0 \\le \\delta \\ll 1$ applied immediately after each gate. This leakage models amplitude loss to degrees of freedom outside the simulated Hilbert space (computational subspace), and therefore is non-unitary on the simulated subspace. At each Trotter step, apply $U_V$, then $L(\\delta)$, then $U_T$, then $L(\\delta)$.\n\nStarting from the normalized initial condition $\\psi(x,0) = 1$ for $x=0$ and $\\psi(x,0) = 0$ for $x \\neq 0$, implement the above evolution for $M$ discrete steps. After each Trotter step $k$ (i.e., after the sequence $U_V$, $L(\\delta)$, $U_T$, $L(\\delta)$ is applied once), compute the norm $n_k = \\sum_{x=0}^{N-1} \\lvert \\psi(x,t_k) \\rvert^2$ and verify the norm preservation property in the error-free case. Quantify the drift due to finite gate errors by reporting the single metric $D = \\max_{1 \\le k \\le M} \\lvert 1 - n_k \\rvert$, the maximum absolute deviation of the norm from $1$ over all steps.\n\nUse dimensionless units for all quantities. Angles are dimensionless phases; no angle unit conversion is required.\n\nYour program must simulate the evolution and, for the parameter sets below, output the drift metric $D$ for each case. Round each reported $D$ to six decimal places. The final output must be a single line containing the results as a comma-separated list enclosed in square brackets.\n\nTest suite (each tuple is $(N, J, V_0, \\Delta t, M, \\delta)$):\n- Case $1$: $(8, 1.0, 0.0, 0.10, 100, 0.0)$.\n- Case $2$: $(8, 1.0, 0.5, 0.05, 200, 0.0)$.\n- Case $3$: $(8, 1.0, 0.5, 0.05, 200, 1.0 \\times 10^{-4})$.\n- Case $4$: $(8, 1.0, 0.5, 0.05, 10, 5.0 \\times 10^{-2})$.\n- Case $5$: $(8, 1.0, 1.0, 0.50, 20, 0.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[D_1,D_2,D_3,D_4,D_5]$), where each $D_i$ is the drift metric for Case $i$ rounded to six decimal places.", "solution": "The problem requires the simulation of a quantum system on a one-dimensional lattice and the quantification of norm deviation due to simulated gate errors. The process involves constructing the Hamiltonian, implementing the time evolution via Trotterization, and calculating a specific error metric.\n\n**1. System Representation**\n\nThe quantum state of the system is a vector $\\lvert \\psi \\rangle \\in \\mathbb{C}^N$, where $N$ is the number of lattice sites. In the computational implementation, this is represented as a `numpy` array of size $N$ with a complex data type. The initial condition is $\\psi(x,0) = 1$ for $x=0$ and $\\psi(x,0) = 0$ otherwise, which corresponds to a state vector with a $1$ in the first component and $0$s elsewhere. This is a normalized state, i.e., $\\langle \\psi(0) \\mid \\psi(0) \\rangle = \\sum_{x=0}^{N-1} \\lvert \\psi(x,0) \\rvert^2 = 1$.\n\n**2. Hamiltonian and Evolution Operators**\n\nThe time evolution is governed by the Schrödinger equation $i \\frac{d}{dt} \\lvert \\psi(t) \\rangle = H \\lvert \\psi(t) \\rangle$. For a small time step $\\Delta t$, the evolution operator is approximately $U(\\Delta t) \\approx e^{-i H \\Delta t}$. The Hamiltonian $H$ is the sum of a kinetic term $T$ and a potential term $V$.\n\n- **Potential Operator ($V$):** The potential is an on-site term $V = \\sum_{x=0}^{N-1} V_x \\lvert x \\rangle \\langle x \\rvert$, with $V_x = V_0 \\cos(\\frac{2\\pi x}{N})$. This operator is diagonal in the position basis $\\{\\lvert x \\rangle\\}$. The corresponding evolution operator, $U_V = e^{-i V \\Delta t}$, is also diagonal, with matrix elements $(U_V)_{xx} = e^{-i V_x \\Delta t}$. Its application to a state vector $\\psi$ is an efficient element-wise multiplication: $(\\psi')_x = e^{-i V_x \\Delta t} \\psi_x$.\n\n- **Kinetic Operator ($T$):** The kinetic term is a hopping term $T = -J \\sum_{x=0}^{N-1} \\left( \\lvert x \\rangle \\langle x+1 \\rvert + \\lvert x+1 \\rangle \\langle x \\rvert \\right)$, where addition is modulo $N$. In the position basis, this is a real, symmetric $N \\times N$ matrix. The diagonal elements are $0$, and the elements on the first super-diagonal and sub-diagonal are $-J$. Due to the periodic boundary conditions, the elements $T_{0,N-1}$ and $T_{N-1,0}$ are also $-J$. The evolution operator for the kinetic part is $U_T = e^{-i T \\Delta t}$. Since $T$ is not a diagonal matrix, its exponential must be computed using a numerical matrix exponentiation algorithm, such as the one provided by `scipy.linalg.expm`. The operators $T$ and $V$ are Hermitian, so $U_T$ and $U_V$ are unitary.\n\n**3. Trotterized Evolution with Errors**\n\nThe problem specifies a first-order Trotter-Suzuki decomposition to approximate the full evolution operator $e^{-i(T+V)\\Delta t}$. A single step of the ideal evolution applies first $U_V$ and then $U_T$, resulting in the combined operator $U_{\\text{Trotter}} = U_T U_V$. Since $U_T$ and $U_V$ are unitary, their product $U_{\\text{Trotter}}$ is also unitary, which guarantees the conservation of the state norm: $\\lVert U_{\\text{Trotter}} \\psi \\rVert^2 = \\lVert \\psi \\rVert^2$.\n\nGate errors are modeled by a non-unitary leakage operator $L(\\delta) = (1-\\delta)I$, which is applied after each of the unitary gates. The evolution of the state vector $\\psi_k$ at step $k$ to $\\psi_{k+1}$ at step $k+1$ is given by:\n$$\n\\lvert \\psi_{k+1} \\rangle = L(\\delta) U_T L(\\delta) U_V \\lvert \\psi_k \\rangle\n$$\nThis operator is not unitary for $\\delta > 0$. Let $n_k = \\lVert \\psi_k \\rVert^2$ be the norm at step $k$. The norm evolves as:\n$$\nn_{k+1} = \\lVert L(\\delta) U_T L(\\delta) U_V \\psi_k \\rVert^2 = \\langle \\psi_k \\rvert U_V^\\dagger L(\\delta)^\\dagger U_T^\\dagger L(\\delta)^\\dagger L(\\delta) U_T L(\\delta) U_V \\lvert \\psi_k \\rangle\n$$\nSince $L(\\delta)$ is a scalar operator $(1-\\delta)I$, and $U_T, U_V$ are unitary, this simplifies to:\n$$\nn_{k+1} = (1-\\delta)^2 \\cdot (1-\\delta)^2 \\cdot \\langle \\psi_k \\rvert U_V^\\dagger U_T^\\dagger U_T U_V \\lvert \\psi_k \\rangle = (1-\\delta)^4 n_k\n$$\nStarting with $n_0=1$, the norm after $k$ steps is $n_k = ((1-\\delta)^4)^k = (1-\\delta)^{4k}$.\n\n**4. Simulation Algorithm and Metric Calculation**\n\nThe simulation algorithm proceeds as follows for each set of parameters $(N, J, V_0, \\Delta t, M, \\delta)$:\n\n1.  **Initialization:** Create the initial state vector $\\psi$, where $\\psi_0=1$ and $\\psi_x=0$ for $x>0$.\n2.  **Operator Construction:**\n    a. Construct the vector of potential values $V_x$ and from it the vector of multiplicative phase factors $e^{-i V_x \\Delta t}$.\n    b. Construct the $N \\times N$ kinetic matrix $T$.\n    c. Compute the kinetic evolution matrix $U_T = e^{-i T \\Delta t}$ once before the time-stepping loop.\n3.  **Time Evolution:** Loop for $k$ from $1$ to $M$:\n    a. Apply the potential evolution operator: $\\psi \\leftarrow U_V \\psi$ (element-wise multiplication).\n    b. Apply the first leakage operator: $\\psi \\leftarrow (1-\\delta) \\psi$ (scalar multiplication).\n    c. Apply the kinetic evolution operator: $\\psi \\leftarrow U_T \\psi$ (matrix-vector multiplication).\n    d. Apply the second leakage operator: $\\psi \\leftarrow (1-\\delta) \\psi$ (scalar multiplication).\n    e. After this full step, compute the norm squared $n_k = \\sum_{x=0}^{N-1} \\lvert \\psi_x \\rvert^2$.\n    f. Record the deviation for this step: $|1 - n_k|$.\n4.  **Metric Calculation:** The final drift metric $D$ is the maximum deviation recorded over all $M$ steps: $D = \\max_{1 \\le k \\le M} |1 - n_k|$.\n\nFor the cases where $\\delta=0$, the leakage operator is the identity operator, $L(0) = I$. The evolution is unitary, and the norm is conserved at every step. Therefore, the deviation $|1-n_k|$ should be $0$ within the limits of floating-point arithmetic precision. For cases where $\\delta>0$, the norm decays, and the deviation $|1 - n_k| = 1 - (1-\\delta)^{4k}$ increases with $k$. The maximum deviation will thus occur at the final step, $k=M$, giving $D = 1 - (1-\\delta)^{4M}$.\n\nThe provided Python code implements this algorithm. It iterates through each test case, performs the simulation, calculates $D$, and formats the results as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Simulates the quantum evolution on a 1D lattice and calculates the norm drift.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, 1.0, 0.0, 0.10, 100, 0.0),            # Case 1\n        (8, 1.0, 0.5, 0.05, 200, 0.0),            # Case 2\n        (8, 1.0, 0.5, 0.05, 200, 1.0e-4),         # Case 3\n        (8, 1.0, 0.5, 0.05, 10, 5.0e-2),          # Case 4\n        (8, 1.0, 1.0, 0.50, 20, 0.0),             # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        N, J, V0, dt, M, delta = case\n\n        # 1. Initialization\n        # a. Initial state: psi(x,0) = 1 for x=0, 0 otherwise.\n        psi = np.zeros(N, dtype=np.complex128)\n        psi[0] = 1.0 + 0.0j\n\n        # 2. Operator Construction\n        # a. Potential evolution operator U_V (as element-wise multiplicative factors)\n        x_sites = np.arange(N)\n        V_diag = V0 * np.cos(2 * np.pi * x_sites / N)\n        U_V_factors = np.exp(-1j * V_diag * dt)\n\n        # b. Kinetic operator T\n        T = np.zeros((N, N), dtype=np.float64)\n        for i in range(N):\n            T[i, (i + 1) % N] = -J\n            T[i, (i - 1 + N) % N] = -J\n        \n        # c. Kinetic evolution operator U_T\n        U_T = expm(-1j * T * dt)\n\n        # d. Leakage factor\n        leakage_factor = 1.0 - delta\n\n        # 3. Time Evolution Loop\n        deviations = []\n        for _ in range(M):\n            # Apply U_V\n            psi = U_V_factors * psi\n            \n            # Apply first leakage L(delta)\n            psi = leakage_factor * psi\n            \n            # Apply U_T\n            psi = U_T @ psi\n            \n            # Apply second leakage L(delta)\n            psi = leakage_factor * psi\n\n            # Calculate and store the norm deviation for the current step\n            norm_k = np.sum(np.abs(psi)**2)\n            deviations.append(np.abs(1.0 - norm_k))\n\n        # 4. Metric Calculation\n        # The drift D is the maximum absolute deviation over all M steps.\n        if not deviations:\n            D = 0.0\n        else:\n            D = np.max(deviations)\n        \n        results.append(D)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3181193"}, {"introduction": "Real quantum systems are never perfectly isolated; they inevitably interact with their environment, leading to noise and decoherence. To accurately model this reality, we move beyond state vectors and unitary evolution to the framework of open quantum systems using density matrices. This practice challenges you to simulate a quantum system using the Lindblad master equation, the primary tool for describing environmental effects, and to verify a crucial principle: whether a physical quantity remains conserved depends intimately on the symmetries of the noise process ([@problem_id:3181239]).", "problem": "You are tasked with validating a conservation law in a quantum simulation using a Markovian open-system model. Consider a chain of $n$ qubits with Pauli operators $X$, $Y$, and $Z$, and define the Hamiltonian\n$$\nH = \\sum_{i=1}^{n-1} J Z_i Z_{i+1} + \\sum_{i=1}^{n} h_i Z_i,\n$$\nwhere $J$ is a real nearest-neighbor coupling and $h_i$ are real on-site fields. Let the conserved observable be the total magnetization in the $z$-basis\n$$\nA = \\sum_{i=1}^{n} Z_i.\n$$\nFor this $H$, one has $[H, A] = 0$, so the observable $A$ is conserved under unitary evolution generated by $H$.\n\nTo incorporate noise, use the Markovian Lindblad master equation for the density matrix $\\rho(t)$:\n$$\n\\frac{d\\rho}{dt} = -i[H, \\rho] + \\sum_k \\left(L_k \\rho L_k^\\dagger - \\frac{1}{2}\\{L_k^\\dagger L_k, \\rho\\}\\right),\n$$\nwhere $\\{X,Y\\} = XY + YX$ denotes the anticommutator and $L_k$ are collapse operators defining the noise channel. Two noise channels must be considered:\n- Pure dephasing in the $z$-basis: $L_k = \\sqrt{\\gamma} Z_k$ for each site $k$, where $\\gamma \\ge 0$ is the dephasing rate.\n- Bit-flip noise: $L_k = \\sqrt{\\gamma} X_k$ for each site $k$, where $\\gamma \\ge 0$ is the flip rate.\n\nThe expectation value of $A$ at time $t$ is $\\langle A \\rangle_t = \\operatorname{Tr}(A \\rho(t))$. Your program must:\n1. Construct $H$ and $A$ for the given parameters and verify numerically that $[H, A] = 0$ by computing $\\|[H, A]\\|_F$, the Frobenius norm, and ensuring it is below a small tolerance.\n2. Evolve $\\rho(t)$ from an initial pure product state under the Lindblad equation using a superoperator (Liouvillian) representation and compute $\\langle A \\rangle_t$ at multiple times $t \\in \\{0, T/4, T/2, 3T/4, T\\}$.\n3. Verify that $\\langle A \\rangle_t$ remains constant in time for noise that preserves the symmetry ($L_k \\propto Z_k$) and detect when it does not remain constant (e.g., under bit-flip noise). Use an absolute tolerance of $10^{-7}$ to decide constancy, i.e., report success if $\\max_t |\\langle A \\rangle_t - \\langle A \\rangle_0| \\le 10^{-7}$.\n\nTime is dimensionless (arbitrary units), and all rates are in inverse time units consistent with the chosen time unit.\n\nImplement the following test suite of parameter values:\n- Test case 1 (happy path, nonzero dephasing): $n = 3$, $J = 1.0$, $h = [0.3, -0.2, 0.5]$, noise type $=$ dephasing, $\\gamma = 0.4$, $T = 2.0$, initial state $|0\\rangle \\otimes |0\\rangle \\otimes |+\\rangle$, where $|+\\rangle = (|0\\rangle + |1\\rangle)/\\sqrt{2}$.\n- Test case 2 (boundary, zero noise): $n = 3$, $J = 1.0$, $h = [0.3, -0.2, 0.5]$, noise type $=$ dephasing, $\\gamma = 0.0$, $T = 1.5$, initial state $|0\\rangle \\otimes |0\\rangle \\otimes |+\\rangle$.\n- Test case 3 (edge, stronger dephasing on smaller system): $n = 2$, $J = 0.7$, $h = [0.1, -0.05]$, noise type $=$ dephasing, $\\gamma = 2.0$, $T = 3.0$, initial state $|0\\rangle \\otimes |+\\rangle$.\n- Test case 4 (symmetry-breaking noise): $n = 3$, $J = 1.0$, $h = [0.0, 0.0, 0.0]$, noise type $=$ bit-flip, $\\gamma = 0.2$, $T = 3.0$, initial state $|0\\rangle \\otimes |0\\rangle \\otimes |+\\rangle$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is a boolean indicating whether $\\langle A \\rangle_t$ is constant within the specified tolerance for the given test case.", "solution": "First, we establish the mathematical representation of the quantum system. A system of $n$ qubits resides in a Hilbert space of dimension $D = 2^n$. The basis states are tensor products of single-qubit states. An operator $O_k$ acting non-trivially only on the $k$-th qubit is represented in the $D \\times D$ space by the Kronecker product $I^{\\otimes(k-1)} \\otimes O \\otimes I^{\\otimes(n-k)}$, where $I$ is the $2 \\times 2$ identity matrix.\n\nThe Hamiltonian $H = \\sum_{i=1}^{n-1} J Z_i Z_{i+1} + \\sum_{i=1}^{n} h_i Z_i$ and the observable $A = \\sum_{i=1}^{n} Z_i$ are constructed as $D \\times D$ matrices by summing the matrix representations of their individual terms. We verify the conservation condition $[H, A] = 0$ by numerically computing the Frobenius norm of the commutator matrix $HA - AH$. Analytically, this commutator is zero because all operators involved ($Z_i$) mutually commute. Numerically, the norm should be close to zero within machine precision.\n\nThe time evolution of the system's density matrix $\\rho(t)$ is governed by the Lindblad master equation:\n$$\n\\frac{d\\rho}{dt} = \\mathcal{L}(\\rho) = -i[H, \\rho] + \\sum_k \\left(L_k \\rho L_k^\\dagger - \\frac{1}{2}\\{L_k^\\dagger L_k, \\rho\\}\\right)\n$$\nThis is a linear first-order differential equation for the density matrix $\\rho$. To solve it numerically, we transform it into a matrix-vector equation by \"vectorizing\" the $D \\times D$ density matrix $\\rho$ into a $D^2 \\times 1$ column vector $|\\rho\\rangle\\rangle$. Applying this transformation, the Lindblad equation becomes $\\frac{d|\\rho\\rangle\\rangle}{dt} = \\mathcal{L}_{\\text{matrix}} |\\rho\\rangle\\rangle$, where $\\mathcal{L}_{\\text{matrix}}$ is a $D^2 \\times D^2$ matrix known as the Liouvillian superoperator.\n\nFor column-wise vectorization (stacking the columns of $\\rho$), the Liouvillian superoperator is given by:\n$$\n\\mathcal{L}_{\\text{matrix}} = -i(I_D \\otimes H - H^T \\otimes I_D) + \\sum_k \\left( L_k^* \\otimes L_k - \\frac{1}{2} I_D \\otimes L_k^\\dagger L_k - \\frac{1}{2} (L_k^\\dagger L_k)^T \\otimes I_D \\right)\n$$\nHere, $\\otimes$ is the Kronecker product, $I_D$ is the $D \\times D$ identity matrix, $*$ denotes complex conjugation, and $T$ denotes the transpose. The collapse operators $L_k$ are constructed based on the specified noise model (dephasing: $L_k = \\sqrt{\\gamma}Z_k$; bit-flip: $L_k = \\sqrt{\\gamma}X_k$).\n\nThe formal solution to the vectorized master equation is $|\\rho(t)\\rangle\\rangle = e^{\\mathcal{L}_{\\text{matrix}} t} |\\rho(0)\\rangle\\rangle$. We compute the evolution by calculating the matrix exponential of the Liouvillian using `scipy.linalg.expm`.\n\nFor each test case, we first construct the initial density matrix $\\rho(0) = |\\psi_0\\rangle\\langle\\psi_0|$ from the given pure product state $|\\psi_0\\rangle$. We then vectorize $\\rho(0)$ to get $|\\rho(0)\\rangle\\rangle$. At each required time $t$, we compute $|\\rho(t)\\rangle\\rangle = e^{\\mathcal{L}_{\\text{matrix}} t} |\\rho(0)\\rangle\\rangle$, reshape it back into a $D \\times D$ matrix $\\rho(t)$, and calculate the expectation value $\\langle A \\rangle_t = \\operatorname{Tr}(A \\rho(t))$.\n\nFinally, we check for the conservation of $\\langle A \\rangle_t$. We compute the maximum absolute deviation $\\max_t |\\langle A \\rangle_t - \\langle A \\rangle_0|$ over the specified time points. If this deviation is less than or equal to the given tolerance of $10^{-7}$, the observable is considered constant, and the result is `True`; otherwise, it is `False`.\n\nThe expectation is that for dephasing noise ($L_k \\propto Z_k$), the observable $A = \\sum_j Z_j$ is conserved because $[A, L_k] = 0$ for all $k$. In contrast, for bit-flip noise ($L_k \\propto X_k$), $[A, L_k] \\neq 0$, and thus the expectation value $\\langle A \\rangle_t$ is not expected to remain constant.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the quantum simulation problem by constructing the system,\n    evolving it under the Lindblad master equation, and checking for\n    the conservation of an observable.\n    \"\"\"\n    # Define single-qubit Pauli matrices and basis states\n    I_1 = np.array([[1, 0], [0, 1]], dtype=complex)\n    X_1 = np.array([[0, 1], [1, 0]], dtype=complex)\n    Z_1 = np.array([[1, 0], [0, -1]], dtype=complex)\n    s0 = np.array([[1], [0]], dtype=complex)  # |0>\n    s1 = np.array([[0], [1]], dtype=complex)  # |1>\n    s_plus = (s0 + s1) / np.sqrt(2)         # |+>\n\n    def get_operator(op, k, n):\n        \"\"\"\n        Constructs the n-qubit operator for a single-qubit operator `op`\n        acting on qubit `k` (0-indexed).\n        \"\"\"\n        op_list = [I_1] * n\n        op_list[k] = op\n        \n        full_op = op_list[0]\n        for i in range(1, n):\n            full_op = np.kron(full_op, op_list[i])\n        return full_op\n\n    test_cases = [\n        (3, 1.0, [0.3, -0.2, 0.5], 'dephasing', 0.4, 2.0, [s0, s0, s_plus]),\n        (3, 1.0, [0.3, -0.2, 0.5], 'dephasing', 0.0, 1.5, [s0, s0, s_plus]),\n        (2, 0.7, [0.1, -0.05], 'dephasing', 2.0, 3.0, [s0, s_plus]),\n        (3, 1.0, [0.0, 0.0, 0.0], 'bit-flip', 0.2, 3.0, [s0, s0, s_plus])\n    ]\n    \n    results = []\n    CONSTANCY_TOLERANCE = 1e-7\n\n    for n, J, h, noise_type, gamma, T, initial_state_kets in test_cases:\n        dim = 2**n\n        Id_dim = np.eye(dim, dtype=complex)\n        \n        # Construct Hamiltonian H\n        H = np.zeros((dim, dim), dtype=complex)\n        for i in range(n - 1):\n            H += J * (get_operator(Z_1, i, n) @ get_operator(Z_1, i + 1, n))\n        for i in range(n):\n            H += h[i] * get_operator(Z_1, i, n)\n            \n        # Construct observable A\n        A = np.zeros((dim, dim), dtype=complex)\n        for i in range(n):\n            A += get_operator(Z_1, i, n)\n\n        # Verification step: Check if [H, A] is numerically zero\n        comm_H_A = H @ A - A @ H\n        norm_comm = np.linalg.norm(comm_H_A, 'fro')\n        assert norm_comm < 1e-9, f\"[H,A] should be zero, but norm is {norm_comm}\"\n\n        # Construct initial density matrix rho0\n        psi0 = initial_state_kets[0]\n        for i in range(1, n):\n            psi0 = np.kron(psi0, initial_state_kets[i])\n        rho0 = psi0 @ psi0.conj().T\n        \n        # Construct Liouvillian superoperator\n        # Unitary part: -i * (I kron H - H.T kron I)\n        L_unitary = -1j * (np.kron(Id_dim, H) - np.kron(H.T, Id_dim))\n        \n        # Dissipative part\n        L_dissipative = np.zeros((dim**2, dim**2), dtype=complex)\n        if gamma > 0:\n            if noise_type == 'dephasing':\n                L_op_base = Z_1\n            elif noise_type == 'bit-flip':\n                L_op_base = X_1\n            else:\n                raise ValueError(f\"Unknown noise type: {noise_type}\")\n            \n            for k in range(n):\n                Lk = np.sqrt(gamma) * get_operator(L_op_base, k, n)\n                Lk_dag_Lk = Lk.conj().T @ Lk\n                \n                # Dissipator for Lk based on column-vectorization convention\n                # Lk* kron Lk - 0.5 * I kron (Lk_dag Lk) - 0.5 * (Lk_dag Lk).T kron I\n                term1 = np.kron(Lk.conj(), Lk)\n                term2 = -0.5 * np.kron(Id_dim, Lk_dag_Lk)\n                term3 = -0.5 * np.kron(Lk_dag_Lk.T, Id_dim)\n                L_dissipative += term1 + term2 + term3\n        \n        Liouvillian = L_unitary + L_dissipative\n        \n        # Evolve state and compute expectation values\n        rho0_vec = rho0.flatten('F') # Column-vectorize\n        time_points = [0, T / 4.0, T / 2.0, 3.0 * T / 4.0, T]\n        exp_A_values = []\n        \n        for t in time_points:\n            # Evolve vectorized density matrix: |rho(t)>> = exp(L*t) |rho(0)>>\n            if t == 0:\n                rhot_vec = rho0_vec\n            else:\n                U_super = expm(Liouvillian * t)\n                rhot_vec = U_super @ rho0_vec\n            \n            # Reshape back to matrix form\n            rhot = rhot_vec.reshape((dim, dim), order='F')\n            \n            # Compute expectation value <A>_t = Tr(A * rho(t))\n            exp_A = np.trace(A @ rhot).real\n            exp_A_values.append(exp_A)\n            \n        # Check for constancy\n        initial_exp_A = exp_A_values[0]\n        max_deviation = np.max(np.abs(np.array(exp_A_values) - initial_exp_A))\n        is_constant = max_deviation <= CONSTANCY_TOLERANCE\n        results.append(is_constant)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, [r for r in results]))}]\")\n\nsolve()\n```", "id": "3181239"}, {"introduction": "While forward simulation predicts a system's behavior based on a known Hamiltonian, a frequent task in the lab is the inverse: to deduce the Hamiltonian from experimental measurements. This process of system identification is essential for characterizing and calibrating quantum devices. In this exercise, you will step into the role of an experimentalist, using noisy time-series data from a single qubit to reconstruct its governing Hamiltonian, combining quantum dynamics with classical data analysis techniques like linear regression ([@problem_id:3181125]).", "problem": "You will implement Hamiltonian learning for a single qubit by reconstructing an unknown time-independent Hamiltonian from noisy time-series measurements of observables and quantifying the reconstruction error under finite measurement shots and limited timesteps. Work in natural units with reduced Planck constant set to $1$ so that all quantities are dimensionless. The unknown Hamiltonian has the form $H = \\tfrac{1}{2}\\,\\mathbf{h}\\cdot\\boldsymbol{\\sigma}$, where $\\mathbf{h} \\in \\mathbb{R}^3$ is an unknown vector and $\\boldsymbol{\\sigma} = (\\sigma_x,\\sigma_y,\\sigma_z)$ are the Pauli operators. A pure initial state is represented by its Bloch vector $\\mathbf{r}(0) \\in \\mathbb{R}^3$ with $\\|\\mathbf{r}(0)\\|=1$, and its Bloch vector $\\mathbf{r}(t)$ evolves in time under the dynamics generated by $H$.\n\nFundamental base and modeling assumptions:\n- The Heisenberg equation of motion states that $\\tfrac{d}{dt}\\langle O\\rangle = i \\langle [H,O]\\rangle$ for any observable $O$, and the Pauli commutation relations state $[\\sigma_a,\\sigma_b]=2i\\sum_{c}\\epsilon_{abc}\\sigma_c$, where $\\epsilon_{abc}$ is the Levi-Civita symbol.\n- For a single qubit with $H=\\tfrac{1}{2}\\,\\mathbf{h}\\cdot\\boldsymbol{\\sigma}$, the Bloch vector obeys $\\tfrac{d}{dt}\\mathbf{r}(t)=\\mathbf{h}\\times \\mathbf{r}(t)$, where $\\times$ denotes the vector cross product.\n- A projective measurement of $\\sigma_k$ at time $t$ yields an outcome in $\\{+1,-1\\}$ with probabilities $p_{+}(t)=\\tfrac{1+\\langle\\sigma_k\\rangle_t}{2}$ and $p_{-}(t)=\\tfrac{1-\\langle\\sigma_k\\rangle_t}{2}$, where $\\langle\\sigma_k\\rangle_t=r_k(t)$ is the $k$-th component of $\\mathbf{r}(t)$. With $N$ independent shots, the sample mean is an unbiased estimator of $r_k(t)$ with variance decreasing as $1/N$.\n\nYour program must:\n1. Fix the true Hamiltonian parameter vector to $\\mathbf{h}_{\\text{true}} = (0.9,-1.2,0.7)$ and the initial Bloch vector to $\\mathbf{r}(0) = \\dfrac{(0.3,0.8,0.5)}{\\|(0.3,0.8,0.5)\\|}$.\n2. Simulate the exact noiseless time evolution of the Bloch vector $\\mathbf{r}(t)$ implied by the dynamics $\\tfrac{d}{dt}\\mathbf{r}(t)=\\mathbf{h}\\times \\mathbf{r}(t)$. You may compute $\\mathbf{r}(t_k)$ at discrete times $t_k = k\\,\\Delta t$ for $k=0,1,\\dots,N_t-1$ using any correct method consistent with the stated laws (for example, propagating the state by unitary evolution or using rotation of the Bloch vector about the axis $\\mathbf{h}$).\n3. Model finite-shot measurements at each time $t_k$ for each Pauli observable $\\sigma_x,\\sigma_y,\\sigma_z$ by drawing $N$ outcomes in $\\{+1,-1\\}$ with probabilities determined by the exact expectations and computing the sample mean for each component, yielding a noisy estimate $\\widehat{\\mathbf{r}}(t_k)$.\n4. Estimate the time derivative $\\tfrac{d}{dt}\\mathbf{r}(t)$ at interior times using a central finite difference on the noisy estimates: for $k=1,\\dots,N_t-2$, set $\\widehat{\\dot{\\mathbf{r}}}(t_k) = \\dfrac{\\widehat{\\mathbf{r}}(t_{k+1}) - \\widehat{\\mathbf{r}}(t_{k-1})}{2\\,\\Delta t}$.\n5. Use linear regression to estimate $\\mathbf{h}$ from the relation $\\dot{\\mathbf{r}}(t) = \\mathbf{h}\\times \\mathbf{r}(t)$. Write this as a linear system $\\dot{\\mathbf{r}}(t_k)=C(\\mathbf{r}(t_k))\\,\\mathbf{h}$, where $C(\\mathbf{r})$ is the $3\\times 3$ matrix\n$$\nC(\\mathbf{r})=\\begin{bmatrix}\n0 & r_z & -r_y\\\\\n-r_z & 0 & r_x\\\\\nr_y & -r_x & 0\n\\end{bmatrix}.\n$$\nConstruct an overdetermined system by stacking all interior times with $C(\\widehat{\\mathbf{r}}(t_k))$ on the left-hand side and $\\widehat{\\dot{\\mathbf{r}}}(t_k)$ on the right-hand side, and compute the least squares estimate $\\widehat{\\mathbf{h}}$ that minimizes the sum of squared residuals. Here, you must use Ordinary Least Squares (OLS), that is, unweighted least squares without additional regularization.\n6. Quantify the reconstruction error for each test case as the Euclidean norm $e=\\|\\widehat{\\mathbf{h}}-\\mathbf{h}_{\\text{true}}\\|_2$.\n\nUse a fixed pseudorandom seed $12345$ for all random sampling to make the results reproducible.\n\nTest suite:\nRun your program for the following five cases, each specified by the triple $(N_t,\\Delta t,N)$:\n- Case $1$ (happy path): $(101,\\,0.05,\\,20000)$.\n- Case $2$ (limited timesteps): $(7,\\,0.2,\\,20000)$.\n- Case $3$ (finite shots): $(101,\\,0.05,\\,200)$.\n- Case $4$ (limited timesteps and finite shots): $(7,\\,0.2,\\,200)$.\n- Case $5$ (many timesteps but very few shots): $(401,\\,0.01,\\,50)$.\n\nFinal output format:\nYour program should produce a single line of output containing the list of errors for the five cases, in order, as a comma-separated list enclosed in square brackets. Each error must be rounded to exactly six digits after the decimal point. For example: $[0.123456,0.000001,0.314159,0.271828,0.000000]$. No other text should be printed.", "solution": "The objective is to reconstruct the Hamiltonian vector $\\mathbf{h}$ of a single-qubit system, described by $H = \\frac{1}{2}\\mathbf{h}\\cdot\\boldsymbol{\\sigma}$, from noisy time-series data. The procedure involves simulating the system's evolution, modeling measurement noise, estimating time derivatives from the noisy data, and applying linear regression to infer $\\mathbf{h}$.\n\n**Step 1: Simulation of Exact Qubit Dynamics**\nThe evolution of the qubit's state, represented by the Bloch vector $\\mathbf{r}(t)$, is governed by the differential equation $\\frac{d}{dt}\\mathbf{r}(t) = \\mathbf{h} \\times \\mathbf{r}(t)$. This equation describes the precession of the vector $\\mathbf{r}(t)$ around the constant vector $\\mathbf{h}$ with an angular frequency $\\omega = \\|\\mathbf{h}\\|_2$. The exact analytical solution for $\\mathbf{r}(t)$ given an initial state $\\mathbf{r}(0)$ is provided by Rodrigues' rotation formula:\n$$\n\\mathbf{r}(t) = \\mathbf{r}(0)\\cos(\\omega t) + (\\hat{\\mathbf{h}} \\times \\mathbf{r}(0))\\sin(\\omega t) + \\hat{\\mathbf{h}}(\\hat{\\mathbf{h}} \\cdot \\mathbf{r}(0))(1 - \\cos(\\omega t))\n$$\nwhere $\\hat{\\mathbf{h}} = \\mathbf{h}/\\|\\mathbf{h}\\|_2$ is the unit vector along the Hamiltonian axis. We use this formula to compute the exact, noiseless Bloch vector $\\mathbf{r}(t_k)$ at discrete time points $t_k = k\\Delta t$ for $k=0, 1, \\dots, N_t-1$.\n\n**Step 2: Simulation of Measurement Noise**\nIn a real experiment, the expectation values $\\langle \\sigma_j \\rangle_t = r_j(t)$ are not directly accessible. They are estimated from a finite number of projective measurements. For a measurement of the Pauli operator $\\sigma_j$ on a system in a state with expectation value $r_j(t)$, the outcomes are $\\{+1, -1\\}$. The probability of obtaining the outcome $+1$ is given by $p_+(t) = \\frac{1 + r_j(t)}{2}$.\nTo simulate this process, we perform $N$ independent trials (shots). The number of times the outcome $+1$ is observed, $n_+$, follows a binomial distribution, $n_+ \\sim \\text{Binomial}(N, p_+)$. The empirical estimate for the expectation value, $\\widehat{r}_j(t)$, is the sample mean of the outcomes:\n$$\n\\widehat{r}_j(t) = \\frac{n_+ \\cdot (+1) + (N - n_+) \\cdot (-1)}{N} = \\frac{2n_+ - N}{N}\n$$\nThis procedure is applied at each time $t_k$ for each component $\\{x, y, z\\}$ to generate the noisy time-series data $\\widehat{\\mathbf{r}}(t_k)$.\n\n**Step 3: Numerical Estimation of the Time Derivative**\nTo utilize the dynamical equation $\\dot{\\mathbf{r}} = \\mathbf{h} \\times \\mathbf{r}$, we must estimate the time derivative of the Bloch vector from the noisy, discrete data $\\widehat{\\mathbf{r}}(t_k)$. We employ a second-order central finite difference scheme, which offers a good balance between accuracy and noise amplification. For interior time points $t_k$ where $k \\in \\{1, \\dots, N_t-2\\}$, the derivative is estimated as:\n$$\n\\widehat{\\dot{\\mathbf{r}}}(t_k) = \\frac{\\widehat{\\mathbf{r}}(t_{k+1}) - \\widehat{\\mathbf{r}}(t_{k-1})}{2\\Delta t}\n$$\n\n**Step 4: Hamiltonian Estimation via Linear Regression**\nThe core of the reconstruction is to solve for $\\mathbf{h}$ from the dynamical equation. We rewrite the cross product as a matrix-vector multiplication: $\\mathbf{h} \\times \\mathbf{r}(t) = C(\\mathbf{r}(t))\\mathbf{h}$, where $C(\\mathbf{r})$ is the skew-symmetric matrix:\n$$\nC(\\mathbf{r}) = \\begin{bmatrix}\n0 & r_z & -r_y\\\\\n-r_z & 0 & r_x\\\\\nr_y & -r_x & 0\n\\end{bmatrix}\n$$\nSubstituting our noisy estimates for the state and its derivative, we obtain a set of approximate linear equations for each interior time point $t_k$:\n$$\n\\widehat{\\dot{\\mathbf{r}}}(t_k) \\approx C(\\widehat{\\mathbf{r}}(t_k))\\mathbf{h}\n$$\nBy stacking these $3$-dimensional vector equations for all $N_t-2$ interior points, we form a single large, overdetermined linear system of the form $A\\mathbf{h} \\approx \\mathbf{b}$. The design matrix $A$ is a tall matrix of size $(3(N_t-2)) \\times 3$, constructed by vertically stacking the individual $C(\\widehat{\\mathbf{r}}(t_k))$ matrices. The observation vector $\\mathbf{b}$ has size $(3(N_t-2)) \\times 1$ and is formed by stacking the estimated derivative vectors $\\widehat{\\dot{\\mathbf{r}}}(t_k)$.\nThe problem specifies using Ordinary Least Squares (OLS) to find the estimate $\\widehat{\\mathbf{h}}$ that minimizes the sum of squared residuals, i.e., $\\|\\mathbf{b} - A\\widehat{\\mathbf{h}}\\|_2^2$. This solution is given formally by $\\widehat{\\mathbf{h}} = (A^T A)^{-1}A^T \\mathbf{b}$, though it is computed using more numerically stable algorithms such as QR decomposition.\n\n**Step 5: Error Quantification**\nFinally, the accuracy of the Hamiltonian reconstruction is quantified by calculating the Euclidean norm of the difference between the estimated vector $\\widehat{\\mathbf{h}}$ and the true vector $\\mathbf{h}_{\\text{true}}$:\n$$\ne = \\|\\widehat{\\mathbf{h}} - \\mathbf{h}_{\\text{true}}\\|_2\n$$\nThis entire procedure is repeated for each test case specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Implements Hamiltonian learning for a single qubit from noisy measurements.\n    \"\"\"\n    \n    # Define globally fixed parameters\n    h_true = np.array([0.9, -1.2, 0.7])\n    r0_unnormalized = np.array([0.3, 0.8, 0.5])\n    r0 = r0_unnormalized / np.linalg.norm(r0_unnormalized)\n    seed = 12345\n    rng = np.random.default_rng(seed)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (101, 0.05, 20000),  # Case 1: happy path\n        (7, 0.2, 20000),   # Case 2: limited timesteps\n        (101, 0.05, 200),    # Case 3: finite shots\n        (7, 0.2, 200),     # Case 4: limited timesteps and finite shots\n        (401, 0.01, 50),     # Case 5: many timesteps but very few shots\n    ]\n\n    results = []\n    \n    for Nt, dt, N in test_cases:\n        # Step 1: Simulate exact time evolution of the Bloch vector\n        # This uses Rodrigues' rotation formula.\n        omega = np.linalg.norm(h_true)\n        h_hat = h_true / omega\n        times = np.linspace(0, (Nt - 1) * dt, Nt)\n        \n        cos_omega_t = np.cos(omega * times)\n        sin_omega_t = np.sin(omega * times)\n        \n        r0_dot_h_hat = np.dot(r0, h_hat)\n        h_hat_cross_r0 = np.cross(h_hat, r0)\n        \n        # Broadcasting to calculate r(t) for all times at once\n        r_exact = (r0[:, np.newaxis] * cos_omega_t +\n                   h_hat_cross_r0[:, np.newaxis] * sin_omega_t +\n                   h_hat[:, np.newaxis] * r0_dot_h_hat * (1 - cos_omega_t)).T\n\n        # Step 2: Model finite-shot measurements to get noisy estimates\n        r_noisy = np.zeros_like(r_exact)\n        for k in range(Nt):\n            for j in range(3):\n                # Probability of measuring +1\n                p_plus = (1 + r_exact[k, j]) / 2\n                # Number of +1 outcomes in N shots\n                n_plus = rng.binomial(N, p_plus)\n                # Sample mean is the estimate for the expectation value\n                r_noisy[k, j] = (2 * n_plus - N) / N\n                \n        # Step 3: Estimate the time derivative using a central finite difference\n        # This applies to interior points k=1, ..., Nt-2\n        r_dot_noisy = (r_noisy[2:] - r_noisy[:-2]) / (2 * dt)\n        \n        # Step 4: Use linear regression to estimate h\n        # We solve A*h = b, where A is the design matrix and b is the observation vector.\n        num_interior_points = Nt - 2\n        \n        # We need r_noisy at the same interior points for constructing C(r)\n        r_noisy_interior = r_noisy[1:-1]\n        \n        # Construct the design matrix A by stacking C(r(t_k)) matrices\n        A = np.zeros((3 * num_interior_points, 3))\n        \n        rx, ry, rz = r_noisy_interior[:, 0], r_noisy_interior[:, 1], r_noisy_interior[:, 2]\n        \n        # A_ij is C(r_i)_j\n        # Populate A based on the structure of C(r)\n        A[0::3, 1] = rz\n        A[0::3, 2] = -ry\n        A[1::3, 0] = -rz\n        A[1::3, 2] = rx\n        A[2::3, 0] = ry\n        A[2::3, 1] = -rx\n        \n        # Construct the observation vector b by flattening the estimated derivatives\n        b = r_dot_noisy.flatten()\n        \n        # Solve the overdetermined system using Ordinary Least Squares\n        h_estimated, _, _, _ = linalg.lstsq(A, b)\n        \n        # Step 5: Quantify the reconstruction error\n        error = np.linalg.norm(h_estimated - h_true)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.6f}' for err in results)}]\")\n\nsolve()\n```", "id": "3181125"}]}