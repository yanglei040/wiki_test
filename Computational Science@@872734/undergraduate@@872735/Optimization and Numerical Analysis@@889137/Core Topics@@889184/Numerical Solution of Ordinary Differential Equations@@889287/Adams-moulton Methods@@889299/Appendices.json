{"hands_on_practices": [{"introduction": "To begin, we'll ground our understanding of Adams-Moulton methods in a concrete calculation. This exercise introduces the popular predictor-corrector scheme, which combines an explicit method (the predictor) with an implicit one (the corrector) to gain accuracy without needing to solve a nonlinear equation at each step. You will perform a single predictor-corrector cycle, first estimating the next solution point and then refining it, which is the fundamental computational rhythm of these powerful techniques [@problem_id:2152822].", "problem": "Consider the initial value problem defined by the ordinary differential equation $y'(t) = y(t) - t^2 + 1$. Suppose we are using a numerical method with a fixed step size $h = 0.2$ to approximate the solution. We are given the first two points on the approximate solution curve: at $t_0 = 0.0$, the value is $y_0 = 0.5$, and at $t_1 = 0.2$, the value is $y_1 = 0.82930$.\n\nYour task is to compute the next value, $y_2$, at time $t_2 = 0.4$, by applying a single step of the following predictor-corrector scheme.\n\nFirst, compute a predicted value $y_{i+1}^*$ using the formula:\n$$y_{i+1}^* = y_i + \\frac{h}{2}\\left(3f(t_i, y_i) - f(t_{i-1}, y_{i-1})\\right)$$\nwhere $f(t,y) = y'(t)$.\n\nSecond, use this predicted value to compute the corrected value $y_{i+1}$ using the formula:\n$$y_{i+1} = y_i + \\frac{h}{2}\\left(f(t_{i+1}, y_{i+1}^*) + f(t_i, y_i)\\right)$$\n\nReport the final corrected value $y_2$. Round your final answer to five significant figures.", "solution": "We are given the ODE $y'(t)=f(t,y)=y-t^{2}+1$ and step size $h=0.2$, with known values $(t_{0},y_{0})=(0.0,0.5)$ and $(t_{1},y_{1})=(0.2,0.82930)$. We aim to compute $y_{2}$ at $t_{2}=0.4$ using the specified predictor-corrector scheme.\n\nFirst compute the needed function values at the known points:\n$$f(t_{0},y_{0})=y_{0}-t_{0}^{2}+1=0.5-0+1=1.5,$$\n$$f(t_{1},y_{1})=y_{1}-t_{1}^{2}+1=0.82930-0.04+1=1.78930.$$\n\nPredictor (Adams-Bashforth two-step):\n$$y_{2}^{*}=y_{1}+\\frac{h}{2}\\left(3f(t_{1},y_{1})-f(t_{0},y_{0})\\right)\n=0.82930+0.1\\left(3\\cdot 1.78930-1.5\\right)=0.82930+0.1\\cdot 3.86790=1.216090.$$\n\nEvaluate $f$ at the predicted point $(t_{2},y_{2}^{*})=(0.4,1.216090)$:\n$$f(t_{2},y_{2}^{*})=y_{2}^{*}-t_{2}^{2}+1=1.216090-0.16+1=2.056090.$$\n\nCorrector (trapezoidal step using the predicted endpoint value):\n$$y_{2}=y_{1}+\\frac{h}{2}\\left(f(t_{2},y_{2}^{*})+f(t_{1},y_{1})\\right)\n=0.82930+0.1\\left(2.056090+1.78930\\right)\n=0.82930+0.3845390=1.2138390.$$\n\nRounding to five significant figures yields $1.2138$.", "answer": "$$\\boxed{1.2138}$$", "id": "2152822"}, {"introduction": "Having seen how to execute a single step, we now zoom out to consider the overall efficiency and accuracy of a method. A crucial property is its \"order,\" which dictates how the global error behaves as we change the step size $h$. This thought experiment [@problem_id:2152827] directly probes this relationship for a fourth-order Adams-Moulton method. Mastering this concept is essential for predicting the cost of a simulation and making practical trade-offs between computational effort and the desired precision of the result.", "problem": "A computational scientist is simulating a system whose state, represented by a function $y(t)$, evolves according to a well-behaved ordinary differential equation (ODE). To find an approximate solution, they employ the 4th-order Adams-Moulton method, a popular implicit multi-step method.\n\nIn the first simulation, a constant step size $h$ is used to integrate the ODE from an initial time $t_0$ to a final time $t_f$. Upon completion, the computed solution is compared against a high-precision benchmark solution, revealing a global error of $\\epsilon$ at the final time $t_f$.\n\nTo explore the trade-off between accuracy and computational cost, the scientist runs the simulation again over the same time interval, but this time using a new, larger step size $h_{new} = 2h$. Assuming that both $h$ and $h_{new}$ are small enough to be in the asymptotic regime of convergence for the method, provide the best estimate for the new global error, $\\epsilon_{new}$, at time $t_f$.\n\nA. $2\\epsilon$\n\nB. $4\\epsilon$\n\nC. $8\\epsilon$\n\nD. $16\\epsilon$\n\nE. $32\\epsilon$", "solution": "We are told the method used is the 4th-order Adams-Moulton method. A linear multistep method of order $p$ has local truncation error of order $O(h^{p+1})$ and, under zero-stability and smoothness of the solution, a global error of order $O(h^{p})$. For the 4th-order Adams-Moulton method, $p=4$.\n\nIn the asymptotic regime, the global error at a fixed final time can be modeled as\n$$\n\\epsilon \\approx C h^{p},\n$$\nwhere $C$ is a problem- and method-dependent constant that does not depend on $h$. With $p=4$, this becomes\n$$\n\\epsilon \\approx C h^{4}.\n$$\nWhen the step size is doubled to $h_{new} = 2h$, the new global error scales as\n$$\n\\epsilon_{new} \\approx C (h_{new})^{4} = C (2h)^{4} = 16 C h^{4} = 16 \\epsilon.\n$$\nThus, the best estimate for the new global error is $16\\epsilon$, corresponding to option D.", "answer": "$$\\boxed{D}$$", "id": "2152827"}, {"introduction": "Accuracy isn't the only factor that determines a method's usefulness; stability is equally critical. An unstable method can produce wildly oscillating and unphysical results, even if its local error is small. This advanced practice [@problem_id:2371562] challenges the intuitive notion that higher-order methods are always better by asking you to find a scenario where a lower-order Adams-Moulton method is stable, but a higher-order one fails. By investigating the roots of the stability polynomial, you will gain a deeper appreciation for the nuanced and vital concept of absolute stability, a key consideration for solving the \"stiff\" equations that appear throughout science and engineering.", "problem": "You are to construct and analyze a linear ordinary differential equation (ODE) to expose a counterintuitive stability behavior between two implicit Adams–Moulton multistep methods of different orders. The goal is to identify an example where the second-order Adams–Moulton method (AM-2) is stable for a given step size, while the higher-order fourth-order Adams–Moulton method (AM-4) is unstable. You must implement a program that certifies stability or instability by applying the fundamental root condition for linear multistep methods to the linear test equation.\n\nFundamental base and definitions:\n- Consider the linear test equation $y' = \\lambda y$ with complex scalar $ \\lambda \\in \\mathbb{C} $. For a fixed step size $h > 0$, define the complex number $z = h \\lambda$.\n- A linear multistep method has the form $\\sum_{j=0}^{s} \\alpha_j y_{n+j} = h \\sum_{j=0}^{s} \\beta_j f_{n+j}$, where $f_{n+j} = f(t_{n+j}, y_{n+j})$. On the test equation $f(t,y) = \\lambda y$, the method reduces to the characteristic equation in the amplification factor $\\xi$: $ \\rho(\\xi) - z \\sigma(\\xi) = 0$, where $ \\rho(\\xi) = \\sum_{j=0}^{s} \\alpha_j \\xi^j$ and $ \\sigma(\\xi) = \\sum_{j=0}^{s} \\beta_j \\xi^j$.\n- Absolute stability for a given $z$ means that all roots $\\xi$ of $ \\rho(\\xi) - z \\sigma(\\xi) = 0$ satisfy $|\\xi| < 1$; if a root lies on the unit circle it must be simple to be marginally stable. You should implement a numerical check of the root condition and treat $|\\xi| \\le 1$ within a small numerical tolerance as stable.\n\nTask requirements:\n1. Use the above principles to implement stability tests for the Adams–Moulton method of order $2$ (AM-2) and the Adams–Moulton method of order $4$ (AM-4). You should use the standard Adams–Moulton coefficients for these methods. For each method, construct the corresponding polynomials $ \\rho(\\xi)$ and $ \\sigma(\\xi)$ and test the root condition for a given $z$.\n2. Construct a scalar linear ODE of the form $y' = \\lambda y$ that is “pathological” in the following sense: for a specified step size $h$ the AM-2 method is stable (all roots satisfy $|\\xi| < 1$) while the AM-4 method is unstable (at least one root satisfies $|\\xi| > 1$). Your program should verify this numerically via the root condition, not by appealing to any external stability region plot.\n3. Implement the stability check robustly by computing the roots of the characteristic polynomial using a standard polynomial root finder and verifying the modulus condition with a small numerical tolerance.\n\nTest suite:\nEvaluate your implementation on the following three test cases, each specified by the pair $(\\lambda,h)$:\n- Case $1$: $\\lambda = -1.0$, $h = 0.1$.\n- Case $2$: $\\lambda = -50.0$, $h = 0.2$.\n- Case $3$: $\\lambda = 1.0$, $h = 0.1$.\n\nFor each case, compute $z = h \\lambda$ and determine two booleans: the first indicates whether AM-2 is stable, and the second indicates whether AM-4 is stable, both according to the root condition. The “pathological” behavior is embedded in one of these cases.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of lists, each inner list being of the form $[b_{\\mathrm{AM2}}, b_{\\mathrm{AM4}}]$ with unquoted booleans. For example, the output must look like $[[\\text{True},\\text{False}],[\\text{True},\\text{True}],[\\text{False},\\text{False}]]$ but with the actual values determined by your computation for the above test suite.", "solution": "The problem as stated is a standard exercise in the numerical analysis of ordinary differential equations. It is scientifically grounded, well-posed, and contains sufficient information to proceed. The objective is to demonstrate a known phenomenon where a higher-order numerical method can exhibit a smaller stability region than a lower-order one, leading to counterintuitive behavior for certain stiff problems. I will proceed with the solution.\n\nThe analysis is centered on the linear test equation, a fundamental tool for studying the stability of numerical methods for ODEs. The equation is given by:\n$$\ny'(t) = \\lambda y(t)\n$$\nwhere $y(t) \\in \\mathbb{C}$ and $\\lambda \\in \\mathbb{C}$. When a linear multistep method (LMM) of the form $\\sum_{j=0}^{s} \\alpha_j y_{n+j} = h \\sum_{j=0}^{s} \\beta_j f_{n+j}$ is applied to this equation with $f(t,y) = \\lambda y$, it yields a linear constant-coefficient recurrence relation for the sequence $\\{y_n\\}$. The solutions to this recurrence are of the form $y_n = \\xi^n$, where $\\xi$ is a root of the characteristic equation:\n$$\n\\rho(\\xi) - z \\sigma(\\xi) = 0\n$$\nHere, $z = h\\lambda$, and $\\rho(\\xi) = \\sum_{j=0}^{s} \\alpha_j \\xi^j$ and $\\sigma(\\xi) = \\sum_{j=0}^{s} \\beta_j \\xi^j$ are the first and second characteristic polynomials of the method, respectively.\n\nA method is defined as absolutely stable for a given $z$ if all roots $\\xi_k$ of its characteristic equation satisfy $|\\xi_k| \\le 1$. Any root with modulus equal to $1$ must be simple. The problem statement permits a slight relaxation for numerical implementation, where $|\\xi_k| \\le 1 + \\epsilon$ for a small tolerance $\\epsilon$ is considered stable. This check simplifies the analysis by avoiding the explicit check for simple roots on the unit circle.\n\nFirst, we analyze the second-order Adams-Moulton method (AM-2), also known as the trapezoidal rule. This is a one-step method ($s=1$) defined by:\n$$\ny_{n+1} - y_{n} = \\frac{h}{2} (f_{n+1} + f_n)\n$$\nFrom this form, we identify the coefficients $\\alpha_1=1$, $\\alpha_0=-1$ and $\\beta_1=1/2$, $\\beta_0=1/2$. The characteristic polynomials are:\n$$\n\\rho(\\xi) = \\xi - 1\n$$\n$$\n\\sigma(\\xi) = \\frac{1}{2}\\xi + \\frac{1}{2}\n$$\nThe resulting characteristic equation is a linear equation for $\\xi$:\n$$\n(\\xi - 1) - z \\left( \\frac{1}{2}\\xi + \\frac{1}{2} \\right) = 0 \\implies \\xi\\left(1 - \\frac{z}{2}\\right) = 1 + \\frac{z}{2}\n$$\nThe single root, known as the amplification factor, is:\n$$\n\\xi = \\frac{1 + z/2}{1 - z/2}\n$$\nFor stability, we require $|\\xi| \\le 1$. Let $z = x+iy$. The condition $|\\frac{2+z}{2-z}| \\le 1$ is equivalent to $|2+z|^2 \\le |2-z|^2$.\n$$\n(2+x)^2 + y^2 \\le (2-x)^2 + y^2 \\implies 4+4x+x^2 \\le 4-4x+x^2 \\implies 8x \\le 0 \\implies x \\le 0\n$$\nThus, the AM-2 method is stable for all $z$ in the left half of the complex plane, $\\text{Re}(z) \\le 0$. This property is known as A-stability.\n\nNext, we analyze the fourth-order Adams-Moulton method (AM-4). This is a three-step method ($s=3$) given by the formula:\n$$\ny_{n+3} - y_{n+2} = \\frac{h}{24}(9f_{n+3} + 19f_{n+2} - 5f_{n+1} + f_n)\n$$\nFrom this, we extract the coefficients. The first characteristic polynomial has $\\alpha_3=1$, $\\alpha_2=-1$, and all other $\\alpha_j=0$:\n$$\n\\rho(\\xi) = \\xi^3 - \\xi^2\n$$\nThe coefficients for the second characteristic polynomial are $\\beta_3 = 9/24$, $\\beta_2 = 19/24$, $\\beta_1 = -5/24$, and $\\beta_0 = 1/24$:\n$$\n\\sigma(\\xi) = \\frac{1}{24}(9\\xi^3 + 19\\xi^2 - 5\\xi + 1)\n$$\nThe characteristic equation $\\rho(\\xi) - z \\sigma(\\xi) = 0$ is:\n$$\n(\\xi^3 - \\xi^2) - \\frac{z}{24}(9\\xi^3 + 19\\xi^2 - 5\\xi + 1) = 0\n$$\nMultiplying by $24$ and collecting terms by powers of $\\xi$ yields a cubic polynomial equation:\n$$\n(24 - 9z)\\xi^3 + (-24 - 19z)\\xi^2 + (5z)\\xi - z = 0\n$$\nUnlike AM-2, this equation cannot be easily solved analytically for regions of stability. The stability of AM-4 for a given $z$ must be determined by numerically finding the three roots of this polynomial and checking if their moduli are all less than or equal to $1$. It is a known result that AM-4 is not A-stable; its region of absolute stability does not contain the entire left half-plane.\n\nThe implementation will proceed as follows. For each given pair $(\\lambda, h)$:\n1. Calculate $z = h\\lambda$.\n2. For AM-2, compute $\\xi = (1 + z/2)/(1 - z/2)$ and check if $|\\xi| \\le 1 + \\epsilon$.\n3. For AM-4, construct the complex coefficients of the cubic polynomial $P(\\xi) = a_3 \\xi^3 + a_2 \\xi^2 + a_1 \\xi + a_0$, where $a_3=24-9z$, $a_2=-24-19z$, $a_1=5z$, and $a_0=-z$. Use a standard numerical root-finder to obtain the roots $\\xi_1, \\xi_2, \\xi_3$. Check if $\\max(|\\xi_1|, |\\xi_2|, |\\xi_3|) \\le 1 + \\epsilon$.\n4. A small tolerance $\\epsilon = 10^{-9}$ is appropriate for this numerical check.\n\nWe now evaluate the provided test cases based on this procedure.\n\n- **Case 1**: $(\\lambda, h) = (-1.0, 0.1) \\implies z = -0.1$.\n  - AM-2: $\\text{Re}(z) = -0.1 \\le 0$. The method is stable.\n  - AM-4: $z = -0.1$ is a point very close to the origin. The method is zero-stable, and for small negative real $z$, it is known to be stable. We expect stability.\n  - Predicted outcome: $[\\text{True}, \\text{True}]$.\n\n- **Case 2**: $(\\lambda, h) = (-50.0, 0.2) \\implies z = -10.0$.\n  - AM-2: $\\text{Re}(z) = -10.0 \\le 0$. The method is A-stable, so it remains stable.\n  - AM-4: The stability region of AM-4 along the negative real axis is approximately $(-3.0, 0)$. Since $z = -10.0$ is far outside this interval, we expect at least one root to have a modulus greater than $1$. The method is unstable. This is the pathological case.\n  - Predicted outcome: $[\\text{True}, \\text{False}]$.\n\n- **Case 3**: $(\\lambda, h) = (1.0, 0.1) \\implies z = 0.1$.\n  - AM-2: $\\text{Re}(z) = 0.1 > 0$. The method is unstable.\n  - AM-4: For $\\text{Re}(z) > 0$, instability is expected. The root of $\\rho(\\xi)$ at $\\xi=1$ is perturbed to a value greater than $1$. The method is unstable.\n  - Predicted outcome: $[\\text{False}, \\text{False}]$.\n\nThe final program will implement this logic and confirm these predictions numerically.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_stability_am2(z: complex, tol: float = 1e-9) -> bool:\n    \"\"\"\n    Checks the stability of the AM-2 method for a given z = h*lambda.\n    AM-2 is stable if the single root xi of its characteristic equation has |xi| <= 1.\n    \"\"\"\n    # The characteristic polynomial for AM-2 is (1 - z/2)*xi - (1 + z/2) = 0.\n    # Avoid division by zero if z = 2.\n    if abs(z - 2.0) < tol:\n        # If z=2, the equation is degenerate. Physically, this corresponds to an\n        # infinite amplification factor, hence unstable.\n        return False\n        \n    xi = (1 + z / 2) / (1 - z / 2)\n    return np.abs(xi) <= 1.0 + tol\n\ndef check_stability_am4(z: complex, tol: float = 1e-9) -> bool:\n    \"\"\"\n    Checks the stability of the AM-4 method for a given z = h*lambda.\n    AM-4 is stable if all roots xi of its characteristic equation have |xi| <= 1.\n    \"\"\"\n    # Characteristic equation for AM-4:\n    # (24 - 9*z)*xi^3 + (-24 - 19*z)*xi^2 + (5*z)*xi - z = 0\n    # Coefficients of the cubic polynomial a*xi^3 + b*xi^2 + c*xi + d = 0\n    # The coefficients are complex numbers.\n    coeffs = [\n        24 - 9 * z,\n        -24 - 19 * z,\n        5 * z,\n        -z\n    ]\n    \n    # Use numpy.roots to find the roots of the polynomial.\n    # The roots will be complex.\n    try:\n        roots = np.roots(coeffs)\n    except np.linalg.LinAlgError:\n        # This can happen in degenerate cases, considered unstable.\n        return False\n\n    # Check the modulus of each root. The method is unstable if any root has\n    # a modulus greater than 1 (plus tolerance).\n    max_modulus = np.max(np.abs(roots))\n    \n    return max_modulus <= 1.0 + tol\n\ndef solve():\n    \"\"\"\n    Solves the problem by evaluating the stability of AM-2 and AM-4 for given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement as tuples of (lambda, h).\n    test_cases = [\n        (-1.0, 0.1),\n        (-50.0, 0.2),\n        (1.0, 0.1),\n    ]\n\n    results = []\n    for lambda_val, h_val in test_cases:\n        # Calculate z = h * lambda\n        z = h_val * lambda_val\n        \n        # Check stability for AM-2 and AM-4\n        is_stable_am2 = check_stability_am2(z)\n        is_stable_am4 = check_stability_am4(z)\n        \n        results.append([is_stable_am2, is_stable_am4])\n\n    # Format the final output string exactly as specified.\n    # e.g., [[True,False],[True,True],[False,False]]\n    # No spaces within the inner lists.\n    formatted_inner_lists = [f\"[{r[0]},{r[1]}]\" for r in results]\n    output_string = f\"[{','.join(formatted_inner_lists)}]\"\n    \n    print(output_string)\n\nsolve()\n```", "id": "2371562"}]}