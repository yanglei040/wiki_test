{"hands_on_practices": [{"introduction": "A fundamental application of polynomial interpolation is creating a continuous function model from a set of discrete data points. Once this model is established, we can use tools from calculus and analysis to understand its behavior, such as finding its maximum or minimum values. This practice [@problem_id:2183531] walks you through this two-step process: first, constructing a quadratic polynomial that fits given experimental data, and second, determining the minimum value predicted by your model.", "problem": "In a numerical modeling experiment, a certain quantity $y$ is found to depend on a variable $x$ according to a quadratic relationship, $y=P(x)$, where $P(x)$ is a polynomial of degree two. To characterize this relationship, three data points are measured: $(0, 5)$, $(2, 3)$, and $(4, 7)$. Assuming these points lie exactly on the curve of the polynomial, determine the minimum value attained by the function $P(x)$.", "solution": "Let $P(x)$ be a quadratic polynomial, written as $P(x)=ax^{2}+bx+c$ with $a\\neq 0$. The given points $(0,5)$, $(2,3)$, and $(4,7)$ lie on its graph, so they satisfy\n$$\nP(0)=5,\\quad P(2)=3,\\quad P(4)=7.\n$$\nFrom $P(0)=5$ we obtain $c=5$.\n\nUsing $P(2)=3$ gives\n$$\n4a+2b+c=3 \\;\\Longrightarrow\\; 4a+2b+5=3 \\;\\Longrightarrow\\; 4a+2b=-2 \\;\\Longrightarrow\\; 2a+b=-1.\n$$\nUsing $P(4)=7$ gives\n$$\n16a+4b+c=7 \\;\\Longrightarrow\\; 16a+4b+5=7 \\;\\Longrightarrow\\; 16a+4b=2 \\;\\Longrightarrow\\; 8a+2b=1.\n$$\nSubtracting $2\\cdot(2a+b=-1)$, i.e., $4a+2b=-2$, from $8a+2b=1$ yields\n$$\n(8a+2b)-(4a+2b)=1-(-2)\\;\\Longrightarrow\\; 4a=3 \\;\\Longrightarrow\\; a=\\frac{3}{4}.\n$$\nSubstituting into $2a+b=-1$ gives\n$$\n2\\cdot \\frac{3}{4}+b=-1 \\;\\Longrightarrow\\; \\frac{3}{2}+b=-1 \\;\\Longrightarrow\\; b=-\\frac{5}{2}.\n$$\nTherefore,\n$$\nP(x)=\\frac{3}{4}x^{2}-\\frac{5}{2}x+5.\n$$\nSince $a=\\frac{3}{4}>0$, the parabola opens upward, so $P(x)$ attains its minimum at the vertex $x^{*}=-\\frac{b}{2a}$. Compute\n$$\nx^{*}=-\\frac{b}{2a}=-\\frac{-\\frac{5}{2}}{2\\cdot \\frac{3}{4}}=\\frac{\\frac{5}{2}}{\\frac{3}{2}}=\\frac{5}{3}.\n$$\nThe minimum value can be computed using the identity $P_{\\min}=c-\\frac{b^{2}}{4a}$ for $a>0$:\n$$\nP_{\\min}=5-\\frac{\\left(-\\frac{5}{2}\\right)^{2}}{4\\cdot \\frac{3}{4}}=5-\\frac{\\frac{25}{4}}{3}=5-\\frac{25}{12}=\\frac{60}{12}-\\frac{25}{12}=\\frac{35}{12}.\n$$\nThus, the minimum value of $P(x)$ is $\\frac{35}{12}$.", "answer": "$$\\boxed{\\frac{35}{12}}$$", "id": "2183531"}, {"introduction": "While constructing a Lagrange polynomial can seem like a purely mechanical task, keen observation can often reveal underlying simplicities that save a great deal of work. This problem [@problem_id:2183548] presents a function that appears complex but possesses special properties when evaluated at integer nodes. By analyzing the function's behavior at these specific points before diving into calculations, you can leverage the uniqueness theorem of interpolating polynomials to find a dramatically simplified solution.", "problem": "Let $P_n(x)$ be the unique Lagrange interpolating polynomial of degree at most $n$ for a given function $f(x)$ at the $n+1$ distinct integer nodes $x_j = j$, where $j = 0, 1, 2, \\dots, n$.\n\nThe function to be interpolated is given by:\n$$f(x) = C_1 \\exp\\left(\\frac{\\cos(k_1 \\pi x) - 1}{2}\\right) + C_2 \\frac{\\sin(k_2 \\pi x)}{1 + x^4}$$\n\nThe parameters involved are real constants and integers, defined as follows:\n- $n$ is a positive integer such that $n \\ge 1$.\n- $k_1$ is a non-zero even integer.\n- $k_2$ is a non-zero integer.\n- $C_1$ and $C_2$ are arbitrary real constants.\n\nYour task is to determine the value of the definite integral of the interpolating polynomial $P_n(x)$ from $0$ to $1$. Express your answer as a closed-form analytic expression in terms of the given parameters.", "solution": "The goal is to compute the definite integral $I = \\int_0^1 P_n(x) dx$. The polynomial $P_n(x)$ is the Lagrange interpolating polynomial of degree at most $n$ for the function $f(x)$ at the integer nodes $x_j = j$ for $j = 0, 1, \\dots, n$.\n\nBy definition, the interpolating polynomial must match the function value at each node. That is, $P_n(x_j) = f(x_j)$ for all $j \\in \\{0, 1, \\dots, n\\}$. Let's evaluate the function $f(x)$ at these integer nodes.\n\nFor any node $x_j = j$, where $j$ is an integer, we analyze the two terms of $f(x_j)$:\n\nFirst term: $T_1 = C_1 \\exp\\left(\\frac{\\cos(k_1 \\pi j) - 1}{2}\\right)$.\nWe are given that $k_1$ is a non-zero even integer. We can write $k_1 = 2m$ for some non-zero integer $m$.\nThe argument of the cosine function is $k_1 \\pi j = 2m \\pi j$. For any integers $m$ and $j$, the product $mj$ is also an integer.\nThe cosine of any integer multiple of $2\\pi$ is always 1.\nTherefore, $\\cos(k_1 \\pi j) = \\cos(2m \\pi j) = 1$.\nSubstituting this result into the first term:\n$$T_1 = C_1 \\exp\\left(\\frac{1 - 1}{2}\\right) = C_1 \\exp\\left(\\frac{0}{2}\\right) = C_1 \\exp(0) = C_1 \\cdot 1 = C_1$$\n\nSecond term: $T_2 = C_2 \\frac{\\sin(k_2 \\pi j)}{1 + j^4}$.\nWe are given that $k_2$ is a non-zero integer.\nThe argument of the sine function is $k_2 \\pi j$. For any integers $k_2$ and $j$, the product $k_2 j$ is also an integer.\nThe sine of any integer multiple of $\\pi$ is always 0.\nTherefore, $\\sin(k_2 \\pi j) = 0$.\nSubstituting this result into the second term:\n$$T_2 = C_2 \\frac{0}{1 + j^4} = 0$$\n\nCombining these two results, we find the value of the function $f(x)$ at each node $x_j = j$:\n$$f(x_j) = f(j) = T_1 + T_2 = C_1 + 0 = C_1$$\nThis means that for all nodes $x_0, x_1, \\dots, x_n$, the function has the same constant value, $C_1$. The interpolation points are $(0, C_1), (1, C_1), (2, C_1), \\dots, (n, C_1)$.\n\nThe Lagrange interpolating polynomial $P_n(x)$ is the unique polynomial of degree at most $n$ that passes through these $n+1$ points.\nConsider the constant polynomial $Q(x) = C_1$. This is a polynomial of degree 0. Since we are given $n \\ge 1$, the degree of $Q(x)$ is less than or equal to $n$.\nAlso, $Q(j) = C_1$ for all $j=0, 1, \\dots, n$.\nSince $Q(x)$ is a polynomial of degree at most $n$ that satisfies the interpolation conditions, and the Lagrange interpolating polynomial is unique, it must be that $P_n(x) = Q(x)$.\nTherefore, the interpolating polynomial is simply $P_n(x) = C_1$.\n\nAlternatively, using the formal definition of the Lagrange polynomial:\n$$P_n(x) = \\sum_{j=0}^{n} f(x_j) L_j(x)$$\nwhere $L_j(x)$ are the Lagrange basis polynomials. Since we found $f(x_j) = C_1$ for all $j$:\n$$P_n(x) = \\sum_{j=0}^{n} C_1 L_j(x) = C_1 \\sum_{j=0}^{n} L_j(x)$$\nA fundamental property of Lagrange basis polynomials is that their sum is unity: $\\sum_{j=0}^{n} L_j(x) = 1$.\nThus, $P_n(x) = C_1 \\cdot 1 = C_1$.\n\nNow we can compute the required integral:\n$$I = \\int_0^1 P_n(x) dx = \\int_0^1 C_1 dx$$\nSince $C_1$ is a constant, we can pull it out of the integral:\n$$I = C_1 \\int_0^1 1 \\, dx = C_1 [x]_0^1 = C_1 (1 - 0) = C_1$$\nThe value of the definite integral is $C_1$.", "answer": "$$\\boxed{C_1}$$", "id": "2183548"}, {"introduction": "The theoretical properties of Lagrange polynomials provide a powerful foundation for developing practical computational algorithms. A classic example is using the degree of an interpolating polynomial to test if a set of points is collinear. This coding challenge [@problem_id:2425948] asks you to translate this elegant mathematical principle into a robust program, forcing you to confront real-world computational issues such as floating-point precision and geometric edge cases like vertical lines.", "problem": "You are given finite sets of planar points $\\{(x_i,y_i)\\}_{i=0}^{n}$, with $n \\ge 1$. A set of points is collinear if and only if there exists a straight line that contains all points. A straight line can be represented either as $y = a x + b$ for some real $a$ and $b$ (non-vertical lines), or as $x = c$ for some real $c$ (vertical lines). Your task is to design and implement a program that determines collinearity by examining the degree of the unique interpolating polynomial constructed in the Lagrange form for the non-vertical case, combined with a logically necessary pre-check to correctly handle the vertical case.\n\nFundamental base to be used:\n- The definition of a polynomialâ€™s degree as the highest exponent of $x$ with a nonzero coefficient.\n- The fact that for distinct abscissas $x_0,\\dots,x_n$, there exists a unique polynomial $p(x)$ of degree at most $n$ that interpolates the data $(x_i,y_i)$, and that any such polynomial coincides with the data exactly at $n+1$ interpolation nodes.\n- The definition of collinearity for planar points as lying on a single line.\n\nDesign requirements for the algorithm:\n- If all $x$-coordinates are equal within a numeric tolerance $\\tau$, conclude the points are collinear on a vertical line and return $\\mathrm{True}$.\n- If there exist two points with the same $x$-coordinate but different $y$-coordinates (differing by more than $\\tau$), while not all $x$-coordinates are equal within $\\tau$, conclude the set cannot lie on any single straight line and return $\\mathrm{False}$.\n- Otherwise, remove exact duplicate points, ensure the remaining interpolation nodes have distinct $x$-coordinates, construct the Lagrange interpolating polynomial $p(x)$ for $y$ as a function of $x$, convert it to monomial coefficients, determine its effective degree by treating any coefficient with absolute value $\\le \\tau$ as zero, and declare the set collinear if and only if the effective degree is at most $1$.\n- Use a fixed tolerance $\\tau = 10^{-10}$ for all zero tests and vertical-line checks, and treat all computations using real arithmetic. The program must not assume any special structure beyond what is stated here.\n- If the number of unique points (after removing duplicates) is at most $2$, return $\\mathrm{True}$ because any two points are collinear.\n\nInput for your program is fixed by the following test suite embedded directly in your source code. For each case, interpret each pair $(x,y)$ as using dimensionless units.\n- Case $\\#1$ (non-vertical, linear): $\\{(-1, -1), (0, 1), (2, 5)\\}$.\n- Case $\\#2$ (non-vertical, non-linear): $\\{(0, 0), (1, 1), (2, 2.1)\\}$.\n- Case $\\#3$ (vertical line): $\\{(3, 0), (3, 5), (3, -2)\\}$.\n- Case $\\#4$ (duplicates included, linear): $\\{(1, 2), (1, 2), (2, 4), (3, 6)\\}$.\n- Case $\\#5$ (conflicting equal $x$ with different $y$ and a different $x$ present): $\\{(1, 2), (1, 3), (2, 4)\\}$.\n- Case $\\#6$ (exactly two points): $\\{(-100, 50), (200, -250)\\}$.\n- Case $\\#7$ (near-linear with tiny perturbation well below tolerance): $\\{(0, 1), (1, 0.5), (2, 0), (3, -0.5 + 10^{-12})\\}$.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the above test cases. Each result must be a boolean $\\mathrm{True}$ or $\\mathrm{False}$ with no spaces. For example, the format must be like $[r_A,r_B,r_C]$.\n\nConstraints and notes:\n- Use only real arithmetic with a fixed tolerance $\\tau = 10^{-10}$ for coefficient trimming and equality checks as specified.\n- The implementation must be self-contained and not require any input. The outputs must be computed from the hard-coded test suite.", "solution": "The problem is to determine if a given set of $n+1$ planar points, $\\{(x_i, y_i)\\}_{i=0}^{n}$ for $n \\ge 1$, is collinear. Collinearity dictates that all points must lie on a single straight line, which may be non-vertical (of the form $y = ax + b$) or vertical (of the form $x = c$). The method prescribed is to use polynomial interpolation, based on the principle that a set of points lies on a non-vertical line if and only if the unique interpolating polynomial passing through them has a degree of at most $1$. This must be augmented with logic to handle numerical precision and the special case of vertical lines. The problem is well-posed and scientifically sound, so we proceed with the design of a rigorous algorithm.\n\nThe algorithmic procedure is constructed in a sequence of logical steps, designed to handle all cases and numerical artifacts systematically. A numerical tolerance $\\tau = 10^{-10}$ is used for all floating-point comparisons.\n\nFirst, the input data must be sanitized. We are given a set of points, which may contain duplicates. Any two points define a line, so if the number of unique points is less than or equal to $2$, the set is trivially collinear. We begin by reducing the input to a set of unique points. Let this set be $S$. If $|S| \\le 2$, we conclude the points are collinear and terminate.\n\nSecond, we must address the case of vertical lines. A vertical line is described by the equation $x=c$ for some constant $c$. This is not a function of the form $y=f(x)$, and thus cannot be represented by a standard polynomial in $x$. This case is identified by checking if all points in the unique set $S$ have the same $x$-coordinate, within the tolerance $\\tau$. Let $X = \\{x | (x, y) \\in S\\}$. If $\\max(X) - \\min(X) \\le \\tau$, all points lie on a vertical line, and we conclude they are collinear.\n\nThird, for the non-vertical case, the points must represent a single-valued function. That is, for any two points $(x_i, y_i)$ and $(x_j, y_j)$ in $S$, if $x_i$ is numerically indistinguishable from $x_j$, then $y_i$ must also be numerically indistinguishable from $y_j$. If we find two points where $|x_i - x_j| \\le \\tau$ but $|y_i - y_j| > \\tau$, then no function $y=f(x)$ can pass through both. Since the vertical line case has already been excluded, no single line can contain these points. We must therefore check for this condition and conclude the points are not collinear if it is met. This step also serves to prepare the data for interpolation. We can group points whose $x$-coordinates are within $\\tau$ of each other. If any such group has a spread of $y$-coordinates greater than $\\tau$, we have found a contradiction. Otherwise, we can replace each group with a single representative point, for instance, by averaging the coordinates within the group. This process yields a new set of points, $S'$, where all $x$-coordinates are distinct (separated by more than $\\tau$). If, after this consolidation, the number of points $|S'| \\le 2$, the set is again trivially collinear.\n\nFourth, with a sanitized set of $N+1$ points $S' = \\{(x'_j, y'_j)\\}_{j=0}^{N}$ (where $N+1 = |S'| > 2$) having distinct abscissas, we can apply the fundamental theorem of polynomial interpolation. There exists a unique polynomial $p(x)$ of degree at most $N$ such that $p(x'_j) = y'_j$ for all $j \\in \\{0, \\dots, N\\}$. This polynomial can be constructed in the Lagrange form:\n$$\np(x) = \\sum_{j=0}^{N} y'_j L_j(x), \\quad \\text{where} \\quad L_j(x) = \\prod_{k=0, k \\ne j}^{N} \\frac{x - x'_k}{x'_j - x'_k}\n$$\nThe points are collinear if and only if they lie on a line $y = ax+b$, which is a polynomial of degree $1$ (or degree $0$ if $a=0$). Therefore, the collinearity condition is equivalent to the degree of the unique interpolating polynomial $p(x)$ being at most $1$.\n\nTo determine the degree, we must convert $p(x)$ to its monomial representation, $p(x) = \\sum_{k=0}^{N} c_k x^k$. In practical computation with floating-point numbers, coefficients that are theoretically zero may appear as very small non-zero values. We must therefore determine the \"effective degree\" of the polynomial. The effective degree is defined as the largest integer $k$ for which the absolute value of the corresponding coefficient, $|c_k|$, is greater than the tolerance $\\tau$. If all coefficients $c_k$ for $k > 1$ satisfy $|c_k| \\le \\tau$, the effective degree is at most $1$, and we conclude the points are collinear. Otherwise, the points are not collinear. If all coefficients satisfy $|c_k| \\le \\tau$, the effective degree is considered to be less than or equal to $1$, and the points are collinear (representing a horizontal line close to $y=0$). This completes the algorithm.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import lagrange\n\ndef solve():\n    \"\"\"\n    Solves the collinearity problem for a predefined suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case #1 (non-vertical, linear)\n        [(-1, -1), (0, 1), (2, 5)],\n        # Case #2 (non-vertical, non-linear)\n        [(0, 0), (1, 1), (2, 2.1)],\n        # Case #3 (vertical line)\n        [(3, 0), (3, 5), (3, -2)],\n        # Case #4 (duplicates included, linear)\n        [(1, 2), (1, 2), (2, 4), (3, 6)],\n        # Case #5 (conflicting equal x with different y and a different x present)\n        [(1, 2), (1, 3), (2, 4)],\n        # Case #6 (exactly two points)\n        [(-100, 50), (200, -250)],\n        # Case #7 (near-linear with tiny perturbation well below tolerance)\n        [(0, 1), (1, 0.5), (2, 0), (3, -0.5 + 1e-12)],\n    ]\n\n    tolerance = 1e-10\n    \n    results = []\n    for points in test_cases:\n        result = is_collinear(points, tolerance)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef is_collinear(points, tau):\n    \"\"\"\n    Determines if a set of points is collinear based on the degree of the\n    interpolating polynomial and special case checks.\n\n    Args:\n        points (list of tuples): A list of (x, y) coordinates.\n        tau (float): The numerical tolerance for floating-point comparisons.\n\n    Returns:\n        bool: True if the points are collinear, False otherwise.\n    \"\"\"\n    # 1. Remove exact duplicates and handle trivial cases.\n    unique_points = sorted(list(set(points)))\n    if len(unique_points) <= 2:\n        return True\n\n    x_coords = np.array([p[0] for p in unique_points])\n    y_coords = np.array([p[1] for p in unique_points])\n\n    # 2. Check for vertical line.\n    # np.ptp (peak-to-peak) is equivalent to max(arr) - min(arr)\n    if np.ptp(x_coords) <= tau:\n        return True\n\n    # 3. Consolidate points with close x-coordinates and check for function validity.\n    # This step ensures that for each x, there is a unique y (within tolerance)\n    # and prepares a set of nodes with distinct x for interpolation.\n    consolidated_points = []\n    \n    # The unique_points are already sorted by x-coordinate (default tuple sort).\n    # We group points with numerically equal x-coordinates.\n    i = 0\n    while i < len(unique_points):\n        # Start a new group\n        group_indices = [i]\n        j = i + 1\n        while j < len(unique_points) and abs(unique_points[j][0] - unique_points[i][0]) <= tau:\n            group_indices.append(j)\n            j += 1\n        \n        # Process the group\n        group_y = y_coords[group_indices]\n        if np.ptp(group_y) > tau:\n            # Contradiction: same x, different y. Not a function.\n            return False\n        \n        # The group is valid, consolidate into a single point by averaging.\n        group_x = x_coords[group_indices]\n        avg_x = np.mean(group_x)\n        avg_y = np.mean(group_y)\n        consolidated_points.append((avg_x, avg_y))\n        \n        i = j # Move to the start of the next group\n\n    if len(consolidated_points) <= 2:\n        return True\n\n    # 4. Perform Lagrange interpolation and check the degree.\n    x_final = np.array([p[0] for p in consolidated_points])\n    y_final = np.array([p[1] for p in consolidated_points])\n    \n    # Construct the unique interpolating polynomial.\n    poly = lagrange(x_final, y_final)\n    \n    # 5. Determine the effective degree.\n    effective_degree = 0\n    # a_n is the coefficient of the highest power\n    coeffs = poly.coeffs\n    for i, coeff in enumerate(coeffs):\n        if abs(coeff) > tau:\n            # Degree is (number of coeffs - 1) for the first element,\n            # and decreases with index.\n            effective_degree = len(coeffs) - 1 - i\n            break\n    \n    return effective_degree <= 1\n\n# Execute the solution\nsolve()\n```", "id": "2425948"}]}