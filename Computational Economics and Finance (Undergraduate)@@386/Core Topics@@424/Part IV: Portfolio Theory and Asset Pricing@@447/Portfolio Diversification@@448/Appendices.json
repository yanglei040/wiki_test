{"hands_on_practices": [{"introduction": "This first practice gets to the heart of why diversification works by exploring how combining assets systematically reduces a portfolio's idiosyncratic (asset-specific) risk. By working through a formal model, you will derive and computationally verify the famous result that much of the diversifiable risk can be eliminated with a surprisingly small number of assets, a principle often summarized by the \"$1/N$ rule\" [@problem_id:2420248]. This exercise highlights the power of using expectation to uncover fundamental financial principles, distinguishing them from the noise of specific data points.", "id": "2420248", "problem": "You are given a formal model of diversifiable risk within a finite stock universe. Consider a universe with $K$ assets indexed by $i \\in \\{1,\\dots,K\\}$. Each asset $i$ has an idiosyncratic variance $d_i$ (that is, the variance of the asset’s idiosyncratic return component). Assume idiosyncratic shocks are mutually independent across assets and independent of any systematic component. For any subset $S \\subset \\{1,\\dots,K\\}$ with $|S| = N$ and an equal-weight portfolio formed on $S$ with weights $w_i = 1/N$ for $i \\in S$, define the portfolio’s diversifiable risk (the idiosyncratic variance contribution) as\n$$\nV_{\\text{idio}}(S) = \\sum_{i \\in S} w_i^2 d_i.\n$$\nDefine the baseline diversifiable risk of a single asset in the universe as the cross-sectional mean\n$$\n\\bar d = \\frac{1}{K} \\sum_{i=1}^{K} d_i.\n$$\nFor a given $N$, define the remaining diversifiable risk fraction of an equal-weight $N$-asset portfolio, in expectation over a uniformly random choice of $S$ of size $N$, as\n$$\nR(N) = \\mathbb{E}\\left[ \\frac{V_{\\text{idio}}(S)}{\\bar d} \\right],\n$$\nwhere the expectation is taken with respect to the uniform distribution over all subsets $S$ of size $N$.\n\nYour task is: for each stock universe below, empirically determine the minimum number of assets $N$ required such that at least $95\\%$ of the diversifiable risk is eliminated in expectation, that is, such that $1 - R(N) \\ge 0.95$, equivalently $R(N) \\le 0.05$. If no such $N$ exists with $1 \\le N \\le K$, output $-1$. All proportions must be expressed as decimals (for example, use $0.95$ rather than a percentage sign).\n\nTest suite:\n\n- Case A: $K = 25$, idiosyncratic variances\n  $(\\, $0.0289$, $0.0225$, $0.0361$, $0.0196$, $0.0400$, $0.0256$, $0.0324$, $0.0169$, $0.0484$, $0.0276$, $0.0304$, $0.0216$, $0.0336$, $0.0180$, $0.0450$, $0.0240$, $0.0260$, $0.0290$, $0.0310$, $0.0340$, $0.0380$, $0.0420$, $0.0460$, $0.0500$, $0.0550$ \\,)$, target elimination $0.95$.\n\n- Case B: $K = 20$, idiosyncratic variances\n  $(\\, $0.0200$, $0.0225$, $0.0256$, $0.0289$, $0.0324$, $0.0361$, $0.0400$, $0.0441$, $0.0484$, $0.0529$, $0.0196$, $0.0216$, $0.0230$, $0.0260$, $0.0290$, $0.0330$, $0.0370$, $0.0410$, $0.0450$, $0.0490$ \\,)$, target elimination $0.95$.\n\n- Case C: $K = 19$, idiosyncratic variances\n  $(\\, $0.0180$, $0.0190$, $0.0200$, $0.0210$, $0.0220$, $0.0230$, $0.0240$, $0.0250$, $0.0260$, $0.0270$, $0.0280$, $0.0290$, $0.0300$, $0.0310$, $0.0320$, $0.0330$, $0.0340$, $0.0350$, $0.0360$ \\,)$, target elimination $0.95$.\n\n- Case D: $K = 30$, idiosyncratic variances\n  $(\\, $0.0150$, $0.0160$, $0.0170$, $0.0180$, $0.0190$, $0.0200$, $0.0210$, $0.0220$, $0.0230$, $0.0240$, $0.0250$, $0.0260$, $0.0270$, $0.0280$, $0.0290$, $0.0300$, $0.0310$, $0.0320$, $0.0330$, $0.0340$, $0.0350$, $0.0360$, $0.0370$, $0.0380$, $0.0390$, $0.0400$, $0.0410$, $0.0420$, $0.0430$, $0.0440$ \\,)$, target elimination $0.95$.\n\nRequired final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\,\\text{resultA},\\text{resultB},\\text{resultC},\\text{resultD}\\,]$). Each result must be an integer. Use $-1$ if no $N$ satisfies the requirement for the given universe.", "solution": "The problem statement is coherent and grounded in established financial theory. An analytical solution is possible and shall be derived. The objective is to determine the minimum number of assets $N$, constrained by $1 \\le N \\le K$, required to reduce the expected diversifiable risk to a specified level.\n\nThe condition for risk elimination is given as $1 - R(N) \\ge 0.95$, which is equivalent to the remaining diversifiable risk fraction $R(N)$ being less than or equal to $0.05$. The target is to find the minimum integer $N$ that satisfies $R(N) \\le 0.05$ and the constraint $1 \\le N \\le K$.\n\nThe remaining risk fraction is defined as:\n$$\nR(N) = \\mathbb{E}\\left[ \\frac{V_{\\text{idio}}(S)}{\\bar d} \\right]\n$$\nwhere the portfolio's idiosyncratic variance, $V_{\\text{idio}}(S)$, for an equal-weight portfolio with weights $w_i = 1/N$ on a set $S$ of size $N$, is:\n$$\nV_{\\text{idio}}(S) = \\sum_{i \\in S} w_i^2 d_i = \\sum_{i \\in S} \\left(\\frac{1}{N}\\right)^2 d_i = \\frac{1}{N^2} \\sum_{i \\in S} d_i\n$$\nThe baseline risk, $\\bar d = \\frac{1}{K} \\sum_{i=1}^{K} d_i$, is a constant for a given asset universe. We can therefore move it and other constants outside the expectation operator:\n$$\nR(N) = \\frac{1}{\\bar d} \\mathbb{E}[V_{\\text{idio}}(S)] = \\frac{1}{N^2 \\bar d} \\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right]\n$$\nTo evaluate the expectation $\\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right]$, we employ the principle of linearity of expectation. Let $\\mathbf{1}_{j \\in S}$ be an indicator random variable that equals $1$ if asset $j$ is in the randomly selected portfolio $S$, and $0$ otherwise. The sum can be written over the entire universe of $K$ assets:\n$$\n\\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right] = \\mathbb{E}\\left[ \\sum_{j=1}^{K} d_j \\mathbf{1}_{j \\in S} \\right] = \\sum_{j=1}^{K} d_j \\mathbb{E}[\\mathbf{1}_{j \\in S}]\n$$\nThe expectation $\\mathbb{E}[\\mathbf{1}_{j \\in S}]$ is the probability that any specific asset $j$ is included in a subset $S$ of size $N$ chosen uniformly at random. The total number of such subsets is $\\binom{K}{N}$. To construct a subset containing asset $j$, we must select the remaining $N-1$ assets from the available $K-1$ assets, which can be done in $\\binom{K-1}{N-1}$ ways. The probability is therefore:\n$$\nP(j \\in S) = \\frac{\\binom{K-1}{N-1}}{\\binom{K}{N}} = \\frac{(K-1)!}{(N-1)!(K-N)!} \\cdot \\frac{N!(K-N)!}{K!} = \\frac{N}{K}\n$$\nThis probability is uniform for all assets. Substituting this into the expectation for the sum:\n$$\n\\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right] = \\sum_{j=1}^{K} d_j \\left(\\frac{N}{K}\\right) = \\frac{N}{K} \\sum_{j=1}^{K} d_j\n$$\nRecalling the definition of the mean idiosyncratic variance, $\\bar d = \\frac{1}{K} \\sum_{j=1}^{K} d_j$, we have $\\sum_{j=1}^{K} d_j = K \\bar d$. Therefore:\n$$\n\\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right] = \\frac{N}{K} (K \\bar d) = N \\bar d\n$$\nWe now substitute this result back into the expression for $R(N)$:\n$$\nR(N) = \\frac{1}{N^2 \\bar d} (N \\bar d) = \\frac{1}{N}\n$$\nThis derivation yields the fundamental result that $R(N) = 1/N$. It is a crucial observation that this result is independent of the specific values or the distribution of the idiosyncratic variances $\\{d_i\\}_{i=1}^K$, provided their mean $\\bar d$ is non-zero. Consequently, the provided numerical data for these variances are irrelevant to determining the expected risk fraction.\n\nThe problem requires finding the minimum integer $N$ such that $R(N) \\le 0.05$. Applying our result:\n$$\n\\frac{1}{N} \\le 0.05\n$$\nSolving this inequality for $N$ gives:\n$$\nN \\ge \\frac{1}{0.05} \\implies N \\ge 20\n$$\nThe minimum integer $N$ satisfying this condition is $N=20$. This solution is only valid if it is possible to construct a portfolio of this size from the given universe, meaning $N$ must be less than or equal to $K$.\n\nThe final logic is as follows:\n\\begin{enumerate}\n    \\item If the universe size $K$ is greater than or equal to $20$, the minimum required number of assets is $N=20$.\n    \\item If $K$ is less than $20$, it is impossible to form a portfolio of $20$ assets, so no value of $N$ in the allowed range $1 \\le N \\le K$ can satisfy the condition. The answer in this case is $-1$.\n\\end{enumerate}\n\nApplying this reasoning to the specified test cases:\n\\begin{itemize}\n    \\item Case A: $K = 25$. Since $25 \\ge 20$, the minimum required $N$ is $20$.\n    \\item Case B: $K = 20$. Since $20 \\ge 20$, the minimum required $N$ is $20$.\n    \\item Case C: $K = 19$. Since $19 < 20$, no valid $N$ exists. The result is $-1$.\n    \\item Case D: $K = 30$. Since $30 \\ge 20$, the minimum required $N$ is $20$.\n\\end{itemize}\nThe solution for each case is determined exclusively by the value of $K$ relative to the derived threshold of $20$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the minimum number of assets N to achieve a target risk elimination level.\n\n    As derived in the solution, the expected remaining diversifiable risk fraction R(N)\n    for an N-asset equal-weight portfolio is R(N) = 1/N. This result is independent\n    of the specific idiosyncratic variances of the assets.\n\n    The problem requires finding the minimum integer N such that R(N) <= 0.05,\n    which simplifies to 1/N <= 0.05, or N >= 20.\n\n    The solution N must also be within the bounds of the asset universe, 1 <= N <= K.\n    Therefore, if K >= 20, the minimum N is 20. If K < 20, no such N exists.\n    \"\"\"\n\n    # The test cases are defined by the total number of assets, K.\n    # The lists of idiosyncratic variances are superfluous to the problem's solution.\n    # The target elimination of 0.95 (implying R(N) <= 0.05) is constant across all cases.\n    test_cases_K = [\n        25,  # Case A\n        20,  # Case B\n        19,  # Case C\n        30,  # Case D\n    ]\n\n    # The required risk elimination fraction is 0.95.\n    target_elimination = 0.95\n    # This implies the remaining risk fraction, R(N), must be <= 1 - 0.95.\n    max_remaining_fraction = 1.0 - target_elimination\n\n    # From R(N) = 1/N, we need 1/N <= max_remaining_fraction.\n    # This implies N >= 1/max_remaining_fraction.\n    # For max_remaining_fraction = 0.05, this means N >= 20.\n    min_N_required = int(np.ceil(1.0 / max_remaining_fraction))\n\n    results = []\n    for K in test_cases_K:\n        # Check if a portfolio of the required size can be formed.\n        if K >= min_N_required:\n            # If the universe is large enough, the minimum N is the calculated threshold.\n            result = min_N_required\n        else:\n            # If the universe is too small, no solution exists.\n            result = -1\n        results.append(result)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "The classic mean-variance framework is powerful, but it treats all volatility—upside and downside—as equally \"risky\". This practice moves beyond that simplification by introducing downside deviation, or semi-variance, as a risk measure that focuses only on returns falling below a certain threshold $\\tau$ [@problem_id:2420250]. You will formulate and solve a portfolio optimization problem to construct an efficient frontier based on this more intuitive definition of risk, $\\sigma_-^2(w;\\tau) = \\frac{1}{T} \\sum_{t=1}^T \\max\\\\!\\\\left(0,\\\\, \\\\tau - w^\\\\top r_t \\\\right)^2$, thereby learning a practical skill used in modern asset management.", "id": "2420250", "problem": "You are given sample monthly returns for a universe of risky assets and asked to recompute an efficient frontier using downside deviation (semi-variance) with respect to a specified threshold as the risk metric. A portfolio is represented by weights $w \\in \\mathbb{R}^N$ with $w_i \\geq 0$ for all $i$ and $\\sum_{i=1}^N w_i = 1$. Given a time series $\\{r_t\\}_{t=1}^T$ of asset return vectors $r_t \\in \\mathbb{R}^N$, the sample expected portfolio return is $\\mu(w) = \\frac{1}{T} \\sum_{t=1}^T w^\\top r_t$. For a given threshold $\\tau \\in \\mathbb{R}$, the sample semi-variance is\n$$\n\\sigma_-^2(w;\\tau) = \\frac{1}{T} \\sum_{t=1}^T \\max\\!\\left(0,\\, \\tau - w^\\top r_t \\right)^2,\n$$\nand the downside deviation is $d(w;\\tau) = \\sqrt{\\sigma_-^2(w;\\tau)}$. All returns are unitless and expressed as decimals.\n\nYour task is to compute, for each specified test case below, the minimum downside deviation $d^\\star(\\mu_{\\text{target}},\\tau)$ over all portfolios $w$ that satisfy $w_i \\ge 0$, $\\sum_{i=1}^N w_i = 1$, and $\\mu(w) \\ge \\mu_{\\text{target}}$.\n\nData: There are $N=3$ assets and $T=12$ months. The monthly returns for each asset are:\n\n- Asset $1$: $[-0.01,\\ 0.005,\\ 0.012,\\ 0.007,\\ -0.004,\\ 0.009,\\ 0.011,\\ 0.006,\\ 0.003,\\ 0.008,\\ 0.010,\\ 0.007]$.\n- Asset $2$: $[-0.015,\\ 0.012,\\ 0.018,\\ 0.010,\\ -0.006,\\ 0.015,\\ 0.020,\\ 0.011,\\ 0.004,\\ 0.013,\\ 0.019,\\ 0.012]$.\n- Asset $3$: $[-0.03,\\ 0.025,\\ 0.035,\\ 0.020,\\ -0.015,\\ 0.028,\\ 0.038,\\ 0.022,\\ 0.010,\\ 0.030,\\ 0.036,\\ 0.024]$.\n\nLet the asset return at month $t$ be the column vector $r_t \\in \\mathbb{R}^3$ extracted from the above sequences.\n\nTest Suite: Compute $d^\\star(\\mu_{\\text{target}},\\tau)$ for each of the following parameter pairs $(\\mu_{\\text{target}},\\tau)$:\n\n- Case $1$: $(\\mu_{\\text{target}},\\tau) = (0.007,\\ 0.0)$.\n- Case $2$: $(\\mu_{\\text{target}},\\tau) = (0.012,\\ 0.005)$.\n- Case $3$: $(\\mu_{\\text{target}},\\tau) = (0.018,\\ 0.015)$.\n- Case $4$: $(\\mu_{\\text{target}},\\tau) = (0.0185833333333,\\ 0.020)$.\n\nConventions and requirements:\n\n- All returns are decimals; do not use a percentage sign.\n- The final answers for each case must be the minimized downside deviation values $d^\\star(\\mu_{\\text{target}},\\tau)$, each expressed as a decimal rounded to exactly $6$ places after the decimal point.\n- Your program must produce a single line of output containing the results in the order of the cases above as a comma-separated list enclosed in square brackets, for example $[x_1,x_2,x_3,x_4]$, where each $x_i$ is the rounded decimal for Case $i$.\n\nYour program must be a complete, runnable program that computes the required values from first principles based on the definitions above and the provided data and produces the output in the exact required format. No user input is allowed, and no external files are used.", "solution": "The problem has been analyzed and is determined to be valid. It is a well-posed, scientifically grounded problem in the field of computational finance, free of any ambiguities or contradictions.\n\nThe task is to find the minimum downside deviation for a portfolio of $N=3$ assets, given a time series of returns over $T=12$ periods. This requires solving a constrained nonlinear optimization problem for several specified parameter sets.\n\nThe portfolio is defined by a vector of weights $w \\in \\mathbb{R}^N$, where $w_i$ is the weight of asset $i$. The constraints on the portfolio weights are:\n$1.$ Non-negativity: $w_i \\ge 0$ for $i=1, 2, \\dots, N$. This means no short selling is allowed.\n$2.$ Fully invested: $\\sum_{i=1}^N w_i = 1$. The entire capital is allocated among the assets.\n\nThe sample expected portfolio return is defined as $\\mu(w) = \\frac{1}{T} \\sum_{t=1}^T w^\\top r_t$, where $r_t \\in \\mathbb{R}^N$ is the vector of asset returns at time $t$. This can be simplified to $\\mu(w) = w^\\top \\bar{r}$, where $\\bar{r} = \\frac{1}{T} \\sum_{t=1}^T r_t$ is the vector of mean asset returns.\n\nThe risk metric is the sample downside deviation, $d(w;\\tau) = \\sqrt{\\sigma_-^2(w;\\tau)}$, where $\\sigma_-^2(w;\\tau)$ is the sample semi-variance with respect to a return threshold $\\tau$:\n$$\n\\sigma_-^2(w;\\tau) = \\frac{1}{T} \\sum_{t=1}^T \\max\\!\\left(0,\\, \\tau - w^\\top r_t \\right)^2\n$$\nMinimizing the downside deviation $d(w;\\tau)$ is equivalent to minimizing the semi-variance $\\sigma_-^2(w;\\tau)$, as the square root function is strictly monotonic for non-negative values. This avoids dealing with the square root in the optimization objective, simplifying the problem.\n\nFor each test case, defined by a pair $(\\mu_{\\text{target}}, \\tau)$, we must solve the following optimization problem:\n$$\n\\begin{aligned}\n\\underset{w}{\\text{minimize}} \\quad & \\sigma_-^2(w;\\tau) = \\frac{1}{T} \\sum_{t=1}^T \\max(0, \\tau - w^\\top r_t)^2 \\\\\n\\text{subject to} \\quad & w \\in \\mathbb{R}^N \\\\\n& \\sum_{i=1}^N w_i = 1 \\\\\n& w_i \\ge 0, \\quad \\text{for } i=1, \\dots, N \\\\\n& \\mu(w) \\ge \\mu_{\\text{target}}\n\\end{aligned}\n$$\nThis is a convex optimization problem, as the objective function $\\sigma_-^2(w;\\tau)$ is a convex function of $w$, and the constraints define a convex feasible set (a polytope). Consequently, any local minimum found is also a global minimum.\n\nThe problem will be solved numerically using the Sequential Least Squares Programming (SLSQP) algorithm, which is well-suited for constrained nonlinear optimization. The implementation will be done in Python using the `scipy.optimize.minimize` function. The inputs to the solver are:\n- The objective function, which calculates $\\sigma_-^2(w;\\tau)$ for a given weight vector $w$.\n- The set of constraints: an equality constraint for the sum of weights, an inequality constraint for the minimum target return, and bounds for the non-negativity of weights.\n- An initial guess for the weights $w$, for which an equally weighted portfolio, $w_i = 1/N$, is a standard choice.\n\nThe final answer for each case, $d^\\star(\\mu_{\\text{target}},\\tau)$, is obtained by taking the square root of the minimized semi-variance returned by the optimizer. The provided asset return data and test case parameters will be used to compute the four requested values.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Computes the minimum downside deviation for a portfolio of assets\n    subject to a target return constraint.\n    \"\"\"\n    # Define asset return data\n    asset1_returns = np.array([-0.01, 0.005, 0.012, 0.007, -0.004, 0.009, 0.011, 0.006, 0.003, 0.008, 0.010, 0.007])\n    asset2_returns = np.array([-0.015, 0.012, 0.018, 0.010, -0.006, 0.015, 0.020, 0.011, 0.004, 0.013, 0.019, 0.012])\n    asset3_returns = np.array([-0.03, 0.025, 0.035, 0.020, -0.015, 0.028, 0.038, 0.022, 0.010, 0.030, 0.036, 0.024])\n\n    # Combine into a single matrix R of shape (T, N)\n    returns_matrix = np.vstack([asset1_returns, asset2_returns, asset3_returns]).T\n    \n    T, N = returns_matrix.shape\n    mean_asset_returns = np.mean(returns_matrix, axis=0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.007, 0.0),\n        (0.012, 0.005),\n        (0.018, 0.015),\n        (0.0185833333333, 0.020),\n    ]\n\n    results = []\n    for mu_target, tau in test_cases:\n        # Define the objective function (semi-variance) to be minimized.\n        # w: portfolio weights (optimization variable)\n        # R: matrix of asset returns\n        # T_val: number of time periods\n        # tau_val: downside deviation threshold\n        def objective_func(w, R, T_val, tau_val):\n            portfolio_returns = R @ w\n            downside_diffs = np.maximum(0, tau_val - portfolio_returns)\n            semi_variance = np.sum(downside_diffs**2) / T_val\n            return semi_variance\n\n        # Define constraints for the optimization\n        constraints = [\n            # Constraint 1: Sum of weights must be 1 (fully invested)\n            {'type': 'eq', 'fun': lambda w: np.sum(w) - 1},\n            # Constraint 2: Portfolio expected return must meet or exceed target\n            {'type': 'ineq', 'fun': lambda w: w @ mean_asset_returns - mu_target}\n        ]\n\n        # Define bounds for the weights (w_i >= 0, no short selling)\n        bounds = [(0, None) for _ in range(N)]\n\n        # Initial guess for the weights (equal weighting)\n        w0 = np.ones(N) / N\n\n        # Perform the optimization using SLSQP\n        opt_result = minimize(\n            objective_func,\n            w0,\n            args=(returns_matrix, T, tau),\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            tol=1e-12  # Set a tight tolerance for accuracy\n        )\n\n        # The result from the optimizer is the minimized semi-variance\n        min_semi_variance = opt_result.fun\n        \n        # The required answer is the downside deviation (sqrt of semi-variance)\n        min_downside_deviation = np.sqrt(min_semi_variance)\n        \n        results.append(min_downside_deviation)\n\n    # Format the results as specified: a comma-separated list of decimals\n    # rounded to 6 places, enclosed in square brackets.\n    output_str = '[' + ','.join([f\"{r:.6f}\" for r in results]) + ']'\n    print(output_str)\n\nsolve()\n```"}, {"introduction": "An optimal portfolio on paper is useless if the cost to achieve it is prohibitively high. This final exercise bridges the gap between theory and practice by introducing the critical real-world friction of transaction costs into the optimization problem [@problem_id:2420328]. You will develop a computational model to find the truly optimal portfolio by balancing the benefit of rebalancing towards a theoretical ideal against the drag of a non-linear trading cost function, $C(\\\\Delta \\\\mathbf{w}) = k \\\\sum_{i=1}^{N} |\\\\Delta w_{i}|^{1.5}$, tackling a core challenge in quantitative portfolio management.", "id": "2420328", "problem": "You are given a single-period portfolio rebalancing problem with $N$ assets, an initial weight vector $\\mathbf{w}^{0} \\in \\mathbb{R}^{N}$, an expected return vector $\\boldsymbol{\\mu} \\in \\mathbb{R}^{N}$, and a symmetric positive definite covariance matrix $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{N \\times N}$. A risk-aversion parameter $\\gamma \\in \\mathbb{R}_{+}$ trades off expected return against risk in a Mean-Variance Optimization (MVO) objective, and portfolio weights must satisfy a budget constraint $\\sum_{i=1}^{N} w_{i} = 1$. Short-selling is allowed, so there are no inequality bounds on $\\mathbf{w}$ beyond the budget constraint. Rebalancing incurs non-linear transaction costs given by the function $C(\\Delta \\mathbf{w}) = k \\sum_{i=1}^{N} |\\Delta w_{i}|^{1.5}$ for a coefficient $k \\in \\mathbb{R}_{+}$, where $\\Delta \\mathbf{w} = \\mathbf{w} - \\mathbf{w}^{0}$. All answers must be expressed as pure numbers with no units.\n\nStarting only from the definitions of expected return, variance, and the given transaction cost function, and without using any shortcut formulas provided by this problem statement, you must:\n\n- Formulate the rebalancing problem as the maximization of expected net utility under the budget constraint, using the fundamental MVO objective that balances expected return and variance, minus the given transaction cost.\n- Derive the gradient of the objective with respect to $\\mathbf{w}$ and argue about the concavity of the objective and the convexity of the feasible set.\n- Design a computational approach that solves the constrained optimization by iterative methods that rely on the gradient and a projection operator that enforces the budget constraint $\\sum_{i=1}^{N} w_{i} = 1$ at each step. Ensure numerical stability for the non-linear cost term and justify your line-search or step-size policy.\n\nYour program must implement this approach and compute the optimal post-trade weight vector $\\mathbf{w}^{\\star}$ for each of the following test cases. In all cases, use the exact numbers provided. When an array or matrix is given, use it exactly as specified. For all cases, the budget constraint is $\\sum_{i=1}^{N} w_{i} = 1$ and short-selling is allowed.\n\nTest Suite:\n\n- Case $1$ (general concave objective with non-zero transaction costs):\n  - $N = 4$\n  - $\\boldsymbol{\\mu} = [0.08, 0.12, 0.10, 0.07]$\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}([0.04, 0.09, 0.0625, 0.0324])$\n  - $\\gamma = 5.0$\n  - $k = 0.01$\n  - $\\mathbf{w}^{0} = [0.25, 0.25, 0.25, 0.25]$\n\n- Case $2$ (boundary case with zero transaction costs):\n  - $N = 4$\n  - $\\boldsymbol{\\mu} = [0.08, 0.12, 0.10, 0.07]$\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}([0.04, 0.09, 0.0625, 0.0324])$\n  - $\\gamma = 5.0$\n  - $k = 0.0$\n  - $\\mathbf{w}^{0} = [0.25, 0.25, 0.25, 0.25]$\n\n- Case $3$ (high transaction costs discourage rebalancing):\n  - $N = 4$\n  - $\\boldsymbol{\\mu} = [0.08, 0.12, 0.10, 0.07]$\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}([0.04, 0.09, 0.0625, 0.0324])$\n  - $\\gamma = 5.0$\n  - $k = 10.0$\n  - $\\mathbf{w}^{0} = [0.10, 0.50, 0.20, 0.20]$\n\n- Case $4$ (different dimension and parameters):\n  - $N = 3$\n  - $\\boldsymbol{\\mu} = [0.15, 0.05, 0.09]$\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}([0.1225, 0.0225, 0.04])$\n  - $\\gamma = 8.0$\n  - $k = 0.02$\n  - $\\mathbf{w}^{0} = [0.20, 0.60, 0.20]$\n\nRequired final output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- Each result must be an inner list of floats representing the optimal weights $\\mathbf{w}^{\\star}$ for the corresponding test case, in the same order as the cases are listed above.\n- Round each weight to $6$ decimal places.\n- For example, the shape of the output must be like $[[w_{1,1}, w_{1,2}, \\dots],[w_{2,1}, \\dots],\\dots]$ and the program must print exactly one line with this list.\n\nYour program must be fully self-contained, require no user input, and use only the standard library together with the specified allowed libraries. The answers are lists of floats. No percentages, physical units, or angle units are involved in this problem. The mathematical model must be implemented exactly as stated, and the optimization must enforce $\\sum_{i=1}^{N} w_{i} = 1$ for every case.", "solution": "The problem statement is critically validated and is deemed valid. It is scientifically grounded in the principles of modern portfolio theory and convex optimization, well-posed with a unique solution guaranteed, and stated objectively with all necessary parameters provided. The problem asks for the formulation and solution of a single-period portfolio rebalancing problem, which is a formalizable problem in computational finance. All data is self-contained and consistent.\n\nThe problem is to find the optimal portfolio weight vector $\\mathbf{w}^{\\star} \\in \\mathbb{R}^{N}$ that maximizes the net utility of an investor, considering expected returns, risk, and transaction costs.\n\nFirst, we formulate the optimization problem. The investor's utility function, which we aim to maximize, incorporates three components: the expected portfolio return, a penalty for portfolio risk (variance), and the transaction costs incurred from rebalancing.\n\n1.  **Expected Portfolio Return**: Given the expected return vector $\\boldsymbol{\\mu} \\in \\mathbb{R}^{N}$ for $N$ assets and a portfolio weight vector $\\mathbf{w} \\in \\mathbb{R}^{N}$, the expected return is a linear function of the weights:\n    $$ E[R_p] = \\mathbf{w}^T \\boldsymbol{\\mu} = \\sum_{i=1}^{N} w_i \\mu_i $$\n\n2.  **Portfolio Risk (Variance)**: Given the covariance matrix of asset returns $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{N \\times N}$, the portfolio variance is a quadratic function of the weights:\n    $$ \\text{Var}(R_p) = \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w} $$\n    The Mean-Variance Optimization (MVO) objective penalizes this variance, scaled by a risk-aversion parameter $\\gamma > 0$. We adopt the standard formulation which uses a factor of $\\frac{1}{2}$ for mathematical convenience, leading to a risk penalty term of $\\frac{\\gamma}{2} \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w}$.\n\n3.  **Transaction Costs**: Rebalancing from an initial portfolio $\\mathbf{w}^0$ to a new portfolio $\\mathbf{w}$ incurs costs. The change in weights is $\\Delta \\mathbf{w} = \\mathbf{w} - \\mathbf{w}^0$. The specified cost function is non-linear:\n    $$ C(\\Delta \\mathbf{w}) = k \\sum_{i=1}^{N} |\\Delta w_{i}|^{1.5} = k \\sum_{i=1}^{N} |w_i - w_i^0|^{1.5} $$\n    where $k > 0$ is a transaction cost coefficient.\n\nThe total objective function $f(\\mathbf{w})$ to be maximized is the expected return minus the risk penalty and transaction costs:\n$$ f(\\mathbf{w}) = \\mathbf{w}^T \\boldsymbol{\\mu} - \\frac{\\gamma}{2} \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w} - k \\sum_{i=1}^{N} |w_i - w_i^0|^{1.5} $$\nThis maximization is subject to the budget constraint, which requires that the weights sum to unity:\n$$ \\sum_{i=1}^{N} w_i = 1 \\quad \\text{or, in vector notation,} \\quad \\mathbf{1}^T \\mathbf{w} = 1 $$\nThe complete optimization problem is therefore:\n$$ \\underset{\\mathbf{w} \\in \\mathbb{R}^N}{\\text{maximize}} \\quad f(\\mathbf{w}) \\quad \\text{subject to} \\quad \\mathbf{1}^T \\mathbf{w} = 1 $$\n\nNext, we analyze the properties of the problem. The feasible set defined by the constraint $\\mathbf{1}^T \\mathbf{w} = 1$ is an affine hyperplane in $\\mathbb{R}^N$, which is a closed and convex set.\nFor the objective function $f(\\mathbf{w})$, we analyze its concavity by examining its components.\n-   The term $\\mathbf{w}^T \\boldsymbol{\\mu}$ is linear in $\\mathbf{w}$, so it is both concave and convex.\n-   The term $-\\frac{\\gamma}{2} \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w}$ is a quadratic form. Since $\\boldsymbol{\\Sigma}$ is given as positive definite and $\\gamma > 0$, the matrix $-\\frac{\\gamma}{2}\\boldsymbol{\\Sigma}$ is negative definite. This implies that this term is a strictly concave function of $\\mathbf{w}$.\n-   The transaction cost term is $-k \\sum_{i=1}^{N} |w_i - w_i^0|^{1.5}$. The function $\\phi(x) = |x|^{1.5}$ is a convex function for $x \\in \\mathbb{R}$. Its second derivative, $\\phi''(x) = 0.75 |x|^{-0.5}$, is non-negative where defined. A sum of convex functions is convex, so $\\sum_{i=1}^{N} |w_i - w_i^0|^{1.5}$ is convex. Multiplying by $-k$ (where $k \\ge 0$) makes the term $-k \\sum_{i=1}^{N} |w_i - w_i^0|^{1.5}$ a concave function.\n\nThe objective function $f(\\mathbf{w})$ is the sum of a linear function (concave), a strictly concave function, and a concave function. The sum of a strictly concave function and other concave functions is strictly concave. Therefore, $f(\\mathbf{w})$ is a strictly concave function. Maximizing a strictly concave function over a closed, non-empty, convex set has a unique solution.\n\nTo solve this problem computationally, we design an iterative algorithm based on Projected Gradient Ascent, as requested. This method iteratively takes a step in the direction of the gradient of the objective function and then projects the resulting point back onto the feasible set.\n\nThe gradient of the objective function, $\\nabla f(\\mathbf{w})$, is required. We compute it term by term:\n-   $\\nabla (\\mathbf{w}^T \\boldsymbol{\\mu}) = \\boldsymbol{\\mu}$\n-   $\\nabla (-\\frac{\\gamma}{2} \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w}) = -\\gamma \\boldsymbol{\\Sigma} \\mathbf{w}$ (using the symmetry of $\\boldsymbol{\\Sigma}$)\n-   For the cost term, we find the partial derivative with respect to $w_i$:\n    $$ \\frac{\\partial}{\\partial w_i} \\left( -k \\sum_{j=1}^{N} |w_j - w_j^0|^{1.5} \\right) = -k \\frac{d}{d w_i} |w_i - w_i^0|^{1.5} $$\n    Let $u = w_i - w_i^0$. The derivative of $|u|^{1.5}$ with respect to $u$ is $1.5 \\cdot \\text{sgn}(u) \\cdot |u|^{0.5}$, which is well-defined and continuous for all $u \\in \\mathbb{R}$.\n    Thus, the gradient of the cost term is a vector with components $-1.5k \\cdot \\text{sgn}(w_i - w_i^0) \\cdot |w_i - w_i^0|^{0.5}$.\n\nCombining these, the full gradient is:\n$$ \\nabla f(\\mathbf{w}) = \\boldsymbol{\\mu} - \\gamma \\boldsymbol{\\Sigma} \\mathbf{w} - 1.5 k \\cdot \\mathbf{v}(\\mathbf{w}) $$\nwhere $\\mathbf{v}(\\mathbf{w})$ is a vector whose $i$-th component is $v_i = \\text{sgn}(w_i - w_i^0) \\sqrt{|w_i - w_i^0|}$. Numerically, we handle the case $w_i - w_i^0 = 0$ by noting that the derivative is $0$.\n\nThe Projected Gradient Ascent algorithm proceeds as follows:\n1.  Initialize weights $\\mathbf{w}^{(0)}$, ensuring they satisfy the budget constraint (e.g., $\\mathbf{w}^{(0)} = \\mathbf{w}^0$). Let $t=0$.\n2.  Repeat until convergence:\n    a.  Compute the gradient: $\\mathbf{g}^{(t)} = \\nabla f(\\mathbf{w}^{(t)})$.\n    b.  Perform an update step: $\\mathbf{w}_{\\text{temp}}^{(t+1)} = \\mathbf{w}^{(t)} + \\alpha_t \\mathbf{g}^{(t)}$, where $\\alpha_t > 0$ is the step size.\n    c.  Project back to the feasible set: $\\mathbf{w}^{(t+1)} = P(\\mathbf{w}_{\\text{temp}}^{(t+1)})$. The projection $P(\\mathbf{y})$ of a point $\\mathbf{y}$ onto the hyperplane $\\mathbf{1}^T\\mathbf{w}=1$ is given by:\n        $$ P(\\mathbf{y}) = \\mathbf{y} + \\left( \\frac{1 - \\mathbf{1}^T \\mathbf{y}}{N} \\right) \\mathbf{1} $$\n        This formula is derived by minimizing the Euclidean distance $||\\mathbf{w} - \\mathbf{y}||_2$ subject to $\\mathbf{1}^T\\mathbf{w}=1$.\n    d.  Increment $t$.\n\nThe step-size $\\alpha_t$ is crucial for convergence. A fixed, small step size can work but is inefficient. We will use a backtracking line search to determine an appropriate $\\alpha_t$ at each iteration. This method ensures sufficient increase in the objective function and provides robust convergence. Starting with an initial guess for $\\alpha$, we iteratively reduce it (e.g., by a factor $\\beta \\in (0,1)$\n) until the Armijo-Goldstein condition is satisfied:\n$$ f(\\mathbf{w}^{(t+1)}) \\ge f(\\mathbf{w}^{(t)}) + c \\cdot (\\mathbf{g}^{(t)})^T (\\mathbf{w}^{(t+1)} - \\mathbf{w}^{(t)}) $$\nfor a constant $c \\in (0,1)$.\n\nThe algorithm terminates when the change in the weight vector between iterations is negligible, i.e., $||\\mathbf{w}^{(t+1)} - \\mathbf{w}^{(t)}||_2 < \\epsilon$ for a small tolerance $\\epsilon$.\n\nFor numerical stability, the term $\\sqrt{|w_i - w_i^0|}$ is implemented as `np.sqrt(np.abs(w_i - w_i^0))` to prevent any issues with floating-point arithmetic that might result in a negative argument to the square root. The `np.sign` function in NumPy correctly handles the case where the argument is zero.\n\nThe following Python code implements this Projected Gradient Ascent algorithm with backtracking line search to solve for the optimal weight vector $\\mathbf{w}^{\\star}$ for each of the given test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of portfolio rebalancing problems using\n    the Projected Gradient Ascent method with backtracking line search.\n    \"\"\"\n\n    def compute_objective(w, mu, Sigma, gamma, k, w0):\n        \"\"\"Computes the value of the objective function.\"\"\"\n        expected_return = w.T @ mu\n        risk_penalty = 0.5 * gamma * w.T @ Sigma @ w\n        delta_w = w - w0\n        transaction_cost = k * np.sum(np.abs(delta_w)**1.5)\n        return expected_return - risk_penalty - transaction_cost\n\n    def compute_gradient(w, mu, Sigma, gamma, k, w0):\n        \"\"\"Computes the gradient of the objective function.\"\"\"\n        delta_w = w - w0\n        # The derivative of |x|^1.5 is 1.5 * sgn(x) * |x|^0.5.\n        # np.sign(0) is 0, which is correct for the derivative at x=0.\n        grad_cost_term = 1.5 * k * np.sign(delta_w) * np.sqrt(np.abs(delta_w))\n        grad = mu - gamma * Sigma @ w - grad_cost_term\n        return grad\n\n    def project(y):\n        \"\"\"Projects a vector y onto the budget constraint hyperplane sum(w)=1.\"\"\"\n        N = len(y)\n        return y + (1 - np.sum(y)) / N * np.ones(N)\n\n    def optimize_portfolio(mu, Sigma, gamma, k, w0):\n        \"\"\"\n        Performs Projected Gradient Ascent to find the optimal portfolio.\n        \"\"\"\n        N = len(mu)\n        w = w0.copy()\n\n        # Hyperparameters for the optimization algorithm\n        max_iter = 50000\n        tolerance = 1e-12\n        alpha_init = 1.0  # Initial step size for backtracking\n        beta = 0.5      # Backtracking line search factor\n        c = 1e-4        # Armijo condition constant\n\n        for i in range(max_iter):\n            f_w = compute_objective(w, mu, Sigma, gamma, k, w0)\n            grad = compute_gradient(w, mu, Sigma, gamma, k, w0)\n            \n            alpha = alpha_init\n            while True:\n                w_temp = w + alpha * grad\n                w_new = project(w_temp)\n                \n                f_w_new = compute_objective(w_new, mu, Sigma, gamma, k, w0)\n                \n                # Armijo condition for sufficient increase\n                # Note: For maximization, we check f_new >= f_old + ...\n                if f_w_new >= f_w + c * np.dot(grad, w_new - w):\n                    break\n                \n                alpha *= beta\n                if alpha < 1e-15: # Prevent infinitely small step size\n                    break\n\n            # Convergence check\n            if np.linalg.norm(w_new - w) < tolerance:\n                w = w_new\n                break\n            \n            w = w_new\n        \n        return w\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 4,\n            \"mu\": np.array([0.08, 0.12, 0.10, 0.07]),\n            \"Sigma\": np.diag([0.04, 0.09, 0.0625, 0.0324]),\n            \"gamma\": 5.0,\n            \"k\": 0.01,\n            \"w0\": np.array([0.25, 0.25, 0.25, 0.25])\n        },\n        {\n            \"N\": 4,\n            \"mu\": np.array([0.08, 0.12, 0.10, 0.07]),\n            \"Sigma\": np.diag([0.04, 0.09, 0.0625, 0.0324]),\n            \"gamma\": 5.0,\n            \"k\": 0.0,\n            \"w0\": np.array([0.25, 0.25, 0.25, 0.25])\n        },\n        {\n            \"N\": 4,\n            \"mu\": np.array([0.08, 0.12, 0.10, 0.07]),\n            \"Sigma\": np.diag([0.04, 0.09, 0.0625, 0.0324]),\n            \"gamma\": 5.0,\n            \"k\": 10.0,\n            \"w0\": np.array([0.10, 0.50, 0.20, 0.20])\n        },\n        {\n            \"N\": 3,\n            \"mu\": np.array([0.15, 0.05, 0.09]),\n            \"Sigma\": np.diag([0.1225, 0.0225, 0.04]),\n            \"gamma\": 8.0,\n            \"k\": 0.02,\n            \"w0\": np.array([0.20, 0.60, 0.20])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        w_star = optimize_portfolio(\n            case[\"mu\"], case[\"Sigma\"], case[\"gamma\"], case[\"k\"], case[\"w0\"]\n        )\n        # Round each weight to 6 decimal places and convert to list\n        rounded_weights = np.round(w_star, 6).tolist()\n        results.append(rounded_weights)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) and join is tricky for lists of lists.\n    # We build the string representation manually.\n    result_str = \",\".join([str(res) for res in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"}]}