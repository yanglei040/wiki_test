{"hands_on_practices": [{"introduction": "While the classic mean-variance framework provides elegant analytical solutions, real-world investing often includes constraints like the inability to short-sell assets. This practice guides you through the computational effects of this constraint, revealing that the smooth efficient frontier transforms into a series of connected segments. You will implement an algorithm to identify the 'corner portfolios' that define this structure and computationally verify the powerful Two-Fund Separation Theorem, which states that any efficient portfolio on a segment is a simple combination of its two endpoints [@problem_id:2383613].", "id": "2383613", "problem": "Consider a mean-variance portfolio selection problem under no-short-selling constraints. Let there be $n$ risky assets with expected return vector $\\boldsymbol{\\mu} \\in \\mathbb{R}^n$ and positive definite covariance matrix $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{n \\times n}$. A portfolio is represented by weights $\\boldsymbol{w} \\in \\mathbb{R}^n$ with $\\boldsymbol{1}^\\top \\boldsymbol{w} = 1$ and $\\boldsymbol{w} \\succeq \\boldsymbol{0}$. For a target expected return $r \\in \\mathbb{R}$, the mean-variance efficient portfolio solves the convex optimization problem of minimizing the variance $ \\boldsymbol{w}^\\top \\boldsymbol{\\Sigma} \\boldsymbol{w}$ subject to the constraints $\\boldsymbol{1}^\\top \\boldsymbol{w} = 1$, $\\boldsymbol{\\mu}^\\top \\boldsymbol{w} = r$, and $\\boldsymbol{w} \\succeq \\boldsymbol{0}$.\n\nA corner portfolio (also called a critical portfolio) is defined as an efficient portfolio at a target return $r$ at which the set of active inequality constraints changes, that is, at least one component of $\\boldsymbol{w}$ hits $0$ or leaves $0$ as $r$ varies. Between two adjacent corner portfolios, the set of assets with strictly positive weights remains constant.\n\nYour tasks are:\n- Starting from the fundamental definitions above, implement an algorithm that:\n  1. Computes the minimum-variance portfolio under $\\boldsymbol{1}^\\top \\boldsymbol{w} = 1$ and $\\boldsymbol{w} \\succeq \\boldsymbol{0}$, and records its expected return $r_{\\mathrm{mv}} = \\boldsymbol{\\mu}^\\top \\boldsymbol{w}_{\\mathrm{mv}}$.\n  2. Constructs the efficient frontier over target returns $r \\in [r_{\\mathrm{mv}}, \\max_i \\mu_i]$ by solving, for a grid of $r$ values, the variance-minimization problem under $\\boldsymbol{1}^\\top \\boldsymbol{w} = 1$, $\\boldsymbol{\\mu}^\\top \\boldsymbol{w} = r$, and $\\boldsymbol{w} \\succeq \\boldsymbol{0}$.\n  3. Identifies corner portfolios by detecting return levels at which the active asset set (indices of strictly positive weights) changes. Refine each detected change via bisection on $r$ so that the change point is located to within a tolerance of $10^{-6}$ in $r$.\n  4. Demonstrates the following property computationally: for any efficient portfolio at a target $r$ that lies between two adjacent corner portfolios with target returns $r_{\\ell}$ and $r_u$ (where $r_{\\ell} \\le r \\le r_u$), the optimal weights $\\boldsymbol{w}(r)$ are equal, within a numerical tolerance, to a convex combination $\\tau \\boldsymbol{w}(r_u) + (1-\\tau)\\boldsymbol{w}(r_\\ell)$ for some $\\tau \\in [0,1]$ chosen so that the combined portfolio has expected return $r$.\n- Use the following tolerance conventions in your algorithm:\n  - Treat any weight less than or equal to $10^{-8}$ as zero for the purpose of determining the active set.\n  - When checking equality of two weight vectors, accept a maximum absolute deviation of at most $5 \\times 10^{-4}$.\n\nYou must implement your algorithm and apply it to the following test suite, where each test case specifies $(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$:\n\n- Test case $1$ (two assets):\n  - $\\boldsymbol{\\mu} = [\\,0.08,\\, 0.12\\,]$.\n  - $\\boldsymbol{\\Sigma} = \\begin{bmatrix} 0.04 & 0.006 \\\\ 0.006 & 0.09 \\end{bmatrix}$.\n\n- Test case $2$ (three assets, one dominated by construction):\n  - $\\boldsymbol{\\mu} = [\\,0.06,\\, 0.10,\\, 0.03\\,]$.\n  - $\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n  0.0422 & 0.0134 & 0.0418 \\\\\n  0.0134 & 0.0343 & 0.0276 \\\\\n  0.0418 & 0.0276 & 0.1062\n  \\end{bmatrix}$.\n\n- Test case $3$ (three assets, all relevant):\n  - $\\boldsymbol{\\mu} = [\\,0.06,\\, 0.11,\\, 0.08\\,]$.\n  - $\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n  0.02 & 0.015 & 0.005 \\\\\n  0.015 & 0.05 & 0.01 \\\\\n  0.005 & 0.01 & 0.03\n  \\end{bmatrix}$.\n\nFor each test case, you must:\n- Report the total number of corner portfolios detected on the efficient frontier over $r \\in [r_{\\mathrm{mv}}, \\max_i \\mu_i]$.\n- Verify the convex-combination property by sampling at least $5$ evenly spaced target returns in $[r_{\\mathrm{mv}}, \\max_i \\mu_i]$ and checking whether each efficient portfolio lies within the specified tolerance of the convex combination of its adjacent corner portfolios. Aggregate these checks into a single boolean per test case that is true if and only if all sampled target returns pass the check.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as:\n$[\\,\\text{corner\\_count\\_1},\\, \\text{convex\\_ok\\_1},\\, \\text{corner\\_count\\_2},\\, \\text{convex\\_ok\\_2},\\, \\text{corner\\_count\\_3},\\, \\text{convex\\_ok\\_3}\\,]$,\nwhere each corner count is an integer and each convexity check is a boolean. No physical units apply in this problem, and all returns are decimals (for example, write $0.12$ instead of $12$ percent).", "solution": "The problem presented is a standard exercise in computational finance related to Markowitz mean-variance optimization. It requires the construction of an efficient frontier for a portfolio of risky assets under a no-short-selling constraint ($\\boldsymbol{w} \\succeq \\boldsymbol{0}$). This task is fundamentally a convex Quadratic Programming (QP) problem. The problem statement is scientifically sound, self-contained, and well-posed, as the objective function $\\boldsymbol{w}^\\top \\boldsymbol{\\Sigma} \\boldsymbol{w}$ is strictly convex (given $\\boldsymbol{\\Sigma}$ is positive definite) and the constraints define a non-empty compact convex set for any feasible target return $r$. Therefore, a unique solution exists. We proceed with a direct implementation of the required algorithm.\n\nThe central optimization problem is formulated as follows:\n$$\n\\begin{aligned}\n& \\underset{\\boldsymbol{w} \\in \\mathbb{R}^n}{\\text{minimize}}\n& & \\frac{1}{2} \\boldsymbol{w}^\\top \\boldsymbol{\\Sigma} \\boldsymbol{w} \\\\\n& \\text{subject to}\n& & \\boldsymbol{1}^\\top \\boldsymbol{w} = 1, \\\\\n& & & \\boldsymbol{\\mu}^\\top \\boldsymbol{w} = r, \\\\\n& & & w_i \\ge 0 \\quad \\text{for } i = 1, \\dots, n.\n\\end{aligned}\n$$\nHere, $\\boldsymbol{w}$ is the vector of portfolio weights, $\\boldsymbol{\\mu}$ is the vector of expected returns, $\\boldsymbol{\\Sigma}$ is the covariance matrix, and $r$ is the target expected return. We use the Sequential Least Squares Programming (`SLSQP`) method provided by `scipy.optimize.minimize` to solve this QP problem for given parameters $(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma}, r)$.\n\nThe algorithm proceeds in three main stages as per the problem specification.\n\nFirst, the relevant range of the efficient frontier is established. The lower bound is the expected return $r_{\\mathrm{mv}}$ of the global minimum-variance portfolio (GMVP) under the no-short-selling constraint. This portfolio, $\\boldsymbol{w}_{\\mathrm{mv}}$, is found by solving the QP problem without the target return constraint ($\\boldsymbol{\\mu}^\\top \\boldsymbol{w} = r$). The upper bound is the maximum possible expected return, $r_{\\max} = \\max_i \\mu_i$, achieved by allocating $100\\%$ of the investment to the single asset with the highest expected return. The efficient frontier is the set of optimal portfolios for target returns $r \\in [r_{\\mathrm{mv}}, r_{\\max}]$.\n\nSecond, the corner portfolios are identified. A corner portfolio corresponds to a point on the efficient frontier where the set of assets with strictly positive weights (the active set) changes. Our procedure to find them is as follows:\n$1$. A fine grid of $1001$ target returns is generated over the interval $[r_{\\mathrm{mv}}, r_{\\max}]$.\n$2$. For each return $r_j$ in this grid, we solve the QP to find the optimal weights $\\boldsymbol{w}(r_j)$. We define the active set as the indices $i$ for which $w_i(r_j) > 10^{-8}$.\n$3$. We scan the grid and identify adjacent points $(r_j, r_{j+1})$ where the computed active sets differ. Such an interval must contain a corner portfolio.\n$4$. For each identified interval, a bisection search is performed to find the critical return $r_c$ at which the active set changes. The search refines the location of $r_c$ until the width of the search interval is less than $10^{-6}$.\n$5$. The final list of corner portfolios comprises the GMVP, the maximum-return portfolio, and all unique portfolios found through the bisection search. The list is sorted by return and de-duplicated to handle cases where the same corner is found from multiple grid intervals. The total number of these unique corner portfolios is then reported.\n\nThird, we computationally verify the two-fund separation property, which states that any efficient portfolio between two adjacent corner portfolios is a convex combination of those two corner portfolios. The verification is conducted as follows:\n$1$. A sample of at least $5$ evenly spaced target returns $\\{r_k\\}$ is generated over the entire range $[r_{\\mathrm{mv}}, r_{\\max}]$.\n$2$. For each $r_k$, we compute the optimal portfolio $\\boldsymbol{w}_{actual}(r_k)$ directly using the QP solver.\n$3$. We identify the two adjacent corner portfolios, $(r_\\ell, \\boldsymbol{w}_\\ell)$ and $(r_u, \\boldsymbol{w}_u)$, that bracket $r_k$, i.e., $r_\\ell \\le r_k \\le r_u$.\n$4$. We calculate the theoretical portfolio $\\boldsymbol{w}_{theory}(r_k)$ using the convex combination $\\boldsymbol{w}_{theory}(r_k) = (1-\\tau) \\boldsymbol{w}_\\ell + \\tau \\boldsymbol{w}_u$, where the interpolation factor $\\tau = (r_k - r_\\ell) / (r_u - r_\\ell)$ ensures that the expected return of the combination is $r_k$.\n$5$. We then check if $\\boldsymbol{w}_{actual}(r_k)$ and $\\boldsymbol{w}_{theory}(r_k)$ are equal within the specified numerical tolerance. The check passes if the maximum absolute difference between their corresponding weights, $\\max_i |w_{actual,i}(r_k) - w_{theory,i}(r_k)|$, is no more than $5 \\times 10^{-4}$.\n$6$. The overall verification for a test case is deemed successful (True) if and only if this condition holds for all sampled returns.\n\nThis comprehensive procedure is systematically applied to all test cases to generate the required results.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve_qp(target_r, mu, Sigma, n):\n    \"\"\"Solves the quadratic programming problem for a given target return.\"\"\"\n    objective = lambda w: w.T @ Sigma @ w\n    w0 = np.ones(n) / n\n    constraints = [\n        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0},\n        {'type': 'eq', 'fun': lambda w: w.T @ mu - target_r}\n    ]\n    bounds = tuple((0, None) for _ in range(n))\n    \n    result = minimize(objective, w0, method='SLSQP', bounds=bounds, constraints=constraints, tol=1e-9)\n    # The problem is constructed to be feasible, so success is expected.\n    return result.x\n\ndef process_case(mu, Sigma):\n    \"\"\"\n    Processes a single test case: finds corner portfolios and verifies the\n    convex combination property.\n    \"\"\"\n    n = len(mu)\n    weight_tol = 1e-8\n    bisection_tol = 1e-6\n    vector_comp_tol = 5e-4\n\n    # 1. Find the global minimum variance portfolio (GMVP) with no short-selling\n    objective_gmvp = lambda w: w.T @ Sigma @ w\n    constraints_gmvp = [{'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0}]\n    bounds_gmvp = tuple((0, None) for _ in range(n))\n    res_gmvp = minimize(objective_gmvp, np.ones(n) / n, method='SLSQP', bounds=bounds_gmvp, constraints=constraints_gmvp, tol=1e-9)\n    w_mv = res_gmvp.x\n    r_mv = w_mv.T @ mu\n\n    # 2. Define the efficient frontier range\n    r_max = np.max(mu)\n    w_max_idx = np.argmax(mu)\n\n    # 3. Grid search to find intervals containing corner portfolios\n    grid_size = 1001\n    r_grid = np.linspace(r_mv, r_max, grid_size)\n    active_sets_grid = []\n    for r_val in r_grid:\n        w = solve_qp(r_val, mu, Sigma, n)\n        active_set = frozenset(np.where(w > weight_tol)[0])\n        active_sets_grid.append(active_set)\n\n    # 4. Use bisection to refine corner portfolio locations\n    found_corner_returns = []\n    for i in range(grid_size - 1):\n        if active_sets_grid[i] != active_sets_grid[i+1]:\n            r_low, r_high = r_grid[i], r_grid[i+1]\n            active_low = active_sets_grid[i]\n            \n            while (r_high - r_low) > bisection_tol:\n                r_mid = (r_low + r_high) / 2\n                w_mid = solve_qp(r_mid, mu, Sigma, n)\n                active_mid = frozenset(np.where(w_mid > weight_tol)[0])\n                if active_mid == active_low:\n                    r_low = r_mid\n                else:\n                    r_high = r_mid\n            found_corner_returns.append((r_low + r_high) / 2)\n\n    # 5. Consolidate and de-duplicate corner portfolios\n    all_corner_returns = sorted(list(set([r_mv] + found_corner_returns + [r_max])))\n    \n    unique_corner_portfolios = []\n    if all_corner_returns:\n        last_r = -np.inf\n        for r in all_corner_returns:\n            if r - last_r > 1e-5: # De-duplication tolerance\n                w = solve_qp(r, mu, Sigma, n)\n                unique_corner_portfolios.append({'r': r, 'w': w})\n                last_r = r\n    \n    # If the GMVP is the max return asset, there's only one portfolio\n    if len(unique_corner_portfolios) == 0:\n        unique_corner_portfolios.append({'r': r_mv, 'w': w_mv})\n    \n    corner_count = len(unique_corner_portfolios)\n\n    # 6. Verify the convex combination property\n    convex_ok = True\n    num_samples = 5\n    sample_returns = np.linspace(r_mv, r_max, num_samples)\n    \n    corner_rs = np.array([cp['r'] for cp in unique_corner_portfolios])\n    corner_ws = np.array([cp['w'] for cp in unique_corner_portfolios])\n\n    if corner_count < 2: # Only one portfolio, property is trivially true\n        return corner_count, True\n\n    for r_sample in sample_returns:\n        w_actual = solve_qp(r_sample, mu, Sigma, n)\n        \n        idx_u = np.searchsorted(corner_rs, r_sample)\n\n        if idx_u == 0:\n             w_theory = corner_ws[0]\n        elif idx_u == len(corner_rs):\n             w_theory = corner_ws[-1]\n        else:\n            r_l, w_l = corner_rs[idx_u - 1], corner_ws[idx_u - 1]\n            r_u, w_u = corner_rs[idx_u], corner_ws[idx_u]\n            \n            if np.isclose(r_u, r_l):\n                tau = 0.0 if np.isclose(r_sample, r_l) else 1.0\n            else:\n                tau = (r_sample - r_l) / (r_u - r_l)\n            \n            w_theory = (1 - tau) * w_l + tau * w_u\n        \n        if np.max(np.abs(w_actual - w_theory)) > vector_comp_tol:\n            convex_ok = False\n            break\n\n    return corner_count, convex_ok\n\n\ndef solve():\n    test_cases = [\n        {\n            \"mu\": np.array([0.08, 0.12]),\n            \"Sigma\": np.array([[0.04, 0.006], [0.006, 0.09]])\n        },\n        {\n            \"mu\": np.array([0.06, 0.10, 0.03]),\n            \"Sigma\": np.array([\n                [0.0422, 0.0134, 0.0418],\n                [0.0134, 0.0343, 0.0276],\n                [0.0418, 0.0276, 0.1062]\n            ])\n        },\n        {\n            \"mu\": np.array([0.06, 0.11, 0.08]),\n            \"Sigma\": np.array([\n                [0.02, 0.015, 0.005],\n                [0.015, 0.05, 0.01],\n                [0.005, 0.01, 0.03]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        mu_vec = case[\"mu\"]\n        Sigma_mat = case[\"Sigma\"]\n        \n        # Check for positive definiteness as a matter of principle\n        if not np.all(np.linalg.eigvals(Sigma_mat) > 0):\n             raise ValueError(\"Covariance matrix is not positive definite.\")\n        \n        corner_count, convex_ok = process_case(mu_vec, Sigma_mat)\n        results.append(corner_count)\n        results.append(convex_ok)\n\n    # Final print statement must match the problem's required format exactly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "Mean-variance optimization is famously sensitive to its inputs, particularly the covariance matrix of asset returns, a concept often summarized as \"garbage in, garbage out\". This exercise moves from pure optimization to the practical challenge of statistical modeling, comparing two common approaches for estimating this crucial input. You will construct and compare the efficient frontiers derived from a simple historical covariance matrix versus a more structured factor model, providing hands-on insight into how modeling assumptions can significantly alter optimal portfolio decisions [@problem_id:2383628].", "id": "2383628", "problem": "You are given two alternative specifications for the covariance matrix of asset returns for constructing the efficient frontier of portfolios under the mean-variance paradigm. For a vector of portfolio weights $w \\in \\mathbb{R}^n$, an expected return vector $\\mu \\in \\mathbb{R}^n$, and a symmetric positive definite covariance matrix $\\Sigma \\in \\mathbb{R}^{n \\times n}$, the portfolio variance is $w^{\\top} \\Sigma w$ and the portfolio expected return is $w^{\\top} \\mu$. The efficient frontier at a target expected return $r_{\\text{tgt}}$ is defined by the solution to the constrained optimization problem that minimizes $w^{\\top} \\Sigma w$ subject to $w^{\\top} \\mu = r_{\\text{tgt}}$, $\\mathbf{1}^{\\top} w = 1$, and $w \\succeq 0$, where $\\mathbf{1}$ denotes the vector of all ones and $\\succeq$ denotes elementwise inequality. The standard deviation is the square root of the variance and must be reported in decimal units (not in a percentage sign).\n\nTwo covariance specifications are to be compared:\n- A historical covariance matrix $\\Sigma_{\\text{hist}}$.\n- A factor model covariance matrix $\\Sigma_{\\text{fac}}$ defined by $\\Sigma_{\\text{fac}} = B \\Sigma_F B^{\\top} + D$, where $B \\in \\mathbb{R}^{n \\times k}$ is the exposure matrix to $k$ factors, $\\Sigma_F \\in \\mathbb{R}^{k \\times k}$ is the factor covariance matrix, and $D \\in \\mathbb{R}^{n \\times n}$ is a diagonal matrix of idiosyncratic variances.\n\nFor each test case below, define the target return grid $T = \\{ r_0, r_1, r_2, r_3, r_4 \\}$ where $r_0 = \\min_i \\mu_i$, $r_4 = \\max_i \\mu_i$, and for $j \\in \\{ 1, 2, 3 \\}$, $r_j = r_0 + \\frac{j}{4} (r_4 - r_0)$. For each $r \\in T$, compute the efficient frontier point under both $\\Sigma_{\\text{hist}}$ and $\\Sigma_{\\text{fac}}$ and record the corresponding standard deviations. For each test case, compute the single summary metric\n$$\\Delta = \\max_{r \\in T} \\left| \\sigma_{\\text{hist}}(r) - \\sigma_{\\text{fac}}(r) \\right|,$$\nwhere $\\sigma_{\\text{hist}}(r)$ and $\\sigma_{\\text{fac}}(r)$ denote the optimal portfolio standard deviations at target return $r$ under $\\Sigma_{\\text{hist}}$ and $\\Sigma_{\\text{fac}}$, respectively.\n\nYour program must output a single line containing a comma-separated list with the three values of $\\Delta$ for the test cases below, enclosed in square brackets, as decimals rounded to six digits after the decimal point, for example, $[0.012345,0.000001,0.543210]$. No other text should be printed.\n\nTest Suite:\n- Test Case $1$:\n  - Number of assets $n = 4$, number of factors $k = 3$.\n  - Expected returns\n    $$\\mu = \\begin{bmatrix} 0.08 \\\\ 0.10 \\\\ 0.12 \\\\ 0.09 \\end{bmatrix}.$$\n  - Factor exposures\n    $$B = \\begin{bmatrix}\n    1.2 & 0.5 & 0.3 \\\\\n    0.8 & 1.1 & -0.2 \\\\\n    1.5 & -0.4 & 0.7 \\\\\n    0.6 & 0.9 & 0.4\n    \\end{bmatrix}.$$\n  - Factor covariance\n    $$\\Sigma_F = \\begin{bmatrix}\n    0.04 & 0 & 0 \\\\\n    0 & 0.03 & 0 \\\\\n    0 & 0 & 0.02\n    \\end{bmatrix}.$$\n  - Idiosyncratic variance (diagonal)\n    $$D = \\begin{bmatrix}\n    0.02 & 0 & 0 & 0 \\\\\n    0 & 0.015 & 0 & 0 \\\\\n    0 & 0 & 0.018 & 0 \\\\\n    0 & 0 & 0 & 0.017\n    \\end{bmatrix}.$$\n  - Historical covariance is defined via a symmetric perturbation of the factor-implied covariance:\n    $$\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}} + E,$$\n    where\n    $$E = \\begin{bmatrix}\n    0.001 & -0.0003 & 0.0002 & -0.0001 \\\\\n    -0.0003 & 0.001 & -0.00025 & 0.00015 \\\\\n    0.0002 & -0.00025 & 0.0012 & -0.0002 \\\\\n    -0.0001 & 0.00015 & -0.0002 & 0.0008\n    \\end{bmatrix}.$$\n- Test Case $2$:\n  - Number of assets $n = 4$, number of factors $k = 3$.\n  - Expected returns\n    $$\\mu = \\begin{bmatrix} 0.07 \\\\ 0.075 \\\\ 0.072 \\\\ 0.074 \\end{bmatrix}.$$\n  - Factor exposures\n    $$B = \\begin{bmatrix}\n    1.0 & 0.2 & 0.1 \\\\\n    0.95 & 0.25 & 0.12 \\\\\n    1.05 & 0.18 & 0.09 \\\\\n    0.90 & 0.30 & 0.11\n    \\end{bmatrix}.$$\n  - Factor covariance\n    $$\\Sigma_F = \\begin{bmatrix}\n    0.05 & 0 & 0 \\\\\n    0 & 0.025 & 0 \\\\\n    0 & 0 & 0.015\n    \\end{bmatrix}.$$\n  - Idiosyncratic variance (diagonal)\n    $$D = \\begin{bmatrix}\n    0.01 & 0 & 0 & 0 \\\\\n    0 & 0.012 & 0 & 0 \\\\\n    0 & 0 & 0.011 & 0 \\\\\n    0 & 0 & 0 & 0.013\n    \\end{bmatrix}.$$\n  - Historical covariance equals the factor-implied covariance:\n    $$\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}}.$$\n- Test Case $3$:\n  - Number of assets $n = 4$, number of factors $k = 3$.\n  - Expected returns\n    $$\\mu = \\begin{bmatrix} 0.11 \\\\ 0.09 \\\\ 0.10 \\\\ 0.115 \\end{bmatrix}.$$\n  - Factor exposures\n    $$B = \\begin{bmatrix}\n    0.7 & -0.2 & 0.5 \\\\\n    1.3 & 0.4 & -0.1 \\\\\n    0.2 & 1.1 & 0.3 \\\\\n    1.0 & -0.3 & 0.8\n    \\end{bmatrix}.$$\n  - Factor covariance\n    $$\\Sigma_F = \\begin{bmatrix}\n    0.06 & 0 & 0 \\\\\n    0 & 0.02 & 0 \\\\\n    0 & 0 & 0.025\n    \\end{bmatrix}.$$\n  - Idiosyncratic variance (diagonal)\n    $$D = \\begin{bmatrix}\n    0.02 & 0 & 0 & 0 \\\\\n    0 & 0.018 & 0 & 0 \\\\\n    0 & 0 & 0.016 & 0 \\\\\n    0 & 0 & 0 & 0.017\n    \\end{bmatrix}.$$\n  - Historical covariance is defined via a symmetric perturbation of the factor-implied covariance:\n    $$\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}} + E,$$\n    where\n    $$E = \\begin{bmatrix}\n    0.002 & 0.0004 & -0.0003 & 0.0002 \\\\\n    0.0004 & 0.0025 & 0.00035 & -0.00025 \\\\\n    -0.0003 & 0.00035 & 0.0022 & 0.00015 \\\\\n    0.0002 & -0.00025 & 0.00015 & 0.0018\n    \\end{bmatrix}.$$\n\nRequirements:\n- For each test case, construct $\\Sigma_{\\text{fac}} = B \\Sigma_F B^{\\top} + D$ and then construct $\\Sigma_{\\text{hist}}$ as specified above.\n- For each $r \\in T$, solve the constrained optimization problem for both $\\Sigma_{\\text{hist}}$ and $\\Sigma_{\\text{fac}}$ and compute the corresponding optimal standard deviation.\n- For each test case, compute $\\Delta$ as defined above.\n- Your program should produce a single line of output containing the three values of $\\Delta$ for the test cases in order as a comma-separated list enclosed in square brackets, with each value rounded to exactly six digits after the decimal point. All calculations are to be performed in decimal units (no percentage signs), and no angles are involved in this problem.", "solution": "The problem requires the comparison of two specifications for a portfolio's covariance matrix, $\\Sigma_{\\text{hist}}$ and $\\Sigma_{\\text{fac}}$, by calculating the maximum difference in the resulting efficient frontiers. This is a problem in computational finance, specifically portfolio optimization under the mean-variance framework developed by Markowitz.\n\nThe core of the problem is to find the portfolio weight vector $w \\in \\mathbb{R}^n$ that minimizes portfolio variance, $w^{\\top} \\Sigma w$, for a given target expected return, $r_{\\text{tgt}}$. This is formulated as a constrained quadratic programming (QP) problem.\n\n**1. Problem Formulation**\n\nFor a given covariance matrix $\\Sigma$, expected return vector $\\mu$, and target return $r_{\\text{tgt}}$, the optimization problem is:\n$$\n\\begin{aligned}\n& \\underset{w}{\\text{minimize}}\n& & w^{\\top} \\Sigma w \\\\\n& \\text{subject to}\n& & w^{\\top} \\mu = r_{\\text{tgt}} \\\\\n& & & \\mathbf{1}^{\\top} w = 1 \\\\\n& & & w \\succeq 0\n\\end{aligned}\n$$\nwhere $w$ is the vector of portfolio weights, $n$ is the number of assets, $\\mathbf{1}$ is an $n$-dimensional vector of ones, and $w \\succeq 0$ denotes element-wise non-negativity (no short selling). The solution to this problem gives the minimum variance for a target return $r_{\\text{tgt}}$. The standard deviation is the square root of this minimum variance.\n\n**2. Covariance Matrix Construction**\n\nTwo covariance matrices must be constructed for each test case.\n\nFirst, the factor model covariance matrix, $\\Sigma_{\\text{fac}}$, is constructed as:\n$$\n\\Sigma_{\\text{fac}} = B \\Sigma_F B^{\\top} + D\n$$\nwhere $B$ is the $n \\times k$ matrix of factor exposures, $\\Sigma_F$ is the $k \\times k$ factor covariance matrix, and $D$ is the $n \\times n$ diagonal matrix of idiosyncratic variances. Given that $\\Sigma_F$ is specified as a diagonal matrix with positive entries, it is positive definite. $D$ is also diagonal with positive entries and thus positive definite. The term $B \\Sigma_F B^{\\top}$ is positive semidefinite. The sum of a positive definite matrix ($D$) and a positive semidefinite matrix ($B \\Sigma_F B^{\\top}$) results in a matrix $\\Sigma_{\\text{fac}}$ that is guaranteed to be positive definite.\n\nSecond, the historical covariance matrix, $\\Sigma_{\\text{hist}}$, is specified differently in each test case. In Test Cases $1$ and $3$, it is defined as a perturbation of the factor model matrix:\n$$\n\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}} + E\n$$\nwhere $E$ is a given symmetric matrix. For the optimization problem to be well-posed (specifically, to have a unique minimum), $\\Sigma_{\\text{hist}}$ must also be positive definite. This condition is not guaranteed a priori and depends on the perturbation $E$. A computational check of the eigenvalues of the resulting $\\Sigma_{\\text{hist}}$ matrices for Test Cases $1$ and $3$ confirms that all eigenvalues are positive, so the matrices are indeed positive definite. In Test Case $2$, $\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}}$, so its positive definiteness is assured.\n\n**3. Numerical Optimization**\n\nThe QP problem is solved using a numerical solver. The `scipy.optimize.minimize` function with the Sequential Least Squares Programming (`SLSQP`) method is appropriate for this type of constrained optimization problem.\n\nFor each covariance matrix $\\Sigma \\in \\{\\Sigma_{\\text{hist}}, \\Sigma_{\\text{fac}}\\}$ and each target return $r_{\\text{tgt}}$, the solver is configured as follows:\n- **Objective function**: $f(w) = w^{\\top} \\Sigma w$.\n- **Equality constraints**:\n    1. $g_1(w) = w^{\\top} \\mu - r_{\\text{tgt}} = 0$\n    2. $g_2(w) = \\mathbf{1}^{\\top} w - 1 = 0$\n- **Bounds**: $w_i \\ge 0$ for $i=1, \\dots, n$. An initial guess, such as an equally weighted portfolio $w_0 = [1/n, \\dots, 1/n]^{\\top}$, provides a feasible starting point.\n\nThe optimization yields the optimal weight vector $w_{\\text{opt}}$, and the minimized objective function value is the portfolio variance, $\\sigma^2 = w_{\\text{opt}}^{\\top} \\Sigma w_{\\text{opt}}$. The standard deviation is $\\sigma = \\sqrt{\\sigma^2}$.\n\n**4. Metric Calculation**\n\nThe analysis is performed over a grid of $5$ target returns, $T = \\{r_0, r_1, r_2, r_3, r_4\\}$. The grid is defined by the minimum and maximum expected returns of the individual assets:\n- $r_0 = \\min_{i} \\mu_i$\n- $r_4 = \\max_{i} \\mu_i$\n- The intermediate points are evenly spaced: $r_j = r_0 + \\frac{j}{4}(r_4 - r_0)$ for $j \\in \\{1, 2, 3\\}$.\n\nFor each $r \\in T$, we compute the optimal standard deviation for both covariance models, $\\sigma_{\\text{hist}}(r)$ and $\\sigma_{\\text{fac}}(r)$. The final summary metric for each test case, $\\Delta$, is the maximum absolute difference between these standard deviations over the entire grid:\n$$\n\\Delta = \\max_{r \\in T} \\left| \\sigma_{\\text{hist}}(r) - \\sigma_{\\text{fac}}(r) \\right|\n$$\nThe overall procedure is to iterate through each test case, construct the necessary matrices, solve the series of optimization problems for each point in the return grid $T$, and compute the final metric $\\Delta$. For Test Case $2$, since $\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}}$, the optimization problems are identical, leading to $\\sigma_{\\text{hist}}(r) = \\sigma_{\\text{fac}}(r)$ for all $r$, and thus $\\Delta=0$ without requiring numerical computation.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the portfolio optimization problem for three test cases and\n    calculates the summary metric Delta for each.\n    \"\"\"\n\n    # Test Case 1 Data\n    case1 = {\n        'n': 4, 'k': 3,\n        'mu': np.array([0.08, 0.10, 0.12, 0.09]),\n        'B': np.array([\n            [1.2, 0.5, 0.3],\n            [0.8, 1.1, -0.2],\n            [1.5, -0.4, 0.7],\n            [0.6, 0.9, 0.4]\n        ]),\n        'Sigma_F': np.diag([0.04, 0.03, 0.02]),\n        'D': np.diag([0.02, 0.015, 0.018, 0.017]),\n        'E': np.array([\n            [0.001, -0.0003, 0.0002, -0.0001],\n            [-0.0003, 0.001, -0.00025, 0.00015],\n            [0.0002, -0.00025, 0.0012, -0.0002],\n            [-0.0001, 0.00015, -0.0002, 0.0008]\n        ])\n    }\n\n    # Test Case 2 Data\n    case2 = {\n        'n': 4, 'k': 3,\n        'mu': np.array([0.07, 0.075, 0.072, 0.074]),\n        'B': np.array([\n            [1.0, 0.2, 0.1],\n            [0.95, 0.25, 0.12],\n            [1.05, 0.18, 0.09],\n            [0.90, 0.30, 0.11]\n        ]),\n        'Sigma_F': np.diag([0.05, 0.025, 0.015]),\n        'D': np.diag([0.01, 0.012, 0.011, 0.013]),\n        'E': np.zeros((4, 4))  # Sigma_hist = Sigma_fac\n    }\n\n    # Test Case 3 Data\n    case3 = {\n        'n': 4, 'k': 3,\n        'mu': np.array([0.11, 0.09, 0.10, 0.115]),\n        'B': np.array([\n            [0.7, -0.2, 0.5],\n            [1.3, 0.4, -0.1],\n            [0.2, 1.1, 0.3],\n            [1.0, -0.3, 0.8]\n        ]),\n        'Sigma_F': np.diag([0.06, 0.02, 0.025]),\n        'D': np.diag([0.02, 0.018, 0.016, 0.017]),\n        'E': np.array([\n            [0.002, 0.0004, -0.0003, 0.0002],\n            [0.0004, 0.0025, 0.00035, -0.00025],\n            [-0.0003, 0.00035, 0.0022, 0.00015],\n            [0.0002, -0.00025, 0.00015, 0.0018]\n        ])\n    }\n\n    test_cases = [case1, case2, case3]\n    results = []\n\n    for case in test_cases:\n        delta = compute_delta_for_case(case)\n        results.append(delta)\n    \n    # Format the final output string as required.\n    print(f\"[{','.join(f'{d:.6f}' for d in results)}]\")\n\ndef run_optimization(Sigma, mu, r_tgt, n):\n    \"\"\"\n    Solves the quadratic programming problem for a given covariance matrix and target return.\n    \"\"\"\n    \n    # Objective function: portfolio variance\n    def portfolio_variance(w, Sigma_arg):\n        return w.T @ Sigma_arg @ w\n\n    # Initial guess: equally weighted portfolio\n    w0 = np.ones(n) / n\n\n    # Constraints: sum of weights is 1, portfolio return is r_tgt\n    constraints = [\n        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0},\n        {'type': 'eq', 'fun': lambda w: np.dot(w, mu) - r_tgt}\n    ]\n\n    # Bounds: weights are non-negative (no short selling)\n    bounds = tuple((0.0, None) for _ in range(n))\n\n    # Perform the optimization\n    result = minimize(\n        fun=portfolio_variance,\n        x0=w0,\n        args=(Sigma,),\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints\n    )\n\n    if not result.success:\n        raise ValueError(f\"Optimization failed for r_tgt={r_tgt}: {result.message}\")\n        \n    return result.fun # This is the minimized variance\n\ndef compute_delta_for_case(case_data):\n    \"\"\"\n    Computes the summary metric Delta for a single test case.\n    \"\"\"\n    n, mu, B, Sigma_F, D, E = (\n        case_data['n'], case_data['mu'], case_data['B'],\n        case_data['Sigma_F'], case_data['D'], case_data['E']\n    )\n\n    # Construct covariance matrices\n    Sigma_fac = B @ Sigma_F @ B.T + D\n    Sigma_hist = Sigma_fac + E\n\n    # For Test Case 2, Sigma_hist == Sigma_fac, so Delta is 0.\n    if np.allclose(Sigma_hist, Sigma_fac):\n        return 0.0\n\n    # Define the target return grid\n    r_min = np.min(mu)\n    r_max = np.max(mu)\n    target_returns = np.linspace(r_min, r_max, 5)\n\n    max_diff = 0.0\n    for r_tgt in target_returns:\n        # Solve for historical covariance\n        var_hist = run_optimization(Sigma_hist, mu, r_tgt, n)\n        std_dev_hist = np.sqrt(var_hist)\n\n        # Solve for factor model covariance\n        var_fac = run_optimization(Sigma_fac, mu, r_tgt, n)\n        std_dev_fac = np.sqrt(var_fac)\n\n        # Update the maximum difference\n        diff = np.abs(std_dev_hist - std_dev_fac)\n        if diff > max_diff:\n            max_diff = diff\n            \n    return max_diff\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "The previous practice highlighted how different input models can yield different portfolios, so how can we create portfolios that are \"robust\" to these estimation errors? This practice introduces the powerful framework of robust optimization, where we explicitly account for model uncertainty. You will solve a mean-variance problem that finds the best portfolio while simultaneously hedging against a whole set of possible covariance matrices, learning how to make optimization results more reliable in the face of imperfect information [@problem_id:2409743].", "id": "2409743", "problem": "You are given a robust Mean-Variance Optimization (MVO) problem in which the covariance matrix is not known exactly but is known to lie in a Frobenius-norm uncertainty ball around a nominal estimate. Consider $n=3$ risky assets with expected excess return vector $\\mu \\in \\mathbb{R}^{3}$ and nominal covariance matrix $\\Sigma_{0} \\in \\mathbb{R}^{3 \\times 3}$. The covariance matrix is uncertain and constrained to the set\n$$\n\\mathcal{U}(\\delta) \\;=\\; \\left\\{ \\Sigma \\in \\mathbb{S}_{+}^{3} \\;:\\; \\left\\| \\Sigma - \\Sigma_{0} \\right\\|_{F} \\le \\delta \\right\\},\n$$\nwhere $\\delta \\ge 0$ is a given radius, $\\mathbb{S}_{+}^{3}$ denotes the set of symmetric positive semidefinite $3 \\times 3$ matrices, and $\\|\\cdot\\|_{F}$ denotes the Frobenius norm.\n\nA portfolio is a weight vector $x \\in \\mathbb{R}^{3}$ satisfying the full-investment constraint $\\mathbf{1}^{\\top} x = 1$, where $\\mathbf{1}$ is the vector of ones. Short-selling is allowed. For a given risk-aversion parameter $\\gamma > 0$, consider the robust MVO problem\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\;\\; \\frac{\\gamma}{2} \\;\\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} \\; x^{\\top} \\Sigma x \\;-\\; \\mu^{\\top} x\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\n\nUse the following data, which are fixed across all test cases:\n- Asset count $n = 3$.\n- Expected excess returns (in decimal units): $\\mu = \\begin{bmatrix} 0.12 \\\\ 0.10 \\\\ 0.07 \\end{bmatrix}$.\n- Nominal covariance matrix:\n$$\n\\Sigma_{0} \\;=\\;\n\\begin{bmatrix}\n0.0100 & 0.0018 & 0.0011 \\\\\n0.0018 & 0.0064 & 0.0013 \\\\\n0.0011 & 0.0013 & 0.0025\n\\end{bmatrix}.\n$$\n\nThe program must, for each specified test case, compute the unique optimizer $x^{\\star}$ of the robust MVO problem above and report it as a list of three real numbers rounded to six decimal places.\n\nTest suite:\n1. Case A (nominal boundary): $\\gamma = 5.0$, $\\delta = 0.0$.\n2. Case B (moderate robustness): $\\gamma = 5.0$, $\\delta = 0.020$.\n3. Case C (strong robustness): $\\gamma = 5.0$, $\\delta = 0.050$.\n4. Case D (high risk aversion with robustness): $\\gamma = 20.0$, $\\delta = 0.020$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a bracketed, comma-separated list of the three portfolio weights. All numbers must be rounded to six decimal places. For example, the required format is\n$[\\,[w_{1,1},w_{1,2},w_{1,3}],\\,[w_{2,1},w_{2,2},w_{2,3}],\\,[w_{3,1},w_{3,2},w_{3,3}],\\,[w_{4,1},w_{4,2},w_{4,3}]\\,]$,\nwhere $w_{k,i}$ denotes the $i$-th weight in the $k$-th test case. No units are involved, and numbers must be expressed as real decimals, not percentages.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extracted Givens**\n- Number of assets: $n = 3$.\n- Expected excess return vector: $\\mu = \\begin{bmatrix} 0.12 \\\\ 0.10 \\\\ 0.07 \\end{bmatrix}$.\n- Nominal covariance matrix:\n$$\n\\Sigma_{0} \\;=\\;\n\\begin{bmatrix}\n0.0100 & 0.0018 & 0.0011 \\\\\n0.0018 & 0.0064 & 0.0013 \\\\\n0.0011 & 0.0013 & 0.0025\n\\end{bmatrix}.\n$$\n- Covariance uncertainty set: $\\mathcal{U}(\\delta) \\;=\\; \\left\\{ \\Sigma \\in \\mathbb{S}_{+}^{3} \\;:\\; \\left\\| \\Sigma - \\Sigma_{0} \\right\\|_{F} \\le \\delta \\right\\}$, where $\\mathbb{S}_{+}^{3}$ is the set of symmetric positive semidefinite $3 \\times 3$ matrices and $\\| \\cdot \\|_{F}$ is the Frobenius norm.\n- Portfolio constraint: $\\mathbf{1}^{\\top} x = 1$.\n- Robust Mean-Variance Optimization (MVO) problem:\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\;\\; \\frac{\\gamma}{2} \\;\\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} \\; x^{\\top} \\Sigma x \\;-\\; \\mu^{\\top} x\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\n- Test cases are defined by pairs of parameters $(\\gamma, \\delta)$:\n  1. Case A: $\\gamma = 5.0$, $\\delta = 0.0$.\n  2. Case B: $\\gamma = 5.0$, $\\delta = 0.020$.\n  3. Case C: $\\gamma = 5.0$, $\\delta = 0.050$.\n  4. Case D: $\\gamma = 20.0$, $\\delta = 0.020$.\n\n**Step 2: Validation of Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective. It is a standard formulation in robust portfolio optimization, a subfield of computational finance. All parameters are explicitly defined, and the data are consistent. The nominal covariance matrix $\\Sigma_0$ is symmetric and positive definite (its eigenvalues are approximately $0.0107$, $0.0059$, and $0.0023$), thus it belongs to $\\mathbb{S}_{+}^{3}$. The problem formulation is mathematically precise and allows for a unique, derivable solution. No flaws are identified.\n\n**Step 3: Verdict and Action**\nThe problem is deemed valid. A solution will be derived.\n\n**Derivation of the Solution**\nThe specified robust MVO problem is a minimax problem:\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\left( \\frac{\\gamma}{2} \\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} x^{\\top} \\Sigma x -\\mu^{\\top} x \\right)\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\nTo solve this, we first analyze the inner maximization problem, which seeks the worst-case portfolio variance for a fixed portfolio $x$:\n$$\n\\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} x^{\\top} \\Sigma x = \\sup_{\\Sigma} \\left\\{ x^{\\top} \\Sigma x \\mid \\Sigma \\in \\mathbb{S}_{+}^{3}, \\|\\Sigma - \\Sigma_{0}\\|_{F} \\le \\delta \\right\\}.\n$$\nWe can express the quadratic form $x^{\\top} \\Sigma x$ using the trace operator and the matrix inner product $\\langle A, B \\rangle_{F} = \\text{Tr}(A^{\\top}B)$. Since $x^{\\top}\\Sigma x$ is a scalar, $x^{\\top}\\Sigma x = \\text{Tr}(x^{\\top}\\Sigma x) = \\text{Tr}(\\Sigma x x^{\\top})$. As $\\Sigma$ and $xx^\\top$ are symmetric, this is equivalent to $\\langle \\Sigma, x x^{\\top} \\rangle_{F}$.\n\nLet $\\Delta = \\Sigma - \\Sigma_0$. The maximization problem over $\\Sigma$ can be rewritten as a maximization over the symmetric perturbation matrix $\\Delta$:\n$$\n\\sup_{\\Delta} \\left\\{ x^{\\top}(\\Sigma_0 + \\Delta)x \\mid \\|\\Delta\\|_{F} \\le \\delta, \\Sigma_0+\\Delta \\in \\mathbb{S}_{+}^{3}, \\Delta \\in \\mathbb{S}^{3} \\right\\},\n$$\nwhere $\\mathbb{S}^{3}$ is the set of $3 \\times 3$ symmetric matrices.\nThe objective function is $x^{\\top}\\Sigma_0 x + x^{\\top}\\Delta x = x^{\\top}\\Sigma_0 x + \\langle \\Delta, x x^{\\top} \\rangle_{F}$. The term $x^{\\top}\\Sigma_0 x$ is constant with respect to $\\Delta$, so we must solve:\n$$\nx^{\\top}\\Sigma_0 x + \\sup_{\\Delta} \\left\\{ \\langle \\Delta, x x^{\\top} \\rangle_{F} \\mid \\|\\Delta\\|_{F} \\le \\delta, \\Sigma_0+\\Delta \\in \\mathbb{S}_{+}^{3}, \\Delta \\in \\mathbb{S}^{3} \\right\\}.\n$$\nBy the Cauchy-Schwarz inequality for the Frobenius inner product, the supremum of $\\langle \\Delta, x x^{\\top} \\rangle_{F}$ subject to $\\|\\Delta\\|_{F} \\le \\delta$ is attained when $\\Delta$ is aligned with the matrix $xx^{\\top}$. The optimal perturbation is $\\Delta^{\\star} = \\delta \\frac{x x^{\\top}}{\\|x x^{\\top}\\|_{F}}$.\nThe Frobenius norm of the rank-1 matrix $x x^{\\top}$ is:\n$$\n\\|x x^{\\top}\\|_{F} = \\sqrt{\\text{Tr}\\left((x x^{\\top})^{\\top}(x x^{\\top})\\right)} = \\sqrt{\\text{Tr}\\left(x x^{\\top} x x^{\\top}\\right)} = \\sqrt{\\text{Tr}\\left(x(x^{\\top}x)x^{\\top}\\right)} = \\sqrt{(x^{\\top}x)\\text{Tr}(x x^{\\top})} = \\sqrt{\\|x\\|_{2}^2 \\|x\\|_{2}^2} = \\|x\\|_{2}^2,\n$$\nwhere $\\|x\\|_2$ is the Euclidean norm of $x$.\nThe optimal perturbation is therefore $\\Delta^{\\star} = \\frac{\\delta}{\\|x\\|_{2}^2} x x^{\\top}$. The corresponding worst-case covariance matrix is $\\Sigma^{\\star} = \\Sigma_0 + \\frac{\\delta}{\\|x\\|_{2}^2} x x^{\\top}$. Since $\\Sigma_0$ is positive semidefinite and $xx^{\\top}$ is positive semidefinite, their weighted sum (with non-negative weights) ensures $\\Sigma^\\star \\in \\mathbb{S}_{+}^{3}$. Thus, the positive semidefiniteness constraint on $\\Sigma$ is automatically satisfied by the solution of the relaxed problem and can be ignored.\n\nThe maximum value of the inner product term is $\\langle \\Delta^{\\star}, x x^{\\top} \\rangle_{F} = \\delta \\|x x^{\\top}\\|_{F} = \\delta \\|x\\|_{2}^2$.\nThe worst-case variance is:\n$$\n\\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} x^{\\top} \\Sigma x = x^{\\top}\\Sigma_0 x + \\delta \\|x\\|_{2}^2.\n$$\nSubstituting this back into the MVO problem, we obtain an equivalent standard quadratic program:\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\;\\; \\frac{\\gamma}{2} \\left( x^{\\top}\\Sigma_0 x + \\delta \\|x\\|_{2}^2 \\right) - \\mu^{\\top} x\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\nRecognizing that $\\|x\\|_{2}^2 = x^{\\top}Ix$, where $I$ is the identity matrix, the objective function can be rewritten as:\n$$\nf(x) = \\frac{\\gamma}{2} x^{\\top}(\\Sigma_0 + \\delta I)x - \\mu^{\\top} x.\n$$\nLet us define the robust covariance matrix $\\tilde{\\Sigma} = \\Sigma_0 + \\delta I$. The problem is now a standard MVO problem:\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\;\\; \\frac{\\gamma}{2} x^{\\top}\\tilde{\\Sigma}x - \\mu^{\\top} x\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\nThis is a convex optimization problem with a linear equality constraint, which we solve using the method of Lagrange multipliers. The Lagrangian is:\n$$\n\\mathcal{L}(x, \\lambda) = \\frac{\\gamma}{2} x^{\\top}\\tilde{\\Sigma}x - \\mu^{\\top} x + \\lambda(1 - \\mathbf{1}^{\\top} x).\n$$\nThe first-order necessary conditions for optimality are obtained by setting the gradients to zero:\n$$\n\\nabla_x \\mathcal{L} = \\gamma \\tilde{\\Sigma}x - \\mu - \\lambda\\mathbf{1} = 0\n$$\n$$\n\\nabla_\\lambda \\mathcal{L} = 1 - \\mathbf{1}^{\\top} x = 0\n$$\nFrom the first equation, we solve for $x$. Since $\\Sigma_0$ is positive definite and $\\delta \\ge 0$, $\\tilde{\\Sigma}$ is also positive definite and therefore invertible.\n$$\n\\gamma \\tilde{\\Sigma}x = \\mu + \\lambda\\mathbf{1} \\implies x = \\frac{1}{\\gamma} \\tilde{\\Sigma}^{-1} (\\mu + \\lambda\\mathbf{1}).\n$$\nWe substitute this expression for $x$ into the budget constraint $\\mathbf{1}^{\\top}x = 1$:\n$$\n\\mathbf{1}^{\\top} \\left( \\frac{1}{\\gamma} \\tilde{\\Sigma}^{-1} (\\mu + \\lambda\\mathbf{1}) \\right) = 1\n$$\n$$\n\\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mu + \\lambda(\\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1}) = \\gamma.\n$$\nTo find $\\lambda$, we define the scalars:\n$$\nA = \\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1}, \\quad B = \\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mu.\n$$\nThe equation for $\\lambda$ becomes $B + \\lambda A = \\gamma$, which gives:\n$$\n\\lambda = \\frac{\\gamma - B}{A}.\n$$\nThe unique optimal portfolio $x^{\\star}$ is found by first computing $\\lambda$ and then substituting it back into the expression for $x$.\n\n**Algorithm**\nFor each test case with parameters $(\\gamma, \\delta)$:\n1. Construct the robust covariance matrix $\\tilde{\\Sigma} = \\Sigma_0 + \\delta I$, where $I$ is the $3 \\times 3$ identity matrix.\n2. Compute the inverse $\\tilde{\\Sigma}^{-1}$.\n3. Calculate the scalars $A = \\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1}$ and $B = \\mu^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1}$. Note that since $\\tilde{\\Sigma}^{-1}$ is symmetric, $\\mu^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1} = \\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mu$.\n4. Compute the Lagrange multiplier $\\lambda = \\frac{\\gamma - B}{A}$.\n5. Calculate the optimal weight vector $x^{\\star} = \\frac{1}{\\gamma} \\tilde{\\Sigma}^{-1}(\\mu + \\lambda\\mathbf{1})$.\n6. Report the components of $x^{\\star}$ rounded to six decimal places.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the robust mean-variance optimization problem for a given set of test cases.\n    \"\"\"\n\n    # --- Fixed Parameters from Problem Statement ---\n    # Number of assets\n    n = 3\n    # Expected excess returns vector (mu)\n    mu = np.array([[0.12], [0.10], [0.07]])\n    # Nominal covariance matrix (Sigma_0)\n    sigma_0 = np.array([\n        [0.0100, 0.0018, 0.0011],\n        [0.0018, 0.0064, 0.0013],\n        [0.0011, 0.0013, 0.0025]\n    ])\n    # Vector of ones for the budget constraint\n    ones = np.ones((n, 1))\n    # Identity matrix\n    identity = np.identity(n)\n\n    # --- Test Suite ---\n    test_cases = [\n        # (gamma, delta)\n        (5.0, 0.0),       # Case A\n        (5.0, 0.020),     # Case B\n        (5.0, 0.050),     # Case C\n        (20.0, 0.020)     # Case D\n    ]\n\n    results_as_strings = []\n\n    for gamma, delta in test_cases:\n        # Step 1: Construct the robust covariance matrix\n        sigma_tilde = sigma_0 + delta * identity\n\n        # Step 2: Compute its inverse\n        sigma_tilde_inv = np.linalg.inv(sigma_tilde)\n\n        # Step 3: Calculate scalars A and B for solving for lambda\n        # A = 1^T * inv(Sigma_tilde) * 1\n        A_matrix = ones.T @ sigma_tilde_inv @ ones\n        A = A_matrix[0, 0]\n        \n        # B = 1^T * inv(Sigma_tilde) * mu\n        B_matrix = ones.T @ sigma_tilde_inv @ mu\n        B = B_matrix[0, 0]\n\n        # Step 4: Compute the Lagrange multiplier lambda\n        lambda_val = (gamma - B) / A\n\n        # Step 5: Calculate the optimal portfolio weights x_star\n        # x_star = (1/gamma) * inv(Sigma_tilde) * (mu + lambda * 1)\n        x_star_vec = (1 / gamma) * sigma_tilde_inv @ (mu + lambda_val * ones)\n\n        # Format the result string for the current case\n        # Flatten the column vector to a 1D array for easier formatting\n        x_star_flat = x_star_vec.flatten()\n        # Create a string representation like \"[w1,w2,w3]\" with 6 decimal places\n        case_result_str = (\n            f\"[{x_star_flat[0]:.6f},\"\n            f\"{x_star_flat[1]:.6f},\"\n            f\"{x_star_flat[2]:.6f}]\"\n        )\n        results_as_strings.append(case_result_str)\n\n    # Final print statement in the exact required format: [[w1,w2,w3],[...],...]\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"}]}