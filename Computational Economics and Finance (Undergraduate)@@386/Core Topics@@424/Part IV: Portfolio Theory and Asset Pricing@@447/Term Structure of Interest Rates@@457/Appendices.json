{"hands_on_practices": [{"introduction": "While traditional duration provides a useful first-order approximation of interest rate risk, its assumption of parallel yield curve shifts is a significant limitation. This exercise ([@problem_id:2436810]) introduces Key Rate Durations (KRDs), a more sophisticated tool that measures a portfolio's sensitivity to shifts in specific parts of the term structure. By implementing this from scratch, you will gain hands-on experience in modeling a yield curve and performing a granular risk analysis essential for modern fixed-income management.", "id": "2436810", "problem": "Write a complete, runnable program that computes Key Rate Durations (KRDs) for a fixed-income cash flow portfolio under a given term structure and simulates the impact of a specified non-parallel shift in the yield curve. The program must adhere to the following definitions and requirements.\n\nDefinitions and assumptions:\n- The portfolio is defined by a finite set of dated cash flows $\\{(t_i, C_i)\\}_{i=1}^N$, where $t_i$ is time in years from the valuation date and $C_i$ is the cash flow amount in the same monetary units as the final output.\n- The term structure is specified by a set of key maturities $\\{T_j\\}_{j=1}^M$ (in years) and corresponding baseline continuously compounded zero rates $\\{z_j\\}_{j=1}^M$ (in decimal form).\n- For any maturity $t \\ge 0$, the continuously compounded zero rate $z(t)$ is obtained by linear interpolation on the zero rates as a function of maturity using the key points $\\{(T_j, z_j)\\}_{j=1}^M$, with flat extrapolation outside the range $[T_1, T_M]$. Formally, $z(t)$ is the value of the unique piecewise-linear function on $[T_1, T_M]$ that satisfies $z(T_j) = z_j$ for all $j$, with $z(t) = z(T_1)$ for $t \\le T_1$ and $z(t) = z(T_M)$ for $t \\ge T_M$.\n- The discount factor for maturity $t$ is $D(t) = \\exp(-z(t)\\, t)$, and the present value is $P = \\sum_{i=1}^N C_i \\, D(t_i)$.\n- The Key Rate Duration (KRD) with respect to the $k$-th key maturity $T_k$ is the dimensionless sensitivity\n$$\\mathrm{KRD}_k \\equiv -\\frac{1}{P}\\,\\frac{\\partial P}{\\partial z_k},$$\nto be computed numerically by a symmetric finite difference of magnitude $\\delta$ applied only to the $k$-th key rate while all other key rates are held fixed. Specifically, let $P^{(+)}_k$ be the present value computed with the key rate vector $\\{z_j\\}$ replaced by $\\{z_j + \\delta \\cdot \\mathbf{1}_{\\{j=k\\}}\\}$, and $P^{(-)}_k$ be the present value with $\\{z_j - \\delta \\cdot \\mathbf{1}_{\\{j=k\\}}\\}$. Then\n$$\\mathrm{KRD}_k = -\\frac{P^{(+)}_k - P^{(-)}_k}{2\\,P\\,\\delta}.$$\n- A non-parallel scenario shift is a vector $\\{s_j\\}_{j=1}^M$ (in decimal form) applied to the key rates, producing shifted key rates $\\tilde z_j = z_j + s_j$. The shifted curve $\\tilde z(t)$ is obtained by the same interpolation and extrapolation rules as $z(t)$. The scenario present value is $\\tilde P = \\sum_{i=1}^N C_i \\exp(-\\tilde z(t_i)\\, t_i)$. The required scenario impact is the monetary change $\\Delta P = \\tilde P - P$.\n\nAll rates $z_j$, shifts $s_j$, and bump size $\\delta$ must be specified in decimals (for example, $0.01$ denotes one percent). All times $t_i$ and $T_j$ are in years. The final monetary impact $\\Delta P$ must be expressed in the same units as the cash flows $C_i$. No user input is required; the program must use the test suite provided below.\n\nTest suite:\n- Case A (general case):\n  - Key maturities: $[0.5, 1.0, 2.0, 5.0, 10.0]$\n  - Baseline zero rates (continuously compounded): $[0.02, 0.022, 0.025, 0.03, 0.035]$\n  - Portfolio cash flows (time, amount): $\\{(1.0, 7.0), (2.0, 7.0), (3.0, 107.0), (4.0, 3.0), (5.0, 3.0), (6.0, 3.0), (7.0, 103.0)\\}$\n  - Bump magnitude for KRD: $\\delta = 0.0001$\n  - Non-parallel scenario shifts: $[-0.0005, -0.0002, 0.0001, 0.0003, 0.0006]$\n- Case B (boundary case: zero-coupon concentration):\n  - Key maturities: $[1.0, 2.0, 3.0, 5.0]$\n  - Baseline zero rates (continuously compounded): $[0.015, 0.02, 0.022, 0.025]$\n  - Portfolio cash flows: $\\{(2.0, 100.0)\\}$\n  - Bump magnitude for KRD: $\\delta = 0.0001$\n  - Non-parallel scenario shifts: $[0.0, 0.001, 0.0, 0.0]$\n- Case C (edge case: extrapolation before first key and beyond last key):\n  - Key maturities: $[0.5, 1.0, 3.0, 10.0]$\n  - Baseline zero rates (continuously compounded): $[0.01, 0.012, 0.018, 0.028]$\n  - Portfolio cash flows: $\\{(0.25, 1.0), (0.75, 1.0), (1.25, 1.0), (3.5, 2.0), (10.0, 2.0), (12.0, 105.0)\\}$\n  - Bump magnitude for KRD: $\\delta = 0.0001$\n  - Non-parallel scenario shifts: $[-0.0001, 0.0002, 0.0005, -0.0002]$\n\nRequired outputs:\n- For each case, compute:\n  - The vector of Key Rate Durations $[\\mathrm{KRD}_1, \\ldots, \\mathrm{KRD}_M]$ in the order of the provided key maturities.\n  - The scenario impact $\\Delta P$ as a real number in the same monetary units as the cash flows.\n- The program must produce a single line of output containing a list with one entry per case. Each case entry must be a list formed by concatenating the KRD vector and the single $\\Delta P$ value. For example, the output format must be exactly like\n  - $[[\\mathrm{KRD}^{(A)}_1,\\ldots,\\mathrm{KRD}^{(A)}_M,\\Delta P^{(A)}],[\\mathrm{KRD}^{(B)}_1,\\ldots,\\mathrm{KRD}^{(B)}_M,\\Delta P^{(B)}],[\\mathrm{KRD}^{(C)}_1,\\ldots,\\mathrm{KRD}^{(C)}_M,\\Delta P^{(C)}]]$\nprinted on a single line, using decimal representations.", "solution": "The problem presented is subjected to a rigorous validation protocol.\n\n### Step 1: Extract Givens\n\nThe following information has been extracted verbatim from the problem statement:\n- **Portfolio Definition**: A set of dated cash flows $\\{(t_i, C_i)\\}_{i=1}^N$, where $t_i$ is time in years and $C_i$ is the cash flow amount.\n- **Term Structure**: A set of key maturities $\\{T_j\\}_{j=1}^M$ (in years) and corresponding baseline continuously compounded zero rates $\\{z_j\\}_{j=1}^M$ (in decimal form).\n- **Yield Curve Construction**: For any maturity $t \\ge 0$, the continuously compounded zero rate $z(t)$ is obtained by linear interpolation on the zero rates $\\{z_j\\}$ as a function of maturity $\\{T_j\\}$, with flat extrapolation such that $z(t) = z(T_1)$ for $t \\le T_1$ and $z(t) = z(T_M)$ for $t \\ge T_M$.\n- **Discount Factor**: $D(t) = \\exp(-z(t)\\, t)$.\n- **Present Value (PV)**: $P = \\sum_{i=1}^N C_i \\, D(t_i)$.\n- **Key Rate Duration (KRD)**: Defined as $\\mathrm{KRD}_k \\equiv -\\frac{1}{P}\\,\\frac{\\partial P}{\\partial z_k}$.\n- **KRD Numerical Approximation**: $\\mathrm{KRD}_k = -\\frac{P^{(+)}_k - P^{(-)}_k}{2\\,P\\,\\delta}$, where $P^{(+)}_k$ and $P^{(-)}_k$ are PVs computed by shifting the $k$-th key rate $z_k$ by $+\\delta$ and $-\\delta$, respectively.\n- **Non-Parallel Scenario Shift**: A vector of shifts $\\{s_j\\}_{j=1}^M$ applied to the key rates, resulting in shifted rates $\\tilde z_j = z_j + s_j$. The shifted curve $\\tilde z(t)$ is constructed using the same rules.\n- **Scenario Impact**: The monetary change in present value, $\\Delta P = \\tilde P - P$, where $\\tilde P$ is the PV under the shifted curve.\n- **Test Cases**:\n    - **Case A**:\n        - Key maturities: $[0.5, 1.0, 2.0, 5.0, 10.0]$\n        - Baseline zero rates: $[0.02, 0.022, 0.025, 0.03, 0.035]$\n        - Portfolio cash flows: $\\{(1.0, 7.0), (2.0, 7.0), (3.0, 107.0), (4.0, 3.0), (5.0, 3.0), (6.0, 3.0), (7.0, 103.0)\\}$\n        - Bump magnitude $\\delta$: $0.0001$\n        - Scenario shifts: $[-0.0005, -0.0002, 0.0001, 0.0003, 0.0006]$\n    - **Case B**:\n        - Key maturities: $[1.0, 2.0, 3.0, 5.0]$\n        - Baseline zero rates: $[0.015, 0.02, 0.022, 0.025]$\n        - Portfolio cash flows: $\\{(2.0, 100.0)\\}$\n        - Bump magnitude $\\delta$: $0.0001$\n        - Scenario shifts: $[0.0, 0.001, 0.0, 0.0]$\n    - **Case C**:\n        - Key maturities: $[0.5, 1.0, 3.0, 10.0]$\n        - Baseline zero rates: $[0.01, 0.012, 0.018, 0.028]$\n        - Portfolio cash flows: $\\{(0.25, 1.0), (0.75, 1.0), (1.25, 1.0), (3.5, 2.0), (10.0, 2.0), (12.0, 105.0)\\}$\n        - Bump magnitude $\\delta$: $0.0001$\n        - Scenario shifts: $[-0.0001, 0.0002, 0.0005, -0.0002]$\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is examined against the criteria for validity.\n- **Scientific Grounding**: The problem employs standard, well-established concepts from computational finance and fixed-income analysis, including term structure of interest rates, present value calculation, discount factors, and key rate duration. The mathematical formalisms are correct.\n- **Well-Posedness**: All necessary parameters, functions, and numerical methods are explicitly defined. The yield curve construction via interpolation and extrapolation is unambiguous. The finite difference scheme for Key Rate Duration is precisely specified. The input data for each test case is complete. A unique solution is computable.\n- **Objectivity**: The language is formal and quantitative, free of any subjective or ambiguous terminology.\n\nThe problem does not exhibit any of the defined flaws:\n1.  It is not scientifically unsound; it adheres to established financial mathematics.\n2.  It is not non-formalizable; it is a standard quantitative task.\n3.  It is not incomplete or contradictory; all required data is provided.\n4.  It is not unrealistic; the values are plausible for market data.\n5.  It is not ill-posed; the problem structure guarantees a unique, stable solution.\n6.  It is not outside scientific verifiability; the results can be independently reproduced.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be developed.\n\n### Solution\n\nThe solution requires implementation of several financial-mathematical functions as specified. The logical structure of the problem solving proceeds as follows.\n\n**1. Yield Curve Construction**\n\nThe foundation of the calculation is the function $z(t)$ which provides the continuously compounded zero rate for any maturity $t$. This function is constructed from the given key maturities $\\{T_j\\}_{j=1}^M$ and corresponding key rates $\\{z_j\\}_{j=1}^M$. The problem specifies a piecewise-linear function on the interval $[T_1, T_M]$ with flat extrapolation outside this range. This means:\n$$\nz(t) = \\begin{cases} \nz_1 & \\text{if } t \\le T_1 \\\\\nz_j + (t - T_j) \\frac{z_{j+1} - z_j}{T_{j+1} - T_j} & \\text{if } T_j < t \\le T_{j+1} \\text{ for } 1 \\le j < M \\\\\nz_M & \\text{if } t > T_M \n\\end{cases}\n$$\nThis construction is efficiently implemented using interpolation libraries, which handle the piecewise definition and boundary conditions correctly. We will define a function that takes a set of cash-flow times, the key maturities, and key rates, and returns the corresponding interpolated zero rates for each time.\n\n**2. Present Value Calculation**\n\nThe present value ($PV$) of the portfolio is the sum of the discounted values of its individual cash flows. For a set of cash flows $\\{(t_i, C_i)\\}_{i=1}^N$, the present value $P$ is given by:\n$$\nP = \\sum_{i=1}^{N} C_i \\cdot D(t_i)\n$$\nwhere $D(t_i)$ is the discount factor for maturity $t_i$. The discount factor is determined by the zero rate $z(t_i)$ from the constructed yield curve:\n$$\nD(t_i) = \\exp(-z(t_i) \\cdot t_i)\n$$\nWe will implement a function to compute this sum. This function will be the core component for all subsequent calculations.\n\n**3. Key Rate Duration (KRD) Calculation**\n\nKey Rate Duration, $\\mathrm{KRD}_k$, measures the sensitivity of the portfolio's present value to a small change in the $k$-th key rate, $z_k$. The problem specifies a numerical approximation using a symmetric finite difference method. The formula is:\n$$\n\\mathrm{KRD}_k = -\\frac{P^{(+)}_k - P^{(-)}_k}{2 \\cdot P \\cdot \\delta}\n$$\nHere, $P$ is the baseline present value. $P^{(+)}_k$ is the PV re-calculated after bumping the $k$-th key rate up by a small amount $\\delta$, i.e., using the rate vector $\\{z_1, \\dots, z_k + \\delta, \\dots, z_M\\}$. Similarly, $P^{(-)}_k$ is the PV re-calculated after bumping the $k$-th key rate down by $\\delta$, i.e., using $\\{z_1, \\dots, z_k - \\delta, \\dots, z_M\\}$. This procedure is repeated for each key rate $z_k$ where $k$ ranges from $1$ to $M$.\n\nThe algorithm is as follows:\n- Calculate the baseline portfolio present value, $P$.\n- For each key rate index $k \\in \\{1, \\dots, M\\}$:\n    - Construct the \"up-shifted\" rate vector and calculate $P^{(+)}_k$.\n    - Construct the \"down-shifted\" rate vector and calculate $P^{(-)}_k$.\n    - Compute $\\mathrm{KRD}_k$ using the formula.\n- Collect all $\\mathrm{KRD}_k$ values into a result vector.\n\n**4. Scenario Impact Analysis**\n\nThe final task is to compute the change in portfolio value, $\\Delta P$, under a specified non-parallel shift of the yield curve. The shifts $\\{s_j\\}_{j=1}^M$ are applied to the baseline key rates to obtain a new set of scenario rates:\n$$\n\\tilde{z}_j = z_j + s_j \\quad \\text{for } j = 1, \\dots, M\n$$\nUsing this new set of key rates $\\{\\tilde{z}_j\\}$, a new yield curve $\\tilde{z}(t)$ is constructed, and the portfolio is re-valued to find the scenario present value, $\\tilde{P}$.\n$$\n\\tilde{P} = \\sum_{i=1}^{N} C_i \\cdot \\exp(-\\tilde{z}(t_i) \\cdot t_i)\n$$\nThe monetary impact is simply the difference between the new and original present values:\n$$\n\\Delta P = \\tilde{P} - P\n$$\nThe calculation proceeds by first computing the baseline value $P$, then computing the scenario value $\\tilde{P}$, and finally taking their difference.\n\nA single program will be constructed to execute these steps for each test case provided in the problem statement and format the results according to the specified output structure.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational finance problem for calculating Key Rate Durations\n    and scenario impacts for a fixed-income portfolio.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Case A (general case)\",\n            \"key_maturities\": np.array([0.5, 1.0, 2.0, 5.0, 10.0]),\n            \"key_rates\": np.array([0.02, 0.022, 0.025, 0.03, 0.035]),\n            \"cash_flows\": np.array([(1.0, 7.0), (2.0, 7.0), (3.0, 107.0), (4.0, 3.0), (5.0, 3.0), (6.0, 3.0), (7.0, 103.0)]),\n            \"delta\": 0.0001,\n            \"scenario_shifts\": np.array([-0.0005, -0.0002, 0.0001, 0.0003, 0.0006])\n        },\n        {\n            \"name\": \"Case B (boundary case: zero-coupon concentration)\",\n            \"key_maturities\": np.array([1.0, 2.0, 3.0, 5.0]),\n            \"key_rates\": np.array([0.015, 0.02, 0.022, 0.025]),\n            \"cash_flows\": np.array([(2.0, 100.0)]),\n            \"delta\": 0.0001,\n            \"scenario_shifts\": np.array([0.0, 0.001, 0.0, 0.0])\n        },\n        {\n            \"name\": \"Case C (edge case: extrapolation before first key and beyond last key)\",\n            \"key_maturities\": np.array([0.5, 1.0, 3.0, 10.0]),\n            \"key_rates\": np.array([0.01, 0.012, 0.018, 0.028]),\n            \"cash_flows\": np.array([(0.25, 1.0), (0.75, 1.0), (1.25, 1.0), (3.5, 2.0), (10.0, 2.0), (12.0, 105.0)]),\n            \"delta\": 0.0001,\n            \"scenario_shifts\": np.array([-0.0001, 0.0002, 0.0005, -0.0002])\n        }\n    ]\n\n    def get_zero_rates(times, key_maturities, key_rates):\n        \"\"\"\n        Computes continuously compounded zero rates for given times using linear\n        interpolation and flat extrapolation on key rates.\n        \n        Args:\n            times (np.ndarray): Array of times t for which to find zero rates.\n            key_maturities (np.ndarray): The key maturities T_j of the term structure.\n            key_rates (np.ndarray): The key zero rates z_j of the term structure.\n        \n        Returns:\n            np.ndarray: Array of zero rates z(t) for each time in `times`.\n        \"\"\"\n        # numpy.interp handles linear interpolation and flat extrapolation as required.\n        # For t <= T_1, it uses z_1. For t >= T_M, it uses z_M.\n        return np.interp(times, key_maturities, key_rates)\n\n    def calculate_pv(cf_times, cf_amounts, key_maturities, key_rates):\n        \"\"\"\n        Calculates the present value of a portfolio of cash flows.\n\n        Args:\n            cf_times (np.ndarray): Times of cash flows.\n            cf_amounts (np.ndarray): Amounts of cash flows.\n            key_maturities (np.ndarray): The key maturities of the term structure.\n            key_rates (np.ndarray): The key zero rates of the term structure.\n\n        Returns:\n            float: The total present value of the portfolio.\n        \"\"\"\n        zero_rates = get_zero_rates(cf_times, key_maturities, key_rates)\n        discount_factors = np.exp(-zero_rates * cf_times)\n        present_values = cf_amounts * discount_factors\n        return np.sum(present_values)\n\n    all_results = []\n    for case in test_cases:\n        # Unpack case data\n        key_maturities = case[\"key_maturities\"]\n        base_rates = case[\"key_rates\"]\n        cash_flows = case[\"cash_flows\"]\n        cf_times = cash_flows[:, 0]\n        cf_amounts = cash_flows[:, 1]\n        delta = case[\"delta\"]\n        scenario_shifts = case[\"scenario_shifts\"]\n\n        # 1. Calculate base Present Value (P)\n        base_pv = calculate_pv(cf_times, cf_amounts, key_maturities, base_rates)\n\n        # 2. Calculate Key Rate Durations (KRDs)\n        krds = []\n        for i in range(len(key_maturities)):\n            # Positive bump\n            rates_plus = base_rates.copy()\n            rates_plus[i] += delta\n            pv_plus = calculate_pv(cf_times, cf_amounts, key_maturities, rates_plus)\n            \n            # Negative bump\n            rates_minus = base_rates.copy()\n            rates_minus[i] -= delta\n            pv_minus = calculate_pv(cf_times, cf_amounts, key_maturities, rates_minus)\n            \n            # KRD calculation\n            krd = - (pv_plus - pv_minus) / (2 * base_pv * delta)\n            krds.append(krd)\n\n        # 3. Calculate Scenario Impact (Delta P)\n        shifted_rates = base_rates + scenario_shifts\n        scenario_pv = calculate_pv(cf_times, cf_amounts, key_maturities, shifted_rates)\n        delta_p = scenario_pv - base_pv\n        \n        # 4. Consolidate results for the case\n        case_results = krds + [delta_p]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The str() function on a list provides the required '[...]' format.\n    # Joining these with commas and wrapping in outer brackets gives the final format.\n    print(f\"[{','.join(str(r) for r in all_results)}]\")\n\nsolve()\n```"}, {"introduction": "Beyond simply measuring risk, duration and convexity are powerful tools for active portfolio management, with immunization being a classic strategy to shield a portfolio's value from interest rate changes. This practice ([@problem_id:2436877]) challenges you to apply these concepts by constructing a portfolio that is both duration-neutral and convexity-maximized. You will achieve this by formulating the problem as a linear program and leveraging computational solvers, bridging the gap between financial theory and applied optimization.", "id": "2436877", "problem": "Design and implement a complete program that, given a discrete term structure of interest rates and a finite set of zero-coupon bonds, constructs a static portfolio of these bonds that has zero dollar duration with respect to a parallel shift in the continuously compounded yield curve, and that maximizes dollar convexity per unit price under box constraints on portfolio weights.\n\nStart from the following foundational definitions in fixed-income analytics:\n- The price $P(T)$ of a zero-coupon bond with maturity $T$ years under a continuously compounded spot rate $r(T)$ is $P(T) = \\exp(-r(T)\\,T)$.\n- Under a parallel shift $y$ (in decimal units) applied to all continuously compounded rates, the perturbed price is $P_y(T) = \\exp(-(r(T)+y)\\,T)$. For a portfolio with weights $w_i$ (one weight per bond), maturities $T_i$, and spot rates $r(T_i)$, the portfolio price under shift $y$ is $P_{\\text{port}}(y) = \\sum_i w_i\\, \\exp(-(r(T_i)+y)\\,T_i)$.\n- Define portfolio dollar duration as $-\\left.\\dfrac{dP_{\\text{port}}}{dy}\\right|_{y=0}$ and portfolio dollar convexity as $\\left.\\dfrac{d^2 P_{\\text{port}}}{dy^2}\\right|_{y=0}$.\n\nYour algorithm must:\n- Use the above definitions to derive expressions for the dollar duration and dollar convexity contributions of each zero-coupon bond in terms of its maturity $T_i$ and undiscounted price $P_i = \\exp(-r(T_i)\\,T_i)$.\n- Impose the following constraints on the portfolio weights $w_i$:\n  1) A unit-price budget constraint: $\\sum_i w_i\\,P_i = 1$ (i.e., the portfolio has unit price in currency units).\n  2) Zero dollar duration: $-\\left.\\dfrac{dP_{\\text{port}}}{dy}\\right|_{y=0} = 0$.\n  3) Box constraints: $w_{\\min} \\le w_i \\le w_{\\max}$ for all $i$.\n- Maximize the dollar convexity per unit price. Under the unit-price budget constraint, this coincides with maximizing the portfolio’s dollar convexity itself. The objective must be expressed in terms of $w_i$, $T_i$, and $P_i$ derived from first principles as above.\n- Solve this problem as an optimization subject to linear equality constraints and bound constraints. All interest rates must be interpreted as decimals (not percentages). Time must be in years. The final optimized convexity must be reported in units of years squared.\n\nImplementation requirements:\n- Input is hard-coded via a test suite described below; no external input is read.\n- For each test case, compute the optimal convexity value as a float in years squared. Round each result to six decimal places.\n\nTest suite:\nFor each test case, the input is a triple: a list of maturities $[T_1,\\dots,T_n]$ in years, a list of continuously compounded spot rates $[r(T_1),\\dots,r(T_n)]$ in decimals, and uniform bounds $(w_{\\min}, w_{\\max})$ applied to all $w_i$.\n\n- Test case 1 (happy path):\n  - $T = [1.0, 3.0, 10.0]$\n  - $r = [0.02, 0.025, 0.03]$\n  - $(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$\n\n- Test case 2 (multiple degrees of freedom, moderate bounds):\n  - $T = [0.5, 2.0, 5.0, 20.0]$\n  - $r = [0.015, 0.02, 0.028, 0.035]$\n  - $(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$\n\n- Test case 3 (flat curve edge case):\n  - $T = [1.0, 2.0, 4.0]$\n  - $r = [0.02, 0.02, 0.02]$\n  - $(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$\n\n- Test case 4 (short and long maturities mix):\n  - $T = [0.25, 7.0, 15.0]$\n  - $r = [0.01, 0.03, 0.035]$\n  - $(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For the four test cases above, the output must be of the form \"[c1,c2,c3,c4]\" where each $c_k$ is the optimized convexity in years squared, rounded to six decimal places, with no additional text.", "solution": "The problem statement shall first be subjected to rigorous validation.\n\n## Problem Validation\n\n### Step 1: Extract Givens\nThe givens are extracted verbatim from the problem description:\n\n- **Definitions:**\n  - Zero-coupon bond price: $P(T) = \\exp(-r(T)\\,T)$ for maturity $T$ and spot rate $r(T)$.\n  - Perturbed price under parallel shift $y$: $P_y(T) = \\exp(-(r(T)+y)\\,T)$.\n  - Portfolio price under shift $y$: $P_{\\text{port}}(y) = \\sum_i w_i\\, \\exp(-(r(T_i)+y)\\,T_i)$.\n  - Portfolio dollar duration: $D_\\$ = -\\left.\\dfrac{dP_{\\text{port}}}{dy}\\right|_{y=0}$.\n  - Portfolio dollar convexity: $C_\\$ = \\left.\\dfrac{d^2 P_{\\text{port}}}{dy^2}\\right|_{y=0}$.\n\n- **Objective:**\n  - Maximize the dollar convexity per unit price.\n\n- **Constraints:**\n  1. Unit-price budget constraint: $\\sum_i w_i\\,P_i = 1$, where $P_i = \\exp(-r(T_i)\\,T_i)$.\n  2. Zero dollar duration constraint: $-\\left.\\dfrac{dP_{\\text{port}}}{dy}\\right|_{y=0} = 0$.\n  3. Box constraints on weights: $w_{\\min} \\le w_i \\le w_{\\max}$ for all $i$.\n\n- **Test Suite Data:**\n  - Case 1: $T = [1.0, 3.0, 10.0]$, $r = [0.02, 0.025, 0.03]$, $(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$.\n  - Case 2: $T = [0.5, 2.0, 5.0, 20.0]$, $r = [0.015, 0.02, 0.028, 0.035]$, $(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$.\n  - Case 3: $T = [1.0, 2.0, 4.0]$, $r = [0.02, 0.02, 0.02]$, $(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$.\n  - Case 4: $T = [0.25, 7.0, 15.0]$, $r = [0.01, 0.03, 0.035]$, $(w_{\\min}, w_{\\max}) = (-2.0, 2.0)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed against the required criteria.\n\n- **Scientifically Grounded:** The problem is firmly rooted in the principles of fixed-income analysis. The definitions provided for bond pricing, dollar duration, and dollar convexity are standard Taylor series-based approximations used in interest rate risk management. The overall task of constructing a portfolio to meet specific risk (duration) and performance (convexity) targets is a canonical problem in financial engineering, often referred to as portfolio immunization or hedging. The formulation is mathematically and financially sound.\n- **Well-Posed:** The problem is a constrained optimization task. As will be shown, it reduces to a Linear Program (LP). An LP with a non-empty feasible region (the set of weights $\\mathbf{w}$ satisfying all constraints) is guaranteed to have a solution. Given the constraints, a feasible region is not guaranteed but is highly likely for the provided test cases. The problem is sufficiently specified to allow for a unique, stable, and meaningful solution.\n- **Objective:** The problem is stated using precise, unambiguous mathematical and financial terminology. There are no subjective or opinion-based statements.\n\nThe problem does not exhibit any of the listed invalidity flaws. It is scientifically sound, formalizable, complete, and well-structured.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be developed.\n\n## Solution Derivation and Algorithmic Design\n\nThe task is to structure a portfolio of zero-coupon bonds to maximize convexity while being immune to first-order parallel shifts in the yield curve (i.e., having zero dollar duration). The portfolio's initial price is constrained to be one unit of currency.\n\n### Derivation of Objective and Constraint Functions\n\nWe begin by deriving the expressions for dollar duration and dollar convexity from the provided definition of the portfolio price under a parallel yield curve shift $y$:\n$$P_{\\text{port}}(y) = \\sum_{i} w_i \\exp(-(r(T_i) + y)T_i)$$\nLet $P_i = \\exp(-r(T_i)T_i)$ be the initial price of the $i$-th bond. The expression can be rewritten as:\n$$P_{\\text{port}}(y) = \\sum_{i} w_i P_i \\exp(-yT_i)$$\nThe portfolio's value is a function of the weights $w_i$ and the yield shift $y$. We now compute the required derivatives with respect to $y$, evaluated at $y=0$.\n\nThe first derivative is:\n$$\\frac{dP_{\\text{port}}}{dy} = \\frac{d}{dy} \\left( \\sum_{i} w_i P_i \\exp(-yT_i) \\right) = \\sum_{i} w_i P_i \\frac{d}{dy}(\\exp(-yT_i)) = \\sum_{i} w_i P_i (-T_i \\exp(-yT_i))$$\nEvaluating at $y=0$:\n$$\\left.\\frac{dP_{\\text{port}}}{dy}\\right|_{y=0} = -\\sum_{i} w_i P_i T_i$$\nThe portfolio dollar duration, $D_\\$$, is defined as the negative of this quantity:\n$$D_\\$ = -\\left.\\frac{dP_{\\text{port}}}{dy}\\right|_{y=0} = \\sum_{i} w_i P_i T_i$$\n\nThe second derivative is:\n$$\\frac{d^2P_{\\text{port}}}{dy^2} = \\frac{d}{dy} \\left( -\\sum_{i} w_i P_i T_i \\exp(-yT_i) \\right) = -\\sum_{i} w_i P_i T_i (-T_i \\exp(-yT_i)) = \\sum_{i} w_i P_i T_i^2 \\exp(-yT_i)$$\nEvaluating at $y=0$:\n$$\\left.\\frac{d^2P_{\\text{port}}}{dy^2}\\right|_{y=0} = \\sum_{i} w_i P_i T_i^2$$\nThe portfolio dollar convexity, $C_\\$$, is defined as this second derivative:\n$$C_\\$ = \\left.\\frac{d^2P_{\\text{port}}}{dy^2}\\right|_{y=0} = \\sum_{i} w_i P_i T_i^2$$\n\n### Formulation as a Linear Programming Problem\n\nThe problem is to find the vector of weights $\\mathbf{w} = [w_1, w_2, \\dots, w_n]^T$ that solves the following optimization problem:\n\n**Maximize:**\n$$C_\\$ = \\sum_{i=1}^n w_i P_i T_i^2$$\n\n**Subject to:**\n1.  **Unit Price:** $\\sum_{i=1}^n w_i P_i = 1$\n2.  **Zero Dollar Duration:** $\\sum_{i=1}^n w_i P_i T_i = 0$\n3.  **Box Constraints:** $w_{\\min} \\le w_i \\le w_{\\max}$ for $i=1, \\dots, n$\n\nThis is a Linear Programming (LP) problem. The objective function and all constraints are linear functions of the decision variables $w_i$. We will use a standard LP solver, `scipy.optimize.linprog`, which is designed to solve minimization problems. To maximize our objective function $C_\\$$, we will minimize its negative, $-C_\\$$.\n\nThe standard form for `scipy.optimize.linprog` is:\n$\\min_{\\mathbf{w}} \\mathbf{c}^T \\mathbf{w}$ subject to $\\mathbf{A}_{\\text{eq}}\\mathbf{w} = \\mathbf{b}_{\\text{eq}}$ and $\\mathbf{l} \\le \\mathbf{w} \\le \\mathbf{u}$.\n\nMatching our problem to this form:\n- **Decision variables** $\\mathbf{w}$: The vector of bond weights $[w_1, \\dots, w_n]^T$.\n- **Objective vector** $\\mathbf{c}$: To minimize $-C_\\$ = -\\sum_i w_i P_i T_i^2$, the objective vector is $\\mathbf{c} = [-P_1 T_1^2, -P_2 T_2^2, \\dots, -P_n T_n^2]^T$.\n- **Equality constraints matrix** $\\mathbf{A}_{\\text{eq}}$: This is a $2 \\times n$ matrix where each row corresponds to an equality constraint.\n  - Row 1 (Unit Price): $[P_1, P_2, \\dots, P_n]$\n  - Row 2 (Zero Duration): $[P_1 T_1, P_2 T_2, \\dots, P_n T_n]$\n- **Equality constraints vector** $\\mathbf{b}_{\\text{eq}}$: This is a vector of length $2$.\n  - $[1, 0]^T$\n- **Bounds**: The box constraints are handled directly by the `bounds` parameter, which is a sequence of $(w_{\\min}, w_{\\max})$ tuples for each $w_i$.\n\n### Algorithm for Implementation\n\nFor each given test case (a set of maturities $T_i$, spot rates $r_i$, and bounds $w_{\\min}, w_{\\max}$):\n1.  Compute the bond prices $P_i = \\exp(-r_i T_i)$ for all $i$.\n2.  Construct the objective vector $\\mathbf{c}$ for the minimization problem. For each bond $i$, the corresponding element is $-P_i T_i^2$.\n3.  Construct the $2 \\times n$ equality constraint matrix $\\mathbf{A}_{\\text{eq}}$. The first row contains the prices $P_i$, and the second row contains the dollar duration contributions per unit, $P_i T_i$.\n4.  Construct the equality constraint vector $\\mathbf{b}_{\\text{eq}} = [1, 0]^T$.\n5.  Define the bounds for each weight $w_i$ as $(w_{\\min}, w_{\\max})$.\n6.  Solve the LP problem using `scipy.optimize.linprog`. The result of the optimization, `res.fun`, will be the minimum value of the objective function, which is $-\\max(C_\\$)$.\n7.  The maximum convexity is therefore $-(\\text{res.fun})$.\n8.  Round the final convexity value to six decimal places as required.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves for the maximum portfolio convexity under duration and budget constraints\n    for a series of test cases.\n    \"\"\"\n    \n    # Test suite as per the problem description.\n    test_cases = [\n        {\n            \"T\": [1.0, 3.0, 10.0],\n            \"r\": [0.02, 0.025, 0.03],\n            \"bounds\": (-2.0, 2.0)\n        },\n        {\n            \"T\": [0.5, 2.0, 5.0, 20.0],\n            \"r\": [0.015, 0.02, 0.028, 0.035],\n            \"bounds\": (-2.0, 2.0)\n        },\n        {\n            \"T\": [1.0, 2.0, 4.0],\n            \"r\": [0.02, 0.02, 0.02],\n            \"bounds\": (-2.0, 2.0)\n        },\n        {\n            \"T\": [0.25, 7.0, 15.0],\n            \"r\": [0.01, 0.03, 0.035],\n            \"bounds\": (-2.0, 2.0)\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Extract data for the current test case\n        T = np.array(case[\"T\"])\n        r = np.array(case[\"r\"])\n        w_min, w_max = case[\"bounds\"]\n        n = len(T)\n\n        # 1. Calculate bond prices from spot rates and maturities\n        # P_i = exp(-r_i * T_i)\n        P = np.exp(-r * T)\n\n        # 2. Formulate the Linear Programming problem\n        \n        # Objective function: Maximize sum(w_i * P_i * T_i^2)\n        # For a minimization solver, we minimize -sum(w_i * P_i * T_i^2).\n        # The objective vector c for linprog is [-P_1*T_1^2, -P_2*T_2^2, ...]\n        c_obj = -(P * T**2)\n\n        # Equality constraints: A_eq @ w = b_eq\n        # Constraint 1: sum(w_i * P_i) = 1 (unit price)\n        # Constraint 2: sum(w_i * P_i * T_i) = 0 (zero dollar duration)\n        A_eq = np.array([\n            P,        # Coefficients for the unit price constraint\n            P * T     # Coefficients for the zero dollar duration constraint\n        ])\n        b_eq = np.array([1, 0])\n\n        # Bounds for each weight w_i\n        bounds = [(w_min, w_max)] * n\n\n        # 3. Solve the LP problem\n        # The 'highs' method is robust and recommended for new applications.\n        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        if res.success:\n            # The solver returns the minimum value of the objective function.\n            # Since our objective was negated for minimization, the maximum\n            # convexity is the negative of the solver's result.\n            max_convexity = -res.fun\n            results.append(round(max_convexity, 6))\n        else:\n            # In case the optimization fails (e.g., infeasible problem),\n            # append NaN or handle as an error. For this problem, we assume\n            # a solution exists for all test cases.\n            results.append(np.nan)\n\n    # 4. Print the final results in the specified format\n    # Example format: [c1,c2,c3,c4]\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"}, {"introduction": "The previous exercises focused on describing and managing risk based on a given term structure. We now turn to theoretical models that attempt to explain the underlying dynamics of interest rates themselves. In this exercise ([@problem_id:2436856]), you will work with the classic Cox-Ingersoll-Ross (CIR) model, implementing its analytical solution for bond prices to explore how different economic assumptions, represented by model parameters, can generate various yield curve shapes, including the much-discussed inverted curve.", "id": "2436856", "problem": "You are given the following setup for the Cox–Ingersoll–Ross (CIR) short-rate model under the risk-neutral measure. The short rate process is defined by the stochastic differential equation $dr_t = \\kappa(\\theta - r_t) \\, dt + \\sigma \\sqrt{r_t} \\, dW_t$, where $r_t$ is the short rate at time $t$, $\\kappa$ is the speed of mean reversion, $\\theta$ is the long-run mean level, $\\sigma$ is the volatility parameter, and $W_t$ is a standard Wiener process. Assume the process is well-defined and that the parameters are such that the model is admissible.\n\nAt time $t=0$, denote the given initial short rate by $r_0$. For any maturity $T > 0$ (in years), the time-$0$ price of a default-free zero-coupon bond maturing at $T$, denoted $P(0,T)$, is defined by the risk-neutral valuation formula\n$$\nP(0,T) = \\mathbb{E}\\left[ \\exp\\left( -\\int_0^T r_s \\, ds \\right) \\right],\n$$\nand the corresponding continuously-compounded zero-coupon yield is\n$$\ny(0,T) = -\\frac{1}{T}\\ln P(0,T).\n$$\n\nYour task is to, for each parameter set in the test suite below, generate the yield curve $\\{y(0,T_i)\\}_{i=1}^n$ at the specified maturities $T_i$ (in years) and determine whether the curve is inverted on this grid. An inverted yield curve on the grid $\\{T_i\\}_{i=1}^n$ means the yields are strictly decreasing with maturity on this grid, i.e., $y(0,T_{i+1}) < y(0,T_i)$ for every adjacent pair $(T_i,T_{i+1})$ in the grid.\n\nAll yields must be treated as rates per year in decimal form. Maturities are in years. The final outputs are booleans indicating whether the yield curve is inverted on the specified grid for each parameter set.\n\nTest suite:\n- Maturity grid: $\\{T_i\\}_{i=1}^5 = [0.5, 1.0, 2.0, 5.0, 10.0]$ (years).\n- Parameter sets $(\\kappa,\\theta,\\sigma,r_0)$:\n    1. $(1.0,\\, 0.03,\\, 0.10,\\, 0.12)$\n    2. $(0.5,\\, 0.05,\\, 0.10,\\, 0.01)$\n    3. $(1.5,\\, 0.03,\\, 0.05,\\, 0.025)$\n    4. $(0.8,\\, 0.02,\\, \\sqrt{2 \\cdot 0.8 \\cdot 0.02},\\, 0.09)$\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the parameter sets above. For example, a valid output format is $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$, where each $\\text{result}_j$ is either $\\text{True}$ or $\\text{False}$.", "solution": "The problem statement submitted for analysis is deemed valid. It is scientifically grounded in the established theory of interest rate term structure models, specifically the Cox–Ingersoll–Ross (CIR) model. The problem is well-posed, with all necessary parameters and definitions provided, allowing for the computation of a unique and meaningful solution. All given parameter sets adhere to the Feller condition, $2\\kappa\\theta \\geq \\sigma^2$, ensuring the short-rate process remains non-negative.\n\nThe task is to determine whether the yield curve is inverted for several parameter sets. A yield curve is defined as inverted on a specified grid of maturities, $\\{T_i\\}_{i=1}^n$, if the yield $y(0, T)$ is a strictly decreasing function of maturity $T$ over that grid, i.e., $y(0,T_{i+1}) < y(0,T_i)$ for all adjacent pairs in the grid.\n\nThe solution begins with the analytical formula for the price of a zero-coupon bond, $P(0, T)$, under the CIR model. The model specifies the short-rate dynamics as:\n$$\ndr_t = \\kappa(\\theta - r_t) \\, dt + \\sigma \\sqrt{r_t} \\, dW_t\n$$\nFor this process, the price of a bond at time $t=0$ maturing at time $T$ is given by an affine term structure model:\n$$\nP(0, T) = A(0, T) e^{-B(0, T) r_0}\n$$\nwhere $r_0$ is the initial short rate. The functions $A(0, T)$ and $B(0, T)$ depend on the model parameters $(\\kappa, \\theta, \\sigma)$ and the time to maturity $T$.\n\nFirst, we define an auxiliary parameter, $\\gamma$, as:\n$$\n\\gamma = \\sqrt{\\kappa^2 + 2\\sigma^2}\n$$\nThe function $B(0, T)$ is then given by:\n$$\nB(0, T) = \\frac{2(e^{\\gamma T} - 1)}{(\\gamma + \\kappa)(e^{\\gamma T} - 1) + 2\\gamma}\n$$\nAnd the function $A(0, T)$ is given by:\n$$\nA(0, T) = \\left[ \\frac{2\\gamma e^{(\\kappa + \\gamma)T/2}}{(\\gamma + \\kappa)(e^{\\gamma T} - 1) + 2\\gamma} \\right]^{\\frac{2\\kappa\\theta}{\\sigma^2}}\n$$\nThe continuously compounded yield, $y(0, T)$, is defined as:\n$$\ny(0, T) = -\\frac{1}{T} \\ln P(0, T)\n$$\nSubstituting the expression for $P(0, T)$, we obtain the formula for the yield:\n$$\ny(0, T) = -\\frac{1}{T} \\left( \\ln A(0, T) - B(0, T) r_0 \\right) = \\frac{B(0, T) r_0 - \\ln A(0, T)}{T}\n$$\nTo avoid numerical instability, especially for large $T$, it is preferable to work with the logarithm of $A(0, T)$ directly:\n$$\n\\ln A(0, T) = \\frac{2\\kappa\\theta}{\\sigma^2} \\left[ \\ln(2\\gamma) + \\frac{(\\kappa + \\gamma)T}{2} - \\ln\\left( (\\gamma + \\kappa)(e^{\\gamma T} - 1) + 2\\gamma \\right) \\right]\n$$\nThe algorithm to solve the problem is as follows:\n1.  For each given parameter set $(\\kappa, \\theta, \\sigma, r_0)$:\n2.  Define the maturity grid $T_{grid} = [0.5, 1.0, 2.0, 5.0, 10.0]$.\n3.  Calculate the auxiliary parameter $\\gamma$.\n4.  For each maturity $T_i$ in the grid, compute the yield $y(0, T_i)$ using the formulas for $B(0, T_i)$ and $\\ln A(0, T_i)$. This generates a vector of yields corresponding to the maturity grid.\n5.  Check if this vector of yields is strictly decreasing. This is achieved by verifying the condition $y(0, T_{i+1}) < y(0, T_i)$ for $i=1, \\dots, 4$.\n6.  If the condition holds for all pairs, the result for the given parameter set is `True`; otherwise, it is `False`.\n\nThis procedure is deterministic and will be implemented for each test case to produce the final output. The shape of the CIR yield curve is primarily determined by the relation between the initial rate $r_0$ and the long-run mean rate $\\theta$. If $r_0$ is substantially higher than $\\theta$, the short rate is expected to fall, typically resulting in an inverted yield curve. Conversely, if $r_0 < \\theta$, an upward-sloping curve is expected. The final check across the specified grid provides a definitive answer for the given discrete maturities.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates CIR model yield curves for several parameter sets and checks for inversion.\n    \"\"\"\n    # Define the maturity grid from the problem statement.\n    T_grid = np.array([0.5, 1.0, 2.0, 5.0, 10.0])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (kappa, theta, sigma, r0)\n        (1.0, 0.03, 0.10, 0.12),\n        (0.5, 0.05, 0.10, 0.01),\n        (1.5, 0.03, 0.05, 0.025),\n        (0.8, 0.02, np.sqrt(2 * 0.8 * 0.02), 0.09)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        kappa, theta, sigma, r0 = case\n        \n        # Ensure Feller condition 2*kappa*theta >= sigma**2 holds, although problem statement guarantees it.\n        # This check is for robustness against division by zero if sigma is very small.\n        if sigma < 1e-9:\n            # Handle the case of zero volatility separately if needed. For this problem, not necessary.\n            # Simplified model dynamics would apply.\n            # This is a degenerate case and not in the test suite.\n            # Based on the formula, we need sigma**2 in the denominator for log_A.\n            # However, 2*kappa*theta/sigma**2 can be shown to have a well-defined limit as sigma -> 0.\n            # We assume sigma is not pathologically small.\n            pass\n\n        # 1. Calculate auxiliary parameter gamma\n        gamma = np.sqrt(kappa**2 + 2 * sigma**2)\n\n        # 2. Vectorized calculation for the entire maturity grid T\n        T = T_grid\n        \n        # Calculate term e^(gamma*T)\n        exp_gamma_T = np.exp(gamma * T)\n\n        # Common denominator for both A(0,T) and B(0,T)\n        common_denominator = (gamma + kappa) * (exp_gamma_T - 1) + 2 * gamma\n        \n        # 3. Calculate B(0, T)\n        B_0T = 2 * (exp_gamma_T - 1) / common_denominator\n        \n        # 4. Calculate log of A(0, T) to maintain numerical stability\n        exponent_log_A = 2 * kappa * theta / (sigma**2)\n        log_A_base_numerator = 2 * gamma * np.exp((kappa + gamma) * T / 2)\n        log_A_base = log_A_base_numerator / common_denominator\n        log_A_0T = exponent_log_A * np.log(log_A_base)\n        \n        # 5. Calculate log of bond price P(0, T)\n        log_P_0T = log_A_0T - B_0T * r0\n        \n        # 6. Calculate the yield curve y(0, T)\n        yield_curve = -log_P_0T / T\n        \n        # 7. Check if the yield curve is strictly inverted on the grid\n        # np.diff(x) calculates x[i+1] - x[i].\n        # For a strictly decreasing sequence, all differences must be negative.\n        is_inverted = np.all(np.diff(yield_curve) < 0)\n        \n        results.append(is_inverted)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}