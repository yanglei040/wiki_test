{"hands_on_practices": [{"introduction": "While the Black-Scholes-Merton model provides elegant closed-form solutions for option Greeks, many real-world models do not. This exercise bridges theory and practice by having you implement both the analytical formulas and the versatile finite difference method for calculating these sensitivities. By comparing the two, you will gain hands-on insight into the numerical stability of these approximations and the critical trade-off involved in choosing the perturbation size, a fundamental concept in computational finance [@problem_id:2416913].", "id": "2416913", "problem": "You are to write a complete and runnable program that, under the Black–Scholes–Merton model with continuously compounded risk-free rate and no dividends, evaluates the analytical sensitivities (Greeks) of a European call option and compares them to symmetric finite-difference approximations as the bump size $h$ approaches zero. Work in the following definitions and conventions.\n\nConsider a European call option with underlying asset price $S&gt;0$, strike price $K&gt;0$, risk-free rate $r\\in\\mathbb{R}$ expressed as a decimal per annum, volatility $\\sigma&gt;0$ expressed as a decimal per annum, and time to maturity $T&gt;0$ in years. Under the Black–Scholes–Merton model, the option price $C(S,K,r,\\sigma,T)$ is well-defined, and the Greeks of interest (with respect to their natural variables) are:\n- Delta $\\Delta := \\frac{\\partial C}{\\partial S}$,\n- Gamma $\\Gamma := \\frac{\\partial^2 C}{\\partial S^2}$,\n- Vega $\\mathcal{V} := \\frac{\\partial C}{\\partial \\sigma}$,\n- Theta $\\Theta := \\frac{\\partial C}{\\partial T}$, where $T$ denotes time-to-maturity (note this is the derivative with respect to $T$, not with respect to calendar time),\n- Rho $\\mathrm{P} := \\frac{\\partial C}{\\partial r}$.\n\nYour program must:\n- Compute the analytical values of $\\Delta$, $\\Gamma$, $\\mathcal{V}$, $\\Theta$, and $\\mathrm{P}$ for each parameter tuple $(S,K,r,\\sigma,T)$ using the Black–Scholes–Merton framework without dividends.\n- For each Greek, and for each bump size $h$ in the set $\\mathcal{H} = \\{10^{-1},10^{-2},10^{-3},10^{-4},10^{-5},10^{-6}\\}$, compute the symmetric finite-difference approximation with respect to its defining variable using the central difference stencil when well-defined. The central differences to be used are:\n  - For $\\Delta$ and $\\Gamma$, perturb $S$ by $\\pm h$,\n  - For $\\mathcal{V}$, perturb $\\sigma$ by $\\pm h$,\n  - For $\\Theta$, perturb $T$ by $\\pm h$,\n  - For $\\mathrm{P}$, perturb $r$ by $\\pm h$.\n- Enforce domain constraints so that perturbed parameters remain in their domains. Specifically, only use a given $h\\in\\mathcal{H}$ for a Greek if the corresponding plus and minus perturbations keep the argument within its valid domain, namely $S\\pm h&gt;0$, $\\sigma\\pm h&gt;0$, $T\\pm h&gt;0$, and no restriction for $r\\pm h$.\n- For each admissible $h$, compute the absolute relative error between the finite-difference approximation and its analytical Greek. If the analytical value equals $0$ exactly, define the error as the absolute difference. For each Greek, identify the $h\\in\\mathcal{H}$ (among those admitted by the domain constraints) that minimizes this error. If no $h$ is admissible for a particular Greek in a test case, report a non-number for that Greek.\n\nTest suite. Your program must evaluate the above for the following parameter tuples $(S,K,r,\\sigma,T)$:\n- Case A (general): $(S,K,r,\\sigma,T)=(100,100,0.05,0.2,1)$.\n- Case B (short maturity): $(S,K,r,\\sigma,T)=(100,100,0.05,0.2,0.01)$.\n- Case C (deep in-the-money): $(S,K,r,\\sigma,T)=(150,100,0.05,0.3,1.5)$.\n- Case D (deep out-of-the-money, low volatility): $(S,K,r,\\sigma,T)=(50,100,0.01,0.05,2)$.\n\nAll rates and volatilities must be treated as decimals (for example, $0.05$ rather than $5$), and time $T$ must be in years.\n\nRequired final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The result for each test case must be a list of five floating-point numbers in the order $[\\Delta,\\Gamma,\\mathcal{V},\\Theta,\\mathrm{P}]$ representing, for each Greek, the bump size $h\\in\\mathcal{H}$ that minimizes the error under the above criterion (or a non-number if no admissible $h$ exists). The overall output must therefore be a list of four such lists, in the same order as Cases A through D. For example, the printed structure must look like $[[h\\_{\\Delta}^{(A)},h\\_{\\Gamma}^{(A)},h\\_{\\mathcal{V}}^{(A)},h\\_{\\Theta}^{(A)},h\\_{\\mathrm{P}}^{(A)}],[h\\_{\\Delta}^{(B)},\\dots],[h\\_{\\Delta}^{(C)},\\dots],[h\\_{\\Delta}^{(D)},\\dots]]$ with numeric values substituted.", "solution": "The problem requires the implementation and comparison of analytical and numerical methods for calculating the sensitivities, or \"Greeks,\" of a European call option within the Black-Scholes-Merton (BSM) framework. The validity of this problem is affirmed, as it is based on fundamental principles of financial mathematics and numerical analysis. It is well-posed, objective, and contains all necessary information for a unique solution.\n\nThe solution proceeds in three stages. First, we present the analytical formulas for the option price and its associated Greeks. Second, we define the finite-difference schemes used for their numerical approximation. Finally, we detail the algorithm for comparing these methods and identifying the optimal numerical step size $h$ for each case.\n\n**1. The Black-Scholes-Merton Model**\n\nThe price of a European call option, $C$, on a non-dividend-paying underlying asset is given by the BSM formula:\n$$\nC(S, K, r, \\sigma, T) = S N(d_1) - K e^{-rT} N(d_2)\n$$\nwhere the parameters are:\n- $S$: current price of the underlying asset $(S>0)$\n- $K$: strike price of the option $(K>0)$\n- $r$: continuously compounded risk-free interest rate\n- $\\sigma$: volatility of the underlying asset's returns $(\\sigma>0)$\n- $T$: time to maturity in years $(T>0)$\n\nThe functions $N(\\cdot)$, $d_1$, and $d_2$ are defined as:\n- $N(x)$: The cumulative distribution function (CDF) of the standard normal distribution, $N(x) = \\int_{-\\infty}^{x} \\phi(z) dz$, where $\\phi(z) = \\frac{1}{\\sqrt{2\\pi}}e^{-z^2/2}$ is the probability density function (PDF).\n- $d_1 = \\frac{\\ln(S/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma \\sqrt{T}}$\n- $d_2 = d_1 - \\sigma \\sqrt{T} = \\frac{\\ln(S/K) + (r - \\frac{1}{2}\\sigma^2)T}{\\sigma \\sqrt{T}}$\n\n**2. Analytical Formulas for the Greeks**\n\nThe Greeks are the partial derivatives of the option price $C$ with respect to its parameters. The analytical formulas for the Greeks specified in the problem are as follows:\n\n- **Delta ($\\Delta$):** The rate of change of the option price with respect to the underlying asset price $S$.\n$$\n\\Delta = \\frac{\\partial C}{\\partial S} = N(d_1)\n$$\n\n- **Gamma ($\\Gamma$):** The rate of change of Delta with respect to $S$. It is the second partial derivative of $C$ with respect to $S$.\n$$\n\\Gamma = \\frac{\\partial^2 C}{\\partial S^2} = \\frac{\\phi(d_1)}{S\\sigma\\sqrt{T}}\n$$\n\n- **Vega ($\\mathcal{V}$):** The rate of change of the option price with respect to volatility $\\sigma$.\n$$\n\\mathcal{V} = \\frac{\\partial C}{\\partial \\sigma} = S\\phi(d_1)\\sqrt{T}\n$$\n\n- **Theta ($\\Theta$):** The rate of change of the option price with respect to the time to maturity $T$. As specified, this is $\\frac{\\partial C}{\\partial T}$, which is of opposite sign to the conventional definition of Theta that measures sensitivity to the passage of calendar time.\n$$\n\\Theta = \\frac{\\partial C}{\\partial T} = \\frac{S\\phi(d_1)\\sigma}{2\\sqrt{T}} + r K e^{-rT} N(d_2)\n$$\n\n- **Rho ($\\mathrm{P}$):** The rate of change of the option price with respect to the risk-free rate $r$.\n$$\n\\mathrm{P} = \\frac{\\partial C}{\\partial r} = K T e^{-rT} N(d_2)\n$$\n\n**3. Finite-Difference Approximations**\n\nWe employ symmetric finite-difference stencils to approximate the derivatives. For a function $f(x)$ and a small perturbation $h$:\n\n- The first derivative is approximated by the central difference formula:\n$$\nf'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h} \\quad (\\text{Error } O(h^2))\n$$\n\n- The second derivative is approximated by:\n$$\nf''(x) \\approx \\frac{f(x+h) - 2f(x) + f(x-h)}{h^2} \\quad (\\text{Error } O(h^2))\n$$\n\nApplying these to the option price function $C(\\cdot)$ yields the following approximations for the Greeks:\n\n- **Delta:** $\\Delta_{\\text{FD}}(h) = \\frac{C(S+h, \\dots) - C(S-h, \\dots)}{2h}$\n- **Gamma:** $\\Gamma_{\\text{FD}}(h) = \\frac{C(S+h, \\dots) - 2C(S, \\dots) + C(S-h, \\dots)}{h^2}$\n- **Vega:** $\\mathcal{V}_{\\text{FD}}(h) = \\frac{C(\\dots, \\sigma+h, \\dots) - C(\\dots, \\sigma-h, \\dots)}{2h}$\n- **Theta:** $\\Theta_{\\text{FD}}(h) = \\frac{C(\\dots, T+h) - C(\\dots, T-h)}{2h}$\n- **Rho:** $\\mathrm{P}_{\\text{FD}}(h) = \\frac{C(\\dots, r+h, \\dots) - C(\\dots, r-h, \\dots)}{2h}$\n\n**4. Algorithmic Procedure**\n\nThe objective is to find the bump size $h$ from the set $\\mathcal{H} = \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}, 10^{-5}, 10^{-6}\\}$ that minimizes the approximation error for each Greek.\n\nThe algorithm for each test case $(S,K,r,\\sigma,T)$ and for each Greek $G \\in \\{\\Delta, \\Gamma, \\mathcal{V}, \\Theta, \\mathrm{P}\\}$ is as follows:\n\n1.  **Compute Analytical Value:** Calculate the true value, $G_{\\text{analytical}}$, using the formulas from Section 2.\n2.  **Iterate and Evaluate:** For each $h \\in \\mathcal{H}$:\n    a. **Validate Domain:** Check if the perturbation is valid. For a variable $x \\in \\{S, \\sigma, T\\}$ with domain $x>0$, the condition is $x-h > 0$. If this condition is not met, the current $h$ is inadmissible and is skipped. No domain constraint applies to $r$.\n    b. **Compute Numerical Approximation:** If $h$ is admissible, compute the finite-difference approximation, $G_{\\text{FD}}(h)$, using the formulas from Section 3.\n    c. **Compute Error:** Calculate the error. If $|G_{\\text{analytical}}| > \\epsilon$ (where $\\epsilon$ is a small tolerance like $10^{-15}$), use the absolute relative error:\n    $$\n    \\text{Error}(h) = \\left| \\frac{G_{\\text{FD}}(h) - G_{\\text{analytical}}}{G_{\\text{analytical}}} \\right|\n    $$\n    Otherwise, if $G_{\\text{analytical}} \\approx 0$, use the absolute error to avoid division by zero:\n    $$\n    \\text{Error}(h) = |G_{\\text{FD}}(h) - G_{\\text{analytical}}|\n    $$\n    d. **Track Minimum:** Compare $\\text{Error}(h)$ with the minimum error found so far. If it is lower, store $h$ as the current optimal bump size.\n3.  **Report Result:** After iterating through all $h \\in \\mathcal{H}$, the stored optimal $h$ is the result for the Greek $G$. If no $h$ was admissible, the result is a non-number (NaN).\n\nThis procedure is repeated for all five Greeks and for all four test cases provided in the problem statement. The final implementation encapsulates this logic in a Python script.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Evaluates optimal finite-difference bump sizes for Black-Scholes-Merton Greeks.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (S, K, r, sigma, T)\n        (100.0, 100.0, 0.05, 0.20, 1.0),\n        # Case B\n        (100.0, 100.0, 0.05, 0.20, 0.01),\n        # Case C\n        (150.0, 100.0, 0.05, 0.30, 1.5),\n        # Case D\n        (50.0, 100.0, 0.01, 0.05, 2.0)\n    ]\n\n    H_SET = [1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6]\n    \n    def bsm_call_price(S, K, r, sigma, T):\n        \"\"\"Calculates the BSM price of a European call option.\"\"\"\n        # For T=0, the option price is its intrinsic value.\n        # Use a small tolerance for floating point comparisons.\n        if T < 1e-9:\n            return max(0.0, S - K)\n        \n        # If other parameters are non-positive, price is 0. This is enforced\n        # by the domain constraint checks on h, but is good practice.\n        if S <= 0 or K <= 0 or sigma <= 0:\n            return 0.0\n\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    def analytical_greeks(S, K, r, sigma, T):\n        \"\"\"Calculates the analytical values of BSM Greeks.\"\"\"\n        # As per problem, T > 0, so no need to handle T=0 case separately here.\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n\n        phi_d1 = norm.pdf(d1)\n        cdf_d1 = norm.cdf(d1)\n        cdf_d2 = norm.cdf(d2)\n\n        delta = cdf_d1\n        gamma = phi_d1 / (S * sigma * np.sqrt(T))\n        vega = S * phi_d1 * np.sqrt(T)\n        # As per problem, Theta is dC/dT (time-to-maturity), not dC/dt (calendar time).\n        theta = (S * phi_d1 * sigma) / (2 * np.sqrt(T)) + r * K * np.exp(-r * T) * cdf_d2\n        rho = K * T * np.exp(-r * T) * cdf_d2\n\n        return {\n            'delta': delta, \n            'gamma': gamma, \n            'vega': vega, \n            'theta': theta, \n            'rho': rho\n        }\n\n    all_results = []\n    for S, K, r, sigma, T in test_cases:\n        case_results = []\n        greeks_ana = analytical_greeks(S, K, r, sigma, T)\n\n        # --- Delta and Gamma ---\n        min_error_delta, optimal_h_delta = float('inf'), np.nan\n        min_error_gamma, optimal_h_gamma = float('inf'), np.nan\n        ana_delta = greeks_ana['delta']\n        ana_gamma = greeks_ana['gamma']\n        price_0 = bsm_call_price(S, K, r, sigma, T)\n        for h in H_SET:\n            if S - h > 0:\n                price_p = bsm_call_price(S + h, K, r, sigma, T)\n                price_m = bsm_call_price(S - h, K, r, sigma, T)\n                \n                # Delta\n                approx_delta = (price_p - price_m) / (2 * h)\n                error_delta = abs((approx_delta - ana_delta) / ana_delta) if abs(ana_delta) > 1e-15 else abs(approx_delta - ana_delta)\n                if error_delta < min_error_delta:\n                    min_error_delta = error_delta\n                    optimal_h_delta = h\n                \n                # Gamma\n                approx_gamma = (price_p - 2 * price_0 + price_m) / (h**2)\n                error_gamma = abs((approx_gamma - ana_gamma) / ana_gamma) if abs(ana_gamma) > 1e-15 else abs(approx_gamma - ana_gamma)\n                if error_gamma < min_error_gamma:\n                    min_error_gamma = error_gamma\n                    optimal_h_gamma = h\n        case_results.extend([optimal_h_delta, optimal_h_gamma])\n        \n        # --- Vega ---\n        min_error_vega, optimal_h_vega = float('inf'), np.nan\n        ana_vega = greeks_ana['vega']\n        for h in H_SET:\n            if sigma - h > 0:\n                approx_vega = (bsm_call_price(S, K, r, sigma + h, T) - bsm_call_price(S, K, r, sigma - h, T)) / (2 * h)\n                error_vega = abs((approx_vega - ana_vega) / ana_vega) if abs(ana_vega) > 1e-15 else abs(approx_vega - ana_vega)\n                if error_vega < min_error_vega:\n                    min_error_vega = error_vega\n                    optimal_h_vega = h\n        case_results.append(optimal_h_vega)\n        \n        # --- Theta ---\n        min_error_theta, optimal_h_theta = float('inf'), np.nan\n        ana_theta = greeks_ana['theta']\n        for h in H_SET:\n            if T - h > 0:\n                approx_theta = (bsm_call_price(S, K, r, sigma, T + h) - bsm_call_price(S, K, r, sigma, T - h)) / (2 * h)\n                error_theta = abs((approx_theta - ana_theta) / ana_theta) if abs(ana_theta) > 1e-15 else abs(approx_theta - ana_theta)\n                if error_theta < min_error_theta:\n                    min_error_theta = error_theta\n                    optimal_h_theta = h\n        case_results.append(optimal_h_theta)\n        \n        # --- Rho ---\n        min_error_rho, optimal_h_rho = float('inf'), np.nan\n        ana_rho = greeks_ana['rho']\n        for h in H_SET:\n            # No domain constraint for r\n            approx_rho = (bsm_call_price(S, K, r + h, sigma, T) - bsm_call_price(S, K, r - h, sigma, T)) / (2 * h)\n            error_rho = abs((approx_rho - ana_rho) / ana_rho) if abs(ana_rho) > 1e-15 else abs(approx_rho - ana_rho)\n            if error_rho < min_error_rho:\n                min_error_rho = error_rho\n                optimal_h_rho = h\n        case_results.append(optimal_h_rho)\n        \n        all_results.append(case_results)\n\n    # Format the final output as a string representing a list of lists.\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"}, {"introduction": "Option Greeks are not merely for risk measurement; they are the fundamental building blocks for constructing sophisticated trading and hedging strategies. This practice challenges you to design a portfolio that isolates a specific market view, a common task for quantitative traders. By creating a Vega-neutral, positive Gamma position using a calendar spread, you will learn how to neutralize risk from one factor (implied volatility level) to speculate on another (realized volatility) [@problem_id:2416880].", "id": "2416880", "problem": "You are given a frictionless market with a single underlying asset whose price is denoted by $S$. European options are priced under the Black–Scholes framework with continuously compounded risk-free rate $r$, continuous dividend yield $q$, and constant volatility $\\sigma$. All times to maturity $T$ are in years. All rates and volatilities must be expressed as decimals, not as percentages.\n\nConsider portfolios formed from two European call options on the same underlying with the same strike $K$ but different maturities $T_1$ and $T_2$ with $T_1 \\lt T_2$. Define the portfolio weights as follows: the position in the short-dated call (maturity $T_1$) is fixed at $w_1 = 1$ (one long unit), and the position in the long-dated call (maturity $T_2$) is $w_2$ (a real number, which may be negative). The Vega of the portfolio with respect to a small parallel shift in the term structure of volatility is defined as the derivative of the portfolio value with respect to $\\sigma$ when both options’ volatilities change by the same small amount. The Gamma of the portfolio is defined as the second derivative of the portfolio value with respect to $S$.\n\nYour task is to determine, for each test case below, the unique weight $w_2$ such that the portfolio’s Vega is exactly zero at the given $S$ (that is, Vega-neutral for small parallel shifts in the term structure of volatility at the current spot), and then compute the resulting net Gamma and the resulting net Vega at that $S$. A portfolio is “long volatility” if its net Gamma is positive at $S$.\n\nImplement a complete program that:\n- Computes the Vega and the Gamma of each constituent option under the Black–Scholes model from first principles.\n- Determines the unique $w_2$ that makes the portfolio’s net Vega equal to zero at the given $S$ with $w_1 = 1$.\n- Evaluates the resulting portfolio’s net Gamma and net Vega at the given $S$.\n\nUse the following test suite of parameter sets, each provided as a tuple $(S,K,r,q,\\sigma,T_1,T_2)$:\n- Test $1$: $(S,K,r,q,\\sigma,T_1,T_2) = (\\,\\$100\\,,\\,\\$100\\,,\\,0.02\\,,\\,0.00\\,,\\,0.20\\,,\\,0.25\\,,\\,1.00\\,)$.\n- Test $2$: $(S,K,r,q,\\sigma,T_1,T_2) = (\\,\\$50\\,,\\,\\$50\\,,\\,0.01\\,,\\,0.03\\,,\\,0.35\\,,\\,0.10\\,,\\,0.60\\,)$.\n- Test $3$: $(S,K,r,q,\\sigma,T_1,T_2) = (\\,\\$200\\,,\\,\\$200\\,,\\,0.00\\,,\\,0.05\\,,\\,0.15\\,,\\,0.05\\,,\\,0.50\\,)$.\n\nRequired final output format:\n- Your program should produce a single line of output containing a Python-style list of floats with three values per test case in order: $w_2$, the net Gamma, and the net Vega, for each test case in the same order as above. All numbers must be rounded to $10$ decimal places. For example, the overall structure must be of the form $[w_{2,1},\\Gamma_1,\\text{Vega}_1,w_{2,2},\\Gamma_2,\\text{Vega}_2,w_{2,3},\\Gamma_3,\\text{Vega}_3]$ where commas separate entries and there are no extra spaces or text.", "solution": "The problem statement presented is valid. It is scientifically grounded within the established framework of the Black–Scholes model, is mathematically well-posed, and is formulated with objective, unambiguous language. All necessary parameters are provided, and there are no internal contradictions. We may therefore proceed with a rigorous solution.\n\nThe problem requires constructing a Vega-neutral portfolio of two European call options and then determining its net Gamma. The pricing and risk measurement of these options are governed by the Black–Scholes model. The value of a European call option, $C$, depends on the underlying asset price $S$, strike price $K$, time to maturity $T$, risk-free interest rate $r$, continuous dividend yield $q$, and volatility $\\sigma$.\n\nThe core of the model revolves around the terms $d_1$ and $d_2$, defined as:\n$$ d_1 = \\frac{\\ln(S/K) + (r - q + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} $$\n$$ d_2 = d_1 - \\sigma\\sqrt{T} $$\nThe option's Gamma, $\\Gamma$, which measures the rate of change of the option's Delta with respect to the underlying price $S$, is given by:\n$$ \\Gamma = \\frac{\\partial^2 C}{\\partial S^2} = \\frac{e^{-qT}\\phi(d_1)}{S\\sigma\\sqrt{T}} $$\nThe option's Vega, $\\mathcal{V}$, which measures the sensitivity of the option's value to a change in volatility $\\sigma$, is given by:\n$$ \\mathcal{V} = \\frac{\\partial C}{\\partial \\sigma} = S e^{-qT} \\sqrt{T} \\phi(d_1) $$\nIn these formulae, $\\phi(x)$ denotes the probability density function (PDF) of the standard normal distribution, $\\phi(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}$.\n\nThe portfolio consists of two European call options on the same underlying asset with a common strike price $K$ but different maturities, $T_1$ and $T_2$, where $T_1 < T_2$. The weight of the short-dated option (maturity $T_1$) is fixed at $w_1 = 1$. The weight of the long-dated option (maturity $T_2$) is $w_2$.\n\nThe net Gamma, $\\Gamma_P$, and net Vega, $\\mathcal{V}_P$, of the portfolio are linear combinations of the individual option greeks:\n$$ \\Gamma_P = w_1\\Gamma_1 + w_2\\Gamma_2 $$\n$$ \\mathcal{V}_P = w_1\\mathcal{V}_1 + w_2\\mathcal{V}_2 $$\nHere, $(\\Gamma_1, \\mathcal{V}_1)$ are the greeks for the option with maturity $T_1$, and $(\\Gamma_2, \\mathcal{V}_2)$ are the greeks for the option with maturity $T_2$.\n\nThe primary objective is to make the portfolio Vega-neutral, which means setting its net Vega to zero. Given $w_1 = 1$, we impose the condition:\n$$ \\mathcal{V}_P = 1 \\cdot \\mathcal{V}_1 + w_2\\mathcal{V}_2 = 0 $$\nFor any European option with $T > 0$, Vega ($\\mathcal{V}$) is strictly positive. Since both $T_1$ and $T_2$ are positive, $\\mathcal{V}_2 > 0$, and we can uniquely solve for the weight $w_2$:\n$$ w_2 = -\\frac{\\mathcal{V}_1}{\\mathcal{V}_2} $$\nThis weight $w_2$ represents the number of units of the long-dated call option that must be shorted to offset the Vega of one long unit of the short-dated call option.\n\nOnce $w_2$ is determined, we can compute the resulting net Gamma of this Vega-neutral portfolio:\n$$ \\Gamma_P = \\Gamma_1 + w_2\\Gamma_2 = \\Gamma_1 - \\left(\\frac{\\mathcal{V}_1}{\\mathcal{V}_2}\\right)\\Gamma_2 $$\nThe net Vega of the portfolio under this construction is, by definition, exactly zero. A numerical computation may yield a value close to zero due to floating-point precision limitations, which is an expected artifact.\n\nThe algorithm proceeds as follows:\n$1$. For each set of parameters $(S, K, r, q, \\sigma, T_1, T_2)$ from the test suite, we will first compute the Gamma and Vega for each of the two options. This involves calculating the respective $d_1$ term and then applying the $\\Gamma$ and $\\mathcal{V}$ formulas.\n$2$. Using the computed Vegas, $\\mathcal{V}_1$ and $\\mathcal{V}_2$, we determine the weight $w_2 = -\\mathcal{V}_1 / \\mathcal{V}_2$.\n$3$. We then calculate the portfolio's net Gamma, $\\Gamma_P = \\Gamma_1 + w_2\\Gamma_2$.\n$4$. The resulting net Vega will be calculated as $\\mathcal{V}_P = \\mathcal{V}_1 + w_2\\mathcal{V}_2$ to confirm it is zero.\n$5$. The triplet $(w_2, \\Gamma_P, \\mathcal{V}_P)$ is then stored for each test case.\n$6$. Finally, all results are collected, formatted to the required precision, and printed in the specified single-line format.\nThis procedure will be implemented in a self-contained Python program, utilizing `numpy` for numerical calculations and `scipy.stats.norm` for the standard normal PDF.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the weight w2 for a Vega-neutral portfolio of two European call options,\n    and the resulting portfolio's net Gamma and net Vega.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S, K, r, q, sigma, T1, T2)\n        (100.0, 100.0, 0.02, 0.00, 0.20, 0.25, 1.00),\n        (50.0, 50.0, 0.01, 0.03, 0.35, 0.10, 0.60),\n        (200.0, 200.0, 0.00, 0.05, 0.15, 0.05, 0.50),\n    ]\n\n    results = []\n\n    def calculate_greeks(S, K, T, r, q, sigma):\n        \"\"\"\n        Calculates the Gamma and Vega of a European call option using Black-Scholes formulas.\n\n        Args:\n            S (float): Spot price of the underlying asset.\n            K (float): Strike price of the option.\n            T (float): Time to maturity in years.\n            r (float): Risk-free interest rate (decimal).\n            q (float): Continuous dividend yield (decimal).\n            sigma (float): Volatility of the underlying asset (decimal).\n\n        Returns:\n            tuple: A tuple containing the option's Gamma and Vega.\n        \"\"\"\n        # Ensure T > 0 to avoid division by zero\n        if T <= 0:\n            return 0.0, 0.0\n\n        sigma_sqrt_T = sigma * np.sqrt(T)\n        \n        # d1 calculation\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma**2) * T) / sigma_sqrt_T\n        \n        # Standard normal probability density function (PDF)\n        phi_d1 = norm.pdf(d1)\n        \n        # Gamma formula\n        gamma = np.exp(-q * T) * phi_d1 / (S * sigma_sqrt_T)\n        \n        # Vega formula\n        vega = S * np.exp(-q * T) * np.sqrt(T) * phi_d1\n        \n        return gamma, vega\n\n    # Process each test case\n    for S, K, r, q, sigma, T1, T2 in test_cases:\n        # Calculate greeks for the short-dated option (T1)\n        gamma1, vega1 = calculate_greeks(S, K, T1, r, q, sigma)\n        \n        # Calculate greeks for the long-dated option (T2)\n        gamma2, vega2 = calculate_greeks(S, K, T2, r, q, sigma)\n        \n        # Determine weight w2 for Vega neutrality (w1 is fixed at 1)\n        # The equation is V_p = 1*vega1 + w2*vega2 = 0\n        w2 = -vega1 / vega2\n        \n        # Calculate the net Gamma of the portfolio\n        net_gamma = gamma1 + w2 * gamma2\n        \n        # Calculate the net Vega of the portfolio (should be zero by construction)\n        net_vega = vega1 + w2 * vega2\n        \n        # Append the results for the current test case\n        results.extend([w2, net_gamma, net_vega])\n\n    # Format the results to 10 decimal places and join into a single string\n    formatted_results = [f\"{x:.10f}\" for x in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "A key limitation of the basic Black-Scholes-Merton model is its assumption of constant volatility, which contradicts the widely observed \"volatility smile\" in markets. This advanced practice moves beyond textbook examples to confront a real-world modeling challenge. You will quantify the pricing inaccuracies and hedging errors that arise from using a simplified, single at-the-money volatility, thereby demonstrating the critical importance of more sophisticated models for accurate risk management [@problem_id:2416891].", "id": "2416891", "problem": "You are given a market with a single underlying asset and European call options. Assume the unique no-arbitrage value of a European option equals its risk-neutral expectation when the underlying follows a geometric Brownian motion with constant volatility parameter equal to the option’s input implied volatility, a continuously compounded risk-free rate, and zero continuous dividend yield. For each option, define its sensitivities (the “Greeks”) as the corresponding partial derivatives of its value with respect to the defined inputs: the delta is the partial derivative with respect to the underlying’s spot price, the gamma is the second partial derivative with respect to the underlying’s spot price, the vega is the partial derivative with respect to the input volatility, the theta is the negative partial derivative with respect to the time to maturity, and the rho is the partial derivative with respect to the risk-free rate. Consider the following common approximation practice: compute all option prices and Greeks using a single at-the-money implied volatility for all strikes, instead of using a strike-dependent implied volatility smile.\n\nThe underlying has current price $S_0 = 100$, the continuously compounded risk-free rate is $r = 0.02$ per year, the continuous dividend yield is zero, and each option has time to maturity $T = 0.5$ years. The strike set is $K \\in \\{70,85,100,115,130\\}$. A parametric implied volatility smile maps each strike $K$ to an implied volatility $\\sigma(K)$ via\n$$\n\\sigma(K) \\;=\\; a \\;+\\; b \\,\\ln\\!\\big(K/S_0\\big) \\;+\\; c \\,\\big(\\ln\\!\\big(K/S_0\\big)\\big)^2.\n$$\nFor each test case, the at-the-money (ATM) implied volatility is $\\sigma_{\\text{ATM}} = \\sigma(S_0)$, and two valuation-and-Greeks approaches are considered:\n- Full-smile approach: for each $K$, use $\\sigma(K)$ specific to that strike.\n- ATM-only approach: for each $K$, use $\\sigma_{\\text{ATM}}$ for all strikes.\n\nDefine the “true” valuation for any option at a given state to be the unique no-arbitrage value under the above geometric Brownian motion with the state’s strike-specific implied volatility according to the smile. For hedging, consider a single-step delta hedge: at time $t=0$ for a given $K$, short one call option and buy $\\Delta$ units of the underlying, where $\\Delta$ is computed at $t=0$ according to one of the two approaches. After the following scenario shock, unwind the position to compute the hedging profit-and-loss.\n\nThe scenario shock is the same for every test case:\n- Underlying price changes to $S_1 = S_0 \\times (1 + u)$ with $u = 0.01$.\n- The implied volatility smile undergoes a parallel shift by $d v = 0.01$, so the new implied volatility at strike $K$ is $\\sigma'(K) = \\sigma(K) + d v$.\n- Time passes by $\\Delta t = 1/252$ years so the maturity becomes $T' = T - \\Delta t$.\n\nFor each test case below, do the following for the fixed strike set $K \\in \\{70,85,100,115,130\\}$:\n1. Compute the root-mean-square pricing error at time $t=0$ when using the ATM-only approach relative to the full-smile approach, namely\n$$\n\\text{RMSE} \\;=\\; \\sqrt{\\frac{1}{5} \\sum_{K} \\big( V_{\\text{ATM}}(S_0,K,T,r,\\sigma_{\\text{ATM}}) - V_{\\text{smile}}(S_0,K,T,r,\\sigma(K)) \\big)^2 }.\n$$\n2. Compute the average absolute delta-hedged profit-and-loss over the scenario shock for each hedging approach. For a given strike $K$, define\n$$\n\\text{PnL}_{\\text{method}}(K) \\;=\\; V_{\\text{true}}(S_1,K,T',r,\\sigma'(K)) \\;-\\; V_{\\text{true}}(S_0,K,T,r,\\sigma(K)) \\;-\\; \\Delta_{\\text{method}}(S_0,K,T,r,\\cdot)\\,\\big(S_1 - S_0\\big),\n$$\nwhere $V_{\\text{true}}(\\cdot)$ is the “true” valuation using the strike’s implied volatility from the smile at the corresponding time, $\\Delta_{\\text{method}}$ is the delta computed at $t=0$ under either the ATM-only approach (use $\\sigma_{\\text{ATM}}$ for all $K$) or the full-smile approach (use $\\sigma(K)$ for each $K$), and the dot $\\cdot$ denotes the implied volatility input appropriate to the method. Let\n$$\n\\overline{A}_{\\text{ATM}} \\;=\\; \\frac{1}{5} \\sum_{K} \\big|\\text{PnL}_{\\text{ATM}}(K)\\big|,\\qquad\n\\overline{A}_{\\text{smile}} \\;=\\; \\frac{1}{5} \\sum_{K} \\big|\\text{PnL}_{\\text{smile}}(K)\\big|.\n$$\nReport the ratio\n$$\nR \\;=\\; \\frac{\\overline{A}_{\\text{ATM}}}{\\overline{A}_{\\text{smile}}}.\n$$\n\nTest suite of smile parameters $(a,b,c)$:\n- Case $1$: $(a,b,c) = (0.2,\\,0.0,\\,0.0)$.\n- Case $2$: $(a,b,c) = (0.2,\\,-0.05,\\,0.0)$.\n- Case $3$: $(a,b,c) = (0.2,\\,-0.05,\\,0.15)$.\n\nYour program must compute, for each case in the given order, the pair $[\\text{RMSE}, R]$ as real numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets and ordered by the above cases, where each case’s result is itself a two-element comma-separated list enclosed in square brackets. For example, the required output format is\n$[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$,\nwhere $x_i$ and $y_i$ are the required floats for case $i$. No additional text should be printed.", "solution": "The problem is valid. It is a well-defined quantitative finance problem grounded in the standard Black-Scholes-Merton framework for option pricing and hedging. All parameters, models, and calculation procedures are specified unambiguously.\n\nThe solution requires the evaluation of pricing and hedging performance degradation when a simplified volatility model (constant at-the-money volatility) is used instead of a more realistic, strike-dependent volatility smile. This will be performed for three different smile parameterizations.\n\nThe core of the analysis rests upon the Black-Scholes-Merton (BSM) model for a European call option. Under the problem's stated assumptions (geometric Brownian motion, constant risk-free rate, no dividends), the price $V_c$ of a European call option is given by:\n$$ V_c(S, K, T, r, \\sigma) = S N(d_1) - K e^{-rT} N(d_2) $$\nwhere $S$ is the spot price of the underlying asset, $K$ is the strike price, $T$ is the time to maturity in years, $r$ is the continuously compounded risk-free rate, and $\\sigma$ is the volatility. The function $N(\\cdot)$ is the cumulative distribution function (CDF) of the standard normal distribution. The terms $d_1$ and $d_2$ are defined as:\n$$ d_1 = \\frac{\\ln(S/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} $$\n$$ d_2 = d_1 - \\sigma\\sqrt{T} $$\nThe delta ($\\Delta$) of the call option, which represents the sensitivity of the option price to a change in the underlying's price, is the first partial derivative of $V_c$ with respect to $S$:\n$$ \\Delta = \\frac{\\partial V_c}{\\partial S} = N(d_1) $$\nThis quantity is central to constructing a delta-neutral hedge.\n\nThe problem defines a parametric volatility smile as a function of the strike price $K$:\n$$ \\sigma(K) \\;=\\; a \\;+\\; b \\,\\ln\\!\\big(K/S_0\\big) \\;+\\; c \\,\\big(\\ln\\!\\big(K/S_0\\big)\\big)^2. $$\n\nThe solution proceeds by executing the required calculations for each of the three test cases $(a,b,c)$.\n\n**Step 1: Calculate Root-Mean-Square Pricing Error (RMSE)**\n\nAt the initial time $t=0$, we have $S_0 = 100$, $r = 0.02$, and $T = 0.5$. For each strike $K \\in \\{70, 85, 100, 115, 130\\}$:\n1.  The \"full-smile\" volatility $\\sigma(K)$ is calculated using the given parameters $(a,b,c)$. The corresponding \"true\" price is $V_{\\text{smile}}(S_0,K,T,r,\\sigma(K)) = V_c(S_0,K,T,r,\\sigma(K))$.\n2.  The \"ATM-only\" volatility is constant for all strikes: $\\sigma_{\\text{ATM}} = \\sigma(S_0) = a$. The approximate price is $V_{\\text{ATM}}(S_0,K,T,r,\\sigma_{\\text{ATM}}) = V_c(S_0,K,T,r,a)$.\n3.  The RMSE is then computed across the set of five strikes according to the provided formula:\n    $$ \\text{RMSE} \\;=\\; \\sqrt{\\frac{1}{5} \\sum_{K} \\big( V_{\\text{ATM}}(K) - V_{\\text{smile}}(K) \\big)^2 } $$\n\n**Step 2: Calculate Hedging Performance Ratio (R)**\n\nThis step analyzes the profit-and-loss (PnL) of a one-step delta hedge under a specified market shock.\nThe initial portfolio at $t=0$ consists of a short position in one call option and a long position of $\\Delta$ shares of the underlying, where $\\Delta$ is computed at $t=0$. The value of this portfolio is $P_0 = \\Delta S_0 - V_0$.\n\nAfter the shock, at time $t_1$, the new market state is:\n-   Underlying Price: $S_1 = S_0 (1+u) = 100 \\times (1+0.01) = 101$.\n-   Time to Maturity: $T' = T - \\Delta t = 0.5 - 1/252$.\n-   New Volatility Smile: $\\sigma'(K) = \\sigma(K) + dv = \\sigma(K) + 0.01$.\n\nThe \"true\" value of the option at $t_1$ is $V_{\\text{true},1}(K) = V_c(S_1, K, T', r, \\sigma'(K))$. The value of the hedging portfolio at $t_1$ is $P_1 = \\Delta S_1 - V_{\\text{true},1}(K)$.\nThe PnL over the period is $P_1 - P_0 = (\\Delta S_1 - V_{\\text{true},1}(K)) - (\\Delta S_0 - V_0) = V_0 - V_{\\text{true},1}(K) + \\Delta(S_1 - S_0)$, which is the negative of the formula provided in the problem. The sign convention does not affect the average absolute PnL. We will use the formula as given:\n$$ \\text{PnL}(K) = V_{\\text{true},1}(K) - V_{0}(K) - \\Delta(K)(S_1 - S_0) $$\nwhere $V_0(K)$ is the \"true\" price at $t=0$, i.e., $V_{\\text{smile}}(K)$.\n\nTwo different hedging strategies are compared:\n1.  **ATM-only Hedge**: $\\Delta_{\\text{method}} = \\Delta_{\\text{ATM}}(K) = N(d_1)$ calculated using $\\sigma_{\\text{ATM}} = a$. The corresponding PnL is $\\text{PnL}_{\\text{ATM}}(K)$.\n2.  **Full-smile Hedge**: $\\Delta_{\\text{method}} = \\Delta_{\\text{smile}}(K) = N(d_1)$ calculated using $\\sigma(K)$. The corresponding PnL is $\\text{PnL}_{\\text{smile}}(K)$.\n\nFor each strategy, the average absolute PnL is computed:\n$$ \\overline{A}_{\\text{ATM}} = \\frac{1}{5} \\sum_{K} |\\text{PnL}_{\\text{ATM}}(K)| \\quad \\text{and} \\quad \\overline{A}_{\\text{smile}} = \\frac{1}{5} \\sum_{K} |\\text{PnL}_{\\text{smile}}(K)| $$\nFinally, the ratio $R$ is determined:\n$$ R = \\frac{\\overline{A}_{\\text{ATM}}}{\\overline{A}_{\\text{smile}}} $$\nThis ratio quantifies the increase in average hedging error resulting from the use of the simplified ATM-only volatility model. A value of $R=1$ implies no difference in performance, while $R>1$ indicates the ATM-only model is inferior for hedging. For Case $1$, where the smile is flat ($b=c=0$), we expect $\\sigma(K) = \\sigma_{\\text{ATM}}$, leading to $\\text{RMSE}=0$ and $R=1$.\n\nThe algorithm will be implemented in Python using `numpy` for efficient array operations and `scipy.stats.norm` for the standard normal CDF.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef bsm_call_price(S, K, T, r, sigma):\n    \"\"\"\n    Computes European call option price using the Black-Scholes-Merton model.\n    Vectorized to handle numpy arrays.\n    \"\"\"\n    # Defensive programming to avoid division by zero or log of non-positive\n    # This is important for very small T or sigma\n    d1 = np.full_like(S, np.inf, dtype=float)\n    d2 = np.full_like(S, np.inf, dtype=float)\n    \n    valid_mask = (sigma > 1e-9) & (T > 1e-9)\n    \n    sigma_sqrt_T = sigma[valid_mask] * np.sqrt(T)\n    d1[valid_mask] = (np.log(S[valid_mask] / K[valid_mask]) + (r + 0.5 * sigma[valid_mask]**2) * T) / sigma_sqrt_T\n    d2[valid_mask] = d1[valid_mask] - sigma_sqrt_T\n    \n    price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef bsm_call_delta(S, K, T, r, sigma):\n    \"\"\"\n    Computes European call option delta using the Black-Scholes-Merton model.\n    Vectorized to handle numpy arrays.\n    \"\"\"\n    # Defensive programming similar to price function\n    d1 = np.full_like(S, np.inf, dtype=float)\n    \n    valid_mask = (sigma > 1e-9) & (T > 1e-9)\n\n    sigma_sqrt_T = sigma[valid_mask] * np.sqrt(T)\n    d1[valid_mask] = (np.log(S[valid_mask] / K[valid_mask]) + (r + 0.5 * sigma[valid_mask]**2) * T) / sigma_sqrt_T\n    \n    delta = norm.cdf(d1)\n    return delta\n\ndef solve():\n    \"\"\"\n    Main solver function to compute RMSE and hedging performance ratio R\n    for the given test cases.\n    \"\"\"\n    # Market and scenario parameters\n    S0 = 100.0\n    r = 0.02\n    T0 = 0.5\n    strikes = np.array([70.0, 85.0, 100.0, 115.0, 130.0])\n    num_strikes = len(strikes)\n\n    u_shock = 0.01\n    dv_shock = 0.01\n    dt_shock = 1.0 / 252.0\n\n    # Post-shock state\n    S1 = S0 * (1.0 + u_shock)\n    T1 = T0 - dt_shock\n    delta_S = S1 - S0\n\n    # Test suite of smile parameters\n    test_cases = [\n        (0.2, 0.0, 0.0),    # Case 1: Flat smile\n        (0.2, -0.05, 0.0),  # Case 2: Linear smile (skew)\n        (0.2, -0.05, 0.15), # Case 3: Quadratic smile (skew and convexity)\n    ]\n\n    results = []\n    \n    # Broadcast S0 and T0 to match the shape of strikes for vectorized calculations\n    S0_vec = np.full_like(strikes, S0)\n    S1_vec = np.full_like(strikes, S1)\n\n    for a, b, c in test_cases:\n        # --- Time t=0 calculations ---\n        \n        # Volatility calculations\n        log_moneyness = np.log(strikes / S0)\n        sigma_smile_t0 = a + b * log_moneyness + c * log_moneyness**2\n        sigma_atm_t0 = a  # This is a scalar\n        sigma_atm_t0_vec = np.full_like(strikes, sigma_atm_t0)\n\n        # 1. Compute RMSE\n        v_smile_t0 = bsm_call_price(S0_vec, strikes, T0, r, sigma_smile_t0)\n        v_atm_t0 = bsm_call_price(S0_vec, strikes, T0, r, sigma_atm_t0_vec)\n        \n        rmse = np.sqrt(np.mean((v_atm_t0 - v_smile_t0)**2))\n        \n        # --- Hedging PnL calculations ---\n\n        # Deltas at t=0\n        delta_smile_t0 = bsm_call_delta(S0_vec, strikes, T0, r, sigma_smile_t0)\n        delta_atm_t0 = bsm_call_delta(S0_vec, strikes, T0, r, sigma_atm_t0_vec)\n\n        # \"True\" option value at t=1 (post-shock)\n        sigma_smile_t1 = sigma_smile_t0 + dv_shock\n        v_true_t1 = bsm_call_price(S1_vec, strikes, T1, r, sigma_smile_t1)\n        \n        # PnL for both hedging methods\n        # The true initial value is always the smile value\n        v_true_t0 = v_smile_t0 \n        \n        pnl_smile = v_true_t1 - v_true_t0 - delta_smile_t0 * delta_S\n        pnl_atm = v_true_t1 - v_true_t0 - delta_atm_t0 * delta_S\n        \n        # Average absolute PnLs\n        avg_abs_pnl_smile = np.mean(np.abs(pnl_smile))\n        avg_abs_pnl_atm = np.mean(np.abs(pnl_atm))\n\n        # 2. Compute Ratio R\n        # Handle the theoretical case of zero denominator, though unlikely here\n        if avg_abs_pnl_smile < 1e-12:\n            ratio_R = 1.0 if avg_abs_pnl_atm < 1e-12 else np.inf\n        else:\n            ratio_R = avg_abs_pnl_atm / avg_abs_pnl_smile\n            \n        results.append([rmse, ratio_R])\n    \n    # Format the output as specified: [[x1,y1],[x2,y2],[x3,y3]]\n    output_str = \"[\" + \",\".join([f\"[{x:.8f},{y:.8f}]\" for x, y in results]) + \"]\"\n    print(output_str)\n\n\nsolve()\n```"}]}