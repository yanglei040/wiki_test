{"hands_on_practices": [{"introduction": "The Black-Scholes-Merton formula is celebrated as the analytical solution to a specific partial differential equation (PDE). This exercise demystifies the PDE by guiding you to solve it numerically using the robust Crank-Nicolson finite difference method [@problem_id:2387926]. By building a solver from the ground up, you will gain a profound appreciation for how an option's value evolves through time and asset price, thereby deriving the price computationally and confirming the stability of this powerful numerical technique.", "id": "2387926", "problem": "Consider a frictionless market with a risky asset whose price process is denoted by $S_t$ and a money market account earning a continuously compounded risk-free rate $r$. Assume that, under the risk-neutral probability measure, the risky asset follows a geometric Brownian motion $dS_t = r S_t \\, dt + \\sigma S_t \\, dW_t$, where $\\sigma &gt; 0$ is constant volatility and $W_t$ is a standard Brownian motion. Let $V(S,t)$ denote the time-$t$ value of a European call option with strike $K$ and maturity $T$. By no-arbitrage and replication, $V(S,t)$ satisfies the Black-Scholes-Merton partial differential equation $V_t + \\tfrac{1}{2} \\sigma^2 S^2 V_{SS} + r S V_S - r V = 0$ for $S \\in (0,\\infty)$ and $t \\in [0,T)$. The terminal condition is $V(S,T) = \\max(S-K,0)$. On a truncated spatial domain $S \\in [0,S_{\\max}]$ with $S_{\\max} \\gg K$, impose boundary conditions $V(0,t) = 0$ and $V(S_{\\max},t) \\approx S_{\\max} - K e^{-r (T-t)}$ for $t \\in [0,T]$.\n\nYour task is to write a complete and runnable program that, starting from the fundamental no-arbitrage principle and the Black-Scholes-Merton partial differential equation, computes a numerical solution on a uniform space-time grid and demonstrates unconditional stability empirically by using very large time steps. The program must:\n\n- Construct a consistent finite-difference approximation that is second order accurate in both time and space on the domain $S \\in [0,S_{\\max}]$ and $\\tau \\in [0,T]$, where $\\tau = T - t$ is the time-to-maturity variable. The initial condition at $\\tau = 0$ is $V(S,0) = \\max(S-K,0)$. The boundary conditions are $V(0,\\tau) = 0$ and $V(S_{\\max},\\tau) = S_{\\max} - K e^{-r \\tau}$ for $\\tau \\in [0,T]$.\n- Price a European call at a given initial underlying value $S_0$ by linearly interpolating the grid solution $V(S,\\tau)$ at $\\tau = T$. All rates must be expressed as decimals, not with a percentage sign. All prices must be reported in the same arbitrary monetary unit as $S$ and $K$.\n- Quantitatively assess the numerical error by comparing the numerical price to the analytical Black-Scholes-Merton value $C_{\\text{BSM}}(S_0,K,r,\\sigma,T)$ and reporting the absolute error as a floating-point number.\n- Empirically demonstrate unconditional stability by running the scheme with very large time steps (very small numbers of time levels) while keeping the spatial grid fixed and verifying that the numerical solution remains bounded between $0$ and $S_{\\max}$ at all time levels and nodes.\n\nUse the following common parameter values: $S_0 = 100$, $K = 100$, $r = 0.05$, $\\sigma = 0.2$, $T = 1$, $S_{\\max} = 500$. Use a uniform spatial grid with $M$ subintervals (so $M+1$ spatial nodes), and a uniform temporal grid in $\\tau$ with $N$ subintervals (so $N+1$ time levels including $\\tau=0$ and $\\tau=T$).\n\nTest suite. Your program must run the following four test cases and aggregate the results as specified:\n- Test case $1$ (happy path accuracy): $(M,N) = (400,400)$. Output the absolute error $|C_{\\text{num}} - C_{\\text{BSM}}|$ as a floating-point number.\n- Test case $2$ (extremely large time step): $(M,N) = (400,4)$. Output the absolute error $|C_{\\text{num}} - C_{\\text{BSM}}|$ as a floating-point number.\n- Test case $3$ (coarser space-time grid): $(M,N) = (100,100)$. Output the absolute error $|C_{\\text{num}} - C_{\\text{BSM}}|$ as a floating-point number.\n- Test case $4$ (empirical unconditional stability check): Fix $M = 400$ and run with $N \\in \\{1,2,4,8,16,32,64\\}$. Let the stability indicator be the boolean that is true if and only if for every $N$ in this set, at every time level and every spatial node, all computed values are finite and lie within $[0,S_{\\max}]$ up to a tolerance of $10^{-8}$, and false otherwise. Output this boolean.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order: test case $1$ absolute error, test case $2$ absolute error, test case $3$ absolute error, and test case $4$ stability boolean. For example, a syntactically correct output line is of the form $[0.001234,0.056789,0.012345,True]$.", "solution": "The problem statement constitutes a well-posed initial-boundary value problem from computational finance. It is scientifically grounded in the Black-Scholes-Merton no-arbitrage framework and provides a complete and consistent set of parameters, initial conditions, and boundary conditions for a numerical solution. The problem is therefore valid, and we proceed to construct the required numerical method and program.\n\nThe fundamental equation is the Black-Scholes-Merton partial differential equation (PDE) for the value of a European option, $V(S,t)$:\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\nThis is a final value problem with the terminal condition at time $t=T$ given by the option's payoff function, $V(S,T) = \\max(S-K, 0)$. To transform this into a standard initial value problem, we introduce the time-to-maturity variable $\\tau = T - t$. The derivatives transform as $\\frac{\\partial}{\\partial t} = \\frac{\\partial \\tau}{\\partial t} \\frac{\\partial}{\\partial \\tau} = - \\frac{\\partial}{\\partial \\tau}$. Substituting this into the PDE yields:\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\nThis is a forward diffusion-convection-reaction equation in $\\tau$, which we must solve from $\\tau=0$ to $\\tau=T$. The initial condition at $\\tau=0$ is $V(S,0) = \\max(S-K,0)$.\n\nThe problem requires a numerical scheme that is second-order accurate in both space and time and is unconditionally stable. The Crank-Nicolson finite difference method possesses these properties. We discretize the domain $(S, \\tau) \\in [0, S_{\\max}] \\times [0, T]$ on a uniform grid. Let $S_j = j \\Delta S$ for $j=0, 1, \\dots, M$, where $\\Delta S = S_{\\max}/M$. Let $\\tau_i = i \\Delta \\tau$ for $i=0, 1, \\dots, N$, where $\\Delta \\tau = T/N$. Let $V_j^i$ be the numerical approximation of $V(S_j, \\tau_i)$.\n\nWe approximate the spatial derivatives using second-order central differences:\n$$\n\\frac{\\partial V}{\\partial S} \\bigg|_{S_j,\\tau_i} \\approx \\frac{V_{j+1}^i - V_{j-1}^i}{2 \\Delta S}\n$$\n$$\n\\frac{\\partial^2 V}{\\partial S^2} \\bigg|_{S_j,\\tau_i} \\approx \\frac{V_{j+1}^i - 2V_j^i + V_{j-1}^i}{(\\Delta S)^2}\n$$\nLet $\\mathcal{L}$ be the spatial differential operator on the right-hand side of the transformed PDE. The Crank-Nicolson scheme approximates the PDE as:\n$$\n\\frac{V_j^{i+1} - V_j^i}{\\Delta \\tau} = \\frac{1}{2} \\left[ (\\mathcal{L} V^i)_j + (\\mathcal{L} V^{i+1})_j \\right]\n$$\nRearranging terms separates the unknowns at time level $i+1$ from the knowns at level $i$:\n$$\n\\left(I - \\frac{\\Delta \\tau}{2} \\mathcal{L}_d\\right) V^{i+1} = \\left(I + \\frac{\\Delta \\tau}{2} \\mathcal{L}_d\\right) V^i\n$$\nwhere $\\mathcal{L}_d$ is the discretized spatial operator. This equation represents a system of linear equations for the vector of option values $V^{i+1}$ at the interior spatial nodes $j=1, \\dots, M-1$. The system is tridiagonal. The general equation for an interior node $j$ is:\n$$\nl_j V_{j-1}^{i+1} + d_j V_j^{i+1} + u_j V_{j+1}^{i+1} = l'_j V_{j-1}^i + d'_j V_j^i + u'_j V_{j+1}^i\n$$\nwhere the coefficients are derived by substituting the finite difference approximations into the operator $\\mathcal{L}$. For $S_j=j\\Delta S$, they simplify to:\n$$\nl_j = -\\frac{\\Delta \\tau}{4}(\\sigma^2 j^2 - rj)\n$$\n$$\nd_j = 1 + \\frac{\\Delta \\tau}{2}(\\sigma^2 j^2 + r)\n$$\n$$\nu_j = -\\frac{\\Delta \\tau}{4}(\\sigma^2 j^2 + rj)\n$$\nThe coefficients on the right-hand side are $l'_j = -l_j$, $d'_j = 2 - d_j$, and $u'_j = -u_j$.\n\nAt each time step $i \\to i+1$, we solve the tridiagonal system $A V^{i+1} = \\mathbf{b}$, where $A$ is the matrix with diagonals $(l_j, d_j, u_j)$ and $\\mathbf{b}$ is the vector computed from the right-hand side.\nThe boundary conditions must be incorporated.\nThe condition $V(0, \\tau) = 0$ implies $V_0^i = 0$ for all $i$. This means the first equation of the system (for $j=1$) involves no unknown boundary terms.\nThe condition $V(S_{\\max}, \\tau) = S_{\\max} - Ke^{-r\\tau}$ provides known values for $V_M^i$ at each time step. The term $u_{M-1} V_M^{i+1}$ from the last equation of the system (for $j=M-1$) is known and moved to the right-hand side. The right-hand-side vector $\\mathbf{b}$ is thus modified accordingly before solving the system.\n\nThe procedure is as follows:\n1. Initialize the grid solution at $\\tau=0$ with $V_j^0 = \\max(j\\Delta S - K, 0)$.\n2. For each time step $i$ from $0$ to $N-1$:\n    a. Construct the right-hand-side vector $\\mathbf{b}$ using values from $V^i$.\n    b. Adjust the last element of $\\mathbf{b}$ to account for the boundary condition at $S_{\\max}$.\n    c. Solve the tridiagonal system $A V_{\\text{interior}}^{i+1} = \\mathbf{b}$ for the interior node values $V_1^{i+1}, \\dots, V_{M-1}^{i+1}$. A banded matrix solver is efficient for this.\n    d. Update the full solution vector $V^{i+1}$ with the computed interior values and the boundary values for $\\tau_{i+1}$.\n3. After completing all time steps, the vector $V^N$ contains the option prices at $\\tau=T$ (i.e., time $t=0$).\n4. Linearly interpolate the values in $V^N$ at the specified initial stock price $S_0$ to obtain the final numerical price $C_{\\text{num}}$.\n5. Compute the absolute error $|C_{\\text{num}} - C_{\\text{BSM}}|$, where $C_{\\text{BSM}}$ is the analytical price from the Black-Scholes-Merton formula:\n$$C(S, K, r, \\sigma, T) = S_0 N(d_1) - K e^{-rT} N(d_2)$$\n$$d_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}, \\quad d_2 = d_1 - \\sigma\\sqrt{T}$$\nwhere $N(\\cdot)$ is the cumulative distribution function of the standard normal distribution.\n6. For the stability test, the values of $V_j^i$ at all nodes and time steps are checked to ensure they remain finite and within the no-arbitrage bounds $[0, S_{\\max}]$. The unconditional stability of the Crank-Nicolson scheme ensures this holds even for large $\\Delta \\tau$ (small $N$).\n\nThis systematic procedure is implemented in the provided program to solve the given test cases.", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Common parameters as specified in the problem\n    S0 = 100.0\n    K = 100.0\n    r = 0.05\n    SIGMA = 0.2\n    T = 1.0\n    S_MAX = 500.0\n\n    def bsm_analytical_price(s, k, rate, sigma, time):\n        \"\"\"Calculates the analytical Black-Scholes-Merton price for a European call.\"\"\"\n        if time == 0:\n            return np.maximum(s - k, 0)\n        d1 = (np.log(s / k) + (rate + 0.5 * sigma**2) * time) / (sigma * np.sqrt(time))\n        d2 = d1 - sigma * np.sqrt(time)\n        price = s * norm.cdf(d1) - k * np.exp(-rate * time) * norm.cdf(d2)\n        return price\n\n    def solve_crank_nicolson(s0, k, rate, sigma, time, s_max, M, N, stability_check=False, tol=1e-8):\n        \"\"\"\n        Solves the Black-Scholes PDE using the Crank-Nicolson finite difference method.\n\n        If stability_check is True, it returns a boolean indicating if the solution\n        remained within bounds [0, s_max] throughout the simulation. Otherwise, it\n        returns the interpolated option price at s0.\n        \"\"\"\n        # Grid setup\n        dS = s_max / M\n        dTau = time / N\n        S_grid = np.linspace(0, s_max, M + 1)\n\n        # Initial condition at tau=0 (which is maturity t=T)\n        V = np.maximum(S_grid - k, 0)\n        \n        if stability_check:\n            if not(np.all(np.isfinite(V)) and np.all((V >= 0 - tol) & (V <= s_max + tol))):\n                return False\n\n        # Coefficients for the tridiagonal system. These are time-independent.\n        j = np.arange(1, M, dtype=np.float64)  # Interior nodes j = 1, ..., M-1\n        \n        # Coefficients for LHS matrix A in A * V_new = b\n        l_j = -0.25 * dTau * (sigma**2 * j**2 - rate * j)\n        d_j = 1.0 + 0.5 * dTau * (sigma**2 * j**2 + rate)\n        u_j = -0.25 * dTau * (sigma**2 * j**2 + rate * j)\n        \n        # LHS matrix A, in banded form for scipy.linalg.solve_banded\n        A = np.zeros((3, M - 1))\n        A[0, 1:] = u_j[:-1]   # Upper diagonal\n        A[1, :] = d_j         # Main diagonal\n        A[2, :-1] = l_j[1:]   # Lower diagonal\n        \n        # Coefficients for RHS matrix B where b = B * V_old\n        l_prime_j = -l_j\n        d_prime_j = 2.0 - d_j\n        u_prime_j = -u_j\n        \n        # Time-stepping loop from tau=0 to tau=T\n        for i in range(N):\n            tau_i_plus_1 = (i + 1) * dTau\n            \n            # Construct RHS vector b = B * V_old\n            rhs_vector = (l_prime_j * V[:-2] + \n                          d_prime_j * V[1:-1] +\n                          u_prime_j * V[2:])\n\n            # Boundary condition adjustments for the RHS vector b\n            bc_upper_i_plus_1 = s_max - k * np.exp(-rate * tau_i_plus_1)\n            rhs_vector[-1] -= u_j[-1] * bc_upper_i_plus_1\n            \n            # Solve the linear system A * V_new = b for interior nodes\n            V_interior_new = solve_banded((1, 1), A, rhs_vector)\n            \n            # Update full solution vector V for the next time step\n            V[1:-1] = V_interior_new\n            V[0] = 0.0  # Lower boundary V(0, t)=0\n            V[-1] = bc_upper_i_plus_1\n            \n            if stability_check:\n                if not (np.all(np.isfinite(V)) and np.all((V >= 0 - tol) & (V <= s_max + tol))):\n                    return False\n                    \n        if stability_check:\n            return True\n\n        # Interpolate to find price at S0 after all time steps\n        numerical_price = np.interp(s0, S_grid, V)\n        return numerical_price\n\n    results = []\n    \n    # Calculate the analytical price once for all comparisons\n    analytical_price = bsm_analytical_price(S0, K, r, SIGMA, T)\n\n    # Test Case 1: (M,N) = (400,400)\n    M1, N1 = 400, 400\n    num_price1 = solve_crank_nicolson(S0, K, r, SIGMA, T, S_MAX, M1, N1)\n    results.append(abs(num_price1 - analytical_price))\n\n    # Test Case 2: (M,N) = (400,4)\n    M2, N2 = 400, 4\n    num_price2 = solve_crank_nicolson(S0, K, r, SIGMA, T, S_MAX, M2, N2)\n    results.append(abs(num_price2 - analytical_price))\n\n    # Test Case 3: (M,N) = (100,100)\n    M3, N3 = 100, 100\n    num_price3 = solve_crank_nicolson(S0, K, r, SIGMA, T, S_MAX, M3, N3)\n    results.append(abs(num_price3 - analytical_price))\n\n    # Test Case 4: Stability Check\n    M4 = 400\n    N_values = [1, 2, 4, 8, 16, 32, 64]\n    overall_stability = True\n    for N_val in N_values:\n        is_stable = solve_crank_nicolson(S0, K, r, SIGMA, T, S_MAX, M4, N_val, stability_check=True)\n        if not is_stable:\n            overall_stability = False\n            break\n    results.append(overall_stability)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "The BSM model is built upon the assumption that stock prices follow a Geometric Brownian Motion, a process described by stochastic calculus. This exercise challenges you to apply Itô's Lemma—a fundamental tool in the derivation of the BSM equation—to compute an option's instantaneous \"beta\" with respect to its underlying asset [@problem_id:2390329]. This practice moves beyond the standard option Greeks to reveal the option's price elasticity, $\\Omega$, thereby reinforcing your intuition for how derivatives dynamically respond to random price fluctuations.", "id": "2390329", "problem": "Consider a frictionless market with a continuously traded underlying stock whose price process is modeled as Geometric Brownian Motion (GBM), that is, $dS_t = \\mu S_t \\, dt + \\sigma S_t \\, dW_t$ for constants $\\,\\mu \\in \\mathbb{R}\\,$ and $\\,\\sigma &gt; 0\\,$, where $W_t$ is a standard Brownian motion. Let $C(S,t)$ denote the time-$t$ price of a European call option with strike $K$ and maturity $T$, written on the stock with continuous dividend yield $q$ and a continuously compounded risk-free rate $r$. The option is the unique no-arbitrage price under the Black–Scholes–Merton framework.\n\nDefine the arithmetic return of the stock over an infinitesimal time interval as $r_S = dS_t / S_t$ and the arithmetic return of the option as $r_C = dC_t / C_t$. Define the instantaneous beta of the option’s return with respect to the stock’s return as\n$$\\beta = \\lim_{\\Delta t \\to 0^+} \\frac{\\operatorname{Cov}\\!\\left(r_C, r_S\\right)}{\\operatorname{Var}\\!\\left(r_S\\right)}.$$\nYour task is to compute, for each parameter set in the test suite below, the instantaneous beta $\\beta$ implied by the model, using exact analytical values for the option price and its sensitivity consistent with the model assumptions. All outputs must be real numbers without any unit conversions or percentage symbols.\n\nTest suite (each case is a tuple $(S, K, r, q, \\sigma, T)$):\n- Case 1 (general, at-the-money): $(100.0, 100.0, 0.01, 0.02, 0.2, 1.0)$.\n- Case 2 (deep in-the-money): $(150.0, 100.0, 0.03, 0.0, 0.25, 2.0)$.\n- Case 3 (deep out-of-the-money): $(50.0, 100.0, 0.01, 0.0, 0.2, 1.0)$.\n- Case 4 (short time-to-maturity, at-the-money): $(100.0, 100.0, 0.0, 0.0, 0.2, 1.0/365.0)$.\n- Case 5 (out-of-the-money with dividends, long maturity): $(100.0, 110.0, 0.05, 0.02, 0.3, 3.0)$.\n\nRequirements:\n- For each case, compute the instantaneous beta $\\beta$ under the stated model and parameters, using the arithmetic return definition above.\n- Express each result as a float rounded to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite (for example, $[x_1,x_2,x_3,x_4,x_5]$). Do not include any additional text or spaces.\n\nNote: Angles are not involved; there are no physical units to report. All numerical answers must be provided as real numbers (for example, use $0.123456$ rather than $12.3456\\%$).", "solution": "The problem requires the computation of the instantaneous beta of a European call option's return with respect to its underlying stock's return. We begin by rigorously deriving the analytical expression for this beta within the Black-Scholes-Merton framework.\n\nThe problem defines the instantaneous beta as:\n$$ \\beta = \\lim_{\\Delta t \\to 0^+} \\frac{\\operatorname{Cov}\\!\\left(r_C, r_S\\right)}{\\operatorname{Var}\\!\\left(r_S\\right)} $$\nwhere $r_S = dS_t / S_t$ and $r_C = dC_t / C_t$ are the arithmetic returns of the stock and option, respectively. This formulation is equivalent to the ratio of the instantaneous rates of covariance and variance.\n\nFirst, we analyze the denominator, which involves the stock's return dynamics. The stock price $S_t$ follows a Geometric Brownian Motion (GBM):\n$$ dS_t = \\mu S_t \\, dt + \\sigma S_t \\, dW_t $$\nThe arithmetic return is therefore:\n$$ r_S = \\frac{dS_t}{S_t} = \\mu \\, dt + \\sigma \\, dW_t $$\nThe variance of this process over an infinitesimal time interval $dt$ is driven solely by the stochastic term. The increment of a standard Brownian motion $dW_t$ is normally distributed with mean $0$ and variance $dt$.\n$$ \\operatorname{Var}(r_S) = \\operatorname{Var}(\\mu \\, dt + \\sigma \\, dW_t) = \\sigma^2 \\operatorname{Var}(dW_t) = \\sigma^2 dt $$\nThe instantaneous variance rate is the coefficient of $dt$, which is $\\sigma^2$. This is the denominator of the expression for $\\beta$.\n\nNext, we analyze the numerator, which involves the option's return dynamics. The option price $C(S,t)$ is a function of the stock price $S$ and time $t$. We apply Itô's Lemma to find the dynamics of $C(S,t)$:\n$$ dC_t = \\frac{\\partial C}{\\partial t} dt + \\frac{\\partial C}{\\partial S} dS_t + \\frac{1}{2} \\frac{\\partial^2 C}{\\partial S^2} (dS_t)^2 $$\nThe quadratic variation term $(dS_t)^2$ is calculated as:\n$$ (dS_t)^2 = (\\mu S_t \\, dt + \\sigma S_t \\, dW_t)^2 = \\sigma^2 S_t^2 (dW_t)^2 = \\sigma^2 S_t^2 dt $$\nHere, we neglect terms of order $dt^{3/2}$ and $dt^2$. Substituting the expressions for $dS_t$ and $(dS_t)^2$ into the Itô expansion for $dC_t$:\n$$ dC_t = \\frac{\\partial C}{\\partial t} dt + \\frac{\\partial C}{\\partial S} (\\mu S_t \\, dt + \\sigma S_t \\, dW_t) + \\frac{1}{2} \\frac{\\partial^2 C}{\\partial S^2} \\sigma^2 S_t^2 dt $$\nGrouping the $dt$ and $dW_t$ terms gives:\n$$ dC_t = \\left( \\frac{\\partial C}{\\partial t} + \\mu S_t \\frac{\\partial C}{\\partial S} + \\frac{1}{2} \\sigma^2 S_t^2 \\frac{\\partial^2 C}{\\partial S^2} \\right) dt + \\left( \\sigma S_t \\frac{\\partial C}{\\partial S} \\right) dW_t $$\nThe arithmetic return of the option is $r_C = dC_t / C_t$:\n$$ r_C = \\frac{1}{C_t} \\left( \\frac{\\partial C}{\\partial t} + \\mu S_t \\frac{\\partial C}{\\partial S} + \\frac{1}{2} \\sigma^2 S_t^2 \\frac{\\partial^2 C}{\\partial S^2} \\right) dt + \\frac{1}{C_t} \\left( \\sigma S_t \\frac{\\partial C}{\\partial S} \\right) dW_t $$\nNow, we compute the covariance between $r_C$ and $r_S$ over the interval $dt$:\n$$ \\operatorname{Cov}(r_C, r_S) = \\operatorname{Cov}\\left( \\frac{1}{C_t} \\sigma S_t \\frac{\\partial C}{\\partial S} dW_t, \\sigma dW_t \\right) $$\nOnly the stochastic components contribute to the covariance.\n$$ \\operatorname{Cov}(r_C, r_S) = \\left( \\frac{1}{C_t} \\sigma S_t \\frac{\\partial C}{\\partial S} \\right) \\cdot \\sigma \\cdot \\operatorname{Var}(dW_t) = \\frac{\\sigma^2 S_t}{C_t} \\frac{\\partial C}{\\partial S} dt $$\nThe instantaneous covariance rate is the coefficient of $dt$: $\\frac{\\sigma^2 S_t}{C_t} \\frac{\\partial C}{\\partial S}$.\n\nWe can now assemble the expression for beta:\n$$ \\beta = \\frac{\\text{Instantaneous Covariance Rate}}{\\text{Instantaneous Variance Rate}} = \\frac{\\frac{\\sigma^2 S_t}{C_t} \\frac{\\partial C}{\\partial S}}{\\sigma^2} $$\nThe $\\sigma^2$ terms cancel, yielding a remarkably simple and elegant result:\n$$ \\beta = \\frac{S_t}{C_t} \\frac{\\partial C}{\\partial S} $$\nThis quantity is also known as the elasticity of the option price with respect to the stock price, often denoted by $\\Omega$. It is the product of the option's delta ($\\Delta_C = \\frac{\\partial C}{\\partial S}$) and the ratio of the stock price to the option price.\n\nTo compute $\\beta$ numerically, we must use the analytical formulas for the Black-Scholes-Merton model, as specified. Let $\\tau = T-t$ be the time to maturity. At time $t=0$, $\\tau=T$. The price of a European call option with a continuous dividend yield $q$ is:\n$$ C(S, t) = S e^{-q \\tau} N(d_1) - K e^{-r \\tau} N(d_2) $$\nThe option's delta is:\n$$ \\Delta_C = \\frac{\\partial C}{\\partial S} = e^{-q \\tau} N(d_1) $$\nwhere $N(\\cdot)$ is the cumulative distribution function (CDF) of the standard normal distribution, and $d_1, d_2$ are given by:\n$$ d_1 = \\frac{\\ln(S/K) + (r - q + \\frac{1}{2}\\sigma^2)\\tau}{\\sigma \\sqrt{\\tau}} $$\n$$ d_2 = d_1 - \\sigma \\sqrt{\\tau} $$\nSubstituting the expressions for $C$ and $\\Delta_C$ into our formula for $\\beta$:\n$$ \\beta = \\frac{S \\cdot \\left( e^{-q \\tau} N(d_1) \\right)}{S e^{-q \\tau} N(d_1) - K e^{-r \\tau} N(d_2)} $$\nThis is the final analytical formula to be implemented. For each test case, we will substitute the given parameters $(S, K, r, q, \\sigma, T)$ (with $\\tau=T$) into this equation, using a standard numerical library to evaluate the normal CDF $N(\\cdot)$. The procedure is as follows:\n$1$. For each set of parameters, calculate $\\tau=T$.\n$2$. Compute $d_1$ and $d_2$.\n$3$. Evaluate $N(d_1)$ and $N(d_2)$.\n$4$. Calculate the numerator term $S e^{-q \\tau} N(d_1)$.\n$5$. Calculate the denominator term (the call price $C$) which is $S e^{-q \\tau} N(d_1) - K e^{-r \\tau} N(d_2)$.\n$6$. The value of $\\beta$ is the ratio of the result from step $4$ to the result from step $5$.\nThis procedure will be applied to all test cases provided.", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the instantaneous beta of a European call option for a set of test cases.\n    \"\"\"\n    # Test suite: (S, K, r, q, sigma, T)\n    test_cases = [\n        (100.0, 100.0, 0.01, 0.02, 0.2, 1.0),\n        (150.0, 100.0, 0.03, 0.0, 0.25, 2.0),\n        (50.0, 100.0, 0.01, 0.0, 0.2, 1.0),\n        (100.0, 100.0, 0.0, 0.0, 0.2, 1.0 / 365.0),\n        (100.0, 110.0, 0.05, 0.02, 0.3, 3.0),\n    ]\n\n    def calculate_beta(S, K, r, q, sigma, T):\n        \"\"\"\n        Calculates the instantaneous beta of a European call option.\n        Beta = (S * Delta) / C\n        \"\"\"\n        # Ensure time to maturity is not zero to avoid division by zero in d1/d2.\n        # If maturity is extremely small, the result will be large but finite.\n        if T <= 1e-12:\n            return float('inf')\n\n        # Time to maturity\n        tau = T\n\n        # Calculate d1 and d2\n        sigma_sqrt_tau = sigma * np.sqrt(tau)\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma**2) * tau) / sigma_sqrt_tau\n        d2 = d1 - sigma_sqrt_tau\n\n        # Evaluate the standard normal CDF\n        N_d1 = norm.cdf(d1)\n        N_d2 = norm.cdf(d2)\n        \n        # Calculate Delta, the first partial derivative of the option price\n        # with respect to the stock price. This is the hedging ratio.\n        # Delta = exp(-q*tau) * N(d1)\n        \n        # We compute beta using the derived analytical formula:\n        # beta = (S * exp(-q*tau) * N(d1)) / (S * exp(-q*tau) * N(d1) - K * exp(-r*tau) * N(d2))\n        \n        numerator = S * np.exp(-q * tau) * N_d1\n        \n        # Denominator is the Black-Scholes call price C\n        denominator = numerator - K * np.exp(-r * tau) * N_d2\n\n        # To avoid division by zero for deep out-of-the-money options where C might be numerically zero\n        if np.abs(denominator) < 1e-12:\n            # If the call price is effectively zero, the beta is theoretically infinite.\n            # In practice, we return a very large number or inf.\n            return float('inf')\n\n        beta = numerator / denominator\n        \n        return beta\n\n    results = []\n    for case in test_cases:\n        beta_value = calculate_beta(*case)\n        # Round the result to six decimal places as required.\n        results.append(f\"{beta_value:.6f}\")\n\n    # Format the final output string\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "The true power of the BSM framework lies in its extensibility to a vast universe of \"exotic\" derivatives. This practice ventures into that territory by asking you to price a compound option—an option to buy another option—a task that requires careful application of risk-neutral valuation to joint probability distributions [@problem_id:2400487]. You will then tackle a critical real-world problem: inverting your pricing model to calculate the implied volatility from a market price, a key parameter that reflects market expectations.", "id": "2400487", "problem": "Implement a complete, runnable program that computes the implied volatility for a European call-on-a-call (a compound option: an option on an option) under the Black–Scholes–Merton (BSM) framework with continuous dividend yield. The program must, for each test case, find the unique volatility parameter $\\sigma$ (a nonnegative real number expressed as a decimal, not a percentage) that makes the model price of the compound option equal to a given observed (market) price. All monetary inputs are dimensionless currency units, time is in years, and rates are annual continuously compounded rates. The final outputs must be floats rounded to six decimal places.\n\nUse the following foundational base:\n- Under the BSM assumptions, the underlying asset price $S_t$ follows a geometric Brownian motion under the risk-neutral measure with drift $r - q$ and volatility $\\sigma$, where $r$ is the continuously compounded risk-free rate and $q$ is the continuously compounded dividend yield.\n- The time-$0$ price of a European call with spot $S_0$, strike $K$, maturity $T$, risk-free rate $r$, dividend yield $q$, and volatility $\\sigma$ is the risk-neutral discounted expectation of its payoff $\\max(S_T - K, 0)$.\n- The price of a European compound option (call on a call) can be represented as a risk-neutral discounted expectation of the payoff at the compound exercise time $T_1$, which involves the continuation value of the underlying call option to its final maturity $T_2$, with $0 < T_1 < T_2$.\n- The critical stock level $S^\\star$ at time $T_1$ is defined implicitly by the indifference condition that the value of the underlying call at $T_1$ equals the compound option’s strike $A$, i.e., the Black–Scholes price of the underlying call with time to maturity $T_2 - T_1$ evaluated at spot $S^\\star$ equals $A$.\n\nYour task:\n- From first principles, derive the numerical procedure needed to price a European call-on-a-call under the BSM assumptions, including how to determine the critical level $S^\\star$ and how to evaluate the relevant multivariate Gaussian probabilities rigorously.\n- Then, given a set of observed compound option prices, invert the pricing map to produce the implied volatilities $\\sigma$ for each test case by solving a one-dimensional root-finding problem.\n\nImplementation requirements:\n- For each test case, first define the function that prices a European call-on-a-call for given inputs $(S_0, K, A, r, q, T_1, T_2, \\sigma)$. The pricing map must be based on risk-neutral valuation and the joint normality of the relevant log-returns. It must correctly incorporate the critical boundary $S^\\star$ that solves the implicit condition for optimal exercise of the compound option at $T_1$, and it must correctly compute the required bivariate standard normal cumulative distribution function with correlation $\\rho = \\sqrt{T_1/T_2}$.\n- Next, implement a robust numerical inversion (e.g., bracketing-based root-finding over $\\sigma \\in [10^{-6}, 3]$) to match a given observed market price. If strict bracketing fails, use a bounded continuous optimization within the same interval to minimize the squared pricing error. Return the minimizer as the implied volatility.\n- All answers for $\\sigma$ must be printed as decimals (not percentages) rounded to six decimal places.\n\nTest suite:\nProvide the implied volatility for the following four test cases. Each case is specified as a tuple $(S_0, K, A, r, q, T_1, T_2, P_{\\text{mkt}})$:\n- Case 1 (happy path, balanced maturities and moderate strike for the compound option): $(100.0, 100.0, 10.0, 0.03, 0.01, 0.5, 1.0, 5.50)$.\n- Case 2 (deep in-the-money underlying call, low compound strike, zero rates and dividend): $(120.0, 100.0, 5.0, 0.0, 0.0, 0.25, 1.0, 18.00)$.\n- Case 3 (out-of-the-money underlying call, longer maturities, small compound strike): $(80.0, 100.0, 2.0, 0.02, 0.0, 0.75, 1.5, 0.70)$.\n- Case 4 (short first maturity, moderately out-of-the-money underlying call): $(100.0, 110.0, 3.0, 0.01, 0.0, 0.1, 0.5, 0.60)$.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered to correspond to the cases above. Each number must be rounded to six decimal places. For example, an output for four cases must look like: \"[x1,x2,x3,x4]\" where each $x_i$ is a float with exactly six digits after the decimal point.\n\nMathematical and algorithmic constraints:\n- Let $S^\\star$ be defined as the unique solution to $C(S^\\star; K, r, q, \\sigma, T_2 - T_1) = A$, where $C(\\cdot)$ denotes the BSM price of a European call with time to maturity $T_2 - T_1$.\n- Use the fact that the joint distribution of the standardized log-price increments up to $T_1$ and $T_2$ is bivariate normal with correlation $\\rho = \\sqrt{T_1/T_2}$.\n- All intermediate computations must be in the same consistent units as specified. All final implied volatilities must be decimals with six digits after the decimal point.", "solution": "The problem presented is a well-defined exercise in computational finance, grounded in the established Black-Scholes-Merton (BSM) framework. It requires the inversion of the pricing model for a European call-on-a-call option to find the implied volatility. The problem is scientifically sound, self-contained, and algorithmically specified. It is therefore deemed valid. We proceed to the solution.\n\nThe objective is to determine the implied volatility, $\\sigma$, which is the value of the volatility parameter that equates the theoretical price of a compound option to its observed market price, $P_{\\text{mkt}}$. This requires two main components: a correct pricing function for the compound option, and a robust numerical root-finding algorithm.\n\nFirst, we establish the pricing model for a European call-on-a-call option from first principles.\n\n**1. Risk-Neutral Valuation and Payoff Structure**\n\nUnder the risk-neutral measure $\\mathbb{Q}$, the price of any derivative at time $t=0$ is its discounted expected future payoff. A European call-on-a-call option grants the holder the right to purchase a standard European call option at a future time $T_1$ for a strike price $A$. The underlying call has its own strike price $K$ and a final maturity $T_2$, where $0 < T_1 < T_2$.\n\nLet $C(S_t, t; K, T_2)$ denote the price of the underlying call option at time $t$ when the asset price is $S_t$. Its time to maturity is $T_2 - t$. At the first exercise date $T_1$, the payoff of the compound option is $\\max(C(S_{T_1}, T_1; K, T_2) - A, 0)$.\n\nThe time-$0$ price of the compound call, denoted $CC_0$, is therefore:\n$$ CC_0 = e^{-r T_1} \\mathbb{E}^{\\mathbb{Q}} \\left[ \\max(C(S_{T_1}, T_1; K, T_2) - A, 0) \\right] $$\nwhere $r$ is the risk-free rate and the expectation is over the distribution of the asset price $S_{T_1}$.\n\n**2. The Critical Stock Price, $S^\\star$**\n\nThe compound option will be exercised at time $T_1$ if and only if its intrinsic value is positive, i.e., $C(S_{T_1}, T_1; K, T_2) > A$. The BSM price of a call option is a monotonically increasing function of the underlying asset price $S$. Consequently, there exists a unique critical stock price, which we denote $S^\\star$, such that the holder is indifferent to exercising. This $S^\\star$ is the solution to the implicit equation:\n$$ C(S^\\star, T_1; K, T_2) = A $$\nThe time to maturity for this underlying call is $\\tau = T_2 - T_1$. The BSM formula for this call is:\n$$ C(S, T_1; K, T_2) = S e^{-q \\tau} \\Phi(d_1(S, \\tau)) - K e^{-r \\tau} \\Phi(d_2(S, \\tau)) $$\nwhere\n$$ d_{1,2}(S, \\tau) = \\frac{\\ln(S/K) + (r - q \\pm \\frac{1}{2}\\sigma^2)\\tau}{\\sigma\\sqrt{\\tau}} $$\nand $\\Phi(\\cdot)$ is the standard normal cumulative distribution function (CDF).\nThe condition $C(S_{T_1}, T_1; K, T_2) > A$ is thus equivalent to $S_{T_1} > S^\\star$. This critical boundary is essential for the valuation. To find $S^\\star$ for a given volatility $\\sigma$, we must solve the equation $C(S^\\star, T_1; K, T_2) - A = 0$ using a numerical root-finding method, such as Newton-Raphson, which is efficient as the derivative of the call price with respect to $S$ (the option's Delta, $\\Delta = e^{-q\\tau}\\Phi(d_1)$) is known analytically.\n\n**3. The Compound Option Pricing Formula**\n\nUsing the critical price $S^\\star$, the price of the compound option can be expressed as the discounted expectation of a payoff conditional on $S_{T_1} > S^\\star$:\n$$ CC_0 = e^{-r T_1} \\mathbb{E}^{\\mathbb{Q}} \\left[ (C(S_{T_1}, T_1; K, T_2) - A) \\cdot \\mathbb{I}_{S_{T_1} > S^\\star} \\right] $$\nwhere $\\mathbb{I}$ is the indicator function. By the tower property of conditional expectation, this is equivalent to:\n$$ CC_0 = \\mathbb{E}^{\\mathbb{Q}} \\left[ e^{-r T_2} \\max(S_{T_2} - K, 0) \\cdot \\mathbb{I}_{S_{T_1} > S^\\star} \\right] - A e^{-r T_1} \\mathbb{P}^{\\mathbb{Q}}(S_{T_1} > S^\\star) $$\nThis expression requires evaluating the expectation of a product of functions of the asset price at two different times, $T_1$ and $T_2$. The asset price process $S_t$ under the BSM model is a geometric Brownian motion, which implies that the logarithmic prices $\\ln S_{T_1}$ and $\\ln S_{T_2}$ are jointly normally distributed. Specifically, the vector $(\\ln S_{T_1}, \\ln S_{T_2})$ is bivariate normal. The correlation coefficient between the driving Wiener processes at $T_1$ and $T_2$ is $\\rho = \\sqrt{T_1/T_2}$, which is also the correlation between $\\ln S_{T_1}$ and $\\ln S_{T_2}$.\n\nEvaluation of the expectation leads to the final analytical formula derived by Geske (1979):\n$$ CC_0 = S_0 e^{-q T_2} M(a_1, b_1; \\rho) - K e^{-r T_2} M(a_2, b_2; \\rho) - A e^{-r T_1} \\Phi(a_2) $$\nwhere $S_0$ is the initial asset price, $q$ is the dividend yield, $M(x, y; \\rho)$ is the bivariate standard normal CDF with correlation $\\rho$, and the parameters are defined as:\n$$ a_1 = \\frac{\\ln(S_0/S^\\star) + (r - q + \\frac{1}{2}\\sigma^2)T_1}{\\sigma \\sqrt{T_1}} $$\n$$ a_2 = a_1 - \\sigma\\sqrt{T_1} = \\frac{\\ln(S_0/S^\\star) + (r - q - \\frac{1}{2}\\sigma^2)T_1}{\\sigma \\sqrt{T_1}} $$\n$$ b_1 = \\frac{\\ln(S_0/K) + (r - q + \\frac{1}{2}\\sigma^2)T_2}{\\sigma \\sqrt{T_2}} $$\n$$ b_2 = b_1 - \\sigma\\sqrt{T_2} =  \\frac{\\ln(S_0/K) + (r - q - \\frac{1}{2}\\sigma^2)T_2}{\\sigma \\sqrt{T_2}} $$\n$$ \\rho = \\sqrt{T_1 / T_2} $$\nThe terms in this formula correspond to the probabilities of joint events. The term $S_0 e^{-q T_2} M(a_1, b_1; \\rho) - K e^{-r T_2} M(a_2, b_2; \\rho)$ represents the time-$0$ value of receiving the underlying call option at time $T_1$ conditional on $S_{T_1} > S^\\star$. The final term, $-A e^{-r T_1} \\Phi(a_2)$, is the discounted cost of exercising the compound option, weighted by the probability of exercise, $\\mathbb{P}^{\\mathbb{Q}}(S_{T_1} > S^\\star) = \\Phi(a_2)$. The terms involving the bivariate CDF $M(\\cdot, \\cdot; \\rho)$ represent the joint probabilities $\\mathbb{P}(S_{T_1} > S^\\star, S_{T_2} > K)$ under the appropriate risk-neutral measures.\n\n**4. Numerical Inversion for Implied Volatility**\n\nWith the pricing function $CC_0(\\sigma)$ established, the problem reduces to finding the root of the function:\n$$ f(\\sigma) = CC_0(S_0, K, A, r, q, T_1, T_2, \\sigma) - P_{\\text{mkt}} = 0 $$\nThe price of a compound call, like a standard call, is a monotonically increasing function of volatility $\\sigma$ (its Vega is positive). This property guarantees that for a market price $P_{\\text{mkt}}$ that falls within the possible range of model prices, a unique solution for $\\sigma$ exists.\n\nWe implement a robust numerical procedure as specified:\n1.  Define a search interval for $\\sigma$, for example, $[\\sigma_{\\min}, \\sigma_{\\max}] = [10^{-6}, 3.0]$.\n2.  Attempt to use a bracketing root-finding algorithm like Brent's method (`brentq`). This method is efficient and guaranteed to converge if a root is bracketed, i.e., $f(\\sigma_{\\min})$ and $f(\\sigma_{\\max})$ have opposite signs.\n3.  If a root is not bracketed (e.g., $P_{\\text{mkt}}$ is outside the price range generated by $\\sigma$ in the interval), we fall back to a bounded numerical optimization. We seek to minimize the squared pricing error:\n    $$ \\min_{\\sigma \\in [\\sigma_{\\min}, \\sigma_{\\max}]} \\left( CC_0(\\sigma) - P_{\\text{mkt}} \\right)^2 $$\n    This ensures that we find the value of $\\sigma$ that produces the model price closest to the market price, even if an exact match is not possible within the specified volatility bounds.\n\nThe final implementation will combine these components: a function to find $S^\\star$, a function to price the compound call using the Geske formula, and a main function to perform the inversion for $\\sigma$. Special care must be taken for the limiting case of $\\sigma \\to 0$ to avoid numerical instability.", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.stats import multivariate_normal\nfrom scipy.optimize import root_scalar, brentq, minimize_scalar\n\ndef black_scholes_call(S, K, T, r, q, sigma):\n    \"\"\"\n    Prices a European call option using the Black-Scholes-Merton formula.\n    \"\"\"\n    # Handle edge cases of zero time or zero volatility\n    if T <= 1e-9 or sigma <= 1e-9:\n        price_at_maturity = np.maximum(S * np.exp((r - q) * T) - K, 0)\n        return np.exp(-r * T) * price_at_maturity\n    \n    d1 = (np.log(S / K) + (r - q + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    price = S * np.exp(-q * T) * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef find_S_star(K, A, T_mat, r, q, sigma):\n    \"\"\"\n    Finds the critical stock price S* such that C(S*, T_mat) = A.\n    T_mat is the time to maturity of the underlying option, i.e., T2 - T1.\n    \"\"\"\n    # Handle the sigma -> 0 limit analytically to avoid numerical instability.\n    if sigma <= 1e-9:\n        if A <= 0: return K * np.exp(-(r-q)*T_mat) \n        # C(S, tau) -> exp(-r*tau) * max(S*exp((r-q)*tau) - K, 0)\n        # S*exp((r-q)*tau) - K = A * exp(r*tau) => S* = (K + A*exp(r*tau))*exp(-(r-q)*tau)\n        S_star = (K + A * np.exp(r * T_mat)) * np.exp(-(r - q) * T_mat)\n        return S_star\n    \n    # Objective function f(S) = C(S) - A. We want to find its root.\n    def objective(S):\n        return black_scholes_call(S, K, T_mat, r, q, sigma) - A\n    \n    # Derivative of objective wrt S is the call option's Delta.\n    def fprime(S):\n        if S <= 0: return 0.0\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma**2) * T_mat) / (sigma * np.sqrt(T_mat))\n        return np.exp(-q * T_mat) * norm.cdf(d1)\n\n    # Use Newton's method with a reasonable initial guess.\n    # Fallback to a bracketing method for robustness.\n    try:\n        # Initial guess from the zero-sigma limit.\n        initial_guess = (K + A * np.exp(r * T_mat)) * np.exp(-(r - q) * T_mat)\n        sol = root_scalar(objective, x0=initial_guess, fprime=fprime, method='newton', xtol=1e-9, rtol=1e-9)\n        if sol.converged:\n            return sol.root\n    except (ValueError, RuntimeError):\n        pass  # Fallback if Newton fails\n\n    try:\n        sol = root_scalar(objective, bracket=[1e-6, 5 * (K+A)], method='brentq', xtol=1e-9, rtol=1e-9)\n        return sol.root\n    except ValueError:\n        # If bracket is invalid, it indicates extreme parameters.\n        # This is a last resort for very unusual inputs.\n        return K\n\n\ndef compound_call_price(S0, K, A, r, q, T1, T2, sigma):\n    \"\"\"\n    Prices a European call-on-a-call option using the Geske (1979) formula.\n    \"\"\"\n    # Handle the zero volatility limit.\n    if sigma <= 1e-9:\n        # Value of underlying call at T1 if exercised: S0 * exp((r-q)*T1)\n        price_S_T1 = S0 * np.exp((r - q) * T1)\n        # Value of underlying call at T1 given S_T1.\n        C1 = black_scholes_call(price_S_T1, K, T2 - T1, r, q, sigma)\n        payoff_at_T1 = np.maximum(C1 - A, 0)\n        return np.exp(-r * T1) * payoff_at_T1\n\n    T_mat_underlying = T2 - T1\n    S_star = find_S_star(K, A, T_mat_underlying, r, q, sigma)\n    \n    if S_star <= 0: # S* must be positive\n        return 0.0\n\n    rho = np.sqrt(T1 / T2)\n\n    sig_sqrt_T1 = sigma * np.sqrt(T1)\n    sig_sqrt_T2 = sigma * np.sqrt(T2)\n    \n    a1 = (np.log(S0 / S_star) + (r - q + 0.5 * sigma**2) * T1) / sig_sqrt_T1\n    a2 = a1 - sig_sqrt_T1\n    \n    b1 = (np.log(S0 / K) + (r - q + 0.5 * sigma**2) * T2) / sig_sqrt_T2\n    b2 = b1 - sig_sqrt_T2\n    \n    mean = np.array([0.0, 0.0])\n    cov_matrix = np.array([[1.0, rho], [rho, 1.0]])\n    \n    M_ab1 = multivariate_normal.cdf([a1, b1], mean=mean, cov=cov_matrix)\n    M_ab2 = multivariate_normal.cdf([a2, b2], mean=mean, cov=cov_matrix)\n    \n    N_a2 = norm.cdf(a2)\n    \n    price = (S0 * np.exp(-q * T2) * M_ab1\n             - K * np.exp(-r * T2) * M_ab2\n             - A * np.exp(-r * T1) * N_a2)\n             \n    return price\n\ndef get_implied_volatility(S0, K, A, r, q, T1, T2, P_mkt):\n    \"\"\"\n    Calculates the implied volatility by inverting the compound call pricing function.\n    \"\"\"\n    sigma_min, sigma_max = 1e-6, 3.0\n    \n    # Objective function for root-finding: f(sigma) = C(sigma) - P_mkt\n    def error_func(sigma):\n        return compound_call_price(S0, K, A, r, q, T1, T2, sigma) - P_mkt\n    \n    # Try to use a robust bracketing method first.\n    try:\n        val_min = error_func(sigma_min)\n        val_max = error_func(sigma_max)\n        if np.sign(val_min) != np.sign(val_max):\n            iv = brentq(error_func, sigma_min, sigma_max, xtol=1e-7, rtol=1e-7)\n            return iv\n    except Exception:\n        # This pass allows fallback to the optimization method below\n        # if brentq fails for any reason (e.g., non-monotonicity from numerical errors)\n        pass\n\n    # If bracketing fails, use bounded optimization to minimize squared error.\n    def squared_error_func(sigma):\n        return error_func(sigma)**2\n        \n    res = minimize_scalar(\n        squared_error_func, \n        bounds=(sigma_min, sigma_max), \n        method='bounded'\n    )\n    \n    return res.x\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases and prints the output.\n    \"\"\"\n    test_cases = [\n        # (S0, K, A, r, q, T1, T2, P_mkt)\n        (100.0, 100.0, 10.0, 0.03, 0.01, 0.5, 1.0, 5.50),\n        (120.0, 100.0, 5.0, 0.0, 0.0, 0.25, 1.0, 18.00),\n        (80.0, 100.0, 2.0, 0.02, 0.0, 0.75, 1.5, 0.70),\n        (100.0, 110.0, 3.0, 0.01, 0.0, 0.1, 0.5, 0.60)\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, K, A, r, q, T1, T2, P_mkt = case\n        iv = get_implied_volatility(S0, K, A, r, q, T1, T2, P_mkt)\n        results.append(f\"{iv:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}