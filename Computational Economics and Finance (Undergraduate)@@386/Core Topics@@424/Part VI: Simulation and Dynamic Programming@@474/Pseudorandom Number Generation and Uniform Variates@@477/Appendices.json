{"hands_on_practices": [{"introduction": "A good pseudorandom number generator (PRNG) is the cornerstone of any simulation. However, not all generators are created equal, and some seemingly simple ones, like the Linear Congruential Generator (LCG), hide critical flaws. This exercise challenges you to look beneath the surface and investigate a famous weakness of LCGs: the non-randomness of their low-order bits [@problem_id:2423215]. By analyzing the statistical properties of these bits, you will gain a crucial insight into why understanding a generator's internal structure is as important as using it correctly.", "id": "2423215", "problem": "Consider a Linear Congruential Generator (LCG) defined by integers $m \\gt 0$, $a$, $c$, and an initial seed $x_0$, evolving by the recursion\n$$\nx_{n+1} \\equiv a\\,x_n + c \\pmod{m}, \\quad n \\ge 0.\n$$\nIn computational economics and finance, such sequences are often used to generate pseudorandom numbers intended to approximate independent samples from a uniform distribution. In this problem, you will examine what happens to the statistical properties of the sequence if, instead of using the full $x_n$, you only use the $k = 3$ least significant bits of each $x_n$. Define the $3$-bit output as\n$$\ny_n \\equiv x_n \\bmod 2^3 \\in \\{0,1,2,3,4,5,6,7\\},\n$$\nand the least significant bit as\n$$\nb_n \\equiv x_n \\bmod 2 \\in \\{0,1\\}.\n$$\nStarting only from the core definitions of modular arithmetic and the LCG recursion, reason about the behavior of these low-order bits and then implement a program to quantify the following empirical properties for various LCG parameterizations used as test cases.\n\nTasks to implement for each test case:\n- Generate $N$ consecutive states $x_1, x_2, \\dots, x_N$ from the given LCG, starting from the specified seed $x_0$.\n- From the generated sequence, compute $y_n = x_n \\bmod 8$ and $b_n = x_n \\bmod 2$ for $n = 1,2,\\dots,N$.\n- Compute the following diagnostics:\n  1. The chi-square statistic for the $3$-bit histogram of $y_n$ against the discrete uniform distribution on $\\{0,1,\\dots,7\\}$:\n     $$\n     \\chi^2 \\;=\\; \\sum_{j=0}^{7} \\frac{\\left(O_j - \\frac{N}{8}\\right)^2}{\\frac{N}{8}},\n     $$\n     where $O_j$ is the observed count of $y_n = j$ among $N$ samples.\n  2. The empirical lag-$1$ autocorrelation of the least significant bit sequence $b_n$:\n     $$\n     \\hat{\\rho}_1 \\;=\\; \\frac{\\sum_{n=1}^{N-1} \\left(b_n - \\bar{b}\\right)\\left(b_{n+1} - \\bar{b}\\right)}{\\sqrt{\\sum_{n=1}^{N-1} \\left(b_n - \\bar{b}\\right)^2} \\, \\sqrt{\\sum_{n=1}^{N-1} \\left(b_{n+1} - \\bar{b}\\right)^2}},\n     \\quad \\bar{b} \\;=\\; \\frac{1}{N}\\sum_{n=1}^{N} b_n.\n     $$\n  3. A boolean indicator $\\mathrm{isDet3}$ that is true if and only if $y_{n+1}$ depends only on $y_n$ (that is, the mapping on the $3$ least significant bits is autonomous and can be written as a recursion on $\\mathbb{Z}/2^3\\mathbb{Z}$). This occurs precisely when reducing the LCG modulo $2^3$ commutes with the original recursion in the sense of ring homomorphisms.\n  4. If $\\mathrm{isDet3}$ is true, compute the period $P_3$ of the $3$-bit subsequence by iterating the induced map on $\\{0,1,\\dots,7\\}$ starting from $y_0 = x_0 \\bmod 8$ until the first return to $y_0$. If $\\mathrm{isDet3}$ is false, set $P_3 = 0$.\n\nTest suite to run:\n- Case $1$ (mixed LCG with modulus a power of two): $m = 2^{31}$, $a = 1103515245$, $c = 12345$, $x_0 = 1$, $N = 100000$.\n- Case $2$ (multiplicative LCG with prime modulus): $m = 2^{31} - 1$, $a = 16807$, $c = 0$, $x_0 = 1$, $N = 100000$.\n- Case $3$ (mixed LCG with large power-of-two modulus): $m = 2^{48}$, $a = 25214903917$, $c = 11$, $x_0 = 1$, $N = 100000$.\n\nFinal output format:\n- Your program should produce a single line of output containing a list of results, one per test case, where each test case result is the list\n$$\n\\left[\\chi^2,\\; \\hat{\\rho}_1,\\; \\mathrm{isDet3},\\; P_3\\right],\n$$\nwith the two numerical entries as real numbers and $P_3$ as an integer, and $\\mathrm{isDet3}$ as a boolean. Aggregate the three test-case result lists into a single top-level list and print it as a single line, with comma-separated entries enclosed in square brackets, for example:\n$$\n\\big[\\,[\\chi^2_1,\\hat{\\rho}_{1,1},\\mathrm{isDet3}_1,P_{3,1}],\\;[\\chi^2_2,\\hat{\\rho}_{1,2},\\mathrm{isDet3}_2,P_{3,2}],\\;[\\chi^2_3,\\hat{\\rho}_{1,3},\\mathrm{isDet3}_3,P_{3,3}]\\,\\big].\n$$\nNo external input is required, and no physical units are involved. Angles are not used. All answers are raw numbers or booleans as specified.", "solution": "The problem requires an analysis of the statistical properties of the least significant bits produced by a Linear Congruential Generator (LCG). We must first validate the problem's statement and then provide a thorough solution based on fundamental principles of number theory and statistics.\n\nThe problem is scientifically and mathematically well-posed. It concerns the standard LCG recursion $x_{n+1} \\equiv a\\,x_n + c \\pmod{m}$ and investigates the properties of the derived sequences $y_n \\equiv x_n \\pmod{8}$ and $b_n \\equiv x_n \\pmod{2}$. The diagnostics requested—the chi-square statistic, lag-$1$ autocorrelation, and the period of the low-bit sequence—are standard tools for assessing the quality of pseudorandom number generators. The parameters for the test cases are taken from historically significant LCGs, and the problem is completely specified, containing no ambiguities or contradictions. The problem is therefore deemed **valid**, and we may proceed with a solution.\n\nThe core of the analysis rests on the behavior of the LCG recursion under the modulo $2^3 = 8$ operation.\n\n**1. Analysis of Determinism for the 3-bit Subsequence ($\\mathrm{isDet3}$)**\n\nThe indicator $\\mathrm{isDet3}$ is true if the sequence of $3$-bit values $y_n = x_n \\pmod{8}$ is autonomous, meaning $y_{n+1}$ is a function of $y_n$ alone.\nThe LCG recursion is $x_{n+1} = (a\\,x_n + c) - q_n m$ for some integer $q_n = \\lfloor (a\\,x_n + c)/m \\rfloor$.\nTaking this equation modulo $8$, we get:\n$$\ny_{n+1} \\equiv x_{n+1} \\pmod{8} \\equiv (a\\,x_n + c - q_n m) \\pmod{8}\n$$\nLet us express $x_n$ in terms of $y_n$: $x_n = 8k + y_n$ for some integer $k$. The value of $k$ depends on the higher-order bits of $x_n$.\nSubstituting this into the congruence gives:\n$$\ny_{n+1} \\equiv (a\\,(8k + y_n) + c - q_n m) \\pmod{8}\n$$\n$$\ny_{n+1} \\equiv (8ak + a y_n + c - q_n m) \\pmod{8}\n$$\n$$\ny_{n+1} \\equiv (a y_n + c - q_n m) \\pmod{8}\n$$\nFor $y_{n+1}$ to be a function of $y_n$ only, the expression must be independent of $k$ and $q_n$, which both depend on the full value of $x_n$. The term $a y_n + c$ depends only on $y_n$. The term $q_n m$ introduces a dependency on the higher-order bits of $x_n$, since $q_n$ is a function of $x_n$.\nThis dependency is removed if and only if $q_n m \\pmod{8}$ is constant for all $n$. The simplest way for this to hold for any sequence $x_n$ (and thus any sequence $q_n$) is if $m \\equiv 0 \\pmod{8}$. If $m$ is a multiple of $8$, then $q_n m \\equiv q_n \\cdot 0 \\equiv 0 \\pmod{8}$, regardless of the value of $q_n$.\nIn this case, the recursion for $y_n$ simplifies to:\n$$\ny_{n+1} \\equiv a y_n + c \\pmod{8}\n$$\nThis is a self-contained LCG on the ring of integers modulo $8$, $\\mathbb{Z}/8\\mathbb{Z}$.\n\nIf $m$ is not a multiple of $8$, then $m \\pmod{8}$ is non-zero. The value of $q_n$ can change based on the high bits of $x_n$, which means $q_n m \\pmod{8}$ is not constant. Therefore, $y_{n+1}$ will depend on more than just $y_n$.\n\nThus, the condition for $\\mathrm{isDet3}$ to be true is precisely $m \\equiv 0 \\pmod{8}$.\n\n**2. Period of the 3-bit Subsequence ($P_3$)**\n\nIf $\\mathrm{isDet3}$ is false ($m \\not\\equiv 0 \\pmod{8}$), $P_3$ is defined to be $0$.\nIf $\\mathrm{isDet3}$ is true, we must find the period of the sequence $y_{n+1} \\equiv a y_n + c \\pmod{8}$, starting from $y_0 = x_0 \\pmod{8}$. Since the state space $\\{0, 1, \\dots, 7\\}$ is finite, this sequence is guaranteed to be periodic. The period can be found by simulating the sequence $y_0, y_1, y_2, \\dots$ and recording the number of steps until $y_0$ is revisited for the first time. The length of the cycle is the period $P_3$.\nFor an LCG on $\\mathbb{Z}_{2^k}$, the maximal period of $2^k$ is achieved if and only if $c$ is odd and $a \\equiv 1 \\pmod{4}$. For our case, $k=3$, this translates to $c$ being odd and $a \\equiv 1 \\pmod{4}$ for a period of $8$.\n\n**3. Chi-Square Statistic ($\\chi^2$)**\n\nThis statistic measures the goodness of fit of the observed frequencies of $y_n$ to a discrete uniform distribution. For $N$ samples and $8$ possible outcomes $\\{0, 1, ..., 7\\}$, the expected frequency for each outcome $j$ is $E_j = N/8$. If $O_j$ is the observed frequency of outcome $j$ in the sequence $y_1, \\dots, y_N$, the statistic is calculated as:\n$$\n\\chi^2 = \\sum_{j=0}^{7} \\frac{\\left(O_j - E_j\\right)^2}{E_j} = \\sum_{j=0}^{7} \\frac{\\left(O_j - N/8\\right)^2}{N/8}\n$$\nA small value of $\\chi^2$ (close to $0$) suggests the data is consistent with a uniform distribution, while a large value suggests it is not.\n\n**4. Lag-1 Autocorrelation of the Least Significant Bit ($\\hat{\\rho}_1$)**\n\nThis statistic measures the linear correlation between consecutive elements of the sequence of least significant bits, $b_n = x_n \\pmod{2}$. The formula provided is a variant of the Pearson correlation coefficient:\n$$\n\\hat{\\rho}_1 = \\frac{\\sum_{n=1}^{N-1} (b_n - \\bar{b})(b_{n+1} - \\bar{b})}{\\sqrt{\\sum_{n=1}^{N-1} (b_n - \\bar{b})^2} \\cdot \\sqrt{\\sum_{n=1}^{N-1} (b_{n+1} - \\bar{b})^2}}\n$$\nwhere $\\bar{b} = \\frac{1}{N}\\sum_{n=1}^{N} b_n$ is the mean of the entire sequence $b_1, \\dots, b_N$. A value of $\\hat{\\rho}_1$ close to $0$ indicates low linear correlation, while values near $+1$ or $-1$ indicate strong positive or negative correlation, respectively.\n\n**Analysis of Test Cases:**\n\n- **Case 1:** $m = 2^{31}, a = 1103515245, c = 12345$.\n  - Since $m = 2^{31}$ is a multiple of $8$, $\\mathrm{isDet3}$ is true.\n  - The induced LCG is $y_{n+1} \\equiv a y_n + c \\pmod{8}$. We have $a \\equiv 5 \\pmod{8}$ and $c \\equiv 1 \\pmod{8}$. Since $a \\equiv 1 \\pmod{4}$ and $c$ is odd, the period $P_3$ will be maximal, which is $8$.\n  - The sequence $y_n$ will consist of $N/P_3 = 100000/8 = 12500$ repetitions of a permutation of $\\{0, \\dots, 7\\}$. Thus, each value occurs exactly $12500$ times. $O_j = E_j = 12500$, leading to $\\chi^2 = 0$.\n  - The LSB sequence $b_n = y_n \\pmod{2}$ will be periodic. $y_n$ sequence starting from $y_0 = 1$ is $1, 6, 7, 4, 5, 2, 3, 0, \\dots$. The LSB sequence $b_n$ is $1, 0, 1, 0, 1, 0, 1, 0, \\dots$. This is a perfectly alternating sequence, which implies a strong negative lag-$1$ autocorrelation, $\\hat{\\rho}_1 \\approx -1$.\n\n- **Case 2:** $m = 2^{31} - 1, a = 16807, c = 0$.\n  - The modulus $m$ is a prime number and is not a multiple of $8$. Thus, $\\mathrm{isDet3}$ is false, and $P_3 = 0$.\n  - The low-order bits $y_n$ are not determined by a simple local recursion but are mixed by the global operation modulo a large prime. We expect these bits to behave pseudo-randomly.\n  - $\\chi^2$ should be a small positive value, characteristic of random sampling fluctuations.\n  - $\\hat{\\rho}_1$ should be close to $0$, indicating low correlation between consecutive bits.\n\n- **Case 3:** $m = 2^{48}, a = 25214903917, c = 11$.\n  - Similar to Case 1, $m = 2^{48}$ is a multiple of $8$, so $\\mathrm{isDet3}$ is true.\n  - The induced LCG is $y_{n+1} \\equiv a y_n + c \\pmod{8}$. We find $a \\equiv 5 \\pmod{8}$ and $c \\equiv 3 \\pmod{8}$. Again, $a \\equiv 1 \\pmod{4}$ and $c$ is odd, so the period $P_3$ is $8$.\n  - As in Case 1, the perfect periodicity implies $O_j = N/8$, so $\\chi^2 = 0$.\n  - The LSB sequence $b_n = y_n \\pmod{2}$ will also be periodic. For $y_0=1$, the sequence is $1, 0, 3, 2, 5, 4, 7, 6, \\dots$. The LSB sequence is again $1, 0, 1, 0, 1, 0, 1, 0, \\dots$. Thus, we expect $\\hat{\\rho}_1 \\approx -1$.\n\nThis analysis shows a fundamental weakness of LCGs with power-of-two moduli: their low-order bits are highly non-random, having very short periods. This is why such generators must be used with caution, and often their output is truncated to use only the higher-order bits.\n\n**Implementation Plan:**\n\nThe implementation will follow the logic above. A loop will iterate through the test cases. For each case, we will:\n1.  Generate $N$ values of $x_n$ using the LCG recursion. Python's arbitrary-precision integers will handle large intermediate products.\n2.  Compute the $y_n$ and $b_n$ sequences.\n3.  Compute $\\chi^2$ by counting occurrences of each value in $y_n$ and applying the formula.\n4.  Compute $\\hat{\\rho}_1$ directly from the provided formula using the $b_n$ sequence.\n5.  Determine $\\mathrm{isDet3}$ by checking if $m \\pmod{8} == 0$.\n6.  If $\\mathrm{isDet3}$ is true, compute $P_3$ by iterating the map on $\\mathbb{Z}_8$ until the initial state is revisited. Otherwise, set $P_3 = 0$.\nThe results will be collected and printed in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_diagnostics(m, a, c, x0, N):\n    \"\"\"\n    Generates LCG sequences and computes statistical diagnostics.\n    \"\"\"\n    # Use standard Python integers which support arbitrary size.\n    # This is crucial for Case 3 where intermediate products exceed 64 bits.\n    x = np.zeros(N + 1, dtype=object)\n    x[0] = x0\n\n    # Generate N consecutive states x_1, ..., x_N\n    for n in range(N):\n        x[n+1] = (a * x[n] + c) % m\n\n    # The problem asks for analysis on x_1, ..., x_N\n    x_sequence = x[1:].astype(np.int64)\n\n    # Compute y_n and b_n sequences\n    y_n = x_sequence % 8\n    b_n = x_sequence % 2\n\n    # 1. Chi-square statistic for y_n\n    # O_j are the observed counts for j=0..7\n    # N is the number of samples, so N/8 is the expected count for each bin.\n    observed_counts, _ = np.histogram(y_n, bins=np.arange(9)) # bins are [0,1,..,8]\n    expected_count = N / 8.0\n    chi2_stat = np.sum((observed_counts - expected_count)**2 / expected_count)\n\n    # 2. Lag-1 autocorrelation of b_n\n    b_mean = np.mean(b_n)\n    \n    # Slices for b_n and b_{n+1}\n    # b_current corresponds to b_1, ..., b_{N-1}\n    # b_next corresponds to b_2, ..., b_N\n    b_current = b_n[:-1]\n    b_next = b_n[1:]\n    \n    dev_current = b_current - b_mean\n    dev_next = b_next - b_mean\n    \n    numerator = np.sum(dev_current * dev_next)\n    \n    sum_sq_dev_current = np.sum(dev_current**2)\n    sum_sq_dev_next = np.sum(dev_next**2) # This is sum_{n=1}^{N-1} (b_{n+1} - b_bar)^2\n    \n    denominator = np.sqrt(sum_sq_dev_current * sum_sq_dev_next)\n    \n    # Handle case where denominator is zero (sequence is constant)\n    if denominator == 0:\n        rho1 = 0.0\n    else:\n        rho1 = numerator / denominator\n\n    # 3. Determinism indicator for y_n\n    isDet3 = (m % 8 == 0)\n\n    # 4. Period P3 of the 3-bit subsequence\n    P3 = 0\n    if isDet3:\n        y_current = x0 % 8\n        y_start = y_current\n        count = 0\n        while True:\n            count += 1\n            y_current = (a * y_current + c) % 8\n            if y_current == y_start:\n                P3 = count\n                break\n            # Safety break for unexpected behavior, though not anticipated here\n            if count > 8:\n                P3 = -1 # Should not happen based on theory\n                break\n\n    return [chi2_stat, rho1, isDet3, P3]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (mixed LCG with modulus a power of two)\n        (2**31, 1103515245, 12345, 1, 100000),\n        # Case 2 (multiplicative LCG with prime modulus)\n        (2**31 - 1, 16807, 0, 1, 100000),\n        # Case 3 (mixed LCG with large power-of-two modulus)\n        (2**48, 25214903917, 11, 1, 100000),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, a, c, x0, N = case\n        result = compute_diagnostics(m, a, c, x0, N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # str() on a list gives a string like '[...]', so a simple join creates the required nested list string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "Even with a perfect source of uniform random numbers, generating variates for specific tasks can introduce subtle biases. A common task in simulation is drawing an integer uniformly from a specific range $[a, b]$, but a naive approach using the modulo operator often leads to an incorrect distribution. This practice requires you to analytically quantify the bias of the naive method and contrast it with the provably correct rejection sampling technique [@problem_id:2423278]. Mastering this distinction will equip you to build more accurate and reliable simulation models in economics and finance.", "id": "2423278", "problem": "You are given access to a base Pseudorandom Number Generator (PRNG) that produces independent draws uniformly over the integer set $\\{0,1,\\dots,m-1\\}$, where $m = 2^{32}$. Your task is to analyze how to generate a random integer in a target range $[a,b]$ using this source and to quantify the bias introduced by a naive implementation. This problem is motivated by Monte Carlo algorithms widely used in computational economics and finance, where biased discrete uniform sampling can distort estimates (for example, state transitions, resampling steps in Sequential Monte Carlo, or discrete choice simulation). You must derive the relevant expressions from first principles and implement a program that computes exact bias metrics and resource usage without simulation.\n\nFundamental definitions and assumptions:\n- The base PRNG output $X$ is exactly uniform over $\\{0,1,\\dots,m-1\\}$ with $m=2^{32}$.\n- Let $n = b-a+1$ be the size of the target integer range $[a,b]$.\n- The naive “modulo” mapping produces $Y_{\\mathrm{mod}} = a + (X \\bmod n)$.\n- The rejection sampling mapping defines $q = \\lfloor m/n \\rfloor$, accepts a draw if $X < qn$, and returns $Y_{\\mathrm{rej}} = a + (X \\bmod n)$ on acceptance; otherwise it redraws from the base PRNG until acceptance.\n\nYour tasks:\n1) Derive from first principles the exact probability mass function of $Y_{\\mathrm{mod}}$ in terms of $m$, $n$, $q = \\lfloor m/n \\rfloor$, and $r = m - qn$, and then derive a closed-form expression for the total variation distance between the distribution of $Y_{\\mathrm{mod}}$ and the ideal discrete uniform distribution on $[a,b]$. The total variation distance between two distributions with probabilities $\\{p_i\\}$ and $\\{u_i\\}$ over $n$ outcomes is defined as\n$$\n\\mathrm{TVD} = \\frac{1}{2}\\sum_{i=1}^{n} \\left| p_i - u_i \\right|.\n$$\n\n2) Prove that the rejection sampling mapping yields an exactly uniform distribution on $[a,b]$ (that is, the total variation distance is $0$), and derive its acceptance probability $\\alpha$ and the expected number of base PRNG draws per accepted output. Express your answers in terms of $m$, $n$, $q$, and $r$.\n\n3) Implement a program that, for each test case below, computes three quantities using your derived formulas (not by simulation):\n- The total variation distance for the modulo method, $\\mathrm{TVD}_{\\mathrm{mod}}$.\n- The total variation distance for the rejection method, $\\mathrm{TVD}_{\\mathrm{rej}}$.\n- The expected number of base PRNG draws per accepted output under rejection sampling, $\\mathbb{E}[D]$.\n\nTest suite (use the following $(a,b)$ pairs; these are designed to include a common case, boundary cases, and edge cases):\n- Case 1 (general case): $(a,b) = (0, 9)$ so $n=10$.\n- Case 2 (degenerate range): $(a,b) = (5, 5)$ so $n=1$.\n- Case 3 (includes negative): $(a,b) = (-2, 2)$ so $n=5$.\n- Case 4 (divides $m$ exactly): $(a,b) = (0, 65535)$ so $n=65536$.\n- Case 5 (large nondividing): $(a,b) = (-10, 10^{6})$ so $n = 1{,}000{,}011$.\n\nPrecise output requirements:\n- For each test case, output a list $[\\mathrm{TVD}_{\\mathrm{mod}}, \\mathrm{TVD}_{\\mathrm{rej}}, \\mathbb{E}[D]]$ in this order.\n- Your program should produce a single line of output containing the results for all test cases, as a comma-separated list of these per-case lists, enclosed in square brackets. For example: \n\"[ [x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}],... ]\" but with no spaces. Your program must output exactly one such line.\n- All results must be numeric (floating-point is acceptable). No random sampling is permitted in your solution; compute values using closed-form expressions only.", "solution": "We begin from first principles. The base Pseudorandom Number Generator (PRNG) draws $X$ uniformly from the finite set $\\{0,1,\\dots,m-1\\}$, with $m = 2^{32}$. For a target integer interval $[a,b]$, define $n = b-a+1 \\in \\mathbb{N}$.\n\nNaive modulo mapping analysis:\nDefine the naive mapping $Y_{\\mathrm{mod}} = a + (X \\bmod n)$. Since $X$ is uniform on $\\{0,1,\\dots,m-1\\}$ and $(X \\bmod n)$ takes values in $\\{0,1,\\dots,n-1\\}$, the probability that $(X \\bmod n) = i$ is proportional to how many integers in $\\{0,1,\\dots,m-1\\}$ have remainder $i$ modulo $n$.\n\nLet $q = \\left\\lfloor \\frac{m}{n} \\right\\rfloor$ and $r = m - qn = m \\bmod n$, where $r \\in \\{0,1,\\dots,n-1\\}$. There are exactly $r$ remainders that occur $q+1$ times and $n-r$ remainders that occur $q$ times when we partition $\\{0,1,\\dots,m-1\\}$ into congruence classes modulo $n$. Therefore, for remainder $i$,\n- For $r$ many values of $i$, $\\mathbb{P}[(X \\bmod n)=i] = \\frac{q+1}{m}$.\n- For $n-r$ many values of $i$, $\\mathbb{P}[(X \\bmod n)=i] = \\frac{q}{m}$.\n\nThe ideal discrete uniform distribution on $\\{0,1,\\dots,n-1\\}$ assigns probability $\\frac{1}{n}$ to each remainder. The absolute deviations are\n$$\n\\left|\\frac{q+1}{m} - \\frac{1}{n}\\right| = \\frac{n-r}{mn}, \\quad\n\\left|\\frac{q}{m} - \\frac{1}{n}\\right| = \\frac{r}{mn}.\n$$\nThe total variation distance is thus\n$$\n\\mathrm{TVD}_{\\mathrm{mod}} = \\frac{1}{2}\\left( r \\cdot \\frac{n-r}{mn} + (n-r) \\cdot \\frac{r}{mn} \\right) = \\frac{r(n-r)}{mn}.\n$$\nThis closed-form expression quantifies the bias introduced by the modulo method whenever $r \\neq 0$ (that is, whenever $n$ does not divide $m$). If $r=0$, then $\\mathrm{TVD}_{\\mathrm{mod}} = 0$ and the mapping is exactly uniform.\n\nRejection sampling analysis:\nDefine $q = \\left\\lfloor \\frac{m}{n} \\right\\rfloor$ as before and accept a draw if $X < qn$, returning $Y_{\\mathrm{rej}} = a + (X \\bmod n)$ on acceptance; otherwise, redraw from the base PRNG. Because the accepted set has size $qn$ and is partitioned into $n$ congruence classes each of size exactly $q$, conditional on acceptance the remainder $(X \\bmod n)$ is exactly uniform over $\\{0,1,\\dots,n-1\\}$. Therefore,\n$$\n\\mathrm{TVD}_{\\mathrm{rej}} = 0.\n$$\nThe acceptance probability is $\\alpha = \\frac{qn}{m} = 1 - \\frac{r}{m}$, and the number of base draws $D$ required is a geometric random variable with success probability $\\alpha$, so the expected number of base draws per accepted output is\n$$\n\\mathbb{E}[D] = \\frac{1}{\\alpha} = \\frac{1}{1 - \\frac{r}{m}}.\n$$\nIn the special case $r=0$ (that is, when $n$ divides $m$), we have $\\alpha = 1$ and $\\mathbb{E}[D] = 1$.\n\nAlgorithmic design:\nGiven $(a,b)$, compute $n = b-a+1$, then compute $q = \\left\\lfloor \\frac{m}{n} \\right\\rfloor$ and $r = m - qn$. Using these, evaluate:\n- $\\mathrm{TVD}_{\\mathrm{mod}} = \\frac{r(n-r)}{mn}$.\n- $\\mathrm{TVD}_{\\mathrm{rej}} = 0$.\n- $\\mathbb{E}[D] = \\frac{1}{1 - \\frac{r}{m}}$ (with the convention $\\mathbb{E}[D]=1$ when $r=0$).\nNo random sampling is required; these are closed-form computations.\n\nTest suite coverage:\n- Case $n=10$ tests a general nondividing case ($r \\neq 0$).\n- Case $n=1$ tests a degenerate interval (always uniform, zero bias).\n- Case $n=5$ tests inclusion of negative bounds and a small nondividing case.\n- Case $n=65536$ tests the exact-dividing case ($n$ divides $m$).\n- Case $n=1{,}000{,}011$ tests a large nondividing case.\n\nOutput format:\nFor each case, output $[\\mathrm{TVD}_{\\mathrm{mod}}, \\mathrm{TVD}_{\\mathrm{rej}}, \\mathbb{E}[D]]$. Aggregate all five case results as a single comma-separated list enclosed in square brackets, with no spaces, e.g., \"[[x1,y1,z1],[x2,y2,z2],...]\" printed on a single line.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_metrics(a: int, b: int, m: int) -> tuple[float, float, float]:\n    \"\"\"\n    Compute (TVD_mod, TVD_rej, E[D]) for target range [a,b],\n    given base PRNG modulus m (here m=2^32).\n    \"\"\"\n    n = b - a + 1\n    if n <= 0:\n        raise ValueError(\"Invalid range: b must be >= a.\")\n    # Compute q and r\n    q = m // n\n    r = m - q * n  # same as m % n, but avoids negatives\n    # Total variation distance for modulo method: r*(n-r)/(m*n)\n    tvd_mod = (r * (n - r)) / (m * n)\n    # Rejection sampling is exactly uniform\n    tvd_rej = 0.0\n    # Expected number of base draws per accepted output: 1 / (1 - r/m)\n    if r == 0:\n        expected_draws = 1.0\n    else:\n        expected_draws = 1.0 / (1.0 - (r / m))\n    return float(tvd_mod), float(tvd_rej), float(expected_draws)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 9),          # n=10\n        (5, 5),          # n=1\n        (-2, 2),         # n=5\n        (0, 65535),      # n=65536 (divides 2^32)\n        (-10, 10**6),    # n=1_000_011\n    ]\n    # Base PRNG modulus m = 2^32\n    m = 2 ** 32\n\n    results_str = []\n    for a, b in test_cases:\n        tvd_mod, tvd_rej, expected_draws = compute_metrics(a, b, m)\n        # Format numbers using a consistent, compact representation\n        # Use .17g for good precision without excessive digits\n        sub = \"[\" + \",\".join([\n            format(tvd_mod, \".17g\"),\n            format(tvd_rej, \".17g\"),\n            format(expected_draws, \".17g\"),\n        ]) + \"]\"\n        results_str.append(sub)\n\n    # Final print statement in the exact required format (no spaces).\n    print(f\"[{','.join(results_str)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "The quality of a PRNG can be viewed through different lenses: for many Monte Carlo simulations, passing statistical tests for randomness is sufficient, but for applications involving security or unpredictability, a higher standard is required. This exercise illuminates the fundamental difference between statistical PRNGs and cryptographically secure PRNGs (CSPRNGs) by tasking you with \"cracking\" a simple LCG from a few of its outputs [@problem_id:2423284]. Successfully predicting the LCG sequence—and failing to do so for a modern CSPRNG—provides a powerful, hands-on demonstration of what makes a generator truly unpredictable and suitable for sensitive applications.", "id": "2423284", "problem": "You are given two classes of generators that are used to produce discrete uniform variates in computational economics and finance: a linear congruential generator and a cryptographically secure generator constructed from a cryptographic hash in counter mode. Your task is to implement a predictor that, after passively observing three consecutive outputs of a generator, attempts to predict the next output. The predictor should succeed for the linear congruential generator and fail for the cryptographically secure generator.\n\nFundamental base and definitions:\n- A linear congruential generator (LCG) is defined by the recurrence\n$$X_{t+1} \\equiv a X_t + c \\pmod{m},$$\nwith state $X_t \\in \\{0,1,\\dots,m-1\\}$, modulus $m \\in \\mathbb{N}$, multiplier $a \\in \\{0,1,\\dots,m-1\\}$, increment $c \\in \\{0,1,\\dots,m-1\\}$, and an initial seed $X_0$. It produces discrete uniform variates by mapping $U_t = X_t/m \\in [0,1)$.\n- The cryptographically secure generator used here is specified as follows: let $H$ be the Secure Hash Algorithm 256-bit hash function (SHA-256). For a given byte-string seed $s$ and a prime modulus $m$, define\n$$X_t \\equiv \\mathrm{int}\\big(H(s \\,\\|\\, \\mathrm{encode}_{8}(t))\\big) \\bmod m,$$\nwhere $\\mathrm{encode}_{8}(t)$ is the $8$-byte big-endian encoding of the nonnegative integer $t$, $\\|$ denotes concatenation, and $\\mathrm{int}(\\cdot)$ interprets the $32$-byte hash output as a nonnegative integer in base $256$. This construction is a standard counter-based pseudorandom number generator using a cryptographic primitive, and its outputs are intended to be computationally unpredictable.\n\nYour program must implement the following:\n1. A function that, given a modulus $m$ and three consecutive observed states $(x_0,x_1,x_2)$ from a single generator, attempts to infer parameters $(a,c)$ consistent with the LCG definition and predict the next state $\\hat{x}_3 \\equiv a x_2 + c \\pmod{m}$. If multiple $(a,c)$ satisfy the congruences with the given observations or if modular inversion is impossible in your method, you may choose any consistent rule, but you must return a single integer prediction $\\hat{x}_3 \\in \\{0,1,\\dots,m-1\\}$.\n2. For each test case, compute the true next state $x_3$ using the specified ground-truth generator. Report whether your predictor’s $\\hat{x}_3$ equals the true $x_3$ as a boolean.\n\nTest suite:\n- Case A (LCG, happy path): $m = 2147483647$, $a = 48271$, $c = 0$, $X_0 = 12345$.\n- Case B (LCG, nonzero increment): $m = 1000003$, $a = 35011$, $c = 7919$, $X_0 = 424242$.\n- Case C (LCG, boundary where $a = 1$): $m = 101$, $a = 1$, $c = 1$, $X_0 = 17$.\n- Case D (cryptographically secure generator): prime modulus $m = 4294967291$, seed $s$ equal to the ASCII byte-string of the text “econ-secure”. The generator is $X_t \\equiv \\mathrm{int}\\big(H(s \\,\\|\\, \\mathrm{encode}_{8}(t))\\big) \\bmod m$ with $H$ being SHA-256.\n\nFor each case, proceed as follows:\n- Generate the first four consecutive states $X_0, X_1, X_2, X_3$ using the specified ground-truth generator and parameters.\n- Give the predictor only $(m, X_0, X_1, X_2)$ and let it compute $\\hat{X}_3$ by fitting an LCG as per item $1$ above.\n- Compute a boolean $b$ that is $\\mathrm{True}$ if $\\hat{X}_3 = X_3$ and $\\mathrm{False}$ otherwise.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets (e.g., “[True,False,True,False]”), in the order Case A, Case B, Case C, Case D.\n\nNotes and requirements:\n- All quantities are dimensionless counts; no physical units are involved.\n- Angles are not involved.\n- Do not use percentage signs; no percentages are required.\n- Design your predictor strictly from the definitions provided. Do not hard-code the answers.\n- Ensure your program is self-contained and does not read any input.", "solution": "The problem as stated is valid. It is scientifically grounded in the fields of number theory and cryptography, is well-posed with a clear and achievable objective, and is free of ambiguity or contradiction. It correctly frames a fundamental dichotomy between statistically random sequences, which may be predictable, and cryptographically secure sequences, which are designed to be unpredictable. We shall therefore proceed with a full solution.\n\nThe task is to differentiate between a linear congruential generator (LCG) and a cryptographically secure pseudorandom number generator (CSPRNG) by attempting to predict the next term in a sequence after observing three consecutive terms. The success or failure of this prediction serves to classify the generator.\n\nThe LCG is defined by the linear recurrence relation:\n$$X_{t+1} \\equiv a X_t + c \\pmod{m}$$\nwhere $a$ is the multiplier, $c$ is the increment, and $m$ is the modulus. This linear structure is its critical vulnerability. Given three observed consecutive states, $x_0$, $x_1$, and $x_2$, we can construct a system of two linear congruences with two unknowns, a and c:\n$$\n\\begin{cases}\nx_1 \\equiv a x_0 + c \\pmod{m} \\\\\nx_2 \\equiv a x_1 + c \\pmod{m}\n\\end{cases}\n$$\nTo solve for the unknown parameters, we first eliminate $c$ by subtracting the first congruence from the second:\n$$x_2 - x_1 \\equiv (a x_1 + c) - (a x_0 + c) \\pmod{m}$$\n$$x_2 - x_1 \\equiv a (x_1 - x_0) \\pmod{m}$$\nLet $\\Delta_0 = x_1 - x_0$ and $\\Delta_1 = x_2 - x_1$. The congruence simplifies to $\\Delta_1 \\equiv a \\Delta_0 \\pmod{m}$. We can solve for $a$ by multiplying by the modular multiplicative inverse of $\\Delta_0$ modulo $m$. This inverse, $\\Delta_0^{-1}$, exists if and only if $\\text{gcd}(\\Delta_0, m) = 1$. The test cases utilize prime moduli $m$, for which this condition holds unless $\\Delta_0$ is a multiple of $m$, i.e., $x_1 \\equiv x_0 \\pmod{m}$. Assuming $x_1 \\not\\equiv x_0 \\pmod{m}$, we find a unique solution for the multiplier $\\hat{a}$:\n$$\\hat{a} \\equiv \\Delta_1 \\cdot (\\Delta_0 \\pmod m)^{-1} \\pmod{m}$$\nOnce $\\hat{a}$ is determined, we substitute it back into the first congruence to solve for the increment $\\hat{c}$:\n$$\\hat{c} \\equiv x_1 - \\hat{a} x_0 \\pmod{m}$$\nHaving recovered the parameters $(\\hat{a}, \\hat{c})$, we can predict the next state, $\\hat{x}_3$, using the LCG recurrence:\n$$\\hat{x}_3 \\equiv \\hat{a} x_2 + \\hat{c} \\pmod{m}$$\nIf the observed sequence was indeed produced by an LCG, our recovered parameters $(\\hat{a}, \\hat{c})$ will be identical to the generator's true parameters, and our prediction $\\hat{x}_3$ will equal the true state $X_3$.\n\nThe cryptographically secure generator, in contrast, is designed to make such prediction computationally infeasible. Its definition is:\n$$X_t \\equiv \\mathrm{int}\\big(H(s \\,\\|\\, \\mathrm{encode}_{8}(t))\\big) \\bmod m$$\nHere, $H$ is the SHA-$256$ cryptographic hash function. The output $X_t$ is a complex, non-linear transformation of a simple counter $t$. There is no simple algebraic relationship between consecutive terms $X_t$ and $X_{t+1}$. While our predictor can still be applied to a sequence from this generator—it will always find some LCG parameters $(\\hat{a}, \\hat{c})$ that fit any three points $(x_0, x_1, x_2)$ (provided $x_1 \\not\\equiv x_0 \\pmod m$)—these parameters are mere artifacts. They describe a line passing through three effectively random points and have no bearing on the underlying generation process. The true next state, $X_3$, is determined by an independent evaluation of the hash function at $t=3$. The probability that our prediction $\\hat{x}_3$ matches $X_3$ is vanishingly small, approximately $1/m$.\n\nThus, our algorithm will generate the true sequence $(X_0, X_1, X_2, X_3)$ for each test case, apply the LCG predictor to $(X_0, X_1, X_2)$ to compute $\\hat{X}_3$, and report whether $\\hat{X}_3 = X_3$. We expect a positive result for all LCG cases and a negative result for the CSPRNG case, thereby demonstrating the principle of unpredictability.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport hashlib\n\ndef solve():\n    \"\"\"\n    Main function to run the prediction tests and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A (LCG, happy path)\",\n            \"type\": \"lcg\",\n            \"m\": 2147483647,\n            \"a\": 48271,\n            \"c\": 0,\n            \"x0\": 12345,\n            \"seed\": None,\n        },\n        {\n            \"name\": \"Case B (LCG, nonzero increment)\",\n            \"type\": \"lcg\",\n            \"m\": 1000003,\n            \"a\": 35011,\n            \"c\": 7919,\n            \"x0\": 424242,\n            \"seed\": None,\n        },\n        {\n            \"name\": \"Case C (LCG, boundary where a = 1)\",\n            \"type\": \"lcg\",\n            \"m\": 101,\n            \"a\": 1,\n            \"c\": 1,\n            \"x0\": 17,\n            \"seed\": None,\n        },\n        {\n            \"name\": \"Case D (cryptographically secure generator)\",\n            \"type\": \"csg\",\n            \"m\": 4294967291,\n            \"a\": None,\n            \"c\": None,\n            \"x0\": None,\n            \"seed\": b\"econ-secure\",\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Generate the ground-truth sequence of 4 states (X0, X1, X2, X3)\n        if case[\"type\"] == \"lcg\":\n            true_sequence = generate_lcg_sequence(\n                case[\"m\"], case[\"a\"], case[\"c\"], case[\"x0\"], 4\n            )\n        elif case[\"type\"] == \"csg\":\n            true_sequence = generate_csg_sequence(case[\"m\"], case[\"seed\"], 4)\n        else:\n            raise ValueError(f\"Unknown generator type: {case['type']}\")\n\n        x0, x1, x2, x3_true = true_sequence\n\n        # Predict the next state assuming an LCG model\n        x3_pred = predict_next_lcg(case[\"m\"], x0, x1, x2)\n\n        # Compare the prediction with the true state\n        results.append(x3_pred == x3_true)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_lcg_sequence(m, a, c, x0, count):\n    \"\"\"\n    Generates a sequence of numbers from a Linear Congruential Generator.\n    X_{t+1} = (a * X_t + c) % m\n    \"\"\"\n    sequence = []\n    x_current = x0\n    for _ in range(count):\n        sequence.append(x_current)\n        x_current = (a * x_current + c) % m\n    return sequence\n\ndef generate_csg_sequence(m, seed, count):\n    \"\"\"\n    Generates a sequence from a SHA-256 counter-based generator.\n    X_t = int(SHA256(seed || encode_8(t))) % m\n    \"\"\"\n    sequence = []\n    for t in range(count):\n        t_bytes = t.to_bytes(8, 'big')\n        data_to_hash = seed + t_bytes\n        h = hashlib.sha256(data_to_hash).digest()\n        int_hash = int.from_bytes(h, 'big')\n        x_t = int_hash % m\n        sequence.append(x_t)\n    return sequence\n\ndef predict_next_lcg(m, x0, x1, x2):\n    \"\"\"\n    Predicts the next state (x3) from three previous states (x0, x1, x2)\n    by inferring the parameters of an LCG.\n    \"\"\"\n    # System to solve for a_hat, c_hat:\n    # x1 = a*x0 + c (mod m)\n    # x2 = a*x1 + c (mod m)\n    # Subtracting gives: x2 - x1 = a * (x1 - x0) (mod m)\n    \n    delta0 = (x1 - x0) % m\n    delta1 = (x2 - x1) % m\n\n    try:\n        # To solve a_hat * delta0 = delta1 (mod m), we need the modular inverse of delta0.\n        # pow(base, -1, mod) computes this efficiently.\n        inv_delta0 = pow(delta0, -1, m)\n        a_hat = (delta1 * inv_delta0) % m\n    except ValueError:\n        # This occurs if gcd(delta0, m) != 1. Since all test case moduli are prime,\n        # this only happens if delta0 = 0 (mod m), i.e., x1 == x0.\n        # If x1 = x0, the congruence is 0 = delta1 (mod m), so we must have x2 = x1.\n        if delta1 == 0:  # Case x0 = x1 = x2, a constant sequence\n            # The recurrence is x0 = a*x0 + c. Prediction for x3 is a*x2 + c = a*x0 + c = x0.\n            # So, the next term is also x0 (or x2, which is the same).\n            return x2\n        else: # Case x0 = x1 but x2 != x1.\n            # This sequence cannot be from an LCG. As per problem, we must return a prediction.\n            # We choose a default of 0.\n            return 0\n\n    # Solve for c_hat using c_hat = x1 - a_hat * x0 (mod m)\n    c_hat = (x1 - a_hat * x0) % m\n\n    # Predict x3_hat = a_hat * x2 + c_hat (mod m)\n    x3_hat = (a_hat * x2 + c_hat) % m\n\n    return x3_hat\n\nsolve()\n```"}]}