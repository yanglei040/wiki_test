{"hands_on_practices": [{"introduction": "Many systems in finance and economics, from stock exchange matching engines to bank teller lines, can be analyzed as queues. This exercise introduces you to Discrete-Event Simulation (DES), a powerful technique for modeling systems that evolve through a sequence of events over time. By simulating individual order arrivals and their processing, you will estimate key performance metrics like average waiting time and gain insight into system stability and the concept of a \"burn-in\" period needed to observe steady-state behavior [@problem_id:2403274].", "id": "2403274", "problem": "You will build a discrete-event simulator for a single-server queue representing a high-frequency trading exchange’s matching engine. Orders arrive as a Poisson process with rate parameter $\\lambda$ (orders per second), and each order’s processing time is exponentially distributed with rate parameter $\\mu$ (orders per second). The server follows a First-Come, First-Served (FCFS) discipline. The system starts empty and idle at time $t=0$. Your task is to estimate the average waiting time in queue (that is, the time from an order’s arrival until it begins service) in seconds.\n\nBase your simulation on the following definitions:\n- A Poisson arrival process with rate $\\lambda$ has independent and stationary increments. Equivalently, the interarrival times $\\{I_i\\}_{i \\ge 1}$ are independent and identically distributed exponential random variables with mean $1/\\lambda$.\n- Exponential service times $\\{X_i\\}_{i \\ge 1}$ have mean $1/\\mu$, independent of arrivals and of each other.\n- Let $A_i$ denote the arrival time of the $i$-th order, $S_i$ the service start time, and $C_i$ the completion time. The waiting time in queue of the $i$-th order is $W_i = S_i - A_i$. The average waiting time estimator after discarding a burn-in of $b$ orders is\n$$\n\\widehat{W}_q = \\frac{1}{N - b} \\sum_{i=b+1}^{N} W_i.\n$$\n\nImplementation requirements:\n- The simulator must start with an empty system and idle server at $t=0$.\n- Generate interarrival times $\\{I_i\\}$ as independent exponential random variables with mean $1/\\lambda$, and service times $\\{X_i\\}$ as independent exponential random variables with mean $1/\\mu$.\n- Construct arrival times as $A_i = \\sum_{j=1}^{i} I_j$, and enforce FCFS service with a single server.\n- Estimate $\\widehat{W}_q$ in seconds for each parameter set by discarding the first $b$ waiting times (burn-in) and averaging the remainder.\n- Initialize the random number generator exactly once at the beginning with seed $123456$ to ensure reproducibility across the entire test suite.\n- Time is measured in seconds. Your program must print the estimates in seconds, rounded to six decimal places.\n\nTest suite:\nRun your simulator for the following five parameter sets $(\\lambda, \\mu, N, b)$, where $N$ is the total number of arrivals simulated and $b$ is the burn-in:\n1. $(800.0, 1000.0, 200000, 5000)$\n2. $(100.0, 1000.0, 200000, 5000)$\n3. $(990.0, 1000.0, 200000, 5000)$\n4. $(450.0, 500.0, 200000, 5000)$\n5. $(1000.0, 1000.0, 200000, 5000)$\n\nFinal output format:\nYour program should produce a single line of output containing the five estimated average waiting times in queue, in seconds, rounded to six decimal places, as a comma-separated list enclosed in square brackets, with no spaces. For example,\n\"[0.004123,0.000111,0.098765,0.018400,0.537219]\".", "solution": "The problem presented requires the construction of a discrete-event simulator for a single-server queue, known in queueing theory as an M/M/1 queue. The system models a high-frequency trading exchange's matching engine. Arrivals follow a Poisson process, and service times are exponentially distributed. The service discipline is First-Come, First-Served (FCFS). Our objective is to estimate the average waiting time in the queue, $\\widehat{W}_q$.\n\nThe problem is scientifically and computationally well-posed. It is grounded in the established principles of queueing theory, a standard tool for performance analysis. All necessary parameters ($\\lambda, \\mu, N, b$) and initial conditions (system empty and idle at $t=0$) are provided, along with a specified random number generator seed, ensuring a unique and reproducible computational result. The problem is therefore valid.\n\nLet the Poisson arrival rate be $\\lambda$ and the exponential service rate be $\\mu$. The corresponding mean interarrival time is $1/\\lambda$ and the mean service time is $1/\\mu$. We denote the interarrival time between order $i-1$ and $i$ as $I_i$, and the service time of order $i$ as $X_i$.\n\nThe core of the simulation is a set of recurrence relations that describe the system's state evolution over time. Let $A_i$, $S_i$, and $C_i$ be the arrival time, service start time, and completion time for the $i$-th order, for $i \\in \\{1, 2, \\dots, N\\}$.\n\nThe arrival time of the $i$-th order is given by the cumulative sum of interarrival times:\n$$\nA_i = \\sum_{j=1}^{i} I_j \\quad \\text{with } A_0 = 0\n$$\nwhich can be computed iteratively as $A_i = A_{i-1} + I_i$.\n\nThe system starts empty, so the first order ($i=1$) begins service immediately upon arrival: $S_1 = A_1$. Its completion time is $C_1 = S_1 + X_1$.\n\nFor any subsequent order $i > 1$, its service can only begin after it has arrived (at time $A_i$) and after the server is free. The server becomes free upon completing service for the previous order, at time $C_{i-1}$. Thus, the service start time for order $i$ is determined by the later of these two events:\n$$\nS_i = \\max(A_i, C_{i-1})\n$$\nThe completion time for order $i$ is then:\n$$\nC_i = S_i + X_i\n$$\nThe waiting time in queue for order $i$, $W_i$, is the time elapsed from its arrival until its service begins:\n$$\nW_i = S_i - A_i = \\max(A_i, C_{i-1}) - A_i = \\max(0, C_{i-1} - A_i)\n$$\nThis set of relations allows for an iterative simulation of the queueing process.\n\nThe traffic intensity, $\\rho = \\lambda/\\mu$, is a critical parameter. For a stable steady-state to exist, we must have $\\rho < 1$. In such cases, the theoretical average waiting time is $W_q = \\frac{\\rho}{\\mu(1-\\rho)}$. Test case 5, where $(\\lambda, \\mu) = (1000.0, 1000.0)$, corresponds to $\\rho=1$. This is a null-recurrent Markov chain, for which the expected waiting time is infinite. However, the computational task of running a simulation for a finite number of orders $N$ remains well-defined and will produce a finite result. This result is understood not as an estimate of a finite steady-state mean, but as the outcome of the specified finite-time process.\n\nThe simulation algorithm proceeds as follows:\n$1$. Initialize a single random number generator with the seed $123456$.\n$2$. For each test case $(\\lambda, \\mu, N, b)$:\n    a. Generate $N$ i.i.d. interarrival times $\\{I_i\\}_{i=1}^N$ from an exponential distribution with mean $1/\\lambda$.\n    b. Generate $N$ i.i.d. service times $\\{X_i\\}_{i=1}^N$ from an exponential distribution with mean $1/\\mu$.\n    c. Initialize `arrival_time` and `completion_time_of_previous_customer` to $0.0$.\n    d. Iterate from $i=1$ to $N$, updating `arrival_time` with $I_i$, and calculating $S_i$, $W_i$, and $C_i$ using the recurrence relations. The value of $C_{i-1}$ is tracked by `completion_time_of_previous_customer`. Store each $W_i$.\n$3$. After simulating all $N$ orders, the first $b$ waiting times are discarded to remove the transient effects of the initial empty-and-idle state (burn-in).\n$4$. The average waiting time is estimated as the sample mean of the remaining $N-b$ observations:\n$$\n\\widehat{W}_q = \\frac{1}{N - b} \\sum_{i=b+1}^{N} W_i\n$$\nThis computed value, rounded to six decimal places, constitutes the required output for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_queue(lambda_rate, mu_rate, N, b, rng):\n    \"\"\"\n    Simulates a single-server M/M/1 queue to estimate average waiting time.\n\n    Args:\n        lambda_rate (float): Arrival rate of orders.\n        mu_rate (float): Service rate of orders.\n        N (int): Total number of orders to simulate.\n        b (int): Number of burn-in orders to discard.\n        rng (numpy.random.Generator): The random number generator instance.\n\n    Returns:\n        float: The estimated average waiting time in the queue.\n    \"\"\"\n    # Scale parameter for exponential distribution is the mean.\n    # Mean interarrival time = 1 / lambda_rate\n    # Mean service time = 1 / mu_rate\n    interarrival_times = rng.exponential(scale=1.0/lambda_rate, size=N)\n    service_times = rng.exponential(scale=1.0/mu_rate, size=N)\n\n    # Initialize simulation state variables\n    current_arrival_time = 0.0\n    # Tracks the completion time of the previous customer, C_{i-1}\n    completion_time_of_previous = 0.0\n    waiting_times = np.zeros(N)\n\n    # Main simulation loop over N customers\n    for i in range(N):\n        # Calculate arrival time of current customer: A_i = A_{i-1} + I_i\n        current_arrival_time += interarrival_times[i]\n        \n        # Service start time: S_i = max(A_i, C_{i-1})\n        service_start_time = max(current_arrival_time, completion_time_of_previous)\n        \n        # Waiting time in queue: W_i = S_i - A_i\n        waiting_times[i] = service_start_time - current_arrival_time\n        \n        # Update completion time for the next iteration: C_i = S_i + X_i\n        completion_time_of_previous = service_start_time + service_times[i]\n\n    # Calculate the average waiting time after the burn-in period\n    # np.mean on the slice waiting_times[b:N] is equivalent to the formula in the problem.\n    avg_waiting_time = np.mean(waiting_times[b:])\n    \n    return avg_waiting_time\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    # Initialize the random number generator exactly once at the beginning\n    # with seed 123456 to ensure reproducibility.\n    rng = np.random.default_rng(123456)\n    \n    # Define the test cases from the problem statement.\n    # Format: (lambda, mu, N, b)\n    test_cases = [\n        (800.0, 1000.0, 200000, 5000),\n        (100.0, 1000.0, 200000, 5000),\n        (990.0, 1000.0, 200000, 5000),\n        (450.0, 500.0, 200000, 5000),\n        (1000.0, 1000.0, 200000, 5000)\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_rate, mu_rate, N, b = case\n        estimated_wait = simulate_queue(lambda_rate, mu_rate, N, b, rng)\n        # Format the result to six decimal places, as a string.\n        results.append(f\"{estimated_wait:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "Monte Carlo simulation is a cornerstone of modern computational finance, used to price complex derivatives by averaging their payoffs over thousands of possible futures. This practice provides a perfect entry point by asking you to price a simple digital option, whose payoff depends only on whether the asset price finishes above a certain strike. The true power of this exercise [@problem_id:2403319] lies in its focus on estimation error; by computing the analytical price and comparing it to your simulation results, you will develop a crucial understanding of how to measure and interpret the precision of your Monte Carlo estimates.", "id": "2403319", "problem": "You are asked to implement a complete, runnable program that prices a digital cash-or-nothing call option by Monte Carlo simulation and analyzes how the Monte Carlo error behaves as the strike price approaches the threshold where the option has the highest variance under the risk-neutral measure. Work within the canonical Black–Scholes framework under the risk-neutral measure. All notation is defined below.\n\nDefinitions and modeling assumptions:\n- The underlying asset price process $\\{S_t\\}_{t \\ge 0}$ follows a geometric Brownian motion under the risk-neutral measure with drift equal to the continuously compounded risk-free rate $r$, that is, $dS_t = r S_t \\, dt + \\sigma S_t \\, dW_t$, where $\\sigma &gt; 0$ is constant volatility and $\\{W_t\\}_{t \\ge 0}$ is a standard Wiener process.\n- The time-$0$ spot is $S_0$, the maturity is $T &gt; 0$, the strike is $K &gt; 0$, and the option pays a fixed cash amount $L &gt; 0$ at time $T$ if and only if $S_T \\ge K$, and otherwise pays $0$. The discount factor to time $0$ is $\\exp(-rT)$.\n\nFundamental base:\n- Under the risk-neutral measure, $S_T$ is lognormal and $\\ln S_T$ is normally distributed with mean $\\ln S_0 + (r - \\tfrac{1}{2}\\sigma^2)T$ and variance $\\sigma^2 T$.\n- Risk-neutral valuation states that the time-$0$ price of any integrable payoff $X_T$ is $\\exp(-rT)\\,\\mathbb{E}[X_T]$ where the expectation is taken under the risk-neutral measure.\n\nTasks to implement and compute:\n1. Implement a Monte Carlo estimator for the price of the digital cash-or-nothing call option by simulating $N$ independent draws of $S_T$ using the lognormal representation implied by the model. Use the same stream of standard normal draws for all strikes (common random numbers) to isolate how the strike alone affects the Monte Carlo error. Use a fixed random seed for reproducibility.\n2. Compute for each strike $K$:\n   - The Monte Carlo price estimate $\\hat{C}_{\\text{MC}}(K) = \\exp(-rT)\\,\\frac{1}{N}\\sum_{i=1}^{N} L \\,\\mathbf{1}\\{S_T^{(i)} \\ge K\\}$.\n   - The Monte Carlo standard error $\\widehat{\\text{se}}_{\\text{MC}}(K) = \\exp(-rT)\\,\\frac{\\widehat{\\sigma}_{\\text{payoff}}}{\\sqrt{N}}$, where $\\widehat{\\sigma}_{\\text{payoff}}$ is the sample standard deviation of the undiscounted simulated payoffs $L \\,\\mathbf{1}\\{S_T^{(i)} \\ge K\\}$ computed with population normalization.\n3. Derive and compute the analytical price $C_{\\text{BS}}(K)$ starting from the fundamental base. Do not assume any pricing shortcut that is not derived from the model’s Gaussian property of $\\ln S_T$ and risk-neutral valuation. Also derive and compute the corresponding analytical Monte Carlo standard error $\\text{se}_{\\text{BS}}(K)$ by using the variance of a Bernoulli random variable with success probability $p(K) = \\mathbb{P}(S_T \\ge K)$.\n4. Use the following parameter values for a test suite of strikes to demonstrate how the Monte Carlo error behaves as the strike moves around the level of maximal variance:\n   - Global parameters: $S_0 = 100$, $r = 0.02$, $\\sigma = 0.2$, $T = 1$, $L = 1$, $N = 200000$.\n   - Strikes to evaluate: $K \\in \\{60, 90, 100, 110, 140\\}$.\n   - Use a fixed seed equal to $123456$ for the pseudo-random number generator and use common random numbers across the different strikes.\n\nAnswer specification and output format:\n- For each strike $K$ in the specified set, your program must compute a list with the following five entries in this exact order: $[K, \\hat{C}_{\\text{MC}}(K), C_{\\text{BS}}(K), \\widehat{\\text{se}}_{\\text{MC}}(K), \\text{se}_{\\text{BS}}(K)]$.\n- The final program output must be a single line consisting of a bracketed, comma-separated list of these per-strike lists in the same strike order as provided. For example, a syntactically valid output has the structure $[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\dots]$ with decimal numbers only. Do not print any additional text.\n\nNotes:\n- Express all outputs as decimals (floating-point numbers) without any currency symbols.\n- Angles are not used; no angle unit is required.", "solution": "The problem presented is a standard exercise in computational finance and is scientifically well-grounded, well-posed, and complete. It is validated as a legitimate problem for which a solution can be constructed. The task is to price a digital cash-or-nothing call option using both an analytical formula derived from the Black-Scholes model and a Monte Carlo simulation. We will also analyze the behavior of the Monte Carlo estimation error.\n\nFirst, we derive the analytical price for the option. The option's payoff at maturity $T$ is $L$ if the asset price $S_T$ is at or above the strike $K$, and $0$ otherwise. The payoff function is $X_T = L \\cdot \\mathbf{1}\\{S_T \\ge K\\}$, where $\\mathbf{1}\\{\\cdot\\}$ is the indicator function. According to the principle of risk-neutral valuation, the price of the option at time $t=0$, denoted $C(K)$, is the discounted expected payoff under the risk-neutral measure $\\mathbb{Q}$:\n$$C(K) = e^{-rT} \\mathbb{E}^{\\mathbb{Q}}[X_T] = e^{-rT} \\mathbb{E}^{\\mathbb{Q}}[L \\cdot \\mathbf{1}\\{S_T \\ge K\\}]$$\nBy linearity of expectation, this becomes:\n$$C(K) = L e^{-rT} \\mathbb{E}^{\\mathbb{Q}}[\\mathbf{1}\\{S_T \\ge K\\}] = L e^{-rT} \\mathbb{Q}(S_T \\ge K)$$\nThe problem states that under $\\mathbb{Q}$, the asset price follows a geometric Brownian motion, which implies that $\\ln S_T$ is normally distributed. The mean and variance are given as:\n$$\\ln S_T \\sim \\mathcal{N}\\left(\\ln S_0 + (r - \\frac{1}{2}\\sigma^2)T, \\sigma^2 T\\right)$$\nTo compute the probability $\\mathbb{Q}(S_T \\ge K)$, we standardize the random variable $\\ln S_T$. The condition $S_T \\ge K$ is equivalent to $\\ln S_T \\ge \\ln K$:\n$$\\mathbb{Q}(\\ln S_T \\ge \\ln K) = \\mathbb{Q}\\left(\\frac{\\ln S_T - (\\ln S_0 + (r - \\frac{1}{2}\\sigma^2)T)}{\\sigma\\sqrt{T}} \\ge \\frac{\\ln K - (\\ln S_0 + (r - \\frac{1}{2}\\sigma^2)T)}{\\sigma\\sqrt{T}}\\right)$$\nThe term on the left is a standard normal random variable, $Z \\sim \\mathcal{N}(0, 1)$. The expression on the right is commonly manipulated into the standard Black-Scholes $d_2$ parameter:\n$$d_2 = \\frac{\\ln(S_0/K) + (r - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}$$\nThus, the probability is:\n$$\\mathbb{Q}(S_T \\ge K) = \\mathbb{Q}(Z \\ge -d_2) = \\mathbb{Q}(Z \\le d_2) = \\Phi(d_2)$$\nwhere $\\Phi(\\cdot)$ is the cumulative distribution function (CDF) of the standard normal distribution. The analytical price, which we denote $C_{\\text{BS}}(K)$, is therefore:\n$$C_{\\text{BS}}(K) = L e^{-rT} \\Phi(d_2)$$\n\nNext, we derive the analytical formula for the standard error of the Monte Carlo estimator. The Monte Carlo price estimator is $\\hat{C}_{\\text{MC}}(K) = e^{-rT} \\frac{1}{N}\\sum_{i=1}^{N} Y^{(i)}$, where $Y^{(i)} = L \\cdot \\mathbf{1}\\{S_T^{(i)} \\ge K\\}$ are independent samples of the undiscounted payoff. The standard error is the square root of the variance of this estimator:\n$$\\text{se}(\\hat{C}_{\\text{MC}}(K)) = \\sqrt{\\text{Var}(\\hat{C}_{\\text{MC}}(K))} = \\sqrt{\\text{Var}\\left(e^{-rT} \\frac{1}{N}\\sum_{i=1}^{N} Y^{(i)}\\right)}$$\nUsing the properties of variance, this simplifies to:\n$$\\text{se}(\\hat{C}_{\\text{MC}}(K)) = e^{-rT} \\sqrt{\\frac{\\text{Var}(Y^{(1)})}{N}} = \\frac{e^{-rT} \\sigma_{\\text{payoff}}}{\\sqrt{N}}$$\nwhere $\\sigma_{\\text{payoff}}$ is the standard deviation of a single undiscounted payoff. The payoff random variable $Y = L \\cdot \\mathbf{1}\\{S_T \\ge K\\}$ is a scaled Bernoulli variable. It takes the value $L$ with success probability $p(K) = \\mathbb{Q}(S_T \\ge K) = \\Phi(d_2)$ and $0$ otherwise. The variance of $Y$ is:\n$$\\text{Var}(Y) = \\mathbb{E}[Y^2] - (\\mathbb{E}[Y])^2 = (L^2 \\cdot p(K)) - (L \\cdot p(K))^2 = L^2 p(K)(1 - p(K))$$\nThe standard deviation of the payoff is $\\sigma_{\\text{payoff}} = \\sqrt{\\text{Var}(Y)} = L \\sqrt{p(K)(1 - p(K))}$. Therefore, the analytical Monte Carlo standard error, denoted $\\text{se}_{\\text{BS}}(K)$, is:\n$$\\text{se}_{\\text{BS}}(K) = \\frac{e^{-rT} L \\sqrt{\\Phi(d_2)(1 - \\Phi(d_2))}}{\\sqrt{N}}$$\n\nThe Monte Carlo simulation is implemented by generating $N$ independent draws of a standard normal random variable $Z^{(i)}$, and using these to compute $N$ simulated terminal asset prices:\n$$S_T^{(i)} = S_0 \\exp\\left( \\left(r - \\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T} Z^{(i)} \\right)$$\nFor each strike $K$, the Monte Carlo price estimate $\\hat{C}_{\\text{MC}}(K)$ is the discounted sample mean of the simulated payoffs:\n$$\\hat{C}_{\\text{MC}}(K) = e^{-rT} \\frac{1}{N} \\sum_{i=1}^{N} L \\cdot \\mathbf{1}\\{S_T^{(i)} \\ge K\\}$$\nThe estimated standard error, $\\widehat{\\text{se}}_{\\text{MC}}(K)$, is computed using the sample standard deviation of the undiscounted payoffs, $\\widehat{\\sigma}_{\\text{payoff}}$. As specified, population normalization (dividing by $N$) is used:\n$$\\widehat{\\sigma}_{\\text{payoff}} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left(Y^{(i)} - \\bar{Y}\\right)^2}, \\quad \\text{where } \\bar{Y} = \\frac{1}{N} \\sum_{i=1}^{N} Y^{(i)}$$\n$$\\widehat{\\text{se}}_{\\text{MC}}(K) = e^{-rT} \\frac{\\widehat{\\sigma}_{\\text{payoff}}}{\\sqrt{N}}$$\nTo ensure comparability across different strikes, common random numbers are used, meaning the same set of $N$ draws $\\{Z^{(i)}\\}$ is used to generate the asset price paths $\\{S_T^{(i)}\\}$ for all values of $K$. A fixed seed is used for the random number generator to ensure reproducibility.\n\nThe Monte Carlo error, represented by the standard error, is proportional to $\\sqrt{p(K)(1 - p(K))}$. This term is maximized when the probability of exercise $p(K) = \\Phi(d_2) = 0.5$, which occurs at $d_2 = 0$. Solving for $K$ gives the strike price of maximum variance:\n$$K_{\\text{max var}} = S_0 \\exp\\left(\\left(r - \\frac{1}{2}\\sigma^2\\right)T\\right)$$\nFor the given parameters $S_0=100$, $r=0.02$, $\\sigma=0.2$, and $T=1$, this gives $K_{\\text{max var}} = 100 \\cdot \\exp(0.02-0.02) = 100$. The provided set of strikes $\\{60, 90, 100, 110, 140\\}$ is appropriately chosen to demonstrate the behavior of the error around this point of maximum uncertainty.", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes analytical and Monte Carlo prices and standard errors for a digital\n    cash-or-nothing call option under the Black-Scholes framework.\n    \"\"\"\n    # Global parameters from the problem statement\n    S0 = 100.0\n    r = 0.02\n    sigma = 0.2\n    T = 1.0\n    L = 1.0\n    N = 200000\n\n    # Strike prices to evaluate\n    K_values = [60.0, 90.0, 100.0, 110.0, 140.0]\n\n    # Fixed seed for reproducibility\n    seed = 123456\n\n    # --- Monte Carlo Simulation Setup ---\n    # Use a single stream of random numbers for all strikes (common random numbers)\n    rng = np.random.default_rng(seed)\n    z = rng.standard_normal(N)\n\n    # Simulate terminal asset prices based on the lognormal property\n    drift = (r - 0.5 * sigma**2) * T\n    diffusion = sigma * np.sqrt(T)\n    S_T = S0 * np.exp(drift + diffusion * z)\n\n    # --- Calculation Loop ---\n    results = []\n    discount_factor = np.exp(-r * T)\n\n    for K in K_values:\n        # 1. Analytical Calculations (Black-Scholes)\n        d2 = (np.log(S0 / K) + (r - 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        p_K = norm.cdf(d2)  # Probability P(S_T >= K)\n\n        # Analytical price\n        C_bs = L * discount_factor * p_K\n        \n        # Analytical standard error of the MC estimator\n        payoff_var_analytical = (L**2) * p_K * (1 - p_K)\n        se_bs = discount_factor * np.sqrt(payoff_var_analytical / N)\n\n        # 2. Monte Carlo Estimators\n        # Calculate undiscounted payoffs for each simulated path\n        payoffs = L * (S_T >= K)\n\n        # Monte Carlo price estimate\n        mean_payoff = np.mean(payoffs)\n        C_mc = discount_factor * mean_payoff\n\n        # Monte Carlo standard error estimate\n        # Use population standard deviation (ddof=0) as specified\n        payoff_std_sample = np.std(payoffs, ddof=0)\n        se_mc = discount_factor * payoff_std_sample / np.sqrt(N)\n        \n        # Store the five required values for a given strike K\n        results.append([K, C_mc, C_bs, se_mc, se_bs])\n\n    # --- Output Formatting ---\n    # The final output must be a single line in the format [[...],[...],...]\n    # without extra spaces.\n    list_of_strings = []\n    for sublist in results:\n        # Format each sublist as a string \"[v1,v2,v3,v4,v5]\"\n        str_sublist = \"[\" + \",\".join(map(str, sublist)) + \"]\"\n        list_of_strings.append(str_sublist)\n\n    final_output = \"[\" + \",\".join(list_of_strings) + \"]\"\n    print(final_output)\n\nsolve()\n```"}, {"introduction": "Building upon the foundational Monte Carlo method, this practice tackles a more complex and realistic problem: characterizing the risk of a portfolio. Maximum Drawdown (MDD), the largest percentage loss from a peak to a subsequent trough, is a vital risk metric that depends on the entire price history of an asset, making it difficult to analyze with closed-form formulas. By simulating complete asset price paths and calculating the MDD for each one [@problem_id:2403314], you will learn how to apply simulation to understand the full distribution of sophisticated, path-dependent risk measures, a skill essential for modern risk management.", "id": "2403314", "problem": "Consider a portfolio whose value process is modeled in continuous time by geometric Brownian motion (GBM). Let $S_t$ denote the portfolio value at time $t \\in [0,T]$ with initial level $S_0 \\gt 0$. The process satisfies the stochastic differential equation $dS_t = \\mu S_t \\, dt + \\sigma S_t \\, dW_t$, where $\\mu \\in \\mathbb{R}$ is the drift, $\\sigma \\ge 0$ is the volatility, and $(W_t)_{t \\ge 0}$ is a standard Brownian motion. On a uniform time grid $t_k = k \\Delta t$ for $k \\in \\{0,1,\\dots,n\\}$, where $\\Delta t = T/n$, assume the exact finite-horizon increment property of GBM: for each $k \\in \\{0,1,\\dots,n-1\\}$, the log return $\\log\\left(\\frac{S_{t_{k+1}}}{S_{t_k}}\\right)$ is normally distributed with mean $(\\mu - \\tfrac{1}{2}\\sigma^2)\\Delta t$ and variance $\\sigma^2 \\Delta t$, independently across $k$ and across simulated paths.\n\nDefine the running maximum on the grid by $M_{t_k} = \\max_{0 \\le j \\le k} S_{t_j}$, and the drawdown at time $t_k$ by $D_{t_k} = 1 - \\frac{S_{t_k}}{M_{t_k}}$. The maximum drawdown for a path over $[0,T]$ is $\\mathrm{MDD} = \\max_{0 \\le k \\le n} D_{t_k}$. All drawdowns in this problem must be expressed as decimal fractions, not with a percentage sign.\n\nFor each parameter set in the test suite below, independently simulate $N_{\\text{paths}}$ sample paths on the specified grid and compute, from the resulting sample of maximum drawdowns $\\{\\mathrm{MDD}^{(i)}\\}_{i=1}^{N_{\\text{paths}}}$:\n- The sample mean $\\widehat{\\mathbb{E}}[\\mathrm{MDD}] = \\frac{1}{N_{\\text{paths}}}\\sum_{i=1}^{N_{\\text{paths}}} \\mathrm{MDD}^{(i)}$.\n- The exceedance probability at threshold $d^\\star$, defined as $\\widehat{\\mathbb{P}}(\\mathrm{MDD} \\ge d^\\star) = \\frac{1}{N_{\\text{paths}}}\\sum_{i=1}^{N_{\\text{paths}}} \\mathbf{1}\\{\\mathrm{MDD}^{(i)} \\ge d^\\star\\}$.\n- The empirical upper quantile at probability level $q$, denoted $Q_q$, defined as the sample quantile of order $q$ of the set $\\{\\mathrm{MDD}^{(i)}\\}_{i=1}^{N_{\\text{paths}}}$.\n\nFor reproducibility, use the exact integer random seed specified for each case below when simulating that case. No physical units are involved. Angles are not used. All requested outputs must be real numbers.\n\nTest suite of parameter sets, where each tuple lists $(S_0,\\mu,\\sigma,T,n,N_{\\text{paths}},d^\\star,q,\\text{seed})$:\n- Case $1$: $(100,\\ 0.05,\\ 0.20,\\ 1.0,\\ 252,\\ 8000,\\ 0.20,\\ 0.95,\\ 202311)$.\n- Case $2$: $(100,\\ 0.05,\\ 0.0001,\\ 1.0,\\ 252,\\ 8000,\\ 0.01,\\ 0.95,\\ 202312)$.\n- Case $3$: $(100,\\ 0.00,\\ 0.60,\\ 1.0,\\ 252,\\ 8000,\\ 0.50,\\ 0.95,\\ 202313)$.\n- Case $4$: $(100,\\ -0.10,\\ 0.25,\\ 2.0,\\ 504,\\ 8000,\\ 0.30,\\ 0.95,\\ 202314)$.\n- Case $5$: $(100,\\ 0.02,\\ 0.15,\\ 0.25,\\ 63,\\ 8000,\\ 0.10,\\ 0.95,\\ 202315)$.\n\nYour program must produce a single line of output containing the results for all cases aggregated into one list. For each case in the order listed, output three values in this exact order: the sample mean of maximum drawdown, the exceedance probability at the given threshold, and the empirical quantile at level $q$. Concatenate these triplets in case order to form one flat list. Each value must be rounded to exactly $6$ decimal places. The final output must be a single line containing a comma-separated list enclosed in square brackets, with no spaces. For example, for two cases the format would be one line like $[x_{1,1},x_{1,2},x_{1,3},x_{2,1},x_{2,2},x_{2,3}]$, where $x_{i,j}$ denotes the $j$-th value for case $i$.", "solution": "The problem statement is subjected to rigorous validation and is found to be valid. It is scientifically grounded in the established theory of stochastic calculus and its application in financial modeling, specifically the geometric Brownian motion model. The problem is well-posed, with all parameters, definitions, and constraints clearly and objectively specified. It represents a standard, formalizable task in computational finance. I will, therefore, provide a complete solution.\n\nThe objective is to compute statistics related to the maximum drawdown ($\\mathrm{MDD}$) of a portfolio whose value follows a geometric Brownian motion (GBM). The process $S_t$ is described by the stochastic differential equation $dS_t = \\mu S_t \\, dt + \\sigma S_t \\, dW_t$. We will employ a Monte Carlo simulation approach to generate a large number of sample paths, calculate the $\\mathrm{MDD}$ for each path, and then compute the required sample statistics from the resulting distribution of $\\mathrm{MDD}$ values.\n\nThe solution methodology comprises four main steps for each parameter set provided.\n\nFirst, the simulation parameters are initialized. For each test case, we are given the initial portfolio value $S_0$, drift $\\mu$, volatility $\\sigma$, time horizon $T$, number of time steps $n$, number of simulation paths $N_{\\text{paths}}$, drawdown threshold $d^\\star$, quantile level $q$, and a random seed. The time discretization step is calculated as $\\Delta t = T/n$. For reproducibility, a new random number generator is initialized with the specified seed for each case.\n\nSecond, we generate $N_{\\text{paths}}$ sample paths of the GBM process. The problem correctly states that for a discrete time grid $t_k = k \\Delta t$, the exact solution to the GBM SDE provides the following relation:\n$$ S_{t_{k+1}} = S_{t_k} \\exp\\left( (\\mu - \\frac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_k \\right) $$\nwhere each $Z_k$ is an independent random variable drawn from the standard normal distribution, $\\mathcal{N}(0, 1)$. For numerical stability and computational efficiency, we first simulate the logarithm of the price process, $X_t = \\log(S_t)$. The increments of the log-price process are given by:\n$$ X_{t_{k+1}} - X_{t_k} = (\\mu - \\frac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_k $$\nWe generate a matrix of $N_{\\text{paths}} \\times n$ standard normal random numbers. Then, for each path, we compute the cumulative sum of these increments to obtain the log-price trajectory starting from $X_0 = \\log(S_0)$. Finally, we obtain the price paths $S$ by exponentiating the log-price paths. This entire procedure is implemented using vectorized `numpy` operations to efficiently generate all $N_{\\text{paths}}$ paths simultaneously. The resulting matrix of asset prices $S$ has dimensions $N_{\\text{paths}} \\times (n+1)$.\n\nThird, for each simulated path, we calculate the maximum drawdown. The running maximum at time $t_k$ is defined as $M_{t_k} = \\max_{0 \\le j \\le k} S_{t_j}$. The drawdown at time $t_k$ is $D_{t_k} = 1 - S_{t_k}/M_{t_k}$. The maximum drawdown for a single path is $\\mathrm{MDD} = \\max_{0 \\le k \\le n} D_{t_k}$. Computationally, for the matrix $S$ of all paths, we first compute the running maximum along each row (path) using `numpy.maximum.accumulate`. This yields a matrix $M$ of running maximums. Then, the drawdown matrix $D$ is computed as $D = 1 - S/M$. The maximum drawdown for each path is found by taking the maximum value across each row of $D$, resulting in a vector of $N_{\\text{paths}}$ $\\mathrm{MDD}$ values.\n\nFourth, from the sample of $N_{\\text{paths}}$ maximum drawdowns, denoted $\\{\\mathrm{MDD}^{(i)}\\}_{i=1}^{N_{\\text{paths}}}$, we compute the required statistics:\n- The sample mean, $\\widehat{\\mathbb{E}}[\\mathrm{MDD}]$, is the arithmetic average of the $\\mathrm{MDD}$ sample.\n- The exceedance probability, $\\widehat{\\mathbb{P}}(\\mathrm{MDD} \\ge d^\\star)$, is the fraction of simulated paths for which the $\\mathrm{MDD}$ is greater than or equal to the specified threshold $d^\\star$.\n- The empirical quantile, $Q_q$, is the value below which a fraction $q$ of the sample $\\mathrm{MDD}$s fall. This is computed using the `numpy.quantile` function, which provides a standard implementation of sample quantiles.\n\nThese three computed values for each test case are collected, rounded to $6$ decimal places, and formatted into a single flat list as specified by the problem.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating maximum drawdown statistics for a\n    Geometric Brownian Motion process via Monte Carlo simulation.\n    \"\"\"\n    test_cases = [\n        # (S0, mu, sigma, T, n, N_paths, d_star, q, seed)\n        (100.0, 0.05, 0.20, 1.0, 252, 8000, 0.20, 0.95, 202311),\n        (100.0, 0.05, 0.0001, 1.0, 252, 8000, 0.01, 0.95, 202312),\n        (100.0, 0.00, 0.60, 1.0, 252, 8000, 0.50, 0.95, 202313),\n        (100.0, -0.10, 0.25, 2.0, 504, 8000, 0.30, 0.95, 202314),\n        (100.0, 0.02, 0.15, 0.25, 63, 8000, 0.10, 0.95, 202315),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        S0, mu, sigma, T, n, N_paths, d_star, q, seed = case\n\n        # Step 1: Initialization\n        # Set the time step and initialize the random number generator for reproducibility.\n        dt = T / n\n        rng = np.random.default_rng(seed)\n\n        # Step 2: Path Generation\n        # Generate N_paths x n matrix of standard normal random variates.\n        Z = rng.standard_normal(size=(N_paths, n))\n\n        # Calculate log-returns using the exact discretization of GBM's log-process.\n        # This results in an N_paths x n matrix.\n        log_returns = (mu - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z\n\n        # Compute log-prices by taking the cumulative sum of log-returns.\n        # The resulting matrix has shape N_paths x (n+1).\n        log_prices = np.zeros((N_paths, n + 1))\n        log_prices[:, 0] = np.log(S0)\n        log_prices[:, 1:] = np.log(S0) + np.cumsum(log_returns, axis=1)\n\n        # Convert log-prices to prices by exponentiation.\n        S = np.exp(log_prices)\n\n        # Step 3: Maximum Drawdown (MDD) Calculation\n        # Compute the running maximum for each path.\n        M = np.maximum.accumulate(S, axis=1)\n\n        # Compute the drawdown at each time step for each path.\n        # Division by zero is avoided as S0 > 0 implies M > 0.\n        D = 1 - S / M\n\n        # Find the maximum drawdown for each path by taking the max over time.\n        mdd_samples = np.max(D, axis=1)\n\n        # Step 4: Statistical Estimation\n        # Calculate the sample mean of the maximum drawdowns.\n        mean_mdd = np.mean(mdd_samples)\n\n        # Calculate the exceedance probability P(MDD >= d*).\n        exceedance_prob = np.mean(mdd_samples >= d_star)\n\n        # Calculate the empirical q-quantile of the maximum drawdowns.\n        quantile_mdd = np.quantile(mdd_samples, q)\n\n        results.extend([mean_mdd, exceedance_prob, quantile_mdd])\n\n    # Final print statement in the exact required format.\n    # Each value is formatted to 6 decimal places.\n    output_str = f\"[{','.join([f'{val:.6f}' for val in results])}]\"\n    print(output_str)\n\nsolve()\n```"}]}