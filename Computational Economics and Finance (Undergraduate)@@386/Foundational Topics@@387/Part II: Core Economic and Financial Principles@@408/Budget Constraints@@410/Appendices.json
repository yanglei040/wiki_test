{"hands_on_practices": [{"introduction": "While introductory economics often begins with a simple, linear budget line, real-world consumer choices are frequently shaped by more complex pricing schemes. This first exercise moves beyond the basics by modeling a \"buy-one-get-one-free\" (BOGO) promotion, a common retail strategy that creates a non-linear budget constraint with distinct segments and a \"kink\" point. By deriving the budget set from first principles, you will practice translating a descriptive rule into a precise mathematical representation of a consumer's purchasing power, a foundational skill for analyzing realistic market scenarios [@problem_id:2378669].", "id": "2378669", "problem": "A consumer chooses quantities of two perfectly divisible goods, good $x_1$ and good $x_2$, facing nonnegative prices $p_1$ and $p_2$ and a monetary income $m$. The budget set is the set of all nonnegative bundles whose total expenditure under the store’s posted pricing rule does not exceed $m$. The store offers a buy-one-get-one-free (BOGO) promotion on good $x_1$ up to a cap: for each unit of $x_1$ purchased, up to a maximum of $K$ paid units, the consumer is entitled to an additional equal quantity of $x_1$ at zero price. Beyond this cap, additional units of $x_1$ do not generate free units, and all further units must be paid at the posted price $p_1$. Assume that both goods are perfectly divisible so that the promotion applies proportionally.\n\nStarting only from the definition of the budget set and the described promotion, derive the exact expression for the horizontal intercept of the budget set (the maximum attainable $x_1$ when $x_2=0$) as a function of $m$, $p_1$, and $K$. Then evaluate this intercept numerically for $p_1 = 4$, $p_2 = 5$, $m = 90$, and $K = 8$. Provide the final numerical value of the intercept. No rounding is required.", "solution": "The problem statement is subjected to validation prior to any attempt at a solution.\n\n**Step 1: Extract Givens**\n- Goods: two perfectly divisible goods, $x_1$ and $x_2$.\n- Prices: nonnegative prices $p_1$ and $p_2$.\n- Income: monetary income $m$.\n- Budget Set: set of nonnegative bundles $(x_1, x_2)$ such that total expenditure does not exceed $m$.\n- Promotion: Buy-one-get-one-free (BOGO) on good $x_1$. For each unit of $x_1$ purchased, an equal quantity is given for free.\n- Promotion Cap: The BOGO promotion applies up to a maximum of $K$ paid units of $x_1$. Beyond this, all further units of $x_1$ must be purchased at price $p_1$.\n- Divisibility: The promotion applies proportionally for perfectly divisible goods.\n- Objective 1: Derive the expression for the horizontal intercept of the budget set (maximum $x_1$ when $x_2=0$) as a function of $m$, $p_1$, and $K$.\n- Objective 2: Evaluate this intercept numerically for $p_1 = 4$, $p_2 = 5$, $m = 90$, and $K = 8$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective. It describes a non-linear budget constraint, which is a standard topic in microeconomic consumer theory. The setup is clear, internally consistent, and contains all necessary information to derive a unique solution. The language is precise and free of subjective claims. The problem is therefore deemed **valid**.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\nThe objective is to find the maximum attainable quantity of good $x_1$ when the quantity of good $x_2$ is zero, i.e., $x_2 = 0$. This is the horizontal intercept of the budget set. The total expenditure on goods must not exceed the income $m$. With $x_2=0$, the entire income $m$ can be spent on good $x_1$. We must therefore determine the maximum quantity of $x_1$ that can be acquired for an expenditure of $m$.\n\nLet us first formalize the expenditure, $E_1(x_1)$, required to acquire a total quantity $x_1$ of the first good. The pricing rule is piecewise.\n\nPart 1: The BOGO Promotion Regime\nThe promotion states that for each unit of $x_1$ paid for, one unit is received for free. This means that to acquire a total quantity $x_1$, the consumer must pay for only $x_1/2$ units. The cost is therefore $E_1(x_1) = p_1 \\cdot \\frac{x_1}{2}$.\nThis promotion is valid as long as the number of paid units does not exceed $K$. The number of paid units is $x_1/2$. So, this pricing rule applies for $x_1/2 \\le K$, which is equivalent to $0 \\le x_1 \\le 2K$.\n\nPart 2: The Standard Pricing Regime\nIf the consumer wishes to acquire more than $2K$ units of $x_1$, they must first exhaust the BOGO promotion. The cost to acquire the first $2K$ units of $x_1$ is the cost of paying for $K$ units, which is $p_1 K$.\nFor any quantity beyond $2K$, i.e., for $x_1 > 2K$, the additional units, $(x_1 - 2K)$, must be paid for at the standard price $p_1$. The expenditure for these additional units is $p_1 (x_1 - 2K)$.\nThe total expenditure to acquire a quantity $x_1 > 2K$ is the sum of the cost for the first $2K$ units and the cost for the additional units:\n$$E_1(x_1) = p_1 K + p_1 (x_1 - 2K) = p_1 K + p_1 x_1 - 2p_1 K = p_1 x_1 - p_1 K = p_1 (x_1 - K)$$\n\nCombining these two parts, the expenditure function for acquiring $x_1$ is:\n$$ E_1(x_1) = \\begin{cases} \\frac{p_1 x_1}{2} & \\text{if } 0 \\le x_1 \\le 2K \\\\ p_1(x_1 - K) & \\text{if } x_1 > 2K \\end{cases} $$\n\nTo find the horizontal intercept, we set the total expenditure equal to the income $m$ (since $x_2=0$) and solve for $x_1$. The solution depends on the value of $m$ relative to the expenditure required to exhaust the BOGO promotion, which is $p_1 K$.\n\nCase A: $m \\le p_1 K$\nIf the income is not sufficient to pay for $K$ units, the consumer will operate entirely within the BOGO promotion regime. The maximum quantity of $x_1$ is found by setting the expenditure in this regime equal to $m$:\n$$\\frac{p_1 x_1}{2} = m$$\n$$x_1 = \\frac{2m}{p_1}$$\nWe must verify that this result is consistent with the condition $x_1 \\le 2K$.\nSince $m \\le p_1 K$, we have $\\frac{m}{p_1} \\le K$, and thus $\\frac{2m}{p_1} \\le 2K$. The condition is satisfied.\n\nCase B: $m > p_1 K$\nIf the income is greater than the cost to exhaust the promotion, the consumer will acquire more than $2K$ units of $x_1$. The expenditure is given by the second part of the function:\n$$p_1(x_1 - K) = m$$\n$$x_1 - K = \\frac{m}{p_1}$$\n$$x_1 = K + \\frac{m}{p_1}$$\nWe must verify that this result is consistent with the condition $x_1 > 2K$.\nSince $m > p_1 K$, we have $\\frac{m}{p_1} > K$, which implies $K + \\frac{m}{p_1} > K+K = 2K$. The condition is satisfied.\n\nThe general expression for the horizontal intercept, $x_{1, \\text{intercept}}$, is:\n$$ x_{1, \\text{intercept}} = \\begin{cases} \\frac{2m}{p_1} & \\text{if } m \\le p_1 K \\\\ K + \\frac{m}{p_1} & \\text{if } m > p_1 K \\end{cases} $$\nThis concludes the first part of the problem.\n\nFor the second part, we must evaluate this intercept for the given numerical values: $p_1 = 4$, $p_2 = 5$, $m = 90$, and $K = 8$. The value of $p_2$ is irrelevant for this calculation.\nFirst, we determine which case applies by comparing $m$ to $p_1 K$:\n$$m = 90$$\n$$p_1 K = 4 \\times 8 = 32$$\nSince $90 > 32$, we have $m > p_1 K$, which corresponds to Case B.\nThe formula for the intercept is $x_{1, \\text{intercept}} = K + \\frac{m}{p_1}$.\nSubstituting the numerical values:\n$$x_{1, \\text{intercept}} = 8 + \\frac{90}{4}$$\n$$x_{1, \\text{intercept}} = 8 + 22.5$$\n$$x_{1, \\text{intercept}} = 30.5$$\nThe maximum attainable quantity of good $x_1$ is $30.5$.", "answer": "$$\\boxed{30.5}$$"}, {"introduction": "Building on the concept of non-linear constraints, this practice explores how an individual makes optimal choices when faced with a complex budget set. We examine the classic labor-leisure trade-off, but with the realistic complication of a progressive income tax system, which results in a piece-wise linear budget constraint. This computational exercise challenges you to implement an algorithm that identifies the utility-maximizing choice of labor hours $h^{\\star}$, considering not only interior solutions along the budget segments but also the \"kink points\" where tax brackets change, which are often sources of optimal solutions [@problem_id:2378657].", "id": "2378657", "problem": "Consider a single representative individual making a labor-leisure choice under a progressive income tax that creates a piece-wise linear budget constraint. Time is the scarce resource. The individual has a fixed time endowment of $T$ hours, chooses labor hours $h \\in [0,T]$, consumes $c$, and enjoys leisure $s = T - h$. The wage rate (before tax) is $w$ per hour, and the individual has nonlabor income $b$. The individual’s preferences are represented by a Cobb–Douglas utility function $U(c,s) = c^{\\alpha} s^{1-\\alpha}$, where $\\alpha \\in (0,1)$.\n\nThe government levies a progressive tax on labor income following a bracket schedule. Let pre-tax labor income be $y = w h$. The tax schedule is defined by a sequence of bracket thresholds $\\{K_0, K_1, \\dots, K_{N}\\}$ with $K_0 = 0$ and $K_{N} = +\\infty$, and corresponding marginal tax rates $\\{t_1, t_2, \\dots, t_{N}\\}$, applied to income increments between thresholds. All marginal tax rates must be provided as decimals (for example, use $0.2$ instead of $20\\%$). Taxes owed are computed as the accumulated tax in lower brackets plus the marginal tax on the income within the current bracket. Consumption is given by $c = b + y - \\mathcal{T}(y)$, where $\\mathcal{T}(y)$ is the total tax owed on income $y$ as defined by the bracket schedule.\n\nYour tasks are:\n\n- Use only the following fundamental base: (i) the definition of the budget constraint $c = b + y - \\mathcal{T}(y)$ with $y = w h$, where $\\mathcal{T}(y)$ is defined by the piece-wise marginal rates and thresholds; (ii) the definition of leisure $s = T - h$; and (iii) the first-order condition for an interior optimum equating the marginal rate of substitution between leisure and consumption to the after-tax wage within a bracket when applicable. Non-interior optima can occur at the kink points or at the endpoints $h=0$ or $h=T$.\n- For each bracket $i \\in \\{1,\\dots,N\\}$, the marginal tax rate $t_i$ applies to $y \\in [K_{i-1},K_i)$, and the total tax owed can be written as the sum of taxes from lower brackets plus $t_i$ times the amount of income within the current bracket. This implies a piece-wise linear budget constraint with slope equal to the after-tax wage $w(1 - t_i)$ in bracket $i$.\n- Your program must, for each test case, determine the utility-maximizing choice of labor hours $h^\\star \\in [0,T]$ by checking all candidate solutions implied by the theory: (a) interior solutions within each bracket where the first-order condition holds, provided that the implied $y = w h$ lies within the bracket’s income range, and (b) all kink points corresponding to the thresholds $\\{K_1,\\dots,K_{N-1}\\}$ that are attainable within the time endowment, in addition to the endpoints $h=0$ and $h=T$. For each candidate $h$, compute $c = b + w h - \\mathcal{T}(w h)$, $s = T - h$, and $U(c,s) = c^{\\alpha} s^{1-\\alpha}$, and then select the candidate that maximizes $U(c,s)$.\n- All inputs are purely numerical; there are no physical units beyond hours for $T$ and $h$. All outputs must be numerical. Angles are not involved. Percentages must be provided as decimals.\n\nTest suite to implement:\n\nProvide the following five test cases; in each, $K$ lists the thresholds and $t$ lists the corresponding marginal tax rates:\n\n- Case $1$: $T = 16$, $w = 25$, $b = 10$, $\\alpha = 0.4$, $K = [0, 200, 400, +\\infty)$, $t = [0.0, 0.2, 0.35]$.\n- Case $2$: $T = 24$, $w = 20$, $b = 300$, $\\alpha = 0.2$, $K = [0, 100, 200, +\\infty)$, $t = [0.5, 0.7, 0.9]$.\n- Case $3$: $T = 8$, $w = 30$, $b = 0$, $\\alpha = 0.5$, $K = [0, +\\infty)$, $t = [0.25]$.\n- Case $4$: $T = 6$, $w = 40$, $b = 0$, $\\alpha = 0.5$, $K = [0, 80, 120, +\\infty)$, $t = [0.0, 0.5, 0.6]$.\n- Case $5$: $T = 12$, $w = 15$, $b = 0$, $\\alpha = 0.9$, $K = [0, 60, 120, +\\infty)$, $t = [0.1, 0.2, 0.4]$.\n\nFinal output format:\n\n- For each test case, output a list $[h^\\star, c^\\star, s^\\star, U^\\star]$ where $h^\\star$, $c^\\star$, $s^\\star$, and $U^\\star$ are floating-point numbers rounded to exactly six decimal places.\n- Your program should produce a single line of output containing the five case results as a comma-separated list enclosed in square brackets, with each case represented as its own list. For example: \"[[h1,c1,s1,U1],[h2,c2,s2,U2],...]\" with exactly six decimal places for each number and no additional text.", "solution": "We start from the fundamental definitions. The individual chooses labor hours $h \\in [0,T]$, with leisure $s = T - h$, pre-tax labor income $y = w h$, and consumption $c = b + y - \\mathcal{T}(y)$. Preferences are given by the Cobb–Douglas utility function $U(c,s) = c^{\\alpha} s^{1-\\alpha}$ with parameter $\\alpha \\in (0,1)$.\n\nThe progressive tax schedule is defined by thresholds $\\{K_0,\\dots,K_N\\}$ with $K_0 = 0$ and $K_N = +\\infty$ and bracket marginal rates $\\{t_1,\\dots,t_N\\}$. Within bracket $i$, for $y \\in [K_{i-1}, K_i)$, the total tax can be expressed as\n$$\n\\mathcal{T}(y) \\;=\\; \\underbrace{\\sum_{j=1}^{i-1} t_j (K_j - K_{j-1})}_{\\text{cumulative tax up to } K_{i-1}} \\;+\\; t_i \\, (y - K_{i-1}) \\;=\\; C_{i-1} + t_i y - t_i K_{i-1},\n$$\nwhere $C_{i-1} = \\sum_{j=1}^{i-1} t_j (K_j - K_{j-1})$ is the cumulative tax at the lower threshold $K_{i-1}$. Hence, within bracket $i$,\n$$\nc \\;=\\; b + y - \\mathcal{T}(y) \\;=\\; \\underbrace{b - C_{i-1} + t_i K_{i-1}}_{B_i} \\;+\\; (1 - t_i) y,\n$$\nwhich is a linear function of $y$ (and therefore of $h$), with slope equal to the after-tax wage in bracket $i$, given by $w_i = w (1 - t_i)$. Thus, for $y = w h$ in bracket $i$,\n$$\nc(h) \\;=\\; B_i + w_i h\n\\quad\\text{and}\\quad\ns(h) \\;=\\; T - h.\n$$\n\nFor an interior solution within a given bracket $i$, the first-order condition equates the marginal rate of substitution to the relevant after-tax wage:\n$$\n\\text{MRS}_{s,c} \\;=\\; \\frac{\\partial U/\\partial s}{\\partial U/\\partial c} \\;=\\; \\frac{(1-\\alpha)}{\\alpha} \\,\\frac{c}{s} \\;=\\; w_i.\n$$\nSubstituting $c = B_i + w_i h$ and $s = T - h$ yields\n$$\n\\frac{(1-\\alpha)}{\\alpha}\\,\\frac{B_i + w_i h}{T - h} \\;=\\; w_i.\n$$\nSolving for $h$ gives the candidate interior solution in bracket $i$:\n$$\nh_i^\\circ \\;=\\; \\alpha T \\;-\\; \\frac{1-\\alpha}{w_i}\\, B_i.\n$$\nThis $h_i^\\circ$ is only valid if it is feasible, meaning it satisfies $0 \\le h_i^\\circ \\le T$ and the implied income $y_i^\\circ = w h_i^\\circ$ lies within the income range of the bracket, that is $K_{i-1} \\le y_i^\\circ < K_i$. If the candidate does not satisfy these conditions, the optimum cannot be interior within that bracket.\n\nIn addition to interior candidates, optimal solutions can occur at kinks because the slope of the budget constraint changes at the thresholds $\\{K_1,\\dots,K_{N-1}\\}$. Each kink corresponds to labor hours $h_k = K_k / w$, provided $h_k \\le T$. The endpoints $h=0$ and $h=T$ are also candidates. For each candidate $h$, compute:\n- $y = w h$,\n- total tax $\\mathcal{T}(y)$ from the bracket schedule,\n- $c = b + y - \\mathcal{T}(y)$,\n- $s = T - h$,\n- $U(c,s) = c^{\\alpha} s^{1-\\alpha}$.\n\nAmong all candidates, select the $h^\\star$ that maximizes $U(c,s)$. If multiple candidates yield utility values that are equal up to numerical tolerance, one can select the candidate with the smallest $h$ for determinism.\n\nAlgorithmic design:\n- Precompute cumulative taxes $C_{i-1}$ and the constants $B_i = b - C_{i-1} + t_i K_{i-1}$ and after-tax wages $w_i = w(1 - t_i)$ for each bracket $i$.\n- Generate the candidate set consisting of:\n  - Interior candidates $h_i^\\circ = \\alpha T - \\frac{1-\\alpha}{w_i} B_i$ restricted to $0 \\le h_i^\\circ \\le T$ and $K_{i-1} \\le w h_i^\\circ < K_i$.\n  - Kink candidates $h_k = K_k / w$ for all thresholds with $h_k \\le T$.\n  - Endpoints $h=0$ and $h=T$.\n- Evaluate $U(c(h), s(h))$ at all candidates and select the maximizer.\n\nThis procedure is applied independently to each of the five test cases:\n- Case $1$: $T = 16$, $w = 25$, $b = 10$, $\\alpha = 0.4$, $K = [0, 200, 400, +\\infty)$, $t = [0.0, 0.2, 0.35]$.\n- Case $2$: $T = 24$, $w = 20$, $b = 300$, $\\alpha = 0.2$, $K = [0, 100, 200, +\\infty)$, $t = [0.5, 0.7, 0.9]$.\n- Case $3$: $T = 8$, $w = 30$, $b = 0$, $\\alpha = 0.5$, $K = [0, +\\infty)$, $t = [0.25]$.\n- Case $4$: $T = 6$, $w = 40$, $b = 0$, $\\alpha = 0.5$, $K = [0, 80, 120, +\\infty)$, $t = [0.0, 0.5, 0.6]$.\n- Case $5$: $T = 12$, $w = 15$, $b = 0$, $\\alpha = 0.9$, $K = [0, 60, 120, +\\infty)$, $t = [0.1, 0.2, 0.4]$.\n\nThe program implements this candidate-evaluation method, computes the optimal $[h^\\star, c^\\star, s^\\star, U^\\star]$ for each case, rounds each value to exactly six decimal places, and prints the results as a single-line list of lists as specified.", "answer": "```python\nimport numpy as np\n\ndef compute_cumulative_tax_thresholds(K, t):\n    \"\"\"\n    Given thresholds K (length N+1 with K[0]=0, K[N]=inf) and marginal rates t (length N),\n    compute cumulative tax up to each lower threshold K[i] for bracket i (i from 0..N-1).\n    Returns list C where C[i] = cumulative tax up to K[i] (i.e., sum_{j< i} t[j]*(K[j+1]-K[j])).\n    \"\"\"\n    N = len(t)\n    C = [0.0] * (N + 1)\n    cum = 0.0\n    for i in range(1, N + 1):\n        # Tax in bracket i-1 fully applied up to K[i]\n        width = K[i] - K[i - 1]\n        if np.isfinite(width):\n            cum += t[i - 1] * width\n        else:\n            # Last width is infinite; do not add to cumulative because it's unbounded\n            cum += 0.0\n        C[i] = cum\n    return C\n\ndef total_tax(y, K, t):\n    \"\"\"\n    Compute total tax owed given income y, thresholds K, and marginal rates t.\n    \"\"\"\n    N = len(t)\n    tax = 0.0\n    remaining = y\n    for i in range(N):\n        lower = K[i]\n        upper = K[i + 1]\n        if remaining <= lower:\n            break\n        taxable = min(remaining, upper) - lower\n        if taxable > 0:\n            tax += t[i] * taxable\n    return tax\n\ndef evaluate_candidates(case):\n    T = float(case[\"T\"])\n    w = float(case[\"w\"])\n    b = float(case[\"b\"])\n    alpha = float(case[\"alpha\"])\n    # Ensure K and t are numpy arrays, last K can be inf\n    K = np.array(case[\"K\"], dtype=float)\n    t_rates = np.array(case[\"t\"], dtype=float)\n    N = len(t_rates)\n    # Precompute cumulative taxes at thresholds\n    C = compute_cumulative_tax_thresholds(K, t_rates)  # length N+1\n    # Generate candidates: endpoints\n    candidates = [0.0, T]\n    # Kinks: K[1..N-1]\n    for j in range(1, len(K) - 1):\n        h_kink = K[j] / w\n        if h_kink <= T + 1e-12:\n            candidates.append(max(0.0, min(T, h_kink)))\n    # Interior candidates within each bracket\n    for i in range(N):\n        lower = K[i]\n        upper = K[i + 1]\n        wi = w * (1.0 - t_rates[i])\n        # If after-tax wage is effectively zero, skip interior candidate\n        if wi <= 1e-12:\n            continue\n        Bi = b - C[i] + t_rates[i] * K[i]\n        h_int = alpha * T - (1.0 - alpha) * Bi / wi\n        # Feasibility: within [0,T] and income within bracket\n        if h_int < -1e-12 or h_int > T + 1e-12:\n            continue\n        y_int = w * h_int\n        lower_ok = y_int >= lower - 1e-9\n        upper_ok = (y_int < upper - 1e-9) or not np.isfinite(upper)\n        if lower_ok and upper_ok:\n            # Clamp to [0,T]\n            h_int = max(0.0, min(T, h_int))\n            candidates.append(h_int)\n    # Deduplicate candidates with tolerance\n    candidates_sorted = sorted(candidates)\n    uniq = []\n    for h in candidates_sorted:\n        if not uniq or abs(h - uniq[-1]) > 1e-9:\n            uniq.append(h)\n    # Evaluate utility and select best\n    best = None\n    best_tuple = None\n    for h in uniq:\n        y = w * h\n        tax = total_tax(y, K, t_rates)\n        c = b + y - tax\n        s = T - h\n        # Utility: c^alpha * s^(1-alpha); by convention, if c<=0 or s<=0, utility is 0\n        if c <= 0.0 or s <= 0.0:\n            U = 0.0\n        else:\n            U = (c ** alpha) * (s ** (1.0 - alpha))\n        # Select by utility, tie-break by smallest h\n        sel_key = (U, -h)  # since we want smallest h on tie, use -h with max\n        if (best is None) or (sel_key > best):\n            best = sel_key\n            best_tuple = (h, c, s, U)\n    # Round to six decimals\n    h_star, c_star, s_star, U_star = best_tuple\n    return [round(h_star, 6), round(c_star, 6), round(s_star, 6), round(U_star, 6)]\n\ndef solve():\n    test_cases = [\n        # Case 1\n        {\"T\": 16.0, \"w\": 25.0, \"b\": 10.0, \"alpha\": 0.4,\n         \"K\": [0.0, 200.0, 400.0, np.inf], \"t\": [0.0, 0.2, 0.35]},\n        # Case 2\n        {\"T\": 24.0, \"w\": 20.0, \"b\": 300.0, \"alpha\": 0.2,\n         \"K\": [0.0, 100.0, 200.0, np.inf], \"t\": [0.5, 0.7, 0.9]},\n        # Case 3\n        {\"T\": 8.0, \"w\": 30.0, \"b\": 0.0, \"alpha\": 0.5,\n         \"K\": [0.0, np.inf], \"t\": [0.25]},\n        # Case 4\n        {\"T\": 6.0, \"w\": 40.0, \"b\": 0.0, \"alpha\": 0.5,\n         \"K\": [0.0, 80.0, 120.0, np.inf], \"t\": [0.0, 0.5, 0.6]},\n        # Case 5\n        {\"T\": 12.0, \"w\": 15.0, \"b\": 0.0, \"alpha\": 0.9,\n         \"K\": [0.0, 60.0, 120.0, np.inf], \"t\": [0.1, 0.2, 0.4]},\n    ]\n    results = []\n    for case in test_cases:\n        results.append(evaluate_candidates(case))\n\n    # Format as a single-line list of lists with exactly six decimals\n    def fmt_num(x):\n        return f\"{x:.6f}\"\n\n    inner = []\n    for res in results:\n        inner.append(\"[\" + \",\" + \",\".join(fmt_num(v) for v in res)[1:] + \"]\" if False else \"[\" + \",\".join(fmt_num(v) for v in res) + \"]\")\n    output = \"[\" + \",\".join(inner) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "This final practice introduces a critical element of modern finance: uncertainty. Here, we model the budget constraint of a consumer whose future income depends on the volatile exchange rate of a cryptocurrency and who wishes to borrow against this uncertain future wealth. The core task is to determine the maximum borrowing capacity under a \"robust solvency\" requirement, which demands that the loan can be repaid even in the worst-case future scenario, where the exchange rate $E$ is at its minimum $E_{\\min}$. This problem bridges consumer theory and risk management, demonstrating how to define today's feasible consumption set when tomorrow's resources are uncertain [@problem_id:2378611].", "id": "2378611", "problem": "A consumer chooses nonnegative quantities of two goods, denoted by $x_1$ and $x_2$, with fiat prices $p_1$ and $p_2$, respectively. The consumer has current fiat wealth $w_0$ at date $0$ and will receive $q$ units of a cryptocurrency at date $1$. The fiat exchange rate of the cryptocurrency at date $1$ is uncertain and belongs to a known closed interval $[E_{\\min}, E_{\\max}]$, with $E_{\\min} \\ge 0$. The consumer cannot sell the cryptocurrency prior to date $1$.\n\nAt date $0$, the consumer may borrow an amount $b$ in fiat, subject to an exogenous cap $B_{\\max} \\ge 0$, and must repay $(1+r)b$ at date $1$, where $r \\ge 0$ is the interest rate. To service the debt, the consumer may sell any amount $z(E) \\in [0,q]$ of cryptocurrency at date $1$ after observing the realized exchange rate $E \\in [E_{\\min}, E_{\\max}]$. If $z(E) = 0$, no exchange fee is paid and fiat proceeds are $0$. If $z(E) &gt; 0$, the exchange levies an ad valorem fee at rate $f \\in [0,1)$ and a fixed fee $k \\ge 0$, so fiat proceeds from selling $z(E)$ units at exchange rate $E$ are $(1-f) E \\, z(E) - k$.\n\nThe lender imposes a robust solvency requirement: for every $E \\in [E_{\\min}, E_{\\max}]$, there must exist a choice $z(E) \\in [0,q]$ such that the net proceeds from sale at date $1$ are at least the repayment $(1+r)b$. Formally, for all $E \\in [E_{\\min}, E_{\\max}]$, there exists $z(E) \\in [0,q]$ satisfying\n$$(1-f) E \\, z(E) - k \\cdot \\mathbf{1}_{\\{z(E) &gt; 0\\}} \\;\\ge\\; (1+r) b,$$\nwhere $\\mathbf{1}_{\\{\\cdot\\}}$ is the indicator function that equals $1$ if its argument is true and $0$ otherwise.\n\nAt date $0$, the consumer’s budget set is the set of $(x_1,x_2)$ such that\n$$p_1 x_1 + p_2 x_2 \\;\\le\\; w_0 + b,$$\nwith $x_1 \\ge 0$, $x_2 \\ge 0$, and $b \\in [0,B_{\\max}]$ satisfying the robust solvency requirement above.\n\nTask. For each parameter set in the test suite below, compute the following three quantities:\n- The maximal robustly feasible borrowing capacity $b_{\\max}$.\n- The $x_1$-axis intercept $x_1^{\\max}$ of the resulting budget line with $x_2 = 0$, that is, $x_1^{\\max} = (w_0 + b_{\\max})/p_1$.\n- The $x_2$-axis intercept $x_2^{\\max}$ of the resulting budget line with $x_1 = 0$, that is, $x_2^{\\max} = (w_0 + b_{\\max})/p_2$.\n\nReport each of the three quantities as a decimal rounded to six digits after the decimal point.\n\nTest suite. Each case is a tuple $(p_1,p_2,w_0,q,E_{\\min},E_{\\max},f,k,r,B_{\\max})$:\n- Case $1$: $(2.0,\\,3.0,\\,10.0,\\,5.0,\\,180.0,\\,220.0,\\,0.01,\\,5.0,\\,0.05,\\,1000.0)$.\n- Case $2$: $(1.5,\\,4.0,\\,20.0,\\,2.0,\\,5.555555555555556,\\,6.0,\\,0.1,\\,10.0,\\,0.1,\\,100.0)$.\n- Case $3$: $(5.0,\\,2.0,\\,0.0,\\,3.0,\\,100.0,\\,200.0,\\,0.0,\\,0.0,\\,0.2,\\,1000.0)$.\n- Case $4$: $(1.0,\\,1.0,\\,5.0,\\,10.0,\\,50.0,\\,60.0,\\,0.05,\\,0.0,\\,0.0,\\,100.0)$.\n- Case $5$: $(2.0,\\,2.0,\\,0.0,\\,1.0,\\,100.0,\\,150.0,\\,0.1,\\,5.0,\\,1.0,\\,1000.0)$.\n- Case $6$: $(3.0,\\,6.0,\\,7.0,\\,0.0,\\,100.0,\\,120.0,\\,0.2,\\,1.0,\\,0.3,\\,50.0)$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case $i$, output the list $[b_{\\max,i},x_{1,i}^{\\max},x_{2,i}^{\\max}]$ with each number rounded to six digits after the decimal point. Aggregate the six case-level lists into a single list in the same order as above, with no spaces anywhere. For example, an output with two hypothetical cases would look like $[[1.000000,2.000000,3.000000],[4.000000,5.000000,6.000000]]$.", "solution": "The problem is to determine the date $0$ budget line in fiat given a future cryptocurrency income that is uncertain but bounded and a lender who requires robust solvency for every exchange rate realization in the interval $[E_{\\min}, E_{\\max}]$. The core steps rely on the definition of feasibility under the robust solvency constraint and on the definition of a budget line.\n\nFirst, consider the robust borrowing constraint. For any chosen loan $b \\in [0,B_{\\max}]$, the solvency requirement demands that for each $E \\in [E_{\\min}, E_{\\max}]$ there exists a sale quantity $z(E) \\in [0,q]$ such that\n$$(1-f) E \\, z(E) - k \\cdot \\mathbf{1}_{\\{z(E) &gt; 0\\}} \\;\\ge\\; (1+r) b.$$\nLet us analyze the maximum fiat that can be guaranteed for repayment across all $E$ given the ability to select $z(E)$ after $E$ is realized.\n\nFix $E \\in [E_{\\min}, E_{\\max}]$. The proceeds function when selling $z \\in [0,q]$ units is\n$$\\pi(E,z) \\;=\\; \\begin{cases}\n0, & z = 0,\\\\\n(1-f) E \\, z - k, & z \\in (0,q].\n\\end{cases}$$\nFor a given $E$, the proceeds $\\pi(E,z)$ are nondecreasing in $z$ on $(0,q]$ because $(1-f)E \\ge 0$. Therefore, conditional on selling at all, the maximal proceeds at that $E$ arise from selling the entire endowment:\n$$\\max_{z \\in (0,q]} \\pi(E,z) \\;=\\; (1-f) E \\, q - k.$$\nHowever, the consumer can also choose not to sell and thereby avoid the fixed fee $k$, yielding proceeds $0$. Thus, the maximal proceeds at rate $E$ that can be guaranteed by an optimal sale decision at that $E$ are\n$$\\Pi(E) \\;=\\; \\max\\!\\big(0,\\,(1-f) E \\, q - k\\big).$$\n\nThe lender requires that the repayment $(1+r) b$ not exceed the proceeds available at any $E \\in [E_{\\min}, E_{\\max}]$ under the optimal sale decision for that $E$. This induces the robust bound\n$$(1+r) b \\;\\le\\; \\inf_{E \\in [E_{\\min}, E_{\\max}]} \\Pi(E).$$\nBecause $\\Pi(E)$ is nondecreasing in $E$ (as $(1-f) E \\, q - k$ is nondecreasing and the maximum with $0$ preserves monotonicity), the infimum over $[E_{\\min}, E_{\\max}]$ is attained at $E_{\\min}$:\n$$\\inf_{E \\in [E_{\\min}, E_{\\max}]} \\Pi(E) \\;=\\; \\max\\!\\big(0,\\,(1-f) E_{\\min} \\, q - k\\big).$$\nHence the largest $b$ consistent with robust solvency and the exogenous cap is\n$$b_{\\max} \\;=\\; \\min\\!\\left(B_{\\max},\\; \\frac{\\max\\!\\big(0,\\,(1-f) E_{\\min} \\, q - k\\big)}{1+r}\\right).$$\n\nNext, the date $0$ budget set is defined by the standard linear expenditure constraint\n$$p_1 x_1 + p_2 x_2 \\;\\le\\; w_0 + b,$$\nwith $b \\in [0,b_{\\max}]$ and $x_1 \\ge 0$, $x_2 \\ge 0$. The outer envelope of the budget set is the budget line obtained when $b = b_{\\max}$. The $x_1$-axis and $x_2$-axis intercepts of this line, obtained by setting the other good’s consumption to zero, are\n$$x_1^{\\max} \\;=\\; \\frac{w_0 + b_{\\max}}{p_1}, \\qquad x_2^{\\max} \\;=\\; \\frac{w_0 + b_{\\max}}{p_2}.$$\n\nTherefore, the computation for each case proceeds from first principles as follows:\n1. Compute the worst-case guaranteed proceeds $\\max\\!\\big(0,\\,(1-f) E_{\\min} \\, q - k\\big)$.\n2. Divide by $(1+r)$ to obtain the lending bound implied by repayment, and take the minimum with $B_{\\max}$ to obtain $b_{\\max}$.\n3. Compute $x_1^{\\max} = (w_0 + b_{\\max})/p_1$ and $x_2^{\\max} = (w_0 + b_{\\max})/p_2$.\n\nApplying these steps to each test case and rounding all reported numbers to six digits after the decimal point yields the outputs required by the specification.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\n\ndef robust_borrowing_capacity(p1, p2, w0, q, E_min, E_max, f, k, r, B_max):\n    \"\"\"\n    Compute b_max = min(B_max, max(0, (1-f)*E_min*q - k) / (1+r))\n    Then compute axis intercepts:\n      x1_max = (w0 + b_max)/p1\n      x2_max = (w0 + b_max)/p2\n    \"\"\"\n    # Worst-case guaranteed proceeds at E_min given optimal choice of z(E)\n    proceeds_low = (1.0 - f) * E_min * q - k\n    guaranteed = proceeds_low if proceeds_low > 0.0 else 0.0\n    denom = 1.0 + r\n    # Guard against any numerical issues (denom should be > 0 given r >= 0 in problem)\n    if denom <= 0.0:\n        # Fallback: if denom is zero or negative (not in provided tests), set borrowing bound to 0\n        b_bound = 0.0\n    else:\n        b_bound = guaranteed / denom\n    b_max = b_bound if b_bound <= B_max else B_max\n    # Axis intercepts\n    x1_max = (w0 + b_max) / p1\n    x2_max = (w0 + b_max) / p2\n    return b_max, x1_max, x2_max\n\ndef fmt6(x):\n    # Format with exactly 6 digits after the decimal, avoiding \"-0.000000\"\n    if abs(x) < 0.0000005:\n        x = 0.0\n    return f\"{x:.6f}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (p1, p2, w0, q, E_min, E_max, f, k, r, B_max)\n    test_cases = [\n        (2.0, 3.0, 10.0, 5.0, 180.0, 220.0, 0.01, 5.0, 0.05, 1000.0),            # Case 1\n        (1.5, 4.0, 20.0, 2.0, 5.555555555555556, 6.0, 0.1, 10.0, 0.1, 100.0),    # Case 2\n        (5.0, 2.0, 0.0, 3.0, 100.0, 200.0, 0.0, 0.0, 0.2, 1000.0),               # Case 3\n        (1.0, 1.0, 5.0, 10.0, 50.0, 60.0, 0.05, 0.0, 0.0, 100.0),                # Case 4\n        (2.0, 2.0, 0.0, 1.0, 100.0, 150.0, 0.1, 5.0, 1.0, 1000.0),               # Case 5\n        (3.0, 6.0, 7.0, 0.0, 100.0, 120.0, 0.2, 1.0, 0.3, 50.0),                 # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        p1, p2, w0, q, E_min, E_max, f, k, r, B_max = case\n        b_max, x1_max, x2_max = robust_borrowing_capacity(p1, p2, w0, q, E_min, E_max, f, k, r, B_max)\n        results.append((b_max, x1_max, x2_max))\n\n    # Build output string with no spaces and six decimals per number\n    inner_lists = []\n    for b, x1, x2 in results:\n        inner = f\"[{fmt6(b)},{fmt6(x1)},{fmt6(x2)}]\"\n        inner_lists.append(inner)\n    output = f\"[{','.join(inner_lists)}]\"\n    # Final print statement in the exact required format.\n    print(output)\n\nsolve()\n```"}]}