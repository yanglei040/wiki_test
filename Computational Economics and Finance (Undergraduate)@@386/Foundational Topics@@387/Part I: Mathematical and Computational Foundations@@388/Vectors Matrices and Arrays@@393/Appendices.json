{"hands_on_practices": [{"introduction": "Vectors provide a powerful and intuitive language for representing and manipulating financial data like portfolio holdings. This first exercise grounds your understanding in a fundamental application: portfolio rebalancing. You will use basic vector operations to model the trades required to shift from an initial portfolio to a target one and then calculate the associated transaction costs, linking abstract vector arithmetic directly to a critical, real-world cost in asset management [@problem_id:2447786].", "id": "2447786", "problem": "A portfolio manager rebalances a five-asset portfolio in a frictional market with proportional transaction costs. The current portfolio weights are $w^{(0)} = (0.25, 0.35, 0.10, 0.20, 0.10)$, and the target weights after rebalancing are $w^{(1)} = (0.20, 0.40, 0.15, 0.15, 0.10)$. The trade vector in portfolio weights is $x = w^{(1)} - w^{(0)}$. Each asset $i$ incurs a proportional transaction-cost rate $c_i$ per unit of portfolio wealth traded, with cost rates given by the vector $c = (0.001, 0.0015, 0.0005, 0.002, 0.001)$. The one-period total transaction cost as a fraction of initial total wealth is defined as the sum of the entries of the Hadamard (element-wise) product between the absolute trade vector and the cost vector, that is,\n$$S = \\sum_{i=1}^{5} |x_i|\\,c_i.$$\nCompute $S$. Express your answer as a decimal number (no percentage sign). No rounding instruction is required if the value is exact.", "solution": "The problem statement has been validated and is deemed scientifically grounded, well-posed, and objective. It provides a complete and consistent set of data and definitions from the field of computational finance, allowing for a unique and meaningful solution. We may therefore proceed with the calculation.\n\nThe problem requires the computation of the total transaction cost, $S$, for rebalancing a five-asset portfolio. We are given the initial portfolio weights vector $w^{(0)}$, the target weights vector $w^{(1)}$, and the vector of proportional transaction-cost rates $c$.\n\nThe initial weights are given as the vector:\n$$w^{(0)} = (0.25, 0.35, 0.10, 0.20, 0.10)$$\nThe target weights after rebalancing are:\n$$w^{(1)} = (0.20, 0.40, 0.15, 0.15, 0.10)$$\n\nFirst, we must calculate the trade vector, $x$, which is defined as the difference between the target weights and the current weights:\n$$x = w^{(1)} - w^{(0)}$$\nSubstituting the given vectors, we perform an element-wise subtraction:\n$$x = (0.20 - 0.25, 0.40 - 0.35, 0.15 - 0.10, 0.15 - 0.20, 0.10 - 0.10)$$\n$$x = (-0.05, 0.05, 0.05, -0.05, 0.00)$$\nThe components $x_i$ of this vector represent the change in the portfolio weight for each asset $i$. A negative value indicates a sale, and a positive value indicates a purchase.\n\nThe total transaction cost, $S$, is defined as the sum of the costs for each trade, which is given by the formula:\n$$S = \\sum_{i=1}^{5} |x_i|\\,c_i$$\nThis formula corresponds to the dot product of the absolute trade vector, $|x|$, and the cost-rate vector, $c$. The absolute trade vector contains the absolute values of the components of $x$:\n$$|x| = (|-0.05|, |0.05|, |0.05|, |-0.05|, |0.00|)$$\n$$|x| = (0.05, 0.05, 0.05, 0.05, 0.00)$$\nThe vector of transaction-cost rates is given as:\n$$c = (0.001, 0.0015, 0.0005, 0.002, 0.001)$$\n\nNow we can compute $S$ by substituting the values of $|x_i|$ and $c_i$ into the summation formula:\n$$S = |x_1|c_1 + |x_2|c_2 + |x_3|c_3 + |x_4|c_4 + |x_5|c_5$$\n$$S = (0.05)(0.001) + (0.05)(0.0015) + (0.05)(0.0005) + (0.05)(0.002) + (0.00)(0.001)$$\nLet us evaluate each term:\n$$S = 0.00005 + 0.000075 + 0.000025 + 0.0001 + 0$$\nSumming these values gives the total transaction cost:\n$$S = 0.00025$$\nAlternatively, we can factor out the common term $0.05$ from the first four terms:\n$$S = 0.05 \\times (0.001 + 0.0015 + 0.0005 + 0.002) + 0$$\n$$S = 0.05 \\times (0.005)$$\n$$S = 0.00025$$\nThe result is an exact decimal value, representing the total transaction cost as a fraction of the portfolio's initial total wealth.", "answer": "$$\\boxed{0.00025}$$"}, {"introduction": "Beyond representing static collections of assets, vectors and matrices excel at modeling complex, interconnected systems. This practice moves from the portfolio level to the macroeconomic scale, exploring the celebrated gravity model of international trade. You will construct a matrix representing all bilateral trade flows between a set of countries by combining vectors of economic size (GDP) and a matrix of distances, using powerful operations like the outer product and Hadamard (element-wise) division to build the model from its core components [@problem_id:2447752].", "id": "2447752", "problem": "Consider a world with three countries. Let the vector of gross domestic products (GDP) in a common monetary unit be $g \\in \\mathbb{R}^{3}$ with $g = \\begin{pmatrix} 2 \\\\ 3 \\\\ 5 \\end{pmatrix}$. Let the symmetric distance matrix be\n$$\nD \\;=\\; \\begin{pmatrix}\n1 & 1 & 2 \\\\\n1 & 1 & 4 \\\\\n2 & 4 & 1\n\\end{pmatrix},\n$$\nwhere for $i \\neq j$, $D_{ij}$ is the bilateral distance between countries $i$ and $j$ in a common distance unit, and diagonal entries are placeholders that will not be used because intranational trade is excluded. Define the off-diagonal mask matrix\n$$\nM \\;=\\; \\begin{pmatrix}\n0 & 1 & 1 \\\\\n1 & 0 & 1 \\\\\n1 & 1 & 0\n\\end{pmatrix}.\n$$\nFor conformable matrices $X$ and $Y$ with strictly positive entries, define the Hadamard (elementwise) product by $(X \\circ Y)_{ij} = X_{ij} Y_{ij}$ and the Hadamard (elementwise) division by $(X \\oslash Y)_{ij} = X_{ij} / Y_{ij}$.\n\nThe baseline gravity model of international trade posits that for $i \\neq j$, the predicted bilateral trade flow from country $i$ to country $j$ is proportional to the product of their GDPs and inversely proportional to their distance, with a common proportionality constant $A > 0$. Using outer products and Hadamard operations, define the $3 \\times 3$ matrix of predicted bilateral trade flows as\n$$\nT \\;=\\; A \\,\\big( (g g^{\\top}) \\oslash D \\big) \\circ M.\n$$\n\nSuppose the observed total bilateral trade across all ordered country pairs is $S = 2.95$ in the same trade-flow unit as $T$. Choose $A$ so that the sum of the off-diagonal entries of $T$ equals $S$. Compute the numerical value of $A$. Provide a single real number; no rounding is required, and do not include units with your final answer.", "solution": "The problem statement is first subjected to validation. It is found to be scientifically grounded, describing a standard gravity model of trade from computational economics. The problem is well-posed, providing all necessary data and definitions for a unique solution. It is expressed in objective, unambiguous language. All necessary conditions for validity are satisfied. Therefore, a solution is derived as follows.\n\nThe problem requires us to find the value of the proportionality constant $A$, given the vector of gross domestic products $g$, the distance matrix $D$, the mask matrix $M$, and the total observed bilateral trade $S$. The matrix of predicted bilateral trade flows, $T$, is defined by the equation:\n$$\nT \\;=\\; A \\,\\big( (g g^{\\top}) \\oslash D \\big) \\circ M\n$$\nThe condition to determine $A$ is that the sum of the off-diagonal entries of $T$ must be equal to the total observed trade $S = 2.95$. Let us denote the sum of all entries of a matrix $X$ by $\\Sigma(X)$. The condition is $\\sum_{i \\neq j} T_{ij} = S$.\n\nThe mask matrix $M$ is defined as:\n$$\nM \\;=\\; \\begin{pmatrix}\n0 & 1 & 1 \\\\\n1 & 0 & 1 \\\\\n1 & 1 & 0\n\\end{pmatrix}\n$$\nThe entries on the main diagonal of $M$ are all $0$. The definition of the Hadamard product `$\\circ$` implies that the entries on the main diagonal of $T$ will also be $0$, since $(X \\circ M)_{ii} = X_{ii} M_{ii} = X_{ii} \\cdot 0 = 0$. Consequently, the sum of the off-diagonal entries of $T$ is identical to the sum of all entries of $T$. The governing equation is therefore $\\Sigma(T) = S$.\n\nLet us define the matrix $T_0 = \\big( (g g^{\\top}) \\oslash D \\big) \\circ M$. The trade matrix is then $T = A \\cdot T_0$. The sum of its elements is $\\Sigma(T) = \\Sigma(A \\cdot T_0) = A \\cdot \\Sigma(T_0)$. The equation to solve for $A$ becomes:\n$$\nA \\cdot \\Sigma(T_0) = S\n$$\nwhich yields $A = \\frac{S}{\\Sigma(T_0)}$. Our task reduces to computing the numerical value of $\\Sigma(T_0)$.\n\nThe given data are:\n$S = 2.95$, $g = \\begin{pmatrix} 2 \\\\ 3 \\\\ 5 \\end{pmatrix}$, and $D = \\begin{pmatrix} 1 & 1 & 2 \\\\ 1 & 1 & 4 \\\\ 2 & 4 & 1 \\end{pmatrix}$.\n\nFirst, we compute the outer product $g g^{\\top}$:\n$$\ng g^{\\top} \\;=\\; \\begin{pmatrix} 2 \\\\ 3 \\\\ 5 \\end{pmatrix} \\begin{pmatrix} 2 & 3 & 5 \\end{pmatrix} \\;=\\; \\begin{pmatrix} 2 \\times 2 & 2 \\times 3 & 2 \\times 5 \\\\ 3 \\times 2 & 3 \\times 3 & 3 \\times 5 \\\\ 5 \\times 2 & 5 \\times 3 & 5 \\times 5 \\end{pmatrix} \\;=\\; \\begin{pmatrix} 4 & 6 & 10 \\\\ 6 & 9 & 15 \\\\ 10 & 15 & 25 \\end{pmatrix}\n$$\n\nSecond, we perform the Hadamard (elementwise) division of $g g^{\\top}$ by the distance matrix $D$:\n$$\n(g g^{\\top}) \\oslash D \\;=\\; \\begin{pmatrix} \\frac{4}{1} & \\frac{6}{1} & \\frac{10}{2} \\\\ \\frac{6}{1} & \\frac{9}{1} & \\frac{15}{4} \\\\ \\frac{10}{2} & \\frac{15}{4} & \\frac{25}{1} \\end{pmatrix} \\;=\\; \\begin{pmatrix} 4 & 6 & 5 \\\\ 6 & 9 & 3.75 \\\\ 5 & 3.75 & 25 \\end{pmatrix}\n$$\nNote that the diagonal entries of $D$ are described as placeholders and are not used in the final calculation due to the mask matrix $M$. The off-diagonal entries of $D$ are all non-zero, so the division is well-defined for the relevant elements.\n\nThird, we compute $T_0$ by applying the Hadamard product with the mask matrix $M$:\n$$\nT_0 \\;=\\; \\big( (g g^{\\top}) \\oslash D \\big) \\circ M \\;=\\; \\begin{pmatrix} 4 & 6 & 5 \\\\ 6 & 9 & 3.75 \\\\ 5 & 3.75 & 25 \\end{pmatrix} \\circ \\begin{pmatrix} 0 & 1 & 1 \\\\ 1 & 0 & 1 \\\\ 1 & 1 & 0 \\end{pmatrix} \\;=\\; \\begin{pmatrix} 0 & 6 & 5 \\\\ 6 & 0 & 3.75 \\\\ 5 & 3.75 & 0 \\end{pmatrix}\n$$\n\nFourth, we calculate the sum of all elements of $T_0$, which we denoted $\\Sigma(T_0)$:\n$$\n\\Sigma(T_0) \\;=\\; 0 + 6 + 5 + 6 + 0 + 3.75 + 5 + 3.75 + 0\n$$\n$$\n\\Sigma(T_0) \\;=\\; (6 + 6) + (5 + 5) + (3.75 + 3.75) \\;=\\; 12 + 10 + 7.5 = 29.5\n$$\n\nFinally, we substitute the values of $S$ and $\\Sigma(T_0)$ into the expression for $A$:\n$$\nA \\;=\\; \\frac{S}{\\Sigma(T_0)} \\;=\\; \\frac{2.95}{29.5}\n$$\n$$\nA \\;=\\; \\frac{29.5 \\times 0.1}{29.5} \\;=\\; 0.1\n$$\nThe proportionality constant $A$ is precisely $0.1$. This result is consistent with the condition $A>0$.", "answer": "$$ \\boxed{0.1} $$"}, {"introduction": "Eigendecomposition is a cornerstone of advanced data analysis, allowing us to uncover the most important structural patterns within a dataset. In finance, the eigenvectors of an asset return covariance matrix correspond to the market's principal components of risk. This practice challenges you to apply this profound concept by constructing a portfolio whose returns are, by design, uncorrelated with the market's dominant risk factors, providing a hands-on introduction to building sophisticated 'eigen-portfolios' through constrained optimization [@problem_id:2447812].", "id": "2447812", "problem": "You are given a symmetric positive definite covariance matrix $\\Sigma \\in \\mathbb{R}^{n \\times n}$ describing the joint distribution of $n$ asset returns, and an integer $k$ with $0 \\le k \\le n-1$. Let $\\Sigma = Q \\Lambda Q^{\\top}$ be its eigenvalue decomposition, where the columns of $Q$ are orthonormal eigenvectors and $\\Lambda = \\mathrm{diag}(\\lambda_1,\\dots,\\lambda_n)$ with $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_n > 0$. The first $k$ principal components in the sense of Principal Component Analysis (PCA) are the eigenvectors corresponding to the largest $k$ eigenvalues, namely the first $k$ columns of $Q$. A portfolio weight vector $w \\in \\mathbb{R}^n$ has zero correlation with the $i$-th principal component time series if and only if $w^{\\top} \\Sigma v_i = 0$, where $v_i$ is the $i$-th eigenvector of $\\Sigma$.\n\nConstruct an eigen-portfolio weight vector $w$ that satisfies both of the following conditions:\n- Zero-correlation constraints: $w^{\\top} \\Sigma v_i = 0$ for all $i \\in \\{1,2,\\dots,k\\}$.\n- Unit-budget constraint: $\\mathbf{1}^{\\top} w = 1$, where $\\mathbf{1} \\in \\mathbb{R}^n$ is the vector of ones.\n\nAmong all such $w$, select the unique minimizer of the variance $w^{\\top} \\Sigma w$. Your program must compute $w$ for each test case in the suite below and report the resulting weight vectors.\n\nAngles are not involved. No physical units are involved. All reported numbers must be real numbers. Your program must output the results in a single line as a comma-separated list of lists, where each inner list contains the portfolio weights for a test case, rounded to $6$ decimal places.\n\nTest Suite:\n- Test case $\\#1$: $n=3$, $k=1$, \n  $\\Sigma = \\mathrm{diag}([\\,0.16,\\,0.09,\\,0.04\\,])$.\n- Test case $\\#2$: $n=4$, $k=2$, \n  $\\Sigma = \\mathrm{diag}([\\,0.09,\\,0.0625,\\,0.04,\\,0.0225\\,])$.\n- Test case $\\#3$: $n=5$, $k=0$, \n  $\\Sigma = \\mathrm{diag}([\\,0.25,\\,0.16,\\,0.09,\\,0.04,\\,0.01\\,])$.\n- Test case $\\#4$: $n=5$, $k=4$, \n  $\\Sigma = \\mathrm{diag}([\\,0.25,\\,0.16,\\,0.09,\\,0.04,\\,0.01\\,])$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the weight vectors for the test suite as a comma-separated list enclosed in square brackets, with each vector serialized as a list of $n$ floats rounded to $6$ decimal places, in the same order as the test cases. For example, an output with two vectors should look like $[[w_{1,1},w_{1,2},\\dots],[w_{2,1},w_{2,2},\\dots]]$.", "solution": "The problem presented is a constrained quadratic optimization problem set within the context of financial portfolio theory. We are tasked with constructing a portfolio weight vector $w \\in \\mathbb{R}^n$ that minimizes portfolio variance, given by $w^{\\top} \\Sigma w$, while adhering to a set of linear constraints. The constraints require the portfolio to have zero correlation with the first $k$ principal components of asset returns and to be fully invested.\n\nFirst, we formalize the optimization problem. We seek to find $w$ that solves:\n$$ \\text{minimize} \\quad f(w) = w^{\\top} \\Sigma w $$\nsubject to the constraints:\n1.  $w^{\\top} \\Sigma v_i = 0$ for $i \\in \\{1, 2, \\dots, k\\}$ (Zero-correlation constraints)\n2.  $\\mathbf{1}^{\\top} w = 1$ (Unit-budget constraint)\n\nHere, $\\Sigma$ is a symmetric positive definite covariance matrix, $v_i$ is the $i$-th eigenvector of $\\Sigma$ corresponding to the eigenvalue $\\lambda_i$, and $\\mathbf{1}$ is the vector of ones. The eigenvalues are ordered such that $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_n > 0$.\n\nThe zero-correlation constraint can be simplified. From the eigenvector definition, $\\Sigma v_i = \\lambda_i v_i$. Substituting this into the constraint gives:\n$$ w^{\\top} (\\lambda_i v_i) = \\lambda_i (w^{\\top} v_i) = 0 $$\nSince $\\Sigma$ is positive definite, all its eigenvalues $\\lambda_i$ are strictly positive. Thus, we can divide by $\\lambda_i$, and the constraint becomes equivalent to:\n$$ w^{\\top} v_i = 0 \\quad \\text{for } i \\in \\{1, 2, \\dots, k\\} $$\nThis condition states that the weight vector $w$ must be orthogonal to the first $k$ eigenvectors of $\\Sigma$. The eigenvectors $\\{v_1, \\dots, v_n\\}$ form an orthonormal basis for $\\mathbb{R}^n$. A vector orthogonal to the first $k$ basis vectors must lie in the subspace spanned by the remaining $n-k$ basis vectors, $\\{v_{k+1}, \\dots, v_n\\}$.\nTherefore, $w$ can be expressed as a linear combination of these remaining eigenvectors:\n$$ w = \\sum_{j=k+1}^{n} c_j v_j $$\nfor some scalar coefficients $c_{k+1}, \\dots, c_n$. Let $c$ be the vector of these coefficients.\n\nNow, we substitute this representation of $w$ into the objective function and the unit-budget constraint.\nThe objective function becomes:\n$$ w^{\\top} \\Sigma w = \\left(\\sum_{j=k+1}^{n} c_j v_j\\right)^{\\top} \\Sigma \\left(\\sum_{l=k+1}^{n} c_l v_l\\right) = \\sum_{j=k+1}^{n} \\sum_{l=k+1}^{n} c_j c_l (v_j^{\\top} \\Sigma v_l) $$\nDue to the property $v_j^{\\top} \\Sigma v_l = v_j^{\\top} (\\lambda_l v_l) = \\lambda_l (v_j^{\\top} v_l) = \\lambda_l \\delta_{jl}$, where $\\delta_{jl}$ is the Kronecker delta, the objective function simplifies to:\n$$ w^{\\top} \\Sigma w = \\sum_{j=k+1}^{n} c_j^2 \\lambda_j $$\nThe unit-budget constraint becomes:\n$$ \\mathbf{1}^{\\top} w = \\mathbf{1}^{\\top} \\left(\\sum_{j=k+1}^{n} c_j v_j\\right) = \\sum_{j=k+1}^{n} c_j (\\mathbf{1}^{\\top} v_j) = 1 $$\nLet us define $u_j = \\mathbf{1}^{\\top} v_j$. The constraint is then $\\sum_{j=k+1}^{n} c_j u_j = 1$.\n\nThe problem is now reduced to finding the coefficients $c_j$ that solve:\n$$ \\text{minimize} \\quad \\sum_{j=k+1}^{n} c_j^2 \\lambda_j $$\n$$ \\text{subject to} \\quad \\sum_{j=k+1}^{n} c_j u_j = 1 $$\nThis is a standard problem solvable with the method of Lagrange multipliers. The Lagrangian is:\n$$ \\mathcal{L}(c, \\mu) = \\sum_{j=k+1}^{n} c_j^2 \\lambda_j - \\mu \\left(\\sum_{j=k+1}^{n} c_j u_j - 1\\right) $$\nTaking the partial derivative with respect to each $c_j$ and setting it to zero yields the first-order conditions:\n$$ \\frac{\\partial \\mathcal{L}}{\\partial c_j} = 2 c_j \\lambda_j - \\mu u_j = 0 \\implies c_j = \\frac{\\mu u_j}{2 \\lambda_j} $$\nWe find the Lagrange multiplier $\\mu$ by substituting this expression for $c_j$ back into the constraint:\n$$ \\sum_{j=k+1}^{n} \\left(\\frac{\\mu u_j}{2 \\lambda_j}\\right) u_j = 1 \\implies \\frac{\\mu}{2} \\sum_{j=k+1}^{n} \\frac{u_j^2}{\\lambda_j} = 1 $$\n$$ \\mu = \\frac{2}{\\sum_{i=k+1}^{n} u_i^2 / \\lambda_i} $$\nSubstituting $\\mu$ back into the expression for $c_j$:\n$$ c_j = \\frac{u_j}{\\lambda_j} \\left( \\frac{1}{\\sum_{i=k+1}^{n} u_i^2 / \\lambda_i} \\right) $$\nThe final weight vector is then reconstructed as $w = \\sum_{j=k+1}^{n} c_j v_j$.\n\nFor the specific test cases provided, the covariance matrix $\\Sigma$ is diagonal. This significantly simplifies the calculations. For a diagonal matrix $\\Sigma = \\mathrm{diag}(\\lambda_1, \\dots, \\lambda_n)$, the eigenvalues are the diagonal elements $\\lambda_i$, and the corresponding eigenvectors are the standard basis vectors $v_i = e_i$, where $e_i$ has a $1$ at the $i$-th position and zeros elsewhere.\nIn this case, the scalars $u_j$ become:\n$$ u_j = \\mathbf{1}^{\\top} v_j = \\mathbf{1}^{\\top} e_j = 1 \\quad \\text{for all } j $$\nThe expression for the coefficients $c_j$ simplifies to:\n$$ c_j = \\frac{1}{\\lambda_j} \\left( \\frac{1}{\\sum_{i=k+1}^{n} 1 / \\lambda_i} \\right) $$\nThe weight vector $w$ is $w = \\sum_{j=k+1}^{n} c_j e_j$. This means the components of $w$, denoted by $w_j$, are:\n$$ w_j = \\begin{cases} 0 & \\text{if } 1 \\le j \\le k \\\\ c_j & \\text{if } k+1 \\le j \\le n \\end{cases} $$\nSo, for $j \\in \\{k+1, \\dots, n\\}$, the weight is:\n$$ w_j = \\frac{1/\\lambda_j}{\\sum_{i=k+1}^{n} 1/\\lambda_i} $$\nThis formula provides a direct method to compute the weight vector for the given test cases. The first $k$ weights are zero, and the remaining $n-k$ weights are distributed proportionally to the inverse of their corresponding eigenvalues, normalized to sum to one.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the eigen-portfolio optimization problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {'sigma_diag': np.array([0.16, 0.09, 0.04]), 'k': 1},\n        {'sigma_diag': np.array([0.09, 0.0625, 0.04, 0.0225]), 'k': 2},\n        {'sigma_diag': np.array([0.25, 0.16, 0.09, 0.04, 0.01]), 'k': 0},\n        {'sigma_diag': np.array([0.25, 0.16, 0.09, 0.04, 0.01]), 'k': 4},\n    ]\n\n    def compute_weights(sigma_diag: np.ndarray, k: int) -> list[float]:\n        \"\"\"\n        Computes the optimal portfolio weights for a diagonal covariance matrix.\n\n        Args:\n            sigma_diag: A numpy array containing the diagonal elements of Sigma,\n                        which are the eigenvalues sorted in descending order.\n            k: The number of principal components to be uncorrelated with.\n\n        Returns:\n            A list of portfolio weights rounded to 6 decimal places.\n        \"\"\"\n        n = len(sigma_diag)\n        \n        # The weights corresponding to the first k principal components are zero.\n        # Problem statement uses 1-based indexing for k, so in 0-based Python,\n        # weights w[0]...w[k-1] are zero.\n        # The remaining weights are calculated for indices k to n-1.\n        w = np.zeros(n)\n\n        # The problem constraints ensure 0 <= k <= n-1, so the slice for\n        # relevant_lambdas is always non-empty.\n        \n        # Eigenvalues to be used are from index k to n-1.\n        relevant_lambdas = sigma_diag[k:]\n        \n        # The formula for weights w_j (for j >= k) is (1/lambda_j) / sum(1/lambda_i)\n        # where the sum is over i from k to n-1.\n        inv_lambdas = np.reciprocal(relevant_lambdas)\n        sum_inv_lambdas = np.sum(inv_lambdas)\n        \n        # Calculate the non-zero portion of the weights\n        non_zero_weights = inv_lambdas / sum_inv_lambdas\n        \n        # Assign the calculated weights to the final weight vector\n        w[k:] = non_zero_weights\n        \n        return list(np.round(w, 6))\n\n    all_results = []\n    for case in test_cases:\n        weights = compute_weights(case['sigma_diag'], case['k'])\n        all_results.append(weights)\n        \n    # Format the final output string according to the problem specification.\n    # Ex: [[w11,w12,...],[w21,w22,...]]\n    # This requires creating a string for each inner list and then joining them.\n    \n    # Using python's default str(list) representation introduces spaces\n    # after commas, which might be undesirable. Manual formatting ensures\n    # the output is exactly as specified.\n    # Example: [0.0, 0.36, 0.64] -> \"[0.000000,0.360000,0.640000]\"\n    \n    w_strings = []\n    for w_vector in all_results:\n        w_str = f\"[{','.join([f'{x:.6f}' for x in w_vector])}]\"\n        w_strings.append(w_str)\n    \n    final_output = f\"[{','.join(w_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"}]}