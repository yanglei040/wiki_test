{"hands_on_practices": [{"introduction": "Before diving into the complexities of default contagion, let's start with a foundational policy question. Imagine you are a regulator tasked with stabilizing a financial system; what is the absolute minimum capital injection required to ensure every institution can meet its obligations? This exercise [@problem_id:2392858] guides you through formulating this question as an optimization problem and reveals a surprisingly elegant analytical solution that defines the bedrock condition for system-wide solvency.", "id": "2392858", "problem": "Consider a financial system of $n$ institutions modeled in the framework of Eisenberg and Noe. Let $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ be the matrix of nominal interbank liabilities, where $L_{ij}$ denotes the nominal liability of institution $i$ to institution $j$. Define the vector of total nominal obligations $\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$ by $\\bar{p}_i = \\sum_{j=1}^n L_{ij}$, and define the relative liabilities matrix $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ by\n$$\n\\pi_{ij} = \n\\begin{cases}\n\\dfrac{L_{ij}}{\\bar{p}_i}, & \\text{if } \\bar{p}_i > 0,\\\n$$6pt]\n0, & \\text{if } \\bar{p}_i = 0.\n\\end{cases}\n$$\nLet $e \\in \\mathbb{R}_{\\ge 0}^n$ denote the vector of external assets. A clearing payment vector $p \\in \\mathbb{R}_{\\ge 0}^n$ satisfies the Eisenberg–Noe clearing condition\n$$\np = \\min\\left(\\bar{p}, \\, \\Pi^\\top p + e\\right),\n$$\nwhere the minimum is taken componentwise. The system is said to be saved if there exists a clearing vector $p$ such that $p = \\bar{p}$.\n\nA regulator can inject a nonnegative bailout vector $\\Delta e \\in \\mathbb{R}_{\\ge 0}^n$ into external assets, resulting in total external assets $e + \\Delta e$. Consider the optimization problem of finding a bailout that saves the system while minimizing the total bailout capital, that is, minimizing $\\sum_{i=1}^n \\Delta e_i$ subject to the system being saved.\n\nYour task is to compute, for each test case below, the minimum total bailout capital $\\sum_{i=1}^n \\Delta e_i$ (expressed as a decimal number), under the requirement that the post-bailout system is saved in the sense defined above.\n\nTest suite:\n- Case A ($n=3$):\n  - Liabilities matrix $L$:\n    $$\n    L = \\begin{bmatrix}\n    0 & 50 & 0\\\\\n    0 & 0 & 40\\\\\n    30 & 0 & 0\n    \\end{bmatrix}.\n    $$\n  - External assets $e$:\n    $$\n    e = \\begin{bmatrix}\n    10\\\\\n    5\\\\\n    5\n    \\end{bmatrix}.\n    $$\n- Case B ($n=2$):\n  - Liabilities matrix $L$:\n    $$\n    L = \\begin{bmatrix}\n    0 & 10\\\\\n    0 & 0\n    \\end{bmatrix}.\n    $$\n  - External assets $e$:\n    $$\n    e = \\begin{bmatrix}\n    10\\\\\n    0\n    \\end{bmatrix}.\n    $$\n- Case C ($n=3$):\n  - Liabilities matrix $L$:\n    $$\n    L = \\begin{bmatrix}\n    0 & 10 & 0\\\\\n    0 & 0 & 0\\\\\n    0 & 20 & 0\n    \\end{bmatrix}.\n    $$\n  - External assets $e$:\n    $$\n    e = \\begin{bmatrix}\n    0\\\\\n    0\\\\\n    0\n    \\end{bmatrix}.\n    $$\n- Case D ($n=2$):\n  - Liabilities matrix $L$:\n    $$\n    L = \\begin{bmatrix}\n    0 & 50\\\\\n    50 & 0\n    \\end{bmatrix}.\n    $$\n  - External assets $e$:\n    $$\n    e = \\begin{bmatrix}\n    0\\\\\n    0\n    \\end{bmatrix}.\n    $$\n\nAnswer specification:\n- For each case, compute the minimum total bailout capital $\\sum_{i=1}^n \\Delta e_i$ as a single real number (a float).\n- Your program should produce a single line of output containing the results as a comma-separated list of decimal numbers rounded to four decimal places, enclosed in square brackets, in the order $[\\text{Case A}, \\text{Case B}, \\text{Case C}, \\text{Case D}]$.\n\nNo physical units apply. Angles are not involved. Percentages must not be used; all quantities must be expressed as decimal numbers. The program must be self-contained and must not read any input.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded in the established Eisenberg-Noe model of financial clearing, is mathematically well-posed, objective, and provides a complete and consistent set of data and definitions for its resolution.\n\nThe core of the problem is to find the minimum total bailout capital $\\sum_{i=1}^n \\Delta e_i$ required to \"save\" the financial system. The system, with injected capital $\\Delta e$, has total external assets $e' = e + \\Delta e$. A system is defined as \"saved\" if the clearing payment vector $p$ equals the vector of total nominal obligations, $\\bar{p}$.\n\nThe clearing vector $p$ must satisfy the Eisenberg-Noe clearing condition, which, with the bailout, is:\n$$\np = \\min\\left(\\bar{p}, \\, \\Pi^\\top p + e + \\Delta e\\right)\n$$\nFor the system to be saved, the vector $p = \\bar{p}$ must be a solution to this equation. Substituting $p = \\bar{p}$ into the condition yields:\n$$\n\\bar{p} = \\min\\left(\\bar{p}, \\, \\Pi^\\top \\bar{p} + e + \\Delta e\\right)\n$$\nThis vector equation holds if and only if it holds for each component $i \\in \\{1, \\dots, n\\}$:\n$$\n\\bar{p}_i = \\min\\left(\\bar{p}_i, \\, (\\Pi^\\top \\bar{p})_i + e_i + \\Delta e_i\\right)\n$$\nThis is equivalent to the set of inequalities:\n$$\n\\bar{p}_i \\le (\\Pi^\\top \\bar{p})_i + e_i + \\Delta e_i\n$$\nThe regulator's task is to find a non-negative bailout vector, $\\Delta e \\in \\mathbb{R}_{\\ge 0}^n$, that satisfies this condition while minimizing the total expenditure $\\sum_{i=1}^n \\Delta e_i$.\n\nRearranging the inequality for $\\Delta e_i$, we obtain a lower bound for the required bailout for each institution:\n$$\n\\Delta e_i \\ge \\bar{p}_i - (\\Pi^\\top \\bar{p})_i - e_i\n$$\nSince the bailout contributions $\\Delta e_i$ must also be non-negative, the constraint becomes:\n$$\n\\Delta e_i \\ge \\max\\left(0, \\, \\bar{p}_i - (\\Pi^\\top \\bar{p})_i - e_i\\right)\n$$\nTo minimize the total sum $\\sum_{i=1}^n \\Delta e_i$, we must choose the smallest permissible value for each $\\Delta e_i$, as the constraints are independent. Thus, the optimal bailout for institution $i$ is:\n$$\n\\Delta e_i^* = \\max\\left(0, \\, \\bar{p}_i - (\\Pi^\\top \\bar{p})_i - e_i\\right)\n$$\nThe term $(\\Pi^\\top \\bar{p})_i$ represents the total assets institution $i$ is due to receive from its counterparties, assuming they all meet their full obligations. Let us analyze this term:\n$$\n(\\Pi^\\top \\bar{p})_i = \\sum_{j=1}^n (\\Pi^\\top)_{ij} \\bar{p}_j = \\sum_{j=1}^n \\pi_{ji} \\bar{p}_j\n$$\nBy definition, $\\pi_{ji} = L_{ji} / \\bar{p}_j$ if $\\bar{p}_j > 0$, and $\\pi_{ji} = 0$ if $\\bar{p}_j = 0$.\n- If $\\bar{p}_j > 0$, the term in the sum is $(L_{ji} / \\bar{p}_j) \\bar{p}_j = L_{ji}$.\n- If $\\bar{p}_j = 0$, then $\\sum_{k=1}^n L_{jk} = 0$. As liabilities are non-negative ($L_{jk} \\ge 0$), this implies $L_{jk} = 0$ for all $k$, so $L_{ji}=0$. The term in the sum is $\\pi_{ji} \\bar{p}_j = 0 \\cdot 0 = 0$. Thus, the term is also equal to $L_{ji}$.\nThis demonstrates rigorously that $\\pi_{ji} \\bar{p}_j = L_{ji}$ for all $j$. Therefore, the sum simplifies to:\n$$\n(\\Pi^\\top \\bar{p})_i = \\sum_{j=1}^n L_{ji}\n$$\nThis is simply the sum of the $i$-th column of the liabilities matrix $L$, representing the total nominal payments due to institution $i$.\nThe capital shortfall for institution $i$, before bailout, is the excess of its obligations over its total assets (assuming full payment from others):\n$$\ns_i = \\underbrace{\\sum_{j=1}^n L_{ij}}_{\\text{Obligations}} - \\left( \\underbrace{\\sum_{j=1}^n L_{ji}}_{\\text{Interbank Assets}} + \\underbrace{e_i}_{\\text{External Assets}} \\right)\n$$\nThe minimum total bailout capital is the sum of the positive shortfalls across all institutions:\n$$\n\\sum_{i=1}^n \\Delta e_i^* = \\sum_{i=1}^n \\max(0, s_i)\n$$\nWe now apply this formula to each test case.\n\n**Case A**\n- Liabilities $L = \\begin{bmatrix} 0 & 50 & 0 \\\\ 0 & 0 & 40 \\\\ 30 & 0 & 0 \\end{bmatrix}$, External assets $e = \\begin{bmatrix} 10 \\\\ 5 \\\\ 5 \\end{bmatrix}$.\n- Obligations (row sums of $L$): $\\bar{p} = \\begin{bmatrix} 50 \\\\ 40 \\\\ 30 \\end{bmatrix}$.\n- Interbank assets (column sums of $L$): $\\sum_j L_{j,:} = \\begin{bmatrix} 30 \\\\ 50 \\\\ 40 \\end{bmatrix}$.\n- Shortfalls $s_i = \\bar{p}_i - (\\sum_j L_{ji}) - e_i$:\n  - $s_1 = 50 - 30 - 10 = 10$\n  - $s_2 = 40 - 50 - 5 = -15$\n  - $s_3 = 30 - 40 - 5 = -15$\n- Bailouts $\\Delta e_i^* = \\max(0, s_i)$:\n  - $\\Delta e_1^* = \\max(0, 10) = 10$\n  - $\\Delta e_2^* = \\max(0, -15) = 0$\n  - $\\Delta e_3^* = \\max(0, -15) = 0$\n- Minimum total bailout: $10 + 0 + 0 = 10$.\n\n**Case B**\n- Liabilities $L = \\begin{bmatrix} 0 & 10 \\\\ 0 & 0 \\end{bmatrix}$, External assets $e = \\begin{bmatrix} 10 \\\\ 0 \\end{bmatrix}$.\n- Obligations (row sums of $L$): $\\bar{p} = \\begin{bmatrix} 10 \\\\ 0 \\end{bmatrix}$.\n- Interbank assets (column sums of $L$): $\\sum_j L_{j,:} = \\begin{bmatrix} 0 \\\\ 10 \\end{bmatrix}$.\n- Shortfalls $s_i = \\bar{p}_i - (\\sum_j L_{ji}) - e_i$:\n  - $s_1 = 10 - 0 - 10 = 0$\n  - $s_2 = 0 - 10 - 0 = -10$\n- Bailouts $\\Delta e_i^* = \\max(0, s_i)$:\n  - $\\Delta e_1^* = \\max(0, 0) = 0$\n  - $\\Delta e_2^* = \\max(0, -10) = 0$\n- Minimum total bailout: $0 + 0 = 0$. The system is already solvent.\n\n**Case C**\n- Liabilities $L = \\begin{bmatrix} 0 & 10 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 20 & 0 \\end{bmatrix}$, External assets $e = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$.\n- Obligations (row sums of $L$): $\\bar{p} = \\begin{bmatrix} 10 \\\\ 0 \\\\ 20 \\end{bmatrix}$.\n- Interbank assets (column sums of $L$): $\\sum_j L_{j,:} = \\begin{bmatrix} 0 \\\\ 30 \\\\ 0 \\end{bmatrix}$.\n- Shortfalls $s_i = \\bar{p}_i - (\\sum_j L_{ji}) - e_i$:\n  - $s_1 = 10 - 0 - 0 = 10$\n  - $s_2 = 0 - 30 - 0 = -30$\n  - $s_3 = 20 - 0 - 0 = 20$\n- Bailouts $\\Delta e_i^* = \\max(0, s_i)$:\n  - $\\Delta e_1^* = \\max(0, 10) = 10$\n  - $\\Delta e_2^* = \\max(0, -30) = 0$\n  - $\\Delta e_3^* = \\max(0, 20) = 20$\n- Minimum total bailout: $10 + 0 + 20 = 30$.\n\n**Case D**\n- Liabilities $L = \\begin{bmatrix} 0 & 50 \\\\ 50 & 0 \\end{bmatrix}$, External assets $e = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n- Obligations (row sums of $L$): $\\bar{p} = \\begin{bmatrix} 50 \\\\ 50 \\end{bmatrix}$.\n- Interbank assets (column sums of $L$): $\\sum_j L_{j,:} = \\begin{bmatrix} 50 \\\\ 50 \\end{bmatrix}$.\n- Shortfalls $s_i = \\bar{p}_i - (\\sum_j L_{ji}) - e_i$:\n  - $s_1 = 50 - 50 - 0 = 0$\n  - $s_2 = 50 - 50 - 0 = 0$\n- Bailouts $\\Delta e_i^* = \\max(0, s_i)$:\n  - $\\Delta e_1^* = \\max(0, 0) = 0$\n  - $\\Delta e_2^* = \\max(0, 0) = 0$\n- Minimum total bailout: $0 + 0 = 0$. The system's obligations are perfectly netted.\n\nFinal numerical results are: $10.0$ for Case A, $0.0$ for Case B, $30.0$ for Case C, and $0.0$ for Case D. The program will format these as required.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the minimum total bailout capital for a series of financial network test cases\n    based on the Eisenberg-Noe model.\n    \"\"\"\n\n    test_cases = [\n        # Case A\n        {\n            \"L\": np.array([[0, 50, 0], [0, 0, 40], [30, 0, 0]], dtype=float),\n            \"e\": np.array([10, 5, 5], dtype=float)\n        },\n        # Case B\n        {\n            \"L\": np.array([[0, 10], [0, 0]], dtype=float),\n            \"e\": np.array([10, 0], dtype=float)\n        },\n        # Case C\n        {\n            \"L\": np.array([[0, 10, 0], [0, 0, 0], [0, 20, 0]], dtype=float),\n            \"e\": np.array([0, 0, 0], dtype=float)\n        },\n        # Case D\n        {\n            \"L\": np.array([[0, 50], [50, 0]], dtype=float),\n            \"e\": np.array([0, 0], dtype=float)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        e = case[\"e\"]\n\n        # The condition for a \"saved\" system is that full nominal payments are a clearing vector.\n        # This requires that for each institution i, its total assets (assuming full payment from\n        # others) are greater than or equal to its total nominal obligations.\n        # Total Assets = Interbank Assets + External Assets\n        # Total Obligations = Interbank Liabilities\n        #\n        # Interbank assets for each institution are the column sums of L.\n        # Total nominal obligations for each institution are the row sums of L.\n        \n        # 1. Calculate total nominal obligations (p_bar), which are the row sums of L.\n        p_bar = np.sum(L, axis=1)\n\n        # 2. Calculate total interbank assets receivable, which are the column sums of L.\n        # This is equivalent to Pi^T * p_bar in the Eisenberg-Noe formulation.\n        interbank_assets = np.sum(L, axis=0)\n\n        # 3. Calculate the capital shortfall for each institution.\n        # Shortfall = Obligations - (Interbank Assets + External Assets)\n        shortfall = p_bar - interbank_assets - e\n\n        # 4. The minimum bailout for each institution is the positive part of its shortfall.\n        bailout_vector = np.maximum(0, shortfall)\n\n        # 5. The total minimum bailout is the sum of the individual required bailouts.\n        total_min_bailout = np.sum(bailout_vector)\n        \n        results.append(total_min_bailout)\n\n    # Print the final results in the specified format, rounded to four decimal places.\n    print(f\"[{','.join(f'{r:.4f}' for r in results)}]\")\n\nsolve()\n```"}, {"introduction": "In the real world, bailout funds are finite, forcing difficult choices. This practice [@problem_id:2392815] moves beyond the ideal of full solvency to explore the efficient allocation of limited capital. You will implement the iterative clearing algorithm to challenge the common 'too big to fail' narrative, computationally investigating whether rescuing a systemically important smaller bank can be more effective for overall stability than rescuing the largest one.", "id": "2392815", "problem": "You are given a financial system with $n$ banks represented in the Eisenberg–Noe (EN) framework. Each bank $i \\in \\{1,\\dots,n\\}$ has a total nominal liability $\\bar{p}_i \\ge 0$ toward all creditors (both interbank and external). Let $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ be the matrix of interbank nominal liabilities where $L_{ij}$ denotes the nominal amount owed by bank $i$ to bank $j$. Define the relative liabilities matrix $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ by\n$$\n\\pi_{ij} = \\begin{cases}\n\\dfrac{L_{ij}}{\\bar{p}_i}, & \\text{if } \\bar{p}_i > 0,\\\\\n0, & \\text{if } \\bar{p}_i = 0.\n\\end{cases}\n$$\nLet $x \\in \\mathbb{R}_{\\ge 0}^n$ denote the vector of external assets (endowments). The Eisenberg–Noe clearing payments vector $p \\in \\mathbb{R}_{\\ge 0}^n$ is defined as the greatest fixed point solving, componentwise,\n$$\np_i = \\min\\left\\{\\bar{p}_i,\\ x_i + \\sum_{j=1}^n \\pi_{ji} p_j\\right\\} \\quad \\text{for all } i \\in \\{1,\\dots,n\\},\n$$\nor in vector form,\n$$\np = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p\\right\\},\n$$\nwhere the minimum is taken componentwise. Consider a targeted bailout policy that injects a nonnegative budget $b$ into a single bank $k$, modeled as adding $b$ to $x_k$ while leaving all other $x_i$ unchanged.\n\nFor each test case below, you must compute the difference\n$$\n\\Delta = \\left(\\sum_{i=1}^n p_i^{(\\text{small})}\\right) - \\left(\\sum_{i=1}^n p_i^{(\\text{large})}\\right),\n$$\nwhere $p^{(\\text{small})}$ is the clearing payments vector when the entire budget $b$ is injected into the specified smaller, more connected bank, and $p^{(\\text{large})}$ is the clearing payments vector when the entire budget $b$ is injected into the largest bank by total nominal liabilities $\\bar{p}_i$. You are provided explicit indices for the largest bank and for the smaller, more connected bank in each test. Your program must produce the list of $\\Delta$ values for the test suite, rounded to six decimal places.\n\nAll inputs are dimensionless monetary quantities; no physical units are involved.\n\nTest suite:\n- Test case $1$:\n    - $n = 4$.\n    - $\\bar{p} = (\\,$$10$$,$$6$$,$$6$$,$$6$$\\,)$.\n    - $x = (\\,$$1$$,$$1$$,$$1$$,$$1$$\\,)$.\n    - $L = \\begin{pmatrix}\n    $$0$$ & $$0$$ & $$0$$ & $$0$$\\\\\n    $$0$$ & $$0$$ & $$3$$ & $$3$$\\\\\n    $$1$$ & $$0$$ & $$0$$ & $$0$$\\\\\n    $$1$$ & $$0$$ & $$0$$ & $$0$$\n    \\end{pmatrix}$.\n    - Budget $b = $$2$$.\n    - Index of largest bank $i_{\\text{large}} = $$0$$.\n    - Index of smaller, more connected bank $i_{\\text{small}} = $$1$$.\n- Test case $2$:\n    - $n = 3$.\n    - $\\bar{p} = (\\,$$5$$,$$4$$,$$4$$\\,)$.\n    - $x = (\\,$$0.5$$,$$0.5$$,$$0.5$$\\,)$.\n    - $L = \\begin{pmatrix}\n    $$0$$ & $$0$$ & $$0$$\\\\\n    $$0$$ & $$0$$ & $$2$$\\\\\n    $$0$$ & $$1$$ & $$0$$\n    \\end{pmatrix}$.\n    - Budget $b = $$0$$.\n    - Index of largest bank $i_{\\text{large}} = $$0$$.\n    - Index of smaller, more connected bank $i_{\\text{small}} = $$1$$.\n- Test case $3$:\n    - $n = 3$.\n    - $\\bar{p} = (\\,$$8$$,$$3$$,$$3$$\\,)$.\n    - $x = (\\,$$1$$,$$0.5$$,$$0.5$$\\,)$.\n    - $L = \\begin{pmatrix}\n    $$0$$ & $$3$$ & $$3$$\\\\\n    $$0$$ & $$0$$ & $$0$$\\\\\n    $$0$$ & $$0$$ & $$0$$\n    \\end{pmatrix}$.\n    - Budget $b = $$2$$.\n    - Index of largest bank $i_{\\text{large}} = $$0$$.\n    - Index of smaller, more connected bank $i_{\\text{small}} = $$1$$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each entry equal to $\\Delta$ for the corresponding test case, rounded to six decimal places (for example, $[\\,\\delta_1,\\delta_2,\\delta_3\\,]$).", "solution": "The problem statement has been evaluated and is deemed valid. It is self-contained, scientifically grounded in the established Eisenberg-Noe model of financial network clearing, and mathematically well-posed. All data required for a unique solution are provided, and there are no internal contradictions.\n\nThe central task is to compute the Eisenberg-Noe clearing payments vector $p$, which is defined as the greatest fixed point of the equation\n$$\np = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p\\right\\}\n$$\nwhere the minimum is taken componentwise. The vector $\\bar{p}$ represents the total nominal liabilities, $x$ is the vector of external assets, and $\\Pi$ is the relative interbank liabilities matrix.\n\nTo find the solution, we define an operator $F: \\mathbb{R}^n \\to \\mathbb{R}^n$ as\n$$\nF(p) = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p\\right\\}\n$$\nThe search for the clearing vector $p$ is restricted to the compact set $[0, \\bar{p}]$, which is the hyperrectangle $\\{p \\in \\mathbb{R}^n \\mid 0 \\le p_i \\le \\bar{p}_i \\text{ for all } i\\}$. This set, endowed with the componentwise partial order, forms a complete lattice.\n\nThe operator $F(p)$ is monotone on this lattice. That is, if $p^{(a)} \\le p^{(b)}$ componentwise, then $x + \\Pi^\\top p^{(a)} \\le x + \\Pi^\\top p^{(b)}$ because $\\Pi^\\top$ has non-negative entries. Consequently, $F(p^{(a)}) = \\min\\{\\bar{p}, x + \\Pi^\\top p^{(a)}\\} \\le \\min\\{\\bar{p}, x + \\Pi^\\top p^{(b)}\\} = F(p^{(b)})$.\n\nAccording to Tarski's fixed-point theorem, any monotone function on a complete lattice has a set of fixed points that is itself a non-empty complete lattice. This guarantees the existence of a greatest fixed point. This greatest fixed point can be found by a simple iterative algorithm. We initialize the iteration with the maximal element of the lattice, $p^{(0)} = \\bar{p}$. The sequence is then generated by\n$$\np^{(k+1)} = F(p^{(k)}) = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p^{(k)}\\right\\}\n$$\nSince $p^{(1)} = F(p^{(0)}) \\le p^{(0)}$ and $F$ is monotone, the sequence $\\{p^{(k)}\\}_{k \\ge 0}$ is non-increasing and bounded below by the zero vector. Therefore, it is guaranteed to converge to a fixed point, and because it starts from the top of the lattice, it converges to the greatest fixed point.\n\nThe overall procedure to solve the problem for each test case is as follows:\n\n1.  Given the parameters $n, \\bar{p}, x, L, b, i_{\\text{large}}, i_{\\text{small}}$, first compute the relative liabilities matrix $\\Pi$ according to its definition:\n    $$\n    \\pi_{ij} = \\begin{cases}\n    \\dfrac{L_{ij}}{\\bar{p}_i}, & \\text{if } \\bar{p}_i > 0,\\\\\n    0, & \\text{if } \\bar{p}_i = 0.\n    \\end{cases}\n    $$\n2.  Define two scenarios for the external assets vector based on the bailout target. Let $e_k$ be the standard basis vector with a $1$ at index $k$ and $0$ elsewhere.\n    - For the bailout of the smaller bank: $x^{(\\text{small})} = x + b \\cdot e_{i_{\\text{small}}}$.\n    - For the bailout of the largest bank: $x^{(\\text{large})} = x + b \\cdot e_{i_{\\text{large}}}$.\n3.  For each scenario, compute the corresponding clearing vector:\n    - Compute $p^{(\\text{small})}$ by iterating $p \\gets \\min\\{\\bar{p}, x^{(\\text{small})} + \\Pi^\\top p\\}$ starting with $p = \\bar{p}$ until the vector $p$ converges.\n    - Compute $p^{(\\text{large})}$ by iterating $p \\gets \\min\\{\\bar{p}, x^{(\\text{large})} + \\Pi^\\top p\\}$ starting with $p = \\bar{p}$ until the vector $p$ converges.\n4.  Calculate the sum of payments for each resulting clearing vector:\n    $$\n    S_{\\text{small}} = \\sum_{i=1}^n p_i^{(\\text{small})} \\quad \\text{and} \\quad S_{\\text{large}} = \\sum_{i=1}^n p_i^{(\\text{large})}\n    $$\n5.  Finally, compute the required difference $\\Delta = S_{\\text{small}} - S_{\\text{large}}$.\n\nThis structured, theoretically-grounded algorithm will be implemented to find the numerical solution for each specified test case. The convergence criterion for the iteration will be when the change between successive vectors is negligible, for instance, when the supremum norm of the difference, $\\|p^{(k+1)} - p^{(k)}\\|_\\infty$, falls below a small tolerance $\\epsilon > 0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_clearing_vector(p_bar: np.ndarray, x: np.ndarray, Pi: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the Eisenberg-Noe clearing payments vector.\n\n    This function finds the greatest fixed point of the equation:\n    p = min(p_bar, x + Pi.T @ p)\n    using a convergent iterative method starting from p = p_bar.\n\n    Args:\n        p_bar: Vector of total nominal liabilities.\n        x: Vector of external assets.\n        Pi: Relative liabilities matrix.\n\n    Returns:\n        The clearing payments vector p.\n    \"\"\"\n    n = len(p_bar)\n    # Initialize with the maximal element of the lattice [0, p_bar].\n    p = p_bar.copy()\n    \n    # Iterate until convergence.\n    # The sequence is non-increasing and bounded below, so it must converge.\n    for _ in range(1000):  # A sufficiently large number of iterations for convergence\n        p_prev = p.copy()\n        p = np.minimum(p_bar, x + Pi.T @ p_prev)\n        # Check for convergence using a small tolerance.\n        if np.allclose(p, p_prev, rtol=1e-12, atol=1e-12):\n            break\n            \n    return p\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"n\": 4,\n            \"p_bar\": np.array([10.0, 6.0, 6.0, 6.0]),\n            \"x\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"L\": np.array([\n                [0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 3.0, 3.0],\n                [1.0, 0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0, 0.0]\n            ]),\n            \"b\": 2.0,\n            \"i_large\": 0,\n            \"i_small\": 1,\n        },\n        # Test case 2\n        {\n            \"n\": 3,\n            \"p_bar\": np.array([5.0, 4.0, 4.0]),\n            \"x\": np.array([0.5, 0.5, 0.5]),\n            \"L\": np.array([\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 2.0],\n                [0.0, 1.0, 0.0]\n            ]),\n            \"b\": 0.0,\n            \"i_large\": 0,\n            \"i_small\": 1,\n        },\n        # Test case 3\n        {\n            \"n\": 3,\n            \"p_bar\": np.array([8.0, 3.0, 3.0]),\n            \"x\": np.array([1.0, 0.5, 0.5]),\n            \"L\": np.array([\n                [0.0, 3.0, 3.0],\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0]\n            ]),\n            \"b\": 2.0,\n            \"i_large\": 0,\n            \"i_small\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        p_bar = case[\"p_bar\"]\n        x = case[\"x\"]\n        L = case[\"L\"]\n        b = case[\"b\"]\n        i_large = case[\"i_large\"]\n        i_small = case[\"i_small\"]\n\n        # Calculate the relative liabilities matrix Pi\n        Pi = np.zeros((n, n))\n        for i in range(n):\n            if p_bar[i] > 0:\n                Pi[i, :] = L[i, :] / p_bar[i]\n\n        # Scenario 1: Bailout injected into the smaller bank\n        x_small = x.copy()\n        x_small[i_small] += b\n        p_small = compute_clearing_vector(p_bar, x_small, Pi)\n        total_payments_small = np.sum(p_small)\n\n        # Scenario 2: Bailout injected into the largest bank\n        x_large = x.copy()\n        x_large[i_large] += b\n        p_large = compute_clearing_vector(p_bar, x_large, Pi)\n        total_payments_large = np.sum(p_large)\n        \n        # Calculate the difference delta\n        delta = total_payments_small - total_payments_large\n        results.append(f\"{delta:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "Financial networks are rife with counter-intuitive behaviors that defy simple logic. This advanced practice [@problem_id:2392827] presents a fascinating paradox: can adding a new liability, which seemingly increases the system's burden, actually make it more stable? By modeling this scenario, you will see how interconnectedness can sometimes create stabilizing feedback loops, reinforcing the critical need for computational tools over gut-feeling in financial regulation.", "id": "2392827", "problem": "Consider the Eisenberg–Noe (EN) network clearing model for $n$ financial institutions, where the nominal liabilities matrix is $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ with entries $L_{ij}$ denoting the nominal liability of institution $i$ to institution $j$, and the external asset vector is $e \\in \\mathbb{R}_{\\ge 0}^{n}$. Define the total nominal liabilities of institution $i$ as $\\bar{p}_i = \\sum_{j=1}^n L_{ij}$ and the relative liabilities matrix $P \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ by\n$$\nP_{ij} = \\begin{cases}\n\\dfrac{L_{ij}}{\\bar{p}_i}, & \\text{if } \\bar{p}_i > 0,\\\n$$6pt]\n0, & \\text{if } \\bar{p}_i = 0.\n\\end{cases}\n$$\nA clearing payment vector $p \\in \\mathbb{R}_{\\ge 0}^{n}$ is a fixed point of the EN model defined componentwise by\n$$\np_i = \\min\\left\\{ \\bar{p}_i,\\; e_i + \\sum_{j=1}^n P_{ji} \\, p_j \\right\\} \\quad \\text{for all } i \\in \\{1,\\dots,n\\}.\n$$\nAn institution $i$ is in default if $p_i < \\bar{p}_i$. The system-wide default count is the number of indices $i$ such that $p_i < \\bar{p}_i$.\n\nYou are given a set of test cases. Each test case specifies a base network $(L^{\\mathrm{base}}, e)$ together with a single new liability link $(i^\\star, j^\\star, \\Delta)$ to be added to the base network, forming an augmented network $L^{\\mathrm{aug}}$ defined by $L^{\\mathrm{aug}}_{i^\\star j^\\star} = L^{\\mathrm{base}}_{i^\\star j^\\star} + \\Delta$ and $L^{\\mathrm{aug}}_{ij} = L^{\\mathrm{base}}_{ij}$ for all $(i,j) \\ne (i^\\star, j^\\star)$. For each test case, compute the EN clearing payment vectors for the base and augmented networks, determine the corresponding default counts, and report whether the augmented network has a strictly smaller default count than the base network.\n\nYour program must use the following test suite, listed as $(L^{\\mathrm{base}}, e, i^\\star, j^\\star, \\Delta)$ with all indices in $\\{1,\\dots,n\\}$ and all numbers in $\\mathbb{R}_{\\ge 0}$:\n\n- Test Case $1$ (happy path: adding a positive liability reduces defaults). Here $n = 3$,\n$$\nL^{\\mathrm{base}} = \\begin{bmatrix}\n0 & 0 & 0\\\\\n0 & 0 & 100\\\\\n60 & 0 & 0\n\\end{bmatrix}, \\quad\ne = \\begin{bmatrix} 50\\\\ 10\\\\ 0 \\end{bmatrix}, \\quad\n(i^\\star, j^\\star, \\Delta) = (1, 2, 60).\n$$\n\n- Test Case $2$ (boundary case: zero-sized new link changes nothing). Here $n = 3$,\n$$\nL^{\\mathrm{base}} = \\begin{bmatrix}\n0 & 0 & 0\\\\\n0 & 0 & 100\\\\\n60 & 0 & 0\n\\end{bmatrix}, \\quad\ne = \\begin{bmatrix} 50\\\\ 10\\\\ 0 \\end{bmatrix}, \\quad\n(i^\\star, j^\\star, \\Delta) = (1, 2, 0).\n$$\n\n- Test Case $3$ (edge case: adding a positive liability increases defaults). Here $n = 2$,\n$$\nL^{\\mathrm{base}} = \\begin{bmatrix}\n0 & 10\\\\\n0 & 0\n\\end{bmatrix}, \\quad\ne = \\begin{bmatrix} 15\\\\ 0 \\end{bmatrix}, \\quad\n(i^\\star, j^\\star, \\Delta) = (1, 2, 20).\n$$\n\nFor each test case, the required output is a boolean stating whether the augmented network has a strictly smaller default count than the base network, i.e., whether\n$$\n\\#\\{ i : p^{\\mathrm{aug}}_i < \\bar{p}^{\\mathrm{aug}}_i \\} < \\#\\{ i : p^{\\mathrm{base}}_i < \\bar{p}^{\\mathrm{base}}_i \\}.\n$$\n\nFinal Output Format: Your program should produce a single line of output containing the results for Test Cases $1$, $2$, and $3$ as a comma-separated list enclosed in square brackets, in the order given above, for example, $\\texttt{[true,false,true]}$ is not acceptable because booleans must follow the language’s capitalization; instead, produce the language’s native boolean literals in a list, e.g., $\\texttt{[True,False,True]}$.", "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n\nThe provided information is as follows:\n- A financial network of $n$ institutions.\n- Nominal liabilities matrix: $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$, where $L_{ij}$ is the liability of institution $i$ to $j$.\n- External asset vector: $e \\in \\mathbb{R}_{\\ge 0}^{n}$.\n- Total nominal liabilities of institution $i$: $\\bar{p}_i = \\sum_{j=1}^n L_{ij}$.\n- Relative liabilities matrix $P \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$:\n$$\nP_{ij} = \\begin{cases}\n\\dfrac{L_{ij}}{\\bar{p}_i}, & \\text{if } \\bar{p}_i > 0, \\\\\n0, & \\text{if } \\bar{p}_i = 0.\n\\end{cases}\n$$\n- Clearing payment vector $p \\in \\mathbb{R}_{\\ge 0}^{n}$, which is a fixed point of the Eisenberg-Noe (EN) model:\n$$\np_i = \\min\\left\\{ \\bar{p}_i,\\; e_i + \\sum_{j=1}^n P_{ji} \\, p_j \\right\\} \\quad \\text{for all } i \\in \\{1,\\dots,n\\}.\n$$\n- An institution $i$ is in default if $p_i < \\bar{p}_i$.\n- The system-wide default count is $\\#\\{ i : p_i < \\bar{p}_i \\}$.\n- An augmented network $L^{\\mathrm{aug}}$ is formed from a base network $L^{\\mathrm{base}}$ by adding a new liability link $(i^\\star, j^\\star, \\Delta)$: $L^{\\mathrm{aug}}_{i^\\star j^\\star} = L^{\\mathrm{base}}_{i^\\star j^\\star} + \\Delta$, with all other entries unchanged.\n- The task is to determine for each test case if $\\#\\{ i : p^{\\mathrm{aug}}_i < \\bar{p}^{\\mathrm{aug}}_i \\} < \\#\\{ i : p^{\\mathrm{base}}_i < \\bar{p}^{\\mathrm{base}}_i \\}$.\n- Test Case $1$: $n = 3$, $L^{\\mathrm{base}} = \\begin{bmatrix} 0 & 0 & 0\\\\ 0 & 0 & 100\\\\ 60 & 0 & 0 \\end{bmatrix}$, $e = \\begin{bmatrix} 50\\\\ 10\\\\ 0 \\end{bmatrix}$, $(i^\\star, j^\\star, \\Delta) = (1, 2, 60)$.\n- Test Case $2$: $n = 3$, $L^{\\mathrm{base}} = \\begin{bmatrix} 0 & 0 & 0\\\\ 0 & 0 & 100\\\\ 60 & 0 & 0 \\end{bmatrix}$, $e = \\begin{bmatrix} 50\\\\ 10\\\\ 0 \\end{bmatrix}$, $(i^\\star, j^\\star, \\Delta) = (1, 2, 0)$.\n- Test Case $3$: $n = 2$, $L^{\\mathrm{base}} = \\begin{bmatrix} 0 & 10\\\\ 0 & 0 \\end{bmatrix}$, $e = \\begin{bmatrix} 15\\\\ 0 \\end{bmatrix}$, $(i^\\star, j^\\star, \\Delta) = (1, 2, 20)$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is analyzed against the validation criteria.\n- **Scientifically Grounded:** The problem is based on the Eisenberg-Noe model, a cornerstone of financial network clearing literature. This is a standard and respected model in computational economics. The premise is scientifically sound.\n- **Well-Posed:** The problem provides a complete set of definitions and data. The existence of a clearing vector is guaranteed by Tarski's fixed-point theorem, as the function defining the iteration is monotone on the complete lattice $[0, \\bar{p}]$. The problem is well-posed.\n- **Objective:** The problem is formulated using precise mathematical language, free of ambiguity or subjective claims.\n\nThe problem does not exhibit any of the flaws listed for invalidity. It is scientifically sound, formalizable, complete, and well-structured.\n\n### Step 3: Verdict and Action\n\nThe problem is valid. A solution will be constructed.\n\n### Solution\n\nThe core of the problem is to compute the clearing payment vector $p$ for a given financial network $(L, e)$. The clearing vector is the solution to a system of fixed-point equations. In vector notation, the system is $p = f(p)$, where the function $f: \\mathbb{R}^n \\to \\mathbb{R}^n$ is defined as:\n$$\nf(p) = \\min(\\bar{p}, e + P^T p)\n$$\nHere, $\\bar{p}$ is the vector of total nominal liabilities, $e$ is the external asset vector, $P^T$ is the transpose of the relative liabilities matrix, and the $\\min$ operation is performed element-wise.\n\nThe clearing vector is found using a fixed-point iteration method. The theory of the Eisenberg-Noe model establishes that this iteration converges to the largest clearing vector, which is the economically relevant solution. The iterative scheme is:\n$$\np^{(k+1)} = \\min\\left(\\bar{p}, e + P^T p^{(k)}\\right)\n$$\nA suitable initial vector for the iteration is $p^{(0)} = \\bar{p}$, as no institution can pay more than its total nominal liabilities. The iteration proceeds until the solution converges, which is determined by checking if the norm of the difference between successive iterates, $\\| p^{(k+1)} - p^{(k)} \\|$, falls below a small tolerance $\\epsilon$.\n\nThe algorithm for a single network $(L, e)$ is as follows:\n1.  Compute the vector of total nominal liabilities, $\\bar{p}$, where $\\bar{p}_i = \\sum_{j=1}^n L_{ij}$.\n2.  Construct the relative liabilities matrix $P$. For each row $i$, if $\\bar{p}_i > 0$, then $P_{ij} = L_{ij} / \\bar{p}_i$. If $\\bar{p}_i = 0$, then $P_{ij} = 0$.\n3.  Initialize the payment vector $p^{(0)} = \\bar{p}$.\n4.  Iterate for $k=0, 1, 2, \\dots$ using the formula $p^{(k+1)} = \\min(\\bar{p}, e + P^T p^{(k)})$.\n5.  Terminate when $\\|p^{(k+1)} - p^{(k)}\\|_\\infty < \\epsilon$ for a predefined tolerance $\\epsilon > 0$. The resulting vector is the clearing vector $p$.\n6.  Once the clearing vector $p$ is found, the number of defaulting institutions is calculated as the count of indices $i$ for which $p_i < \\bar{p}_i$. A small numerical tolerance should be considered in practice, but given the integer data, a direct comparison is sufficient if calculations are precise.\n\nThis procedure is applied to each test case. For each case, we are given $(L^{\\mathrm{base}}, e, i^\\star, j^\\star, \\Delta)$.\n- First, the procedure is run on the base network $(L^{\\mathrm{base}}, e)$ to find the clearing vector $p^{\\mathrm{base}}$ and the corresponding default count $D^{\\mathrm{base}}$.\n- Second, the augmented liabilities matrix $L^{\\mathrm{aug}}$ is constructed by setting $L^{\\mathrm{aug}}_{i^\\star j^\\star} = L^{\\mathrm{base}}_{i^\\star j^\\star} + \\Delta$ (adjusting for zero-based indexing used in programming environments).\n- Third, the procedure is run on the augmented network $(L^{\\mathrm{aug}}, e)$ to find $p^{\\mathrm{aug}}$ and its default count $D^{\\mathrm{aug}}$.\n- Finally, the boolean condition $D^{\\mathrm{aug}} < D^{\\mathrm{base}}$ is evaluated.\n\nThis process is repeated for all three test cases provided, and the resulting boolean values are collected into a list.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _calculate_clearing_vector_and_defaults(L, e, tol=1e-12, max_iter=1000):\n    \"\"\"\n    Calculates the Eisenberg-Noe clearing vector and default count.\n    \n    Args:\n        L (np.array): The n x n nominal liabilities matrix.\n        e (np.array): The n-dimensional external asset vector.\n        tol (float): Tolerance for convergence of the fixed-point iteration.\n        max_iter (int): Maximum number of iterations.\n        \n    Returns:\n        A tuple (p, default_count) where:\n        - p is the clearing payment vector.\n        - default_count is the number of defaulting institutions.\n    \"\"\"\n    n = L.shape[0]\n    p_bar = np.sum(L, axis=1)\n\n    # If an institution has no liabilities, it cannot default.\n    # Its clearing payment is 0.\n    if np.all(p_bar == 0):\n        return np.zeros(n), 0\n\n    # Calculate the relative liabilities matrix P.\n    # P_ij = L_ij / p_bar_i if p_bar_i > 0, else 0.\n    P = np.zeros_like(L, dtype=float)\n    non_zero_liab_rows = p_bar > 0\n    # Use np.newaxis to ensure correct broadcasting for element-wise division.\n    P[non_zero_liab_rows, :] = L[non_zero_liab_rows, :] / p_bar[non_zero_liab_rows, np.newaxis]\n\n    # The iteration uses the transpose of P.\n    PT = P.T\n\n    # Fixed-point iteration to find the clearing vector p.\n    # Start with the maximal possible payments, p_bar.\n    p = p_bar.copy()\n    for _ in range(max_iter):\n        p_next = np.minimum(p_bar, e + PT @ p)\n        # Check for convergence using the infinity norm.\n        if np.linalg.norm(p_next - p, ord=np.inf) < tol:\n            p = p_next\n            break\n        p = p_next\n    # The else block for a for-loop executes if the loop completes without a 'break'.\n    # This indicates failure to converge, which should not happen for this model.\n    else: \n         # In a real-world application one might raise an exception.\n         # For this problem, convergence is guaranteed and rapid.\n         pass\n\n    # An institution i defaults if its actual payment p_i is strictly less\n    # than its total nominal liability p_bar_i.\n    # With floating point arithmetic, it's safer to check if (p_bar_i - p_i > tol).\n    # However, the problem formulation implies exact arithmetic is sufficient.\n    default_count = np.sum(p_bar - p > tol)\n\n    return p, default_count\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    # Note: problem uses 1-based indexing for i*, j*, so we subtract 1 for 0-based Python.\n    test_cases = [\n        {\n            \"L_base\": np.array([[0, 0, 0], [0, 0, 100], [60, 0, 0]], dtype=float),\n            \"e\": np.array([50, 10, 0], dtype=float),\n            \"link\": (1 - 1, 2 - 1, 60.0)  # (i*, j*, Delta)\n        },\n        {\n            \"L_base\": np.array([[0, 0, 0], [0, 0, 100], [60, 0, 0]], dtype=float),\n            \"e\": np.array([50, 10, 0], dtype=float),\n            \"link\": (1 - 1, 2 - 1, 0.0)\n        },\n        {\n            \"L_base\": np.array([[0, 10], [0, 0]], dtype=float),\n            \"e\": np.array([15, 0], dtype=float),\n            \"link\": (1 - 1, 2 - 1, 20.0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L_base = case[\"L_base\"]\n        e = case[\"e\"]\n        i_star, j_star, delta = case[\"link\"]\n\n        # Calculate defaults for the base network\n        _, defaults_base = _calculate_clearing_vector_and_defaults(L_base, e)\n\n        # Construct the augmented network by adding the new liability link\n        L_aug = L_base.copy()\n        L_aug[i_star, j_star] += delta\n        \n        # Calculate defaults for the augmented network\n        _, defaults_aug = _calculate_clearing_vector_and_defaults(L_aug, e)\n\n        # The result is True if the default count strictly decreases\n        results.append(defaults_aug < defaults_base)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) converts Python booleans (True, False) to strings (\"True\", \"False\").\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}