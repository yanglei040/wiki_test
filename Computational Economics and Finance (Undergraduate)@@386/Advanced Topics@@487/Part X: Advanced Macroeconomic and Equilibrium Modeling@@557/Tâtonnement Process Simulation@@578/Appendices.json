{"hands_on_practices": [{"introduction": "This first practice serves as a foundational exercise, guiding you through the implementation of a classic Walrasian tâtonnement process. You will model a pure exchange economy and derive the demand functions for agents with Constant Elasticity of Substitution (CES) preferences. By simulating the price adjustment mechanism for different values of the elasticity of substitution, $\\sigma$, you will gain hands-on insight into how the willingness of consumers to substitute between goods affects the market's speed of convergence to equilibrium [@problem_id:2436189].", "id": "2436189", "problem": "Implement and analyze a discrete-time tâtonnement process in a pure exchange economy with two goods and two consumers whose preferences follow Constant Elasticity of Substitution (CES) utility. Your goal is to compare convergence speeds when the elasticity of substitution parameter is low versus high. Work in purely mathematical terms, with all quantities dimensionless. The program you produce must be a fully runnable script that uses only the Python standard library together with NumPy and SciPy as permitted by the execution environment.\n\nConsider two consumers indexed by $i \\in \\{1,2\\}$ and two goods indexed by $j \\in \\{1,2\\}$. Each consumer $i$ has a CES utility function with elasticity of substitution $\\sigma > 0$, $\\sigma \\neq 1$, given by\n$$\nU_i(x_{i1},x_{i2};\\sigma) \\;=\\; \\left(\\alpha_i \\, x_{i1}^{\\rho} \\;+\\; (1-\\alpha_i)\\, x_{i2}^{\\rho}\\right)^{\\frac{1}{\\rho}},\n\\quad \\text{where} \\quad \\rho \\;=\\; \\frac{\\sigma - 1}{\\sigma},\n$$\nwith weight $\\alpha_i \\in (0,1)$. If $\\sigma = 1$, interpret $U_i$ as the Cobb–Douglas limit.\n\nEach consumer $i$ possesses an endowment vector $e_i \\in \\mathbb{R}^2_{+}$ and faces prices $p \\in \\mathbb{R}^2_{++}$. The budget set is defined by $p \\cdot x_i \\leq p \\cdot e_i$, where $m_i = p \\cdot e_i$ is the income. Let the aggregate excess demand be\n$$\nz(p;\\sigma) \\;=\\; \\sum_{i=1}^{2} x_i(p;\\sigma, m_i) \\;-\\; \\sum_{i=1}^{2} e_i,\n\\quad \\text{with} \\quad m_i \\;=\\; p \\cdot e_i.\n$$\nYou must compute the Marshallian (uncompensated) demands $x_i(p;\\sigma,m_i)$ from the utility maximization problem\n$$\n\\max_{x_i \\ge 0}\\; U_i(x_{i1},x_{i2};\\sigma) \\quad \\text{subject to} \\quad p \\cdot x_i \\le m_i,\n$$\nusing first principles in your solution derivation.\n\nSimulate a discrete-time tâtonnement process that adjusts prices in the direction of excess demand while ensuring positivity and scale invariance. Use the exponentiated update with simplex normalization:\n$$\n\\tilde{p}_{t+1} \\;=\\; p_t \\odot \\exp\\!\\left(\\eta \\, z(p_t;\\sigma)\\right),\n\\qquad\np_{t+1} \\;=\\; \\frac{\\tilde{p}_{t+1}}{\\mathbf{1}^\\top \\tilde{p}_{t+1}},\n$$\nwhere $\\odot$ denotes componentwise multiplication, $\\exp(\\cdot)$ is applied componentwise, $\\eta > 0$ is a step size, and $\\mathbf{1}$ is the all-ones vector. Initialize at a strictly positive price vector $p_0$ and renormalize to satisfy $\\mathbf{1}^\\top p_0 = 1$. At each iteration $t$, compute $z(p_t;\\sigma)$. Stop at the smallest $t$ such that\n$$\n\\max_{j \\in \\{1,2\\}} \\left| z_j(p_t;\\sigma) \\right| \\;\\le\\; \\varepsilon,\n$$\nor when a maximum number of iterations is reached. Return the number of iterations used until convergence or the maximum if not converged.\n\nUse the following fixed economy:\n- Consumer weights: $\\alpha_1 = 0.7$, $\\alpha_2 = 0.3$.\n- Endowments: $e_1 = (1.2,\\, 0.3)$, $e_2 = (0.2,\\, 1.1)$.\n- Convergence tolerance: $\\varepsilon = 10^{-8}$.\n- Maximum iterations: $100000$.\n- Price normalization at every step: $\\mathbf{1}^\\top p_t = 1$.\n\nTest suite:\nImplement and run the simulation for the following parameter sets $(\\sigma,\\eta,p_0)$:\n- Case $1$: $(\\sigma,\\eta,p_0) = (0.5,\\, 0.10,\\, (0.5,\\, 0.5))$.\n- Case $2$: $(\\sigma,\\eta,p_0) = (5.0,\\, 0.10,\\, (0.5,\\, 0.5))$.\n- Case $3$: $(\\sigma,\\eta,p_0) = (0.5,\\, 0.05,\\, (0.9,\\, 0.1))$.\n- Case $4$: $(\\sigma,\\eta,p_0) = (5.0,\\, 0.05,\\, (0.9,\\, 0.1))$.\n\nFor each case, compute the integer number of iterations required to meet the stopping criterion. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\"[123,456,789,1011]\"$) in the order of Cases $1$ through $4$.\n\nYour code must be a complete, runnable program that performs all computations internally and prints only the specified final output line.", "solution": "The problem requires the implementation and analysis of a Walrasian tâtonnement process for a two-consumer, two-good pure exchange economy. The consumers' preferences are described by Constant Elasticity of Substitution (CES) utility functions. Our primary task is to derive the necessary economic functions from first principles and then construct a discrete-time simulation to find the number of iterations required for the price vector to converge to an equilibrium, under different parameterizations.\n\nFirst, we must derive the Marshallian demand functions for a consumer $i$ with a CES utility function. The utility maximization problem (UMP) is stated as:\n$$\n\\max_{x_{i1}, x_{i2} \\ge 0} \\; U_i(x_{i1}, x_{i2};\\sigma) = \\left(\\alpha_i x_{i1}^{\\rho} + (1-\\alpha_i) x_{i2}^{\\rho}\\right)^{1/\\rho}\n$$\nsubject to the budget constraint:\n$$\np_1 x_{i1} + p_2 x_{i2} \\le m_i\n$$\nwhere $p = (p_1, p_2)$ is the strictly positive price vector, $m_i$ is the consumer's income, and $\\rho = (\\sigma - 1)/\\sigma$. Since the specified utility function is strictly increasing in its arguments, the budget constraint will hold with equality at the optimum: $p_1 x_{i1} + p_2 x_{i2} = m_i$.\n\nTo solve the UMP, it is computationally convenient to maximize the monotonic transformation $U_i^\\rho$, as this simplifies the derivatives. The corresponding Lagrangian for this modified problem is:\n$$\n\\mathcal{L}(x_{i1}, x_{i2}, \\lambda) = \\alpha_i x_{i1}^{\\rho} + (1-\\alpha_i) x_{i2}^{\\rho} - \\lambda (p_1 x_{i1} + p_2 x_{i2} - m_i)\n$$\nThe first-order conditions with respect to $x_{i1}$ and $x_{i2}$, assuming an interior solution ($x_{i1}>0, x_{i2}>0$), are:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial x_{i1}} = \\rho \\alpha_i x_{i1}^{\\rho - 1} - \\lambda p_1 = 0\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial x_{i2}} = \\rho (1-\\alpha_i) x_{i2}^{\\rho - 1} - \\lambda p_2 = 0\n$$\nWe can eliminate the Lagrange multiplier $\\lambda$ by dividing the first equation by the second:\n$$\n\\frac{\\alpha_i}{(1-\\alpha_i)} \\left(\\frac{x_{i1}}{x_{i2}}\\right)^{\\rho-1} = \\frac{p_1}{p_2}\n$$\nSolving for the ratio of goods consumed:\n$$\n\\frac{x_{i1}}{x_{i2}} = \\left( \\frac{p_1}{p_2} \\frac{1-\\alpha_i}{\\alpha_i} \\right)^{\\frac{1}{\\rho-1}}\n$$\nUsing the definition $\\rho = (\\sigma - 1)/\\sigma$, we have $\\rho - 1 = -1/\\sigma$. The exponent in the expression above becomes $1/(\\rho-1) = -\\sigma$. Thus, the relationship is:\n$$\nx_{i1} = x_{i2} \\left( \\frac{p_1}{p_2} \\right)^{-\\sigma} \\left( \\frac{\\alpha_i}{1-\\alpha_i} \\right)^{\\sigma}\n$$\nSubstituting this expression for $x_{i1}$ into the budget constraint $p_1 x_{i1} + p_2 x_{i2} = m_i$ allows us to solve for $x_{i2}$ and subsequently for $x_{i1}$. This procedure yields the standard Marshallian demand functions for the CES utility specification. For goods $j \\in \\{1,2\\}$, the demand of consumer $i$ is:\n$$\nx_{i1}(p, m_i; \\sigma) = m_i \\frac{\\alpha_i^{\\sigma} p_1^{-\\sigma}}{\\alpha_i^{\\sigma} p_1^{1-\\sigma} + (1-\\alpha_i)^{\\sigma} p_2^{1-\\sigma}}\n$$\n$$\nx_{i2}(p, m_i; \\sigma) = m_i \\frac{(1-\\alpha_i)^{\\sigma} p_2^{-\\sigma}}{\\alpha_i^{\\sigma} p_1^{1-\\sigma} + (1-\\alpha_i)^{\\sigma} p_2^{1-\\sigma}}\n$$\nThese expressions are well-defined for all $p \\in \\mathbb{R}_{++}^2$ and $\\sigma > 0$.\n\nThe simulation of the tâtonnement process is an iterative algorithm. We are given the aggregate endowments $E = \\sum_{i=1}^2 e_i$. The process proceeds for iterations $t=0, 1, 2, \\dots$ as follows:\n1.  Initialize with a strictly positive price vector $p_0$ and normalize it such that its components sum to $1$.\n2.  At each iteration $t$, given the current price vector $p_t=(p_{t,1}, p_{t,2})$:\n    a. Calculate the income $m_{i,t}$ for each consumer $i$: $m_{i,t} = p_t \\cdot e_i = p_{t,1} e_{i1} + p_{t,2} e_{i2}$.\n    b. Calculate the demand vector $x_{i}(p_t, m_{i,t}; \\sigma)$ for each consumer using the derived formulas.\n    c. Compute the aggregate demand vector $X_t = \\sum_{i=1}^2 x_{i}(p_t, m_{i,t}; \\sigma)$.\n    d. Compute the aggregate excess demand vector $z(p_t; \\sigma) = X_t - E$. By Walras's law, it must be that $p_t \\cdot z(p_t; \\sigma) = 0$.\n3.  Check for convergence. The process terminates if the infinity norm of the excess demand vector is below a tolerance $\\varepsilon$: $\\max_j |z_j(p_t; \\sigma)| \\le \\varepsilon$. If this condition is met, the number of iterations required for convergence is recorded as $t$.\n4.  If the system has not converged, update the price vector. An intermediate, unnormalized price vector $\\tilde{p}_{t+1}$ is computed component-wise using the exponential update rule:\n    $$\n    \\tilde{p}_{t+1, j} = p_{t,j} \\exp(\\eta \\, z_j(p_t; \\sigma)) \\quad \\text{for } j \\in \\{1,2\\}\n    $$\n    where $\\eta > 0$ is a fixed step-size parameter. This update rule ensures the new price vector remains strictly positive.\n5.  The new price vector for the next iteration, $p_{t+1}$, is obtained by normalizing $\\tilde{p}_{t+1}$ onto the standard simplex:\n    $$\n    p_{t+1} = \\frac{\\tilde{p}_{t+1}}{\\mathbf{1}^\\top \\tilde{p}_{t+1}} = \\frac{\\tilde{p}_{t+1}}{\\tilde{p}_{t+1,1} + \\tilde{p}_{t+1,2}}\n    $$\n6.  The process then repeats from step 2 with the index $t$ incremented. If the number of iterations reaches the specified maximum, $100000$, the simulation stops and reports this maximum value, indicating that convergence was not achieved within the allotted steps.\n\nThe provided numerical implementation will precisely encode this algorithm. Vector and matrix operations from the NumPy library are utilized for efficient computation of incomes, demands, and excess demands. The fixed parameters of the economy ($\\alpha_i, e_i$) and the simulation parameters $(\\sigma, \\eta, p_0, \\varepsilon, \\text{max\\_iter})$ are defined as specified in the problem statement. The simulation is executed for each of the four test cases, and the number of iterations to convergence is collected for the final output.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the simulation for all test cases.\n    \"\"\"\n\n    # --- Fixed Economy and Simulation Parameters ---\n    # Consumer preference weights (alpha_1, alpha_2)\n    ALPHA = np.array([0.7, 0.3])\n    # Consumer endowments e_i = (e_i1, e_i2)\n    ENDOWMENTS = np.array([[1.2, 0.3], [0.2, 1.1]])\n    # Convergence tolerance\n    EPSILON = 1e-8\n    # Maximum number of iterations\n    MAX_ITER = 100000\n    # Aggregate endowments E = (E_1, E_2)\n    E_AGG = np.sum(ENDOWMENTS, axis=0)\n\n    # --- Test Cases ---\n    # Each case is a tuple: (sigma, eta, p0)\n    test_cases = [\n        (0.5, 0.10, (0.5, 0.5)),\n        (5.0, 0.10, (0.5, 0.5)),\n        (0.5, 0.05, (0.9, 0.1)),\n        (5.0, 0.05, (0.9, 0.1)),\n    ]\n\n    def calculate_excess_demand(p, sigma):\n        \"\"\"\n        Calculates the aggregate excess demand vector for a given price vector and elasticity.\n\n        Args:\n            p (np.ndarray): Price vector of shape (2,).\n            sigma (float): Elasticity of substitution.\n\n        Returns:\n            np.ndarray: Aggregate excess demand vector of shape (2,).\n        \"\"\"\n        # Calculate incomes for each consumer: m_i = p . e_i\n        # ENDOWMENTS is (2, 2), p is (2,). Result is a (2,) vector of incomes.\n        incomes = ENDOWMENTS @ p\n\n        # Prepare matrices for vectorized demand calculation.\n        # alpha_matrix[i, j] is the weight consumer i gives to good j.\n        alpha_matrix = np.array([ALPHA, 1 - ALPHA]).T\n\n        # Numerator term: alpha_ij^sigma * p_j^(-sigma)\n        p_pow_neg_sigma = p**(-sigma)       # element-wise power\n        alpha_pow_sigma = alpha_matrix**sigma # element-wise power\n        numerators = alpha_pow_sigma * p_pow_neg_sigma # broadcasting (2,2) * (2,)\n\n        # Denominator term: D_i = sum_j alpha_ij^sigma * p_j^(1-sigma)\n        p_pow_1_minus_sigma = p**(1 - sigma)\n        # Using dot product with ones vector for summation over j\n        denominators = (alpha_pow_sigma * p_pow_1_minus_sigma) @ np.ones(2)\n\n        # Calculate Marshallian demands: x_ij = m_i * Numerator_ij / Denominator_i\n        # Use np.newaxis to align dimensions for broadcasting correctly.\n        demands = (incomes[:, np.newaxis] * numerators) / denominators[:, np.newaxis]\n\n        # Aggregate demand and excess demand\n        X_agg = np.sum(demands, axis=0)\n        z = X_agg - E_AGG\n        \n        return z\n\n    def run_simulation(sigma, eta, p0):\n        \"\"\"\n        Runs the tâtonnement process simulation for a given parameter set.\n\n        Args:\n            sigma (float): Elasticity of substitution.\n            eta (float): Step size for price updates.\n            p0 (tuple): Initial price vector.\n\n        Returns:\n            int: Number of iterations to converge, or MAX_ITER if not converged.\n        \"\"\"\n        # Initialize and normalize the price vector.\n        p = np.array(p0, dtype=np.float64)\n        p /= np.sum(p)\n\n        for t in range(MAX_ITER):\n            # Calculate excess demand at current price p_t\n            z = calculate_excess_demand(p, sigma)\n\n            # Check for convergence\n            if np.max(np.abs(z)) <= EPSILON:\n                return t\n\n            # Update prices using the exponential rule\n            p_tilde = p * np.exp(eta * z)\n            \n            # Normalize to get the price vector for the next iteration\n            p = p_tilde / np.sum(p_tilde)\n        \n        # After MAX_ITER iterations, check for convergence one last time.\n        z = calculate_excess_demand(p, sigma)\n        if np.max(np.abs(z)) <= EPSILON:\n            return MAX_ITER\n\n        # If the loop finishes without converging, return MAX_ITER.\n        return MAX_ITER\n\n    # Execute simulation for all test cases and collect results.\n    results = []\n    for sigma_val, eta_val, p0_val in test_cases:\n        iterations = run_simulation(sigma_val, eta_val, p0_val)\n        results.append(iterations)\n\n    # Print results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "Building upon the standard model, this exercise introduces a common real-world market friction: 'sticky prices'. You will modify the price adjustment rule so that prices only respond to excess demand when it exceeds a certain threshold, $\\delta$. This practice provides a micro-level simulation of a concept crucial to modern macroeconomics, demonstrating how price rigidities can slow down market clearing and affect the stability of the equilibrium-finding process [@problem_id:2436152].", "id": "2436152", "problem": "Consider a pure exchange economy with $I = 2$ agents and $G = 3$ goods. Each agent $i \\in \\{1,2\\}$ has a Cobb–Douglas utility function over the goods with exponents $\\alpha_{ig}$ that satisfy $\\sum_{g=1}^{3} \\alpha_{ig} = 1$ and $\\alpha_{ig} \\in (0,1)$ for all $g$. Agent $i$ is endowed with a vector of strictly positive goods $\\mathbf{e}_i \\in \\mathbb{R}_{++}^{3}$. Let the aggregate endowment be $\\mathbf{E} = \\sum_{i=1}^{2} \\mathbf{e}_i$. Prices are represented by a strictly positive vector $\\mathbf{p} \\in \\mathbb{R}_{++}^{3}$, with the first good used as numeraire so that $p_1 \\equiv 1$ at all times. \n\nGiven a price vector $\\mathbf{p}$, agent $i$ has income $m_i(\\mathbf{p}) = \\mathbf{p} \\cdot \\mathbf{e}_i$. For Cobb–Douglas preferences, the individual demand of agent $i$ for good $g$ is $x_{ig}(\\mathbf{p}) = \\alpha_{ig} \\, m_i(\\mathbf{p}) / p_g$. The aggregate demand for good $g$ is $X_g(\\mathbf{p}) = \\sum_{i=1}^{2} x_{ig}(\\mathbf{p})$, and the excess demand is $Z_g(\\mathbf{p}) = X_g(\\mathbf{p}) - E_g$. Market clearing requires $Z_g(\\mathbf{p}^*) = 0$ for all $g$ at equilibrium prices $\\mathbf{p}^*$, with $p_1^* = 1$ as the normalization.\n\nYou will simulate a discrete-time tâtonnement (price adjustment) process with sticky prices. Let $t \\in \\{0,1,2,\\dots\\}$ index iterations. For a given step size $\\gamma > 0$ and a stickiness threshold $\\delta \\ge 0$, the prices update as follows:\n- The numeraire price is fixed: $p_1^{t+1} = 1$ for all $t$.\n- For each non-numeraire good $g \\in \\{2,3\\}$,\n  - If $\\lvert Z_g(\\mathbf{p}^t) \\rvert > \\delta$, then \n    $$\n    p_g^{t+1} = \\max\\{\\varepsilon, \\, p_g^t \\, (1 + \\gamma \\, Z_g(\\mathbf{p}^t))\\},\n    $$\n    where $\\varepsilon > 0$ is a small constant to enforce positivity.\n  - Otherwise, $p_g^{t+1} = p_g^t$ (no change due to stickiness).\nConvergence is declared when $\\max_{g \\in \\{1,2,3\\}} \\lvert Z_g(\\mathbf{p}^t) \\rvert \\le \\tau$, where $\\tau > 0$ is a tolerance. If convergence is not achieved within $T_{\\max}$ iterations, the process stops and is declared not converged.\n\nUse the following calibrated economy:\n- Cobb–Douglas exponents:\n  - Agent $1$: $(\\alpha_{11}, \\alpha_{12}, \\alpha_{13}) = (0.5, 0.3, 0.2)$.\n  - Agent $2$: $(\\alpha_{21}, \\alpha_{22}, \\alpha_{23}) = (0.2, 0.4, 0.4)$.\n- Endowments:\n  - Agent $1$: $\\mathbf{e}_1 = (1.0, 0.5, 0.5)$.\n  - Agent $2$: $\\mathbf{e}_2 = (0.5, 1.0, 0.5)$.\n- Aggregate endowment: $\\mathbf{E} = (1.5, 1.5, 1.0)$.\n- Fixed parameters for all simulations: positivity floor $\\varepsilon = 10^{-8}$, convergence tolerance $\\tau = 10^{-6}$.\n- The initial price vector $\\mathbf{p}^0$ is always specified with $p_1^0 = 1$.\n\nImplement the simulation for the following test suite of cases. Each test case is a tuple $(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0)$ with explicit values:\n- Case $\\mathrm{A}$ (baseline, no stickiness): $(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.2, 0.0, 5000, [1.0, 1.0, 1.0])$.\n- Case $\\mathrm{B}$ (moderate stickiness, off-equilibrium start): $(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.15, 0.1, 5000, [1.0, 0.7, 1.3])$.\n- Case $\\mathrm{C}$ (high stickiness, effectively frozen): $(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.2, 1.0, 10, [1.0, 1.0, 1.0])$.\n- Case $\\mathrm{D}$ (boundary stickiness at equality): $(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.2, 0.2, 10, [1.0, 1.0, 1.0])$.\n\nRequirements for your program:\n- Compute $Z_g(\\mathbf{p})$ exactly as defined above from the fundamentals for each iteration.\n- Apply the sticky tâtonnement rule exactly as specified with strict inequality $\\lvert Z_g \\rvert > \\delta$ triggering an update.\n- Keep $p_1 \\equiv 1$ at all times.\n- Stop early if the convergence condition $\\max_g \\lvert Z_g(\\mathbf{p}^t) \\rvert \\le \\tau$ is satisfied.\n- For each test case, produce a result of the form $[N, B, [p_1, p_2, p_3]]$, where:\n  - $N$ is the integer number of iterations actually performed (between $0$ and $T_{\\max}$).\n  - $B$ is a boolean equal to $\\mathrm{True}$ if convergence was declared and $\\mathrm{False}$ otherwise.\n  - $[p_1, p_2, p_3]$ is the final price vector rounded to six decimal places.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases $\\mathrm{A}$, $\\mathrm{B}$, $\\mathrm{C}$, $\\mathrm{D}$. For example, it should look like $[[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]],[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]],[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]],[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]]]$ with the actual numeric and boolean results substituted.", "solution": "The problem is valid. It is a well-defined exercise in computational economics, grounded in the established principles of general equilibrium theory and numerical simulation of dynamic systems. All parameters, equations, and conditions are specified with sufficient precision to construct a unique, verifiable solution.\n\nThe problem requires the simulation of a discrete-time tâtonnement price adjustment process in a pure exchange economy. The economy consists of $I=2$ agents and $G=3$ goods. The core of the solution is to implement an iterative algorithm that updates prices based on excess market demand until an equilibrium is reached or a maximum number of iterations is exceeded.\n\nFirst, we establish the fundamental equations of the economic model. Each agent $i \\in \\{1, 2\\}$ has Cobb-Douglas preferences, described by the utility function $U_i(\\mathbf{x}_i) = \\prod_{g=1}^3 x_{ig}^{\\alpha_{ig}}$, where $\\mathbf{x}_i = (x_{i1}, x_{i2}, x_{i3})$ is the consumption bundle and $\\boldsymbol{\\alpha}_i = (\\alpha_{i1}, \\alpha_{i2}, \\alpha_{i3})$ are the utility-share parameters. Agents are endowed with a vector of goods $\\mathbf{e}_i = (e_{i1}, e_{i2}, e_{i3})$.\n\nGiven a price vector $\\mathbf{p} = (p_1, p_2, p_3)$, the income (or wealth) of agent $i$ is derived from their endowment:\n$$\nm_i(\\mathbf{p}) = \\mathbf{p} \\cdot \\mathbf{e}_i = \\sum_{g=1}^{3} p_g e_{ig}\n$$\nA key property of Cobb-Douglas utility is that an agent $i$ allocates a constant fraction $\\alpha_{ig}$ of their income to each good $g$. This yields the individual demand function:\n$$\nx_{ig}(\\mathbf{p}) = \\frac{\\alpha_{ig} m_i(\\mathbf{p})}{p_g}\n$$\nThe aggregate demand for each good $g$ is the sum of individual demands across all agents:\n$$\nX_g(\\mathbf{p}) = \\sum_{i=1}^{2} x_{ig}(\\mathbf{p})\n$$\nThe total amount of each good in the economy is fixed by the aggregate endowment, $\\mathbf{E} = \\mathbf{e}_1 + \\mathbf{e}_2$. The excess demand for good $g$, denoted $Z_g(\\mathbf{p})$, is the difference between what is demanded and what is available:\n$$\nZ_g(\\mathbf{p}) = X_g(\\mathbf{p}) - E_g\n$$\nThe problem specifies the following economic parameters:\n- Utility exponents: $\\boldsymbol{\\alpha}_1 = (0.5, 0.3, 0.2)$ for agent $1$, and $\\boldsymbol{\\alpha}_2 = (0.2, 0.4, 0.4)$ for agent $2$.\n- Endowments: $\\mathbf{e}_1 = (1.0, 0.5, 0.5)$ for agent $1$, and $\\mathbf{e}_2 = (0.5, 1.0, 0.5)$ for agent $2$.\n- Aggregate endowment: $\\mathbf{E} = \\mathbf{e}_1 + \\mathbf{e}_2 = (1.5, 1.5, 1.0)$.\n\nThe simulation follows a discrete-time tâtonnement process, indexed by $t \\in \\{0, 1, 2, \\dots\\}$. The price of good $1$ is normalized to serve as the numeraire, i.e., $p_1^t \\equiv 1$ for all $t$. The prices of the non-numeraire goods, $p_2$ and $p_3$, are adjusted based on their respective excess demands, but with a \"stickiness\" condition.\n\nThe algorithmic procedure is as follows:\n1.  **Initialization**: At iteration $t=0$, start with a given initial price vector $\\mathbf{p}^0$.\n2.  **Iteration Loop**: For $t = 0, 1, \\dots, T_{\\max}$:\n    a. **Compute State**: Calculate the agent incomes $m_i(\\mathbf{p}^t)$, aggregate demands $X_g(\\mathbf{p}^t)$, and excess demands $Z_g(\\mathbf{p}^t)$ for all goods $g \\in \\{1, 2, 3\\}$.\n    b. **Check Convergence**: If $\\max_{g} |Z_g(\\mathbf{p}^t)| \\le \\tau$, where $\\tau = 10^{-6}$ is the tolerance, the process has converged. The simulation terminates, reporting the current iteration count $t$, a convergence status of `True`, and the final price vector $\\mathbf{p}^t$.\n    c. **Check Iteration Limit**: If $t$ reaches $T_{\\max}$, the simulation stops. The final state is reported with an iteration count of $T_{\\max}$ and a convergence status determined by the final check in step (b).\n    d. **Price Update**: If the process has not terminated, compute the next price vector $\\mathbf{p}^{t+1}$. The numeraire price is fixed: $p_1^{t+1} = 1$. For each non-numeraire good $g \\in \\{2, 3\\}$, the price is updated according to the stickiness rule:\n       $$\n       p_g^{t+1} =\n       \\begin{cases}\n       \\max\\{\\varepsilon, p_g^t (1 + \\gamma Z_g(\\mathbf{p}^t))\\} & \\text{if } |Z_g(\\mathbf{p}^t)| > \\delta \\\\\n       p_g^t & \\text{if } |Z_g(\\mathbf{p}^t)| \\le \\delta\n       \\end{cases}\n       $$\n       Here, $\\gamma$ is the adjustment speed, $\\delta$ is the stickiness threshold, and $\\varepsilon = 10^{-8}$ is a floor to ensure prices remain strictly positive.\n    e. **Advance**: Set $\\mathbf{p}^t \\leftarrow \\mathbf{p}^{t+1}$, increment the iteration counter, and repeat from step (a).\n\nThis algorithm will be implemented in Python using the `numpy` library for efficient vector and matrix operations. The program will execute the simulation for four specified test cases, each with a different set of parameters $(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0)$, and will format the results as requested.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the tâtonnement process simulations for all test cases.\n    \"\"\"\n    \n    # Calibrated economy parameters\n    alphas = np.array([\n        [0.5, 0.3, 0.2],  # Agent 1\n        [0.2, 0.4, 0.4]   # Agent 2\n    ])\n    \n    endowments = np.array([\n        [1.0, 0.5, 0.5],  # Agent 1\n        [0.5, 1.0, 0.5]   # Agent 2\n    ])\n    \n    agg_endowment = np.sum(endowments, axis=0)\n    \n    # Fixed simulation parameters\n    epsilon = 1e-8\n    tau = 1e-6\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: baseline, no stickiness\n        (0.2, 0.0, 5000, np.array([1.0, 1.0, 1.0])),\n        # Case B: moderate stickiness, off-equilibrium start\n        (0.15, 0.1, 5000, np.array([1.0, 0.7, 1.3])),\n        # Case C: high stickiness, effectively frozen\n        (0.2, 1.0, 10, np.array([1.0, 1.0, 1.0])),\n        # Case D: boundary stickiness at equality\n        (0.2, 0.2, 10, np.array([1.0, 1.0, 1.0])),\n    ]\n\n    results = []\n    for case in test_cases:\n        gamma, delta, T_max, p0 = case\n        \n        # Run the simulation for the current case\n        N, B, p_final = simulate_tatonnement(\n            gamma, delta, T_max, p0, \n            alphas, endowments, agg_endowment, \n            epsilon, tau\n        )\n        \n        # Round final prices to 6 decimal places\n        p_final_rounded = np.round(p_final, 6).tolist()\n        \n        results.append([N, B, p_final_rounded])\n\n    # Final print statement in the exact required format.\n    # The replace(\" \", \"\") call ensures the output matches the dense format.\n    print(str(results).replace(\" \", \"\"))\n\ndef simulate_tatonnement(gamma, delta, T_max, p0, alphas, endowments, agg_endowment, epsilon, tau):\n    \"\"\"\n    Simulates the sticky tâtonnement process for a single case.\n    \n    Returns:\n        N (int): Number of iterations performed.\n        converged (bool): True if convergence was achieved, False otherwise.\n        p (np.ndarray): The final price vector.\n    \"\"\"\n    p = p0.copy()\n    N = 0\n    converged = False\n\n    while N <= T_max:\n        # Step 1: Calculate incomes m_i(p) = p . e_i\n        incomes = np.dot(endowments, p)\n        \n        # Step 2: Calculate individual demands x_ig(p) = alpha_ig * m_i(p) / p_g\n        # We need to handle division by p_g carefully.\n        # income_per_price matrix: (I x G)\n        income_matrix = np.tile(incomes, (alphas.shape[1], 1)).T\n        demands = alphas * income_matrix / p\n        \n        # Step 3: Calculate aggregate and excess demands\n        agg_demand = np.sum(demands, axis=0)\n        excess_demand = agg_demand - agg_endowment\n        \n        # Step 4: Check for convergence\n        if np.max(np.abs(excess_demand)) <= tau:\n            converged = True\n            break\n        \n        # Step 5: Check for maximum iterations\n        if N == T_max:\n            break\n        \n        # Step 6: Update prices for the next iteration\n        p_next = p.copy()\n        \n        # Update for non-numeraire goods (g=2, 3), indices 1, 2\n        for g_idx in [1, 2]:\n            if abs(excess_demand[g_idx]) > delta:\n                p_next[g_idx] = max(epsilon, p[g_idx] * (1 + gamma * excess_demand[g_idx]))\n        \n        p = p_next\n        N += 1\n        \n    return N, converged, p\n\nsolve()\n\n```"}, {"introduction": "Our final practice moves beyond the idealized world of Walrasian tâtonnement, where no transactions occur until equilibrium is reached. Here, you will simulate a 'non-Walrasian' process that allows for limited, rationed trade to happen at out-of-equilibrium prices, causing agents' endowments to evolve over time. This advanced exercise illustrates the concept of path dependency in economic dynamics and provides a richer, more realistic model of how markets grope towards equilibrium [@problem_id:2436167].", "id": "2436167", "problem": "You are given a two-good, two-agent pure exchange economy. Time is discrete and indexed by $t \\in \\{0,1,2,\\dots\\}$. There are two goods labeled $g \\in \\{1,2\\}$, and two agents labeled $i \\in \\{A,B\\}$. At each time $t$, a strictly positive price vector $p_t = (p_{t,1}, p_{t,2}) \\in \\mathbb{R}_{++}^2$ is announced, after which agents form demands based on their current endowments and the announced prices. The process then allows limited, rationed trade to occur if markets fail to clear, followed by a new round of price announcements.\n\nFundamental model components:\n\n1) Preferences and demands. Each agent $i$ has Cobb–Douglas utility over the two goods with parameter $\\alpha_i \\in (0,1)$:\n$$\nu_i(x_{i,1}, x_{i,2}) = x_{i,1}^{\\alpha_i} x_{i,2}^{1-\\alpha_i}.\n$$\nGiven prices $p_t$ and endowment $e_{i}(t) = (e_{i,1}(t), e_{i,2}(t)) \\in \\mathbb{R}_{+}^2$, the budget is $m_i(t) = p_{t,1} e_{i,1}(t) + p_{t,2} e_{i,2}(t)$. The Cobb–Douglas demand of agent $i$ at time $t$ is:\n$$\nd_{i,1}(t) = \\frac{\\alpha_i \\, m_i(t)}{p_{t,1}}, \\qquad d_{i,2}(t) = \\frac{(1-\\alpha_i) \\, m_i(t)}{p_{t,2}}.\n$$\nDefine aggregate demand for good $g$ by $D_g(t) = \\sum_{i \\in \\{A,B\\}} d_{i,g}(t)$. Define aggregate endowment (aggregate supply) $S_g(t) = \\sum_{i \\in \\{A,B\\}} e_{i,g}(t)$. Aggregate excess demand is\n$$\nz_g(t) = D_g(t) - S_g(t).\n$$\n\n2) Limited, rationed trade before the next price announcement. For each good $g \\in \\{1,2\\}$, define each agent’s net desired trade $n_{i,g}(t) = d_{i,g}(t) - e_{i,g}(t)$. Let the sets of buyers and sellers for good $g$ be\n$$\n\\mathcal{B}_g(t) = \\{ i : n_{i,g}(t) > 0 \\}, \\quad \\mathcal{S}_g(t) = \\{ i : n_{i,g}(t) < 0 \\}.\n$$\nDefine total desired purchases and sales for good $g$ by\n$$\nB_g(t) = \\sum_{i \\in \\mathcal{B}_g(t)} n_{i,g}(t), \\qquad S_g^{\\text{tot}}(t) = \\sum_{i \\in \\mathcal{S}_g(t)} \\big( -n_{i,g}(t) \\big).\n$$\nLet $\\rho \\in [0,1]$ be a fixed “per-round trade limit.” The actual quantity of good $g$ traded at time $t$ is the short side multiplied by the limit:\n$$\nT_g(t) = \\rho \\cdot \\min\\big( B_g(t), \\, S_g^{\\text{tot}}(t) \\big).\n$$\nTrading is rationed proportionally to submitted quantities on each side of the market:\n- For each buyer $i \\in \\mathcal{B}_g(t)$, the quantity acquired of good $g$ is\n$$\nq_{i,g}(t) = \\begin{cases}\nT_g(t) \\cdot \\dfrac{n_{i,g}(t)}{B_g(t)} & \\text{if } B_g(t) > 0, \\\\\n0 & \\text{if } B_g(t) = 0,\n\\end{cases}\n$$\nand for each seller $i \\in \\mathcal{S}_g(t)$, the quantity delivered of good $g$ is\n$$\ns_{i,g}(t) = \\begin{cases}\nT_g(t) \\cdot \\dfrac{-n_{i,g}(t)}{S_g^{\\text{tot}}(t)} & \\text{if } S_g^{\\text{tot}}(t) > 0, \\\\\n0 & \\text{if } S_g^{\\text{tot}}(t) = 0.\n\\end{cases}\n$$\nEndowments update by conservation of goods:\n$$\ne_{i,g}(t+1) = e_{i,g}(t) + q_{i,g}(t) - s_{i,g}(t).\n$$\nNote that $S_g(t+1) = \\sum_i e_{i,g}(t+1) = S_g(t)$ for each $g$.\n\n3) Price adjustment (tâtonnement). Let $\\eta > 0$ be a given step parameter. Prices evolve according to\n$$\np_{t+1,g} = p_{t,g} \\cdot \\exp\\!\\left( \\eta \\cdot \\frac{z_g(t)}{S_g(t)} \\right), \\quad g \\in \\{1,2\\}.\n$$\nPrices are then normalized by fixing good $2$ as the numeraire:\n$$\n\\tilde{p}_{t+1,g} = \\frac{p_{t+1,g}}{p_{t+1,2}}, \\quad \\text{so that } \\tilde{p}_{t+1,2} = 1.\n$$\nFor notational simplicity, relabel $\\tilde{p}_{t+1}$ as $p_{t+1}$.\n\n4) Convergence and termination. The process terminates when\n$$\n\\max\\{ |z_1(t)|, |z_2(t)| \\} \\le \\varepsilon\n$$\nfor a given tolerance $\\varepsilon > 0$, or when a maximum number of iterations $T_{\\max}$ is reached. Upon termination, report the normalized price of good $1$, i.e., $p_{t,1}$ with $p_{t,2} = 1$.\n\nTask. Implement a program that simulates the above non-Walrasian, rationed-trade tâtonnement process and returns the final normalized price of good $1$ for each parameter set in the test suite below. All numbers are dimensionless.\n\nTest suite. For each case, the input consists of\n- Cobb–Douglas parameters $(\\alpha_A,\\alpha_B)$,\n- initial endowments $e_A(0) = (e_{A,1}(0), e_{A,2}(0))$, $e_B(0) = (e_{B,1}(0), e_{B,2}(0))$,\n- initial prices $p_0 = (p_{0,1}, p_{0,2})$,\n- step parameter $\\eta$, trade limit $\\rho$, tolerance $\\varepsilon$, and maximum iterations $T_{\\max}$.\n\nSpecify and solve the following four cases:\n\n- Case $1$ (happy path): $(\\alpha_A,\\alpha_B) = (0.5, 0.5)$, $e_A(0) = (1, 0)$, $e_B(0) = (0, 1)$, $p_0 = (2, 1)$, $\\eta = 0.2$, $\\rho = 0.5$, $\\varepsilon = 10^{-8}$, $T_{\\max} = 10000$.\n- Case $2$ (boundary: initially clearing prices): $(\\alpha_A,\\alpha_B) = (0.5, 0.5)$, $e_A(0) = (1, 0)$, $e_B(0) = (0, 1)$, $p_0 = (1, 1)$, $\\eta = 0.2$, $\\rho = 0.7$, $\\varepsilon = 10^{-10}$, $T_{\\max} = 10000$.\n- Case $3$ (edge: no trade allowed between announcements): $(\\alpha_A,\\alpha_B) = (0.5, 0.5)$, $e_A(0) = (1, 0)$, $e_B(0) = (0, 1)$, $p_0 = (3, 1)$, $\\eta = 0.3$, $\\rho = 0$, $\\varepsilon = 10^{-8}$, $T_{\\max} = 10000$.\n- Case $4$ (asymmetric preferences and endowments): $(\\alpha_A,\\alpha_B) = (0.8, 0.2)$, $e_A(0) = (2, 0.5)$, $e_B(0) = (0.5, 1)$, $p_0 = (0.4, 1)$, $\\eta = 0.2$, $\\rho = 1$, $\\varepsilon = 10^{-8}$, $T_{\\max} = 20000$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, output the final normalized price of good $1$ rounded to six decimal places. For example, an output with four cases should look like\n$$\n[\\text{p1\\_case1},\\text{p1\\_case2},\\text{p1\\_case3},\\text{p1\\_case4}],\n$$\nwhere each entry is a decimal number with six digits after the decimal point.", "solution": "The problem is subjected to rigorous validation and is deemed valid. It presents a clearly defined, scientifically grounded, and computationally tractable model of a non-Walrasian tâtonnement process from the field of computational economics. All parameters, equations, and conditions are specified without ambiguity, forming a self-contained and consistent system. The problem asks for the numerical simulation of this system under several parameterizations, a standard task in scientific computing.\n\nThe solution requires implementing a discrete-time simulation that iteratively updates endowments and prices until the market approaches equilibrium. The algorithm proceeds as follows.\n\nLet time be indexed by $t \\in \\{0, 1, 2, \\ldots\\}$. The state of the system at time $t$ is described by the price vector $p_t = (p_{t,1}, p_{t,2})$ and the endowment matrix for the two agents $i \\in \\{A, B\\}$ and two goods $g \\in \\{1, 2\\}$, denoted $e(t) = \\{e_{i,g}(t)\\}$. The simulation starts with initial conditions $p_0$ and $e(0)$. The total endowment of each good, $S_g = \\sum_{i} e_{i,g}(t)$, is constant over time, a property known as conservation of goods, which is inherent in a pure exchange model.\n\nThe simulation loop for each time step $t$ from $0$ to $T_{\\max}-1$ consists of the following sequence of calculations:\n\n1.  **Demand and Excess Demand Calculation**: Given prevailing prices $p_t$ and current endowments $e(t)$, we first compute the budget for each agent $i$:\n    $$\n    m_i(t) = \\sum_{g=1}^{2} p_{t,g} e_{i,g}(t) = p_t \\cdot e_i(t).\n    $$\n    The demand for each good $g$ by agent $i$ is derived from the maximization of their Cobb-Douglas utility function $u_i(x_{i,1}, x_{i,2}) = x_{i,1}^{\\alpha_i} x_{i,2}^{1-\\alpha_i}$ subject to their budget constraint. This yields the demand functions:\n    $$\n    d_{i,1}(t) = \\frac{\\alpha_i m_i(t)}{p_{t,1}} \\quad \\text{and} \\quad d_{i,2}(t) = \\frac{(1-\\alpha_i) m_i(t)}{p_{t,2}}.\n    $$\n    Aggregate demand for each good $g$ is the sum of individual demands, $D_g(t) = \\sum_i d_{i,g}(t)$. Aggregate excess demand for good $g$, denoted $z_g(t)$, is the difference between aggregate demand and aggregate supply (total endowment):\n    $$\n    z_g(t) = D_g(t) - S_g.\n    $$\n    As a consistency check, Walras's Law must hold: $\\sum_g p_{t,g} z_g(t) = 0$.\n\n2.  **Convergence Check**: The simulation terminates if the market is sufficiently close to equilibrium. This is determined by checking if the magnitude of aggregate excess demand for both goods is below a specified tolerance $\\varepsilon > 0$:\n    $$\n    \\max\\left( |z_1(t)|, |z_2(t)| \\right) \\le \\varepsilon.\n    $$\n    If this condition is met, the process stops, and the current normalized price of good $1$, $p_{t,1}$, is the result.\n\n3.  **Rationed Trade and Endowment Update**: If the market has not cleared, out-of-equilibrium trade occurs. This trade is limited by a factor $\\rho \\in [0,1]$ and rationed on the short side of the market.\n    - First, we determine each agent's net desired trade for each good: $n_{i,g}(t) = d_{i,g}(t) - e_{i,g}(t)$.\n    - For each good $g$, we find the total desired purchases, $B_g(t) = \\sum_{i: n_{i,g}(t)>0} n_{i,g}(t)$, and total desired sales, $S_g^{\\text{tot}}(t) = \\sum_{i: n_{i,g}(t)<0} (-n_{i,g}(t))$.\n    - The actual quantity of good $g$ traded is $T_g(t) = \\rho \\cdot \\min(B_g(t), S_g^{\\text{tot}}(t))$.\n    - The amount that a buyer $i$ acquires, $q_{i,g}(t)$, and a seller $j$ gives up, $s_{j,g}(t)$, is proportional to their desired trade volume. For a buyer $i$, $q_{i,g}(t) = T_g(t) \\cdot n_{i,g}(t) / B_g(t)$ (if $B_g(t)>0$), and for a seller $j$, $s_{j,g}(t) = T_g(t) \\cdot (-n_{j,g}(t)) / S_g^{\\text{tot}}(t)$ (if $S_g^{\\text{tot}}(t)>0$).\n    - The endowments for the next period, $t+1$, are then updated based on these trades:\n    $$\n    e_{i,g}(t+1) = e_{i,g}(t) + q_{i,g}(t) - s_{i,g}(t).\n    $$\n    If $\\rho=0$, no trade occurs, and $e_{i,g}(t+1) = e_{i,g}(t)$ for all $i,g,t$.\n\n4.  **Price Update**: The prices for the next period are adjusted based on the current period's excess demands. The unnormalized price for good $g$ is updated using the exponential rule:\n    $$\n    p'_{t+1,g} = p_{t,g} \\cdot \\exp\\left( \\eta \\cdot \\frac{z_g(t)}{S_g} \\right).\n    $$\n    This rule increases the price of goods with positive excess demand and decreases it for those with negative excess demand, ensuring prices remain positive. The step size $\\eta>0$ controls the speed of adjustment.\n\n5.  **Price Normalization**: To prevent prices from diverging and to fix a unit of account, the price vector is normalized. Good $2$ is chosen as the numeraire, meaning its price is set to $1$. The prices for period $t+1$ are:\n    $$\n    p_{t+1,1} = \\frac{p'_{t+1,1}}{p'_{t+1,2}} \\quad \\text{and} \\quad p_{t+1,2} = 1.\n    $$\n    This completes the iteration. The simulation continues with the updated endowments $e(t+1)$ and prices $p_{t+1}$. If the convergence criterion is not met within $T_{\\max}$ iterations, the loop terminates and reports the final computed price $p_{T_{\\max},1}$.\n\nThis entire procedure is encapsulated in a numerical algorithm and applied to each of the four specified test cases to determine the final equilibrium or near-equilibrium price of good $1$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(alpha_A, alpha_B, e_A_0, e_B_0, p_0, eta, rho, eps, T_max):\n    \"\"\"\n    Simulates the non-Walrasian tâtonnement process for a single case.\n\n    Args:\n        alpha_A (float): Cobb-Douglas parameter for agent A.\n        alpha_B (float): Cobb-Douglas parameter for agent B.\n        e_A_0 (tuple): Initial endowment for agent A (good 1, good 2).\n        e_B_0 (tuple): Initial endowment for agent B (good 1, good 2).\n        p_0 (tuple): Initial prices (p1, p2).\n        eta (float): Price adjustment step parameter.\n        rho (float): Per-round trade limit.\n        eps (float): Convergence tolerance.\n        T_max (int): Maximum number of iterations.\n\n    Returns:\n        float: The final normalized price of good 1.\n    \"\"\"\n    # Convert inputs to numpy arrays for vectorized operations\n    alphas = np.array([alpha_A, alpha_B])\n    endowments = np.array([e_A_0, e_B_0], dtype=np.float64)\n    prices = np.array(p_0, dtype=np.float64)\n\n    # Aggregate supply (total endowment) is constant throughout the simulation\n    S_total = np.sum(endowments, axis=0)\n\n    for _ in range(T_max):\n        # Step 1: Calculate Demands and Excess Demands\n        # Budgets: m_i = p . e_i\n        budgets = np.dot(endowments, prices)\n        \n        # Demands: d_i,g\n        demands = np.zeros_like(endowments)\n        # Agent A's demands\n        demands[0, 0] = alphas[0] * budgets[0] / prices[0]\n        demands[0, 1] = (1 - alphas[0]) * budgets[0] / prices[1]\n        # Agent B's demands\n        demands[1, 0] = alphas[1] * budgets[1] / prices[0]\n        demands[1, 1] = (1 - alphas[1]) * budgets[1] / prices[1]\n        \n        # Aggregate Demand and Excess Demand\n        D_total = np.sum(demands, axis=0)\n        z = D_total - S_total\n\n        # Step 2: Check for Convergence\n        if np.max(np.abs(z)) <= eps:\n            return prices[0]\n\n        # Step 3: Rationed Trade and Endowment Update\n        # This step is skipped if rho is 0, as no trade occurs.\n        if rho > 0:\n            net_desired_trades = demands - endowments\n            e_next = endowments.copy()\n\n            for g in range(2):  # For each good\n                n_g = net_desired_trades[:, g]\n                \n                # Identify buyers and sellers\n                buyers_mask = n_g > 1e-12 # Use a small tolerance for floating point\n                sellers_mask = n_g < -1e-12\n\n                # Total desired purchases and sales\n                B_g = np.sum(n_g[buyers_mask])\n                S_g_tot = -np.sum(n_g[sellers_mask])\n\n                if B_g > 0 and S_g_tot > 0:\n                    # Actual quantity of good g traded\n                    T_g = rho * min(B_g, S_g_tot)\n                    \n                    # Rationed quantities and endowment updates\n                    # For buyers of good g\n                    q_ig = T_g * (n_g[buyers_mask] / B_g)\n                    e_next[buyers_mask, g] += q_ig\n                    \n                    # For sellers of good g\n                    s_ig = T_g * (-n_g[sellers_mask] / S_g_tot)\n                    e_next[sellers_mask, g] -= s_ig\n            \n            endowments = e_next\n        \n        # Step 4 & 5: Price Update and Normalization\n        # Update unnormalized prices\n        # Protect against division by zero if S_total[g] is somehow 0\n        update_ratios = np.divide(z, S_total, out=np.zeros_like(z), where=S_total!=0)\n        p_next_unnormalized = prices * np.exp(eta * update_ratios)\n        \n        # Normalize prices using good 2 as numeraire\n        if p_next_unnormalized[1] > 0:\n            prices = p_next_unnormalized / p_next_unnormalized[1]\n        # If p_next_unnormalized[1] hits zero, stop to avoid errors\n        else:\n            break\n            \n    return prices[0]\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Happy path\n        # (alpha_A, alpha_B), e_A(0), e_B(0), p_0, eta, rho, eps, T_max\n        (0.5, 0.5, (1.0, 0.0), (0.0, 1.0), (2.0, 1.0), 0.2, 0.5, 1e-8, 10000),\n        # Case 2: Boundary (initially clearing prices)\n        (0.5, 0.5, (1.0, 0.0), (0.0, 1.0), (1.0, 1.0), 0.2, 0.7, 1e-10, 10000),\n        # Case 3: Edge (no trade allowed)\n        (0.5, 0.5, (1.0, 0.0), (0.0, 1.0), (3.0, 1.0), 0.3, 0.0, 1e-8, 10000),\n        # Case 4: Asymmetric preferences and endowments\n        (0.8, 0.2, (2.0, 0.5), (0.5, 1.0), (0.4, 1.0), 0.2, 1.0, 1e-8, 20000),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha_A, alpha_B, e_A_0, e_B_0, p_0, eta, rho, eps, T_max = case\n        result = solve_case(alpha_A, alpha_B, e_A_0, e_B_0, p_0, eta, rho, eps, T_max)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}