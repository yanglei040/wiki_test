{"hands_on_practices": [{"introduction": "A core insight from heterogeneous agent models is that market prices emerge from the interaction of diverse beliefs and strategies. This first exercise provides a clear, hands-on demonstration of this principle by building a market from the ground up. You will simulate an economy populated by two types of agents—those with perfect foresight and those using a simple historical heuristic—to see how their collective actions shape the asset's price and cause it to diverge from its fundamental value [@problem_id:2399044].", "id": "2399044", "problem": "Consider a single risky asset traded over $T$ discrete periods indexed by $t \\in \\{0,1,\\dots,T-1\\}$. There are $N$ risk-averse agents who trade against an exogenous net supply $Q$ of the asset in each period. The asset delivers a deterministic fundamental payoff $F_t$ at the end of period $t$. A fraction $\\phi$ of agents have a perfect forecast of the fundamental payoff (for each period $t$ they know $F_t$ exactly), representing agents equipped with Artificial Intelligence (AI). The remaining fraction $1-\\phi$ of agents are heuristic forecasters who form expectations using a simple rule.\n\nEach agent $i$ has mean-variance preferences with identical constant absolute risk aversion $a$ and common perceived payoff variance $s^2$ for the asset in each period. In period $t$, given price $P_t$ and agent-specific expectation $E_i[F_t]$ of the period-$t$ payoff, agent $i$ demands\n$$\nD_{i,t} \\;=\\; \\frac{E_i[F_t] - P_t}{a\\,s^2}.\n$$\nMarket clearing in each period requires\n$$\n\\sum_{i=1}^{N} D_{i,t} \\;=\\; Q.\n$$\nExpectations are heterogeneous as follows:\n- For AI-informed agents, $E_i[F_t] = F_t$.\n- For heuristic agents, the expectation is the previous period price, i.e.,\n$$\nE_i[F_t] \\;=\\; H_t \\;=\\; P_{t-1}.\n$$\nThe initial condition is given by $P_{-1} = F_0$ so that the heuristic expectation in the first trading period is well-defined.\n\nThe fundamental payoff path is common across all test cases and is defined deterministically by\n$$\nF_t \\;=\\; 100 \\;+\\; 5 \\,\\sin\\!\\left( \\frac{2\\pi t}{10} \\right) \\;+\\; 0.5\\,t\n$$\nfor all $t \\in \\{0,1,\\dots,T-1\\}$, with the sine function taking its argument in radians.\n\nYour task is to compute the price sequence $\\{P_t\\}_{t=0}^{T-1}$ implied by the above market for given parameters $\\left(T,N,\\phi,a,s^2,Q\\right)$, using the market clearing condition and the specified expectations. For each parameter set, compute the mean absolute deviation between prices and fundamentals,\n$$\n\\mathrm{MAD} \\;=\\; \\frac{1}{T}\\sum_{t=0}^{T-1} \\left| P_t - F_t \\right|,\n$$\nas a real number.\n\nUse the following fixed model ingredients for all test cases:\n- Number of periods $T=20$.\n- Number of agents $N=100$.\n\nTest suite of parameter sets to evaluate:\n- Case $1$: $\\phi=0.4$, $a=2.0$, $s^2=1.0$, $Q=10.0$.\n- Case $2$: $\\phi=1.0$, $a=3.0$, $s^2=2.0$, $Q=0.0$.\n- Case $3$: $\\phi=0.0$, $a=2.0$, $s^2=1.0$, $Q=5.0$.\n- Case $4$: $\\phi=0.5$, $a=10^6$, $s^2=1.0$, $Q=0.0$.\n- Case $5$: $\\phi=0.6$, $a=2.0$, $s^2=1.0$, $Q=100.0$.\n\nYour program must compute the $\\mathrm{MAD}$ for each case, in the order listed above, and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each value rounded to $6$ decimal places (for example, $\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$). No other text should be printed.", "solution": "The problem statement has been subjected to rigorous validation and is found to be valid. It is scientifically sound, well-posed, and objective. It presents a standard heterogeneous agent model from computational economics, providing all necessary parameters and initial conditions to derive a unique, computable solution. We will proceed to solve it.\n\nThe model consists of $N$ agents trading a risky asset. A fraction $\\phi$ of these agents are \"AI-informed,\" with perfect foresight of the fundamental payoff $F_t$. Their expectation is $E_{\\text{AI}}[F_t] = F_t$. The remaining fraction $1-\\phi$ are \"heuristic\" agents, who form their expectation based on the previous period's price: $E_{\\text{Heuristic}}[F_t] = P_{t-1}$. All agents share the same constant absolute risk aversion coefficient $a$ and perceived payoff variance $s^2$. The demand for agent $i$ in period $t$ is given by:\n$$\nD_{i,t} = \\frac{E_i[F_t] - P_t}{a s^2}\n$$\nMarket clearing dictates that total demand equals the net supply $Q$:\n$$\n\\sum_{i=1}^{N} D_{i,t} = Q\n$$\nWe can express the total demand by summing the demands from each agent type. The number of AI-informed agents is $N\\phi$ and the number of heuristic agents is $N(1-\\phi)$. The market clearing condition thus becomes:\n$$\n(N\\phi) \\left( \\frac{F_t - P_t}{a s^2} \\right) + N(1-\\phi) \\left( \\frac{P_{t-1} - P_t}{a s^2} \\right) = Q\n$$\nTo find the equilibrium price $P_t$, we must solve this equation for $P_t$. First, we multiply both sides by $\\frac{a s^2}{N}$:\n$$\n\\phi(F_t - P_t) + (1-\\phi)(P_{t-1} - P_t) = \\frac{a s^2 Q}{N}\n$$\nNext, we expand and collect the terms involving $P_t$:\n$$\n\\phi F_t - \\phi P_t + (1-\\phi) P_{t-1} - (1-\\phi) P_t = \\frac{a s^2 Q}{N}\n$$\n$$\n\\phi F_t + (1-\\phi) P_{t-1} - (\\phi + 1 - \\phi) P_t = \\frac{a s^2 Q}{N}\n$$\n$$\n\\phi F_t + (1-\\phi) P_{t-1} - P_t = \\frac{a s^2 Q}{N}\n$$\nIsolating $P_t$ yields the first-order linear recurrence relation for the price path:\n$$\nP_t = \\phi F_t + (1-\\phi) P_{t-1} - \\frac{a s^2 Q}{N}\n$$\nThis equation shows that the current price is a weighted average of the fundamental value $F_t$ and the previous price $P_{t-1}$, adjusted for a risk premium term related to the net supply $Q$. The weights are determined by the fraction of AI-informed agents, $\\phi$.\n\nThe problem provides the deterministic path for the fundamental value $F_t$ over $T=20$ periods:\n$$\nF_t = 100 + 5 \\sin\\left(\\frac{2\\pi t}{10}\\right) + 0.5t \\quad \\text{for } t \\in \\{0, 1, \\dots, T-1\\}\n$$\nAn initial condition is required to start the recursion. It is given as $P_{-1} = F_0$. With this, we can compute the entire price sequence $\\{P_t\\}_{t=0}^{T-1}$ iteratively.\n\nThe algorithm for each test case is as follows:\n1.  Set the parameters $(T, N, \\phi, a, s^2, Q)$.\n2.  Generate the fundamental value series $\\{F_t\\}_{t=0}^{T-1}$ according to its definition.\n3.  Initialize the price recursion with $P_{-1} = F_0$.\n4.  Iterate for $t$ from $0$ to $T-1$, applying the derived recurrence relation to compute each $P_t$.\n5.  Once the price series $\\{P_t\\}_{t=0}^{T-1}$ is computed, calculate the mean absolute deviation (MAD) from the fundamental values:\n    $$\n    \\mathrm{MAD} = \\frac{1}{T} \\sum_{t=0}^{T-1} |P_t - F_t|\n    $$\nThis procedure is applied to each of the five specified parameter sets to obtain the required results. The implementation will utilize numerical libraries to ensure precision.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the price path and Mean Absolute Deviation (MAD) for a\n    heterogeneous agent model based on the problem specification.\n    \"\"\"\n    \n    # Fixed model parameters\n    T = 20\n    N = 100\n\n    # Test suite of parameter sets (phi, a, s^2, Q)\n    test_cases = [\n        (0.4, 2.0, 1.0, 10.0),  # Case 1\n        (1.0, 3.0, 2.0, 0.0),   # Case 2\n        (0.0, 2.0, 1.0, 5.0),   # Case 3\n        (0.5, 1e6, 1.0, 0.0),   # Case 4\n        (0.6, 2.0, 1.0, 100.0)  # Case 5\n    ]\n\n    results = []\n\n    # Generate the fundamental payoff path\n    t_vals = np.arange(T)\n    F = 100.0 + 5.0 * np.sin(2.0 * np.pi * t_vals / 10.0) + 0.5 * t_vals\n\n    for case in test_cases:\n        phi, a, s2, Q = case\n        \n        # Initialize the price array\n        P = np.zeros(T)\n        \n        # Set the initial condition P_{-1} = F_0\n        P_prev = F[0]\n        \n        # Define the constant term from the recurrence relation\n        const_term = (a * s2 * Q) / N\n        \n        # Iterate through time to compute the price path\n        for t in range(T):\n            # Price recurrence relation: P_t = phi*F_t + (1-phi)*P_{t-1} - (a*s^2*Q)/N\n            P[t] = phi * F[t] + (1 - phi) * P_prev - const_term\n            P_prev = P[t]\n            \n        # Calculate the Mean Absolute Deviation (MAD)\n        mad = np.mean(np.abs(P - F))\n        \n        # Append formatted result\n        results.append(f\"{mad:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "Real-world markets are not static; they evolve as agents learn and as wealth shifts between different strategies. This practice introduces these crucial dynamics by modeling agents who not only form expectations but also update them based on past errors, a process known as adaptive learning. By simulating how both beliefs and wealth co-evolve, you will explore how successful strategies gain more market influence over time, a key feedback loop that drives market evolution [@problem_id:2399122].", "id": "2399122", "problem": "Consider a large population of agents making portfolio choices between a safe asset and a risky asset. Time is discrete, indexed by $t \\in \\{0,1,2,\\dots,T-1\\}$. Each agent $i \\in \\{1,\\dots,N\\}$ chooses, at the start of period $t$, a portfolio share $x_{i,t} \\in [0,1]$ to invest in the risky asset, with the remaining share $1-x_{i,t}$ invested in the safe asset. The safe asset has a constant gross return $R_f > 0$. The risky asset has a net return $r_t$ that is independent and identically distributed (i.i.d.) across time with unknown mean $\\mu^\\star$ and known variance $\\sigma^2$. Returns are expressed in decimals; for example, a five percent return is $0.05$ and a one percent gross risk-free return per period is $R_f = 1.01$.\n\nAgents are heterogeneous in two dimensions:\n- Each agent $i$ has a risk-aversion coefficient $\\gamma_i > 0$.\n- Each agent $i$ has a learning rate $\\alpha_i \\in (0,1]$ used to adaptively update her estimate of the risky asset’s expected net return.\n\nAt time $t$, before observing $r_t$, each agent holds a belief $\\mu_{i,t}$ about the risky asset’s expected net return. Beliefs evolve according to adaptive learning:\n$$\n\\mu_{i,t+1} \\;=\\; \\mu_{i,t} + \\alpha_i \\left(r_t - \\mu_{i,t}\\right).\n$$\nAssume all agents know the variance $\\sigma^2$ and the safe gross return $R_f$, but not $\\mu^\\star$. There is a no-short, no-leverage constraint: $x_{i,t} \\in [0,1]$ for all $i,t$.\n\nWealth evolves according to standard gross returns aggregation:\n$$\nW_{i,t+1} \\;=\\; W_{i,t} \\left[ R_f \\left(1-x_{i,t}\\right) + \\left(1+r_t\\right) x_{i,t} \\right],\n$$\nwith initial wealth $W_{i,0} = 1$ for all $i$.\n\nAgents choose $x_{i,t}$ to maximize a mean-variance objective grounded in the Markowitz framework, which can be rationalized by exponential utility under normal returns. Starting from the definitions of expectation and variance for linear portfolios and the normality assumption for $r_t$, derive from first principles the one-period optimal risky share $x_{i,t}$ as a function of the agent’s belief $\\mu_{i,t}$, the safe return $R_f$, the risk-aversion parameter $\\gamma_i$, and the return variance $\\sigma^2$, under the constraint $x_{i,t} \\in [0,1]$. The final choice rule must be obtained from first-order conditions and then projected onto the feasible set $[0,1]$.\n\nDefine the wealth-weighted aggregate risky share at time $t$ as\n$$\n\\bar{x}_t \\;=\\; \\frac{\\sum_{i=1}^{N} W_{i,t} \\, x_{i,t}}{\\sum_{i=1}^{N} W_{i,t}}.\n$$\n\nYour task is to implement a simulation of this heterogeneous-agent economy and compute, for each parameter set in the test suite below, the time average of the wealth-weighted risky share over the last $L$ periods:\n$$\n\\bar{x}_{\\text{avg}} \\;=\\; \\frac{1}{L} \\sum_{t=T-L}^{T-1} \\bar{x}_t.\n$$\n\nInitial beliefs are set to the safe net return for all agents:\n$$\n\\mu_{i,0} \\;=\\; R_f - 1.\n$$\n\nHeterogeneity is assigned deterministically using index-based cycles. Let $\\gamma_{\\text{base}} > 0$ and $\\alpha_{\\text{base}} \\in (0,1]$ be given. For agent indices $i = 1,\\dots,N$, define\n$$\n\\gamma_i \\;=\\; \\gamma_{\\text{base}} \\times m_{(i \\bmod 4)},\n\\quad \\text{where } m_{0}=0.5,\\; m_{1}=1.0,\\; m_{2}=1.5,\\; m_{3}=2.0,\n$$\nand\n$$\n\\alpha_i \\;=\\; \\min\\left(0.9,\\; \\alpha_{\\text{base}} \\times a_{(i \\bmod 4)}\\right),\n\\quad \\text{where } a_{0}=0.5,\\; a_{1}=1.0,\\; a_{2}=2.0,\\; a_{3}=4.0.\n$$\n\nSimulation protocol:\n- Use $N$ agents and $T$ periods.\n- The risky net return is drawn as $r_t \\sim \\mathcal{N}(\\mu^\\star,\\sigma^2)$ independently across $t$.\n- Use a fixed pseudo-random number generator seed for reproducibility: a base seed of $12345$, offset by the zero-based test case index $k \\in \\{0,1,2,3\\}$ so that the seed for case $k$ is $12345 + k$.\n- Compute $\\bar{x}_{\\text{avg}}$ as defined above.\n\nTest suite (each item is a parameter tuple $(\\mu^\\star,\\sigma,R_f,\\gamma_{\\text{base}},\\alpha_{\\text{base}},N,T,L)$; all returns are decimals):\n1. Case $1$: $(0.06,\\,0.15,\\,1.01,\\,3.0,\\,0.20,\\,200,\\,2000,\\,500)$.\n2. Case $2$: $(0.01,\\,0.15,\\,1.01,\\,3.0,\\,0.20,\\,200,\\,2000,\\,500)$.\n3. Case $3$: $(0.06,\\,0.20,\\,1.01,\\,3.0,\\,0.20,\\,200,\\,2000,\\,500)$.\n4. Case $4$: $(0.06,\\,0.15,\\,1.01,\\,6.0,\\,0.05,\\,200,\\,2000,\\,500)$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the cases above, for example\n$[r_1,r_2,r_3,r_4]$,\nwhere each $r_k$ is the floating-point value of $\\bar{x}_{\\text{avg}}$ for case $k$, expressed as a decimal (not a percentage). Round or format as you see fit, but ensure standard floating-point formatting is used so that each $r_k$ can be parsed as a float.", "solution": "The problem statement is critically validated and found to be valid. It is a well-posed problem in the field of computational economics, grounded in established economic theory, and all necessary parameters and functional forms for a simulation are provided. The model combines a standard Markowitz-style portfolio choice problem with an adaptive learning dynamic, which is a common structure for heterogeneous agent models in finance. There are no scientific inconsistencies, contradictions, or critical ambiguities that would prevent a unique and meaningful solution. The minor ambiguity regarding the agent indexing `i mod 4` is resolved by adopting the standard computational convention of using a zero-based index derived from the one-based agent index, i.e., `(i-1) mod 4`, which aligns with the provided multiplier indices $\\{0,1,2,3\\}$.\n\nThe solution proceeds in two parts: first, the derivation of the agent's optimal decision rule from first principles, and second, the description of the simulation algorithm constructed upon this rule.\n\n**Part 1: Derivation of the Optimal Risky Asset Share**\n\nEach agent $i$ chooses the share of their wealth $x_{i,t} \\in [0,1]$ to invest in the risky asset to maximize a one-period mean-variance objective. The gross return on the agent's portfolio, $R_{p,i,t}$, is a weighted average of the safe asset gross return, $R_f$, and the risky asset gross return, $1+r_t$:\n$$\nR_{p,i,t} \\;=\\; (1-x_{i,t})R_f + x_{i,t}(1+r_t)\n$$\nThis can be rewritten in terms of the excess return of the risky asset over the safe asset:\n$$\nR_{p,i,t} \\;=\\; R_f + x_{i,t}(1+r_t - R_f) \\;=\\; R_f + x_{i,t}(r_t - (R_f-1))\n$$\nLet $r_f = R_f-1$ be the net risk-free rate.\n$$\nR_{p,i,t} \\;=\\; R_f + x_{i,t}(r_t - r_f)\n$$\nThe agent's decision is made at time $t$ before $r_t$ is known. Therefore, the agent uses their subjective expectation $E_t[\\cdot]$ based on their belief $\\mu_{i,t}$ and the known variance $\\sigma^2$. The expected portfolio return is:\n$$\nE_t[R_{p,i,t}] \\;=\\; E_t[R_f + x_{i,t}(r_t - r_f)] \\;=\\; R_f + x_{i,t}(E_t[r_t] - r_f) \\;=\\; R_f + x_{i,t}(\\mu_{i,t} - r_f)\n$$\nThe variance of the portfolio return is:\n$$\nVar_t(R_{p,i,t}) \\;=\\; Var_t(R_f + x_{i,t}(r_t - r_f)) \\;=\\; Var_t(x_{i,t}r_t) \\;=\\; x_{i,t}^2 Var_t(r_t) \\;=\\; x_{i,t}^2 \\sigma^2\n$$\nThe mean-variance objective function for agent $i$ is to maximize:\n$$\nU(x_{i,t}) \\;=\\; E_t[R_{p,i,t}] - \\frac{\\gamma_i}{2} Var_t(R_{p,i,t})\n$$\nSubstituting the expressions for the expected value and variance:\n$$\nU(x_{i,t}) \\;=\\; \\left( R_f + x_{i,t}(\\mu_{i,t} - r_f) \\right) - \\frac{\\gamma_i}{2} x_{i,t}^2 \\sigma^2\n$$\nThis is a concave quadratic function of $x_{i,t}$. To find the optimal unconstrained share, $x_{i,t}^*$, we take the first derivative with respect to $x_{i,t}$ and set it to zero (the first-order condition for a maximum):\n$$\n\\frac{\\mathrm{d}U}{\\mathrm{d}x_{i,t}} \\;=\\; (\\mu_{i,t} - r_f) - \\gamma_i \\sigma^2 x_{i,t} \\;=\\; 0\n$$\nSolving for $x_{i,t}$:\n$$\nx_{i,t}^* \\;=\\; \\frac{\\mu_{i,t} - r_f}{\\gamma_i \\sigma^2} \\;=\\; \\frac{\\mu_{i,t} - (R_f - 1)}{\\gamma_i \\sigma^2}\n$$\nThis is the classic Merton's share. The numerator represents the perceived excess net return of the risky asset, and the denominator is the product of risk aversion and return variance.\n\nThe problem specifies a no-short-selling and no-leverage constraint, meaning $x_{i,t}$ must lie in the interval $[0,1]$. The final optimal choice is the projection of the unconstrained solution $x_{i,t}^*$ onto this feasible set:\n$$\nx_{i,t} \\;=\\; \\max\\left(0, \\min\\left(1, x_{i,t}^*\\right)\\right)\n$$\n\n**Part 2: Simulation Algorithm**\n\nThe simulation models the economy over $T$ discrete time periods for a population of $N$ heterogeneous agents. The algorithm proceeds as follows:\n\n1.  **Initialization (at $t=0$):**\n    *   Set the global parameters $(\\mu^\\star, \\sigma, R_f, N, T, L)$ and heterogeneity base parameters $(\\gamma_{\\text{base}}, \\alpha_{\\text{base}})$ from the test case.\n    *   Initialize the pseudo-random number generator with the specified seed.\n    *   Create the population of $N$ agents. For each agent $i \\in \\{1, \\dots, N\\}$, assign the heterogeneous parameters $\\gamma_i$ and $\\alpha_i$ according to the deterministic cycle. Let $j = (i-1) \\pmod 4$. Then:\n        $$\n        \\gamma_i \\;=\\; \\gamma_{\\text{base}} \\times m_j, \\quad \\text{where } m \\in \\{0.5, 1.0, 1.5, 2.0\\}\n        $$\n        $$\n        \\alpha_i \\;=\\; \\min(0.9, \\alpha_{\\text{base}} \\times a_j), \\quad \\text{where } a \\in \\{0.5, 1.0, 2.0, 4.0\\}\n        $$\n    *   Set the initial state variables for each agent $i$:\n        *   Initial wealth: $W_{i,0} = 1$.\n        *   Initial belief: $\\mu_{i,0} = R_f - 1$.\n\n2.  **Time Loop (for $t=0, 1, \\dots, T-1$):**\n    The following steps are executed in each period $t$:\n    *   **a. Portfolio Choice:** Each agent $i$ calculates their optimal risky asset allocation $x_{i,t}$ using their current belief $\\mu_{i,t}$ and the derived formula from Part 1.\n    *   **b. Aggregation:** The wealth-weighted aggregate risky share for the economy, $\\bar{x}_t$, is computed:\n        $$\n        \\bar{x}_t \\;=\\; \\frac{\\sum_{i=1}^{N} W_{i,t} \\, x_{i,t}}{\\sum_{i=1}^{N} W_{i,t}}\n        $$\n        If the current period $t$ is within the final averaging window, i.e., $t \\ge T-L$, the value of $\\bar{x}_t$ is stored.\n    *   **c. Market Realization:** A random net return for the risky asset, $r_t$, is drawn from a normal distribution with the true mean $\\mu^\\star$ and variance $\\sigma^2$: $r_t \\sim \\mathcal{N}(\\mu^\\star, \\sigma^2)$.\n    *   **d. State Update:** The states of all agents are updated to reflect the outcome of period $t$, preparing for period $t+1$:\n        *   Wealth evolution: $W_{i,t+1} = W_{i,t} [ R_f (1-x_{i,t}) + (1+r_t) x_{i,t} ]$.\n        *   Belief evolution: $\\mu_{i,t+1} = \\mu_{i,t} + \\alpha_i (r_t - \\mu_{i,t})$.\n\n3.  **Final Calculation:**\n    After the simulation loop completes, the final output, $\\bar{x}_{\\text{avg}}$, is calculated by taking the arithmetic mean of the stored $\\bar{x}_t$ values from the last $L$ periods:\n    $$\n    \\bar{x}_{\\text{avg}} \\;=\\; \\frac{1}{L} \\sum_{t=T-L}^{T-1} \\bar{x}_t\n    $$\n\nThis algorithm is implemented using vectorized operations with the `numpy` library to ensure computational efficiency.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(mu_star, sigma, R_f, gamma_base, alpha_base, N, T, L, seed):\n    \"\"\"\n    Runs a single simulation of the heterogeneous agent model.\n\n    Args:\n        mu_star (float): True mean of the risky asset net return.\n        sigma (float): True standard deviation of the risky asset net return.\n        R_f (float): Gross risk-free return.\n        gamma_base (float): Base risk-aversion coefficient.\n        alpha_base (float): Base learning rate.\n        N (int): Number of agents.\n        T (int): Number of time periods.\n        L (int): Number of last periods to average over.\n        seed (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        float: The time average of the wealth-weighted risky share over the last L periods.\n    \"\"\"\n    # Initialize the pseudo-random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # Define heterogeneity multipliers\n    m_multipliers = np.array([0.5, 1.0, 1.5, 2.0])\n    a_multipliers = np.array([0.5, 1.0, 2.0, 4.0])\n\n    # Assign heterogeneous parameters to agents based on index-based cycles.\n    agent_indices_mod_4 = np.arange(N) % 4\n    gamma_i = gamma_base * m_multipliers[agent_indices_mod_4]\n    alpha_i = np.minimum(0.9, alpha_base * a_multipliers[agent_indices_mod_4])\n\n    # Initial state variables\n    r_f_net = R_f - 1.0\n    mu_i_t = np.full(N, r_f_net)\n    W_i_t = np.ones(N)\n    \n    # Pre-calculate constant variance\n    sigma2 = sigma**2\n\n    # Storage for results in the final averaging window\n    x_bar_history = []\n\n    # Simulation loop over T periods\n    for t in range(T):\n        # 1. Agents make portfolio choices\n        # Calculate unconstrained optimal share\n        x_i_t_star = (mu_i_t - r_f_net) / (gamma_i * sigma2)\n        # Apply no-short, no-leverage constraint [0, 1]\n        x_i_t = np.clip(x_i_t_star, 0.0, 1.0)\n        \n        # 2. Compute and store aggregate risky share if in the final L periods\n        if t >= T - L:\n            total_W_t = np.sum(W_i_t)\n            # Avoid division by zero, though unlikely with these parameters\n            if total_W_t > 0:\n                x_bar_t = np.sum(W_i_t * x_i_t) / total_W_t\n                x_bar_history.append(x_bar_t)\n            else:\n                 x_bar_history.append(0.0)\n\n        # 3. Realize the risky asset's net return for the period\n        r_t = rng.normal(loc=mu_star, scale=sigma)\n        \n        # 4. Update agent states for the next period\n        # Update wealth\n        portfolio_gross_return = R_f * (1.0 - x_i_t) + (1.0 + r_t) * x_i_t\n        W_i_t = W_i_t * portfolio_gross_return\n        # Update beliefs\n        mu_i_t = mu_i_t + alpha_i * (r_t - mu_i_t)\n\n    # 5. Final calculation: average of the stored aggregate shares\n    x_bar_avg = np.mean(x_bar_history) if x_bar_history else 0.0\n    \n    return x_bar_avg\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print the results.\n    \"\"\"\n    _ = np.set_printoptions # Scipy and numpy are permitted; not used here.\n\n    # Test suite: (mu_star, sigma, R_f, gamma_base, alpha_base, N, T, L)\n    test_cases = [\n        (0.06, 0.15, 1.01, 3.0, 0.20, 200, 2000, 500),\n        (0.01, 0.15, 1.01, 3.0, 0.20, 200, 2000, 500),\n        (0.06, 0.20, 1.01, 3.0, 0.20, 200, 2000, 500),\n        (0.06, 0.15, 1.01, 6.0, 0.05, 200, 2000, 500),\n    ]\n\n    results = []\n    base_seed = 12345\n    for i, case in enumerate(test_cases):\n        mu_star, sigma, R_f, gamma_base, alpha_base, N, T, L = case\n        # Set seed based on test case index\n        seed = base_seed + i\n        result = run_simulation(mu_star, sigma, R_f, gamma_base, alpha_base, N, T, L, seed)\n        results.append(result)\n\n    # Format the output as a comma-separated list in brackets, with standard float precision.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"}, {"introduction": "Financial instability can sometimes arise not from faulty expectations, but from the mechanical trading rules agents must follow, especially those related to leverage. This final exercise provides a stylized model to explore the concept of endogenous risk, where market dynamics themselves create fragility. By simulating the behavior of a single, highly-leveraged trader subject to a maximum leverage constraint, you will witness firsthand how forced selling (deleveraging) in a downturn can amplify price crashes and generate large drawdowns, illustrating a fundamental mechanism behind financial crises [@problem_id:2399105].", "id": "2399105", "problem": "Consider a discrete-time market with heterogeneous agents trading a single risky asset over $T$ periods. Time is indexed by $t \\in \\{0,1,2,\\dots,T\\}$. There is a continuum of baseline liquidity providers who aggregate to a linear inverse demand around a fundamental signal, and a single leveraged agent. Let the fundamental signal be $v_t \\in \\mathbb{R}_{>0}$, and let the traded price be $p_t \\in \\mathbb{R}_{>0}$. The baseline liquidity is summarized by a reduced-form linear price impact coefficient $\\alpha \\in \\mathbb{R}_{>0}$ such that, at any period $t \\ge 1$, if the leveraged agent chooses a position $q_t \\in \\mathbb{R}$ (measured in shares, with $q_t \\ge 0$ interpreted as a long position), the market-clearing price satisfies\n$$\np_t \\;=\\; v_t \\;+\\; \\alpha \\, q_t.\n$$\nThe leveraged agent has equity (wealth) $W_t \\in \\mathbb{R}$, with initial equity $W_0 \\in \\mathbb{R}_{>0}$, and enters period $t \\ge 1$ with $(p_{t-1}, q_{t-1}, W_{t-1})$. The agent faces a leverage constraint specified by a target leverage $L_{\\text{target}} \\in \\mathbb{R}_{\\ge 0}$ and a maximum admissible leverage $L_{\\max} \\in \\mathbb{R}_{\\ge 0}$. Leverage is defined as assets over equity, namely $\\ell_t = \\dfrac{p_t \\, q_t}{W_t}$ whenever $W_t > 0$. The agent is bankrupt and exits permanently if $W_t \\le 0$, in which case $q_s = 0$ and $p_s = v_s$ for all subsequent periods $s \\ge t$.\n\nEach period $t \\ge 1$ proceeds as follows. First, the fundamental updates deterministically to\n$$\nv_t \\;=\\; v_0 \\;+\\; A \\, \\sin\\!\\Big( \\dfrac{2\\pi t}{P} \\Big),\n$$\nwhere $A \\in \\mathbb{R}_{\\ge 0}$ is the amplitude, $P \\in \\mathbb{R}_{>0}$ is the period, and the sine function is evaluated in radians. Next, before the leveraged agent trades, the pre-trade price is\n$$\np_t^{\\text{pre}} \\;=\\; v_t \\;+\\; \\alpha \\, q_{t-1}.\n$$\nThe agent’s interim equity (marked to $p_t^{\\text{pre}}$) is\n$$\nW_t' \\;=\\; W_{t-1} \\;+\\; q_{t-1} \\, \\big( p_t^{\\text{pre}} - p_{t-1} \\big).\n$$\nIf $W_t' \\le 0$, the agent defaults immediately, and the period closes at $p_t = v_t$ with $q_t = 0$ and $W_t = 0$. If $W_t' > 0$, the agent compares pre-trade leverage $\\ell_t^{\\text{pre}} = \\dfrac{p_t^{\\text{pre}} \\, q_{t-1}}{W_t'}$ to $L_{\\max}$. If $\\ell_t^{\\text{pre}} > L_{\\max}$, the agent must deleverage to the maximum, setting a post-trade leverage target $m_t = L_{\\max}$. Otherwise, the agent aims for $m_t = \\min\\{L_{\\text{target}}, L_{\\max}\\}$. The agent then chooses $(q_t, p_t)$ to satisfy the market-clearing condition and the leverage target simultaneously:\n$$\np_t \\;=\\; v_t \\;+\\; \\alpha \\, q_t,\n\\qquad\np_t \\, q_t \\;=\\; m_t \\, W_t'.\n$$\nIf $m_t = 0$, this implies $q_t = 0$ and $p_t = v_t$. If $m_t > 0$, combining the two equations yields the quadratic condition\n$$\np_t^2 \\;-\\; v_t \\, p_t \\;-\\; \\alpha \\, m_t \\, W_t' \\;=\\; 0,\n$$\nwhose economically relevant solution is\n$$\np_t \\;=\\; \\dfrac{v_t \\;+\\; \\sqrt{\\,v_t^2 \\;+\\; 4 \\alpha \\, m_t \\, W_t'\\,}}{2},\n\\qquad\nq_t \\;=\\; \\dfrac{m_t \\, W_t'}{p_t}.\n$$\nPost-trade equity is $W_t = W_t'$. The initial conditions are $p_0 = v_0$, $q_0 = 0$, and $W_0$ given.\n\nFor each simulation, define the maximum drawdown over the horizon $t \\in \\{1,2,\\dots,T\\}$ as\n$$\n\\text{MDD} \\;=\\; \\max_{1 \\le t \\le T} \\;\\left( \\dfrac{\\max_{1 \\le s \\le t} p_s \\;-\\; p_t}{\\max_{1 \\le s \\le t} p_s} \\right),\n$$\nwith the convention that the fraction is $0$ when the denominator is $0$.\n\nYour task is to compute the maximum drawdown $\\text{MDD}$ for each of the following test cases. Each case specifies the tuple $(T, v_0, A, P, \\alpha, W_0, L_{\\text{target}}, L_{\\max})$:\n\n- Case $1$: $(T, v_0, A, P, \\alpha, W_0, L_{\\text{target}}, L_{\\max}) = (200, 100, 5, 50, 0.8, 100, 0, 0)$.\n- Case $2$: $(T, v_0, A, P, \\alpha, W_0, L_{\\text{target}}, L_{\\max}) = (200, 100, 5, 50, 0.8, 100, 2, 6)$.\n- Case $3$: $(T, v_0, A, P, \\alpha, W_0, L_{\\text{target}}, L_{\\max}) = (200, 100, 5, 50, 0.8, 100, 8, 6)$.\n- Case $4$: $(T, v_0, A, P, \\alpha, W_0, L_{\\text{target}}, L_{\\max}) = (200, 100, 5, 50, 1.2, 100, 8, 6)$.\n- Case $5$: $(T, v_0, A, P, \\alpha, W_0, L_{\\text{target}}, L_{\\max}) = (200, 100, 5, 50, 1.2, 40, 8, 6)$.\n\nYour program should produce a single line of output containing the five maximum drawdowns in order for Cases $1$ through $5$, as a comma-separated list enclosed in square brackets, with each value expressed as a decimal rounded to exactly six digits after the decimal point (for example, $[0.012345,0.067890,0.000000,0.543210,0.101112]$).", "solution": "We formalize the market with one risky asset, baseline liquidity summarized by a linear price impact coefficient, and a single leveraged agent. Prices clear each period according to the reduced-form inverse demand. The leveraged agent’s constraint binds through a leverage metric defined as assets over equity.\n\nModel primitives and variables. Let $T \\in \\mathbb{N}$, $v_0 \\in \\mathbb{R}_{>0}$, $A \\in \\mathbb{R}_{\\ge 0}$, $P \\in \\mathbb{R}_{>0}$, $\\alpha \\in \\mathbb{R}_{>0}$, $W_0 \\in \\mathbb{R}_{>0}$, $L_{\\text{target}} \\in \\mathbb{R}_{\\ge 0}$, and $L_{\\max} \\in \\mathbb{R}_{\\ge 0}$. The fundamental evolves deterministically by\n$$\nv_t \\;=\\; v_0 \\;+\\; A \\sin\\!\\Big( \\dfrac{2\\pi t}{P} \\Big),\n$$\nwith the angle measured in radians. The market-clearing price when the leveraged agent holds $q_t$ shares is\n$$\np_t \\;=\\; v_t \\;+\\; \\alpha \\, q_t.\n$$\n\nPeriod-by-period evolution. At the end of period $t-1$, the state is $(p_{t-1}, q_{t-1}, W_{t-1})$. At period $t \\ge 1$:\n\n1. Fundamental update: compute $v_t$ as above.\n\n2. Pre-trade price given existing position:\n$$\np_t^{\\text{pre}} \\;=\\; v_t \\;+\\; \\alpha \\, q_{t-1}.\n$$\n\n3. Interim equity marked to pre-trade price:\n$$\nW_t' \\;=\\; W_{t-1} \\;+\\; q_{t-1} \\big( p_t^{\\text{pre}} - p_{t-1} \\big).\n$$\nIf $W_t' \\le 0$, the agent is bankrupt and exits. The period closes at $p_t = v_t$, $q_t = 0$, and $W_t = 0$, and this remains so for all subsequent periods.\n\n4. If $W_t' > 0$, compute the pre-trade leverage\n$$\n\\ell_t^{\\text{pre}} \\;=\\; \\dfrac{p_t^{\\text{pre}} \\, q_{t-1}}{W_t'}.\n$$\nDetermine the post-trade leverage target\n$$\nm_t \\;=\\;\n\\begin{cases}\nL_{\\max}, & \\text{if } \\ell_t^{\\text{pre}} > L_{\\max},\\\n$$6pt]\n\\min\\{L_{\\text{target}}, L_{\\max}\\}, & \\text{otherwise}.\n\\end{cases}\n$$\n\n5. Solve for the post-trade price and position subject to market-clearing and the leverage target:\n$$\np_t \\;=\\; v_t \\;+\\; \\alpha q_t,\n\\qquad\np_t q_t \\;=\\; m_t W_t'.\n$$\nIf $m_t = 0$, this yields $p_t = v_t$ and $q_t = 0$. If $m_t > 0$, substitute $q_t = \\dfrac{m_t W_t'}{p_t}$ into $p_t = v_t + \\alpha q_t$ to obtain the quadratic\n$$\np_t^2 \\;-\\; v_t p_t \\;-\\; \\alpha m_t W_t' \\;=\\; 0.\n$$\nThe economically relevant positive solution is\n$$\np_t \\;=\\; \\dfrac{v_t + \\sqrt{v_t^2 + 4 \\alpha m_t W_t'}}{2},\n\\qquad\nq_t \\;=\\; \\dfrac{m_t W_t'}{p_t}.\n$$\nSet $W_t = W_t'$.\n\nInitialization. At $t=0$, the initial conditions are $p_0 = v_0$, $q_0 = 0$, and $W_0$ given.\n\nMetric. The maximum drawdown over $t \\in \\{1,2,\\dots,T\\}$ is defined by\n$$\n\\text{MDD} \\;=\\; \\max_{1 \\le t \\le T} \\left( \\dfrac{\\max_{1 \\le s \\le t} p_s - p_t}{\\max_{1 \\le s \\le t} p_s} \\right),\n$$\nwith the convention of $0$ if the denominator is $0$. Computationally, this is obtained by maintaining the running peak $\\text{peak}_t = \\max\\{\\text{peak}_{t-1}, p_t\\}$ and evaluating the running drawdown $\\text{dd}_t = \\dfrac{\\text{peak}_t - p_t}{\\text{peak}_t}$ when $\\text{peak}_t > 0$, updating the maximum across time.\n\nDeterministic test suite. For each specified tuple $(T, v_0, A, P, \\alpha, W_0, L_{\\text{target}}, L_{\\max})$, simulate the path $\\{(p_t, q_t, W_t)\\}_{t=0}^T$ deterministically by the equations above, then compute $\\text{MDD}$.\n\nFinal output. Return the five $\\text{MDD}$ values, each rounded to exactly six digits after the decimal point, in a single line as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $5$.", "answer": "```python\nimport numpy as np\n\ndef simulate_case(T, v0, A, P, alpha, W0, L_target, L_max):\n    # Initialize state\n    p_prev = v0\n    q_prev = 0.0\n    W_prev = W0\n    bankrupt = False\n\n    max_drawdown = 0.0\n    peak = -np.inf\n\n    # Simulate over t=1..T\n    for t in range(1, T + 1):\n        # Fundamental update: v_t = v0 + A * sin(2*pi*t/P), with radians\n        v_t = v0 + A * np.sin(2.0 * np.pi * t / P)\n\n        if bankrupt:\n            # After bankruptcy, agent is out: q=0, price equals fundamental\n            p_t = v_t\n            q_t = 0.0\n            W_t = 0.0\n        else:\n            # Pre-trade price given existing position\n            p_pre = v_t + alpha * q_prev\n            # Interim equity marked to pre-trade price\n            W_interim = W_prev + q_prev * (p_pre - p_prev)\n\n            if W_interim <= 0.0:\n                # Bankruptcy and exit\n                bankrupt = True\n                p_t = v_t\n                q_t = 0.0\n                W_t = 0.0\n            else:\n                # Pre-trade leverage\n                if W_interim == 0.0:\n                    L_pre = np.inf\n                else:\n                    L_pre = (p_pre * q_prev) / W_interim if W_interim > 0 else np.inf\n\n                # Determine target leverage m_t\n                if L_pre > L_max:\n                    m_t = L_max\n                else:\n                    m_t = min(L_target, L_max)\n\n                if m_t <= 0.0:\n                    # No position\n                    p_t = v_t\n                    q_t = 0.0\n                else:\n                    # Solve quadratic for p_t: p^2 - v_t p - alpha*m_t*W_interim = 0\n                    disc = v_t * v_t + 4.0 * alpha * m_t * W_interim\n                    # Numerical safeguard: ensure non-negative\n                    if disc < 0.0:\n                        disc = 0.0\n                    sqrt_disc = np.sqrt(disc)\n                    p_t = 0.5 * (v_t + sqrt_disc)\n                    # Compute q_t from leverage target\n                    if p_t <= 0.0:\n                        # Fallback if numerical issues (should not occur with given params)\n                        p_t = max(v_t, 1e-12)\n                    q_t = (m_t * W_interim) / p_t\n\n                # Post-trade equity equals interim equity (no transaction costs)\n                W_t = W_interim\n\n        # Update peak and drawdown metrics using p_t\n        if p_t > peak:\n            peak = p_t\n        if peak > 0.0:\n            dd = (peak - p_t) / peak\n            if dd > max_drawdown:\n                max_drawdown = dd\n\n        # Prepare for next period\n        p_prev = p_t\n        q_prev = q_t\n        W_prev = W_t\n\n    return max_drawdown\n\ndef solve():\n    # Define the test cases from the problem statement:\n    # Each tuple: (T, v0, A, P, alpha, W0, L_target, L_max)\n    test_cases = [\n        (200, 100.0, 5.0, 50.0, 0.8, 100.0, 0.0, 0.0),\n        (200, 100.0, 5.0, 50.0, 0.8, 100.0, 2.0, 6.0),\n        (200, 100.0, 5.0, 50.0, 0.8, 100.0, 8.0, 6.0),\n        (200, 100.0, 5.0, 50.0, 1.2, 100.0, 8.0, 6.0),\n        (200, 100.0, 5.0, 50.0, 1.2, 40.0, 8.0, 6.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        T, v0, A, P, alpha, W0, L_target, L_max = case\n        mdd = simulate_case(T, v0, A, P, alpha, W0, L_target, L_max)\n        # Round to exactly 6 decimals in the output\n        results.append(f\"{mdd:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"}]}