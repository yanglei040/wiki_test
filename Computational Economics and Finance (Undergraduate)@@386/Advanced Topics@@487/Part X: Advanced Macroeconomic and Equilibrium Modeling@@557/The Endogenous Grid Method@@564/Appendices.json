{"hands_on_practices": [{"introduction": "A deep understanding of any algorithm is best tested by the ability to debug it. This first exercise moves beyond simple implementation and challenges you to think critically about the core logic of the Endogenous Grid Method (EGM). You will be presented with a flawed EGM implementation for a classic consumption-savings model and asked to identify the error, implement a corrected version, and quantify the impact on the solution's accuracy. This practice will solidify your grasp of the fundamental role of the Euler equation in linking economic theory to numerical computation. [@problem_id:2440065]", "id": "2440065", "problem": "Consider the infinite-horizon consumption-savings problem with Constant Relative Risk Aversion (CRRA) utility. A representative agent chooses consumption $c_t$ and next-period assets $a_{t+1}$ to maximize\n$$\n\\sum_{t=0}^{\\infty} \\beta^t \\frac{c_t^{1-\\sigma}}{1-\\sigma},\n$$\nsubject to the budget constraint\n$$\na_{t+1} = m_t - c_t,\\quad m_t = R a_t + y,\\quad a_{t+1} \\ge 0,\n$$\nwhere $\\beta \\in (0,1)$ is the discount factor, $\\sigma > 0$ is the coefficient of relative risk aversion, $R > 0$ is the gross interest factor, and $y > 0$ is an exogenous constant income. The marginal utility is $u'(c) = c^{-\\sigma}$. The optimality condition away from the borrowing constraint is the Euler equation\n$$\nu'(c_t) = \\beta R u'(c_{t+1}).\n$$\n\nA common numerical method to solve for the stationary consumption policy $c(m)$ is the Endogenous Grid Method (EGM). In EGM, one fixes a grid for next period assets $a'$, computes next period cash-on-hand $m'$, evaluates next period marginal utility using the current guess of the policy, then uses the Euler equation to recover current consumption and computes the endogenous current cash-on-hand $m$, finally interpolating to obtain $c(m)$.\n\nYou are given the following broken implementation sketch of the EGM update for this one-state, no-uncertainty model. Each step is written in mathematical pseudocode, where the variables $(\\beta, R, \\sigma, y)$ are parameters, $a'$ is the exogenous grid for next period assets, $m'$ is next period cash-on-hand, and $c^{\\text{old}}(m)$ is the current policy guess as a function of $m$:\n\n- Step 1 (grid for next period assets): Choose a grid $\\{a'_i\\}_{i=1}^N$ on $[0,\\bar a]$ for some large $\\bar a > 0$.\n- Step 2 (next period resources): For each $a'_i$, compute $m'_i = R a'_i + y$.\n- Step 3 (next period marginal utility): For each $m'_i$, compute $u'(c^{\\text{old}}(m'_i)) = \\left(c^{\\text{old}}(m'_i)\\right)^{-\\sigma}$.\n- Step 4 (current consumption from Euler, BROKEN): For each $i$, set\n$$\nc^{\\text{endo}}_i = \\left(R \\cdot u'(c^{\\text{old}}(m'_i))\\right)^{-1/\\sigma}.\n$$\n- Step 5 (endogenous current resources): For each $i$, set $m^{\\text{endo}}_i = c^{\\text{endo}}_i + a'_i$.\n- Step 6 (interpolate to fixed $m$-grid): Define a fixed grid $\\{m_j\\}_{j=1}^M$ on $[y, \\bar m]$ for some large $\\bar m > 0$. For $m_j < \\min_i m^{\\text{endo}}_i$, enforce the borrowing constraint by setting $c^{\\text{new}}(m_j) = m_j$. For $m_j \\ge \\min_i m^{\\text{endo}}_i$, obtain $c^{\\text{new}}(m_j)$ by linear interpolation of the pairs $\\left(m^{\\text{endo}}_i, c^{\\text{endo}}_i\\right)$.\n\nThe broken step is Step 4. Your tasks are:\n\n1) Identify the logical error in Step 4 from first principles starting at the Euler equation and the CRRA marginal utility definition. Explain why Step 4 is incorrect and what the correct expression must be.\n\n2) Implement two solvers:\n- A \"broken\" EGM solver that uses the incorrect Step 4 above.\n- A \"corrected\" EGM solver that uses the logically corrected Step 4 you derive in part 1.\n\nBoth solvers should iterate on the consumption policy using the EGM update until convergence to a fixed point of the policy operator, or until a maximum number of iterations is reached. You must handle the borrowing constraint $a' \\ge 0$ by setting $c(m) = m$ wherever it binds. Use linear interpolation between grid points and linear extrapolation beyond the last endogenous grid point. Ensure $c(m) \\le m$ for all $m$.\n\n3) For evaluation, define the Euler residual at a given $m$ as\n$$\n\\mathcal{R}(m) = \n\\begin{cases}\n\\left|u'(c(m)) - \\beta R \\, u'\\left(c\\left(R\\left[m - c(m)\\right] + y\\right)\\right)\\right|, & \\text{if } m - c(m) > 10^{-10},\\\\\n0, & \\text{if } m - c(m) \\le 10^{-10},\n\\end{cases}\n$$\nwhich measures the absolute Euler-equation violation away from the borrowing constraint. Compute the supremum norm of the Euler residual over an evaluation grid of cash-on-hand values.\n\n4) Using your two solvers and the residual definition, run the following test suite. For each parameter set, compute the supremum Euler residual for the broken and corrected solvers on the same evaluation grid. Then output a boolean per test case that is true if and only if all of the following hold simultaneously: the corrected residual is strictly less than $10^{-5}$, the broken residual is at least $10^{-3}$, and the broken residual is at least $10$ times the corrected residual.\n\nTest suite parameter sets:\n- Case A (happy path): $\\beta = 0.96$, $R = 1.04$, $\\sigma = 2.0$, $y = 1.0$, $\\bar a = 50.0$, $N = 300$, $M = 400$.\n- Case B (more impatience and curvature): $\\beta = 0.90$, $R = 1.04$, $\\sigma = 3.0$, $y = 1.0$, $\\bar a = 50.0$, $N = 300$, $M = 400$.\n- Case C (near knife-edge $\\beta R \\approx 1$): $\\beta = 0.995$, $R = 1.004$, $\\sigma = 2.0$, $y = 1.0$, $\\bar a = 60.0$, $N = 300$, $M = 500$.\n\nUse the same stopping rule for both solvers with a maximum of $800$ iterations and a tolerance of $10^{-8}$ in the sup-norm difference between successive policy functions, employing convex damping if necessary to ensure stability.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each entry must be a boolean corresponding to Cases A, B, and C in order, as defined above. No extra whitespace or text is permitted in the output.\n\nAll answers are non-dimensional; no physical units are involved.", "solution": "The problem statement is a valid exercise in computational economics. It concerns the standard infinite-horizon consumption-savings model with Constant Relative Risk Aversion (CRRA) utility. The task is to identify and rectify a logical error in a provided sketch of the Endogenous Grid Method (EGM) algorithm, implement both the flawed and corrected versions, and compare their accuracy using the Euler equation residual. All parameters and model components are well-defined and consistent with established economic theory.\n\n**1. Identification and Correction of the Algorithmic Flaw**\n\nThe core of the dynamic optimization problem is the Euler equation, which dictates the optimal trade-off between consumption today and consumption tomorrow. For the given model, it is:\n$$\nu'(c_t) = \\beta R u'(c_{t+1})\n$$\nwhere $c_t$ is consumption in the current period and $c_{t+1}$ is consumption in the next period. The agent's utility is of the CRRA form, which implies a marginal utility function $u'(c) = c^{-\\sigma}$. Substituting this into the Euler equation yields:\n$$\nc_t^{-\\sigma} = \\beta R c_{t+1}^{-\\sigma}\n$$\nThe Endogenous Grid Method (EGM) solves for the policy function $c(m)$ by working backward from a grid of future states. In this context, $c_t$ corresponds to the endogenous current consumption we wish to find, which we denote $c^{\\text{endo}}$. The future consumption, $c_{t+1}$, is determined by the current guess of the policy function, $c^{\\text{old}}$, evaluated at next period's cash-on-hand, $m'$. Thus, $c_{t+1} = c^{\\text{old}}(m')$. The Euler equation becomes:\n$$\n(c^{\\text{endo}})^{-\\sigma} = \\beta R \\left( c^{\\text{old}}(m') \\right)^{-\\sigma}\n$$\nTo find the correct expression for today's consumption, $c^{\\text{endo}}$, we solve for it by raising both sides to the power of $-1/\\sigma$:\n$$\n\\left( (c^{\\text{endo}})^{-\\sigma} \\right)^{-1/\\sigma} = \\left( \\beta R \\left( c^{\\text{old}}(m') \\right)^{-\\sigma} \\right)^{-1/\\sigma}\n$$\n$$\nc^{\\text{endo}} = \\left( \\beta R \\right)^{-1/\\sigma} \\left( \\left(c^{\\text{old}}(m') \\right)^{-\\sigma} \\right)^{-1/\\sigma}\n$$\n$$\nc^{\\text{endo}} = \\left( \\beta R \\right)^{-1/\\sigma} c^{\\text{old}}(m')\n$$\nAlternatively, and more directly for implementation, we can write this as:\n$$\nc^{\\text{endo}} = \\left[ \\beta R \\cdot u'(c^{\\text{old}}(m')) \\right]^{-1/\\sigma}\n$$\nNow, we compare this correct derivation with the expression provided in the problem statement's Step 4:\n$$\nc^{\\text{endo}}_i = \\left(R \\cdot u'(c^{\\text{old}}(m'_i))\\right)^{-1/\\sigma} \\quad (\\text{Broken Step 4})\n$$\nThe logical error is immediately apparent: the broken step **omits the discount factor $\\beta$**.\n\nThe economic implication of this error is significant. The agent plans consumption as if they are more patient than their preferences dictate. By omitting $\\beta \\in (0,1)$, the agent effectively acts as if $\\beta=1$, failing to discount future marginal utility. This leads to an incorrect intertemporal allocation, where the agent overvalues future consumption relative to present consumption. Consequently, for any given level of future consumption, the agent using the broken rule will save more (and consume less) today compared to the truly optimal agent. This deviation from optimality will manifest as a non-zero Euler equation residual.\n\n**2. Algorithmic Implementation Strategy**\n\nTwo solvers, \"broken\" and \"corrected,\" will be implemented based on the EGM. Both will follow the same iterative procedure, differing only in the equation used in Step 4.\n\nThe algorithm for a single EGM iteration is as follows:\n1.  **Define Grids**: An exogenous grid for next-period assets, $\\{a'_i\\}_{i=1}^N$, is defined on $[0, \\bar a]$. A fixed grid for current cash-on-hand, $\\{m_j\\}_{j=1}^M$, is defined on $[y, \\bar m]$, where $\\bar m = R \\bar a + y$.\n2.  **Initial Policy**: Start with an initial guess for the consumption policy, $c^{\\text{old}}(m)$. A robust choice is $c^{\\text{old}}(m) = m$.\n3.  **Iteration Loop**: Repeat until the policy function converges.\n    a.  **Next-Period States**: For each point $a'_i$ on the asset grid, calculate the corresponding next-period cash-on-hand: $m'_i = R a'_i + y$.\n    b.  **Next-Period Consumption**: Using the current policy guess $c^{\\text{old}}$, find the consumption at each $m'_i$. This requires interpolation of $c^{\\text{old}}$ (defined on the fixed grid $\\{m_j\\}$) at the points $\\{m'_i\\}$.\n    c.  **Invert Euler Equation**: Use the Euler equation to find the current consumption, $c^{\\text{endo}}_i$, that corresponds to each $a'_i$.\n        -   **Corrected Solver**: $c^{\\text{endo}}_i = \\left[ \\beta R \\cdot (c^{\\text{old}}(m'_i))^{-\\sigma} \\right]^{-1/\\sigma}$.\n        -   **Broken Solver**: $c^{\\text{endo}}_i = \\left[ R \\cdot (c^{\\text{old}}(m'_i))^{-\\sigma} \\right]^{-1/\\sigma}$.\n    d.  **Endogenous Grid**: Construct the endogenous grid for current cash-on-hand: $m^{\\text{endo}}_i = c^{\\text{endo}}_i + a'_i$. This creates a set of pairs $(m^{\\text{endo}}_i, c^{\\text{endo}}_i)$ that satisfy the Euler equation.\n    e.  **Update Policy Function**: Construct the new policy, $c^{\\text{new}}$, on the fixed grid $\\{m_j\\}$.\n        i.  Linearly interpolate the pairs $(m^{\\text{endo}}_i, c^{\\text{endo}}_i)$ to find consumption values on the fixed grid $\\{m_j\\}$. Linear extrapolation is used for points outside the range of $\\{m^{\\text{endo}}_i\\}$.\n        ii.  Handle the borrowing constraint: For any $m_j$ below the lowest endogenous grid point ($m_j < m^{\\text{endo}}_1$), the agent is constrained and consumes all resources. Thus, set $c^{\\text{new}}(m_j) = m_j$.\n        iii. Enforce feasibility: Ensure $c^{\\text{new}}(m_j) \\le m_j$ for all $j$.\n    f.  **Convergence Check**: Calculate the supremum norm of the difference between the old and new policies, $\\max_j |c^{\\text{new}}(m_j) - c^{\\text{old}}(m_j)|$. If this difference is below a tolerance (e.g., $10^{-8}$), convergence is achieved. Otherwise, set $c^{\\text{old}} = c^{\\text{new}}$ and begin the next iteration.\n\nFor the given parameterizations, this EGM implementation is stable and does not necessitate damping.\n\n**3. Euler Residual Calculation**\n\nAfter obtaining a converged policy function $c(m)$, its accuracy is assessed by computing the supremum norm of the Euler residual, $\\mathcal{R}(m)$, across the evaluation grid $\\{m_j\\}$. For each $m_j$ on the grid:\n1.  Calculate current consumption $c_j = c(m_j)$ and next-period assets $a'_{j} = m_j - c_j$.\n2.  If the borrowing constraint is not binding ($a'_{j} > 10^{-10}$), compute next-period cash-on-hand $m'_{j} = R a'_{j} + y$ and next-period consumption $c'_{j} = c(m'_{j})$. The residual is then $|\\left(c_j\\right)^{-\\sigma} - \\beta R \\left(c'_{j}\\right)^{-\\sigma}|$.\n3.  If the constraint is binding ($a'_{j} \\le 10^{-10}$), the residual is defined as $0$.\nThe maximum of these values over all $j$ is the final error metric.\n\nThe procedure outlined above is implemented for both the broken and corrected solvers for each test case to determine the final boolean outcome.", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Solves the consumption-savings problem using both broken and corrected EGM,\n    and evaluates the results based on Euler residuals.\n    \"\"\"\n\n    def egm_solver(beta, R, sigma, y, a_bar, N, M, is_broken):\n        \"\"\"\n        Iteratively solves for the consumption policy function using the EGM.\n\n        Args:\n            beta (float): Discount factor.\n            R (float): Gross interest rate.\n            sigma (float): CRRA parameter.\n            y (float): Constant income.\n            a_bar (float): Upper bound for the asset grid.\n            N (int): Number of points in the asset grid.\n            M (int): Number of points in the cash-on-hand grid.\n            is_broken (bool): If True, uses the flawed Euler equation update.\n\n        Returns:\n            tuple: A tuple containing the cash-on-hand grid (np.ndarray) and the\n                   converged consumption policy (np.ndarray).\n        \"\"\"\n        max_iter = 800\n        tol = 1.0e-8\n\n        # Step 1: Set up grids\n        a_prime_grid = np.linspace(0.0, a_bar, N)\n        m_bar = R * a_bar + y\n        m_grid = np.linspace(y, m_bar, M)\n\n        # Initial guess for the policy function: consume everything\n        c_policy = m_grid.copy()\n\n        for _ in range(max_iter):\n            c_old_policy = c_policy.copy()\n            c_old_interp = interp1d(\n                m_grid, c_old_policy, kind='linear',\n                fill_value=\"extrapolate\", bounds_error=False\n            )\n\n            # Step 2: Next period resources\n            m_prime = R * a_prime_grid + y\n            \n            # Step 3: Next period consumption and marginal utility\n            c_at_m_prime = c_old_interp(m_prime)\n            # Ensure consumption is positive for marginal utility calculation\n            c_at_m_prime[c_at_m_prime <= 1.0e-14] = 1.0e-14\n            marg_util_at_m_prime = c_at_m_prime**(-sigma)\n\n            # Step 4: Current consumption from Euler equation (broken or correct)\n            if is_broken:\n                c_endo = (R * marg_util_at_m_prime)**(-1.0 / sigma)\n            else:\n                c_endo = (beta * R * marg_util_at_m_prime)**(-1.0 / sigma)\n\n            # Step 5: Endogenous current resources\n            m_endo = c_endo + a_prime_grid\n            \n            # Step 6: Interpolate to get new policy on the fixed m-grid\n            c_new_interp = interp1d(\n                m_endo, c_endo, kind='linear',\n                fill_value=\"extrapolate\", bounds_error=False\n            )\n            c_policy = c_new_interp(m_grid)\n\n            # Enforce borrowing constraint for m below the first endogenous point\n            borrowing_constrained = m_grid < m_endo[0]\n            c_policy[borrowing_constrained] = m_grid[borrowing_constrained]\n\n            # Enforce physical constraint c(m) <= m\n            c_policy = np.minimum(c_policy, m_grid)\n\n            # Check for convergence\n            diff = np.max(np.abs(c_policy - c_old_policy))\n            if diff < tol:\n                break\n        \n        return m_grid, c_policy\n\n    def calculate_euler_residual(policy_func, m_grid, beta, R, sigma, y):\n        \"\"\"\n        Calculates the supremum norm of the Euler equation residual.\n\n        Args:\n            policy_func (np.ndarray): The converged consumption policy.\n            m_grid (np.ndarray): The cash-on-hand grid.\n            beta, R, sigma, y (float): Model parameters.\n\n        Returns:\n            float: The max absolute Euler residual.\n        \"\"\"\n        c_interp = interp1d(\n            m_grid, policy_func, kind='linear',\n            fill_value=\"extrapolate\", bounds_error=False\n        )\n\n        c_at_m = policy_func\n        a_prime = m_grid - c_at_m\n\n        residuals = np.zeros_like(m_grid)\n        \n        # Evaluate residual only where the borrowing constraint doesn't bind\n        not_binding_mask = a_prime > 1.0e-10\n        m_eval = m_grid[not_binding_mask]\n        c_eval = c_at_m[not_binding_mask]\n        a_prime_eval = a_prime[not_binding_mask]\n\n        if m_eval.size > 0:\n            m_prime_eval = R * a_prime_eval + y\n            c_at_m_prime_eval = c_interp(m_prime_eval)\n            \n            # Ensure consumption values are positive\n            c_eval[c_eval <= 1.0e-14] = 1.0e-14\n            c_at_m_prime_eval[c_at_m_prime_eval <= 1.0e-14] = 1.0e-14\n\n            marg_util_now = c_eval**(-sigma)\n            marg_util_future = c_at_m_prime_eval**(-sigma)\n            \n            residual_values = np.abs(marg_util_now - beta * R * marg_util_future)\n            residuals[not_binding_mask] = residual_values\n\n        return np.max(residuals)\n\n    test_cases = [\n        # Case A\n        {'beta': 0.96, 'R': 1.04, 'sigma': 2.0, 'y': 1.0, 'a_bar': 50.0, 'N': 300, 'M': 400},\n        # Case B\n        {'beta': 0.90, 'R': 1.04, 'sigma': 3.0, 'y': 1.0, 'a_bar': 50.0, 'N': 300, 'M': 400},\n        # Case C\n        {'beta': 0.995, 'R': 1.004, 'sigma': 2.0, 'y': 1.0, 'a_bar': 60.0, 'N': 300, 'M': 500},\n    ]\n\n    results = []\n    for params in test_cases:\n        # Run broken solver and calculate its residual\n        m_grid_b, policy_b = egm_solver(**params, is_broken=True)\n        res_brok = calculate_euler_residual(policy_b, m_grid_b, **{k:v for k,v in params.items() if k in ['beta','R','sigma','y']})\n\n        # Run corrected solver and calculate its residual\n        m_grid_c, policy_c = egm_solver(**params, is_broken=False)\n        res_corr = calculate_euler_residual(policy_c, m_grid_c, **{k:v for k,v in params.items() if k in ['beta','R','sigma','y']})\n\n        # Evaluate the condition\n        condition_met = (res_corr < 1.0e-5) and \\\n                        (res_brok >= 1.0e-3) and \\\n                        (res_brok >= 10.0 * res_corr)\n        results.append(condition_met)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "Having mastered the core EGM logic, we now turn to applying it in a richer economic context. This practice extends the standard framework to a finite-horizon life-cycle model where agents are motivated to leave a bequest. You will learn how to modify the backward induction process by incorporating a non-trivial terminal value function, a common feature in many dynamic models. By analyzing how savings behavior changes with the strength of the bequest motive, you will gain hands-on experience in using EGM for comparative statics. [@problem_id:2440058]", "id": "2440058", "problem": "You are asked to implement the Endogenous Grid Method (EGM) for a finite-horizon, deterministic consumption-saving life-cycle model with a bequest motive at the end of life. The agent lives for $T$ consumption periods indexed by $t \\in \\{0,1,\\ldots,T-1\\}$, and faces a budget constraint $c_t + a_{t+1} = R a_t + y_t$, with $a_{t+1} \\ge \\underline{a}$ and given initial assets $a_0$. Preferences are given by\n$$\n\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T),\n$$\nwhere $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$ for $\\gamma \\ne 1$ and $\\phi(a)$ captures bequest motives. You will analyze how the bequest motive affects savings throughout the life-cycle.\n\nFundamental base and core definitions:\n- The period budget constraint is $c_t + a_{t+1} = R a_t + y_t$, where $R$ is the gross interest factor, and $y_t$ is exogenous income.\n- The borrowing constraint is $a_{t+1} \\ge \\underline{a}$ with $\\underline{a} \\in \\mathbb{R}$.\n- The agent’s objective is to choose $\\{c_t,a_{t+1}\\}_{t=0}^{T-1}$ to maximize $\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T)$ subject to the constraints.\n- The first-order conditions (Euler equations) under interior choices and no uncertainty are:\n  - For $t \\in \\{0,1,\\ldots,T-2\\}$: $u'(c_t) = \\beta R u'(c_{t+1})$.\n  - At $t = T-1$ with a terminal bequest $\\phi(a_T)$: $u'(c_{T-1}) = \\beta \\phi'(a_T)$.\n- Define the Endogenous Grid Method mapping for each $t$ by selecting a grid over $a_{t+1}$, computing $c_t$ from the Euler equation using the inverse of the marginal utility $u'(\\cdot)$, and then forming the endogenous grid for cash-on-hand $m_t = a_{t+1} + c_t$. The borrowing constraint is handled by enforcing $a_{t+1} = \\underline{a}$ when the Euler-implied choice would violate the constraint.\n\nModel specification to be implemented:\n- Preferences:\n  - $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$ with $\\gamma > 0$ and $\\gamma \\ne 1$.\n  - $\\phi(a) = \\kappa \\cdot \\frac{(a + b)^{1-\\nu} - b^{1-\\nu}}{1-\\nu}$ with $\\nu > 0$, $\\kappa \\ge 0$, and $b > 0$; hence $\\phi'(a) = \\kappa \\cdot (a+b)^{-\\nu}$.\n- Technology and income:\n  - Gross interest factor $R > 0$ is constant across $t$.\n  - Deterministic income $\\{y_t\\}_{t=0}^{T-1}$ is given.\n- Constraints:\n  - Borrowing limit $\\underline{a}$ is fixed and satisfies $\\underline{a} \\le 0$; in the test suite below it will be set to $\\underline{a} = 0$.\n- Horizon and timing:\n  - There are $T$ consumption periods. The bequest term $\\beta^{T} \\phi(a_T)$ depends on $a_T$ chosen at period $t = T-1$; there is no consumption in the terminal date beyond $t = T-1$.\n\nAlgorithmic task:\n- Use the Endogenous Grid Method to compute the policy functions $\\{c_t(m_t)\\}_{t=0}^{T-1}$ on a grid for $a_{t+1}$ at each $t$, working by backward induction.\n- At $t = T-1$, use the Euler condition $u'(c_{T-1}) = \\beta \\phi'(a_T)$ to compute endogenous $m_{T-1} = a_T + c_{T-1}$ from a grid of $a_T$. If $\\kappa = 0$ so that $\\phi'(a_T) = 0$, the interior Euler equation does not hold and the borrowing constraint binds: $a_T = \\underline{a}$ and $c_{T-1} = m_{T-1} - \\underline{a}$.\n- For $t \\le T-2$, given $c_{t+1}(\\cdot)$, compute for each grid point $a_{t+1}$ the next-period resources $m_{t+1} = R a_{t+1} + y_{t+1}$ and use $u'(c_t) = \\beta R u'(c_{t+1}(m_{t+1}))$ to obtain $c_t$, hence $m_t = a_{t+1} + c_t$. Handle the borrowing constraint by enforcing $a_{t+1} = \\underline{a}$ for low $m_t$ values as required.\n\nSimulation and analysis:\n- After computing policy functions, simulate the life-cycle path of assets and consumption starting from $a_0$ and the given income sequence to obtain $\\{a_{t+1}\\}_{t=0}^{T-1}$ and $\\{c_t\\}_{t=0}^{T-1}$. Define the period-$t$ savings as $a_{t+1}$.\n- For each parameter set in the test suite below, report the average savings across the life-cycle,\n$$\n\\bar{s} = \\frac{1}{T} \\sum_{t=0}^{T-1} a_{t+1},\n$$\nas a real number.\n\nTest suite:\nUse the following common elements across all tests:\n- Horizon $T = 5$.\n- Interest factor $R = 1.03$.\n- Discount factor $\\beta$ will vary by test case as specified below.\n- Relative risk aversion for consumption $\\gamma = 2$.\n- Bequest curvature $\\nu = 2$.\n- Bequest shift $b = 0.01$.\n- Borrowing limit $\\underline{a} = 0$.\n- Initial assets $a_0 = 0$.\n- Deterministic income sequence $\\{y_t\\}_{t=0}^{4} = \\{1.0, 1.0, 0.8, 0.6, 0.5\\}$.\n\nDefine four test cases that vary the bequest strength $\\kappa$ and intertemporal discount factor $\\beta$:\n1. Case A (baseline, no bequest): $\\kappa = 0.0$, $\\beta = 0.96$.\n2. Case B (moderate bequest): $\\kappa = 0.5$, $\\beta = 0.96$.\n3. Case C (strong bequest): $\\kappa = 2.0$, $\\beta = 0.96$.\n4. Case D (moderate bequest, more impatience): $\\kappa = 0.5$, $\\beta = 0.90$.\n\nNumerical requirements:\n- Implement the Endogenous Grid Method with a grid over $a_{t+1}$ of at least $200$ evenly spaced points on $[\\underline{a}, a_{\\max}]$, where $a_{\\max}$ is large enough to avoid truncation of optimal choices. In your program, choose a fixed $a_{\\max}$ that is numerically adequate for all test cases.\n- Use linear interpolation to evaluate $c_{t+1}(m_{t+1})$ off-grid.\n- When $m_{t+1}$ or $m_t$ fall below the smallest endogenous cash-on-hand value implied by the Euler equation, impose the borrowing constraint $a_{t+1} = \\underline{a}$ so that $c_t = m_t - \\underline{a}$.\n\nFinal output specification:\n- For each test case, compute $\\bar{s}$ as defined above and return a list of these four real numbers in order $[\\bar{s}_A, \\bar{s}_B, \\bar{s}_C, \\bar{s}_D]$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,x_3,x_4]$). No additional text should be printed.\n- No physical units arise in this problem. All numerical outputs must be real numbers in decimal representation.", "solution": "The user has provided a scientifically valid and well-posed problem from the field of computational economics. The task is to solve a finite-horizon, deterministic consumption-saving life-cycle model using the Endogenous Grid Method (EGM) and analyze the impact of a bequest motive on savings. I will proceed with a complete solution.\n\nThe agent's objective is to maximize life-cycle utility, given by:\n$$\n\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T)\n$$\nThe utility from consumption is of the Constant Relative Risk Aversion (CRRA) form, $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$, which implies a marginal utility of $u'(c) = c^{-\\gamma}$. The inverse marginal utility function is therefore $(u')^{-1}(x) = x^{-1/\\gamma}$. The bequest motive is captured by the terminal value function $\\phi(a_T)$, with marginal utility $\\phi'(a_T) = \\kappa (a_T+b)^{-\\nu}$.\n\nThe agent faces a budget constraint in each period $t$: $c_t + a_{t+1} = R a_t + y_t$, where $m_t = R a_t + y_t$ is the cash-on-hand. There is a borrowing limit $a_{t+1} \\ge \\underline{a}$.\n\nThe problem is solved by backward induction using the Endogenous Grid Method. The core of the method is to use the first-order conditions (Euler equations) to construct the policy function for consumption, $c_t(m_t)$, from the end of life backwards to the beginning.\n\nThe Euler equations are:\n1.  For periods $t \\in \\{0, 1, \\ldots, T-2\\}$: $u'(c_t) = \\beta R u'(c_{t+1})$.\n2.  For the final consumption period $t = T-1$: $u'(c_{T-1}) = \\beta \\phi'(a_T)$.\n\nThe solution proceeds in three main stages: construction of the policy function in the final period, backward iteration to construct policy functions for all prior periods, and forward simulation to find the life-cycle path and average savings.\n\n**1. Policy Function in the Terminal Period ($t=T-1$)**\n\nThe EGM starts from an exogenous grid of post-decision states. For period $t=T-1$, this is a grid for end-of-life assets, $\\{a_{T,i}\\}_{i=1}^N$, over the interval $[\\underline{a}, a_{\\max}]$.\n\n- **Case with Bequest Motive ($\\kappa > 0$):**\n  The terminal Euler equation $u'(c_{T-1}) = \\beta \\phi'(a_T)$ is used. Substituting the functional forms, we get $c_{T-1}^{-\\gamma} = \\beta \\kappa (a_T+b)^{-\\nu}$. Solving for consumption $c_{T-1}$ for each point $a_{T,i}$ on our grid:\n  $$\n  c_{T-1,i} = \\left( \\beta \\kappa (a_{T,i}+b)^{-\\nu} \\right)^{-1/\\gamma}\n  $$\n  With $c_{T-1,i}$ and $a_{T,i}$ known, we find the corresponding pre-decision state (cash-on-hand) on an endogenous grid: $m_{T-1,i} = a_{T,i} + c_{T-1,i}$. This gives us a set of pairs $(m_{T-1,i}, c_{T-1,i})$ defining the consumption policy for unconstrained agents.\n\n- **Case without Bequest Motive ($\\kappa = 0$):**\n  If $\\kappa=0$, then $\\phi'(a_T)=0$. The Euler equation $c_{T-1}^{-\\gamma} = 0$ would imply infinite consumption, which is infeasible. The agent's optimal choice is to consume all available resources, hitting the borrowing limit. Thus, $a_T = \\underline{a}$ and the policy function is simply $c_{T-1}(m_{T-1}) = m_{T-1} - \\underline{a}$.\n\n**2. Policy Function in Pre-terminal Periods ($t < T-1$)**\n\nWe iterate backward from $t=T-2$ to $t=0$. For each period $t$, we assume the policy function for the next period, $c_{t+1}(m_{t+1})$, is known (represented by the grids computed in the previous step).\n\n1.  Start with an exogenous grid for savings, $\\{a_{t+1,i}\\}_{i=1}^N$, over $[\\underline{a}, a_{\\max}]$.\n2.  For each grid point $a_{t+1,i}$, calculate the cash-on-hand in the next period: $m_{t+1,i} = R a_{t+1,i} + y_{t+1}$.\n3.  Evaluate the known policy function $c_{t+1}(m_{t+1,i})$ to find next-period consumption, $c_{t+1,i}$. This is done via linear interpolation on the stored policy grid for period $t+1$.\n4.  Use the intertemporal Euler equation, $u'(c_t) = \\beta R u'(c_{t+1})$, to work backward to current consumption, $c_{t,i}$. For CRRA utility, this simplifies nicely:\n    $$\n    c_{t,i}^{-\\gamma} = \\beta R c_{t+1,i}^{-\\gamma} \\implies c_{t,i} = (\\beta R)^{-1/\\gamma} c_{t+1,i}\n    $$\n5.  Construct the endogenous grid for cash-on-hand: $m_{t,i} = a_{t+1,i} + c_{t,i}$.\n    This yields the pairs $(m_{t,i}, c_{t,i})$ that define the policy for unconstrained agents in period $t$.\n\n**3. Handling the Borrowing Constraint**\n\nThe EGM procedure naturally generates the policy for unconstrained choices. For agents with low cash-on-hand, the borrowing constraint $a_{t+1} \\ge \\underline{a}$ will bind. Their consumption is $c_t = m_t - \\underline{a}$.\nThe EGM grid begins with $a_{t+1,1} = \\underline{a}$. This corresponds to a point $(m_{t,1}, c_{t,1})$ which forms the \"kink\" between the constrained and unconstrained regions. The policy is continuous at this point. To create a full numerical policy function, we prepend the point $(\\underline{a}, 0)$ to the EGM-generated grids $(m_{t,i}, c_{t,i})$. Linear interpolation between $(\\underline{a}, 0)$ and $(m_{t,1}, c_{t,1})$ correctly reproduces the linear policy $c_t = m_t - \\underline{a}$ in the constrained region, as $m_{t,1} = \\underline{a} + c_{t,1}$.\n\n**4. Simulation and Calculation of Average Savings**\n\nWith all policy functions $\\{c_t(m_t)\\}_{t=0}^{T-1}$ computed, we simulate the agent's life-cycle path forward in time.\n1.  Start with initial assets $a_0$.\n2.  For $t = 0, \\ldots, T-1$:\n    -   Calculate cash-on-hand: $m_t = R a_t + y_t$.\n    -   Determine consumption by interpolating on the stored policy grid: $c_t = c_t(m_t)$.\n    -   Determine savings for the next period from the budget constraint: $a_{t+1} = m_t - c_t$.\n3.  The simulation yields the path of savings $\\{a_1, a_2, \\ldots, a_T\\}$. The final metric is the average of these values:\n    $$\n    \\bar{s} = \\frac{1}{T} \\sum_{t=0}^{T-1} a_{t+1}\n    $$\nThe implementation will perform these steps for each of the four test cases specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the life-cycle model for all test cases and print the results.\n    \"\"\"\n    \n    # Define common parameters across all test cases\n    T = 5\n    R = 1.03\n    gamma = 2.0\n    nu = 2.0\n    b = 0.01\n    underline_a = 0.0\n    a0 = 0.0\n    income = np.array([1.0, 1.0, 0.8, 0.6, 0.5])\n    \n    # Numerical parameters for the Endogenous Grid Method\n    grid_size = 200\n    a_max = 20.0\n    \n    # Define the four test cases by varying bequest strength (kappa) and discount factor (beta)\n    test_cases = [\n        # (kappa, beta)\n        (0.0, 0.96),  # Case A: No bequest motive\n        (0.5, 0.96),  # Case B: Moderate bequest motive\n        (2.0, 0.96),  # Case C: Strong bequest motive\n        (0.5, 0.90),  # Case D: Moderate bequest, more impatient\n    ]\n\n    results = []\n    # Solve the model for each case and store the average savings\n    for kappa, beta in test_cases:\n        avg_savings = solve_one_case(T, R, gamma, nu, b, underline_a, a0, income, \n                                     grid_size, a_max, kappa, beta)\n        results.append(avg_savings)\n\n    # Print the results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_one_case(T, R, gamma, nu, b, underline_a, a0, income, grid_size, a_max, kappa, beta):\n    \"\"\"\n    Solves the life-cycle model for a single set of parameters using EGM.\n\n    Returns:\n        float: The average savings over the agent's life-cycle.\n    \"\"\"\n    # Exogenous grid for post-decision assets (a_{t+1})\n    a_grid = np.linspace(underline_a, a_max, grid_size)\n    \n    # Dictionary to store the computed policy functions (m_grid, c_grid) for each period\n    policy_functions = {}\n    \n    # --- Backward Induction: Solve for policy functions from T-1 to 0 ---\n    \n    # Period t = T-1 (the final consumption period)\n    t = T - 1\n    if kappa == 0.0:\n        # No bequest motive: agent consumes everything, so a_T = underline_a.\n        # The policy is c_{T-1} = m_{T-1} - underline_a.\n        # We represent this linear policy on a grid for consistency with other periods.\n        # A simple two-point grid is sufficient for linear interpolation.\n        m_grid_t = np.array([underline_a, a_max * R + np.max(income)])\n        c_grid_t = m_grid_t - underline_a\n    else:\n        # With bequest motive, use the terminal Euler equation: u'(c_{T-1}) = beta * phi'(a_T)\n        # Here, a_grid represents the grid for a_T.\n        a_T = a_grid\n        phi_p = kappa * (a_T + b)**(-nu)\n        # Avoid division by zero or negative base if phi_p <= 0\n        c_endo_t = np.full_like(a_T, 1e-10) # a small positive value for consumption\n        positive_phi_p_mask = phi_p > 0\n        c_endo_t[positive_phi_p_mask] = (beta * phi_p[positive_phi_p_mask])**(-1.0 / gamma)\n\n        # Compute the endogenous grid for cash-on-hand: m_{T-1} = a_T + c_{T-1}\n        m_endo_t = a_T + c_endo_t\n\n        # Combine with the borrowing-constrained region to form the full policy function.\n        # The constrained policy c = m - underline_a is represented by the point (underline_a, 0).\n        m_grid_t = np.concatenate(([underline_a], m_endo_t))\n        c_grid_t = np.concatenate(([0.0], c_endo_t))\n        \n    policy_functions[t] = (m_grid_t, c_grid_t)\n    \n    # Periods t = T-2 down to 0\n    for t in range(T - 2, -1, -1):\n        m_grid_t_plus_1, c_grid_t_plus_1 = policy_functions[t + 1]\n        \n        # Here, a_grid represents the grid for a_{t+1}\n        a_t_plus_1 = a_grid\n        \n        # 1. Calculate next-period cash-on-hand for each point on the a_{t+1} grid\n        m_t_plus_1 = R * a_t_plus_1 + income[t + 1]\n        \n        # 2. Interpolate on the next-period policy function to find c_{t+1}\n        c_t_plus_1 = np.interp(m_t_plus_1, m_grid_t_plus_1, c_grid_t_plus_1)\n        \n        # 3. Use the intertemporal Euler equation to find current consumption c_t\n        # For CRRA utility, this simplifies to c_t = (beta * R)^(-1/gamma) * c_{t+1}\n        c_endo_t = (beta * R)**(-1.0 / gamma) * c_t_plus_1\n        \n        # 4. Compute the endogenous grid for cash-on-hand m_t\n        m_endo_t = a_t_plus_1 + c_endo_t\n        \n        # Add the borrowing-constrained region\n        m_grid_t = np.concatenate(([underline_a], m_endo_t))\n        c_grid_t = np.concatenate(([0.0], c_endo_t))\n        \n        policy_functions[t] = (m_grid_t, c_grid_t)\n        \n    # --- Forward Simulation: Calculate the life-cycle path of assets ---\n    \n    a_path = np.zeros(T + 1)\n    a_path[0] = a0\n    \n    for t in range(T):\n        # Calculate current period's cash-on-hand\n        m_t = R * a_path[t] + income[t]\n        \n        # Get the policy function for the current period\n        m_grid_t, c_grid_t = policy_functions[t]\n        \n        # Evaluate the policy function to get consumption\n        c_t = np.interp(m_t, m_grid_t, c_grid_t)\n        \n        # Calculate next period's assets from the budget constraint\n        a_path[t + 1] = m_t - c_t\n        \n    # The problem defines savings as {a_1, ..., a_T}.\n    # Calculate the average of these savings.\n    avg_savings = np.mean(a_path[1:])\n    \n    return avg_savings\n\n# Execute the main function when the script is run\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "Our final practice demonstrates the true power and flexibility of the Endogenous Grid Method. We tackle an infinite-horizon model where the agent makes a simultaneous, endogenous choice of labor supply alongside consumption and savings. This requires carefully combining the intertemporal Euler equation with an intratemporal first-order condition. This exercise challenges you to generalize the EGM algorithm to handle multiple continuous choices and provides insight into solving more complex, realistic dynamic stochastic general equilibrium (DSGE) models. [@problem_id:2440090]", "id": "2440090", "problem": "Consider a representative agent who solves an infinite-horizon deterministic consumption-savings problem with a within-period labor choice. Time is discrete, indexed by $t \\in \\{0,1,2,\\dots\\}$. Beginning-of-period wealth is $a_t \\in [\\underline{a},\\overline{a}]$. The agent chooses consumption $c_t \\ge 0$, next period’s assets $a_{t+1} \\ge \\underline{a}$, and labor supply $l_t \\in [0,\\overline{l}]$ each period.\n\nPreferences are given by\n$$\n\\sum_{t=0}^{\\infty} \\beta^t \\left( \\frac{c_t^{1-\\sigma}-1}{1-\\sigma} - \\chi \\frac{l_t^{1+\\varphi}}{1+\\varphi} \\right),\n$$\nwhere $\\beta \\in (0,1)$ is the discount factor, $\\sigma > 0$ is the coefficient of relative risk aversion, $\\chi > 0$ scales the disutility of labor, and $\\varphi > 0$ is the Frisch elasticity parameter. The budget constraint is\n$$\nc_t + a_{t+1} = R a_t + w l_t,\n$$\nwhere $R > 0$ is the gross return factor and $w > 0$ is the wage rate, both constant over time. The borrowing constraint is $a_{t+1} \\ge \\underline{a}$, with $\\underline{a} \\in \\mathbb{R}$, and the labor bound is $0 \\le l_t \\le \\overline{l}$, with $\\overline{l} > 0$.\n\nYour task is to implement the Endogenous Grid Method (Endogenous Grid Method (EGM)) to compute the stationary policy function for consumption as a function of beginning-of-period wealth, using the envelope condition for the marginal value of wealth. You must proceed from fundamental dynamic programming principles and first-order conditions, and you must not assume any “shortcut” formulas as given. In particular:\n\n- Start from the Bellman equation and the fundamental Euler and intratemporal optimality conditions derived from the Lagrangian formulation.\n- Use the envelope condition to express the marginal value of beginning-of-period wealth in terms of within-period marginal utility and the gross return, and use this to construct the endogenous grid mapping that avoids root-finding on consumption along interior regions.\n- Correctly handle the borrowing constraint $a_{t+1} \\ge \\underline{a}$ by solving the within-period static problem at the constraint when it binds. In that constrained region, you must use the intratemporal first-order condition and the budget constraint to determine the pair $(c_t,l_t)$ given $a_t$ and $a_{t+1}=\\underline{a}$; if the intratemporal condition has no interior solution within $[0,\\overline{l}]$, you must set $l_t$ at the nearest bound in $[0,\\overline{l}]$ and recover $c_t$ from the budget constraint.\n- When $l_t$ is interior, the intratemporal condition is\n$$\nu_c(c_t,l_t) \\cdot w = v_l(c_t,l_t),\n$$\nfor $u_c(c_t,l_t) = \\frac{\\partial}{\\partial c} \\left( \\frac{c^{1-\\sigma}-1}{1-\\sigma} - \\chi \\frac{l^{1+\\varphi}}{1+\\varphi} \\right) = c^{-\\sigma}$ and $v_l(c_t,l_t) = \\frac{\\partial}{\\partial l} \\left( \\chi \\frac{l^{1+\\varphi}}{1+\\varphi} \\right) = \\chi l^{\\varphi}$.\n\nImplement an iterative EGM algorithm on a discrete asset grid to compute the stationary consumption policy. Then, assess the quality of the numerical solution by reporting the maximum Euler equation residual over the asset grid:\n- At interior points where $a_{t+1} > \\underline{a}$ and $l_t \\in (0,\\overline{l})$, compute the absolute value of\n$$\nu_c(c_t,l_t) - \\beta R \\, u_c(c_{t+1},l_{t+1}).\n$$\n- At points where the borrowing constraint binds, compute the inequality residual as the nonnegative part of\n$$\nu_c(c_t,l_t) - \\beta R \\, u_c(c_{t+1},l_{t+1}).\n$$\nAggregate the residuals by taking the maximum over the asset grid.\n\nTest Suite. Your program must run the EGM solver and report the maximum Euler residual (a single real number) for each of the following parameter sets. All parameters are dimensionless. Use the same asset grid and convergence tolerances across all cases. The four parameter sets are:\n\n- Case $1$: $\\beta = 0.96$, $\\sigma = 2.0$, $\\chi = 1.0$, $\\varphi = 1.0$, $R = 1.03$, $w = 1.0$, $\\underline{a} = 0.0$, $\\overline{a} = 20.0$, $\\overline{l} = 1.0$.\n- Case $2$: $\\beta = 0.96$, $\\sigma = 2.0$, $\\chi = 3.0$, $\\varphi = 1.0$, $R = 1.03$, $w = 1.0$, $\\underline{a} = 0.0$, $\\overline{a} = 20.0$, $\\overline{l} = 1.0$.\n- Case $3$: $\\beta = 0.96$, $\\sigma = 2.0$, $\\chi = 1.0$, $\\varphi = 1.0$, $R = 1.04$, $w = 0.5$, $\\underline{a} = 0.0$, $\\overline{a} = 20.0$, $\\overline{l} = 1.0$.\n- Case $4$: $\\beta = 0.96$, $\\sigma = 2.0$, $\\chi = 0.2$, $\\varphi = 1.0$, $R = 1.02$, $w = 1.0$, $\\underline{a} = 0.0$, $\\overline{a} = 20.0$, $\\overline{l} = 1.0$.\n\nNumerical and algorithmic requirements:\n- Use a uniform grid for $a$ with at least $200$ points on $[\\underline{a},\\overline{a}]$ and a uniform grid for $a'$ with at least $200$ points on $[\\underline{a},\\overline{a}]$.\n- Use a fixed-point iteration on the consumption policy with a convergence tolerance no larger than $10^{-8}$ in the sup norm.\n- When necessary, use robust root-finding for the intratemporal condition under the borrowing constraint using only simple methods such as bisection on $[0,\\overline{l}]$.\n- To avoid division by zero, enforce a strictly positive lower bound on consumption no larger than $10^{-8}$ whenever evaluating marginal utilities.\n\nFinal Output Format. Your program should produce a single line of output containing the four maximum Euler residuals for the cases above as a comma-separated list enclosed in square brackets, with each residual rounded to exactly $6$ decimal places, in the order of the cases as listed above (for example, $[0.000123,0.000456,0.000789,0.000012]$). No other text should be printed.", "solution": "The problem requires the computation of a stationary consumption policy for an infinite-horizon consumption-savings model with endogenous labor supply. The specified method is the Endogenous Grid Method (EGM), which is known for its efficiency and stability. The solution will be derived from first principles of dynamic programming.\n\nThe agent's problem is to solve the Bellman equation:\n$$\nV(a_t) = \\max_{c_t, l_t, a_{t+1}} \\left\\{ \\frac{c_t^{1-\\sigma}-1}{1-\\sigma} - \\chi \\frac{l_t^{1+\\varphi}}{1+\\varphi} + \\beta V(a_{t+1}) \\right\\}\n$$\nsubject to the budget constraint $c_t + a_{t+1} = R a_t + w l_t$, and the constraints $c_t \\ge 0$, $a_{t+1} \\ge \\underline{a}$, and $l_t \\in [0, \\overline{l}]$. We denote the single-period utility function as $u(c_t, l_t) = \\frac{c_t^{1-\\sigma}-1}{1-\\sigma} - \\chi \\frac{l_t^{1+\\varphi}}{1+\\varphi}$.\n\nFirst, we derive the necessary first-order conditions (FOCs) for an interior solution by setting up the Lagrangian for the period-$t$ problem:\n$$\n\\mathcal{L} = u(c_t, l_t) + \\beta V(a_{t+1}) - \\lambda_t (c_t + a_{t+1} - R a_t - w l_t)\n$$\nThe FOCs with respect to the control variables $c_t$, $l_t$, and $a_{t+1}$ are:\n$1$. $\\frac{\\partial \\mathcal{L}}{\\partial c_t} = u_c(c_t, l_t) - \\lambda_t = 0 \\implies c_t^{-\\sigma} = \\lambda_t$\n$2$. $\\frac{\\partial \\mathcal{L}}{\\partial l_t} = u_l(c_t, l_t) + \\lambda_t w = 0 \\implies -\\chi l_t^{\\varphi} + \\lambda_t w = 0$\n$3$. $\\frac{\\partial \\mathcal{L}}{\\partial a_{t+1}} = \\beta V'(a_{t+1}) - \\lambda_t = 0$\n\nCombining conditions ($1$) and ($2$) yields the intratemporal optimality condition, which links consumption and labor within a single period:\n$$\nc_t^{-\\sigma} w = \\chi l_t^{\\varphi}\n$$\nThis equation implies an optimal labor supply for a given level of consumption, $l_t^*(c_t)$. Considering the labor supply bounds, the policy for $l_t$ is:\n$$\nl_t(c_t) = \\min\\left( \\left( \\frac{w}{\\chi} c_t^{-\\sigma} \\right)^{1/\\varphi}, \\overline{l} \\right)\n$$\nsince labor cannot be negative.\n\nNext, we use the Envelope Theorem to find the derivative of the value function, $V'(a_t)$:\n$$\nV'(a_t) = \\frac{\\partial \\mathcal{L}}{\\partial a_t} \\bigg|_{\\text{optimal choices}} = \\lambda_t R\n$$\nSubstituting $\\lambda_t = u_c(c_t, l_t) = c_t^{-\\sigma}$ gives the envelope condition:\n$$\nV'(a_t) = R c_t^{-\\sigma}\n$$\nBy advancing the time index by one, we have $V'(a_{t+1}) = R c_{t+1}^{-\\sigma}$.\nFinally, combining FOC ($3$) with the envelope condition gives the intertemporal Euler equation:\n$$\n\\lambda_t = \\beta V'(a_{t+1}) \\implies c_t^{-\\sigma} = \\beta R c_{t+1}^{-\\sigma}\n$$\nThis equation is the foundation of the EGM algorithm.\n\nThe EGM algorithm proceeds iteratively to find a fixed point for the stationary consumption policy function $c(a)$. Let $c_k(a)$ be the guess for the policy function at iteration $k$.\n\n**Step 1: The EGM Backward Step (Unconstrained Agents)**\nInstead of fixing current assets $a_t$ and finding optimal $c_t$, we fix next period's assets $a_{t+1}$ and find the corresponding $a_t$ and $c_t$. We select a grid of points for $a_{t+1}$, which we take to be the predefined exogenous asset grid, $A_{grid}$.\nFor each $a_{t+1} \\in A_{grid}$:\n- We find the corresponding next-period consumption using our current policy guess: $c_{t+1} = c_k(a_{t+1})$.\n- We use the Euler equation to find the current-period consumption $c_t$ that would lead to this choice:\n$$\nc_t^{-\\sigma} = \\beta R (c_k(a_{t+1}))^{-\\sigma} \\implies c_t = (\\beta R)^{-1/\\sigma} c_k(a_{t+1})\n$$\n- With $c_t$ determined, we find the corresponding optimal labor supply $l_t$ from the intratemporal condition:\n$$\nl_t = \\min\\left( \\left( \\frac{w}{\\chi} c_t^{-\\sigma} \\right)^{1/\\varphi}, \\overline{l} \\right)\n$$\n- Finally, we use the budget constraint to find the current asset level $a_t$ that is consistent with these choices. This level of $a_t$ forms our \"endogenous grid\":\n$$\na_t = \\frac{1}{R} (c_t + a_{t+1} - w l_t)\n$$\nThis procedure gives us a set of pairs $(a_t, c_t)$ that lie on the new policy function, $c_{k+1}$.\n\n**Step 2: Interpolation**\nThe endogenous grid of $a_t$ values will not match our predefined exogenous grid $A_{grid}$. To obtain the policy function $c_{k+1}(a)$ on $A_{grid}$, we linearly interpolate the set of pairs $(a_t, c_t)$ computed in Step $1$.\n\n**Step 3: Handling the Borrowing Constraint**\nThe EGM procedure above applies only to agents who are making an interior choice for $a_{t+1}$. Agents with very low asset holdings $a_t$ will be constrained and forced to choose $a_{t+1} = \\underline{a}$. This occurs for asset levels $a_t$ below the lowest point on the endogenous grid computed in Step $1$ (which corresponds to choosing $a_{t+1}=\\underline{a}$). For these constrained agents, we must solve their optimization problem directly.\nFor a given $a_t$, we set $a_{t+1} = \\underline{a}$. The agent's problem reduces to a static choice of $l_t$ to maximize utility, subject to the budget constraint which now determines consumption: $c_t = R a_t + w l_t - \\underline{a}$.\nThe problem is:\n$$\n\\max_{l_t \\in [0, \\overline{l}]} \\left\\{ u(R a_t + w l_t - \\underline{a}, l_t) \\right\\}\n$$\nThe FOC for an interior solution for $l_t$ is:\n$$\n(R a_t + w l_t - \\underline{a})^{-\\sigma} w = \\chi l_t^{\\varphi}\n$$\nThis is a nonlinear equation in $l_t$ which can be solved using a root-finding algorithm like bisection. The solution must respect the bounds $[0, \\overline{l}]$ and the constraint that consumption must be positive. If the equation has no solution inside $(0, \\overline{l})$, the optimum lies at one of the boundaries. Once the optimal $l_t$ is found, the corresponding $c_t$ is determined by the budget constraint.\n\n**Step 4: Iteration and Convergence**\nWe combine the policy function for the constrained region (Step $3$) and the unconstrained region (Step $2$) to form the complete new policy guess, $c_{k+1}(a)$. We then compute the maximum absolute difference between $c_{k+1}(a)$ and $c_k(a)$ across the grid $A_{grid}$. If this difference is below a specified tolerance, the algorithm has converged. Otherwise, we set $c_k \\leftarrow c_{k+1}$ and repeat from Step $1$.\n\n**Step 5: Euler Equation Residual Calculation**\nAfter convergence to a stationary policy $c(a)$, we assess its accuracy by computing the Euler equation residuals. For each $a_t$ on the grid, we compute:\n- Current choices: $c_t = c(a_t)$ and $l_t = l(c_t)$.\n- Next-period assets: $a_{t+1} = R a_t + w l_t - c_t$.\n- Next-period choices: $c_{t+1} = c(a_{t+1})$ (using interpolation) and $l_{t+1} = l(c_{t+1})$.\nThe residual is then calculated as:\n- $|c_t^{-\\sigma} - \\beta R c_{t+1}^{-\\sigma}|$ if $a_{t+1} > \\underline{a}$ (unconstrained).\n- $\\max(0, c_t^{-\\sigma} - \\beta R c_{t+1}^{-\\sigma})$ if $a_{t+1} \\le \\underline{a}$ (constrained).\nThe maximum of these residuals over the entire asset grid $A_{grid}$ is reported as the final measure of accuracy.", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Main function to solve the consumption-savings problem for four test cases\n    and print the formatted results.\n    \"\"\"\n\n    def _bisection(f, a, b, tol=1e-10, max_iter=100):\n        \"\"\"A simple bisection root-finder.\"\"\"\n        fa = f(a)\n        for _ in range(max_iter):\n            mid = a + 0.5 * (b - a)\n            if (b - a) * 0.5 < tol:\n                return mid\n            fmid = f(mid)\n            if np.sign(fmid) == np.sign(fa):\n                a = mid\n                fa = fmid\n            else:\n                b = mid\n        return (a + b) / 2.0\n\n    def _solve_l_constrained(a_t, params):\n        \"\"\"\n        Solves for the optimal labor supply l_t for a borrowing-constrained agent.\n        The choice of next-period asset is fixed at a_min.\n        \"\"\"\n        beta, sigma, chi, phi, R, w, a_min, a_max, l_max = params\n        c_min_val = 1e-8\n\n        def foc_l(l, current_a):\n            \"\"\"The first-order condition for labor choice.\"\"\"\n            cons = R * current_a + w * l - a_min\n            if cons <= 0:\n                return 1e12  # Effectively infinite marginal utility of consumption\n            \n            marginal_utility_c = cons**(-sigma)\n            \n            if l <= 0:\n                # With phi > 0, marginal disutility of labor at l=0 is 0.\n                marginal_disutility_l = 0\n            else:\n                marginal_disutility_l = chi * l**phi\n            \n            return marginal_utility_c * w - marginal_disutility_l\n\n        # Check consumption at l=0. If not positive, agent must work.\n        cons_at_zero_l = R * a_t - a_min\n        if cons_at_zero_l <= c_min_val:\n            # Agent must work to survive (c > 0). Find the minimum required labor.\n            l_lower_bound = (a_min - R * a_t + c_min_val) / w if w > 0 else l_max\n            l_search_min = min(max(0, l_lower_bound), l_max)\n\n            if l_search_min >= l_max:\n                return l_max\n\n            # If FOC is positive at l_max, l_max is the solution.\n            if foc_l(l_max, a_t) >= 0:\n                return l_max\n            \n            # Otherwise, find the root between the minimum required labor and l_max.\n            return _bisection(lambda l: foc_l(l, a_t), l_search_min, l_max)\n        else:\n            # Agent can survive without working. Interior solution for l is possible.\n            # If FOC is negative at l=0, l=0 is optimal.\n            if foc_l(0, a_t) <= 0:\n                return 0.0\n            \n            # If FOC is positive at l_max, l_max is optimal.\n            if foc_l(l_max, a_t) >= 0:\n                return l_max\n                \n            # Otherwise, find interior solution between 0 and l_max.\n            return _bisection(lambda l: foc_l(l, a_t), 0.0, l_max)\n\n    def compute_policy_and_residual(params):\n        \"\"\"\n        Computes the stationary policy functions and the max Euler residual\n        for a given set of parameters.\n        \"\"\"\n        beta, sigma, chi, phi, R, w, a_min, a_max, l_max = params\n        \n        # Numerical parameters\n        N_a = 200\n        tol = 1e-9\n        c_min_val = 1e-8\n\n        # Grids\n        a_grid = np.linspace(a_min, a_max, N_a)\n        \n        # Initial guess for consumption policy\n        c_policy = (R - 1) * a_grid + w * l_max / 2  # A simple guess\n\n        # Policy function iteration loop\n        max_iter = 1000\n        for it in range(max_iter):\n            c_old = c_policy.copy()\n            c_interp = interp1d(a_grid, c_old, kind='linear', fill_value='extrapolate')\n\n            # EGM Step for unconstrained region\n            a_prime_grid = a_grid  # Choices for a_t+1 are on the grid\n            c_prime = c_interp(a_prime_grid)\n            c_prime = np.maximum(c_min_val, c_prime)\n            \n            mu_prime = c_prime**(-sigma)\n            mu_curr = beta * R * mu_prime\n            c_endog = mu_curr**(-1.0/sigma)\n            \n            l_endog = (w/chi * c_endog**(-sigma))**(1.0/phi)\n            l_endog = np.minimum(l_endog, l_max)\n            \n            a_endog = (c_endog + a_prime_grid - w * l_endog) / R\n\n            # Combine constrained and unconstrained regions\n            c_policy = np.zeros_like(a_grid)\n            \n            # Identify constrained region\n            a_bind_threshold = a_endog[0]\n            constrained_mask = a_grid < a_bind_threshold\n\n            # Solve for constrained agents\n            a_constrained = a_grid[constrained_mask]\n            l_constrained = np.array([_solve_l_constrained(a, params) for a in a_constrained])\n            c_constrained = R * a_constrained + w * l_constrained - a_min\n            c_policy[constrained_mask] = c_constrained\n\n            # Interpolate for unconstrained agents\n            unconstrained_mask = ~constrained_mask\n            if np.any(unconstrained_mask):\n                c_unconstrained_interp = interp1d(a_endog, c_endog, kind='linear', fill_value='extrapolate')\n                c_policy[unconstrained_mask] = c_unconstrained_interp(a_grid[unconstrained_mask])\n            \n            c_policy = np.maximum(c_min_val, c_policy)\n\n            # Check for convergence\n            diff = np.max(np.abs(c_policy - c_old))\n            if diff < tol:\n                break\n\n        # Post-convergence: Calculate Euler residuals\n        c_final_interp = interp1d(a_grid, c_policy, kind='linear', fill_value='extrapolate')\n        \n        c_t = c_policy\n        l_t = (w/chi * np.maximum(c_t, c_min_val)**(-sigma))**(1.0/phi)\n        l_t = np.minimum(l_t, l_max)\n\n        a_t_plus_1 = R * a_grid + w * l_t - c_t\n        \n        c_t_plus_1 = c_final_interp(a_t_plus_1)\n        c_t_plus_1 = np.maximum(c_min_val, c_t_plus_1)\n        \n        mu_t = np.maximum(c_t, c_min_val)**(-sigma)\n        mu_t_plus_1 = np.maximum(c_t_plus_1, c_min_val)**(-sigma)\n\n        residuals = np.zeros_like(a_grid)\n        \n        # Unconstrained residuals\n        unc_mask = a_t_plus_1 > a_min\n        residuals[unc_mask] = np.abs(mu_t[unc_mask] - beta * R * mu_t_plus_1[unc_mask])\n\n        # Constrained residuals\n        cons_mask = ~unc_mask\n        residuals[cons_mask] = np.maximum(0, mu_t[cons_mask] - beta * R * mu_t_plus_1[cons_mask])\n\n        return np.max(residuals)\n\n    # Test cases from the problem statement\n    test_cases = [\n        (0.96, 2.0, 1.0, 1.0, 1.03, 1.0, 0.0, 20.0, 1.0),\n        (0.96, 2.0, 3.0, 1.0, 1.03, 1.0, 0.0, 20.0, 1.0),\n        (0.96, 2.0, 1.0, 1.0, 1.04, 0.5, 0.0, 20.0, 1.0),\n        (0.96, 2.0, 0.2, 1.0, 1.02, 1.0, 0.0, 20.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        max_residual = compute_policy_and_residual(case)\n        results.append(max_residual)\n\n    # Format and print the final output\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}