{"hands_on_practices": [{"introduction": "To begin our hands-on exploration, we start with a foundational skill: calculating a mixed-strategy Nash Equilibrium in a simple two-player, two-strategy game. This exercise [@problem_id:2381458] presents a classic business scenario where direct competition leaves no stable pure-strategy outcome. By applying the indifference principle—the idea that a player must be made indifferent between the actions they are mixing—we can solve for the precise probabilities that constitute a stable equilibrium.", "id": "2381458", "problem": "Two competing fashion brands, labeled Brand A and Brand B, each decide simultaneously on the timing of their season-end sale. Each brand has two possible actions: $E$ (launch the sale early) or $L$ (launch the sale late). The interaction is a one-shot, static, simultaneous-move game with complete information. Profits are realized immediately after the actions are chosen and are given in the following way, where the first number in each pair is the profit of Brand A and the second number is the profit of Brand B:\n\n- If both choose $E$, profits are $(40, 10)$.\n- If Brand A chooses $E$ and Brand B chooses $L$, profits are $(15, 45)$.\n- If Brand A chooses $L$ and Brand B chooses $E$, profits are $(10, 50)$.\n- If both choose $L$, profits are $(35, 12)$.\n\nAssume the game has a unique mixed-strategy Nash equilibrium (Nash equilibrium (NE)). Let $p$ denote the probability with which Brand A chooses $E$ in this equilibrium. What is $p$? Express your answer as a reduced fraction or as a decimal number. No rounding is required.", "solution": "The problem statement is subjected to validation.\n\nGivens extracted from the statement:\n1.  Two players: Brand A and Brand B.\n2.  Action set for each player: {$E, L$}.\n3.  The game is a static, simultaneous-move game with complete information.\n4.  Payoff matrix, where payoffs are (Profit of Brand A, Profit of Brand B):\n    -   If (Brand A, Brand B) choose $(E, E)$, payoffs are $(40, 10)$.\n    -   If (Brand A, Brand B) choose $(E, L)$, payoffs are $(15, 45)$.\n    -   If (Brand A, Brand B) choose $(L, E)$, payoffs are $(10, 50)$.\n    -   If (Brand A, Brand B) choose $(L, L)$, payoffs are $(35, 12)$.\n5.  It is assumed that a unique mixed-strategy Nash equilibrium (NE) exists.\n6.  The variable $p$ denotes the probability with which Brand A chooses action $E$ in this equilibrium.\n7.  The task is to find the value of $p$.\n\nValidation verdict:\nThe problem is scientifically grounded in the established principles of game theory. It is a well-posed question concerning the computation of a mixed-strategy Nash equilibrium for a $2 \\times 2$ static game. The provided information is complete, consistent, and objective. There are no violations of scientific or logical principles. The problem does not contain any of the flaws listed in the validation checklist. Therefore, the problem is deemed valid and a solution will be provided.\n\nThe game can be represented by the following payoff matrix, where Brand A is the row player and Brand B is the column player. The entries are the payoffs $(u_A, u_B)$:\n\n$$\n\\begin{array}{c|cc}\n\\multicolumn{1}{c}{} & \\multicolumn{2}{c}{\\text{Brand B}} \\\\\n\\multicolumn{1}{c}{} & E & L \\\\\n\\cline{2-3}\n\\text{Brand A} \\;\\; E & (40, 10) & (15, 45) \\\\\nL & (10, 50) & (35, 12) \\\\\n\\end{array}\n$$\n\nFirst, we check for pure-strategy Nash equilibria. A pure-strategy profile is a Nash equilibrium if no player can unilaterally deviate to improve their payoff.\n-   $(E, E)$: Brand B would prefer to deviate to $L$ (payoff of $45 > 10$). Not a NE.\n-   $(E, L)$: Brand A would prefer to deviate to $L$ (payoff of $35 > 15$). Not a NE.\n-   $(L, E)$: Brand A would prefer to deviate to $E$ (payoff of $40 > 10$). Not a NE.\n-   $(L, L)$: Brand B would prefer to deviate to $E$ (payoff of $50 > 12$). Not a NE.\nThere are no pure-strategy Nash equilibria. As the problem states, we must find the mixed-strategy Nash equilibrium.\n\nLet $p$ be the probability that Brand A chooses action $E$. Thus, Brand A plays $L$ with probability $1-p$.\nLet $q$ be the probability that Brand B chooses action $E$. Thus, Brand B plays $L$ with probability $1-q$.\n\nFor a mixed-strategy Nash equilibrium to exist, each player must be indifferent between the pure strategies they are mixing over. The value of $p$ is the one that makes Brand B indifferent between choosing $E$ and choosing $L$.\n\nThe expected payoff for Brand B from choosing $E$, denoted $E[U_B(E)]$, is calculated based on Brand A's strategy:\n$$ E[U_B(E)] = p \\cdot 10 + (1-p) \\cdot 50 $$\nThe expected payoff for Brand B from choosing $L$, denoted $E[U_B(L)]$, is:\n$$ E[U_B(L)] = p \\cdot 45 + (1-p) \\cdot 12 $$\n\nIn equilibrium, Brand B must be indifferent, so we set $E[U_B(E)] = E[U_B(L)]$:\n$$ p \\cdot 10 + (1-p) \\cdot 50 = p \\cdot 45 + (1-p) \\cdot 12 $$\nWe now solve this equation for $p$:\n$$ 10p + 50 - 50p = 45p + 12 - 12p $$\n$$ 50 - 40p = 33p + 12 $$\nNow, we collect the terms involving $p$ on one side and the constant terms on the other:\n$$ 50 - 12 = 33p + 40p $$\n$$ 38 = 73p $$\n$$ p = \\frac{38}{73} $$\n\nThis is the probability with which Brand A must play $E$ to make Brand B indifferent between its pure strategies. Since $0 < \\frac{38}{73} < 1$, this is a valid mixed strategy.\n\nFor completeness, we can also calculate the equilibrium strategy for Brand B, $q$. Brand A must be indifferent between its strategies $E$ and $L$.\nThe expected payoff for Brand A from choosing $E$:\n$$ E[U_A(E)] = q \\cdot 40 + (1-q) \\cdot 15 = 40q + 15 - 15q = 25q + 15 $$\nThe expected payoff for Brand A from choosing $L$:\n$$ E[U_A(L)] = q \\cdot 10 + (1-q) \\cdot 35 = 10q + 35 - 35q = 35 - 25q $$\nSetting $E[U_A(E)] = E[U_A(L)]$:\n$$ 25q + 15 = 35 - 25q $$\n$$ 50q = 20 $$\n$$ q = \\frac{20}{50} = \\frac{2}{5} $$\nSince $0 < \\frac{2}{5} < 1$, this is also a valid mixed strategy. The unique mixed-strategy Nash Equilibrium is $\\left(\\sigma_A, \\sigma_B\\right) = \\left(p=\\frac{38}{73}, q=\\frac{2}{5}\\right)$.\n\nThe question asks for the value of $p$. The fraction $\\frac{38}{73}$ is in reduced form, as $73$ is a prime number and $38 = 2 \\times 19$.", "answer": "$$\\boxed{\\frac{38}{73}}$$"}, {"introduction": "While manual calculation is crucial for understanding the mechanics, a computational approach is needed to solve larger and more complex games. This practice [@problem_id:2381485] challenges you to move from solving a single case to building a general-purpose algorithm. You will implement the support enumeration method, which systematically checks for equilibria, translating the logic of the indifference principle into a robust program capable of analyzing any finite bimatrix game.", "id": "2381485", "problem": "Consider a finite two-player static game with complete information, represented in bimatrix form by two payoff matrices $A \\in \\mathbb{R}^{m \\times n}$ and $B \\in \\mathbb{R}^{m \\times n}$. Player $1$ (row player) chooses a mixed strategy $x \\in \\Delta^{m-1}$ over $m$ pure strategies, and Player $2$ (column player) chooses a mixed strategy $y \\in \\Delta^{n-1}$ over $n$ pure strategies, where $\\Delta^{k}$ denotes the $k$-dimensional probability simplex. A pair $(x,y)$ is a Nash equilibrium if $x$ is a best response to $y$ and $y$ is a best response to $x$. All payoffs are unitless. You must implement a complete program that, given a set of bimatrix games, computes the number of distinct Nash equilibria (including pure and mixed) for each game, using exact real-number arithmetic with numerical verification under an absolute tolerance of $\\varepsilon = 10^{-9}$ for all inequality and equality checks. Two equilibria are considered identical if both mixed strategies are elementwise equal within absolute tolerance $\\varepsilon$.\n\nUse the following test suite of games. Each game is specified by a pair of payoff matrices $(A^{(k)}, B^{(k)})$:\n\nTest case $1$ (a game with a unique pure-strategy Nash equilibrium):\n$$\nA^{(1)} = \\begin{pmatrix}\n2 & 0 \\\\\n3 & 1\n\\end{pmatrix}, \\quad\nB^{(1)} = \\begin{pmatrix}\n2 & 3 \\\\\n0 & 1\n\\end{pmatrix}.\n$$\n\nTest case $2$ (a game with multiple equilibria, including at least one mixed-strategy equilibrium):\n$$\nA^{(2)} = \\begin{pmatrix}\n3 & 0 \\\\\n0 & 2\n\\end{pmatrix}, \\quad\nB^{(2)} = \\begin{pmatrix}\n2 & 0 \\\\\n0 & 3\n\\end{pmatrix}.\n$$\n\nTest case $3$ (a strictly competitive game with a unique mixed-strategy equilibrium):\n$$\nA^{(3)} = \\begin{pmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{pmatrix}, \\quad\nB^{(3)} = \\begin{pmatrix}\n-1 & 1 \\\\\n1 & -1\n\\end{pmatrix}.\n$$\n\nTest case $4$ (a $3 \\times 3$ game with strict dominance leading to a unique pure-strategy Nash equilibrium):\n$$\nA^{(4)} = \\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n2 & 3 & 2\n\\end{pmatrix}, \\quad\nB^{(4)} = \\begin{pmatrix}\n0 & 5 & 0 \\\\\n1 & 6 & 1 \\\\\n2 & 7 & 2\n\\end{pmatrix}.\n$$\n\nYour program must compute, for each test case $k \\in \\{1,2,3,4\\}$, the number of distinct Nash equilibria of $(A^{(k)}, B^{(k)})$. All computations must adhere to the absolute tolerance $\\varepsilon = 10^{-9}$ when checking best-response optimality and equality of payoffs across supported pure strategies. The final output must aggregate the results for all test cases into a single line as a comma-separated list enclosed in square brackets, in the order of the test cases. For example, the output format must be exactly of the form\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4],\n$$\nwhere each $\\text{result}_k$ is an integer equal to the number of distinct Nash equilibria found for test case $k$.", "solution": "The problem requires the computation of the number of all distinct Nash equilibria for a given set of two-player finite static games. The games are presented in bimatrix form, defined by payoff matrices $A \\in \\mathbb{R}^{m \\times n}$ for the row player (Player 1) and $B \\in \\mathbb{R}^{m \\times n}$ for the column player (Player 2).\n\nA Nash equilibrium is a profile of mixed strategies, $(x, y)$, where $x \\in \\Delta^{m-1}$ and $y \\in \\Delta^{n-1}$, such that no player has an incentive to unilaterally deviate. This means $x$ is a best response to $y$, and $y$ is a best response to $x$. The expected payoff for Player 1 is $x^T A y$ and for Player 2 is $x^T B y$.\n\nTo find all Nash equilibria, including pure and mixed ones, we employ the method of **support enumeration**. The support of a mixed strategy is the set of pure strategies played with a non-zero probability. Let $S_1$ be the support of $x$ and $S_2$ be the support of $y$.\n\nA foundational result in game theory, the **Indifference Principle**, states that for a mixed strategy to be a best response, the player must be indifferent among all pure strategies within its support. The expected payoff from playing any of these pure strategies must be equal. Furthermore, the expected payoff from any pure strategy in the support must be at least as great as the expected payoff from any pure strategy outside the support.\n\nLet us assume a candidate Nash equilibrium exists with supports $S_1$ for Player 1 and $S_2$ for Player 2. For non-degenerate games, all Nash equilibria have supports of the same size, i.e., $|S_1| = |S_2|$. We will thus iterate through all possible support pairs $(S_1, S_2)$ of equal size $k$, where $k$ ranges from $1$ to $\\min(m, n)$.\n\nFor a given pair of supports $(S_1, S_2)$ with $|S_1| = |S_2| = k$, we formulate two systems of linear equations to find the candidate strategies $x$ and $y$.\n\n**1. Solving for Player 2's strategy $y$:**\nPlayer 1 must be indifferent among all pure strategies $i \\in S_1$. This means the expected payoff for playing any strategy $i \\in S_1$ against $y$ must be the same value, say $v_1$.\n$$ (A y)_i = \\sum_{j=1}^{n} A_{ij} y_j = v_1 \\quad \\forall i \\in S_1 $$\nSince $y_j = 0$ for $j \\notin S_2$, this simplifies to:\n$$ \\sum_{j \\in S_2} A_{ij} y_j = v_1 \\quad \\forall i \\in S_1 $$\nThis provides $k$ equations. However, to solve for the $k$ unknown probabilities $\\{y_j\\}_{j \\in S_2}$, we only need $k-1$ independent indifference equations. Let $i_0$ be an arbitrary reference strategy in $S_1$. The $k-1$ indifference conditions are:\n$$ \\sum_{j \\in S_2} A_{ij} y_j = \\sum_{j \\in S_2} A_{i_0,j} y_j \\implies \\sum_{j \\in S_2} (A_{ij} - A_{i_0,j}) y_j = 0 \\quad \\forall i \\in S_1, i \\neq i_0 $$\nThe final equation required is the probability normalization constraint:\n$$ \\sum_{j \\in S_2} y_j = 1 $$\nThis forms a system of $k$ linear equations in $k$ variables, $\\{y_j\\}_{j \\in S_2}$, which can be solved using standard linear algebra methods.\n\n**2. Solving for Player 1's strategy $x$:**\nSimilarly, Player 2 must be indifferent among all pure strategies $j \\in S_2$. The expected payoff for playing any strategy $j \\in S_2$ against $x$ must be the same value, $v_2$.\n$$ (x^T B)_j = \\sum_{i=1}^{m} x_i B_{ij} = v_2 \\quad \\forall j \\in S_2 $$\nSince $x_i = 0$ for $i \\notin S_1$, this becomes:\n$$ \\sum_{i \\in S_1} x_i B_{ij} = v_2 \\quad \\forall j \\in S_2 $$\nThis can be expressed using the transpose of $B$, $B^T$, as $(B^T x)_j = v_2$. The procedure is analogous to the one for Player 1. We form a system of $k$ linear equations in $k$ variables, $\\{x_i\\}_{i \\in S_1}$, from $k-1$ indifference conditions and the normalization constraint $\\sum_{i \\in S_1} x_i = 1$.\n\n**3. Verification of the Candidate Equilibrium:**\nA solution $(x, y)$ to these systems is only a candidate equilibrium. It must be verified against three conditions, using a numerical tolerance $\\varepsilon = 10^{-9}$:\na. **Probability Distribution Validity:** All components of the computed strategies must be non-negative. That is, $x_i \\ge -\\varepsilon$ for all $i \\in S_1$ and $y_j \\ge -\\varepsilon$ for all $j \\in S_2$.\nb. **Best Response for Player 1:** Player 1 must not gain by deviating to a pure strategy $i' \\notin S_1$. The payoff for any such strategy must not be strictly greater than the equilibrium payoff $v_1$.\n$$ (A y)_{i'} \\le v_1 + \\varepsilon \\quad \\forall i' \\notin S_1, \\text{ where } v_1 = (A y)_{i_0} \\text{ for any } i_0 \\in S_1 $$\nc. **Best Response for Player 2:** Player 2 must not gain by deviating to a pure strategy $j' \\notin S_2$.\n$$ (x^T B)_{j'} \\le v_2 + \\varepsilon \\quad \\forall j' \\notin S_2, \\text{ where } v_2 = (x^T B)_{j_0} \\text{ for any } j_0 \\in S_2 $$\n\nIf a candidate $(x, y)$ passes all verification steps, it is a valid Nash equilibrium. The algorithm proceeds by iterating through all valid support pairs, solving the corresponding linear systems, verifying the solutions, and collecting all unique valid equilibria. Pure strategy equilibria are naturally included in this procedure when the support size $k$ is $1$. Finally, the total number of distinct equilibria found is reported for each game.", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef find_equilibria(A, B, tol=1e-9):\n    \"\"\"\n    Finds all Nash equilibria in a bimatrix game using support enumeration.\n    \n    This function iterates through all possible support pairs of equal size,\n    solves for candidate mixed strategies, and verifies if they constitute\n    a Nash equilibrium.\n    \"\"\"\n    m, n = A.shape\n    found_equilibria = []\n\n    # Iterate over all possible support sizes k. For non-degenerate games,\n    # equilibria have supports of equal size.\n    for k in range(1, min(m, n) + 1):\n        # Iterate over all possible supports for Player 1 (rows)\n        for s1_indices in combinations(range(m), k):\n            s1 = list(s1_indices)\n            \n            # Iterate over all possible supports for Player 2 (columns)\n            for s2_indices in combinations(range(n), k):\n                s2 = list(s2_indices)\n\n                # 1. Solve for Player 2's mixed strategy y\n                try:\n                    # Construct the linear system for y\n                    # We need to solve M_y * y_s2 = b_y\n                    # k-1 indifference equations and 1 probability sum equation\n                    M_y = np.ones((k, k))\n                    b_y = np.zeros(k)\n                    b_y[-1] = 1.0\n                    \n                    # Indifference equations for player 1\n                    A_sub = A[s1, :][:, s2]\n                    M_y[:-1, :] = A_sub[:-1, :] - A_sub[-1, :]\n\n                    y_s2 = np.linalg.solve(M_y, b_y)\n\n                except np.linalg.LinAlgError:\n                    continue  # Singular matrix, no unique solution for this support pair\n\n                # 2. Solve for Player 1's mixed strategy x\n                try:\n                    # Construct the linear system for x, using the transpose of B\n                    # We need to solve M_x * x_s1 = b_x\n                    B_T_sub = B.T[s2, :][:, s1]\n                    M_x = np.ones((k, k))\n                    b_x = np.zeros(k)\n                    b_x[-1] = 1.0\n\n                    # Indifference equations for player 2\n                    M_x[:-1, :] = B_T_sub[:-1, :] - B_T_sub[-1, :]\n                    \n                    x_s1 = np.linalg.solve(M_x, b_x)\n\n                except np.linalg.LinAlgError:\n                    continue # Singular matrix\n\n                # 3. Verify the candidate solution (x, y)\n                \n                # a. Check if strategies are valid probability distributions\n                if np.min(x_s1) < -tol or np.min(y_s2) < -tol:\n                    continue\n\n                # Reconstruct full strategy vectors\n                x = np.zeros(m)\n                x[s1] = x_s1\n                y = np.zeros(n)\n                y[s2] = y_s2\n\n                # b. Verify best-response conditions for players\n                p1_payoffs = A @ y\n                p2_payoffs = x @ B\n\n                v1 = p1_payoffs[s1[0]]\n                v2 = p2_payoffs[s2[0]]\n\n                # Check if any strategy outside the support yields a strictly higher payoff\n                p1_max_other_payoff = -np.inf\n                for i in range(m):\n                    if i not in s1:\n                        p1_max_other_payoff = max(p1_max_other_payoff, p1_payoffs[i])\n                \n                if p1_max_other_payoff > v1 + tol:\n                    continue\n\n                p2_max_other_payoff = -np.inf\n                for j in range(n):\n                    if j not in s2:\n                        p2_max_other_payoff = max(p2_max_other_payoff, p2_payoffs[j])\n\n                if p2_max_other_payoff > v2 + tol:\n                    continue\n\n                # The candidate is a valid Nash Equilibrium.\n                # Add it to the list if it's not a duplicate.\n                is_duplicate = False\n                for ex, ey in found_equilibria:\n                    if np.allclose(x, ex, atol=tol) and np.allclose(y, ey, atol=tol):\n                        is_duplicate = True\n                        break\n                \n                if not is_duplicate:\n                    found_equilibria.append((x, y))\n\n    return len(found_equilibria)\n\n\ndef solve():\n    \"\"\"\n    Solves the given set of bimatrix games and prints the number of equilibria.\n    \"\"\"\n    test_cases = [\n        (np.array([[2, 0], [3, 1]]), np.array([[2, 3], [0, 1]])),\n        (np.array([[3, 0], [0, 2]]), np.array([[2, 0], [0, 3]])),\n        (np.array([[1, -1], [-1, 1]]), np.array([[-1, 1], [1, -1]])),\n        (np.array([[1, 0, 0], [0, 1, 0], [2, 3, 2]]), np.array([[0, 5, 0], [1, 6, 1], [2, 7, 2]]))\n    ]\n    \n    results = []\n    for A, B in test_cases:\n        num_equilibria = find_equilibria(A, B)\n        results.append(num_equilibria)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"}, {"introduction": "Many economic models, from pricing strategies to production levels, involve continuous choices rather than a finite set of actions. This final practice [@problem_id:2381470] addresses this by introducing a powerful technique for analyzing such games: discretization. By approximating the continuous strategy space with a fine grid, we can compute an approximate Nash equilibrium and study its convergence, bridging the gap between theoretical models and practical, computational solutions.", "id": "2381470", "problem": "Consider a two-player static game with continuous strategies. Each player $i \\in \\{1,2\\}$ chooses a strategy $s_i \\in [0,1]$. The payoff functions are\n$$\nu_1(s_1,s_2) \\;=\\; \\alpha_1 s_1 \\;-\\; \\frac{\\beta_1}{2}s_1^2 \\;-\\; \\gamma s_1 s_2,\n\\qquad\nu_2(s_1,s_2) \\;=\\; \\alpha_2 s_2 \\;-\\; \\frac{\\beta_2}{2}s_2^2 \\;-\\; \\gamma s_1 s_2,\n$$\nwhere $\\alpha_1,\\alpha_2 > 0$, $\\beta_1,\\beta_2 > 0$, and $\\gamma \\ge 0$ are parameters.\n\nDefine, for any positive integer $k$, the discretized action set $A_k = \\{0, \\tfrac{1}{k}, \\tfrac{2}{k}, \\ldots, 1\\}$. The discretized version of the game restricts both players to actions in $A_k$. For any fixed $k$, define the grid-equilibrium loss at a pair $(a_1,a_2)\\in A_k \\times A_k$ by\n$$\n\\Delta_1(a_1,a_2) \\;=\\; \\max_{a_1' \\in A_k} u_1(a_1',a_2) \\;-\\; u_1(a_1,a_2),\n\\quad\n\\Delta_2(a_1,a_2) \\;=\\; \\max_{a_2' \\in A_k} u_2(a_1,a_2') \\;-\\; u_2(a_1,a_2),\n$$\nand\n$$\nL_k(a_1,a_2) \\;=\\; \\Delta_1(a_1,a_2) \\;+\\; \\Delta_2(a_1,a_2).\n$$\nA pair $(a_1,a_2)\\in A_k \\times A_k$ is a pure-strategy Nash equilibrium of the discretized game if and only if $L_k(a_1,a_2)=0$. For each $k$, define the selected discretized equilibrium estimate $(\\hat s_1^{(k)}, \\hat s_2^{(k)})$ by the following selection rule:\n- If there exists at least one pair with $L_k(a_1,a_2)=0$, select among those the pair that minimizes the Euclidean norm $\\|(a_1,a_2)\\|_2$. If there are multiple minima, break ties by lexicographic order on $(a_1,a_2)$.\n- If no pair satisfies $L_k(a_1,a_2)=0$, select any pair that minimizes $L_k(a_1,a_2)$, breaking ties by first minimizing $\\|(a_1,a_2)\\|_2$, then by lexicographic order on $(a_1,a_2)$.\n\nFor a given parameter vector $(\\alpha_1,\\alpha_2,\\beta_1,\\beta_2,\\gamma)$ and an increasing sequence of discretizations $k \\in \\{10,20,40,80,160\\}$, define the final estimate $(\\hat s_1,\\hat s_2)$ to be $(\\hat s_1^{(160)}, \\hat s_2^{(160)})$. Define the convergence indicator $\\mathsf{conv}$ to be $1$ if\n$$\n\\max\\Big\\{\\,\\big|\\hat s_1^{(160)} - \\hat s_1^{(80)}\\big|,\\;\\big|\\hat s_2^{(160)} - \\hat s_2^{(80)}\\big|\\,\\Big\\} \\;\\le\\; \\tau,\n$$\nand $\\mathsf{conv}=0$ otherwise, where $\\tau = 7 \\times 10^{-3}$.\n\nTest suite. Use the following parameter sets:\n- Case A: $(\\alpha_1,\\alpha_2,\\beta_1,\\beta_2,\\gamma) = (1.0,\\,1.2,\\,2.0,\\,1.8,\\,0.5)$.\n- Case B: $(\\alpha_1,\\alpha_2,\\beta_1,\\beta_2,\\gamma) = (3.0,\\,3.0,\\,1.0,\\,1.0,\\,0.2)$.\n- Case C: $(\\alpha_1,\\alpha_2,\\beta_1,\\beta_2,\\gamma) = (0.05,\\,0.02,\\,2.0,\\,3.0,\\,0.9)$.\n\nRequired output. Your program should produce a single line of output containing a list of three results (one per parameter set, in the order A, B, C). Each result must be the list $[\\hat s_1,\\hat s_2,\\mathsf{conv}]$, where $\\hat s_1$ and $\\hat s_2$ are printed as decimals rounded to six digits after the decimal point, and $\\mathsf{conv}$ is printed as the integer $0$ or $1$. For example, the overall output must have the form\n$$\n\\big[[x_1,y_1,c_1],[x_2,y_2,c_2],[x_3,y_3,c_3]\\big],\n$$\nwith each $x_i$ and $y_i$ rounded to six digits after the decimal point and each $c_i \\in \\{0,1\\}$.", "solution": "The problem statement has been validated and is deemed to be well-posed, scientifically sound, and computationally tractable. It describes a standard problem in computational game theory—the approximation of a Nash equilibrium in a continuous game by analyzing its discretized counterpart.\n\nThe game involves two players, $i \\in \\{1, 2\\}$, with strategy spaces $s_i \\in [0, 1]$. The payoff functions are given by:\n$$\nu_1(s_1, s_2) = \\alpha_1 s_1 - \\frac{\\beta_1}{2}s_1^2 - \\gamma s_1 s_2\n$$\n$$\nu_2(s_1, s_2) = \\alpha_2 s_2 - \\frac{\\beta_2}{2}s_2^2 - \\gamma s_1 s_2\n$$\nGiven the constraints $\\beta_1 > 0$ and $\\beta_2 > 0$, each player's payoff function is strictly concave with respect to their own strategy, $s_i$. This property is crucial as it ensures that for any fixed strategy of the opponent, a player's best response is unique.\n\nThe problem requires us to analyze a discretized version of this game, where strategies are restricted to the set $A_k = \\{0, \\frac{1}{k}, \\frac{2}{k}, \\ldots, 1\\}$. A pure-strategy Nash Equilibrium (NE) of this discretized game is a pair of actions $(a_1, a_2) \\in A_k \\times A_k$ such that neither player has a unilateral incentive to deviate to another action in $A_k$. Formally, for player $1$, this means $u_1(a_1, a_2) \\ge u_1(a_1', a_2)$ for all $a_1' \\in A_k$. A similar condition holds for player $2$.\n\nThe problem defines a grid-equilibrium loss, $L_k(a_1, a_2)$, as the sum of the maximum possible gains from deviation for each player:\n$$\nL_k(a_1, a_2) = \\underbrace{\\left(\\max_{a_1' \\in A_k} u_1(a_1', a_2) - u_1(a_1, a_2)\\right)}_{\\Delta_1(a_1, a_2)} + \\underbrace{\\left(\\max_{a_2' \\in A_k} u_2(a_1, a_2') - u_2(a_1, a_2)\\right)}_{\\Delta_2(a_1, a_2)}\n$$\nA pair $(a_1, a_2)$ is a pure-strategy NE if and only if both deviation gains are zero, which implies $L_k(a_1, a_2) = 0$. When no such exact NE exists on the grid, we seek an approximate equilibrium by finding the pair that minimizes $L_k(a_1, a_2)$.\n\nThe solution methodology is a direct implementation of the problem's requirements. For each specified value of the discretization parameter $k \\in \\{10, 20, 40, 80, 160\\}$ and for each set of game parameters $(\\alpha_1, \\alpha_2, \\beta_1, \\beta_2, \\gamma)$, the following computational procedure is executed:\n\n1.  **Grid Generation and Utility Calculation**: The discrete action set $A_k$ is generated. We construct a $(k+1) \\times (k+1)$ grid representing all possible strategy pairs $(a_1, a_2) \\in A_k \\times A_k$. Using vectorized computations for efficiency, we compute two matrices, $U_1$ and $U_2$, where $(U_1)_{ij} = u_1(\\frac{i}{k}, \\frac{j}{k})$ and $(U_2)_{ij} = u_2(\\frac{i}{k}, \\frac{j}{k})$.\n\n2.  **Loss Matrix Computation**: For each player, and for each fixed strategy of the opponent, we find the maximum utility achievable on the grid. For player $1$, for each column $j$ (fixed $a_2 = \\frac{j}{k}$), we find $\\max_i (U_1)_{ij}$. For player $2$, for each row $i$ (fixed $a_1 = \\frac{i}{k}$), we find $\\max_j (U_2)_{ij}$. These maximal utilities are then used to compute the deviation gain matrices, $\\Delta_1$ and $\\Delta_2$, and finally the total loss matrix, $L_k = \\Delta_1 + \\Delta_2$.\n\n3.  **Equilibrium Selection**: We identify the selected discretized equilibrium estimate $(\\hat s_1^{(k)}, \\hat s_2^{(k)})$ according to the specified hierarchical rule:\n    a. First, we identify the set of candidate pairs. If there exist any pairs $(a_1, a_2)$ for which $L_k(a_1, a_2) = 0$ (within a small numerical tolerance), this set of pairs becomes the candidate pool.\n    b. If no exact NE exists (i.e., $\\min L_k > 0$), the candidate pool consists of all pairs that achieve this minimum value of $L_k$.\n    c. From the candidate pool, the final selection is made by finding the pair that minimizes the Euclidean norm $\\|(a_1, a_2)\\|_2 = \\sqrt{a_1^2 + a_2^2}$.\n    d. Any remaining ties are broken by selecting the pair that is minimal in lexicographical order. This entire selection is implemented by sorting the candidate pairs based on a tuple of keys: $(\\text{norm}, a_1, a_2)$.\n\n4.  **Final Estimate and Convergence**: This procedure is repeated for all specified $k$. The final estimate $(\\hat s_1, \\hat s_2)$ is defined as the result for $k=160$, i.e., $(\\hat s_1^{(160)}, \\hat s_2^{(160)})$. The convergence indicator, $\\mathsf{conv}$, is computed by comparing the estimates for $k=160$ and $k=80$. It is set to $1$ if the maximum absolute difference in the strategy components is no more than the threshold $\\tau = 7 \\times 10^{-3}$, and $0$ otherwise.\n\nThis complete algorithm is applied to each of the three test cases, and the results are formatted as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the discretized Nash equilibrium estimates for a series of two-player games.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (alpha1, alpha2, beta1, beta2, gamma)\n        (1.0, 1.2, 2.0, 1.8, 0.5),\n        # Case B:\n        (3.0, 3.0, 1.0, 1.0, 0.2),\n        # Case C:\n        (0.05, 0.02, 2.0, 3.0, 0.9),\n    ]\n\n    k_values = [10, 20, 40, 80, 160]\n    tau = 7e-3\n    \n    overall_results = []\n    \n    for case in test_cases:\n        alpha1, alpha2, beta1, beta2, gamma = case\n        \n        estimates = {}\n        \n        for k in k_values:\n            actions = np.linspace(0, 1, k + 1, dtype=np.float64)\n            \n            # Create a grid of strategies. 'ij' indexing ensures that\n            # a1_grid varies along axis 0 and a2_grid along axis 1.\n            a1_grid, a2_grid = np.meshgrid(actions, actions, indexing='ij')\n\n            # Vectorized calculation of utility matrices for all strategy pairs\n            u1_matrix = alpha1 * a1_grid - (beta1 / 2) * a1_grid**2 - gamma * a1_grid * a2_grid\n            u2_matrix = alpha2 * a2_grid - (beta2 / 2) * a2_grid**2 - gamma * a1_grid * a2_grid\n            \n            # For each fixed strategy of player 2 (a2), find player 1's best response utility.\n            # This corresponds to finding the maximum value in each column (axis=0) of u1_matrix.\n            max_u1_for_each_a2 = np.max(u1_matrix, axis=0)\n            \n            # For each fixed strategy of player 1 (a1), find player 2's best response utility.\n            # This corresponds to finding the maximum value in each row (axis=1) of u2_matrix.\n            max_u2_for_each_a1 = np.max(u2_matrix, axis=1)\n\n            # Calculate deviation gain matrices, Delta_1 and Delta_2.\n            # Broadcasting is used to subtract the utility matrix from the max utility vectors.\n            delta1_matrix = max_u1_for_each_a2[np.newaxis, :] - u1_matrix\n            delta2_matrix = max_u2_for_each_a1[:, np.newaxis] - u2_matrix\n            \n            # Calculate the total loss matrix L_k\n            L_k_matrix = delta1_matrix + delta2_matrix\n            \n            # --- Selection Rule Implementation ---\n            # Use a small tolerance for floating-point comparisons.\n            tolerance = 1e-9\n            \n            # First, check for exact Nash Equilibria (where L_k is approximately 0).\n            zero_loss_indices = np.argwhere(L_k_matrix < tolerance)\n            \n            candidate_indices = []\n            if zero_loss_indices.size > 0:\n                # If NE exist, they form the candidate set.\n                candidate_indices = zero_loss_indices\n            else:\n                # If no NE exist, find pairs with the minimum L_k.\n                L_min = np.min(L_k_matrix)\n                candidate_indices = np.argwhere(np.abs(L_k_matrix - L_min) < tolerance)\n            \n            # From the candidate indices, select the best one based on the hierarchical tie-breaking rule.\n            # 1. Minimize Euclidean norm.\n            # 2. Break ties with lexicographical order on (a1, a2).\n            candidates_to_sort = []\n            for i, j in candidate_indices:\n                a1, a2 = actions[i], actions[j]\n                norm_sq = a1**2 + a2**2\n                candidates_to_sort.append((norm_sq, a1, a2))\n            \n            # Sort by norm, then by a1, then by a2. Python's default tuple sort does this.\n            candidates_to_sort.sort()\n            \n            # The best candidate is the first element after sorting.\n            _best_norm_sq, s1_hat_k, s2_hat_k = candidates_to_sort[0]\n            estimates[k] = (s1_hat_k, s2_hat_k)\n\n        # --- Final Estimate and Convergence Indicator ---\n        s1_hat_160, s2_hat_160 = estimates[160]\n        s1_hat_80, s2_hat_80 = estimates[80]\n        \n        conv_diff = max(abs(s1_hat_160 - s1_hat_80), abs(s2_hat_160 - s2_hat_80))\n        conv = 1 if conv_diff <= tau else 0\n        \n        overall_results.append([s1_hat_160, s2_hat_160, conv])\n\n    # Format the final output string to match the required format.\n    formatted_results = []\n    for res in overall_results:\n        s1_str = f\"{res[0]:.6f}\"\n        s2_str = f\"{res[1]:.6f}\"\n        c_str = str(res[2])\n        formatted_results.append(f\"[{s1_str},{s2_str},{c_str}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}