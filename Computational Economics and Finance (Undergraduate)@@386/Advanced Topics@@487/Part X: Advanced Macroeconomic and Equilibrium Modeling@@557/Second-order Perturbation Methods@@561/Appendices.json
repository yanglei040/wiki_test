{"hands_on_practices": [{"introduction": "Our first practice moves beyond single-agent models to explore how shocks propagate through an interconnected system, a core concern in financial economics. By analyzing a stylized interbank network with non-linear costs, you will apply the perturbation method to a system of equations to isolate first- and second-order effects. This exercise provides a clear, hands-on introduction to the core algebra of second-order approximation and demonstrates its power in understanding systemic risk and contagion [@problem_id:2428772].", "id": "2428772", "problem": "Consider an economy with $n$ interconnected banks. Let $W \\in \\mathbb{R}^{n \\times n}$ be a nonnegative exposure matrix with zero diagonal, where $W_{ij}$ measures bank $i$'s loss sensitivity to counterparty $j$. Let $u \\in \\mathbb{R}^{n}$ be a fixed shock direction vector and let $s \\in \\mathbb{R}$ be a scalar shock amplitude. Each bank’s equilibrium loss vector $\\ell(s) \\in \\mathbb{R}^{n}$ is defined implicitly by the fixed-point system\n$$\n\\ell(s) \\;=\\; W \\big( s\\,u \\;+\\; \\alpha\\,\\ell(s) \\;+\\; \\gamma\\,(\\ell(s)\\circ \\ell(s)) \\big),\n$$\nwhere $\\alpha \\in \\mathbb{R}$ and $\\gamma \\in \\mathbb{R}_{\\ge 0}$ are given parameters and $\\ell(s)\\circ \\ell(s)$ denotes the elementwise (Hadamard) square of $\\ell(s)$. Assume that $I - \\alpha W$ is nonsingular, which guarantees a unique solution $\\ell(s)$ for $s$ in a neighborhood of $0$.\n\nYour task is to obtain the second-order perturbation approximation of $\\ell(s)$ around $s=0$. That is, determine vectors $a \\in \\mathbb{R}^{n}$ and $b \\in \\mathbb{R}^{n}$ such that\n$$\n\\ell(s) \\;=\\; a\\,s \\;+\\; b\\,s^{2} \\;+\\; o(s^{2}) \\quad \\text{as } s \\to 0,\n$$\nand then evaluate the approximation $\\widehat{\\ell}(s) \\equiv a\\,s + b\\,s^{2}$ at the specified parameter values below.\n\nTest Suite. For each test case, compute and report $\\widehat{\\ell}(s)$:\n- Test case $1$:\n$$\nn=3,\\quad\nW=\\begin{bmatrix}\n0 & 0.3 & 0.2\\\\\n0.25 & 0 & 0.15\\\\\n0.1 & 0.2 & 0\n\\end{bmatrix},\\quad\n\\alpha=0.8,\\quad\n\\gamma=0.7,\\quad\nu=\\begin{bmatrix}1\\\\0\\\\0\\end{bmatrix},\\quad\ns=0.05.\n$$\n- Test case $2$:\n$$\nn=3,\\quad\nW=\\begin{bmatrix}\n0 & 0.45 & 0.45\\\\\n0.45 & 0 & 0.45\\\\\n0.45 & 0.45 & 0\n\\end{bmatrix},\\quad\n\\alpha=1.05,\\quad\n\\gamma=0.5,\\quad\nu=\\begin{bmatrix}0\\\\1\\\\0\\end{bmatrix},\\quad\ns=0.02.\n$$\n- Test case $3$:\n$$\nn=4,\\quad\nW=\\begin{bmatrix}\n0 & 0.2 & 0.1 & 0\\\\\n0.1 & 0 & 0.1 & 0.1\\\\\n0.05 & 0.1 & 0 & 0.1\\\\\n0 & 0.1 & 0.1 & 0\n\\end{bmatrix},\\quad\n\\alpha=0.9,\\quad\n\\gamma=0.0,\\quad\nu=\\begin{bmatrix}0.6\\\\0.4\\\\0\\\\0\\end{bmatrix},\\quad\ns=0.03.\n$$\n- Test case $4$:\n$$\nn=3,\\quad\nW=\\begin{bmatrix}\n0 & 0.3 & 0.2\\\\\n0.25 & 0 & 0.15\\\\\n0.1 & 0.2 & 0\n\\end{bmatrix},\\quad\n\\alpha=0.8,\\quad\n\\gamma=0.7,\\quad\nu=\\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix},\\quad\ns=-0.05.\n$$\n\nFinal Output Format. Your program must output a single line containing a list of the four results, where each result is the list of components of $\\widehat{\\ell}(s)$ for the corresponding test case, each component rounded to $6$ decimal places. The format must have no spaces, for example:\n$$\n\\big[\\,[x_{1,1},x_{1,2},\\dots],[x_{2,1},x_{2,2},\\dots],[x_{3,1},\\dots],[x_{4,1},\\dots]\\,\\big].\n$$\nNo physical units are involved. Angles are not used. All numerical answers must be decimals (not percentages).", "solution": "We start from the implicit fixed-point definition of the equilibrium loss vector $\\ell(s)\\in\\mathbb{R}^{n}$:\n$$\n\\ell(s) \\;=\\; W \\big( s\\,u \\;+\\; \\alpha\\,\\ell(s) \\;+\\; \\gamma\\,(\\ell(s)\\circ \\ell(s)) \\big).\n$$\nDefine the residual map $F:\\mathbb{R}^{n}\\times\\mathbb{R}\\to\\mathbb{R}^{n}$ by\n$$\nF(\\ell,s) \\;=\\; \\ell \\;-\\; W \\big( s\\,u \\;+\\; \\alpha\\,\\ell \\;+\\; \\gamma\\,(\\ell\\circ \\ell) \\big).\n$$\nBy assumption, the matrix $I-\\alpha W$ is nonsingular, which implies that for $s$ in a neighborhood of $0$ there exists a unique continuously differentiable function $\\ell(s)$ with $F(\\ell(s),s)=0$.\n\nWe seek a second-order perturbation expansion around $s=0$:\n$$\n\\ell(s) \\;=\\; a\\,s \\;+\\; b\\,s^{2} \\;+\\; o(s^{2}),\n$$\nfor vectors $a,b\\in\\mathbb{R}^{n}$. Substituting this expansion into the fixed-point system and collecting terms by powers of $s$ yields the equations determining $a$ and $b$.\n\nFirst-order terms. Substitute $\\ell(s)\\approx a\\,s$ and note that $(\\ell\\circ \\ell)\\approx (a\\circ a)\\,s^{2}$ contributes no first-order term. The $\\mathcal{O}(s)$ terms in $F(\\ell,s)=0$ satisfy\n$$\na \\;-\\; W\\big(u+\\alpha\\,a\\big) \\;=\\; 0,\n$$\nwhich can be rearranged as\n$$\n\\big(I-\\alpha W\\big)\\,a \\;=\\; W\\,u.\n$$\nBecause $I-\\alpha W$ is nonsingular, the unique first-order coefficient is\n$$\na \\;=\\; \\big(I-\\alpha W\\big)^{-1} W\\,u.\n$$\n\nSecond-order terms. Substitute $\\ell(s)\\approx a\\,s+b\\,s^{2}$ and observe that\n$$\n\\ell\\circ \\ell \\;=\\; (a\\circ a)\\,s^{2} \\;+\\; \\mathcal{O}(s^{3}),\n$$\nbecause $(a\\,s)\\circ (b\\,s^{2})$ is of order $s^{3}$. The $\\mathcal{O}(s^{2})$ terms in $F(\\ell,s)=0$ satisfy\n$$\nb \\;-\\; W\\big(\\alpha\\,b \\;+\\; \\gamma\\,(a\\circ a)\\big) \\;=\\; 0,\n$$\nwhich rearranges to\n$$\n\\big(I-\\alpha W\\big)\\,b \\;=\\; W\\big(\\gamma\\,(a\\circ a)\\big).\n$$\nThus, the second-order coefficient is\n$$\nb \\;=\\; \\big(I-\\alpha W\\big)^{-1} W\\big(\\gamma\\,(a\\circ a)\\big).\n$$\n\nPutting the coefficients together, the second-order perturbation approximation of the equilibrium loss vector is\n$$\n\\widehat{\\ell}(s) \\;=\\; a\\,s \\;+\\; b\\,s^{2}, \\quad\na \\;=\\; \\big(I-\\alpha W\\big)^{-1} W\\,u,\\quad\nb \\;=\\; \\big(I-\\alpha W\\big)^{-1} W\\big(\\gamma\\,(a\\circ a)\\big).\n$$\n\nProperties and checks relevant to the test suite:\n- When $\\gamma=0$, the convex term vanishes and $b=0$, so the approximation is purely linear: $\\widehat{\\ell}(s)=a\\,s$.\n- If $s<0$ but $\\gamma>0$, the quadratic term $b\\,s^{2}$ is nonnegative componentwise whenever $W\\ge 0$ and $a\\circ a\\ge 0$, creating asymmetry between positive and negative shocks due to convex balance sheet costs.\n- The condition that $I-\\alpha W$ be nonsingular is assured when $\\alpha\\,\\rho(W) < 1$, where $\\rho(W)$ is the spectral radius. The provided numerical cases satisfy this, including a near-boundary configuration where $\\alpha\\,\\rho(W)$ is close to $1$.\n\nAlgorithmic implementation for each test case:\n- Form $A = I - \\alpha W$.\n- Solve $A\\,a = W\\,u$ for $a$.\n- Compute $v = \\gamma\\,(a\\circ a)$ and solve $A\\,b = W\\,v$ for $b$.\n- Evaluate $\\widehat{\\ell}(s) = a\\,s + b\\,s^{2}$.\n- Round each component to $6$ decimal places and report the vector.\n\nApplying this procedure to each of the four specified test cases produces the requested list of vectors in the final output format, with no spaces and each component rounded to $6$ decimal places.", "answer": "```python\nimport numpy as np\n\ndef second_order_approx(W, alpha, gamma, u, s):\n    \"\"\"\n    Compute the second-order perturbation approximation:\n    l_hat(s) = a*s + b*s^2\n    where:\n      (I - alpha W) a = W u\n      (I - alpha W) b = W [ gamma (a◦a) ]\n    \"\"\"\n    W = np.array(W, dtype=float)\n    u = np.array(u, dtype=float).reshape(-1)\n    n = W.shape[0]\n    I = np.eye(n)\n    A = I - alpha * W\n    # Solve for a\n    rhs_a = W @ u\n    a = np.linalg.solve(A, rhs_a)\n    # Solve for b\n    v = gamma * (a * a)\n    rhs_b = W @ v\n    b = np.linalg.solve(A, rhs_b)\n    # Evaluate approximation\n    l_hat = a * s + b * (s ** 2)\n    return l_hat\n\ndef format_vector(vec):\n    # Format a 1D numpy array as a bracketed list with 6 decimal places, no spaces\n    return \"[\" + \",\".join(f\"{x:.6f}\" for x in vec) + \"]\"\n\ndef solve():\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"W\": [\n                [0.0, 0.3, 0.2],\n                [0.25, 0.0, 0.15],\n                [0.1, 0.2, 0.0]\n            ],\n            \"alpha\": 0.8,\n            \"gamma\": 0.7,\n            \"u\": [1.0, 0.0, 0.0],\n            \"s\": 0.05\n        },\n        # Test case 2\n        {\n            \"W\": [\n                [0.0, 0.45, 0.45],\n                [0.45, 0.0, 0.45],\n                [0.45, 0.45, 0.0]\n            ],\n            \"alpha\": 1.05,\n            \"gamma\": 0.5,\n            \"u\": [0.0, 1.0, 0.0],\n            \"s\": 0.02\n        },\n        # Test case 3 (gamma = 0)\n        {\n            \"W\": [\n                [0.0, 0.2, 0.1, 0.0],\n                [0.1, 0.0, 0.1, 0.1],\n                [0.05, 0.1, 0.0, 0.1],\n                [0.0, 0.1, 0.1, 0.0]\n            ],\n            \"alpha\": 0.9,\n            \"gamma\": 0.0,\n            \"u\": [0.6, 0.4, 0.0, 0.0],\n            \"s\": 0.03\n        },\n        # Test case 4 (negative shock)\n        {\n            \"W\": [\n                [0.0, 0.3, 0.2],\n                [0.25, 0.0, 0.15],\n                [0.1, 0.2, 0.0]\n            ],\n            \"alpha\": 0.8,\n            \"gamma\": 0.7,\n            \"u\": [0.0, 0.0, 1.0],\n            \"s\": -0.05\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        W = case[\"W\"]\n        alpha = case[\"alpha\"]\n        gamma = case[\"gamma\"]\n        u = case[\"u\"]\n        s = case[\"s\"]\n        l_hat = second_order_approx(W, alpha, gamma, u, s)\n        results.append(format_vector(l_hat))\n\n    # Final print statement in the exact required format: list of lists, no spaces.\n    print(\"[\" + \",\".join(results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "Building on the core mechanics, this exercise focuses on the economic interpretation of the second-order terms within a standard neoclassical growth model. You will derive the second-order derivatives of the capital accumulation rule and investigate how they change when the production technology shifts from Cobb-Douglas to Constant Elasticity of Substitution (CES). This practice [@problem_id:2428838] illuminates how fundamental parameters like the elasticity of substitution influence the model's curvature and its response to risk, directly connecting abstract derivatives to concepts like precautionary savings.", "id": "2428838", "problem": "Consider a discrete-time capital accumulation economy with inelastic labor supply normalized to one. Let the law of motion for capital be given by the map $g$ defined as $k_{t+1} = g(k_t,s_t)$, where $k_t$ is capital at time $t$ and $s_t$ is the technology shock at time $t$. Technology $z_t$ enters multiplicatively as $z_t = \\exp(s_t)$. The capital accumulation map is\n$$\ng(k,s) = \\bar{s}\\,\\exp(s)\\,F(k) + (1 - \\delta)\\,k,\n$$\nwhere $\\bar{s} \\in (0,1)$ is a constant saving rate and $\\delta \\in (0,1)$ is the depreciation rate. The production function $F$ is Constant Elasticity of Substitution (CES) with unit labor, parameterized by an elasticity of substitution $\\sigma \\in (0,\\infty)$ and a share parameter $\\nu \\in (0,1)$ as follows. For $\\sigma \\neq 1$, let $\\rho = 1 - \\frac{1}{\\sigma}$ and define\n$$\nF(k) = \\left(\\nu\\,k^{\\rho} + (1-\\nu)\\right)^{\\tfrac{1}{\\rho}}.\n$$\nFor $\\sigma = 1$, interpret the production function as the Cobb–Douglas limit\n$$\nF(k) = k^{\\nu}.\n$$\nAssume the exogenous technology shock follows a stationary Autoregressive of order $1$ (AR(1)) process, $s_{t+1} = \\varphi\\, s_t + \\sigma_{\\varepsilon}\\,\\varepsilon_{t+1}$, where $|\\varphi|<1$, $\\sigma_{\\varepsilon} > 0$, and $\\varepsilon_{t+1}$ is independent and identically distributed standard normal with zero mean and unit variance.\n\nWork in levels and focus on a deterministic steady state $(\\bar{k},\\bar{s})$ with $\\bar{s} = 0$ and constant technology $\\exp(\\bar{s}) = 1$. The deterministic steady state $\\bar{k}>0$ is defined by the fixed point condition under $\\bar{s}=0$:\n$$\n\\bar{k} = \\bar{s}\\,F(\\bar{k}) + (1-\\delta)\\,\\bar{k},\n$$\nwhich is equivalent to\n$$\n\\delta\\,\\bar{k} = \\bar{s}\\,F(\\bar{k}).\n$$\n\nDefine the second-order partial derivatives of the map $g$ at the steady state $(\\bar{k},0)$ as $g_{kk}(\\bar{k},0) = \\left.\\frac{\\partial^2 g}{\\partial k^2}\\right|_{(k,s)=(\\bar{k},0)}$, $g_{ks}(\\bar{k},0) = \\left.\\frac{\\partial^2 g}{\\partial k\\,\\partial s}\\right|_{(k,s)=(\\bar{k},0)}$, and $g_{ss}(\\bar{k},0) = \\left.\\frac{\\partial^2 g}{\\partial s^2}\\right|_{(k,s)=(\\bar{k},0)}$. For the stochastic environment, approximate the unconditional variance of $s_t$ by the stationary value $\\mathbb{V}\\mathrm{ar}(s_t) = \\sigma_{\\varepsilon}^2/(1-\\varphi^2)$. Using the second-order Taylor expansion of $\\exp(s)$ around $s=0$, define the risk-induced drift correction in expected next-period capital at the steady state by\n$$\n\\Delta(\\bar{k}) = \\frac{1}{2}\\,g_{ss}(\\bar{k},0)\\,\\frac{\\sigma_{\\varepsilon}^2}{1-\\varphi^2}.\n$$\n\nYour task is to, for each parameter set in the test suite below, compute the deterministic steady state $\\bar{k}$, then evaluate $g_{kk}(\\bar{k},0)$, $g_{ks}(\\bar{k},0)$, $g_{ss}(\\bar{k},0)$, and the drift correction $\\Delta(\\bar{k})$ as defined above.\n\nTest Suite:\n- Case A (Cobb–Douglas baseline): $\\bar{s} = 0.2$, $\\delta = 0.08$, $\\nu = 0.33$, $\\sigma = 1.0$, $\\varphi = 0.9$, $\\sigma_{\\varepsilon} = 0.02$.\n- Case B (smaller elasticity): $\\bar{s} = 0.2$, $\\delta = 0.08$, $\\nu = 0.33$, $\\sigma = 0.8$, $\\varphi = 0.9$, $\\sigma_{\\varepsilon} = 0.02$.\n- Case C (much smaller elasticity): $\\bar{s} = 0.2$, $\\delta = 0.08$, $\\nu = 0.33$, $\\sigma = 0.5$, $\\varphi = 0.9$, $\\sigma_{\\varepsilon} = 0.02$.\n- Case D (near-Cobb–Douglas): $\\bar{s} = 0.2$, $\\delta = 0.08$, $\\nu = 0.33$, $\\sigma = 0.99$, $\\varphi = 0.9$, $\\sigma_{\\varepsilon} = 0.02$.\n\nAnswer format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The result for each case must itself be a list of four real numbers $[g_{kk}(\\bar{k},0), g_{ks}(\\bar{k},0), g_{ss}(\\bar{k},0), \\Delta(\\bar{k})]$ in this exact order. Aggregate these four-element lists for the four cases into a single outer list, preserving the order of cases A, B, C, D. For example, the output should look like $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$ where each $a_i,b_i,c_i,d_i$ is a real number.", "solution": "We begin by conducting a formal validation of the problem statement.\n\n### Step 1: Extract Givens\n\nThe provided problem statement contains the following definitions, parameters, and conditions:\n- Law of motion for capital: $k_{t+1} = g(k_t,s_t)$.\n- Capital accumulation map: $g(k,s) = \\bar{s}\\,\\exp(s)\\,F(k) + (1 - \\delta)\\,k$.\n- Constants and parameters: saving rate $\\bar{s} \\in (0,1)$, depreciation rate $\\delta \\in (0,1)$, elasticity of substitution $\\sigma \\in (0,\\infty)$, share parameter $\\nu \\in (0,1)$.\n- Production function $F(k)$:\n  - For $\\sigma \\neq 1$: $F(k) = \\left(\\nu\\,k^{\\rho} + (1-\\nu)\\right)^{\\tfrac{1}{\\rho}}$, with $\\rho = 1 - \\frac{1}{\\sigma}$.\n  - For $\\sigma = 1$: $F(k) = k^{\\nu}$ (Cobb–Douglas limit).\n- Exogenous shock process: $s_{t+1} = \\varphi\\, s_t + \\sigma_{\\varepsilon}\\,\\varepsilon_{t+1}$, with $|\\varphi|<1$, $\\sigma_{\\varepsilon} > 0$, and $\\varepsilon_{t+1} \\sim \\mathcal{N}(0,1)$.\n- Deterministic steady state: $(\\bar{k}, \\bar{s})$ where $\\bar{s} = 0$, and $\\bar{k} > 0$ satisfies the condition $\\delta\\,\\bar{k} = \\bar{s}\\,F(\\bar{k)$.\n- Quantities to compute: The second-order partial derivatives of $g(k,s)$ evaluated at the steady state $(\\bar{k},0)$: $g_{kk}(\\bar{k},0)$, $g_{ks}(\\bar{k},0)$, and $g_{ss}(\\bar{k},0)$.\n- Unconditional variance of the shock process: $\\mathbb{V}\\mathrm{ar}(s_t) = \\sigma_{\\varepsilon}^2/(1-\\varphi^2)$.\n- Risk-induced drift correction: $\\Delta(\\bar{k}) = \\frac{1}{2}\\,g_{ss}(\\bar{k},0)\\,\\frac{\\sigma_{\\varepsilon}^2}{1-\\varphi^2}$.\n- Test Suite: Four parameter sets (A, B, C, D) are specified for computation.\n\n### Step 2: Validate Using Extracted Givens\n\nWe now assess the problem's validity against established criteria.\n- **Scientifically Grounded**: The problem is set within the framework of a standard neoclassical growth model with a constant savings rate and stochastic technology, a fundamental construct in modern macroeconomics. The Constant Elasticity of Substitution (CES) production function and the first-order autoregressive (AR(1)) shock process are standard, well-understood components. The task of computing derivatives for a second-order approximation is a core technique in computational economics for analyzing the effects of risk. The problem is therefore scientifically sound.\n- **Well-Posed**: The problem is specified with mathematical precision. The steady-state condition $\\delta\\,\\bar{k} = \\bar{s}\\,F(\\bar{k})$ defines a nonlinear equation for $\\bar{k}$. For the given production functions and parameter constraints, a unique, positive, and stable steady state $\\bar{k}$ is expected to exist. The subsequent computation of partial derivatives and the drift correction are direct applications of calculus and substitution. The problem is well-posed.\n- **Objective**: The problem is stated using clear, quantitative, and unambiguous language. All terms are formally defined. The task is objective and does not involve subjective interpretation.\n\nNo flaws are found corresponding to the checklist items (Scientific Unsoundness, Non-Formalizable, Incomplete Setup, Unrealistic, Ill-Posed, Outside Scientific Verifiability).\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. We will now proceed with a complete, reasoned solution.\n\n### Derivation of Solution\n\nThe task is to compute the second-order partial derivatives of the capital accumulation map $g(k,s)$ at the deterministic steady state $(\\bar{k}, 0)$, and the resulting drift correction $\\Delta(\\bar{k})$. The map is given by:\n$$g(k,s) = \\bar{s}\\,\\exp(s)\\,F(k) + (1 - \\delta)\\,k$$\n\nThe first-order partial derivatives are:\n$$g_k(k,s) = \\frac{\\partial g}{\\partial k} = \\bar{s}\\,\\exp(s)\\,F'(k) + (1 - \\delta)$$\n$$g_s(k,s) = \\frac{\\partial g}{\\partial s} = \\bar{s}\\,\\exp(s)\\,F(k)$$\n\nThe second-order partial derivatives are:\n$$g_{kk}(k,s) = \\frac{\\partial^2 g}{\\partial k^2} = \\bar{s}\\,\\exp(s)\\,F''(k)$$\n$$g_{ks}(k,s) = \\frac{\\partial^2 g}{\\partial k \\partial s} = \\bar{s}\\,\\exp(s)\\,F'(k)$$\n$$g_{ss}(k,s) = \\frac{\\partial^2 g}{\\partial s^2} = \\bar{s}\\,\\exp(s)\\,F(k)$$\n\nEvaluating these derivatives at the steady state $(k,s) = (\\bar{k},0)$ and using $\\exp(0)=1$:\n$$g_{kk}(\\bar{k},0) = \\bar{s}\\,F''(\\bar{k})$$\n$$g_{ks}(\\bar{k},0) = \\bar{s}\\,F'(\\bar{k})$$\n$$g_{ss}(\\bar{k},0) = \\bar{s}\\,F(\\bar{k})$$\n\nThe steady-state condition is $\\delta\\,\\bar{k} = \\bar{s}\\,F(\\bar{k})$. This provides a crucial simplification for $g_{ss}$:\n$$g_{ss}(\\bar{k},0) = \\delta\\,\\bar{k}$$\nThe drift correction term $\\Delta(\\bar{k})$ is then:\n$$\\Delta(\\bar{k}) = \\frac{1}{2}\\,g_{ss}(\\bar{k},0)\\,\\frac{\\sigma_{\\varepsilon}^2}{1-\\varphi^2} = \\frac{1}{2}\\,\\delta\\,\\bar{k}\\,\\frac{\\sigma_{\\varepsilon}^2}{1-\\varphi^2}$$\n\nWe now derive expressions for $g_{kk}$ and $g_{ks}$ for the two specified functional forms of $F(k)$.\n\n**Case 1: Cobb-Douglas Production Function ($\\sigma = 1$)**\nHere, $F(k) = k^{\\nu}$.\nThe steady state $\\bar{k}$ is found by solving $\\delta\\,\\bar{k} = \\bar{s}\\,\\bar{k}^{\\nu}$:\n$$\\bar{k}^{1-\\nu} = \\frac{\\bar{s}}{\\delta} \\implies \\bar{k} = \\left(\\frac{\\bar{s}}{\\delta}\\right)^{\\frac{1}{1-\\nu}}$$\nThe derivatives of $F(k)$ are $F'(k) = \\nu\\,k^{\\nu-1}$ and $F''(k) = \\nu(\\nu-1)\\,k^{\\nu-2}$.\nWe find simpler expressions for the required quantities at steady state.\nFor $g_{ks}$, we substitute the marginal product to average product ratio, $F'(\\bar{k}) = \\nu F(\\bar{k})/\\bar{k}$:\n$$g_{ks}(\\bar{k},0) = \\bar{s}\\,F'(\\bar{k}) = \\bar{s}\\,\\nu\\,\\frac{F(\\bar{k})}{\\bar{k}}$$\nUsing the steady-state condition $F(\\bar{k})/\\bar{k} = \\delta/\\bar{s}$:\n$$g_{ks}(\\bar{k},0) = \\bar{s}\\,\\nu\\,\\left(\\frac{\\delta}{\\bar{s}}\\right) = \\nu\\,\\delta$$\nFor $g_{kk}$, we use the relation $F''(\\bar{k}) = (\\nu-1)F'(\\bar{k})/\\bar{k}$:\n$$g_{kk}(\\bar{k},0) = \\bar{s}\\,F''(\\bar{k}) = \\bar{s}\\,\\frac{\\nu-1}{\\bar{k}}F'(\\bar{k}) = \\frac{\\nu-1}{\\bar{k}}\\,g_{ks}(\\bar{k},0) = \\frac{\\nu(\\nu-1)\\delta}{\\bar{k}}$$\n\n**Case 2: CES Production Function ($\\sigma \\neq 1$)**\nHere, $F(k) = (\\nu\\,k^{\\rho} + 1-\\nu)^{1/\\rho}$ with $\\rho = 1-1/\\sigma$.\nThe steady-state capital stock $\\bar{k}$ must be determined numerically by finding the root of the nonlinear equation:\n$$\\bar{s}\\,(\\nu\\,\\bar{k}^{\\rho} + 1-\\nu)^{1/\\rho} - \\delta\\,\\bar{k} = 0$$\nThe derivative $F'(k)$ is given by $F'(k) = \\nu\\,k^{\\rho-1}[F(k)]^{1-\\rho}$.\nTherefore, $g_{ks}$ at steady state is:\n$$g_{ks}(\\bar{k},0) = \\bar{s}\\,F'(\\bar{k}) = \\bar{s}\\,\\nu\\,\\bar{k}^{\\rho-1}[F(\\bar{k})]^{1-\\rho}$$\nSubstituting $F(\\bar{k}) = \\delta\\bar{k}/\\bar{s}$:\n$$g_{ks}(\\bar{k},0) = \\bar{s}\\,\\nu\\,\\bar{k}^{\\rho-1}\\left(\\frac{\\delta\\bar{k}}{\\bar{s}}\\right)^{1-\\rho} = \\bar{s}\\,\\nu\\,\\bar{k}^{\\rho-1}\\left(\\frac{\\delta}{\\bar{s}}\\right)^{1-\\rho}\\bar{k}^{1-\\rho} = \\nu\\,\\bar{s}^{1-(1-\\rho)}\\delta^{1-\\rho} = \\nu\\,\\bar{s}^{\\rho}\\delta^{1-\\rho}$$\nThe second derivative $F''(k)$ can be shown to be $F''(k) = -\\frac{\\nu(1-\\nu)}{\\sigma} k^{\\rho-2}[F(k)]^{1-2\\rho}$.\nTherefore, $g_{kk}$ at steady state is:\n$$g_{kk}(\\bar{k},0) = \\bar{s}\\,F''(\\bar{k}) = -\\frac{\\bar{s}\\,\\nu(1-\\nu)}{\\sigma} \\bar{k}^{\\rho-2}[F(\\bar{k})]^{1-2\\rho}$$\nSubstituting $F(\\bar{k}) = \\delta\\bar{k}/\\bar{s}$:\n$$g_{kk}(\\bar{k},0) = -\\frac{\\bar{s}\\,\\nu(1-\\nu)}{\\sigma} \\bar{k}^{\\rho-2}\\left(\\frac{\\delta\\bar{k}}{\\bar{s}}\\right)^{1-2\\rho} = -\\frac{\\nu(1-\\nu)}{\\sigma} \\bar{s}^{1-(1-2\\rho)}\\delta^{1-2\\rho}\\bar{k}^{(\\rho-2)+(1-2\\rho)}$$\n$$g_{kk}(\\bar{k},0) = -\\frac{\\nu(1-\\nu)}{\\sigma} \\bar{s}^{2\\rho}\\delta^{1-2\\rho}\\bar{k}^{-(1+\\rho)}$$\n\nThe algorithm will proceed by applying these derived analytical formulas for each set of parameters provided in the test suite. For the CES case, a numerical root-finding procedure is employed to determine $\\bar{k}$.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef calculate_quantities(params: dict) -> list[float]:\n    \"\"\"\n    Calculates the required economic quantities for a given parameter set.\n    \"\"\"\n    s_bar, delta, nu, sigma, phi, sigma_eps = (\n        params[\"s_bar\"],\n        params[\"delta\"],\n        params[\"nu\"],\n        params[\"sigma\"],\n        params[\"phi\"],\n        params[\"sigma_eps\"],\n    )\n\n    k_bar = 0.0\n    g_kk = 0.0\n    g_ks = 0.0\n    g_ss = 0.0\n    \n    # Use a small tolerance for floating point comparison of sigma\n    if abs(sigma - 1.0) < 1e-9:\n        # Cobb-Douglas case (sigma = 1)\n        # Analytical solution for steady-state capital\n        k_bar = (s_bar / delta) ** (1.0 / (1.0 - nu))\n        \n        # Simplified analytical formulas for derivatives\n        g_kk = nu * (nu - 1.0) * delta / k_bar\n        g_ks = nu * delta\n        g_ss = delta * k_bar\n        \n    else:\n        # CES case (sigma != 1)\n        rho = 1.0 - 1.0 / sigma\n\n        # Production function F(k) for the CES case\n        def F(k, nu_p, rho_p):\n            if k < 0: return -np.inf # Ensure domain\n            return (nu_p * k**rho_p + (1.0 - nu_p)) ** (1.0 / rho_p)\n\n        # Function whose root defines the steady-state capital\n        def steady_state_equation(k):\n            return s_bar * F(k, nu, rho) - delta * k\n        \n        # Find k_bar numerically.\n        # The Cobb-Douglas steady state is a good starting point for the search bracket.\n        k_guess = (s_bar / delta) ** (1.0 / (1.0 - nu))\n        bracket_low = max(1e-6, k_guess * 0.1)\n        bracket_high = k_guess * 10\n        sol = root_scalar(steady_state_equation, bracket=[bracket_low, bracket_high], method='brentq')\n        k_bar = sol.root\n\n        # Simplified analytical formulas for derivatives\n        g_kk = (\n            - (nu * (1.0 - nu) / sigma) \n            * (s_bar ** (2.0 * rho)) \n            * (delta ** (1.0 - 2.0 * rho)) \n            * (k_bar ** -(1.0 + rho))\n        )\n        g_ks = nu * (s_bar ** rho) * (delta ** (1.0 - rho))\n        g_ss = delta * k_bar\n\n    # Calculate the risk-induced drift correction\n    var_s = sigma_eps**2 / (1.0 - phi**2)\n    delta_k = 0.5 * g_ss * var_s\n\n    return [g_kk, g_ks, g_ss, delta_k]\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Cobb-Douglas baseline\n        {\"s_bar\": 0.2, \"delta\": 0.08, \"nu\": 0.33, \"sigma\": 1.0, \"phi\": 0.9, \"sigma_eps\": 0.02},\n        # Case B: smaller elasticity\n        {\"s_bar\": 0.2, \"delta\": 0.08, \"nu\": 0.33, \"sigma\": 0.8, \"phi\": 0.9, \"sigma_eps\": 0.02},\n        # Case C: much smaller elasticity\n        {\"s_bar\": 0.2, \"delta\": 0.08, \"nu\": 0.33, \"sigma\": 0.5, \"phi\": 0.9, \"sigma_eps\": 0.02},\n        # Case D: near-Cobb-Douglas\n        {\"s_bar\": 0.2, \"delta\": 0.08, \"nu\": 0.33, \"sigma\": 0.99, \"phi\": 0.9, \"sigma_eps\": 0.02},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_quantities(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format [[a,b],[c,d]] is produced by str() on a list of lists.\n    # We remove whitespace for a compact representation.\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"}, {"introduction": "In our final practice, we bring all the pieces together to demonstrate one of the primary motivations for using second-order methods: analyzing asymmetric dynamics. You will implement a full-scale simulation of a non-linear model using a second-order approximated policy function, which you will first derive using the implicit function theorem. By computing Generalized Impulse Response Functions (GIRFs) [@problem_id:2428798], you will be able to quantitatively measure how the economy's response to a positive shock differs from its response to a negative one, a hallmark of non-linearity that first-order methods cannot capture.", "id": "2428798", "problem": "You are asked to design and implement a program that computes Generalized Impulse Response Functions (GIRFs) for a nonlinear capital accumulation model subject to a stochastic technology process, using a second-order perturbation method around the deterministic steady state. The goal is to quantify and report the asymmetry between the responses to a positive versus a negative one-standard-deviation technology shock, and to do so across a small suite of parameter configurations.\n\nThe economic environment is a simple nonlinear production-investment model without intertemporal optimization. The model features adjustment costs that make the law of motion implicit and nonlinear, a standard Cobb-Douglas production function, and a mean-reverting technology process. The model is specified as follows.\n\n- State dynamics. Let $k_t$ denote capital at the end of period $t$, and let $z_t$ denote the (log) technology at time $t$. Let $A_t = \\exp(z_t)$ denote the level of technology. Given a fixed savings rate $s \\in (0,1)$ and a quadratic adjustment cost, capital evolves implicitly via\n$$\nF(i,k,z) \\equiv i - (1-\\delta) k - s \\,\\exp(z)\\, k^{\\alpha} + \\frac{\\phi}{2}\\,\\frac{(i-k)^2}{k} = 0,\n$$\nwhere $i \\equiv k_{t}$, $k \\equiv k_{t-1}$, $z \\equiv z_t$, $\\delta \\in (0,1)$ is the depreciation rate, $\\alpha \\in (0,1)$ is the output elasticity of capital, and $\\phi \\ge 0$ is the adjustment cost parameter. Output is defined by\n$$\ny_t = \\exp(z_t)\\, k_{t-1}^{\\alpha}.\n$$\n\n- Technology process. The technology follows a stationary autoregressive process of order one with independent and identically distributed Gaussian innovations:\n$$\nz_{t+1} = \\rho\\, z_t + \\sigma\\, \\epsilon_{t+1}, \\quad \\epsilon_{t+1} \\sim \\mathcal{N}(0,1),\n$$\nwith persistence $\\rho \\in (-1,1)$ and standard deviation $\\sigma > 0$. All angles are linear measures; no angle units are involved. There are no physical units required for the variables; report all numerical results as unit-free real numbers.\n\n- Steady state. The deterministic steady state sets $z=0$, $i=k=\\bar{k}$, and $z=0$. With the adjustment cost at the steady state equal to zero, the steady state $\\bar{k}$ solves\n$$\n\\delta \\,\\bar{k} = s\\, \\bar{k}^{\\alpha} \\quad \\Longrightarrow \\quad \\bar{k} = \\left(\\frac{s}{\\delta}\\right)^{\\frac{1}{1-\\alpha}}.\n$$\n\nSecond-order perturbation around the steady state. Define the implicit solution $i = h(k,z)$ to $F(i,k,z)=0$. A second-order perturbation approximation to the policy function $h(k,z)$ around $(\\bar{k},0)$ is the second-order Taylor expansion\n$$\nh(k,z) \\approx \\bar{k} + h_k \\,(k-\\bar{k}) + h_z \\, z + \\frac{1}{2}\\left[ h_{kk}\\,(k-\\bar{k})^2 + 2h_{kz}\\,(k-\\bar{k})\\, z + h_{zz}\\, z^2 \\right],\n$$\nwhere the derivatives $h_k$, $h_z$, $h_{kk}$, $h_{kz}$, and $h_{zz}$ are evaluated at $(\\bar{k},0)$ and are obtained using the implicit function theorem from derivatives of $F(i,k,z)$ at $(i,k,z)=(\\bar{k},\\bar{k},0)$.\n\nGeneralized Impulse Response Functions. For a given horizon $H \\in \\mathbb{N}$ and number of Monte Carlo paths $R \\in \\mathbb{N}$, the GIRF of a variable $v_t$ to an initial shock $\\epsilon_0$ at time $t=0$ is defined for horizon $h \\in \\{0,1,\\dots,H\\}$ as\n$$\n\\text{GIRF}_v(h;\\epsilon_0) \\equiv \\mathbb{E}\\left[ v_{t+h} \\,\\middle|\\, \\epsilon_0, \\text{ initial at steady state}, \\{\\epsilon_j\\}_{j\\ge 1} \\right] - \\mathbb{E}\\left[ v_{t+h} \\,\\middle|\\, \\epsilon_0 = 0, \\text{ initial at steady state}, \\{\\epsilon_j\\}_{j\\ge 1} \\right],\n$$\nwhere the expectations are taken over future shocks $\\{\\epsilon_j\\}_{j\\ge 1}$, which are drawn identically in both the shocked and baseline paths to isolate the effect of the initial innovation. In this problem, set $v_t = y_t$ and take $\\epsilon_0 \\in \\{+1,-1\\}$. The GIRFs are generated by simulating the second-order approximated model for $R$ Monte Carlo paths under a given parameterization, starting from $(k_{-1}, z_{-1}) = (\\bar{k},0)$, using the same random seeds for the future innovations in the shocked and baseline paths. Use the second-order approximation $h(k,z)$ to propagate capital, and the exact formula for $z_{t+1}$.\n\nAsymmetry measure. To highlight asymmetry between responses to positive and negative shocks, compute\n$$\n\\mathcal{A} \\equiv \\max_{0 \\le h \\le H} \\left| \\text{GIRF}_y(h; +1) + \\text{GIRF}_y(h; -1) \\right|.\n$$\nIn a linear-symmetric model, one expects $\\text{GIRF}_y(h; -1) \\approx -\\text{GIRF}_y(h; +1)$, so $\\mathcal{A}$ would be close to zero. Nonlinearity captured by the second-order approximation typically produces $\\mathcal{A} > 0$.\n\nYour task. Derive the needed derivatives from first principles and implement a program that\n- computes the steady state $\\bar{k}$,\n- computes the derivatives needed for the second-order approximation to $h(k,z)$ at $(\\bar{k},0)$,\n- simulates the model using the second-order approximation to produce the GIRFs of $y_t$ for $\\epsilon_0=+1$ and $\\epsilon_0=-1$,\n- computes and reports the asymmetry measure $\\mathcal{A}$ for each of the parameter sets in the test suite below.\n\nTest suite. Use the following parameter sets, each defining a separate test case. For each case, set $H=20$ and $R=5000$ Monte Carlo paths. The parameters are:\n- Case A (nonlinear adjustment costs, moderate volatility): $(\\alpha,\\delta,s,\\phi,\\rho,\\sigma) = (0.33,\\,0.08,\\,0.25,\\,4.0,\\,0.90,\\,0.02)$.\n- Case B (no adjustment costs, same volatility): $(\\alpha,\\delta,s,\\phi,\\rho,\\sigma) = (0.33,\\,0.08,\\,0.25,\\,0.0,\\,0.90,\\,0.02)$.\n- Case C (nonlinear adjustment costs, low volatility): $(\\alpha,\\delta,s,\\phi,\\rho,\\sigma) = (0.33,\\,0.08,\\,0.25,\\,4.0,\\,0.90,\\,0.002)$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\mathcal{A}_{\\text{A}}, \\mathcal{A}_{\\text{B}}, \\mathcal{A}_{\\text{C}}]$, where each entry is a real number. For example, a valid output line looks like\n\"[0.012345,0.006789,0.001234]\".", "solution": "The problem requires the computation of an asymmetry measure for Generalized Impulse Response Functions (GIRFs) in a nonlinear capital accumulation model. This is to be achieved by employing a second-order perturbation method. The analysis proceeds in two main stages: first, the derivation of the second-order accurate policy function for capital accumulation, and second, the simulation of the model to generate GIRFs and the asymmetry measure.\n\n**Step 1: Model Specification and Steady State**\n\nThe economic model is described by the following equations:\nThe law of motion for capital $k_t$ is given implicitly by:\n$$F(k_t, k_{t-1}, z_t) \\equiv k_t - (1-\\delta) k_{t-1} - s \\exp(z_t) k_{t-1}^{\\alpha} + \\frac{\\phi}{2} \\frac{(k_t - k_{t-1})^2}{k_{t-1}} = 0$$\nwhere $z_t$ is the log-technology process, which follows a first-order autoregressive process:\n$$z_{t+1} = \\rho z_t + \\sigma \\epsilon_{t+1}, \\quad \\epsilon_{t+1} \\sim \\mathcal{N}(0,1)$$\nOutput $y_t$ is given by a Cobb-Douglas production function:\n$$y_t = \\exp(z_t) k_{t-1}^{\\alpha}$$\nThe deterministic steady state is characterized by $z_t = 0$ and $k_t = k_{t-1} = \\bar{k}$ for all $t$. Substituting these into the capital accumulation equation yields the steady-state capital stock $\\bar{k}$:\n$$\\bar{k} - (1-\\delta)\\bar{k} - s \\bar{k}^{\\alpha} = 0 \\implies \\delta \\bar{k} = s \\bar{k}^{\\alpha}$$\nSolving for $\\bar{k}$ gives:\n$$\\bar{k} = \\left(\\frac{s}{\\delta}\\right)^{\\frac{1}{1-\\alpha}}$$\n\n**Step 2: Second-Order Perturbation via Implicit Function Theorem**\n\nWe seek a second-order Taylor approximation of the policy function $i = h(k,z)$ around the steady state $(k,z)=(\\bar{k},0)$, where we use the notation $i=k_t$ and $k=k_{t-1}$. The implicit function is $F(i,k,z) = 0$. The derivatives of $h$ are found by repeatedly differentiating the identity $F(h(k,z), k, z) = 0$. All derivatives are evaluated at the steady state $(i,k,z)=(\\bar{k},\\bar{k},0)$.\n\nFirst, we calculate the necessary partial derivatives of $F(i,k,z)$:\n$F_i = 1 + \\phi\\frac{i-k}{k} \\implies F_i\\vert_{ss} = 1$\n$F_k = -(1-\\delta) - s\\alpha e^z k^{\\alpha-1} - \\phi\\frac{i-k}{k} - \\frac{\\phi}{2}\\frac{(i-k)^2}{k^2} \\implies F_k\\vert_{ss} = -(1-\\delta) - s\\alpha\\bar{k}^{\\alpha-1} = -(1-\\delta(1-\\alpha))$\n$F_z = -se^z k^\\alpha \\implies F_z\\vert_{ss} = -s\\bar{k}^\\alpha = -\\delta\\bar{k}$\n\n$F_{ii} = \\frac{\\phi}{k} \\implies F_{ii}\\vert_{ss} = \\frac{\\phi}{\\bar{k}}$\n$F_{ik} = -\\frac{\\phi i}{k^2} \\implies F_{ik}\\vert_{ss} = -\\frac{\\phi}{\\bar{k}}$\n$F_{iz} = 0$\n$F_{kk} = -s\\alpha(\\alpha-1)e^z k^{\\alpha-2} + \\frac{\\phi}{k} \\implies F_{kk}\\vert_{ss} = -s\\alpha(\\alpha-1)\\bar{k}^{\\alpha-2} + \\frac{\\phi}{\\bar{k}} = -\\frac{\\delta\\alpha(\\alpha-1)}{\\bar{k}} + \\frac{\\phi}{\\bar{k}}$\n$F_{kz} = -s\\alpha e^z k^{\\alpha-1} \\implies F_{kz}\\vert_{ss} = -s\\alpha\\bar{k}^{\\alpha-1} = -\\alpha\\delta$\n$F_{zz} = -se^z k^\\alpha \\implies F_{zz}\\vert_{ss} = -s\\bar{k}^\\alpha = -\\delta\\bar{k}$\n\nUsing the implicit function theorem, the first derivatives of $h(k,z)$ are:\n$h_k = -\\frac{F_k}{F_i} = 1-\\delta(1-\\alpha)$\n$h_z = -\\frac{F_z}{F_i} = \\delta\\bar{k}$\n\nThe second derivatives are found by differentiating the first-order conditions again:\n$F_i h_{kk} + F_{ii}h_k^2 + 2F_{ik}h_k + F_{kk} = 0 \\implies h_{kk} = -(F_{ii}h_k^2 + 2F_{ik}h_k + F_{kk})$\n$F_i h_{kz} + F_{ii}h_k h_z + F_{ik}h_z + F_{iz}h_k + F_{kz} = 0 \\implies h_{kz} = -(F_{ii}h_k h_z + F_{ik}h_z + F_{kz})$\n$F_i h_{zz} + F_{ii}h_z^2 + 2F_{iz}h_z + F_{zz} = 0 \\implies h_{zz} = -(F_{ii}h_z^2 + F_{zz})$\nSubstituting the derivatives of $F$ evaluated at the steady state gives:\n$h_{kk} = -\\left(\\frac{\\phi}{\\bar{k}}h_k^2 - \\frac{2\\phi}{\\bar{k}}h_k - \\frac{\\delta\\alpha(\\alpha-1)}{\\bar{k}} + \\frac{\\phi}{\\bar{k}}\\right) = -\\frac{1}{\\bar{k}}\\left(\\phi(h_k-1)^2 - \\delta\\alpha(\\alpha-1)\\right)$\n$h_{kz} = -\\left(\\frac{\\phi}{\\bar{k}}h_k h_z - \\frac{\\phi}{\\bar{k}}h_z - \\alpha\\delta\\right) = -\\frac{\\phi}{\\bar{k}}(h_k-1)h_z + \\alpha\\delta$\n$h_{zz} = -\\left(\\frac{\\phi}{\\bar{k}}h_z^2 - \\delta\\bar{k}\\right) = \\delta\\bar{k} - \\frac{\\phi}{\\bar{k}}h_z^2$\n\nThe second-order approximation of the policy function $k_t = h(k_{t-1}, z_t)$ around the steady state, expressed in terms of deviations $\\hat{k}_t = k_t - \\bar{k}$ and $z_t$, is:\n$$\\hat{k}_t \\approx h_k \\hat{k}_{t-1} + h_z z_t + \\frac{1}{2}h_{kk}\\hat{k}_{t-1}^2 + h_{kz}\\hat{k}_{t-1}z_t + \\frac{1}{2}h_{zz}z_t^2$$\n\n**Step 3: Simulation of Generalized Impulse Response Functions**\n\nThe GIRF for output $y_t$ at horizon $h$ to an initial shock $\\epsilon_0$ is computed as the difference between the expected path of the variable following the shock and its expected path in the absence of the shock (the baseline).\n$$ \\text{GIRF}_y(h;\\epsilon_0) = \\mathbb{E}[ y_h \\,|\\, \\epsilon_0, \\text{state}_{ -1}=(\\bar{k},0) ] - \\mathbb{E}[ y_h \\,|\\, \\epsilon_0=0, \\text{state}_{ -1}=(\\bar{k},0) ] $$\nThe expectation is over future shocks $\\{\\epsilon_j\\}_{j \\ge 1}$ and is approximated via Monte Carlo simulation over $R$ paths. The simulation procedure is as follows:\n1. For each parameter case, calculate $\\bar{k}$ and the derivatives of $h$.\n2. Generate $R$ paths of exogenous shocks $\\{\\epsilon_{r,h}\\}_{h=1}^H$ for $r=1,\\dots,R$. Use a fixed random seed for reproducibility.\n3. Simulate three scenarios for $R$ paths each: a baseline ($\\epsilon_0=0$), a positive shock ($\\epsilon_0=+1$), and a negative shock ($\\epsilon_0=-1$).\n4. For each scenario and each path $r$, starting with $(k_{-1,r}, z_{-1,r}) = (\\bar{k},0)$, iterate from $h=0$ to $H$:\n   a. Update the technology process: $z_{h,r} = \\rho z_{h-1,r} + \\sigma \\epsilon_{h,r}$. For $h=0$, $\\epsilon_{0,r}$ is deterministic for each scenario. For $h>0$, $\\epsilon_{h,r}$ is the pre-generated random shock, identical across scenarios.\n   b. Calculate output for period $h$: $y_{h,r} = \\exp(z_{h,r}) k_{h-1,r}^{\\alpha}$.\n   c. Update the capital stock using the second-order policy rule: $k_{h,r} = \\bar{k} + \\hat{k}_{h,r}$.\n5. Average the simulated output paths $y_{h,r}$ across all $R$ paths for each scenario to obtain $\\mathbb{E}[y_h]$.\n6. Compute $\\text{GIRF}_y(h;+1)$ and $\\text{GIRF}_y(h;-1)$ for $h=0,\\dots,H$.\n7. The asymmetry measure $\\mathcal{A}$ is then found by taking the maximum absolute value of the sum of the positive and negative shock responses over the horizon:\n$$ \\mathcal{A} = \\max_{0 \\le h \\le H} |\\text{GIRF}_y(h;+1) + \\text{GIRF}_y(h;-1)| $$\n\nThis procedure is implemented for each of the three test cases specified. The nonlinearity introduced by the second-order terms is expected to make $\\mathcal{A}$ greater than zero.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    \n    # Define test cases from the problem statement.\n    # (alpha, delta, s, phi, rho, sigma)\n    test_cases = [\n        (0.33, 0.08, 0.25, 4.0, 0.90, 0.02),  # Case A\n        (0.33, 0.08, 0.25, 0.0, 0.90, 0.02),  # Case B\n        (0.33, 0.08, 0.25, 4.0, 0.90, 0.002), # Case C\n    ]\n    \n    # Simulation parameters\n    H = 20\n    R = 5000\n    \n    results = []\n    for params in test_cases:\n        result = compute_asymmetry(params, H, R, seed=42)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\ndef compute_asymmetry(params, H, R, seed=0):\n    \"\"\"\n    Computes the GIRF asymmetry measure for a given set of model parameters.\n\n    Args:\n        params (tuple): A tuple of model parameters (alpha, delta, s, phi, rho, sigma).\n        H (int): The simulation horizon.\n        R (int): The number of Monte Carlo paths.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The computed asymmetry measure A.\n    \"\"\"\n    alpha, delta, s, phi, rho, sigma = params\n\n    # Step 1: Compute steady state\n    k_bar = (s / delta)**(1 / (1 - alpha))\n\n    # Step 2: Compute derivatives for second-order approximation\n    h_k = 1.0 - delta * (1.0 - alpha)\n    h_z = delta * k_bar\n    \n    # Note: h_kk = -1/k_bar * (phi*(h_k-1)**2 - delta*alpha*(1-alpha))\n    h_kk = (1.0 / k_bar) * (delta * alpha * (1.0 - alpha) - phi * (h_k - 1.0)**2)\n    \n    # Note: h_kz = alpha*delta - phi/k_bar * (h_k-1)*h_z\n    h_kz = alpha * delta - (phi / k_bar) * (h_k - 1.0) * h_z\n    \n    # Note: h_zz = delta*k_bar - phi/k_bar * h_z**2\n    h_zz = delta * k_bar - (phi / k_bar) * h_z**2\n\n    # Coefficients for the policy rule (including 1/2 factor)\n    H_kk_half = 0.5 * h_kk\n    H_zz_half = 0.5 * h_zz\n\n    # Step 3: Setup simulation\n    rng = np.random.default_rng(seed)\n    # Future shocks for t=1,...,H\n    future_shocks = rng.normal(size=(R, H))\n\n    # Dictionary to hold output paths for each scenario\n    y_paths = {'base': np.zeros((R, H + 1)), 'pos': np.zeros((R, H + 1)), 'neg': np.zeros((R, H + 1))}\n    \n    initial_shocks = {'base': 0.0, 'pos': 1.0, 'neg': -1.0}\n\n    # Step 4: Run simulation\n    for scenario, eps0 in initial_shocks.items():\n        # Initialize states at t=-1\n        k_prev = np.full(R, k_bar)\n        z_prev = np.zeros(R)\n\n        # Main simulation loop over time h=0,...,H\n        for h in range(H + 1):\n            # Update technology process\n            if h == 0:\n                z_curr = rho * z_prev + sigma * eps0\n            else:\n                shocks_h = future_shocks[:, h-1]\n                z_curr = rho * z_prev + sigma * shocks_h\n            \n            # Compute output y_h = exp(z_h) * k_{h-1}^alpha\n            y_paths[scenario][:, h] = np.exp(z_curr) * (k_prev**alpha)\n\n            # Compute new capital stock k_h = h(k_{h-1}, z_h) using 2nd order approximation\n            k_hat_prev = k_prev - k_bar\n            \n            k_hat_curr = (h_k * k_hat_prev + h_z * z_curr\n                          + H_kk_half * k_hat_prev**2 \n                          + h_kz * k_hat_prev * z_curr \n                          + H_zz_half * z_curr**2)\n            \n            k_curr = k_bar + k_hat_curr\n            \n            # Update states for next period\n            k_prev = k_curr\n            z_prev = z_curr\n\n    # Step 5: Compute GIRFs by averaging\n    y_exp_base = np.mean(y_paths['base'], axis=0)\n    y_exp_pos = np.mean(y_paths['pos'], axis=0)\n    y_exp_neg = np.mean(y_paths['neg'], axis=0)\n    \n    girf_pos = y_exp_pos - y_exp_base\n    girf_neg = y_exp_neg - y_exp_base\n\n    # Step 6: Compute asymmetry measure\n    asymmetry_h = np.abs(girf_pos + girf_neg)\n    \n    # Step 7: Return maximum asymmetry over horizon\n    return np.max(asymmetry_h)\n\nif __name__ == '__main__':\n    solve()\n```"}]}