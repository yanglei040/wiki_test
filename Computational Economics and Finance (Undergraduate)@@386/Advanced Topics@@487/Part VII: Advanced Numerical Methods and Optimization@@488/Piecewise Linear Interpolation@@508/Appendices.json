{"hands_on_practices": [{"introduction": "In many financial applications, we can calculate key metrics only at discrete points, such as an interest rate grid. This exercise [@problem_id:2419227] demonstrates a fundamental use of piecewise linear interpolation: to estimate a value between known data points. You will apply this technique to find the Internal Rate of Return ($IRR$) of a project, a common task in capital budgeting where the goal is to find the interest rate that makes the Net Present Value ($NPV$) zero.", "id": "2419227", "problem": "In capital budgeting within computational economics and finance, the net present value (NPV) of a deterministic project with cash flow sequence $\\{C_{0}, C_{1}, \\dots, C_{T}\\}$ discounted at rate $r$ is defined by the fundamental present value relation\n$$\n\\mathrm{NPV}(r) \\equiv \\sum_{t=0}^{T} \\frac{C_{t}}{(1+r)^{t}}.\n$$\nThe internal rate of return (IRR) is defined as the unique real number $r^{\\ast}$ (if it exists) such that $\\mathrm{NPV}(r^{\\ast})=0$.\n\nConsider a one-period project with cash flows $C_{0}=-100$ at time $t=0$ and $C_{1}=103.5$ at time $t=1$. Suppose an analyst computes the projectâ€™s $\\mathrm{NPV}(r)$ only at the discrete set of interest rates $r \\in \\{0.01,0.02,\\dots,0.10\\}$ and then uses a piecewise linear interpolation of $\\mathrm{NPV}(r)$ across adjacent grid points to estimate the IRR.\n\nUsing only the two consecutive grid rates that bracket the sign change of $\\mathrm{NPV}(r)$, construct the linear interpolant of $\\mathrm{NPV}(r)$ over that interval and solve for the interpolated IRR. Next, compute the true IRR exactly from first principles. Finally, report the absolute difference between the interpolated IRR and the true IRR as a single number. Express your final answer as an exact fraction (no rounding). Percentages must be expressed as decimals or fractions, not with a percentage sign.", "solution": "The problem statement is subjected to rigorous validation before any attempt at a solution.\n\nStep 1: Extract Givens\n-   Net Present Value (NPV) definition: $\\mathrm{NPV}(r) \\equiv \\sum_{t=0}^{T} \\frac{C_{t}}{(1+r)^{t}}$\n-   Internal Rate of Return (IRR) definition: The unique real number $r^{\\ast}$ such that $\\mathrm{NPV}(r^{\\ast}) = 0$.\n-   Project cash flows: $C_{0}=-100$ at $t=0$, $C_{1}=103.5$ at $t=1$.\n-   Project duration: $T=1$.\n-   Discrete set of interest rates for interpolation: $r \\in \\{0.01, 0.02, \\dots, 0.10\\}$.\n-   Task 1: Use piecewise linear interpolation between two consecutive grid rates that bracket the sign change of $\\mathrm{NPV}(r)$ to estimate the IRR ($r_{\\text{interp}}$).\n-   Task 2: Compute the true IRR ($r_{\\text{true}}$) exactly.\n-   Task 3: Report the absolute difference $|r_{\\text{interp}} - r_{\\text{true}}|$ as an exact fraction.\n\nStep 2: Validate Using Extracted Givens\nThe problem is evaluated against the required criteria.\n-   **Scientifically Grounded**: The concepts of NPV, IRR, and linear interpolation are standard and well-established in finance and numerical analysis. The premises are factually and mathematically sound.\n-   **Well-Posed**: The problem provides all necessary data and a clear, unambiguous objective. A unique solution exists and can be derived from the provided information.\n-   **Objective**: The problem is stated in precise, formal language, free of subjectivity or ambiguity.\n\nStep 3: Verdict and Action\nThe problem is valid. It is self-contained, scientifically sound, and well-posed. A solution will be derived.\n\nThe NPV for the given one-period project is:\n$$\n\\mathrm{NPV}(r) = C_{0} + \\frac{C_{1}}{1+r} = -100 + \\frac{103.5}{1+r}\n$$\n\nThe first step is to identify the interval over which to perform the linear interpolation. We must evaluate $\\mathrm{NPV}(r)$ at the specified grid points to find two consecutive rates, $r_{1}$ and $r_{2}$, such that $\\mathrm{NPV}(r_{1})$ and $\\mathrm{NPV}(r_{2})$ have opposite signs. The function $\\mathrm{NPV}(r)$ is a monotonically decreasing function of $r$ for $r > -1$.\n\nLet us evaluate at the grid points:\n$\\mathrm{NPV}(0.01) = -100 + \\frac{103.5}{1.01} \\approx 2.475 > 0$\n$\\mathrm{NPV}(0.02) = -100 + \\frac{103.5}{1.02} \\approx 1.471 > 0$\n$\\mathrm{NPV}(0.03) = -100 + \\frac{103.5}{1.03} = -100 + \\frac{10350}{103} = \\frac{-10300 + 10350}{103} = \\frac{50}{103} > 0$\n$\\mathrm{NPV}(0.04) = -100 + \\frac{103.5}{1.04} = -100 + \\frac{10350}{104} = \\frac{-10400 + 10350}{104} = -\\frac{50}{104} < 0$\n\nThe sign change occurs in the interval $[0.03, 0.04]$. Thus, we use the points $(r_{1}, \\mathrm{NPV}(r_{1}))$ and $(r_{2}, \\mathrm{NPV}(r_{2}))$, where $r_{1} = 0.03$ and $r_{2} = 0.04$. The corresponding NPV values are $\\mathrm{NPV}(r_{1}) = \\frac{50}{103}$ and $\\mathrm{NPV}(r_{2}) = -\\frac{50}{104}$.\n\nWe construct a linear interpolant, $L(r)$, passing through these two points. The interpolated IRR, which we denote $r_{\\text{interp}}$, is the root of this linear function, i.e., $L(r_{\\text{interp}}) = 0$. Using the formula for linear interpolation (or the secant method):\n$$\nr_{\\text{interp}} = r_{1} - \\mathrm{NPV}(r_{1}) \\frac{r_{2} - r_{1}}{\\mathrm{NPV}(r_{2}) - \\mathrm{NPV}(r_{1})}\n$$\nSubstituting the known values:\n$$\nr_{\\text{interp}} = 0.03 - \\left(\\frac{50}{103}\\right) \\frac{0.04 - 0.03}{\\left(-\\frac{50}{104}\\right) - \\left(\\frac{50}{103}\\right)} = 0.03 - \\left(\\frac{50}{103}\\right) \\frac{0.01}{-50 \\left(\\frac{1}{104} + \\frac{1}{103}\\right)}\n$$\n$$\nr_{\\text{interp}} = 0.03 + \\frac{1}{103} \\frac{0.01}{\\frac{103+104}{104 \\cdot 103}} = 0.03 + \\frac{0.01}{103} \\frac{104 \\cdot 103}{207} = 0.03 + 0.01 \\cdot \\frac{104}{207}\n$$\nExpressing as fractions:\n$$\nr_{\\text{interp}} = \\frac{3}{100} + \\frac{1}{100} \\cdot \\frac{104}{207} = \\frac{1}{100} \\left( 3 + \\frac{104}{207} \\right) = \\frac{1}{100} \\left( \\frac{3 \\cdot 207 + 104}{207} \\right)\n$$\n$$\nr_{\\text{interp}} = \\frac{1}{100} \\left( \\frac{621 + 104}{207} \\right) = \\frac{725}{20700}\n$$\nThis fraction can be simplified. Both numerator and denominator are divisible by $25$:\n$$\nr_{\\text{interp}} = \\frac{725 \\div 25}{20700 \\div 25} = \\frac{29}{828}\n$$\nNext, we compute the true IRR, $r_{\\text{true}}$, by setting $\\mathrm{NPV}(r_{\\text{true}})=0$:\n$$\n-100 + \\frac{103.5}{1+r_{\\text{true}}} = 0\n$$\n$$\n\\frac{103.5}{1+r_{\\text{true}}} = 100\n$$\n$$\n1+r_{\\text{true}} = \\frac{103.5}{100} = 1.035\n$$\n$$\nr_{\\text{true}} = 1.035 - 1 = 0.035\n$$\nAs an exact fraction:\n$$\nr_{\\text{true}} = \\frac{35}{1000} = \\frac{7}{200}\n$$\nFinally, we compute the absolute difference between the interpolated IRR and the true IRR:\n$$\n|r_{\\text{interp}} - r_{\\text{true}}| = \\left| \\frac{29}{828} - \\frac{7}{200} \\right|\n$$\nTo subtract the fractions, we find a common denominator. The prime factorizations are $828 = 2^{2} \\cdot 3^{2} \\cdot 23$ and $200 = 2^{3} \\cdot 5^{2}$. The least common multiple is $2^{3} \\cdot 3^{2} \\cdot 5^{2} \\cdot 23 = 8 \\cdot 9 \\cdot 25 \\cdot 23 = 41400$.\n$$\n|r_{\\text{interp}} - r_{\\text{true}}| = \\left| \\frac{29 \\cdot 50}{828 \\cdot 50} - \\frac{7 \\cdot 207}{200 \\cdot 207} \\right| = \\left| \\frac{1450}{41400} - \\frac{1449}{41400} \\right|\n$$\n$$\n|r_{\\text{interp}} - r_{\\text{true}}| = \\left| \\frac{1450 - 1449}{41400} \\right| = \\frac{1}{41400}\n$$\nThis is the required absolute difference as an exact fraction.", "answer": "$$\n\\boxed{\\frac{1}{41400}}\n$$"}, {"introduction": "When building financial models, it's not enough to just estimate values; we must ensure our methods respect fundamental no-arbitrage principles. This practice [@problem_id:2419232] explores the relationship between piecewise linear interpolation and the classic put-call parity for European options. By interpolating call and put prices independently, you will investigate whether this core no-arbitrage condition is preserved, revealing an important property of linear operators in finance.", "id": "2419232", "problem": "A quantitative research team must compute option values across strikes for a European option surface used in a risk engine. They decide to use piecewise linear interpolation in strike for calls and puts separately. Consider a single maturity with the following market inputs:\n\n- Underlying spot price $S_0 = 100$ (currency units).\n- Time to maturity $T = 0.5$ (years).\n- Continuously compounded risk-free rate $r = 0$ (per year).\n- Continuous dividend yield $q = 0$ (per year).\n- Observed mid-prices at strikes $K_1 = 95$ and $K_2 = 105$:\n  - Call prices: $C(95) = 9$, $C(105) = 4$.\n  - Put prices: $P(95) = 4$, $P(105) = 9$.\n\nUsing piecewise linear interpolation in strike $K$, independently interpolate the call and the put to the target strike $K^{\\ast} = 100$ to obtain $C_{\\text{lin}}(K^{\\ast})$ and $P_{\\text{lin}}(K^{\\ast})$. Then compute the put-call parity residual\n$$\nR \\equiv \\bigl(C_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast})\\bigr) - \\bigl(S_0 \\exp(-q T) - K^{\\ast} \\exp(-r T)\\bigr).\n$$\nReport the value of $R$ in currency units as a single real number. No rounding is required.", "solution": "The problem requires the computation of a put-call parity residual after performing piecewise linear interpolation of call and put option prices. First, the problem statement must be rigorously validated.\n\n**Problem Validation**\nThe givens are listed verbatim:\n- Underlying spot price $S_0 = 100$.\n- Time to maturity $T = 0.5$.\n- Continuously compounded risk-free rate $r = 0$.\n- Continuous dividend yield $q = 0$.\n- Observed mid-prices at strikes $K_1 = 95$ and $K_2 = 105$.\n- Call prices: $C(95) = 9$, $C(105) = 4$.\n- Put prices: $P(95) = 4$, $P(105) = 9$.\n- Target strike $K^{\\ast} = 100$.\n\nThe put-call parity relationship for European options is a fundamental principle in finance, given by:\n$$C(K) - P(K) = S_0 \\exp(-qT) - K \\exp(-rT)$$\nGiven the parameters $r = 0$ and $q = 0$, this relationship simplifies to:\n$$C(K) - P(K) = S_0 - K$$\nA critical step is to check if the provided market data is consistent with this principle.\nAt strike $K_1 = 95$:\nThe left-hand side is $C(95) - P(95) = 9 - 4 = 5$.\nThe right-hand side is $S_0 - K_1 = 100 - 95 = 5$.\nThe values are consistent.\n\nAt strike $K_2 = 105$:\nThe left-hand side is $C(105) - P(105) = 4 - 9 = -5$.\nThe right-hand side is $S_0 - K_2 = 100 - 105 = -5$.\nThe values are consistent.\n\nThe problem is scientifically grounded, as it is based on standard financial engineering principles and internally consistent data. It is well-posed, objective, and complete. Therefore, the problem is valid, and we shall proceed with the solution.\n\n**Solution Derivation**\nThe methodology specified is piecewise linear interpolation in strike $K$ for call and put prices independently. For a function $f(x)$ with known values at points $x_1$ and $x_2$, the linearly interpolated value at an intermediate point $x$ is given by the formula:\n$$f(x) = f(x_1) + (x - x_1) \\frac{f(x_2) - f(x_1)}{x_2 - x_1}$$\n\nFirst, we apply this formula to interpolate the call price $C(K)$ at the target strike $K^{\\ast} = 100$. The known data points are $(K_1, C(K_1)) = (95, 9)$ and $(K_2, C(K_2)) = (105, 4)$.\n$$\nC_{\\text{lin}}(K^{\\ast}) = C(K_1) + (K^{\\ast} - K_1) \\frac{C(K_2) - C(K_1)}{K_2 - K_1}\n$$\nSubstituting the numerical values:\n$$\nC_{\\text{lin}}(100) = 9 + (100 - 95) \\frac{4 - 9}{105 - 95} = 9 + (5) \\frac{-5}{10} = 9 - 2.5 = 6.5\n$$\n\nNext, we perform the same interpolation for the put price $P(K)$. The known data points are $(K_1, P(K_1)) = (95, 4)$ and $(K_2, P(K_2)) = (105, 9)$.\n$$\nP_{\\text{lin}}(K^{\\ast}) = P(K_1) + (K^{\\ast} - K_1) \\frac{P(K_2) - P(K_1)}{K_2 - K_1}\n$$\nSubstituting the numerical values:\n$$\nP_{\\text{lin}}(100) = 4 + (100 - 95) \\frac{9 - 4}{105 - 95} = 4 + (5) \\frac{5}{10} = 4 + 2.5 = 6.5\n$$\n\nThe final step is to compute the put-call parity residual $R$, as defined in the problem statement:\n$$\nR \\equiv \\bigl(C_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast})\\bigr) - \\bigl(S_0 \\exp(-q T) - K^{\\ast} \\exp(-r T)\\bigr)\n$$\nWe have the interpolated values $C_{\\text{lin}}(100) = 6.5$ and $P_{\\text{lin}}(100) = 6.5$. The first term of the residual is:\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = 6.5 - 6.5 = 0\n$$\nThe second term, which is the theoretical price difference from put-call parity at $K^{\\ast}$, is:\n$$\nS_0 \\exp(-q T) - K^{\\ast} \\exp(-r T) = 100 \\exp(-0 \\cdot 0.5) - 100 \\exp(-0 \\cdot 0.5) = 100 \\cdot 1 - 100 \\cdot 1 = 0\n$$\nSubstituting these results into the definition of $R$:\n$$\nR = 0 - 0 = 0\n$$\n\nThis result is not an accident of the specific numbers chosen. It illustrates a general property of linear operators. Since interpolation is a linear operation, and the put-call parity check is a linear functional of the prices, the property holds for the interpolated values if it holds at the endpoints.\nLet the interpolation weight be $w = \\frac{K^{\\ast} - K_1}{K_2 - K_1}$. The interpolated prices are:\n$$\nC_{\\text{lin}}(K^{\\ast}) = (1-w) C(K_1) + w C(K_2)\n$$\n$$\nP_{\\text{lin}}(K^{\\ast}) = (1-w) P(K_1) + w P(K_2)\n$$\nThe difference of the interpolated prices is a linear combination of the endpoint differences:\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = (1-w) [C(K_1) - P(K_1)] + w [C(K_2) - P(K_2)]\n$$\nGiven that the endpoints satisfy parity, $C(K) - P(K) = S_0 \\exp(-qT) - K \\exp(-rT)$, we substitute this relationship:\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = (1-w)[S_0 e^{-qT} - K_1 e^{-rT}] + w[S_0 e^{-qT} - K_2 e^{-rT}]\n$$\n$$\n= S_0 e^{-qT} - [(1-w)K_1 + wK_2]e^{-rT}\n$$\nBy definition of linear interpolation, $K^{\\ast} = (1-w)K_1 + wK_2$. Therefore,\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = S_0 e^{-qT} - K^{\\ast}e^{-rT}\n$$\nThis demonstrates that if the input data for interpolation is free of arbitrage (i.e., satisfies put-call parity), then the set of interpolated prices is also arbitrage-free in the same sense. The residual $R$ must therefore be identically zero. The numerical calculation confirms this general theoretical result.", "answer": "$$\\boxed{0}$$"}, {"introduction": "In sophisticated financial modeling, we often interpolate not the final prices, but the parameters that generate them, such as implied volatility. This advanced practice [@problem_id:2419249] delves into the critical task of constructing a valid volatility smile, a cornerstone of modern options pricing. By implementing a numerical check using butterfly spreads, you will discover how seemingly plausible interpolation choices can lead to models that contain arbitrage, highlighting the non-linear and subtle challenges in computational finance.", "id": "2419249", "problem": "Consider a single-maturity European call option market with spot price $S_0$, time to maturity $T$ (in years), continuously compounded risk-free rate $r$, and continuous dividend yield $\\delta$. A volatility smile is defined by specifying a finite set of strike-volatility nodes $\\{(K_i,\\sigma_i)\\}_{i=1}^m$ with strictly increasing strikes $K_1 &lt; K_2 &lt; \\cdots &lt; K_m$ and corresponding Blackâ€“Scholesâ€“Merton (BSM) implied volatilities $\\sigma_i &gt; 0$. For any strike $K$ with $K_1 \\le K \\le K_m$, define the implied volatility function $\\sigma(K)$ by piecewise linear interpolation on the nodes:\n- For $K \\in [K_i, K_{i+1}]$, let $\\sigma(K)$ be the unique affine function on $[K_i,K_{i+1}]$ satisfying $\\sigma(K_i)=\\sigma_i$ and $\\sigma(K_{i+1})=\\sigma_{i+1}$.\nNo extrapolation is needed because all evaluation strikes will lie within $[K_1,K_m]$.\n\nFor any strike $K$ and volatility $\\sigma(K)$, define the BSM European call price under zero interest rate and zero dividend yield by\n$$\nC(K) \\equiv S_0 \\, \\Phi(d_1) - K \\, \\Phi(d_2),\n$$\nwhere\n$$\nd_1 \\equiv \\frac{\\ln(S_0/K) + \\tfrac{1}{2}\\sigma(K)^2 T}{\\sigma(K)\\sqrt{T}}, \n\\quad\nd_2 \\equiv d_1 - \\sigma(K)\\sqrt{T},\n$$\nand $\\Phi(\\cdot)$ is the cumulative distribution function of the standard normal distribution. In a no-arbitrage setting, call prices as a function of strike are convex, which implies that for any equally spaced triplet of strikes $K-h$, $K$, $K+h$ (with $h&gt;0$), the butterfly spread price\n$$\nB(K;h) \\equiv C(K-h) - 2\\,C(K) + C(K+h)\n$$\nmust be nonnegative. A negative value indicates a violation of the no-arbitrage condition that butterfly spread prices must be positive (equivalently, a negative risk-neutral density at some strike).\n\nWrite a program that, for each of the following test cases, constructs $\\sigma(K)$ by piecewise linear interpolation on the provided nodes, computes $C(K)$ on an equally spaced strike grid, evaluates discrete butterfly spread prices over the interior grid points, and returns the minimum butterfly spread price found.\n\nUse the following fixed market inputs for all test cases:\n- $S_0 = 100$,\n- $T = 1$ (in years),\n- $r = 0$,\n- $\\delta = 0$.\n\nFor each test case:\n1. Let $K_{\\min} \\equiv K_1$ and $K_{\\max} \\equiv K_m$.\n2. Construct an equally spaced strike grid $\\{K_j\\}_{j=0}^{N-1}$ with $N=81$ points covering $[K_{\\min},K_{\\max}]$ inclusive, so that $K_0 = K_{\\min}$, $K_{N-1}=K_{\\max}$, and $K_{j+1}-K_j$ is constant for all $j$.\n3. Compute $C(K_j)$ for all $j=0,\\dots,N-1$ using the BSM formula with $\\sigma(K_j)$ defined by piecewise linear interpolation.\n4. For each interior index $j=1,\\dots,N-2$, compute the discrete butterfly spread price\n$$\nB_j \\equiv C(K_{j-1}) - 2\\,C(K_j) + C(K_{j+1}).\n$$\n5. Report the minimum butterfly spread price\n$$\nb_{\\min} \\equiv \\min_{1 \\le j \\le N-2} B_j.\n$$\nReturn $b_{\\min}$ rounded to six decimal places.\n\nTest suite (each case provides the node pairs $\\{(K_i,\\sigma_i)\\}$):\n- Case A (flat smile, general happy path): $(K,\\sigma)$ nodes\n  $$\n  \\{(70,0.20),(85,0.20),(100,0.20),(115,0.20),(130,0.20)\\}.\n  $$\n- Case B (spiky smile intended to violate no-arbitrage): $(K,\\sigma)$ nodes\n  $$\n  \\{(70,0.15),(85,0.15),(100,0.90),(115,0.15),(130,0.15)\\}.\n  $$\n- Case C (boundary coverage with minimal nodes and nonuniform smile): $(K,\\sigma)$ nodes\n  $$\n  \\{(80,0.18),(100,0.20),(120,0.22)\\}.\n  $$\n\nFinal output format:\n- Your program should produce a single line of output containing the three results $[b_{\\min}^{(A)}, b_{\\min}^{(B)}, b_{\\min}^{(C)}]$ as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places (e.g., \"[0.012345,-0.001234,0.000000]\").", "solution": "The problem presented is a well-posed and scientifically grounded exercise in computational finance, specifically concerning the verification of no-arbitrage conditions in an options market. All necessary parameters and definitions are provided, and the task is to implement a clearly specified numerical algorithm. The problem is therefore deemed valid and a full solution will be provided.\n\nThe core principle to be tested is the convexity of European call option prices with respect to the strike price. In an arbitrage-free market, the call price function, $C(K)$, must be convex in strike $K$. This implies that its second derivative, $\\frac{\\partial^2 C}{\\partial K^2}$, must be non-negative. This second derivative is directly related to the risk-neutral probability density function of the underlying asset's price at maturity, $T$, via the Breeden-Litzenberger formula: $\\frac{\\partial^2 C}{\\partial K^2} = e^{rT} p(S_T = K)$. A negative value for this derivative would imply a negative probability, which is a clear sign of an arbitrage opportunity.\n\nA discrete approximation to the second derivative is the butterfly spread, defined for a triplet of strikes $K-h$, $K$, and $K+h$ (with $h>0$) as:\n$$ B(K;h) \\equiv C(K-h) - 2C(K) + C(K+h) $$\nThe no-arbitrage condition requires $B(K;h) \\ge 0$. The problem asks us to check this condition on a discrete grid of strikes for specified volatility smiles.\n\nThe procedure is as follows:\n\n1.  **Model and Parameter Setup**: We are given the fixed market parameters: spot price $S_0 = 100$, time to maturity $T = 1$ year, risk-free rate $r = 0$, and dividend yield $\\delta = 0$. The Black-Scholes-Merton (BSM) price for a European call option under these conditions is:\n    $$ C(K) = S_0 \\Phi(d_1) - K \\Phi(d_2) $$\n    where $\\Phi(\\cdot)$ is the cumulative distribution function of the standard normal distribution, and the terms $d_1$ and $d_2$ are:\n    $$ d_1 = \\frac{\\ln(S_0/K) + \\frac{1}{2}\\sigma(K)^2 T}{\\sigma(K)\\sqrt{T}} $$\n    $$ d_2 = d_1 - \\sigma(K)\\sqrt{T} $$\n    The implied volatility, $\\sigma(K)$, is not constant but is a function of the strike price $K$.\n\n2.  **Implied Volatility Interpolation**: For each test case, the volatility smile is defined by a set of nodes $\\{(K_i, \\sigma_i)\\}_{i=1}^m$. For any strike $K$ within the range $[K_1, K_m]$, the value of $\\sigma(K)$ is determined by piecewise linear interpolation. If $K$ falls within an interval $[K_i, K_{i+1}]$, its volatility is given by the affine function:\n    $$ \\sigma(K) = \\sigma_i + \\frac{\\sigma_{i+1} - \\sigma_i}{K_{i+1} - K_i} (K - K_i) $$\n\n3.  **Numerical Evaluation Grid**: For each case, we define a evaluation range $[K_{\\min}, K_{\\max}]$, where $K_{\\min} = K_1$ and $K_{\\max} = K_m$. An equally spaced grid of $N=81$ strikes, $\\{K_j\\}_{j=0}^{N-1}$, is constructed over this range, where $K_0=K_{\\min}$ and $K_{N-1}=K_{\\max}$.\n\n4.  **Computation of Call Prices and Butterfly Spreads**: We proceed through a sequence of computations for each test case:\n    a. For each strike $K_j$ on the grid, we first calculate the corresponding implied volatility $\\sigma(K_j)$ using the piecewise linear interpolation function.\n    b. Using this $\\sigma(K_j)$, we compute the BSM call price $C(K_j)$. This results in a vector of call prices $\\{C(K_j)\\}_{j=0}^{N-1}$.\n    c. For each interior point of the grid, with index $j$ from $1$ to $N-2$, we compute the discrete butterfly spread price:\n       $$ B_j = C(K_{j-1}) - 2C(K_j) + C(K_{j+1}) $$\n    \n5.  **Arbitrage Detection**: The final step is to find the minimum value among all computed butterfly spreads:\n    $$ b_{\\min} = \\min_{1 \\le j \\le N-2} B_j $$\n    A negative value for $b_{\\min}$ signifies a violation of the no-arbitrage condition, indicating that the given volatility smile is not consistent with a valid risk-neutral density. For Case A (flat smile), we expect $b_{\\min} \\ge 0$, as the standard BSM model is arbitrage-free. For Case B (spiky smile), the extreme convexity in the volatility function is known to potentially cause non-convexity in the call price function, so we might find $b_{\\min} < 0$. Case C presents a more realistic, sloped smile, whose arbitrage-freeness must be verified numerically.\n\nThe implementation will utilize `scipy.interpolate.interp1d` for the volatility function and `scipy.stats.norm.cdf` for the function $\\Phi$. All vector and matrix operations will be handled by `numpy` for efficiency.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Computes the minimum butterfly spread price for different volatility smiles\n    to check for arbitrage.\n    \"\"\"\n    # Fixed market inputs for all test cases\n    S0 = 100.0\n    T = 1.0\n    # r = 0, delta = 0 are implicitly used in the simplified BSM formula.\n\n    # Grid parameters\n    N = 81\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: flat smile\n        [\n            (70.0, 0.20), (85.0, 0.20), (100.0, 0.20), (115.0, 0.20), (130.0, 0.20)\n        ],\n        # Case B: spiky smile\n        [\n            (70.0, 0.15), (85.0, 0.15), (100.0, 0.90), (115.0, 0.15), (130.0, 0.15)\n        ],\n        # Case C: sloped smile\n        [\n            (80.0, 0.18), (100.0, 0.20), (120.0, 0.22)\n        ],\n    ]\n\n    def bsm_call_price(K, sigma_K):\n        \"\"\"\n        Calculates the BSM European call price for r=0, delta=0.\n        K and sigma_K can be numpy arrays.\n        \"\"\"\n        # Handle cases where sigma_K might be zero or K is zero to avoid division by zero or log(0)\n        # However, problem constraints (sigma_i > 0, K_i > 0) make this unlikely\n        # for interpolated values. Add a small epsilon for robustness.\n        epsilon = 1e-12\n        sigma_K = np.maximum(sigma_K, epsilon)\n        K = np.maximum(K, epsilon)\n\n        d1 = (np.log(S0 / K) + 0.5 * sigma_K**2 * T) / (sigma_K * np.sqrt(T))\n        d2 = d1 - sigma_K * np.sqrt(T)\n        \n        price = S0 * norm.cdf(d1) - K * norm.cdf(d2)\n        return price\n\n    results = []\n    for nodes in test_cases:\n        # 1. Unpack nodes and create interpolator for sigma(K)\n        strikes_nodes, vols_nodes = zip(*nodes)\n        \n        # Use scipy's linear interpolation. fill_value is not needed as we\n        # stay within the bounds defined by the nodes.\n        sigma_func = interp1d(\n            strikes_nodes, vols_nodes, kind='linear', bounds_error=True\n        )\n\n        # 2. Construct the equally spaced strike grid\n        K_min = strikes_nodes[0]\n        K_max = strikes_nodes[-1]\n        K_grid = np.linspace(K_min, K_max, N)\n\n        # 3. Compute C(K_j) for all j\n        # First, compute interpolated volatilities on the grid\n        sigma_grid = sigma_func(K_grid)\n        # Then, compute call prices on the grid\n        C_grid = bsm_call_price(K_grid, sigma_grid)\n        \n        # 4. Compute discrete butterfly spread prices\n        # B_j = C(K_{j-1}) - 2*C(K_j) + C(K_{j+1})\n        # This can be vectorized using numpy slicing\n        butterfly_spreads = C_grid[:-2] - 2 * C_grid[1:-1] + C_grid[2:]\n\n        # 5. Report the minimum butterfly spread price\n        b_min = np.min(butterfly_spreads)\n        \n        # Round to six decimal places as required\n        results.append(round(b_min, 6))\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}