{"hands_on_practices": [{"introduction": "Before we can price derivatives or simulate paths, we must first understand the fundamental mathematical law governing the evolution of an option's price in a world with jumps. This practice guides you through the derivation of the Partial Integro-Differential Equation (PIDE) for a European option under the Merton model [@problem_id:1282213]. By applying Itô's lemma for jump-diffusion processes, you will see precisely how the continuous movements of the Black-Scholes world are augmented with an integral term that captures the non-local impact of market shocks.", "id": "1282213", "problem": "A quantitative analysis team is developing a pricing model for a European call option. They recognize that the standard Black-Scholes model, which assumes continuous asset price movements, fails to capture the risk of sudden, large price shocks observed in financial markets. To address this, they decide to model the underlying asset price, $S_t$, using a Merton jump-diffusion process.\n\nUnder the risk-neutral probability measure, the asset price dynamics are given by the stochastic differential equation:\n$$\n\\frac{dS_t}{S_{t-}} = (r - \\lambda k) dt + \\sigma dW_t + (Y-1)dN_t\n$$\nwhere:\n- $S_{t-}$ is the price of the asset just before a potential jump at time $t$.\n- $r$ is the constant risk-free interest rate.\n- $\\sigma$ is the constant volatility of the diffusion component.\n- $W_t$ is a standard Wiener process.\n- $N_t$ is a Poisson process with a constant intensity $\\lambda > 0$, representing the arrival of jumps.\n- $Y$ is a random variable for the multiplicative jump size, such that if a jump occurs at time $t$, the price moves from $S_{t-}$ to $S_t = Y S_{t-}$. The jump sizes are independent of each other and of the Wiener process.\n- The natural logarithm of the jump size, $\\ln(Y)$, is assumed to follow a normal distribution with mean $\\mu_J$ and variance $\\sigma_J^2$. In other words, $\\ln(Y) \\sim N(\\mu_J, \\sigma_J^2)$.\n- $k$ is the expected relative jump size, defined as $k = E[Y-1]$, where the expectation is taken over the risk-neutral distribution of $Y$.\n\nLet $C(S, t)$ be the price of a European call option on this asset with strike price $K$ and expiry time $T$. Your task is to derive the Partial Integro-Differential Equation (PIDE) that the option price $C(S, t)$ must satisfy for $t < T$. Your final answer should be the complete PIDE, expressed in terms of $C$ and its partial derivatives, $S, t, r, \\sigma, \\lambda, \\mu_J$, and $\\sigma_J$.\n\n", "solution": "Under the stated risk-neutral dynamics,\n$$\n\\frac{dS_{t}}{S_{t-}}=\\left(r-\\lambda k\\right)dt+\\sigma dW_{t}+(Y-1)dN_{t},\n$$\nwith $k=E[Y-1]$, the option price $C(S,t)$ is a function of $(S,t)$ for $t<T$. Apply Itô's lemma for jump-diffusions to $f(S,t)=C(S,t)$. For a process with diffusion and compound Poisson jumps,\n$$\ndC=C_{t}\\,dt+C_{S}\\,dS+\\frac{1}{2}C_{SS}\\,d[S^{c}]_{t}+\\left(C(S_{t-}+\\Delta S_{t},t)-C(S_{t-},t)-C_{S}(S_{t-},t)\\,\\Delta S_{t}\\right),\n$$\nwhere $d[S^{c}]_{t}=\\sigma^{2}S_{t}^{2}dt$ is the quadratic variation of the continuous part, and $\\Delta S_{t}=S_{t}-S_{t-}=S_{t-}(Y-1)$ when a jump occurs. Using $dS_{t}=S_{t-}\\left((r-\\lambda k)dt+\\sigma dW_{t}+(Y-1)dN_{t}\\right)$, we have\n$$\nC_{S}\\,dS_{t}=C_{S}\\left((r-\\lambda k)S\\,dt+\\sigma S\\,dW_{t}+S(Y-1)\\,dN_{t}\\right),\n$$\nand the jump correction term equals\n$$\n\\left(C(SY,t)-C(S,t)-C_{S}S(Y-1)\\right)dN_{t}.\n$$\nAdding these yields a cancellation of the linear jump term, so the jump contribution becomes\n$$\n\\left(C(SY,t)-C(S,t)\\right)dN_{t}.\n$$\nCollecting terms,\n$$\ndC=\\left(C_{t}+(r-\\lambda k)S C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS}\\right)dt+\\sigma S C_{S}\\,dW_{t}+\\left(C(SY,t)-C(S,t)\\right)dN_{t}.\n$$\n\nUnder the risk-neutral measure, the discounted option price is a martingale. For $G(t)=\\exp(-rt)C(S_{t},t)$,\n$$\ndG=\\exp(-rt)\\left(dC-rC\\,dt\\right),\n$$\nso its drift must vanish:\n$$\nC_{t}+(r-\\lambda k)S C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS}-rC+\\lambda\\,E\\!\\left[C(SY,t)-C(S,t)\\right]=0.\n$$\nBecause $\\ln(Y)\\sim N(\\mu_{J},\\sigma_{J}^{2})$, $Y$ is lognormally distributed with density\n$$\nf_{Y}(y)=\\frac{1}{y\\,\\sigma_{J}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(\\ln y-\\mu_{J})^{2}}{2\\sigma_{J}^{2}}\\right),\\quad y>0,\n$$\nand\n$$\nk=E[Y-1]=\\exp\\!\\left(\\mu_{J}+\\frac{1}{2}\\sigma_{J}^{2}\\right)-1.\n$$\nTherefore, the expectation can be written as an integral and $k$ expressed in terms of $\\mu_{J},\\sigma_{J}$, giving the PIDE (for $t<T$):\n$$\nC_{t}+\\left(r-\\lambda\\left(\\exp\\!\\left(\\mu_{J}+\\frac{1}{2}\\sigma_{J}^{2}\\right)-1\\right)\\right)S C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS}-rC+\\lambda\\int_{0}^{\\infty}\\left[C(Sy,t)-C(S,t)\\right]\\frac{1}{y\\,\\sigma_{J}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(\\ln y-\\mu_{J})^{2}}{2\\sigma_{J}^{2}}\\right)dy=0.\n$$\nFor completeness, the terminal condition is $C(S,T)=\\max(S-K,0)$, though it is not part of the PIDE itself.", "answer": "$$\\boxed{C_{t}+\\left(r-\\lambda\\left(\\exp\\!\\left(\\mu_{J}+\\frac{1}{2}\\sigma_{J}^{2}\\right)-1\\right)\\right)S\\,C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS}-r\\,C+\\lambda\\int_{0}^{\\infty}\\left[C(Sy,t)-C(S,t)\\right]\\frac{1}{y\\,\\sigma_{J}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(\\ln y-\\mu_{J})^{2}}{2\\sigma_{J}^{2}}\\right)\\,dy=0}$$"}, {"introduction": "While the PIDE describes the evolution of derivative prices, another powerful way to understand a jump-diffusion model is by examining the probability distribution of asset returns it generates. This exercise transitions from theoretical derivation to direct computation by asking you to implement the probability density function (PDF) for log-returns in the Merton model [@problem_id:2422076]. You will construct the PDF as an infinite weighted sum of Gaussian densities, a structure that provides direct, quantitative insight into the \"fat tails\" and skewness that jumps introduce compared to a standard geometric Brownian motion.", "id": "2422076", "problem": "Consider an asset price process modeled by the Merton jump-diffusion, defined as follows. Let $S_t$ denote the asset price at time $t \\ge 0$. The price dynamics under the physical measure are given by the stochastic differential equation (SDE): \n$$\n\\frac{dS_t}{S_{t^-}} = \\mu \\, dt + \\sigma \\, dW_t + (J - 1) \\, dN_t,\n$$\nwhere $W_t$ is a standard Brownian motion, $N_t$ is a Poisson process with intensity $\\lambda > 0$ independent of $W_t$, and the jump size $J$ satisfies $\\log J \\sim \\mathcal{N}(m, \\delta^2)$ with $\\delta \\ge 0$ and $m \\in \\mathbb{R}$. Define the log-return over horizon $T > 0$ as $X_T = \\log(S_T/S_0)$. Let $\\kappa = \\mathbb{E}[J - 1] = \\exp\\!\\left(m + \\tfrac{1}{2}\\delta^2\\right) - 1$.\n\nFrom first principles, the exact distributional representation of $X_T$ is obtained by conditioning on the number of jumps in $[0,T]$. Let $N_T \\sim \\text{Poisson}(\\lambda T)$. Then\n$$\nX_T \\,\\big|\\, (N_T = n) \\sim \\mathcal{N}\\!\\left(\\left(\\mu - \\tfrac{1}{2}\\sigma^2 - \\lambda \\kappa\\right)T + n m,\\; \\sigma^2 T + n \\delta^2\\right),\n$$\nand the unconditional probability density function $f_{X_T}(x)$ is the Poisson-weighted infinite mixture of Gaussian densities:\n$$\nf_{X_T}(x) = \\sum_{n=0}^{\\infty} \\underbrace{e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}}_{\\text{Poisson weight}} \\cdot \\underbrace{\\frac{1}{\\sqrt{2\\pi(\\sigma^2 T + n\\delta^2)}} \\exp\\!\\left(-\\frac{\\left(x - \\left(\\mu - \\tfrac{1}{2}\\sigma^2 - \\lambda \\kappa\\right)T - n m\\right)^2}{2(\\sigma^2 T + n\\delta^2)}\\right)}_{\\text{Gaussian density at }x}.\n$$\n\nTask. For each parameter set below, compute the values of the log-return density $f_{X_T}(x)$ at the specified log-return points $x$. Your program must output density values that are accurate up to an absolute error not exceeding $10^{-10}$ per evaluation. All quantities are dimensionless; express all numeric outputs as floating-point numbers.\n\nTest suite. Use the following parameter sets, each specified as $(\\mu, \\sigma, \\lambda, m, \\delta, T; \\ \\text{grid } \\{x\\})$:\n- Case A (general jump-diffusion): $(0.08, \\ 0.2, \\ 0.5, \\ -0.1, \\ 0.2, \\ 1.0; \\ \\{-0.2, \\ 0.0, \\ 0.2\\})$.\n- Case B (no jumps boundary, $\\lambda = 0$): $(0.05, \\ 0.25, \\ 0.0, \\ 0.0, \\ 0.1, \\ 1.0; \\ \\{-0.2, \\ 0.0, \\ 0.2\\})$.\n- Case C (deterministic jump size, $\\delta = 0$): $(0.06, \\ 0.15, \\ 1.2, \\ -0.05, \\ 0.0, \\ 0.5; \\ \\{-0.1, \\ 0.0, \\ 0.1\\})$.\n- Case D (short horizon): $(0.10, \\ 0.3, \\ 2.5, \\ -0.02, \\ 0.1, \\ 0.01; \\ \\{-0.02, \\ 0.0, \\ 0.02\\})$.\n\nRequired final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must be an inner list of density values ordered according to its grid. Thus the final output must be a single line representing a list of four lists, for Cases A through D in order, for example: \n\"[ [f_A(x1),f_A(x2),f_A(x3)], [f_B(x1),f_B(x2),f_B(x3)], [f_C(x1),f_C(x2),f_C(x3)], [f_D(x1),f_D(x2),f_D(x3)] ]\" but with no whitespace anywhere, i.e., \"[[...],[...],[...],[...]]\".", "solution": "The problem is valid. It is a well-posed, scientifically grounded problem in computational finance that is free of contradictions or ambiguities. The task is to compute the value of the probability density function (PDF) for the log-return of an asset whose price is governed by the Merton jump-diffusion model.\n\nThe asset price $S_t$ follows the stochastic differential equation:\n$$\n\\frac{dS_t}{S_{t^-}} = \\mu \\, dt + \\sigma \\, dW_t + (J - 1) \\, dN_t\n$$\nThe log-return over a horizon $T$, defined as $X_T = \\log(S_T/S_0)$, has a probability density function $f_{X_T}(x)$ given by an infinite mixture of Gaussian densities, as stated in the problem:\n$$\nf_{X_T}(x) = \\sum_{n=0}^{\\infty} \\mathbb{P}(N_T=n) \\cdot \\phi(x; \\mu_n, \\sigma_n^2)\n$$\nIn this expression, $\\mathbb{P}(N_T=n) = e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}$ is the probability mass function of a Poisson random variable $N_T$ with mean $\\lambda T$, representing the number of jumps in the interval $[0, T]$. The function $\\phi(x; \\mu_n, \\sigma_n^2)$ is the PDF of a normal distribution with mean $\\mu_n$ and variance $\\sigma_n^2$. The parameters of this $n$-th Gaussian component are given by:\n$$\n\\mu_n = \\left(\\mu - \\tfrac{1}{2}\\sigma^2 - \\lambda \\kappa\\right)T + n m\n$$\n$$\n\\sigma_n^2 = \\sigma^2 T + n \\delta^2\n$$\nwhere the jump compensator $\\kappa$ is defined as $\\kappa = \\mathbb{E}[J - 1] = \\exp(m + \\tfrac{1}{2}\\delta^2) - 1$.\n\nThe central task is the numerical evaluation of this infinite series to an absolute precision of $10^{-10}$. Since a closed-form solution for the sum is not available, we must employ a numerical approximation, which involves truncating the series.\n\nThe implemented methodology is an iterative summation of the series terms, $T_n(x) = \\mathbb{P}(N_T=n) \\cdot \\phi(x; \\mu_n, \\sigma_n^2)$. The summation proceeds for $n = 0, 1, 2, \\dots$ and is terminated when the contribution of subsequent terms becomes numerically insignificant. All terms $T_n(x)$ are strictly non-negative. The convergence of the sum is rapid, driven by the decay of the Poisson probabilities $\\mathbb{P}(N_T=n)$ as $n$ increases, especially for values of $n$ greater than the mean $\\lambda T$. The parameter values provided in the test suite result in small values for $\\lambda T$ (at most $0.6$), guaranteeing very fast convergence.\n\nThe algorithmic procedure is as follows for each parameter set and evaluation point $x$:\n1.  First, pre-compute several constants to optimize the calculation loop: the Poisson mean $\\Lambda = \\lambda T$, the jump compensator $\\kappa$, the constant part of the conditional mean $D = (\\mu - \\frac{1}{2}\\sigma^2 - \\lambda\\kappa)T$, and the constant part of the conditional variance $V = \\sigma^2 T$.\n2.  A special case for $\\lambda = 0$ (no jumps) is handled separately for efficiency. When $\\lambda = 0$, the Merton model simplifies to the Geometric Brownian Motion (GBM) model. The infinite sum collapses to its first term ($n=0$), and the log-return density becomes a single Gaussian PDF, $\\phi(x; (\\mu - \\frac{1}{2}\\sigma^2)T, \\sigma^2 T)$.\n3.  For the general case where $\\lambda > 0$, the total density $f_{X_T}(x)$ is initialized to zero and the terms of the series are summed iteratively.\n4.  The loop proceeds over the number of jumps $n=0, 1, 2, \\dots$:\n    a. The Poisson probability $\\mathbb{P}(N_T=n)$ is calculated. To maintain numerical stability and avoid computing large factorials, this is done using the recurrence relation $\\mathbb{P}(N_T=n) = \\mathbb{P}(N_T=n-1) \\cdot \\frac{\\Lambda}{n}$, starting from the base case $\\mathbb{P}(N_T=0) = e^{-\\Lambda}$.\n    b. The mean $\\mu_n = D + nm$ and variance $\\sigma_n^2 = V + n\\delta^2$ for the $n$-th Gaussian component are computed.\n    c. The value of the corresponding Gaussian PDF, $\\phi(x; \\mu_n, \\sigma_n^2)$, is evaluated at the point $x$. This is reliably done using the `scipy.stats.norm.pdf` function from the SciPy library.\n    d. The complete term for the series, $T_n(x) = \\mathbb{P}(N_T=n) \\cdot \\phi(x; \\mu_n, \\sigma_n^2)$, is calculated.\n    e. The loop is terminated if the calculated term $T_n(x)$ falls below an absolute tolerance of $10^{-16}$. This threshold is significantly smaller than the required final accuracy of $10^{-10}$, ensuring that the truncated tail of the series does not impact the result. For additional robustness, this check is performed only after $n$ has surpassed the mode of the Poisson distribution ($n > \\Lambda$).\n    f. If the termination condition is not met, the term $T_n(x)$ is added to the running total for $f_{X_T}(x)$.\n5.  After the loop terminates, the accumulated sum provides the final density value at $x$.\n\nThis procedure is systematically applied to all parameter sets and their corresponding evaluation grids as specified in the problem statement. The resulting densities are then formatted into the required nested list structure for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, including test cases and output formatting.\n    \"\"\"\n\n    def compute_merton_pdf(params):\n        \"\"\"\n        Computes the Merton jump-diffusion model's log-return PDF for a given parameter set.\n        \"\"\"\n        mu, sigma, lam, m, delta, T, x_grid = params\n\n        # Handle the boundary case of no jumps (lambda=0), which is the Black-Scholes-Merton model.\n        if lam == 0.0:\n            drift = (mu - 0.5 * sigma**2) * T\n            variance = sigma**2 * T\n            \n            # The problem's constraints (sigma>0, T>0) ensure variance is positive.\n            std_dev = np.sqrt(variance)\n            return [norm.pdf(x, loc=drift, scale=std_dev) for x in x_grid]\n\n        # Pre-compute constants for the general jump-diffusion case (lambda > 0)\n        kappa = np.exp(m + 0.5 * delta**2) - 1\n        drift_base = (mu - 0.5 * sigma**2 - lam * kappa) * T\n        var_base = sigma**2 * T\n        lambda_T = lam * T\n\n        results = []\n        for x in x_grid:\n            total_pdf = 0.0\n            n = 0\n            \n            # Start with n=0 term: P(N_T=0) = exp(-lambda*T)\n            poisson_prob = np.exp(-lambda_T)\n\n            while True:\n                # Calculate mean and variance of the n-th Gaussian component\n                cond_mean = drift_base + n * m\n                cond_var = var_base + n * delta**2\n                \n                # The variance is always > 0 for test cases, so sqrt is safe\n                cond_std = np.sqrt(cond_var)\n\n                # Evaluate the density of the n-th Gaussian at point x\n                gaussian_pdf = norm.pdf(x, loc=cond_mean, scale=cond_std)\n                \n                # The term for this n in the infinite sum\n                term = poisson_prob * gaussian_pdf\n                \n                # Check for convergence. Stop when the term's contribution is negligible.\n                # An absolute tolerance on the term is sufficient here. 1e-16 is a safe\n                # margin for a required absolute error of 1e-10.\n                if term < 1e-16 and n > lambda_T:\n                    break\n                \n                total_pdf += term\n                \n                # Prepare for the next iteration\n                n += 1\n                # Update Poisson probability using the recurrence relation: P(k) = P(k-1) * lambda*T / k\n                poisson_prob = poisson_prob * lambda_T / n\n\n                # Safety break to prevent infinite loops with unusual parameters\n                if n > 300:\n                    break\n            \n            results.append(total_pdf)\n        \n        return results\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Parameter set: mu, sigma, lambda, m, delta, T, x_grid)\n        # Case A (general jump-diffusion)\n        (0.08, 0.2, 0.5, -0.1, 0.2, 1.0, [-0.2, 0.0, 0.2]),\n        # Case B (no jumps boundary, lambda = 0)\n        (0.05, 0.25, 0.0, 0.0, 0.1, 1.0, [-0.2, 0.0, 0.2]),\n        # Case C (deterministic jump size, delta = 0)\n        (0.06, 0.15, 1.2, -0.05, 0.0, 0.5, [-0.1, 0.0, 0.1]),\n        # Case D (short horizon)\n        (0.10, 0.3, 2.5, -0.02, 0.1, 0.01, [-0.02, 0.0, 0.02]),\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        case_results = compute_merton_pdf(case_params)\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    result_strings = []\n    for res_list in all_results:\n        # Convert each float in the inner list to its standard string representation.\n        inner_list_str = \"[\" + \",\".join(map(str, res_list)) + \"]\"\n        result_strings.append(inner_list_str)\n    \n    final_output = \"[\" + \",\".join(result_strings) + \"]\"\n    print(final_output)\n\nsolve()\n```"}, {"introduction": "A financial model is only as powerful as its ability to reflect market reality. This final practice bridges the gap between theory and application by tackling the crucial task of model calibration [@problem_id:2398577]. Here, you will step into the role of a quantitative analyst, using the Merton pricing formula—whose logic is built upon the distributional properties you explored previously—to fit the jump intensity parameter, $\\lambda$, to a set of synthetic market prices. By implementing a Golden-Section Search optimizer from scratch, you will develop a complete workflow for making a sophisticated asset pricing model consistent with observed data.", "id": "2398577", "problem": "Write a complete, runnable program that uses Golden-Section Search (GSS) to calibrate the jump intensity parameter $\\lambda$ in a Merton jump-diffusion model by minimizing the sum of squared pricing errors between model and synthetic market prices of out-of-the-money European call options. Your program must implement, from first principles, the pricing model and the univariate optimizer, and must not rely on any external optimizer.\n\nFundamental base:\n- Under the risk-neutral measure, the price of a European call option with strike $K$ and maturity $T$ is given by the risk-neutral expectation $C = e^{-r T} \\mathbb{E}\\left[(S_T - K)^{+}\\right]$.\n- In the Merton jump-diffusion model, the asset dynamics under the risk-neutral measure are\n$$\n\\frac{dS_t}{S_{t^-}} = \\left(r - q - \\lambda k\\right)\\,dt + \\sigma\\, dW_t + (J - 1)\\, dN_t,\n$$\nwhere $r$ is the continuously compounded risk-free rate, $q$ is the continuous dividend yield, $\\sigma$ is the diffusion volatility, $N_t$ is a Poisson process with intensity $\\lambda$, and $J$ is the jump size with $\\ln J \\sim \\mathcal{N}(\\mu_J,\\sigma_J^2)$. The jump compensator is $k = \\mathbb{E}[J - 1] = e^{\\mu_J + \\tfrac{1}{2}\\sigma_J^2} - 1$.\n- Conditioning on $N_T = n$ leads to a Poisson mixture of log-normal distributions, yielding a closed-form mixture representation for the call price as a weighted sum of Black–Scholes terms.\n\nPricing model to implement:\n- Define $k = e^{\\mu_J + \\tfrac{1}{2}\\sigma_J^2} - 1$, the effective net drift $b(\\lambda) = r - q - \\lambda k$, and the per-jump scaling factor $s_J = 1 + k = e^{\\mu_J + \\tfrac{1}{2}\\sigma_J^2}$.\n- For each nonnegative integer $n$, define the conditional variance parameter\n$$\n\\sigma_n = \\sqrt{\\sigma^2 + \\frac{n\\,\\sigma_J^2}{T}},\n$$\nand the adjusted spot\n$$\nS_n = S_0\\, s_J^{\\,n}.\n$$\n- The Poisson weight is\n$$\n\\pi_n(\\lambda) = e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}.\n$$\n- The Black–Scholes (BS) call price with effective net drift $b(\\lambda)$ is\n$$\nC_{\\text{BS}}(S,K,r,q,\\sigma_n,T;b) = S\\,e^{-qT}\\,\\Phi(d_1) - K\\,e^{-rT}\\,\\Phi(d_2),\n$$\nwith\n$$\nd_1 = \\frac{\\ln\\left(\\frac{S}{K}\\right) + \\left(b + \\tfrac{1}{2}\\sigma_n^2\\right)T}{\\sigma_n \\sqrt{T}}, \\quad d_2 = d_1 - \\sigma_n \\sqrt{T},\n$$\nand $\\Phi(\\cdot)$ the standard normal cumulative distribution function.\n- The Merton call price is\n$$\nC_{\\text{Merton}}(\\lambda; S_0, K, r, q, \\sigma, \\mu_J, \\sigma_J, T) = \\sum_{n=0}^{\\infty} \\pi_n(\\lambda)\\, C_{\\text{BS}}(S_n, K, r, q, \\sigma_n, T; b(\\lambda)).\n$$\n- For numerical implementation, truncate the infinite sum by:\n  - summing over $n = 0,1,2,\\dots$ until the incremental Poisson weight $\\pi_n(\\lambda)$ falls below $10^{-12}$, or\n  - reaching a hard cap $n_{\\max} = 50$,\n  whichever occurs first.\n\nCalibration objective:\n- Given a set of out-of-the-money strikes $\\{K_i\\}_{i=1}^m$ and corresponding market call prices $\\{C^{\\text{mkt}}_i\\}_{i=1}^m$, define the objective\n$$\nJ(\\lambda) = \\sum_{i=1}^m \\left( C_{\\text{Merton}}(\\lambda; S_0, K_i, r, q, \\sigma, \\mu_J, \\sigma_J, T) - C^{\\text{mkt}}_i \\right)^2.\n$$\n- Calibrate $\\lambda$ by minimizing $J(\\lambda)$ over the closed interval $\\lambda \\in [0, 3]$ using Golden-Section Search. Terminate when the bracket length is less than $10^{-6}$ or after $200$ iterations, whichever is earlier.\n\nNumerical details:\n- Use $\\Phi(x) = \\tfrac{1}{2}\\left(1 + \\operatorname{erf}\\left(\\tfrac{x}{\\sqrt{2}}\\right)\\right)$.\n- All options are European calls, and all strikes in the test suite are strictly out-of-the-money: $K > S_0$.\n- No randomness is to be used; all numbers must be computed deterministically.\n\nTest suite:\nFor each case below, first generate synthetic market prices by evaluating the Merton price with the stated “true” $\\lambda$ and the specified numerical settings. Then, discard the true value and apply your calibration routine to recover $\\widehat{\\lambda}$ from the synthetic market prices.\n\n- Case A (happy path):\n  - $S_0 = 100.0$, $r = 0.02$, $q = 0.0$, $T = 0.75$,\n  - $\\sigma = 0.20$, $\\mu_J = -0.10$, $\\sigma_J = 0.25$,\n  - strikes $K \\in \\{105.0, 110.0, 120.0\\}$,\n  - true $\\lambda_{\\text{true}} = 0.60$.\n\n- Case B (boundary, no jumps):\n  - $S_0 = 100.0$, $r = 0.01$, $q = 0.0$, $T = 1.00$,\n  - $\\sigma = 0.15$, $\\mu_J = -0.20$, $\\sigma_J = 0.30$,\n  - strikes $K \\in \\{102.0, 110.0, 125.0\\}$,\n  - true $\\lambda_{\\text{true}} = 0.00$.\n\n- Case C (higher jump activity):\n  - $S_0 = 100.0$, $r = 0.03$, $q = 0.0$, $T = 2.00$,\n  - $\\sigma = 0.18$, $\\mu_J = 0.05$, $\\sigma_J = 0.20$,\n  - strikes $K \\in \\{105.0, 115.0, 130.0, 150.0\\}$,\n  - true $\\lambda_{\\text{true}} = 1.20$.\n\nFinal output format:\n- Your program should produce a single line of output containing the calibrated intensities for the three cases as a comma-separated list enclosed in square brackets, each value rounded to six decimal places, in the order A, B, C. For example, the output must look like\n$$\n[\\widehat{\\lambda}_A,\\widehat{\\lambda}_B,\\widehat{\\lambda}_C],\n$$\nwith each $\\widehat{\\lambda}$ rounded to $6$ decimal places (no units).", "solution": "The problem has been subjected to rigorous validation and is deemed valid. The formulation is scientifically grounded in the Merton jump-diffusion model, a standard in financial engineering. It is well-posed, providing a complete and internally consistent set of definitions, parameters, and numerical procedures for a deterministic optimization task. The objective is stated with mathematical precision, free from ambiguity or subjective content. All necessary components for a unique solution are provided.\n\nThe task is to calibrate the jump intensity parameter, $\\lambda$, of a Merton jump-diffusion model. This is accomplished by minimizing an objective function, $J(\\lambda)$, representing the sum of squared differences between option prices generated by the model and a set of synthetic market prices. The optimization is constrained to the interval $\\lambda \\in [0, 3]$ and must be performed using the Golden-Section Search (GSS) algorithm, implemented from first principles.\n\nThe core of the problem involves the implementation of two main components: the Merton pricing model and the GSS optimizer.\n\nFirst, we implement the pricing model for a European call option as specified. The Merton price, $C_{\\text{Merton}}$, is a weighted sum over prices of Black-Scholes-type options, conditioned on the number of jumps, $n$, occurring over the option's life, $T$. The price is given by:\n$$\nC_{\\text{Merton}}(\\lambda) = \\sum_{n=0}^{\\infty} \\pi_n(\\lambda)\\, C_{\\text{BS}}(S_n, K, r, q, \\sigma_n, T; b(\\lambda))\n$$\nThe Poisson weight $\\pi_n(\\lambda)$, representing the probability of $n$ jumps, is:\n$$\n\\pi_n(\\lambda) = e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}\n$$\nThe conditional Black-Scholes component, $C_{\\text{BS}}$, is defined for an adjusted spot price $S_n = S_0\\, s_J^{\\,n}$ and a conditional volatility $\\sigma_n = \\sqrt{\\sigma^2 + n\\,\\sigma_J^2/T}$. The per-jump scaling factor is $s_J = e^{\\mu_J + \\frac{1}{2}\\sigma_J^2}$. The component price is given by:\n$$\nC_{\\text{BS}} = S_n\\,e^{-qT}\\,\\Phi(d_1) - K\\,e^{-rT}\\,\\Phi(d_2)\n$$\nwith its parameters $d_1$ and $d_2$ dependent on an effective net drift $b(\\lambda) = r - q - \\lambda k$, where $k = s_J - 1$. The specific formula for $d_1$ is:\n$$\nd_1 = \\frac{\\ln\\left(\\frac{S_n}{K}\\right) + \\left(b(\\lambda) + \\tfrac{1}{2}\\sigma_n^2\\right)T}{\\sigma_n \\sqrt{T}}\n$$\nand $d_2 = d_1 - \\sigma_n \\sqrt{T}$. The standard normal cumulative distribution function, $\\Phi(\\cdot)$, is computed using the error function, $\\operatorname{erf}(\\cdot)$, as $\\Phi(x) = \\frac{1}{2}\\left(1 + \\operatorname{erf}\\left(\\frac{x}{\\sqrt{2}}\\right)\\right)$. For numerical implementation, the infinite sum is truncated. The summation proceeds over $n=0, 1, 2, \\dots$ and terminates when the term's Poisson weight $\\pi_n(\\lambda)$ falls below a tolerance of $10^{-12}$, or when a maximum of $n_{\\max}=50$ terms have been included, whichever occurs first. A robust iterative method is used to compute the Poisson weights, $\\pi_n(\\lambda) = \\pi_{n-1}(\\lambda) \\cdot \\frac{\\lambda T}{n}$, to avoid numerical overflow with large factorials.\n\nSecond, we define the calibration objective function, $J(\\lambda)$, as the sum of squared errors (SSE) over a set of $m$ options with different strikes $\\{K_i\\}_{i=1}^m$:\n$$\nJ(\\lambda) = \\sum_{i=1}^m \\left( C_{\\text{Merton}}(\\lambda; K_i) - C^{\\text{mkt}}_i \\right)^2\n$$\nwhere $C^{\\text{mkt}}_i$ are the given synthetic market prices.\n\nThird, we implement the Golden-Section Search (GSS) algorithm to minimize $J(\\lambda)$. GSS is a derivative-free optimization method for finding the extremum of a unimodal function by iteratively narrowing the search interval. The search begins on the interval $[a, b] = [0, 3]$. Two interior points, $c$ and $d$, are chosen to divide the interval according to the golden ratio, $\\phi = (1+\\sqrt{5})/2 \\approx 1.618$.\n$$\nc = b - \\frac{b-a}{\\phi} \\quad \\text{and} \\quad d = a + \\frac{b-a}{\\phi}\n$$\nThe objective function is evaluated at these points. If $J(c) < J(d)$, the minimum must lie in the interval $[a, d]$, so the new search interval becomes $[a, d]$. Otherwise, if $J(c) \\ge J(d)$, the new interval becomes $[c, b]$. This process reduces the interval length by a factor of $1/\\phi$ at each step, guaranteeing convergence. The algorithm terminates when the interval length $|b-a|$ is less than a tolerance of $10^{-6}$ or after a maximum of $200$ iterations. The midpoint of the final interval, $(a+b)/2$, is returned as the calibrated estimate $\\widehat{\\lambda}$.\n\nThe overall procedure involves first generating the synthetic market prices $C^{\\text{mkt}}_i$ for each test case by evaluating the specified $C_{\\text{Merton}}$ function at the given \"true\" intensity, $\\lambda_{\\text{true}}$. Then, this true value is conceptually discarded, and the GSS algorithm is employed to find the $\\widehat{\\lambda}$ that best reproduces these synthetic prices by minimizing $J(\\lambda)$. This process is repeated for all specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\n# Define a global constant for the Golden Ratio.\nGR = (1 + np.sqrt(5)) / 2\n\ndef norm_cdf(x):\n    \"\"\"\n    Computes the standard normal cumulative distribution function using the error function.\n    All mathematical entities must be in LaTeX: Phi(x) = 1/2 * (1 + erf(x/sqrt(2))).\n    \"\"\"\n    return 0.5 * (1 + erf(x / np.sqrt(2)))\n\ndef merton_bs_component(S, K, r, q, T, sigma_n, b):\n    \"\"\"\n    Computes a single Black-Scholes-like component of the Merton price series,\n    using the specific functional form provided in the problem statement.\n    \"\"\"\n    if sigma_n <= 0 or T <= 0:\n        return np.maximum(0, S - K) if S > K else 0.0\n\n    d1 = (np.log(S / K) + (b + 0.5 * sigma_n**2) * T) / (sigma_n * np.sqrt(T))\n    d2 = d1 - sigma_n * np.sqrt(T)\n    price = S * np.exp(-q * T) * norm_cdf(d1) - K * np.exp(-r * T) * norm_cdf(d2)\n    return price\n\ndef merton_price(lambda_val, S0, K, r, q, T, sigma, mu_J, sigma_J):\n    \"\"\"\n    Calculates the Merton jump-diffusion model call option price. The infinite sum\n    is truncated based on the Poisson weight or a maximum number of terms.\n    \"\"\"\n    # Jump-related parameters, constant with respect to lambda\n    k = np.exp(mu_J + 0.5 * sigma_J**2) - 1\n    s_J = 1 + k\n    \n    # Lambda-dependent effective drift\n    b = r - q - lambda_val * k\n    \n    total_price = 0.0\n    lambda_T = lambda_val * T\n    \n    n_max = 50\n    weight_tol = 1e-12\n\n    # Term for n=0 jumps (pure diffusion component)\n    poisson_weight = np.exp(-lambda_T)\n    sigma_0 = sigma\n    component_price_0 = merton_bs_component(S0, K, r, q, T, sigma_0, b)\n    total_price += poisson_weight * component_price_0\n    \n    # Terms for n=1 to n_max jumps\n    for n in range(1, n_max + 1):\n        poisson_weight *= lambda_T / n\n        if poisson_weight < weight_tol:\n            break\n        \n        sigma_n = np.sqrt(sigma**2 + n * sigma_J**2 / T)\n        S_n = S0 * (s_J**n)\n        \n        component_price = merton_bs_component(S_n, K, r, q, T, sigma_n, b)\n        total_price += poisson_weight * component_price\n        \n    return total_price\n\ndef objective_function(lambda_val, S0, r, q, T, sigma, mu_J, sigma_J, strikes, market_prices):\n    \"\"\"\n    Calculates the sum of squared errors (SSE) between model prices and market prices.\n    This is the function to be minimized.\n    \"\"\"\n    sse = 0.0\n    for i in range(len(strikes)):\n        model_price = merton_price(lambda_val, S0, strikes[i], r, q, T, sigma, mu_J, sigma_J)\n        sse += (model_price - market_prices[i])**2\n    return sse\n\ndef golden_section_search(f, a, b, tol=1e-6, max_iter=200):\n    \"\"\"\n    Performs Golden-Section Search to find the minimum of a univariate function 'f'\n    on the interval [a, b].\n    \"\"\"\n    inv_phi = 1 / GR\n    \n    # Initialize interior points\n    c = b - inv_phi * (b - a)\n    d = a + inv_phi * (b - a)\n    \n    fc = f(c)\n    fd = f(d)\n    \n    for _ in range(max_iter):\n        if abs(b - a) < tol:\n            break\n            \n        if fc < fd:\n            b = d\n            d = c\n            fd = fc\n            c = b - inv_phi * (b - a)\n            fc = f(c)\n        else:\n            a = c\n            c = d\n            fc = fd\n            d = a + inv_phi * (b - a)\n            fd = f(d)\n            \n    return (a + b) / 2\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite, calibrate lambda for each case, and print results.\n    \"\"\"\n    test_cases = [\n        # Case A: Happy path\n        {'S0': 100.0, 'r': 0.02, 'q': 0.0, 'T': 0.75, 'sigma': 0.20,\n         'mu_J': -0.10, 'sigma_J': 0.25, 'strikes': [105.0, 110.0, 120.0],\n         'lambda_true': 0.60},\n        # Case B: Boundary case, no jumps\n        {'S0': 100.0, 'r': 0.01, 'q': 0.0, 'T': 1.00, 'sigma': 0.15,\n         'mu_J': -0.20, 'sigma_J': 0.30, 'strikes': [102.0, 110.0, 125.0],\n         'lambda_true': 0.00},\n        # Case C: Higher jump activity\n        {'S0': 100.0, 'r': 0.03, 'q': 0.0, 'T': 2.00, 'sigma': 0.18,\n         'mu_J': 0.05, 'sigma_J': 0.20, 'strikes': [105.0, 115.0, 130.0, 150.0],\n         'lambda_true': 1.20}\n    ]\n    \n    calibrated_lambdas = []\n    \n    for case in test_cases:\n        # 1. Generate synthetic market prices using the true lambda\n        market_prices = [\n            merton_price(case['lambda_true'], case['S0'], K, case['r'], case['q'], case['T'],\n                         case['sigma'], case['mu_J'], case['sigma_J'])\n            for K in case['strikes']\n        ]\n\n        # 2. Define objective function for this case, capturing all parameters except lambda\n        obj_func = lambda l: objective_function(\n            l, case['S0'], case['r'], case['q'], case['T'], case['sigma'],\n            case['mu_J'], case['sigma_J'], case['strikes'], market_prices\n        )\n\n        # 3. Run Golden-Section Search to find the calibrated lambda\n        lambda_hat = golden_section_search(obj_func, a=0.0, b=3.0, tol=1e-6, max_iter=200)\n        calibrated_lambdas.append(lambda_hat)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{l:.6f}' for l in calibrated_lambdas])}]\")\n\nsolve()\n```"}]}