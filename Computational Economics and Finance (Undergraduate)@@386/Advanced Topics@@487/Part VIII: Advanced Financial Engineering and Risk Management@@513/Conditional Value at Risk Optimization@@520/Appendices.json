{"hands_on_practices": [{"introduction": "This first practice lays the groundwork for Conditional Value at Risk (CVaR) optimization. You will implement the seminal formulation that transforms the problem of minimizing tail risk, as measured by $\\text{CVaR}_\\alpha$, into a tractable Linear Program (LP). By comparing a long-only portfolio to one that allows short-selling and leverage, you will gain hands-on experience modeling real-world constraints and analyzing their impact on optimal risk-return profiles [@problem_id:2382531].", "id": "2382531", "problem": "Consider a finite-scenario portfolio optimization problem to minimize empirical Conditional Value at Risk (CVaR) of portfolio loss at a given confidence level. There are $n$ risky assets and $N$ scenarios of gross simple returns. Let $\\mathbf{r}_i \\in \\mathbb{R}^n$ denote the vector of asset returns in scenario $i \\in \\{1,\\dots,N\\}$, and let $\\mathbf{w} \\in \\mathbb{R}^n$ denote portfolio weights with the full-investment budget constraint $\\sum_{j=1}^n w_j = 1$. The portfolio loss in scenario $i$ is $\\ell_i(\\mathbf{w}) = - \\mathbf{r}_i^\\top \\mathbf{w}$. For a confidence level $\\alpha \\in (0,1)$, the empirical CVaR of the loss is defined by\n$$\n\\operatorname{CVaR}_\\alpha(\\mathbf{w}) \\;=\\; \\min_{t \\in \\mathbb{R}} \\left\\{ t \\;+\\; \\frac{1}{(1-\\alpha)N} \\sum_{i=1}^N \\big(\\ell_i(\\mathbf{w}) - t\\big)_+ \\right\\},\n$$\nwhere $(x)_+ = \\max\\{x,0\\}$. The expected return constraint requires the portfolioâ€™s scenario-average return to be at least a target $\\mu_{\\min}$, namely $\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i^\\top \\mathbf{w} \\ge \\mu_{\\min}$.\n\nYou must compare two regimes:\n- Short-selling prohibited: $w_j \\ge 0$ for all $j \\in \\{1,\\dots,n\\}$.\n- Short-selling allowed with leverage: the gross leverage constraint $\\sum_{j=1}^n |w_j| \\le L$ holds for a given $L \\ge 1$, and $w_j$ can be negative.\n\nUse the following data with $N = 12$ scenarios and $n = 4$ assets. The scenario return matrix $\\mathbf{R} \\in \\mathbb{R}^{12 \\times 4}$ is given by\n$$\n\\mathbf{R} \\;=\\;\n\\begin{bmatrix}\n0.01 & 0.005 & -0.02 & 0.002 \\\\\n0.015 & -0.01 & 0.03 & 0.003 \\\\\n-0.02 & 0.018 & 0.025 & 0.0025 \\\\\n0.005 & 0.004 & -0.015 & 0.002 \\\\\n0.012 & -0.005 & 0.022 & 0.003 \\\\\n-0.015 & 0.02 & -0.018 & 0.0025 \\\\\n0.008 & 0.001 & 0.027 & 0.002 \\\\\n0.004 & 0.003 & -0.012 & 0.003 \\\\\n0.02 & -0.012 & 0.019 & 0.0025 \\\\\n-0.01 & 0.017 & -0.014 & 0.002 \\\\\n0.006 & -0.004 & 0.021 & 0.003 \\\\\n0.007 & 0.009 & -0.016 & 0.0025\n\\end{bmatrix}.\n$$\n\nFor each test case below, compute the optimal weights $\\mathbf{w}^\\star$ that minimize $\\operatorname{CVaR}_\\alpha(\\mathbf{w})$ subject to the specified constraints, and report both $\\mathbf{w}^\\star$ and the corresponding optimal CVaR value.\n\nTest suite:\n- Test $1$ (happy path): $\\alpha = 0.95$, $\\mu_{\\min} = 0.003$, short-selling prohibited.\n- Test $2$ (comparison with leverage): $\\alpha = 0.95$, $\\mu_{\\min} = 0.003$, short-selling allowed with gross leverage $L = 1.5$.\n- Test $3$ (tail-stringent edge case): $\\alpha = 0.99$, $\\mu_{\\min} = 0.0038$, short-selling allowed with gross leverage $L = 2.0$.\n\nFinal output format:\n- Your program should produce a single line of output containing a list of three elements, each being a list of $5$ floats: the $4$ optimal weights followed by the optimal CVaR value. Numbers must be rounded to $6$ decimal places. The line must be a comma-separated list enclosed in square brackets, for example, $[\\,[x_1,x_2,x_3,x_4,c]\\, , \\, [\\dots] \\, , \\, [\\dots]\\,]$ with each $x_k$ and $c$ a float rounded to $6$ decimals.\n- No other text should be printed.", "solution": "The problem presented is a well-posed portfolio optimization task under the Conditional Value at Risk (CVaR) framework. It is scientifically grounded in established financial engineering principles and mathematically consistent. All necessary parameters and data are provided, and there are no ambiguities or contradictions. As such, the problem is valid, and we may proceed with its solution.\n\nThe objective is to minimize the empirical CVaR of portfolio loss, $\\operatorname{CVaR}_\\alpha(\\mathbf{w})$, subject to a set of constraints on the portfolio weights $\\mathbf{w} \\in \\mathbb{R}^n$. The portfolio consists of $n=4$ assets, evaluated over $N=12$ historical scenarios. The gross simple returns for these scenarios are given by the matrix $\\mathbf{R} \\in \\mathbb{R}^{12 \\times 4}$. Let $\\mathbf{r}_i \\in \\mathbb{R}^n$ be the column vector of asset returns in scenario $i$, corresponding to the transpose of the $i$-th row of $\\mathbf{R}$. The portfolio loss in scenario $i$ is defined as $\\ell_i(\\mathbf{w}) = - \\mathbf{r}_i^\\top \\mathbf{w}$.\n\nThe problem is to solve:\n$$\n\\min_{\\mathbf{w}} \\operatorname{CVaR}_\\alpha(\\mathbf{w})\n$$\nsubject to problem-specific constraints. The definition of $\\operatorname{CVaR}_\\alpha(\\mathbf{w})$ is given as:\n$$\n\\operatorname{CVaR}_\\alpha(\\mathbf{w}) \\;=\\; \\min_{t \\in \\mathbb{R}} \\left\\{ t \\;+\\; \\frac{1}{(1-\\alpha)N} \\sum_{i=1}^N \\big(\\ell_i(\\mathbf{w}) - t\\big)_+ \\right\\}\n$$\nwhere $(x)_+ = \\max\\{x,0\\}$.\n\nThis nested minimization problem can be reformulated as a a joint minimization over both $\\mathbf{w}$ and the auxiliary variable $t \\in \\mathbb{R}$:\n$$\n\\min_{\\mathbf{w}, t} \\left\\{ t \\;+\\; \\frac{1}{(1-\\alpha)N} \\sum_{i=1}^N \\big(-\\mathbf{r}_i^\\top \\mathbf{w} - t\\big)_+ \\right\\}\n$$\nThe term $(\\cdot)_+$ is nonlinear. To create a computationally tractable problem, specifically a Linear Program (LP), we introduce a vector of auxiliary variables $\\mathbf{u} = [u_1, \\dots, u_N]^\\top$, where each $u_i$ represents the excess loss in scenario $i$ over the Value at Risk (VaR), which is proxied by $t$. We require $u_i \\ge (-\\mathbf{r}_i^\\top \\mathbf{w} - t)$ and $u_i \\ge 0$. The minimization objective will ensure that $u_i$ takes the smallest possible value, i.e., $u_i = \\max(-\\mathbf{r}_i^\\top \\mathbf{w} - t, 0)$.\n\nThe optimization problem is thus transformed into the following LP:\n$$\n\\begin{array}{ll}\n\\underset{\\mathbf{w}, t, \\mathbf{u}}{\\text{minimize}} & t + \\frac{1}{(1-\\alpha)N} \\sum_{i=1}^N u_i \\\\\n\\text{subject to} & u_i + \\mathbf{r}_i^\\top \\mathbf{w} + t \\ge 0, \\quad \\forall i \\in \\{1, \\dots, N\\} \\\\\n& u_i \\ge 0, \\quad \\forall i \\in \\{1, \\dots, N\\} \\\\\n& \\text{and additional portfolio constraints on } \\mathbf{w}.\n\\end{array}\n$$\nThe decision variables are the weight vector $\\mathbf{w} \\in \\mathbb{R}^n$, the VaR proxy $t \\in \\mathbb{R}$, and the excess loss variables $\\mathbf{u} \\in \\mathbb{R}^N$.\n\nThe portfolio constraints are:\n1.  Full investment (budget constraint): $\\sum_{j=1}^n w_j = \\mathbf{1}^\\top \\mathbf{w} = 1$.\n2.  Minimum expected return: $\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i^\\top \\mathbf{w} \\ge \\mu_{\\min}$. This is equivalent to $\\bar{\\mathbf{r}}^\\top \\mathbf{w} \\ge \\mu_{\\min}$, where $\\bar{\\mathbf{r}} = \\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i$ is the vector of scenario-averaged returns.\n\nWe analyze the two specified regimes.\n\n**Regime 1: Short-selling prohibited**\nIn this regime, the weights must be non-negative. The full set of constraints for the LP is:\n$$\n\\begin{array}{ll}\n\\underset{\\mathbf{w}, t, \\mathbf{u}}{\\text{minimize}} & t + \\frac{1}{(1-\\alpha)N} \\sum_{i=1}^N u_i \\\\\n\\text{subject to} & -\\mathbf{r}_i^\\top \\mathbf{w} - t - u_i \\le 0, \\quad i=1, \\dots, N \\\\\n& -\\bar{\\mathbf{r}}^\\top \\mathbf{w} \\le -\\mu_{\\min} \\\\\n& \\mathbf{1}^\\top \\mathbf{w} = 1 \\\\\n& w_j \\ge 0, \\quad j=1, \\dots, n \\\\\n& u_i \\ge 0, \\quad i=1, \\dots, N\n\\end{array}\n$$\nThis is a standard LP form solvable by algorithms like the simplex or interior-point methods. The optimization variables are $[\\mathbf{w}^\\top, t, \\mathbf{u}^\\top]^\\top$.\n\n**Regime 2: Short-selling allowed with leverage**\nHere, weights $w_j$ can be negative. The non-negativity constraint on $\\mathbf{w}$ is replaced by a gross leverage constraint: $\\sum_{j=1}^n |w_j| \\le L$. The absolute value function is nonlinear. We linearize it by decomposing each weight $w_j$ into its positive and negative parts: $w_j = w_j^+ - w_j^-$, with $w_j^+ \\ge 0$ and $w_j^- \\ge 0$. The absolute value is then $|w_j| = w_j^+ + w_j^-$.\n\nThe portfolio weight vector becomes $\\mathbf{w} = \\mathbf{w}^+ - \\mathbf{w}^-$, where $\\mathbf{w}^+, \\mathbf{w}^- \\in \\mathbb{R}^n$ are vectors of non-negative variables. The LP for this regime is formulated over variables $\\mathbf{w}^+, \\mathbf{w}^-, t, \\mathbf{u}$:\n$$\n\\begin{array}{ll}\n\\underset{\\mathbf{w}^+, \\mathbf{w}^-, t, \\mathbf{u}}{\\text{minimize}} & t + \\frac{1}{(1-\\alpha)N} \\sum_{i=1}^N u_i \\\\\n\\text{subject to} & -\\mathbf{r}_i^\\top (\\mathbf{w}^+ - \\mathbf{w}^-) - t - u_i \\le 0, \\quad i=1, \\dots, N \\\\\n& -\\bar{\\mathbf{r}}^\\top (\\mathbf{w}^+ - \\mathbf{w}^-) \\le -\\mu_{\\min} \\\\\n& \\mathbf{1}^\\top (\\mathbf{w}^+ - \\mathbf{w}^-) = 1 \\\\\n& \\mathbf{1}^\\top (\\mathbf{w}^+ + \\mathbf{w}^-) \\le L \\\\\n& w_j^+ \\ge 0, w_j^- \\ge 0, \\quad j=1, \\dots, n \\\\\n& u_i \\ge 0, \\quad i=1, \\dots, N\n\\end{array}\n$$\nThe optimization variables vector is $[\\mathbf{w}^{+ \\top}, \\mathbf{w}^{- \\top}, t, \\mathbf{u}^\\top]^\\top$. Once the optimal $\\mathbf{w}^{+ \\star}$ and $\\mathbf{w}^{- \\star}$ are found, the optimal portfolio weights are recovered as $\\mathbf{w}^\\star = \\mathbf{w}^{+ \\star} - \\mathbf{w}^{- \\star}$.\n\nFor each test case, the corresponding LP will be constructed and solved. The optimal weights $\\mathbf{w}^\\star$ and the optimal objective value, which is the minimal $\\operatorname{CVaR}_\\alpha$, will be reported.\n\nThe following data is used for all test cases: $n=4$, $N=12$, and the return matrix $\\mathbf{R}$.\nThe vector of mean returns is $\\bar{\\mathbf{r}} = [0.004333, 0.004667, 0.004917, 0.0025]^\\top$.\n\n**Test Case 1**: $\\alpha = 0.95$, $\\mu_{\\min} = 0.003$, short-selling prohibited.\nThis uses the Regime 1 formulation. The constant factor in the objective is $1 / ((1-0.95) \\cdot 12) = 1/0.6 = 5/3$.\n\n**Test Case 2**: $\\alpha = 0.95$, $\\mu_{\\min} = 0.003$, short-selling allowed, $L = 1.5$.\nThis uses the Regime 2 formulation. The factor is again $5/3$.\n\n**Test Case 3**: $\\alpha = 0.99$, $\\mu_{\\min} = 0.0038$, short-selling allowed, $L = 2.0$.\nThis uses the Regime 2 formulation. The factor is $1 / ((1-0.99) \\cdot 12) = 1/0.12 = 25/3$.\n\nThe solution for each case will be computed using a numerical LP solver.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_cvar_optimization(R, alpha, mu_min, L=None, short_selling_prohibited=True):\n    \"\"\"\n    Solves the CVaR optimization problem.\n    \"\"\"\n    N, n = R.shape\n    r_bar = R.mean(axis=0)\n    cvar_factor = 1 / ((1 - alpha) * N)\n\n    if short_selling_prohibited:\n        # Decision variables: x = [w_1, ..., w_n, t, u_1, ..., u_N]\n        # Total variables: n + 1 + N\n        \n        # --- Objective function ---\n        # min t + cvar_factor * sum(u_i)\n        c = np.zeros(n + 1 + N)\n        c[n] = 1  # Coefficient for t\n        c[n + 1:] = cvar_factor  # Coefficients for u_i\n        \n        # --- Constraints ---\n        # A_ub * x <= b_ub\n        # A_eq * x == b_eq\n\n        # Inequality constraints:\n        # 1. -r_bar.T @ w <= -mu_min\n        # 2. -R @ w - t - u <= 0 --> -R @ w - t*1 - I @ u <= 0\n        A_ub = np.zeros((N + 1, n + 1 + N))\n        b_ub = np.zeros(N + 1)\n        \n        # Expected return constraint\n        A_ub[0, :n] = -r_bar\n        b_ub[0] = -mu_min\n\n        # CVaR constraints\n        A_ub[1:, :n] = -R\n        A_ub[1:, n] = -1\n        A_ub[1:, n + 1:] = -np.eye(N)\n        \n        # Equality constraints (budget):\n        # 1. sum(w_j) = 1\n        A_eq = np.zeros((1, n + 1 + N))\n        A_eq[0, :n] = 1\n        b_eq = np.array([1])\n        \n        # --- Bounds ---\n        # w_j >= 0, u_i >= 0, t is free\n        bounds = [(0, None)] * n + [(None, None)] + [(0, None)] * N\n        \n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if not res.success:\n            raise RuntimeError(f\"Optimization failed: {res.message}\")\n        \n        w_opt = res.x[:n]\n        cvar_opt = res.fun\n        \n        return w_opt, cvar_opt\n        \n    else:  # Short-selling allowed with leverage\n        # Decision variables: x = [w_p_1, ..., w_p_n, w_m_1, ..., w_m_n, t, u_1, ..., u_N]\n        # Total variables: 2*n + 1 + N\n        \n        # --- Objective function ---\n        c = np.zeros(2 * n + 1 + N)\n        c[2 * n] = 1  # Coefficient for t\n        c[2 * n + 1:] = cvar_factor # Coefficients for u_i\n\n        # --- Constraints ---\n        # Inequality constraints:\n        # 1. Leverage: sum(w_p_j + w_m_j) <= L\n        # 2. Expected return: -r_bar.T @ (w_p - w_m) <= -mu_min\n        # 3. CVaR: -R @ (w_p - w_m) - t - u <= 0\n        A_ub = np.zeros((1 + 1 + N, 2 * n + 1 + N))\n        b_ub = np.zeros(1 + 1 + N)\n        \n        # Leverage constraint\n        A_ub[0, :2 * n] = 1\n        b_ub[0] = L\n\n        # Expected return constraint\n        A_ub[1, :n] = -r_bar\n        A_ub[1, n:2 * n] = r_bar\n        b_ub[1] = -mu_min\n\n        # CVaR constraints\n        A_ub[2:, :n] = -R\n        A_ub[2:, n:2 * n] = R\n        A_ub[2:, 2 * n] = -1\n        A_ub[2:, 2 * n + 1:] = -np.eye(N)\n        \n        # Equality constraints (budget):\n        # 1. sum(w_p_j - w_m_j) = 1\n        A_eq = np.zeros((1, 2 * n + 1 + N))\n        A_eq[0, :n] = 1\n        A_eq[0, n:2 * n] = -1\n        b_eq = np.array([1])\n        \n        # --- Bounds ---\n        # w_p_j >= 0, w_m_j >= 0, u_i >= 0, t is free\n        bounds = [(0, None)] * (2 * n) + [(None, None)] + [(0, None)] * N\n\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if not res.success:\n            raise RuntimeError(f\"Optimization failed: {res.message}\")\n\n        w_p = res.x[:n]\n        w_m = res.x[n:2 * n]\n        w_opt = w_p - w_m\n        cvar_opt = res.fun\n        \n        return w_opt, cvar_opt\n\n\ndef solve():\n    R = np.array([\n        [0.01, 0.005, -0.02, 0.002],\n        [0.015, -0.01, 0.03, 0.003],\n        [-0.02, 0.018, 0.025, 0.0025],\n        [0.005, 0.004, -0.015, 0.002],\n        [0.012, -0.005, 0.022, 0.003],\n        [-0.015, 0.02, -0.018, 0.0025],\n        [0.008, 0.001, 0.027, 0.002],\n        [0.004, 0.003, -0.012, 0.003],\n        [0.02, -0.012, 0.019, 0.0025],\n        [-0.01, 0.017, -0.014, 0.002],\n        [0.006, -0.004, 0.021, 0.003],\n        [0.007, 0.009, -0.016, 0.0025]\n    ])\n\n    test_cases = [\n        # alpha, mu_min, L, short_selling_prohibited\n        (0.95, 0.003, None, True),\n        (0.95, 0.003, 1.5, False),\n        (0.99, 0.0038, 2.0, False)\n    ]\n\n    results = []\n    for alpha, mu_min, L, ssp in test_cases:\n        w_opt, cvar_opt = solve_cvar_optimization(R, alpha, mu_min, L, ssp)\n        \n        # Round to 6 decimal places\n        result_list = [round(w, 6) for w in w_opt] + [round(cvar_opt, 6)]\n        results.append(result_list)\n    \n    # Format the output string precisely as required, without extra spaces\n    res_strings = [f\"[{','.join(f'{v:.6f}' for v in r)}]\" for r in results]\n    final_output = f\"[{','.join(res_strings)}]\"\n    print(final_output)\n\nsolve()\n```"}, {"introduction": "A model is only as good as its inputs. This practice elevates our analysis by moving from raw historical returns to a more structured view of risk using a linear factor model, a cornerstone of modern asset pricing [@problem_id:2382483]. You will first construct asset return scenarios based on systematic factor exposures and then use these scenarios to perform a CVaR optimization, learning how to integrate econometric models into the portfolio construction process.", "id": "2382483", "problem": "Implement a complete program that solves the following optimization problem from first principles.\n\nYou are given a linear factor model of asset returns. There are $n = 4$ assets and $k = 3$ systematic factors. The asset returns in scenario $s \\in \\{1,\\dots,S\\}$, with $S=12$, are modeled as\n$$\nr_{i,s} = \\boldsymbol{b}_i^{\\top} \\boldsymbol{f}_s + e_{i,s},\n$$\nwhere $\\boldsymbol{b}_i \\in \\mathbb{R}^k$ is the factor loading vector for asset $i$, $\\boldsymbol{f}_s \\in \\mathbb{R}^k$ is the factor return vector in scenario $s$, and $e_{i,s} \\in \\mathbb{R}$ is the idiosyncratic residual in scenario $s$ for asset $i$. The expected factor return vector is $\\boldsymbol{\\mu}_f \\in \\mathbb{R}^k$, and $\\mathbb{E}[e_{i,s}] = 0$ for all $i,s$. The portfolio weight vector is $\\boldsymbol{w} \\in \\mathbb{R}^n$, subject to long-only and full-investment constraints:\n$$\n\\sum_{i=1}^n w_i = 1,\\quad w_i \\ge 0 \\text{ for all } i.\n$$\nThe portfolio return in scenario $s$ is\n$$\nr_{p,s} = \\sum_{i=1}^n w_i r_{i,s},\n$$\nand the portfolio expected return is\n$$\n\\mathbb{E}[r_p] = \\sum_{i=1}^n w_i \\mathbb{E}[r_i] = \\sum_{i=1}^n w_i \\boldsymbol{b}_i^{\\top} \\boldsymbol{\\mu}_f.\n$$\nDefine the portfolio loss in scenario $s$ as $L_s = -r_{p,s}$. For a confidence level $\\alpha \\in (0,1)$, the Value at Risk (VaR) at level $\\alpha$ is the $\\alpha$-quantile of $\\{L_s\\}_{s=1}^S$, and the Conditional Value at Risk (CVaR) at level $\\alpha$ is the expected loss conditional on exceeding the VaR:\n$$\n\\text{CVaR}_\\alpha(L) = \\mathbb{E}[L \\mid L \\ge \\text{VaR}_\\alpha(L)].\n$$\nYour task is, for each specified test case $(\\alpha, r_{\\min})$, to compute the minimum possible $\\text{CVaR}_\\alpha(L)$ over all feasible $\\boldsymbol{w}$ that satisfy the constraints and the minimum expected return requirement\n$$\n\\mathbb{E}[r_p] \\ge r_{\\min}.\n$$\nUse the following data, which must be treated as exact:\n\n- Number of assets $n = 4$, number of factors $k = 3$, number of scenarios $S = 12$.\n\n- Factor loading matrix $\\mathbf{B} \\in \\mathbb{R}^{n \\times k}$, with rows $\\boldsymbol{b}_i^{\\top}$:\n$$\n\\mathbf{B} =\n\\begin{bmatrix}\n1.1 & 0.3 & 0.2 \\\\\n0.9 & 0.1 & -0.1 \\\\\n1.4 & -0.2 & 0.5 \\\\\n0.7 & 0.5 & 0.0\n\\end{bmatrix}.\n$$\n\n- Expected factor return vector $\\boldsymbol{\\mu}_f \\in \\mathbb{R}^k$:\n$$\n\\boldsymbol{\\mu}_f = \\begin{bmatrix} 0.004 \\\\ 0.003 \\\\ 0.002 \\end{bmatrix}.\n$$\n\n- Factor return scenarios $\\mathbf{F} \\in \\mathbb{R}^{S \\times k}$, with rows $\\boldsymbol{f}_s^{\\top}$ for $s=1,\\dots,12$:\n$$\n\\mathbf{F} =\n\\begin{bmatrix}\n0.015 & 0.010 & 0.005 \\\\\n-0.020 & -0.015 & -0.010 \\\\\n0.025 & 0.005 & 0.000 \\\\\n0.010 & -0.005 & 0.004 \\\\\n-0.030 & 0.020 & -0.005 \\\\\n0.005 & 0.000 & 0.007 \\\\\n0.018 & -0.012 & 0.003 \\\\\n-0.012 & 0.018 & 0.006 \\\\\n0.022 & 0.012 & -0.004 \\\\\n-0.015 & -0.008 & 0.002 \\\\\n0.008 & 0.006 & -0.006 \\\\\n-0.005 & 0.004 & 0.009\n\\end{bmatrix}.\n$$\n\n- Idiosyncratic residual matrix $\\mathbf{E} \\in \\mathbb{R}^{S \\times n}$, with entries $e_{i,s}$ arranged as rows $s=1,\\dots,12$ and columns $i=1,\\dots,4$:\n$$\n\\mathbf{E} =\n\\begin{bmatrix}\n0.0010 & -0.0010 & 0.0005 & -0.0005 \\\\\n-0.0020 & 0.0010 & -0.0005 & 0.0005 \\\\\n0.0000 & -0.0020 & 0.0010 & -0.0010 \\\\\n0.0010 & 0.0010 & -0.0010 & 0.0010 \\\\\n-0.0010 & 0.0020 & 0.0000 & 0.0000 \\\\\n0.0000 & -0.0010 & 0.0005 & -0.0005 \\\\\n0.0020 & 0.0000 & -0.0005 & 0.0005 \\\\\n-0.0010 & -0.0020 & 0.0010 & -0.0010 \\\\\n0.0010 & 0.0010 & -0.0010 & 0.0010 \\\\\n-0.0010 & 0.0000 & 0.0000 & 0.0000 \\\\\n0.0000 & 0.0010 & 0.0005 & -0.0005 \\\\\n0.0010 & -0.0010 & -0.0005 & 0.0005\n\\end{bmatrix}.\n$$\n\nFor each test case $(\\alpha, r_{\\min})$, form the scenario asset return matrix $\\mathbf{R} \\in \\mathbb{R}^{S \\times n}$ as\n$$\n\\mathbf{R} = \\mathbf{F} \\mathbf{B}^{\\top} + \\mathbf{E},\n$$\ncompute $r_{p,s} = \\sum_{i=1}^n w_i R_{s,i}$, define $L_s = - r_{p,s}$, and find the minimum achievable $\\text{CVaR}_\\alpha(L)$ over all $\\boldsymbol{w}$ that satisfy the constraints and $\\mathbb{E}[r_p] \\ge r_{\\min}$.\n\nTest suite (four test cases), each with $(\\alpha, r_{\\min})$:\n- Case $1$: $(0.95,\\ 0.003)$.\n- Case $2$: $(0.99,\\ 0.000)$.\n- Case $3$: $(0.90,\\ 0.004)$.\n- Case $4$: $(0.95,\\ 0.006)$.\n\nYour program should compute, for each case, the minimized $\\text{CVaR}_\\alpha(L)$ as a real number. The final output format must be a single line containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases (for example, $[x_1,x_2,x_3,x_4]$). No units are required. All numerical answers must be printed as base-$10$ decimals.", "solution": "The user has provided a well-defined problem in computational finance. The task is to find the minimum Conditional Value at Risk (CVaR) for a portfolio of assets, subject to a set of constraints. This is a classic portfolio optimization problem that can be formulated and solved as a linear program (LP).\n\n### Step 1: Problem Validation\n\nThe first step is to validate the problem statement.\n\n**Givens Extracted:**\n- **Model parameters**: Number of assets $n = 4$, number of factors $k = 3$, number of scenarios $S = 12$.\n- **Asset return model**: $r_{i,s} = \\boldsymbol{b}_i^{\\top} \\boldsymbol{f}_s + e_{i,s}$.\n- **Data matrices and vectors**: Factor loading matrix $\\mathbf{B} \\in \\mathbb{R}^{4 \\times 3}$, expected factor return vector $\\boldsymbol{\\mu}_f \\in \\mathbb{R}^3$, factor return scenarios matrix $\\mathbf{F} \\in \\mathbb{R}^{12 \\times 3}$, and idiosyncratic residual matrix $\\mathbf{E} \\in \\mathbb{R}^{12 \\times 4}$. All numerical values are provided.\n- **Portfolio constraints**: Long-only ($w_i \\ge 0$ for $i=1,\\dots,n$) and full-investment ($\\sum_{i=1}^n w_i = 1$).\n- **Objective**: Minimize $\\text{CVaR}_\\alpha(L)$ where $L_s = -r_{p,s} = -\\sum_{i=1}^n w_i r_{i,s}$ is the portfolio loss in scenario $s$.\n- **Performance constraint**: The portfolio expected return $\\mathbb{E}[r_p] = \\sum_{i=1}^n w_i \\boldsymbol{b}_i^{\\top} \\boldsymbol{\\mu}_f$ must satisfy $\\mathbb{E}[r_p] \\ge r_{\\min}$.\n- **Test cases**: Four pairs of $(\\alpha, r_{\\min})$ are provided for computation.\n\n**Validation Verdict:**\nThe problem is **valid**.\n1.  **Scientifically Grounded**: The problem is based on the standard linear factor model for asset returns and utilizes Conditional Value at Risk (CVaR), a coherent and widely accepted risk measure in modern portfolio theory. The task of minimizing CVaR is a staple of financial engineering.\n2.  **Well-Posed**: The problem is structured as a convex optimization problem, specifically a linear program. The constraints define a non-empty, convex, and compact feasible set for the portfolio weights. The objective function is linear. Therefore, a unique and stable solution exists. All necessary data are provided.\n3.  **Objective**: The problem is stated using precise, unambiguous mathematical terminology, free of any subjective or speculative content.\n\nThe problem is sound and can be solved using established mathematical methods.\n\n### Step 2: Principled Solution using Linear Programming\n\nThe core of the problem is the minimization of CVaR based on a discrete set of $S$ scenarios. This can be formulated as a linear program.\n\n**A. Preprocessing of Financial Data**\n\nFirst, we compute two key quantities from the given data:\n1.  The vector of expected asset returns, $\\boldsymbol{\\mu}_r \\in \\mathbb{R}^n$. The expected return for asset $i$ is $\\mathbb{E}[r_i] = \\boldsymbol{b}_i^{\\top} \\boldsymbol{\\mu}_f$, since $\\mathbb{E}[e_{i,s}]=0$. In matrix notation:\n    $$\n    \\boldsymbol{\\mu}_r = \\mathbf{B} \\boldsymbol{\\mu}_f\n    $$\n2.  The matrix of scenario-based asset returns, $\\mathbf{R} \\in \\mathbb{R}^{S \\times n}$. The entry $R_{s,i}$ is the return of asset $i$ in scenario $s$. In matrix notation:\n    $$\n    \\mathbf{R} = \\mathbf{F} \\mathbf{B}^{\\top} + \\mathbf{E}\n    $$\n    The portfolio's return in scenario $s$ is then given by $r_{p,s} = \\boldsymbol{R}_s^{\\top} \\boldsymbol{w}$, where $\\boldsymbol{R}_s^{\\top}$ is the $s$-th row of $\\mathbf{R}$. The portfolio loss is $L_s = -r_{p,s}$.\n\n**B. Linear Programming Formulation for CVaR Minimization**\n\nFor a set of $S$ scenarios with equal probability $1/S$, the CVaR at confidence level $\\alpha$ can be found by solving the following optimization problem:\n$$\n\\text{CVaR}_\\alpha(L) = \\min_{\\zeta \\in \\mathbb{R}} \\left( \\zeta + \\frac{1}{S(1-\\alpha)} \\sum_{s=1}^S \\max(0, L_s - \\zeta) \\right)\n$$\nHere, $\\zeta$ is an optimization variable that corresponds to the Value at Risk (VaR). To make this problem suitable for a linear program solver, we introduce a vector of auxiliary variables $\\boldsymbol{z} \\in \\mathbb{R}^S$, where each $z_s$ represents the excess loss over $\\zeta$, i.e., $z_s \\ge \\max(0, L_s - \\zeta)$.\n\nOur goal is to minimize CVaR by choosing the portfolio weights $\\boldsymbol{w}$. The complete optimization problem involves finding the optimal $\\boldsymbol{w}$, $\\zeta$, and $\\boldsymbol{z}$. The problem becomes:\n\n$$\n\\min_{\\boldsymbol{w}, \\zeta, \\boldsymbol{z}} \\quad \\zeta + \\frac{1}{S(1-\\alpha)} \\sum_{s=1}^S z_s\n$$\nsubject to the following linear constraints:\n\n1.  **Excess Loss Constraints**: For each scenario $s=1, \\dots, S$, the variable $z_s$ must capture the loss exceeding $\\zeta$:\n    $$\n    z_s \\ge L_s - \\zeta \\implies z_s \\ge -(\\mathbf{R}_s^{\\top} \\boldsymbol{w}) - \\zeta\n    $$\n    This is equivalent to: $-\\boldsymbol{R}_s^{\\top} \\boldsymbol{w} - \\zeta - z_s \\le 0$.\n2.  **Non-negativity of Excess Loss**:\n    $$\n    z_s \\ge 0\n    $$\n3.  **Full Investment Constraint**: The weights must sum to one.\n    $$\n    \\sum_{i=1}^n w_i = 1\n    $$\n4.  **Long-Only Constraint**: All portfolio weights must be non-negative.\n    $$\n    w_i \\ge 0 \\quad \\text{for } i=1, \\dots, n\n    $$\n5.  **Minimum Expected Return Constraint**: The portfolio's expected return must meet the specified minimum.\n    $$\n    \\mathbb{E}[r_p] = \\boldsymbol{\\mu}_r^{\\top} \\boldsymbol{w} \\ge r_{\\min}\n    $$\n    This is equivalent to: $-\\boldsymbol{\\mu}_r^{\\top} \\boldsymbol{w} \\le -r_{\\min}$.\n\n**C. Standard LP Form**\n\nThis problem can be cast into the standard LP form $\\min \\boldsymbol{c}^{\\top}\\boldsymbol{x}$ subject to $\\mathbf{A}_{ub}\\boldsymbol{x} \\le \\boldsymbol{b}_{ub}$ and $\\mathbf{A}_{eq}\\boldsymbol{x} = \\boldsymbol{b}_{eq}$, with bounds on $\\boldsymbol{x}$.\n\n-   **Decision Variable Vector**: We define a single vector of decision variables $\\boldsymbol{x} \\in \\mathbb{R}^{n+1+S}$:\n    $$\n    \\boldsymbol{x} = [\\boldsymbol{w}^{\\top}, \\zeta, \\boldsymbol{z}^{\\top}]^{\\top} = [w_1, \\dots, w_n, \\zeta, z_1, \\dots, z_S]^{\\top}\n    $$\n-   **Objective Function Vector**: The vector $\\boldsymbol{c} \\in \\mathbb{R}^{n+1+S}$ defines the objective function:\n    $$\n    \\boldsymbol{c} = [0, \\dots, 0, 1, \\frac{1}{S(1-\\alpha)}, \\dots, \\frac{1}{S(1-\\alpha)}]^{\\top}\n    $$\n    (where there are $n$ initial zeros).\n-   **Equality Constraints**: The full-investment constraint is the only equality: $\\mathbf{A}_{eq}\\boldsymbol{x} = \\boldsymbol{b}_{eq}$, where:\n    $$\n    \\mathbf{A}_{eq} = [\\underbrace{1, \\dots, 1}_{n}, \\underbrace{0, \\dots, 0}_{1+S}] \\quad \\text{and} \\quad \\boldsymbol{b}_{eq} = [1]\n    $$\n-   **Inequality Constraints**: The constraints on excess loss and minimum return form the inequalities $\\mathbf{A}_{ub}\\boldsymbol{x} \\le \\boldsymbol{b}_{ub}$. The matrix $\\mathbf{A}_{ub} \\in \\mathbb{R}^{(S+1) \\times (n+1+S)}$ and vector $\\boldsymbol{b}_{ub} \\in \\mathbb{R}^{S+1}$ are structured as follows:\n    - For rows $s=1, \\dots, S$ (from constraint 1):\n      $$\n      (\\mathbf{A}_{ub})_{s,j} = \\begin{cases} -R_{s,j} & 1 \\le j \\le n \\\\ -1 & j = n+1 \\\\ -1 & j = n+1+s \\\\ 0 & \\text{otherwise} \\end{cases}, \\quad (\\boldsymbol{b}_{ub})_s = 0\n      $$\n    - For row $S+1$ (from constraint 5):\n      $$\n      (\\mathbf{A}_{ub})_{S+1,j} = \\begin{cases} -(\\boldsymbol{\\mu}_r)_j & 1 \\le j \\le n \\\\ 0 & \\text{otherwise} \\end{cases}, \\quad (\\boldsymbol{b}_{ub})_{S+1} = -r_{\\min}\n      $$\n-   **Bounds**: The non-negativity constraints on $\\boldsymbol{w}$ and $\\boldsymbol{z}$ are handled as bounds on the variables:\n    - $0 \\le w_i \\le 1$ for $i=1, \\dots, n$. (The upper bound $1$ is implied but helpful for the solver).\n    - $-\\infty < \\zeta < \\infty$ (unbounded).\n    - $z_s \\ge 0$ for $s=1, \\dots, S$.\n\nWith this formulation, a standard LP solver like `scipy.optimize.linprog` can be used to find the optimal solution vector $\\boldsymbol{x}^*$. The minimal CVaR value is then given by the optimal objective function value, $\\boldsymbol{c}^{\\top}\\boldsymbol{x}^*$. This procedure is repeated for each test case.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the CVaR optimization problem for a series of test cases.\n    \"\"\"\n    # Define given constants and data\n    n = 4  # number of assets\n    k = 3  # number of factors\n    S = 12 # number of scenarios\n\n    B = np.array([\n        [1.1, 0.3, 0.2],\n        [0.9, 0.1, -0.1],\n        [1.4, -0.2, 0.5],\n        [0.7, 0.5, 0.0]\n    ])\n\n    mu_f = np.array([0.004, 0.003, 0.002])\n\n    F = np.array([\n        [0.015, 0.010, 0.005],\n        [-0.020, -0.015, -0.010],\n        [0.025, 0.005, 0.000],\n        [0.010, -0.005, 0.004],\n        [-0.030, 0.020, -0.005],\n        [0.005, 0.000, 0.007],\n        [0.018, -0.012, 0.003],\n        [-0.012, 0.018, 0.006],\n        [0.022, 0.012, -0.004],\n        [-0.015, -0.008, 0.002],\n        [0.008, 0.006, -0.006],\n        [-0.005, 0.004, 0.009]\n    ])\n\n    E = np.array([\n        [0.0010, -0.0010, 0.0005, -0.0005],\n        [-0.0020, 0.0010, -0.0005, 0.0005],\n        [0.0000, -0.0020, 0.0010, -0.0010],\n        [0.0010, 0.0010, -0.0010, 0.0010],\n        [-0.0010, 0.0020, 0.0000, 0.0000],\n        [0.0000, -0.0010, 0.0005, -0.0005],\n        [0.0020, 0.0000, -0.0005, 0.0005],\n        [-0.0010, -0.0020, 0.0010, -0.0010],\n        [0.0010, 0.0010, -0.0010, 0.0010],\n        [-0.0010, 0.0000, 0.0000, 0.0000],\n        [0.0000, 0.0010, 0.0005, -0.0005],\n        [0.0010, -0.0010, -0.0005, 0.0005]\n    ])\n\n    # Test cases: (alpha, r_min)\n    test_cases = [\n        (0.95, 0.003),\n        (0.99, 0.000),\n        (0.90, 0.004),\n        (0.95, 0.006)\n    ]\n\n    # Preprocessing: Calculate scenario returns and expected returns\n    # R has shape (S, n)\n    R = F @ B.T + E\n    # mu_r has shape (n,)\n    mu_r = B @ mu_f\n\n    results = []\n    for alpha, r_min in test_cases:\n        # Formulate the Linear Program for CVaR minimization\n        # Decision variables x = [w_1, ..., w_n, zeta, z_1, ..., z_S]\n        # Total number of variables is n + 1 + S\n        n_vars = n + 1 + S\n\n        # Objective function: min (zeta + 1/(S*(1-alpha)) * sum(z_s))\n        c = np.zeros(n_vars)\n        c[n] = 1.0  # Coefficient for zeta\n        c[n + 1:] = 1.0 / (S * (1 - alpha)) # Coefficients for z_s\n\n        # Inequality constraints: A_ub * x <= b_ub\n        # S constraints for z_s >= -r_p,s - zeta and 1 for E[r_p] >= r_min\n        A_ub = np.zeros((S + 1, n_vars))\n        b_ub = np.zeros(S + 1)\n\n        # Constraints: -r_p,s - zeta - z_s <= 0  for s = 1,...,S\n        # - (sum_i R_si * w_i) - zeta - z_s <= 0\n        for s in range(S):\n            A_ub[s, :n] = -R[s, :]  # Coefficients for w_i\n            A_ub[s, n] = -1.0       # Coefficient for zeta\n            A_ub[s, n + 1 + s] = -1.0 # Coefficient for z_s\n        \n        # Minimum expected return constraint: E[r_p] >= r_min\n        # -E[r_p] <= -r_min => -mu_r.T @ w <= -r_min\n        A_ub[S, :n] = -mu_r\n        b_ub[S] = -r_min\n        \n        # Equality constraints: A_eq * x = b_eq\n        # Full investment constraint: sum(w_i) = 1\n        A_eq = np.zeros((1, n_vars))\n        A_eq[0, :n] = 1.0\n        b_eq = np.array([1.0])\n\n        # Bounds for variables\n        w_bounds = (0, 1) # Weights are between 0 and 1\n        zeta_bounds = (None, None) # Zeta is unbounded\n        z_bounds = (0, None) # z_s are non-negative\n\n        bounds = [w_bounds] * n + [zeta_bounds] + [z_bounds] * S\n\n        # Solve the linear program\n        res = linprog(c=c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if res.success:\n            min_cvar = res.fun\n            results.append(f\"{min_cvar:.10f}\")\n        else:\n            # Handle cases where optimization may fail, though not expected here\n            results.append(\"Error\")\n\n    # Format and print the final output\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "Now we apply our skills to a portfolio of derivative securities, whose payoffs are non-linear functions of an underlying asset's price. This exercise reveals a powerful insight: despite the non-linearity of the instruments themselves, the portfolio optimization problem can remain a linear one, showcasing the robustness of the CVaR framework [@problem_id:2382528]. You will integrate concepts from option pricing theory with risk management to construct and optimize a sophisticated portfolio of European calls, puts, and digital options.", "id": "2382528", "problem": "You are given a portfolio selection problem in which the assets are European-style derivatives written on a single underlying risk asset with terminal price denoted by $S_T$. The payoff $P(S_T)$ of each derivative is a non-linear function of $S_T$. The objective is to choose non-negative portfolio weights $w \\in \\mathbb{R}^J_{\\ge 0}$ that minimize the Conditional Value at Risk (CVaR) of the portfolio loss at a specified confidence level $0 < \\alpha < 1$, subject to a budget constraint that fully invests a given initial budget.\n\nData and modeling assumptions are as follows.\n\n1. Under the physical measure, the terminal price $S_T$ follows a lognormal distribution generated from a normal variate $Z \\sim \\mathcal{N}(0,1)$, with parameters $S_0 > 0$ (current price), $\\mu_p \\in \\mathbb{R}$ (physical drift), $\\sigma > 0$ (volatility), and horizon $T > 0$:\n$$\nS_T = S_0 \\exp\\left( \\left(\\mu_p - \\tfrac{1}{2}\\sigma^2\\right) T + \\sigma \\sqrt{T}\\, Z \\right).\n$$\nFor computational purposes, the empirical distribution of $S_T$ must be constructed using $N$ scenarios generated by an equally spaced probability grid $u_i = \\tfrac{i - 0.5}{N}$ for $i = 1,2,\\dots,N$, mapped via the inverse standard normal cumulative distribution function $\\Phi^{-1}$ to $z_i = \\Phi^{-1}(u_i)$ and then to\n$$\nS_T^{(i)} = S_0 \\exp\\left( \\left(\\mu_p - \\tfrac{1}{2}\\sigma^2\\right) T + \\sigma \\sqrt{T}\\, z_i \\right).\n$$\n\n2. The portfolio consists of $J$ derivative instruments with payoffs defined at maturity $T$ as follows, in the fixed order below. Let $K \\in \\mathbb{R}_{>0}$ denote a strike parameter. The instruments (with their payoff functions and strikes) are:\n- Instrument $1$: European call with strike $K = 90$, payoff $P_1(S_T) = \\max(S_T - 90, 0)$.\n- Instrument $2$: European call with strike $K = 100$, payoff $P_2(S_T) = \\max(S_T - 100, 0)$.\n- Instrument $3$: European call with strike $K = 110$, payoff $P_3(S_T) = \\max(S_T - 110, 0)$.\n- Instrument $4$: European put with strike $K = 90$, payoff $P_4(S_T) = \\max(90 - S_T, 0)$.\n- Instrument $5$: European put with strike $K = 100$, payoff $P_5(S_T) = \\max(100 - S_T, 0)$.\n- Instrument $6$: European put with strike $K = 110$, payoff $P_6(S_T) = \\max(110 - S_T, 0)$.\n- Instrument $7$: European digital call with strike $K = 100$, payoff $P_7(S_T) = \\mathbf{1}_{\\{S_T > 100\\}}$.\n\n3. Initial costs $c_j$ for $j = 1,\\dots,7$ must be computed under the Blackâ€“Scholes framework with risk-neutral drift $r$ and the same volatility $\\sigma$ and maturity $T$. Specifically, using the standard Blackâ€“Scholes notation\n$$\nd_1 = \\frac{\\ln\\left(\\frac{S_0}{K}\\right) + \\left(r + \\tfrac{1}{2}\\sigma^2\\right) T}{\\sigma \\sqrt{T}}, \\quad\nd_2 = d_1 - \\sigma \\sqrt{T}, \\quad \\Phi(\\cdot) \\text{ is the standard normal CDF},\n$$\nthe time-$0$ prices are:\n- European call: $c_{\\text{call}}(S_0,K,\\sigma,r,T) = S_0 \\Phi(d_1) - K e^{-rT} \\Phi(d_2)$.\n- European put: $c_{\\text{put}}(S_0,K,\\sigma,r,T) = K e^{-rT} \\Phi(-d_2) - S_0 \\Phi(-d_1)$.\n- European digital call: $c_{\\text{dig}}(S_0,K,\\sigma,r,T) = e^{-rT} \\Phi(d_2)$.\n\n4. The portfolio loss in scenario $i$ for weights $w \\in \\mathbb{R}^7_{\\ge 0}$ is defined as\n$$\nL_i(w) = \\sum_{j=1}^{7} w_j \\left( c_j e^{rT} - P_j\\left(S_T^{(i)}\\right) \\right).\n$$\nThis loss is measured at time $T$ by compounding initial costs at the continuously compounded risk-free rate $r$ to time $T$ and subtracting the realized payoff.\n\n5. The Conditional Value at Risk at level $\\alpha$ for the empirical loss distribution $\\{L_i(w)\\}_{i=1}^N$ is defined as the average of the worst $(1-\\alpha)$ fraction of losses (i.e., the tail mean beyond the Value at Risk), using the empirical distribution induced by the $N$ equally likely scenarios. In case $(1-\\alpha)N$ is not an integer, interpret the average via the standard tail-averaging definition with the appropriate fractional weighting.\n\n6. The optimization problem is:\n- Decision variables: $w \\in \\mathbb{R}^7_{\\ge 0}$.\n- Objective: minimize the CVaR at level $\\alpha$ of the empirical loss distribution $\\{L_i(w)\\}_{i=1}^N$.\n- Constraints: full-investment budget\n$$\n\\sum_{j=1}^{7} c_j w_j = B,\n$$\nand non-negativity $w_j \\ge 0$ for $j = 1,\\dots,7$.\n\nYour task is to implement a program that, for each test case below, constructs the $N$ scenarios $\\{S_T^{(i)}\\}_{i=1}^N$, computes the derivative prices $\\{c_j\\}_{j=1}^7$, solves the CVaR-minimization problem above, and outputs the optimal weight vector $w^\\star$ corresponding to the instrument ordering specified in point $2$.\n\nTest Suite. For each test case, use the specified parameter values:\n- Test case $1$: $S_0 = 100$, $r = 0.02$, $T = 1$, $\\mu_p = 0.05$, $\\sigma = 0.2$, $\\alpha = 0.95$, $B = 10$, $N = 200$.\n- Test case $2$: $S_0 = 100$, $r = 0.02$, $T = 1$, $\\mu_p = 0.02$, $\\sigma = 0.2$, $\\alpha = 0.99$, $B = 10$, $N = 200$.\n- Test case $3$: $S_0 = 100$, $r = 0.02$, $T = 1$, $\\mu_p = 0.02$, $\\sigma = 0.01$, $\\alpha = 0.95$, $B = 10$, $N = 200$.\n\nRequired final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the $k$-th element is itself a list of $7$ floating-point numbers (rounded to $6$ decimal places) giving the optimal weights for test case $k$ in the instrument order in point $2$. For example, an output for three tests must look like\n$$\n[[w_{1,1},w_{1,2},\\dots,w_{1,7}],[w_{2,1},\\dots,w_{2,7}],[w_{3,1},\\dots,w_{3,7}]].\n$$\nNo additional text may be printed. All numerical answers must be dimensionless real numbers.", "solution": "The problem has been validated and is deemed to be scientifically sound, well-posed, and complete. It is a standard problem in computational finance, specifically in portfolio risk management. The models, formulas, and parameters provided are consistent and allow for a unique and meaningful solution. We shall proceed with the derivation and implementation of the solution.\n\nThe problem requires the minimization of the Conditional Value at Risk (CVaR) of a portfolio's loss, subject to budget and non-negativity constraints on the portfolio weights. This can be formulated as a Linear Program (LP), which is a computationally tractable optimization problem.\n\nLet $w \\in \\mathbb{R}^J_{\\ge 0}$ be the vector of portfolio weights for $J=7$ instruments. The loss of the portfolio in scenario $i \\in \\{1, \\dots, N\\}$ is given as a linear function of the weights:\n$$\nL_i(w) = \\sum_{j=1}^{7} w_j \\left( c_j e^{rT} - P_j\\left(S_T^{(i)}\\right) \\right)\n$$\nwhere $c_j$ is the initial cost of instrument $j$, $r$ is the risk-free rate, $T$ is the time horizon, and $P_j(S_T^{(i)})$ is the payoff of instrument $j$ under the terminal asset price scenario $S_T^{(i)}$. The initial costs are determined by the Black-Scholes model under a risk-neutral measure, while the terminal price scenarios $S_T^{(i)}$ are generated under a physical measure. This distinction is standard and appropriate.\n\nThe CVaR at a confidence level $\\alpha \\in (0, 1)$ for a loss distribution can be found by solving the following optimization problem, as established by Rockafellar and Uryasev:\n$$\n\\text{CVaR}_{\\alpha}(L(w)) = \\min_{v \\in \\mathbb{R}} \\left( v + \\frac{1}{1-\\alpha} \\mathbb{E}[\\max(L(w) - v, 0)] \\right)\n$$\nHere, $v$ is an auxiliary variable representing the Value at Risk (VaR) at level $\\alpha$. For an empirical distribution based on $N$ equally likely scenarios, the expectation is replaced by an average:\n$$\n\\text{CVaR}_{\\alpha}(\\{L_i(w)\\}) = \\min_{v \\in \\mathbb{R}} \\left( v + \\frac{1}{N(1-\\alpha)} \\sum_{i=1}^N \\max(L_i(w) - v, 0) \\right)\n$$\nThe full optimization problem is to minimize this quantity with respect to both $w$ and $v$, subject to the given constraints.\n$$\n\\min_{w, v} \\quad v + \\frac{1}{N(1-\\alpha)} \\sum_{i=1}^N \\max(L_i(w) - v, 0)\n$$\nSubject to:\n$$\n\\sum_{j=1}^{7} c_j w_j = B\n$$\n$$\nw_j \\ge 0 \\quad \\text{for } j=1, \\dots, 7\n$$\nThis is a convex but non-linear optimization problem due to the $\\max$ function. It can be transformed into an equivalent LP by introducing $N$ auxiliary variables $u_i \\ge 0$, where each $u_i$ represents the shortfall of the loss $L_i(w)$ over the VaR $v$. That is, $u_i \\ge L_i(w) - v$.\n\nThe equivalent LP is formulated as follows:\n- **Decision Variables**:\n  - $w \\in \\mathbb{R}^7$: the portfolio weights.\n  - $v \\in \\mathbb{R}$: the Value at Risk.\n  - $u \\in \\mathbb{R}^N$: the shortfall variables for each scenario.\n\n- **Objective Function**:\n  Minimize $v + \\frac{1}{N(1-\\alpha)} \\sum_{i=1}^N u_i$.\n\n- **Constraints**:\n  1. $L_i(w) - v - u_i \\le 0$ for each scenario $i=1, \\dots, N$.\n  2. $\\sum_{j=1}^{7} c_j w_j = B$ (Budget constraint).\n  3. $w_j \\ge 0$ for $j=1, \\dots, 7$ (Non-negativity of weights).\n  4. $u_i \\ge 0$ for $i=1, \\dots, N$ (Non-negativity of shortfalls).\n\nSince $L_i(w)$ is linear in $w$, the first constraint is also linear. The entire problem is thus an LP. To implement the solution, we construct the matrices for a standard LP solver. Let the vector of optimization variables be $\\mathbf{x} = [w_1, \\dots, w_7, v, u_1, \\dots, u_N]^T$, which has dimension $J+1+N = 7+1+N$.\n\n1.  **Scenario Generation**: For each test case, we generate $N$ scenarios for the terminal price $S_T$. We first create an equally spaced probability grid $p_i = (i - 0.5)/N$ for $i=1, \\dots, N$. The standard normal variates are $z_i = \\Phi^{-1}(p_i)$, where $\\Phi^{-1}$ is the inverse of the standard normal CDF. Then, the terminal prices are computed:\n    $$\n    S_T^{(i)} = S_0 \\exp\\left( \\left(\\mu_p - \\frac{1}{2}\\sigma^2\\right) T + \\sigma \\sqrt{T}\\, z_i \\right)\n    $$\n\n2.  **Derivative Pricing**: We compute the initial costs $c_j$ for the $J=7$ derivatives using the provided Black-Scholes formulas. These formulas require the parameters $S_0, T, r, \\sigma,$ and the respective strikes $K$.\n\n3.  **LP Formulation**:\n    - **Objective Vector $\\mathbf{c}_{\\text{LP}}$**: The objective is to minimize $\\mathbf{c}_{\\text{LP}}^T \\mathbf{x}$. Based on the objective function, this vector is:\n      $$\n      \\mathbf{c}_{\\text{LP}} = [\\underbrace{0, \\dots, 0}_{7 \\text{ times}}, 1, \\underbrace{\\frac{1}{N(1-\\alpha)}, \\dots, \\frac{1}{N(1-\\alpha)}}_{N \\text{ times}}]^T\n      $$\n    - **Equality Constraints $\\mathbf{A}_{\\text{eq}}\\mathbf{x} = \\mathbf{b}_{\\text{eq}}$**: This corresponds to the budget constraint.\n      $$\n      \\mathbf{A}_{\\text{eq}} = [c_1, \\dots, c_7, 0, 0, \\dots, 0] \\quad (\\text{a } 1 \\times (8+N) \\text{ matrix})\n      $$\n      $$\n      \\mathbf{b}_{\\text{eq}} = [B]\n      $$\n    - **Inequality Constraints $\\mathbf{A}_{\\text{ub}}\\mathbf{x} \\le \\mathbf{b}_{\\text{ub}}$**: These correspond to the $N$ shortfall constraints $L_i(w) - v - u_i \\le 0$. Let $\\mathbf{M}$ be an $N \\times 7$ matrix where $M_{ij} = c_j e^{rT} - P_j(S_T^{(i)})$. Then $L_i(w) = \\sum_j M_{ij} w_j$. The constraints can be written in matrix form.\n      - The first $7$ columns of $\\mathbf{A}_{\\text{ub}}$ correspond to the coefficients of $w_j$ and form the matrix $\\mathbf{M}$.\n      - The $8$-th column, for $v$, is a vector of $-1$.\n      - The last $N$ columns, for $u_i$, form the matrix $- \\mathbf{I}_N$, where $\\mathbf{I}_N$ is the $N \\times N$ identity matrix.\n      $$\n      \\mathbf{A}_{\\text{ub}} = [\\mathbf{M} \\quad -\\mathbf{1}_{N \\times 1} \\quad -\\mathbf{I}_N] \\quad (\\text{an } N \\times (8+N) \\text{ matrix})\n      $$\n      $$\n      \\mathbf{b}_{\\text{ub}} = \\mathbf{0}_{N \\times 1}\n      $$\n    - **Bounds**: The variables are subject to bounds: $w_j \\ge 0$, $v$ is unrestricted, and $u_i \\ge 0$.\n\nThis LP is then solved using a numerical solver. The optimal weights $w^\\star$ are the first $7$ elements of the resulting solution vector $\\mathbf{x}^\\star$.", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.optimize import linprog\n\ndef black_scholes_pricer(S0, K, T, r, sigma, option_type):\n    \"\"\"\n    Calculates the time-0 price of European options using the Black-Scholes model.\n    \"\"\"\n    d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    \n    if option_type == 'call':\n        price = S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    elif option_type == 'put':\n        price = K * np.exp(-r * T) * norm.cdf(-d2) - S0 * norm.cdf(-d1)\n    elif option_type == 'digital_call':\n        price = np.exp(-r * T) * norm.cdf(d2)\n    else:\n        raise ValueError(\"Invalid option type. Must be 'call', 'put', or 'digital_call'.\")\n        \n    return price\n\ndef solve():\n    \"\"\"\n    Solves the CVaR optimization problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {'S0': 100, 'r': 0.02, 'T': 1, 'mu_p': 0.05, 'sigma': 0.2, 'alpha': 0.95, 'B': 10, 'N': 200},\n        {'S0': 100, 'r': 0.02, 'T': 1, 'mu_p': 0.02, 'sigma': 0.2, 'alpha': 0.99, 'B': 10, 'N': 200},\n        {'S0': 100, 'r': 0.02, 'T': 1, 'mu_p': 0.02, 'sigma': 0.01, 'alpha': 0.95, 'B': 10, 'N': 200},\n    ]\n\n    # Instrument definitions\n    J = 7\n    instrument_strikes = np.array([90, 100, 110, 90, 100, 110, 100], dtype=float)\n    instrument_types = ['call', 'call', 'call', 'put', 'put', 'put', 'digital_call']\n\n    final_results = []\n\n    for params in test_cases:\n        S0, r, T, mu_p, sigma, alpha, B, N = \\\n            params['S0'], params['r'], params['T'], params['mu_p'], \\\n            params['sigma'], params['alpha'], params['B'], params['N']\n\n        # Step 1: Scenario Generation\n        u = (np.arange(1, N + 1) - 0.5) / N\n        z = norm.ppf(u)\n        S_T = S0 * np.exp((mu_p - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * z)\n\n        # Step 2: Derivative Pricing\n        costs = np.array([\n            black_scholes_pricer(S0, K, T, r, sigma, opt_type)\n            for K, opt_type in zip(instrument_strikes, instrument_types)\n        ])\n\n        # Step 3: Calculate Payoffs for each scenario\n        payoffs = np.zeros((N, J))\n        payoffs[:, 0] = np.maximum(S_T - 90, 0)\n        payoffs[:, 1] = np.maximum(S_T - 100, 0)\n        payoffs[:, 2] = np.maximum(S_T - 110, 0)\n        payoffs[:, 3] = np.maximum(90 - S_T, 0)\n        payoffs[:, 4] = np.maximum(100 - S_T, 0)\n        payoffs[:, 5] = np.maximum(110 - S_T, 0)\n        payoffs[:, 6] = (S_T > 100).astype(float)\n\n        # Step 4: Construct the Linear Program\n        num_vars = J + 1 + N\n        \n        # Objective function vector\n        c_lp = np.zeros(num_vars)\n        c_lp[J] = 1.0  # Coefficient for v\n        c_lp[J + 1:] = 1.0 / (N * (1 - alpha)) # Coefficients for u_i\n\n        # Equality constraint (budget)\n        A_eq = np.zeros((1, num_vars))\n        A_eq[0, :J] = costs\n        b_eq = np.array([B])\n        \n        # Inequality constraints (loss vs VaR)\n        loss_matrix = costs * np.exp(r * T) - payoffs # Shape (N, J)\n        \n        A_ub = np.zeros((N, num_vars))\n        A_ub[:, :J] = loss_matrix\n        A_ub[:, J] = -1.0 # Coefficients for -v\n        A_ub[:, J + 1:] = -np.eye(N) # Coefficients for -u_i\n        b_ub = np.zeros(N)\n\n        # Bounds for variables\n        bounds = [(0, None)] * J + [(None, None)] + [(0, None)] * N\n\n        # Step 5: Solve the LP\n        res = linprog(c=c_lp, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        optimal_weights = res.x[:J]\n        \n        # Format results\n        formatted_weights = [f\"{w:.6f}\" for w in optimal_weights]\n        final_results.append(f\"[{','.join(formatted_weights)}]\")\n    \n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"}]}