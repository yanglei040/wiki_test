{"hands_on_practices": [{"introduction": "Building a predictive model is a cornerstone of computational finance, and this first exercise guides you through a complete, practical workflow. Using a hypothetical dataset for mortgage default prediction, you will implement and compare two of the most common Support Vector Machine classifiers: one with a linear kernel and another with a non-linear Radial Basis Function (RBF) kernel. This practice will solidify your understanding of cross-validation for robust model evaluation and challenge you to interpret what the best-performing kernel implies about the nature of credit risk [@problem_id:2435431].", "id": "2435431", "problem": "You are given a binary classification task in computational economics and finance: predicting mortgage default using Support Vector Machines (SVM). The labels are $y \\in \\{-1, +1\\}$, where $+1$ denotes default and $-1$ denotes no default. Each observation has $3$ features: loan-to-value ratio $(x_1)$ as a decimal, debt-to-income ratio $(x_2)$ as a decimal, and FICO score $(x_3)$ as an integer. The dataset consists of $20$ observations indexed by $i \\in \\{1,2,\\ldots,20\\}$, specified as $(x_{i1}, x_{i2}, x_{i3}; y_i)$:\n- $1$: $(0.65, 0.18, 780; -1)$\n- $2$: $(0.70, 0.20, 760; -1)$\n- $3$: $(0.75, 0.25, 740; -1)$\n- $4$: $(0.80, 0.22, 770; -1)$\n- $5$: $(0.68, 0.30, 720; -1)$\n- $6$: $(0.72, 0.28, 730; -1)$\n- $7$: $(0.85, 0.20, 750; -1)$\n- $8$: $(0.90, 0.18, 760; -1)$\n- $9$: $(0.78, 0.26, 740; -1)$\n- $10$: $(0.82, 0.27, 735; -1)$\n- $11$: $(0.95, 0.45, 660; +1)$\n- $12$: $(1.02, 0.40, 680; +1)$\n- $13$: $(0.88, 0.55, 620; +1)$\n- $14$: $(0.92, 0.50, 600; +1)$\n- $15$: $(1.05, 0.35, 650; +1)$\n- $16$: $(0.90, 0.60, 590; +1)$\n- $17$: $(0.98, 0.48, 630; +1)$\n- $18$: $(1.10, 0.30, 610; +1)$\n- $19$: $(0.84, 0.58, 605; +1)$\n- $20$: $(0.70, 0.40, 580; +1)$\n\nFormulate a soft-margin binary Support Vector Machine (SVM) classifier and evaluate out-of-sample classification accuracy using $k$-fold cross-validation with $k = 5$. Use the following three parameter sets as the test suite:\n- Test $A$: Linear kernel with soft-margin parameter $C = 10$.\n- Test $B$: Gaussian Radial Basis Function (RBF) kernel with $C = 10$ and $\\gamma = 0.5$.\n- Test $C$: Gaussian Radial Basis Function (RBF) kernel with $C = 10$ and $\\gamma = 2.0$.\n\nFor each of the three tests $A$, $B$, and $C$, compute the mean $5$-fold out-of-sample classification accuracy as a real number in $[0,1]$. Round each accuracy to three decimals.\n\nFinally, infer what the kernel choice implies about the nature of the credit risk mapping from features to default. Output an integer indicator defined as follows: output $1$ if the best of the RBF accuracies (from tests $B$ or $C$) exceeds the linear kernel accuracy (from test $A$) by at least $0.03$; otherwise output $0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[\\text{acc}_A,\\text{acc}_B,\\text{acc}_C,\\text{indicator}]$, where $\\text{acc}_A$ is the mean accuracy for test $A$, $\\text{acc}_B$ for test $B$, $\\text{acc}_C$ for test $C$, and $\\text{indicator}$ is the integer described above. For example, the format should be $[0.842,0.902,0.881,1]$.", "solution": "The problem presented is a standard binary classification task in machine learning, applied to the domain of computational finance. The objective is to construct and evaluate a soft-margin Support Vector Machine (SVM) classifier for predicting mortgage default. The problem is scientifically grounded, well-posed, and all necessary data and parameters are provided. It is therefore deemed valid and a formal solution will be constructed.\n\nThe core of the solution involves solving the dual optimization problem for the soft-margin SVM. For a training set of $N$ data points $(\\mathbf{x}_i, y_i)$, where $\\mathbf{x}_i \\in \\mathbb{R}^d$ are feature vectors and $y_i \\in \\{-1, +1\\}$ are labels, the dual problem is a Quadratic Programming (QP) problem formulated as follows:\n$$\n\\max_{\\boldsymbol{\\alpha}} \\mathcal{L}_D(\\boldsymbol{\\alpha}) = \\sum_{i=1}^{N} \\alpha_i - \\frac{1}{2} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\alpha_i \\alpha_j y_i y_j K(\\mathbf{x}_i, \\mathbf{x}_j)\n$$\nsubject to the constraints:\n$$\n\\sum_{i=1}^{N} \\alpha_i y_i = 0\n$$\n$$\n0 \\le \\alpha_i \\le C, \\quad \\text{for } i=1, \\ldots, N\n$$\nHere, $\\boldsymbol{\\alpha} = (\\alpha_1, \\ldots, \\alpha_N)$ is the vector of Lagrange multipliers, $C$ is the regularization parameter that controls the penalty for misclassification, and $K(\\mathbf{x}_i, \\mathbf{x}_j)$ is the kernel function. The problem is solved by minimizing the negative of the dual Lagrangian, $-\\mathcal{L}_D(\\boldsymbol{\\alpha})$, which is equivalent to minimizing $L(\\boldsymbol{\\alpha}) = \\frac{1}{2} \\boldsymbol{\\alpha}^T P \\boldsymbol{\\alpha} - \\mathbf{1}^T \\boldsymbol{\\alpha}$, where the matrix $P$ has elements $P_{ij} = y_i y_j K(\\mathbf{x}_i, \\mathbf{x}_j)$.\n\nThe problem specifies two types of kernel functions:\n$1$. **Linear Kernel**: This kernel corresponds to a linear decision boundary in the original feature space. It is defined as:\n$$\nK(\\mathbf{x}_i, \\mathbf{x}_j) = \\mathbf{x}_i^T \\mathbf{x}_j\n$$\n$2$. **Gaussian Radial Basis Function (RBF) Kernel**: This kernel allows for a non-linear decision boundary by mapping the data into an infinite-dimensional feature space. It is defined as:\n$$\nK(\\mathbf{x}_i, \\mathbf{x}_j) = \\exp(-\\gamma \\|\\mathbf{x}_i - \\mathbf{x}_j\\|^2)\n$$\nwhere $\\gamma > 0$ is a parameter that controls the width of the Gaussian.\n\nThe solution is implemented by numerically solving this QP problem using the Sequential Least Squares Programming (SLSQP) algorithm available in `scipy.optimize.minimize`. Upon finding the optimal vector $\\boldsymbol{\\alpha}^*$, the bias term $b$ is calculated. A robust method is to average over all support vectors for which $0 < \\alpha_i^* < C$, since for these points the Karush-Kuhn-Tucker (KKT) conditions imply the margin is exactly met:\n$$\nb = y_s - \\sum_{i=1}^{N} \\alpha_i^* y_i K(\\mathbf{x}_i, \\mathbf{x}_s)\n$$\nIf no such non-bound support vectors exist, $b$ is determined by taking the midpoint of the feasible interval defined by the margin constraints of the bounded support vectors ($\\alpha_i^* = C$).\n\nThe decision function for a new data point $\\mathbf{x}$ is then given by:\n$$\nf(\\mathbf{x}) = \\text{sign}\\left(\\sum_{i=1}^{N} \\alpha_i^* y_i K(\\mathbf{x}_i, \\mathbf{x}) + b\\right)\n$$\n\nA critical step in the methodology is **feature scaling**. The input features ($x_1, x_2, x_3$) have vastly different scales. The FICO score $x_3$ would otherwise dominate any distance-based calculation, such as in the RBF kernel. To address this, we apply standardization (Z-score normalization) to the features. Within each fold of the cross-validation, the mean and standard deviation are computed from the training data and then used to scale both the training and test data for that fold. This prevents data leakage from the test set into the training process.\n\nThe model's performance is evaluated using $k$-fold cross-validation with $k=5$. The dataset of $20$ observations is partitioned into $5$ disjoint folds of $4$ observations each. For each of the $5$ iterations, one fold is used as the test set and the remaining $4$ folds are used for training. The classification accuracy, defined as the fraction of correctly predicted labels on the test set, is computed for each fold. The final out-of-sample accuracy for a given parameter set is the mean of these $5$ accuracies.\n\nThis procedure is carried out for each of the three specified test cases (A, B, C). Finally, an indicator variable is computed. This variable is $1$ if the best-performing RBF kernel's accuracy exceeds the linear kernel's accuracy by at least $0.03$, and $0$ otherwise. This comparison allows for an inference about the geometric nature of the class separation; a significantly better RBF performance implies a non-linear decision boundary is more appropriate for this credit risk classification problem. The final output assembles the computed accuracies and the indicator into the required list format.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to solve the SVM cross-validation problem.\n    \"\"\"\n    # Dataset definition\n    data = [\n        (0.65, 0.18, 780, -1), (0.70, 0.20, 760, -1), (0.75, 0.25, 740, -1),\n        (0.80, 0.22, 770, -1), (0.68, 0.30, 720, -1), (0.72, 0.28, 730, -1),\n        (0.85, 0.20, 750, -1), (0.90, 0.18, 760, -1), (0.78, 0.26, 740, -1),\n        (0.82, 0.27, 735, -1), (0.95, 0.45, 660, 1), (1.02, 0.40, 680, 1),\n        (0.88, 0.55, 620, 1), (0.92, 0.50, 600, 1), (1.05, 0.35, 650, 1),\n        (0.90, 0.60, 590, 1), (0.98, 0.48, 630, 1), (1.10, 0.30, 610, 1),\n        (0.84, 0.58, 605, 1), (0.70, 0.40, 580, 1)\n    ]\n    X = np.array([d[:3] for d in data])\n    y = np.array([d[3] for d in data])\n\n    # Test cases\n    test_cases = [\n        {'C': 10.0, 'kernel_type': 'linear', 'gamma': None},\n        {'C': 10.0, 'kernel_type': 'rbf', 'gamma': 0.5},\n        {'C': 10.0, 'kernel_type': 'rbf', 'gamma': 2.0},\n    ]\n\n    # --- Kernel Functions ---\n    def linear_kernel(x1, x2):\n        return np.dot(x1, x2)\n\n    def make_rbf_kernel(gamma):\n        def rbf_kernel(x1, x2):\n            return np.exp(-gamma * np.linalg.norm(x1 - x2)**2)\n        return rbf_kernel\n\n    # --- SVM Solver ---\n    def train_svm(X_train, y_train, C, kernel_func):\n        n_samples = X_train.shape[0]\n        \n        # Build Kernel/Gram matrix\n        K = np.zeros((n_samples, n_samples))\n        for i in range(n_samples):\n            for j in range(n_samples):\n                K[i, j] = kernel_func(X_train[i], X_train[j])\n        \n        # QP problem formulation for scipy.optimize.minimize\n        # Minimize: 0.5 * alpha.T * P * alpha - 1.T * alpha\n        # P_ij = y_i * y_j * K_ij\n        P = np.outer(y_train, y_train) * K\n        # Add a small regularization for numerical stability\n        P += 1e-8 * np.eye(n_samples)\n\n\n        def objective(alpha):\n            return 0.5 * alpha.T @ P @ alpha - np.sum(alpha)\n\n        # Constraints: sum(alpha_i * y_i) = 0\n        eq_cons = {'type': 'eq',\n                   'fun': lambda alpha: y_train.T @ alpha,\n                   'jac': lambda alpha: y_train}\n\n        # Bounds: 0 <= alpha_i <= C\n        bounds = [(0, C) for _ in range(n_samples)]\n\n        # Initial guess\n        alpha0 = np.zeros(n_samples)\n\n        # Solve QP problem\n        res = minimize(objective, alpha0, method='SLSQP', bounds=bounds, constraints=[eq_cons])\n        alpha = res.x\n\n        # Find support vectors\n        sv_mask = alpha > 1e-6\n        \n        # Compute bias term 'b'\n        non_bound_sv_mask = (alpha > 1e-6) & (alpha < C - 1e-6)\n        if np.any(non_bound_sv_mask):\n            non_bound_sv_indices = np.where(non_bound_sv_mask)[0]\n            b_values = [y_train[s] - np.sum(alpha[sv_mask] * y_train[sv_mask] * K[sv_mask, s]) for s in non_bound_sv_indices]\n            b = np.mean(b_values)\n        else: # Fallback if no non-bound SVs are found\n            sv_indices = np.where(sv_mask)[0]\n            f_vals_pos = [np.sum(alpha[sv_mask] * y_train[sv_mask] * K[sv_mask, i]) for i in sv_indices if y_train[i] == 1]\n            f_vals_neg = [np.sum(alpha[sv_mask] * y_train[sv_mask] * K[sv_mask, i]) for i in sv_indices if y_train[i] == -1]\n            \n            if not f_vals_pos or not f_vals_neg:\n                # Can happen if all SVs are from one class. Use a simple mean.\n                b_vals = [y_train[i] - np.sum(alpha * y_train * K[:, i]) for i in sv_indices]\n                b = np.mean(b_vals) if b_vals else 0\n            else:\n                b = -0.5 * (np.min(f_vals_pos) + np.max(f_vals_neg))\n\n        return alpha, b\n\n    # --- Prediction Function ---\n    def predict(X_test, X_train, y_train, alpha, b, kernel_func):\n        sv_mask = alpha > 1e-6\n        alpha_sv = alpha[sv_mask]\n        y_train_sv = y_train[sv_mask]\n        X_train_sv = X_train[sv_mask]\n        \n        y_pred = np.zeros(X_test.shape[0])\n        for i in range(X_test.shape[0]):\n            s = 0\n            for j in range(alpha_sv.shape[0]):\n                s += alpha_sv[j] * y_train_sv[j] * kernel_func(X_train_sv[j], X_test[i])\n            y_pred[i] = s + b\n\n        pred_labels = np.sign(y_pred)\n        pred_labels[pred_labels == 0] = 1 # Assign a class if decision value is exactly 0\n        return pred_labels\n\n    # --- Cross-Validation ---\n    def run_cross_validation(X, y, C, kernel_func, k=5):\n        n_samples = X.shape[0]\n        fold_size = n_samples // k\n        indices = np.arange(n_samples)\n        \n        accuracies = []\n        for i in range(k):\n            # Split data into train and test sets for the current fold\n            start, end = i * fold_size, (i + 1) * fold_size\n            test_indices = indices[start:end]\n            train_indices = np.delete(indices, test_indices)\n\n            X_train, y_train = X[train_indices], y[train_indices]\n            X_test, y_test = X[test_indices], y[test_indices]\n            \n            # --- Feature Scaling ---\n            mean = np.mean(X_train, axis=0)\n            std = np.std(X_train, axis=0)\n            std[std == 0] = 1.0 # Avoid division by zero\n            \n            X_train_scaled = (X_train - mean) / std\n            X_test_scaled = (X_test - mean) / std\n            \n            # Train SVM\n            alpha, b = train_svm(X_train_scaled, y_train, C, kernel_func)\n            \n            # Predict on test set\n            y_pred = predict(X_test_scaled, X_train_scaled, y_train, alpha, b, kernel_func)\n            \n            # Calculate accuracy\n            accuracy = np.mean(y_pred == y_test)\n            accuracies.append(accuracy)\n            \n        return np.mean(accuracies)\n\n    # --- Main Execution Logic ---\n    results = []\n    for case in test_cases:\n        C = case['C']\n        if case['kernel_type'] == 'linear':\n            kernel = linear_kernel\n        else: # rbf\n            kernel = make_rbf_kernel(case['gamma'])\n        \n        mean_accuracy = run_cross_validation(X, y, C, kernel)\n        results.append(round(mean_accuracy, 3))\n    \n    acc_A, acc_B, acc_C = results\n    \n    # Compute the final indicator\n    indicator = 1 if max(acc_B, acc_C) >= acc_A + 0.03 else 0\n    results.append(indicator)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "The true power of Support Vector Machines lies in the \"kernel trick,\" which allows us to implicitly operate in high-dimensional feature spaces. This exercise takes you beyond using standard, off-the-shelf kernels by tasking you with designing a custom kernel tailored for financial time-series analysis. By integrating a time-decay component that gives more weight to recent data, you will learn how to encode crucial domain-specific knowledge directly into your model, a key skill for any quantitative analyst [@problem_id:2435408].", "id": "2435408", "problem": "You are given a binary classification task motivated by financial time-series prediction. Each sample consists of a feature vector representing summary statistics of recent returns and volatility, a timestamp indicating its position in a chronological sequence, and a label indicating whether the next-day return moved up or down. Consider the following training data with four samples, where each feature vector lies in $\\mathbb{R}^2$, each timestamp is an integer, and each label is in $\\{-1,+1\\}$:\n- Sample $1$: $x_1 = (0.00, 0.00)$, $t_1 = 1$, $y_1 = -1$.\n- Sample $2$: $x_2 = (1.00, 0.20)$, $t_2 = 2$, $y_2 = +1$.\n- Sample $3$: $x_3 = (0.90, 1.00)$, $t_3 = 3$, $y_3 = +1$.\n- Sample $4$: $x_4 = (-0.80, -0.50)$, $t_4 = 4$, $y_4 = -1$.\n\nYou must use a Support Vector Machine (SVM) with a kernel function that increases the influence of more recent observations. Let the kernel be defined for any two samples $(x_i,t_i)$ and $(x_j,t_j)$ by\n$$\nK_{\\alpha,\\gamma}\\big((x_i,t_i),(x_j,t_j)\\big) \\;=\\; \\exp\\!\\big(-\\gamma \\,\\|x_i - x_j\\|_2^2\\big)\\;\\cdot\\;\\exp\\!\\big(\\alpha\\,(t_i + t_j)\\big),\n$$\nwhere $\\alpha \\ge 0$ controls the time-decay strength and $\\gamma > 0$ controls the radial basis scale.\n\nTrain a soft-margin SVM in the dual using this kernel. Let $n$ denote the number of training samples. The dual optimization problem is:\n$$\n\\max_{\\alpha_1,\\dots,\\alpha_n}\\;\\; \\sum_{i=1}^n \\alpha_i \\;-\\;\\frac{1}{2}\\sum_{i=1}^n\\sum_{j=1}^n \\alpha_i\\alpha_j\\,y_i y_j\\, K_{\\alpha,\\gamma}\\big((x_i,t_i),(x_j,t_j)\\big),\n$$\nsubject to the constraints\n$$\n\\sum_{i=1}^n y_i \\alpha_i \\;=\\; 0,\\quad 0 \\le \\alpha_i \\le C \\;\\text{ for all } i.\n$$\nAfter obtaining an optimal solution $\\{\\alpha_i^\\star\\}_{i=1}^n$, define the decision function for any input $(z,t_z)$ by\n$$\nf(z,t_z) \\;=\\; \\sum_{i=1}^n \\alpha_i^\\star y_i\\, K_{\\alpha,\\gamma}\\big((x_i,t_i),(z,t_z)\\big) \\;+\\; b,\n$$\nwith bias $b$ chosen to satisfy the Karush-Kuhn-Tucker conditions. Specifically, if there exists at least one index $i$ with $0 < \\alpha_i^\\star < C$, then enforce $y_i\\,f(x_i,t_i)=1$ and take $b$ to be the average of $y_i - \\sum_{j=1}^n \\alpha_j^\\star y_j K_{\\alpha,\\gamma}((x_j,t_j),(x_i,t_i))$ over all such $i$. If there is no such index, choose $b$ in the interval of values consistent with the complementary slackness inequalities,\n$$\n\\begin{aligned}\n&\\text{for } \\alpha_i^\\star = 0:\\;\\; y_i\\,f(x_i,t_i) \\ge 1,\\\\\n&\\text{for } \\alpha_i^\\star = C:\\;\\; y_i\\,f(x_i,t_i) \\le 1,\n\\end{aligned}\n$$\nand to make the output unique, select $b$ as the midpoint of the tightest feasible interval implied by these inequalities.\n\nClassify the following three test inputs, each evaluated at timestamp $t_z = 5$:\n- $z_1 = (0.95, 0.70)$,\n- $z_2 = (-0.70, -0.40)$,\n- $z_3 = (0.10, 0.05)$.\nUse the sign of $f(z,t_z)$ to predict the label in $\\{-1,+1\\}$, with the convention that nonnegative values map to $+1$.\n\nYour program must solve the SVM dual exactly as posed for each parameter configuration below and output the predicted labels for the three test inputs in the stated order for each configuration. The test suite of parameter configurations is:\n- Case $1$: $(\\alpha,\\gamma,C) = (0.0, 1.0, 10.0)$.\n- Case $2$: $(\\alpha,\\gamma,C) = (0.5, 1.0, 10.0)$.\n- Case $3$: $(\\alpha,\\gamma,C) = (1.0, 0.5, 10.0)$.\n- Case $4$: $(\\alpha,\\gamma,C) = (0.0, 5.0, 1.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list of three integers corresponding to the predicted labels for $(z_1,5)$, $(z_2,5)$, and $(z_3,5)$, in that order, for each case in the given order. For example, the output format must be\n$$\n\\big[\\,[\\ell_{1,1},\\ell_{1,2},\\ell_{1,3}],\\;[\\ell_{2,1},\\ell_{2,2},\\ell_{2,3}],\\;[\\ell_{3,1},\\ell_{3,2},\\ell_{3,3}],\\;[\\ell_{4,1},\\ell_{4,2},\\ell_{4,3}]\\,\\big],\n$$\nwhere each $\\ell_{k,j} \\in \\{-1,+1\\}$ is an integer. No other text should be printed.", "solution": "The problem is deemed valid. It presents a standard soft-margin Support Vector Machine (SVM) classification task, albeit with a custom kernel function. The problem is scientifically grounded in established machine learning theory, well-posed as a convex optimization problem, stated objectively, and provides all necessary information for a unique solution.\n\nThe solution process involves several distinct steps for each given parameter configuration $(\\alpha, \\gamma, C)$.\n\nFirst, we formalize the SVM dual problem as a standard Quadratic Program (QP) suitable for numerical solvers. The objective is to find the Lagrange multipliers $\\boldsymbol{\\alpha} = [\\alpha_1, \\dots, \\alpha_n]^T$ that maximize the dual objective function. This is equivalent to minimizing the following quadratic form:\n$$\n\\mathcal{L}(\\boldsymbol{\\alpha}) = \\frac{1}{2} \\boldsymbol{\\alpha}^T \\mathbf{H} \\boldsymbol{\\alpha} - \\mathbf{1}^T \\boldsymbol{\\alpha}\n$$\nsubject to the constraints:\n$$\n\\mathbf{y}^T \\boldsymbol{\\alpha} = 0 \\quad \\text{and} \\quad \\mathbf{0} \\le \\boldsymbol{\\alpha} \\le C \\cdot \\mathbf{1}\n$$\nHere, $n=4$ is the number of training samples, $\\mathbf{y} = [-1, 1, 1, -1]^T$ is the vector of labels, $\\mathbf{1}$ is a vector of ones, and $C$ is the regularization parameter. The matrix $\\mathbf{H}$ is an $n \\times n$ matrix with elements $H_{ij} = y_i y_j K_{ij}$, where $K_{ij}$ is the value of the kernel function for the $i$-th and $j$-th training samples.\n\nThe kernel function is given by:\n$$\nK_{\\alpha,\\gamma}\\big((x_i,t_i),(x_j,t_j)\\big) \\;=\\; \\exp\\!\\big(-\\gamma \\,d_{ij}^2\\big)\\;\\cdot\\;\\exp\\!\\big(\\alpha\\,(t_i + t_j)\\big)\n$$\nwhere $d_{ij}^2 = \\|x_i - x_j\\|_2^2$ is the squared Euclidean distance between the feature vectors $x_i$ and $x_j$. For the given training data:\n$x_1 = (0.00, 0.00)$, $t_1 = 1$, $y_1 = -1$\n$x_2 = (1.00, 0.20)$, $t_2 = 2$, $y_2 = +1$\n$x_3 = (0.90, 1.00)$, $t_3 = 3$, $y_3 = +1$\n$x_4 = (-0.80, -0.50)$, $t_4 = 4$, $y_4 = -1$\nWe first precompute the $n \\times n$ Gram matrix, denoted as $\\mathbf{K}$, with entries $K_{ij} = K_{\\alpha,\\gamma}\\big((x_i,t_i),(x_j,t_j)\\big)$. Then, we construct the matrix $\\mathbf{H}$ using the formula $H_{ij} = y_i y_j K_{ij}$.\n\nThis constrained optimization problem is solved using a numerical QP solver. We employ the Sequential Least Squares Programming (SLSQP) algorithm from the `scipy.optimize.minimize` library function. This function takes the objective $\\mathcal{L}(\\boldsymbol{\\alpha})$, an initial guess (e.g., $\\boldsymbol{\\alpha}_0 = \\mathbf{0}$), the bounds $0 \\le \\alpha_i \\le C$ for each $i$, and the linear equality constraint $\\sum_i y_i \\alpha_i = 0$. The solver returns the optimal vector $\\boldsymbol{\\alpha}^\\star = [\\alpha_1^\\star, \\dots, \\alpha_n^\\star]^T$. Due to numerical precision, values of $\\alpha_i^\\star$ very close to $0$ or $C$ are clamped to these exact values.\n\nAfter obtaining $\\boldsymbol{\\alpha}^\\star$, we compute the bias term $b$. The method for this depends on the resulting $\\alpha_i^\\star$ values, based on the Karush-Kuhn-Tucker (KKT) conditions.\nLet $S$ be the set of indices for support vectors on the margin, where $0 < \\alpha_i^\\star < C$.\nIf $S$ is non-empty, the bias $b$ is computed to ensure that for any $i \\in S$, the decision function yields $y_i f(x_i, t_i) = 1$. This leads to the expression:\n$$\nb_i = y_i - \\sum_{j=1}^n \\alpha_j^\\star y_j K_{ij}\n$$\nFor robustness, we average these values over all $i \\in S$: $b = \\frac{1}{|S|} \\sum_{i \\in S} b_i$.\n\nIf $S$ is empty, all $\\alpha_i^\\star$ are at the boundaries ($0$ or $C$). In this case, $b$ is not uniquely determined by a single equation but must lie in an interval defined by the KKT complementary slackness conditions:\n- For $\\alpha_i^\\star = 0$: $y_i \\big(\\sum_{j=1}^n \\alpha_j^\\star y_j K_{ij} + b\\big) \\ge 1$.\n- For $\\alpha_i^\\star = C$: $y_i \\big(\\sum_{j=1}^n \\alpha_j^\\star y_j K_{ij} + b\\big) \\le 1$.\nThese inequalities define a feasible interval for $b$. Let $b_{lower}$ be the maximum of the lower bounds and $b_{upper}$ be the minimum of the upper bounds derived from these conditions. The problem requires selecting $b$ as the midpoint of this tightest feasible interval: $b = (b_{lower} + b_{upper}) / 2$.\n\nFinally, with $\\boldsymbol{\\alpha}^\\star$ and $b$ determined, we classify the three new test inputs $z_1, z_2, z_3$ at timestamp $t_z = 5$. For each test point $(z, t_z)$, the decision function is evaluated:\n$$\nf(z,t_z) \\;=\\; \\sum_{i=1}^n \\alpha_i^\\star y_i\\, K_{\\alpha,\\gamma}\\big((x_i,t_i),(z,t_z)\\big) \\;+\\; b\n$$\nThe predicted label $\\ell \\in \\{-1, +1\\}$ is given by the sign of $f(z,t_z)$, with the convention that non-negative values map to $+1$:\n$$\n\\ell = \\begin{cases} +1 & \\text{if } f(z,t_z) \\ge 0 \\\\ -1 & \\text{if } f(z,t_z) < 0 \\end{cases}\n$$\nThis entire process is executed for each of the four specified parameter configurations, and the resulting predictions are aggregated into the required output format.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, Bounds\n\ndef solve():\n    # Define the training data from the problem statement.\n    X_train = np.array([\n        [0.00, 0.00],\n        [1.00, 0.20],\n        [0.90, 1.00],\n        [-0.80, -0.50]\n    ])\n    T_train = np.array([1, 2, 3, 4])\n    Y_train = np.array([-1, 1, 1, -1])\n    n_samples = len(X_train)\n\n    # Define the test inputs.\n    X_test = np.array([\n        [0.95, 0.70],\n        [-0.70, -0.40],\n        [0.10, 0.05]\n    ])\n    T_test = 5\n\n    # Define the parameter configurations from the problem statement.\n    test_cases = [\n        (0.0, 1.0, 10.0),\n        (0.5, 1.0, 10.0),\n        (1.0, 0.5, 10.0),\n        (0.0, 5.0, 1.0),\n    ]\n\n    all_results = []\n    # Numerical tolerance for floating point comparisons\n    tol = 1e-9\n\n    for case in test_cases:\n        alpha_param, gamma, C = case\n        \n        # 1. Construct the Kernel Matrix K.\n        # Efficiently compute squared Euclidean distances between all pairs of training points.\n        sq_dists = np.sum(X_train**2, axis=1, keepdims=True) + np.sum(X_train**2, axis=1) - 2 * np.dot(X_train, X_train.T)\n        rbf_kernel = np.exp(-gamma * sq_dists)\n        time_component = np.exp(alpha_param * (T_train.reshape(-1, 1) + T_train))\n        K = rbf_kernel * time_component\n\n        # 2. Construct the matrix H for the QP problem.\n        H = np.outer(Y_train, Y_train) * K\n        \n        # 3. Define the QP objective function and constraints.\n        def objective_func(alphas):\n            return 0.5 * alphas.T @ H @ alphas - np.sum(alphas)\n        \n        constraints = ({'type': 'eq', 'fun': lambda alphas: np.dot(Y_train, alphas)})\n        bounds = Bounds([0] * n_samples, [C] * n_samples)\n        \n        # 4. Solve the QP problem for the optimal alphas.\n        result = minimize(objective_func, np.zeros(n_samples), method='SLSQP', bounds=bounds, constraints=constraints)\n        alpha_star = result.x\n        \n        # Clamp near-zero and near-C values for stable bias calculation.\n        alpha_star[alpha_star < tol] = 0\n        alpha_star[alpha_star > C - tol] = C\n        \n        # 5. Calculate the bias term b.\n        # Find support vectors on the margin (0 < alpha_i < C).\n        sv_margin_indices = np.where((alpha_star > tol) & (alpha_star < C - tol))[0]\n\n        if len(sv_margin_indices) > 0:\n            # Case 1: bias calculation from margin support vectors.\n            b_values = [Y_train[i] - np.sum(alpha_star * Y_train * K[:, i]) for i in sv_margin_indices]\n            b = np.mean(b_values)\n        else:\n            # Case 2: bias calculation from KKT conditions on non-margin SVs.\n            b_lowers, b_uppers = [], []\n            f_preds_no_b = K.T @ (alpha_star * Y_train)\n\n            for i in range(n_samples):\n                if not ((alpha_star[i] > tol) and (alpha_star[i] < C - tol)):\n                    if np.isclose(alpha_star[i], 0): # alpha_i = 0 implies y_i(f_i+b) >= 1\n                        if Y_train[i] == 1: b_lowers.append(1 - f_preds_no_b[i])\n                        else: b_uppers.append(-1 - f_preds_no_b[i])\n                    elif np.isclose(alpha_star[i], C): # alpha_i = C implies y_i(f_i+b) <= 1\n                        if Y_train[i] == 1: b_uppers.append(1 - f_preds_no_b[i])\n                        else: b_lowers.append(-1 - f_preds_no_b[i])\n            \n            max_lower = max(b_lowers) if b_lowers else -np.inf\n            min_upper = min(b_uppers) if b_uppers else np.inf\n            b = (max_lower + min_upper) / 2.0\n\n        # 6. Classify test inputs using the calculated model.\n        case_predictions = []\n        for z in X_test:\n            # Calculate kernel values between training points and the test point.\n            sq_dists_test = np.sum(X_train**2, axis=1) + np.sum(z**2) - 2 * np.dot(X_train, z)\n            rbf_kernel_test = np.exp(-gamma * sq_dists_test)\n            time_component_test = np.exp(alpha_param * (T_train + T_test))\n            K_test = rbf_kernel_test * time_component_test\n            \n            # Evaluate the decision function.\n            f_z = np.sum(alpha_star * Y_train * K_test) + b\n            \n            # Predict the label.\n            prediction = 1 if f_z >= 0 else -1\n            case_predictions.append(prediction)\n        \n        all_results.append(case_predictions)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"}, {"introduction": "Financial markets are inherently dynamic, and a model that works today may fail tomorrow. This advanced practice addresses the critical issue of model stability in a non-stationary world by simulating a changing market environment. You will perform a rolling-window analysis to investigate whether the set of \"important\" stocks, identified as the support vectors of your SVM, remains consistent over time, and quantify this stability using the Jaccard index [@problem_id:2435480].", "id": "2435480", "problem": "You are given a cross-sectional stock classification task motivated by a rolling-window study in computational economics and finance. The aim is to formalize and quantify whether the set of \"most important\" stocks, defined as the support vectors in a soft-margin Support Vector Machine (SVM), changes over time when the predictive task is re-estimated on rolling windows.\n\nStart from the following fundamental base:\n- The soft-margin Support Vector Machine (SVM) solves the convex optimization problem\n  $$\n  \\min_{\\mathbf{w}, b, \\boldsymbol{\\xi}} \\;\\; \\frac{1}{2}\\lVert \\mathbf{w} \\rVert_2^2 + C \\sum_{i=1}^{m} \\xi_i\n  \\quad \\text{subject to} \\quad\n  y_i \\big(\\mathbf{w}^\\top \\mathbf{x}_i + b\\big) \\ge 1 - \\xi_i, \\;\\; \\xi_i \\ge 0,\n  $$\n  where $C \\ge 0$ is the regularization constant, $\\mathbf{x}_i \\in \\mathbb{R}^d$ are features, $y_i \\in \\{-1, +1\\}$ are labels, and $\\xi_i$ are slack variables.\n- Its Lagrangian dual for the linear kernel can be written as the quadratic program\n  $$\n  \\min_{\\boldsymbol{\\alpha} \\in \\mathbb{R}^m} \\;\\; \\frac{1}{2} \\boldsymbol{\\alpha}^\\top \\mathbf{Q} \\boldsymbol{\\alpha} - \\mathbf{1}^\\top \\boldsymbol{\\alpha}\n  \\quad \\text{subject to} \\quad\n  \\mathbf{y}^\\top \\boldsymbol{\\alpha} = 0, \\;\\; 0 \\le \\alpha_i \\le C,\n  $$\n  where $\\mathbf{Q}$ is the matrix with entries $Q_{ij} = y_i y_j \\mathbf{x}_i^\\top \\mathbf{x}_j$, $\\mathbf{1}$ is the vector of ones, and $\\mathbf{y} = (y_1,\\dots,y_m)^\\top$.\n- By the Karush–Kuhn–Tucker (KKT) conditions, data points with dual variables $\\alpha_i &gt; 0$ are support vectors. Those with $0 &lt; \\alpha_i &lt; C$ lie on the margin; those with $\\alpha_i = C$ are margin-violating or misclassified points. The primal solution satisfies $\\mathbf{w} = \\sum_{i=1}^m \\alpha_i y_i \\mathbf{x}_i$.\n\nDataset construction and rolling windows:\n- There are $N = 8$ stocks indexed by $i \\in \\{0,1,\\dots,7\\}$, each with a fixed two-dimensional feature vector $\\mathbf{x}_i \\in \\mathbb{R}^2$ representing simplified cross-sectional characteristics (for example, momentum and size), given by\n  $$\n  \\mathbf{x}_0 = (0.9, 0.2), \\;\\;\n  \\mathbf{x}_1 = (0.7, 0.4), \\;\\;\n  \\mathbf{x}_2 = (0.5, 0.1), \\;\\;\n  \\mathbf{x}_3 = (0.3, 0.3),\n  $$\n  $$\n  \\mathbf{x}_4 = (-0.2, -0.8), \\;\\;\n  \\mathbf{x}_5 = (-0.4, -0.5), \\;\\;\n  \\mathbf{x}_6 = (-0.6, -0.2), \\;\\;\n  \\mathbf{x}_7 = (-0.8, -0.4).\n  $$\n- There are $T = 6$ time points indexed by $t \\in \\{0,1,2,3,4,5\\}$. At each time $t$, a true but unknown linear scoring rule varies smoothly:\n  $$\n  \\mathbf{w}_t = (\\cos\\theta_t, \\sin\\theta_t), \\quad \\text{with} \\quad \\theta_t \\in \\{0^\\circ, 22.5^\\circ, 45^\\circ, 67.5^\\circ, 90^\\circ, 112.5^\\circ\\}.\n  $$\n  The intercept is $b_t = 0$. Labels are generated deterministically by $y_{i,t} = \\mathrm{sign}(\\mathbf{w}_t^\\top \\mathbf{x}_i)$, so that $y_{i,t} \\in \\{-1, +1\\}$ for all $i,t$.\n- For a rolling window of width $W$, the training sample in window $k$ (starting at time $t = k$) aggregates all pairs $(\\mathbf{x}_i, y_{i,t})$ for $i \\in \\{0,\\dots,7\\}$ and $t \\in \\{k, k+1, \\dots, k+W-1\\}$, producing $m = N \\cdot W$ samples. Let $\\mathcal{S}_k$ denote the set of stock indices that appear as support vectors in window $k$, i.e., $\\mathcal{S}_k = \\{i \\in \\{0,\\dots,7\\} \\mid \\exists$ sample of stock $i$ in window $k$ with $\\alpha &gt; 0\\}$.\n\nStability measure:\n- For consecutive windows $k$ and $k+1$, define the set-similarity stability as the Jaccard index\n  $$\n  J(\\mathcal{S}_k, \\mathcal{S}_{k+1}) = \\frac{|\\mathcal{S}_k \\cap \\mathcal{S}_{k+1}|}{|\\mathcal{S}_k \\cup \\mathcal{S}_{k+1}|}.\n  $$\n- For a given regularization constant $C$ and window width $W$, with $K = T - W + 1$ windows, compute the average consecutive-window stability\n  $$\n  \\bar{J} = \\frac{1}{K-1}\\sum_{k=0}^{K-2} J(\\mathcal{S}_k, \\mathcal{S}_{k+1}).\n  $$\n\nTask:\n- Implement the SVM dual optimization using the above quadratic program with a linear kernel to obtain the dual variables $\\boldsymbol{\\alpha}$, identify support vectors per window, and compute the stability measure $\\bar{J}$.\n- Your implementation must be a complete, runnable program that performs the full pipeline without any user input.\n\nTest suite and required outputs:\n- Use the following test suite of $(C, W)$ parameter pairs:\n  1. $(C, W) = (1.0, 3)$\n  2. $(C, W) = (10.0, 3)$\n  3. $(C, W) = (0.3, 2)$\n- For each parameter pair, compute the average consecutive-window stability $\\bar{J}$ as a float rounded to four decimal places.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[a,b,c]$, where $a$, $b$, and $c$ are the values of $\\bar{J}$ for the three test cases in the order given.\n- Angles are given in degrees; there are no physical units to report; all outputs are unitless floats. The final printed values must be rounded to four decimal places.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the theory of support vector machines and convex optimization, and its application to computational finance is a legitimate area of study. The problem is well-posed, providing all necessary data, definitions, and a clear, objective computational goal. It contains no logical contradictions, ambiguities, or factually incorrect premises. We will therefore proceed with a complete solution.\n\nThe core of the problem is to quantify the stability of a stock's \"importance\" over time. Importance is defined in terms of being a support vector in a soft-margin Support Vector Machine (SVM) classification task. The analysis is performed on a rolling-window basis. The solution is executed by following a sequence of steps derived from first principles.\n\nFirst, we establish the synthetic dataset. There are $N=8$ stocks, each with a fixed, two-dimensional feature vector $\\mathbf{x}_i \\in \\mathbb{R}^2$. Over $T=6$ time periods, the underlying classification rule changes smoothly. This is modeled by a rotating weight vector $\\mathbf{w}_t = (\\cos\\theta_t, \\sin\\theta_t)^\\top$ for a sequence of angles $\\theta_t$. The class label $y_{i,t} \\in \\{-1, +1\\}$ for stock $i$ at time $t$ is determined deterministically as $y_{i,t} = \\mathrm{sign}(\\mathbf{w}_t^\\top \\mathbf{x}_i)$.\n\nSecond, we implement the rolling-window analysis. For a given window width $W$ and regularization parameter $C$, we construct a series of training datasets. The $k$-th window, for $k \\in \\{0, 1, \\dots, T-W\\}$, consists of all data points $(\\mathbf{x}_i, y_{i,t})$ where $i \\in \\{0, \\dots, N-1\\}$ and $t \\in \\{k, \\dots, k+W-1\\}$. This results in a training set of size $m = N \\cdot W$ for each window.\n\nThird, for each window's training data, we solve the dual problem of the soft-margin SVM. The problem is a Quadratic Program (QP) defined as:\n$$\n\\min_{\\boldsymbol{\\alpha} \\in \\mathbb{R}^m} \\;\\; \\frac{1}{2} \\boldsymbol{\\alpha}^\\top \\mathbf{Q} \\boldsymbol{\\alpha} - \\mathbf{1}^\\top \\boldsymbol{\\alpha}\n$$\nsubject to the constraints:\n$$\n\\mathbf{y}^\\top \\boldsymbol{\\alpha} = 0\n$$\n$$\n0 \\le \\alpha_j \\le C \\quad \\text{for } j=1, \\dots, m\n$$\nHere, $\\boldsymbol{\\alpha}$ is the vector of Lagrange multipliers, $\\mathbf{y}$ is the vector of labels in the window's training set, and $\\mathbf{Q}$ is an $m \\times m$ matrix with entries $Q_{jl} = y_j y_l (\\mathbf{x}_j^\\top \\mathbf{x}_l)$. This constrained optimization problem is convex and can be solved reliably using numerical methods. We employ the Sequential Least Squares Programming (SLSQP) algorithm, as implemented in the `scipy.optimize.minimize` function. We supply the objective function, its gradient (Jacobian) $\\nabla_{\\boldsymbol{\\alpha}}f(\\boldsymbol{\\alpha}) = \\mathbf{Q}\\boldsymbol{\\alpha} - \\mathbf{1}$, the linear equality constraint, and the box constraints on $\\boldsymbol{\\alpha}$.\n\nFourth, after solving for the optimal dual variables $\\boldsymbol{\\alpha}^{(k)}$ for window $k$, we identify the set of important stocks. According to the Karush–Kuhn–Tucker (KKT) conditions of the SVM, a data point $j$ is a support vector if its corresponding Lagrange multiplier $\\alpha_j$ is strictly positive. Due to floating-point arithmetic, we use a small tolerance, identifying support vectors as those with $\\alpha_j > \\epsilon$ for some small $\\epsilon > 0$. The set of important stocks for window $k$, denoted $\\mathcal{S}_k$, is the set of all unique stock indices $i$ for which at least one corresponding data point in window $k$ is a support vector.\n\nFifth, we quantify the stability of these sets over time. The similarity between the support vector sets of two consecutive windows, $\\mathcal{S}_k$ and $\\mathcal{S}_{k+1}$, is measured by the Jaccard index:\n$$\nJ(\\mathcal{S}_k, \\mathcal{S}_{k+1}) = \\frac{|\\mathcal{S}_k \\cap \\mathcal{S}_{k+1}|}{|\\mathcal{S}_k \\cup \\mathcal{S}_{k+1}|}\n$$\nThe overall stability for a given $(C, W)$ pair, $\\bar{J}$, is the arithmetic mean of the Jaccard indices across all consecutive window pairs from $k=0$ to $k=K-2$, where $K = T - W + 1$ is the total number of windows.\n\nFinally, this entire pipeline is executed for each $(C, W)$ pair specified in the test suite. The computed average stability $\\bar{J}$ for each case is rounded to four decimal places and reported as the final result. The implementation is self-contained in a single Python script, utilizing `numpy` for efficient numerical computation and `scipy` for the core optimization task, adhering strictly to the problem's requirements.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the SVM stability analysis problem for the given test cases.\n    \"\"\"\n    \n    # Define fixed problem parameters and data\n    N = 8\n    T = 6\n    x_stocks = np.array([\n        [0.9, 0.2], [0.7, 0.4], [0.5, 0.1], [0.3, 0.3],\n        [-0.2, -0.8], [-0.4, -0.5], [-0.6, -0.2], [-0.8, -0.4]\n    ])\n    thetas_deg = np.array([0.0, 22.5, 45.0, 67.5, 90.0, 112.5])\n    \n    # Pre-calculate true weights and labels for all time points\n    thetas_rad = np.deg2rad(thetas_deg)\n    w_t_vectors = np.array([np.cos(thetas_rad), np.sin(thetas_rad)]).T\n    # y_labels[i, t] is the label for stock i at time t. Shape (8, 6)\n    y_labels = np.sign(x_stocks @ w_t_vectors.T)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 3),    # (C, W) pair 1\n        (10.0, 3),   # (C, W) pair 2\n        (0.3, 2),    # (C, W) pair 3\n    ]\n\n    results = []\n    \n    for C, W in test_cases:\n        K = T - W + 1  # Total number of rolling windows\n        all_S_sets = []\n\n        # Iterate over each rolling window\n        for k in range(K):\n            # 1. Construct the training dataset for the current window k\n            m = N * W\n            train_X = np.zeros((m, 2))\n            train_y = np.zeros(m)\n            train_stock_indices = np.zeros(m, dtype=int)\n            \n            idx = 0\n            for i in range(N):\n                for t_offset in range(W):\n                    t = k + t_offset\n                    train_X[idx] = x_stocks[i]\n                    train_y[idx] = y_labels[i, t]\n                    train_stock_indices[idx] = i\n                    idx += 1\n\n            # 2. Set up the dual SVM Quadratic Program\n            gram_matrix = train_X @ train_X.T\n            y_outer = np.outer(train_y, train_y)\n            Q = gram_matrix * y_outer\n\n            def objective_func(alpha):\n                return 0.5 * (alpha.T @ Q @ alpha) - np.sum(alpha)\n\n            def objective_jac(alpha):\n                return (alpha.T @ Q) - 1.0\n\n            # Equality constraint: y^T * alpha = 0\n            eq_cons = {\n                'type': 'eq',\n                'fun': lambda alpha: alpha @ train_y,\n                'jac': lambda alpha: train_y\n            }\n            \n            # Box constraints: 0 <= alpha_i <= C\n            bounds = [(0, C) for _ in range(m)]\n\n            # Initial guess for alpha\n            alpha_0 = np.zeros(m)\n            \n            # 3. Solve the QP using SLSQP\n            res = minimize(\n                fun=objective_func,\n                x0=alpha_0,\n                jac=objective_jac,\n                bounds=bounds,\n                constraints=[eq_cons],\n                method='SLSQP',\n                tol=1e-9\n            )\n            \n            alphas = res.x\n            \n            # 4. Identify support vector stock indices\n            # A stock is a support vector if any of its observations have alpha > 0\n            sv_mask = alphas > 1e-7  # Tolerance for floating point precision\n            sv_stock_indices = train_stock_indices[sv_mask]\n            S_k = set(sv_stock_indices)\n            all_S_sets.append(S_k)\n            \n        # 5. Compute the average consecutive-window stability (Jaccard index)\n        jaccard_scores = []\n        if K > 1:\n            for k_pair in range(K - 1):\n                S_k = all_S_sets[k_pair]\n                S_k_plus_1 = all_S_sets[k_pair + 1]\n                \n                intersection_len = len(S_k.intersection(S_k_plus_1))\n                union_len = len(S_k.union(S_k_plus_1))\n                \n                # J(A,B) = 1 if A and B are empty. Otherwise, |A intersect B| / |A union B|\n                if union_len == 0:\n                    jaccard_index = 1.0\n                else:\n                    jaccard_index = intersection_len / union_len\n                \n                jaccard_scores.append(jaccard_index)\n            \n            avg_jaccard = np.mean(jaccard_scores)\n        else: # Case with only one window, stability is not defined.\n            avg_jaccard = 0.0\n\n        results.append(round(avg_jaccard, 4))\n\n    # Print the final results in the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}