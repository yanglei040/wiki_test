{"hands_on_practices": [{"introduction": "The heart of any limit order book is its matching engine, which processes orders according to strict price-time priority rules. This first exercise takes you through the fundamental task of building a simulator for a continuous-price LOB, where prices are not confined to a discrete grid. Successfully completing this practice [@problem_id:2406545] will require a thoughtful combination of data structures to efficiently manage the book and execute trades, forming the bedrock of more complex market simulations.", "id": "2406545", "problem": "You are asked to design and implement a continuous-price limit order book (LOB) simulator. Unlike the common discrete tick setting, prices here are real-valued and not snapped to a grid. The simulator must implement price–time priority, allow cancellations, and process market and limit orders with partial fills, all under a small numerical tolerance to handle floating-point comparisons.\n\nThe core of the problem is to translate the microstructure logic of a double auction with continuous prices into efficient data structures and an algorithmic matching engine, then to compute specified aggregate metrics. The following are the foundational definitions and rules you must adhere to.\n\nDefinitions and rules:\n- A limit order is a tuple $(\\text{side}, \\text{quantity}, \\text{price}, \\text{id})$ with $\\text{side} \\in \\{\\text{buy}, \\text{sell}\\}$, $\\text{quantity} \\in \\mathbb{R}_{>0}$, $\\text{price} \\in \\mathbb{R}_{>0}$, and a unique integer identifier $\\text{id} \\in \\mathbb{Z}_{>0}$. A market order is a tuple $(\\text{side}, \\text{quantity}, \\text{id})$ with no price. A cancellation targets an existing identifier and is $(\\text{id})$.\n- Price–time priority: Among resting orders on the same side with the same price, execution priority is by arrival time (first-in-first-out). Across prices, the best price executes first: the highest price for buys and the lowest price for sells.\n- Matching condition with tolerance: Let $\\varepsilon \\ge 0$ be a numerical tolerance. A new buy limit order with price $p_b$ is marketable if the current best ask price $a^\\star$ satisfies $a^\\star \\le p_b + \\varepsilon$. A new sell limit order with price $p_s$ is marketable if the current best bid price $b^\\star$ satisfies $b^\\star + \\varepsilon \\ge p_s$. Market orders are always marketable.\n- Execution price: A trade occurs at the price of the resting order.\n- Partial fills: If the incoming order’s remaining quantity is $q_\\text{in} > 0$ and the best opposing resting order at price $p^\\star$ has remaining quantity $q^\\star > 0$, then the executed quantity is $\\min(q_\\text{in}, q^\\star)$. Quantities are reduced accordingly; any residual on the incoming order continues matching; any residual on a non-marketable incoming limit order becomes a new resting order.\n- Cancellations: A cancellation by identifier removes any remaining quantity of that resting order from the book (if it exists and has not already been fully executed or cancelled).\n- Empty side best price: If the buy or sell book is empty at the end, define the best price for that side to be $0$.\n\nRequired output metrics per test case:\n- The best bid price $b^\\star_\\text{final}$ and the best ask price $a^\\star_\\text{final}$ after all events in the test case are processed (use $0$ if a side is empty).\n- The total number of trades $N_T$, where each match against a resting order counts as one trade, even if triggered by a single incoming order.\n- The total executed quantity $Q_T = \\sum_i q_i$, where $q_i$ is the quantity of trade $i$.\n- The volume-weighted average price (VWAP) over all trades:\n$$\n\\text{VWAP} = \n\\begin{cases}\n\\frac{\\sum_i q_i p_i}{\\sum_i q_i}, & \\text{if } \\sum_i q_i > 0,\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nwhere $p_i$ is the execution price of trade $i$.\nAll floating-point outputs must be rounded to exactly $6$ decimal places; integers must be printed without decimal places.\n\nAlgorithmic requirements:\n- Because prices are continuous, you must not discretize or bucket prices. Use an order-statistics-friendly structure such as a heap for best-price extraction and, for each distinct price, a queue to maintain time priority. You must handle lazy deletion of empty price levels. Floating-point comparisons must use the given $\\varepsilon$ tolerance.\n- Trade execution uses the price–time priority and the execution price is always the resting order’s price.\n\nTest suite:\nFor each test case $k \\in \\{1,2,3,4\\}$, you are given a tolerance $\\varepsilon_k$ and a sequence of events $\\{E_{k,j}\\}_{j=1}^{m_k}$.\n\nEvent encoding:\n- Limit order: $E=(\\text{\"limit\"}, \\text{side}, q, p, \\text{id})$ with $\\text{side} \\in \\{\\text{\"buy\"}, \\text{\"sell\"}\\}$, $q \\in \\mathbb{R}_{>0}$, $p \\in \\mathbb{R}_{>0}$, $\\text{id} \\in \\mathbb{Z}_{>0}$.\n- Market order: $E=(\\text{\"market\"}, \\text{side}, q, \\text{id})$ with $\\text{side} \\in \\{\\text{\"buy\"}, \\text{\"sell\"}\\}$, $q \\in \\mathbb{R}_{>0}$, $\\text{id} \\in \\mathbb{Z}_{>0}$.\n- Cancellation: $E=(\\text{\"cancel\"}, \\text{id})$.\n\nTest case $1$:\n- $\\varepsilon_1 = 10^{-9}$.\n- Events:\n  - $E_{1,1}=(\\text{\"limit\"}, \\text{\"sell\"}, 5, 101.0, 1)$.\n  - $E_{1,2}=(\\text{\"limit\"}, \\text{\"sell\"}, 3, 100.5, 2)$.\n  - $E_{1,3}=(\\text{\"limit\"}, \\text{\"buy\"}, 4, 100.0, 3)$.\n  - $E_{1,4}=(\\text{\"limit\"}, \\text{\"buy\"}, 6, 101.0, 4)$.\n\nTest case $2$ (boundary: equal prices and strict FIFO at a single price level):\n- $\\varepsilon_2 = 0$.\n- Events:\n  - $E_{2,1}=(\\text{\"limit\"}, \\text{\"sell\"}, 2, 100.0, 10)$.\n  - $E_{2,2}=(\\text{\"limit\"}, \\text{\"sell\"}, 1, 100.0, 11)$.\n  - $E_{2,3}=(\\text{\"limit\"}, \\text{\"buy\"}, 3, 100.0, 12)$.\n\nTest case $3$ (market order sweeping multiple price levels):\n- $\\varepsilon_3 = 10^{-9}$.\n- Events:\n  - $E_{3,1}=(\\text{\"limit\"}, \\text{\"sell\"}, 1, 100.0, 20)$.\n  - $E_{3,2}=(\\text{\"limit\"}, \\text{\"sell\"}, 2, 100.2, 21)$.\n  - $E_{3,3}=(\\text{\"limit\"}, \\text{\"sell\"}, 4, 101.0, 22)$.\n  - $E_{3,4}=(\\text{\"market\"}, \\text{\"buy\"}, 5, 23)$.\n\nTest case $4$ (tolerance-enabled crossing and cancellation):\n- $\\varepsilon_4 = 10^{-3}$.\n- Events:\n  - $E_{4,1}=(\\text{\"limit\"}, \\text{\"sell\"}, 5, 100.0001, 30)$.\n  - $E_{4,2}=(\\text{\"limit\"}, \\text{\"buy\"}, 2, 100.0, 31)$.\n  - $E_{4,3}=(\\text{\"cancel\"}, 30)$.\n  - $E_{4,4}=(\\text{\"market\"}, \\text{\"sell\"}, 1, 32)$.\n\nProgram input and output:\n- There is no external input. Hard-code the above test suite in your program.\n- For each test case, process all events in order and compute $[b^\\star_\\text{final}, a^\\star_\\text{final}, N_T, Q_T, \\text{VWAP}]$.\n- Your program should produce a single line of output containing a top-level list of the test-case results, each being a list as specified, with floats rounded to exactly $6$ decimal places and no spaces anywhere. For example: $[[\\dots],[\\dots],[\\dots],[\\dots]]$.\n\nConstraints and guarantees:\n- All quantities and prices are strictly positive real numbers within a reasonable financial range.\n- Identifiers are unique across the entire test suite, and cancellations refer only to previously submitted identifiers.\n- The matching engine must not discretize prices; it must respect the continuous-price comparisons with $\\varepsilon$ as defined.", "solution": "The problem requires the design and implementation of a continuous-price limit order book (LOB) simulator. The solution must adhere to price-time priority, handle various order types, and compute specific financial metrics. The core of the solution is an event-driven simulation built upon carefully chosen data structures that efficiently manage the state of the order book.\n\n**1. Foundational Design: Event-Driven Simulation**\n\nThe simulation proceeds by processing a chronological sequence of events. The state of the LOB—comprising all resting buy (bid) and sell (ask) orders—is updated in response to each event. The design is encapsulated within a `LimitOrderBook` class, which maintains the book's state and contains the logic for processing events and matching orders.\n\n**2. Core Data Structures**\n\nTo satisfy the price-time priority rule in a continuous price setting, a combination of heaps and queues is employed. This hybrid structure is optimal for the required operations: fast retrieval of the best-priced order and strict enforcement of arrival time for orders at the same price.\n\n- **Price Priority (Heaps)**: A trade must occur at the best available price. For buy orders (bids), the best price is the highest price. For sell orders (asks), it is the lowest.\n    - The **ask book** is managed by a min-heap, which provides $O(1)$ access to the minimum price (best ask). Python's `heapq` library is used for this purpose.\n    - The **bid book** is managed by a max-heap. Since `heapq` only provides a min-heap, this is implemented by storing the negation of bid prices (e.g., $-p$ for a price $p$), which effectively reverses the sort order and allows the min-heap to retrieve the maximum price in $O(1)$ time.\n\n- **Time Priority (Queues)**: For orders at the same price, execution follows a first-in-first-out (FIFO) principle.\n    - A dictionary, `price_levels`, maps each distinct price $p$ to a queue (specifically, a `collections.deque`) of orders at that price. A `deque` is chosen for its efficient $O(1)$ append and pop operations from both ends, which is ideal for managing the arrival and execution of orders.\n\n- **Order Tracking (Dictionary)**: Cancellations require fast lookup of an order by its unique identifier, `id`.\n    - A dictionary, `orders_map`, maps each `id` to its corresponding `Order` object. This allows for $O(1)$ access to any active order for modification (e.g., quantity reduction) or cancellation. An `Order` class is defined to store its `id`, `side`, `price`, and remaining `quantity`.\n\n**3. Algorithmic Logic and Execution Flow**\n\nThe simulator's logic is organized around a main event processing loop.\n\n- **Event Dispatching**: A central method, `process_event`, identifies the type of event—limit order, market order, or cancellation—and dispatches it to the corresponding handler function.\n\n- **Order Matching Engine**: This is the heart of the LOB. When a marketable order arrives (a market order, or a limit order that crosses the spread), the `_match_order` method is invoked.\n    - An incoming buy order with price $p_b$ is marketable if the best ask price $a^\\star$ satisfies $a^\\star \\le p_b + \\varepsilon$. An incoming sell order with price $p_s$ is marketable if the best bid price $b^\\star$ satisfies $b^\\star + \\varepsilon \\ge p_s$. A market order is always marketable.\n    - The matching loop continues as long as the incoming order has quantity $q_\\text{in} > 0$ and there are crossing orders in the opposing book.\n    - In each step, it matches against the best-priced resting order. A trade occurs at the price of the resting order. The executed quantity is $\\min(q_\\text{in}, q^\\star)$, where $q^\\star$ is the quantity of the resting order.\n    - Quantities of both orders are reduced. If the resting order is fully filled, it is removed from its price-level queue and the `orders_map`. If the incoming order is filled, the matching process stops. Any residual of a non-marketable incoming limit order is then placed on the book.\n\n- **Order Placement**: If a limit order is not marketable, or if a residual quantity remains after matching, it is added to the book using an `_add_order_to_book` method. This involves adding the `Order` object to the appropriate price-level queue and `orders_map`. If the price level is new, the price is also pushed onto the corresponding bid or ask heap.\n\n- **Cancellations and Lazy Deletion**: A cancellation event for a given `id` is handled by looking up the order in `orders_map` and setting its `quantity` to $0$. This is a \"lazy\" cancellation. The \"zombie\" order object remains in its queue.\n    - To prevent these zero-quantity orders from affecting matching, a `_peek_best_price` helper function is implemented. Before returning the best price from a heap, this function inspects the corresponding price-level queue. It cleans up the queue by removing any zero-quantity orders from its front. If this cleanup empties the entire price level, the price is popped from the heap, and the process repeats until a valid, non-empty price level is found at the top of the heap or the heap is empty. This lazy deletion mechanism ensures high performance by avoiding costly traversals of the book to find and remove empty levels.\n\n**4. Calculation of Output Metrics**\n\nAfter processing all events in a test case, the final metrics are computed:\n- **Best Bid/Ask ($b^\\star_\\text{final}, a^\\star_\\text{final}$)**: These are retrieved using the `_peek_best_price` method for the bid and ask sides, respectively. If a side is empty, the price is defined as $0$.\n- **Total Trades ($N_T$)**: A counter is incremented each time a match occurs between an incoming order and a resting order.\n- **Total Executed Quantity ($Q_T$)**: This is the cumulative sum of quantities from all trades.\n- **Volume-Weighted Average Price (VWAP)**: This is calculated as $\\frac{\\sum_i q_i p_i}{\\sum_i q_i}$, where $q_i$ and $p_i$ are the quantity and price of each trade. A running sum of the numerator, $\\sum_i q_i p_i$, is maintained during the simulation. The final VWAP is this sum divided by the final $Q_T$. If $Q_T = 0$, VWAP is $0$.\n\nAll floating-point results are formatted and rounded to $6$ decimal places as required. The entire design ensures correctness, adherence to the specified rules, and computational efficiency suitable for a high-performance matching engine simulation.", "answer": "```python\nimport collections\nimport heapq\n\nclass Order:\n    \"\"\"Represents an order in the book.\"\"\"\n    __slots__ = ['id', 'side', 'quantity', 'price']\n    \n    def __init__(self, id, side, quantity, price=None):\n        self.id = id\n        self.side = side\n        self.quantity = float(quantity)\n        self.price = float(price) if price is not None else None\n\nclass LimitOrderBook:\n    \"\"\"A continuous-price limit order book simulator.\"\"\"\n    \n    def __init__(self, epsilon=1e-9):\n        # Bids are a max-heap (implemented with negative prices in a min-heap)\n        self.bids = []  \n        # Asks are a min-heap\n        self.asks = []  \n        # price -> deque of orders\n        self.price_levels = collections.defaultdict(collections.deque)\n        # id -> Order object\n        self.orders_map = {}\n        self.epsilon = epsilon\n        \n        # Statistics\n        self.n_trades = 0\n        self.total_quantity = 0.0\n        self.vwap_numerator = 0.0\n\n    def _peek_best_price(self, side):\n        \"\"\"Returns the best price for a side, handling lazy deletion.\"\"\"\n        heap = self.bids if side == \"buy\" else self.asks\n        \n        while heap:\n            price_in_heap = heap[0]\n            real_price = -price_in_heap if side == \"buy\" else price_in_heap\n            \n            level_queue = self.price_levels[real_price]\n            \n            # Clean up filled/cancelled orders from the front of the queue\n            while level_queue and level_queue[0].quantity <= 0:\n                dead_order = level_queue.popleft()\n                if dead_order.id in self.orders_map:\n                    del self.orders_map[dead_order.id]\n            \n            if not level_queue:\n                # Price level is now empty, remove from heap and map\n                heapq.heappop(heap)\n                del self.price_levels[real_price]\n            else:\n                # Found a valid price level\n                return real_price\n        \n        return 0.0 # Per problem spec for empty side\n\n    def _add_order_to_book(self, order):\n        \"\"\"Adds a limit order to the book.\"\"\"\n        if order.quantity <= 0: return\n\n        # If price level is new, add price to the correct heap\n        if not self.price_levels[order.price]:\n            if order.side == \"buy\":\n                heapq.heappush(self.bids, -order.price)\n            else:\n                heapq.heappush(self.asks, order.price)\n        \n        self.price_levels[order.price].append(order)\n        self.orders_map[order.id] = order\n\n    def _match_order(self, incoming_order):\n        \"\"\"Matches an incoming order against the book.\"\"\"\n        while incoming_order.quantity > 0:\n            best_opp_price = self._peek_best_price(\"sell\" if incoming_order.side == \"buy\" else \"buy\")\n            \n            if best_opp_price == 0.0:\n                break # No liquidity on the opposing side\n\n            # Check marketability for incoming limit orders\n            is_marketable = False\n            if incoming_order.price is None: # Market order\n                is_marketable = True\n            elif incoming_order.side == \"buy\": # Buy limit\n                if best_opp_price <= incoming_order.price + self.epsilon:\n                    is_marketable = True\n            else: # Sell limit\n                if best_opp_price + self.epsilon >= incoming_order.price:\n                    is_marketable = True\n\n            if not is_marketable:\n                break # Incoming limit order is no longer aggressive enough\n\n            resting_order_queue = self.price_levels[best_opp_price]\n            \n            # Match against orders at this price level\n            while resting_order_queue and incoming_order.quantity > 0:\n                resting_order = resting_order_queue[0]\n                \n                trade_qty = min(incoming_order.quantity, resting_order.quantity)\n                \n                # Update statistics\n                self.n_trades += 1\n                self.total_quantity += trade_qty\n                # Trade happens at the resting order's price\n                self.vwap_numerator += trade_qty * resting_order.price\n                \n                # Update quantities\n                incoming_order.quantity -= trade_qty\n                resting_order.quantity -= trade_qty\n                \n                if resting_order.quantity <= 0:\n                    resting_order_queue.popleft()\n                    if resting_order.id in self.orders_map:\n                         del self.orders_map[resting_order.id]\n            \n            # If the price level was exhausted, _peek_best_price will clean it up on the next loop\n        \n        # If incoming was a limit order with residual quantity, add it to the book\n        if incoming_order.price is not None and incoming_order.quantity > 0:\n            self._add_order_to_book(incoming_order)\n\n    def process_event(self, event):\n        \"\"\"Processes a single event tuple.\"\"\"\n        event_type = event[0]\n        \n        if event_type == \"limit\":\n            _, side, qty, price, oid = event\n            order = Order(oid, side, qty, price)\n            self._match_order(order)\n            \n        elif event_type == \"market\":\n            _, side, qty, oid = event\n            order = Order(oid, side, qty, None)\n            self._match_order(order)\n\n        elif event_type == \"cancel\":\n            _, oid = event\n            if oid in self.orders_map:\n                self.orders_map[oid].quantity = 0\n\n    def get_final_metrics(self):\n        \"\"\"Returns the final metrics for the test case.\"\"\"\n        b_star = self._peek_best_price(\"buy\")\n        a_star = self._peek_best_price(\"sell\")\n        \n        vwap = 0.0\n        if self.total_quantity > 0:\n            vwap = self.vwap_numerator / self.total_quantity\n\n        return [\n            f\"{b_star:.6f}\",\n            f\"{a_star:.6f}\",\n            self.n_trades,\n            f\"{self.total_quantity:.6f}\",\n            f\"{vwap:.6f}\"\n        ]\n\ndef solve():\n    test_cases = [\n        # Test Case 1\n        (1e-9, [\n            (\"limit\", \"sell\", 5, 101.0, 1),\n            (\"limit\", \"sell\", 3, 100.5, 2),\n            (\"limit\", \"buy\", 4, 100.0, 3),\n            (\"limit\", \"buy\", 6, 101.0, 4),\n        ]),\n        # Test Case 2\n        (0.0, [\n            (\"limit\", \"sell\", 2, 100.0, 10),\n            (\"limit\", \"sell\", 1, 100.0, 11),\n            (\"limit\", \"buy\", 3, 100.0, 12),\n        ]),\n        # Test Case 3\n        (1e-9, [\n            (\"limit\", \"sell\", 1, 100.0, 20),\n            (\"limit\", \"sell\", 2, 100.2, 21),\n            (\"limit\", \"sell\", 4, 101.0, 22),\n            (\"market\", \"buy\", 5, 23),\n        ]),\n        # Test Case 4\n        (1e-3, [\n            (\"limit\", \"sell\", 5, 100.0001, 30),\n            (\"limit\", \"buy\", 2, 100.0, 31),\n            (\"cancel\", 30),\n            (\"market\", \"sell\", 1, 32),\n        ])\n    ]\n\n    all_results = []\n    for epsilon, events in test_cases:\n        lob = LimitOrderBook(epsilon)\n        for event in events:\n            lob.process_event(event)\n        \n        metrics = lob.get_final_metrics()\n        all_results.append(f\"[{','.join(map(str, metrics))}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"}, {"introduction": "With a working matching engine, we can begin to explore how different market participants influence market dynamics. This practice [@problem_id:2406579] challenges you to implement a stylized High-Frequency Trading (HFT) agent that strategically places orders to profit from the spread. By simulating this agent's behavior, you will directly observe its impact on key market quality metrics and gain insight into the complex interplay between algorithmic trading and liquidity.", "id": "2406579", "problem": "Construct a complete, runnable program that simulates a discrete-time limit order book under price-time priority, to examine the impact of allowing sub-penny pricing on order queue dynamics and a stylized high-frequency trading (HFT) strategy. The model must be defined as follows.\n\nThe asset has a fixed reference level price $P^{\\ast}$ measured in arbitrary currency units. Prices are constrained to a grid with tick size $\\Delta p$, so any quote must be a multiple of $\\Delta p$. Initialize the baseline best bid and best ask at $B_0 = P^{\\ast} - \\Delta p$ and $A_0 = P^{\\ast} + \\Delta p$. Initialize the baseline best bid queue size $Q^0_B$ and best ask queue size $Q^0_A$ (in units), each measured as integers. Time is discrete with steps $t \\in \\{1,2,\\ldots,T\\}$. At each time step exactly one event occurs, independently of the past, according to a categorical distribution with probabilities $p_{\\text{MB}}$, $p_{\\text{MS}}$, $p_{\\text{LB}}$, $p_{\\text{LS}}$, and $p_{\\text{C}}$ that sum to $1$. The five event types are:\n- Market buy (MB) of unit size $1$: removes $1$ unit from the current best ask queue, if available.\n- Market sell (MS) of unit size $1$: removes $1$ unit from the current best bid queue, if available.\n- Baseline limit buy (LB) of unit size $1$: adds $1$ unit to the baseline best bid queue at price $B_t$.\n- Baseline limit sell (LS) of unit size $1$: adds $1$ unit to the baseline best ask queue at price $A_t$.\n- Baseline cancellation (C) of unit size $1$: removes $1$ unit from exactly one of the baseline best queues that currently has strictly positive size, chosen uniformly at random among such sides; if both baseline best queues are empty, this event has no effect.\n\nPrice-time priority means that trades execute at the highest bid and the lowest ask; within a price level, execution priority is first-in-first-out, but since the simulation aggregates homogeneous unit-size orders per side, it is sufficient to update the aggregate queue sizes accordingly. Prices $B_t$ and $A_t$ for baseline orders remain fixed at $B_t = P^{\\ast} - \\Delta p$ and $A_t = P^{\\ast} + \\Delta p$ for all $t$.\n\nIntroduce a stylized high-frequency trading (HFT) agent characterized by parameters: HFT posting quantity $q_{\\text{HFT}} \\in \\mathbb{Z}_{\\ge 0}$ (units) and a time-to-live $\\tau \\in \\mathbb{Z}_{\\ge 1}$ (steps) for its limit orders. The HFT agent is allowed to improve the price by exactly one tick relative to the baseline best on at most one side at any time, which is feasible only because the tick grid allows such price improvement. The HFT agent follows these rules:\n- Activation: Immediately after an LB event, if $q_{\\text{HFT}} \\ge 1$, the HFT posts a buy limit order of size $q_{\\text{HFT}}$ at the improved price $P^{\\ast}$ (one-tick better than the baseline best bid). Immediately after an LS event, if $q_{\\text{HFT}} \\ge 1$, the HFT posts a sell limit order of size $q_{\\text{HFT}}$ at the improved price $P^{\\ast}$ (one-tick better than the baseline best ask). If the HFT already has an active order on the opposite side, that order is cancelled upon this activation. On activation (or re-activation on the same side), the HFT order’s remaining quantity is set to $q_{\\text{HFT}}$ and its remaining time-to-live is set to $\\tau$.\n- Priority and spread: If the HFT has an active buy at price $P^{\\ast}$, then the current best bid becomes $P^{\\ast}$ while the best ask remains at $A_t = P^{\\ast} + \\Delta p$, yielding a current spread of $\\Delta p$. If the HFT has an active sell at price $P^{\\ast}$, then the current best ask becomes $P^{\\ast}$ while the best bid remains at $B_t = P^{\\ast} - \\Delta p$, yielding a current spread of $\\Delta p$. If the HFT has no active order, the spread equals $2\\Delta p$.\n- Execution against market orders: A market buy (respectively market sell) first executes against any active HFT sell (respectively HFT buy) because of the improved price. If the HFT order is present on that side with strictly positive remaining quantity, one unit fills, reducing the HFT’s remaining quantity by $1$, and the HFT immediately neutralizes inventory by submitting an offsetting market order of unit size against the opposite baseline best, which reduces that opposite baseline queue by $1$ if available. If no HFT order is present on the relevant side, the market order consumes the corresponding baseline best queue by $1$ if available.\n- HFT order lifetime: At the end of every time step, if the HFT has an active order, its remaining time-to-live decreases by $1$. If the remaining time-to-live reaches $0$ or the remaining quantity reaches $0$, the HFT cancels its order (no longer active).\n- HFT profit accounting: Each filled HFT unit immediately generates realized profit equal to the contemporaneous spread between the opposite side execution and the HFT’s improved price, which in this model equals $\\Delta p$ per HFT unit filled. The HFT’s profit at time step $t$ is $0$ if no HFT fill occurs at $t$.\n\nLet the following performance statistics be computed over the horizon $\\{1,\\ldots,T\\}$:\n- Average spread: $\\frac{1}{T}\\sum_{t=1}^{T} \\left(A^{\\text{best}}_t - B^{\\text{best}}_t\\right)$, where $A^{\\text{best}}_t$ and $B^{\\text{best}}_t$ are the best ask and best bid at time $t$ implied by the HFT activation rules above.\n- HFT fill rate per step: total number of HFT unit fills divided by $T$.\n- HFT average profit per step: total HFT profit divided by $T$.\n- Average baseline best-queue size: $\\frac{1}{T}\\sum_{t=1}^{T} \\left(Q_{B,t} + Q_{A,t}\\right)$, where $Q_{B,t}$ and $Q_{A,t}$ are the baseline best bid and best ask queue sizes at the end of step $t$.\n\nAll quantities are unitless except prices which are in arbitrary currency units. No angles or physical units are involved. All answers must be expressed as floats.\n\nYour program must run the simulation for the following test suite. Each tuple lists $(\\Delta p, T, q_{\\text{HFT}}, \\tau, \\text{seed}, (p_{\\text{MB}}, p_{\\text{MS}}, p_{\\text{LB}}, p_{\\text{LS}}, p_{\\text{C}}))$. Use $P^{\\ast} = 100$, $Q^0_B = 10$, $Q^0_A = 10$, and unit sizes $1$ for all market and baseline limit orders and cancellations in all test cases.\n- Case $1$: $(0.01, 50000, 1, 50, 123, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- Case $2$: $(0.001, 50000, 1, 50, 456, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- Case $3$: $(0.001, 50000, 0, 50, 789, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- Case $4$: $(0.005, 50000, 1, 50, 321, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- Case $5$: $(0.001, 50000, 1, 50, 654, (0.15, 0.15, 0.15, 0.15, 0.4))$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s result is itself a list $[\\text{avg\\_spread}, \\text{hft\\_fill\\_rate}, \\text{hft\\_profit\\_per\\_step}, \\text{avg\\_baseline\\_queue}]$ with floats. For example, the output format must be of the form\n$[[x_{1,1},x_{1,2},x_{1,3},x_{1,4}],[x_{2,1},x_{2,2},x_{2,3},x_{2,4}],[x_{3,1},x_{3,2},x_{3,3},x_{3,4}],[x_{4,1},x_{4,2},x_{4,3},x_{4,4}],[x_{5,1},x_{5,2},x_{5,3},x_{5,4}]]$\nwith no spaces anywhere in the line.", "solution": "The problem requires the construction of a discrete-time simulation model of a limit order book (LOB) to analyze the effects of a high-frequency trading (HFT) strategy. The problem is well-posed, scientifically grounded in the domain of computational finance, and its parameters and rules are specified with sufficient detail to permit a unique, reproducible solution.\n\nThe solution is a direct implementation of the specified stochastic process. The core of the solution is a function that simulates the LOB's evolution over a time horizon of $T$ steps.\n\n**1. State Representation**\nThe state of the system at any discrete time step $t$ is fully described by a set of variables:\n- $Q_{B,t}$: The number of resting units in the baseline best bid queue at price $P^{\\ast} - \\Delta p$.\n- $Q_{A,t}$: The number of resting units in the baseline best ask queue at price $P^{\\ast} + \\Delta p$.\n- HFT Order State: A structure representing the HFT's single active order, defined by its side (buy or sell), remaining quantity $q_{\\text{rem}}$, and remaining time-to-live (TTL) $\\tau_{\\text{rem}}$. If no order is active, its state is marked as 'none'.\n\nThe simulation begins at $t=0$ with initial queue sizes $Q^0_B$ and $Q^0_A$, and with no active HFT order.\n\n**2. Simulation Dynamics**\nThe simulation proceeds from $t=1$ to $T$. Within each time step, a strict sequence of operations is followed to update the state of the LOB.\n\n**Step 2.1: Event Generation**\nAt the beginning of each step $t$, a single event is drawn from a categorical distribution defined by the probabilities $(p_{\\text{MB}}, p_{\\text{MS}}, p_{\\text{LB}}, p_{\\text{LS}}, p_{\\text{C}})$. The five possible events are: Market Buy (MB), Market Sell (MS), Baseline Limit Buy (LB), Baseline Limit Sell (LS), and Baseline Cancellation (C).\n\n**Step 2.2: State Transition Logic**\nThe system state is updated based on the drawn event and the HFT agent's rules.\n\n- **Market Orders (MB, MS):** If an HFT order exists at a better price (price $P^{\\ast}$), the market order first consumes liquidity from the HFT. A market buy (MB) consumes the HFT's sell order, and a market sell (MS) consumes the HFT's buy order.\n    - Upon a fill of one unit, the HFT's order quantity $q_{\\text{rem}}$ is decremented.\n    - The HFT's total fills are incremented by $1$, and its total profit is incremented by the defined profit-per-fill, $\\Delta p$.\n    - The HFT immediately neutralizes its acquired position by sending an offsetting market order of size $1$ to the opposite baseline queue. For example, after an HFT buy order is filled, the HFT submits a market buy, which consumes one unit from the baseline ask queue $Q_{A,t}$.\n    - If no HFT order is available on the corresponding side, the market order consumes one unit from the respective baseline queue ($Q_{A,t}$ for an MB, $Q_{B,t}$ for an MS), if the queue is not empty.\n\n- **Baseline Limit Orders (LB, LS):** A baseline limit buy (LB) increments $Q_{B,t}$ by $1$, and a baseline limit sell (LS) increments $Q_{A,t}$ by $1$.\n    - Immediately following an LB or LS event, the HFT agent (if $q_{\\text{HFT}} \\ge 1$) places a new limit order of size $q_{\\text{HFT}}$ and TTL $\\tau$ at the improved price $P^{\\ast}$. An LB triggers an HFT buy order, and an LS triggers an HFT sell order.\n    - Posting a new HFT order cancels any pre-existing HFT order, ensuring the HFT is active on at most one side of the book. Activating an order resets its quantity to $q_{\\text{HFT}}$ and its TTL to $\\tau$.\n\n- **Baseline Cancellation (C):** A single unit is removed from one of the non-empty baseline queues ($Q_{B,t}$ or $Q_{A,t}$). If both are non-empty, one is chosen uniformly at random. If only one is non-empty, it is chosen. If both are empty, there is no effect.\n\n**Step 2.3: End-of-Step Updates**\nAfter the event logic is fully resolved, end-of-step updates are performed.\n- **HFT Order Lifecycle:** If an HFT order is active, its TTL, $\\tau_{\\text{rem}}$, is decremented by $1$. The order is then checked for cancellation. If its TTL has reached $0$ or its remaining quantity $q_{\\text{rem}}$ has reached $0$, the order is removed from the book (its state is set to 'none').\n\n**3. Metrics Calculation**\nPerformance statistics are aggregated over the $T$ time steps. At the end of each step $t$, after all state transitions and cancellations have been processed, the following metrics are recorded:\n\n- **Spread:** The best bid-ask spread, $A^{\\text{best}}_t - B^{\\text{best}}_t$, is calculated. If the HFT has an active order (post-cancellation check), the spread is $\\Delta p$. Otherwise, the spread is determined by the baseline queues, which is $2\\Delta p$.\n- **Baseline Queue Size:** The total size of the baseline queues, $Q_{B,t} + Q_{A,t}$, is recorded.\n\nAfter the simulation completes, the final average metrics are computed by dividing the accumulated totals by $T$:\n- Average Spread: $\\frac{1}{T}\\sum_{t=1}^{T} (A^{\\text{best}}_t - B^{\\text{best}}_t)$\n- HFT Fill Rate: $\\frac{1}{T} \\times (\\text{Total HFT Fills})$\n- HFT Average Profit: $\\frac{1}{T} \\times (\\text{Total HFT Profit})$\n- Average Baseline Queue Size: $\\frac{1}{T}\\sum_{t=1}^{T} (Q_{B,t} + Q_{A,t})$\n\n**4. Implementation**\nThe simulation is implemented in Python, using the `numpy` library for reproducible random number generation, which is controlled by a specified seed for each test case. The logic described above is encapsulated in a function that takes the model parameters as input. A main function iterates through the provided test cases, calls the simulation, and formats the results into the precise string format required.", "answer": "```python\nimport numpy as np\n\ndef run_simulation(delta_p, T, q_hft, tau, seed, probs):\n    \"\"\"\n    Runs a single simulation of the limit order book model.\n    \"\"\"\n    # Fixed parameters\n    P_star = 100.0\n    Q0_B = 10\n    Q0_A = 10\n    \n    # State variables\n    q_b = Q0_B\n    q_a = Q0_A\n    hft_order = {'side': 'none', 'qty': 0, 'ttl': 0}\n\n    # Statistics accumulators\n    total_spread = 0.0\n    total_hft_fills = 0\n    total_hft_profit = 0.0\n    total_baseline_queue_size = 0.0\n\n    # Setup random number generator\n    rng = np.random.default_rng(seed)\n    events = ['MB', 'MS', 'LB', 'LS', 'C']\n\n    for _ in range(T):\n        # Step 1: Draw event\n        event = rng.choice(events, p=probs)\n        \n        # Step 2: State Transition Logic\n        if event == 'MB':  # Market Buy\n            if hft_order['side'] == 'sell' and hft_order['qty'] > 0:\n                hft_order['qty'] -= 1\n                total_hft_fills += 1\n                total_hft_profit += delta_p\n                # HFT offset order (market sell against baseline bid)\n                if q_b > 0:\n                    q_b -= 1\n            else:\n                if q_a > 0:\n                    q_a -= 1\n        \n        elif event == 'MS':  # Market Sell\n            if hft_order['side'] == 'buy' and hft_order['qty'] > 0:\n                hft_order['qty'] -= 1\n                total_hft_fills += 1\n                total_hft_profit += delta_p\n                # HFT offset order (market buy against baseline ask)\n                if q_a > 0:\n                    q_a -= 1\n            else:\n                if q_b > 0:\n                    q_b -= 1\n        \n        elif event == 'LB':  # Baseline Limit Buy\n            q_b += 1\n            if q_hft >= 1:\n                hft_order = {'side': 'buy', 'qty': q_hft, 'ttl': tau}\n        \n        elif event == 'LS':  # Baseline Limit Sell\n            q_a += 1\n            if q_hft >= 1:\n                hft_order = {'side': 'sell', 'qty': q_hft, 'ttl': tau}\n        \n        elif event == 'C':  # Baseline Cancellation\n            can_cancel_b = q_b > 0\n            can_cancel_a = q_a > 0\n            if can_cancel_b and can_cancel_a:\n                if rng.random() < 0.5:\n                    q_b -= 1\n                else:\n                    q_a -= 1\n            elif can_cancel_b:\n                q_b -= 1\n            elif can_cancel_a:\n                q_a -= 1\n\n        # Step 3: End-of-step HFT order lifecycle update\n        if hft_order['side'] != 'none':\n            hft_order['ttl'] -= 1\n            if hft_order['ttl'] <= 0 or hft_order['qty'] <= 0:\n                hft_order = {'side': 'none', 'qty': 0, 'ttl': 0}\n\n        # Step 4: Calculate and accumulate metrics for the current step t\n        current_spread = 2.0 * delta_p\n        if hft_order['side'] != 'none':\n            current_spread = delta_p\n        \n        total_spread += current_spread\n        total_baseline_queue_size += (q_b + q_a)\n\n    # Final calculation of average metrics\n    avg_spread = total_spread / T\n    hft_fill_rate = total_hft_fills / T\n    hft_avg_profit = total_hft_profit / T\n    avg_baseline_queue = total_baseline_queue_size / T\n\n    return [avg_spread, hft_fill_rate, hft_avg_profit, avg_baseline_queue]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.01, 50000, 1, 50, 123, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.001, 50000, 1, 50, 456, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.001, 50000, 0, 50, 789, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.005, 50000, 1, 50, 321, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.001, 50000, 1, 50, 654, (0.15, 0.15, 0.15, 0.15, 0.4)),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        delta_p, T, q_hft, tau, seed, probs = case\n        result = run_simulation(delta_p, T, q_hft, tau, seed, probs)\n        all_results.append(result)\n\n    # Format the output string exactly as specified\n    result_strings = []\n    for res_list in all_results:\n        # Format each float to a reasonable precision to avoid excessive length\n        inner_str = f\"[{','.join(f'{x:.8f}' for x in res_list)}]\"\n        result_strings.append(inner_str)\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"}, {"introduction": "The data generated by a limit order book is a rich, but often noisy, source of information about hidden trading intentions. This final practice moves from pure simulation to statistical inference, asking you to develop an intelligent agent that detects hidden \"iceberg\" orders [@problem_id:2406526]. This exercise combines concepts from point processes and hypothesis testing, demonstrating how computational models can be used to unearth patterns and make informed decisions from market data.", "id": "2406526", "problem": "You are given a stylized, one-sided limit order book at a single price level. The event stream consists of two types of time-stamped events measured in seconds: marketable trades that consume displayed liquidity at the level and replenishments that add displayed liquidity at the same level. For each test case, you must decide whether the observed trade flow and replenishment timing are more consistent with the presence of a hidden \"iceberg\" order at that price level during a specified detection interval. A hidden iceberg order is defined here as latent liquidity that tends to restore displayed quantity shortly after it is consumed by trades.\n\nFormulation. Let the calibration interval be the half-open interval $\\left[0,T_{\\mathrm{cal}}\\right)$ with duration $T_{\\mathrm{cal}}$ in seconds. Let replenishment (add-liquidity) event times inside the calibration interval be $\\{r_i^{(\\mathrm{cal})}\\}_{i=1}^{N_{\\mathrm{cal}}}$, where $N_{\\mathrm{cal}}$ is the count of replenishments observed during calibration. In the subsequent detection interval $\\left[T_{\\mathrm{cal}}, T_{\\mathrm{end}}\\right]$, let the marketable trade times be $\\{t_j\\}_{j=1}^{m}$ and the replenishment times be $\\{s_\\ell\\}_{\\ell=1}^{L}$. Fix a window length $\\tau>0$ seconds and a significance level $\\alpha\\in(0,1)$ expressed as a decimal. For each trade time $t_j$, define the indicator\n$$\nY_j \\equiv \\mathbf{1}\\left\\{\\exists\\, s_\\ell \\text{ such that } t_j < s_\\ell \\le t_j + \\tau\\right\\},\n$$\nwhich records whether a replenishment occurs within $\\tau$ seconds after the trade.\n\nModeling assumptions. During calibration, replenishments follow a homogeneous Poisson process with constant rate $\\lambda$ (per second). During detection under the null hypothesis of no iceberg, replenishments continue to follow a homogeneous Poisson process with the same rate $\\lambda$, independent of the trade times $\\{t_j\\}_{j=1}^m$. Under this null, for any fixed $\\tau$, the probability that $Y_j=1$ equals $p_0 = 1 - e^{-\\lambda \\tau}$. Under the alternative of an iceberg, replenishments are more likely to occur promptly after trades; specifically, conditional on a trade, a replenishment occurs within $\\tau$ seconds with probability $p_1=0.9$, independently across trades.\n\nLearning and decision rule. Estimate $\\lambda$ from first principles using the calibration data as the maximum likelihood estimator for a homogeneous Poisson process,\n$$\n\\widehat{\\lambda} \\equiv \\frac{N_{\\mathrm{cal}}}{T_{\\mathrm{cal}}}.\n$$\nSet $\\widehat{p}_0 \\equiv 1 - e^{-\\widehat{\\lambda} \\tau}$. In the detection interval, compute $K \\equiv \\sum_{j=1}^{m} Y_j$, the number of trades that are followed by at least one replenishment within $\\tau$ seconds. Decide \"iceberg present\" if and only if $K \\ge k^\\star$, where $k^\\star$ is the smallest integer in $\\{0,1,\\dots,m\\}$ such that the upper tail of the Binomial distribution with parameters $m$ and $\\widehat{p}_0$ is no larger than $\\alpha$:\n$$\n\\sum_{k=k^\\star}^{m} \\binom{m}{k} \\widehat{p}_0^{\\,k} \\left(1-\\widehat{p}_0\\right)^{m-k} \\le \\alpha.\n$$\nIf $m=0$ (no trades in the detection interval), return the decision \"iceberg present\" as $\\mathrm{False}$.\n\nUnits and angle conventions. All times must be treated in seconds. There are no angular quantities.\n\nYour program must implement the above estimator and decision rule exactly and apply them to the test suite below. For each test case, you are given $T_{\\mathrm{cal}}$, the lists $\\{r_i^{(\\mathrm{cal})}\\}$, $\\{t_j\\}$, $\\{s_\\ell\\}$, and the parameters $\\tau$ and $\\alpha$. Compute the boolean decision for each test case in order.\n\nTest suite. Each list below contains strictly increasing real numbers in seconds. All replenishment events listed for calibration occur in $\\left[0,T_{\\mathrm{cal}}\\right)$; all detection events occur in $\\left[T_{\\mathrm{cal}}, T_{\\mathrm{end}}\\right]$ with unspecified $T_{\\mathrm{end}}$ (only relative timing within the detection interval matters for the decision rule).\n\n- Test case $1$ (highly suggestive replenishment after every trade):\n  - $T_{\\mathrm{cal}}=10.0$.\n  - Calibration replenishments $\\{r_i^{(\\mathrm{cal})}\\} = [1.0,\\, 2.7,\\, 4.0,\\, 5.5,\\, 7.2,\\, 9.8]$.\n  - Detection trades $\\{t_j\\} = [10.0,\\, 11.0,\\, 12.0,\\, 13.0,\\, 14.0,\\, 15.0]$.\n  - Detection replenishments $\\{s_\\ell\\} = [10.05,\\, 11.05,\\, 12.05,\\, 13.05,\\, 14.05,\\, 15.05,\\, 19.0]$.\n  - $\\tau = 0.15$, $\\alpha=0.05$.\n\n- Test case $2$ (rare replenishments; mostly absent after trades):\n  - $T_{\\mathrm{cal}}=10.0$.\n  - Calibration replenishments $\\{r_i^{(\\mathrm{cal})}\\} = [2.0,\\, 7.0]$.\n  - Detection trades $\\{t_j\\} = [10.0,\\, 10.5,\\, 11.0,\\, 12.0,\\, 13.0,\\, 14.0,\\, 15.0]$.\n  - Detection replenishments $\\{s_\\ell\\} = [12.05,\\, 16.0]$.\n  - $\\tau = 0.15$, $\\alpha=0.05$.\n\n- Test case $3$ (borderline frequency of post-trade replenishments):\n  - $T_{\\mathrm{cal}}=10.0$.\n  - Calibration replenishments $\\{r_i^{(\\mathrm{cal})}\\} = [0.5,\\, 1.7,\\, 3.0,\\, 6.3,\\, 8.9]$.\n  - Detection trades $\\{t_j\\} = [10.0,\\, 10.3,\\, 11.0,\\, 12.0,\\, 13.0,\\, 14.0,\\, 15.0,\\, 16.0,\\, 17.0,\\, 18.0]$.\n  - Detection replenishments $\\{s_\\ell\\} = [10.05,\\, 12.30,\\, 14.10,\\, 17.30]$.\n  - $\\tau = 0.15$, $\\alpha=0.05$.\n\n- Test case $4$ (no trades in detection interval):\n  - $T_{\\mathrm{cal}}=10.0$.\n  - Calibration replenishments $\\{r_i^{(\\mathrm{cal})}\\} = [1.0,\\, 2.0,\\, 3.0]$.\n  - Detection trades $\\{t_j\\} = [\\,]$ (empty list).\n  - Detection replenishments $\\{s_\\ell\\} = [\\,]$ (empty list).\n  - $\\tau = 0.15$, $\\alpha=0.05$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets and ordered as the test cases above, for example: \"[True,False,True,False]\".", "solution": "The problem presents a well-defined task in statistical hypothesis testing, applied to the analysis of limit order book data. The formulation is scientifically grounded, internally consistent, and complete. There are no logical contradictions, ambiguities, or factual errors. Therefore, the problem is deemed valid and a formal solution can be constructed.\n\nThe core of the problem is to decide between two hypotheses concerning the behavior of liquidity replenishments following trades.\n- The null hypothesis, $H_0$, posits that replenishments are random events governed by a homogeneous Poisson process, independent of trade occurrences.\n- The alternative hypothesis, $H_1$, posits that a hidden \"iceberg\" order exists, which causes a high probability of rapid replenishment after a trade.\n\nThe solution proceeds systematically through the steps outlined in the problem statement.\n\n**Step 1: Estimation of the Baseline Replenishment Rate**\n\nUnder the null hypothesis $H_0$, replenishments in the calibration interval $\\left[0, T_{\\mathrm{cal}}\\right)$ follow a homogeneous Poisson process with an unknown constant rate $\\lambda$. The problem provides the maximum likelihood estimator (MLE) for this rate, which is derived from first principles of statistical inference for point processes. Given $N_{\\mathrm{cal}}$ events observed over a duration of $T_{\\mathrm{cal}}$, the MLE for $\\lambda$ is:\n$$\n\\widehat{\\lambda} = \\frac{N_{\\mathrm{cal}}}{T_{\\mathrm{cal}}}\n$$\nThis estimator represents the empirical frequency of replenishment events and serves as our baseline expectation for replenishment activity in the absence of any special mechanism like an iceberg order.\n\n**Step 2: Derivation of the Null Probability of Post-Trade Replenishment**\n\nUnder $H_0$, the number of replenishments in any time interval of length $\\tau$ is a random variable following a Poisson distribution with mean $\\lambda \\tau$. The probability of observing zero replenishments in such an interval is $e^{-\\lambda \\tau}$. Consequently, the probability of observing at least one replenishment within $\\tau$ seconds is:\n$$\np_0 = 1 - e^{-\\lambda \\tau}\n$$\nSince $\\lambda$ is unknown, we substitute its estimate $\\widehat{\\lambda}$ to obtain an estimated probability under the null hypothesis:\n$$\n\\widehat{p}_0 = 1 - e^{-\\widehat{\\lambda}\\tau}\n$$\nThis value, $\\widehat{p}_0$, is the probability that a single, arbitrary trade is followed by a replenishment within the time window $\\tau$, assuming no iceberg order is present.\n\n**Step 3: Construction of the Test Statistic**\n\nIn the detection interval $\\left[T_{\\mathrm{cal}}, T_{\\mathrm{end}}\\right]$, we observe $m$ trades at times $\\{t_j\\}_{j=1}^m$. For each trade $t_j$, we define a Bernoulli random variable $Y_j$:\n$$\nY_j = \\mathbf{1}\\left\\{\\exists\\, s_\\ell \\text{ such that } t_j < s_\\ell \\le t_j + \\tau\\right\\}\n$$\nUnder $H_0$, the $Y_j$ are assumed to be independent and identically distributed, with $P(Y_j=1) = \\widehat{p}_0$. The test statistic, $K$, is the sum of these indicators:\n$$\nK = \\sum_{j=1}^{m} Y_j\n$$\nThis statistic $K$ counts the number of trades that are \"quickly\" followed by a replenishment. Under $H_0$, $K$ follows a Binomial distribution with parameters $m$ and $\\widehat{p}_0$, denoted $K \\sim \\text{Binomial}(m, \\widehat{p}_0)$. An unusually high value of $K$ would cast doubt on the null hypothesis.\n\n**Step 4: The Decision Rule**\n\nWe perform a one-sided hypothesis test at a significance level $\\alpha$. We reject $H_0$ in favor of $H_1$ if the observed value of $K$ is sufficiently large. To formalize \"sufficiently large,\" we find a critical value $k^\\star$, which is the smallest integer in $\\{0, 1, \\dots, m\\}$ defining the rejection region $[k^\\star, m]$. This $k^\\star$ is chosen such that the probability of a Type I error (falsely rejecting a true $H_0$) is controlled at or below $\\alpha$. Mathematically, $k^\\star$ is the minimum integer satisfying:\n$$\nP(X \\ge k^\\star) = \\sum_{k=k^\\star}^{m} \\binom{m}{k} \\widehat{p}_0^{\\,k} \\left(1-\\widehat{p}_0\\right)^{m-k} \\le \\alpha,\n$$\nwhere $X \\sim \\text{Binomial}(m, \\widehat{p}_0)$. This sum is the survival function (SF) of the binomial distribution.\n\nThe final decision is made by comparing the observed statistic $K$ to this critical value:\n- If $K \\ge k^\\star$, we reject $H_0$ and conclude that an iceberg order is present (return True).\n- If $K < k^\\star$, we fail to reject $H_0$ and conclude there is not enough evidence for an iceberg order (return False).\nA special case is stipulated: if $m=0$, no trades occur, and the decision is automatically False.\n\n**Application to Test Cases**\n\n**Test Case 1:**\n- Given: $T_{\\mathrm{cal}}=10.0$, $N_{\\mathrm{cal}}=6$, $m=6$, $\\tau=0.15$, $\\alpha=0.05$.\n- $\\widehat{\\lambda} = 6 / 10.0 = 0.6$.\n- $\\widehat{p}_0 = 1 - e^{-0.6 \\times 0.15} = 1 - e^{-0.09} \\approx 0.08607$.\n- For each of the $m=6$ trades, there is a replenishment within the $(t_j, t_j+0.15]$ window. Thus, $K=6$.\n- We seek the smallest integer $k^\\star \\in \\{0, \\dots, 6\\}$ such that $P(X \\ge k^\\star) \\le 0.05$ for $X \\sim \\text{Binomial}(6, 0.08607)$.\n  - $P(X \\ge 2) \\approx 0.0835 > 0.05$.\n  - $P(X \\ge 3) \\approx 0.0031 \\le 0.05$.\n- The critical value is $k^\\star=3$.\n- Decision: Since $K=6 \\ge k^\\star=3$, we reject $H_0$. The result is True.\n\n**Test Case 2:**\n- Given: $T_{\\mathrm{cal}}=10.0$, $N_{\\mathrm{cal}}=2$, $m=7$, $\\tau=0.15$, $\\alpha=0.05$.\n- $\\widehat{\\lambda} = 2 / 10.0 = 0.2$.\n- $\\widehat{p}_0 = 1 - e^{-0.2 \\times 0.15} = 1 - e^{-0.03} \\approx 0.02956$.\n- The trade at $t_4=12.0$ is followed by a replenishment at $s_1=12.05$, which is within the window $(12.0, 12.15]$. No other trades are followed by a replenishment. Thus, $K=1$.\n- We seek $k^\\star$ for $X \\sim \\text{Binomial}(7, 0.02956)$.\n  - $P(X \\ge 1) \\approx 0.1885 > 0.05$.\n  - $P(X \\ge 2) \\approx 0.0153 \\le 0.05$.\n- The critical value is $k^\\star=2$.\n- Decision: Since $K=1 < k^\\star=2$, we fail to reject $H_0$. The result is False.\n\n**Test Case 3:**\n- Given: $T_{\\mathrm{cal}}=10.0$, $N_{\\mathrm{cal}}=5$, $m=10$, $\\tau=0.15$, $\\alpha=0.05$.\n- $\\widehat{\\lambda} = 5 / 10.0 = 0.5$.\n- $\\widehat{p}_0 = 1 - e^{-0.5 \\times 0.15} = 1 - e^{-0.075} \\approx 0.07226$.\n- The trade at $t_1=10.0$ has a replenishment at $10.05$. The trade at $t_6=14.0$ has a replenishment at $14.10$. No other trades have a valid subsequent replenishment. Thus, $K=2$.\n- We seek $k^\\star$ for $X \\sim \\text{Binomial}(10, 0.07226)$.\n  - $P(X \\ge 2) \\approx 0.1565 > 0.05$.\n  - $P(X \\ge 3) \\approx 0.0271 \\le 0.05$.\n- The critical value is $k^\\star=3$.\n- Decision: Since $K=2 < k^\\star=3$, we fail to reject $H_0$. The result is False.\n\n**Test Case 4:**\n- Given: $m=0$.\n- According to the problem's explicit rule for no trades in the detection interval, the decision must be False. We do not need to perform any calculations.\n- Decision: The result is False.\n\nThe final sequence of boolean decisions is [True, False, False, False].", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import binom\n\ndef solve():\n    \"\"\"\n    Implements the iceberg order detection algorithm based on hypothesis testing.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"T_cal\": 10.0,\n            \"r_cal\": [1.0, 2.7, 4.0, 5.5, 7.2, 9.8],\n            \"t_det\": [10.0, 11.0, 12.0, 13.0, 14.0, 15.0],\n            \"s_det\": [10.05, 11.05, 12.05, 13.05, 14.05, 15.05, 19.0],\n            \"tau\": 0.15,\n            \"alpha\": 0.05\n        },\n        {\n            \"T_cal\": 10.0,\n            \"r_cal\": [2.0, 7.0],\n            \"t_det\": [10.0, 10.5, 11.0, 12.0, 13.0, 14.0, 15.0],\n            \"s_det\": [12.05, 16.0],\n            \"tau\": 0.15,\n            \"alpha\": 0.05\n        },\n        {\n            \"T_cal\": 10.0,\n            \"r_cal\": [0.5, 1.7, 3.0, 6.3, 8.9],\n            \"t_det\": [10.0, 10.3, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0],\n            \"s_det\": [10.05, 12.30, 14.10, 17.30],\n            \"tau\": 0.15,\n            \"alpha\": 0.05\n        },\n        {\n            \"T_cal\": 10.0,\n            \"r_cal\": [1.0, 2.0, 3.0],\n            \"t_det\": [],\n            \"s_det\": [],\n            \"tau\": 0.15,\n            \"alpha\": 0.05\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        T_cal = case[\"T_cal\"]\n        r_cal = case[\"r_cal\"]\n        t_det = case[\"t_det\"]\n        s_det = case[\"s_det\"]\n        tau = case[\"tau\"]\n        alpha = case[\"alpha\"]\n\n        m = len(t_det)\n        \n        # Per problem specification, if m=0, return False.\n        if m == 0:\n            results.append(False)\n            continue\n            \n        N_cal = len(r_cal)\n        \n        # Step 1: Estimate lambda\n        if T_cal > 0:\n            lambda_hat = N_cal / T_cal\n        else: # Handle division by zero, although not in test cases\n            lambda_hat = 0.0\n\n        # Step 2: Estimate p0 under the null hypothesis\n        p0_hat = 1 - np.exp(-lambda_hat * tau)\n\n        # Step 3: Compute the test statistic K\n        K = 0\n        trades_np = np.array(t_det)\n        replenishments_np = np.array(s_det)\n        \n        if len(replenishments_np) > 0:\n            # For each trade, find the index of the first replenishment that occurs *after* it.\n            # searchsorted with side='right' finds insertion points for trades\n            # which is the index of the first element in replenishments > trade_time.\n            indices = np.searchsorted(replenishments_np, trades_np, side='right')\n            \n            for i in range(m):\n                trade_time = trades_np[i]\n                repl_index = indices[i]\n                \n                # Check if there is a replenishment after the trade\n                if repl_index < len(replenishments_np):\n                    # Check if this replenishment is within the tau window\n                    if replenishments_np[repl_index] <= trade_time + tau:\n                        K += 1\n        \n        # Step 4: Find the critical value k_star\n        # k_star is the smallest integer such that P(X >= k_star) <= alpha\n        # P(X >= k) is the survival function, binom.sf(k-1, n, p)\n        k_star = -1\n        for k_test in range(m + 2): # Iterate up to m+1\n            # binom.sf(k-1) computes P(X >= k)\n            p_value = binom.sf(k_test - 1, m, p0_hat)\n            if p_value <= alpha:\n                k_star = k_test\n                break\n        \n        # If no such k is found (e.g., if alpha is very small), k_star remains m+1,\n        # which means the null is never rejected. This logic is correct.\n\n        # Step 5: Make the decision\n        decision = K >= k_star\n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(res) for res in results)}]\")\n\nsolve()\n```"}]}