name: PR triage (labels, reviewers, summary)

on:
  pull_request_target:
    types: [opened, reopened, synchronize, ready_for_review, edited]

permissions:
  contents: read         # read mapping file
  pull-requests: write   # request reviewers and comment
  issues: write          # add/remove labels

concurrency:
  group: pr-triage-${{ github.event.pull_request.id }}
  cancel-in-progress: false

jobs:
  triage:
    runs-on: ubuntu-latest
    steps:
      - name: Triage PR
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const { owner, repo } = context.repo;
            const baseRef = pr.base.ref;

            // ---- Helpers ----
            function globToRegExp(glob) {
              let re = glob
                .replace(/[.+^${}()|[\]\\]/g, '\\$&')
                .replace(/\/\*\*\/?/g, '(?:\\/.*\\/)?')
                .replace(/\*\*/g, '.*')
                .replace(/\*/g, '[^/]*')
                .replace(/\?/g, '.');
              return new RegExp('^' + re + '$');
            }

            async function getJSONFile(path) {
              try {
                const res = await github.rest.repos.getContent({
                  owner, repo, path, ref: baseRef
                });
                if (Array.isArray(res.data) || !res.data.content) return null;
                const decoded = Buffer.from(res.data.content, 'base64').toString('utf8');
                return JSON.parse(decoded);
              } catch (e) {
                core.info(`No mapping file at ${path} or failed to parse JSON: ${e.message}`);
                return null;
              }
            }

            async function listAllChangedFiles() {
              const files = await github.paginate(github.rest.pulls.listFiles, {
                owner, repo, pull_number: pr.number, per_page: 100
              });
              return files.map(f => ({
                filename: f.filename,
                status: f.status,
                additions: f.additions,
                deletions: f.deletions,
                changes: f.changes
              }));
            }

            async function ensureLabelsExist(labelsWithOptionalColor) {
              for (const { name, color, description } of labelsWithOptionalColor) {
                try {
                  await github.rest.issues.getLabel({ owner, repo, name });
                } catch (e) {
                  if (e.status === 404) {
                    try {
                      await github.rest.issues.createLabel({
                        owner, repo, name,
                        color: color || 'ededed',
                        description: description || 'Created by PR triage workflow'
                      });
                      core.info(`Created label: ${name}`);
                    } catch (ce) {
                      core.warning(`Could not create label ${name}: ${ce.message}`);
                    }
                  } else {
                    core.warning(`Error checking label ${name}: ${e.message}`);
                  }
                }
              }
            }

            async function addLabels(issueNumber, labels) {
              if (!labels.length) return;
              try {
                await github.rest.issues.addLabels({
                  owner, repo, issue_number: issueNumber, labels
                });
              } catch (e) {
                core.warning(`Failed to add labels [${labels.join(', ')}]: ${e.message}`);
              }
            }

            async function removeLabelIfPresent(issueNumber, name) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name });
              } catch (e) {
                if (e.status !== 404) core.info(`Label ${name} not present or removal failed: ${e.message}`);
              }
            }

            async function upsertSummaryComment(issueNumber, body) {
              const marker = '<!-- pr-bot:summary -->';
              const fullBody = `${marker}\n${body}`;
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner, repo, issue_number: issueNumber, per_page: 100
              });
              const existing = comments.find(c =>
                c.user && c.user.type === 'Bot' &&
                c.body && c.body.includes(marker)
              );
              if (existing) {
                await github.rest.issues.updateComment({
                  owner, repo, comment_id: existing.id, body: fullBody
                });
              } else {
                await github.rest.issues.createComment({
                  owner, repo, issue_number: issueNumber, body: fullBody
                });
              }
            }

            // ---- Load mapping file ----
            const map = await getJSONFile('.github/reviewer-map.json') || {};
            const defaultLabels = new Set((map.defaults && map.defaults.labels) || []);
            const sizeBands = Array.isArray(map.sizeLabels) && map.sizeLabels.length
              ? map.sizeLabels
              : [
                  { label: 'size:XS', max: 9 },
                  { label: 'size:S',  max: 49 },
                  { label: 'size:M',  max: 199 },
                  { label: 'size:L',  max: 999 },
                  { label: 'size:XL', max: 999999 }
                ];
            const rules = Array.isArray(map.rules) ? map.rules : [];
            const ruleRegexes = rules.map(r => ({ ...r, regex: globToRegExp(r.pattern) }));

            // Field mapping: value can be string (slug) or object { slug, users?, teams? }
            const fieldMap = map.fieldMap || {};
            const fieldLabels = new Set();

            function normalizedSegments(path) {
              return path.split('/').map(s => {
                // 1) Strip trailing "@@<digits>"
                let t = s.replace(/@@\d+$/, '');
                // 2) Strip trailing "(本科|研究生|Undergraduate|Graduate)" with ASCII/full-width brackets, allow spaces
                //    Support multiple trailing qualifiers if present
                t = t.replace(/\s*(?:[\(（]\s*(?:本科|研究生|Undergraduate|Graduate)\s*[\)）])+\s*$/i, '');
                return t;
              });
            }

            // ---- Compute changes ----
            const files = await listAllChangedFiles();
            const totalAdd = files.reduce((s, f) => s + (f.additions || 0), 0);
            const totalDel = files.reduce((s, f) => s + (f.deletions || 0), 0);
            const totalChg = totalAdd + totalDel;

            // Size label
            let sizeLabel = sizeBands.find(b => totalChg <= b.max)?.label || null;

            // Match rules and collect reviewers/labels
            const matchedLabels = new Set([...defaultLabels]);
            const userReviewers = new Set();
            const teamReviewers = new Set();

            for (const f of files) {
              // Rule-based labels/reviewers
              for (const r of ruleRegexes) {
                if (r.regex.test(f.filename)) {
                  (r.labels || []).forEach(l => matchedLabels.add(l));
                  (r.users || []).forEach(u => userReviewers.add(u));
                  (r.teams || []).forEach(t => teamReviewers.add(t));
                }
              }
              // Field-based labels and reviewers
              for (const seg of normalizedSegments(f.filename)) {
                const m = fieldMap[seg];
                if (!m) continue;

                let slug = null;
                if (typeof m === 'string') {
                  slug = m;
                } else if (m && typeof m === 'object') {
                  slug = m.slug || null;
                  if (Array.isArray(m.users)) m.users.forEach(u => userReviewers.add(u));
                  if (Array.isArray(m.teams)) m.teams.forEach(t => teamReviewers.add(t));
                }
                if (slug) fieldLabels.add(`field:${slug}`);
              }
            }

            // Remove PR author from reviewers
            const author = pr.user?.login;
            if (author) userReviewers.delete(author);

            // Avoid re-requesting already requested reviewers
            const alreadyUsers = new Set((pr.requested_reviewers || []).map(u => u.login));
            const alreadyTeams = new Set((pr.requested_teams || []).map(t => t.slug));

            const newUsers = [...userReviewers].filter(u => !alreadyUsers.has(u));
            const newTeams = [...teamReviewers].filter(t => !alreadyTeams.has(t));

            // Prepare labels
            const labelsToAdd = new Set([...matchedLabels, ...fieldLabels]);
            if (sizeLabel) labelsToAdd.add(sizeLabel);

            // Ensure labels exist (attempt auto-create)
            await ensureLabelsExist(
              [...labelsToAdd].map(name => ({ name }))
            );

            // Remove previous size:* labels to keep only one
            const currentLabels = (pr.labels || []).map(l => l.name);
            for (const l of currentLabels) {
              if (l.toLowerCase().startsWith('size:') && l !== sizeLabel) {
                await removeLabelIfPresent(pr.number, l);
              }
            }

            // Add labels not already present
            const labelsMissing = [...labelsToAdd].filter(l => !currentLabels.includes(l));
            if (labelsMissing.length) {
              await addLabels(pr.number, labelsMissing);
            }

            // Request reviewers if not a draft
            let requestedUsers = [];
            let requestedTeams = [];
            if (!pr.draft) {
              const cap = 15; // GitHub API limit for combined reviewers
              const combined = [...newUsers.map(u => ({ t: 'u', v: u })), ...newTeams.map(t => ({ t: 't', v: t }))].slice(0, cap);
              const usersToReq = combined.filter(x => x.t === 'u').map(x => x.v);
              const teamsToReq = combined.filter(x => x.t === 't').map(x => x.v);

              if (usersToReq.length || teamsToReq.length) {
                try {
                  await github.rest.pulls.requestReviewers({
                    owner, repo, pull_number: pr.number,
                    reviewers: usersToReq,
                    team_reviewers: teamsToReq
                  });
                  requestedUsers = usersToReq;
                  requestedTeams = teamsToReq;
                } catch (e) {
                  core.warning(`Failed to request reviewers: ${e.message}`);
                }
              }
            }

            // ---- Build and upsert summary comment ----
            const topFiles = files
              .sort((a, b) => (b.additions + b.deletions) - (a.additions + a.deletions))
              .slice(0, 10);

            const areas = [...labelsToAdd].filter(l => l.startsWith('area:'));
            const fields = [...fieldLabels];
            const reviewersList = [
              ...requestedUsers.map(u => `@${u}`),
              ...requestedTeams.map(t => `@${owner}/${t}`)
            ];
            const labelsList = [...labelsToAdd];

            const bodyLines = [];
            bodyLines.push(`PR triage summary`);
            bodyLines.push('');
            bodyLines.push(`- Files changed: ${files.length}  |  Additions: ${totalAdd}  |  Deletions: ${totalDel}`);
            if (sizeLabel) bodyLines.push(`- Size: ${sizeLabel}`);
            if (areas.length) bodyLines.push(`- Areas: ${areas.join(', ')}`);
            if (fields.length) bodyLines.push(`- Fields: ${fields.join(', ')}`);
            if (labelsList.length) bodyLines.push(`- Labels applied: ${labelsList.join(', ')}`);
            if (reviewersList.length) bodyLines.push(`- Reviewers requested: ${reviewersList.join(', ')}`);
            bodyLines.push('');
            bodyLines.push(`Top changed files:`);
            for (const f of topFiles) {
              bodyLines.push(`- ${f.filename} (+${f.additions} / -${f.deletions})`);
            }
            bodyLines.push('');
            bodyLines.push(`Note: This comment is auto-updated when the PR changes.`);

            await upsertSummaryComment(pr.number, bodyLines.join('\n'));

            core.info('PR triage complete.');
