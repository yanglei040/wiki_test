{"hands_on_practices": [{"introduction": "要掌握压缩感知中的理论概念，第一步是进行计算实现。这个练习 [@problem_id:3434936] 提供了一个动手实践的机会，旨在弥合互相关性（$\\mu$）和受限等距常数（$\\delta_s$）等抽象定义与其实际计算之间的差距。通过编程，你将生成传感矩阵，计算其经验相干性，并验证其如何遵守理论上的Welch界。此外，你将探索格什戈林圆盘定理如何提供一种切实可行的方法来估计通常计算上难以处理的$\\delta_s$，从而让你直接感受这些基本概念之间的相互作用。", "problem": "您的任务是，以编程方式研究相互相干性、韦尔奇下界以及基于盖尔什戈林圆盘定理的限制等距常数界限三者之间的相互作用。研究对象是其列受到乘性归一化误差扰动的随机部分标准正交矩阵。\n\n仅从以下基本概念出发：\n- 相互相干性的定义：对于一个有列的矩阵，相互相干性是不同列对之间最大绝对归一化内积。\n- 韦尔奇界：对于固定维度空间中任意一组固定数量的单位向量，其相互相干性服从一个仅由维度和向量数量决定的通用下界。\n- 盖尔什戈林圆盘定理：一个实对称矩阵的每个特征值至少位于一个盖尔什戈林圆盘内，该圆盘由对应行中的对角线元素和非对角线元素的绝对值之和确定。\n- 矩阵的$s$阶限制等距常数：最小的非负数，使得该矩阵与任意$s$-稀疏向量的乘积的范数平方，被夹在该向量范数平方的线性扰动之间。\n\n您的程序必须为每个测试用例实现以下流程：\n1. 在$\\mathbb{R}^{n \\times n}$中构造一个随机标准正交基，选择$m$个不同的行以形成一个随机的$m \\times n$部分标准正交矩阵，然后应用形式为$1 + \\varepsilon \\cdot \\theta_j$的独立乘性列缩放（其中每个$\\theta_j$在$\\left[-1,1\\right]$内），以引入列归一化误差。所有随机性必须由一个提供的整数种子控制，以保证可复现性。\n2. 通过将每对成对内积除以相应列范数的乘积，并取所有不同列对的最大绝对值，来计算经验相互相干性$\\mu$。\n3. 计算作为$m$和$n$的函数的韦尔奇下界，并与$\\mu$一同报告。同时报告在标准数值容差范围内，$\\mu$是否大于或等于韦尔奇界。\n4. 通过穷举所有大小为$s$的列子集，形成它们的格拉姆矩阵，并取所有子集中特征值与$1$的最大绝对偏差，来计算精确的限制等距常数$\\delta_s$。这等价于在所有支撑集大小为$s$的单位向量上优化二次型，但必须通过子集穷举和特征值计算来执行，以确保精确性。\n5. 仅使用可直接计算的矩阵量，计算$\\delta_s$的两个基于盖尔什戈林定理的上界：\n   - 一个基于相干性的界，通过将盖尔什戈林定理应用于单位归一化列的格拉姆矩阵推导得出，从而得到一个用相互相干性表示的、依赖于$s$的界。\n   - 一个从未归一化的格拉姆矩阵推导出的界，该界同时包含了由列归一化误差引起的对角线元素与1的偏差，以及对非对角线元素幅值的统一界。\n6. 将精确的$\\delta_s$与每个界进行比较，并报告在数值容差范围内，每个界是否为精确值的上界。\n\n您的程序必须使用以下测试套件。对于每个元组，其条目为$(\\text{seed}, n, m, s, \\varepsilon)$:\n- $(123, 16, 8, 3, 0.05)$: 一个平衡的中等规模案例，用于测试典型行为。\n- $(456, 18, 15, 4, 0.10)$: 一个$m$接近$n$的案例，用于测试较小的韦尔奇界和中等归一化误差的影响。\n- $(789, 14, 7, 1, 0.20)$: 一个$s=1$的边界案例，用于分离出对角线元素与1的偏差。\n\n最终输出要求：\n- 对于每个测试用例，按以下顺序输出一个包含八个条目的列表：\n  1. 经验相互相干性$\\mu$，浮点数。\n  2. 韦尔奇下界，浮点数。\n  3. 一个布尔值，指示在小容差范围内$\\mu$是否大于或等于韦尔奇界。\n  4. 精确的$\\delta_s$，浮点数。\n  5. $\\delta_s$的基于相干性的盖尔什戈林上界，浮点数。\n  6. $\\delta_s$的未归一化的盖尔什戈林上界，浮点数。\n  7. 一个布尔值，指示在小容差范围内精确的$\\delta_s$是否小于或等于基于相干性的界。\n  8. 一个布尔值，指示在小容差范围内精确的$\\delta_s$是否小于或等于未归一化的盖尔什戈林界。\n- 您的程序应生成一行输出，其中包含所有测试用例的结果，格式为列表的列表，精确格式如下：\n  [[case1_entry1,case1_entry2,...,case1_entry8],[case2_entry1,...,case2_entry8],[case3_entry1,...,case3_entry8]]\n\n不涉及物理单位或角度单位。所有计算必须是实值计算。通过在计算精确的限制等距常数时使用精确的子集穷举，以及通过从上述基本概念推导所有报告的界限（不使用捷径或黑箱公式），来确保科学真实性。", "solution": "我们从基本定义和经典定理出发，推导待计算的量以及算法步骤。\n\n令$A \\in \\mathbb{R}^{m \\times n}$表示感知矩阵。令$a_j \\in \\mathbb{R}^m$表示$A$的第$j$列。相互相干性定义为\n$$\n\\mu \\triangleq \\max_{i \\neq j} \\frac{\\left| \\langle a_i, a_j \\rangle \\right|}{\\|a_i\\|_2 \\, \\|a_j\\|_2},\n$$\n即不同列之间最大绝对归一化内积。此量对于各列进行正数缩放是不变的。\n\n韦尔奇界是通过考虑$\\mathbb{R}^m$中的$n$个单位向量、它们对角线元素为1的格拉姆矩阵$G \\in \\mathbb{R}^{n \\times n}$以及与维度$m$相关的弗罗贝尼乌斯范数约束而得出的。具体来说，令$G = X^\\top X$，其中$X \\in \\mathbb{R}^{m \\times n}$的列$x_j$是单位范数向量。$G$的特征值是非负的，总和为$n$，并且由于$\\operatorname{rank}(G) \\le m$，最多有$m$个非零特征值。在所有这样的$G$中，非对角线元素的平方和\n$$\n\\sum_{i \\ne j} G_{ij}^2 = \\|G\\|_F^2 - \\operatorname{trace}(G^2) \\quad \\text{(已减去对角线元素)},\n$$\n在非零特征值相等时达到最小值，这是由凸性和对称性决定的。这产生了关于最大非对角线幅值的经典韦尔奇下界。具体到当前情况，对于$\\mathbb{R}^m$中的$n$个单位向量，其相互相干性服从\n$$\n\\mu \\ge \\sqrt{\\frac{n - m}{m (n - 1)}}.\n$$\n在我们的计算中，$A$的列在行选择和缩放后通常不是单位范数，但如上定义的相互相干性适当地归一化了内积，所以我们将经验$\\mu$与这个通用下界进行比较。\n\n$s$阶限制等距常数（RIC），记为$\\delta_s$，通过以下不等式定义：\n$$\n(1 - \\delta_s) \\, \\|x\\|_2^2 \\le \\|A x\\|_2^2 \\le (1 + \\delta_s) \\, \\|x\\|_2^2\n\\quad \\text{对于所有$s$-稀疏向量 $x \\in \\mathbb{R}^n$}.\n$$\n等价地，对于每个子集$S \\subset \\{1,\\dots,n\\}$且$|S| = s$，令$A_S$表示由$S$索引的列组成的$m \\times s$子矩阵，令$G_S = A_S^\\top A_S$为其格拉姆矩阵，我们有\n$$\n\\lambda_{\\min}(G_S) \\ge 1 - \\delta_s, \\quad \\lambda_{\\max}(G_S) \\le 1 + \\delta_s,\n$$\n因此\n$$\n\\delta_s = \\max_{|S|=s} \\max \\left\\{ 1 - \\lambda_{\\min}(G_S), \\, \\lambda_{\\max}(G_S) - 1 \\right\\}.\n$$\n所以，精确的$\\delta_s$可以通过穷举所有大小为$s$的子集$S$，计算$G_S$的极端特征值，并汇总它们与$1$的最坏情况偏差来计算。\n\n为了从第一性原理获得$\\delta_s$的易于处理的上界，我们使用盖尔什戈林圆盘定理。对于任意实对称矩阵$M$，每个特征值至少位于一个形如$[M_{ii} - R_i, M_{ii} + R_i]$的区间内，其中$R_i = \\sum_{j \\ne i} |M_{ij}|$是绝对行和半径。将此应用于$G_S$，对于每个$i \\in S$，可得\n$$\n\\lambda \\in \\left[ (G_S)_{ii} - \\sum_{j \\in S, j \\ne i} |(G_S)_{ij}|, \\, (G_S)_{ii} + \\sum_{j \\in S, j \\ne i} |(G_S)_{ij}| \\right].\n$$\n令$d_j = \\|a_j\\|_2^2 = G_{jj}$，令$\\nu = \\max_{i \\ne j} |G_{ij}|$。那么，对所有$|S|=s$的$S$和所有$i \\in S$统一地，我们得到\n$$\n\\lambda \\in \\left[ d_i - (s - 1) \\nu, \\, d_i + (s - 1) \\nu \\right].\n$$\n由此得出，任何此类特征值与$1$的偏差有界于\n$$\n| \\lambda - 1 | \\le | d_i - 1 | + (s - 1) \\nu.\n$$\n对$i$和$S$取最大值，得到未归一化的盖尔什戈林界\n$$\n\\delta_s \\le \\alpha + (s - 1) \\nu, \\quad \\text{其中 } \\alpha \\triangleq \\max_j | d_j - 1 |, \\;\\; \\nu \\triangleq \\max_{i \\ne j} | G_{ij} |.\n$$\n\n此外，如果所有列都被归一化为单位范数，使得对所有$j$都有$d_j=1$，那么$G_{ij}$等于归一化内积。在这种情况下，通过使用相互相干性来界定行和，\n$$\n\\sum_{j \\in S, j \\ne i} | G_{ij} | \\le (s - 1) \\mu,\n$$\n因此$G_S$的特征值位于$[1 - (s - 1) \\mu, \\, 1 + (s - 1) \\mu]$内，这蕴含了基于相干性的盖尔什戈林界\n$$\n\\delta_s \\le (s - 1) \\mu.\n$$\n在我们的设定中，实际矩阵$A$存在列归一化误差；因此，未归一化的盖尔什戈林界直接适用于$A$，而基于相干性的界对应于其列被单独归一化为单位范数的矩阵。因此，基于相干性的界可能会低估未归一化矩阵$A$的真实RIC，而未归一化的盖尔什戈林界保证是真实RIC的上界。\n\n算法设计：\n1. 随机部分标准正交构造：通过对高斯随机矩阵进行QR分解并校正列符号以使分布均匀，生成一个哈尔分布的正交矩阵$Q \\in \\mathbb{R}^{n \\times n}$。选择$m$个不同的行形成$A_0 \\in \\mathbb{R}^{m \\times n}$。\n2. 列归一化误差：抽取独立的缩放因子$s_j \\in [1 - \\varepsilon, 1 + \\varepsilon]$并设置$A = A_0 \\, \\mathrm{diag}(s)$。\n3. 相互相干性：计算格拉姆矩阵$G = A^\\top A$和列范数$d_j = G_{jj}$；然后计算归一化成对相关性$G_{ij}/\\sqrt{d_i d_j}$并取最大绝对非对角线值。\n4. 韦尔奇界：根据$m$和$n$计算下界。\n5. 精确RIC：穷举所有$\\binom{n}{s}$个大小为$s$的支撑集$S$，计算$G_S$及其极端特征值，并累积与$1$的最大偏差。\n6. 盖尔什戈林界：计算$\\alpha = \\max_j |d_j - 1|$、$\\nu = \\max_{i \\ne j} |G_{ij}|$，并构成$\\alpha + (s - 1)\\nu$；同时计算$(s - 1)\\mu$。\n7. 容差检查：用一个小的非负容差测试$\\mu$与韦尔奇界以及$\\delta_s$与每个盖尔什戈林界，以考虑浮点运算。\n\n测试套件覆盖：\n- 维度适中且缩放误差较小的典型情况。\n- $m$接近$n$的情况，此时韦尔奇下界很小，缩放误差适中。\n- $s = 1$的边界情况，此时RIC简化为最大对角线偏差，从而分离出列归一化误差的影响。\n\n程序打印单行：一个列表，其中为每个测试用例包含一个按指定顺序排列的八个条目的列表。所有报告的量都直接根据上述定义和盖尔什戈林定理推导得出，精确的RIC通过带有特征值计算的穷举子集枚举获得。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to execute the analysis for all test cases and print the results.\n    \"\"\"\n    test_suite = [\n        # (seed, n, m, s, eps)\n        (123, 16, 8, 3, 0.05),\n        (456, 18, 15, 4, 0.10),\n        (789, 14, 7, 1, 0.20),\n    ]\n    all_results = [process_case(*params) for params in test_suite]\n    # Format output as a list of lists with no spaces, as requested.\n    results_as_strings = [str(r).replace(\" \", \"\") for r in all_results]\n    print(f\"[{','.join(results_as_strings)}]\")\n\ndef haar_orthogonal(n: int, rng: np.random.Generator) -> np.ndarray:\n    \"\"\"\n    Generates a Haar-distributed orthogonal matrix Q in R^{n x n}.\n    \"\"\"\n    X = rng.standard_normal((n, n))\n    Q, R = np.linalg.qr(X)\n    d = np.sign(np.diag(R))\n    d[d == 0] = 1.0\n    Q = Q @ np.diag(d)\n    return Q\n\ndef process_case(seed: int, n: int, m: int, s: int, eps: float) -> list:\n    \"\"\"\n    Processes a single test case according to the problem specification.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    tol = 1e-9\n\n    # 1. Construct the matrix A\n    Q_haar = haar_orthogonal(n, rng)\n    row_indices = rng.choice(n, size=m, replace=False)\n    A_partial = Q_haar[row_indices, :]\n    theta = rng.uniform(-1.0, 1.0, size=n)\n    scaling_factors = 1 + eps * theta\n    A = A_partial * scaling_factors\n\n    # 2. Compute empirical mutual coherence (mu)\n    G = A.T @ A\n    col_norms = np.linalg.norm(A, axis=0)\n    mu_val = 0.0\n    if n > 1:\n        norm_prod = np.outer(col_norms, col_norms)\n        # Avoid division by zero for zero-norm columns\n        valid_mask = norm_prod > tol\n        coherence_matrix = np.zeros_like(G)\n        coherence_matrix[valid_mask] = np.abs(G[valid_mask]) / norm_prod[valid_mask]\n        np.fill_diagonal(coherence_matrix, 0)\n        mu_val = np.max(coherence_matrix)\n\n    # 3. Compute Welch bound\n    welch_bound = 0.0\n    if n > m:\n        welch_bound = np.sqrt((n - m) / (m * (n - 1)))\n    mu_ge_welch = mu_val >= welch_bound - tol\n\n    # 4. Compute exact delta_s\n    delta_s_exact = 0.0\n    if s > 0 and n >= s:\n        max_dev = 0.0\n        for subset_indices in combinations(range(n), s):\n            G_S = A[:, subset_indices].T @ A[:, subset_indices]\n            try:\n                eigvals = np.linalg.eigvalsh(G_S)\n                dev = np.max(np.abs(eigvals - 1))\n                if dev > max_dev:\n                    max_dev = dev\n            except np.linalg.LinAlgError:\n                # In case of numerical instability, we might get an error.\n                # For this problem's scope, we assume matrices are well-behaved.\n                pass\n        delta_s_exact = max_dev\n\n    # 5. Compute Gershgorin-based bounds for delta_s\n    # Coherence-based bound (for normalized matrix)\n    delta_s_coherence_bound = (s - 1) * mu_val if s > 1 else 0.0\n\n    # Unnormalized bound (for the actual matrix A)\n    diag_dev = np.max(np.abs(np.diag(G) - 1))\n    if s == 1:\n        delta_s_unnormalized_bound = diag_dev\n    else:\n        off_diag_abs = np.abs(G)\n        np.fill_diagonal(off_diag_abs, 0)\n        max_off_diag = np.max(off_diag_abs) if n > 1 else 0.0\n        delta_s_unnormalized_bound = diag_dev + (s - 1) * max_off_diag\n\n    # 6. Compare exact delta_s with bounds\n    delta_s_le_coh = delta_s_exact = delta_s_coherence_bound + tol\n    delta_s_le_unnorm = delta_s_exact = delta_s_unnormalized_bound + tol\n\n    return [\n        float(mu_val),\n        float(welch_bound),\n        bool(mu_ge_welch),\n        float(delta_s_exact),\n        float(delta_s_coherence_bound),\n        float(delta_s_unnormalized_bound),\n        bool(delta_s_le_coh),\n        bool(delta_s_le_unnorm)\n    ]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3434936"}, {"introduction": "一旦我们拥有了分析给定传感矩阵的工具，下一个合乎逻辑的步骤就是探究我们是否能改善其性质。本练习 [@problem_id:3434906] 探讨了一种直接且直观的字典设计策略：贪婪列剪枝。你将实现一种算法，该算法策略性地移除“最差”的列——即那些对高相干性贡献最大的列——并量化其影响。这个练习展示了主动的设计选择如何增强字典性能，从而为正交匹配追踪（OMP）等贪婪算法带来更强的理论恢复保证。", "problem": "您的任务是定量评估从一个近等角紧框架（near-ETF）类型的传感矩阵中移除固定数量的列，如何影响压缩感知和稀疏优化中基于相干性的关键恢复保证。请严格在纯数学设置下进行，处理实数矩阵，不涉及物理单位。所有角度均与此问题无关。\n\n从以下基本概念出发：\n- 互相关性、格拉姆矩阵、受限等距常数和支撑集限制子矩阵的定义。\n- 单位范数框架的相干性韦尔奇界。\n- 格申高林圆盘定理。\n- 基于互相关性的正交匹配追踪（OMP）算法精确恢复的经典充分条件，其中正交匹配追踪（OMP）是一种用于稀疏恢复的贪婪算法。\n\n您的程序必须为每个测试用例实现以下步骤：\n1. 按如下方式构造一个维度为 $m \\times n$ 的实数传感矩阵。生成一个元素服从独立标准正态分布的矩阵，并将每一列归一化为单位 $\\ell_2$-范数。这样构造了一个随机的近ETF，其意义在于对于给定的 $(m,n)$，它的互相关性接近于最小值，但不一定等于韦尔奇界。\n2. 计算互相关性 $\\mu$，其值为列归一化传感矩阵的格拉姆矩阵中非对角元素绝对值的最大值。\n3. 仅使用基本结果，推导并计算：\n   - 由韦尔奇定理预测的、针对给定 $(m,n)$ 的 $\\mu$ 的下界。\n   - 基于应用于格拉姆矩阵的 $s \\times s$ 主子矩阵的格申高林圆盘定理，得到的受限等距常数 $\\delta_s$ 的上界。\n   - 保证基于互相关性的OMP成功恢复的最大稀疏度 $s_{\\text{OMP}}$，纯粹以 $\\mu$ 表示。\n4. 通过移除 $k$ 个对相干性最有害（因此对基于格申高林界的约束最不利）的列来进行列剪枝，使用以下贪婪规则：在每一步剪枝中，为每一列 $j$ 计算其与所有其他列的内积绝对值之和（对 $i \\neq j$ 求和），并移除该和最大的列。移除一列后，在缩减后的矩阵上重新计算这些和，并重复此过程，直到移除 $k$ 列。用 $n' = n - k$ 表示剪枝后的列数。\n5. 对剪枝后的矩阵重新计算第2步和第3步中的所有量。\n6. 对于一个预设的固定稀疏度 $s$，通过比较 $s$ 与剪枝前后的 $s_{\\text{OMP}}$，判断OMP成功保证在剪枝前后是否得到满足。\n\n限制与约定：\n- 所有列都被归一化为单位 $\\ell_2$-范数。\n- 格拉姆矩阵必须根据构造的传感矩阵精确计算。\n- 如果 $n \\le m$，$\\mu$ 的韦尔奇下界应取为 $0$。\n- 在所有测试用例中，保证稀疏度 $s$ 在剪枝后满足 $s \\le n'$。\n- 对于每个测试用例，给定种子随机数生成器后，所有计算都是确定性的。\n- 对于所有浮点输出，使用标准四舍五入精确到小数点后六位。\n\n测试套件：\n对以下每个参数元组 $(m,n,k,s,\\text{seed})$，执行上述过程：\n- 测试用例 A: $(m,n,k,s,\\text{seed}) = (30,60,10,4,1)$。\n- 测试用例 B: $(m,n,k,s,\\text{seed}) = (40,80,0,6,2)$。\n- 测试用例 C: $(m,n,k,s,\\text{seed}) = (20,100,40,8,3)$。\n- 测试用例 D: $(m,n,k,s,\\text{seed}) = (50,55,4,3,4)$。\n- 测试用例 E: $(m,n,k,s,\\text{seed}) = (30,90,20,10,5)$。\n\n对于每个测试用例，您的程序必须按以下顺序输出一个列表：\n- 剪枝前的互相关性 $\\mu$，作为浮点数，四舍五入到六位小数。\n- 剪枝后的互相关性 $\\mu'$，作为浮点数，四舍五入到六位小数。\n- 剪枝前基于格申高林圆盘的 $\\delta_s$ 上界，作为浮点数，四舍五入到六位小数。\n- 剪枝后基于格申高林圆盘的 $\\delta_s$ 上界，作为浮点数，四舍五入到六位小数。\n- 剪枝前保证OMP成功的最大稀疏度 $s_{\\text{OMP}}$，作为整数。\n- 剪枝后保证OMP成功的最大稀疏度 $s_{\\text{OMP}}'$，作为整数。\n- 表示剪枝前固定稀疏度 $s$ 是否满足OMP保证的布尔值。\n- 表示剪枝后固定稀疏度 $s$ 是否满足OMP保证的布尔值。\n- 剪枝前 $\\mu$ 的韦尔奇下界，作为浮点数，四舍五入到六位小数。\n- 剪枝后 $\\mu$ 的韦尔奇下界，作为浮点数，四舍五入到六位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由每个测试用例的列表组成的逗号分隔列表，并用方括号括起来。例如，一个有效的输出格式为 \"[[case1_values...],[case2_values...],...]\"，不含空格。每个内部列表必须严格遵循上述指定的顺序。不得打印任何其他文本。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于压缩感知和稀疏优化的原理，问题提法得当，算法流程清晰，表述客观。所有必要的数据和定义都已提供，不存在内部矛盾或含糊之处。\n\n任务是分析一种特定的贪婪列剪枝策略对传感矩阵基于相干性的恢复保证的影响。对于由参数 $(m, n, k, s, \\text{seed})$ 指定的每个测试用例，我们将在对矩阵进行剪枝前后执行一系列计算。\n\n**1. 传感矩阵构造**\n\n首先，构造一个传感矩阵 $\\mathbf{A} \\in \\mathbb{R}^{m \\times n}$。其元素独立地从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取。随后，它的 $n$ 个列（记为 $\\mathbf{a}_i$，其中 $i \\in \\{1, \\dots, n\\}$）中的每一列都被归一化为单位欧几里得范数（$\\ell_2$-范数）：\n$$\n\\|\\mathbf{a}_i\\|_2 = 1 \\quad \\forall i \\in \\{1, \\dots, n\\}\n$$\n这个过程产生一个随机矩阵，其列构成一个单位范数框架。然后计算格拉姆矩阵 $\\mathbf{G} \\in \\mathbb{R}^{n \\times n}$，即 $\\mathbf{G} = \\mathbf{A}^T\\mathbf{A}$。格拉姆矩阵的元素是矩阵 $\\mathbf{A}$ 的列之间的内积：$G_{ij} = \\langle \\mathbf{a}_i, \\mathbf{a}_j \\rangle$。由于列归一化，$\\mathbf{G}$ 的对角线元素都为1，$G_{ii} = \\|\\mathbf{a}_i\\|_2^2 = 1$。非对角线元素量化了不同列之间的相关性。\n\n**2. 剪枝前基于相干性的保证分析**\n\n在移除任何列之前，我们根据初始矩阵 $\\mathbf{A}$ 计算几个关键指标。\n\n*   **互相关性 ($\\mu$):** $\\mathbf{A}$ 的互相关性是其格拉姆矩阵非对角线元素绝对值的最大值。它衡量任意两个不同列之间的最差情况相关性。\n    $$\n    \\mu = \\mu(\\mathbf{A}) = \\max_{i \\neq j} |\\langle \\mathbf{a}_i, \\mathbf{a}_j \\rangle| = \\max_{i \\neq j} |G_{ij}|\n    $$\n*   **韦尔奇界 ($\\mu_W$):** 该定理为 $\\mathbb{R}^m$ 中任意具有 $n$ 个单位范数向量的框架的互相关性提供了一个基本下界。对于 $n  m$，该界由以下公式给出：\n    $$\n    \\mu_W = \\sqrt{\\frac{n-m}{m(n-1)}}\n    $$\n    对于 $n \\le m$ 的情况，问题指定使用 $\\mu_W = 0$。达到此界的矩阵称为等角紧框架（ETF）。所构造的随机矩阵预期是一个近ETF，意味着其相干性 $\\mu$ 将接近 $\\mu_W$。\n*   **基于格申高林圆盘的受限等距常数 ($\\delta_s$) 界：** 受限等距性质（RIP）是恢复保证的核心概念。如果对于任意 $s$-稀疏向量 $\\mathbf{x}$，都有 $(1-\\delta_s)\\|\\mathbf{x}\\|_2^2 \\le \\|\\mathbf{A}\\mathbf{x}\\|_2^2 \\le (1+\\delta_s)\\|\\mathbf{x}\\|_2^2$ 成立，则称矩阵 $\\mathbf{A}$ 具有阶数为 $s$、常数为 $\\delta_s$ 的RIP。这等价于要求格拉姆矩阵 $\\mathbf{G}$ 的任意 $s \\times s$ 主子矩阵 $\\mathbf{G}_S$ 的所有特征值都位于区间 $[1-\\delta_s, 1+\\delta_s]$ 内。格申高林圆盘定理指出，$\\mathbf{G}_S$ 的每个特征值都位于以其对角线元素为中心的圆盘并集之内。由于 $(\\mathbf{G}_S)_{ii}=1$，特征值 $\\lambda$ 必须满足 $|\\lambda - 1| \\le \\max_{i \\in S} \\sum_{j \\in S, j \\neq i} |G_{ij}|$。该和的上界为 $(s-1)\\mu$。这给出了 $\\delta_s$ 的一个简单上界：\n    $$\n    \\delta_s \\le (s-1)\\mu\n    $$\n    我们为预设的稀疏度 $s$ 计算这个值，$\\delta_{s, \\text{Gersh}} = (s-1)\\mu$。\n*   **OMP恢复保证 ($s_{\\text{OMP}}$):** 正交匹配追踪（OMP）是一种贪婪算法，只要稀疏度 $s$ 满足以下条件，它就能保证从测量值 $\\mathbf{y} = \\mathbf{A}\\mathbf{x}$ 中完美恢复任何 $s$-稀疏信号 $\\mathbf{x}$：\n    $$\n    s  \\frac{1}{2}\\left(1 + \\frac{1}{\\mu}\\right)\n    $$\n    我们计算保证成立的最大整数稀疏度 $s_{\\text{OMP}}$。这是严格小于该界的最大整数：\n    $$\n    s_{\\text{OMP}} = \\left\\lceil \\frac{1}{2}\\left(1 + \\frac{1}{\\mu}\\right) \\right\\rceil - 1\n    $$\n\n**3. 贪婪列剪枝**\n\n该过程涉及使用贪婪策略从 $\\mathbf{A}$ 中移除 $k$ 个列。目标是移除那些“对相干性最有害”的列。这被解释为移除与所有其他列的总绝对相关性最高的列。在 $k$ 个剪枝步骤的每一步中，我们执行以下操作：\n1.  对于当前具有列 $\\{\\mathbf{a}_j\\}$ 的矩阵，计算每一列 $j$ 的“相干性贡献”：$c_j = \\sum_{i \\neq j} |\\langle \\mathbf{a}_i, \\mathbf{a}_j \\rangle|$。\n2.  识别使该和最大化的列索引 $j^*$：$j^* = \\arg\\max_j c_j$。\n3.  从矩阵中移除列 $\\mathbf{a}_{j^*}$。\n\n这个过程重复 $k$ 次，使列数从 $n$ 减少到 $n' = n-k$。将得到的剪枝后矩阵记为 $\\mathbf{A}'$。\n\n**4. 剪枝后分析**\n\n剪枝后，我们得到矩阵 $\\mathbf{A}' \\in \\mathbb{R}^{m \\times n'}$。对这个新矩阵重新评估第2步中计算的所有量：\n*   剪枝后互相关性，$\\mu' = \\mu(\\mathbf{A}')$。\n*   剪枝后韦尔奇界，$\\mu'_W$，使用维度 $n'$ 计算。\n*   剪枝后基于格申高林圆盘的 $\\delta_s$ 界，即 $\\delta'_{s, \\text{Gersh}} = (s-1)\\mu'$。\n*   剪枝后保证OMP成功的最大稀疏度，$s'_{\\text{OMP}}$，使用 $\\mu'$ 计算。\n\n**5. OMP保证判定**\n\n最后，对于预设的固定稀疏度 $s$，我们判断OMP成功保证在剪枝前后是否得到满足。这涉及两个布尔检查：\n1.  **剪枝前：** $s  \\frac{1}{2}\\left(1 + \\frac{1}{\\mu}\\right)$ 是否成立？\n2.  **剪枝后：** $s  \\frac{1}{2}\\left(1 + \\frac{1}{\\mu'}\\right)$ 是否成立？\n\n对于每个测试用例，这些步骤生成所需的十个输出值：$\\mu$、$\\mu'$、$\\delta_{s, \\text{Gersh}}$、$\\delta'_{s, \\text{Gersh}}$、$s_{\\text{OMP}}$、$s'_{\\text{OMP}}$、两个布尔值、$\\mu_W$ 和 $\\mu'_W$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the analysis for all test cases.\n    \"\"\"\n    test_cases = [\n        # (m, n, k, s, seed)\n        (30, 60, 10, 4, 1),\n        (40, 80, 0, 6, 2),\n        (20, 100, 40, 8, 3),\n        (50, 55, 4, 3, 4),\n        (30, 90, 20, 10, 5),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        m, n, k, s, seed = case\n        result = process_case(m, n, k, s, seed)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists, with no spaces.\n    results_as_strings = [str(r).replace(\" \", \"\") for r in all_results]\n    print(f\"[{','.join(results_as_strings)}]\")\n\ndef process_case(m, n, k, s, seed):\n    \"\"\"\n    Processes a single test case according to the problem specification.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # 1. Construct the sensing matrix\n    A = rng.standard_normal((m, n))\n    A /= np.linalg.norm(A, axis=0, keepdims=True)\n\n    # 2. Pre-pruning analysis\n    mu_pre, delta_s_bound_pre, s_omp_pre, omp_guarantee_pre, welch_pre = analyze_matrix(A, s)\n\n    # 4. Perform column pruning\n    A_pruned = A.copy()\n    for _ in range(k):\n        # Ensure there are columns to prune\n        if A_pruned.shape[1] = 1:\n            break\n        \n        # Compute Gram matrix for the current matrix\n        G_prune = A_pruned.T @ A_pruned\n        np.fill_diagonal(G_prune, 0)\n        \n        # Find the column that maximizes the sum of absolute inner products\n        # with other columns.\n        coherence_sums = np.sum(np.abs(G_prune), axis=1)\n        idx_to_remove = np.argmax(coherence_sums)\n        \n        # Remove the identified column\n        A_pruned = np.delete(A_pruned, idx_to_remove, axis=1)\n    \n    # 5. Post-pruning analysis\n    if k == 0:\n        # If no pruning was done, post-pruning metrics are identical to pre-pruning.\n        mu_post = mu_pre\n        delta_s_bound_post = delta_s_bound_pre\n        s_omp_post = s_omp_pre\n        omp_guarantee_post = omp_guarantee_pre\n        welch_post = welch_pre\n    else:\n        mu_post, delta_s_bound_post, s_omp_post, omp_guarantee_post, welch_post = analyze_matrix(A_pruned, s)\n\n    # 6. Format and return results\n    return [\n        round(mu_pre, 6),\n        round(mu_post, 6),\n        round(delta_s_bound_pre, 6),\n        round(delta_s_bound_post, 6),\n        int(s_omp_pre),\n        int(s_omp_post),\n        omp_guarantee_pre,\n        omp_guarantee_post,\n        round(welch_pre, 6),\n        round(welch_post, 6)\n    ]\n\ndef analyze_matrix(A, s):\n    \"\"\"\n    Computes all required metrics for a given sensing matrix A and sparsity s.\n    \"\"\"\n    m, n = A.shape\n\n    if n = 1:\n        # Trivial case with 0 or 1 columns: coherence is 0.\n        mu = 0.0\n        delta_s_bound = 0.0\n        # OMP bound is infinite, so s_omp is effectively infinite. Use a large integer.\n        s_omp = 2**31 - 1\n        omp_guarantee = True\n        welch = 0.0\n        return mu, delta_s_bound, s_omp, omp_guarantee, welch\n\n    # Compute Gram matrix and mutual coherence\n    G = A.T @ A\n    np.fill_diagonal(G, 0)\n    mu = np.max(np.abs(G))\n\n    # Welch bound\n    if n > m:\n        welch = np.sqrt((n - m) / (m * (n - 1)))\n    else:\n        welch = 0.0\n\n    # Gershgorin-based upper bound on RIC\n    delta_s_bound = (s - 1) * mu\n\n    # OMP success guarantee\n    if mu == 0:\n        s_omp = 2**31 - 1\n        omp_guarantee = True\n    else:\n        omp_bound = 0.5 * (1 + 1 / mu)\n        # s_OMP is the largest integer s' such that s'  omp_bound.\n        s_omp = np.ceil(omp_bound) - 1\n        # Check if the specific sparsity s meets the guarantee.\n        omp_guarantee = (s  omp_bound)\n    \n    return mu, delta_s_bound, s_omp, omp_guarantee, welch\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3434906"}]}