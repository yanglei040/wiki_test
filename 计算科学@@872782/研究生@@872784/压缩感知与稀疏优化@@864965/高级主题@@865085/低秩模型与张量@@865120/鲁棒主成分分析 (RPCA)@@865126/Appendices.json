{"hands_on_practices": [{"introduction": "稳健主成分分析的许多算法依赖于求解两个核心的近端算子（proximal operator）。对于低秩分量，最关键的算子是奇异值阈值（Singular Value Thresholding, SVT）算子。这个练习要求你从核范数（nuclear norm）的近端算子的基本定义出发，推导出SVT算子的形式，从而揭示其内在机理。通过这个从第一性原理出发的推导，你将深刻理解为什么收缩奇异值是在此优化框架下促进矩阵低秩性的正确方法。[@problem_id:3474854]", "problem": "考虑典型的鲁棒主成分分析（RPCA）分解模型，该模型通过凸优化寻求一个低秩矩阵和一个稀疏矩阵。更新低秩分量的标准近端步骤使用核范数的近端算子。令核范数定义为 $\\|X\\|_{*} = \\sum_{i} \\sigma_{i}(X)$，其中 $\\sigma_{i}(X)$ 是矩阵 $X$ 的奇异值。一个正常、下半连续、凸函数 $f$ 在点 $Y$ 处的近端算子定义为 $\\operatorname{prox}_{f}(Y) = \\arg\\min_{X} \\left\\{ f(X) + \\tfrac{1}{2}\\|X - Y\\|_{F}^{2} \\right\\}$，其中 $\\|\\cdot\\|_{F}$ 表示弗罗贝尼乌斯范数。在 RPCA 的低秩更新中，使用缩放核范数 $f(X) = \\tau \\|X\\|_{*}$ 的近端算子，其中 $\\tau > 0$ 是一个阈值参数。\n\n仅从这些基本定义出发，结合弗罗贝尼乌斯范数和核范数的酉不变性，推导由 $\\operatorname{prox}_{\\tau \\|\\cdot\\|_{*}}(Y)$（也称为奇异值阈值（SVT）算子，首次使用时定义此缩写）对奇异值引起的变换。然后，将您的推导应用于一个矩阵 $Y$，其奇异值分解（SVD）为 $Y = U \\Sigma V^{\\top}$，奇异值为 $(\\sigma_{1}, \\sigma_{2}, \\sigma_{3}) = (5, 3, 0)$，并使用阈值 $\\tau = 2$。计算近端点 $L^{\\star} = \\operatorname{prox}_{\\tau \\|\\cdot\\|_{*}}(Y)$ 的奇异值和 $L^{\\star}$ 的秩。\n\n将您的最终答案表示为单个表达式，列出 $L^{\\star}$ 的按非递增顺序排列的奇异值，后跟 $L^{\\star}$ 的秩。无需四舍五入，不涉及物理单位。", "solution": "该问题是有效的，因为它具有科学依据、良定且客观。它包含凸优化和矩阵分析领域内的标准推导和应用。所有必要的定义和数据均已提供。\n\n任务是推导缩放核范数的近端算子，并将其应用于特定矩阵。函数 $f(X) = \\tau \\|X\\|_{*}$ 的近端算子定义为以下优化问题的解：\n$$\nL^{\\star} = \\operatorname{prox}_{\\tau \\|\\cdot\\|_{*}}(Y) = \\arg\\min_{X} \\left\\{ \\tau \\|X\\|_{*} + \\tfrac{1}{2}\\|X - Y\\|_{F}^{2} \\right\\}\n$$\n其中 $\\|X\\|_{*} = \\sum_{i} \\sigma_{i}(X)$ 是核范数，$\\sigma_i(X)$ 是 $X$ 的奇异值，而 $\\|A\\|_{F} = \\sqrt{\\sum_{i,j} |A_{ij}|^2} = \\sqrt{\\operatorname{Tr}(A^{\\top}A)}$ 是弗罗贝尼乌斯范数。\n\n设矩阵 $Y \\in \\mathbb{R}^{m \\times n}$ 的奇异值分解（SVD）为 $Y = U \\Sigma_Y V^{\\top}$，其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是酉矩阵，$\\Sigma_Y$ 是一个大小为 $m \\times n$ 的矩形对角矩阵，其非负对角线元素 $\\sigma_i(Y)$（即 $Y$ 的奇异值）按非递增顺序排列。\n\n目标函数可以展开为：\n$$\nJ(X) = \\tau \\|X\\|_{*} + \\tfrac{1}{2} \\left( \\|X\\|_{F}^{2} - 2\\langle X, Y \\rangle_F + \\|Y\\|_{F}^{2} \\right)\n$$\n其中 $\\langle X, Y \\rangle_F = \\operatorname{Tr}(X^{\\top}Y)$ 是弗罗贝尼乌斯内积。项 $\\|Y\\|_{F}^{2}$ 相对于 $X$ 是一个常数，在最小化过程中可以忽略。范数可以用奇异值表示：$\\|X\\|_{*} = \\sum_i \\sigma_i(X)$ 和 $\\|X\\|_{F}^{2} = \\sum_i \\sigma_i(X)^2$。该问题等价于最小化：\n$$\n\\tilde{J}(X) = \\tau \\sum_i \\sigma_i(X) + \\tfrac{1}{2} \\sum_i \\sigma_i(X)^2 - \\operatorname{Tr}(X^{\\top}Y)\n$$\n冯·诺依曼迹不等式指出，对于任意两个矩阵 $A$ 和 $B$，$\\operatorname{Tr}(A^{\\top}B) \\le \\sum_i \\sigma_i(A)\\sigma_i(B)$。当 $A$ 和 $B$ 共享相同的奇异向量时，即对于某些酉矩阵 $U$ 和 $V$，有 $A = U\\Sigma_A V^{\\top}$ 和 $B = U\\Sigma_B V^{\\top}$ 时，等号成立。为了最小化 $\\tilde{J}(X)$，我们必须最大化项 $\\operatorname{Tr}(X^{\\top}Y)$。根据 von Neumann 不等式，当 $X$ 与 $Y$ 具有相同的奇异向量时，达到这个最大值。因此，我们寻求形式为 $X = U \\Sigma_X V^{\\top}$ 的解，其中 $U$ 和 $V$ 是来自 $Y$ 的奇异值分解的奇异向量矩阵。\n\n使用弗罗贝尼乌斯范数的酉不变性，项 $\\|X - Y\\|_{F}^{2}$ 可以简化为：\n$$\n\\|X - Y\\|_{F}^{2} = \\|U \\Sigma_X V^{\\top} - U \\Sigma_Y V^{\\top}\\|_{F}^{2} = \\|U(\\Sigma_X - \\Sigma_Y)V^{\\top}\\|_{F}^{2} = \\|\\Sigma_X - \\Sigma_Y\\|_{F}^{2}\n$$\n由于 $\\Sigma_X$ 和 $\\Sigma_Y$ 是对角矩阵，其对角线元素分别为 $\\sigma_i(X)$ 和 $\\sigma_i(Y)$，这变为：\n$$\n\\|\\Sigma_X - \\Sigma_Y\\|_{F}^{2} = \\sum_i (\\sigma_i(X) - \\sigma_i(Y))^2\n$$\n$X$ 的核范数是 $\\|X\\|_{*} = \\sum_i \\sigma_i(X)$。\n将这些代入原始优化问题，我们现在对奇异值 $\\sigma_i(X)$ 进行最小化：\n$$\n\\min_{\\{\\sigma_i(X) \\ge 0\\}} \\left\\{ \\tau \\sum_i \\sigma_i(X) + \\tfrac{1}{2} \\sum_i (\\sigma_i(X) - \\sigma_i(Y))^2 \\right\\}\n$$\n这个问题是可分的，意味着我们可以独立地求解每个 $\\sigma_i(X)$。对于每个 $i$，我们求解：\n$$\n\\min_{\\sigma \\ge 0} \\left\\{ \\tau \\sigma + \\tfrac{1}{2} (\\sigma - \\sigma_i(Y))^2 \\right\\}\n$$\n令 $g(\\sigma) = \\tau \\sigma + \\tfrac{1}{2} (\\sigma - \\sigma_i(Y))^2$。这是一个凸二次函数。为了找到最小值，我们计算关于 $\\sigma$ 的导数并将其设为零（暂时忽略非负约束）：\n$$\n\\frac{dg}{d\\sigma} = \\tau + (\\sigma - \\sigma_i(Y)) = 0 \\implies \\sigma = \\sigma_i(Y) - \\tau\n$$\n现在，我们必须强制执行约束 $\\sigma \\ge 0$。\n1. 如果 $\\sigma_i(Y) - \\tau > 0$，无约束最小化子是正的，因此它是有效解。最优值为 $\\sigma^{\\star} = \\sigma_i(Y) - \\tau$。\n2. 如果 $\\sigma_i(Y) - \\tau \\le 0$，无约束最小化子是非正的。由于 $g(\\sigma)$ 是一个开口向上、顶点在 $\\sigma_i(Y) - \\tau$ 的抛物线，对于 $\\sigma > \\sigma_i(Y) - \\tau$，该函数是递增的。因此，在定义域 $\\sigma \\ge 0$ 上，最小值在边界处达到，即在 $\\sigma^{\\star} = 0$ 处。\n\n结合这两种情况，每个奇异值的解是：\n$$\n\\sigma_i(L^{\\star}) = \\max(0, \\sigma_i(Y) - \\tau) = (\\sigma_i(Y) - \\tau)_+\n$$\n这个操作被称为软阈值。得到的矩阵 $L^{\\star}$ 是通过将此变换应用于 $Y$ 的奇异值，同时保持奇异向量不变来构造的：\n$$\nL^{\\star} = U \\mathcal{S}_{\\tau}(\\Sigma_Y) V^{\\top}\n$$\n其中 $\\mathcal{S}_{\\tau}(\\Sigma_Y)$ 是对角矩阵，其对角线元素为 $\\max(0, \\sigma_i(Y)-\\tau)$。这个变换称为奇异值阈值（SVT）算子。\n\n现在我们将此结果应用于给定的问题。我们有一个矩阵 $Y$，其奇异值为 $(\\sigma_1, \\sigma_2, \\sigma_3) = (5, 3, 0)$，阈值为 $\\tau = 2$。\n我们使用推导出的规则计算 $L^{\\star} = \\operatorname{prox}_{\\tau \\|\\cdot\\|_{*}}(Y)$ 的奇异值。让我们将 $L^{\\star}$ 的奇异值表示为 $\\sigma_i^{\\star}$。\n\n对于 $\\sigma_1 = 5$：\n$$\n\\sigma_1^{\\star} = \\max(0, 5 - 2) = \\max(0, 3) = 3\n$$\n对于 $\\sigma_2 = 3$：\n$$\n\\sigma_2^{\\star} = \\max(0, 3 - 2) = \\max(0, 1) = 1\n$$\n对于 $\\sigma_3 = 0$：\n$$\n\\sigma_3^{\\star} = \\max(0, 0 - 2) = \\max(0, -2) = 0\n$$\n$L^{\\star}$ 的奇异值按非递增顺序排列为 $(3, 1, 0)$。\n\n矩阵的秩是其非零奇异值的数量。对于 $L^{\\star}$，非零奇异值为 $3$ 和 $1$。有两个这样的值。\n因此，$L^{\\star}$ 的秩为 $2$。\n\n最终答案要求 $L^{\\star}$ 的奇异值和 $L^{\\star}$ 的秩。它们是 $(3, 1, 0)$ 和 $2$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3  1  0  2\n\\end{pmatrix}\n}\n$$", "id": "3474854"}, {"introduction": "在掌握了核心的SVT算子之后，一个自然的问题是：在什么条件下，我们能保证稳健主成分分析（RPCA）能够成功地从损坏的数据中精确地恢复出低秩和稀疏成分？这个练习将引导你应用一项关键的理论恢复保证。通过将具体的问题参数（如矩阵维度、秩、非相干性参数和稀疏度）代入理论不等式，你将学会如何评估一个特定问题是否可能被PCP方法解决，从而在理论和实践之间建立起一座桥梁。[@problem_id:3474843]", "problem": "考虑鲁棒主成分分析（RPCA）模型，其中数据矩阵 $M \\in \\mathbb{R}^{m \\times n}$ 分解为 $M = L_{0} + S_{0}$，其中 $L_{0}$ 是一个低秩矩阵，$S_{0}$ 是一个稀疏矩阵。恢复方法是主成分追踪（PCP），它求解凸规划 $\\min_{L,S} \\|L\\|_{*} + \\lambda \\|S\\|_{1}$，约束条件为 $M = L + S$，正则化参数选择为 $\\lambda = 1/\\sqrt{\\max\\{m,n\\}}$。假设 $m = n$，且 $L_{0}$ 的秩为 $r$，并满足参数为 $\\mu$ 的标准 $\\mu$-非相干模型，而 $S_{0}$ 的支撑集在 $mn$ 个条目上服从稀疏度为 $\\rho$ 的独立同分布伯努利分布。\n\nRPCA 文献中一个广泛使用的充分条件指出，存在绝对常数 $c_{r} > 0$ 和 $c_{\\rho} > 0$，使得只要满足以下条件，PCP 就能以高概率精确地恢复 $(L_{0}, S_{0})$：\n$$\nr \\leq c_{r} \\frac{n}{\\mu (\\ln n)^{2}}\n\\quad \\text{and} \\quad\n\\rho \\leq c_{\\rho}.\n$$\n为了进行保守的数值可行性检查，采用显式常数 $c_{r} = 0.4$ 和 $c_{\\rho} = 0.1$。\n\n对于一个方形实例，其中 $m = n = 100$，秩 $r = 5$，非相干参数 $\\mu = 3$，稀疏度 $\\rho = 0.05$，计算指示符\n$$\nI \\equiv \\mathbf{1}\\!\\left\\{\\, r \\leq c_{r} \\frac{n}{\\mu (\\ln n)^{2}} \\ \\text{and} \\ \\rho \\leq c_{\\rho} \\,\\right\\},\n$$\n其中，如果事件成立，$\\mathbf{1}\\{\\cdot\\}$ 的值为 $1$，否则为 $0$。报告 $I$ 的值作为你的最终答案。无需四舍五入。", "solution": "问题要求计算一个指示函数 $I$，该函数的定义基于一组充分条件的满足情况，这些条件用于从和 $M = L_{0} + S_{0}$ 中精确恢复低秩矩阵 $L_{0}$ 和稀疏矩阵 $S_{0}$。恢复过程使用主成分追踪（PCP）方法。\n\n指示函数的表达式为：\n$$\nI \\equiv \\mathbf{1}\\!\\left\\{\\, r \\leq c_{r} \\frac{n}{\\mu (\\ln n)^{2}} \\ \\text{and} \\ \\rho \\leq c_{\\rho} \\,\\right\\}\n$$\n如果大括号内的两个不等式都成立，则此函数的值为 $1$，否则为 $0$。我们已知以下具体的参数值：\n- 矩阵维度：$m = n = 100$\n- $L_{0}$ 的秩：$r = 5$\n- $L_{0}$ 的非相干参数：$\\mu = 3$\n- $S_{0}$ 的稀疏度：$\\rho = 0.05$\n- 秩条件的常数：$c_{r} = 0.4$\n- 稀疏度条件的常数：$c_{\\rho} = 0.1$\n\n为了确定 $I$ 的值，我们必须分别评估这两个不等式。\n\n首先，我们来评估秩条件：\n$$\nr \\leq c_{r} \\frac{n}{\\mu (\\ln n)^{2}}\n$$\n将给定值代入不等式的左侧（LHS）和右侧（RHS）：\n- 左侧：$r = 5$\n- 右侧：$c_{r} \\frac{n}{\\mu (\\ln n)^{2}} = (0.4) \\frac{100}{3 (\\ln(100))^{2}}$\n\n我们需要计算右侧的数值。$100$ 的自然对数是 $\\ln(100) \\approx 4.60517$。\n因此，$(\\ln(100))^{2} \\approx (4.60517)^{2} \\approx 21.20758$。\n\n现在，我们可以将这个值代回到右侧的表达式中：\n$$\n\\text{RHS} \\approx (0.4) \\frac{100}{3 \\times 21.20758} = \\frac{40}{63.62274} \\approx 0.6287\n$$\n因此，需要检查的不等式是：\n$$\n5 \\leq 0.6287\n$$\n这个陈述显然是错误的。\n\n其次，我们来评估稀疏度条件：\n$$\n\\rho \\leq c_{\\rho}\n$$\n代入给定值：\n- 左侧：$\\rho = 0.05$\n- 右侧：$c_{\\rho} = 0.1$\n\n需要检查的不等式是：\n$$\n0.05 \\leq 0.1\n$$\n这个陈述是正确的。\n\n指示函数 $I$ 的值为 $1$ 当且仅当两个条件都满足。总的逻辑条件是两个独立检查的合取：\n$$\n\\left( r \\leq c_{r} \\frac{n}{\\mu (\\ln n)^{2}} \\right) \\land \\left( \\rho \\leq c_{\\rho} \\right)\n$$\n在我们的情况下，这对应于：\n$$\n(\\text{假}) \\land (\\text{真})\n$$\n这个逻辑与运算的结果是假。\n\n因此，指示函数内的条件不满足。根据指示函数的定义，$\\mathbf{1}\\{\\text{假}\\} = 0$。\n因此，$I$ 的值为 $0$。这意味着对于给定的参数，通过 PCP 保证精确恢复的充分条件没有得到满足。", "answer": "$$\\boxed{0}$$", "id": "3474843"}, {"introduction": "现在你已经掌握了核心的数学工具和理论基础，是时候将这些知识整合起来，构建一个完整的RPCA求解器了。这项练习要求你编写一个交替近端最小化算法，这需要你将用于低秩部分更新的SVT算子和用于稀疏部分更新的逐元素软阈值算子结合到一个迭代框架中。通过完成这个编程任务，你将获得将理论转化为实用算法的宝贵经验，并学会如何通过合成数据来验证算法的有效性，这是计算和优化领域从业者的核心技能之一。[@problem_id:3474831]", "problem": "您需要实现并分析一个用于鲁棒主成分分析 (Robust Principal Component Analysis, RPCA) 的简单交替邻近最小化算法。RPCA 是压缩感知和稀疏优化中的一个典型问题。考虑一个数据矩阵 $M \\in \\mathbb{R}^{m \\times n}$，它可以分解为 $M = L_{\\star} + S_{\\star}$，其中 $L_{\\star}$ 是低秩的，$S_{\\star}$ 是稀疏的。从使用核范数和逐元素绝对值范数进行凸正则化的基础出发，考虑以下无约束惩罚目标函数：\n$$\n\\min_{L, S \\in \\mathbb{R}^{m \\times n}} \\; \\frac{1}{2} \\lVert M - L - S \\rVert_{F}^{2} + \\mu \\lVert L \\rVert_{\\ast} + \\lambda \\lVert S \\rVert_{1},\n$$\n其中 $\\lVert \\cdot \\rVert_{F}$ 是 Frobenius 范数，$\\lVert \\cdot \\rVert_{\\ast}$ 是核范数（奇异值之和），$\\lVert \\cdot \\rVert_{1}$ 是逐元素 $\\ell_{1}$ 范数。您的程序必须实现一个交替邻近最小化方案，该方案在最小化关于 $L$ 的目标函数（保持 $S$ 固定）和最小化关于 $S$ 的目标函数（保持 $L$ 固定）之间交替进行。核范数的邻近算子对应于奇异值阈值化，而逐元素 $\\ell_{1}$ 范数的邻近算子对应于逐元素软阈值化。\n\n从第一性原理出发，将您的推导建立在邻近算子、核范数和 $\\ell_{1}$ 范数的定义，以及通过奇异值分解对矩阵进行分解的基础上。除了由这些范数定义的交替最小化和邻近更新外，不要假设任何特殊的算法模板。\n\n您的程序必须：\n- 为一个小规模的测试套件构建合成测试矩阵 $M = L_{\\star} + S_{\\star}$，其中 $L_{\\star}$ 具有指定的秩，$S_{\\star}$ 具有指定的稀疏支撑集。对 $L_{\\star}$ 使用标准正交因子（从随机高斯矩阵进行 QR 分解获得）和固定的奇异值，并为 $S_{\\star}$ 选择一个随机支撑集，其非零项具有固定的幅度和随机的符号。使用固定的伪随机种子以保证可复现性。\n- 运行交替邻近最小化更新：\n  - 通过将 $\\mu \\lVert \\cdot \\rVert_{\\ast}$ 的邻近映射应用于 $M - S$ 来更新 $L$。\n  - 通过将 $\\lambda \\lVert \\cdot \\rVert_{1}$ 的邻近映射应用于 $M - L$ 来更新 $S$。\n- 将 $L$ 和 $S$ 初始化为零矩阵。\n- 在每次迭代中，检查估计的低秩矩阵是否具有正确的秩（即，大于固定阈值的奇异值数量与真实秩相符），以及估计的稀疏矩阵是否具有完全正确的支撑集（即，幅度大于固定阈值的索引集合与真实支撑集相符）。为这两项检查定义一个小的绝对阈值，分别为 $\\tau_{\\text{rank}} = 10^{-6}$ 和 $\\tau_{\\text{supp}} = 10^{-6}$。\n- 报告首次同时实现正确秩和正确支撑集时的迭代次数。如果在最多 $1000$ 次迭代内未达到此条件，则为该测试用例报告 $-1$。使用收敛保护措施更新迭代，直到达到最大迭代次数上限或 $(L,S)$ 的相对变化降至 $10^{-8}$ 以下。\n\n测试套件：\n实现四个具有以下参数的测试用例。对于每个用例，按规定生成 $L_{\\star}$ 和 $S_{\\star}$，设置 $M = L_{\\star} + S_{\\star}$，并使用指定的 $(\\mu,\\lambda)$ 运行算法。\n\n- 用例 A（理想情况，混合低秩和稀疏）：\n  - 维度：$m = 12$, $n = 10$。\n  - $L_{\\star}$ 的秩：$r = 2$，奇异值为 $[8.0, 6.0]$。\n  - 稀疏支撑集大小：$12$ 个非零项，幅度为 $5.0$，符号为随机的 $\\pm 1$。\n  - 参数：$\\mu = 1.0$, $\\lambda = 0.35$。\n  - 随机种子：$0$。\n\n- 用例 B（边界条件，无稀疏分量）：\n  - 维度：$m = 15$, $n = 10$。\n  - $L_{\\star}$ 的秩：$r = 3$，奇异值为 $[5.0, 4.0, 3.0]$。\n  - 稀疏支撑集大小：$0$。\n  - 参数：$\\mu = 0.8$, $\\lambda = 0.30$。\n  - 随机种子：$1$。\n\n- 用例 C（边界条件，无低秩分量）：\n  - 维度：$m = 10$, $n = 10$。\n  - $L_{\\star}$ 的秩：$r = 0$。\n  - 稀疏支撑集大小：$15$ 个非零项，幅度为 $4.0$，符号为随机的 $\\pm 1$。\n  - 参数：$\\mu = 1.0$, $\\lambda = 0.50$。\n  - 随机种子：$2$。\n\n- 用例 D（接近阈值的较难情况）：\n  - 维度：$m = 10$, $n = 10$。\n  - $L_{\\star}$ 的秩：$r = 2$，奇异值为 $[1.2, 1.1]$。\n  - 稀疏支撑集大小：$8$ 个非零项，幅度为 $0.6$，符号为随机的 $\\pm 1$。\n  - 参数：$\\mu = 0.8$, $\\lambda = 0.45$。\n  - 随机种子：$3$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的迭代次数，格式为方括号括起来的逗号分隔列表（例如，$\\texttt{[7,4,5,-1]}$）。不应打印任何额外文本。此问题不涉及任何物理单位，也无需指定任何角度。所有数值输出均为纯整数。原则上允许使用任何语言，但您的最终答案必须是一个完整的、可运行的程序，并遵守所提供的执行环境约束。", "solution": "该问题要求实现一个交替邻近最小化算法来解决鲁棒主成分分析（RPCA）问题。该解决方案旨在将一个给定的数据矩阵 $M \\in \\mathbb{R}^{m \\times n}$ 分解为一个低秩分量 $L$ 和一个稀疏分量 $S$。这是通过求解以下凸优化问题来实现的：\n$$\n\\min_{L, S \\in \\mathbb{R}^{m \\times n}} \\; f(L, S) = \\frac{1}{2} \\lVert M - L - S \\rVert_{F}^{2} + \\mu \\lVert L \\rVert_{\\ast} + \\lambda \\lVert S \\rVert_{1}\n$$\n在这里，$\\lVert \\cdot \\rVert_{F}$ 是 Frobenius 范数，用于衡量数据保真度；$\\lVert \\cdot \\rVert_{\\ast}$ 是核范数（奇异值之和），作为 $L$ 的秩的凸代理；$\\lVert \\cdot \\rVert_{1}$ 是逐元素 $\\ell_1$ 范数（各项绝对值之和），用于促进 $S$ 的稀疏性。参数 $\\mu > 0$ 和 $\\lambda > 0$ 控制数据保真度与低秩和稀疏正则化项之间的权衡。\n\n所选择的求解方法是交替最小化方案，这是一种块坐标下降方法。在每次迭代中，我们针对一个变量最小化目标函数，同时保持另一个变量固定。这将联合最小化问题分解为两个更简单的子问题。\n\n**步骤1：关于 $L$ 的最小化**\n\n将 $S$ 固定为上一次迭代的值 $S_k$，更新 $L$ 的子问题是：\n$$\nL_{k+1} = \\arg\\min_{L} \\frac{1}{2} \\lVert M - L - S_k \\rVert_{F}^{2} + \\mu \\lVert L \\rVert_{\\ast}\n$$\n这可以重写为：\n$$\nL_{k+1} = \\arg\\min_{L} \\frac{1}{2} \\lVert (M - S_k) - L \\rVert_{F}^{2} + \\mu \\lVert L \\rVert_{\\ast}\n$$\n这是核范数的邻近算子（由 $\\mu$ 缩放）应用于矩阵 $M - S_k$ 的定义。邻近算子，记为 $\\text{prox}_{\\mu \\lVert \\cdot \\rVert_{\\ast}}$，由奇异值阈值化 (SVT) 算子给出。对于任意矩阵 $X \\in \\mathbb{R}^{m \\times n}$，其奇异值分解 (SVD) 为 $X = U \\Sigma V^T$，其中 $\\Sigma = \\text{diag}(\\{\\sigma_i\\}_{i=1}^{\\min(m,n)})$，SVT 算子定义为：\n$$\n\\text{prox}_{\\mu \\lVert \\cdot \\rVert_{\\ast}}(X) = U \\mathcal{S}_{\\mu}(\\Sigma) V^T\n$$\n其中 $\\mathcal{S}_{\\mu}(\\Sigma)$ 是一个对角矩阵，其对角元素为 $(\\mathcal{S}_{\\mu}(\\Sigma))_{ii} = \\max(0, \\sigma_i - \\mu)$。此操作有效地将 $X$ 的奇异值向零收缩 $\\mu$，并将任何小于 $\\mu$ 的奇异值设为零，从而促进低秩结构。\n\n**步骤2：关于 $S$ 的最小化**\n\n接下来，我们将 $L$ 固定为其新计算出的值 $L_{k+1}$，并求解 $S$：\n$$\nS_{k+1} = \\arg\\min_{S} \\frac{1}{2} \\lVert M - L_{k+1} - S \\rVert_{F}^{2} + \\lambda \\lVert S \\rVert_{1}\n$$\n这可以重写为：\n$$\nS_{k+1} = \\arg\\min_{S} \\frac{1}{2} \\lVert (M - L_{k+1}) - S \\rVert_{F}^{2} + \\lambda \\lVert S \\rVert_{1}\n$$\n这是 $\\ell_1$ 范数的邻近算子（由 $\\lambda$ 缩放）应用于矩阵 $M - L_{k+1}$ 的定义。由于 Frobenius 范数和 $\\ell_1$ 范数在矩阵元素上的可分离性，该问题可以逐元素求解。对于每个条目 $(i,j)$，问题是：\n$$\n(S_{k+1})_{ij} = \\arg\\min_{s_{ij}} \\frac{1}{2} ((M-L_{k+1})_{ij} - s_{ij})^2 + \\lambda |s_{ij}|\n$$\n解由逐元素软阈值化算子 $\\mathcal{S}_{\\lambda}$ 给出：\n$$\n(S_{k+1})_{ij} = \\mathcal{S}_{\\lambda}((M-L_{k+1})_{ij}) = \\text{sign}((M-L_{k+1})_{ij}) \\max(0, |(M-L_{k+1})_{ij}| - \\lambda)\n$$\n该操作将每个元素的幅度向零收缩 $\\lambda$，从而促进稀疏性。\n\n**算法与实现**\n\n完整的算法流程如下：\n1. 初始化 $L_0 = 0$ 和 $S_0 = 0$。\n2. 对于 $k=0, 1, 2, \\dots$ 直到收敛或达到最大迭代次数：\n   a. 更新 $L$：$L_{k+1} = \\text{prox}_{\\mu \\lVert \\cdot \\rVert_{\\ast}}(M - S_k)$。\n   b. 更新 $S$：$S_{k+1} = \\text{prox}_{\\lambda \\lVert \\cdot \\rVert_{1}}(M - L_{k+1})$。\n\n该实现根据每个测试用例的指定参数创建合成数据 $M = L_{\\star} + S_{\\star}$。$L_{\\star}$ 由随机标准正交基和指定的奇异值构成。$S_{\\star}$ 通过在随机支撑集上填充具有固定幅度和随机符号的条目来构建。固定的随机种子确保了可复现性。\n\n算法进行迭代，并在每一步 $k$ 检查估计的 $L_k$ 是否具有正确的秩 $r$（奇异值大于 $\\tau_{\\text{rank}} = 10^{-6}$ 的数量）以及估计的 $S_k$ 是否具有完全正确的支撑集（$|(S_k)_{ij}| > \\tau_{\\text{supp}} = 10^{-6}$ 的索引集合与 $S_{\\star}$ 的真实支撑集相匹配）。首次同时满足这两个条件的迭代次数被记录下来。如果满足这些条件且算法随后收敛（$(L,S)$ 的相对变化低于 $10^{-8}$），或者达到 $1000$ 次的最大迭代限制，则过程停止。如果在迭代限制内未满足成功条件，则报告 $-1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ... # No scipy needed for this implementation.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Robust PCA and print results.\n    \"\"\"\n\n    def generate_data(m, n, r, singular_values, sparse_size, sparse_mag, seed):\n        \"\"\"Generates synthetic data matrix M = L_star + S_star.\"\"\"\n        rng = np.random.default_rng(seed)\n\n        # Generate L_star (low-rank matrix)\n        if r > 0:\n            U_rand = rng.standard_normal(size=(m, r))\n            U, _ = np.linalg.qr(U_rand)\n            \n            V_rand = rng.standard_normal(size=(n, r))\n            V, _ = np.linalg.qr(V_rand)\n            \n            Sigma_star = np.diag(singular_values)\n            L_star = U @ Sigma_star @ V.T\n        else:\n            L_star = np.zeros((m, n))\n\n        # Generate S_star (sparse matrix)\n        S_star = np.zeros((m, n))\n        if sparse_size > 0:\n            indices = rng.choice(m * n, size=sparse_size, replace=False)\n            row_indices, col_indices = np.unravel_index(indices, (m, n))\n            \n            signs = rng.choice([-1.0, 1.0], size=sparse_size)\n            \n            S_star[row_indices, col_indices] = signs * sparse_mag\n        \n        true_support_indices = np.where(S_star != 0)\n        \n        M = L_star + S_star\n        \n        return M, true_support_indices\n\n    def prox_nuclear(X, mu):\n        \"\"\"Singular Value Thresholding (proximal operator for nuclear norm).\"\"\"\n        U, s, Vt = np.linalg.svd(X, full_matrices=False, compute_uv=True)\n        s_thresh = np.maximum(0, s - mu)\n        return U @ np.diag(s_thresh) @ Vt\n\n    def prox_l1(X, lam):\n        \"\"\"Element-wise soft-thresholding (proximal operator for l1 norm).\"\"\"\n        return np.sign(X) * np.maximum(np.abs(X) - lam, 0)\n\n    def run_rpca_instance(m, n, true_rank, sv, sp_size, sp_mag, mu, lam, seed):\n        \"\"\"Runs the alternating proximal minimization for one RPCA instance.\"\"\"\n        M, true_support_indices = generate_data(m, n, true_rank, sv, sp_size, sp_mag, seed)\n        \n        L = np.zeros((m, n))\n        S = np.zeros((m, n))\n        \n        max_iter = 1000\n        conv_tol = 1e-8\n        rank_tol = 1e-6\n        supp_tol = 1e-6\n        \n        found_iter = -1\n        \n        true_support_mask = np.zeros((m, n), dtype=bool)\n        if sp_size > 0:\n            true_support_mask[true_support_indices] = True\n        \n        for k in range(1, max_iter + 1):\n            L_old, S_old = L.copy(), S.copy()\n            \n            # L-update\n            L = prox_nuclear(M - S, mu)\n            \n            # S-update\n            S = prox_l1(M - L, lam)\n            \n            # Check for correct rank and support (if not already found)\n            if found_iter == -1:\n                singular_values_L = np.linalg.svd(L, compute_uv=False)\n                estimated_rank = np.sum(singular_values_L > rank_tol)\n                rank_ok = (estimated_rank == true_rank)\n                \n                estimated_support_mask = np.abs(S) > supp_tol\n                support_ok = np.array_equal(estimated_support_mask, true_support_mask)\n                \n                if rank_ok and support_ok:\n                    found_iter = k\n                    \n            # Check for convergence\n            norm_L_fro_sq = np.linalg.norm(L_old, 'fro')**2\n            norm_S_fro_sq = np.linalg.norm(S_old, 'fro')**2\n            norm_val_sq = norm_L_fro_sq + norm_S_fro_sq\n\n            norm_diff_L_fro_sq = np.linalg.norm(L - L_old, 'fro')**2\n            norm_diff_S_fro_sq = np.linalg.norm(S - S_old, 'fro')**2\n            norm_diff_sq = norm_diff_L_fro_sq + norm_diff_S_fro_sq\n            \n            if norm_val_sq > 0: # Avoid division by zero, especially at first iteration\n                rel_change = np.sqrt(norm_diff_sq / norm_val_sq)\n                if rel_change  conv_tol:\n                    break\n        return found_iter\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Happy path\n        {'m': 12, 'n': 10, 'true_rank': 2, 'sv': [8.0, 6.0], 'sp_size': 12, 'sp_mag': 5.0, 'mu': 1.0, 'lam': 0.35, 'seed': 0},\n        # Case B: No sparse component\n        {'m': 15, 'n': 10, 'true_rank': 3, 'sv': [5.0, 4.0, 3.0], 'sp_size': 0, 'sp_mag': 0.0, 'mu': 0.8, 'lam': 0.30, 'seed': 1},\n        # Case C: No low-rank component\n        {'m': 10, 'n': 10, 'true_rank': 0, 'sv': [], 'sp_size': 15, 'sp_mag': 4.0, 'mu': 1.0, 'lam': 0.50, 'seed': 2},\n        # Case D: Harder case\n        {'m': 10, 'n': 10, 'true_rank': 2, 'sv': [1.2, 1.1], 'sp_size': 8, 'sp_mag': 0.6, 'mu': 0.8, 'lam': 0.45, 'seed': 3},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_rpca_instance(**case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3474831"}]}