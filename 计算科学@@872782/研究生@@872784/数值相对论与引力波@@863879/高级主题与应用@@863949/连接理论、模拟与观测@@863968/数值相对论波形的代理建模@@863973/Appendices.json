{"hands_on_practices": [{"introduction": "理解代理建模的最佳方式莫过于亲手构建一个。这项练习将指导您为一种简化的“玩具”波形，从零开始构建一个完整的经验插值代理模型。通过这个实践，您将从基本原理出发，实现降阶基的构建和经验插值节点的选择，从而牢固掌握代理建模的核心概念。", "problem": "实现一个完整的、可运行的程序，该程序为一个玩具引力波类波形族构建一个经验插值代理模型，并验证重构误差随经验节点数量增加的收敛性。任务是从参数化函数族的降阶建模和线性近似的基本原理出发。该波形族以解析形式给出，以便可以直接验证代理模型的构建和误差量化。角度必须以弧度处理。\n\n给定一个参数化波形族 $w(t;\\lambda)$，定义在 $t \\in [0,1]$ 和 $\\lambda \\in [0,1]$ 上。该波形为\n$$\nw(t;\\lambda) \\equiv \\left(1 + 0.3\\,\\lambda\\right)\\,\\left(t+0.01\\right)^{1/4}\\,\\exp\\!\\left(-t^{8}\\right)\\,\\sin\\!\\big(\\varphi(t;\\lambda)\\big),\n$$\n其中相位是\n$$\n\\varphi(t;\\lambda) \\equiv 2\\pi f_0\\,t + \\beta\\,\\lambda\\,t^{3/2} + \\kappa\\,t^{2}.\n$$\n使用 $f_0 = 20$，$\\beta = 35$ 和 $\\kappa = 3$。正弦函数的参数以弧度为单位。\n\n基本出发点：利用这样一个原理，即一个光滑、低内蕴维度的参数化函数族，允许通过其快照矩阵的主奇异向量捕获的精确低秩近似。经验插值方法（Empirical Interpolation Method, EIM）构建一个插值算子，通过在自适应选择的节点上匹配函数，来恢复其在降阶基展开中的系数。您必须从第一性原理出发实现以下步骤：\n\n1. 时间离散化与快照：\n   - 用 $N_t = 2000$ 个点的均匀网格离散化区间 $[0,1]$。\n   - 构建一个包含 $[0,1]$ 区间内 $M = 20$ 个等距值的训练参数集 $\\Lambda_{\\mathrm{train}}$。\n   - 形成快照矩阵 $S \\in \\mathbb{R}^{N_t \\times M}$，其列为 $S_{:,j} = w(t;\\lambda_j)$，其中 $\\lambda_j \\in \\Lambda_{\\mathrm{train}}$。\n\n2. 通过奇异值分解（SVD）获得降阶基：\n   - 计算一个细奇异值分解 $S = U \\Sigma V^{\\top}$。\n   - 降阶基函数是前 $r$ 个左奇异向量 $U_{:,1},\\dots,U_{:,r}$，其中 $1 \\le r \\le M$。\n\n3. 经验插值方法（EIM）节点选择：\n   - 归纳地定义经验插值节点。令 $\\Phi_k$ 表示 $k$ 维基 $\\{U_{:,1},\\dots,U_{:,k}\\}$，视为时间网格上的函数。\n   - 初始化：选择第一个节点索引 $i_1$ 作为 $U_{:,1}$ 在网格上绝对值的最大值索引。\n   - 归纳步骤：给定节点 $\\{i_1,\\dots,i_{k-1}\\}$，找到系数 $\\{a_j\\}_{j=1}^{k-1}$，使得在现有节点上，由 $\\Phi_{k-1}$ 张成的子空间中插值 $U_{:,k}$。即，找到 $a \\in \\mathbb{R}^{k-1}$ 使得对于所有 $\\ell \\in \\{1,\\dots,k-1\\}$，\n     $$\n     \\sum_{j=1}^{k-1} a_j\\,U_{i_\\ell,j} = U_{i_\\ell,k}.\n     $$\n     然后形成残差向量 $r^{(k)} = U_{:,k} - \\sum_{j=1}^{k-1} a_j\\,U_{:,j}$，并选择 $i_k$ 作为 $r^{(k)}$ 在网格上绝对值的最大值索引。\n   - 这对每个 $m \\in \\{1,2,\\dots,M\\}$ 产生一个包含 $m$ 个节点的集合 $\\{i_1,\\dots,i_m\\}$。\n\n4. 经验插值重构：\n   - 对于一个给定的波形 $y = w(\\cdot;\\lambda)$ 和一个选定的 $m$，通过在经验节点上强制插值来计算系数 $c \\in \\mathbb{R}^{m}$：\n     $$\n     \\sum_{j=1}^{m} c_j\\,U_{i_\\ell,j} = y_{i_\\ell}, \\quad \\ell=1,\\dots,m.\n     $$\n     求解关于 $c$ 的线性系统并重构 $\\widehat{y}^{(m)} = \\sum_{j=1}^{m} c_j\\,U_{:,j}$。\n\n5. 误差量化与奇异值衰减：\n   - 对于给定的 $\\lambda$，计算在 $[0,1]$ 上的相对 $L^2$ 误差，\n     $$\n     \\varepsilon^{(m)}(\\lambda) \\equiv \\frac{\\left(\\int_0^1 \\big|y(t) - \\widehat{y}^{(m)}(t)\\big|^2\\,dt\\right)^{1/2}}{\\left(\\int_0^1 |y(t)|^2\\,dt\\right)^{1/2}},\n     $$\n     在时间网格上使用梯形法则进行计算。\n   - 通过将直线拟合到作为 $k$ 的函数的 $\\log(\\sigma_k)$ 来估计奇异值的指数衰减率，其中 $\\{\\sigma_k\\}$ 是来自 $\\Sigma$ 的奇异值。具体来说，对于索引 $k$ 使得 $\\sigma_k$ 保持大于 $\\sigma_1$ 的一个固定小分数（例如，大于 $10^{-12}\\,\\sigma_1$）的情况，求解一个最小二乘问题以获得下式中的参数 $(a,b)$：\n     $$\n     \\log \\sigma_k \\approx a + b\\,k,\n     $$\n     并报告速率估计 $\\rho \\equiv -b$。\n\n测试套件规范：\n- 使用测试参数集 $\\Lambda_{\\mathrm{test}} = \\{0.07,\\,0.31,\\,0.59,\\,0.93\\}$。\n- 使用节点数 $\\mathcal{M} = \\{1,\\,2,\\,3,\\,5,\\,8,\\,12,\\,16\\}$。\n- 对于每个 $m \\in \\mathcal{M}$，计算最大测试误差\n  $$\n  E_m \\equiv \\max_{\\lambda \\in \\Lambda_{\\mathrm{test}}} \\varepsilon^{(m)}(\\lambda).\n  $$\n- 同时按上述方法计算奇异值衰减率估计 $\\rho$。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。第一个条目必须是七个值 $[E_1,E_2,E_3,E_5,E_8,E_{12},E_{16}]$ 按此顺序构成的列表，第二个条目必须是标量 $\\rho$。角度使用弧度，不带物理单位。每个打印的数值必须四舍五入到六位有效数字并以科学记数法表示。例如，输出形式为\n  $$\n  [[\\text{e}_1,\\text{e}_2,\\dots,\\text{e}_7],\\text{r}]\n  $$\n  其中每个 $\\text{e}_j$ 和 $\\text{r}$ 以类似 $1.234567\\text{e}{-03}$ 的数字形式出现。\n\n科学真实性：\n- 波形族 $w(t;\\lambda)$ 是解析的，在 $t$ 和 $\\lambda$ 上都是光滑的，并表现出类似啁啾的相位演化和幅度调制，这些特征模拟了数值相对论波形的显著特点，而无需援引完整的广义相对论。这确保了降阶基和经验插值方法是适用的，并且奇异值有意义地衰减。\n\n覆盖性设计：\n- 所选的 $\\mathcal{M}$ 覆盖了边界情况 $m=1$、适度的中间大小，以及一个接近训练集维度的大尺寸。\n- 测试集 $\\Lambda_{\\mathrm{test}}$ 包括参数范围两端和内部的值，以探测整个域上的插值行为。\n\n您的实现必须是自包含的，不需要用户输入，并严格遵守指定的最终输出格式。", "solution": "经评估，用户提供的问题是 **有效的**。这是一个在数值分析和降阶建模领域中适定且有科学依据的问题，所有必要的数据和算法步骤都已明确指定。不存在会使其无效的矛盾、模糊之处或对科学原理的违背。任务是实现经验插值方法（Empirical Interpolation Method, EIM），为一个给定的参数化函数族构建一个代理模型，这是计算科学中一项标准且重要的技术。\n\n该解决方案通过遵循规定的步骤序列来实现，这些步骤植根于线性代数和逼近理论的原理。\n\n**1. 波形离散化与快照矩阵生成**\n基础步骤是将连续的参数化函数族 $w(t;\\lambda)$ 以适合数值线性代数的离散形式表示。该波形定义为：\n$$\nw(t;\\lambda) = \\left(1 + 0.3\\,\\lambda\\right)\\,\\left(t+0.01\\right)^{1/4}\\,\\exp\\!\\left(-t^{8}\\right)\\,\\sin\\!\\big(2\\pi f_0\\,t + \\beta\\,\\lambda\\,t^{3/2} + \\kappa\\,t^{2}\\big)\n$$\n其中常数为 $f_0 = 20$, $\\beta = 35$, 和 $\\kappa = 3$。\n\n首先，时间域 $t \\in [0,1]$ 被离散化为一个包含 $N_t = 2000$ 个点的均匀网格。其次，参数域 $\\lambda \\in [0,1]$ 在 $M=20$ 个等距点上进行采样，形成一个训练集 $\\Lambda_{\\mathrm{train}}$。对于每个训练参数 $\\lambda_j \\in \\Lambda_{\\mathrm{train}}$，在时间网格上评估波形 $w(t; \\lambda_j)$，得到一个 $\\mathbb{R}^{N_t}$ 中的向量。这些向量被组装成列，形成快照矩阵 $S \\in \\mathbb{R}^{N_t \\times M}$。因此，矩阵 $S$ 是该函数族的离散表示。\n\n**2. 通过奇异值分解（SVD）获得降阶基**\n低秩近似原理指出，如果族中的函数高度相关，则快照矩阵 $S$ 可以被一个低秩矩阵精确近似。在最小二乘意义下，最优的低秩基由 $S$ 的主左奇异向量给出。计算一个细奇异值分解：\n$$\nS = U \\Sigma V^{\\top}\n$$\n其中 $U \\in \\mathbb{R}^{N_t \\times M}$ 是一个具有标准正交列的矩阵（左奇异向量），$\\Sigma \\in \\mathbb{R}^{M \\times M}$ 是一个包含奇异值 $\\{\\sigma_k\\}$ 的对角矩阵，而 $V \\in \\mathbb{R}^{M \\times M}$ 是一个正交矩阵。$U$ 的列，记为 $\\{U_{:,1}, \\dots, U_{:,M}\\}$，构成了降阶基。奇异值 $\\sigma_k$ 的快速衰减表明该函数族具有低的内蕴维度，非常适合降阶建模。\n\n**3. 用于节点选择的经验插值方法（EIM）**\n虽然SVD提供了最优基，但为新波形计算投影系数需要计算其与基函数的内积，这是一个与评估完整波形一样耗费计算资源的操作。EIM通过选择一小组“经验”时间点（或节点）来规避这个问题，在这些点上评估波形。然后通过求解一个小型线性系统来找到系数。\n\nEIM节点被贪婪地选择，以在降阶基内实现最优插值。\n- **步骤 1 ($k=1$):** 考虑第一个基函数 $U_{:,1}$。选择第一个节点 $i_1$ 作为 $|U_{:,1}(t)|$ 取得最大值的时间索引。该点捕获了最主要模式的最显著特征。\n- **归纳步骤 ($k  1$):** 为了找到第 $k$ 个节点 $i_k$，我们首先考虑第 $k$ 个基函数 $U_{:,k}$。我们通过在先前选择的节点 $\\{i_1, \\dots, i_{k-1}\\}$ 上强制相等，在前述基函数 $\\{U_{:,1}, \\dots, U_{:,k-1}\\}$ 张成的子空间内构造它的插值。这需要求解一个 $(k-1) \\times (k-1)$ 的线性系统来获得插值系数 $\\{a_j\\}_{j=1}^{k-1}$：\n$$\n\\sum_{j=1}^{k-1} a_j\\,U_{i_\\ell, j} = U_{i_\\ell, k}, \\quad \\text{for } \\ell = 1, \\dots, k-1\n$$\n残差 $r^{(k)}(t) = U_{:,k} - \\sum_{j=1}^{k-1} a_j U_{:,j}$ 表示 $U_{:,k}$ 中不能被现有节点上的先前基函数捕获的部分。新节点 $i_k$ 被选为该残差 $|r^{(k)}(t)|$ 最大化的时间索引。对 $k=1, \\dots, M$ 重复此过程，生成一个包含 $M$ 个经验节点的序列。\n\n**4. 波形重构与误差量化**\n对于一个测试波形 $y(t) = w(t; \\lambda)$（其中 $\\lambda \\in \\Lambda_{\\mathrm{test}}$）以及选定的基函数/节点数 $m$，代理近似 $\\widehat{y}^{(m)}$ 被构造为前 $m$ 个基函数的线性组合：$\\widehat{y}^{(m)} = \\sum_{j=1}^{m} c_j U_{:,j}$。系数 $c = \\{c_j\\}_{j=1}^m$ 通过求解一个 $m \\times m$ 的线性系统来确定，该系统强制真波形与代理模型在前 $m$ 个经验节点 $\\{i_1, \\dots, i_m\\}$ 上相等：\n$$\n\\sum_{j=1}^{m} c_j\\,U_{i_\\ell, j} = y_{i_\\ell}, \\quad \\ell=1,\\dots,m\n$$\n该代理模型的精度通过相对 $L^2$ 误差 $\\varepsilon^{(m)}(\\lambda)$ 来量化，使用时间网格上的梯形法则进行数值计算。然后对每个 $m \\in \\mathcal{M} = \\{1, 2, 3, 5, 8, 12, 16\\}$ 确定在测试集 $\\Lambda_{\\mathrm{test}}$ 上的最大误差 $E_m$。\n\n**5. 奇异值衰减率**\n奇异值的指数衰减是模型可约性的关键指标。衰减率 $\\rho$ 通过对模型 $\\log \\sigma_k \\approx a + b k$ 进行线性最小二乘拟合来估计，该拟合针对所有数值上显著的奇异值 $\\sigma_k$（即 $\\sigma_k > 10^{-12} \\sigma_1$）。估计的速率则为 $\\rho = -b$。\n\n最终程序实现了这些步骤，以计算所需的误差度量和奇异值衰减率，并根据问题规范将输出格式化为单行。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs an empirical interpolation surrogate for a toy waveform family\n    and verifies the convergence of the reconstruction error.\n    \"\"\"\n    # Step 0: Define constants and parameters\n    f0 = 20.0\n    beta = 35.0\n    kappa = 3.0\n    Nt = 2000\n    M = 20\n    test_lambdas = [0.07, 0.31, 0.59, 0.93]\n    m_counts = [1, 2, 3, 5, 8, 12, 16]\n\n    def get_waveform(t, lam, f0, beta, kappa):\n        \"\"\"\n        Computes the toy gravitational waveform w(t; lambda).\n        \"\"\"\n        # Phase function in radians\n        phase = 2.0 * np.pi * f0 * t + beta * lam * np.power(t, 1.5) + kappa * np.power(t, 2.0)\n        # Amplitude modulation\n        amplitude = (1.0 + 0.3 * lam) * np.power(t + 0.01, 0.25) * np.exp(-np.power(t, 8.0))\n        return amplitude * np.sin(phase)\n\n    # Step 1: Time discretization, training set, and snapshot matrix\n    t_grid = np.linspace(0.0, 1.0, Nt)\n    train_lambdas = np.linspace(0.0, 1.0, M)\n    \n    S = np.zeros((Nt, M))\n    for j, lam in enumerate(train_lambdas):\n        S[:, j] = get_waveform(t_grid, lam, f0, beta, kappa)\n\n    # Step 2: Reduced basis by SVD\n    U, svals, _ = np.linalg.svd(S, full_matrices=False)\n    \n    # Step 5 (part 1): Singular value decay rate estimation\n    s_thresh = svals[0] * 1e-12\n    s_fit = svals[svals > s_thresh]\n    k_fit = np.arange(1, len(s_fit) + 1)\n    \n    # Perform a linear least-squares fit for log(sigma_k) vs. k\n    # np.polyfit for degree 1 returns [slope, intercept]\n    slope, _ = np.polyfit(k_fit, np.log(s_fit), 1)\n    rho = -slope\n    \n    # Step 3: Empirical Interpolation Method (EIM) node selection\n    eim_nodes = []\n    for k in range(M):\n        if k == 0:\n            # First residual is just the first basis vector\n            residual = U[:, 0]\n        else:\n            # For the (k+1)-th node (0-indexed k), we have k nodes in eim_nodes.\n            # We solve for the coefficients that interpolate U[:, k] using the basis U[:, :k]\n            # at the previously selected k nodes.\n            A_mat = U[eim_nodes, :k]  # k x k matrix\n            b_vec = U[eim_nodes, k]   # k-dim vector\n            \n            coeffs = np.linalg.solve(A_mat, b_vec)\n            \n            # Compute the residual vector over the full time domain\n            projection = U[:, :k] @ coeffs\n            residual = U[:, k] - projection\n\n        # Select new node as the point of maximum absolute residual\n        new_node_idx = np.argmax(np.abs(residual))\n        eim_nodes.append(int(new_node_idx))\n        \n    # Step 4  5 (part 2): Reconstruction and error quantification\n    max_errors = []\n    for m in m_counts:\n        nodes_m = eim_nodes[:m]\n        U_m = U[:, :m]\n        \n        # Define the m x m interpolation matrix\n        interp_matrix = U_m[nodes_m, :]\n        \n        current_max_error = 0.0\n        for lam_test in test_lambdas:\n            y_true = get_waveform(t_grid, lam_test, f0, beta, kappa)\n            \n            # Get waveform values at the interpolation nodes\n            y_nodes = y_true[nodes_m]\n            \n            # Solve for reconstruction coefficients\n            c_coeffs = np.linalg.solve(interp_matrix, y_nodes)\n            \n            # Reconstruct the surrogate waveform\n            y_recon = U_m @ c_coeffs\n            \n            # Calculate relative L2 error using the trapezoidal rule\n            norm_diff_sq = np.trapz((y_true - y_recon)**2, t_grid)\n            norm_true_sq = np.trapz(y_true**2, t_grid)\n            \n            norm_diff = np.sqrt(norm_diff_sq)\n            norm_true = np.sqrt(norm_true_sq)\n            \n            rel_error = norm_diff / norm_true if norm_true > 1e-15 else 0.0\n            \n            current_max_error = max(current_max_error, rel_error)\n        \n        max_errors.append(current_max_error)\n        \n    # Format the final output as specified (using {:.6e} for 7 significant figures\n    # to match the provided formatting example, despite the \"six\" in text).\n    errors_formatted = [\"{:.6e}\".format(e) for e in max_errors]\n    rho_formatted = \"{:.6e}\".format(rho)\n    \n    print(f\"[[{','.join(errors_formatted)}],{rho_formatted}]\")\n\nsolve()\n```", "id": "3488482"}, {"introduction": "构建模型是一回事，而确保其预测的可靠性则是另一回事。这项练习聚焦于数值稳定性这一关键概念，探讨插值节点和基函数数量的选择如何影响模型对误差的敏感性。通过这个实践，您将学会量化和控制代理模型中潜在的误差放大效应，这是构建稳健模型的重要一步。", "problem": "考虑一个用于数值相对论波形的代理模型设置，其中使用一个降阶基矩阵 $U \\in \\mathbb{R}^{m \\times r}$ 从一组选定的节点 $\\mathcal{T} = (t_{i_1}, \\dots, t_{i_r})$ 重构波形样本，这些节点索引了基的行。基于经验插值的重构由方形插值子矩阵 $U(\\mathcal{T}) \\in \\mathbb{R}^{r \\times r}$ 控制，该子矩阵通过将 $U$ 限制在由 $\\mathcal{T}$ 给出的行上形成。经验插值方法 (Empirical Interpolation Method, EIM) 用于通过 $U(\\mathcal{T}) c = w(\\mathcal{T})$ 计算系数 $c \\in \\mathbb{R}^r$，从而重构波形近似 $U c$。我们关心的是由于 $U(\\mathcal{T})$ 的条件数和 $U$ 的算子范数，导致 $w(\\mathcal{T})$ 中的节点误差在重构近似 $U c$ 中被放大的情况。\n\n从以下基本概念开始：\n- 奇异值分解 (Singular Value Decomposition, SVD)：对于矩阵 $A$，其奇异值用 $\\sigma_{\\max}(A)$ 和 $\\sigma_{\\min}(A)$ 分别表示最大和最小奇异值。谱范数为 $\\lVert A \\rVert_2 = \\sigma_{\\max}(A)$，如果 $A$ 可逆，则 $\\lVert A^{-1} \\rVert_2 = 1/\\sigma_{\\min}(A)$。\n- 2-范数条件数：对于可逆矩阵 $A$，$\\kappa_2(A) = \\lVert A \\rVert_2 \\lVert A^{-1} \\rVert_2 = \\sigma_{\\max}(A)/\\sigma_{\\min}(A)$。\n- 线性误差传播：对于节点上的扰动 $\\delta w(\\mathcal{T})$，导致的系数误差满足 $\\delta c = U(\\mathcal{T})^{-1} \\delta w(\\mathcal{T})$，重构波形误差为 $U \\delta c$。因此，节点误差在重构近似中的放大因子的一个界为 $G = \\lVert U \\rVert_2 \\lVert U(\\mathcal{T})^{-1} \\rVert_2$。\n\n任务：给定 $U$ 和一个有序节点集 $\\mathcal{T}$，对于截断 $k = 1, 2, \\dots, r$，计算方形插值矩阵 $U_k(\\mathcal{T}_k)$ 的条件数，其中 $U_k$ 是将 $U$ 截断至其前 $k$ 列的结果，$\\mathcal{T}_k$ 是将 $\\mathcal{T}$ 截断至其前 $k$ 个索引的结果。然后，选择最大的截断 $k$，使得放大因子 $G_k = \\lVert U_k \\rVert_2 \\lVert U_k(\\mathcal{T}_k)^{-1} \\rVert_2$ 严格小于 $10$。对于选定的截断，还需报告 2-范数条件数 $\\kappa_2(U_k(\\mathcal{T}_k)) = \\sigma_{\\max}(U_k(\\mathcal{T}_k))/\\sigma_{\\min}(U_k(\\mathcal{T}_k))$。如果 $U_k(\\mathcal{T}_k)$ 是奇异的，则将 $\\lVert U_k(\\mathcal{T}_k)^{-1} \\rVert_2$ 和 $\\kappa_2(U_k(\\mathcal{T}_k))$ 视为 $+\\infty$。\n\n为使问题在纯数学意义上具体且普遍适用，请使用如下定义的离散时间网格和范德蒙型降阶基。对于每个测试用例，\n- 设 $m$ 为采样时间点数，$r$ 为降阶基的大小。\n- 定义一个均匀网格 $t_i = \\frac{i}{m-1}$，其中 $i = 0, 1, \\dots, m-1$。\n- 定义降阶基矩阵 $U \\in \\mathbb{R}^{m \\times r}$，其元素为 $U_{i,j} = t_i^j$，其中列索引 $j = 0, 1, \\dots, r-1$。\n- 定义有序节点集 $\\mathcal{T}$ 为 $\\{0,1,\\dots,m-1\\}$ 中 $r$ 个不同整数索引的列表。\n\n对于每个测试用例，您必须计算满足 $G_k  10$ 的最大截断 $k$，以及相应的条件数 $\\kappa_2(U_k(\\mathcal{T}_k))$ 和放大因子 $G_k$。全程使用谱范数（2-范数）。将浮点数输出四舍五入到六位小数。\n\n测试套件：\n- 用例 1: $m = 12$, $r = 6$, $\\mathcal{T} = [0,2,4,6,8,10]$.\n- 用例 2: $m = 12$, $r = 6$, $\\mathcal{T} = [0,1,2,3,4,5]$.\n- 用例 3: $m = 20$, $r = 10$, $\\mathcal{T} = [10,11,12,13,14,15,16,17,18,19]$.\n- 用例 4: $m = 20$, $r = 10$, $\\mathcal{T} = [19,18,17,16,15,14,13,12,11,10]$.\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是 $[k, \\kappa, G]$ 形式的列表，其中 $k$ 是一个整数，$\\kappa$ 和 $G$ 是四舍五入到六位小数的浮点数。例如，最终输出应类似于 $[[k_1,\\kappa_1,G_1],[k_2,\\kappa_2,G_2],[k_3,\\kappa_3,G_3],[k_4,\\kappa_4,G_4]]$。", "solution": "目标是针对几个测试用例，确定降阶基近似的最大截断水平 `$k$`，该截断水平能保持指定的数值稳定性。这种稳定性由一个放大因子 `$G_k$` 来量化，该因子必须严格小于 `$10$`。对于这个最大的 `$k$`，我们还必须报告相关插值矩阵的条件数 `$\\kappa_2(U_k(\\mathcal{T}_k))$` 和放大因子 `$G_k$`。\n\n解决方案的流程是实现问题陈述中描述的定义和算法。对于由参数 `$m$`（时间样本数）、`$r$`（基的大小）和 `$\\mathcal{T}$`（节点索引的有序集）定义的每个测试用例，我们执行以下步骤。\n\n首先，我们构建必要的数学对象。通过 `$t_i = \\frac{i}{m-1}$` 定义一个均匀时间网格 `$\\{t_i\\}_{i=0}^{m-1}$`。利用这个网格，我们构建 `$m \\times r$` 的基矩阵 `$U$`，其元素由 `$U_{i,j} = t_i^j$` 给出，其中 `$i \\in \\{0, \\dots, m-1\\}$` 且 `$j \\in \\{0, \\dots, r-1\\}$`。这是一个范德蒙型矩阵。\n\n接下来，我们从 `$k=1$` 到 `$k=r$` 遍历所有可能的截断水平。对于每个 `$k$`，我们将截断基矩阵 `$U_k$` 定义为 `$U$` 的前 `$k$` 列，将截断的有序节点集 `$\\mathcal{T}_k$` 定义为 `$\\mathcal{T}$` 中的前 `$k$` 个索引。这些用于构建方形的 `$k \\times k$` 插值子矩阵 `$U_k(\\mathcal{T}_k)$`，该子矩阵通过选择 `$U_k$` 中对应于 `$\\mathcal{T}_k$` 中索引的行来形成。\n\n任务的核心是计算放大因子 `$G_k$` 和条件数 `$\\kappa_2(U_k(\\mathcal{T}_k))$`。这些量是根据矩阵范数定义的，而通过奇异值分解 (SVD) 计算它们最为可靠。\n放大因子为 `$G_k = \\lVert U_k \\rVert_2 \\lVert U_k(\\mathcal{T}_k)^{-1} \\rVert_2$`。矩阵 `$A$` 的谱范数 `$\\lVert A \\rVert_2$` 是其最大奇异值 `$\\sigma_{\\max}(A)$`。如果 `$A$` 可逆，其逆矩阵的范数 `$\\lVert A^{-1} \\rVert_2$` 是其最小奇异值的倒数，即 `$1/\\sigma_{\\min}(A)$`。\n因此，对于每个 `$k$`，我们计算：\n$1$. `$U_k$` 的 SVD，以找到其最大奇异值，`$\\sigma_{\\max}(U_k) = \\lVert U_k \\rVert_2$`。\n$2$. `$U_k(\\mathcal{T}_k)$` 的 SVD，以找到其最大和最小奇异值，`$\\sigma_{\\max}(U_k(\\mathcal{T}_k))$` 和 `$\\sigma_{\\min}(U_k(\\mathcal{T}_k))$`。\n\n如果 `$U_k(\\mathcal{T}_k)$` 是数值奇异的，其最小奇异值 `$\\sigma_{\\min}(U_k(\\mathcal{T}_k))$` 实际上为零。在这种情况下，根据问题要求，`$\\lVert U_k(\\mathcal{T}_k)^{-1} \\rVert_2$` 和 `$\\kappa_2(U_k(\\mathcal{T}_k))$` 被视为无穷大。在数值计算中，这通过检查 `$\\sigma_{\\min}(U_k(\\mathcal{T}_k))$` 是否低于某个相对于机器精度的小阈值来处理。\n\n如果矩阵不是奇异的，我们计算以下量：\n- 放大因子：`$G_k = \\sigma_{\\max}(U_k) \\cdot \\frac{1}{\\sigma_{\\min}(U_k(\\mathcal{T}_k))}$`\n- 条件数：`$\\kappa_2(U_k(\\mathcal{T}_k)) = \\frac{\\sigma_{\\max}(U_k(\\mathcal{T}_k))}{\\sigma_{\\min}(U_k(\\mathcal{T}_k))}$`\n\n然后我们检查是否 `$G_k  10$`。我们需要找到满足此条件的最大 `$k$`。从 `$k=1$` 到 `$r$` 执行迭代搜索。在迭代过程中，我们跟踪满足条件的最新（因此也是最大）的 `$k$` 值。与这个最终的 `$k$` 对应的 `$\\kappa_2(U_k(\\mathcal{T}_k))$` 和 `$G_k$` 的值被存储下来。可以确定，对于 `$k=1$`，`$G_1 = \\sqrt{m}$`，对于所有测试用例，该值都小于 `$10$`，从而保证解的存在。\n\n最后，对于每个测试用例，收集得到的三元组 `$[k, \\kappa, G]$`，其中浮点数 `$\\kappa$` 和 `$G$` 四舍五入到六位小数。然后，所有测试用例的结果按照规定格式化为单个字符串。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        (12, 6, [0, 2, 4, 6, 8, 10]),\n        (12, 6, [0, 1, 2, 3, 4, 5]),\n        (20, 10, [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]),\n        (20, 10, [19, 18, 17, 16, 15, 14, 13, 12, 11, 10])\n    ]\n\n    all_results = []\n    \n    for m, r, T_nodes in test_cases:\n        # Define the uniform time grid t_i = i/(m-1)\n        t = np.linspace(0.0, 1.0, m)\n        \n        # Define the reduced basis matrix U with U_ij = t_i^j\n        # np.vander with increasing=True matches this definition.\n        U = np.vander(t, N=r, increasing=True)\n        \n        max_k_found = 0\n        final_kappa = np.nan\n        final_G = np.nan\n        \n        # Iterate through all truncations k = 1, ..., r\n        for k in range(1, r + 1):\n            # U_k is the first k columns of U\n            U_k = U[:, :k]\n            \n            # T_k is the first k indices from the ordered node set T\n            T_k_indices = T_nodes[:k]\n            \n            # Form the square interpolation submatrix U_k(T_k)\n            U_k_T_k = U_k[T_k_indices, :]\n            \n            # Compute the 2-norm of U_k (its largest singular value)\n            norm_U_k = np.linalg.norm(U_k, 2)\n            \n            G_k = np.inf\n            kappa_k = np.inf\n            \n            try:\n                # Compute singular values of the interpolation matrix\n                s_U_k_T_k = np.linalg.svd(U_k_T_k, compute_uv=False)\n                \n                sigma_max_val = s_U_k_T_k[0]\n                sigma_min_val = s_U_k_T_k[-1]\n\n                # Check for numerical singularity. A matrix is singular if sigma_min is\n                # close to zero. We use a standard threshold based on machine epsilon.\n                if sigma_min_val  np.finfo(float).eps * sigma_max_val * k:\n                    G_k = np.inf\n                    kappa_k = np.inf\n                else:\n                    # norm(A_inv) = 1/sigma_min(A)\n                    norm_inv_U_k_T_k = 1.0 / sigma_min_val\n                    # G_k = ||U_k|| * ||U_k(T_k)^-1||\n                    G_k = norm_U_k * norm_inv_U_k_T_k\n                    # kappa_k = sigma_max / sigma_min\n                    kappa_k = sigma_max_val / sigma_min_val\n\n            except np.linalg.LinAlgError:\n                # This case handles matrices that are exactly singular,\n                # though svd is robust and usually won't raise this.\n                G_k = np.inf\n                kappa_k = np.inf\n            \n            # Check if the amplification factor is below the threshold\n            if G_k  10.0:\n                # If so, this k is a candidate. Since we iterate k from 1 to r,\n                # the last one to satisfy the condition will be the maximal k.\n                max_k_found = k\n                final_kappa = kappa_k\n                final_G = G_k\n        \n        all_results.append([max_k_found, final_kappa, final_G])\n\n    # Format the final output string as per requirements\n    result_strings = []\n    for result in all_results:\n        k, kappa, G = result\n        # Format floats to exactly six decimal places\n        result_strings.append(f\"[{k},{kappa:.6f},{G:.6f}]\")\n    \n    # Print the single-line output\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3488481"}, {"introduction": "掌握了基本原理之后，我们现在可以探索如何使代理模型更高效、更精确。这最后一项实践介绍了一种先进的自适应技术，它智能地布置插值节点，将它们集中在波形变化最剧烈的区域。这展示了构建高性能代理模型的一个关键原则：将计算资源分配到最需要的地方。", "problem": "你的任务是在代理模型中，为引力波形的相位实现一种曲率优化的多速率经验插值。其目标是通过根据相位 $\\,\\phi(t)\\,$ 的局部曲率优化节点密度，从而在并合阶段附近分配更多的插值节点，而在旋进阶段分配较少的节点。该实现必须针对一个小的、精心选择的测试套件，生成与时间上均匀节点分配方案的定量误差比较。所有角度必须以弧度表示，所有时间变量必须以秒表示。\n\n基本原理和背景：在数值相对论和引力波建模中，复应变 $\\,h(t)\\,$ 可以表示为 $\\,h(t) = A(t)\\,e^{i\\phi(t)}\\,$，其中 $\\,A(t)\\,$ 是振幅，$\\,\\phi(t)\\,$ 是相位。对于一个足够光滑的函数，其插值误差由其导数控制，这与经典多项式插值和数值分析中的情况类似，即局部插值误差在高曲率（大的 $\\,|\\phi''(t)|\\,$）区域会增加。为了在固定的模型复杂度（即固定的插值节点数）下减少代理模型误差，一种策略是优先在高曲率区域分配节点。本问题专注于构建这样一种节点分配方案并评估其效益。\n\n使用的定义：\n- 令 $\\,t \\in [t_0,t_c]\\,$ 表示时间（单位为秒），其中 $\\,t_c\\,$ 为并合时间。\n- 令 $\\,\\phi(t)\\,$ 表示相位（单位为弧度）。\n- 瞬时引力波频率为 $\\,f(t) = d\\phi/dt\\,$，单位为弧度/秒。\n- 局部曲率的代理是 $\\,w(t) = |\\phi''(t)|^p + \\mu\\,$，其中 $\\,p \\ge 0\\,$ 且 $\\,\\mu  0\\,$ 是一个小的下限值，以避免在低曲率区域出现退化情况。\n\n用于测试的波形相位模型：使用一个合成但有物理动机的旋进-并合频率模型，\n$$\nf(t) = \\alpha \\,\\big(t_c - t + \\varepsilon\\big)^{-3/8}\\,\\left[1 + \\beta \\,\\exp\\!\\left(-\\frac{(t - t_m)^2}{2\\sigma^2}\\right)\\right],\n$$\n其中 $\\,t_m = t_c - \\varepsilon\\,$。相位 $\\,\\phi(t)\\,$ 必须通过数值时间积分获得，\n$$\n\\phi(t)=\\phi_0 + \\int_{t_0}^t f(s)\\,ds,\n$$\n其中 $\\,\\phi_0 = 0\\,$。所有角度单位为弧度，所有时间单位为秒。\n\n多速率节点分配：给定一个时间网格 $\\,\\{t_i\\}_{i=0}^{M-1}\\,$，数值计算 $\\,\\phi(t)\\,$ 及其一阶导数 $\\,\\phi'(t)\\,$ 和二阶导数 $\\,\\phi''(t)\\,$。定义 $\\,w(t) = |\\phi''(t)|^p + \\mu\\,$ 并构建累积分布函数\n$$\n\\mathrm{CDF}(t) = \\frac{\\int_{t_0}^{t} w(s)\\,ds}{\\int_{t_0}^{t_c} w(s)\\,ds}.\n$$\n对于指定的节点数 $\\,N\\,$，通过在均匀分位数 $\\,q_k = \\frac{k}{N-1}\\,$ 处对累积分布函数求逆来选择节点时间 $\\,\\{t_k\\}_{k=0}^{N-1}\\,$，即 $\\,t_k = \\mathrm{CDF}^{-1}(q_k)\\,$，并确保 $\\,t_0\\,$ 和 $\\,t_c\\,$ 被包含在内。使用保形三次样条从这些节点插值 $\\,\\phi(t)\\,$。作为基准，在 $\\,[t_0,t_c]\\,$ 上随时间均匀选择 $\\,N\\,$ 个节点，并用相同的方法插值相位。\n\n性能度量：对于每个测试案例，计算均匀节点和曲率优化节点在整个网格上的最大绝对插值误差，\n$$\nE_{\\mathrm{uniform}} = \\max_i \\left|\\phi(t_i) - \\tilde{\\phi}_{\\mathrm{uniform}}(t_i)\\right|,\n\\qquad\nE_{\\mathrm{curv}} = \\max_i \\left|\\phi(t_i) - \\tilde{\\phi}_{\\mathrm{curv}}(t_i)\\right|.\n$$\n同时报告误差比\n$$\nR = \\frac{E_{\\mathrm{curv}}}{E_{\\mathrm{uniform}}}.\n$$\n所有误差必须以弧度为单位报告。\n\n实现细节：\n- 使用有限差分法进行数值微分来计算 $\\,\\phi'(t)\\,$ 和 $\\,\\phi''(t)\\,$。\n- 使用数值积分来计算 $\\,\\phi(t)\\,$ 和用于节点选择的累积分布函数。\n- 使用保形三次插值方法从所选节点重构 $\\,\\phi(t)\\,$。\n- 使用 $\\,p = 1\\,$ 和 $\\,\\mu = 10^{-12}\\,$。\n\n测试套件和参数：\n- 时域：$\\,t_0 = 0\\,$, $\\,t_c = 1\\,$, 所有案例的网格点数 $\\,M = 2048\\,$。\n- 案例 $\\,1\\,$ (理想情况): $\\,\\alpha = 50\\,$, $\\,\\varepsilon = 0.01\\,$, $\\,\\beta = 1.5\\,$, $\\,\\sigma = 0.03\\,$, $\\,N = 32\\,$。\n- 案例 $\\,2\\,$ (低曲率): $\\,\\alpha = 20\\,$, $\\,\\varepsilon = 0.2\\,$, $\\,\\beta = 0.5\\,$, $\\,\\sigma = 0.1\\,$, $\\,N = 32\\,$。\n- 案例 $\\,3\\,$ (并合附近高曲率): $\\,\\alpha = 80\\,$, $\\,\\varepsilon = 0.005\\,$, $\\,\\beta = 2.5\\,$, $\\,\\sigma = 0.02\\,$, $\\,N = 32\\,$。\n- 案例 $\\,4\\,$ (节点数少的边界情况): $\\,\\alpha = 50\\,$, $\\,\\varepsilon = 0.01\\,$, $\\,\\beta = 1.5\\,$, $\\,\\sigma = 0.03\\,$, $\\,N = 6\\,$。\n\n最终输出格式：\n你的程序应生成单行输出，包含一个逗号分隔的列表，其中是按案例划分的结果，每个案例贡献一个三元列表 $\\,\\big[E_{\\mathrm{uniform}},E_{\\mathrm{curv}},R\\big]\\,$，其中误差的单位为弧度，比率为无量纲。输出必须是单一的、不含空格的Python风格列表的列表，例如，\n$$\n\\texttt{[[e1\\_u,e1\\_c,r1],[e2\\_u,e2\\_c,r2],[e3\\_u,e3\\_c,r3],[e4\\_u,e4\\_c,r4]]}.\n$$", "solution": "该问题要求实现并评估一种用于插值引力波相位的曲率优化节点放置策略，这是构建代理模型中的一项常见任务。其目标是证明，与标准的节点均匀分布相比，根据函数的局部曲率非均匀地分布固定数量的插值节点 $N$，可以得到更精确的表示。解决方案通过几个清晰的逻辑阶段进行：基准真相生成、曲率估计、节点放置、插值和误差分析。\n\n首先，生成波形相位 $\\phi(t)$ 的一个高保真“基准真相”表示。问题提供了一个在时间区间 $t \\in [t_0, t_c]$ 上的瞬时引力波频率 $f(t)$ 的合成模型：\n$$\nf(t) = \\alpha \\,\\big(t_c - t + \\varepsilon\\big)^{-3/8}\\,\\left[1 + \\beta \\,\\exp\\!\\left(-\\frac{(t - t_m)^2}{2\\sigma^2}\\right)\\right]\n$$\n此处，$t_m = t_c - \\varepsilon$，且 $\\{\\alpha, \\beta, \\varepsilon, \\sigma\\}$ 是定义波形具体形状的参数。该频率函数在一个大小为 $M=2048$ 的精细、均匀时间网格 $\\{t_i\\}_{i=0}^{M-1}$ 上进行求值。然后通过对频率进行数值积分来获得波形相位 $\\phi(t)$，初始条件为 $\\phi(t_0) = \\phi_0 = 0$。\n$$\n\\phi(t) = \\int_{t_0}^t f(s)\\,ds\n$$\n该积分使用一种数值积分方法执行，具体来说是累积梯形法则，以生成离散的基准真相相位 $\\phi(t_i)$。\n\n优化策略的核心在于将插值节点密度与函数的曲率关联起来。定义了一个局部曲率的代理，即权重函数 $w(t)$：\n$$\nw(t) = |\\phi''(t)|^p + \\mu\n$$\n问题指定使用 $p=1$ 和一个小的正下限值 $\\mu=10^{-12}$，以确保权重始终非零。为计算 $w(t)$，必须从离散数据 $\\phi(t_i)$ 中估计相位的二阶导数 $\\phi''(t)$。这是通过应用一个数值微分程序（例如二阶中心有限差分格式）两次来实现的：首先对 $\\phi(t_i)$ 应用以获得一阶导数 $\\phi'(t_i)$，然后对 $\\phi'(t_i)$ 应用以获得二阶导数 $\\phi''(t_i)$。\n\n在精细网格上计算出权重函数 $w(t)$ 后，下一步是确定 $N$ 个曲率优化节点的位置。这是通过定义一个基于 $w(t)$ 累积积分的新坐标系来完成的。构建一个累积分布函数 $\\mathrm{CDF}(t)$：\n$$\n\\mathrm{CDF}(t) = \\frac{\\int_{t_0}^{t} w(s)\\,ds}{\\int_{t_0}^{t_c} w(s)\\,ds}\n$$\n这个函数将时间区间 $[t_0, t_c]$ 映射到区间 $[0, 1]$，拉伸了 $w(t)$ 较大的区域。通过在 $[0, 1]$ 中选择均匀间隔的分位数 $q_k = \\frac{k}{N-1}$，并通过对CDF求逆来找到相应的时间，从而找到所需的节点位置 $\\{t_k^{\\text{curv}}\\}_{k=0}^{N-1}$：\n$$\nt_k^{\\text{curv}} = \\mathrm{CDF}^{-1}(q_k)\n$$\n在数值上，通过对从 $t_i$ 到 $\\mathrm{CDF}(t_i)$ 的离散映射使用线性插值，可以高效地处理这个求逆过程。这个过程确保了具有较高曲率（较大的 $w(t)$）的区域被分配更高的节点密度。\n\n为了进行基准比较，还通过简单地将区间 $[t_0, t_c]$ 分成 $N-1$ 个相等的段来生成一组 $N$ 个均匀节点 $\\{t_k^{\\text{unif}}\\}_{k=0}^{N-1}$。\n\n对于这两个节点集（曲率优化和均匀）中的每一个，都会构建一个相位的插值函数。首先通过插值基准真相相位 $\\phi(t_i)$ 来获得节点位置处的相位值 $\\phi(t_k)$。然后，将一个保形分段三次埃尔米特插值多项式 (PCHIP) 拟合到点对 $(t_k, \\phi(t_k))$ 上。选择此方法是为了避免标准高阶多项式插值可能产生的伪振荡，这对于像引力波相位这样的平滑变化函数至关重要。这样就得到了两个插值函数：$\\tilde{\\phi}_{\\mathrm{curv}}(t)$ 和 $\\tilde{\\phi}_{\\mathrm{uniform}}(t)$。\n\n最后，评估每种插值方案的准确性。两个插值函数都在原始的精细时间网格 $\\{t_i\\}$ 上进行求值，并为每种情况计算插值相位与基准真相相位之间的最大绝对误差：\n$$\nE_{\\mathrm{uniform}} = \\max_i \\left|\\phi(t_i) - \\tilde{\\phi}_{\\mathrm{uniform}}(t_i)\\right|\n$$\n$$\nE_{\\mathrm{curv}} = \\max_i \\left|\\phi(t_i) - \\tilde{\\phi}_{\\mathrm{curv}}(t_i)\\right|\n$$\n计算无量纲比率 $R = E_{\\mathrm{curv}} / E_{\\mathrm{uniform}}$ 以量化相对性能。若 $R  1$，则表示曲率优化的节点放置提高了准确性。对指定的四个测试案例中的每一个都重复整个过程，并将结果编译成所需的输出格式。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the execution for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {'alpha': 50, 'epsilon': 0.01, 'beta': 1.5, 'sigma': 0.03, 'N': 32},\n        # Case 2 (low curvature)\n        {'alpha': 20, 'epsilon': 0.2, 'beta': 0.5, 'sigma': 0.1, 'N': 32},\n        # Case 3 (high curvature near merger)\n        {'alpha': 80, 'epsilon': 0.005, 'beta': 2.5, 'sigma': 0.02, 'N': 32},\n        # Case 4 (boundary with few nodes)\n        {'alpha': 50, 'epsilon': 0.01, 'beta': 1.5, 'sigma': 0.03, 'N': 6},\n    ]\n\n    results = []\n    for params in test_cases:\n        e_unif, e_curv, r = solve_case(**params)\n        results.append([e_unif, e_curv, r])\n    \n    # Format the output as a Python-style list of lists string with no spaces.\n    print(str(results).replace(\" \", \"\"))\n\ndef solve_case(alpha, epsilon, beta, sigma, N):\n    \"\"\"\n    Solves a single case for given waveform and interpolation parameters.\n    \"\"\"\n    # General parameters from the problem statement\n    t0 = 0.0\n    tc = 1.0\n    M = 2048\n    p = 1.0\n    mu = 1e-12\n\n    # Step 1: Generate the high-resolution \"ground truth\" waveform phase\n    t_fine = np.linspace(t0, tc, M)\n    t_m = tc - epsilon\n    \n    # Frequency model\n    f_t = alpha * (tc - t_fine + epsilon)**(-3.0/8.0) * \\\n          (1.0 + beta * np.exp(-(t_fine - t_m)**2 / (2.0 * sigma**2)))\n\n    # Phase model via numerical integration\n    phi_t = cumulative_trapezoid(f_t, x=t_fine, initial=0.0)\n\n    # Step 2: Compute curvature proxy\n    phi_prime_t = np.gradient(phi_t, t_fine)\n    phi_double_prime_t = np.gradient(phi_prime_t, t_fine)\n    w_t = np.abs(phi_double_prime_t)**p + mu\n\n    # Step 3: Curvature-optimized node placement\n    # Form the CDF from the weight function\n    cdf_integral = cumulative_trapezoid(w_t, x=t_fine, initial=0.0)\n    cdf_t = cdf_integral / cdf_integral[-1]\n    \n    # Invert the CDF at uniform quantiles to find node locations\n    quantiles = np.linspace(0.0, 1.0, N)\n    t_nodes_curv = np.interp(quantiles, cdf_t, t_fine)\n\n    # Step 4: Uniform node placement (baseline)\n    t_nodes_unif = np.linspace(t0, tc, N)\n\n    # Step 5: Interpolation and Error Calculation\n    \n    # 5a. Uniform nodes\n    phi_nodes_unif = np.interp(t_nodes_unif, t_fine, phi_t)\n    interp_unif = PchipInterpolator(t_nodes_unif, phi_nodes_unif)\n    phi_reconstructed_unif = interp_unif(t_fine)\n    e_uniform = np.max(np.abs(phi_t - phi_reconstructed_unif))\n\n    # 5b. Curvature-optimized nodes\n    phi_nodes_curv = np.interp(t_nodes_curv, t_fine, phi_t)\n    interp_curv = PchipInterpolator(t_nodes_curv, phi_nodes_curv)\n    phi_reconstructed_curv = interp_curv(t_fine)\n    e_curv = np.max(np.abs(phi_t - phi_reconstructed_curv))\n\n    # 5c. Error ratio\n    ratio = e_curv / e_uniform if e_uniform != 0 else float('inf')\n\n    return e_uniform, e_curv, ratio\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3488485"}]}