{"hands_on_practices": [{"introduction": "检验广义相对论的第一步是学会如何量化地比较引力波信号。本练习将指导你计算两个波形模型之间的“失配”（mismatch），这是一个基于噪声加权内积的关键指标。通过亲手实现这一核心数据分析工具，你将深入理解波形模型的微小差异如何转化为可观测的区别。[@problem_id:3488789]", "problem": "考虑两个频域的旋进-并合-铃振 (IMR) 引力波模型，记为 $h_1(f)$ 和 $h_2(f)$，它们描述了一个由分量质量为 $m_1$ 和 $m_2$（以太阳质量为单位）以及无量纲对齐自旋为 $\\chi_1$ 和 $\\chi_2$ 构成的准圆、非进动双星系统。设两个信号 $a$ 和 $b$ 之间的内积定义为\n$$\n(a|b) = 4\\,\\Re \\int_0^\\infty \\frac{\\tilde a(f)\\,\\tilde b^*(f)}{S_n(f)}\\,df,\n$$\n其中 $S_n(f)$ 是探测器的单边噪声功率谱密度，波浪号表示傅里叶变换。在对恒定相移 $\\phi$ 和时间平移 $t$ 进行最大化后，$h_1$ 和 $h_2$ 之间的归一化重叠为\n$$\n\\mathcal{O} = \\max_{\\phi,t} \\frac{(h_1|h_2)}{\\sqrt{(h_1|h_1)\\,(h_2|h_2)}},\n$$\n失配则为 $\\mathcal{M} = 1 - \\mathcal{O}$。\n\n您将使用以下具有物理动机且自洽的设置，计算四个测试案例的 $\\mathcal{M}$：\n\n1. 频率网格和采样：\n   - 使用采样率 $f_{\\mathrm{samp}} = 4096$ Hz 和离散傅里叶变换长度 $N = 16384$。\n   - 频率分辨率为 $\\Delta f = f_{\\mathrm{samp}}/N$，奈奎斯特频率为 $f_{\\mathrm{Nyq}} = f_{\\mathrm{samp}}/2$。\n   - 定义低频截断 $f_{\\mathrm{low}} = 20$ Hz；对于 $f  f_{\\mathrm{low}}$，波形振幅必须设置为零。\n\n2. 噪声功率谱密度：\n   - 使用以下对 Advanced Laser Interferometer Gravitational-Wave Observatory (Advanced LIGO) 设计灵敏度曲线的解析、正定近似：\n     $$\n     S_n(f) = S_0\\left[\\left(\\frac{f_0}{f}\\right)^4 + 1 + \\left(\\frac{f}{f_0}\\right)^2\\right],\n     $$\n     其中 $S_0 = 10^{-46}$ 且 $f_0 = 100$ Hz。此形式捕捉了低频段的上升、 $f_0$ 附近的最小值以及高频段的衰退。\n\n3. IMR 模型：\n   - 通用定义：\n     - 使用 $M_\\odot = 4.925491\\times 10^{-6}$ s 将太阳质量转换为几何时间单位，因此总质量（以秒为单位）为 $M = (m_1+m_2)\\,M_\\odot$。\n     - 对称质量比为 $\\eta = \\frac{m_1 m_2}{(m_1+m_2)^2}$。\n     - 有效对齐自旋为 $\\chi_{\\mathrm{eff}} = \\frac{m_1 \\chi_1 + m_2 \\chi_2}{m_1+m_2}$。\n     - 顺行的 Kerr 黑洞最内稳定圆轨道 (ISCO) 半径（以 $M$ 为单位）为\n       $$\n       r_{\\mathrm{ISCO}} = 3 + Z_2 - \\mathrm{sign}(a)\\,\\sqrt{(3 - Z_1)\\left(3 + Z_1 + 2 Z_2\\right)},\n       $$\n       其中 $a = \\chi_{\\mathrm{eff}}$，\n       $$\n       Z_1 = 1 + (1-a^2)^{1/3}\\left[(1+a)^{1/3} + (1-a)^{1/3}\\right],\\quad\n       Z_2 = \\sqrt{3a^2 + Z_1^2}.\n       $$\n       对应的轨道角频率为\n       $$\n       \\Omega_{\\mathrm{ISCO}} = \\frac{1}{M\\left(r_{\\mathrm{ISCO}}^{3/2} + a\\right)},\n       $$\n       引力波 ISCO 频率为 $f_{\\mathrm{ISCO}} = \\Omega_{\\mathrm{ISCO}}/(2\\pi)$。对于无自旋情况，使用 $a=0$。\n   - 振幅模型（适用于两个模型，但截断选择不同）：\n     $$\n     A(f) = f^{-7/6}\\,\\exp\\left[-\\left(\\frac{f}{f_{\\mathrm{cut}}}\\right)^p\\right],\n     $$\n     其中 $p>0$。为模型1选择 $p=4$，为模型2选择 $p=3$。这种指数锥化处理对旋进振幅进行了正则化，并模拟了并合-铃振阶段的抑制效应。\n   - 相位模型：\n     - 使用领头阶后牛顿旋进相标度，\n       $$\n       \\psi_{\\mathrm{LO}}(f) = \\frac{3}{128\\,\\eta}\\left(\\pi M f\\right)^{-5/3},\n       $$\n       该标度捕捉了主要的啁啾行为。\n     - 模型1相位：$\\psi_1(f) = \\psi_{\\mathrm{LO}}(f)$。\n     - 模型2相位：$\\psi_2(f) = \\psi_{\\mathrm{LO}}(f) + \\delta\\left(\\frac{f}{f_{\\mathrm{ISCO}}^{\\mathrm{(NS)}}}\\right)^2$，其中 $f_{\\mathrm{ISCO}}^{\\mathrm{(NS)}}$ 使用 $a=0$ 计算，$\\delta = 0.1$ 弧度，引入一个小的、具有物理动机的高频修正，以表示并合附近建模的差异。\n   - 截断频率：\n     - 模型1使用依赖于自旋的截断 $f_{\\mathrm{cut}} = 1.3\\,f_{\\mathrm{ISCO}}(a=\\chi_{\\mathrm{eff}})$。\n     - 模型2使用无自旋的截断 $f_{\\mathrm{cut}} = 1.3\\,f_{\\mathrm{ISCO}}(a=0)$。\n\n   于是，频域波形为\n   $$\n   h_1(f) = A_1(f)\\,e^{i\\psi_1(f)},\\qquad h_2(f) = A_2(f)\\,e^{i\\psi_2(f)}.\n   $$\n\n4. 对相位和时间的最大化：\n   - 恒定相移 $\\phi$ 使 $h_2(f)$ 乘以 $e^{i\\phi}$；时间平移 $t$ 使其乘以 $e^{i2\\pi f t}$。\n   - 证明对 $\\phi$ 的最大化会得到复数相关的模，而对 $t$ 的最大化对应于找到单边、噪声加权的互谱的离散傅里叶逆变换的最大模。在数值上，使用均匀频率网格 $f_k = k\\,\\Delta f$，用离散和来近似积分。对于时间最大化，在与 $f_{\\mathrm{samp}}$ 和 $N$ 相关联的紧凑时间网格上评估离散傅里叶逆变换，并取其最大模。\n\n5. 计算细节：\n   - 内积应通过在 $f\\in[0,f_{\\mathrm{Nyq}}]$ 上的黎曼和来近似，对于 $f  f_{\\mathrm{low}}$，被积函数为零。\n   - 您需要对四个不同的、物理上合理的双星系统参数集重复此计算：\n     1. $m_1 = 30.0$, $m_2 = 30.0$, $\\chi_1 = 0.2$, $\\chi_2 = 0.2$\n     2. $m_1 = 15.0$, $m_2 = 10.0$, $\\chi_1 = 0.5$, $\\chi_2 = -0.3$\n     3. $m_1 = 1.4$, $m_2 = 1.3$, $\\chi_1 = 0.02$, $\\chi_2 = -0.01$\n     4. $m_1 = 35.0$, $m_2 = 20.0$, $\\chi_1 = 0.95$, $\\chi_2 = 0.8$\n\n您的最终输出必须是一个包含四个失配值的单行，格式为一个用方括号括起来的逗号分隔列表。值必须是浮点数。", "solution": "用户提供了一个引力波数据分析领域的问题，该问题要求计算两个唯象的旋进-并合-铃振 (IMR) 波形模型之间的失配。在尝试求解之前，该问题需要根据严格的科学和逻辑标准进行验证。\n\n### 步骤 1：问题验证\n\n问题陈述提供了一套全面且自洽的定义、方程和参数。\n- **已知条件**：\n    - **模型**：两个频域模型 $h_1(f)$ 和 $h_2(f)$，用于描述参数为 $(m_1, m_2, \\chi_1, \\chi_2)$ 的非进动双星系统。\n    - **内积**：$(a|b) = 4\\,\\Re \\int_0^\\infty \\frac{\\tilde a(f)\\,\\tilde b^*(f)}{S_n(f)}\\,df$。\n    - **重叠和失配**：$\\mathcal{O} = \\max_{\\phi,t} \\frac{(h_1|h_2)}{\\sqrt{(h_1|h_1)\\,(h_2|h_2)}}$，以及 $\\mathcal{M} = 1 - \\mathcal{O}$。\n    - **数值设置**：$f_{\\mathrm{samp}} = 4096$ Hz, $N = 16384$, $\\Delta f = f_{\\mathrm{samp}}/N$, $f_{\\mathrm{Nyq}} = f_{\\mathrm{samp}}/2$, $f_{\\mathrm{low}} = 20$ Hz。\n    - **噪声功率谱密度 (PSD)**：$S_n(f) = S_0[ (f_0/f)^4 + 1 + (f/f_0)^2 ]$，其中 $S_0 = 10^{-46}$ 且 $f_0 = 100$ Hz。\n    - **物理常数和定义**：$M_\\odot = 4.925491\\times 10^{-6}$ s。提供了总质量 $M$、对称质量比 $\\eta$ 和有效自旋 $\\chi_{\\mathrm{eff}}$ 的定义。\n    - **ISCO 频率**：给出了一套完整的基于 Kerr 度规 ISCO 半径计算 $f_{\\mathrm{ISCO}}$ 的方程。\n    - **波形模型**：为两个模型定义了振幅 $A(f)$ 和相位 $\\psi(f)$ 的具体函数形式，包括参数选择（模型1为 $p=4$，模型2为 $p=3$）以及相位修正（$\\delta = 0.1$）和截断频率定义的差异。\n    - **最大化过程**：提供了关于如何对相移和时间平移最大化重叠的清晰物理和数值描述，正确地将此过程与对噪声加权互谱进行离散傅里叶逆变换 (IDFT) 联系起来。\n    - **测试案例**：指定了四个不同的、具有物理意义的测试案例。\n\n- **验证结论**：\n    1.  **科学依据充分**：该问题牢固地植根于广义相对论和引力波数据分析的原理。内积、噪声功率谱密度、波形匹配以及后牛顿/唯象模型等概念都是该领域的标准内容。所提供的公式，如 Kerr ISCO 和 LIGO 噪声曲线的公式，都是有物理动机的既定公式。\n    2.  **良态的**：该问题在数学和计算上是明确定义的。所有必要的常数、函数和参数都已提供，使得每个测试案例都能得到唯一的数值结果。\n    3.  **客观性**：问题陈述使用精确、客观的语言，没有歧义或主观论断。\n    4.  **缺陷**：该问题没有任何不合格的缺陷。它在科学上是合理的，完全可形式化、完整、可行、结构良好、非平凡且可验证。\n\n- **结论**：该问题有效。将着手构建解决方案。\n\n### 步骤 2：解法构建\n\n问题的核心是计算失配 $\\mathcal{M} = 1 - \\mathcal{O}$。这需要计算最大化重叠 $\\mathcal{O}$。重叠定义为：\n$$\n\\mathcal{O} = \\frac{\\max_{\\phi, t} (h_1 | h_2')}{\\sqrt{(h_1|h_1)(h_2|h_2)}}\n$$\n其中 $h_2'(f) = h_2(f) e^{i(2\\pi f t + \\phi)}$。\n\n**归一化因子 (分母)：**\n分母包含两个波形的模长。对于一个波形 $h$，其模长的平方由以下公式给出：\n$$\n(h|h) = 4\\Re \\int_0^\\infty \\frac{h(f) h^*(f)}{S_n(f)} df = 4 \\int_0^\\infty \\frac{|h(f)|^2}{S_n(f)} df\n$$\n这些积分将近似为频率网格上的离散黎曼和：\n$$\n(h|h) \\approx 4 \\sum_{k=k_{\\text{low}}}^{k_{\\text{Nyq}}} \\frac{|h(f_k)|^2}{S_n(f_k)} \\Delta f\n$$\n其中 $f_k = k \\Delta f$，$k_{\\text{low}}$ 是对应于 $f_{\\text{low}}$ 的索引。\n\n**最大化的内积 (分子)：**\n分子要求对内积 $(h_1 | h_2')$ 在时间平移 $t$ 和相移 $\\phi$ 上进行最大化。\n$$\n(h_1 | h_2') = 4\\Re \\int_0^\\infty \\frac{h_1(f) (h_2(f)e^{i(2\\pi f t + \\phi)})^*}{S_n(f)} df = 4\\Re \\left[ e^{-i\\phi} \\int_0^\\infty \\frac{h_1(f)h_2^*(f)}{S_n(f)} e^{-i2\\pi f t} df \\right]\n$$\n令复数量 $C(t) = \\int_0^\\infty \\frac{h_1(f)h_2^*(f)}{S_n(f)} e^{-i2\\pi f t} df$。需要最大化的表达式是 $4\\Re[e^{-i\\phi} C(t)]$。对于任意给定的 $t$，通过选择 $e^{-i\\phi}$ 与 $C(t)$ 具有相同的相位，可以对 $\\phi$ 进行最大化，得到最大值为 $4|C(t)|$。然后我们必须对这个值在 $t$ 上进行最大化。最终最大化的内积是 $4 \\max_t |C(t)|$。\n\n函数 $C(t)$ 是单边、噪声加权的互谱 $Q(f) = \\frac{h_1(f)h_2^*(f)}{S_n(f)}$ 的傅里叶逆变换。在计算上，我们可以通过计算离散谱 $Q_k = Q(f_k)$ 的离散傅里叶逆变换 (IDFT) 并找到所得时间序列的最大模，来求得 $\\max_t |C(t)|$。\n单边谱 $Q_k$（对于 $k=0, \\dots, N/2$）的 IDFT 可以通过创建一个长度为 $N$ 的数组，将 $Q_k$ 放入前 $N/2+1$ 个元素，其余补零，然后应用 IDFT 来实现。IDFT 与连续积分之间的关系需要一个缩放因子。\n$$\n\\max_t |C(t)| \\approx \\max_n \\left| \\Delta f \\sum_{k=0}^{N/2} Q_k e^{-i2\\pi kn/N} \\right|\n$$\n像 `numpy` 这样的库中的标准 `ifft` 计算的是 $(1/N) \\sum X_k e^{i2\\pi kn/N}$。为了与我们期望的计算相匹配，我们必须将 `ifft(X)` 的输出乘以 $N \\cdot \\Delta f = f_{\\mathrm{samp}}$。注意指数中符号的差异；这对应于时间反转，但这不影响绝对值的最大值。\n\n**实现步骤：**\n1.  定义一个频率网格 $f_k$，从 $0$ 到 $f_{\\mathrm{Nyq}}$，间距为 $\\Delta f$。\n2.  对于每个测试案例 $(m_1, m_2, \\chi_1, \\chi_2)$：\n    a. 实现一个函数，根据提供的 Kerr 公式计算 $f_{\\mathrm{ISCO}}$。\n    b. 实现一个函数，根据各自不同的振幅和相位规定生成波形 $h_1(f)$ 和 $h_2(f)$，确保当 $f  f_{\\mathrm{low}}$ 时波形为零。\n    c. 在频率网格上计算噪声功率谱密度 $S_n(f)$。\n    d. 使用黎曼和计算模长 $(h_1|h_1)$ 和 $(h_2|h_2)$。\n    e. 计算噪声加权的互谱 $Q(f_k)$。\n    f. 对一个单边的 $Q(f_k)$ 数组（补零至长度 $N$）使用 `numpy.fft.ifft`，并乘以 $f_{\\mathrm{samp}}$ 以获得时间序列。\n    g. 找到该时间序列的最大绝对值 `max_corr`。\n    h. 计算重叠 $\\mathcal{O} = \\frac{4 \\cdot \\text{max\\_corr}}{\\sqrt{(h_1|h_1)(h_2|h_2)}}$。因子 $4$ 会抵消，所以 $\\mathcal{O} = \\frac{\\text{max\\_corr}}{\\sqrt{(\\text{norm}_1/4)(\\text{norm}_2/4)}}$。\n    i. 计算并存储失配 $\\mathcal{M} = 1 - \\mathcal{O}$。\n3.  按规定格式化失配值的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the mismatch between two IMR gravitational-wave models\n    for a set of test cases.\n    \"\"\"\n\n    # --- Physical and Numerical Constants ---\n    M_SUN_S = 4.925491e-6  # Solar mass in seconds (G=c=1 units)\n    F_SAMP = 4096.0         # Sampling rate in Hz\n    N = 16384               # Number of points in the DFT\n    F_LOW = 20.0            # Lower frequency cutoff in Hz\n    S0 = 1e-46              # Noise PSD amplitude\n    F0 = 100.0              # Noise PSD characteristic frequency in Hz\n    DELTA_PHASE = 0.1       # Phase correction parameter in radians\n\n    # --- Helper Functions ---\n\n    def get_isco_freq(m1, m2, spin_a):\n        \"\"\"Calculates the gravitational-wave ISCO frequency.\"\"\"\n        if not -1.0 = spin_a = 1.0:\n            raise ValueError(\"Spin parameter 'a' must be between -1 and 1.\")\n\n        total_mass_sec = (m1 + m2) * M_SUN_S\n\n        if np.isclose(spin_a, 0):\n            r_isco = 6.0\n        else:\n            a_sq = spin_a**2\n            z1 = 1.0 + (1.0 - a_sq)**(1/3) * ((1.0 + spin_a)**(1/3) + (1.0 - spin_a)**(1/3))\n            z2 = np.sqrt(3.0 * a_sq + z1**2)\n            \n            # Ensure argument of sqrt is non-negative to avoid domain errors\n            sqrt_arg = (3.0 - z1) * (3.0 + z1 + 2.0 * z2)\n            r_isco = 3.0 + z2 - np.sign(spin_a) * np.sqrt(max(0, sqrt_arg))\n\n        omega_isco = 1.0 / (total_mass_sec * (r_isco**1.5 + spin_a))\n        f_isco = omega_isco / (2.0 * np.pi)\n        return f_isco\n\n    def get_ligo_psd(freqs):\n        \"\"\"Calculates the analytic Advanced LIGO noise power spectral density.\"\"\"\n        psd = np.full_like(freqs, np.inf)\n        valid_f_mask = freqs > 0\n        f_valid = freqs[valid_f_mask]\n        f_ratio = F0 / f_valid\n        psd[valid_f_mask] = S0 * (f_ratio**4 + 1.0 + (f_valid / F0)**2)\n        return psd\n\n    def generate_waveform(freqs, m1, m2, chi1, chi2, model_type):\n        \"\"\"Generates a frequency-domain waveform model.\"\"\"\n        total_mass_sec = (m1 + m2) * M_SUN_S\n        eta = (m1 * m2) / (m1 + m2)**2\n        chi_eff = (m1 * chi1 + m2 * chi2) / (m1 + m2)\n\n        f_isco_spin = get_isco_freq(m1, m2, chi_eff)\n        f_isco_ns = get_isco_freq(m1, m2, 0.0)\n        \n        if model_type == 1:\n            p, f_cut = 4.0, 1.3 * f_isco_spin\n        elif model_type == 2:\n            p, f_cut = 3.0, 1.3 * f_isco_ns\n        else:\n            raise ValueError(\"model_type must be 1 or 2\")\n\n        h = np.zeros_like(freqs, dtype=np.complex128)\n        \n        # Only compute for f > 0 to avoid singularities\n        mask = freqs > 0\n        f_valid = freqs[mask]\n        \n        # Amplitude\n        amp = f_valid**(-7.0/6.0) * np.exp(-(f_valid / f_cut)**p)\n        \n        # Phase\n        psi_lo = (3.0 / (128.0 * eta)) * (np.pi * total_mass_sec * f_valid)**(-5.0/3.0)\n        psi = psi_lo\n        if model_type == 2:\n            psi_corr = DELTA_PHASE * (f_valid / f_isco_ns)**2\n            psi += psi_corr\n            \n        h[mask] = amp * np.exp(1j * psi)\n        \n        # Apply low-frequency cutoff\n        h[freqs  F_LOW] = 0.0\n        \n        return h\n\n    def calculate_mismatch(params):\n        \"\"\"Computes the mismatch for a single binary system.\"\"\"\n        m1, m2, chi1, chi2 = params\n        \n        delta_f = F_SAMP / N\n        freqs = np.arange(N / 2 + 1) * delta_f\n\n        h1 = generate_waveform(freqs, m1, m2, chi1, chi2, model_type=1)\n        h2 = generate_waveform(freqs, m1, m2, chi1, chi2, model_type=2)\n        Sn = get_ligo_psd(freqs)\n\n        # Denominator of overlap: norm of each waveform\n        integrand1 = np.divide(np.abs(h1)**2, Sn, where=Sn!=0, out=np.zeros_like(Sn))\n        integrand2 = np.divide(np.abs(h2)**2, Sn, where=Sn!=0, out=np.zeros_like(Sn))\n        \n        norm1_sq = np.sum(integrand1) * delta_f\n        norm2_sq = np.sum(integrand2) * delta_f\n\n        # Numerator of overlap: maximized over time and phase\n        cross_spectrum = np.divide(h1 * np.conj(h2), Sn, where=Sn!=0, out=np.zeros_like(Sn, dtype=np.complex128))\n    \n        X = np.zeros(N, dtype=np.complex128)\n        X[:len(cross_spectrum)] = cross_spectrum\n        \n        # IFFT scaling: multiply by N * df = f_samp to match integral def.\n        # This finds max_t | integral(Q(f) exp(i 2pi f t) df) |\n        time_series = np.fft.ifft(X) * F_SAMP\n        max_corr = np.max(np.abs(time_series))\n        \n        # Final overlap and mismatch calculation\n        # Factors of 4 from inner product definition cancel out\n        denominator = np.sqrt(norm1_sq * norm2_sq)\n        if denominator == 0:\n            return 1.0 # Mismatch is 1 if signals have no power in band\n        \n        overlap = max_corr / denominator\n        mismatch = 1.0 - overlap\n        return mismatch\n    \n    # --- Main Execution Logic ---\n    \n    test_cases = [\n        (30.0, 30.0, 0.2, 0.2),       # Case 1\n        (15.0, 10.0, 0.5, -0.3),      # Case 2\n        (1.4, 1.3, 0.02, -0.01),     # Case 3\n        (35.0, 20.0, 0.95, 0.8),       # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        mismatch_val = calculate_mismatch(case)\n        results.append(f\"{mismatch_val:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3488789"}, {"introduction": "广义相对论的一个关键预言是，整个并合过程——从旋进到铃振——都应是自洽的。本练习将引导你实现一个简化的旋进-并合-铃振（IMR）一致性检验，这是检验GR的支柱性方法之一。你将通过计算贝叶斯因子，亲身体验如何用统计证据来判断由信号不同部分推断出的黑洞性质是否相互矛盾。[@problem_id:3488813]", "problem": "实现一个完整且可运行的程序，该程序使用一个合成数据集，通过在旋进和铃振推断中传播测量不确定性，并计算旋进预测的最终黑洞自旋与铃振推断的最终黑洞自旋之间的一致性与不一致性假设的贝叶斯因子，来执行一个简化的广义相对论 (GR) 的旋进-并合-铃振 (IMR) 一致性检验。完全在引力常数和光速满足 $G = c = 1$ 的几何单位制中进行计算，并以无量纲形式表示所有量。最终输出必须是单行，包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表。列表中的值必须是贝叶斯因子（浮点数）。\n\n您必须在以下物理和统计基础上构建检验，仅使用此处给出的定义和经过充分检验的公式，不得引入超出指定范围的任何额外经验拟合。该检验的目标是残骸黑洞的无量纲最终自旋参数 $a \\in (0,1)$。旋进阶段测量的参数是对称质量比 $\\eta \\in (0,0.25]$，而铃振阶段测量的量是无量纲的主导准简正模 (QNM) 频率 $\\hat{\\omega}$ 和无量纲的阻尼时间 $\\hat{\\tau}$。程序必须计算一个贝叶斯因子，用于量化旋进和铃振与单个共同最终自旋 $a$ 一致的假设（假设 $\\mathcal{H}_{\\mathrm{c}}$）相对于旋进和铃振倾向于不同最终自旋的假设（假设 $\\mathcal{H}_{\\mathrm{i}}$）的证据。\n\n使用的基本基础和建模假设：\n- 旋进阶段的总结参数是对称质量比 $\\eta \\equiv \\frac{m_1 m_2}{(m_1 + m_2)^2}$，残骸的无自旋最终自旋由经过充分检验的拟合公式近似：\n$$\na(\\eta) \\equiv a_{\\mathrm{f}}(\\eta) = \\sqrt{12}\\,\\eta - 3.871\\,\\eta^2.\n$$\n- 作为最终自旋 $a$ 的函数，主导的克尔黑洞准简正模（$\\ell = m = 2, n = 0$）的无量纲频率和品质因子由标准的 Berti–Cardoso–Will 拟合给出：\n$$\n\\hat{\\omega}(a) = 1.5251 - 1.1568\\,\\bigl(1 - a\\bigr)^{0.1292}, \\quad\nQ(a) = 0.7000 + 1.4187\\,\\bigl(1 - a\\bigr)^{-0.4990}.\n$$\n- 无量纲的阻尼时间为\n$$\n\\hat{\\tau}(a) = \\frac{2\\,Q(a)}{\\hat{\\omega}(a)}.\n$$\n- 旋进测量模型：对 $\\eta$ 进行单次高斯测量，其均值为 $\\bar{\\eta}$，标准差为 $\\sigma_{\\eta}$。使用在 $\\bar{\\eta}$ 处计算的导数 $\\frac{da}{d\\eta}$，通过线性不确定性传播将此不确定性传播到 $a$，从而得到一个高斯分布 $a_{\\mathrm{I}} \\sim \\mathcal{N}(\\mu_{\\mathrm{I}}, \\sigma_{\\mathrm{I}}^2)$，其中 $\\mu_{\\mathrm{I}} = a(\\bar{\\eta})$ 且 $\\sigma_{\\mathrm{I}} = \\left|\\frac{da}{d\\eta}(\\bar{\\eta})\\right| \\sigma_{\\eta}$。\n- 铃振测量模型：对 $\\mathbf{y} \\equiv \\bigl(\\hat{\\omega}, \\hat{\\tau}\\bigr)$ 进行二维高斯测量，其均值为 $\\bar{\\mathbf{y}}$，对角协方差为 $\\Sigma_{\\mathrm{R}} = \\mathrm{diag}(\\sigma_{\\hat{\\omega}}^2, \\sigma_{\\hat{\\tau}}^2)$。通过最小化加权最小二乘失配来推断 $a$：\n$$\n\\chi^2(a) = \\bigl(\\bar{\\mathbf{y}} - \\mathbf{g}(a)\\bigr)^{\\top} \\Sigma_{\\mathrm{R}}^{-1} \\bigl(\\bar{\\mathbf{y}} - \\mathbf{g}(a)\\bigr),\n$$\n其中 $\\mathbf{g}(a) = \\bigl(\\hat{\\omega}(a), \\hat{\\tau}(a)\\bigr)$。将 $a$ 的铃振后验分布近似为高斯分布 $a_{\\mathrm{R}} \\sim \\mathcal{N}(\\mu_{\\mathrm{R}}, \\sigma_{\\mathrm{R}}^2)$，其中 $\\mu_{\\mathrm{R}}$ 是 $\\chi^2(a)$ 在 $a \\in (0,1)$ 上的最小值点，且\n$$\n\\sigma_{\\mathrm{R}}^2 \\approx \\Bigl(J^{\\top} \\Sigma_{\\mathrm{R}}^{-1} J\\Bigr)^{-1}\\Bigr|_{a = \\mu_{\\mathrm{R}}},\n$$\n其中灵敏度向量 $J = \\frac{d\\mathbf{g}}{da} = \\left(\\frac{d\\hat{\\omega}}{da}, \\frac{d\\hat{\\tau}}{da}\\right)$ 在 $a = \\mu_{\\mathrm{R}}$ 处计算。可以使用数值有限差分来计算 $J$。\n- 使用高斯先验进行贝叶斯模型比较：对 $a$ 采用先验分布 $a \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2)$，其均值为 $\\mu_0$，标准差为 $\\sigma_0$，名义上截断至 $(0,1)$ 区间，但为了解析易处理性，使用其未截断的高斯形式。\n- 在一致性假设 $\\mathcal{H}_{\\mathrm{c}}$ 下，两个测量共享相同的 $a$，证据为一维积分：\n$$\nZ_{\\mathrm{c}} = \\int_{-\\infty}^{+\\infty} \\mathcal{N}\\bigl(a; \\mu_{\\mathrm{I}}, \\sigma_{\\mathrm{I}}^2\\bigr)\\,\\mathcal{N}\\bigl(a; \\mu_{\\mathrm{R}}, \\sigma_{\\mathrm{R}}^2\\bigr)\\,\\mathcal{N}\\bigl(a; \\mu_0, \\sigma_0^2\\bigr)\\, da.\n$$\n- 在不一致性假设 $\\mathcal{H}_{\\mathrm{i}}$ 下，旋进和铃振由从相同先验中抽取的独立自旋 $a_{\\mathrm{I}}$ 和 $a_{\\mathrm{R}}$ 控制，因此证据因子分解为：\n$$\nZ_{\\mathrm{i}} = \\left[\\int_{-\\infty}^{+\\infty} \\mathcal{N}\\bigl(a_{\\mathrm{I}}; \\mu_{\\mathrm{I}}, \\sigma_{\\mathrm{I}}^2\\bigr)\\,\\mathcal{N}\\bigl(a_{\\mathrm{I}}; \\mu_0, \\sigma_0^2\\bigr)\\, da_{\\mathrm{I}}\\right]\\,\n\\left[\\int_{-\\infty}^{+\\infty} \\mathcal{N}\\bigl(a_{\\mathrm{R}}; \\mu_{\\mathrm{R}}, \\sigma_{\\mathrm{R}}^2\\bigr)\\,\\mathcal{N}\\bigl(a_{\\mathrm{R}}; \\mu_0, \\sigma_0^2\\bigr)\\, da_{\\mathrm{R}}\\right].\n$$\n- 贝叶斯因子为 $K \\equiv \\frac{Z_{\\mathrm{c}}}{Z_{\\mathrm{i}}}$。\n\n测试套件的合成数据构建：\n- 对每个测试，定义一个真实的对称质量比 $\\eta_{\\mathrm{true}}$，构建真实的最终自旋 $a_{\\mathrm{true}} = a(\\eta_{\\mathrm{true}})$，并定义一个铃振偏差 $\\delta a$ 来设置铃振平均自旋 $a_{\\mathrm{RD}} = a_{\\mathrm{true}} + \\delta a$。\n- 将铃振的平均测量值设置为在 $a_{\\mathrm{RD}}$ 处的无噪声模型值：\n$$\n\\bar{\\hat{\\omega}} = \\hat{\\omega}(a_{\\mathrm{RD}}), \\quad \\bar{\\hat{\\tau}} = \\hat{\\tau}(a_{\\mathrm{RD}}).\n$$\n- 旋进阶段 $\\eta$ 的平均测量值为 $\\bar{\\eta}$，标准差为 $\\sigma_{\\eta}$；按上述规定传播到 $(\\mu_{\\mathrm{I}}, \\sigma_{\\mathrm{I}})$。\n- 使用均值为 $\\mu_0$、标准差为 $\\sigma_0$ 的高斯先验。\n\n数值要求：\n- 实现对 $\\chi^2(a)$ 在 $a \\in (0,1)$ 上的稳健一维最小化，以找到 $\\mu_{\\mathrm{R}}$。\n- 使用小步长的数值中心有限差分来计算 $J$。\n- 以闭合形式计算一维高斯证据积分。\n- 所有量都是无量纲的；不需要物理单位转换。\n- 您的程序必须生成单行输出，其中包含所有测试用例的贝叶斯因子，格式为用方括号括起来的逗号分隔列表，例如 $[\\text{value}_1,\\text{value}_2,\\text{value}_3]$。\n\n先验规范（所有测试通用）：\n- $\\mu_0 = 0.7$，\n- $\\sigma_0 = 0.3$。\n\n测试套件：\n- 测试 $1$（理想路径，一致，类等质量）：\n  - $\\eta_{\\mathrm{true}} = 0.25$，$\\delta a = 0.0$，\n  - $\\bar{\\eta} = 0.248$，$\\sigma_{\\eta} = 0.004$，\n  - $\\sigma_{\\hat{\\omega}} = 0.003$，$\\sigma_{\\hat{\\tau}} = 0.2$。\n- 测试 $2$（不一致的铃振偏差，中等质量比）：\n  - $\\eta_{\\mathrm{true}} = 0.20$，$\\delta a = 0.10$，\n  - $\\bar{\\eta} = 0.202$，$\\sigma_{\\eta} = 0.004$，\n  - $\\sigma_{\\hat{\\omega}} = 0.003$，$\\sigma_{\\hat{\\tau}} = 0.2$。\n- 测试 $3$（弱旋进和强铃振的边缘情况）：\n  - $\\eta_{\\mathrm{true}} = 0.24$，$\\delta a = 0.0$，\n  - $\\bar{\\eta} = 0.235$，$\\sigma_{\\eta} = 0.020$，\n  - $\\sigma_{\\hat{\\omega}} = 0.001$，$\\sigma_{\\hat{\\tau}} = 0.05$。\n\n最终输出格式：\n- 您的程序必须向标准输出打印且仅打印一行：一个形式为 $[K_1,K_2,K_3]$ 的列表，其中 $K_i$ 是按上述规定为测试 $i$ 计算出的贝叶斯因子。不允许有多余的空格或文本。", "solution": "我们首先对各个量以及从测量到贝叶斯因子的流程进行形式化。所有的数学符号和数字都用 LaTeX 表示。\n\n定义和测量模型：\n- 对称质量比为 $\\eta = \\frac{m_1 m_2}{(m_1 + m_2)^2}$，且满足 $\\eta \\in (0, 0.25]$。对于无自旋的前身天体，最终的克尔自旋 $a$ 由经过充分检验的关系式近似：\n$$\na(\\eta) = \\sqrt{12}\\,\\eta - 3.871\\,\\eta^2,\n$$\n当 $\\eta = 0.25$ 时，该式得出 $a \\approx 0.686$。\n\n- 作为最终自旋 $a$ 的函数，主导的克尔准简正模 (QNM) 的无量纲频率和品质因子由以下公式给出：\n$$\n\\hat{\\omega}(a) = 1.5251 - 1.1568 \\bigl(1-a\\bigr)^{0.1292}, \\quad\nQ(a) = 0.7000 + 1.4187 \\bigl(1-a\\bigr)^{-0.4990},\n$$\n无量纲的阻尼时间为：\n$$\n\\hat{\\tau}(a) = \\frac{2 Q(a)}{\\hat{\\omega}(a)}.\n$$\n\n- 旋进测量：将一个均值为 $\\bar{\\eta}$、标准差为 $\\sigma_{\\eta}$ 的关于 $\\eta$ 的高斯测量通过线性化传播为一个关于 $a$ 的高斯估计。我们计算均值\n$$\n\\mu_{\\mathrm{I}} = a(\\bar{\\eta}),\n$$\n和标准差\n$$\n\\sigma_{\\mathrm{I}} = \\left|\\frac{da}{d\\eta}(\\bar{\\eta})\\right| \\sigma_{\\eta}, \\quad \\frac{da}{d\\eta} = \\sqrt{12} - 2 \\cdot 3.871 \\, \\eta.\n$$\n这使用了一阶不确定性传播，该方法在 $\\sigma_{\\eta}$ 足够小的情况下是有效的。\n\n- 铃振测量：一个二维高斯观测值 $\\bar{\\mathbf{y}} = \\bigl(\\bar{\\hat{\\omega}}, \\bar{\\hat{\\tau}}\\bigr)$，其对角协方差为 $\\Sigma_{\\mathrm{R}} = \\mathrm{diag}(\\sigma_{\\hat{\\omega}}^2, \\sigma_{\\hat{\\tau}}^2)$，通过映射 $\\mathbf{g}(a) = \\bigl(\\hat{\\omega}(a), \\hat{\\tau}(a)\\bigr)$ 为参数 $a$ 提供信息。我们定义失配\n$$\n\\chi^2(a) = \\bigl(\\bar{\\mathbf{y}} - \\mathbf{g}(a)\\bigr)^{\\top} \\Sigma_{\\mathrm{R}}^{-1} \\bigl(\\bar{\\mathbf{y}} - \\mathbf{g}(a)\\bigr),\n$$\n并选择\n$$\n\\mu_{\\mathrm{R}} = \\operatorname*{arg\\,min}_{a \\in (0,1)} \\chi^2(a).\n$$\n来自局部高斯近似的后验方差由逆费雪信息给出：\n$$\n\\sigma_{\\mathrm{R}}^2 \\approx \\Bigl(J^{\\top} \\Sigma_{\\mathrm{R}}^{-1} J\\Bigr)^{-1} \\Big|_{a = \\mu_{\\mathrm{R}}}, \\quad J = \\frac{d\\mathbf{g}}{da} = \\left(\\frac{d\\hat{\\omega}}{da}, \\frac{d\\hat{\\tau}}{da}\\right).\n$$\n我们使用小步长 $h$ 的中心有限差分来数值计算 $J$，即\n$$\n\\frac{d\\hat{\\omega}}{da}(a) \\approx \\frac{\\hat{\\omega}(a + h) - \\hat{\\omega}(a - h)}{2 h}, \\quad \\frac{d\\hat{\\tau}}{da}(a) \\approx \\frac{\\hat{\\tau}(a + h) - \\hat{\\tau}(a - h)}{2 h}.\n$$\n\n- 贝叶斯模型比较：采用先验 $a \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2)$，其中 $\\mu_0 = 0.7$ 且 $\\sigma_0 = 0.3$。在一致性假设 $\\mathcal{H}_{\\mathrm{c}}$ 下，证据为\n$$\nZ_{\\mathrm{c}} = \\int_{-\\infty}^{+\\infty} \\mathcal{N}\\bigl(a; \\mu_{\\mathrm{I}}, \\sigma_{\\mathrm{I}}^2\\bigr)\\,\\mathcal{N}\\bigl(a; \\mu_{\\mathrm{R}}, \\sigma_{\\mathrm{R}}^2\\bigr)\\,\\mathcal{N}\\bigl(a; \\mu_0, \\sigma_0^2\\bigr)\\, da.\n$$\n在不一致性假设 $\\mathcal{H}_{\\mathrm{i}}$ 下，对于独立的 $a_{\\mathrm{I}}$ 和 $a_{\\mathrm{R}}$，证据因子分解为：\n$$\nZ_{\\mathrm{i}} = \\left[\\int_{-\\infty}^{+\\infty} \\mathcal{N}\\bigl(a_{\\mathrm{I}}; \\mu_{\\mathrm{I}}, \\sigma_{\\mathrm{I}}^2\\bigr)\\,\\mathcal{N}\\bigl(a_{\\mathrm{I}}; \\mu_0, \\sigma_0^2\\bigr)\\, da_{\\mathrm{I}}\\right]\\,\n\\left[\\int_{-\\infty}^{+\\infty} \\mathcal{N}\\bigl(a_{\\mathrm{R}}; \\mu_{\\mathrm{R}}, \\sigma_{\\mathrm{R}}^2\\bigr)\\,\\mathcal{N}\\bigl(a_{\\mathrm{R}}; \\mu_0, \\sigma_0^2\\bigr)\\, da_{\\mathrm{R}}\\right].\n$$\n\n高斯乘积的闭合形式证据：\n- 关于 $a$ 的高斯函数的乘积仍然是关于 $a$ 的高斯函数。我们定义精度 $\\lambda_{\\mathrm{I}} = \\sigma_{\\mathrm{I}}^{-2}$、$\\lambda_{\\mathrm{R}} = \\sigma_{\\mathrm{R}}^{-2}$ 和 $\\lambda_0 = \\sigma_0^{-2}$。$Z_{\\mathrm{c}}$ 的积分可以通过配方法写出。指数部分的二次型为\n$$\n\\frac{(a - \\mu_{\\mathrm{I}})^2}{\\sigma_{\\mathrm{I}}^2} + \\frac{(a - \\mu_{\\mathrm{R}})^2}{\\sigma_{\\mathrm{R}}^2} + \\frac{(a - \\mu_0)^2}{\\sigma_0^2} = \\Lambda\\, a^2 - 2 b\\, a + c,\n$$\n其中\n$$\n\\Lambda = \\lambda_{\\mathrm{I}} + \\lambda_{\\mathrm{R}} + \\lambda_0, \\quad b = \\lambda_{\\mathrm{I}} \\mu_{\\mathrm{I}} + \\lambda_{\\mathrm{R}} \\mu_{\\mathrm{R}} + \\lambda_0 \\mu_0, \\quad c = \\lambda_{\\mathrm{I}} \\mu_{\\mathrm{I}}^2 + \\lambda_{\\mathrm{R}} \\mu_{\\mathrm{R}}^2 + \\lambda_0 \\mu_0^2.\n$$\n用后验均值 $m = b/\\Lambda$ 进行配方，积分得到\n$$\nZ_{\\mathrm{c}} = \\frac{1}{(2\\pi)\\,\\sigma_{\\mathrm{I}}\\,\\sigma_{\\mathrm{R}}\\,\\sigma_0} \\cdot \\frac{1}{\\sqrt{\\Lambda}} \\cdot \\exp\\left( -\\frac{1}{2}\\left[c - \\frac{b^2}{\\Lambda}\\right] \\right).\n$$\n\n- $Z_{\\mathrm{i}}$ 中的每个因子是两个高斯函数的卷积积分，得到\n$$\n\\int \\mathcal{N}(a; \\mu, \\sigma^2) \\mathcal{N}(a; \\mu_0, \\sigma_0^2)\\, da = \\mathcal{N}(\\mu; \\mu_0, \\sigma^2 + \\sigma_0^2) = \\frac{1}{\\sqrt{2\\pi(\\sigma^2 + \\sigma_0^2)}} \\exp\\left( -\\frac{1}{2} \\frac{(\\mu - \\mu_0)^2}{\\sigma^2 + \\sigma_0^2} \\right).\n$$\n因此，\n$$\nZ_{\\mathrm{i}} = \\frac{1}{2\\pi \\sqrt{(\\sigma_{\\mathrm{I}}^2 + \\sigma_0^2)(\\sigma_{\\mathrm{R}}^2 + \\sigma_0^2)}} \\exp\\left( -\\frac{1}{2} \\left[ \\frac{(\\mu_{\\mathrm{I}} - \\mu_0)^2}{\\sigma_{\\mathrm{I}}^2 + \\sigma_0^2} + \\frac{(\\mu_{\\mathrm{R}} - \\mu_0)^2}{\\sigma_{\\mathrm{R}}^2 + \\sigma_0^2} \\right] \\right).\n$$\n\n贝叶斯因子：\n- 贝叶斯因子为\n$$\nK = \\frac{Z_{\\mathrm{c}}}{Z_{\\mathrm{i}}}.\n$$\n代入上面推导出的表达式可以得到一个闭合形式，可以直接从 $(\\mu_{\\mathrm{I}}, \\sigma_{\\mathrm{I}})$、$(\\mu_{\\mathrm{R}}, \\sigma_{\\mathrm{R}})$ 和 $(\\mu_0, \\sigma_0)$ 计算得出。\n\n每个测试的合成数据生成：\n- 对于每个测试，我们设置 $\\eta_{\\mathrm{true}}$ 并计算 $a_{\\mathrm{true}} = a(\\eta_{\\mathrm{true}})$。应用一个铃振偏差 $\\delta a$ 来构建铃振平均自旋 $a_{\\mathrm{RD}} = a_{\\mathrm{true}} + \\delta a$。然后我们将铃振均值设置为模型的预测值\n$$\n\\bar{\\hat{\\omega}} = \\hat{\\omega}(a_{\\mathrm{RD}}), \\quad \\bar{\\hat{\\tau}} = \\hat{\\tau}(a_{\\mathrm{RD}}).\n$$\n旋进阶段 $\\eta$ 的均值给定为 $\\bar{\\eta}$，标准差为 $\\sigma_{\\eta}$，我们通过线性化从中计算出 $\\mu_{\\mathrm{I}}$ 和 $\\sigma_{\\mathrm{I}}$。\n\n算法步骤：\n- 对于每个测试用例，\n  - 计算 $a_{\\mathrm{true}} = a(\\eta_{\\mathrm{true}})$ 和 $a_{\\mathrm{RD}} = a_{\\mathrm{true}} + \\delta a$。\n  - 使用提供的 QNM 拟合公式计算铃振均值 $\\bar{\\hat{\\omega}}$ 和 $\\bar{\\hat{\\tau}}$。\n  - 计算 $\\mu_{\\mathrm{I}} = a(\\bar{\\eta})$ 和 $\\sigma_{\\mathrm{I}} = \\left|\\sqrt{12} - 2\\cdot 3.871 \\, \\bar{\\eta}\\right| \\sigma_{\\eta}$。\n  - 通过在 $a \\in (0,1)$ 上最小化 $\\chi^2(a)$ 来推断 $\\mu_{\\mathrm{R}}$；在 $a = \\mu_{\\mathrm{R}}$ 处使用数值导数计算 $J$，从而计算 $\\sigma_{\\mathrm{R}}^2 \\approx \\bigl(J^{\\top} \\Sigma_{\\mathrm{R}}^{-1} J\\bigr)^{-1}$。\n  - 使用上述闭合形式表达式，以及 $\\mu_0 = 0.7$ 和 $\\sigma_0 = 0.3$，计算 $Z_{\\mathrm{c}}$ 和 $Z_{\\mathrm{i}}$。\n  - 返回 $K = Z_{\\mathrm{c}}/Z_{\\mathrm{i}}$。\n\n测试套件详情：\n- 测试 $1$：$\\eta_{\\mathrm{true}} = 0.25$，$\\delta a = 0.0$，$\\bar{\\eta} = 0.248$，$\\sigma_{\\eta} = 0.004$，$\\sigma_{\\hat{\\omega}} = 0.003$，$\\sigma_{\\hat{\\tau}} = 0.2$。\n- 测试 $2$：$\\eta_{\\mathrm{true}} = 0.20$，$\\delta a = 0.10$，$\\bar{\\eta} = 0.202$，$\\sigma_{\\eta} = 0.004$，$\\sigma_{\\hat{\\omega}} = 0.003$，$\\sigma_{\\hat{\\tau}} = 0.2$。\n- 测试 $3$：$\\eta_{\\mathrm{true}} = 0.24$，$\\delta a = 0.0$，$\\bar{\\eta} = 0.235$，$\\sigma_{\\eta} = 0.020$，$\\sigma_{\\hat{\\omega}} = 0.001$，$\\sigma_{\\hat{\\tau}} = 0.05$。\n\n程序必须将三个测试的贝叶斯因子组合成一个列表，并以 $[K_1,K_2,K_3]$ 的格式精确地打印在同一行上，不得有任何额外文本。\n\n此过程检验了广义相对论 (GR) 的假设，即单个最终自旋参数 $a$ 可以同时解释旋进和铃振的测量结果。大的贝叶斯因子 $K$ 支持一致性，而小的 $K$ 支持不一致性。该设计涵盖了一个理想路径（测试 $1$）、一个有意设置为不一致的场景（测试 $2$）以及一个弱旋进但强铃振信息的边缘情况（测试 $3$）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef final_spin_from_eta(eta: float) -> float:\n    # a(eta) = sqrt(12)*eta - 3.871*eta^2\n    return np.sqrt(12.0) * eta - 3.871 * eta**2\n\ndef da_deta(eta: float) -> float:\n    # derivative of final spin wrt eta: sqrt(12) - 2*3.871*eta\n    return np.sqrt(12.0) - 2.0 * 3.871 * eta\n\ndef omega_hat(a: float) -> float:\n    # Dimensionless QNM frequency fit\n    return 1.5251 - 1.1568 * (1.0 - a)**0.1292\n\ndef Q_factor(a: float) -> float:\n    # Quality factor fit\n    return 0.7000 + 1.4187 * (1.0 - a)**(-0.4990)\n\ndef tau_hat(a: float) -> float:\n    # Dimensionless damping time\n    w = omega_hat(a)\n    Q = Q_factor(a)\n    return 2.0 * Q / w\n\ndef g_vec(a: float) -> np.ndarray:\n    return np.array([omega_hat(a), tau_hat(a)])\n\ndef chi2(a: float, ybar: np.ndarray, inv_cov: np.ndarray) -> float:\n    # Enforce bounds inside minimization; if outside (0,1), penalize\n    if not (0.0  a  1.0):\n        return 1e9 + (a - 0.5)**2\n    r = ybar - g_vec(a)\n    return float(r.T @ inv_cov @ r)\n\ndef numerical_J(a: float, h: float = 1e-6) -> np.ndarray:\n    # Central finite differences for derivatives of omega_hat and tau_hat wrt a\n    ap = min(a + h, 1.0 - 1e-9)\n    am = max(a - h, 1e-9)\n    gp = g_vec(ap)\n    gm = g_vec(am)\n    return (gp - gm) / (ap - am)\n\ndef infer_ringdown_posterior(ybar: np.ndarray, sigmas: np.ndarray) -> tuple[float, float]:\n    # ybar = [omega_hat_mean, tau_hat_mean]; sigmas = [sigma_omega, sigma_tau]\n    cov = np.diag(sigmas**2)\n    inv_cov = np.diag(1.0 / (sigmas**2))\n    # Minimize chi^2 over a in (0,1)\n    res = minimize_scalar(lambda a: chi2(a, ybar, inv_cov), bounds=(0.0, 1.0), method='bounded')\n    a_hat = float(res.x)\n    # Fisher information for variance\n    J = numerical_J(a_hat)\n    F = float(J.T @ inv_cov @ J)\n    # Guard against numerical issues\n    if F = 0.0 or not np.isfinite(F):\n        # Fall back to a small variance to avoid division by zero; but keep finite\n        var = 1e6\n    else:\n        var = 1.0 / F\n    return a_hat, var\n\ndef gaussian_evidence_consistent(muI: float, sigI: float, muR: float, sigR: float, mu0: float, sig0: float) -> float:\n    # Z_c = (1/((2π) σI σR σ0)) * (1/sqrt(Λ)) * exp(-0.5*(c - b^2/Λ))\n    sigI2, sigR2, sig02 = sigI**2, sigR**2, sig0**2\n    lamI = 1.0 / sigI2\n    lamR = 1.0 / sigR2\n    lam0 = 1.0 / sig02\n    Lam = lamI + lamR + lam0\n    b = lamI * muI + lamR * muR + lam0 * mu0\n    c = lamI * muI**2 + lamR * muR**2 + lam0 * mu0**2\n    \n    # This is not Z_c, but Z_c multiplied by all the normalization constants.\n    # We can use the formula for the integral of product of Gaussians directly.\n    # The integral of N(x;μ1,σ1^2)N(x;μ2,σ2^2) is N(μ1;μ2,σ1^2+σ2^2)\n    # And integral of N(x;μ1,σ1^2)N(x;μ2,σ2^2)N(x;μ3,σ3^2) gives something more complex\n    \n    # Let's re-derive Zc more carefully.\n    # Integral[ N(x|m1,s1)N(x|m2,s2)N(x|m3,s3) ] dx\n    # The product of the three Gaussians is a new Gaussian (unnormalized)\n    # exp( -0.5 * [ (x-m1)^2/s1^2 + (x-m2)^2/s2^2 + (x-m3)^2/s3^2 ] )\n    # The new precision is Lam = 1/s1^2 + 1/s2^2 + 1/s3^2. New variance s_post^2 = 1/Lam\n    # The new mean is m_post = s_post^2 * (m1/s1^2 + m2/s2^2 + m3/s3^2)\n    # Product is C * N(x | m_post, s_post^2)\n    # C = N(m1; m2, s1^2+s2^2) * N(0; m_post_12, s_post_12^2+s3^2) ?? No, that's for convolutions.\n    # C = exp(-0.5 * [ m1^2/s1^2 + m2^2/s2^2 - m_post_12^2/s_post_12^2 ]) / (2pi s1 s2)\n    # Let's use a known identity:\n    # N(x|a,A)N(x|b,B) = N(a|b, A+B) N(x|c, C) where C=(A^-1+B^-1)^-1, c=C(A^-1a+B^-1b)\n    \n    # Z_c = Integral[ N(a|μI,σI^2) N(a|μR,σR^2) N(a|μ0,σ0^2) ] da\n    #     = Integral[ N(μI|μR,σI^2+σR^2) N(a|μ_IR, σ_IR^2) N(a|μ0,σ0^2) ] da\n    # where σ_IR^2 = (1/σI^2+1/σR^2)^-1, μ_IR = σ_IR^2(μI/σI^2+μR/σR^2)\n    #     = N(μI|μR, σI^2+σR^2) * Integral[ N(a|μ_IR,σ_IR^2) N(a|μ0,σ0^2) ] da\n    #     = N(μI|μR, σI^2+σR^2) * N(μ_IR|μ0, σ_IR^2+σ0^2)\n    \n    # Let's verify this identity.\n    # This is correct.\n    \n    sI2, sR2, s02 = sigI**2, sigR**2, sig0**2\n    \n    s_IR2 = 1.0 / (1.0/sI2 + 1.0/sR2)\n    mu_IR = s_IR2 * (muI/sI2 + muR/sR2)\n    \n    norm_const_1 = 1.0 / np.sqrt(2 * np.pi * (sI2 + sR2))\n    exp_1 = np.exp(-0.5 * (muI - muR)**2 / (sI2 + sR2))\n    N1 = norm_const_1 * exp_1\n    \n    norm_const_2 = 1.0 / np.sqrt(2 * np.pi * (s_IR2 + s02))\n    exp_2 = np.exp(-0.5 * (mu_IR - mu0)**2 / (s_IR2 + s02))\n    N2 = norm_const_2 * exp_2\n    \n    return N1 * N2\n\ndef gaussian_evidence_inconsistent(muI: float, sigI: float, muR: float, sigR: float, mu0: float, sig0: float) -> float:\n    # Z_i = Integral[N(aI|μI,σI^2)N(aI|μ0,σ0^2)]daI * Integral[N(aR|μR,σR^2)N(aR|μ0,σ0^2)]daR\n    # Integral[N(x|μ1,s1^2)N(x|μ2,s2^2)]dx = N(μ1|μ2, s1^2+s2^2)\n    \n    sI2, sR2, s02 = sigI**2, sigR**2, sig0**2\n\n    s_I0_2 = sI2 + s02\n    termI = (1.0 / np.sqrt(2 * np.pi * s_I0_2)) * np.exp(-0.5 * (muI-mu0)**2 / s_I0_2)\n    \n    s_R0_2 = sR2 + s02\n    termR = (1.0 / np.sqrt(2 * np.pi * s_R0_2)) * np.exp(-0.5 * (muR-mu0)**2 / s_R0_2)\n    \n    return termI * termR\n\ndef bayes_factor(muI: float, sigI: float, muR: float, sigR: float, mu0: float, sig0: float) -> float:\n    Zc = gaussian_evidence_consistent(muI, sigI, muR, sigR, mu0, sig0)\n    Zi = gaussian_evidence_inconsistent(muI, sigI, muR, sigR, mu0, sig0)\n    if Zi == 0.0 or not np.isfinite(Zi):\n        return float('inf')\n    return Zc / Zi\n\ndef solve():\n    mu0 = 0.7\n    sig0 = 0.3\n\n    test_cases = [\n        (0.25, 0.0, 0.248, 0.004, 0.003, 0.2),   # Test 1\n        (0.20, 0.10, 0.202, 0.004, 0.003, 0.2),  # Test 2\n        (0.24, 0.0, 0.235, 0.020, 0.001, 0.05),  # Test 3\n    ]\n\n    results = []\n    for (eta_true, delta_a, eta_bar, sigma_eta, sigma_omega, sigma_tau) in test_cases:\n        a_true = final_spin_from_eta(eta_true)\n        a_rd = a_true + delta_a\n        ybar = np.array([omega_hat(a_rd), tau_hat(a_rd)])\n        sigmas = np.array([sigma_omega, sigma_tau])\n\n        mu_I = final_spin_from_eta(eta_bar)\n        dade = da_deta(eta_bar)\n        sig_I = abs(dade) * sigma_eta\n        sig_I = max(sig_I, 1e-9)\n\n        mu_R, var_R = infer_ringdown_posterior(ybar, sigmas)\n        sig_R = np.sqrt(max(var_R, 1e-18))\n\n        K = bayes_factor(mu_I, sig_I, mu_R, sig_R, mu0, sig0)\n        results.append(K)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3488813"}, {"introduction": "我们如何寻找未知的广义相对论破缺？一种强大的方法是分析数据的“残差”——即从观测数据中减去最佳GR模型后剩下的部分。本练习将带你深入了解这种检验的统计核心，你将学习如何计算发现显著残差的统计显著性（p-value），并掌握处理“别处张望效应”（look-elsewhere effect）这一在所有前沿搜索中都至关重要的问题。[@problem_id:3488777]", "problem": "分析一个来自双黑洞并合的引力波事件，旨在使用残差功率诊断方法在并合阶段检验广义相对论（GR）。设单个探测器中的应变数据模型为 $d(t) = h_{\\mathrm{GR}}(t;\\hat{\\theta}) + n(t)$，其中 $h_{\\mathrm{GR}}(t;\\hat{\\theta})$ 是在最大似然参数 $\\hat{\\theta}$ 下的最佳拟合GR波形，而 $n(t)$ 是一个零均值、高斯、平稳的噪声过程，其特征由单边功率谱密度（PSD）$S_{n}(f)$ 描述。定义两个时间序列 $a(t)$ 和 $b(t)$ 之间的噪声加权内积为\n$$\n(a|b) \\equiv 4 \\,\\Re \\int_{0}^{\\infty} \\frac{\\tilde{a}(f)\\,\\tilde{b}^{*}(f)}{S_{n}(f)}\\,\\mathrm{d}f,\n$$\n其中 $\\tilde{a}(f)$ 表示 $a(t)$ 的傅里叶变换，而 $^{*}$ 表示复共轭。残差为 $r(t) \\equiv d(t) - h_{\\mathrm{GR}}(t;\\hat{\\theta})$。\n\n在GR是正确的且模型 $h_{\\mathrm{GR}}$ 捕捉到真实信号的原假设下，$r(t)$ 服从高斯噪声分布。考虑一个狭窄的并合时频窗口 $\\mathcal{W}$，当使用上述内积进行投影时，该窗口包含 $k$ 个有效独立、标准正交、方差为单位的白化基分量。在此窗口中，残差功率统计量为\n$$\n\\rho \\equiv (r|r)_{\\mathcal{W}},\n$$\n在原假设下，该统计量服从自由度为 $k$ 的卡方随机变量分布，记为 $\\chi^{2}_{k}$。\n\n假设构造的并合窗口 $\\mathcal{W}$ 包含 $k=4$ 个有效独立自由度（例如，两个独立的傅里葉频段，每个频段在白化后具有两个正交分量）。在这样一个窗口中，观测值为 $\\rho_{\\mathrm{obs}}=20$。此超额的局域显著性由原假设下的上尾概率 $p_{\\mathrm{local}}=\\mathbb{P}(\\chi^{2}_{k} \\ge \\rho_{\\mathrm{obs}})$ 来量化。\n\n通过扫描 $M=50$ 个具有相同构造的不相交并合子窗口来进行“别处张望”研究，每个子窗口都会产生一个独立的 $\\rho$ 实现。相对于原假设的全局显著性定义为：在原假设下，$M$ 个窗口中至少有一个产生超过 $\\rho_{\\mathrm{obs}}$ 的值的概率。\n\n仅从上述定义以及高斯随机变量和卡方分布的标准性质出发，完成以下任务：\n\n1. 对于 $k=4$ 的情况，推導 $p_{\\mathrm{local}}$ 关于 $\\rho_{\\mathrm{obs}}$ 的显式表达式。\n2. 利用窗口间的独立性，推導全局p值 $p_{\\mathrm{global}}$ 关于 $p_{\\mathrm{local}}$ 和 $M$ 的显式表达式。\n3. 对于 $\\rho_{\\mathrm{obs}}=20$, $k=4$ 和 $M=50$，数值计算 $p_{\\mathrm{global}}$。\n\n将最终答案表示为等于 $p_{\\mathrm{global}}$ 的一个十进制数，四捨五入到三位有效数字。最终答案中不要包含任何单位。", "solution": "用户希望我解决一个与引力波数据统计分析相关的问题。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n*   应变数据模型：$d(t) = h_{\\mathrm{GR}}(t;\\hat{\\theta}) + n(t)$。\n*   $h_{\\mathrm{GR}}(t;\\hat{\\theta})$ 是最佳拟合广义相对论(GR)波形。\n*   $n(t)$ 是零均值、高斯、平稳噪声，具有单边功率谱密度(PSD) $S_{n}(f)$。\n*   噪声加权内积：$(a|b) \\equiv 4 \\,\\Re \\int_{0}^{\\infty} \\frac{\\tilde{a}(f)\\,\\tilde{b}^{*}(f)}{S_{n}(f)}\\,\\mathrm{d}f$。\n*   残差：$r(t) \\equiv d(t) - h_{\\mathrm{GR}}(t;\\hat{\\theta})$。\n*   原假设：$r(t)$ 服从高斯噪声分布。\n*   残差功率统计量：$\\rho \\equiv (r|r)_{\\mathcal{W}}$。\n*   在原假设下，$\\rho$ 服从自由度为 $k$ 的卡方随机变量 $\\chi^{2}_{k}$ 分布。\n*   并合窗口中的自由度数量：$k=4$。\n*   观测到的残差功率：$\\rho_{\\mathrm{obs}}=20$。\n*   局域p值的定义：$p_{\\mathrm{local}}=\\mathbb{P}(\\chi^{2}_{k} \\ge \\rho_{\\mathrm{obs}})$。\n*   用于“别处张望”研究的不相交、独立子窗口的数量：$M=50$。\n*   全局p值的定义：$M$ 个窗口中至少有一个产生超过 $\\rho_{\\mathrm{obs}}$ 的值的概率。\n\n**步骤2：使用提取的已知条件进行验证**\n\n问题陈述具有科学依据，提法明確且客观。它描述了引力波数据分析中的一个标准程序，用于检验观测数据与广义相对论预测的一致性。其统计框架（卡方检验、p值、“别处张望”效应）表述正确。所有定义和数值均已提供，无矛盾之处，并且在问题背景下是物理上合理的。该问题沒有违反任何指定的无效性标准。\n\n**步骤3：结论与行动**\n\n问题有效。将提供完整解答。\n\n### 解答\n\n根据问题陈述的要求，解答分为三个部分。\n\n**1. 推导 $p_{\\mathrm{local}}$ 的显式表达式**\n\n局域p值 $p_{\\mathrm{local}}$ 是在原假设下观测到残差功率大于或等于 $\\rho_{\\mathrm{obs}}$ 的概率。问题陈述指出，统计量 $\\rho$ 服从自由度为 $k$ 的卡方分布，记为 $\\chi^2_k$。因此，我们有：\n$$\np_{\\mathrm{local}} = \\mathbb{P}(\\chi^{2}_{k} \\ge \\rho_{\\mathrm{obs}})\n$$\n一个 $\\chi^2_k$ 随机变量 $x$ 的概率密度函数（PDF）由以下公式给出：\n$$\nf(x; k) = \\frac{1}{2^{k/2} \\Gamma(k/2)} x^{k/2 - 1} \\exp\\left(-\\frac{x}{2}\\right)\n$$\n其中 $\\Gamma(z)$ 是伽马函数。对于本问题，给定 $k=4$。伽马函数的值为 $\\Gamma(k/2) = \\Gamma(4/2) = \\Gamma(2) = (2-1)! = 1! = 1$。\n将 $k=4$ 代入PDF，我们得到：\n$$\nf(x; 4) = \\frac{1}{2^{4/2} \\Gamma(2)} x^{4/2 - 1} \\exp\\left(-\\frac{x}{2}\\right) = \\frac{1}{4 \\cdot 1} x^{1} \\exp\\left(-\\frac{x}{2}\\right) = \\frac{1}{4} x \\exp\\left(-\\frac{x}{2}\\right)\n$$\n局域p值是此PDF从 $\\rho_{\\mathrm{obs}}$ 到无穷大的积分：\n$$\np_{\\mathrm{local}} = \\int_{\\rho_{\\mathrm{obs}}}^{\\infty} f(x; 4) \\, \\mathrm{d}x = \\int_{\\rho_{\\mathrm{obs}}}^{\\infty} \\frac{1}{4} x \\exp\\left(-\\frac{x}{2}\\right) \\, \\mathrm{d}x\n$$\n我们使用分部积分法 $\\int u \\, \\mathrm{d}v = uv - \\int v \\, \\mathrm{d}u$ 来求解此积分。令 $u = x$ 且 $\\mathrm{d}v = \\exp(-x/2) \\, \\mathrm{d}x$。则 $\\mathrm{d}u = \\mathrm{d}x$ 且 $v = -2 \\exp(-x/2)$。\n$$\n\\int x \\exp\\left(-\\frac{x}{2}\\right) \\, \\mathrm{d}x = x \\left(-2 \\exp\\left(-\\frac{x}{2}\\right)\\right) - \\int \\left(-2 \\exp\\left(-\\frac{x}{2}\\right)\\right) \\, \\mathrm{d}x\n$$\n$$\n= -2x \\exp\\left(-\\frac{x}{2}\\right) + 2 \\int \\exp\\left(-\\frac{x}{2}\\right) \\, \\mathrm{d}x = -2x \\exp\\left(-\\frac{x}{2}\\right) - 4 \\exp\\left(-\\frac{x}{2}\\right) = -2(x+2) \\exp\\left(-\\frac{x}{2}\\right)\n$$\n现在我们计算 $p_{\\mathrm{local}}$ 的定积分：\n$$\np_{\\mathrm{local}} = \\frac{1}{4} \\left[ -2(x+2) \\exp\\left(-\\frac{x}{2}\\right) \\right]_{\\rho_{\\mathrm{obs}}}^{\\infty}\n$$\n积分上限的计算结果为 $0$，因为 $\\lim_{x \\to \\infty} (x+2) \\exp(-x/2) = 0$。\n$$\np_{\\mathrm{local}} = \\frac{1}{4} \\left( 0 - \\left[-2(\\rho_{\\mathrm{obs}}+2) \\exp\\left(-\\frac{\\rho_{\\mathrm{obs}}}{2}\\right)\\right] \\right) = \\frac{2(\\rho_{\\mathrm{obs}}+2)}{4} \\exp\\left(-\\frac{\\rho_{\\mathrm{obs}}}{2}\\right)\n$$\n对于 $k=4$，$p_{\\mathrm{local}}$ 的显式表达式为：\n$$\np_{\\mathrm{local}} = \\left(1 + \\frac{\\rho_{\\mathrm{obs}}}{2}\\right) \\exp\\left(-\\frac{\\rho_{\\mathrm{obs}}}{2}\\right)\n$$\n\n**2. 推导 $p_{\\mathrm{global}}$ 的显式表达式**\n\n全局p值 $p_{\\mathrm{global}}$ 是 $M$ 个独立窗口中至少有一个产生超过 $\\rho_{\\mathrm{obs}}$ 的 $\\rho$ 值的概率。设 $E_i$ 为第 $i$ 个窗口的残差功率 $\\rho_i \\ge \\rho_{\\mathrm{obs}}$ 的事件。在原假设下，任何单个窗口发生此事件的概率为 $p_{\\mathrm{local}}$：\n$$\n\\mathbb{P}(E_i) = p_{\\mathrm{local}} \\quad \\text{for } i=1, \\dots, M\n$$\n我们希望找到这些事件的并集的概率：\n$$\np_{\\mathrm{global}} = \\mathbb{P}(E_1 \\cup E_2 \\cup \\dots \\cup E_M)\n$$\n计算其互补事件的概率更简单：即所有窗口都未显示超额。这是互补事件 $E_i^c$ 的交集，其中 $\\mathbb{P}(E_i^c) = 1 - p_{\\mathrm{local}}$。\n$$\n1 - p_{\\mathrm{global}} = \\mathbb{P}(E_1^c \\cap E_2^c \\cap \\dots \\cap E_M^c)\n$$\n由于陈述中说明 $M$ 个窗口是独立的，交集的概率是各个概率的乘积：\n$$\n1 - p_{\\mathrm{global}} = \\prod_{i=1}^{M} \\mathbb{P}(E_i^c) = \\prod_{i=1}^{M} (1 - p_{\\mathrm{local}}) = (1 - p_{\\mathrm{local}})^M\n$$\n因此，全局p值的显式表达式为：\n$$\np_{\\mathrm{global}} = 1 - (1 - p_{\\mathrm{local}})^M\n$$\n\n**3. $p_{\\mathrm{global}}$ 的数值计算**\n\n我们已知数值 $\\rho_{\\mathrm{obs}}=20$，$k=4$ 和 $M=50$。\n首先，我们使用第1部分推导的表达式计算 $p_{\\mathrm{local}}$：\n$$\np_{\\mathrm{local}} = \\left(1 + \\frac{20}{2}\\right) \\exp\\left(-\\frac{20}{2}\\right) = (1+10) \\exp(-10) = 11 \\exp(-10)\n$$\n现在，我们将此结果代入第2部分中 $p_{\\mathrm{global}}$ 的表达式，并取 $M=50$：\n$$\np_{\\mathrm{global}} = 1 - (1 - 11 \\exp(-10))^{50}\n$$\n我们现在对这个表达式进行数值计算。\n$$\n\\exp(-10) \\approx 4.539992976 \\times 10^{-5}\n$$\n$$\np_{\\mathrm{local}} = 11 \\times \\exp(-10) \\approx 11 \\times 4.539992976 \\times 10^{-5} \\approx 4.99399227 \\times 10^{-4}\n$$\n$$\n1 - p_{\\mathrm{local}} \\approx 1 - 4.99399227 \\times 10^{-4} \\approx 0.99950060077\n$$\n$$\n(1 - p_{\\mathrm{local}})^{50} \\approx (0.99950060077)^{50} \\approx 0.9753303603\n$$\n$$\np_{\\mathrm{global}} = 1 - (1 - p_{\\mathrm{local}})^{50} \\approx 1 - 0.9753303603 \\approx 0.0246696397\n$$\n将最终结果四舍五入到三位有效数字，我们得到 $0.0247$。", "answer": "$$\\boxed{0.0247}$$", "id": "3488777"}]}